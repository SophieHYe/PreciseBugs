{"buggy_code": ["/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/core/data/dataset_utils.h\"\n#include \"tensorflow/core/data/root_dataset.h\"\n#include \"tensorflow/core/framework/dataset.h\"\n#include \"tensorflow/core/framework/function_handle_cache.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include \"tensorflow/core/kernels/ops_util.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/lib/io/record_writer.h\"\n#include \"tensorflow/core/platform/file_system.h\"\n#include \"tensorflow/core/platform/resource.h\"\n\nnamespace tensorflow {\nnamespace data {\nnamespace experimental {\nnamespace {\n\nclass ToTFRecordOp : public AsyncOpKernel {\n public:\n  explicit ToTFRecordOp(OpKernelConstruction* ctx)\n      : AsyncOpKernel(ctx),\n        background_worker_(ctx->env(), \"tf_data_to_tf_record\") {}\n\n  template <typename T>\n  Status ParseScalarArgument(OpKernelContext* ctx,\n                             const StringPiece& argument_name, T* output) {\n    const Tensor* argument_t;\n    TF_RETURN_IF_ERROR(ctx->input(argument_name, &argument_t));\n    if (!TensorShapeUtils::IsScalar(argument_t->shape())) {\n      return errors::InvalidArgument(argument_name, \" must be a scalar\");\n    }\n    *output = argument_t->scalar<T>()();\n    return Status::OK();\n  }\n\n  void ComputeAsync(OpKernelContext* ctx, DoneCallback done) override {\n    // The call to `iterator->GetNext()` may block and depend on an inter-op\n    // thread pool thread, so we issue the call using a background thread.\n    background_worker_.Schedule([this, ctx, done = std::move(done)]() {\n      OP_REQUIRES_OK_ASYNC(ctx, DoCompute(ctx), done);\n      done();\n    });\n  }\n\n private:\n  Status DoCompute(OpKernelContext* ctx) {\n    tensorflow::ResourceTagger tag(kTFDataResourceTag,\n                                   ctx->op_kernel().type_string());\n    tstring filename;\n    TF_RETURN_IF_ERROR(\n        ParseScalarArgument<tstring>(ctx, \"filename\", &filename));\n    tstring compression_type;\n    TF_RETURN_IF_ERROR(ParseScalarArgument<tstring>(ctx, \"compression_type\",\n                                                    &compression_type));\n    std::unique_ptr<WritableFile> file;\n    TF_RETURN_IF_ERROR(ctx->env()->NewWritableFile(filename, &file));\n    auto writer = absl::make_unique<io::RecordWriter>(\n        file.get(),\n        io::RecordWriterOptions::CreateRecordWriterOptions(compression_type));\n\n    DatasetBase* dataset;\n    TF_RETURN_IF_ERROR(GetDatasetFromVariantTensor(ctx->input(0), &dataset));\n\n    IteratorContext::Params params(ctx);\n    FunctionHandleCache function_handle_cache(params.flr);\n    params.function_handle_cache = &function_handle_cache;\n    ResourceMgr resource_mgr;\n    params.resource_mgr = &resource_mgr;\n    CancellationManager cancellation_manager(ctx->cancellation_manager());\n    params.cancellation_manager = &cancellation_manager;\n\n    IteratorContext iter_ctx(std::move(params));\n    DatasetBase* finalized_dataset;\n    TF_RETURN_IF_ERROR(FinalizeDataset(ctx, dataset, &finalized_dataset));\n\n    std::unique_ptr<IteratorBase> iterator;\n    TF_RETURN_IF_ERROR(finalized_dataset->MakeIterator(\n        &iter_ctx, /*parent=*/nullptr, \"ToTFRecordOpIterator\", &iterator));\n\n    std::vector<Tensor> components;\n    components.reserve(finalized_dataset->output_dtypes().size());\n    bool end_of_sequence;\n    do {\n      TF_RETURN_IF_ERROR(\n          iterator->GetNext(&iter_ctx, &components, &end_of_sequence));\n\n      if (!end_of_sequence) {\n        TF_RETURN_IF_ERROR(\n            writer->WriteRecord(components[0].scalar<tstring>()()));\n      }\n      components.clear();\n    } while (!end_of_sequence);\n    return Status::OK();\n  }\n\n  BackgroundWorker background_worker_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"DatasetToTFRecord\").Device(DEVICE_CPU),\n                        ToTFRecordOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"ExperimentalDatasetToTFRecord\").Device(DEVICE_CPU), ToTFRecordOp);\n\n}  // namespace\n}  // namespace experimental\n}  // namespace data\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/core/data/dataset_utils.h\"\n#include \"tensorflow/core/data/root_dataset.h\"\n#include \"tensorflow/core/framework/dataset.h\"\n#include \"tensorflow/core/framework/function_handle_cache.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/ops_util.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/lib/io/record_writer.h\"\n#include \"tensorflow/core/platform/file_system.h\"\n#include \"tensorflow/core/platform/resource.h\"\n\nnamespace tensorflow {\nnamespace data {\nnamespace experimental {\nnamespace {\n\nclass ToTFRecordOp : public AsyncOpKernel {\n public:\n  explicit ToTFRecordOp(OpKernelConstruction* ctx)\n      : AsyncOpKernel(ctx),\n        background_worker_(ctx->env(), \"tf_data_to_tf_record\") {}\n\n  template <typename T>\n  Status ParseScalarArgument(OpKernelContext* ctx,\n                             const StringPiece& argument_name, T* output) {\n    const Tensor* argument_t;\n    TF_RETURN_IF_ERROR(ctx->input(argument_name, &argument_t));\n    if (!TensorShapeUtils::IsScalar(argument_t->shape())) {\n      return errors::InvalidArgument(argument_name, \" must be a scalar\");\n    }\n    *output = argument_t->scalar<T>()();\n    return Status::OK();\n  }\n\n  void ComputeAsync(OpKernelContext* ctx, DoneCallback done) override {\n    // The call to `iterator->GetNext()` may block and depend on an inter-op\n    // thread pool thread, so we issue the call using a background thread.\n    background_worker_.Schedule([this, ctx, done = std::move(done)]() {\n      OP_REQUIRES_OK_ASYNC(ctx, DoCompute(ctx), done);\n      done();\n    });\n  }\n\n private:\n  Status DoCompute(OpKernelContext* ctx) {\n    tensorflow::ResourceTagger tag(kTFDataResourceTag,\n                                   ctx->op_kernel().type_string());\n    tstring filename;\n    TF_RETURN_IF_ERROR(\n        ParseScalarArgument<tstring>(ctx, \"filename\", &filename));\n    tstring compression_type;\n    TF_RETURN_IF_ERROR(ParseScalarArgument<tstring>(ctx, \"compression_type\",\n                                                    &compression_type));\n    std::unique_ptr<WritableFile> file;\n    TF_RETURN_IF_ERROR(ctx->env()->NewWritableFile(filename, &file));\n    auto writer = absl::make_unique<io::RecordWriter>(\n        file.get(),\n        io::RecordWriterOptions::CreateRecordWriterOptions(compression_type));\n\n    DatasetBase* dataset;\n    TF_RETURN_IF_ERROR(GetDatasetFromVariantTensor(ctx->input(0), &dataset));\n\n    IteratorContext::Params params(ctx);\n    FunctionHandleCache function_handle_cache(params.flr);\n    params.function_handle_cache = &function_handle_cache;\n    ResourceMgr resource_mgr;\n    params.resource_mgr = &resource_mgr;\n    CancellationManager cancellation_manager(ctx->cancellation_manager());\n    params.cancellation_manager = &cancellation_manager;\n\n    IteratorContext iter_ctx(std::move(params));\n    DatasetBase* finalized_dataset;\n    TF_RETURN_IF_ERROR(FinalizeDataset(ctx, dataset, &finalized_dataset));\n\n    std::unique_ptr<IteratorBase> iterator;\n    TF_RETURN_IF_ERROR(finalized_dataset->MakeIterator(\n        &iter_ctx, /*parent=*/nullptr, \"ToTFRecordOpIterator\", &iterator));\n\n    const int num_output_dtypes = finalized_dataset->output_dtypes().size();\n    if (num_output_dtypes != 1) {\n      return errors::InvalidArgument(\n          \"ToTFRecordOp currently only support datasets of 1 single column, \",\n          \"but got \", num_output_dtypes);\n    }\n    const DataType dt = finalized_dataset->output_dtypes()[0];\n    if (dt != DT_STRING) {\n      return errors::InvalidArgument(\n          \"ToTFRecordOp currently only supports DT_STRING dataypes, but got \",\n          DataTypeString(dt));\n    }\n    std::vector<Tensor> components;\n    components.reserve(num_output_dtypes);\n    bool end_of_sequence;\n    do {\n      TF_RETURN_IF_ERROR(\n          iterator->GetNext(&iter_ctx, &components, &end_of_sequence));\n\n      if (!end_of_sequence) {\n        TF_RETURN_IF_ERROR(\n            writer->WriteRecord(components[0].scalar<tstring>()()));\n      }\n      components.clear();\n    } while (!end_of_sequence);\n    return Status::OK();\n  }\n\n  BackgroundWorker background_worker_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"DatasetToTFRecord\").Device(DEVICE_CPU),\n                        ToTFRecordOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"ExperimentalDatasetToTFRecord\").Device(DEVICE_CPU), ToTFRecordOp);\n\n}  // namespace\n}  // namespace experimental\n}  // namespace data\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/data/experimental/to_tf_record_op.cc"], "buggy_code_start_loc": [20], "buggy_code_end_loc": [96], "fixing_code_start_loc": [21], "fixing_code_end_loc": [109], "type": "CWE-787", "message": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.ExperimentalDatasetToTFRecord` and `tf.raw_ops.DatasetToTFRecord` can trigger heap buffer overflow and segmentation fault. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/to_tf_record_op.cc#L93-L102) assumes that all records in the dataset are of string type. However, there is no check for that, and the example given above uses numeric types. We have patched the issue in GitHub commit e0b6e58c328059829c3eb968136f17aa72b6c876. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-37650", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-12T21:15:08.077", "lastModified": "2021-08-18T15:34:41.093", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.ExperimentalDatasetToTFRecord` and `tf.raw_ops.DatasetToTFRecord` can trigger heap buffer overflow and segmentation fault. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/to_tf_record_op.cc#L93-L102) assumes that all records in the dataset are of string type. However, there is no check for that, and the example given above uses numeric types. We have patched the issue in GitHub commit e0b6e58c328059829c3eb968136f17aa72b6c876. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico. En las versiones afectadas, la implementaci\u00f3n para \"tf.raw_ops.ExperimentalDatasetToTFRecord\" y \"tf.raw_ops.DatasetToTFRecord\" puede desencadenar un desbordamiento del buffer de la pila y un fallo de segmentaci\u00f3n. La [implementaci\u00f3n](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/to_tf_record_op.cc#L93-L102) asume que todos los registros del conjunto de datos son de tipo cadena. Sin embargo, no hay ninguna comprobaci\u00f3n al respecto, y el ejemplo anterior usa tipos num\u00e9ricos. Hemos parcheado el problema en el commit e0b6e58c328059829c3eb968136f17aa72b6c876 de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.6.0. Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.5.1, TensorFlow versi\u00f3n 2.4.3, y TensorFlow versi\u00f3n 2.3.4, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango de soporte."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.4", "matchCriteriaId": "0F83C081-51CC-415F-A8C0-0A44C75E2CD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.3", "matchCriteriaId": "BD3F2BF8-EBA9-42BF-8F9B-D918B880B15A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "D03E99A7-4E3D-427D-A156-C0713E9FB02A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "70FA6E48-6C57-40CA-809F-4E3D07CBF348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "42187561-E491-434D-828C-F36701446634"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C66B61C8-450A-4C5E-9174-F970D6DEE778"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/e0b6e58c328059829c3eb968136f17aa72b6c876", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-f8h4-7rgh-q2gm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/e0b6e58c328059829c3eb968136f17aa72b6c876"}}