{"buggy_code": ["Express Handlebars\n==================\n\nA [Handlebars][] view engine for [Express][] which doesn't suck.\n\n[![npm version][npm-badge]][npm]\n[![dependency status][dep-badge]][dep-status]\n\n**This package used to be named `express3-handlebars`. The previous `express-handlebars` package by @jneen can be found [here][jneen-exphbs].**\n\n\n[Express]: https://github.com/expressjs/express\n[Handlebars]: https://github.com/handlebars-lang/handlebars.js\n[npm]: https://www.npmjs.org/package/express-handlebars\n[npm-badge]: https://img.shields.io/npm/v/express-handlebars.svg?style=flat-square\n[dep-status]: https://david-dm.org/express-handlebars/express-handlebars\n[dep-badge]: https://img.shields.io/david/express-handlebars/express-handlebars.svg?style=flat-square\n[jneen-exphbs]: https://github.com/jneen/express-handlebars\n\n\n## Goals & Design\n\nI created this project out of frustration with the existing Handlebars view engines for Express. As of version 3.x, Express got out of the business of being a generic view engine \u2014 this was a great decision \u2014 leaving developers to implement the concepts of layouts, partials, and doing file I/O for their template engines of choice.\n\n### Goals and Features\n\nAfter building a half-dozen Express apps, I developed requirements and opinions about what a Handlebars view engine should provide and how it should be implemented. The following is that list:\n\n* Add back the concept of \"layout\", which was removed in Express 3.x.\n\n* Add back the concept of \"partials\" via Handlebars' partials mechanism.\n\n* Support a directory of partials; e.g., `{{> foo/bar}}` which exists on the file system at `views/partials/foo/bar.handlebars`, by default.\n\n* Smart file system I/O and template caching. When in development, templates are always loaded from disk. In production, raw files and compiled templates are cached, including partials.\n\n* All async and non-blocking. File system I/O is slow and servers should not be blocked from handling requests while reading from disk. I/O queuing is used to avoid doing unnecessary work.\n\n* Ability to easily precompile templates and partials for use on the client, enabling template sharing and reuse.\n\n* Ability to use a different Handlebars module/implementation other than the Handlebars npm package.\n\n### Package Design\n\nThis package was designed to work great for both the simple and complex use cases. I _intentionally_ made sure the full implementation is exposed and is easily overridable.\n\nThe package exports a function which can be invoked with no arguments or with a `config` object and it will return a function (closed over sensible defaults) which can be registered with an Express app. It's an engine factory function.\n\nThis exported engine factory has two properties which expose the underlying implementation:\n\n* `ExpressHandlebars()`: The constructor function which holds the internal implementation on its `prototype`. This produces instance objects which store their configuration, `compiled` and `precompiled` templates, and expose an `engine()` function which can be registered with an Express app.\n\n* `create()`: A convenience factory function for creating `ExpressHandlebars` instances.\n\nAn instance-based approach is used so that multiple `ExpressHandlebars` instances can be created with their own configuration, templates, partials, and helpers.\n\n\n## Installation\n\nInstall using npm:\n\n```shell\n$ npm install express-handlebars\n```\n\n\n## Usage\n\nThis view engine uses sensible defaults that leverage the \"Express-way\" of structuring an app's views. This makes it trivial to use in basic apps:\n\n### Basic Usage\n\n**Directory Structure:**\n\n```\n.\n\u251c\u2500\u2500 app.js\n\u2514\u2500\u2500 views\n    \u251c\u2500\u2500 home.handlebars\n    \u2514\u2500\u2500 layouts\n        \u2514\u2500\u2500 main.handlebars\n\n2 directories, 3 files\n```\n\n**app.js:**\n\nCreates a super simple Express app which shows the basic way to register a Handlebars view engine using this package.\n\n```javascript\nvar express = require('express');\nvar exphbs  = require('express-handlebars');\n\nvar app = express();\n\napp.engine('handlebars', exphbs());\napp.set('view engine', 'handlebars');\n\napp.get('/', function (req, res) {\n    res.render('home');\n});\n\napp.listen(3000);\n```\n\n**views/layouts/main.handlebars:**\n\nThe main layout is the HTML page wrapper which can be reused for the different views of the app. `{{{body}}}` is used as a placeholder for where the main content should be rendered.\n\n```handlebars\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>Example App</title>\n</head>\n<body>\n\n    {{{body}}}\n\n</body>\n</html>\n```\n\n**views/home.handlebars:**\n\nThe content for the app's home view which will be rendered into the layout's `{{{body}}}`.\n\n```handlebars\n<h1>Example App: Home</h1>\n```\n\n#### Running the Example\n\nThe above example is bundled in this package's [examples directory][], where it can be run by:\n\n```shell\n$ cd examples/basic/\n$ npm install\n$ npm start\n```\n\n### Using Instances\n\nAnother way to use this view engine is to create an instance(s) of `ExpressHandlebars`, allowing access to the full API:\n\n```javascript\nvar express = require('express');\nvar exphbs  = require('express-handlebars');\n\nvar app = express();\nvar hbs = exphbs.create({ /* config */ });\n\n// Register `hbs.engine` with the Express app.\napp.engine('handlebars', hbs.engine);\napp.set('view engine', 'handlebars');\n\n// ...still have a reference to `hbs`, on which methods like `getPartials()`\n// can be called.\n```\n\n**Note:** The [Advanced Usage][] example demonstrates how `ExpressHandlebars` instances can be leveraged.\n\n### Template Caching\n\nThis view engine uses a smart template caching strategy. In development, templates will always be loaded from disk, i.e., no caching. In production, raw files and compiled Handlebars templates are aggressively cached.\n\nThe easiest way to control template/view caching is through Express' [view cache setting][]:\n\n```javascript\napp.enable('view cache');\n```\n\nExpress enables this setting by default when in production mode, i.e.:\n\n```\nprocess.env.NODE_ENV === \"production\"\n```\n\n**Note:** All of the public API methods accept `options.cache`, which gives control over caching when calling these methods directly.\n\n### Layouts\n\nA layout is simply a Handlebars template with a `{{{body}}}` placeholder. Usually it will be an HTML page wrapper into which views will be rendered.\n\nThis view engine adds back the concept of \"layout\", which was removed in Express 3.x. It can be configured with a path to the layouts directory, by default it's set to relative to `express settings.view` + `layouts/`\n\nThere are two ways to set a default layout: configuring the view engine's `defaultLayout` property, or setting [Express locals][] `app.locals.layout`.\n\nThe layout into which a view should be rendered can be overridden per-request by assigning a different value to the `layout` request local. The following will render the \"home\" view with no layout:\n\n```javascript\napp.get('/', function (req, res, next) {\n    res.render('home', {layout: false});\n});\n```\n\n### Helpers\n\nHelper functions, or \"helpers\" are functions that can be [registered with Handlebars][] and can be called within a template. Helpers can be used for transforming output, iterating over data, etc. To keep with the spirit of *logic-less* templates, helpers are the place where logic should be defined.\n\nHandlebars ships with some [built-in helpers][], such as: `with`, `if`, `each`, etc. Most application will need to extend this set of helpers to include app-specific logic and transformations. Beyond defining global helpers on `Handlebars`, this view engine supports `ExpressHandlebars` instance-level helpers via the `helpers` configuration property, and render-level helpers via `options.helpers` when calling the `render()` and `renderView()` methods.\n\nThe following example shows helpers being specified at each level:\n\n**app.js:**\n\nCreates a super simple Express app which shows the basic way to register `ExpressHandlebars` instance-level helpers, and override one at the render-level.\n\n```javascript\nvar express = require('express');\nvar exphbs  = require('express-handlebars');\n\nvar app = express();\n\nvar hbs = exphbs.create({\n    // Specify helpers which are only registered on this instance.\n    helpers: {\n        foo: function () { return 'FOO!'; },\n        bar: function () { return 'BAR!'; }\n    }\n});\n\napp.engine('handlebars', hbs.engine);\napp.set('view engine', 'handlebars');\n\napp.get('/', function (req, res, next) {\n    res.render('home', {\n        showTitle: true,\n\n        // Override `foo` helper only for this rendering.\n        helpers: {\n            foo: function () { return 'foo.'; }\n        }\n    });\n});\n\napp.listen(3000);\n```\n\n**views/home.handlebars:**\n\nThe app's home view which uses helper functions to help render the contents.\n\n```handlebars\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>Example App - Home</title>\n</head>\n<body>\n\n    <!-- Uses built-in `if` helper. -->\n  {{#if showTitle}}\n    <h1>Home</h1>\n  {{/if}}\n\n    <!-- Calls `foo` helper, overridden at render-level. -->\n    <p>{{foo}}</p>\n\n    <!-- Calls `bar` helper, defined at instance-level. -->\n    <p>{{bar}}</p>\n\n</body>\n</html>\n```\n\n#### More on Helpers\n\nRefer to the [Handlebars website][] for more information on defining helpers:\n\n* [Expression Helpers][]\n* [Block Helpers][]\n\n### Metadata\n\nHandlebars has a data channel feature that propagates data through all scopes, including helpers and partials. Values in the data channel can be accessed via the `{{@variable}}` syntax. Express Handlebars provides metadata about a template it renders on a `{{@exphbs}}` object allowing access to things like the view name passed to `res.render()` via `{{@exphbs.view}}`.\n\nThe following is the list of metadata that's accessible on the `{{@exphbs}}` data object:\n\n* `cache`: Boolean whether or not the template is cached.\n* `encoding`: String name of encoding for files.\n* `view`: String name of the view passed to `res.render()`.\n* `layout`: String name of the layout view.\n* `data`: Original data object passed when rendering the template.\n* `helpers`: Collection of helpers used when rendering the template.\n* `partials`: Collection of partials used when rendering the template.\n* `runtimeOptions`: Runtime Options used to render the template.\n\n\n[examples directory]: https://github.com/express-handlebars/express-handlebars/tree/master/examples\n[view cache setting]: https://expressjs.com/en/api.html#app.settings.table\n[Express locals]: https://expressjs.com/en/api.html#app.locals\n[registered with Handlebars]: https://github.com/wycats/handlebars.js/#registering-helpers\n[built-in helpers]: https://handlebarsjs.com/guide/builtin-helpers.html\n[Handlebars website]: https://handlebarsjs.com/\n[Expression Helpers]: https://handlebarsjs.com/guide/#custom-helpers\n[Block Helpers]: https://handlebarsjs.com/guide/#block-helpers\n\n\n## API\n\n### Configuration and Defaults\n\nThere are two main ways to use this package: via its engine factory function, or creating `ExpressHandlebars` instances; both use the same configuration properties and defaults.\n\n```javascript\nvar exphbs = require('express-handlebars');\n\n// Using the engine factory:\nexphbs({ /* config */ });\n\n// Create an instance:\nexphbs.create({ /* config */ });\n```\n\nThe following is the list of configuration properties and their default values (if any):\n\n#### `handlebars=require('handlebars')`\nThe Handlebars module/implementation. This allows for the `ExpressHandlebars` instance to use a different Handlebars module/implementation than that provided by the Handlebars npm package.\n\n#### `extname=\".handlebars\"`\nThe string name of the file extension used by the templates. This value should correspond with the `extname` under which this view engine is registered with Express when calling `app.engine()`.\n\nThe following example sets up an Express app to use `.hbs` as the file extension for views:\n\n```javascript\nvar express = require('express');\nvar exphbs  = require('express-handlebars');\n\nvar app = express();\n\napp.engine('.hbs', exphbs({extname: '.hbs'}));\napp.set('view engine', '.hbs');\n```\n\n**Note:** Setting the app's `\"view engine\"` setting will make that value the default file extension used for looking up views.\n\n#### `encoding=\"utf8\"`\nDefault encoding when reading files.\n\n#### `layoutsDir`\nDefault layouts directory is relative to `express settings.view` + `layouts/`\nThe string path to the directory where the layout templates reside.\n\n**Note:** If you configure Express to look for views in a custom location (e.g., `app.set('views', 'some/path/')`), and if your `layoutsDir` is not relative to `express settings.view` + `layouts/`, you will need to reflect that by passing an updated path as the `layoutsDir` property in your configuration.\n\n#### `partialsDir`\nDefault partials directory is relative to `express settings.view` + `partials/`\nThe string path to the directory where the partials templates reside or object with the following properties:\n\n* `dir`: The string path to the directory where the partials templates reside.\n* `namespace`: Optional string namespace to prefix the partial names.\n* `templates`: Optional collection (or promise of a collection) of templates in the form: `{filename: template}`.\n* `rename(filePath, namespace)`: Optional function to rename the partials. Takes two arguments: `filePath`, e.g., `partials/some/path/template.handlebars` and `namespace`.\n\n**Note:** If you configure Express to look for views in a custom location (e.g., `app.set('views', 'some/path/')`), and if your `partialsDir` is not relative to `express settings.view` + `partials/`, you will need to reflect that by passing an updated path as the `partialsDir` property in your configuration.\n\n**Note:** Multiple partials dirs can be used by making `partialsDir` an array of strings, and/or config objects as described above. The namespacing feature is useful if multiple partials dirs are used and their file paths might clash.\n\n#### `defaultLayout`\nThe string name or path of a template in the `layoutsDir` to use as the default layout. `main` is used as the default. This is overridden by a `layout` specified in the app or response `locals`. **Note:** A falsy value will render without a layout; e.g., `res.render('home', {layout: false});`. You can also use a falsy value when creating the engine to make using no layout a default e.g. `app.engine('.hbs', exphbs({defaultLayout: false}));`.\n\n#### `helpers`\nAn object which holds the helper functions used when rendering templates with this `ExpressHandlebars` instance. When rendering a template, a collection of helpers will be generated by merging: `handlebars.helpers` (global), `helpers` (instance), and `options.helpers` (render-level). This allows Handlebars' `registerHelper()` function to operate as expected, will providing two extra levels over helper overrides.\n\n#### `compilerOptions`\nAn object which holds options that will be passed along to the Handlebars compiler functions: `Handlebars.compile()` and `Handlebars.precompile()`.\n\n#### `runtimeOptions`\nAn object which holds options that will be passed along to the template function in addition to the `data`, `helpers`, and `partials` options. See [Runtime Options][] for a list of available options.\n\n### Properties\n\nThe public API properties are provided via `ExpressHandlebars` instances. In additional to the properties listed in the **Configuration and Defaults** section, the following are additional public properties:\n\n#### `engine`\nA function reference to the `renderView()` method which is bound to `this` `ExpressHandlebars` instance. This bound function should be used when registering this view engine with an Express app.\n\n#### `extname`\nThe normalized `extname` which will _always_ start with `.` and defaults to `.handlebars`.\n\n#### `compiled`\nAn object cache which holds compiled Handlebars template functions in the format: `{\"path/to/template\": [Function]}`.\n\n#### `precompiled`\nAn object cache which holds precompiled Handlebars template strings in the format: `{\"path/to/template\": [String]}`.\n\n### Methods\n\nThe following is the list of public API methods provided via `ExpressHandlebars` instances:\n\n**Note:** All of the public methods return a [`Promise`][promise] (with the exception of `renderView()` which is the interface with Express.)\n\n#### `getPartials([options])`\nRetrieves the partials in the `partialsDir` and returns a Promise for an object mapping the partials in the form `{name: partial}`.\n\nBy default each partial will be a compiled Handlebars template function. Use `options.precompiled` to receive the partials as precompiled templates \u2014 this is useful for sharing templates with client code.\n\n**Parameters:**\n\n* `[options]`: Optional object containing any of the following properties:\n\n  * `[cache]`: Whether cached templates can be used if they have already been requested. This is recommended for production to avoid unnecessary file I/O.\n\n  * `[encoding]`: File encoding.\n\n  * `[precompiled=false]`: Whether precompiled templates should be provided, instead of compiled Handlebars template functions.\n\nThe name of each partial corresponds to its location in `partialsDir`. For example, consider the following directory structure:\n\n```\nviews\n\u2514\u2500\u2500 partials\n    \u251c\u2500\u2500 foo\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 bar.handlebars\n    \u2514\u2500\u2500 title.handlebars\n\n2 directories, 2 files\n```\n\n`getPartials()` would produce the following result:\n\n```javascript\nvar hbs = require('express-handlebars').create();\n\nhbs.getPartials().then(function (partials) {\n    console.log(partials);\n    // => { 'foo/bar': [Function],\n    // =>    title: [Function] }\n});\n```\n\n#### `getTemplate(filePath, [options])`\nRetrieves the template at the specified `filePath` and returns a Promise for the compiled Handlebars template function.\n\nUse `options.precompiled` to receive a precompiled Handlebars template.\n\n**Parameters:**\n\n* `filePath`: String path to the Handlebars template file.\n\n* `[options]`: Optional object containing any of the following properties:\n\n  * `[cache]`: Whether a cached template can be used if it have already been requested. This is recommended for production to avoid necessary file I/O.\n\n  * `[encoding]`: File encoding.\n\n  * `[precompiled=false]`: Whether a precompiled template should be provided, instead of a compiled Handlebars template function.\n\n#### `getTemplates(dirPath, [options])`\nRetrieves all the templates in the specified `dirPath` and returns a Promise for an object mapping the compiled templates in the form `{filename: template}`.\n\nUse `options.precompiled` to receive precompiled Handlebars templates \u2014 this is useful for sharing templates with client code.\n\n**Parameters:**\n\n* `dirPath`: String path to the directory containing Handlebars template files.\n\n* `[options]`: Optional object containing any of the following properties:\n\n  * `[cache]`: Whether cached templates can be used if it have already been requested. This is recommended for production to avoid necessary file I/O.\n\n  * `[encoding]`: File encoding.\n\n  * `[precompiled=false]`: Whether precompiled templates should be provided, instead of a compiled Handlebars template function.\n\n#### `render(filePath, context, [options])`\nRenders the template at the specified `filePath` with the `context`, using this instance's `helpers` and partials by default, and returns a Promise for the resulting string.\n\n**Parameters:**\n\n* `filePath`: String path to the Handlebars template file.\n\n* `context`: Object in which the template will be executed. This contains all of the values to fill into the template.\n\n* `[options]`: Optional object which can contain any of the following properties which affect this view engine's behavior:\n\n  * `[cache]`: Whether a cached template can be used if it have already been requested. This is recommended for production to avoid unnecessary file I/O.\n\n  * `[encoding]`: File encoding.\n\n  * `[data]`: Optional object which can contain any data that Handlebars will pipe through the template, all helpers, and all partials. This is a side data channel.\n\n  * `[helpers]`: Render-level helpers that will be used instead of any instance-level helpers; these will be merged with (and will override) any global Handlebars helper functions.\n\n  * `[partials]`: Render-level partials that will be used instead of any instance-level partials. This is used internally as an optimization to avoid re-loading all the partials.\n\n  * `[runtimeOptions]`: Optional object which can contain options passed to the template function.\n\n#### `renderView(viewPath, options|callback, [callback])`\nRenders the template at the specified `viewPath` as the `{{{body}}}` within the layout specified by the `defaultLayout` or `options.layout`. Rendering will use this instance's `helpers` and partials, and passes the resulting string to the `callback`.\n\nThis method is called by Express and is the main entry point into this Express view engine implementation. It adds the concept of a \"layout\" and delegates rendering to the `render()` method.\n\nThe `options` will be used both as the context in which the Handlebars templates are rendered, and to signal this view engine on how it should behave, e.g., `options.cache=false` will _always_ load the templates from disk.\n\n**Parameters:**\n\n* `viewPath`: String path to the Handlebars template file which should serve as the `{{{body}}}` when using a layout.\n\n* `[options]`: Optional object which will serve as the context in which the Handlebars templates are rendered. It may also contain any of the following properties which affect this view engine's behavior:\n\n  * `[cache]`: Whether cached templates can be used if they have already been requested. This is recommended for production to avoid unnecessary file I/O.\n\n  * `[encoding]`: File encoding.\n\n  * `[data]`: Optional object which can contain any data that Handlebars will pipe through the template, all helpers, and all partials. This is a side data channel.\n\n  * `[helpers]`: Render-level helpers that will be merged with (and will override) instance and global helper functions.\n\n  * `[partials]`: Render-level partials will be merged with (and will override) instance and global partials. This should be a `{partialName: fn}` hash or a Promise of an object with this shape.\n\n  * `[layout]`: Optional string path to the Handlebars template file to be used as the \"layout\". This overrides any `defaultLayout` value. Passing a falsy value will render with no layout (even if a `defaultLayout` is defined).\n\n  * `[runtimeOptions]`: Optional object which can contain options passed to the template function.\n\n* `callback`: Function to call once the template is retrieved.\n\n### Hooks\n\nThe following is the list of protected methods that are called internally and serve as _hooks_ to override functionality of `ExpressHandlebars` instances. A value or a promise can be returned from these methods which allows them to perform async operations.\n\n#### `_compileTemplate(template, options)`\nThis hook will be called when a Handlebars template needs to be compiled. This function needs to return a compiled Handlebars template function, or a promise for one.\n\nBy default this hook calls `Handlebars.compile()`, but it can be overridden to preform operations before and/or after Handlebars compiles the template. This is useful if you wanted to first process Markdown within a Handlebars template.\n\n**Parameters:**\n\n* `template`: String Handlebars template that needs to be compiled.\n\n* `options`: Object `compilerOptions` that were specified when the `ExpressHandlebars` instance as created. This object should be passed along to the `Handlebars.compile()` function.\n\n#### `_precompileTemplate(template, options)`\nThis hook will be called when a Handlebars template needs to be precompiled. This function needs to return a serialized Handlebars template spec. string, or a promise for one.\n\nBy default this hook calls `Handlebars.precompile()`, but it can be overridden to preform operations before and/or after Handlebars precompiles the template. This is useful if you wanted to first process Markdown within a Handlebars template.\n\n**Parameters:**\n\n* `template`: String Handlebars template that needs to be precompiled.\n\n* `options`: Object `compilerOptions` that were specified when the `ExpressHandlebars` instance as created. This object should be passed along to the `Handlebars.compile()` function.\n\n#### `_renderTemplate(template, context, options)`\nThis hook will be called when a compiled Handlebars template needs to be rendered. This function needs to returned the rendered output string, or a promise for one.\n\nBy default this hook simply calls the passed-in `template` with the `context` and `options` arguments, but it can be overridden to perform operations before and/or after rendering the template.\n\n**Parameters:**\n\n* `template`: Compiled Handlebars template function to call.\n\n* `context`: The context object in which to render the `template`.\n\n* `options`: Object that contains options and metadata for rendering the template:\n\n  * `data`: Object to define custom `@variable` private variables.\n\n  * `helpers`: Object to provide custom helpers in addition to the globally defined helpers.\n\n  * `partials`: Object to provide custom partials in addition to the globally defined partials.\n\n  * `...runtimeOptions`: Other options specified by the `runtimeOptions` value.\n\n\n[promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n[Runtime Options]: https://handlebarsjs.com/api-reference/runtime-options.html\n\n\n## Examples\n\n### [Basic Usage][]\n\nThis example shows the most basic way to use this view engine.\n\n### [Advanced Usage][]\n\nThis example is more comprehensive and shows how to use many of the features of this view engine, including helpers, partials, multiple layouts, etc.\n\nAs noted in the **Package Design** section, this view engine's implementation is instance-based, and more advanced usages can take advantage of this. The Advanced Usage example demonstrates how to use an `ExpressHandlebars` instance to share templates with the client, among other features.\n\n\n[Basic Usage]: https://github.com/express-handlebars/express-handlebars/tree/master/examples/basic\n[Advanced Usage]: https://github.com/express-handlebars/express-handlebars/tree/master/examples/advanced\n\n\nLicense\n-------\n\nThis software is free to use under the Yahoo! Inc. BSD license. See the [LICENSE file][] for license text and copyright information.\n\n\n[LICENSE file]: https://github.com/express-handlebars/express-handlebars/blob/master/LICENSE\n"], "fixing_code": ["Express Handlebars\n==================\n\nA [Handlebars][] view engine for [Express][] which doesn't suck.\n\n[![npm version][npm-badge]][npm]\n[![dependency status][dep-badge]][dep-status]\n\n**This package used to be named `express3-handlebars`. The previous `express-handlebars` package by @jneen can be found [here][jneen-exphbs].**\n\n\n[Express]: https://github.com/expressjs/express\n[Handlebars]: https://github.com/handlebars-lang/handlebars.js\n[npm]: https://www.npmjs.org/package/express-handlebars\n[npm-badge]: https://img.shields.io/npm/v/express-handlebars.svg?style=flat-square\n[dep-status]: https://david-dm.org/express-handlebars/express-handlebars\n[dep-badge]: https://img.shields.io/david/express-handlebars/express-handlebars.svg?style=flat-square\n[jneen-exphbs]: https://github.com/jneen/express-handlebars\n\n\n## Goals & Design\n\nI created this project out of frustration with the existing Handlebars view engines for Express. As of version 3.x, Express got out of the business of being a generic view engine \u2014 this was a great decision \u2014 leaving developers to implement the concepts of layouts, partials, and doing file I/O for their template engines of choice.\n\n### Goals and Features\n\nAfter building a half-dozen Express apps, I developed requirements and opinions about what a Handlebars view engine should provide and how it should be implemented. The following is that list:\n\n* Add back the concept of \"layout\", which was removed in Express 3.x.\n\n* Add back the concept of \"partials\" via Handlebars' partials mechanism.\n\n* Support a directory of partials; e.g., `{{> foo/bar}}` which exists on the file system at `views/partials/foo/bar.handlebars`, by default.\n\n* Smart file system I/O and template caching. When in development, templates are always loaded from disk. In production, raw files and compiled templates are cached, including partials.\n\n* All async and non-blocking. File system I/O is slow and servers should not be blocked from handling requests while reading from disk. I/O queuing is used to avoid doing unnecessary work.\n\n* Ability to easily precompile templates and partials for use on the client, enabling template sharing and reuse.\n\n* Ability to use a different Handlebars module/implementation other than the Handlebars npm package.\n\n### Package Design\n\nThis package was designed to work great for both the simple and complex use cases. I _intentionally_ made sure the full implementation is exposed and is easily overridable.\n\nThe package exports a function which can be invoked with no arguments or with a `config` object and it will return a function (closed over sensible defaults) which can be registered with an Express app. It's an engine factory function.\n\nThis exported engine factory has two properties which expose the underlying implementation:\n\n* `ExpressHandlebars()`: The constructor function which holds the internal implementation on its `prototype`. This produces instance objects which store their configuration, `compiled` and `precompiled` templates, and expose an `engine()` function which can be registered with an Express app.\n\n* `create()`: A convenience factory function for creating `ExpressHandlebars` instances.\n\nAn instance-based approach is used so that multiple `ExpressHandlebars` instances can be created with their own configuration, templates, partials, and helpers.\n\n\n## Installation\n\nInstall using npm:\n\n```shell\n$ npm install express-handlebars\n```\n\n## Danger \ud83d\udd25\n \nNever put objects on the `req` object straight in as the data, this can allow hackers to run XSS attacks. Always make sure you are destructuring the values on objects like `req.query` and `req.params`. See https://blog.shoebpatel.com/2021/01/23/The-Secret-Parameter-LFR-and-Potential-RCE-in-NodeJS-Apps/ for more details.\n\n## Usage\n\nThis view engine uses sensible defaults that leverage the \"Express-way\" of structuring an app's views. This makes it trivial to use in basic apps:\n\n### Basic Usage\n\n**Directory Structure:**\n\n```\n.\n\u251c\u2500\u2500 app.js\n\u2514\u2500\u2500 views\n    \u251c\u2500\u2500 home.handlebars\n    \u2514\u2500\u2500 layouts\n        \u2514\u2500\u2500 main.handlebars\n\n2 directories, 3 files\n```\n\n**app.js:**\n\nCreates a super simple Express app which shows the basic way to register a Handlebars view engine using this package.\n\n```javascript\nvar express = require('express');\nvar exphbs  = require('express-handlebars');\n\nvar app = express();\n\napp.engine('handlebars', exphbs());\napp.set('view engine', 'handlebars');\n\napp.get('/', function (req, res) {\n    res.render('home');\n});\n\napp.listen(3000);\n```\n\n**views/layouts/main.handlebars:**\n\nThe main layout is the HTML page wrapper which can be reused for the different views of the app. `{{{body}}}` is used as a placeholder for where the main content should be rendered.\n\n```handlebars\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>Example App</title>\n</head>\n<body>\n\n    {{{body}}}\n\n</body>\n</html>\n```\n\n**views/home.handlebars:**\n\nThe content for the app's home view which will be rendered into the layout's `{{{body}}}`.\n\n```handlebars\n<h1>Example App: Home</h1>\n```\n\n#### Running the Example\n\nThe above example is bundled in this package's [examples directory][], where it can be run by:\n\n```shell\n$ cd examples/basic/\n$ npm install\n$ npm start\n```\n\n### Using Instances\n\nAnother way to use this view engine is to create an instance(s) of `ExpressHandlebars`, allowing access to the full API:\n\n```javascript\nvar express = require('express');\nvar exphbs  = require('express-handlebars');\n\nvar app = express();\nvar hbs = exphbs.create({ /* config */ });\n\n// Register `hbs.engine` with the Express app.\napp.engine('handlebars', hbs.engine);\napp.set('view engine', 'handlebars');\n\n// ...still have a reference to `hbs`, on which methods like `getPartials()`\n// can be called.\n```\n\n**Note:** The [Advanced Usage][] example demonstrates how `ExpressHandlebars` instances can be leveraged.\n\n### Template Caching\n\nThis view engine uses a smart template caching strategy. In development, templates will always be loaded from disk, i.e., no caching. In production, raw files and compiled Handlebars templates are aggressively cached.\n\nThe easiest way to control template/view caching is through Express' [view cache setting][]:\n\n```javascript\napp.enable('view cache');\n```\n\nExpress enables this setting by default when in production mode, i.e.:\n\n```\nprocess.env.NODE_ENV === \"production\"\n```\n\n**Note:** All of the public API methods accept `options.cache`, which gives control over caching when calling these methods directly.\n\n### Layouts\n\nA layout is simply a Handlebars template with a `{{{body}}}` placeholder. Usually it will be an HTML page wrapper into which views will be rendered.\n\nThis view engine adds back the concept of \"layout\", which was removed in Express 3.x. It can be configured with a path to the layouts directory, by default it's set to relative to `express settings.view` + `layouts/`\n\nThere are two ways to set a default layout: configuring the view engine's `defaultLayout` property, or setting [Express locals][] `app.locals.layout`.\n\nThe layout into which a view should be rendered can be overridden per-request by assigning a different value to the `layout` request local. The following will render the \"home\" view with no layout:\n\n```javascript\napp.get('/', function (req, res, next) {\n    res.render('home', {layout: false});\n});\n```\n\n### Helpers\n\nHelper functions, or \"helpers\" are functions that can be [registered with Handlebars][] and can be called within a template. Helpers can be used for transforming output, iterating over data, etc. To keep with the spirit of *logic-less* templates, helpers are the place where logic should be defined.\n\nHandlebars ships with some [built-in helpers][], such as: `with`, `if`, `each`, etc. Most application will need to extend this set of helpers to include app-specific logic and transformations. Beyond defining global helpers on `Handlebars`, this view engine supports `ExpressHandlebars` instance-level helpers via the `helpers` configuration property, and render-level helpers via `options.helpers` when calling the `render()` and `renderView()` methods.\n\nThe following example shows helpers being specified at each level:\n\n**app.js:**\n\nCreates a super simple Express app which shows the basic way to register `ExpressHandlebars` instance-level helpers, and override one at the render-level.\n\n```javascript\nvar express = require('express');\nvar exphbs  = require('express-handlebars');\n\nvar app = express();\n\nvar hbs = exphbs.create({\n    // Specify helpers which are only registered on this instance.\n    helpers: {\n        foo: function () { return 'FOO!'; },\n        bar: function () { return 'BAR!'; }\n    }\n});\n\napp.engine('handlebars', hbs.engine);\napp.set('view engine', 'handlebars');\n\napp.get('/', function (req, res, next) {\n    res.render('home', {\n        showTitle: true,\n\n        // Override `foo` helper only for this rendering.\n        helpers: {\n            foo: function () { return 'foo.'; }\n        }\n    });\n});\n\napp.listen(3000);\n```\n\n**views/home.handlebars:**\n\nThe app's home view which uses helper functions to help render the contents.\n\n```handlebars\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>Example App - Home</title>\n</head>\n<body>\n\n    <!-- Uses built-in `if` helper. -->\n  {{#if showTitle}}\n    <h1>Home</h1>\n  {{/if}}\n\n    <!-- Calls `foo` helper, overridden at render-level. -->\n    <p>{{foo}}</p>\n\n    <!-- Calls `bar` helper, defined at instance-level. -->\n    <p>{{bar}}</p>\n\n</body>\n</html>\n```\n\n#### More on Helpers\n\nRefer to the [Handlebars website][] for more information on defining helpers:\n\n* [Expression Helpers][]\n* [Block Helpers][]\n\n### Metadata\n\nHandlebars has a data channel feature that propagates data through all scopes, including helpers and partials. Values in the data channel can be accessed via the `{{@variable}}` syntax. Express Handlebars provides metadata about a template it renders on a `{{@exphbs}}` object allowing access to things like the view name passed to `res.render()` via `{{@exphbs.view}}`.\n\nThe following is the list of metadata that's accessible on the `{{@exphbs}}` data object:\n\n* `cache`: Boolean whether or not the template is cached.\n* `encoding`: String name of encoding for files.\n* `view`: String name of the view passed to `res.render()`.\n* `layout`: String name of the layout view.\n* `data`: Original data object passed when rendering the template.\n* `helpers`: Collection of helpers used when rendering the template.\n* `partials`: Collection of partials used when rendering the template.\n* `runtimeOptions`: Runtime Options used to render the template.\n\n\n[examples directory]: https://github.com/express-handlebars/express-handlebars/tree/master/examples\n[view cache setting]: https://expressjs.com/en/api.html#app.settings.table\n[Express locals]: https://expressjs.com/en/api.html#app.locals\n[registered with Handlebars]: https://github.com/wycats/handlebars.js/#registering-helpers\n[built-in helpers]: https://handlebarsjs.com/guide/builtin-helpers.html\n[Handlebars website]: https://handlebarsjs.com/\n[Expression Helpers]: https://handlebarsjs.com/guide/#custom-helpers\n[Block Helpers]: https://handlebarsjs.com/guide/#block-helpers\n\n\n## API\n\n### Configuration and Defaults\n\nThere are two main ways to use this package: via its engine factory function, or creating `ExpressHandlebars` instances; both use the same configuration properties and defaults.\n\n```javascript\nvar exphbs = require('express-handlebars');\n\n// Using the engine factory:\nexphbs({ /* config */ });\n\n// Create an instance:\nexphbs.create({ /* config */ });\n```\n\nThe following is the list of configuration properties and their default values (if any):\n\n#### `handlebars=require('handlebars')`\nThe Handlebars module/implementation. This allows for the `ExpressHandlebars` instance to use a different Handlebars module/implementation than that provided by the Handlebars npm package.\n\n#### `extname=\".handlebars\"`\nThe string name of the file extension used by the templates. This value should correspond with the `extname` under which this view engine is registered with Express when calling `app.engine()`.\n\nThe following example sets up an Express app to use `.hbs` as the file extension for views:\n\n```javascript\nvar express = require('express');\nvar exphbs  = require('express-handlebars');\n\nvar app = express();\n\napp.engine('.hbs', exphbs({extname: '.hbs'}));\napp.set('view engine', '.hbs');\n```\n\n**Note:** Setting the app's `\"view engine\"` setting will make that value the default file extension used for looking up views.\n\n#### `encoding=\"utf8\"`\nDefault encoding when reading files.\n\n#### `layoutsDir`\nDefault layouts directory is relative to `express settings.view` + `layouts/`\nThe string path to the directory where the layout templates reside.\n\n**Note:** If you configure Express to look for views in a custom location (e.g., `app.set('views', 'some/path/')`), and if your `layoutsDir` is not relative to `express settings.view` + `layouts/`, you will need to reflect that by passing an updated path as the `layoutsDir` property in your configuration.\n\n#### `partialsDir`\nDefault partials directory is relative to `express settings.view` + `partials/`\nThe string path to the directory where the partials templates reside or object with the following properties:\n\n* `dir`: The string path to the directory where the partials templates reside.\n* `namespace`: Optional string namespace to prefix the partial names.\n* `templates`: Optional collection (or promise of a collection) of templates in the form: `{filename: template}`.\n* `rename(filePath, namespace)`: Optional function to rename the partials. Takes two arguments: `filePath`, e.g., `partials/some/path/template.handlebars` and `namespace`.\n\n**Note:** If you configure Express to look for views in a custom location (e.g., `app.set('views', 'some/path/')`), and if your `partialsDir` is not relative to `express settings.view` + `partials/`, you will need to reflect that by passing an updated path as the `partialsDir` property in your configuration.\n\n**Note:** Multiple partials dirs can be used by making `partialsDir` an array of strings, and/or config objects as described above. The namespacing feature is useful if multiple partials dirs are used and their file paths might clash.\n\n#### `defaultLayout`\nThe string name or path of a template in the `layoutsDir` to use as the default layout. `main` is used as the default. This is overridden by a `layout` specified in the app or response `locals`. **Note:** A falsy value will render without a layout; e.g., `res.render('home', {layout: false});`. You can also use a falsy value when creating the engine to make using no layout a default e.g. `app.engine('.hbs', exphbs({defaultLayout: false}));`.\n\n#### `helpers`\nAn object which holds the helper functions used when rendering templates with this `ExpressHandlebars` instance. When rendering a template, a collection of helpers will be generated by merging: `handlebars.helpers` (global), `helpers` (instance), and `options.helpers` (render-level). This allows Handlebars' `registerHelper()` function to operate as expected, will providing two extra levels over helper overrides.\n\n#### `compilerOptions`\nAn object which holds options that will be passed along to the Handlebars compiler functions: `Handlebars.compile()` and `Handlebars.precompile()`.\n\n#### `runtimeOptions`\nAn object which holds options that will be passed along to the template function in addition to the `data`, `helpers`, and `partials` options. See [Runtime Options][] for a list of available options.\n\n### Properties\n\nThe public API properties are provided via `ExpressHandlebars` instances. In additional to the properties listed in the **Configuration and Defaults** section, the following are additional public properties:\n\n#### `engine`\nA function reference to the `renderView()` method which is bound to `this` `ExpressHandlebars` instance. This bound function should be used when registering this view engine with an Express app.\n\n#### `extname`\nThe normalized `extname` which will _always_ start with `.` and defaults to `.handlebars`.\n\n#### `compiled`\nAn object cache which holds compiled Handlebars template functions in the format: `{\"path/to/template\": [Function]}`.\n\n#### `precompiled`\nAn object cache which holds precompiled Handlebars template strings in the format: `{\"path/to/template\": [String]}`.\n\n### Methods\n\nThe following is the list of public API methods provided via `ExpressHandlebars` instances:\n\n**Note:** All of the public methods return a [`Promise`][promise] (with the exception of `renderView()` which is the interface with Express.)\n\n#### `getPartials([options])`\nRetrieves the partials in the `partialsDir` and returns a Promise for an object mapping the partials in the form `{name: partial}`.\n\nBy default each partial will be a compiled Handlebars template function. Use `options.precompiled` to receive the partials as precompiled templates \u2014 this is useful for sharing templates with client code.\n\n**Parameters:**\n\n* `[options]`: Optional object containing any of the following properties:\n\n  * `[cache]`: Whether cached templates can be used if they have already been requested. This is recommended for production to avoid unnecessary file I/O.\n\n  * `[encoding]`: File encoding.\n\n  * `[precompiled=false]`: Whether precompiled templates should be provided, instead of compiled Handlebars template functions.\n\nThe name of each partial corresponds to its location in `partialsDir`. For example, consider the following directory structure:\n\n```\nviews\n\u2514\u2500\u2500 partials\n    \u251c\u2500\u2500 foo\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 bar.handlebars\n    \u2514\u2500\u2500 title.handlebars\n\n2 directories, 2 files\n```\n\n`getPartials()` would produce the following result:\n\n```javascript\nvar hbs = require('express-handlebars').create();\n\nhbs.getPartials().then(function (partials) {\n    console.log(partials);\n    // => { 'foo/bar': [Function],\n    // =>    title: [Function] }\n});\n```\n\n#### `getTemplate(filePath, [options])`\nRetrieves the template at the specified `filePath` and returns a Promise for the compiled Handlebars template function.\n\nUse `options.precompiled` to receive a precompiled Handlebars template.\n\n**Parameters:**\n\n* `filePath`: String path to the Handlebars template file.\n\n* `[options]`: Optional object containing any of the following properties:\n\n  * `[cache]`: Whether a cached template can be used if it have already been requested. This is recommended for production to avoid necessary file I/O.\n\n  * `[encoding]`: File encoding.\n\n  * `[precompiled=false]`: Whether a precompiled template should be provided, instead of a compiled Handlebars template function.\n\n#### `getTemplates(dirPath, [options])`\nRetrieves all the templates in the specified `dirPath` and returns a Promise for an object mapping the compiled templates in the form `{filename: template}`.\n\nUse `options.precompiled` to receive precompiled Handlebars templates \u2014 this is useful for sharing templates with client code.\n\n**Parameters:**\n\n* `dirPath`: String path to the directory containing Handlebars template files.\n\n* `[options]`: Optional object containing any of the following properties:\n\n  * `[cache]`: Whether cached templates can be used if it have already been requested. This is recommended for production to avoid necessary file I/O.\n\n  * `[encoding]`: File encoding.\n\n  * `[precompiled=false]`: Whether precompiled templates should be provided, instead of a compiled Handlebars template function.\n\n#### `render(filePath, context, [options])`\nRenders the template at the specified `filePath` with the `context`, using this instance's `helpers` and partials by default, and returns a Promise for the resulting string.\n\n**Parameters:**\n\n* `filePath`: String path to the Handlebars template file.\n\n* `context`: Object in which the template will be executed. This contains all of the values to fill into the template.\n\n* `[options]`: Optional object which can contain any of the following properties which affect this view engine's behavior:\n\n  * `[cache]`: Whether a cached template can be used if it have already been requested. This is recommended for production to avoid unnecessary file I/O.\n\n  * `[encoding]`: File encoding.\n\n  * `[data]`: Optional object which can contain any data that Handlebars will pipe through the template, all helpers, and all partials. This is a side data channel.\n\n  * `[helpers]`: Render-level helpers that will be used instead of any instance-level helpers; these will be merged with (and will override) any global Handlebars helper functions.\n\n  * `[partials]`: Render-level partials that will be used instead of any instance-level partials. This is used internally as an optimization to avoid re-loading all the partials.\n\n  * `[runtimeOptions]`: Optional object which can contain options passed to the template function.\n\n#### `renderView(viewPath, options|callback, [callback])`\nRenders the template at the specified `viewPath` as the `{{{body}}}` within the layout specified by the `defaultLayout` or `options.layout`. Rendering will use this instance's `helpers` and partials, and passes the resulting string to the `callback`.\n\nThis method is called by Express and is the main entry point into this Express view engine implementation. It adds the concept of a \"layout\" and delegates rendering to the `render()` method.\n\nThe `options` will be used both as the context in which the Handlebars templates are rendered, and to signal this view engine on how it should behave, e.g., `options.cache=false` will _always_ load the templates from disk.\n\n**Parameters:**\n\n* `viewPath`: String path to the Handlebars template file which should serve as the `{{{body}}}` when using a layout.\n\n* `[options]`: Optional object which will serve as the context in which the Handlebars templates are rendered. It may also contain any of the following properties which affect this view engine's behavior:\n\n  * `[cache]`: Whether cached templates can be used if they have already been requested. This is recommended for production to avoid unnecessary file I/O.\n\n  * `[encoding]`: File encoding.\n\n  * `[data]`: Optional object which can contain any data that Handlebars will pipe through the template, all helpers, and all partials. This is a side data channel.\n\n  * `[helpers]`: Render-level helpers that will be merged with (and will override) instance and global helper functions.\n\n  * `[partials]`: Render-level partials will be merged with (and will override) instance and global partials. This should be a `{partialName: fn}` hash or a Promise of an object with this shape.\n\n  * `[layout]`: Optional string path to the Handlebars template file to be used as the \"layout\". This overrides any `defaultLayout` value. Passing a falsy value will render with no layout (even if a `defaultLayout` is defined).\n\n  * `[runtimeOptions]`: Optional object which can contain options passed to the template function.\n\n* `callback`: Function to call once the template is retrieved.\n\n### Hooks\n\nThe following is the list of protected methods that are called internally and serve as _hooks_ to override functionality of `ExpressHandlebars` instances. A value or a promise can be returned from these methods which allows them to perform async operations.\n\n#### `_compileTemplate(template, options)`\nThis hook will be called when a Handlebars template needs to be compiled. This function needs to return a compiled Handlebars template function, or a promise for one.\n\nBy default this hook calls `Handlebars.compile()`, but it can be overridden to preform operations before and/or after Handlebars compiles the template. This is useful if you wanted to first process Markdown within a Handlebars template.\n\n**Parameters:**\n\n* `template`: String Handlebars template that needs to be compiled.\n\n* `options`: Object `compilerOptions` that were specified when the `ExpressHandlebars` instance as created. This object should be passed along to the `Handlebars.compile()` function.\n\n#### `_precompileTemplate(template, options)`\nThis hook will be called when a Handlebars template needs to be precompiled. This function needs to return a serialized Handlebars template spec. string, or a promise for one.\n\nBy default this hook calls `Handlebars.precompile()`, but it can be overridden to preform operations before and/or after Handlebars precompiles the template. This is useful if you wanted to first process Markdown within a Handlebars template.\n\n**Parameters:**\n\n* `template`: String Handlebars template that needs to be precompiled.\n\n* `options`: Object `compilerOptions` that were specified when the `ExpressHandlebars` instance as created. This object should be passed along to the `Handlebars.compile()` function.\n\n#### `_renderTemplate(template, context, options)`\nThis hook will be called when a compiled Handlebars template needs to be rendered. This function needs to returned the rendered output string, or a promise for one.\n\nBy default this hook simply calls the passed-in `template` with the `context` and `options` arguments, but it can be overridden to perform operations before and/or after rendering the template.\n\n**Parameters:**\n\n* `template`: Compiled Handlebars template function to call.\n\n* `context`: The context object in which to render the `template`.\n\n* `options`: Object that contains options and metadata for rendering the template:\n\n  * `data`: Object to define custom `@variable` private variables.\n\n  * `helpers`: Object to provide custom helpers in addition to the globally defined helpers.\n\n  * `partials`: Object to provide custom partials in addition to the globally defined partials.\n\n  * `...runtimeOptions`: Other options specified by the `runtimeOptions` value.\n\n\n[promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n[Runtime Options]: https://handlebarsjs.com/api-reference/runtime-options.html\n\n\n## Examples\n\n### [Basic Usage][]\n\nThis example shows the most basic way to use this view engine.\n\n### [Advanced Usage][]\n\nThis example is more comprehensive and shows how to use many of the features of this view engine, including helpers, partials, multiple layouts, etc.\n\nAs noted in the **Package Design** section, this view engine's implementation is instance-based, and more advanced usages can take advantage of this. The Advanced Usage example demonstrates how to use an `ExpressHandlebars` instance to share templates with the client, among other features.\n\n\n[Basic Usage]: https://github.com/express-handlebars/express-handlebars/tree/master/examples/basic\n[Advanced Usage]: https://github.com/express-handlebars/express-handlebars/tree/master/examples/advanced\n\n\nLicense\n-------\n\nThis software is free to use under the Yahoo! Inc. BSD license. See the [LICENSE file][] for license text and copyright information.\n\n\n[LICENSE file]: https://github.com/express-handlebars/express-handlebars/blob/master/LICENSE\n"], "filenames": ["README.md"], "buggy_code_start_loc": [65], "buggy_code_end_loc": [65], "fixing_code_start_loc": [66], "fixing_code_end_loc": [69], "type": "CWE-94", "message": "Express-handlebars is a Handlebars view engine for Express. Express-handlebars mixes pure template data with engine configuration options through the Express render API. More specifically, the layout parameter may trigger file disclosure vulnerabilities in downstream applications. This potential vulnerability is somewhat restricted in that only files with existing extentions (i.e. file.extension) can be included, files that lack an extension will have .handlebars appended to them. For complete details refer to the referenced GHSL-2021-018 report. Notes in documentation have been added to help users avoid this potential information exposure vulnerability.", "other": {"cve": {"id": "CVE-2021-32820", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-14T19:15:07.960", "lastModified": "2022-07-02T18:24:15.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Express-handlebars is a Handlebars view engine for Express. Express-handlebars mixes pure template data with engine configuration options through the Express render API. More specifically, the layout parameter may trigger file disclosure vulnerabilities in downstream applications. This potential vulnerability is somewhat restricted in that only files with existing extentions (i.e. file.extension) can be included, files that lack an extension will have .handlebars appended to them. For complete details refer to the referenced GHSL-2021-018 report. Notes in documentation have been added to help users avoid this potential information exposure vulnerability."}, {"lang": "es", "value": "Express-handlebars es un motor de visualizaci\u00f3n handlebars para Express.&#xa0;Express-handlebars mezcla datos de plantilla puros con opciones de configuraci\u00f3n del motor mediante la API de renderizado Express.&#xa0;M\u00e1s espec\u00edficamente, el par\u00e1metro layout puede desencadenar vulnerabilidades de divulgaci\u00f3n de archivos en aplicaciones posteriores.&#xa0;Esta vulnerabilidad potencial est\u00e1 algo restringida en el sentido de que solo pueden ser incluidos archivos con extensiones existentes (es decir, file.extension), los archivos que carecen de extensi\u00f3n tendr\u00e1n .handlebars adjuntos.&#xa0;Para obtener detalles completos, consulte el reporte GHSL-2021-018 al que se hace referencia.&#xa0;Se han agregado notas en una documentaci\u00f3n para ayudar a usuarios a evitar esta potencial vulnerabilidad de exposici\u00f3n de informaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:express_handlebars_project:express_handlebars:*:*:*:*:*:node.js:*:*", "versionEndIncluding": "5.3.2", "matchCriteriaId": "068FB627-1A18-4647-ACAD-3C5EEFA3750B"}]}]}], "references": [{"url": "https://github.com/express-handlebars/express-handlebars/blob/78c47a235c4ad7bc2674bddd8ec2721567ed8c72/README.md#danger-", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/express-handlebars/express-handlebars/commit/78c47a235c4ad7bc2674bddd8ec2721567ed8c72", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/express-handlebars/express-handlebars/pull/163", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2021-018-express-handlebars/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/express-handlebars", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/express-handlebars/express-handlebars/commit/78c47a235c4ad7bc2674bddd8ec2721567ed8c72"}}