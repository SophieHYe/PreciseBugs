{"buggy_code": ["/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <limits>\n#include <string>\n#include <vector>\n\n#include \"third_party/eigen3/Eigen/Core\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/kernels/boosted_trees/boosted_trees.pb.h\"\n#include \"tensorflow/core/kernels/boosted_trees/tree_helper.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n\nnamespace tensorflow {\n\nusing Matrix =\n    Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;\nusing ConstMatrixMap = Eigen::Map<const Matrix>;\nusing MatrixMap = Eigen::Map<Matrix>;\n\nusing ConstVectorMap = Eigen::Map<const Eigen::VectorXf>;\nusing VectorMap = Eigen::Map<Eigen::VectorXf>;\n\nconstexpr char kInequalitySplit[] = \"inequality\";\nconstexpr char kEqualitySplit[] = \"equality\";\n\n// V1 Op. Deprecated. BoostedTreesCalculateBestFeatureSplitOpV2 is V2.\nclass BoostedTreesCalculateBestGainsPerFeatureOp : public OpKernel {\n public:\n  explicit BoostedTreesCalculateBestGainsPerFeatureOp(\n      OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_features\", &num_features_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_id_range\n    const Tensor* node_id_range_t;\n    OP_REQUIRES_OK(context, context->input(\"node_id_range\", &node_id_range_t));\n    OP_REQUIRES(\n        context, node_id_range_t->dims() == 1,\n        errors::InvalidArgument(\"node_id_range must be a rank 1 tensor, but \"\n                                \"given node_id_range has dims of \",\n                                node_id_range_t->dims()));\n    OP_REQUIRES(context, node_id_range_t->dim_size(0) == 2,\n                errors::InvalidArgument(\n                    \"node_id_range must be a rank 1 tensor with shape=[2], but \"\n                    \"given node_id_range has shape \",\n                    node_id_range_t->dim_size(0), \" on its first dim\"));\n    const auto node_id_range = node_id_range_t->vec<int32>();\n    const int32_t node_id_first = node_id_range(0);  // inclusive\n    const int32_t node_id_last = node_id_range(1);   // exclusive\n    // stats_summary_list\n    OpInputList stats_summary_list;\n    OP_REQUIRES_OK(context, context->input_list(\"stats_summary_list\",\n                                                &stats_summary_list));\n    const int64_t num_buckets = stats_summary_list[0].dim_size(1);\n    // Check for single logit: 1 gradient + 1 hessian value.\n    DCHECK_EQ(stats_summary_list[0].dim_size(2), 2);\n    std::vector<TTypes<float, 3>::ConstTensor> stats_summary;\n    stats_summary.reserve(stats_summary_list.size());\n    for (const auto& tensor : stats_summary_list) {\n      stats_summary.emplace_back(tensor.tensor<float, 3>());\n    }\n    const Tensor* l1_t;\n    OP_REQUIRES_OK(context, context->input(\"l1\", &l1_t));\n    const auto l1 = l1_t->scalar<float>()();\n    const Tensor* l2_t;\n    OP_REQUIRES_OK(context, context->input(\"l2\", &l2_t));\n    const auto l2 = l2_t->scalar<float>()();\n    const Tensor* tree_complexity_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"tree_complexity\", &tree_complexity_t));\n    const auto tree_complexity = tree_complexity_t->scalar<float>()();\n    const Tensor* min_node_weight_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"min_node_weight\", &min_node_weight_t));\n    const auto min_node_weight = min_node_weight_t->scalar<float>()();\n\n    // Allocate output lists of tensors:\n    OpOutputList output_node_ids_list;\n    OP_REQUIRES_OK(\n        context, context->output_list(\"node_ids_list\", &output_node_ids_list));\n    OpOutputList output_gains_list;\n    OP_REQUIRES_OK(context,\n                   context->output_list(\"gains_list\", &output_gains_list));\n    OpOutputList output_thresholds_list;\n    OP_REQUIRES_OK(context, context->output_list(\"thresholds_list\",\n                                                 &output_thresholds_list));\n    OpOutputList output_left_node_contribs_list;\n    OP_REQUIRES_OK(context,\n                   context->output_list(\"left_node_contribs_list\",\n                                        &output_left_node_contribs_list));\n    OpOutputList output_right_node_contribs_list;\n    OP_REQUIRES_OK(context,\n                   context->output_list(\"right_node_contribs_list\",\n                                        &output_right_node_contribs_list));\n\n    // Use identity later to convert float to Eigen::Matrix type for input to\n    // CalculateWeightsAndGains. This op only supports single dimension logits.\n    Eigen::MatrixXf identity;\n    identity.setIdentity(1, 1);\n    // Get the best split info per node for each feature.\n    for (int feature_idx = 0; feature_idx < num_features_; ++feature_idx) {\n      std::vector<float> cum_grad;\n      std::vector<float> cum_hess;\n      cum_grad.reserve(num_buckets);\n      cum_hess.reserve(num_buckets);\n\n      std::vector<int32> output_node_ids;\n      std::vector<float> output_gains;\n      std::vector<int32> output_thresholds;\n      std::vector<float> output_left_node_contribs;\n      std::vector<float> output_right_node_contribs;\n      for (int node_id = node_id_first; node_id < node_id_last; ++node_id) {\n        // Calculate gains.\n        cum_grad.clear();\n        cum_hess.clear();\n        float total_grad = 0.0;\n        float total_hess = 0.0;\n        for (int bucket = 0; bucket < num_buckets; ++bucket) {\n          // TODO(nponomareva): Consider multi-dimensional gradients/hessians.\n          total_grad += stats_summary[feature_idx](node_id, bucket, 0);\n          total_hess += stats_summary[feature_idx](node_id, bucket, 1);\n          cum_grad.push_back(total_grad);\n          cum_hess.push_back(total_hess);\n        }\n        // Check if node has enough of average hessian.\n        if (total_hess < min_node_weight) {\n          // Do not split the node because not enough avg hessian.\n          continue;\n        }\n        float best_gain = std::numeric_limits<float>::lowest();\n        float best_bucket = 0;\n        float best_contrib_for_left = 0.0;\n        float best_contrib_for_right = 0.0;\n        // Parent gain.\n        float parent_gain;\n        Eigen::VectorXf unused(1);\n        CalculateWeightsAndGains(total_grad * identity, total_hess * identity,\n                                 l1, l2, &unused, &parent_gain);\n\n        for (int bucket = 0; bucket < num_buckets; ++bucket) {\n          const float cum_grad_bucket = cum_grad[bucket];\n          const float cum_hess_bucket = cum_hess[bucket];\n          // Left child.\n          Eigen::VectorXf contrib_for_left(1);\n          float gain_for_left;\n          CalculateWeightsAndGains(cum_grad_bucket * identity,\n                                   cum_hess_bucket * identity, l1, l2,\n                                   &contrib_for_left, &gain_for_left);\n          // Right child.\n          // use contrib_for_right.\n          Eigen::VectorXf contrib_for_right(1);\n          float gain_for_right;\n          CalculateWeightsAndGains((total_grad - cum_grad_bucket) * identity,\n                                   (total_hess - cum_hess_bucket) * identity,\n                                   l1, l2, &contrib_for_right, &gain_for_right);\n\n          if (GainIsLarger(gain_for_left + gain_for_right, best_gain)) {\n            best_gain = gain_for_left + gain_for_right;\n            best_bucket = bucket;\n            best_contrib_for_left = contrib_for_left[0];\n            best_contrib_for_right = contrib_for_right[0];\n          }\n        }  // for bucket\n        output_node_ids.push_back(node_id);\n        // Remove the parent gain for the parent node.\n        output_gains.push_back(best_gain - parent_gain);\n        output_thresholds.push_back(best_bucket);\n        output_left_node_contribs.push_back(best_contrib_for_left);\n        output_right_node_contribs.push_back(best_contrib_for_right);\n      }  // for node_id\n      const int num_nodes = output_node_ids.size();\n      // output_node_ids\n      Tensor* output_node_ids_t;\n      OP_REQUIRES_OK(context,\n                     output_node_ids_list.allocate(feature_idx, {num_nodes},\n                                                   &output_node_ids_t));\n      auto output_node_ids_vec = output_node_ids_t->vec<int32>();\n      // output_gains\n      Tensor* output_gains_t;\n      OP_REQUIRES_OK(context, output_gains_list.allocate(\n                                  feature_idx, {num_nodes}, &output_gains_t));\n      auto output_gains_vec = output_gains_t->vec<float>();\n      // output_thresholds\n      Tensor* output_thresholds_t;\n      OP_REQUIRES_OK(context,\n                     output_thresholds_list.allocate(feature_idx, {num_nodes},\n                                                     &output_thresholds_t));\n      auto output_thresholds_vec = output_thresholds_t->vec<int32>();\n      // output_left_node_contribs\n      Tensor* output_left_node_contribs_t;\n      OP_REQUIRES_OK(context, output_left_node_contribs_list.allocate(\n                                  feature_idx, {num_nodes, 1},\n                                  &output_left_node_contribs_t));\n      auto output_left_node_contribs_matrix =\n          output_left_node_contribs_t->matrix<float>();\n      // output_right_node_contribs\n      Tensor* output_right_node_contribs_t;\n      OP_REQUIRES_OK(context, output_right_node_contribs_list.allocate(\n                                  feature_idx, {num_nodes, 1},\n                                  &output_right_node_contribs_t));\n      auto output_right_node_contribs_matrix =\n          output_right_node_contribs_t->matrix<float>();\n      // Sets output tensors from vectors.\n      for (int i = 0; i < num_nodes; ++i) {\n        output_node_ids_vec(i) = output_node_ids[i];\n        // Adjust the gains to penalize by tree complexity.\n        output_gains_vec(i) = output_gains[i] - tree_complexity;\n        output_thresholds_vec(i) = output_thresholds[i];\n        output_left_node_contribs_matrix(i, 0) = output_left_node_contribs[i];\n        // This op only supports 1-dimensional logits.\n        output_right_node_contribs_matrix(i, 0) = output_right_node_contribs[i];\n      }\n    }  // for f\n  }\n\n private:\n  int max_splits_;\n  int num_features_;\n};\n\n// V1 op that only supports single dimensional logit.\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesCalculateBestGainsPerFeature\").Device(DEVICE_CPU),\n    BoostedTreesCalculateBestGainsPerFeatureOp);\n\n// Deprecated op. Use BoostedTreesCalculateBestFeatureSplitOpV2.\nclass BoostedTreesCalculateBestFeatureSplitOp : public OpKernel {\n public:\n  explicit BoostedTreesCalculateBestFeatureSplitOp(\n      OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"logits_dimension\", &logits_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"split_type\", &split_type_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_id_range\n    const Tensor* node_id_range_t;\n    OP_REQUIRES_OK(context, context->input(\"node_id_range\", &node_id_range_t));\n    OP_REQUIRES(\n        context, node_id_range_t->NumElements() == 2,\n        errors::InvalidArgument(\"node_id_range argument must have shape [2]\"));\n    const auto node_id_range = node_id_range_t->vec<int32>();\n    const int32_t node_id_first = node_id_range(0);  // inclusive\n    const int32_t node_id_last = node_id_range(1);   // exclusive\n\n    const Tensor* stats_summary_t;\n    OP_REQUIRES_OK(context, context->input(\"stats_summary\", &stats_summary_t));\n    OP_REQUIRES(\n        context, stats_summary_t->shape().dims() == 4,\n        errors::InvalidArgument(\"stats_summary argument must have rank 4\"));\n    TTypes<float, 4>::ConstTensor stats_summary =\n        stats_summary_t->tensor<float, 4>();\n    const int32_t feature_dims = stats_summary_t->dim_size(1);\n    // The last bucket is for default/missing value.\n    const int32_t num_buckets = stats_summary_t->dim_size(2) - 1;\n    const int32_t logits_dim = logits_dim_;\n    const int32_t hessian_dim = stats_summary_t->dim_size(3) - logits_dim;\n    DCHECK_GT(hessian_dim, 0);\n    DCHECK_LE(hessian_dim, logits_dim * logits_dim);\n\n    const Tensor* l1_t;\n    OP_REQUIRES_OK(context, context->input(\"l1\", &l1_t));\n    OP_REQUIRES(context, l1_t->NumElements() == 1,\n                errors::InvalidArgument(\"l1 argument must be a scalar\"));\n    const auto l1 = l1_t->scalar<float>()();\n    DCHECK_GE(l1, 0);\n    if (logits_dim_ > 1) {\n      // Multi-class L1 regularization not supported yet.\n      DCHECK_EQ(l1, 0);\n    }\n\n    const Tensor* l2_t;\n    OP_REQUIRES_OK(context, context->input(\"l2\", &l2_t));\n    OP_REQUIRES(context, l2_t->NumElements() == 1,\n                errors::InvalidArgument(\"l2 argument must be a scalar\"));\n    const auto l2 = l2_t->scalar<float>()();\n    DCHECK_GE(l2, 0);\n\n    const Tensor* tree_complexity_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"tree_complexity\", &tree_complexity_t));\n    OP_REQUIRES(\n        context, tree_complexity_t->NumElements() == 1,\n        errors::InvalidArgument(\"tree_complexity argument must be a scalar\"));\n    const auto tree_complexity = tree_complexity_t->scalar<float>()();\n\n    const Tensor* min_node_weight_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"min_node_weight\", &min_node_weight_t));\n    OP_REQUIRES(\n        context, min_node_weight_t->NumElements() == 1,\n        errors::InvalidArgument(\"min_node_weight argument must be a scalar\"));\n    const auto min_node_weight = min_node_weight_t->scalar<float>()();\n\n    std::vector<int32> output_node_ids;\n    std::vector<float> output_gains;\n    std::vector<int32> output_feature_dimensions;\n    std::vector<int32> output_thresholds;\n    std::vector<Eigen::VectorXf> output_left_node_contribs;\n    std::vector<Eigen::VectorXf> output_right_node_contribs;\n    std::vector<std::string> output_split_types;\n\n    // TODO(tanzheny) parallelize the computation.\n    // Iterate each node and find the best gain per node.\n    for (int32_t node_id = node_id_first; node_id < node_id_last; ++node_id) {\n      float best_gain = std::numeric_limits<float>::lowest();\n      int32_t best_bucket = 0;\n      int32_t best_f_dim = 0;\n      string best_split_type;\n      Eigen::VectorXf best_contrib_for_left(logits_dim);\n      Eigen::VectorXf best_contrib_for_right(logits_dim);\n      float parent_gain;\n\n      // Including default bucket.\n      ConstMatrixMap stats_mat(&stats_summary(node_id, 0, 0, 0),\n                               num_buckets + 1, logits_dim + hessian_dim);\n      const Eigen::VectorXf total_grad =\n          stats_mat.leftCols(logits_dim).colwise().sum();\n      const Eigen::VectorXf total_hess =\n          stats_mat.rightCols(hessian_dim).colwise().sum();\n      if (total_hess.norm() < min_node_weight) {\n        continue;\n      }\n      Eigen::VectorXf parent_weight(logits_dim);\n      CalculateWeightsAndGains(total_grad, total_hess, l1, l2, &parent_weight,\n                               &parent_gain);\n\n      if (split_type_ == \"inequality\") {\n        CalculateBestInequalitySplit(\n            stats_summary, node_id, feature_dims, logits_dim, hessian_dim,\n            num_buckets, min_node_weight, l1, l2, &best_gain, &best_bucket,\n            &best_f_dim, &best_split_type, &best_contrib_for_left,\n            &best_contrib_for_right);\n      } else {\n        CalculateBestEqualitySplit(\n            stats_summary, total_grad, total_hess, node_id, feature_dims,\n            logits_dim, hessian_dim, num_buckets, l1, l2, &best_gain,\n            &best_bucket, &best_f_dim, &best_split_type, &best_contrib_for_left,\n            &best_contrib_for_right);\n      }\n\n      if (best_gain == std::numeric_limits<float>::lowest()) {\n        // Do not add the node if not split if found.\n        continue;\n      }\n      output_node_ids.push_back(node_id);\n      // Remove the parent gain for the parent node.\n      output_gains.push_back(best_gain - parent_gain);\n      output_feature_dimensions.push_back(best_f_dim);\n      // default direction is fixed for dense splits.\n      // TODO(tanzheny) account for default values.\n      output_split_types.push_back(best_split_type);\n      output_thresholds.push_back(best_bucket);\n      output_left_node_contribs.push_back(best_contrib_for_left);\n      output_right_node_contribs.push_back(best_contrib_for_right);\n    }  // for node id\n    const int num_nodes = output_node_ids.size();\n    // output_node_ids\n    Tensor* output_node_ids_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"node_ids\", {num_nodes},\n                                                     &output_node_ids_t));\n    auto output_node_ids_vec = output_node_ids_t->vec<int32>();\n\n    // output_gains\n    Tensor* output_gains_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"gains\", {num_nodes},\n                                                     &output_gains_t));\n    auto output_gains_vec = output_gains_t->vec<float>();\n\n    // output_feature_dimensions\n    Tensor* output_feature_dimension_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"feature_dimensions\", {num_nodes},\n                                            &output_feature_dimension_t));\n    auto output_feature_dimensions_vec =\n        output_feature_dimension_t->vec<int32>();\n\n    // output_thresholds\n    Tensor* output_thresholds_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"thresholds\", {num_nodes},\n                                                     &output_thresholds_t));\n    auto output_thresholds_vec = output_thresholds_t->vec<int32>();\n\n    // output_left_node_contribs\n    Tensor* output_left_node_contribs_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"left_node_contribs\", {num_nodes, logits_dim},\n                                &output_left_node_contribs_t));\n    auto output_left_node_contribs_matrix =\n        output_left_node_contribs_t->matrix<float>();\n\n    // output_right_node_contribs\n    Tensor* output_right_node_contribs_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"right_node_contribs\", {num_nodes, logits_dim},\n                                &output_right_node_contribs_t));\n    auto output_right_node_contribs_matrix =\n        output_right_node_contribs_t->matrix<float>();\n\n    // split type\n    Tensor* output_split_types_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"split_with_default_directions\",\n                                          {num_nodes}, &output_split_types_t));\n    auto output_split_types_vec = output_split_types_t->vec<tstring>();\n\n    // Sets output tensors from vectors.\n    for (int i = 0; i < num_nodes; ++i) {\n      output_node_ids_vec(i) = output_node_ids[i];\n      // Adjust the gains to penalize by tree complexity.\n      output_gains_vec(i) = output_gains[i] - tree_complexity;\n      output_feature_dimensions_vec(i) = output_feature_dimensions[i];\n      output_thresholds_vec(i) = output_thresholds[i];\n      for (int j = 0; j < logits_dim; ++j) {\n        output_left_node_contribs_matrix(i, j) =\n            output_left_node_contribs[i][j];\n        output_right_node_contribs_matrix(i, j) =\n            output_right_node_contribs[i][j];\n      }\n      output_split_types_vec(i) = output_split_types[i];\n    }\n  }\n\n private:\n  // TODO(crawles): Simplify inequality path just like equality b/138329196\n  // Currently this is not simplify-able due to numerical instability in math\n  // i.e. gain = -g.transpose() * hessian_and_reg.colPivHouseholderQr().solve(g)\n  // It caused gain to be Inf when g is approaching 0 but not exactly 0 while\n  // there is no regularization.\n  // Calculate the best inequality split per node.\n  void CalculateBestInequalitySplit(\n      TTypes<float, 4>::ConstTensor stats_summary, const int32_t node_id,\n      const int32_t feature_dims, const int32_t logits_dim,\n      const int32_t hessian_dim, const int32_t num_buckets,\n      const float min_node_weight, const float l1, const float l2,\n      float* best_gain, int32* best_bucket, int32* best_f_dim,\n      string* best_split_type, Eigen::VectorXf* best_contrib_for_left,\n      Eigen::VectorXf* best_contrib_for_right) {\n    std::vector<Eigen::VectorXf> cum_grad;\n    std::vector<Eigen::VectorXf> cum_hess;\n    // get all cumulative gradients including default bucket.\n    cum_grad.reserve(num_buckets);\n    cum_hess.reserve(num_buckets);\n\n    for (int f_dim = 0; f_dim < feature_dims; ++f_dim) {\n      ConstVectorMap default_stats_vec(\n          &stats_summary(node_id, f_dim, num_buckets, 0),\n          logits_dim + hessian_dim);\n      Eigen::VectorXf missing_bucket_grad = default_stats_vec.head(logits_dim);\n      Eigen::VectorXf missing_bucket_hess = default_stats_vec.tail(hessian_dim);\n      cum_grad.clear();\n      cum_hess.clear();\n      Eigen::VectorXf total_grad = Eigen::VectorXf::Zero(logits_dim);\n      Eigen::VectorXf total_hess = Eigen::VectorXf::Zero(hessian_dim);\n      // sum all the gradients including default bucket.\n      for (int bucket = 0; bucket <= num_buckets; ++bucket) {\n        for (int i = 0; i < logits_dim; ++i) {\n          total_grad[i] += stats_summary(node_id, f_dim, bucket, i);\n        }\n        for (int i = 0; i < hessian_dim; ++i) {\n          // Full hessian.\n          total_hess[i] +=\n              stats_summary(node_id, f_dim, bucket, logits_dim + i);\n        }\n        if (bucket < num_buckets) {\n          cum_grad.push_back(total_grad);\n          cum_hess.push_back(total_hess);\n        }\n      }\n      const string kInequalityDefaultLeft =\n          boosted_trees::SplitTypeWithDefault_Name(\n              boosted_trees::INEQUALITY_DEFAULT_LEFT);\n      const string kInequalityDefaultRight =\n          boosted_trees::SplitTypeWithDefault_Name(\n              boosted_trees::INEQUALITY_DEFAULT_RIGHT);\n\n      // Iterate from left to right, excluding default bucket.\n      for (int bucket = 0; bucket < num_buckets; ++bucket) {\n        // default value goes to left node.\n        const Eigen::VectorXf total_left_grad =\n            cum_grad[bucket] + missing_bucket_grad;\n        const Eigen::VectorXf total_left_hess =\n            cum_hess[bucket] + missing_bucket_hess;\n        MaybeUpdateBestSplit(\n            total_left_grad, total_grad - total_left_grad, total_left_hess,\n            total_hess - total_left_hess, logits_dim, bucket, f_dim, l1, l2,\n            kInequalityDefaultLeft, best_gain, best_bucket, best_f_dim,\n            best_split_type, best_contrib_for_left, best_contrib_for_right);\n        // default value goes to right node.\n        MaybeUpdateBestSplit(\n            cum_grad[bucket], total_grad - cum_grad[bucket], cum_hess[bucket],\n            total_hess - cum_hess[bucket], logits_dim, bucket, f_dim, l1, l2,\n            kInequalityDefaultRight, best_gain, best_bucket, best_f_dim,\n            best_split_type, best_contrib_for_left, best_contrib_for_right);\n      }  // for bucket\n    }\n  }\n\n  // Calculate the best equality split per node.\n  void CalculateBestEqualitySplit(\n      TTypes<float, 4>::ConstTensor stats_summary,\n      const Eigen::VectorXf& total_grad, const Eigen::VectorXf& total_hess,\n      const int32_t node_id, const int32_t feature_dims,\n      const int32_t logits_dim, const int32_t hessian_dim,\n      const int32_t num_buckets, const float l1, const float l2,\n      float* best_gain, int32* best_bucket, int32* best_f_dim,\n      string* best_split_type, Eigen::VectorXf* best_contrib_for_left,\n      Eigen::VectorXf* best_contrib_for_right) {\n    const string kEqualityDefaultRight =\n        boosted_trees::SplitTypeWithDefault_Name(\n            boosted_trees::EQUALITY_DEFAULT_RIGHT);\n    for (int f_dim = 0; f_dim < feature_dims; ++f_dim) {\n      for (int bucket = 0; bucket < num_buckets; ++bucket) {\n        ConstVectorMap stats_vec(&stats_summary(node_id, f_dim, bucket, 0),\n                                 logits_dim + hessian_dim);\n        Eigen::VectorXf curr_grad = stats_vec.head(logits_dim);\n        Eigen::VectorXf curr_hess = stats_vec.tail(hessian_dim);\n        MaybeUpdateBestSplit(curr_grad, total_grad - curr_grad, curr_hess,\n                             total_hess - curr_hess, logits_dim, bucket, f_dim,\n                             l1, l2, kEqualityDefaultRight, best_gain,\n                             best_bucket, best_f_dim, best_split_type,\n                             best_contrib_for_left, best_contrib_for_right);\n      }\n    }\n  }\n\n  void MaybeUpdateBestSplit(const Eigen::VectorXf& grad_for_left,\n                            const Eigen::VectorXf& grad_for_right,\n                            const Eigen::VectorXf& hess_for_left,\n                            const Eigen::VectorXf& hess_for_right,\n                            const int32_t logits_dim, const int32_t bucket,\n                            const int32_t f_dim, const float l1, const float l2,\n                            const string split_type, float* best_gain,\n                            int32* best_bucket, int32* best_f_dim,\n                            string* best_split_type,\n                            Eigen::VectorXf* best_contrib_for_left,\n                            Eigen::VectorXf* best_contrib_for_right) {\n    // Left child.\n    Eigen::VectorXf contrib_for_left(logits_dim);\n    float gain_for_left;\n    CalculateWeightsAndGains(grad_for_left, hess_for_left, l1, l2,\n                             &contrib_for_left, &gain_for_left);\n    Eigen::VectorXf contrib_for_right(logits_dim);\n    float gain_for_right;\n    CalculateWeightsAndGains(grad_for_right, hess_for_right, l1, l2,\n                             &contrib_for_right, &gain_for_right);\n    if (GainIsLarger(gain_for_left + gain_for_right, *best_gain)) {\n      *best_gain = gain_for_left + gain_for_right;\n      *best_bucket = bucket;\n      *best_f_dim = f_dim;\n      *best_contrib_for_left = contrib_for_left;\n      *best_contrib_for_right = contrib_for_right;\n      *best_split_type = split_type;\n    }\n  }\n\n  int logits_dim_;\n  string split_type_;\n};\n\n// Deprecated op. Use BoostedTreesCalculateBestFeatureSplitOpV2.\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesCalculateBestFeatureSplit\").Device(DEVICE_CPU),\n    BoostedTreesCalculateBestFeatureSplitOp);\n\n// V2 Op.\nclass BoostedTreesCalculateBestFeatureSplitV2 : public OpKernel {\n public:\n  explicit BoostedTreesCalculateBestFeatureSplitV2(\n      OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"logits_dimension\", &logits_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_features\", &num_features_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_id_range\n    const Tensor* node_id_range_t;\n    OP_REQUIRES_OK(context, context->input(\"node_id_range\", &node_id_range_t));\n    const auto node_id_range = node_id_range_t->vec<int32>();\n    OP_REQUIRES(\n        context, node_id_range_t->dims() == 1,\n        errors::InvalidArgument(\"node_id_range must be a rank 1 tensor, but \"\n                                \"given node_id_range has dims of \",\n                                node_id_range_t->dims()));\n    OP_REQUIRES(context, node_id_range_t->dim_size(0) == 2,\n                errors::InvalidArgument(\n                    \"node_id_range must be a rank 1 tensor with shape=[2], but \"\n                    \"given node_id_range has shape \",\n                    node_id_range_t->dim_size(0), \" on its first dim\"));\n    const int32_t node_id_first = node_id_range(0);  // Inclusive.\n    const int32_t node_id_last = node_id_range(1);   // Exclusive.\n\n    // Get stats_summaries_list.\n    OpInputList stats_summaries_list;\n    OP_REQUIRES_OK(context, context->input_list(\"stats_summaries_list\",\n                                                &stats_summaries_list));\n\n    // Infer dimensions of a stats_summary.\n    DCHECK_GT(stats_summaries_list.size(), 0);\n    const int32_t feature_dims = stats_summaries_list[0].dim_size(1);\n    // The last bucket is for default/missing value.\n    const int32_t num_buckets = stats_summaries_list[0].dim_size(2) - 1;\n    const int32_t logits_dim = logits_dim_;\n    const int32_t hessian_dim =\n        stats_summaries_list[0].dim_size(3) - logits_dim;\n    DCHECK_GT(hessian_dim, 0);\n    DCHECK_LE(hessian_dim, logits_dim * logits_dim);\n\n    // Vector of stats_summaries; each element is stats for feature of shape\n    // [max_splits, feature_dim, num_buckets, logits_dim + hessian_dim].\n    std::vector<TTypes<float, 4>::ConstTensor> stats_summaries;\n    DCHECK_EQ(stats_summaries_list.size(), num_features_);\n    stats_summaries.reserve(num_features_);\n    for (const auto& tensor : stats_summaries_list) {\n      stats_summaries.emplace_back(tensor.tensor<float, 4>());\n    }\n\n    // Split types.\n    const Tensor* split_types_t;\n    OP_REQUIRES_OK(context, context->input(\"split_types\", &split_types_t));\n    const auto split_types = split_types_t->vec<tstring>();\n    DCHECK_EQ(split_types.size(), num_features_);\n    // Validate.\n    for (int i = 0; i < num_features_; ++i) {\n      if (!(split_types(i) == kInequalitySplit ||\n            split_types(i) == kEqualitySplit)) {\n        OP_REQUIRES_OK(\n            context,\n            errors::Aborted(\n                \"Operation received an exception: Incorrect split type\"));\n      }\n    }\n    // Feature ids.\n    const Tensor* candidate_feature_ids_t;\n    OP_REQUIRES_OK(context, context->input(\"candidate_feature_ids\",\n                                           &candidate_feature_ids_t));\n    const auto candidate_feature_ids = candidate_feature_ids_t->vec<int32>();\n    DCHECK_EQ(candidate_feature_ids.size(), num_features_);\n\n    // L1, L2, tree_complexity, min_node_weight.\n    const Tensor* l1_t;\n    OP_REQUIRES_OK(context, context->input(\"l1\", &l1_t));\n    const auto l1 = l1_t->scalar<float>()();\n    DCHECK_GE(l1, 0);\n    if (logits_dim_ > 1) {\n      // Multi-class L1 regularization not supported yet.\n      DCHECK_EQ(l1, 0);\n    }\n    const Tensor* l2_t;\n    OP_REQUIRES_OK(context, context->input(\"l2\", &l2_t));\n    const auto l2 = l2_t->scalar<float>()();\n    DCHECK_GE(l2, 0);\n    const Tensor* tree_complexity_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"tree_complexity\", &tree_complexity_t));\n    const auto tree_complexity = tree_complexity_t->scalar<float>()();\n    const Tensor* min_node_weight_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"min_node_weight\", &min_node_weight_t));\n    const auto min_node_weight = min_node_weight_t->scalar<float>()();\n\n    std::vector<int32> output_node_ids;\n    std::vector<float> output_gains;\n    std::vector<int32> output_feature_ids;\n    std::vector<int32> output_feature_dimensions;\n    std::vector<int32> output_thresholds;\n    std::vector<Eigen::VectorXf> output_left_node_contribs;\n    std::vector<Eigen::VectorXf> output_right_node_contribs;\n    std::vector<string> output_split_types;\n\n    // TODO(tanzheny) parallelize the computation.\n    // Iterate each node and find the best gain per node.\n    float parent_gain;\n    for (int32_t node_id = node_id_first; node_id < node_id_last; ++node_id) {\n      float best_gain = std::numeric_limits<float>::lowest();\n      int32_t best_bucket;\n      int32_t best_f_id;\n      int32_t best_f_dim;\n      string best_split_type;\n      Eigen::VectorXf best_contrib_for_left(logits_dim);\n      Eigen::VectorXf best_contrib_for_right(logits_dim);\n\n      // Sum of gradient and hessian. Compute parent gain using first feature.\n      ConstMatrixMap stats_mat(&stats_summaries[0](node_id, 0, 0, 0),\n                               num_buckets + 1,  // Including default bucket.\n                               logits_dim + hessian_dim);\n      const Eigen::VectorXf total_grad =\n          stats_mat.leftCols(logits_dim).colwise().sum();\n      const Eigen::VectorXf total_hess =\n          stats_mat.rightCols(hessian_dim).colwise().sum();\n      if (total_hess.norm() < min_node_weight) {\n        continue;\n      }\n      Eigen::VectorXf unused(logits_dim);\n      CalculateWeightsAndGains(total_grad, total_hess, l1, l2, &unused,\n                               &parent_gain);\n      for (int f_idx = 0; f_idx < num_features_; ++f_idx) {\n        const string split_type = split_types(f_idx);\n        TTypes<float, 4>::ConstTensor stats_summary = stats_summaries[f_idx];\n        float f_best_gain = std::numeric_limits<float>::lowest();\n        int32_t f_best_bucket;\n        int32_t f_best_f_dim;\n        string f_best_split_type;\n        Eigen::VectorXf f_best_contrib_for_left(logits_dim);\n        Eigen::VectorXf f_best_contrib_for_right(logits_dim);\n\n        if (split_type == kInequalitySplit) {\n          CalculateBestInequalitySplit(\n              stats_summary, node_id, feature_dims, logits_dim, hessian_dim,\n              num_buckets, min_node_weight, l1, l2, &f_best_gain,\n              &f_best_bucket, &f_best_f_dim, &f_best_split_type,\n              &f_best_contrib_for_left, &f_best_contrib_for_right);\n        } else {\n          CalculateBestEqualitySplit(\n              stats_summary, total_grad, total_hess, node_id, feature_dims,\n              logits_dim, hessian_dim, num_buckets, l1, l2, &f_best_gain,\n              &f_best_bucket, &f_best_f_dim, &f_best_split_type,\n              &f_best_contrib_for_left, &f_best_contrib_for_right);\n        }\n        if (f_best_gain > best_gain) {\n          best_gain = f_best_gain;\n          best_f_id = candidate_feature_ids(f_idx);\n          best_f_dim = f_best_f_dim;\n          best_split_type = f_best_split_type;\n          best_bucket = f_best_bucket;\n          best_contrib_for_left = f_best_contrib_for_left;\n          best_contrib_for_right = f_best_contrib_for_right;\n        }\n      }  // For feature id.\n      if (best_gain == std::numeric_limits<float>::lowest()) {\n        // Do not add the node if no split is found.\n        continue;\n      }\n      output_node_ids.push_back(node_id);\n      // Remove the parent gain for the parent node.\n      output_gains.push_back(best_gain - parent_gain);\n      output_feature_ids.push_back(best_f_id);\n      output_feature_dimensions.push_back(best_f_dim);\n      // Default direction is fixed for dense splits.\n      // TODO(tanzheny) account for default values.\n      output_split_types.push_back(best_split_type);\n      output_thresholds.push_back(best_bucket);\n      output_left_node_contribs.push_back(best_contrib_for_left);\n      output_right_node_contribs.push_back(best_contrib_for_right);\n    }  // for node id.\n    const int num_nodes = output_node_ids.size();\n    // output_node_ids\n    Tensor* output_node_ids_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"node_ids\", {num_nodes},\n                                                     &output_node_ids_t));\n    auto output_node_ids_vec = output_node_ids_t->vec<int32>();\n\n    // output_gains\n    Tensor* output_gains_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"gains\", {num_nodes},\n                                                     &output_gains_t));\n    auto output_gains_vec = output_gains_t->vec<float>();\n\n    // output_feature_ids\n    Tensor* output_features_ids_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"feature_ids\", {num_nodes},\n                                                     &output_features_ids_t));\n    auto output_features_vec = output_features_ids_t->vec<int32>();\n\n    // output_feature_dimensions\n    Tensor* output_feature_dimension_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"feature_dimensions\", {num_nodes},\n                                            &output_feature_dimension_t));\n    auto output_feature_dimensions_vec =\n        output_feature_dimension_t->vec<int32>();\n\n    // output_thresholds\n    Tensor* output_thresholds_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"thresholds\", {num_nodes},\n                                                     &output_thresholds_t));\n    auto output_thresholds_vec = output_thresholds_t->vec<int32>();\n\n    // output_left_node_contribs\n    Tensor* output_left_node_contribs_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"left_node_contribs\", {num_nodes, logits_dim},\n                                &output_left_node_contribs_t));\n    auto output_left_node_contribs_matrix =\n        output_left_node_contribs_t->matrix<float>();\n\n    // output_right_node_contribs\n    Tensor* output_right_node_contribs_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"right_node_contribs\", {num_nodes, logits_dim},\n                                &output_right_node_contribs_t));\n    auto output_right_node_contribs_matrix =\n        output_right_node_contribs_t->matrix<float>();\n\n    // split type\n    Tensor* output_split_types_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"split_with_default_directions\",\n                                          {num_nodes}, &output_split_types_t));\n    auto output_split_types_vec = output_split_types_t->vec<tstring>();\n\n    // Sets output tensors from vectors.\n    for (int i = 0; i < num_nodes; ++i) {\n      output_node_ids_vec(i) = output_node_ids[i];\n      output_features_vec(i) = output_feature_ids[i];\n      // Adjust the gains to penalize by tree complexity.\n      output_gains_vec(i) = output_gains[i] - tree_complexity;\n      output_feature_dimensions_vec(i) = output_feature_dimensions[i];\n      output_thresholds_vec(i) = output_thresholds[i];\n      for (int j = 0; j < logits_dim; ++j) {\n        output_left_node_contribs_matrix(i, j) =\n            output_left_node_contribs[i][j];\n        output_right_node_contribs_matrix(i, j) =\n            output_right_node_contribs[i][j];\n      }\n      output_split_types_vec(i) = output_split_types[i];\n    }\n  }\n\n private:\n  // TODO(crawles): Simplify inequality path just like equality b/138329196\n  // Currently this is not simplify-able due to numerical instability in math\n  // i.e. gain = -g.transpose() * hessian_and_reg.colPivHouseholderQr().solve(g)\n  // It caused gain to be Inf when g is approaching 0 but not exactly 0 while\n  // there is no regularization.\n  // Calculate the best inequality split per node.\n  void CalculateBestInequalitySplit(\n      TTypes<float, 4>::ConstTensor stats_summary, const int32_t node_id,\n      const int32_t feature_dims, const int32_t logits_dim,\n      const int32_t hessian_dim, const int32_t num_buckets,\n      const float min_node_weight, const float l1, const float l2,\n      float* best_gain, int32* best_bucket, int32* best_f_dim,\n      string* best_split_type, Eigen::VectorXf* best_contrib_for_left,\n      Eigen::VectorXf* best_contrib_for_right) {\n    std::vector<Eigen::VectorXf> cum_grad;\n    std::vector<Eigen::VectorXf> cum_hess;\n    // get all cumulative gradients including default bucket.\n    cum_grad.reserve(num_buckets);\n    cum_hess.reserve(num_buckets);\n\n    for (int f_dim = 0; f_dim < feature_dims; ++f_dim) {\n      ConstVectorMap default_stats_vec(\n          &stats_summary(node_id, f_dim, num_buckets, 0),\n          logits_dim + hessian_dim);\n      Eigen::VectorXf missing_bucket_grad = default_stats_vec.head(logits_dim);\n      Eigen::VectorXf missing_bucket_hess = default_stats_vec.tail(hessian_dim);\n      cum_grad.clear();\n      cum_hess.clear();\n      Eigen::VectorXf total_grad = Eigen::VectorXf::Zero(logits_dim);\n      Eigen::VectorXf total_hess = Eigen::VectorXf::Zero(hessian_dim);\n      // sum all the gradients including default bucket.\n      for (int bucket = 0; bucket <= num_buckets; ++bucket) {\n        for (int i = 0; i < logits_dim; ++i) {\n          total_grad[i] += stats_summary(node_id, f_dim, bucket, i);\n        }\n        for (int i = 0; i < hessian_dim; ++i) {\n          // Full hessian.\n          total_hess[i] +=\n              stats_summary(node_id, f_dim, bucket, logits_dim + i);\n        }\n        if (bucket < num_buckets) {\n          cum_grad.push_back(total_grad);\n          cum_hess.push_back(total_hess);\n        }\n      }\n      const string kInequalityDefaultLeft =\n          boosted_trees::SplitTypeWithDefault_Name(\n              boosted_trees::INEQUALITY_DEFAULT_LEFT);\n      const string kInequalityDefaultRight =\n          boosted_trees::SplitTypeWithDefault_Name(\n              boosted_trees::INEQUALITY_DEFAULT_RIGHT);\n\n      // Iterate from left to right, excluding default bucket.\n      for (int bucket = 0; bucket < num_buckets; ++bucket) {\n        // default value goes to left node.\n        const Eigen::VectorXf total_left_grad =\n            cum_grad[bucket] + missing_bucket_grad;\n        const Eigen::VectorXf total_left_hess =\n            cum_hess[bucket] + missing_bucket_hess;\n        MaybeUpdateBestSplit(\n            total_left_grad, total_grad - total_left_grad, total_left_hess,\n            total_hess - total_left_hess, logits_dim, bucket, f_dim, l1, l2,\n            kInequalityDefaultLeft, best_gain, best_bucket, best_f_dim,\n            best_split_type, best_contrib_for_left, best_contrib_for_right);\n        // default value goes to right node.\n        MaybeUpdateBestSplit(\n            cum_grad[bucket], total_grad - cum_grad[bucket], cum_hess[bucket],\n            total_hess - cum_hess[bucket], logits_dim, bucket, f_dim, l1, l2,\n            kInequalityDefaultRight, best_gain, best_bucket, best_f_dim,\n            best_split_type, best_contrib_for_left, best_contrib_for_right);\n      }  // for bucket\n    }\n  }\n\n  // Calculate the best equality split per node.\n  void CalculateBestEqualitySplit(\n      TTypes<float, 4>::ConstTensor stats_summary,\n      const Eigen::VectorXf& total_grad, const Eigen::VectorXf& total_hess,\n      const int32_t node_id, const int32_t feature_dims,\n      const int32_t logits_dim, const int32_t hessian_dim,\n      const int32_t num_buckets, const float l1, const float l2,\n      float* best_gain, int32* best_bucket, int32* best_f_dim,\n      string* best_split_type, Eigen::VectorXf* best_contrib_for_left,\n      Eigen::VectorXf* best_contrib_for_right) {\n    const string kEqualityDefaultRight =\n        boosted_trees::SplitTypeWithDefault_Name(\n            boosted_trees::EQUALITY_DEFAULT_RIGHT);\n    for (int f_dim = 0; f_dim < feature_dims; ++f_dim) {\n      for (int bucket = 0; bucket < num_buckets; ++bucket) {\n        ConstVectorMap stats_vec(&stats_summary(node_id, f_dim, bucket, 0),\n                                 logits_dim + hessian_dim);\n        Eigen::VectorXf curr_grad = stats_vec.head(logits_dim);\n        Eigen::VectorXf curr_hess = stats_vec.tail(hessian_dim);\n        MaybeUpdateBestSplit(curr_grad, total_grad - curr_grad, curr_hess,\n                             total_hess - curr_hess, logits_dim, bucket, f_dim,\n                             l1, l2, kEqualityDefaultRight, best_gain,\n                             best_bucket, best_f_dim, best_split_type,\n                             best_contrib_for_left, best_contrib_for_right);\n      }\n    }\n  }\n\n  void MaybeUpdateBestSplit(const Eigen::VectorXf& grad_for_left,\n                            const Eigen::VectorXf& grad_for_right,\n                            const Eigen::VectorXf& hess_for_left,\n                            const Eigen::VectorXf& hess_for_right,\n                            const int32_t logits_dim, const int32_t bucket,\n                            const int32_t f_dim, const float l1, const float l2,\n                            const string split_type, float* best_gain,\n                            int32* best_bucket, int32* best_f_dim,\n                            string* best_split_type,\n                            Eigen::VectorXf* best_contrib_for_left,\n                            Eigen::VectorXf* best_contrib_for_right) {\n    // Left child.\n    Eigen::VectorXf contrib_for_left(logits_dim);\n    float gain_for_left;\n    CalculateWeightsAndGains(grad_for_left, hess_for_left, l1, l2,\n                             &contrib_for_left, &gain_for_left);\n    Eigen::VectorXf contrib_for_right(logits_dim);\n    float gain_for_right;\n    CalculateWeightsAndGains(grad_for_right, hess_for_right, l1, l2,\n                             &contrib_for_right, &gain_for_right);\n    if (GainIsLarger(gain_for_left + gain_for_right, *best_gain)) {\n      *best_gain = gain_for_left + gain_for_right;\n      *best_bucket = bucket;\n      *best_f_dim = f_dim;\n      *best_contrib_for_left = contrib_for_left;\n      *best_contrib_for_right = contrib_for_right;\n      *best_split_type = split_type;\n    }\n  }\n  int num_features_;\n  int logits_dim_;\n};\n\n// v2 op that supports multi-class.\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesCalculateBestFeatureSplitV2\").Device(DEVICE_CPU),\n    BoostedTreesCalculateBestFeatureSplitV2);\n\n// Map from bucket id to vector of statistics.\ntypedef std::map<int32, std::vector<float>> BucketMap;\ntypedef BucketMap::iterator BucketMapIterator;\n// Map from feature dimension to BucketMap.\ntypedef std::map<int32, BucketMap> FeatureMap;\ntypedef FeatureMap::iterator FeatureMapIterator;\n\nclass BoostedTreesSparseCalculateBestFeatureSplitOp : public OpKernel {\n public:\n  explicit BoostedTreesSparseCalculateBestFeatureSplitOp(\n      OpKernelConstruction* const context)\n      : OpKernel(context) {\n    // TODO(crawles): Using logits_dim_ for multi-class split.\n    OP_REQUIRES_OK(context, context->GetAttr(\"logits_dimension\", &logits_dim_));\n    // TODO(tanzheny): Using this for equality split.\n    OP_REQUIRES_OK(context, context->GetAttr(\"split_type\", &split_type_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_id_range\n    const Tensor* node_id_range_t;\n    OP_REQUIRES_OK(context, context->input(\"node_id_range\", &node_id_range_t));\n    const auto node_id_range = node_id_range_t->vec<int32>();\n    const int32_t node_id_first = node_id_range(0);  // inclusive\n    const int32_t node_id_last = node_id_range(1);   // exclusive\n\n    const Tensor* stats_summary_indices_t;\n    OP_REQUIRES_OK(context, context->input(\"stats_summary_indices\",\n                                           &stats_summary_indices_t));\n    const auto stats_summary_indices = stats_summary_indices_t->matrix<int32>();\n    const int32_t num_sparse_entries = stats_summary_indices_t->dim_size(0);\n\n    const Tensor* stats_summary_values_t;\n    OP_REQUIRES_OK(context, context->input(\"stats_summary_values\",\n                                           &stats_summary_values_t));\n    const auto stats_summary_values = stats_summary_values_t->vec<float>();\n\n    const Tensor* stats_summary_shape_t;\n    OP_REQUIRES_OK(\n        context, context->input(\"stats_summary_shape\", &stats_summary_shape_t));\n    const auto stats_summary_shape = stats_summary_shape_t->vec<int32>();\n    const int32_t num_buckets = stats_summary_shape(2) - 1;\n    const int32_t stats_dims = stats_summary_shape(3);\n\n    const Tensor* l1_t;\n    OP_REQUIRES_OK(context, context->input(\"l1\", &l1_t));\n    const auto l1 = l1_t->scalar<float>()();\n\n    const Tensor* l2_t;\n    OP_REQUIRES_OK(context, context->input(\"l2\", &l2_t));\n    const auto l2 = l2_t->scalar<float>()();\n\n    const Tensor* tree_complexity_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"tree_complexity\", &tree_complexity_t));\n    const auto tree_complexity = tree_complexity_t->scalar<float>()();\n\n    const Tensor* min_node_weight_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"min_node_weight\", &min_node_weight_t));\n    const auto min_node_weight = min_node_weight_t->scalar<float>()();\n\n    std::vector<int32> output_node_ids;\n    std::vector<float> output_gains;\n    std::vector<int32> output_feature_dimensions;\n    std::vector<int32> output_thresholds;\n    std::vector<float> output_left_node_contribs;\n    std::vector<float> output_right_node_contribs;\n    std::vector<string> output_split_types;\n\n    FeatureMap f_map;\n\n    int32_t previous_node_id = -1;\n    for (int idx = 0; idx < num_sparse_entries; ++idx) {\n      int32_t node_id = stats_summary_indices(idx, 0);\n      if (node_id != previous_node_id) {\n        process_node(f_map, &output_node_ids, &output_gains,\n                     &output_feature_dimensions, &output_thresholds,\n                     &output_left_node_contribs, &output_right_node_contribs,\n                     &output_split_types, previous_node_id, min_node_weight, l1,\n                     l2, num_buckets);\n        f_map.clear();\n      }\n      previous_node_id = node_id;\n      DCHECK_LE(node_id_first, node_id);\n      DCHECK_LT(node_id, node_id_last);\n      const int32_t feature_dim = stats_summary_indices(idx, 1);\n      const int32_t bucket_id = stats_summary_indices(idx, 2);\n      const int32_t stat_dim = stats_summary_indices(idx, 3);\n      OP_REQUIRES(context, stat_dim < stats_dims,\n                  errors::InvalidArgument(\n                      \"Stat dim, the sum of logits dim and hessian dim in \"\n                      \"stats_summary_indices, cannot be greater than stats \"\n                      \"dims, the last value in stats_summary_shape, which was \",\n                      stats_dims, \". At index (\", idx,\n                      \", 4), stats_summary_indices contains value \", stat_dim));\n      std::pair<FeatureMapIterator, bool> const& f_insert_result = f_map.insert(\n          FeatureMapIterator::value_type(feature_dim, BucketMap()));\n      auto& b_map = f_insert_result.first->second;\n      std::pair<BucketMapIterator, bool> const& b_insert_result =\n          b_map.insert(BucketMapIterator::value_type(\n              bucket_id, std::vector<float>(stats_dims)));\n      auto& stats = b_insert_result.first->second;\n      stats[stat_dim] = stats_summary_values(idx);\n    }  // for node_id\n    // process the last node id\n    process_node(f_map, &output_node_ids, &output_gains,\n                 &output_feature_dimensions, &output_thresholds,\n                 &output_left_node_contribs, &output_right_node_contribs,\n                 &output_split_types, previous_node_id, min_node_weight, l1, l2,\n                 num_buckets);\n\n    const int num_nodes = output_node_ids.size();\n    // output_node_ids\n    Tensor* output_node_ids_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"node_ids\", {num_nodes},\n                                                     &output_node_ids_t));\n    auto output_node_ids_vec = output_node_ids_t->vec<int32>();\n\n    // output_gains\n    Tensor* output_gains_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"gains\", {num_nodes},\n                                                     &output_gains_t));\n    auto output_gains_vec = output_gains_t->vec<float>();\n\n    // output_feature_dimensions\n    Tensor* output_feature_dimension_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"feature_dimensions\", {num_nodes},\n                                            &output_feature_dimension_t));\n    auto output_feature_dimensions_vec =\n        output_feature_dimension_t->vec<int32>();\n\n    // output_thresholds\n    Tensor* output_thresholds_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"thresholds\", {num_nodes},\n                                                     &output_thresholds_t));\n    auto output_thresholds_vec = output_thresholds_t->vec<int32>();\n\n    // output_left_node_contribs\n    Tensor* output_left_node_contribs_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"left_node_contribs\", {num_nodes, 1},\n                                          &output_left_node_contribs_t));\n    auto output_left_node_contribs_matrix =\n        output_left_node_contribs_t->matrix<float>();\n\n    // output_right_node_contribs\n    Tensor* output_right_node_contribs_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"right_node_contribs\", {num_nodes, 1},\n                                          &output_right_node_contribs_t));\n    auto output_right_node_contribs_matrix =\n        output_right_node_contribs_t->matrix<float>();\n\n    // split type\n    Tensor* output_split_types_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"split_with_default_directions\",\n                                          {num_nodes}, &output_split_types_t));\n    auto output_split_types_vec = output_split_types_t->vec<tstring>();\n\n    // Sets output tensors from vectors.\n    for (int i = 0; i < num_nodes; ++i) {\n      output_node_ids_vec(i) = output_node_ids[i];\n      // Adjust the gains to penalize by tree complexity.\n      output_gains_vec(i) = output_gains[i] - tree_complexity;\n      output_feature_dimensions_vec(i) = output_feature_dimensions[i];\n      output_thresholds_vec(i) = output_thresholds[i];\n      // TODO(crawles): change this for multi-class.\n      output_left_node_contribs_matrix(i, 0) = output_left_node_contribs[i];\n      output_right_node_contribs_matrix(i, 0) = output_right_node_contribs[i];\n      output_split_types_vec(i) = output_split_types[i];\n    }\n  }\n\n protected:\n  void process_node(const FeatureMap& f_map,\n                    std::vector<int32>* output_node_ids,\n                    std::vector<float>* output_gains,\n                    std::vector<int32>* output_feature_dimensions,\n                    std::vector<int32>* output_thresholds,\n                    std::vector<float>* output_left_node_contribs,\n                    std::vector<float>* output_right_node_contribs,\n                    std::vector<string>* output_split_types,\n                    const int32_t node_id, const float min_node_weight,\n                    const float l1, const float l2, const int32_t num_buckets) {\n    float parent_gain;\n    Eigen::VectorXf unused(logits_dim_);\n    Eigen::MatrixXf identity;\n    identity.setIdentity(1, 1);\n\n    // start processing for previous node id.\n    float best_gain = std::numeric_limits<float>::lowest();\n    float best_bucket = 0;\n    float best_f_dim = 0;\n    string best_split_type = boosted_trees::SplitTypeWithDefault_Name(\n        boosted_trees::INEQUALITY_DEFAULT_LEFT);\n    float best_contrib_for_left = 0.0;\n    float best_contrib_for_right = 0.0;\n    // the sum of gradients including default bucket.\n    float total_grad = 0;\n    // the sum of hessians including default bucket.\n    float total_hess = 0;\n\n    for (auto f_iter = f_map.begin(); f_iter != f_map.end(); ++f_iter) {\n      const int32_t feature_dim = f_iter->first;\n      const auto buckets_to_stats_map = f_iter->second;\n\n      // The very last bucket contains stats for missing values.\n      // TODO(crawles): use vector for multi-class.\n      const float default_grad =\n          (buckets_to_stats_map.find(num_buckets) == buckets_to_stats_map.end()\n               ? 0\n               : buckets_to_stats_map.at(num_buckets)[0]);\n      const float default_hess =\n          (buckets_to_stats_map.find(num_buckets) == buckets_to_stats_map.end()\n               ? 0\n               : buckets_to_stats_map.at(num_buckets)[1]);\n\n      if (f_iter == f_map.begin()) {\n        // first get the sum of grads, including default bucket.\n        for (auto b_iter = buckets_to_stats_map.begin();\n             b_iter != buckets_to_stats_map.end(); ++b_iter) {\n          total_grad += b_iter->second[0];\n          total_hess += b_iter->second[1];\n        }\n        if (total_hess < min_node_weight) {\n          // Do not split the node because not enough avg hessian.\n          break;\n        }\n        CalculateWeightsAndGains(total_grad * identity, total_hess * identity,\n                                 l1, l2, &unused, &parent_gain);\n      }\n\n      float total_left_grad = 0;\n      float total_left_hess = 0;\n      for (auto b_iter = buckets_to_stats_map.begin();\n           b_iter != buckets_to_stats_map.end(); ++b_iter) {\n        const int32_t bucket_id = b_iter->first;\n        // total_left_stats should exclude stats from default bucket.\n        if (bucket_id == num_buckets) {\n          break;\n        }\n        // TODO(crawles): vector for multi-class.\n        total_left_grad += b_iter->second[0];\n        total_left_hess += b_iter->second[1];\n        // From left to right, default right.\n        // Left child.\n        Eigen::VectorXf contrib_for_left(1);\n        float gain_for_left;\n        CalculateWeightsAndGains(total_left_grad * identity,\n                                 total_left_hess * identity, l1, l2,\n                                 &contrib_for_left, &gain_for_left);\n        // Right child.\n        Eigen::VectorXf contrib_for_right(1);\n        float gain_for_right;\n        CalculateWeightsAndGains((total_grad - total_left_grad) * identity,\n                                 (total_hess - total_left_hess) * identity, l1,\n                                 l2, &contrib_for_right, &gain_for_right);\n        if (GainIsLarger(gain_for_left + gain_for_right, best_gain)) {\n          best_gain = gain_for_left + gain_for_right;\n          best_bucket = bucket_id;\n          best_f_dim = feature_dim;\n          best_split_type = boosted_trees::SplitTypeWithDefault_Name(\n              boosted_trees::INEQUALITY_DEFAULT_RIGHT);\n          best_contrib_for_left = contrib_for_left[0];\n          best_contrib_for_right = contrib_for_right[0];\n        }\n\n        // From right to left, default left.\n        CalculateWeightsAndGains((total_left_grad + default_grad) * identity,\n                                 (total_left_hess + default_hess) * identity,\n                                 l1, l2, &contrib_for_left, &gain_for_left);\n        CalculateWeightsAndGains(\n            (total_grad - default_grad - total_left_grad) * identity,\n            (total_hess - default_hess - total_left_hess) * identity, l1, l2,\n            &contrib_for_right, &gain_for_right);\n        if (GainIsLarger(gain_for_left + gain_for_right, best_gain)) {\n          best_gain = gain_for_left + gain_for_right;\n          best_bucket = bucket_id;\n          best_f_dim = feature_dim;\n          best_split_type = boosted_trees::SplitTypeWithDefault_Name(\n              boosted_trees::INEQUALITY_DEFAULT_LEFT);\n          best_contrib_for_left = contrib_for_left[0];\n          best_contrib_for_right = contrib_for_right[0];\n        }\n      }  // for bucket_id\n    }    // for feature_dim\n    if (best_gain != std::numeric_limits<float>::lowest()) {\n      output_node_ids->push_back(node_id);\n      // Remove the parent gain.\n      output_gains->push_back(best_gain - parent_gain);\n      output_feature_dimensions->push_back(best_f_dim);\n      output_split_types->push_back(best_split_type);\n      output_thresholds->push_back(best_bucket);\n      output_left_node_contribs->push_back(best_contrib_for_left);\n      output_right_node_contribs->push_back(best_contrib_for_right);\n    }\n  }\n\n private:\n  int logits_dim_;\n  string split_type_;\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesSparseCalculateBestFeatureSplit\").Device(DEVICE_CPU),\n    BoostedTreesSparseCalculateBestFeatureSplitOp);\n\nclass BoostedTreesMakeStatsSummaryOp : public OpKernel {\n public:\n  explicit BoostedTreesMakeStatsSummaryOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_features\", &num_features_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_ids\n    const Tensor* node_ids_t;\n    OP_REQUIRES_OK(context, context->input(\"node_ids\", &node_ids_t));\n    const auto node_ids = node_ids_t->vec<int32>();\n    // gradients\n    const Tensor* gradients_t;\n    OP_REQUIRES_OK(context, context->input(\"gradients\", &gradients_t));\n    const auto gradients = gradients_t->matrix<float>();\n    // hessians\n    const Tensor* hessians_t;\n    OP_REQUIRES_OK(context, context->input(\"hessians\", &hessians_t));\n    const auto hessians = hessians_t->matrix<float>();\n    // bucketized_features\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features_list\",\n                                                &bucketized_features_list));\n    // Infer batch size.\n    const int64_t batch_size = node_ids_t->dim_size(0);\n\n    // Allocate temporary stats tensor (Rank 4).\n    Tensor temp_stats_double_t;\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DT_DOUBLE,\n                                {num_features_, max_splits_, num_buckets_, 2},\n                                &temp_stats_double_t));\n    auto temp_stats_double = temp_stats_double_t.tensor<double, 4>();\n    temp_stats_double.setZero();\n\n    // Partition by node, and then bucketize.\n    for (int feature_idx = 0; feature_idx < num_features_; ++feature_idx) {\n      const auto& features = bucketized_features_list[feature_idx].vec<int32>();\n      for (int i = 0; i < batch_size; ++i) {\n        const int32_t node = node_ids(i);\n        const int32_t bucket = features(i);\n        temp_stats_double(feature_idx, node, bucket, 0) += gradients(i, 0);\n        temp_stats_double(feature_idx, node, bucket, 1) += hessians(i, 0);\n      }\n    }\n\n    // Copy temp tensor over to output tensor.\n    Tensor* output_stats_summary_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"stats_summary\", temp_stats_double_t.shape(),\n                                &output_stats_summary_t));\n    output_stats_summary_t->tensor<float, 4>() =\n        temp_stats_double.template cast<float>();\n  }\n\n private:\n  int max_splits_;\n  int num_buckets_;\n  int num_features_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"BoostedTreesMakeStatsSummary\").Device(DEVICE_CPU),\n                        BoostedTreesMakeStatsSummaryOp);\n\n// TODO(tanzheny): Add an option of default value into the API interface.\nclass BoostedTreesAggregateStatsOp : public OpKernel {\n public:\n  explicit BoostedTreesAggregateStatsOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_ids.\n    const Tensor* node_ids_t;\n    OP_REQUIRES_OK(context, context->input(\"node_ids\", &node_ids_t));\n    const auto node_ids = node_ids_t->vec<int32>();\n\n    // gradients.\n    const Tensor* gradients_t;\n    OP_REQUIRES_OK(context, context->input(\"gradients\", &gradients_t));\n    const auto gradients = gradients_t->matrix<float>();\n\n    // hessians.\n    const Tensor* hessians_t;\n    OP_REQUIRES_OK(context, context->input(\"hessians\", &hessians_t));\n    const auto hessians = hessians_t->matrix<float>();\n\n    // feature.\n    const Tensor* feature_t;\n    OP_REQUIRES_OK(context, context->input(\"feature\", &feature_t));\n    const auto feature = feature_t->matrix<int32>();\n\n    // Infer batch size, feature dimension and stats dimension.\n    const int64_t batch_size = node_ids_t->dim_size(0);\n    const int64_t logits_dims = gradients_t->dim_size(1);\n    const int64_t hessians_dims = hessians_t->dim_size(1);\n    const int64_t stats_dims = logits_dims + hessians_dims;\n    const int64_t feature_dims = feature_t->dim_size(1);\n\n    // Allocate temporary stats tensor (Rank 4), upcasting to double.\n    // A default bucket is added to the end for missing/default values.\n    Tensor temp_stats_double_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_temp(\n                     DT_DOUBLE,\n                     {max_splits_, feature_dims, num_buckets_ + 1, stats_dims},\n                     &temp_stats_double_t));\n    auto temp_stats_double = temp_stats_double_t.tensor<double, 4>();\n    temp_stats_double.setZero();\n\n    for (int i = 0; i < batch_size; ++i) {\n      const int32_t node = node_ids(i);\n      for (int feature_dim = 0; feature_dim < feature_dims; ++feature_dim) {\n        const int32_t feature_value = feature(i, feature_dim);\n        const int32_t bucket =\n            (feature_value == -1) ? num_buckets_ : feature_value;\n        for (int stat_dim = 0; stat_dim < logits_dims; ++stat_dim) {\n          temp_stats_double(node, feature_dim, bucket, stat_dim) +=\n              gradients(i, stat_dim);\n        }\n        for (int stat_dim = logits_dims; stat_dim < stats_dims; ++stat_dim) {\n          temp_stats_double(node, feature_dim, bucket, stat_dim) +=\n              hessians(i, stat_dim - logits_dims);\n        }\n      }\n    }\n\n    // Copy temp tensor over to output tensor, downcasting to float.\n    Tensor* output_stats_summary_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"stats_summary\", temp_stats_double_t.shape(),\n                                &output_stats_summary_t));\n    output_stats_summary_t->tensor<float, 4>() =\n        temp_stats_double.template cast<float>();\n  }\n\n private:\n  int max_splits_;\n  int num_buckets_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"BoostedTreesAggregateStats\").Device(DEVICE_CPU),\n                        BoostedTreesAggregateStatsOp);\n\n// Key based on node id, feature dimension and bucket id.\nstruct StatsPartitionKey {\n  StatsPartitionKey(const int32_t node_id, const int32_t feature_dim,\n                    const int32_t bucket_id)\n      : node_id(node_id), feature_dim(feature_dim), bucket_id(bucket_id) {}\n\n  bool operator==(const StatsPartitionKey& other) const {\n    return (node_id == other.node_id) && (feature_dim == other.feature_dim) &&\n           (bucket_id == other.bucket_id);\n  }\n\n  // Compare for StatsPartitionKey.\n  struct Less {\n    bool operator()(const StatsPartitionKey& a,\n                    const StatsPartitionKey& b) const {\n      if (a.node_id < b.node_id) {\n        return true;\n      }\n      if ((a.node_id == b.node_id) && (a.feature_dim < b.feature_dim)) {\n        return true;\n      }\n      if ((a.node_id == b.node_id) && (a.feature_dim == b.feature_dim) &&\n          (a.bucket_id < b.bucket_id)) {\n        return true;\n      }\n      return false;\n    }\n  };\n\n  // Tree node id.\n  int32 node_id;\n  // Dimension within feature column.\n  int32 feature_dim;\n  // bucketized feature value .\n  int32 bucket_id;\n};\n\ntypedef std::map<StatsPartitionKey, std::vector<float>, StatsPartitionKey::Less>\n    StatsPartitionMap;\ntypedef StatsPartitionMap::iterator StatsPartitionIterator;\n\n// Key based on instance and feature dimension.\nstruct InstanceFeatureDimKey {\n  InstanceFeatureDimKey() : instance(-1), feature_dim(-1) {}\n\n  InstanceFeatureDimKey(const int32_t instance, const int32_t feature_dim)\n      : instance(instance), feature_dim(feature_dim) {}\n\n  bool operator==(const InstanceFeatureDimKey& other) const {\n    return (instance == other.instance) && (feature_dim == other.feature_dim);\n  }\n\n  // Compare for InstanceFeatureDimKey.\n  struct Less {\n    bool operator()(const InstanceFeatureDimKey& a,\n                    const InstanceFeatureDimKey& b) const {\n      if (a.instance < b.instance) {\n        return true;\n      }\n      if ((a.instance == b.instance) && (a.feature_dim < b.feature_dim)) {\n        return true;\n      }\n      return false;\n    }\n  };\n\n  // Instance id within a batch.\n  int32 instance;\n  // Dimension within feature column.\n  int32 feature_dim;\n};\n\n// Add statistics to StatsPartitionMap for (instance, feature dim, bucket id).\nstatic void AddInstanceStatsToMap(\n    const int32_t instance, const int32_t feature_dim, const int32_t bucket_id,\n    const int32_t logits_dims, const int32_t stats_dims,\n    StatsPartitionMap* stats_map, const TTypes<float>::ConstMatrix& gradients,\n    const TTypes<float>::ConstMatrix& hessians,\n    const TTypes<int32>::ConstVec& node_ids) {\n  const int32_t node_id = node_ids(instance);\n  const auto key = StatsPartitionKey(node_id, feature_dim, bucket_id);\n  std::pair<StatsPartitionIterator, bool> const& insert_result =\n      stats_map->insert(StatsPartitionIterator::value_type(\n          key, std::vector<float>(stats_dims, 0.0f)));\n  auto& stats = insert_result.first->second;\n  for (int stat_dim = 0; stat_dim < logits_dims; ++stat_dim) {\n    stats[stat_dim] += gradients(instance, stat_dim);\n  }\n  for (int stat_dim = logits_dims; stat_dim < stats_dims; ++stat_dim) {\n    stats[stat_dim] += hessians(instance, stat_dim - logits_dims);\n  }\n}\n\n// Add statistics to StatsPartitionMap for bucket_id ranging from\n// (start_instance, start_feature_dim) to (end_instance, end_feature_dim),\n// inclusive on start and end instances, exclusive on end feature dim.\nstatic void AddRangeStats(const int start_instance, const int end_instance,\n                          const int start_feature_dim,\n                          const int end_feature_dim,\n                          StatsPartitionMap* stats_map,\n                          const TTypes<float>::ConstMatrix& gradients,\n                          const TTypes<float>::ConstMatrix& hessians,\n                          const TTypes<int32>::ConstVec& node_ids,\n                          const int32_t feature_dims, const int32_t bucket_id,\n                          const int32_t logits_dims, const int32_t stats_dims) {\n  DCHECK_LE(start_instance, end_instance);\n  if (start_instance == end_instance) {\n    DCHECK_LT(start_feature_dim, end_feature_dim);\n  }\n  for (int32_t instance = start_instance; instance <= end_instance;\n       ++instance) {\n    const int32_t start_f_dim =\n        (instance == start_instance) ? start_feature_dim + 1 : 0;\n    const int32_t end_f_dim =\n        (instance == end_instance) ? end_feature_dim : feature_dims;\n    for (int32_t f_dim = start_f_dim; f_dim < end_f_dim; ++f_dim) {\n      AddInstanceStatsToMap(instance, f_dim, bucket_id, logits_dims, stats_dims,\n                            stats_map, gradients, hessians, node_ids);\n    }\n  }\n}\n\nclass BoostedTreesSparseAggregateStatsOp : public OpKernel {\n public:\n  explicit BoostedTreesSparseAggregateStatsOp(\n      OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_ids.\n    const Tensor* node_ids_t;\n    OP_REQUIRES_OK(context, context->input(\"node_ids\", &node_ids_t));\n    const auto node_ids = node_ids_t->vec<int32>();\n\n    // gradients.\n    const Tensor* gradients_t;\n    OP_REQUIRES_OK(context, context->input(\"gradients\", &gradients_t));\n    const auto gradients = gradients_t->matrix<float>();\n\n    // hessians.\n    const Tensor* hessians_t;\n    OP_REQUIRES_OK(context, context->input(\"hessians\", &hessians_t));\n    const auto hessians = hessians_t->matrix<float>();\n\n    // feature indices.\n    const Tensor* feature_indices_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"feature_indices\", &feature_indices_t));\n    const auto feature_indices = feature_indices_t->matrix<int32>();\n\n    // feature values.\n    const Tensor* feature_values_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"feature_values\", &feature_values_t));\n    const auto feature_values = feature_values_t->vec<int32>();\n\n    // feature shape.\n    const Tensor* feature_shape_t;\n    OP_REQUIRES_OK(context, context->input(\"feature_shape\", &feature_shape_t));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(feature_shape_t->shape()),\n                errors::InvalidArgument(\n                    \"Input shapes should be a vector but received shapes \",\n                    feature_shape_t->shape().DebugString()));\n    const auto feature_shape = feature_shape_t->vec<int32>();\n\n    const int64_t batch_size = gradients_t->dim_size(0);\n    const int64_t logits_dims = gradients_t->dim_size(1);\n    const int64_t hessians_dims = hessians_t->dim_size(1);\n    const int64_t stats_dims = logits_dims + hessians_dims;\n    const int64_t num_sparse_entries = feature_indices_t->dim_size(0);\n    const int32_t feature_dims = feature_shape(1);\n    DCHECK_LE(num_sparse_entries, batch_size * feature_dims);\n\n    // Aggregate statistics info to map.\n    StatsPartitionMap stats_map;\n\n    int prev_instance = 0;\n    int prev_f_dim = -1;\n\n    for (int i = 0; i < num_sparse_entries; ++i) {\n      // the instance number within a batch\n      const int32_t instance = feature_indices(i, 0);\n      DCHECK_LE(instance, batch_size);\n      DCHECK_GE(instance, prev_instance);\n      // the node id within a tree.\n      const int32_t node_id = node_ids(instance);\n      DCHECK_LE(node_id, max_splits_);\n      // the feature dimension.\n      const int32_t f_dim = feature_indices(i, 1);\n      DCHECK_LE(f_dim, feature_dims);\n      // the bucket id of the value.\n      const int32_t bucket_id = feature_values(i);\n      DCHECK_LE(bucket_id, num_buckets_);\n\n      // Add statistics for the missing entries into default bucket.\n      // The last bucket is default bucket.\n      const int missing_entry_bucket = num_buckets_;\n      AddRangeStats(prev_instance, instance, prev_f_dim, f_dim, &stats_map,\n                    gradients, hessians, node_ids, feature_dims,\n                    missing_entry_bucket, logits_dims, stats_dims);\n      prev_instance = instance;\n      prev_f_dim = f_dim;\n      // Add statistics for the non-missing entry into\n      // (cur_instance, cur_f_dim, bucket_id).\n      AddInstanceStatsToMap(instance, f_dim, bucket_id, logits_dims, stats_dims,\n                            &stats_map, gradients, hessians, node_ids);\n    }\n    AddRangeStats(prev_instance, batch_size - 1, prev_f_dim, feature_dims,\n                  &stats_map, gradients, hessians, node_ids, feature_dims,\n                  num_buckets_, logits_dims, stats_dims);\n\n    // Serialize statistics info map to tensor output.\n    const int64_t num_slots = stats_map.size() * stats_dims;\n    Tensor* summary_indices_t = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"stats_summary_indices\",\n                                            TensorShape({num_slots, 4}),\n                                            &summary_indices_t));\n    auto summary_indices = summary_indices_t->matrix<int32>();\n    Tensor* summary_values_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"stats_summary_values\",\n                                                     TensorShape({num_slots}),\n                                                     &summary_values_t));\n    auto summary_values = summary_values_t->vec<float>();\n    int entry_index = 0;\n    for (auto& iter : stats_map) {\n      for (int stat_dim = 0; stat_dim < stats_dims; ++stat_dim) {\n        summary_indices(entry_index, 0) = iter.first.node_id;\n        summary_indices(entry_index, 1) = iter.first.feature_dim;\n        summary_indices(entry_index, 2) = iter.first.bucket_id;\n        summary_indices(entry_index, 3) = stat_dim;\n        summary_values(entry_index) = iter.second[stat_dim];\n        ++entry_index;\n      }\n    }\n\n    Tensor* summary_shape_t = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"stats_summary_shape\",\n                                          TensorShape({4}), &summary_shape_t));\n    auto summary_shape = summary_shape_t->vec<int32>();\n    summary_shape(0) = max_splits_;\n    summary_shape(1) = feature_dims;\n    summary_shape(2) = num_buckets_ + 1;\n    summary_shape(3) = stats_dims;\n  }\n\n private:\n  int max_splits_;\n  int num_buckets_;\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesSparseAggregateStats\").Device(DEVICE_CPU),\n    BoostedTreesSparseAggregateStatsOp);\n\n}  // namespace tensorflow\n", "# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for boosted_trees stats kernels.\"\"\"\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import boosted_trees_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.platform import googletest\n\n\n_INEQUALITY_DEFAULT_LEFT = 'INEQUALITY_DEFAULT_LEFT'.encode('utf-8')\n_INEQUALITY_DEFAULT_RIGHT = 'INEQUALITY_DEFAULT_RIGHT'.encode('utf-8')\n_EQUALITY_DEFAULT_RIGHT = 'EQUALITY_DEFAULT_RIGHT'.encode('utf-8')\n\n\nclass StatsOpsTest(test_util.TensorFlowTestCase):\n  \"\"\"Tests stats_ops.\"\"\"\n\n  def _append_zeros_for_default_bucket(self, stats_summary):\n    summary_shapes = stats_summary.shape\n    # pad zeros for missing value bucket.\n    stats_summary = np.concatenate(\n        (stats_summary,\n         np.zeros([summary_shapes[0], summary_shapes[1], 1, summary_shapes[3]\n                  ])),\n        axis=2)\n    return stats_summary\n\n  def add_f_dim_and_append_zeros(self, stats_summaries):\n    \"\"\"Transform a list of stats summaries, adding a feature dimension.\n\n    The input shape is a list of arrays of shape [max_splits, num_buckets,\n    logits+hess dim]. This transformation returns a list of arrays of shape\n    [max_splits, 1, num_buckets + 1, logits+hess dim].\n\n    Args:\n      stats_summaries: a list of numpy arrays.\n\n    Returns:\n      A list of numpy arrays.\n    \"\"\"\n    return [\n        self._append_zeros_for_default_bucket(np.expand_dims(feature, axis=1))\n        for feature in stats_summaries\n    ]\n\n  def _get_stats_summary_for_split(self):\n    return [\n        [\n            [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .07], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .58], [0., 0.], [.3, .4]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 0\n        [\n            [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .06], [.06, .07]],  # node 1\n            [[.1, .1], [.2, .3], [-.4, .5], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 1\n    ]  # shape=[feature_dim, max_splits, num_buckets, 2]\n\n  def _get_sparse_stats_summary_for_split(self, stats_summary=None):\n    if stats_summary is None:\n      stats_summary = np.asarray(self._get_stats_summary_for_split())\n      stats_summary[0][0][1] = np.zeros([2])\n      stats_summary[1][0][2] = np.zeros([2])\n      stats_summary = np.moveaxis(stats_summary, 0, 1)\n    slices = stats_summary.nonzero()\n    values = stats_summary[slices]\n    indices = np.asarray(slices)\n    return np.moveaxis(indices, 0, 1), values, stats_summary.shape\n\n  def testCalculateBestSplitsWithoutRegularizationInSparse(self):\n    # This test uses the same data as dense, but run in sparse kernel and\n    # make sure the sparse kernel returns same result as dense kernel.\n    dense_summary = np.asarray([\n        [\n            [[0., 0.], [.0, .0], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .07], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .58], [0., 0.], [.3, .4]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 0\n        [\n            [[0., 0.], [0., 0.], [.0, .0], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .06], [.06, .07]],  # node 1\n            [[.1, .1], [.2, .3], [-.4, .5], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    node_id_range = [1, 3]\n    dense_summary = np.moveaxis(dense_summary, 0, 1)\n    dense_shape = dense_summary.shape\n\n    default_bucket_summary = np.zeros(dense_shape[0:2] + (1, dense_shape[3]))\n    sparse_summary = np.concatenate((dense_summary, default_bucket_summary),\n                                    axis=2)\n    slices = sparse_summary.nonzero()\n    summary_values = sparse_summary[slices]\n    summary_indices = np.asarray(slices)\n    summary_indices = np.moveaxis(summary_indices, 0, 1)\n    summary_shape = sparse_summary.shape\n\n    (node_ids, gains, _, _, left_node_contribs, right_node_contribs,\n     _) = self.evaluate(\n         boosted_trees_ops.sparse_calculate_best_feature_split(\n             node_id_range,\n             summary_indices,\n             summary_values,\n             summary_shape,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.02823, 0.41184], gains)\n    self.assertAllClose([-0.6], left_node_contribs[0])\n    self.assertAllClose([-0.076923], right_node_contribs[0])\n\n  def testSparseCalculateBestSplitsWithoutRegularization(self):\n    node_id_range = [1, 3]\n    (summary_indices, summary_values,\n     summary_shape) = self._get_sparse_stats_summary_for_split()\n\n    (node_ids, gains, feature_dimensions, thresholds, left_node_contribs,\n     right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.sparse_calculate_best_feature_split(\n             node_id_range,\n             summary_indices,\n             summary_values,\n             summary_shape,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.116495, 0.60429], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.631579], [-0.770833]], left_node_contribs)\n    self.assertAllClose([[0.833333], [0.8]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestGainsWithoutRegularization_v1_op(self):\n    \"\"\"Testing Gain calculation without any regularization.\"\"\"\n    with self.cached_session() as sess:\n      max_splits = 7\n      node_id_range = [1, 3]  # node 1 through 2 will be processed.\n      stats_summary_list = self._get_stats_summary_for_split()\n\n      (node_ids_list, gains_list, thresholds_list, left_node_contribs_list,\n       right_node_contribs_list\n      ) = boosted_trees_ops.calculate_best_gains_per_feature(\n          node_id_range,\n          stats_summary_list,\n          l1=0.0,\n          l2=0.0,\n          tree_complexity=0.0,\n          min_node_weight=0,\n          max_splits=max_splits)\n\n      self.assertAllEqual([[1, 2], [1, 2]], self.evaluate(node_ids_list))\n      self.assertAllClose([[0.004775, 0.41184], [0.02823, 0.41184]],\n                          self.evaluate(gains_list))\n      self.assertAllEqual([[1, 1], [1, 1]], self.evaluate(thresholds_list))\n      # The left node contrib will be later added to the previous node value to\n      # make the left node value, and the same for right node contrib.\n      self.assertAllClose([[[-.416667], [.568966]], [[-.6], [-.75]]],\n                          self.evaluate(left_node_contribs_list))\n      self.assertAllClose([[[-.592593], [-.75]], [[-.076923], [.568966]]],\n                          self.evaluate(right_node_contribs_list))\n\n  def testCalculateBestFeaturesInvalidSplitType_v2_op(self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [9, 12]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    stats_summaries = self.add_f_dim_and_append_zeros(stats_summaries)\n\n    with self.assertRaisesRegex(Exception, 'Incorrect split type'):\n      self.evaluate(\n          boosted_trees_ops.calculate_best_feature_split_v2(\n              node_id_range,\n              stats_summaries,\n              split_types=['INVALID'] * len(candidate_feature_ids),\n              candidate_feature_ids=candidate_feature_ids,\n              l1=0.0,\n              l2=0.0,\n              tree_complexity=0.0,\n              min_node_weight=0,\n              logits_dimension=1))\n\n  def testCalculateBestFeaturesWithoutRegularization_v2_op(self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [9, 12]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    stats_summaries = self.add_f_dim_and_append_zeros(stats_summaries)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range,\n             stats_summaries,\n             split_types=['inequality'] * len(candidate_feature_ids),\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature_id and dimension that has the best gain per node.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.02823, 0.41184], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllEqual([12, 9], feature_ids)\n    f_dim = 0  # Both features only have one dimension.\n    self.assertAllEqual([f_dim] * 2, feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-.6], [.568966]], left_node_contribs)\n    self.assertAllClose([[-.076923], [-.75]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureSplitsWithoutRegularization_v2_op(self):\n    \"\"\"Testing best split without any regularization for a multi-dim feature.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature_id and dimension that has the best gain per node.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.02823, 0.41184], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 0], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-.6], [.568966]], left_node_contribs)\n    self.assertAllClose([[-.076923], [-.75]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureSplitWMissingValuesWORegularization_v2_op(\n      self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.116495, 0.60429], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.631579], [-0.770833]], left_node_contribs)\n    self.assertAllClose([[0.833333], [0.8]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureEqualitySplitsWithoutRegularization_v2_op(\n      self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['equality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    # 0.116495 = (-0.05)^2/0.06 + 0.36^2/0.57 - 0.31^2/0.63\n    # 0.60429 = (-0.4)^2/0.5 + 0.37^2/0.48 - 0.03^2/0.98\n    self.assertAllClose([0.116495, 0.60429], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([2, 2], thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    # left contrib 0.83 = 0.05/0.06, 0.8 = 0.4/0.5\n    self.assertAllClose([[0.833333], [.8]], left_node_contribs)\n    # right contrib -0.6315 = -0.36/0.57, -0.7708 = -0.37/0.48\n    self.assertAllClose([[-0.631579], [-0.770833]], right_node_contribs)\n    self.assertAllEqual([_EQUALITY_DEFAULT_RIGHT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureMixedSplitTypeWithoutRegularization_v2_op(\n      self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [9, 12]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Add in feature dimension.\n    stats_summaries = [\n        np.expand_dims(feature, axis=1) for feature in stats_summaries\n    ]\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range,\n             stats_summaries,\n             split_types=['inequality', 'equality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    # 0.116495 = (-0.05)^2/0.06 + 0.36^2/0.57 - 0.31^2/0.63\n    # 0.60429 = (-0.4)^2/0.5 + 0.37^2/0.48 - 0.03^2/0.98\n    self.assertAllClose([0.116495, 0.60429], gains)\n    self.assertAllEqual([12, 12], feature_ids)\n    f_dim = 0  # Both features only have one dimension.\n    self.assertAllEqual([f_dim, f_dim], feature_dimensions)\n    self.assertAllEqual([2, 2], thresholds)\n    # Same result as equality only test, as feature_1 is chose for both nodes.\n    # left contrib 0.83 = 0.05/0.06, 0.8 = 0.4/0.5\n    self.assertAllClose([[0.833333], [.8]], left_node_contribs)\n    # right contrib -0.6315 = -0.36/0.57, -0.7708 = -0.37/0.48\n    self.assertAllClose([[-0.631579], [-0.770833]], right_node_contribs)\n    # Feature 1 is inequality.\n    self.assertAllEqual([_EQUALITY_DEFAULT_RIGHT, _EQUALITY_DEFAULT_RIGHT],\n                        split_types)\n\n  def testCalculateBestGainsWithL2_v1_op(self):\n    \"\"\"Testing Gain calculation with L2.\"\"\"\n    with self.cached_session() as sess:\n      max_splits = 7\n      node_id_range = [1, 3]  # node 1 through 2 will be processed.\n      stats_summary_list = self._get_stats_summary_for_split()\n\n      (node_ids_list, gains_list, thresholds_list, left_node_contribs_list,\n       right_node_contribs_list\n      ) = boosted_trees_ops.calculate_best_gains_per_feature(\n          node_id_range,\n          stats_summary_list,\n          l1=0.0,\n          l2=0.1,\n          tree_complexity=0.0,\n          min_node_weight=0,\n          max_splits=max_splits)\n\n      self.assertAllEqual([[1, 2], [1, 2]], self.evaluate(node_ids_list))\n      self.assertAllClose([[0., 0.33931375], [0.01879096, 0.33931375]],\n                          self.evaluate(gains_list))\n      self.assertAllEqual([[0, 1], [1, 1]], self.evaluate(thresholds_list))\n      # The left node contrib will be later added to the previous node value to\n      # make the left node value, and the same for right node contrib.\n      self.assertAllClose([[[0.], [.485294]], [[-.5], [-.6]]],\n                          self.evaluate(left_node_contribs_list))\n      self.assertAllClose([[[-.424658], [-.6]], [[-.043478], [.485294]]],\n                          self.evaluate(right_node_contribs_list))\n\n  def testCalculateMultiDimBestFeatureSplitsWithL2_v2_op(self):\n    \"\"\"Testing best split calculation with L2.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 0], feature_dimensions)\n    self.assertAllClose([0.01879096, 0.33931375], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    # # The left node contrib will be later added to the previous node value to\n    # # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-.5], [.485294]], left_node_contribs)\n    self.assertAllClose([[-.043478], [-.6]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateMultiDimBestFeatureSplitsWithMissingValuesL2_v2_op(self):\n    \"\"\"Testing best split calculation with L2.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllClose([0.077414, 0.501868], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.537313], [-0.637931]], left_node_contribs)\n    self.assertAllClose([[0.3125], [0.666667]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateMultiDimBestFeatureEqualitySplitsWithL2_v2_op(self):\n    \"\"\"Testing best split calculation with L2.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['equality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    # 0.077414 = 0.05^2/0.16 + 0.36^2/0.67 - 0.31^2/0.73\n    # 0.501868 = 0.4^2/0.6 + 0.37^2/0.58 - 0.03^2/1.08\n    self.assertAllClose([0.077414, 0.501868], gains)\n    self.assertAllEqual([2, 2], thresholds)\n    # # The left node contrib will be later added to the previous node value to\n    # # make the left node value, and the same for right node contrib.\n    # left contrib 0.3125 = 0.05/0.16, 0.6667 = 0.4/0.6\n    self.assertAllClose([[0.3125], [0.666667]], left_node_contribs)\n    # right contrib -0.5373 = -0.36/0.67, -0.6379 = -0.37/0.58\n    self.assertAllClose([[-0.537313], [-0.637931]], right_node_contribs)\n    self.assertAllEqual([_EQUALITY_DEFAULT_RIGHT] * 2, split_types)\n\n  def testSparseCalculateBestSplitsWithL2(self):\n    node_id_range = [1, 3]\n    (summary_indices, summary_values,\n     summary_shape) = self._get_sparse_stats_summary_for_split()\n\n    (node_ids, gains, feature_dimensions, thresholds, left_node_contribs,\n     right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.sparse_calculate_best_feature_split(\n             node_id_range,\n             summary_indices,\n             summary_values,\n             summary_shape,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.077414, 0.501868], gains)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.537313], [-0.637931]], left_node_contribs)\n    self.assertAllClose([[0.3125], [0.666667]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT, _INEQUALITY_DEFAULT_LEFT],\n                        split_types)\n\n  def testCalculateBestGainsWithL1_v1_op(self):\n    \"\"\"Testing Gain calculation with L1.\"\"\"\n    with self.cached_session() as sess:\n      max_splits = 7\n      node_id_range = [1, 3]  # node 1 through 2 will be processed.\n      stats_summary_list = self._get_stats_summary_for_split()\n\n      l1 = 0.1\n      (node_ids_list, gains_list, thresholds_list, left_node_contribs_list,\n       right_node_contribs_list\n      ) = boosted_trees_ops.calculate_best_gains_per_feature(\n          node_id_range,\n          stats_summary_list,\n          l1=l1,\n          l2=0.0,\n          tree_complexity=0.0,\n          min_node_weight=0,\n          max_splits=max_splits)\n\n      self.assertAllEqual([[0, 1], [1, 1]], self.evaluate(thresholds_list))\n\n      self.assertAllEqual([[1, 2], [1, 2]], self.evaluate(node_ids_list))\n      self.assertAllClose([[[0.0], [0.3965517]], [[-0.4], [-0.5]]],\n                          self.evaluate(left_node_contribs_list))\n\n      self.assertAllClose([[[-0.3333333], [-0.5]], [[0.0], [0.396552]]],\n                          self.evaluate(right_node_contribs_list))\n\n      # Gain should also include an adjustment of the gradient by l1.\n      self.assertAllClose([[0.0, 0.191207], [0.01, 0.191207]],\n                          self.evaluate(gains_list))\n\n  def testCalculateBestMultiDimFeatureSplitsWithL1_v2_op(self):\n    \"\"\"Testing best split calculation with L1.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.1,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    # Gain should also include an adjustment of the gradient by l1.\n    self.assertAllClose([0.01, 0.191207], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[-0.4], [-0.5]], left_node_contribs)\n    self.assertAllClose([[0.], [0.396552]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureSplitsWithMissingValuesL1_v2_op(self):\n    \"\"\"Testing best split calculation with L1.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.1,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    # Gain should also include an adjustment of the gradient by l1.\n    # (0.36-0.1)^2/0.57 + 0 - (0.31-0.1)^2/0.63 = 0.048597\n    # (0.37-0.1)^2/0.48 + (-0.4+0.1)^2/0.5 = 0.331875\n    self.assertAllClose([0.048597, 0.331875], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    # -(0.36-0.1)/0.57 = -0.45614\n    # -(0.37-0.1)/0.48 = -0.5625\n    self.assertAllClose([[-0.45614], [-0.5625]], left_node_contribs)\n    # -(-0.4+0.1)/0.5 = 0.6\n    self.assertAllClose([[0.], [0.6]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureEqualitySplitsWithL1_v2_op(self):\n    \"\"\"Testing best split calculation with L1.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['equality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.1,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    # 0.048597 = 0 + 0.26^2/0.57 - 0.21^2/0.63\n    # 0.501868 = 0.3^2/0.5 + 0.27^2/0.48 - 0\n    self.assertAllClose([0.048597, 0.331875], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([2, 2], thresholds)\n    # # The left node contrib will be later added to the previous node value to\n    # # make the left node value, and the same for right node contrib.\n    # left contrib 0 (-0.05>-0.1), 0.6 = 0.3/0.5\n    self.assertAllClose([[0], [0.6]], left_node_contribs)\n    # right contrib -0.45614 = -0.26/0.57, -0.5625 = -0.27/0.48\n    self.assertAllClose([[-0.45614], [-0.5625]], right_node_contribs)\n    self.assertAllEqual([_EQUALITY_DEFAULT_RIGHT] * 2, split_types)\n\n  def testSparseCalculateBestSplitsWithL1(self):\n    node_id_range = [1, 3]\n    (summary_indices, summary_values,\n     summary_shape) = self._get_sparse_stats_summary_for_split()\n\n    (node_ids, gains, feature_dimensions, thresholds, left_node_contribs,\n     right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.sparse_calculate_best_feature_split(\n             node_id_range,\n             summary_indices,\n             summary_values,\n             summary_shape,\n             l1=0.1,\n             l2=0.,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.048597, 0.331875], gains)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.45614], [-0.5625]], left_node_contribs)\n    self.assertAllClose([[0.0], [0.6]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestGainsWithTreeComplexity_v1_op(self):\n    \"\"\"Testing best gain calculation with tree complexity.\"\"\"\n    with self.cached_session() as sess:\n      max_splits = 7\n      node_id_range = [1, 3]  # node 1 through 2 will be processed.\n      stats_summary_list = self._get_stats_summary_for_split()\n\n      l2 = 0.1\n      tree_complexity = 3.\n      (node_ids_list, gains_list, thresholds_list, left_node_contribs_list,\n       right_node_contribs_list\n      ) = boosted_trees_ops.calculate_best_gains_per_feature(\n          node_id_range,\n          stats_summary_list,\n          l1=0.0,\n          l2=l2,\n          tree_complexity=tree_complexity,\n          min_node_weight=0,\n          max_splits=max_splits)\n\n      self.assertAllEqual([[1, 2], [1, 2]], self.evaluate(node_ids_list))\n\n      self.assertAllClose([[-3., -2.66068625], [-2.98120904, -2.66068625]],\n                          self.evaluate(gains_list))\n\n      self.assertAllEqual([[0, 1], [1, 1]], self.evaluate(thresholds_list))\n      # The left node contrib will be later added to the previous node value to\n      # make the left node value, and the same for right node contrib.\n      self.assertAllClose([[[0.], [.485294]], [[-.5], [-.6]]],\n                          self.evaluate(left_node_contribs_list))\n      self.assertAllClose([[[-.424658], [-.6]], [[-.043478], [.485294]]],\n                          self.evaluate(right_node_contribs_list))\n\n  def testCalculateBestMultiDimFeatureSplitsWithTreeComplexity_v2_op(self):\n    \"\"\"Testing best split calculation with tree complexity.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=3,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    # Gain should also include an adjustment of the gradient by l1.\n    self.assertAllClose([-2.98120904, -2.66068625], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 0], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[-0.5], [0.485294]], left_node_contribs)\n    self.assertAllClose([[-0.043478], [-.6]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureSplitsWMissingValsTreeComplexity_v2_op(\n      self):\n    \"\"\"Testing best split calculation with tree complexity.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=3,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    # Gain should also include an adjustment of the gradient by l1.\n    self.assertAllClose([-2.922586, -2.498132], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[-0.537313], [-0.637931]], left_node_contribs)\n    self.assertAllClose([[0.3125], [0.666667]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureEqualitySplitsWithTreeComplexity_v2_op(\n      self):\n    \"\"\"Testing best split calculation with tree complexity.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['equality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=3,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    # -2.922586 = 0.05^2/0.16 + 0.36^2/0.67 - 0.31^2/0.73 - 3\n    # -2.498132 = 0.4^2/0.6 + 0.37^2/0.58 - 0.03^2/1.08 - 3\n    self.assertAllClose([-2.922586, -2.498132], gains)\n    self.assertAllEqual([2, 2], thresholds)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    # # The left node contrib will be later added to the previous node value to\n    # # make the left node value, and the same for right node contrib.\n    # left contrib 0.3125 = 0.05/0.16, 0.6667 = 0.4/0.6\n    self.assertAllClose([[0.3125], [0.666667]], left_node_contribs)\n    # right contrib -0.5373 = -0.36/0.67, -0.6379 = -0.37/0.58\n    self.assertAllClose([[-0.537313], [-0.637931]], right_node_contribs)\n    self.assertAllEqual([_EQUALITY_DEFAULT_RIGHT] * 2, split_types)\n\n  def testSparseCalculateBestSplitsWithTreeComplexity(self):\n    \"\"\"Testing best split calculation with tree complexity.\"\"\"\n    node_id_range = [1, 3]\n    (summary_indices, summary_values,\n     summary_shape) = self._get_sparse_stats_summary_for_split()\n\n    (node_ids, gains, feature_dimensions, thresholds, left_node_contribs,\n     right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.sparse_calculate_best_feature_split(\n             node_id_range,\n             summary_indices,\n             summary_values,\n             summary_shape,\n             l1=0.,\n             l2=0.1,\n             tree_complexity=3.,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([-2.922586, -2.498132], gains)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[-0.537313], [-0.637931]], left_node_contribs)\n    self.assertAllClose([[0.3125], [0.666667]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestGainsWithMinNodeWeight_v1_op(self):\n    \"\"\"Testing Gain calculation with min node weight.\"\"\"\n    with self.cached_session() as sess:\n      max_splits = 7\n      node_id_range = [1, 3]  # node 1 through 2 will be processed.\n      stats_summary_list = [\n          [\n              [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n              [[0., 0.], [.15, .036], [.06, .07], [.1, .2]],  # node 1\n              [[0., 0.], [-.33, .68], [0., 0.], [.3, .4]],  # node 2\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n          ],  # feature 0\n          [\n              [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n              [[0., 0.], [.3, .5], [-.05, .6], [.06, .07]],  # node 1\n              [[.1, .1], [.2, .03], [-.4, .05], [.07, .08]],  # node 2\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n          ],  # feature 1\n      ]  # feature_dim * shape=[max_splits, num_buckets, 2]\n\n      (node_ids_list, gains_list, thresholds_list, left_node_contribs_list,\n       right_node_contribs_list\n      ) = boosted_trees_ops.calculate_best_gains_per_feature(\n          node_id_range,\n          stats_summary_list,\n          l1=0.0,\n          l2=0.0,\n          tree_complexity=0.0,\n          min_node_weight=1,\n          max_splits=max_splits)\n\n      # We can't split node 1 on feature 1 and node 2 on feature 2 because of\n      # the min node weight.\n      self.assertAllEqual([[2], [1]], self.evaluate(node_ids_list))\n      self.assertAllClose([[0.384314], [0.098013]], self.evaluate(gains_list))\n      self.assertAllEqual([[1], [1]], self.evaluate(thresholds_list))\n      self.assertAllClose([[[0.4852941]], [[-.6]]],\n                          self.evaluate(left_node_contribs_list))\n      self.assertAllClose([[[-0.75]], [[-0.014925]]],\n                          self.evaluate(right_node_contribs_list))\n\n  def testCalculateMultiDimBestSplitsWithMinNodeWeight_v2_op(self):\n    \"\"\"Testing best split calculation with min node weight.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summary = np.asarray([\n        [\n            [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .61], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .68], [0., 0.], [.3, .4]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 0\n        [\n            [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .6], [.06, .07]],  # node 1\n            [[.1, 1.], [.2, -.05], [-.4, .05], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    # Reshape to [max_splits, feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summary, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=1,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    # Gain should also include an adjustment of the gradient by l1.\n    self.assertAllClose([0.098013, 0.931596], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[-.6], [-0.315789]], left_node_contribs)\n    self.assertAllClose([[-0.014925], [2.53846]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateMultiDimBestSplitsWithMissingValuesMinNodeWeight_v2_op(self):\n    \"\"\"Testing best split calculation with min node weight.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summary = np.asarray([\n        [\n            [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .61], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .68], [0., 0.], [.3, .4]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 0\n        [\n            [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .6], [.06, .07]],  # node 1\n            [[.1, 1.], [.2, -.05], [-.4, .05], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    # Reshape to [max_splits, feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summary, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=1,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    # Gain should also include an adjustment of the gradient by l1.\n    self.assertAllClose([0.149398, 3.332075], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[-0.631579], [-0.359223]], left_node_contribs)\n    self.assertAllClose([[0.083333], [7.999989]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testSparseCalculateBestSplitsWithMinNodeWeight(self):\n    \"\"\"Testing best split calculation with min node weight.\"\"\"\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summary = np.asarray([\n        [\n            [[0., 0.], [.0, .0], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .61], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .68], [0., 0.], [.3, .4]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 0\n        [\n            [[0., 0.], [0., 0.], [.0, .0], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [-.05, .6], [.3, .5], [.06, .07]],  # node 1\n            [[.1, 1.], [.2, -.05], [-.4, .05], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    # reshape to [max_splits, feature_dim, num_buckets, 2]\n    stats_summary = np.moveaxis(stats_summary, 0, 1)\n\n    (summary_indices, summary_values,\n     summary_shape) = self._get_sparse_stats_summary_for_split(stats_summary)\n\n    (node_ids, gains, feature_dimensions, thresholds, left_node_contribs,\n     right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.sparse_calculate_best_feature_split(\n             node_id_range,\n             summary_indices,\n             summary_values,\n             summary_shape,\n             l1=0.,\n             l2=0.,\n             tree_complexity=0.,\n             min_node_weight=1,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.149398, 3.332079], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[0.083333], [-0.359223]], left_node_contribs)\n    self.assertAllClose([[-0.631579], [7.999998]], right_node_contribs)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_RIGHT, _INEQUALITY_DEFAULT_LEFT],\n                        split_types)\n\n  def testCalculateBestGainsWithMinNodeWeightNoSplitOnFeaturePossible_v1_op(\n      self):\n    \"\"\"Testing Gain calculation without any regularization.\"\"\"\n    with self.cached_session() as sess:\n      max_splits = 7\n      node_id_range = [1, 3]  # node 1 through 2 will be processed.\n      stats_summary_list = [\n          [\n              [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n              [[0., 0.], [.15, .0036], [.06, .007], [.1, .2]],  # node 1\n              [[0., 0.], [-.33, .068], [0., 0.], [.3, .04]],  # node 2\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n          ],  # feature 0\n          [\n              [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n              [[0., 0.], [.3, .5], [-.05, .6], [.06, .07]],  # node 1\n              [[.1, .1], [.2, .03], [-.4, .05], [.07, .08]],  # node 2\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n          ],  # feature 1\n      ]  # feature_dim * shape=[max_splits, num_buckets, 2]\n\n      (node_ids_list, _, _, _,\n       _) = boosted_trees_ops.calculate_best_gains_per_feature(\n           node_id_range,\n           stats_summary_list,\n           l1=0.0,\n           l2=0.0,\n           tree_complexity=0.0,\n           min_node_weight=1,\n           max_splits=max_splits)\n\n      # We can't split either of the nodes on the first feature\n      self.assertEqual(2, len(self.evaluate(node_ids_list)))\n      self.assertAllEqual([], self.evaluate(node_ids_list)[0])\n      self.assertAllEqual([1], self.evaluate(node_ids_list)[1])\n\n      # Now check when we can't split on any feature\n      (node_ids_list, _, _, _,\n       _) = boosted_trees_ops.calculate_best_gains_per_feature(\n           node_id_range,\n           stats_summary_list,\n           l1=0.0,\n           l2=0.0,\n           tree_complexity=0.0,\n           min_node_weight=10,\n           max_splits=max_splits)\n      self.assertAllEqual([[], []], self.evaluate(node_ids_list))\n\n  def testCalculateBestMultiDimFeatureSplitsWithNoSplitOnFeaturePossible_v2_op(\n      self):\n    \"\"\"Testing best split calculation with min node weight and no split.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summary = np.asarray([\n        [\n            [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .7], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .068], [0., 0.], [.3, .04]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 0\n        [\n            [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .06], [.06, .7]],  # node 1\n            [[.1, .1], [.2, -.05], [-.4, .05], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    # Reshape to [max_splits, feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summary, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, _, _, _, _, _, _,\n     _) = boosted_trees_ops.calculate_best_feature_split_v2(\n         node_id_range, [stats_summary],\n         split_types=['inequality'],\n         candidate_feature_ids=candidate_feature_ids,\n         l1=0.0,\n         l2=0.0,\n         tree_complexity=0.0,\n         min_node_weight=1,\n         logits_dimension=1)\n\n    # We can't split either of the nodes on the first feature.\n    self.assertAllEqual([1], node_ids)\n\n    # Now check when we can't split on any feature.\n    (node_ids, _, _, _, _, _, _,\n     _) = boosted_trees_ops.calculate_best_feature_split_v2(\n         node_id_range, [stats_summary],\n         split_types=['inequality'],\n         candidate_feature_ids=candidate_feature_ids,\n         l1=0.0,\n         l2=0.0,\n         tree_complexity=0.0,\n         min_node_weight=10,\n         logits_dimension=1)\n    self.assertAllEqual([], node_ids)\n\n  def testCalculateBestMultiDimFeatureEqualitySplitsWithNoSplitPossible_v2_op(\n      self):\n    \"\"\"Testing best split calculation with min node weight and no split.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summary = np.asarray([\n        [\n            [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .7], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .068], [0., 0.], [.3, .04]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 0\n        [\n            [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .06], [.06, .7]],  # node 1\n            [[.1, .1], [.2, -.05], [-.4, .05], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    # Reshape to [max_splits, feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summary, 0, 1)\n\n    (node_ids, _, _, _, _, _, _,\n     _) = boosted_trees_ops.calculate_best_feature_split_v2(\n         node_id_range, [stats_summary],\n         split_types=['equality'],\n         candidate_feature_ids=candidate_feature_ids,\n         l1=0.0,\n         l2=0.0,\n         tree_complexity=0.0,\n         min_node_weight=1,\n         logits_dimension=1)\n\n    # We can't split either of the nodes on the first feature\n    self.assertAllEqual([1], node_ids)\n\n    # Now check when we can't split on any feature\n    (node_ids, _, _, _, _, _, _,\n     _) = boosted_trees_ops.calculate_best_feature_split_v2(\n         node_id_range, [stats_summary],\n         split_types=['equality'],\n         candidate_feature_ids=candidate_feature_ids,\n         l1=0.0,\n         l2=0.0,\n         tree_complexity=0.0,\n         min_node_weight=10,\n         logits_dimension=1)\n    self.assertAllEqual([], node_ids)\n\n  def testSparseCalculateBestSplitsWithMinNodeWeightNoSplitOnFeature(self):\n    \"\"\"Testing best split calculation with min node weight and no split.\"\"\"\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summary = np.asarray([\n        [\n            [[0., 0.], [.0, .0], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .7], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .068], [0., 0.], [.3, .04]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 0\n        [\n            [[0., 0.], [0., 0.], [.0, .0], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .6], [.06, .07]],  # node 1\n            [[.1, .1], [.2, .03], [-.4, .05], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    # reshape to [max_splits, feature_dim, num_buckets, 2]\n    stats_summary = np.moveaxis(stats_summary, 0, 1)\n    (summary_indices, summary_values,\n     summary_shape) = self._get_sparse_stats_summary_for_split(stats_summary)\n\n    (node_ids, _, _, _, _, _, _) = self.evaluate(\n        boosted_trees_ops.sparse_calculate_best_feature_split(\n            node_id_range,\n            summary_indices,\n            summary_values,\n            summary_shape,\n            l1=0.,\n            l2=0.,\n            tree_complexity=0.,\n            min_node_weight=1,\n            logits_dimension=1))\n\n    # We can't split either of the nodes on the first feature\n    self.assertAllEqual([1], node_ids)\n\n    # Now check when we can't split on any feature\n    (node_ids, _, _, _, _, _, _) = self.evaluate(\n        boosted_trees_ops.sparse_calculate_best_feature_split(\n            node_id_range,\n            summary_indices,\n            summary_values,\n            summary_shape,\n            l1=0.,\n            l2=0.,\n            tree_complexity=0.,\n            min_node_weight=10,\n            logits_dimension=1))\n    self.assertAllEqual([], node_ids)\n\n  @test_util.run_deprecated_v1\n  def testMakeStatsSummarySimple(self):\n    \"\"\"Simple test for MakeStatsSummary.\"\"\"\n    expected_stats_summary = np.asarray([1., 5., 2., 6., 3., 7., 4., 8.])\n    self.assertAllClose(\n        expected_stats_summary.reshape((1, 2, 2, 2)),\n        boosted_trees_ops.make_stats_summary(\n            node_ids=[0, 0, 1, 1],\n            gradients=[[1.], [2.], [3.], [4.]],\n            hessians=[[5.], [6.], [7.], [8.]],\n            bucketized_features_list=[[0, 1, 0, 1]],\n            max_splits=2,\n            num_buckets=2))\n\n  @test_util.run_deprecated_v1\n  def testAggregateStatsSimple(self):\n    # Get the same result as MakeStatsSummary Op.\n    expected_stats_summary = np.asarray(\n        [1., 5., 2., 6., 0., 0., 3., 7., 4., 8., 0., 0.])\n    # shape=[max_splits, num_buckets, feature_dim, stats_dim]\n    expected_stats_summary = np.reshape(expected_stats_summary, (2, 3, 1, 2))\n    # Reshape feature dim and bucket id axes\n    expected_stats_summary = np.swapaxes(expected_stats_summary, 1, 2)\n    self.assertAllClose(\n        expected_stats_summary,\n        boosted_trees_ops.boosted_trees_aggregate_stats(\n            node_ids=[0, 0, 1, 1],\n            gradients=[[1.], [2.], [3.], [4.]],\n            hessians=[[5.], [6.], [7.], [8.]],\n            feature=[[0], [1], [0], [1]],\n            max_splits=2,\n            num_buckets=2))\n\n  def testMakeStatsSummaryAccumulate(self):\n    \"\"\"Tests that Summary actually accumulates.\"\"\"\n    with self.cached_session():\n      max_splits = 3\n      num_buckets = 4\n      node_ids = [1, 1, 2, 2, 1, 1, 2, 0]\n      gradients = [[.1], [.2], [.3], [-.4], [-.05], [.06], [.07], [.08]]\n      hessians = [[.2], [.3], [.4], [.5], [.06], [.07], [.08], [.09]]\n\n      # Tests a single feature.\n      bucketized_features = [[3, 1, 2, 0, 1, 2, 0, 1]]\n      result = boosted_trees_ops.make_stats_summary(\n          node_ids, gradients, hessians, bucketized_features, max_splits,\n          num_buckets)  # shape=[max_splits, num_buckets, feature_dim, 2]\n      self.assertAllClose(\n          [[\n              [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0\n              [[0., 0.], [.15, .36], [.06, .07], [.1, .2]],  # node 1\n              [[-.33, .58], [0., 0.], [.3, .4], [0., 0.]],  # node 2\n          ]],\n          self.evaluate(result))\n\n  def testAggregateStatsAccumulate(self):\n    \"\"\"Tests that Summary actually accumulates.\"\"\"\n    max_splits = 3\n    num_buckets = 4\n    node_ids = [1, 1, 2, 2, 1, 1, 2, 0]\n    gradients = [[.1], [.2], [.3], [-.4], [-.05], [.06], [.07], [.08]]\n    hessians = [[.2], [.3], [.4], [.5], [.06], [.07], [.08], [.09]]\n\n    # Tests a single feature.\n    bucketized_features = [[3], [1], [2], [0], [1], [2], [0], [1]]\n    result = boosted_trees_ops.boosted_trees_aggregate_stats(\n        node_ids, gradients, hessians, bucketized_features, max_splits,\n        num_buckets)\n    # shape=[max_splits, num_buckets, feature_dim, stats_dim]\n    # Get the same result as MakeStatsSummary Op.\n    expected_stats_summary = [\n        [[[0., 0.]], [[.08, .09]], [[0., 0.]], [[0., 0.]], [[0., 0.]]],\n        [[[0., 0.]], [[.15, .36]], [[.06, .07]], [[.1, .2]], [[0., 0.]]],\n        [[[-.33, .58]], [[0., 0.]], [[.3, .4]], [[0., 0.]], [[0., 0.]]],\n    ]\n    # Swap feature dim and bucket id axis\n    expected_stats_summary = np.swapaxes(expected_stats_summary, 1, 2)\n    self.assertAllClose(expected_stats_summary, result)\n\n  def testAggregateStatsAccumulateWithMissingValue(self):\n    \"\"\"Tests that Summary actually accumulates.\"\"\"\n    max_splits = 3\n    num_buckets = 4\n    node_ids = [1, 1, 2, 2, 1, 1, 2, 0]\n    gradients = [[.1], [.2], [.3], [-.4], [-.05], [.06], [.07], [.08]]\n    hessians = [[.2], [.3], [.4], [.5], [.06], [.07], [.08], [.09]]\n\n    # Tests a single feature.\n    missing_feature = -1\n    bucketized_features = [[3], [1], [2], [0], [missing_feature], [2], [0], [1]]\n    result = boosted_trees_ops.boosted_trees_aggregate_stats(\n        node_ids, gradients, hessians, bucketized_features, max_splits,\n        num_buckets)\n    # shape=[max_splits, num_buckets, feature_dim, stats_dim]\n    # Get the same result as MakeStatsSummary Op.\n    expected_stats_summary = [\n        [[[0., 0.]], [[.08, .09]], [[0., 0.]], [[0., 0.]], [[0., 0.]]],\n        [[[0., 0.]], [[.2, .3]], [[.06, .07]], [[.1, .2]], [[-.05, .06]]],\n        [[[-.33, .58]], [[0., 0.]], [[.3, .4]], [[0., 0.]], [[0., 0.]]],\n    ]\n    # Swap feature dim and bucket id axis\n    expected_stats_summary = np.swapaxes(expected_stats_summary, 1, 2)\n    self.assertAllClose(expected_stats_summary, result)\n\n  def testMakeStatsSummaryMultipleFeatures(self):\n    \"\"\"Tests that MakeStatsSummary works for multiple features.\"\"\"\n    with self.cached_session():\n      max_splits = 3\n      num_buckets = 4\n      node_ids = [1, 1, 2, 2, 1, 1, 2, 0]\n      gradients = [[.1], [.2], [.3], [-.4], [-.05], [.06], [.07], [.08]]\n      hessians = [[.2], [.3], [.4], [.5], [.06], [.07], [.08], [.09]]\n\n      # Tests multiple features.\n      # The output from another feature will stored be in 3rd dimension.\n      bucketized_features = [[3, 1, 2, 0, 1, 2, 0, 1], [0, 0, 0, 2, 2, 3, 3, 2]]\n      result = boosted_trees_ops.make_stats_summary(\n          node_ids, gradients, hessians, bucketized_features, max_splits,\n          num_buckets)  # shape=[max_splits, num_buckets, feature_dim, 2]\n      self.assertAllClose(\n          [\n              [\n                  [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0\n                  [[0., 0.], [.15, .36], [.06, .07], [.1, .2]],  # node 1\n                  [[-.33, .58], [0., 0.], [.3, .4], [0., 0.]],  # node 2\n              ],  # feature 0\n              [\n                  [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0\n                  [[.3, .5], [0., 0.], [-.05, .06], [.06, .07]],  # node 1\n                  [[.3, .4], [0., 0.], [-.4, .5], [.07, .08]],  # node 2\n              ],  # feature 1\n          ],\n          self.evaluate(result))\n\n  def testAggregatesSummaryMultipleDimensionFeature(self):\n    \"\"\"Tests that MakeStatsSummary works for multiple features.\"\"\"\n    expected_stats_summary = np.asarray(\n        [[0, 0, 0, 0, .08, .09, 0, 0, 0, 0, .08, .09, 0, 0, 0, 0, 0, 0, 0, 0],\n         [\n             0, 0, .3, .5, .15, .36, 0, 0, .06, .07, -.05, .06, .1, .2, .06,\n             .07, 0, 0, 0, 0\n         ],\n         [\n             -.33, .58, .3, .4, 0, 0, 0, 0, .3, .4, -.4, .5, 0, 0, .07, .08, 0,\n             0, 0, 0\n         ]])\n    with self.cached_session():\n      max_splits = 3\n      num_buckets = 4\n      node_ids = [1, 1, 2, 2, 1, 1, 2, 0]\n      gradients = [[.1], [.2], [.3], [-.4], [-.05], [.06], [.07], [.08]]\n      hessians = [[.2], [.3], [.4], [.5], [.06], [.07], [.08], [.09]]\n\n      # Tests multiple features.\n      bucketized_features = [[3, 0], [1, 0], [2, 0], [0, 2], [1, 2], [2, 3],\n                             [0, 3], [1, 2]]\n      result = boosted_trees_ops.boosted_trees_aggregate_stats(\n          node_ids, gradients, hessians, bucketized_features, max_splits,\n          num_buckets)\n      # Reshape to [max_splits, num_buckets, feature_dim, stats_dim]\n      expected_stats_summary = np.reshape(expected_stats_summary, (3, 5, 2, 2))\n      # Swap feature_dim and bucket_id axis\n      expected_stats_summary = np.swapaxes(expected_stats_summary, 1, 2)\n      self.assertAllClose(expected_stats_summary, result)\n\n  def testAggregateStatsMultiClass(self):\n    \"\"\"Tests that Summary actually accumulates.\"\"\"\n    with self.cached_session():\n      max_splits = 3\n      num_buckets = 4\n      node_ids = [1, 1, 2, 2, 1, 1, 2, 0]\n      gradients = [[.1, .2], [.2, .4], [.3, .6], [-.4, -.8], [-.05, -.1],\n                   [.06, .12], [.07, .14], [.08, .16]]\n      hessians = [[.2, .6], [.3, .9], [.4, 1.2], [.5, 1.5], [.06, .18],\n                  [.07, .21], [.08, .24], [.09, .27]]\n\n      # Tests a single feature.\n      bucketized_features = [[3], [1], [2], [0], [1], [2], [0], [1]]\n      result = boosted_trees_ops.boosted_trees_aggregate_stats(\n          node_ids, gradients, hessians, bucketized_features, max_splits,\n          num_buckets)\n      # shape=[max_splits, num_buckets, feature_dim, stats_dim]\n      expected_stats_summary = [\n          [[[0., 0., 0., 0.]], [[.08, .16, .09, .27]], [[0., 0., 0., 0.]],\n           [[0., 0., 0., 0.]], [[0., 0., 0., 0.]]],\n          [[[0., 0., 0., 0.]], [[.15, 0.3, .36, 1.08]], [[.06, 0.12, .07,\n                                                          0.21]],\n           [[.1, .2, .2, .6]], [[0., 0., 0., 0.]]],\n          [[[-.33, -.66, .58, 1.74]], [[0., 0., 0., 0.]], [[.3, .6, .4, 1.2]],\n           [[0., 0., 0., 0.]], [[0., 0., 0., 0.]]],\n      ]\n      expected_stats_summary = np.swapaxes(expected_stats_summary, 1, 2)\n      self.assertAllClose(expected_stats_summary, result)\n\n  def _get_dense_summaries_from_sparse_features(self, max_splits, num_buckets,\n                                                batch_size, feature_dims,\n                                                logits_dims, hess_dims):\n    np.random.seed(0)\n    stats_dims = logits_dims + hess_dims\n    node_ids = np.random.randint(max_splits, size=batch_size)\n    gradients = np.random.uniform(5.0, size=(batch_size, logits_dims))\n    hessians = np.random.uniform(5.0, size=(batch_size, hess_dims))\n    dense_indices = np.random.randint(2, size=(batch_size, feature_dims))\n    feature_indices = np.argwhere(dense_indices == 1)\n    missing_feature_indices = np.argwhere(dense_indices == 0)\n    feature_values = np.random.randint(num_buckets, size=len(feature_indices))\n    feature_shape = np.asarray([batch_size, feature_dims])\n    # Last bucket is for missing values.\n    dense_summary = np.zeros(\n        (max_splits, feature_dims, num_buckets + 1, stats_dims))\n    for (instance, f_dim), bucket in zip(feature_indices, feature_values):\n      node_id = node_ids[instance]\n      dense_summary[node_id][f_dim][bucket] += np.concatenate(\n          [gradients[instance], hessians[instance]])\n\n    for instance, f_dim in missing_feature_indices:\n      node_id = node_ids[instance]\n      dense_summary[node_id][f_dim][num_buckets] += np.concatenate(\n          [gradients[instance], hessians[instance]])\n\n    return (node_ids, gradients, hessians, feature_indices, feature_values,\n            feature_shape, dense_summary)\n\n  def testMakeSparseStatsSummarySingleFeatureDimension(self):\n    batch_size = 10\n    max_splits = 2\n    num_buckets = 2\n    feature_dims = 1\n    logits_dims = 1\n    hess_dims = 1\n\n    (node_ids, gradients, hessians, feature_indices, feature_values,\n     feature_shape,\n     expected_dense_summary) = self._get_dense_summaries_from_sparse_features(\n         max_splits, num_buckets, batch_size, feature_dims, logits_dims,\n         hess_dims)\n\n    (summary_indices, summary_values,\n     summary_shape) = boosted_trees_ops.boosted_trees_sparse_aggregate_stats(\n         node_ids, gradients, hessians, feature_indices, feature_values,\n         feature_shape, max_splits, num_buckets)\n    dense_result = sparse_ops.sparse_to_dense(summary_indices, summary_shape,\n                                              summary_values)\n    self.assertAllClose(expected_dense_summary, dense_result)\n\n  def testMakeSparseStatsSummaryMultiDimFeature(self):\n    batch_size = 10\n    max_splits = 2\n    num_buckets = 2\n    feature_dims = 1\n    logits_dims = 1\n    hess_dims = 1\n\n    (node_ids, gradients, hessians, feature_indices, feature_values,\n     feature_shape,\n     expected_dense_summary) = self._get_dense_summaries_from_sparse_features(\n         max_splits, num_buckets, batch_size, feature_dims, logits_dims,\n         hess_dims)\n\n    (summary_indices, summary_values,\n     summary_shape) = boosted_trees_ops.boosted_trees_sparse_aggregate_stats(\n         node_ids, gradients, hessians, feature_indices, feature_values,\n         feature_shape, max_splits, num_buckets)\n    dense_result = sparse_ops.sparse_to_dense(summary_indices, summary_shape,\n                                              summary_values)\n    self.assertAllClose(expected_dense_summary, dense_result)\n\n  def testMakeSparseStatsSummaryMultiClass(self):\n    batch_size = 10\n    max_splits = 2\n    num_buckets = 2\n    feature_dims = 1\n    logits_dims = 2\n    hess_dims = 2\n\n    (node_ids, gradients, hessians, feature_indices, feature_values,\n     feature_shape,\n     expected_dense_summary) = self._get_dense_summaries_from_sparse_features(\n         max_splits, num_buckets, batch_size, feature_dims, logits_dims,\n         hess_dims)\n\n    (summary_indices, summary_values,\n     summary_shape) = boosted_trees_ops.boosted_trees_sparse_aggregate_stats(\n         node_ids, gradients, hessians, feature_indices, feature_values,\n         feature_shape, max_splits, num_buckets)\n    dense_result = sparse_ops.sparse_to_dense(summary_indices, summary_shape,\n                                              summary_values)\n    self.assertAllClose(expected_dense_summary, dense_result)\n\n  def testMakeSparseStatsSummaryMultiClassAndMultiFeatureDim(self):\n    batch_size = 10\n    max_splits = 2\n    num_buckets = 2\n    feature_dim = 2\n    logits_dims = 2\n    hess_dims = 2\n\n    (node_ids, gradients, hessians, feature_indices, feature_values,\n     feature_shape,\n     expected_dense_summary) = self._get_dense_summaries_from_sparse_features(\n         max_splits, num_buckets, batch_size, feature_dim, logits_dims,\n         hess_dims)\n\n    (summary_indices, summary_values,\n     summary_shape) = boosted_trees_ops.boosted_trees_sparse_aggregate_stats(\n         node_ids, gradients, hessians, feature_indices, feature_values,\n         feature_shape, max_splits, num_buckets)\n    dense_result = sparse_ops.sparse_to_dense(summary_indices, summary_shape,\n                                              summary_values)\n    self.assertAllClose(expected_dense_summary, dense_result)\n\n  def _verify_precision(self, length):\n    with self.cached_session():\n      max_splits = 1\n      num_buckets = 1\n      node_ids = array_ops.fill([length], 0)\n\n      gradients = constant_op.constant(\n          2.0 / length, dtype=dtypes.float32, shape=[length, 1])\n      hessians = constant_op.constant(\n          0.2 / length, dtype=dtypes.float32, shape=[length, 1])\n\n      bucketized_features = array_ops.zeros([length], dtype=dtypes.int32)\n\n      result = boosted_trees_ops.make_stats_summary(\n          node_ids, gradients, hessians, [bucketized_features], max_splits,\n          num_buckets)  # shape=[max_splits, num_buckets, feature_dim, 2]\n\n      self.assertAllClose([[[[2., 0.2]]]], self.evaluate(result))\n\n  def testMakeStatsSummaryNumericalPrecisionSmallBatch(self):\n    \"\"\"Tests numeric precision.\"\"\"\n    self._verify_precision(length=2000)\n\n  def testMakeStatsSummaryNumericalPrecisionMediumBatch(self):\n    \"\"\"Tests numeric precision.\"\"\"\n    self._verify_precision(length=100000)\n\n  def testMakeStatsSummaryNumericalPrecisionLargeBatch(self):\n    \"\"\"Tests numeric precision.\"\"\"\n    self._verify_precision(length=1000000)\n\n  def testMakeStatsSummaryNumericalPrecisionMegaBatch(self):\n    \"\"\"Tests numeric precision.\"\"\"\n    self._verify_precision(length=50000000)\n\n\nclass BestMultiDimFeatureSplitMultiClassV2Op(StatsOpsTest):\n  \"\"\"Tests multi-class/multi-regression for best splits using V2 op.\"\"\"\n\n  logits_dim = 2\n\n  def _get_stats_summary_for_split_diagonal_hessian(self):\n    summary = [\n        [[[0., 0., 0., 0.], [0.08, 0.2, 0.09, 0.3], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]],\n         [[0., 0., 0., 0.], [0., 0., 0., 0.], [0.08, 0.2, 0.09, 0.3],\n          [0., 0., 0., 0.]]],  # node 0\n        [[[0., 0., 0., 0.], [-0.25, -0.1, 0.36, 0.2], [-0.14, 0.25, 0.07, 0.18],\n          [0.1, 0.235, 0.2, 0.06]],\n         [[0., 0., 0., 0.], [-0.3, 0.12, 0.5, 0.31], [-0.05, 0.115, 0.11, 0.09],\n          [0.06, 0.15, 0.02, 0.04]]],  # node 1\n        [[[0., 0., 0., 0.], [-0.03, 0.21, 0.28, 0.44], [0., 0., 0., 0.],\n          [0.3, 0.04, 0.4, 0.41]],\n         [[0.4, 0.188, 0.16, -0.03], [0.2, -0.088, 0.1, -0.24],\n          [-0.4, -0.06, 0.5, 0.15], [0.07, 0.21, -0.08, 0.97]]],  # node 2\n        [[[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]],\n         [[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]]],  # node 3\n        [[[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]],\n         [[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]]],  # node 4\n        [[[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]],\n         [[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]]],  # node 5\n        [[[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]],\n         [[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]]]  # node 6\n    ]\n    # [max_splits, feature_dim, num_buckets, 4]\n    return np.array(summary)\n\n  def _add_feature_dim(self, stats_summary):\n    \"\"\"Add dimension for features; number of features will be 1.\"\"\"\n    return np.expand_dims(stats_summary, axis=1)\n\n  def testSumOfStatsSummaryValuesFromHelperFunction(self):\n    \"\"\"Sum of grads and hessians is correct from helper function.\"\"\"\n    # [max_splits, feature_dim, num_buckets, 4]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n    # Test that sum of grads/hessians are same for both features for all nodes.\n    # [max_splits, feature_dim, 4]\n    agg = stats_summary.sum(axis=2)  # Sum along buckets.\n    self.assertAllClose(agg[:, 0, :], agg[:, 1, :])  # There are two features.\n    # Test sum of hessians for each nodes. These values are used to evaluate if\n    # node meets min_node_weight criteria.\n    nodes_agg = agg[:, 0, :]\n    hessians = nodes_agg[:, self.logits_dim:]\n\n    def frobenius(x, **kwargs):\n      return np.sqrt(np.square(x).sum(**kwargs))\n\n    self.assertAllClose([0.3132092, 0.76843998, 1.08853112, 0., 0., 0., 0.],\n                        frobenius(hessians, axis=1))\n\n  def testCalculateBestFeatureSplitsSingleClassVsMultiClass(self):\n    \"\"\"Testing same results using same grads/hess with both single and multi.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n\n    # Build same stats summary in single class and multi-class form (using\n    # diagonal hessian).\n    empty = [0] * 2\n    stats_summary = [\n        [empty, [.08, .09], empty],  # node 0; ignored\n        [empty, [-0.25, 0.11], [0.1, 0.5]],  # node 1\n        [empty, [0.14, 0.1], empty],  # node 2\n        [empty, empty, empty],  # node 3; ignored\n    ]\n    # [max_splits, feature_dim, num_buckets, 2]\n    stats_summary = self._add_feature_dim(stats_summary)\n    diag_empty = [0] * 4\n    diag_stats_summary = [\n        [diag_empty, [0, .08, 0, 0.09], diag_empty],  # node 0; ignored\n        [diag_empty, [0, -0.25, 0, 0.11], [0, 0.1, 0, 0.5]],  # node 1\n        [diag_empty, [0, 0.14, 0, 0.1], diag_empty],  # node 2\n        [diag_empty, diag_empty, diag_empty],  # node 3; ignored\n    ]\n    # [max_splits, feature_dim, num_buckets, 4]\n    diag_stats_summary = self._add_feature_dim(diag_stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    (diag_node_ids, diag_gains, diag_feature_ids, diag_feature_dimensions,\n     diag_thresholds, diag_left_node_contribs, diag_right_node_contribs,\n     diag_split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [diag_stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=2))\n\n    self.assertAllEqual(node_ids, diag_node_ids)\n    self.assertAllClose(gains, diag_gains)\n    self.assertAllEqual(feature_ids, diag_feature_ids)\n    self.assertAllEqual(feature_dimensions, diag_feature_dimensions)\n    self.assertAllEqual(thresholds, diag_thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    zeros = np.zeros_like(left_node_contribs)\n    self.assertAllClose(\n        np.concatenate([zeros, left_node_contribs], axis=1),\n        diag_left_node_contribs)\n    self.assertAllClose(\n        np.concatenate([zeros, right_node_contribs], axis=1),\n        diag_right_node_contribs)\n    self.assertAllEqual(split_types, diag_split_types)\n\n  def testCalculateBestFeatureSplitsDiagonalVsFull(self):\n    \"\"\"Test results are same using diagonal hessian and full hessian.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n\n    # Build same stats summary in diagonal and full hessian form, respectively.\n    diag_empty = [0] * 4\n    diag_stats_summary = [\n        [diag_empty, [.08, .09, -.1, .2], diag_empty],  # node 0; ignored\n        [diag_empty, [.15, .36, .21, -.11], [.06, .07, .67, 0.5]],  # node 1\n        [diag_empty, [-.33, .58, -.2, -.31], diag_empty],  # node 2\n        [diag_empty, diag_empty, diag_empty],  # node 3; ignored\n    ]\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    diag_stats_summary = self._add_feature_dim(diag_stats_summary)\n    full_empty = [0] * 6\n    full_stats_summary = [\n        [full_empty, [.08, .09, -.1, 0, 0, .2], full_empty],  # node 0; ignored\n        [full_empty, [.15, .36, .21, 0, 0, -.11], [.06, .07, .67, 0, 0,\n                                                   0.5]],  # node 1\n        [full_empty, [-.33, .58, -.2, 0, 0, -.31], full_empty],  # node 2\n        [full_empty, full_empty, full_empty],  # node 3; ignored\n    ]\n    # [max_splits, feature_dim, num_buckets, logits_dim + logits_dim**2]\n    full_stats_summary = self._add_feature_dim(full_stats_summary)\n    (diag_node_ids, diag_gains, diag_feature_ids, diag_feature_dimensions,\n     diag_thresholds, diag_left_node_contribs, diag_right_node_contribs,\n     diag_split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [diag_stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    (full_node_ids, full_gains, full_feature_ids, full_feature_dimensions,\n     full_thresholds, full_left_node_contribs, full_right_node_contribs,\n     full_split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [full_stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    self.assertAllEqual(diag_node_ids, full_node_ids)\n    self.assertAllClose(diag_gains, full_gains)\n    self.assertAllEqual(diag_feature_ids, full_feature_ids)\n    self.assertAllEqual(diag_feature_dimensions, full_feature_dimensions)\n    self.assertAllEqual(diag_thresholds, full_thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose(diag_left_node_contribs, full_left_node_contribs)\n    self.assertAllClose(diag_right_node_contribs, full_right_node_contribs)\n    self.assertAllEqual(diag_split_types, full_split_types)\n\n  def testCalculateBestFeatureSplitsWithoutRegularization(self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.912981, 1.446218], gains)\n    self.assertAllEqual([2, 1], thresholds)\n    self.assertAllEqual([14, 14], feature_ids)\n    self.assertAllEqual([0, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[0.906977, -0.394737], [-2.307692, 0.370370]],\n                        left_node_contribs)\n    self.assertAllClose([[-0.5, -3.916667], [0.785714, -0.133928]],\n                        right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestFeatureSplitsWMissingValuesWoRegularization(self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.912981, 2.79444], gains)\n    self.assertAllEqual([0, 1], thresholds)\n    self.assertAllEqual([14, 14], feature_ids)\n    self.assertAllEqual([0, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.5, -3.916667], [-3.722223, -0.442857]],\n                        left_node_contribs)\n    self.assertAllClose([[0.906977, -0.394737], [0.8, 0.4]],\n                        right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestFeatureSplitsWithL2(self):\n    \"\"\"Testing best split calculation inith L2 regularization.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    l2 = 0.1\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=l2,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.475669, 1.009791], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllEqual([14, 14], feature_ids)\n    self.assertAllEqual([0, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[0.543478, 0.333333], [-1.666667, 0.588235]],\n                        left_node_contribs)\n    self.assertAllClose([[0.108108, -1.426471], [0.634615, -0.122951]],\n                        right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestFeatureSplitsWithMissingValuesL2(self):\n    \"\"\"Testing best split calculation inith L2 regularization.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n\n    l2 = 0.1\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=l2,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.475669, 3.467833], gains)\n    self.assertAllEqual([1, 0], thresholds)\n    self.assertAllEqual([14, 14], feature_ids)\n    self.assertAllEqual([0, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[0.543478, 0.333333], [-2.611111, -0.382692]],\n                        left_node_contribs)\n    self.assertAllClose([[0.108108, -1.426471], [0.285714, 14.800049]],\n                        right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_RIGHT, _INEQUALITY_DEFAULT_LEFT],\n                        split_types)\n\n  def testCalculateBestFeatureSplitsWithMinNodeWeight(self):\n    \"\"\"Testing best split calculation with min_node_weight.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0.5,\n             logits_dimension=self.logits_dim))\n\n    # Both nodes have large enough sum(hessians) so use them.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.912981, 2.79444], gains)\n    self.assertAllEqual([0, 1], thresholds)\n    self.assertAllEqual([14, 14], feature_ids)\n    self.assertAllEqual([0, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.5, -3.916667], [-3.722223, -0.442857]],\n                        left_node_contribs)\n    self.assertAllClose([[0.906977, -0.394737], [0.8, 0.4]],\n                        right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestFeatureSplitsWithTreeComplexity(self):\n    \"\"\"Testing best split calculation with tree complexity.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n\n    l2 = 0.1\n    tree_complexity = 3.\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=l2,\n             tree_complexity=tree_complexity,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllEqual([1, 2], node_ids)\n    # L2 test result, but subtracted by tree_complexity.\n    self.assertAllClose([-2.524331, 0.467833], gains)\n    self.assertAllEqual([1, 0], thresholds)\n    self.assertAllEqual([14, 14], feature_ids)\n    self.assertAllEqual([0, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[0.543478, 0.333333], [-2.611111, -0.382692]],\n                        left_node_contribs)\n    self.assertAllClose([[0.108108, -1.426471], [0.285714, 14.800049]],\n                        right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_RIGHT, _INEQUALITY_DEFAULT_LEFT],\n                        split_types)\n\n  def testCalculateBestFeatureSplitsWithMinNodeNoSplitOnFeaturePossible(self):\n    \"\"\"Test when parent node hessian doesn't meet min node weight.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n\n    min_node_weight = 0.8\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=min_node_weight,\n             logits_dimension=self.logits_dim))\n\n    # node_1 doesn't have large enough sum(hessians) so don't return it.\n    self.assertAllEqual([2], node_ids)\n    self.assertAllClose([2.79444], gains)\n    self.assertAllEqual([1], thresholds)\n    self.assertAllEqual([14], feature_ids)\n    self.assertAllEqual([1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-3.722223, -0.442857]], left_node_contribs)\n    self.assertAllClose([[0.8, 0.4]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT], split_types)\n\n\nif __name__ == '__main__':\n  googletest.main()\n"], "fixing_code": ["/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <limits>\n#include <string>\n#include <vector>\n\n#include \"third_party/eigen3/Eigen/Core\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/kernels/boosted_trees/boosted_trees.pb.h\"\n#include \"tensorflow/core/kernels/boosted_trees/tree_helper.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n\nnamespace tensorflow {\n\nusing Matrix =\n    Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;\nusing ConstMatrixMap = Eigen::Map<const Matrix>;\nusing MatrixMap = Eigen::Map<Matrix>;\n\nusing ConstVectorMap = Eigen::Map<const Eigen::VectorXf>;\nusing VectorMap = Eigen::Map<Eigen::VectorXf>;\n\nconstexpr char kInequalitySplit[] = \"inequality\";\nconstexpr char kEqualitySplit[] = \"equality\";\n\n// V1 Op. Deprecated. BoostedTreesCalculateBestFeatureSplitOpV2 is V2.\nclass BoostedTreesCalculateBestGainsPerFeatureOp : public OpKernel {\n public:\n  explicit BoostedTreesCalculateBestGainsPerFeatureOp(\n      OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_features\", &num_features_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_id_range\n    const Tensor* node_id_range_t;\n    OP_REQUIRES_OK(context, context->input(\"node_id_range\", &node_id_range_t));\n    OP_REQUIRES(\n        context, node_id_range_t->dims() == 1,\n        errors::InvalidArgument(\"node_id_range must be a rank 1 tensor, but \"\n                                \"given node_id_range has dims of \",\n                                node_id_range_t->dims()));\n    OP_REQUIRES(context, node_id_range_t->dim_size(0) == 2,\n                errors::InvalidArgument(\n                    \"node_id_range must be a rank 1 tensor with shape=[2], but \"\n                    \"given node_id_range has shape \",\n                    node_id_range_t->dim_size(0), \" on its first dim\"));\n    const auto node_id_range = node_id_range_t->vec<int32>();\n    const int32_t node_id_first = node_id_range(0);  // inclusive\n    const int32_t node_id_last = node_id_range(1);   // exclusive\n    // stats_summary_list\n    OpInputList stats_summary_list;\n    OP_REQUIRES_OK(context, context->input_list(\"stats_summary_list\",\n                                                &stats_summary_list));\n    const int64_t num_buckets = stats_summary_list[0].dim_size(1);\n    // Check for single logit: 1 gradient + 1 hessian value.\n    OP_REQUIRES(context, stats_summary_list[0].dim_size(2) == 2,\n                errors::InvalidArgument(\"stats_summary_list[0] must have \"\n                                        \"exactly 2 dimensions, obtained: \",\n                                        stats_summary_list[0].dim_size(2)));\n    std::vector<TTypes<float, 3>::ConstTensor> stats_summary;\n    stats_summary.reserve(stats_summary_list.size());\n    for (const auto& tensor : stats_summary_list) {\n      stats_summary.emplace_back(tensor.tensor<float, 3>());\n    }\n    const Tensor* l1_t;\n    OP_REQUIRES_OK(context, context->input(\"l1\", &l1_t));\n    const auto l1 = l1_t->scalar<float>()();\n    const Tensor* l2_t;\n    OP_REQUIRES_OK(context, context->input(\"l2\", &l2_t));\n    const auto l2 = l2_t->scalar<float>()();\n    const Tensor* tree_complexity_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"tree_complexity\", &tree_complexity_t));\n    const auto tree_complexity = tree_complexity_t->scalar<float>()();\n    const Tensor* min_node_weight_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"min_node_weight\", &min_node_weight_t));\n    const auto min_node_weight = min_node_weight_t->scalar<float>()();\n\n    // Allocate output lists of tensors:\n    OpOutputList output_node_ids_list;\n    OP_REQUIRES_OK(\n        context, context->output_list(\"node_ids_list\", &output_node_ids_list));\n    OpOutputList output_gains_list;\n    OP_REQUIRES_OK(context,\n                   context->output_list(\"gains_list\", &output_gains_list));\n    OpOutputList output_thresholds_list;\n    OP_REQUIRES_OK(context, context->output_list(\"thresholds_list\",\n                                                 &output_thresholds_list));\n    OpOutputList output_left_node_contribs_list;\n    OP_REQUIRES_OK(context,\n                   context->output_list(\"left_node_contribs_list\",\n                                        &output_left_node_contribs_list));\n    OpOutputList output_right_node_contribs_list;\n    OP_REQUIRES_OK(context,\n                   context->output_list(\"right_node_contribs_list\",\n                                        &output_right_node_contribs_list));\n\n    // Use identity later to convert float to Eigen::Matrix type for input to\n    // CalculateWeightsAndGains. This op only supports single dimension logits.\n    Eigen::MatrixXf identity;\n    identity.setIdentity(1, 1);\n    // Get the best split info per node for each feature.\n    for (int feature_idx = 0; feature_idx < num_features_; ++feature_idx) {\n      std::vector<float> cum_grad;\n      std::vector<float> cum_hess;\n      cum_grad.reserve(num_buckets);\n      cum_hess.reserve(num_buckets);\n\n      std::vector<int32> output_node_ids;\n      std::vector<float> output_gains;\n      std::vector<int32> output_thresholds;\n      std::vector<float> output_left_node_contribs;\n      std::vector<float> output_right_node_contribs;\n      for (int node_id = node_id_first; node_id < node_id_last; ++node_id) {\n        // Calculate gains.\n        cum_grad.clear();\n        cum_hess.clear();\n        float total_grad = 0.0;\n        float total_hess = 0.0;\n        for (int bucket = 0; bucket < num_buckets; ++bucket) {\n          // TODO(nponomareva): Consider multi-dimensional gradients/hessians.\n          total_grad += stats_summary[feature_idx](node_id, bucket, 0);\n          total_hess += stats_summary[feature_idx](node_id, bucket, 1);\n          cum_grad.push_back(total_grad);\n          cum_hess.push_back(total_hess);\n        }\n        // Check if node has enough of average hessian.\n        if (total_hess < min_node_weight) {\n          // Do not split the node because not enough avg hessian.\n          continue;\n        }\n        float best_gain = std::numeric_limits<float>::lowest();\n        float best_bucket = 0;\n        float best_contrib_for_left = 0.0;\n        float best_contrib_for_right = 0.0;\n        // Parent gain.\n        float parent_gain;\n        Eigen::VectorXf unused(1);\n        CalculateWeightsAndGains(total_grad * identity, total_hess * identity,\n                                 l1, l2, &unused, &parent_gain);\n\n        for (int bucket = 0; bucket < num_buckets; ++bucket) {\n          const float cum_grad_bucket = cum_grad[bucket];\n          const float cum_hess_bucket = cum_hess[bucket];\n          // Left child.\n          Eigen::VectorXf contrib_for_left(1);\n          float gain_for_left;\n          CalculateWeightsAndGains(cum_grad_bucket * identity,\n                                   cum_hess_bucket * identity, l1, l2,\n                                   &contrib_for_left, &gain_for_left);\n          // Right child.\n          // use contrib_for_right.\n          Eigen::VectorXf contrib_for_right(1);\n          float gain_for_right;\n          CalculateWeightsAndGains((total_grad - cum_grad_bucket) * identity,\n                                   (total_hess - cum_hess_bucket) * identity,\n                                   l1, l2, &contrib_for_right, &gain_for_right);\n\n          if (GainIsLarger(gain_for_left + gain_for_right, best_gain)) {\n            best_gain = gain_for_left + gain_for_right;\n            best_bucket = bucket;\n            best_contrib_for_left = contrib_for_left[0];\n            best_contrib_for_right = contrib_for_right[0];\n          }\n        }  // for bucket\n        output_node_ids.push_back(node_id);\n        // Remove the parent gain for the parent node.\n        output_gains.push_back(best_gain - parent_gain);\n        output_thresholds.push_back(best_bucket);\n        output_left_node_contribs.push_back(best_contrib_for_left);\n        output_right_node_contribs.push_back(best_contrib_for_right);\n      }  // for node_id\n      const int num_nodes = output_node_ids.size();\n      // output_node_ids\n      Tensor* output_node_ids_t;\n      OP_REQUIRES_OK(context,\n                     output_node_ids_list.allocate(feature_idx, {num_nodes},\n                                                   &output_node_ids_t));\n      auto output_node_ids_vec = output_node_ids_t->vec<int32>();\n      // output_gains\n      Tensor* output_gains_t;\n      OP_REQUIRES_OK(context, output_gains_list.allocate(\n                                  feature_idx, {num_nodes}, &output_gains_t));\n      auto output_gains_vec = output_gains_t->vec<float>();\n      // output_thresholds\n      Tensor* output_thresholds_t;\n      OP_REQUIRES_OK(context,\n                     output_thresholds_list.allocate(feature_idx, {num_nodes},\n                                                     &output_thresholds_t));\n      auto output_thresholds_vec = output_thresholds_t->vec<int32>();\n      // output_left_node_contribs\n      Tensor* output_left_node_contribs_t;\n      OP_REQUIRES_OK(context, output_left_node_contribs_list.allocate(\n                                  feature_idx, {num_nodes, 1},\n                                  &output_left_node_contribs_t));\n      auto output_left_node_contribs_matrix =\n          output_left_node_contribs_t->matrix<float>();\n      // output_right_node_contribs\n      Tensor* output_right_node_contribs_t;\n      OP_REQUIRES_OK(context, output_right_node_contribs_list.allocate(\n                                  feature_idx, {num_nodes, 1},\n                                  &output_right_node_contribs_t));\n      auto output_right_node_contribs_matrix =\n          output_right_node_contribs_t->matrix<float>();\n      // Sets output tensors from vectors.\n      for (int i = 0; i < num_nodes; ++i) {\n        output_node_ids_vec(i) = output_node_ids[i];\n        // Adjust the gains to penalize by tree complexity.\n        output_gains_vec(i) = output_gains[i] - tree_complexity;\n        output_thresholds_vec(i) = output_thresholds[i];\n        output_left_node_contribs_matrix(i, 0) = output_left_node_contribs[i];\n        // This op only supports 1-dimensional logits.\n        output_right_node_contribs_matrix(i, 0) = output_right_node_contribs[i];\n      }\n    }  // for f\n  }\n\n private:\n  int max_splits_;\n  int num_features_;\n};\n\n// V1 op that only supports single dimensional logit.\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesCalculateBestGainsPerFeature\").Device(DEVICE_CPU),\n    BoostedTreesCalculateBestGainsPerFeatureOp);\n\n// Deprecated op. Use BoostedTreesCalculateBestFeatureSplitOpV2.\nclass BoostedTreesCalculateBestFeatureSplitOp : public OpKernel {\n public:\n  explicit BoostedTreesCalculateBestFeatureSplitOp(\n      OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"logits_dimension\", &logits_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"split_type\", &split_type_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_id_range\n    const Tensor* node_id_range_t;\n    OP_REQUIRES_OK(context, context->input(\"node_id_range\", &node_id_range_t));\n    OP_REQUIRES(\n        context, node_id_range_t->NumElements() == 2,\n        errors::InvalidArgument(\"node_id_range argument must have shape [2]\"));\n    const auto node_id_range = node_id_range_t->vec<int32>();\n    const int32_t node_id_first = node_id_range(0);  // inclusive\n    const int32_t node_id_last = node_id_range(1);   // exclusive\n\n    const Tensor* stats_summary_t;\n    OP_REQUIRES_OK(context, context->input(\"stats_summary\", &stats_summary_t));\n    OP_REQUIRES(\n        context, stats_summary_t->shape().dims() == 4,\n        errors::InvalidArgument(\"stats_summary argument must have rank 4\"));\n    TTypes<float, 4>::ConstTensor stats_summary =\n        stats_summary_t->tensor<float, 4>();\n    const int32_t feature_dims = stats_summary_t->dim_size(1);\n    // The last bucket is for default/missing value.\n    const int32_t num_buckets = stats_summary_t->dim_size(2) - 1;\n    const int32_t logits_dim = logits_dim_;\n    const int32_t hessian_dim = stats_summary_t->dim_size(3) - logits_dim;\n    OP_REQUIRES(context, hessian_dim > 0,\n                errors::InvalidArgument(\"hessian dim should be < 0, got \",\n                                        hessian_dim));\n    OP_REQUIRES(context, hessian_dim <= logits_dim * logits_dim,\n                errors::InvalidArgument(\n                    \"hessian dim should be <= \", logits_dim * logits_dim,\n                    \" but got: \", hessian_dim));\n\n    const Tensor* l1_t;\n    OP_REQUIRES_OK(context, context->input(\"l1\", &l1_t));\n    OP_REQUIRES(context, l1_t->NumElements() == 1,\n                errors::InvalidArgument(\"l1 argument must be a scalar\"));\n    const auto l1 = l1_t->scalar<float>()();\n    DCHECK_GE(l1, 0);\n    if (logits_dim_ > 1) {\n      // Multi-class L1 regularization not supported yet.\n      DCHECK_EQ(l1, 0);\n    }\n\n    const Tensor* l2_t;\n    OP_REQUIRES_OK(context, context->input(\"l2\", &l2_t));\n    OP_REQUIRES(context, l2_t->NumElements() == 1,\n                errors::InvalidArgument(\"l2 argument must be a scalar\"));\n    const auto l2 = l2_t->scalar<float>()();\n    DCHECK_GE(l2, 0);\n\n    const Tensor* tree_complexity_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"tree_complexity\", &tree_complexity_t));\n    OP_REQUIRES(\n        context, tree_complexity_t->NumElements() == 1,\n        errors::InvalidArgument(\"tree_complexity argument must be a scalar\"));\n    const auto tree_complexity = tree_complexity_t->scalar<float>()();\n\n    const Tensor* min_node_weight_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"min_node_weight\", &min_node_weight_t));\n    OP_REQUIRES(\n        context, min_node_weight_t->NumElements() == 1,\n        errors::InvalidArgument(\"min_node_weight argument must be a scalar\"));\n    const auto min_node_weight = min_node_weight_t->scalar<float>()();\n\n    std::vector<int32> output_node_ids;\n    std::vector<float> output_gains;\n    std::vector<int32> output_feature_dimensions;\n    std::vector<int32> output_thresholds;\n    std::vector<Eigen::VectorXf> output_left_node_contribs;\n    std::vector<Eigen::VectorXf> output_right_node_contribs;\n    std::vector<std::string> output_split_types;\n\n    // TODO(tanzheny) parallelize the computation.\n    // Iterate each node and find the best gain per node.\n    for (int32_t node_id = node_id_first; node_id < node_id_last; ++node_id) {\n      float best_gain = std::numeric_limits<float>::lowest();\n      int32_t best_bucket = 0;\n      int32_t best_f_dim = 0;\n      string best_split_type;\n      Eigen::VectorXf best_contrib_for_left(logits_dim);\n      Eigen::VectorXf best_contrib_for_right(logits_dim);\n      float parent_gain;\n\n      // Including default bucket.\n      ConstMatrixMap stats_mat(&stats_summary(node_id, 0, 0, 0),\n                               num_buckets + 1, logits_dim + hessian_dim);\n      const Eigen::VectorXf total_grad =\n          stats_mat.leftCols(logits_dim).colwise().sum();\n      const Eigen::VectorXf total_hess =\n          stats_mat.rightCols(hessian_dim).colwise().sum();\n      if (total_hess.norm() < min_node_weight) {\n        continue;\n      }\n      Eigen::VectorXf parent_weight(logits_dim);\n      CalculateWeightsAndGains(total_grad, total_hess, l1, l2, &parent_weight,\n                               &parent_gain);\n\n      if (split_type_ == \"inequality\") {\n        CalculateBestInequalitySplit(\n            stats_summary, node_id, feature_dims, logits_dim, hessian_dim,\n            num_buckets, min_node_weight, l1, l2, &best_gain, &best_bucket,\n            &best_f_dim, &best_split_type, &best_contrib_for_left,\n            &best_contrib_for_right);\n      } else {\n        CalculateBestEqualitySplit(\n            stats_summary, total_grad, total_hess, node_id, feature_dims,\n            logits_dim, hessian_dim, num_buckets, l1, l2, &best_gain,\n            &best_bucket, &best_f_dim, &best_split_type, &best_contrib_for_left,\n            &best_contrib_for_right);\n      }\n\n      if (best_gain == std::numeric_limits<float>::lowest()) {\n        // Do not add the node if not split if found.\n        continue;\n      }\n      output_node_ids.push_back(node_id);\n      // Remove the parent gain for the parent node.\n      output_gains.push_back(best_gain - parent_gain);\n      output_feature_dimensions.push_back(best_f_dim);\n      // default direction is fixed for dense splits.\n      // TODO(tanzheny) account for default values.\n      output_split_types.push_back(best_split_type);\n      output_thresholds.push_back(best_bucket);\n      output_left_node_contribs.push_back(best_contrib_for_left);\n      output_right_node_contribs.push_back(best_contrib_for_right);\n    }  // for node id\n    const int num_nodes = output_node_ids.size();\n    // output_node_ids\n    Tensor* output_node_ids_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"node_ids\", {num_nodes},\n                                                     &output_node_ids_t));\n    auto output_node_ids_vec = output_node_ids_t->vec<int32>();\n\n    // output_gains\n    Tensor* output_gains_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"gains\", {num_nodes},\n                                                     &output_gains_t));\n    auto output_gains_vec = output_gains_t->vec<float>();\n\n    // output_feature_dimensions\n    Tensor* output_feature_dimension_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"feature_dimensions\", {num_nodes},\n                                            &output_feature_dimension_t));\n    auto output_feature_dimensions_vec =\n        output_feature_dimension_t->vec<int32>();\n\n    // output_thresholds\n    Tensor* output_thresholds_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"thresholds\", {num_nodes},\n                                                     &output_thresholds_t));\n    auto output_thresholds_vec = output_thresholds_t->vec<int32>();\n\n    // output_left_node_contribs\n    Tensor* output_left_node_contribs_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"left_node_contribs\", {num_nodes, logits_dim},\n                                &output_left_node_contribs_t));\n    auto output_left_node_contribs_matrix =\n        output_left_node_contribs_t->matrix<float>();\n\n    // output_right_node_contribs\n    Tensor* output_right_node_contribs_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"right_node_contribs\", {num_nodes, logits_dim},\n                                &output_right_node_contribs_t));\n    auto output_right_node_contribs_matrix =\n        output_right_node_contribs_t->matrix<float>();\n\n    // split type\n    Tensor* output_split_types_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"split_with_default_directions\",\n                                          {num_nodes}, &output_split_types_t));\n    auto output_split_types_vec = output_split_types_t->vec<tstring>();\n\n    // Sets output tensors from vectors.\n    for (int i = 0; i < num_nodes; ++i) {\n      output_node_ids_vec(i) = output_node_ids[i];\n      // Adjust the gains to penalize by tree complexity.\n      output_gains_vec(i) = output_gains[i] - tree_complexity;\n      output_feature_dimensions_vec(i) = output_feature_dimensions[i];\n      output_thresholds_vec(i) = output_thresholds[i];\n      for (int j = 0; j < logits_dim; ++j) {\n        output_left_node_contribs_matrix(i, j) =\n            output_left_node_contribs[i][j];\n        output_right_node_contribs_matrix(i, j) =\n            output_right_node_contribs[i][j];\n      }\n      output_split_types_vec(i) = output_split_types[i];\n    }\n  }\n\n private:\n  // TODO(crawles): Simplify inequality path just like equality b/138329196\n  // Currently this is not simplify-able due to numerical instability in math\n  // i.e. gain = -g.transpose() * hessian_and_reg.colPivHouseholderQr().solve(g)\n  // It caused gain to be Inf when g is approaching 0 but not exactly 0 while\n  // there is no regularization.\n  // Calculate the best inequality split per node.\n  void CalculateBestInequalitySplit(\n      TTypes<float, 4>::ConstTensor stats_summary, const int32_t node_id,\n      const int32_t feature_dims, const int32_t logits_dim,\n      const int32_t hessian_dim, const int32_t num_buckets,\n      const float min_node_weight, const float l1, const float l2,\n      float* best_gain, int32* best_bucket, int32* best_f_dim,\n      string* best_split_type, Eigen::VectorXf* best_contrib_for_left,\n      Eigen::VectorXf* best_contrib_for_right) {\n    std::vector<Eigen::VectorXf> cum_grad;\n    std::vector<Eigen::VectorXf> cum_hess;\n    // get all cumulative gradients including default bucket.\n    cum_grad.reserve(num_buckets);\n    cum_hess.reserve(num_buckets);\n\n    for (int f_dim = 0; f_dim < feature_dims; ++f_dim) {\n      ConstVectorMap default_stats_vec(\n          &stats_summary(node_id, f_dim, num_buckets, 0),\n          logits_dim + hessian_dim);\n      Eigen::VectorXf missing_bucket_grad = default_stats_vec.head(logits_dim);\n      Eigen::VectorXf missing_bucket_hess = default_stats_vec.tail(hessian_dim);\n      cum_grad.clear();\n      cum_hess.clear();\n      Eigen::VectorXf total_grad = Eigen::VectorXf::Zero(logits_dim);\n      Eigen::VectorXf total_hess = Eigen::VectorXf::Zero(hessian_dim);\n      // sum all the gradients including default bucket.\n      for (int bucket = 0; bucket <= num_buckets; ++bucket) {\n        for (int i = 0; i < logits_dim; ++i) {\n          total_grad[i] += stats_summary(node_id, f_dim, bucket, i);\n        }\n        for (int i = 0; i < hessian_dim; ++i) {\n          // Full hessian.\n          total_hess[i] +=\n              stats_summary(node_id, f_dim, bucket, logits_dim + i);\n        }\n        if (bucket < num_buckets) {\n          cum_grad.push_back(total_grad);\n          cum_hess.push_back(total_hess);\n        }\n      }\n      const string kInequalityDefaultLeft =\n          boosted_trees::SplitTypeWithDefault_Name(\n              boosted_trees::INEQUALITY_DEFAULT_LEFT);\n      const string kInequalityDefaultRight =\n          boosted_trees::SplitTypeWithDefault_Name(\n              boosted_trees::INEQUALITY_DEFAULT_RIGHT);\n\n      // Iterate from left to right, excluding default bucket.\n      for (int bucket = 0; bucket < num_buckets; ++bucket) {\n        // default value goes to left node.\n        const Eigen::VectorXf total_left_grad =\n            cum_grad[bucket] + missing_bucket_grad;\n        const Eigen::VectorXf total_left_hess =\n            cum_hess[bucket] + missing_bucket_hess;\n        MaybeUpdateBestSplit(\n            total_left_grad, total_grad - total_left_grad, total_left_hess,\n            total_hess - total_left_hess, logits_dim, bucket, f_dim, l1, l2,\n            kInequalityDefaultLeft, best_gain, best_bucket, best_f_dim,\n            best_split_type, best_contrib_for_left, best_contrib_for_right);\n        // default value goes to right node.\n        MaybeUpdateBestSplit(\n            cum_grad[bucket], total_grad - cum_grad[bucket], cum_hess[bucket],\n            total_hess - cum_hess[bucket], logits_dim, bucket, f_dim, l1, l2,\n            kInequalityDefaultRight, best_gain, best_bucket, best_f_dim,\n            best_split_type, best_contrib_for_left, best_contrib_for_right);\n      }  // for bucket\n    }\n  }\n\n  // Calculate the best equality split per node.\n  void CalculateBestEqualitySplit(\n      TTypes<float, 4>::ConstTensor stats_summary,\n      const Eigen::VectorXf& total_grad, const Eigen::VectorXf& total_hess,\n      const int32_t node_id, const int32_t feature_dims,\n      const int32_t logits_dim, const int32_t hessian_dim,\n      const int32_t num_buckets, const float l1, const float l2,\n      float* best_gain, int32* best_bucket, int32* best_f_dim,\n      string* best_split_type, Eigen::VectorXf* best_contrib_for_left,\n      Eigen::VectorXf* best_contrib_for_right) {\n    const string kEqualityDefaultRight =\n        boosted_trees::SplitTypeWithDefault_Name(\n            boosted_trees::EQUALITY_DEFAULT_RIGHT);\n    for (int f_dim = 0; f_dim < feature_dims; ++f_dim) {\n      for (int bucket = 0; bucket < num_buckets; ++bucket) {\n        ConstVectorMap stats_vec(&stats_summary(node_id, f_dim, bucket, 0),\n                                 logits_dim + hessian_dim);\n        Eigen::VectorXf curr_grad = stats_vec.head(logits_dim);\n        Eigen::VectorXf curr_hess = stats_vec.tail(hessian_dim);\n        MaybeUpdateBestSplit(curr_grad, total_grad - curr_grad, curr_hess,\n                             total_hess - curr_hess, logits_dim, bucket, f_dim,\n                             l1, l2, kEqualityDefaultRight, best_gain,\n                             best_bucket, best_f_dim, best_split_type,\n                             best_contrib_for_left, best_contrib_for_right);\n      }\n    }\n  }\n\n  void MaybeUpdateBestSplit(const Eigen::VectorXf& grad_for_left,\n                            const Eigen::VectorXf& grad_for_right,\n                            const Eigen::VectorXf& hess_for_left,\n                            const Eigen::VectorXf& hess_for_right,\n                            const int32_t logits_dim, const int32_t bucket,\n                            const int32_t f_dim, const float l1, const float l2,\n                            const string split_type, float* best_gain,\n                            int32* best_bucket, int32* best_f_dim,\n                            string* best_split_type,\n                            Eigen::VectorXf* best_contrib_for_left,\n                            Eigen::VectorXf* best_contrib_for_right) {\n    // Left child.\n    Eigen::VectorXf contrib_for_left(logits_dim);\n    float gain_for_left;\n    CalculateWeightsAndGains(grad_for_left, hess_for_left, l1, l2,\n                             &contrib_for_left, &gain_for_left);\n    Eigen::VectorXf contrib_for_right(logits_dim);\n    float gain_for_right;\n    CalculateWeightsAndGains(grad_for_right, hess_for_right, l1, l2,\n                             &contrib_for_right, &gain_for_right);\n    if (GainIsLarger(gain_for_left + gain_for_right, *best_gain)) {\n      *best_gain = gain_for_left + gain_for_right;\n      *best_bucket = bucket;\n      *best_f_dim = f_dim;\n      *best_contrib_for_left = contrib_for_left;\n      *best_contrib_for_right = contrib_for_right;\n      *best_split_type = split_type;\n    }\n  }\n\n  int logits_dim_;\n  string split_type_;\n};\n\n// Deprecated op. Use BoostedTreesCalculateBestFeatureSplitOpV2.\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesCalculateBestFeatureSplit\").Device(DEVICE_CPU),\n    BoostedTreesCalculateBestFeatureSplitOp);\n\n// V2 Op.\nclass BoostedTreesCalculateBestFeatureSplitV2 : public OpKernel {\n public:\n  explicit BoostedTreesCalculateBestFeatureSplitV2(\n      OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"logits_dimension\", &logits_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_features\", &num_features_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_id_range\n    const Tensor* node_id_range_t;\n    OP_REQUIRES_OK(context, context->input(\"node_id_range\", &node_id_range_t));\n    const auto node_id_range = node_id_range_t->vec<int32>();\n    OP_REQUIRES(\n        context, node_id_range_t->dims() == 1,\n        errors::InvalidArgument(\"node_id_range must be a rank 1 tensor, but \"\n                                \"given node_id_range has dims of \",\n                                node_id_range_t->dims()));\n    OP_REQUIRES(context, node_id_range_t->dim_size(0) == 2,\n                errors::InvalidArgument(\n                    \"node_id_range must be a rank 1 tensor with shape=[2], but \"\n                    \"given node_id_range has shape \",\n                    node_id_range_t->dim_size(0), \" on its first dim\"));\n    const int32_t node_id_first = node_id_range(0);  // Inclusive.\n    const int32_t node_id_last = node_id_range(1);   // Exclusive.\n\n    // Get stats_summaries_list.\n    OpInputList stats_summaries_list;\n    OP_REQUIRES_OK(context, context->input_list(\"stats_summaries_list\",\n                                                &stats_summaries_list));\n\n    // Infer dimensions of a stats_summary.\n    DCHECK_GT(stats_summaries_list.size(), 0);\n    const int32_t feature_dims = stats_summaries_list[0].dim_size(1);\n    // The last bucket is for default/missing value.\n    const int32_t num_buckets = stats_summaries_list[0].dim_size(2) - 1;\n    const int32_t logits_dim = logits_dim_;\n    const int32_t hessian_dim =\n        stats_summaries_list[0].dim_size(3) - logits_dim;\n    OP_REQUIRES(context, hessian_dim > 0,\n                errors::InvalidArgument(\"hessian dim should be < 0, got \",\n                                        hessian_dim));\n    OP_REQUIRES(context, hessian_dim <= logits_dim * logits_dim,\n                errors::InvalidArgument(\n                    \"hessian dim should be <= \", logits_dim * logits_dim,\n                    \" but got: \", hessian_dim));\n\n    // Vector of stats_summaries; each element is stats for feature of shape\n    // [max_splits, feature_dim, num_buckets, logits_dim + hessian_dim].\n    std::vector<TTypes<float, 4>::ConstTensor> stats_summaries;\n    DCHECK_EQ(stats_summaries_list.size(), num_features_);\n    stats_summaries.reserve(num_features_);\n    for (const auto& tensor : stats_summaries_list) {\n      stats_summaries.emplace_back(tensor.tensor<float, 4>());\n    }\n\n    // Split types.\n    const Tensor* split_types_t;\n    OP_REQUIRES_OK(context, context->input(\"split_types\", &split_types_t));\n    const auto split_types = split_types_t->vec<tstring>();\n    DCHECK_EQ(split_types.size(), num_features_);\n    // Validate.\n    for (int i = 0; i < num_features_; ++i) {\n      if (!(split_types(i) == kInequalitySplit ||\n            split_types(i) == kEqualitySplit)) {\n        OP_REQUIRES_OK(\n            context,\n            errors::Aborted(\n                \"Operation received an exception: Incorrect split type\"));\n      }\n    }\n    // Feature ids.\n    const Tensor* candidate_feature_ids_t;\n    OP_REQUIRES_OK(context, context->input(\"candidate_feature_ids\",\n                                           &candidate_feature_ids_t));\n    const auto candidate_feature_ids = candidate_feature_ids_t->vec<int32>();\n    DCHECK_EQ(candidate_feature_ids.size(), num_features_);\n\n    // L1, L2, tree_complexity, min_node_weight.\n    const Tensor* l1_t;\n    OP_REQUIRES_OK(context, context->input(\"l1\", &l1_t));\n    const auto l1 = l1_t->scalar<float>()();\n    DCHECK_GE(l1, 0);\n    if (logits_dim_ > 1) {\n      // Multi-class L1 regularization not supported yet.\n      DCHECK_EQ(l1, 0);\n    }\n    const Tensor* l2_t;\n    OP_REQUIRES_OK(context, context->input(\"l2\", &l2_t));\n    const auto l2 = l2_t->scalar<float>()();\n    DCHECK_GE(l2, 0);\n    const Tensor* tree_complexity_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"tree_complexity\", &tree_complexity_t));\n    const auto tree_complexity = tree_complexity_t->scalar<float>()();\n    const Tensor* min_node_weight_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"min_node_weight\", &min_node_weight_t));\n    const auto min_node_weight = min_node_weight_t->scalar<float>()();\n\n    std::vector<int32> output_node_ids;\n    std::vector<float> output_gains;\n    std::vector<int32> output_feature_ids;\n    std::vector<int32> output_feature_dimensions;\n    std::vector<int32> output_thresholds;\n    std::vector<Eigen::VectorXf> output_left_node_contribs;\n    std::vector<Eigen::VectorXf> output_right_node_contribs;\n    std::vector<string> output_split_types;\n\n    // TODO(tanzheny) parallelize the computation.\n    // Iterate each node and find the best gain per node.\n    float parent_gain;\n    for (int32_t node_id = node_id_first; node_id < node_id_last; ++node_id) {\n      float best_gain = std::numeric_limits<float>::lowest();\n      int32_t best_bucket;\n      int32_t best_f_id;\n      int32_t best_f_dim;\n      string best_split_type;\n      Eigen::VectorXf best_contrib_for_left(logits_dim);\n      Eigen::VectorXf best_contrib_for_right(logits_dim);\n\n      // Sum of gradient and hessian. Compute parent gain using first feature.\n      ConstMatrixMap stats_mat(&stats_summaries[0](node_id, 0, 0, 0),\n                               num_buckets + 1,  // Including default bucket.\n                               logits_dim + hessian_dim);\n      const Eigen::VectorXf total_grad =\n          stats_mat.leftCols(logits_dim).colwise().sum();\n      const Eigen::VectorXf total_hess =\n          stats_mat.rightCols(hessian_dim).colwise().sum();\n      if (total_hess.norm() < min_node_weight) {\n        continue;\n      }\n      Eigen::VectorXf unused(logits_dim);\n      CalculateWeightsAndGains(total_grad, total_hess, l1, l2, &unused,\n                               &parent_gain);\n      for (int f_idx = 0; f_idx < num_features_; ++f_idx) {\n        const string split_type = split_types(f_idx);\n        TTypes<float, 4>::ConstTensor stats_summary = stats_summaries[f_idx];\n        float f_best_gain = std::numeric_limits<float>::lowest();\n        int32_t f_best_bucket;\n        int32_t f_best_f_dim;\n        string f_best_split_type;\n        Eigen::VectorXf f_best_contrib_for_left(logits_dim);\n        Eigen::VectorXf f_best_contrib_for_right(logits_dim);\n\n        if (split_type == kInequalitySplit) {\n          CalculateBestInequalitySplit(\n              stats_summary, node_id, feature_dims, logits_dim, hessian_dim,\n              num_buckets, min_node_weight, l1, l2, &f_best_gain,\n              &f_best_bucket, &f_best_f_dim, &f_best_split_type,\n              &f_best_contrib_for_left, &f_best_contrib_for_right);\n        } else {\n          CalculateBestEqualitySplit(\n              stats_summary, total_grad, total_hess, node_id, feature_dims,\n              logits_dim, hessian_dim, num_buckets, l1, l2, &f_best_gain,\n              &f_best_bucket, &f_best_f_dim, &f_best_split_type,\n              &f_best_contrib_for_left, &f_best_contrib_for_right);\n        }\n        if (f_best_gain > best_gain) {\n          best_gain = f_best_gain;\n          best_f_id = candidate_feature_ids(f_idx);\n          best_f_dim = f_best_f_dim;\n          best_split_type = f_best_split_type;\n          best_bucket = f_best_bucket;\n          best_contrib_for_left = f_best_contrib_for_left;\n          best_contrib_for_right = f_best_contrib_for_right;\n        }\n      }  // For feature id.\n      if (best_gain == std::numeric_limits<float>::lowest()) {\n        // Do not add the node if no split is found.\n        continue;\n      }\n      output_node_ids.push_back(node_id);\n      // Remove the parent gain for the parent node.\n      output_gains.push_back(best_gain - parent_gain);\n      output_feature_ids.push_back(best_f_id);\n      output_feature_dimensions.push_back(best_f_dim);\n      // Default direction is fixed for dense splits.\n      // TODO(tanzheny) account for default values.\n      output_split_types.push_back(best_split_type);\n      output_thresholds.push_back(best_bucket);\n      output_left_node_contribs.push_back(best_contrib_for_left);\n      output_right_node_contribs.push_back(best_contrib_for_right);\n    }  // for node id.\n    const int num_nodes = output_node_ids.size();\n    // output_node_ids\n    Tensor* output_node_ids_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"node_ids\", {num_nodes},\n                                                     &output_node_ids_t));\n    auto output_node_ids_vec = output_node_ids_t->vec<int32>();\n\n    // output_gains\n    Tensor* output_gains_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"gains\", {num_nodes},\n                                                     &output_gains_t));\n    auto output_gains_vec = output_gains_t->vec<float>();\n\n    // output_feature_ids\n    Tensor* output_features_ids_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"feature_ids\", {num_nodes},\n                                                     &output_features_ids_t));\n    auto output_features_vec = output_features_ids_t->vec<int32>();\n\n    // output_feature_dimensions\n    Tensor* output_feature_dimension_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"feature_dimensions\", {num_nodes},\n                                            &output_feature_dimension_t));\n    auto output_feature_dimensions_vec =\n        output_feature_dimension_t->vec<int32>();\n\n    // output_thresholds\n    Tensor* output_thresholds_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"thresholds\", {num_nodes},\n                                                     &output_thresholds_t));\n    auto output_thresholds_vec = output_thresholds_t->vec<int32>();\n\n    // output_left_node_contribs\n    Tensor* output_left_node_contribs_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"left_node_contribs\", {num_nodes, logits_dim},\n                                &output_left_node_contribs_t));\n    auto output_left_node_contribs_matrix =\n        output_left_node_contribs_t->matrix<float>();\n\n    // output_right_node_contribs\n    Tensor* output_right_node_contribs_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"right_node_contribs\", {num_nodes, logits_dim},\n                                &output_right_node_contribs_t));\n    auto output_right_node_contribs_matrix =\n        output_right_node_contribs_t->matrix<float>();\n\n    // split type\n    Tensor* output_split_types_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"split_with_default_directions\",\n                                          {num_nodes}, &output_split_types_t));\n    auto output_split_types_vec = output_split_types_t->vec<tstring>();\n\n    // Sets output tensors from vectors.\n    for (int i = 0; i < num_nodes; ++i) {\n      output_node_ids_vec(i) = output_node_ids[i];\n      output_features_vec(i) = output_feature_ids[i];\n      // Adjust the gains to penalize by tree complexity.\n      output_gains_vec(i) = output_gains[i] - tree_complexity;\n      output_feature_dimensions_vec(i) = output_feature_dimensions[i];\n      output_thresholds_vec(i) = output_thresholds[i];\n      for (int j = 0; j < logits_dim; ++j) {\n        output_left_node_contribs_matrix(i, j) =\n            output_left_node_contribs[i][j];\n        output_right_node_contribs_matrix(i, j) =\n            output_right_node_contribs[i][j];\n      }\n      output_split_types_vec(i) = output_split_types[i];\n    }\n  }\n\n private:\n  // TODO(crawles): Simplify inequality path just like equality b/138329196\n  // Currently this is not simplify-able due to numerical instability in math\n  // i.e. gain = -g.transpose() * hessian_and_reg.colPivHouseholderQr().solve(g)\n  // It caused gain to be Inf when g is approaching 0 but not exactly 0 while\n  // there is no regularization.\n  // Calculate the best inequality split per node.\n  void CalculateBestInequalitySplit(\n      TTypes<float, 4>::ConstTensor stats_summary, const int32_t node_id,\n      const int32_t feature_dims, const int32_t logits_dim,\n      const int32_t hessian_dim, const int32_t num_buckets,\n      const float min_node_weight, const float l1, const float l2,\n      float* best_gain, int32* best_bucket, int32* best_f_dim,\n      string* best_split_type, Eigen::VectorXf* best_contrib_for_left,\n      Eigen::VectorXf* best_contrib_for_right) {\n    std::vector<Eigen::VectorXf> cum_grad;\n    std::vector<Eigen::VectorXf> cum_hess;\n    // get all cumulative gradients including default bucket.\n    cum_grad.reserve(num_buckets);\n    cum_hess.reserve(num_buckets);\n\n    for (int f_dim = 0; f_dim < feature_dims; ++f_dim) {\n      ConstVectorMap default_stats_vec(\n          &stats_summary(node_id, f_dim, num_buckets, 0),\n          logits_dim + hessian_dim);\n      Eigen::VectorXf missing_bucket_grad = default_stats_vec.head(logits_dim);\n      Eigen::VectorXf missing_bucket_hess = default_stats_vec.tail(hessian_dim);\n      cum_grad.clear();\n      cum_hess.clear();\n      Eigen::VectorXf total_grad = Eigen::VectorXf::Zero(logits_dim);\n      Eigen::VectorXf total_hess = Eigen::VectorXf::Zero(hessian_dim);\n      // sum all the gradients including default bucket.\n      for (int bucket = 0; bucket <= num_buckets; ++bucket) {\n        for (int i = 0; i < logits_dim; ++i) {\n          total_grad[i] += stats_summary(node_id, f_dim, bucket, i);\n        }\n        for (int i = 0; i < hessian_dim; ++i) {\n          // Full hessian.\n          total_hess[i] +=\n              stats_summary(node_id, f_dim, bucket, logits_dim + i);\n        }\n        if (bucket < num_buckets) {\n          cum_grad.push_back(total_grad);\n          cum_hess.push_back(total_hess);\n        }\n      }\n      const string kInequalityDefaultLeft =\n          boosted_trees::SplitTypeWithDefault_Name(\n              boosted_trees::INEQUALITY_DEFAULT_LEFT);\n      const string kInequalityDefaultRight =\n          boosted_trees::SplitTypeWithDefault_Name(\n              boosted_trees::INEQUALITY_DEFAULT_RIGHT);\n\n      // Iterate from left to right, excluding default bucket.\n      for (int bucket = 0; bucket < num_buckets; ++bucket) {\n        // default value goes to left node.\n        const Eigen::VectorXf total_left_grad =\n            cum_grad[bucket] + missing_bucket_grad;\n        const Eigen::VectorXf total_left_hess =\n            cum_hess[bucket] + missing_bucket_hess;\n        MaybeUpdateBestSplit(\n            total_left_grad, total_grad - total_left_grad, total_left_hess,\n            total_hess - total_left_hess, logits_dim, bucket, f_dim, l1, l2,\n            kInequalityDefaultLeft, best_gain, best_bucket, best_f_dim,\n            best_split_type, best_contrib_for_left, best_contrib_for_right);\n        // default value goes to right node.\n        MaybeUpdateBestSplit(\n            cum_grad[bucket], total_grad - cum_grad[bucket], cum_hess[bucket],\n            total_hess - cum_hess[bucket], logits_dim, bucket, f_dim, l1, l2,\n            kInequalityDefaultRight, best_gain, best_bucket, best_f_dim,\n            best_split_type, best_contrib_for_left, best_contrib_for_right);\n      }  // for bucket\n    }\n  }\n\n  // Calculate the best equality split per node.\n  void CalculateBestEqualitySplit(\n      TTypes<float, 4>::ConstTensor stats_summary,\n      const Eigen::VectorXf& total_grad, const Eigen::VectorXf& total_hess,\n      const int32_t node_id, const int32_t feature_dims,\n      const int32_t logits_dim, const int32_t hessian_dim,\n      const int32_t num_buckets, const float l1, const float l2,\n      float* best_gain, int32* best_bucket, int32* best_f_dim,\n      string* best_split_type, Eigen::VectorXf* best_contrib_for_left,\n      Eigen::VectorXf* best_contrib_for_right) {\n    const string kEqualityDefaultRight =\n        boosted_trees::SplitTypeWithDefault_Name(\n            boosted_trees::EQUALITY_DEFAULT_RIGHT);\n    for (int f_dim = 0; f_dim < feature_dims; ++f_dim) {\n      for (int bucket = 0; bucket < num_buckets; ++bucket) {\n        ConstVectorMap stats_vec(&stats_summary(node_id, f_dim, bucket, 0),\n                                 logits_dim + hessian_dim);\n        Eigen::VectorXf curr_grad = stats_vec.head(logits_dim);\n        Eigen::VectorXf curr_hess = stats_vec.tail(hessian_dim);\n        MaybeUpdateBestSplit(curr_grad, total_grad - curr_grad, curr_hess,\n                             total_hess - curr_hess, logits_dim, bucket, f_dim,\n                             l1, l2, kEqualityDefaultRight, best_gain,\n                             best_bucket, best_f_dim, best_split_type,\n                             best_contrib_for_left, best_contrib_for_right);\n      }\n    }\n  }\n\n  void MaybeUpdateBestSplit(const Eigen::VectorXf& grad_for_left,\n                            const Eigen::VectorXf& grad_for_right,\n                            const Eigen::VectorXf& hess_for_left,\n                            const Eigen::VectorXf& hess_for_right,\n                            const int32_t logits_dim, const int32_t bucket,\n                            const int32_t f_dim, const float l1, const float l2,\n                            const string split_type, float* best_gain,\n                            int32* best_bucket, int32* best_f_dim,\n                            string* best_split_type,\n                            Eigen::VectorXf* best_contrib_for_left,\n                            Eigen::VectorXf* best_contrib_for_right) {\n    // Left child.\n    Eigen::VectorXf contrib_for_left(logits_dim);\n    float gain_for_left;\n    CalculateWeightsAndGains(grad_for_left, hess_for_left, l1, l2,\n                             &contrib_for_left, &gain_for_left);\n    Eigen::VectorXf contrib_for_right(logits_dim);\n    float gain_for_right;\n    CalculateWeightsAndGains(grad_for_right, hess_for_right, l1, l2,\n                             &contrib_for_right, &gain_for_right);\n    if (GainIsLarger(gain_for_left + gain_for_right, *best_gain)) {\n      *best_gain = gain_for_left + gain_for_right;\n      *best_bucket = bucket;\n      *best_f_dim = f_dim;\n      *best_contrib_for_left = contrib_for_left;\n      *best_contrib_for_right = contrib_for_right;\n      *best_split_type = split_type;\n    }\n  }\n  int num_features_;\n  int logits_dim_;\n};\n\n// v2 op that supports multi-class.\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesCalculateBestFeatureSplitV2\").Device(DEVICE_CPU),\n    BoostedTreesCalculateBestFeatureSplitV2);\n\n// Map from bucket id to vector of statistics.\ntypedef std::map<int32, std::vector<float>> BucketMap;\ntypedef BucketMap::iterator BucketMapIterator;\n// Map from feature dimension to BucketMap.\ntypedef std::map<int32, BucketMap> FeatureMap;\ntypedef FeatureMap::iterator FeatureMapIterator;\n\nclass BoostedTreesSparseCalculateBestFeatureSplitOp : public OpKernel {\n public:\n  explicit BoostedTreesSparseCalculateBestFeatureSplitOp(\n      OpKernelConstruction* const context)\n      : OpKernel(context) {\n    // TODO(crawles): Using logits_dim_ for multi-class split.\n    OP_REQUIRES_OK(context, context->GetAttr(\"logits_dimension\", &logits_dim_));\n    // TODO(tanzheny): Using this for equality split.\n    OP_REQUIRES_OK(context, context->GetAttr(\"split_type\", &split_type_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_id_range\n    const Tensor* node_id_range_t;\n    OP_REQUIRES_OK(context, context->input(\"node_id_range\", &node_id_range_t));\n    const auto node_id_range = node_id_range_t->vec<int32>();\n    OP_REQUIRES(\n        context, node_id_range.size() == 2,\n        errors::InvalidArgument(\"node_id_range should have 2 entries, got: \",\n                                node_id_range.size()));\n    const int32_t node_id_first = node_id_range(0);  // inclusive\n    const int32_t node_id_last = node_id_range(1);   // exclusive\n\n    const Tensor* stats_summary_indices_t;\n    OP_REQUIRES_OK(context, context->input(\"stats_summary_indices\",\n                                           &stats_summary_indices_t));\n    const auto stats_summary_indices = stats_summary_indices_t->matrix<int32>();\n    const int32_t num_sparse_entries = stats_summary_indices_t->dim_size(0);\n\n    const Tensor* stats_summary_values_t;\n    OP_REQUIRES_OK(context, context->input(\"stats_summary_values\",\n                                           &stats_summary_values_t));\n    const auto stats_summary_values = stats_summary_values_t->vec<float>();\n\n    const Tensor* stats_summary_shape_t;\n    OP_REQUIRES_OK(\n        context, context->input(\"stats_summary_shape\", &stats_summary_shape_t));\n    const auto stats_summary_shape = stats_summary_shape_t->vec<int32>();\n    const int32_t num_buckets = stats_summary_shape(2) - 1;\n    const int32_t stats_dims = stats_summary_shape(3);\n\n    const Tensor* l1_t;\n    OP_REQUIRES_OK(context, context->input(\"l1\", &l1_t));\n    const auto l1 = l1_t->scalar<float>()();\n\n    const Tensor* l2_t;\n    OP_REQUIRES_OK(context, context->input(\"l2\", &l2_t));\n    const auto l2 = l2_t->scalar<float>()();\n\n    const Tensor* tree_complexity_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"tree_complexity\", &tree_complexity_t));\n    const auto tree_complexity = tree_complexity_t->scalar<float>()();\n\n    const Tensor* min_node_weight_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"min_node_weight\", &min_node_weight_t));\n    const auto min_node_weight = min_node_weight_t->scalar<float>()();\n\n    std::vector<int32> output_node_ids;\n    std::vector<float> output_gains;\n    std::vector<int32> output_feature_dimensions;\n    std::vector<int32> output_thresholds;\n    std::vector<float> output_left_node_contribs;\n    std::vector<float> output_right_node_contribs;\n    std::vector<string> output_split_types;\n\n    FeatureMap f_map;\n\n    int32_t previous_node_id = -1;\n    for (int idx = 0; idx < num_sparse_entries; ++idx) {\n      int32_t node_id = stats_summary_indices(idx, 0);\n      if (node_id != previous_node_id) {\n        process_node(f_map, &output_node_ids, &output_gains,\n                     &output_feature_dimensions, &output_thresholds,\n                     &output_left_node_contribs, &output_right_node_contribs,\n                     &output_split_types, previous_node_id, min_node_weight, l1,\n                     l2, num_buckets);\n        f_map.clear();\n      }\n      previous_node_id = node_id;\n      DCHECK_LE(node_id_first, node_id);\n      DCHECK_LT(node_id, node_id_last);\n      const int32_t feature_dim = stats_summary_indices(idx, 1);\n      const int32_t bucket_id = stats_summary_indices(idx, 2);\n      const int32_t stat_dim = stats_summary_indices(idx, 3);\n      OP_REQUIRES(context, stat_dim < stats_dims,\n                  errors::InvalidArgument(\n                      \"Stat dim, the sum of logits dim and hessian dim in \"\n                      \"stats_summary_indices, cannot be greater than stats \"\n                      \"dims, the last value in stats_summary_shape, which was \",\n                      stats_dims, \". At index (\", idx,\n                      \", 4), stats_summary_indices contains value \", stat_dim));\n      OP_REQUIRES(context, stat_dim >= 0,\n                  errors::InvalidArgument(\n                      \"Stat dim, the sum of logits dim and hessian dim in \"\n                      \"stats_summary_indices, should be >= 0, which was \",\n                      stat_dim, \" at index \", idx));\n      std::pair<FeatureMapIterator, bool> const& f_insert_result = f_map.insert(\n          FeatureMapIterator::value_type(feature_dim, BucketMap()));\n      auto& b_map = f_insert_result.first->second;\n      std::pair<BucketMapIterator, bool> const& b_insert_result =\n          b_map.insert(BucketMapIterator::value_type(\n              bucket_id, std::vector<float>(stats_dims)));\n      auto& stats = b_insert_result.first->second;\n      stats[stat_dim] = stats_summary_values(idx);\n    }  // for node_id\n    // process the last node id\n    process_node(f_map, &output_node_ids, &output_gains,\n                 &output_feature_dimensions, &output_thresholds,\n                 &output_left_node_contribs, &output_right_node_contribs,\n                 &output_split_types, previous_node_id, min_node_weight, l1, l2,\n                 num_buckets);\n\n    const int num_nodes = output_node_ids.size();\n    // output_node_ids\n    Tensor* output_node_ids_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"node_ids\", {num_nodes},\n                                                     &output_node_ids_t));\n    auto output_node_ids_vec = output_node_ids_t->vec<int32>();\n\n    // output_gains\n    Tensor* output_gains_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"gains\", {num_nodes},\n                                                     &output_gains_t));\n    auto output_gains_vec = output_gains_t->vec<float>();\n\n    // output_feature_dimensions\n    Tensor* output_feature_dimension_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"feature_dimensions\", {num_nodes},\n                                            &output_feature_dimension_t));\n    auto output_feature_dimensions_vec =\n        output_feature_dimension_t->vec<int32>();\n\n    // output_thresholds\n    Tensor* output_thresholds_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\"thresholds\", {num_nodes},\n                                                     &output_thresholds_t));\n    auto output_thresholds_vec = output_thresholds_t->vec<int32>();\n\n    // output_left_node_contribs\n    Tensor* output_left_node_contribs_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"left_node_contribs\", {num_nodes, 1},\n                                          &output_left_node_contribs_t));\n    auto output_left_node_contribs_matrix =\n        output_left_node_contribs_t->matrix<float>();\n\n    // output_right_node_contribs\n    Tensor* output_right_node_contribs_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"right_node_contribs\", {num_nodes, 1},\n                                          &output_right_node_contribs_t));\n    auto output_right_node_contribs_matrix =\n        output_right_node_contribs_t->matrix<float>();\n\n    // split type\n    Tensor* output_split_types_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"split_with_default_directions\",\n                                          {num_nodes}, &output_split_types_t));\n    auto output_split_types_vec = output_split_types_t->vec<tstring>();\n\n    // Sets output tensors from vectors.\n    for (int i = 0; i < num_nodes; ++i) {\n      output_node_ids_vec(i) = output_node_ids[i];\n      // Adjust the gains to penalize by tree complexity.\n      output_gains_vec(i) = output_gains[i] - tree_complexity;\n      output_feature_dimensions_vec(i) = output_feature_dimensions[i];\n      output_thresholds_vec(i) = output_thresholds[i];\n      // TODO(crawles): change this for multi-class.\n      output_left_node_contribs_matrix(i, 0) = output_left_node_contribs[i];\n      output_right_node_contribs_matrix(i, 0) = output_right_node_contribs[i];\n      output_split_types_vec(i) = output_split_types[i];\n    }\n  }\n\n protected:\n  void process_node(const FeatureMap& f_map,\n                    std::vector<int32>* output_node_ids,\n                    std::vector<float>* output_gains,\n                    std::vector<int32>* output_feature_dimensions,\n                    std::vector<int32>* output_thresholds,\n                    std::vector<float>* output_left_node_contribs,\n                    std::vector<float>* output_right_node_contribs,\n                    std::vector<string>* output_split_types,\n                    const int32_t node_id, const float min_node_weight,\n                    const float l1, const float l2, const int32_t num_buckets) {\n    float parent_gain;\n    Eigen::VectorXf unused(logits_dim_);\n    Eigen::MatrixXf identity;\n    identity.setIdentity(1, 1);\n\n    // start processing for previous node id.\n    float best_gain = std::numeric_limits<float>::lowest();\n    float best_bucket = 0;\n    float best_f_dim = 0;\n    string best_split_type = boosted_trees::SplitTypeWithDefault_Name(\n        boosted_trees::INEQUALITY_DEFAULT_LEFT);\n    float best_contrib_for_left = 0.0;\n    float best_contrib_for_right = 0.0;\n    // the sum of gradients including default bucket.\n    float total_grad = 0;\n    // the sum of hessians including default bucket.\n    float total_hess = 0;\n\n    for (auto f_iter = f_map.begin(); f_iter != f_map.end(); ++f_iter) {\n      const int32_t feature_dim = f_iter->first;\n      const auto buckets_to_stats_map = f_iter->second;\n\n      // The very last bucket contains stats for missing values.\n      // TODO(crawles): use vector for multi-class.\n      const float default_grad =\n          (buckets_to_stats_map.find(num_buckets) == buckets_to_stats_map.end()\n               ? 0\n               : buckets_to_stats_map.at(num_buckets)[0]);\n      const float default_hess =\n          (buckets_to_stats_map.find(num_buckets) == buckets_to_stats_map.end()\n               ? 0\n               : buckets_to_stats_map.at(num_buckets)[1]);\n\n      if (f_iter == f_map.begin()) {\n        // first get the sum of grads, including default bucket.\n        for (auto b_iter = buckets_to_stats_map.begin();\n             b_iter != buckets_to_stats_map.end(); ++b_iter) {\n          total_grad += b_iter->second[0];\n          total_hess += b_iter->second[1];\n        }\n        if (total_hess < min_node_weight) {\n          // Do not split the node because not enough avg hessian.\n          break;\n        }\n        CalculateWeightsAndGains(total_grad * identity, total_hess * identity,\n                                 l1, l2, &unused, &parent_gain);\n      }\n\n      float total_left_grad = 0;\n      float total_left_hess = 0;\n      for (auto b_iter = buckets_to_stats_map.begin();\n           b_iter != buckets_to_stats_map.end(); ++b_iter) {\n        const int32_t bucket_id = b_iter->first;\n        // total_left_stats should exclude stats from default bucket.\n        if (bucket_id == num_buckets) {\n          break;\n        }\n        // TODO(crawles): vector for multi-class.\n        total_left_grad += b_iter->second[0];\n        total_left_hess += b_iter->second[1];\n        // From left to right, default right.\n        // Left child.\n        Eigen::VectorXf contrib_for_left(1);\n        float gain_for_left;\n        CalculateWeightsAndGains(total_left_grad * identity,\n                                 total_left_hess * identity, l1, l2,\n                                 &contrib_for_left, &gain_for_left);\n        // Right child.\n        Eigen::VectorXf contrib_for_right(1);\n        float gain_for_right;\n        CalculateWeightsAndGains((total_grad - total_left_grad) * identity,\n                                 (total_hess - total_left_hess) * identity, l1,\n                                 l2, &contrib_for_right, &gain_for_right);\n        if (GainIsLarger(gain_for_left + gain_for_right, best_gain)) {\n          best_gain = gain_for_left + gain_for_right;\n          best_bucket = bucket_id;\n          best_f_dim = feature_dim;\n          best_split_type = boosted_trees::SplitTypeWithDefault_Name(\n              boosted_trees::INEQUALITY_DEFAULT_RIGHT);\n          best_contrib_for_left = contrib_for_left[0];\n          best_contrib_for_right = contrib_for_right[0];\n        }\n\n        // From right to left, default left.\n        CalculateWeightsAndGains((total_left_grad + default_grad) * identity,\n                                 (total_left_hess + default_hess) * identity,\n                                 l1, l2, &contrib_for_left, &gain_for_left);\n        CalculateWeightsAndGains(\n            (total_grad - default_grad - total_left_grad) * identity,\n            (total_hess - default_hess - total_left_hess) * identity, l1, l2,\n            &contrib_for_right, &gain_for_right);\n        if (GainIsLarger(gain_for_left + gain_for_right, best_gain)) {\n          best_gain = gain_for_left + gain_for_right;\n          best_bucket = bucket_id;\n          best_f_dim = feature_dim;\n          best_split_type = boosted_trees::SplitTypeWithDefault_Name(\n              boosted_trees::INEQUALITY_DEFAULT_LEFT);\n          best_contrib_for_left = contrib_for_left[0];\n          best_contrib_for_right = contrib_for_right[0];\n        }\n      }  // for bucket_id\n    }    // for feature_dim\n    if (best_gain != std::numeric_limits<float>::lowest()) {\n      output_node_ids->push_back(node_id);\n      // Remove the parent gain.\n      output_gains->push_back(best_gain - parent_gain);\n      output_feature_dimensions->push_back(best_f_dim);\n      output_split_types->push_back(best_split_type);\n      output_thresholds->push_back(best_bucket);\n      output_left_node_contribs->push_back(best_contrib_for_left);\n      output_right_node_contribs->push_back(best_contrib_for_right);\n    }\n  }\n\n private:\n  int logits_dim_;\n  string split_type_;\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesSparseCalculateBestFeatureSplit\").Device(DEVICE_CPU),\n    BoostedTreesSparseCalculateBestFeatureSplitOp);\n\nclass BoostedTreesMakeStatsSummaryOp : public OpKernel {\n public:\n  explicit BoostedTreesMakeStatsSummaryOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_features\", &num_features_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_ids\n    const Tensor* node_ids_t;\n    OP_REQUIRES_OK(context, context->input(\"node_ids\", &node_ids_t));\n    const auto node_ids = node_ids_t->vec<int32>();\n    // gradients\n    const Tensor* gradients_t;\n    OP_REQUIRES_OK(context, context->input(\"gradients\", &gradients_t));\n    const auto gradients = gradients_t->matrix<float>();\n    OP_REQUIRES(\n        context, node_ids.size() == gradients.dimension(0),\n        errors::InvalidArgument(\n            \"node_ids size should match 0th dim of gradients. node ids \"\n            \"size: \",\n            node_ids.size(), \", gradients dim0: \", gradients.dimension(0)));\n    // hessians\n    const Tensor* hessians_t;\n    OP_REQUIRES_OK(context, context->input(\"hessians\", &hessians_t));\n    const auto hessians = hessians_t->matrix<float>();\n    // bucketized_features\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features_list\",\n                                                &bucketized_features_list));\n    // Infer batch size.\n    const int64_t batch_size = node_ids_t->dim_size(0);\n\n    // Allocate temporary stats tensor (Rank 4).\n    Tensor temp_stats_double_t;\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DT_DOUBLE,\n                                {num_features_, max_splits_, num_buckets_, 2},\n                                &temp_stats_double_t));\n    auto temp_stats_double = temp_stats_double_t.tensor<double, 4>();\n    temp_stats_double.setZero();\n\n    // Partition by node, and then bucketize.\n    for (int feature_idx = 0; feature_idx < num_features_; ++feature_idx) {\n      const auto& features = bucketized_features_list[feature_idx].vec<int32>();\n      for (int i = 0; i < batch_size; ++i) {\n        const int32_t node = node_ids(i);\n        const int32_t bucket = features(i);\n        temp_stats_double(feature_idx, node, bucket, 0) += gradients(i, 0);\n        temp_stats_double(feature_idx, node, bucket, 1) += hessians(i, 0);\n      }\n    }\n\n    // Copy temp tensor over to output tensor.\n    Tensor* output_stats_summary_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"stats_summary\", temp_stats_double_t.shape(),\n                                &output_stats_summary_t));\n    output_stats_summary_t->tensor<float, 4>() =\n        temp_stats_double.template cast<float>();\n  }\n\n private:\n  int max_splits_;\n  int num_buckets_;\n  int num_features_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"BoostedTreesMakeStatsSummary\").Device(DEVICE_CPU),\n                        BoostedTreesMakeStatsSummaryOp);\n\n// TODO(tanzheny): Add an option of default value into the API interface.\nclass BoostedTreesAggregateStatsOp : public OpKernel {\n public:\n  explicit BoostedTreesAggregateStatsOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_ids.\n    const Tensor* node_ids_t;\n    OP_REQUIRES_OK(context, context->input(\"node_ids\", &node_ids_t));\n    const auto node_ids = node_ids_t->vec<int32>();\n\n    // gradients.\n    const Tensor* gradients_t;\n    OP_REQUIRES_OK(context, context->input(\"gradients\", &gradients_t));\n    const auto gradients = gradients_t->matrix<float>();\n\n    OP_REQUIRES(\n        context, node_ids.size() == gradients.dimension(0),\n        errors::InvalidArgument(\n            \"node_ids size should match 0th dim of gradients. node ids \"\n            \"size: \",\n            node_ids.size(), \", gradients dim0: \", gradients.dimension(0)));\n\n    // hessians.\n    const Tensor* hessians_t;\n    OP_REQUIRES_OK(context, context->input(\"hessians\", &hessians_t));\n    const auto hessians = hessians_t->matrix<float>();\n\n    // feature.\n    const Tensor* feature_t;\n    OP_REQUIRES_OK(context, context->input(\"feature\", &feature_t));\n    const auto feature = feature_t->matrix<int32>();\n\n    // Infer batch size, feature dimension and stats dimension.\n    const int64_t batch_size = node_ids_t->dim_size(0);\n    const int64_t logits_dims = gradients_t->dim_size(1);\n    const int64_t hessians_dims = hessians_t->dim_size(1);\n    const int64_t stats_dims = logits_dims + hessians_dims;\n    const int64_t feature_dims = feature_t->dim_size(1);\n\n    // Allocate temporary stats tensor (Rank 4), upcasting to double.\n    // A default bucket is added to the end for missing/default values.\n    Tensor temp_stats_double_t;\n    OP_REQUIRES_OK(\n        context, context->allocate_temp(\n                     DT_DOUBLE,\n                     {max_splits_, feature_dims, num_buckets_ + 1, stats_dims},\n                     &temp_stats_double_t));\n    auto temp_stats_double = temp_stats_double_t.tensor<double, 4>();\n    temp_stats_double.setZero();\n\n    for (int i = 0; i < batch_size; ++i) {\n      const int32_t node = node_ids(i);\n      OP_REQUIRES(context, node >= 0,\n                  errors::InvalidArgument(\n                      \"node_ids \", i, \"th entry should be >=0, got: \", node));\n      for (int feature_dim = 0; feature_dim < feature_dims; ++feature_dim) {\n        const int32_t feature_value = feature(i, feature_dim);\n        const int32_t bucket =\n            (feature_value == -1) ? num_buckets_ : feature_value;\n        for (int stat_dim = 0; stat_dim < logits_dims; ++stat_dim) {\n          temp_stats_double(node, feature_dim, bucket, stat_dim) +=\n              gradients(i, stat_dim);\n        }\n        for (int stat_dim = logits_dims; stat_dim < stats_dims; ++stat_dim) {\n          temp_stats_double(node, feature_dim, bucket, stat_dim) +=\n              hessians(i, stat_dim - logits_dims);\n        }\n      }\n    }\n\n    // Copy temp tensor over to output tensor, downcasting to float.\n    Tensor* output_stats_summary_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"stats_summary\", temp_stats_double_t.shape(),\n                                &output_stats_summary_t));\n    output_stats_summary_t->tensor<float, 4>() =\n        temp_stats_double.template cast<float>();\n  }\n\n private:\n  int max_splits_;\n  int num_buckets_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"BoostedTreesAggregateStats\").Device(DEVICE_CPU),\n                        BoostedTreesAggregateStatsOp);\n\n// Key based on node id, feature dimension and bucket id.\nstruct StatsPartitionKey {\n  StatsPartitionKey(const int32_t node_id, const int32_t feature_dim,\n                    const int32_t bucket_id)\n      : node_id(node_id), feature_dim(feature_dim), bucket_id(bucket_id) {}\n\n  bool operator==(const StatsPartitionKey& other) const {\n    return (node_id == other.node_id) && (feature_dim == other.feature_dim) &&\n           (bucket_id == other.bucket_id);\n  }\n\n  // Compare for StatsPartitionKey.\n  struct Less {\n    bool operator()(const StatsPartitionKey& a,\n                    const StatsPartitionKey& b) const {\n      if (a.node_id < b.node_id) {\n        return true;\n      }\n      if ((a.node_id == b.node_id) && (a.feature_dim < b.feature_dim)) {\n        return true;\n      }\n      if ((a.node_id == b.node_id) && (a.feature_dim == b.feature_dim) &&\n          (a.bucket_id < b.bucket_id)) {\n        return true;\n      }\n      return false;\n    }\n  };\n\n  // Tree node id.\n  int32 node_id;\n  // Dimension within feature column.\n  int32 feature_dim;\n  // bucketized feature value .\n  int32 bucket_id;\n};\n\ntypedef std::map<StatsPartitionKey, std::vector<float>, StatsPartitionKey::Less>\n    StatsPartitionMap;\ntypedef StatsPartitionMap::iterator StatsPartitionIterator;\n\n// Key based on instance and feature dimension.\nstruct InstanceFeatureDimKey {\n  InstanceFeatureDimKey() : instance(-1), feature_dim(-1) {}\n\n  InstanceFeatureDimKey(const int32_t instance, const int32_t feature_dim)\n      : instance(instance), feature_dim(feature_dim) {}\n\n  bool operator==(const InstanceFeatureDimKey& other) const {\n    return (instance == other.instance) && (feature_dim == other.feature_dim);\n  }\n\n  // Compare for InstanceFeatureDimKey.\n  struct Less {\n    bool operator()(const InstanceFeatureDimKey& a,\n                    const InstanceFeatureDimKey& b) const {\n      if (a.instance < b.instance) {\n        return true;\n      }\n      if ((a.instance == b.instance) && (a.feature_dim < b.feature_dim)) {\n        return true;\n      }\n      return false;\n    }\n  };\n\n  // Instance id within a batch.\n  int32 instance;\n  // Dimension within feature column.\n  int32 feature_dim;\n};\n\n// Add statistics to StatsPartitionMap for (instance, feature dim, bucket id).\nstatic void AddInstanceStatsToMap(\n    const int32_t instance, const int32_t feature_dim, const int32_t bucket_id,\n    const int32_t logits_dims, const int32_t stats_dims,\n    StatsPartitionMap* stats_map, const TTypes<float>::ConstMatrix& gradients,\n    const TTypes<float>::ConstMatrix& hessians,\n    const TTypes<int32>::ConstVec& node_ids) {\n  const int32_t node_id = node_ids(instance);\n  const auto key = StatsPartitionKey(node_id, feature_dim, bucket_id);\n  std::pair<StatsPartitionIterator, bool> const& insert_result =\n      stats_map->insert(StatsPartitionIterator::value_type(\n          key, std::vector<float>(stats_dims, 0.0f)));\n  auto& stats = insert_result.first->second;\n  for (int stat_dim = 0; stat_dim < logits_dims; ++stat_dim) {\n    stats[stat_dim] += gradients(instance, stat_dim);\n  }\n  for (int stat_dim = logits_dims; stat_dim < stats_dims; ++stat_dim) {\n    stats[stat_dim] += hessians(instance, stat_dim - logits_dims);\n  }\n}\n\n// Add statistics to StatsPartitionMap for bucket_id ranging from\n// (start_instance, start_feature_dim) to (end_instance, end_feature_dim),\n// inclusive on start and end instances, exclusive on end feature dim.\nstatic void AddRangeStats(const int start_instance, const int end_instance,\n                          const int start_feature_dim,\n                          const int end_feature_dim,\n                          StatsPartitionMap* stats_map,\n                          const TTypes<float>::ConstMatrix& gradients,\n                          const TTypes<float>::ConstMatrix& hessians,\n                          const TTypes<int32>::ConstVec& node_ids,\n                          const int32_t feature_dims, const int32_t bucket_id,\n                          const int32_t logits_dims, const int32_t stats_dims) {\n  DCHECK_LE(start_instance, end_instance);\n  if (start_instance == end_instance) {\n    DCHECK_LT(start_feature_dim, end_feature_dim);\n  }\n  for (int32_t instance = start_instance; instance <= end_instance;\n       ++instance) {\n    const int32_t start_f_dim =\n        (instance == start_instance) ? start_feature_dim + 1 : 0;\n    const int32_t end_f_dim =\n        (instance == end_instance) ? end_feature_dim : feature_dims;\n    for (int32_t f_dim = start_f_dim; f_dim < end_f_dim; ++f_dim) {\n      AddInstanceStatsToMap(instance, f_dim, bucket_id, logits_dims, stats_dims,\n                            stats_map, gradients, hessians, node_ids);\n    }\n  }\n}\n\nclass BoostedTreesSparseAggregateStatsOp : public OpKernel {\n public:\n  explicit BoostedTreesSparseAggregateStatsOp(\n      OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    // node_ids.\n    const Tensor* node_ids_t;\n    OP_REQUIRES_OK(context, context->input(\"node_ids\", &node_ids_t));\n    const auto node_ids = node_ids_t->vec<int32>();\n\n    // gradients.\n    const Tensor* gradients_t;\n    OP_REQUIRES_OK(context, context->input(\"gradients\", &gradients_t));\n    const auto gradients = gradients_t->matrix<float>();\n\n    // hessians.\n    const Tensor* hessians_t;\n    OP_REQUIRES_OK(context, context->input(\"hessians\", &hessians_t));\n    const auto hessians = hessians_t->matrix<float>();\n\n    // feature indices.\n    const Tensor* feature_indices_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"feature_indices\", &feature_indices_t));\n    const auto feature_indices = feature_indices_t->matrix<int32>();\n\n    // feature values.\n    const Tensor* feature_values_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"feature_values\", &feature_values_t));\n    const auto feature_values = feature_values_t->vec<int32>();\n\n    // feature shape.\n    const Tensor* feature_shape_t;\n    OP_REQUIRES_OK(context, context->input(\"feature_shape\", &feature_shape_t));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(feature_shape_t->shape()),\n                errors::InvalidArgument(\n                    \"Input shapes should be a vector but received shapes \",\n                    feature_shape_t->shape().DebugString()));\n    const auto feature_shape = feature_shape_t->vec<int32>();\n\n    const int64_t batch_size = gradients_t->dim_size(0);\n    const int64_t logits_dims = gradients_t->dim_size(1);\n    const int64_t hessians_dims = hessians_t->dim_size(1);\n    const int64_t stats_dims = logits_dims + hessians_dims;\n    const int64_t num_sparse_entries = feature_indices_t->dim_size(0);\n    const int32_t feature_dims = feature_shape(1);\n    OP_REQUIRES(context, num_sparse_entries <= batch_size * feature_dims,\n                errors::InvalidArgument(\n                    \"feature_indices dim0 should be <= gradients dim0 * \"\n                    \"feature_shape[1]. features_indices dim0: \",\n                    num_sparse_entries, \" gradients dim0: \", batch_size,\n                    \", feature_shape[1]: \", feature_dims));\n\n    // Aggregate statistics info to map.\n    StatsPartitionMap stats_map;\n\n    int prev_instance = 0;\n    int prev_f_dim = -1;\n\n    for (int i = 0; i < num_sparse_entries; ++i) {\n      // the instance number within a batch\n      const int32_t instance = feature_indices(i, 0);\n      DCHECK_LE(instance, batch_size);\n      DCHECK_GE(instance, prev_instance);\n      // the node id within a tree.\n      const int32_t node_id = node_ids(instance);\n      DCHECK_LE(node_id, max_splits_);\n      // the feature dimension.\n      const int32_t f_dim = feature_indices(i, 1);\n      DCHECK_LE(f_dim, feature_dims);\n      // the bucket id of the value.\n      const int32_t bucket_id = feature_values(i);\n      DCHECK_LE(bucket_id, num_buckets_);\n\n      // Add statistics for the missing entries into default bucket.\n      // The last bucket is default bucket.\n      const int missing_entry_bucket = num_buckets_;\n      AddRangeStats(prev_instance, instance, prev_f_dim, f_dim, &stats_map,\n                    gradients, hessians, node_ids, feature_dims,\n                    missing_entry_bucket, logits_dims, stats_dims);\n      prev_instance = instance;\n      prev_f_dim = f_dim;\n      // Add statistics for the non-missing entry into\n      // (cur_instance, cur_f_dim, bucket_id).\n      AddInstanceStatsToMap(instance, f_dim, bucket_id, logits_dims, stats_dims,\n                            &stats_map, gradients, hessians, node_ids);\n    }\n    AddRangeStats(prev_instance, batch_size - 1, prev_f_dim, feature_dims,\n                  &stats_map, gradients, hessians, node_ids, feature_dims,\n                  num_buckets_, logits_dims, stats_dims);\n\n    // Serialize statistics info map to tensor output.\n    const int64_t num_slots = stats_map.size() * stats_dims;\n    Tensor* summary_indices_t = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"stats_summary_indices\",\n                                            TensorShape({num_slots, 4}),\n                                            &summary_indices_t));\n    auto summary_indices = summary_indices_t->matrix<int32>();\n    Tensor* summary_values_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"stats_summary_values\",\n                                                     TensorShape({num_slots}),\n                                                     &summary_values_t));\n    auto summary_values = summary_values_t->vec<float>();\n    int entry_index = 0;\n    for (auto& iter : stats_map) {\n      for (int stat_dim = 0; stat_dim < stats_dims; ++stat_dim) {\n        summary_indices(entry_index, 0) = iter.first.node_id;\n        summary_indices(entry_index, 1) = iter.first.feature_dim;\n        summary_indices(entry_index, 2) = iter.first.bucket_id;\n        summary_indices(entry_index, 3) = stat_dim;\n        summary_values(entry_index) = iter.second[stat_dim];\n        ++entry_index;\n      }\n    }\n\n    Tensor* summary_shape_t = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"stats_summary_shape\",\n                                          TensorShape({4}), &summary_shape_t));\n    auto summary_shape = summary_shape_t->vec<int32>();\n    summary_shape(0) = max_splits_;\n    summary_shape(1) = feature_dims;\n    summary_shape(2) = num_buckets_ + 1;\n    summary_shape(3) = stats_dims;\n  }\n\n private:\n  int max_splits_;\n  int num_buckets_;\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesSparseAggregateStats\").Device(DEVICE_CPU),\n    BoostedTreesSparseAggregateStatsOp);\n\n}  // namespace tensorflow\n", "# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for boosted_trees stats kernels.\"\"\"\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import boosted_trees_ops\nfrom tensorflow.python.ops import gen_boosted_trees_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.platform import googletest\n\n\n_INEQUALITY_DEFAULT_LEFT = 'INEQUALITY_DEFAULT_LEFT'.encode('utf-8')\n_INEQUALITY_DEFAULT_RIGHT = 'INEQUALITY_DEFAULT_RIGHT'.encode('utf-8')\n_EQUALITY_DEFAULT_RIGHT = 'EQUALITY_DEFAULT_RIGHT'.encode('utf-8')\n\n\nclass StatsOpsTest(test_util.TensorFlowTestCase):\n  \"\"\"Tests stats_ops.\"\"\"\n\n  def _append_zeros_for_default_bucket(self, stats_summary):\n    summary_shapes = stats_summary.shape\n    # pad zeros for missing value bucket.\n    stats_summary = np.concatenate(\n        (stats_summary,\n         np.zeros([summary_shapes[0], summary_shapes[1], 1, summary_shapes[3]\n                  ])),\n        axis=2)\n    return stats_summary\n\n  def add_f_dim_and_append_zeros(self, stats_summaries):\n    \"\"\"Transform a list of stats summaries, adding a feature dimension.\n\n    The input shape is a list of arrays of shape [max_splits, num_buckets,\n    logits+hess dim]. This transformation returns a list of arrays of shape\n    [max_splits, 1, num_buckets + 1, logits+hess dim].\n\n    Args:\n      stats_summaries: a list of numpy arrays.\n\n    Returns:\n      A list of numpy arrays.\n    \"\"\"\n    return [\n        self._append_zeros_for_default_bucket(np.expand_dims(feature, axis=1))\n        for feature in stats_summaries\n    ]\n\n  def _get_stats_summary_for_split(self):\n    return [\n        [\n            [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .07], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .58], [0., 0.], [.3, .4]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 0\n        [\n            [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .06], [.06, .07]],  # node 1\n            [[.1, .1], [.2, .3], [-.4, .5], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 1\n    ]  # shape=[feature_dim, max_splits, num_buckets, 2]\n\n  def _get_sparse_stats_summary_for_split(self, stats_summary=None):\n    if stats_summary is None:\n      stats_summary = np.asarray(self._get_stats_summary_for_split())\n      stats_summary[0][0][1] = np.zeros([2])\n      stats_summary[1][0][2] = np.zeros([2])\n      stats_summary = np.moveaxis(stats_summary, 0, 1)\n    slices = stats_summary.nonzero()\n    values = stats_summary[slices]\n    indices = np.asarray(slices)\n    return np.moveaxis(indices, 0, 1), values, stats_summary.shape\n\n  def testCalculateBestSplitsWithoutRegularizationInSparse(self):\n    # This test uses the same data as dense, but run in sparse kernel and\n    # make sure the sparse kernel returns same result as dense kernel.\n    dense_summary = np.asarray([\n        [\n            [[0., 0.], [.0, .0], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .07], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .58], [0., 0.], [.3, .4]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 0\n        [\n            [[0., 0.], [0., 0.], [.0, .0], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .06], [.06, .07]],  # node 1\n            [[.1, .1], [.2, .3], [-.4, .5], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    node_id_range = [1, 3]\n    dense_summary = np.moveaxis(dense_summary, 0, 1)\n    dense_shape = dense_summary.shape\n\n    default_bucket_summary = np.zeros(dense_shape[0:2] + (1, dense_shape[3]))\n    sparse_summary = np.concatenate((dense_summary, default_bucket_summary),\n                                    axis=2)\n    slices = sparse_summary.nonzero()\n    summary_values = sparse_summary[slices]\n    summary_indices = np.asarray(slices)\n    summary_indices = np.moveaxis(summary_indices, 0, 1)\n    summary_shape = sparse_summary.shape\n\n    (node_ids, gains, _, _, left_node_contribs, right_node_contribs,\n     _) = self.evaluate(\n         boosted_trees_ops.sparse_calculate_best_feature_split(\n             node_id_range,\n             summary_indices,\n             summary_values,\n             summary_shape,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.02823, 0.41184], gains)\n    self.assertAllClose([-0.6], left_node_contribs[0])\n    self.assertAllClose([-0.076923], right_node_contribs[0])\n\n  def testSparseCalculateBestSplitsWithoutRegularization(self):\n    node_id_range = [1, 3]\n    (summary_indices, summary_values,\n     summary_shape) = self._get_sparse_stats_summary_for_split()\n\n    (node_ids, gains, feature_dimensions, thresholds, left_node_contribs,\n     right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.sparse_calculate_best_feature_split(\n             node_id_range,\n             summary_indices,\n             summary_values,\n             summary_shape,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.116495, 0.60429], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.631579], [-0.770833]], left_node_contribs)\n    self.assertAllClose([[0.833333], [0.8]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestGainsWithoutRegularization_v1_op(self):\n    \"\"\"Testing Gain calculation without any regularization.\"\"\"\n    with self.cached_session() as sess:\n      max_splits = 7\n      node_id_range = [1, 3]  # node 1 through 2 will be processed.\n      stats_summary_list = self._get_stats_summary_for_split()\n\n      (node_ids_list, gains_list, thresholds_list, left_node_contribs_list,\n       right_node_contribs_list\n      ) = boosted_trees_ops.calculate_best_gains_per_feature(\n          node_id_range,\n          stats_summary_list,\n          l1=0.0,\n          l2=0.0,\n          tree_complexity=0.0,\n          min_node_weight=0,\n          max_splits=max_splits)\n\n      self.assertAllEqual([[1, 2], [1, 2]], self.evaluate(node_ids_list))\n      self.assertAllClose([[0.004775, 0.41184], [0.02823, 0.41184]],\n                          self.evaluate(gains_list))\n      self.assertAllEqual([[1, 1], [1, 1]], self.evaluate(thresholds_list))\n      # The left node contrib will be later added to the previous node value to\n      # make the left node value, and the same for right node contrib.\n      self.assertAllClose([[[-.416667], [.568966]], [[-.6], [-.75]]],\n                          self.evaluate(left_node_contribs_list))\n      self.assertAllClose([[[-.592593], [-.75]], [[-.076923], [.568966]]],\n                          self.evaluate(right_node_contribs_list))\n\n  def testCalculateBestFeaturesInvalidSplitType_v2_op(self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [9, 12]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    stats_summaries = self.add_f_dim_and_append_zeros(stats_summaries)\n\n    with self.assertRaisesRegex(Exception, 'Incorrect split type'):\n      self.evaluate(\n          boosted_trees_ops.calculate_best_feature_split_v2(\n              node_id_range,\n              stats_summaries,\n              split_types=['INVALID'] * len(candidate_feature_ids),\n              candidate_feature_ids=candidate_feature_ids,\n              l1=0.0,\n              l2=0.0,\n              tree_complexity=0.0,\n              min_node_weight=0,\n              logits_dimension=1))\n\n  def testCalculateBestFeaturesWithoutRegularization_v2_op(self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [9, 12]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    stats_summaries = self.add_f_dim_and_append_zeros(stats_summaries)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range,\n             stats_summaries,\n             split_types=['inequality'] * len(candidate_feature_ids),\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature_id and dimension that has the best gain per node.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.02823, 0.41184], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllEqual([12, 9], feature_ids)\n    f_dim = 0  # Both features only have one dimension.\n    self.assertAllEqual([f_dim] * 2, feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-.6], [.568966]], left_node_contribs)\n    self.assertAllClose([[-.076923], [-.75]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureSplitsWithoutRegularization_v2_op(self):\n    \"\"\"Testing best split without any regularization for a multi-dim feature.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature_id and dimension that has the best gain per node.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.02823, 0.41184], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 0], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-.6], [.568966]], left_node_contribs)\n    self.assertAllClose([[-.076923], [-.75]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureSplitWMissingValuesWORegularization_v2_op(\n      self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.116495, 0.60429], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.631579], [-0.770833]], left_node_contribs)\n    self.assertAllClose([[0.833333], [0.8]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureEqualitySplitsWithoutRegularization_v2_op(\n      self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['equality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    # 0.116495 = (-0.05)^2/0.06 + 0.36^2/0.57 - 0.31^2/0.63\n    # 0.60429 = (-0.4)^2/0.5 + 0.37^2/0.48 - 0.03^2/0.98\n    self.assertAllClose([0.116495, 0.60429], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([2, 2], thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    # left contrib 0.83 = 0.05/0.06, 0.8 = 0.4/0.5\n    self.assertAllClose([[0.833333], [.8]], left_node_contribs)\n    # right contrib -0.6315 = -0.36/0.57, -0.7708 = -0.37/0.48\n    self.assertAllClose([[-0.631579], [-0.770833]], right_node_contribs)\n    self.assertAllEqual([_EQUALITY_DEFAULT_RIGHT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureMixedSplitTypeWithoutRegularization_v2_op(\n      self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [9, 12]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Add in feature dimension.\n    stats_summaries = [\n        np.expand_dims(feature, axis=1) for feature in stats_summaries\n    ]\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range,\n             stats_summaries,\n             split_types=['inequality', 'equality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    # 0.116495 = (-0.05)^2/0.06 + 0.36^2/0.57 - 0.31^2/0.63\n    # 0.60429 = (-0.4)^2/0.5 + 0.37^2/0.48 - 0.03^2/0.98\n    self.assertAllClose([0.116495, 0.60429], gains)\n    self.assertAllEqual([12, 12], feature_ids)\n    f_dim = 0  # Both features only have one dimension.\n    self.assertAllEqual([f_dim, f_dim], feature_dimensions)\n    self.assertAllEqual([2, 2], thresholds)\n    # Same result as equality only test, as feature_1 is chose for both nodes.\n    # left contrib 0.83 = 0.05/0.06, 0.8 = 0.4/0.5\n    self.assertAllClose([[0.833333], [.8]], left_node_contribs)\n    # right contrib -0.6315 = -0.36/0.57, -0.7708 = -0.37/0.48\n    self.assertAllClose([[-0.631579], [-0.770833]], right_node_contribs)\n    # Feature 1 is inequality.\n    self.assertAllEqual([_EQUALITY_DEFAULT_RIGHT, _EQUALITY_DEFAULT_RIGHT],\n                        split_types)\n\n  def testCalculateBestGainsWithL2_v1_op(self):\n    \"\"\"Testing Gain calculation with L2.\"\"\"\n    with self.cached_session() as sess:\n      max_splits = 7\n      node_id_range = [1, 3]  # node 1 through 2 will be processed.\n      stats_summary_list = self._get_stats_summary_for_split()\n\n      (node_ids_list, gains_list, thresholds_list, left_node_contribs_list,\n       right_node_contribs_list\n      ) = boosted_trees_ops.calculate_best_gains_per_feature(\n          node_id_range,\n          stats_summary_list,\n          l1=0.0,\n          l2=0.1,\n          tree_complexity=0.0,\n          min_node_weight=0,\n          max_splits=max_splits)\n\n      self.assertAllEqual([[1, 2], [1, 2]], self.evaluate(node_ids_list))\n      self.assertAllClose([[0., 0.33931375], [0.01879096, 0.33931375]],\n                          self.evaluate(gains_list))\n      self.assertAllEqual([[0, 1], [1, 1]], self.evaluate(thresholds_list))\n      # The left node contrib will be later added to the previous node value to\n      # make the left node value, and the same for right node contrib.\n      self.assertAllClose([[[0.], [.485294]], [[-.5], [-.6]]],\n                          self.evaluate(left_node_contribs_list))\n      self.assertAllClose([[[-.424658], [-.6]], [[-.043478], [.485294]]],\n                          self.evaluate(right_node_contribs_list))\n\n  def testCalculateMultiDimBestFeatureSplitsWithL2_v2_op(self):\n    \"\"\"Testing best split calculation with L2.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 0], feature_dimensions)\n    self.assertAllClose([0.01879096, 0.33931375], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    # # The left node contrib will be later added to the previous node value to\n    # # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-.5], [.485294]], left_node_contribs)\n    self.assertAllClose([[-.043478], [-.6]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateMultiDimBestFeatureSplitsWithMissingValuesL2_v2_op(self):\n    \"\"\"Testing best split calculation with L2.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllClose([0.077414, 0.501868], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.537313], [-0.637931]], left_node_contribs)\n    self.assertAllClose([[0.3125], [0.666667]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateMultiDimBestFeatureEqualitySplitsWithL2_v2_op(self):\n    \"\"\"Testing best split calculation with L2.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['equality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    # 0.077414 = 0.05^2/0.16 + 0.36^2/0.67 - 0.31^2/0.73\n    # 0.501868 = 0.4^2/0.6 + 0.37^2/0.58 - 0.03^2/1.08\n    self.assertAllClose([0.077414, 0.501868], gains)\n    self.assertAllEqual([2, 2], thresholds)\n    # # The left node contrib will be later added to the previous node value to\n    # # make the left node value, and the same for right node contrib.\n    # left contrib 0.3125 = 0.05/0.16, 0.6667 = 0.4/0.6\n    self.assertAllClose([[0.3125], [0.666667]], left_node_contribs)\n    # right contrib -0.5373 = -0.36/0.67, -0.6379 = -0.37/0.58\n    self.assertAllClose([[-0.537313], [-0.637931]], right_node_contribs)\n    self.assertAllEqual([_EQUALITY_DEFAULT_RIGHT] * 2, split_types)\n\n  def testSparseCalculateBestSplitsWithL2(self):\n    node_id_range = [1, 3]\n    (summary_indices, summary_values,\n     summary_shape) = self._get_sparse_stats_summary_for_split()\n\n    (node_ids, gains, feature_dimensions, thresholds, left_node_contribs,\n     right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.sparse_calculate_best_feature_split(\n             node_id_range,\n             summary_indices,\n             summary_values,\n             summary_shape,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.077414, 0.501868], gains)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.537313], [-0.637931]], left_node_contribs)\n    self.assertAllClose([[0.3125], [0.666667]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT, _INEQUALITY_DEFAULT_LEFT],\n                        split_types)\n\n  def testCalculateBestGainsWithL1_v1_op(self):\n    \"\"\"Testing Gain calculation with L1.\"\"\"\n    with self.cached_session() as sess:\n      max_splits = 7\n      node_id_range = [1, 3]  # node 1 through 2 will be processed.\n      stats_summary_list = self._get_stats_summary_for_split()\n\n      l1 = 0.1\n      (node_ids_list, gains_list, thresholds_list, left_node_contribs_list,\n       right_node_contribs_list\n      ) = boosted_trees_ops.calculate_best_gains_per_feature(\n          node_id_range,\n          stats_summary_list,\n          l1=l1,\n          l2=0.0,\n          tree_complexity=0.0,\n          min_node_weight=0,\n          max_splits=max_splits)\n\n      self.assertAllEqual([[0, 1], [1, 1]], self.evaluate(thresholds_list))\n\n      self.assertAllEqual([[1, 2], [1, 2]], self.evaluate(node_ids_list))\n      self.assertAllClose([[[0.0], [0.3965517]], [[-0.4], [-0.5]]],\n                          self.evaluate(left_node_contribs_list))\n\n      self.assertAllClose([[[-0.3333333], [-0.5]], [[0.0], [0.396552]]],\n                          self.evaluate(right_node_contribs_list))\n\n      # Gain should also include an adjustment of the gradient by l1.\n      self.assertAllClose([[0.0, 0.191207], [0.01, 0.191207]],\n                          self.evaluate(gains_list))\n\n  def testCalculateBestMultiDimFeatureSplitsWithL1_v2_op(self):\n    \"\"\"Testing best split calculation with L1.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.1,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    # Gain should also include an adjustment of the gradient by l1.\n    self.assertAllClose([0.01, 0.191207], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[-0.4], [-0.5]], left_node_contribs)\n    self.assertAllClose([[0.], [0.396552]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureSplitsWithMissingValuesL1_v2_op(self):\n    \"\"\"Testing best split calculation with L1.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.1,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    # Gain should also include an adjustment of the gradient by l1.\n    # (0.36-0.1)^2/0.57 + 0 - (0.31-0.1)^2/0.63 = 0.048597\n    # (0.37-0.1)^2/0.48 + (-0.4+0.1)^2/0.5 = 0.331875\n    self.assertAllClose([0.048597, 0.331875], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    # -(0.36-0.1)/0.57 = -0.45614\n    # -(0.37-0.1)/0.48 = -0.5625\n    self.assertAllClose([[-0.45614], [-0.5625]], left_node_contribs)\n    # -(-0.4+0.1)/0.5 = 0.6\n    self.assertAllClose([[0.], [0.6]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureEqualitySplitsWithL1_v2_op(self):\n    \"\"\"Testing best split calculation with L1.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['equality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.1,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    # 0.048597 = 0 + 0.26^2/0.57 - 0.21^2/0.63\n    # 0.501868 = 0.3^2/0.5 + 0.27^2/0.48 - 0\n    self.assertAllClose([0.048597, 0.331875], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([2, 2], thresholds)\n    # # The left node contrib will be later added to the previous node value to\n    # # make the left node value, and the same for right node contrib.\n    # left contrib 0 (-0.05>-0.1), 0.6 = 0.3/0.5\n    self.assertAllClose([[0], [0.6]], left_node_contribs)\n    # right contrib -0.45614 = -0.26/0.57, -0.5625 = -0.27/0.48\n    self.assertAllClose([[-0.45614], [-0.5625]], right_node_contribs)\n    self.assertAllEqual([_EQUALITY_DEFAULT_RIGHT] * 2, split_types)\n\n  def testSparseCalculateBestSplitsWithL1(self):\n    node_id_range = [1, 3]\n    (summary_indices, summary_values,\n     summary_shape) = self._get_sparse_stats_summary_for_split()\n\n    (node_ids, gains, feature_dimensions, thresholds, left_node_contribs,\n     right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.sparse_calculate_best_feature_split(\n             node_id_range,\n             summary_indices,\n             summary_values,\n             summary_shape,\n             l1=0.1,\n             l2=0.,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.048597, 0.331875], gains)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.45614], [-0.5625]], left_node_contribs)\n    self.assertAllClose([[0.0], [0.6]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestGainsWithTreeComplexity_v1_op(self):\n    \"\"\"Testing best gain calculation with tree complexity.\"\"\"\n    with self.cached_session() as sess:\n      max_splits = 7\n      node_id_range = [1, 3]  # node 1 through 2 will be processed.\n      stats_summary_list = self._get_stats_summary_for_split()\n\n      l2 = 0.1\n      tree_complexity = 3.\n      (node_ids_list, gains_list, thresholds_list, left_node_contribs_list,\n       right_node_contribs_list\n      ) = boosted_trees_ops.calculate_best_gains_per_feature(\n          node_id_range,\n          stats_summary_list,\n          l1=0.0,\n          l2=l2,\n          tree_complexity=tree_complexity,\n          min_node_weight=0,\n          max_splits=max_splits)\n\n      self.assertAllEqual([[1, 2], [1, 2]], self.evaluate(node_ids_list))\n\n      self.assertAllClose([[-3., -2.66068625], [-2.98120904, -2.66068625]],\n                          self.evaluate(gains_list))\n\n      self.assertAllEqual([[0, 1], [1, 1]], self.evaluate(thresholds_list))\n      # The left node contrib will be later added to the previous node value to\n      # make the left node value, and the same for right node contrib.\n      self.assertAllClose([[[0.], [.485294]], [[-.5], [-.6]]],\n                          self.evaluate(left_node_contribs_list))\n      self.assertAllClose([[[-.424658], [-.6]], [[-.043478], [.485294]]],\n                          self.evaluate(right_node_contribs_list))\n\n  def testCalculateBestMultiDimFeatureSplitsWithTreeComplexity_v2_op(self):\n    \"\"\"Testing best split calculation with tree complexity.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=3,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    # Gain should also include an adjustment of the gradient by l1.\n    self.assertAllClose([-2.98120904, -2.66068625], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 0], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[-0.5], [0.485294]], left_node_contribs)\n    self.assertAllClose([[-0.043478], [-.6]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureSplitsWMissingValsTreeComplexity_v2_op(\n      self):\n    \"\"\"Testing best split calculation with tree complexity.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=3,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    # Get same result as v1 op (CalculateBestGainsPerFeature), and find the\n    # feature dimension that has the best gain.\n    self.assertAllEqual([1, 2], node_ids)\n    # Gain should also include an adjustment of the gradient by l1.\n    self.assertAllClose([-2.922586, -2.498132], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[-0.537313], [-0.637931]], left_node_contribs)\n    self.assertAllClose([[0.3125], [0.666667]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestMultiDimFeatureEqualitySplitsWithTreeComplexity_v2_op(\n      self):\n    \"\"\"Testing best split calculation with tree complexity.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summaries = self._get_stats_summary_for_split()\n    # Convert from list of arrays to a single array and reshape to [max_splits,\n    # feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summaries, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['equality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.1,\n             tree_complexity=3,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    # -2.922586 = 0.05^2/0.16 + 0.36^2/0.67 - 0.31^2/0.73 - 3\n    # -2.498132 = 0.4^2/0.6 + 0.37^2/0.58 - 0.03^2/1.08 - 3\n    self.assertAllClose([-2.922586, -2.498132], gains)\n    self.assertAllEqual([2, 2], thresholds)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    # # The left node contrib will be later added to the previous node value to\n    # # make the left node value, and the same for right node contrib.\n    # left contrib 0.3125 = 0.05/0.16, 0.6667 = 0.4/0.6\n    self.assertAllClose([[0.3125], [0.666667]], left_node_contribs)\n    # right contrib -0.5373 = -0.36/0.67, -0.6379 = -0.37/0.58\n    self.assertAllClose([[-0.537313], [-0.637931]], right_node_contribs)\n    self.assertAllEqual([_EQUALITY_DEFAULT_RIGHT] * 2, split_types)\n\n  def testSparseCalculateBestSplitsWithTreeComplexity(self):\n    \"\"\"Testing best split calculation with tree complexity.\"\"\"\n    node_id_range = [1, 3]\n    (summary_indices, summary_values,\n     summary_shape) = self._get_sparse_stats_summary_for_split()\n\n    (node_ids, gains, feature_dimensions, thresholds, left_node_contribs,\n     right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.sparse_calculate_best_feature_split(\n             node_id_range,\n             summary_indices,\n             summary_values,\n             summary_shape,\n             l1=0.,\n             l2=0.1,\n             tree_complexity=3.,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([-2.922586, -2.498132], gains)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[-0.537313], [-0.637931]], left_node_contribs)\n    self.assertAllClose([[0.3125], [0.666667]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestGainsWithMinNodeWeight_v1_op(self):\n    \"\"\"Testing Gain calculation with min node weight.\"\"\"\n    with self.cached_session() as sess:\n      max_splits = 7\n      node_id_range = [1, 3]  # node 1 through 2 will be processed.\n      stats_summary_list = [\n          [\n              [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n              [[0., 0.], [.15, .036], [.06, .07], [.1, .2]],  # node 1\n              [[0., 0.], [-.33, .68], [0., 0.], [.3, .4]],  # node 2\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n          ],  # feature 0\n          [\n              [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n              [[0., 0.], [.3, .5], [-.05, .6], [.06, .07]],  # node 1\n              [[.1, .1], [.2, .03], [-.4, .05], [.07, .08]],  # node 2\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n          ],  # feature 1\n      ]  # feature_dim * shape=[max_splits, num_buckets, 2]\n\n      (node_ids_list, gains_list, thresholds_list, left_node_contribs_list,\n       right_node_contribs_list\n      ) = boosted_trees_ops.calculate_best_gains_per_feature(\n          node_id_range,\n          stats_summary_list,\n          l1=0.0,\n          l2=0.0,\n          tree_complexity=0.0,\n          min_node_weight=1,\n          max_splits=max_splits)\n\n      # We can't split node 1 on feature 1 and node 2 on feature 2 because of\n      # the min node weight.\n      self.assertAllEqual([[2], [1]], self.evaluate(node_ids_list))\n      self.assertAllClose([[0.384314], [0.098013]], self.evaluate(gains_list))\n      self.assertAllEqual([[1], [1]], self.evaluate(thresholds_list))\n      self.assertAllClose([[[0.4852941]], [[-.6]]],\n                          self.evaluate(left_node_contribs_list))\n      self.assertAllClose([[[-0.75]], [[-0.014925]]],\n                          self.evaluate(right_node_contribs_list))\n\n  def testCalculateMultiDimBestSplitsWithMinNodeWeight_v2_op(self):\n    \"\"\"Testing best split calculation with min node weight.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summary = np.asarray([\n        [\n            [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .61], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .68], [0., 0.], [.3, .4]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 0\n        [\n            [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .6], [.06, .07]],  # node 1\n            [[.1, 1.], [.2, -.05], [-.4, .05], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    # Reshape to [max_splits, feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summary, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=1,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    # Gain should also include an adjustment of the gradient by l1.\n    self.assertAllClose([0.098013, 0.931596], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[-.6], [-0.315789]], left_node_contribs)\n    self.assertAllClose([[-0.014925], [2.53846]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateMultiDimBestSplitsWithMissingValuesMinNodeWeight_v2_op(self):\n    \"\"\"Testing best split calculation with min node weight.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summary = np.asarray([\n        [\n            [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .61], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .68], [0., 0.], [.3, .4]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 0\n        [\n            [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .6], [.06, .07]],  # node 1\n            [[.1, 1.], [.2, -.05], [-.4, .05], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    # Reshape to [max_splits, feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summary, 0, 1)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=1,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    # Gain should also include an adjustment of the gradient by l1.\n    self.assertAllClose([0.149398, 3.332075], gains)\n    self.assertAllEqual([4, 4], feature_ids)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[-0.631579], [-0.359223]], left_node_contribs)\n    self.assertAllClose([[0.083333], [7.999989]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testSparseCalculateBestSplitsWithMinNodeWeight(self):\n    \"\"\"Testing best split calculation with min node weight.\"\"\"\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summary = np.asarray([\n        [\n            [[0., 0.], [.0, .0], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .61], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .68], [0., 0.], [.3, .4]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 0\n        [\n            [[0., 0.], [0., 0.], [.0, .0], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [-.05, .6], [.3, .5], [.06, .07]],  # node 1\n            [[.1, 1.], [.2, -.05], [-.4, .05], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    # reshape to [max_splits, feature_dim, num_buckets, 2]\n    stats_summary = np.moveaxis(stats_summary, 0, 1)\n\n    (summary_indices, summary_values,\n     summary_shape) = self._get_sparse_stats_summary_for_split(stats_summary)\n\n    (node_ids, gains, feature_dimensions, thresholds, left_node_contribs,\n     right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.sparse_calculate_best_feature_split(\n             node_id_range,\n             summary_indices,\n             summary_values,\n             summary_shape,\n             l1=0.,\n             l2=0.,\n             tree_complexity=0.,\n             min_node_weight=1,\n             logits_dimension=1))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.149398, 3.332079], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllClose([[0.083333], [-0.359223]], left_node_contribs)\n    self.assertAllClose([[-0.631579], [7.999998]], right_node_contribs)\n    self.assertAllEqual([1, 1], feature_dimensions)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_RIGHT, _INEQUALITY_DEFAULT_LEFT],\n                        split_types)\n\n  def testCalculateBestGainsWithMinNodeWeightNoSplitOnFeaturePossible_v1_op(\n      self):\n    \"\"\"Testing Gain calculation without any regularization.\"\"\"\n    with self.cached_session() as sess:\n      max_splits = 7\n      node_id_range = [1, 3]  # node 1 through 2 will be processed.\n      stats_summary_list = [\n          [\n              [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n              [[0., 0.], [.15, .0036], [.06, .007], [.1, .2]],  # node 1\n              [[0., 0.], [-.33, .068], [0., 0.], [.3, .04]],  # node 2\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n          ],  # feature 0\n          [\n              [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n              [[0., 0.], [.3, .5], [-.05, .6], [.06, .07]],  # node 1\n              [[.1, .1], [.2, .03], [-.4, .05], [.07, .08]],  # node 2\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n              [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n          ],  # feature 1\n      ]  # feature_dim * shape=[max_splits, num_buckets, 2]\n\n      (node_ids_list, _, _, _,\n       _) = boosted_trees_ops.calculate_best_gains_per_feature(\n           node_id_range,\n           stats_summary_list,\n           l1=0.0,\n           l2=0.0,\n           tree_complexity=0.0,\n           min_node_weight=1,\n           max_splits=max_splits)\n\n      # We can't split either of the nodes on the first feature\n      self.assertEqual(2, len(self.evaluate(node_ids_list)))\n      self.assertAllEqual([], self.evaluate(node_ids_list)[0])\n      self.assertAllEqual([1], self.evaluate(node_ids_list)[1])\n\n      # Now check when we can't split on any feature\n      (node_ids_list, _, _, _,\n       _) = boosted_trees_ops.calculate_best_gains_per_feature(\n           node_id_range,\n           stats_summary_list,\n           l1=0.0,\n           l2=0.0,\n           tree_complexity=0.0,\n           min_node_weight=10,\n           max_splits=max_splits)\n      self.assertAllEqual([[], []], self.evaluate(node_ids_list))\n\n  def testCalculateBestMultiDimFeatureSplitsWithNoSplitOnFeaturePossible_v2_op(\n      self):\n    \"\"\"Testing best split calculation with min node weight and no split.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summary = np.asarray([\n        [\n            [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .7], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .068], [0., 0.], [.3, .04]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 0\n        [\n            [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .06], [.06, .7]],  # node 1\n            [[.1, .1], [.2, -.05], [-.4, .05], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    # Reshape to [max_splits, feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summary, 0, 1)\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, _, _, _, _, _, _,\n     _) = boosted_trees_ops.calculate_best_feature_split_v2(\n         node_id_range, [stats_summary],\n         split_types=['inequality'],\n         candidate_feature_ids=candidate_feature_ids,\n         l1=0.0,\n         l2=0.0,\n         tree_complexity=0.0,\n         min_node_weight=1,\n         logits_dimension=1)\n\n    # We can't split either of the nodes on the first feature.\n    self.assertAllEqual([1], node_ids)\n\n    # Now check when we can't split on any feature.\n    (node_ids, _, _, _, _, _, _,\n     _) = boosted_trees_ops.calculate_best_feature_split_v2(\n         node_id_range, [stats_summary],\n         split_types=['inequality'],\n         candidate_feature_ids=candidate_feature_ids,\n         l1=0.0,\n         l2=0.0,\n         tree_complexity=0.0,\n         min_node_weight=10,\n         logits_dimension=1)\n    self.assertAllEqual([], node_ids)\n\n  def testCalculateBestMultiDimFeatureEqualitySplitsWithNoSplitPossible_v2_op(\n      self):\n    \"\"\"Testing best split calculation with min node weight and no split.\"\"\"\n    candidate_feature_ids = [4]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summary = np.asarray([\n        [\n            [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .7], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .068], [0., 0.], [.3, .04]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 0\n        [\n            [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .06], [.06, .7]],  # node 1\n            [[.1, .1], [.2, -.05], [-.4, .05], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # f_dim 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    # Reshape to [max_splits, feature_dim, num_buckets, 2].\n    stats_summary = np.moveaxis(stats_summary, 0, 1)\n\n    (node_ids, _, _, _, _, _, _,\n     _) = boosted_trees_ops.calculate_best_feature_split_v2(\n         node_id_range, [stats_summary],\n         split_types=['equality'],\n         candidate_feature_ids=candidate_feature_ids,\n         l1=0.0,\n         l2=0.0,\n         tree_complexity=0.0,\n         min_node_weight=1,\n         logits_dimension=1)\n\n    # We can't split either of the nodes on the first feature\n    self.assertAllEqual([1], node_ids)\n\n    # Now check when we can't split on any feature\n    (node_ids, _, _, _, _, _, _,\n     _) = boosted_trees_ops.calculate_best_feature_split_v2(\n         node_id_range, [stats_summary],\n         split_types=['equality'],\n         candidate_feature_ids=candidate_feature_ids,\n         l1=0.0,\n         l2=0.0,\n         tree_complexity=0.0,\n         min_node_weight=10,\n         logits_dimension=1)\n    self.assertAllEqual([], node_ids)\n\n  def testSparseCalculateBestSplitsWithMinNodeWeightNoSplitOnFeature(self):\n    \"\"\"Testing best split calculation with min node weight and no split.\"\"\"\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    stats_summary = np.asarray([\n        [\n            [[0., 0.], [.0, .0], [0., 0.], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.15, .36], [.06, .7], [.1, .2]],  # node 1\n            [[0., 0.], [-.33, .068], [0., 0.], [.3, .04]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 0\n        [\n            [[0., 0.], [0., 0.], [.0, .0], [0., 0.]],  # node 0; ignored\n            [[0., 0.], [.3, .5], [-.05, .6], [.06, .07]],  # node 1\n            [[.1, .1], [.2, .03], [-.4, .05], [.07, .08]],  # node 2\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 3; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 4; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 5; ignored\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.]],  # node 6; ignored\n        ],  # feature 1\n    ])  # feature_dim * shape=[max_splits, num_buckets, 2]\n    # reshape to [max_splits, feature_dim, num_buckets, 2]\n    stats_summary = np.moveaxis(stats_summary, 0, 1)\n    (summary_indices, summary_values,\n     summary_shape) = self._get_sparse_stats_summary_for_split(stats_summary)\n\n    (node_ids, _, _, _, _, _, _) = self.evaluate(\n        boosted_trees_ops.sparse_calculate_best_feature_split(\n            node_id_range,\n            summary_indices,\n            summary_values,\n            summary_shape,\n            l1=0.,\n            l2=0.,\n            tree_complexity=0.,\n            min_node_weight=1,\n            logits_dimension=1))\n\n    # We can't split either of the nodes on the first feature\n    self.assertAllEqual([1], node_ids)\n\n    # Now check when we can't split on any feature\n    (node_ids, _, _, _, _, _, _) = self.evaluate(\n        boosted_trees_ops.sparse_calculate_best_feature_split(\n            node_id_range,\n            summary_indices,\n            summary_values,\n            summary_shape,\n            l1=0.,\n            l2=0.,\n            tree_complexity=0.,\n            min_node_weight=10,\n            logits_dimension=1))\n    self.assertAllEqual([], node_ids)\n\n  @test_util.run_deprecated_v1\n  def testMakeStatsSummarySimple(self):\n    \"\"\"Simple test for MakeStatsSummary.\"\"\"\n    expected_stats_summary = np.asarray([1., 5., 2., 6., 3., 7., 4., 8.])\n    self.assertAllClose(\n        expected_stats_summary.reshape((1, 2, 2, 2)),\n        boosted_trees_ops.make_stats_summary(\n            node_ids=[0, 0, 1, 1],\n            gradients=[[1.], [2.], [3.], [4.]],\n            hessians=[[5.], [6.], [7.], [8.]],\n            bucketized_features_list=[[0, 1, 0, 1]],\n            max_splits=2,\n            num_buckets=2))\n\n  @test_util.run_deprecated_v1\n  def testAggregateStatsSimple(self):\n    # Get the same result as MakeStatsSummary Op.\n    expected_stats_summary = np.asarray(\n        [1., 5., 2., 6., 0., 0., 3., 7., 4., 8., 0., 0.])\n    # shape=[max_splits, num_buckets, feature_dim, stats_dim]\n    expected_stats_summary = np.reshape(expected_stats_summary, (2, 3, 1, 2))\n    # Reshape feature dim and bucket id axes\n    expected_stats_summary = np.swapaxes(expected_stats_summary, 1, 2)\n    self.assertAllClose(\n        expected_stats_summary,\n        boosted_trees_ops.boosted_trees_aggregate_stats(\n            node_ids=[0, 0, 1, 1],\n            gradients=[[1.], [2.], [3.], [4.]],\n            hessians=[[5.], [6.], [7.], [8.]],\n            feature=[[0], [1], [0], [1]],\n            max_splits=2,\n            num_buckets=2))\n\n  def testMakeStatsSummaryAccumulate(self):\n    \"\"\"Tests that Summary actually accumulates.\"\"\"\n    with self.cached_session():\n      max_splits = 3\n      num_buckets = 4\n      node_ids = [1, 1, 2, 2, 1, 1, 2, 0]\n      gradients = [[.1], [.2], [.3], [-.4], [-.05], [.06], [.07], [.08]]\n      hessians = [[.2], [.3], [.4], [.5], [.06], [.07], [.08], [.09]]\n\n      # Tests a single feature.\n      bucketized_features = [[3, 1, 2, 0, 1, 2, 0, 1]]\n      result = boosted_trees_ops.make_stats_summary(\n          node_ids, gradients, hessians, bucketized_features, max_splits,\n          num_buckets)  # shape=[max_splits, num_buckets, feature_dim, 2]\n      self.assertAllClose(\n          [[\n              [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0\n              [[0., 0.], [.15, .36], [.06, .07], [.1, .2]],  # node 1\n              [[-.33, .58], [0., 0.], [.3, .4], [0., 0.]],  # node 2\n          ]],\n          self.evaluate(result))\n\n  def testAggregateStatsAccumulate(self):\n    \"\"\"Tests that Summary actually accumulates.\"\"\"\n    max_splits = 3\n    num_buckets = 4\n    node_ids = [1, 1, 2, 2, 1, 1, 2, 0]\n    gradients = [[.1], [.2], [.3], [-.4], [-.05], [.06], [.07], [.08]]\n    hessians = [[.2], [.3], [.4], [.5], [.06], [.07], [.08], [.09]]\n\n    # Tests a single feature.\n    bucketized_features = [[3], [1], [2], [0], [1], [2], [0], [1]]\n    result = boosted_trees_ops.boosted_trees_aggregate_stats(\n        node_ids, gradients, hessians, bucketized_features, max_splits,\n        num_buckets)\n    # shape=[max_splits, num_buckets, feature_dim, stats_dim]\n    # Get the same result as MakeStatsSummary Op.\n    expected_stats_summary = [\n        [[[0., 0.]], [[.08, .09]], [[0., 0.]], [[0., 0.]], [[0., 0.]]],\n        [[[0., 0.]], [[.15, .36]], [[.06, .07]], [[.1, .2]], [[0., 0.]]],\n        [[[-.33, .58]], [[0., 0.]], [[.3, .4]], [[0., 0.]], [[0., 0.]]],\n    ]\n    # Swap feature dim and bucket id axis\n    expected_stats_summary = np.swapaxes(expected_stats_summary, 1, 2)\n    self.assertAllClose(expected_stats_summary, result)\n\n  def testAggregateStatsAccumulateWithMissingValue(self):\n    \"\"\"Tests that Summary actually accumulates.\"\"\"\n    max_splits = 3\n    num_buckets = 4\n    node_ids = [1, 1, 2, 2, 1, 1, 2, 0]\n    gradients = [[.1], [.2], [.3], [-.4], [-.05], [.06], [.07], [.08]]\n    hessians = [[.2], [.3], [.4], [.5], [.06], [.07], [.08], [.09]]\n\n    # Tests a single feature.\n    missing_feature = -1\n    bucketized_features = [[3], [1], [2], [0], [missing_feature], [2], [0], [1]]\n    result = boosted_trees_ops.boosted_trees_aggregate_stats(\n        node_ids, gradients, hessians, bucketized_features, max_splits,\n        num_buckets)\n    # shape=[max_splits, num_buckets, feature_dim, stats_dim]\n    # Get the same result as MakeStatsSummary Op.\n    expected_stats_summary = [\n        [[[0., 0.]], [[.08, .09]], [[0., 0.]], [[0., 0.]], [[0., 0.]]],\n        [[[0., 0.]], [[.2, .3]], [[.06, .07]], [[.1, .2]], [[-.05, .06]]],\n        [[[-.33, .58]], [[0., 0.]], [[.3, .4]], [[0., 0.]], [[0., 0.]]],\n    ]\n    # Swap feature dim and bucket id axis\n    expected_stats_summary = np.swapaxes(expected_stats_summary, 1, 2)\n    self.assertAllClose(expected_stats_summary, result)\n\n  def testMakeStatsSummaryMultipleFeatures(self):\n    \"\"\"Tests that MakeStatsSummary works for multiple features.\"\"\"\n    with self.cached_session():\n      max_splits = 3\n      num_buckets = 4\n      node_ids = [1, 1, 2, 2, 1, 1, 2, 0]\n      gradients = [[.1], [.2], [.3], [-.4], [-.05], [.06], [.07], [.08]]\n      hessians = [[.2], [.3], [.4], [.5], [.06], [.07], [.08], [.09]]\n\n      # Tests multiple features.\n      # The output from another feature will stored be in 3rd dimension.\n      bucketized_features = [[3, 1, 2, 0, 1, 2, 0, 1], [0, 0, 0, 2, 2, 3, 3, 2]]\n      result = boosted_trees_ops.make_stats_summary(\n          node_ids, gradients, hessians, bucketized_features, max_splits,\n          num_buckets)  # shape=[max_splits, num_buckets, feature_dim, 2]\n      self.assertAllClose(\n          [\n              [\n                  [[0., 0.], [.08, .09], [0., 0.], [0., 0.]],  # node 0\n                  [[0., 0.], [.15, .36], [.06, .07], [.1, .2]],  # node 1\n                  [[-.33, .58], [0., 0.], [.3, .4], [0., 0.]],  # node 2\n              ],  # feature 0\n              [\n                  [[0., 0.], [0., 0.], [.08, .09], [0., 0.]],  # node 0\n                  [[.3, .5], [0., 0.], [-.05, .06], [.06, .07]],  # node 1\n                  [[.3, .4], [0., 0.], [-.4, .5], [.07, .08]],  # node 2\n              ],  # feature 1\n          ],\n          self.evaluate(result))\n\n  def testAggregatesSummaryMultipleDimensionFeature(self):\n    \"\"\"Tests that MakeStatsSummary works for multiple features.\"\"\"\n    expected_stats_summary = np.asarray(\n        [[0, 0, 0, 0, .08, .09, 0, 0, 0, 0, .08, .09, 0, 0, 0, 0, 0, 0, 0, 0],\n         [\n             0, 0, .3, .5, .15, .36, 0, 0, .06, .07, -.05, .06, .1, .2, .06,\n             .07, 0, 0, 0, 0\n         ],\n         [\n             -.33, .58, .3, .4, 0, 0, 0, 0, .3, .4, -.4, .5, 0, 0, .07, .08, 0,\n             0, 0, 0\n         ]])\n    with self.cached_session():\n      max_splits = 3\n      num_buckets = 4\n      node_ids = [1, 1, 2, 2, 1, 1, 2, 0]\n      gradients = [[.1], [.2], [.3], [-.4], [-.05], [.06], [.07], [.08]]\n      hessians = [[.2], [.3], [.4], [.5], [.06], [.07], [.08], [.09]]\n\n      # Tests multiple features.\n      bucketized_features = [[3, 0], [1, 0], [2, 0], [0, 2], [1, 2], [2, 3],\n                             [0, 3], [1, 2]]\n      result = boosted_trees_ops.boosted_trees_aggregate_stats(\n          node_ids, gradients, hessians, bucketized_features, max_splits,\n          num_buckets)\n      # Reshape to [max_splits, num_buckets, feature_dim, stats_dim]\n      expected_stats_summary = np.reshape(expected_stats_summary, (3, 5, 2, 2))\n      # Swap feature_dim and bucket_id axis\n      expected_stats_summary = np.swapaxes(expected_stats_summary, 1, 2)\n      self.assertAllClose(expected_stats_summary, result)\n\n  def testAggregateStatsMultiClass(self):\n    \"\"\"Tests that Summary actually accumulates.\"\"\"\n    with self.cached_session():\n      max_splits = 3\n      num_buckets = 4\n      node_ids = [1, 1, 2, 2, 1, 1, 2, 0]\n      gradients = [[.1, .2], [.2, .4], [.3, .6], [-.4, -.8], [-.05, -.1],\n                   [.06, .12], [.07, .14], [.08, .16]]\n      hessians = [[.2, .6], [.3, .9], [.4, 1.2], [.5, 1.5], [.06, .18],\n                  [.07, .21], [.08, .24], [.09, .27]]\n\n      # Tests a single feature.\n      bucketized_features = [[3], [1], [2], [0], [1], [2], [0], [1]]\n      result = boosted_trees_ops.boosted_trees_aggregate_stats(\n          node_ids, gradients, hessians, bucketized_features, max_splits,\n          num_buckets)\n      # shape=[max_splits, num_buckets, feature_dim, stats_dim]\n      expected_stats_summary = [\n          [[[0., 0., 0., 0.]], [[.08, .16, .09, .27]], [[0., 0., 0., 0.]],\n           [[0., 0., 0., 0.]], [[0., 0., 0., 0.]]],\n          [[[0., 0., 0., 0.]], [[.15, 0.3, .36, 1.08]], [[.06, 0.12, .07,\n                                                          0.21]],\n           [[.1, .2, .2, .6]], [[0., 0., 0., 0.]]],\n          [[[-.33, -.66, .58, 1.74]], [[0., 0., 0., 0.]], [[.3, .6, .4, 1.2]],\n           [[0., 0., 0., 0.]], [[0., 0., 0., 0.]]],\n      ]\n      expected_stats_summary = np.swapaxes(expected_stats_summary, 1, 2)\n      self.assertAllClose(expected_stats_summary, result)\n\n  def _get_dense_summaries_from_sparse_features(self, max_splits, num_buckets,\n                                                batch_size, feature_dims,\n                                                logits_dims, hess_dims):\n    np.random.seed(0)\n    stats_dims = logits_dims + hess_dims\n    node_ids = np.random.randint(max_splits, size=batch_size)\n    gradients = np.random.uniform(5.0, size=(batch_size, logits_dims))\n    hessians = np.random.uniform(5.0, size=(batch_size, hess_dims))\n    dense_indices = np.random.randint(2, size=(batch_size, feature_dims))\n    feature_indices = np.argwhere(dense_indices == 1)\n    missing_feature_indices = np.argwhere(dense_indices == 0)\n    feature_values = np.random.randint(num_buckets, size=len(feature_indices))\n    feature_shape = np.asarray([batch_size, feature_dims])\n    # Last bucket is for missing values.\n    dense_summary = np.zeros(\n        (max_splits, feature_dims, num_buckets + 1, stats_dims))\n    for (instance, f_dim), bucket in zip(feature_indices, feature_values):\n      node_id = node_ids[instance]\n      dense_summary[node_id][f_dim][bucket] += np.concatenate(\n          [gradients[instance], hessians[instance]])\n\n    for instance, f_dim in missing_feature_indices:\n      node_id = node_ids[instance]\n      dense_summary[node_id][f_dim][num_buckets] += np.concatenate(\n          [gradients[instance], hessians[instance]])\n\n    return (node_ids, gradients, hessians, feature_indices, feature_values,\n            feature_shape, dense_summary)\n\n  def testMakeSparseStatsSummarySingleFeatureDimension(self):\n    batch_size = 10\n    max_splits = 2\n    num_buckets = 2\n    feature_dims = 1\n    logits_dims = 1\n    hess_dims = 1\n\n    (node_ids, gradients, hessians, feature_indices, feature_values,\n     feature_shape,\n     expected_dense_summary) = self._get_dense_summaries_from_sparse_features(\n         max_splits, num_buckets, batch_size, feature_dims, logits_dims,\n         hess_dims)\n\n    (summary_indices, summary_values,\n     summary_shape) = boosted_trees_ops.boosted_trees_sparse_aggregate_stats(\n         node_ids, gradients, hessians, feature_indices, feature_values,\n         feature_shape, max_splits, num_buckets)\n    dense_result = sparse_ops.sparse_to_dense(summary_indices, summary_shape,\n                                              summary_values)\n    self.assertAllClose(expected_dense_summary, dense_result)\n\n  def testMakeSparseStatsSummaryMultiDimFeature(self):\n    batch_size = 10\n    max_splits = 2\n    num_buckets = 2\n    feature_dims = 1\n    logits_dims = 1\n    hess_dims = 1\n\n    (node_ids, gradients, hessians, feature_indices, feature_values,\n     feature_shape,\n     expected_dense_summary) = self._get_dense_summaries_from_sparse_features(\n         max_splits, num_buckets, batch_size, feature_dims, logits_dims,\n         hess_dims)\n\n    (summary_indices, summary_values,\n     summary_shape) = boosted_trees_ops.boosted_trees_sparse_aggregate_stats(\n         node_ids, gradients, hessians, feature_indices, feature_values,\n         feature_shape, max_splits, num_buckets)\n    dense_result = sparse_ops.sparse_to_dense(summary_indices, summary_shape,\n                                              summary_values)\n    self.assertAllClose(expected_dense_summary, dense_result)\n\n  def testMakeSparseStatsSummaryMultiClass(self):\n    batch_size = 10\n    max_splits = 2\n    num_buckets = 2\n    feature_dims = 1\n    logits_dims = 2\n    hess_dims = 2\n\n    (node_ids, gradients, hessians, feature_indices, feature_values,\n     feature_shape,\n     expected_dense_summary) = self._get_dense_summaries_from_sparse_features(\n         max_splits, num_buckets, batch_size, feature_dims, logits_dims,\n         hess_dims)\n\n    (summary_indices, summary_values,\n     summary_shape) = boosted_trees_ops.boosted_trees_sparse_aggregate_stats(\n         node_ids, gradients, hessians, feature_indices, feature_values,\n         feature_shape, max_splits, num_buckets)\n    dense_result = sparse_ops.sparse_to_dense(summary_indices, summary_shape,\n                                              summary_values)\n    self.assertAllClose(expected_dense_summary, dense_result)\n\n  def testMakeSparseStatsSummaryMultiClassAndMultiFeatureDim(self):\n    batch_size = 10\n    max_splits = 2\n    num_buckets = 2\n    feature_dim = 2\n    logits_dims = 2\n    hess_dims = 2\n\n    (node_ids, gradients, hessians, feature_indices, feature_values,\n     feature_shape,\n     expected_dense_summary) = self._get_dense_summaries_from_sparse_features(\n         max_splits, num_buckets, batch_size, feature_dim, logits_dims,\n         hess_dims)\n\n    (summary_indices, summary_values,\n     summary_shape) = boosted_trees_ops.boosted_trees_sparse_aggregate_stats(\n         node_ids, gradients, hessians, feature_indices, feature_values,\n         feature_shape, max_splits, num_buckets)\n    dense_result = sparse_ops.sparse_to_dense(summary_indices, summary_shape,\n                                              summary_values)\n    self.assertAllClose(expected_dense_summary, dense_result)\n\n  def _verify_precision(self, length):\n    with self.cached_session():\n      max_splits = 1\n      num_buckets = 1\n      node_ids = array_ops.fill([length], 0)\n\n      gradients = constant_op.constant(\n          2.0 / length, dtype=dtypes.float32, shape=[length, 1])\n      hessians = constant_op.constant(\n          0.2 / length, dtype=dtypes.float32, shape=[length, 1])\n\n      bucketized_features = array_ops.zeros([length], dtype=dtypes.int32)\n\n      result = boosted_trees_ops.make_stats_summary(\n          node_ids, gradients, hessians, [bucketized_features], max_splits,\n          num_buckets)  # shape=[max_splits, num_buckets, feature_dim, 2]\n\n      self.assertAllClose([[[[2., 0.2]]]], self.evaluate(result))\n\n  def testMakeStatsSummaryNumericalPrecisionSmallBatch(self):\n    \"\"\"Tests numeric precision.\"\"\"\n    self._verify_precision(length=2000)\n\n  def testMakeStatsSummaryNumericalPrecisionMediumBatch(self):\n    \"\"\"Tests numeric precision.\"\"\"\n    self._verify_precision(length=100000)\n\n  def testMakeStatsSummaryNumericalPrecisionLargeBatch(self):\n    \"\"\"Tests numeric precision.\"\"\"\n    self._verify_precision(length=1000000)\n\n  def testMakeStatsSummaryNumericalPrecisionMegaBatch(self):\n    \"\"\"Tests numeric precision.\"\"\"\n    self._verify_precision(length=50000000)\n\n  def testBoostedTreesCalculateBestGainsPerFeatureSecurity(self):\n    node_id_range = [1, 2]\n    stats_summary_list = [[[[]]]]\n    l1 = [1.0]\n    l2 = [1.0]\n    tree_complexity = [1.0]\n    min_node_weight = [1.17]\n    max_splits = 1\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      gen_boosted_trees_ops.boosted_trees_calculate_best_gains_per_feature(\n          node_id_range=node_id_range,\n          stats_summary_list=stats_summary_list,\n          l1=l1,\n          l2=l2,\n          tree_complexity=tree_complexity,\n          min_node_weight=min_node_weight,\n          max_splits=max_splits)\n\n  def testBoostedTreesCalculateBestFeatureSplitSecurity(self):\n    node_id_range = [1, 2]\n    stats_summary = [[[[]]]]\n    split_type = 'equality'\n    l1 = [1.0]\n    l2 = [1.0]\n    tree_complexity = [1.0]\n    min_node_weight = [1.17]\n    logits_dimension = 5\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      gen_boosted_trees_ops.boosted_trees_calculate_best_feature_split(\n          node_id_range=node_id_range,\n          stats_summary=stats_summary,\n          l1=l1,\n          l2=l2,\n          tree_complexity=tree_complexity,\n          min_node_weight=min_node_weight,\n          logits_dimension=logits_dimension,\n          split_type=split_type)\n\n  def testBoostedTreesCalculateBestFeatureSplitSecurity2(self):\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      gen_boosted_trees_ops.boosted_trees_calculate_best_feature_split(\n          node_id_range=[0, 8],\n          stats_summary=[[[[1.0], [2.0], [3.0]]]],\n          l1=[0.5],\n          l2=[0.5],\n          tree_complexity=[0.1],\n          min_node_weight=[1.0],\n          logits_dimension=8)\n\n  def testBoostedTreesCalculateBestFeatureSplitV2Security(self):\n    node_id_range = [1, 2]\n    stats_summaries_list = [[[[[]]]]]\n    split_types = ['inequality']\n    candidate_feature_ids = [1, 2, 3, 4]\n    l1 = [1.0]\n    l2 = [1.0]\n    tree_complexity = [1.0]\n    min_node_weight = [1.17]\n    logits_dimension = 5\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      gen_boosted_trees_ops.boosted_trees_calculate_best_feature_split_v2(\n          node_id_range=node_id_range,\n          stats_summaries_list=stats_summaries_list,\n          split_types=split_types,\n          candidate_feature_ids=candidate_feature_ids,\n          l1=l1,\n          l2=l2,\n          tree_complexity=tree_complexity,\n          min_node_weight=min_node_weight,\n          logits_dimension=logits_dimension)\n\n  def testBoostedTreesSparseCalculateBestFeatureSplitSecurity(self):\n    node_id_range = []\n    stats_summary_indices = [[]]\n    stats_summary_values = [1.0]\n    stats_summary_shape = [1, 1, 1, 1]\n    l1 = [1.0]\n    l2 = [1.0]\n    tree_complexity = [0.5]\n    min_node_weight = [1.0]\n    logits_dimension = 3\n    split_type = 'inequality'\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      gen_boosted_trees_ops.boosted_trees_sparse_calculate_best_feature_split(\n          node_id_range=node_id_range,\n          stats_summary_indices=stats_summary_indices,\n          stats_summary_values=stats_summary_values,\n          stats_summary_shape=stats_summary_shape,\n          l1=l1,\n          l2=l2,\n          tree_complexity=tree_complexity,\n          min_node_weight=min_node_weight,\n          logits_dimension=logits_dimension,\n          split_type=split_type)\n\n  def testBoostedTreesSparseCalculateBestFeatureSplitSecurity2(self):\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      gen_boosted_trees_ops.boosted_trees_sparse_calculate_best_feature_split(\n          node_id_range=[0, 1],\n          stats_summary_indices=[[0, -1, -1, -1], [1, 0, -1, 0], [1, 0, 0, -1]],\n          stats_summary_values=[0.1, 0.2, 0.3],\n          stats_summary_shape=[1, 1, 1, 1],\n          l1=[0.5],\n          l2=[0.5],\n          tree_complexity=[0.1],\n          min_node_weight=[1.0],\n          logits_dimension=1)\n\n  def testBoostedTreesMakeStatsSummarySecurity(self):\n    node_ids = [1, 2]\n    gradients = [[]]\n    hessians = [[0.2], [0.1]]\n    bucketized_features_list = [[1], [2]]\n    max_splits = 3\n    num_buckets = 3\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      gen_boosted_trees_ops.boosted_trees_make_stats_summary(\n          node_ids=node_ids,\n          gradients=gradients,\n          hessians=hessians,\n          bucketized_features_list=bucketized_features_list,\n          max_splits=max_splits,\n          num_buckets=num_buckets)\n\n  def testBoostedTreesMakeStatsSummarySecurity2(self):\n    node_ids = [1, 2, 3]\n    gradients = [[0.1], [0.2]]\n    hessians = [[0.2], [0.1]]\n    bucketized_features_list = [[1], [2]]\n    max_splits = 3\n    num_buckets = 3\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      gen_boosted_trees_ops.boosted_trees_make_stats_summary(\n          node_ids=node_ids,\n          gradients=gradients,\n          hessians=hessians,\n          bucketized_features_list=bucketized_features_list,\n          max_splits=max_splits,\n          num_buckets=num_buckets)\n\n  def testBoostedTreesAggregateStatsSecurity(self):\n    node_ids = [1, 2]\n    gradients = [[]]\n    hessians = [[100.0]]\n    feature = [[0, 0, 0]]\n    max_splits = 100\n    num_buckets = 100\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      gen_boosted_trees_ops.boosted_trees_aggregate_stats(\n          node_ids=node_ids,\n          gradients=gradients,\n          hessians=hessians,\n          feature=feature,\n          max_splits=max_splits,\n          num_buckets=num_buckets)\n\n  def testBoostedTreesAggregateStatsSecurity2(self):\n    node_ids = [-10]\n    gradients = [[0.0, 0.0]]\n    hessians = [[100.0]]\n    feature = [[0, 0, 0]]\n    max_splits = 100\n    num_buckets = 100\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      self.evaluate(\n          gen_boosted_trees_ops.boosted_trees_aggregate_stats(\n              node_ids=node_ids,\n              gradients=gradients,\n              hessians=hessians,\n              feature=feature,\n              max_splits=max_splits,\n              num_buckets=num_buckets))\n\n  def testBoostedTreesSparseAggregateStatsSecurity(self):\n    node_ids = []\n    gradients = [[1.0]]\n    hessians = [[100.0]]\n    feature_indices = [[0, 0, 0]]\n    feature_values = [0, 0, 0]\n    feature_shape = [0, 0, 0]\n    max_splits = 100\n    num_buckets = 100\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      gen_boosted_trees_ops.boosted_trees_sparse_aggregate_stats(\n          node_ids=node_ids,\n          gradients=gradients,\n          hessians=hessians,\n          feature_indices=feature_indices,\n          feature_values=feature_values,\n          feature_shape=feature_shape,\n          max_splits=max_splits,\n          num_buckets=num_buckets)\n\n\nclass BestMultiDimFeatureSplitMultiClassV2Op(StatsOpsTest):\n  \"\"\"Tests multi-class/multi-regression for best splits using V2 op.\"\"\"\n\n  logits_dim = 2\n\n  def _get_stats_summary_for_split_diagonal_hessian(self):\n    summary = [\n        [[[0., 0., 0., 0.], [0.08, 0.2, 0.09, 0.3], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]],\n         [[0., 0., 0., 0.], [0., 0., 0., 0.], [0.08, 0.2, 0.09, 0.3],\n          [0., 0., 0., 0.]]],  # node 0\n        [[[0., 0., 0., 0.], [-0.25, -0.1, 0.36, 0.2], [-0.14, 0.25, 0.07, 0.18],\n          [0.1, 0.235, 0.2, 0.06]],\n         [[0., 0., 0., 0.], [-0.3, 0.12, 0.5, 0.31], [-0.05, 0.115, 0.11, 0.09],\n          [0.06, 0.15, 0.02, 0.04]]],  # node 1\n        [[[0., 0., 0., 0.], [-0.03, 0.21, 0.28, 0.44], [0., 0., 0., 0.],\n          [0.3, 0.04, 0.4, 0.41]],\n         [[0.4, 0.188, 0.16, -0.03], [0.2, -0.088, 0.1, -0.24],\n          [-0.4, -0.06, 0.5, 0.15], [0.07, 0.21, -0.08, 0.97]]],  # node 2\n        [[[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]],\n         [[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]]],  # node 3\n        [[[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]],\n         [[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]]],  # node 4\n        [[[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]],\n         [[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]]],  # node 5\n        [[[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]],\n         [[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.],\n          [0., 0., 0., 0.]]]  # node 6\n    ]\n    # [max_splits, feature_dim, num_buckets, 4]\n    return np.array(summary)\n\n  def _add_feature_dim(self, stats_summary):\n    \"\"\"Add dimension for features; number of features will be 1.\"\"\"\n    return np.expand_dims(stats_summary, axis=1)\n\n  def testSumOfStatsSummaryValuesFromHelperFunction(self):\n    \"\"\"Sum of grads and hessians is correct from helper function.\"\"\"\n    # [max_splits, feature_dim, num_buckets, 4]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n    # Test that sum of grads/hessians are same for both features for all nodes.\n    # [max_splits, feature_dim, 4]\n    agg = stats_summary.sum(axis=2)  # Sum along buckets.\n    self.assertAllClose(agg[:, 0, :], agg[:, 1, :])  # There are two features.\n    # Test sum of hessians for each nodes. These values are used to evaluate if\n    # node meets min_node_weight criteria.\n    nodes_agg = agg[:, 0, :]\n    hessians = nodes_agg[:, self.logits_dim:]\n\n    def frobenius(x, **kwargs):\n      return np.sqrt(np.square(x).sum(**kwargs))\n\n    self.assertAllClose([0.3132092, 0.76843998, 1.08853112, 0., 0., 0., 0.],\n                        frobenius(hessians, axis=1))\n\n  def testCalculateBestFeatureSplitsSingleClassVsMultiClass(self):\n    \"\"\"Testing same results using same grads/hess with both single and multi.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n\n    # Build same stats summary in single class and multi-class form (using\n    # diagonal hessian).\n    empty = [0] * 2\n    stats_summary = [\n        [empty, [.08, .09], empty],  # node 0; ignored\n        [empty, [-0.25, 0.11], [0.1, 0.5]],  # node 1\n        [empty, [0.14, 0.1], empty],  # node 2\n        [empty, empty, empty],  # node 3; ignored\n    ]\n    # [max_splits, feature_dim, num_buckets, 2]\n    stats_summary = self._add_feature_dim(stats_summary)\n    diag_empty = [0] * 4\n    diag_stats_summary = [\n        [diag_empty, [0, .08, 0, 0.09], diag_empty],  # node 0; ignored\n        [diag_empty, [0, -0.25, 0, 0.11], [0, 0.1, 0, 0.5]],  # node 1\n        [diag_empty, [0, 0.14, 0, 0.1], diag_empty],  # node 2\n        [diag_empty, diag_empty, diag_empty],  # node 3; ignored\n    ]\n    # [max_splits, feature_dim, num_buckets, 4]\n    diag_stats_summary = self._add_feature_dim(diag_stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=1))\n\n    (diag_node_ids, diag_gains, diag_feature_ids, diag_feature_dimensions,\n     diag_thresholds, diag_left_node_contribs, diag_right_node_contribs,\n     diag_split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [diag_stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=2))\n\n    self.assertAllEqual(node_ids, diag_node_ids)\n    self.assertAllClose(gains, diag_gains)\n    self.assertAllEqual(feature_ids, diag_feature_ids)\n    self.assertAllEqual(feature_dimensions, diag_feature_dimensions)\n    self.assertAllEqual(thresholds, diag_thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    zeros = np.zeros_like(left_node_contribs)\n    self.assertAllClose(\n        np.concatenate([zeros, left_node_contribs], axis=1),\n        diag_left_node_contribs)\n    self.assertAllClose(\n        np.concatenate([zeros, right_node_contribs], axis=1),\n        diag_right_node_contribs)\n    self.assertAllEqual(split_types, diag_split_types)\n\n  def testCalculateBestFeatureSplitsDiagonalVsFull(self):\n    \"\"\"Test results are same using diagonal hessian and full hessian.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n\n    # Build same stats summary in diagonal and full hessian form, respectively.\n    diag_empty = [0] * 4\n    diag_stats_summary = [\n        [diag_empty, [.08, .09, -.1, .2], diag_empty],  # node 0; ignored\n        [diag_empty, [.15, .36, .21, -.11], [.06, .07, .67, 0.5]],  # node 1\n        [diag_empty, [-.33, .58, -.2, -.31], diag_empty],  # node 2\n        [diag_empty, diag_empty, diag_empty],  # node 3; ignored\n    ]\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    diag_stats_summary = self._add_feature_dim(diag_stats_summary)\n    full_empty = [0] * 6\n    full_stats_summary = [\n        [full_empty, [.08, .09, -.1, 0, 0, .2], full_empty],  # node 0; ignored\n        [full_empty, [.15, .36, .21, 0, 0, -.11], [.06, .07, .67, 0, 0,\n                                                   0.5]],  # node 1\n        [full_empty, [-.33, .58, -.2, 0, 0, -.31], full_empty],  # node 2\n        [full_empty, full_empty, full_empty],  # node 3; ignored\n    ]\n    # [max_splits, feature_dim, num_buckets, logits_dim + logits_dim**2]\n    full_stats_summary = self._add_feature_dim(full_stats_summary)\n    (diag_node_ids, diag_gains, diag_feature_ids, diag_feature_dimensions,\n     diag_thresholds, diag_left_node_contribs, diag_right_node_contribs,\n     diag_split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [diag_stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    (full_node_ids, full_gains, full_feature_ids, full_feature_dimensions,\n     full_thresholds, full_left_node_contribs, full_right_node_contribs,\n     full_split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [full_stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    self.assertAllEqual(diag_node_ids, full_node_ids)\n    self.assertAllClose(diag_gains, full_gains)\n    self.assertAllEqual(diag_feature_ids, full_feature_ids)\n    self.assertAllEqual(diag_feature_dimensions, full_feature_dimensions)\n    self.assertAllEqual(diag_thresholds, full_thresholds)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose(diag_left_node_contribs, full_left_node_contribs)\n    self.assertAllClose(diag_right_node_contribs, full_right_node_contribs)\n    self.assertAllEqual(diag_split_types, full_split_types)\n\n  def testCalculateBestFeatureSplitsWithoutRegularization(self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.912981, 1.446218], gains)\n    self.assertAllEqual([2, 1], thresholds)\n    self.assertAllEqual([14, 14], feature_ids)\n    self.assertAllEqual([0, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[0.906977, -0.394737], [-2.307692, 0.370370]],\n                        left_node_contribs)\n    self.assertAllClose([[-0.5, -3.916667], [0.785714, -0.133928]],\n                        right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestFeatureSplitsWMissingValuesWoRegularization(self):\n    \"\"\"Testing best split calculation without any regularization.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.912981, 2.79444], gains)\n    self.assertAllEqual([0, 1], thresholds)\n    self.assertAllEqual([14, 14], feature_ids)\n    self.assertAllEqual([0, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.5, -3.916667], [-3.722223, -0.442857]],\n                        left_node_contribs)\n    self.assertAllClose([[0.906977, -0.394737], [0.8, 0.4]],\n                        right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestFeatureSplitsWithL2(self):\n    \"\"\"Testing best split calculation inith L2 regularization.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n    stats_summary = self._append_zeros_for_default_bucket(stats_summary)\n\n    l2 = 0.1\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=l2,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.475669, 1.009791], gains)\n    self.assertAllEqual([1, 1], thresholds)\n    self.assertAllEqual([14, 14], feature_ids)\n    self.assertAllEqual([0, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[0.543478, 0.333333], [-1.666667, 0.588235]],\n                        left_node_contribs)\n    self.assertAllClose([[0.108108, -1.426471], [0.634615, -0.122951]],\n                        right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestFeatureSplitsWithMissingValuesL2(self):\n    \"\"\"Testing best split calculation inith L2 regularization.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n\n    l2 = 0.1\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=l2,\n             tree_complexity=0.0,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.475669, 3.467833], gains)\n    self.assertAllEqual([1, 0], thresholds)\n    self.assertAllEqual([14, 14], feature_ids)\n    self.assertAllEqual([0, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[0.543478, 0.333333], [-2.611111, -0.382692]],\n                        left_node_contribs)\n    self.assertAllClose([[0.108108, -1.426471], [0.285714, 14.800049]],\n                        right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_RIGHT, _INEQUALITY_DEFAULT_LEFT],\n                        split_types)\n\n  def testCalculateBestFeatureSplitsWithMinNodeWeight(self):\n    \"\"\"Testing best split calculation with min_node_weight.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=0.5,\n             logits_dimension=self.logits_dim))\n\n    # Both nodes have large enough sum(hessians) so use them.\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllClose([0.912981, 2.79444], gains)\n    self.assertAllEqual([0, 1], thresholds)\n    self.assertAllEqual([14, 14], feature_ids)\n    self.assertAllEqual([0, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-0.5, -3.916667], [-3.722223, -0.442857]],\n                        left_node_contribs)\n    self.assertAllClose([[0.906977, -0.394737], [0.8, 0.4]],\n                        right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT] * 2, split_types)\n\n  def testCalculateBestFeatureSplitsWithTreeComplexity(self):\n    \"\"\"Testing best split calculation with tree complexity.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n\n    l2 = 0.1\n    tree_complexity = 3.\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=l2,\n             tree_complexity=tree_complexity,\n             min_node_weight=0,\n             logits_dimension=self.logits_dim))\n\n    self.assertAllEqual([1, 2], node_ids)\n    self.assertAllEqual([1, 2], node_ids)\n    # L2 test result, but subtracted by tree_complexity.\n    self.assertAllClose([-2.524331, 0.467833], gains)\n    self.assertAllEqual([1, 0], thresholds)\n    self.assertAllEqual([14, 14], feature_ids)\n    self.assertAllEqual([0, 1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[0.543478, 0.333333], [-2.611111, -0.382692]],\n                        left_node_contribs)\n    self.assertAllClose([[0.108108, -1.426471], [0.285714, 14.800049]],\n                        right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_RIGHT, _INEQUALITY_DEFAULT_LEFT],\n                        split_types)\n\n  def testCalculateBestFeatureSplitsWithMinNodeNoSplitOnFeaturePossible(self):\n    \"\"\"Test when parent node hessian doesn't meet min node weight.\"\"\"\n    candidate_feature_ids = [14]\n    node_id_range = [1, 3]  # node 1 through 2 will be processed.\n    # [max_splits, feature_dim, num_buckets, 2*logits_dim]\n    stats_summary = self._get_stats_summary_for_split_diagonal_hessian()\n\n    min_node_weight = 0.8\n    (node_ids, gains, feature_ids, feature_dimensions, thresholds,\n     left_node_contribs, right_node_contribs, split_types) = self.evaluate(\n         boosted_trees_ops.calculate_best_feature_split_v2(\n             node_id_range, [stats_summary],\n             split_types=['inequality'],\n             candidate_feature_ids=candidate_feature_ids,\n             l1=0.0,\n             l2=0.0,\n             tree_complexity=0.0,\n             min_node_weight=min_node_weight,\n             logits_dimension=self.logits_dim))\n\n    # node_1 doesn't have large enough sum(hessians) so don't return it.\n    self.assertAllEqual([2], node_ids)\n    self.assertAllClose([2.79444], gains)\n    self.assertAllEqual([1], thresholds)\n    self.assertAllEqual([14], feature_ids)\n    self.assertAllEqual([1], feature_dimensions)\n    # The left node contrib will be later added to the previous node value to\n    # make the left node value, and the same for right node contrib.\n    self.assertAllClose([[-3.722223, -0.442857]], left_node_contribs)\n    self.assertAllClose([[0.8, 0.4]], right_node_contribs)\n    self.assertAllEqual([_INEQUALITY_DEFAULT_LEFT], split_types)\n\n\nif __name__ == '__main__':\n  googletest.main()\n"], "filenames": ["tensorflow/core/kernels/boosted_trees/stats_ops.cc", "tensorflow/python/kernel_tests/boosted_trees/stats_ops_test.py"], "buggy_code_start_loc": [75, 19], "buggy_code_end_loc": [1616, 1666], "fixing_code_start_loc": [75, 20], "fixing_code_end_loc": [1659, 1862], "type": "CWE-476", "message": "TensorFlow is an open source platform for machine learning. In affected versions the code for boosted trees in TensorFlow is still missing validation. As a result, attackers can trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures) as well as abuse undefined behavior (binding references to `nullptr`s). An attacker can also read and write from heap buffers, depending on the API that gets used and the arguments that are passed to the call. Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs. We will deprecate TensorFlow's boosted trees APIs in subsequent releases. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-41208", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-05T22:15:08.533", "lastModified": "2021-11-09T18:36:01.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. In affected versions the code for boosted trees in TensorFlow is still missing validation. As a result, attackers can trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures) as well as abuse undefined behavior (binding references to `nullptr`s). An attacker can also read and write from heap buffers, depending on the API that gets used and the arguments that are passed to the call. Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs. We will deprecate TensorFlow's boosted trees APIs in subsequent releases. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. En las versiones afectadas, el c\u00f3digo de los \u00e1rboles potenciados en TensorFlow sigue sin ser comprendido por la comprobaci\u00f3n. Como resultado, los atacantes pueden desencadenar una denegaci\u00f3n de servicio (por medio de la desreferenciaci\u00f3n de \"nullptr\"s o a trav\u00e9s de fallos de \"CHECK\") as\u00ed como abusar de un comportamiento indefinido (vinculando referencias a \"nullptr\"s). Un atacante tambi\u00e9n puede leer y escribir desde los buffers de la pila, dependiendo de la API que es usada y los argumentos que son pasados a la llamada. Dado que la implementaci\u00f3n de boosted trees en TensorFlow no es mantenida, es recomendado no seguir usando estas APIs. Dejaremos de usar las APIs de \u00e1rboles potenciados de TensorFlow en versiones posteriores. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.7.0. Tambi\u00e9n ser\u00e1 incluida este commit en TensorFlow versi\u00f3n 2.6.1, TensorFlow versi\u00f3n 2.5.2, y TensorFlow versi\u00f3n 2.4.4, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}, {"lang": "en", "value": "CWE-824"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.4", "matchCriteriaId": "0E596567-6F67-4880-8EC4-CB262BF02E0D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.5.0", "versionEndExcluding": "2.5.2", "matchCriteriaId": "035CDF63-1548-4FB4-B8A9-B8D328FAF910"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.0", "versionEndExcluding": "2.6.1", "matchCriteriaId": "5D68D8D1-DB27-4395-9D3D-2BED901B852C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "A58EDA5C-66D6-46F1-962E-60AFB7C784A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "89522760-C2DF-400D-9624-626D8F160CBA"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/5c8c9a8bfe750f9743d0c859bae112060b216f5c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-57wx-m983-2f88", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/5c8c9a8bfe750f9743d0c859bae112060b216f5c"}}