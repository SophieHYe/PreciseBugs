{"buggy_code": ["/*\n *  avilib.c\n *\n *  Copyright (C) Thomas ostreich - June 2001\n *  multiple audio track support Copyright (C) 2002 Thomas ostreich\n *\n *  Original code:\n *  Copyright (C) 1999 Rainer Johanni <Rainer@Johanni.de>\n *\n *  This file is part of transcode, a linux video stream processing tool\n *\n *  transcode is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  transcode is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License aint with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/setup.h>\n\n#ifndef GPAC_DISABLE_AVILIB\n\n#include <gpac/internal/avilib.h>\n\n\n#define INFO_LIST\n\n// add a new riff chunk after XX MB\n#define NEW_RIFF_THRES (1900*1024*1024)\n\n// Maximum number of indices per stream\n#define NR_IXNN_CHUNKS 96\n\n\n#define DEBUG_ODML\n#undef DEBUG_ODML\n\n/* The following variable indicates the kind of error */\n\nint AVI_errno = 0;\n\n#define MAX_INFO_STRLEN 64\nstatic char id_str[MAX_INFO_STRLEN];\n\n#define FRAME_RATE_SCALE 1000000\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for writing an AVI File                            *\n *                                                                 *\n *******************************************************************/\n\nstatic u32 avi_read(FILE *fd, char *buf, u32 len)\n{\n\tu32 r = 0;\n\n\twhile (r < len) {\n\t\ts32 n = (s32) gf_fread(buf + r, len - r, fd);\n\t\tif (n == 0) break;\n\t\tif (n < 0) return r;\n\t\tr += n;\n\t}\n\n\treturn r;\n}\n\nstatic u32 avi_write (FILE *fd, char *buf, u32 len)\n{\n\tu32 r = 0;\n\n\twhile (r < len) {\n\t\ts32 n = (u32) gf_fwrite (buf + r, len - r, fd);\n\t\tif (n < 0)\n\t\t\treturn n;\n\n\t\tr += n;\n\t}\n\treturn r;\n}\n\n/* HEADERBYTES: The number of bytes to reserve for the header */\n\n#define HEADERBYTES 2048\n\n/* AVI_MAX_LEN: The maximum length of an AVI file, we stay a bit below\n    the 2GB limit (Remember: 2*10^9 is smaller than 2 GB) */\n\n#define AVI_MAX_LEN (UINT_MAX-(1<<20)*16-HEADERBYTES)\n\n#define PAD_EVEN(x) ( ((x)+1) & ~1 )\n\n\n/* Copy n into dst as a 4 or 2 byte, little endian number.\n   Should also work on big endian machines */\n\nstatic void long2str(unsigned char *dst, s32 n)\n{\n\tdst[0] = (n    )&0xff;\n\tdst[1] = (n>> 8)&0xff;\n\tdst[2] = (n>>16)&0xff;\n\tdst[3] = (n>>24)&0xff;\n}\n\n#ifdef WORDS_BIGENDIAN\nstatic void short2str(unsigned char *dst, s32 n)\n{\n\tdst[0] = (n    )&0xff;\n\tdst[1] = (n>> 8)&0xff;\n}\n#endif\n\n/* Convert a string of 4 or 2 bytes to a number,\n   also working on big endian machines */\n\nstatic u64 str2ullong(unsigned char *str)\n{\n\tu64 r = ((u32)str[0] | ((u32)str[1]<<8) | ((u32)str[2]<<16) | ((u32)str[3]<<24));\n\tu64 s = ((u32)str[4] | ((u32)str[5]<<8) | ((u32)str[6]<<16) | ((u32)str[7]<<24));\n#ifdef __GNUC__\n\treturn ((s<<32)&0xffffffff00000000ULL)|(r&0xffffffff);\n#else\n\treturn ((s<<32)&0xffffffff00000000)|(r&0xffffffff);\n#endif\n}\n\nstatic u32 str2ulong(unsigned char *str)\n{\n\treturn ( (u32)str[0] | ((u32)str[1]<<8) | ((u32)str[2]<<16) | ((u32)str[3]<<24) );\n}\nstatic u32 str2ushort(unsigned char *str)\n{\n\treturn ( (u32)str[0] | ((u32)str[1]<<8) );\n}\n\n// bit 31 denotes a keyframe\nstatic u32 str2ulong_len (unsigned char *str)\n{\n\treturn str2ulong(str) & 0x7fffffff;\n}\n\n\n// if bit 31 is 0, its a keyframe\nstatic u32 str2ulong_key (unsigned char *str)\n{\n\tu32 c = str2ulong(str);\n\tc &= 0x80000000;\n\tif (c == 0) return 0x10;\n\telse return 0;\n}\n\n/* Calculate audio sample size from number of bits and number of channels.\n   This may have to be adjusted for eg. 12 bits and stereo */\n\nstatic int avi_sampsize(avi_t *AVI, int j)\n{\n\tint s;\n\ts = ((AVI->track[j].a_bits+7)/8)*AVI->track[j].a_chans;\n\t//   if(s==0) s=1; /* avoid possible zero divisions */\n\tif(s<4) s=4; /* avoid possible zero divisions */\n\treturn s;\n}\n\n/* Add a chunk (=tag and data) to the AVI file,\n   returns -1 on write error, 0 on success */\n\nstatic int avi_add_chunk(avi_t *AVI, unsigned char *tag, unsigned char *data, u32 length)\n{\n\tunsigned char c[8];\n\tchar p=0;\n\n\t/* Copy tag and length int c, so that we need only 1 write system call\n\t   for these two values */\n\n\tmemcpy(c,tag,4);\n\tlong2str(c+4,length);\n\n\t/* Output tag, length and data, restore previous position\n\t   if the write fails */\n\n\tif( avi_write(AVI->fdes,(char *)c,8) != 8 ||\n\t        avi_write(AVI->fdes,(char *)data,length) != length ||\n\t        avi_write(AVI->fdes,&p,length&1) != (length&1)) // if len is uneven, write a pad byte\n\t{\n\t\tgf_fseek(AVI->fdes,AVI->pos,SEEK_SET);\n\t\tAVI_errno = AVI_ERR_WRITE;\n\t\treturn -1;\n\t}\n\n\t/* Update file position */\n\n\tAVI->pos += 8 + PAD_EVEN(length);\n\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] pos=%lu %s\\n\", AVI->pos, tag));\n\n\treturn 0;\n}\n\n#define OUTD(n) long2str((unsigned char*) (ix00+bl),(s32)n); bl+=4\n#define OUTW(n) ix00[bl] = (n)&0xff; ix00[bl+1] = (n>>8)&0xff; bl+=2\n#define OUTC(n) ix00[bl] = (n)&0xff; bl+=1\n#define OUTS(s) memcpy(ix00+bl,s,4); bl+=4\n\n// this does the physical writeout of the ix## structure\nstatic int avi_ixnn_entry(avi_t *AVI, avistdindex_chunk *ch, avisuperindex_entry *en)\n{\n\tint bl;\n\tu32 k;\n\tunsigned int max = ch->nEntriesInUse * sizeof (u32) * ch->wLongsPerEntry + 24; // header\n\tchar *ix00 = (char *)gf_malloc (max);\n\tchar dfcc[5];\n\tmemcpy (dfcc, ch->fcc, 4);\n\tdfcc[4] = 0;\n\n\tbl = 0;\n\n\tif (en) {\n\t\ten->qwOffset = AVI->pos;\n\t\ten->dwSize = max;\n\t\t//en->dwDuration = ch->nEntriesInUse -1; // NUMBER OF stream ticks == frames for video/samples for audio\n\t}\n\n#ifdef DEBUG_ODML\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML Write %s: Entries %ld size %d \\n\", dfcc, ch->nEntriesInUse, max));\n#endif\n\n\t//OUTS(ch->fcc);\n\t//OUTD(max);\n\tOUTW(ch->wLongsPerEntry);\n\tOUTC(ch->bIndexSubType);\n\tOUTC(ch->bIndexType);\n\tOUTD(ch->nEntriesInUse);\n\tOUTS(ch->dwChunkId);\n\tOUTD(ch->qwBaseOffset&0xffffffff);\n\tOUTD((ch->qwBaseOffset>>32)&0xffffffff);\n\tOUTD(ch->dwReserved3);\n\n\tfor (k = 0; k < ch->nEntriesInUse; k++) {\n\t\tOUTD(ch->aIndex[k].dwOffset);\n\t\tOUTD(ch->aIndex[k].dwSize);\n\n\t}\n\tavi_add_chunk (AVI, (unsigned char*)ch->fcc, (unsigned char*)ix00, max);\n\n\tgf_free(ix00);\n\n\treturn 0;\n}\n#undef OUTS\n#undef OUTW\n#undef OUTD\n#undef OUTC\n\n// inits a super index structure including its enclosed stdindex\nstatic int avi_init_super_index(avi_t *AVI, unsigned char *idxtag, avisuperindex_chunk **si)\n{\n\tint k;\n\n\tavisuperindex_chunk *sil = NULL;\n\n\tif ((sil = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk))) == NULL) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\tmemcpy (sil->fcc, \"indx\", 4);\n\tsil->dwSize = 0; // size of this chunk\n\tsil->wLongsPerEntry = 4;\n\tsil->bIndexSubType = 0;\n\tsil->bIndexType = AVI_INDEX_OF_INDEXES;\n\tsil->nEntriesInUse = 0; // none are in use\n\tmemcpy (sil->dwChunkId, idxtag, 4);\n\tmemset (sil->dwReserved, 0, sizeof (sil->dwReserved));\n\n\t// NR_IXNN_CHUNKS == allow 32 indices which means 32 GB files -- arbitrary\n\tsil->aIndex = (avisuperindex_entry *) gf_malloc (sil->wLongsPerEntry * NR_IXNN_CHUNKS * sizeof (void*));\n\tif (!sil->aIndex) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\tmemset (sil->aIndex, 0, sil->wLongsPerEntry * NR_IXNN_CHUNKS * sizeof (u32));\n\n\tsil->stdindex = (avistdindex_chunk **)gf_malloc (NR_IXNN_CHUNKS * sizeof (avistdindex_chunk *));\n\tif (!sil->stdindex) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NR_IXNN_CHUNKS; k++) {\n\t\tsil->stdindex[k] = (avistdindex_chunk *) gf_malloc (sizeof (avistdindex_chunk));\n\t\t// gets rewritten later\n\t\tsil->stdindex[k]->qwBaseOffset = (u64)k * AVI->new_riff_threshold;\n\t\tsil->stdindex[k]->aIndex = NULL;\n\t}\n\n\t*si = sil;\n\n\treturn 0;\n}\n\n// fills an alloc'ed stdindex structure and mallocs some entries for the actual chunks\nstatic int avi_add_std_index(avi_t *AVI, unsigned char *idxtag, unsigned char *strtag,\n                             avistdindex_chunk *stdil)\n{\n\n\tmemcpy (stdil->fcc, idxtag, 4);\n\tstdil->dwSize = 4096;\n\tstdil->wLongsPerEntry = 2; //sizeof(avistdindex_entry)/sizeof(u32);\n\tstdil->bIndexSubType = 0;\n\tstdil->bIndexType = AVI_INDEX_OF_CHUNKS;\n\tstdil->nEntriesInUse = 0;\n\n\t// cp 00db ChunkId\n\tmemcpy(stdil->dwChunkId, strtag, 4);\n\n\t//stdil->qwBaseOffset = AVI->video_superindex->aIndex[ cur_std_idx ]->qwOffset;\n\n\tstdil->aIndex = (avistdindex_entry *)gf_malloc(stdil->dwSize * sizeof (u32) * stdil->wLongsPerEntry);\n\n\tif (!stdil->aIndex) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\n\n\treturn 0;\n}\n\nstatic int avi_add_odml_index_entry_core(avi_t *AVI, int flags, u64 pos, unsigned int len, avistdindex_chunk *si)\n{\n\tu32 cur_chunk_idx;\n\t// put new chunk into index\n\tsi->nEntriesInUse++;\n\tcur_chunk_idx = si->nEntriesInUse-1;\n\n\t// need to fetch more memory\n\tif (cur_chunk_idx >= si->dwSize) {\n\t\tsi->dwSize += 4096;\n\t\tsi->aIndex = (avistdindex_entry *)gf_realloc ( si->aIndex, si->dwSize * sizeof (u32) * si->wLongsPerEntry);\n\t}\n\n\tif(len>AVI->max_len) AVI->max_len=len;\n\n\t// if bit 31 is set, it is NOT a keyframe\n\tif (flags != 0x10) {\n\t\tlen |= 0x80000000;\n\t}\n\n\tsi->aIndex [ cur_chunk_idx ].dwSize = len;\n\tsi->aIndex [ cur_chunk_idx ].dwOffset = (u32) (pos - si->qwBaseOffset + 8);\n\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: POS: 0x%lX\\n\", si->aIndex [ cur_chunk_idx ].dwOffset));\n\n\treturn 0;\n}\n\nstatic int avi_add_odml_index_entry(avi_t *AVI, unsigned char *tag, int flags, u64 pos, unsigned int len)\n{\n\tchar fcc[5];\n\n\tint audio = (strchr ((char*)tag, 'w')?1:0);\n\tint video = !audio;\n\n\tunsigned int cur_std_idx;\n\tu32 audtr;\n\ts64 towrite = 0;\n\n\tif (video) {\n\n\t\tif (!AVI->video_superindex) {\n\t\t\tif (avi_init_super_index(AVI, (unsigned char *)\"ix00\", &AVI->video_superindex) < 0) return -1;\n\t\t\tAVI->video_superindex->nEntriesInUse++;\n\t\t\tcur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\n\t\t\tif (avi_add_std_index (AVI, (unsigned char *)\"ix00\", (unsigned char *)\"00db\", AVI->video_superindex->stdindex[ cur_std_idx ]) < 0)\n\t\t\t\treturn -1;\n\t\t} // init\n\n\t} // video\n\n\tif (audio) {\n\n\t\tfcc[0] = 'i';\n\t\tfcc[1] = 'x';\n\t\tfcc[2] = tag[0];\n\t\tfcc[3] = tag[1];\n\t\tfcc[4] = '\\0';\n\t\tif (!AVI->track[AVI->aptr].audio_superindex) {\n\n#ifdef DEBUG_ODML\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: fcc = %s\\n\", fcc));\n#endif\n\t\t\tif (avi_init_super_index(AVI, (unsigned char *)fcc, &AVI->track[AVI->aptr].audio_superindex) < 0) return -1;\n\n\n\t\t\tAVI->track[AVI->aptr].audio_superindex->nEntriesInUse++;\n\n\t\t\tsprintf(fcc, \"ix%02d\", AVI->aptr+1);\n\t\t\tif (avi_add_std_index (AVI, (unsigned char *)fcc, tag, AVI->track[AVI->aptr].audio_superindex->stdindex[\n\t\t\t                           AVI->track[AVI->aptr].audio_superindex->nEntriesInUse - 1 ]) < 0\n\t\t\t   ) return -1;\n\t\t} // init\n\n\t}\n\n\ttowrite = 0;\n\tif (AVI->video_superindex) {\n\n\t\tcur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\t\ttowrite += AVI->video_superindex->stdindex[cur_std_idx]->nEntriesInUse*8\n\t\t           + 4+4+2+1+1+4+4+8+4;\n\t\tif (cur_std_idx == 0) {\n\t\t\ttowrite += AVI->n_idx*16 + 8;\n\t\t\ttowrite += HEADERBYTES;\n\t\t}\n\t}\n\n\tfor (audtr=0; audtr<AVI->anum; audtr++) {\n\t\tif (AVI->track[audtr].audio_superindex) {\n\t\t\tcur_std_idx = AVI->track[audtr].audio_superindex->nEntriesInUse-1;\n\t\t\ttowrite += AVI->track[audtr].audio_superindex->stdindex[cur_std_idx]->nEntriesInUse*8\n\t\t\t           + 4+4+2+1+1+4+4+8+4;\n\t\t}\n\t}\n\ttowrite += len + (len&1) + 8;\n\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: towrite = 0x%llX = %\"LLD\"\\n\", towrite, towrite));\n\n\tif (AVI->video_superindex &&\n\t        (s64)(AVI->pos+towrite) > (s64)((s64) AVI->new_riff_threshold*AVI->video_superindex->nEntriesInUse)) {\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Adding a new RIFF chunk: %d\\n\", AVI->video_superindex->nEntriesInUse));\n\n\t\t// rotate ALL indices\n\t\tAVI->video_superindex->nEntriesInUse++;\n\t\tcur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\n\t\tif (AVI->video_superindex->nEntriesInUse > NR_IXNN_CHUNKS) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib - redefine NR_IXNN_CHUNKS\\n\"));\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] cur_std_idx=%d NR_IXNN_CHUNKS=%d\"\n\t\t\t                                        \"POS=%\"LLD\" towrite=%\"LLD\"\\n\",\n\t\t\t                                        cur_std_idx,NR_IXNN_CHUNKS, AVI->pos, towrite));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (avi_add_std_index (AVI, (unsigned char *)\"ix00\", (unsigned char *)\"00db\", AVI->video_superindex->stdindex[ cur_std_idx ]) < 0)\n\t\t\treturn -1;\n\n\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\t\t\tchar aud[5];\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\t// not initialized -> no index\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAVI->track[audtr].audio_superindex->nEntriesInUse++;\n\n\t\t\tsprintf(fcc, \"ix%02d\", audtr+1);\n\t\t\tsprintf(aud, \"0%01dwb\", audtr+1);\n\t\t\tif (avi_add_std_index (AVI, (unsigned char *)fcc, (unsigned char *)aud, AVI->track[audtr].audio_superindex->stdindex[\n\t\t\t                           AVI->track[audtr].audio_superindex->nEntriesInUse - 1 ]) < 0\n\t\t\t   ) return -1;\n\t\t}\n\n\t\t// write the new riff;\n\t\tif (cur_std_idx > 0) {\n\n\t\t\t// dump the _previous_ == already finished index\n\t\t\tavi_ixnn_entry (AVI, AVI->video_superindex->stdindex[cur_std_idx - 1],\n\t\t\t                &AVI->video_superindex->aIndex[cur_std_idx - 1]);\n\t\t\tAVI->video_superindex->aIndex[cur_std_idx - 1].dwDuration =\n\t\t\t    AVI->video_superindex->stdindex[cur_std_idx - 1]->nEntriesInUse - 1;\n\n\t\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\n\t\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\t\t// not initialized -> no index\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tavi_ixnn_entry (AVI, AVI->track[audtr].audio_superindex->stdindex[cur_std_idx - 1],\n\t\t\t\t                &AVI->track[audtr].audio_superindex->aIndex[cur_std_idx - 1]);\n\n\t\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx - 1].dwDuration =\n\t\t\t\t    AVI->track[audtr].audio_superindex->stdindex[cur_std_idx - 1]->nEntriesInUse - 1;\n\t\t\t\tif (AVI->track[audtr].a_fmt == 0x1) {\n\t\t\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx - 1].dwDuration *=\n\t\t\t\t\t    AVI->track[audtr].a_bits*AVI->track[audtr].a_rate*AVI->track[audtr].a_chans/800;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// XXX: dump idx1 structure\n\t\t\tif (cur_std_idx == 1) {\n\t\t\t\tavi_add_chunk(AVI, (unsigned char *)\"idx1\", (unsigned char *)AVI->idx, AVI->n_idx*16);\n\t\t\t\t// qwBaseOffset will contain the start of the second riff chunk\n\t\t\t}\n\t\t\t// Fix the Offsets later at closing time\n\t\t\tavi_add_chunk(AVI, (unsigned char *)\"RIFF\", (unsigned char *)\"AVIXLIST\\0\\0\\0\\0movi\", 16);\n\n\t\t\tAVI->video_superindex->stdindex[ cur_std_idx ]->qwBaseOffset = AVI->pos -16 -8;\n#ifdef DEBUG_ODML\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: RIFF No.%02d at Offset 0x%llX\\n\", cur_std_idx, AVI->pos -16 -8));\n#endif\n\n\t\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\t\t\t\tif (AVI->track[audtr].audio_superindex)\n\t\t\t\t\tAVI->track[audtr].audio_superindex->stdindex[ cur_std_idx ]->qwBaseOffset =\n\t\t\t\t\t    AVI->pos -16 -8;\n\n\t\t\t}\n\n\t\t\t// now we can be sure\n\t\t\tAVI->is_opendml++;\n\t\t}\n\n\t}\n\n\n\tif (video) {\n\t\tavi_add_odml_index_entry_core(AVI, flags, AVI->pos, len,\n\t\t                              AVI->video_superindex->stdindex[ AVI->video_superindex->nEntriesInUse-1 ]);\n\n\t\tAVI->total_frames++;\n\t} // video\n\n\tif (audio) {\n\t\tavi_add_odml_index_entry_core(AVI, flags, AVI->pos, len,\n\t\t                              AVI->track[AVI->aptr].audio_superindex->stdindex[\n\t\t                                  AVI->track[AVI->aptr].audio_superindex->nEntriesInUse-1 ]);\n\t}\n\n\n\treturn 0;\n}\n\n// #undef NR_IXNN_CHUNKS\n\nstatic int avi_add_index_entry(avi_t *AVI, unsigned char *tag, int flags, u64 pos, u64 len)\n{\n\tif(AVI->n_idx>=AVI->max_idx) {\n\t\tvoid *ptr = gf_realloc((void *)AVI->idx,(AVI->max_idx+4096)*16);\n\n\t\tif(ptr == 0) {\n\t\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\t\treturn -1;\n\t\t}\n\t\tAVI->max_idx += 4096;\n\t\tAVI->idx = (unsigned char((*)[16]) ) ptr;\n\t}\n\n\t/* Add index entry */\n\n\t//   GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] INDEX %s %ld %lu %lu\\n\", tag, flags, pos, len));\n\n\tmemcpy(AVI->idx[AVI->n_idx],tag,4);\n\tlong2str(AVI->idx[AVI->n_idx]+ 4,flags);\n\tlong2str(AVI->idx[AVI->n_idx]+ 8, (s32) pos);\n\tlong2str(AVI->idx[AVI->n_idx]+12, (s32) len);\n\n\t/* Update counter */\n\n\tAVI->n_idx++;\n\n\tif(len>AVI->max_len) AVI->max_len=(u32) len;\n\n\treturn 0;\n}\n\n#if 0\n/* Returns 1 if more audio is in that video junk */\nint AVI_can_read_audio(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\treturn -1;\n\t}\n\n\t// is it -1? the last ones got left out --tibit\n\t//if (AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) {\n\tif (AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks) {\n\t\treturn 0;\n\t}\n\n\tif (AVI->video_pos >= AVI->video_frames) return 1;\n\n\tif (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos < AVI->video_index[AVI->video_pos].pos) return 1;\n\telse return 0;\n}\n#endif\n\n/*\n   AVI_open_output_file: Open an AVI File and write a bunch\n                         of zero bytes as space for the header.\n\n   returns a pointer to avi_t on success, a zero pointer on error\n*/\n\nGF_EXPORT\navi_t* AVI_open_output_file(char * filename, u64 opendml_threshold)\n{\n\tavi_t *AVI;\n\tint i;\n\n\tunsigned char AVI_header[HEADERBYTES];\n\n\t/* Allocate the avi_t struct and zero it */\n\n\tAVI = (avi_t *) gf_malloc(sizeof(avi_t));\n\tif(AVI==0)\n\t{\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn 0;\n\t}\n\tmemset((void *)AVI,0,sizeof(avi_t));\n\n\tAVI->fdes = gf_fopen(filename, \"w+b\");\n\tif (!AVI->fdes )\n\t{\n\t\tAVI_errno = AVI_ERR_OPEN;\n\t\tgf_free(AVI);\n\t\treturn 0;\n\t}\n\n\t/* Write out HEADERBYTES bytes, the header will go here\n\t   when we are finished with writing */\n\n\tfor (i=0; i<HEADERBYTES; i++) AVI_header[i] = 0;\n\ti = avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES);\n\tif (i != HEADERBYTES)\n\t{\n\t\tgf_fclose(AVI->fdes);\n\t\tAVI_errno = AVI_ERR_WRITE;\n\t\tgf_free(AVI);\n\t\treturn 0;\n\t}\n\n\tAVI->pos  = HEADERBYTES;\n\tAVI->mode = AVI_MODE_WRITE; /* open for writing */\n\tif (opendml_threshold)\n\t\tAVI->new_riff_threshold = opendml_threshold;\n\telse\n\t\tAVI->new_riff_threshold = (1900*1024*1024);\n\n\t//init\n\tAVI->anum = 0;\n\tAVI->aptr = 0;\n\n\treturn AVI;\n}\n\nGF_EXPORT\nvoid AVI_set_video(avi_t *AVI, int width, int height, double fps, char *compressor)\n{\n\t/* may only be called if file is open for writing */\n\n\tif(AVI->mode==AVI_MODE_READ) return;\n\n\tAVI->width  = width;\n\tAVI->height = height;\n\tAVI->fps    = fps;\n\n\tif(strncmp(compressor, \"RGB\", 3)==0) {\n\t\tmemset(AVI->compressor, 0, 4);\n\t} else {\n\t\tmemcpy(AVI->compressor,compressor,4);\n\t}\n\n\tAVI->compressor[4] = 0;\n\n\tavi_update_header(AVI);\n}\n\nGF_EXPORT\nvoid AVI_set_audio(avi_t *AVI, int channels, int rate, int bits, int format, int mp3rate)\n{\n\t/* may only be called if file is open for writing */\n\n\tif(AVI->mode==AVI_MODE_READ) return;\n\n\t//inc audio tracks\n\tAVI->aptr=AVI->anum;\n\t++AVI->anum;\n\n\tif(AVI->anum > AVI_MAX_TRACKS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));\n\t\texit(1);\n\t}\n\n\tAVI->track[AVI->aptr].a_chans = channels;\n\tAVI->track[AVI->aptr].a_rate  = rate;\n\tAVI->track[AVI->aptr].a_bits  = bits;\n\tAVI->track[AVI->aptr].a_fmt   = format;\n\tAVI->track[AVI->aptr].mp3rate = mp3rate;\n\n\tavi_update_header(AVI);\n}\n\n#define OUT4CC(s) \\\n   if(nhb<=HEADERBYTES-4) memcpy(AVI_header+nhb,s,4); \\\n   nhb += 4\n\n#define OUTLONG(n) \\\n   if(nhb<=HEADERBYTES-4) long2str(AVI_header+nhb, (s32)(n)); \\\n   nhb += 4\n\n#define OUTSHRT(n) \\\n   if(nhb<=HEADERBYTES-2) { \\\n      AVI_header[nhb  ] = (u8) ((n   )&0xff); \\\n      AVI_header[nhb+1] = (u8) ((n>>8)&0xff); \\\n   } \\\n   nhb += 2\n\n#define OUTCHR(n) \\\n   if(nhb<=HEADERBYTES-1) { \\\n      AVI_header[nhb  ] = (n   )&0xff; \\\n   } \\\n   nhb += 1\n\n#define OUTMEM(d, s) \\\n   { \\\n     u32 s_ = (u32) (s); \\\n     if(nhb + s_ <= HEADERBYTES) \\\n        memcpy(AVI_header+nhb, (d), s_); \\\n     nhb += s_; \\\n   }\n\n\n//ThOe write preliminary AVI file header: 0 frames, max vid/aud size\nint avi_update_header(avi_t *AVI)\n{\n\tint njunk, ms_per_frame, frate, flag;\n\tint movi_len, hdrl_start, strl_start;\n\tu32 j;\n\tunsigned char AVI_header[HEADERBYTES];\n\tu32 nhb;\n\tunsigned int xd_size, xd_size_align2;\n\n\t//assume max size\n\tmovi_len = AVI_MAX_LEN - HEADERBYTES + 4;\n\n\t//assume index will be written\n//\tint hasIndex=1;\n\n\tif(AVI->fps < 0.001) {\n\t\tfrate=0;\n\t\tms_per_frame=0;\n\t} else {\n\t\tfrate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n\t\tms_per_frame=(int) (1000000/AVI->fps + 0.5);\n\t}\n\n\t/* Prepare the file header */\n\n\tnhb = 0;\n\n\t/* The RIFF header */\n\n\tOUT4CC (\"RIFF\");\n\tOUTLONG(movi_len);    // assume max size\n\tOUT4CC (\"AVI \");\n\n\t/* Start the header list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\thdrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"hdrl\");\n\n\t/* The main AVI header */\n\n\t/* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n\tOUT4CC (\"avih\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUTLONG(ms_per_frame);       /* Microseconds per frame */\n\t//ThOe ->0\n\t//   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n\tOUTLONG(0);\n\tOUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n\t/* Other sources call it 'reserved' */\n\tflag = AVIF_ISINTERLEAVED;\n\t//if (hasIndex)\n\t\tflag |= AVIF_HASINDEX;\n\tif (/*hasIndex && */AVI->must_use_index)\n\t\tflag |= AVIF_MUSTUSEINDEX;\n\tOUTLONG(flag);               /* Flags */\n\tOUTLONG(0);                  // no frames yet\n\tOUTLONG(0);                  /* InitialFrames */\n\n\tOUTLONG(AVI->anum+1);\n\n\tOUTLONG(0);                  /* SuggestedBufferSize */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\t/* MS calls the following 'reserved': */\n\tOUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n\tOUTLONG(0);                  /* DataRate:   Data rate of playback     */\n\tOUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n\tOUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n\t/* Start the video stream list ---------------------------------- */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\tstrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"strl\");\n\n\t/* The video stream header */\n\n\tOUT4CC (\"strh\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUT4CC (\"vids\");             /* Type */\n\tOUT4CC (AVI->compressor);    /* Handler */\n\tOUTLONG(0);                  /* Flags */\n\tOUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n\tOUTLONG(0);                  /* InitialFrames */\n\tOUTLONG(FRAME_RATE_SCALE);              /* Scale */\n\tOUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n\tOUTLONG(0);                  /* Start */\n\tOUTLONG(0);                  // no frames yet\n\tOUTLONG(0);                  /* SuggestedBufferSize */\n\tOUTLONG(-1);                 /* Quality */\n\tOUTLONG(0);                  /* SampleSize */\n\tOUTLONG(0);                  /* Frame */\n\tOUTLONG(0);                  /* Frame */\n\t//   OUTLONG(0);                  /* Frame */\n\t//OUTLONG(0);                  /* Frame */\n\n\t/* The video stream format */\n\n\txd_size        = AVI->extradata_size;\n\txd_size_align2 = (AVI->extradata_size+1) & ~1;\n\n\tOUT4CC (\"strf\");\n\tOUTLONG(40 + xd_size_align2);/* # of bytes to follow */\n\tOUTLONG(40 + xd_size);\t/* Size */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\tOUTSHRT(1);\n\tOUTSHRT(24);     /* Planes, Count */\n\tOUT4CC (AVI->compressor);    /* Compression */\n\t// ThOe (*3)\n\tOUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n\tOUTLONG(0);                  /* XPelsPerMeter */\n\tOUTLONG(0);                  /* YPelsPerMeter */\n\tOUTLONG(0);                  /* ClrUsed: Number of colors used */\n\tOUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n\t// write extradata\n\tif (xd_size > 0 && AVI->extradata) {\n\t\tOUTMEM(AVI->extradata, xd_size);\n\t\tif (xd_size != xd_size_align2) {\n\t\t\tOUTCHR(0);\n\t\t}\n\t}\n\n\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\n\n\t/* Start the audio stream list ---------------------------------- */\n\n\tfor(j=0; j<AVI->anum; ++j) {\n\t\tint sampsize = avi_sampsize(AVI, j);\n\n\t\tOUT4CC (\"LIST\");\n\t\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\t\tstrl_start = nhb;  /* Store start position */\n\t\tOUT4CC (\"strl\");\n\n\t\t/* The audio stream header */\n\n\t\tOUT4CC (\"strh\");\n\t\tOUTLONG(56);            /* # of bytes to follow */\n\t\tOUT4CC (\"auds\");\n\n\t\t// -----------\n\t\t// ThOe\n\t\tOUTLONG(0);             /* Format (Optionally) */\n\t\t// -----------\n\n\t\tOUTLONG(0);             /* Flags */\n\t\tOUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n\t\tOUTLONG(0);             /* InitialFrames */\n\n\t\t// ThOe /4\n\t\tOUTLONG(sampsize/4);      /* Scale */\n\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);\n\t\tOUTLONG(0);             /* Start */\n\t\tOUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n\t\tOUTLONG(0);             /* SuggestedBufferSize */\n\t\tOUTLONG(-1);            /* Quality */\n\n\t\t// ThOe /4\n\t\tOUTLONG(sampsize/4);    /* SampleSize */\n\n\t\tOUTLONG(0);             /* Frame */\n\t\tOUTLONG(0);             /* Frame */\n\t\t//       OUTLONG(0);             /* Frame */\n\t\t//OUTLONG(0);             /* Frame */\n\n\t\t/* The audio stream format */\n\n\t\tOUT4CC (\"strf\");\n\t\tOUTLONG(16);                   /* # of bytes to follow */\n\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */\n\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n\t\t// ThOe\n\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);\n\t\t//ThOe (/4)\n\n\t\tOUTSHRT(sampsize/4);           /* BlockAlign */\n\n\n\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n\n\t\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n\t\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\t}\n\n\t/* Finish header list */\n\n\tlong2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n\n\n\t/* Calculate the needed amount of junk bytes, output junk */\n\n\tnjunk = HEADERBYTES - nhb - 8 - 12;\n\n\t/* Safety first: if njunk <= 0, somebody has played with\n\t   HEADERBYTES without knowing what (s)he did.\n\t   This is a fatal error */\n\n\tif(njunk<=0)\n\t{\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVI_close_output_file: # of header bytes too small\\n\"));\n\t\texit(1);\n\t}\n\n\tOUT4CC (\"JUNK\");\n\tOUTLONG(njunk);\n\tmemset(AVI_header+nhb,0,njunk);\n\n\tnhb += njunk;\n\n\t/* Start the movi list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(movi_len); /* Length of list in bytes */\n\tOUT4CC (\"movi\");\n\n\t/* Output the header, truncate the file to the number of bytes\n\t   actually written, report an error if someting goes wrong */\n\n\tif ( (gf_fseek(AVI->fdes, 0, SEEK_SET) ==(u64)-1) ||\n\t        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES ||\n\t        (gf_fseek(AVI->fdes,AVI->pos,SEEK_SET)==(u64)-1)\n\t   ) {\n\t\tAVI_errno = AVI_ERR_CLOSE;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\n//SLM\n#ifndef S_IRUSR\n#define S_IRWXU       00700       /* read, write, execute: owner */\n#define S_IRUSR       00400       /* read permission: owner */\n#define S_IWUSR       00200       /* write permission: owner */\n#define S_IXUSR       00100       /* execute permission: owner */\n#define S_IRWXG       00070       /* read, write, execute: group */\n#define S_IRGRP       00040       /* read permission: group */\n#define S_IWGRP       00020       /* write permission: group */\n#define S_IXGRP       00010       /* execute permission: group */\n#define S_IRWXO       00007       /* read, write, execute: other */\n#define S_IROTH       00004       /* read permission: other */\n#define S_IWOTH       00002       /* write permission: other */\n#define S_IXOTH       00001       /* execute permission: other */\n#endif\n\n/*\n  Write the header of an AVI file and close it.\n  returns 0 on success, -1 on write error.\n*/\n\nstatic int avi_close_output_file(avi_t *AVI)\n{\n\tint njunk, hasIndex, ms_per_frame, frate, idxerror, flag;\n\tu64 movi_len;\n\tint hdrl_start, strl_start;\n\tu32 j;\n\tunsigned char AVI_header[HEADERBYTES];\n\tint nhb;\n\tunsigned int xd_size, xd_size_align2;\n\n#ifdef INFO_LIST\n\tint info_len;\n\tint id_len, real_id_len;\n\tint info_start_pos;\n//   time_t calptr;\n#endif\n\n\t/* Calculate length of movi list */\n\n\t// dump the rest of the index\n\tif (AVI->is_opendml) {\n\t\tint cur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\t\tu32 audtr;\n\n#ifdef DEBUG_ODML\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML dump the rest indices\\n\"));\n#endif\n\t\tavi_ixnn_entry (AVI, AVI->video_superindex->stdindex[cur_std_idx],\n\t\t                &AVI->video_superindex->aIndex[cur_std_idx]);\n\n\t\tAVI->video_superindex->aIndex[cur_std_idx].dwDuration =\n\t\t    AVI->video_superindex->stdindex[cur_std_idx]->nEntriesInUse - 1;\n\n\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\t// not initialized -> no index\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tavi_ixnn_entry (AVI, AVI->track[audtr].audio_superindex->stdindex[cur_std_idx],\n\t\t\t                &AVI->track[audtr].audio_superindex->aIndex[cur_std_idx]);\n\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx].dwDuration =\n\t\t\t    AVI->track[audtr].audio_superindex->stdindex[cur_std_idx]->nEntriesInUse - 1;\n\t\t\tif (AVI->track[audtr].a_fmt == 0x1) {\n\t\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx].dwDuration *=\n\t\t\t\t    AVI->track[audtr].a_bits*AVI->track[audtr].a_rate*AVI->track[audtr].a_chans/800;\n\t\t\t}\n\t\t}\n\t\t// The AVI->video_superindex->nEntriesInUse contains the offset\n\t\tAVI->video_superindex->stdindex[ cur_std_idx+1 ]->qwBaseOffset = AVI->pos;\n\n\t\t// Correct!\n\t\tmovi_len = AVI->video_superindex->stdindex[ 1 ]->qwBaseOffset - HEADERBYTES+4 - AVI->n_idx*16 - 8;\n\t} else {\n\t\tmovi_len = AVI->pos - HEADERBYTES + 4;\n\t}\n\n\n\t/* Try to output the index entries. This may fail e.g. if no space\n\t   is left on device. We will report this as an error, but we still\n\t   try to write the header correctly (so that the file still may be\n\t   readable in the most cases */\n\n\tidxerror = 0;\n\thasIndex = 1;\n\tif (!AVI->is_opendml) {\n\t\t//   GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] pos=%lu, index_len=%ld             \\n\", AVI->pos, AVI->n_idx*16));\n\t\tint ret = avi_add_chunk(AVI, (unsigned char *)\"idx1\", (unsigned char *)AVI->idx, AVI->n_idx*16);\n\t\thasIndex = (ret==0);\n\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] pos=%lu, index_len=%d\\n\", AVI->pos, hasIndex));\n\n\t\tif(ret) {\n\t\t\tidxerror = 1;\n\t\t\tAVI_errno = AVI_ERR_WRITE_INDEX;\n\t\t}\n\t}\n\n\t/* Calculate Microseconds per frame */\n\n\tif(AVI->fps < 0.001) {\n\t\tfrate=0;\n\t\tms_per_frame=0;\n\t} else {\n\t\tfrate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n\t\tms_per_frame=(int) (1000000/AVI->fps + 0.5);\n\t}\n\n\t/* Prepare the file header */\n\n\tnhb = 0;\n\n\t/* The RIFF header */\n\n\tOUT4CC (\"RIFF\");\n\tif (AVI->is_opendml) {\n\t\tOUTLONG(AVI->video_superindex->stdindex[ 1 ]->qwBaseOffset - 8);    /* # of bytes to follow */\n\t} else {\n\t\tOUTLONG(AVI->pos - 8);    /* # of bytes to follow */\n\t}\n\n\tOUT4CC (\"AVI \");\n\n\t/* Start the header list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\thdrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"hdrl\");\n\n\t/* The main AVI header */\n\n\t/* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n\tOUT4CC (\"avih\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUTLONG(ms_per_frame);       /* Microseconds per frame */\n\t//ThOe ->0\n\t//   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n\tOUTLONG(0);\n\tOUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n\t/* Other sources call it 'reserved' */\n\tflag = AVIF_ISINTERLEAVED;\n\tif(hasIndex) flag |= AVIF_HASINDEX;\n\tif(hasIndex && AVI->must_use_index) flag |= AVIF_MUSTUSEINDEX;\n\tOUTLONG(flag);               /* Flags */\n\tOUTLONG(AVI->video_frames);  /* TotalFrames */\n\tOUTLONG(0);                  /* InitialFrames */\n\n\tOUTLONG(AVI->anum+1);\n//   if (AVI->track[0].audio_bytes)\n//      { OUTLONG(2); }           /* Streams */\n//   else\n//      { OUTLONG(1); }           /* Streams */\n\n\tOUTLONG(0);                  /* SuggestedBufferSize */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\t/* MS calls the following 'reserved': */\n\tOUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n\tOUTLONG(0);                  /* DataRate:   Data rate of playback     */\n\tOUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n\tOUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n\t/* Start the video stream list ---------------------------------- */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\tstrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"strl\");\n\n\t/* The video stream header */\n\n\tOUT4CC (\"strh\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUT4CC (\"vids\");             /* Type */\n\tOUT4CC (AVI->compressor);    /* Handler */\n\tOUTLONG(0);                  /* Flags */\n\tOUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n\tOUTLONG(0);                  /* InitialFrames */\n\tOUTLONG(FRAME_RATE_SCALE);   /* Scale */\n\tOUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n\tOUTLONG(0);                  /* Start */\n\tOUTLONG(AVI->video_frames);  /* Length */\n\tOUTLONG(AVI->max_len);       /* SuggestedBufferSize */\n\tOUTLONG(0);                  /* Quality */\n\tOUTLONG(0);                  /* SampleSize */\n\tOUTLONG(0);                  /* Frame */\n\tOUTLONG(0);                  /* Frame */\n\t//OUTLONG(0);                  /* Frame */\n\t//OUTLONG(0);                  /* Frame */\n\n\t/* The video stream format */\n\n\txd_size        = AVI->extradata_size;\n\txd_size_align2 = (AVI->extradata_size+1) & ~1;\n\n\tOUT4CC (\"strf\");\n\tOUTLONG(40 + xd_size_align2);/* # of bytes to follow */\n\tOUTLONG(40 + xd_size);\t/* Size */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\tOUTSHRT(1);\n\tOUTSHRT(24);     /* Planes, Count */\n\tOUT4CC (AVI->compressor);    /* Compression */\n\t// ThOe (*3)\n\tOUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n\tOUTLONG(0);                  /* XPelsPerMeter */\n\tOUTLONG(0);                  /* YPelsPerMeter */\n\tOUTLONG(0);                  /* ClrUsed: Number of colors used */\n\tOUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n\t// write extradata if present\n\tif (xd_size > 0 && AVI->extradata) {\n\t\tOUTMEM(AVI->extradata, xd_size);\n\t\tif (xd_size != xd_size_align2) {\n\t\t\tOUTCHR(0);\n\t\t}\n\t}\n\n\t// dump index of indices for audio\n\tif (AVI->is_opendml) {\n\t\tu32 k;\n\n\t\tOUT4CC(AVI->video_superindex->fcc);\n\t\tOUTLONG(2+1+1+4+4+3*4 + AVI->video_superindex->nEntriesInUse * (8+4+4));\n\t\tOUTSHRT(AVI->video_superindex->wLongsPerEntry);\n\t\tOUTCHR(AVI->video_superindex->bIndexSubType);\n\t\tOUTCHR(AVI->video_superindex->bIndexType);\n\t\tOUTLONG(AVI->video_superindex->nEntriesInUse);\n\t\tOUT4CC(AVI->video_superindex->dwChunkId);\n\t\tOUTLONG(0);\n\t\tOUTLONG(0);\n\t\tOUTLONG(0);\n\n\n\t\tfor (k = 0; k < AVI->video_superindex->nEntriesInUse; k++) {\n\t\t\tu32 r = (u32) ((AVI->video_superindex->aIndex[k].qwOffset >> 32) & 0xffffffff);\n\t\t\tu32 s = (u32) ((AVI->video_superindex->aIndex[k].qwOffset) & 0xffffffff);\n\n\t\t\tOUTLONG(s);\n\t\t\tOUTLONG(r);\n\t\t\tOUTLONG(AVI->video_superindex->aIndex[k].dwSize);\n\t\t\tOUTLONG(AVI->video_superindex->aIndex[k].dwDuration);\n\t\t}\n\n\t}\n\n\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\n\t/* Start the audio stream list ---------------------------------- */\n\n\tfor(j=0; j<AVI->anum; ++j) {\n\n\t\t//if (AVI->track[j].a_chans && AVI->track[j].audio_bytes)\n\t\t{\n\t\t\tunsigned int nBlockAlign = 0;\n\t\t\tunsigned int avgbsec = 0;\n\t\t\tunsigned int scalerate = 0;\n\n\t\t\tint sampsize = avi_sampsize(AVI, j);\n\t\t\tsampsize = AVI->track[j].a_fmt==0x1?sampsize*4:sampsize;\n\n\t\t\tnBlockAlign = (AVI->track[j].a_rate<32000)?576:1152;\n\t\t\t/*\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] XXX sampsize (%d) block (%ld) rate (%ld) audio_bytes (%ld) mp3rate(%ld,%ld)\\n\",\n\t\t\t sampsize, nBlockAlign, AVI->track[j].a_rate,\n\t\t\t (int int)AVI->track[j].audio_bytes,\n\t\t\t 1000*AVI->track[j].mp3rate/8, AVI->track[j].mp3rate));\n\t\t\t */\n\n\t\t\tif (AVI->track[j].a_fmt==0x1) {\n\t\t\t\tsampsize = (AVI->track[j].a_chans<2)?sampsize/2:sampsize;\n\t\t\t\tavgbsec = AVI->track[j].a_rate*sampsize/4;\n\t\t\t\tscalerate = AVI->track[j].a_rate*sampsize/4;\n\t\t\t} else  {\n\t\t\t\tavgbsec = 1000*AVI->track[j].mp3rate/8;\n\t\t\t\tscalerate = 1000*AVI->track[j].mp3rate/8;\n\t\t\t}\n\n\t\t\tOUT4CC (\"LIST\");\n\t\t\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\t\t\tstrl_start = nhb;  /* Store start position */\n\t\t\tOUT4CC (\"strl\");\n\n\t\t\t/* The audio stream header */\n\n\t\t\tOUT4CC (\"strh\");\n\t\t\tOUTLONG(56);            /* # of bytes to follow */\n\t\t\tOUT4CC (\"auds\");\n\n\t\t\t// -----------\n\t\t\t// ThOe\n\t\t\tOUTLONG(0);             /* Format (Optionally) */\n\t\t\t// -----------\n\n\t\t\tOUTLONG(0);             /* Flags */\n\t\t\tOUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n\t\t\tOUTLONG(0);             /* InitialFrames */\n\n\t\t\t// VBR\n\t\t\tif (AVI->track[j].a_fmt == 0x55 && AVI->track[j].a_vbr) {\n\t\t\t\tOUTLONG(nBlockAlign);                   /* Scale */\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* Rate */\n\t\t\t\tOUTLONG(0);                             /* Start */\n\t\t\t\tOUTLONG(AVI->track[j].audio_chunks);    /* Length */\n\t\t\t\tOUTLONG(0);                      /* SuggestedBufferSize */\n\t\t\t\tOUTLONG(0);                             /* Quality */\n\t\t\t\tOUTLONG(0);                             /* SampleSize */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t} else {\n\t\t\t\tOUTLONG(sampsize/4);                    /* Scale */\n\t\t\t\tOUTLONG(scalerate);  /* Rate */\n\t\t\t\tOUTLONG(0);                             /* Start */\n\t\t\t\tOUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n\t\t\t\tOUTLONG(0);                             /* SuggestedBufferSize */\n\t\t\t\tOUTLONG(0xffffffff);                             /* Quality */\n\t\t\t\tOUTLONG(sampsize/4);                    /* SampleSize */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t}\n\n\t\t\t/* The audio stream format */\n\n\t\t\tOUT4CC (\"strf\");\n\n\t\t\tif (AVI->track[j].a_fmt == 0x55 && AVI->track[j].a_vbr) {\n\n\t\t\t\tOUTLONG(30);                            /* # of bytes to follow */ // mplayer writes 28\n\t\t\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */                  // 2\n\t\t\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */      // 2\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */           // 4\n\t\t\t\t//ThOe/tibit\n\t\t\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);  /* maybe we should write an avg. */ // 4\n\t\t\t\tOUTSHRT(nBlockAlign);                   /* BlockAlign */              // 2\n\t\t\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */           // 2\n\n\t\t\t\tOUTSHRT(12);                           /* cbSize */                   // 2\n\t\t\t\tOUTSHRT(1);                            /* wID */                      // 2\n\t\t\t\tOUTLONG(2);                            /* fdwFlags */                 // 4\n\t\t\t\tOUTSHRT(nBlockAlign);                  /* nBlockSize */               // 2\n\t\t\t\tOUTSHRT(1);                            /* nFramesPerBlock */          // 2\n\t\t\t\tOUTSHRT(0);                            /* nCodecDelay */              // 2\n\n\t\t\t} else if (AVI->track[j].a_fmt == 0x55 && !AVI->track[j].a_vbr) {\n\n\t\t\t\tOUTLONG(30);                            /* # of bytes to follow */\n\t\t\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */\n\t\t\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n\t\t\t\t//ThOe/tibit\n\t\t\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);\n\t\t\t\tOUTSHRT(sampsize/4);                    /* BlockAlign */\n\t\t\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n\n\t\t\t\tOUTSHRT(12);                           /* cbSize */\n\t\t\t\tOUTSHRT(1);                            /* wID */\n\t\t\t\tOUTLONG(2);                            /* fdwFlags */\n\t\t\t\tOUTSHRT(nBlockAlign);                  /* nBlockSize */\n\t\t\t\tOUTSHRT(1);                            /* nFramesPerBlock */\n\t\t\t\tOUTSHRT(0);                            /* nCodecDelay */\n\n\t\t\t} else {\n\n\t\t\t\tOUTLONG(18);                   /* # of bytes to follow */\n\t\t\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */\n\t\t\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n\t\t\t\t//ThOe/tibit\n\t\t\t\tOUTLONG(avgbsec);  /* Avg bytes/sec */\n\t\t\t\tOUTSHRT(sampsize/4);                    /* BlockAlign */\n\t\t\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n\t\t\t\tOUTSHRT(0);                           /* cbSize */\n\n\t\t\t}\n\t\t}\n\t\tif (AVI->is_opendml) {\n\t\t\tu32 k;\n\n\t\t\tif (!AVI->track[j].audio_superindex) {\n\t\t\t\t// not initialized -> no index\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tOUT4CC(AVI->track[j].audio_superindex->fcc);    /* \"indx\" */\n\t\t\tOUTLONG(2+1+1+4+4+3*4 + AVI->track[j].audio_superindex->nEntriesInUse * (8+4+4));\n\t\t\tOUTSHRT(AVI->track[j].audio_superindex->wLongsPerEntry);\n\t\t\tOUTCHR(AVI->track[j].audio_superindex->bIndexSubType);\n\t\t\tOUTCHR(AVI->track[j].audio_superindex->bIndexType);\n\t\t\tOUTLONG(AVI->track[j].audio_superindex->nEntriesInUse);\n\t\t\tOUT4CC(AVI->track[j].audio_superindex->dwChunkId);\n\t\t\tOUTLONG(0);\n\t\t\tOUTLONG(0);\n\t\t\tOUTLONG(0);\n\n\t\t\tfor (k = 0; k < AVI->track[j].audio_superindex->nEntriesInUse; k++) {\n\t\t\t\tu32 r = (u32) ((AVI->track[j].audio_superindex->aIndex[k].qwOffset >> 32) & 0xffffffff);\n\t\t\t\tu32 s = (u32) ((AVI->track[j].audio_superindex->aIndex[k].qwOffset) & 0xffffffff);\n\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] AUD[%d] NrEntries %d/%ld (%c%c%c%c) |0x%llX|%ld|%ld| \\n\",  j, k,\n\t\t\t\t        AVI->track[j].audio_superindex->nEntriesInUse,\n\t\t\t\t    AVI->track[j].audio_superindex->dwChunkId[0], AVI->track[j].audio_superindex->dwChunkId[1],\n\t\t\t\t    AVI->track[j].audio_superindex->dwChunkId[2], AVI->track[j].audio_superindex->dwChunkId[3],\n\t\t\t\t    AVI->track[j].audio_superindex->aIndex[k].qwOffset,\n\t\t\t\t    AVI->track[j].audio_superindex->aIndex[k].dwSize,\n\t\t\t\t    AVI->track[j].audio_superindex->aIndex[k].dwDuration\n\t\t\t\t  ));\n\t\t\t\t  */\n\n\t\t\t\tOUTLONG(s);\n\t\t\t\tOUTLONG(r);\n\t\t\t\tOUTLONG(AVI->track[j].audio_superindex->aIndex[k].dwSize);\n\t\t\t\tOUTLONG(AVI->track[j].audio_superindex->aIndex[k].dwDuration);\n\t\t\t}\n\t\t}\n\t\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\t\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\t}\n\n\tif (AVI->is_opendml) {\n\t\tOUT4CC(\"LIST\");\n\t\tOUTLONG(16);\n\t\tOUT4CC(\"odml\");\n\t\tOUT4CC(\"dmlh\");\n\t\tOUTLONG(4);\n\t\tOUTLONG(AVI->total_frames);\n\t}\n\n\t/* Finish header list */\n\n\tlong2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n\n\n\t// add INFO list --- (0.6.0pre4)\n\n#ifdef INFO_LIST\n\tOUT4CC (\"LIST\");\n\n\tinfo_start_pos = nhb;\n\tinfo_len = MAX_INFO_STRLEN + 12;\n\tOUTLONG(info_len); // rewritten later\n\tOUT4CC (\"INFO\");\n\n\tOUT4CC (\"ISFT\");\n\t//OUTLONG(MAX_INFO_STRLEN);\n\tmemset(id_str, 0, MAX_INFO_STRLEN);\n\tif (gf_sys_is_test_mode()) {\n\t\tsnprintf(id_str, MAX_INFO_STRLEN, \"GPAC/avilib\");\n\t} else {\n\t\tsnprintf(id_str, MAX_INFO_STRLEN, \"GPAC/avilib-%s\", gf_gpac_version());\n\t}\n\treal_id_len = id_len = (u32) strlen(id_str)+1;\n\tif (id_len&1) id_len++;\n\n\tOUTLONG(real_id_len);\n\n\tmemset(AVI_header+nhb, 0, id_len);\n\tmemcpy(AVI_header+nhb, id_str, id_len);\n\tnhb += id_len;\n\n\tinfo_len = 0;\n\n\t// write correct len\n\tlong2str(AVI_header+info_start_pos, info_len + id_len + 4+4+4);\n\n\tnhb += info_len;\n\n//   OUT4CC (\"ICMT\");\n//   OUTLONG(MAX_INFO_STRLEN);\n\n//   calptr=time(NULL);\n//   sprintf(id_str, \"\\t%s %s\", ctime(&calptr), \"\");\n//   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n//   memcpy(AVI_header+nhb, id_str, 25);\n//   nhb += MAX_INFO_STRLEN;\n#endif\n\n\t// ----------------------------\n\n\t/* Calculate the needed amount of junk bytes, output junk */\n\n\tnjunk = HEADERBYTES - nhb - 8 - 12;\n\n\t/* Safety first: if njunk <= 0, somebody has played with\n\t   HEADERBYTES without knowing what (s)he did.\n\t   This is a fatal error */\n\n\tif(njunk<=0)\n\t{\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVI_close_output_file: # of header bytes too small\\n\"));\n\t\texit(1);\n\t}\n\n\tOUT4CC (\"JUNK\");\n\tOUTLONG(njunk);\n\tmemset(AVI_header+nhb,0,njunk);\n\n\tnhb += njunk;\n\n\t/* Start the movi list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(movi_len); /* Length of list in bytes */\n\tOUT4CC (\"movi\");\n\n\t/* Output the header, truncate the file to the number of bytes\n\t   actually written, report an error if someting goes wrong */\n\n\tif ( (gf_fseek(AVI->fdes,0,SEEK_SET)==(u64)-1) ||\n\t        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES\n//\t\t|| ftruncate(AVI->fdes,AVI->pos)<0\n\t   )\n\t{\n\t\tAVI_errno = AVI_ERR_CLOSE;\n\t\treturn -1;\n\t}\n\n\n\t// Fix up the empty additional RIFF and LIST chunks\n\tif (AVI->is_opendml) {\n\t\tu32 k;\n\t\tchar f[4];\n\t\tu32 len;\n\n\t\tfor (k=1; k<AVI->video_superindex->nEntriesInUse; k++) {\n\t\t\t// the len of the RIFF Chunk\n\t\t\tgf_fseek(AVI->fdes, AVI->video_superindex->stdindex[k]->qwBaseOffset+4, SEEK_SET);\n\t\t\tlen = (u32) (AVI->video_superindex->stdindex[k+1]->qwBaseOffset - AVI->video_superindex->stdindex[k]->qwBaseOffset - 8);\n\t\t\tlong2str((unsigned char *)f, len);\n\t\t\tavi_write(AVI->fdes, f, 4);\n\n\t\t\t// len of the LIST/movi chunk\n\t\t\tgf_fseek(AVI->fdes, 8, SEEK_CUR);\n\t\t\tlen -= 12;\n\t\t\tlong2str((unsigned char *)f, len);\n\t\t\tavi_write(AVI->fdes, f, 4);\n\t\t}\n\t}\n\n\n\tif(idxerror) return -1;\n\n\treturn 0;\n}\n\n/*\n   AVI_write_data:\n   Add video or audio data to the file;\n\n   Return values:\n    0    No error;\n   -1    Error, AVI_errno is set appropriatly;\n\n*/\n\nstatic int avi_write_data(avi_t *AVI, char *data, unsigned int length, int audio, int keyframe)\n{\n\tint n = 0;\n\n\tunsigned char astr[5];\n\n\t// transcode core itself checks for the size -- unneeded and\n\t// does harm to xvid 2pass encodes where the first pass can get\n\t// _very_ large -- tibit.\n\n#if 0\n\t/* Check for maximum file length */\n\n\tif ( (AVI->pos + 8 + length + 8 + (AVI->n_idx+1)*16) > AVI_MAX_LEN ) {\n\t\tAVI_errno = AVI_ERR_SIZELIM;\n\t\treturn -1;\n\t}\n#endif\n\n\t/* Add index entry */\n\n\t//set tag for current audio track\n\tsprintf((char *)astr, \"0%1dwb\", (int)(AVI->aptr+1));\n\n\tif(audio) {\n\t\tif (!AVI->is_opendml) n = avi_add_index_entry(AVI,astr,0x10,AVI->pos,length);\n\t\tn += avi_add_odml_index_entry(AVI,astr,0x10,AVI->pos,length);\n\t} else {\n\t\tif (!AVI->is_opendml) n = avi_add_index_entry(AVI,(unsigned char *)\"00db\",((keyframe)?0x10:0x0),AVI->pos,length);\n\t\tn += avi_add_odml_index_entry(AVI,(unsigned char *)\"00db\",((keyframe)?0x10:0x0),AVI->pos,length);\n\t}\n\n\tif(n) return -1;\n\n\t/* Output tag and data */\n\n\tif(audio)\n\t\tn = avi_add_chunk(AVI,(unsigned char *)astr, (unsigned char *)data, length);\n\telse\n\t\tn = avi_add_chunk(AVI,(unsigned char *)\"00db\", (unsigned char *)data, length);\n\n\tif (n) return -1;\n\n\treturn 0;\n}\n\nGF_EXPORT\nint AVI_write_frame(avi_t *AVI, u8 *data, int bytes, int keyframe)\n{\n\ts64 pos;\n\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tpos = AVI->pos;\n\n\tif(avi_write_data(AVI,data,bytes,0,keyframe)) return -1;\n\n\tAVI->last_pos = pos;\n\tAVI->last_len = bytes;\n\tAVI->video_frames++;\n\treturn 0;\n}\n\n#if 0 //unused\nint AVI_dup_frame(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tif(AVI->last_pos==0) return 0; /* No previous real frame */\n\tif(avi_add_index_entry(AVI,(unsigned char *)\"00db\",0x10,AVI->last_pos,AVI->last_len)) return -1;\n\tAVI->video_frames++;\n\tAVI->must_use_index = 1;\n\treturn 0;\n}\n#endif\n\nGF_EXPORT\nint AVI_write_audio(avi_t *AVI, u8 *data, int bytes)\n{\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tif( avi_write_data(AVI,data,bytes,1,0) ) return -1;\n\tAVI->track[AVI->aptr].audio_bytes += bytes;\n\tAVI->track[AVI->aptr].audio_chunks++;\n\treturn 0;\n}\n\n#if 0 //unused\n\nint AVI_append_audio(avi_t *AVI, u8 *data, int bytes)\n{\n\n\t// won't work for >2gb\n\tint i, length, pos;\n\tunsigned char c[4];\n\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\t// update last index entry:\n\n\t--AVI->n_idx;\n\tlength = str2ulong(AVI->idx[AVI->n_idx]+12);\n\tpos    = str2ulong(AVI->idx[AVI->n_idx]+8);\n\n\t//update;\n\tlong2str(AVI->idx[AVI->n_idx]+12,length+bytes);\n\n\t++AVI->n_idx;\n\n\tAVI->track[AVI->aptr].audio_bytes += bytes;\n\n\t//update chunk header\n\tgf_fseek(AVI->fdes, pos+4, SEEK_SET);\n\tlong2str(c, length+bytes);\n\tavi_write(AVI->fdes, (char *)c, 4);\n\n\tgf_fseek(AVI->fdes, pos+8+length, SEEK_SET);\n\n\ti=PAD_EVEN(length + bytes);\n\n\tbytes = i - length;\n\tavi_write(AVI->fdes, data, bytes);\n\tAVI->pos = pos + 8 + i;\n\n\treturn 0;\n}\n\nu64 AVI_bytes_remain(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_READ) return 0;\n\n\treturn ( AVI_MAX_LEN - (AVI->pos + 8 + 16*AVI->n_idx));\n}\n\nu64 AVI_bytes_written(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_READ) return 0;\n\n\treturn (AVI->pos + 8 + 16*AVI->n_idx);\n}\n#endif\n\nint AVI_set_audio_track(avi_t *AVI, u32 track)\n{\n\n\tif (track + 1 > AVI->anum) return(-1);\n\n\t//this info is not written to file anyway\n\tAVI->aptr=track;\n\treturn 0;\n}\n\nint AVI_get_audio_track(avi_t *AVI)\n{\n\treturn(AVI->aptr);\n}\n\n#if 0 //unused\nvoid AVI_set_audio_vbr(avi_t *AVI, int is_vbr)\n{\n\tAVI->track[AVI->aptr].a_vbr = is_vbr;\n}\n\nint AVI_get_audio_vbr(avi_t *AVI)\n{\n\treturn(AVI->track[AVI->aptr].a_vbr);\n}\n#endif\n\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for reading video and audio from an AVI File       *\n *                                                                 *\n *******************************************************************/\n\nGF_EXPORT\nint AVI_close(avi_t *AVI)\n{\n\tint ret;\n\tu32 j;\n\n\t/* If the file was open for writing, the header and index still have\n\t   to be written */\n\n\tif(AVI->mode == AVI_MODE_WRITE)\n\t\tret = avi_close_output_file(AVI);\n\telse\n\t\tret = 0;\n\n\t/* Even if there happened an error, we first clean up */\n\n\tgf_fclose(AVI->fdes);\n\tif(AVI->idx) gf_free(AVI->idx);\n\tif(AVI->video_index) gf_free(AVI->video_index);\n\tif(AVI->video_superindex) {\n\t\tif(AVI->video_superindex->aIndex) gf_free(AVI->video_superindex->aIndex);\n\t\tif (AVI->video_superindex->stdindex) {\n\t\t\tfor (j=0; j < NR_IXNN_CHUNKS; j++) {\n\t\t\t\tif (AVI->video_superindex->stdindex[j]->aIndex)\n\t\t\t\t\tgf_free(AVI->video_superindex->stdindex[j]->aIndex);\n\t\t\t\tgf_free(AVI->video_superindex->stdindex[j]);\n\t\t\t}\n\t\t\tgf_free(AVI->video_superindex->stdindex);\n\t\t}\n\t\tgf_free(AVI->video_superindex);\n\t}\n\n\tfor (j=0; j<AVI->anum; j++)\n\t{\n\t\tif(AVI->track[j].audio_index) gf_free(AVI->track[j].audio_index);\n\t\tif(AVI->track[j].audio_superindex) {\n\t\t\tavisuperindex_chunk *asi = AVI->track[j].audio_superindex;\n\t\t\tif (asi->aIndex) gf_free(asi->aIndex);\n\n\t\t\tif (asi->stdindex) {\n\t\t\t\tfor (j=0; j < NR_IXNN_CHUNKS; j++) {\n\t\t\t\t\tif (asi->stdindex[j]->aIndex)\n\t\t\t\t\t\tgf_free(asi->stdindex[j]->aIndex);\n\t\t\t\t\tgf_free(asi->stdindex[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(asi->stdindex);\n\t\t\t}\n\t\t\tgf_free(asi);\n\t\t}\n\t}\n\n\tif (AVI->bitmap_info_header)\n\t\tgf_free(AVI->bitmap_info_header);\n\tfor (j = 0; j < AVI->anum; j++)\n\t\tif (AVI->wave_format_ex[j])\n\t\t\tgf_free(AVI->wave_format_ex[j]);\n\tif (AVI->extradata)\n\t\tgf_free(AVI->extradata);\n\n\tgf_free(AVI);\n\treturn ret;\n}\n\n\n#define ERR_EXIT(x) \\\n{ \\\n   AVI_close(AVI); \\\n   AVI_errno = x; \\\n   return 0; \\\n}\n\n\navi_t *AVI_open_input_file(char *filename, int getIndex)\n{\n\tavi_t *AVI;\n\n\t/* Create avi_t structure */\n\n\tAVI = (avi_t *) gf_malloc(sizeof(avi_t));\n\tif(AVI==NULL)\n\t{\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn 0;\n\t}\n\tmemset((void *)AVI,0,sizeof(avi_t));\n\n\tAVI->mode = AVI_MODE_READ; /* open for reading */\n\n\t/* Open the file */\n\n\tAVI->fdes = gf_fopen(filename,\"rb\");\n\tif(!AVI->fdes )\n\t{\n\t\tAVI_errno = AVI_ERR_OPEN;\n\t\tgf_free(AVI);\n\t\treturn 0;\n\t}\n\n\tAVI_errno = 0;\n\tavi_parse_input_file(AVI, getIndex);\n\n\tif (AVI != NULL && !AVI_errno) {\n\t\tAVI->aptr=0; //reset\n\t}\n\n\tif (AVI_errno) return NULL;\n\n\treturn AVI;\n}\n\n#if 0\navi_t *AVI_open_fd(FILE *fd, int getIndex)\n{\n\tavi_t *AVI=NULL;\n\n\t/* Create avi_t structure */\n\n\tAVI = (avi_t *) gf_malloc(sizeof(avi_t));\n\tif(AVI==NULL)\n\t{\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn 0;\n\t}\n\tmemset((void *)AVI,0,sizeof(avi_t));\n\n\tAVI->mode = AVI_MODE_READ; /* open for reading */\n\n\t// file alread open\n\tAVI->fdes = fd;\n\n\tAVI_errno = 0;\n\tavi_parse_input_file(AVI, getIndex);\n\n\tif (AVI != NULL && !AVI_errno) {\n\t\tAVI->aptr=0; //reset\n\t}\n\n\tif (AVI_errno)\n\t\treturn AVI=NULL;\n\telse\n\t\treturn AVI;\n}\n#endif\n\nint avi_parse_input_file(avi_t *AVI, int getIndex)\n{\n\tint i, rate, scale, idx_type;\n\ts64 n;\n\tunsigned char *hdrl_data;\n\tu64 header_offset=0;\n\tint hdrl_len=0;\n\tint nvi, nai[AVI_MAX_TRACKS], ioff;\n\tu64 tot[AVI_MAX_TRACKS];\n\tu32 j;\n\tint lasttag = 0;\n\tint vids_strh_seen = 0;\n\tint vids_strf_seen = 0;\n\tint auds_strh_seen = 0;\n\t//  int auds_strf_seen = 0;\n\tint num_stream = 0;\n\tchar data[256];\n\ts64 oldpos=-1, newpos=-1;\n\n\tint aud_chunks = 0;\n\tif (!AVI) {\n\t   AVI_errno = AVI_ERR_OPEN;\n\t   return 0;\n\t}\n\n\t/* Read first 12 bytes and check that this is an AVI file */\n\tif (avi_read(AVI->fdes,data,12) != 12 )\n\t\tERR_EXIT(AVI_ERR_READ)\n\n\tif (strnicmp(data  ,\"RIFF\",4) !=0 || strnicmp(data+8,\"AVI \",4) !=0 )\n\t\tERR_EXIT(AVI_ERR_NO_AVI)\n\n\t/* Go through the AVI file and extract the header list,\n\t   the start position of the 'movi' list and an optionally\n\t   present idx1 tag */\n\n\thdrl_data = 0;\n\n\twhile(1)\n\t{\n\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break; /* We assume it's EOF */\n\t\tnewpos = gf_ftell(AVI->fdes);\n\t\tif(oldpos==newpos) {\n\t\t\t/* This is a broken AVI stream... */\n\t\t\treturn -1;\n\t\t}\n\t\toldpos=newpos;\n\n\t\tn = str2ulong((unsigned char *)data+4);\n\t\tn = PAD_EVEN(n);\n\n\t\tif(strnicmp(data,\"LIST\",4) == 0)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\tn -= 4;\n\t\t\tif(strnicmp(data,\"hdrl\",4) == 0)\n\t\t\t{\n\t\t\t\thdrl_len = (u32) n;\n\t\t\t\thdrl_data = (unsigned char *) gf_malloc((u32)n);\n\t\t\t\tif(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\t\t\t// offset of header\n\n\t\t\t\theader_offset = gf_ftell(AVI->fdes);\n\n\t\t\t\tif( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t}\n\t\t\telse if(strnicmp(data,\"movi\",4) == 0)\n\t\t\t{\n\t\t\t\tAVI->movi_start = gf_ftell(AVI->fdes);\n\t\t\t\tif (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t\t}\n\t\t\telse if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t}\n\t\telse if(strnicmp(data,\"idx1\",4) == 0)\n\t\t{\n\t\t\t/* n must be a multiple of 16, but the reading does not\n\t\t\t   break if this is not the case */\n\n\t\t\tAVI->n_idx = AVI->max_idx = (u32) (n/16);\n\t\t\tAVI->idx = (unsigned  char((*)[16]) ) gf_malloc((u32)n);\n\t\t\tif(AVI->idx==0) ERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t\tif(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {\n\t\t\t\t\tgf_free( AVI->idx);\n\t\t\t\t\tAVI->idx=NULL;\n\t\t\t\t\tAVI->n_idx = 0;\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t}\n\n\tif(!hdrl_data      ) ERR_EXIT(AVI_ERR_NO_HDRL)\n\t\tif(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)\n\n\t\t\t/* Interpret the header list */\n\n\t\t\tfor(i=0; i<hdrl_len;)\n\t\t\t{\n\t\t\t\t/* List tags are completly ignored */\n\n#ifdef DEBUG_ODML\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"LIST\",4)==0) {\n\t\t\t\t\ti+= 12;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tn = str2ulong(hdrl_data+i+4);\n\t\t\t\tn = PAD_EVEN(n);\n\n\n\t\t\t\t/* Interpret the tag and its args */\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"strh\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG   %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\t\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"vids\",4) == 0 && !vids_strh_seen)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(AVI->compressor,hdrl_data+i+4,4);\n\t\t\t\t\t\tAVI->compressor[4] = 0;\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->v_codech_off = header_offset + i+4;\n\n\t\t\t\t\t\tscale = str2ulong(hdrl_data+i+20);\n\t\t\t\t\t\trate  = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tif(scale!=0) AVI->fps = (double)rate/(double)scale;\n\t\t\t\t\t\tAVI->video_frames = str2ulong(hdrl_data+i+32);\n\t\t\t\t\t\tAVI->video_strn = num_stream;\n\t\t\t\t\t\tAVI->max_len = 0;\n\t\t\t\t\t\tvids_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 1; /* vids */\n\t\t\t\t\t\tmemcpy(&AVI->video_stream_header, hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char *)hdrl_data+i,\"auds\",4) ==0 && ! auds_strh_seen)\n\t\t\t\t\t{\n\n\t\t\t\t\t\t//inc audio tracks\n\t\t\t\t\t\tAVI->aptr=AVI->anum;\n\t\t\t\t\t\t++AVI->anum;\n\n\t\t\t\t\t\tif(AVI->anum > AVI_MAX_TRACKS) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));\n\t\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_strn = num_stream;\n\n\t\t\t\t\t\t// if samplesize==0 -> vbr\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_vbr = !str2ulong(hdrl_data+i+44);\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].padrate = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tmemcpy(&AVI->stream_headers[AVI->aptr], hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\n\t\t\t\t\t\t//\t   auds_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 2; /* auds */\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codech_off = header_offset + i;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char*)hdrl_data+i,\"iavs\",4) ==0 && ! auds_strh_seen) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVILIB: error - DV AVI Type 1 no supported\\n\"));\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlasttag = 0;\n\t\t\t\t\tnum_stream++;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"dmlh\",4) == 0) {\n\t\t\t\t\tAVI->total_frames = str2ulong(hdrl_data+i+8);\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] real number of frames %d\\n\", AVI->total_frames));\n#endif\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *)\n\t\t\t\t\t\t                          gf_malloc(str2ulong((unsigned char *)&bih.bi_size));\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i,\n\t\t\t\t\t\t\t       str2ulong((unsigned char *)&bih.bi_size));\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->v_codecf_off = header_offset + i+16;\n\n\t\t\t\t\t\tmemcpy(AVI->compressor2, hdrl_data+i+16, 4);\n\t\t\t\t\t\tAVI->compressor2[4] = 0;\n\n\t\t\t\t\t\tif (n>40) {\n\t\t\t\t\t\t\tAVI->extradata_size = (u32) (n - 40);\n\t\t\t\t\t\t\tAVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);\n\t\t\t\t\t\t\tmemcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\talWAVEFORMATEX *wfe;\n\t\t\t\t\t\tchar *nwfe;\n\t\t\t\t\t\tint wfes;\n\n\t\t\t\t\t\tif ((u32) (hdrl_len - i) < sizeof(alWAVEFORMATEX))\n\t\t\t\t\t\t\twfes = hdrl_len - i;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twfes = sizeof(alWAVEFORMATEX);\n\t\t\t\t\t\twfe = (alWAVEFORMATEX *)gf_malloc(sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\tif (wfe != NULL) {\n\t\t\t\t\t\t\tmemset(wfe, 0, sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\t\tmemcpy(wfe, hdrl_data + i, wfes);\n\t\t\t\t\t\t\tif (str2ushort((unsigned char *)&wfe->cb_size) != 0) {\n\t\t\t\t\t\t\t\tnwfe = (char *)\n\t\t\t\t\t\t\t\t       gf_realloc(wfe, sizeof(alWAVEFORMATEX) +\n\t\t\t\t\t\t\t\t                  str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\tif (nwfe != 0) {\n\t\t\t\t\t\t\t\t\ts64 lpos = gf_ftell(AVI->fdes);\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, header_offset + i + sizeof(alWAVEFORMATEX),\n\t\t\t\t\t\t\t\t\t         SEEK_SET);\n\t\t\t\t\t\t\t\t\twfe = (alWAVEFORMATEX *)nwfe;\n\t\t\t\t\t\t\t\t\tnwfe = &nwfe[sizeof(alWAVEFORMATEX)];\n\t\t\t\t\t\t\t\t\tavi_read(AVI->fdes, nwfe,\n\t\t\t\t\t\t\t\t\t         str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, lpos, SEEK_SET);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tAVI->wave_format_ex[AVI->aptr] = wfe;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );\n\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codecf_off = header_offset + i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);\n\t\t\t\t\t\t//ThOe: read mp3bitrate\n\t\t\t\t\t\tAVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;\n\t\t\t\t\t\t//:ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n\t\t\t\t\t\t//            auds_strf_seen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) // V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->dwSize = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->video_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->nEntriesInUse = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->video_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->fcc[0], AVI->video_superindex->fcc[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->fcc[2], AVI->video_superindex->fcc[3]));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->video_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->video_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->video_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));\n#endif\n\n\t\t\t\t\t\tAVI->is_opendml = 1;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) // A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->nEntriesInUse = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->stdindex = NULL;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->fcc));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->dwChunkId[0]));\n#endif\n\n\t\t\t\t\t}\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if((strnicmp((char*)hdrl_data+i,\"JUNK\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"strn\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"vprp\",4) == 0)) {\n\t\t\t\t\ti += 8;\n\t\t\t\t\t// do not reset lasttag\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tlasttag = 0;\n\t\t\t\t}\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] adding %ld bytes\\n\", (int int)n));\n\n\t\t\t\ti += (u32) n;\n\t\t\t}\n\n\tgf_free(hdrl_data);\n\n\tif(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\tAVI->video_tag[0] = AVI->video_strn/10 + '0';\n\tAVI->video_tag[1] = AVI->video_strn%10 + '0';\n\tAVI->video_tag[2] = 'd';\n\tAVI->video_tag[3] = 'b';\n\n\t/* Audio tag is set to \"99wb\" if no audio present */\n\tif(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;\n\n\t{\n\t\tint tk=0;\n\t\tfor(j=0; j<AVI->anum+1; ++j) {\n\t\t\tif (j == AVI->video_strn) continue;\n\t\t\tAVI->track[tk].audio_tag[0] = j/10 + '0';\n\t\t\tAVI->track[tk].audio_tag[1] = j%10 + '0';\n\t\t\tAVI->track[tk].audio_tag[2] = 'w';\n\t\t\tAVI->track[tk].audio_tag[3] = 'b';\n\t\t\t++tk;\n\t\t}\n\t}\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\n\tif(!getIndex) return(0);\n\n\t/* if the file has an idx1, check if this is relative\n\t   to the start of the file or to the start of the movi list */\n\n\tidx_type = 0;\n\n\tif(AVI->idx)\n\t{\n\t\ts64 pos, len;\n\n\t\t/* Search the first videoframe in the idx1 and look where\n\t\t   it is in the file */\n\n\t\tfor(i=0; i<AVI->n_idx; i++)\n\t\t\tif( strnicmp((char *)AVI->idx[i],(char *)AVI->video_tag,3)==0 ) break;\n\t\tif(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\t\tpos = str2ulong(AVI->idx[i]+ 8);\n\t\tlen = str2ulong(AVI->idx[i]+12);\n\n\t\tgf_fseek(AVI->fdes,pos,SEEK_SET);\n\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t{\n\t\t\t\tidx_type = 1; /* Index from start of file */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);\n\t\t\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t\t\t{\n\t\t\t\t\t\tidx_type = 2; /* Index from start of movi list */\n\t\t\t\t\t}\n\t\t\t}\n\t\t/* idx_type remains 0 if neither of the two tests above succeeds */\n\t}\n\n\n\tif(idx_type == 0 && !AVI->is_opendml && !AVI->total_frames)\n\t{\n\t\t/* we must search through the file to get the index */\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\t\t\t/* The movi list may contain sub-lists, ignore them */\n\n\t\t\tif(strnicmp(data,\"LIST\",4)==0)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,4,SEEK_CUR);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\tif( ( (data[2]=='d' || data[2]=='D') &&\n\t\t\t        (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )\n\t\t\t        || ( (data[2]=='w' || data[2]=='W') &&\n\t\t\t             (data[3]=='b' || data[3]=='B') ) )\n\t\t\t{\n\t\t\t\tu64 __pos = gf_ftell(AVI->fdes) - 8;\n\t\t\t\tavi_add_index_entry(AVI,(unsigned char *)data,0,__pos,n);\n\t\t\t}\n\n\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t}\n\t\tidx_type = 1;\n\t}\n\n\t// ************************\n\t// OPENDML\n\t// ************************\n\n\t// read extended index chunks\n\tif (AVI->is_opendml) {\n\t\tu64 offset = 0;\n\t\thdrl_len = 4+4+2+1+1+4+4+8+4;\n\t\tchar *en, *chunk_start;\n\t\tint k = 0;\n\t\tu32 audtr = 0;\n\t\tu32 nrEntries = 0;\n\n\t\tAVI->video_index = NULL;\n\n\t\tnvi = 0;\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\t\t\tnai[audtr] = 0;\n\t\t\ttot[audtr] = 0;\n\t\t}\n\n\t\t// ************************\n\t\t// VIDEO\n\t\t// ************************\n\n\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; j++) {\n\n\t\t\t// read from file\n\t\t\tchunk_start = en = (char*) gf_malloc ((u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) );\n\n\t\t\tif (gf_fseek(AVI->fdes, AVI->video_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) ) <= 0) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n#ifdef DEBUG_ODML\n\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:0] Video nrEntries %ld\\n\", j, nrEntries));\n#endif\n\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t// skip header\n\t\t\ten += hdrl_len;\n\t\t\tnvi += nrEntries;\n\t\t\tAVI->video_index = (video_index_entry *) gf_realloc (AVI->video_index, nvi * sizeof (video_index_entry));\n\t\t\tif (!AVI->video_index) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] out of mem (size = %ld)\\n\", nvi * sizeof (video_index_entry)));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\twhile (k < nvi) {\n\n\t\t\t\tAVI->video_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\ten += 4;\n\t\t\t\tAVI->video_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\tAVI->video_index[k].key = str2ulong_key((unsigned char*)en);\n\t\t\t\ten += 4;\n\n\t\t\t\t// completely empty chunk\n\t\t\t\tif (AVI->video_index[k].pos-offset == 0 && AVI->video_index[k].len == 0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tnvi--;\n\t\t\t\t}\n\n#ifdef DEBUG_ODML\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] POS 0x%llX len=%d key=%s offset (%llx) (%ld)\\n\", k,\n\t\t\t\t  AVI->video_index[k].pos,\n\t\t\t\t  (int)AVI->video_index[k].len,\n\t\t\t\t  AVI->video_index[k].key?\"yes\":\"no \", offset,\n\t\t\t\t  AVI->video_superindex->aIndex[j].dwSize));\n\t\t\t\t  */\n#endif\n\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\tgf_free(chunk_start);\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\t// this should deal with broken 'rec ' odml files.\n\t\tif (AVI->video_frames == 0) {\n\t\t\tAVI->is_opendml=0;\n\t\t\tgoto multiple_riff;\n\t\t}\n\n\t\t// ************************\n\t\t// AUDIO\n\t\t// ************************\n\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\n\t\t\tk = 0;\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] (%s) cannot read audio index for track %d\\n\", __FILE__, audtr));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j=0; j<AVI->track[audtr].audio_superindex->nEntriesInUse; j++) {\n\n\t\t\t\t// read from file\n\t\t\t\tchunk_start = en = (char*)gf_malloc ((u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len));\n\n\t\t\t\tif (gf_fseek(AVI->fdes, AVI->track[audtr].audio_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len)) <= 0) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n\t\t\t\t//if (nrEntries > 50) nrEntries = 2; // XXX\n#ifdef DEBUG_ODML\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] Audio nrEntries %ld\\n\", j, audtr, nrEntries));\n#endif\n\t\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t\t// skip header\n\t\t\t\ten += hdrl_len;\n\t\t\t\tnai[audtr] += nrEntries;\n\t\t\t\tAVI->track[audtr].audio_index = (audio_index_entry *) gf_realloc (AVI->track[audtr].audio_index, nai[audtr] * sizeof (audio_index_entry));\n\n\t\t\t\twhile (k < nai[audtr]) {\n\n\t\t\t\t\tAVI->track[audtr].audio_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].tot = tot[audtr];\n\t\t\t\t\ttot[audtr] += AVI->track[audtr].audio_index[k].len;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t/*\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] POS 0x%llX len=%d offset (%llx) (%ld)\\n\", k, audtr,\n\t\t\t\t\t  AVI->track[audtr].audio_index[k].pos,\n\t\t\t\t\t  (int)AVI->track[audtr].audio_index[k].len,\n\t\t\t\t\t  offset, AVI->track[audtr].audio_superindex->aIndex[j].dwSize));\n\t\t\t\t\t  */\n#endif\n\n\t\t\t\t\t++k;\n\t\t\t\t}\n\n\t\t\t\tgf_free(chunk_start);\n\t\t\t}\n\n\t\t\tAVI->track[audtr].audio_chunks = nai[audtr];\n\t\t\tAVI->track[audtr].audio_bytes = tot[audtr];\n\t\t}\n\t} // is opendml\n\n\telse if (AVI->total_frames && !AVI->is_opendml && idx_type==0) {\n\n\t\t// *********************\n\t\t// MULTIPLE RIFF CHUNKS (and no index)\n\t\t// *********************\n\nmultiple_riff:\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Reconstructing index...\"));\n\n\t\t// Number of frames; only one audio track supported\n\t\tnvi = AVI->video_frames = AVI->total_frames;\n\t\tnai[0] = AVI->track[0].audio_chunks = AVI->total_frames;\n\t\tfor(j=1; j<AVI->anum; ++j) AVI->track[j].audio_chunks = 0;\n\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\taud_chunks = AVI->total_frames;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif (nvi >= AVI->total_frames) break;\n\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\n\t\t\tj=0;\n\n\t\t\tif (aud_chunks - nai[j] -1 <= 0) {\n\t\t\t\taud_chunks += AVI->total_frames;\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *)\n\t\t\t\t                            gf_realloc( AVI->track[j].audio_index, (aud_chunks+1)*sizeof(audio_index_entry));\n\t\t\t\tif (!AVI->track[j].audio_index) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib -- no mem\\n\"));\n\t\t\t\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\t// VIDEO\n\t\t\tif(\n\t\t\t    (data[0]=='0' || data[1]=='0') &&\n\t\t\t    (data[2]=='d' || data[2]=='D') &&\n\t\t\t    (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') ) {\n\n\t\t\t\tAVI->video_index[nvi].key = 0x0;\n\t\t\t\tAVI->video_index[nvi].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->video_index[nvi].len = (u32) n;\n\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Frame %ld pos %\"LLD\" len %\"LLD\" key %ld\\n\",\n\t\t\t\t    nvi, AVI->video_index[nvi].pos,  AVI->video_index[nvi].len, (long)AVI->video_index[nvi].key));\n\t\t\t\t    */\n\t\t\t\tnvi++;\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\n\t\t\t//AUDIO\n\t\t\telse if(\n\t\t\t    (data[0]=='0' || data[1]=='1') &&\n\t\t\t    (data[2]=='w' || data[2]=='W') &&\n\t\t\t    (data[3]=='b' || data[3]=='B') ) {\n\n\n\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->track[j].audio_index[nai[j]].len = (u32) n;\n\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\tnai[j]++;\n\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgf_fseek(AVI->fdes,-4,SEEK_CUR);\n\t\t\t}\n\n\t\t}\n\t\tif (nvi < AVI->total_frames) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[avilib] Uh? Some frames seems missing (%ld/%d)\\n\",\n\t\t\t        nvi,  AVI->total_frames));\n\t\t}\n\n\n\t\tAVI->video_frames = nvi;\n\t\tAVI->track[0].audio_chunks = nai[0];\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] done. nvi=%ld nai=%ld tot=%ld\\n\", nvi, nai[0], tot[0]));\n\n\t} // total_frames but no indx chunk (xawtv does this)\n\n\telse\n\n\t{\n\t\t// ******************\n\t\t// NO OPENDML\n\t\t// ******************\n\n\t\t/* Now generate the video index and audio index arrays */\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) nai[j] = 0;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) nvi++;\n\n\t\t\tfor(j=0; j<AVI->anum; ++j) if(strnicmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];\n\n\n\t\tif(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\tioff = idx_type == 1 ? 8 : (u32)AVI->movi_start+4;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\t//video\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) {\n\t\t\t\tAVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);\n\t\t\t\tAVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\tAVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\tnvi++;\n\t\t\t}\n\n\t\t\t//audio\n\t\t\tfor(j=0; j<AVI->anum; ++j) {\n\n\t\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\t\tnai[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\n\t} // is no opendml\n\n\t/* Reposition the file */\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\tAVI->video_pos = 0;\n\n\treturn(0);\n}\n\nint AVI_video_frames(avi_t *AVI)\n{\n\treturn AVI->video_frames;\n}\nint  AVI_video_width(avi_t *AVI)\n{\n\treturn AVI->width;\n}\nint  AVI_video_height(avi_t *AVI)\n{\n\treturn AVI->height;\n}\ndouble AVI_frame_rate(avi_t *AVI)\n{\n\treturn AVI->fps;\n}\nchar* AVI_video_compressor(avi_t *AVI)\n{\n\treturn AVI->compressor2;\n}\n\n#if 0\nint AVI_max_video_chunk(avi_t *AVI)\n{\n\treturn AVI->max_len;\n}\n#endif\n\nint AVI_audio_tracks(avi_t *AVI)\n{\n\treturn(AVI->anum);\n}\n\nint AVI_audio_channels(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_chans;\n}\n\nint AVI_audio_mp3rate(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].mp3rate;\n}\n\n#if 0 //unused\nint AVI_audio_padrate(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].padrate;\n}\n#endif\n\nint AVI_audio_bits(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_bits;\n}\n\nint AVI_audio_format(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_fmt;\n}\n\nint AVI_audio_rate(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_rate;\n}\n\n\nint AVI_frame_size(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(frame < 0 || frame >= AVI->video_frames) return 0;\n\treturn (u32) (AVI->video_index[frame].len);\n}\n\nint AVI_audio_size(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(frame < 0 || frame >= AVI->track[AVI->aptr].audio_chunks) return -1;\n\treturn (u32) (AVI->track[AVI->aptr].audio_index[frame].len);\n}\n\nu64 AVI_get_video_position(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn (u64) -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn (u64) -1;\n\t}\n\n\tif(frame < 0 || frame >= AVI->video_frames) return 0;\n\treturn(AVI->video_index[frame].pos);\n}\n\n\nint AVI_seek_start(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\tAVI->video_pos = 0;\n\treturn 0;\n}\n\nint AVI_set_video_position(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif (frame < 0 ) frame = 0;\n\tAVI->video_pos = frame;\n\treturn 0;\n}\n\n#if 0 //unused\nint AVI_set_audio_bitrate(avi_t *AVI, int bitrate)\n{\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tAVI->track[AVI->aptr].mp3rate = bitrate;\n\treturn 0;\n}\n#endif\n\nint AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe)\n{\n\tint n;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n\tn = (u32) AVI->video_index[AVI->video_pos].len;\n\n\t*keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\n\tif (vidbuf == NULL) {\n\t\tAVI->video_pos++;\n\t\treturn n;\n\t}\n\n\tgf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\n\tif (avi_read(AVI->fdes,vidbuf,n) != (u32) n)\n\t{\n\t\tAVI_errno = AVI_ERR_READ;\n\t\treturn -1;\n\t}\n\n\tAVI->video_pos++;\n\n\treturn n;\n}\n\n#if 0 //unused\nint AVI_get_audio_position_index(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index) {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\treturn (AVI->track[AVI->aptr].audio_posc);\n}\n\nint AVI_set_audio_position_index(avi_t *AVI, int indexpos)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tif(indexpos > AVI->track[AVI->aptr].audio_chunks)     {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tAVI->track[AVI->aptr].audio_posc = indexpos;\n\tAVI->track[AVI->aptr].audio_posb = 0;\n\n\treturn 0;\n}\n#endif\n\n\nint AVI_set_audio_position(avi_t *AVI, int byte)\n{\n\tint n0, n1;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(byte < 0) byte = 0;\n\n\t/* Binary search in the audio chunks */\n\n\tn0 = 0;\n\tn1 = AVI->track[AVI->aptr].audio_chunks;\n\n\twhile(n0<n1-1)\n\t{\n\t\tint n = (n0+n1)/2;\n\t\tif(AVI->track[AVI->aptr].audio_index[n].tot>(u32) byte)\n\t\t\tn1 = n;\n\t\telse\n\t\t\tn0 = n;\n\t}\n\n\tAVI->track[AVI->aptr].audio_posc = n0;\n\tAVI->track[AVI->aptr].audio_posb = (u32) (byte - AVI->track[AVI->aptr].audio_index[n0].tot);\n\n\treturn 0;\n}\n\n\nint AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous)\n{\n\tint nr, todo;\n\ts64 pos;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tnr = 0; /* total number of bytes read */\n\n\tif (bytes==0) {\n\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t}\n\n\t*continuous = 1;\n\twhile(bytes>0)\n\t{\n\t\ts64 ret;\n\t\tint left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb);\n\t\tif(left==0)\n\t\t{\n\t\t\tif(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n\t\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t\t\t*continuous = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(bytes<left)\n\t\t\ttodo = bytes;\n\t\telse\n\t\t\ttodo = left;\n\t\tpos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n\t\tgf_fseek(AVI->fdes, pos, SEEK_SET);\n\t\tif ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo)\n\t\t{\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] XXX pos = %\"LLD\", ret = %\"LLD\", todo = %ld\\n\", pos, ret, todo));\n\t\t\tAVI_errno = AVI_ERR_READ;\n\t\t\treturn -1;\n\t\t}\n\t\tbytes -= todo;\n\t\tnr    += todo;\n\t\tAVI->track[AVI->aptr].audio_posb += todo;\n\t}\n\n\treturn nr;\n}\n\n\n#if 0 //unused\n/* AVI_read_data: Special routine for reading the next audio or video chunk\n                  without having an index of the file. */\n\nint AVI_read_data(avi_t *AVI, char *vidbuf, int max_vidbuf,\n                  char *audbuf, int max_audbuf,\n                  int *len)\n{\n\n\t/*\n\t * Return codes:\n\t *\n\t *    1 = video data read\n\t *    2 = audio data read\n\t *    0 = reached EOF\n\t *   -1 = video buffer too small\n\t *   -2 = audio buffer too small\n\t */\n\n\ts64 n;\n\tchar data[8];\n\n\tif(AVI->mode==AVI_MODE_WRITE) return 0;\n\n\twhile(1)\n\t{\n\t\t/* Read tag and length */\n\n\t\tif( avi_read(AVI->fdes,data,8) != 8 ) return 0;\n\n\t\t/* if we got a list tag, ignore it */\n\n\t\tif(strnicmp(data,\"LIST\",4) == 0)\n\t\t{\n\t\t\tgf_fseek(AVI->fdes,4,SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = PAD_EVEN(str2ulong((unsigned char *)data+4));\n\n\t\tif(strnicmp(data,AVI->video_tag,3) == 0)\n\t\t{\n\t\t\t*len = (u32) n;\n\t\t\tAVI->video_pos++;\n\t\t\tif(n>max_vidbuf)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(avi_read(AVI->fdes,vidbuf, (u32) n) != n ) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\telse if(strnicmp(data,AVI->track[AVI->aptr].audio_tag,4) == 0)\n\t\t{\n\t\t\t*len = (u32) n;\n\t\t\tif(n>max_audbuf)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tif(avi_read(AVI->fdes,audbuf, (u32) n) != n ) return 0;\n\t\t\treturn 2;\n\t\t\tbreak;\n\t\t}\n\t\telse if(gf_fseek(AVI->fdes,n,SEEK_CUR) == (u64) -1)  return 0;\n\t}\n}\n\nu64 AVI_max_size(void)\n{\n\treturn((u64) AVI_MAX_LEN);\n}\n#endif\n\n\n#endif /*GPAC_DISABLE_AVILIB*/\n"], "fixing_code": ["/*\n *  avilib.c\n *\n *  Copyright (C) Thomas ostreich - June 2001\n *  multiple audio track support Copyright (C) 2002 Thomas ostreich\n *\n *  Original code:\n *  Copyright (C) 1999 Rainer Johanni <Rainer@Johanni.de>\n *\n *  This file is part of transcode, a linux video stream processing tool\n *\n *  transcode is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  transcode is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License aint with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/setup.h>\n\n#ifndef GPAC_DISABLE_AVILIB\n\n#include <gpac/internal/avilib.h>\n\n\n#define INFO_LIST\n\n// add a new riff chunk after XX MB\n#define NEW_RIFF_THRES (1900*1024*1024)\n\n// Maximum number of indices per stream\n#define NR_IXNN_CHUNKS 96\n\n\n#define DEBUG_ODML\n#undef DEBUG_ODML\n\n/* The following variable indicates the kind of error */\n\nint AVI_errno = 0;\n\n#define MAX_INFO_STRLEN 64\nstatic char id_str[MAX_INFO_STRLEN];\n\n#define FRAME_RATE_SCALE 1000000\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for writing an AVI File                            *\n *                                                                 *\n *******************************************************************/\n\nstatic u32 avi_read(FILE *fd, char *buf, u32 len)\n{\n\tu32 r = 0;\n\n\twhile (r < len) {\n\t\ts32 n = (s32) gf_fread(buf + r, len - r, fd);\n\t\tif (n == 0) break;\n\t\tif (n < 0) return r;\n\t\tr += n;\n\t}\n\n\treturn r;\n}\n\nstatic u32 avi_write (FILE *fd, char *buf, u32 len)\n{\n\tu32 r = 0;\n\n\twhile (r < len) {\n\t\ts32 n = (u32) gf_fwrite (buf + r, len - r, fd);\n\t\tif (n < 0)\n\t\t\treturn n;\n\n\t\tr += n;\n\t}\n\treturn r;\n}\n\n/* HEADERBYTES: The number of bytes to reserve for the header */\n\n#define HEADERBYTES 2048\n\n/* AVI_MAX_LEN: The maximum length of an AVI file, we stay a bit below\n    the 2GB limit (Remember: 2*10^9 is smaller than 2 GB) */\n\n#define AVI_MAX_LEN (UINT_MAX-(1<<20)*16-HEADERBYTES)\n\n#define PAD_EVEN(x) ( ((x)+1) & ~1 )\n\n\n/* Copy n into dst as a 4 or 2 byte, little endian number.\n   Should also work on big endian machines */\n\nstatic void long2str(unsigned char *dst, s32 n)\n{\n\tdst[0] = (n    )&0xff;\n\tdst[1] = (n>> 8)&0xff;\n\tdst[2] = (n>>16)&0xff;\n\tdst[3] = (n>>24)&0xff;\n}\n\n#ifdef WORDS_BIGENDIAN\nstatic void short2str(unsigned char *dst, s32 n)\n{\n\tdst[0] = (n    )&0xff;\n\tdst[1] = (n>> 8)&0xff;\n}\n#endif\n\n/* Convert a string of 4 or 2 bytes to a number,\n   also working on big endian machines */\n\nstatic u64 str2ullong(unsigned char *str)\n{\n\tu64 r = ((u32)str[0] | ((u32)str[1]<<8) | ((u32)str[2]<<16) | ((u32)str[3]<<24));\n\tu64 s = ((u32)str[4] | ((u32)str[5]<<8) | ((u32)str[6]<<16) | ((u32)str[7]<<24));\n#ifdef __GNUC__\n\treturn ((s<<32)&0xffffffff00000000ULL)|(r&0xffffffff);\n#else\n\treturn ((s<<32)&0xffffffff00000000)|(r&0xffffffff);\n#endif\n}\n\nstatic u32 str2ulong(unsigned char *str)\n{\n\treturn ( (u32)str[0] | ((u32)str[1]<<8) | ((u32)str[2]<<16) | ((u32)str[3]<<24) );\n}\nstatic u32 str2ushort(unsigned char *str)\n{\n\treturn ( (u32)str[0] | ((u32)str[1]<<8) );\n}\n\n// bit 31 denotes a keyframe\nstatic u32 str2ulong_len (unsigned char *str)\n{\n\treturn str2ulong(str) & 0x7fffffff;\n}\n\n\n// if bit 31 is 0, its a keyframe\nstatic u32 str2ulong_key (unsigned char *str)\n{\n\tu32 c = str2ulong(str);\n\tc &= 0x80000000;\n\tif (c == 0) return 0x10;\n\telse return 0;\n}\n\n/* Calculate audio sample size from number of bits and number of channels.\n   This may have to be adjusted for eg. 12 bits and stereo */\n\nstatic int avi_sampsize(avi_t *AVI, int j)\n{\n\tint s;\n\ts = ((AVI->track[j].a_bits+7)/8)*AVI->track[j].a_chans;\n\t//   if(s==0) s=1; /* avoid possible zero divisions */\n\tif(s<4) s=4; /* avoid possible zero divisions */\n\treturn s;\n}\n\n/* Add a chunk (=tag and data) to the AVI file,\n   returns -1 on write error, 0 on success */\n\nstatic int avi_add_chunk(avi_t *AVI, unsigned char *tag, unsigned char *data, u32 length)\n{\n\tunsigned char c[8];\n\tchar p=0;\n\n\t/* Copy tag and length int c, so that we need only 1 write system call\n\t   for these two values */\n\n\tmemcpy(c,tag,4);\n\tlong2str(c+4,length);\n\n\t/* Output tag, length and data, restore previous position\n\t   if the write fails */\n\n\tif( avi_write(AVI->fdes,(char *)c,8) != 8 ||\n\t        avi_write(AVI->fdes,(char *)data,length) != length ||\n\t        avi_write(AVI->fdes,&p,length&1) != (length&1)) // if len is uneven, write a pad byte\n\t{\n\t\tgf_fseek(AVI->fdes,AVI->pos,SEEK_SET);\n\t\tAVI_errno = AVI_ERR_WRITE;\n\t\treturn -1;\n\t}\n\n\t/* Update file position */\n\n\tAVI->pos += 8 + PAD_EVEN(length);\n\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] pos=%lu %s\\n\", AVI->pos, tag));\n\n\treturn 0;\n}\n\n#define OUTD(n) long2str((unsigned char*) (ix00+bl),(s32)n); bl+=4\n#define OUTW(n) ix00[bl] = (n)&0xff; ix00[bl+1] = (n>>8)&0xff; bl+=2\n#define OUTC(n) ix00[bl] = (n)&0xff; bl+=1\n#define OUTS(s) memcpy(ix00+bl,s,4); bl+=4\n\n// this does the physical writeout of the ix## structure\nstatic int avi_ixnn_entry(avi_t *AVI, avistdindex_chunk *ch, avisuperindex_entry *en)\n{\n\tint bl;\n\tu32 k;\n\tunsigned int max = ch->nEntriesInUse * sizeof (u32) * ch->wLongsPerEntry + 24; // header\n\tchar *ix00 = (char *)gf_malloc (max);\n\tchar dfcc[5];\n\tmemcpy (dfcc, ch->fcc, 4);\n\tdfcc[4] = 0;\n\n\tbl = 0;\n\n\tif (en) {\n\t\ten->qwOffset = AVI->pos;\n\t\ten->dwSize = max;\n\t\t//en->dwDuration = ch->nEntriesInUse -1; // NUMBER OF stream ticks == frames for video/samples for audio\n\t}\n\n#ifdef DEBUG_ODML\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML Write %s: Entries %ld size %d \\n\", dfcc, ch->nEntriesInUse, max));\n#endif\n\n\t//OUTS(ch->fcc);\n\t//OUTD(max);\n\tOUTW(ch->wLongsPerEntry);\n\tOUTC(ch->bIndexSubType);\n\tOUTC(ch->bIndexType);\n\tOUTD(ch->nEntriesInUse);\n\tOUTS(ch->dwChunkId);\n\tOUTD(ch->qwBaseOffset&0xffffffff);\n\tOUTD((ch->qwBaseOffset>>32)&0xffffffff);\n\tOUTD(ch->dwReserved3);\n\n\tfor (k = 0; k < ch->nEntriesInUse; k++) {\n\t\tOUTD(ch->aIndex[k].dwOffset);\n\t\tOUTD(ch->aIndex[k].dwSize);\n\n\t}\n\tavi_add_chunk (AVI, (unsigned char*)ch->fcc, (unsigned char*)ix00, max);\n\n\tgf_free(ix00);\n\n\treturn 0;\n}\n#undef OUTS\n#undef OUTW\n#undef OUTD\n#undef OUTC\n\n// inits a super index structure including its enclosed stdindex\nstatic int avi_init_super_index(avi_t *AVI, unsigned char *idxtag, avisuperindex_chunk **si)\n{\n\tint k;\n\n\tavisuperindex_chunk *sil = NULL;\n\n\tif ((sil = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk))) == NULL) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\tmemcpy (sil->fcc, \"indx\", 4);\n\tsil->dwSize = 0; // size of this chunk\n\tsil->wLongsPerEntry = 4;\n\tsil->bIndexSubType = 0;\n\tsil->bIndexType = AVI_INDEX_OF_INDEXES;\n\tsil->nEntriesInUse = 0; // none are in use\n\tmemcpy (sil->dwChunkId, idxtag, 4);\n\tmemset (sil->dwReserved, 0, sizeof (sil->dwReserved));\n\n\t// NR_IXNN_CHUNKS == allow 32 indices which means 32 GB files -- arbitrary\n\tsil->aIndex = (avisuperindex_entry *) gf_malloc (sil->wLongsPerEntry * NR_IXNN_CHUNKS * sizeof (void*));\n\tif (!sil->aIndex) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\tmemset (sil->aIndex, 0, sil->wLongsPerEntry * NR_IXNN_CHUNKS * sizeof (u32));\n\n\tsil->stdindex = (avistdindex_chunk **)gf_malloc (NR_IXNN_CHUNKS * sizeof (avistdindex_chunk *));\n\tif (!sil->stdindex) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NR_IXNN_CHUNKS; k++) {\n\t\tsil->stdindex[k] = (avistdindex_chunk *) gf_malloc (sizeof (avistdindex_chunk));\n\t\t// gets rewritten later\n\t\tsil->stdindex[k]->qwBaseOffset = (u64)k * AVI->new_riff_threshold;\n\t\tsil->stdindex[k]->aIndex = NULL;\n\t}\n\n\t*si = sil;\n\n\treturn 0;\n}\n\n// fills an alloc'ed stdindex structure and mallocs some entries for the actual chunks\nstatic int avi_add_std_index(avi_t *AVI, unsigned char *idxtag, unsigned char *strtag,\n                             avistdindex_chunk *stdil)\n{\n\n\tmemcpy (stdil->fcc, idxtag, 4);\n\tstdil->dwSize = 4096;\n\tstdil->wLongsPerEntry = 2; //sizeof(avistdindex_entry)/sizeof(u32);\n\tstdil->bIndexSubType = 0;\n\tstdil->bIndexType = AVI_INDEX_OF_CHUNKS;\n\tstdil->nEntriesInUse = 0;\n\n\t// cp 00db ChunkId\n\tmemcpy(stdil->dwChunkId, strtag, 4);\n\n\t//stdil->qwBaseOffset = AVI->video_superindex->aIndex[ cur_std_idx ]->qwOffset;\n\n\tstdil->aIndex = (avistdindex_entry *)gf_malloc(stdil->dwSize * sizeof (u32) * stdil->wLongsPerEntry);\n\n\tif (!stdil->aIndex) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\n\n\treturn 0;\n}\n\nstatic int avi_add_odml_index_entry_core(avi_t *AVI, int flags, u64 pos, unsigned int len, avistdindex_chunk *si)\n{\n\tu32 cur_chunk_idx;\n\t// put new chunk into index\n\tsi->nEntriesInUse++;\n\tcur_chunk_idx = si->nEntriesInUse-1;\n\n\t// need to fetch more memory\n\tif (cur_chunk_idx >= si->dwSize) {\n\t\tsi->dwSize += 4096;\n\t\tsi->aIndex = (avistdindex_entry *)gf_realloc ( si->aIndex, si->dwSize * sizeof (u32) * si->wLongsPerEntry);\n\t}\n\n\tif(len>AVI->max_len) AVI->max_len=len;\n\n\t// if bit 31 is set, it is NOT a keyframe\n\tif (flags != 0x10) {\n\t\tlen |= 0x80000000;\n\t}\n\n\tsi->aIndex [ cur_chunk_idx ].dwSize = len;\n\tsi->aIndex [ cur_chunk_idx ].dwOffset = (u32) (pos - si->qwBaseOffset + 8);\n\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: POS: 0x%lX\\n\", si->aIndex [ cur_chunk_idx ].dwOffset));\n\n\treturn 0;\n}\n\nstatic int avi_add_odml_index_entry(avi_t *AVI, unsigned char *tag, int flags, u64 pos, unsigned int len)\n{\n\tchar fcc[5];\n\n\tint audio = (strchr ((char*)tag, 'w')?1:0);\n\tint video = !audio;\n\n\tunsigned int cur_std_idx;\n\tu32 audtr;\n\ts64 towrite = 0;\n\n\tif (video) {\n\n\t\tif (!AVI->video_superindex) {\n\t\t\tif (avi_init_super_index(AVI, (unsigned char *)\"ix00\", &AVI->video_superindex) < 0) return -1;\n\t\t\tAVI->video_superindex->nEntriesInUse++;\n\t\t\tcur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\n\t\t\tif (avi_add_std_index (AVI, (unsigned char *)\"ix00\", (unsigned char *)\"00db\", AVI->video_superindex->stdindex[ cur_std_idx ]) < 0)\n\t\t\t\treturn -1;\n\t\t} // init\n\n\t} // video\n\n\tif (audio) {\n\n\t\tfcc[0] = 'i';\n\t\tfcc[1] = 'x';\n\t\tfcc[2] = tag[0];\n\t\tfcc[3] = tag[1];\n\t\tfcc[4] = '\\0';\n\t\tif (!AVI->track[AVI->aptr].audio_superindex) {\n\n#ifdef DEBUG_ODML\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: fcc = %s\\n\", fcc));\n#endif\n\t\t\tif (avi_init_super_index(AVI, (unsigned char *)fcc, &AVI->track[AVI->aptr].audio_superindex) < 0) return -1;\n\n\n\t\t\tAVI->track[AVI->aptr].audio_superindex->nEntriesInUse++;\n\n\t\t\tsprintf(fcc, \"ix%02d\", AVI->aptr+1);\n\t\t\tif (avi_add_std_index (AVI, (unsigned char *)fcc, tag, AVI->track[AVI->aptr].audio_superindex->stdindex[\n\t\t\t                           AVI->track[AVI->aptr].audio_superindex->nEntriesInUse - 1 ]) < 0\n\t\t\t   ) return -1;\n\t\t} // init\n\n\t}\n\n\ttowrite = 0;\n\tif (AVI->video_superindex) {\n\n\t\tcur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\t\ttowrite += AVI->video_superindex->stdindex[cur_std_idx]->nEntriesInUse*8\n\t\t           + 4+4+2+1+1+4+4+8+4;\n\t\tif (cur_std_idx == 0) {\n\t\t\ttowrite += AVI->n_idx*16 + 8;\n\t\t\ttowrite += HEADERBYTES;\n\t\t}\n\t}\n\n\tfor (audtr=0; audtr<AVI->anum; audtr++) {\n\t\tif (AVI->track[audtr].audio_superindex) {\n\t\t\tcur_std_idx = AVI->track[audtr].audio_superindex->nEntriesInUse-1;\n\t\t\ttowrite += AVI->track[audtr].audio_superindex->stdindex[cur_std_idx]->nEntriesInUse*8\n\t\t\t           + 4+4+2+1+1+4+4+8+4;\n\t\t}\n\t}\n\ttowrite += len + (len&1) + 8;\n\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: towrite = 0x%llX = %\"LLD\"\\n\", towrite, towrite));\n\n\tif (AVI->video_superindex &&\n\t        (s64)(AVI->pos+towrite) > (s64)((s64) AVI->new_riff_threshold*AVI->video_superindex->nEntriesInUse)) {\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Adding a new RIFF chunk: %d\\n\", AVI->video_superindex->nEntriesInUse));\n\n\t\t// rotate ALL indices\n\t\tAVI->video_superindex->nEntriesInUse++;\n\t\tcur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\n\t\tif (AVI->video_superindex->nEntriesInUse > NR_IXNN_CHUNKS) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib - redefine NR_IXNN_CHUNKS\\n\"));\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] cur_std_idx=%d NR_IXNN_CHUNKS=%d\"\n\t\t\t                                        \"POS=%\"LLD\" towrite=%\"LLD\"\\n\",\n\t\t\t                                        cur_std_idx,NR_IXNN_CHUNKS, AVI->pos, towrite));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (avi_add_std_index (AVI, (unsigned char *)\"ix00\", (unsigned char *)\"00db\", AVI->video_superindex->stdindex[ cur_std_idx ]) < 0)\n\t\t\treturn -1;\n\n\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\t\t\tchar aud[5];\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\t// not initialized -> no index\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAVI->track[audtr].audio_superindex->nEntriesInUse++;\n\n\t\t\tsprintf(fcc, \"ix%02d\", audtr+1);\n\t\t\tsprintf(aud, \"0%01dwb\", audtr+1);\n\t\t\tif (avi_add_std_index (AVI, (unsigned char *)fcc, (unsigned char *)aud, AVI->track[audtr].audio_superindex->stdindex[\n\t\t\t                           AVI->track[audtr].audio_superindex->nEntriesInUse - 1 ]) < 0\n\t\t\t   ) return -1;\n\t\t}\n\n\t\t// write the new riff;\n\t\tif (cur_std_idx > 0) {\n\n\t\t\t// dump the _previous_ == already finished index\n\t\t\tavi_ixnn_entry (AVI, AVI->video_superindex->stdindex[cur_std_idx - 1],\n\t\t\t                &AVI->video_superindex->aIndex[cur_std_idx - 1]);\n\t\t\tAVI->video_superindex->aIndex[cur_std_idx - 1].dwDuration =\n\t\t\t    AVI->video_superindex->stdindex[cur_std_idx - 1]->nEntriesInUse - 1;\n\n\t\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\n\t\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\t\t// not initialized -> no index\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tavi_ixnn_entry (AVI, AVI->track[audtr].audio_superindex->stdindex[cur_std_idx - 1],\n\t\t\t\t                &AVI->track[audtr].audio_superindex->aIndex[cur_std_idx - 1]);\n\n\t\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx - 1].dwDuration =\n\t\t\t\t    AVI->track[audtr].audio_superindex->stdindex[cur_std_idx - 1]->nEntriesInUse - 1;\n\t\t\t\tif (AVI->track[audtr].a_fmt == 0x1) {\n\t\t\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx - 1].dwDuration *=\n\t\t\t\t\t    AVI->track[audtr].a_bits*AVI->track[audtr].a_rate*AVI->track[audtr].a_chans/800;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// XXX: dump idx1 structure\n\t\t\tif (cur_std_idx == 1) {\n\t\t\t\tavi_add_chunk(AVI, (unsigned char *)\"idx1\", (unsigned char *)AVI->idx, AVI->n_idx*16);\n\t\t\t\t// qwBaseOffset will contain the start of the second riff chunk\n\t\t\t}\n\t\t\t// Fix the Offsets later at closing time\n\t\t\tavi_add_chunk(AVI, (unsigned char *)\"RIFF\", (unsigned char *)\"AVIXLIST\\0\\0\\0\\0movi\", 16);\n\n\t\t\tAVI->video_superindex->stdindex[ cur_std_idx ]->qwBaseOffset = AVI->pos -16 -8;\n#ifdef DEBUG_ODML\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: RIFF No.%02d at Offset 0x%llX\\n\", cur_std_idx, AVI->pos -16 -8));\n#endif\n\n\t\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\t\t\t\tif (AVI->track[audtr].audio_superindex)\n\t\t\t\t\tAVI->track[audtr].audio_superindex->stdindex[ cur_std_idx ]->qwBaseOffset =\n\t\t\t\t\t    AVI->pos -16 -8;\n\n\t\t\t}\n\n\t\t\t// now we can be sure\n\t\t\tAVI->is_opendml++;\n\t\t}\n\n\t}\n\n\n\tif (video) {\n\t\tavi_add_odml_index_entry_core(AVI, flags, AVI->pos, len,\n\t\t                              AVI->video_superindex->stdindex[ AVI->video_superindex->nEntriesInUse-1 ]);\n\n\t\tAVI->total_frames++;\n\t} // video\n\n\tif (audio) {\n\t\tavi_add_odml_index_entry_core(AVI, flags, AVI->pos, len,\n\t\t                              AVI->track[AVI->aptr].audio_superindex->stdindex[\n\t\t                                  AVI->track[AVI->aptr].audio_superindex->nEntriesInUse-1 ]);\n\t}\n\n\n\treturn 0;\n}\n\n// #undef NR_IXNN_CHUNKS\n\nstatic int avi_add_index_entry(avi_t *AVI, unsigned char *tag, int flags, u64 pos, u64 len)\n{\n\tif(AVI->n_idx>=AVI->max_idx) {\n\t\tvoid *ptr = gf_realloc((void *)AVI->idx,(AVI->max_idx+4096)*16);\n\n\t\tif(ptr == 0) {\n\t\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\t\treturn -1;\n\t\t}\n\t\tAVI->max_idx += 4096;\n\t\tAVI->idx = (unsigned char((*)[16]) ) ptr;\n\t}\n\n\t/* Add index entry */\n\n\t//   GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] INDEX %s %ld %lu %lu\\n\", tag, flags, pos, len));\n\n\tmemcpy(AVI->idx[AVI->n_idx],tag,4);\n\tlong2str(AVI->idx[AVI->n_idx]+ 4,flags);\n\tlong2str(AVI->idx[AVI->n_idx]+ 8, (s32) pos);\n\tlong2str(AVI->idx[AVI->n_idx]+12, (s32) len);\n\n\t/* Update counter */\n\n\tAVI->n_idx++;\n\n\tif(len>AVI->max_len) AVI->max_len=(u32) len;\n\n\treturn 0;\n}\n\n#if 0\n/* Returns 1 if more audio is in that video junk */\nint AVI_can_read_audio(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\treturn -1;\n\t}\n\n\t// is it -1? the last ones got left out --tibit\n\t//if (AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) {\n\tif (AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks) {\n\t\treturn 0;\n\t}\n\n\tif (AVI->video_pos >= AVI->video_frames) return 1;\n\n\tif (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos < AVI->video_index[AVI->video_pos].pos) return 1;\n\telse return 0;\n}\n#endif\n\n/*\n   AVI_open_output_file: Open an AVI File and write a bunch\n                         of zero bytes as space for the header.\n\n   returns a pointer to avi_t on success, a zero pointer on error\n*/\n\nGF_EXPORT\navi_t* AVI_open_output_file(char * filename, u64 opendml_threshold)\n{\n\tavi_t *AVI;\n\tint i;\n\n\tunsigned char AVI_header[HEADERBYTES];\n\n\t/* Allocate the avi_t struct and zero it */\n\n\tAVI = (avi_t *) gf_malloc(sizeof(avi_t));\n\tif(AVI==0)\n\t{\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn 0;\n\t}\n\tmemset((void *)AVI,0,sizeof(avi_t));\n\n\tAVI->fdes = gf_fopen(filename, \"w+b\");\n\tif (!AVI->fdes )\n\t{\n\t\tAVI_errno = AVI_ERR_OPEN;\n\t\tgf_free(AVI);\n\t\treturn 0;\n\t}\n\n\t/* Write out HEADERBYTES bytes, the header will go here\n\t   when we are finished with writing */\n\n\tfor (i=0; i<HEADERBYTES; i++) AVI_header[i] = 0;\n\ti = avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES);\n\tif (i != HEADERBYTES)\n\t{\n\t\tgf_fclose(AVI->fdes);\n\t\tAVI_errno = AVI_ERR_WRITE;\n\t\tgf_free(AVI);\n\t\treturn 0;\n\t}\n\n\tAVI->pos  = HEADERBYTES;\n\tAVI->mode = AVI_MODE_WRITE; /* open for writing */\n\tif (opendml_threshold)\n\t\tAVI->new_riff_threshold = opendml_threshold;\n\telse\n\t\tAVI->new_riff_threshold = (1900*1024*1024);\n\n\t//init\n\tAVI->anum = 0;\n\tAVI->aptr = 0;\n\n\treturn AVI;\n}\n\nGF_EXPORT\nvoid AVI_set_video(avi_t *AVI, int width, int height, double fps, char *compressor)\n{\n\t/* may only be called if file is open for writing */\n\n\tif(AVI->mode==AVI_MODE_READ) return;\n\n\tAVI->width  = width;\n\tAVI->height = height;\n\tAVI->fps    = fps;\n\n\tif(strncmp(compressor, \"RGB\", 3)==0) {\n\t\tmemset(AVI->compressor, 0, 4);\n\t} else {\n\t\tmemcpy(AVI->compressor,compressor,4);\n\t}\n\n\tAVI->compressor[4] = 0;\n\n\tavi_update_header(AVI);\n}\n\nGF_EXPORT\nvoid AVI_set_audio(avi_t *AVI, int channels, int rate, int bits, int format, int mp3rate)\n{\n\t/* may only be called if file is open for writing */\n\n\tif(AVI->mode==AVI_MODE_READ) return;\n\n\t//inc audio tracks\n\tAVI->aptr=AVI->anum;\n\t++AVI->anum;\n\n\tif(AVI->anum > AVI_MAX_TRACKS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));\n\t\texit(1);\n\t}\n\n\tAVI->track[AVI->aptr].a_chans = channels;\n\tAVI->track[AVI->aptr].a_rate  = rate;\n\tAVI->track[AVI->aptr].a_bits  = bits;\n\tAVI->track[AVI->aptr].a_fmt   = format;\n\tAVI->track[AVI->aptr].mp3rate = mp3rate;\n\n\tavi_update_header(AVI);\n}\n\n#define OUT4CC(s) \\\n   if(nhb<=HEADERBYTES-4) memcpy(AVI_header+nhb,s,4); \\\n   nhb += 4\n\n#define OUTLONG(n) \\\n   if(nhb<=HEADERBYTES-4) long2str(AVI_header+nhb, (s32)(n)); \\\n   nhb += 4\n\n#define OUTSHRT(n) \\\n   if(nhb<=HEADERBYTES-2) { \\\n      AVI_header[nhb  ] = (u8) ((n   )&0xff); \\\n      AVI_header[nhb+1] = (u8) ((n>>8)&0xff); \\\n   } \\\n   nhb += 2\n\n#define OUTCHR(n) \\\n   if(nhb<=HEADERBYTES-1) { \\\n      AVI_header[nhb  ] = (n   )&0xff; \\\n   } \\\n   nhb += 1\n\n#define OUTMEM(d, s) \\\n   { \\\n     u32 s_ = (u32) (s); \\\n     if(nhb + s_ <= HEADERBYTES) \\\n        memcpy(AVI_header+nhb, (d), s_); \\\n     nhb += s_; \\\n   }\n\n\n//ThOe write preliminary AVI file header: 0 frames, max vid/aud size\nint avi_update_header(avi_t *AVI)\n{\n\tint njunk, ms_per_frame, frate, flag;\n\tint movi_len, hdrl_start, strl_start;\n\tu32 j;\n\tunsigned char AVI_header[HEADERBYTES];\n\tu32 nhb;\n\tunsigned int xd_size, xd_size_align2;\n\n\t//assume max size\n\tmovi_len = AVI_MAX_LEN - HEADERBYTES + 4;\n\n\t//assume index will be written\n//\tint hasIndex=1;\n\n\tif(AVI->fps < 0.001) {\n\t\tfrate=0;\n\t\tms_per_frame=0;\n\t} else {\n\t\tfrate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n\t\tms_per_frame=(int) (1000000/AVI->fps + 0.5);\n\t}\n\n\t/* Prepare the file header */\n\n\tnhb = 0;\n\n\t/* The RIFF header */\n\n\tOUT4CC (\"RIFF\");\n\tOUTLONG(movi_len);    // assume max size\n\tOUT4CC (\"AVI \");\n\n\t/* Start the header list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\thdrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"hdrl\");\n\n\t/* The main AVI header */\n\n\t/* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n\tOUT4CC (\"avih\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUTLONG(ms_per_frame);       /* Microseconds per frame */\n\t//ThOe ->0\n\t//   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n\tOUTLONG(0);\n\tOUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n\t/* Other sources call it 'reserved' */\n\tflag = AVIF_ISINTERLEAVED;\n\t//if (hasIndex)\n\t\tflag |= AVIF_HASINDEX;\n\tif (/*hasIndex && */AVI->must_use_index)\n\t\tflag |= AVIF_MUSTUSEINDEX;\n\tOUTLONG(flag);               /* Flags */\n\tOUTLONG(0);                  // no frames yet\n\tOUTLONG(0);                  /* InitialFrames */\n\n\tOUTLONG(AVI->anum+1);\n\n\tOUTLONG(0);                  /* SuggestedBufferSize */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\t/* MS calls the following 'reserved': */\n\tOUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n\tOUTLONG(0);                  /* DataRate:   Data rate of playback     */\n\tOUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n\tOUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n\t/* Start the video stream list ---------------------------------- */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\tstrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"strl\");\n\n\t/* The video stream header */\n\n\tOUT4CC (\"strh\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUT4CC (\"vids\");             /* Type */\n\tOUT4CC (AVI->compressor);    /* Handler */\n\tOUTLONG(0);                  /* Flags */\n\tOUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n\tOUTLONG(0);                  /* InitialFrames */\n\tOUTLONG(FRAME_RATE_SCALE);              /* Scale */\n\tOUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n\tOUTLONG(0);                  /* Start */\n\tOUTLONG(0);                  // no frames yet\n\tOUTLONG(0);                  /* SuggestedBufferSize */\n\tOUTLONG(-1);                 /* Quality */\n\tOUTLONG(0);                  /* SampleSize */\n\tOUTLONG(0);                  /* Frame */\n\tOUTLONG(0);                  /* Frame */\n\t//   OUTLONG(0);                  /* Frame */\n\t//OUTLONG(0);                  /* Frame */\n\n\t/* The video stream format */\n\n\txd_size        = AVI->extradata_size;\n\txd_size_align2 = (AVI->extradata_size+1) & ~1;\n\n\tOUT4CC (\"strf\");\n\tOUTLONG(40 + xd_size_align2);/* # of bytes to follow */\n\tOUTLONG(40 + xd_size);\t/* Size */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\tOUTSHRT(1);\n\tOUTSHRT(24);     /* Planes, Count */\n\tOUT4CC (AVI->compressor);    /* Compression */\n\t// ThOe (*3)\n\tOUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n\tOUTLONG(0);                  /* XPelsPerMeter */\n\tOUTLONG(0);                  /* YPelsPerMeter */\n\tOUTLONG(0);                  /* ClrUsed: Number of colors used */\n\tOUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n\t// write extradata\n\tif (xd_size > 0 && AVI->extradata) {\n\t\tOUTMEM(AVI->extradata, xd_size);\n\t\tif (xd_size != xd_size_align2) {\n\t\t\tOUTCHR(0);\n\t\t}\n\t}\n\n\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\n\n\t/* Start the audio stream list ---------------------------------- */\n\n\tfor(j=0; j<AVI->anum; ++j) {\n\t\tint sampsize = avi_sampsize(AVI, j);\n\n\t\tOUT4CC (\"LIST\");\n\t\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\t\tstrl_start = nhb;  /* Store start position */\n\t\tOUT4CC (\"strl\");\n\n\t\t/* The audio stream header */\n\n\t\tOUT4CC (\"strh\");\n\t\tOUTLONG(56);            /* # of bytes to follow */\n\t\tOUT4CC (\"auds\");\n\n\t\t// -----------\n\t\t// ThOe\n\t\tOUTLONG(0);             /* Format (Optionally) */\n\t\t// -----------\n\n\t\tOUTLONG(0);             /* Flags */\n\t\tOUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n\t\tOUTLONG(0);             /* InitialFrames */\n\n\t\t// ThOe /4\n\t\tOUTLONG(sampsize/4);      /* Scale */\n\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);\n\t\tOUTLONG(0);             /* Start */\n\t\tOUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n\t\tOUTLONG(0);             /* SuggestedBufferSize */\n\t\tOUTLONG(-1);            /* Quality */\n\n\t\t// ThOe /4\n\t\tOUTLONG(sampsize/4);    /* SampleSize */\n\n\t\tOUTLONG(0);             /* Frame */\n\t\tOUTLONG(0);             /* Frame */\n\t\t//       OUTLONG(0);             /* Frame */\n\t\t//OUTLONG(0);             /* Frame */\n\n\t\t/* The audio stream format */\n\n\t\tOUT4CC (\"strf\");\n\t\tOUTLONG(16);                   /* # of bytes to follow */\n\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */\n\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n\t\t// ThOe\n\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);\n\t\t//ThOe (/4)\n\n\t\tOUTSHRT(sampsize/4);           /* BlockAlign */\n\n\n\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n\n\t\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n\t\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\t}\n\n\t/* Finish header list */\n\n\tlong2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n\n\n\t/* Calculate the needed amount of junk bytes, output junk */\n\n\tnjunk = HEADERBYTES - nhb - 8 - 12;\n\n\t/* Safety first: if njunk <= 0, somebody has played with\n\t   HEADERBYTES without knowing what (s)he did.\n\t   This is a fatal error */\n\n\tif(njunk<=0)\n\t{\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVI_close_output_file: # of header bytes too small\\n\"));\n\t\texit(1);\n\t}\n\n\tOUT4CC (\"JUNK\");\n\tOUTLONG(njunk);\n\tmemset(AVI_header+nhb,0,njunk);\n\n\tnhb += njunk;\n\n\t/* Start the movi list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(movi_len); /* Length of list in bytes */\n\tOUT4CC (\"movi\");\n\n\t/* Output the header, truncate the file to the number of bytes\n\t   actually written, report an error if someting goes wrong */\n\n\tif ( (gf_fseek(AVI->fdes, 0, SEEK_SET) ==(u64)-1) ||\n\t        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES ||\n\t        (gf_fseek(AVI->fdes,AVI->pos,SEEK_SET)==(u64)-1)\n\t   ) {\n\t\tAVI_errno = AVI_ERR_CLOSE;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\n//SLM\n#ifndef S_IRUSR\n#define S_IRWXU       00700       /* read, write, execute: owner */\n#define S_IRUSR       00400       /* read permission: owner */\n#define S_IWUSR       00200       /* write permission: owner */\n#define S_IXUSR       00100       /* execute permission: owner */\n#define S_IRWXG       00070       /* read, write, execute: group */\n#define S_IRGRP       00040       /* read permission: group */\n#define S_IWGRP       00020       /* write permission: group */\n#define S_IXGRP       00010       /* execute permission: group */\n#define S_IRWXO       00007       /* read, write, execute: other */\n#define S_IROTH       00004       /* read permission: other */\n#define S_IWOTH       00002       /* write permission: other */\n#define S_IXOTH       00001       /* execute permission: other */\n#endif\n\n/*\n  Write the header of an AVI file and close it.\n  returns 0 on success, -1 on write error.\n*/\n\nstatic int avi_close_output_file(avi_t *AVI)\n{\n\tint njunk, hasIndex, ms_per_frame, frate, idxerror, flag;\n\tu64 movi_len;\n\tint hdrl_start, strl_start;\n\tu32 j;\n\tunsigned char AVI_header[HEADERBYTES];\n\tint nhb;\n\tunsigned int xd_size, xd_size_align2;\n\n#ifdef INFO_LIST\n\tint info_len;\n\tint id_len, real_id_len;\n\tint info_start_pos;\n//   time_t calptr;\n#endif\n\n\t/* Calculate length of movi list */\n\n\t// dump the rest of the index\n\tif (AVI->is_opendml) {\n\t\tint cur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\t\tu32 audtr;\n\n#ifdef DEBUG_ODML\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML dump the rest indices\\n\"));\n#endif\n\t\tavi_ixnn_entry (AVI, AVI->video_superindex->stdindex[cur_std_idx],\n\t\t                &AVI->video_superindex->aIndex[cur_std_idx]);\n\n\t\tAVI->video_superindex->aIndex[cur_std_idx].dwDuration =\n\t\t    AVI->video_superindex->stdindex[cur_std_idx]->nEntriesInUse - 1;\n\n\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\t// not initialized -> no index\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tavi_ixnn_entry (AVI, AVI->track[audtr].audio_superindex->stdindex[cur_std_idx],\n\t\t\t                &AVI->track[audtr].audio_superindex->aIndex[cur_std_idx]);\n\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx].dwDuration =\n\t\t\t    AVI->track[audtr].audio_superindex->stdindex[cur_std_idx]->nEntriesInUse - 1;\n\t\t\tif (AVI->track[audtr].a_fmt == 0x1) {\n\t\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx].dwDuration *=\n\t\t\t\t    AVI->track[audtr].a_bits*AVI->track[audtr].a_rate*AVI->track[audtr].a_chans/800;\n\t\t\t}\n\t\t}\n\t\t// The AVI->video_superindex->nEntriesInUse contains the offset\n\t\tAVI->video_superindex->stdindex[ cur_std_idx+1 ]->qwBaseOffset = AVI->pos;\n\n\t\t// Correct!\n\t\tmovi_len = AVI->video_superindex->stdindex[ 1 ]->qwBaseOffset - HEADERBYTES+4 - AVI->n_idx*16 - 8;\n\t} else {\n\t\tmovi_len = AVI->pos - HEADERBYTES + 4;\n\t}\n\n\n\t/* Try to output the index entries. This may fail e.g. if no space\n\t   is left on device. We will report this as an error, but we still\n\t   try to write the header correctly (so that the file still may be\n\t   readable in the most cases */\n\n\tidxerror = 0;\n\thasIndex = 1;\n\tif (!AVI->is_opendml) {\n\t\t//   GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] pos=%lu, index_len=%ld             \\n\", AVI->pos, AVI->n_idx*16));\n\t\tint ret = avi_add_chunk(AVI, (unsigned char *)\"idx1\", (unsigned char *)AVI->idx, AVI->n_idx*16);\n\t\thasIndex = (ret==0);\n\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] pos=%lu, index_len=%d\\n\", AVI->pos, hasIndex));\n\n\t\tif(ret) {\n\t\t\tidxerror = 1;\n\t\t\tAVI_errno = AVI_ERR_WRITE_INDEX;\n\t\t}\n\t}\n\n\t/* Calculate Microseconds per frame */\n\n\tif(AVI->fps < 0.001) {\n\t\tfrate=0;\n\t\tms_per_frame=0;\n\t} else {\n\t\tfrate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n\t\tms_per_frame=(int) (1000000/AVI->fps + 0.5);\n\t}\n\n\t/* Prepare the file header */\n\n\tnhb = 0;\n\n\t/* The RIFF header */\n\n\tOUT4CC (\"RIFF\");\n\tif (AVI->is_opendml) {\n\t\tOUTLONG(AVI->video_superindex->stdindex[ 1 ]->qwBaseOffset - 8);    /* # of bytes to follow */\n\t} else {\n\t\tOUTLONG(AVI->pos - 8);    /* # of bytes to follow */\n\t}\n\n\tOUT4CC (\"AVI \");\n\n\t/* Start the header list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\thdrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"hdrl\");\n\n\t/* The main AVI header */\n\n\t/* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n\tOUT4CC (\"avih\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUTLONG(ms_per_frame);       /* Microseconds per frame */\n\t//ThOe ->0\n\t//   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n\tOUTLONG(0);\n\tOUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n\t/* Other sources call it 'reserved' */\n\tflag = AVIF_ISINTERLEAVED;\n\tif(hasIndex) flag |= AVIF_HASINDEX;\n\tif(hasIndex && AVI->must_use_index) flag |= AVIF_MUSTUSEINDEX;\n\tOUTLONG(flag);               /* Flags */\n\tOUTLONG(AVI->video_frames);  /* TotalFrames */\n\tOUTLONG(0);                  /* InitialFrames */\n\n\tOUTLONG(AVI->anum+1);\n//   if (AVI->track[0].audio_bytes)\n//      { OUTLONG(2); }           /* Streams */\n//   else\n//      { OUTLONG(1); }           /* Streams */\n\n\tOUTLONG(0);                  /* SuggestedBufferSize */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\t/* MS calls the following 'reserved': */\n\tOUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n\tOUTLONG(0);                  /* DataRate:   Data rate of playback     */\n\tOUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n\tOUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n\t/* Start the video stream list ---------------------------------- */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\tstrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"strl\");\n\n\t/* The video stream header */\n\n\tOUT4CC (\"strh\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUT4CC (\"vids\");             /* Type */\n\tOUT4CC (AVI->compressor);    /* Handler */\n\tOUTLONG(0);                  /* Flags */\n\tOUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n\tOUTLONG(0);                  /* InitialFrames */\n\tOUTLONG(FRAME_RATE_SCALE);   /* Scale */\n\tOUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n\tOUTLONG(0);                  /* Start */\n\tOUTLONG(AVI->video_frames);  /* Length */\n\tOUTLONG(AVI->max_len);       /* SuggestedBufferSize */\n\tOUTLONG(0);                  /* Quality */\n\tOUTLONG(0);                  /* SampleSize */\n\tOUTLONG(0);                  /* Frame */\n\tOUTLONG(0);                  /* Frame */\n\t//OUTLONG(0);                  /* Frame */\n\t//OUTLONG(0);                  /* Frame */\n\n\t/* The video stream format */\n\n\txd_size        = AVI->extradata_size;\n\txd_size_align2 = (AVI->extradata_size+1) & ~1;\n\n\tOUT4CC (\"strf\");\n\tOUTLONG(40 + xd_size_align2);/* # of bytes to follow */\n\tOUTLONG(40 + xd_size);\t/* Size */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\tOUTSHRT(1);\n\tOUTSHRT(24);     /* Planes, Count */\n\tOUT4CC (AVI->compressor);    /* Compression */\n\t// ThOe (*3)\n\tOUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n\tOUTLONG(0);                  /* XPelsPerMeter */\n\tOUTLONG(0);                  /* YPelsPerMeter */\n\tOUTLONG(0);                  /* ClrUsed: Number of colors used */\n\tOUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n\t// write extradata if present\n\tif (xd_size > 0 && AVI->extradata) {\n\t\tOUTMEM(AVI->extradata, xd_size);\n\t\tif (xd_size != xd_size_align2) {\n\t\t\tOUTCHR(0);\n\t\t}\n\t}\n\n\t// dump index of indices for audio\n\tif (AVI->is_opendml) {\n\t\tu32 k;\n\n\t\tOUT4CC(AVI->video_superindex->fcc);\n\t\tOUTLONG(2+1+1+4+4+3*4 + AVI->video_superindex->nEntriesInUse * (8+4+4));\n\t\tOUTSHRT(AVI->video_superindex->wLongsPerEntry);\n\t\tOUTCHR(AVI->video_superindex->bIndexSubType);\n\t\tOUTCHR(AVI->video_superindex->bIndexType);\n\t\tOUTLONG(AVI->video_superindex->nEntriesInUse);\n\t\tOUT4CC(AVI->video_superindex->dwChunkId);\n\t\tOUTLONG(0);\n\t\tOUTLONG(0);\n\t\tOUTLONG(0);\n\n\n\t\tfor (k = 0; k < AVI->video_superindex->nEntriesInUse; k++) {\n\t\t\tu32 r = (u32) ((AVI->video_superindex->aIndex[k].qwOffset >> 32) & 0xffffffff);\n\t\t\tu32 s = (u32) ((AVI->video_superindex->aIndex[k].qwOffset) & 0xffffffff);\n\n\t\t\tOUTLONG(s);\n\t\t\tOUTLONG(r);\n\t\t\tOUTLONG(AVI->video_superindex->aIndex[k].dwSize);\n\t\t\tOUTLONG(AVI->video_superindex->aIndex[k].dwDuration);\n\t\t}\n\n\t}\n\n\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\n\t/* Start the audio stream list ---------------------------------- */\n\n\tfor(j=0; j<AVI->anum; ++j) {\n\n\t\t//if (AVI->track[j].a_chans && AVI->track[j].audio_bytes)\n\t\t{\n\t\t\tunsigned int nBlockAlign = 0;\n\t\t\tunsigned int avgbsec = 0;\n\t\t\tunsigned int scalerate = 0;\n\n\t\t\tint sampsize = avi_sampsize(AVI, j);\n\t\t\tsampsize = AVI->track[j].a_fmt==0x1?sampsize*4:sampsize;\n\n\t\t\tnBlockAlign = (AVI->track[j].a_rate<32000)?576:1152;\n\t\t\t/*\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] XXX sampsize (%d) block (%ld) rate (%ld) audio_bytes (%ld) mp3rate(%ld,%ld)\\n\",\n\t\t\t sampsize, nBlockAlign, AVI->track[j].a_rate,\n\t\t\t (int int)AVI->track[j].audio_bytes,\n\t\t\t 1000*AVI->track[j].mp3rate/8, AVI->track[j].mp3rate));\n\t\t\t */\n\n\t\t\tif (AVI->track[j].a_fmt==0x1) {\n\t\t\t\tsampsize = (AVI->track[j].a_chans<2)?sampsize/2:sampsize;\n\t\t\t\tavgbsec = AVI->track[j].a_rate*sampsize/4;\n\t\t\t\tscalerate = AVI->track[j].a_rate*sampsize/4;\n\t\t\t} else  {\n\t\t\t\tavgbsec = 1000*AVI->track[j].mp3rate/8;\n\t\t\t\tscalerate = 1000*AVI->track[j].mp3rate/8;\n\t\t\t}\n\n\t\t\tOUT4CC (\"LIST\");\n\t\t\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\t\t\tstrl_start = nhb;  /* Store start position */\n\t\t\tOUT4CC (\"strl\");\n\n\t\t\t/* The audio stream header */\n\n\t\t\tOUT4CC (\"strh\");\n\t\t\tOUTLONG(56);            /* # of bytes to follow */\n\t\t\tOUT4CC (\"auds\");\n\n\t\t\t// -----------\n\t\t\t// ThOe\n\t\t\tOUTLONG(0);             /* Format (Optionally) */\n\t\t\t// -----------\n\n\t\t\tOUTLONG(0);             /* Flags */\n\t\t\tOUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n\t\t\tOUTLONG(0);             /* InitialFrames */\n\n\t\t\t// VBR\n\t\t\tif (AVI->track[j].a_fmt == 0x55 && AVI->track[j].a_vbr) {\n\t\t\t\tOUTLONG(nBlockAlign);                   /* Scale */\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* Rate */\n\t\t\t\tOUTLONG(0);                             /* Start */\n\t\t\t\tOUTLONG(AVI->track[j].audio_chunks);    /* Length */\n\t\t\t\tOUTLONG(0);                      /* SuggestedBufferSize */\n\t\t\t\tOUTLONG(0);                             /* Quality */\n\t\t\t\tOUTLONG(0);                             /* SampleSize */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t} else {\n\t\t\t\tOUTLONG(sampsize/4);                    /* Scale */\n\t\t\t\tOUTLONG(scalerate);  /* Rate */\n\t\t\t\tOUTLONG(0);                             /* Start */\n\t\t\t\tOUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n\t\t\t\tOUTLONG(0);                             /* SuggestedBufferSize */\n\t\t\t\tOUTLONG(0xffffffff);                             /* Quality */\n\t\t\t\tOUTLONG(sampsize/4);                    /* SampleSize */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t}\n\n\t\t\t/* The audio stream format */\n\n\t\t\tOUT4CC (\"strf\");\n\n\t\t\tif (AVI->track[j].a_fmt == 0x55 && AVI->track[j].a_vbr) {\n\n\t\t\t\tOUTLONG(30);                            /* # of bytes to follow */ // mplayer writes 28\n\t\t\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */                  // 2\n\t\t\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */      // 2\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */           // 4\n\t\t\t\t//ThOe/tibit\n\t\t\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);  /* maybe we should write an avg. */ // 4\n\t\t\t\tOUTSHRT(nBlockAlign);                   /* BlockAlign */              // 2\n\t\t\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */           // 2\n\n\t\t\t\tOUTSHRT(12);                           /* cbSize */                   // 2\n\t\t\t\tOUTSHRT(1);                            /* wID */                      // 2\n\t\t\t\tOUTLONG(2);                            /* fdwFlags */                 // 4\n\t\t\t\tOUTSHRT(nBlockAlign);                  /* nBlockSize */               // 2\n\t\t\t\tOUTSHRT(1);                            /* nFramesPerBlock */          // 2\n\t\t\t\tOUTSHRT(0);                            /* nCodecDelay */              // 2\n\n\t\t\t} else if (AVI->track[j].a_fmt == 0x55 && !AVI->track[j].a_vbr) {\n\n\t\t\t\tOUTLONG(30);                            /* # of bytes to follow */\n\t\t\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */\n\t\t\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n\t\t\t\t//ThOe/tibit\n\t\t\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);\n\t\t\t\tOUTSHRT(sampsize/4);                    /* BlockAlign */\n\t\t\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n\n\t\t\t\tOUTSHRT(12);                           /* cbSize */\n\t\t\t\tOUTSHRT(1);                            /* wID */\n\t\t\t\tOUTLONG(2);                            /* fdwFlags */\n\t\t\t\tOUTSHRT(nBlockAlign);                  /* nBlockSize */\n\t\t\t\tOUTSHRT(1);                            /* nFramesPerBlock */\n\t\t\t\tOUTSHRT(0);                            /* nCodecDelay */\n\n\t\t\t} else {\n\n\t\t\t\tOUTLONG(18);                   /* # of bytes to follow */\n\t\t\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */\n\t\t\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n\t\t\t\t//ThOe/tibit\n\t\t\t\tOUTLONG(avgbsec);  /* Avg bytes/sec */\n\t\t\t\tOUTSHRT(sampsize/4);                    /* BlockAlign */\n\t\t\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n\t\t\t\tOUTSHRT(0);                           /* cbSize */\n\n\t\t\t}\n\t\t}\n\t\tif (AVI->is_opendml) {\n\t\t\tu32 k;\n\n\t\t\tif (!AVI->track[j].audio_superindex) {\n\t\t\t\t// not initialized -> no index\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tOUT4CC(AVI->track[j].audio_superindex->fcc);    /* \"indx\" */\n\t\t\tOUTLONG(2+1+1+4+4+3*4 + AVI->track[j].audio_superindex->nEntriesInUse * (8+4+4));\n\t\t\tOUTSHRT(AVI->track[j].audio_superindex->wLongsPerEntry);\n\t\t\tOUTCHR(AVI->track[j].audio_superindex->bIndexSubType);\n\t\t\tOUTCHR(AVI->track[j].audio_superindex->bIndexType);\n\t\t\tOUTLONG(AVI->track[j].audio_superindex->nEntriesInUse);\n\t\t\tOUT4CC(AVI->track[j].audio_superindex->dwChunkId);\n\t\t\tOUTLONG(0);\n\t\t\tOUTLONG(0);\n\t\t\tOUTLONG(0);\n\n\t\t\tfor (k = 0; k < AVI->track[j].audio_superindex->nEntriesInUse; k++) {\n\t\t\t\tu32 r = (u32) ((AVI->track[j].audio_superindex->aIndex[k].qwOffset >> 32) & 0xffffffff);\n\t\t\t\tu32 s = (u32) ((AVI->track[j].audio_superindex->aIndex[k].qwOffset) & 0xffffffff);\n\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] AUD[%d] NrEntries %d/%ld (%c%c%c%c) |0x%llX|%ld|%ld| \\n\",  j, k,\n\t\t\t\t        AVI->track[j].audio_superindex->nEntriesInUse,\n\t\t\t\t    AVI->track[j].audio_superindex->dwChunkId[0], AVI->track[j].audio_superindex->dwChunkId[1],\n\t\t\t\t    AVI->track[j].audio_superindex->dwChunkId[2], AVI->track[j].audio_superindex->dwChunkId[3],\n\t\t\t\t    AVI->track[j].audio_superindex->aIndex[k].qwOffset,\n\t\t\t\t    AVI->track[j].audio_superindex->aIndex[k].dwSize,\n\t\t\t\t    AVI->track[j].audio_superindex->aIndex[k].dwDuration\n\t\t\t\t  ));\n\t\t\t\t  */\n\n\t\t\t\tOUTLONG(s);\n\t\t\t\tOUTLONG(r);\n\t\t\t\tOUTLONG(AVI->track[j].audio_superindex->aIndex[k].dwSize);\n\t\t\t\tOUTLONG(AVI->track[j].audio_superindex->aIndex[k].dwDuration);\n\t\t\t}\n\t\t}\n\t\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\t\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\t}\n\n\tif (AVI->is_opendml) {\n\t\tOUT4CC(\"LIST\");\n\t\tOUTLONG(16);\n\t\tOUT4CC(\"odml\");\n\t\tOUT4CC(\"dmlh\");\n\t\tOUTLONG(4);\n\t\tOUTLONG(AVI->total_frames);\n\t}\n\n\t/* Finish header list */\n\n\tlong2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n\n\n\t// add INFO list --- (0.6.0pre4)\n\n#ifdef INFO_LIST\n\tOUT4CC (\"LIST\");\n\n\tinfo_start_pos = nhb;\n\tinfo_len = MAX_INFO_STRLEN + 12;\n\tOUTLONG(info_len); // rewritten later\n\tOUT4CC (\"INFO\");\n\n\tOUT4CC (\"ISFT\");\n\t//OUTLONG(MAX_INFO_STRLEN);\n\tmemset(id_str, 0, MAX_INFO_STRLEN);\n\tif (gf_sys_is_test_mode()) {\n\t\tsnprintf(id_str, MAX_INFO_STRLEN, \"GPAC/avilib\");\n\t} else {\n\t\tsnprintf(id_str, MAX_INFO_STRLEN, \"GPAC/avilib-%s\", gf_gpac_version());\n\t}\n\treal_id_len = id_len = (u32) strlen(id_str)+1;\n\tif (id_len&1) id_len++;\n\n\tOUTLONG(real_id_len);\n\n\tmemset(AVI_header+nhb, 0, id_len);\n\tmemcpy(AVI_header+nhb, id_str, id_len);\n\tnhb += id_len;\n\n\tinfo_len = 0;\n\n\t// write correct len\n\tlong2str(AVI_header+info_start_pos, info_len + id_len + 4+4+4);\n\n\tnhb += info_len;\n\n//   OUT4CC (\"ICMT\");\n//   OUTLONG(MAX_INFO_STRLEN);\n\n//   calptr=time(NULL);\n//   sprintf(id_str, \"\\t%s %s\", ctime(&calptr), \"\");\n//   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n//   memcpy(AVI_header+nhb, id_str, 25);\n//   nhb += MAX_INFO_STRLEN;\n#endif\n\n\t// ----------------------------\n\n\t/* Calculate the needed amount of junk bytes, output junk */\n\n\tnjunk = HEADERBYTES - nhb - 8 - 12;\n\n\t/* Safety first: if njunk <= 0, somebody has played with\n\t   HEADERBYTES without knowing what (s)he did.\n\t   This is a fatal error */\n\n\tif(njunk<=0)\n\t{\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVI_close_output_file: # of header bytes too small\\n\"));\n\t\texit(1);\n\t}\n\n\tOUT4CC (\"JUNK\");\n\tOUTLONG(njunk);\n\tmemset(AVI_header+nhb,0,njunk);\n\n\tnhb += njunk;\n\n\t/* Start the movi list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(movi_len); /* Length of list in bytes */\n\tOUT4CC (\"movi\");\n\n\t/* Output the header, truncate the file to the number of bytes\n\t   actually written, report an error if someting goes wrong */\n\n\tif ( (gf_fseek(AVI->fdes,0,SEEK_SET)==(u64)-1) ||\n\t        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES\n//\t\t|| ftruncate(AVI->fdes,AVI->pos)<0\n\t   )\n\t{\n\t\tAVI_errno = AVI_ERR_CLOSE;\n\t\treturn -1;\n\t}\n\n\n\t// Fix up the empty additional RIFF and LIST chunks\n\tif (AVI->is_opendml) {\n\t\tu32 k;\n\t\tchar f[4];\n\t\tu32 len;\n\n\t\tfor (k=1; k<AVI->video_superindex->nEntriesInUse; k++) {\n\t\t\t// the len of the RIFF Chunk\n\t\t\tgf_fseek(AVI->fdes, AVI->video_superindex->stdindex[k]->qwBaseOffset+4, SEEK_SET);\n\t\t\tlen = (u32) (AVI->video_superindex->stdindex[k+1]->qwBaseOffset - AVI->video_superindex->stdindex[k]->qwBaseOffset - 8);\n\t\t\tlong2str((unsigned char *)f, len);\n\t\t\tavi_write(AVI->fdes, f, 4);\n\n\t\t\t// len of the LIST/movi chunk\n\t\t\tgf_fseek(AVI->fdes, 8, SEEK_CUR);\n\t\t\tlen -= 12;\n\t\t\tlong2str((unsigned char *)f, len);\n\t\t\tavi_write(AVI->fdes, f, 4);\n\t\t}\n\t}\n\n\n\tif(idxerror) return -1;\n\n\treturn 0;\n}\n\n/*\n   AVI_write_data:\n   Add video or audio data to the file;\n\n   Return values:\n    0    No error;\n   -1    Error, AVI_errno is set appropriatly;\n\n*/\n\nstatic int avi_write_data(avi_t *AVI, char *data, unsigned int length, int audio, int keyframe)\n{\n\tint n = 0;\n\n\tunsigned char astr[5];\n\n\t// transcode core itself checks for the size -- unneeded and\n\t// does harm to xvid 2pass encodes where the first pass can get\n\t// _very_ large -- tibit.\n\n#if 0\n\t/* Check for maximum file length */\n\n\tif ( (AVI->pos + 8 + length + 8 + (AVI->n_idx+1)*16) > AVI_MAX_LEN ) {\n\t\tAVI_errno = AVI_ERR_SIZELIM;\n\t\treturn -1;\n\t}\n#endif\n\n\t/* Add index entry */\n\n\t//set tag for current audio track\n\tsprintf((char *)astr, \"0%1dwb\", (int)(AVI->aptr+1));\n\n\tif(audio) {\n\t\tif (!AVI->is_opendml) n = avi_add_index_entry(AVI,astr,0x10,AVI->pos,length);\n\t\tn += avi_add_odml_index_entry(AVI,astr,0x10,AVI->pos,length);\n\t} else {\n\t\tif (!AVI->is_opendml) n = avi_add_index_entry(AVI,(unsigned char *)\"00db\",((keyframe)?0x10:0x0),AVI->pos,length);\n\t\tn += avi_add_odml_index_entry(AVI,(unsigned char *)\"00db\",((keyframe)?0x10:0x0),AVI->pos,length);\n\t}\n\n\tif(n) return -1;\n\n\t/* Output tag and data */\n\n\tif(audio)\n\t\tn = avi_add_chunk(AVI,(unsigned char *)astr, (unsigned char *)data, length);\n\telse\n\t\tn = avi_add_chunk(AVI,(unsigned char *)\"00db\", (unsigned char *)data, length);\n\n\tif (n) return -1;\n\n\treturn 0;\n}\n\nGF_EXPORT\nint AVI_write_frame(avi_t *AVI, u8 *data, int bytes, int keyframe)\n{\n\ts64 pos;\n\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tpos = AVI->pos;\n\n\tif(avi_write_data(AVI,data,bytes,0,keyframe)) return -1;\n\n\tAVI->last_pos = pos;\n\tAVI->last_len = bytes;\n\tAVI->video_frames++;\n\treturn 0;\n}\n\n#if 0 //unused\nint AVI_dup_frame(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tif(AVI->last_pos==0) return 0; /* No previous real frame */\n\tif(avi_add_index_entry(AVI,(unsigned char *)\"00db\",0x10,AVI->last_pos,AVI->last_len)) return -1;\n\tAVI->video_frames++;\n\tAVI->must_use_index = 1;\n\treturn 0;\n}\n#endif\n\nGF_EXPORT\nint AVI_write_audio(avi_t *AVI, u8 *data, int bytes)\n{\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tif( avi_write_data(AVI,data,bytes,1,0) ) return -1;\n\tAVI->track[AVI->aptr].audio_bytes += bytes;\n\tAVI->track[AVI->aptr].audio_chunks++;\n\treturn 0;\n}\n\n#if 0 //unused\n\nint AVI_append_audio(avi_t *AVI, u8 *data, int bytes)\n{\n\n\t// won't work for >2gb\n\tint i, length, pos;\n\tunsigned char c[4];\n\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\t// update last index entry:\n\n\t--AVI->n_idx;\n\tlength = str2ulong(AVI->idx[AVI->n_idx]+12);\n\tpos    = str2ulong(AVI->idx[AVI->n_idx]+8);\n\n\t//update;\n\tlong2str(AVI->idx[AVI->n_idx]+12,length+bytes);\n\n\t++AVI->n_idx;\n\n\tAVI->track[AVI->aptr].audio_bytes += bytes;\n\n\t//update chunk header\n\tgf_fseek(AVI->fdes, pos+4, SEEK_SET);\n\tlong2str(c, length+bytes);\n\tavi_write(AVI->fdes, (char *)c, 4);\n\n\tgf_fseek(AVI->fdes, pos+8+length, SEEK_SET);\n\n\ti=PAD_EVEN(length + bytes);\n\n\tbytes = i - length;\n\tavi_write(AVI->fdes, data, bytes);\n\tAVI->pos = pos + 8 + i;\n\n\treturn 0;\n}\n\nu64 AVI_bytes_remain(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_READ) return 0;\n\n\treturn ( AVI_MAX_LEN - (AVI->pos + 8 + 16*AVI->n_idx));\n}\n\nu64 AVI_bytes_written(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_READ) return 0;\n\n\treturn (AVI->pos + 8 + 16*AVI->n_idx);\n}\n#endif\n\nint AVI_set_audio_track(avi_t *AVI, u32 track)\n{\n\n\tif (track + 1 > AVI->anum) return(-1);\n\n\t//this info is not written to file anyway\n\tAVI->aptr=track;\n\treturn 0;\n}\n\nint AVI_get_audio_track(avi_t *AVI)\n{\n\treturn(AVI->aptr);\n}\n\n#if 0 //unused\nvoid AVI_set_audio_vbr(avi_t *AVI, int is_vbr)\n{\n\tAVI->track[AVI->aptr].a_vbr = is_vbr;\n}\n\nint AVI_get_audio_vbr(avi_t *AVI)\n{\n\treturn(AVI->track[AVI->aptr].a_vbr);\n}\n#endif\n\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for reading video and audio from an AVI File       *\n *                                                                 *\n *******************************************************************/\n\nGF_EXPORT\nint AVI_close(avi_t *AVI)\n{\n\tint ret;\n\tu32 j;\n\n\t/* If the file was open for writing, the header and index still have\n\t   to be written */\n\n\tif(AVI->mode == AVI_MODE_WRITE)\n\t\tret = avi_close_output_file(AVI);\n\telse\n\t\tret = 0;\n\n\t/* Even if there happened an error, we first clean up */\n\n\tgf_fclose(AVI->fdes);\n\tif(AVI->idx) gf_free(AVI->idx);\n\tif(AVI->video_index) gf_free(AVI->video_index);\n\tif(AVI->video_superindex) {\n\t\tif(AVI->video_superindex->aIndex) gf_free(AVI->video_superindex->aIndex);\n\t\tif (AVI->video_superindex->stdindex) {\n\t\t\tfor (j=0; j < NR_IXNN_CHUNKS; j++) {\n\t\t\t\tif (AVI->video_superindex->stdindex[j]->aIndex)\n\t\t\t\t\tgf_free(AVI->video_superindex->stdindex[j]->aIndex);\n\t\t\t\tgf_free(AVI->video_superindex->stdindex[j]);\n\t\t\t}\n\t\t\tgf_free(AVI->video_superindex->stdindex);\n\t\t}\n\t\tgf_free(AVI->video_superindex);\n\t}\n\n\tfor (j=0; j<AVI->anum; j++)\n\t{\n\t\tif(AVI->track[j].audio_index) gf_free(AVI->track[j].audio_index);\n\t\tif(AVI->track[j].audio_superindex) {\n\t\t\tavisuperindex_chunk *asi = AVI->track[j].audio_superindex;\n\t\t\tif (asi->aIndex) gf_free(asi->aIndex);\n\n\t\t\tif (asi->stdindex) {\n\t\t\t\tfor (j=0; j < NR_IXNN_CHUNKS; j++) {\n\t\t\t\t\tif (asi->stdindex[j]->aIndex)\n\t\t\t\t\t\tgf_free(asi->stdindex[j]->aIndex);\n\t\t\t\t\tgf_free(asi->stdindex[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(asi->stdindex);\n\t\t\t}\n\t\t\tgf_free(asi);\n\t\t}\n\t}\n\n\tif (AVI->bitmap_info_header)\n\t\tgf_free(AVI->bitmap_info_header);\n\tfor (j = 0; j < AVI->anum; j++)\n\t\tif (AVI->wave_format_ex[j])\n\t\t\tgf_free(AVI->wave_format_ex[j]);\n\tif (AVI->extradata)\n\t\tgf_free(AVI->extradata);\n\n\tgf_free(AVI);\n\treturn ret;\n}\n\n\n#define ERR_EXIT(x) \\\n{ \\\n   AVI_close(AVI); \\\n   AVI_errno = x; \\\n   return 0; \\\n}\n\n\navi_t *AVI_open_input_file(char *filename, int getIndex)\n{\n\tavi_t *AVI;\n\n\t/* Create avi_t structure */\n\n\tAVI = (avi_t *) gf_malloc(sizeof(avi_t));\n\tif(AVI==NULL)\n\t{\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn 0;\n\t}\n\tmemset((void *)AVI,0,sizeof(avi_t));\n\n\tAVI->mode = AVI_MODE_READ; /* open for reading */\n\n\t/* Open the file */\n\n\tAVI->fdes = gf_fopen(filename,\"rb\");\n\tif(!AVI->fdes )\n\t{\n\t\tAVI_errno = AVI_ERR_OPEN;\n\t\tgf_free(AVI);\n\t\treturn 0;\n\t}\n\n\tAVI_errno = 0;\n\tavi_parse_input_file(AVI, getIndex);\n\n\tif (AVI != NULL && !AVI_errno) {\n\t\tAVI->aptr=0; //reset\n\t}\n\n\tif (AVI_errno) return NULL;\n\n\treturn AVI;\n}\n\n#if 0\navi_t *AVI_open_fd(FILE *fd, int getIndex)\n{\n\tavi_t *AVI=NULL;\n\n\t/* Create avi_t structure */\n\n\tAVI = (avi_t *) gf_malloc(sizeof(avi_t));\n\tif(AVI==NULL)\n\t{\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn 0;\n\t}\n\tmemset((void *)AVI,0,sizeof(avi_t));\n\n\tAVI->mode = AVI_MODE_READ; /* open for reading */\n\n\t// file alread open\n\tAVI->fdes = fd;\n\n\tAVI_errno = 0;\n\tavi_parse_input_file(AVI, getIndex);\n\n\tif (AVI != NULL && !AVI_errno) {\n\t\tAVI->aptr=0; //reset\n\t}\n\n\tif (AVI_errno)\n\t\treturn AVI=NULL;\n\telse\n\t\treturn AVI;\n}\n#endif\n\nint avi_parse_input_file(avi_t *AVI, int getIndex)\n{\n\tint rate, scale, idx_type;\n\ts64 n, i;\n\tunsigned char *hdrl_data;\n\tu64 header_offset=0;\n\tint hdrl_len=0;\n\tint nvi, nai[AVI_MAX_TRACKS], ioff;\n\tu64 tot[AVI_MAX_TRACKS];\n\tu32 j;\n\tint lasttag = 0;\n\tint vids_strh_seen = 0;\n\tint vids_strf_seen = 0;\n\tint auds_strh_seen = 0;\n\t//  int auds_strf_seen = 0;\n\tint num_stream = 0;\n\tchar data[256];\n\ts64 oldpos=-1, newpos=-1;\n\n\tint aud_chunks = 0;\n\tif (!AVI) {\n\t   AVI_errno = AVI_ERR_OPEN;\n\t   return 0;\n\t}\n\n\t/* Read first 12 bytes and check that this is an AVI file */\n\tif (avi_read(AVI->fdes,data,12) != 12 )\n\t\tERR_EXIT(AVI_ERR_READ)\n\n\tif (strnicmp(data  ,\"RIFF\",4) !=0 || strnicmp(data+8,\"AVI \",4) !=0 )\n\t\tERR_EXIT(AVI_ERR_NO_AVI)\n\n\t/* Go through the AVI file and extract the header list,\n\t   the start position of the 'movi' list and an optionally\n\t   present idx1 tag */\n\n\thdrl_data = 0;\n\n\twhile(1)\n\t{\n\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break; /* We assume it's EOF */\n\t\tnewpos = gf_ftell(AVI->fdes);\n\t\tif(oldpos==newpos) {\n\t\t\t/* This is a broken AVI stream... */\n\t\t\treturn -1;\n\t\t}\n\t\toldpos=newpos;\n\n\t\tn = str2ulong((unsigned char *)data+4);\n\t\tn = PAD_EVEN(n);\n\n\t\tif(strnicmp(data,\"LIST\",4) == 0)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\tn -= 4;\n\t\t\tif(strnicmp(data,\"hdrl\",4) == 0)\n\t\t\t{\n\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\thdrl_len = (u32) n;\n\t\t\t\thdrl_data = (unsigned char *) gf_malloc((u32)n);\n\t\t\t\tif(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\t\t\t// offset of header\n\n\t\t\t\theader_offset = gf_ftell(AVI->fdes);\n\n\t\t\t\tif( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t}\n\t\t\telse if(strnicmp(data,\"movi\",4) == 0)\n\t\t\t{\n\t\t\t\tAVI->movi_start = gf_ftell(AVI->fdes);\n\t\t\t\tif (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t\t}\n\t\t\telse if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t}\n\t\telse if(strnicmp(data,\"idx1\",4) == 0)\n\t\t{\n\t\t\t/* n must be a multiple of 16, but the reading does not\n\t\t\t   break if this is not the case */\n\n\t\t\tAVI->n_idx = AVI->max_idx = (u32) (n/16);\n\t\t\tAVI->idx = (unsigned  char((*)[16]) ) gf_malloc((u32)n);\n\t\t\tif(AVI->idx==0) ERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t\tif(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {\n\t\t\t\t\tgf_free( AVI->idx);\n\t\t\t\t\tAVI->idx=NULL;\n\t\t\t\t\tAVI->n_idx = 0;\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t}\n\n\tif(!hdrl_data      ) ERR_EXIT(AVI_ERR_NO_HDRL)\n\t\tif(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)\n\n\t\t\t/* Interpret the header list */\n\n\t\t\tfor(i=0; i<hdrl_len;)\n\t\t\t{\n\t\t\t\t/* List tags are completly ignored */\n\n#ifdef DEBUG_ODML\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"LIST\",4)==0) {\n\t\t\t\t\ti+= 12;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tn = str2ulong(hdrl_data+i+4);\n\t\t\t\tn = PAD_EVEN(n);\n\n\n\t\t\t\t/* Interpret the tag and its args */\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"strh\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG   %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\t\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"vids\",4) == 0 && !vids_strh_seen)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(AVI->compressor,hdrl_data+i+4,4);\n\t\t\t\t\t\tAVI->compressor[4] = 0;\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->v_codech_off = header_offset + i+4;\n\n\t\t\t\t\t\tscale = str2ulong(hdrl_data+i+20);\n\t\t\t\t\t\trate  = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tif(scale!=0) AVI->fps = (double)rate/(double)scale;\n\t\t\t\t\t\tAVI->video_frames = str2ulong(hdrl_data+i+32);\n\t\t\t\t\t\tAVI->video_strn = num_stream;\n\t\t\t\t\t\tAVI->max_len = 0;\n\t\t\t\t\t\tvids_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 1; /* vids */\n\t\t\t\t\t\tmemcpy(&AVI->video_stream_header, hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char *)hdrl_data+i,\"auds\",4) ==0 && ! auds_strh_seen)\n\t\t\t\t\t{\n\n\t\t\t\t\t\t//inc audio tracks\n\t\t\t\t\t\tAVI->aptr=AVI->anum;\n\t\t\t\t\t\t++AVI->anum;\n\n\t\t\t\t\t\tif(AVI->anum > AVI_MAX_TRACKS) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));\n\t\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_strn = num_stream;\n\n\t\t\t\t\t\t// if samplesize==0 -> vbr\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_vbr = !str2ulong(hdrl_data+i+44);\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].padrate = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tmemcpy(&AVI->stream_headers[AVI->aptr], hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\n\t\t\t\t\t\t//\t   auds_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 2; /* auds */\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codech_off = header_offset + i;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char*)hdrl_data+i,\"iavs\",4) ==0 && ! auds_strh_seen) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVILIB: error - DV AVI Type 1 no supported\\n\"));\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlasttag = 0;\n\t\t\t\t\tnum_stream++;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"dmlh\",4) == 0) {\n\t\t\t\t\tAVI->total_frames = str2ulong(hdrl_data+i+8);\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] real number of frames %d\\n\", AVI->total_frames));\n#endif\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *)\n\t\t\t\t\t\t                          gf_malloc(str2ulong((unsigned char *)&bih.bi_size));\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i,\n\t\t\t\t\t\t\t       str2ulong((unsigned char *)&bih.bi_size));\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->v_codecf_off = header_offset + i+16;\n\n\t\t\t\t\t\tmemcpy(AVI->compressor2, hdrl_data+i+16, 4);\n\t\t\t\t\t\tAVI->compressor2[4] = 0;\n\n\t\t\t\t\t\tif (n>40) {\n\t\t\t\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\t\t\tAVI->extradata_size = (u32) (n - 40);\n\t\t\t\t\t\t\tAVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);\n\t\t\t\t\t\t\tif (!AVI->extradata) ERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t\t\t\t\tmemcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\talWAVEFORMATEX *wfe;\n\t\t\t\t\t\tchar *nwfe;\n\t\t\t\t\t\tint wfes;\n\n\t\t\t\t\t\tif ((u32) (hdrl_len - i) < sizeof(alWAVEFORMATEX))\n\t\t\t\t\t\t\twfes = hdrl_len - i;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twfes = sizeof(alWAVEFORMATEX);\n\t\t\t\t\t\twfe = (alWAVEFORMATEX *)gf_malloc(sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\tif (wfe != NULL) {\n\t\t\t\t\t\t\tmemset(wfe, 0, sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\t\tmemcpy(wfe, hdrl_data + i, wfes);\n\t\t\t\t\t\t\tif (str2ushort((unsigned char *)&wfe->cb_size) != 0) {\n\t\t\t\t\t\t\t\tnwfe = (char *)\n\t\t\t\t\t\t\t\t       gf_realloc(wfe, sizeof(alWAVEFORMATEX) +\n\t\t\t\t\t\t\t\t                  str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\tif (nwfe != 0) {\n\t\t\t\t\t\t\t\t\ts64 lpos = gf_ftell(AVI->fdes);\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, header_offset + i + sizeof(alWAVEFORMATEX),\n\t\t\t\t\t\t\t\t\t         SEEK_SET);\n\t\t\t\t\t\t\t\t\twfe = (alWAVEFORMATEX *)nwfe;\n\t\t\t\t\t\t\t\t\tnwfe = &nwfe[sizeof(alWAVEFORMATEX)];\n\t\t\t\t\t\t\t\t\tavi_read(AVI->fdes, nwfe,\n\t\t\t\t\t\t\t\t\t         str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, lpos, SEEK_SET);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tAVI->wave_format_ex[AVI->aptr] = wfe;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );\n\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codecf_off = header_offset + i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);\n\t\t\t\t\t\t//ThOe: read mp3bitrate\n\t\t\t\t\t\tAVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;\n\t\t\t\t\t\t//:ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n\t\t\t\t\t\t//            auds_strf_seen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) // V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->dwSize = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->video_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->nEntriesInUse = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->video_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->fcc[0], AVI->video_superindex->fcc[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->fcc[2], AVI->video_superindex->fcc[3]));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->video_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->video_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->video_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));\n#endif\n\n\t\t\t\t\t\tAVI->is_opendml = 1;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) // A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->nEntriesInUse = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->stdindex = NULL;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->fcc));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->dwChunkId[0]));\n#endif\n\n\t\t\t\t\t}\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if((strnicmp((char*)hdrl_data+i,\"JUNK\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"strn\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"vprp\",4) == 0)) {\n\t\t\t\t\ti += 8;\n\t\t\t\t\t// do not reset lasttag\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tlasttag = 0;\n\t\t\t\t}\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] adding %ld bytes\\n\", (int int)n));\n\n\t\t\t\ti += (u32) n;\n\t\t\t}\n\n\tgf_free(hdrl_data);\n\n\tif(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\tAVI->video_tag[0] = AVI->video_strn/10 + '0';\n\tAVI->video_tag[1] = AVI->video_strn%10 + '0';\n\tAVI->video_tag[2] = 'd';\n\tAVI->video_tag[3] = 'b';\n\n\t/* Audio tag is set to \"99wb\" if no audio present */\n\tif(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;\n\n\t{\n\t\tint tk=0;\n\t\tfor(j=0; j<AVI->anum+1; ++j) {\n\t\t\tif (j == AVI->video_strn) continue;\n\t\t\tAVI->track[tk].audio_tag[0] = j/10 + '0';\n\t\t\tAVI->track[tk].audio_tag[1] = j%10 + '0';\n\t\t\tAVI->track[tk].audio_tag[2] = 'w';\n\t\t\tAVI->track[tk].audio_tag[3] = 'b';\n\t\t\t++tk;\n\t\t}\n\t}\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\n\tif(!getIndex) return(0);\n\n\t/* if the file has an idx1, check if this is relative\n\t   to the start of the file or to the start of the movi list */\n\n\tidx_type = 0;\n\n\tif(AVI->idx)\n\t{\n\t\ts64 pos, len;\n\n\t\t/* Search the first videoframe in the idx1 and look where\n\t\t   it is in the file */\n\n\t\tfor(i=0; i<AVI->n_idx; i++)\n\t\t\tif( strnicmp((char *)AVI->idx[i],(char *)AVI->video_tag,3)==0 ) break;\n\t\tif(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\t\tpos = str2ulong(AVI->idx[i]+ 8);\n\t\tlen = str2ulong(AVI->idx[i]+12);\n\n\t\tgf_fseek(AVI->fdes,pos,SEEK_SET);\n\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t{\n\t\t\t\tidx_type = 1; /* Index from start of file */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);\n\t\t\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t\t\t{\n\t\t\t\t\t\tidx_type = 2; /* Index from start of movi list */\n\t\t\t\t\t}\n\t\t\t}\n\t\t/* idx_type remains 0 if neither of the two tests above succeeds */\n\t}\n\n\n\tif(idx_type == 0 && !AVI->is_opendml && !AVI->total_frames)\n\t{\n\t\t/* we must search through the file to get the index */\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\t\t\t/* The movi list may contain sub-lists, ignore them */\n\n\t\t\tif(strnicmp(data,\"LIST\",4)==0)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,4,SEEK_CUR);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\tif( ( (data[2]=='d' || data[2]=='D') &&\n\t\t\t        (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )\n\t\t\t        || ( (data[2]=='w' || data[2]=='W') &&\n\t\t\t             (data[3]=='b' || data[3]=='B') ) )\n\t\t\t{\n\t\t\t\tu64 __pos = gf_ftell(AVI->fdes) - 8;\n\t\t\t\tavi_add_index_entry(AVI,(unsigned char *)data,0,__pos,n);\n\t\t\t}\n\n\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t}\n\t\tidx_type = 1;\n\t}\n\n\t// ************************\n\t// OPENDML\n\t// ************************\n\n\t// read extended index chunks\n\tif (AVI->is_opendml) {\n\t\tu64 offset = 0;\n\t\thdrl_len = 4+4+2+1+1+4+4+8+4;\n\t\tchar *en, *chunk_start;\n\t\tint k = 0;\n\t\tu32 audtr = 0;\n\t\tu32 nrEntries = 0;\n\n\t\tAVI->video_index = NULL;\n\n\t\tnvi = 0;\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\t\t\tnai[audtr] = 0;\n\t\t\ttot[audtr] = 0;\n\t\t}\n\n\t\t// ************************\n\t\t// VIDEO\n\t\t// ************************\n\n\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; j++) {\n\n\t\t\t// read from file\n\t\t\tchunk_start = en = (char*) gf_malloc ((u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) );\n\n\t\t\tif (gf_fseek(AVI->fdes, AVI->video_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) ) <= 0) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n#ifdef DEBUG_ODML\n\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:0] Video nrEntries %ld\\n\", j, nrEntries));\n#endif\n\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t// skip header\n\t\t\ten += hdrl_len;\n\t\t\tnvi += nrEntries;\n\t\t\tAVI->video_index = (video_index_entry *) gf_realloc (AVI->video_index, nvi * sizeof (video_index_entry));\n\t\t\tif (!AVI->video_index) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] out of mem (size = %ld)\\n\", nvi * sizeof (video_index_entry)));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\twhile (k < nvi) {\n\n\t\t\t\tAVI->video_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\ten += 4;\n\t\t\t\tAVI->video_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\tAVI->video_index[k].key = str2ulong_key((unsigned char*)en);\n\t\t\t\ten += 4;\n\n\t\t\t\t// completely empty chunk\n\t\t\t\tif (AVI->video_index[k].pos-offset == 0 && AVI->video_index[k].len == 0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tnvi--;\n\t\t\t\t}\n\n#ifdef DEBUG_ODML\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] POS 0x%llX len=%d key=%s offset (%llx) (%ld)\\n\", k,\n\t\t\t\t  AVI->video_index[k].pos,\n\t\t\t\t  (int)AVI->video_index[k].len,\n\t\t\t\t  AVI->video_index[k].key?\"yes\":\"no \", offset,\n\t\t\t\t  AVI->video_superindex->aIndex[j].dwSize));\n\t\t\t\t  */\n#endif\n\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\tgf_free(chunk_start);\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\t// this should deal with broken 'rec ' odml files.\n\t\tif (AVI->video_frames == 0) {\n\t\t\tAVI->is_opendml=0;\n\t\t\tgoto multiple_riff;\n\t\t}\n\n\t\t// ************************\n\t\t// AUDIO\n\t\t// ************************\n\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\n\t\t\tk = 0;\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] (%s) cannot read audio index for track %d\\n\", __FILE__, audtr));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j=0; j<AVI->track[audtr].audio_superindex->nEntriesInUse; j++) {\n\n\t\t\t\t// read from file\n\t\t\t\tchunk_start = en = (char*)gf_malloc ((u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len));\n\n\t\t\t\tif (gf_fseek(AVI->fdes, AVI->track[audtr].audio_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len)) <= 0) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n\t\t\t\t//if (nrEntries > 50) nrEntries = 2; // XXX\n#ifdef DEBUG_ODML\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] Audio nrEntries %ld\\n\", j, audtr, nrEntries));\n#endif\n\t\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t\t// skip header\n\t\t\t\ten += hdrl_len;\n\t\t\t\tnai[audtr] += nrEntries;\n\t\t\t\tAVI->track[audtr].audio_index = (audio_index_entry *) gf_realloc (AVI->track[audtr].audio_index, nai[audtr] * sizeof (audio_index_entry));\n\n\t\t\t\twhile (k < nai[audtr]) {\n\n\t\t\t\t\tAVI->track[audtr].audio_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].tot = tot[audtr];\n\t\t\t\t\ttot[audtr] += AVI->track[audtr].audio_index[k].len;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t/*\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] POS 0x%llX len=%d offset (%llx) (%ld)\\n\", k, audtr,\n\t\t\t\t\t  AVI->track[audtr].audio_index[k].pos,\n\t\t\t\t\t  (int)AVI->track[audtr].audio_index[k].len,\n\t\t\t\t\t  offset, AVI->track[audtr].audio_superindex->aIndex[j].dwSize));\n\t\t\t\t\t  */\n#endif\n\n\t\t\t\t\t++k;\n\t\t\t\t}\n\n\t\t\t\tgf_free(chunk_start);\n\t\t\t}\n\n\t\t\tAVI->track[audtr].audio_chunks = nai[audtr];\n\t\t\tAVI->track[audtr].audio_bytes = tot[audtr];\n\t\t}\n\t} // is opendml\n\n\telse if (AVI->total_frames && !AVI->is_opendml && idx_type==0) {\n\n\t\t// *********************\n\t\t// MULTIPLE RIFF CHUNKS (and no index)\n\t\t// *********************\n\nmultiple_riff:\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Reconstructing index...\"));\n\n\t\t// Number of frames; only one audio track supported\n\t\tnvi = AVI->video_frames = AVI->total_frames;\n\t\tnai[0] = AVI->track[0].audio_chunks = AVI->total_frames;\n\t\tfor(j=1; j<AVI->anum; ++j) AVI->track[j].audio_chunks = 0;\n\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\taud_chunks = AVI->total_frames;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif (nvi >= AVI->total_frames) break;\n\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\n\t\t\tj=0;\n\n\t\t\tif (aud_chunks - nai[j] -1 <= 0) {\n\t\t\t\taud_chunks += AVI->total_frames;\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *)\n\t\t\t\t                            gf_realloc( AVI->track[j].audio_index, (aud_chunks+1)*sizeof(audio_index_entry));\n\t\t\t\tif (!AVI->track[j].audio_index) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib -- no mem\\n\"));\n\t\t\t\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\t// VIDEO\n\t\t\tif(\n\t\t\t    (data[0]=='0' || data[1]=='0') &&\n\t\t\t    (data[2]=='d' || data[2]=='D') &&\n\t\t\t    (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') ) {\n\n\t\t\t\tAVI->video_index[nvi].key = 0x0;\n\t\t\t\tAVI->video_index[nvi].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->video_index[nvi].len = (u32) n;\n\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Frame %ld pos %\"LLD\" len %\"LLD\" key %ld\\n\",\n\t\t\t\t    nvi, AVI->video_index[nvi].pos,  AVI->video_index[nvi].len, (long)AVI->video_index[nvi].key));\n\t\t\t\t    */\n\t\t\t\tnvi++;\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\n\t\t\t//AUDIO\n\t\t\telse if(\n\t\t\t    (data[0]=='0' || data[1]=='1') &&\n\t\t\t    (data[2]=='w' || data[2]=='W') &&\n\t\t\t    (data[3]=='b' || data[3]=='B') ) {\n\n\n\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->track[j].audio_index[nai[j]].len = (u32) n;\n\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\tnai[j]++;\n\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgf_fseek(AVI->fdes,-4,SEEK_CUR);\n\t\t\t}\n\n\t\t}\n\t\tif (nvi < AVI->total_frames) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[avilib] Uh? Some frames seems missing (%ld/%d)\\n\",\n\t\t\t        nvi,  AVI->total_frames));\n\t\t}\n\n\n\t\tAVI->video_frames = nvi;\n\t\tAVI->track[0].audio_chunks = nai[0];\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] done. nvi=%ld nai=%ld tot=%ld\\n\", nvi, nai[0], tot[0]));\n\n\t} // total_frames but no indx chunk (xawtv does this)\n\n\telse\n\n\t{\n\t\t// ******************\n\t\t// NO OPENDML\n\t\t// ******************\n\n\t\t/* Now generate the video index and audio index arrays */\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) nai[j] = 0;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) nvi++;\n\n\t\t\tfor(j=0; j<AVI->anum; ++j) if(strnicmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];\n\n\n\t\tif(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\tioff = idx_type == 1 ? 8 : (u32)AVI->movi_start+4;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\t//video\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) {\n\t\t\t\tAVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);\n\t\t\t\tAVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\tAVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\tnvi++;\n\t\t\t}\n\n\t\t\t//audio\n\t\t\tfor(j=0; j<AVI->anum; ++j) {\n\n\t\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\t\tnai[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\n\t} // is no opendml\n\n\t/* Reposition the file */\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\tAVI->video_pos = 0;\n\n\treturn(0);\n}\n\nint AVI_video_frames(avi_t *AVI)\n{\n\treturn AVI->video_frames;\n}\nint  AVI_video_width(avi_t *AVI)\n{\n\treturn AVI->width;\n}\nint  AVI_video_height(avi_t *AVI)\n{\n\treturn AVI->height;\n}\ndouble AVI_frame_rate(avi_t *AVI)\n{\n\treturn AVI->fps;\n}\nchar* AVI_video_compressor(avi_t *AVI)\n{\n\treturn AVI->compressor2;\n}\n\n#if 0\nint AVI_max_video_chunk(avi_t *AVI)\n{\n\treturn AVI->max_len;\n}\n#endif\n\nint AVI_audio_tracks(avi_t *AVI)\n{\n\treturn(AVI->anum);\n}\n\nint AVI_audio_channels(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_chans;\n}\n\nint AVI_audio_mp3rate(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].mp3rate;\n}\n\n#if 0 //unused\nint AVI_audio_padrate(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].padrate;\n}\n#endif\n\nint AVI_audio_bits(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_bits;\n}\n\nint AVI_audio_format(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_fmt;\n}\n\nint AVI_audio_rate(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_rate;\n}\n\n\nint AVI_frame_size(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(frame < 0 || frame >= AVI->video_frames) return 0;\n\treturn (u32) (AVI->video_index[frame].len);\n}\n\nint AVI_audio_size(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(frame < 0 || frame >= AVI->track[AVI->aptr].audio_chunks) return -1;\n\treturn (u32) (AVI->track[AVI->aptr].audio_index[frame].len);\n}\n\nu64 AVI_get_video_position(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn (u64) -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn (u64) -1;\n\t}\n\n\tif(frame < 0 || frame >= AVI->video_frames) return 0;\n\treturn(AVI->video_index[frame].pos);\n}\n\n\nint AVI_seek_start(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\tAVI->video_pos = 0;\n\treturn 0;\n}\n\nint AVI_set_video_position(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif (frame < 0 ) frame = 0;\n\tAVI->video_pos = frame;\n\treturn 0;\n}\n\n#if 0 //unused\nint AVI_set_audio_bitrate(avi_t *AVI, int bitrate)\n{\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tAVI->track[AVI->aptr].mp3rate = bitrate;\n\treturn 0;\n}\n#endif\n\nint AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe)\n{\n\tint n;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n\tn = (u32) AVI->video_index[AVI->video_pos].len;\n\n\t*keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\n\tif (vidbuf == NULL) {\n\t\tAVI->video_pos++;\n\t\treturn n;\n\t}\n\n\tgf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\n\tif (avi_read(AVI->fdes,vidbuf,n) != (u32) n)\n\t{\n\t\tAVI_errno = AVI_ERR_READ;\n\t\treturn -1;\n\t}\n\n\tAVI->video_pos++;\n\n\treturn n;\n}\n\n#if 0 //unused\nint AVI_get_audio_position_index(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index) {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\treturn (AVI->track[AVI->aptr].audio_posc);\n}\n\nint AVI_set_audio_position_index(avi_t *AVI, int indexpos)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tif(indexpos > AVI->track[AVI->aptr].audio_chunks)     {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tAVI->track[AVI->aptr].audio_posc = indexpos;\n\tAVI->track[AVI->aptr].audio_posb = 0;\n\n\treturn 0;\n}\n#endif\n\n\nint AVI_set_audio_position(avi_t *AVI, int byte)\n{\n\tint n0, n1;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(byte < 0) byte = 0;\n\n\t/* Binary search in the audio chunks */\n\n\tn0 = 0;\n\tn1 = AVI->track[AVI->aptr].audio_chunks;\n\n\twhile(n0<n1-1)\n\t{\n\t\tint n = (n0+n1)/2;\n\t\tif(AVI->track[AVI->aptr].audio_index[n].tot>(u32) byte)\n\t\t\tn1 = n;\n\t\telse\n\t\t\tn0 = n;\n\t}\n\n\tAVI->track[AVI->aptr].audio_posc = n0;\n\tAVI->track[AVI->aptr].audio_posb = (u32) (byte - AVI->track[AVI->aptr].audio_index[n0].tot);\n\n\treturn 0;\n}\n\n\nint AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous)\n{\n\tint nr, todo;\n\ts64 pos;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tnr = 0; /* total number of bytes read */\n\n\tif (bytes==0) {\n\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t}\n\n\t*continuous = 1;\n\twhile(bytes>0)\n\t{\n\t\ts64 ret;\n\t\tint left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb);\n\t\tif(left==0)\n\t\t{\n\t\t\tif(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n\t\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t\t\t*continuous = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(bytes<left)\n\t\t\ttodo = bytes;\n\t\telse\n\t\t\ttodo = left;\n\t\tpos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n\t\tgf_fseek(AVI->fdes, pos, SEEK_SET);\n\t\tif ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo)\n\t\t{\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] XXX pos = %\"LLD\", ret = %\"LLD\", todo = %ld\\n\", pos, ret, todo));\n\t\t\tAVI_errno = AVI_ERR_READ;\n\t\t\treturn -1;\n\t\t}\n\t\tbytes -= todo;\n\t\tnr    += todo;\n\t\tAVI->track[AVI->aptr].audio_posb += todo;\n\t}\n\n\treturn nr;\n}\n\n\n#if 0 //unused\n/* AVI_read_data: Special routine for reading the next audio or video chunk\n                  without having an index of the file. */\n\nint AVI_read_data(avi_t *AVI, char *vidbuf, int max_vidbuf,\n                  char *audbuf, int max_audbuf,\n                  int *len)\n{\n\n\t/*\n\t * Return codes:\n\t *\n\t *    1 = video data read\n\t *    2 = audio data read\n\t *    0 = reached EOF\n\t *   -1 = video buffer too small\n\t *   -2 = audio buffer too small\n\t */\n\n\ts64 n;\n\tchar data[8];\n\n\tif(AVI->mode==AVI_MODE_WRITE) return 0;\n\n\twhile(1)\n\t{\n\t\t/* Read tag and length */\n\n\t\tif( avi_read(AVI->fdes,data,8) != 8 ) return 0;\n\n\t\t/* if we got a list tag, ignore it */\n\n\t\tif(strnicmp(data,\"LIST\",4) == 0)\n\t\t{\n\t\t\tgf_fseek(AVI->fdes,4,SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = PAD_EVEN(str2ulong((unsigned char *)data+4));\n\n\t\tif(strnicmp(data,AVI->video_tag,3) == 0)\n\t\t{\n\t\t\t*len = (u32) n;\n\t\t\tAVI->video_pos++;\n\t\t\tif(n>max_vidbuf)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(avi_read(AVI->fdes,vidbuf, (u32) n) != n ) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\telse if(strnicmp(data,AVI->track[AVI->aptr].audio_tag,4) == 0)\n\t\t{\n\t\t\t*len = (u32) n;\n\t\t\tif(n>max_audbuf)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tif(avi_read(AVI->fdes,audbuf, (u32) n) != n ) return 0;\n\t\t\treturn 2;\n\t\t\tbreak;\n\t\t}\n\t\telse if(gf_fseek(AVI->fdes,n,SEEK_CUR) == (u64) -1)  return 0;\n\t}\n}\n\nu64 AVI_max_size(void)\n{\n\treturn((u64) AVI_MAX_LEN);\n}\n#endif\n\n\n#endif /*GPAC_DISABLE_AVILIB*/\n"], "filenames": ["src/media_tools/avilib.c"], "buggy_code_start_loc": [1887], "buggy_code_end_loc": [2095], "fixing_code_start_loc": [1887], "fixing_code_end_loc": [2099], "type": "CWE-835", "message": "Inf loop in GitHub repository gpac/gpac prior to 2.1.0-DEV.", "other": {"cve": {"id": "CVE-2022-1222", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-04T10:15:08.567", "lastModified": "2023-05-27T04:15:20.260", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Inf loop in GitHub repository gpac/gpac prior to 2.1.0-DEV."}, {"lang": "es", "value": "Un bucle de Informaci\u00f3n en el repositorio de GitHub gpac/gpac versiones anteriores a 2.1.0-DEV"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0", "matchCriteriaId": "668F3068-DA1D-4B5B-8AFB-B904259711A7"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/7f060bbb72966cae80d6fee338d0b07fa3fc06e1", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/f8cb85b8-7ff3-47f1-a9a6-7080eb371a3d", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/7f060bbb72966cae80d6fee338d0b07fa3fc06e1"}}