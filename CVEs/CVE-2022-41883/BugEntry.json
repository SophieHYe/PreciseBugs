{"buggy_code": ["/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/common_runtime/eager/execute.h\"\n\n#include <algorithm>\n#include <cstddef>\n#include <optional>\n#include <vector>\n\n// clang-format off\n// Required for IS_MOBILE_PLATFORM\n#include \"absl/container/btree_map.h\"\n#include \"absl/container/flat_hash_set.h\"\n#include \"absl/strings/str_replace.h\"\n#include \"tensorflow/core/common_runtime/eager/eager_operation.h\"\n#include \"tensorflow/core/framework/cancellation.h\"\n#include \"tensorflow/core/framework/function.pb.h\"\n#include \"tensorflow/core/framework/kernel_def.pb.h\"\n#include \"tensorflow/core/framework/node_def.pb.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/lib/core/refcount.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/platform.h\"\n#include \"tensorflow/core/platform/protobuf.h\"\n\n// clang-format on\n\n#include \"absl/container/inlined_vector.h\"\n#include \"absl/strings/match.h\"\n#include \"absl/strings/str_cat.h\"\n#include \"absl/types/optional.h\"\n#include \"tensorflow/c/tf_tensor_internal.h\"\n#include \"tensorflow/compiler/jit/defs.h\"\n#include \"tensorflow/core/common_runtime/colocation_graph.h\"\n#include \"tensorflow/core/common_runtime/device.h\"\n#include \"tensorflow/core/common_runtime/device_set.h\"\n#include \"tensorflow/core/common_runtime/eager/context.h\"\n#include \"tensorflow/core/common_runtime/eager/copy_to_device_node.h\"\n#include \"tensorflow/core/common_runtime/eager/execute_node.h\"\n#include \"tensorflow/core/common_runtime/eager/kernel_and_device.h\"\n#include \"tensorflow/core/common_runtime/eager/tensor_handle.h\"\n#include \"tensorflow/core/framework/dataset.h\"\n#include \"tensorflow/core/framework/function.h\"\n#include \"tensorflow/core/framework/logging.h\"\n#include \"tensorflow/core/framework/node_def_util.h\"\n#include \"tensorflow/core/framework/tensor_reference.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/platform/statusor.h\"\n#include \"tensorflow/core/profiler/lib/scoped_memory_debug_annotation.h\"\n#include \"tensorflow/core/profiler/lib/traceme.h\"\n#include \"tensorflow/core/protobuf/error_codes.pb.h\"\n#include \"tensorflow/core/util/device_name_utils.h\"\n#if !defined(IS_MOBILE_PLATFORM)\n#include \"tensorflow/core/distributed_runtime/eager/eager_client.h\"\n#include \"tensorflow/core/distributed_runtime/eager/remote_copy_node.h\"\n#include \"tensorflow/core/distributed_runtime/eager/remote_mgr.h\"\n#include \"tensorflow/core/distributed_runtime/eager/remote_execute_node.h\"\n#include \"tensorflow/core/protobuf/remote_tensor_handle.pb.h\"\n#endif  // IS_MOBILE_PLATFORM\n#include \"tensorflow/core/common_runtime/eager/eager_op_rewrite_registry.h\"\n#include \"tensorflow/core/framework/step_stats.pb.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/gtl/cleanup.h\"\n#include \"tensorflow/core/lib/gtl/flatset.h\"\n#include \"tensorflow/core/lib/random/random.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/util/ptr_util.h\"\n#include \"tensorflow/core/util/util.h\"\n\n#ifdef INTEL_MKL\n#include \"tensorflow/core/graph/mkl_graph_util.h\"\n#endif\n\nnamespace tensorflow {\n\nnamespace {\n\nconst string& DeviceNameOrUnspecified(Device* device) {\n  static string* unspecified_string = new string(\"<unspecified>\");\n  return (device == nullptr) ? *unspecified_string : device->name();\n}\n\n// Returns whether a kernel should be cached.\nbool KernelCacheEnabled(const OpDef& op_def) {\n  if (data::DatasetOpKernel::IsDatasetOp(op_def)) {\n    return false;\n  }\n  // TODO(b/162540360): Revisit a way to mark kernels as uncachable once we have\n  // 5+ kernels to exclude.\n  return true;\n}\n\n// This function expects *handle to point to an existing tensor handle that is\n// currently on \"handle_device\", but where the operation expects that input to\n// reside on \"expected_input_device\".  The function will arrange for this\n// transfer to happen and will return OK on success and will storage a new\n// handle to the equivalent tensor on the correct device in \"*result\".  Or if an\n// error is encountered, it will return a non-OK status and set \"*result\" to\n// nullptr.\n//\n// `op_device` is passed in explicitly because `op->device()` might be\n// unset and we might have selected some specific device to run this op on.\nStatus CopyInputToExpectedDevice(EagerContext* ctx, EagerOperation* op,\n                                 Device* op_device,\n                                 TensorHandle* handle,  // op->Inputs()[i]\n                                 int i, Device* handle_device,\n                                 Device* expected_input_device,\n                                 TensorHandle** result) {\n  VLOG(6) << \"Expected input device: \" << expected_input_device->name()\n          << \"; handle_device: \" << handle_device->name();\n  // Should only be called when these don't match\n  DCHECK(expected_input_device != handle_device);\n  *result = nullptr;\n  const string& op_device_name = DeviceNameOrUnspecified(op_device);\n\n  switch (ctx->GetDevicePlacementPolicy()) {\n    case DEVICE_PLACEMENT_SILENT_FOR_INT32:\n      // TODO(xpan): See if we could bubble python related error up\n      // to python level.\n      if (handle->dtype == DT_INT32) {\n        // Note: enabling silent copies of int32 tensors to match behavior\n        // of graph mode.\n        break;\n      }\n      VLOG(6) << \"DevicePlacementPolicy: DEVICE_PLACEMENT_SILENT_FOR_INT32 but \"\n                 \"input type is not INT32.\";\n      TF_FALLTHROUGH_INTENDED;\n    case DEVICE_PLACEMENT_EXPLICIT:\n      // tf.identity is allowed to copy, as indicated in the error message\n      // below.\n      if (op->Name() == \"Identity\" ||\n          op->Name() == \"IdentityN\"\n          // Constants start on CPU:0 and are copied via EagerConst to the\n          // current device.\n          || op->Name() == \"_EagerConst\") {\n        break;\n      }\n      return errors::InvalidArgument(\n          \"Tensors on conflicting devices:\"\n          \" cannot compute \",\n          op->Name(), \" as input #\", i, \" was expected to be on \",\n          expected_input_device->name(), \" but is actually on \",\n          handle_device->name(), \" (operation running on \", op_device_name, \")\",\n          \" Tensors can be copied explicitly using:\"\n          \" `with tf.device(device_name): x = tf.identity(x)`\"\n          \" or transparently copied by using\"\n          \" tf.config.experimental.set_device_policy('silent').\"\n          \" Copying tensors between devices may slow down your model\");\n    case DEVICE_PLACEMENT_WARN:\n      LOG(WARNING) << \"before computing \" << op->Name() << \" input #\" << i\n                   << \" was expected to be on \" << expected_input_device->name()\n                   << \" but is actually on \" << handle_device->name()\n                   << \" (operation running on \" << op_device_name\n                   << \"). This triggers a copy which can be a performance \"\n                      \"bottleneck.\";\n      break;\n    case DEVICE_PLACEMENT_SILENT:  // Do nothing.\n      break;\n  }\n  // We are only here if the policy is warn or silent copies, so we should\n  // trigger a copy.\n  TensorHandle* result_handle = nullptr;\n  profiler::TraceMe activity(\n      [&] {\n        return absl::StrCat(\"_Send input \", i, \" from \", handle_device->name(),\n                            \" to \", expected_input_device->name());\n      },\n      profiler::TraceMeLevel::kInfo);\n  Status status =\n      EagerCopyToDevice(handle, ctx, &op->Executor(), expected_input_device,\n                        /* mirror= */ true, &result_handle);\n  activity.Stop();\n  if (!status.ok()) {\n    return Status(\n        status.code(),\n        absl::StrCat(\"Failed copying input tensor from \", handle_device->name(),\n                     \" to \", expected_input_device->name(), \" in order to run \",\n                     op->Name(), \": \", status.error_message()));\n  }\n\n  *result = result_handle;\n\n  return OkStatus();\n}\n\n// `op_device_name` the name of the device on which the op will run, if any.\n// For functions running using function library runtime, the device can be\n// unspecified.\nStatus ValidateInputTypeAndPlacement(\n    EagerContext* ctx, EagerOperation* op,\n    const core::RefCountPtr<KernelAndDevice>& kernel) {\n  profiler::TraceMe activity(\"ValidateInputTypeAndPlacement\",\n                             profiler::TraceMeLevel::kInfo);\n  const int n_inputs = op->Inputs().size();\n  if (kernel->num_inputs() != n_inputs) {\n    return errors::InvalidArgument(\"expected \", kernel->num_inputs(),\n                                   \" inputs, got \", n_inputs);\n  }\n  const bool is_function = kernel->IsFunction();\n  if (n_inputs > 0) {\n    const DataType* input_types = &kernel->input_dtypes()[0];\n    const absl::InlinedVector<TensorHandle*, 4>* handles;\n    TF_RETURN_IF_ERROR(op->TensorHandleInputs(&handles));\n    for (int i = 0; i < n_inputs; ++i) {\n      TensorHandle* handle = (*handles)[i];\n      Device* expected_device = kernel->InputDevice(i);\n      if (!kernel->IsFunction() && handle->Type() == TensorHandle::PACKED) {\n        // Extract a handle on the op device from a packed input.\n        // This happens when a function is marked for XLA compilation.\n        // MaybePackInputTensor guarantees that a primitive op has no packed\n        // input at this point.\n        for (int j = 0; j < handle->NumPackedHandles(); ++j) {\n          TensorHandle* h = nullptr;\n          TF_RETURN_IF_ERROR(handle->ExtractPackedHandle(j, &h));\n          if ((h->op_device() != nullptr) &&\n              (h->op_device()->name() == op->DeviceName())) {\n            op->UpdateInput(i, h);\n            handle = h;\n            break;\n          }\n        }\n      }\n      Device* handle_device = handle->DeviceOrHostCPU(*ctx);\n      const bool maybe_copy =\n          !is_function || handle->Type() != TensorHandle::REMOTE;\n      VLOG(6) << \"!is_function: \" << !is_function;\n      VLOG(6) << \"handle->Type(): \" << handle->Type();\n      // If the input is already on the right device, then nothing to do.\n      if (expected_device != handle_device && maybe_copy) {\n        TF_RETURN_IF_ERROR(CopyInputToExpectedDevice(ctx, op, kernel->device(),\n                                                     handle, i, handle_device,\n                                                     expected_device, &handle));\n        op->UpdateInput(i, handle);\n        // Unref handle since it has a ref as an input now\n        handle->Unref();\n      }\n      if (handle->dtype != input_types[i]) {\n        return errors::InvalidArgument(\n            \"cannot compute \", op->Name(), \" as input #\", i, \"(zero-based)\",\n            \" was expected to be a \", DataTypeString(input_types[i]),\n            \" tensor but is a \", DataTypeString(handle->dtype), \" tensor\");\n      }\n    }\n  }\n  return OkStatus();\n}\n\nStatus GetOutputDTypes(EagerOperation* op, DataTypeVector* output_dtypes) {\n  const auto& node_def = op->MutableAttrs()->BuildNodeDef();\n  const OpDef* op_def = nullptr;\n\n  const FunctionDef* function_def =\n      op->EagerContext().FuncLibDef()->Find(op->Name());\n  if (function_def != nullptr) {\n    op_def = &(function_def->signature());\n  } else {\n    TF_RETURN_IF_ERROR(OpDefForOp(op->Name().c_str(), &op_def));\n  }\n\n  TF_RETURN_IF_ERROR(OutputTypesForNode(node_def, *op_def, output_dtypes));\n\n  return OkStatus();\n}\n\ninline tensorflow::Fprint128 FingerprintCat128(const tensorflow::Fprint128& a,\n                                               const tensorflow::Fprint128& b) {\n  return {tensorflow::FingerprintCat64(a.low64, b.low64),\n          tensorflow::FingerprintCat64(a.high64, b.high64)};\n}\n\ninline tensorflow::Fprint128 FingerprintCat128(const tensorflow::Fprint128& a,\n                                               const int64_t b) {\n  auto x = tensorflow::FingerprintCat64(a.low64, b);\n  return {x, tensorflow::FingerprintCat64(a.high64, x)};\n}\n\nconst KernelDef* GetKernelDef(const EagerOperation& op, const NodeDef* node_def,\n                              const Device* op_device) {\n  if (node_def == nullptr || op_device == nullptr) return nullptr;\n  const KernelDef* kernel_def = nullptr;\n  Status s = FindKernelDef(DeviceType(op_device->device_type()), *node_def,\n                           &kernel_def,\n                           /*kernel_class_name=*/nullptr);\n  if (!s.ok()) return nullptr;\n  return kernel_def;\n}\n\nbool IsHostMemoryArg(const EagerOperation& op, const NodeDef* node_def,\n                     const Device* op_device, const KernelDef* kernel_def,\n                     const int port_id) {\n  if (op.is_function()) return false;\n  if (node_def == nullptr) return false;\n  if (kernel_def == nullptr || op_device == nullptr) return false;\n  const auto& host_memory_args = kernel_def->host_memory_arg();\n  const OpDef& op_def = OpRegistry::Global()->LookUp(op.Name())->op_def;\n  const int arg_id = OpPortIdToArgId(*node_def, op_def.input_arg(), port_id);\n  return std::find(host_memory_args.begin(), host_memory_args.end(),\n                   op_def.input_arg(arg_id).name()) != host_memory_args.end();\n}\n\nStatus GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,\n                         const bool is_host_memory_arg,\n                         TensorHandle* tensor_handle, Device** result) {\n  Device* cpu_device = ctx.HostCPU();\n  string device_name;\n  if (tensor_handle->Type() != TensorHandle::LOCAL) {\n    Device* device = tensor_handle->device();\n    device_name = device != nullptr ? device->name() : cpu_device->name();\n    *result = (device == nullptr ? cpu_device : device);\n  } else if (tensor_handle->dtype == DT_RESOURCE) {\n    // Use the resource's actual device because it is the device that will\n    // influence partitioning the multi-device function.\n    const Tensor* tensor;\n    // TODO(fishx): Avoid blocking here.\n    TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));\n    if (tensor->NumElements() == 0) {\n      return errors::InvalidArgument(\"Empty resource handle\");\n    }\n    const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);\n    device_name = handle.device();\n\n    Device* input_device;\n    TF_RETURN_IF_ERROR(\n        ctx.FindDeviceFromName(device_name.c_str(), &input_device));\n    *result = input_device;\n  } else {\n    Device* device = tensor_handle->device();\n    const bool is_tpu = device != nullptr && device->device_type() == \"TPU\";\n    // int32 return values can be placed on TPUs.\n    // int32 retrun values can be placed on device for eager operations.\n    const bool use_host_memory =\n        is_tpu || (!op.is_function() && device != cpu_device &&\n                   !is_host_memory_arg)\n            ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)\n            : MTypeFromDType(tensor_handle->dtype);\n    if (use_host_memory) {\n      *result = cpu_device;\n    } else {\n      // Eager ops executing as functions should have their preferred inputs set\n      // to the op's device. This allows us to avoid expensive D2H copies if a\n      // mirror of the tensor already exists on the op's device.\n      if (!op.is_function() && device != cpu_device && !is_host_memory_arg) {\n        device = absl::get<Device*>(op.Device());\n      }\n      *result = (device == nullptr ? cpu_device : device);\n    }\n  }\n  return OkStatus();\n}\n\n// Appends a TensorShape object to Fprint128 hash.\n// For best performance, we would like to avoid dynamic memory allocation in\n// this function.\n// If \"shape\" has unknown rank, we attach \"?\" to hashed content; otherwise we\n// attach every dim size to hashed content.\nvoid AppendTensorShapeToFingerprint(const PartialTensorShape& shape,\n                                    Fprint128* fingerprint) {\n  if (shape.unknown_rank()) {\n    char c = '?';\n    *fingerprint = FingerprintCat128(*fingerprint, c);\n  } else {\n    for (int i = 0; i < shape.dims(); i++) {\n      int64_t dim = shape.dim_size(i);\n      *fingerprint = FingerprintCat128(*fingerprint, dim);\n    }\n  }\n}\n\nStatus GetFuncAttr(const EagerOperation* op, const EagerContext& ctx,\n                   const char* attr_name, bool* value) {\n  Status status = op->Attrs().Get(attr_name, value);\n  if (status.ok()) {\n    VLOG(2) << \"Caller explicitly specifies \" << attr_name\n            << (value ? \"=true \" : \"=false, \") << op->DebugString();\n    return OkStatus();\n  }\n\n  const FunctionDef* function_def =\n      ctx.pflr()->GetFunctionLibraryDefinition()->Find(op->Name());\n  if (function_def == nullptr) {\n    return errors::NotFound(\"Failed to find function '\", op->Name(), \"'\");\n  }\n\n  status = GetNodeAttr(AttrSlice(&function_def->attr()), attr_name, value);\n  if (status.ok()) {\n    VLOG(2) << \"Function definition explicitly specifies \" << attr_name\n            << (value ? \"=true\" : \"=false\");\n    return OkStatus();\n  }\n  return status;\n}\n\nStatus MustCompileWithXLA(const EagerOperation* op, const EagerContext& ctx,\n                          bool* compile_with_xla) {\n  if (!op->is_function()) {\n    *compile_with_xla = false;\n    return OkStatus();\n  }\n\n  if (op->eager_func_params().has_value() &&\n      op->eager_func_params().value().is_component_function) {\n    // If the op is a component of a multi-device function, don't compile it\n    // with XLA.\n    *compile_with_xla = false;\n    return OkStatus();\n  }\n\n  Status status = GetFuncAttr(op, ctx, kXlaMustCompileAttr, compile_with_xla);\n  if (status.ok()) {\n    return OkStatus();\n  }\n\n  // No explicit requests. Compile for XLA devices by default.\n  if (op->GetDeviceParsedName().type == \"TPU\" ||\n      op->GetDeviceParsedName().type == \"XLA_GPU\" ||\n      op->GetDeviceParsedName().type == \"XLA_CPU\") {\n    VLOG(2) << \"Compiling \" << op->Name()\n            << \" with XLA because it is running on an XLA device \"\n            << op->GetDeviceParsedName().type;\n    *compile_with_xla = true;\n  } else {\n    *compile_with_xla = false;\n  }\n\n  return OkStatus();\n}\n\nStatus VerifyWrappableInCallOp(const OpDef& opdef, EagerOperation* op) {\n  absl::flat_hash_set<string> opdef_attrs;\n  for (const auto& attr : opdef.attr()) {\n    opdef_attrs.insert(attr.name());\n  }\n  const auto& node_def = op->MutableAttrs()->BuildNodeDef();\n  for (const auto& attr : node_def.attr()) {\n    if (opdef_attrs.find(attr.first) == opdef_attrs.end()) {\n      return errors::Unimplemented(\"EagerOperation: \", op->Name(),\n                                   \" has a private attr '\", attr.first, \"'.\");\n    }\n  }\n  return OkStatus();\n}\n\nusing ProtoArgListType = protobuf::RepeatedPtrField<OpDef_ArgDef>;\n\nstring EscapeOrigName(const string& orig_name) {\n  // Replace _ with __ in the original name to avoid name conflicts.\n  return absl::StrReplaceAll(orig_name, {{\"_\", \"__\"}});\n}\n\n// Variadic args are flattened during wrapping. This utility returns the name\n// of a flattened arg/attr.\nstring GetFlatName(const string orig_name, int index) {\n  return absl::StrCat(EscapeOrigName(orig_name), \"_\", index);\n}\n\n// Builds the name of the wrapping FunctionDef for an eager op.\n//\n// For ops without variadic inputs/outputs, the name is simply __wrapped_OpType.\n//\n// For ops with variadic inputs/outputs, the arity of each variadic attr is\n// encoded in the name. For example:\n//\n// IdentityN[T:[DT_FLOAT, DT_INT64]] -> __wrapped__IdentityN_T_2\n// Concat[N:2, T:DT_FLOAT] -> __wrapped__Concat_N_2\nStatus BuildWrappedOpName(EagerOperation* op, const OpDef& opdef,\n                          const AbstractOpAttrs* op_attrs, string* name) {\n  string fname = absl::StrCat(\"__wrapped__\", EscapeOrigName(op->Name()));\n  // For every variadic arg in `args`, populates `attr_to_len` with\n  // (attr_name, len(arg)).\n  auto FillAttrToLen = [op_attrs, op](\n                           const ProtoArgListType& args,\n                           absl::btree_map<string, int>* attr_to_len) {\n    for (const auto& arg : args) {\n      if (!arg.type_list_attr().empty()) {\n        gtl::InlinedVector<DataType, 4> type_list;\n        TF_RETURN_IF_ERROR(\n            op_attrs->GetTypeList(arg.type_list_attr(), &type_list));\n        (*attr_to_len)[arg.type_list_attr()] = type_list.size();\n      } else if (!arg.number_attr().empty()) {\n        int64_t number_attr;\n        if (!op_attrs->GetInt(arg.number_attr(), &number_attr)) {\n          return errors::Internal(\"Unable to read attr \", arg.number_attr(),\n                                  \" for op \", op->Name());\n        }\n        (*attr_to_len)[arg.number_attr()] = number_attr;\n      }\n    }\n    return OkStatus();\n  };\n  absl::btree_map<string, int> attr_to_len;\n  TF_RETURN_IF_ERROR(FillAttrToLen(opdef.input_arg(), &attr_to_len));\n  TF_RETURN_IF_ERROR(FillAttrToLen(opdef.output_arg(), &attr_to_len));\n  for (auto& name_len : attr_to_len) {\n    absl::StrAppend(&fname, \"_\", name_len.first, \"_\", name_len.second);\n  }\n  // The NodeDef in the FunctionDef gets placed on `op-DeviceName()` to ensure\n  // placement consistency with eager mode.\n  // TODO(b/200153278): Ideally we would just forward the call op's device at\n  // runtime but currently there is no way to do it so we incur the cost of\n  // creating extra FunctionDefs.\n  absl::StrAppend(&fname, \"_device_\", op->DeviceName());\n  *name = fname;\n  return OkStatus();\n}\n\n// Validates the node def. This is required when running in eager op as function\n// mode because this code path does not go through the _apply_op_helper's\n// validation (which is reached when executing in graph mode)\n// or the eager execution's validation (which is reached via the CreateOpKernel\n// call).\nStatus ValidateOp(EagerOperation* op) {\n  const NodeDef& node_def = op->MutableAttrs()->BuildNodeDef();\n  const OpDef* op_def;\n  TF_RETURN_IF_ERROR(OpRegistry::Global()->LookUpOpDef(node_def.op(), &op_def));\n  return ValidateNodeDef(node_def, *op_def);\n}\n\n// Builds the signature of the wrapping FunctionDef for an eager op.\n//\n// For ops without variadic inputs/outputs, the signature is the same as the\n// OpDef of the original op.\n//\n// Variadic inputs/outputs get flattened since we do not support executing\n// functions with variadic signatures.\n//\n// TODO(srbs): These examples should be tests.\n//\n// Examples:\n//\n// Mixed type list:\n//\n// op {\n//   name: \"IdentityN\"\n//   input_arg {\n//     name: \"input\"\n//     type_list_attr: \"T\"\n//   }\n//   output_arg {\n//     name: \"output\"\n//     type_list_attr: \"T\"\n//   }\n//   attr {\n//     name: \"T\"\n//     type: \"list(type)\"\n//     has_minimum: true\n//     minimum: 1\n//   }\n// }\n//\n// With two inputs T=[DT_FLOAT, DT_INT64] would convert to\n//\n// op {\n//   name: \"__wrapped__IdentityN_T_2\"\n//   input_arg {\n//     name: \"input_0\"\n//     type_attr: \"T_0\"\n//   }\n//   input_arg {\n//     name: \"input_1\"\n//     type_attr: \"T_1\"\n//   }\n//   output_arg {\n//     name: \"output_0\"\n//     type_attr: \"T_0\"\n//   }\n//   output_arg {\n//     name: \"output_1\"\n//     type_attr: \"T_1\"\n//   }\n//   attr {\n//     name: \"T_0\"\n//     type: \"type\"\n//   }\n//   attr {\n//     name: \"T_1\"\n//     type: \"type\"\n//   }\n//   attr {\n//     name: \"T\"\n//     type: \"list(type)\"\n//     has_minimum: true\n//     minimum: 1\n//   }\n// }\n//\n// Note that the list(type) attr is preserved so that it can get copied to the\n// inner op via a placeholder. This allows additional verification.\n//\n// Single type list:\n//\n// op {\n//   name: \"ConcatV2\"\n//   input_arg {\n//     name: \"values\"\n//     type_attr: \"T\"\n//     number_attr: \"N\"\n//   }\n//   attr {\n//     name: \"N\"\n//     type: \"int\"\n//     has_minimum: true\n//     minimum: 2\n//   }\n//   attr {\n//     name: \"T\"\n//     type: \"type\"\n//   }\n//   [axis, output, Tidx are simply copied]\n// }\n//\n// With two inputs N=2 would convert to:\n//\n// op {\n//   name: \"__wrapped__ConcatV2_N_2\"\n//   input_arg {\n//     name: \"values_0\"\n//     type_attr: \"T\"\n//   }\n//   input_arg {\n//     name: \"values_1\"\n//     type_attr: \"T\"\n//   }\n//   attr {\n//     name: \"N\"\n//     type: \"int\"\n//     has_minimum: true\n//     minimum: 2\n//   }\n//   attr {\n//     name: \"T\"\n//     type: \"type\"\n//   }\n//   [axis, output, Tidx are simply copied]\n// }\n//\n// Note that the N attr is preserved so that it can get copied to the\n// inner op via a placeholder. This allows additional verification.\nStatus BuildWrappedOpSignature(EagerOperation* op, const OpDef& opdef,\n                               const string& fname, OpDef& signature) {\n  signature = opdef;\n  signature.clear_input_arg();\n  signature.clear_output_arg();\n  signature.set_name(fname);\n  auto op_attrs = op->GetOpAttrs();\n  auto FillSignatureArgs = [op_attrs, op](\n                               const ProtoArgListType& opdef_args,\n                               ProtoArgListType* sig_args,\n                               absl::flat_hash_set<string>& new_attrs) {\n    for (const auto& arg : opdef_args) {\n      if (!arg.type_list_attr().empty()) {\n        gtl::InlinedVector<DataType, 4> type_list;\n        TF_RETURN_IF_ERROR(\n            op_attrs->GetTypeList(arg.type_list_attr(), &type_list));\n        for (size_t i = 0; i < type_list.size(); i++) {\n          auto arg_def = sig_args->Add();\n          arg_def->set_name(GetFlatName(arg.name(), i));\n          auto attr_name = GetFlatName(arg.type_list_attr(), i);\n          new_attrs.insert(attr_name);\n          arg_def->set_type_attr(std::move(attr_name));\n        }\n      } else if (!arg.number_attr().empty()) {\n        int64_t number_attr;\n        if (!op_attrs->GetInt(arg.number_attr(), &number_attr)) {\n          return errors::Internal(\"Unable to read attr \", arg.number_attr(),\n                                  \" for op \", op->Name());\n        }\n        for (int64_t i = 0; i < number_attr; i++) {\n          auto arg_def = sig_args->Add();\n          arg_def->set_name(GetFlatName(arg.name(), i));\n          if (!arg.type_attr().empty()) {\n            arg_def->set_type_attr(arg.type_attr());\n          } else {\n            arg_def->set_type(arg.type());\n          }\n        }\n      } else {\n        auto arg_def = sig_args->Add();\n        *arg_def = arg;\n        arg_def->set_name(EscapeOrigName(arg.name()));\n        if (!arg.type_attr().empty()) {\n          // Don't escape: type attrs are still referenced by the original name.\n          arg_def->set_type_attr(arg.type_attr());\n        }\n      }\n    }\n    return OkStatus();\n  };\n  absl::flat_hash_set<string> new_attrs;\n  TF_RETURN_IF_ERROR(FillSignatureArgs(\n      opdef.input_arg(), signature.mutable_input_arg(), new_attrs));\n  TF_RETURN_IF_ERROR(FillSignatureArgs(\n      opdef.output_arg(), signature.mutable_output_arg(), new_attrs));\n  for (auto& attr_name : new_attrs) {\n    auto attr_def = signature.mutable_attr()->Add();\n    attr_def->set_name(attr_name);\n    attr_def->set_type(\"type\");\n  }\n  return OkStatus();\n}\n\n// For mixed type inputs \"list(type)\" we create new attributes in the signature\n// for each element tensor (See examples in BuildWrappedOpSignature). Here\n// we construct the values for those attributes and set them on the wrapped op.\nStatus AddMixedTypeListAttrs(EagerOperation* wrapped_op,\n                             const AbstractOpAttrs* op_attrs,\n                             const OpDef& opdef) {\n  auto FillAttrsToAdd =\n      [op_attrs](const ProtoArgListType& opdef_args,\n                 absl::flat_hash_map<string, DataType>* attrs_to_add) {\n        for (const auto& arg : opdef_args) {\n          if (!arg.type_list_attr().empty()) {\n            gtl::InlinedVector<DataType, 4> type_list;\n            TF_RETURN_IF_ERROR(\n                op_attrs->GetTypeList(arg.type_list_attr(), &type_list));\n            for (size_t i = 0; i < type_list.size(); i++) {\n              auto attr_name = GetFlatName(arg.type_list_attr(), i);\n              (*attrs_to_add)[attr_name] = type_list[i];\n            }\n          }\n        }\n        return OkStatus();\n      };\n  absl::flat_hash_map<string, DataType> attrs_to_add;\n  TF_RETURN_IF_ERROR(FillAttrsToAdd(opdef.input_arg(), &attrs_to_add));\n  TF_RETURN_IF_ERROR(FillAttrsToAdd(opdef.output_arg(), &attrs_to_add));\n  for (auto& name_type : attrs_to_add) {\n    TF_RETURN_IF_ERROR(\n        wrapped_op->SetAttrType(name_type.first.data(), name_type.second));\n  }\n  // TODO(srbs): Rename all original attributes using EscapeOrigName.\n  return OkStatus();\n}\n\n// Maps the op's outputs to the function outputs. Mainly useful for variadic\n// outputs which need to be flattened.\nStatus PopulateRetMap(FunctionDef* fdef, const AbstractOpAttrs* op_attrs,\n                      const EagerOperation* op, const OpDef& opdef,\n                      const OpDef& signature, const string& node_name) {\n  int next_sig_output = 0;\n  for (size_t i = 0; i < opdef.output_arg_size(); i++) {\n    const auto& output_arg = opdef.output_arg(i);\n    if (!output_arg.type_list_attr().empty()) {\n      gtl::InlinedVector<DataType, 4> type_list;\n      TF_RETURN_IF_ERROR(\n          op_attrs->GetTypeList(output_arg.type_list_attr(), &type_list));\n      for (int j = 0; j < type_list.size(); j++) {\n        (*fdef->mutable_ret())[signature.output_arg(next_sig_output++).name()] =\n            absl::StrCat(node_name, \":\", output_arg.name(), \":\", j);\n      }\n    } else if (!output_arg.number_attr().empty()) {\n      int64_t number_attr;\n      if (!op_attrs->GetInt(output_arg.number_attr(), &number_attr)) {\n        return errors::Internal(\"Unable to read attr \",\n                                output_arg.number_attr(), \" for op \",\n                                op->Name());\n      }\n      for (int j = 0; j < number_attr; j++) {\n        (*fdef->mutable_ret())[signature.output_arg(next_sig_output++).name()] =\n            absl::StrCat(node_name, \":\", output_arg.name(), \":\", j);\n      }\n    } else {\n      (*fdef->mutable_ret())[signature.output_arg(next_sig_output++).name()] =\n          absl::StrCat(node_name, \":\", output_arg.name(), \":0\");\n    }\n  }\n  return OkStatus();\n}\n\n#ifdef INTEL_MKL\ninline void GetMKLNodeDef(NodeDef* ndef) {\n  // All MKL eager ops have `_kernel` private attribute that needs to be set\n  // to a fixed label.\n  AttrValue attr_kernel;\n  attr_kernel.set_s(mkl_op_registry::kMklNameChangeOpLabel);\n  (*ndef->mutable_attr()).insert({\"_kernel\", attr_kernel});\n}\n#endif  // INTEL_MKL\n\nStatus WrapInCallOp(EagerOperation* op, EagerOperation** wrapped_op) {\n  DCHECK(!op->is_function());\n  const OpDef& opdef = OpRegistry::Global()->LookUp(op->Name())->op_def;\n  // Raise an error for ops which don't support wrapping yet. This includes\n  // ops with list inputs/outputs and ops with private attrs.\n  // TODO(srbs): Support list inputs/outputs.\n  TF_RETURN_IF_ERROR(VerifyWrappableInCallOp(opdef, op));\n\n  // Build a FunctionDef containing op as a node and register with context.\n  // TODO(srbs): Here we are unable to distinguish between a FunctionDef for\n  // a wrapped eager op and an existing user defined function registered with\n  // the context e.g. with something like\n  // @tf.function\n  // def __wrapped__Add(x, y):\n  //   ...\n  // This can be avoided by introducing a dict in EagerContext that stores a\n  // mapping from the eager op's name to its unique FunctionDef name.\n  auto op_attrs = op->GetOpAttrs();\n  string fname;\n  TF_RETURN_IF_ERROR(BuildWrappedOpName(op, opdef, op_attrs, &fname));\n  if (!op->EagerContext().GetFunctionDef(fname)) {\n    FunctionDef fdef;\n    // Set signature.\n    TF_RETURN_IF_ERROR(\n        BuildWrappedOpSignature(op, opdef, fname, *fdef.mutable_signature()));\n    // Add node.\n    NodeDef* ndef = fdef.add_node_def();\n    ndef->set_op(op->Name());\n    ndef->set_name(op->Name());  // This could be anything.\n    const auto& signature = fdef.signature();\n    for (size_t i = 0; i < signature.input_arg_size(); i++) {\n      ndef->add_input(absl::StrCat(fdef.signature().input_arg(i).name(), \":0\"));\n    }\n    // TODO(srbs): Private attrs on the op are dropped here and applied to\n    // the call op instead. If this causes problems we might have to copy those\n    // attrs to this ndef. That would require updating fname to contain a hash\n    // of such attributes.\n    for (const auto& attr : opdef.attr()) {\n      (*ndef->mutable_attr())[attr.name()].set_placeholder(attr.name());\n    }\n    // Set the device of this node to be the exact same one that eager mode\n    // would have used.\n    // TODO(b/200153278): Ideally we would just forward the call op's device at\n    // runtime but currently there is no way to do it.\n    ndef->set_device(op->DeviceName());\n\n#ifdef INTEL_MKL\n    if (IsMKLEnabled() &&\n        absl::StartsWith(op->Name(), mkl_op_registry::kMklOpPrefix)) {\n      GetMKLNodeDef(ndef);\n    }\n#endif  // INTEL_MKL\n\n    // Set `ret` map.\n    TF_RETURN_IF_ERROR(\n        PopulateRetMap(&fdef, op_attrs, op, opdef, signature, ndef->name()));\n    VLOG(1) << fdef.DebugString();\n    TF_RETURN_IF_ERROR(op->EagerContext().AddFunctionDef(std::move(fdef)));\n  }\n  // Build the call op.\n  auto& ctx = op->EagerContext();\n  AbstractOperationPtr call_op(ctx.CreateOperation());\n  TF_RETURN_IF_ERROR(call_op->Reset(fname.c_str(), op->DeviceName().c_str()));\n  for (auto t : op->Inputs()) {\n    TF_RETURN_IF_ERROR(call_op->AddInput(t));\n  }\n  *wrapped_op = down_cast<EagerOperation*>(call_op.release());\n  // Attributes on the elementary eager operation are applied to the call op and\n  // to the NodeDef inside the FunctionDef. This allows us to have a single\n  // FunctionDef for different attribute values. When the function is\n  // instantiated, these attributes get forwarded to the NodeDef. This is done\n  // by setting the AttrValue.placeholder field for the NodeDef attrs.\n  (*wrapped_op)->AddAttrs(op_attrs);\n  return AddMixedTypeListAttrs(*wrapped_op, op_attrs, opdef);\n}\n\n// Necessary condition to place int args/retvals on device but not sufficient.\n// For eager operations return values can be placed on the device for use\n// by subsequent eager ops. E.g.\n// with tf.device(\"/GPU:0\"):\n//   x = tf.random_uniform(shape=(2, 2), maxval=5, dtype=tf.int32)\n//   y = tf.random_uniform(shape=(2, 2), maxval=5, dtype=tf.int32)\n//   z = tf.bitwise.bitwise_and(x, y)\n// In the above example `z` can use the outputs of `x` and `y` without needing\n// an H2D copy if x and y are left on-device.\nbool IntArgsAndRetvalsOnDevice(EagerOperation* op,\n                               const KernelDef* kernel_def) {\n  // We choose to leave `EagerConsts`\n  // on HOST to avoid `shape` and other arguments that are traditionally pinned\n  // to HostMemory from being placed on-device and then being copied to host via\n  // an expensive D2H transfer.\n  if (op->Name() == \"_EagerConst\") return false;\n\n  // Check if any of the Op's output_arg(s) are pinned to Host.\n  if (kernel_def == nullptr) return false;\n  const OpDef& op_def = OpRegistry::Global()->LookUp(op->Name())->op_def;\n  for (const string& host_memory_arg : kernel_def->host_memory_arg()) {\n    for (const auto& output_arg : op_def.output_arg()) {\n      if (output_arg.name() == host_memory_arg) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nStatusOr<Fprint128> GetKernelCacheKey(\n    const EagerOperation& op, const Fprint128& op_cache_key,\n    const std::vector<Device*>& input_device_ptrs,\n    const std::unordered_map<int, DtypeAndPartialTensorShape>&\n        input_resource_variable_dtypes_and_shapes) {\n  EagerContext& ctx = op.EagerContext();\n\n  Fprint128 cache_key = op_cache_key;\n  /// Include soft placement policy in cache key since the placement strategy\n  // can change and thus affect which kernel is picked.\n  cache_key = FingerprintCat128(cache_key, ctx.AllowSoftPlacement());\n\n  // Include run_eager_op_as_function policy in cache key since the execution\n  // strategy can change and affect which kernel is picked.\n  VLOG(3) << \"ctx.RunEagerOpAsFunction(): \" << ctx.RunEagerOpAsFunction();\n  cache_key = FingerprintCat128(cache_key, ctx.RunEagerOpAsFunction());\n\n  // When running in eager_op_as_function mode Send/Recv ops need to be\n  // placed on the same rendezvous to match the behaviour of eager mode.\n  bool reuse_rendezvous_for_functions =\n      (ctx.RunEagerOpAsFunction() && !op.is_function()) ||\n      ctx.GetReuseRendezvousForFunctions();\n  // The launch-time rendezvous reuse setting is bundled with the kernel, so we\n  // need to include it in the cache key.\n  cache_key = FingerprintCat128(cache_key, reuse_rendezvous_for_functions);\n\n  for (int i = 0, end = input_device_ptrs.size(); i < end; ++i) {\n    cache_key = FingerprintCat128(cache_key,\n                                  Fingerprint128(input_device_ptrs[i]->name()));\n\n    auto input_resource = input_resource_variable_dtypes_and_shapes.find(i);\n    if (input_resource != input_resource_variable_dtypes_and_shapes.end()) {\n      // const DtypeAndPartialTensorShape& dtype_and_shape\n      const DtypeAndPartialTensorShape& dtype_and_shape =\n          input_resource->second;\n      // Add _Arg index, dtype and shape to \"cache_key\".\n      cache_key = FingerprintCat128(cache_key, i);\n      cache_key = FingerprintCat128(cache_key, dtype_and_shape.dtype);\n      AppendTensorShapeToFingerprint(dtype_and_shape.shape, &cache_key);\n    }\n  }\n\n  return cache_key;\n}\n\n// Extracts function input info for `op` with `kernel_def`.\n// The following are extracted:\n//   `input_device_ptrs` - The input devices of `op`.\n//   `composite_devices` - Maps from a CompositeDevice name to a list of\n//     physical device names.\n//   `input_resource_variable_dtypes_shape` - A map from input index\n//     to dtype and shapes for resource inputs.\nStatus ExtractFunctionInputInfo(\n    EagerOperation* op, const KernelDef* kernel_def,\n    std::vector<Device*>& input_device_ptrs,\n    absl::flat_hash_map<string, const std::vector<string>*>& composite_devices,\n    std::unordered_map<int, DtypeAndPartialTensorShape>&\n        input_resource_variable_dtypes_and_shapes) {\n  profiler::TraceMe activity(\"EagerCopyToDevice\",\n                             profiler::TraceMeLevel::kInfo);\n  EagerContext& ctx = op->EagerContext();\n  input_device_ptrs.reserve(op->Inputs().size());\n  const absl::InlinedVector<TensorHandle*, 4>* inputs;\n  TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));\n  Device* op_device = nullptr;\n  const NodeDef* node_def = nullptr;\n  if (!op->is_function()) {\n    op_device = absl::get<Device*>(op->Device());\n    node_def = &op->MutableAttrs()->BuildNodeDef();\n  }\n  for (int i = 0, end = inputs->size(); i < end; ++i) {\n    TensorHandle* input = (*inputs)[i];\n\n    Device* input_device;\n    bool is_host_memory_arg =\n        IsHostMemoryArg(*op, node_def, op_device, kernel_def, i);\n    TF_RETURN_IF_ERROR(\n        GetDeviceForInput(*op, ctx, is_host_memory_arg, input, &input_device));\n    VLOG(1) << op->Name() << \":input:\" << i << \" \" << input_device->name();\n    input_device_ptrs.push_back(input_device);\n    CompositeDevice* composite_device = nullptr;\n    if (ctx.FindCompositeDeviceFromName(input_device->name(), &composite_device)\n            .ok()) {\n      composite_devices[input_device->name()] =\n          composite_device->underlying_devices();\n    }\n    if (input->dtype == DT_RESOURCE) {\n      // We only care about data type and shape for resource variable inputs.\n      // But we have no way to tell if input is resource variable (other than\n      // looking it up in ResourceMgr, which is slow). So we just get\n      // resource_dtypes_and_shapes for all DT_RESOURCE inputs. If\n      // resource_dtypes_and_shapes is not empty, take the first element.\n      std::vector<DtypeAndPartialTensorShape> resource_dtypes_and_shapes;\n      TF_RETURN_IF_ERROR(\n          input->GetResourceHandleDtypesAndShapes(&resource_dtypes_and_shapes));\n      if (!resource_dtypes_and_shapes.empty()) {\n        const DtypeAndPartialTensorShape& dtype_and_shape =\n            resource_dtypes_and_shapes.at(0);\n        input_resource_variable_dtypes_and_shapes[i] = dtype_and_shape;\n      }\n    }\n  }\n  return OkStatus();\n}\n\nStatus SetOpDevice(EagerContext& ctx, EagerOperation* op, Device** device) {\n  // Here in local execute, set preferred device to be on the local task to\n  // avoid placing op on a remote device with higher priority.\n  const DeviceNameUtils::ParsedName& preferred_device =\n      DeviceNameUtils::HasSomeDetails(op->GetDeviceParsedName())\n          ? op->GetDeviceParsedName()\n          : DeviceNameUtils::AddressSpace(ctx.HostCPUParsedName());\n  // Note: We use the unwrapped op for inferring the device.\n  // Without this, when wrapping CPU-only ops like RangeDataset we would\n  // place the wrapped op on a GPU (if one is available) which leads to\n  // errors because placer pins the function output nodes to GPU thereby\n  // forcing a H2D copy of the dataset variant which is not supported.\n  auto ndef = op->MutableAttrs()->BuildNodeDef();\n#ifdef INTEL_MKL\n  if (IsMKLEnabled() &&\n      absl::StartsWith(op->Name(), mkl_op_registry::kMklOpPrefix)) {\n    GetMKLNodeDef(&ndef);\n  }\n#endif  // INTEL_MKL\n\n  TF_RETURN_IF_ERROR(ctx.SelectDevice(preferred_device, ndef, device));\n\n  VLOG(1) << \"PreferredDevice \" << op->Name() << \": \" << preferred_device;\n  VLOG(1) << \"Placer place op [\" << op->Name()\n          << \"] on device: \" << (*device)->name();\n  VLOG(4) << \"Available kernels for \" << op->Name() << \" are\"\n          << KernelsRegisteredForOp(op->Name());\n  op->SetDevice(*device);\n  return OkStatus();\n}\n\nFprint128 GetDeviceCacheKey(EagerOperation* op, const EagerContext& ctx) {\n  Fprint128 device_cache_key = op->MutableAttrs()->CacheKey(op->DeviceName());\n  device_cache_key =\n      FingerprintCat128(device_cache_key, ctx.AllowSoftPlacement());\n  return device_cache_key;\n}\n\nStatus GetOrCreateKernelAndDevice(\n    EagerOperation* op, TensorHandle** retvals, int* num_retvals,\n    core::RefCountPtr<KernelAndDevice>* out_kernel) {\n  EagerContext& ctx = op->EagerContext();\n  Device* device = absl::get<Device*>(op->Device());\n\n  // Set the EagerOperation's device prior to extracting the input_device_ptrs\n  // to avoid any redundant H2D/D2H copies.\n  if (device == nullptr && !op->is_function()) {\n    Fprint128 device_cache_key = GetDeviceCacheKey(op, ctx);\n    device = ctx.GetCachedDevice(device_cache_key);\n    if (device == nullptr) {\n      TF_RETURN_IF_ERROR(SetOpDevice(ctx, op, &device));\n      ctx.AddDeviceToCache(device_cache_key, device);\n    } else {\n      op->SetDevice(device);\n    }\n  }\n\n  // Save the original value of reuse_rendezvous_for_functions from the context.\n  bool reuse_rendezvous_for_functions_original_value =\n      ctx.GetReuseRendezvousForFunctions();\n  // When running in eager_op_as_function mode Send/Recv ops need to be\n  // placed on the same rendezvous to match the behaviour of eager mode.\n  bool reuse_rendezvous_for_functions =\n      (ctx.RunEagerOpAsFunction() && !op->is_function()) ||\n      reuse_rendezvous_for_functions_original_value;\n\n  std::vector<Device*> input_device_ptrs;\n  absl::flat_hash_map<string, const std::vector<string>*> composite_devices;\n  std::unordered_map<int, DtypeAndPartialTensorShape>\n      input_resource_variable_dtypes_and_shapes;\n  const KernelDef* kernel_def = nullptr;\n  if (!op->is_function()) {\n    const NodeDef* node_def = &op->MutableAttrs()->BuildNodeDef();\n    kernel_def = GetKernelDef(*op, node_def, device);\n  }\n  if (op->is_function() || ctx.RunEagerOpAsFunction()) {\n    TF_RETURN_IF_ERROR(ExtractFunctionInputInfo(\n        op, kernel_def, input_device_ptrs, composite_devices,\n        input_resource_variable_dtypes_and_shapes));\n  }\n\n  TF_ASSIGN_OR_RETURN(\n      Fprint128 cache_key,\n      GetKernelCacheKey(*op, op->MutableAttrs()->CacheKey(op->DeviceName()),\n                        input_device_ptrs,\n                        input_resource_variable_dtypes_and_shapes));\n  core::RefCountPtr<KernelAndDevice> kernel = ctx.GetCachedKernel(cache_key);\n  AbstractOperationPtr wrapped_op_releaser;\n  // We can eliminate some overhead by running simple functions using regular\n  // CallOp kernel. However, it is tricky to figure out which functions should\n  // be run using CallOp. Also, currently CallOp runs neither optimization\n  // passes (needed for TPU/XLA) nor grappler.\n  // Here are some cases where a function should be run in multi-device mode:\n  //  - Function takes at least two resources on different devices.\n  //  - Function takes a resource on deviceA and a body op explicitly placed\n  //  on deviceB.\n  //  - Function has a colocation constraint.\n  //  - Function has an explicit device annotation (which might not be using\n  //    full canonical device name) different from op_device. Note that false\n  //    positives are ok.\n  //  - Function has a node or a (node) attribute that can potentially make\n  //    the function multi-device after a rewrite pass (e.g. various XLA/TPU\n  //    special nodes and attributes)\n  if (kernel == nullptr) {\n    VLOG(2) << \"Creating new kernel for \" << op->Name() << \" on device \"\n            << DeviceNameOrUnspecified(absl::get<Device*>(op->Device()));\n    bool run_function_with_flr = false;\n    bool function_outputs_on_op_device = false;\n    absl::optional<string> xla_compile_device_type;\n    if (op->is_function()) {\n      bool compile_with_xla;\n      TF_RETURN_IF_ERROR(MustCompileWithXLA(op, ctx, &compile_with_xla));\n      if (compile_with_xla) {\n        if (ctx.JitCompileRewrite()) {\n          xla_compile_device_type = op->GetDeviceParsedName().type;\n          run_function_with_flr = true;\n        } else {\n          // Note that it is not ideal, but currently correct, to set this\n          // attribute after computing the kernel cache key above.\n          // Note: If the attribute is already set to true, this is a noop.\n          op->MutableAttrs()->Set(kXlaMustCompileAttr, true);\n        }\n      } else {\n        run_function_with_flr = true;\n      }\n      GetFuncAttr(op, ctx, kOutputsOnOpDevice, &function_outputs_on_op_device)\n          .IgnoreError();\n    }\n\n    VLOG(2) << op->Name() << \" function_outputs_on_op_device: \"\n            << function_outputs_on_op_device;\n    if (device == nullptr) {\n      TF_RETURN_IF_ERROR(SetOpDevice(ctx, op, &device));\n    } else {\n      VLOG(1) << \"Device for [\" << op->Name()\n              << \"] already set to: \" << device->name();\n    }\n\n    // Note: We wrap the eager op AFTER the device has been inferred to ensure\n    // that placement of the NodeDef in the function is exactly the same as in\n    // eager mode. This is specially important for cases where the\n    // preferred device is not the actual device on which the op is run.\n    // E.g. the preferred device for a `RangeDataset` op could be set to `GPU`\n    // but `ctx->SelectDevice` would still place it on CPU. Placer on the other\n    // hand would throw an error.\n    //\n    // Note: The wrapped function is never jit compiled but rather run via the\n    // FLR. This is needed because certain ops e.g. `VarHandleOp` can not be\n    // jit compiled. Ideally we would run this via the jit compiled path and\n    // expect unsupported ops to be outside compiled but that is not supported\n    // on GPUs right now.\n    bool allow_small_function_optimizations = false;\n    bool int_args_and_retvals_on_device = false;\n    bool allow_control_flow_sync_execution = false;\n    // TODO(b/176491312): Remove this if shape inference on import flag is\n    // removed.\n    bool shape_inference_on_tfe_dialect_import = true;\n    if (ctx.RunEagerOpAsFunction() && !op->is_function()) {\n      EagerOperation* wrapped_op = nullptr;\n      TF_RETURN_IF_ERROR(ValidateOp(op));\n      TF_RETURN_IF_ERROR(WrapInCallOp(op, &wrapped_op));\n      DCHECK(wrapped_op);\n      DCHECK(wrapped_op->is_function());\n      wrapped_op_releaser.reset(wrapped_op);\n      run_function_with_flr = true;\n      allow_small_function_optimizations = true;\n      allow_control_flow_sync_execution = true;\n      shape_inference_on_tfe_dialect_import = false;\n      int_args_and_retvals_on_device =\n          IntArgsAndRetvalsOnDevice(op, kernel_def);\n      op = wrapped_op;\n      if (int_args_and_retvals_on_device) {\n        op->MutableAttrs()->Set(FunctionLibraryDefinition::kIntsOnDeviceAttr,\n                                true);\n      }\n    }\n    const NodeDef& ndef = op->MutableAttrs()->BuildNodeDef();\n\n    FunctionLibraryRuntime* flr =\n        device == nullptr ? nullptr : ctx.func_lib(device);\n    if (device != nullptr && flr == nullptr) {\n      return errors::NotFound(\n          \"Unable to find a FunctionLibraryRuntime corresponding to device \",\n          device->name());\n    }\n    auto runner = (flr != nullptr && flr->runner() != nullptr) ? flr->runner()\n                                                               : ctx.runner();\n    GraphCollector* graph_collector = nullptr;\n    if (ctx.ShouldStoreGraphs()) {\n      graph_collector = ctx.GetGraphCollector();\n    }\n    // Treat the function as multi_device only when we are not compiling\n    // it wholly with XLA. When compiling wholly with XLA, flr->CreateKernel\n    // will create an XlaLaunchOp kernel to compile and run the function.\n    if (run_function_with_flr) {\n      // Multi-device functions don't use the rendezvous from eager context.\n      // If we use that rendezvous, multiple concurrent calls to the same\n      // function will likely result in collisions. However, this also means\n      // that we don't support legitimate sending/receiving across function\n      // boundary.\n      VLOG(2) << \"Running \" << ndef.op() << \" using multi-device function. \"\n              << \"Full node_def=\" << ndef.DebugString();\n      std::function<int64_t()> get_op_id = nullptr;\n#if !defined(IS_MOBILE_PLATFORM)\n      get_op_id = [&ctx]() { return ctx.RemoteMgr()->NextOpId(); };\n#endif  // IS_MOBILE_PLATFORM\n\n      ctx.reuse_rendezvous_for_functions_mu()->lock();\n      ctx.SetReuseRendezvousForFunctions(reuse_rendezvous_for_functions);\n      auto rendezvous_creator = ctx.RendezvousCreator();\n      ctx.SetReuseRendezvousForFunctions(\n          reuse_rendezvous_for_functions_original_value);\n      ctx.reuse_rendezvous_for_functions_mu()->unlock();\n      kernel.reset(new KernelAndDeviceFunc(\n          flr, ctx.pflr(), std::move(input_device_ptrs),\n          std::move(composite_devices),\n          std::move(input_resource_variable_dtypes_and_shapes), runner,\n          ctx.GetCollectiveExecutorHandle(), ctx.HostCPU(), op->Name(),\n          function_outputs_on_op_device, allow_small_function_optimizations,\n          allow_control_flow_sync_execution,\n          shape_inference_on_tfe_dialect_import, int_args_and_retvals_on_device,\n          xla_compile_device_type, std::move(rendezvous_creator), get_op_id));\n    } else {\n      VLOG(2) << \"Running \" << ndef.op() << \" using op kernel. \"\n              << \". Full node_def=\" << ndef.DebugString();\n      kernel.reset(new KernelAndDeviceOp(\n          ctx.GetRendezvous(), ctx.LogMemory(), flr, runner,\n          ctx.GetCollectiveExecutorHandle(), ctx.HostCPU()));\n    }\n\n    TF_RETURN_IF_ERROR(\n        kernel->Init(ctx.LogDevicePlacement(), ndef, graph_collector));\n\n    if (op->is_function()) {\n      ctx.AddKernelToCache(cache_key, kernel.get());\n    } else {\n      // Exclude tf.data op kernels from being cached. The reason for this is\n      // that tf.data op kernels that accept a user-defined function will have a\n      // unique cache key every time they are executed (because the user-defined\n      // function is traced every time). Caching such kernels provides no\n      // benefit and in some cases results in linear memory growth of use\n      // programs that build input pipeline graphs in a loop.\n      const OpDef* op_def;\n      TF_RETURN_IF_ERROR(OpDefForOp(op->Name().data(), &op_def));\n      if (KernelCacheEnabled(*op_def)) {\n        ctx.AddKernelToCache(cache_key, kernel.get());\n      }\n    }\n  }\n\n  int num_outputs = kernel->num_outputs();\n  if (num_outputs > *num_retvals) {\n    return errors::InvalidArgument(\"Expecting \", num_outputs,\n                                   \" outputs, but *num_retvals is \",\n                                   *num_retvals);\n  }\n  *num_retvals = num_outputs;\n\n  kernel->Ref();  // Ownership of reference is passed to out_kernel.\n  out_kernel->reset(kernel.get());\n  return OkStatus();\n}\n\nStatus CreateUnshapedOutput(\n    const KernelAndDevice& kernel, const int output_num, Device* output_device,\n    const DataType& output_dtype,\n    const absl::optional<EagerFunctionParams>& eager_func_params,\n    EagerContext* ctx, TensorHandle** output) {\n#if defined(IS_MOBILE_PLATFORM)\n  return errors::Unimplemented(\n      \"Remote outputs are not available on mobile devices.\");\n#else  // !IS_MOBILE_PLATFORM\n  int64_t op_id;\n  if (eager_func_params.has_value()) {\n    op_id = eager_func_params.value().op_id;\n  } else {\n    return errors::InvalidArgument(\n        \"Unable to find a remote op id for a remote output of \", kernel.name());\n  }\n  string remote_task;\n  if (!DeviceNameUtils::GetTaskName(output_device->parsed_name(),\n                                    &remote_task)) {\n    return errors::InvalidArgument(\n        \"Unable to find remote task corresponding to device \",\n        output_device->name());\n  }\n  if (ctx->RemoteMgr()->IsMaster()) {\n    *output = TensorHandle::CreateUnshapedRemoteHandle(\n        op_id, output_num, remote_task, output_dtype, output_device, ctx);\n  } else {\n    *output = TensorHandle::CreateLazyRemoteHandle(op_id, output_num,\n                                                   output_dtype, output_device,\n                                                   /*is_ready=*/false, ctx);\n  }\n  return OkStatus();\n#endif  // !IS_MOBILE_PLATFORM\n}\n\nStatus AddOrExecuteNode(core::RefCountPtr<KernelAndDevice> kernel,\n                        EagerOperation* op, TensorHandle** retvals) {\n  EagerExecutor& executor = op->Executor();\n  EagerContext& ctx = op->EagerContext();\n  GraphCollector* graph_collector = nullptr;\n  if (ctx.ShouldStoreGraphs()) {\n    graph_collector = ctx.GetGraphCollector();\n  }\n  const int num_outputs = kernel->num_outputs();\n  absl::optional<EagerFunctionParams> eager_func_params =\n      op->eager_func_params();\n  if (kernel->IsCrossProcess() && !eager_func_params.has_value()) {\n    // Create an eager op id for a cross-process function if not exist.\n#if defined(IS_MOBILE_PLATFORM)\n    return errors::Unimplemented(\n        \"Cross-process functions are not supported on mobile devices.\");\n#else  // !IS_MOBILE_PLATFORM\n    const int64_t op_id = ctx.RemoteMgr()->NextOpId();\n    eager_func_params = EagerFunctionParams{\n        op_id, /* is_component_function= */ false, /* step_id= */ std::nullopt};\n#endif  // !IS_MOBILE_PLATFORM\n  }\n  if (executor.Async()) {\n    const DataTypeVector& output_dtypes = kernel->output_dtypes();\n    for (int i = 0, end = num_outputs; i < end; ++i) {\n      Device* output_device = ctx.CanonicalDevice(kernel->OutputDevice(i));\n      if (output_device == nullptr || output_device->IsLocal()) {\n        retvals[i] = TensorHandle::CreateEmptyLocalHandle(\n            /* d= */ output_device, /* op_device= */ kernel->device(),\n            /* resource_device= */ kernel->OutputResourceDevice(i),\n            output_dtypes[i], &ctx);\n      } else {\n        TF_RETURN_IF_ERROR(\n            CreateUnshapedOutput(*kernel, i, output_device, output_dtypes[i],\n                                 eager_func_params, &ctx, &retvals[i]));\n      }\n    }\n    const absl::InlinedVector<TensorHandle*, 4>* inputs;\n    TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));\n    auto node = std::make_unique<AsyncExecuteNode>(\n        &ctx, *inputs, eager_func_params, std::move(kernel), graph_collector,\n        op->GetCancellationManager(),\n        absl::Span<TensorHandle*>(retvals, num_outputs), op->GetStackTrace());\n    // Release the inputs from the eager operation since the AsyncExecuteNode\n    // would have taken ownership. This allows the inputs to be forwarded if\n    // possible.\n    op->Clear();\n    // For async mode, execution order will make sure that all\n    // input handles are ready before executing them.\n    // TODO(b/137118203): Consider executing \"cheap\" kernels inline for\n    // performance.\n    return executor.AddOrExecute(std::move(node));\n  } else {\n    for (int i = 0, end = num_outputs; i < end; ++i) {\n      retvals[i] = nullptr;\n    }\n    const absl::InlinedVector<TensorHandle*, 4>* inputs;\n    TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));\n    ExecuteNode node(&ctx, *inputs, eager_func_params, kernel, graph_collector,\n                     op->GetCancellationManager(),\n                     {retvals, static_cast<size_t>(num_outputs)},\n                     op->GetStackTrace());\n    Status s = executor.SyncExecute(&node);\n    // We release the inputs AFTER executing the operation in sync mode since\n    // ExecuteNode does not increment the reference count and thus does not have\n    // ownership of the inputs while executing.\n    op->Clear();\n    return s;\n  }\n}\n\n// There are a lot of references to devices in this function and around.\n// Here is what they mean:\n//  EagerOperation::Device(): The device on which the user requested the op\n//    be executed, except if we had to change the device due to resource inputs\n//    or CPU pinning. If the user did not request a device, the op does not\n//    take resources, and we did not pin it to CPU, the device can be nullptr.\n//  KernelAndDevice::Device(): The first time we see an op (combined with\n//    its attributes), we need to create a KernelAndDevice object for it.\n//    If op->Device() is a nullptr, we select a device for the op when\n//    creating the KernelAndDevice. A concrete device will always be selected\n//    here except when `op` is a function to be executed using function library\n//    runtime. In this case, we don't select a device because running\n//    a function with explicitly requested device has different behavior than\n//    running without an explicitly requested device.\nStatus EagerLocalExecute(EagerOperation* op, TensorHandle** retvals,\n                         int* num_retvals) {\n  profiler::ScopedMemoryDebugAnnotation op_annotation(\n      op->op_name(), op->eager_func_params().has_value()\n                         ? op->eager_func_params().value().step_id.value_or(0)\n                         : 0);\n  profiler::TraceMe activity(\n      [&] { return absl::StrCat(\"EagerLocalExecute: \", op->Name()); },\n      profiler::TraceMeLevel::kInfo);\n  EagerContext& ctx = op->EagerContext();\n  auto& executor = op->Executor();\n  TF_RETURN_IF_ERROR(executor.status());\n\n  core::RefCountPtr<KernelAndDevice> kernel;\n  auto status = GetOrCreateKernelAndDevice(op, retvals, num_retvals, &kernel);\n\n#ifdef INTEL_MKL\n  if (IsMKLEnabled() && kernel != nullptr &&\n      op->Device() == kVariantDeviceNull) {\n    // oneDNN optimization pass relies on the op's assigned device to determine\n    // whether it can be rewritten.\n    op->SetDevice(kernel->device());\n  }\n#endif  // INTEL_MKL\n\n  // Run all the registered rewrite pass after the placement, regardless whether\n  // the placement is successful or not. The passes can either create new ops\n  // (without placement) or update some fields of the input op.\n  std::unique_ptr<tensorflow::EagerOperation> out_op;\n  TF_RETURN_IF_ERROR(EagerOpRewriteRegistry::Global()->RunRewrite(\n      EagerOpRewriteRegistry::POST_PLACEMENT, op, &out_op));\n  if (out_op) {\n    op = out_op.get();\n    // If the out op doesn't have device, either because it is a new op or\n    // the op wasn't placed successfully, then we do the placement again.\n    if (op->Device() == kVariantDeviceNull) {\n      status = GetOrCreateKernelAndDevice(op, retvals, num_retvals, &kernel);\n    }\n  }\n  if (!status.ok()) return status;\n\n  int num_outputs = kernel->num_outputs();\n  TF_RETURN_IF_ERROR(ValidateInputTypeAndPlacement(&ctx, op, kernel));\n\n  if (ctx.LogDevicePlacement() || VLOG_IS_ON(1)) {\n    string msg = strings::StrCat(\"Executing op \", op->Name(), \" in device \",\n                                 kernel->device()->name());\n    if (!logging::LogToListeners(msg)) {\n      LOG(INFO) << msg;\n    }\n  }\n\n  Status s = AddOrExecuteNode(std::move(kernel), op, retvals);\n  // Since the operation failed, we need to Unref any outputs if they were\n  // allocated.\n  if (!s.ok()) {\n    for (int i = 0, end = num_outputs; i < end; ++i) {\n      if (retvals[i] != nullptr) {\n        retvals[i]->Unref();\n        retvals[i] = nullptr;\n      }\n    }\n  }\n\n  return s;\n}\n\n// Run a Pack op to pack the tensors pointed by a packed input TensorHandle if\n// the op is a primitive op.\nStatus MaybePackInputTensor(EagerOperation* op) {\n  if (op->is_function() || op->EagerContext().RunEagerOpAsFunction()) {\n    // Functions could take packed TensorHandles as inputs.\n    return OkStatus();\n  }\n  EagerContext& ctx = op->EagerContext();\n  const absl::InlinedVector<TensorHandle*, 4>* inputs;\n  TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));\n  for (int i = 0; i < inputs->size(); ++i) {\n    TensorHandle* handle = (*inputs)[i];\n    if (handle->Type() == TensorHandle::PACKED) {\n      EagerOperation pack_op(&ctx);\n      TF_RETURN_IF_ERROR(pack_op.Reset(\"Pack\", /*device_name=*/nullptr,\n                                       /*remote=*/false, /*executor=*/nullptr));\n      pack_op.MutableAttrs()->Set(\"N\", handle->NumPackedHandles());\n      pack_op.MutableAttrs()->Set(\"T\", handle->dtype);\n      for (int i = 0; i < handle->NumPackedHandles(); ++i) {\n        tensorflow::TensorHandle* h = nullptr;\n        TF_RETURN_IF_ERROR(handle->ExtractPackedHandle(i, &h));\n        TF_RETURN_IF_ERROR(pack_op.AddInput(h));\n      }\n      int num_retvals = 1;\n      absl::FixedArray<tensorflow::TensorHandle*> retvals(num_retvals);\n      TF_RETURN_IF_ERROR(\n          EagerLocalExecute(&pack_op, retvals.data(), &num_retvals));\n      tensorflow::TensorHandle* ret = retvals.at(0);\n      op->UpdateInput(i, ret);\n      ret->Unref();\n    }\n  }\n  return OkStatus();\n}\n\n#if !defined(IS_MOBILE_PLATFORM)\nvoid PrepareRemoteOp(eager::Operation* remote_op, EagerOperation* op) {\n  EagerContext& ctx = op->EagerContext();\n\n  remote_op->set_id(ctx.RemoteMgr()->NextOpId());\n  remote_op->set_name(op->Name());\n\n  op->Attrs().FillAttrValueMapWithoutDefaults(remote_op->mutable_attrs());\n  remote_op->set_device(absl::get<Device*>(op->Device())->name());\n  remote_op->set_is_function(op->is_function());\n}\n\nStatus StoreResourceDtypesAndShapes(const eager::Operation& remote_op,\n                                    const DataTypeVector& output_dtypes,\n                                    TensorHandle** retvals) {\n  if (remote_op.name() == \"VarHandleOp\") {\n    if (output_dtypes.size() != 1) {\n      return errors::Internal(\"VarHandleOp should only have one output.\");\n    }\n    if (output_dtypes[0] != DT_RESOURCE) {\n      return errors::Internal(\n          \"The output of VarHandleOp should be a DT_RESOURCE.\");\n    }\n    AttrSlice attr_slice = AttrSlice(&remote_op.attrs());\n    const AttrValue* dtype;\n    TF_RETURN_IF_ERROR(attr_slice.Find(\"dtype\", &dtype));\n    const AttrValue* shape;\n    TF_RETURN_IF_ERROR(attr_slice.Find(\"shape\", &shape));\n    retvals[0]->SetResourceHandleDtypeAndShape(\n        {DtypeAndPartialTensorShape{dtype->type(), shape->shape()}});\n  }\n  return OkStatus();\n}\n\nStatus EagerRemoteExecute(EagerOperation* op, TensorHandle** retvals,\n                          int* num_retvals) {\n  EagerContext& ctx = op->EagerContext();\n\n  // TODO(fishx): Remove following code when lazy tensor copy is ready.\n  if (op->Device() == kVariantDeviceNull) {\n    tensorflow::Device* device = nullptr;\n    string device_name = op->DeviceName();\n    TF_RETURN_IF_ERROR(ctx.FindDeviceFromName(device_name.c_str(), &device));\n    op->SetDevice(device);\n  }\n\n  core::RefCountPtr<eager::EagerClient> eager_client;\n  uint64 context_id = ctx.GetContextId();\n  TF_RETURN_IF_ERROR(ctx.GetClient(op->GetDeviceParsedName(), &eager_client));\n  string remote_task;\n  if (!DeviceNameUtils::GetTaskName(op->GetDeviceParsedName(), &remote_task)) {\n    return errors::InvalidArgument(\n        \"Unable to find remote task corresponding to device \",\n        op->DeviceName());\n  }\n\n  std::unique_ptr<eager::EnqueueRequest> request(new eager::EnqueueRequest);\n  request->set_context_id(context_id);\n\n  eager::Operation* remote_op = request->add_queue()->mutable_operation();\n\n  tensorflow::Device* op_device = absl::get<Device*>(op->Device());\n  {\n    profiler::TraceMe activity(\"CopyInputToExpectedDevice\",\n                               profiler::TraceMeLevel::kInfo);\n    const bool is_function = op->is_function();\n    const absl::InlinedVector<TensorHandle*, 4>* inputs;\n    TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));\n    for (int i = 0, end = inputs->size(); i < end; i++) {\n      tensorflow::TensorHandle* input = (*inputs)[i];\n      tensorflow::Device* input_device = input->device();\n      tensorflow::Device* input_device_or_cpu = input->DeviceOrHostCPU(ctx);\n      const string* input_device_name = &input_device_or_cpu->name();\n      bool serialize_resource_dtype_and_shape = false;\n      if (op_device != input_device &&\n          // If the expected and actual devices are on the same task, don't\n          // explicitly copy, and instead depend on the copy to happen locally\n          // when the op is executed on the device.\n          !ctx.OnSameTask(op_device, input_device)) {\n        if (!is_function || input_device_or_cpu->IsLocal()) {\n          tensorflow::Device* remote_cpu_device;\n          TF_RETURN_IF_ERROR(\n              ctx.CPUDeviceOnTask(op_device, &remote_cpu_device));\n          // Always copy to the remote CPU so that the actual device can be\n          // correctly determined after the kernel is selected/instantiated,\n          // since the op might have its inputs on host memory.\n          TensorHandle* handle = input;\n          Device* handle_device = handle->DeviceOrHostCPU(ctx);\n          // If the input is already on the right device, then nothing to do.\n          if (remote_cpu_device != handle_device) {\n            VLOG(6) << \"remote_cpu_device != handle_device\";\n            TF_RETURN_IF_ERROR(CopyInputToExpectedDevice(\n                &ctx, op, op_device, handle, i, handle_device,\n                remote_cpu_device, &handle));\n            op->UpdateInput(i, handle);\n            input = handle;\n            input_device = remote_cpu_device;\n            input_device_name = &remote_cpu_device->name();\n            // Unref handle since it has a ref as an input now\n            handle->Unref();\n          }\n        } else {\n          serialize_resource_dtype_and_shape =\n              (input->dtype == DT_RESOURCE) &&\n              (!input->HasResourceShapeMirror(op_device,\n                                              ctx.GetContextViewId()));\n        }\n      }\n      auto* input_handle = remote_op->add_op_inputs()->mutable_remote_handle();\n      // For a remote component function, a function execution request and an\n      // input generation request may come from different workers. We need to\n      // guarantee that the input generation request is processed before the\n      // function execution request, so wait until the remote input is ready\n      // before sending it to the multi-device function device.\n      const bool wait_until_ready = op->is_function();\n      TF_RETURN_IF_ERROR(ctx.RemoteMgr()->SerializeRemoteTensorHandle(\n          input, wait_until_ready, input_handle, input_device,\n          *input_device_name, serialize_resource_dtype_and_shape));\n      if (!input_handle->resource_dtypes_and_shapes().empty()) {\n        TF_RETURN_IF_ERROR(\n            input->AddResourceShapeMirror(op_device, input_handle->op_id(),\n                                          input_handle->output_num(), &ctx));\n      }\n    }\n  }\n\n  PrepareRemoteOp(remote_op, op);\n\n  DataTypeVector output_dtypes;\n  TF_RETURN_IF_ERROR(GetOutputDTypes(op, &output_dtypes));\n\n  const size_t num_outputs = output_dtypes.size();\n  if (num_outputs != *num_retvals) {\n    return errors::InvalidArgument(\n        \"num_retvals does not match expected output dtypes\");\n  }\n  *num_retvals = num_outputs;\n\n  const tensorflow::uint64 id = remote_op->id();\n  for (size_t i = 0; i < num_outputs; ++i) {\n    // TODO(nareshmodi): Change the callback to instead add the decref to a\n    // list of pending decrefs that we can send as a batch with the next\n    // execute.\n\n    // The device_ and resource_device_ of this TensorHandle might be\n    // incorrect. For multi-device functions, we don't know the output device\n    // until the function is instantiated on a remote worker. Luckily, we don't\n    // need to know the correct remote device here. We just need to know that it\n    // is remote. If we need copy this tensor to this process or run any ops\n    // which take this tensor as an input, block until the correct device is\n    // set.\n    const bool unknown_device = op->is_function();\n    retvals[i] = TensorHandle::CreateUnshapedRemoteHandle(\n        id, i, remote_task, output_dtypes[i], op_device, &ctx, unknown_device);\n  }\n\n  // Store the data type and shape of a remote resource variable on the\n  // corresponding remote TensorHandle (output of 'VarHandleOp').\n  // If the variable is an input of a remote function, the function may need\n  // the type and shape during function instantiation. Store the type and\n  // shape on eager master and sent them to the default function device along\n  // with the EnqueueRequest.\n  TF_RETURN_IF_ERROR(\n      StoreResourceDtypesAndShapes(*remote_op, output_dtypes, retvals));\n\n  auto& executor = op->Executor();\n  VLOG(4) << \"Execute remote eager op: \" << op->Name()\n          << \" (is async?: \" << executor.Async() << \").\";\n\n  const absl::InlinedVector<TensorHandle*, 4>* inputs;\n  TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));\n\n  std::unique_ptr<EagerNode> node(new eager::RemoteExecuteNode(\n      &op->EagerContext(), std::move(request), op_device,\n      ctx.GetContextViewId(), eager_client.get(), op->GetCancellationManager(),\n      op->MutableAttrs()->BuildNodeDef(), op->EagerContext().FuncLibDef(),\n      *inputs, {retvals, num_outputs}));\n\n  if (op->EagerContext().LogDevicePlacement() || VLOG_IS_ON(1)) {\n    string msg = strings::StrCat(\n        \"Executing op \", op->Name(), \" on task \",\n        DeviceNameUtils::ParsedNameToString(op->GetDeviceParsedName()));\n    if (!logging::LogToListeners(msg)) {\n      LOG(INFO) << msg;\n    }\n  }\n\n  Status s = executor.AddOrExecute(std::move(node));\n  // Since the operation failed, we need to Unref any outputs that were\n  // allocated.\n  if (!s.ok()) {\n    for (size_t i = 0; i < num_outputs; ++i) {\n      retvals[i]->Unref();\n      // Ensure that any smart pointers created to wrap results become noops\n      // rather than operating on invalid memory.\n      retvals[i] = nullptr;\n    }\n  }\n\n  return s;\n}\n#endif  // IS_MOBILE_PLATFORM\n\nStatus GetKernelOutputs(\n    std::vector<EagerKernelRet>* outputs, int num_outputs,\n    TensorHandle** retvals, EagerContext* ctx, KernelAndDevice* kernel,\n    const absl::optional<EagerFunctionParams>& eager_func_params) {\n  for (int i = 0, end = num_outputs; i < end; ++i) {\n    if (retvals[i] == nullptr) {\n      EagerKernelRet& ret = (*outputs)[i];\n      Device* output_device = ctx->CanonicalDevice(kernel->OutputDevice(i));\n      if (ret.index() == 0) {\n        retvals[i] = TensorHandle::CreateLocalHandle(\n            std::move(absl::get<Tensor>(ret)),\n            /* d= */ output_device,\n            /* op_device= */ kernel->device(),\n            /* resource_device= */ kernel->OutputResourceDevice(i), ctx);\n      } else {\n        const DataTypeVector& output_dtypes = kernel->output_dtypes();\n        TF_RETURN_IF_ERROR(\n            CreateUnshapedOutput(*kernel, i, output_device, output_dtypes[i],\n                                 eager_func_params, ctx, &retvals[i]));\n#if !defined(IS_MOBILE_PLATFORM)\n        TF_RETURN_IF_ERROR(\n            retvals[i]->SetRemoteShape(absl::get<TensorShape>(ret),\n                                       output_device, ctx->GetContextViewId()));\n#endif  // IS_MOBILE_PLATFORM\n      }\n    } else {\n      if (!kernel->IsFunction() &&\n          TF_PREDICT_FALSE(kernel->device() != retvals[i]->op_device())) {\n        return errors::Internal(\n            \"Kernel output tensor handle has a different op device than the \"\n            \"kernel. This should never happen.\");\n      }\n      if (TF_PREDICT_FALSE(ctx->CanonicalDevice(kernel->OutputDevice(i)) !=\n                           retvals[i]->device())) {\n        return errors::Internal(\n            \"Kernel output tensor handle locates on a different device than \"\n            \"the specified kernel output device. This should never happen.\");\n      }\n\n      EagerKernelRet& ret = (*outputs)[i];\n      if (ret.index() == 0) {\n        TF_RETURN_IF_ERROR(retvals[i]->SetTensor(\n            std::move(absl::get<Tensor>(ret)),\n            ctx->CanonicalDevice(kernel->OutputDevice(i))));\n      } else {\n#if defined(IS_MOBILE_PLATFORM)\n        return errors::Unimplemented(\n            \"Remote outputs are not available on mobile devices.\");\n#else  // !IS_MOBILE_PLATFORM\n        TF_RETURN_IF_ERROR(retvals[i]->SetRemoteShape(\n            absl::get<TensorShape>(ret), retvals[i]->device(),\n            ctx->GetContextViewId()));\n#endif  // !IS_MOBILE_PLATFORM\n      }\n    }\n  }\n  return OkStatus();\n}\n\nvoid CollectGraphs(EagerContext* ctx) {\n  mutex_lock ml(*ctx->MetadataMu());\n\n  GraphCollector* collector = ctx->GetGraphCollector();\n  mutex_lock mll(collector->mu);\n\n  // Adding to partition graphs for backward compatibility.\n  for (const auto& graph : collector->partitioned_graphs) {\n    *ctx->RunMetadataProto()->add_partition_graphs() = graph;\n  }\n\n  if (collector->dirty) {\n    auto* function_graphs = ctx->RunMetadataProto()->add_function_graphs();\n    *function_graphs->mutable_post_optimization_graph() =\n        collector->optimized_graph;\n    *function_graphs->mutable_pre_optimization_graph() = collector->raw_graph;\n    for (const auto& graph : collector->partitioned_graphs) {\n      *function_graphs->add_partition_graphs() = graph;\n    }\n  }\n\n  collector->ClearGraphs();\n}\n}  // namespace\n\nStatus EagerExecute(EagerOperation* op, TensorHandle** retvals,\n                    int* num_retvals) {\n  profiler::TraceMe activity([&] {\n    return ::tensorflow::profiler::TraceMeEncode(\n        \"EagerExecute\",\n        {{\"eager_op\", op->Name()}, {\"is_func\", op->is_function()}});\n  });\n\n  if (!op->Executor().Async()) {\n    VLOG(6) << \"op: \" << op->Name() << \" is not Async.\";\n    if (!op->EagerContext()\n             .GetGlobalRendezvousForFunctionLocalRendezvousStatus()\n             .ok()) {\n      VLOG(6) << \"global_rendezvous_for_functions_ is in bad state. Resetting.\";\n      op->EagerContext().ResetGlobalRendezvousForFunction();\n    }\n    // In sync mode, always clear error to maintain the same behavior as before.\n    // TODO(b/141004939): Remove this.\n    op->Executor().ClearError();\n  }\n\n  std::unique_ptr<tensorflow::EagerOperation> out_op;\n  TF_RETURN_IF_ERROR(EagerOpRewriteRegistry::Global()->RunRewrite(\n      EagerOpRewriteRegistry::PRE_EXECUTION, op, &out_op));\n\n  if (op->IsLocal()) {\n    if (out_op) {\n      op = out_op.get();\n    }\n    TF_RETURN_IF_ERROR(MaybePackInputTensor(op));\n    return EagerLocalExecute(op, retvals, num_retvals);\n  }\n\n#if defined(IS_MOBILE_PLATFORM)\n  return errors::Unimplemented(\n      \"Eager's remote execution is not available on mobile devices.\");\n#else   // !IS_MOBILE_PLATFORM\n  if (out_op) {\n    op = out_op.get();\n  }\n  return EagerRemoteExecute(op, retvals, num_retvals);\n#endif  // !IS_MOBILE_PLATFORM\n}\n\n// TODO(gjn): Consider moving into ExecuteNode class\nStatus EagerKernelExecute(\n    EagerContext* ctx, const absl::InlinedVector<TensorHandle*, 4>& op_inputs,\n    const absl::optional<EagerFunctionParams>& eager_func_params,\n    const core::RefCountPtr<KernelAndDevice>& kernel,\n    GraphCollector* graph_collector, CancellationManager* cancellation_manager,\n    absl::Span<TensorHandle*> retvals,\n    const absl::optional<ManagedStackTrace>& stack_trace) {\n  profiler::TraceMe activity(\"EagerKernelExecute\",\n                             profiler::TraceMeLevel::kInfo);\n  std::vector<EagerKernelRet> outputs(1);\n\n  ExecuteNodeArgs inputs(op_inputs.size());\n  TF_RETURN_IF_ERROR(inputs.Init(ctx, op_inputs, kernel));\n  // TODO(apassos) figure out how to record stats for ops which are a part of\n  // functions.\n  // TODO(b/111859745): When we support recovering from kernel/device errors, we\n  // would need to call XlaDevice::EnsureDeviceContextOk() before using an XLA\n  // device. We don't call it now because it is an unneeded overhead (it\n  // acquires a lock) and we can't recover from errors anyway.\n  ScopedStepContainer* container = ctx->StepContainer();\n  CoordinationServiceAgent* coord_agent = nullptr;\n#if !defined(IS_MOBILE_PLATFORM)\n  if (ctx->GetDistributedManager() != nullptr)\n    coord_agent = ctx->GetDistributedManager()->GetCoordinationServiceAgent();\n#endif  // !IS_MOBILE_PLATFORM\n  TF_RETURN_IF_ERROR(kernel->Run(container, inputs, &outputs,\n                                 cancellation_manager, eager_func_params,\n                                 stack_trace, coord_agent));\n  if (graph_collector != nullptr) {\n    CollectGraphs(ctx);\n  }\n\n  if (TF_PREDICT_FALSE(retvals.size() != outputs.size())) {\n    return errors::Internal(\n        \"EagerKernelExecute returns a list of \", outputs.size(),\n        \" tensors but \", retvals.size(),\n        \" is expected. This should never \"\n        \"happen. Please file a bug with the TensorFlow team.\");\n  }\n  return GetKernelOutputs(&outputs, retvals.size(), retvals.data(), ctx,\n                          kernel.get(), eager_func_params);\n}\n\nnamespace {\n\nStatus LocalEagerCopyToDevice(TensorHandle* h, EagerContext* ctx,\n                              EagerExecutor* executor, Device* dstd,\n                              bool mirror, TensorHandle** result) {\n  TF_RETURN_IF_ERROR(executor->status());\n  Device* d = ctx->CanonicalDevice(dstd);\n  if (mirror && h->HasLocalMirror(d)) {\n    h->Ref();\n    *result = h;\n    return OkStatus();\n  }\n\n  bool async = executor->Async();\n  if (mirror) {\n    h->Ref();\n    *result = h;\n\n    if (h->HasLocalMirror(d)) {\n      return OkStatus();\n    }\n\n    // We don't bother adding an empty local mirror in sync mode since we'll be\n    // executing the operation directly and be calling AddLocalMirror. A\n    // reference count is still needed which will be removed if the operation\n    // fails.\n    if (async) {\n      Status s = h->AddEmptyLocalMirror(d);\n      if (!s.ok()) {\n        // If a mirror was added since we called HasLocalMirror then just return\n        // since another thread has already added the mirror.\n        if (s.code() == error::Code::ALREADY_EXISTS) {\n          return OkStatus();\n        }\n\n        // Remove the previously added reference count since adding the mirror\n        // failed.\n        h->Unref();\n        *result = nullptr;\n        return s;\n      }\n    }\n  } else {\n    *result = TensorHandle::CreateEmptyLocalHandle(\n        d, dstd, h->resource_device(), h->dtype, ctx);\n  }\n\n  Status s;\n  if (async) {\n    // Note that `h` may not be currently ready. However execution order will\n    // make sure that `h` is ready before the copy is actually done.\n    std::unique_ptr<EagerNode> node(\n        new CopyToDeviceNode(h, *result, d, *ctx, async, mirror));\n    s = executor->AddOrExecute(std::move(node));\n  } else {\n    CopyToDeviceNode node(h, *result, d, *ctx, async, mirror);\n    s = executor->SyncExecute(&node);\n  }\n\n  // Since the operation failed, we need to Unref any outputs that were\n  // allocated.\n  if (!s.ok()) {\n    (*result)->Unref();\n    *result = nullptr;\n  }\n\n  return s;\n}\n\n}  // namespace\n\nStatus EagerCopyToDevice(TensorHandle* h, EagerContext* ctx,\n                         EagerExecutor* executor, Device* device, bool mirror,\n                         TensorHandle** result) {\n  TF_RETURN_IF_ERROR(h->WaitUnknownDevice());\n  auto send_device = h->DeviceOrHostCPU(*ctx);\n  bool sender_is_local = send_device->IsLocal();\n\n  bool receiver_is_local = device->IsLocal();\n\n  if (!executor->Async()) {\n    // In sync mode, always clear error to maintain the same behavior as before.\n    // TODO(b/141004939): Remove this.\n    executor->ClearError();\n  }\n\n  if (sender_is_local && receiver_is_local) {\n    return LocalEagerCopyToDevice(h, ctx, executor, device, mirror, result);\n  } else {\n#if defined(IS_MOBILE_PLATFORM)\n    return errors::Unimplemented(\n        \"Eager's remote execution is not available on mobile devices.\");\n#else   // !IS_MOBILE_PLATFORM\n    uint64 recv_op_id = 0;\n    if (receiver_is_local) {\n      Device* d = ctx->CanonicalDevice(device);\n      // TODO(gjn): Need to add support for async execution. Note if receiver\n      // is local, we need to first add support in TensorHandle to wait on local\n      // mirrors.\n      if (mirror) {\n        h->Ref();\n        *result = h;\n\n        if (h->HasLocalMirror(d)) {\n          return OkStatus();\n        }\n\n        Status s = h->AddEmptyLocalMirror(d);\n        if (!s.ok()) {\n          // If a mirror was added since we called HasLocalMirror then just\n          // return since another thread has already added the mirror.\n          if (s.code() == error::Code::ALREADY_EXISTS) {\n            return OkStatus();\n          }\n\n          // Remove the previously added reference count since adding the mirror\n          // failed.\n          h->Unref();\n          *result = nullptr;\n          return s;\n        }\n      } else {\n        *result = TensorHandle::CreateEmptyLocalHandle(\n            /* d= */ d, /* op_device= */ device,\n            /*resource_device=*/nullptr, h->dtype, ctx);\n      }\n    } else {\n      if (mirror) {\n        if (h->HasRemoteMirror(device, ctx->GetContextViewId())) {\n          h->Ref();\n          *result = h;\n          return OkStatus();\n        }\n      }\n      string remote_task;\n      if (!DeviceNameUtils::GetTaskName(device->parsed_name(), &remote_task)) {\n        return errors::InvalidArgument(\n            \"Unable to find remote task corresponding to device \",\n            device->name());\n      }\n      recv_op_id = ctx->RemoteMgr()->NextOpId();\n      if (mirror) {\n        TF_RETURN_IF_ERROR(h->AddUnshapedRemoteMirror(device, recv_op_id, 0,\n                                                      remote_task, ctx));\n        h->Ref();\n        *result = h;\n      } else {\n        *result = TensorHandle::CreateUnshapedRemoteHandle(\n            recv_op_id, 0, remote_task, h->dtype, device, ctx);\n      }\n    }\n\n    auto node = std::make_unique<eager::RemoteCopyNode>(\n        ctx, executor, h, result[0], device, recv_op_id);\n    Status s = executor->AddOrExecute(std::move(node));\n    if (!s.ok()) {\n      result[0]->Unref();\n      result[0] = nullptr;\n    }\n    return s;\n#endif  // !IS_MOBILE_PLATFORM\n  }\n}\n\nnamespace {\n// Low-level utility function to execute the kernel specified by `kernel` on\n// `kernel->device()`, with the provided inputs as `op_inputs` in the 'ctx'.\n// Different from `EagerKernelExecute` that ties up the thread until the\n// underlying function finishes execute, this function does not block the thread\n// and could return before the function execution finishes. The provided\n// `StatusCallback` will be triggered after function execution with its status.\nvoid EagerKernelExecuteAsync(\n    EagerContext* ctx, const absl::InlinedVector<TensorHandle*, 4>& op_inputs,\n    const absl::optional<EagerFunctionParams>& eager_func_params,\n    const core::RefCountPtr<KernelAndDevice> kernel,\n    GraphCollector* graph_collector, CancellationManager* cancellation_manager,\n    TensorHandle** retvals, int num_outputs, StatusCallback done) {\n  auto inputs = std::make_shared<ExecuteNodeArgs>(op_inputs.size());\n  auto outputs = std::make_shared<std::vector<EagerKernelRet>>(1);\n\n  Status s = inputs->Init(ctx, op_inputs, kernel);\n  if (!s.ok()) {\n    done(s);\n    return;\n  }\n  CoordinationServiceAgent* coord_agent = nullptr;\n#if !defined(IS_MOBILE_PLATFORM)\n  if (ctx->GetDistributedManager() != nullptr)\n    coord_agent = ctx->GetDistributedManager()->GetCoordinationServiceAgent();\n#endif  // !IS_MOBILE_PLATFORM\n\n  kernel->Ref();  // Ownership of reference is transferred to the callback\n  kernel->RunAsync(\n      ctx->StepContainer(), *inputs, outputs.get(), cancellation_manager,\n      eager_func_params, coord_agent,\n      [retvals, inputs, outputs, num_outputs, ctx, graph_collector,\n       eager_func_params, kernel_raw = kernel.get(),\n       done = std::move(done)](const Status& s) {\n        auto wrapped_done = [&](const Status& s) {\n          kernel_raw->Unref();\n          done(s);\n        };\n        if (!s.ok()) {\n          wrapped_done(s);\n          return;\n        }\n        if (graph_collector != nullptr) {\n          CollectGraphs(ctx);\n        }\n        DCHECK_EQ(num_outputs, outputs->size());\n        wrapped_done(GetKernelOutputs(outputs.get(), num_outputs, retvals, ctx,\n                                      kernel_raw, eager_func_params));\n      });\n}\n}  // namespace\n\n// Low-level utility to run the eager operation on local devices. Different from\n// `EagerLocalExecute` which blocks and waits for the finishing the op\n// execution, this method does not block the thread and could return before the\n// eager operation execution finishes. The provided `StatusCallback` will be\n// triggered after execution with its status.\nvoid EagerLocalExecuteAsync(EagerOperation* op, TensorHandle** retvals,\n                            int* num_retvals, StatusCallback done) {\n  if (!op->IsLocal()) {\n    done(errors::InvalidArgument(\n        \"Remote execution is not supported in async EagerLocalExecuteAsync\"));\n    return;\n  }\n\n  profiler::ScopedMemoryDebugAnnotation op_annotation(\n      op->op_name(), op->eager_func_params().has_value()\n                         ? op->eager_func_params().value().step_id.value_or(0)\n                         : 0);\n  profiler::TraceMe activity(\n      [&] { return absl::StrCat(\"EagerLocalExecuteAsync: \", op->Name()); },\n      profiler::TraceMeLevel::kInfo);\n  EagerContext& ctx = op->EagerContext();\n\n  core::RefCountPtr<KernelAndDevice> kernel;\n  Status s = GetOrCreateKernelAndDevice(op, retvals, num_retvals, &kernel);\n  if (!s.ok()) {\n    done(s);\n    return;\n  }\n\n  int num_outputs = kernel->num_outputs();\n  s = ValidateInputTypeAndPlacement(&ctx, op, kernel);\n  if (!s.ok()) {\n    done(s);\n    return;\n  }\n\n  if (ctx.LogDevicePlacement() || VLOG_IS_ON(1)) {\n    string msg = strings::StrCat(\"Executing op \", op->Name(), \" in device \",\n                                 kernel->device()->name());\n    if (!logging::LogToListeners(msg)) {\n      LOG(INFO) << msg;\n    }\n  }\n\n  GraphCollector* graph_collector = nullptr;\n  if (ctx.ShouldStoreGraphs()) {\n    graph_collector = ctx.GetGraphCollector();\n  }\n\n  for (int i = 0, end = num_outputs; i < end; ++i) {\n    const DataTypeVector& output_dtypes = kernel->output_dtypes();\n    retvals[i] = TensorHandle::CreateEmptyLocalHandle(\n        /* d= */ ctx.CanonicalDevice(kernel->OutputDevice(i)),\n        /* op_device= */ kernel->device(),\n        /* resource_device= */ kernel->OutputResourceDevice(i),\n        output_dtypes[i], &ctx);\n  }\n\n  const absl::InlinedVector<TensorHandle*, 4>* inputs;\n  s = op->TensorHandleInputs(&inputs);\n  if (!s.ok()) {\n    done(s);\n    return;\n  }\n  EagerKernelExecuteAsync(\n      &ctx, *inputs, op->eager_func_params(), std::move(kernel),\n      graph_collector, op->GetCancellationManager(), retvals, num_outputs,\n      [op, num_outputs, retvals, done = std::move(done)](const Status& s) {\n        op->Clear();\n        // Since the operation failed, we need to Unref any outputs if they were\n        // allocated.\n        if (!s.ok()) {\n          for (int i = 0, end = num_outputs; i < end; ++i) {\n            if (retvals[i] != nullptr) {\n              retvals[i]->Unref();\n              retvals[i] = nullptr;\n            }\n          }\n        }\n        done(s);\n      });\n}\n}  // namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for tensorflow.ops.data_flow_ops.{,parallel_}dynamic_stitch.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import data_flow_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import gradients_impl\nimport tensorflow.python.ops.data_flow_grad  # pylint: disable=unused-import\nfrom tensorflow.python.platform import test\n\n\nclass DynamicStitchTestBase(object):\n\n  def __init__(self, stitch_op):\n    self.stitch_op = stitch_op\n\n  def testScalar(self):\n    with test_util.use_gpu():\n      indices = [constant_op.constant(0), constant_op.constant(1)]\n      data = [constant_op.constant(40), constant_op.constant(60)]\n      for step in -1, 1:\n        stitched_t = self.stitch_op(indices[::step], data)\n        stitched_val = self.evaluate(stitched_t)\n        self.assertAllEqual([40, 60][::step], stitched_val)\n        # Dimension 0 is max(flatten(indices))+1.\n        self.assertEqual([2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testShapeInferenceForScalarWithNonConstantIndices(self):\n    with test_util.use_gpu():\n      indices = [\n          array_ops.placeholder(dtype=dtypes.int32),\n          constant_op.constant(1)\n      ]\n      data = [constant_op.constant(40), constant_op.constant(60)]\n      for step in -1, 1:\n        stitched_t = self.stitch_op(indices[::step], data)\n        # Dimension 0 is max(flatten(indices))+1, but the first indices input is\n        # not a constant tensor, so we can only infer it as a vector of unknown\n        # length.\n        self.assertEqual([None], stitched_t.get_shape().as_list())\n\n  @test_util.disable_tfrt(\"b/169901260\")\n  def testSimpleOneDimensional(self):\n    # Test various datatypes in the simple case to ensure that the op was\n    # registered under those types.\n    dtypes_to_test = [\n        dtypes.float32, dtypes.qint8, dtypes.quint8, dtypes.qint32\n    ]\n    for dtype in dtypes_to_test:\n      indices = [\n          constant_op.constant([0, 4, 7]),\n          constant_op.constant([1, 6, 2, 3, 5])\n      ]\n      data = [\n          math_ops.cast(constant_op.constant([0, 40, 70]), dtype=dtype),\n          math_ops.cast(\n              constant_op.constant([10, 60, 20, 30, 50]), dtype=dtype)\n      ]\n      stitched_t = self.stitch_op(indices, data)\n      stitched_val = self.evaluate(stitched_t)\n      self.assertAllEqual([0, 10, 20, 30, 40, 50, 60, 70], stitched_val)\n      # Dimension 0 is max(flatten(indices))+1.\n      self.assertEqual([8], stitched_t.get_shape().as_list())\n\n  def testOneListOneDimensional(self):\n    indices = [constant_op.constant([1, 6, 2, 3, 5, 0, 4, 7])]\n    data = [constant_op.constant([10, 60, 20, 30, 50, 0, 40, 70])]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual([0, 10, 20, 30, 40, 50, 60, 70], stitched_val)\n    # Dimension 0 is max(flatten(indices))+1.\n    self.assertEqual([8], stitched_t.get_shape().as_list())\n\n  def testSimpleTwoDimensional(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6]),\n        constant_op.constant([2, 3, 5])\n    ]\n    data = [\n        constant_op.constant([[0, 1], [40, 41], [70, 71]]),\n        constant_op.constant([[10, 11], [60, 61]]),\n        constant_op.constant([[20, 21], [30, 31], [50, 51]])\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual([[0, 1], [10, 11], [20, 21], [30, 31], [40, 41],\n                         [50, 51], [60, 61], [70, 71]], stitched_val)\n    # Dimension 0 is max(flatten(indices))+1.\n    self.assertEqual([8, 2], stitched_t.get_shape().as_list())\n\n  def testZeroSizeTensor(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6]),\n        constant_op.constant([2, 3, 5]),\n        array_ops.zeros([0], dtype=dtypes.int32)\n    ]\n    data = [\n        constant_op.constant([[0, 1], [40, 41], [70, 71]]),\n        constant_op.constant([[10, 11], [60, 61]]),\n        constant_op.constant([[20, 21], [30, 31], [50, 51]]),\n        array_ops.zeros([0, 2], dtype=dtypes.int32)\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual([[0, 1], [10, 11], [20, 21], [30, 31], [40, 41],\n                         [50, 51], [60, 61], [70, 71]], stitched_val)\n    # Dimension 0 is max(flatten(indices))+1.\n    self.assertEqual([8, 2], stitched_t.get_shape().as_list())\n\n  def testAllZeroSizeTensor(self):\n    indices = [\n        array_ops.zeros([0], dtype=dtypes.int32),\n        array_ops.zeros([0], dtype=dtypes.int32)\n    ]\n    data = [\n        array_ops.zeros([0, 2], dtype=dtypes.int32),\n        array_ops.zeros([0, 2], dtype=dtypes.int32)\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual(np.zeros((0, 2)), stitched_val)\n    self.assertEqual([0, 2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testHigherRank(self):\n    indices = [\n        constant_op.constant(6),\n        constant_op.constant([4, 1]),\n        constant_op.constant([[5, 2], [0, 3]])\n    ]\n    data = [\n        constant_op.constant([61., 62.]),\n        constant_op.constant([[41., 42.], [11., 12.]]),\n        constant_op.constant([[[51., 52.], [21., 22.]],\n                              [[1., 2.], [31., 32.]]])\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    correct = 10. * np.arange(7)[:, None] + [1., 2.]\n    self.assertAllEqual(correct, stitched_val)\n    self.assertEqual([7, 2], stitched_t.get_shape().as_list())\n    # Test gradients\n    stitched_grad = 7. * stitched_val\n    grads = gradients_impl.gradients(stitched_t, indices + data,\n                                     stitched_grad)\n    self.assertEqual(grads[:3], [None] * 3)  # Indices have no gradients\n    for datum, grad in zip(data, self.evaluate(grads[3:])):\n      self.assertAllEqual(7. * self.evaluate(datum), grad)\n\n  @test_util.run_deprecated_v1\n  def testErrorIndicesMultiDimensional(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([[1, 6, 2, 3, 5]])\n    ]\n    data = [\n        constant_op.constant([[0, 40, 70]]),\n        constant_op.constant([10, 60, 20, 30, 50])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  @test_util.run_deprecated_v1\n  def testErrorDataNumDimsMismatch(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6, 2, 3, 5])\n    ]\n    data = [\n        constant_op.constant([0, 40, 70]),\n        constant_op.constant([[10, 60, 20, 30, 50]])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  @test_util.run_deprecated_v1\n  def testErrorDataDimSizeMismatch(self):\n    indices = [\n        constant_op.constant([0, 4, 5]),\n        constant_op.constant([1, 6, 2, 3])\n    ]\n    data = [\n        constant_op.constant([[0], [40], [70]]),\n        constant_op.constant([[10, 11], [60, 61], [20, 21], [30, 31]])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  @test_util.run_deprecated_v1\n  def testErrorDataAndIndicesSizeMismatch(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6, 2, 3, 5])\n    ]\n    data = [\n        constant_op.constant([0, 40, 70]),\n        constant_op.constant([10, 60, 20, 30])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n\nclass DynamicStitchTest(DynamicStitchTestBase, test.TestCase):\n\n  def __init__(self, *test_case_args):\n    test.TestCase.__init__(self, *test_case_args)\n    DynamicStitchTestBase.__init__(self, data_flow_ops.dynamic_stitch)\n\n\nclass ParallelDynamicStitchTest(DynamicStitchTestBase, test.TestCase):\n\n  def __init__(self, *test_case_args):\n    test.TestCase.__init__(self, *test_case_args)\n    DynamicStitchTestBase.__init__(self, data_flow_ops.parallel_dynamic_stitch)\n\n  def testScalar(self):\n    with test_util.use_gpu():\n      indices = [constant_op.constant(0), constant_op.constant(1)]\n      data = [constant_op.constant(40.0), constant_op.constant(60.0)]\n      for step in -1, 1:\n        stitched_t = data_flow_ops.dynamic_stitch(indices[::step], data)\n        stitched_val = self.evaluate(stitched_t)\n        self.assertAllEqual([40.0, 60.0][::step], stitched_val)\n        # Dimension 0 is max(flatten(indices))+1.\n        self.assertEqual([2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testHigherRank(self):\n    indices = [\n        constant_op.constant(6),\n        constant_op.constant([4, 1]),\n        constant_op.constant([[5, 2], [0, 3]])\n    ]\n    data = [\n        constant_op.constant([61, 62], dtype=dtypes.float32),\n        constant_op.constant([[41, 42], [11, 12]], dtype=dtypes.float32),\n        constant_op.constant(\n            [[[51, 52], [21, 22]], [[1, 2], [31, 32]]], dtype=dtypes.float32)\n    ]\n    stitched_t = data_flow_ops.dynamic_stitch(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    correct = 10 * np.arange(7)[:, None] + [1.0, 2.0]\n    self.assertAllEqual(correct, stitched_val)\n    self.assertEqual([7, 2], stitched_t.get_shape().as_list())\n    # Test gradients\n    stitched_grad = 7 * stitched_val\n    grads = gradients_impl.gradients(stitched_t, indices + data,\n                                     stitched_grad)\n    self.assertEqual(grads[:3], [None] * 3)  # Indices have no gradients\n    for datum, grad in zip(data, self.evaluate(grads[3:])):\n      self.assertAllEqual(7.0 * self.evaluate(datum), grad)\n\n  # GPU version unit tests\n  def testScalarGPU(self):\n    indices = [constant_op.constant(0), constant_op.constant(1)]\n    data = [constant_op.constant(40.0), constant_op.constant(60.0)]\n    for step in -1, 1:\n      stitched_t = data_flow_ops.dynamic_stitch(indices[::step], data)\n      stitched_val = self.evaluate(stitched_t)\n      self.assertAllEqual([40.0, 60.0][::step], stitched_val)\n      # Dimension 0 is max(flatten(indices))+1.\n      self.assertEqual([2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testHigherRankGPU(self):\n    indices = [\n        constant_op.constant(6),\n        constant_op.constant([4, 1]),\n        constant_op.constant([[5, 2], [0, 3]])\n    ]\n    data = [\n        constant_op.constant([61, 62], dtype=dtypes.float32),\n        constant_op.constant([[41, 42], [11, 12]], dtype=dtypes.float32),\n        constant_op.constant(\n            [[[51, 52], [21, 22]], [[1, 2], [31, 32]]], dtype=dtypes.float32)\n    ]\n    stitched_t = data_flow_ops.dynamic_stitch(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    correct = 10 * np.arange(7)[:, None] + [1.0, 2.0]\n    self.assertAllEqual(correct, stitched_val)\n    self.assertEqual([7, 2], stitched_t.get_shape().as_list())\n    # Test gradients\n    stitched_grad = 7 * stitched_val\n    grads = gradients_impl.gradients(stitched_t, indices + data,\n                                     stitched_grad)\n    self.assertEqual(grads[:3], [None] * 3)  # Indices have no gradients\n    for datum, grad in zip(data, self.evaluate(grads[3:])):\n      self.assertAllEqual(7.0 * self.evaluate(datum), grad)\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "fixing_code": ["/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/common_runtime/eager/execute.h\"\n\n#include <algorithm>\n#include <cstddef>\n#include <optional>\n#include <vector>\n\n// clang-format off\n// Required for IS_MOBILE_PLATFORM\n#include \"absl/container/btree_map.h\"\n#include \"absl/container/flat_hash_set.h\"\n#include \"absl/strings/str_replace.h\"\n#include \"tensorflow/core/common_runtime/eager/eager_operation.h\"\n#include \"tensorflow/core/framework/cancellation.h\"\n#include \"tensorflow/core/framework/function.pb.h\"\n#include \"tensorflow/core/framework/kernel_def.pb.h\"\n#include \"tensorflow/core/framework/node_def.pb.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/lib/core/refcount.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/platform.h\"\n#include \"tensorflow/core/platform/protobuf.h\"\n\n// clang-format on\n\n#include \"absl/container/inlined_vector.h\"\n#include \"absl/strings/match.h\"\n#include \"absl/strings/str_cat.h\"\n#include \"absl/types/optional.h\"\n#include \"tensorflow/c/tf_tensor_internal.h\"\n#include \"tensorflow/compiler/jit/defs.h\"\n#include \"tensorflow/core/common_runtime/colocation_graph.h\"\n#include \"tensorflow/core/common_runtime/device.h\"\n#include \"tensorflow/core/common_runtime/device_set.h\"\n#include \"tensorflow/core/common_runtime/eager/context.h\"\n#include \"tensorflow/core/common_runtime/eager/copy_to_device_node.h\"\n#include \"tensorflow/core/common_runtime/eager/execute_node.h\"\n#include \"tensorflow/core/common_runtime/eager/kernel_and_device.h\"\n#include \"tensorflow/core/common_runtime/eager/tensor_handle.h\"\n#include \"tensorflow/core/framework/dataset.h\"\n#include \"tensorflow/core/framework/function.h\"\n#include \"tensorflow/core/framework/logging.h\"\n#include \"tensorflow/core/framework/node_def_util.h\"\n#include \"tensorflow/core/framework/tensor_reference.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/platform/statusor.h\"\n#include \"tensorflow/core/profiler/lib/scoped_memory_debug_annotation.h\"\n#include \"tensorflow/core/profiler/lib/traceme.h\"\n#include \"tensorflow/core/protobuf/error_codes.pb.h\"\n#include \"tensorflow/core/util/device_name_utils.h\"\n#if !defined(IS_MOBILE_PLATFORM)\n#include \"tensorflow/core/distributed_runtime/eager/eager_client.h\"\n#include \"tensorflow/core/distributed_runtime/eager/remote_copy_node.h\"\n#include \"tensorflow/core/distributed_runtime/eager/remote_mgr.h\"\n#include \"tensorflow/core/distributed_runtime/eager/remote_execute_node.h\"\n#include \"tensorflow/core/protobuf/remote_tensor_handle.pb.h\"\n#endif  // IS_MOBILE_PLATFORM\n#include \"tensorflow/core/common_runtime/eager/eager_op_rewrite_registry.h\"\n#include \"tensorflow/core/framework/step_stats.pb.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/gtl/cleanup.h\"\n#include \"tensorflow/core/lib/gtl/flatset.h\"\n#include \"tensorflow/core/lib/random/random.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/util/ptr_util.h\"\n#include \"tensorflow/core/util/util.h\"\n\n#ifdef INTEL_MKL\n#include \"tensorflow/core/graph/mkl_graph_util.h\"\n#endif\n\nnamespace tensorflow {\n\nnamespace {\n\nconst string& DeviceNameOrUnspecified(Device* device) {\n  static string* unspecified_string = new string(\"<unspecified>\");\n  return (device == nullptr) ? *unspecified_string : device->name();\n}\n\n// Returns whether a kernel should be cached.\nbool KernelCacheEnabled(const OpDef& op_def) {\n  if (data::DatasetOpKernel::IsDatasetOp(op_def)) {\n    return false;\n  }\n  // TODO(b/162540360): Revisit a way to mark kernels as uncachable once we have\n  // 5+ kernels to exclude.\n  return true;\n}\n\n// This function expects *handle to point to an existing tensor handle that is\n// currently on \"handle_device\", but where the operation expects that input to\n// reside on \"expected_input_device\".  The function will arrange for this\n// transfer to happen and will return OK on success and will storage a new\n// handle to the equivalent tensor on the correct device in \"*result\".  Or if an\n// error is encountered, it will return a non-OK status and set \"*result\" to\n// nullptr.\n//\n// `op_device` is passed in explicitly because `op->device()` might be\n// unset and we might have selected some specific device to run this op on.\nStatus CopyInputToExpectedDevice(EagerContext* ctx, EagerOperation* op,\n                                 Device* op_device,\n                                 TensorHandle* handle,  // op->Inputs()[i]\n                                 int i, Device* handle_device,\n                                 Device* expected_input_device,\n                                 TensorHandle** result) {\n  VLOG(6) << \"Expected input device: \" << expected_input_device->name()\n          << \"; handle_device: \" << handle_device->name();\n  // Should only be called when these don't match\n  DCHECK(expected_input_device != handle_device);\n  *result = nullptr;\n  const string& op_device_name = DeviceNameOrUnspecified(op_device);\n\n  switch (ctx->GetDevicePlacementPolicy()) {\n    case DEVICE_PLACEMENT_SILENT_FOR_INT32:\n      // TODO(xpan): See if we could bubble python related error up\n      // to python level.\n      if (handle->dtype == DT_INT32) {\n        // Note: enabling silent copies of int32 tensors to match behavior\n        // of graph mode.\n        break;\n      }\n      VLOG(6) << \"DevicePlacementPolicy: DEVICE_PLACEMENT_SILENT_FOR_INT32 but \"\n                 \"input type is not INT32.\";\n      TF_FALLTHROUGH_INTENDED;\n    case DEVICE_PLACEMENT_EXPLICIT:\n      // tf.identity is allowed to copy, as indicated in the error message\n      // below.\n      if (op->Name() == \"Identity\" ||\n          op->Name() == \"IdentityN\"\n          // Constants start on CPU:0 and are copied via EagerConst to the\n          // current device.\n          || op->Name() == \"_EagerConst\") {\n        break;\n      }\n      return errors::InvalidArgument(\n          \"Tensors on conflicting devices:\"\n          \" cannot compute \",\n          op->Name(), \" as input #\", i, \" was expected to be on \",\n          expected_input_device->name(), \" but is actually on \",\n          handle_device->name(), \" (operation running on \", op_device_name, \")\",\n          \" Tensors can be copied explicitly using:\"\n          \" `with tf.device(device_name): x = tf.identity(x)`\"\n          \" or transparently copied by using\"\n          \" tf.config.experimental.set_device_policy('silent').\"\n          \" Copying tensors between devices may slow down your model\");\n    case DEVICE_PLACEMENT_WARN:\n      LOG(WARNING) << \"before computing \" << op->Name() << \" input #\" << i\n                   << \" was expected to be on \" << expected_input_device->name()\n                   << \" but is actually on \" << handle_device->name()\n                   << \" (operation running on \" << op_device_name\n                   << \"). This triggers a copy which can be a performance \"\n                      \"bottleneck.\";\n      break;\n    case DEVICE_PLACEMENT_SILENT:  // Do nothing.\n      break;\n  }\n  // We are only here if the policy is warn or silent copies, so we should\n  // trigger a copy.\n  TensorHandle* result_handle = nullptr;\n  profiler::TraceMe activity(\n      [&] {\n        return absl::StrCat(\"_Send input \", i, \" from \", handle_device->name(),\n                            \" to \", expected_input_device->name());\n      },\n      profiler::TraceMeLevel::kInfo);\n  Status status =\n      EagerCopyToDevice(handle, ctx, &op->Executor(), expected_input_device,\n                        /* mirror= */ true, &result_handle);\n  activity.Stop();\n  if (!status.ok()) {\n    return Status(\n        status.code(),\n        absl::StrCat(\"Failed copying input tensor from \", handle_device->name(),\n                     \" to \", expected_input_device->name(), \" in order to run \",\n                     op->Name(), \": \", status.error_message()));\n  }\n\n  *result = result_handle;\n\n  return OkStatus();\n}\n\n// `op_device_name` the name of the device on which the op will run, if any.\n// For functions running using function library runtime, the device can be\n// unspecified.\nStatus ValidateInputTypeAndPlacement(\n    EagerContext* ctx, EagerOperation* op,\n    const core::RefCountPtr<KernelAndDevice>& kernel) {\n  profiler::TraceMe activity(\"ValidateInputTypeAndPlacement\",\n                             profiler::TraceMeLevel::kInfo);\n  const int n_inputs = op->Inputs().size();\n  if (kernel->num_inputs() != n_inputs) {\n    return errors::InvalidArgument(\"expected \", kernel->num_inputs(),\n                                   \" inputs, got \", n_inputs);\n  }\n  const bool is_function = kernel->IsFunction();\n  if (n_inputs > 0) {\n    const DataType* input_types = &kernel->input_dtypes()[0];\n    const absl::InlinedVector<TensorHandle*, 4>* handles;\n    TF_RETURN_IF_ERROR(op->TensorHandleInputs(&handles));\n    for (int i = 0; i < n_inputs; ++i) {\n      TensorHandle* handle = (*handles)[i];\n      Device* expected_device = kernel->InputDevice(i);\n      if (!kernel->IsFunction() && handle->Type() == TensorHandle::PACKED) {\n        // Extract a handle on the op device from a packed input.\n        // This happens when a function is marked for XLA compilation.\n        // MaybePackInputTensor guarantees that a primitive op has no packed\n        // input at this point.\n        for (int j = 0; j < handle->NumPackedHandles(); ++j) {\n          TensorHandle* h = nullptr;\n          TF_RETURN_IF_ERROR(handle->ExtractPackedHandle(j, &h));\n          if ((h->op_device() != nullptr) &&\n              (h->op_device()->name() == op->DeviceName())) {\n            op->UpdateInput(i, h);\n            handle = h;\n            break;\n          }\n        }\n      }\n      Device* handle_device = handle->DeviceOrHostCPU(*ctx);\n      const bool maybe_copy =\n          !is_function || handle->Type() != TensorHandle::REMOTE;\n      VLOG(6) << \"!is_function: \" << !is_function;\n      VLOG(6) << \"handle->Type(): \" << handle->Type();\n      // If the input is already on the right device, then nothing to do.\n      if (expected_device != handle_device && maybe_copy) {\n        TF_RETURN_IF_ERROR(CopyInputToExpectedDevice(ctx, op, kernel->device(),\n                                                     handle, i, handle_device,\n                                                     expected_device, &handle));\n        op->UpdateInput(i, handle);\n        // Unref handle since it has a ref as an input now\n        handle->Unref();\n      }\n      if (handle->dtype != input_types[i]) {\n        return errors::InvalidArgument(\n            \"cannot compute \", op->Name(), \" as input #\", i, \"(zero-based)\",\n            \" was expected to be a \", DataTypeString(input_types[i]),\n            \" tensor but is a \", DataTypeString(handle->dtype), \" tensor\");\n      }\n    }\n  }\n  return OkStatus();\n}\n\nStatus GetOutputDTypes(EagerOperation* op, DataTypeVector* output_dtypes) {\n  const auto& node_def = op->MutableAttrs()->BuildNodeDef();\n  const OpDef* op_def = nullptr;\n\n  const FunctionDef* function_def =\n      op->EagerContext().FuncLibDef()->Find(op->Name());\n  if (function_def != nullptr) {\n    op_def = &(function_def->signature());\n  } else {\n    TF_RETURN_IF_ERROR(OpDefForOp(op->Name().c_str(), &op_def));\n  }\n\n  TF_RETURN_IF_ERROR(OutputTypesForNode(node_def, *op_def, output_dtypes));\n\n  return OkStatus();\n}\n\ninline tensorflow::Fprint128 FingerprintCat128(const tensorflow::Fprint128& a,\n                                               const tensorflow::Fprint128& b) {\n  return {tensorflow::FingerprintCat64(a.low64, b.low64),\n          tensorflow::FingerprintCat64(a.high64, b.high64)};\n}\n\ninline tensorflow::Fprint128 FingerprintCat128(const tensorflow::Fprint128& a,\n                                               const int64_t b) {\n  auto x = tensorflow::FingerprintCat64(a.low64, b);\n  return {x, tensorflow::FingerprintCat64(a.high64, x)};\n}\n\nconst KernelDef* GetKernelDef(const EagerOperation& op, const NodeDef* node_def,\n                              const Device* op_device) {\n  if (node_def == nullptr || op_device == nullptr) return nullptr;\n  const KernelDef* kernel_def = nullptr;\n  Status s = FindKernelDef(DeviceType(op_device->device_type()), *node_def,\n                           &kernel_def,\n                           /*kernel_class_name=*/nullptr);\n  if (!s.ok()) return nullptr;\n  return kernel_def;\n}\n\nbool IsHostMemoryArg(const EagerOperation& op, const NodeDef* node_def,\n                     const Device* op_device, const KernelDef* kernel_def,\n                     const int port_id) {\n  if (op.is_function()) return false;\n  if (node_def == nullptr) return false;\n  if (kernel_def == nullptr || op_device == nullptr) return false;\n  const auto& host_memory_args = kernel_def->host_memory_arg();\n  const OpDef& op_def = OpRegistry::Global()->LookUp(op.Name())->op_def;\n  const int arg_id = OpPortIdToArgId(*node_def, op_def.input_arg(), port_id);\n  // Fail if argument ID not found.\n  if (arg_id < 0) {\n    return false;\n  }\n  return std::find(host_memory_args.begin(), host_memory_args.end(),\n                   op_def.input_arg(arg_id).name()) != host_memory_args.end();\n}\n\nStatus GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,\n                         const bool is_host_memory_arg,\n                         TensorHandle* tensor_handle, Device** result) {\n  Device* cpu_device = ctx.HostCPU();\n  string device_name;\n  if (tensor_handle->Type() != TensorHandle::LOCAL) {\n    Device* device = tensor_handle->device();\n    device_name = device != nullptr ? device->name() : cpu_device->name();\n    *result = (device == nullptr ? cpu_device : device);\n  } else if (tensor_handle->dtype == DT_RESOURCE) {\n    // Use the resource's actual device because it is the device that will\n    // influence partitioning the multi-device function.\n    const Tensor* tensor;\n    // TODO(fishx): Avoid blocking here.\n    TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));\n    if (tensor->NumElements() == 0) {\n      return errors::InvalidArgument(\"Empty resource handle\");\n    }\n    const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);\n    device_name = handle.device();\n\n    Device* input_device;\n    TF_RETURN_IF_ERROR(\n        ctx.FindDeviceFromName(device_name.c_str(), &input_device));\n    *result = input_device;\n  } else {\n    Device* device = tensor_handle->device();\n    const bool is_tpu = device != nullptr && device->device_type() == \"TPU\";\n    // int32 return values can be placed on TPUs.\n    // int32 retrun values can be placed on device for eager operations.\n    const bool use_host_memory =\n        is_tpu || (!op.is_function() && device != cpu_device &&\n                   !is_host_memory_arg)\n            ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)\n            : MTypeFromDType(tensor_handle->dtype);\n    if (use_host_memory) {\n      *result = cpu_device;\n    } else {\n      // Eager ops executing as functions should have their preferred inputs set\n      // to the op's device. This allows us to avoid expensive D2H copies if a\n      // mirror of the tensor already exists on the op's device.\n      if (!op.is_function() && device != cpu_device && !is_host_memory_arg) {\n        device = absl::get<Device*>(op.Device());\n      }\n      *result = (device == nullptr ? cpu_device : device);\n    }\n  }\n  return OkStatus();\n}\n\n// Appends a TensorShape object to Fprint128 hash.\n// For best performance, we would like to avoid dynamic memory allocation in\n// this function.\n// If \"shape\" has unknown rank, we attach \"?\" to hashed content; otherwise we\n// attach every dim size to hashed content.\nvoid AppendTensorShapeToFingerprint(const PartialTensorShape& shape,\n                                    Fprint128* fingerprint) {\n  if (shape.unknown_rank()) {\n    char c = '?';\n    *fingerprint = FingerprintCat128(*fingerprint, c);\n  } else {\n    for (int i = 0; i < shape.dims(); i++) {\n      int64_t dim = shape.dim_size(i);\n      *fingerprint = FingerprintCat128(*fingerprint, dim);\n    }\n  }\n}\n\nStatus GetFuncAttr(const EagerOperation* op, const EagerContext& ctx,\n                   const char* attr_name, bool* value) {\n  Status status = op->Attrs().Get(attr_name, value);\n  if (status.ok()) {\n    VLOG(2) << \"Caller explicitly specifies \" << attr_name\n            << (value ? \"=true \" : \"=false, \") << op->DebugString();\n    return OkStatus();\n  }\n\n  const FunctionDef* function_def =\n      ctx.pflr()->GetFunctionLibraryDefinition()->Find(op->Name());\n  if (function_def == nullptr) {\n    return errors::NotFound(\"Failed to find function '\", op->Name(), \"'\");\n  }\n\n  status = GetNodeAttr(AttrSlice(&function_def->attr()), attr_name, value);\n  if (status.ok()) {\n    VLOG(2) << \"Function definition explicitly specifies \" << attr_name\n            << (value ? \"=true\" : \"=false\");\n    return OkStatus();\n  }\n  return status;\n}\n\nStatus MustCompileWithXLA(const EagerOperation* op, const EagerContext& ctx,\n                          bool* compile_with_xla) {\n  if (!op->is_function()) {\n    *compile_with_xla = false;\n    return OkStatus();\n  }\n\n  if (op->eager_func_params().has_value() &&\n      op->eager_func_params().value().is_component_function) {\n    // If the op is a component of a multi-device function, don't compile it\n    // with XLA.\n    *compile_with_xla = false;\n    return OkStatus();\n  }\n\n  Status status = GetFuncAttr(op, ctx, kXlaMustCompileAttr, compile_with_xla);\n  if (status.ok()) {\n    return OkStatus();\n  }\n\n  // No explicit requests. Compile for XLA devices by default.\n  if (op->GetDeviceParsedName().type == \"TPU\" ||\n      op->GetDeviceParsedName().type == \"XLA_GPU\" ||\n      op->GetDeviceParsedName().type == \"XLA_CPU\") {\n    VLOG(2) << \"Compiling \" << op->Name()\n            << \" with XLA because it is running on an XLA device \"\n            << op->GetDeviceParsedName().type;\n    *compile_with_xla = true;\n  } else {\n    *compile_with_xla = false;\n  }\n\n  return OkStatus();\n}\n\nStatus VerifyWrappableInCallOp(const OpDef& opdef, EagerOperation* op) {\n  absl::flat_hash_set<string> opdef_attrs;\n  for (const auto& attr : opdef.attr()) {\n    opdef_attrs.insert(attr.name());\n  }\n  const auto& node_def = op->MutableAttrs()->BuildNodeDef();\n  for (const auto& attr : node_def.attr()) {\n    if (opdef_attrs.find(attr.first) == opdef_attrs.end()) {\n      return errors::Unimplemented(\"EagerOperation: \", op->Name(),\n                                   \" has a private attr '\", attr.first, \"'.\");\n    }\n  }\n  return OkStatus();\n}\n\nusing ProtoArgListType = protobuf::RepeatedPtrField<OpDef_ArgDef>;\n\nstring EscapeOrigName(const string& orig_name) {\n  // Replace _ with __ in the original name to avoid name conflicts.\n  return absl::StrReplaceAll(orig_name, {{\"_\", \"__\"}});\n}\n\n// Variadic args are flattened during wrapping. This utility returns the name\n// of a flattened arg/attr.\nstring GetFlatName(const string orig_name, int index) {\n  return absl::StrCat(EscapeOrigName(orig_name), \"_\", index);\n}\n\n// Builds the name of the wrapping FunctionDef for an eager op.\n//\n// For ops without variadic inputs/outputs, the name is simply __wrapped_OpType.\n//\n// For ops with variadic inputs/outputs, the arity of each variadic attr is\n// encoded in the name. For example:\n//\n// IdentityN[T:[DT_FLOAT, DT_INT64]] -> __wrapped__IdentityN_T_2\n// Concat[N:2, T:DT_FLOAT] -> __wrapped__Concat_N_2\nStatus BuildWrappedOpName(EagerOperation* op, const OpDef& opdef,\n                          const AbstractOpAttrs* op_attrs, string* name) {\n  string fname = absl::StrCat(\"__wrapped__\", EscapeOrigName(op->Name()));\n  // For every variadic arg in `args`, populates `attr_to_len` with\n  // (attr_name, len(arg)).\n  auto FillAttrToLen = [op_attrs, op](\n                           const ProtoArgListType& args,\n                           absl::btree_map<string, int>* attr_to_len) {\n    for (const auto& arg : args) {\n      if (!arg.type_list_attr().empty()) {\n        gtl::InlinedVector<DataType, 4> type_list;\n        TF_RETURN_IF_ERROR(\n            op_attrs->GetTypeList(arg.type_list_attr(), &type_list));\n        (*attr_to_len)[arg.type_list_attr()] = type_list.size();\n      } else if (!arg.number_attr().empty()) {\n        int64_t number_attr;\n        if (!op_attrs->GetInt(arg.number_attr(), &number_attr)) {\n          return errors::Internal(\"Unable to read attr \", arg.number_attr(),\n                                  \" for op \", op->Name());\n        }\n        (*attr_to_len)[arg.number_attr()] = number_attr;\n      }\n    }\n    return OkStatus();\n  };\n  absl::btree_map<string, int> attr_to_len;\n  TF_RETURN_IF_ERROR(FillAttrToLen(opdef.input_arg(), &attr_to_len));\n  TF_RETURN_IF_ERROR(FillAttrToLen(opdef.output_arg(), &attr_to_len));\n  for (auto& name_len : attr_to_len) {\n    absl::StrAppend(&fname, \"_\", name_len.first, \"_\", name_len.second);\n  }\n  // The NodeDef in the FunctionDef gets placed on `op-DeviceName()` to ensure\n  // placement consistency with eager mode.\n  // TODO(b/200153278): Ideally we would just forward the call op's device at\n  // runtime but currently there is no way to do it so we incur the cost of\n  // creating extra FunctionDefs.\n  absl::StrAppend(&fname, \"_device_\", op->DeviceName());\n  *name = fname;\n  return OkStatus();\n}\n\n// Validates the node def. This is required when running in eager op as function\n// mode because this code path does not go through the _apply_op_helper's\n// validation (which is reached when executing in graph mode)\n// or the eager execution's validation (which is reached via the CreateOpKernel\n// call).\nStatus ValidateOp(EagerOperation* op) {\n  const NodeDef& node_def = op->MutableAttrs()->BuildNodeDef();\n  const OpDef* op_def;\n  TF_RETURN_IF_ERROR(OpRegistry::Global()->LookUpOpDef(node_def.op(), &op_def));\n  return ValidateNodeDef(node_def, *op_def);\n}\n\n// Builds the signature of the wrapping FunctionDef for an eager op.\n//\n// For ops without variadic inputs/outputs, the signature is the same as the\n// OpDef of the original op.\n//\n// Variadic inputs/outputs get flattened since we do not support executing\n// functions with variadic signatures.\n//\n// TODO(srbs): These examples should be tests.\n//\n// Examples:\n//\n// Mixed type list:\n//\n// op {\n//   name: \"IdentityN\"\n//   input_arg {\n//     name: \"input\"\n//     type_list_attr: \"T\"\n//   }\n//   output_arg {\n//     name: \"output\"\n//     type_list_attr: \"T\"\n//   }\n//   attr {\n//     name: \"T\"\n//     type: \"list(type)\"\n//     has_minimum: true\n//     minimum: 1\n//   }\n// }\n//\n// With two inputs T=[DT_FLOAT, DT_INT64] would convert to\n//\n// op {\n//   name: \"__wrapped__IdentityN_T_2\"\n//   input_arg {\n//     name: \"input_0\"\n//     type_attr: \"T_0\"\n//   }\n//   input_arg {\n//     name: \"input_1\"\n//     type_attr: \"T_1\"\n//   }\n//   output_arg {\n//     name: \"output_0\"\n//     type_attr: \"T_0\"\n//   }\n//   output_arg {\n//     name: \"output_1\"\n//     type_attr: \"T_1\"\n//   }\n//   attr {\n//     name: \"T_0\"\n//     type: \"type\"\n//   }\n//   attr {\n//     name: \"T_1\"\n//     type: \"type\"\n//   }\n//   attr {\n//     name: \"T\"\n//     type: \"list(type)\"\n//     has_minimum: true\n//     minimum: 1\n//   }\n// }\n//\n// Note that the list(type) attr is preserved so that it can get copied to the\n// inner op via a placeholder. This allows additional verification.\n//\n// Single type list:\n//\n// op {\n//   name: \"ConcatV2\"\n//   input_arg {\n//     name: \"values\"\n//     type_attr: \"T\"\n//     number_attr: \"N\"\n//   }\n//   attr {\n//     name: \"N\"\n//     type: \"int\"\n//     has_minimum: true\n//     minimum: 2\n//   }\n//   attr {\n//     name: \"T\"\n//     type: \"type\"\n//   }\n//   [axis, output, Tidx are simply copied]\n// }\n//\n// With two inputs N=2 would convert to:\n//\n// op {\n//   name: \"__wrapped__ConcatV2_N_2\"\n//   input_arg {\n//     name: \"values_0\"\n//     type_attr: \"T\"\n//   }\n//   input_arg {\n//     name: \"values_1\"\n//     type_attr: \"T\"\n//   }\n//   attr {\n//     name: \"N\"\n//     type: \"int\"\n//     has_minimum: true\n//     minimum: 2\n//   }\n//   attr {\n//     name: \"T\"\n//     type: \"type\"\n//   }\n//   [axis, output, Tidx are simply copied]\n// }\n//\n// Note that the N attr is preserved so that it can get copied to the\n// inner op via a placeholder. This allows additional verification.\nStatus BuildWrappedOpSignature(EagerOperation* op, const OpDef& opdef,\n                               const string& fname, OpDef& signature) {\n  signature = opdef;\n  signature.clear_input_arg();\n  signature.clear_output_arg();\n  signature.set_name(fname);\n  auto op_attrs = op->GetOpAttrs();\n  auto FillSignatureArgs = [op_attrs, op](\n                               const ProtoArgListType& opdef_args,\n                               ProtoArgListType* sig_args,\n                               absl::flat_hash_set<string>& new_attrs) {\n    for (const auto& arg : opdef_args) {\n      if (!arg.type_list_attr().empty()) {\n        gtl::InlinedVector<DataType, 4> type_list;\n        TF_RETURN_IF_ERROR(\n            op_attrs->GetTypeList(arg.type_list_attr(), &type_list));\n        for (size_t i = 0; i < type_list.size(); i++) {\n          auto arg_def = sig_args->Add();\n          arg_def->set_name(GetFlatName(arg.name(), i));\n          auto attr_name = GetFlatName(arg.type_list_attr(), i);\n          new_attrs.insert(attr_name);\n          arg_def->set_type_attr(std::move(attr_name));\n        }\n      } else if (!arg.number_attr().empty()) {\n        int64_t number_attr;\n        if (!op_attrs->GetInt(arg.number_attr(), &number_attr)) {\n          return errors::Internal(\"Unable to read attr \", arg.number_attr(),\n                                  \" for op \", op->Name());\n        }\n        for (int64_t i = 0; i < number_attr; i++) {\n          auto arg_def = sig_args->Add();\n          arg_def->set_name(GetFlatName(arg.name(), i));\n          if (!arg.type_attr().empty()) {\n            arg_def->set_type_attr(arg.type_attr());\n          } else {\n            arg_def->set_type(arg.type());\n          }\n        }\n      } else {\n        auto arg_def = sig_args->Add();\n        *arg_def = arg;\n        arg_def->set_name(EscapeOrigName(arg.name()));\n        if (!arg.type_attr().empty()) {\n          // Don't escape: type attrs are still referenced by the original name.\n          arg_def->set_type_attr(arg.type_attr());\n        }\n      }\n    }\n    return OkStatus();\n  };\n  absl::flat_hash_set<string> new_attrs;\n  TF_RETURN_IF_ERROR(FillSignatureArgs(\n      opdef.input_arg(), signature.mutable_input_arg(), new_attrs));\n  TF_RETURN_IF_ERROR(FillSignatureArgs(\n      opdef.output_arg(), signature.mutable_output_arg(), new_attrs));\n  for (auto& attr_name : new_attrs) {\n    auto attr_def = signature.mutable_attr()->Add();\n    attr_def->set_name(attr_name);\n    attr_def->set_type(\"type\");\n  }\n  return OkStatus();\n}\n\n// For mixed type inputs \"list(type)\" we create new attributes in the signature\n// for each element tensor (See examples in BuildWrappedOpSignature). Here\n// we construct the values for those attributes and set them on the wrapped op.\nStatus AddMixedTypeListAttrs(EagerOperation* wrapped_op,\n                             const AbstractOpAttrs* op_attrs,\n                             const OpDef& opdef) {\n  auto FillAttrsToAdd =\n      [op_attrs](const ProtoArgListType& opdef_args,\n                 absl::flat_hash_map<string, DataType>* attrs_to_add) {\n        for (const auto& arg : opdef_args) {\n          if (!arg.type_list_attr().empty()) {\n            gtl::InlinedVector<DataType, 4> type_list;\n            TF_RETURN_IF_ERROR(\n                op_attrs->GetTypeList(arg.type_list_attr(), &type_list));\n            for (size_t i = 0; i < type_list.size(); i++) {\n              auto attr_name = GetFlatName(arg.type_list_attr(), i);\n              (*attrs_to_add)[attr_name] = type_list[i];\n            }\n          }\n        }\n        return OkStatus();\n      };\n  absl::flat_hash_map<string, DataType> attrs_to_add;\n  TF_RETURN_IF_ERROR(FillAttrsToAdd(opdef.input_arg(), &attrs_to_add));\n  TF_RETURN_IF_ERROR(FillAttrsToAdd(opdef.output_arg(), &attrs_to_add));\n  for (auto& name_type : attrs_to_add) {\n    TF_RETURN_IF_ERROR(\n        wrapped_op->SetAttrType(name_type.first.data(), name_type.second));\n  }\n  // TODO(srbs): Rename all original attributes using EscapeOrigName.\n  return OkStatus();\n}\n\n// Maps the op's outputs to the function outputs. Mainly useful for variadic\n// outputs which need to be flattened.\nStatus PopulateRetMap(FunctionDef* fdef, const AbstractOpAttrs* op_attrs,\n                      const EagerOperation* op, const OpDef& opdef,\n                      const OpDef& signature, const string& node_name) {\n  int next_sig_output = 0;\n  for (size_t i = 0; i < opdef.output_arg_size(); i++) {\n    const auto& output_arg = opdef.output_arg(i);\n    if (!output_arg.type_list_attr().empty()) {\n      gtl::InlinedVector<DataType, 4> type_list;\n      TF_RETURN_IF_ERROR(\n          op_attrs->GetTypeList(output_arg.type_list_attr(), &type_list));\n      for (int j = 0; j < type_list.size(); j++) {\n        (*fdef->mutable_ret())[signature.output_arg(next_sig_output++).name()] =\n            absl::StrCat(node_name, \":\", output_arg.name(), \":\", j);\n      }\n    } else if (!output_arg.number_attr().empty()) {\n      int64_t number_attr;\n      if (!op_attrs->GetInt(output_arg.number_attr(), &number_attr)) {\n        return errors::Internal(\"Unable to read attr \",\n                                output_arg.number_attr(), \" for op \",\n                                op->Name());\n      }\n      for (int j = 0; j < number_attr; j++) {\n        (*fdef->mutable_ret())[signature.output_arg(next_sig_output++).name()] =\n            absl::StrCat(node_name, \":\", output_arg.name(), \":\", j);\n      }\n    } else {\n      (*fdef->mutable_ret())[signature.output_arg(next_sig_output++).name()] =\n          absl::StrCat(node_name, \":\", output_arg.name(), \":0\");\n    }\n  }\n  return OkStatus();\n}\n\n#ifdef INTEL_MKL\ninline void GetMKLNodeDef(NodeDef* ndef) {\n  // All MKL eager ops have `_kernel` private attribute that needs to be set\n  // to a fixed label.\n  AttrValue attr_kernel;\n  attr_kernel.set_s(mkl_op_registry::kMklNameChangeOpLabel);\n  (*ndef->mutable_attr()).insert({\"_kernel\", attr_kernel});\n}\n#endif  // INTEL_MKL\n\nStatus WrapInCallOp(EagerOperation* op, EagerOperation** wrapped_op) {\n  DCHECK(!op->is_function());\n  const OpDef& opdef = OpRegistry::Global()->LookUp(op->Name())->op_def;\n  // Raise an error for ops which don't support wrapping yet. This includes\n  // ops with list inputs/outputs and ops with private attrs.\n  // TODO(srbs): Support list inputs/outputs.\n  TF_RETURN_IF_ERROR(VerifyWrappableInCallOp(opdef, op));\n\n  // Build a FunctionDef containing op as a node and register with context.\n  // TODO(srbs): Here we are unable to distinguish between a FunctionDef for\n  // a wrapped eager op and an existing user defined function registered with\n  // the context e.g. with something like\n  // @tf.function\n  // def __wrapped__Add(x, y):\n  //   ...\n  // This can be avoided by introducing a dict in EagerContext that stores a\n  // mapping from the eager op's name to its unique FunctionDef name.\n  auto op_attrs = op->GetOpAttrs();\n  string fname;\n  TF_RETURN_IF_ERROR(BuildWrappedOpName(op, opdef, op_attrs, &fname));\n  if (!op->EagerContext().GetFunctionDef(fname)) {\n    FunctionDef fdef;\n    // Set signature.\n    TF_RETURN_IF_ERROR(\n        BuildWrappedOpSignature(op, opdef, fname, *fdef.mutable_signature()));\n    // Add node.\n    NodeDef* ndef = fdef.add_node_def();\n    ndef->set_op(op->Name());\n    ndef->set_name(op->Name());  // This could be anything.\n    const auto& signature = fdef.signature();\n    for (size_t i = 0; i < signature.input_arg_size(); i++) {\n      ndef->add_input(absl::StrCat(fdef.signature().input_arg(i).name(), \":0\"));\n    }\n    // TODO(srbs): Private attrs on the op are dropped here and applied to\n    // the call op instead. If this causes problems we might have to copy those\n    // attrs to this ndef. That would require updating fname to contain a hash\n    // of such attributes.\n    for (const auto& attr : opdef.attr()) {\n      (*ndef->mutable_attr())[attr.name()].set_placeholder(attr.name());\n    }\n    // Set the device of this node to be the exact same one that eager mode\n    // would have used.\n    // TODO(b/200153278): Ideally we would just forward the call op's device at\n    // runtime but currently there is no way to do it.\n    ndef->set_device(op->DeviceName());\n\n#ifdef INTEL_MKL\n    if (IsMKLEnabled() &&\n        absl::StartsWith(op->Name(), mkl_op_registry::kMklOpPrefix)) {\n      GetMKLNodeDef(ndef);\n    }\n#endif  // INTEL_MKL\n\n    // Set `ret` map.\n    TF_RETURN_IF_ERROR(\n        PopulateRetMap(&fdef, op_attrs, op, opdef, signature, ndef->name()));\n    VLOG(1) << fdef.DebugString();\n    TF_RETURN_IF_ERROR(op->EagerContext().AddFunctionDef(std::move(fdef)));\n  }\n  // Build the call op.\n  auto& ctx = op->EagerContext();\n  AbstractOperationPtr call_op(ctx.CreateOperation());\n  TF_RETURN_IF_ERROR(call_op->Reset(fname.c_str(), op->DeviceName().c_str()));\n  for (auto t : op->Inputs()) {\n    TF_RETURN_IF_ERROR(call_op->AddInput(t));\n  }\n  *wrapped_op = down_cast<EagerOperation*>(call_op.release());\n  // Attributes on the elementary eager operation are applied to the call op and\n  // to the NodeDef inside the FunctionDef. This allows us to have a single\n  // FunctionDef for different attribute values. When the function is\n  // instantiated, these attributes get forwarded to the NodeDef. This is done\n  // by setting the AttrValue.placeholder field for the NodeDef attrs.\n  (*wrapped_op)->AddAttrs(op_attrs);\n  return AddMixedTypeListAttrs(*wrapped_op, op_attrs, opdef);\n}\n\n// Necessary condition to place int args/retvals on device but not sufficient.\n// For eager operations return values can be placed on the device for use\n// by subsequent eager ops. E.g.\n// with tf.device(\"/GPU:0\"):\n//   x = tf.random_uniform(shape=(2, 2), maxval=5, dtype=tf.int32)\n//   y = tf.random_uniform(shape=(2, 2), maxval=5, dtype=tf.int32)\n//   z = tf.bitwise.bitwise_and(x, y)\n// In the above example `z` can use the outputs of `x` and `y` without needing\n// an H2D copy if x and y are left on-device.\nbool IntArgsAndRetvalsOnDevice(EagerOperation* op,\n                               const KernelDef* kernel_def) {\n  // We choose to leave `EagerConsts`\n  // on HOST to avoid `shape` and other arguments that are traditionally pinned\n  // to HostMemory from being placed on-device and then being copied to host via\n  // an expensive D2H transfer.\n  if (op->Name() == \"_EagerConst\") return false;\n\n  // Check if any of the Op's output_arg(s) are pinned to Host.\n  if (kernel_def == nullptr) return false;\n  const OpDef& op_def = OpRegistry::Global()->LookUp(op->Name())->op_def;\n  for (const string& host_memory_arg : kernel_def->host_memory_arg()) {\n    for (const auto& output_arg : op_def.output_arg()) {\n      if (output_arg.name() == host_memory_arg) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nStatusOr<Fprint128> GetKernelCacheKey(\n    const EagerOperation& op, const Fprint128& op_cache_key,\n    const std::vector<Device*>& input_device_ptrs,\n    const std::unordered_map<int, DtypeAndPartialTensorShape>&\n        input_resource_variable_dtypes_and_shapes) {\n  EagerContext& ctx = op.EagerContext();\n\n  Fprint128 cache_key = op_cache_key;\n  /// Include soft placement policy in cache key since the placement strategy\n  // can change and thus affect which kernel is picked.\n  cache_key = FingerprintCat128(cache_key, ctx.AllowSoftPlacement());\n\n  // Include run_eager_op_as_function policy in cache key since the execution\n  // strategy can change and affect which kernel is picked.\n  VLOG(3) << \"ctx.RunEagerOpAsFunction(): \" << ctx.RunEagerOpAsFunction();\n  cache_key = FingerprintCat128(cache_key, ctx.RunEagerOpAsFunction());\n\n  // When running in eager_op_as_function mode Send/Recv ops need to be\n  // placed on the same rendezvous to match the behaviour of eager mode.\n  bool reuse_rendezvous_for_functions =\n      (ctx.RunEagerOpAsFunction() && !op.is_function()) ||\n      ctx.GetReuseRendezvousForFunctions();\n  // The launch-time rendezvous reuse setting is bundled with the kernel, so we\n  // need to include it in the cache key.\n  cache_key = FingerprintCat128(cache_key, reuse_rendezvous_for_functions);\n\n  for (int i = 0, end = input_device_ptrs.size(); i < end; ++i) {\n    cache_key = FingerprintCat128(cache_key,\n                                  Fingerprint128(input_device_ptrs[i]->name()));\n\n    auto input_resource = input_resource_variable_dtypes_and_shapes.find(i);\n    if (input_resource != input_resource_variable_dtypes_and_shapes.end()) {\n      // const DtypeAndPartialTensorShape& dtype_and_shape\n      const DtypeAndPartialTensorShape& dtype_and_shape =\n          input_resource->second;\n      // Add _Arg index, dtype and shape to \"cache_key\".\n      cache_key = FingerprintCat128(cache_key, i);\n      cache_key = FingerprintCat128(cache_key, dtype_and_shape.dtype);\n      AppendTensorShapeToFingerprint(dtype_and_shape.shape, &cache_key);\n    }\n  }\n\n  return cache_key;\n}\n\n// Extracts function input info for `op` with `kernel_def`.\n// The following are extracted:\n//   `input_device_ptrs` - The input devices of `op`.\n//   `composite_devices` - Maps from a CompositeDevice name to a list of\n//     physical device names.\n//   `input_resource_variable_dtypes_shape` - A map from input index\n//     to dtype and shapes for resource inputs.\nStatus ExtractFunctionInputInfo(\n    EagerOperation* op, const KernelDef* kernel_def,\n    std::vector<Device*>& input_device_ptrs,\n    absl::flat_hash_map<string, const std::vector<string>*>& composite_devices,\n    std::unordered_map<int, DtypeAndPartialTensorShape>&\n        input_resource_variable_dtypes_and_shapes) {\n  profiler::TraceMe activity(\"EagerCopyToDevice\",\n                             profiler::TraceMeLevel::kInfo);\n  EagerContext& ctx = op->EagerContext();\n  input_device_ptrs.reserve(op->Inputs().size());\n  const absl::InlinedVector<TensorHandle*, 4>* inputs;\n  TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));\n  Device* op_device = nullptr;\n  const NodeDef* node_def = nullptr;\n  if (!op->is_function()) {\n    op_device = absl::get<Device*>(op->Device());\n    node_def = &op->MutableAttrs()->BuildNodeDef();\n  }\n  for (int i = 0, end = inputs->size(); i < end; ++i) {\n    TensorHandle* input = (*inputs)[i];\n\n    Device* input_device;\n    bool is_host_memory_arg =\n        IsHostMemoryArg(*op, node_def, op_device, kernel_def, i);\n    TF_RETURN_IF_ERROR(\n        GetDeviceForInput(*op, ctx, is_host_memory_arg, input, &input_device));\n    VLOG(1) << op->Name() << \":input:\" << i << \" \" << input_device->name();\n    input_device_ptrs.push_back(input_device);\n    CompositeDevice* composite_device = nullptr;\n    if (ctx.FindCompositeDeviceFromName(input_device->name(), &composite_device)\n            .ok()) {\n      composite_devices[input_device->name()] =\n          composite_device->underlying_devices();\n    }\n    if (input->dtype == DT_RESOURCE) {\n      // We only care about data type and shape for resource variable inputs.\n      // But we have no way to tell if input is resource variable (other than\n      // looking it up in ResourceMgr, which is slow). So we just get\n      // resource_dtypes_and_shapes for all DT_RESOURCE inputs. If\n      // resource_dtypes_and_shapes is not empty, take the first element.\n      std::vector<DtypeAndPartialTensorShape> resource_dtypes_and_shapes;\n      TF_RETURN_IF_ERROR(\n          input->GetResourceHandleDtypesAndShapes(&resource_dtypes_and_shapes));\n      if (!resource_dtypes_and_shapes.empty()) {\n        const DtypeAndPartialTensorShape& dtype_and_shape =\n            resource_dtypes_and_shapes.at(0);\n        input_resource_variable_dtypes_and_shapes[i] = dtype_and_shape;\n      }\n    }\n  }\n  return OkStatus();\n}\n\nStatus SetOpDevice(EagerContext& ctx, EagerOperation* op, Device** device) {\n  // Here in local execute, set preferred device to be on the local task to\n  // avoid placing op on a remote device with higher priority.\n  const DeviceNameUtils::ParsedName& preferred_device =\n      DeviceNameUtils::HasSomeDetails(op->GetDeviceParsedName())\n          ? op->GetDeviceParsedName()\n          : DeviceNameUtils::AddressSpace(ctx.HostCPUParsedName());\n  // Note: We use the unwrapped op for inferring the device.\n  // Without this, when wrapping CPU-only ops like RangeDataset we would\n  // place the wrapped op on a GPU (if one is available) which leads to\n  // errors because placer pins the function output nodes to GPU thereby\n  // forcing a H2D copy of the dataset variant which is not supported.\n  auto ndef = op->MutableAttrs()->BuildNodeDef();\n#ifdef INTEL_MKL\n  if (IsMKLEnabled() &&\n      absl::StartsWith(op->Name(), mkl_op_registry::kMklOpPrefix)) {\n    GetMKLNodeDef(&ndef);\n  }\n#endif  // INTEL_MKL\n\n  TF_RETURN_IF_ERROR(ctx.SelectDevice(preferred_device, ndef, device));\n\n  VLOG(1) << \"PreferredDevice \" << op->Name() << \": \" << preferred_device;\n  VLOG(1) << \"Placer place op [\" << op->Name()\n          << \"] on device: \" << (*device)->name();\n  VLOG(4) << \"Available kernels for \" << op->Name() << \" are\"\n          << KernelsRegisteredForOp(op->Name());\n  op->SetDevice(*device);\n  return OkStatus();\n}\n\nFprint128 GetDeviceCacheKey(EagerOperation* op, const EagerContext& ctx) {\n  Fprint128 device_cache_key = op->MutableAttrs()->CacheKey(op->DeviceName());\n  device_cache_key =\n      FingerprintCat128(device_cache_key, ctx.AllowSoftPlacement());\n  return device_cache_key;\n}\n\nStatus GetOrCreateKernelAndDevice(\n    EagerOperation* op, TensorHandle** retvals, int* num_retvals,\n    core::RefCountPtr<KernelAndDevice>* out_kernel) {\n  EagerContext& ctx = op->EagerContext();\n  Device* device = absl::get<Device*>(op->Device());\n\n  // Set the EagerOperation's device prior to extracting the input_device_ptrs\n  // to avoid any redundant H2D/D2H copies.\n  if (device == nullptr && !op->is_function()) {\n    Fprint128 device_cache_key = GetDeviceCacheKey(op, ctx);\n    device = ctx.GetCachedDevice(device_cache_key);\n    if (device == nullptr) {\n      TF_RETURN_IF_ERROR(SetOpDevice(ctx, op, &device));\n      ctx.AddDeviceToCache(device_cache_key, device);\n    } else {\n      op->SetDevice(device);\n    }\n  }\n\n  // Save the original value of reuse_rendezvous_for_functions from the context.\n  bool reuse_rendezvous_for_functions_original_value =\n      ctx.GetReuseRendezvousForFunctions();\n  // When running in eager_op_as_function mode Send/Recv ops need to be\n  // placed on the same rendezvous to match the behaviour of eager mode.\n  bool reuse_rendezvous_for_functions =\n      (ctx.RunEagerOpAsFunction() && !op->is_function()) ||\n      reuse_rendezvous_for_functions_original_value;\n\n  std::vector<Device*> input_device_ptrs;\n  absl::flat_hash_map<string, const std::vector<string>*> composite_devices;\n  std::unordered_map<int, DtypeAndPartialTensorShape>\n      input_resource_variable_dtypes_and_shapes;\n  const KernelDef* kernel_def = nullptr;\n  if (!op->is_function()) {\n    const NodeDef* node_def = &op->MutableAttrs()->BuildNodeDef();\n    kernel_def = GetKernelDef(*op, node_def, device);\n  }\n  if (op->is_function() || ctx.RunEagerOpAsFunction()) {\n    TF_RETURN_IF_ERROR(ExtractFunctionInputInfo(\n        op, kernel_def, input_device_ptrs, composite_devices,\n        input_resource_variable_dtypes_and_shapes));\n  }\n\n  TF_ASSIGN_OR_RETURN(\n      Fprint128 cache_key,\n      GetKernelCacheKey(*op, op->MutableAttrs()->CacheKey(op->DeviceName()),\n                        input_device_ptrs,\n                        input_resource_variable_dtypes_and_shapes));\n  core::RefCountPtr<KernelAndDevice> kernel = ctx.GetCachedKernel(cache_key);\n  AbstractOperationPtr wrapped_op_releaser;\n  // We can eliminate some overhead by running simple functions using regular\n  // CallOp kernel. However, it is tricky to figure out which functions should\n  // be run using CallOp. Also, currently CallOp runs neither optimization\n  // passes (needed for TPU/XLA) nor grappler.\n  // Here are some cases where a function should be run in multi-device mode:\n  //  - Function takes at least two resources on different devices.\n  //  - Function takes a resource on deviceA and a body op explicitly placed\n  //  on deviceB.\n  //  - Function has a colocation constraint.\n  //  - Function has an explicit device annotation (which might not be using\n  //    full canonical device name) different from op_device. Note that false\n  //    positives are ok.\n  //  - Function has a node or a (node) attribute that can potentially make\n  //    the function multi-device after a rewrite pass (e.g. various XLA/TPU\n  //    special nodes and attributes)\n  if (kernel == nullptr) {\n    VLOG(2) << \"Creating new kernel for \" << op->Name() << \" on device \"\n            << DeviceNameOrUnspecified(absl::get<Device*>(op->Device()));\n    bool run_function_with_flr = false;\n    bool function_outputs_on_op_device = false;\n    absl::optional<string> xla_compile_device_type;\n    if (op->is_function()) {\n      bool compile_with_xla;\n      TF_RETURN_IF_ERROR(MustCompileWithXLA(op, ctx, &compile_with_xla));\n      if (compile_with_xla) {\n        if (ctx.JitCompileRewrite()) {\n          xla_compile_device_type = op->GetDeviceParsedName().type;\n          run_function_with_flr = true;\n        } else {\n          // Note that it is not ideal, but currently correct, to set this\n          // attribute after computing the kernel cache key above.\n          // Note: If the attribute is already set to true, this is a noop.\n          op->MutableAttrs()->Set(kXlaMustCompileAttr, true);\n        }\n      } else {\n        run_function_with_flr = true;\n      }\n      GetFuncAttr(op, ctx, kOutputsOnOpDevice, &function_outputs_on_op_device)\n          .IgnoreError();\n    }\n\n    VLOG(2) << op->Name() << \" function_outputs_on_op_device: \"\n            << function_outputs_on_op_device;\n    if (device == nullptr) {\n      TF_RETURN_IF_ERROR(SetOpDevice(ctx, op, &device));\n    } else {\n      VLOG(1) << \"Device for [\" << op->Name()\n              << \"] already set to: \" << device->name();\n    }\n\n    // Note: We wrap the eager op AFTER the device has been inferred to ensure\n    // that placement of the NodeDef in the function is exactly the same as in\n    // eager mode. This is specially important for cases where the\n    // preferred device is not the actual device on which the op is run.\n    // E.g. the preferred device for a `RangeDataset` op could be set to `GPU`\n    // but `ctx->SelectDevice` would still place it on CPU. Placer on the other\n    // hand would throw an error.\n    //\n    // Note: The wrapped function is never jit compiled but rather run via the\n    // FLR. This is needed because certain ops e.g. `VarHandleOp` can not be\n    // jit compiled. Ideally we would run this via the jit compiled path and\n    // expect unsupported ops to be outside compiled but that is not supported\n    // on GPUs right now.\n    bool allow_small_function_optimizations = false;\n    bool int_args_and_retvals_on_device = false;\n    bool allow_control_flow_sync_execution = false;\n    // TODO(b/176491312): Remove this if shape inference on import flag is\n    // removed.\n    bool shape_inference_on_tfe_dialect_import = true;\n    if (ctx.RunEagerOpAsFunction() && !op->is_function()) {\n      EagerOperation* wrapped_op = nullptr;\n      TF_RETURN_IF_ERROR(ValidateOp(op));\n      TF_RETURN_IF_ERROR(WrapInCallOp(op, &wrapped_op));\n      DCHECK(wrapped_op);\n      DCHECK(wrapped_op->is_function());\n      wrapped_op_releaser.reset(wrapped_op);\n      run_function_with_flr = true;\n      allow_small_function_optimizations = true;\n      allow_control_flow_sync_execution = true;\n      shape_inference_on_tfe_dialect_import = false;\n      int_args_and_retvals_on_device =\n          IntArgsAndRetvalsOnDevice(op, kernel_def);\n      op = wrapped_op;\n      if (int_args_and_retvals_on_device) {\n        op->MutableAttrs()->Set(FunctionLibraryDefinition::kIntsOnDeviceAttr,\n                                true);\n      }\n    }\n    const NodeDef& ndef = op->MutableAttrs()->BuildNodeDef();\n\n    FunctionLibraryRuntime* flr =\n        device == nullptr ? nullptr : ctx.func_lib(device);\n    if (device != nullptr && flr == nullptr) {\n      return errors::NotFound(\n          \"Unable to find a FunctionLibraryRuntime corresponding to device \",\n          device->name());\n    }\n    auto runner = (flr != nullptr && flr->runner() != nullptr) ? flr->runner()\n                                                               : ctx.runner();\n    GraphCollector* graph_collector = nullptr;\n    if (ctx.ShouldStoreGraphs()) {\n      graph_collector = ctx.GetGraphCollector();\n    }\n    // Treat the function as multi_device only when we are not compiling\n    // it wholly with XLA. When compiling wholly with XLA, flr->CreateKernel\n    // will create an XlaLaunchOp kernel to compile and run the function.\n    if (run_function_with_flr) {\n      // Multi-device functions don't use the rendezvous from eager context.\n      // If we use that rendezvous, multiple concurrent calls to the same\n      // function will likely result in collisions. However, this also means\n      // that we don't support legitimate sending/receiving across function\n      // boundary.\n      VLOG(2) << \"Running \" << ndef.op() << \" using multi-device function. \"\n              << \"Full node_def=\" << ndef.DebugString();\n      std::function<int64_t()> get_op_id = nullptr;\n#if !defined(IS_MOBILE_PLATFORM)\n      get_op_id = [&ctx]() { return ctx.RemoteMgr()->NextOpId(); };\n#endif  // IS_MOBILE_PLATFORM\n\n      ctx.reuse_rendezvous_for_functions_mu()->lock();\n      ctx.SetReuseRendezvousForFunctions(reuse_rendezvous_for_functions);\n      auto rendezvous_creator = ctx.RendezvousCreator();\n      ctx.SetReuseRendezvousForFunctions(\n          reuse_rendezvous_for_functions_original_value);\n      ctx.reuse_rendezvous_for_functions_mu()->unlock();\n      kernel.reset(new KernelAndDeviceFunc(\n          flr, ctx.pflr(), std::move(input_device_ptrs),\n          std::move(composite_devices),\n          std::move(input_resource_variable_dtypes_and_shapes), runner,\n          ctx.GetCollectiveExecutorHandle(), ctx.HostCPU(), op->Name(),\n          function_outputs_on_op_device, allow_small_function_optimizations,\n          allow_control_flow_sync_execution,\n          shape_inference_on_tfe_dialect_import, int_args_and_retvals_on_device,\n          xla_compile_device_type, std::move(rendezvous_creator), get_op_id));\n    } else {\n      VLOG(2) << \"Running \" << ndef.op() << \" using op kernel. \"\n              << \". Full node_def=\" << ndef.DebugString();\n      kernel.reset(new KernelAndDeviceOp(\n          ctx.GetRendezvous(), ctx.LogMemory(), flr, runner,\n          ctx.GetCollectiveExecutorHandle(), ctx.HostCPU()));\n    }\n\n    TF_RETURN_IF_ERROR(\n        kernel->Init(ctx.LogDevicePlacement(), ndef, graph_collector));\n\n    if (op->is_function()) {\n      ctx.AddKernelToCache(cache_key, kernel.get());\n    } else {\n      // Exclude tf.data op kernels from being cached. The reason for this is\n      // that tf.data op kernels that accept a user-defined function will have a\n      // unique cache key every time they are executed (because the user-defined\n      // function is traced every time). Caching such kernels provides no\n      // benefit and in some cases results in linear memory growth of use\n      // programs that build input pipeline graphs in a loop.\n      const OpDef* op_def;\n      TF_RETURN_IF_ERROR(OpDefForOp(op->Name().data(), &op_def));\n      if (KernelCacheEnabled(*op_def)) {\n        ctx.AddKernelToCache(cache_key, kernel.get());\n      }\n    }\n  }\n\n  int num_outputs = kernel->num_outputs();\n  if (num_outputs > *num_retvals) {\n    return errors::InvalidArgument(\"Expecting \", num_outputs,\n                                   \" outputs, but *num_retvals is \",\n                                   *num_retvals);\n  }\n  *num_retvals = num_outputs;\n\n  kernel->Ref();  // Ownership of reference is passed to out_kernel.\n  out_kernel->reset(kernel.get());\n  return OkStatus();\n}\n\nStatus CreateUnshapedOutput(\n    const KernelAndDevice& kernel, const int output_num, Device* output_device,\n    const DataType& output_dtype,\n    const absl::optional<EagerFunctionParams>& eager_func_params,\n    EagerContext* ctx, TensorHandle** output) {\n#if defined(IS_MOBILE_PLATFORM)\n  return errors::Unimplemented(\n      \"Remote outputs are not available on mobile devices.\");\n#else  // !IS_MOBILE_PLATFORM\n  int64_t op_id;\n  if (eager_func_params.has_value()) {\n    op_id = eager_func_params.value().op_id;\n  } else {\n    return errors::InvalidArgument(\n        \"Unable to find a remote op id for a remote output of \", kernel.name());\n  }\n  string remote_task;\n  if (!DeviceNameUtils::GetTaskName(output_device->parsed_name(),\n                                    &remote_task)) {\n    return errors::InvalidArgument(\n        \"Unable to find remote task corresponding to device \",\n        output_device->name());\n  }\n  if (ctx->RemoteMgr()->IsMaster()) {\n    *output = TensorHandle::CreateUnshapedRemoteHandle(\n        op_id, output_num, remote_task, output_dtype, output_device, ctx);\n  } else {\n    *output = TensorHandle::CreateLazyRemoteHandle(op_id, output_num,\n                                                   output_dtype, output_device,\n                                                   /*is_ready=*/false, ctx);\n  }\n  return OkStatus();\n#endif  // !IS_MOBILE_PLATFORM\n}\n\nStatus AddOrExecuteNode(core::RefCountPtr<KernelAndDevice> kernel,\n                        EagerOperation* op, TensorHandle** retvals) {\n  EagerExecutor& executor = op->Executor();\n  EagerContext& ctx = op->EagerContext();\n  GraphCollector* graph_collector = nullptr;\n  if (ctx.ShouldStoreGraphs()) {\n    graph_collector = ctx.GetGraphCollector();\n  }\n  const int num_outputs = kernel->num_outputs();\n  absl::optional<EagerFunctionParams> eager_func_params =\n      op->eager_func_params();\n  if (kernel->IsCrossProcess() && !eager_func_params.has_value()) {\n    // Create an eager op id for a cross-process function if not exist.\n#if defined(IS_MOBILE_PLATFORM)\n    return errors::Unimplemented(\n        \"Cross-process functions are not supported on mobile devices.\");\n#else  // !IS_MOBILE_PLATFORM\n    const int64_t op_id = ctx.RemoteMgr()->NextOpId();\n    eager_func_params = EagerFunctionParams{\n        op_id, /* is_component_function= */ false, /* step_id= */ std::nullopt};\n#endif  // !IS_MOBILE_PLATFORM\n  }\n  if (executor.Async()) {\n    const DataTypeVector& output_dtypes = kernel->output_dtypes();\n    for (int i = 0, end = num_outputs; i < end; ++i) {\n      Device* output_device = ctx.CanonicalDevice(kernel->OutputDevice(i));\n      if (output_device == nullptr || output_device->IsLocal()) {\n        retvals[i] = TensorHandle::CreateEmptyLocalHandle(\n            /* d= */ output_device, /* op_device= */ kernel->device(),\n            /* resource_device= */ kernel->OutputResourceDevice(i),\n            output_dtypes[i], &ctx);\n      } else {\n        TF_RETURN_IF_ERROR(\n            CreateUnshapedOutput(*kernel, i, output_device, output_dtypes[i],\n                                 eager_func_params, &ctx, &retvals[i]));\n      }\n    }\n    const absl::InlinedVector<TensorHandle*, 4>* inputs;\n    TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));\n    auto node = std::make_unique<AsyncExecuteNode>(\n        &ctx, *inputs, eager_func_params, std::move(kernel), graph_collector,\n        op->GetCancellationManager(),\n        absl::Span<TensorHandle*>(retvals, num_outputs), op->GetStackTrace());\n    // Release the inputs from the eager operation since the AsyncExecuteNode\n    // would have taken ownership. This allows the inputs to be forwarded if\n    // possible.\n    op->Clear();\n    // For async mode, execution order will make sure that all\n    // input handles are ready before executing them.\n    // TODO(b/137118203): Consider executing \"cheap\" kernels inline for\n    // performance.\n    return executor.AddOrExecute(std::move(node));\n  } else {\n    for (int i = 0, end = num_outputs; i < end; ++i) {\n      retvals[i] = nullptr;\n    }\n    const absl::InlinedVector<TensorHandle*, 4>* inputs;\n    TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));\n    ExecuteNode node(&ctx, *inputs, eager_func_params, kernel, graph_collector,\n                     op->GetCancellationManager(),\n                     {retvals, static_cast<size_t>(num_outputs)},\n                     op->GetStackTrace());\n    Status s = executor.SyncExecute(&node);\n    // We release the inputs AFTER executing the operation in sync mode since\n    // ExecuteNode does not increment the reference count and thus does not have\n    // ownership of the inputs while executing.\n    op->Clear();\n    return s;\n  }\n}\n\n// There are a lot of references to devices in this function and around.\n// Here is what they mean:\n//  EagerOperation::Device(): The device on which the user requested the op\n//    be executed, except if we had to change the device due to resource inputs\n//    or CPU pinning. If the user did not request a device, the op does not\n//    take resources, and we did not pin it to CPU, the device can be nullptr.\n//  KernelAndDevice::Device(): The first time we see an op (combined with\n//    its attributes), we need to create a KernelAndDevice object for it.\n//    If op->Device() is a nullptr, we select a device for the op when\n//    creating the KernelAndDevice. A concrete device will always be selected\n//    here except when `op` is a function to be executed using function library\n//    runtime. In this case, we don't select a device because running\n//    a function with explicitly requested device has different behavior than\n//    running without an explicitly requested device.\nStatus EagerLocalExecute(EagerOperation* op, TensorHandle** retvals,\n                         int* num_retvals) {\n  profiler::ScopedMemoryDebugAnnotation op_annotation(\n      op->op_name(), op->eager_func_params().has_value()\n                         ? op->eager_func_params().value().step_id.value_or(0)\n                         : 0);\n  profiler::TraceMe activity(\n      [&] { return absl::StrCat(\"EagerLocalExecute: \", op->Name()); },\n      profiler::TraceMeLevel::kInfo);\n  EagerContext& ctx = op->EagerContext();\n  auto& executor = op->Executor();\n  TF_RETURN_IF_ERROR(executor.status());\n\n  core::RefCountPtr<KernelAndDevice> kernel;\n  auto status = GetOrCreateKernelAndDevice(op, retvals, num_retvals, &kernel);\n\n#ifdef INTEL_MKL\n  if (IsMKLEnabled() && kernel != nullptr &&\n      op->Device() == kVariantDeviceNull) {\n    // oneDNN optimization pass relies on the op's assigned device to determine\n    // whether it can be rewritten.\n    op->SetDevice(kernel->device());\n  }\n#endif  // INTEL_MKL\n\n  // Run all the registered rewrite pass after the placement, regardless whether\n  // the placement is successful or not. The passes can either create new ops\n  // (without placement) or update some fields of the input op.\n  std::unique_ptr<tensorflow::EagerOperation> out_op;\n  TF_RETURN_IF_ERROR(EagerOpRewriteRegistry::Global()->RunRewrite(\n      EagerOpRewriteRegistry::POST_PLACEMENT, op, &out_op));\n  if (out_op) {\n    op = out_op.get();\n    // If the out op doesn't have device, either because it is a new op or\n    // the op wasn't placed successfully, then we do the placement again.\n    if (op->Device() == kVariantDeviceNull) {\n      status = GetOrCreateKernelAndDevice(op, retvals, num_retvals, &kernel);\n    }\n  }\n  if (!status.ok()) return status;\n\n  int num_outputs = kernel->num_outputs();\n  TF_RETURN_IF_ERROR(ValidateInputTypeAndPlacement(&ctx, op, kernel));\n\n  if (ctx.LogDevicePlacement() || VLOG_IS_ON(1)) {\n    string msg = strings::StrCat(\"Executing op \", op->Name(), \" in device \",\n                                 kernel->device()->name());\n    if (!logging::LogToListeners(msg)) {\n      LOG(INFO) << msg;\n    }\n  }\n\n  Status s = AddOrExecuteNode(std::move(kernel), op, retvals);\n  // Since the operation failed, we need to Unref any outputs if they were\n  // allocated.\n  if (!s.ok()) {\n    for (int i = 0, end = num_outputs; i < end; ++i) {\n      if (retvals[i] != nullptr) {\n        retvals[i]->Unref();\n        retvals[i] = nullptr;\n      }\n    }\n  }\n\n  return s;\n}\n\n// Run a Pack op to pack the tensors pointed by a packed input TensorHandle if\n// the op is a primitive op.\nStatus MaybePackInputTensor(EagerOperation* op) {\n  if (op->is_function() || op->EagerContext().RunEagerOpAsFunction()) {\n    // Functions could take packed TensorHandles as inputs.\n    return OkStatus();\n  }\n  EagerContext& ctx = op->EagerContext();\n  const absl::InlinedVector<TensorHandle*, 4>* inputs;\n  TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));\n  for (int i = 0; i < inputs->size(); ++i) {\n    TensorHandle* handle = (*inputs)[i];\n    if (handle->Type() == TensorHandle::PACKED) {\n      EagerOperation pack_op(&ctx);\n      TF_RETURN_IF_ERROR(pack_op.Reset(\"Pack\", /*device_name=*/nullptr,\n                                       /*remote=*/false, /*executor=*/nullptr));\n      pack_op.MutableAttrs()->Set(\"N\", handle->NumPackedHandles());\n      pack_op.MutableAttrs()->Set(\"T\", handle->dtype);\n      for (int i = 0; i < handle->NumPackedHandles(); ++i) {\n        tensorflow::TensorHandle* h = nullptr;\n        TF_RETURN_IF_ERROR(handle->ExtractPackedHandle(i, &h));\n        TF_RETURN_IF_ERROR(pack_op.AddInput(h));\n      }\n      int num_retvals = 1;\n      absl::FixedArray<tensorflow::TensorHandle*> retvals(num_retvals);\n      TF_RETURN_IF_ERROR(\n          EagerLocalExecute(&pack_op, retvals.data(), &num_retvals));\n      tensorflow::TensorHandle* ret = retvals.at(0);\n      op->UpdateInput(i, ret);\n      ret->Unref();\n    }\n  }\n  return OkStatus();\n}\n\n#if !defined(IS_MOBILE_PLATFORM)\nvoid PrepareRemoteOp(eager::Operation* remote_op, EagerOperation* op) {\n  EagerContext& ctx = op->EagerContext();\n\n  remote_op->set_id(ctx.RemoteMgr()->NextOpId());\n  remote_op->set_name(op->Name());\n\n  op->Attrs().FillAttrValueMapWithoutDefaults(remote_op->mutable_attrs());\n  remote_op->set_device(absl::get<Device*>(op->Device())->name());\n  remote_op->set_is_function(op->is_function());\n}\n\nStatus StoreResourceDtypesAndShapes(const eager::Operation& remote_op,\n                                    const DataTypeVector& output_dtypes,\n                                    TensorHandle** retvals) {\n  if (remote_op.name() == \"VarHandleOp\") {\n    if (output_dtypes.size() != 1) {\n      return errors::Internal(\"VarHandleOp should only have one output.\");\n    }\n    if (output_dtypes[0] != DT_RESOURCE) {\n      return errors::Internal(\n          \"The output of VarHandleOp should be a DT_RESOURCE.\");\n    }\n    AttrSlice attr_slice = AttrSlice(&remote_op.attrs());\n    const AttrValue* dtype;\n    TF_RETURN_IF_ERROR(attr_slice.Find(\"dtype\", &dtype));\n    const AttrValue* shape;\n    TF_RETURN_IF_ERROR(attr_slice.Find(\"shape\", &shape));\n    retvals[0]->SetResourceHandleDtypeAndShape(\n        {DtypeAndPartialTensorShape{dtype->type(), shape->shape()}});\n  }\n  return OkStatus();\n}\n\nStatus EagerRemoteExecute(EagerOperation* op, TensorHandle** retvals,\n                          int* num_retvals) {\n  EagerContext& ctx = op->EagerContext();\n\n  // TODO(fishx): Remove following code when lazy tensor copy is ready.\n  if (op->Device() == kVariantDeviceNull) {\n    tensorflow::Device* device = nullptr;\n    string device_name = op->DeviceName();\n    TF_RETURN_IF_ERROR(ctx.FindDeviceFromName(device_name.c_str(), &device));\n    op->SetDevice(device);\n  }\n\n  core::RefCountPtr<eager::EagerClient> eager_client;\n  uint64 context_id = ctx.GetContextId();\n  TF_RETURN_IF_ERROR(ctx.GetClient(op->GetDeviceParsedName(), &eager_client));\n  string remote_task;\n  if (!DeviceNameUtils::GetTaskName(op->GetDeviceParsedName(), &remote_task)) {\n    return errors::InvalidArgument(\n        \"Unable to find remote task corresponding to device \",\n        op->DeviceName());\n  }\n\n  std::unique_ptr<eager::EnqueueRequest> request(new eager::EnqueueRequest);\n  request->set_context_id(context_id);\n\n  eager::Operation* remote_op = request->add_queue()->mutable_operation();\n\n  tensorflow::Device* op_device = absl::get<Device*>(op->Device());\n  {\n    profiler::TraceMe activity(\"CopyInputToExpectedDevice\",\n                               profiler::TraceMeLevel::kInfo);\n    const bool is_function = op->is_function();\n    const absl::InlinedVector<TensorHandle*, 4>* inputs;\n    TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));\n    for (int i = 0, end = inputs->size(); i < end; i++) {\n      tensorflow::TensorHandle* input = (*inputs)[i];\n      tensorflow::Device* input_device = input->device();\n      tensorflow::Device* input_device_or_cpu = input->DeviceOrHostCPU(ctx);\n      const string* input_device_name = &input_device_or_cpu->name();\n      bool serialize_resource_dtype_and_shape = false;\n      if (op_device != input_device &&\n          // If the expected and actual devices are on the same task, don't\n          // explicitly copy, and instead depend on the copy to happen locally\n          // when the op is executed on the device.\n          !ctx.OnSameTask(op_device, input_device)) {\n        if (!is_function || input_device_or_cpu->IsLocal()) {\n          tensorflow::Device* remote_cpu_device;\n          TF_RETURN_IF_ERROR(\n              ctx.CPUDeviceOnTask(op_device, &remote_cpu_device));\n          // Always copy to the remote CPU so that the actual device can be\n          // correctly determined after the kernel is selected/instantiated,\n          // since the op might have its inputs on host memory.\n          TensorHandle* handle = input;\n          Device* handle_device = handle->DeviceOrHostCPU(ctx);\n          // If the input is already on the right device, then nothing to do.\n          if (remote_cpu_device != handle_device) {\n            VLOG(6) << \"remote_cpu_device != handle_device\";\n            TF_RETURN_IF_ERROR(CopyInputToExpectedDevice(\n                &ctx, op, op_device, handle, i, handle_device,\n                remote_cpu_device, &handle));\n            op->UpdateInput(i, handle);\n            input = handle;\n            input_device = remote_cpu_device;\n            input_device_name = &remote_cpu_device->name();\n            // Unref handle since it has a ref as an input now\n            handle->Unref();\n          }\n        } else {\n          serialize_resource_dtype_and_shape =\n              (input->dtype == DT_RESOURCE) &&\n              (!input->HasResourceShapeMirror(op_device,\n                                              ctx.GetContextViewId()));\n        }\n      }\n      auto* input_handle = remote_op->add_op_inputs()->mutable_remote_handle();\n      // For a remote component function, a function execution request and an\n      // input generation request may come from different workers. We need to\n      // guarantee that the input generation request is processed before the\n      // function execution request, so wait until the remote input is ready\n      // before sending it to the multi-device function device.\n      const bool wait_until_ready = op->is_function();\n      TF_RETURN_IF_ERROR(ctx.RemoteMgr()->SerializeRemoteTensorHandle(\n          input, wait_until_ready, input_handle, input_device,\n          *input_device_name, serialize_resource_dtype_and_shape));\n      if (!input_handle->resource_dtypes_and_shapes().empty()) {\n        TF_RETURN_IF_ERROR(\n            input->AddResourceShapeMirror(op_device, input_handle->op_id(),\n                                          input_handle->output_num(), &ctx));\n      }\n    }\n  }\n\n  PrepareRemoteOp(remote_op, op);\n\n  DataTypeVector output_dtypes;\n  TF_RETURN_IF_ERROR(GetOutputDTypes(op, &output_dtypes));\n\n  const size_t num_outputs = output_dtypes.size();\n  if (num_outputs != *num_retvals) {\n    return errors::InvalidArgument(\n        \"num_retvals does not match expected output dtypes\");\n  }\n  *num_retvals = num_outputs;\n\n  const tensorflow::uint64 id = remote_op->id();\n  for (size_t i = 0; i < num_outputs; ++i) {\n    // TODO(nareshmodi): Change the callback to instead add the decref to a\n    // list of pending decrefs that we can send as a batch with the next\n    // execute.\n\n    // The device_ and resource_device_ of this TensorHandle might be\n    // incorrect. For multi-device functions, we don't know the output device\n    // until the function is instantiated on a remote worker. Luckily, we don't\n    // need to know the correct remote device here. We just need to know that it\n    // is remote. If we need copy this tensor to this process or run any ops\n    // which take this tensor as an input, block until the correct device is\n    // set.\n    const bool unknown_device = op->is_function();\n    retvals[i] = TensorHandle::CreateUnshapedRemoteHandle(\n        id, i, remote_task, output_dtypes[i], op_device, &ctx, unknown_device);\n  }\n\n  // Store the data type and shape of a remote resource variable on the\n  // corresponding remote TensorHandle (output of 'VarHandleOp').\n  // If the variable is an input of a remote function, the function may need\n  // the type and shape during function instantiation. Store the type and\n  // shape on eager master and sent them to the default function device along\n  // with the EnqueueRequest.\n  TF_RETURN_IF_ERROR(\n      StoreResourceDtypesAndShapes(*remote_op, output_dtypes, retvals));\n\n  auto& executor = op->Executor();\n  VLOG(4) << \"Execute remote eager op: \" << op->Name()\n          << \" (is async?: \" << executor.Async() << \").\";\n\n  const absl::InlinedVector<TensorHandle*, 4>* inputs;\n  TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));\n\n  std::unique_ptr<EagerNode> node(new eager::RemoteExecuteNode(\n      &op->EagerContext(), std::move(request), op_device,\n      ctx.GetContextViewId(), eager_client.get(), op->GetCancellationManager(),\n      op->MutableAttrs()->BuildNodeDef(), op->EagerContext().FuncLibDef(),\n      *inputs, {retvals, num_outputs}));\n\n  if (op->EagerContext().LogDevicePlacement() || VLOG_IS_ON(1)) {\n    string msg = strings::StrCat(\n        \"Executing op \", op->Name(), \" on task \",\n        DeviceNameUtils::ParsedNameToString(op->GetDeviceParsedName()));\n    if (!logging::LogToListeners(msg)) {\n      LOG(INFO) << msg;\n    }\n  }\n\n  Status s = executor.AddOrExecute(std::move(node));\n  // Since the operation failed, we need to Unref any outputs that were\n  // allocated.\n  if (!s.ok()) {\n    for (size_t i = 0; i < num_outputs; ++i) {\n      retvals[i]->Unref();\n      // Ensure that any smart pointers created to wrap results become noops\n      // rather than operating on invalid memory.\n      retvals[i] = nullptr;\n    }\n  }\n\n  return s;\n}\n#endif  // IS_MOBILE_PLATFORM\n\nStatus GetKernelOutputs(\n    std::vector<EagerKernelRet>* outputs, int num_outputs,\n    TensorHandle** retvals, EagerContext* ctx, KernelAndDevice* kernel,\n    const absl::optional<EagerFunctionParams>& eager_func_params) {\n  for (int i = 0, end = num_outputs; i < end; ++i) {\n    if (retvals[i] == nullptr) {\n      EagerKernelRet& ret = (*outputs)[i];\n      Device* output_device = ctx->CanonicalDevice(kernel->OutputDevice(i));\n      if (ret.index() == 0) {\n        retvals[i] = TensorHandle::CreateLocalHandle(\n            std::move(absl::get<Tensor>(ret)),\n            /* d= */ output_device,\n            /* op_device= */ kernel->device(),\n            /* resource_device= */ kernel->OutputResourceDevice(i), ctx);\n      } else {\n        const DataTypeVector& output_dtypes = kernel->output_dtypes();\n        TF_RETURN_IF_ERROR(\n            CreateUnshapedOutput(*kernel, i, output_device, output_dtypes[i],\n                                 eager_func_params, ctx, &retvals[i]));\n#if !defined(IS_MOBILE_PLATFORM)\n        TF_RETURN_IF_ERROR(\n            retvals[i]->SetRemoteShape(absl::get<TensorShape>(ret),\n                                       output_device, ctx->GetContextViewId()));\n#endif  // IS_MOBILE_PLATFORM\n      }\n    } else {\n      if (!kernel->IsFunction() &&\n          TF_PREDICT_FALSE(kernel->device() != retvals[i]->op_device())) {\n        return errors::Internal(\n            \"Kernel output tensor handle has a different op device than the \"\n            \"kernel. This should never happen.\");\n      }\n      if (TF_PREDICT_FALSE(ctx->CanonicalDevice(kernel->OutputDevice(i)) !=\n                           retvals[i]->device())) {\n        return errors::Internal(\n            \"Kernel output tensor handle locates on a different device than \"\n            \"the specified kernel output device. This should never happen.\");\n      }\n\n      EagerKernelRet& ret = (*outputs)[i];\n      if (ret.index() == 0) {\n        TF_RETURN_IF_ERROR(retvals[i]->SetTensor(\n            std::move(absl::get<Tensor>(ret)),\n            ctx->CanonicalDevice(kernel->OutputDevice(i))));\n      } else {\n#if defined(IS_MOBILE_PLATFORM)\n        return errors::Unimplemented(\n            \"Remote outputs are not available on mobile devices.\");\n#else  // !IS_MOBILE_PLATFORM\n        TF_RETURN_IF_ERROR(retvals[i]->SetRemoteShape(\n            absl::get<TensorShape>(ret), retvals[i]->device(),\n            ctx->GetContextViewId()));\n#endif  // !IS_MOBILE_PLATFORM\n      }\n    }\n  }\n  return OkStatus();\n}\n\nvoid CollectGraphs(EagerContext* ctx) {\n  mutex_lock ml(*ctx->MetadataMu());\n\n  GraphCollector* collector = ctx->GetGraphCollector();\n  mutex_lock mll(collector->mu);\n\n  // Adding to partition graphs for backward compatibility.\n  for (const auto& graph : collector->partitioned_graphs) {\n    *ctx->RunMetadataProto()->add_partition_graphs() = graph;\n  }\n\n  if (collector->dirty) {\n    auto* function_graphs = ctx->RunMetadataProto()->add_function_graphs();\n    *function_graphs->mutable_post_optimization_graph() =\n        collector->optimized_graph;\n    *function_graphs->mutable_pre_optimization_graph() = collector->raw_graph;\n    for (const auto& graph : collector->partitioned_graphs) {\n      *function_graphs->add_partition_graphs() = graph;\n    }\n  }\n\n  collector->ClearGraphs();\n}\n}  // namespace\n\nStatus EagerExecute(EagerOperation* op, TensorHandle** retvals,\n                    int* num_retvals) {\n  profiler::TraceMe activity([&] {\n    return ::tensorflow::profiler::TraceMeEncode(\n        \"EagerExecute\",\n        {{\"eager_op\", op->Name()}, {\"is_func\", op->is_function()}});\n  });\n\n  if (!op->Executor().Async()) {\n    VLOG(6) << \"op: \" << op->Name() << \" is not Async.\";\n    if (!op->EagerContext()\n             .GetGlobalRendezvousForFunctionLocalRendezvousStatus()\n             .ok()) {\n      VLOG(6) << \"global_rendezvous_for_functions_ is in bad state. Resetting.\";\n      op->EagerContext().ResetGlobalRendezvousForFunction();\n    }\n    // In sync mode, always clear error to maintain the same behavior as before.\n    // TODO(b/141004939): Remove this.\n    op->Executor().ClearError();\n  }\n\n  std::unique_ptr<tensorflow::EagerOperation> out_op;\n  TF_RETURN_IF_ERROR(EagerOpRewriteRegistry::Global()->RunRewrite(\n      EagerOpRewriteRegistry::PRE_EXECUTION, op, &out_op));\n\n  if (op->IsLocal()) {\n    if (out_op) {\n      op = out_op.get();\n    }\n    TF_RETURN_IF_ERROR(MaybePackInputTensor(op));\n    return EagerLocalExecute(op, retvals, num_retvals);\n  }\n\n#if defined(IS_MOBILE_PLATFORM)\n  return errors::Unimplemented(\n      \"Eager's remote execution is not available on mobile devices.\");\n#else   // !IS_MOBILE_PLATFORM\n  if (out_op) {\n    op = out_op.get();\n  }\n  return EagerRemoteExecute(op, retvals, num_retvals);\n#endif  // !IS_MOBILE_PLATFORM\n}\n\n// TODO(gjn): Consider moving into ExecuteNode class\nStatus EagerKernelExecute(\n    EagerContext* ctx, const absl::InlinedVector<TensorHandle*, 4>& op_inputs,\n    const absl::optional<EagerFunctionParams>& eager_func_params,\n    const core::RefCountPtr<KernelAndDevice>& kernel,\n    GraphCollector* graph_collector, CancellationManager* cancellation_manager,\n    absl::Span<TensorHandle*> retvals,\n    const absl::optional<ManagedStackTrace>& stack_trace) {\n  profiler::TraceMe activity(\"EagerKernelExecute\",\n                             profiler::TraceMeLevel::kInfo);\n  std::vector<EagerKernelRet> outputs(1);\n\n  ExecuteNodeArgs inputs(op_inputs.size());\n  TF_RETURN_IF_ERROR(inputs.Init(ctx, op_inputs, kernel));\n  // TODO(apassos) figure out how to record stats for ops which are a part of\n  // functions.\n  // TODO(b/111859745): When we support recovering from kernel/device errors, we\n  // would need to call XlaDevice::EnsureDeviceContextOk() before using an XLA\n  // device. We don't call it now because it is an unneeded overhead (it\n  // acquires a lock) and we can't recover from errors anyway.\n  ScopedStepContainer* container = ctx->StepContainer();\n  CoordinationServiceAgent* coord_agent = nullptr;\n#if !defined(IS_MOBILE_PLATFORM)\n  if (ctx->GetDistributedManager() != nullptr)\n    coord_agent = ctx->GetDistributedManager()->GetCoordinationServiceAgent();\n#endif  // !IS_MOBILE_PLATFORM\n  TF_RETURN_IF_ERROR(kernel->Run(container, inputs, &outputs,\n                                 cancellation_manager, eager_func_params,\n                                 stack_trace, coord_agent));\n  if (graph_collector != nullptr) {\n    CollectGraphs(ctx);\n  }\n\n  if (TF_PREDICT_FALSE(retvals.size() != outputs.size())) {\n    return errors::Internal(\n        \"EagerKernelExecute returns a list of \", outputs.size(),\n        \" tensors but \", retvals.size(),\n        \" is expected. This should never \"\n        \"happen. Please file a bug with the TensorFlow team.\");\n  }\n  return GetKernelOutputs(&outputs, retvals.size(), retvals.data(), ctx,\n                          kernel.get(), eager_func_params);\n}\n\nnamespace {\n\nStatus LocalEagerCopyToDevice(TensorHandle* h, EagerContext* ctx,\n                              EagerExecutor* executor, Device* dstd,\n                              bool mirror, TensorHandle** result) {\n  TF_RETURN_IF_ERROR(executor->status());\n  Device* d = ctx->CanonicalDevice(dstd);\n  if (mirror && h->HasLocalMirror(d)) {\n    h->Ref();\n    *result = h;\n    return OkStatus();\n  }\n\n  bool async = executor->Async();\n  if (mirror) {\n    h->Ref();\n    *result = h;\n\n    if (h->HasLocalMirror(d)) {\n      return OkStatus();\n    }\n\n    // We don't bother adding an empty local mirror in sync mode since we'll be\n    // executing the operation directly and be calling AddLocalMirror. A\n    // reference count is still needed which will be removed if the operation\n    // fails.\n    if (async) {\n      Status s = h->AddEmptyLocalMirror(d);\n      if (!s.ok()) {\n        // If a mirror was added since we called HasLocalMirror then just return\n        // since another thread has already added the mirror.\n        if (s.code() == error::Code::ALREADY_EXISTS) {\n          return OkStatus();\n        }\n\n        // Remove the previously added reference count since adding the mirror\n        // failed.\n        h->Unref();\n        *result = nullptr;\n        return s;\n      }\n    }\n  } else {\n    *result = TensorHandle::CreateEmptyLocalHandle(\n        d, dstd, h->resource_device(), h->dtype, ctx);\n  }\n\n  Status s;\n  if (async) {\n    // Note that `h` may not be currently ready. However execution order will\n    // make sure that `h` is ready before the copy is actually done.\n    std::unique_ptr<EagerNode> node(\n        new CopyToDeviceNode(h, *result, d, *ctx, async, mirror));\n    s = executor->AddOrExecute(std::move(node));\n  } else {\n    CopyToDeviceNode node(h, *result, d, *ctx, async, mirror);\n    s = executor->SyncExecute(&node);\n  }\n\n  // Since the operation failed, we need to Unref any outputs that were\n  // allocated.\n  if (!s.ok()) {\n    (*result)->Unref();\n    *result = nullptr;\n  }\n\n  return s;\n}\n\n}  // namespace\n\nStatus EagerCopyToDevice(TensorHandle* h, EagerContext* ctx,\n                         EagerExecutor* executor, Device* device, bool mirror,\n                         TensorHandle** result) {\n  TF_RETURN_IF_ERROR(h->WaitUnknownDevice());\n  auto send_device = h->DeviceOrHostCPU(*ctx);\n  bool sender_is_local = send_device->IsLocal();\n\n  bool receiver_is_local = device->IsLocal();\n\n  if (!executor->Async()) {\n    // In sync mode, always clear error to maintain the same behavior as before.\n    // TODO(b/141004939): Remove this.\n    executor->ClearError();\n  }\n\n  if (sender_is_local && receiver_is_local) {\n    return LocalEagerCopyToDevice(h, ctx, executor, device, mirror, result);\n  } else {\n#if defined(IS_MOBILE_PLATFORM)\n    return errors::Unimplemented(\n        \"Eager's remote execution is not available on mobile devices.\");\n#else   // !IS_MOBILE_PLATFORM\n    uint64 recv_op_id = 0;\n    if (receiver_is_local) {\n      Device* d = ctx->CanonicalDevice(device);\n      // TODO(gjn): Need to add support for async execution. Note if receiver\n      // is local, we need to first add support in TensorHandle to wait on local\n      // mirrors.\n      if (mirror) {\n        h->Ref();\n        *result = h;\n\n        if (h->HasLocalMirror(d)) {\n          return OkStatus();\n        }\n\n        Status s = h->AddEmptyLocalMirror(d);\n        if (!s.ok()) {\n          // If a mirror was added since we called HasLocalMirror then just\n          // return since another thread has already added the mirror.\n          if (s.code() == error::Code::ALREADY_EXISTS) {\n            return OkStatus();\n          }\n\n          // Remove the previously added reference count since adding the mirror\n          // failed.\n          h->Unref();\n          *result = nullptr;\n          return s;\n        }\n      } else {\n        *result = TensorHandle::CreateEmptyLocalHandle(\n            /* d= */ d, /* op_device= */ device,\n            /*resource_device=*/nullptr, h->dtype, ctx);\n      }\n    } else {\n      if (mirror) {\n        if (h->HasRemoteMirror(device, ctx->GetContextViewId())) {\n          h->Ref();\n          *result = h;\n          return OkStatus();\n        }\n      }\n      string remote_task;\n      if (!DeviceNameUtils::GetTaskName(device->parsed_name(), &remote_task)) {\n        return errors::InvalidArgument(\n            \"Unable to find remote task corresponding to device \",\n            device->name());\n      }\n      recv_op_id = ctx->RemoteMgr()->NextOpId();\n      if (mirror) {\n        TF_RETURN_IF_ERROR(h->AddUnshapedRemoteMirror(device, recv_op_id, 0,\n                                                      remote_task, ctx));\n        h->Ref();\n        *result = h;\n      } else {\n        *result = TensorHandle::CreateUnshapedRemoteHandle(\n            recv_op_id, 0, remote_task, h->dtype, device, ctx);\n      }\n    }\n\n    auto node = std::make_unique<eager::RemoteCopyNode>(\n        ctx, executor, h, result[0], device, recv_op_id);\n    Status s = executor->AddOrExecute(std::move(node));\n    if (!s.ok()) {\n      result[0]->Unref();\n      result[0] = nullptr;\n    }\n    return s;\n#endif  // !IS_MOBILE_PLATFORM\n  }\n}\n\nnamespace {\n// Low-level utility function to execute the kernel specified by `kernel` on\n// `kernel->device()`, with the provided inputs as `op_inputs` in the 'ctx'.\n// Different from `EagerKernelExecute` that ties up the thread until the\n// underlying function finishes execute, this function does not block the thread\n// and could return before the function execution finishes. The provided\n// `StatusCallback` will be triggered after function execution with its status.\nvoid EagerKernelExecuteAsync(\n    EagerContext* ctx, const absl::InlinedVector<TensorHandle*, 4>& op_inputs,\n    const absl::optional<EagerFunctionParams>& eager_func_params,\n    const core::RefCountPtr<KernelAndDevice> kernel,\n    GraphCollector* graph_collector, CancellationManager* cancellation_manager,\n    TensorHandle** retvals, int num_outputs, StatusCallback done) {\n  auto inputs = std::make_shared<ExecuteNodeArgs>(op_inputs.size());\n  auto outputs = std::make_shared<std::vector<EagerKernelRet>>(1);\n\n  Status s = inputs->Init(ctx, op_inputs, kernel);\n  if (!s.ok()) {\n    done(s);\n    return;\n  }\n  CoordinationServiceAgent* coord_agent = nullptr;\n#if !defined(IS_MOBILE_PLATFORM)\n  if (ctx->GetDistributedManager() != nullptr)\n    coord_agent = ctx->GetDistributedManager()->GetCoordinationServiceAgent();\n#endif  // !IS_MOBILE_PLATFORM\n\n  kernel->Ref();  // Ownership of reference is transferred to the callback\n  kernel->RunAsync(\n      ctx->StepContainer(), *inputs, outputs.get(), cancellation_manager,\n      eager_func_params, coord_agent,\n      [retvals, inputs, outputs, num_outputs, ctx, graph_collector,\n       eager_func_params, kernel_raw = kernel.get(),\n       done = std::move(done)](const Status& s) {\n        auto wrapped_done = [&](const Status& s) {\n          kernel_raw->Unref();\n          done(s);\n        };\n        if (!s.ok()) {\n          wrapped_done(s);\n          return;\n        }\n        if (graph_collector != nullptr) {\n          CollectGraphs(ctx);\n        }\n        DCHECK_EQ(num_outputs, outputs->size());\n        wrapped_done(GetKernelOutputs(outputs.get(), num_outputs, retvals, ctx,\n                                      kernel_raw, eager_func_params));\n      });\n}\n}  // namespace\n\n// Low-level utility to run the eager operation on local devices. Different from\n// `EagerLocalExecute` which blocks and waits for the finishing the op\n// execution, this method does not block the thread and could return before the\n// eager operation execution finishes. The provided `StatusCallback` will be\n// triggered after execution with its status.\nvoid EagerLocalExecuteAsync(EagerOperation* op, TensorHandle** retvals,\n                            int* num_retvals, StatusCallback done) {\n  if (!op->IsLocal()) {\n    done(errors::InvalidArgument(\n        \"Remote execution is not supported in async EagerLocalExecuteAsync\"));\n    return;\n  }\n\n  profiler::ScopedMemoryDebugAnnotation op_annotation(\n      op->op_name(), op->eager_func_params().has_value()\n                         ? op->eager_func_params().value().step_id.value_or(0)\n                         : 0);\n  profiler::TraceMe activity(\n      [&] { return absl::StrCat(\"EagerLocalExecuteAsync: \", op->Name()); },\n      profiler::TraceMeLevel::kInfo);\n  EagerContext& ctx = op->EagerContext();\n\n  core::RefCountPtr<KernelAndDevice> kernel;\n  Status s = GetOrCreateKernelAndDevice(op, retvals, num_retvals, &kernel);\n  if (!s.ok()) {\n    done(s);\n    return;\n  }\n\n  int num_outputs = kernel->num_outputs();\n  s = ValidateInputTypeAndPlacement(&ctx, op, kernel);\n  if (!s.ok()) {\n    done(s);\n    return;\n  }\n\n  if (ctx.LogDevicePlacement() || VLOG_IS_ON(1)) {\n    string msg = strings::StrCat(\"Executing op \", op->Name(), \" in device \",\n                                 kernel->device()->name());\n    if (!logging::LogToListeners(msg)) {\n      LOG(INFO) << msg;\n    }\n  }\n\n  GraphCollector* graph_collector = nullptr;\n  if (ctx.ShouldStoreGraphs()) {\n    graph_collector = ctx.GetGraphCollector();\n  }\n\n  for (int i = 0, end = num_outputs; i < end; ++i) {\n    const DataTypeVector& output_dtypes = kernel->output_dtypes();\n    retvals[i] = TensorHandle::CreateEmptyLocalHandle(\n        /* d= */ ctx.CanonicalDevice(kernel->OutputDevice(i)),\n        /* op_device= */ kernel->device(),\n        /* resource_device= */ kernel->OutputResourceDevice(i),\n        output_dtypes[i], &ctx);\n  }\n\n  const absl::InlinedVector<TensorHandle*, 4>* inputs;\n  s = op->TensorHandleInputs(&inputs);\n  if (!s.ok()) {\n    done(s);\n    return;\n  }\n  EagerKernelExecuteAsync(\n      &ctx, *inputs, op->eager_func_params(), std::move(kernel),\n      graph_collector, op->GetCancellationManager(), retvals, num_outputs,\n      [op, num_outputs, retvals, done = std::move(done)](const Status& s) {\n        op->Clear();\n        // Since the operation failed, we need to Unref any outputs if they were\n        // allocated.\n        if (!s.ok()) {\n          for (int i = 0, end = num_outputs; i < end; ++i) {\n            if (retvals[i] != nullptr) {\n              retvals[i]->Unref();\n              retvals[i] = nullptr;\n            }\n          }\n        }\n        done(s);\n      });\n}\n}  // namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for tensorflow.ops.data_flow_ops.{,parallel_}dynamic_stitch.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import data_flow_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import gradients_impl\nimport tensorflow.python.ops.data_flow_grad  # pylint: disable=unused-import\nfrom tensorflow.python.platform import test\n\n\nclass DynamicStitchTestBase(object):\n\n  def __init__(self, stitch_op):\n    self.stitch_op = stitch_op\n\n  def testScalar(self):\n    with test_util.use_gpu():\n      indices = [constant_op.constant(0), constant_op.constant(1)]\n      data = [constant_op.constant(40), constant_op.constant(60)]\n      for step in -1, 1:\n        stitched_t = self.stitch_op(indices[::step], data)\n        stitched_val = self.evaluate(stitched_t)\n        self.assertAllEqual([40, 60][::step], stitched_val)\n        # Dimension 0 is max(flatten(indices))+1.\n        self.assertEqual([2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testShapeInferenceForScalarWithNonConstantIndices(self):\n    with test_util.use_gpu():\n      indices = [\n          array_ops.placeholder(dtype=dtypes.int32),\n          constant_op.constant(1)\n      ]\n      data = [constant_op.constant(40), constant_op.constant(60)]\n      for step in -1, 1:\n        stitched_t = self.stitch_op(indices[::step], data)\n        # Dimension 0 is max(flatten(indices))+1, but the first indices input is\n        # not a constant tensor, so we can only infer it as a vector of unknown\n        # length.\n        self.assertEqual([None], stitched_t.get_shape().as_list())\n\n  @test_util.disable_tfrt(\"b/169901260\")\n  def testSimpleOneDimensional(self):\n    # Test various datatypes in the simple case to ensure that the op was\n    # registered under those types.\n    dtypes_to_test = [\n        dtypes.float32, dtypes.qint8, dtypes.quint8, dtypes.qint32\n    ]\n    for dtype in dtypes_to_test:\n      indices = [\n          constant_op.constant([0, 4, 7]),\n          constant_op.constant([1, 6, 2, 3, 5])\n      ]\n      data = [\n          math_ops.cast(constant_op.constant([0, 40, 70]), dtype=dtype),\n          math_ops.cast(\n              constant_op.constant([10, 60, 20, 30, 50]), dtype=dtype)\n      ]\n      stitched_t = self.stitch_op(indices, data)\n      stitched_val = self.evaluate(stitched_t)\n      self.assertAllEqual([0, 10, 20, 30, 40, 50, 60, 70], stitched_val)\n      # Dimension 0 is max(flatten(indices))+1.\n      self.assertEqual([8], stitched_t.get_shape().as_list())\n\n  def testOneListOneDimensional(self):\n    indices = [constant_op.constant([1, 6, 2, 3, 5, 0, 4, 7])]\n    data = [constant_op.constant([10, 60, 20, 30, 50, 0, 40, 70])]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual([0, 10, 20, 30, 40, 50, 60, 70], stitched_val)\n    # Dimension 0 is max(flatten(indices))+1.\n    self.assertEqual([8], stitched_t.get_shape().as_list())\n\n  def testSimpleTwoDimensional(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6]),\n        constant_op.constant([2, 3, 5])\n    ]\n    data = [\n        constant_op.constant([[0, 1], [40, 41], [70, 71]]),\n        constant_op.constant([[10, 11], [60, 61]]),\n        constant_op.constant([[20, 21], [30, 31], [50, 51]])\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual([[0, 1], [10, 11], [20, 21], [30, 31], [40, 41],\n                         [50, 51], [60, 61], [70, 71]], stitched_val)\n    # Dimension 0 is max(flatten(indices))+1.\n    self.assertEqual([8, 2], stitched_t.get_shape().as_list())\n\n  def testZeroSizeTensor(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6]),\n        constant_op.constant([2, 3, 5]),\n        array_ops.zeros([0], dtype=dtypes.int32)\n    ]\n    data = [\n        constant_op.constant([[0, 1], [40, 41], [70, 71]]),\n        constant_op.constant([[10, 11], [60, 61]]),\n        constant_op.constant([[20, 21], [30, 31], [50, 51]]),\n        array_ops.zeros([0, 2], dtype=dtypes.int32)\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual([[0, 1], [10, 11], [20, 21], [30, 31], [40, 41],\n                         [50, 51], [60, 61], [70, 71]], stitched_val)\n    # Dimension 0 is max(flatten(indices))+1.\n    self.assertEqual([8, 2], stitched_t.get_shape().as_list())\n\n  def testAllZeroSizeTensor(self):\n    indices = [\n        array_ops.zeros([0], dtype=dtypes.int32),\n        array_ops.zeros([0], dtype=dtypes.int32)\n    ]\n    data = [\n        array_ops.zeros([0, 2], dtype=dtypes.int32),\n        array_ops.zeros([0, 2], dtype=dtypes.int32)\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual(np.zeros((0, 2)), stitched_val)\n    self.assertEqual([0, 2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testHigherRank(self):\n    indices = [\n        constant_op.constant(6),\n        constant_op.constant([4, 1]),\n        constant_op.constant([[5, 2], [0, 3]])\n    ]\n    data = [\n        constant_op.constant([61., 62.]),\n        constant_op.constant([[41., 42.], [11., 12.]]),\n        constant_op.constant([[[51., 52.], [21., 22.]],\n                              [[1., 2.], [31., 32.]]])\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    correct = 10. * np.arange(7)[:, None] + [1., 2.]\n    self.assertAllEqual(correct, stitched_val)\n    self.assertEqual([7, 2], stitched_t.get_shape().as_list())\n    # Test gradients\n    stitched_grad = 7. * stitched_val\n    grads = gradients_impl.gradients(stitched_t, indices + data,\n                                     stitched_grad)\n    self.assertEqual(grads[:3], [None] * 3)  # Indices have no gradients\n    for datum, grad in zip(data, self.evaluate(grads[3:])):\n      self.assertAllEqual(7. * self.evaluate(datum), grad)\n\n  @test_util.run_deprecated_v1\n  def testErrorIndicesMultiDimensional(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([[1, 6, 2, 3, 5]])\n    ]\n    data = [\n        constant_op.constant([[0, 40, 70]]),\n        constant_op.constant([10, 60, 20, 30, 50])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  @test_util.run_deprecated_v1\n  def testErrorDataNumDimsMismatch(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6, 2, 3, 5])\n    ]\n    data = [\n        constant_op.constant([0, 40, 70]),\n        constant_op.constant([[10, 60, 20, 30, 50]])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  @test_util.run_deprecated_v1\n  def testErrorDataDimSizeMismatch(self):\n    indices = [\n        constant_op.constant([0, 4, 5]),\n        constant_op.constant([1, 6, 2, 3])\n    ]\n    data = [\n        constant_op.constant([[0], [40], [70]]),\n        constant_op.constant([[10, 11], [60, 61], [20, 21], [30, 31]])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  @test_util.run_deprecated_v1\n  def testErrorDataAndIndicesSizeMismatch(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6, 2, 3, 5])\n    ]\n    data = [\n        constant_op.constant([0, 40, 70]),\n        constant_op.constant([10, 60, 20, 30])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n\nclass DynamicStitchTest(DynamicStitchTestBase, test.TestCase):\n\n  def __init__(self, *test_case_args):\n    test.TestCase.__init__(self, *test_case_args)\n    DynamicStitchTestBase.__init__(self, data_flow_ops.dynamic_stitch)\n\n\nclass ParallelDynamicStitchTest(DynamicStitchTestBase, test.TestCase):\n\n  def __init__(self, *test_case_args):\n    test.TestCase.__init__(self, *test_case_args)\n    DynamicStitchTestBase.__init__(self, data_flow_ops.parallel_dynamic_stitch)\n\n  def testScalar(self):\n    with test_util.use_gpu():\n      indices = [constant_op.constant(0), constant_op.constant(1)]\n      data = [constant_op.constant(40.0), constant_op.constant(60.0)]\n      for step in -1, 1:\n        stitched_t = data_flow_ops.dynamic_stitch(indices[::step], data)\n        stitched_val = self.evaluate(stitched_t)\n        self.assertAllEqual([40.0, 60.0][::step], stitched_val)\n        # Dimension 0 is max(flatten(indices))+1.\n        self.assertEqual([2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testHigherRank(self):\n    indices = [\n        constant_op.constant(6),\n        constant_op.constant([4, 1]),\n        constant_op.constant([[5, 2], [0, 3]])\n    ]\n    data = [\n        constant_op.constant([61, 62], dtype=dtypes.float32),\n        constant_op.constant([[41, 42], [11, 12]], dtype=dtypes.float32),\n        constant_op.constant(\n            [[[51, 52], [21, 22]], [[1, 2], [31, 32]]], dtype=dtypes.float32)\n    ]\n    stitched_t = data_flow_ops.dynamic_stitch(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    correct = 10 * np.arange(7)[:, None] + [1.0, 2.0]\n    self.assertAllEqual(correct, stitched_val)\n    self.assertEqual([7, 2], stitched_t.get_shape().as_list())\n    # Test gradients\n    stitched_grad = 7 * stitched_val\n    grads = gradients_impl.gradients(stitched_t, indices + data,\n                                     stitched_grad)\n    self.assertEqual(grads[:3], [None] * 3)  # Indices have no gradients\n    for datum, grad in zip(data, self.evaluate(grads[3:])):\n      self.assertAllEqual(7.0 * self.evaluate(datum), grad)\n\n  # GPU version unit tests\n  def testScalarGPU(self):\n    indices = [constant_op.constant(0), constant_op.constant(1)]\n    data = [constant_op.constant(40.0), constant_op.constant(60.0)]\n    for step in -1, 1:\n      stitched_t = data_flow_ops.dynamic_stitch(indices[::step], data)\n      stitched_val = self.evaluate(stitched_t)\n      self.assertAllEqual([40.0, 60.0][::step], stitched_val)\n      # Dimension 0 is max(flatten(indices))+1.\n      self.assertEqual([2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testHigherRankGPU(self):\n    indices = [\n        constant_op.constant(6),\n        constant_op.constant([4, 1]),\n        constant_op.constant([[5, 2], [0, 3]])\n    ]\n    data = [\n        constant_op.constant([61, 62], dtype=dtypes.float32),\n        constant_op.constant([[41, 42], [11, 12]], dtype=dtypes.float32),\n        constant_op.constant(\n            [[[51, 52], [21, 22]], [[1, 2], [31, 32]]], dtype=dtypes.float32)\n    ]\n    stitched_t = data_flow_ops.dynamic_stitch(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    correct = 10 * np.arange(7)[:, None] + [1.0, 2.0]\n    self.assertAllEqual(correct, stitched_val)\n    self.assertEqual([7, 2], stitched_t.get_shape().as_list())\n    # Test gradients\n    stitched_grad = 7 * stitched_val\n    grads = gradients_impl.gradients(stitched_t, indices + data,\n                                     stitched_grad)\n    self.assertEqual(grads[:3], [None] * 3)  # Indices have no gradients\n    for datum, grad in zip(data, self.evaluate(grads[3:])):\n      self.assertAllEqual(7.0 * self.evaluate(datum), grad)\n\n  @test_util.run_in_graph_and_eager_modes\n  def testMismatchedDataAndIndexListSizes(self):\n    indices = [\n        constant_op.constant([2]),\n        constant_op.constant([1]),\n        constant_op.constant([0]),\n        constant_op.constant([3]),\n    ]\n    data = [\n        constant_op.constant([1.0]),\n        constant_op.constant([2.0]),\n        constant_op.constant([3.0]),\n        constant_op.constant([4.0])\n    ]\n    with self.assertRaisesRegex(\n        (ValueError, errors.InvalidArgumentError),\n        \"expected inputs .* do not match|List argument .* must match\"):\n      self.evaluate(data_flow_ops.dynamic_stitch(indices[0:2], data))\n\n    with self.assertRaisesRegex(\n        (ValueError, errors.InvalidArgumentError),\n        \"expected inputs .* do not match|List argument .* must match\"):\n      self.evaluate(data_flow_ops.dynamic_stitch(indices, data[0:2]))\n\nif __name__ == \"__main__\":\n  test.main()\n"], "filenames": ["tensorflow/core/common_runtime/eager/execute.cc", "tensorflow/python/kernel_tests/data_structures/dynamic_stitch_op_test.py"], "buggy_code_start_loc": [315, 20], "buggy_code_end_loc": [315, 310], "fixing_code_start_loc": [316, 21], "fixing_code_end_loc": [320, 335], "type": "CWE-125", "message": "TensorFlow is an open source platform for machine learning. When ops that have specified input sizes receive a differing number of inputs, the executor will crash. We have patched the issue in GitHub commit f5381e0e10b5a61344109c1b7c174c68110f7629. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2022-41883", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-18T21:15:10.923", "lastModified": "2022-11-23T18:12:30.150", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. When ops that have specified input sizes receive a differing number of inputs, the executor will crash. We have patched the issue in GitHub commit f5381e0e10b5a61344109c1b7c174c68110f7629. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10.0:-:*:*:*:*:*:*", "matchCriteriaId": "471595C4-437A-4DDA-A4CA-91FF1E1CD7A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "B5F5D78E-DBBA-4CC7-ADB1-454F86700280"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "EF6375A0-9871-4072-95F0-4266620F4713"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "534F3684-3E31-4A0A-9821-70EEFA8AB258"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "E1D5EAED-B494-4E30-AB79-99BD1876B5FA"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/dynamic_stitch_op.cc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/ops/data_flow_ops.cc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/f5381e0e10b5a61344109c1b7c174c68110f7629", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-w58w-79xv-6vcj", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/f5381e0e10b5a61344109c1b7c174c68110f7629"}}