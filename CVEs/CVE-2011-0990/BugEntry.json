{"buggy_code": ["/*\n * icall.c:\n *\n * Authors:\n *   Dietmar Maurer (dietmar@ximian.com)\n *   Paolo Molaro (lupus@ximian.com)\n *\t Patrik Torstensson (patrik.torstensson@labs2.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n */\n\n#include <config.h>\n#include <glib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <ctype.h>\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if defined (PLATFORM_WIN32)\n#include <stdlib.h>\n#endif\n\n#include \"mono/utils/mono-membar.h\"\n#include <mono/metadata/object.h>\n#include <mono/metadata/threads.h>\n#include <mono/metadata/threads-types.h>\n#include <mono/metadata/threadpool.h>\n#include <mono/metadata/monitor.h>\n#include <mono/metadata/reflection.h>\n#include <mono/metadata/assembly.h>\n#include <mono/metadata/tabledefs.h>\n#include <mono/metadata/exception.h>\n#include <mono/metadata/file-io.h>\n#include <mono/metadata/console-io.h>\n#include <mono/metadata/socket-io.h>\n#include <mono/metadata/mono-endian.h>\n#include <mono/metadata/tokentype.h>\n#include <mono/metadata/domain-internals.h>\n#include <mono/metadata/metadata-internals.h>\n#include <mono/metadata/class-internals.h>\n#include <mono/metadata/marshal.h>\n#include <mono/metadata/gc-internal.h>\n#include <mono/metadata/mono-gc.h>\n#include <mono/metadata/rand.h>\n#include <mono/metadata/sysmath.h>\n#include <mono/metadata/string-icalls.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/metadata/process.h>\n#include <mono/metadata/environment.h>\n#include <mono/metadata/profiler-private.h>\n#include <mono/metadata/locales.h>\n#include <mono/metadata/filewatcher.h>\n#include <mono/metadata/char-conversions.h>\n#include <mono/metadata/security.h>\n#include <mono/metadata/mono-config.h>\n#include <mono/metadata/cil-coff.h>\n#include <mono/metadata/number-formatter.h>\n#include <mono/metadata/security-manager.h>\n#include <mono/metadata/security-core-clr.h>\n#include <mono/metadata/mono-perfcounters.h>\n#include <mono/metadata/mono-debug.h>\n#include <mono/metadata/verify-internals.h>\n#include <mono/io-layer/io-layer.h>\n#include <mono/utils/strtod.h>\n#include <mono/utils/monobitset.h>\n#include <mono/utils/mono-time.h>\n#include <mono/utils/mono-proclib.h>\n#include <mono/utils/mono-string.h>\n#include <mono/utils/mono-error-internals.h>\n\n\n#if defined (PLATFORM_WIN32)\n#include <windows.h>\n#include <shlobj.h>\n#endif\n#include \"decimal.h\"\n\nstatic MonoReflectionAssembly* ves_icall_System_Reflection_Assembly_GetCallingAssembly (void);\n\nstatic MonoArray*\ntype_array_from_modifiers (MonoImage *image, MonoType *type, int optional);\n\n/* This is an implementation of a growable pointer array that avoids doing memory allocations for small sizes.\n * It works by allocating an initial small array on stack and only going to malloc'd memory if needed. \n */\ntypedef struct {\n\tvoid **data;\n\tint size;\n\tint capacity;\n} MonoPtrArray;\n\n#define MONO_PTR_ARRAY_MAX_ON_STACK (16)\n\n#define mono_ptr_array_init(ARRAY, INITIAL_SIZE) do {\\\n\t(ARRAY).size = 0; \\\n\t(ARRAY).capacity = MAX (INITIAL_SIZE, MONO_PTR_ARRAY_MAX_ON_STACK); \\\n\t(ARRAY).data = INITIAL_SIZE > MONO_PTR_ARRAY_MAX_ON_STACK ? mono_gc_alloc_fixed (sizeof (void*) * INITIAL_SIZE, NULL) : g_newa (void*, MONO_PTR_ARRAY_MAX_ON_STACK); \\\n} while (0)\n\n#define mono_ptr_array_destroy(ARRAY) do {\\\n\tif ((ARRAY).capacity > MONO_PTR_ARRAY_MAX_ON_STACK) \\\n\t\tmono_gc_free_fixed ((ARRAY).data); \\\n} while (0)\n\n#define mono_ptr_array_append(ARRAY, VALUE) do { \\\n\tif ((ARRAY).size >= (ARRAY).capacity) {\\\n\t\tvoid *__tmp = mono_gc_alloc_fixed (sizeof (void*) * (ARRAY).capacity * 2, NULL); \\\n\t\tmemcpy (__tmp, (ARRAY).data, (ARRAY).capacity * sizeof (void*)); \\\n\t\tif ((ARRAY).capacity > MONO_PTR_ARRAY_MAX_ON_STACK)\t\\\n\t\t\tmono_gc_free_fixed ((ARRAY).data);\t\\\n\t\t(ARRAY).data = __tmp;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t(ARRAY).capacity *= 2;\\\n\t}\\\n\t((ARRAY).data [(ARRAY).size++] = VALUE); \\\n} while (0)\n\n#define mono_ptr_array_set(ARRAY, IDX, VALUE) do { \\\n\t((ARRAY).data [(IDX)] = VALUE); \\\n} while (0)\n\t\n#define mono_ptr_array_get(ARRAY, IDX) ((ARRAY).data [(IDX)])\n\n#define mono_ptr_array_size(ARRAY) ((ARRAY).size)\n\n\nstatic inline MonoBoolean\nis_generic_parameter (MonoType *type)\n{\n\treturn !type->byref && (type->type == MONO_TYPE_VAR || type->type == MONO_TYPE_MVAR);\n}\n\n/*\n * We expect a pointer to a char, not a string\n */\nstatic gboolean\nmono_double_ParseImpl (char *ptr, double *result)\n{\n\tgchar *endptr = NULL;\n\t*result = 0.0;\n\n\tMONO_ARCH_SAVE_REGS;\n\n#ifdef __arm__\n\tif (*ptr)\n\t\t*result = strtod (ptr, &endptr);\n#else\n\tif (*ptr){\n#ifdef _EGLIB_MAJOR\n\t\t/* Need to lock here because EGLIB (#464316) has locking defined as no-ops, and that breaks mono_strtod */\n\t\tEnterCriticalSection (&mono_strtod_mutex);\n\t\t*result = mono_strtod (ptr, &endptr);\n\t\tLeaveCriticalSection (&mono_strtod_mutex);\n#else\n\t\t*result = mono_strtod (ptr, &endptr);\n#endif\n\t}\n#endif\n\n\tif (!*ptr || (endptr && *endptr))\n\t\treturn FALSE;\n\t\n\treturn TRUE;\n}\n\nstatic MonoObject *\nves_icall_System_Array_GetValueImpl (MonoObject *this, guint32 pos)\n{\n\tMonoClass *ac;\n\tMonoArray *ao;\n\tgint32 esize;\n\tgpointer *ea;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tao = (MonoArray *)this;\n\tac = (MonoClass *)ao->obj.vtable->klass;\n\n\tesize = mono_array_element_size (ac);\n\tea = (gpointer*)((char*)ao->vector + (pos * esize));\n\n\tif (ac->element_class->valuetype)\n\t\treturn mono_value_box (this->vtable->domain, ac->element_class, ea);\n\telse\n\t\treturn *ea;\n}\n\nstatic MonoObject *\nves_icall_System_Array_GetValue (MonoObject *this, MonoObject *idxs)\n{\n\tMonoClass *ac, *ic;\n\tMonoArray *ao, *io;\n\tgint32 i, pos, *ind;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (idxs);\n\n\tio = (MonoArray *)idxs;\n\tic = (MonoClass *)io->obj.vtable->klass;\n\t\n\tao = (MonoArray *)this;\n\tac = (MonoClass *)ao->obj.vtable->klass;\n\n\tg_assert (ic->rank == 1);\n\tif (io->bounds != NULL || io->max_length !=  ac->rank)\n\t\tmono_raise_exception (mono_get_exception_argument (NULL, NULL));\n\n\tind = (gint32 *)io->vector;\n\n\tif (ao->bounds == NULL) {\n\t\tif (*ind < 0 || *ind >= ao->max_length)\n\t\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\n\t\treturn ves_icall_System_Array_GetValueImpl (this, *ind);\n\t}\n\t\n\tfor (i = 0; i < ac->rank; i++)\n\t\tif ((ind [i] < ao->bounds [i].lower_bound) ||\n\t\t    (ind [i] >=  (mono_array_lower_bound_t)ao->bounds [i].length + ao->bounds [i].lower_bound))\n\t\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\n\tpos = ind [0] - ao->bounds [0].lower_bound;\n\tfor (i = 1; i < ac->rank; i++)\n\t\tpos = pos*ao->bounds [i].length + ind [i] - \n\t\t\tao->bounds [i].lower_bound;\n\n\treturn ves_icall_System_Array_GetValueImpl (this, pos);\n}\n\nstatic void\nves_icall_System_Array_SetValueImpl (MonoArray *this, MonoObject *value, guint32 pos)\n{\n\tMonoClass *ac, *vc, *ec;\n\tgint32 esize, vsize;\n\tgpointer *ea, *va;\n\tint et, vt;\n\n\tguint64 u64 = 0;\n\tgint64 i64 = 0;\n\tgdouble r64 = 0;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (value)\n\t\tvc = value->vtable->klass;\n\telse\n\t\tvc = NULL;\n\n\tac = this->obj.vtable->klass;\n\tec = ac->element_class;\n\n\tesize = mono_array_element_size (ac);\n\tea = (gpointer*)((char*)this->vector + (pos * esize));\n\tva = (gpointer*)((char*)value + sizeof (MonoObject));\n\n\tif (mono_class_is_nullable (ec)) {\n\t\tmono_nullable_init ((guint8*)ea, value, ec);\n\t\treturn;\n\t}\n\n\tif (!value) {\n\t\tmemset (ea, 0,  esize);\n\t\treturn;\n\t}\n\n#define NO_WIDENING_CONVERSION G_STMT_START{\\\n\tmono_raise_exception (mono_get_exception_argument ( \\\n\t\t\"value\", \"not a widening conversion\")); \\\n}G_STMT_END\n\n#define CHECK_WIDENING_CONVERSION(extra) G_STMT_START{\\\n\tif (esize < vsize + (extra)) \\\n\t\tmono_raise_exception (mono_get_exception_argument ( \\\n\t\t\t\"value\", \"not a widening conversion\")); \\\n}G_STMT_END\n\n#define INVALID_CAST G_STMT_START{\\\n\tmono_raise_exception (mono_get_exception_invalid_cast ()); \\\n}G_STMT_END\n\n\t/* Check element (destination) type. */\n\tswitch (ec->byval_arg.type) {\n\tcase MONO_TYPE_STRING:\n\t\tswitch (vc->byval_arg.type) {\n\t\tcase MONO_TYPE_STRING:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tINVALID_CAST;\n\t\t}\n\t\tbreak;\n\tcase MONO_TYPE_BOOLEAN:\n\t\tswitch (vc->byval_arg.type) {\n\t\tcase MONO_TYPE_BOOLEAN:\n\t\t\tbreak;\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_U1:\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_I4:\n\t\tcase MONO_TYPE_I8:\n\t\tcase MONO_TYPE_R4:\n\t\tcase MONO_TYPE_R8:\n\t\t\tNO_WIDENING_CONVERSION;\n\t\tdefault:\n\t\t\tINVALID_CAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!ec->valuetype) {\n\t\tif (!mono_object_isinst (value, ec))\n\t\t\tINVALID_CAST;\n\t\tmono_gc_wbarrier_set_arrayref (this, ea, (MonoObject*)value);\n\t\treturn;\n\t}\n\n\tif (mono_object_isinst (value, ec)) {\n\t\tif (ec->has_references)\n\t\t\tmono_value_copy (ea, (char*)value + sizeof (MonoObject), ec);\n\t\telse\n\t\t\tmemcpy (ea, (char *)value + sizeof (MonoObject), esize);\n\t\treturn;\n\t}\n\n\tif (!vc->valuetype)\n\t\tINVALID_CAST;\n\n\tvsize = mono_class_instance_size (vc) - sizeof (MonoObject);\n\n\tet = ec->byval_arg.type;\n\tif (et == MONO_TYPE_VALUETYPE && ec->byval_arg.data.klass->enumtype)\n\t\tet = mono_class_enum_basetype (ec->byval_arg.data.klass)->type;\n\n\tvt = vc->byval_arg.type;\n\tif (vt == MONO_TYPE_VALUETYPE && vc->byval_arg.data.klass->enumtype)\n\t\tvt = mono_class_enum_basetype (vc->byval_arg.data.klass)->type;\n\n#define ASSIGN_UNSIGNED(etype) G_STMT_START{\\\n\tswitch (vt) { \\\n\tcase MONO_TYPE_U1: \\\n\tcase MONO_TYPE_U2: \\\n\tcase MONO_TYPE_U4: \\\n\tcase MONO_TYPE_U8: \\\n\tcase MONO_TYPE_CHAR: \\\n\t\tCHECK_WIDENING_CONVERSION(0); \\\n\t\t*(etype *) ea = (etype) u64; \\\n\t\treturn; \\\n\t/* You can't assign a signed value to an unsigned array. */ \\\n\tcase MONO_TYPE_I1: \\\n\tcase MONO_TYPE_I2: \\\n\tcase MONO_TYPE_I4: \\\n\tcase MONO_TYPE_I8: \\\n\t/* You can't assign a floating point number to an integer array. */ \\\n\tcase MONO_TYPE_R4: \\\n\tcase MONO_TYPE_R8: \\\n\t\tNO_WIDENING_CONVERSION; \\\n\t} \\\n}G_STMT_END\n\n#define ASSIGN_SIGNED(etype) G_STMT_START{\\\n\tswitch (vt) { \\\n\tcase MONO_TYPE_I1: \\\n\tcase MONO_TYPE_I2: \\\n\tcase MONO_TYPE_I4: \\\n\tcase MONO_TYPE_I8: \\\n\t\tCHECK_WIDENING_CONVERSION(0); \\\n\t\t*(etype *) ea = (etype) i64; \\\n\t\treturn; \\\n\t/* You can assign an unsigned value to a signed array if the array's */ \\\n\t/* element size is larger than the value size. */ \\\n\tcase MONO_TYPE_U1: \\\n\tcase MONO_TYPE_U2: \\\n\tcase MONO_TYPE_U4: \\\n\tcase MONO_TYPE_U8: \\\n\tcase MONO_TYPE_CHAR: \\\n\t\tCHECK_WIDENING_CONVERSION(1); \\\n\t\t*(etype *) ea = (etype) u64; \\\n\t\treturn; \\\n\t/* You can't assign a floating point number to an integer array. */ \\\n\tcase MONO_TYPE_R4: \\\n\tcase MONO_TYPE_R8: \\\n\t\tNO_WIDENING_CONVERSION; \\\n\t} \\\n}G_STMT_END\n\n#define ASSIGN_REAL(etype) G_STMT_START{\\\n\tswitch (vt) { \\\n\tcase MONO_TYPE_R4: \\\n\tcase MONO_TYPE_R8: \\\n\t\tCHECK_WIDENING_CONVERSION(0); \\\n\t\t*(etype *) ea = (etype) r64; \\\n\t\treturn; \\\n\t/* All integer values fit into a floating point array, so we don't */ \\\n\t/* need to CHECK_WIDENING_CONVERSION here. */ \\\n\tcase MONO_TYPE_I1: \\\n\tcase MONO_TYPE_I2: \\\n\tcase MONO_TYPE_I4: \\\n\tcase MONO_TYPE_I8: \\\n\t\t*(etype *) ea = (etype) i64; \\\n\t\treturn; \\\n\tcase MONO_TYPE_U1: \\\n\tcase MONO_TYPE_U2: \\\n\tcase MONO_TYPE_U4: \\\n\tcase MONO_TYPE_U8: \\\n\tcase MONO_TYPE_CHAR: \\\n\t\t*(etype *) ea = (etype) u64; \\\n\t\treturn; \\\n\t} \\\n}G_STMT_END\n\n\tswitch (vt) {\n\tcase MONO_TYPE_U1:\n\t\tu64 = *(guint8 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_U2:\n\t\tu64 = *(guint16 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_U4:\n\t\tu64 = *(guint32 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_U8:\n\t\tu64 = *(guint64 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_I1:\n\t\ti64 = *(gint8 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_I2:\n\t\ti64 = *(gint16 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_I4:\n\t\ti64 = *(gint32 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_I8:\n\t\ti64 = *(gint64 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_R4:\n\t\tr64 = *(gfloat *) va;\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n\t\tr64 = *(gdouble *) va;\n\t\tbreak;\n\tcase MONO_TYPE_CHAR:\n\t\tu64 = *(guint16 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_BOOLEAN:\n\t\t/* Boolean is only compatible with itself. */\n\t\tswitch (et) {\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_U1:\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_I4:\n\t\tcase MONO_TYPE_I8:\n\t\tcase MONO_TYPE_R4:\n\t\tcase MONO_TYPE_R8:\n\t\t\tNO_WIDENING_CONVERSION;\n\t\tdefault:\n\t\t\tINVALID_CAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* If we can't do a direct copy, let's try a widening conversion. */\n\tswitch (et) {\n\tcase MONO_TYPE_CHAR:\n\t\tASSIGN_UNSIGNED (guint16);\n\tcase MONO_TYPE_U1:\n\t\tASSIGN_UNSIGNED (guint8);\n\tcase MONO_TYPE_U2:\n\t\tASSIGN_UNSIGNED (guint16);\n\tcase MONO_TYPE_U4:\n\t\tASSIGN_UNSIGNED (guint32);\n\tcase MONO_TYPE_U8:\n\t\tASSIGN_UNSIGNED (guint64);\n\tcase MONO_TYPE_I1:\n\t\tASSIGN_SIGNED (gint8);\n\tcase MONO_TYPE_I2:\n\t\tASSIGN_SIGNED (gint16);\n\tcase MONO_TYPE_I4:\n\t\tASSIGN_SIGNED (gint32);\n\tcase MONO_TYPE_I8:\n\t\tASSIGN_SIGNED (gint64);\n\tcase MONO_TYPE_R4:\n\t\tASSIGN_REAL (gfloat);\n\tcase MONO_TYPE_R8:\n\t\tASSIGN_REAL (gdouble);\n\t}\n\n\tINVALID_CAST;\n\t/* Not reached, INVALID_CAST does not return. Just to avoid a compiler warning ... */\n\treturn;\n\n#undef INVALID_CAST\n#undef NO_WIDENING_CONVERSION\n#undef CHECK_WIDENING_CONVERSION\n#undef ASSIGN_UNSIGNED\n#undef ASSIGN_SIGNED\n#undef ASSIGN_REAL\n}\n\nstatic void \nves_icall_System_Array_SetValue (MonoArray *this, MonoObject *value,\n\t\t\t\t MonoArray *idxs)\n{\n\tMonoClass *ac, *ic;\n\tgint32 i, pos, *ind;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (idxs);\n\n\tic = idxs->obj.vtable->klass;\n\tac = this->obj.vtable->klass;\n\n\tg_assert (ic->rank == 1);\n\tif (idxs->bounds != NULL || idxs->max_length != ac->rank)\n\t\tmono_raise_exception (mono_get_exception_argument (NULL, NULL));\n\n\tind = (gint32 *)idxs->vector;\n\n\tif (this->bounds == NULL) {\n\t\tif (*ind < 0 || *ind >= this->max_length)\n\t\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\n\t\tves_icall_System_Array_SetValueImpl (this, value, *ind);\n\t\treturn;\n\t}\n\t\n\tfor (i = 0; i < ac->rank; i++)\n\t\tif ((ind [i] < this->bounds [i].lower_bound) ||\n\t\t    (ind [i] >= (mono_array_lower_bound_t)this->bounds [i].length + this->bounds [i].lower_bound))\n\t\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\n\tpos = ind [0] - this->bounds [0].lower_bound;\n\tfor (i = 1; i < ac->rank; i++)\n\t\tpos = pos * this->bounds [i].length + ind [i] - \n\t\t\tthis->bounds [i].lower_bound;\n\n\tves_icall_System_Array_SetValueImpl (this, value, pos);\n}\n\nstatic MonoArray *\nves_icall_System_Array_CreateInstanceImpl (MonoReflectionType *type, MonoArray *lengths, MonoArray *bounds)\n{\n\tMonoClass *aklass;\n\tMonoArray *array;\n\tmono_array_size_t *sizes, i;\n\tgboolean bounded = FALSE;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (type);\n\tMONO_CHECK_ARG_NULL (lengths);\n\n\tMONO_CHECK_ARG (lengths, mono_array_length (lengths) > 0);\n\tif (bounds)\n\t\tMONO_CHECK_ARG (bounds, mono_array_length (lengths) == mono_array_length (bounds));\n\n\tfor (i = 0; i < mono_array_length (lengths); i++)\n\t\tif (mono_array_get (lengths, gint32, i) < 0)\n\t\t\tmono_raise_exception (mono_get_exception_argument_out_of_range (NULL));\n\n\tif (bounds && (mono_array_length (bounds) == 1) && (mono_array_get (bounds, gint32, 0) != 0))\n\t\t/* vectors are not the same as one dimensional arrays with no-zero bounds */\n\t\tbounded = TRUE;\n\telse\n\t\tbounded = FALSE;\n\n\taklass = mono_bounded_array_class_get (mono_class_from_mono_type (type->type), mono_array_length (lengths), bounded);\n\n\tsizes = alloca (aklass->rank * sizeof(mono_array_size_t) * 2);\n\tfor (i = 0; i < aklass->rank; ++i) {\n\t\tsizes [i] = mono_array_get (lengths, guint32, i);\n\t\tif (bounds)\n\t\t\tsizes [i + aklass->rank] = mono_array_get (bounds, guint32, i);\n\t\telse\n\t\t\tsizes [i + aklass->rank] = 0;\n\t}\n\n\tarray = mono_array_new_full (mono_object_domain (type), aklass, sizes, sizes + aklass->rank);\n\n\treturn array;\n}\n\nstatic MonoArray *\nves_icall_System_Array_CreateInstanceImpl64 (MonoReflectionType *type, MonoArray *lengths, MonoArray *bounds)\n{\n\tMonoClass *aklass;\n\tMonoArray *array;\n\tmono_array_size_t *sizes, i;\n\tgboolean bounded = FALSE;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (type);\n\tMONO_CHECK_ARG_NULL (lengths);\n\n\tMONO_CHECK_ARG (lengths, mono_array_length (lengths) > 0);\n\tif (bounds)\n\t\tMONO_CHECK_ARG (bounds, mono_array_length (lengths) == mono_array_length (bounds));\n\n\tfor (i = 0; i < mono_array_length (lengths); i++) \n\t\tif ((mono_array_get (lengths, gint64, i) < 0) ||\n\t\t    (mono_array_get (lengths, gint64, i) > MONO_ARRAY_MAX_INDEX))\n\t\t\tmono_raise_exception (mono_get_exception_argument_out_of_range (NULL));\n\n\tif (bounds && (mono_array_length (bounds) == 1) && (mono_array_get (bounds, gint64, 0) != 0))\n\t\t/* vectors are not the same as one dimensional arrays with no-zero bounds */\n\t\tbounded = TRUE;\n\telse\n\t\tbounded = FALSE;\n\n\taklass = mono_bounded_array_class_get (mono_class_from_mono_type (type->type), mono_array_length (lengths), bounded);\n\n\tsizes = alloca (aklass->rank * sizeof(mono_array_size_t) * 2);\n\tfor (i = 0; i < aklass->rank; ++i) {\n\t\tsizes [i] = mono_array_get (lengths, guint64, i);\n\t\tif (bounds)\n\t\t\tsizes [i + aklass->rank] = (mono_array_size_t) mono_array_get (bounds, guint64, i);\n\t\telse\n\t\t\tsizes [i + aklass->rank] = 0;\n\t}\n\n\tarray = mono_array_new_full (mono_object_domain (type), aklass, sizes, sizes + aklass->rank);\n\n\treturn array;\n}\n\nstatic gint32 \nves_icall_System_Array_GetRank (MonoObject *this)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn this->vtable->klass->rank;\n}\n\nstatic gint32\nves_icall_System_Array_GetLength (MonoArray *this, gint32 dimension)\n{\n\tgint32 rank = ((MonoObject *)this)->vtable->klass->rank;\n\tmono_array_size_t length;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif ((dimension < 0) || (dimension >= rank))\n\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\t\n\tif (this->bounds == NULL)\n\t\tlength = this->max_length;\n\telse\n\t\tlength = this->bounds [dimension].length;\n\n#ifdef MONO_BIG_ARRAYS\n\tif (length > G_MAXINT32)\n\t        mono_raise_exception (mono_get_exception_overflow ());\n#endif\n\treturn length;\n}\n\nstatic gint64\nves_icall_System_Array_GetLongLength (MonoArray *this, gint32 dimension)\n{\n\tgint32 rank = ((MonoObject *)this)->vtable->klass->rank;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif ((dimension < 0) || (dimension >= rank))\n\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\t\n\tif (this->bounds == NULL)\n \t\treturn this->max_length;\n \t\n \treturn this->bounds [dimension].length;\n}\n\nstatic gint32\nves_icall_System_Array_GetLowerBound (MonoArray *this, gint32 dimension)\n{\n\tgint32 rank = ((MonoObject *)this)->vtable->klass->rank;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif ((dimension < 0) || (dimension >= rank))\n\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\t\n\tif (this->bounds == NULL)\n\t\treturn 0;\n\t\n\treturn this->bounds [dimension].lower_bound;\n}\n\nstatic void\nves_icall_System_Array_ClearInternal (MonoArray *arr, int idx, int length)\n{\n\tint sz = mono_array_element_size (mono_object_class (arr));\n\tmemset (mono_array_addr_with_size (arr, sz, idx), 0, length * sz);\n}\n\nstatic gboolean\nves_icall_System_Array_FastCopy (MonoArray *source, int source_idx, MonoArray* dest, int dest_idx, int length)\n{\n\tint element_size;\n\tvoid * dest_addr;\n\tvoid * source_addr;\n\tMonoClass *src_class;\n\tMonoClass *dest_class;\n\tint i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (source->obj.vtable->klass->rank != dest->obj.vtable->klass->rank)\n\t\treturn FALSE;\n\n\tif (source->bounds || dest->bounds)\n\t\treturn FALSE;\n\n\t/* there's no integer overflow since mono_array_length returns an unsigned integer */\n\tif ((dest_idx + length > mono_array_length (dest)) ||\n\t\t(source_idx + length > mono_array_length (source)))\n\t\treturn FALSE;\n\n\tsrc_class = source->obj.vtable->klass->element_class;\n\tdest_class = dest->obj.vtable->klass->element_class;\n\n\t/*\n\t * Handle common cases.\n\t */\n\n\t/* Case1: object[] -> valuetype[] (ArrayList::ToArray) */\n\tif (src_class == mono_defaults.object_class && dest_class->valuetype) {\n\t\tint has_refs = dest_class->has_references;\n\t\tfor (i = source_idx; i < source_idx + length; ++i) {\n\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, i);\n\t\t\tif (elem && !mono_object_isinst (elem, dest_class))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\telement_size = mono_array_element_size (dest->obj.vtable->klass);\n\t\tmemset (mono_array_addr_with_size (dest, element_size, dest_idx), 0, element_size * length);\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, source_idx + i);\n\t\t\tvoid *addr = mono_array_addr_with_size (dest, element_size, dest_idx + i);\n\t\t\tif (!elem)\n\t\t\t\tcontinue;\n\t\t\tif (has_refs)\n\t\t\t\tmono_value_copy (addr, (char *)elem + sizeof (MonoObject), dest_class);\n\t\t\telse\n\t\t\t\tmemcpy (addr, (char *)elem + sizeof (MonoObject), element_size);\n\t\t}\n\t\treturn TRUE;\n\t}\n\n\t/* Check if we're copying a char[] <==> (u)short[] */\n\tif (src_class != dest_class) {\n\t\tif (dest_class->valuetype || dest_class->enumtype || src_class->valuetype || src_class->enumtype)\n\t\t\treturn FALSE;\n\n\t\tif (mono_class_is_subclass_of (src_class, dest_class, FALSE))\n\t\t\t;\n\t\t/* Case2: object[] -> reftype[] (ArrayList::ToArray) */\n\t\telse if (mono_class_is_subclass_of (dest_class, src_class, FALSE))\n\t\t\tfor (i = source_idx; i < source_idx + length; ++i) {\n\t\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, i);\n\t\t\t\tif (elem && !mono_object_isinst (elem, dest_class))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\telse\n\t\t\treturn FALSE;\n\t}\n\n\tif (dest_class->valuetype) {\n\t\telement_size = mono_array_element_size (source->obj.vtable->klass);\n\t\tsource_addr = mono_array_addr_with_size (source, element_size, source_idx);\n\t\tif (dest_class->has_references) {\n\t\t\tmono_value_copy_array (dest, dest_idx, source_addr, length);\n\t\t} else {\n\t\t\tdest_addr = mono_array_addr_with_size (dest, element_size, dest_idx);\n\t\t\tmemmove (dest_addr, source_addr, element_size * length);\n\t\t}\n\t} else {\n\t\tmono_array_memcpy_refs (dest, dest_idx, source, source_idx, length);\n\t}\n\n\treturn TRUE;\n}\n\nstatic void\nves_icall_System_Array_GetGenericValueImpl (MonoObject *this, guint32 pos, gpointer value)\n{\n\tMonoClass *ac;\n\tMonoArray *ao;\n\tgint32 esize;\n\tgpointer *ea;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tao = (MonoArray *)this;\n\tac = (MonoClass *)ao->obj.vtable->klass;\n\n\tesize = mono_array_element_size (ac);\n\tea = (gpointer*)((char*)ao->vector + (pos * esize));\n\n\tmemcpy (value, ea, esize);\n}\n\nstatic void\nves_icall_System_Array_SetGenericValueImpl (MonoObject *this, guint32 pos, gpointer value)\n{\n\tMonoClass *ac, *ec;\n\tMonoArray *ao;\n\tgint32 esize;\n\tgpointer *ea;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tao = (MonoArray *)this;\n\tac = (MonoClass *)ao->obj.vtable->klass;\n\tec = ac->element_class;\n\n\tesize = mono_array_element_size (ac);\n\tea = (gpointer*)((char*)ao->vector + (pos * esize));\n\n\tif (MONO_TYPE_IS_REFERENCE (&ec->byval_arg)) {\n\t\tg_assert (esize == sizeof (gpointer));\n\t\tmono_gc_wbarrier_generic_store (ea, *(gpointer*)value);\n\t} else {\n\t\tg_assert (ec->inited);\n\t\tif (ec->has_references)\n\t\t\tmono_gc_wbarrier_value_copy (ea, value, 1, ec);\n\t\tmemcpy (ea, value, esize);\n\t}\n}\n\nstatic void\nves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray (MonoArray *array, MonoClassField *field_handle)\n{\n\tMonoClass *klass = array->obj.vtable->klass;\n\tguint32 size = mono_array_element_size (klass);\n\tMonoType *type = mono_type_get_underlying_type (&klass->element_class->byval_arg);\n\tint align;\n\tconst char *field_data;\n\n\tif (MONO_TYPE_IS_REFERENCE (type) || type->type == MONO_TYPE_VALUETYPE) {\n\t\tMonoException *exc = mono_get_exception_argument(\"array\",\n\t\t\t\"Cannot initialize array of non-primitive type.\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tif (!(field_handle->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA)) {\n\t\tMonoException *exc = mono_get_exception_argument(\"field_handle\",\n\t\t\t\"Field doesn't have an RVA\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tsize *= array->max_length;\n\tfield_data = mono_field_get_data (field_handle);\n\n\tif (size > mono_type_size (field_handle->type, &align)) {\n\t\tMonoException *exc = mono_get_exception_argument(\"field_handle\",\n\t\t\t\"Field not large enough to fill array\");\n\t\tmono_raise_exception (exc);\n\t}\n\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n#define SWAP(n) {\\\n\tguint ## n *data = (guint ## n *) mono_array_addr (array, char, 0); \\\n\tguint ## n *src = (guint ## n *) field_data; \\\n\tguint ## n *end = (guint ## n *)((char*)src + size); \\\n\\\n\tfor (; src < end; data++, src++) { \\\n\t\t*data = read ## n (src); \\\n\t} \\\n}\n\n\t/* printf (\"Initialize array with elements of %s type\\n\", klass->element_class->name); */\n\n\tswitch (type->type) {\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\t\tSWAP (16);\n\t\tbreak;\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_R4:\n\t\tSWAP (32);\n\t\tbreak;\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R8:\n\t\tSWAP (64);\n\t\tbreak;\n\tdefault:\n\t\tmemcpy (mono_array_addr (array, char, 0), field_data, size);\n\t\tbreak;\n\t}\n#else\n\tmemcpy (mono_array_addr (array, char, 0), field_data, size);\n#ifdef ARM_FPU_FPA\n\tif (klass->element_class->byval_arg.type == MONO_TYPE_R8) {\n\t\tgint i;\n\t\tdouble tmp;\n\t\tdouble *data = (double*)mono_array_addr (array, double, 0);\n\n\t\tfor (i = 0; i < size; i++, data++) {\n\t\t\treadr8 (data, &tmp);\n\t\t\t*data = tmp;\n\t\t}\n\t}\n#endif\n#endif\n}\n\nstatic gint\nves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetOffsetToStringData (void)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn offsetof (MonoString, chars);\n}\n\nstatic MonoObject *\nves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetObjectValue (MonoObject *obj)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif ((obj == NULL) || (! (obj->vtable->klass->valuetype)))\n\t\treturn obj;\n\telse\n\t\treturn mono_object_clone (obj);\n}\n\nstatic void\nves_icall_System_Runtime_CompilerServices_RuntimeHelpers_RunClassConstructor (MonoType *handle)\n{\n\tMonoClass *klass;\n\tMonoVTable *vtable;\n\n\tMONO_CHECK_ARG_NULL (handle);\n\n\tklass = mono_class_from_mono_type (handle);\n\tMONO_CHECK_ARG (handle, klass);\n\n\tvtable = mono_class_vtable_full (mono_domain_get (), klass, TRUE);\n\n\t/* This will call the type constructor */\n\tmono_runtime_class_init (vtable);\n}\n\nstatic void\nves_icall_System_Runtime_CompilerServices_RuntimeHelpers_RunModuleConstructor (MonoImage *image)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_image_check_for_module_cctor (image);\n\tif (image->has_module_cctor) {\n\t\tMonoClass *module_klass = mono_class_get (image, MONO_TOKEN_TYPE_DEF | 1);\n\t\t/*It's fine to raise the exception here*/\n\t\tmono_runtime_class_init (mono_class_vtable_full (mono_domain_get (), module_klass, TRUE));\n\t}\n}\n\nstatic MonoObject *\nves_icall_System_Object_MemberwiseClone (MonoObject *this)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_object_clone (this);\n}\n\nstatic gint32\nves_icall_System_ValueType_InternalGetHashCode (MonoObject *this, MonoArray **fields)\n{\n\tMonoClass *klass;\n\tMonoObject **values = NULL;\n\tMonoObject *o;\n\tint count = 0;\n\tgint32 result = 0;\n\tMonoClassField* field;\n\tgpointer iter;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_object_class (this);\n\n\tif (mono_class_num_fields (klass) == 0)\n\t\treturn mono_object_hash (this);\n\n\t/*\n\t * Compute the starting value of the hashcode for fields of primitive\n\t * types, and return the remaining fields in an array to the managed side.\n\t * This way, we can avoid costly reflection operations in managed code.\n\t */\n\titer = NULL;\n\twhile ((field = mono_class_get_fields (klass, &iter))) {\n\t\tif (field->type->attrs & FIELD_ATTRIBUTE_STATIC)\n\t\t\tcontinue;\n\t\tif (mono_field_is_deleted (field))\n\t\t\tcontinue;\n\t\t/* FIXME: Add more types */\n\t\tswitch (field->type->type) {\n\t\tcase MONO_TYPE_I4:\n\t\t\tresult ^= *(gint32*)((guint8*)this + field->offset);\n\t\t\tbreak;\n\t\tcase MONO_TYPE_STRING: {\n\t\t\tMonoString *s;\n\t\t\ts = *(MonoString**)((guint8*)this + field->offset);\n\t\t\tif (s != NULL)\n\t\t\t\tresult ^= mono_string_hash (s);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tif (!values)\n\t\t\t\tvalues = g_newa (MonoObject*, mono_class_num_fields (klass));\n\t\t\to = mono_field_get_value_object (mono_object_domain (this), field, this);\n\t\t\tvalues [count++] = o;\n\t\t}\n\t}\n\n\tif (values) {\n\t\tint i;\n\t\tmono_gc_wbarrier_generic_store (fields, (MonoObject*) mono_array_new (mono_domain_get (), mono_defaults.object_class, count));\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tmono_array_setref (*fields, i, values [i]);\n\t} else {\n\t\t*fields = NULL;\n\t}\n\treturn result;\n}\n\nstatic MonoBoolean\nves_icall_System_ValueType_Equals (MonoObject *this, MonoObject *that, MonoArray **fields)\n{\n\tMonoClass *klass;\n\tMonoObject **values = NULL;\n\tMonoObject *o;\n\tMonoClassField* field;\n\tgpointer iter;\n\tint count = 0;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (that);\n\n\tif (this->vtable != that->vtable)\n\t\treturn FALSE;\n\n\tklass = mono_object_class (this);\n\n\tif (klass->enumtype && mono_class_enum_basetype (klass) && mono_class_enum_basetype (klass)->type == MONO_TYPE_I4)\n\t\treturn (*(gint32*)((guint8*)this + sizeof (MonoObject)) == *(gint32*)((guint8*)that + sizeof (MonoObject)));\n\n\t/*\n\t * Do the comparison for fields of primitive type and return a result if\n\t * possible. Otherwise, return the remaining fields in an array to the \n\t * managed side. This way, we can avoid costly reflection operations in \n\t * managed code.\n\t */\n\t*fields = NULL;\n\titer = NULL;\n\twhile ((field = mono_class_get_fields (klass, &iter))) {\n\t\tif (field->type->attrs & FIELD_ATTRIBUTE_STATIC)\n\t\t\tcontinue;\n\t\tif (mono_field_is_deleted (field))\n\t\t\tcontinue;\n\t\t/* FIXME: Add more types */\n\t\tswitch (field->type->type) {\n\t\tcase MONO_TYPE_U1:\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_BOOLEAN:\n\t\t\tif (*((guint8*)this + field->offset) != *((guint8*)that + field->offset))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_CHAR:\n\t\t\tif (*(gint16*)((guint8*)this + field->offset) != *(gint16*)((guint8*)that + field->offset))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_I4:\n\t\t\tif (*(gint32*)((guint8*)this + field->offset) != *(gint32*)((guint8*)that + field->offset))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I8:\n\t\t\tif (*(gint64*)((guint8*)this + field->offset) != *(gint64*)((guint8*)that + field->offset))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\tcase MONO_TYPE_R4:\n\t\t\tif (*(float*)((guint8*)this + field->offset) != *(float*)((guint8*)that + field->offset))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\tcase MONO_TYPE_R8:\n\t\t\tif (*(double*)((guint8*)this + field->offset) != *(double*)((guint8*)that + field->offset))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\n\n\t\tcase MONO_TYPE_STRING: {\n\t\t\tMonoString *s1, *s2;\n\t\t\tguint32 s1len, s2len;\n\t\t\ts1 = *(MonoString**)((guint8*)this + field->offset);\n\t\t\ts2 = *(MonoString**)((guint8*)that + field->offset);\n\t\t\tif (s1 == s2)\n\t\t\t\tbreak;\n\t\t\tif ((s1 == NULL) || (s2 == NULL))\n\t\t\t\treturn FALSE;\n\t\t\ts1len = mono_string_length (s1);\n\t\t\ts2len = mono_string_length (s2);\n\t\t\tif (s1len != s2len)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (memcmp (mono_string_chars (s1), mono_string_chars (s2), s1len * sizeof (gunichar2)) != 0)\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tif (!values)\n\t\t\t\tvalues = g_newa (MonoObject*, mono_class_num_fields (klass) * 2);\n\t\t\to = mono_field_get_value_object (mono_object_domain (this), field, this);\n\t\t\tvalues [count++] = o;\n\t\t\to = mono_field_get_value_object (mono_object_domain (this), field, that);\n\t\t\tvalues [count++] = o;\n\t\t}\n\n\t\tif (klass->enumtype)\n\t\t\t/* enums only have one non-static field */\n\t\t\tbreak;\n\t}\n\n\tif (values) {\n\t\tint i;\n\t\tmono_gc_wbarrier_generic_store (fields, (MonoObject*) mono_array_new (mono_domain_get (), mono_defaults.object_class, count));\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tmono_array_setref (*fields, i, values [i]);\n\t\treturn FALSE;\n\t} else {\n\t\treturn TRUE;\n\t}\n}\n\nstatic MonoReflectionType *\nves_icall_System_Object_GetType (MonoObject *obj)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (obj->vtable->klass != mono_defaults.transparent_proxy_class)\n\t\treturn mono_type_get_object (mono_object_domain (obj), &obj->vtable->klass->byval_arg);\n\telse\n\t\treturn mono_type_get_object (mono_object_domain (obj), &((MonoTransparentProxy*)obj)->remote_class->proxy_class->byval_arg);\n}\n\nstatic void\nmono_type_type_from_obj (MonoReflectionType *mtype, MonoObject *obj)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmtype->type = &obj->vtable->klass->byval_arg;\n\tg_assert (mtype->type->type);\n}\n\nstatic gint32\nves_icall_ModuleBuilder_getToken (MonoReflectionModuleBuilder *mb, MonoObject *obj)\n{\n\tMONO_ARCH_SAVE_REGS;\n\t\n\tMONO_CHECK_ARG_NULL (obj);\n\t\n\treturn mono_image_create_token (mb->dynamic_image, obj, TRUE, TRUE);\n}\n\nstatic gint32\nves_icall_ModuleBuilder_getMethodToken (MonoReflectionModuleBuilder *mb,\n\t\t\t\t\tMonoReflectionMethod *method,\n\t\t\t\t\tMonoArray *opt_param_types)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (method);\n\t\n\treturn mono_image_create_method_token (\n\t\tmb->dynamic_image, (MonoObject *) method, opt_param_types);\n}\n\nstatic void\nves_icall_ModuleBuilder_WriteToFile (MonoReflectionModuleBuilder *mb, HANDLE file)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_image_create_pefile (mb, file);\n}\n\nstatic void\nves_icall_ModuleBuilder_build_metadata (MonoReflectionModuleBuilder *mb)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_image_build_metadata (mb);\n}\n\nstatic void\nves_icall_ModuleBuilder_RegisterToken (MonoReflectionModuleBuilder *mb, MonoObject *obj, guint32 token)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_image_register_token (mb->dynamic_image, token, obj);\n}\n\nstatic gboolean\nget_caller (MonoMethod *m, gint32 no, gint32 ilo, gboolean managed, gpointer data)\n{\n\tMonoMethod **dest = data;\n\n\t/* skip unmanaged frames */\n\tif (!managed)\n\t\treturn FALSE;\n\n\tif (m == *dest) {\n\t\t*dest = NULL;\n\t\treturn FALSE;\n\t}\n\tif (!(*dest)) {\n\t\t*dest = m;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean\nget_executing (MonoMethod *m, gint32 no, gint32 ilo, gboolean managed, gpointer data)\n{\n\tMonoMethod **dest = data;\n\n\t/* skip unmanaged frames */\n\tif (!managed)\n\t\treturn FALSE;\n\n\tif (!(*dest)) {\n\t\tif (!strcmp (m->klass->name_space, \"System.Reflection\"))\n\t\t\treturn FALSE;\n\t\t*dest = m;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean\nget_caller_no_reflection (MonoMethod *m, gint32 no, gint32 ilo, gboolean managed, gpointer data)\n{\n\tMonoMethod **dest = data;\n\n\t/* skip unmanaged frames */\n\tif (!managed)\n\t\treturn FALSE;\n\n\tif (m->wrapper_type != MONO_WRAPPER_NONE)\n\t\treturn FALSE;\n\n\tif (m->klass->image == mono_defaults.corlib && !strcmp (m->klass->name_space, \"System.Reflection\"))\n\t\treturn FALSE;\n\n\tif (m == *dest) {\n\t\t*dest = NULL;\n\t\treturn FALSE;\n\t}\n\tif (!(*dest)) {\n\t\t*dest = m;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic MonoReflectionType *\ntype_from_name (const char *str, MonoBoolean ignoreCase)\n{\n\tMonoType *type = NULL;\n\tMonoAssembly *assembly = NULL;\n\tMonoTypeNameParse info;\n\tchar *temp_str = g_strdup (str);\n\tgboolean type_resolve = FALSE;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t/* mono_reflection_parse_type() mangles the string */\n\tif (!mono_reflection_parse_type (temp_str, &info)) {\n\t\tmono_reflection_free_type_info (&info);\n\t\tg_free (temp_str);\n\t\treturn NULL;\n\t}\n\n\tif (info.assembly.name) {\n\t\tassembly = mono_assembly_load (&info.assembly, NULL, NULL);\n\t} else {\n\t\tMonoMethod *m = mono_method_get_last_managed ();\n\t\tMonoMethod *dest = m;\n\n\t\tmono_stack_walk_no_il (get_caller_no_reflection, &dest);\n\t\tif (!dest)\n\t\t\tdest = m;\n\n\t\t/*\n\t\t * FIXME: mono_method_get_last_managed() sometimes returns NULL, thus\n\t\t *        causing ves_icall_System_Reflection_Assembly_GetCallingAssembly()\n\t\t *        to crash.  This only seems to happen in some strange remoting\n\t\t *        scenarios and I was unable to figure out what's happening there.\n\t\t *        Dec 10, 2005 - Martin.\n\t\t */\n\n\t\tif (dest) {\n\t\t\tassembly = dest->klass->image->assembly;\n\t\t\ttype_resolve = TRUE;\n\t\t} else {\n\t\t\tg_warning (G_STRLOC);\n\t\t}\n\t}\n\n\tif (assembly) {\n\t\t/* When loading from the current assembly, AppDomain.TypeResolve will not be called yet */\n\t\ttype = mono_reflection_get_type (assembly->image, &info, ignoreCase, &type_resolve);\n\t}\n\n\tif (!info.assembly.name && !type) /* try mscorlib */\n\t\ttype = mono_reflection_get_type (NULL, &info, ignoreCase, &type_resolve);\n\n\tif (assembly && !type && type_resolve) {\n\t\ttype_resolve = FALSE; /* This will invoke TypeResolve if not done in the first 'if' */\n\t\ttype = mono_reflection_get_type (assembly->image, &info, ignoreCase, &type_resolve);\n\t}\n\n\tmono_reflection_free_type_info (&info);\n\tg_free (temp_str);\n\n\tif (!type) \n\t\treturn NULL;\n\n\treturn mono_type_get_object (mono_domain_get (), type);\n}\n\n#ifdef UNUSED\nMonoReflectionType *\nmono_type_get (const char *str)\n{\n\tchar *copy = g_strdup (str);\n\tMonoReflectionType *type = type_from_name (copy, FALSE);\n\n\tg_free (copy);\n\treturn type;\n}\n#endif\n\nstatic MonoReflectionType*\nves_icall_type_from_name (MonoString *name,\n\t\t\t  MonoBoolean throwOnError,\n\t\t\t  MonoBoolean ignoreCase)\n{\n\tchar *str = mono_string_to_utf8 (name);\n\tMonoReflectionType *type;\n\n\ttype = type_from_name (str, ignoreCase);\n\tg_free (str);\n\tif (type == NULL){\n\t\tMonoException *e = NULL;\n\t\t\n\t\tif (throwOnError)\n\t\t\te = mono_get_exception_type_load (name, NULL);\n\n\t\tmono_loader_clear_error ();\n\t\tif (e != NULL)\n\t\t\tmono_raise_exception (e);\n\t}\n\t\n\treturn type;\n}\n\n\nstatic MonoReflectionType*\nves_icall_type_from_handle (MonoType *handle)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\tMonoClass *klass = mono_class_from_mono_type (handle);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_class_init (klass);\n\treturn mono_type_get_object (domain, handle);\n}\n\nstatic MonoBoolean\nves_icall_System_Type_EqualsInternal (MonoReflectionType *type, MonoReflectionType *c)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (c && type->type && c->type)\n\t\treturn mono_metadata_type_equal (type->type, c->type);\n\telse\n\t\treturn (type == c) ? TRUE : FALSE;\n}\n\n/* System.TypeCode */\ntypedef enum {\n\tTYPECODE_EMPTY,\n\tTYPECODE_OBJECT,\n\tTYPECODE_DBNULL,\n\tTYPECODE_BOOLEAN,\n\tTYPECODE_CHAR,\n\tTYPECODE_SBYTE,\n\tTYPECODE_BYTE,\n\tTYPECODE_INT16,\n\tTYPECODE_UINT16,\n\tTYPECODE_INT32,\n\tTYPECODE_UINT32,\n\tTYPECODE_INT64,\n\tTYPECODE_UINT64,\n\tTYPECODE_SINGLE,\n\tTYPECODE_DOUBLE,\n\tTYPECODE_DECIMAL,\n\tTYPECODE_DATETIME,\n\tTYPECODE_STRING = 18\n} TypeCode;\n\nstatic guint32\nves_icall_type_GetTypeCodeInternal (MonoReflectionType *type)\n{\n\tint t = type->type->type;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->type->byref)\n\t\treturn TYPECODE_OBJECT;\n\nhandle_enum:\n\tswitch (t) {\n\tcase MONO_TYPE_VOID:\n\t\treturn TYPECODE_OBJECT;\n\tcase MONO_TYPE_BOOLEAN:\n\t\treturn TYPECODE_BOOLEAN;\n\tcase MONO_TYPE_U1:\n\t\treturn TYPECODE_BYTE;\n\tcase MONO_TYPE_I1:\n\t\treturn TYPECODE_SBYTE;\n\tcase MONO_TYPE_U2:\n\t\treturn TYPECODE_UINT16;\n\tcase MONO_TYPE_I2:\n\t\treturn TYPECODE_INT16;\n\tcase MONO_TYPE_CHAR:\n\t\treturn TYPECODE_CHAR;\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n\t\treturn TYPECODE_OBJECT;\n\tcase MONO_TYPE_U4:\n\t\treturn TYPECODE_UINT32;\n\tcase MONO_TYPE_I4:\n\t\treturn TYPECODE_INT32;\n\tcase MONO_TYPE_U8:\n\t\treturn TYPECODE_UINT64;\n\tcase MONO_TYPE_I8:\n\t\treturn TYPECODE_INT64;\n\tcase MONO_TYPE_R4:\n\t\treturn TYPECODE_SINGLE;\n\tcase MONO_TYPE_R8:\n\t\treturn TYPECODE_DOUBLE;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (type->type->data.klass->enumtype) {\n\t\t\tt = mono_class_enum_basetype (type->type->data.klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tMonoClass *k =  type->type->data.klass;\n\t\t\tif (strcmp (k->name_space, \"System\") == 0) {\n\t\t\t\tif (strcmp (k->name, \"Decimal\") == 0)\n\t\t\t\t\treturn TYPECODE_DECIMAL;\n\t\t\t\telse if (strcmp (k->name, \"DateTime\") == 0)\n\t\t\t\t\treturn TYPECODE_DATETIME;\n\t\t\t}\n\t\t}\n\t\treturn TYPECODE_OBJECT;\n\tcase MONO_TYPE_STRING:\n\t\treturn TYPECODE_STRING;\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn TYPECODE_OBJECT;\n\tcase MONO_TYPE_CLASS:\n\t\t{\n\t\t\tMonoClass *k =  type->type->data.klass;\n\t\t\tif (strcmp (k->name_space, \"System\") == 0) {\n\t\t\t\tif (strcmp (k->name, \"DBNull\") == 0)\n\t\t\t\t\treturn TYPECODE_DBNULL;\n\t\t\t}\n\t\t}\n\t\treturn TYPECODE_OBJECT;\n\tcase MONO_TYPE_GENERICINST:\n\t\treturn TYPECODE_OBJECT;\n\tdefault:\n\t\tg_error (\"type 0x%02x not handled in GetTypeCode()\", t);\n\t}\n\treturn 0;\n}\n\nstatic guint32\nves_icall_type_is_subtype_of (MonoReflectionType *type, MonoReflectionType *c, MonoBoolean check_interfaces)\n{\n\tMonoDomain *domain; \n\tMonoClass *klass;\n\tMonoClass *klassc;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_assert (type != NULL);\n\t\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\n\tif (!c) /* FIXME: dont know what do do here */\n\t\treturn 0;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tklassc = mono_class_from_mono_type (c->type);\n\n\tif (type->type->byref)\n\t\treturn klassc == mono_defaults.object_class;\n\n\treturn mono_class_is_subclass_of (klass, klassc, check_interfaces);\n}\n\nstatic guint32\nves_icall_type_is_assignable_from (MonoReflectionType *type, MonoReflectionType *c)\n{\n\tMonoDomain *domain; \n\tMonoClass *klass;\n\tMonoClass *klassc;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_assert (type != NULL);\n\t\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tklassc = mono_class_from_mono_type (c->type);\n\n\tif (type->type->byref && !c->type->byref)\n\t\treturn FALSE;\n\n\treturn mono_class_is_assignable_from (klass, klassc);\n}\n\nstatic guint32\nves_icall_type_IsInstanceOfType (MonoReflectionType *type, MonoObject *obj)\n{\n\tMonoClass *klass = mono_class_from_mono_type (type->type);\n\treturn mono_object_isinst (obj, klass) != NULL;\n}\n\nstatic guint32\nves_icall_get_attributes (MonoReflectionType *type)\n{\n\tMonoClass *klass = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn klass->flags;\n}\n\nstatic MonoReflectionMarshal*\nves_icall_System_Reflection_FieldInfo_GetUnmanagedMarshal (MonoReflectionField *field)\n{\n\tMonoClass *klass = field->field->parent;\n\tMonoMarshalType *info;\n\tint i;\n\n\tif (klass->generic_container ||\n\t    (klass->generic_class && klass->generic_class->context.class_inst->is_open))\n\t\treturn NULL;\n\n\tinfo = mono_marshal_load_type_info (klass);\n\n\tfor (i = 0; i < info->num_fields; ++i) {\n\t\tif (info->fields [i].field == field->field) {\n\t\t\tif (!info->fields [i].mspec)\n\t\t\t\treturn NULL;\n\t\t\telse\n\t\t\t\treturn mono_reflection_marshal_from_marshal_spec (field->object.vtable->domain, klass, info->fields [i].mspec);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic MonoReflectionField*\nves_icall_System_Reflection_FieldInfo_internal_from_handle_type (MonoClassField *handle, MonoType *type)\n{\n\tgboolean found = FALSE;\n\tMonoClass *klass;\n\tMonoClass *k;\n\n\tg_assert (handle);\n\n\tif (!type) {\n\t\tklass = handle->parent;\n\t} else {\n\t\tklass = mono_class_from_mono_type (type);\n\n\t\t/* Check that the field belongs to the class */\n\t\tfor (k = klass; k; k = k->parent) {\n\t\t\tif (k == handle->parent) {\n\t\t\t\tfound = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\t/* The managed code will throw the exception */\n\t\t\treturn NULL;\n\t}\n\n\treturn mono_field_get_object (mono_domain_get (), klass, handle);\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_FieldInfo_GetTypeModifiers (MonoReflectionField *field, MonoBoolean optional)\n{\n\tMonoType *type = field->field->type;\n\n\treturn type_array_from_modifiers (field->field->parent->image, type, optional);\n}\n\nstatic void\nves_icall_get_method_info (MonoMethod *method, MonoMethodInfo *info)\n{\n\tMonoDomain *domain = mono_domain_get ();\n\tMonoMethodSignature* sig;\n\tMONO_ARCH_SAVE_REGS;\n\n\tsig = mono_method_signature (method);\n\tif (!sig) {\n\t\tg_assert (mono_loader_get_last_error ());\n\t\tmono_raise_exception (mono_loader_error_prepare_exception (mono_loader_get_last_error ()));\n\t}\n\n\tMONO_STRUCT_SETREF (info, parent, mono_type_get_object (domain, &method->klass->byval_arg));\n\tMONO_STRUCT_SETREF (info, ret, mono_type_get_object (domain, sig->ret));\n\tinfo->attrs = method->flags;\n\tinfo->implattrs = method->iflags;\n\tif (sig->call_convention == MONO_CALL_DEFAULT)\n\t\tinfo->callconv = sig->sentinelpos >= 0 ? 2 : 1;\n\telse {\n\t\tif (sig->call_convention == MONO_CALL_VARARG || sig->sentinelpos >= 0)\n\t\t\tinfo->callconv = 2;\n\t\telse\n\t\t\tinfo->callconv = 1;\n\t}\n\tinfo->callconv |= (sig->hasthis << 5) | (sig->explicit_this << 6); \n}\n\nstatic MonoArray*\nves_icall_get_parameter_info (MonoMethod *method, MonoReflectionMethod *member)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\n\treturn mono_param_get_objects_internal (domain, method, member->reftype ? mono_class_from_mono_type (member->reftype->type) : NULL);\n}\n\nstatic MonoReflectionMarshal*\nves_icall_System_MonoMethodInfo_get_retval_marshal (MonoMethod *method)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\tMonoReflectionMarshal* res = NULL;\n\tMonoMarshalSpec **mspecs;\n\tint i;\n\n\tmspecs = g_new (MonoMarshalSpec*, mono_method_signature (method)->param_count + 1);\n\tmono_method_get_marshal_info (method, mspecs);\n\n\tif (mspecs [0])\n\t\tres = mono_reflection_marshal_from_marshal_spec (domain, method->klass, mspecs [0]);\n\t\t\n\tfor (i = mono_method_signature (method)->param_count; i >= 0; i--)\n\t\tif (mspecs [i])\n\t\t\tmono_metadata_free_marshal_spec (mspecs [i]);\n\tg_free (mspecs);\n\n\treturn res;\n}\n\nstatic gint32\nves_icall_MonoField_GetFieldOffset (MonoReflectionField *field)\n{\n\treturn field->field->offset - sizeof (MonoObject);\n}\n\nstatic MonoReflectionType*\nves_icall_MonoField_GetParentType (MonoReflectionField *field, MonoBoolean declaring)\n{\n\tMonoClass *parent;\n\tMONO_ARCH_SAVE_REGS;\n\n\tparent = declaring? field->field->parent: field->klass;\n\n\treturn mono_type_get_object (mono_object_domain (field), &parent->byval_arg);\n}\n\nstatic MonoObject *\nves_icall_MonoField_GetValueInternal (MonoReflectionField *field, MonoObject *obj)\n{\t\n\tMonoObject *o;\n\tMonoClassField *cf = field->field;\n\tMonoClass *klass;\n\tMonoVTable *vtable;\n\tMonoType *t;\n\tMonoDomain *domain = mono_object_domain (field); \n\tgchar *v;\n\tgboolean is_static = FALSE;\n\tgboolean is_ref = FALSE;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (field->klass->image->assembly->ref_only)\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\n\t\t\t\t\t\"It is illegal to get the value on a field on a type loaded using the ReflectionOnly methods.\"));\n\t\n\tif (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\tmono_security_core_clr_ensure_reflection_access_field (cf);\n\n\tmono_class_init (field->klass);\n\n\tif (cf->type->attrs & FIELD_ATTRIBUTE_STATIC)\n\t\tis_static = TRUE;\n\n\tif (obj && !is_static) {\n\t\t/* Check that the field belongs to the object */\n\t\tgboolean found = FALSE;\n\t\tMonoClass *k;\n\n\t\tfor (k = obj->vtable->klass; k; k = k->parent) {\n\t\t\tif (k == cf->parent) {\n\t\t\t\tfound = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tchar *msg = g_strdup_printf (\"Field '%s' defined on type '%s' is not a field on the target object which is of type '%s'.\", mono_field_get_name (cf), cf->parent->name, obj->vtable->klass->name);\n\t\t\tMonoException *ex = mono_get_exception_argument (NULL, msg);\n\t\t\tg_free (msg);\n\t\t\tmono_raise_exception (ex);\n\t\t}\n\t}\n\n\tt = mono_type_get_underlying_type (cf->type);\n\tswitch (t->type) {\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_ARRAY:\n\tcase MONO_TYPE_SZARRAY:\n\t\tis_ref = TRUE;\n\t\tbreak;\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_VALUETYPE:\n\t\tis_ref = t->byref;\n\t\tbreak;\n\tcase MONO_TYPE_GENERICINST:\n\t\tif (mono_type_generic_inst_is_valuetype (t)) {\n\t\t\tis_ref = t->byref;\n\t\t} else {\n\t\t\tis_ref = TRUE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tg_error (\"type 0x%x not handled in \"\n\t\t\t \"ves_icall_Monofield_GetValue\", t->type);\n\t\treturn NULL;\n\t}\n\n\tvtable = NULL;\n\tif (is_static) {\n\t\tvtable = mono_class_vtable_full (domain, cf->parent, TRUE);\n\t\tif (!vtable->initialized && !(cf->type->attrs & FIELD_ATTRIBUTE_LITERAL))\n\t\t\tmono_runtime_class_init (vtable);\n\t}\n\t\n\tif (is_ref) {\n\t\tif (is_static) {\n\t\t\tmono_field_static_get_value (vtable, cf, &o);\n\t\t} else {\n\t\t\tmono_field_get_value (obj, cf, &o);\n\t\t}\n\t\treturn o;\n\t}\n\n\tif (mono_class_is_nullable (mono_class_from_mono_type (cf->type))) {\n\t\tMonoClass *nklass = mono_class_from_mono_type (cf->type);\n\t\tguint8 *buf;\n\n\t\t/* Convert the Nullable structure into a boxed vtype */\n\t\tif (is_static)\n\t\t\tbuf = (guint8*)vtable->data + cf->offset;\n\t\telse\n\t\t\tbuf = (guint8*)obj + cf->offset;\n\n\t\treturn mono_nullable_box (buf, nklass);\n\t}\n\n\t/* boxed value type */\n\tklass = mono_class_from_mono_type (cf->type);\n\to = mono_object_new (domain, klass);\n\tv = ((gchar *) o) + sizeof (MonoObject);\n\tif (is_static) {\n\t\tmono_field_static_get_value (vtable, cf, v);\n\t} else {\n\t\tmono_field_get_value (obj, cf, v);\n\t}\n\n\treturn o;\n}\n\nstatic void\nves_icall_MonoField_SetValueInternal (MonoReflectionField *field, MonoObject *obj, MonoObject *value)\n{\n\tMonoClassField *cf = field->field;\n\tgchar *v;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (field->klass->image->assembly->ref_only)\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\n\t\t\t\t\t\"It is illegal to set the value on a field on a type loaded using the ReflectionOnly methods.\"));\n\n\tif (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\tmono_security_core_clr_ensure_reflection_access_field (cf);\n\n\tv = (gchar *) value;\n\tif (!cf->type->byref) {\n\t\tswitch (cf->type->type) {\n\t\tcase MONO_TYPE_U1:\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_BOOLEAN:\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_U:\n\t\tcase MONO_TYPE_I:\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_I4:\n\t\tcase MONO_TYPE_R4:\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I8:\n\t\tcase MONO_TYPE_R8:\n\t\tcase MONO_TYPE_VALUETYPE:\n\t\t\tif (v != NULL)\n\t\t\t\tv += sizeof (MonoObject);\n\t\t\tbreak;\n\t\tcase MONO_TYPE_STRING:\n\t\tcase MONO_TYPE_OBJECT:\n\t\tcase MONO_TYPE_CLASS:\n\t\tcase MONO_TYPE_ARRAY:\n\t\tcase MONO_TYPE_SZARRAY:\n\t\t\t/* Do nothing */\n\t\t\tbreak;\n\t\tcase MONO_TYPE_GENERICINST: {\n\t\t\tMonoGenericClass *gclass = cf->type->data.generic_class;\n\t\t\tg_assert (!gclass->context.class_inst->is_open);\n\n\t\t\tif (mono_class_is_nullable (mono_class_from_mono_type (cf->type))) {\n\t\t\t\tMonoClass *nklass = mono_class_from_mono_type (cf->type);\n\t\t\t\tMonoObject *nullable;\n\n\t\t\t\t/* \n\t\t\t\t * Convert the boxed vtype into a Nullable structure.\n\t\t\t\t * This is complicated by the fact that Nullables have\n\t\t\t\t * a variable structure.\n\t\t\t\t */\n\t\t\t\tnullable = mono_object_new (mono_domain_get (), nklass);\n\n\t\t\t\tmono_nullable_init (mono_object_unbox (nullable), value, nklass);\n\n\t\t\t\tv = mono_object_unbox (nullable);\n\t\t\t}\n\t\t\telse \n\t\t\t\tif (gclass->container_class->valuetype && (v != NULL))\n\t\t\t\t\tv += sizeof (MonoObject);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tg_error (\"type 0x%x not handled in \"\n\t\t\t\t \"ves_icall_FieldInfo_SetValueInternal\", cf->type->type);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (cf->type->attrs & FIELD_ATTRIBUTE_STATIC) {\n\t\tMonoVTable *vtable = mono_class_vtable_full (mono_object_domain (field), cf->parent, TRUE);\n\t\tif (!vtable->initialized)\n\t\t\tmono_runtime_class_init (vtable);\n\t\tmono_field_static_set_value (vtable, cf, v);\n\t} else {\n\t\tmono_field_set_value (obj, cf, v);\n\t}\n}\n\nstatic MonoObject *\nves_icall_MonoField_GetRawConstantValue (MonoReflectionField *this)\n{\t\n\tMonoObject *o = NULL;\n\tMonoClassField *field = this->field;\n\tMonoClass *klass;\n\tMonoDomain *domain = mono_object_domain (this); \n\tgchar *v;\n\tMonoTypeEnum def_type;\n\tconst char *def_value;\n\n\tMONO_ARCH_SAVE_REGS;\n\t\n\tmono_class_init (field->parent);\n\n\tif (!(field->type->attrs & FIELD_ATTRIBUTE_HAS_DEFAULT))\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (NULL));\n\n\tif (field->parent->image->dynamic) {\n\t\t/* FIXME: */\n\t\tg_assert_not_reached ();\n\t}\n\n\tdef_value = mono_class_get_field_default_value (field, &def_type);\n\n\tswitch (def_type) {\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_R8: {\n\t\tMonoType *t;\n\n\t\t/* boxed value type */\n\t\tt = g_new0 (MonoType, 1);\n\t\tt->type = def_type;\n\t\tklass = mono_class_from_mono_type (t);\n\t\tg_free (t);\n\t\to = mono_object_new (domain, klass);\n\t\tv = ((gchar *) o) + sizeof (MonoObject);\n\t\tmono_get_constant_value_from_blob (domain, def_type, def_value, v);\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_CLASS:\n\t\tmono_get_constant_value_from_blob (domain, def_type, def_value, &o);\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\treturn o;\n}\n\nstatic MonoReflectionType*\nves_icall_MonoGenericMethod_get_ReflectedType (MonoReflectionGenericMethod *rmethod)\n{\n\tMonoMethod *method = rmethod->method.method;\n\n\treturn mono_type_get_object (mono_object_domain (rmethod), &method->klass->byval_arg);\n}\n\n/* From MonoProperty.cs */\ntypedef enum {\n\tPInfo_Attributes = 1,\n\tPInfo_GetMethod  = 1 << 1,\n\tPInfo_SetMethod  = 1 << 2,\n\tPInfo_ReflectedType = 1 << 3,\n\tPInfo_DeclaringType = 1 << 4,\n\tPInfo_Name = 1 << 5\n} PInfo;\n\nstatic void\nves_icall_get_property_info (MonoReflectionProperty *property, MonoPropertyInfo *info, PInfo req_info)\n{\n\tMonoDomain *domain = mono_object_domain (property); \n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif ((req_info & PInfo_ReflectedType) != 0)\n\t\tMONO_STRUCT_SETREF (info, parent, mono_type_get_object (domain, &property->klass->byval_arg));\n\telse if ((req_info & PInfo_DeclaringType) != 0)\n\t\tMONO_STRUCT_SETREF (info, parent, mono_type_get_object (domain, &property->property->parent->byval_arg));\n\n\tif ((req_info & PInfo_Name) != 0)\n\t\tMONO_STRUCT_SETREF (info, name, mono_string_new (domain, property->property->name));\n\n\tif ((req_info & PInfo_Attributes) != 0)\n\t\tinfo->attrs = property->property->attrs;\n\n\tif ((req_info & PInfo_GetMethod) != 0)\n\t\tMONO_STRUCT_SETREF (info, get, property->property->get ?\n\t\t\t\t\t\t\tmono_method_get_object (domain, property->property->get, property->klass): NULL);\n\t\n\tif ((req_info & PInfo_SetMethod) != 0)\n\t\tMONO_STRUCT_SETREF (info, set, property->property->set ?\n\t\t\t\t\t\t\tmono_method_get_object (domain, property->property->set, property->klass): NULL);\n\t/* \n\t * There may be other methods defined for properties, though, it seems they are not exposed \n\t * in the reflection API \n\t */\n}\n\nstatic void\nves_icall_get_event_info (MonoReflectionMonoEvent *event, MonoEventInfo *info)\n{\n\tMonoDomain *domain = mono_object_domain (event); \n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_STRUCT_SETREF (info, reflected_type, mono_type_get_object (domain, &event->klass->byval_arg));\n\tMONO_STRUCT_SETREF (info, declaring_type, mono_type_get_object (domain, &event->event->parent->byval_arg));\n\n\tMONO_STRUCT_SETREF (info, name, mono_string_new (domain, event->event->name));\n\tinfo->attrs = event->event->attrs;\n\tMONO_STRUCT_SETREF (info, add_method, event->event->add ? mono_method_get_object (domain, event->event->add, NULL): NULL);\n\tMONO_STRUCT_SETREF (info, remove_method, event->event->remove ? mono_method_get_object (domain, event->event->remove, NULL): NULL);\n\tMONO_STRUCT_SETREF (info, raise_method, event->event->raise ? mono_method_get_object (domain, event->event->raise, NULL): NULL);\n\n\tif (event->event->other) {\n\t\tint i, n = 0;\n\t\twhile (event->event->other [n])\n\t\t\tn++;\n\t\tMONO_STRUCT_SETREF (info, other_methods, mono_array_new (domain, mono_defaults.method_info_class, n));\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tmono_array_setref (info->other_methods, i, mono_method_get_object (domain, event->event->other [i], NULL));\n\t}\t\t\n}\n\nstatic MonoArray*\nves_icall_Type_GetInterfaces (MonoReflectionType* type)\n{\n\tMonoError error;\n\tMonoDomain *domain = mono_object_domain (type); \n\tMonoArray *intf;\n\tGPtrArray *ifaces = NULL;\n\tint i;\n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\tMonoClass *parent;\n\tMonoBitSet *slots;\n\tMonoGenericContext *context = NULL;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (class->generic_class && class->generic_class->context.class_inst->is_open) {\n\t\tcontext = mono_class_get_context (class);\n\t\tclass = class->generic_class->container_class;\n\t}\n\n\tmono_class_setup_vtable (class);\n\n\tslots = mono_bitset_new (class->max_interface_id + 1, 0);\n\n\tfor (parent = class; parent; parent = parent->parent) {\n\t\tGPtrArray *tmp_ifaces = mono_class_get_implemented_interfaces (parent, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tmono_bitset_free (slots);\n\t\t\tmono_error_raise_exception (&error);\n\t\t\treturn NULL;\n\t\t} else if (tmp_ifaces) {\n\t\t\tfor (i = 0; i < tmp_ifaces->len; ++i) {\n\t\t\t\tMonoClass *ic = g_ptr_array_index (tmp_ifaces, i);\n\n\t\t\t\tif (mono_bitset_test (slots, ic->interface_id))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmono_bitset_set (slots, ic->interface_id);\n\t\t\t\tif (ifaces == NULL)\n\t\t\t\t\tifaces = g_ptr_array_new ();\n\t\t\t\tg_ptr_array_add (ifaces, ic);\n\t\t\t}\n\t\t\tg_ptr_array_free (tmp_ifaces, TRUE);\n\t\t}\n\t}\n\tmono_bitset_free (slots);\n\n\tif (!ifaces)\n\t\treturn mono_array_new_cached (domain, mono_defaults.monotype_class, 0);\n\t\t\n\tintf = mono_array_new_cached (domain, mono_defaults.monotype_class, ifaces->len);\n\tfor (i = 0; i < ifaces->len; ++i) {\n\t\tMonoClass *ic = g_ptr_array_index (ifaces, i);\n\t\tMonoType *ret = &ic->byval_arg, *inflated = NULL;\n\t\tif (context && ic->generic_class && ic->generic_class->context.class_inst->is_open)\n\t\t\tinflated = ret = mono_class_inflate_generic_type (ret, context);\n\t\t\n\t\tmono_array_setref (intf, i, mono_type_get_object (domain, ret));\n\t\tif (inflated)\n\t\t\tmono_metadata_free_type (inflated);\n\t}\n\tg_ptr_array_free (ifaces, TRUE);\n\n\treturn intf;\n}\n\nstatic void\nves_icall_Type_GetInterfaceMapData (MonoReflectionType *type, MonoReflectionType *iface, MonoArray **targets, MonoArray **methods)\n{\n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\tMonoClass *iclass = mono_class_from_mono_type (iface->type);\n\tMonoReflectionMethod *member;\n\tMonoMethod* method;\n\tgpointer iter;\n\tint i = 0, len, ioffset;\n\tMonoDomain *domain;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_class_setup_vtable (class);\n\n\t/* type doesn't implement iface: the exception is thrown in managed code */\n\tif (! MONO_CLASS_IMPLEMENTS_INTERFACE (class, iclass->interface_id))\n\t\t\treturn;\n\n\tlen = mono_class_num_methods (iclass);\n\tioffset = mono_class_interface_offset (class, iclass);\n\tdomain = mono_object_domain (type);\n\tmono_gc_wbarrier_generic_store (targets, (MonoObject*) mono_array_new (domain, mono_defaults.method_info_class, len));\n\tmono_gc_wbarrier_generic_store (methods, (MonoObject*) mono_array_new (domain, mono_defaults.method_info_class, len));\n\titer = NULL;\n\twhile ((method = mono_class_get_methods (iclass, &iter))) {\n\t\tmember = mono_method_get_object (domain, method, iclass);\n\t\tmono_array_setref (*methods, i, member);\n\t\tmember = mono_method_get_object (domain, class->vtable [i + ioffset], class);\n\t\tmono_array_setref (*targets, i, member);\n\t\t\n\t\ti ++;\n\t}\n}\n\nstatic void\nves_icall_Type_GetPacking (MonoReflectionType *type, guint32 *packing, guint32 *size)\n{\n\tMonoClass *klass = mono_class_from_mono_type (type->type);\n\n\tif (klass->image->dynamic) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)type;\n\t\t*packing = tb->packing_size;\n\t\t*size = tb->class_size;\n\t} else {\n\t\tmono_metadata_packing_from_typedef (klass->image, klass->type_token, packing, size);\n\t}\n}\n\nstatic MonoReflectionType*\nves_icall_MonoType_GetElementType (MonoReflectionType *type)\n{\n\tMonoClass *class;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!type->type->byref && type->type->type == MONO_TYPE_SZARRAY)\n\t\treturn mono_type_get_object (mono_object_domain (type), &type->type->data.klass->byval_arg);\n\n\tclass = mono_class_from_mono_type (type->type);\n\n\t// GetElementType should only return a type for:\n\t// Array Pointer PassedByRef\n\tif (type->type->byref)\n\t\treturn mono_type_get_object (mono_object_domain (type), &class->byval_arg);\n\telse if (class->element_class && MONO_CLASS_IS_ARRAY (class))\n\t\treturn mono_type_get_object (mono_object_domain (type), &class->element_class->byval_arg);\n\telse if (class->element_class && type->type->type == MONO_TYPE_PTR)\n\t\treturn mono_type_get_object (mono_object_domain (type), &class->element_class->byval_arg);\n\telse\n\t\treturn NULL;\n}\n\nstatic MonoReflectionType*\nves_icall_get_type_parent (MonoReflectionType *type)\n{\n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn class->parent ? mono_type_get_object (mono_object_domain (type), &class->parent->byval_arg): NULL;\n}\n\nstatic MonoBoolean\nves_icall_type_ispointer (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn type->type->type == MONO_TYPE_PTR;\n}\n\nstatic MonoBoolean\nves_icall_type_isprimitive (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn (!type->type->byref && (((type->type->type >= MONO_TYPE_BOOLEAN) && (type->type->type <= MONO_TYPE_R8)) || (type->type->type == MONO_TYPE_I) || (type->type->type == MONO_TYPE_U)));\n}\n\nstatic MonoBoolean\nves_icall_type_isbyref (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn type->type->byref;\n}\n\nstatic MonoBoolean\nves_icall_type_iscomobject (MonoReflectionType *type)\n{\n\tMonoClass *klass = mono_class_from_mono_type (type->type);\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn (klass && klass->is_com_object);\n}\n\nstatic MonoReflectionModule*\nves_icall_MonoType_get_Module (MonoReflectionType *type)\n{\n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_module_get_object (mono_object_domain (type), class->image);\n}\n\nstatic MonoReflectionAssembly*\nves_icall_MonoType_get_Assembly (MonoReflectionType *type)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_assembly_get_object (domain, class->image->assembly);\n}\n\nstatic MonoReflectionType*\nves_icall_MonoType_get_DeclaringType (MonoReflectionType *type)\n{\n\tMonoDomain *domain = mono_domain_get ();\n\tMonoClass *class;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->type->byref)\n\t\treturn NULL;\n\tif (type->type->type == MONO_TYPE_VAR)\n\t\tclass = mono_type_get_generic_param_owner (type->type)->owner.klass;\n\telse if (type->type->type == MONO_TYPE_MVAR)\n\t\tclass = mono_type_get_generic_param_owner (type->type)->owner.method->klass;\n\telse\n\t\tclass = mono_class_from_mono_type (type->type)->nested_in;\n\n\treturn class ? mono_type_get_object (domain, &class->byval_arg) : NULL;\n}\n\nstatic MonoReflectionType*\nves_icall_MonoType_get_UnderlyingSystemType (MonoReflectionType *type)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (class->enumtype && mono_class_enum_basetype (class)) /* types that are modified typebuilders may not have enum_basetype set */\n\t\treturn mono_type_get_object (domain, mono_class_enum_basetype (class));\n\telse if (class->element_class)\n\t\treturn mono_type_get_object (domain, &class->element_class->byval_arg);\n\telse\n\t\treturn NULL;\n}\n\nstatic MonoString*\nves_icall_MonoType_get_Name (MonoReflectionType *type)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->type->byref) {\n\t\tchar *n = g_strdup_printf (\"%s&\", class->name);\n\t\tMonoString *res = mono_string_new (domain, n);\n\n\t\tg_free (n);\n\n\t\treturn res;\n\t} else {\n\t\treturn mono_string_new (domain, class->name);\n\t}\n}\n\nstatic MonoString*\nves_icall_MonoType_get_Namespace (MonoReflectionType *type)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\twhile (class->nested_in)\n\t\tclass = class->nested_in;\n\n\tif (class->name_space [0] == '\\0')\n\t\treturn NULL;\n\telse\n\t\treturn mono_string_new (domain, class->name_space);\n}\n\nstatic gint32\nves_icall_MonoType_GetArrayRank (MonoReflectionType *type)\n{\n\tMonoClass *class;\n\n\tif (type->type->type != MONO_TYPE_ARRAY && type->type->type != MONO_TYPE_SZARRAY)\n\t\tmono_raise_exception (mono_get_exception_argument (\"type\", \"Type must be an array type\"));\n\n\tclass = mono_class_from_mono_type (type->type);\n\treturn class->rank;\n}\n\nstatic MonoArray*\nves_icall_MonoType_GetGenericArguments (MonoReflectionType *type)\n{\n\tMonoArray *res;\n\tMonoClass *klass, *pklass;\n\tMonoDomain *domain = mono_object_domain (type);\n\tMonoVTable *array_vtable = mono_class_vtable_full (domain, mono_array_class_get_cached (mono_defaults.systemtype_class, 1), TRUE);\n\tint i;\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (type->type);\n\n\tif (klass->generic_container) {\n\t\tMonoGenericContainer *container = klass->generic_container;\n\t\tres = mono_array_new_specific (array_vtable, container->type_argc);\n\t\tfor (i = 0; i < container->type_argc; ++i) {\n\t\t\tpklass = mono_class_from_generic_parameter (mono_generic_container_get_param (container, i), klass->image, FALSE);\n\t\t\tmono_array_setref (res, i, mono_type_get_object (domain, &pklass->byval_arg));\n\t\t}\n\t} else if (klass->generic_class) {\n\t\tMonoGenericInst *inst = klass->generic_class->context.class_inst;\n\t\tres = mono_array_new_specific (array_vtable, inst->type_argc);\n\t\tfor (i = 0; i < inst->type_argc; ++i)\n\t\t\tmono_array_setref (res, i, mono_type_get_object (domain, inst->type_argv [i]));\n\t} else {\n\t\tres = mono_array_new_specific (array_vtable, 0);\n\t}\n\treturn res;\n}\n\nstatic gboolean\nves_icall_Type_get_IsGenericTypeDefinition (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!IS_MONOTYPE (type))\n\t\treturn FALSE;\n\n\tif (type->type->byref)\n\t\treturn FALSE;\n\n\tklass = mono_class_from_mono_type (type->type);\n\n\treturn klass->generic_container != NULL;\n}\n\nstatic MonoReflectionType*\nves_icall_Type_GetGenericTypeDefinition_impl (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->type->byref)\n\t\treturn NULL;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tif (klass->generic_container) {\n\t\treturn type; /* check this one */\n\t}\n\tif (klass->generic_class) {\n\t\tMonoClass *generic_class = klass->generic_class->container_class;\n\n\t\tif (generic_class->wastypebuilder && generic_class->reflection_info)\n\t\t\treturn generic_class->reflection_info;\n\t\telse\n\t\t\treturn mono_type_get_object (mono_object_domain (type), &generic_class->byval_arg);\n\t}\n\treturn NULL;\n}\n\nstatic MonoReflectionType*\nves_icall_Type_MakeGenericType (MonoReflectionType *type, MonoArray *type_array)\n{\n\tMonoClass *class;\n\tMonoType *geninst, **types;\n\tint i, count;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tcount = mono_array_length (type_array);\n\ttypes = g_new0 (MonoType *, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *t = mono_array_get (type_array, gpointer, i);\n\t\ttypes [i] = t->type;\n\t}\n\n\tgeninst = mono_reflection_bind_generic_parameters (type, count, types);\n\tg_free (types);\n\tif (!geninst)\n\t\treturn NULL;\n\n\tclass = mono_class_from_mono_type (geninst);\n\n\t/*we might inflate to the GTD*/\n\tif (class->generic_class && !mono_verifier_class_is_valid_generic_instantiation (class))\n\t\tmono_raise_exception (mono_get_exception_argument (\"method\", \"Invalid generic arguments\"));\n\n\treturn mono_type_get_object (mono_object_domain (type), geninst);\n}\n\nstatic gboolean\nves_icall_Type_get_IsGenericInstance (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->type->byref)\n\t\treturn FALSE;\n\n\tklass = mono_class_from_mono_type (type->type);\n\treturn klass->generic_class != NULL;\n}\n\nstatic gboolean\nves_icall_Type_get_IsGenericType (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!IS_MONOTYPE (type))\n\t\treturn FALSE;\n\n\tif (type->type->byref)\n\t\treturn FALSE;\n\n\tklass = mono_class_from_mono_type (type->type);\n\treturn klass->generic_class != NULL || klass->generic_container != NULL;\n}\n\nstatic gint32\nves_icall_Type_GetGenericParameterPosition (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!IS_MONOTYPE (type))\n\t\treturn -1;\n\n\tif (is_generic_parameter (type->type))\n\t\treturn mono_type_get_generic_param_num (type->type);\n\treturn -1;\n}\n\nstatic GenericParameterAttributes\nves_icall_Type_GetGenericParameterAttributes (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_assert (IS_MONOTYPE (type));\n\tg_assert (is_generic_parameter (type->type));\n\treturn mono_generic_param_info (type->type->data.generic_param)->flags;\n}\n\nstatic MonoArray *\nves_icall_Type_GetGenericParameterConstraints (MonoReflectionType *type)\n{\n\tMonoGenericParamInfo *param_info;\n\tMonoDomain *domain;\n\tMonoClass **ptr;\n\tMonoArray *res;\n\tint i, count;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_assert (IS_MONOTYPE (type));\n\n\tdomain = mono_object_domain (type);\n\tparam_info = mono_generic_param_info (type->type->data.generic_param);\n\tfor (count = 0, ptr = param_info->constraints; ptr && *ptr; ptr++, count++)\n\t\t;\n\n\tres = mono_array_new (domain, mono_defaults.monotype_class, count);\n\tfor (i = 0; i < count; i++)\n\t\tmono_array_setref (res, i, mono_type_get_object (domain, &param_info->constraints [i]->byval_arg));\n\n\n\treturn res;\n}\n\nstatic MonoBoolean\nves_icall_MonoType_get_IsGenericParameter (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\treturn is_generic_parameter (type->type);\n}\n\nstatic MonoBoolean\nves_icall_TypeBuilder_get_IsGenericParameter (MonoReflectionTypeBuilder *tb)\n{\n\tMONO_ARCH_SAVE_REGS;\n\treturn is_generic_parameter (tb->type.type);\n}\n\nstatic void\nves_icall_EnumBuilder_setup_enum_type (MonoReflectionType *enumtype,\n\t\t\t\t\t\t\t\t\t   MonoReflectionType *t)\n{\n\tenumtype->type = t->type;\n}\n\nstatic MonoReflectionMethod*\nves_icall_MonoType_GetCorrespondingInflatedMethod (MonoReflectionType *type, \n                                                   MonoReflectionMethod* generic)\n{\n\tMonoDomain *domain; \n\tMonoClass *klass;\n\tMonoMethod *method;\n\tgpointer iter;\n\t\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\n\tklass = mono_class_from_mono_type (type->type);\n\n\titer = NULL;\n\twhile ((method = mono_class_get_methods (klass, &iter))) {\n                if (method->token == generic->method->token)\n                        return mono_method_get_object (domain, method, klass);\n        }\n\n        return NULL;\n}\n\n\n\nstatic MonoReflectionMethod *\nves_icall_MonoType_get_DeclaringMethod (MonoReflectionType *ref_type)\n{\n\tMonoMethod *method;\n\tMonoType *type = ref_type->type;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->byref || (type->type != MONO_TYPE_MVAR && type->type != MONO_TYPE_VAR))\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\"DeclaringMethod can only be used on generic arguments\"));\n\tif (type->type == MONO_TYPE_VAR)\n\t\treturn NULL;\n\n\tmethod = mono_type_get_generic_param_owner (type)->owner.method;\n\tg_assert (method);\n\treturn mono_method_get_object (mono_object_domain (ref_type), method, method->klass);\n}\n\nstatic MonoReflectionDllImportAttribute*\nves_icall_MonoMethod_GetDllImportAttribute (MonoMethod *method)\n{\n\tstatic MonoClass *DllImportAttributeClass = NULL;\n\tMonoDomain *domain = mono_domain_get ();\n\tMonoReflectionDllImportAttribute *attr;\n\tMonoImage *image = method->klass->image;\n\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)method;\n\tMonoTableInfo *tables = image->tables;\n\tMonoTableInfo *im = &tables [MONO_TABLE_IMPLMAP];\n\tMonoTableInfo *mr = &tables [MONO_TABLE_MODULEREF];\n\tguint32 im_cols [MONO_IMPLMAP_SIZE];\n\tguint32 scope_token;\n\tconst char *import = NULL;\n\tconst char *scope = NULL;\n\tguint32 flags;\n\n\tif (!(method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))\n\t\treturn NULL;\n\n\tif (!DllImportAttributeClass) {\n\t\tDllImportAttributeClass = \n\t\t\tmono_class_from_name (mono_defaults.corlib,\n\t\t\t\t\t\t\t\t  \"System.Runtime.InteropServices\", \"DllImportAttribute\");\n\t\tg_assert (DllImportAttributeClass);\n\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tif (method->klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\tg_hash_table_lookup (\n\t\t\t\t\t\t\t\t\t  ((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (method_aux) {\n\t\t\timport = method_aux->dllentry;\n\t\t\tscope = method_aux->dll;\n\t\t}\n\n\t\tif (!import || !scope) {\n\t\t\tmono_raise_exception (mono_get_exception_argument (\"method\", \"System.Reflection.Emit method with invalid pinvoke information\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse {\n\t\tif (piinfo->implmap_idx) {\n\t\t\tmono_metadata_decode_row (im, piinfo->implmap_idx - 1, im_cols, MONO_IMPLMAP_SIZE);\n\t\t\t\n\t\t\tpiinfo->piflags = im_cols [MONO_IMPLMAP_FLAGS];\n\t\t\timport = mono_metadata_string_heap (image, im_cols [MONO_IMPLMAP_NAME]);\n\t\t\tscope_token = mono_metadata_decode_row_col (mr, im_cols [MONO_IMPLMAP_SCOPE] - 1, MONO_MODULEREF_NAME);\n\t\t\tscope = mono_metadata_string_heap (image, scope_token);\n\t\t}\n\t}\n\tflags = piinfo->piflags;\n\t\n\tattr = (MonoReflectionDllImportAttribute*)mono_object_new (domain, DllImportAttributeClass);\n\n\tMONO_OBJECT_SETREF (attr, dll, mono_string_new (domain, scope));\n\tMONO_OBJECT_SETREF (attr, entry_point, mono_string_new (domain, import));\n\tattr->call_conv = (flags & 0x700) >> 8;\n\tattr->charset = ((flags & 0x6) >> 1) + 1;\n\tif (attr->charset == 1)\n\t\tattr->charset = 2;\n\tattr->exact_spelling = (flags & 0x1) != 0;\n\tattr->set_last_error = (flags & 0x40) != 0;\n\tattr->best_fit_mapping = (flags & 0x30) == 0x10;\n\tattr->throw_on_unmappable = (flags & 0x3000) == 0x1000;\n\tattr->preserve_sig = FALSE;\n\n\treturn attr;\n}\n\nstatic MonoReflectionMethod *\nves_icall_MonoMethod_GetGenericMethodDefinition (MonoReflectionMethod *method)\n{\n\tMonoMethodInflated *imethod;\n\tMonoMethod *result;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (method->method->is_generic)\n\t\treturn method;\n\n\tif (!method->method->is_inflated)\n\t\treturn NULL;\n\n\timethod = (MonoMethodInflated *) method->method;\n\n\tresult = imethod->declaring;\n\t/* Not a generic method.  */\n\tif (!result->is_generic)\n\t\treturn NULL;\n\n\tif (method->method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->method->klass->image;\n\t\tMonoReflectionMethod *res;\n\n\t\t/*\n\t\t * FIXME: Why is this stuff needed at all ? Why can't the code below work for\n\t\t * the dynamic case as well ?\n\t\t */\n\t\tmono_loader_lock ();\n\t\tres = mono_g_hash_table_lookup (image->generic_def_objects, imethod);\n\t\tmono_loader_unlock ();\n\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (imethod->context.class_inst) {\n\t\tMonoClass *klass = ((MonoMethod *) imethod)->klass;\n\t\t/*Generic methods gets the context of the GTD.*/\n\t\tif (mono_class_get_context (klass))\n\t\t\tresult = mono_class_inflate_generic_method_full (result, klass, mono_class_get_context (klass));\n\t}\n\n\treturn mono_method_get_object (mono_object_domain (method), result, NULL);\n}\n\nstatic gboolean\nves_icall_MonoMethod_get_IsGenericMethod (MonoReflectionMethod *method)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_method_signature (method->method)->generic_param_count != 0;\n}\n\nstatic gboolean\nves_icall_MonoMethod_get_IsGenericMethodDefinition (MonoReflectionMethod *method)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn method->method->is_generic;\n}\n\nstatic MonoArray*\nves_icall_MonoMethod_GetGenericArguments (MonoReflectionMethod *method)\n{\n\tMonoArray *res;\n\tMonoDomain *domain;\n\tint count, i;\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = mono_object_domain (method);\n\n\tif (method->method->is_inflated) {\n\t\tMonoGenericInst *inst = mono_method_get_context (method->method)->method_inst;\n\n\t\tif (inst) {\n\t\t\tcount = inst->type_argc;\n\t\t\tres = mono_array_new (domain, mono_defaults.systemtype_class, count);\n\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tmono_array_setref (res, i, mono_type_get_object (domain, inst->type_argv [i]));\n\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tcount = mono_method_signature (method->method)->generic_param_count;\n\tres = mono_array_new (domain, mono_defaults.systemtype_class, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tMonoGenericContainer *container = mono_method_get_generic_container (method->method);\n\t\tMonoGenericParam *param = mono_generic_container_get_param (container, i);\n\t\tMonoClass *pklass = mono_class_from_generic_parameter (\n\t\t\tparam, method->method->klass->image, TRUE);\n\t\tmono_array_setref (res, i,\n\t\t\t\tmono_type_get_object (domain, &pklass->byval_arg));\n\t}\n\n\treturn res;\n}\n\nstatic MonoObject *\nves_icall_InternalInvoke (MonoReflectionMethod *method, MonoObject *this, MonoArray *params, MonoException **exc) \n{\n\t/* \n\t * Invoke from reflection is supposed to always be a virtual call (the API\n\t * is stupid), mono_runtime_invoke_*() calls the provided method, allowing\n\t * greater flexibility.\n\t */\n\tMonoMethod *m = method->method;\n\tint pcount;\n\tvoid *obj = this;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t*exc = NULL;\n\n\tif (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\tmono_security_core_clr_ensure_reflection_access_method (m);\n\n\tif (!(m->flags & METHOD_ATTRIBUTE_STATIC)) {\n\t\tif (!mono_class_vtable_full (mono_object_domain (method), m->klass, FALSE)) {\n\t\t\tmono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_class_get_exception_for_failure (m->klass));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (this) {\n\t\t\tif (!mono_object_isinst (this, m->klass)) {\n\t\t\t\tmono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_exception_from_name_msg (mono_defaults.corlib, \"System.Reflection\", \"TargetException\", \"Object does not match target type.\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tm = mono_object_get_virtual_method (this, m);\n\t\t\t/* must pass the pointer to the value for valuetype methods */\n\t\t\tif (m->klass->valuetype)\n\t\t\t\tobj = mono_object_unbox (this);\n\t\t} else if (strcmp (m->name, \".ctor\") && !m->wrapper_type) {\n\t\t\tmono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_exception_from_name_msg (mono_defaults.corlib, \"System.Reflection\", \"TargetException\", \"Non-static method requires a target.\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tpcount = params? mono_array_length (params): 0;\n\tif (pcount != mono_method_signature (m)->param_count) {\n\t\tmono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_exception_from_name (mono_defaults.corlib, \"System.Reflection\", \"TargetParameterCountException\"));\n\t\treturn NULL;\n\t}\n\n\tif ((m->klass->flags & TYPE_ATTRIBUTE_ABSTRACT) && !strcmp (m->name, \".ctor\") && !this) {\n\t\tmono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_exception_from_name_msg (mono_defaults.corlib, \"System.Reflection\", \"TargetException\", \"Cannot invoke constructor of an abstract class.\"));\n\t\treturn NULL;\n\t}\n\n\tif (m->klass->image->assembly->ref_only) {\n\t\tmono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_get_exception_invalid_operation (\"It is illegal to invoke a method on a type loaded using the ReflectionOnly api.\"));\n\t\treturn NULL;\n\t}\n\t\n\tif (m->klass->rank && !strcmp (m->name, \".ctor\")) {\n\t\tint i;\n\t\tmono_array_size_t *lengths;\n\t\tmono_array_size_t *lower_bounds;\n\t\tpcount = mono_array_length (params);\n\t\tlengths = alloca (sizeof (mono_array_size_t) * pcount);\n\t\tfor (i = 0; i < pcount; ++i)\n\t\t\tlengths [i] = *(mono_array_size_t*) ((char*)mono_array_get (params, gpointer, i) + sizeof (MonoObject));\n\n\t\tif (m->klass->rank == pcount) {\n\t\t\t/* Only lengths provided. */\n\t\t\tlower_bounds = NULL;\n\t\t} else {\n\t\t\tg_assert (pcount == (m->klass->rank * 2));\n\t\t\t/* lower bounds are first. */\n\t\t\tlower_bounds = lengths;\n\t\t\tlengths += m->klass->rank;\n\t\t}\n\n\t\treturn (MonoObject*)mono_array_new_full (mono_object_domain (params), m->klass, lengths, lower_bounds);\n\t}\n\treturn mono_runtime_invoke_array (m, obj, params, NULL);\n}\n\nstatic MonoObject *\nves_icall_InternalExecute (MonoReflectionMethod *method, MonoObject *this, MonoArray *params, MonoArray **outArgs) \n{\n\tMonoDomain *domain = mono_object_domain (method); \n\tMonoMethod *m = method->method;\n\tMonoMethodSignature *sig = mono_method_signature (m);\n\tMonoArray *out_args;\n\tMonoObject *result;\n\tint i, j, outarg_count = 0;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (m->klass == mono_defaults.object_class) {\n\n\t\tif (!strcmp (m->name, \"FieldGetter\")) {\n\t\t\tMonoClass *k = this->vtable->klass;\n\t\t\tMonoString *name;\n\t\t\tchar *str;\n\t\t\t\n\t\t\t/* If this is a proxy, then it must be a CBO */\n\t\t\tif (k == mono_defaults.transparent_proxy_class) {\n\t\t\t\tMonoTransparentProxy *tp = (MonoTransparentProxy*) this;\n\t\t\t\tthis = tp->rp->unwrapped_server;\n\t\t\t\tg_assert (this);\n\t\t\t\tk = this->vtable->klass;\n\t\t\t}\n\t\t\t\n\t\t\tname = mono_array_get (params, MonoString *, 1);\n\t\t\tstr = mono_string_to_utf8 (name);\n\t\t\n\t\t\tdo {\n\t\t\t\tMonoClassField* field = mono_class_get_field_from_name (k, str);\n\t\t\t\tif (field) {\n\t\t\t\t\tMonoClass *field_klass =  mono_class_from_mono_type (field->type);\n\t\t\t\t\tif (field_klass->valuetype)\n\t\t\t\t\t\tresult = mono_value_box (domain, field_klass, (char *)this + field->offset);\n\t\t\t\t\telse \n\t\t\t\t\t\tresult = *((gpointer *)((char *)this + field->offset));\n\t\t\t\t\n\t\t\t\t\tout_args = mono_array_new (domain, mono_defaults.object_class, 1);\n\t\t\t\t\tmono_gc_wbarrier_generic_store (outArgs, (MonoObject*) out_args);\n\t\t\t\t\tmono_array_setref (out_args, 0, result);\n\t\t\t\t\tg_free (str);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tk = k->parent;\n\t\t\t} while (k);\n\n\t\t\tg_free (str);\n\t\t\tg_assert_not_reached ();\n\n\t\t} else if (!strcmp (m->name, \"FieldSetter\")) {\n\t\t\tMonoClass *k = this->vtable->klass;\n\t\t\tMonoString *name;\n\t\t\tguint32 size;\n\t\t\tgint32 align;\n\t\t\tchar *str;\n\t\t\t\n\t\t\t/* If this is a proxy, then it must be a CBO */\n\t\t\tif (k == mono_defaults.transparent_proxy_class) {\n\t\t\t\tMonoTransparentProxy *tp = (MonoTransparentProxy*) this;\n\t\t\t\tthis = tp->rp->unwrapped_server;\n\t\t\t\tg_assert (this);\n\t\t\t\tk = this->vtable->klass;\n\t\t\t}\n\t\t\t\n\t\t\tname = mono_array_get (params, MonoString *, 1);\n\t\t\tstr = mono_string_to_utf8 (name);\n\t\t\n\t\t\tdo {\n\t\t\t\tMonoClassField* field = mono_class_get_field_from_name (k, str);\n\t\t\t\tif (field) {\n\t\t\t\t\tMonoClass *field_klass =  mono_class_from_mono_type (field->type);\n\t\t\t\t\tMonoObject *val = mono_array_get (params, gpointer, 2);\n\n\t\t\t\t\tif (field_klass->valuetype) {\n\t\t\t\t\t\tsize = mono_type_size (field->type, &align);\n#ifdef HAVE_SGEN_GC\n\t\t\t\t\t\tmono_gc_wbarrier_value_copy ((char *)this + field->offset, (char*)val + sizeof (MonoObject), 1, field_klass);\n#endif\n\t\t\t\t\t\tmemcpy ((char *)this + field->offset, \n\t\t\t\t\t\t\t((char *)val) + sizeof (MonoObject), size);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmono_gc_wbarrier_set_field (this, (char*)this + field->offset, val);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tout_args = mono_array_new (domain, mono_defaults.object_class, 0);\n\t\t\t\t\tmono_gc_wbarrier_generic_store (outArgs, (MonoObject*) out_args);\n\n\t\t\t\t\tg_free (str);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tk = k->parent;\n\t\t\t} while (k);\n\n\t\t\tg_free (str);\n\t\t\tg_assert_not_reached ();\n\n\t\t}\n\t}\n\n\tfor (i = 0; i < mono_array_length (params); i++) {\n\t\tif (sig->params [i]->byref) \n\t\t\toutarg_count++;\n\t}\n\n\tout_args = mono_array_new (domain, mono_defaults.object_class, outarg_count);\n\t\n\t/* handle constructors only for objects already allocated */\n\tif (!strcmp (method->method->name, \".ctor\"))\n\t\tg_assert (this);\n\n\t/* This can be called only on MBR objects, so no need to unbox for valuetypes. */\n\tg_assert (!method->method->klass->valuetype);\n\tresult = mono_runtime_invoke_array (method->method, this, params, NULL);\n\n\tfor (i = 0, j = 0; i < mono_array_length (params); i++) {\n\t\tif (sig->params [i]->byref) {\n\t\t\tgpointer arg;\n\t\t\targ = mono_array_get (params, gpointer, i);\n\t\t\tmono_array_setref (out_args, j, arg);\n\t\t\tj++;\n\t\t}\n\t}\n\n\tmono_gc_wbarrier_generic_store (outArgs, (MonoObject*) out_args);\n\n\treturn result;\n}\n\nstatic guint64\nread_enum_value (char *mem, int type)\n{\n\tswitch (type) {\n\tcase MONO_TYPE_U1:\n\t\treturn *(guint8*)mem;\n\tcase MONO_TYPE_I1:\n\t\treturn *(gint8*)mem;\n\tcase MONO_TYPE_U2:\n\t\treturn *(guint16*)mem;\n\tcase MONO_TYPE_I2:\n\t\treturn *(gint16*)mem;\n\tcase MONO_TYPE_U4:\n\t\treturn *(guint32*)mem;\n\tcase MONO_TYPE_I4:\n\t\treturn *(gint32*)mem;\n\tcase MONO_TYPE_U8:\n\t\treturn *(guint64*)mem;\n\tcase MONO_TYPE_I8:\n\t\treturn *(gint64*)mem;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn 0;\n}\n\nstatic void\nwrite_enum_value (char *mem, int type, guint64 value)\n{\n\tswitch (type) {\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1: {\n\t\tguint8 *p = (guint8*)mem;\n\t\t*p = value;\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2: {\n\t\tguint16 *p = (void*)mem;\n\t\t*p = value;\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4: {\n\t\tguint32 *p = (void*)mem;\n\t\t*p = value;\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8: {\n\t\tguint64 *p = (void*)mem;\n\t\t*p = value;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn;\n}\n\nstatic MonoObject *\nves_icall_System_Enum_ToObject (MonoReflectionType *enumType, MonoObject *value)\n{\n\tMonoDomain *domain; \n\tMonoClass *enumc, *objc;\n\tMonoObject *res;\n\tMonoType *etype;\n\tguint64 val;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (enumType);\n\tMONO_CHECK_ARG_NULL (value);\n\n\tdomain = mono_object_domain (enumType); \n\tenumc = mono_class_from_mono_type (enumType->type);\n\tobjc = value->vtable->klass;\n\n\tif (!enumc->enumtype)\n\t\tmono_raise_exception (mono_get_exception_argument (\"enumType\", \"Type provided must be an Enum.\"));\n\tif (!((objc->enumtype) || (objc->byval_arg.type >= MONO_TYPE_I1 && objc->byval_arg.type <= MONO_TYPE_U8)))\n\t\tmono_raise_exception (mono_get_exception_argument (\"value\", \"The value passed in must be an enum base or an underlying type for an enum, such as an Int32.\"));\n\n\tetype = mono_class_enum_basetype (enumc);\n\tif (!etype)\n\t\t/* MS throws this for typebuilders */\n\t\tmono_raise_exception (mono_get_exception_argument (\"Type must be a type provided by the runtime.\", \"enumType\"));\n\n\tres = mono_object_new (domain, enumc);\n\tval = read_enum_value ((char *)value + sizeof (MonoObject), objc->enumtype? mono_class_enum_basetype (objc)->type: objc->byval_arg.type);\n\twrite_enum_value ((char *)res + sizeof (MonoObject), etype->type, val);\n\n\treturn res;\n}\n\nstatic MonoObject *\nves_icall_System_Enum_get_value (MonoObject *this)\n{\n\tMonoObject *res;\n\tMonoClass *enumc;\n\tgpointer dst;\n\tgpointer src;\n\tint size;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!this)\n\t\treturn NULL;\n\n\tg_assert (this->vtable->klass->enumtype);\n\t\n\tenumc = mono_class_from_mono_type (mono_class_enum_basetype (this->vtable->klass));\n\tres = mono_object_new (mono_object_domain (this), enumc);\n\tdst = (char *)res + sizeof (MonoObject);\n\tsrc = (char *)this + sizeof (MonoObject);\n\tsize = mono_class_value_size (enumc, NULL);\n\n\tmemcpy (dst, src, size);\n\n\treturn res;\n}\n\nstatic MonoReflectionType *\nves_icall_System_Enum_get_underlying_type (MonoReflectionType *type)\n{\n\tMonoType *etype;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tetype = mono_class_enum_basetype (mono_class_from_mono_type (type->type));\n\tif (!etype)\n\t\t/* MS throws this for typebuilders */\n\t\tmono_raise_exception (mono_get_exception_argument (\"Type must be a type provided by the runtime.\", \"enumType\"));\n\n\treturn mono_type_get_object (mono_object_domain (type), etype);\n}\n\nstatic int\nves_icall_System_Enum_compare_value_to (MonoObject *this, MonoObject *other)\n{\n\tgpointer tdata = (char *)this + sizeof (MonoObject);\n\tgpointer odata = (char *)other + sizeof (MonoObject);\n\tMonoType *basetype = mono_class_enum_basetype (this->vtable->klass);\n\tg_assert (basetype);\n\n#define COMPARE_ENUM_VALUES(ENUM_TYPE) do { \\\n\t\tENUM_TYPE me = *((ENUM_TYPE*)tdata); \\\n\t\tENUM_TYPE other = *((ENUM_TYPE*)odata); \\\n\t\tif (me == other) \\\n\t\t\treturn 0; \\\n\t\treturn me > other ? 1 : -1; \\\n\t} while (0)\n\n#define COMPARE_ENUM_VALUES_RANGE(ENUM_TYPE) do { \\\n\t\tENUM_TYPE me = *((ENUM_TYPE*)tdata); \\\n\t\tENUM_TYPE other = *((ENUM_TYPE*)odata); \\\n\t\tif (me == other) \\\n\t\t\treturn 0; \\\n\t\treturn me - other; \\\n\t} while (0)\n\n\tswitch (basetype->type) {\n\t\tcase MONO_TYPE_U1:\n\t\t\tCOMPARE_ENUM_VALUES (guint8);\n\t\tcase MONO_TYPE_I1:\n\t\t\tCOMPARE_ENUM_VALUES (gint8);\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_U2:\n\t\t\tCOMPARE_ENUM_VALUES_RANGE (guint16);\n\t\tcase MONO_TYPE_I2:\n\t\t\tCOMPARE_ENUM_VALUES (gint16);\n\t\tcase MONO_TYPE_U4:\n\t\t\tCOMPARE_ENUM_VALUES (guint32);\n\t\tcase MONO_TYPE_I4:\n\t\t\tCOMPARE_ENUM_VALUES (gint32);\n\t\tcase MONO_TYPE_U8:\n\t\t\tCOMPARE_ENUM_VALUES (guint64);\n\t\tcase MONO_TYPE_I8:\n\t\t\tCOMPARE_ENUM_VALUES (gint64);\n\t\tdefault:\n\t\t\tg_error (\"Implement type 0x%02x in get_hashcode\", basetype->type);\n\t}\n#undef COMPARE_ENUM_VALUES_RANGE\n#undef COMPARE_ENUM_VALUES\n\treturn 0;\n}\n\nstatic int\nves_icall_System_Enum_get_hashcode (MonoObject *this)\n{\n\tgpointer data = (char *)this + sizeof (MonoObject);\n\tMonoType *basetype = mono_class_enum_basetype (this->vtable->klass);\n\tg_assert (basetype);\n\n\tswitch (basetype->type) {\n\t\tcase MONO_TYPE_I1:\t\n\t\t\treturn *((gint8*)data);\n\t\tcase MONO_TYPE_U1:\n\t\t\treturn *((guint8*)data);\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_U2:\n\t\t\treturn *((guint16*)data);\n\t\t\n\t\tcase MONO_TYPE_I2:\n\t\t\treturn *((gint16*)data);\n\t\tcase MONO_TYPE_U4:\n\t\t\treturn *((guint32*)data);\n\t\tcase MONO_TYPE_I4:\n\t\t\treturn *((gint32*)data);\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I8: {\n\t\t\tgint64 value = *((gint64*)data);\n\t\t\treturn (gint)(value & 0xffffffff) ^ (int)(value >> 32);\n\t\t}\n\t\tdefault:\n\t\t\tg_error (\"Implement type 0x%02x in get_hashcode\", basetype->type);\n\t}\n\treturn 0;\n}\n\nstatic void\nves_icall_get_enum_info (MonoReflectionType *type, MonoEnumInfo *info)\n{\n\tMonoDomain *domain = mono_object_domain (type); \n\tMonoClass *enumc = mono_class_from_mono_type (type->type);\n\tguint j = 0, nvalues, crow;\n\tgpointer iter;\n\tMonoClassField *field;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_STRUCT_SETREF (info, utype, mono_type_get_object (domain, mono_class_enum_basetype (enumc)));\n\tnvalues = mono_class_num_fields (enumc) ? mono_class_num_fields (enumc) - 1 : 0;\n\tMONO_STRUCT_SETREF (info, names, mono_array_new (domain, mono_defaults.string_class, nvalues));\n\tMONO_STRUCT_SETREF (info, values, mono_array_new (domain, enumc, nvalues));\n\n\tcrow = -1;\n\titer = NULL;\n\twhile ((field = mono_class_get_fields (enumc, &iter))) {\n\t\tconst char *p;\n\t\tint len;\n\t\tMonoTypeEnum def_type;\n\t\t\n\t\tif (strcmp (\"value__\", mono_field_get_name (field)) == 0)\n\t\t\tcontinue;\n\t\tif (mono_field_is_deleted (field))\n\t\t\tcontinue;\n\t\tmono_array_setref (info->names, j, mono_string_new (domain, mono_field_get_name (field)));\n\n\t\tp = mono_class_get_field_default_value (field, &def_type);\n\t\tlen = mono_metadata_decode_blob_size (p, &p);\n\t\tswitch (mono_class_enum_basetype (enumc)->type) {\n\t\tcase MONO_TYPE_U1:\n\t\tcase MONO_TYPE_I1:\n\t\t\tmono_array_set (info->values, gchar, j, *p);\n\t\t\tbreak;\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_I2:\n\t\t\tmono_array_set (info->values, gint16, j, read16 (p));\n\t\t\tbreak;\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_I4:\n\t\t\tmono_array_set (info->values, gint32, j, read32 (p));\n\t\t\tbreak;\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I8:\n\t\t\tmono_array_set (info->values, gint64, j, read64 (p));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_error (\"Implement type 0x%02x in get_enum_info\", mono_class_enum_basetype (enumc)->type);\n\t\t}\n\t\t++j;\n\t}\n}\n\nenum {\n\tBFLAGS_IgnoreCase = 1,\n\tBFLAGS_DeclaredOnly = 2,\n\tBFLAGS_Instance = 4,\n\tBFLAGS_Static = 8,\n\tBFLAGS_Public = 0x10,\n\tBFLAGS_NonPublic = 0x20,\n\tBFLAGS_FlattenHierarchy = 0x40,\n\tBFLAGS_InvokeMethod = 0x100,\n\tBFLAGS_CreateInstance = 0x200,\n\tBFLAGS_GetField = 0x400,\n\tBFLAGS_SetField = 0x800,\n\tBFLAGS_GetProperty = 0x1000,\n\tBFLAGS_SetProperty = 0x2000,\n\tBFLAGS_ExactBinding = 0x10000,\n\tBFLAGS_SuppressChangeType = 0x20000,\n\tBFLAGS_OptionalParamBinding = 0x40000\n};\n\nstatic MonoReflectionField *\nves_icall_Type_GetField (MonoReflectionType *type, MonoString *name, guint32 bflags)\n{\n\tMonoDomain *domain; \n\tMonoClass *startklass, *klass;\n\tint match;\n\tMonoClassField *field;\n\tgpointer iter;\n\tchar *utf8_name;\n\tint (*compare_func) (const char *s1, const char *s2) = NULL;\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!name)\n\t\tmono_raise_exception (mono_get_exception_argument_null (\"name\"));\n\tif (type->type->byref)\n\t\treturn NULL;\n\n\tcompare_func = (bflags & BFLAGS_IgnoreCase) ? mono_utf8_strcasecmp : strcmp;\n\nhandle_parent:\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\titer = NULL;\n\twhile ((field = mono_class_get_fields (klass, &iter))) {\n\t\tmatch = 0;\n\n\t\tif (field->type == NULL)\n\t\t\tcontinue;\n\t\tif (mono_field_is_deleted (field))\n\t\t\tcontinue;\n\t\tif ((field->type->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) == FIELD_ATTRIBUTE_PUBLIC) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else if ((klass == startklass) || (field->type->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) != FIELD_ATTRIBUTE_PRIVATE) {\n\t\t\tif (bflags & BFLAGS_NonPublic) {\n\t\t\t\tmatch++;\n\t\t\t}\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\t\tif (field->type->attrs & FIELD_ATTRIBUTE_STATIC) {\n\t\t\tif (bflags & BFLAGS_Static)\n\t\t\t\tif ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))\n\t\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\tmatch++;\n\t\t}\n\n\t\tif (!match)\n\t\t\tcontinue;\n\t\t\n\t\tutf8_name = mono_string_to_utf8 (name);\n\n\t\tif (compare_func (mono_field_get_name (field), utf8_name)) {\n\t\t\tg_free (utf8_name);\n\t\t\tcontinue;\n\t\t}\n\t\tg_free (utf8_name);\n\t\t\n\t\treturn mono_field_get_object (domain, klass, field);\n\t}\n\tif (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))\n\t\tgoto handle_parent;\n\n\treturn NULL;\n}\n\nstatic MonoArray*\nves_icall_Type_GetFields_internal (MonoReflectionType *type, guint32 bflags, MonoReflectionType *reftype)\n{\n\tMonoDomain *domain; \n\tMonoClass *startklass, *klass, *refklass;\n\tMonoArray *res;\n\tMonoObject *member;\n\tint i, match;\n\tgpointer iter;\n\tMonoClassField *field;\n\tMonoPtrArray tmp_array;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tif (type->type->byref)\n\t\treturn mono_array_new (domain, mono_defaults.field_info_class, 0);\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\trefklass = mono_class_from_mono_type (reftype->type);\n\n\tmono_ptr_array_init (tmp_array, 2);\n\t\nhandle_parent:\t\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\titer = NULL;\n\twhile ((field = mono_class_get_fields (klass, &iter))) {\n\t\tmatch = 0;\n\t\tif (mono_field_is_deleted (field))\n\t\t\tcontinue;\n\t\tif ((field->type->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) == FIELD_ATTRIBUTE_PUBLIC) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else if ((klass == startklass) || (field->type->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) != FIELD_ATTRIBUTE_PRIVATE) {\n\t\t\tif (bflags & BFLAGS_NonPublic) {\n\t\t\t\tmatch++;\n\t\t\t}\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\t\tif (field->type->attrs & FIELD_ATTRIBUTE_STATIC) {\n\t\t\tif (bflags & BFLAGS_Static)\n\t\t\t\tif ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))\n\t\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\tmatch++;\n\t\t}\n\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmember = (MonoObject*)mono_field_get_object (domain, refklass, field);\n\t\tmono_ptr_array_append (tmp_array, member);\n\t}\n\tif (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))\n\t\tgoto handle_parent;\n\n\tres = mono_array_new_cached (domain, mono_defaults.field_info_class, mono_ptr_array_size (tmp_array));\n\n\tfor (i = 0; i < mono_ptr_array_size (tmp_array); ++i)\n\t\tmono_array_setref (res, i, mono_ptr_array_get (tmp_array, i));\n\n\tmono_ptr_array_destroy (tmp_array);\n\n\treturn res;\n}\n\nstatic gboolean\nmethod_nonpublic (MonoMethod* method, gboolean start_klass)\n{\n\tswitch (method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) {\n\t\tcase METHOD_ATTRIBUTE_ASSEM:\n\t\t\treturn (start_klass || mono_defaults.generic_ilist_class);\n\t\tcase METHOD_ATTRIBUTE_PRIVATE:\n\t\t\treturn start_klass;\n\t\tcase METHOD_ATTRIBUTE_PUBLIC:\n\t\t\treturn FALSE;\n\t\tdefault:\n\t\t\treturn TRUE;\n\t}\n}\n\nstatic MonoArray*\nves_icall_Type_GetMethodsByName (MonoReflectionType *type, MonoString *name, guint32 bflags, MonoBoolean ignore_case, MonoReflectionType *reftype)\n{\n\tstatic MonoClass *MethodInfo_array;\n\tMonoDomain *domain; \n\tMonoClass *startklass, *klass, *refklass;\n\tMonoArray *res;\n\tMonoMethod *method;\n\tgpointer iter;\n\tMonoObject *member;\n\tint i, len, match, nslots;\n\t/*FIXME, use MonoBitSet*/\n\tguint32 method_slots_default [8];\n\tguint32 *method_slots = NULL;\n\tgchar *mname = NULL;\n\tint (*compare_func) (const char *s1, const char *s2) = NULL;\n\tMonoVTable *array_vtable;\n\tMonoException *ex;\n\tMonoPtrArray tmp_array;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_ptr_array_init (tmp_array, 4);\n\n\tif (!MethodInfo_array) {\n\t\tMonoClass *klass = mono_array_class_get (mono_defaults.method_info_class, 1);\n\t\tmono_memory_barrier ();\n\t\tMethodInfo_array = klass;\n\t}\n\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tarray_vtable = mono_class_vtable_full (domain, MethodInfo_array, TRUE);\n\tif (type->type->byref)\n\t\treturn mono_array_new_specific (array_vtable, 0);\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\trefklass = mono_class_from_mono_type (reftype->type);\n\tlen = 0;\n\tif (name != NULL) {\n\t\tmname = mono_string_to_utf8 (name);\n\t\tcompare_func = (ignore_case) ? mono_utf8_strcasecmp : strcmp;\n\t}\n\n\t/* An optimization for calls made from Delegate:CreateDelegate () */\n\tif (klass->delegate && mname && !strcmp (mname, \"Invoke\") && (bflags == (BFLAGS_Public | BFLAGS_Static | BFLAGS_Instance))) {\n\t\tmethod = mono_get_delegate_invoke (klass);\n\t\tif (mono_loader_get_last_error ())\n\t\t\tgoto loader_error;\n\n\t\tmember = (MonoObject*)mono_method_get_object (domain, method, refklass);\n\n\t\tres = mono_array_new_specific (array_vtable, 1);\n\t\tmono_array_setref (res, 0, member);\n\t\tg_free (mname);\n\t\treturn res;\n\t}\n\n\tmono_class_setup_vtable (klass);\n\tif (klass->exception_type != MONO_EXCEPTION_NONE || mono_loader_get_last_error ())\n\t\tgoto loader_error;\n\n\tif (is_generic_parameter (type->type))\n\t\tnslots = mono_class_get_vtable_size (klass->parent);\n\telse\n\t\tnslots = MONO_CLASS_IS_INTERFACE (klass) ? mono_class_num_methods (klass) : mono_class_get_vtable_size (klass);\n\tif (nslots >= sizeof (method_slots_default) * 8) {\n\t\tmethod_slots = g_new0 (guint32, nslots / 32 + 1);\n\t} else {\n\t\tmethod_slots = method_slots_default;\n\t\tmemset (method_slots, 0, sizeof (method_slots_default));\n\t}\nhandle_parent:\n\tmono_class_setup_vtable (klass);\n\tif (klass->exception_type != MONO_EXCEPTION_NONE || mono_loader_get_last_error ())\n\t\tgoto loader_error;\t\t\n\n\titer = NULL;\n\twhile ((method = mono_class_get_methods (klass, &iter))) {\n\t\tmatch = 0;\n\t\tif (method->slot != -1) {\n\t\t\tg_assert (method->slot < nslots);\n\t\t\tif (method_slots [method->slot >> 5] & (1 << (method->slot & 0x1f)))\n\t\t\t\tcontinue;\n\t\t\tif (!(method->flags & METHOD_ATTRIBUTE_NEW_SLOT))\n\t\t\t\tmethod_slots [method->slot >> 5] |= 1 << (method->slot & 0x1f);\n\t\t}\n\n\t\tif (method->name [0] == '.' && (strcmp (method->name, \".ctor\") == 0 || strcmp (method->name, \".cctor\") == 0))\n\t\t\tcontinue;\n\t\tif ((method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else if ((bflags & BFLAGS_NonPublic) && method_nonpublic (method, (klass == startklass))) {\n\t\t\t\tmatch++;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\t\tif (method->flags & METHOD_ATTRIBUTE_STATIC) {\n\t\t\tif (bflags & BFLAGS_Static)\n\t\t\t\tif ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))\n\t\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\tmatch++;\n\t\t}\n\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (name != NULL) {\n\t\t\tif (compare_func (mname, method->name))\n\t\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tmatch = 0;\n\t\t\n\t\tmember = (MonoObject*)mono_method_get_object (domain, method, refklass);\n\t\t\n\t\tmono_ptr_array_append (tmp_array, member);\n\t}\n\tif (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))\n\t\tgoto handle_parent;\n\n\tg_free (mname);\n\tif (method_slots != method_slots_default)\n\t\tg_free (method_slots);\n\n\tres = mono_array_new_specific (array_vtable, mono_ptr_array_size (tmp_array));\n\n\tfor (i = 0; i < mono_ptr_array_size (tmp_array); ++i)\n\t\tmono_array_setref (res, i, mono_ptr_array_get (tmp_array, i));\n\n\tmono_ptr_array_destroy (tmp_array);\n\treturn res;\n\nloader_error:\n\tg_free (mname);\n\tif (method_slots != method_slots_default)\n\t\tg_free (method_slots);\n\tmono_ptr_array_destroy (tmp_array);\n\tif (klass->exception_type != MONO_EXCEPTION_NONE) {\n\t\tex = mono_class_get_exception_for_failure (klass);\n\t} else {\n\t\tex = mono_loader_error_prepare_exception (mono_loader_get_last_error ());\n\t\tmono_loader_clear_error ();\n\t}\n\tmono_raise_exception (ex);\n\treturn NULL;\n}\n\nstatic MonoArray*\nves_icall_Type_GetConstructors_internal (MonoReflectionType *type, guint32 bflags, MonoReflectionType *reftype)\n{\n\tMonoDomain *domain; \n\tstatic MonoClass *System_Reflection_ConstructorInfo;\n\tMonoClass *startklass, *klass, *refklass;\n\tMonoArray *res;\n\tMonoMethod *method;\n\tMonoObject *member;\n\tint i, match;\n\tgpointer iter = NULL;\n\tMonoPtrArray tmp_array;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_ptr_array_init (tmp_array, 4); /*FIXME, guestimating*/\n\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tif (type->type->byref)\n\t\treturn mono_array_new_cached (domain, mono_defaults.method_info_class, 0);\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\trefklass = mono_class_from_mono_type (reftype->type);\n\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\tif (!System_Reflection_ConstructorInfo)\n\t\tSystem_Reflection_ConstructorInfo = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"ConstructorInfo\");\n\n\titer = NULL;\n\twhile ((method = mono_class_get_methods (klass, &iter))) {\n\t\tmatch = 0;\n\t\tif (strcmp (method->name, \".ctor\") && strcmp (method->name, \".cctor\"))\n\t\t\tcontinue;\n\t\tif ((method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_NonPublic)\n\t\t\t\tmatch++;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\t\tif (method->flags & METHOD_ATTRIBUTE_STATIC) {\n\t\t\tif (bflags & BFLAGS_Static)\n\t\t\t\tif ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))\n\t\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\tmatch++;\n\t\t}\n\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmember = (MonoObject*)mono_method_get_object (domain, method, refklass);\n\n\t\tmono_ptr_array_append (tmp_array, member);\n\t}\n\n\tres = mono_array_new_cached (domain, System_Reflection_ConstructorInfo, mono_ptr_array_size (tmp_array));\n\n\tfor (i = 0; i < mono_ptr_array_size (tmp_array); ++i)\n\t\tmono_array_setref (res, i, mono_ptr_array_get (tmp_array, i));\n\n\tmono_ptr_array_destroy (tmp_array);\n\n\treturn res;\n}\n\nstatic guint\nproperty_hash (gconstpointer data)\n{\n\tMonoProperty *prop = (MonoProperty*)data;\n\n\treturn g_str_hash (prop->name);\n}\n\nstatic gboolean\nproperty_equal (MonoProperty *prop1, MonoProperty *prop2)\n{\n\t// Properties are hide-by-name-and-signature\n\tif (!g_str_equal (prop1->name, prop2->name))\n\t\treturn FALSE;\n\n\tif (prop1->get && prop2->get && !mono_metadata_signature_equal (mono_method_signature (prop1->get), mono_method_signature (prop2->get)))\n\t\treturn FALSE;\n\tif (prop1->set && prop2->set && !mono_metadata_signature_equal (mono_method_signature (prop1->set), mono_method_signature (prop2->set)))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\nstatic gboolean\nproperty_accessor_nonpublic (MonoMethod* accessor, gboolean start_klass)\n{\n\tif (!accessor)\n\t\treturn FALSE;\n\n\treturn method_nonpublic (accessor, start_klass);\n}\n\nstatic MonoArray*\nves_icall_Type_GetPropertiesByName (MonoReflectionType *type, MonoString *name, guint32 bflags, MonoBoolean ignore_case, MonoReflectionType *reftype)\n{\n\tMonoDomain *domain; \n\tstatic MonoClass *System_Reflection_PropertyInfo;\n\tMonoClass *startklass, *klass;\n\tMonoArray *res;\n\tMonoMethod *method;\n\tMonoProperty *prop;\n\tint i, match;\n\tguint32 flags;\n\tgchar *propname = NULL;\n\tint (*compare_func) (const char *s1, const char *s2) = NULL;\n\tgpointer iter;\n\tGHashTable *properties;\n\tMonoPtrArray tmp_array;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_ptr_array_init (tmp_array, 8); /*This the average for ASP.NET types*/\n\n\tif (!System_Reflection_PropertyInfo)\n\t\tSystem_Reflection_PropertyInfo = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"PropertyInfo\");\n\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tif (type->type->byref)\n\t\treturn mono_array_new_cached (domain, System_Reflection_PropertyInfo, 0);\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\tif (name != NULL) {\n\t\tpropname = mono_string_to_utf8 (name);\n\t\tcompare_func = (ignore_case) ? mono_utf8_strcasecmp : strcmp;\n\t}\n\n\tmono_class_setup_vtable (klass);\n\n\tproperties = g_hash_table_new (property_hash, (GEqualFunc)property_equal);\nhandle_parent:\n\tmono_class_setup_vtable (klass);\n\tif (klass->exception_type != MONO_EXCEPTION_NONE) {\n\t\tg_hash_table_destroy (properties);\n\t\tif (name != NULL)\n\t\t\tg_free (propname);\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\t}\n\n\titer = NULL;\n\twhile ((prop = mono_class_get_properties (klass, &iter))) {\n\t\tmatch = 0;\n\t\tmethod = prop->get;\n\t\tif (!method)\n\t\t\tmethod = prop->set;\n\t\tif (method)\n\t\t\tflags = method->flags;\n\t\telse\n\t\t\tflags = 0;\n\t\tif ((prop->get && ((prop->get->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)) ||\n\t\t\t(prop->set && ((prop->set->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC))) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else if (bflags & BFLAGS_NonPublic) {\n\t\t\tif (property_accessor_nonpublic(prop->get, startklass == klass) ||\n\t\t\t\tproperty_accessor_nonpublic(prop->set, startklass == klass)) {\n\t\t\t\tmatch++;\n\t\t\t}\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\t\tif (flags & METHOD_ATTRIBUTE_STATIC) {\n\t\t\tif (bflags & BFLAGS_Static)\n\t\t\t\tif ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))\n\t\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\tmatch++;\n\t\t}\n\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\n\t\tif (name != NULL) {\n\t\t\tif (compare_func (propname, prop->name))\n\t\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (g_hash_table_lookup (properties, prop))\n\t\t\tcontinue;\n\n\t\tmono_ptr_array_append (tmp_array, mono_property_get_object (domain, startklass, prop));\n\t\t\n\t\tg_hash_table_insert (properties, prop, prop);\n\t}\n\tif ((!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent)))\n\t\tgoto handle_parent;\n\n\tg_hash_table_destroy (properties);\n\tg_free (propname);\n\n\tres = mono_array_new_cached (domain, System_Reflection_PropertyInfo, mono_ptr_array_size (tmp_array));\n\tfor (i = 0; i < mono_ptr_array_size (tmp_array); ++i)\n\t\tmono_array_setref (res, i, mono_ptr_array_get (tmp_array, i));\n\n\tmono_ptr_array_destroy (tmp_array);\n\n\treturn res;\n}\n\nstatic MonoReflectionEvent *\nves_icall_MonoType_GetEvent (MonoReflectionType *type, MonoString *name, guint32 bflags)\n{\n\tMonoDomain *domain;\n\tMonoClass *klass, *startklass;\n\tgpointer iter;\n\tMonoEvent *event;\n\tMonoMethod *method;\n\tgchar *event_name;\n\tint (*compare_func) (const char *s1, const char *s2) = NULL;\n\tMONO_ARCH_SAVE_REGS;\n\n\tevent_name = mono_string_to_utf8 (name);\n\tif (type->type->byref)\n\t\treturn NULL;\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\tdomain = mono_object_domain (type);\n\n\tcompare_func = (bflags & BFLAGS_IgnoreCase) ? mono_utf8_strcasecmp : strcmp;\n\n  handle_parent:\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\titer = NULL;\n\twhile ((event = mono_class_get_events (klass, &iter))) {\n\t\tif (compare_func (event->name, event_name))\n\t\t\tcontinue;\n\n\t\tmethod = event->add;\n\t\tif (!method)\n\t\t\tmethod = event->remove;\n\t\tif (!method)\n\t\t\tmethod = event->raise;\n\t\tif (method) {\n\t\t\tif ((method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC) {\n\t\t\t\tif (!(bflags & BFLAGS_Public))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!(bflags & BFLAGS_NonPublic))\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((klass != startklass) && (method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PRIVATE)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (method->flags & METHOD_ATTRIBUTE_STATIC) {\n\t\t\t\tif (!(bflags & BFLAGS_Static))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!(bflags & BFLAGS_FlattenHierarchy) && (klass != startklass))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!(bflags & BFLAGS_Instance))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else \n\t\t\tif (!(bflags & BFLAGS_NonPublic))\n\t\t\t\tcontinue;\n\t\t\n\t\tg_free (event_name);\n\t\treturn mono_event_get_object (domain, startklass, event);\n\t}\n\n\tif (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))\n\t\tgoto handle_parent;\n\n\tg_free (event_name);\n\treturn NULL;\n}\n\nstatic MonoArray*\nves_icall_Type_GetEvents_internal (MonoReflectionType *type, guint32 bflags, MonoReflectionType *reftype)\n{\n\tMonoDomain *domain; \n\tstatic MonoClass *System_Reflection_EventInfo;\n\tMonoClass *startklass, *klass;\n\tMonoArray *res;\n\tMonoMethod *method;\n\tMonoEvent *event;\n\tint i, match;\n\tgpointer iter;\n\t\n\tMonoPtrArray tmp_array;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_ptr_array_init (tmp_array, 4);\n\n\tif (!System_Reflection_EventInfo)\n\t\tSystem_Reflection_EventInfo = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"EventInfo\");\n\n\tdomain = mono_object_domain (type);\n\tif (type->type->byref)\n\t\treturn mono_array_new_cached (domain, System_Reflection_EventInfo, 0);\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\nhandle_parent:\t\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\titer = NULL;\n\twhile ((event = mono_class_get_events (klass, &iter))) {\n\t\tmatch = 0;\n\t\tmethod = event->add;\n\t\tif (!method)\n\t\t\tmethod = event->remove;\n\t\tif (!method)\n\t\t\tmethod = event->raise;\n\t\tif (method) {\n\t\t\tif ((method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC) {\n\t\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\t\tmatch++;\n\t\t\t} else if ((klass == startklass) || (method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) != METHOD_ATTRIBUTE_PRIVATE) {\n\t\t\t\tif (bflags & BFLAGS_NonPublic)\n\t\t\t\t\tmatch++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tif (bflags & BFLAGS_NonPublic)\n\t\t\t\tmatch ++;\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\t\tif (method) {\n\t\t\tif (method->flags & METHOD_ATTRIBUTE_STATIC) {\n\t\t\t\tif (bflags & BFLAGS_Static)\n\t\t\t\t\tif ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))\n\t\t\t\t\t\tmatch++;\n\t\t\t} else {\n\t\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\t\tmatch++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\tmatch ++;\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmono_ptr_array_append (tmp_array, mono_event_get_object (domain, startklass, event));\n\t}\n\tif (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))\n\t\tgoto handle_parent;\n\n\tres = mono_array_new_cached (domain, System_Reflection_EventInfo, mono_ptr_array_size (tmp_array));\n\n\tfor (i = 0; i < mono_ptr_array_size (tmp_array); ++i)\n\t\tmono_array_setref (res, i, mono_ptr_array_get (tmp_array, i));\n\n\tmono_ptr_array_destroy (tmp_array);\n\n\treturn res;\n}\n\nstatic MonoReflectionType *\nves_icall_Type_GetNestedType (MonoReflectionType *type, MonoString *name, guint32 bflags)\n{\n\tMonoDomain *domain; \n\tMonoClass *klass;\n\tMonoClass *nested;\n\tchar *str;\n\tgpointer iter;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (name == NULL)\n\t\tmono_raise_exception (mono_get_exception_argument_null (\"name\"));\n\t\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tif (type->type->byref)\n\t\treturn NULL;\n\tklass = mono_class_from_mono_type (type->type);\n\tstr = mono_string_to_utf8 (name);\n\n handle_parent:\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\t/*\n\t * If a nested type is generic, return its generic type definition.\n\t * Note that this means that the return value is essentially a\n\t * nested type of the generic type definition of @klass.\n\t *\n\t * A note in MSDN claims that a generic type definition can have\n\t * nested types that aren't generic.  In any case, the container of that\n\t * nested type would be the generic type definition.\n\t */\n\tif (klass->generic_class)\n\t\tklass = klass->generic_class->container_class;\n\n\titer = NULL;\n\twhile ((nested = mono_class_get_nested_types (klass, &iter))) {\n\t\tint match = 0;\n\t\tif ((nested->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK) == TYPE_ATTRIBUTE_NESTED_PUBLIC) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_NonPublic)\n\t\t\t\tmatch++;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tif (strcmp (nested->name, str) == 0){\n\t\t\tg_free (str);\n\t\t\treturn mono_type_get_object (domain, &nested->byval_arg);\n\t\t}\n\t}\n\tif (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))\n\t\tgoto handle_parent;\n\tg_free (str);\n\treturn NULL;\n}\n\nstatic MonoArray*\nves_icall_Type_GetNestedTypes (MonoReflectionType *type, guint32 bflags)\n{\n\tMonoDomain *domain; \n\tMonoClass *klass;\n\tMonoArray *res;\n\tMonoObject *member;\n\tint i, match;\n\tMonoClass *nested;\n\tgpointer iter;\n\tMonoPtrArray tmp_array;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tif (type->type->byref)\n\t\treturn mono_array_new (domain, mono_defaults.monotype_class, 0);\n\tklass = mono_class_from_mono_type (type->type);\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\t/*\n\t * If a nested type is generic, return its generic type definition.\n\t * Note that this means that the return value is essentially the set\n\t * of nested types of the generic type definition of @klass.\n\t *\n\t * A note in MSDN claims that a generic type definition can have\n\t * nested types that aren't generic.  In any case, the container of that\n\t * nested type would be the generic type definition.\n\t */\n\tif (klass->generic_class)\n\t\tklass = klass->generic_class->container_class;\n\n\tmono_ptr_array_init (tmp_array, 1);\n\titer = NULL;\n\twhile ((nested = mono_class_get_nested_types (klass, &iter))) {\n\t\tmatch = 0;\n\t\tif ((nested->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK) == TYPE_ATTRIBUTE_NESTED_PUBLIC) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_NonPublic)\n\t\t\t\tmatch++;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmember = (MonoObject*)mono_type_get_object (domain, &nested->byval_arg);\n\t\tmono_ptr_array_append (tmp_array, member);\n\t}\n\n\tres = mono_array_new_cached (domain, mono_defaults.monotype_class, mono_ptr_array_size (tmp_array));\n\n\tfor (i = 0; i < mono_ptr_array_size (tmp_array); ++i)\n\t\tmono_array_setref (res, i, mono_ptr_array_get (tmp_array, i));\n\n\tmono_ptr_array_destroy (tmp_array);\n\n\treturn res;\n}\n\nstatic MonoReflectionType*\nves_icall_System_Reflection_Assembly_InternalGetType (MonoReflectionAssembly *assembly, MonoReflectionModule *module, MonoString *name, MonoBoolean throwOnError, MonoBoolean ignoreCase)\n{\n\tgchar *str;\n\tMonoType *type = NULL;\n\tMonoTypeNameParse info;\n\tgboolean type_resolve;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t/* On MS.NET, this does not fire a TypeResolve event */\n\ttype_resolve = TRUE;\n\tstr = mono_string_to_utf8 (name);\n\t/*g_print (\"requested type %s in %s\\n\", str, assembly->assembly->aname.name);*/\n\tif (!mono_reflection_parse_type (str, &info)) {\n\t\tg_free (str);\n\t\tmono_reflection_free_type_info (&info);\n\t\tif (throwOnError) /* uhm: this is a parse error, though... */\n\t\t\tmono_raise_exception (mono_get_exception_type_load (name, NULL));\n\t\t/*g_print (\"failed parse\\n\");*/\n\t\treturn NULL;\n\t}\n\n\tif (info.assembly.name) {\n\t\tg_free (str);\n\t\tmono_reflection_free_type_info (&info);\n\t\tif (throwOnError) {\n\t\t\t/* 1.0 and 2.0 throw different exceptions */\n\t\t\tif (mono_defaults.generic_ilist_class)\n\t\t\t\tmono_raise_exception (mono_get_exception_argument (NULL, \"Type names passed to Assembly.GetType() must not specify an assembly.\"));\n\t\t\telse\n\t\t\t\tmono_raise_exception (mono_get_exception_type_load (name, NULL));\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (module != NULL) {\n\t\tif (module->image)\n\t\t\ttype = mono_reflection_get_type (module->image, &info, ignoreCase, &type_resolve);\n\t\telse\n\t\t\ttype = NULL;\n\t}\n\telse\n\t\tif (assembly->assembly->dynamic) {\n\t\t\t/* Enumerate all modules */\n\t\t\tMonoReflectionAssemblyBuilder *abuilder = (MonoReflectionAssemblyBuilder*)assembly;\n\t\t\tint i;\n\n\t\t\ttype = NULL;\n\t\t\tif (abuilder->modules) {\n\t\t\t\tfor (i = 0; i < mono_array_length (abuilder->modules); ++i) {\n\t\t\t\t\tMonoReflectionModuleBuilder *mb = mono_array_get (abuilder->modules, MonoReflectionModuleBuilder*, i);\n\t\t\t\t\ttype = mono_reflection_get_type (&mb->dynamic_image->image, &info, ignoreCase, &type_resolve);\n\t\t\t\t\tif (type)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!type && abuilder->loaded_modules) {\n\t\t\t\tfor (i = 0; i < mono_array_length (abuilder->loaded_modules); ++i) {\n\t\t\t\t\tMonoReflectionModule *mod = mono_array_get (abuilder->loaded_modules, MonoReflectionModule*, i);\n\t\t\t\t\ttype = mono_reflection_get_type (mod->image, &info, ignoreCase, &type_resolve);\n\t\t\t\t\tif (type)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\ttype = mono_reflection_get_type (assembly->assembly->image, &info, ignoreCase, &type_resolve);\n\tg_free (str);\n\tmono_reflection_free_type_info (&info);\n\tif (!type) {\n\t\tMonoException *e = NULL;\n\t\t\n\t\tif (throwOnError)\n\t\t\te = mono_get_exception_type_load (name, NULL);\n\n\t\tif (mono_loader_get_last_error () && mono_defaults.generic_ilist_class)\n\t\t\te = mono_loader_error_prepare_exception (mono_loader_get_last_error ());\n\n\t\tmono_loader_clear_error ();\n\n\t\tif (e != NULL)\n\t\t\tmono_raise_exception (e);\n\n\t\treturn NULL;\n\t}\n\n\tif (type->type == MONO_TYPE_CLASS) {\n\t\tMonoClass *klass = mono_type_get_class (type);\n\n\t\tif (mono_is_security_manager_active () && !klass->exception_type)\n\t\t\t/* Some security problems are detected during generic vtable construction */\n\t\t\tmono_class_setup_vtable (klass);\n\t\t/* need to report exceptions ? */\n\t\tif (throwOnError && klass->exception_type) {\n\t\t\t/* report SecurityException (or others) that occured when loading the assembly */\n\t\t\tMonoException *exc = mono_class_get_exception_for_failure (klass);\n\t\t\tmono_loader_clear_error ();\n\t\t\tmono_raise_exception (exc);\n\t\t} else if (klass->exception_type == MONO_EXCEPTION_SECURITY_INHERITANCEDEMAND) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* g_print (\"got it\\n\"); */\n\treturn mono_type_get_object (mono_object_domain (assembly), type);\n}\n\nstatic gboolean\nreplace_shadow_path (MonoDomain *domain, gchar *dirname, gchar **filename)\n{\n\tgchar *content;\n\tgchar *shadow_ini_file;\n\tgsize len;\n\n\t/* Check for shadow-copied assembly */\n\tif (mono_is_shadow_copy_enabled (domain, dirname)) {\n\t\tshadow_ini_file = g_build_filename (dirname, \"__AssemblyInfo__.ini\", NULL);\n\t\tcontent = NULL;\n\t\tif (!g_file_get_contents (shadow_ini_file, &content, &len, NULL) ||\n\t\t\t!g_file_test (content, G_FILE_TEST_IS_REGULAR)) {\n\t\t\tif (content) {\n\t\t\t\tg_free (content);\n\t\t\t\tcontent = NULL;\n\t\t\t}\n\t\t}\n\t\tg_free (shadow_ini_file);\n\t\tif (content != NULL) {\n\t\t\tif (*filename)\n\t\t\t\tg_free (*filename);\n\t\t\t*filename = content;\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\nstatic MonoString *\nves_icall_System_Reflection_Assembly_get_code_base (MonoReflectionAssembly *assembly, MonoBoolean escaped)\n{\n\tMonoDomain *domain = mono_object_domain (assembly); \n\tMonoAssembly *mass = assembly->assembly;\n\tMonoString *res = NULL;\n\tgchar *uri;\n\tgchar *absolute;\n\tgchar *dirname;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (g_path_is_absolute (mass->image->name)) {\n\t\tabsolute = g_strdup (mass->image->name);\n\t\tdirname = g_path_get_dirname (absolute);\n\t} else {\n\t\tabsolute = g_build_filename (mass->basedir, mass->image->name, NULL);\n\t\tdirname = g_strdup (mass->basedir);\n\t}\n\n\treplace_shadow_path (domain, dirname, &absolute);\n\tg_free (dirname);\n#if PLATFORM_WIN32\n\t{\n\t\tgint i;\n\t\tfor (i = strlen (absolute) - 1; i >= 0; i--)\n\t\t\tif (absolute [i] == '\\\\')\n\t\t\t\tabsolute [i] = '/';\n\t}\n#endif\n\tif (escaped) {\n\t\turi = g_filename_to_uri (absolute, NULL, NULL);\n\t} else {\n\t\tconst char *prepend = \"file://\";\n#if PLATFORM_WIN32\n\t\tif (*absolute == '/' && *(absolute + 1) == '/') {\n\t\t\tprepend = \"file:\";\n\t\t} else {\n\t\t\tprepend = \"file:///\";\n\t\t}\n#endif\n\t\turi = g_strconcat (prepend, absolute, NULL);\n\t}\n\n\tif (uri) {\n\t\tres = mono_string_new (domain, uri);\n\t\tg_free (uri);\n\t}\n\tg_free (absolute);\n\treturn res;\n}\n\nstatic MonoBoolean\nves_icall_System_Reflection_Assembly_get_global_assembly_cache (MonoReflectionAssembly *assembly)\n{\n\tMonoAssembly *mass = assembly->assembly;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mass->in_gac;\n}\n\nstatic MonoReflectionAssembly*\nves_icall_System_Reflection_Assembly_load_with_partial_name (MonoString *mname, MonoObject *evidence)\n{\n\tgchar *name;\n\tMonoAssembly *res;\n\tMonoImageOpenStatus status;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tname = mono_string_to_utf8 (mname);\n\tres = mono_assembly_load_with_partial_name (name, &status);\n\n\tg_free (name);\n\n\tif (res == NULL)\n\t\treturn NULL;\n\treturn mono_assembly_get_object (mono_domain_get (), res);\n}\n\nstatic MonoString *\nves_icall_System_Reflection_Assembly_get_location (MonoReflectionAssembly *assembly)\n{\n\tMonoDomain *domain = mono_object_domain (assembly); \n\tMonoString *res;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tres = mono_string_new (domain, mono_image_get_filename (assembly->assembly->image));\n\n\treturn res;\n}\n\nstatic MonoBoolean\nves_icall_System_Reflection_Assembly_get_ReflectionOnly (MonoReflectionAssembly *assembly)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn assembly->assembly->ref_only;\n}\n\nstatic MonoString *\nves_icall_System_Reflection_Assembly_InternalImageRuntimeVersion (MonoReflectionAssembly *assembly)\n{\n\tMonoDomain *domain = mono_object_domain (assembly); \n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_string_new (domain, assembly->assembly->image->version);\n}\n\nstatic MonoReflectionMethod*\nves_icall_System_Reflection_Assembly_get_EntryPoint (MonoReflectionAssembly *assembly) \n{\n\tguint32 token = mono_image_get_entry_point (assembly->assembly->image);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!token)\n\t\treturn NULL;\n\treturn mono_method_get_object (mono_object_domain (assembly), mono_get_method (assembly->assembly->image, token, NULL), NULL);\n}\n\nstatic MonoReflectionModule*\nves_icall_System_Reflection_Assembly_GetManifestModuleInternal (MonoReflectionAssembly *assembly) \n{\n\treturn mono_module_get_object (mono_object_domain (assembly), assembly->assembly->image);\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Assembly_GetManifestResourceNames (MonoReflectionAssembly *assembly) \n{\n\tMonoTableInfo *table = &assembly->assembly->image->tables [MONO_TABLE_MANIFESTRESOURCE];\n\tMonoArray *result = mono_array_new (mono_object_domain (assembly), mono_defaults.string_class, table->rows);\n\tint i;\n\tconst char *val;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tval = mono_metadata_string_heap (assembly->assembly->image, mono_metadata_decode_row_col (table, i, MONO_MANIFEST_NAME));\n\t\tmono_array_setref (result, i, mono_string_new (mono_object_domain (assembly), val));\n\t}\n\treturn result;\n}\n\nstatic MonoObject*\ncreate_version (MonoDomain *domain, guint32 major, guint32 minor, guint32 build, guint32 revision)\n{\n\tstatic MonoClass *System_Version = NULL;\n\tstatic MonoMethod *create_version = NULL;\n\tMonoObject *result;\n\tgpointer args [4];\n\t\n\tif (!System_Version) {\n\t\tSystem_Version = mono_class_from_name (mono_defaults.corlib, \"System\", \"Version\");\n\t\tg_assert (System_Version);\n\t}\n\n\tif (!create_version) {\n\t\tMonoMethodDesc *desc = mono_method_desc_new (\":.ctor(int,int,int,int)\", FALSE);\n\t\tcreate_version = mono_method_desc_search_in_class (desc, System_Version);\n\t\tg_assert (create_version);\n\t\tmono_method_desc_free (desc);\n\t}\n\n\targs [0] = &major;\n\targs [1] = &minor;\n\targs [2] = &build;\n\targs [3] = &revision;\n\tresult = mono_object_new (domain, System_Version);\n\tmono_runtime_invoke (create_version, result, args, NULL);\n\n\treturn result;\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Assembly_GetReferencedAssemblies (MonoReflectionAssembly *assembly) \n{\n\tstatic MonoClass *System_Reflection_AssemblyName;\n\tMonoArray *result;\n\tMonoDomain *domain = mono_object_domain (assembly);\n\tint i, count = 0;\n\tstatic MonoMethod *create_culture = NULL;\n\tMonoImage *image = assembly->assembly->image;\n\tMonoTableInfo *t;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!System_Reflection_AssemblyName)\n\t\tSystem_Reflection_AssemblyName = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"AssemblyName\");\n\n\tt = &assembly->assembly->image->tables [MONO_TABLE_ASSEMBLYREF];\n\tcount = t->rows;\n\n\tresult = mono_array_new (domain, System_Reflection_AssemblyName, count);\n\n\tif (count > 0 && !create_culture) {\n\t\tMonoMethodDesc *desc = mono_method_desc_new (\n\t\t\t\"System.Globalization.CultureInfo:CreateCulture(string,bool)\", TRUE);\n\t\tcreate_culture = mono_method_desc_search_in_image (desc, mono_defaults.corlib);\n\t\tg_assert (create_culture);\n\t\tmono_method_desc_free (desc);\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionAssemblyName *aname;\n\t\tguint32 cols [MONO_ASSEMBLYREF_SIZE];\n\n\t\tmono_metadata_decode_row (t, i, cols, MONO_ASSEMBLYREF_SIZE);\n\n\t\taname = (MonoReflectionAssemblyName *) mono_object_new (\n\t\t\tdomain, System_Reflection_AssemblyName);\n\n\t\tMONO_OBJECT_SETREF (aname, name, mono_string_new (domain, mono_metadata_string_heap (image, cols [MONO_ASSEMBLYREF_NAME])));\n\n\t\taname->major = cols [MONO_ASSEMBLYREF_MAJOR_VERSION];\n\t\taname->minor = cols [MONO_ASSEMBLYREF_MINOR_VERSION];\n\t\taname->build = cols [MONO_ASSEMBLYREF_BUILD_NUMBER];\n\t\taname->revision = cols [MONO_ASSEMBLYREF_REV_NUMBER];\n\t\taname->flags = cols [MONO_ASSEMBLYREF_FLAGS];\n\t\taname->versioncompat = 1; /* SameMachine (default) */\n\t\taname->hashalg = ASSEMBLY_HASH_SHA1; /* SHA1 (default) */\n\t\tMONO_OBJECT_SETREF (aname, version, create_version (domain, aname->major, aname->minor, aname->build, aname->revision));\n\n\t\tif (create_culture) {\n\t\t\tgpointer args [2];\n\t\t\tMonoBoolean assembly_ref = 1;\n\t\t\targs [0] = mono_string_new (domain, mono_metadata_string_heap (image, cols [MONO_ASSEMBLYREF_CULTURE]));\n\t\t\targs [1] = &assembly_ref;\n\t\t\tMONO_OBJECT_SETREF (aname, cultureInfo, mono_runtime_invoke (create_culture, NULL, args, NULL));\n\t\t}\n\t\t\n\t\tif (cols [MONO_ASSEMBLYREF_PUBLIC_KEY]) {\n\t\t\tconst gchar *pkey_ptr = mono_metadata_blob_heap (image, cols [MONO_ASSEMBLYREF_PUBLIC_KEY]);\n\t\t\tguint32 pkey_len = mono_metadata_decode_blob_size (pkey_ptr, &pkey_ptr);\n\n\t\t\tif ((cols [MONO_ASSEMBLYREF_FLAGS] & ASSEMBLYREF_FULL_PUBLIC_KEY_FLAG)) {\n\t\t\t\t/* public key token isn't copied - the class library will \n\t\t   \t\tautomatically generate it from the public key if required */\n\t\t\t\tMONO_OBJECT_SETREF (aname, publicKey, mono_array_new (domain, mono_defaults.byte_class, pkey_len));\n\t\t\t\tmemcpy (mono_array_addr (aname->publicKey, guint8, 0), pkey_ptr, pkey_len);\n\t\t\t} else {\n\t\t\t\tMONO_OBJECT_SETREF (aname, keyToken, mono_array_new (domain, mono_defaults.byte_class, pkey_len));\n\t\t\t\tmemcpy (mono_array_addr (aname->keyToken, guint8, 0), pkey_ptr, pkey_len);\n\t\t\t}\n\t\t} else {\n\t\t\tMONO_OBJECT_SETREF (aname, keyToken, mono_array_new (domain, mono_defaults.byte_class, 0));\n\t\t}\n\t\t\n\t\t/* note: this function doesn't return the codebase on purpose (i.e. it can\n\t\t         be used under partial trust as path information isn't present). */\n\n\t\tmono_array_setref (result, i, aname);\n\t}\n\treturn result;\n}\n\ntypedef struct {\n\tMonoArray *res;\n\tint idx;\n} NameSpaceInfo;\n\nstatic void\nforeach_namespace (const char* key, gconstpointer val, NameSpaceInfo *info)\n{\n\tMonoString *name = mono_string_new (mono_object_domain (info->res), key);\n\n\tmono_array_setref (info->res, info->idx, name);\n\tinfo->idx++;\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Assembly_GetNamespaces (MonoReflectionAssembly *assembly) \n{\n\tMonoImage *img = assembly->assembly->image;\n\tMonoArray *res;\n\tNameSpaceInfo info;\n\tint len;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_image_lock (img);\n\tmono_image_init_name_cache (img);\n\nRETRY_LEN:\n\tlen = g_hash_table_size (img->name_cache);\n\tmono_image_unlock (img);\n\n\t/*we can't create objects holding the image lock */\n\tres = mono_array_new (mono_object_domain (assembly), mono_defaults.string_class, len);\n\n\tmono_image_lock (img);\n\t/*len might have changed, create a new array*/\n\tif (len != g_hash_table_size (img->name_cache))\n\t\tgoto RETRY_LEN;\n\n\tinfo.res = res;\n\tinfo.idx = 0;\n\tg_hash_table_foreach (img->name_cache, (GHFunc)foreach_namespace, &info);\n\tmono_image_unlock (img);\n\n\treturn res;\n}\n\n/* move this in some file in mono/util/ */\nstatic char *\ng_concat_dir_and_file (const char *dir, const char *file)\n{\n\tg_return_val_if_fail (dir != NULL, NULL);\n\tg_return_val_if_fail (file != NULL, NULL);\n\n        /*\n\t * If the directory name doesn't have a / on the end, we need\n\t * to add one so we get a proper path to the file\n\t */\n\tif (dir [strlen(dir) - 1] != G_DIR_SEPARATOR)\n\t\treturn g_strconcat (dir, G_DIR_SEPARATOR_S, file, NULL);\n\telse\n\t\treturn g_strconcat (dir, file, NULL);\n}\n\nstatic void *\nves_icall_System_Reflection_Assembly_GetManifestResourceInternal (MonoReflectionAssembly *assembly, MonoString *name, gint32 *size, MonoReflectionModule **ref_module) \n{\n\tchar *n = mono_string_to_utf8 (name);\n\tMonoTableInfo *table = &assembly->assembly->image->tables [MONO_TABLE_MANIFESTRESOURCE];\n\tguint32 i;\n\tguint32 cols [MONO_MANIFEST_SIZE];\n\tguint32 impl, file_idx;\n\tconst char *val;\n\tMonoImage *module;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tmono_metadata_decode_row (table, i, cols, MONO_MANIFEST_SIZE);\n\t\tval = mono_metadata_string_heap (assembly->assembly->image, cols [MONO_MANIFEST_NAME]);\n\t\tif (strcmp (val, n) == 0)\n\t\t\tbreak;\n\t}\n\tg_free (n);\n\tif (i == table->rows)\n\t\treturn NULL;\n\t/* FIXME */\n\timpl = cols [MONO_MANIFEST_IMPLEMENTATION];\n\tif (impl) {\n\t\t/*\n\t\t * this code should only be called after obtaining the \n\t\t * ResourceInfo and handling the other cases.\n\t\t */\n\t\tg_assert ((impl & MONO_IMPLEMENTATION_MASK) == MONO_IMPLEMENTATION_FILE);\n\t\tfile_idx = impl >> MONO_IMPLEMENTATION_BITS;\n\n\t\tmodule = mono_image_load_file_for_image (assembly->assembly->image, file_idx);\n\t\tif (!module)\n\t\t\treturn NULL;\n\t}\n\telse\n\t\tmodule = assembly->assembly->image;\n\n\tmono_gc_wbarrier_generic_store (ref_module, (MonoObject*) mono_module_get_object (mono_domain_get (), module));\n\n\treturn (void*)mono_image_get_resource (module, cols [MONO_MANIFEST_OFFSET], (guint32*)size);\n}\n\nstatic gboolean\nves_icall_System_Reflection_Assembly_GetManifestResourceInfoInternal (MonoReflectionAssembly *assembly, MonoString *name, MonoManifestResourceInfo *info)\n{\n\tMonoTableInfo *table = &assembly->assembly->image->tables [MONO_TABLE_MANIFESTRESOURCE];\n\tint i;\n\tguint32 cols [MONO_MANIFEST_SIZE];\n\tguint32 file_cols [MONO_FILE_SIZE];\n\tconst char *val;\n\tchar *n;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tn = mono_string_to_utf8 (name);\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tmono_metadata_decode_row (table, i, cols, MONO_MANIFEST_SIZE);\n\t\tval = mono_metadata_string_heap (assembly->assembly->image, cols [MONO_MANIFEST_NAME]);\n\t\tif (strcmp (val, n) == 0)\n\t\t\tbreak;\n\t}\n\tg_free (n);\n\tif (i == table->rows)\n\t\treturn FALSE;\n\n\tif (!cols [MONO_MANIFEST_IMPLEMENTATION]) {\n\t\tinfo->location = RESOURCE_LOCATION_EMBEDDED | RESOURCE_LOCATION_IN_MANIFEST;\n\t}\n\telse {\n\t\tswitch (cols [MONO_MANIFEST_IMPLEMENTATION] & MONO_IMPLEMENTATION_MASK) {\n\t\tcase MONO_IMPLEMENTATION_FILE:\n\t\t\ti = cols [MONO_MANIFEST_IMPLEMENTATION] >> MONO_IMPLEMENTATION_BITS;\n\t\t\ttable = &assembly->assembly->image->tables [MONO_TABLE_FILE];\n\t\t\tmono_metadata_decode_row (table, i - 1, file_cols, MONO_FILE_SIZE);\n\t\t\tval = mono_metadata_string_heap (assembly->assembly->image, file_cols [MONO_FILE_NAME]);\n\t\t\tMONO_OBJECT_SETREF (info, filename, mono_string_new (mono_object_domain (assembly), val));\n\t\t\tif (file_cols [MONO_FILE_FLAGS] && FILE_CONTAINS_NO_METADATA)\n\t\t\t\tinfo->location = 0;\n\t\t\telse\n\t\t\t\tinfo->location = RESOURCE_LOCATION_EMBEDDED;\n\t\t\tbreak;\n\n\t\tcase MONO_IMPLEMENTATION_ASSEMBLYREF:\n\t\t\ti = cols [MONO_MANIFEST_IMPLEMENTATION] >> MONO_IMPLEMENTATION_BITS;\n\t\t\tmono_assembly_load_reference (assembly->assembly->image, i - 1);\n\t\t\tif (assembly->assembly->image->references [i - 1] == (gpointer)-1) {\n\t\t\t\tchar *msg = g_strdup_printf (\"Assembly %d referenced from assembly %s not found \", i - 1, assembly->assembly->image->name);\n\t\t\t\tMonoException *ex = mono_get_exception_file_not_found2 (msg, NULL);\n\t\t\t\tg_free (msg);\n\t\t\t\tmono_raise_exception (ex);\n\t\t\t}\n\t\t\tMONO_OBJECT_SETREF (info, assembly, mono_assembly_get_object (mono_domain_get (), assembly->assembly->image->references [i - 1]));\n\n\t\t\t/* Obtain info recursively */\n\t\t\tves_icall_System_Reflection_Assembly_GetManifestResourceInfoInternal (info->assembly, name, info);\n\t\t\tinfo->location |= RESOURCE_LOCATION_ANOTHER_ASSEMBLY;\n\t\t\tbreak;\n\n\t\tcase MONO_IMPLEMENTATION_EXP_TYPE:\n\t\t\tg_assert_not_reached ();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic MonoObject*\nves_icall_System_Reflection_Assembly_GetFilesInternal (MonoReflectionAssembly *assembly, MonoString *name, MonoBoolean resource_modules) \n{\n\tMonoTableInfo *table = &assembly->assembly->image->tables [MONO_TABLE_FILE];\n\tMonoArray *result = NULL;\n\tint i, count;\n\tconst char *val;\n\tchar *n;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t/* check hash if needed */\n\tif (name) {\n\t\tn = mono_string_to_utf8 (name);\n\t\tfor (i = 0; i < table->rows; ++i) {\n\t\t\tval = mono_metadata_string_heap (assembly->assembly->image, mono_metadata_decode_row_col (table, i, MONO_FILE_NAME));\n\t\t\tif (strcmp (val, n) == 0) {\n\t\t\t\tMonoString *fn;\n\t\t\t\tg_free (n);\n\t\t\t\tn = g_concat_dir_and_file (assembly->assembly->basedir, val);\n\t\t\t\tfn = mono_string_new (mono_object_domain (assembly), n);\n\t\t\t\tg_free (n);\n\t\t\t\treturn (MonoObject*)fn;\n\t\t\t}\n\t\t}\n\t\tg_free (n);\n\t\treturn NULL;\n\t}\n\n\tcount = 0;\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tif (resource_modules || !(mono_metadata_decode_row_col (table, i, MONO_FILE_FLAGS) & FILE_CONTAINS_NO_METADATA))\n\t\t\tcount ++;\n\t}\n\n\tresult = mono_array_new (mono_object_domain (assembly), mono_defaults.string_class, count);\n\n\tcount = 0;\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tif (resource_modules || !(mono_metadata_decode_row_col (table, i, MONO_FILE_FLAGS) & FILE_CONTAINS_NO_METADATA)) {\n\t\t\tval = mono_metadata_string_heap (assembly->assembly->image, mono_metadata_decode_row_col (table, i, MONO_FILE_NAME));\n\t\t\tn = g_concat_dir_and_file (assembly->assembly->basedir, val);\n\t\t\tmono_array_setref (result, count, mono_string_new (mono_object_domain (assembly), n));\n\t\t\tg_free (n);\n\t\t\tcount ++;\n\t\t}\n\t}\n\treturn (MonoObject*)result;\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Assembly_GetModulesInternal (MonoReflectionAssembly *assembly)\n{\n\tMonoDomain *domain = mono_domain_get();\n\tMonoArray *res;\n\tMonoClass *klass;\n\tint i, j, file_count = 0;\n\tMonoImage **modules;\n\tguint32 module_count, real_module_count;\n\tMonoTableInfo *table;\n\tguint32 cols [MONO_FILE_SIZE];\n\tMonoImage *image = assembly->assembly->image;\n\n\tg_assert (image != NULL);\n\tg_assert (!assembly->assembly->dynamic);\n\n\ttable = &image->tables [MONO_TABLE_FILE];\n\tfile_count = table->rows;\n\n\tmodules = image->modules;\n\tmodule_count = image->module_count;\n\n\treal_module_count = 0;\n\tfor (i = 0; i < module_count; ++i)\n\t\tif (modules [i])\n\t\t\treal_module_count ++;\n\n\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"Module\");\n\tres = mono_array_new (domain, klass, 1 + real_module_count + file_count);\n\n\tmono_array_setref (res, 0, mono_module_get_object (domain, image));\n\tj = 1;\n\tfor (i = 0; i < module_count; ++i)\n\t\tif (modules [i]) {\n\t\t\tmono_array_setref (res, j, mono_module_get_object (domain, modules[i]));\n\t\t\t++j;\n\t\t}\n\n\tfor (i = 0; i < file_count; ++i, ++j) {\n\t\tmono_metadata_decode_row (table, i, cols, MONO_FILE_SIZE);\n\t\tif (cols [MONO_FILE_FLAGS] && FILE_CONTAINS_NO_METADATA)\n\t\t\tmono_array_setref (res, j, mono_module_file_get_object (domain, image, i));\n\t\telse {\n\t\t\tMonoImage *m = mono_image_load_file_for_image (image, i + 1);\n\t\t\tif (!m) {\n\t\t\t\tMonoString *fname = mono_string_new (mono_domain_get (), mono_metadata_string_heap (image, cols [MONO_FILE_NAME]));\n\t\t\t\tmono_raise_exception (mono_get_exception_file_not_found2 (NULL, fname));\n\t\t\t}\n\t\t\tmono_array_setref (res, j, mono_module_get_object (domain, m));\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic MonoReflectionMethod*\nves_icall_GetCurrentMethod (void) \n{\n\tMonoMethod *m = mono_method_get_last_managed ();\n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_method_get_object (mono_domain_get (), m, NULL);\n}\n\n\nstatic MonoMethod*\nmono_method_get_equivalent_method (MonoMethod *method, MonoClass *klass)\n{\n\tint offset = -1, i;\n\tif (method->is_inflated && ((MonoMethodInflated*)method)->context.method_inst) {\n\t\tMonoMethodInflated *inflated = (MonoMethodInflated*)method;\n\t\t//method is inflated, we should inflate it on the other class\n\t\tMonoGenericContext ctx;\n\t\tctx.method_inst = inflated->context.method_inst;\n\t\tctx.class_inst = inflated->context.class_inst;\n\t\tif (klass->generic_class)\n\t\t\tctx.class_inst = klass->generic_class->context.class_inst;\n\t\telse if (klass->generic_container)\n\t\t\tctx.class_inst = klass->generic_container->context.class_inst;\n\t\treturn mono_class_inflate_generic_method_full (inflated->declaring, klass, &ctx);\n\t}\n\n\tmono_class_setup_methods (method->klass);\n\tif (method->klass->exception_type)\n\t\treturn NULL;\n\tfor (i = 0; i < method->klass->method.count; ++i) {\n\t\tif (method->klass->methods [i] == method) {\n\t\t\toffset = i;\n\t\t\tbreak;\n\t\t}\t\n\t}\n\tmono_class_setup_methods (klass);\n\tif (klass->exception_type)\n\t\treturn NULL;\n\tg_assert (offset >= 0 && offset < klass->method.count);\n\treturn klass->methods [offset];\n}\n\nstatic MonoReflectionMethod*\nves_icall_System_Reflection_MethodBase_GetMethodFromHandleInternalType (MonoMethod *method, MonoType *type)\n{\n\tMonoClass *klass;\n\tif (type) {\n\t\tklass = mono_class_from_mono_type (type);\n\t\tif (mono_class_get_generic_type_definition (method->klass) != mono_class_get_generic_type_definition (klass)) \n\t\t\treturn NULL;\n\t\tif (method->klass != klass) {\n\t\t\tmethod = mono_method_get_equivalent_method (method, klass);\n\t\t\tif (!method)\n\t\t\t\treturn NULL;\n\t\t}\n\t} else\n\t\tklass = method->klass;\n\treturn mono_method_get_object (mono_domain_get (), method, klass);\n}\n\nstatic MonoReflectionMethod*\nves_icall_System_Reflection_MethodBase_GetMethodFromHandleInternal (MonoMethod *method)\n{\n\treturn mono_method_get_object (mono_domain_get (), method, NULL);\n}\n\nstatic MonoReflectionMethodBody*\nves_icall_System_Reflection_MethodBase_GetMethodBodyInternal (MonoMethod *method)\n{\n\treturn mono_method_body_get_object (mono_domain_get (), method);\n}\n\nstatic MonoReflectionAssembly*\nves_icall_System_Reflection_Assembly_GetExecutingAssembly (void)\n{\n\tMonoMethod *dest = NULL;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_stack_walk_no_il (get_executing, &dest);\n\treturn mono_assembly_get_object (mono_domain_get (), dest->klass->image->assembly);\n}\n\n\nstatic MonoReflectionAssembly*\nves_icall_System_Reflection_Assembly_GetEntryAssembly (void)\n{\n\tMonoDomain* domain = mono_domain_get ();\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!domain->entry_assembly)\n\t\treturn NULL;\n\n\treturn mono_assembly_get_object (domain, domain->entry_assembly);\n}\n\nstatic MonoReflectionAssembly*\nves_icall_System_Reflection_Assembly_GetCallingAssembly (void)\n{\n\tMonoMethod *m;\n\tMonoMethod *dest;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tdest = NULL;\n\tmono_stack_walk_no_il (get_executing, &dest);\n\tm = dest;\n\tmono_stack_walk_no_il (get_caller, &dest);\n\tif (!dest)\n\t\tdest = m;\n\treturn mono_assembly_get_object (mono_domain_get (), dest->klass->image->assembly);\n}\n\nstatic MonoString *\nves_icall_System_MonoType_getFullName (MonoReflectionType *object, gboolean full_name,\n\t\t\t\t       gboolean assembly_qualified)\n{\n\tMonoDomain *domain = mono_object_domain (object); \n\tMonoTypeNameFormat format;\n\tMonoString *res;\n\tgchar *name;\n\n\tMONO_ARCH_SAVE_REGS;\n\tif (full_name)\n\t\tformat = assembly_qualified ?\n\t\t\tMONO_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED :\n\t\t\tMONO_TYPE_NAME_FORMAT_FULL_NAME;\n\telse\n\t\tformat = MONO_TYPE_NAME_FORMAT_REFLECTION;\n \n\tname = mono_type_get_name_full (object->type, format);\n\tif (!name)\n\t\treturn NULL;\n\n\tif (full_name && (object->type->type == MONO_TYPE_VAR || object->type->type == MONO_TYPE_MVAR)) {\n\t\tg_free (name);\n\t\treturn NULL;\n\t}\n\n\tres = mono_string_new (domain, name);\n\tg_free (name);\n\n\treturn res;\n}\n\nstatic void\nfill_reflection_assembly_name (MonoDomain *domain, MonoReflectionAssemblyName *aname, MonoAssemblyName *name, const char *absolute, gboolean by_default_version, gboolean default_publickey, gboolean default_token)\n{\n\tstatic MonoMethod *create_culture = NULL;\n\tgpointer args [2];\n\tguint32 pkey_len;\n\tconst char *pkey_ptr;\n\tgchar *codebase;\n\tMonoBoolean assembly_ref = 0;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_OBJECT_SETREF (aname, name, mono_string_new (domain, name->name));\n\taname->major = name->major;\n\taname->minor = name->minor;\n\taname->build = name->build;\n\taname->flags = name->flags;\n\taname->revision = name->revision;\n\taname->hashalg = name->hash_alg;\n\taname->versioncompat = 1; /* SameMachine (default) */\n\n\tif (by_default_version)\n\t\tMONO_OBJECT_SETREF (aname, version, create_version (domain, name->major, name->minor, name->build, name->revision));\n\n\tcodebase = NULL;\n\tif (absolute != NULL && *absolute != '\\0') {\n\t\tconst gchar *prepend = \"file://\";\n\t\tgchar *result;\n\n\t\tcodebase = g_strdup (absolute);\n\n#if PLATFORM_WIN32\n\t\t{\n\t\t\tgint i;\n\t\t\tfor (i = strlen (codebase) - 1; i >= 0; i--)\n\t\t\t\tif (codebase [i] == '\\\\')\n\t\t\t\t\tcodebase [i] = '/';\n\n\t\t\tif (*codebase == '/' && *(codebase + 1) == '/') {\n\t\t\t\tprepend = \"file:\";\n\t\t\t} else {\n\t\t\t\tprepend = \"file:///\";\n\t\t\t}\n\t\t}\n#endif\n\t\tresult = g_strconcat (prepend, codebase, NULL);\n\t\tg_free (codebase);\n\t\tcodebase = result;\n\t}\n\n\tif (codebase) {\n\t\tMONO_OBJECT_SETREF (aname, codebase, mono_string_new (domain, codebase));\n\t\tg_free (codebase);\n\t}\n\n\tif (!create_culture) {\n\t\tMonoMethodDesc *desc = mono_method_desc_new (\"System.Globalization.CultureInfo:CreateCulture(string,bool)\", TRUE);\n\t\tcreate_culture = mono_method_desc_search_in_image (desc, mono_defaults.corlib);\n\t\tg_assert (create_culture);\n\t\tmono_method_desc_free (desc);\n\t}\n\n\tif (name->culture) {\n\t\targs [0] = mono_string_new (domain, name->culture);\n\t\targs [1] = &assembly_ref;\n\t\tMONO_OBJECT_SETREF (aname, cultureInfo, mono_runtime_invoke (create_culture, NULL, args, NULL));\n\t}\n\n\tif (name->public_key) {\n\t\tpkey_ptr = (char*)name->public_key;\n\t\tpkey_len = mono_metadata_decode_blob_size (pkey_ptr, &pkey_ptr);\n\n\t\tMONO_OBJECT_SETREF (aname, publicKey, mono_array_new (domain, mono_defaults.byte_class, pkey_len));\n\t\tmemcpy (mono_array_addr (aname->publicKey, guint8, 0), pkey_ptr, pkey_len);\n\t\taname->flags |= ASSEMBLYREF_FULL_PUBLIC_KEY_FLAG;\n\t} else if (default_publickey) {\n\t\tMONO_OBJECT_SETREF (aname, publicKey, mono_array_new (domain, mono_defaults.byte_class, 0));\n\t\taname->flags |= ASSEMBLYREF_FULL_PUBLIC_KEY_FLAG;\n\t}\n\n\t/* MonoAssemblyName keeps the public key token as an hexadecimal string */\n\tif (name->public_key_token [0]) {\n\t\tint i, j;\n\t\tchar *p;\n\n\t\tMONO_OBJECT_SETREF (aname, keyToken, mono_array_new (domain, mono_defaults.byte_class, 8));\n\t\tp = mono_array_addr (aname->keyToken, char, 0);\n\n\t\tfor (i = 0, j = 0; i < 8; i++) {\n\t\t\t*p = g_ascii_xdigit_value (name->public_key_token [j++]) << 4;\n\t\t\t*p |= g_ascii_xdigit_value (name->public_key_token [j++]);\n\t\t\tp++;\n\t\t}\n\t} else if (default_token) {\n\t\tMONO_OBJECT_SETREF (aname, keyToken, mono_array_new (domain, mono_defaults.byte_class, 0));\n\t}\n}\n\nstatic MonoString *\nves_icall_System_Reflection_Assembly_get_fullName (MonoReflectionAssembly *assembly)\n{\n\tMonoDomain *domain = mono_object_domain (assembly); \n\tMonoAssembly *mass = assembly->assembly;\n\tMonoString *res;\n\tgchar *name;\n\n\tname = g_strdup_printf (\n\t\t\"%s, Version=%d.%d.%d.%d, Culture=%s, PublicKeyToken=%s%s\",\n\t\tmass->aname.name,\n\t\tmass->aname.major, mass->aname.minor, mass->aname.build, mass->aname.revision,\n\t\tmass->aname.culture && *mass->aname.culture? mass->aname.culture: \"neutral\",\n\t\tmass->aname.public_key_token [0] ? (char *)mass->aname.public_key_token : \"null\",\n\t\t(mass->aname.flags & ASSEMBLYREF_RETARGETABLE_FLAG) ? \", Retargetable=Yes\" : \"\");\n\n\tres = mono_string_new (domain, name);\n\tg_free (name);\n\n\treturn res;\n}\n\nstatic void\nves_icall_System_Reflection_Assembly_FillName (MonoReflectionAssembly *assembly, MonoReflectionAssemblyName *aname)\n{\n\tgchar *absolute;\n\tMonoAssembly *mass = assembly->assembly;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (g_path_is_absolute (mass->image->name)) {\n\t\tfill_reflection_assembly_name (mono_object_domain (assembly),\n\t\t\taname, &mass->aname, mass->image->name, TRUE,\n\t\t\tTRUE, mono_framework_version () >= 2);\n\t\treturn;\n\t}\n\tabsolute = g_build_filename (mass->basedir, mass->image->name, NULL);\n\n\tfill_reflection_assembly_name (mono_object_domain (assembly),\n\t\taname, &mass->aname, absolute, TRUE, TRUE,\n\t\tmono_framework_version () >= 2);\n\n\tg_free (absolute);\n}\n\nstatic void\nves_icall_System_Reflection_Assembly_InternalGetAssemblyName (MonoString *fname, MonoReflectionAssemblyName *aname)\n{\n\tchar *filename;\n\tMonoImageOpenStatus status = MONO_IMAGE_OK;\n\tgboolean res;\n\tMonoImage *image;\n\tMonoAssemblyName name;\n\tchar *dirname\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tfilename = mono_string_to_utf8 (fname);\n\n\tdirname = g_path_get_dirname (filename);\n\treplace_shadow_path (mono_domain_get (), dirname, &filename);\n\tg_free (dirname);\n\n\timage = mono_image_open (filename, &status);\n\n\tif (!image){\n\t\tMonoException *exc;\n\n\t\tg_free (filename);\n\t\tif (status == MONO_IMAGE_IMAGE_INVALID)\n\t\t\texc = mono_get_exception_bad_image_format2 (NULL, fname);\n\t\telse\n\t\t\texc = mono_get_exception_file_not_found2 (NULL, fname);\n\t\tmono_raise_exception (exc);\n\t}\n\n\tres = mono_assembly_fill_assembly_name (image, &name);\n\tif (!res) {\n\t\tmono_image_close (image);\n\t\tg_free (filename);\n\t\tmono_raise_exception (mono_get_exception_argument (\"assemblyFile\", \"The file does not contain a manifest\"));\n\t}\n\n\tfill_reflection_assembly_name (mono_domain_get (), aname, &name, filename,\n\t\tTRUE, mono_framework_version () == 1,\n\t\tmono_framework_version () >= 2);\n\n\tg_free (filename);\n\tmono_image_close (image);\n}\n\nstatic MonoBoolean\nves_icall_System_Reflection_Assembly_LoadPermissions (MonoReflectionAssembly *assembly,\n\tchar **minimum, guint32 *minLength, char **optional, guint32 *optLength, char **refused, guint32 *refLength)\n{\n\tMonoBoolean result = FALSE;\n\tMonoDeclSecurityEntry entry;\n\n\t/* SecurityAction.RequestMinimum */\n\tif (mono_declsec_get_assembly_action (assembly->assembly, SECURITY_ACTION_REQMIN, &entry)) {\n\t\t*minimum = entry.blob;\n\t\t*minLength = entry.size;\n\t\tresult = TRUE;\n\t}\n\t/* SecurityAction.RequestOptional */\n\tif (mono_declsec_get_assembly_action (assembly->assembly, SECURITY_ACTION_REQOPT, &entry)) {\n\t\t*optional = entry.blob;\n\t\t*optLength = entry.size;\n\t\tresult = TRUE;\n\t}\n\t/* SecurityAction.RequestRefuse */\n\tif (mono_declsec_get_assembly_action (assembly->assembly, SECURITY_ACTION_REQREFUSE, &entry)) {\n\t\t*refused = entry.blob;\n\t\t*refLength = entry.size;\n\t\tresult = TRUE;\n\t}\n\n\treturn result;\t\n}\n\nstatic MonoArray*\nmono_module_get_types (MonoDomain *domain, MonoImage *image, MonoArray **exceptions, MonoBoolean exportedOnly)\n{\n\tMonoArray *res;\n\tMonoClass *klass;\n\tMonoTableInfo *tdef = &image->tables [MONO_TABLE_TYPEDEF];\n\tint i, count;\n\tguint32 attrs, visibility;\n\n\t/* we start the count from 1 because we skip the special type <Module> */\n\tif (exportedOnly) {\n\t\tcount = 0;\n\t\tfor (i = 1; i < tdef->rows; ++i) {\n\t\t\tattrs = mono_metadata_decode_row_col (tdef, i, MONO_TYPEDEF_FLAGS);\n\t\t\tvisibility = attrs & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\t\t\tif (visibility == TYPE_ATTRIBUTE_PUBLIC || visibility == TYPE_ATTRIBUTE_NESTED_PUBLIC)\n\t\t\t\tcount++;\n\t\t}\n\t} else {\n\t\tcount = tdef->rows - 1;\n\t}\n\tres = mono_array_new (domain, mono_defaults.monotype_class, count);\n\t*exceptions = mono_array_new (domain, mono_defaults.exception_class, count);\n\tcount = 0;\n\tfor (i = 1; i < tdef->rows; ++i) {\n\t\tattrs = mono_metadata_decode_row_col (tdef, i, MONO_TYPEDEF_FLAGS);\n\t\tvisibility = attrs & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\t\tif (!exportedOnly || (visibility == TYPE_ATTRIBUTE_PUBLIC || visibility == TYPE_ATTRIBUTE_NESTED_PUBLIC)) {\n\t\t\tklass = mono_class_get (image, (i + 1) | MONO_TOKEN_TYPE_DEF);\n\t\t\tif (klass) {\n\t\t\t\tmono_array_setref (res, count, mono_type_get_object (domain, &klass->byval_arg));\n\t\t\t} else {\n\t\t\t\tMonoLoaderError *error;\n\t\t\t\tMonoException *ex;\n\t\t\t\t\n\t\t\t\terror = mono_loader_get_last_error ();\n\t\t\t\tg_assert (error != NULL);\n\t\n\t\t\t\tex = mono_loader_error_prepare_exception (error);\n\t\t\t\tmono_array_setref (*exceptions, count, ex);\n\t\t\t}\n\t\t\tif (mono_loader_get_last_error ())\n\t\t\t\tmono_loader_clear_error ();\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Assembly_GetTypes (MonoReflectionAssembly *assembly, MonoBoolean exportedOnly)\n{\n\tMonoArray *res = NULL;\n\tMonoArray *exceptions = NULL;\n\tMonoImage *image = NULL;\n\tMonoTableInfo *table = NULL;\n\tMonoDomain *domain;\n\tGList *list = NULL;\n\tint i, len, ex_count;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = mono_object_domain (assembly);\n\n\tg_assert (!assembly->assembly->dynamic);\n\timage = assembly->assembly->image;\n\ttable = &image->tables [MONO_TABLE_FILE];\n\tres = mono_module_get_types (domain, image, &exceptions, exportedOnly);\n\n\t/* Append data from all modules in the assembly */\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tif (!(mono_metadata_decode_row_col (table, i, MONO_FILE_FLAGS) & FILE_CONTAINS_NO_METADATA)) {\n\t\t\tMonoImage *loaded_image = mono_assembly_load_module (image->assembly, i + 1);\n\t\t\tif (loaded_image) {\n\t\t\t\tMonoArray *ex2;\n\t\t\t\tMonoArray *res2 = mono_module_get_types (domain, loaded_image, &ex2, exportedOnly);\n\t\t\t\t/* Append the new types to the end of the array */\n\t\t\t\tif (mono_array_length (res2) > 0) {\n\t\t\t\t\tguint32 len1, len2;\n\t\t\t\t\tMonoArray *res3, *ex3;\n\n\t\t\t\t\tlen1 = mono_array_length (res);\n\t\t\t\t\tlen2 = mono_array_length (res2);\n\n\t\t\t\t\tres3 = mono_array_new (domain, mono_defaults.monotype_class, len1 + len2);\n\t\t\t\t\tmono_array_memcpy_refs (res3, 0, res, 0, len1);\n\t\t\t\t\tmono_array_memcpy_refs (res3, len1, res2, 0, len2);\n\t\t\t\t\tres = res3;\n\n\t\t\t\t\tex3 = mono_array_new (domain, mono_defaults.monotype_class, len1 + len2);\n\t\t\t\t\tmono_array_memcpy_refs (ex3, 0, exceptions, 0, len1);\n\t\t\t\t\tmono_array_memcpy_refs (ex3, len1, ex2, 0, len2);\n\t\t\t\t\texceptions = ex3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the ReflectionTypeLoadException must have all the types (Types property), \n\t * NULL replacing types which throws an exception. The LoaderException must\n\t * contain all exceptions for NULL items.\n\t */\n\n\tlen = mono_array_length (res);\n\n\tex_count = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tMonoReflectionType *t = mono_array_get (res, gpointer, i);\n\t\tMonoClass *klass;\n\n\t\tif (t) {\n\t\t\tklass = mono_type_get_class (t->type);\n\t\t\tif ((klass != NULL) && klass->exception_type) {\n\t\t\t\t/* keep the class in the list */\n\t\t\t\tlist = g_list_append (list, klass);\n\t\t\t\t/* and replace Type with NULL */\n\t\t\t\tmono_array_setref (res, i, NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tex_count ++;\n\t\t}\n\t}\n\n\tif (list || ex_count) {\n\t\tGList *tmp = NULL;\n\t\tMonoException *exc = NULL;\n\t\tMonoArray *exl = NULL;\n\t\tint j, length = g_list_length (list) + ex_count;\n\n\t\tmono_loader_clear_error ();\n\n\t\texl = mono_array_new (domain, mono_defaults.exception_class, length);\n\t\t/* Types for which mono_class_get () succeeded */\n\t\tfor (i = 0, tmp = list; tmp; i++, tmp = tmp->next) {\n\t\t\tMonoException *exc = mono_class_get_exception_for_failure (tmp->data);\n\t\t\tmono_array_setref (exl, i, exc);\n\t\t}\n\t\t/* Types for which it don't */\n\t\tfor (j = 0; j < mono_array_length (exceptions); ++j) {\n\t\t\tMonoException *exc = mono_array_get (exceptions, MonoException*, j);\n\t\t\tif (exc) {\n\t\t\t\tg_assert (i < length);\n\t\t\t\tmono_array_setref (exl, i, exc);\n\t\t\t\ti ++;\n\t\t\t}\n\t\t}\n\t\tg_list_free (list);\n\t\tlist = NULL;\n\n\t\texc = mono_get_exception_reflection_type_load (res, exl);\n\t\tmono_loader_clear_error ();\n\t\tmono_raise_exception (exc);\n\t}\n\t\t\n\treturn res;\n}\n\nstatic gboolean\nves_icall_System_Reflection_AssemblyName_ParseName (MonoReflectionAssemblyName *name, MonoString *assname)\n{\n\tMonoAssemblyName aname;\n\tMonoDomain *domain = mono_object_domain (name);\n\tchar *val;\n\tgboolean is_version_defined;\n\tgboolean is_token_defined;\n\n\taname.public_key = NULL;\n\tval = mono_string_to_utf8 (assname);\n\tif (!mono_assembly_name_parse_full (val, &aname, TRUE, &is_version_defined, &is_token_defined)) {\n\t\tg_free ((guint8*) aname.public_key);\n\t\tg_free (val);\n\t\treturn FALSE;\n\t}\n\t\n\tfill_reflection_assembly_name (domain, name, &aname, \"\", is_version_defined,\n\t\tFALSE, is_token_defined);\n\n\tmono_assembly_name_free (&aname);\n\tg_free ((guint8*) aname.public_key);\n\tg_free (val);\n\n\treturn TRUE;\n}\n\nstatic MonoReflectionType*\nves_icall_System_Reflection_Module_GetGlobalType (MonoReflectionModule *module)\n{\n\tMonoDomain *domain = mono_object_domain (module); \n\tMonoClass *klass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_assert (module->image);\n\n\tif (module->image->dynamic && ((MonoDynamicImage*)(module->image))->initial_image)\n\t\t/* These images do not have a global type */\n\t\treturn NULL;\n\n\tklass = mono_class_get (module->image, 1 | MONO_TOKEN_TYPE_DEF);\n\treturn mono_type_get_object (domain, &klass->byval_arg);\n}\n\nstatic void\nves_icall_System_Reflection_Module_Close (MonoReflectionModule *module)\n{\n\t/*if (module->image)\n\t\tmono_image_close (module->image);*/\n}\n\nstatic MonoString*\nves_icall_System_Reflection_Module_GetGuidInternal (MonoReflectionModule *module)\n{\n\tMonoDomain *domain = mono_object_domain (module); \n\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_assert (module->image);\n\treturn mono_string_new (domain, module->image->guid);\n}\n\nstatic gpointer\nves_icall_System_Reflection_Module_GetHINSTANCE (MonoReflectionModule *module)\n{\n#ifdef PLATFORM_WIN32\n\tif (module->image && module->image->is_module_handle)\n\t\treturn module->image->raw_data;\n#endif\n\n\treturn (gpointer) (-1);\n}\n\nstatic void\nves_icall_System_Reflection_Module_GetPEKind (MonoImage *image, gint32 *pe_kind, gint32 *machine)\n{\n\tif (image->dynamic) {\n\t\tMonoDynamicImage *dyn = (MonoDynamicImage*)image;\n\t\t*pe_kind = dyn->pe_kind;\n\t\t*machine = dyn->machine;\n\t}\n\telse {\n\t\t*pe_kind = ((MonoCLIImageInfo*)(image->image_info))->cli_cli_header.ch_flags & 0x3;\n\t\t*machine = ((MonoCLIImageInfo*)(image->image_info))->cli_header.coff.coff_machine;\n\t}\n}\n\nstatic gint32\nves_icall_System_Reflection_Module_GetMDStreamVersion (MonoImage *image)\n{\n\treturn (image->md_version_major << 16) | (image->md_version_minor);\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Module_InternalGetTypes (MonoReflectionModule *module)\n{\n\tMonoArray *exceptions;\n\tint i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!module->image)\n\t\treturn mono_array_new (mono_object_domain (module), mono_defaults.monotype_class, 0);\n\telse {\n\t\tMonoArray *res = mono_module_get_types (mono_object_domain (module), module->image, &exceptions, FALSE);\n\t\tfor (i = 0; i < mono_array_length (exceptions); ++i) {\n\t\t\tMonoException *ex = mono_array_get (exceptions, MonoException *, i);\n\t\t\tif (ex)\n\t\t\t\tmono_raise_exception (ex);\n\t\t}\n\t\treturn res;\n\t}\n}\n\nstatic gboolean\nmono_metadata_memberref_is_method (MonoImage *image, guint32 token)\n{\n\tguint32 cols [MONO_MEMBERREF_SIZE];\n\tconst char *sig;\n\tmono_metadata_decode_row (&image->tables [MONO_TABLE_MEMBERREF], mono_metadata_token_index (token) - 1, cols, MONO_MEMBERREF_SIZE);\n\tsig = mono_metadata_blob_heap (image, cols [MONO_MEMBERREF_SIGNATURE]);\n\tmono_metadata_decode_blob_size (sig, &sig);\n\treturn (*sig != 0x6);\n}\n\nstatic void\ninit_generic_context_from_args (MonoGenericContext *context, MonoArray *type_args, MonoArray *method_args)\n{\n\tif (type_args)\n\t\tcontext->class_inst = mono_metadata_get_generic_inst (mono_array_length (type_args),\n\t\t\t\t\t\t\t\t      mono_array_addr (type_args, MonoType*, 0));\n\telse\n\t\tcontext->class_inst = NULL;\n\tif (method_args)\n\t\tcontext->method_inst = mono_metadata_get_generic_inst (mono_array_length (method_args),\n\t\t\t\t\t\t\t\t       mono_array_addr (method_args, MonoType*, 0));\n\telse\n\t\tcontext->method_inst = NULL;\n}\n\nstatic MonoType*\nves_icall_System_Reflection_Module_ResolveTypeToken (MonoImage *image, guint32 token, MonoArray *type_args, MonoArray *method_args, MonoResolveTokenError *error)\n{\n\tMonoClass *klass;\n\tint table = mono_metadata_token_table (token);\n\tint index = mono_metadata_token_index (token);\n\tMonoGenericContext context;\n\n\t*error = ResolveTokenError_Other;\n\n\t/* Validate token */\n\tif ((table != MONO_TABLE_TYPEDEF) && (table != MONO_TABLE_TYPEREF) && \n\t\t(table != MONO_TABLE_TYPESPEC)) {\n\t\t*error = ResolveTokenError_BadTable;\n\t\treturn NULL;\n\t}\n\n\tif (image->dynamic) {\n\t\tif (type_args || method_args)\n\t\t\tmono_raise_exception (mono_get_exception_not_implemented (NULL));\n\t\tklass = mono_lookup_dynamic_token_class (image, token, FALSE, NULL, NULL);\n\t\tif (!klass)\n\t\t\treturn NULL;\n\t\treturn &klass->byval_arg;\n\t}\n\n\tif ((index <= 0) || (index > image->tables [table].rows)) {\n\t\t*error = ResolveTokenError_OutOfRange;\n\t\treturn NULL;\n\t}\n\n\tinit_generic_context_from_args (&context, type_args, method_args);\n\tklass = mono_class_get_full (image, token, &context);\n\n\tif (mono_loader_get_last_error ())\n\t\tmono_raise_exception (mono_loader_error_prepare_exception (mono_loader_get_last_error ()));\n\n\tif (klass)\n\t\treturn &klass->byval_arg;\n\telse\n\t\treturn NULL;\n}\n\nstatic MonoMethod*\nves_icall_System_Reflection_Module_ResolveMethodToken (MonoImage *image, guint32 token, MonoArray *type_args, MonoArray *method_args, MonoResolveTokenError *error)\n{\n\tint table = mono_metadata_token_table (token);\n\tint index = mono_metadata_token_index (token);\n\tMonoGenericContext context;\n\tMonoMethod *method;\n\n\t*error = ResolveTokenError_Other;\n\n\t/* Validate token */\n\tif ((table != MONO_TABLE_METHOD) && (table != MONO_TABLE_METHODSPEC) && \n\t\t(table != MONO_TABLE_MEMBERREF)) {\n\t\t*error = ResolveTokenError_BadTable;\n\t\treturn NULL;\n\t}\n\n\tif (image->dynamic) {\n\t\tif (type_args || method_args)\n\t\t\tmono_raise_exception (mono_get_exception_not_implemented (NULL));\n\t\t/* FIXME: validate memberref token type */\n\t\treturn mono_lookup_dynamic_token_class (image, token, FALSE, NULL, NULL);\n\t}\n\n\tif ((index <= 0) || (index > image->tables [table].rows)) {\n\t\t*error = ResolveTokenError_OutOfRange;\n\t\treturn NULL;\n\t}\n\tif ((table == MONO_TABLE_MEMBERREF) && (!mono_metadata_memberref_is_method (image, token))) {\n\t\t*error = ResolveTokenError_BadTable;\n\t\treturn NULL;\n\t}\n\n\tinit_generic_context_from_args (&context, type_args, method_args);\n\tmethod = mono_get_method_full (image, token, NULL, &context);\n\n\tif (mono_loader_get_last_error ())\n\t\tmono_raise_exception (mono_loader_error_prepare_exception (mono_loader_get_last_error ()));\n\n\treturn method;\n}\n\nstatic MonoString*\nves_icall_System_Reflection_Module_ResolveStringToken (MonoImage *image, guint32 token, MonoResolveTokenError *error)\n{\n\tint index = mono_metadata_token_index (token);\n\n\t*error = ResolveTokenError_Other;\n\n\t/* Validate token */\n\tif (mono_metadata_token_code (token) != MONO_TOKEN_STRING) {\n\t\t*error = ResolveTokenError_BadTable;\n\t\treturn NULL;\n\t}\n\n\tif (image->dynamic)\n\t\treturn mono_lookup_dynamic_token_class (image, token, FALSE, NULL, NULL);\n\n\tif ((index <= 0) || (index >= image->heap_us.size)) {\n\t\t*error = ResolveTokenError_OutOfRange;\n\t\treturn NULL;\n\t}\n\n\t/* FIXME: What to do if the index points into the middle of a string ? */\n\n\treturn mono_ldstr (mono_domain_get (), image, index);\n}\n\nstatic MonoClassField*\nves_icall_System_Reflection_Module_ResolveFieldToken (MonoImage *image, guint32 token, MonoArray *type_args, MonoArray *method_args, MonoResolveTokenError *error)\n{\n\tMonoClass *klass;\n\tint table = mono_metadata_token_table (token);\n\tint index = mono_metadata_token_index (token);\n\tMonoGenericContext context;\n\tMonoClassField *field;\n\n\t*error = ResolveTokenError_Other;\n\n\t/* Validate token */\n\tif ((table != MONO_TABLE_FIELD) && (table != MONO_TABLE_MEMBERREF)) {\n\t\t*error = ResolveTokenError_BadTable;\n\t\treturn NULL;\n\t}\n\n\tif (image->dynamic) {\n\t\tif (type_args || method_args)\n\t\t\tmono_raise_exception (mono_get_exception_not_implemented (NULL));\n\t\t/* FIXME: validate memberref token type */\n\t\treturn mono_lookup_dynamic_token_class (image, token, FALSE, NULL, NULL);\n\t}\n\n\tif ((index <= 0) || (index > image->tables [table].rows)) {\n\t\t*error = ResolveTokenError_OutOfRange;\n\t\treturn NULL;\n\t}\n\tif ((table == MONO_TABLE_MEMBERREF) && (mono_metadata_memberref_is_method (image, token))) {\n\t\t*error = ResolveTokenError_BadTable;\n\t\treturn NULL;\n\t}\n\n\tinit_generic_context_from_args (&context, type_args, method_args);\n\tfield = mono_field_from_token (image, token, &klass, &context);\n\n\tif (mono_loader_get_last_error ())\n\t\tmono_raise_exception (mono_loader_error_prepare_exception (mono_loader_get_last_error ()));\n\t\n\treturn field;\n}\n\n\nstatic MonoObject*\nves_icall_System_Reflection_Module_ResolveMemberToken (MonoImage *image, guint32 token, MonoArray *type_args, MonoArray *method_args, MonoResolveTokenError *error)\n{\n\tint table = mono_metadata_token_table (token);\n\n\t*error = ResolveTokenError_Other;\n\n\tswitch (table) {\n\tcase MONO_TABLE_TYPEDEF:\n\tcase MONO_TABLE_TYPEREF:\n\tcase MONO_TABLE_TYPESPEC: {\n\t\tMonoType *t = ves_icall_System_Reflection_Module_ResolveTypeToken (image, token, type_args, method_args, error);\n\t\tif (t)\n\t\t\treturn (MonoObject*)mono_type_get_object (mono_domain_get (), t);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\tcase MONO_TABLE_METHOD:\n\tcase MONO_TABLE_METHODSPEC: {\n\t\tMonoMethod *m = ves_icall_System_Reflection_Module_ResolveMethodToken (image, token, type_args, method_args, error);\n\t\tif (m)\n\t\t\treturn (MonoObject*)mono_method_get_object (mono_domain_get (), m, m->klass);\n\t\telse\n\t\t\treturn NULL;\n\t}\t\t\n\tcase MONO_TABLE_FIELD: {\n\t\tMonoClassField *f = ves_icall_System_Reflection_Module_ResolveFieldToken (image, token, type_args, method_args, error);\n\t\tif (f)\n\t\t\treturn (MonoObject*)mono_field_get_object (mono_domain_get (), f->parent, f);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\tcase MONO_TABLE_MEMBERREF:\n\t\tif (mono_metadata_memberref_is_method (image, token)) {\n\t\t\tMonoMethod *m = ves_icall_System_Reflection_Module_ResolveMethodToken (image, token, type_args, method_args, error);\n\t\t\tif (m)\n\t\t\t\treturn (MonoObject*)mono_method_get_object (mono_domain_get (), m, m->klass);\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t\telse {\n\t\t\tMonoClassField *f = ves_icall_System_Reflection_Module_ResolveFieldToken (image, token, type_args, method_args, error);\n\t\t\tif (f)\n\t\t\t\treturn (MonoObject*)mono_field_get_object (mono_domain_get (), f->parent, f);\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t*error = ResolveTokenError_BadTable;\n\t}\n\n\treturn NULL;\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Module_ResolveSignature (MonoImage *image, guint32 token, MonoResolveTokenError *error)\n{\n\tint table = mono_metadata_token_table (token);\n\tint idx = mono_metadata_token_index (token);\n\tMonoTableInfo *tables = image->tables;\n\tguint32 sig, len;\n\tconst char *ptr;\n\tMonoArray *res;\n\n\t*error = ResolveTokenError_OutOfRange;\n\n\t/* FIXME: Support other tables ? */\n\tif (table != MONO_TABLE_STANDALONESIG)\n\t\treturn NULL;\n\n\tif (image->dynamic)\n\t\treturn NULL;\n\n\tif ((idx == 0) || (idx > tables [MONO_TABLE_STANDALONESIG].rows))\n\t\treturn NULL;\n\n\tsig = mono_metadata_decode_row_col (&tables [MONO_TABLE_STANDALONESIG], idx - 1, 0);\n\n\tptr = mono_metadata_blob_heap (image, sig);\n\tlen = mono_metadata_decode_blob_size (ptr, &ptr);\n\n\tres = mono_array_new (mono_domain_get (), mono_defaults.byte_class, len);\n\tmemcpy (mono_array_addr (res, guint8, 0), ptr, len);\n\treturn res;\n}\n\nstatic MonoReflectionType*\nves_icall_ModuleBuilder_create_modified_type (MonoReflectionTypeBuilder *tb, MonoString *smodifiers)\n{\n\tMonoClass *klass;\n\tint isbyref = 0, rank;\n\tchar *str = mono_string_to_utf8 (smodifiers);\n\tchar *p;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (tb->type.type);\n\tp = str;\n\t/* logic taken from mono_reflection_parse_type(): keep in sync */\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase '&':\n\t\t\tif (isbyref) { /* only one level allowed by the spec */\n\t\t\t\tg_free (str);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tisbyref = 1;\n\t\t\tp++;\n\t\t\tg_free (str);\n\t\t\treturn mono_type_get_object (mono_object_domain (tb), &klass->this_arg);\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tklass = mono_ptr_class_get (&klass->byval_arg);\n\t\t\tmono_class_init (klass);\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\trank = 1;\n\t\t\tp++;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == ']')\n\t\t\t\t\tbreak;\n\t\t\t\tif (*p == ',')\n\t\t\t\t\trank++;\n\t\t\t\telse if (*p != '*') { /* '*' means unknown lower bound */\n\t\t\t\t\tg_free (str);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tif (*p != ']') {\n\t\t\t\tg_free (str);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tp++;\n\t\t\tklass = mono_array_class_get (klass, rank);\n\t\t\tmono_class_init (klass);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tg_free (str);\n\treturn mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n}\n\nstatic MonoBoolean\nves_icall_Type_IsArrayImpl (MonoReflectionType *t)\n{\n\tMonoType *type;\n\tMonoBoolean res;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\ttype = t->type;\n\tres = !type->byref && (type->type == MONO_TYPE_ARRAY || type->type == MONO_TYPE_SZARRAY);\n\n\treturn res;\n}\n\nstatic void\ncheck_for_invalid_type (MonoClass *klass)\n{\n\tchar *name;\n\tMonoString *str;\n\tif (klass->byval_arg.type != MONO_TYPE_TYPEDBYREF)\n\t\treturn;\n\n\tname = mono_type_get_full_name (klass);\n\tstr =  mono_string_new (mono_domain_get (), name);\n\tg_free (name);\n\tmono_raise_exception ((MonoException*)mono_get_exception_type_load (str, NULL));\n\n}\nstatic MonoReflectionType *\nves_icall_Type_make_array_type (MonoReflectionType *type, int rank)\n{\n\tMonoClass *klass, *aklass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tcheck_for_invalid_type (klass);\n\n\tif (rank == 0) //single dimentional array\n\t\taklass = mono_array_class_get (klass, 1);\n\telse\n\t\taklass = mono_bounded_array_class_get (klass, rank, TRUE);\n\n\treturn mono_type_get_object (mono_object_domain (type), &aklass->byval_arg);\n}\n\nstatic MonoReflectionType *\nves_icall_Type_make_byref_type (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tcheck_for_invalid_type (klass);\n\n\treturn mono_type_get_object (mono_object_domain (type), &klass->this_arg);\n}\n\nstatic MonoReflectionType *\nves_icall_Type_MakePointerType (MonoReflectionType *type)\n{\n\tMonoClass *klass, *pklass;\n\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tcheck_for_invalid_type (klass);\n\n\tpklass = mono_ptr_class_get (type->type);\n\n\treturn mono_type_get_object (mono_object_domain (type), &pklass->byval_arg);\n}\n\nstatic MonoObject *\nves_icall_System_Delegate_CreateDelegate_internal (MonoReflectionType *type, MonoObject *target,\n\t\t\t\t\t\t   MonoReflectionMethod *info, MonoBoolean throwOnBindFailure)\n{\n\tMonoClass *delegate_class = mono_class_from_mono_type (type->type);\n\tMonoObject *delegate;\n\tgpointer func;\n\tMonoMethod *method = info->method;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_assert (delegate_class->parent == mono_defaults.multicastdelegate_class);\n\n\tif (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR) {\n\t\tif (!mono_security_core_clr_ensure_delegate_creation (method, throwOnBindFailure))\n\t\t\treturn NULL;\n\t}\n\n\tdelegate = mono_object_new (mono_object_domain (type), delegate_class);\n\n\tif (method->dynamic) {\n\t\t/* Creating a trampoline would leak memory */\n\t\tfunc = mono_compile_method (method);\n\t} else {\n\t\tfunc = mono_create_ftnptr (mono_domain_get (),\n\t\t\tmono_runtime_create_jump_trampoline (mono_domain_get (), method, TRUE));\n\t}\n\n\tmono_delegate_ctor_with_method (delegate, target, func, method);\n\n\treturn delegate;\n}\n\nstatic void\nves_icall_System_Delegate_SetMulticastInvoke (MonoDelegate *this)\n{\n\t/* Reset the invoke impl to the default one */\n\tthis->invoke_impl = mono_runtime_create_delegate_trampoline (this->object.vtable->klass);\n}\n\n/*\n * Magic number to convert a time which is relative to\n * Jan 1, 1970 into a value which is relative to Jan 1, 0001.\n */\n#define\tEPOCH_ADJUST\t((guint64)62135596800LL)\n\n/*\n * Magic number to convert FILETIME base Jan 1, 1601 to DateTime - base Jan, 1, 0001\n */\n#define FILETIME_ADJUST ((guint64)504911232000000000LL)\n\n#ifdef PLATFORM_WIN32\n/* convert a SYSTEMTIME which is of the form \"last thursday in october\" to a real date */\nstatic void\nconvert_to_absolute_date(SYSTEMTIME *date)\n{\n#define IS_LEAP(y) ((y % 4) == 0 && ((y % 100) != 0 || (y % 400) == 0))\n\tstatic int days_in_month[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\tstatic int leap_days_in_month[] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\t/* from the calendar FAQ */\n\tint a = (14 - date->wMonth) / 12;\n\tint y = date->wYear - a;\n\tint m = date->wMonth + 12 * a - 2;\n\tint d = (1 + y + y/4 - y/100 + y/400 + (31*m)/12) % 7;\n\n\t/* d is now the day of the week for the first of the month (0 == Sunday) */\n\n\tint day_of_week = date->wDayOfWeek;\n\n\t/* set day_in_month to the first day in the month which falls on day_of_week */    \n\tint day_in_month = 1 + (day_of_week - d);\n\tif (day_in_month <= 0)\n\t\tday_in_month += 7;\n\n\t/* wDay is 1 for first weekday in month, 2 for 2nd ... 5 means last - so work that out allowing for days in the month */\n\tdate->wDay = day_in_month + (date->wDay - 1) * 7;\n\tif (date->wDay > (IS_LEAP(date->wYear) ? leap_days_in_month[date->wMonth - 1] : days_in_month[date->wMonth - 1]))\n\t\tdate->wDay -= 7;\n}\n#endif\n\n#ifndef PLATFORM_WIN32\n/*\n * Return's the offset from GMT of a local time.\n * \n *  tm is a local time\n *  t  is the same local time as seconds.\n */\nstatic int \ngmt_offset(struct tm *tm, time_t t)\n{\n#if defined (HAVE_TM_GMTOFF)\n\treturn tm->tm_gmtoff;\n#else\n\tstruct tm g;\n\ttime_t t2;\n\tg = *gmtime(&t);\n\tg.tm_isdst = tm->tm_isdst;\n\tt2 = mktime(&g);\n\treturn (int)difftime(t, t2);\n#endif\n}\n#endif\n/*\n * This is heavily based on zdump.c from glibc 2.2.\n *\n *  * data[0]:  start of daylight saving time (in DateTime ticks).\n *  * data[1]:  end of daylight saving time (in DateTime ticks).\n *  * data[2]:  utcoffset (in TimeSpan ticks).\n *  * data[3]:  additional offset when daylight saving (in TimeSpan ticks).\n *  * name[0]:  name of this timezone when not daylight saving.\n *  * name[1]:  name of this timezone when daylight saving.\n *\n *  FIXME: This only works with \"standard\" Unix dates (years between 1900 and 2100) while\n *         the class library allows years between 1 and 9999.\n *\n *  Returns true on success and zero on failure.\n */\nstatic guint32\nves_icall_System_CurrentSystemTimeZone_GetTimeZoneData (guint32 year, MonoArray **data, MonoArray **names)\n{\n#ifndef PLATFORM_WIN32\n\tMonoDomain *domain = mono_domain_get ();\n\tstruct tm start, tt;\n\ttime_t t;\n\n\tlong int gmtoff;\n\tint is_daylight = 0, day;\n\tchar tzone [64];\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (data);\n\tMONO_CHECK_ARG_NULL (names);\n\n\tmono_gc_wbarrier_generic_store (data, (MonoObject*) mono_array_new (domain, mono_defaults.int64_class, 4));\n\tmono_gc_wbarrier_generic_store (names, (MonoObject*) mono_array_new (domain, mono_defaults.string_class, 2));\n\n\t/* \n\t * no info is better than crashing: we'll need our own tz data\n\t * to make this work properly, anyway. The range is probably\n\t * reduced to 1970 .. 2037 because that is what mktime is\n\t * guaranteed to support (we get into an infinite loop\n\t * otherwise).\n\t */\n\n\tmemset (&start, 0, sizeof (start));\n\n\tstart.tm_mday = 1;\n\tstart.tm_year = year-1900;\n\n\tt = mktime (&start);\n\n\tif ((year < 1970) || (year > 2037) || (t == -1)) {\n\t\tt = time (NULL);\n\t\ttt = *localtime (&t);\n\t\tstrftime (tzone, sizeof (tzone), \"%Z\", &tt);\n\t\tmono_array_setref ((*names), 0, mono_string_new (domain, tzone));\n\t\tmono_array_setref ((*names), 1, mono_string_new (domain, tzone));\n\t\treturn 1;\n\t}\n\n\tgmtoff = gmt_offset (&start, t);\n\n\t/* For each day of the year, calculate the tm_gmtoff. */\n\tfor (day = 0; day < 365; day++) {\n\n\t\tt += 3600*24;\n\t\ttt = *localtime (&t);\n\n\t\t/* Daylight saving starts or ends here. */\n\t\tif (gmt_offset (&tt, t) != gmtoff) {\n\t\t\tstruct tm tt1;\n\t\t\ttime_t t1;\n\n\t\t\t/* Try to find the exact hour when daylight saving starts/ends. */\n\t\t\tt1 = t;\n\t\t\tdo {\n\t\t\t\tt1 -= 3600;\n\t\t\t\ttt1 = *localtime (&t1);\n\t\t\t} while (gmt_offset (&tt1, t1) != gmtoff);\n\n\t\t\t/* Try to find the exact minute when daylight saving starts/ends. */\n\t\t\tdo {\n\t\t\t\tt1 += 60;\n\t\t\t\ttt1 = *localtime (&t1);\n\t\t\t} while (gmt_offset (&tt1, t1) == gmtoff);\n\t\t\tt1+=gmtoff;\n\t\t\tstrftime (tzone, sizeof (tzone), \"%Z\", &tt);\n\t\t\t\n\t\t\t/* Write data, if we're already in daylight saving, we're done. */\n\t\t\tif (is_daylight) {\n\t\t\t\tmono_array_setref ((*names), 0, mono_string_new (domain, tzone));\n\t\t\t\tmono_array_set ((*data), gint64, 1, ((gint64)t1 + EPOCH_ADJUST) * 10000000L);\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tmono_array_setref ((*names), 1, mono_string_new (domain, tzone));\n\t\t\t\tmono_array_set ((*data), gint64, 0, ((gint64)t1 + EPOCH_ADJUST) * 10000000L);\n\t\t\t\tis_daylight = 1;\n\t\t\t}\n\n\t\t\t/* This is only set once when we enter daylight saving. */\n\t\t\tmono_array_set ((*data), gint64, 2, (gint64)gmtoff * 10000000L);\n\t\t\tmono_array_set ((*data), gint64, 3, (gint64)(gmt_offset (&tt, t) - gmtoff) * 10000000L);\n\n\t\t\tgmtoff = gmt_offset (&tt, t);\n\t\t}\n\t}\n\n\tif (!is_daylight) {\n\t\tstrftime (tzone, sizeof (tzone), \"%Z\", &tt);\n\t\tmono_array_setref ((*names), 0, mono_string_new (domain, tzone));\n\t\tmono_array_setref ((*names), 1, mono_string_new (domain, tzone));\n\t\tmono_array_set ((*data), gint64, 0, 0);\n\t\tmono_array_set ((*data), gint64, 1, 0);\n\t\tmono_array_set ((*data), gint64, 2, (gint64) gmtoff * 10000000L);\n\t\tmono_array_set ((*data), gint64, 3, 0);\n\t}\n\n\treturn 1;\n#else\n\tMonoDomain *domain = mono_domain_get ();\n\tTIME_ZONE_INFORMATION tz_info;\n\tFILETIME ft;\n\tint i;\n\tint err, tz_id;\n\n\ttz_id = GetTimeZoneInformation (&tz_info);\n\tif (tz_id == TIME_ZONE_ID_INVALID)\n\t\treturn 0;\n\n\tMONO_CHECK_ARG_NULL (data);\n\tMONO_CHECK_ARG_NULL (names);\n\n\tmono_gc_wbarrier_generic_store (data, mono_array_new (domain, mono_defaults.int64_class, 4));\n\tmono_gc_wbarrier_generic_store (names, mono_array_new (domain, mono_defaults.string_class, 2));\n\n\tfor (i = 0; i < 32; ++i)\n\t\tif (!tz_info.DaylightName [i])\n\t\t\tbreak;\n\tmono_array_setref ((*names), 1, mono_string_new_utf16 (domain, tz_info.DaylightName, i));\n\tfor (i = 0; i < 32; ++i)\n\t\tif (!tz_info.StandardName [i])\n\t\t\tbreak;\n\tmono_array_setref ((*names), 0, mono_string_new_utf16 (domain, tz_info.StandardName, i));\n\n\tif ((year <= 1601) || (year > 30827)) {\n\t\t/*\n\t\t * According to MSDN, the MS time functions can't handle dates outside\n\t\t * this interval.\n\t\t */\n\t\treturn 1;\n\t}\n\n\t/* even if the timezone has no daylight savings it may have Bias (e.g. GMT+13 it seems) */\n\tif (tz_id != TIME_ZONE_ID_UNKNOWN) {\n\t\ttz_info.StandardDate.wYear = year;\n\t\tconvert_to_absolute_date(&tz_info.StandardDate);\n\t\terr = SystemTimeToFileTime (&tz_info.StandardDate, &ft);\n\t\t//g_assert(err);\n\t\tif (err == 0)\n\t\t\treturn 0;\n\t\t\n\t\tmono_array_set ((*data), gint64, 1, FILETIME_ADJUST + (((guint64)ft.dwHighDateTime<<32) | ft.dwLowDateTime));\n\t\ttz_info.DaylightDate.wYear = year;\n\t\tconvert_to_absolute_date(&tz_info.DaylightDate);\n\t\terr = SystemTimeToFileTime (&tz_info.DaylightDate, &ft);\n\t\t//g_assert(err);\n\t\tif (err == 0)\n\t\t\treturn 0;\n\t\t\n\t\tmono_array_set ((*data), gint64, 0, FILETIME_ADJUST + (((guint64)ft.dwHighDateTime<<32) | ft.dwLowDateTime));\n\t}\n\tmono_array_set ((*data), gint64, 2, (tz_info.Bias + tz_info.StandardBias) * -600000000LL);\n\tmono_array_set ((*data), gint64, 3, (tz_info.DaylightBias - tz_info.StandardBias) * -600000000LL);\n\n\treturn 1;\n#endif\n}\n\nstatic gpointer\nves_icall_System_Object_obj_address (MonoObject *this) \n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn this;\n}\n\n/* System.Buffer */\n\nstatic inline gint32 \nmono_array_get_byte_length (MonoArray *array)\n{\n\tMonoClass *klass;\n\tint length;\n\tint i;\n\n\tklass = array->obj.vtable->klass;\n\n\tif (array->bounds == NULL)\n\t\tlength = array->max_length;\n\telse {\n\t\tlength = 1;\n\t\tfor (i = 0; i < klass->rank; ++ i)\n\t\t\tlength *= array->bounds [i].length;\n\t}\n\n\tswitch (klass->element_class->byval_arg.type) {\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_BOOLEAN:\n\t\treturn length;\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_CHAR:\n\t\treturn length << 1;\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_R4:\n\t\treturn length << 2;\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\t\treturn length * sizeof (gpointer);\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R8:\n\t\treturn length << 3;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic gint32 \nves_icall_System_Buffer_ByteLengthInternal (MonoArray *array) \n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_array_get_byte_length (array);\n}\n\nstatic gint8 \nves_icall_System_Buffer_GetByteInternal (MonoArray *array, gint32 idx) \n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_array_get (array, gint8, idx);\n}\n\nstatic void \nves_icall_System_Buffer_SetByteInternal (MonoArray *array, gint32 idx, gint8 value) \n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_array_set (array, gint8, idx, value);\n}\n\nstatic MonoBoolean\nves_icall_System_Buffer_BlockCopyInternal (MonoArray *src, gint32 src_offset, MonoArray *dest, gint32 dest_offset, gint32 count) \n{\n\tguint8 *src_buf, *dest_buf;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t/* watch out for integer overflow */\n\tif ((src_offset > mono_array_get_byte_length (src) - count) || (dest_offset > mono_array_get_byte_length (dest) - count))\n\t\treturn FALSE;\n\n\tsrc_buf = (guint8 *)src->vector + src_offset;\n\tdest_buf = (guint8 *)dest->vector + dest_offset;\n\n\tif (src != dest)\n\t\tmemcpy (dest_buf, src_buf, count);\n\telse\n\t\tmemmove (dest_buf, src_buf, count); /* Source and dest are the same array */\n\n\treturn TRUE;\n}\n\nstatic MonoObject *\nves_icall_Remoting_RealProxy_GetTransparentProxy (MonoObject *this, MonoString *class_name)\n{\n\tMonoDomain *domain = mono_object_domain (this); \n\tMonoObject *res;\n\tMonoRealProxy *rp = ((MonoRealProxy *)this);\n\tMonoTransparentProxy *tp;\n\tMonoType *type;\n\tMonoClass *klass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tres = mono_object_new (domain, mono_defaults.transparent_proxy_class);\n\ttp = (MonoTransparentProxy*) res;\n\t\n\tMONO_OBJECT_SETREF (tp, rp, rp);\n\ttype = ((MonoReflectionType *)rp->class_to_proxy)->type;\n\tklass = mono_class_from_mono_type (type);\n\n\ttp->custom_type_info = (mono_object_isinst (this, mono_defaults.iremotingtypeinfo_class) != NULL);\n\ttp->remote_class = mono_remote_class (domain, class_name, klass);\n\n\tres->vtable = mono_remote_class_vtable (domain, tp->remote_class, rp);\n\treturn res;\n}\n\nstatic MonoReflectionType *\nves_icall_Remoting_RealProxy_InternalGetProxyType (MonoTransparentProxy *tp)\n{\n\treturn mono_type_get_object (mono_object_domain (tp), &tp->remote_class->proxy_class->byval_arg);\n}\n\n/* System.Environment */\n\nMonoString*\nves_icall_System_Environment_get_UserName (void)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\t/* using glib is more portable */\n\treturn mono_string_new (mono_domain_get (), g_get_user_name ());\n}\n\n\nstatic MonoString *\nves_icall_System_Environment_get_MachineName (void)\n{\n#if defined (PLATFORM_WIN32)\n\tgunichar2 *buf;\n\tguint32 len;\n\tMonoString *result;\n\n\tlen = MAX_COMPUTERNAME_LENGTH + 1;\n\tbuf = g_new (gunichar2, len);\n\n\tresult = NULL;\n\tif (GetComputerName (buf, (PDWORD) &len))\n\t\tresult = mono_string_new_utf16 (mono_domain_get (), buf, len);\n\n\tg_free (buf);\n\treturn result;\n#elif !defined(DISABLE_SOCKETS)\n\tgchar buf [256];\n\tMonoString *result;\n\n\tif (gethostname (buf, sizeof (buf)) == 0)\n\t\tresult = mono_string_new (mono_domain_get (), buf);\n\telse\n\t\tresult = NULL;\n\t\n\treturn result;\n#else\n\treturn mono_string_new (mono_domain_get (), \"mono\");\n#endif\n}\n\nstatic int\nves_icall_System_Environment_get_Platform (void)\n{\n#if defined (PLATFORM_WIN32)\n\t/* Win32NT */\n\treturn 2;\n#elif defined(__MACH__)\n\t/* OSX */\n\tif (mono_framework_version () < 2)\n\t\treturn 128;\n\n\t//\n\t// For compatibility with our client code, this will be 4 for a while.\n\t// We will eventually move to 6 to match .NET, but it requires all client\n\t// code to be updated and the documentation everywhere to be updated \n\t// first.\n\t//\n\treturn 4;\n#else\n\t/* Unix */\n\tif (mono_framework_version () < 2)\n\t\treturn 128;\n\treturn 4;\n#endif\n}\n\nstatic MonoString *\nves_icall_System_Environment_get_NewLine (void)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n#if defined (PLATFORM_WIN32)\n\treturn mono_string_new (mono_domain_get (), \"\\r\\n\");\n#else\n\treturn mono_string_new (mono_domain_get (), \"\\n\");\n#endif\n}\n\nstatic MonoString *\nves_icall_System_Environment_GetEnvironmentVariable (MonoString *name)\n{\n\tconst gchar *value;\n\tgchar *utf8_name;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (name == NULL)\n\t\treturn NULL;\n\n\tutf8_name = mono_string_to_utf8 (name);\t/* FIXME: this should be ascii */\n\tvalue = g_getenv (utf8_name);\n\n\tg_free (utf8_name);\n\n\tif (value == 0)\n\t\treturn NULL;\n\t\n\treturn mono_string_new (mono_domain_get (), value);\n}\n\n/*\n * There is no standard way to get at environ.\n */\n#ifndef _MSC_VER\n#ifndef __MINGW32_VERSION\n#ifdef __APPLE__\n/* Apple defines this in crt_externs.h but doesn't provide that header for \n * arm-apple-darwin9.  We'll manually define the symbol on Apple as it does\n * in fact exist on all implementations (so far) \n */\ngchar ***_NSGetEnviron(void);\n#define environ (*_NSGetEnviron())\n#else\nextern\nchar **environ;\n#endif\n#endif\n#endif\n\nstatic MonoArray *\nves_icall_System_Environment_GetEnvironmentVariableNames (void)\n{\n#ifdef PLATFORM_WIN32\n\tMonoArray *names;\n\tMonoDomain *domain;\n\tMonoString *str;\n\tWCHAR* env_strings;\n\tWCHAR* env_string;\n\tWCHAR* equal_str;\n\tint n = 0;\n\n\tenv_strings = GetEnvironmentStrings();\n\n\tif (env_strings) {\n\t\tenv_string = env_strings;\n\t\twhile (*env_string != '\\0') {\n\t\t/* weird case that MS seems to skip */\n\t\t\tif (*env_string != '=')\n\t\t\t\tn++;\n\t\t\twhile (*env_string != '\\0')\n\t\t\t\tenv_string++;\n\t\t\tenv_string++;\n\t\t}\n\t}\n\n\tdomain = mono_domain_get ();\n\tnames = mono_array_new (domain, mono_defaults.string_class, n);\n\n\tif (env_strings) {\n\t\tn = 0;\n\t\tenv_string = env_strings;\n\t\twhile (*env_string != '\\0') {\n\t\t\t/* weird case that MS seems to skip */\n\t\t\tif (*env_string != '=') {\n\t\t\t\tequal_str = wcschr(env_string, '=');\n\t\t\t\tg_assert(equal_str);\n\t\t\t\tstr = mono_string_new_utf16 (domain, env_string, equal_str-env_string);\n\t\t\t\tmono_array_setref (names, n, str);\n\t\t\t\tn++;\n\t\t\t}\n\t\t\twhile (*env_string != '\\0')\n\t\t\t\tenv_string++;\n\t\t\tenv_string++;\n\t\t}\n\n\t\tFreeEnvironmentStrings (env_strings);\n\t}\n\n\treturn names;\n\n#else\n\tMonoArray *names;\n\tMonoDomain *domain;\n\tMonoString *str;\n\tgchar **e, **parts;\n\tint n;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tn = 0;\n\tfor (e = environ; *e != 0; ++ e)\n\t\t++ n;\n\n\tdomain = mono_domain_get ();\n\tnames = mono_array_new (domain, mono_defaults.string_class, n);\n\n\tn = 0;\n\tfor (e = environ; *e != 0; ++ e) {\n\t\tparts = g_strsplit (*e, \"=\", 2);\n\t\tif (*parts != 0) {\n\t\t\tstr = mono_string_new (domain, *parts);\n\t\t\tmono_array_setref (names, n, str);\n\t\t}\n\n\t\tg_strfreev (parts);\n\n\t\t++ n;\n\t}\n\n\treturn names;\n#endif\n}\n\n/*\n * If your platform lacks setenv/unsetenv, you must upgrade your glib.\n */\n#if !GLIB_CHECK_VERSION(2,4,0)\n#define g_setenv(a,b,c)   setenv(a,b,c)\n#define g_unsetenv(a) unsetenv(a)\n#endif\n\nstatic void\nves_icall_System_Environment_InternalSetEnvironmentVariable (MonoString *name, MonoString *value)\n{\n\tMonoError error;\n\n#ifdef PLATFORM_WIN32\n\tgunichar2 *utf16_name, *utf16_value;\n#else\n\tgchar *utf8_name, *utf8_value;\n#endif\n\n\tMONO_ARCH_SAVE_REGS;\n\t\n#ifdef PLATFORM_WIN32\n\tutf16_name = mono_string_to_utf16 (name);\n\tif ((value == NULL) || (mono_string_length (value) == 0) || (mono_string_chars (value)[0] == 0)) {\n\t\tSetEnvironmentVariable (utf16_name, NULL);\n\t\tg_free (utf16_name);\n\t\treturn;\n\t}\n\n\tutf16_value = mono_string_to_utf16 (value);\n\n\tSetEnvironmentVariable (utf16_name, utf16_value);\n\n\tg_free (utf16_name);\n\tg_free (utf16_value);\n#else\n\tutf8_name = mono_string_to_utf8 (name);\t/* FIXME: this should be ascii */\n\n\tif ((value == NULL) || (mono_string_length (value) == 0) || (mono_string_chars (value)[0] == 0)) {\n\t\tg_unsetenv (utf8_name);\n\t\tg_free (utf8_name);\n\t\treturn;\n\t}\n\n\tutf8_value = mono_string_to_utf8_checked (value, &error);\n\tif (!mono_error_ok (&error)) {\n\t\tg_free (utf8_name);\n\t\tmono_error_raise_exception (&error);\n\t}\n\tg_setenv (utf8_name, utf8_value, TRUE);\n\n\tg_free (utf8_name);\n\tg_free (utf8_value);\n#endif\n}\n\nstatic void\nves_icall_System_Environment_Exit (int result)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_threads_set_shutting_down ();\n\n\tmono_runtime_set_shutting_down ();\n\n\t/* This will kill the tp threads which cannot be suspended */\n\tmono_thread_pool_cleanup ();\n\n\t/* Suspend all managed threads since the runtime is going away */\n\tmono_thread_suspend_all_other_threads ();\n\n\tmono_runtime_quit ();\n\n\t/* we may need to do some cleanup here... */\n\texit (result);\n}\n\nstatic MonoString*\nves_icall_System_Environment_GetGacPath (void)\n{\n\treturn mono_string_new (mono_domain_get (), mono_assembly_getrootdir ());\n}\n\nstatic MonoString*\nves_icall_System_Environment_GetWindowsFolderPath (int folder)\n{\n#if defined (PLATFORM_WIN32)\n\t#ifndef CSIDL_FLAG_CREATE\n\t\t#define CSIDL_FLAG_CREATE\t0x8000\n\t#endif\n\n\tWCHAR path [MAX_PATH];\n\t/* Create directory if no existing */\n\tif (SUCCEEDED (SHGetFolderPathW (NULL, folder | CSIDL_FLAG_CREATE, NULL, 0, path))) {\n\t\tint len = 0;\n\t\twhile (path [len])\n\t\t\t++ len;\n\t\treturn mono_string_new_utf16 (mono_domain_get (), path, len);\n\t}\n#else\n\tg_warning (\"ves_icall_System_Environment_GetWindowsFolderPath should only be called on Windows!\");\n#endif\n\treturn mono_string_new (mono_domain_get (), \"\");\n}\n\nstatic MonoArray *\nves_icall_System_Environment_GetLogicalDrives (void)\n{\n        gunichar2 buf [256], *ptr, *dname;\n\tgunichar2 *u16;\n\tguint initial_size = 127, size = 128;\n\tgint ndrives;\n\tMonoArray *result;\n\tMonoString *drivestr;\n\tMonoDomain *domain = mono_domain_get ();\n\tgint len;\n\n\tMONO_ARCH_SAVE_REGS;\n\n        buf [0] = '\\0';\n\tptr = buf;\n\n\twhile (size > initial_size) {\n\t\tsize = (guint) GetLogicalDriveStrings (initial_size, ptr);\n\t\tif (size > initial_size) {\n\t\t\tif (ptr != buf)\n\t\t\t\tg_free (ptr);\n\t\t\tptr = g_malloc0 ((size + 1) * sizeof (gunichar2));\n\t\t\tinitial_size = size;\n\t\t\tsize++;\n\t\t}\n\t}\n\n\t/* Count strings */\n\tdname = ptr;\n\tndrives = 0;\n\tdo {\n\t\twhile (*dname++);\n\t\tndrives++;\n\t} while (*dname);\n\n\tdname = ptr;\n\tresult = mono_array_new (domain, mono_defaults.string_class, ndrives);\n\tndrives = 0;\n\tdo {\n\t\tlen = 0;\n\t\tu16 = dname;\n\t\twhile (*u16) { u16++; len ++; }\n\t\tdrivestr = mono_string_new_utf16 (domain, dname, len);\n\t\tmono_array_setref (result, ndrives++, drivestr);\n\t\twhile (*dname++);\n\t} while (*dname);\n\n\tif (ptr != buf)\n\t\tg_free (ptr);\n\n\treturn result;\n}\n\nstatic MonoString *\nves_icall_System_Environment_InternalGetHome (void)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_string_new (mono_domain_get (), g_get_home_dir ());\n}\n\nstatic const char *encodings [] = {\n\t(char *) 1,\n\t\t\"ascii\", \"us_ascii\", \"us\", \"ansi_x3.4_1968\",\n\t\t\"ansi_x3.4_1986\", \"cp367\", \"csascii\", \"ibm367\",\n\t\t\"iso_ir_6\", \"iso646_us\", \"iso_646.irv:1991\",\n\t(char *) 2,\n\t\t\"utf_7\", \"csunicode11utf7\", \"unicode_1_1_utf_7\",\n\t\t\"unicode_2_0_utf_7\", \"x_unicode_1_1_utf_7\",\n\t\t\"x_unicode_2_0_utf_7\",\n\t(char *) 3,\n\t\t\"utf_8\", \"unicode_1_1_utf_8\", \"unicode_2_0_utf_8\",\n\t\t\"x_unicode_1_1_utf_8\", \"x_unicode_2_0_utf_8\",\n\t(char *) 4,\n\t\t\"utf_16\", \"UTF_16LE\", \"ucs_2\", \"unicode\",\n\t\t\"iso_10646_ucs2\",\n\t(char *) 5,\n\t\t\"unicodefffe\", \"utf_16be\",\n\t(char *) 6,\n\t\t\"iso_8859_1\",\n\t(char *) 0\n};\n\n/*\n * Returns the internal codepage, if the value of \"int_code_page\" is\n * 1 at entry, and we can not compute a suitable code page number,\n * returns the code page as a string\n */\nstatic MonoString*\nves_icall_System_Text_Encoding_InternalCodePage (gint32 *int_code_page) \n{\n\tconst char *cset;\n\tconst char *p;\n\tchar *c;\n\tchar *codepage = NULL;\n\tint code;\n\tint want_name = *int_code_page;\n\tint i;\n\t\n\t*int_code_page = -1;\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_get_charset (&cset);\n\tc = codepage = strdup (cset);\n\tfor (c = codepage; *c; c++){\n\t\tif (isascii (*c) && isalpha (*c))\n\t\t\t*c = tolower (*c);\n\t\tif (*c == '-')\n\t\t\t*c = '_';\n\t}\n\t/* g_print (\"charset: %s\\n\", cset); */\n\t\n\t/* handle some common aliases */\n\tp = encodings [0];\n\tcode = 0;\n\tfor (i = 0; p != 0; ){\n\t\tif ((gssize) p < 7){\n\t\t\tcode = (gssize) p;\n\t\t\tp = encodings [++i];\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp (p, codepage) == 0){\n\t\t\t*int_code_page = code;\n\t\t\tbreak;\n\t\t}\n\t\tp = encodings [++i];\n\t}\n\t\n\tif (strstr (codepage, \"utf_8\") != NULL)\n\t\t*int_code_page |= 0x10000000;\n\tfree (codepage);\n\t\n\tif (want_name && *int_code_page == -1)\n\t\treturn mono_string_new (mono_domain_get (), cset);\n\telse\n\t\treturn NULL;\n}\n\nstatic MonoBoolean\nves_icall_System_Environment_get_HasShutdownStarted (void)\n{\n\tif (mono_runtime_is_shutting_down ())\n\t\treturn TRUE;\n\n\tif (mono_domain_is_unloading (mono_domain_get ()))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic void\nves_icall_System_Environment_BroadcastSettingChange (void)\n{\n#ifdef PLATFORM_WIN32\n\tSendMessageTimeout (HWND_BROADCAST, WM_SETTINGCHANGE, NULL, L\"Environment\", SMTO_ABORTIFHUNG, 2000, 0);\n#endif\n}\n\nstatic void\nves_icall_MonoMethodMessage_InitMessage (MonoMethodMessage *this, \n\t\t\t\t\t MonoReflectionMethod *method,\n\t\t\t\t\t MonoArray *out_args)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_message_init (mono_object_domain (this), this, method, out_args);\n}\n\nstatic MonoBoolean\nves_icall_IsTransparentProxy (MonoObject *proxy)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!proxy)\n\t\treturn 0;\n\n\tif (proxy->vtable->klass == mono_defaults.transparent_proxy_class)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic MonoReflectionMethod *\nves_icall_Remoting_RemotingServices_GetVirtualMethod (\n\tMonoReflectionType *rtype, MonoReflectionMethod *rmethod)\n{\n\tMonoClass *klass;\n\tMonoMethod *method;\n\tMonoMethod **vtable;\n\tMonoMethod *res = NULL;\n\n\tMONO_CHECK_ARG_NULL (rtype);\n\tMONO_CHECK_ARG_NULL (rmethod);\n\n\tmethod = rmethod->method;\n\tklass = mono_class_from_mono_type (rtype->type);\n\n\tif (MONO_CLASS_IS_INTERFACE (klass))\n\t\treturn NULL;\n\n\tif (method->flags & METHOD_ATTRIBUTE_STATIC)\n\t\treturn NULL;\n\n\tif ((method->flags & METHOD_ATTRIBUTE_FINAL) || !(method->flags & METHOD_ATTRIBUTE_VIRTUAL)) {\n\t\tif (klass == method->klass || mono_class_is_subclass_of (klass, method->klass, FALSE))\n\t\t\treturn rmethod;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tmono_class_setup_vtable (klass);\n\tvtable = klass->vtable;\n\n\tif (method->klass->flags & TYPE_ATTRIBUTE_INTERFACE) {\n\t\tint offs = mono_class_interface_offset (klass, method->klass);\n\t\tif (offs >= 0)\n\t\t\tres = vtable [offs + method->slot];\n\t} else {\n\t\tif (!(klass == method->klass || mono_class_is_subclass_of (klass, method->klass, FALSE)))\n\t\t\treturn NULL;\n\n\t\tif (method->slot != -1)\n\t\t\tres = vtable [method->slot];\n\t}\n\n\tif (!res)\n\t\treturn NULL;\n\n\treturn mono_method_get_object (mono_domain_get (), res, NULL);\n}\n\nstatic void\nves_icall_System_Runtime_Activation_ActivationServices_EnableProxyActivation (MonoReflectionType *type, MonoBoolean enable)\n{\n\tMonoClass *klass;\n\tMonoVTable* vtable;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tvtable = mono_class_vtable_full (mono_domain_get (), klass, TRUE);\n\n\tif (enable) vtable->remote = 1;\n\telse vtable->remote = 0;\n}\n\nstatic MonoObject *\nves_icall_System_Runtime_Activation_ActivationServices_AllocateUninitializedClassInstance (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMonoDomain *domain;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = mono_object_domain (type);\n\tklass = mono_class_from_mono_type (type->type);\n\n\tif (klass->rank >= 1) {\n\t\tg_assert (klass->rank == 1);\n\t\treturn (MonoObject *) mono_array_new (domain, klass->element_class, 0);\n\t} else {\n\t\t/* Bypass remoting object creation check */\n\t\treturn mono_object_new_alloc_specific (mono_class_vtable_full (domain, klass, TRUE));\n\t}\n}\n\nstatic MonoString *\nves_icall_System_IO_get_temp_path (void)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_string_new (mono_domain_get (), g_get_tmp_dir ());\n}\n\n#ifndef PLATFORM_NO_DRIVEINFO\nstatic MonoBoolean\nves_icall_System_IO_DriveInfo_GetDiskFreeSpace (MonoString *path_name, guint64 *free_bytes_avail,\n\t\t\t\t\t\tguint64 *total_number_of_bytes, guint64 *total_number_of_free_bytes,\n\t\t\t\t\t\tgint32 *error)\n{\n\tgboolean result;\n\tULARGE_INTEGER wapi_free_bytes_avail;\n\tULARGE_INTEGER wapi_total_number_of_bytes;\n\tULARGE_INTEGER wapi_total_number_of_free_bytes;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t*error = ERROR_SUCCESS;\n\tresult = GetDiskFreeSpaceEx (mono_string_chars (path_name), &wapi_free_bytes_avail, &wapi_total_number_of_bytes,\n\t\t\t\t     &wapi_total_number_of_free_bytes);\n\n\tif (result) {\n\t\t*free_bytes_avail = wapi_free_bytes_avail.QuadPart;\n\t\t*total_number_of_bytes = wapi_total_number_of_bytes.QuadPart;\n\t\t*total_number_of_free_bytes = wapi_total_number_of_free_bytes.QuadPart;\n\t} else {\n\t\t*free_bytes_avail = 0;\n\t\t*total_number_of_bytes = 0;\n\t\t*total_number_of_free_bytes = 0;\n\t\t*error = GetLastError ();\n\t}\n\n\treturn result;\n}\n\nstatic guint32\nves_icall_System_IO_DriveInfo_GetDriveType (MonoString *root_path_name)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn GetDriveType (mono_string_chars (root_path_name));\n}\n#endif\n\nstatic gpointer\nves_icall_RuntimeMethod_GetFunctionPointer (MonoMethod *method)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_compile_method (method);\n}\n\nstatic MonoString *\nves_icall_System_Configuration_DefaultConfig_get_machine_config_path (void)\n{\n\tMonoString *mcpath;\n\tgchar *path;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tpath = g_build_path (G_DIR_SEPARATOR_S, mono_get_config_dir (), \"mono\", mono_get_runtime_info ()->framework_version, \"machine.config\", NULL);\n\n#if defined (PLATFORM_WIN32)\n\t/* Avoid mixing '/' and '\\\\' */\n\t{\n\t\tgint i;\n\t\tfor (i = strlen (path) - 1; i >= 0; i--)\n\t\t\tif (path [i] == '/')\n\t\t\t\tpath [i] = '\\\\';\n\t}\n#endif\n\tmcpath = mono_string_new (mono_domain_get (), path);\n\tg_free (path);\n\n\treturn mcpath;\n}\n\nstatic MonoString *\nget_bundled_machine_config (void)\n{\n\tconst gchar *machine_config;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmachine_config = mono_get_machine_config ();\n\n\tif (!machine_config)\n\t\treturn NULL;\n\n\treturn mono_string_new (mono_domain_get (), machine_config);\n}\n\nstatic MonoString *\nves_icall_System_Web_Util_ICalls_get_machine_install_dir (void)\n{\n\tMonoString *ipath;\n\tgchar *path;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tpath = g_path_get_dirname (mono_get_config_dir ());\n\n#if defined (PLATFORM_WIN32)\n\t/* Avoid mixing '/' and '\\\\' */\n\t{\n\t\tgint i;\n\t\tfor (i = strlen (path) - 1; i >= 0; i--)\n\t\t\tif (path [i] == '/')\n\t\t\t\tpath [i] = '\\\\';\n\t}\n#endif\n\tipath = mono_string_new (mono_domain_get (), path);\n\tg_free (path);\n\n\treturn ipath;\n}\n\nstatic gboolean\nves_icall_get_resources_ptr (MonoReflectionAssembly *assembly, gpointer *result, gint32 *size)\n{\n\tMonoPEResourceDataEntry *entry;\n\tMonoImage *image;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!assembly || !result || !size)\n\t\treturn FALSE;\n\n\t*result = NULL;\n\t*size = 0;\n\timage = assembly->assembly->image;\n\tentry = mono_image_lookup_resource (image, MONO_PE_RESOURCE_ID_ASPNET_STRING, 0, NULL);\n\tif (!entry)\n\t\treturn FALSE;\n\n\t*result = mono_image_rva_map (image, entry->rde_data_offset);\n\tif (!(*result)) {\n\t\tg_free (entry);\n\t\treturn FALSE;\n\t}\n\t*size = entry->rde_size;\n\tg_free (entry);\n\treturn TRUE;\n}\n\nstatic MonoBoolean\nves_icall_System_Diagnostics_Debugger_IsAttached_internal (void)\n{\n\treturn mono_debug_using_mono_debugger () || mono_is_debugger_attached ();\n}\n\nstatic void\nves_icall_System_Diagnostics_DefaultTraceListener_WriteWindowsDebugString (MonoString *message)\n{\n#if defined (PLATFORM_WIN32)\n\tOutputDebugString (mono_string_chars (message));\n#else\n\tg_warning (\"WriteWindowsDebugString called and PLATFORM_WIN32 not defined!\\n\");\n#endif\n}\n\n/* Only used for value types */\nstatic MonoObject *\nves_icall_System_Activator_CreateInstanceInternal (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMonoDomain *domain;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = mono_object_domain (type);\n\tklass = mono_class_from_mono_type (type->type);\n\n\tif (mono_class_is_nullable (klass))\n\t\t/* No arguments -> null */\n\t\treturn NULL;\n\n\treturn mono_object_new (domain, klass);\n}\n\nstatic MonoReflectionMethod *\nves_icall_MonoMethod_get_base_definition (MonoReflectionMethod *m)\n{\n\tMonoClass *klass, *parent;\n\tMonoMethod *method = m->method;\n\tMonoMethod *result = NULL;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (method->klass == NULL)\n\t\treturn m;\n\n\tif (!(method->flags & METHOD_ATTRIBUTE_VIRTUAL) ||\n\t    MONO_CLASS_IS_INTERFACE (method->klass) ||\n\t    method->flags & METHOD_ATTRIBUTE_NEW_SLOT)\n\t\treturn m;\n\n\tklass = method->klass;\n\tif (klass->generic_class)\n\t\tklass = klass->generic_class->container_class;\n\n\t/* At the end of the loop, klass points to the eldest class that has this virtual function slot. */\n\tfor (parent = klass->parent; parent != NULL; parent = parent->parent) {\n\t\tmono_class_setup_vtable (parent);\n\t\tif (parent->vtable_size <= method->slot)\n\t\t\tbreak;\n\t\tklass = parent;\n\t}\t\t\n\n\tif (klass == method->klass)\n\t\treturn m;\n\n\tresult = klass->vtable [method->slot];\n\tif (result == NULL) {\n\t\t/* It is an abstract method */\n\t\tgpointer iter = NULL;\n\t\twhile ((result = mono_class_get_methods (klass, &iter)))\n\t\t\tif (result->slot == method->slot)\n\t\t\t\tbreak;\n\t}\n\n\tif (result == NULL)\n\t\treturn m;\n\n\treturn mono_method_get_object (mono_domain_get (), result, NULL);\n}\n\nstatic MonoString*\nves_icall_MonoMethod_get_name (MonoReflectionMethod *m)\n{\n\tMonoMethod *method = m->method;\n\n\tMONO_OBJECT_SETREF (m, name, mono_string_new (mono_object_domain (m), method->name));\n\treturn m->name;\n}\n\nstatic void\nmono_ArgIterator_Setup (MonoArgIterator *iter, char* argsp, char* start)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\titer->sig = *(MonoMethodSignature**)argsp;\n\t\n\tg_assert (iter->sig->sentinelpos <= iter->sig->param_count);\n\tg_assert (iter->sig->call_convention == MONO_CALL_VARARG);\n\n\titer->next_arg = 0;\n\t/* FIXME: it's not documented what start is exactly... */\n\tif (start) {\n\t\titer->args = start;\n\t} else {\n\t\titer->args = argsp + sizeof (gpointer);\n#ifndef MONO_ARCH_REGPARMS\n\t\t{\n\t\tguint32 i, arg_size;\n\t\tgint32 align;\n\t\tfor (i = 0; i < iter->sig->sentinelpos; ++i) {\n\t\t\targ_size = mono_type_stack_size (iter->sig->params [i], &align);\n\t\t\titer->args = (char*)iter->args + arg_size;\n\t\t}\n\t\t}\n#endif\n\t}\n\titer->num_args = iter->sig->param_count - iter->sig->sentinelpos;\n\n\t/* g_print (\"sig %p, param_count: %d, sent: %d\\n\", iter->sig, iter->sig->param_count, iter->sig->sentinelpos); */\n}\n\nstatic MonoTypedRef\nmono_ArgIterator_IntGetNextArg (MonoArgIterator *iter)\n{\n\tguint32 i, arg_size;\n\tgint32 align;\n\tMonoTypedRef res;\n\tMONO_ARCH_SAVE_REGS;\n\n\ti = iter->sig->sentinelpos + iter->next_arg;\n\n\tg_assert (i < iter->sig->param_count);\n\n\tres.type = iter->sig->params [i];\n\tres.klass = mono_class_from_mono_type (res.type);\n\tres.value = iter->args;\n\targ_size = mono_type_stack_size (res.type, &align);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\tif (arg_size <= sizeof (gpointer)) {\n\t\tint dummy;\n\t\tint padding = arg_size - mono_type_size (res.type, &dummy);\n\t\tres.value = (guint8*)res.value + padding;\n\t}\n#endif\n\titer->args = (char*)iter->args + arg_size;\n\titer->next_arg++;\n\n\t/* g_print (\"returning arg %d, type 0x%02x of size %d at %p\\n\", i, res.type->type, arg_size, res.value); */\n\n\treturn res;\n}\n\nstatic MonoTypedRef\nmono_ArgIterator_IntGetNextArgT (MonoArgIterator *iter, MonoType *type)\n{\n\tguint32 i, arg_size;\n\tgint32 align;\n\tMonoTypedRef res;\n\tMONO_ARCH_SAVE_REGS;\n\n\ti = iter->sig->sentinelpos + iter->next_arg;\n\n\tg_assert (i < iter->sig->param_count);\n\n\twhile (i < iter->sig->param_count) {\n\t\tif (!mono_metadata_type_equal (type, iter->sig->params [i]))\n\t\t\tcontinue;\n\t\tres.type = iter->sig->params [i];\n\t\tres.klass = mono_class_from_mono_type (res.type);\n\t\t/* FIXME: endianess issue... */\n\t\tres.value = iter->args;\n\t\targ_size = mono_type_stack_size (res.type, &align);\n\t\titer->args = (char*)iter->args + arg_size;\n\t\titer->next_arg++;\n\t\t/* g_print (\"returning arg %d, type 0x%02x of size %d at %p\\n\", i, res.type->type, arg_size, res.value); */\n\t\treturn res;\n\t}\n\t/* g_print (\"arg type 0x%02x not found\\n\", res.type->type); */\n\n\tres.type = NULL;\n\tres.value = NULL;\n\tres.klass = NULL;\n\treturn res;\n}\n\nstatic MonoType*\nmono_ArgIterator_IntGetNextArgType (MonoArgIterator *iter)\n{\n\tgint i;\n\tMONO_ARCH_SAVE_REGS;\n\t\n\ti = iter->sig->sentinelpos + iter->next_arg;\n\n\tg_assert (i < iter->sig->param_count);\n\n\treturn iter->sig->params [i];\n}\n\nstatic MonoObject*\nmono_TypedReference_ToObject (MonoTypedRef tref)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (MONO_TYPE_IS_REFERENCE (tref.type)) {\n\t\tMonoObject** objp = tref.value;\n\t\treturn *objp;\n\t}\n\n\treturn mono_value_box (mono_domain_get (), tref.klass, tref.value);\n}\n\nstatic MonoObject*\nmono_TypedReference_ToObjectInternal (MonoType *type, gpointer value, MonoClass *klass)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (MONO_TYPE_IS_REFERENCE (type)) {\n\t\tMonoObject** objp = value;\n\t\treturn *objp;\n\t}\n\n\treturn mono_value_box (mono_domain_get (), klass, value);\n}\n\nstatic void\nprelink_method (MonoMethod *method)\n{\n\tconst char *exc_class, *exc_arg;\n\tif (!(method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))\n\t\treturn;\n\tmono_lookup_pinvoke_call (method, &exc_class, &exc_arg);\n\tif (exc_class) {\n\t\tmono_raise_exception( \n\t\t\tmono_exception_from_name_msg (mono_defaults.corlib, \"System\", exc_class, exc_arg ) );\n\t}\n\t/* create the wrapper, too? */\n}\n\nstatic void\nves_icall_System_Runtime_InteropServices_Marshal_Prelink (MonoReflectionMethod *method)\n{\n\tMONO_ARCH_SAVE_REGS;\n\tprelink_method (method->method);\n}\n\nstatic void\nves_icall_System_Runtime_InteropServices_Marshal_PrelinkAll (MonoReflectionType *type)\n{\n\tMonoClass *klass = mono_class_from_mono_type (type->type);\n\tMonoMethod* m;\n\tgpointer iter = NULL;\n\tMONO_ARCH_SAVE_REGS;\n\n\twhile ((m = mono_class_get_methods (klass, &iter)))\n\t\tprelink_method (m);\n}\n\n/* These parameters are \"readonly\" in corlib/System/NumberFormatter.cs */\nstatic void\nves_icall_System_NumberFormatter_GetFormatterTables (guint64 const **mantissas,\n\t\t\t\t\t    gint32 const **exponents,\n\t\t\t\t\t    gunichar2 const **digitLowerTable,\n\t\t\t\t\t    gunichar2 const **digitUpperTable,\n\t\t\t\t\t    gint64 const **tenPowersList,\n\t\t\t\t\t    gint32 const **decHexDigits)\n{\n\t*mantissas = Formatter_MantissaBitsTable;\n\t*exponents = Formatter_TensExponentTable;\n\t*digitLowerTable = Formatter_DigitLowerTable;\n\t*digitUpperTable = Formatter_DigitUpperTable;\n\t*tenPowersList = Formatter_TenPowersList;\n\t*decHexDigits = Formatter_DecHexDigits;\n}\n\n/* These parameters are \"readonly\" in corlib/System/Char.cs */\nstatic void\nves_icall_System_Char_GetDataTablePointers (guint8 const **category_data,\n\t\t\t\t\t    guint8 const **numeric_data,\n\t\t\t\t\t    gdouble const **numeric_data_values,\n\t\t\t\t\t    guint16 const **to_lower_data_low,\n\t\t\t\t\t    guint16 const **to_lower_data_high,\n\t\t\t\t\t    guint16 const **to_upper_data_low,\n\t\t\t\t\t    guint16 const **to_upper_data_high)\n{\n\t*category_data = CategoryData;\n\t*numeric_data = NumericData;\n\t*numeric_data_values = NumericDataValues;\n\t*to_lower_data_low = ToLowerDataLow;\n\t*to_lower_data_high = ToLowerDataHigh;\n\t*to_upper_data_low = ToUpperDataLow;\n\t*to_upper_data_high = ToUpperDataHigh;\n}\n\nstatic gint32\nves_icall_MonoDebugger_GetMethodToken (MonoReflectionMethod *method)\n{\n\treturn method->method->token;\n}\n\n/*\n * We return NULL for no modifiers so the corlib code can return Type.EmptyTypes\n * and avoid useless allocations.\n */\nstatic MonoArray*\ntype_array_from_modifiers (MonoImage *image, MonoType *type, int optional)\n{\n\tMonoArray *res;\n\tint i, count = 0;\n\tfor (i = 0; i < type->num_mods; ++i) {\n\t\tif ((optional && !type->modifiers [i].required) || (!optional && type->modifiers [i].required))\n\t\t\tcount++;\n\t}\n\tif (!count)\n\t\treturn NULL;\n\tres = mono_array_new (mono_domain_get (), mono_defaults.systemtype_class, count);\n\tcount = 0;\n\tfor (i = 0; i < type->num_mods; ++i) {\n\t\tif ((optional && !type->modifiers [i].required) || (!optional && type->modifiers [i].required)) {\n\t\t\tMonoClass *klass = mono_class_get (image, type->modifiers [i].token);\n\t\t\tmono_array_setref (res, count, mono_type_get_object (mono_domain_get (), &klass->byval_arg));\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic MonoArray*\nparam_info_get_type_modifiers (MonoReflectionParameter *param, MonoBoolean optional)\n{\n\tMonoType *type = param->ClassImpl->type;\n\tMonoClass *member_class = mono_object_class (param->MemberImpl);\n\tMonoMethod *method = NULL;\n\tMonoImage *image;\n\tint pos;\n\tMonoMethodSignature *sig;\n\n\tif (mono_class_is_reflection_method_or_constructor (member_class)) {\n\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)param->MemberImpl;\n\t\tmethod = rmethod->method;\n\t} else if (member_class->image == mono_defaults.corlib && !strcmp (\"MonoProperty\", member_class->name)) {\n\t\tMonoReflectionProperty *prop = (MonoReflectionProperty *)param->MemberImpl;\n\t\tif (!(method = prop->property->get))\n\t\t\tmethod = prop->property->set;\n\t\tg_assert (method);\t\n\t} else {\n\t\tchar *type_name = mono_type_get_full_name (member_class);\n\t\tchar *msg = g_strdup_printf (\"Custom modifiers on a ParamInfo with member %s are not supported\", type_name);\n\t\tMonoException *ex = mono_get_exception_not_supported  (msg);\n\t\tg_free (type_name);\n\t\tg_free (msg);\n\t\tmono_raise_exception (ex);\n\t}\n\n\timage = method->klass->image;\n\tpos = param->PositionImpl;\n\tsig = mono_method_signature (method);\n\tif (pos == -1)\n\t\ttype = sig->ret;\n\telse\n\t\ttype = sig->params [pos];\n\n\treturn type_array_from_modifiers (image, type, optional);\n}\n\nstatic MonoType*\nget_property_type (MonoProperty *prop)\n{\n\tMonoMethodSignature *sig;\n\tif (prop->get) {\n\t\tsig = mono_method_signature (prop->get);\n\t\treturn sig->ret;\n\t} else if (prop->set) {\n\t\tsig = mono_method_signature (prop->set);\n\t\treturn sig->params [sig->param_count - 1];\n\t}\n\treturn NULL;\n}\n\nstatic MonoArray*\nproperty_info_get_type_modifiers (MonoReflectionProperty *property, MonoBoolean optional)\n{\n\tMonoType *type = get_property_type (property->property);\n\tMonoImage *image = property->klass->image;\n\n\tif (!type)\n\t\treturn NULL;\n\treturn type_array_from_modifiers (image, type, optional);\n}\n\nstatic MonoBoolean\ncustom_attrs_defined_internal (MonoObject *obj, MonoReflectionType *attr_type)\n{\n\tMonoCustomAttrInfo *cinfo;\n\tgboolean found;\n\n\tcinfo = mono_reflection_get_custom_attrs_info (obj);\n\tif (!cinfo)\n\t\treturn FALSE;\n\tfound = mono_custom_attrs_has_attr (cinfo, mono_class_from_mono_type (attr_type->type));\n\tif (!cinfo->cached)\n\t\tmono_custom_attrs_free (cinfo);\n\treturn found;\n}\n\nstatic MonoArray*\ncustom_attrs_get_by_type (MonoObject *obj, MonoReflectionType *attr_type)\n{\n\tMonoArray *res = mono_reflection_get_custom_attrs_by_type (obj, attr_type ? mono_class_from_mono_type (attr_type->type) : NULL);\n\n\tif (mono_loader_get_last_error ()) {\n\t\tmono_raise_exception (mono_loader_error_prepare_exception (mono_loader_get_last_error ()));\n\t\tg_assert_not_reached ();\n\t\t/* Not reached */\n\t\treturn NULL;\n\t} else {\n\t\treturn res;\n\t}\n}\n\nstatic MonoString*\nves_icall_Mono_Runtime_GetDisplayName (void)\n{\n\tchar *info;\n\tMonoString *display_name;\n\n\tinfo = mono_get_runtime_callbacks ()->get_runtime_build_info ();\n\tdisplay_name = mono_string_new (mono_domain_get (), info);\n\tg_free (info);\n\treturn display_name;\n}\n\nstatic MonoString*\nves_icall_System_ComponentModel_Win32Exception_W32ErrorMessage (guint32 code)\n{\n\tMonoString *message;\n\tguint32 ret;\n\tgunichar2 buf[256];\n\t\n\tret = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\t     FORMAT_MESSAGE_IGNORE_INSERTS, NULL, code, 0,\n\t\t\t     buf, 255, NULL);\n\tif (ret == 0) {\n\t\tmessage = mono_string_new (mono_domain_get (), \"Error looking up error string\");\n\t} else {\n\t\tmessage = mono_string_new_utf16 (mono_domain_get (), buf, ret);\n\t}\n\t\n\treturn message;\n}\n\nconst static guchar\ndbase64 [] = {\n\t128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,\n\t128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,\n\t128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 62, 128, 128, 128, 63,\n\t52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 128, 128, 128, 0, 128, 128,\n\t128, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n\t15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 128, 128, 128, 128, 128,\n\t128, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n\t41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n};\n\nstatic MonoArray *\nbase64_to_byte_array (gunichar2 *start, gint ilength, MonoBoolean allowWhitespaceOnly)\n{\n\tgint ignored;\n\tgint i;\n\tgunichar2 c;\n\tgunichar2 last, prev_last, prev2_last;\n\tgint olength;\n\tMonoArray *result;\n\tguchar *res_ptr;\n\tgint a [4], b [4];\n\tMonoException *exc;\n\n\tignored = 0;\n\tlast = prev_last = 0, prev2_last = 0;\n\tfor (i = 0; i < ilength; i++) {\n\t\tc = start [i];\n\t\tif (c >= sizeof (dbase64)) {\n\t\t\texc = mono_exception_from_name_msg (mono_get_corlib (),\n\t\t\t\t\"System\", \"FormatException\",\n\t\t\t\t\"Invalid character found.\");\n\t\t\tmono_raise_exception (exc);\n\t\t} else if (isspace (c)) {\n\t\t\tignored++;\n\t\t} else {\n\t\t\tprev2_last = prev_last;\n\t\t\tprev_last = last;\n\t\t\tlast = c;\n\t\t}\n\t}\n\n\tolength = ilength - ignored;\n\n\tif (allowWhitespaceOnly && olength == 0) {\n\t\treturn mono_array_new (mono_domain_get (), mono_defaults.byte_class, 0);\n\t}\n\n\tif ((olength & 3) != 0 || olength <= 0) {\n\t\texc = mono_exception_from_name_msg (mono_get_corlib (), \"System\",\n\t\t\t\t\t\"FormatException\", \"Invalid length.\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tif (prev2_last == '=') {\n\t\texc = mono_exception_from_name_msg (mono_get_corlib (), \"System\", \"FormatException\", \"Invalid format.\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tolength = (olength * 3) / 4;\n\tif (last == '=')\n\t\tolength--;\n\n\tif (prev_last == '=')\n\t\tolength--;\n\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, olength);\n\tres_ptr = mono_array_addr (result, guchar, 0);\n\tfor (i = 0; i < ilength; ) {\n\t\tint k;\n\n\t\tfor (k = 0; k < 4 && i < ilength;) {\n\t\t\tc = start [i++];\n\t\t\tif (isspace (c))\n\t\t\t\tcontinue;\n\n\t\t\ta [k] = (guchar) c;\n\t\t\tif (((b [k] = dbase64 [c]) & 0x80) != 0) {\n\t\t\t\texc = mono_exception_from_name_msg (mono_get_corlib (),\n\t\t\t\t\t\"System\", \"FormatException\",\n\t\t\t\t\t\"Invalid character found.\");\n\t\t\t\tmono_raise_exception (exc);\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\t*res_ptr++ = (b [0] << 2) | (b [1] >> 4);\n\t\tif (a [2] != '=')\n\t\t\t*res_ptr++ = (b [1] << 4) | (b [2] >> 2);\n\t\tif (a [3] != '=')\n\t\t\t*res_ptr++ = (b [2] << 6) | b [3];\n\n\t\twhile (i < ilength && isspace (start [i]))\n\t\t\ti++;\n\t}\n\n\treturn result;\n}\n\nstatic MonoArray *\nInternalFromBase64String (MonoString *str, MonoBoolean allowWhitespaceOnly)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn base64_to_byte_array (mono_string_chars (str), \n\t\tmono_string_length (str), allowWhitespaceOnly);\n}\n\nstatic MonoArray *\nInternalFromBase64CharArray (MonoArray *input, gint offset, gint length)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn base64_to_byte_array (mono_array_addr (input, gunichar2, offset),\n\t\tlength, FALSE);\n}\n\n#define ICALL_TYPE(id,name,first)\n#define ICALL(id,name,func) Icall_ ## id,\n\nenum {\n#include \"metadata/icall-def.h\"\n\tIcall_last\n};\n\n#undef ICALL_TYPE\n#undef ICALL\n#define ICALL_TYPE(id,name,first) Icall_type_ ## id,\n#define ICALL(id,name,func)\nenum {\n#include \"metadata/icall-def.h\"\n\tIcall_type_num\n};\n\n#undef ICALL_TYPE\n#undef ICALL\n#define ICALL_TYPE(id,name,firstic) {(Icall_ ## firstic)},\n#define ICALL(id,name,func)\ntypedef struct {\n\tguint16 first_icall;\n} IcallTypeDesc;\n\nstatic const IcallTypeDesc\nicall_type_descs [] = {\n#include \"metadata/icall-def.h\"\n\t{Icall_last}\n};\n\n#define icall_desc_num_icalls(desc) ((desc) [1].first_icall - (desc) [0].first_icall)\n\n#undef ICALL_TYPE\n#define ICALL_TYPE(id,name,first)\n#undef ICALL\n\n#ifdef HAVE_ARRAY_ELEM_INIT\n#define MSGSTRFIELD(line) MSGSTRFIELD1(line)\n#define MSGSTRFIELD1(line) str##line\n\nstatic const struct msgstrtn_t {\n#define ICALL(id,name,func)\n#undef ICALL_TYPE\n#define ICALL_TYPE(id,name,first) char MSGSTRFIELD(__LINE__) [sizeof (name)];\n#include \"metadata/icall-def.h\"\n#undef ICALL_TYPE\n} icall_type_names_str = {\n#define ICALL_TYPE(id,name,first) (name),\n#include \"metadata/icall-def.h\"\n#undef ICALL_TYPE\n};\nstatic const guint16 icall_type_names_idx [] = {\n#define ICALL_TYPE(id,name,first) [Icall_type_ ## id] = offsetof (struct msgstrtn_t, MSGSTRFIELD(__LINE__)),\n#include \"metadata/icall-def.h\"\n#undef ICALL_TYPE\n};\n#define icall_type_name_get(id) ((const char*)&icall_type_names_str + icall_type_names_idx [(id)])\n\nstatic const struct msgstr_t {\n#undef ICALL\n#define ICALL_TYPE(id,name,first)\n#define ICALL(id,name,func) char MSGSTRFIELD(__LINE__) [sizeof (name)];\n#include \"metadata/icall-def.h\"\n#undef ICALL\n} icall_names_str = {\n#define ICALL(id,name,func) (name),\n#include \"metadata/icall-def.h\"\n#undef ICALL\n};\nstatic const guint16 icall_names_idx [] = {\n#define ICALL(id,name,func) [Icall_ ## id] = offsetof (struct msgstr_t, MSGSTRFIELD(__LINE__)),\n#include \"metadata/icall-def.h\"\n#undef ICALL\n};\n#define icall_name_get(id) ((const char*)&icall_names_str + icall_names_idx [(id)])\n\n#else\n\n#undef ICALL_TYPE\n#undef ICALL\n#define ICALL_TYPE(id,name,first) name,\n#define ICALL(id,name,func)\nstatic const char* const\nicall_type_names [] = {\n#include \"metadata/icall-def.h\"\n\tNULL\n};\n\n#define icall_type_name_get(id) (icall_type_names [(id)])\n\n#undef ICALL_TYPE\n#undef ICALL\n#define ICALL_TYPE(id,name,first)\n#define ICALL(id,name,func) name,\nstatic const char* const\nicall_names [] = {\n#include \"metadata/icall-def.h\"\n\tNULL\n};\n#define icall_name_get(id) icall_names [(id)]\n\n#endif /* !HAVE_ARRAY_ELEM_INIT */\n\n#undef ICALL_TYPE\n#undef ICALL\n#define ICALL_TYPE(id,name,first)\n#define ICALL(id,name,func) func,\nstatic const gconstpointer\nicall_functions [] = {\n#include \"metadata/icall-def.h\"\n\tNULL\n};\n\nstatic GHashTable *icall_hash = NULL;\nstatic GHashTable *jit_icall_hash_name = NULL;\nstatic GHashTable *jit_icall_hash_addr = NULL;\n\nvoid\nmono_icall_init (void)\n{\n\tint i = 0;\n\n\t/* check that tables are sorted: disable in release */\n\tif (TRUE) {\n\t\tint j;\n\t\tconst char *prev_class = NULL;\n\t\tconst char *prev_method;\n\t\t\n\t\tfor (i = 0; i < Icall_type_num; ++i) {\n\t\t\tconst IcallTypeDesc *desc;\n\t\t\tint num_icalls;\n\t\t\tprev_method = NULL;\n\t\t\tif (prev_class && strcmp (prev_class, icall_type_name_get (i)) >= 0)\n\t\t\t\tg_print (\"class %s should come before class %s\\n\", icall_type_name_get (i), prev_class);\n\t\t\tprev_class = icall_type_name_get (i);\n\t\t\tdesc = &icall_type_descs [i];\n\t\t\tnum_icalls = icall_desc_num_icalls (desc);\n\t\t\t/*g_print (\"class %s has %d icalls starting at %d\\n\", prev_class, num_icalls, desc->first_icall);*/\n\t\t\tfor (j = 0; j < num_icalls; ++j) {\n\t\t\t\tconst char *methodn = icall_name_get (desc->first_icall + j);\n\t\t\t\tif (prev_method && strcmp (prev_method, methodn) >= 0)\n\t\t\t\t\tg_print (\"method %s should come before method %s\\n\", methodn, prev_method);\n\t\t\t\tprev_method = methodn;\n\t\t\t}\n\t\t}\n\t}\n\n\ticall_hash = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}\n\nvoid\nmono_icall_cleanup (void)\n{\n\tg_hash_table_destroy (icall_hash);\n\tg_hash_table_destroy (jit_icall_hash_name);\n\tg_hash_table_destroy (jit_icall_hash_addr);\n}\n\nvoid\nmono_add_internal_call (const char *name, gconstpointer method)\n{\n\tmono_loader_lock ();\n\n\tg_hash_table_insert (icall_hash, g_strdup (name), (gpointer) method);\n\n\tmono_loader_unlock ();\n}\n\n#ifdef HAVE_ARRAY_ELEM_INIT\nstatic int\ncompare_method_imap (const void *key, const void *elem)\n{\n\tconst char* method_name = (const char*)&icall_names_str + (*(guint16*)elem);\n\treturn strcmp (key, method_name);\n}\n\nstatic gpointer\nfind_method_icall (const IcallTypeDesc *imap, const char *name)\n{\n\tconst guint16 *nameslot = bsearch (name, icall_names_idx + imap->first_icall, icall_desc_num_icalls (imap), sizeof (icall_names_idx [0]), compare_method_imap);\n\tif (!nameslot)\n\t\treturn NULL;\n\treturn (gpointer)icall_functions [(nameslot - &icall_names_idx [0])];\n}\n\nstatic int\ncompare_class_imap (const void *key, const void *elem)\n{\n\tconst char* class_name = (const char*)&icall_type_names_str + (*(guint16*)elem);\n\treturn strcmp (key, class_name);\n}\n\nstatic const IcallTypeDesc*\nfind_class_icalls (const char *name)\n{\n\tconst guint16 *nameslot = bsearch (name, icall_type_names_idx, Icall_type_num, sizeof (icall_type_names_idx [0]), compare_class_imap);\n\tif (!nameslot)\n\t\treturn NULL;\n\treturn &icall_type_descs [nameslot - &icall_type_names_idx [0]];\n}\n\n#else\nstatic int\ncompare_method_imap (const void *key, const void *elem)\n{\n\tconst char** method_name = (const char**)elem;\n\treturn strcmp (key, *method_name);\n}\n\nstatic gpointer\nfind_method_icall (const IcallTypeDesc *imap, const char *name)\n{\n\tconst char **nameslot = bsearch (name, icall_names + imap->first_icall, icall_desc_num_icalls (imap), sizeof (icall_names [0]), compare_method_imap);\n\tif (!nameslot)\n\t\treturn NULL;\n\treturn (gpointer)icall_functions [(nameslot - icall_names)];\n}\n\nstatic int\ncompare_class_imap (const void *key, const void *elem)\n{\n\tconst char** class_name = (const char**)elem;\n\treturn strcmp (key, *class_name);\n}\n\nstatic const IcallTypeDesc*\nfind_class_icalls (const char *name)\n{\n\tconst char **nameslot = bsearch (name, icall_type_names, Icall_type_num, sizeof (icall_type_names [0]), compare_class_imap);\n\tif (!nameslot)\n\t\treturn NULL;\n\treturn &icall_type_descs [nameslot - icall_type_names];\n}\n\n#endif\n\n/* \n * we should probably export this as an helper (handle nested types).\n * Returns the number of chars written in buf.\n */\nstatic int\nconcat_class_name (char *buf, int bufsize, MonoClass *klass)\n{\n\tint nspacelen, cnamelen;\n\tnspacelen = strlen (klass->name_space);\n\tcnamelen = strlen (klass->name);\n\tif (nspacelen + cnamelen + 2 > bufsize)\n\t\treturn 0;\n\tif (nspacelen) {\n\t\tmemcpy (buf, klass->name_space, nspacelen);\n\t\tbuf [nspacelen ++] = '.';\n\t}\n\tmemcpy (buf + nspacelen, klass->name, cnamelen);\n\tbuf [nspacelen + cnamelen] = 0;\n\treturn nspacelen + cnamelen;\n}\n\ngpointer\nmono_lookup_internal_call (MonoMethod *method)\n{\n\tchar *sigstart;\n\tchar *tmpsig;\n\tchar mname [2048];\n\tint typelen = 0, mlen, siglen;\n\tgpointer res;\n\tconst IcallTypeDesc *imap;\n\n\tg_assert (method != NULL);\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tif (method->klass->nested_in) {\n\t\tint pos = concat_class_name (mname, sizeof (mname)-2, method->klass->nested_in);\n\t\tif (!pos)\n\t\t\treturn NULL;\n\n\t\tmname [pos++] = '/';\n\t\tmname [pos] = 0;\n\n\t\ttypelen = concat_class_name (mname+pos, sizeof (mname)-pos-1, method->klass);\n\t\tif (!typelen)\n\t\t\treturn NULL;\n\n\t\ttypelen += pos;\n\t} else {\n\t\ttypelen = concat_class_name (mname, sizeof (mname), method->klass);\n\t\tif (!typelen)\n\t\t\treturn NULL;\n\t}\n\n\timap = find_class_icalls (mname);\n\n\tmname [typelen] = ':';\n\tmname [typelen + 1] = ':';\n\n\tmlen = strlen (method->name);\n\tmemcpy (mname + typelen + 2, method->name, mlen);\n\tsigstart = mname + typelen + 2 + mlen;\n\t*sigstart = 0;\n\n\ttmpsig = mono_signature_get_desc (mono_method_signature (method), TRUE);\n\tsiglen = strlen (tmpsig);\n\tif (typelen + mlen + siglen + 6 > sizeof (mname))\n\t\treturn NULL;\n\tsigstart [0] = '(';\n\tmemcpy (sigstart + 1, tmpsig, siglen);\n\tsigstart [siglen + 1] = ')';\n\tsigstart [siglen + 2] = 0;\n\tg_free (tmpsig);\n\t\n\tmono_loader_lock ();\n\n\tres = g_hash_table_lookup (icall_hash, mname);\n\tif (res) {\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\t/* try without signature */\n\t*sigstart = 0;\n\tres = g_hash_table_lookup (icall_hash, mname);\n\tif (res) {\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\n\t/* it wasn't found in the static call tables */\n\tif (!imap) {\n\t\tmono_loader_unlock ();\n\t\treturn NULL;\n\t}\n\tres = find_method_icall (imap, sigstart - mlen);\n\tif (res) {\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\t/* try _with_ signature */\n\t*sigstart = '(';\n\tres = find_method_icall (imap, sigstart - mlen);\n\tif (res) {\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\n\tg_warning (\"cant resolve internal call to \\\"%s\\\" (tested without signature also)\", mname);\n\tg_print (\"\\nYour mono runtime and class libraries are out of sync.\\n\");\n\tg_print (\"The out of sync library is: %s\\n\", method->klass->image->name);\n\tg_print (\"\\nWhen you update one from svn you need to update, compile and install\\nthe other too.\\n\");\n\tg_print (\"Do not report this as a bug unless you're sure you have updated correctly:\\nyou probably have a broken mono install.\\n\");\n\tg_print (\"If you see other errors or faults after this message they are probably related\\n\");\n\tg_print (\"and you need to fix your mono install first.\\n\");\n\n\tmono_loader_unlock ();\n\n\treturn NULL;\n}\n\nstatic MonoType*\ntype_from_typename (char *typename)\n{\n\tMonoClass *klass = NULL;\t/* assignment to shut GCC warning up */\n\n\tif (!strcmp (typename, \"int\"))\n\t\tklass = mono_defaults.int_class;\n\telse if (!strcmp (typename, \"ptr\"))\n\t\tklass = mono_defaults.int_class;\n\telse if (!strcmp (typename, \"void\"))\n\t\tklass = mono_defaults.void_class;\n\telse if (!strcmp (typename, \"int32\"))\n\t\tklass = mono_defaults.int32_class;\n\telse if (!strcmp (typename, \"uint32\"))\n\t\tklass = mono_defaults.uint32_class;\n\telse if (!strcmp (typename, \"int8\"))\n\t\tklass = mono_defaults.sbyte_class;\n\telse if (!strcmp (typename, \"uint8\"))\n\t\tklass = mono_defaults.byte_class;\n\telse if (!strcmp (typename, \"int16\"))\n\t\tklass = mono_defaults.int16_class;\n\telse if (!strcmp (typename, \"uint16\"))\n\t\tklass = mono_defaults.uint16_class;\n\telse if (!strcmp (typename, \"long\"))\n\t\tklass = mono_defaults.int64_class;\n\telse if (!strcmp (typename, \"ulong\"))\n\t\tklass = mono_defaults.uint64_class;\n\telse if (!strcmp (typename, \"float\"))\n\t\tklass = mono_defaults.single_class;\n\telse if (!strcmp (typename, \"double\"))\n\t\tklass = mono_defaults.double_class;\n\telse if (!strcmp (typename, \"object\"))\n\t\tklass = mono_defaults.object_class;\n\telse if (!strcmp (typename, \"obj\"))\n\t\tklass = mono_defaults.object_class;\n\telse if (!strcmp (typename, \"string\"))\n\t\tklass = mono_defaults.string_class;\n\telse if (!strcmp (typename, \"bool\"))\n\t\tklass = mono_defaults.boolean_class;\n\telse if (!strcmp (typename, \"boolean\"))\n\t\tklass = mono_defaults.boolean_class;\n\telse {\n\t\tg_error (\"%s\", typename);\n\t\tg_assert_not_reached ();\n\t}\n\treturn &klass->byval_arg;\n}\n\nMonoMethodSignature*\nmono_create_icall_signature (const char *sigstr)\n{\n\tgchar **parts;\n\tint i, len;\n\tgchar **tmp;\n\tMonoMethodSignature *res;\n\n\tmono_loader_lock ();\n\tres = g_hash_table_lookup (mono_defaults.corlib->helper_signatures, sigstr);\n\tif (res) {\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\n\tparts = g_strsplit (sigstr, \" \", 256);\n\n\ttmp = parts;\n\tlen = 0;\n\twhile (*tmp) {\n\t\tlen ++;\n\t\ttmp ++;\n\t}\n\n\tres = mono_metadata_signature_alloc (mono_defaults.corlib, len - 1);\n\tres->pinvoke = 1;\n\n#ifdef PLATFORM_WIN32\n\t/* \n\t * Under windows, the default pinvoke calling convention is STDCALL but\n\t * we need CDECL.\n\t */\n\tres->call_convention = MONO_CALL_C;\n#endif\n\n\tres->ret = type_from_typename (parts [0]);\n\tfor (i = 1; i < len; ++i) {\n\t\tres->params [i - 1] = type_from_typename (parts [i]);\n\t}\n\n\tg_strfreev (parts);\n\n\tg_hash_table_insert (mono_defaults.corlib->helper_signatures, (gpointer)sigstr, res);\n\n\tmono_loader_unlock ();\n\n\treturn res;\n}\n\nMonoJitICallInfo *\nmono_find_jit_icall_by_name (const char *name)\n{\n\tMonoJitICallInfo *info;\n\tg_assert (jit_icall_hash_name);\n\n\tmono_loader_lock ();\n\tinfo = g_hash_table_lookup (jit_icall_hash_name, name);\n\tmono_loader_unlock ();\n\treturn info;\n}\n\nMonoJitICallInfo *\nmono_find_jit_icall_by_addr (gconstpointer addr)\n{\n\tMonoJitICallInfo *info;\n\tg_assert (jit_icall_hash_addr);\n\n\tmono_loader_lock ();\n\tinfo = g_hash_table_lookup (jit_icall_hash_addr, (gpointer)addr);\n\tmono_loader_unlock ();\n\n\treturn info;\n}\n\n/*\n * mono_get_jit_icall_info:\n *\n *   Return the hashtable mapping JIT icall names to MonoJitICallInfo structures. The\n * caller should access it while holding the loader lock.\n */\nGHashTable*\nmono_get_jit_icall_info (void)\n{\n\treturn jit_icall_hash_name;\n}\n\nvoid\nmono_register_jit_icall_wrapper (MonoJitICallInfo *info, gconstpointer wrapper)\n{\n\tmono_loader_lock ();\n\tg_hash_table_insert (jit_icall_hash_addr, (gpointer)wrapper, info);\n\tmono_loader_unlock ();\n}\n\nMonoJitICallInfo *\nmono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)\n{\n\tMonoJitICallInfo *info;\n\t\n\tg_assert (func);\n\tg_assert (name);\n\n\tmono_loader_lock ();\n\n\tif (!jit_icall_hash_name) {\n\t\tjit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);\n\t\tjit_icall_hash_addr = g_hash_table_new (NULL, NULL);\n\t}\n\n\tif (g_hash_table_lookup (jit_icall_hash_name, name)) {\n\t\tg_warning (\"jit icall already defined \\\"%s\\\"\\n\", name);\n\t\tg_assert_not_reached ();\n\t}\n\n\tinfo = g_new0 (MonoJitICallInfo, 1);\n\t\n\tinfo->name = name;\n\tinfo->func = func;\n\tinfo->sig = sig;\n\n\tif (is_save) {\n\t\tinfo->wrapper = func;\n\t} else {\n\t\tinfo->wrapper = NULL;\n\t}\n\n\tg_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);\n\tg_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);\n\n\tmono_loader_unlock ();\n\treturn info;\n}\n"], "fixing_code": ["/*\n * icall.c:\n *\n * Authors:\n *   Dietmar Maurer (dietmar@ximian.com)\n *   Paolo Molaro (lupus@ximian.com)\n *\t Patrik Torstensson (patrik.torstensson@labs2.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n */\n\n#include <config.h>\n#include <glib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <ctype.h>\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if defined (PLATFORM_WIN32)\n#include <stdlib.h>\n#endif\n\n#include \"mono/utils/mono-membar.h\"\n#include <mono/metadata/object.h>\n#include <mono/metadata/threads.h>\n#include <mono/metadata/threads-types.h>\n#include <mono/metadata/threadpool.h>\n#include <mono/metadata/monitor.h>\n#include <mono/metadata/reflection.h>\n#include <mono/metadata/assembly.h>\n#include <mono/metadata/tabledefs.h>\n#include <mono/metadata/exception.h>\n#include <mono/metadata/file-io.h>\n#include <mono/metadata/console-io.h>\n#include <mono/metadata/socket-io.h>\n#include <mono/metadata/mono-endian.h>\n#include <mono/metadata/tokentype.h>\n#include <mono/metadata/domain-internals.h>\n#include <mono/metadata/metadata-internals.h>\n#include <mono/metadata/class-internals.h>\n#include <mono/metadata/marshal.h>\n#include <mono/metadata/gc-internal.h>\n#include <mono/metadata/mono-gc.h>\n#include <mono/metadata/rand.h>\n#include <mono/metadata/sysmath.h>\n#include <mono/metadata/string-icalls.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/metadata/process.h>\n#include <mono/metadata/environment.h>\n#include <mono/metadata/profiler-private.h>\n#include <mono/metadata/locales.h>\n#include <mono/metadata/filewatcher.h>\n#include <mono/metadata/char-conversions.h>\n#include <mono/metadata/security.h>\n#include <mono/metadata/mono-config.h>\n#include <mono/metadata/cil-coff.h>\n#include <mono/metadata/number-formatter.h>\n#include <mono/metadata/security-manager.h>\n#include <mono/metadata/security-core-clr.h>\n#include <mono/metadata/mono-perfcounters.h>\n#include <mono/metadata/mono-debug.h>\n#include <mono/metadata/verify-internals.h>\n#include <mono/io-layer/io-layer.h>\n#include <mono/utils/strtod.h>\n#include <mono/utils/monobitset.h>\n#include <mono/utils/mono-time.h>\n#include <mono/utils/mono-proclib.h>\n#include <mono/utils/mono-string.h>\n#include <mono/utils/mono-error-internals.h>\n\n\n#if defined (PLATFORM_WIN32)\n#include <windows.h>\n#include <shlobj.h>\n#endif\n#include \"decimal.h\"\n\nstatic MonoReflectionAssembly* ves_icall_System_Reflection_Assembly_GetCallingAssembly (void);\n\nstatic MonoArray*\ntype_array_from_modifiers (MonoImage *image, MonoType *type, int optional);\n\n/* This is an implementation of a growable pointer array that avoids doing memory allocations for small sizes.\n * It works by allocating an initial small array on stack and only going to malloc'd memory if needed. \n */\ntypedef struct {\n\tvoid **data;\n\tint size;\n\tint capacity;\n} MonoPtrArray;\n\n#define MONO_PTR_ARRAY_MAX_ON_STACK (16)\n\n#define mono_ptr_array_init(ARRAY, INITIAL_SIZE) do {\\\n\t(ARRAY).size = 0; \\\n\t(ARRAY).capacity = MAX (INITIAL_SIZE, MONO_PTR_ARRAY_MAX_ON_STACK); \\\n\t(ARRAY).data = INITIAL_SIZE > MONO_PTR_ARRAY_MAX_ON_STACK ? mono_gc_alloc_fixed (sizeof (void*) * INITIAL_SIZE, NULL) : g_newa (void*, MONO_PTR_ARRAY_MAX_ON_STACK); \\\n} while (0)\n\n#define mono_ptr_array_destroy(ARRAY) do {\\\n\tif ((ARRAY).capacity > MONO_PTR_ARRAY_MAX_ON_STACK) \\\n\t\tmono_gc_free_fixed ((ARRAY).data); \\\n} while (0)\n\n#define mono_ptr_array_append(ARRAY, VALUE) do { \\\n\tif ((ARRAY).size >= (ARRAY).capacity) {\\\n\t\tvoid *__tmp = mono_gc_alloc_fixed (sizeof (void*) * (ARRAY).capacity * 2, NULL); \\\n\t\tmemcpy (__tmp, (ARRAY).data, (ARRAY).capacity * sizeof (void*)); \\\n\t\tif ((ARRAY).capacity > MONO_PTR_ARRAY_MAX_ON_STACK)\t\\\n\t\t\tmono_gc_free_fixed ((ARRAY).data);\t\\\n\t\t(ARRAY).data = __tmp;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t(ARRAY).capacity *= 2;\\\n\t}\\\n\t((ARRAY).data [(ARRAY).size++] = VALUE); \\\n} while (0)\n\n#define mono_ptr_array_set(ARRAY, IDX, VALUE) do { \\\n\t((ARRAY).data [(IDX)] = VALUE); \\\n} while (0)\n\t\n#define mono_ptr_array_get(ARRAY, IDX) ((ARRAY).data [(IDX)])\n\n#define mono_ptr_array_size(ARRAY) ((ARRAY).size)\n\n\nstatic inline MonoBoolean\nis_generic_parameter (MonoType *type)\n{\n\treturn !type->byref && (type->type == MONO_TYPE_VAR || type->type == MONO_TYPE_MVAR);\n}\n\n/*\n * We expect a pointer to a char, not a string\n */\nstatic gboolean\nmono_double_ParseImpl (char *ptr, double *result)\n{\n\tgchar *endptr = NULL;\n\t*result = 0.0;\n\n\tMONO_ARCH_SAVE_REGS;\n\n#ifdef __arm__\n\tif (*ptr)\n\t\t*result = strtod (ptr, &endptr);\n#else\n\tif (*ptr){\n#ifdef _EGLIB_MAJOR\n\t\t/* Need to lock here because EGLIB (#464316) has locking defined as no-ops, and that breaks mono_strtod */\n\t\tEnterCriticalSection (&mono_strtod_mutex);\n\t\t*result = mono_strtod (ptr, &endptr);\n\t\tLeaveCriticalSection (&mono_strtod_mutex);\n#else\n\t\t*result = mono_strtod (ptr, &endptr);\n#endif\n\t}\n#endif\n\n\tif (!*ptr || (endptr && *endptr))\n\t\treturn FALSE;\n\t\n\treturn TRUE;\n}\n\nstatic MonoObject *\nves_icall_System_Array_GetValueImpl (MonoObject *this, guint32 pos)\n{\n\tMonoClass *ac;\n\tMonoArray *ao;\n\tgint32 esize;\n\tgpointer *ea;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tao = (MonoArray *)this;\n\tac = (MonoClass *)ao->obj.vtable->klass;\n\n\tesize = mono_array_element_size (ac);\n\tea = (gpointer*)((char*)ao->vector + (pos * esize));\n\n\tif (ac->element_class->valuetype)\n\t\treturn mono_value_box (this->vtable->domain, ac->element_class, ea);\n\telse\n\t\treturn *ea;\n}\n\nstatic MonoObject *\nves_icall_System_Array_GetValue (MonoObject *this, MonoObject *idxs)\n{\n\tMonoClass *ac, *ic;\n\tMonoArray *ao, *io;\n\tgint32 i, pos, *ind;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (idxs);\n\n\tio = (MonoArray *)idxs;\n\tic = (MonoClass *)io->obj.vtable->klass;\n\t\n\tao = (MonoArray *)this;\n\tac = (MonoClass *)ao->obj.vtable->klass;\n\n\tg_assert (ic->rank == 1);\n\tif (io->bounds != NULL || io->max_length !=  ac->rank)\n\t\tmono_raise_exception (mono_get_exception_argument (NULL, NULL));\n\n\tind = (gint32 *)io->vector;\n\n\tif (ao->bounds == NULL) {\n\t\tif (*ind < 0 || *ind >= ao->max_length)\n\t\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\n\t\treturn ves_icall_System_Array_GetValueImpl (this, *ind);\n\t}\n\t\n\tfor (i = 0; i < ac->rank; i++)\n\t\tif ((ind [i] < ao->bounds [i].lower_bound) ||\n\t\t    (ind [i] >=  (mono_array_lower_bound_t)ao->bounds [i].length + ao->bounds [i].lower_bound))\n\t\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\n\tpos = ind [0] - ao->bounds [0].lower_bound;\n\tfor (i = 1; i < ac->rank; i++)\n\t\tpos = pos*ao->bounds [i].length + ind [i] - \n\t\t\tao->bounds [i].lower_bound;\n\n\treturn ves_icall_System_Array_GetValueImpl (this, pos);\n}\n\nstatic void\nves_icall_System_Array_SetValueImpl (MonoArray *this, MonoObject *value, guint32 pos)\n{\n\tMonoClass *ac, *vc, *ec;\n\tgint32 esize, vsize;\n\tgpointer *ea, *va;\n\tint et, vt;\n\n\tguint64 u64 = 0;\n\tgint64 i64 = 0;\n\tgdouble r64 = 0;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (value)\n\t\tvc = value->vtable->klass;\n\telse\n\t\tvc = NULL;\n\n\tac = this->obj.vtable->klass;\n\tec = ac->element_class;\n\n\tesize = mono_array_element_size (ac);\n\tea = (gpointer*)((char*)this->vector + (pos * esize));\n\tva = (gpointer*)((char*)value + sizeof (MonoObject));\n\n\tif (mono_class_is_nullable (ec)) {\n\t\tmono_nullable_init ((guint8*)ea, value, ec);\n\t\treturn;\n\t}\n\n\tif (!value) {\n\t\tmemset (ea, 0,  esize);\n\t\treturn;\n\t}\n\n#define NO_WIDENING_CONVERSION G_STMT_START{\\\n\tmono_raise_exception (mono_get_exception_argument ( \\\n\t\t\"value\", \"not a widening conversion\")); \\\n}G_STMT_END\n\n#define CHECK_WIDENING_CONVERSION(extra) G_STMT_START{\\\n\tif (esize < vsize + (extra)) \\\n\t\tmono_raise_exception (mono_get_exception_argument ( \\\n\t\t\t\"value\", \"not a widening conversion\")); \\\n}G_STMT_END\n\n#define INVALID_CAST G_STMT_START{\\\n\tmono_raise_exception (mono_get_exception_invalid_cast ()); \\\n}G_STMT_END\n\n\t/* Check element (destination) type. */\n\tswitch (ec->byval_arg.type) {\n\tcase MONO_TYPE_STRING:\n\t\tswitch (vc->byval_arg.type) {\n\t\tcase MONO_TYPE_STRING:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tINVALID_CAST;\n\t\t}\n\t\tbreak;\n\tcase MONO_TYPE_BOOLEAN:\n\t\tswitch (vc->byval_arg.type) {\n\t\tcase MONO_TYPE_BOOLEAN:\n\t\t\tbreak;\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_U1:\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_I4:\n\t\tcase MONO_TYPE_I8:\n\t\tcase MONO_TYPE_R4:\n\t\tcase MONO_TYPE_R8:\n\t\t\tNO_WIDENING_CONVERSION;\n\t\tdefault:\n\t\t\tINVALID_CAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!ec->valuetype) {\n\t\tif (!mono_object_isinst (value, ec))\n\t\t\tINVALID_CAST;\n\t\tmono_gc_wbarrier_set_arrayref (this, ea, (MonoObject*)value);\n\t\treturn;\n\t}\n\n\tif (mono_object_isinst (value, ec)) {\n\t\tif (ec->has_references)\n\t\t\tmono_value_copy (ea, (char*)value + sizeof (MonoObject), ec);\n\t\telse\n\t\t\tmemcpy (ea, (char *)value + sizeof (MonoObject), esize);\n\t\treturn;\n\t}\n\n\tif (!vc->valuetype)\n\t\tINVALID_CAST;\n\n\tvsize = mono_class_instance_size (vc) - sizeof (MonoObject);\n\n\tet = ec->byval_arg.type;\n\tif (et == MONO_TYPE_VALUETYPE && ec->byval_arg.data.klass->enumtype)\n\t\tet = mono_class_enum_basetype (ec->byval_arg.data.klass)->type;\n\n\tvt = vc->byval_arg.type;\n\tif (vt == MONO_TYPE_VALUETYPE && vc->byval_arg.data.klass->enumtype)\n\t\tvt = mono_class_enum_basetype (vc->byval_arg.data.klass)->type;\n\n#define ASSIGN_UNSIGNED(etype) G_STMT_START{\\\n\tswitch (vt) { \\\n\tcase MONO_TYPE_U1: \\\n\tcase MONO_TYPE_U2: \\\n\tcase MONO_TYPE_U4: \\\n\tcase MONO_TYPE_U8: \\\n\tcase MONO_TYPE_CHAR: \\\n\t\tCHECK_WIDENING_CONVERSION(0); \\\n\t\t*(etype *) ea = (etype) u64; \\\n\t\treturn; \\\n\t/* You can't assign a signed value to an unsigned array. */ \\\n\tcase MONO_TYPE_I1: \\\n\tcase MONO_TYPE_I2: \\\n\tcase MONO_TYPE_I4: \\\n\tcase MONO_TYPE_I8: \\\n\t/* You can't assign a floating point number to an integer array. */ \\\n\tcase MONO_TYPE_R4: \\\n\tcase MONO_TYPE_R8: \\\n\t\tNO_WIDENING_CONVERSION; \\\n\t} \\\n}G_STMT_END\n\n#define ASSIGN_SIGNED(etype) G_STMT_START{\\\n\tswitch (vt) { \\\n\tcase MONO_TYPE_I1: \\\n\tcase MONO_TYPE_I2: \\\n\tcase MONO_TYPE_I4: \\\n\tcase MONO_TYPE_I8: \\\n\t\tCHECK_WIDENING_CONVERSION(0); \\\n\t\t*(etype *) ea = (etype) i64; \\\n\t\treturn; \\\n\t/* You can assign an unsigned value to a signed array if the array's */ \\\n\t/* element size is larger than the value size. */ \\\n\tcase MONO_TYPE_U1: \\\n\tcase MONO_TYPE_U2: \\\n\tcase MONO_TYPE_U4: \\\n\tcase MONO_TYPE_U8: \\\n\tcase MONO_TYPE_CHAR: \\\n\t\tCHECK_WIDENING_CONVERSION(1); \\\n\t\t*(etype *) ea = (etype) u64; \\\n\t\treturn; \\\n\t/* You can't assign a floating point number to an integer array. */ \\\n\tcase MONO_TYPE_R4: \\\n\tcase MONO_TYPE_R8: \\\n\t\tNO_WIDENING_CONVERSION; \\\n\t} \\\n}G_STMT_END\n\n#define ASSIGN_REAL(etype) G_STMT_START{\\\n\tswitch (vt) { \\\n\tcase MONO_TYPE_R4: \\\n\tcase MONO_TYPE_R8: \\\n\t\tCHECK_WIDENING_CONVERSION(0); \\\n\t\t*(etype *) ea = (etype) r64; \\\n\t\treturn; \\\n\t/* All integer values fit into a floating point array, so we don't */ \\\n\t/* need to CHECK_WIDENING_CONVERSION here. */ \\\n\tcase MONO_TYPE_I1: \\\n\tcase MONO_TYPE_I2: \\\n\tcase MONO_TYPE_I4: \\\n\tcase MONO_TYPE_I8: \\\n\t\t*(etype *) ea = (etype) i64; \\\n\t\treturn; \\\n\tcase MONO_TYPE_U1: \\\n\tcase MONO_TYPE_U2: \\\n\tcase MONO_TYPE_U4: \\\n\tcase MONO_TYPE_U8: \\\n\tcase MONO_TYPE_CHAR: \\\n\t\t*(etype *) ea = (etype) u64; \\\n\t\treturn; \\\n\t} \\\n}G_STMT_END\n\n\tswitch (vt) {\n\tcase MONO_TYPE_U1:\n\t\tu64 = *(guint8 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_U2:\n\t\tu64 = *(guint16 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_U4:\n\t\tu64 = *(guint32 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_U8:\n\t\tu64 = *(guint64 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_I1:\n\t\ti64 = *(gint8 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_I2:\n\t\ti64 = *(gint16 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_I4:\n\t\ti64 = *(gint32 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_I8:\n\t\ti64 = *(gint64 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_R4:\n\t\tr64 = *(gfloat *) va;\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n\t\tr64 = *(gdouble *) va;\n\t\tbreak;\n\tcase MONO_TYPE_CHAR:\n\t\tu64 = *(guint16 *) va;\n\t\tbreak;\n\tcase MONO_TYPE_BOOLEAN:\n\t\t/* Boolean is only compatible with itself. */\n\t\tswitch (et) {\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_U1:\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_I4:\n\t\tcase MONO_TYPE_I8:\n\t\tcase MONO_TYPE_R4:\n\t\tcase MONO_TYPE_R8:\n\t\t\tNO_WIDENING_CONVERSION;\n\t\tdefault:\n\t\t\tINVALID_CAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* If we can't do a direct copy, let's try a widening conversion. */\n\tswitch (et) {\n\tcase MONO_TYPE_CHAR:\n\t\tASSIGN_UNSIGNED (guint16);\n\tcase MONO_TYPE_U1:\n\t\tASSIGN_UNSIGNED (guint8);\n\tcase MONO_TYPE_U2:\n\t\tASSIGN_UNSIGNED (guint16);\n\tcase MONO_TYPE_U4:\n\t\tASSIGN_UNSIGNED (guint32);\n\tcase MONO_TYPE_U8:\n\t\tASSIGN_UNSIGNED (guint64);\n\tcase MONO_TYPE_I1:\n\t\tASSIGN_SIGNED (gint8);\n\tcase MONO_TYPE_I2:\n\t\tASSIGN_SIGNED (gint16);\n\tcase MONO_TYPE_I4:\n\t\tASSIGN_SIGNED (gint32);\n\tcase MONO_TYPE_I8:\n\t\tASSIGN_SIGNED (gint64);\n\tcase MONO_TYPE_R4:\n\t\tASSIGN_REAL (gfloat);\n\tcase MONO_TYPE_R8:\n\t\tASSIGN_REAL (gdouble);\n\t}\n\n\tINVALID_CAST;\n\t/* Not reached, INVALID_CAST does not return. Just to avoid a compiler warning ... */\n\treturn;\n\n#undef INVALID_CAST\n#undef NO_WIDENING_CONVERSION\n#undef CHECK_WIDENING_CONVERSION\n#undef ASSIGN_UNSIGNED\n#undef ASSIGN_SIGNED\n#undef ASSIGN_REAL\n}\n\nstatic void \nves_icall_System_Array_SetValue (MonoArray *this, MonoObject *value,\n\t\t\t\t MonoArray *idxs)\n{\n\tMonoClass *ac, *ic;\n\tgint32 i, pos, *ind;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (idxs);\n\n\tic = idxs->obj.vtable->klass;\n\tac = this->obj.vtable->klass;\n\n\tg_assert (ic->rank == 1);\n\tif (idxs->bounds != NULL || idxs->max_length != ac->rank)\n\t\tmono_raise_exception (mono_get_exception_argument (NULL, NULL));\n\n\tind = (gint32 *)idxs->vector;\n\n\tif (this->bounds == NULL) {\n\t\tif (*ind < 0 || *ind >= this->max_length)\n\t\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\n\t\tves_icall_System_Array_SetValueImpl (this, value, *ind);\n\t\treturn;\n\t}\n\t\n\tfor (i = 0; i < ac->rank; i++)\n\t\tif ((ind [i] < this->bounds [i].lower_bound) ||\n\t\t    (ind [i] >= (mono_array_lower_bound_t)this->bounds [i].length + this->bounds [i].lower_bound))\n\t\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\n\tpos = ind [0] - this->bounds [0].lower_bound;\n\tfor (i = 1; i < ac->rank; i++)\n\t\tpos = pos * this->bounds [i].length + ind [i] - \n\t\t\tthis->bounds [i].lower_bound;\n\n\tves_icall_System_Array_SetValueImpl (this, value, pos);\n}\n\nstatic MonoArray *\nves_icall_System_Array_CreateInstanceImpl (MonoReflectionType *type, MonoArray *lengths, MonoArray *bounds)\n{\n\tMonoClass *aklass;\n\tMonoArray *array;\n\tmono_array_size_t *sizes, i;\n\tgboolean bounded = FALSE;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (type);\n\tMONO_CHECK_ARG_NULL (lengths);\n\n\tMONO_CHECK_ARG (lengths, mono_array_length (lengths) > 0);\n\tif (bounds)\n\t\tMONO_CHECK_ARG (bounds, mono_array_length (lengths) == mono_array_length (bounds));\n\n\tfor (i = 0; i < mono_array_length (lengths); i++)\n\t\tif (mono_array_get (lengths, gint32, i) < 0)\n\t\t\tmono_raise_exception (mono_get_exception_argument_out_of_range (NULL));\n\n\tif (bounds && (mono_array_length (bounds) == 1) && (mono_array_get (bounds, gint32, 0) != 0))\n\t\t/* vectors are not the same as one dimensional arrays with no-zero bounds */\n\t\tbounded = TRUE;\n\telse\n\t\tbounded = FALSE;\n\n\taklass = mono_bounded_array_class_get (mono_class_from_mono_type (type->type), mono_array_length (lengths), bounded);\n\n\tsizes = alloca (aklass->rank * sizeof(mono_array_size_t) * 2);\n\tfor (i = 0; i < aklass->rank; ++i) {\n\t\tsizes [i] = mono_array_get (lengths, guint32, i);\n\t\tif (bounds)\n\t\t\tsizes [i + aklass->rank] = mono_array_get (bounds, guint32, i);\n\t\telse\n\t\t\tsizes [i + aklass->rank] = 0;\n\t}\n\n\tarray = mono_array_new_full (mono_object_domain (type), aklass, sizes, sizes + aklass->rank);\n\n\treturn array;\n}\n\nstatic MonoArray *\nves_icall_System_Array_CreateInstanceImpl64 (MonoReflectionType *type, MonoArray *lengths, MonoArray *bounds)\n{\n\tMonoClass *aklass;\n\tMonoArray *array;\n\tmono_array_size_t *sizes, i;\n\tgboolean bounded = FALSE;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (type);\n\tMONO_CHECK_ARG_NULL (lengths);\n\n\tMONO_CHECK_ARG (lengths, mono_array_length (lengths) > 0);\n\tif (bounds)\n\t\tMONO_CHECK_ARG (bounds, mono_array_length (lengths) == mono_array_length (bounds));\n\n\tfor (i = 0; i < mono_array_length (lengths); i++) \n\t\tif ((mono_array_get (lengths, gint64, i) < 0) ||\n\t\t    (mono_array_get (lengths, gint64, i) > MONO_ARRAY_MAX_INDEX))\n\t\t\tmono_raise_exception (mono_get_exception_argument_out_of_range (NULL));\n\n\tif (bounds && (mono_array_length (bounds) == 1) && (mono_array_get (bounds, gint64, 0) != 0))\n\t\t/* vectors are not the same as one dimensional arrays with no-zero bounds */\n\t\tbounded = TRUE;\n\telse\n\t\tbounded = FALSE;\n\n\taklass = mono_bounded_array_class_get (mono_class_from_mono_type (type->type), mono_array_length (lengths), bounded);\n\n\tsizes = alloca (aklass->rank * sizeof(mono_array_size_t) * 2);\n\tfor (i = 0; i < aklass->rank; ++i) {\n\t\tsizes [i] = mono_array_get (lengths, guint64, i);\n\t\tif (bounds)\n\t\t\tsizes [i + aklass->rank] = (mono_array_size_t) mono_array_get (bounds, guint64, i);\n\t\telse\n\t\t\tsizes [i + aklass->rank] = 0;\n\t}\n\n\tarray = mono_array_new_full (mono_object_domain (type), aklass, sizes, sizes + aklass->rank);\n\n\treturn array;\n}\n\nstatic gint32 \nves_icall_System_Array_GetRank (MonoObject *this)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn this->vtable->klass->rank;\n}\n\nstatic gint32\nves_icall_System_Array_GetLength (MonoArray *this, gint32 dimension)\n{\n\tgint32 rank = ((MonoObject *)this)->vtable->klass->rank;\n\tmono_array_size_t length;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif ((dimension < 0) || (dimension >= rank))\n\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\t\n\tif (this->bounds == NULL)\n\t\tlength = this->max_length;\n\telse\n\t\tlength = this->bounds [dimension].length;\n\n#ifdef MONO_BIG_ARRAYS\n\tif (length > G_MAXINT32)\n\t        mono_raise_exception (mono_get_exception_overflow ());\n#endif\n\treturn length;\n}\n\nstatic gint64\nves_icall_System_Array_GetLongLength (MonoArray *this, gint32 dimension)\n{\n\tgint32 rank = ((MonoObject *)this)->vtable->klass->rank;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif ((dimension < 0) || (dimension >= rank))\n\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\t\n\tif (this->bounds == NULL)\n \t\treturn this->max_length;\n \t\n \treturn this->bounds [dimension].length;\n}\n\nstatic gint32\nves_icall_System_Array_GetLowerBound (MonoArray *this, gint32 dimension)\n{\n\tgint32 rank = ((MonoObject *)this)->vtable->klass->rank;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif ((dimension < 0) || (dimension >= rank))\n\t\tmono_raise_exception (mono_get_exception_index_out_of_range ());\n\t\n\tif (this->bounds == NULL)\n\t\treturn 0;\n\t\n\treturn this->bounds [dimension].lower_bound;\n}\n\nstatic void\nves_icall_System_Array_ClearInternal (MonoArray *arr, int idx, int length)\n{\n\tint sz = mono_array_element_size (mono_object_class (arr));\n\tmemset (mono_array_addr_with_size (arr, sz, idx), 0, length * sz);\n}\n\nstatic gboolean\nves_icall_System_Array_FastCopy (MonoArray *source, int source_idx, MonoArray* dest, int dest_idx, int length)\n{\n\tint element_size;\n\tvoid * dest_addr;\n\tvoid * source_addr;\n\tMonoClass *src_class;\n\tMonoClass *dest_class;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (source->obj.vtable->klass->rank != dest->obj.vtable->klass->rank)\n\t\treturn FALSE;\n\n\tif (source->bounds || dest->bounds)\n\t\treturn FALSE;\n\n\t/* there's no integer overflow since mono_array_length returns an unsigned integer */\n\tif ((dest_idx + length > mono_array_length (dest)) ||\n\t\t(source_idx + length > mono_array_length (source)))\n\t\treturn FALSE;\n\n\tsrc_class = source->obj.vtable->klass->element_class;\n\tdest_class = dest->obj.vtable->klass->element_class;\n\n\t/*\n\t * Handle common cases.\n\t */\n\n\t/* Case1: object[] -> valuetype[] (ArrayList::ToArray) */\n\tif (src_class == mono_defaults.object_class && dest_class->valuetype) {\n\t\t// FIXME: This is racy\n\t\treturn FALSE;\n\t\t/*\n\t\t  int i;\n\t\tint has_refs = dest_class->has_references;\n\t\tfor (i = source_idx; i < source_idx + length; ++i) {\n\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, i);\n\t\t\tif (elem && !mono_object_isinst (elem, dest_class))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\telement_size = mono_array_element_size (dest->obj.vtable->klass);\n\t\tmemset (mono_array_addr_with_size (dest, element_size, dest_idx), 0, element_size * length);\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, source_idx + i);\n\t\t\tvoid *addr = mono_array_addr_with_size (dest, element_size, dest_idx + i);\n\t\t\tif (!elem)\n\t\t\t\tcontinue;\n\t\t\tif (has_refs)\n\t\t\t\tmono_value_copy (addr, (char *)elem + sizeof (MonoObject), dest_class);\n\t\t\telse\n\t\t\t\tmemcpy (addr, (char *)elem + sizeof (MonoObject), element_size);\n\t\t}\n\t\treturn TRUE;\n\t\t*/\n\t}\n\n\t/* Check if we're copying a char[] <==> (u)short[] */\n\tif (src_class != dest_class) {\n\t\tif (dest_class->valuetype || dest_class->enumtype || src_class->valuetype || src_class->enumtype)\n\t\t\treturn FALSE;\n\n\t\tif (mono_class_is_subclass_of (src_class, dest_class, FALSE))\n\t\t\t;\n\t\t/* Case2: object[] -> reftype[] (ArrayList::ToArray) */\n\t\telse if (mono_class_is_subclass_of (dest_class, src_class, FALSE)) {\n\t\t\t// FIXME: This is racy\n\t\t\treturn FALSE;\n\t\t\t/*\n\t\t\t  int i;\n\t\t\tfor (i = source_idx; i < source_idx + length; ++i) {\n\t\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, i);\n\t\t\t\tif (elem && !mono_object_isinst (elem, dest_class))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t*/\n\t\t} else\n\t\t\treturn FALSE;\n\t}\n\n\tif (dest_class->valuetype) {\n\t\telement_size = mono_array_element_size (source->obj.vtable->klass);\n\t\tsource_addr = mono_array_addr_with_size (source, element_size, source_idx);\n\t\tif (dest_class->has_references) {\n\t\t\tmono_value_copy_array (dest, dest_idx, source_addr, length);\n\t\t} else {\n\t\t\tdest_addr = mono_array_addr_with_size (dest, element_size, dest_idx);\n\t\t\tmemmove (dest_addr, source_addr, element_size * length);\n\t\t}\n\t} else {\n\t\tmono_array_memcpy_refs (dest, dest_idx, source, source_idx, length);\n\t}\n\n\treturn TRUE;\n}\n\nstatic void\nves_icall_System_Array_GetGenericValueImpl (MonoObject *this, guint32 pos, gpointer value)\n{\n\tMonoClass *ac;\n\tMonoArray *ao;\n\tgint32 esize;\n\tgpointer *ea;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tao = (MonoArray *)this;\n\tac = (MonoClass *)ao->obj.vtable->klass;\n\n\tesize = mono_array_element_size (ac);\n\tea = (gpointer*)((char*)ao->vector + (pos * esize));\n\n\tmemcpy (value, ea, esize);\n}\n\nstatic void\nves_icall_System_Array_SetGenericValueImpl (MonoObject *this, guint32 pos, gpointer value)\n{\n\tMonoClass *ac, *ec;\n\tMonoArray *ao;\n\tgint32 esize;\n\tgpointer *ea;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tao = (MonoArray *)this;\n\tac = (MonoClass *)ao->obj.vtable->klass;\n\tec = ac->element_class;\n\n\tesize = mono_array_element_size (ac);\n\tea = (gpointer*)((char*)ao->vector + (pos * esize));\n\n\tif (MONO_TYPE_IS_REFERENCE (&ec->byval_arg)) {\n\t\tg_assert (esize == sizeof (gpointer));\n\t\tmono_gc_wbarrier_generic_store (ea, *(gpointer*)value);\n\t} else {\n\t\tg_assert (ec->inited);\n\t\tif (ec->has_references)\n\t\t\tmono_gc_wbarrier_value_copy (ea, value, 1, ec);\n\t\tmemcpy (ea, value, esize);\n\t}\n}\n\nstatic void\nves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray (MonoArray *array, MonoClassField *field_handle)\n{\n\tMonoClass *klass = array->obj.vtable->klass;\n\tguint32 size = mono_array_element_size (klass);\n\tMonoType *type = mono_type_get_underlying_type (&klass->element_class->byval_arg);\n\tint align;\n\tconst char *field_data;\n\n\tif (MONO_TYPE_IS_REFERENCE (type) || type->type == MONO_TYPE_VALUETYPE) {\n\t\tMonoException *exc = mono_get_exception_argument(\"array\",\n\t\t\t\"Cannot initialize array of non-primitive type.\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tif (!(field_handle->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA)) {\n\t\tMonoException *exc = mono_get_exception_argument(\"field_handle\",\n\t\t\t\"Field doesn't have an RVA\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tsize *= array->max_length;\n\tfield_data = mono_field_get_data (field_handle);\n\n\tif (size > mono_type_size (field_handle->type, &align)) {\n\t\tMonoException *exc = mono_get_exception_argument(\"field_handle\",\n\t\t\t\"Field not large enough to fill array\");\n\t\tmono_raise_exception (exc);\n\t}\n\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n#define SWAP(n) {\\\n\tguint ## n *data = (guint ## n *) mono_array_addr (array, char, 0); \\\n\tguint ## n *src = (guint ## n *) field_data; \\\n\tguint ## n *end = (guint ## n *)((char*)src + size); \\\n\\\n\tfor (; src < end; data++, src++) { \\\n\t\t*data = read ## n (src); \\\n\t} \\\n}\n\n\t/* printf (\"Initialize array with elements of %s type\\n\", klass->element_class->name); */\n\n\tswitch (type->type) {\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\t\tSWAP (16);\n\t\tbreak;\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_R4:\n\t\tSWAP (32);\n\t\tbreak;\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R8:\n\t\tSWAP (64);\n\t\tbreak;\n\tdefault:\n\t\tmemcpy (mono_array_addr (array, char, 0), field_data, size);\n\t\tbreak;\n\t}\n#else\n\tmemcpy (mono_array_addr (array, char, 0), field_data, size);\n#ifdef ARM_FPU_FPA\n\tif (klass->element_class->byval_arg.type == MONO_TYPE_R8) {\n\t\tgint i;\n\t\tdouble tmp;\n\t\tdouble *data = (double*)mono_array_addr (array, double, 0);\n\n\t\tfor (i = 0; i < size; i++, data++) {\n\t\t\treadr8 (data, &tmp);\n\t\t\t*data = tmp;\n\t\t}\n\t}\n#endif\n#endif\n}\n\nstatic gint\nves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetOffsetToStringData (void)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn offsetof (MonoString, chars);\n}\n\nstatic MonoObject *\nves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetObjectValue (MonoObject *obj)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif ((obj == NULL) || (! (obj->vtable->klass->valuetype)))\n\t\treturn obj;\n\telse\n\t\treturn mono_object_clone (obj);\n}\n\nstatic void\nves_icall_System_Runtime_CompilerServices_RuntimeHelpers_RunClassConstructor (MonoType *handle)\n{\n\tMonoClass *klass;\n\tMonoVTable *vtable;\n\n\tMONO_CHECK_ARG_NULL (handle);\n\n\tklass = mono_class_from_mono_type (handle);\n\tMONO_CHECK_ARG (handle, klass);\n\n\tvtable = mono_class_vtable_full (mono_domain_get (), klass, TRUE);\n\n\t/* This will call the type constructor */\n\tmono_runtime_class_init (vtable);\n}\n\nstatic void\nves_icall_System_Runtime_CompilerServices_RuntimeHelpers_RunModuleConstructor (MonoImage *image)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_image_check_for_module_cctor (image);\n\tif (image->has_module_cctor) {\n\t\tMonoClass *module_klass = mono_class_get (image, MONO_TOKEN_TYPE_DEF | 1);\n\t\t/*It's fine to raise the exception here*/\n\t\tmono_runtime_class_init (mono_class_vtable_full (mono_domain_get (), module_klass, TRUE));\n\t}\n}\n\nstatic MonoObject *\nves_icall_System_Object_MemberwiseClone (MonoObject *this)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_object_clone (this);\n}\n\nstatic gint32\nves_icall_System_ValueType_InternalGetHashCode (MonoObject *this, MonoArray **fields)\n{\n\tMonoClass *klass;\n\tMonoObject **values = NULL;\n\tMonoObject *o;\n\tint count = 0;\n\tgint32 result = 0;\n\tMonoClassField* field;\n\tgpointer iter;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_object_class (this);\n\n\tif (mono_class_num_fields (klass) == 0)\n\t\treturn mono_object_hash (this);\n\n\t/*\n\t * Compute the starting value of the hashcode for fields of primitive\n\t * types, and return the remaining fields in an array to the managed side.\n\t * This way, we can avoid costly reflection operations in managed code.\n\t */\n\titer = NULL;\n\twhile ((field = mono_class_get_fields (klass, &iter))) {\n\t\tif (field->type->attrs & FIELD_ATTRIBUTE_STATIC)\n\t\t\tcontinue;\n\t\tif (mono_field_is_deleted (field))\n\t\t\tcontinue;\n\t\t/* FIXME: Add more types */\n\t\tswitch (field->type->type) {\n\t\tcase MONO_TYPE_I4:\n\t\t\tresult ^= *(gint32*)((guint8*)this + field->offset);\n\t\t\tbreak;\n\t\tcase MONO_TYPE_STRING: {\n\t\t\tMonoString *s;\n\t\t\ts = *(MonoString**)((guint8*)this + field->offset);\n\t\t\tif (s != NULL)\n\t\t\t\tresult ^= mono_string_hash (s);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tif (!values)\n\t\t\t\tvalues = g_newa (MonoObject*, mono_class_num_fields (klass));\n\t\t\to = mono_field_get_value_object (mono_object_domain (this), field, this);\n\t\t\tvalues [count++] = o;\n\t\t}\n\t}\n\n\tif (values) {\n\t\tint i;\n\t\tmono_gc_wbarrier_generic_store (fields, (MonoObject*) mono_array_new (mono_domain_get (), mono_defaults.object_class, count));\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tmono_array_setref (*fields, i, values [i]);\n\t} else {\n\t\t*fields = NULL;\n\t}\n\treturn result;\n}\n\nstatic MonoBoolean\nves_icall_System_ValueType_Equals (MonoObject *this, MonoObject *that, MonoArray **fields)\n{\n\tMonoClass *klass;\n\tMonoObject **values = NULL;\n\tMonoObject *o;\n\tMonoClassField* field;\n\tgpointer iter;\n\tint count = 0;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (that);\n\n\tif (this->vtable != that->vtable)\n\t\treturn FALSE;\n\n\tklass = mono_object_class (this);\n\n\tif (klass->enumtype && mono_class_enum_basetype (klass) && mono_class_enum_basetype (klass)->type == MONO_TYPE_I4)\n\t\treturn (*(gint32*)((guint8*)this + sizeof (MonoObject)) == *(gint32*)((guint8*)that + sizeof (MonoObject)));\n\n\t/*\n\t * Do the comparison for fields of primitive type and return a result if\n\t * possible. Otherwise, return the remaining fields in an array to the \n\t * managed side. This way, we can avoid costly reflection operations in \n\t * managed code.\n\t */\n\t*fields = NULL;\n\titer = NULL;\n\twhile ((field = mono_class_get_fields (klass, &iter))) {\n\t\tif (field->type->attrs & FIELD_ATTRIBUTE_STATIC)\n\t\t\tcontinue;\n\t\tif (mono_field_is_deleted (field))\n\t\t\tcontinue;\n\t\t/* FIXME: Add more types */\n\t\tswitch (field->type->type) {\n\t\tcase MONO_TYPE_U1:\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_BOOLEAN:\n\t\t\tif (*((guint8*)this + field->offset) != *((guint8*)that + field->offset))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_CHAR:\n\t\t\tif (*(gint16*)((guint8*)this + field->offset) != *(gint16*)((guint8*)that + field->offset))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_I4:\n\t\t\tif (*(gint32*)((guint8*)this + field->offset) != *(gint32*)((guint8*)that + field->offset))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I8:\n\t\t\tif (*(gint64*)((guint8*)this + field->offset) != *(gint64*)((guint8*)that + field->offset))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\tcase MONO_TYPE_R4:\n\t\t\tif (*(float*)((guint8*)this + field->offset) != *(float*)((guint8*)that + field->offset))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\tcase MONO_TYPE_R8:\n\t\t\tif (*(double*)((guint8*)this + field->offset) != *(double*)((guint8*)that + field->offset))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\n\n\t\tcase MONO_TYPE_STRING: {\n\t\t\tMonoString *s1, *s2;\n\t\t\tguint32 s1len, s2len;\n\t\t\ts1 = *(MonoString**)((guint8*)this + field->offset);\n\t\t\ts2 = *(MonoString**)((guint8*)that + field->offset);\n\t\t\tif (s1 == s2)\n\t\t\t\tbreak;\n\t\t\tif ((s1 == NULL) || (s2 == NULL))\n\t\t\t\treturn FALSE;\n\t\t\ts1len = mono_string_length (s1);\n\t\t\ts2len = mono_string_length (s2);\n\t\t\tif (s1len != s2len)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (memcmp (mono_string_chars (s1), mono_string_chars (s2), s1len * sizeof (gunichar2)) != 0)\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tif (!values)\n\t\t\t\tvalues = g_newa (MonoObject*, mono_class_num_fields (klass) * 2);\n\t\t\to = mono_field_get_value_object (mono_object_domain (this), field, this);\n\t\t\tvalues [count++] = o;\n\t\t\to = mono_field_get_value_object (mono_object_domain (this), field, that);\n\t\t\tvalues [count++] = o;\n\t\t}\n\n\t\tif (klass->enumtype)\n\t\t\t/* enums only have one non-static field */\n\t\t\tbreak;\n\t}\n\n\tif (values) {\n\t\tint i;\n\t\tmono_gc_wbarrier_generic_store (fields, (MonoObject*) mono_array_new (mono_domain_get (), mono_defaults.object_class, count));\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tmono_array_setref (*fields, i, values [i]);\n\t\treturn FALSE;\n\t} else {\n\t\treturn TRUE;\n\t}\n}\n\nstatic MonoReflectionType *\nves_icall_System_Object_GetType (MonoObject *obj)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (obj->vtable->klass != mono_defaults.transparent_proxy_class)\n\t\treturn mono_type_get_object (mono_object_domain (obj), &obj->vtable->klass->byval_arg);\n\telse\n\t\treturn mono_type_get_object (mono_object_domain (obj), &((MonoTransparentProxy*)obj)->remote_class->proxy_class->byval_arg);\n}\n\nstatic void\nmono_type_type_from_obj (MonoReflectionType *mtype, MonoObject *obj)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmtype->type = &obj->vtable->klass->byval_arg;\n\tg_assert (mtype->type->type);\n}\n\nstatic gint32\nves_icall_ModuleBuilder_getToken (MonoReflectionModuleBuilder *mb, MonoObject *obj)\n{\n\tMONO_ARCH_SAVE_REGS;\n\t\n\tMONO_CHECK_ARG_NULL (obj);\n\t\n\treturn mono_image_create_token (mb->dynamic_image, obj, TRUE, TRUE);\n}\n\nstatic gint32\nves_icall_ModuleBuilder_getMethodToken (MonoReflectionModuleBuilder *mb,\n\t\t\t\t\tMonoReflectionMethod *method,\n\t\t\t\t\tMonoArray *opt_param_types)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (method);\n\t\n\treturn mono_image_create_method_token (\n\t\tmb->dynamic_image, (MonoObject *) method, opt_param_types);\n}\n\nstatic void\nves_icall_ModuleBuilder_WriteToFile (MonoReflectionModuleBuilder *mb, HANDLE file)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_image_create_pefile (mb, file);\n}\n\nstatic void\nves_icall_ModuleBuilder_build_metadata (MonoReflectionModuleBuilder *mb)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_image_build_metadata (mb);\n}\n\nstatic void\nves_icall_ModuleBuilder_RegisterToken (MonoReflectionModuleBuilder *mb, MonoObject *obj, guint32 token)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_image_register_token (mb->dynamic_image, token, obj);\n}\n\nstatic gboolean\nget_caller (MonoMethod *m, gint32 no, gint32 ilo, gboolean managed, gpointer data)\n{\n\tMonoMethod **dest = data;\n\n\t/* skip unmanaged frames */\n\tif (!managed)\n\t\treturn FALSE;\n\n\tif (m == *dest) {\n\t\t*dest = NULL;\n\t\treturn FALSE;\n\t}\n\tif (!(*dest)) {\n\t\t*dest = m;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean\nget_executing (MonoMethod *m, gint32 no, gint32 ilo, gboolean managed, gpointer data)\n{\n\tMonoMethod **dest = data;\n\n\t/* skip unmanaged frames */\n\tif (!managed)\n\t\treturn FALSE;\n\n\tif (!(*dest)) {\n\t\tif (!strcmp (m->klass->name_space, \"System.Reflection\"))\n\t\t\treturn FALSE;\n\t\t*dest = m;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean\nget_caller_no_reflection (MonoMethod *m, gint32 no, gint32 ilo, gboolean managed, gpointer data)\n{\n\tMonoMethod **dest = data;\n\n\t/* skip unmanaged frames */\n\tif (!managed)\n\t\treturn FALSE;\n\n\tif (m->wrapper_type != MONO_WRAPPER_NONE)\n\t\treturn FALSE;\n\n\tif (m->klass->image == mono_defaults.corlib && !strcmp (m->klass->name_space, \"System.Reflection\"))\n\t\treturn FALSE;\n\n\tif (m == *dest) {\n\t\t*dest = NULL;\n\t\treturn FALSE;\n\t}\n\tif (!(*dest)) {\n\t\t*dest = m;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic MonoReflectionType *\ntype_from_name (const char *str, MonoBoolean ignoreCase)\n{\n\tMonoType *type = NULL;\n\tMonoAssembly *assembly = NULL;\n\tMonoTypeNameParse info;\n\tchar *temp_str = g_strdup (str);\n\tgboolean type_resolve = FALSE;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t/* mono_reflection_parse_type() mangles the string */\n\tif (!mono_reflection_parse_type (temp_str, &info)) {\n\t\tmono_reflection_free_type_info (&info);\n\t\tg_free (temp_str);\n\t\treturn NULL;\n\t}\n\n\tif (info.assembly.name) {\n\t\tassembly = mono_assembly_load (&info.assembly, NULL, NULL);\n\t} else {\n\t\tMonoMethod *m = mono_method_get_last_managed ();\n\t\tMonoMethod *dest = m;\n\n\t\tmono_stack_walk_no_il (get_caller_no_reflection, &dest);\n\t\tif (!dest)\n\t\t\tdest = m;\n\n\t\t/*\n\t\t * FIXME: mono_method_get_last_managed() sometimes returns NULL, thus\n\t\t *        causing ves_icall_System_Reflection_Assembly_GetCallingAssembly()\n\t\t *        to crash.  This only seems to happen in some strange remoting\n\t\t *        scenarios and I was unable to figure out what's happening there.\n\t\t *        Dec 10, 2005 - Martin.\n\t\t */\n\n\t\tif (dest) {\n\t\t\tassembly = dest->klass->image->assembly;\n\t\t\ttype_resolve = TRUE;\n\t\t} else {\n\t\t\tg_warning (G_STRLOC);\n\t\t}\n\t}\n\n\tif (assembly) {\n\t\t/* When loading from the current assembly, AppDomain.TypeResolve will not be called yet */\n\t\ttype = mono_reflection_get_type (assembly->image, &info, ignoreCase, &type_resolve);\n\t}\n\n\tif (!info.assembly.name && !type) /* try mscorlib */\n\t\ttype = mono_reflection_get_type (NULL, &info, ignoreCase, &type_resolve);\n\n\tif (assembly && !type && type_resolve) {\n\t\ttype_resolve = FALSE; /* This will invoke TypeResolve if not done in the first 'if' */\n\t\ttype = mono_reflection_get_type (assembly->image, &info, ignoreCase, &type_resolve);\n\t}\n\n\tmono_reflection_free_type_info (&info);\n\tg_free (temp_str);\n\n\tif (!type) \n\t\treturn NULL;\n\n\treturn mono_type_get_object (mono_domain_get (), type);\n}\n\n#ifdef UNUSED\nMonoReflectionType *\nmono_type_get (const char *str)\n{\n\tchar *copy = g_strdup (str);\n\tMonoReflectionType *type = type_from_name (copy, FALSE);\n\n\tg_free (copy);\n\treturn type;\n}\n#endif\n\nstatic MonoReflectionType*\nves_icall_type_from_name (MonoString *name,\n\t\t\t  MonoBoolean throwOnError,\n\t\t\t  MonoBoolean ignoreCase)\n{\n\tchar *str = mono_string_to_utf8 (name);\n\tMonoReflectionType *type;\n\n\ttype = type_from_name (str, ignoreCase);\n\tg_free (str);\n\tif (type == NULL){\n\t\tMonoException *e = NULL;\n\t\t\n\t\tif (throwOnError)\n\t\t\te = mono_get_exception_type_load (name, NULL);\n\n\t\tmono_loader_clear_error ();\n\t\tif (e != NULL)\n\t\t\tmono_raise_exception (e);\n\t}\n\t\n\treturn type;\n}\n\n\nstatic MonoReflectionType*\nves_icall_type_from_handle (MonoType *handle)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\tMonoClass *klass = mono_class_from_mono_type (handle);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_class_init (klass);\n\treturn mono_type_get_object (domain, handle);\n}\n\nstatic MonoBoolean\nves_icall_System_Type_EqualsInternal (MonoReflectionType *type, MonoReflectionType *c)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (c && type->type && c->type)\n\t\treturn mono_metadata_type_equal (type->type, c->type);\n\telse\n\t\treturn (type == c) ? TRUE : FALSE;\n}\n\n/* System.TypeCode */\ntypedef enum {\n\tTYPECODE_EMPTY,\n\tTYPECODE_OBJECT,\n\tTYPECODE_DBNULL,\n\tTYPECODE_BOOLEAN,\n\tTYPECODE_CHAR,\n\tTYPECODE_SBYTE,\n\tTYPECODE_BYTE,\n\tTYPECODE_INT16,\n\tTYPECODE_UINT16,\n\tTYPECODE_INT32,\n\tTYPECODE_UINT32,\n\tTYPECODE_INT64,\n\tTYPECODE_UINT64,\n\tTYPECODE_SINGLE,\n\tTYPECODE_DOUBLE,\n\tTYPECODE_DECIMAL,\n\tTYPECODE_DATETIME,\n\tTYPECODE_STRING = 18\n} TypeCode;\n\nstatic guint32\nves_icall_type_GetTypeCodeInternal (MonoReflectionType *type)\n{\n\tint t = type->type->type;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->type->byref)\n\t\treturn TYPECODE_OBJECT;\n\nhandle_enum:\n\tswitch (t) {\n\tcase MONO_TYPE_VOID:\n\t\treturn TYPECODE_OBJECT;\n\tcase MONO_TYPE_BOOLEAN:\n\t\treturn TYPECODE_BOOLEAN;\n\tcase MONO_TYPE_U1:\n\t\treturn TYPECODE_BYTE;\n\tcase MONO_TYPE_I1:\n\t\treturn TYPECODE_SBYTE;\n\tcase MONO_TYPE_U2:\n\t\treturn TYPECODE_UINT16;\n\tcase MONO_TYPE_I2:\n\t\treturn TYPECODE_INT16;\n\tcase MONO_TYPE_CHAR:\n\t\treturn TYPECODE_CHAR;\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n\t\treturn TYPECODE_OBJECT;\n\tcase MONO_TYPE_U4:\n\t\treturn TYPECODE_UINT32;\n\tcase MONO_TYPE_I4:\n\t\treturn TYPECODE_INT32;\n\tcase MONO_TYPE_U8:\n\t\treturn TYPECODE_UINT64;\n\tcase MONO_TYPE_I8:\n\t\treturn TYPECODE_INT64;\n\tcase MONO_TYPE_R4:\n\t\treturn TYPECODE_SINGLE;\n\tcase MONO_TYPE_R8:\n\t\treturn TYPECODE_DOUBLE;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (type->type->data.klass->enumtype) {\n\t\t\tt = mono_class_enum_basetype (type->type->data.klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tMonoClass *k =  type->type->data.klass;\n\t\t\tif (strcmp (k->name_space, \"System\") == 0) {\n\t\t\t\tif (strcmp (k->name, \"Decimal\") == 0)\n\t\t\t\t\treturn TYPECODE_DECIMAL;\n\t\t\t\telse if (strcmp (k->name, \"DateTime\") == 0)\n\t\t\t\t\treturn TYPECODE_DATETIME;\n\t\t\t}\n\t\t}\n\t\treturn TYPECODE_OBJECT;\n\tcase MONO_TYPE_STRING:\n\t\treturn TYPECODE_STRING;\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn TYPECODE_OBJECT;\n\tcase MONO_TYPE_CLASS:\n\t\t{\n\t\t\tMonoClass *k =  type->type->data.klass;\n\t\t\tif (strcmp (k->name_space, \"System\") == 0) {\n\t\t\t\tif (strcmp (k->name, \"DBNull\") == 0)\n\t\t\t\t\treturn TYPECODE_DBNULL;\n\t\t\t}\n\t\t}\n\t\treturn TYPECODE_OBJECT;\n\tcase MONO_TYPE_GENERICINST:\n\t\treturn TYPECODE_OBJECT;\n\tdefault:\n\t\tg_error (\"type 0x%02x not handled in GetTypeCode()\", t);\n\t}\n\treturn 0;\n}\n\nstatic guint32\nves_icall_type_is_subtype_of (MonoReflectionType *type, MonoReflectionType *c, MonoBoolean check_interfaces)\n{\n\tMonoDomain *domain; \n\tMonoClass *klass;\n\tMonoClass *klassc;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_assert (type != NULL);\n\t\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\n\tif (!c) /* FIXME: dont know what do do here */\n\t\treturn 0;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tklassc = mono_class_from_mono_type (c->type);\n\n\tif (type->type->byref)\n\t\treturn klassc == mono_defaults.object_class;\n\n\treturn mono_class_is_subclass_of (klass, klassc, check_interfaces);\n}\n\nstatic guint32\nves_icall_type_is_assignable_from (MonoReflectionType *type, MonoReflectionType *c)\n{\n\tMonoDomain *domain; \n\tMonoClass *klass;\n\tMonoClass *klassc;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_assert (type != NULL);\n\t\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tklassc = mono_class_from_mono_type (c->type);\n\n\tif (type->type->byref && !c->type->byref)\n\t\treturn FALSE;\n\n\treturn mono_class_is_assignable_from (klass, klassc);\n}\n\nstatic guint32\nves_icall_type_IsInstanceOfType (MonoReflectionType *type, MonoObject *obj)\n{\n\tMonoClass *klass = mono_class_from_mono_type (type->type);\n\treturn mono_object_isinst (obj, klass) != NULL;\n}\n\nstatic guint32\nves_icall_get_attributes (MonoReflectionType *type)\n{\n\tMonoClass *klass = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn klass->flags;\n}\n\nstatic MonoReflectionMarshal*\nves_icall_System_Reflection_FieldInfo_GetUnmanagedMarshal (MonoReflectionField *field)\n{\n\tMonoClass *klass = field->field->parent;\n\tMonoMarshalType *info;\n\tint i;\n\n\tif (klass->generic_container ||\n\t    (klass->generic_class && klass->generic_class->context.class_inst->is_open))\n\t\treturn NULL;\n\n\tinfo = mono_marshal_load_type_info (klass);\n\n\tfor (i = 0; i < info->num_fields; ++i) {\n\t\tif (info->fields [i].field == field->field) {\n\t\t\tif (!info->fields [i].mspec)\n\t\t\t\treturn NULL;\n\t\t\telse\n\t\t\t\treturn mono_reflection_marshal_from_marshal_spec (field->object.vtable->domain, klass, info->fields [i].mspec);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic MonoReflectionField*\nves_icall_System_Reflection_FieldInfo_internal_from_handle_type (MonoClassField *handle, MonoType *type)\n{\n\tgboolean found = FALSE;\n\tMonoClass *klass;\n\tMonoClass *k;\n\n\tg_assert (handle);\n\n\tif (!type) {\n\t\tklass = handle->parent;\n\t} else {\n\t\tklass = mono_class_from_mono_type (type);\n\n\t\t/* Check that the field belongs to the class */\n\t\tfor (k = klass; k; k = k->parent) {\n\t\t\tif (k == handle->parent) {\n\t\t\t\tfound = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\t/* The managed code will throw the exception */\n\t\t\treturn NULL;\n\t}\n\n\treturn mono_field_get_object (mono_domain_get (), klass, handle);\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_FieldInfo_GetTypeModifiers (MonoReflectionField *field, MonoBoolean optional)\n{\n\tMonoType *type = field->field->type;\n\n\treturn type_array_from_modifiers (field->field->parent->image, type, optional);\n}\n\nstatic void\nves_icall_get_method_info (MonoMethod *method, MonoMethodInfo *info)\n{\n\tMonoDomain *domain = mono_domain_get ();\n\tMonoMethodSignature* sig;\n\tMONO_ARCH_SAVE_REGS;\n\n\tsig = mono_method_signature (method);\n\tif (!sig) {\n\t\tg_assert (mono_loader_get_last_error ());\n\t\tmono_raise_exception (mono_loader_error_prepare_exception (mono_loader_get_last_error ()));\n\t}\n\n\tMONO_STRUCT_SETREF (info, parent, mono_type_get_object (domain, &method->klass->byval_arg));\n\tMONO_STRUCT_SETREF (info, ret, mono_type_get_object (domain, sig->ret));\n\tinfo->attrs = method->flags;\n\tinfo->implattrs = method->iflags;\n\tif (sig->call_convention == MONO_CALL_DEFAULT)\n\t\tinfo->callconv = sig->sentinelpos >= 0 ? 2 : 1;\n\telse {\n\t\tif (sig->call_convention == MONO_CALL_VARARG || sig->sentinelpos >= 0)\n\t\t\tinfo->callconv = 2;\n\t\telse\n\t\t\tinfo->callconv = 1;\n\t}\n\tinfo->callconv |= (sig->hasthis << 5) | (sig->explicit_this << 6); \n}\n\nstatic MonoArray*\nves_icall_get_parameter_info (MonoMethod *method, MonoReflectionMethod *member)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\n\treturn mono_param_get_objects_internal (domain, method, member->reftype ? mono_class_from_mono_type (member->reftype->type) : NULL);\n}\n\nstatic MonoReflectionMarshal*\nves_icall_System_MonoMethodInfo_get_retval_marshal (MonoMethod *method)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\tMonoReflectionMarshal* res = NULL;\n\tMonoMarshalSpec **mspecs;\n\tint i;\n\n\tmspecs = g_new (MonoMarshalSpec*, mono_method_signature (method)->param_count + 1);\n\tmono_method_get_marshal_info (method, mspecs);\n\n\tif (mspecs [0])\n\t\tres = mono_reflection_marshal_from_marshal_spec (domain, method->klass, mspecs [0]);\n\t\t\n\tfor (i = mono_method_signature (method)->param_count; i >= 0; i--)\n\t\tif (mspecs [i])\n\t\t\tmono_metadata_free_marshal_spec (mspecs [i]);\n\tg_free (mspecs);\n\n\treturn res;\n}\n\nstatic gint32\nves_icall_MonoField_GetFieldOffset (MonoReflectionField *field)\n{\n\treturn field->field->offset - sizeof (MonoObject);\n}\n\nstatic MonoReflectionType*\nves_icall_MonoField_GetParentType (MonoReflectionField *field, MonoBoolean declaring)\n{\n\tMonoClass *parent;\n\tMONO_ARCH_SAVE_REGS;\n\n\tparent = declaring? field->field->parent: field->klass;\n\n\treturn mono_type_get_object (mono_object_domain (field), &parent->byval_arg);\n}\n\nstatic MonoObject *\nves_icall_MonoField_GetValueInternal (MonoReflectionField *field, MonoObject *obj)\n{\t\n\tMonoObject *o;\n\tMonoClassField *cf = field->field;\n\tMonoClass *klass;\n\tMonoVTable *vtable;\n\tMonoType *t;\n\tMonoDomain *domain = mono_object_domain (field); \n\tgchar *v;\n\tgboolean is_static = FALSE;\n\tgboolean is_ref = FALSE;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (field->klass->image->assembly->ref_only)\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\n\t\t\t\t\t\"It is illegal to get the value on a field on a type loaded using the ReflectionOnly methods.\"));\n\t\n\tif (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\tmono_security_core_clr_ensure_reflection_access_field (cf);\n\n\tmono_class_init (field->klass);\n\n\tif (cf->type->attrs & FIELD_ATTRIBUTE_STATIC)\n\t\tis_static = TRUE;\n\n\tif (obj && !is_static) {\n\t\t/* Check that the field belongs to the object */\n\t\tgboolean found = FALSE;\n\t\tMonoClass *k;\n\n\t\tfor (k = obj->vtable->klass; k; k = k->parent) {\n\t\t\tif (k == cf->parent) {\n\t\t\t\tfound = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tchar *msg = g_strdup_printf (\"Field '%s' defined on type '%s' is not a field on the target object which is of type '%s'.\", mono_field_get_name (cf), cf->parent->name, obj->vtable->klass->name);\n\t\t\tMonoException *ex = mono_get_exception_argument (NULL, msg);\n\t\t\tg_free (msg);\n\t\t\tmono_raise_exception (ex);\n\t\t}\n\t}\n\n\tt = mono_type_get_underlying_type (cf->type);\n\tswitch (t->type) {\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_ARRAY:\n\tcase MONO_TYPE_SZARRAY:\n\t\tis_ref = TRUE;\n\t\tbreak;\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_VALUETYPE:\n\t\tis_ref = t->byref;\n\t\tbreak;\n\tcase MONO_TYPE_GENERICINST:\n\t\tif (mono_type_generic_inst_is_valuetype (t)) {\n\t\t\tis_ref = t->byref;\n\t\t} else {\n\t\t\tis_ref = TRUE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tg_error (\"type 0x%x not handled in \"\n\t\t\t \"ves_icall_Monofield_GetValue\", t->type);\n\t\treturn NULL;\n\t}\n\n\tvtable = NULL;\n\tif (is_static) {\n\t\tvtable = mono_class_vtable_full (domain, cf->parent, TRUE);\n\t\tif (!vtable->initialized && !(cf->type->attrs & FIELD_ATTRIBUTE_LITERAL))\n\t\t\tmono_runtime_class_init (vtable);\n\t}\n\t\n\tif (is_ref) {\n\t\tif (is_static) {\n\t\t\tmono_field_static_get_value (vtable, cf, &o);\n\t\t} else {\n\t\t\tmono_field_get_value (obj, cf, &o);\n\t\t}\n\t\treturn o;\n\t}\n\n\tif (mono_class_is_nullable (mono_class_from_mono_type (cf->type))) {\n\t\tMonoClass *nklass = mono_class_from_mono_type (cf->type);\n\t\tguint8 *buf;\n\n\t\t/* Convert the Nullable structure into a boxed vtype */\n\t\tif (is_static)\n\t\t\tbuf = (guint8*)vtable->data + cf->offset;\n\t\telse\n\t\t\tbuf = (guint8*)obj + cf->offset;\n\n\t\treturn mono_nullable_box (buf, nklass);\n\t}\n\n\t/* boxed value type */\n\tklass = mono_class_from_mono_type (cf->type);\n\to = mono_object_new (domain, klass);\n\tv = ((gchar *) o) + sizeof (MonoObject);\n\tif (is_static) {\n\t\tmono_field_static_get_value (vtable, cf, v);\n\t} else {\n\t\tmono_field_get_value (obj, cf, v);\n\t}\n\n\treturn o;\n}\n\nstatic void\nves_icall_MonoField_SetValueInternal (MonoReflectionField *field, MonoObject *obj, MonoObject *value)\n{\n\tMonoClassField *cf = field->field;\n\tgchar *v;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (field->klass->image->assembly->ref_only)\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\n\t\t\t\t\t\"It is illegal to set the value on a field on a type loaded using the ReflectionOnly methods.\"));\n\n\tif (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\tmono_security_core_clr_ensure_reflection_access_field (cf);\n\n\tv = (gchar *) value;\n\tif (!cf->type->byref) {\n\t\tswitch (cf->type->type) {\n\t\tcase MONO_TYPE_U1:\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_BOOLEAN:\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_U:\n\t\tcase MONO_TYPE_I:\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_I4:\n\t\tcase MONO_TYPE_R4:\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I8:\n\t\tcase MONO_TYPE_R8:\n\t\tcase MONO_TYPE_VALUETYPE:\n\t\t\tif (v != NULL)\n\t\t\t\tv += sizeof (MonoObject);\n\t\t\tbreak;\n\t\tcase MONO_TYPE_STRING:\n\t\tcase MONO_TYPE_OBJECT:\n\t\tcase MONO_TYPE_CLASS:\n\t\tcase MONO_TYPE_ARRAY:\n\t\tcase MONO_TYPE_SZARRAY:\n\t\t\t/* Do nothing */\n\t\t\tbreak;\n\t\tcase MONO_TYPE_GENERICINST: {\n\t\t\tMonoGenericClass *gclass = cf->type->data.generic_class;\n\t\t\tg_assert (!gclass->context.class_inst->is_open);\n\n\t\t\tif (mono_class_is_nullable (mono_class_from_mono_type (cf->type))) {\n\t\t\t\tMonoClass *nklass = mono_class_from_mono_type (cf->type);\n\t\t\t\tMonoObject *nullable;\n\n\t\t\t\t/* \n\t\t\t\t * Convert the boxed vtype into a Nullable structure.\n\t\t\t\t * This is complicated by the fact that Nullables have\n\t\t\t\t * a variable structure.\n\t\t\t\t */\n\t\t\t\tnullable = mono_object_new (mono_domain_get (), nklass);\n\n\t\t\t\tmono_nullable_init (mono_object_unbox (nullable), value, nklass);\n\n\t\t\t\tv = mono_object_unbox (nullable);\n\t\t\t}\n\t\t\telse \n\t\t\t\tif (gclass->container_class->valuetype && (v != NULL))\n\t\t\t\t\tv += sizeof (MonoObject);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tg_error (\"type 0x%x not handled in \"\n\t\t\t\t \"ves_icall_FieldInfo_SetValueInternal\", cf->type->type);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (cf->type->attrs & FIELD_ATTRIBUTE_STATIC) {\n\t\tMonoVTable *vtable = mono_class_vtable_full (mono_object_domain (field), cf->parent, TRUE);\n\t\tif (!vtable->initialized)\n\t\t\tmono_runtime_class_init (vtable);\n\t\tmono_field_static_set_value (vtable, cf, v);\n\t} else {\n\t\tmono_field_set_value (obj, cf, v);\n\t}\n}\n\nstatic MonoObject *\nves_icall_MonoField_GetRawConstantValue (MonoReflectionField *this)\n{\t\n\tMonoObject *o = NULL;\n\tMonoClassField *field = this->field;\n\tMonoClass *klass;\n\tMonoDomain *domain = mono_object_domain (this); \n\tgchar *v;\n\tMonoTypeEnum def_type;\n\tconst char *def_value;\n\n\tMONO_ARCH_SAVE_REGS;\n\t\n\tmono_class_init (field->parent);\n\n\tif (!(field->type->attrs & FIELD_ATTRIBUTE_HAS_DEFAULT))\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (NULL));\n\n\tif (field->parent->image->dynamic) {\n\t\t/* FIXME: */\n\t\tg_assert_not_reached ();\n\t}\n\n\tdef_value = mono_class_get_field_default_value (field, &def_type);\n\n\tswitch (def_type) {\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_R8: {\n\t\tMonoType *t;\n\n\t\t/* boxed value type */\n\t\tt = g_new0 (MonoType, 1);\n\t\tt->type = def_type;\n\t\tklass = mono_class_from_mono_type (t);\n\t\tg_free (t);\n\t\to = mono_object_new (domain, klass);\n\t\tv = ((gchar *) o) + sizeof (MonoObject);\n\t\tmono_get_constant_value_from_blob (domain, def_type, def_value, v);\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_CLASS:\n\t\tmono_get_constant_value_from_blob (domain, def_type, def_value, &o);\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\treturn o;\n}\n\nstatic MonoReflectionType*\nves_icall_MonoGenericMethod_get_ReflectedType (MonoReflectionGenericMethod *rmethod)\n{\n\tMonoMethod *method = rmethod->method.method;\n\n\treturn mono_type_get_object (mono_object_domain (rmethod), &method->klass->byval_arg);\n}\n\n/* From MonoProperty.cs */\ntypedef enum {\n\tPInfo_Attributes = 1,\n\tPInfo_GetMethod  = 1 << 1,\n\tPInfo_SetMethod  = 1 << 2,\n\tPInfo_ReflectedType = 1 << 3,\n\tPInfo_DeclaringType = 1 << 4,\n\tPInfo_Name = 1 << 5\n} PInfo;\n\nstatic void\nves_icall_get_property_info (MonoReflectionProperty *property, MonoPropertyInfo *info, PInfo req_info)\n{\n\tMonoDomain *domain = mono_object_domain (property); \n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif ((req_info & PInfo_ReflectedType) != 0)\n\t\tMONO_STRUCT_SETREF (info, parent, mono_type_get_object (domain, &property->klass->byval_arg));\n\telse if ((req_info & PInfo_DeclaringType) != 0)\n\t\tMONO_STRUCT_SETREF (info, parent, mono_type_get_object (domain, &property->property->parent->byval_arg));\n\n\tif ((req_info & PInfo_Name) != 0)\n\t\tMONO_STRUCT_SETREF (info, name, mono_string_new (domain, property->property->name));\n\n\tif ((req_info & PInfo_Attributes) != 0)\n\t\tinfo->attrs = property->property->attrs;\n\n\tif ((req_info & PInfo_GetMethod) != 0)\n\t\tMONO_STRUCT_SETREF (info, get, property->property->get ?\n\t\t\t\t\t\t\tmono_method_get_object (domain, property->property->get, property->klass): NULL);\n\t\n\tif ((req_info & PInfo_SetMethod) != 0)\n\t\tMONO_STRUCT_SETREF (info, set, property->property->set ?\n\t\t\t\t\t\t\tmono_method_get_object (domain, property->property->set, property->klass): NULL);\n\t/* \n\t * There may be other methods defined for properties, though, it seems they are not exposed \n\t * in the reflection API \n\t */\n}\n\nstatic void\nves_icall_get_event_info (MonoReflectionMonoEvent *event, MonoEventInfo *info)\n{\n\tMonoDomain *domain = mono_object_domain (event); \n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_STRUCT_SETREF (info, reflected_type, mono_type_get_object (domain, &event->klass->byval_arg));\n\tMONO_STRUCT_SETREF (info, declaring_type, mono_type_get_object (domain, &event->event->parent->byval_arg));\n\n\tMONO_STRUCT_SETREF (info, name, mono_string_new (domain, event->event->name));\n\tinfo->attrs = event->event->attrs;\n\tMONO_STRUCT_SETREF (info, add_method, event->event->add ? mono_method_get_object (domain, event->event->add, NULL): NULL);\n\tMONO_STRUCT_SETREF (info, remove_method, event->event->remove ? mono_method_get_object (domain, event->event->remove, NULL): NULL);\n\tMONO_STRUCT_SETREF (info, raise_method, event->event->raise ? mono_method_get_object (domain, event->event->raise, NULL): NULL);\n\n\tif (event->event->other) {\n\t\tint i, n = 0;\n\t\twhile (event->event->other [n])\n\t\t\tn++;\n\t\tMONO_STRUCT_SETREF (info, other_methods, mono_array_new (domain, mono_defaults.method_info_class, n));\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tmono_array_setref (info->other_methods, i, mono_method_get_object (domain, event->event->other [i], NULL));\n\t}\t\t\n}\n\nstatic MonoArray*\nves_icall_Type_GetInterfaces (MonoReflectionType* type)\n{\n\tMonoError error;\n\tMonoDomain *domain = mono_object_domain (type); \n\tMonoArray *intf;\n\tGPtrArray *ifaces = NULL;\n\tint i;\n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\tMonoClass *parent;\n\tMonoBitSet *slots;\n\tMonoGenericContext *context = NULL;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (class->generic_class && class->generic_class->context.class_inst->is_open) {\n\t\tcontext = mono_class_get_context (class);\n\t\tclass = class->generic_class->container_class;\n\t}\n\n\tmono_class_setup_vtable (class);\n\n\tslots = mono_bitset_new (class->max_interface_id + 1, 0);\n\n\tfor (parent = class; parent; parent = parent->parent) {\n\t\tGPtrArray *tmp_ifaces = mono_class_get_implemented_interfaces (parent, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tmono_bitset_free (slots);\n\t\t\tmono_error_raise_exception (&error);\n\t\t\treturn NULL;\n\t\t} else if (tmp_ifaces) {\n\t\t\tfor (i = 0; i < tmp_ifaces->len; ++i) {\n\t\t\t\tMonoClass *ic = g_ptr_array_index (tmp_ifaces, i);\n\n\t\t\t\tif (mono_bitset_test (slots, ic->interface_id))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmono_bitset_set (slots, ic->interface_id);\n\t\t\t\tif (ifaces == NULL)\n\t\t\t\t\tifaces = g_ptr_array_new ();\n\t\t\t\tg_ptr_array_add (ifaces, ic);\n\t\t\t}\n\t\t\tg_ptr_array_free (tmp_ifaces, TRUE);\n\t\t}\n\t}\n\tmono_bitset_free (slots);\n\n\tif (!ifaces)\n\t\treturn mono_array_new_cached (domain, mono_defaults.monotype_class, 0);\n\t\t\n\tintf = mono_array_new_cached (domain, mono_defaults.monotype_class, ifaces->len);\n\tfor (i = 0; i < ifaces->len; ++i) {\n\t\tMonoClass *ic = g_ptr_array_index (ifaces, i);\n\t\tMonoType *ret = &ic->byval_arg, *inflated = NULL;\n\t\tif (context && ic->generic_class && ic->generic_class->context.class_inst->is_open)\n\t\t\tinflated = ret = mono_class_inflate_generic_type (ret, context);\n\t\t\n\t\tmono_array_setref (intf, i, mono_type_get_object (domain, ret));\n\t\tif (inflated)\n\t\t\tmono_metadata_free_type (inflated);\n\t}\n\tg_ptr_array_free (ifaces, TRUE);\n\n\treturn intf;\n}\n\nstatic void\nves_icall_Type_GetInterfaceMapData (MonoReflectionType *type, MonoReflectionType *iface, MonoArray **targets, MonoArray **methods)\n{\n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\tMonoClass *iclass = mono_class_from_mono_type (iface->type);\n\tMonoReflectionMethod *member;\n\tMonoMethod* method;\n\tgpointer iter;\n\tint i = 0, len, ioffset;\n\tMonoDomain *domain;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_class_setup_vtable (class);\n\n\t/* type doesn't implement iface: the exception is thrown in managed code */\n\tif (! MONO_CLASS_IMPLEMENTS_INTERFACE (class, iclass->interface_id))\n\t\t\treturn;\n\n\tlen = mono_class_num_methods (iclass);\n\tioffset = mono_class_interface_offset (class, iclass);\n\tdomain = mono_object_domain (type);\n\tmono_gc_wbarrier_generic_store (targets, (MonoObject*) mono_array_new (domain, mono_defaults.method_info_class, len));\n\tmono_gc_wbarrier_generic_store (methods, (MonoObject*) mono_array_new (domain, mono_defaults.method_info_class, len));\n\titer = NULL;\n\twhile ((method = mono_class_get_methods (iclass, &iter))) {\n\t\tmember = mono_method_get_object (domain, method, iclass);\n\t\tmono_array_setref (*methods, i, member);\n\t\tmember = mono_method_get_object (domain, class->vtable [i + ioffset], class);\n\t\tmono_array_setref (*targets, i, member);\n\t\t\n\t\ti ++;\n\t}\n}\n\nstatic void\nves_icall_Type_GetPacking (MonoReflectionType *type, guint32 *packing, guint32 *size)\n{\n\tMonoClass *klass = mono_class_from_mono_type (type->type);\n\n\tif (klass->image->dynamic) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)type;\n\t\t*packing = tb->packing_size;\n\t\t*size = tb->class_size;\n\t} else {\n\t\tmono_metadata_packing_from_typedef (klass->image, klass->type_token, packing, size);\n\t}\n}\n\nstatic MonoReflectionType*\nves_icall_MonoType_GetElementType (MonoReflectionType *type)\n{\n\tMonoClass *class;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!type->type->byref && type->type->type == MONO_TYPE_SZARRAY)\n\t\treturn mono_type_get_object (mono_object_domain (type), &type->type->data.klass->byval_arg);\n\n\tclass = mono_class_from_mono_type (type->type);\n\n\t// GetElementType should only return a type for:\n\t// Array Pointer PassedByRef\n\tif (type->type->byref)\n\t\treturn mono_type_get_object (mono_object_domain (type), &class->byval_arg);\n\telse if (class->element_class && MONO_CLASS_IS_ARRAY (class))\n\t\treturn mono_type_get_object (mono_object_domain (type), &class->element_class->byval_arg);\n\telse if (class->element_class && type->type->type == MONO_TYPE_PTR)\n\t\treturn mono_type_get_object (mono_object_domain (type), &class->element_class->byval_arg);\n\telse\n\t\treturn NULL;\n}\n\nstatic MonoReflectionType*\nves_icall_get_type_parent (MonoReflectionType *type)\n{\n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn class->parent ? mono_type_get_object (mono_object_domain (type), &class->parent->byval_arg): NULL;\n}\n\nstatic MonoBoolean\nves_icall_type_ispointer (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn type->type->type == MONO_TYPE_PTR;\n}\n\nstatic MonoBoolean\nves_icall_type_isprimitive (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn (!type->type->byref && (((type->type->type >= MONO_TYPE_BOOLEAN) && (type->type->type <= MONO_TYPE_R8)) || (type->type->type == MONO_TYPE_I) || (type->type->type == MONO_TYPE_U)));\n}\n\nstatic MonoBoolean\nves_icall_type_isbyref (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn type->type->byref;\n}\n\nstatic MonoBoolean\nves_icall_type_iscomobject (MonoReflectionType *type)\n{\n\tMonoClass *klass = mono_class_from_mono_type (type->type);\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn (klass && klass->is_com_object);\n}\n\nstatic MonoReflectionModule*\nves_icall_MonoType_get_Module (MonoReflectionType *type)\n{\n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_module_get_object (mono_object_domain (type), class->image);\n}\n\nstatic MonoReflectionAssembly*\nves_icall_MonoType_get_Assembly (MonoReflectionType *type)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_assembly_get_object (domain, class->image->assembly);\n}\n\nstatic MonoReflectionType*\nves_icall_MonoType_get_DeclaringType (MonoReflectionType *type)\n{\n\tMonoDomain *domain = mono_domain_get ();\n\tMonoClass *class;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->type->byref)\n\t\treturn NULL;\n\tif (type->type->type == MONO_TYPE_VAR)\n\t\tclass = mono_type_get_generic_param_owner (type->type)->owner.klass;\n\telse if (type->type->type == MONO_TYPE_MVAR)\n\t\tclass = mono_type_get_generic_param_owner (type->type)->owner.method->klass;\n\telse\n\t\tclass = mono_class_from_mono_type (type->type)->nested_in;\n\n\treturn class ? mono_type_get_object (domain, &class->byval_arg) : NULL;\n}\n\nstatic MonoReflectionType*\nves_icall_MonoType_get_UnderlyingSystemType (MonoReflectionType *type)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (class->enumtype && mono_class_enum_basetype (class)) /* types that are modified typebuilders may not have enum_basetype set */\n\t\treturn mono_type_get_object (domain, mono_class_enum_basetype (class));\n\telse if (class->element_class)\n\t\treturn mono_type_get_object (domain, &class->element_class->byval_arg);\n\telse\n\t\treturn NULL;\n}\n\nstatic MonoString*\nves_icall_MonoType_get_Name (MonoReflectionType *type)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->type->byref) {\n\t\tchar *n = g_strdup_printf (\"%s&\", class->name);\n\t\tMonoString *res = mono_string_new (domain, n);\n\n\t\tg_free (n);\n\n\t\treturn res;\n\t} else {\n\t\treturn mono_string_new (domain, class->name);\n\t}\n}\n\nstatic MonoString*\nves_icall_MonoType_get_Namespace (MonoReflectionType *type)\n{\n\tMonoDomain *domain = mono_domain_get (); \n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\twhile (class->nested_in)\n\t\tclass = class->nested_in;\n\n\tif (class->name_space [0] == '\\0')\n\t\treturn NULL;\n\telse\n\t\treturn mono_string_new (domain, class->name_space);\n}\n\nstatic gint32\nves_icall_MonoType_GetArrayRank (MonoReflectionType *type)\n{\n\tMonoClass *class;\n\n\tif (type->type->type != MONO_TYPE_ARRAY && type->type->type != MONO_TYPE_SZARRAY)\n\t\tmono_raise_exception (mono_get_exception_argument (\"type\", \"Type must be an array type\"));\n\n\tclass = mono_class_from_mono_type (type->type);\n\treturn class->rank;\n}\n\nstatic MonoArray*\nves_icall_MonoType_GetGenericArguments (MonoReflectionType *type)\n{\n\tMonoArray *res;\n\tMonoClass *klass, *pklass;\n\tMonoDomain *domain = mono_object_domain (type);\n\tMonoVTable *array_vtable = mono_class_vtable_full (domain, mono_array_class_get_cached (mono_defaults.systemtype_class, 1), TRUE);\n\tint i;\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (type->type);\n\n\tif (klass->generic_container) {\n\t\tMonoGenericContainer *container = klass->generic_container;\n\t\tres = mono_array_new_specific (array_vtable, container->type_argc);\n\t\tfor (i = 0; i < container->type_argc; ++i) {\n\t\t\tpklass = mono_class_from_generic_parameter (mono_generic_container_get_param (container, i), klass->image, FALSE);\n\t\t\tmono_array_setref (res, i, mono_type_get_object (domain, &pklass->byval_arg));\n\t\t}\n\t} else if (klass->generic_class) {\n\t\tMonoGenericInst *inst = klass->generic_class->context.class_inst;\n\t\tres = mono_array_new_specific (array_vtable, inst->type_argc);\n\t\tfor (i = 0; i < inst->type_argc; ++i)\n\t\t\tmono_array_setref (res, i, mono_type_get_object (domain, inst->type_argv [i]));\n\t} else {\n\t\tres = mono_array_new_specific (array_vtable, 0);\n\t}\n\treturn res;\n}\n\nstatic gboolean\nves_icall_Type_get_IsGenericTypeDefinition (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!IS_MONOTYPE (type))\n\t\treturn FALSE;\n\n\tif (type->type->byref)\n\t\treturn FALSE;\n\n\tklass = mono_class_from_mono_type (type->type);\n\n\treturn klass->generic_container != NULL;\n}\n\nstatic MonoReflectionType*\nves_icall_Type_GetGenericTypeDefinition_impl (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->type->byref)\n\t\treturn NULL;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tif (klass->generic_container) {\n\t\treturn type; /* check this one */\n\t}\n\tif (klass->generic_class) {\n\t\tMonoClass *generic_class = klass->generic_class->container_class;\n\n\t\tif (generic_class->wastypebuilder && generic_class->reflection_info)\n\t\t\treturn generic_class->reflection_info;\n\t\telse\n\t\t\treturn mono_type_get_object (mono_object_domain (type), &generic_class->byval_arg);\n\t}\n\treturn NULL;\n}\n\nstatic MonoReflectionType*\nves_icall_Type_MakeGenericType (MonoReflectionType *type, MonoArray *type_array)\n{\n\tMonoClass *class;\n\tMonoType *geninst, **types;\n\tint i, count;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tcount = mono_array_length (type_array);\n\ttypes = g_new0 (MonoType *, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *t = mono_array_get (type_array, gpointer, i);\n\t\ttypes [i] = t->type;\n\t}\n\n\tgeninst = mono_reflection_bind_generic_parameters (type, count, types);\n\tg_free (types);\n\tif (!geninst)\n\t\treturn NULL;\n\n\tclass = mono_class_from_mono_type (geninst);\n\n\t/*we might inflate to the GTD*/\n\tif (class->generic_class && !mono_verifier_class_is_valid_generic_instantiation (class))\n\t\tmono_raise_exception (mono_get_exception_argument (\"method\", \"Invalid generic arguments\"));\n\n\treturn mono_type_get_object (mono_object_domain (type), geninst);\n}\n\nstatic gboolean\nves_icall_Type_get_IsGenericInstance (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->type->byref)\n\t\treturn FALSE;\n\n\tklass = mono_class_from_mono_type (type->type);\n\treturn klass->generic_class != NULL;\n}\n\nstatic gboolean\nves_icall_Type_get_IsGenericType (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!IS_MONOTYPE (type))\n\t\treturn FALSE;\n\n\tif (type->type->byref)\n\t\treturn FALSE;\n\n\tklass = mono_class_from_mono_type (type->type);\n\treturn klass->generic_class != NULL || klass->generic_container != NULL;\n}\n\nstatic gint32\nves_icall_Type_GetGenericParameterPosition (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!IS_MONOTYPE (type))\n\t\treturn -1;\n\n\tif (is_generic_parameter (type->type))\n\t\treturn mono_type_get_generic_param_num (type->type);\n\treturn -1;\n}\n\nstatic GenericParameterAttributes\nves_icall_Type_GetGenericParameterAttributes (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_assert (IS_MONOTYPE (type));\n\tg_assert (is_generic_parameter (type->type));\n\treturn mono_generic_param_info (type->type->data.generic_param)->flags;\n}\n\nstatic MonoArray *\nves_icall_Type_GetGenericParameterConstraints (MonoReflectionType *type)\n{\n\tMonoGenericParamInfo *param_info;\n\tMonoDomain *domain;\n\tMonoClass **ptr;\n\tMonoArray *res;\n\tint i, count;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_assert (IS_MONOTYPE (type));\n\n\tdomain = mono_object_domain (type);\n\tparam_info = mono_generic_param_info (type->type->data.generic_param);\n\tfor (count = 0, ptr = param_info->constraints; ptr && *ptr; ptr++, count++)\n\t\t;\n\n\tres = mono_array_new (domain, mono_defaults.monotype_class, count);\n\tfor (i = 0; i < count; i++)\n\t\tmono_array_setref (res, i, mono_type_get_object (domain, &param_info->constraints [i]->byval_arg));\n\n\n\treturn res;\n}\n\nstatic MonoBoolean\nves_icall_MonoType_get_IsGenericParameter (MonoReflectionType *type)\n{\n\tMONO_ARCH_SAVE_REGS;\n\treturn is_generic_parameter (type->type);\n}\n\nstatic MonoBoolean\nves_icall_TypeBuilder_get_IsGenericParameter (MonoReflectionTypeBuilder *tb)\n{\n\tMONO_ARCH_SAVE_REGS;\n\treturn is_generic_parameter (tb->type.type);\n}\n\nstatic void\nves_icall_EnumBuilder_setup_enum_type (MonoReflectionType *enumtype,\n\t\t\t\t\t\t\t\t\t   MonoReflectionType *t)\n{\n\tenumtype->type = t->type;\n}\n\nstatic MonoReflectionMethod*\nves_icall_MonoType_GetCorrespondingInflatedMethod (MonoReflectionType *type, \n                                                   MonoReflectionMethod* generic)\n{\n\tMonoDomain *domain; \n\tMonoClass *klass;\n\tMonoMethod *method;\n\tgpointer iter;\n\t\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\n\tklass = mono_class_from_mono_type (type->type);\n\n\titer = NULL;\n\twhile ((method = mono_class_get_methods (klass, &iter))) {\n                if (method->token == generic->method->token)\n                        return mono_method_get_object (domain, method, klass);\n        }\n\n        return NULL;\n}\n\n\n\nstatic MonoReflectionMethod *\nves_icall_MonoType_get_DeclaringMethod (MonoReflectionType *ref_type)\n{\n\tMonoMethod *method;\n\tMonoType *type = ref_type->type;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (type->byref || (type->type != MONO_TYPE_MVAR && type->type != MONO_TYPE_VAR))\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\"DeclaringMethod can only be used on generic arguments\"));\n\tif (type->type == MONO_TYPE_VAR)\n\t\treturn NULL;\n\n\tmethod = mono_type_get_generic_param_owner (type)->owner.method;\n\tg_assert (method);\n\treturn mono_method_get_object (mono_object_domain (ref_type), method, method->klass);\n}\n\nstatic MonoReflectionDllImportAttribute*\nves_icall_MonoMethod_GetDllImportAttribute (MonoMethod *method)\n{\n\tstatic MonoClass *DllImportAttributeClass = NULL;\n\tMonoDomain *domain = mono_domain_get ();\n\tMonoReflectionDllImportAttribute *attr;\n\tMonoImage *image = method->klass->image;\n\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)method;\n\tMonoTableInfo *tables = image->tables;\n\tMonoTableInfo *im = &tables [MONO_TABLE_IMPLMAP];\n\tMonoTableInfo *mr = &tables [MONO_TABLE_MODULEREF];\n\tguint32 im_cols [MONO_IMPLMAP_SIZE];\n\tguint32 scope_token;\n\tconst char *import = NULL;\n\tconst char *scope = NULL;\n\tguint32 flags;\n\n\tif (!(method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))\n\t\treturn NULL;\n\n\tif (!DllImportAttributeClass) {\n\t\tDllImportAttributeClass = \n\t\t\tmono_class_from_name (mono_defaults.corlib,\n\t\t\t\t\t\t\t\t  \"System.Runtime.InteropServices\", \"DllImportAttribute\");\n\t\tg_assert (DllImportAttributeClass);\n\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tif (method->klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\tg_hash_table_lookup (\n\t\t\t\t\t\t\t\t\t  ((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (method_aux) {\n\t\t\timport = method_aux->dllentry;\n\t\t\tscope = method_aux->dll;\n\t\t}\n\n\t\tif (!import || !scope) {\n\t\t\tmono_raise_exception (mono_get_exception_argument (\"method\", \"System.Reflection.Emit method with invalid pinvoke information\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse {\n\t\tif (piinfo->implmap_idx) {\n\t\t\tmono_metadata_decode_row (im, piinfo->implmap_idx - 1, im_cols, MONO_IMPLMAP_SIZE);\n\t\t\t\n\t\t\tpiinfo->piflags = im_cols [MONO_IMPLMAP_FLAGS];\n\t\t\timport = mono_metadata_string_heap (image, im_cols [MONO_IMPLMAP_NAME]);\n\t\t\tscope_token = mono_metadata_decode_row_col (mr, im_cols [MONO_IMPLMAP_SCOPE] - 1, MONO_MODULEREF_NAME);\n\t\t\tscope = mono_metadata_string_heap (image, scope_token);\n\t\t}\n\t}\n\tflags = piinfo->piflags;\n\t\n\tattr = (MonoReflectionDllImportAttribute*)mono_object_new (domain, DllImportAttributeClass);\n\n\tMONO_OBJECT_SETREF (attr, dll, mono_string_new (domain, scope));\n\tMONO_OBJECT_SETREF (attr, entry_point, mono_string_new (domain, import));\n\tattr->call_conv = (flags & 0x700) >> 8;\n\tattr->charset = ((flags & 0x6) >> 1) + 1;\n\tif (attr->charset == 1)\n\t\tattr->charset = 2;\n\tattr->exact_spelling = (flags & 0x1) != 0;\n\tattr->set_last_error = (flags & 0x40) != 0;\n\tattr->best_fit_mapping = (flags & 0x30) == 0x10;\n\tattr->throw_on_unmappable = (flags & 0x3000) == 0x1000;\n\tattr->preserve_sig = FALSE;\n\n\treturn attr;\n}\n\nstatic MonoReflectionMethod *\nves_icall_MonoMethod_GetGenericMethodDefinition (MonoReflectionMethod *method)\n{\n\tMonoMethodInflated *imethod;\n\tMonoMethod *result;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (method->method->is_generic)\n\t\treturn method;\n\n\tif (!method->method->is_inflated)\n\t\treturn NULL;\n\n\timethod = (MonoMethodInflated *) method->method;\n\n\tresult = imethod->declaring;\n\t/* Not a generic method.  */\n\tif (!result->is_generic)\n\t\treturn NULL;\n\n\tif (method->method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->method->klass->image;\n\t\tMonoReflectionMethod *res;\n\n\t\t/*\n\t\t * FIXME: Why is this stuff needed at all ? Why can't the code below work for\n\t\t * the dynamic case as well ?\n\t\t */\n\t\tmono_loader_lock ();\n\t\tres = mono_g_hash_table_lookup (image->generic_def_objects, imethod);\n\t\tmono_loader_unlock ();\n\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (imethod->context.class_inst) {\n\t\tMonoClass *klass = ((MonoMethod *) imethod)->klass;\n\t\t/*Generic methods gets the context of the GTD.*/\n\t\tif (mono_class_get_context (klass))\n\t\t\tresult = mono_class_inflate_generic_method_full (result, klass, mono_class_get_context (klass));\n\t}\n\n\treturn mono_method_get_object (mono_object_domain (method), result, NULL);\n}\n\nstatic gboolean\nves_icall_MonoMethod_get_IsGenericMethod (MonoReflectionMethod *method)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_method_signature (method->method)->generic_param_count != 0;\n}\n\nstatic gboolean\nves_icall_MonoMethod_get_IsGenericMethodDefinition (MonoReflectionMethod *method)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn method->method->is_generic;\n}\n\nstatic MonoArray*\nves_icall_MonoMethod_GetGenericArguments (MonoReflectionMethod *method)\n{\n\tMonoArray *res;\n\tMonoDomain *domain;\n\tint count, i;\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = mono_object_domain (method);\n\n\tif (method->method->is_inflated) {\n\t\tMonoGenericInst *inst = mono_method_get_context (method->method)->method_inst;\n\n\t\tif (inst) {\n\t\t\tcount = inst->type_argc;\n\t\t\tres = mono_array_new (domain, mono_defaults.systemtype_class, count);\n\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tmono_array_setref (res, i, mono_type_get_object (domain, inst->type_argv [i]));\n\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tcount = mono_method_signature (method->method)->generic_param_count;\n\tres = mono_array_new (domain, mono_defaults.systemtype_class, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tMonoGenericContainer *container = mono_method_get_generic_container (method->method);\n\t\tMonoGenericParam *param = mono_generic_container_get_param (container, i);\n\t\tMonoClass *pklass = mono_class_from_generic_parameter (\n\t\t\tparam, method->method->klass->image, TRUE);\n\t\tmono_array_setref (res, i,\n\t\t\t\tmono_type_get_object (domain, &pklass->byval_arg));\n\t}\n\n\treturn res;\n}\n\nstatic MonoObject *\nves_icall_InternalInvoke (MonoReflectionMethod *method, MonoObject *this, MonoArray *params, MonoException **exc) \n{\n\t/* \n\t * Invoke from reflection is supposed to always be a virtual call (the API\n\t * is stupid), mono_runtime_invoke_*() calls the provided method, allowing\n\t * greater flexibility.\n\t */\n\tMonoMethod *m = method->method;\n\tint pcount;\n\tvoid *obj = this;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t*exc = NULL;\n\n\tif (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\tmono_security_core_clr_ensure_reflection_access_method (m);\n\n\tif (!(m->flags & METHOD_ATTRIBUTE_STATIC)) {\n\t\tif (!mono_class_vtable_full (mono_object_domain (method), m->klass, FALSE)) {\n\t\t\tmono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_class_get_exception_for_failure (m->klass));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (this) {\n\t\t\tif (!mono_object_isinst (this, m->klass)) {\n\t\t\t\tmono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_exception_from_name_msg (mono_defaults.corlib, \"System.Reflection\", \"TargetException\", \"Object does not match target type.\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tm = mono_object_get_virtual_method (this, m);\n\t\t\t/* must pass the pointer to the value for valuetype methods */\n\t\t\tif (m->klass->valuetype)\n\t\t\t\tobj = mono_object_unbox (this);\n\t\t} else if (strcmp (m->name, \".ctor\") && !m->wrapper_type) {\n\t\t\tmono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_exception_from_name_msg (mono_defaults.corlib, \"System.Reflection\", \"TargetException\", \"Non-static method requires a target.\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tpcount = params? mono_array_length (params): 0;\n\tif (pcount != mono_method_signature (m)->param_count) {\n\t\tmono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_exception_from_name (mono_defaults.corlib, \"System.Reflection\", \"TargetParameterCountException\"));\n\t\treturn NULL;\n\t}\n\n\tif ((m->klass->flags & TYPE_ATTRIBUTE_ABSTRACT) && !strcmp (m->name, \".ctor\") && !this) {\n\t\tmono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_exception_from_name_msg (mono_defaults.corlib, \"System.Reflection\", \"TargetException\", \"Cannot invoke constructor of an abstract class.\"));\n\t\treturn NULL;\n\t}\n\n\tif (m->klass->image->assembly->ref_only) {\n\t\tmono_gc_wbarrier_generic_store (exc, (MonoObject*) mono_get_exception_invalid_operation (\"It is illegal to invoke a method on a type loaded using the ReflectionOnly api.\"));\n\t\treturn NULL;\n\t}\n\t\n\tif (m->klass->rank && !strcmp (m->name, \".ctor\")) {\n\t\tint i;\n\t\tmono_array_size_t *lengths;\n\t\tmono_array_size_t *lower_bounds;\n\t\tpcount = mono_array_length (params);\n\t\tlengths = alloca (sizeof (mono_array_size_t) * pcount);\n\t\tfor (i = 0; i < pcount; ++i)\n\t\t\tlengths [i] = *(mono_array_size_t*) ((char*)mono_array_get (params, gpointer, i) + sizeof (MonoObject));\n\n\t\tif (m->klass->rank == pcount) {\n\t\t\t/* Only lengths provided. */\n\t\t\tlower_bounds = NULL;\n\t\t} else {\n\t\t\tg_assert (pcount == (m->klass->rank * 2));\n\t\t\t/* lower bounds are first. */\n\t\t\tlower_bounds = lengths;\n\t\t\tlengths += m->klass->rank;\n\t\t}\n\n\t\treturn (MonoObject*)mono_array_new_full (mono_object_domain (params), m->klass, lengths, lower_bounds);\n\t}\n\treturn mono_runtime_invoke_array (m, obj, params, NULL);\n}\n\nstatic MonoObject *\nves_icall_InternalExecute (MonoReflectionMethod *method, MonoObject *this, MonoArray *params, MonoArray **outArgs) \n{\n\tMonoDomain *domain = mono_object_domain (method); \n\tMonoMethod *m = method->method;\n\tMonoMethodSignature *sig = mono_method_signature (m);\n\tMonoArray *out_args;\n\tMonoObject *result;\n\tint i, j, outarg_count = 0;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (m->klass == mono_defaults.object_class) {\n\n\t\tif (!strcmp (m->name, \"FieldGetter\")) {\n\t\t\tMonoClass *k = this->vtable->klass;\n\t\t\tMonoString *name;\n\t\t\tchar *str;\n\t\t\t\n\t\t\t/* If this is a proxy, then it must be a CBO */\n\t\t\tif (k == mono_defaults.transparent_proxy_class) {\n\t\t\t\tMonoTransparentProxy *tp = (MonoTransparentProxy*) this;\n\t\t\t\tthis = tp->rp->unwrapped_server;\n\t\t\t\tg_assert (this);\n\t\t\t\tk = this->vtable->klass;\n\t\t\t}\n\t\t\t\n\t\t\tname = mono_array_get (params, MonoString *, 1);\n\t\t\tstr = mono_string_to_utf8 (name);\n\t\t\n\t\t\tdo {\n\t\t\t\tMonoClassField* field = mono_class_get_field_from_name (k, str);\n\t\t\t\tif (field) {\n\t\t\t\t\tMonoClass *field_klass =  mono_class_from_mono_type (field->type);\n\t\t\t\t\tif (field_klass->valuetype)\n\t\t\t\t\t\tresult = mono_value_box (domain, field_klass, (char *)this + field->offset);\n\t\t\t\t\telse \n\t\t\t\t\t\tresult = *((gpointer *)((char *)this + field->offset));\n\t\t\t\t\n\t\t\t\t\tout_args = mono_array_new (domain, mono_defaults.object_class, 1);\n\t\t\t\t\tmono_gc_wbarrier_generic_store (outArgs, (MonoObject*) out_args);\n\t\t\t\t\tmono_array_setref (out_args, 0, result);\n\t\t\t\t\tg_free (str);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tk = k->parent;\n\t\t\t} while (k);\n\n\t\t\tg_free (str);\n\t\t\tg_assert_not_reached ();\n\n\t\t} else if (!strcmp (m->name, \"FieldSetter\")) {\n\t\t\tMonoClass *k = this->vtable->klass;\n\t\t\tMonoString *name;\n\t\t\tguint32 size;\n\t\t\tgint32 align;\n\t\t\tchar *str;\n\t\t\t\n\t\t\t/* If this is a proxy, then it must be a CBO */\n\t\t\tif (k == mono_defaults.transparent_proxy_class) {\n\t\t\t\tMonoTransparentProxy *tp = (MonoTransparentProxy*) this;\n\t\t\t\tthis = tp->rp->unwrapped_server;\n\t\t\t\tg_assert (this);\n\t\t\t\tk = this->vtable->klass;\n\t\t\t}\n\t\t\t\n\t\t\tname = mono_array_get (params, MonoString *, 1);\n\t\t\tstr = mono_string_to_utf8 (name);\n\t\t\n\t\t\tdo {\n\t\t\t\tMonoClassField* field = mono_class_get_field_from_name (k, str);\n\t\t\t\tif (field) {\n\t\t\t\t\tMonoClass *field_klass =  mono_class_from_mono_type (field->type);\n\t\t\t\t\tMonoObject *val = mono_array_get (params, gpointer, 2);\n\n\t\t\t\t\tif (field_klass->valuetype) {\n\t\t\t\t\t\tsize = mono_type_size (field->type, &align);\n#ifdef HAVE_SGEN_GC\n\t\t\t\t\t\tmono_gc_wbarrier_value_copy ((char *)this + field->offset, (char*)val + sizeof (MonoObject), 1, field_klass);\n#endif\n\t\t\t\t\t\tmemcpy ((char *)this + field->offset, \n\t\t\t\t\t\t\t((char *)val) + sizeof (MonoObject), size);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmono_gc_wbarrier_set_field (this, (char*)this + field->offset, val);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tout_args = mono_array_new (domain, mono_defaults.object_class, 0);\n\t\t\t\t\tmono_gc_wbarrier_generic_store (outArgs, (MonoObject*) out_args);\n\n\t\t\t\t\tg_free (str);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tk = k->parent;\n\t\t\t} while (k);\n\n\t\t\tg_free (str);\n\t\t\tg_assert_not_reached ();\n\n\t\t}\n\t}\n\n\tfor (i = 0; i < mono_array_length (params); i++) {\n\t\tif (sig->params [i]->byref) \n\t\t\toutarg_count++;\n\t}\n\n\tout_args = mono_array_new (domain, mono_defaults.object_class, outarg_count);\n\t\n\t/* handle constructors only for objects already allocated */\n\tif (!strcmp (method->method->name, \".ctor\"))\n\t\tg_assert (this);\n\n\t/* This can be called only on MBR objects, so no need to unbox for valuetypes. */\n\tg_assert (!method->method->klass->valuetype);\n\tresult = mono_runtime_invoke_array (method->method, this, params, NULL);\n\n\tfor (i = 0, j = 0; i < mono_array_length (params); i++) {\n\t\tif (sig->params [i]->byref) {\n\t\t\tgpointer arg;\n\t\t\targ = mono_array_get (params, gpointer, i);\n\t\t\tmono_array_setref (out_args, j, arg);\n\t\t\tj++;\n\t\t}\n\t}\n\n\tmono_gc_wbarrier_generic_store (outArgs, (MonoObject*) out_args);\n\n\treturn result;\n}\n\nstatic guint64\nread_enum_value (char *mem, int type)\n{\n\tswitch (type) {\n\tcase MONO_TYPE_U1:\n\t\treturn *(guint8*)mem;\n\tcase MONO_TYPE_I1:\n\t\treturn *(gint8*)mem;\n\tcase MONO_TYPE_U2:\n\t\treturn *(guint16*)mem;\n\tcase MONO_TYPE_I2:\n\t\treturn *(gint16*)mem;\n\tcase MONO_TYPE_U4:\n\t\treturn *(guint32*)mem;\n\tcase MONO_TYPE_I4:\n\t\treturn *(gint32*)mem;\n\tcase MONO_TYPE_U8:\n\t\treturn *(guint64*)mem;\n\tcase MONO_TYPE_I8:\n\t\treturn *(gint64*)mem;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn 0;\n}\n\nstatic void\nwrite_enum_value (char *mem, int type, guint64 value)\n{\n\tswitch (type) {\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1: {\n\t\tguint8 *p = (guint8*)mem;\n\t\t*p = value;\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2: {\n\t\tguint16 *p = (void*)mem;\n\t\t*p = value;\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4: {\n\t\tguint32 *p = (void*)mem;\n\t\t*p = value;\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8: {\n\t\tguint64 *p = (void*)mem;\n\t\t*p = value;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn;\n}\n\nstatic MonoObject *\nves_icall_System_Enum_ToObject (MonoReflectionType *enumType, MonoObject *value)\n{\n\tMonoDomain *domain; \n\tMonoClass *enumc, *objc;\n\tMonoObject *res;\n\tMonoType *etype;\n\tguint64 val;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (enumType);\n\tMONO_CHECK_ARG_NULL (value);\n\n\tdomain = mono_object_domain (enumType); \n\tenumc = mono_class_from_mono_type (enumType->type);\n\tobjc = value->vtable->klass;\n\n\tif (!enumc->enumtype)\n\t\tmono_raise_exception (mono_get_exception_argument (\"enumType\", \"Type provided must be an Enum.\"));\n\tif (!((objc->enumtype) || (objc->byval_arg.type >= MONO_TYPE_I1 && objc->byval_arg.type <= MONO_TYPE_U8)))\n\t\tmono_raise_exception (mono_get_exception_argument (\"value\", \"The value passed in must be an enum base or an underlying type for an enum, such as an Int32.\"));\n\n\tetype = mono_class_enum_basetype (enumc);\n\tif (!etype)\n\t\t/* MS throws this for typebuilders */\n\t\tmono_raise_exception (mono_get_exception_argument (\"Type must be a type provided by the runtime.\", \"enumType\"));\n\n\tres = mono_object_new (domain, enumc);\n\tval = read_enum_value ((char *)value + sizeof (MonoObject), objc->enumtype? mono_class_enum_basetype (objc)->type: objc->byval_arg.type);\n\twrite_enum_value ((char *)res + sizeof (MonoObject), etype->type, val);\n\n\treturn res;\n}\n\nstatic MonoObject *\nves_icall_System_Enum_get_value (MonoObject *this)\n{\n\tMonoObject *res;\n\tMonoClass *enumc;\n\tgpointer dst;\n\tgpointer src;\n\tint size;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!this)\n\t\treturn NULL;\n\n\tg_assert (this->vtable->klass->enumtype);\n\t\n\tenumc = mono_class_from_mono_type (mono_class_enum_basetype (this->vtable->klass));\n\tres = mono_object_new (mono_object_domain (this), enumc);\n\tdst = (char *)res + sizeof (MonoObject);\n\tsrc = (char *)this + sizeof (MonoObject);\n\tsize = mono_class_value_size (enumc, NULL);\n\n\tmemcpy (dst, src, size);\n\n\treturn res;\n}\n\nstatic MonoReflectionType *\nves_icall_System_Enum_get_underlying_type (MonoReflectionType *type)\n{\n\tMonoType *etype;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tetype = mono_class_enum_basetype (mono_class_from_mono_type (type->type));\n\tif (!etype)\n\t\t/* MS throws this for typebuilders */\n\t\tmono_raise_exception (mono_get_exception_argument (\"Type must be a type provided by the runtime.\", \"enumType\"));\n\n\treturn mono_type_get_object (mono_object_domain (type), etype);\n}\n\nstatic int\nves_icall_System_Enum_compare_value_to (MonoObject *this, MonoObject *other)\n{\n\tgpointer tdata = (char *)this + sizeof (MonoObject);\n\tgpointer odata = (char *)other + sizeof (MonoObject);\n\tMonoType *basetype = mono_class_enum_basetype (this->vtable->klass);\n\tg_assert (basetype);\n\n#define COMPARE_ENUM_VALUES(ENUM_TYPE) do { \\\n\t\tENUM_TYPE me = *((ENUM_TYPE*)tdata); \\\n\t\tENUM_TYPE other = *((ENUM_TYPE*)odata); \\\n\t\tif (me == other) \\\n\t\t\treturn 0; \\\n\t\treturn me > other ? 1 : -1; \\\n\t} while (0)\n\n#define COMPARE_ENUM_VALUES_RANGE(ENUM_TYPE) do { \\\n\t\tENUM_TYPE me = *((ENUM_TYPE*)tdata); \\\n\t\tENUM_TYPE other = *((ENUM_TYPE*)odata); \\\n\t\tif (me == other) \\\n\t\t\treturn 0; \\\n\t\treturn me - other; \\\n\t} while (0)\n\n\tswitch (basetype->type) {\n\t\tcase MONO_TYPE_U1:\n\t\t\tCOMPARE_ENUM_VALUES (guint8);\n\t\tcase MONO_TYPE_I1:\n\t\t\tCOMPARE_ENUM_VALUES (gint8);\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_U2:\n\t\t\tCOMPARE_ENUM_VALUES_RANGE (guint16);\n\t\tcase MONO_TYPE_I2:\n\t\t\tCOMPARE_ENUM_VALUES (gint16);\n\t\tcase MONO_TYPE_U4:\n\t\t\tCOMPARE_ENUM_VALUES (guint32);\n\t\tcase MONO_TYPE_I4:\n\t\t\tCOMPARE_ENUM_VALUES (gint32);\n\t\tcase MONO_TYPE_U8:\n\t\t\tCOMPARE_ENUM_VALUES (guint64);\n\t\tcase MONO_TYPE_I8:\n\t\t\tCOMPARE_ENUM_VALUES (gint64);\n\t\tdefault:\n\t\t\tg_error (\"Implement type 0x%02x in get_hashcode\", basetype->type);\n\t}\n#undef COMPARE_ENUM_VALUES_RANGE\n#undef COMPARE_ENUM_VALUES\n\treturn 0;\n}\n\nstatic int\nves_icall_System_Enum_get_hashcode (MonoObject *this)\n{\n\tgpointer data = (char *)this + sizeof (MonoObject);\n\tMonoType *basetype = mono_class_enum_basetype (this->vtable->klass);\n\tg_assert (basetype);\n\n\tswitch (basetype->type) {\n\t\tcase MONO_TYPE_I1:\t\n\t\t\treturn *((gint8*)data);\n\t\tcase MONO_TYPE_U1:\n\t\t\treturn *((guint8*)data);\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_U2:\n\t\t\treturn *((guint16*)data);\n\t\t\n\t\tcase MONO_TYPE_I2:\n\t\t\treturn *((gint16*)data);\n\t\tcase MONO_TYPE_U4:\n\t\t\treturn *((guint32*)data);\n\t\tcase MONO_TYPE_I4:\n\t\t\treturn *((gint32*)data);\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I8: {\n\t\t\tgint64 value = *((gint64*)data);\n\t\t\treturn (gint)(value & 0xffffffff) ^ (int)(value >> 32);\n\t\t}\n\t\tdefault:\n\t\t\tg_error (\"Implement type 0x%02x in get_hashcode\", basetype->type);\n\t}\n\treturn 0;\n}\n\nstatic void\nves_icall_get_enum_info (MonoReflectionType *type, MonoEnumInfo *info)\n{\n\tMonoDomain *domain = mono_object_domain (type); \n\tMonoClass *enumc = mono_class_from_mono_type (type->type);\n\tguint j = 0, nvalues, crow;\n\tgpointer iter;\n\tMonoClassField *field;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_STRUCT_SETREF (info, utype, mono_type_get_object (domain, mono_class_enum_basetype (enumc)));\n\tnvalues = mono_class_num_fields (enumc) ? mono_class_num_fields (enumc) - 1 : 0;\n\tMONO_STRUCT_SETREF (info, names, mono_array_new (domain, mono_defaults.string_class, nvalues));\n\tMONO_STRUCT_SETREF (info, values, mono_array_new (domain, enumc, nvalues));\n\n\tcrow = -1;\n\titer = NULL;\n\twhile ((field = mono_class_get_fields (enumc, &iter))) {\n\t\tconst char *p;\n\t\tint len;\n\t\tMonoTypeEnum def_type;\n\t\t\n\t\tif (strcmp (\"value__\", mono_field_get_name (field)) == 0)\n\t\t\tcontinue;\n\t\tif (mono_field_is_deleted (field))\n\t\t\tcontinue;\n\t\tmono_array_setref (info->names, j, mono_string_new (domain, mono_field_get_name (field)));\n\n\t\tp = mono_class_get_field_default_value (field, &def_type);\n\t\tlen = mono_metadata_decode_blob_size (p, &p);\n\t\tswitch (mono_class_enum_basetype (enumc)->type) {\n\t\tcase MONO_TYPE_U1:\n\t\tcase MONO_TYPE_I1:\n\t\t\tmono_array_set (info->values, gchar, j, *p);\n\t\t\tbreak;\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_I2:\n\t\t\tmono_array_set (info->values, gint16, j, read16 (p));\n\t\t\tbreak;\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_I4:\n\t\t\tmono_array_set (info->values, gint32, j, read32 (p));\n\t\t\tbreak;\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I8:\n\t\t\tmono_array_set (info->values, gint64, j, read64 (p));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_error (\"Implement type 0x%02x in get_enum_info\", mono_class_enum_basetype (enumc)->type);\n\t\t}\n\t\t++j;\n\t}\n}\n\nenum {\n\tBFLAGS_IgnoreCase = 1,\n\tBFLAGS_DeclaredOnly = 2,\n\tBFLAGS_Instance = 4,\n\tBFLAGS_Static = 8,\n\tBFLAGS_Public = 0x10,\n\tBFLAGS_NonPublic = 0x20,\n\tBFLAGS_FlattenHierarchy = 0x40,\n\tBFLAGS_InvokeMethod = 0x100,\n\tBFLAGS_CreateInstance = 0x200,\n\tBFLAGS_GetField = 0x400,\n\tBFLAGS_SetField = 0x800,\n\tBFLAGS_GetProperty = 0x1000,\n\tBFLAGS_SetProperty = 0x2000,\n\tBFLAGS_ExactBinding = 0x10000,\n\tBFLAGS_SuppressChangeType = 0x20000,\n\tBFLAGS_OptionalParamBinding = 0x40000\n};\n\nstatic MonoReflectionField *\nves_icall_Type_GetField (MonoReflectionType *type, MonoString *name, guint32 bflags)\n{\n\tMonoDomain *domain; \n\tMonoClass *startklass, *klass;\n\tint match;\n\tMonoClassField *field;\n\tgpointer iter;\n\tchar *utf8_name;\n\tint (*compare_func) (const char *s1, const char *s2) = NULL;\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!name)\n\t\tmono_raise_exception (mono_get_exception_argument_null (\"name\"));\n\tif (type->type->byref)\n\t\treturn NULL;\n\n\tcompare_func = (bflags & BFLAGS_IgnoreCase) ? mono_utf8_strcasecmp : strcmp;\n\nhandle_parent:\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\titer = NULL;\n\twhile ((field = mono_class_get_fields (klass, &iter))) {\n\t\tmatch = 0;\n\n\t\tif (field->type == NULL)\n\t\t\tcontinue;\n\t\tif (mono_field_is_deleted (field))\n\t\t\tcontinue;\n\t\tif ((field->type->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) == FIELD_ATTRIBUTE_PUBLIC) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else if ((klass == startklass) || (field->type->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) != FIELD_ATTRIBUTE_PRIVATE) {\n\t\t\tif (bflags & BFLAGS_NonPublic) {\n\t\t\t\tmatch++;\n\t\t\t}\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\t\tif (field->type->attrs & FIELD_ATTRIBUTE_STATIC) {\n\t\t\tif (bflags & BFLAGS_Static)\n\t\t\t\tif ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))\n\t\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\tmatch++;\n\t\t}\n\n\t\tif (!match)\n\t\t\tcontinue;\n\t\t\n\t\tutf8_name = mono_string_to_utf8 (name);\n\n\t\tif (compare_func (mono_field_get_name (field), utf8_name)) {\n\t\t\tg_free (utf8_name);\n\t\t\tcontinue;\n\t\t}\n\t\tg_free (utf8_name);\n\t\t\n\t\treturn mono_field_get_object (domain, klass, field);\n\t}\n\tif (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))\n\t\tgoto handle_parent;\n\n\treturn NULL;\n}\n\nstatic MonoArray*\nves_icall_Type_GetFields_internal (MonoReflectionType *type, guint32 bflags, MonoReflectionType *reftype)\n{\n\tMonoDomain *domain; \n\tMonoClass *startklass, *klass, *refklass;\n\tMonoArray *res;\n\tMonoObject *member;\n\tint i, match;\n\tgpointer iter;\n\tMonoClassField *field;\n\tMonoPtrArray tmp_array;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tif (type->type->byref)\n\t\treturn mono_array_new (domain, mono_defaults.field_info_class, 0);\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\trefklass = mono_class_from_mono_type (reftype->type);\n\n\tmono_ptr_array_init (tmp_array, 2);\n\t\nhandle_parent:\t\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\titer = NULL;\n\twhile ((field = mono_class_get_fields (klass, &iter))) {\n\t\tmatch = 0;\n\t\tif (mono_field_is_deleted (field))\n\t\t\tcontinue;\n\t\tif ((field->type->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) == FIELD_ATTRIBUTE_PUBLIC) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else if ((klass == startklass) || (field->type->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) != FIELD_ATTRIBUTE_PRIVATE) {\n\t\t\tif (bflags & BFLAGS_NonPublic) {\n\t\t\t\tmatch++;\n\t\t\t}\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\t\tif (field->type->attrs & FIELD_ATTRIBUTE_STATIC) {\n\t\t\tif (bflags & BFLAGS_Static)\n\t\t\t\tif ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))\n\t\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\tmatch++;\n\t\t}\n\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmember = (MonoObject*)mono_field_get_object (domain, refklass, field);\n\t\tmono_ptr_array_append (tmp_array, member);\n\t}\n\tif (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))\n\t\tgoto handle_parent;\n\n\tres = mono_array_new_cached (domain, mono_defaults.field_info_class, mono_ptr_array_size (tmp_array));\n\n\tfor (i = 0; i < mono_ptr_array_size (tmp_array); ++i)\n\t\tmono_array_setref (res, i, mono_ptr_array_get (tmp_array, i));\n\n\tmono_ptr_array_destroy (tmp_array);\n\n\treturn res;\n}\n\nstatic gboolean\nmethod_nonpublic (MonoMethod* method, gboolean start_klass)\n{\n\tswitch (method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) {\n\t\tcase METHOD_ATTRIBUTE_ASSEM:\n\t\t\treturn (start_klass || mono_defaults.generic_ilist_class);\n\t\tcase METHOD_ATTRIBUTE_PRIVATE:\n\t\t\treturn start_klass;\n\t\tcase METHOD_ATTRIBUTE_PUBLIC:\n\t\t\treturn FALSE;\n\t\tdefault:\n\t\t\treturn TRUE;\n\t}\n}\n\nstatic MonoArray*\nves_icall_Type_GetMethodsByName (MonoReflectionType *type, MonoString *name, guint32 bflags, MonoBoolean ignore_case, MonoReflectionType *reftype)\n{\n\tstatic MonoClass *MethodInfo_array;\n\tMonoDomain *domain; \n\tMonoClass *startklass, *klass, *refklass;\n\tMonoArray *res;\n\tMonoMethod *method;\n\tgpointer iter;\n\tMonoObject *member;\n\tint i, len, match, nslots;\n\t/*FIXME, use MonoBitSet*/\n\tguint32 method_slots_default [8];\n\tguint32 *method_slots = NULL;\n\tgchar *mname = NULL;\n\tint (*compare_func) (const char *s1, const char *s2) = NULL;\n\tMonoVTable *array_vtable;\n\tMonoException *ex;\n\tMonoPtrArray tmp_array;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_ptr_array_init (tmp_array, 4);\n\n\tif (!MethodInfo_array) {\n\t\tMonoClass *klass = mono_array_class_get (mono_defaults.method_info_class, 1);\n\t\tmono_memory_barrier ();\n\t\tMethodInfo_array = klass;\n\t}\n\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tarray_vtable = mono_class_vtable_full (domain, MethodInfo_array, TRUE);\n\tif (type->type->byref)\n\t\treturn mono_array_new_specific (array_vtable, 0);\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\trefklass = mono_class_from_mono_type (reftype->type);\n\tlen = 0;\n\tif (name != NULL) {\n\t\tmname = mono_string_to_utf8 (name);\n\t\tcompare_func = (ignore_case) ? mono_utf8_strcasecmp : strcmp;\n\t}\n\n\t/* An optimization for calls made from Delegate:CreateDelegate () */\n\tif (klass->delegate && mname && !strcmp (mname, \"Invoke\") && (bflags == (BFLAGS_Public | BFLAGS_Static | BFLAGS_Instance))) {\n\t\tmethod = mono_get_delegate_invoke (klass);\n\t\tif (mono_loader_get_last_error ())\n\t\t\tgoto loader_error;\n\n\t\tmember = (MonoObject*)mono_method_get_object (domain, method, refklass);\n\n\t\tres = mono_array_new_specific (array_vtable, 1);\n\t\tmono_array_setref (res, 0, member);\n\t\tg_free (mname);\n\t\treturn res;\n\t}\n\n\tmono_class_setup_vtable (klass);\n\tif (klass->exception_type != MONO_EXCEPTION_NONE || mono_loader_get_last_error ())\n\t\tgoto loader_error;\n\n\tif (is_generic_parameter (type->type))\n\t\tnslots = mono_class_get_vtable_size (klass->parent);\n\telse\n\t\tnslots = MONO_CLASS_IS_INTERFACE (klass) ? mono_class_num_methods (klass) : mono_class_get_vtable_size (klass);\n\tif (nslots >= sizeof (method_slots_default) * 8) {\n\t\tmethod_slots = g_new0 (guint32, nslots / 32 + 1);\n\t} else {\n\t\tmethod_slots = method_slots_default;\n\t\tmemset (method_slots, 0, sizeof (method_slots_default));\n\t}\nhandle_parent:\n\tmono_class_setup_vtable (klass);\n\tif (klass->exception_type != MONO_EXCEPTION_NONE || mono_loader_get_last_error ())\n\t\tgoto loader_error;\t\t\n\n\titer = NULL;\n\twhile ((method = mono_class_get_methods (klass, &iter))) {\n\t\tmatch = 0;\n\t\tif (method->slot != -1) {\n\t\t\tg_assert (method->slot < nslots);\n\t\t\tif (method_slots [method->slot >> 5] & (1 << (method->slot & 0x1f)))\n\t\t\t\tcontinue;\n\t\t\tif (!(method->flags & METHOD_ATTRIBUTE_NEW_SLOT))\n\t\t\t\tmethod_slots [method->slot >> 5] |= 1 << (method->slot & 0x1f);\n\t\t}\n\n\t\tif (method->name [0] == '.' && (strcmp (method->name, \".ctor\") == 0 || strcmp (method->name, \".cctor\") == 0))\n\t\t\tcontinue;\n\t\tif ((method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else if ((bflags & BFLAGS_NonPublic) && method_nonpublic (method, (klass == startklass))) {\n\t\t\t\tmatch++;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\t\tif (method->flags & METHOD_ATTRIBUTE_STATIC) {\n\t\t\tif (bflags & BFLAGS_Static)\n\t\t\t\tif ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))\n\t\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\tmatch++;\n\t\t}\n\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (name != NULL) {\n\t\t\tif (compare_func (mname, method->name))\n\t\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tmatch = 0;\n\t\t\n\t\tmember = (MonoObject*)mono_method_get_object (domain, method, refklass);\n\t\t\n\t\tmono_ptr_array_append (tmp_array, member);\n\t}\n\tif (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))\n\t\tgoto handle_parent;\n\n\tg_free (mname);\n\tif (method_slots != method_slots_default)\n\t\tg_free (method_slots);\n\n\tres = mono_array_new_specific (array_vtable, mono_ptr_array_size (tmp_array));\n\n\tfor (i = 0; i < mono_ptr_array_size (tmp_array); ++i)\n\t\tmono_array_setref (res, i, mono_ptr_array_get (tmp_array, i));\n\n\tmono_ptr_array_destroy (tmp_array);\n\treturn res;\n\nloader_error:\n\tg_free (mname);\n\tif (method_slots != method_slots_default)\n\t\tg_free (method_slots);\n\tmono_ptr_array_destroy (tmp_array);\n\tif (klass->exception_type != MONO_EXCEPTION_NONE) {\n\t\tex = mono_class_get_exception_for_failure (klass);\n\t} else {\n\t\tex = mono_loader_error_prepare_exception (mono_loader_get_last_error ());\n\t\tmono_loader_clear_error ();\n\t}\n\tmono_raise_exception (ex);\n\treturn NULL;\n}\n\nstatic MonoArray*\nves_icall_Type_GetConstructors_internal (MonoReflectionType *type, guint32 bflags, MonoReflectionType *reftype)\n{\n\tMonoDomain *domain; \n\tstatic MonoClass *System_Reflection_ConstructorInfo;\n\tMonoClass *startklass, *klass, *refklass;\n\tMonoArray *res;\n\tMonoMethod *method;\n\tMonoObject *member;\n\tint i, match;\n\tgpointer iter = NULL;\n\tMonoPtrArray tmp_array;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_ptr_array_init (tmp_array, 4); /*FIXME, guestimating*/\n\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tif (type->type->byref)\n\t\treturn mono_array_new_cached (domain, mono_defaults.method_info_class, 0);\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\trefklass = mono_class_from_mono_type (reftype->type);\n\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\tif (!System_Reflection_ConstructorInfo)\n\t\tSystem_Reflection_ConstructorInfo = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"ConstructorInfo\");\n\n\titer = NULL;\n\twhile ((method = mono_class_get_methods (klass, &iter))) {\n\t\tmatch = 0;\n\t\tif (strcmp (method->name, \".ctor\") && strcmp (method->name, \".cctor\"))\n\t\t\tcontinue;\n\t\tif ((method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_NonPublic)\n\t\t\t\tmatch++;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\t\tif (method->flags & METHOD_ATTRIBUTE_STATIC) {\n\t\t\tif (bflags & BFLAGS_Static)\n\t\t\t\tif ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))\n\t\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\tmatch++;\n\t\t}\n\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmember = (MonoObject*)mono_method_get_object (domain, method, refklass);\n\n\t\tmono_ptr_array_append (tmp_array, member);\n\t}\n\n\tres = mono_array_new_cached (domain, System_Reflection_ConstructorInfo, mono_ptr_array_size (tmp_array));\n\n\tfor (i = 0; i < mono_ptr_array_size (tmp_array); ++i)\n\t\tmono_array_setref (res, i, mono_ptr_array_get (tmp_array, i));\n\n\tmono_ptr_array_destroy (tmp_array);\n\n\treturn res;\n}\n\nstatic guint\nproperty_hash (gconstpointer data)\n{\n\tMonoProperty *prop = (MonoProperty*)data;\n\n\treturn g_str_hash (prop->name);\n}\n\nstatic gboolean\nproperty_equal (MonoProperty *prop1, MonoProperty *prop2)\n{\n\t// Properties are hide-by-name-and-signature\n\tif (!g_str_equal (prop1->name, prop2->name))\n\t\treturn FALSE;\n\n\tif (prop1->get && prop2->get && !mono_metadata_signature_equal (mono_method_signature (prop1->get), mono_method_signature (prop2->get)))\n\t\treturn FALSE;\n\tif (prop1->set && prop2->set && !mono_metadata_signature_equal (mono_method_signature (prop1->set), mono_method_signature (prop2->set)))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\nstatic gboolean\nproperty_accessor_nonpublic (MonoMethod* accessor, gboolean start_klass)\n{\n\tif (!accessor)\n\t\treturn FALSE;\n\n\treturn method_nonpublic (accessor, start_klass);\n}\n\nstatic MonoArray*\nves_icall_Type_GetPropertiesByName (MonoReflectionType *type, MonoString *name, guint32 bflags, MonoBoolean ignore_case, MonoReflectionType *reftype)\n{\n\tMonoDomain *domain; \n\tstatic MonoClass *System_Reflection_PropertyInfo;\n\tMonoClass *startklass, *klass;\n\tMonoArray *res;\n\tMonoMethod *method;\n\tMonoProperty *prop;\n\tint i, match;\n\tguint32 flags;\n\tgchar *propname = NULL;\n\tint (*compare_func) (const char *s1, const char *s2) = NULL;\n\tgpointer iter;\n\tGHashTable *properties;\n\tMonoPtrArray tmp_array;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_ptr_array_init (tmp_array, 8); /*This the average for ASP.NET types*/\n\n\tif (!System_Reflection_PropertyInfo)\n\t\tSystem_Reflection_PropertyInfo = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"PropertyInfo\");\n\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tif (type->type->byref)\n\t\treturn mono_array_new_cached (domain, System_Reflection_PropertyInfo, 0);\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\tif (name != NULL) {\n\t\tpropname = mono_string_to_utf8 (name);\n\t\tcompare_func = (ignore_case) ? mono_utf8_strcasecmp : strcmp;\n\t}\n\n\tmono_class_setup_vtable (klass);\n\n\tproperties = g_hash_table_new (property_hash, (GEqualFunc)property_equal);\nhandle_parent:\n\tmono_class_setup_vtable (klass);\n\tif (klass->exception_type != MONO_EXCEPTION_NONE) {\n\t\tg_hash_table_destroy (properties);\n\t\tif (name != NULL)\n\t\t\tg_free (propname);\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\t}\n\n\titer = NULL;\n\twhile ((prop = mono_class_get_properties (klass, &iter))) {\n\t\tmatch = 0;\n\t\tmethod = prop->get;\n\t\tif (!method)\n\t\t\tmethod = prop->set;\n\t\tif (method)\n\t\t\tflags = method->flags;\n\t\telse\n\t\t\tflags = 0;\n\t\tif ((prop->get && ((prop->get->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)) ||\n\t\t\t(prop->set && ((prop->set->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC))) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else if (bflags & BFLAGS_NonPublic) {\n\t\t\tif (property_accessor_nonpublic(prop->get, startklass == klass) ||\n\t\t\t\tproperty_accessor_nonpublic(prop->set, startklass == klass)) {\n\t\t\t\tmatch++;\n\t\t\t}\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\t\tif (flags & METHOD_ATTRIBUTE_STATIC) {\n\t\t\tif (bflags & BFLAGS_Static)\n\t\t\t\tif ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))\n\t\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\tmatch++;\n\t\t}\n\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\n\t\tif (name != NULL) {\n\t\t\tif (compare_func (propname, prop->name))\n\t\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (g_hash_table_lookup (properties, prop))\n\t\t\tcontinue;\n\n\t\tmono_ptr_array_append (tmp_array, mono_property_get_object (domain, startklass, prop));\n\t\t\n\t\tg_hash_table_insert (properties, prop, prop);\n\t}\n\tif ((!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent)))\n\t\tgoto handle_parent;\n\n\tg_hash_table_destroy (properties);\n\tg_free (propname);\n\n\tres = mono_array_new_cached (domain, System_Reflection_PropertyInfo, mono_ptr_array_size (tmp_array));\n\tfor (i = 0; i < mono_ptr_array_size (tmp_array); ++i)\n\t\tmono_array_setref (res, i, mono_ptr_array_get (tmp_array, i));\n\n\tmono_ptr_array_destroy (tmp_array);\n\n\treturn res;\n}\n\nstatic MonoReflectionEvent *\nves_icall_MonoType_GetEvent (MonoReflectionType *type, MonoString *name, guint32 bflags)\n{\n\tMonoDomain *domain;\n\tMonoClass *klass, *startklass;\n\tgpointer iter;\n\tMonoEvent *event;\n\tMonoMethod *method;\n\tgchar *event_name;\n\tint (*compare_func) (const char *s1, const char *s2) = NULL;\n\tMONO_ARCH_SAVE_REGS;\n\n\tevent_name = mono_string_to_utf8 (name);\n\tif (type->type->byref)\n\t\treturn NULL;\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\tdomain = mono_object_domain (type);\n\n\tcompare_func = (bflags & BFLAGS_IgnoreCase) ? mono_utf8_strcasecmp : strcmp;\n\n  handle_parent:\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\titer = NULL;\n\twhile ((event = mono_class_get_events (klass, &iter))) {\n\t\tif (compare_func (event->name, event_name))\n\t\t\tcontinue;\n\n\t\tmethod = event->add;\n\t\tif (!method)\n\t\t\tmethod = event->remove;\n\t\tif (!method)\n\t\t\tmethod = event->raise;\n\t\tif (method) {\n\t\t\tif ((method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC) {\n\t\t\t\tif (!(bflags & BFLAGS_Public))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!(bflags & BFLAGS_NonPublic))\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((klass != startklass) && (method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PRIVATE)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (method->flags & METHOD_ATTRIBUTE_STATIC) {\n\t\t\t\tif (!(bflags & BFLAGS_Static))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!(bflags & BFLAGS_FlattenHierarchy) && (klass != startklass))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!(bflags & BFLAGS_Instance))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else \n\t\t\tif (!(bflags & BFLAGS_NonPublic))\n\t\t\t\tcontinue;\n\t\t\n\t\tg_free (event_name);\n\t\treturn mono_event_get_object (domain, startklass, event);\n\t}\n\n\tif (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))\n\t\tgoto handle_parent;\n\n\tg_free (event_name);\n\treturn NULL;\n}\n\nstatic MonoArray*\nves_icall_Type_GetEvents_internal (MonoReflectionType *type, guint32 bflags, MonoReflectionType *reftype)\n{\n\tMonoDomain *domain; \n\tstatic MonoClass *System_Reflection_EventInfo;\n\tMonoClass *startklass, *klass;\n\tMonoArray *res;\n\tMonoMethod *method;\n\tMonoEvent *event;\n\tint i, match;\n\tgpointer iter;\n\t\n\tMonoPtrArray tmp_array;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_ptr_array_init (tmp_array, 4);\n\n\tif (!System_Reflection_EventInfo)\n\t\tSystem_Reflection_EventInfo = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"EventInfo\");\n\n\tdomain = mono_object_domain (type);\n\tif (type->type->byref)\n\t\treturn mono_array_new_cached (domain, System_Reflection_EventInfo, 0);\n\tklass = startklass = mono_class_from_mono_type (type->type);\n\nhandle_parent:\t\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\titer = NULL;\n\twhile ((event = mono_class_get_events (klass, &iter))) {\n\t\tmatch = 0;\n\t\tmethod = event->add;\n\t\tif (!method)\n\t\t\tmethod = event->remove;\n\t\tif (!method)\n\t\t\tmethod = event->raise;\n\t\tif (method) {\n\t\t\tif ((method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC) {\n\t\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\t\tmatch++;\n\t\t\t} else if ((klass == startklass) || (method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) != METHOD_ATTRIBUTE_PRIVATE) {\n\t\t\t\tif (bflags & BFLAGS_NonPublic)\n\t\t\t\t\tmatch++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tif (bflags & BFLAGS_NonPublic)\n\t\t\t\tmatch ++;\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmatch = 0;\n\t\tif (method) {\n\t\t\tif (method->flags & METHOD_ATTRIBUTE_STATIC) {\n\t\t\t\tif (bflags & BFLAGS_Static)\n\t\t\t\t\tif ((bflags & BFLAGS_FlattenHierarchy) || (klass == startklass))\n\t\t\t\t\t\tmatch++;\n\t\t\t} else {\n\t\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\t\tmatch++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tif (bflags & BFLAGS_Instance)\n\t\t\t\tmatch ++;\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmono_ptr_array_append (tmp_array, mono_event_get_object (domain, startklass, event));\n\t}\n\tif (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))\n\t\tgoto handle_parent;\n\n\tres = mono_array_new_cached (domain, System_Reflection_EventInfo, mono_ptr_array_size (tmp_array));\n\n\tfor (i = 0; i < mono_ptr_array_size (tmp_array); ++i)\n\t\tmono_array_setref (res, i, mono_ptr_array_get (tmp_array, i));\n\n\tmono_ptr_array_destroy (tmp_array);\n\n\treturn res;\n}\n\nstatic MonoReflectionType *\nves_icall_Type_GetNestedType (MonoReflectionType *type, MonoString *name, guint32 bflags)\n{\n\tMonoDomain *domain; \n\tMonoClass *klass;\n\tMonoClass *nested;\n\tchar *str;\n\tgpointer iter;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (name == NULL)\n\t\tmono_raise_exception (mono_get_exception_argument_null (\"name\"));\n\t\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tif (type->type->byref)\n\t\treturn NULL;\n\tklass = mono_class_from_mono_type (type->type);\n\tstr = mono_string_to_utf8 (name);\n\n handle_parent:\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\t/*\n\t * If a nested type is generic, return its generic type definition.\n\t * Note that this means that the return value is essentially a\n\t * nested type of the generic type definition of @klass.\n\t *\n\t * A note in MSDN claims that a generic type definition can have\n\t * nested types that aren't generic.  In any case, the container of that\n\t * nested type would be the generic type definition.\n\t */\n\tif (klass->generic_class)\n\t\tklass = klass->generic_class->container_class;\n\n\titer = NULL;\n\twhile ((nested = mono_class_get_nested_types (klass, &iter))) {\n\t\tint match = 0;\n\t\tif ((nested->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK) == TYPE_ATTRIBUTE_NESTED_PUBLIC) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_NonPublic)\n\t\t\t\tmatch++;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tif (strcmp (nested->name, str) == 0){\n\t\t\tg_free (str);\n\t\t\treturn mono_type_get_object (domain, &nested->byval_arg);\n\t\t}\n\t}\n\tif (!(bflags & BFLAGS_DeclaredOnly) && (klass = klass->parent))\n\t\tgoto handle_parent;\n\tg_free (str);\n\treturn NULL;\n}\n\nstatic MonoArray*\nves_icall_Type_GetNestedTypes (MonoReflectionType *type, guint32 bflags)\n{\n\tMonoDomain *domain; \n\tMonoClass *klass;\n\tMonoArray *res;\n\tMonoObject *member;\n\tint i, match;\n\tMonoClass *nested;\n\tgpointer iter;\n\tMonoPtrArray tmp_array;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = ((MonoObject *)type)->vtable->domain;\n\tif (type->type->byref)\n\t\treturn mono_array_new (domain, mono_defaults.monotype_class, 0);\n\tklass = mono_class_from_mono_type (type->type);\n\tif (klass->exception_type != MONO_EXCEPTION_NONE)\n\t\tmono_raise_exception (mono_class_get_exception_for_failure (klass));\n\n\t/*\n\t * If a nested type is generic, return its generic type definition.\n\t * Note that this means that the return value is essentially the set\n\t * of nested types of the generic type definition of @klass.\n\t *\n\t * A note in MSDN claims that a generic type definition can have\n\t * nested types that aren't generic.  In any case, the container of that\n\t * nested type would be the generic type definition.\n\t */\n\tif (klass->generic_class)\n\t\tklass = klass->generic_class->container_class;\n\n\tmono_ptr_array_init (tmp_array, 1);\n\titer = NULL;\n\twhile ((nested = mono_class_get_nested_types (klass, &iter))) {\n\t\tmatch = 0;\n\t\tif ((nested->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK) == TYPE_ATTRIBUTE_NESTED_PUBLIC) {\n\t\t\tif (bflags & BFLAGS_Public)\n\t\t\t\tmatch++;\n\t\t} else {\n\t\t\tif (bflags & BFLAGS_NonPublic)\n\t\t\t\tmatch++;\n\t\t}\n\t\tif (!match)\n\t\t\tcontinue;\n\t\tmember = (MonoObject*)mono_type_get_object (domain, &nested->byval_arg);\n\t\tmono_ptr_array_append (tmp_array, member);\n\t}\n\n\tres = mono_array_new_cached (domain, mono_defaults.monotype_class, mono_ptr_array_size (tmp_array));\n\n\tfor (i = 0; i < mono_ptr_array_size (tmp_array); ++i)\n\t\tmono_array_setref (res, i, mono_ptr_array_get (tmp_array, i));\n\n\tmono_ptr_array_destroy (tmp_array);\n\n\treturn res;\n}\n\nstatic MonoReflectionType*\nves_icall_System_Reflection_Assembly_InternalGetType (MonoReflectionAssembly *assembly, MonoReflectionModule *module, MonoString *name, MonoBoolean throwOnError, MonoBoolean ignoreCase)\n{\n\tgchar *str;\n\tMonoType *type = NULL;\n\tMonoTypeNameParse info;\n\tgboolean type_resolve;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t/* On MS.NET, this does not fire a TypeResolve event */\n\ttype_resolve = TRUE;\n\tstr = mono_string_to_utf8 (name);\n\t/*g_print (\"requested type %s in %s\\n\", str, assembly->assembly->aname.name);*/\n\tif (!mono_reflection_parse_type (str, &info)) {\n\t\tg_free (str);\n\t\tmono_reflection_free_type_info (&info);\n\t\tif (throwOnError) /* uhm: this is a parse error, though... */\n\t\t\tmono_raise_exception (mono_get_exception_type_load (name, NULL));\n\t\t/*g_print (\"failed parse\\n\");*/\n\t\treturn NULL;\n\t}\n\n\tif (info.assembly.name) {\n\t\tg_free (str);\n\t\tmono_reflection_free_type_info (&info);\n\t\tif (throwOnError) {\n\t\t\t/* 1.0 and 2.0 throw different exceptions */\n\t\t\tif (mono_defaults.generic_ilist_class)\n\t\t\t\tmono_raise_exception (mono_get_exception_argument (NULL, \"Type names passed to Assembly.GetType() must not specify an assembly.\"));\n\t\t\telse\n\t\t\t\tmono_raise_exception (mono_get_exception_type_load (name, NULL));\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (module != NULL) {\n\t\tif (module->image)\n\t\t\ttype = mono_reflection_get_type (module->image, &info, ignoreCase, &type_resolve);\n\t\telse\n\t\t\ttype = NULL;\n\t}\n\telse\n\t\tif (assembly->assembly->dynamic) {\n\t\t\t/* Enumerate all modules */\n\t\t\tMonoReflectionAssemblyBuilder *abuilder = (MonoReflectionAssemblyBuilder*)assembly;\n\t\t\tint i;\n\n\t\t\ttype = NULL;\n\t\t\tif (abuilder->modules) {\n\t\t\t\tfor (i = 0; i < mono_array_length (abuilder->modules); ++i) {\n\t\t\t\t\tMonoReflectionModuleBuilder *mb = mono_array_get (abuilder->modules, MonoReflectionModuleBuilder*, i);\n\t\t\t\t\ttype = mono_reflection_get_type (&mb->dynamic_image->image, &info, ignoreCase, &type_resolve);\n\t\t\t\t\tif (type)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!type && abuilder->loaded_modules) {\n\t\t\t\tfor (i = 0; i < mono_array_length (abuilder->loaded_modules); ++i) {\n\t\t\t\t\tMonoReflectionModule *mod = mono_array_get (abuilder->loaded_modules, MonoReflectionModule*, i);\n\t\t\t\t\ttype = mono_reflection_get_type (mod->image, &info, ignoreCase, &type_resolve);\n\t\t\t\t\tif (type)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\ttype = mono_reflection_get_type (assembly->assembly->image, &info, ignoreCase, &type_resolve);\n\tg_free (str);\n\tmono_reflection_free_type_info (&info);\n\tif (!type) {\n\t\tMonoException *e = NULL;\n\t\t\n\t\tif (throwOnError)\n\t\t\te = mono_get_exception_type_load (name, NULL);\n\n\t\tif (mono_loader_get_last_error () && mono_defaults.generic_ilist_class)\n\t\t\te = mono_loader_error_prepare_exception (mono_loader_get_last_error ());\n\n\t\tmono_loader_clear_error ();\n\n\t\tif (e != NULL)\n\t\t\tmono_raise_exception (e);\n\n\t\treturn NULL;\n\t}\n\n\tif (type->type == MONO_TYPE_CLASS) {\n\t\tMonoClass *klass = mono_type_get_class (type);\n\n\t\tif (mono_is_security_manager_active () && !klass->exception_type)\n\t\t\t/* Some security problems are detected during generic vtable construction */\n\t\t\tmono_class_setup_vtable (klass);\n\t\t/* need to report exceptions ? */\n\t\tif (throwOnError && klass->exception_type) {\n\t\t\t/* report SecurityException (or others) that occured when loading the assembly */\n\t\t\tMonoException *exc = mono_class_get_exception_for_failure (klass);\n\t\t\tmono_loader_clear_error ();\n\t\t\tmono_raise_exception (exc);\n\t\t} else if (klass->exception_type == MONO_EXCEPTION_SECURITY_INHERITANCEDEMAND) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* g_print (\"got it\\n\"); */\n\treturn mono_type_get_object (mono_object_domain (assembly), type);\n}\n\nstatic gboolean\nreplace_shadow_path (MonoDomain *domain, gchar *dirname, gchar **filename)\n{\n\tgchar *content;\n\tgchar *shadow_ini_file;\n\tgsize len;\n\n\t/* Check for shadow-copied assembly */\n\tif (mono_is_shadow_copy_enabled (domain, dirname)) {\n\t\tshadow_ini_file = g_build_filename (dirname, \"__AssemblyInfo__.ini\", NULL);\n\t\tcontent = NULL;\n\t\tif (!g_file_get_contents (shadow_ini_file, &content, &len, NULL) ||\n\t\t\t!g_file_test (content, G_FILE_TEST_IS_REGULAR)) {\n\t\t\tif (content) {\n\t\t\t\tg_free (content);\n\t\t\t\tcontent = NULL;\n\t\t\t}\n\t\t}\n\t\tg_free (shadow_ini_file);\n\t\tif (content != NULL) {\n\t\t\tif (*filename)\n\t\t\t\tg_free (*filename);\n\t\t\t*filename = content;\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\nstatic MonoString *\nves_icall_System_Reflection_Assembly_get_code_base (MonoReflectionAssembly *assembly, MonoBoolean escaped)\n{\n\tMonoDomain *domain = mono_object_domain (assembly); \n\tMonoAssembly *mass = assembly->assembly;\n\tMonoString *res = NULL;\n\tgchar *uri;\n\tgchar *absolute;\n\tgchar *dirname;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (g_path_is_absolute (mass->image->name)) {\n\t\tabsolute = g_strdup (mass->image->name);\n\t\tdirname = g_path_get_dirname (absolute);\n\t} else {\n\t\tabsolute = g_build_filename (mass->basedir, mass->image->name, NULL);\n\t\tdirname = g_strdup (mass->basedir);\n\t}\n\n\treplace_shadow_path (domain, dirname, &absolute);\n\tg_free (dirname);\n#if PLATFORM_WIN32\n\t{\n\t\tgint i;\n\t\tfor (i = strlen (absolute) - 1; i >= 0; i--)\n\t\t\tif (absolute [i] == '\\\\')\n\t\t\t\tabsolute [i] = '/';\n\t}\n#endif\n\tif (escaped) {\n\t\turi = g_filename_to_uri (absolute, NULL, NULL);\n\t} else {\n\t\tconst char *prepend = \"file://\";\n#if PLATFORM_WIN32\n\t\tif (*absolute == '/' && *(absolute + 1) == '/') {\n\t\t\tprepend = \"file:\";\n\t\t} else {\n\t\t\tprepend = \"file:///\";\n\t\t}\n#endif\n\t\turi = g_strconcat (prepend, absolute, NULL);\n\t}\n\n\tif (uri) {\n\t\tres = mono_string_new (domain, uri);\n\t\tg_free (uri);\n\t}\n\tg_free (absolute);\n\treturn res;\n}\n\nstatic MonoBoolean\nves_icall_System_Reflection_Assembly_get_global_assembly_cache (MonoReflectionAssembly *assembly)\n{\n\tMonoAssembly *mass = assembly->assembly;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mass->in_gac;\n}\n\nstatic MonoReflectionAssembly*\nves_icall_System_Reflection_Assembly_load_with_partial_name (MonoString *mname, MonoObject *evidence)\n{\n\tgchar *name;\n\tMonoAssembly *res;\n\tMonoImageOpenStatus status;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tname = mono_string_to_utf8 (mname);\n\tres = mono_assembly_load_with_partial_name (name, &status);\n\n\tg_free (name);\n\n\tif (res == NULL)\n\t\treturn NULL;\n\treturn mono_assembly_get_object (mono_domain_get (), res);\n}\n\nstatic MonoString *\nves_icall_System_Reflection_Assembly_get_location (MonoReflectionAssembly *assembly)\n{\n\tMonoDomain *domain = mono_object_domain (assembly); \n\tMonoString *res;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tres = mono_string_new (domain, mono_image_get_filename (assembly->assembly->image));\n\n\treturn res;\n}\n\nstatic MonoBoolean\nves_icall_System_Reflection_Assembly_get_ReflectionOnly (MonoReflectionAssembly *assembly)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn assembly->assembly->ref_only;\n}\n\nstatic MonoString *\nves_icall_System_Reflection_Assembly_InternalImageRuntimeVersion (MonoReflectionAssembly *assembly)\n{\n\tMonoDomain *domain = mono_object_domain (assembly); \n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_string_new (domain, assembly->assembly->image->version);\n}\n\nstatic MonoReflectionMethod*\nves_icall_System_Reflection_Assembly_get_EntryPoint (MonoReflectionAssembly *assembly) \n{\n\tguint32 token = mono_image_get_entry_point (assembly->assembly->image);\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!token)\n\t\treturn NULL;\n\treturn mono_method_get_object (mono_object_domain (assembly), mono_get_method (assembly->assembly->image, token, NULL), NULL);\n}\n\nstatic MonoReflectionModule*\nves_icall_System_Reflection_Assembly_GetManifestModuleInternal (MonoReflectionAssembly *assembly) \n{\n\treturn mono_module_get_object (mono_object_domain (assembly), assembly->assembly->image);\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Assembly_GetManifestResourceNames (MonoReflectionAssembly *assembly) \n{\n\tMonoTableInfo *table = &assembly->assembly->image->tables [MONO_TABLE_MANIFESTRESOURCE];\n\tMonoArray *result = mono_array_new (mono_object_domain (assembly), mono_defaults.string_class, table->rows);\n\tint i;\n\tconst char *val;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tval = mono_metadata_string_heap (assembly->assembly->image, mono_metadata_decode_row_col (table, i, MONO_MANIFEST_NAME));\n\t\tmono_array_setref (result, i, mono_string_new (mono_object_domain (assembly), val));\n\t}\n\treturn result;\n}\n\nstatic MonoObject*\ncreate_version (MonoDomain *domain, guint32 major, guint32 minor, guint32 build, guint32 revision)\n{\n\tstatic MonoClass *System_Version = NULL;\n\tstatic MonoMethod *create_version = NULL;\n\tMonoObject *result;\n\tgpointer args [4];\n\t\n\tif (!System_Version) {\n\t\tSystem_Version = mono_class_from_name (mono_defaults.corlib, \"System\", \"Version\");\n\t\tg_assert (System_Version);\n\t}\n\n\tif (!create_version) {\n\t\tMonoMethodDesc *desc = mono_method_desc_new (\":.ctor(int,int,int,int)\", FALSE);\n\t\tcreate_version = mono_method_desc_search_in_class (desc, System_Version);\n\t\tg_assert (create_version);\n\t\tmono_method_desc_free (desc);\n\t}\n\n\targs [0] = &major;\n\targs [1] = &minor;\n\targs [2] = &build;\n\targs [3] = &revision;\n\tresult = mono_object_new (domain, System_Version);\n\tmono_runtime_invoke (create_version, result, args, NULL);\n\n\treturn result;\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Assembly_GetReferencedAssemblies (MonoReflectionAssembly *assembly) \n{\n\tstatic MonoClass *System_Reflection_AssemblyName;\n\tMonoArray *result;\n\tMonoDomain *domain = mono_object_domain (assembly);\n\tint i, count = 0;\n\tstatic MonoMethod *create_culture = NULL;\n\tMonoImage *image = assembly->assembly->image;\n\tMonoTableInfo *t;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!System_Reflection_AssemblyName)\n\t\tSystem_Reflection_AssemblyName = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"AssemblyName\");\n\n\tt = &assembly->assembly->image->tables [MONO_TABLE_ASSEMBLYREF];\n\tcount = t->rows;\n\n\tresult = mono_array_new (domain, System_Reflection_AssemblyName, count);\n\n\tif (count > 0 && !create_culture) {\n\t\tMonoMethodDesc *desc = mono_method_desc_new (\n\t\t\t\"System.Globalization.CultureInfo:CreateCulture(string,bool)\", TRUE);\n\t\tcreate_culture = mono_method_desc_search_in_image (desc, mono_defaults.corlib);\n\t\tg_assert (create_culture);\n\t\tmono_method_desc_free (desc);\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionAssemblyName *aname;\n\t\tguint32 cols [MONO_ASSEMBLYREF_SIZE];\n\n\t\tmono_metadata_decode_row (t, i, cols, MONO_ASSEMBLYREF_SIZE);\n\n\t\taname = (MonoReflectionAssemblyName *) mono_object_new (\n\t\t\tdomain, System_Reflection_AssemblyName);\n\n\t\tMONO_OBJECT_SETREF (aname, name, mono_string_new (domain, mono_metadata_string_heap (image, cols [MONO_ASSEMBLYREF_NAME])));\n\n\t\taname->major = cols [MONO_ASSEMBLYREF_MAJOR_VERSION];\n\t\taname->minor = cols [MONO_ASSEMBLYREF_MINOR_VERSION];\n\t\taname->build = cols [MONO_ASSEMBLYREF_BUILD_NUMBER];\n\t\taname->revision = cols [MONO_ASSEMBLYREF_REV_NUMBER];\n\t\taname->flags = cols [MONO_ASSEMBLYREF_FLAGS];\n\t\taname->versioncompat = 1; /* SameMachine (default) */\n\t\taname->hashalg = ASSEMBLY_HASH_SHA1; /* SHA1 (default) */\n\t\tMONO_OBJECT_SETREF (aname, version, create_version (domain, aname->major, aname->minor, aname->build, aname->revision));\n\n\t\tif (create_culture) {\n\t\t\tgpointer args [2];\n\t\t\tMonoBoolean assembly_ref = 1;\n\t\t\targs [0] = mono_string_new (domain, mono_metadata_string_heap (image, cols [MONO_ASSEMBLYREF_CULTURE]));\n\t\t\targs [1] = &assembly_ref;\n\t\t\tMONO_OBJECT_SETREF (aname, cultureInfo, mono_runtime_invoke (create_culture, NULL, args, NULL));\n\t\t}\n\t\t\n\t\tif (cols [MONO_ASSEMBLYREF_PUBLIC_KEY]) {\n\t\t\tconst gchar *pkey_ptr = mono_metadata_blob_heap (image, cols [MONO_ASSEMBLYREF_PUBLIC_KEY]);\n\t\t\tguint32 pkey_len = mono_metadata_decode_blob_size (pkey_ptr, &pkey_ptr);\n\n\t\t\tif ((cols [MONO_ASSEMBLYREF_FLAGS] & ASSEMBLYREF_FULL_PUBLIC_KEY_FLAG)) {\n\t\t\t\t/* public key token isn't copied - the class library will \n\t\t   \t\tautomatically generate it from the public key if required */\n\t\t\t\tMONO_OBJECT_SETREF (aname, publicKey, mono_array_new (domain, mono_defaults.byte_class, pkey_len));\n\t\t\t\tmemcpy (mono_array_addr (aname->publicKey, guint8, 0), pkey_ptr, pkey_len);\n\t\t\t} else {\n\t\t\t\tMONO_OBJECT_SETREF (aname, keyToken, mono_array_new (domain, mono_defaults.byte_class, pkey_len));\n\t\t\t\tmemcpy (mono_array_addr (aname->keyToken, guint8, 0), pkey_ptr, pkey_len);\n\t\t\t}\n\t\t} else {\n\t\t\tMONO_OBJECT_SETREF (aname, keyToken, mono_array_new (domain, mono_defaults.byte_class, 0));\n\t\t}\n\t\t\n\t\t/* note: this function doesn't return the codebase on purpose (i.e. it can\n\t\t         be used under partial trust as path information isn't present). */\n\n\t\tmono_array_setref (result, i, aname);\n\t}\n\treturn result;\n}\n\ntypedef struct {\n\tMonoArray *res;\n\tint idx;\n} NameSpaceInfo;\n\nstatic void\nforeach_namespace (const char* key, gconstpointer val, NameSpaceInfo *info)\n{\n\tMonoString *name = mono_string_new (mono_object_domain (info->res), key);\n\n\tmono_array_setref (info->res, info->idx, name);\n\tinfo->idx++;\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Assembly_GetNamespaces (MonoReflectionAssembly *assembly) \n{\n\tMonoImage *img = assembly->assembly->image;\n\tMonoArray *res;\n\tNameSpaceInfo info;\n\tint len;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_image_lock (img);\n\tmono_image_init_name_cache (img);\n\nRETRY_LEN:\n\tlen = g_hash_table_size (img->name_cache);\n\tmono_image_unlock (img);\n\n\t/*we can't create objects holding the image lock */\n\tres = mono_array_new (mono_object_domain (assembly), mono_defaults.string_class, len);\n\n\tmono_image_lock (img);\n\t/*len might have changed, create a new array*/\n\tif (len != g_hash_table_size (img->name_cache))\n\t\tgoto RETRY_LEN;\n\n\tinfo.res = res;\n\tinfo.idx = 0;\n\tg_hash_table_foreach (img->name_cache, (GHFunc)foreach_namespace, &info);\n\tmono_image_unlock (img);\n\n\treturn res;\n}\n\n/* move this in some file in mono/util/ */\nstatic char *\ng_concat_dir_and_file (const char *dir, const char *file)\n{\n\tg_return_val_if_fail (dir != NULL, NULL);\n\tg_return_val_if_fail (file != NULL, NULL);\n\n        /*\n\t * If the directory name doesn't have a / on the end, we need\n\t * to add one so we get a proper path to the file\n\t */\n\tif (dir [strlen(dir) - 1] != G_DIR_SEPARATOR)\n\t\treturn g_strconcat (dir, G_DIR_SEPARATOR_S, file, NULL);\n\telse\n\t\treturn g_strconcat (dir, file, NULL);\n}\n\nstatic void *\nves_icall_System_Reflection_Assembly_GetManifestResourceInternal (MonoReflectionAssembly *assembly, MonoString *name, gint32 *size, MonoReflectionModule **ref_module) \n{\n\tchar *n = mono_string_to_utf8 (name);\n\tMonoTableInfo *table = &assembly->assembly->image->tables [MONO_TABLE_MANIFESTRESOURCE];\n\tguint32 i;\n\tguint32 cols [MONO_MANIFEST_SIZE];\n\tguint32 impl, file_idx;\n\tconst char *val;\n\tMonoImage *module;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tmono_metadata_decode_row (table, i, cols, MONO_MANIFEST_SIZE);\n\t\tval = mono_metadata_string_heap (assembly->assembly->image, cols [MONO_MANIFEST_NAME]);\n\t\tif (strcmp (val, n) == 0)\n\t\t\tbreak;\n\t}\n\tg_free (n);\n\tif (i == table->rows)\n\t\treturn NULL;\n\t/* FIXME */\n\timpl = cols [MONO_MANIFEST_IMPLEMENTATION];\n\tif (impl) {\n\t\t/*\n\t\t * this code should only be called after obtaining the \n\t\t * ResourceInfo and handling the other cases.\n\t\t */\n\t\tg_assert ((impl & MONO_IMPLEMENTATION_MASK) == MONO_IMPLEMENTATION_FILE);\n\t\tfile_idx = impl >> MONO_IMPLEMENTATION_BITS;\n\n\t\tmodule = mono_image_load_file_for_image (assembly->assembly->image, file_idx);\n\t\tif (!module)\n\t\t\treturn NULL;\n\t}\n\telse\n\t\tmodule = assembly->assembly->image;\n\n\tmono_gc_wbarrier_generic_store (ref_module, (MonoObject*) mono_module_get_object (mono_domain_get (), module));\n\n\treturn (void*)mono_image_get_resource (module, cols [MONO_MANIFEST_OFFSET], (guint32*)size);\n}\n\nstatic gboolean\nves_icall_System_Reflection_Assembly_GetManifestResourceInfoInternal (MonoReflectionAssembly *assembly, MonoString *name, MonoManifestResourceInfo *info)\n{\n\tMonoTableInfo *table = &assembly->assembly->image->tables [MONO_TABLE_MANIFESTRESOURCE];\n\tint i;\n\tguint32 cols [MONO_MANIFEST_SIZE];\n\tguint32 file_cols [MONO_FILE_SIZE];\n\tconst char *val;\n\tchar *n;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tn = mono_string_to_utf8 (name);\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tmono_metadata_decode_row (table, i, cols, MONO_MANIFEST_SIZE);\n\t\tval = mono_metadata_string_heap (assembly->assembly->image, cols [MONO_MANIFEST_NAME]);\n\t\tif (strcmp (val, n) == 0)\n\t\t\tbreak;\n\t}\n\tg_free (n);\n\tif (i == table->rows)\n\t\treturn FALSE;\n\n\tif (!cols [MONO_MANIFEST_IMPLEMENTATION]) {\n\t\tinfo->location = RESOURCE_LOCATION_EMBEDDED | RESOURCE_LOCATION_IN_MANIFEST;\n\t}\n\telse {\n\t\tswitch (cols [MONO_MANIFEST_IMPLEMENTATION] & MONO_IMPLEMENTATION_MASK) {\n\t\tcase MONO_IMPLEMENTATION_FILE:\n\t\t\ti = cols [MONO_MANIFEST_IMPLEMENTATION] >> MONO_IMPLEMENTATION_BITS;\n\t\t\ttable = &assembly->assembly->image->tables [MONO_TABLE_FILE];\n\t\t\tmono_metadata_decode_row (table, i - 1, file_cols, MONO_FILE_SIZE);\n\t\t\tval = mono_metadata_string_heap (assembly->assembly->image, file_cols [MONO_FILE_NAME]);\n\t\t\tMONO_OBJECT_SETREF (info, filename, mono_string_new (mono_object_domain (assembly), val));\n\t\t\tif (file_cols [MONO_FILE_FLAGS] && FILE_CONTAINS_NO_METADATA)\n\t\t\t\tinfo->location = 0;\n\t\t\telse\n\t\t\t\tinfo->location = RESOURCE_LOCATION_EMBEDDED;\n\t\t\tbreak;\n\n\t\tcase MONO_IMPLEMENTATION_ASSEMBLYREF:\n\t\t\ti = cols [MONO_MANIFEST_IMPLEMENTATION] >> MONO_IMPLEMENTATION_BITS;\n\t\t\tmono_assembly_load_reference (assembly->assembly->image, i - 1);\n\t\t\tif (assembly->assembly->image->references [i - 1] == (gpointer)-1) {\n\t\t\t\tchar *msg = g_strdup_printf (\"Assembly %d referenced from assembly %s not found \", i - 1, assembly->assembly->image->name);\n\t\t\t\tMonoException *ex = mono_get_exception_file_not_found2 (msg, NULL);\n\t\t\t\tg_free (msg);\n\t\t\t\tmono_raise_exception (ex);\n\t\t\t}\n\t\t\tMONO_OBJECT_SETREF (info, assembly, mono_assembly_get_object (mono_domain_get (), assembly->assembly->image->references [i - 1]));\n\n\t\t\t/* Obtain info recursively */\n\t\t\tves_icall_System_Reflection_Assembly_GetManifestResourceInfoInternal (info->assembly, name, info);\n\t\t\tinfo->location |= RESOURCE_LOCATION_ANOTHER_ASSEMBLY;\n\t\t\tbreak;\n\n\t\tcase MONO_IMPLEMENTATION_EXP_TYPE:\n\t\t\tg_assert_not_reached ();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic MonoObject*\nves_icall_System_Reflection_Assembly_GetFilesInternal (MonoReflectionAssembly *assembly, MonoString *name, MonoBoolean resource_modules) \n{\n\tMonoTableInfo *table = &assembly->assembly->image->tables [MONO_TABLE_FILE];\n\tMonoArray *result = NULL;\n\tint i, count;\n\tconst char *val;\n\tchar *n;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t/* check hash if needed */\n\tif (name) {\n\t\tn = mono_string_to_utf8 (name);\n\t\tfor (i = 0; i < table->rows; ++i) {\n\t\t\tval = mono_metadata_string_heap (assembly->assembly->image, mono_metadata_decode_row_col (table, i, MONO_FILE_NAME));\n\t\t\tif (strcmp (val, n) == 0) {\n\t\t\t\tMonoString *fn;\n\t\t\t\tg_free (n);\n\t\t\t\tn = g_concat_dir_and_file (assembly->assembly->basedir, val);\n\t\t\t\tfn = mono_string_new (mono_object_domain (assembly), n);\n\t\t\t\tg_free (n);\n\t\t\t\treturn (MonoObject*)fn;\n\t\t\t}\n\t\t}\n\t\tg_free (n);\n\t\treturn NULL;\n\t}\n\n\tcount = 0;\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tif (resource_modules || !(mono_metadata_decode_row_col (table, i, MONO_FILE_FLAGS) & FILE_CONTAINS_NO_METADATA))\n\t\t\tcount ++;\n\t}\n\n\tresult = mono_array_new (mono_object_domain (assembly), mono_defaults.string_class, count);\n\n\tcount = 0;\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tif (resource_modules || !(mono_metadata_decode_row_col (table, i, MONO_FILE_FLAGS) & FILE_CONTAINS_NO_METADATA)) {\n\t\t\tval = mono_metadata_string_heap (assembly->assembly->image, mono_metadata_decode_row_col (table, i, MONO_FILE_NAME));\n\t\t\tn = g_concat_dir_and_file (assembly->assembly->basedir, val);\n\t\t\tmono_array_setref (result, count, mono_string_new (mono_object_domain (assembly), n));\n\t\t\tg_free (n);\n\t\t\tcount ++;\n\t\t}\n\t}\n\treturn (MonoObject*)result;\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Assembly_GetModulesInternal (MonoReflectionAssembly *assembly)\n{\n\tMonoDomain *domain = mono_domain_get();\n\tMonoArray *res;\n\tMonoClass *klass;\n\tint i, j, file_count = 0;\n\tMonoImage **modules;\n\tguint32 module_count, real_module_count;\n\tMonoTableInfo *table;\n\tguint32 cols [MONO_FILE_SIZE];\n\tMonoImage *image = assembly->assembly->image;\n\n\tg_assert (image != NULL);\n\tg_assert (!assembly->assembly->dynamic);\n\n\ttable = &image->tables [MONO_TABLE_FILE];\n\tfile_count = table->rows;\n\n\tmodules = image->modules;\n\tmodule_count = image->module_count;\n\n\treal_module_count = 0;\n\tfor (i = 0; i < module_count; ++i)\n\t\tif (modules [i])\n\t\t\treal_module_count ++;\n\n\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"Module\");\n\tres = mono_array_new (domain, klass, 1 + real_module_count + file_count);\n\n\tmono_array_setref (res, 0, mono_module_get_object (domain, image));\n\tj = 1;\n\tfor (i = 0; i < module_count; ++i)\n\t\tif (modules [i]) {\n\t\t\tmono_array_setref (res, j, mono_module_get_object (domain, modules[i]));\n\t\t\t++j;\n\t\t}\n\n\tfor (i = 0; i < file_count; ++i, ++j) {\n\t\tmono_metadata_decode_row (table, i, cols, MONO_FILE_SIZE);\n\t\tif (cols [MONO_FILE_FLAGS] && FILE_CONTAINS_NO_METADATA)\n\t\t\tmono_array_setref (res, j, mono_module_file_get_object (domain, image, i));\n\t\telse {\n\t\t\tMonoImage *m = mono_image_load_file_for_image (image, i + 1);\n\t\t\tif (!m) {\n\t\t\t\tMonoString *fname = mono_string_new (mono_domain_get (), mono_metadata_string_heap (image, cols [MONO_FILE_NAME]));\n\t\t\t\tmono_raise_exception (mono_get_exception_file_not_found2 (NULL, fname));\n\t\t\t}\n\t\t\tmono_array_setref (res, j, mono_module_get_object (domain, m));\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic MonoReflectionMethod*\nves_icall_GetCurrentMethod (void) \n{\n\tMonoMethod *m = mono_method_get_last_managed ();\n\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_method_get_object (mono_domain_get (), m, NULL);\n}\n\n\nstatic MonoMethod*\nmono_method_get_equivalent_method (MonoMethod *method, MonoClass *klass)\n{\n\tint offset = -1, i;\n\tif (method->is_inflated && ((MonoMethodInflated*)method)->context.method_inst) {\n\t\tMonoMethodInflated *inflated = (MonoMethodInflated*)method;\n\t\t//method is inflated, we should inflate it on the other class\n\t\tMonoGenericContext ctx;\n\t\tctx.method_inst = inflated->context.method_inst;\n\t\tctx.class_inst = inflated->context.class_inst;\n\t\tif (klass->generic_class)\n\t\t\tctx.class_inst = klass->generic_class->context.class_inst;\n\t\telse if (klass->generic_container)\n\t\t\tctx.class_inst = klass->generic_container->context.class_inst;\n\t\treturn mono_class_inflate_generic_method_full (inflated->declaring, klass, &ctx);\n\t}\n\n\tmono_class_setup_methods (method->klass);\n\tif (method->klass->exception_type)\n\t\treturn NULL;\n\tfor (i = 0; i < method->klass->method.count; ++i) {\n\t\tif (method->klass->methods [i] == method) {\n\t\t\toffset = i;\n\t\t\tbreak;\n\t\t}\t\n\t}\n\tmono_class_setup_methods (klass);\n\tif (klass->exception_type)\n\t\treturn NULL;\n\tg_assert (offset >= 0 && offset < klass->method.count);\n\treturn klass->methods [offset];\n}\n\nstatic MonoReflectionMethod*\nves_icall_System_Reflection_MethodBase_GetMethodFromHandleInternalType (MonoMethod *method, MonoType *type)\n{\n\tMonoClass *klass;\n\tif (type) {\n\t\tklass = mono_class_from_mono_type (type);\n\t\tif (mono_class_get_generic_type_definition (method->klass) != mono_class_get_generic_type_definition (klass)) \n\t\t\treturn NULL;\n\t\tif (method->klass != klass) {\n\t\t\tmethod = mono_method_get_equivalent_method (method, klass);\n\t\t\tif (!method)\n\t\t\t\treturn NULL;\n\t\t}\n\t} else\n\t\tklass = method->klass;\n\treturn mono_method_get_object (mono_domain_get (), method, klass);\n}\n\nstatic MonoReflectionMethod*\nves_icall_System_Reflection_MethodBase_GetMethodFromHandleInternal (MonoMethod *method)\n{\n\treturn mono_method_get_object (mono_domain_get (), method, NULL);\n}\n\nstatic MonoReflectionMethodBody*\nves_icall_System_Reflection_MethodBase_GetMethodBodyInternal (MonoMethod *method)\n{\n\treturn mono_method_body_get_object (mono_domain_get (), method);\n}\n\nstatic MonoReflectionAssembly*\nves_icall_System_Reflection_Assembly_GetExecutingAssembly (void)\n{\n\tMonoMethod *dest = NULL;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_stack_walk_no_il (get_executing, &dest);\n\treturn mono_assembly_get_object (mono_domain_get (), dest->klass->image->assembly);\n}\n\n\nstatic MonoReflectionAssembly*\nves_icall_System_Reflection_Assembly_GetEntryAssembly (void)\n{\n\tMonoDomain* domain = mono_domain_get ();\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!domain->entry_assembly)\n\t\treturn NULL;\n\n\treturn mono_assembly_get_object (domain, domain->entry_assembly);\n}\n\nstatic MonoReflectionAssembly*\nves_icall_System_Reflection_Assembly_GetCallingAssembly (void)\n{\n\tMonoMethod *m;\n\tMonoMethod *dest;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tdest = NULL;\n\tmono_stack_walk_no_il (get_executing, &dest);\n\tm = dest;\n\tmono_stack_walk_no_il (get_caller, &dest);\n\tif (!dest)\n\t\tdest = m;\n\treturn mono_assembly_get_object (mono_domain_get (), dest->klass->image->assembly);\n}\n\nstatic MonoString *\nves_icall_System_MonoType_getFullName (MonoReflectionType *object, gboolean full_name,\n\t\t\t\t       gboolean assembly_qualified)\n{\n\tMonoDomain *domain = mono_object_domain (object); \n\tMonoTypeNameFormat format;\n\tMonoString *res;\n\tgchar *name;\n\n\tMONO_ARCH_SAVE_REGS;\n\tif (full_name)\n\t\tformat = assembly_qualified ?\n\t\t\tMONO_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED :\n\t\t\tMONO_TYPE_NAME_FORMAT_FULL_NAME;\n\telse\n\t\tformat = MONO_TYPE_NAME_FORMAT_REFLECTION;\n \n\tname = mono_type_get_name_full (object->type, format);\n\tif (!name)\n\t\treturn NULL;\n\n\tif (full_name && (object->type->type == MONO_TYPE_VAR || object->type->type == MONO_TYPE_MVAR)) {\n\t\tg_free (name);\n\t\treturn NULL;\n\t}\n\n\tres = mono_string_new (domain, name);\n\tg_free (name);\n\n\treturn res;\n}\n\nstatic void\nfill_reflection_assembly_name (MonoDomain *domain, MonoReflectionAssemblyName *aname, MonoAssemblyName *name, const char *absolute, gboolean by_default_version, gboolean default_publickey, gboolean default_token)\n{\n\tstatic MonoMethod *create_culture = NULL;\n\tgpointer args [2];\n\tguint32 pkey_len;\n\tconst char *pkey_ptr;\n\tgchar *codebase;\n\tMonoBoolean assembly_ref = 0;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_OBJECT_SETREF (aname, name, mono_string_new (domain, name->name));\n\taname->major = name->major;\n\taname->minor = name->minor;\n\taname->build = name->build;\n\taname->flags = name->flags;\n\taname->revision = name->revision;\n\taname->hashalg = name->hash_alg;\n\taname->versioncompat = 1; /* SameMachine (default) */\n\n\tif (by_default_version)\n\t\tMONO_OBJECT_SETREF (aname, version, create_version (domain, name->major, name->minor, name->build, name->revision));\n\n\tcodebase = NULL;\n\tif (absolute != NULL && *absolute != '\\0') {\n\t\tconst gchar *prepend = \"file://\";\n\t\tgchar *result;\n\n\t\tcodebase = g_strdup (absolute);\n\n#if PLATFORM_WIN32\n\t\t{\n\t\t\tgint i;\n\t\t\tfor (i = strlen (codebase) - 1; i >= 0; i--)\n\t\t\t\tif (codebase [i] == '\\\\')\n\t\t\t\t\tcodebase [i] = '/';\n\n\t\t\tif (*codebase == '/' && *(codebase + 1) == '/') {\n\t\t\t\tprepend = \"file:\";\n\t\t\t} else {\n\t\t\t\tprepend = \"file:///\";\n\t\t\t}\n\t\t}\n#endif\n\t\tresult = g_strconcat (prepend, codebase, NULL);\n\t\tg_free (codebase);\n\t\tcodebase = result;\n\t}\n\n\tif (codebase) {\n\t\tMONO_OBJECT_SETREF (aname, codebase, mono_string_new (domain, codebase));\n\t\tg_free (codebase);\n\t}\n\n\tif (!create_culture) {\n\t\tMonoMethodDesc *desc = mono_method_desc_new (\"System.Globalization.CultureInfo:CreateCulture(string,bool)\", TRUE);\n\t\tcreate_culture = mono_method_desc_search_in_image (desc, mono_defaults.corlib);\n\t\tg_assert (create_culture);\n\t\tmono_method_desc_free (desc);\n\t}\n\n\tif (name->culture) {\n\t\targs [0] = mono_string_new (domain, name->culture);\n\t\targs [1] = &assembly_ref;\n\t\tMONO_OBJECT_SETREF (aname, cultureInfo, mono_runtime_invoke (create_culture, NULL, args, NULL));\n\t}\n\n\tif (name->public_key) {\n\t\tpkey_ptr = (char*)name->public_key;\n\t\tpkey_len = mono_metadata_decode_blob_size (pkey_ptr, &pkey_ptr);\n\n\t\tMONO_OBJECT_SETREF (aname, publicKey, mono_array_new (domain, mono_defaults.byte_class, pkey_len));\n\t\tmemcpy (mono_array_addr (aname->publicKey, guint8, 0), pkey_ptr, pkey_len);\n\t\taname->flags |= ASSEMBLYREF_FULL_PUBLIC_KEY_FLAG;\n\t} else if (default_publickey) {\n\t\tMONO_OBJECT_SETREF (aname, publicKey, mono_array_new (domain, mono_defaults.byte_class, 0));\n\t\taname->flags |= ASSEMBLYREF_FULL_PUBLIC_KEY_FLAG;\n\t}\n\n\t/* MonoAssemblyName keeps the public key token as an hexadecimal string */\n\tif (name->public_key_token [0]) {\n\t\tint i, j;\n\t\tchar *p;\n\n\t\tMONO_OBJECT_SETREF (aname, keyToken, mono_array_new (domain, mono_defaults.byte_class, 8));\n\t\tp = mono_array_addr (aname->keyToken, char, 0);\n\n\t\tfor (i = 0, j = 0; i < 8; i++) {\n\t\t\t*p = g_ascii_xdigit_value (name->public_key_token [j++]) << 4;\n\t\t\t*p |= g_ascii_xdigit_value (name->public_key_token [j++]);\n\t\t\tp++;\n\t\t}\n\t} else if (default_token) {\n\t\tMONO_OBJECT_SETREF (aname, keyToken, mono_array_new (domain, mono_defaults.byte_class, 0));\n\t}\n}\n\nstatic MonoString *\nves_icall_System_Reflection_Assembly_get_fullName (MonoReflectionAssembly *assembly)\n{\n\tMonoDomain *domain = mono_object_domain (assembly); \n\tMonoAssembly *mass = assembly->assembly;\n\tMonoString *res;\n\tgchar *name;\n\n\tname = g_strdup_printf (\n\t\t\"%s, Version=%d.%d.%d.%d, Culture=%s, PublicKeyToken=%s%s\",\n\t\tmass->aname.name,\n\t\tmass->aname.major, mass->aname.minor, mass->aname.build, mass->aname.revision,\n\t\tmass->aname.culture && *mass->aname.culture? mass->aname.culture: \"neutral\",\n\t\tmass->aname.public_key_token [0] ? (char *)mass->aname.public_key_token : \"null\",\n\t\t(mass->aname.flags & ASSEMBLYREF_RETARGETABLE_FLAG) ? \", Retargetable=Yes\" : \"\");\n\n\tres = mono_string_new (domain, name);\n\tg_free (name);\n\n\treturn res;\n}\n\nstatic void\nves_icall_System_Reflection_Assembly_FillName (MonoReflectionAssembly *assembly, MonoReflectionAssemblyName *aname)\n{\n\tgchar *absolute;\n\tMonoAssembly *mass = assembly->assembly;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (g_path_is_absolute (mass->image->name)) {\n\t\tfill_reflection_assembly_name (mono_object_domain (assembly),\n\t\t\taname, &mass->aname, mass->image->name, TRUE,\n\t\t\tTRUE, mono_framework_version () >= 2);\n\t\treturn;\n\t}\n\tabsolute = g_build_filename (mass->basedir, mass->image->name, NULL);\n\n\tfill_reflection_assembly_name (mono_object_domain (assembly),\n\t\taname, &mass->aname, absolute, TRUE, TRUE,\n\t\tmono_framework_version () >= 2);\n\n\tg_free (absolute);\n}\n\nstatic void\nves_icall_System_Reflection_Assembly_InternalGetAssemblyName (MonoString *fname, MonoReflectionAssemblyName *aname)\n{\n\tchar *filename;\n\tMonoImageOpenStatus status = MONO_IMAGE_OK;\n\tgboolean res;\n\tMonoImage *image;\n\tMonoAssemblyName name;\n\tchar *dirname\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tfilename = mono_string_to_utf8 (fname);\n\n\tdirname = g_path_get_dirname (filename);\n\treplace_shadow_path (mono_domain_get (), dirname, &filename);\n\tg_free (dirname);\n\n\timage = mono_image_open (filename, &status);\n\n\tif (!image){\n\t\tMonoException *exc;\n\n\t\tg_free (filename);\n\t\tif (status == MONO_IMAGE_IMAGE_INVALID)\n\t\t\texc = mono_get_exception_bad_image_format2 (NULL, fname);\n\t\telse\n\t\t\texc = mono_get_exception_file_not_found2 (NULL, fname);\n\t\tmono_raise_exception (exc);\n\t}\n\n\tres = mono_assembly_fill_assembly_name (image, &name);\n\tif (!res) {\n\t\tmono_image_close (image);\n\t\tg_free (filename);\n\t\tmono_raise_exception (mono_get_exception_argument (\"assemblyFile\", \"The file does not contain a manifest\"));\n\t}\n\n\tfill_reflection_assembly_name (mono_domain_get (), aname, &name, filename,\n\t\tTRUE, mono_framework_version () == 1,\n\t\tmono_framework_version () >= 2);\n\n\tg_free (filename);\n\tmono_image_close (image);\n}\n\nstatic MonoBoolean\nves_icall_System_Reflection_Assembly_LoadPermissions (MonoReflectionAssembly *assembly,\n\tchar **minimum, guint32 *minLength, char **optional, guint32 *optLength, char **refused, guint32 *refLength)\n{\n\tMonoBoolean result = FALSE;\n\tMonoDeclSecurityEntry entry;\n\n\t/* SecurityAction.RequestMinimum */\n\tif (mono_declsec_get_assembly_action (assembly->assembly, SECURITY_ACTION_REQMIN, &entry)) {\n\t\t*minimum = entry.blob;\n\t\t*minLength = entry.size;\n\t\tresult = TRUE;\n\t}\n\t/* SecurityAction.RequestOptional */\n\tif (mono_declsec_get_assembly_action (assembly->assembly, SECURITY_ACTION_REQOPT, &entry)) {\n\t\t*optional = entry.blob;\n\t\t*optLength = entry.size;\n\t\tresult = TRUE;\n\t}\n\t/* SecurityAction.RequestRefuse */\n\tif (mono_declsec_get_assembly_action (assembly->assembly, SECURITY_ACTION_REQREFUSE, &entry)) {\n\t\t*refused = entry.blob;\n\t\t*refLength = entry.size;\n\t\tresult = TRUE;\n\t}\n\n\treturn result;\t\n}\n\nstatic MonoArray*\nmono_module_get_types (MonoDomain *domain, MonoImage *image, MonoArray **exceptions, MonoBoolean exportedOnly)\n{\n\tMonoArray *res;\n\tMonoClass *klass;\n\tMonoTableInfo *tdef = &image->tables [MONO_TABLE_TYPEDEF];\n\tint i, count;\n\tguint32 attrs, visibility;\n\n\t/* we start the count from 1 because we skip the special type <Module> */\n\tif (exportedOnly) {\n\t\tcount = 0;\n\t\tfor (i = 1; i < tdef->rows; ++i) {\n\t\t\tattrs = mono_metadata_decode_row_col (tdef, i, MONO_TYPEDEF_FLAGS);\n\t\t\tvisibility = attrs & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\t\t\tif (visibility == TYPE_ATTRIBUTE_PUBLIC || visibility == TYPE_ATTRIBUTE_NESTED_PUBLIC)\n\t\t\t\tcount++;\n\t\t}\n\t} else {\n\t\tcount = tdef->rows - 1;\n\t}\n\tres = mono_array_new (domain, mono_defaults.monotype_class, count);\n\t*exceptions = mono_array_new (domain, mono_defaults.exception_class, count);\n\tcount = 0;\n\tfor (i = 1; i < tdef->rows; ++i) {\n\t\tattrs = mono_metadata_decode_row_col (tdef, i, MONO_TYPEDEF_FLAGS);\n\t\tvisibility = attrs & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\t\tif (!exportedOnly || (visibility == TYPE_ATTRIBUTE_PUBLIC || visibility == TYPE_ATTRIBUTE_NESTED_PUBLIC)) {\n\t\t\tklass = mono_class_get (image, (i + 1) | MONO_TOKEN_TYPE_DEF);\n\t\t\tif (klass) {\n\t\t\t\tmono_array_setref (res, count, mono_type_get_object (domain, &klass->byval_arg));\n\t\t\t} else {\n\t\t\t\tMonoLoaderError *error;\n\t\t\t\tMonoException *ex;\n\t\t\t\t\n\t\t\t\terror = mono_loader_get_last_error ();\n\t\t\t\tg_assert (error != NULL);\n\t\n\t\t\t\tex = mono_loader_error_prepare_exception (error);\n\t\t\t\tmono_array_setref (*exceptions, count, ex);\n\t\t\t}\n\t\t\tif (mono_loader_get_last_error ())\n\t\t\t\tmono_loader_clear_error ();\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Assembly_GetTypes (MonoReflectionAssembly *assembly, MonoBoolean exportedOnly)\n{\n\tMonoArray *res = NULL;\n\tMonoArray *exceptions = NULL;\n\tMonoImage *image = NULL;\n\tMonoTableInfo *table = NULL;\n\tMonoDomain *domain;\n\tGList *list = NULL;\n\tint i, len, ex_count;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = mono_object_domain (assembly);\n\n\tg_assert (!assembly->assembly->dynamic);\n\timage = assembly->assembly->image;\n\ttable = &image->tables [MONO_TABLE_FILE];\n\tres = mono_module_get_types (domain, image, &exceptions, exportedOnly);\n\n\t/* Append data from all modules in the assembly */\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tif (!(mono_metadata_decode_row_col (table, i, MONO_FILE_FLAGS) & FILE_CONTAINS_NO_METADATA)) {\n\t\t\tMonoImage *loaded_image = mono_assembly_load_module (image->assembly, i + 1);\n\t\t\tif (loaded_image) {\n\t\t\t\tMonoArray *ex2;\n\t\t\t\tMonoArray *res2 = mono_module_get_types (domain, loaded_image, &ex2, exportedOnly);\n\t\t\t\t/* Append the new types to the end of the array */\n\t\t\t\tif (mono_array_length (res2) > 0) {\n\t\t\t\t\tguint32 len1, len2;\n\t\t\t\t\tMonoArray *res3, *ex3;\n\n\t\t\t\t\tlen1 = mono_array_length (res);\n\t\t\t\t\tlen2 = mono_array_length (res2);\n\n\t\t\t\t\tres3 = mono_array_new (domain, mono_defaults.monotype_class, len1 + len2);\n\t\t\t\t\tmono_array_memcpy_refs (res3, 0, res, 0, len1);\n\t\t\t\t\tmono_array_memcpy_refs (res3, len1, res2, 0, len2);\n\t\t\t\t\tres = res3;\n\n\t\t\t\t\tex3 = mono_array_new (domain, mono_defaults.monotype_class, len1 + len2);\n\t\t\t\t\tmono_array_memcpy_refs (ex3, 0, exceptions, 0, len1);\n\t\t\t\t\tmono_array_memcpy_refs (ex3, len1, ex2, 0, len2);\n\t\t\t\t\texceptions = ex3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the ReflectionTypeLoadException must have all the types (Types property), \n\t * NULL replacing types which throws an exception. The LoaderException must\n\t * contain all exceptions for NULL items.\n\t */\n\n\tlen = mono_array_length (res);\n\n\tex_count = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tMonoReflectionType *t = mono_array_get (res, gpointer, i);\n\t\tMonoClass *klass;\n\n\t\tif (t) {\n\t\t\tklass = mono_type_get_class (t->type);\n\t\t\tif ((klass != NULL) && klass->exception_type) {\n\t\t\t\t/* keep the class in the list */\n\t\t\t\tlist = g_list_append (list, klass);\n\t\t\t\t/* and replace Type with NULL */\n\t\t\t\tmono_array_setref (res, i, NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tex_count ++;\n\t\t}\n\t}\n\n\tif (list || ex_count) {\n\t\tGList *tmp = NULL;\n\t\tMonoException *exc = NULL;\n\t\tMonoArray *exl = NULL;\n\t\tint j, length = g_list_length (list) + ex_count;\n\n\t\tmono_loader_clear_error ();\n\n\t\texl = mono_array_new (domain, mono_defaults.exception_class, length);\n\t\t/* Types for which mono_class_get () succeeded */\n\t\tfor (i = 0, tmp = list; tmp; i++, tmp = tmp->next) {\n\t\t\tMonoException *exc = mono_class_get_exception_for_failure (tmp->data);\n\t\t\tmono_array_setref (exl, i, exc);\n\t\t}\n\t\t/* Types for which it don't */\n\t\tfor (j = 0; j < mono_array_length (exceptions); ++j) {\n\t\t\tMonoException *exc = mono_array_get (exceptions, MonoException*, j);\n\t\t\tif (exc) {\n\t\t\t\tg_assert (i < length);\n\t\t\t\tmono_array_setref (exl, i, exc);\n\t\t\t\ti ++;\n\t\t\t}\n\t\t}\n\t\tg_list_free (list);\n\t\tlist = NULL;\n\n\t\texc = mono_get_exception_reflection_type_load (res, exl);\n\t\tmono_loader_clear_error ();\n\t\tmono_raise_exception (exc);\n\t}\n\t\t\n\treturn res;\n}\n\nstatic gboolean\nves_icall_System_Reflection_AssemblyName_ParseName (MonoReflectionAssemblyName *name, MonoString *assname)\n{\n\tMonoAssemblyName aname;\n\tMonoDomain *domain = mono_object_domain (name);\n\tchar *val;\n\tgboolean is_version_defined;\n\tgboolean is_token_defined;\n\n\taname.public_key = NULL;\n\tval = mono_string_to_utf8 (assname);\n\tif (!mono_assembly_name_parse_full (val, &aname, TRUE, &is_version_defined, &is_token_defined)) {\n\t\tg_free ((guint8*) aname.public_key);\n\t\tg_free (val);\n\t\treturn FALSE;\n\t}\n\t\n\tfill_reflection_assembly_name (domain, name, &aname, \"\", is_version_defined,\n\t\tFALSE, is_token_defined);\n\n\tmono_assembly_name_free (&aname);\n\tg_free ((guint8*) aname.public_key);\n\tg_free (val);\n\n\treturn TRUE;\n}\n\nstatic MonoReflectionType*\nves_icall_System_Reflection_Module_GetGlobalType (MonoReflectionModule *module)\n{\n\tMonoDomain *domain = mono_object_domain (module); \n\tMonoClass *klass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_assert (module->image);\n\n\tif (module->image->dynamic && ((MonoDynamicImage*)(module->image))->initial_image)\n\t\t/* These images do not have a global type */\n\t\treturn NULL;\n\n\tklass = mono_class_get (module->image, 1 | MONO_TOKEN_TYPE_DEF);\n\treturn mono_type_get_object (domain, &klass->byval_arg);\n}\n\nstatic void\nves_icall_System_Reflection_Module_Close (MonoReflectionModule *module)\n{\n\t/*if (module->image)\n\t\tmono_image_close (module->image);*/\n}\n\nstatic MonoString*\nves_icall_System_Reflection_Module_GetGuidInternal (MonoReflectionModule *module)\n{\n\tMonoDomain *domain = mono_object_domain (module); \n\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_assert (module->image);\n\treturn mono_string_new (domain, module->image->guid);\n}\n\nstatic gpointer\nves_icall_System_Reflection_Module_GetHINSTANCE (MonoReflectionModule *module)\n{\n#ifdef PLATFORM_WIN32\n\tif (module->image && module->image->is_module_handle)\n\t\treturn module->image->raw_data;\n#endif\n\n\treturn (gpointer) (-1);\n}\n\nstatic void\nves_icall_System_Reflection_Module_GetPEKind (MonoImage *image, gint32 *pe_kind, gint32 *machine)\n{\n\tif (image->dynamic) {\n\t\tMonoDynamicImage *dyn = (MonoDynamicImage*)image;\n\t\t*pe_kind = dyn->pe_kind;\n\t\t*machine = dyn->machine;\n\t}\n\telse {\n\t\t*pe_kind = ((MonoCLIImageInfo*)(image->image_info))->cli_cli_header.ch_flags & 0x3;\n\t\t*machine = ((MonoCLIImageInfo*)(image->image_info))->cli_header.coff.coff_machine;\n\t}\n}\n\nstatic gint32\nves_icall_System_Reflection_Module_GetMDStreamVersion (MonoImage *image)\n{\n\treturn (image->md_version_major << 16) | (image->md_version_minor);\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Module_InternalGetTypes (MonoReflectionModule *module)\n{\n\tMonoArray *exceptions;\n\tint i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!module->image)\n\t\treturn mono_array_new (mono_object_domain (module), mono_defaults.monotype_class, 0);\n\telse {\n\t\tMonoArray *res = mono_module_get_types (mono_object_domain (module), module->image, &exceptions, FALSE);\n\t\tfor (i = 0; i < mono_array_length (exceptions); ++i) {\n\t\t\tMonoException *ex = mono_array_get (exceptions, MonoException *, i);\n\t\t\tif (ex)\n\t\t\t\tmono_raise_exception (ex);\n\t\t}\n\t\treturn res;\n\t}\n}\n\nstatic gboolean\nmono_metadata_memberref_is_method (MonoImage *image, guint32 token)\n{\n\tguint32 cols [MONO_MEMBERREF_SIZE];\n\tconst char *sig;\n\tmono_metadata_decode_row (&image->tables [MONO_TABLE_MEMBERREF], mono_metadata_token_index (token) - 1, cols, MONO_MEMBERREF_SIZE);\n\tsig = mono_metadata_blob_heap (image, cols [MONO_MEMBERREF_SIGNATURE]);\n\tmono_metadata_decode_blob_size (sig, &sig);\n\treturn (*sig != 0x6);\n}\n\nstatic void\ninit_generic_context_from_args (MonoGenericContext *context, MonoArray *type_args, MonoArray *method_args)\n{\n\tif (type_args)\n\t\tcontext->class_inst = mono_metadata_get_generic_inst (mono_array_length (type_args),\n\t\t\t\t\t\t\t\t      mono_array_addr (type_args, MonoType*, 0));\n\telse\n\t\tcontext->class_inst = NULL;\n\tif (method_args)\n\t\tcontext->method_inst = mono_metadata_get_generic_inst (mono_array_length (method_args),\n\t\t\t\t\t\t\t\t       mono_array_addr (method_args, MonoType*, 0));\n\telse\n\t\tcontext->method_inst = NULL;\n}\n\nstatic MonoType*\nves_icall_System_Reflection_Module_ResolveTypeToken (MonoImage *image, guint32 token, MonoArray *type_args, MonoArray *method_args, MonoResolveTokenError *error)\n{\n\tMonoClass *klass;\n\tint table = mono_metadata_token_table (token);\n\tint index = mono_metadata_token_index (token);\n\tMonoGenericContext context;\n\n\t*error = ResolveTokenError_Other;\n\n\t/* Validate token */\n\tif ((table != MONO_TABLE_TYPEDEF) && (table != MONO_TABLE_TYPEREF) && \n\t\t(table != MONO_TABLE_TYPESPEC)) {\n\t\t*error = ResolveTokenError_BadTable;\n\t\treturn NULL;\n\t}\n\n\tif (image->dynamic) {\n\t\tif (type_args || method_args)\n\t\t\tmono_raise_exception (mono_get_exception_not_implemented (NULL));\n\t\tklass = mono_lookup_dynamic_token_class (image, token, FALSE, NULL, NULL);\n\t\tif (!klass)\n\t\t\treturn NULL;\n\t\treturn &klass->byval_arg;\n\t}\n\n\tif ((index <= 0) || (index > image->tables [table].rows)) {\n\t\t*error = ResolveTokenError_OutOfRange;\n\t\treturn NULL;\n\t}\n\n\tinit_generic_context_from_args (&context, type_args, method_args);\n\tklass = mono_class_get_full (image, token, &context);\n\n\tif (mono_loader_get_last_error ())\n\t\tmono_raise_exception (mono_loader_error_prepare_exception (mono_loader_get_last_error ()));\n\n\tif (klass)\n\t\treturn &klass->byval_arg;\n\telse\n\t\treturn NULL;\n}\n\nstatic MonoMethod*\nves_icall_System_Reflection_Module_ResolveMethodToken (MonoImage *image, guint32 token, MonoArray *type_args, MonoArray *method_args, MonoResolveTokenError *error)\n{\n\tint table = mono_metadata_token_table (token);\n\tint index = mono_metadata_token_index (token);\n\tMonoGenericContext context;\n\tMonoMethod *method;\n\n\t*error = ResolveTokenError_Other;\n\n\t/* Validate token */\n\tif ((table != MONO_TABLE_METHOD) && (table != MONO_TABLE_METHODSPEC) && \n\t\t(table != MONO_TABLE_MEMBERREF)) {\n\t\t*error = ResolveTokenError_BadTable;\n\t\treturn NULL;\n\t}\n\n\tif (image->dynamic) {\n\t\tif (type_args || method_args)\n\t\t\tmono_raise_exception (mono_get_exception_not_implemented (NULL));\n\t\t/* FIXME: validate memberref token type */\n\t\treturn mono_lookup_dynamic_token_class (image, token, FALSE, NULL, NULL);\n\t}\n\n\tif ((index <= 0) || (index > image->tables [table].rows)) {\n\t\t*error = ResolveTokenError_OutOfRange;\n\t\treturn NULL;\n\t}\n\tif ((table == MONO_TABLE_MEMBERREF) && (!mono_metadata_memberref_is_method (image, token))) {\n\t\t*error = ResolveTokenError_BadTable;\n\t\treturn NULL;\n\t}\n\n\tinit_generic_context_from_args (&context, type_args, method_args);\n\tmethod = mono_get_method_full (image, token, NULL, &context);\n\n\tif (mono_loader_get_last_error ())\n\t\tmono_raise_exception (mono_loader_error_prepare_exception (mono_loader_get_last_error ()));\n\n\treturn method;\n}\n\nstatic MonoString*\nves_icall_System_Reflection_Module_ResolveStringToken (MonoImage *image, guint32 token, MonoResolveTokenError *error)\n{\n\tint index = mono_metadata_token_index (token);\n\n\t*error = ResolveTokenError_Other;\n\n\t/* Validate token */\n\tif (mono_metadata_token_code (token) != MONO_TOKEN_STRING) {\n\t\t*error = ResolveTokenError_BadTable;\n\t\treturn NULL;\n\t}\n\n\tif (image->dynamic)\n\t\treturn mono_lookup_dynamic_token_class (image, token, FALSE, NULL, NULL);\n\n\tif ((index <= 0) || (index >= image->heap_us.size)) {\n\t\t*error = ResolveTokenError_OutOfRange;\n\t\treturn NULL;\n\t}\n\n\t/* FIXME: What to do if the index points into the middle of a string ? */\n\n\treturn mono_ldstr (mono_domain_get (), image, index);\n}\n\nstatic MonoClassField*\nves_icall_System_Reflection_Module_ResolveFieldToken (MonoImage *image, guint32 token, MonoArray *type_args, MonoArray *method_args, MonoResolveTokenError *error)\n{\n\tMonoClass *klass;\n\tint table = mono_metadata_token_table (token);\n\tint index = mono_metadata_token_index (token);\n\tMonoGenericContext context;\n\tMonoClassField *field;\n\n\t*error = ResolveTokenError_Other;\n\n\t/* Validate token */\n\tif ((table != MONO_TABLE_FIELD) && (table != MONO_TABLE_MEMBERREF)) {\n\t\t*error = ResolveTokenError_BadTable;\n\t\treturn NULL;\n\t}\n\n\tif (image->dynamic) {\n\t\tif (type_args || method_args)\n\t\t\tmono_raise_exception (mono_get_exception_not_implemented (NULL));\n\t\t/* FIXME: validate memberref token type */\n\t\treturn mono_lookup_dynamic_token_class (image, token, FALSE, NULL, NULL);\n\t}\n\n\tif ((index <= 0) || (index > image->tables [table].rows)) {\n\t\t*error = ResolveTokenError_OutOfRange;\n\t\treturn NULL;\n\t}\n\tif ((table == MONO_TABLE_MEMBERREF) && (mono_metadata_memberref_is_method (image, token))) {\n\t\t*error = ResolveTokenError_BadTable;\n\t\treturn NULL;\n\t}\n\n\tinit_generic_context_from_args (&context, type_args, method_args);\n\tfield = mono_field_from_token (image, token, &klass, &context);\n\n\tif (mono_loader_get_last_error ())\n\t\tmono_raise_exception (mono_loader_error_prepare_exception (mono_loader_get_last_error ()));\n\t\n\treturn field;\n}\n\n\nstatic MonoObject*\nves_icall_System_Reflection_Module_ResolveMemberToken (MonoImage *image, guint32 token, MonoArray *type_args, MonoArray *method_args, MonoResolveTokenError *error)\n{\n\tint table = mono_metadata_token_table (token);\n\n\t*error = ResolveTokenError_Other;\n\n\tswitch (table) {\n\tcase MONO_TABLE_TYPEDEF:\n\tcase MONO_TABLE_TYPEREF:\n\tcase MONO_TABLE_TYPESPEC: {\n\t\tMonoType *t = ves_icall_System_Reflection_Module_ResolveTypeToken (image, token, type_args, method_args, error);\n\t\tif (t)\n\t\t\treturn (MonoObject*)mono_type_get_object (mono_domain_get (), t);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\tcase MONO_TABLE_METHOD:\n\tcase MONO_TABLE_METHODSPEC: {\n\t\tMonoMethod *m = ves_icall_System_Reflection_Module_ResolveMethodToken (image, token, type_args, method_args, error);\n\t\tif (m)\n\t\t\treturn (MonoObject*)mono_method_get_object (mono_domain_get (), m, m->klass);\n\t\telse\n\t\t\treturn NULL;\n\t}\t\t\n\tcase MONO_TABLE_FIELD: {\n\t\tMonoClassField *f = ves_icall_System_Reflection_Module_ResolveFieldToken (image, token, type_args, method_args, error);\n\t\tif (f)\n\t\t\treturn (MonoObject*)mono_field_get_object (mono_domain_get (), f->parent, f);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\tcase MONO_TABLE_MEMBERREF:\n\t\tif (mono_metadata_memberref_is_method (image, token)) {\n\t\t\tMonoMethod *m = ves_icall_System_Reflection_Module_ResolveMethodToken (image, token, type_args, method_args, error);\n\t\t\tif (m)\n\t\t\t\treturn (MonoObject*)mono_method_get_object (mono_domain_get (), m, m->klass);\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t\telse {\n\t\t\tMonoClassField *f = ves_icall_System_Reflection_Module_ResolveFieldToken (image, token, type_args, method_args, error);\n\t\t\tif (f)\n\t\t\t\treturn (MonoObject*)mono_field_get_object (mono_domain_get (), f->parent, f);\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t*error = ResolveTokenError_BadTable;\n\t}\n\n\treturn NULL;\n}\n\nstatic MonoArray*\nves_icall_System_Reflection_Module_ResolveSignature (MonoImage *image, guint32 token, MonoResolveTokenError *error)\n{\n\tint table = mono_metadata_token_table (token);\n\tint idx = mono_metadata_token_index (token);\n\tMonoTableInfo *tables = image->tables;\n\tguint32 sig, len;\n\tconst char *ptr;\n\tMonoArray *res;\n\n\t*error = ResolveTokenError_OutOfRange;\n\n\t/* FIXME: Support other tables ? */\n\tif (table != MONO_TABLE_STANDALONESIG)\n\t\treturn NULL;\n\n\tif (image->dynamic)\n\t\treturn NULL;\n\n\tif ((idx == 0) || (idx > tables [MONO_TABLE_STANDALONESIG].rows))\n\t\treturn NULL;\n\n\tsig = mono_metadata_decode_row_col (&tables [MONO_TABLE_STANDALONESIG], idx - 1, 0);\n\n\tptr = mono_metadata_blob_heap (image, sig);\n\tlen = mono_metadata_decode_blob_size (ptr, &ptr);\n\n\tres = mono_array_new (mono_domain_get (), mono_defaults.byte_class, len);\n\tmemcpy (mono_array_addr (res, guint8, 0), ptr, len);\n\treturn res;\n}\n\nstatic MonoReflectionType*\nves_icall_ModuleBuilder_create_modified_type (MonoReflectionTypeBuilder *tb, MonoString *smodifiers)\n{\n\tMonoClass *klass;\n\tint isbyref = 0, rank;\n\tchar *str = mono_string_to_utf8 (smodifiers);\n\tchar *p;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (tb->type.type);\n\tp = str;\n\t/* logic taken from mono_reflection_parse_type(): keep in sync */\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase '&':\n\t\t\tif (isbyref) { /* only one level allowed by the spec */\n\t\t\t\tg_free (str);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tisbyref = 1;\n\t\t\tp++;\n\t\t\tg_free (str);\n\t\t\treturn mono_type_get_object (mono_object_domain (tb), &klass->this_arg);\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tklass = mono_ptr_class_get (&klass->byval_arg);\n\t\t\tmono_class_init (klass);\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\trank = 1;\n\t\t\tp++;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == ']')\n\t\t\t\t\tbreak;\n\t\t\t\tif (*p == ',')\n\t\t\t\t\trank++;\n\t\t\t\telse if (*p != '*') { /* '*' means unknown lower bound */\n\t\t\t\t\tg_free (str);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tif (*p != ']') {\n\t\t\t\tg_free (str);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tp++;\n\t\t\tklass = mono_array_class_get (klass, rank);\n\t\t\tmono_class_init (klass);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tg_free (str);\n\treturn mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n}\n\nstatic MonoBoolean\nves_icall_Type_IsArrayImpl (MonoReflectionType *t)\n{\n\tMonoType *type;\n\tMonoBoolean res;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\ttype = t->type;\n\tres = !type->byref && (type->type == MONO_TYPE_ARRAY || type->type == MONO_TYPE_SZARRAY);\n\n\treturn res;\n}\n\nstatic void\ncheck_for_invalid_type (MonoClass *klass)\n{\n\tchar *name;\n\tMonoString *str;\n\tif (klass->byval_arg.type != MONO_TYPE_TYPEDBYREF)\n\t\treturn;\n\n\tname = mono_type_get_full_name (klass);\n\tstr =  mono_string_new (mono_domain_get (), name);\n\tg_free (name);\n\tmono_raise_exception ((MonoException*)mono_get_exception_type_load (str, NULL));\n\n}\nstatic MonoReflectionType *\nves_icall_Type_make_array_type (MonoReflectionType *type, int rank)\n{\n\tMonoClass *klass, *aklass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tcheck_for_invalid_type (klass);\n\n\tif (rank == 0) //single dimentional array\n\t\taklass = mono_array_class_get (klass, 1);\n\telse\n\t\taklass = mono_bounded_array_class_get (klass, rank, TRUE);\n\n\treturn mono_type_get_object (mono_object_domain (type), &aklass->byval_arg);\n}\n\nstatic MonoReflectionType *\nves_icall_Type_make_byref_type (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tcheck_for_invalid_type (klass);\n\n\treturn mono_type_get_object (mono_object_domain (type), &klass->this_arg);\n}\n\nstatic MonoReflectionType *\nves_icall_Type_MakePointerType (MonoReflectionType *type)\n{\n\tMonoClass *klass, *pklass;\n\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tcheck_for_invalid_type (klass);\n\n\tpklass = mono_ptr_class_get (type->type);\n\n\treturn mono_type_get_object (mono_object_domain (type), &pklass->byval_arg);\n}\n\nstatic MonoObject *\nves_icall_System_Delegate_CreateDelegate_internal (MonoReflectionType *type, MonoObject *target,\n\t\t\t\t\t\t   MonoReflectionMethod *info, MonoBoolean throwOnBindFailure)\n{\n\tMonoClass *delegate_class = mono_class_from_mono_type (type->type);\n\tMonoObject *delegate;\n\tgpointer func;\n\tMonoMethod *method = info->method;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_assert (delegate_class->parent == mono_defaults.multicastdelegate_class);\n\n\tif (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR) {\n\t\tif (!mono_security_core_clr_ensure_delegate_creation (method, throwOnBindFailure))\n\t\t\treturn NULL;\n\t}\n\n\tdelegate = mono_object_new (mono_object_domain (type), delegate_class);\n\n\tif (method->dynamic) {\n\t\t/* Creating a trampoline would leak memory */\n\t\tfunc = mono_compile_method (method);\n\t} else {\n\t\tfunc = mono_create_ftnptr (mono_domain_get (),\n\t\t\tmono_runtime_create_jump_trampoline (mono_domain_get (), method, TRUE));\n\t}\n\n\tmono_delegate_ctor_with_method (delegate, target, func, method);\n\n\treturn delegate;\n}\n\nstatic void\nves_icall_System_Delegate_SetMulticastInvoke (MonoDelegate *this)\n{\n\t/* Reset the invoke impl to the default one */\n\tthis->invoke_impl = mono_runtime_create_delegate_trampoline (this->object.vtable->klass);\n}\n\n/*\n * Magic number to convert a time which is relative to\n * Jan 1, 1970 into a value which is relative to Jan 1, 0001.\n */\n#define\tEPOCH_ADJUST\t((guint64)62135596800LL)\n\n/*\n * Magic number to convert FILETIME base Jan 1, 1601 to DateTime - base Jan, 1, 0001\n */\n#define FILETIME_ADJUST ((guint64)504911232000000000LL)\n\n#ifdef PLATFORM_WIN32\n/* convert a SYSTEMTIME which is of the form \"last thursday in october\" to a real date */\nstatic void\nconvert_to_absolute_date(SYSTEMTIME *date)\n{\n#define IS_LEAP(y) ((y % 4) == 0 && ((y % 100) != 0 || (y % 400) == 0))\n\tstatic int days_in_month[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\tstatic int leap_days_in_month[] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\t/* from the calendar FAQ */\n\tint a = (14 - date->wMonth) / 12;\n\tint y = date->wYear - a;\n\tint m = date->wMonth + 12 * a - 2;\n\tint d = (1 + y + y/4 - y/100 + y/400 + (31*m)/12) % 7;\n\n\t/* d is now the day of the week for the first of the month (0 == Sunday) */\n\n\tint day_of_week = date->wDayOfWeek;\n\n\t/* set day_in_month to the first day in the month which falls on day_of_week */    \n\tint day_in_month = 1 + (day_of_week - d);\n\tif (day_in_month <= 0)\n\t\tday_in_month += 7;\n\n\t/* wDay is 1 for first weekday in month, 2 for 2nd ... 5 means last - so work that out allowing for days in the month */\n\tdate->wDay = day_in_month + (date->wDay - 1) * 7;\n\tif (date->wDay > (IS_LEAP(date->wYear) ? leap_days_in_month[date->wMonth - 1] : days_in_month[date->wMonth - 1]))\n\t\tdate->wDay -= 7;\n}\n#endif\n\n#ifndef PLATFORM_WIN32\n/*\n * Return's the offset from GMT of a local time.\n * \n *  tm is a local time\n *  t  is the same local time as seconds.\n */\nstatic int \ngmt_offset(struct tm *tm, time_t t)\n{\n#if defined (HAVE_TM_GMTOFF)\n\treturn tm->tm_gmtoff;\n#else\n\tstruct tm g;\n\ttime_t t2;\n\tg = *gmtime(&t);\n\tg.tm_isdst = tm->tm_isdst;\n\tt2 = mktime(&g);\n\treturn (int)difftime(t, t2);\n#endif\n}\n#endif\n/*\n * This is heavily based on zdump.c from glibc 2.2.\n *\n *  * data[0]:  start of daylight saving time (in DateTime ticks).\n *  * data[1]:  end of daylight saving time (in DateTime ticks).\n *  * data[2]:  utcoffset (in TimeSpan ticks).\n *  * data[3]:  additional offset when daylight saving (in TimeSpan ticks).\n *  * name[0]:  name of this timezone when not daylight saving.\n *  * name[1]:  name of this timezone when daylight saving.\n *\n *  FIXME: This only works with \"standard\" Unix dates (years between 1900 and 2100) while\n *         the class library allows years between 1 and 9999.\n *\n *  Returns true on success and zero on failure.\n */\nstatic guint32\nves_icall_System_CurrentSystemTimeZone_GetTimeZoneData (guint32 year, MonoArray **data, MonoArray **names)\n{\n#ifndef PLATFORM_WIN32\n\tMonoDomain *domain = mono_domain_get ();\n\tstruct tm start, tt;\n\ttime_t t;\n\n\tlong int gmtoff;\n\tint is_daylight = 0, day;\n\tchar tzone [64];\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tMONO_CHECK_ARG_NULL (data);\n\tMONO_CHECK_ARG_NULL (names);\n\n\tmono_gc_wbarrier_generic_store (data, (MonoObject*) mono_array_new (domain, mono_defaults.int64_class, 4));\n\tmono_gc_wbarrier_generic_store (names, (MonoObject*) mono_array_new (domain, mono_defaults.string_class, 2));\n\n\t/* \n\t * no info is better than crashing: we'll need our own tz data\n\t * to make this work properly, anyway. The range is probably\n\t * reduced to 1970 .. 2037 because that is what mktime is\n\t * guaranteed to support (we get into an infinite loop\n\t * otherwise).\n\t */\n\n\tmemset (&start, 0, sizeof (start));\n\n\tstart.tm_mday = 1;\n\tstart.tm_year = year-1900;\n\n\tt = mktime (&start);\n\n\tif ((year < 1970) || (year > 2037) || (t == -1)) {\n\t\tt = time (NULL);\n\t\ttt = *localtime (&t);\n\t\tstrftime (tzone, sizeof (tzone), \"%Z\", &tt);\n\t\tmono_array_setref ((*names), 0, mono_string_new (domain, tzone));\n\t\tmono_array_setref ((*names), 1, mono_string_new (domain, tzone));\n\t\treturn 1;\n\t}\n\n\tgmtoff = gmt_offset (&start, t);\n\n\t/* For each day of the year, calculate the tm_gmtoff. */\n\tfor (day = 0; day < 365; day++) {\n\n\t\tt += 3600*24;\n\t\ttt = *localtime (&t);\n\n\t\t/* Daylight saving starts or ends here. */\n\t\tif (gmt_offset (&tt, t) != gmtoff) {\n\t\t\tstruct tm tt1;\n\t\t\ttime_t t1;\n\n\t\t\t/* Try to find the exact hour when daylight saving starts/ends. */\n\t\t\tt1 = t;\n\t\t\tdo {\n\t\t\t\tt1 -= 3600;\n\t\t\t\ttt1 = *localtime (&t1);\n\t\t\t} while (gmt_offset (&tt1, t1) != gmtoff);\n\n\t\t\t/* Try to find the exact minute when daylight saving starts/ends. */\n\t\t\tdo {\n\t\t\t\tt1 += 60;\n\t\t\t\ttt1 = *localtime (&t1);\n\t\t\t} while (gmt_offset (&tt1, t1) == gmtoff);\n\t\t\tt1+=gmtoff;\n\t\t\tstrftime (tzone, sizeof (tzone), \"%Z\", &tt);\n\t\t\t\n\t\t\t/* Write data, if we're already in daylight saving, we're done. */\n\t\t\tif (is_daylight) {\n\t\t\t\tmono_array_setref ((*names), 0, mono_string_new (domain, tzone));\n\t\t\t\tmono_array_set ((*data), gint64, 1, ((gint64)t1 + EPOCH_ADJUST) * 10000000L);\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tmono_array_setref ((*names), 1, mono_string_new (domain, tzone));\n\t\t\t\tmono_array_set ((*data), gint64, 0, ((gint64)t1 + EPOCH_ADJUST) * 10000000L);\n\t\t\t\tis_daylight = 1;\n\t\t\t}\n\n\t\t\t/* This is only set once when we enter daylight saving. */\n\t\t\tmono_array_set ((*data), gint64, 2, (gint64)gmtoff * 10000000L);\n\t\t\tmono_array_set ((*data), gint64, 3, (gint64)(gmt_offset (&tt, t) - gmtoff) * 10000000L);\n\n\t\t\tgmtoff = gmt_offset (&tt, t);\n\t\t}\n\t}\n\n\tif (!is_daylight) {\n\t\tstrftime (tzone, sizeof (tzone), \"%Z\", &tt);\n\t\tmono_array_setref ((*names), 0, mono_string_new (domain, tzone));\n\t\tmono_array_setref ((*names), 1, mono_string_new (domain, tzone));\n\t\tmono_array_set ((*data), gint64, 0, 0);\n\t\tmono_array_set ((*data), gint64, 1, 0);\n\t\tmono_array_set ((*data), gint64, 2, (gint64) gmtoff * 10000000L);\n\t\tmono_array_set ((*data), gint64, 3, 0);\n\t}\n\n\treturn 1;\n#else\n\tMonoDomain *domain = mono_domain_get ();\n\tTIME_ZONE_INFORMATION tz_info;\n\tFILETIME ft;\n\tint i;\n\tint err, tz_id;\n\n\ttz_id = GetTimeZoneInformation (&tz_info);\n\tif (tz_id == TIME_ZONE_ID_INVALID)\n\t\treturn 0;\n\n\tMONO_CHECK_ARG_NULL (data);\n\tMONO_CHECK_ARG_NULL (names);\n\n\tmono_gc_wbarrier_generic_store (data, mono_array_new (domain, mono_defaults.int64_class, 4));\n\tmono_gc_wbarrier_generic_store (names, mono_array_new (domain, mono_defaults.string_class, 2));\n\n\tfor (i = 0; i < 32; ++i)\n\t\tif (!tz_info.DaylightName [i])\n\t\t\tbreak;\n\tmono_array_setref ((*names), 1, mono_string_new_utf16 (domain, tz_info.DaylightName, i));\n\tfor (i = 0; i < 32; ++i)\n\t\tif (!tz_info.StandardName [i])\n\t\t\tbreak;\n\tmono_array_setref ((*names), 0, mono_string_new_utf16 (domain, tz_info.StandardName, i));\n\n\tif ((year <= 1601) || (year > 30827)) {\n\t\t/*\n\t\t * According to MSDN, the MS time functions can't handle dates outside\n\t\t * this interval.\n\t\t */\n\t\treturn 1;\n\t}\n\n\t/* even if the timezone has no daylight savings it may have Bias (e.g. GMT+13 it seems) */\n\tif (tz_id != TIME_ZONE_ID_UNKNOWN) {\n\t\ttz_info.StandardDate.wYear = year;\n\t\tconvert_to_absolute_date(&tz_info.StandardDate);\n\t\terr = SystemTimeToFileTime (&tz_info.StandardDate, &ft);\n\t\t//g_assert(err);\n\t\tif (err == 0)\n\t\t\treturn 0;\n\t\t\n\t\tmono_array_set ((*data), gint64, 1, FILETIME_ADJUST + (((guint64)ft.dwHighDateTime<<32) | ft.dwLowDateTime));\n\t\ttz_info.DaylightDate.wYear = year;\n\t\tconvert_to_absolute_date(&tz_info.DaylightDate);\n\t\terr = SystemTimeToFileTime (&tz_info.DaylightDate, &ft);\n\t\t//g_assert(err);\n\t\tif (err == 0)\n\t\t\treturn 0;\n\t\t\n\t\tmono_array_set ((*data), gint64, 0, FILETIME_ADJUST + (((guint64)ft.dwHighDateTime<<32) | ft.dwLowDateTime));\n\t}\n\tmono_array_set ((*data), gint64, 2, (tz_info.Bias + tz_info.StandardBias) * -600000000LL);\n\tmono_array_set ((*data), gint64, 3, (tz_info.DaylightBias - tz_info.StandardBias) * -600000000LL);\n\n\treturn 1;\n#endif\n}\n\nstatic gpointer\nves_icall_System_Object_obj_address (MonoObject *this) \n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn this;\n}\n\n/* System.Buffer */\n\nstatic inline gint32 \nmono_array_get_byte_length (MonoArray *array)\n{\n\tMonoClass *klass;\n\tint length;\n\tint i;\n\n\tklass = array->obj.vtable->klass;\n\n\tif (array->bounds == NULL)\n\t\tlength = array->max_length;\n\telse {\n\t\tlength = 1;\n\t\tfor (i = 0; i < klass->rank; ++ i)\n\t\t\tlength *= array->bounds [i].length;\n\t}\n\n\tswitch (klass->element_class->byval_arg.type) {\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_BOOLEAN:\n\t\treturn length;\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_CHAR:\n\t\treturn length << 1;\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_R4:\n\t\treturn length << 2;\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\t\treturn length * sizeof (gpointer);\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R8:\n\t\treturn length << 3;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic gint32 \nves_icall_System_Buffer_ByteLengthInternal (MonoArray *array) \n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_array_get_byte_length (array);\n}\n\nstatic gint8 \nves_icall_System_Buffer_GetByteInternal (MonoArray *array, gint32 idx) \n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_array_get (array, gint8, idx);\n}\n\nstatic void \nves_icall_System_Buffer_SetByteInternal (MonoArray *array, gint32 idx, gint8 value) \n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_array_set (array, gint8, idx, value);\n}\n\nstatic MonoBoolean\nves_icall_System_Buffer_BlockCopyInternal (MonoArray *src, gint32 src_offset, MonoArray *dest, gint32 dest_offset, gint32 count) \n{\n\tguint8 *src_buf, *dest_buf;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t/* watch out for integer overflow */\n\tif ((src_offset > mono_array_get_byte_length (src) - count) || (dest_offset > mono_array_get_byte_length (dest) - count))\n\t\treturn FALSE;\n\n\tsrc_buf = (guint8 *)src->vector + src_offset;\n\tdest_buf = (guint8 *)dest->vector + dest_offset;\n\n\tif (src != dest)\n\t\tmemcpy (dest_buf, src_buf, count);\n\telse\n\t\tmemmove (dest_buf, src_buf, count); /* Source and dest are the same array */\n\n\treturn TRUE;\n}\n\nstatic MonoObject *\nves_icall_Remoting_RealProxy_GetTransparentProxy (MonoObject *this, MonoString *class_name)\n{\n\tMonoDomain *domain = mono_object_domain (this); \n\tMonoObject *res;\n\tMonoRealProxy *rp = ((MonoRealProxy *)this);\n\tMonoTransparentProxy *tp;\n\tMonoType *type;\n\tMonoClass *klass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tres = mono_object_new (domain, mono_defaults.transparent_proxy_class);\n\ttp = (MonoTransparentProxy*) res;\n\t\n\tMONO_OBJECT_SETREF (tp, rp, rp);\n\ttype = ((MonoReflectionType *)rp->class_to_proxy)->type;\n\tklass = mono_class_from_mono_type (type);\n\n\ttp->custom_type_info = (mono_object_isinst (this, mono_defaults.iremotingtypeinfo_class) != NULL);\n\ttp->remote_class = mono_remote_class (domain, class_name, klass);\n\n\tres->vtable = mono_remote_class_vtable (domain, tp->remote_class, rp);\n\treturn res;\n}\n\nstatic MonoReflectionType *\nves_icall_Remoting_RealProxy_InternalGetProxyType (MonoTransparentProxy *tp)\n{\n\treturn mono_type_get_object (mono_object_domain (tp), &tp->remote_class->proxy_class->byval_arg);\n}\n\n/* System.Environment */\n\nMonoString*\nves_icall_System_Environment_get_UserName (void)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\t/* using glib is more portable */\n\treturn mono_string_new (mono_domain_get (), g_get_user_name ());\n}\n\n\nstatic MonoString *\nves_icall_System_Environment_get_MachineName (void)\n{\n#if defined (PLATFORM_WIN32)\n\tgunichar2 *buf;\n\tguint32 len;\n\tMonoString *result;\n\n\tlen = MAX_COMPUTERNAME_LENGTH + 1;\n\tbuf = g_new (gunichar2, len);\n\n\tresult = NULL;\n\tif (GetComputerName (buf, (PDWORD) &len))\n\t\tresult = mono_string_new_utf16 (mono_domain_get (), buf, len);\n\n\tg_free (buf);\n\treturn result;\n#elif !defined(DISABLE_SOCKETS)\n\tgchar buf [256];\n\tMonoString *result;\n\n\tif (gethostname (buf, sizeof (buf)) == 0)\n\t\tresult = mono_string_new (mono_domain_get (), buf);\n\telse\n\t\tresult = NULL;\n\t\n\treturn result;\n#else\n\treturn mono_string_new (mono_domain_get (), \"mono\");\n#endif\n}\n\nstatic int\nves_icall_System_Environment_get_Platform (void)\n{\n#if defined (PLATFORM_WIN32)\n\t/* Win32NT */\n\treturn 2;\n#elif defined(__MACH__)\n\t/* OSX */\n\tif (mono_framework_version () < 2)\n\t\treturn 128;\n\n\t//\n\t// For compatibility with our client code, this will be 4 for a while.\n\t// We will eventually move to 6 to match .NET, but it requires all client\n\t// code to be updated and the documentation everywhere to be updated \n\t// first.\n\t//\n\treturn 4;\n#else\n\t/* Unix */\n\tif (mono_framework_version () < 2)\n\t\treturn 128;\n\treturn 4;\n#endif\n}\n\nstatic MonoString *\nves_icall_System_Environment_get_NewLine (void)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n#if defined (PLATFORM_WIN32)\n\treturn mono_string_new (mono_domain_get (), \"\\r\\n\");\n#else\n\treturn mono_string_new (mono_domain_get (), \"\\n\");\n#endif\n}\n\nstatic MonoString *\nves_icall_System_Environment_GetEnvironmentVariable (MonoString *name)\n{\n\tconst gchar *value;\n\tgchar *utf8_name;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (name == NULL)\n\t\treturn NULL;\n\n\tutf8_name = mono_string_to_utf8 (name);\t/* FIXME: this should be ascii */\n\tvalue = g_getenv (utf8_name);\n\n\tg_free (utf8_name);\n\n\tif (value == 0)\n\t\treturn NULL;\n\t\n\treturn mono_string_new (mono_domain_get (), value);\n}\n\n/*\n * There is no standard way to get at environ.\n */\n#ifndef _MSC_VER\n#ifndef __MINGW32_VERSION\n#ifdef __APPLE__\n/* Apple defines this in crt_externs.h but doesn't provide that header for \n * arm-apple-darwin9.  We'll manually define the symbol on Apple as it does\n * in fact exist on all implementations (so far) \n */\ngchar ***_NSGetEnviron(void);\n#define environ (*_NSGetEnviron())\n#else\nextern\nchar **environ;\n#endif\n#endif\n#endif\n\nstatic MonoArray *\nves_icall_System_Environment_GetEnvironmentVariableNames (void)\n{\n#ifdef PLATFORM_WIN32\n\tMonoArray *names;\n\tMonoDomain *domain;\n\tMonoString *str;\n\tWCHAR* env_strings;\n\tWCHAR* env_string;\n\tWCHAR* equal_str;\n\tint n = 0;\n\n\tenv_strings = GetEnvironmentStrings();\n\n\tif (env_strings) {\n\t\tenv_string = env_strings;\n\t\twhile (*env_string != '\\0') {\n\t\t/* weird case that MS seems to skip */\n\t\t\tif (*env_string != '=')\n\t\t\t\tn++;\n\t\t\twhile (*env_string != '\\0')\n\t\t\t\tenv_string++;\n\t\t\tenv_string++;\n\t\t}\n\t}\n\n\tdomain = mono_domain_get ();\n\tnames = mono_array_new (domain, mono_defaults.string_class, n);\n\n\tif (env_strings) {\n\t\tn = 0;\n\t\tenv_string = env_strings;\n\t\twhile (*env_string != '\\0') {\n\t\t\t/* weird case that MS seems to skip */\n\t\t\tif (*env_string != '=') {\n\t\t\t\tequal_str = wcschr(env_string, '=');\n\t\t\t\tg_assert(equal_str);\n\t\t\t\tstr = mono_string_new_utf16 (domain, env_string, equal_str-env_string);\n\t\t\t\tmono_array_setref (names, n, str);\n\t\t\t\tn++;\n\t\t\t}\n\t\t\twhile (*env_string != '\\0')\n\t\t\t\tenv_string++;\n\t\t\tenv_string++;\n\t\t}\n\n\t\tFreeEnvironmentStrings (env_strings);\n\t}\n\n\treturn names;\n\n#else\n\tMonoArray *names;\n\tMonoDomain *domain;\n\tMonoString *str;\n\tgchar **e, **parts;\n\tint n;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tn = 0;\n\tfor (e = environ; *e != 0; ++ e)\n\t\t++ n;\n\n\tdomain = mono_domain_get ();\n\tnames = mono_array_new (domain, mono_defaults.string_class, n);\n\n\tn = 0;\n\tfor (e = environ; *e != 0; ++ e) {\n\t\tparts = g_strsplit (*e, \"=\", 2);\n\t\tif (*parts != 0) {\n\t\t\tstr = mono_string_new (domain, *parts);\n\t\t\tmono_array_setref (names, n, str);\n\t\t}\n\n\t\tg_strfreev (parts);\n\n\t\t++ n;\n\t}\n\n\treturn names;\n#endif\n}\n\n/*\n * If your platform lacks setenv/unsetenv, you must upgrade your glib.\n */\n#if !GLIB_CHECK_VERSION(2,4,0)\n#define g_setenv(a,b,c)   setenv(a,b,c)\n#define g_unsetenv(a) unsetenv(a)\n#endif\n\nstatic void\nves_icall_System_Environment_InternalSetEnvironmentVariable (MonoString *name, MonoString *value)\n{\n\tMonoError error;\n\n#ifdef PLATFORM_WIN32\n\tgunichar2 *utf16_name, *utf16_value;\n#else\n\tgchar *utf8_name, *utf8_value;\n#endif\n\n\tMONO_ARCH_SAVE_REGS;\n\t\n#ifdef PLATFORM_WIN32\n\tutf16_name = mono_string_to_utf16 (name);\n\tif ((value == NULL) || (mono_string_length (value) == 0) || (mono_string_chars (value)[0] == 0)) {\n\t\tSetEnvironmentVariable (utf16_name, NULL);\n\t\tg_free (utf16_name);\n\t\treturn;\n\t}\n\n\tutf16_value = mono_string_to_utf16 (value);\n\n\tSetEnvironmentVariable (utf16_name, utf16_value);\n\n\tg_free (utf16_name);\n\tg_free (utf16_value);\n#else\n\tutf8_name = mono_string_to_utf8 (name);\t/* FIXME: this should be ascii */\n\n\tif ((value == NULL) || (mono_string_length (value) == 0) || (mono_string_chars (value)[0] == 0)) {\n\t\tg_unsetenv (utf8_name);\n\t\tg_free (utf8_name);\n\t\treturn;\n\t}\n\n\tutf8_value = mono_string_to_utf8_checked (value, &error);\n\tif (!mono_error_ok (&error)) {\n\t\tg_free (utf8_name);\n\t\tmono_error_raise_exception (&error);\n\t}\n\tg_setenv (utf8_name, utf8_value, TRUE);\n\n\tg_free (utf8_name);\n\tg_free (utf8_value);\n#endif\n}\n\nstatic void\nves_icall_System_Environment_Exit (int result)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_threads_set_shutting_down ();\n\n\tmono_runtime_set_shutting_down ();\n\n\t/* This will kill the tp threads which cannot be suspended */\n\tmono_thread_pool_cleanup ();\n\n\t/* Suspend all managed threads since the runtime is going away */\n\tmono_thread_suspend_all_other_threads ();\n\n\tmono_runtime_quit ();\n\n\t/* we may need to do some cleanup here... */\n\texit (result);\n}\n\nstatic MonoString*\nves_icall_System_Environment_GetGacPath (void)\n{\n\treturn mono_string_new (mono_domain_get (), mono_assembly_getrootdir ());\n}\n\nstatic MonoString*\nves_icall_System_Environment_GetWindowsFolderPath (int folder)\n{\n#if defined (PLATFORM_WIN32)\n\t#ifndef CSIDL_FLAG_CREATE\n\t\t#define CSIDL_FLAG_CREATE\t0x8000\n\t#endif\n\n\tWCHAR path [MAX_PATH];\n\t/* Create directory if no existing */\n\tif (SUCCEEDED (SHGetFolderPathW (NULL, folder | CSIDL_FLAG_CREATE, NULL, 0, path))) {\n\t\tint len = 0;\n\t\twhile (path [len])\n\t\t\t++ len;\n\t\treturn mono_string_new_utf16 (mono_domain_get (), path, len);\n\t}\n#else\n\tg_warning (\"ves_icall_System_Environment_GetWindowsFolderPath should only be called on Windows!\");\n#endif\n\treturn mono_string_new (mono_domain_get (), \"\");\n}\n\nstatic MonoArray *\nves_icall_System_Environment_GetLogicalDrives (void)\n{\n        gunichar2 buf [256], *ptr, *dname;\n\tgunichar2 *u16;\n\tguint initial_size = 127, size = 128;\n\tgint ndrives;\n\tMonoArray *result;\n\tMonoString *drivestr;\n\tMonoDomain *domain = mono_domain_get ();\n\tgint len;\n\n\tMONO_ARCH_SAVE_REGS;\n\n        buf [0] = '\\0';\n\tptr = buf;\n\n\twhile (size > initial_size) {\n\t\tsize = (guint) GetLogicalDriveStrings (initial_size, ptr);\n\t\tif (size > initial_size) {\n\t\t\tif (ptr != buf)\n\t\t\t\tg_free (ptr);\n\t\t\tptr = g_malloc0 ((size + 1) * sizeof (gunichar2));\n\t\t\tinitial_size = size;\n\t\t\tsize++;\n\t\t}\n\t}\n\n\t/* Count strings */\n\tdname = ptr;\n\tndrives = 0;\n\tdo {\n\t\twhile (*dname++);\n\t\tndrives++;\n\t} while (*dname);\n\n\tdname = ptr;\n\tresult = mono_array_new (domain, mono_defaults.string_class, ndrives);\n\tndrives = 0;\n\tdo {\n\t\tlen = 0;\n\t\tu16 = dname;\n\t\twhile (*u16) { u16++; len ++; }\n\t\tdrivestr = mono_string_new_utf16 (domain, dname, len);\n\t\tmono_array_setref (result, ndrives++, drivestr);\n\t\twhile (*dname++);\n\t} while (*dname);\n\n\tif (ptr != buf)\n\t\tg_free (ptr);\n\n\treturn result;\n}\n\nstatic MonoString *\nves_icall_System_Environment_InternalGetHome (void)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_string_new (mono_domain_get (), g_get_home_dir ());\n}\n\nstatic const char *encodings [] = {\n\t(char *) 1,\n\t\t\"ascii\", \"us_ascii\", \"us\", \"ansi_x3.4_1968\",\n\t\t\"ansi_x3.4_1986\", \"cp367\", \"csascii\", \"ibm367\",\n\t\t\"iso_ir_6\", \"iso646_us\", \"iso_646.irv:1991\",\n\t(char *) 2,\n\t\t\"utf_7\", \"csunicode11utf7\", \"unicode_1_1_utf_7\",\n\t\t\"unicode_2_0_utf_7\", \"x_unicode_1_1_utf_7\",\n\t\t\"x_unicode_2_0_utf_7\",\n\t(char *) 3,\n\t\t\"utf_8\", \"unicode_1_1_utf_8\", \"unicode_2_0_utf_8\",\n\t\t\"x_unicode_1_1_utf_8\", \"x_unicode_2_0_utf_8\",\n\t(char *) 4,\n\t\t\"utf_16\", \"UTF_16LE\", \"ucs_2\", \"unicode\",\n\t\t\"iso_10646_ucs2\",\n\t(char *) 5,\n\t\t\"unicodefffe\", \"utf_16be\",\n\t(char *) 6,\n\t\t\"iso_8859_1\",\n\t(char *) 0\n};\n\n/*\n * Returns the internal codepage, if the value of \"int_code_page\" is\n * 1 at entry, and we can not compute a suitable code page number,\n * returns the code page as a string\n */\nstatic MonoString*\nves_icall_System_Text_Encoding_InternalCodePage (gint32 *int_code_page) \n{\n\tconst char *cset;\n\tconst char *p;\n\tchar *c;\n\tchar *codepage = NULL;\n\tint code;\n\tint want_name = *int_code_page;\n\tint i;\n\t\n\t*int_code_page = -1;\n\tMONO_ARCH_SAVE_REGS;\n\n\tg_get_charset (&cset);\n\tc = codepage = strdup (cset);\n\tfor (c = codepage; *c; c++){\n\t\tif (isascii (*c) && isalpha (*c))\n\t\t\t*c = tolower (*c);\n\t\tif (*c == '-')\n\t\t\t*c = '_';\n\t}\n\t/* g_print (\"charset: %s\\n\", cset); */\n\t\n\t/* handle some common aliases */\n\tp = encodings [0];\n\tcode = 0;\n\tfor (i = 0; p != 0; ){\n\t\tif ((gssize) p < 7){\n\t\t\tcode = (gssize) p;\n\t\t\tp = encodings [++i];\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp (p, codepage) == 0){\n\t\t\t*int_code_page = code;\n\t\t\tbreak;\n\t\t}\n\t\tp = encodings [++i];\n\t}\n\t\n\tif (strstr (codepage, \"utf_8\") != NULL)\n\t\t*int_code_page |= 0x10000000;\n\tfree (codepage);\n\t\n\tif (want_name && *int_code_page == -1)\n\t\treturn mono_string_new (mono_domain_get (), cset);\n\telse\n\t\treturn NULL;\n}\n\nstatic MonoBoolean\nves_icall_System_Environment_get_HasShutdownStarted (void)\n{\n\tif (mono_runtime_is_shutting_down ())\n\t\treturn TRUE;\n\n\tif (mono_domain_is_unloading (mono_domain_get ()))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic void\nves_icall_System_Environment_BroadcastSettingChange (void)\n{\n#ifdef PLATFORM_WIN32\n\tSendMessageTimeout (HWND_BROADCAST, WM_SETTINGCHANGE, NULL, L\"Environment\", SMTO_ABORTIFHUNG, 2000, 0);\n#endif\n}\n\nstatic void\nves_icall_MonoMethodMessage_InitMessage (MonoMethodMessage *this, \n\t\t\t\t\t MonoReflectionMethod *method,\n\t\t\t\t\t MonoArray *out_args)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_message_init (mono_object_domain (this), this, method, out_args);\n}\n\nstatic MonoBoolean\nves_icall_IsTransparentProxy (MonoObject *proxy)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!proxy)\n\t\treturn 0;\n\n\tif (proxy->vtable->klass == mono_defaults.transparent_proxy_class)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic MonoReflectionMethod *\nves_icall_Remoting_RemotingServices_GetVirtualMethod (\n\tMonoReflectionType *rtype, MonoReflectionMethod *rmethod)\n{\n\tMonoClass *klass;\n\tMonoMethod *method;\n\tMonoMethod **vtable;\n\tMonoMethod *res = NULL;\n\n\tMONO_CHECK_ARG_NULL (rtype);\n\tMONO_CHECK_ARG_NULL (rmethod);\n\n\tmethod = rmethod->method;\n\tklass = mono_class_from_mono_type (rtype->type);\n\n\tif (MONO_CLASS_IS_INTERFACE (klass))\n\t\treturn NULL;\n\n\tif (method->flags & METHOD_ATTRIBUTE_STATIC)\n\t\treturn NULL;\n\n\tif ((method->flags & METHOD_ATTRIBUTE_FINAL) || !(method->flags & METHOD_ATTRIBUTE_VIRTUAL)) {\n\t\tif (klass == method->klass || mono_class_is_subclass_of (klass, method->klass, FALSE))\n\t\t\treturn rmethod;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tmono_class_setup_vtable (klass);\n\tvtable = klass->vtable;\n\n\tif (method->klass->flags & TYPE_ATTRIBUTE_INTERFACE) {\n\t\tint offs = mono_class_interface_offset (klass, method->klass);\n\t\tif (offs >= 0)\n\t\t\tres = vtable [offs + method->slot];\n\t} else {\n\t\tif (!(klass == method->klass || mono_class_is_subclass_of (klass, method->klass, FALSE)))\n\t\t\treturn NULL;\n\n\t\tif (method->slot != -1)\n\t\t\tres = vtable [method->slot];\n\t}\n\n\tif (!res)\n\t\treturn NULL;\n\n\treturn mono_method_get_object (mono_domain_get (), res, NULL);\n}\n\nstatic void\nves_icall_System_Runtime_Activation_ActivationServices_EnableProxyActivation (MonoReflectionType *type, MonoBoolean enable)\n{\n\tMonoClass *klass;\n\tMonoVTable* vtable;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (type->type);\n\tvtable = mono_class_vtable_full (mono_domain_get (), klass, TRUE);\n\n\tif (enable) vtable->remote = 1;\n\telse vtable->remote = 0;\n}\n\nstatic MonoObject *\nves_icall_System_Runtime_Activation_ActivationServices_AllocateUninitializedClassInstance (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMonoDomain *domain;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = mono_object_domain (type);\n\tklass = mono_class_from_mono_type (type->type);\n\n\tif (klass->rank >= 1) {\n\t\tg_assert (klass->rank == 1);\n\t\treturn (MonoObject *) mono_array_new (domain, klass->element_class, 0);\n\t} else {\n\t\t/* Bypass remoting object creation check */\n\t\treturn mono_object_new_alloc_specific (mono_class_vtable_full (domain, klass, TRUE));\n\t}\n}\n\nstatic MonoString *\nves_icall_System_IO_get_temp_path (void)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_string_new (mono_domain_get (), g_get_tmp_dir ());\n}\n\n#ifndef PLATFORM_NO_DRIVEINFO\nstatic MonoBoolean\nves_icall_System_IO_DriveInfo_GetDiskFreeSpace (MonoString *path_name, guint64 *free_bytes_avail,\n\t\t\t\t\t\tguint64 *total_number_of_bytes, guint64 *total_number_of_free_bytes,\n\t\t\t\t\t\tgint32 *error)\n{\n\tgboolean result;\n\tULARGE_INTEGER wapi_free_bytes_avail;\n\tULARGE_INTEGER wapi_total_number_of_bytes;\n\tULARGE_INTEGER wapi_total_number_of_free_bytes;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t*error = ERROR_SUCCESS;\n\tresult = GetDiskFreeSpaceEx (mono_string_chars (path_name), &wapi_free_bytes_avail, &wapi_total_number_of_bytes,\n\t\t\t\t     &wapi_total_number_of_free_bytes);\n\n\tif (result) {\n\t\t*free_bytes_avail = wapi_free_bytes_avail.QuadPart;\n\t\t*total_number_of_bytes = wapi_total_number_of_bytes.QuadPart;\n\t\t*total_number_of_free_bytes = wapi_total_number_of_free_bytes.QuadPart;\n\t} else {\n\t\t*free_bytes_avail = 0;\n\t\t*total_number_of_bytes = 0;\n\t\t*total_number_of_free_bytes = 0;\n\t\t*error = GetLastError ();\n\t}\n\n\treturn result;\n}\n\nstatic guint32\nves_icall_System_IO_DriveInfo_GetDriveType (MonoString *root_path_name)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn GetDriveType (mono_string_chars (root_path_name));\n}\n#endif\n\nstatic gpointer\nves_icall_RuntimeMethod_GetFunctionPointer (MonoMethod *method)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_compile_method (method);\n}\n\nstatic MonoString *\nves_icall_System_Configuration_DefaultConfig_get_machine_config_path (void)\n{\n\tMonoString *mcpath;\n\tgchar *path;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tpath = g_build_path (G_DIR_SEPARATOR_S, mono_get_config_dir (), \"mono\", mono_get_runtime_info ()->framework_version, \"machine.config\", NULL);\n\n#if defined (PLATFORM_WIN32)\n\t/* Avoid mixing '/' and '\\\\' */\n\t{\n\t\tgint i;\n\t\tfor (i = strlen (path) - 1; i >= 0; i--)\n\t\t\tif (path [i] == '/')\n\t\t\t\tpath [i] = '\\\\';\n\t}\n#endif\n\tmcpath = mono_string_new (mono_domain_get (), path);\n\tg_free (path);\n\n\treturn mcpath;\n}\n\nstatic MonoString *\nget_bundled_machine_config (void)\n{\n\tconst gchar *machine_config;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmachine_config = mono_get_machine_config ();\n\n\tif (!machine_config)\n\t\treturn NULL;\n\n\treturn mono_string_new (mono_domain_get (), machine_config);\n}\n\nstatic MonoString *\nves_icall_System_Web_Util_ICalls_get_machine_install_dir (void)\n{\n\tMonoString *ipath;\n\tgchar *path;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tpath = g_path_get_dirname (mono_get_config_dir ());\n\n#if defined (PLATFORM_WIN32)\n\t/* Avoid mixing '/' and '\\\\' */\n\t{\n\t\tgint i;\n\t\tfor (i = strlen (path) - 1; i >= 0; i--)\n\t\t\tif (path [i] == '/')\n\t\t\t\tpath [i] = '\\\\';\n\t}\n#endif\n\tipath = mono_string_new (mono_domain_get (), path);\n\tg_free (path);\n\n\treturn ipath;\n}\n\nstatic gboolean\nves_icall_get_resources_ptr (MonoReflectionAssembly *assembly, gpointer *result, gint32 *size)\n{\n\tMonoPEResourceDataEntry *entry;\n\tMonoImage *image;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!assembly || !result || !size)\n\t\treturn FALSE;\n\n\t*result = NULL;\n\t*size = 0;\n\timage = assembly->assembly->image;\n\tentry = mono_image_lookup_resource (image, MONO_PE_RESOURCE_ID_ASPNET_STRING, 0, NULL);\n\tif (!entry)\n\t\treturn FALSE;\n\n\t*result = mono_image_rva_map (image, entry->rde_data_offset);\n\tif (!(*result)) {\n\t\tg_free (entry);\n\t\treturn FALSE;\n\t}\n\t*size = entry->rde_size;\n\tg_free (entry);\n\treturn TRUE;\n}\n\nstatic MonoBoolean\nves_icall_System_Diagnostics_Debugger_IsAttached_internal (void)\n{\n\treturn mono_debug_using_mono_debugger () || mono_is_debugger_attached ();\n}\n\nstatic void\nves_icall_System_Diagnostics_DefaultTraceListener_WriteWindowsDebugString (MonoString *message)\n{\n#if defined (PLATFORM_WIN32)\n\tOutputDebugString (mono_string_chars (message));\n#else\n\tg_warning (\"WriteWindowsDebugString called and PLATFORM_WIN32 not defined!\\n\");\n#endif\n}\n\n/* Only used for value types */\nstatic MonoObject *\nves_icall_System_Activator_CreateInstanceInternal (MonoReflectionType *type)\n{\n\tMonoClass *klass;\n\tMonoDomain *domain;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = mono_object_domain (type);\n\tklass = mono_class_from_mono_type (type->type);\n\n\tif (mono_class_is_nullable (klass))\n\t\t/* No arguments -> null */\n\t\treturn NULL;\n\n\treturn mono_object_new (domain, klass);\n}\n\nstatic MonoReflectionMethod *\nves_icall_MonoMethod_get_base_definition (MonoReflectionMethod *m)\n{\n\tMonoClass *klass, *parent;\n\tMonoMethod *method = m->method;\n\tMonoMethod *result = NULL;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (method->klass == NULL)\n\t\treturn m;\n\n\tif (!(method->flags & METHOD_ATTRIBUTE_VIRTUAL) ||\n\t    MONO_CLASS_IS_INTERFACE (method->klass) ||\n\t    method->flags & METHOD_ATTRIBUTE_NEW_SLOT)\n\t\treturn m;\n\n\tklass = method->klass;\n\tif (klass->generic_class)\n\t\tklass = klass->generic_class->container_class;\n\n\t/* At the end of the loop, klass points to the eldest class that has this virtual function slot. */\n\tfor (parent = klass->parent; parent != NULL; parent = parent->parent) {\n\t\tmono_class_setup_vtable (parent);\n\t\tif (parent->vtable_size <= method->slot)\n\t\t\tbreak;\n\t\tklass = parent;\n\t}\t\t\n\n\tif (klass == method->klass)\n\t\treturn m;\n\n\tresult = klass->vtable [method->slot];\n\tif (result == NULL) {\n\t\t/* It is an abstract method */\n\t\tgpointer iter = NULL;\n\t\twhile ((result = mono_class_get_methods (klass, &iter)))\n\t\t\tif (result->slot == method->slot)\n\t\t\t\tbreak;\n\t}\n\n\tif (result == NULL)\n\t\treturn m;\n\n\treturn mono_method_get_object (mono_domain_get (), result, NULL);\n}\n\nstatic MonoString*\nves_icall_MonoMethod_get_name (MonoReflectionMethod *m)\n{\n\tMonoMethod *method = m->method;\n\n\tMONO_OBJECT_SETREF (m, name, mono_string_new (mono_object_domain (m), method->name));\n\treturn m->name;\n}\n\nstatic void\nmono_ArgIterator_Setup (MonoArgIterator *iter, char* argsp, char* start)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\titer->sig = *(MonoMethodSignature**)argsp;\n\t\n\tg_assert (iter->sig->sentinelpos <= iter->sig->param_count);\n\tg_assert (iter->sig->call_convention == MONO_CALL_VARARG);\n\n\titer->next_arg = 0;\n\t/* FIXME: it's not documented what start is exactly... */\n\tif (start) {\n\t\titer->args = start;\n\t} else {\n\t\titer->args = argsp + sizeof (gpointer);\n#ifndef MONO_ARCH_REGPARMS\n\t\t{\n\t\tguint32 i, arg_size;\n\t\tgint32 align;\n\t\tfor (i = 0; i < iter->sig->sentinelpos; ++i) {\n\t\t\targ_size = mono_type_stack_size (iter->sig->params [i], &align);\n\t\t\titer->args = (char*)iter->args + arg_size;\n\t\t}\n\t\t}\n#endif\n\t}\n\titer->num_args = iter->sig->param_count - iter->sig->sentinelpos;\n\n\t/* g_print (\"sig %p, param_count: %d, sent: %d\\n\", iter->sig, iter->sig->param_count, iter->sig->sentinelpos); */\n}\n\nstatic MonoTypedRef\nmono_ArgIterator_IntGetNextArg (MonoArgIterator *iter)\n{\n\tguint32 i, arg_size;\n\tgint32 align;\n\tMonoTypedRef res;\n\tMONO_ARCH_SAVE_REGS;\n\n\ti = iter->sig->sentinelpos + iter->next_arg;\n\n\tg_assert (i < iter->sig->param_count);\n\n\tres.type = iter->sig->params [i];\n\tres.klass = mono_class_from_mono_type (res.type);\n\tres.value = iter->args;\n\targ_size = mono_type_stack_size (res.type, &align);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\tif (arg_size <= sizeof (gpointer)) {\n\t\tint dummy;\n\t\tint padding = arg_size - mono_type_size (res.type, &dummy);\n\t\tres.value = (guint8*)res.value + padding;\n\t}\n#endif\n\titer->args = (char*)iter->args + arg_size;\n\titer->next_arg++;\n\n\t/* g_print (\"returning arg %d, type 0x%02x of size %d at %p\\n\", i, res.type->type, arg_size, res.value); */\n\n\treturn res;\n}\n\nstatic MonoTypedRef\nmono_ArgIterator_IntGetNextArgT (MonoArgIterator *iter, MonoType *type)\n{\n\tguint32 i, arg_size;\n\tgint32 align;\n\tMonoTypedRef res;\n\tMONO_ARCH_SAVE_REGS;\n\n\ti = iter->sig->sentinelpos + iter->next_arg;\n\n\tg_assert (i < iter->sig->param_count);\n\n\twhile (i < iter->sig->param_count) {\n\t\tif (!mono_metadata_type_equal (type, iter->sig->params [i]))\n\t\t\tcontinue;\n\t\tres.type = iter->sig->params [i];\n\t\tres.klass = mono_class_from_mono_type (res.type);\n\t\t/* FIXME: endianess issue... */\n\t\tres.value = iter->args;\n\t\targ_size = mono_type_stack_size (res.type, &align);\n\t\titer->args = (char*)iter->args + arg_size;\n\t\titer->next_arg++;\n\t\t/* g_print (\"returning arg %d, type 0x%02x of size %d at %p\\n\", i, res.type->type, arg_size, res.value); */\n\t\treturn res;\n\t}\n\t/* g_print (\"arg type 0x%02x not found\\n\", res.type->type); */\n\n\tres.type = NULL;\n\tres.value = NULL;\n\tres.klass = NULL;\n\treturn res;\n}\n\nstatic MonoType*\nmono_ArgIterator_IntGetNextArgType (MonoArgIterator *iter)\n{\n\tgint i;\n\tMONO_ARCH_SAVE_REGS;\n\t\n\ti = iter->sig->sentinelpos + iter->next_arg;\n\n\tg_assert (i < iter->sig->param_count);\n\n\treturn iter->sig->params [i];\n}\n\nstatic MonoObject*\nmono_TypedReference_ToObject (MonoTypedRef tref)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (MONO_TYPE_IS_REFERENCE (tref.type)) {\n\t\tMonoObject** objp = tref.value;\n\t\treturn *objp;\n\t}\n\n\treturn mono_value_box (mono_domain_get (), tref.klass, tref.value);\n}\n\nstatic MonoObject*\nmono_TypedReference_ToObjectInternal (MonoType *type, gpointer value, MonoClass *klass)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (MONO_TYPE_IS_REFERENCE (type)) {\n\t\tMonoObject** objp = value;\n\t\treturn *objp;\n\t}\n\n\treturn mono_value_box (mono_domain_get (), klass, value);\n}\n\nstatic void\nprelink_method (MonoMethod *method)\n{\n\tconst char *exc_class, *exc_arg;\n\tif (!(method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))\n\t\treturn;\n\tmono_lookup_pinvoke_call (method, &exc_class, &exc_arg);\n\tif (exc_class) {\n\t\tmono_raise_exception( \n\t\t\tmono_exception_from_name_msg (mono_defaults.corlib, \"System\", exc_class, exc_arg ) );\n\t}\n\t/* create the wrapper, too? */\n}\n\nstatic void\nves_icall_System_Runtime_InteropServices_Marshal_Prelink (MonoReflectionMethod *method)\n{\n\tMONO_ARCH_SAVE_REGS;\n\tprelink_method (method->method);\n}\n\nstatic void\nves_icall_System_Runtime_InteropServices_Marshal_PrelinkAll (MonoReflectionType *type)\n{\n\tMonoClass *klass = mono_class_from_mono_type (type->type);\n\tMonoMethod* m;\n\tgpointer iter = NULL;\n\tMONO_ARCH_SAVE_REGS;\n\n\twhile ((m = mono_class_get_methods (klass, &iter)))\n\t\tprelink_method (m);\n}\n\n/* These parameters are \"readonly\" in corlib/System/NumberFormatter.cs */\nstatic void\nves_icall_System_NumberFormatter_GetFormatterTables (guint64 const **mantissas,\n\t\t\t\t\t    gint32 const **exponents,\n\t\t\t\t\t    gunichar2 const **digitLowerTable,\n\t\t\t\t\t    gunichar2 const **digitUpperTable,\n\t\t\t\t\t    gint64 const **tenPowersList,\n\t\t\t\t\t    gint32 const **decHexDigits)\n{\n\t*mantissas = Formatter_MantissaBitsTable;\n\t*exponents = Formatter_TensExponentTable;\n\t*digitLowerTable = Formatter_DigitLowerTable;\n\t*digitUpperTable = Formatter_DigitUpperTable;\n\t*tenPowersList = Formatter_TenPowersList;\n\t*decHexDigits = Formatter_DecHexDigits;\n}\n\n/* These parameters are \"readonly\" in corlib/System/Char.cs */\nstatic void\nves_icall_System_Char_GetDataTablePointers (guint8 const **category_data,\n\t\t\t\t\t    guint8 const **numeric_data,\n\t\t\t\t\t    gdouble const **numeric_data_values,\n\t\t\t\t\t    guint16 const **to_lower_data_low,\n\t\t\t\t\t    guint16 const **to_lower_data_high,\n\t\t\t\t\t    guint16 const **to_upper_data_low,\n\t\t\t\t\t    guint16 const **to_upper_data_high)\n{\n\t*category_data = CategoryData;\n\t*numeric_data = NumericData;\n\t*numeric_data_values = NumericDataValues;\n\t*to_lower_data_low = ToLowerDataLow;\n\t*to_lower_data_high = ToLowerDataHigh;\n\t*to_upper_data_low = ToUpperDataLow;\n\t*to_upper_data_high = ToUpperDataHigh;\n}\n\nstatic gint32\nves_icall_MonoDebugger_GetMethodToken (MonoReflectionMethod *method)\n{\n\treturn method->method->token;\n}\n\n/*\n * We return NULL for no modifiers so the corlib code can return Type.EmptyTypes\n * and avoid useless allocations.\n */\nstatic MonoArray*\ntype_array_from_modifiers (MonoImage *image, MonoType *type, int optional)\n{\n\tMonoArray *res;\n\tint i, count = 0;\n\tfor (i = 0; i < type->num_mods; ++i) {\n\t\tif ((optional && !type->modifiers [i].required) || (!optional && type->modifiers [i].required))\n\t\t\tcount++;\n\t}\n\tif (!count)\n\t\treturn NULL;\n\tres = mono_array_new (mono_domain_get (), mono_defaults.systemtype_class, count);\n\tcount = 0;\n\tfor (i = 0; i < type->num_mods; ++i) {\n\t\tif ((optional && !type->modifiers [i].required) || (!optional && type->modifiers [i].required)) {\n\t\t\tMonoClass *klass = mono_class_get (image, type->modifiers [i].token);\n\t\t\tmono_array_setref (res, count, mono_type_get_object (mono_domain_get (), &klass->byval_arg));\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic MonoArray*\nparam_info_get_type_modifiers (MonoReflectionParameter *param, MonoBoolean optional)\n{\n\tMonoType *type = param->ClassImpl->type;\n\tMonoClass *member_class = mono_object_class (param->MemberImpl);\n\tMonoMethod *method = NULL;\n\tMonoImage *image;\n\tint pos;\n\tMonoMethodSignature *sig;\n\n\tif (mono_class_is_reflection_method_or_constructor (member_class)) {\n\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)param->MemberImpl;\n\t\tmethod = rmethod->method;\n\t} else if (member_class->image == mono_defaults.corlib && !strcmp (\"MonoProperty\", member_class->name)) {\n\t\tMonoReflectionProperty *prop = (MonoReflectionProperty *)param->MemberImpl;\n\t\tif (!(method = prop->property->get))\n\t\t\tmethod = prop->property->set;\n\t\tg_assert (method);\t\n\t} else {\n\t\tchar *type_name = mono_type_get_full_name (member_class);\n\t\tchar *msg = g_strdup_printf (\"Custom modifiers on a ParamInfo with member %s are not supported\", type_name);\n\t\tMonoException *ex = mono_get_exception_not_supported  (msg);\n\t\tg_free (type_name);\n\t\tg_free (msg);\n\t\tmono_raise_exception (ex);\n\t}\n\n\timage = method->klass->image;\n\tpos = param->PositionImpl;\n\tsig = mono_method_signature (method);\n\tif (pos == -1)\n\t\ttype = sig->ret;\n\telse\n\t\ttype = sig->params [pos];\n\n\treturn type_array_from_modifiers (image, type, optional);\n}\n\nstatic MonoType*\nget_property_type (MonoProperty *prop)\n{\n\tMonoMethodSignature *sig;\n\tif (prop->get) {\n\t\tsig = mono_method_signature (prop->get);\n\t\treturn sig->ret;\n\t} else if (prop->set) {\n\t\tsig = mono_method_signature (prop->set);\n\t\treturn sig->params [sig->param_count - 1];\n\t}\n\treturn NULL;\n}\n\nstatic MonoArray*\nproperty_info_get_type_modifiers (MonoReflectionProperty *property, MonoBoolean optional)\n{\n\tMonoType *type = get_property_type (property->property);\n\tMonoImage *image = property->klass->image;\n\n\tif (!type)\n\t\treturn NULL;\n\treturn type_array_from_modifiers (image, type, optional);\n}\n\nstatic MonoBoolean\ncustom_attrs_defined_internal (MonoObject *obj, MonoReflectionType *attr_type)\n{\n\tMonoCustomAttrInfo *cinfo;\n\tgboolean found;\n\n\tcinfo = mono_reflection_get_custom_attrs_info (obj);\n\tif (!cinfo)\n\t\treturn FALSE;\n\tfound = mono_custom_attrs_has_attr (cinfo, mono_class_from_mono_type (attr_type->type));\n\tif (!cinfo->cached)\n\t\tmono_custom_attrs_free (cinfo);\n\treturn found;\n}\n\nstatic MonoArray*\ncustom_attrs_get_by_type (MonoObject *obj, MonoReflectionType *attr_type)\n{\n\tMonoArray *res = mono_reflection_get_custom_attrs_by_type (obj, attr_type ? mono_class_from_mono_type (attr_type->type) : NULL);\n\n\tif (mono_loader_get_last_error ()) {\n\t\tmono_raise_exception (mono_loader_error_prepare_exception (mono_loader_get_last_error ()));\n\t\tg_assert_not_reached ();\n\t\t/* Not reached */\n\t\treturn NULL;\n\t} else {\n\t\treturn res;\n\t}\n}\n\nstatic MonoString*\nves_icall_Mono_Runtime_GetDisplayName (void)\n{\n\tchar *info;\n\tMonoString *display_name;\n\n\tinfo = mono_get_runtime_callbacks ()->get_runtime_build_info ();\n\tdisplay_name = mono_string_new (mono_domain_get (), info);\n\tg_free (info);\n\treturn display_name;\n}\n\nstatic MonoString*\nves_icall_System_ComponentModel_Win32Exception_W32ErrorMessage (guint32 code)\n{\n\tMonoString *message;\n\tguint32 ret;\n\tgunichar2 buf[256];\n\t\n\tret = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\t     FORMAT_MESSAGE_IGNORE_INSERTS, NULL, code, 0,\n\t\t\t     buf, 255, NULL);\n\tif (ret == 0) {\n\t\tmessage = mono_string_new (mono_domain_get (), \"Error looking up error string\");\n\t} else {\n\t\tmessage = mono_string_new_utf16 (mono_domain_get (), buf, ret);\n\t}\n\t\n\treturn message;\n}\n\nconst static guchar\ndbase64 [] = {\n\t128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,\n\t128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,\n\t128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 62, 128, 128, 128, 63,\n\t52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 128, 128, 128, 0, 128, 128,\n\t128, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n\t15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 128, 128, 128, 128, 128,\n\t128, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n\t41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n};\n\nstatic MonoArray *\nbase64_to_byte_array (gunichar2 *start, gint ilength, MonoBoolean allowWhitespaceOnly)\n{\n\tgint ignored;\n\tgint i;\n\tgunichar2 c;\n\tgunichar2 last, prev_last, prev2_last;\n\tgint olength;\n\tMonoArray *result;\n\tguchar *res_ptr;\n\tgint a [4], b [4];\n\tMonoException *exc;\n\n\tignored = 0;\n\tlast = prev_last = 0, prev2_last = 0;\n\tfor (i = 0; i < ilength; i++) {\n\t\tc = start [i];\n\t\tif (c >= sizeof (dbase64)) {\n\t\t\texc = mono_exception_from_name_msg (mono_get_corlib (),\n\t\t\t\t\"System\", \"FormatException\",\n\t\t\t\t\"Invalid character found.\");\n\t\t\tmono_raise_exception (exc);\n\t\t} else if (isspace (c)) {\n\t\t\tignored++;\n\t\t} else {\n\t\t\tprev2_last = prev_last;\n\t\t\tprev_last = last;\n\t\t\tlast = c;\n\t\t}\n\t}\n\n\tolength = ilength - ignored;\n\n\tif (allowWhitespaceOnly && olength == 0) {\n\t\treturn mono_array_new (mono_domain_get (), mono_defaults.byte_class, 0);\n\t}\n\n\tif ((olength & 3) != 0 || olength <= 0) {\n\t\texc = mono_exception_from_name_msg (mono_get_corlib (), \"System\",\n\t\t\t\t\t\"FormatException\", \"Invalid length.\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tif (prev2_last == '=') {\n\t\texc = mono_exception_from_name_msg (mono_get_corlib (), \"System\", \"FormatException\", \"Invalid format.\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tolength = (olength * 3) / 4;\n\tif (last == '=')\n\t\tolength--;\n\n\tif (prev_last == '=')\n\t\tolength--;\n\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, olength);\n\tres_ptr = mono_array_addr (result, guchar, 0);\n\tfor (i = 0; i < ilength; ) {\n\t\tint k;\n\n\t\tfor (k = 0; k < 4 && i < ilength;) {\n\t\t\tc = start [i++];\n\t\t\tif (isspace (c))\n\t\t\t\tcontinue;\n\n\t\t\ta [k] = (guchar) c;\n\t\t\tif (((b [k] = dbase64 [c]) & 0x80) != 0) {\n\t\t\t\texc = mono_exception_from_name_msg (mono_get_corlib (),\n\t\t\t\t\t\"System\", \"FormatException\",\n\t\t\t\t\t\"Invalid character found.\");\n\t\t\t\tmono_raise_exception (exc);\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\t*res_ptr++ = (b [0] << 2) | (b [1] >> 4);\n\t\tif (a [2] != '=')\n\t\t\t*res_ptr++ = (b [1] << 4) | (b [2] >> 2);\n\t\tif (a [3] != '=')\n\t\t\t*res_ptr++ = (b [2] << 6) | b [3];\n\n\t\twhile (i < ilength && isspace (start [i]))\n\t\t\ti++;\n\t}\n\n\treturn result;\n}\n\nstatic MonoArray *\nInternalFromBase64String (MonoString *str, MonoBoolean allowWhitespaceOnly)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn base64_to_byte_array (mono_string_chars (str), \n\t\tmono_string_length (str), allowWhitespaceOnly);\n}\n\nstatic MonoArray *\nInternalFromBase64CharArray (MonoArray *input, gint offset, gint length)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn base64_to_byte_array (mono_array_addr (input, gunichar2, offset),\n\t\tlength, FALSE);\n}\n\n#define ICALL_TYPE(id,name,first)\n#define ICALL(id,name,func) Icall_ ## id,\n\nenum {\n#include \"metadata/icall-def.h\"\n\tIcall_last\n};\n\n#undef ICALL_TYPE\n#undef ICALL\n#define ICALL_TYPE(id,name,first) Icall_type_ ## id,\n#define ICALL(id,name,func)\nenum {\n#include \"metadata/icall-def.h\"\n\tIcall_type_num\n};\n\n#undef ICALL_TYPE\n#undef ICALL\n#define ICALL_TYPE(id,name,firstic) {(Icall_ ## firstic)},\n#define ICALL(id,name,func)\ntypedef struct {\n\tguint16 first_icall;\n} IcallTypeDesc;\n\nstatic const IcallTypeDesc\nicall_type_descs [] = {\n#include \"metadata/icall-def.h\"\n\t{Icall_last}\n};\n\n#define icall_desc_num_icalls(desc) ((desc) [1].first_icall - (desc) [0].first_icall)\n\n#undef ICALL_TYPE\n#define ICALL_TYPE(id,name,first)\n#undef ICALL\n\n#ifdef HAVE_ARRAY_ELEM_INIT\n#define MSGSTRFIELD(line) MSGSTRFIELD1(line)\n#define MSGSTRFIELD1(line) str##line\n\nstatic const struct msgstrtn_t {\n#define ICALL(id,name,func)\n#undef ICALL_TYPE\n#define ICALL_TYPE(id,name,first) char MSGSTRFIELD(__LINE__) [sizeof (name)];\n#include \"metadata/icall-def.h\"\n#undef ICALL_TYPE\n} icall_type_names_str = {\n#define ICALL_TYPE(id,name,first) (name),\n#include \"metadata/icall-def.h\"\n#undef ICALL_TYPE\n};\nstatic const guint16 icall_type_names_idx [] = {\n#define ICALL_TYPE(id,name,first) [Icall_type_ ## id] = offsetof (struct msgstrtn_t, MSGSTRFIELD(__LINE__)),\n#include \"metadata/icall-def.h\"\n#undef ICALL_TYPE\n};\n#define icall_type_name_get(id) ((const char*)&icall_type_names_str + icall_type_names_idx [(id)])\n\nstatic const struct msgstr_t {\n#undef ICALL\n#define ICALL_TYPE(id,name,first)\n#define ICALL(id,name,func) char MSGSTRFIELD(__LINE__) [sizeof (name)];\n#include \"metadata/icall-def.h\"\n#undef ICALL\n} icall_names_str = {\n#define ICALL(id,name,func) (name),\n#include \"metadata/icall-def.h\"\n#undef ICALL\n};\nstatic const guint16 icall_names_idx [] = {\n#define ICALL(id,name,func) [Icall_ ## id] = offsetof (struct msgstr_t, MSGSTRFIELD(__LINE__)),\n#include \"metadata/icall-def.h\"\n#undef ICALL\n};\n#define icall_name_get(id) ((const char*)&icall_names_str + icall_names_idx [(id)])\n\n#else\n\n#undef ICALL_TYPE\n#undef ICALL\n#define ICALL_TYPE(id,name,first) name,\n#define ICALL(id,name,func)\nstatic const char* const\nicall_type_names [] = {\n#include \"metadata/icall-def.h\"\n\tNULL\n};\n\n#define icall_type_name_get(id) (icall_type_names [(id)])\n\n#undef ICALL_TYPE\n#undef ICALL\n#define ICALL_TYPE(id,name,first)\n#define ICALL(id,name,func) name,\nstatic const char* const\nicall_names [] = {\n#include \"metadata/icall-def.h\"\n\tNULL\n};\n#define icall_name_get(id) icall_names [(id)]\n\n#endif /* !HAVE_ARRAY_ELEM_INIT */\n\n#undef ICALL_TYPE\n#undef ICALL\n#define ICALL_TYPE(id,name,first)\n#define ICALL(id,name,func) func,\nstatic const gconstpointer\nicall_functions [] = {\n#include \"metadata/icall-def.h\"\n\tNULL\n};\n\nstatic GHashTable *icall_hash = NULL;\nstatic GHashTable *jit_icall_hash_name = NULL;\nstatic GHashTable *jit_icall_hash_addr = NULL;\n\nvoid\nmono_icall_init (void)\n{\n\tint i = 0;\n\n\t/* check that tables are sorted: disable in release */\n\tif (TRUE) {\n\t\tint j;\n\t\tconst char *prev_class = NULL;\n\t\tconst char *prev_method;\n\t\t\n\t\tfor (i = 0; i < Icall_type_num; ++i) {\n\t\t\tconst IcallTypeDesc *desc;\n\t\t\tint num_icalls;\n\t\t\tprev_method = NULL;\n\t\t\tif (prev_class && strcmp (prev_class, icall_type_name_get (i)) >= 0)\n\t\t\t\tg_print (\"class %s should come before class %s\\n\", icall_type_name_get (i), prev_class);\n\t\t\tprev_class = icall_type_name_get (i);\n\t\t\tdesc = &icall_type_descs [i];\n\t\t\tnum_icalls = icall_desc_num_icalls (desc);\n\t\t\t/*g_print (\"class %s has %d icalls starting at %d\\n\", prev_class, num_icalls, desc->first_icall);*/\n\t\t\tfor (j = 0; j < num_icalls; ++j) {\n\t\t\t\tconst char *methodn = icall_name_get (desc->first_icall + j);\n\t\t\t\tif (prev_method && strcmp (prev_method, methodn) >= 0)\n\t\t\t\t\tg_print (\"method %s should come before method %s\\n\", methodn, prev_method);\n\t\t\t\tprev_method = methodn;\n\t\t\t}\n\t\t}\n\t}\n\n\ticall_hash = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}\n\nvoid\nmono_icall_cleanup (void)\n{\n\tg_hash_table_destroy (icall_hash);\n\tg_hash_table_destroy (jit_icall_hash_name);\n\tg_hash_table_destroy (jit_icall_hash_addr);\n}\n\nvoid\nmono_add_internal_call (const char *name, gconstpointer method)\n{\n\tmono_loader_lock ();\n\n\tg_hash_table_insert (icall_hash, g_strdup (name), (gpointer) method);\n\n\tmono_loader_unlock ();\n}\n\n#ifdef HAVE_ARRAY_ELEM_INIT\nstatic int\ncompare_method_imap (const void *key, const void *elem)\n{\n\tconst char* method_name = (const char*)&icall_names_str + (*(guint16*)elem);\n\treturn strcmp (key, method_name);\n}\n\nstatic gpointer\nfind_method_icall (const IcallTypeDesc *imap, const char *name)\n{\n\tconst guint16 *nameslot = bsearch (name, icall_names_idx + imap->first_icall, icall_desc_num_icalls (imap), sizeof (icall_names_idx [0]), compare_method_imap);\n\tif (!nameslot)\n\t\treturn NULL;\n\treturn (gpointer)icall_functions [(nameslot - &icall_names_idx [0])];\n}\n\nstatic int\ncompare_class_imap (const void *key, const void *elem)\n{\n\tconst char* class_name = (const char*)&icall_type_names_str + (*(guint16*)elem);\n\treturn strcmp (key, class_name);\n}\n\nstatic const IcallTypeDesc*\nfind_class_icalls (const char *name)\n{\n\tconst guint16 *nameslot = bsearch (name, icall_type_names_idx, Icall_type_num, sizeof (icall_type_names_idx [0]), compare_class_imap);\n\tif (!nameslot)\n\t\treturn NULL;\n\treturn &icall_type_descs [nameslot - &icall_type_names_idx [0]];\n}\n\n#else\nstatic int\ncompare_method_imap (const void *key, const void *elem)\n{\n\tconst char** method_name = (const char**)elem;\n\treturn strcmp (key, *method_name);\n}\n\nstatic gpointer\nfind_method_icall (const IcallTypeDesc *imap, const char *name)\n{\n\tconst char **nameslot = bsearch (name, icall_names + imap->first_icall, icall_desc_num_icalls (imap), sizeof (icall_names [0]), compare_method_imap);\n\tif (!nameslot)\n\t\treturn NULL;\n\treturn (gpointer)icall_functions [(nameslot - icall_names)];\n}\n\nstatic int\ncompare_class_imap (const void *key, const void *elem)\n{\n\tconst char** class_name = (const char**)elem;\n\treturn strcmp (key, *class_name);\n}\n\nstatic const IcallTypeDesc*\nfind_class_icalls (const char *name)\n{\n\tconst char **nameslot = bsearch (name, icall_type_names, Icall_type_num, sizeof (icall_type_names [0]), compare_class_imap);\n\tif (!nameslot)\n\t\treturn NULL;\n\treturn &icall_type_descs [nameslot - icall_type_names];\n}\n\n#endif\n\n/* \n * we should probably export this as an helper (handle nested types).\n * Returns the number of chars written in buf.\n */\nstatic int\nconcat_class_name (char *buf, int bufsize, MonoClass *klass)\n{\n\tint nspacelen, cnamelen;\n\tnspacelen = strlen (klass->name_space);\n\tcnamelen = strlen (klass->name);\n\tif (nspacelen + cnamelen + 2 > bufsize)\n\t\treturn 0;\n\tif (nspacelen) {\n\t\tmemcpy (buf, klass->name_space, nspacelen);\n\t\tbuf [nspacelen ++] = '.';\n\t}\n\tmemcpy (buf + nspacelen, klass->name, cnamelen);\n\tbuf [nspacelen + cnamelen] = 0;\n\treturn nspacelen + cnamelen;\n}\n\ngpointer\nmono_lookup_internal_call (MonoMethod *method)\n{\n\tchar *sigstart;\n\tchar *tmpsig;\n\tchar mname [2048];\n\tint typelen = 0, mlen, siglen;\n\tgpointer res;\n\tconst IcallTypeDesc *imap;\n\n\tg_assert (method != NULL);\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tif (method->klass->nested_in) {\n\t\tint pos = concat_class_name (mname, sizeof (mname)-2, method->klass->nested_in);\n\t\tif (!pos)\n\t\t\treturn NULL;\n\n\t\tmname [pos++] = '/';\n\t\tmname [pos] = 0;\n\n\t\ttypelen = concat_class_name (mname+pos, sizeof (mname)-pos-1, method->klass);\n\t\tif (!typelen)\n\t\t\treturn NULL;\n\n\t\ttypelen += pos;\n\t} else {\n\t\ttypelen = concat_class_name (mname, sizeof (mname), method->klass);\n\t\tif (!typelen)\n\t\t\treturn NULL;\n\t}\n\n\timap = find_class_icalls (mname);\n\n\tmname [typelen] = ':';\n\tmname [typelen + 1] = ':';\n\n\tmlen = strlen (method->name);\n\tmemcpy (mname + typelen + 2, method->name, mlen);\n\tsigstart = mname + typelen + 2 + mlen;\n\t*sigstart = 0;\n\n\ttmpsig = mono_signature_get_desc (mono_method_signature (method), TRUE);\n\tsiglen = strlen (tmpsig);\n\tif (typelen + mlen + siglen + 6 > sizeof (mname))\n\t\treturn NULL;\n\tsigstart [0] = '(';\n\tmemcpy (sigstart + 1, tmpsig, siglen);\n\tsigstart [siglen + 1] = ')';\n\tsigstart [siglen + 2] = 0;\n\tg_free (tmpsig);\n\t\n\tmono_loader_lock ();\n\n\tres = g_hash_table_lookup (icall_hash, mname);\n\tif (res) {\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\t/* try without signature */\n\t*sigstart = 0;\n\tres = g_hash_table_lookup (icall_hash, mname);\n\tif (res) {\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\n\t/* it wasn't found in the static call tables */\n\tif (!imap) {\n\t\tmono_loader_unlock ();\n\t\treturn NULL;\n\t}\n\tres = find_method_icall (imap, sigstart - mlen);\n\tif (res) {\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\t/* try _with_ signature */\n\t*sigstart = '(';\n\tres = find_method_icall (imap, sigstart - mlen);\n\tif (res) {\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\n\tg_warning (\"cant resolve internal call to \\\"%s\\\" (tested without signature also)\", mname);\n\tg_print (\"\\nYour mono runtime and class libraries are out of sync.\\n\");\n\tg_print (\"The out of sync library is: %s\\n\", method->klass->image->name);\n\tg_print (\"\\nWhen you update one from svn you need to update, compile and install\\nthe other too.\\n\");\n\tg_print (\"Do not report this as a bug unless you're sure you have updated correctly:\\nyou probably have a broken mono install.\\n\");\n\tg_print (\"If you see other errors or faults after this message they are probably related\\n\");\n\tg_print (\"and you need to fix your mono install first.\\n\");\n\n\tmono_loader_unlock ();\n\n\treturn NULL;\n}\n\nstatic MonoType*\ntype_from_typename (char *typename)\n{\n\tMonoClass *klass = NULL;\t/* assignment to shut GCC warning up */\n\n\tif (!strcmp (typename, \"int\"))\n\t\tklass = mono_defaults.int_class;\n\telse if (!strcmp (typename, \"ptr\"))\n\t\tklass = mono_defaults.int_class;\n\telse if (!strcmp (typename, \"void\"))\n\t\tklass = mono_defaults.void_class;\n\telse if (!strcmp (typename, \"int32\"))\n\t\tklass = mono_defaults.int32_class;\n\telse if (!strcmp (typename, \"uint32\"))\n\t\tklass = mono_defaults.uint32_class;\n\telse if (!strcmp (typename, \"int8\"))\n\t\tklass = mono_defaults.sbyte_class;\n\telse if (!strcmp (typename, \"uint8\"))\n\t\tklass = mono_defaults.byte_class;\n\telse if (!strcmp (typename, \"int16\"))\n\t\tklass = mono_defaults.int16_class;\n\telse if (!strcmp (typename, \"uint16\"))\n\t\tklass = mono_defaults.uint16_class;\n\telse if (!strcmp (typename, \"long\"))\n\t\tklass = mono_defaults.int64_class;\n\telse if (!strcmp (typename, \"ulong\"))\n\t\tklass = mono_defaults.uint64_class;\n\telse if (!strcmp (typename, \"float\"))\n\t\tklass = mono_defaults.single_class;\n\telse if (!strcmp (typename, \"double\"))\n\t\tklass = mono_defaults.double_class;\n\telse if (!strcmp (typename, \"object\"))\n\t\tklass = mono_defaults.object_class;\n\telse if (!strcmp (typename, \"obj\"))\n\t\tklass = mono_defaults.object_class;\n\telse if (!strcmp (typename, \"string\"))\n\t\tklass = mono_defaults.string_class;\n\telse if (!strcmp (typename, \"bool\"))\n\t\tklass = mono_defaults.boolean_class;\n\telse if (!strcmp (typename, \"boolean\"))\n\t\tklass = mono_defaults.boolean_class;\n\telse {\n\t\tg_error (\"%s\", typename);\n\t\tg_assert_not_reached ();\n\t}\n\treturn &klass->byval_arg;\n}\n\nMonoMethodSignature*\nmono_create_icall_signature (const char *sigstr)\n{\n\tgchar **parts;\n\tint i, len;\n\tgchar **tmp;\n\tMonoMethodSignature *res;\n\n\tmono_loader_lock ();\n\tres = g_hash_table_lookup (mono_defaults.corlib->helper_signatures, sigstr);\n\tif (res) {\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\n\tparts = g_strsplit (sigstr, \" \", 256);\n\n\ttmp = parts;\n\tlen = 0;\n\twhile (*tmp) {\n\t\tlen ++;\n\t\ttmp ++;\n\t}\n\n\tres = mono_metadata_signature_alloc (mono_defaults.corlib, len - 1);\n\tres->pinvoke = 1;\n\n#ifdef PLATFORM_WIN32\n\t/* \n\t * Under windows, the default pinvoke calling convention is STDCALL but\n\t * we need CDECL.\n\t */\n\tres->call_convention = MONO_CALL_C;\n#endif\n\n\tres->ret = type_from_typename (parts [0]);\n\tfor (i = 1; i < len; ++i) {\n\t\tres->params [i - 1] = type_from_typename (parts [i]);\n\t}\n\n\tg_strfreev (parts);\n\n\tg_hash_table_insert (mono_defaults.corlib->helper_signatures, (gpointer)sigstr, res);\n\n\tmono_loader_unlock ();\n\n\treturn res;\n}\n\nMonoJitICallInfo *\nmono_find_jit_icall_by_name (const char *name)\n{\n\tMonoJitICallInfo *info;\n\tg_assert (jit_icall_hash_name);\n\n\tmono_loader_lock ();\n\tinfo = g_hash_table_lookup (jit_icall_hash_name, name);\n\tmono_loader_unlock ();\n\treturn info;\n}\n\nMonoJitICallInfo *\nmono_find_jit_icall_by_addr (gconstpointer addr)\n{\n\tMonoJitICallInfo *info;\n\tg_assert (jit_icall_hash_addr);\n\n\tmono_loader_lock ();\n\tinfo = g_hash_table_lookup (jit_icall_hash_addr, (gpointer)addr);\n\tmono_loader_unlock ();\n\n\treturn info;\n}\n\n/*\n * mono_get_jit_icall_info:\n *\n *   Return the hashtable mapping JIT icall names to MonoJitICallInfo structures. The\n * caller should access it while holding the loader lock.\n */\nGHashTable*\nmono_get_jit_icall_info (void)\n{\n\treturn jit_icall_hash_name;\n}\n\nvoid\nmono_register_jit_icall_wrapper (MonoJitICallInfo *info, gconstpointer wrapper)\n{\n\tmono_loader_lock ();\n\tg_hash_table_insert (jit_icall_hash_addr, (gpointer)wrapper, info);\n\tmono_loader_unlock ();\n}\n\nMonoJitICallInfo *\nmono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)\n{\n\tMonoJitICallInfo *info;\n\t\n\tg_assert (func);\n\tg_assert (name);\n\n\tmono_loader_lock ();\n\n\tif (!jit_icall_hash_name) {\n\t\tjit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);\n\t\tjit_icall_hash_addr = g_hash_table_new (NULL, NULL);\n\t}\n\n\tif (g_hash_table_lookup (jit_icall_hash_name, name)) {\n\t\tg_warning (\"jit icall already defined \\\"%s\\\"\\n\", name);\n\t\tg_assert_not_reached ();\n\t}\n\n\tinfo = g_new0 (MonoJitICallInfo, 1);\n\t\n\tinfo->name = name;\n\tinfo->func = func;\n\tinfo->sig = sig;\n\n\tif (is_save) {\n\t\tinfo->wrapper = func;\n\t} else {\n\t\tinfo->wrapper = NULL;\n\t}\n\n\tg_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);\n\tg_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);\n\n\tmono_loader_unlock ();\n\treturn info;\n}\n"], "filenames": ["mono/metadata/icall.c"], "buggy_code_start_loc": [721], "buggy_code_end_loc": [782], "fixing_code_start_loc": [720], "fixing_code_end_loc": [791], "type": "CWE-362", "message": "Race condition in the FastCopy optimization in the Array.Copy method in metadata/icall.c in Mono, when Moonlight 2.x before 2.4.1 or 3.x before 3.99.3 is used, allows remote attackers to trigger a buffer overflow and modify internal data structures, and cause a denial of service (plugin crash) or corrupt the internal state of the security manager, via a crafted media file in which a thread makes a change after a type check but before a copy action.", "other": {"cve": {"id": "CVE-2011-0990", "sourceIdentifier": "cve@mitre.org", "published": "2011-04-13T21:55:00.783", "lastModified": "2017-08-17T01:33:46.073", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in the FastCopy optimization in the Array.Copy method in metadata/icall.c in Mono, when Moonlight 2.x before 2.4.1 or 3.x before 3.99.3 is used, allows remote attackers to trigger a buffer overflow and modify internal data structures, and cause a denial of service (plugin crash) or corrupt the internal state of the security manager, via a crafted media file in which a thread makes a change after a type check but before a copy action."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la optimizaci\u00f3n de FastCopy en el m\u00e9todo Array.Copy en metadata/icall.c de Mono, cuando se utiliza Moonlight 2.x anterior a 2.4.1 o 3.x anterior a 3.99.3, permite a atacantes remotos provocar un desbordamiento del b\u00fafer y modificar las estructuras internas de datos, tambi\u00e9n permite provocar una denegaci\u00f3n de servicio (ca\u00edda del plugin) o corromper el estado interno del gestor de seguridad mediante un fichero media manipulado, en el que un hilo realiza un cambio despu\u00e9s de una comprobaci\u00f3n de escritura pero antes de una acci\u00f3n de copiado."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:*:*:*:*:*:*:*:*", "matchCriteriaId": "E062208D-082B-4BFD-85CA-3848ECE6F8CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "711824C0-5BFC-4D3A-BAB2-84B8F20BDD7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "C74F2C01-7E26-474A-B8CA-EFCC5C91D83D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.4:*:*:*:*:*:*:*", "matchCriteriaId": "704EB745-3307-4903-8B3B-DCC6682EE228"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.31:*:*:*:*:*:*:*", "matchCriteriaId": "DB7A6358-630E-43FA-B2B8-C99A8808BB09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "AADDCD5B-D116-4BFC-BD2B-4EB6F4470359"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:3.99:*:*:*:*:*:*:*", "matchCriteriaId": "21676825-737D-4071-A7F1-BFB6047215F1"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2011-04/msg00024.html", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2011/04/06/14", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.mono-project.com/Vulnerabilities", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/47208", "source": "cve@mitre.org"}, {"url": "http://www.vupen.com/english/advisories/2011/0904", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=667077", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/66625", "source": "cve@mitre.org"}, {"url": "https://github.com/mono/mono/commit/2f00e4bbb2137130845afb1b2a1e678552fc8e5c", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/mono/mono/commit/2f00e4bbb2137130845afb1b2a1e678552fc8e5c"}}