{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ops.c: implementation of various operators: op_shift, op_delete, op_tilde,\n *\t  op_change, op_yank, do_join\n */\n\n#include \"vim.h\"\n\nstatic void shift_block(oparg_T *oap, int amount);\nstatic void\tmb_adjust_opend(oparg_T *oap);\nstatic int\tdo_addsub(int op_type, pos_T *pos, int length, linenr_T Prenum1);\n\n// Flags for third item in \"opchars\".\n#define OPF_LINES  1\t// operator always works on lines\n#define OPF_CHANGE 2\t// operator changes text\n\n/*\n * The names of operators.\n * IMPORTANT: Index must correspond with defines in vim.h!!!\n * The third field holds OPF_ flags.\n */\nstatic char opchars[][3] =\n{\n    {NUL, NUL, 0},\t\t\t// OP_NOP\n    {'d', NUL, OPF_CHANGE},\t\t// OP_DELETE\n    {'y', NUL, 0},\t\t\t// OP_YANK\n    {'c', NUL, OPF_CHANGE},\t\t// OP_CHANGE\n    {'<', NUL, OPF_LINES | OPF_CHANGE},\t// OP_LSHIFT\n    {'>', NUL, OPF_LINES | OPF_CHANGE},\t// OP_RSHIFT\n    {'!', NUL, OPF_LINES | OPF_CHANGE},\t// OP_FILTER\n    {'g', '~', OPF_CHANGE},\t\t// OP_TILDE\n    {'=', NUL, OPF_LINES | OPF_CHANGE},\t// OP_INDENT\n    {'g', 'q', OPF_LINES | OPF_CHANGE},\t// OP_FORMAT\n    {':', NUL, OPF_LINES},\t\t// OP_COLON\n    {'g', 'U', OPF_CHANGE},\t\t// OP_UPPER\n    {'g', 'u', OPF_CHANGE},\t\t// OP_LOWER\n    {'J', NUL, OPF_LINES | OPF_CHANGE},\t// DO_JOIN\n    {'g', 'J', OPF_LINES | OPF_CHANGE},\t// DO_JOIN_NS\n    {'g', '?', OPF_CHANGE},\t\t// OP_ROT13\n    {'r', NUL, OPF_CHANGE},\t\t// OP_REPLACE\n    {'I', NUL, OPF_CHANGE},\t\t// OP_INSERT\n    {'A', NUL, OPF_CHANGE},\t\t// OP_APPEND\n    {'z', 'f', OPF_LINES},\t\t// OP_FOLD\n    {'z', 'o', OPF_LINES},\t\t// OP_FOLDOPEN\n    {'z', 'O', OPF_LINES},\t\t// OP_FOLDOPENREC\n    {'z', 'c', OPF_LINES},\t\t// OP_FOLDCLOSE\n    {'z', 'C', OPF_LINES},\t\t// OP_FOLDCLOSEREC\n    {'z', 'd', OPF_LINES},\t\t// OP_FOLDDEL\n    {'z', 'D', OPF_LINES},\t\t// OP_FOLDDELREC\n    {'g', 'w', OPF_LINES | OPF_CHANGE},\t// OP_FORMAT2\n    {'g', '@', OPF_CHANGE},\t\t// OP_FUNCTION\n    {Ctrl_A, NUL, OPF_CHANGE},\t\t// OP_NR_ADD\n    {Ctrl_X, NUL, OPF_CHANGE},\t\t// OP_NR_SUB\n};\n\n/*\n * Translate a command name into an operator type.\n * Must only be called with a valid operator name!\n */\n    int\nget_op_type(int char1, int char2)\n{\n    int\t\ti;\n\n    if (char1 == 'r')\t\t// ignore second character\n\treturn OP_REPLACE;\n    if (char1 == '~')\t\t// when tilde is an operator\n\treturn OP_TILDE;\n    if (char1 == 'g' && char2 == Ctrl_A)\t// add\n\treturn OP_NR_ADD;\n    if (char1 == 'g' && char2 == Ctrl_X)\t// subtract\n\treturn OP_NR_SUB;\n    if (char1 == 'z' && char2 == 'y')\t// OP_YANK\n\treturn OP_YANK;\n    for (i = 0; ; ++i)\n    {\n\tif (opchars[i][0] == char1 && opchars[i][1] == char2)\n\t    break;\n\tif (i == (int)ARRAY_LENGTH(opchars) - 1)\n\t{\n\t    internal_error(\"get_op_type()\");\n\t    break;\n\t}\n    }\n    return i;\n}\n\n/*\n * Return TRUE if operator \"op\" always works on whole lines.\n */\n    static int\nop_on_lines(int op)\n{\n    return opchars[op][2] & OPF_LINES;\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Return TRUE if operator \"op\" changes text.\n */\n    int\nop_is_change(int op)\n{\n    return opchars[op][2] & OPF_CHANGE;\n}\n#endif\n\n/*\n * Get first operator command character.\n * Returns 'g' or 'z' if there is another command character.\n */\n    int\nget_op_char(int optype)\n{\n    return opchars[optype][0];\n}\n\n/*\n * Get second operator command character.\n */\n    int\nget_extra_op_char(int optype)\n{\n    return opchars[optype][1];\n}\n\n/*\n * op_shift - handle a shift operation\n */\n    void\nop_shift(oparg_T *oap, int curs_top, int amount)\n{\n    long\t    i;\n    int\t\t    first_char;\n    int\t\t    block_col = 0;\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n\n    if (oap->block_mode)\n\tblock_col = curwin->w_cursor.col;\n\n    for (i = oap->line_count; --i >= 0; )\n    {\n\tfirst_char = *ml_get_curline();\n\tif (first_char == NUL)\t\t\t\t// empty line\n\t    curwin->w_cursor.col = 0;\n\telse if (oap->block_mode)\n\t    shift_block(oap, amount);\n\telse\n\t    // Move the line right if it doesn't start with '#', 'smartindent'\n\t    // isn't set or 'cindent' isn't set or '#' isn't in 'cino'.\n\t    if (first_char != '#' || !preprocs_left())\n\t\tshift_line(oap->op_type == OP_LSHIFT, p_sr, amount, FALSE);\n\t++curwin->w_cursor.lnum;\n    }\n\n    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);\n    if (oap->block_mode)\n    {\n\tcurwin->w_cursor.lnum = oap->start.lnum;\n\tcurwin->w_cursor.col = block_col;\n    }\n    else if (curs_top)\t    // put cursor on first line, for \">>\"\n    {\n\tcurwin->w_cursor.lnum = oap->start.lnum;\n\tbeginline(BL_SOL | BL_FIX);   // shift_line() may have set cursor.col\n    }\n    else\n\t--curwin->w_cursor.lnum;\t// put cursor on last line, for \":>\"\n\n#ifdef FEAT_FOLDING\n    // The cursor line is not in a closed fold\n    foldOpenCursor();\n#endif\n\n\n    if (oap->line_count > p_report)\n    {\n\tchar\t    *op;\n\tchar\t    *msg_line_single;\n\tchar\t    *msg_line_plural;\n\n\tif (oap->op_type == OP_RSHIFT)\n\t    op = \">\";\n\telse\n\t    op = \"<\";\n\tmsg_line_single = NGETTEXT(\"%ld line %sed %d time\",\n\t\t\t\t\t     \"%ld line %sed %d times\", amount);\n\tmsg_line_plural = NGETTEXT(\"%ld lines %sed %d time\",\n\t\t\t\t\t    \"%ld lines %sed %d times\", amount);\n\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\tNGETTEXT(msg_line_single, msg_line_plural, oap->line_count),\n\t\toap->line_count, op, amount);\n\tmsg_attr_keep((char *)IObuff, 0, TRUE);\n    }\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end.lnum = oap->end.lnum;\n\tcurbuf->b_op_end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Shift the current line one shiftwidth left (if left != 0) or right\n * leaves cursor on first blank in the line.\n */\n    void\nshift_line(\n    int\tleft,\n    int\tround,\n    int\tamount,\n    int call_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tcount;\n    int\t\ti, j;\n    int\t\tsw_val = (int)get_sw_value_indent(curbuf);\n\n    count = get_indent();\t// get current indent\n\n    if (round)\t\t\t// round off indent\n    {\n\ti = count / sw_val;\t// number of 'shiftwidth' rounded down\n\tj = count % sw_val;\t// extra spaces\n\tif (j && left)\t\t// first remove extra spaces\n\t    --amount;\n\tif (left)\n\t{\n\t    i -= amount;\n\t    if (i < 0)\n\t\ti = 0;\n\t}\n\telse\n\t    i += amount;\n\tcount = i * sw_val;\n    }\n    else\t\t// original vi indent\n    {\n\tif (left)\n\t{\n\t    count -= sw_val * amount;\n\t    if (count < 0)\n\t\tcount = 0;\n\t}\n\telse\n\t    count += sw_val * amount;\n    }\n\n    // Set new indent\n    if (State & VREPLACE_FLAG)\n\tchange_indent(INDENT_SET, count, FALSE, NUL, call_changed_bytes);\n    else\n\t(void)set_indent(count, call_changed_bytes ? SIN_CHANGED : 0);\n}\n\n/*\n * Shift one line of the current block one shiftwidth right or left.\n * Leaves cursor on first character in block.\n */\n    static void\nshift_block(oparg_T *oap, int amount)\n{\n    int\t\t\tleft = (oap->op_type == OP_LSHIFT);\n    int\t\t\toldstate = State;\n    int\t\t\ttotal;\n    char_u\t\t*newp, *oldp;\n    int\t\t\toldcol = curwin->w_cursor.col;\n    int\t\t\tsw_val = (int)get_sw_value_indent(curbuf);\n    int\t\t\tts_val = (int)curbuf->b_p_ts;\n    struct block_def\tbd;\n    int\t\t\tincr;\n    colnr_T\t\tws_vcol;\n    int\t\t\tadded;\n    unsigned\t\tnew_line_len;\t// the length of the line after the\n\t\t\t\t\t// block shift\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\told_p_ri = p_ri;\n\n    p_ri = 0;\t\t\t// don't want revins in indent\n#endif\n\n    State = MODE_INSERT;\t// don't want MODE_REPLACE for State\n    block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);\n    if (bd.is_short)\n\treturn;\n\n    // total is number of screen columns to be inserted/removed\n    total = (int)((unsigned)amount * (unsigned)sw_val);\n    if ((total / sw_val) != amount)\n\treturn; // multiplication overflow\n\n    oldp = ml_get_curline();\n\n    if (!left)\n    {\n\tint\t\ttabs = 0, spaces = 0;\n\tchartabsize_T\tcts;\n\n\t/*\n\t *  1. Get start vcol\n\t *  2. Total ws vcols\n\t *  3. Divvy into TABs & spp\n\t *  4. Construct new string\n\t */\n\ttotal += bd.pre_whitesp; // all virtual WS up to & incl a split TAB\n\tws_vcol = bd.start_vcol - bd.pre_whitesp;\n\tif (bd.startspaces)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tif ((*mb_ptr2len)(bd.textstart) == 1)\n\t\t    ++bd.textstart;\n\t\telse\n\t\t{\n\t\t    ws_vcol = 0;\n\t\t    bd.startspaces = 0;\n\t\t}\n\t    }\n\t    else\n\t\t++bd.textstart;\n\t}\n\n\t// TODO: is passing bd.textstart for start of the line OK?\n\tinit_chartabsize_arg(&cts, curwin, curwin->w_cursor.lnum,\n\t\t\t\t   bd.start_vcol, bd.textstart, bd.textstart);\n\tfor ( ; VIM_ISWHITE(*cts.cts_ptr); )\n\t{\n\t    incr = lbr_chartabsize_adv(&cts);\n\t    total += incr;\n\t    cts.cts_vcol += incr;\n\t}\n\tbd.textstart = cts.cts_ptr;\n\tbd.start_vcol = cts.cts_vcol;\n\tclear_chartabsize_arg(&cts);\n\n\t// OK, now total=all the VWS reqd, and textstart points at the 1st\n\t// non-ws char in the block.\n#ifdef FEAT_VARTABS\n\tif (!curbuf->b_p_et)\n\t    tabstop_fromto(ws_vcol, ws_vcol + total,\n\t\t\t\tts_val, curbuf->b_p_vts_array, &tabs, &spaces);\n\telse\n\t    spaces = total;\n#else\n\tif (!curbuf->b_p_et)\n\t    tabs = ((ws_vcol % ts_val) + total) / ts_val; // number of tabs\n\tif (tabs > 0)\n\t    spaces = ((ws_vcol % ts_val) + total) % ts_val; // number of spp\n\telse\n\t    spaces = total;\n#endif\n\t// if we're splitting a TAB, allow for it\n\tbd.textcol -= bd.pre_whitesp_c - (bd.startspaces != 0);\n\n\tnew_line_len = bd.textcol + tabs + spaces + (int)STRLEN(bd.textstart);\n\tnewp = alloc(new_line_len + 1);\n\tif (newp == NULL)\n\t    return;\n\tmch_memmove(newp, oldp, (size_t)bd.textcol);\n\tvim_memset(newp + bd.textcol, TAB, (size_t)tabs);\n\tvim_memset(newp + bd.textcol + tabs, ' ', (size_t)spaces);\n\t// Note that STRMOVE() copies the trailing NUL.\n\tSTRMOVE(newp + bd.textcol + tabs + spaces, bd.textstart);\n    }\n    else // left\n    {\n\tcolnr_T\t    destination_col;\t// column to which text in block will\n\t\t\t\t\t// be shifted\n\tchar_u\t    *verbatim_copy_end;\t// end of the part of the line which is\n\t\t\t\t\t// copied verbatim\n\tcolnr_T\t    verbatim_copy_width;// the (displayed) width of this part\n\t\t\t\t\t// of line\n\tunsigned    fill;\t\t// nr of spaces that replace a TAB\n\tsize_t\t    block_space_width;\n\tsize_t\t    shift_amount;\n\tchar_u\t    *non_white = bd.textstart;\n\tcolnr_T\t    non_white_col;\n\tchartabsize_T cts;\n\n\t/*\n\t * Firstly, let's find the first non-whitespace character that is\n\t * displayed after the block's start column and the character's column\n\t * number. Also, let's calculate the width of all the whitespace\n\t * characters that are displayed in the block and precede the searched\n\t * non-whitespace character.\n\t */\n\n\t// If \"bd.startspaces\" is set, \"bd.textstart\" points to the character,\n\t// the part of which is displayed at the block's beginning. Let's start\n\t// searching from the next character.\n\tif (bd.startspaces)\n\t    MB_PTR_ADV(non_white);\n\n\t// The character's column is in \"bd.start_vcol\".\n\tnon_white_col = bd.start_vcol;\n\n\tinit_chartabsize_arg(&cts, curwin, curwin->w_cursor.lnum,\n\t\t\t\t   non_white_col, bd.textstart, non_white);\n\twhile (VIM_ISWHITE(*cts.cts_ptr))\n\t{\n\t    incr = lbr_chartabsize_adv(&cts);\n\t    cts.cts_vcol += incr;\n\t}\n\tnon_white_col = cts.cts_vcol;\n\tnon_white = cts.cts_ptr;\n\tclear_chartabsize_arg(&cts);\n\n\tblock_space_width = non_white_col - oap->start_vcol;\n\t// We will shift by \"total\" or \"block_space_width\", whichever is less.\n\tshift_amount = (block_space_width < (size_t)total\n\t\t\t\t\t ? block_space_width : (size_t)total);\n\n\t// The column to which we will shift the text.\n\tdestination_col = (colnr_T)(non_white_col - shift_amount);\n\n\t// Now let's find out how much of the beginning of the line we can\n\t// reuse without modification.\n\tverbatim_copy_end = bd.textstart;\n\tverbatim_copy_width = bd.start_vcol;\n\n\t// If \"bd.startspaces\" is set, \"bd.textstart\" points to the character\n\t// preceding the block. We have to subtract its width to obtain its\n\t// column number.\n\tif (bd.startspaces)\n\t    verbatim_copy_width -= bd.start_char_vcols;\n\tinit_chartabsize_arg(&cts, curwin, 0, verbatim_copy_width,\n\t\t\t\t\t     bd.textstart, verbatim_copy_end);\n\twhile (cts.cts_vcol < destination_col)\n\t{\n\t    incr = lbr_chartabsize(&cts);\n\t    if (cts.cts_vcol + incr > destination_col)\n\t\tbreak;\n\t    cts.cts_vcol += incr;\n\t    MB_PTR_ADV(cts.cts_ptr);\n\t}\n\tverbatim_copy_width = cts.cts_vcol;\n\tverbatim_copy_end = cts.cts_ptr;\n\tclear_chartabsize_arg(&cts);\n\n\t// If \"destination_col\" is different from the width of the initial\n\t// part of the line that will be copied, it means we encountered a tab\n\t// character, which we will have to partly replace with spaces.\n\tfill = destination_col - verbatim_copy_width;\n\n\t// The replacement line will consist of:\n\t// - the beginning of the original line up to \"verbatim_copy_end\",\n\t// - \"fill\" number of spaces,\n\t// - the rest of the line, pointed to by non_white.\n\tnew_line_len = (unsigned)(verbatim_copy_end - oldp)\n\t\t       + fill\n\t\t       + (unsigned)STRLEN(non_white);\n\n\tnewp = alloc(new_line_len + 1);\n\tif (newp == NULL)\n\t    return;\n\tmch_memmove(newp, oldp, (size_t)(verbatim_copy_end - oldp));\n\tvim_memset(newp + (verbatim_copy_end - oldp), ' ', (size_t)fill);\n\t// Note that STRMOVE() copies the trailing NUL.\n\tSTRMOVE(newp + (verbatim_copy_end - oldp) + fill, non_white);\n    }\n    // replace the line\n    added = new_line_len - (int)STRLEN(oldp);\n    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n    inserted_bytes(curwin->w_cursor.lnum, bd.textcol, added);\n    State = oldstate;\n    curwin->w_cursor.col = oldcol;\n#ifdef FEAT_RIGHTLEFT\n    p_ri = old_p_ri;\n#endif\n}\n\n/*\n * Insert string \"s\" (b_insert ? before : after) block :AKelly\n * Caller must prepare for undo.\n */\n    static void\nblock_insert(\n    oparg_T\t\t*oap,\n    char_u\t\t*s,\n    int\t\t\tb_insert,\n    struct block_def\t*bdp)\n{\n    int\t\tts_val;\n    int\t\tcount = 0;\t// extra spaces to replace a cut TAB\n    int\t\tspaces = 0;\t// non-zero if cutting a TAB\n    colnr_T\toffset;\t\t// pointer along new line\n    colnr_T\tstartcol;\t// column where insert starts\n    unsigned\ts_len;\t\t// STRLEN(s)\n    char_u\t*newp, *oldp;\t// new, old lines\n    linenr_T\tlnum;\t\t// loop var\n    int\t\toldstate = State;\n\n    State = MODE_INSERT;\t// don't want MODE_REPLACE for State\n    s_len = (unsigned)STRLEN(s);\n\n    for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)\n    {\n\tblock_prep(oap, bdp, lnum, TRUE);\n\tif (bdp->is_short && b_insert)\n\t    continue;\t// OP_INSERT, line ends before block start\n\n\toldp = ml_get(lnum);\n\n\tif (b_insert)\n\t{\n\t    ts_val = bdp->start_char_vcols;\n\t    spaces = bdp->startspaces;\n\t    if (spaces != 0)\n\t\tcount = ts_val - 1; // we're cutting a TAB\n\t    offset = bdp->textcol;\n\t}\n\telse // append\n\t{\n\t    ts_val = bdp->end_char_vcols;\n\t    if (!bdp->is_short) // spaces = padding after block\n\t    {\n\t\tspaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0);\n\t\tif (spaces != 0)\n\t\t    count = ts_val - 1; // we're cutting a TAB\n\t\toffset = bdp->textcol + bdp->textlen - (spaces != 0);\n\t    }\n\t    else // spaces = padding to block edge\n\t    {\n\t\t// if $ used, just append to EOL (ie spaces==0)\n\t\tif (!bdp->is_MAX)\n\t\t    spaces = (oap->end_vcol - bdp->end_vcol) + 1;\n\t\tcount = spaces;\n\t\toffset = bdp->textcol + bdp->textlen;\n\t    }\n\t}\n\n\tif (has_mbyte && spaces > 0)\n\t    // avoid copying part of a multi-byte character\n\t    offset -= (*mb_head_off)(oldp, oldp + offset);\n\n\tif (spaces < 0)  // can happen when the cursor was moved\n\t    spaces = 0;\n\n\t// Make sure the allocated size matches what is actually copied below.\n\tnewp = alloc(STRLEN(oldp) + spaces + s_len\n\t\t    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)\n\t\t\t\t\t\t\t\t  + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t// copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)offset);\n\toldp += offset;\n\n\t// insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t// copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces > 0 && !bdp->is_short)\n\t{\n\t    if (*oldp == TAB)\n\t    {\n\t\t// insert post-padding\n\t\tvim_memset(newp + offset + spaces, ' ',\n\t\t\t\t\t\t    (size_t)(ts_val - spaces));\n\t\t// we're splitting a TAB, don't copy it\n\t\toldp++;\n\t\t// We allowed for that TAB, remember this now\n\t\tcount++;\n\t    }\n\t    else\n\t\t// Not a TAB, no extra spaces\n\t\tcount = spaces;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);\n\n\tml_replace(lnum, newp, FALSE);\n\n\tif (b_insert)\n\t    // correct any text properties\n\t    inserted_bytes(lnum, startcol, s_len);\n\n\tif (lnum == oap->end.lnum)\n\t{\n\t    // Set \"']\" mark to the end of the block instead of the end of\n\t    // the insert in the first line.\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = offset;\n\t}\n    } // for all lnum\n\n    changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\n    State = oldstate;\n}\n\n/*\n * Handle a delete operation.\n *\n * Return FAIL if undo failed, OK otherwise.\n */\n    int\nop_delete(oparg_T *oap)\n{\n    int\t\t\tn;\n    linenr_T\t\tlnum;\n    char_u\t\t*ptr;\n    char_u\t\t*newp, *oldp;\n    struct block_def\tbd;\n    linenr_T\t\told_lcount = curbuf->b_ml.ml_line_count;\n    int\t\t\tdid_yank = FALSE;\n\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\t    // nothing to do\n\treturn OK;\n\n    // Nothing to delete, return here.\tDo prepare undo, for op_change().\n    if (oap->empty)\n\treturn u_save_cursor();\n\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn FAIL;\n    }\n\n    if (VIsual_select && oap->is_VIsual)\n\t// use register given with CTRL_R, defaults to zero\n\toap->regname = VIsual_select_reg;\n\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&oap->regname);\n#endif\n\n    if (has_mbyte)\n\tmb_adjust_opend(oap);\n\n    /*\n     * Imitate the strange Vi behaviour: If the delete spans more than one\n     * line and motion_type == MCHAR and the result is a blank line, make the\n     * delete linewise.  Don't do this for the change command or Visual mode.\n     */\n    if (       oap->motion_type == MCHAR\n\t    && !oap->is_VIsual\n\t    && !oap->block_mode\n\t    && oap->line_count > 1\n\t    && oap->motion_force == NUL\n\t    && oap->op_type == OP_DELETE)\n    {\n\tptr = ml_get(oap->end.lnum) + oap->end.col;\n\tif (*ptr != NUL)\n\t    ptr += oap->inclusive;\n\tptr = skipwhite(ptr);\n\tif (*ptr == NUL && inindent(0))\n\t    oap->motion_type = MLINE;\n    }\n\n    /*\n     * Check for trying to delete (e.g. \"D\") in an empty line.\n     * Note: For the change operator it is ok.\n     */\n    if (       oap->motion_type == MCHAR\n\t    && oap->line_count == 1\n\t    && oap->op_type == OP_DELETE\n\t    && *ml_get(oap->start.lnum) == NUL)\n    {\n\t/*\n\t * It's an error to operate on an empty region, when 'E' included in\n\t * 'cpoptions' (Vi compatible).\n\t */\n\tif (virtual_op)\n\t    // Virtual editing: Nothing gets deleted, but we set the '[ and ']\n\t    // marks as if it happened.\n\t    goto setmarks;\n\tif (vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL)\n\t    beep_flush();\n\treturn OK;\n    }\n\n    /*\n     * Do a yank of whatever we're about to delete.\n     * If a yank register was specified, put the deleted text into that\n     * register.  For the black hole register '_' don't yank anything.\n     */\n    if (oap->regname != '_')\n    {\n\tif (oap->regname != 0)\n\t{\n\t    // check for read-only register\n\t    if (!valid_yank_reg(oap->regname, TRUE))\n\t    {\n\t\tbeep_flush();\n\t\treturn OK;\n\t    }\n\t    get_yank_register(oap->regname, TRUE); // yank into specif'd reg.\n\t    if (op_yank(oap, TRUE, FALSE) == OK)   // yank without message\n\t\tdid_yank = TRUE;\n\t}\n\telse\n\t    reset_y_append(); // not appending to unnamed register\n\n\t/*\n\t * Put deleted text into register 1 and shift number registers if the\n\t * delete contains a line break, or when using a specific operator (Vi\n\t * compatible)\n\t */\n\tif (oap->motion_type == MLINE || oap->line_count > 1\n\t\t\t\t\t\t\t   || oap->use_reg_one)\n\t{\n\t    shift_delete_registers();\n\t    if (op_yank(oap, TRUE, FALSE) == OK)\n\t\tdid_yank = TRUE;\n\t}\n\n\t// Yank into small delete register when no named register specified\n\t// and the delete is within one line.\n\tif ((\n#ifdef FEAT_CLIPBOARD\n\t    ((clip_unnamed & CLIP_UNNAMED) && oap->regname == '*') ||\n\t    ((clip_unnamed & CLIP_UNNAMED_PLUS) && oap->regname == '+') ||\n#endif\n\t    oap->regname == 0) && oap->motion_type != MLINE\n\t\t\t\t\t\t      && oap->line_count == 1)\n\t{\n\t    oap->regname = '-';\n\t    get_yank_register(oap->regname, TRUE);\n\t    if (op_yank(oap, TRUE, FALSE) == OK)\n\t\tdid_yank = TRUE;\n\t    oap->regname = 0;\n\t}\n\n\t/*\n\t * If there's too much stuff to fit in the yank register, then get a\n\t * confirmation before doing the delete. This is crude, but simple.\n\t * And it avoids doing a delete of something we can't put back if we\n\t * want.\n\t */\n\tif (!did_yank)\n\t{\n\t    int msg_silent_save = msg_silent;\n\n\t    msg_silent = 0;\t// must display the prompt\n\t    n = ask_yesno((char_u *)_(\"cannot yank; delete anyway\"), TRUE);\n\t    msg_silent = msg_silent_save;\n\t    if (n != 'y')\n\t    {\n\t\temsg(_(e_command_aborted));\n\t\treturn FAIL;\n\t    }\n\t}\n\n#if defined(FEAT_EVAL)\n\tif (did_yank && has_textyankpost())\n\t    yank_do_autocmd(oap, get_y_current());\n#endif\n    }\n\n    /*\n     * block mode delete\n     */\n    if (oap->block_mode)\n    {\n\tif (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t    return FAIL;\n\n\tfor (lnum = curwin->w_cursor.lnum; lnum <= oap->end.lnum; ++lnum)\n\t{\n\t    block_prep(oap, &bd, lnum, TRUE);\n\t    if (bd.textlen == 0)\t// nothing to delete\n\t\tcontinue;\n\n\t    // Adjust cursor position for tab replaced by spaces and 'lbr'.\n\t    if (lnum == curwin->w_cursor.lnum)\n\t    {\n\t\tcurwin->w_cursor.col = bd.textcol + bd.startspaces;\n\t\tcurwin->w_cursor.coladd = 0;\n\t    }\n\n\t    // \"n\" == number of chars deleted\n\t    // If we delete a TAB, it may be replaced by several characters.\n\t    // Thus the number of characters may increase!\n\t    n = bd.textlen - bd.startspaces - bd.endspaces;\n\t    oldp = ml_get(lnum);\n\t    newp = alloc(STRLEN(oldp) + 1 - n);\n\t    if (newp == NULL)\n\t\tcontinue;\n\t    // copy up to deleted part\n\t    mch_memmove(newp, oldp, (size_t)bd.textcol);\n\t    // insert spaces\n\t    vim_memset(newp + bd.textcol, ' ',\n\t\t\t\t     (size_t)(bd.startspaces + bd.endspaces));\n\t    // copy the part after the deleted part\n\t    oldp += bd.textcol + bd.textlen;\n\t    STRMOVE(newp + bd.textcol + bd.startspaces + bd.endspaces, oldp);\n\t    // replace the line\n\t    ml_replace(lnum, newp, FALSE);\n\n#ifdef FEAT_PROP_POPUP\n\t    if (curbuf->b_has_textprop && n != 0)\n\t\tadjust_prop_columns(lnum, bd.textcol, -n, 0);\n#endif\n\t}\n\n\tcheck_cursor_col();\n\tchanged_lines(curwin->w_cursor.lnum, curwin->w_cursor.col,\n\t\t\t\t\t\t       oap->end.lnum + 1, 0L);\n\toap->line_count = 0;\t    // no lines deleted\n    }\n    else if (oap->motion_type == MLINE)\n    {\n\tif (oap->op_type == OP_CHANGE)\n\t{\n\t    // Delete the lines except the first one.  Temporarily move the\n\t    // cursor to the next line.  Save the current line number, if the\n\t    // last line is deleted it may be changed.\n\t    if (oap->line_count > 1)\n\t    {\n\t\tlnum = curwin->w_cursor.lnum;\n\t\t++curwin->w_cursor.lnum;\n\t\tdel_lines((long)(oap->line_count - 1), TRUE);\n\t\tcurwin->w_cursor.lnum = lnum;\n\t    }\n\t    if (u_save_cursor() == FAIL)\n\t\treturn FAIL;\n\t    if (curbuf->b_p_ai)\t\t    // don't delete indent\n\t    {\n\t\tbeginline(BL_WHITE);\t    // cursor on first non-white\n\t\tdid_ai = TRUE;\t\t    // delete the indent when ESC hit\n\t\tai_col = curwin->w_cursor.col;\n\t    }\n\t    else\n\t\tbeginline(0);\t\t    // cursor in column 0\n\t    truncate_line(FALSE);   // delete the rest of the line\n\t\t\t\t    // leave cursor past last char in line\n\t    if (oap->line_count > 1)\n\t\tu_clearline();\t    // \"U\" command not possible after \"2cc\"\n\t}\n\telse\n\t{\n\t    del_lines(oap->line_count, TRUE);\n\t    beginline(BL_WHITE | BL_FIX);\n\t    u_clearline();\t// \"U\" command not possible after \"dd\"\n\t}\n    }\n    else\n    {\n\tif (virtual_op)\n\t{\n\t    int\t\tendcol = 0;\n\n\t    // For virtualedit: break the tabs that are partly included.\n\t    if (gchar_pos(&oap->start) == '\\t')\n\t    {\n\t\tif (u_save_cursor() == FAIL)\t// save first line for undo\n\t\t    return FAIL;\n\t\tif (oap->line_count == 1)\n\t\t    endcol = getviscol2(oap->end.col, oap->end.coladd);\n\t\tcoladvance_force(getviscol2(oap->start.col, oap->start.coladd));\n\t\toap->start = curwin->w_cursor;\n\t\tif (oap->line_count == 1)\n\t\t{\n\t\t    coladvance(endcol);\n\t\t    oap->end.col = curwin->w_cursor.col;\n\t\t    oap->end.coladd = curwin->w_cursor.coladd;\n\t\t    curwin->w_cursor = oap->start;\n\t\t}\n\t    }\n\n\t    // Break a tab only when it's included in the area.\n\t    if (gchar_pos(&oap->end) == '\\t'\n\t\t\t\t     && (int)oap->end.coladd < oap->inclusive)\n\t    {\n\t\t// save last line for undo\n\t\tif (u_save((linenr_T)(oap->end.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t\t    return FAIL;\n\t\tcurwin->w_cursor = oap->end;\n\t\tcoladvance_force(getviscol2(oap->end.col, oap->end.coladd));\n\t\toap->end = curwin->w_cursor;\n\t\tcurwin->w_cursor = oap->start;\n\t    }\n\t    if (has_mbyte)\n\t\tmb_adjust_opend(oap);\n\t}\n\n\tif (oap->line_count == 1)\t// delete characters within one line\n\t{\n\t    if (u_save_cursor() == FAIL)\t// save line for undo\n\t\treturn FAIL;\n\n\t    // if 'cpoptions' contains '$', display '$' at end of change\n\t    if (       vim_strchr(p_cpo, CPO_DOLLAR) != NULL\n\t\t    && oap->op_type == OP_CHANGE\n\t\t    && oap->end.lnum == curwin->w_cursor.lnum\n\t\t    && !oap->is_VIsual)\n\t\tdisplay_dollar(oap->end.col - !oap->inclusive);\n\n\t    n = oap->end.col - oap->start.col + 1 - !oap->inclusive;\n\n\t    if (virtual_op)\n\t    {\n\t\t// fix up things for virtualedit-delete:\n\t\t// break the tabs which are going to get in our way\n\t\tchar_u\t\t*curline = ml_get_curline();\n\t\tint\t\tlen = (int)STRLEN(curline);\n\n\t\tif (oap->end.coladd != 0\n\t\t\t&& (int)oap->end.col >= len - 1\n\t\t\t&& !(oap->start.coladd && (int)oap->end.col >= len - 1))\n\t\t    n++;\n\t\t// Delete at least one char (e.g, when on a control char).\n\t\tif (n == 0 && oap->start.coladd != oap->end.coladd)\n\t\t    n = 1;\n\n\t\t// When deleted a char in the line, reset coladd.\n\t\tif (gchar_cursor() != NUL)\n\t\t    curwin->w_cursor.coladd = 0;\n\t    }\n\t    (void)del_bytes((long)n, !virtual_op,\n\t\t\t    oap->op_type == OP_DELETE && !oap->is_VIsual);\n\t}\n\telse\t\t\t\t// delete characters between lines\n\t{\n\t    pos_T   curpos;\n\n\t    // save deleted and changed lines for undo\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t (linenr_T)(curwin->w_cursor.lnum + oap->line_count)) == FAIL)\n\t\treturn FAIL;\n\n\t    truncate_line(TRUE);\t// delete from cursor to end of line\n\n\t    curpos = curwin->w_cursor;\t// remember curwin->w_cursor\n\t    ++curwin->w_cursor.lnum;\n\t    del_lines((long)(oap->line_count - 2), FALSE);\n\n\t    // delete from start of line until op_end\n\t    n = (oap->end.col + 1 - !oap->inclusive);\n\t    curwin->w_cursor.col = 0;\n\t    (void)del_bytes((long)n, !virtual_op,\n\t\t\t    oap->op_type == OP_DELETE && !oap->is_VIsual);\n\t    curwin->w_cursor = curpos;\t// restore curwin->w_cursor\n\t    (void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t}\n\tif (oap->op_type == OP_DELETE)\n\t    auto_format(FALSE, TRUE);\n    }\n\n    msgmore(curbuf->b_ml.ml_line_count - old_lcount);\n\nsetmarks:\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tif (oap->block_mode)\n\t{\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = oap->start.col;\n\t}\n\telse\n\t    curbuf->b_op_end = oap->start;\n\tcurbuf->b_op_start = oap->start;\n    }\n\n    return OK;\n}\n\n/*\n * Adjust end of operating area for ending on a multi-byte character.\n * Used for deletion.\n */\n    static void\nmb_adjust_opend(oparg_T *oap)\n{\n    char_u\t*p;\n\n    if (oap->inclusive)\n    {\n\tp = ml_get(oap->end.lnum);\n\toap->end.col += mb_tail_off(p, p + oap->end.col);\n    }\n}\n\n/*\n * Replace the character under the cursor with \"c\".\n * This takes care of multi-byte characters.\n */\n    static void\nreplace_character(int c)\n{\n    int n = State;\n\n    State = MODE_REPLACE;\n    ins_char(c);\n    State = n;\n    // Backup to the replaced character.\n    dec_cursor();\n}\n\n/*\n * Replace a whole area with one character.\n */\n    int\nop_replace(oparg_T *oap, int c)\n{\n    int\t\t\tn, numc;\n    int\t\t\tnum_chars;\n    char_u\t\t*newp, *oldp;\n    size_t\t\toldlen;\n    struct block_def\tbd;\n    char_u\t\t*after_p = NULL;\n    int\t\t\thad_ctrl_v_cr = FALSE;\n\n    if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)\n\treturn OK;\t    // nothing to do\n\n    if (c == REPLACE_CR_NCHAR)\n    {\n\thad_ctrl_v_cr = TRUE;\n\tc = CAR;\n    }\n    else if (c == REPLACE_NL_NCHAR)\n    {\n\thad_ctrl_v_cr = TRUE;\n\tc = NL;\n    }\n\n    if (has_mbyte)\n\tmb_adjust_opend(oap);\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn FAIL;\n\n    /*\n     * block mode replace\n     */\n    if (oap->block_mode)\n    {\n\tbd.is_MAX = (curwin->w_curswant == MAXCOL);\n\tfor ( ; curwin->w_cursor.lnum <= oap->end.lnum; ++curwin->w_cursor.lnum)\n\t{\n\t    curwin->w_cursor.col = 0;  // make sure cursor position is valid\n\t    block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);\n\t    if (bd.textlen == 0 && (!virtual_op || bd.is_MAX))\n\t\tcontinue;\t    // nothing to replace\n\n\t    // n == number of extra chars required\n\t    // If we split a TAB, it may be replaced by several characters.\n\t    // Thus the number of characters may increase!\n\t    // If the range starts in virtual space, count the initial\n\t    // coladd offset as part of \"startspaces\"\n\t    if (virtual_op && bd.is_short && *bd.textstart == NUL)\n\t    {\n\t\tpos_T vpos;\n\n\t\tvpos.lnum = curwin->w_cursor.lnum;\n\t\tgetvpos(&vpos, oap->start_vcol);\n\t\tbd.startspaces += vpos.coladd;\n\t\tn = bd.startspaces;\n\t    }\n\t    else\n\t\t// allow for pre spaces\n\t\tn = (bd.startspaces ? bd.start_char_vcols - 1 : 0);\n\n\t    // allow for post spp\n\t    n += (bd.endspaces\n\t\t    && !bd.is_oneChar\n\t\t    && bd.end_char_vcols > 0) ? bd.end_char_vcols - 1 : 0;\n\t    // Figure out how many characters to replace.\n\t    numc = oap->end_vcol - oap->start_vcol + 1;\n\t    if (bd.is_short && (!virtual_op || bd.is_MAX))\n\t\tnumc -= (oap->end_vcol - bd.end_vcol) + 1;\n\n\t    // A double-wide character can be replaced only up to half the\n\t    // times.\n\t    if ((*mb_char2cells)(c) > 1)\n\t    {\n\t\tif ((numc & 1) && !bd.is_short)\n\t\t{\n\t\t    ++bd.endspaces;\n\t\t    ++n;\n\t\t}\n\t\tnumc = numc / 2;\n\t    }\n\n\t    // Compute bytes needed, move character count to num_chars.\n\t    num_chars = numc;\n\t    numc *= (*mb_char2len)(c);\n\t    // oldlen includes textlen, so don't double count\n\t    n += numc - bd.textlen;\n\n\t    oldp = ml_get_curline();\n\t    oldlen = STRLEN(oldp);\n\t    newp = alloc(oldlen + 1 + n);\n\t    if (newp == NULL)\n\t\tcontinue;\n\t    vim_memset(newp, NUL, (size_t)(oldlen + 1 + n));\n\t    // copy up to deleted part\n\t    mch_memmove(newp, oldp, (size_t)bd.textcol);\n\t    oldp += bd.textcol + bd.textlen;\n\t    // insert pre-spaces\n\t    vim_memset(newp + bd.textcol, ' ', (size_t)bd.startspaces);\n\t    // insert replacement chars CHECK FOR ALLOCATED SPACE\n\t    // REPLACE_CR_NCHAR/REPLACE_NL_NCHAR is used for entering CR\n\t    // literally.\n\t    if (had_ctrl_v_cr || (c != '\\r' && c != '\\n'))\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = (int)STRLEN(newp);\n\t\t    while (--num_chars >= 0)\n\t\t\tn += (*mb_char2bytes)(c, newp + n);\n\t\t}\n\t\telse\n\t\t    vim_memset(newp + STRLEN(newp), c, (size_t)numc);\n\t\tif (!bd.is_short)\n\t\t{\n\t\t    // insert post-spaces\n\t\t    vim_memset(newp + STRLEN(newp), ' ', (size_t)bd.endspaces);\n\t\t    // copy the part after the changed part\n\t\t    STRMOVE(newp + STRLEN(newp), oldp);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Replacing with \\r or \\n means splitting the line.\n\t\tafter_p = alloc(oldlen + 1 + n - STRLEN(newp));\n\t\tif (after_p != NULL)\n\t\t    STRMOVE(after_p, oldp);\n\t    }\n\t    // replace the line\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\t    if (after_p != NULL)\n\t    {\n\t\tml_append(curwin->w_cursor.lnum++, after_p, 0, FALSE);\n\t\tappended_lines_mark(curwin->w_cursor.lnum, 1L);\n\t\toap->end.lnum++;\n\t\tvim_free(after_p);\n\t    }\n\t}\n    }\n    else\n    {\n\t/*\n\t * MCHAR and MLINE motion replace.\n\t */\n\tif (oap->motion_type == MLINE)\n\t{\n\t    oap->start.col = 0;\n\t    curwin->w_cursor.col = 0;\n\t    oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t    if (oap->end.col)\n\t\t--oap->end.col;\n\t}\n\telse if (!oap->inclusive)\n\t    dec(&(oap->end));\n\n\twhile (LTOREQ_POS(curwin->w_cursor, oap->end))\n\t{\n\t    n = gchar_cursor();\n\t    if (n != NUL)\n\t    {\n\t\tint new_byte_len = (*mb_char2len)(c);\n\t\tint old_byte_len = mb_ptr2len(ml_get_cursor());\n\n\t\tif (new_byte_len > 1 || old_byte_len > 1)\n\t\t{\n\t\t    // This is slow, but it handles replacing a single-byte\n\t\t    // with a multi-byte and the other way around.\n\t\t    if (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\toap->end.col += new_byte_len - old_byte_len;\n\t\t    replace_character(c);\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (n == TAB)\n\t\t    {\n\t\t\tint end_vcol = 0;\n\n\t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\t{\n\t\t\t    // oap->end has to be recalculated when\n\t\t\t    // the tab breaks\n\t\t\t    end_vcol = getviscol2(oap->end.col,\n\t\t\t\t\t\t\t     oap->end.coladd);\n\t\t\t}\n\t\t\tcoladvance_force(getviscol());\n\t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\t    getvpos(&oap->end, end_vcol);\n\t\t    }\n\t\t    PBYTE(curwin->w_cursor, c);\n\t\t}\n\t    }\n\t    else if (virtual_op && curwin->w_cursor.lnum == oap->end.lnum)\n\t    {\n\t\tint virtcols = oap->end.coladd;\n\n\t\tif (curwin->w_cursor.lnum == oap->start.lnum\n\t\t\t&& oap->start.col == oap->end.col && oap->start.coladd)\n\t\t    virtcols -= oap->start.coladd;\n\n\t\t// oap->end has been trimmed so it's effectively inclusive;\n\t\t// as a result an extra +1 must be counted so we don't\n\t\t// trample the NUL byte.\n\t\tcoladvance_force(getviscol2(oap->end.col, oap->end.coladd) + 1);\n\t\tcurwin->w_cursor.col -= (virtcols + 1);\n\t\tfor (; virtcols >= 0; virtcols--)\n\t\t{\n\t\t    if ((*mb_char2len)(c) > 1)\n\t\t       replace_character(c);\n\t\t    else\n\t\t\tPBYTE(curwin->w_cursor, c);\n\t\t   if (inc(&curwin->w_cursor) == -1)\n\t\t       break;\n\t\t}\n\t    }\n\n\t    // Advance to next character, stop at the end of the file.\n\t    if (inc_cursor() == -1)\n\t\tbreak;\n\t}\n    }\n\n    curwin->w_cursor = oap->start;\n    check_cursor();\n    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1, 0L);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n\n    return OK;\n}\n\nstatic int swapchars(int op_type, pos_T *pos, int length);\n\n/*\n * Handle the (non-standard vi) tilde operator.  Also for \"gu\", \"gU\" and \"g?\".\n */\n    static void\nop_tilde(oparg_T *oap)\n{\n    pos_T\t\tpos;\n    struct block_def\tbd;\n    int\t\t\tdid_change = FALSE;\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n\n    pos = oap->start;\n    if (oap->block_mode)\t\t    // Visual block mode\n    {\n\tfor (; pos.lnum <= oap->end.lnum; ++pos.lnum)\n\t{\n\t    int one_change;\n\n\t    block_prep(oap, &bd, pos.lnum, FALSE);\n\t    pos.col = bd.textcol;\n\t    one_change = swapchars(oap->op_type, &pos, bd.textlen);\n\t    did_change |= one_change;\n\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active() && one_change)\n\t    {\n\t\tchar_u *ptr;\n\n\t\tnetbeans_removed(curbuf, pos.lnum, bd.textcol,\n\t\t\t\t\t\t\t    (long)bd.textlen);\n\t\t// get the line now, it may have been flushed\n\t\tptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\tnetbeans_inserted(curbuf, pos.lnum, bd.textcol,\n\t\t\t\t\t\t&ptr[bd.textcol], bd.textlen);\n\t    }\n#endif\n\t}\n\tif (did_change)\n\t    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);\n    }\n    else\t\t\t\t    // not block mode\n    {\n\tif (oap->motion_type == MLINE)\n\t{\n\t    oap->start.col = 0;\n\t    pos.col = 0;\n\t    oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t    if (oap->end.col)\n\t\t--oap->end.col;\n\t}\n\telse if (!oap->inclusive)\n\t    dec(&(oap->end));\n\n\tif (pos.lnum == oap->end.lnum)\n\t    did_change = swapchars(oap->op_type, &pos,\n\t\t\t\t\t\t  oap->end.col - pos.col + 1);\n\telse\n\t    for (;;)\n\t    {\n\t\tdid_change |= swapchars(oap->op_type, &pos,\n\t\t\t\tpos.lnum == oap->end.lnum ? oap->end.col + 1:\n\t\t\t\t\t   (int)STRLEN(ml_get_pos(&pos)));\n\t\tif (LTOREQ_POS(oap->end, pos) || inc(&pos) == -1)\n\t\t    break;\n\t    }\n\tif (did_change)\n\t{\n\t    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tchar_u *ptr;\n\t\tint count;\n\n\t\tpos = oap->start;\n\t\twhile (pos.lnum < oap->end.lnum)\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\t    count = (int)STRLEN(ptr) - pos.col;\n\t\t    netbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\t\t    // get the line again, it may have been flushed\n\t\t    ptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\t    netbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n\t\tcount = oap->end.col - pos.col + 1;\n\t\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\t\t// get the line again, it may have been flushed\n\t\tptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t    }\n#endif\n\t}\n    }\n\n    if (!did_change && oap->is_VIsual)\n\t// No change: need to remove the Visual selection\n\tredraw_curbuf_later(UPD_INVERTED);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set '[ and '] marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n\n    if (oap->line_count > p_report)\n\tsmsg(NGETTEXT(\"%ld line changed\", \"%ld lines changed\",\n\t\t\t\t\t    oap->line_count), oap->line_count);\n}\n\n/*\n * Invoke swapchar() on \"length\" bytes at position \"pos\".\n * \"pos\" is advanced to just after the changed characters.\n * \"length\" is rounded up to include the whole last multi-byte character.\n * Also works correctly when the number of bytes changes.\n * Returns TRUE if some character was changed.\n */\n    static int\nswapchars(int op_type, pos_T *pos, int length)\n{\n    int todo;\n    int\tdid_change = 0;\n\n    for (todo = length; todo > 0; --todo)\n    {\n\tif (has_mbyte)\n\t{\n\t    int len = (*mb_ptr2len)(ml_get_pos(pos));\n\n\t    // we're counting bytes, not characters\n\t    if (len > 0)\n\t\ttodo -= len - 1;\n\t}\n\tdid_change |= swapchar(op_type, pos);\n\tif (inc(pos) == -1)    // at end of file\n\t    break;\n    }\n    return did_change;\n}\n\n/*\n * If op_type == OP_UPPER: make uppercase,\n * if op_type == OP_LOWER: make lowercase,\n * if op_type == OP_ROT13: do rot13 encoding,\n * else swap case of character at 'pos'\n * returns TRUE when something actually changed.\n */\n    int\nswapchar(int op_type, pos_T *pos)\n{\n    int\t    c;\n    int\t    nc;\n\n    c = gchar_pos(pos);\n\n    // Only do rot13 encoding for ASCII characters.\n    if (c >= 0x80 && op_type == OP_ROT13)\n\treturn FALSE;\n\n    if (op_type == OP_UPPER && c == 0xdf\n\t\t      && (enc_latin1like || STRCMP(p_enc, \"iso-8859-2\") == 0))\n    {\n\tpos_T   sp = curwin->w_cursor;\n\n\t// Special handling of German sharp s: change to \"SS\".\n\tcurwin->w_cursor = *pos;\n\tdel_char(FALSE);\n\tins_char('S');\n\tins_char('S');\n\tcurwin->w_cursor = sp;\n\tinc(pos);\n    }\n\n    if (enc_dbcs != 0 && c >= 0x100)\t// No lower/uppercase letter\n\treturn FALSE;\n    nc = c;\n    if (MB_ISLOWER(c))\n    {\n\tif (op_type == OP_ROT13)\n\t    nc = ROT13(c, 'a');\n\telse if (op_type != OP_LOWER)\n\t    nc = MB_TOUPPER(c);\n    }\n    else if (MB_ISUPPER(c))\n    {\n\tif (op_type == OP_ROT13)\n\t    nc = ROT13(c, 'A');\n\telse if (op_type != OP_UPPER)\n\t    nc = MB_TOLOWER(c);\n    }\n    if (nc != c)\n    {\n\tif (enc_utf8 && (c >= 0x80 || nc >= 0x80))\n\t{\n\t    pos_T   sp = curwin->w_cursor;\n\n\t    curwin->w_cursor = *pos;\n\t    // don't use del_char(), it also removes composing chars\n\t    del_bytes(utf_ptr2len(ml_get_cursor()), FALSE, FALSE);\n\t    ins_char(nc);\n\t    curwin->w_cursor = sp;\n\t}\n\telse\n\t    PBYTE(*pos, nc);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * op_insert - Insert and append operators for Visual mode.\n */\n    void\nop_insert(oparg_T *oap, long count1)\n{\n    long\t\tins_len, pre_textlen = 0;\n    char_u\t\t*firstline, *ins_text;\n    colnr_T\t\tind_pre_col = 0, ind_post_col;\n    int\t\t\tind_pre_vcol = 0, ind_post_vcol = 0;\n    struct block_def\tbd;\n    int\t\t\ti;\n    pos_T\t\tt1;\n    pos_T\t\tstart_insert;\n\t\t\t// offset when cursor was moved in insert mode\n    int\t\t\toffset = 0;\n\n    // edit() changes this - record it for OP_APPEND\n    bd.is_MAX = (curwin->w_curswant == MAXCOL);\n\n    // vis block is still marked. Get rid of it now.\n    curwin->w_cursor.lnum = oap->start.lnum;\n    update_screen(UPD_INVERTED);\n\n    if (oap->block_mode)\n    {\n\t// When 'virtualedit' is used, need to insert the extra spaces before\n\t// doing block_prep().  When only \"block\" is used, virtual edit is\n\t// already disabled, but still need it when calling\n\t// coladvance_force().\n\t// coladvance_force() uses get_ve_flags() to get the 'virtualedit'\n\t// state for the current window.  To override that state, we need to\n\t// set the window-local value of ve_flags rather than the global value.\n\tif (curwin->w_cursor.coladd > 0)\n\t{\n\t    int\t\told_ve_flags = curwin->w_ve_flags;\n\n\t    if (u_save_cursor() == FAIL)\n\t\treturn;\n\n\t    curwin->w_ve_flags = VE_ALL;\n\t    coladvance_force(oap->op_type == OP_APPEND\n\t\t\t\t\t   ? oap->end_vcol + 1 : getviscol());\n\t    if (oap->op_type == OP_APPEND)\n\t\t--curwin->w_cursor.col;\n\t    curwin->w_ve_flags = old_ve_flags;\n\t}\n\t// Get the info about the block before entering the text\n\tblock_prep(oap, &bd, oap->start.lnum, TRUE);\n\t// Get indent information\n\tind_pre_col = (colnr_T)getwhitecols_curline();\n\tind_pre_vcol = get_indent();\n\tfirstline = ml_get(oap->start.lnum) + bd.textcol;\n\n\tif (oap->op_type == OP_APPEND)\n\t    firstline += bd.textlen;\n\tpre_textlen = (long)STRLEN(firstline);\n    }\n\n    if (oap->op_type == OP_APPEND)\n    {\n\tif (oap->block_mode && curwin->w_cursor.coladd == 0)\n\t{\n\t    // Move the cursor to the character right of the block.\n\t    curwin->w_set_curswant = TRUE;\n\t    while (*ml_get_cursor() != NUL\n\t\t    && (curwin->w_cursor.col < bd.textcol + bd.textlen))\n\t\t++curwin->w_cursor.col;\n\t    if (bd.is_short && !bd.is_MAX)\n\t    {\n\t\t// First line was too short, make it longer and adjust the\n\t\t// values in \"bd\".\n\t\tif (u_save_cursor() == FAIL)\n\t\t    return;\n\t\tfor (i = 0; i < bd.endspaces; ++i)\n\t\t    ins_char(' ');\n\t\tbd.textlen += bd.endspaces;\n\t    }\n\t}\n\telse\n\t{\n\t    curwin->w_cursor = oap->end;\n\t    check_cursor_col();\n\n\t    // Works just like an 'i'nsert on the next character.\n\t    if (!LINEEMPTY(curwin->w_cursor.lnum)\n\t\t    && oap->start_vcol != oap->end_vcol)\n\t\tinc_cursor();\n\t}\n    }\n\n    t1 = oap->start;\n    start_insert = curwin->w_cursor;\n    (void)edit(NUL, FALSE, (linenr_T)count1);\n\n    // When a tab was inserted, and the characters in front of the tab\n    // have been converted to a tab as well, the column of the cursor\n    // might have actually been reduced, so need to adjust here.\n    if (t1.lnum == curbuf->b_op_start_orig.lnum\n\t    && LT_POS(curbuf->b_op_start_orig, t1))\n\toap->start = curbuf->b_op_start_orig;\n\n    // If user has moved off this line, we don't know what to do, so do\n    // nothing.\n    // Also don't repeat the insert when Insert mode ended with CTRL-C.\n    if (curwin->w_cursor.lnum != oap->start.lnum || got_int)\n\treturn;\n\n    if (oap->block_mode)\n    {\n\tstruct block_def\tbd2;\n\tint\t\t\tdid_indent = FALSE;\n\tsize_t\t\t\tlen;\n\tint\t\t\tadd;\n\n\t// If indent kicked in, the firstline might have changed\n\t// but only do that, if the indent actually increased.\n\tind_post_col = (colnr_T)getwhitecols_curline();\n\tif (curbuf->b_op_start.col > ind_pre_col && ind_post_col > ind_pre_col)\n\t{\n\t    bd.textcol += ind_post_col - ind_pre_col;\n\t    ind_post_vcol = get_indent();\n\t    bd.start_vcol += ind_post_vcol - ind_pre_vcol;\n\t    did_indent = TRUE;\n\t}\n\n\t// The user may have moved the cursor before inserting something, try\n\t// to adjust the block for that.  But only do it, if the difference\n\t// does not come from indent kicking in.\n\tif (oap->start.lnum == curbuf->b_op_start_orig.lnum\n\t\t\t\t\t\t  && !bd.is_MAX && !did_indent)\n\t{\n\t    int t = getviscol2(curbuf->b_op_start_orig.col,\n\t\t\t\t\t       curbuf->b_op_start_orig.coladd);\n\n\t    if (oap->op_type == OP_INSERT\n\t\t    && oap->start.col + oap->start.coladd\n\t\t\t    != curbuf->b_op_start_orig.col\n\t\t\t\t\t      + curbuf->b_op_start_orig.coladd)\n\t    {\n\t\toap->start.col = curbuf->b_op_start_orig.col;\n\t\tpre_textlen -= t - oap->start_vcol;\n\t\toap->start_vcol = t;\n\t    }\n\t    else if (oap->op_type == OP_APPEND\n\t\t    && oap->start.col + oap->start.coladd\n\t\t\t    >= curbuf->b_op_start_orig.col\n\t\t\t\t\t      + curbuf->b_op_start_orig.coladd)\n\t    {\n\t\toap->start.col = curbuf->b_op_start_orig.col;\n\t\t// reset pre_textlen to the value of OP_INSERT\n\t\tpre_textlen += bd.textlen;\n\t\tpre_textlen -= t - oap->start_vcol;\n\t\toap->start_vcol = t;\n\t\toap->op_type = OP_INSERT;\n\t    }\n\t}\n\n\t// Spaces and tabs in the indent may have changed to other spaces and\n\t// tabs.  Get the starting column again and correct the length.\n\t// Don't do this when \"$\" used, end-of-line will have changed.\n\t//\n\t// if indent was added and the inserted text was after the indent,\n\t// correct the selection for the new indent.\n\tif (did_indent && bd.textcol - ind_post_col > 0)\n\t{\n\t    oap->start.col += ind_post_col - ind_pre_col;\n\t    oap->start_vcol += ind_post_vcol - ind_pre_vcol;\n\t    oap->end.col += ind_post_col - ind_pre_col;\n\t    oap->end_vcol += ind_post_vcol - ind_pre_vcol;\n\t}\n\tblock_prep(oap, &bd2, oap->start.lnum, TRUE);\n\tif (did_indent && bd.textcol - ind_post_col > 0)\n\t{\n\t    // undo for where \"oap\" is used below\n\t    oap->start.col -= ind_post_col - ind_pre_col;\n\t    oap->start_vcol -= ind_post_vcol - ind_pre_vcol;\n\t    oap->end.col -= ind_post_col - ind_pre_col;\n\t    oap->end_vcol -= ind_post_vcol - ind_pre_vcol;\n\t}\n\tif (!bd.is_MAX || bd2.textlen < bd.textlen)\n\t{\n\t    if (oap->op_type == OP_APPEND)\n\t    {\n\t\tpre_textlen += bd2.textlen - bd.textlen;\n\t\tif (bd2.endspaces)\n\t\t    --bd2.textlen;\n\t    }\n\t    bd.textcol = bd2.textcol;\n\t    bd.textlen = bd2.textlen;\n\t}\n\n\t/*\n\t * Subsequent calls to ml_get() flush the firstline data - take a\n\t * copy of the required string.\n\t */\n\tfirstline = ml_get(oap->start.lnum);\n\tlen = STRLEN(firstline);\n\tadd = bd.textcol;\n\tif (oap->op_type == OP_APPEND)\n\t{\n\t    add += bd.textlen;\n\t    // account for pressing cursor in insert mode when '$' was used\n\t    if (bd.is_MAX\n\t\t&& (start_insert.lnum == Insstart.lnum\n\t\t\t\t\t   && start_insert.col > Insstart.col))\n\t    {\n\t\toffset = (start_insert.col - Insstart.col);\n\t\tadd -= offset;\n\t\tif (oap->end_vcol > offset)\n\t\t    oap->end_vcol -= (offset + 1);\n\t\telse\n\t\t    // moved outside of the visual block, what to do?\n\t\t    return;\n\t    }\n\t}\n\tif ((size_t)add > len)\n\t    firstline += len;  // short line, point to the NUL\n\telse\n\t    firstline += add;\n\tif (pre_textlen >= 0 && (ins_len =\n\t\t\t   (long)STRLEN(firstline) - pre_textlen - offset) > 0)\n\t{\n\t    ins_text = vim_strnsave(firstline, ins_len);\n\t    if (ins_text != NULL)\n\t    {\n\t\t// block handled here\n\t\tif (u_save(oap->start.lnum,\n\t\t\t\t\t (linenr_T)(oap->end.lnum + 1)) == OK)\n\t\t    block_insert(oap, ins_text, (oap->op_type == OP_INSERT),\n\t\t\t\t\t\t\t\t\t &bd);\n\n\t\tcurwin->w_cursor.col = oap->start.col;\n\t\tcheck_cursor();\n\t\tvim_free(ins_text);\n\t    }\n\t}\n    }\n}\n\n/*\n * op_change - handle a change operation\n *\n * return TRUE if edit() returns because of a CTRL-O command\n */\n    int\nop_change(oparg_T *oap)\n{\n    colnr_T\t\tl;\n    int\t\t\tretval;\n    long\t\toffset;\n    linenr_T\t\tlinenr;\n    long\t\tins_len;\n    long\t\tpre_textlen = 0;\n    long\t\tpre_indent = 0;\n    char_u\t\t*firstline;\n    char_u\t\t*ins_text, *newp, *oldp;\n    struct block_def\tbd;\n\n    l = oap->start.col;\n    if (oap->motion_type == MLINE)\n    {\n\tl = 0;\n\tcan_si = may_do_si();\t// Like opening a new line, do smart indent\n    }\n\n    // First delete the text in the region.  In an empty buffer only need to\n    // save for undo\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return FALSE;\n    }\n    else if (op_delete(oap) == FAIL)\n\treturn FALSE;\n\n    if ((l > curwin->w_cursor.col) && !LINEEMPTY(curwin->w_cursor.lnum)\n\t\t\t\t\t\t\t && !virtual_op)\n\tinc_cursor();\n\n    // check for still on same line (<CR> in inserted text meaningless)\n    // skip blank lines too\n    if (oap->block_mode)\n    {\n\t// Add spaces before getting the current line length.\n\tif (virtual_op && (curwin->w_cursor.coladd > 0\n\t\t\t\t\t\t    || gchar_cursor() == NUL))\n\t    coladvance_force(getviscol());\n\tfirstline = ml_get(oap->start.lnum);\n\tpre_textlen = (long)STRLEN(firstline);\n\tpre_indent = (long)getwhitecols(firstline);\n\tbd.textcol = curwin->w_cursor.col;\n    }\n\n    if (oap->motion_type == MLINE)\n\tfix_indent();\n\n    retval = edit(NUL, FALSE, (linenr_T)1);\n\n    /*\n     * In Visual block mode, handle copying the new text to all lines of the\n     * block.\n     * Don't repeat the insert when Insert mode ended with CTRL-C.\n     */\n    if (oap->block_mode && oap->start.lnum != oap->end.lnum && !got_int)\n    {\n\t// Auto-indenting may have changed the indent.  If the cursor was past\n\t// the indent, exclude that indent change from the inserted text.\n\tfirstline = ml_get(oap->start.lnum);\n\tif (bd.textcol > (colnr_T)pre_indent)\n\t{\n\t    long new_indent = (long)getwhitecols(firstline);\n\n\t    pre_textlen += new_indent - pre_indent;\n\t    bd.textcol += new_indent - pre_indent;\n\t}\n\n\tins_len = (long)STRLEN(firstline) - pre_textlen;\n\tif (ins_len > 0)\n\t{\n\t    // Subsequent calls to ml_get() flush the firstline data - take a\n\t    // copy of the inserted text.\n\t    if ((ins_text = alloc(ins_len + 1)) != NULL)\n\t    {\n\t\tvim_strncpy(ins_text, firstline + bd.textcol, (size_t)ins_len);\n\t\tfor (linenr = oap->start.lnum + 1; linenr <= oap->end.lnum;\n\t\t\t\t\t\t\t\t     linenr++)\n\t\t{\n\t\t    block_prep(oap, &bd, linenr, TRUE);\n\t\t    if (!bd.is_short || virtual_op)\n\t\t    {\n\t\t\tpos_T vpos;\n\n\t\t\t// If the block starts in virtual space, count the\n\t\t\t// initial coladd offset as part of \"startspaces\"\n\t\t\tif (bd.is_short)\n\t\t\t{\n\t\t\t    vpos.lnum = linenr;\n\t\t\t    (void)getvpos(&vpos, oap->start_vcol);\n\t\t\t}\n\t\t\telse\n\t\t\t    vpos.coladd = 0;\n\t\t\toldp = ml_get(linenr);\n\t\t\tnewp = alloc(STRLEN(oldp) + vpos.coladd + ins_len + 1);\n\t\t\tif (newp == NULL)\n\t\t\t    continue;\n\t\t\t// copy up to block start\n\t\t\tmch_memmove(newp, oldp, (size_t)bd.textcol);\n\t\t\toffset = bd.textcol;\n\t\t\tvim_memset(newp + offset, ' ', (size_t)vpos.coladd);\n\t\t\toffset += vpos.coladd;\n\t\t\tmch_memmove(newp + offset, ins_text, (size_t)ins_len);\n\t\t\toffset += ins_len;\n\t\t\toldp += bd.textcol;\n\t\t\tSTRMOVE(newp + offset, oldp);\n\t\t\tml_replace(linenr, newp, FALSE);\n#ifdef FEAT_PROP_POPUP\n\t\t\t// Shift the properties for linenr as edit() would do.\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t    adjust_prop_columns(linenr, bd.textcol,\n\t\t\t\t\t\t     vpos.coladd + ins_len, 0);\n#endif\n\t\t    }\n\t\t}\n\t\tcheck_cursor();\n\n\t\tchanged_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\t    }\n\t    vim_free(ins_text);\n\t}\n    }\n    auto_format(FALSE, TRUE);\n\n    return retval;\n}\n\n/*\n * When the cursor is on the NUL past the end of the line and it should not be\n * there move it left.\n */\n    void\nadjust_cursor_eol(void)\n{\n    unsigned int cur_ve_flags = get_ve_flags();\n\n    if (curwin->w_cursor.col > 0\n\t    && gchar_cursor() == NUL\n\t    && (cur_ve_flags & VE_ONEMORE) == 0\n\t    && !(restart_edit || (State & MODE_INSERT)))\n    {\n\t// Put the cursor on the last character in the line.\n\tdec_cursor();\n\n\tif (cur_ve_flags == VE_ALL)\n\t{\n\t    colnr_T\t    scol, ecol;\n\n\t    // Coladd is set to the width of the last character.\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol + 1;\n\t}\n    }\n}\n\n/*\n * If \"process\" is TRUE and the line begins with a comment leader (possibly\n * after some white space), return a pointer to the text after it. Put a boolean\n * value indicating whether the line ends with an unclosed comment in\n * \"is_comment\".\n * line - line to be processed,\n * process - if FALSE, will only check whether the line ends with an unclosed\n *\t     comment,\n * include_space - whether to also skip space following the comment leader,\n * is_comment - will indicate whether the current line ends with an unclosed\n *\t\tcomment.\n */\n    char_u *\nskip_comment(\n    char_u   *line,\n    int      process,\n    int\t     include_space,\n    int      *is_comment)\n{\n    char_u *comment_flags = NULL;\n    int    lead_len;\n    int    leader_offset = get_last_leader_offset(line, &comment_flags);\n\n    *is_comment = FALSE;\n    if (leader_offset != -1)\n    {\n\t// Let's check whether the line ends with an unclosed comment.\n\t// If the last comment leader has COM_END in flags, there's no comment.\n\twhile (*comment_flags)\n\t{\n\t    if (*comment_flags == COM_END\n\t\t    || *comment_flags == ':')\n\t\tbreak;\n\t    ++comment_flags;\n\t}\n\tif (*comment_flags != COM_END)\n\t    *is_comment = TRUE;\n    }\n\n    if (process == FALSE)\n\treturn line;\n\n    lead_len = get_leader_len(line, &comment_flags, FALSE, include_space);\n\n    if (lead_len == 0)\n\treturn line;\n\n    // Find:\n    // - COM_END,\n    // - colon,\n    // whichever comes first.\n    while (*comment_flags)\n    {\n\tif (*comment_flags == COM_END\n\t\t|| *comment_flags == ':')\n\t    break;\n\t++comment_flags;\n    }\n\n    // If we found a colon, it means that we are not processing a line\n    // starting with a closing part of a three-part comment. That's good,\n    // because we don't want to remove those as this would be annoying.\n    if (*comment_flags == ':' || *comment_flags == NUL)\n\tline += lead_len;\n\n    return line;\n}\n\n/*\n * Join 'count' lines (minimal 2) at the cursor position.\n * When \"save_undo\" is TRUE save lines for undo first.\n * Set \"use_formatoptions\" to FALSE when e.g. processing backspace and comment\n * leaders should not be removed.\n * When setmark is TRUE, sets the '[ and '] mark, else, the caller is expected\n * to set those marks.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_join(\n    long    count,\n    int\t    insert_space,\n    int\t    save_undo,\n    int\t    use_formatoptions UNUSED,\n    int\t    setmark)\n{\n    char_u\t*curr = NULL;\n    char_u      *curr_start = NULL;\n    char_u\t*cend;\n    char_u\t*newp;\n    size_t\tnewp_len;\n    char_u\t*spaces;\t// number of spaces inserted before a line\n    int\t\tendcurr1 = NUL;\n    int\t\tendcurr2 = NUL;\n    int\t\tcurrsize = 0;\t// size of the current line\n    int\t\tsumsize = 0;\t// size of the long new line\n    linenr_T\tt;\n    colnr_T\tcol = 0;\n    int\t\tret = OK;\n    int\t\t*comments = NULL;\n    int\t\tremove_comments = (use_formatoptions == TRUE)\n\t\t\t\t  && has_format_option(FO_REMOVE_COMS);\n    int\t\tprev_was_comment;\n#ifdef FEAT_PROP_POPUP\n    int\t\tpropcount = 0;\t// number of props over all joined lines\n    int\t\tprops_remaining;\n#endif\n\n    if (save_undo && u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t\t    (linenr_T)(curwin->w_cursor.lnum + count)) == FAIL)\n\treturn FAIL;\n\n    // Allocate an array to store the number of spaces inserted before each\n    // line.  We will use it to pre-compute the length of the new line and the\n    // proper placement of each original line in the new one.\n    spaces = lalloc_clear(count, TRUE);\n    if (spaces == NULL)\n\treturn FAIL;\n    if (remove_comments)\n    {\n\tcomments = lalloc_clear(count * sizeof(int), TRUE);\n\tif (comments == NULL)\n\t{\n\t    vim_free(spaces);\n\t    return FAIL;\n\t}\n    }\n\n    /*\n     * Don't move anything yet, just compute the final line length\n     * and setup the array of space strings lengths\n     * This loops forward over the joined lines.\n     */\n    for (t = 0; t < count; ++t)\n    {\n\tcurr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t));\n#ifdef FEAT_PROP_POPUP\n\tpropcount += count_props((linenr_T) (curwin->w_cursor.lnum + t),\n\t\t\t\t\t\t\tt > 0, t + 1 == count);\n#endif\n\tif (t == 0 && setmark && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ mark.\n\t    curwin->w_buffer->b_op_start.lnum = curwin->w_cursor.lnum;\n\t    curwin->w_buffer->b_op_start.col  = (colnr_T)STRLEN(curr);\n\t}\n\tif (remove_comments)\n\t{\n\t    // We don't want to remove the comment leader if the\n\t    // previous line is not a comment.\n\t    if (t > 0 && prev_was_comment)\n\t    {\n\n\t\tchar_u *new_curr = skip_comment(curr, TRUE, insert_space,\n\t\t\t\t\t\t\t   &prev_was_comment);\n\t\tcomments[t] = (int)(new_curr - curr);\n\t\tcurr = new_curr;\n\t    }\n\t    else\n\t\tcurr = skip_comment(curr, FALSE, insert_space,\n\t\t\t\t\t\t\t   &prev_was_comment);\n\t}\n\n\tif (insert_space && t > 0)\n\t{\n\t    curr = skipwhite(curr);\n\t    if (*curr != NUL && *curr != ')'\n\t\t    && sumsize != 0 && endcurr1 != TAB\n\t\t    && (!has_format_option(FO_MBYTE_JOIN)\n\t\t\t|| (mb_ptr2char(curr) < 0x100 && endcurr1 < 0x100))\n\t\t    && (!has_format_option(FO_MBYTE_JOIN2)\n\t\t\t|| (mb_ptr2char(curr) < 0x100\n\t\t\t    && !(enc_utf8 && utf_eat_space(endcurr1)))\n\t\t\t|| (endcurr1 < 0x100\n\t\t\t    && !(enc_utf8 && utf_eat_space(mb_ptr2char(curr)))))\n\t       )\n\t    {\n\t\t// don't add a space if the line is ending in a space\n\t\tif (endcurr1 == ' ')\n\t\t    endcurr1 = endcurr2;\n\t\telse\n\t\t    ++spaces[t];\n\t\t// extra space when 'joinspaces' set and line ends in '.'\n\t\tif (       p_js\n\t\t\t&& (endcurr1 == '.'\n\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t&& (endcurr1 == '?' || endcurr1 == '!'))))\n\t\t    ++spaces[t];\n\t    }\n\t}\n\tcurrsize = (int)STRLEN(curr);\n\tsumsize += currsize + spaces[t];\n\tendcurr1 = endcurr2 = NUL;\n\tif (insert_space && currsize > 0)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tcend = curr + currsize;\n\t\tMB_PTR_BACK(curr, cend);\n\t\tendcurr1 = (*mb_ptr2char)(cend);\n\t\tif (cend > curr)\n\t\t{\n\t\t    MB_PTR_BACK(curr, cend);\n\t\t    endcurr2 = (*mb_ptr2char)(cend);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tendcurr1 = *(curr + currsize - 1);\n\t\tif (currsize > 1)\n\t\t    endcurr2 = *(curr + currsize - 2);\n\t    }\n\t}\n\tline_breakcheck();\n\tif (got_int)\n\t{\n\t    ret = FAIL;\n\t    goto theend;\n\t}\n    }\n\n    // store the column position before last line\n    col = sumsize - currsize - spaces[count - 1];\n\n    // allocate the space for the new line\n    newp_len = sumsize + 1;\n#ifdef FEAT_PROP_POPUP\n    newp_len += propcount * sizeof(textprop_T);\n#endif\n    newp = alloc(newp_len);\n    if (newp == NULL)\n    {\n\tret = FAIL;\n\tgoto theend;\n    }\n    cend = newp + sumsize;\n    *cend = 0;\n\n    /*\n     * Move affected lines to the new long one.\n     * This loops backwards over the joined lines, including the original line.\n     *\n     * Move marks from each deleted line to the joined line, adjusting the\n     * column.  This is not Vi compatible, but Vi deletes the marks, thus that\n     * should not really be a problem.\n     */\n#ifdef FEAT_PROP_POPUP\n    props_remaining = propcount;\n#endif\n    for (t = count - 1; ; --t)\n    {\n\tint spaces_removed;\n\n\tcend -= currsize;\n\tmch_memmove(cend, curr, (size_t)currsize);\n\n\tif (spaces[t] > 0)\n\t{\n\t    cend -= spaces[t];\n\t    vim_memset(cend, ' ', (size_t)(spaces[t]));\n\t}\n\n\t// If deleting more spaces than adding, the cursor moves no more than\n\t// what is added if it is inside these spaces.\n\tspaces_removed = (curr - curr_start) - spaces[t];\n\n\tmark_col_adjust(curwin->w_cursor.lnum + t, (colnr_T)0, -t,\n\t\t\t (long)(cend - newp - spaces_removed), spaces_removed);\n#ifdef FEAT_PROP_POPUP\n\tprepend_joined_props(newp + sumsize + 1, propcount, &props_remaining,\n\t\tcurwin->w_cursor.lnum + t, t == count - 1,\n\t\t(long)(cend - newp), spaces_removed);\n#endif\n\tif (t == 0)\n\t    break;\n\tcurr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t - 1));\n\tif (remove_comments)\n\t    curr += comments[t - 1];\n\tif (insert_space && t > 1)\n\t    curr = skipwhite(curr);\n\tcurrsize = (int)STRLEN(curr);\n    }\n\n    ml_replace_len(curwin->w_cursor.lnum, newp, (colnr_T)newp_len, TRUE, FALSE);\n\n    if (setmark && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set the '] mark.\n\tcurwin->w_buffer->b_op_end.lnum = curwin->w_cursor.lnum;\n\tcurwin->w_buffer->b_op_end.col  = (colnr_T)sumsize;\n    }\n\n    // Only report the change in the first line here, del_lines() will report\n    // the deleted line.\n    changed_lines(curwin->w_cursor.lnum, currsize,\n\t\t\t\t\t       curwin->w_cursor.lnum + 1, 0L);\n    /*\n     * Delete following lines. To do this we move the cursor there\n     * briefly, and then move it back. After del_lines() the cursor may\n     * have moved up (last line deleted), so the current lnum is kept in t.\n     */\n    t = curwin->w_cursor.lnum;\n    ++curwin->w_cursor.lnum;\n    del_lines(count - 1, FALSE);\n    curwin->w_cursor.lnum = t;\n\n    /*\n     * Set the cursor column:\n     * Vi compatible: use the column of the first join\n     * vim:\t      use the column of the last join\n     */\n    curwin->w_cursor.col =\n\t\t    (vim_strchr(p_cpo, CPO_JOINCOL) != NULL ? currsize : col);\n    check_cursor_col();\n\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = TRUE;\n\ntheend:\n    vim_free(spaces);\n    if (remove_comments)\n\tvim_free(comments);\n    return ret;\n}\n\n/*\n * prepare a few things for block mode yank/delete/tilde\n *\n * for delete:\n * - textlen includes the first/last char to be (partly) deleted\n * - start/endspaces is the number of columns that are taken by the\n *   first/last deleted char minus the number of columns that have to be\n *   deleted.\n * for yank and tilde:\n * - textlen includes the first/last char to be wholly yanked\n * - start/endspaces is the number of columns of the first/last yanked char\n *   that are to be yanked.\n */\n    void\nblock_prep(\n    oparg_T\t\t*oap,\n    struct block_def\t*bdp,\n    linenr_T\t\tlnum,\n    int\t\t\tis_del)\n{\n    int\t\tincr = 0;\n    char_u\t*pend;\n    char_u\t*pstart;\n    char_u\t*line;\n    char_u\t*prev_pstart;\n    char_u\t*prev_pend;\n    chartabsize_T cts;\n#ifdef FEAT_LINEBREAK\n    int\t\tlbr_saved = curwin->w_p_lbr;\n\n    // Avoid a problem with unwanted linebreaks in block mode.\n    curwin->w_p_lbr = FALSE;\n#endif\n    bdp->startspaces = 0;\n    bdp->endspaces = 0;\n    bdp->textlen = 0;\n    bdp->start_vcol = 0;\n    bdp->end_vcol = 0;\n    bdp->is_short = FALSE;\n    bdp->is_oneChar = FALSE;\n    bdp->pre_whitesp = 0;\n    bdp->pre_whitesp_c = 0;\n    bdp->end_char_vcols = 0;\n    bdp->start_char_vcols = 0;\n\n    line = ml_get(lnum);\n    prev_pstart = line;\n    init_chartabsize_arg(&cts, curwin, lnum, bdp->start_vcol, line, line);\n    while (cts.cts_vcol < oap->start_vcol && *cts.cts_ptr != NUL)\n    {\n\t// Count a tab for what it's worth (if list mode not on)\n\tincr = lbr_chartabsize(&cts);\n\tcts.cts_vcol += incr;\n\tif (VIM_ISWHITE(*cts.cts_ptr))\n\t{\n\t    bdp->pre_whitesp += incr;\n\t    bdp->pre_whitesp_c++;\n\t}\n\telse\n\t{\n\t    bdp->pre_whitesp = 0;\n\t    bdp->pre_whitesp_c = 0;\n\t}\n\tprev_pstart = cts.cts_ptr;\n\tMB_PTR_ADV(cts.cts_ptr);\n    }\n    bdp->start_vcol = cts.cts_vcol;\n    pstart = cts.cts_ptr;\n    clear_chartabsize_arg(&cts);\n\n    bdp->start_char_vcols = incr;\n    if (bdp->start_vcol < oap->start_vcol)\t// line too short\n    {\n\tbdp->end_vcol = bdp->start_vcol;\n\tbdp->is_short = TRUE;\n\tif (!is_del || oap->op_type == OP_APPEND)\n\t    bdp->endspaces = oap->end_vcol - oap->start_vcol + 1;\n    }\n    else\n    {\n\t// notice: this converts partly selected Multibyte characters to\n\t// spaces, too.\n\tbdp->startspaces = bdp->start_vcol - oap->start_vcol;\n\tif (is_del && bdp->startspaces)\n\t    bdp->startspaces = bdp->start_char_vcols - bdp->startspaces;\n\tpend = pstart;\n\tbdp->end_vcol = bdp->start_vcol;\n\tif (bdp->end_vcol > oap->end_vcol)\t// it's all in one character\n\t{\n\t    bdp->is_oneChar = TRUE;\n\t    if (oap->op_type == OP_INSERT)\n\t\tbdp->endspaces = bdp->start_char_vcols - bdp->startspaces;\n\t    else if (oap->op_type == OP_APPEND)\n\t    {\n\t\tbdp->startspaces += oap->end_vcol - oap->start_vcol + 1;\n\t\tbdp->endspaces = bdp->start_char_vcols - bdp->startspaces;\n\t    }\n\t    else\n\t    {\n\t\tbdp->startspaces = oap->end_vcol - oap->start_vcol + 1;\n\t\tif (is_del && oap->op_type != OP_LSHIFT)\n\t\t{\n\t\t    // just putting the sum of those two into\n\t\t    // bdp->startspaces doesn't work for Visual replace,\n\t\t    // so we have to split the tab in two\n\t\t    bdp->startspaces = bdp->start_char_vcols\n\t\t\t\t\t- (bdp->start_vcol - oap->start_vcol);\n\t\t    bdp->endspaces = bdp->end_vcol - oap->end_vcol - 1;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    init_chartabsize_arg(&cts, curwin, lnum, bdp->end_vcol,\n\t\t\t\t\t\t\t\t  line, pend);\n\t    prev_pend = pend;\n\t    while (cts.cts_vcol <= oap->end_vcol && *cts.cts_ptr != NUL)\n\t    {\n\t\t// count a tab for what it's worth (if list mode not on)\n\t\tprev_pend = cts.cts_ptr;\n\t\tincr = lbr_chartabsize_adv(&cts);\n\t\tcts.cts_vcol += incr;\n\t    }\n\t    bdp->end_vcol = cts.cts_vcol;\n\t    pend = cts.cts_ptr;\n\t    clear_chartabsize_arg(&cts);\n\n\t    if (bdp->end_vcol <= oap->end_vcol\n\t\t    && (!is_del\n\t\t\t|| oap->op_type == OP_APPEND\n\t\t\t|| oap->op_type == OP_REPLACE)) // line too short\n\t    {\n\t\tbdp->is_short = TRUE;\n\t\t// Alternative: include spaces to fill up the block.\n\t\t// Disadvantage: can lead to trailing spaces when the line is\n\t\t// short where the text is put\n\t\t// if (!is_del || oap->op_type == OP_APPEND)\n\t\tif (oap->op_type == OP_APPEND || virtual_op)\n\t\t    bdp->endspaces = oap->end_vcol - bdp->end_vcol\n\t\t\t\t\t\t\t     + oap->inclusive;\n\t\telse\n\t\t    bdp->endspaces = 0; // replace doesn't add characters\n\t    }\n\t    else if (bdp->end_vcol > oap->end_vcol)\n\t    {\n\t\tbdp->endspaces = bdp->end_vcol - oap->end_vcol - 1;\n\t\tif (!is_del && bdp->endspaces)\n\t\t{\n\t\t    bdp->endspaces = incr - bdp->endspaces;\n\t\t    if (pend != pstart)\n\t\t\tpend = prev_pend;\n\t\t}\n\t    }\n\t}\n\tbdp->end_char_vcols = incr;\n\tif (is_del && bdp->startspaces)\n\t    pstart = prev_pstart;\n\tbdp->textlen = (int)(pend - pstart);\n    }\n    bdp->textcol = (colnr_T) (pstart - line);\n    bdp->textstart = pstart;\n#ifdef FEAT_LINEBREAK\n    curwin->w_p_lbr = lbr_saved;\n#endif\n}\n\n/*\n * Handle the add/subtract operator.\n */\n    void\nop_addsub(\n    oparg_T\t*oap,\n    linenr_T\tPrenum1,\t    // Amount of add/subtract\n    int\t\tg_cmd)\t\t    // was g<c-a>/g<c-x>\n{\n    pos_T\t\tpos;\n    struct block_def\tbd;\n    int\t\t\tchange_cnt = 0;\n    linenr_T\t\tamount = Prenum1;\n\n   // do_addsub() might trigger re-evaluation of 'foldexpr' halfway, when the\n   // buffer is not completely updated yet. Postpone updating folds until before\n   // the call to changed_lines().\n#ifdef FEAT_FOLDING\n   disable_fold_update++;\n#endif\n\n    if (!VIsual_active)\n    {\n\tpos = curwin->w_cursor;\n\tif (u_save_cursor() == FAIL)\n\t{\n#ifdef FEAT_FOLDING\n\t    disable_fold_update--;\n#endif\n\t    return;\n\t}\n\tchange_cnt = do_addsub(oap->op_type, &pos, 0, amount);\n#ifdef FEAT_FOLDING\n\tdisable_fold_update--;\n#endif\n\tif (change_cnt)\n\t    changed_lines(pos.lnum, 0, pos.lnum + 1, 0L);\n    }\n    else\n    {\n\tint\tone_change;\n\tint\tlength;\n\tpos_T\tstartpos;\n\n\tif (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t\t(linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t{\n#ifdef FEAT_FOLDING\n\t    disable_fold_update--;\n#endif\n\t    return;\n\t}\n\n\tpos = oap->start;\n\tfor (; pos.lnum <= oap->end.lnum; ++pos.lnum)\n\t{\n\t    if (oap->block_mode)\t\t    // Visual block mode\n\t    {\n\t\tblock_prep(oap, &bd, pos.lnum, FALSE);\n\t\tpos.col = bd.textcol;\n\t\tlength = bd.textlen;\n\t    }\n\t    else if (oap->motion_type == MLINE)\n\t    {\n\t\tcurwin->w_cursor.col = 0;\n\t\tpos.col = 0;\n\t\tlength = (colnr_T)STRLEN(ml_get(pos.lnum));\n\t    }\n\t    else // oap->motion_type == MCHAR\n\t    {\n\t\tif (pos.lnum == oap->start.lnum && !oap->inclusive)\n\t\t    dec(&(oap->end));\n\t\tlength = (colnr_T)STRLEN(ml_get(pos.lnum));\n\t\tpos.col = 0;\n\t\tif (pos.lnum == oap->start.lnum)\n\t\t{\n\t\t    pos.col += oap->start.col;\n\t\t    length -= oap->start.col;\n\t\t}\n\t\tif (pos.lnum == oap->end.lnum)\n\t\t{\n\t\t    length = (int)STRLEN(ml_get(oap->end.lnum));\n\t\t    if (oap->end.col >= length)\n\t\t\toap->end.col = length - 1;\n\t\t    length = oap->end.col - pos.col + 1;\n\t\t}\n\t    }\n\t    one_change = do_addsub(oap->op_type, &pos, length, amount);\n\t    if (one_change)\n\t    {\n\t\t// Remember the start position of the first change.\n\t\tif (change_cnt == 0)\n\t\t    startpos = curbuf->b_op_start;\n\t\t++change_cnt;\n\t    }\n\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active() && one_change)\n\t    {\n\t\tchar_u *ptr;\n\n\t\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)length);\n\t\tptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t&ptr[pos.col], length);\n\t    }\n#endif\n\t    if (g_cmd && one_change)\n\t\tamount += Prenum1;\n\t}\n\n#ifdef FEAT_FOLDING\n\tdisable_fold_update--;\n#endif\n\tif (change_cnt)\n\t    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);\n\n\tif (!change_cnt && oap->is_VIsual)\n\t    // No change: need to remove the Visual selection\n\t    redraw_curbuf_later(UPD_INVERTED);\n\n\t// Set '[ mark if something changed. Keep the last end\n\t// position from do_addsub().\n\tif (change_cnt > 0 && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t    curbuf->b_op_start = startpos;\n\n\tif (change_cnt > p_report)\n\t    smsg(NGETTEXT(\"%d line changed\", \"%d lines changed\",\n\t\t\t\t\t\t      change_cnt), change_cnt);\n    }\n}\n\n/*\n * Add or subtract 'Prenum1' from a number in a line\n * op_type is OP_NR_ADD or OP_NR_SUB\n *\n * Returns TRUE if some character was changed.\n */\n    static int\ndo_addsub(\n    int\t\top_type,\n    pos_T\t*pos,\n    int\t\tlength,\n    linenr_T\tPrenum1)\n{\n    int\t\tcol;\n    char_u\t*buf1;\n    char_u\tbuf2[NUMBUFLEN];\n    int\t\tpre;\t\t// 'X'/'x': hex; '0': octal; 'B'/'b': bin\n    static int\thexupper = FALSE;\t// 0xABC\n    uvarnumber_T\tn;\n    uvarnumber_T\toldn;\n    char_u\t*ptr;\n    int\t\tc;\n    int\t\ttodel;\n    int\t\tdo_hex;\n    int\t\tdo_oct;\n    int\t\tdo_bin;\n    int\t\tdo_alpha;\n    int\t\tdo_unsigned;\n    int\t\tfirstdigit;\n    int\t\tsubtract;\n    int\t\tnegative = FALSE;\n    int\t\twas_positive = TRUE;\n    int\t\tvisual = VIsual_active;\n    int\t\tdid_change = FALSE;\n    pos_T\tsave_cursor = curwin->w_cursor;\n    int\t\tmaxlen = 0;\n    pos_T\tstartpos;\n    pos_T\tendpos;\n    colnr_T\tsave_coladd = 0;\n\n    do_hex = (vim_strchr(curbuf->b_p_nf, 'x') != NULL);\t// \"heX\"\n    do_oct = (vim_strchr(curbuf->b_p_nf, 'o') != NULL);\t// \"Octal\"\n    do_bin = (vim_strchr(curbuf->b_p_nf, 'b') != NULL);\t// \"Bin\"\n    do_alpha = (vim_strchr(curbuf->b_p_nf, 'p') != NULL);\t// \"alPha\"\n    do_unsigned = (vim_strchr(curbuf->b_p_nf, 'u') != NULL);\t// \"Unsigned\"\n\n    if (virtual_active())\n    {\n\tsave_coladd = pos->coladd;\n\tpos->coladd = 0;\n    }\n\n    curwin->w_cursor = *pos;\n    ptr = ml_get(pos->lnum);\n    col = pos->col;\n\n    if (*ptr == NUL || col + !!save_coladd >= (int)STRLEN(ptr))\n\tgoto theend;\n\n    /*\n     * First check if we are on a hexadecimal number, after the \"0x\".\n     */\n    if (!VIsual_active)\n    {\n\tif (do_bin)\n\t    while (col > 0 && vim_isbdigit(ptr[col]))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\n\tif (do_hex)\n\t    while (col > 0 && vim_isxdigit(ptr[col]))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\n\tif (       do_bin\n\t\t&& do_hex\n\t\t&& ! ((col > 0\n\t\t    && (ptr[col] == 'X'\n\t\t\t|| ptr[col] == 'x')\n\t\t    && ptr[col - 1] == '0'\n\t\t    && (!has_mbyte ||\n\t\t\t!(*mb_head_off)(ptr, ptr + col - 1))\n\t\t    && vim_isxdigit(ptr[col + 1]))))\n\t{\n\n\t    // In case of binary/hexadecimal pattern overlap match, rescan\n\n\t    col = pos->col;\n\n\t    while (col > 0 && vim_isdigit(ptr[col]))\n\t    {\n\t\tcol--;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\t}\n\n\tif ((       do_hex\n\t\t&& col > 0\n\t\t&& (ptr[col] == 'X'\n\t\t    || ptr[col] == 'x')\n\t\t&& ptr[col - 1] == '0'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& vim_isxdigit(ptr[col + 1])) ||\n\t    (       do_bin\n\t\t&& col > 0\n\t\t&& (ptr[col] == 'B'\n\t\t    || ptr[col] == 'b')\n\t\t&& ptr[col - 1] == '0'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& vim_isbdigit(ptr[col + 1])))\n\t{\n\t    // Found hexadecimal or binary number, move to its start.\n\t    --col;\n\t    if (has_mbyte)\n\t\tcol -= (*mb_head_off)(ptr, ptr + col);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Search forward and then backward to find the start of number.\n\t     */\n\t    col = pos->col;\n\n\t    while (ptr[col] != NUL\n\t\t    && !vim_isdigit(ptr[col])\n\t\t    && !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t\tcol += mb_ptr2len(ptr + col);\n\n\t    while (col > 0\n\t\t    && vim_isdigit(ptr[col - 1])\n\t\t    && !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\t}\n    }\n\n    if (visual)\n    {\n\twhile (ptr[col] != NUL && length > 0\n\t\t&& !vim_isdigit(ptr[col])\n\t\t&& !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t{\n\t    int mb_len = mb_ptr2len(ptr + col);\n\n\t    col += mb_len;\n\t    length -= mb_len;\n\t}\n\n\tif (length == 0)\n\t    goto theend;\n\n\tif (col > pos->col && ptr[col - 1] == '-'\n\t\t&& (!has_mbyte || !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& !do_unsigned)\n\t{\n\t    negative = TRUE;\n\t    was_positive = FALSE;\n\t}\n    }\n\n    /*\n     * If a number was found, and saving for undo works, replace the number.\n     */\n    firstdigit = ptr[col];\n    if (!VIM_ISDIGIT(firstdigit) && !(do_alpha && ASCII_ISALPHA(firstdigit)))\n    {\n\tbeep_flush();\n\tgoto theend;\n    }\n\n    if (do_alpha && ASCII_ISALPHA(firstdigit))\n    {\n\t// decrement or increment alphabetic character\n\tif (op_type == OP_NR_SUB)\n\t{\n\t    if (CharOrd(firstdigit) < Prenum1)\n\t    {\n\t\tif (isupper(firstdigit))\n\t\t    firstdigit = 'A';\n\t\telse\n\t\t    firstdigit = 'a';\n\t    }\n\t    else\n\t\tfirstdigit -= Prenum1;\n\t}\n\telse\n\t{\n\t    if (26 - CharOrd(firstdigit) - 1 < Prenum1)\n\t    {\n\t\tif (isupper(firstdigit))\n\t\t    firstdigit = 'Z';\n\t\telse\n\t\t    firstdigit = 'z';\n\t    }\n\t    else\n\t\tfirstdigit += Prenum1;\n\t}\n\tcurwin->w_cursor.col = col;\n\tif (!did_change)\n\t    startpos = curwin->w_cursor;\n\tdid_change = TRUE;\n\t(void)del_char(FALSE);\n\tins_char(firstdigit);\n\tendpos = curwin->w_cursor;\n\tcurwin->w_cursor.col = col;\n    }\n    else\n    {\n\tpos_T\tsave_pos;\n\tint\ti;\n\n\tif (col > 0 && ptr[col - 1] == '-'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& !visual\n\t\t&& !do_unsigned)\n\t{\n\t    // negative number\n\t    --col;\n\t    negative = TRUE;\n\t}\n\t// get the number value (unsigned)\n\tif (visual && VIsual_mode != 'V')\n\t    maxlen = (curbuf->b_visual.vi_curswant == MAXCOL\n\t\t    ? (int)STRLEN(ptr) - col\n\t\t    : length);\n\n\tvim_str2nr(ptr + col, &pre, &length,\n\t\t0 + (do_bin ? STR2NR_BIN : 0)\n\t\t    + (do_oct ? STR2NR_OCT : 0)\n\t\t    + (do_hex ? STR2NR_HEX : 0),\n\t\tNULL, &n, maxlen, FALSE);\n\n\t// ignore leading '-' for hex and octal and bin numbers\n\tif (pre && negative)\n\t{\n\t    ++col;\n\t    --length;\n\t    negative = FALSE;\n\t}\n\t// add or subtract\n\tsubtract = FALSE;\n\tif (op_type == OP_NR_SUB)\n\t    subtract ^= TRUE;\n\tif (negative)\n\t    subtract ^= TRUE;\n\n\toldn = n;\n\tif (subtract)\n\t    n -= (uvarnumber_T)Prenum1;\n\telse\n\t    n += (uvarnumber_T)Prenum1;\n\t// handle wraparound for decimal numbers\n\tif (!pre)\n\t{\n\t    if (subtract)\n\t    {\n\t\tif (n > oldn)\n\t\t{\n\t\t    n = 1 + (n ^ (uvarnumber_T)-1);\n\t\t    negative ^= TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// add\n\t\tif (n < oldn)\n\t\t{\n\t\t    n = (n ^ (uvarnumber_T)-1);\n\t\t    negative ^= TRUE;\n\t\t}\n\t    }\n\t    if (n == 0)\n\t\tnegative = FALSE;\n\t}\n\n\tif (do_unsigned && negative)\n\t{\n\t    if (subtract)\n\t\t// sticking at zero.\n\t\tn = (uvarnumber_T)0;\n\t    else\n\t\t// sticking at 2^64 - 1.\n\t\tn = (uvarnumber_T)(-1);\n\t    negative = FALSE;\n\t}\n\n\tif (visual && !was_positive && !negative && col > 0)\n\t{\n\t    // need to remove the '-'\n\t    col--;\n\t    length++;\n\t}\n\n\t/*\n\t * Delete the old number.\n\t */\n\tcurwin->w_cursor.col = col;\n\tif (!did_change)\n\t    startpos = curwin->w_cursor;\n\tdid_change = TRUE;\n\ttodel = length;\n\tc = gchar_cursor();\n\t/*\n\t * Don't include the '-' in the length, only the length of the\n\t * part after it is kept the same.\n\t */\n\tif (c == '-')\n\t    --length;\n\n\tsave_pos = curwin->w_cursor;\n\tfor (i = 0; i < todel; ++i)\n\t{\n\t    if (c < 0x100 && isalpha(c))\n\t    {\n\t\tif (isupper(c))\n\t\t    hexupper = TRUE;\n\t\telse\n\t\t    hexupper = FALSE;\n\t    }\n\t    inc_cursor();\n\t    c = gchar_cursor();\n\t}\n\tcurwin->w_cursor = save_pos;\n\n\t/*\n\t * Prepare the leading characters in buf1[].\n\t * When there are many leading zeros it could be very long.\n\t * Allocate a bit too much.\n\t */\n\tbuf1 = alloc(length + NUMBUFLEN);\n\tif (buf1 == NULL)\n\t    goto theend;\n\tptr = buf1;\n\tif (negative && (!visual || was_positive))\n\t    *ptr++ = '-';\n\tif (pre)\n\t{\n\t    *ptr++ = '0';\n\t    --length;\n\t}\n\tif (pre == 'b' || pre == 'B' ||\n\t    pre == 'x' || pre == 'X')\n\t{\n\t    *ptr++ = pre;\n\t    --length;\n\t}\n\n\t/*\n\t * Put the number characters in buf2[].\n\t */\n\tif (pre == 'b' || pre == 'B')\n\t{\n\t    int bit = 0;\n\t    int bits = sizeof(uvarnumber_T) * 8;\n\n\t    // leading zeros\n\t    for (bit = bits; bit > 0; bit--)\n\t\tif ((n >> (bit - 1)) & 0x1) break;\n\n\t    for (i = 0; bit > 0; bit--)\n\t\tbuf2[i++] = ((n >> (bit - 1)) & 0x1) ? '1' : '0';\n\n\t    buf2[i] = '\\0';\n\t}\n\telse if (pre == 0)\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llu\", n);\n\telse if (pre == '0')\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llo\", n);\n\telse if (pre && hexupper)\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llX\", n);\n\telse\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llx\", n);\n\tlength -= (int)STRLEN(buf2);\n\n\t/*\n\t * Adjust number of zeros to the new number of digits, so the\n\t * total length of the number remains the same.\n\t * Don't do this when\n\t * the result may look like an octal number.\n\t */\n\tif (firstdigit == '0' && !(do_oct && pre == 0))\n\t    while (length-- > 0)\n\t\t*ptr++ = '0';\n\t*ptr = NUL;\n\n\tSTRCAT(buf1, buf2);\n\n\t// Insert just after the first character to be removed, so that any\n\t// text properties will be adjusted.  Then delete the old number\n\t// afterwards.\n\tsave_pos = curwin->w_cursor;\n\tif (todel > 0)\n\t    inc_cursor();\n\tins_str(buf1);\t\t// insert the new number\n\tvim_free(buf1);\n\n\t// del_char() will also mark line needing displaying\n\tif (todel > 0)\n\t{\n\t    int bytes_after = (int)STRLEN(ml_get_curline())\n\t\t\t\t\t\t\t- curwin->w_cursor.col;\n\n\t    // Delete the one character before the insert.\n\t    curwin->w_cursor = save_pos;\n\t    (void)del_char(FALSE);\n\t    curwin->w_cursor.col = (colnr_T)(STRLEN(ml_get_curline())\n\t\t\t\t\t\t\t\t- bytes_after);\n\t    --todel;\n\t}\n\twhile (todel-- > 0)\n\t    (void)del_char(FALSE);\n\n\tendpos = curwin->w_cursor;\n\tif (did_change && curwin->w_cursor.col)\n\t    --curwin->w_cursor.col;\n    }\n\n    if (did_change && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// set the '[ and '] marks\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = endpos;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n\ntheend:\n    if (visual)\n\tcurwin->w_cursor = save_cursor;\n    else if (did_change)\n\tcurwin->w_set_curswant = TRUE;\n    else if (virtual_active())\n\tcurwin->w_cursor.coladd = save_coladd;\n\n    return did_change;\n}\n\n    void\nclear_oparg(oparg_T *oap)\n{\n    CLEAR_POINTER(oap);\n}\n\n/*\n *  Count the number of bytes, characters and \"words\" in a line.\n *\n *  \"Words\" are counted by looking for boundaries between non-space and\n *  space characters.  (it seems to produce results that match 'wc'.)\n *\n *  Return value is byte count; word count for the line is added to \"*wc\".\n *  Char count is added to \"*cc\".\n *\n *  The function will only examine the first \"limit\" characters in the\n *  line, stopping if it encounters an end-of-line (NUL byte).  In that\n *  case, eol_size will be added to the character count to account for\n *  the size of the EOL character.\n */\n    static varnumber_T\nline_count_info(\n    char_u\t*line,\n    varnumber_T\t*wc,\n    varnumber_T\t*cc,\n    varnumber_T\tlimit,\n    int\t\teol_size)\n{\n    varnumber_T\ti;\n    varnumber_T\twords = 0;\n    varnumber_T\tchars = 0;\n    int\t\tis_word = 0;\n\n    for (i = 0; i < limit && line[i] != NUL; )\n    {\n\tif (is_word)\n\t{\n\t    if (vim_isspace(line[i]))\n\t    {\n\t\twords++;\n\t\tis_word = 0;\n\t    }\n\t}\n\telse if (!vim_isspace(line[i]))\n\t    is_word = 1;\n\t++chars;\n\ti += (*mb_ptr2len)(line + i);\n    }\n\n    if (is_word)\n\twords++;\n    *wc += words;\n\n    // Add eol_size if the end of line was reached before hitting limit.\n    if (i < limit && line[i] == NUL)\n    {\n\ti += eol_size;\n\tchars += eol_size;\n    }\n    *cc += chars;\n    return i;\n}\n\n/*\n * Give some info about the position of the cursor (for \"g CTRL-G\").\n * In Visual mode, give some info about the selected region.  (In this case,\n * the *_count_cursor variables store running totals for the selection.)\n * When \"dict\" is not NULL store the info there instead of showing it.\n */\n    void\ncursor_pos_info(dict_T *dict)\n{\n    char_u\t*p;\n    char_u\tbuf1[50];\n    char_u\tbuf2[40];\n    linenr_T\tlnum;\n    varnumber_T\tbyte_count = 0;\n    varnumber_T\tbom_count  = 0;\n    varnumber_T\tbyte_count_cursor = 0;\n    varnumber_T\tchar_count = 0;\n    varnumber_T\tchar_count_cursor = 0;\n    varnumber_T\tword_count = 0;\n    varnumber_T\tword_count_cursor = 0;\n    int\t\teol_size;\n    varnumber_T\tlast_check = 100000L;\n    long\tline_count_selected = 0;\n    pos_T\tmin_pos, max_pos;\n    oparg_T\toparg;\n    struct block_def\tbd;\n\n    /*\n     * Compute the length of the file in characters.\n     */\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n    {\n\tif (dict == NULL)\n\t{\n\t    msg(_(no_lines_msg));\n\t    return;\n\t}\n    }\n    else\n    {\n\tif (get_fileformat(curbuf) == EOL_DOS)\n\t    eol_size = 2;\n\telse\n\t    eol_size = 1;\n\n\tif (VIsual_active)\n\t{\n\t    if (LT_POS(VIsual, curwin->w_cursor))\n\t    {\n\t\tmin_pos = VIsual;\n\t\tmax_pos = curwin->w_cursor;\n\t    }\n\t    else\n\t    {\n\t\tmin_pos = curwin->w_cursor;\n\t\tmax_pos = VIsual;\n\t    }\n\t    if (*p_sel == 'e' && max_pos.col > 0)\n\t\t--max_pos.col;\n\n\t    if (VIsual_mode == Ctrl_V)\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tchar_u * saved_sbr = p_sbr;\n\t\tchar_u * saved_w_sbr = curwin->w_p_sbr;\n\n\t\t// Make 'sbr' empty for a moment to get the correct size.\n\t\tp_sbr = empty_option;\n\t\tcurwin->w_p_sbr = empty_option;\n#endif\n\t\toparg.is_VIsual = 1;\n\t\toparg.block_mode = TRUE;\n\t\toparg.op_type = OP_NOP;\n\t\tgetvcols(curwin, &min_pos, &max_pos,\n\t\t\t\t\t  &oparg.start_vcol, &oparg.end_vcol);\n#ifdef FEAT_LINEBREAK\n\t\tp_sbr = saved_sbr;\n\t\tcurwin->w_p_sbr = saved_w_sbr;\n#endif\n\t\tif (curwin->w_curswant == MAXCOL)\n\t\t    oparg.end_vcol = MAXCOL;\n\t\t// Swap the start, end vcol if needed\n\t\tif (oparg.end_vcol < oparg.start_vcol)\n\t\t{\n\t\t    oparg.end_vcol += oparg.start_vcol;\n\t\t    oparg.start_vcol = oparg.end_vcol - oparg.start_vcol;\n\t\t    oparg.end_vcol -= oparg.start_vcol;\n\t\t}\n\t    }\n\t    line_count_selected = max_pos.lnum - min_pos.lnum + 1;\n\t}\n\n\tfor (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t{\n\t    // Check for a CTRL-C every 100000 characters.\n\t    if (byte_count > last_check)\n\t    {\n\t\tui_breakcheck();\n\t\tif (got_int)\n\t\t    return;\n\t\tlast_check = byte_count + 100000L;\n\t    }\n\n\t    // Do extra processing for VIsual mode.\n\t    if (VIsual_active\n\t\t    && lnum >= min_pos.lnum && lnum <= max_pos.lnum)\n\t    {\n\t\tchar_u\t    *s = NULL;\n\t\tlong\t    len = 0L;\n\n\t\tswitch (VIsual_mode)\n\t\t{\n\t\t    case Ctrl_V:\n\t\t\tvirtual_op = virtual_active();\n\t\t\tblock_prep(&oparg, &bd, lnum, 0);\n\t\t\tvirtual_op = MAYBE;\n\t\t\ts = bd.textstart;\n\t\t\tlen = (long)bd.textlen;\n\t\t\tbreak;\n\t\t    case 'V':\n\t\t\ts = ml_get(lnum);\n\t\t\tlen = MAXCOL;\n\t\t\tbreak;\n\t\t    case 'v':\n\t\t\t{\n\t\t\t    colnr_T start_col = (lnum == min_pos.lnum)\n\t\t\t\t\t\t\t   ? min_pos.col : 0;\n\t\t\t    colnr_T end_col = (lnum == max_pos.lnum)\n\t\t\t\t      ? max_pos.col - start_col + 1 : MAXCOL;\n\n\t\t\t    s = ml_get(lnum) + start_col;\n\t\t\t    len = end_col;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (s != NULL)\n\t\t{\n\t\t    byte_count_cursor += line_count_info(s, &word_count_cursor,\n\t\t\t\t\t   &char_count_cursor, len, eol_size);\n\t\t    if (lnum == curbuf->b_ml.ml_line_count\n\t\t\t    && !curbuf->b_p_eol\n\t\t\t    && (curbuf->b_p_bin || !curbuf->b_p_fixeol)\n\t\t\t    && (long)STRLEN(s) < len)\n\t\t\tbyte_count_cursor -= eol_size;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// In non-visual mode, check for the line the cursor is on\n\t\tif (lnum == curwin->w_cursor.lnum)\n\t\t{\n\t\t    word_count_cursor += word_count;\n\t\t    char_count_cursor += char_count;\n\t\t    byte_count_cursor = byte_count +\n\t\t\tline_count_info(ml_get(lnum),\n\t\t\t\t&word_count_cursor, &char_count_cursor,\n\t\t\t\t(varnumber_T)(curwin->w_cursor.col + 1),\n\t\t\t\teol_size);\n\t\t}\n\t    }\n\t    // Add to the running totals\n\t    byte_count += line_count_info(ml_get(lnum), &word_count,\n\t\t\t\t\t &char_count, (varnumber_T)MAXCOL,\n\t\t\t\t\t eol_size);\n\t}\n\n\t// Correction for when last line doesn't have an EOL.\n\tif (!curbuf->b_p_eol && (curbuf->b_p_bin || !curbuf->b_p_fixeol))\n\t    byte_count -= eol_size;\n\n\tif (dict == NULL)\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_mode == Ctrl_V && curwin->w_curswant < MAXCOL)\n\t\t{\n\t\t    getvcols(curwin, &min_pos, &max_pos, &min_pos.col,\n\t\t\t\t\t\t\t\t    &max_pos.col);\n\t\t    vim_snprintf((char *)buf1, sizeof(buf1), _(\"%ld Cols; \"),\n\t\t\t    (long)(oparg.end_vcol - oparg.start_vcol + 1));\n\t\t}\n\t\telse\n\t\t    buf1[0] = NUL;\n\n\t\tif (char_count_cursor == byte_count_cursor\n\t\t\t\t\t\t    && char_count == byte_count)\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t    _(\"Selected %s%ld of %ld Lines; %lld of %lld Words; %lld of %lld Bytes\"),\n\t\t\t    buf1, line_count_selected,\n\t\t\t    (long)curbuf->b_ml.ml_line_count,\n\t\t\t    word_count_cursor,\n\t\t\t    word_count,\n\t\t\t    byte_count_cursor,\n\t\t\t    byte_count);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t    _(\"Selected %s%ld of %ld Lines; %lld of %lld Words; %lld of %lld Chars; %lld of %lld Bytes\"),\n\t\t\t    buf1, line_count_selected,\n\t\t\t    (long)curbuf->b_ml.ml_line_count,\n\t\t\t    word_count_cursor,\n\t\t\t    word_count,\n\t\t\t    char_count_cursor,\n\t\t\t    char_count,\n\t\t\t    byte_count_cursor,\n\t\t\t    byte_count);\n\t    }\n\t    else\n\t    {\n\t\tp = ml_get_curline();\n\t\tvalidate_virtcol();\n\t\tcol_print(buf1, sizeof(buf1), (int)curwin->w_cursor.col + 1,\n\t\t\t(int)curwin->w_virtcol + 1);\n\t\tcol_print(buf2, sizeof(buf2), (int)STRLEN(p),\n\t\t\t\t    linetabsize(p));\n\n\t\tif (char_count_cursor == byte_count_cursor\n\t\t\t&& char_count == byte_count)\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"Col %s of %s; Line %ld of %ld; Word %lld of %lld; Byte %lld of %lld\"),\n\t\t\t(char *)buf1, (char *)buf2,\n\t\t\t(long)curwin->w_cursor.lnum,\n\t\t\t(long)curbuf->b_ml.ml_line_count,\n\t\t\tword_count_cursor, word_count,\n\t\t\tbyte_count_cursor, byte_count);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"Col %s of %s; Line %ld of %ld; Word %lld of %lld; Char %lld of %lld; Byte %lld of %lld\"),\n\t\t\t(char *)buf1, (char *)buf2,\n\t\t\t(long)curwin->w_cursor.lnum,\n\t\t\t(long)curbuf->b_ml.ml_line_count,\n\t\t\tword_count_cursor, word_count,\n\t\t\tchar_count_cursor, char_count,\n\t\t\tbyte_count_cursor, byte_count);\n\t    }\n\t}\n\n\tbom_count = bomb_size();\n\tif (dict == NULL && bom_count > 0)\n\t{\n\t    size_t len = STRLEN(IObuff);\n\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\t\t _(\"(+%lld for BOM)\"), bom_count);\n\t}\n\tif (dict == NULL)\n\t{\n\t    // Don't shorten this message, the user asked for it.\n\t    p = p_shm;\n\t    p_shm = (char_u *)\"\";\n\t    msg((char *)IObuff);\n\t    p_shm = p;\n\t}\n    }\n#if defined(FEAT_EVAL)\n    if (dict != NULL)\n    {\n\tdict_add_number(dict, \"words\", word_count);\n\tdict_add_number(dict, \"chars\", char_count);\n\tdict_add_number(dict, \"bytes\", byte_count + bom_count);\n\tdict_add_number(dict, VIsual_active ? \"visual_bytes\" : \"cursor_bytes\",\n\t\tbyte_count_cursor);\n\tdict_add_number(dict, VIsual_active ? \"visual_chars\" : \"cursor_chars\",\n\t\tchar_count_cursor);\n\tdict_add_number(dict, VIsual_active ? \"visual_words\" : \"cursor_words\",\n\t\tword_count_cursor);\n    }\n#endif\n}\n\n/*\n * Handle indent and format operators and visual mode \":\".\n */\n    static void\nop_colon(oparg_T *oap)\n{\n    stuffcharReadbuff(':');\n    if (oap->is_VIsual)\n\tstuffReadbuff((char_u *)\"'<,'>\");\n    else\n    {\n\t// Make the range look nice, so it can be repeated.\n\tif (oap->start.lnum == curwin->w_cursor.lnum)\n\t    stuffcharReadbuff('.');\n\telse\n\t    stuffnumReadbuff((long)oap->start.lnum);\n\tif (oap->end.lnum != oap->start.lnum)\n\t{\n\t    stuffcharReadbuff(',');\n\t    if (oap->end.lnum == curwin->w_cursor.lnum)\n\t\tstuffcharReadbuff('.');\n\t    else if (oap->end.lnum == curbuf->b_ml.ml_line_count)\n\t\tstuffcharReadbuff('$');\n\t    else if (oap->start.lnum == curwin->w_cursor.lnum)\n\t    {\n\t\tstuffReadbuff((char_u *)\".+\");\n\t\tstuffnumReadbuff((long)oap->line_count - 1);\n\t    }\n\t    else\n\t\tstuffnumReadbuff((long)oap->end.lnum);\n\t}\n    }\n    if (oap->op_type != OP_COLON)\n\tstuffReadbuff((char_u *)\"!\");\n    if (oap->op_type == OP_INDENT)\n    {\n\tif (*get_equalprg() == NUL)\n\t    stuffReadbuff((char_u *)\"indent\");\n\telse\n\t    stuffReadbuff(get_equalprg());\n\tstuffReadbuff((char_u *)\"\\n\");\n    }\n    else if (oap->op_type == OP_FORMAT)\n    {\n\tif (*curbuf->b_p_fp != NUL)\n\t    stuffReadbuff(curbuf->b_p_fp);\n\telse if (*p_fp != NUL)\n\t    stuffReadbuff(p_fp);\n\telse\n\t    stuffReadbuff((char_u *)\"fmt\");\n\tstuffReadbuff((char_u *)\"\\n']\");\n    }\n\n    // do_cmdline() does the rest\n}\n\n// callback function for 'operatorfunc'\nstatic callback_T opfunc_cb;\n\n/*\n * Process the 'operatorfunc' option value.\n * Returns OK or FAIL.\n */\n    int\nset_operatorfunc_option(void)\n{\n    return option_set_callback_func(p_opfunc, &opfunc_cb);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_operatorfunc_option(void)\n{\n# ifdef FEAT_EVAL\n    free_callback(&opfunc_cb);\n# endif\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Mark the global 'operatorfunc' callback with 'copyID' so that it is not\n * garbage collected.\n */\n    int\nset_ref_in_opfunc(int copyID UNUSED)\n{\n    int abort = FALSE;\n\n    abort = set_ref_in_callback(&opfunc_cb, copyID);\n\n    return abort;\n}\n#endif\n\n/*\n * Handle the \"g@\" operator: call 'operatorfunc'.\n */\n    static void\nop_function(oparg_T *oap UNUSED)\n{\n#ifdef FEAT_EVAL\n    typval_T\targv[2];\n    int\t\tsave_virtual_op = virtual_op;\n    int\t\tsave_finish_op = finish_op;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    typval_T\trettv;\n\n    if (*p_opfunc == NUL)\n\temsg(_(e_operatorfunc_is_empty));\n    else\n    {\n\t// Set '[ and '] marks to text to be operated on.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n\tif (oap->motion_type != MLINE && !oap->inclusive)\n\t    // Exclude the end position.\n\t    decl(&curbuf->b_op_end);\n\n\targv[0].v_type = VAR_STRING;\n\tif (oap->block_mode)\n\t    argv[0].vval.v_string = (char_u *)\"block\";\n\telse if (oap->motion_type == MLINE)\n\t    argv[0].vval.v_string = (char_u *)\"line\";\n\telse\n\t    argv[0].vval.v_string = (char_u *)\"char\";\n\targv[1].v_type = VAR_UNKNOWN;\n\n\t// Reset virtual_op so that 'virtualedit' can be changed in the\n\t// function.\n\tvirtual_op = MAYBE;\n\n\t// Reset finish_op so that mode() returns the right value.\n\tfinish_op = FALSE;\n\n\tif (call_callback(&opfunc_cb, 0, &rettv, 1, argv) != FAIL)\n\t    clear_tv(&rettv);\n\n\tvirtual_op = save_virtual_op;\n\tfinish_op = save_finish_op;\n\tif (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n\t{\n\t    curbuf->b_op_start = orig_start;\n\t    curbuf->b_op_end = orig_end;\n\t}\n    }\n#else\n    emsg(_(e_eval_feature_not_available));\n#endif\n}\n\n/*\n * Calculate start/end virtual columns for operating in block mode.\n */\n    static void\nget_op_vcol(\n    oparg_T\t*oap,\n    colnr_T\tredo_VIsual_vcol,\n    int\t\tinitial)    // when TRUE adjust position for 'selectmode'\n{\n    colnr_T\t    start, end;\n\n    if (VIsual_mode != Ctrl_V\n\t    || (!initial && oap->end.col < curwin->w_width))\n\treturn;\n\n    oap->block_mode = TRUE;\n\n    // prevent from moving onto a trail byte\n    if (has_mbyte)\n\tmb_adjustpos(curwin->w_buffer, &oap->end);\n\n    getvvcol(curwin, &(oap->start), &oap->start_vcol, NULL, &oap->end_vcol);\n\n    if (!redo_VIsual_busy)\n    {\n\tgetvvcol(curwin, &(oap->end), &start, NULL, &end);\n\n\tif (start < oap->start_vcol)\n\t    oap->start_vcol = start;\n\tif (end > oap->end_vcol)\n\t{\n\t    if (initial && *p_sel == 'e' && start >= 1\n\t\t\t\t    && start - 1 >= oap->end_vcol)\n\t\toap->end_vcol = start - 1;\n\t    else\n\t\toap->end_vcol = end;\n\t}\n    }\n\n    // if '$' was used, get oap->end_vcol from longest line\n    if (curwin->w_curswant == MAXCOL)\n    {\n\tcurwin->w_cursor.col = MAXCOL;\n\toap->end_vcol = 0;\n\tfor (curwin->w_cursor.lnum = oap->start.lnum;\n\t\tcurwin->w_cursor.lnum <= oap->end.lnum;\n\t\t\t\t\t++curwin->w_cursor.lnum)\n\t{\n\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &end);\n\t    if (end > oap->end_vcol)\n\t\toap->end_vcol = end;\n\t}\n    }\n    else if (redo_VIsual_busy)\n\toap->end_vcol = oap->start_vcol + redo_VIsual_vcol - 1;\n    // Correct oap->end.col and oap->start.col to be the\n    // upper-left and lower-right corner of the block area.\n    //\n    // (Actually, this does convert column positions into character\n    // positions)\n    curwin->w_cursor.lnum = oap->end.lnum;\n    coladvance(oap->end_vcol);\n    oap->end = curwin->w_cursor;\n\n    curwin->w_cursor = oap->start;\n    coladvance(oap->start_vcol);\n    oap->start = curwin->w_cursor;\n}\n\n// Information for redoing the previous Visual selection.\ntypedef struct {\n    int\t\trv_mode;\t// 'v', 'V', or Ctrl-V\n    linenr_T\trv_line_count;\t// number of lines\n    colnr_T\trv_vcol;\t// number of cols or end column\n    long\trv_count;\t// count for Visual operator\n    int\t\trv_arg;\t\t// extra argument\n} redo_VIsual_T;\n\n    static int\nis_ex_cmdchar(cmdarg_T *cap)\n{\n    return cap->cmdchar == ':'\n\t|| cap->cmdchar == K_COMMAND\n\t|| cap->cmdchar == K_SCRIPT_COMMAND;\n}\n\n/*\n * Handle an operator after Visual mode or when the movement is finished.\n * \"gui_yank\" is true when yanking text for the clipboard.\n */\n    void\ndo_pending_operator(cmdarg_T *cap, int old_col, int gui_yank)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\told_cursor;\n    int\t\tempty_region_error;\n    int\t\trestart_edit_save;\n#ifdef FEAT_LINEBREAK\n    int\t\tlbr_saved = curwin->w_p_lbr;\n#endif\n\n    // The visual area is remembered for redo\n    static redo_VIsual_T   redo_VIsual = {NUL, 0, 0, 0,0};\n\n    int\t\t    include_line_break = FALSE;\n\n#if defined(FEAT_CLIPBOARD)\n    // Yank the visual area into the GUI selection register before we operate\n    // on it and lose it forever.\n    // Don't do it if a specific register was specified, so that \"\"x\"*P works.\n    // This could call do_pending_operator() recursively, but that's OK\n    // because gui_yank will be TRUE for the nested call.\n    if ((clip_star.available || clip_plus.available)\n\t    && oap->op_type != OP_NOP\n\t    && !gui_yank\n\t    && VIsual_active\n\t    && !redo_VIsual_busy\n\t    && oap->regname == 0)\n\tclip_auto_select();\n#endif\n    old_cursor = curwin->w_cursor;\n\n    // If an operation is pending, handle it...\n    if ((finish_op || VIsual_active) && oap->op_type != OP_NOP)\n    {\n\t// Yank can be redone when 'y' is in 'cpoptions', but not when yanking\n\t// for the clipboard.\n\tint\tredo_yank = vim_strchr(p_cpo, CPO_YANK) != NULL && !gui_yank;\n\n#ifdef FEAT_LINEBREAK\n\t// Avoid a problem with unwanted linebreaks in block mode.\n\tif (curwin->w_p_lbr)\n\t    curwin->w_valid &= ~VALID_VIRTCOL;\n\tcurwin->w_p_lbr = FALSE;\n#endif\n\toap->is_VIsual = VIsual_active;\n\tif (oap->motion_force == 'V')\n\t    oap->motion_type = MLINE;\n\telse if (oap->motion_force == 'v')\n\t{\n\t    // If the motion was linewise, \"inclusive\" will not have been set.\n\t    // Use \"exclusive\" to be consistent.  Makes \"dvj\" work nice.\n\t    if (oap->motion_type == MLINE)\n\t\toap->inclusive = FALSE;\n\t    // If the motion already was characterwise, toggle \"inclusive\"\n\t    else if (oap->motion_type == MCHAR)\n\t\toap->inclusive = !oap->inclusive;\n\t    oap->motion_type = MCHAR;\n\t}\n\telse if (oap->motion_force == Ctrl_V)\n\t{\n\t    // Change line- or characterwise motion into Visual block mode.\n\t    if (!VIsual_active)\n\t    {\n\t\tVIsual_active = TRUE;\n\t\tVIsual = oap->start;\n\t    }\n\t    VIsual_mode = Ctrl_V;\n\t    VIsual_select = FALSE;\n\t    VIsual_reselect = FALSE;\n\t}\n\n\t// Only redo yank when 'y' flag is in 'cpoptions'.\n\t// Never redo \"zf\" (define fold).\n\tif ((redo_yank || oap->op_type != OP_YANK)\n\t\t&& ((!VIsual_active || oap->motion_force)\n\t\t    // Also redo Operator-pending Visual mode mappings\n\t\t    || (VIsual_active\n\t\t\t    && is_ex_cmdchar(cap) && oap->op_type != OP_COLON))\n\t\t&& cap->cmdchar != 'D'\n#ifdef FEAT_FOLDING\n\t\t&& oap->op_type != OP_FOLD\n\t\t&& oap->op_type != OP_FOLDOPEN\n\t\t&& oap->op_type != OP_FOLDOPENREC\n\t\t&& oap->op_type != OP_FOLDCLOSE\n\t\t&& oap->op_type != OP_FOLDCLOSEREC\n\t\t&& oap->op_type != OP_FOLDDEL\n\t\t&& oap->op_type != OP_FOLDDELREC\n#endif\n\t\t)\n\t{\n\t    prep_redo(oap->regname, cap->count0,\n\t\t    get_op_char(oap->op_type), get_extra_op_char(oap->op_type),\n\t\t    oap->motion_force, cap->cmdchar, cap->nchar);\n\t    if (cap->cmdchar == '/' || cap->cmdchar == '?') // was a search\n\t    {\n\t\t// If 'cpoptions' does not contain 'r', insert the search\n\t\t// pattern to really repeat the same command.\n\t\tif (vim_strchr(p_cpo, CPO_REDO) == NULL)\n\t\t    AppendToRedobuffLit(cap->searchbuf, -1);\n\t\tAppendToRedobuff(NL_STR);\n\t    }\n\t    else if (is_ex_cmdchar(cap))\n\t    {\n\t\t// do_cmdline() has stored the first typed line in\n\t\t// \"repeat_cmdline\".  When several lines are typed repeating\n\t\t// won't be possible.\n\t\tif (repeat_cmdline == NULL)\n\t\t    ResetRedobuff();\n\t\telse\n\t\t{\n\t\t    AppendToRedobuffLit(repeat_cmdline, -1);\n\t\t    AppendToRedobuff(NL_STR);\n\t\t    VIM_CLEAR(repeat_cmdline);\n\t\t}\n\t    }\n\t}\n\n\tif (redo_VIsual_busy)\n\t{\n\t    // Redo of an operation on a Visual area. Use the same size from\n\t    // redo_VIsual.rv_line_count and redo_VIsual.rv_vcol.\n\t    oap->start = curwin->w_cursor;\n\t    curwin->w_cursor.lnum += redo_VIsual.rv_line_count - 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    VIsual_mode = redo_VIsual.rv_mode;\n\t    if (redo_VIsual.rv_vcol == MAXCOL || VIsual_mode == 'v')\n\t    {\n\t\tif (VIsual_mode == 'v')\n\t\t{\n\t\t    if (redo_VIsual.rv_line_count <= 1)\n\t\t    {\n\t\t\tvalidate_virtcol();\n\t\t\tcurwin->w_curswant =\n\t\t\t\t     curwin->w_virtcol + redo_VIsual.rv_vcol - 1;\n\t\t    }\n\t\t    else\n\t\t\tcurwin->w_curswant = redo_VIsual.rv_vcol;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_curswant = MAXCOL;\n\t\t}\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    cap->count0 = redo_VIsual.rv_count;\n\t    if (redo_VIsual.rv_count != 0)\n\t\tcap->count1 = redo_VIsual.rv_count;\n\t    else\n\t\tcap->count1 = 1;\n\t}\n\telse if (VIsual_active)\n\t{\n\t    if (!gui_yank)\n\t    {\n\t\t// Save the current VIsual area for '< and '> marks, and \"gv\"\n\t\tcurbuf->b_visual.vi_start = VIsual;\n\t\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\t\tcurbuf->b_visual.vi_mode = VIsual_mode;\n\t\trestore_visual_mode();\n\t\tcurbuf->b_visual.vi_curswant = curwin->w_curswant;\n#ifdef FEAT_EVAL\n\t\tcurbuf->b_visual_mode_eval = VIsual_mode;\n#endif\n\t    }\n\n\t    // In Select mode, a linewise selection is operated upon like a\n\t    // characterwise selection.\n\t    // Special case: gH<Del> deletes the last line.\n\t    if (VIsual_select && VIsual_mode == 'V'\n\t\t\t\t\t    && cap->oap->op_type != OP_DELETE)\n\t    {\n\t\tif (LT_POS(VIsual, curwin->w_cursor))\n\t\t{\n\t\t    VIsual.col = 0;\n\t\t    curwin->w_cursor.col =\n\t\t\t       (colnr_T)STRLEN(ml_get(curwin->w_cursor.lnum));\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.col = 0;\n\t\t    VIsual.col = (colnr_T)STRLEN(ml_get(VIsual.lnum));\n\t\t}\n\t\tVIsual_mode = 'v';\n\t    }\n\t    // If 'selection' is \"exclusive\", backup one character for\n\t    // charwise selections.\n\t    else if (VIsual_mode == 'v')\n\t\tinclude_line_break = unadjust_for_sel();\n\n\t    oap->start = VIsual;\n\t    if (VIsual_mode == 'V')\n\t    {\n\t\toap->start.col = 0;\n\t\toap->start.coladd = 0;\n\t    }\n\t}\n\n\t// Set oap->start to the first position of the operated text, oap->end\n\t// to the end of the operated text.  w_cursor is equal to oap->start.\n\tif (LT_POS(oap->start, curwin->w_cursor))\n\t{\n#ifdef FEAT_FOLDING\n\t    // Include folded lines completely.\n\t    if (!VIsual_active)\n\t    {\n\t\tif (hasFolding(oap->start.lnum, &oap->start.lnum, NULL))\n\t\t    oap->start.col = 0;\n\t\tif ((curwin->w_cursor.col > 0 || oap->inclusive\n\t\t\t\t\t\t  || oap->motion_type == MLINE)\n\t\t\t&& hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum))\n\t\t    curwin->w_cursor.col = (colnr_T)STRLEN(ml_get_curline());\n\t    }\n#endif\n\t    oap->end = curwin->w_cursor;\n\t    curwin->w_cursor = oap->start;\n\n\t    // w_virtcol may have been updated; if the cursor goes back to its\n\t    // previous position w_virtcol becomes invalid and isn't updated\n\t    // automatically.\n\t    curwin->w_valid &= ~VALID_VIRTCOL;\n\t}\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Include folded lines completely.\n\t    if (!VIsual_active && oap->motion_type == MLINE)\n\t    {\n\t\tif (hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tNULL))\n\t\t    curwin->w_cursor.col = 0;\n\t\tif (hasFolding(oap->start.lnum, NULL, &oap->start.lnum))\n\t\t    oap->start.col = (colnr_T)STRLEN(ml_get(oap->start.lnum));\n\t    }\n#endif\n\t    oap->end = oap->start;\n\t    oap->start = curwin->w_cursor;\n\t}\n\n\t// Just in case lines were deleted that make the position invalid.\n\tcheck_pos(curwin->w_buffer, &oap->end);\n\toap->line_count = oap->end.lnum - oap->start.lnum + 1;\n\n\t// Set \"virtual_op\" before resetting VIsual_active.\n\tvirtual_op = virtual_active();\n\n\tif (VIsual_active || redo_VIsual_busy)\n\t{\n\t    get_op_vcol(oap, redo_VIsual.rv_vcol, TRUE);\n\n\t    if (!redo_VIsual_busy && !gui_yank)\n\t    {\n\t\t// Prepare to reselect and redo Visual: this is based on the\n\t\t// size of the Visual text\n\t\tresel_VIsual_mode = VIsual_mode;\n\t\tif (curwin->w_curswant == MAXCOL)\n\t\t    resel_VIsual_vcol = MAXCOL;\n\t\telse\n\t\t{\n\t\t    if (VIsual_mode != Ctrl_V)\n\t\t\tgetvvcol(curwin, &(oap->end),\n\t\t\t\t\t\t  NULL, NULL, &oap->end_vcol);\n\t\t    if (VIsual_mode == Ctrl_V || oap->line_count <= 1)\n\t\t    {\n\t\t\tif (VIsual_mode != Ctrl_V)\n\t\t\t    getvvcol(curwin, &(oap->start),\n\t\t\t\t\t\t&oap->start_vcol, NULL, NULL);\n\t\t\tresel_VIsual_vcol = oap->end_vcol - oap->start_vcol + 1;\n\t\t    }\n\t\t    else\n\t\t\tresel_VIsual_vcol = oap->end_vcol;\n\t\t}\n\t\tresel_VIsual_line_count = oap->line_count;\n\t    }\n\n\t    // can't redo yank (unless 'y' is in 'cpoptions') and \":\"\n\t    if ((redo_yank || oap->op_type != OP_YANK)\n\t\t    && oap->op_type != OP_COLON\n#ifdef FEAT_FOLDING\n\t\t    && oap->op_type != OP_FOLD\n\t\t    && oap->op_type != OP_FOLDOPEN\n\t\t    && oap->op_type != OP_FOLDOPENREC\n\t\t    && oap->op_type != OP_FOLDCLOSE\n\t\t    && oap->op_type != OP_FOLDCLOSEREC\n\t\t    && oap->op_type != OP_FOLDDEL\n\t\t    && oap->op_type != OP_FOLDDELREC\n#endif\n\t\t    && oap->motion_force == NUL\n\t\t    )\n\t    {\n\t\t// Prepare for redoing.  Only use the nchar field for \"r\",\n\t\t// otherwise it might be the second char of the operator.\n\t\tif (cap->cmdchar == 'g' && (cap->nchar == 'n'\n\t\t\t\t\t\t\t|| cap->nchar == 'N'))\n\t\t    prep_redo(oap->regname, cap->count0,\n\t\t\t    get_op_char(oap->op_type),\n\t\t\t    get_extra_op_char(oap->op_type),\n\t\t\t    oap->motion_force, cap->cmdchar, cap->nchar);\n\t\telse if (!is_ex_cmdchar(cap))\n\t\t{\n\t\t    int opchar = get_op_char(oap->op_type);\n\t\t    int extra_opchar = get_extra_op_char(oap->op_type);\n\t\t    int nchar = oap->op_type == OP_REPLACE ? cap->nchar : NUL;\n\n\t\t    // reverse what nv_replace() did\n\t\t    if (nchar == REPLACE_CR_NCHAR)\n\t\t\tnchar = CAR;\n\t\t    else if (nchar == REPLACE_NL_NCHAR)\n\t\t\tnchar = NL;\n\n\t\t    if (opchar == 'g' && extra_opchar == '@')\n\t\t\t// also repeat the count for 'operatorfunc'\n\t\t\tprep_redo_num2(oap->regname, 0L, NUL, 'v',\n\t\t\t\t     cap->count0, opchar, extra_opchar, nchar);\n\t\t    else\n\t\t\tprep_redo(oap->regname, 0L, NUL, 'v',\n\t\t\t\t\t\t  opchar, extra_opchar, nchar);\n\t\t}\n\t\tif (!redo_VIsual_busy)\n\t\t{\n\t\t    redo_VIsual.rv_mode = resel_VIsual_mode;\n\t\t    redo_VIsual.rv_vcol = resel_VIsual_vcol;\n\t\t    redo_VIsual.rv_line_count = resel_VIsual_line_count;\n\t\t    redo_VIsual.rv_count = cap->count0;\n\t\t    redo_VIsual.rv_arg = cap->arg;\n\t\t}\n\t    }\n\n\t    // oap->inclusive defaults to TRUE.\n\t    // If oap->end is on a NUL (empty line) oap->inclusive becomes\n\t    // FALSE.  This makes \"d}P\" and \"v}dP\" work the same.\n\t    if (oap->motion_force == NUL || oap->motion_type == MLINE)\n\t\toap->inclusive = TRUE;\n\t    if (VIsual_mode == 'V')\n\t\toap->motion_type = MLINE;\n\t    else\n\t    {\n\t\toap->motion_type = MCHAR;\n\t\tif (VIsual_mode != Ctrl_V && *ml_get_pos(&(oap->end)) == NUL\n\t\t\t&& (include_line_break || !virtual_op))\n\t\t{\n\t\t    oap->inclusive = FALSE;\n\t\t    // Try to include the newline, unless it's an operator\n\t\t    // that works on lines only.\n\t\t    if (*p_sel != 'o'\n\t\t\t    && !op_on_lines(oap->op_type)\n\t\t\t    && oap->end.lnum < curbuf->b_ml.ml_line_count)\n\t\t    {\n\t\t\t++oap->end.lnum;\n\t\t\toap->end.col = 0;\n\t\t\toap->end.coladd = 0;\n\t\t\t++oap->line_count;\n\t\t    }\n\t\t}\n\t    }\n\n\t    redo_VIsual_busy = FALSE;\n\n\t    // Switch Visual off now, so screen updating does\n\t    // not show inverted text when the screen is redrawn.\n\t    // With OP_YANK and sometimes with OP_COLON and OP_FILTER there is\n\t    // no screen redraw, so it is done here to remove the inverted\n\t    // part.\n\t    if (!gui_yank)\n\t    {\n\t\tVIsual_active = FALSE;\n\t\tsetmouse();\n\t\tmouse_dragging = 0;\n\t\tmay_clear_cmdline();\n\t\tif ((oap->op_type == OP_YANK\n\t\t\t    || oap->op_type == OP_COLON\n\t\t\t    || oap->op_type == OP_FUNCTION\n\t\t\t    || oap->op_type == OP_FILTER)\n\t\t\t&& oap->motion_force == NUL)\n\t\t{\n#ifdef FEAT_LINEBREAK\n\t\t    // make sure redrawing is correct\n\t\t    curwin->w_p_lbr = lbr_saved;\n#endif\n\t\t    redraw_curbuf_later(UPD_INVERTED);\n\t\t}\n\t    }\n\t}\n\n\t// Include the trailing byte of a multi-byte char.\n\tif (has_mbyte && oap->inclusive)\n\t{\n\t    int\t\tl;\n\n\t    l = (*mb_ptr2len)(ml_get_pos(&oap->end));\n\t    if (l > 1)\n\t\toap->end.col += l - 1;\n\t}\n\tcurwin->w_set_curswant = TRUE;\n\n\t// oap->empty is set when start and end are the same.  The inclusive\n\t// flag affects this too, unless yanking and the end is on a NUL.\n\toap->empty = (oap->motion_type == MCHAR\n\t\t    && (!oap->inclusive\n\t\t\t|| (oap->op_type == OP_YANK\n\t\t\t    && gchar_pos(&oap->end) == NUL))\n\t\t    && EQUAL_POS(oap->start, oap->end)\n\t\t    && !(virtual_op && oap->start.coladd != oap->end.coladd));\n\t// For delete, change and yank, it's an error to operate on an\n\t// empty region, when 'E' included in 'cpoptions' (Vi compatible).\n\tempty_region_error = (oap->empty\n\t\t\t\t&& vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL);\n\n\t// Force a redraw when operating on an empty Visual region, when\n\t// 'modifiable is off or creating a fold.\n\tif (oap->is_VIsual && (oap->empty || !curbuf->b_p_ma\n#ifdef FEAT_FOLDING\n\t\t    || oap->op_type == OP_FOLD\n#endif\n\t\t    ))\n\t{\n#ifdef FEAT_LINEBREAK\n\t    curwin->w_p_lbr = lbr_saved;\n#endif\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\n\t// If the end of an operator is in column one while oap->motion_type\n\t// is MCHAR and oap->inclusive is FALSE, we put op_end after the last\n\t// character in the previous line. If op_start is on or before the\n\t// first non-blank in the line, the operator becomes linewise\n\t// (strange, but that's the way vi does it).\n\tif (\t   oap->motion_type == MCHAR\n\t\t&& oap->inclusive == FALSE\n\t\t&& !(cap->retval & CA_NO_ADJ_OP_END)\n\t\t&& oap->end.col == 0\n\t\t&& (!oap->is_VIsual || *p_sel == 'o')\n\t\t&& !oap->block_mode\n\t\t&& oap->line_count > 1)\n\t{\n\t    oap->end_adjusted = TRUE;\t    // remember that we did this\n\t    --oap->line_count;\n\t    --oap->end.lnum;\n\t    if (inindent(0))\n\t\toap->motion_type = MLINE;\n\t    else\n\t    {\n\t\toap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t\tif (oap->end.col)\n\t\t{\n\t\t    --oap->end.col;\n\t\t    oap->inclusive = TRUE;\n\t\t}\n\t    }\n\t}\n\telse\n\t    oap->end_adjusted = FALSE;\n\n\tswitch (oap->op_type)\n\t{\n\tcase OP_LSHIFT:\n\tcase OP_RSHIFT:\n\t    op_shift(oap, TRUE, oap->is_VIsual ? (int)cap->count1 : 1);\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase OP_JOIN_NS:\n\tcase OP_JOIN:\n\t    if (oap->line_count < 2)\n\t\toap->line_count = 2;\n\t    if (curwin->w_cursor.lnum + oap->line_count - 1 >\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count)\n\t\tbeep_flush();\n\t    else\n\t    {\n\t\t(void)do_join(oap->line_count, oap->op_type == OP_JOIN,\n\t\t\t\t\t\t\t    TRUE, TRUE, TRUE);\n\t\tauto_format(FALSE, TRUE);\n\t    }\n\t    break;\n\n\tcase OP_DELETE:\n\t    VIsual_reselect = FALSE;\t    // don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\t(void)op_delete(oap);\n\t\t// save cursor line for undo if it wasn't saved yet\n\t\tif (oap->motion_type == MLINE && has_format_option(FO_AUTO)\n\t\t\t\t\t\t      && u_save_cursor() == OK)\n\t\t    auto_format(FALSE, TRUE);\n\t    }\n\t    break;\n\n\tcase OP_YANK:\n\t    if (empty_region_error)\n\t    {\n\t\tif (!gui_yank)\n\t\t{\n\t\t    vim_beep(BO_OPER);\n\t\t    CancelRedo();\n\t\t}\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\toap->excl_tr_ws = cap->cmdchar == 'z';\n\t\t(void)op_yank(oap, FALSE, !gui_yank);\n\t    }\n\t    check_cursor_col();\n\t    break;\n\n\tcase OP_CHANGE:\n\t    VIsual_reselect = FALSE;\t    // don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\t// This is a new edit command, not a restart.  Need to\n\t\t// remember it to make 'insertmode' work with mappings for\n\t\t// Visual mode.  But do this only once and not when typed and\n\t\t// 'insertmode' isn't set.\n\t\tif (p_im || !KeyTyped)\n\t\t    restart_edit_save = restart_edit;\n\t\telse\n\t\t    restart_edit_save = 0;\n\t\trestart_edit = 0;\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\t// Reset finish_op now, don't want it set inside edit().\n\t\tfinish_op = FALSE;\n\t\tif (op_change(oap))\t// will call edit()\n\t\t    cap->retval |= CA_COMMAND_BUSY;\n\t\tif (restart_edit == 0)\n\t\t    restart_edit = restart_edit_save;\n\t    }\n\t    break;\n\n\tcase OP_FILTER:\n\t    if (vim_strchr(p_cpo, CPO_FILTER) != NULL)\n\t\tAppendToRedobuff((char_u *)\"!\\r\");  // use any last used !cmd\n\t    else\n\t\tbangredo = TRUE;    // do_bang() will put cmd in redo buffer\n\t    // FALLTHROUGH\n\n\tcase OP_INDENT:\n\tcase OP_COLON:\n\n\t    // If 'equalprg' is empty, do the indenting internally.\n\t    if (oap->op_type == OP_INDENT && *get_equalprg() == NUL)\n\t    {\n\t\tif (curbuf->b_p_lisp)\n\t\t{\n\t\t    op_reindent(oap, get_lisp_indent);\n\t\t    break;\n\t\t}\n\t\top_reindent(oap,\n#ifdef FEAT_EVAL\n\t\t\t*curbuf->b_p_inde != NUL ? get_expr_indent :\n#endif\n\t\t\t    get_c_indent);\n\t\tbreak;\n\t    }\n\n\t    op_colon(oap);\n\t    break;\n\n\tcase OP_TILDE:\n\tcase OP_UPPER:\n\tcase OP_LOWER:\n\tcase OP_ROT13:\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t\top_tilde(oap);\n\t    check_cursor_col();\n\t    break;\n\n\tcase OP_FORMAT:\n#if defined(FEAT_EVAL)\n\t    if (*curbuf->b_p_fex != NUL)\n\t\top_formatexpr(oap);\t// use expression\n\t    else\n#endif\n\t    {\n\t\tif (*p_fp != NUL || *curbuf->b_p_fp != NUL)\n\t\t    op_colon(oap);\t\t// use external command\n\t\telse\n\t\t    op_format(oap, FALSE);\t// use internal function\n\t    }\n\t    break;\n\tcase OP_FORMAT2:\n\t    op_format(oap, TRUE);\t// use internal function\n\t    break;\n\n\tcase OP_FUNCTION:\n\t    {\n\t\tredo_VIsual_T   save_redo_VIsual = redo_VIsual;\n\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\t// call 'operatorfunc'\n\t\top_function(oap);\n\n\t\t// Restore the info for redoing Visual mode, the function may\n\t\t// invoke another operator and unintentionally change it.\n\t\tredo_VIsual = save_redo_VIsual;\n\t\tbreak;\n\t    }\n\n\tcase OP_INSERT:\n\tcase OP_APPEND:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\t// This is a new edit command, not a restart.  Need to\n\t\t// remember it to make 'insertmode' work with mappings for\n\t\t// Visual mode.  But do this only once.\n\t\trestart_edit_save = restart_edit;\n\t\trestart_edit = 0;\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\top_insert(oap, cap->count1);\n#ifdef FEAT_LINEBREAK\n\t\t// Reset linebreak, so that formatting works correctly.\n\t\tcurwin->w_p_lbr = FALSE;\n#endif\n\n\t\t// TODO: when inserting in several lines, should format all\n\t\t// the lines.\n\t\tauto_format(FALSE, TRUE);\n\n\t\tif (restart_edit == 0)\n\t\t    restart_edit = restart_edit_save;\n\t\telse\n\t\t    cap->retval |= CA_COMMAND_BUSY;\n\t    }\n\t    break;\n\n\tcase OP_REPLACE:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\top_replace(oap, cap->nchar);\n\t    }\n\t    break;\n\n#ifdef FEAT_FOLDING\n\tcase OP_FOLD:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    foldCreate(oap->start.lnum, oap->end.lnum);\n\t    break;\n\n\tcase OP_FOLDOPEN:\n\tcase OP_FOLDOPENREC:\n\tcase OP_FOLDCLOSE:\n\tcase OP_FOLDCLOSEREC:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    opFoldRange(oap->start.lnum, oap->end.lnum,\n\t\t    oap->op_type == OP_FOLDOPEN\n\t\t\t\t\t    || oap->op_type == OP_FOLDOPENREC,\n\t\t    oap->op_type == OP_FOLDOPENREC\n\t\t\t\t\t  || oap->op_type == OP_FOLDCLOSEREC,\n\t\t\t\t\t  oap->is_VIsual);\n\t    break;\n\n\tcase OP_FOLDDEL:\n\tcase OP_FOLDDELREC:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    deleteFold(oap->start.lnum, oap->end.lnum,\n\t\t\t       oap->op_type == OP_FOLDDELREC, oap->is_VIsual);\n\t    break;\n#endif\n\tcase OP_NR_ADD:\n\tcase OP_NR_SUB:\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\tVIsual_active = TRUE;\n#ifdef FEAT_LINEBREAK\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\top_addsub(oap, cap->count1, redo_VIsual.rv_arg);\n\t\tVIsual_active = FALSE;\n\t    }\n\t    check_cursor_col();\n\t    break;\n\tdefault:\n\t    clearopbeep(oap);\n\t}\n\tvirtual_op = MAYBE;\n\tif (!gui_yank)\n\t{\n\t    // if 'sol' not set, go back to old column for some commands\n\t    if (!p_sol && oap->motion_type == MLINE && !oap->end_adjusted\n\t\t    && (oap->op_type == OP_LSHIFT || oap->op_type == OP_RSHIFT\n\t\t\t\t\t\t|| oap->op_type == OP_DELETE))\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tcurwin->w_p_lbr = FALSE;\n#endif\n\t\tcoladvance(curwin->w_curswant = old_col);\n\t    }\n\t}\n\telse\n\t{\n\t    curwin->w_cursor = old_cursor;\n\t}\n\toap->block_mode = FALSE;\n\tclearop(oap);\n\tmotion_force = NUL;\n    }\n#ifdef FEAT_LINEBREAK\n    curwin->w_p_lbr = lbr_saved;\n#endif\n}\n", "\" Tests for 'virtualedit'.\n\nfunc Test_yank_move_change()\n  new\n  call setline(1, [\n\t\\ \"func foo() error {\",\n\t\\ \"\\tif n, err := bar();\",\n\t\\ \"\\terr != nil {\",\n\t\\ \"\\t\\treturn err\",\n\t\\ \"\\t}\",\n\t\\ \"\\tn = n * n\",\n\t\\ ])\n  set virtualedit=all\n  set ts=4\n  function! MoveSelectionDown(count) abort\n    normal! m`\n    silent! exe \"'<,'>move'>+\".a:count\n    norm! ``\n  endfunction\n\n  xmap ]e :<C-U>call MoveSelectionDown(v:count1)<CR>\n  2\n  normal 2gg\n  normal J\n  normal jVj\n  normal ]e\n  normal ce\n  bwipe!\n  set virtualedit=\n  set ts=8\nendfunc\n\nfunc Test_paste_end_of_line()\n  new\n  set virtualedit=all\n  call setline(1, ['456', '123'])\n  normal! gg0\"ay$\n  exe \"normal! 2G$lllA\\<C-O>:normal! \\\"agP\\r\"\n  call assert_equal('123456', getline(2))\n\n  bwipe!\n  set virtualedit=\nendfunc\n\nfunc Test_replace_end_of_line()\n  new\n  set virtualedit=all\n  call setline(1, range(20))\n  exe \"normal! gg2jv10lr-\"\n  call assert_equal([\"1\", \"-----------\", \"3\"], getline(2,4))\n  call setline(1, range(20))\n  exe \"normal! gg2jv10lr\\<c-k>hh\"\n  call assert_equal([\"1\", \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\", \"3\"], getline(2,4))\n\n  bwipe!\n  set virtualedit=\nendfunc\n\nfunc Test_edit_CTRL_G()\n  new\n  set virtualedit=insert\n  call setline(1, ['123', '1', '12'])\n  exe \"normal! ggA\\<c-g>jx\\<c-g>jx\"\n  call assert_equal(['123', '1  x', '12 x'], getline(1,'$'))\n\n  set virtualedit=all\n  %d_\n  call setline(1, ['1', '12'])\n  exe \"normal! ggllix\\<c-g>jx\"\n  call assert_equal(['1 x', '12x'], getline(1,'$'))\n\n\n  bwipe!\n  set virtualedit=\nendfunc\n\nfunc Test_edit_change()\n  new\n  set virtualedit=all\n  call setline(1, \"\\t\u248c\")\n  normal Cx\n  call assert_equal('x', getline(1))\n  \" Do a visual block change\n  call setline(1, ['a', 'b', 'c'])\n  exe \"normal gg3l\\<C-V>2jcx\"\n  call assert_equal(['a  x', 'b  x', 'c  x'], getline(1, '$'))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Tests for pasting at the beginning, end and middle of a tab character\n\" in virtual edit mode.\nfunc Test_paste_in_tab()\n  new\n  call append(0, '')\n  set virtualedit=all\n\n  \" Tests for pasting a register with characterwise mode type\n  call setreg('\"', 'xyz', 'c')\n\n  \" paste (p) unnamed register at the beginning of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 0)\n  normal p\n  call assert_equal('a xyz      b', getline(1))\n\n  \" paste (P) unnamed register at the beginning of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 0)\n  normal P\n  call assert_equal(\"axyz\\tb\", getline(1))\n\n  \" paste (p) unnamed register at the end of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 6)\n  normal p\n  call assert_equal(\"a\\txyzb\", getline(1))\n\n  \" paste (P) unnamed register at the end of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 6)\n  normal P\n  call assert_equal('a      xyz b', getline(1))\n\n  \" Tests for pasting a register with blockwise mode type\n  call setreg('\"', 'xyz', 'b')\n\n  \" paste (p) unnamed register at the beginning of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 0)\n  normal p\n  call assert_equal('a xyz      b', getline(1))\n\n  \" paste (P) unnamed register at the beginning of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 0)\n  normal P\n  call assert_equal(\"axyz\\tb\", getline(1))\n\n  \" paste (p) unnamed register at the end of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 6)\n  normal p\n  call assert_equal(\"a\\txyzb\", getline(1))\n\n  \" paste (P) unnamed register at the end of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 6)\n  normal P\n  call assert_equal('a      xyz b', getline(1))\n\n  \" Tests for pasting with gp and gP in virtual edit mode\n\n  \" paste (gp) unnamed register at the beginning of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 0)\n  normal gp\n  call assert_equal('a xyz      b', getline(1))\n  call assert_equal([0, 1, 12, 0, 12], getcurpos())\n\n  \" paste (gP) unnamed register at the beginning of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 0)\n  normal gP\n  call assert_equal(\"axyz\\tb\", getline(1))\n  call assert_equal([0, 1, 5, 0, 5], getcurpos())\n\n  \" paste (gp) unnamed register at the end of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 6)\n  normal gp\n  call assert_equal(\"a\\txyzb\", getline(1))\n  call assert_equal([0, 1, 6, 0, 12], getcurpos())\n\n  \" paste (gP) unnamed register at the end of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 6)\n  normal gP\n  call assert_equal('a      xyz b', getline(1))\n  call assert_equal([0, 1, 12, 0, 12], getcurpos())\n\n  \" Tests for pasting a named register\n  let @r = 'xyz'\n\n  \" paste (gp) named register in the middle of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 2)\n  normal \"rgp\n  call assert_equal('a   xyz    b', getline(1))\n  call assert_equal([0, 1, 8, 0, 8], getcurpos())\n\n  \" paste (gP) named register in the middle of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 2)\n  normal \"rgP\n  call assert_equal('a  xyz     b', getline(1))\n  call assert_equal([0, 1, 7, 0, 7], getcurpos())\n\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test for yanking a few spaces within a tab to a register\nfunc Test_yank_in_tab()\n  new\n  let @r = ''\n  call setline(1, \"a\\tb\")\n  set virtualedit=all\n  call cursor(1, 2, 2)\n  normal \"ry5l\n  call assert_equal('     ', @r)\n\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Insert \"keyword keyw\", ESC, C CTRL-N, shows \"keyword ykeyword\".\n\" Repeating CTRL-N fixes it. (Mary Ellen Foster)\nfunc Test_ve_completion()\n  new\n  set completeopt&vim\n  set virtualedit=all\n  exe \"normal ikeyword keyw\\<Esc>C\\<C-N>\"\n  call assert_equal('keyword keyword', getline(1))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Using \"C\" then then <CR> moves the last remaining character to the next\n\" line.  (Mary Ellen Foster)\nfunc Test_ve_del_to_eol()\n  new\n  set virtualedit=all\n  call append(0, 'all your base are belong to us')\n  call search('are', 'w')\n  exe \"normal C\\<CR>are belong to vim\"\n  call assert_equal(['all your base ', 'are belong to vim'], getline(1, 2))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" When past the end of a line that ends in a single character \"b\" skips\n\" that word.\nfunc Test_ve_b_past_eol()\n  new\n  set virtualedit=all\n  call append(0, '1 2 3 4 5 6')\n  normal gg^$15lbC7\n  call assert_equal('1 2 3 4 5 7', getline(1))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Make sure 'i', 'C', 'a', 'A' and 'D' works\nfunc Test_ve_ins_del()\n  new\n  set virtualedit=all\n  call append(0, [\"'i'\", \"'C'\", \"'a'\", \"'A'\", \"'D'\"])\n  call cursor(1, 1)\n  normal $4lix\n  call assert_equal(\"'i'   x\", getline(1))\n  call cursor(2, 1)\n  normal $4lCx\n  call assert_equal(\"'C'   x\", getline(2))\n  call cursor(3, 1)\n  normal $4lax\n  call assert_equal(\"'a'    x\", getline(3))\n  call cursor(4, 1)\n  normal $4lAx\n  call assert_equal(\"'A'x\", getline(4))\n  call cursor(5, 1)\n  normal $4lDix\n  call assert_equal(\"'D'   x\", getline(5))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test for yank bug reported by Mark Waggoner.\nfunc Test_yank_block()\n  new\n  set virtualedit=block\n  call append(0, repeat(['this is a test'], 3))\n  exe \"normal gg^2w\\<C-V>3jy\"\n  call assert_equal(\"a\\na\\na\\n \", @\")\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test \"r\" beyond the end of the line\nfunc Test_replace_after_eol()\n  new\n  set virtualedit=all\n  call append(0, '\"r\"')\n  normal gg$5lrxa\n  call assert_equal('\"r\"    x', getline(1))\n  \" visual block replace\n  %d _\n  call setline(1, ['a', '', 'b'])\n  exe \"normal 2l\\<C-V>2jrx\"\n  call assert_equal(['a x', '  x', 'b x'], getline(1, '$'))\n  \" visual characterwise selection replace after eol\n  %d _\n  call setline(1, 'a')\n  normal 4lv2lrx\n  call assert_equal('a   xxx', getline(1))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test \"r\" on a tab\n\" Note that for this test, 'ts' must be 8 (the default).\nfunc Test_replace_on_tab()\n  new\n  set virtualedit=all\n  call append(0, \"'r'\\t\")\n  normal gg^5lrxAy\n  call assert_equal(\"'r'  x  y\", getline(1))\n  call setline(1, 'aaaaaaaaaaaa')\n  exe \"normal! gg2lgR\\<Tab>\"\n  call assert_equal(\"aa\\taaaa\", getline(1))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test to make sure 'x' can delete control characters\nfunc Test_ve_del_ctrl_chars()\n  new\n  set virtualedit=all\n  call append(0, \"a\\<C-V>b\\<CR>sd\")\n  set display=uhex\n  normal gg^xxxxxxi[text]\n  set display=\n  call assert_equal('[text]', getline(1))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test for ^Y/^E due to bad w_virtcol value, reported by\n\" Roy <royl@netropolis.net>.\nfunc Test_ins_copy_char()\n  new\n  set virtualedit=all\n  call append(0, 'abcv8efi.him2kl')\n  exe \"normal gg^O\\<Esc>3li\\<C-E>\\<Esc>4li\\<C-E>\\<Esc>4li\\<C-E>   <--\"\n  exe \"normal j^o\\<Esc>4li\\<C-Y>\\<Esc>4li\\<C-Y>\\<Esc>4li\\<C-Y>   <--\"\n  call assert_equal('   v   i   m   <--', getline(1))\n  call assert_equal('    8   .   2   <--', getline(3))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test for yanking and pasting using the small delete register\nfunc Test_yank_paste_small_del_reg()\n  new\n  set virtualedit=all\n  call append(0, \"foo, bar\")\n  normal ggdewve\"-p\n  call assert_equal(', foo', getline(1))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test for delete that breaks a tab into spaces\nfunc Test_delete_break_tab()\n  new\n  call setline(1, \"one\\ttwo\")\n  set virtualedit=all\n  normal v3ld\n  call assert_equal('    two', getline(1))\n  set virtualedit&\n  close!\nendfunc\n\n\" Test for using <BS>, <C-W> and <C-U> in virtual edit mode\n\" to erase character, word and line.\nfunc Test_ve_backspace()\n  new\n  call setline(1, 'sample')\n  set virtualedit=all\n  set backspace=indent,eol,start\n  exe \"normal 15|i\\<BS>\\<BS>\"\n  call assert_equal([0, 1, 7, 5], getpos('.'))\n  exe \"normal 15|i\\<C-W>\"\n  call assert_equal([0, 1, 6, 0], getpos('.'))\n  exe \"normal 15|i\\<C-U>\"\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  set backspace&\n  set virtualedit&\n  close!\nendfunc\n\n\" Test for delete (x) on EOL character and after EOL\nfunc Test_delete_past_eol()\n  new\n  call setline(1, \"ab\")\n  set virtualedit=all\n  exe \"normal 2lx\"\n  call assert_equal('ab', getline(1))\n  exe \"normal 10lx\"\n  call assert_equal('ab', getline(1))\n  set virtualedit&\n  bw!\nendfunc\n\n\" After calling s:TryVirtualeditReplace(), line 1 will contain one of these\n\" two strings, depending on whether virtual editing is on or off.\nlet s:result_ve_on  = 'a      x'\nlet s:result_ve_off = 'x'\n\n\" Utility function for Test_global_local_virtualedit()\nfunc s:TryVirtualeditReplace()\n  call setline(1, 'a')\n  normal gg7l\n  normal rx\nendfunc\n\n\" Test for :set and :setlocal\nfunc Test_global_local_virtualedit()\n  new\n\n  \" Verify that 'virtualedit' is initialized to empty, can be set globally to\n  \" all and to empty, and can be set locally to all and to empty.\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  set ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  set ve=\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  setlocal ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  setlocal ve=\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n\n  \" Verify that :set affects multiple windows.\n  split\n  set ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  wincmd p\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  set ve=\n  wincmd p\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  bwipe!\n\n  \" Verify that :setlocal affects only the current window.\n  new\n  split\n  setlocal ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  wincmd p\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  bwipe!\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n\n  \" Verify that the buffer 'virtualedit' state follows the global value only\n  \" when empty and that \"none\" works as expected.\n  \"\n  \"          'virtualedit' State\n  \" +--------+--------------------------+\n  \" | Local  |          Global          |\n  \" |        |                          |\n  \" +--------+--------+--------+--------+\n  \" |        | \"\"     | \"all\"  | \"none\" |\n  \" +--------+--------+--------+--------+\n  \" | \"\"     |  off   |  on    |  off   |\n  \" | \"all\"  |  on    |  on    |  on    |\n  \" | \"none\" |  off   |  off   |  off   |\n  \" +--------+--------+--------+--------+\n  new\n\n  setglobal ve=\n  setlocal ve=\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  setlocal ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  setlocal ve=none\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n\n  setglobal ve=all\n  setlocal ve=\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  setlocal ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  setlocal ve=none\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  setlocal ve=NONE\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n\n  setglobal ve=none\n  setlocal ve=\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  setlocal ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  setlocal ve=none\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n\n  bwipe!\n\n  \" Verify that the 'virtualedit' state is copied to new windows.\n  new\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  split\n  setlocal ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  split\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  setlocal ve=\n  split\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  bwipe!\n\n  setlocal virtualedit&\n  set virtualedit&\nendfunc\n\nfunc Test_virtualedit_mouse()\n  let save_mouse = &mouse\n  set mouse=a\n  set virtualedit=all\n  new\n\n  call setline(1, [\"text\\tword\"])\n  redraw\n  call test_setmouse(1, 4)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 4, 0, 4], getcurpos())\n  call test_setmouse(1, 5)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 5, 0, 5], getcurpos())\n  call test_setmouse(1, 6)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 5, 1, 6], getcurpos())\n  call test_setmouse(1, 7)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 5, 2, 7], getcurpos())\n  call test_setmouse(1, 8)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 5, 3, 8], getcurpos())\n  call test_setmouse(1, 9)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 6, 0, 9], getcurpos())\n  call test_setmouse(1, 15)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 10, 2, 15], getcurpos())\n\n  bwipe!\n  let &mouse = save_mouse\n  set virtualedit&\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ops.c: implementation of various operators: op_shift, op_delete, op_tilde,\n *\t  op_change, op_yank, do_join\n */\n\n#include \"vim.h\"\n\nstatic void shift_block(oparg_T *oap, int amount);\nstatic void\tmb_adjust_opend(oparg_T *oap);\nstatic int\tdo_addsub(int op_type, pos_T *pos, int length, linenr_T Prenum1);\n\n// Flags for third item in \"opchars\".\n#define OPF_LINES  1\t// operator always works on lines\n#define OPF_CHANGE 2\t// operator changes text\n\n/*\n * The names of operators.\n * IMPORTANT: Index must correspond with defines in vim.h!!!\n * The third field holds OPF_ flags.\n */\nstatic char opchars[][3] =\n{\n    {NUL, NUL, 0},\t\t\t// OP_NOP\n    {'d', NUL, OPF_CHANGE},\t\t// OP_DELETE\n    {'y', NUL, 0},\t\t\t// OP_YANK\n    {'c', NUL, OPF_CHANGE},\t\t// OP_CHANGE\n    {'<', NUL, OPF_LINES | OPF_CHANGE},\t// OP_LSHIFT\n    {'>', NUL, OPF_LINES | OPF_CHANGE},\t// OP_RSHIFT\n    {'!', NUL, OPF_LINES | OPF_CHANGE},\t// OP_FILTER\n    {'g', '~', OPF_CHANGE},\t\t// OP_TILDE\n    {'=', NUL, OPF_LINES | OPF_CHANGE},\t// OP_INDENT\n    {'g', 'q', OPF_LINES | OPF_CHANGE},\t// OP_FORMAT\n    {':', NUL, OPF_LINES},\t\t// OP_COLON\n    {'g', 'U', OPF_CHANGE},\t\t// OP_UPPER\n    {'g', 'u', OPF_CHANGE},\t\t// OP_LOWER\n    {'J', NUL, OPF_LINES | OPF_CHANGE},\t// DO_JOIN\n    {'g', 'J', OPF_LINES | OPF_CHANGE},\t// DO_JOIN_NS\n    {'g', '?', OPF_CHANGE},\t\t// OP_ROT13\n    {'r', NUL, OPF_CHANGE},\t\t// OP_REPLACE\n    {'I', NUL, OPF_CHANGE},\t\t// OP_INSERT\n    {'A', NUL, OPF_CHANGE},\t\t// OP_APPEND\n    {'z', 'f', OPF_LINES},\t\t// OP_FOLD\n    {'z', 'o', OPF_LINES},\t\t// OP_FOLDOPEN\n    {'z', 'O', OPF_LINES},\t\t// OP_FOLDOPENREC\n    {'z', 'c', OPF_LINES},\t\t// OP_FOLDCLOSE\n    {'z', 'C', OPF_LINES},\t\t// OP_FOLDCLOSEREC\n    {'z', 'd', OPF_LINES},\t\t// OP_FOLDDEL\n    {'z', 'D', OPF_LINES},\t\t// OP_FOLDDELREC\n    {'g', 'w', OPF_LINES | OPF_CHANGE},\t// OP_FORMAT2\n    {'g', '@', OPF_CHANGE},\t\t// OP_FUNCTION\n    {Ctrl_A, NUL, OPF_CHANGE},\t\t// OP_NR_ADD\n    {Ctrl_X, NUL, OPF_CHANGE},\t\t// OP_NR_SUB\n};\n\n/*\n * Translate a command name into an operator type.\n * Must only be called with a valid operator name!\n */\n    int\nget_op_type(int char1, int char2)\n{\n    int\t\ti;\n\n    if (char1 == 'r')\t\t// ignore second character\n\treturn OP_REPLACE;\n    if (char1 == '~')\t\t// when tilde is an operator\n\treturn OP_TILDE;\n    if (char1 == 'g' && char2 == Ctrl_A)\t// add\n\treturn OP_NR_ADD;\n    if (char1 == 'g' && char2 == Ctrl_X)\t// subtract\n\treturn OP_NR_SUB;\n    if (char1 == 'z' && char2 == 'y')\t// OP_YANK\n\treturn OP_YANK;\n    for (i = 0; ; ++i)\n    {\n\tif (opchars[i][0] == char1 && opchars[i][1] == char2)\n\t    break;\n\tif (i == (int)ARRAY_LENGTH(opchars) - 1)\n\t{\n\t    internal_error(\"get_op_type()\");\n\t    break;\n\t}\n    }\n    return i;\n}\n\n/*\n * Return TRUE if operator \"op\" always works on whole lines.\n */\n    static int\nop_on_lines(int op)\n{\n    return opchars[op][2] & OPF_LINES;\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Return TRUE if operator \"op\" changes text.\n */\n    int\nop_is_change(int op)\n{\n    return opchars[op][2] & OPF_CHANGE;\n}\n#endif\n\n/*\n * Get first operator command character.\n * Returns 'g' or 'z' if there is another command character.\n */\n    int\nget_op_char(int optype)\n{\n    return opchars[optype][0];\n}\n\n/*\n * Get second operator command character.\n */\n    int\nget_extra_op_char(int optype)\n{\n    return opchars[optype][1];\n}\n\n/*\n * op_shift - handle a shift operation\n */\n    void\nop_shift(oparg_T *oap, int curs_top, int amount)\n{\n    long\t    i;\n    int\t\t    first_char;\n    int\t\t    block_col = 0;\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n\n    if (oap->block_mode)\n\tblock_col = curwin->w_cursor.col;\n\n    for (i = oap->line_count; --i >= 0; )\n    {\n\tfirst_char = *ml_get_curline();\n\tif (first_char == NUL)\t\t\t\t// empty line\n\t    curwin->w_cursor.col = 0;\n\telse if (oap->block_mode)\n\t    shift_block(oap, amount);\n\telse\n\t    // Move the line right if it doesn't start with '#', 'smartindent'\n\t    // isn't set or 'cindent' isn't set or '#' isn't in 'cino'.\n\t    if (first_char != '#' || !preprocs_left())\n\t\tshift_line(oap->op_type == OP_LSHIFT, p_sr, amount, FALSE);\n\t++curwin->w_cursor.lnum;\n    }\n\n    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);\n    if (oap->block_mode)\n    {\n\tcurwin->w_cursor.lnum = oap->start.lnum;\n\tcurwin->w_cursor.col = block_col;\n    }\n    else if (curs_top)\t    // put cursor on first line, for \">>\"\n    {\n\tcurwin->w_cursor.lnum = oap->start.lnum;\n\tbeginline(BL_SOL | BL_FIX);   // shift_line() may have set cursor.col\n    }\n    else\n\t--curwin->w_cursor.lnum;\t// put cursor on last line, for \":>\"\n\n#ifdef FEAT_FOLDING\n    // The cursor line is not in a closed fold\n    foldOpenCursor();\n#endif\n\n\n    if (oap->line_count > p_report)\n    {\n\tchar\t    *op;\n\tchar\t    *msg_line_single;\n\tchar\t    *msg_line_plural;\n\n\tif (oap->op_type == OP_RSHIFT)\n\t    op = \">\";\n\telse\n\t    op = \"<\";\n\tmsg_line_single = NGETTEXT(\"%ld line %sed %d time\",\n\t\t\t\t\t     \"%ld line %sed %d times\", amount);\n\tmsg_line_plural = NGETTEXT(\"%ld lines %sed %d time\",\n\t\t\t\t\t    \"%ld lines %sed %d times\", amount);\n\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\tNGETTEXT(msg_line_single, msg_line_plural, oap->line_count),\n\t\toap->line_count, op, amount);\n\tmsg_attr_keep((char *)IObuff, 0, TRUE);\n    }\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end.lnum = oap->end.lnum;\n\tcurbuf->b_op_end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Shift the current line one shiftwidth left (if left != 0) or right\n * leaves cursor on first blank in the line.\n */\n    void\nshift_line(\n    int\tleft,\n    int\tround,\n    int\tamount,\n    int call_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tcount;\n    int\t\ti, j;\n    int\t\tsw_val = (int)get_sw_value_indent(curbuf);\n\n    count = get_indent();\t// get current indent\n\n    if (round)\t\t\t// round off indent\n    {\n\ti = count / sw_val;\t// number of 'shiftwidth' rounded down\n\tj = count % sw_val;\t// extra spaces\n\tif (j && left)\t\t// first remove extra spaces\n\t    --amount;\n\tif (left)\n\t{\n\t    i -= amount;\n\t    if (i < 0)\n\t\ti = 0;\n\t}\n\telse\n\t    i += amount;\n\tcount = i * sw_val;\n    }\n    else\t\t// original vi indent\n    {\n\tif (left)\n\t{\n\t    count -= sw_val * amount;\n\t    if (count < 0)\n\t\tcount = 0;\n\t}\n\telse\n\t    count += sw_val * amount;\n    }\n\n    // Set new indent\n    if (State & VREPLACE_FLAG)\n\tchange_indent(INDENT_SET, count, FALSE, NUL, call_changed_bytes);\n    else\n\t(void)set_indent(count, call_changed_bytes ? SIN_CHANGED : 0);\n}\n\n/*\n * Shift one line of the current block one shiftwidth right or left.\n * Leaves cursor on first character in block.\n */\n    static void\nshift_block(oparg_T *oap, int amount)\n{\n    int\t\t\tleft = (oap->op_type == OP_LSHIFT);\n    int\t\t\toldstate = State;\n    int\t\t\ttotal;\n    char_u\t\t*newp, *oldp;\n    int\t\t\toldcol = curwin->w_cursor.col;\n    int\t\t\tsw_val = (int)get_sw_value_indent(curbuf);\n    int\t\t\tts_val = (int)curbuf->b_p_ts;\n    struct block_def\tbd;\n    int\t\t\tincr;\n    colnr_T\t\tws_vcol;\n    int\t\t\tadded;\n    unsigned\t\tnew_line_len;\t// the length of the line after the\n\t\t\t\t\t// block shift\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\told_p_ri = p_ri;\n\n    p_ri = 0;\t\t\t// don't want revins in indent\n#endif\n\n    State = MODE_INSERT;\t// don't want MODE_REPLACE for State\n    block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);\n    if (bd.is_short)\n\treturn;\n\n    // total is number of screen columns to be inserted/removed\n    total = (int)((unsigned)amount * (unsigned)sw_val);\n    if ((total / sw_val) != amount)\n\treturn; // multiplication overflow\n\n    oldp = ml_get_curline();\n\n    if (!left)\n    {\n\tint\t\ttabs = 0, spaces = 0;\n\tchartabsize_T\tcts;\n\n\t/*\n\t *  1. Get start vcol\n\t *  2. Total ws vcols\n\t *  3. Divvy into TABs & spp\n\t *  4. Construct new string\n\t */\n\ttotal += bd.pre_whitesp; // all virtual WS up to & incl a split TAB\n\tws_vcol = bd.start_vcol - bd.pre_whitesp;\n\tif (bd.startspaces)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tif ((*mb_ptr2len)(bd.textstart) == 1)\n\t\t    ++bd.textstart;\n\t\telse\n\t\t{\n\t\t    ws_vcol = 0;\n\t\t    bd.startspaces = 0;\n\t\t}\n\t    }\n\t    else\n\t\t++bd.textstart;\n\t}\n\n\t// TODO: is passing bd.textstart for start of the line OK?\n\tinit_chartabsize_arg(&cts, curwin, curwin->w_cursor.lnum,\n\t\t\t\t   bd.start_vcol, bd.textstart, bd.textstart);\n\tfor ( ; VIM_ISWHITE(*cts.cts_ptr); )\n\t{\n\t    incr = lbr_chartabsize_adv(&cts);\n\t    total += incr;\n\t    cts.cts_vcol += incr;\n\t}\n\tbd.textstart = cts.cts_ptr;\n\tbd.start_vcol = cts.cts_vcol;\n\tclear_chartabsize_arg(&cts);\n\n\t// OK, now total=all the VWS reqd, and textstart points at the 1st\n\t// non-ws char in the block.\n#ifdef FEAT_VARTABS\n\tif (!curbuf->b_p_et)\n\t    tabstop_fromto(ws_vcol, ws_vcol + total,\n\t\t\t\tts_val, curbuf->b_p_vts_array, &tabs, &spaces);\n\telse\n\t    spaces = total;\n#else\n\tif (!curbuf->b_p_et)\n\t    tabs = ((ws_vcol % ts_val) + total) / ts_val; // number of tabs\n\tif (tabs > 0)\n\t    spaces = ((ws_vcol % ts_val) + total) % ts_val; // number of spp\n\telse\n\t    spaces = total;\n#endif\n\t// if we're splitting a TAB, allow for it\n\tbd.textcol -= bd.pre_whitesp_c - (bd.startspaces != 0);\n\n\tnew_line_len = bd.textcol + tabs + spaces + (int)STRLEN(bd.textstart);\n\tnewp = alloc(new_line_len + 1);\n\tif (newp == NULL)\n\t    return;\n\tmch_memmove(newp, oldp, (size_t)bd.textcol);\n\tvim_memset(newp + bd.textcol, TAB, (size_t)tabs);\n\tvim_memset(newp + bd.textcol + tabs, ' ', (size_t)spaces);\n\t// Note that STRMOVE() copies the trailing NUL.\n\tSTRMOVE(newp + bd.textcol + tabs + spaces, bd.textstart);\n    }\n    else // left\n    {\n\tcolnr_T\t    destination_col;\t// column to which text in block will\n\t\t\t\t\t// be shifted\n\tchar_u\t    *verbatim_copy_end;\t// end of the part of the line which is\n\t\t\t\t\t// copied verbatim\n\tcolnr_T\t    verbatim_copy_width;// the (displayed) width of this part\n\t\t\t\t\t// of line\n\tunsigned    fill;\t\t// nr of spaces that replace a TAB\n\tsize_t\t    block_space_width;\n\tsize_t\t    shift_amount;\n\tchar_u\t    *non_white = bd.textstart;\n\tcolnr_T\t    non_white_col;\n\tchartabsize_T cts;\n\n\t/*\n\t * Firstly, let's find the first non-whitespace character that is\n\t * displayed after the block's start column and the character's column\n\t * number. Also, let's calculate the width of all the whitespace\n\t * characters that are displayed in the block and precede the searched\n\t * non-whitespace character.\n\t */\n\n\t// If \"bd.startspaces\" is set, \"bd.textstart\" points to the character,\n\t// the part of which is displayed at the block's beginning. Let's start\n\t// searching from the next character.\n\tif (bd.startspaces)\n\t    MB_PTR_ADV(non_white);\n\n\t// The character's column is in \"bd.start_vcol\".\n\tnon_white_col = bd.start_vcol;\n\n\tinit_chartabsize_arg(&cts, curwin, curwin->w_cursor.lnum,\n\t\t\t\t   non_white_col, bd.textstart, non_white);\n\twhile (VIM_ISWHITE(*cts.cts_ptr))\n\t{\n\t    incr = lbr_chartabsize_adv(&cts);\n\t    cts.cts_vcol += incr;\n\t}\n\tnon_white_col = cts.cts_vcol;\n\tnon_white = cts.cts_ptr;\n\tclear_chartabsize_arg(&cts);\n\n\tblock_space_width = non_white_col - oap->start_vcol;\n\t// We will shift by \"total\" or \"block_space_width\", whichever is less.\n\tshift_amount = (block_space_width < (size_t)total\n\t\t\t\t\t ? block_space_width : (size_t)total);\n\n\t// The column to which we will shift the text.\n\tdestination_col = (colnr_T)(non_white_col - shift_amount);\n\n\t// Now let's find out how much of the beginning of the line we can\n\t// reuse without modification.\n\tverbatim_copy_end = bd.textstart;\n\tverbatim_copy_width = bd.start_vcol;\n\n\t// If \"bd.startspaces\" is set, \"bd.textstart\" points to the character\n\t// preceding the block. We have to subtract its width to obtain its\n\t// column number.\n\tif (bd.startspaces)\n\t    verbatim_copy_width -= bd.start_char_vcols;\n\tinit_chartabsize_arg(&cts, curwin, 0, verbatim_copy_width,\n\t\t\t\t\t     bd.textstart, verbatim_copy_end);\n\twhile (cts.cts_vcol < destination_col)\n\t{\n\t    incr = lbr_chartabsize(&cts);\n\t    if (cts.cts_vcol + incr > destination_col)\n\t\tbreak;\n\t    cts.cts_vcol += incr;\n\t    MB_PTR_ADV(cts.cts_ptr);\n\t}\n\tverbatim_copy_width = cts.cts_vcol;\n\tverbatim_copy_end = cts.cts_ptr;\n\tclear_chartabsize_arg(&cts);\n\n\t// If \"destination_col\" is different from the width of the initial\n\t// part of the line that will be copied, it means we encountered a tab\n\t// character, which we will have to partly replace with spaces.\n\tfill = destination_col - verbatim_copy_width;\n\n\t// The replacement line will consist of:\n\t// - the beginning of the original line up to \"verbatim_copy_end\",\n\t// - \"fill\" number of spaces,\n\t// - the rest of the line, pointed to by non_white.\n\tnew_line_len = (unsigned)(verbatim_copy_end - oldp)\n\t\t       + fill\n\t\t       + (unsigned)STRLEN(non_white);\n\n\tnewp = alloc(new_line_len + 1);\n\tif (newp == NULL)\n\t    return;\n\tmch_memmove(newp, oldp, (size_t)(verbatim_copy_end - oldp));\n\tvim_memset(newp + (verbatim_copy_end - oldp), ' ', (size_t)fill);\n\t// Note that STRMOVE() copies the trailing NUL.\n\tSTRMOVE(newp + (verbatim_copy_end - oldp) + fill, non_white);\n    }\n    // replace the line\n    added = new_line_len - (int)STRLEN(oldp);\n    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n    inserted_bytes(curwin->w_cursor.lnum, bd.textcol, added);\n    State = oldstate;\n    curwin->w_cursor.col = oldcol;\n#ifdef FEAT_RIGHTLEFT\n    p_ri = old_p_ri;\n#endif\n}\n\n/*\n * Insert string \"s\" (b_insert ? before : after) block :AKelly\n * Caller must prepare for undo.\n */\n    static void\nblock_insert(\n    oparg_T\t\t*oap,\n    char_u\t\t*s,\n    int\t\t\tb_insert,\n    struct block_def\t*bdp)\n{\n    int\t\tts_val;\n    int\t\tcount = 0;\t// extra spaces to replace a cut TAB\n    int\t\tspaces = 0;\t// non-zero if cutting a TAB\n    colnr_T\toffset;\t\t// pointer along new line\n    colnr_T\tstartcol;\t// column where insert starts\n    unsigned\ts_len;\t\t// STRLEN(s)\n    char_u\t*newp, *oldp;\t// new, old lines\n    linenr_T\tlnum;\t\t// loop var\n    int\t\toldstate = State;\n\n    State = MODE_INSERT;\t// don't want MODE_REPLACE for State\n    s_len = (unsigned)STRLEN(s);\n\n    for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)\n    {\n\tblock_prep(oap, bdp, lnum, TRUE);\n\tif (bdp->is_short && b_insert)\n\t    continue;\t// OP_INSERT, line ends before block start\n\n\toldp = ml_get(lnum);\n\n\tif (b_insert)\n\t{\n\t    ts_val = bdp->start_char_vcols;\n\t    spaces = bdp->startspaces;\n\t    if (spaces != 0)\n\t\tcount = ts_val - 1; // we're cutting a TAB\n\t    offset = bdp->textcol;\n\t}\n\telse // append\n\t{\n\t    ts_val = bdp->end_char_vcols;\n\t    if (!bdp->is_short) // spaces = padding after block\n\t    {\n\t\tspaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0);\n\t\tif (spaces != 0)\n\t\t    count = ts_val - 1; // we're cutting a TAB\n\t\toffset = bdp->textcol + bdp->textlen - (spaces != 0);\n\t    }\n\t    else // spaces = padding to block edge\n\t    {\n\t\t// if $ used, just append to EOL (ie spaces==0)\n\t\tif (!bdp->is_MAX)\n\t\t    spaces = (oap->end_vcol - bdp->end_vcol) + 1;\n\t\tcount = spaces;\n\t\toffset = bdp->textcol + bdp->textlen;\n\t    }\n\t}\n\n\tif (has_mbyte && spaces > 0)\n\t    // avoid copying part of a multi-byte character\n\t    offset -= (*mb_head_off)(oldp, oldp + offset);\n\n\tif (spaces < 0)  // can happen when the cursor was moved\n\t    spaces = 0;\n\n\t// Make sure the allocated size matches what is actually copied below.\n\tnewp = alloc(STRLEN(oldp) + spaces + s_len\n\t\t    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)\n\t\t\t\t\t\t\t\t  + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t// copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)offset);\n\toldp += offset;\n\n\t// insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t// copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces > 0 && !bdp->is_short)\n\t{\n\t    if (*oldp == TAB)\n\t    {\n\t\t// insert post-padding\n\t\tvim_memset(newp + offset + spaces, ' ',\n\t\t\t\t\t\t    (size_t)(ts_val - spaces));\n\t\t// we're splitting a TAB, don't copy it\n\t\toldp++;\n\t\t// We allowed for that TAB, remember this now\n\t\tcount++;\n\t    }\n\t    else\n\t\t// Not a TAB, no extra spaces\n\t\tcount = spaces;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);\n\n\tml_replace(lnum, newp, FALSE);\n\n\tif (b_insert)\n\t    // correct any text properties\n\t    inserted_bytes(lnum, startcol, s_len);\n\n\tif (lnum == oap->end.lnum)\n\t{\n\t    // Set \"']\" mark to the end of the block instead of the end of\n\t    // the insert in the first line.\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = offset;\n\t}\n    } // for all lnum\n\n    changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\n    State = oldstate;\n}\n\n/*\n * Handle a delete operation.\n *\n * Return FAIL if undo failed, OK otherwise.\n */\n    int\nop_delete(oparg_T *oap)\n{\n    int\t\t\tn;\n    linenr_T\t\tlnum;\n    char_u\t\t*ptr;\n    char_u\t\t*newp, *oldp;\n    struct block_def\tbd;\n    linenr_T\t\told_lcount = curbuf->b_ml.ml_line_count;\n    int\t\t\tdid_yank = FALSE;\n\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\t    // nothing to do\n\treturn OK;\n\n    // Nothing to delete, return here.\tDo prepare undo, for op_change().\n    if (oap->empty)\n\treturn u_save_cursor();\n\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn FAIL;\n    }\n\n    if (VIsual_select && oap->is_VIsual)\n\t// use register given with CTRL_R, defaults to zero\n\toap->regname = VIsual_select_reg;\n\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&oap->regname);\n#endif\n\n    if (has_mbyte)\n\tmb_adjust_opend(oap);\n\n    /*\n     * Imitate the strange Vi behaviour: If the delete spans more than one\n     * line and motion_type == MCHAR and the result is a blank line, make the\n     * delete linewise.  Don't do this for the change command or Visual mode.\n     */\n    if (       oap->motion_type == MCHAR\n\t    && !oap->is_VIsual\n\t    && !oap->block_mode\n\t    && oap->line_count > 1\n\t    && oap->motion_force == NUL\n\t    && oap->op_type == OP_DELETE)\n    {\n\tptr = ml_get(oap->end.lnum) + oap->end.col;\n\tif (*ptr != NUL)\n\t    ptr += oap->inclusive;\n\tptr = skipwhite(ptr);\n\tif (*ptr == NUL && inindent(0))\n\t    oap->motion_type = MLINE;\n    }\n\n    /*\n     * Check for trying to delete (e.g. \"D\") in an empty line.\n     * Note: For the change operator it is ok.\n     */\n    if (       oap->motion_type == MCHAR\n\t    && oap->line_count == 1\n\t    && oap->op_type == OP_DELETE\n\t    && *ml_get(oap->start.lnum) == NUL)\n    {\n\t/*\n\t * It's an error to operate on an empty region, when 'E' included in\n\t * 'cpoptions' (Vi compatible).\n\t */\n\tif (virtual_op)\n\t    // Virtual editing: Nothing gets deleted, but we set the '[ and ']\n\t    // marks as if it happened.\n\t    goto setmarks;\n\tif (vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL)\n\t    beep_flush();\n\treturn OK;\n    }\n\n    /*\n     * Do a yank of whatever we're about to delete.\n     * If a yank register was specified, put the deleted text into that\n     * register.  For the black hole register '_' don't yank anything.\n     */\n    if (oap->regname != '_')\n    {\n\tif (oap->regname != 0)\n\t{\n\t    // check for read-only register\n\t    if (!valid_yank_reg(oap->regname, TRUE))\n\t    {\n\t\tbeep_flush();\n\t\treturn OK;\n\t    }\n\t    get_yank_register(oap->regname, TRUE); // yank into specif'd reg.\n\t    if (op_yank(oap, TRUE, FALSE) == OK)   // yank without message\n\t\tdid_yank = TRUE;\n\t}\n\telse\n\t    reset_y_append(); // not appending to unnamed register\n\n\t/*\n\t * Put deleted text into register 1 and shift number registers if the\n\t * delete contains a line break, or when using a specific operator (Vi\n\t * compatible)\n\t */\n\tif (oap->motion_type == MLINE || oap->line_count > 1\n\t\t\t\t\t\t\t   || oap->use_reg_one)\n\t{\n\t    shift_delete_registers();\n\t    if (op_yank(oap, TRUE, FALSE) == OK)\n\t\tdid_yank = TRUE;\n\t}\n\n\t// Yank into small delete register when no named register specified\n\t// and the delete is within one line.\n\tif ((\n#ifdef FEAT_CLIPBOARD\n\t    ((clip_unnamed & CLIP_UNNAMED) && oap->regname == '*') ||\n\t    ((clip_unnamed & CLIP_UNNAMED_PLUS) && oap->regname == '+') ||\n#endif\n\t    oap->regname == 0) && oap->motion_type != MLINE\n\t\t\t\t\t\t      && oap->line_count == 1)\n\t{\n\t    oap->regname = '-';\n\t    get_yank_register(oap->regname, TRUE);\n\t    if (op_yank(oap, TRUE, FALSE) == OK)\n\t\tdid_yank = TRUE;\n\t    oap->regname = 0;\n\t}\n\n\t/*\n\t * If there's too much stuff to fit in the yank register, then get a\n\t * confirmation before doing the delete. This is crude, but simple.\n\t * And it avoids doing a delete of something we can't put back if we\n\t * want.\n\t */\n\tif (!did_yank)\n\t{\n\t    int msg_silent_save = msg_silent;\n\n\t    msg_silent = 0;\t// must display the prompt\n\t    n = ask_yesno((char_u *)_(\"cannot yank; delete anyway\"), TRUE);\n\t    msg_silent = msg_silent_save;\n\t    if (n != 'y')\n\t    {\n\t\temsg(_(e_command_aborted));\n\t\treturn FAIL;\n\t    }\n\t}\n\n#if defined(FEAT_EVAL)\n\tif (did_yank && has_textyankpost())\n\t    yank_do_autocmd(oap, get_y_current());\n#endif\n    }\n\n    /*\n     * block mode delete\n     */\n    if (oap->block_mode)\n    {\n\tif (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t    return FAIL;\n\n\tfor (lnum = curwin->w_cursor.lnum; lnum <= oap->end.lnum; ++lnum)\n\t{\n\t    block_prep(oap, &bd, lnum, TRUE);\n\t    if (bd.textlen == 0)\t// nothing to delete\n\t\tcontinue;\n\n\t    // Adjust cursor position for tab replaced by spaces and 'lbr'.\n\t    if (lnum == curwin->w_cursor.lnum)\n\t    {\n\t\tcurwin->w_cursor.col = bd.textcol + bd.startspaces;\n\t\tcurwin->w_cursor.coladd = 0;\n\t    }\n\n\t    // \"n\" == number of chars deleted\n\t    // If we delete a TAB, it may be replaced by several characters.\n\t    // Thus the number of characters may increase!\n\t    n = bd.textlen - bd.startspaces - bd.endspaces;\n\t    oldp = ml_get(lnum);\n\t    newp = alloc(STRLEN(oldp) + 1 - n);\n\t    if (newp == NULL)\n\t\tcontinue;\n\t    // copy up to deleted part\n\t    mch_memmove(newp, oldp, (size_t)bd.textcol);\n\t    // insert spaces\n\t    vim_memset(newp + bd.textcol, ' ',\n\t\t\t\t     (size_t)(bd.startspaces + bd.endspaces));\n\t    // copy the part after the deleted part\n\t    oldp += bd.textcol + bd.textlen;\n\t    STRMOVE(newp + bd.textcol + bd.startspaces + bd.endspaces, oldp);\n\t    // replace the line\n\t    ml_replace(lnum, newp, FALSE);\n\n#ifdef FEAT_PROP_POPUP\n\t    if (curbuf->b_has_textprop && n != 0)\n\t\tadjust_prop_columns(lnum, bd.textcol, -n, 0);\n#endif\n\t}\n\n\tcheck_cursor_col();\n\tchanged_lines(curwin->w_cursor.lnum, curwin->w_cursor.col,\n\t\t\t\t\t\t       oap->end.lnum + 1, 0L);\n\toap->line_count = 0;\t    // no lines deleted\n    }\n    else if (oap->motion_type == MLINE)\n    {\n\tif (oap->op_type == OP_CHANGE)\n\t{\n\t    // Delete the lines except the first one.  Temporarily move the\n\t    // cursor to the next line.  Save the current line number, if the\n\t    // last line is deleted it may be changed.\n\t    if (oap->line_count > 1)\n\t    {\n\t\tlnum = curwin->w_cursor.lnum;\n\t\t++curwin->w_cursor.lnum;\n\t\tdel_lines((long)(oap->line_count - 1), TRUE);\n\t\tcurwin->w_cursor.lnum = lnum;\n\t    }\n\t    if (u_save_cursor() == FAIL)\n\t\treturn FAIL;\n\t    if (curbuf->b_p_ai)\t\t    // don't delete indent\n\t    {\n\t\tbeginline(BL_WHITE);\t    // cursor on first non-white\n\t\tdid_ai = TRUE;\t\t    // delete the indent when ESC hit\n\t\tai_col = curwin->w_cursor.col;\n\t    }\n\t    else\n\t\tbeginline(0);\t\t    // cursor in column 0\n\t    truncate_line(FALSE);   // delete the rest of the line\n\t\t\t\t    // leave cursor past last char in line\n\t    if (oap->line_count > 1)\n\t\tu_clearline();\t    // \"U\" command not possible after \"2cc\"\n\t}\n\telse\n\t{\n\t    del_lines(oap->line_count, TRUE);\n\t    beginline(BL_WHITE | BL_FIX);\n\t    u_clearline();\t// \"U\" command not possible after \"dd\"\n\t}\n    }\n    else\n    {\n\tif (virtual_op)\n\t{\n\t    int\t\tendcol = 0;\n\n\t    // For virtualedit: break the tabs that are partly included.\n\t    if (gchar_pos(&oap->start) == '\\t')\n\t    {\n\t\tif (u_save_cursor() == FAIL)\t// save first line for undo\n\t\t    return FAIL;\n\t\tif (oap->line_count == 1)\n\t\t    endcol = getviscol2(oap->end.col, oap->end.coladd);\n\t\tcoladvance_force(getviscol2(oap->start.col, oap->start.coladd));\n\t\toap->start = curwin->w_cursor;\n\t\tif (oap->line_count == 1)\n\t\t{\n\t\t    coladvance(endcol);\n\t\t    oap->end.col = curwin->w_cursor.col;\n\t\t    oap->end.coladd = curwin->w_cursor.coladd;\n\t\t    curwin->w_cursor = oap->start;\n\t\t}\n\t    }\n\n\t    // Break a tab only when it's included in the area.\n\t    if (gchar_pos(&oap->end) == '\\t'\n\t\t\t\t     && (int)oap->end.coladd < oap->inclusive)\n\t    {\n\t\t// save last line for undo\n\t\tif (u_save((linenr_T)(oap->end.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t\t    return FAIL;\n\t\tcurwin->w_cursor = oap->end;\n\t\tcoladvance_force(getviscol2(oap->end.col, oap->end.coladd));\n\t\toap->end = curwin->w_cursor;\n\t\tcurwin->w_cursor = oap->start;\n\t    }\n\t    if (has_mbyte)\n\t\tmb_adjust_opend(oap);\n\t}\n\n\tif (oap->line_count == 1)\t// delete characters within one line\n\t{\n\t    if (u_save_cursor() == FAIL)\t// save line for undo\n\t\treturn FAIL;\n\n\t    // if 'cpoptions' contains '$', display '$' at end of change\n\t    if (       vim_strchr(p_cpo, CPO_DOLLAR) != NULL\n\t\t    && oap->op_type == OP_CHANGE\n\t\t    && oap->end.lnum == curwin->w_cursor.lnum\n\t\t    && !oap->is_VIsual)\n\t\tdisplay_dollar(oap->end.col - !oap->inclusive);\n\n\t    n = oap->end.col - oap->start.col + 1 - !oap->inclusive;\n\n\t    if (virtual_op)\n\t    {\n\t\t// fix up things for virtualedit-delete:\n\t\t// break the tabs which are going to get in our way\n\t\tchar_u\t\t*curline = ml_get_curline();\n\t\tint\t\tlen = (int)STRLEN(curline);\n\n\t\tif (oap->end.coladd != 0\n\t\t\t&& (int)oap->end.col >= len - 1\n\t\t\t&& !(oap->start.coladd && (int)oap->end.col >= len - 1))\n\t\t    n++;\n\t\t// Delete at least one char (e.g, when on a control char).\n\t\tif (n == 0 && oap->start.coladd != oap->end.coladd)\n\t\t    n = 1;\n\n\t\t// When deleted a char in the line, reset coladd.\n\t\tif (gchar_cursor() != NUL)\n\t\t    curwin->w_cursor.coladd = 0;\n\t    }\n\t    (void)del_bytes((long)n, !virtual_op,\n\t\t\t    oap->op_type == OP_DELETE && !oap->is_VIsual);\n\t}\n\telse\t\t\t\t// delete characters between lines\n\t{\n\t    pos_T   curpos;\n\n\t    // save deleted and changed lines for undo\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t (linenr_T)(curwin->w_cursor.lnum + oap->line_count)) == FAIL)\n\t\treturn FAIL;\n\n\t    truncate_line(TRUE);\t// delete from cursor to end of line\n\n\t    curpos = curwin->w_cursor;\t// remember curwin->w_cursor\n\t    ++curwin->w_cursor.lnum;\n\t    del_lines((long)(oap->line_count - 2), FALSE);\n\n\t    // delete from start of line until op_end\n\t    n = (oap->end.col + 1 - !oap->inclusive);\n\t    curwin->w_cursor.col = 0;\n\t    (void)del_bytes((long)n, !virtual_op,\n\t\t\t    oap->op_type == OP_DELETE && !oap->is_VIsual);\n\t    curwin->w_cursor = curpos;\t// restore curwin->w_cursor\n\t    (void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t}\n\tif (oap->op_type == OP_DELETE)\n\t    auto_format(FALSE, TRUE);\n    }\n\n    msgmore(curbuf->b_ml.ml_line_count - old_lcount);\n\nsetmarks:\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tif (oap->block_mode)\n\t{\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = oap->start.col;\n\t}\n\telse\n\t    curbuf->b_op_end = oap->start;\n\tcurbuf->b_op_start = oap->start;\n    }\n\n    return OK;\n}\n\n/*\n * Adjust end of operating area for ending on a multi-byte character.\n * Used for deletion.\n */\n    static void\nmb_adjust_opend(oparg_T *oap)\n{\n    char_u\t*p;\n\n    if (oap->inclusive)\n    {\n\tp = ml_get(oap->end.lnum);\n\toap->end.col += mb_tail_off(p, p + oap->end.col);\n    }\n}\n\n/*\n * Replace the character under the cursor with \"c\".\n * This takes care of multi-byte characters.\n */\n    static void\nreplace_character(int c)\n{\n    int n = State;\n\n    State = MODE_REPLACE;\n    ins_char(c);\n    State = n;\n    // Backup to the replaced character.\n    dec_cursor();\n}\n\n/*\n * Replace a whole area with one character.\n */\n    int\nop_replace(oparg_T *oap, int c)\n{\n    int\t\t\tn, numc;\n    int\t\t\tnum_chars;\n    char_u\t\t*newp, *oldp;\n    size_t\t\toldlen;\n    struct block_def\tbd;\n    char_u\t\t*after_p = NULL;\n    int\t\t\thad_ctrl_v_cr = FALSE;\n\n    if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)\n\treturn OK;\t    // nothing to do\n\n    if (c == REPLACE_CR_NCHAR)\n    {\n\thad_ctrl_v_cr = TRUE;\n\tc = CAR;\n    }\n    else if (c == REPLACE_NL_NCHAR)\n    {\n\thad_ctrl_v_cr = TRUE;\n\tc = NL;\n    }\n\n    if (has_mbyte)\n\tmb_adjust_opend(oap);\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn FAIL;\n\n    /*\n     * block mode replace\n     */\n    if (oap->block_mode)\n    {\n\tbd.is_MAX = (curwin->w_curswant == MAXCOL);\n\tfor ( ; curwin->w_cursor.lnum <= oap->end.lnum; ++curwin->w_cursor.lnum)\n\t{\n\t    curwin->w_cursor.col = 0;  // make sure cursor position is valid\n\t    block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);\n\t    if (bd.textlen == 0 && (!virtual_op || bd.is_MAX))\n\t\tcontinue;\t    // nothing to replace\n\n\t    // n == number of extra chars required\n\t    // If we split a TAB, it may be replaced by several characters.\n\t    // Thus the number of characters may increase!\n\t    // If the range starts in virtual space, count the initial\n\t    // coladd offset as part of \"startspaces\"\n\t    if (virtual_op && bd.is_short && *bd.textstart == NUL)\n\t    {\n\t\tpos_T vpos;\n\n\t\tvpos.lnum = curwin->w_cursor.lnum;\n\t\tgetvpos(&vpos, oap->start_vcol);\n\t\tbd.startspaces += vpos.coladd;\n\t\tn = bd.startspaces;\n\t    }\n\t    else\n\t\t// allow for pre spaces\n\t\tn = (bd.startspaces ? bd.start_char_vcols - 1 : 0);\n\n\t    // allow for post spp\n\t    n += (bd.endspaces\n\t\t    && !bd.is_oneChar\n\t\t    && bd.end_char_vcols > 0) ? bd.end_char_vcols - 1 : 0;\n\t    // Figure out how many characters to replace.\n\t    numc = oap->end_vcol - oap->start_vcol + 1;\n\t    if (bd.is_short && (!virtual_op || bd.is_MAX))\n\t\tnumc -= (oap->end_vcol - bd.end_vcol) + 1;\n\n\t    // A double-wide character can be replaced only up to half the\n\t    // times.\n\t    if ((*mb_char2cells)(c) > 1)\n\t    {\n\t\tif ((numc & 1) && !bd.is_short)\n\t\t{\n\t\t    ++bd.endspaces;\n\t\t    ++n;\n\t\t}\n\t\tnumc = numc / 2;\n\t    }\n\n\t    // Compute bytes needed, move character count to num_chars.\n\t    num_chars = numc;\n\t    numc *= (*mb_char2len)(c);\n\t    // oldlen includes textlen, so don't double count\n\t    n += numc - bd.textlen;\n\n\t    oldp = ml_get_curline();\n\t    oldlen = STRLEN(oldp);\n\t    newp = alloc(oldlen + 1 + n);\n\t    if (newp == NULL)\n\t\tcontinue;\n\t    vim_memset(newp, NUL, (size_t)(oldlen + 1 + n));\n\t    // copy up to deleted part\n\t    mch_memmove(newp, oldp, (size_t)bd.textcol);\n\t    oldp += bd.textcol + bd.textlen;\n\t    // insert pre-spaces\n\t    vim_memset(newp + bd.textcol, ' ', (size_t)bd.startspaces);\n\t    // insert replacement chars CHECK FOR ALLOCATED SPACE\n\t    // REPLACE_CR_NCHAR/REPLACE_NL_NCHAR is used for entering CR\n\t    // literally.\n\t    if (had_ctrl_v_cr || (c != '\\r' && c != '\\n'))\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = (int)STRLEN(newp);\n\t\t    while (--num_chars >= 0)\n\t\t\tn += (*mb_char2bytes)(c, newp + n);\n\t\t}\n\t\telse\n\t\t    vim_memset(newp + STRLEN(newp), c, (size_t)numc);\n\t\tif (!bd.is_short)\n\t\t{\n\t\t    // insert post-spaces\n\t\t    vim_memset(newp + STRLEN(newp), ' ', (size_t)bd.endspaces);\n\t\t    // copy the part after the changed part\n\t\t    STRMOVE(newp + STRLEN(newp), oldp);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Replacing with \\r or \\n means splitting the line.\n\t\tafter_p = alloc(oldlen + 1 + n - STRLEN(newp));\n\t\tif (after_p != NULL)\n\t\t    STRMOVE(after_p, oldp);\n\t    }\n\t    // replace the line\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\t    if (after_p != NULL)\n\t    {\n\t\tml_append(curwin->w_cursor.lnum++, after_p, 0, FALSE);\n\t\tappended_lines_mark(curwin->w_cursor.lnum, 1L);\n\t\toap->end.lnum++;\n\t\tvim_free(after_p);\n\t    }\n\t}\n    }\n    else\n    {\n\t/*\n\t * MCHAR and MLINE motion replace.\n\t */\n\tif (oap->motion_type == MLINE)\n\t{\n\t    oap->start.col = 0;\n\t    curwin->w_cursor.col = 0;\n\t    oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t    if (oap->end.col)\n\t\t--oap->end.col;\n\t}\n\telse if (!oap->inclusive)\n\t    dec(&(oap->end));\n\n\twhile (LTOREQ_POS(curwin->w_cursor, oap->end))\n\t{\n\t    int done = FALSE;\n\n\t    n = gchar_cursor();\n\t    if (n != NUL)\n\t    {\n\t\tint new_byte_len = (*mb_char2len)(c);\n\t\tint old_byte_len = mb_ptr2len(ml_get_cursor());\n\n\t\tif (new_byte_len > 1 || old_byte_len > 1)\n\t\t{\n\t\t    // This is slow, but it handles replacing a single-byte\n\t\t    // with a multi-byte and the other way around.\n\t\t    if (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\toap->end.col += new_byte_len - old_byte_len;\n\t\t    replace_character(c);\n\t\t    done = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (n == TAB)\n\t\t    {\n\t\t\tint end_vcol = 0;\n\n\t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\t{\n\t\t\t    // oap->end has to be recalculated when\n\t\t\t    // the tab breaks\n\t\t\t    end_vcol = getviscol2(oap->end.col,\n\t\t\t\t\t\t\t     oap->end.coladd);\n\t\t\t}\n\t\t\tcoladvance_force(getviscol());\n\t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\t    getvpos(&oap->end, end_vcol);\n\t\t    }\n\t\t    // with \"coladd\" set may move to just after a TAB\n\t\t    if (gchar_cursor() != NUL)\n\t\t    {\n\t\t\tPBYTE(curwin->w_cursor, c);\n\t\t\tdone = TRUE;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!done && virtual_op && curwin->w_cursor.lnum == oap->end.lnum)\n\t    {\n\t\tint virtcols = oap->end.coladd;\n\n\t\tif (curwin->w_cursor.lnum == oap->start.lnum\n\t\t\t&& oap->start.col == oap->end.col && oap->start.coladd)\n\t\t    virtcols -= oap->start.coladd;\n\n\t\t// oap->end has been trimmed so it's effectively inclusive;\n\t\t// as a result an extra +1 must be counted so we don't\n\t\t// trample the NUL byte.\n\t\tcoladvance_force(getviscol2(oap->end.col, oap->end.coladd) + 1);\n\t\tcurwin->w_cursor.col -= (virtcols + 1);\n\t\tfor (; virtcols >= 0; virtcols--)\n\t\t{\n\t\t    if ((*mb_char2len)(c) > 1)\n\t\t       replace_character(c);\n\t\t    else\n\t\t\tPBYTE(curwin->w_cursor, c);\n\t\t   if (inc(&curwin->w_cursor) == -1)\n\t\t       break;\n\t\t}\n\t    }\n\n\t    // Advance to next character, stop at the end of the file.\n\t    if (inc_cursor() == -1)\n\t\tbreak;\n\t}\n    }\n\n    curwin->w_cursor = oap->start;\n    check_cursor();\n    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1, 0L);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n\n    return OK;\n}\n\nstatic int swapchars(int op_type, pos_T *pos, int length);\n\n/*\n * Handle the (non-standard vi) tilde operator.  Also for \"gu\", \"gU\" and \"g?\".\n */\n    static void\nop_tilde(oparg_T *oap)\n{\n    pos_T\t\tpos;\n    struct block_def\tbd;\n    int\t\t\tdid_change = FALSE;\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n\n    pos = oap->start;\n    if (oap->block_mode)\t\t    // Visual block mode\n    {\n\tfor (; pos.lnum <= oap->end.lnum; ++pos.lnum)\n\t{\n\t    int one_change;\n\n\t    block_prep(oap, &bd, pos.lnum, FALSE);\n\t    pos.col = bd.textcol;\n\t    one_change = swapchars(oap->op_type, &pos, bd.textlen);\n\t    did_change |= one_change;\n\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active() && one_change)\n\t    {\n\t\tchar_u *ptr;\n\n\t\tnetbeans_removed(curbuf, pos.lnum, bd.textcol,\n\t\t\t\t\t\t\t    (long)bd.textlen);\n\t\t// get the line now, it may have been flushed\n\t\tptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\tnetbeans_inserted(curbuf, pos.lnum, bd.textcol,\n\t\t\t\t\t\t&ptr[bd.textcol], bd.textlen);\n\t    }\n#endif\n\t}\n\tif (did_change)\n\t    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);\n    }\n    else\t\t\t\t    // not block mode\n    {\n\tif (oap->motion_type == MLINE)\n\t{\n\t    oap->start.col = 0;\n\t    pos.col = 0;\n\t    oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t    if (oap->end.col)\n\t\t--oap->end.col;\n\t}\n\telse if (!oap->inclusive)\n\t    dec(&(oap->end));\n\n\tif (pos.lnum == oap->end.lnum)\n\t    did_change = swapchars(oap->op_type, &pos,\n\t\t\t\t\t\t  oap->end.col - pos.col + 1);\n\telse\n\t    for (;;)\n\t    {\n\t\tdid_change |= swapchars(oap->op_type, &pos,\n\t\t\t\tpos.lnum == oap->end.lnum ? oap->end.col + 1:\n\t\t\t\t\t   (int)STRLEN(ml_get_pos(&pos)));\n\t\tif (LTOREQ_POS(oap->end, pos) || inc(&pos) == -1)\n\t\t    break;\n\t    }\n\tif (did_change)\n\t{\n\t    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tchar_u *ptr;\n\t\tint count;\n\n\t\tpos = oap->start;\n\t\twhile (pos.lnum < oap->end.lnum)\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\t    count = (int)STRLEN(ptr) - pos.col;\n\t\t    netbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\t\t    // get the line again, it may have been flushed\n\t\t    ptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\t    netbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n\t\tcount = oap->end.col - pos.col + 1;\n\t\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\t\t// get the line again, it may have been flushed\n\t\tptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t    }\n#endif\n\t}\n    }\n\n    if (!did_change && oap->is_VIsual)\n\t// No change: need to remove the Visual selection\n\tredraw_curbuf_later(UPD_INVERTED);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set '[ and '] marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n\n    if (oap->line_count > p_report)\n\tsmsg(NGETTEXT(\"%ld line changed\", \"%ld lines changed\",\n\t\t\t\t\t    oap->line_count), oap->line_count);\n}\n\n/*\n * Invoke swapchar() on \"length\" bytes at position \"pos\".\n * \"pos\" is advanced to just after the changed characters.\n * \"length\" is rounded up to include the whole last multi-byte character.\n * Also works correctly when the number of bytes changes.\n * Returns TRUE if some character was changed.\n */\n    static int\nswapchars(int op_type, pos_T *pos, int length)\n{\n    int todo;\n    int\tdid_change = 0;\n\n    for (todo = length; todo > 0; --todo)\n    {\n\tif (has_mbyte)\n\t{\n\t    int len = (*mb_ptr2len)(ml_get_pos(pos));\n\n\t    // we're counting bytes, not characters\n\t    if (len > 0)\n\t\ttodo -= len - 1;\n\t}\n\tdid_change |= swapchar(op_type, pos);\n\tif (inc(pos) == -1)    // at end of file\n\t    break;\n    }\n    return did_change;\n}\n\n/*\n * If op_type == OP_UPPER: make uppercase,\n * if op_type == OP_LOWER: make lowercase,\n * if op_type == OP_ROT13: do rot13 encoding,\n * else swap case of character at 'pos'\n * returns TRUE when something actually changed.\n */\n    int\nswapchar(int op_type, pos_T *pos)\n{\n    int\t    c;\n    int\t    nc;\n\n    c = gchar_pos(pos);\n\n    // Only do rot13 encoding for ASCII characters.\n    if (c >= 0x80 && op_type == OP_ROT13)\n\treturn FALSE;\n\n    if (op_type == OP_UPPER && c == 0xdf\n\t\t      && (enc_latin1like || STRCMP(p_enc, \"iso-8859-2\") == 0))\n    {\n\tpos_T   sp = curwin->w_cursor;\n\n\t// Special handling of German sharp s: change to \"SS\".\n\tcurwin->w_cursor = *pos;\n\tdel_char(FALSE);\n\tins_char('S');\n\tins_char('S');\n\tcurwin->w_cursor = sp;\n\tinc(pos);\n    }\n\n    if (enc_dbcs != 0 && c >= 0x100)\t// No lower/uppercase letter\n\treturn FALSE;\n    nc = c;\n    if (MB_ISLOWER(c))\n    {\n\tif (op_type == OP_ROT13)\n\t    nc = ROT13(c, 'a');\n\telse if (op_type != OP_LOWER)\n\t    nc = MB_TOUPPER(c);\n    }\n    else if (MB_ISUPPER(c))\n    {\n\tif (op_type == OP_ROT13)\n\t    nc = ROT13(c, 'A');\n\telse if (op_type != OP_UPPER)\n\t    nc = MB_TOLOWER(c);\n    }\n    if (nc != c)\n    {\n\tif (enc_utf8 && (c >= 0x80 || nc >= 0x80))\n\t{\n\t    pos_T   sp = curwin->w_cursor;\n\n\t    curwin->w_cursor = *pos;\n\t    // don't use del_char(), it also removes composing chars\n\t    del_bytes(utf_ptr2len(ml_get_cursor()), FALSE, FALSE);\n\t    ins_char(nc);\n\t    curwin->w_cursor = sp;\n\t}\n\telse\n\t    PBYTE(*pos, nc);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * op_insert - Insert and append operators for Visual mode.\n */\n    void\nop_insert(oparg_T *oap, long count1)\n{\n    long\t\tins_len, pre_textlen = 0;\n    char_u\t\t*firstline, *ins_text;\n    colnr_T\t\tind_pre_col = 0, ind_post_col;\n    int\t\t\tind_pre_vcol = 0, ind_post_vcol = 0;\n    struct block_def\tbd;\n    int\t\t\ti;\n    pos_T\t\tt1;\n    pos_T\t\tstart_insert;\n\t\t\t// offset when cursor was moved in insert mode\n    int\t\t\toffset = 0;\n\n    // edit() changes this - record it for OP_APPEND\n    bd.is_MAX = (curwin->w_curswant == MAXCOL);\n\n    // vis block is still marked. Get rid of it now.\n    curwin->w_cursor.lnum = oap->start.lnum;\n    update_screen(UPD_INVERTED);\n\n    if (oap->block_mode)\n    {\n\t// When 'virtualedit' is used, need to insert the extra spaces before\n\t// doing block_prep().  When only \"block\" is used, virtual edit is\n\t// already disabled, but still need it when calling\n\t// coladvance_force().\n\t// coladvance_force() uses get_ve_flags() to get the 'virtualedit'\n\t// state for the current window.  To override that state, we need to\n\t// set the window-local value of ve_flags rather than the global value.\n\tif (curwin->w_cursor.coladd > 0)\n\t{\n\t    int\t\told_ve_flags = curwin->w_ve_flags;\n\n\t    if (u_save_cursor() == FAIL)\n\t\treturn;\n\n\t    curwin->w_ve_flags = VE_ALL;\n\t    coladvance_force(oap->op_type == OP_APPEND\n\t\t\t\t\t   ? oap->end_vcol + 1 : getviscol());\n\t    if (oap->op_type == OP_APPEND)\n\t\t--curwin->w_cursor.col;\n\t    curwin->w_ve_flags = old_ve_flags;\n\t}\n\t// Get the info about the block before entering the text\n\tblock_prep(oap, &bd, oap->start.lnum, TRUE);\n\t// Get indent information\n\tind_pre_col = (colnr_T)getwhitecols_curline();\n\tind_pre_vcol = get_indent();\n\tfirstline = ml_get(oap->start.lnum) + bd.textcol;\n\n\tif (oap->op_type == OP_APPEND)\n\t    firstline += bd.textlen;\n\tpre_textlen = (long)STRLEN(firstline);\n    }\n\n    if (oap->op_type == OP_APPEND)\n    {\n\tif (oap->block_mode && curwin->w_cursor.coladd == 0)\n\t{\n\t    // Move the cursor to the character right of the block.\n\t    curwin->w_set_curswant = TRUE;\n\t    while (*ml_get_cursor() != NUL\n\t\t    && (curwin->w_cursor.col < bd.textcol + bd.textlen))\n\t\t++curwin->w_cursor.col;\n\t    if (bd.is_short && !bd.is_MAX)\n\t    {\n\t\t// First line was too short, make it longer and adjust the\n\t\t// values in \"bd\".\n\t\tif (u_save_cursor() == FAIL)\n\t\t    return;\n\t\tfor (i = 0; i < bd.endspaces; ++i)\n\t\t    ins_char(' ');\n\t\tbd.textlen += bd.endspaces;\n\t    }\n\t}\n\telse\n\t{\n\t    curwin->w_cursor = oap->end;\n\t    check_cursor_col();\n\n\t    // Works just like an 'i'nsert on the next character.\n\t    if (!LINEEMPTY(curwin->w_cursor.lnum)\n\t\t    && oap->start_vcol != oap->end_vcol)\n\t\tinc_cursor();\n\t}\n    }\n\n    t1 = oap->start;\n    start_insert = curwin->w_cursor;\n    (void)edit(NUL, FALSE, (linenr_T)count1);\n\n    // When a tab was inserted, and the characters in front of the tab\n    // have been converted to a tab as well, the column of the cursor\n    // might have actually been reduced, so need to adjust here.\n    if (t1.lnum == curbuf->b_op_start_orig.lnum\n\t    && LT_POS(curbuf->b_op_start_orig, t1))\n\toap->start = curbuf->b_op_start_orig;\n\n    // If user has moved off this line, we don't know what to do, so do\n    // nothing.\n    // Also don't repeat the insert when Insert mode ended with CTRL-C.\n    if (curwin->w_cursor.lnum != oap->start.lnum || got_int)\n\treturn;\n\n    if (oap->block_mode)\n    {\n\tstruct block_def\tbd2;\n\tint\t\t\tdid_indent = FALSE;\n\tsize_t\t\t\tlen;\n\tint\t\t\tadd;\n\n\t// If indent kicked in, the firstline might have changed\n\t// but only do that, if the indent actually increased.\n\tind_post_col = (colnr_T)getwhitecols_curline();\n\tif (curbuf->b_op_start.col > ind_pre_col && ind_post_col > ind_pre_col)\n\t{\n\t    bd.textcol += ind_post_col - ind_pre_col;\n\t    ind_post_vcol = get_indent();\n\t    bd.start_vcol += ind_post_vcol - ind_pre_vcol;\n\t    did_indent = TRUE;\n\t}\n\n\t// The user may have moved the cursor before inserting something, try\n\t// to adjust the block for that.  But only do it, if the difference\n\t// does not come from indent kicking in.\n\tif (oap->start.lnum == curbuf->b_op_start_orig.lnum\n\t\t\t\t\t\t  && !bd.is_MAX && !did_indent)\n\t{\n\t    int t = getviscol2(curbuf->b_op_start_orig.col,\n\t\t\t\t\t       curbuf->b_op_start_orig.coladd);\n\n\t    if (oap->op_type == OP_INSERT\n\t\t    && oap->start.col + oap->start.coladd\n\t\t\t    != curbuf->b_op_start_orig.col\n\t\t\t\t\t      + curbuf->b_op_start_orig.coladd)\n\t    {\n\t\toap->start.col = curbuf->b_op_start_orig.col;\n\t\tpre_textlen -= t - oap->start_vcol;\n\t\toap->start_vcol = t;\n\t    }\n\t    else if (oap->op_type == OP_APPEND\n\t\t    && oap->start.col + oap->start.coladd\n\t\t\t    >= curbuf->b_op_start_orig.col\n\t\t\t\t\t      + curbuf->b_op_start_orig.coladd)\n\t    {\n\t\toap->start.col = curbuf->b_op_start_orig.col;\n\t\t// reset pre_textlen to the value of OP_INSERT\n\t\tpre_textlen += bd.textlen;\n\t\tpre_textlen -= t - oap->start_vcol;\n\t\toap->start_vcol = t;\n\t\toap->op_type = OP_INSERT;\n\t    }\n\t}\n\n\t// Spaces and tabs in the indent may have changed to other spaces and\n\t// tabs.  Get the starting column again and correct the length.\n\t// Don't do this when \"$\" used, end-of-line will have changed.\n\t//\n\t// if indent was added and the inserted text was after the indent,\n\t// correct the selection for the new indent.\n\tif (did_indent && bd.textcol - ind_post_col > 0)\n\t{\n\t    oap->start.col += ind_post_col - ind_pre_col;\n\t    oap->start_vcol += ind_post_vcol - ind_pre_vcol;\n\t    oap->end.col += ind_post_col - ind_pre_col;\n\t    oap->end_vcol += ind_post_vcol - ind_pre_vcol;\n\t}\n\tblock_prep(oap, &bd2, oap->start.lnum, TRUE);\n\tif (did_indent && bd.textcol - ind_post_col > 0)\n\t{\n\t    // undo for where \"oap\" is used below\n\t    oap->start.col -= ind_post_col - ind_pre_col;\n\t    oap->start_vcol -= ind_post_vcol - ind_pre_vcol;\n\t    oap->end.col -= ind_post_col - ind_pre_col;\n\t    oap->end_vcol -= ind_post_vcol - ind_pre_vcol;\n\t}\n\tif (!bd.is_MAX || bd2.textlen < bd.textlen)\n\t{\n\t    if (oap->op_type == OP_APPEND)\n\t    {\n\t\tpre_textlen += bd2.textlen - bd.textlen;\n\t\tif (bd2.endspaces)\n\t\t    --bd2.textlen;\n\t    }\n\t    bd.textcol = bd2.textcol;\n\t    bd.textlen = bd2.textlen;\n\t}\n\n\t/*\n\t * Subsequent calls to ml_get() flush the firstline data - take a\n\t * copy of the required string.\n\t */\n\tfirstline = ml_get(oap->start.lnum);\n\tlen = STRLEN(firstline);\n\tadd = bd.textcol;\n\tif (oap->op_type == OP_APPEND)\n\t{\n\t    add += bd.textlen;\n\t    // account for pressing cursor in insert mode when '$' was used\n\t    if (bd.is_MAX\n\t\t&& (start_insert.lnum == Insstart.lnum\n\t\t\t\t\t   && start_insert.col > Insstart.col))\n\t    {\n\t\toffset = (start_insert.col - Insstart.col);\n\t\tadd -= offset;\n\t\tif (oap->end_vcol > offset)\n\t\t    oap->end_vcol -= (offset + 1);\n\t\telse\n\t\t    // moved outside of the visual block, what to do?\n\t\t    return;\n\t    }\n\t}\n\tif ((size_t)add > len)\n\t    firstline += len;  // short line, point to the NUL\n\telse\n\t    firstline += add;\n\tif (pre_textlen >= 0 && (ins_len =\n\t\t\t   (long)STRLEN(firstline) - pre_textlen - offset) > 0)\n\t{\n\t    ins_text = vim_strnsave(firstline, ins_len);\n\t    if (ins_text != NULL)\n\t    {\n\t\t// block handled here\n\t\tif (u_save(oap->start.lnum,\n\t\t\t\t\t (linenr_T)(oap->end.lnum + 1)) == OK)\n\t\t    block_insert(oap, ins_text, (oap->op_type == OP_INSERT),\n\t\t\t\t\t\t\t\t\t &bd);\n\n\t\tcurwin->w_cursor.col = oap->start.col;\n\t\tcheck_cursor();\n\t\tvim_free(ins_text);\n\t    }\n\t}\n    }\n}\n\n/*\n * op_change - handle a change operation\n *\n * return TRUE if edit() returns because of a CTRL-O command\n */\n    int\nop_change(oparg_T *oap)\n{\n    colnr_T\t\tl;\n    int\t\t\tretval;\n    long\t\toffset;\n    linenr_T\t\tlinenr;\n    long\t\tins_len;\n    long\t\tpre_textlen = 0;\n    long\t\tpre_indent = 0;\n    char_u\t\t*firstline;\n    char_u\t\t*ins_text, *newp, *oldp;\n    struct block_def\tbd;\n\n    l = oap->start.col;\n    if (oap->motion_type == MLINE)\n    {\n\tl = 0;\n\tcan_si = may_do_si();\t// Like opening a new line, do smart indent\n    }\n\n    // First delete the text in the region.  In an empty buffer only need to\n    // save for undo\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return FALSE;\n    }\n    else if (op_delete(oap) == FAIL)\n\treturn FALSE;\n\n    if ((l > curwin->w_cursor.col) && !LINEEMPTY(curwin->w_cursor.lnum)\n\t\t\t\t\t\t\t && !virtual_op)\n\tinc_cursor();\n\n    // check for still on same line (<CR> in inserted text meaningless)\n    // skip blank lines too\n    if (oap->block_mode)\n    {\n\t// Add spaces before getting the current line length.\n\tif (virtual_op && (curwin->w_cursor.coladd > 0\n\t\t\t\t\t\t    || gchar_cursor() == NUL))\n\t    coladvance_force(getviscol());\n\tfirstline = ml_get(oap->start.lnum);\n\tpre_textlen = (long)STRLEN(firstline);\n\tpre_indent = (long)getwhitecols(firstline);\n\tbd.textcol = curwin->w_cursor.col;\n    }\n\n    if (oap->motion_type == MLINE)\n\tfix_indent();\n\n    retval = edit(NUL, FALSE, (linenr_T)1);\n\n    /*\n     * In Visual block mode, handle copying the new text to all lines of the\n     * block.\n     * Don't repeat the insert when Insert mode ended with CTRL-C.\n     */\n    if (oap->block_mode && oap->start.lnum != oap->end.lnum && !got_int)\n    {\n\t// Auto-indenting may have changed the indent.  If the cursor was past\n\t// the indent, exclude that indent change from the inserted text.\n\tfirstline = ml_get(oap->start.lnum);\n\tif (bd.textcol > (colnr_T)pre_indent)\n\t{\n\t    long new_indent = (long)getwhitecols(firstline);\n\n\t    pre_textlen += new_indent - pre_indent;\n\t    bd.textcol += new_indent - pre_indent;\n\t}\n\n\tins_len = (long)STRLEN(firstline) - pre_textlen;\n\tif (ins_len > 0)\n\t{\n\t    // Subsequent calls to ml_get() flush the firstline data - take a\n\t    // copy of the inserted text.\n\t    if ((ins_text = alloc(ins_len + 1)) != NULL)\n\t    {\n\t\tvim_strncpy(ins_text, firstline + bd.textcol, (size_t)ins_len);\n\t\tfor (linenr = oap->start.lnum + 1; linenr <= oap->end.lnum;\n\t\t\t\t\t\t\t\t     linenr++)\n\t\t{\n\t\t    block_prep(oap, &bd, linenr, TRUE);\n\t\t    if (!bd.is_short || virtual_op)\n\t\t    {\n\t\t\tpos_T vpos;\n\n\t\t\t// If the block starts in virtual space, count the\n\t\t\t// initial coladd offset as part of \"startspaces\"\n\t\t\tif (bd.is_short)\n\t\t\t{\n\t\t\t    vpos.lnum = linenr;\n\t\t\t    (void)getvpos(&vpos, oap->start_vcol);\n\t\t\t}\n\t\t\telse\n\t\t\t    vpos.coladd = 0;\n\t\t\toldp = ml_get(linenr);\n\t\t\tnewp = alloc(STRLEN(oldp) + vpos.coladd + ins_len + 1);\n\t\t\tif (newp == NULL)\n\t\t\t    continue;\n\t\t\t// copy up to block start\n\t\t\tmch_memmove(newp, oldp, (size_t)bd.textcol);\n\t\t\toffset = bd.textcol;\n\t\t\tvim_memset(newp + offset, ' ', (size_t)vpos.coladd);\n\t\t\toffset += vpos.coladd;\n\t\t\tmch_memmove(newp + offset, ins_text, (size_t)ins_len);\n\t\t\toffset += ins_len;\n\t\t\toldp += bd.textcol;\n\t\t\tSTRMOVE(newp + offset, oldp);\n\t\t\tml_replace(linenr, newp, FALSE);\n#ifdef FEAT_PROP_POPUP\n\t\t\t// Shift the properties for linenr as edit() would do.\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t    adjust_prop_columns(linenr, bd.textcol,\n\t\t\t\t\t\t     vpos.coladd + ins_len, 0);\n#endif\n\t\t    }\n\t\t}\n\t\tcheck_cursor();\n\n\t\tchanged_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\t    }\n\t    vim_free(ins_text);\n\t}\n    }\n    auto_format(FALSE, TRUE);\n\n    return retval;\n}\n\n/*\n * When the cursor is on the NUL past the end of the line and it should not be\n * there move it left.\n */\n    void\nadjust_cursor_eol(void)\n{\n    unsigned int cur_ve_flags = get_ve_flags();\n\n    if (curwin->w_cursor.col > 0\n\t    && gchar_cursor() == NUL\n\t    && (cur_ve_flags & VE_ONEMORE) == 0\n\t    && !(restart_edit || (State & MODE_INSERT)))\n    {\n\t// Put the cursor on the last character in the line.\n\tdec_cursor();\n\n\tif (cur_ve_flags == VE_ALL)\n\t{\n\t    colnr_T\t    scol, ecol;\n\n\t    // Coladd is set to the width of the last character.\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol + 1;\n\t}\n    }\n}\n\n/*\n * If \"process\" is TRUE and the line begins with a comment leader (possibly\n * after some white space), return a pointer to the text after it. Put a boolean\n * value indicating whether the line ends with an unclosed comment in\n * \"is_comment\".\n * line - line to be processed,\n * process - if FALSE, will only check whether the line ends with an unclosed\n *\t     comment,\n * include_space - whether to also skip space following the comment leader,\n * is_comment - will indicate whether the current line ends with an unclosed\n *\t\tcomment.\n */\n    char_u *\nskip_comment(\n    char_u   *line,\n    int      process,\n    int\t     include_space,\n    int      *is_comment)\n{\n    char_u *comment_flags = NULL;\n    int    lead_len;\n    int    leader_offset = get_last_leader_offset(line, &comment_flags);\n\n    *is_comment = FALSE;\n    if (leader_offset != -1)\n    {\n\t// Let's check whether the line ends with an unclosed comment.\n\t// If the last comment leader has COM_END in flags, there's no comment.\n\twhile (*comment_flags)\n\t{\n\t    if (*comment_flags == COM_END\n\t\t    || *comment_flags == ':')\n\t\tbreak;\n\t    ++comment_flags;\n\t}\n\tif (*comment_flags != COM_END)\n\t    *is_comment = TRUE;\n    }\n\n    if (process == FALSE)\n\treturn line;\n\n    lead_len = get_leader_len(line, &comment_flags, FALSE, include_space);\n\n    if (lead_len == 0)\n\treturn line;\n\n    // Find:\n    // - COM_END,\n    // - colon,\n    // whichever comes first.\n    while (*comment_flags)\n    {\n\tif (*comment_flags == COM_END\n\t\t|| *comment_flags == ':')\n\t    break;\n\t++comment_flags;\n    }\n\n    // If we found a colon, it means that we are not processing a line\n    // starting with a closing part of a three-part comment. That's good,\n    // because we don't want to remove those as this would be annoying.\n    if (*comment_flags == ':' || *comment_flags == NUL)\n\tline += lead_len;\n\n    return line;\n}\n\n/*\n * Join 'count' lines (minimal 2) at the cursor position.\n * When \"save_undo\" is TRUE save lines for undo first.\n * Set \"use_formatoptions\" to FALSE when e.g. processing backspace and comment\n * leaders should not be removed.\n * When setmark is TRUE, sets the '[ and '] mark, else, the caller is expected\n * to set those marks.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_join(\n    long    count,\n    int\t    insert_space,\n    int\t    save_undo,\n    int\t    use_formatoptions UNUSED,\n    int\t    setmark)\n{\n    char_u\t*curr = NULL;\n    char_u      *curr_start = NULL;\n    char_u\t*cend;\n    char_u\t*newp;\n    size_t\tnewp_len;\n    char_u\t*spaces;\t// number of spaces inserted before a line\n    int\t\tendcurr1 = NUL;\n    int\t\tendcurr2 = NUL;\n    int\t\tcurrsize = 0;\t// size of the current line\n    int\t\tsumsize = 0;\t// size of the long new line\n    linenr_T\tt;\n    colnr_T\tcol = 0;\n    int\t\tret = OK;\n    int\t\t*comments = NULL;\n    int\t\tremove_comments = (use_formatoptions == TRUE)\n\t\t\t\t  && has_format_option(FO_REMOVE_COMS);\n    int\t\tprev_was_comment;\n#ifdef FEAT_PROP_POPUP\n    int\t\tpropcount = 0;\t// number of props over all joined lines\n    int\t\tprops_remaining;\n#endif\n\n    if (save_undo && u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t\t    (linenr_T)(curwin->w_cursor.lnum + count)) == FAIL)\n\treturn FAIL;\n\n    // Allocate an array to store the number of spaces inserted before each\n    // line.  We will use it to pre-compute the length of the new line and the\n    // proper placement of each original line in the new one.\n    spaces = lalloc_clear(count, TRUE);\n    if (spaces == NULL)\n\treturn FAIL;\n    if (remove_comments)\n    {\n\tcomments = lalloc_clear(count * sizeof(int), TRUE);\n\tif (comments == NULL)\n\t{\n\t    vim_free(spaces);\n\t    return FAIL;\n\t}\n    }\n\n    /*\n     * Don't move anything yet, just compute the final line length\n     * and setup the array of space strings lengths\n     * This loops forward over the joined lines.\n     */\n    for (t = 0; t < count; ++t)\n    {\n\tcurr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t));\n#ifdef FEAT_PROP_POPUP\n\tpropcount += count_props((linenr_T) (curwin->w_cursor.lnum + t),\n\t\t\t\t\t\t\tt > 0, t + 1 == count);\n#endif\n\tif (t == 0 && setmark && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ mark.\n\t    curwin->w_buffer->b_op_start.lnum = curwin->w_cursor.lnum;\n\t    curwin->w_buffer->b_op_start.col  = (colnr_T)STRLEN(curr);\n\t}\n\tif (remove_comments)\n\t{\n\t    // We don't want to remove the comment leader if the\n\t    // previous line is not a comment.\n\t    if (t > 0 && prev_was_comment)\n\t    {\n\n\t\tchar_u *new_curr = skip_comment(curr, TRUE, insert_space,\n\t\t\t\t\t\t\t   &prev_was_comment);\n\t\tcomments[t] = (int)(new_curr - curr);\n\t\tcurr = new_curr;\n\t    }\n\t    else\n\t\tcurr = skip_comment(curr, FALSE, insert_space,\n\t\t\t\t\t\t\t   &prev_was_comment);\n\t}\n\n\tif (insert_space && t > 0)\n\t{\n\t    curr = skipwhite(curr);\n\t    if (*curr != NUL && *curr != ')'\n\t\t    && sumsize != 0 && endcurr1 != TAB\n\t\t    && (!has_format_option(FO_MBYTE_JOIN)\n\t\t\t|| (mb_ptr2char(curr) < 0x100 && endcurr1 < 0x100))\n\t\t    && (!has_format_option(FO_MBYTE_JOIN2)\n\t\t\t|| (mb_ptr2char(curr) < 0x100\n\t\t\t    && !(enc_utf8 && utf_eat_space(endcurr1)))\n\t\t\t|| (endcurr1 < 0x100\n\t\t\t    && !(enc_utf8 && utf_eat_space(mb_ptr2char(curr)))))\n\t       )\n\t    {\n\t\t// don't add a space if the line is ending in a space\n\t\tif (endcurr1 == ' ')\n\t\t    endcurr1 = endcurr2;\n\t\telse\n\t\t    ++spaces[t];\n\t\t// extra space when 'joinspaces' set and line ends in '.'\n\t\tif (       p_js\n\t\t\t&& (endcurr1 == '.'\n\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t&& (endcurr1 == '?' || endcurr1 == '!'))))\n\t\t    ++spaces[t];\n\t    }\n\t}\n\tcurrsize = (int)STRLEN(curr);\n\tsumsize += currsize + spaces[t];\n\tendcurr1 = endcurr2 = NUL;\n\tif (insert_space && currsize > 0)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tcend = curr + currsize;\n\t\tMB_PTR_BACK(curr, cend);\n\t\tendcurr1 = (*mb_ptr2char)(cend);\n\t\tif (cend > curr)\n\t\t{\n\t\t    MB_PTR_BACK(curr, cend);\n\t\t    endcurr2 = (*mb_ptr2char)(cend);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tendcurr1 = *(curr + currsize - 1);\n\t\tif (currsize > 1)\n\t\t    endcurr2 = *(curr + currsize - 2);\n\t    }\n\t}\n\tline_breakcheck();\n\tif (got_int)\n\t{\n\t    ret = FAIL;\n\t    goto theend;\n\t}\n    }\n\n    // store the column position before last line\n    col = sumsize - currsize - spaces[count - 1];\n\n    // allocate the space for the new line\n    newp_len = sumsize + 1;\n#ifdef FEAT_PROP_POPUP\n    newp_len += propcount * sizeof(textprop_T);\n#endif\n    newp = alloc(newp_len);\n    if (newp == NULL)\n    {\n\tret = FAIL;\n\tgoto theend;\n    }\n    cend = newp + sumsize;\n    *cend = 0;\n\n    /*\n     * Move affected lines to the new long one.\n     * This loops backwards over the joined lines, including the original line.\n     *\n     * Move marks from each deleted line to the joined line, adjusting the\n     * column.  This is not Vi compatible, but Vi deletes the marks, thus that\n     * should not really be a problem.\n     */\n#ifdef FEAT_PROP_POPUP\n    props_remaining = propcount;\n#endif\n    for (t = count - 1; ; --t)\n    {\n\tint spaces_removed;\n\n\tcend -= currsize;\n\tmch_memmove(cend, curr, (size_t)currsize);\n\n\tif (spaces[t] > 0)\n\t{\n\t    cend -= spaces[t];\n\t    vim_memset(cend, ' ', (size_t)(spaces[t]));\n\t}\n\n\t// If deleting more spaces than adding, the cursor moves no more than\n\t// what is added if it is inside these spaces.\n\tspaces_removed = (curr - curr_start) - spaces[t];\n\n\tmark_col_adjust(curwin->w_cursor.lnum + t, (colnr_T)0, -t,\n\t\t\t (long)(cend - newp - spaces_removed), spaces_removed);\n#ifdef FEAT_PROP_POPUP\n\tprepend_joined_props(newp + sumsize + 1, propcount, &props_remaining,\n\t\tcurwin->w_cursor.lnum + t, t == count - 1,\n\t\t(long)(cend - newp), spaces_removed);\n#endif\n\tif (t == 0)\n\t    break;\n\tcurr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t - 1));\n\tif (remove_comments)\n\t    curr += comments[t - 1];\n\tif (insert_space && t > 1)\n\t    curr = skipwhite(curr);\n\tcurrsize = (int)STRLEN(curr);\n    }\n\n    ml_replace_len(curwin->w_cursor.lnum, newp, (colnr_T)newp_len, TRUE, FALSE);\n\n    if (setmark && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set the '] mark.\n\tcurwin->w_buffer->b_op_end.lnum = curwin->w_cursor.lnum;\n\tcurwin->w_buffer->b_op_end.col  = (colnr_T)sumsize;\n    }\n\n    // Only report the change in the first line here, del_lines() will report\n    // the deleted line.\n    changed_lines(curwin->w_cursor.lnum, currsize,\n\t\t\t\t\t       curwin->w_cursor.lnum + 1, 0L);\n    /*\n     * Delete following lines. To do this we move the cursor there\n     * briefly, and then move it back. After del_lines() the cursor may\n     * have moved up (last line deleted), so the current lnum is kept in t.\n     */\n    t = curwin->w_cursor.lnum;\n    ++curwin->w_cursor.lnum;\n    del_lines(count - 1, FALSE);\n    curwin->w_cursor.lnum = t;\n\n    /*\n     * Set the cursor column:\n     * Vi compatible: use the column of the first join\n     * vim:\t      use the column of the last join\n     */\n    curwin->w_cursor.col =\n\t\t    (vim_strchr(p_cpo, CPO_JOINCOL) != NULL ? currsize : col);\n    check_cursor_col();\n\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = TRUE;\n\ntheend:\n    vim_free(spaces);\n    if (remove_comments)\n\tvim_free(comments);\n    return ret;\n}\n\n/*\n * prepare a few things for block mode yank/delete/tilde\n *\n * for delete:\n * - textlen includes the first/last char to be (partly) deleted\n * - start/endspaces is the number of columns that are taken by the\n *   first/last deleted char minus the number of columns that have to be\n *   deleted.\n * for yank and tilde:\n * - textlen includes the first/last char to be wholly yanked\n * - start/endspaces is the number of columns of the first/last yanked char\n *   that are to be yanked.\n */\n    void\nblock_prep(\n    oparg_T\t\t*oap,\n    struct block_def\t*bdp,\n    linenr_T\t\tlnum,\n    int\t\t\tis_del)\n{\n    int\t\tincr = 0;\n    char_u\t*pend;\n    char_u\t*pstart;\n    char_u\t*line;\n    char_u\t*prev_pstart;\n    char_u\t*prev_pend;\n    chartabsize_T cts;\n#ifdef FEAT_LINEBREAK\n    int\t\tlbr_saved = curwin->w_p_lbr;\n\n    // Avoid a problem with unwanted linebreaks in block mode.\n    curwin->w_p_lbr = FALSE;\n#endif\n    bdp->startspaces = 0;\n    bdp->endspaces = 0;\n    bdp->textlen = 0;\n    bdp->start_vcol = 0;\n    bdp->end_vcol = 0;\n    bdp->is_short = FALSE;\n    bdp->is_oneChar = FALSE;\n    bdp->pre_whitesp = 0;\n    bdp->pre_whitesp_c = 0;\n    bdp->end_char_vcols = 0;\n    bdp->start_char_vcols = 0;\n\n    line = ml_get(lnum);\n    prev_pstart = line;\n    init_chartabsize_arg(&cts, curwin, lnum, bdp->start_vcol, line, line);\n    while (cts.cts_vcol < oap->start_vcol && *cts.cts_ptr != NUL)\n    {\n\t// Count a tab for what it's worth (if list mode not on)\n\tincr = lbr_chartabsize(&cts);\n\tcts.cts_vcol += incr;\n\tif (VIM_ISWHITE(*cts.cts_ptr))\n\t{\n\t    bdp->pre_whitesp += incr;\n\t    bdp->pre_whitesp_c++;\n\t}\n\telse\n\t{\n\t    bdp->pre_whitesp = 0;\n\t    bdp->pre_whitesp_c = 0;\n\t}\n\tprev_pstart = cts.cts_ptr;\n\tMB_PTR_ADV(cts.cts_ptr);\n    }\n    bdp->start_vcol = cts.cts_vcol;\n    pstart = cts.cts_ptr;\n    clear_chartabsize_arg(&cts);\n\n    bdp->start_char_vcols = incr;\n    if (bdp->start_vcol < oap->start_vcol)\t// line too short\n    {\n\tbdp->end_vcol = bdp->start_vcol;\n\tbdp->is_short = TRUE;\n\tif (!is_del || oap->op_type == OP_APPEND)\n\t    bdp->endspaces = oap->end_vcol - oap->start_vcol + 1;\n    }\n    else\n    {\n\t// notice: this converts partly selected Multibyte characters to\n\t// spaces, too.\n\tbdp->startspaces = bdp->start_vcol - oap->start_vcol;\n\tif (is_del && bdp->startspaces)\n\t    bdp->startspaces = bdp->start_char_vcols - bdp->startspaces;\n\tpend = pstart;\n\tbdp->end_vcol = bdp->start_vcol;\n\tif (bdp->end_vcol > oap->end_vcol)\t// it's all in one character\n\t{\n\t    bdp->is_oneChar = TRUE;\n\t    if (oap->op_type == OP_INSERT)\n\t\tbdp->endspaces = bdp->start_char_vcols - bdp->startspaces;\n\t    else if (oap->op_type == OP_APPEND)\n\t    {\n\t\tbdp->startspaces += oap->end_vcol - oap->start_vcol + 1;\n\t\tbdp->endspaces = bdp->start_char_vcols - bdp->startspaces;\n\t    }\n\t    else\n\t    {\n\t\tbdp->startspaces = oap->end_vcol - oap->start_vcol + 1;\n\t\tif (is_del && oap->op_type != OP_LSHIFT)\n\t\t{\n\t\t    // just putting the sum of those two into\n\t\t    // bdp->startspaces doesn't work for Visual replace,\n\t\t    // so we have to split the tab in two\n\t\t    bdp->startspaces = bdp->start_char_vcols\n\t\t\t\t\t- (bdp->start_vcol - oap->start_vcol);\n\t\t    bdp->endspaces = bdp->end_vcol - oap->end_vcol - 1;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    init_chartabsize_arg(&cts, curwin, lnum, bdp->end_vcol,\n\t\t\t\t\t\t\t\t  line, pend);\n\t    prev_pend = pend;\n\t    while (cts.cts_vcol <= oap->end_vcol && *cts.cts_ptr != NUL)\n\t    {\n\t\t// count a tab for what it's worth (if list mode not on)\n\t\tprev_pend = cts.cts_ptr;\n\t\tincr = lbr_chartabsize_adv(&cts);\n\t\tcts.cts_vcol += incr;\n\t    }\n\t    bdp->end_vcol = cts.cts_vcol;\n\t    pend = cts.cts_ptr;\n\t    clear_chartabsize_arg(&cts);\n\n\t    if (bdp->end_vcol <= oap->end_vcol\n\t\t    && (!is_del\n\t\t\t|| oap->op_type == OP_APPEND\n\t\t\t|| oap->op_type == OP_REPLACE)) // line too short\n\t    {\n\t\tbdp->is_short = TRUE;\n\t\t// Alternative: include spaces to fill up the block.\n\t\t// Disadvantage: can lead to trailing spaces when the line is\n\t\t// short where the text is put\n\t\t// if (!is_del || oap->op_type == OP_APPEND)\n\t\tif (oap->op_type == OP_APPEND || virtual_op)\n\t\t    bdp->endspaces = oap->end_vcol - bdp->end_vcol\n\t\t\t\t\t\t\t     + oap->inclusive;\n\t\telse\n\t\t    bdp->endspaces = 0; // replace doesn't add characters\n\t    }\n\t    else if (bdp->end_vcol > oap->end_vcol)\n\t    {\n\t\tbdp->endspaces = bdp->end_vcol - oap->end_vcol - 1;\n\t\tif (!is_del && bdp->endspaces)\n\t\t{\n\t\t    bdp->endspaces = incr - bdp->endspaces;\n\t\t    if (pend != pstart)\n\t\t\tpend = prev_pend;\n\t\t}\n\t    }\n\t}\n\tbdp->end_char_vcols = incr;\n\tif (is_del && bdp->startspaces)\n\t    pstart = prev_pstart;\n\tbdp->textlen = (int)(pend - pstart);\n    }\n    bdp->textcol = (colnr_T) (pstart - line);\n    bdp->textstart = pstart;\n#ifdef FEAT_LINEBREAK\n    curwin->w_p_lbr = lbr_saved;\n#endif\n}\n\n/*\n * Handle the add/subtract operator.\n */\n    void\nop_addsub(\n    oparg_T\t*oap,\n    linenr_T\tPrenum1,\t    // Amount of add/subtract\n    int\t\tg_cmd)\t\t    // was g<c-a>/g<c-x>\n{\n    pos_T\t\tpos;\n    struct block_def\tbd;\n    int\t\t\tchange_cnt = 0;\n    linenr_T\t\tamount = Prenum1;\n\n   // do_addsub() might trigger re-evaluation of 'foldexpr' halfway, when the\n   // buffer is not completely updated yet. Postpone updating folds until before\n   // the call to changed_lines().\n#ifdef FEAT_FOLDING\n   disable_fold_update++;\n#endif\n\n    if (!VIsual_active)\n    {\n\tpos = curwin->w_cursor;\n\tif (u_save_cursor() == FAIL)\n\t{\n#ifdef FEAT_FOLDING\n\t    disable_fold_update--;\n#endif\n\t    return;\n\t}\n\tchange_cnt = do_addsub(oap->op_type, &pos, 0, amount);\n#ifdef FEAT_FOLDING\n\tdisable_fold_update--;\n#endif\n\tif (change_cnt)\n\t    changed_lines(pos.lnum, 0, pos.lnum + 1, 0L);\n    }\n    else\n    {\n\tint\tone_change;\n\tint\tlength;\n\tpos_T\tstartpos;\n\n\tif (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t\t(linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t{\n#ifdef FEAT_FOLDING\n\t    disable_fold_update--;\n#endif\n\t    return;\n\t}\n\n\tpos = oap->start;\n\tfor (; pos.lnum <= oap->end.lnum; ++pos.lnum)\n\t{\n\t    if (oap->block_mode)\t\t    // Visual block mode\n\t    {\n\t\tblock_prep(oap, &bd, pos.lnum, FALSE);\n\t\tpos.col = bd.textcol;\n\t\tlength = bd.textlen;\n\t    }\n\t    else if (oap->motion_type == MLINE)\n\t    {\n\t\tcurwin->w_cursor.col = 0;\n\t\tpos.col = 0;\n\t\tlength = (colnr_T)STRLEN(ml_get(pos.lnum));\n\t    }\n\t    else // oap->motion_type == MCHAR\n\t    {\n\t\tif (pos.lnum == oap->start.lnum && !oap->inclusive)\n\t\t    dec(&(oap->end));\n\t\tlength = (colnr_T)STRLEN(ml_get(pos.lnum));\n\t\tpos.col = 0;\n\t\tif (pos.lnum == oap->start.lnum)\n\t\t{\n\t\t    pos.col += oap->start.col;\n\t\t    length -= oap->start.col;\n\t\t}\n\t\tif (pos.lnum == oap->end.lnum)\n\t\t{\n\t\t    length = (int)STRLEN(ml_get(oap->end.lnum));\n\t\t    if (oap->end.col >= length)\n\t\t\toap->end.col = length - 1;\n\t\t    length = oap->end.col - pos.col + 1;\n\t\t}\n\t    }\n\t    one_change = do_addsub(oap->op_type, &pos, length, amount);\n\t    if (one_change)\n\t    {\n\t\t// Remember the start position of the first change.\n\t\tif (change_cnt == 0)\n\t\t    startpos = curbuf->b_op_start;\n\t\t++change_cnt;\n\t    }\n\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active() && one_change)\n\t    {\n\t\tchar_u *ptr;\n\n\t\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)length);\n\t\tptr = ml_get_buf(curbuf, pos.lnum, FALSE);\n\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t&ptr[pos.col], length);\n\t    }\n#endif\n\t    if (g_cmd && one_change)\n\t\tamount += Prenum1;\n\t}\n\n#ifdef FEAT_FOLDING\n\tdisable_fold_update--;\n#endif\n\tif (change_cnt)\n\t    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);\n\n\tif (!change_cnt && oap->is_VIsual)\n\t    // No change: need to remove the Visual selection\n\t    redraw_curbuf_later(UPD_INVERTED);\n\n\t// Set '[ mark if something changed. Keep the last end\n\t// position from do_addsub().\n\tif (change_cnt > 0 && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t    curbuf->b_op_start = startpos;\n\n\tif (change_cnt > p_report)\n\t    smsg(NGETTEXT(\"%d line changed\", \"%d lines changed\",\n\t\t\t\t\t\t      change_cnt), change_cnt);\n    }\n}\n\n/*\n * Add or subtract 'Prenum1' from a number in a line\n * op_type is OP_NR_ADD or OP_NR_SUB\n *\n * Returns TRUE if some character was changed.\n */\n    static int\ndo_addsub(\n    int\t\top_type,\n    pos_T\t*pos,\n    int\t\tlength,\n    linenr_T\tPrenum1)\n{\n    int\t\tcol;\n    char_u\t*buf1;\n    char_u\tbuf2[NUMBUFLEN];\n    int\t\tpre;\t\t// 'X'/'x': hex; '0': octal; 'B'/'b': bin\n    static int\thexupper = FALSE;\t// 0xABC\n    uvarnumber_T\tn;\n    uvarnumber_T\toldn;\n    char_u\t*ptr;\n    int\t\tc;\n    int\t\ttodel;\n    int\t\tdo_hex;\n    int\t\tdo_oct;\n    int\t\tdo_bin;\n    int\t\tdo_alpha;\n    int\t\tdo_unsigned;\n    int\t\tfirstdigit;\n    int\t\tsubtract;\n    int\t\tnegative = FALSE;\n    int\t\twas_positive = TRUE;\n    int\t\tvisual = VIsual_active;\n    int\t\tdid_change = FALSE;\n    pos_T\tsave_cursor = curwin->w_cursor;\n    int\t\tmaxlen = 0;\n    pos_T\tstartpos;\n    pos_T\tendpos;\n    colnr_T\tsave_coladd = 0;\n\n    do_hex = (vim_strchr(curbuf->b_p_nf, 'x') != NULL);\t// \"heX\"\n    do_oct = (vim_strchr(curbuf->b_p_nf, 'o') != NULL);\t// \"Octal\"\n    do_bin = (vim_strchr(curbuf->b_p_nf, 'b') != NULL);\t// \"Bin\"\n    do_alpha = (vim_strchr(curbuf->b_p_nf, 'p') != NULL);\t// \"alPha\"\n    do_unsigned = (vim_strchr(curbuf->b_p_nf, 'u') != NULL);\t// \"Unsigned\"\n\n    if (virtual_active())\n    {\n\tsave_coladd = pos->coladd;\n\tpos->coladd = 0;\n    }\n\n    curwin->w_cursor = *pos;\n    ptr = ml_get(pos->lnum);\n    col = pos->col;\n\n    if (*ptr == NUL || col + !!save_coladd >= (int)STRLEN(ptr))\n\tgoto theend;\n\n    /*\n     * First check if we are on a hexadecimal number, after the \"0x\".\n     */\n    if (!VIsual_active)\n    {\n\tif (do_bin)\n\t    while (col > 0 && vim_isbdigit(ptr[col]))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\n\tif (do_hex)\n\t    while (col > 0 && vim_isxdigit(ptr[col]))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\n\tif (       do_bin\n\t\t&& do_hex\n\t\t&& ! ((col > 0\n\t\t    && (ptr[col] == 'X'\n\t\t\t|| ptr[col] == 'x')\n\t\t    && ptr[col - 1] == '0'\n\t\t    && (!has_mbyte ||\n\t\t\t!(*mb_head_off)(ptr, ptr + col - 1))\n\t\t    && vim_isxdigit(ptr[col + 1]))))\n\t{\n\n\t    // In case of binary/hexadecimal pattern overlap match, rescan\n\n\t    col = pos->col;\n\n\t    while (col > 0 && vim_isdigit(ptr[col]))\n\t    {\n\t\tcol--;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\t}\n\n\tif ((       do_hex\n\t\t&& col > 0\n\t\t&& (ptr[col] == 'X'\n\t\t    || ptr[col] == 'x')\n\t\t&& ptr[col - 1] == '0'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& vim_isxdigit(ptr[col + 1])) ||\n\t    (       do_bin\n\t\t&& col > 0\n\t\t&& (ptr[col] == 'B'\n\t\t    || ptr[col] == 'b')\n\t\t&& ptr[col - 1] == '0'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& vim_isbdigit(ptr[col + 1])))\n\t{\n\t    // Found hexadecimal or binary number, move to its start.\n\t    --col;\n\t    if (has_mbyte)\n\t\tcol -= (*mb_head_off)(ptr, ptr + col);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Search forward and then backward to find the start of number.\n\t     */\n\t    col = pos->col;\n\n\t    while (ptr[col] != NUL\n\t\t    && !vim_isdigit(ptr[col])\n\t\t    && !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t\tcol += mb_ptr2len(ptr + col);\n\n\t    while (col > 0\n\t\t    && vim_isdigit(ptr[col - 1])\n\t\t    && !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\t}\n    }\n\n    if (visual)\n    {\n\twhile (ptr[col] != NUL && length > 0\n\t\t&& !vim_isdigit(ptr[col])\n\t\t&& !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t{\n\t    int mb_len = mb_ptr2len(ptr + col);\n\n\t    col += mb_len;\n\t    length -= mb_len;\n\t}\n\n\tif (length == 0)\n\t    goto theend;\n\n\tif (col > pos->col && ptr[col - 1] == '-'\n\t\t&& (!has_mbyte || !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& !do_unsigned)\n\t{\n\t    negative = TRUE;\n\t    was_positive = FALSE;\n\t}\n    }\n\n    /*\n     * If a number was found, and saving for undo works, replace the number.\n     */\n    firstdigit = ptr[col];\n    if (!VIM_ISDIGIT(firstdigit) && !(do_alpha && ASCII_ISALPHA(firstdigit)))\n    {\n\tbeep_flush();\n\tgoto theend;\n    }\n\n    if (do_alpha && ASCII_ISALPHA(firstdigit))\n    {\n\t// decrement or increment alphabetic character\n\tif (op_type == OP_NR_SUB)\n\t{\n\t    if (CharOrd(firstdigit) < Prenum1)\n\t    {\n\t\tif (isupper(firstdigit))\n\t\t    firstdigit = 'A';\n\t\telse\n\t\t    firstdigit = 'a';\n\t    }\n\t    else\n\t\tfirstdigit -= Prenum1;\n\t}\n\telse\n\t{\n\t    if (26 - CharOrd(firstdigit) - 1 < Prenum1)\n\t    {\n\t\tif (isupper(firstdigit))\n\t\t    firstdigit = 'Z';\n\t\telse\n\t\t    firstdigit = 'z';\n\t    }\n\t    else\n\t\tfirstdigit += Prenum1;\n\t}\n\tcurwin->w_cursor.col = col;\n\tif (!did_change)\n\t    startpos = curwin->w_cursor;\n\tdid_change = TRUE;\n\t(void)del_char(FALSE);\n\tins_char(firstdigit);\n\tendpos = curwin->w_cursor;\n\tcurwin->w_cursor.col = col;\n    }\n    else\n    {\n\tpos_T\tsave_pos;\n\tint\ti;\n\n\tif (col > 0 && ptr[col - 1] == '-'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& !visual\n\t\t&& !do_unsigned)\n\t{\n\t    // negative number\n\t    --col;\n\t    negative = TRUE;\n\t}\n\t// get the number value (unsigned)\n\tif (visual && VIsual_mode != 'V')\n\t    maxlen = (curbuf->b_visual.vi_curswant == MAXCOL\n\t\t    ? (int)STRLEN(ptr) - col\n\t\t    : length);\n\n\tvim_str2nr(ptr + col, &pre, &length,\n\t\t0 + (do_bin ? STR2NR_BIN : 0)\n\t\t    + (do_oct ? STR2NR_OCT : 0)\n\t\t    + (do_hex ? STR2NR_HEX : 0),\n\t\tNULL, &n, maxlen, FALSE);\n\n\t// ignore leading '-' for hex and octal and bin numbers\n\tif (pre && negative)\n\t{\n\t    ++col;\n\t    --length;\n\t    negative = FALSE;\n\t}\n\t// add or subtract\n\tsubtract = FALSE;\n\tif (op_type == OP_NR_SUB)\n\t    subtract ^= TRUE;\n\tif (negative)\n\t    subtract ^= TRUE;\n\n\toldn = n;\n\tif (subtract)\n\t    n -= (uvarnumber_T)Prenum1;\n\telse\n\t    n += (uvarnumber_T)Prenum1;\n\t// handle wraparound for decimal numbers\n\tif (!pre)\n\t{\n\t    if (subtract)\n\t    {\n\t\tif (n > oldn)\n\t\t{\n\t\t    n = 1 + (n ^ (uvarnumber_T)-1);\n\t\t    negative ^= TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// add\n\t\tif (n < oldn)\n\t\t{\n\t\t    n = (n ^ (uvarnumber_T)-1);\n\t\t    negative ^= TRUE;\n\t\t}\n\t    }\n\t    if (n == 0)\n\t\tnegative = FALSE;\n\t}\n\n\tif (do_unsigned && negative)\n\t{\n\t    if (subtract)\n\t\t// sticking at zero.\n\t\tn = (uvarnumber_T)0;\n\t    else\n\t\t// sticking at 2^64 - 1.\n\t\tn = (uvarnumber_T)(-1);\n\t    negative = FALSE;\n\t}\n\n\tif (visual && !was_positive && !negative && col > 0)\n\t{\n\t    // need to remove the '-'\n\t    col--;\n\t    length++;\n\t}\n\n\t/*\n\t * Delete the old number.\n\t */\n\tcurwin->w_cursor.col = col;\n\tif (!did_change)\n\t    startpos = curwin->w_cursor;\n\tdid_change = TRUE;\n\ttodel = length;\n\tc = gchar_cursor();\n\t/*\n\t * Don't include the '-' in the length, only the length of the\n\t * part after it is kept the same.\n\t */\n\tif (c == '-')\n\t    --length;\n\n\tsave_pos = curwin->w_cursor;\n\tfor (i = 0; i < todel; ++i)\n\t{\n\t    if (c < 0x100 && isalpha(c))\n\t    {\n\t\tif (isupper(c))\n\t\t    hexupper = TRUE;\n\t\telse\n\t\t    hexupper = FALSE;\n\t    }\n\t    inc_cursor();\n\t    c = gchar_cursor();\n\t}\n\tcurwin->w_cursor = save_pos;\n\n\t/*\n\t * Prepare the leading characters in buf1[].\n\t * When there are many leading zeros it could be very long.\n\t * Allocate a bit too much.\n\t */\n\tbuf1 = alloc(length + NUMBUFLEN);\n\tif (buf1 == NULL)\n\t    goto theend;\n\tptr = buf1;\n\tif (negative && (!visual || was_positive))\n\t    *ptr++ = '-';\n\tif (pre)\n\t{\n\t    *ptr++ = '0';\n\t    --length;\n\t}\n\tif (pre == 'b' || pre == 'B' ||\n\t    pre == 'x' || pre == 'X')\n\t{\n\t    *ptr++ = pre;\n\t    --length;\n\t}\n\n\t/*\n\t * Put the number characters in buf2[].\n\t */\n\tif (pre == 'b' || pre == 'B')\n\t{\n\t    int bit = 0;\n\t    int bits = sizeof(uvarnumber_T) * 8;\n\n\t    // leading zeros\n\t    for (bit = bits; bit > 0; bit--)\n\t\tif ((n >> (bit - 1)) & 0x1) break;\n\n\t    for (i = 0; bit > 0; bit--)\n\t\tbuf2[i++] = ((n >> (bit - 1)) & 0x1) ? '1' : '0';\n\n\t    buf2[i] = '\\0';\n\t}\n\telse if (pre == 0)\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llu\", n);\n\telse if (pre == '0')\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llo\", n);\n\telse if (pre && hexupper)\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llX\", n);\n\telse\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llx\", n);\n\tlength -= (int)STRLEN(buf2);\n\n\t/*\n\t * Adjust number of zeros to the new number of digits, so the\n\t * total length of the number remains the same.\n\t * Don't do this when\n\t * the result may look like an octal number.\n\t */\n\tif (firstdigit == '0' && !(do_oct && pre == 0))\n\t    while (length-- > 0)\n\t\t*ptr++ = '0';\n\t*ptr = NUL;\n\n\tSTRCAT(buf1, buf2);\n\n\t// Insert just after the first character to be removed, so that any\n\t// text properties will be adjusted.  Then delete the old number\n\t// afterwards.\n\tsave_pos = curwin->w_cursor;\n\tif (todel > 0)\n\t    inc_cursor();\n\tins_str(buf1);\t\t// insert the new number\n\tvim_free(buf1);\n\n\t// del_char() will also mark line needing displaying\n\tif (todel > 0)\n\t{\n\t    int bytes_after = (int)STRLEN(ml_get_curline())\n\t\t\t\t\t\t\t- curwin->w_cursor.col;\n\n\t    // Delete the one character before the insert.\n\t    curwin->w_cursor = save_pos;\n\t    (void)del_char(FALSE);\n\t    curwin->w_cursor.col = (colnr_T)(STRLEN(ml_get_curline())\n\t\t\t\t\t\t\t\t- bytes_after);\n\t    --todel;\n\t}\n\twhile (todel-- > 0)\n\t    (void)del_char(FALSE);\n\n\tendpos = curwin->w_cursor;\n\tif (did_change && curwin->w_cursor.col)\n\t    --curwin->w_cursor.col;\n    }\n\n    if (did_change && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// set the '[ and '] marks\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = endpos;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n\ntheend:\n    if (visual)\n\tcurwin->w_cursor = save_cursor;\n    else if (did_change)\n\tcurwin->w_set_curswant = TRUE;\n    else if (virtual_active())\n\tcurwin->w_cursor.coladd = save_coladd;\n\n    return did_change;\n}\n\n    void\nclear_oparg(oparg_T *oap)\n{\n    CLEAR_POINTER(oap);\n}\n\n/*\n *  Count the number of bytes, characters and \"words\" in a line.\n *\n *  \"Words\" are counted by looking for boundaries between non-space and\n *  space characters.  (it seems to produce results that match 'wc'.)\n *\n *  Return value is byte count; word count for the line is added to \"*wc\".\n *  Char count is added to \"*cc\".\n *\n *  The function will only examine the first \"limit\" characters in the\n *  line, stopping if it encounters an end-of-line (NUL byte).  In that\n *  case, eol_size will be added to the character count to account for\n *  the size of the EOL character.\n */\n    static varnumber_T\nline_count_info(\n    char_u\t*line,\n    varnumber_T\t*wc,\n    varnumber_T\t*cc,\n    varnumber_T\tlimit,\n    int\t\teol_size)\n{\n    varnumber_T\ti;\n    varnumber_T\twords = 0;\n    varnumber_T\tchars = 0;\n    int\t\tis_word = 0;\n\n    for (i = 0; i < limit && line[i] != NUL; )\n    {\n\tif (is_word)\n\t{\n\t    if (vim_isspace(line[i]))\n\t    {\n\t\twords++;\n\t\tis_word = 0;\n\t    }\n\t}\n\telse if (!vim_isspace(line[i]))\n\t    is_word = 1;\n\t++chars;\n\ti += (*mb_ptr2len)(line + i);\n    }\n\n    if (is_word)\n\twords++;\n    *wc += words;\n\n    // Add eol_size if the end of line was reached before hitting limit.\n    if (i < limit && line[i] == NUL)\n    {\n\ti += eol_size;\n\tchars += eol_size;\n    }\n    *cc += chars;\n    return i;\n}\n\n/*\n * Give some info about the position of the cursor (for \"g CTRL-G\").\n * In Visual mode, give some info about the selected region.  (In this case,\n * the *_count_cursor variables store running totals for the selection.)\n * When \"dict\" is not NULL store the info there instead of showing it.\n */\n    void\ncursor_pos_info(dict_T *dict)\n{\n    char_u\t*p;\n    char_u\tbuf1[50];\n    char_u\tbuf2[40];\n    linenr_T\tlnum;\n    varnumber_T\tbyte_count = 0;\n    varnumber_T\tbom_count  = 0;\n    varnumber_T\tbyte_count_cursor = 0;\n    varnumber_T\tchar_count = 0;\n    varnumber_T\tchar_count_cursor = 0;\n    varnumber_T\tword_count = 0;\n    varnumber_T\tword_count_cursor = 0;\n    int\t\teol_size;\n    varnumber_T\tlast_check = 100000L;\n    long\tline_count_selected = 0;\n    pos_T\tmin_pos, max_pos;\n    oparg_T\toparg;\n    struct block_def\tbd;\n\n    /*\n     * Compute the length of the file in characters.\n     */\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n    {\n\tif (dict == NULL)\n\t{\n\t    msg(_(no_lines_msg));\n\t    return;\n\t}\n    }\n    else\n    {\n\tif (get_fileformat(curbuf) == EOL_DOS)\n\t    eol_size = 2;\n\telse\n\t    eol_size = 1;\n\n\tif (VIsual_active)\n\t{\n\t    if (LT_POS(VIsual, curwin->w_cursor))\n\t    {\n\t\tmin_pos = VIsual;\n\t\tmax_pos = curwin->w_cursor;\n\t    }\n\t    else\n\t    {\n\t\tmin_pos = curwin->w_cursor;\n\t\tmax_pos = VIsual;\n\t    }\n\t    if (*p_sel == 'e' && max_pos.col > 0)\n\t\t--max_pos.col;\n\n\t    if (VIsual_mode == Ctrl_V)\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tchar_u * saved_sbr = p_sbr;\n\t\tchar_u * saved_w_sbr = curwin->w_p_sbr;\n\n\t\t// Make 'sbr' empty for a moment to get the correct size.\n\t\tp_sbr = empty_option;\n\t\tcurwin->w_p_sbr = empty_option;\n#endif\n\t\toparg.is_VIsual = 1;\n\t\toparg.block_mode = TRUE;\n\t\toparg.op_type = OP_NOP;\n\t\tgetvcols(curwin, &min_pos, &max_pos,\n\t\t\t\t\t  &oparg.start_vcol, &oparg.end_vcol);\n#ifdef FEAT_LINEBREAK\n\t\tp_sbr = saved_sbr;\n\t\tcurwin->w_p_sbr = saved_w_sbr;\n#endif\n\t\tif (curwin->w_curswant == MAXCOL)\n\t\t    oparg.end_vcol = MAXCOL;\n\t\t// Swap the start, end vcol if needed\n\t\tif (oparg.end_vcol < oparg.start_vcol)\n\t\t{\n\t\t    oparg.end_vcol += oparg.start_vcol;\n\t\t    oparg.start_vcol = oparg.end_vcol - oparg.start_vcol;\n\t\t    oparg.end_vcol -= oparg.start_vcol;\n\t\t}\n\t    }\n\t    line_count_selected = max_pos.lnum - min_pos.lnum + 1;\n\t}\n\n\tfor (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t{\n\t    // Check for a CTRL-C every 100000 characters.\n\t    if (byte_count > last_check)\n\t    {\n\t\tui_breakcheck();\n\t\tif (got_int)\n\t\t    return;\n\t\tlast_check = byte_count + 100000L;\n\t    }\n\n\t    // Do extra processing for VIsual mode.\n\t    if (VIsual_active\n\t\t    && lnum >= min_pos.lnum && lnum <= max_pos.lnum)\n\t    {\n\t\tchar_u\t    *s = NULL;\n\t\tlong\t    len = 0L;\n\n\t\tswitch (VIsual_mode)\n\t\t{\n\t\t    case Ctrl_V:\n\t\t\tvirtual_op = virtual_active();\n\t\t\tblock_prep(&oparg, &bd, lnum, 0);\n\t\t\tvirtual_op = MAYBE;\n\t\t\ts = bd.textstart;\n\t\t\tlen = (long)bd.textlen;\n\t\t\tbreak;\n\t\t    case 'V':\n\t\t\ts = ml_get(lnum);\n\t\t\tlen = MAXCOL;\n\t\t\tbreak;\n\t\t    case 'v':\n\t\t\t{\n\t\t\t    colnr_T start_col = (lnum == min_pos.lnum)\n\t\t\t\t\t\t\t   ? min_pos.col : 0;\n\t\t\t    colnr_T end_col = (lnum == max_pos.lnum)\n\t\t\t\t      ? max_pos.col - start_col + 1 : MAXCOL;\n\n\t\t\t    s = ml_get(lnum) + start_col;\n\t\t\t    len = end_col;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (s != NULL)\n\t\t{\n\t\t    byte_count_cursor += line_count_info(s, &word_count_cursor,\n\t\t\t\t\t   &char_count_cursor, len, eol_size);\n\t\t    if (lnum == curbuf->b_ml.ml_line_count\n\t\t\t    && !curbuf->b_p_eol\n\t\t\t    && (curbuf->b_p_bin || !curbuf->b_p_fixeol)\n\t\t\t    && (long)STRLEN(s) < len)\n\t\t\tbyte_count_cursor -= eol_size;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// In non-visual mode, check for the line the cursor is on\n\t\tif (lnum == curwin->w_cursor.lnum)\n\t\t{\n\t\t    word_count_cursor += word_count;\n\t\t    char_count_cursor += char_count;\n\t\t    byte_count_cursor = byte_count +\n\t\t\tline_count_info(ml_get(lnum),\n\t\t\t\t&word_count_cursor, &char_count_cursor,\n\t\t\t\t(varnumber_T)(curwin->w_cursor.col + 1),\n\t\t\t\teol_size);\n\t\t}\n\t    }\n\t    // Add to the running totals\n\t    byte_count += line_count_info(ml_get(lnum), &word_count,\n\t\t\t\t\t &char_count, (varnumber_T)MAXCOL,\n\t\t\t\t\t eol_size);\n\t}\n\n\t// Correction for when last line doesn't have an EOL.\n\tif (!curbuf->b_p_eol && (curbuf->b_p_bin || !curbuf->b_p_fixeol))\n\t    byte_count -= eol_size;\n\n\tif (dict == NULL)\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_mode == Ctrl_V && curwin->w_curswant < MAXCOL)\n\t\t{\n\t\t    getvcols(curwin, &min_pos, &max_pos, &min_pos.col,\n\t\t\t\t\t\t\t\t    &max_pos.col);\n\t\t    vim_snprintf((char *)buf1, sizeof(buf1), _(\"%ld Cols; \"),\n\t\t\t    (long)(oparg.end_vcol - oparg.start_vcol + 1));\n\t\t}\n\t\telse\n\t\t    buf1[0] = NUL;\n\n\t\tif (char_count_cursor == byte_count_cursor\n\t\t\t\t\t\t    && char_count == byte_count)\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t    _(\"Selected %s%ld of %ld Lines; %lld of %lld Words; %lld of %lld Bytes\"),\n\t\t\t    buf1, line_count_selected,\n\t\t\t    (long)curbuf->b_ml.ml_line_count,\n\t\t\t    word_count_cursor,\n\t\t\t    word_count,\n\t\t\t    byte_count_cursor,\n\t\t\t    byte_count);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t    _(\"Selected %s%ld of %ld Lines; %lld of %lld Words; %lld of %lld Chars; %lld of %lld Bytes\"),\n\t\t\t    buf1, line_count_selected,\n\t\t\t    (long)curbuf->b_ml.ml_line_count,\n\t\t\t    word_count_cursor,\n\t\t\t    word_count,\n\t\t\t    char_count_cursor,\n\t\t\t    char_count,\n\t\t\t    byte_count_cursor,\n\t\t\t    byte_count);\n\t    }\n\t    else\n\t    {\n\t\tp = ml_get_curline();\n\t\tvalidate_virtcol();\n\t\tcol_print(buf1, sizeof(buf1), (int)curwin->w_cursor.col + 1,\n\t\t\t(int)curwin->w_virtcol + 1);\n\t\tcol_print(buf2, sizeof(buf2), (int)STRLEN(p),\n\t\t\t\t    linetabsize(p));\n\n\t\tif (char_count_cursor == byte_count_cursor\n\t\t\t&& char_count == byte_count)\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"Col %s of %s; Line %ld of %ld; Word %lld of %lld; Byte %lld of %lld\"),\n\t\t\t(char *)buf1, (char *)buf2,\n\t\t\t(long)curwin->w_cursor.lnum,\n\t\t\t(long)curbuf->b_ml.ml_line_count,\n\t\t\tword_count_cursor, word_count,\n\t\t\tbyte_count_cursor, byte_count);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"Col %s of %s; Line %ld of %ld; Word %lld of %lld; Char %lld of %lld; Byte %lld of %lld\"),\n\t\t\t(char *)buf1, (char *)buf2,\n\t\t\t(long)curwin->w_cursor.lnum,\n\t\t\t(long)curbuf->b_ml.ml_line_count,\n\t\t\tword_count_cursor, word_count,\n\t\t\tchar_count_cursor, char_count,\n\t\t\tbyte_count_cursor, byte_count);\n\t    }\n\t}\n\n\tbom_count = bomb_size();\n\tif (dict == NULL && bom_count > 0)\n\t{\n\t    size_t len = STRLEN(IObuff);\n\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\t\t _(\"(+%lld for BOM)\"), bom_count);\n\t}\n\tif (dict == NULL)\n\t{\n\t    // Don't shorten this message, the user asked for it.\n\t    p = p_shm;\n\t    p_shm = (char_u *)\"\";\n\t    msg((char *)IObuff);\n\t    p_shm = p;\n\t}\n    }\n#if defined(FEAT_EVAL)\n    if (dict != NULL)\n    {\n\tdict_add_number(dict, \"words\", word_count);\n\tdict_add_number(dict, \"chars\", char_count);\n\tdict_add_number(dict, \"bytes\", byte_count + bom_count);\n\tdict_add_number(dict, VIsual_active ? \"visual_bytes\" : \"cursor_bytes\",\n\t\tbyte_count_cursor);\n\tdict_add_number(dict, VIsual_active ? \"visual_chars\" : \"cursor_chars\",\n\t\tchar_count_cursor);\n\tdict_add_number(dict, VIsual_active ? \"visual_words\" : \"cursor_words\",\n\t\tword_count_cursor);\n    }\n#endif\n}\n\n/*\n * Handle indent and format operators and visual mode \":\".\n */\n    static void\nop_colon(oparg_T *oap)\n{\n    stuffcharReadbuff(':');\n    if (oap->is_VIsual)\n\tstuffReadbuff((char_u *)\"'<,'>\");\n    else\n    {\n\t// Make the range look nice, so it can be repeated.\n\tif (oap->start.lnum == curwin->w_cursor.lnum)\n\t    stuffcharReadbuff('.');\n\telse\n\t    stuffnumReadbuff((long)oap->start.lnum);\n\tif (oap->end.lnum != oap->start.lnum)\n\t{\n\t    stuffcharReadbuff(',');\n\t    if (oap->end.lnum == curwin->w_cursor.lnum)\n\t\tstuffcharReadbuff('.');\n\t    else if (oap->end.lnum == curbuf->b_ml.ml_line_count)\n\t\tstuffcharReadbuff('$');\n\t    else if (oap->start.lnum == curwin->w_cursor.lnum)\n\t    {\n\t\tstuffReadbuff((char_u *)\".+\");\n\t\tstuffnumReadbuff((long)oap->line_count - 1);\n\t    }\n\t    else\n\t\tstuffnumReadbuff((long)oap->end.lnum);\n\t}\n    }\n    if (oap->op_type != OP_COLON)\n\tstuffReadbuff((char_u *)\"!\");\n    if (oap->op_type == OP_INDENT)\n    {\n\tif (*get_equalprg() == NUL)\n\t    stuffReadbuff((char_u *)\"indent\");\n\telse\n\t    stuffReadbuff(get_equalprg());\n\tstuffReadbuff((char_u *)\"\\n\");\n    }\n    else if (oap->op_type == OP_FORMAT)\n    {\n\tif (*curbuf->b_p_fp != NUL)\n\t    stuffReadbuff(curbuf->b_p_fp);\n\telse if (*p_fp != NUL)\n\t    stuffReadbuff(p_fp);\n\telse\n\t    stuffReadbuff((char_u *)\"fmt\");\n\tstuffReadbuff((char_u *)\"\\n']\");\n    }\n\n    // do_cmdline() does the rest\n}\n\n// callback function for 'operatorfunc'\nstatic callback_T opfunc_cb;\n\n/*\n * Process the 'operatorfunc' option value.\n * Returns OK or FAIL.\n */\n    int\nset_operatorfunc_option(void)\n{\n    return option_set_callback_func(p_opfunc, &opfunc_cb);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_operatorfunc_option(void)\n{\n# ifdef FEAT_EVAL\n    free_callback(&opfunc_cb);\n# endif\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Mark the global 'operatorfunc' callback with 'copyID' so that it is not\n * garbage collected.\n */\n    int\nset_ref_in_opfunc(int copyID UNUSED)\n{\n    int abort = FALSE;\n\n    abort = set_ref_in_callback(&opfunc_cb, copyID);\n\n    return abort;\n}\n#endif\n\n/*\n * Handle the \"g@\" operator: call 'operatorfunc'.\n */\n    static void\nop_function(oparg_T *oap UNUSED)\n{\n#ifdef FEAT_EVAL\n    typval_T\targv[2];\n    int\t\tsave_virtual_op = virtual_op;\n    int\t\tsave_finish_op = finish_op;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    typval_T\trettv;\n\n    if (*p_opfunc == NUL)\n\temsg(_(e_operatorfunc_is_empty));\n    else\n    {\n\t// Set '[ and '] marks to text to be operated on.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n\tif (oap->motion_type != MLINE && !oap->inclusive)\n\t    // Exclude the end position.\n\t    decl(&curbuf->b_op_end);\n\n\targv[0].v_type = VAR_STRING;\n\tif (oap->block_mode)\n\t    argv[0].vval.v_string = (char_u *)\"block\";\n\telse if (oap->motion_type == MLINE)\n\t    argv[0].vval.v_string = (char_u *)\"line\";\n\telse\n\t    argv[0].vval.v_string = (char_u *)\"char\";\n\targv[1].v_type = VAR_UNKNOWN;\n\n\t// Reset virtual_op so that 'virtualedit' can be changed in the\n\t// function.\n\tvirtual_op = MAYBE;\n\n\t// Reset finish_op so that mode() returns the right value.\n\tfinish_op = FALSE;\n\n\tif (call_callback(&opfunc_cb, 0, &rettv, 1, argv) != FAIL)\n\t    clear_tv(&rettv);\n\n\tvirtual_op = save_virtual_op;\n\tfinish_op = save_finish_op;\n\tif (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n\t{\n\t    curbuf->b_op_start = orig_start;\n\t    curbuf->b_op_end = orig_end;\n\t}\n    }\n#else\n    emsg(_(e_eval_feature_not_available));\n#endif\n}\n\n/*\n * Calculate start/end virtual columns for operating in block mode.\n */\n    static void\nget_op_vcol(\n    oparg_T\t*oap,\n    colnr_T\tredo_VIsual_vcol,\n    int\t\tinitial)    // when TRUE adjust position for 'selectmode'\n{\n    colnr_T\t    start, end;\n\n    if (VIsual_mode != Ctrl_V\n\t    || (!initial && oap->end.col < curwin->w_width))\n\treturn;\n\n    oap->block_mode = TRUE;\n\n    // prevent from moving onto a trail byte\n    if (has_mbyte)\n\tmb_adjustpos(curwin->w_buffer, &oap->end);\n\n    getvvcol(curwin, &(oap->start), &oap->start_vcol, NULL, &oap->end_vcol);\n\n    if (!redo_VIsual_busy)\n    {\n\tgetvvcol(curwin, &(oap->end), &start, NULL, &end);\n\n\tif (start < oap->start_vcol)\n\t    oap->start_vcol = start;\n\tif (end > oap->end_vcol)\n\t{\n\t    if (initial && *p_sel == 'e' && start >= 1\n\t\t\t\t    && start - 1 >= oap->end_vcol)\n\t\toap->end_vcol = start - 1;\n\t    else\n\t\toap->end_vcol = end;\n\t}\n    }\n\n    // if '$' was used, get oap->end_vcol from longest line\n    if (curwin->w_curswant == MAXCOL)\n    {\n\tcurwin->w_cursor.col = MAXCOL;\n\toap->end_vcol = 0;\n\tfor (curwin->w_cursor.lnum = oap->start.lnum;\n\t\tcurwin->w_cursor.lnum <= oap->end.lnum;\n\t\t\t\t\t++curwin->w_cursor.lnum)\n\t{\n\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &end);\n\t    if (end > oap->end_vcol)\n\t\toap->end_vcol = end;\n\t}\n    }\n    else if (redo_VIsual_busy)\n\toap->end_vcol = oap->start_vcol + redo_VIsual_vcol - 1;\n    // Correct oap->end.col and oap->start.col to be the\n    // upper-left and lower-right corner of the block area.\n    //\n    // (Actually, this does convert column positions into character\n    // positions)\n    curwin->w_cursor.lnum = oap->end.lnum;\n    coladvance(oap->end_vcol);\n    oap->end = curwin->w_cursor;\n\n    curwin->w_cursor = oap->start;\n    coladvance(oap->start_vcol);\n    oap->start = curwin->w_cursor;\n}\n\n// Information for redoing the previous Visual selection.\ntypedef struct {\n    int\t\trv_mode;\t// 'v', 'V', or Ctrl-V\n    linenr_T\trv_line_count;\t// number of lines\n    colnr_T\trv_vcol;\t// number of cols or end column\n    long\trv_count;\t// count for Visual operator\n    int\t\trv_arg;\t\t// extra argument\n} redo_VIsual_T;\n\n    static int\nis_ex_cmdchar(cmdarg_T *cap)\n{\n    return cap->cmdchar == ':'\n\t|| cap->cmdchar == K_COMMAND\n\t|| cap->cmdchar == K_SCRIPT_COMMAND;\n}\n\n/*\n * Handle an operator after Visual mode or when the movement is finished.\n * \"gui_yank\" is true when yanking text for the clipboard.\n */\n    void\ndo_pending_operator(cmdarg_T *cap, int old_col, int gui_yank)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\told_cursor;\n    int\t\tempty_region_error;\n    int\t\trestart_edit_save;\n#ifdef FEAT_LINEBREAK\n    int\t\tlbr_saved = curwin->w_p_lbr;\n#endif\n\n    // The visual area is remembered for redo\n    static redo_VIsual_T   redo_VIsual = {NUL, 0, 0, 0,0};\n\n    int\t\t    include_line_break = FALSE;\n\n#if defined(FEAT_CLIPBOARD)\n    // Yank the visual area into the GUI selection register before we operate\n    // on it and lose it forever.\n    // Don't do it if a specific register was specified, so that \"\"x\"*P works.\n    // This could call do_pending_operator() recursively, but that's OK\n    // because gui_yank will be TRUE for the nested call.\n    if ((clip_star.available || clip_plus.available)\n\t    && oap->op_type != OP_NOP\n\t    && !gui_yank\n\t    && VIsual_active\n\t    && !redo_VIsual_busy\n\t    && oap->regname == 0)\n\tclip_auto_select();\n#endif\n    old_cursor = curwin->w_cursor;\n\n    // If an operation is pending, handle it...\n    if ((finish_op || VIsual_active) && oap->op_type != OP_NOP)\n    {\n\t// Yank can be redone when 'y' is in 'cpoptions', but not when yanking\n\t// for the clipboard.\n\tint\tredo_yank = vim_strchr(p_cpo, CPO_YANK) != NULL && !gui_yank;\n\n#ifdef FEAT_LINEBREAK\n\t// Avoid a problem with unwanted linebreaks in block mode.\n\tif (curwin->w_p_lbr)\n\t    curwin->w_valid &= ~VALID_VIRTCOL;\n\tcurwin->w_p_lbr = FALSE;\n#endif\n\toap->is_VIsual = VIsual_active;\n\tif (oap->motion_force == 'V')\n\t    oap->motion_type = MLINE;\n\telse if (oap->motion_force == 'v')\n\t{\n\t    // If the motion was linewise, \"inclusive\" will not have been set.\n\t    // Use \"exclusive\" to be consistent.  Makes \"dvj\" work nice.\n\t    if (oap->motion_type == MLINE)\n\t\toap->inclusive = FALSE;\n\t    // If the motion already was characterwise, toggle \"inclusive\"\n\t    else if (oap->motion_type == MCHAR)\n\t\toap->inclusive = !oap->inclusive;\n\t    oap->motion_type = MCHAR;\n\t}\n\telse if (oap->motion_force == Ctrl_V)\n\t{\n\t    // Change line- or characterwise motion into Visual block mode.\n\t    if (!VIsual_active)\n\t    {\n\t\tVIsual_active = TRUE;\n\t\tVIsual = oap->start;\n\t    }\n\t    VIsual_mode = Ctrl_V;\n\t    VIsual_select = FALSE;\n\t    VIsual_reselect = FALSE;\n\t}\n\n\t// Only redo yank when 'y' flag is in 'cpoptions'.\n\t// Never redo \"zf\" (define fold).\n\tif ((redo_yank || oap->op_type != OP_YANK)\n\t\t&& ((!VIsual_active || oap->motion_force)\n\t\t    // Also redo Operator-pending Visual mode mappings\n\t\t    || (VIsual_active\n\t\t\t    && is_ex_cmdchar(cap) && oap->op_type != OP_COLON))\n\t\t&& cap->cmdchar != 'D'\n#ifdef FEAT_FOLDING\n\t\t&& oap->op_type != OP_FOLD\n\t\t&& oap->op_type != OP_FOLDOPEN\n\t\t&& oap->op_type != OP_FOLDOPENREC\n\t\t&& oap->op_type != OP_FOLDCLOSE\n\t\t&& oap->op_type != OP_FOLDCLOSEREC\n\t\t&& oap->op_type != OP_FOLDDEL\n\t\t&& oap->op_type != OP_FOLDDELREC\n#endif\n\t\t)\n\t{\n\t    prep_redo(oap->regname, cap->count0,\n\t\t    get_op_char(oap->op_type), get_extra_op_char(oap->op_type),\n\t\t    oap->motion_force, cap->cmdchar, cap->nchar);\n\t    if (cap->cmdchar == '/' || cap->cmdchar == '?') // was a search\n\t    {\n\t\t// If 'cpoptions' does not contain 'r', insert the search\n\t\t// pattern to really repeat the same command.\n\t\tif (vim_strchr(p_cpo, CPO_REDO) == NULL)\n\t\t    AppendToRedobuffLit(cap->searchbuf, -1);\n\t\tAppendToRedobuff(NL_STR);\n\t    }\n\t    else if (is_ex_cmdchar(cap))\n\t    {\n\t\t// do_cmdline() has stored the first typed line in\n\t\t// \"repeat_cmdline\".  When several lines are typed repeating\n\t\t// won't be possible.\n\t\tif (repeat_cmdline == NULL)\n\t\t    ResetRedobuff();\n\t\telse\n\t\t{\n\t\t    AppendToRedobuffLit(repeat_cmdline, -1);\n\t\t    AppendToRedobuff(NL_STR);\n\t\t    VIM_CLEAR(repeat_cmdline);\n\t\t}\n\t    }\n\t}\n\n\tif (redo_VIsual_busy)\n\t{\n\t    // Redo of an operation on a Visual area. Use the same size from\n\t    // redo_VIsual.rv_line_count and redo_VIsual.rv_vcol.\n\t    oap->start = curwin->w_cursor;\n\t    curwin->w_cursor.lnum += redo_VIsual.rv_line_count - 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    VIsual_mode = redo_VIsual.rv_mode;\n\t    if (redo_VIsual.rv_vcol == MAXCOL || VIsual_mode == 'v')\n\t    {\n\t\tif (VIsual_mode == 'v')\n\t\t{\n\t\t    if (redo_VIsual.rv_line_count <= 1)\n\t\t    {\n\t\t\tvalidate_virtcol();\n\t\t\tcurwin->w_curswant =\n\t\t\t\t     curwin->w_virtcol + redo_VIsual.rv_vcol - 1;\n\t\t    }\n\t\t    else\n\t\t\tcurwin->w_curswant = redo_VIsual.rv_vcol;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_curswant = MAXCOL;\n\t\t}\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    cap->count0 = redo_VIsual.rv_count;\n\t    if (redo_VIsual.rv_count != 0)\n\t\tcap->count1 = redo_VIsual.rv_count;\n\t    else\n\t\tcap->count1 = 1;\n\t}\n\telse if (VIsual_active)\n\t{\n\t    if (!gui_yank)\n\t    {\n\t\t// Save the current VIsual area for '< and '> marks, and \"gv\"\n\t\tcurbuf->b_visual.vi_start = VIsual;\n\t\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\t\tcurbuf->b_visual.vi_mode = VIsual_mode;\n\t\trestore_visual_mode();\n\t\tcurbuf->b_visual.vi_curswant = curwin->w_curswant;\n#ifdef FEAT_EVAL\n\t\tcurbuf->b_visual_mode_eval = VIsual_mode;\n#endif\n\t    }\n\n\t    // In Select mode, a linewise selection is operated upon like a\n\t    // characterwise selection.\n\t    // Special case: gH<Del> deletes the last line.\n\t    if (VIsual_select && VIsual_mode == 'V'\n\t\t\t\t\t    && cap->oap->op_type != OP_DELETE)\n\t    {\n\t\tif (LT_POS(VIsual, curwin->w_cursor))\n\t\t{\n\t\t    VIsual.col = 0;\n\t\t    curwin->w_cursor.col =\n\t\t\t       (colnr_T)STRLEN(ml_get(curwin->w_cursor.lnum));\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.col = 0;\n\t\t    VIsual.col = (colnr_T)STRLEN(ml_get(VIsual.lnum));\n\t\t}\n\t\tVIsual_mode = 'v';\n\t    }\n\t    // If 'selection' is \"exclusive\", backup one character for\n\t    // charwise selections.\n\t    else if (VIsual_mode == 'v')\n\t\tinclude_line_break = unadjust_for_sel();\n\n\t    oap->start = VIsual;\n\t    if (VIsual_mode == 'V')\n\t    {\n\t\toap->start.col = 0;\n\t\toap->start.coladd = 0;\n\t    }\n\t}\n\n\t// Set oap->start to the first position of the operated text, oap->end\n\t// to the end of the operated text.  w_cursor is equal to oap->start.\n\tif (LT_POS(oap->start, curwin->w_cursor))\n\t{\n#ifdef FEAT_FOLDING\n\t    // Include folded lines completely.\n\t    if (!VIsual_active)\n\t    {\n\t\tif (hasFolding(oap->start.lnum, &oap->start.lnum, NULL))\n\t\t    oap->start.col = 0;\n\t\tif ((curwin->w_cursor.col > 0 || oap->inclusive\n\t\t\t\t\t\t  || oap->motion_type == MLINE)\n\t\t\t&& hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum))\n\t\t    curwin->w_cursor.col = (colnr_T)STRLEN(ml_get_curline());\n\t    }\n#endif\n\t    oap->end = curwin->w_cursor;\n\t    curwin->w_cursor = oap->start;\n\n\t    // w_virtcol may have been updated; if the cursor goes back to its\n\t    // previous position w_virtcol becomes invalid and isn't updated\n\t    // automatically.\n\t    curwin->w_valid &= ~VALID_VIRTCOL;\n\t}\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Include folded lines completely.\n\t    if (!VIsual_active && oap->motion_type == MLINE)\n\t    {\n\t\tif (hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tNULL))\n\t\t    curwin->w_cursor.col = 0;\n\t\tif (hasFolding(oap->start.lnum, NULL, &oap->start.lnum))\n\t\t    oap->start.col = (colnr_T)STRLEN(ml_get(oap->start.lnum));\n\t    }\n#endif\n\t    oap->end = oap->start;\n\t    oap->start = curwin->w_cursor;\n\t}\n\n\t// Just in case lines were deleted that make the position invalid.\n\tcheck_pos(curwin->w_buffer, &oap->end);\n\toap->line_count = oap->end.lnum - oap->start.lnum + 1;\n\n\t// Set \"virtual_op\" before resetting VIsual_active.\n\tvirtual_op = virtual_active();\n\n\tif (VIsual_active || redo_VIsual_busy)\n\t{\n\t    get_op_vcol(oap, redo_VIsual.rv_vcol, TRUE);\n\n\t    if (!redo_VIsual_busy && !gui_yank)\n\t    {\n\t\t// Prepare to reselect and redo Visual: this is based on the\n\t\t// size of the Visual text\n\t\tresel_VIsual_mode = VIsual_mode;\n\t\tif (curwin->w_curswant == MAXCOL)\n\t\t    resel_VIsual_vcol = MAXCOL;\n\t\telse\n\t\t{\n\t\t    if (VIsual_mode != Ctrl_V)\n\t\t\tgetvvcol(curwin, &(oap->end),\n\t\t\t\t\t\t  NULL, NULL, &oap->end_vcol);\n\t\t    if (VIsual_mode == Ctrl_V || oap->line_count <= 1)\n\t\t    {\n\t\t\tif (VIsual_mode != Ctrl_V)\n\t\t\t    getvvcol(curwin, &(oap->start),\n\t\t\t\t\t\t&oap->start_vcol, NULL, NULL);\n\t\t\tresel_VIsual_vcol = oap->end_vcol - oap->start_vcol + 1;\n\t\t    }\n\t\t    else\n\t\t\tresel_VIsual_vcol = oap->end_vcol;\n\t\t}\n\t\tresel_VIsual_line_count = oap->line_count;\n\t    }\n\n\t    // can't redo yank (unless 'y' is in 'cpoptions') and \":\"\n\t    if ((redo_yank || oap->op_type != OP_YANK)\n\t\t    && oap->op_type != OP_COLON\n#ifdef FEAT_FOLDING\n\t\t    && oap->op_type != OP_FOLD\n\t\t    && oap->op_type != OP_FOLDOPEN\n\t\t    && oap->op_type != OP_FOLDOPENREC\n\t\t    && oap->op_type != OP_FOLDCLOSE\n\t\t    && oap->op_type != OP_FOLDCLOSEREC\n\t\t    && oap->op_type != OP_FOLDDEL\n\t\t    && oap->op_type != OP_FOLDDELREC\n#endif\n\t\t    && oap->motion_force == NUL\n\t\t    )\n\t    {\n\t\t// Prepare for redoing.  Only use the nchar field for \"r\",\n\t\t// otherwise it might be the second char of the operator.\n\t\tif (cap->cmdchar == 'g' && (cap->nchar == 'n'\n\t\t\t\t\t\t\t|| cap->nchar == 'N'))\n\t\t    prep_redo(oap->regname, cap->count0,\n\t\t\t    get_op_char(oap->op_type),\n\t\t\t    get_extra_op_char(oap->op_type),\n\t\t\t    oap->motion_force, cap->cmdchar, cap->nchar);\n\t\telse if (!is_ex_cmdchar(cap))\n\t\t{\n\t\t    int opchar = get_op_char(oap->op_type);\n\t\t    int extra_opchar = get_extra_op_char(oap->op_type);\n\t\t    int nchar = oap->op_type == OP_REPLACE ? cap->nchar : NUL;\n\n\t\t    // reverse what nv_replace() did\n\t\t    if (nchar == REPLACE_CR_NCHAR)\n\t\t\tnchar = CAR;\n\t\t    else if (nchar == REPLACE_NL_NCHAR)\n\t\t\tnchar = NL;\n\n\t\t    if (opchar == 'g' && extra_opchar == '@')\n\t\t\t// also repeat the count for 'operatorfunc'\n\t\t\tprep_redo_num2(oap->regname, 0L, NUL, 'v',\n\t\t\t\t     cap->count0, opchar, extra_opchar, nchar);\n\t\t    else\n\t\t\tprep_redo(oap->regname, 0L, NUL, 'v',\n\t\t\t\t\t\t  opchar, extra_opchar, nchar);\n\t\t}\n\t\tif (!redo_VIsual_busy)\n\t\t{\n\t\t    redo_VIsual.rv_mode = resel_VIsual_mode;\n\t\t    redo_VIsual.rv_vcol = resel_VIsual_vcol;\n\t\t    redo_VIsual.rv_line_count = resel_VIsual_line_count;\n\t\t    redo_VIsual.rv_count = cap->count0;\n\t\t    redo_VIsual.rv_arg = cap->arg;\n\t\t}\n\t    }\n\n\t    // oap->inclusive defaults to TRUE.\n\t    // If oap->end is on a NUL (empty line) oap->inclusive becomes\n\t    // FALSE.  This makes \"d}P\" and \"v}dP\" work the same.\n\t    if (oap->motion_force == NUL || oap->motion_type == MLINE)\n\t\toap->inclusive = TRUE;\n\t    if (VIsual_mode == 'V')\n\t\toap->motion_type = MLINE;\n\t    else\n\t    {\n\t\toap->motion_type = MCHAR;\n\t\tif (VIsual_mode != Ctrl_V && *ml_get_pos(&(oap->end)) == NUL\n\t\t\t&& (include_line_break || !virtual_op))\n\t\t{\n\t\t    oap->inclusive = FALSE;\n\t\t    // Try to include the newline, unless it's an operator\n\t\t    // that works on lines only.\n\t\t    if (*p_sel != 'o'\n\t\t\t    && !op_on_lines(oap->op_type)\n\t\t\t    && oap->end.lnum < curbuf->b_ml.ml_line_count)\n\t\t    {\n\t\t\t++oap->end.lnum;\n\t\t\toap->end.col = 0;\n\t\t\toap->end.coladd = 0;\n\t\t\t++oap->line_count;\n\t\t    }\n\t\t}\n\t    }\n\n\t    redo_VIsual_busy = FALSE;\n\n\t    // Switch Visual off now, so screen updating does\n\t    // not show inverted text when the screen is redrawn.\n\t    // With OP_YANK and sometimes with OP_COLON and OP_FILTER there is\n\t    // no screen redraw, so it is done here to remove the inverted\n\t    // part.\n\t    if (!gui_yank)\n\t    {\n\t\tVIsual_active = FALSE;\n\t\tsetmouse();\n\t\tmouse_dragging = 0;\n\t\tmay_clear_cmdline();\n\t\tif ((oap->op_type == OP_YANK\n\t\t\t    || oap->op_type == OP_COLON\n\t\t\t    || oap->op_type == OP_FUNCTION\n\t\t\t    || oap->op_type == OP_FILTER)\n\t\t\t&& oap->motion_force == NUL)\n\t\t{\n#ifdef FEAT_LINEBREAK\n\t\t    // make sure redrawing is correct\n\t\t    curwin->w_p_lbr = lbr_saved;\n#endif\n\t\t    redraw_curbuf_later(UPD_INVERTED);\n\t\t}\n\t    }\n\t}\n\n\t// Include the trailing byte of a multi-byte char.\n\tif (has_mbyte && oap->inclusive)\n\t{\n\t    int\t\tl;\n\n\t    l = (*mb_ptr2len)(ml_get_pos(&oap->end));\n\t    if (l > 1)\n\t\toap->end.col += l - 1;\n\t}\n\tcurwin->w_set_curswant = TRUE;\n\n\t// oap->empty is set when start and end are the same.  The inclusive\n\t// flag affects this too, unless yanking and the end is on a NUL.\n\toap->empty = (oap->motion_type == MCHAR\n\t\t    && (!oap->inclusive\n\t\t\t|| (oap->op_type == OP_YANK\n\t\t\t    && gchar_pos(&oap->end) == NUL))\n\t\t    && EQUAL_POS(oap->start, oap->end)\n\t\t    && !(virtual_op && oap->start.coladd != oap->end.coladd));\n\t// For delete, change and yank, it's an error to operate on an\n\t// empty region, when 'E' included in 'cpoptions' (Vi compatible).\n\tempty_region_error = (oap->empty\n\t\t\t\t&& vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL);\n\n\t// Force a redraw when operating on an empty Visual region, when\n\t// 'modifiable is off or creating a fold.\n\tif (oap->is_VIsual && (oap->empty || !curbuf->b_p_ma\n#ifdef FEAT_FOLDING\n\t\t    || oap->op_type == OP_FOLD\n#endif\n\t\t    ))\n\t{\n#ifdef FEAT_LINEBREAK\n\t    curwin->w_p_lbr = lbr_saved;\n#endif\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\n\t// If the end of an operator is in column one while oap->motion_type\n\t// is MCHAR and oap->inclusive is FALSE, we put op_end after the last\n\t// character in the previous line. If op_start is on or before the\n\t// first non-blank in the line, the operator becomes linewise\n\t// (strange, but that's the way vi does it).\n\tif (\t   oap->motion_type == MCHAR\n\t\t&& oap->inclusive == FALSE\n\t\t&& !(cap->retval & CA_NO_ADJ_OP_END)\n\t\t&& oap->end.col == 0\n\t\t&& (!oap->is_VIsual || *p_sel == 'o')\n\t\t&& !oap->block_mode\n\t\t&& oap->line_count > 1)\n\t{\n\t    oap->end_adjusted = TRUE;\t    // remember that we did this\n\t    --oap->line_count;\n\t    --oap->end.lnum;\n\t    if (inindent(0))\n\t\toap->motion_type = MLINE;\n\t    else\n\t    {\n\t\toap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t\tif (oap->end.col)\n\t\t{\n\t\t    --oap->end.col;\n\t\t    oap->inclusive = TRUE;\n\t\t}\n\t    }\n\t}\n\telse\n\t    oap->end_adjusted = FALSE;\n\n\tswitch (oap->op_type)\n\t{\n\tcase OP_LSHIFT:\n\tcase OP_RSHIFT:\n\t    op_shift(oap, TRUE, oap->is_VIsual ? (int)cap->count1 : 1);\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase OP_JOIN_NS:\n\tcase OP_JOIN:\n\t    if (oap->line_count < 2)\n\t\toap->line_count = 2;\n\t    if (curwin->w_cursor.lnum + oap->line_count - 1 >\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count)\n\t\tbeep_flush();\n\t    else\n\t    {\n\t\t(void)do_join(oap->line_count, oap->op_type == OP_JOIN,\n\t\t\t\t\t\t\t    TRUE, TRUE, TRUE);\n\t\tauto_format(FALSE, TRUE);\n\t    }\n\t    break;\n\n\tcase OP_DELETE:\n\t    VIsual_reselect = FALSE;\t    // don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\t(void)op_delete(oap);\n\t\t// save cursor line for undo if it wasn't saved yet\n\t\tif (oap->motion_type == MLINE && has_format_option(FO_AUTO)\n\t\t\t\t\t\t      && u_save_cursor() == OK)\n\t\t    auto_format(FALSE, TRUE);\n\t    }\n\t    break;\n\n\tcase OP_YANK:\n\t    if (empty_region_error)\n\t    {\n\t\tif (!gui_yank)\n\t\t{\n\t\t    vim_beep(BO_OPER);\n\t\t    CancelRedo();\n\t\t}\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\toap->excl_tr_ws = cap->cmdchar == 'z';\n\t\t(void)op_yank(oap, FALSE, !gui_yank);\n\t    }\n\t    check_cursor_col();\n\t    break;\n\n\tcase OP_CHANGE:\n\t    VIsual_reselect = FALSE;\t    // don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\t// This is a new edit command, not a restart.  Need to\n\t\t// remember it to make 'insertmode' work with mappings for\n\t\t// Visual mode.  But do this only once and not when typed and\n\t\t// 'insertmode' isn't set.\n\t\tif (p_im || !KeyTyped)\n\t\t    restart_edit_save = restart_edit;\n\t\telse\n\t\t    restart_edit_save = 0;\n\t\trestart_edit = 0;\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\t// Reset finish_op now, don't want it set inside edit().\n\t\tfinish_op = FALSE;\n\t\tif (op_change(oap))\t// will call edit()\n\t\t    cap->retval |= CA_COMMAND_BUSY;\n\t\tif (restart_edit == 0)\n\t\t    restart_edit = restart_edit_save;\n\t    }\n\t    break;\n\n\tcase OP_FILTER:\n\t    if (vim_strchr(p_cpo, CPO_FILTER) != NULL)\n\t\tAppendToRedobuff((char_u *)\"!\\r\");  // use any last used !cmd\n\t    else\n\t\tbangredo = TRUE;    // do_bang() will put cmd in redo buffer\n\t    // FALLTHROUGH\n\n\tcase OP_INDENT:\n\tcase OP_COLON:\n\n\t    // If 'equalprg' is empty, do the indenting internally.\n\t    if (oap->op_type == OP_INDENT && *get_equalprg() == NUL)\n\t    {\n\t\tif (curbuf->b_p_lisp)\n\t\t{\n\t\t    op_reindent(oap, get_lisp_indent);\n\t\t    break;\n\t\t}\n\t\top_reindent(oap,\n#ifdef FEAT_EVAL\n\t\t\t*curbuf->b_p_inde != NUL ? get_expr_indent :\n#endif\n\t\t\t    get_c_indent);\n\t\tbreak;\n\t    }\n\n\t    op_colon(oap);\n\t    break;\n\n\tcase OP_TILDE:\n\tcase OP_UPPER:\n\tcase OP_LOWER:\n\tcase OP_ROT13:\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t\top_tilde(oap);\n\t    check_cursor_col();\n\t    break;\n\n\tcase OP_FORMAT:\n#if defined(FEAT_EVAL)\n\t    if (*curbuf->b_p_fex != NUL)\n\t\top_formatexpr(oap);\t// use expression\n\t    else\n#endif\n\t    {\n\t\tif (*p_fp != NUL || *curbuf->b_p_fp != NUL)\n\t\t    op_colon(oap);\t\t// use external command\n\t\telse\n\t\t    op_format(oap, FALSE);\t// use internal function\n\t    }\n\t    break;\n\tcase OP_FORMAT2:\n\t    op_format(oap, TRUE);\t// use internal function\n\t    break;\n\n\tcase OP_FUNCTION:\n\t    {\n\t\tredo_VIsual_T   save_redo_VIsual = redo_VIsual;\n\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\t// call 'operatorfunc'\n\t\top_function(oap);\n\n\t\t// Restore the info for redoing Visual mode, the function may\n\t\t// invoke another operator and unintentionally change it.\n\t\tredo_VIsual = save_redo_VIsual;\n\t\tbreak;\n\t    }\n\n\tcase OP_INSERT:\n\tcase OP_APPEND:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\t// This is a new edit command, not a restart.  Need to\n\t\t// remember it to make 'insertmode' work with mappings for\n\t\t// Visual mode.  But do this only once.\n\t\trestart_edit_save = restart_edit;\n\t\trestart_edit = 0;\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\top_insert(oap, cap->count1);\n#ifdef FEAT_LINEBREAK\n\t\t// Reset linebreak, so that formatting works correctly.\n\t\tcurwin->w_p_lbr = FALSE;\n#endif\n\n\t\t// TODO: when inserting in several lines, should format all\n\t\t// the lines.\n\t\tauto_format(FALSE, TRUE);\n\n\t\tif (restart_edit == 0)\n\t\t    restart_edit = restart_edit_save;\n\t\telse\n\t\t    cap->retval |= CA_COMMAND_BUSY;\n\t    }\n\t    break;\n\n\tcase OP_REPLACE:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\t// Restore linebreak, so that when the user edits it looks as\n\t\t// before.\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\top_replace(oap, cap->nchar);\n\t    }\n\t    break;\n\n#ifdef FEAT_FOLDING\n\tcase OP_FOLD:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    foldCreate(oap->start.lnum, oap->end.lnum);\n\t    break;\n\n\tcase OP_FOLDOPEN:\n\tcase OP_FOLDOPENREC:\n\tcase OP_FOLDCLOSE:\n\tcase OP_FOLDCLOSEREC:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    opFoldRange(oap->start.lnum, oap->end.lnum,\n\t\t    oap->op_type == OP_FOLDOPEN\n\t\t\t\t\t    || oap->op_type == OP_FOLDOPENREC,\n\t\t    oap->op_type == OP_FOLDOPENREC\n\t\t\t\t\t  || oap->op_type == OP_FOLDCLOSEREC,\n\t\t\t\t\t  oap->is_VIsual);\n\t    break;\n\n\tcase OP_FOLDDEL:\n\tcase OP_FOLDDELREC:\n\t    VIsual_reselect = FALSE;\t// don't reselect now\n\t    deleteFold(oap->start.lnum, oap->end.lnum,\n\t\t\t       oap->op_type == OP_FOLDDELREC, oap->is_VIsual);\n\t    break;\n#endif\n\tcase OP_NR_ADD:\n\tcase OP_NR_SUB:\n\t    if (empty_region_error)\n\t    {\n\t\tvim_beep(BO_OPER);\n\t\tCancelRedo();\n\t    }\n\t    else\n\t    {\n\t\tVIsual_active = TRUE;\n#ifdef FEAT_LINEBREAK\n\t\tcurwin->w_p_lbr = lbr_saved;\n#endif\n\t\top_addsub(oap, cap->count1, redo_VIsual.rv_arg);\n\t\tVIsual_active = FALSE;\n\t    }\n\t    check_cursor_col();\n\t    break;\n\tdefault:\n\t    clearopbeep(oap);\n\t}\n\tvirtual_op = MAYBE;\n\tif (!gui_yank)\n\t{\n\t    // if 'sol' not set, go back to old column for some commands\n\t    if (!p_sol && oap->motion_type == MLINE && !oap->end_adjusted\n\t\t    && (oap->op_type == OP_LSHIFT || oap->op_type == OP_RSHIFT\n\t\t\t\t\t\t|| oap->op_type == OP_DELETE))\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tcurwin->w_p_lbr = FALSE;\n#endif\n\t\tcoladvance(curwin->w_curswant = old_col);\n\t    }\n\t}\n\telse\n\t{\n\t    curwin->w_cursor = old_cursor;\n\t}\n\toap->block_mode = FALSE;\n\tclearop(oap);\n\tmotion_force = NUL;\n    }\n#ifdef FEAT_LINEBREAK\n    curwin->w_p_lbr = lbr_saved;\n#endif\n}\n", "\" Tests for 'virtualedit'.\n\nfunc Test_yank_move_change()\n  new\n  call setline(1, [\n\t\\ \"func foo() error {\",\n\t\\ \"\\tif n, err := bar();\",\n\t\\ \"\\terr != nil {\",\n\t\\ \"\\t\\treturn err\",\n\t\\ \"\\t}\",\n\t\\ \"\\tn = n * n\",\n\t\\ ])\n  set virtualedit=all\n  set ts=4\n  function! MoveSelectionDown(count) abort\n    normal! m`\n    silent! exe \"'<,'>move'>+\".a:count\n    norm! ``\n  endfunction\n\n  xmap ]e :<C-U>call MoveSelectionDown(v:count1)<CR>\n  2\n  normal 2gg\n  normal J\n  normal jVj\n  normal ]e\n  normal ce\n  bwipe!\n  set virtualedit=\n  set ts=8\nendfunc\n\nfunc Test_paste_end_of_line()\n  new\n  set virtualedit=all\n  call setline(1, ['456', '123'])\n  normal! gg0\"ay$\n  exe \"normal! 2G$lllA\\<C-O>:normal! \\\"agP\\r\"\n  call assert_equal('123456', getline(2))\n\n  bwipe!\n  set virtualedit=\nendfunc\n\nfunc Test_replace_end_of_line()\n  new\n  set virtualedit=all\n  call setline(1, range(20))\n  exe \"normal! gg2jv10lr-\"\n  call assert_equal([\"1\", \"-----------\", \"3\"], getline(2,4))\n  call setline(1, range(20))\n  exe \"normal! gg2jv10lr\\<c-k>hh\"\n  call assert_equal([\"1\", \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\", \"3\"], getline(2,4))\n\n  bwipe!\n  set virtualedit=\nendfunc\n\nfunc Test_edit_CTRL_G()\n  new\n  set virtualedit=insert\n  call setline(1, ['123', '1', '12'])\n  exe \"normal! ggA\\<c-g>jx\\<c-g>jx\"\n  call assert_equal(['123', '1  x', '12 x'], getline(1,'$'))\n\n  set virtualedit=all\n  %d_\n  call setline(1, ['1', '12'])\n  exe \"normal! ggllix\\<c-g>jx\"\n  call assert_equal(['1 x', '12x'], getline(1,'$'))\n\n\n  bwipe!\n  set virtualedit=\nendfunc\n\nfunc Test_edit_change()\n  new\n  set virtualedit=all\n  call setline(1, \"\\t\u248c\")\n  normal Cx\n  call assert_equal('x', getline(1))\n  \" Do a visual block change\n  call setline(1, ['a', 'b', 'c'])\n  exe \"normal gg3l\\<C-V>2jcx\"\n  call assert_equal(['a  x', 'b  x', 'c  x'], getline(1, '$'))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Tests for pasting at the beginning, end and middle of a tab character\n\" in virtual edit mode.\nfunc Test_paste_in_tab()\n  new\n  call append(0, '')\n  set virtualedit=all\n\n  \" Tests for pasting a register with characterwise mode type\n  call setreg('\"', 'xyz', 'c')\n\n  \" paste (p) unnamed register at the beginning of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 0)\n  normal p\n  call assert_equal('a xyz      b', getline(1))\n\n  \" paste (P) unnamed register at the beginning of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 0)\n  normal P\n  call assert_equal(\"axyz\\tb\", getline(1))\n\n  \" paste (p) unnamed register at the end of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 6)\n  normal p\n  call assert_equal(\"a\\txyzb\", getline(1))\n\n  \" paste (P) unnamed register at the end of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 6)\n  normal P\n  call assert_equal('a      xyz b', getline(1))\n\n  \" Tests for pasting a register with blockwise mode type\n  call setreg('\"', 'xyz', 'b')\n\n  \" paste (p) unnamed register at the beginning of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 0)\n  normal p\n  call assert_equal('a xyz      b', getline(1))\n\n  \" paste (P) unnamed register at the beginning of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 0)\n  normal P\n  call assert_equal(\"axyz\\tb\", getline(1))\n\n  \" paste (p) unnamed register at the end of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 6)\n  normal p\n  call assert_equal(\"a\\txyzb\", getline(1))\n\n  \" paste (P) unnamed register at the end of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 6)\n  normal P\n  call assert_equal('a      xyz b', getline(1))\n\n  \" Tests for pasting with gp and gP in virtual edit mode\n\n  \" paste (gp) unnamed register at the beginning of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 0)\n  normal gp\n  call assert_equal('a xyz      b', getline(1))\n  call assert_equal([0, 1, 12, 0, 12], getcurpos())\n\n  \" paste (gP) unnamed register at the beginning of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 0)\n  normal gP\n  call assert_equal(\"axyz\\tb\", getline(1))\n  call assert_equal([0, 1, 5, 0, 5], getcurpos())\n\n  \" paste (gp) unnamed register at the end of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 6)\n  normal gp\n  call assert_equal(\"a\\txyzb\", getline(1))\n  call assert_equal([0, 1, 6, 0, 12], getcurpos())\n\n  \" paste (gP) unnamed register at the end of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 6)\n  normal gP\n  call assert_equal('a      xyz b', getline(1))\n  call assert_equal([0, 1, 12, 0, 12], getcurpos())\n\n  \" Tests for pasting a named register\n  let @r = 'xyz'\n\n  \" paste (gp) named register in the middle of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 2)\n  normal \"rgp\n  call assert_equal('a   xyz    b', getline(1))\n  call assert_equal([0, 1, 8, 0, 8], getcurpos())\n\n  \" paste (gP) named register in the middle of a tab\n  call setline(1, \"a\\tb\")\n  call cursor(1, 2, 2)\n  normal \"rgP\n  call assert_equal('a  xyz     b', getline(1))\n  call assert_equal([0, 1, 7, 0, 7], getcurpos())\n\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test for yanking a few spaces within a tab to a register\nfunc Test_yank_in_tab()\n  new\n  let @r = ''\n  call setline(1, \"a\\tb\")\n  set virtualedit=all\n  call cursor(1, 2, 2)\n  normal \"ry5l\n  call assert_equal('     ', @r)\n\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Insert \"keyword keyw\", ESC, C CTRL-N, shows \"keyword ykeyword\".\n\" Repeating CTRL-N fixes it. (Mary Ellen Foster)\nfunc Test_ve_completion()\n  new\n  set completeopt&vim\n  set virtualedit=all\n  exe \"normal ikeyword keyw\\<Esc>C\\<C-N>\"\n  call assert_equal('keyword keyword', getline(1))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Using \"C\" then then <CR> moves the last remaining character to the next\n\" line.  (Mary Ellen Foster)\nfunc Test_ve_del_to_eol()\n  new\n  set virtualedit=all\n  call append(0, 'all your base are belong to us')\n  call search('are', 'w')\n  exe \"normal C\\<CR>are belong to vim\"\n  call assert_equal(['all your base ', 'are belong to vim'], getline(1, 2))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" When past the end of a line that ends in a single character \"b\" skips\n\" that word.\nfunc Test_ve_b_past_eol()\n  new\n  set virtualedit=all\n  call append(0, '1 2 3 4 5 6')\n  normal gg^$15lbC7\n  call assert_equal('1 2 3 4 5 7', getline(1))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Make sure 'i', 'C', 'a', 'A' and 'D' works\nfunc Test_ve_ins_del()\n  new\n  set virtualedit=all\n  call append(0, [\"'i'\", \"'C'\", \"'a'\", \"'A'\", \"'D'\"])\n  call cursor(1, 1)\n  normal $4lix\n  call assert_equal(\"'i'   x\", getline(1))\n  call cursor(2, 1)\n  normal $4lCx\n  call assert_equal(\"'C'   x\", getline(2))\n  call cursor(3, 1)\n  normal $4lax\n  call assert_equal(\"'a'    x\", getline(3))\n  call cursor(4, 1)\n  normal $4lAx\n  call assert_equal(\"'A'x\", getline(4))\n  call cursor(5, 1)\n  normal $4lDix\n  call assert_equal(\"'D'   x\", getline(5))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test for yank bug reported by Mark Waggoner.\nfunc Test_yank_block()\n  new\n  set virtualedit=block\n  call append(0, repeat(['this is a test'], 3))\n  exe \"normal gg^2w\\<C-V>3jy\"\n  call assert_equal(\"a\\na\\na\\n \", @\")\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test \"r\" beyond the end of the line\nfunc Test_replace_after_eol()\n  new\n  set virtualedit=all\n  call append(0, '\"r\"')\n  normal gg$5lrxa\n  call assert_equal('\"r\"    x', getline(1))\n  \" visual block replace\n  %d _\n  call setline(1, ['a', '', 'b'])\n  exe \"normal 2l\\<C-V>2jrx\"\n  call assert_equal(['a x', '  x', 'b x'], getline(1, '$'))\n  \" visual characterwise selection replace after eol\n  %d _\n  call setline(1, 'a')\n  normal 4lv2lrx\n  call assert_equal('a   xxx', getline(1))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test \"r\" on a tab\n\" Note that for this test, 'ts' must be 8 (the default).\nfunc Test_replace_on_tab()\n  new\n  set virtualedit=all\n  call append(0, \"'r'\\t\")\n  normal gg^5lrxAy\n  call assert_equal(\"'r'  x  y\", getline(1))\n  call setline(1, 'aaaaaaaaaaaa')\n  exe \"normal! gg2lgR\\<Tab>\"\n  call assert_equal(\"aa\\taaaa\", getline(1))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test to make sure 'x' can delete control characters\nfunc Test_ve_del_ctrl_chars()\n  new\n  set virtualedit=all\n  call append(0, \"a\\<C-V>b\\<CR>sd\")\n  set display=uhex\n  normal gg^xxxxxxi[text]\n  set display=\n  call assert_equal('[text]', getline(1))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test for ^Y/^E due to bad w_virtcol value, reported by\n\" Roy <royl@netropolis.net>.\nfunc Test_ins_copy_char()\n  new\n  set virtualedit=all\n  call append(0, 'abcv8efi.him2kl')\n  exe \"normal gg^O\\<Esc>3li\\<C-E>\\<Esc>4li\\<C-E>\\<Esc>4li\\<C-E>   <--\"\n  exe \"normal j^o\\<Esc>4li\\<C-Y>\\<Esc>4li\\<C-Y>\\<Esc>4li\\<C-Y>   <--\"\n  call assert_equal('   v   i   m   <--', getline(1))\n  call assert_equal('    8   .   2   <--', getline(3))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test for yanking and pasting using the small delete register\nfunc Test_yank_paste_small_del_reg()\n  new\n  set virtualedit=all\n  call append(0, \"foo, bar\")\n  normal ggdewve\"-p\n  call assert_equal(', foo', getline(1))\n  bwipe!\n  set virtualedit=\nendfunc\n\n\" Test for delete that breaks a tab into spaces\nfunc Test_delete_break_tab()\n  new\n  call setline(1, \"one\\ttwo\")\n  set virtualedit=all\n  normal v3ld\n  call assert_equal('    two', getline(1))\n  set virtualedit&\n  close!\nendfunc\n\n\" Test for using <BS>, <C-W> and <C-U> in virtual edit mode\n\" to erase character, word and line.\nfunc Test_ve_backspace()\n  new\n  call setline(1, 'sample')\n  set virtualedit=all\n  set backspace=indent,eol,start\n  exe \"normal 15|i\\<BS>\\<BS>\"\n  call assert_equal([0, 1, 7, 5], getpos('.'))\n  exe \"normal 15|i\\<C-W>\"\n  call assert_equal([0, 1, 6, 0], getpos('.'))\n  exe \"normal 15|i\\<C-U>\"\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  set backspace&\n  set virtualedit&\n  close!\nendfunc\n\n\" Test for delete (x) on EOL character and after EOL\nfunc Test_delete_past_eol()\n  new\n  call setline(1, \"ab\")\n  set virtualedit=all\n  exe \"normal 2lx\"\n  call assert_equal('ab', getline(1))\n  exe \"normal 10lx\"\n  call assert_equal('ab', getline(1))\n  set virtualedit&\n  bw!\nendfunc\n\n\" After calling s:TryVirtualeditReplace(), line 1 will contain one of these\n\" two strings, depending on whether virtual editing is on or off.\nlet s:result_ve_on  = 'a      x'\nlet s:result_ve_off = 'x'\n\n\" Utility function for Test_global_local_virtualedit()\nfunc s:TryVirtualeditReplace()\n  call setline(1, 'a')\n  normal gg7l\n  normal rx\nendfunc\n\n\" Test for :set and :setlocal\nfunc Test_global_local_virtualedit()\n  new\n\n  \" Verify that 'virtualedit' is initialized to empty, can be set globally to\n  \" all and to empty, and can be set locally to all and to empty.\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  set ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  set ve=\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  setlocal ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  setlocal ve=\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n\n  \" Verify that :set affects multiple windows.\n  split\n  set ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  wincmd p\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  set ve=\n  wincmd p\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  bwipe!\n\n  \" Verify that :setlocal affects only the current window.\n  new\n  split\n  setlocal ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  wincmd p\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  bwipe!\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n\n  \" Verify that the buffer 'virtualedit' state follows the global value only\n  \" when empty and that \"none\" works as expected.\n  \"\n  \"          'virtualedit' State\n  \" +--------+--------------------------+\n  \" | Local  |          Global          |\n  \" |        |                          |\n  \" +--------+--------+--------+--------+\n  \" |        | \"\"     | \"all\"  | \"none\" |\n  \" +--------+--------+--------+--------+\n  \" | \"\"     |  off   |  on    |  off   |\n  \" | \"all\"  |  on    |  on    |  on    |\n  \" | \"none\" |  off   |  off   |  off   |\n  \" +--------+--------+--------+--------+\n  new\n\n  setglobal ve=\n  setlocal ve=\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  setlocal ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  setlocal ve=none\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n\n  setglobal ve=all\n  setlocal ve=\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  setlocal ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  setlocal ve=none\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  setlocal ve=NONE\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n\n  setglobal ve=none\n  setlocal ve=\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  setlocal ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  setlocal ve=none\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n\n  bwipe!\n\n  \" Verify that the 'virtualedit' state is copied to new windows.\n  new\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  split\n  setlocal ve=all\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  split\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_on, getline(1))\n  setlocal ve=\n  split\n  call s:TryVirtualeditReplace()\n  call assert_equal(s:result_ve_off, getline(1))\n  bwipe!\n\n  setlocal virtualedit&\n  set virtualedit&\nendfunc\n\nfunc Test_virtualedit_mouse()\n  let save_mouse = &mouse\n  set mouse=a\n  set virtualedit=all\n  new\n\n  call setline(1, [\"text\\tword\"])\n  redraw\n  call test_setmouse(1, 4)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 4, 0, 4], getcurpos())\n  call test_setmouse(1, 5)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 5, 0, 5], getcurpos())\n  call test_setmouse(1, 6)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 5, 1, 6], getcurpos())\n  call test_setmouse(1, 7)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 5, 2, 7], getcurpos())\n  call test_setmouse(1, 8)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 5, 3, 8], getcurpos())\n  call test_setmouse(1, 9)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 6, 0, 9], getcurpos())\n  call test_setmouse(1, 15)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 10, 2, 15], getcurpos())\n\n  bwipe!\n  let &mouse = save_mouse\n  set virtualedit&\nendfunc\n\n\" this was replacing the NUL at the end of the line \nfunc Test_virtualedit_replace_after_tab()\n  new\n  s/\\v/\t0\n  set ve=all\n  let @\" = ''\n  sil! norm vPvr0\n  \n  call assert_equal(\"\\t0\", getline(1))\n  set ve&\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/ops.c", "src/testdir/test_virtualedit.vim", "src/version.c"], "buggy_code_start_loc": [1175, 574, 705], "buggy_code_end_loc": [1211, 574, 705], "fixing_code_start_loc": [1176, 575, 706], "fixing_code_end_loc": [1219, 589, 708], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0483.", "other": {"cve": {"id": "CVE-2022-3234", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-17T22:15:09.377", "lastModified": "2023-05-03T12:16:15.780", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0483."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en Heap en el repositorio de GitHub vim/vim anterior a la versi\u00f3n 9.0.0483"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0483", "matchCriteriaId": "6549BB66-1BA8-426D-85E8-51FE5A839ECF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/c249913edc35c0e666d783bfc21595cf9f7d9e0d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/90fdf374-bf04-4386-8a23-38c83b88f0da", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/c249913edc35c0e666d783bfc21595cf9f7d9e0d"}}