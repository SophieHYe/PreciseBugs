{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/nn_ops.cc.\n\n#define USE_EIGEN_TENSOR\n#define EIGEN_USE_THREADS\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define EIGEN_USE_GPU\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#include \"tensorflow/core/kernels/conv_ops.h\"\n\n#include <string.h>\n\n#include <atomic>\n#include <map>\n#include <vector>\n\n#include \"absl/synchronization/blocking_counter.h\"\n#include \"tensorflow/core/framework/allocator.h\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/kernel_shape_util.h\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_slice.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/conv_2d.h\"\n#include \"tensorflow/core/kernels/deep_conv2d.h\"\n#include \"tensorflow/core/kernels/ops_util.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/array_slice.h\"\n#include \"tensorflow/core/lib/strings/numbers.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/util/padding.h\"\n#include \"tensorflow/core/util/tensor_format.h\"\n#include \"tensorflow/core/util/use_cudnn.h\"\n\n#ifdef TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS\n#include \"tensorflow/core/kernels/xsmm_conv2d.h\"\n#endif\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/conv_ops_gpu.h\"\n#include \"tensorflow/core/platform/stream_executor.h\"\n#include \"tensorflow/core/protobuf/autotuning.pb.h\"\n#include \"tensorflow/core/util/proto/proto_utils.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#if GOOGLE_CUDA\n#include \"tensorflow/stream_executor/gpu/gpu_asm_opts.h\"\n#include \"tensorflow/stream_executor/gpu/redzone_allocator.h\"\n#include \"tensorflow/stream_executor/tf_allocator_adapter.h\"\n#endif  // GOOGLE_CUDA\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\nnamespace {\ntemplate <typename Device, typename T>\nstruct LaunchGeneric {\n  void operator()(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int row_stride, int col_stride,\n                  int row_dilation, int col_dilation, const Padding& padding,\n                  const std::vector<int64>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    CHECK(data_format == FORMAT_NHWC) << \"Generic conv implementation only \"\n                                         \"supports NHWC tensor format for now.\";\n    if (filter.dim_size(0) == 1 && filter.dim_size(1) == 1 && row_stride == 1 &&\n        col_stride == 1 && (padding == SAME || padding == VALID)) {\n      // For 1x1 kernel, the 2D convolution is reduced to matrix\n      // multiplication.\n      //\n      // TODO(vrv): We should be able to call SpatialConvolution\n      // and it will produce the same result, but doing so\n      // led to NaNs during training.  Using matmul instead for now.\n      int conv_width = 1;  // Width for the convolution step.\n      for (int i = 0; i < 3; ++i) {\n        conv_width *= output->dim_size(i);\n      }\n\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;\n      dim_pair[0] = Eigen::IndexPair<Eigen::DenseIndex>(1, 0);\n      functor::MatMulConvFunctor<Device, T>()(\n          ctx->eigen_device<Device>(),\n          output->shaped<T, 2>({conv_width, filter.dim_size(3)}),\n          input.shaped<T, 2>({conv_width, filter.dim_size(2)}),\n          filter.shaped<T, 2>({filter.dim_size(2), filter.dim_size(3)}),\n          dim_pair);\n    } else if (filter.dim_size(0) == input.dim_size(1) &&\n               filter.dim_size(1) == input.dim_size(2) && row_dilation == 1 &&\n               col_dilation == 1 && padding == VALID) {\n      // If the input data and filter have the same height/width,\n      // the 2D convolution is reduced to matrix multiplication.\n      const int k =  // Length of reduction dimension.\n          filter.dim_size(0) * filter.dim_size(1) * filter.dim_size(2);\n\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;\n      dim_pair[0] = Eigen::IndexPair<Eigen::DenseIndex>(1, 0);\n      functor::MatMulConvFunctor<Device, T>()(\n          ctx->eigen_device<Device>(),\n          output->shaped<T, 2>({input.dim_size(0), filter.dim_size(3)}),\n          input.shaped<T, 2>({input.dim_size(0), k}),\n          filter.shaped<T, 2>({k, filter.dim_size(3)}), dim_pair);\n    } else {\n      if (padding == EXPLICIT) {\n        functor::SpatialConvolution<Device, T>()(\n            ctx->eigen_device<Device>(), output->tensor<T, 4>(),\n            input.tensor<T, 4>(), filter.tensor<T, 4>(), row_stride, col_stride,\n            row_dilation, col_dilation, static_cast<int>(explicit_paddings[2]),\n            static_cast<int>(explicit_paddings[3]),\n            static_cast<int>(explicit_paddings[4]),\n            static_cast<int>(explicit_paddings[5]));\n      } else {\n        functor::SpatialConvolution<Device, T>()(\n            ctx->eigen_device<Device>(), output->tensor<T, 4>(),\n            input.tensor<T, 4>(), filter.tensor<T, 4>(), row_stride, col_stride,\n            row_dilation, col_dilation, BrainPadding2EigenPadding(padding));\n      }\n    }\n  }\n};\n\n// Compute grouped 2D convolutions on CPU. Unlike grouped convolution\n// implementation in cuDNN this is faaaaaar from optimal and needs more work\n// to deliver competitive performance. Currently it exists to close the feature\n// parity gap between convolution operations on different devices.\ntemplate <typename T>\nstruct LaunchGrouped {\n  void operator()(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int row_stride, int col_stride,\n                  int row_dilation, int col_dilation, const Padding& padding,\n                  const std::vector<int64>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    DCHECK(data_format == FORMAT_NHWC)\n        << \"Grouped conv implementation only \"\n           \"supports NHWC tensor format for now.\";\n\n    const int64 in_depth = input.dim_size(3);\n    const int64 patch_depth = filter.dim_size(2);\n    const int64 num_groups = in_depth / patch_depth;\n\n    // Shuffle input/filter tensors to have group as a leading dimension.\n    std::array<int64, 5> shuffle({3, 0, 1, 2, 4});\n\n    // Compute pre shuffle dimemnsions.\n    auto pre_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {\n      return {tensor.dim_size(0), tensor.dim_size(1), tensor.dim_size(2),\n              num_groups, tensor.dim_size(3) / num_groups};\n    };\n\n    // Compute post shuffle dimemnsions.\n    auto post_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {\n      return {num_groups, tensor.dim_size(0), tensor.dim_size(1),\n              tensor.dim_size(2), tensor.dim_size(3) / num_groups};\n    };\n\n    auto& device = ctx->eigen_device<CPUDevice>();\n\n    absl::BlockingCounter shuffles_completed(2);\n    auto on_shuffled = [&]() { shuffles_completed.DecrementCount(); };\n\n    // Shuffle input into temporary tensor.\n    Tensor input_shuffled(input.dtype(), TensorShape(post_shuffle(input)));\n    input_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        input.shaped<T, 5>(pre_shuffle(input)).shuffle(shuffle);\n\n    // Shuffle filter into temporary tensor.\n    Tensor filter_shuffled(filter.dtype(), TensorShape(post_shuffle(filter)));\n    filter_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        filter.shaped<T, 5>(pre_shuffle(filter)).shuffle(shuffle);\n\n    // Wait for the completion of input/filter shuffles.\n    shuffles_completed.Wait();\n\n    // Write group convolution results into temporary output tensor.\n    Tensor output_shuffled(output->dtype(), TensorShape(post_shuffle(*output)));\n\n    for (int64 i = 0; i < num_groups; ++i) {\n      // TODO(ezhulenev): Run this loop using `parallelFor` (regular parallelFor\n      // will lead to deadlock, SpatialConvolution has to use async Eigen\n      // assignment). This requires small changes to Eigen to support async\n      // exeuction for tensor chipping operation.\n\n      // TODO(ezhulenev): Grouped convolution should also support 1x1 filter\n      // optimization.\n\n      auto input_slice = input_shuffled.tensor<T, 5>().template chip<0>(i);\n      auto filter_slice = filter_shuffled.tensor<T, 5>().template chip<0>(i);\n      auto output_slice = output_shuffled.tensor<T, 5>().template chip<0>(i);\n\n      if (padding == EXPLICIT) {\n        functor::SpatialConvolution<CPUDevice, T>()(\n            ctx->eigen_device<CPUDevice>(), output_slice, input_slice,\n            filter_slice, row_stride, col_stride, row_dilation, col_dilation,\n            static_cast<int>(explicit_paddings[2]),\n            static_cast<int>(explicit_paddings[3]),\n            static_cast<int>(explicit_paddings[4]),\n            static_cast<int>(explicit_paddings[5]));\n      } else {\n        functor::SpatialConvolution<CPUDevice, T>()(\n            ctx->eigen_device<CPUDevice>(), output_slice, input_slice,\n            filter_slice, row_stride, col_stride, row_dilation, col_dilation,\n            BrainPadding2EigenPadding(padding));\n      }\n    }\n\n    // Shuffle temporary output back into pre-shuffled shape.\n    std::array<int64, 5> rev_shuffle({1, 2, 3, 0, 4});\n    output->shaped<T, 5>(pre_shuffle(*output)).device(device) =\n        output_shuffled.tensor<T, 5>().shuffle(rev_shuffle);\n  }\n};\n\n}  // namespace\n\ntemplate <typename T>\nstruct LaunchConv2DOp<CPUDevice, T> {\n  void operator()(OpKernelContext* ctx, bool use_cudnn, bool cudnn_use_autotune,\n                  const Tensor& input, const Tensor& filter, int row_dilation,\n                  int col_dilation, int row_stride, int col_stride,\n                  const Padding& padding,\n                  const std::vector<int64>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    if (data_format != FORMAT_NHWC) {\n      ctx->SetStatus(errors::Unimplemented(\n          \"The Conv2D op currently only supports the NHWC tensor format on the \"\n          \"CPU. The op was given the format: \",\n          ToString(data_format)));\n      return;\n    }\n\n    for (int64 explicit_padding : explicit_paddings) {\n      if (!FastBoundsCheck(explicit_padding, std::numeric_limits<int>::max())) {\n        ctx->SetStatus(errors::InvalidArgument(\"filter too large\"));\n        return;\n      }\n    }\n\n    const int64 in_depth = input.dim_size(3);\n    const int64 out_depth = output->dim_size(3);\n    const int64 patch_depth = filter.dim_size(2);\n\n    if (in_depth % patch_depth != 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"input depth must be evenly divisible by filter depth: \", in_depth,\n          \" vs \", patch_depth));\n      return;\n    }\n\n    const int64 num_groups = in_depth / patch_depth;\n    if (out_depth % num_groups != 0 || out_depth < num_groups) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"output depth must be evenly divisible by number of groups: \",\n          out_depth, \" vs \", num_groups));\n      return;\n    }\n\n    if (in_depth != patch_depth) {\n      LaunchGrouped<T>()(ctx, input, filter, row_stride, col_stride,\n                         row_dilation, col_dilation, padding, explicit_paddings,\n                         output, data_format);\n    } else {\n      LaunchGeneric<CPUDevice, T>()(ctx, input, filter, row_stride, col_stride,\n                                    row_dilation, col_dilation, padding,\n                                    explicit_paddings, output, data_format);\n    }\n  }\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\ntemplate <>\nstruct LaunchConv2DOp<GPUDevice, int32> {\n  void operator()(OpKernelContext* ctx, bool use_cudnn, bool cudnn_use_autotune,\n                  const Tensor& input, const Tensor& filter, int row_dilation,\n                  int col_dilation, int row_stride, int col_stride,\n                  const Padding& padding,\n                  const std::vector<int64>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    if (data_format != FORMAT_NHWC) {\n      ctx->SetStatus(\n          errors::Unimplemented(\"The Conv2D op currently only supports the \"\n                                \"NHWC tensor format for integer types. \"\n                                \"The op was given the format: \",\n                                ToString(data_format)));\n      return;\n    }\n    const int64 in_depth = GetTensorDim(input, data_format, 'C');\n    OP_REQUIRES(ctx, in_depth == filter.dim_size(2),\n                errors::Unimplemented(\n                    \"The Conv2D op currently does not support grouped \"\n                    \"convolutions for integer types. A grouped convolution was \"\n                    \"attempted to be run because the input depth of \",\n                    in_depth, \" does not match the filter input depth of \",\n                    filter.dim_size(2)));\n\n    for (int64 explicit_padding : explicit_paddings) {\n      if (!FastBoundsCheck(explicit_padding, std::numeric_limits<int>::max())) {\n        ctx->SetStatus(errors::InvalidArgument(\"filter too large\"));\n        return;\n      }\n    }\n    LaunchGeneric<GPUDevice, int32>()(\n        ctx, input, filter, row_stride, col_stride, row_dilation, col_dilation,\n        padding, explicit_paddings, output, data_format);\n  }\n};\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename Device, typename T>\nclass LaunchDeepConvOp {\n public:\n  static bool Run(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int batch, int input_rows,\n                  int input_cols, int in_depth, int filter_rows,\n                  int filter_cols, int pad_rows, int pad_cols, int out_rows,\n                  int /*out_cols*/, int /*out_depth*/, int /*dilation_rows*/,\n                  int /*dilation_cols*/, int /*stride_rows*/,\n                  int /*stride_cols*/, Tensor* /*output*/,\n                  TensorFormat /*data_format*/) {\n    return false;\n  }\n};\n\n// Conditionally launches DeepConv operation based on convolution parameters.\ntemplate <>\nclass LaunchDeepConvOp<CPUDevice, float> {\n public:\n  static bool Run(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int batch, int input_rows,\n                  int input_cols, int in_depth, int filter_rows,\n                  int filter_cols, int pad_rows, int pad_cols, int out_rows,\n                  int out_cols, int out_depth, int dilation_rows,\n                  int dilation_cols, int stride_rows, int stride_cols,\n                  Tensor* output, TensorFormat data_format) {\n    if (data_format != FORMAT_NHWC || dilation_rows != 1 ||\n        dilation_cols != 1 ||\n        !CanUseDeepConv2D(stride_rows, stride_cols, filter_rows, filter_cols,\n                          in_depth, out_depth, out_rows, out_cols)) {\n      return false;\n    }\n\n    Conv2DArgs args;\n    args.batch = batch;\n    args.in_rows = input_rows;\n    args.in_cols = input_cols;\n    args.in_depth = in_depth;\n    args.filter_rows = filter_rows;\n    args.filter_cols = filter_cols;\n    args.pad_rows = pad_rows;\n    args.pad_cols = pad_cols;\n    args.out_rows = out_rows;\n    args.out_cols = out_cols;\n    args.out_depth = out_depth;\n\n    auto input_ptr = input.template flat<float>().data();\n    auto filter_ptr = filter.template flat<float>().data();\n    auto output_ptr = output->template flat<float>().data();\n\n    functor::DeepConv2D<CPUDevice, float>()(ctx, args, input_ptr, filter_ptr,\n                                            output_ptr);\n    return true;\n  }\n};\n\n#ifdef TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS\ntemplate <typename Device, typename T>\nclass LaunchXsmmConvOp {\n public:\n  static bool Run(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int batch, int input_rows,\n                  int input_cols, int in_depth, int filter_rows,\n                  int filter_cols, int pad_rows, int pad_cols, int out_rows,\n                  int out_cols, int out_depth, int stride_rows, int stride_cols,\n                  int dilation_rows, int dilation_cols, Tensor* output,\n                  TensorFormat data_format) {\n    return false;\n  }\n};\n\ntemplate <>\nclass LaunchXsmmConvOp<CPUDevice, float> {\n public:\n  static bool Run(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int batch, int input_rows,\n                  int input_cols, int in_depth, int filter_rows,\n                  int filter_cols, int pad_rows, int pad_cols, int out_rows,\n                  int out_cols, int out_depth, int dilation_rows,\n                  int dilation_cols, int stride_rows, int stride_cols,\n                  Tensor* output, TensorFormat data_format) {\n    auto num_threads =\n        ctx->device()->tensorflow_cpu_worker_threads()->num_threads;\n    // See libxsmm_dnn.h for this struct definition.\n    libxsmm_dnn_conv_desc desc;\n    desc.N = batch;\n    desc.C = in_depth;\n    desc.H = input_rows;\n    desc.W = input_cols;\n    desc.K = out_depth;\n    desc.R = filter_rows;\n    desc.S = filter_cols;\n    desc.u = stride_rows;\n    desc.v = stride_cols;\n    desc.pad_h = pad_rows;\n    desc.pad_w = pad_cols;\n    desc.pad_h_in = 0;\n    desc.pad_w_in = 0;\n    desc.pad_h_out = 0;\n    desc.pad_w_out = 0;\n    desc.threads = num_threads;\n    desc.algo = LIBXSMM_DNN_CONV_ALGO_DIRECT;\n    desc.buffer_format = LIBXSMM_DNN_TENSOR_FORMAT_NHWC;\n    desc.filter_format = LIBXSMM_DNN_TENSOR_FORMAT_LIBXSMM;\n    desc.fuse_ops = LIBXSMM_DNN_CONV_FUSE_NONE;\n    desc.options = LIBXSMM_DNN_CONV_OPTION_OVERWRITE;\n    desc.datatype_out = LIBXSMM_DNN_DATATYPE_F32;\n    desc.datatype_in = LIBXSMM_DNN_DATATYPE_F32;\n    if (dilation_rows != 1 || dilation_cols != 1 ||\n        !CanUseXsmmConv2D(desc, data_format)) {\n      return false;\n    }\n\n    auto input_ptr = input.template flat<float>().data();\n    auto filter_ptr = filter.template flat<float>().data();\n    auto output_ptr = output->template flat<float>().data();\n\n    bool success = functor::XsmmFwdConv2D<CPUDevice, float>()(\n        ctx, desc, input_ptr, filter_ptr, output_ptr);\n    return success;\n  }\n};\n#endif\n\n#define TF_REQUIRES(EXP, STATUS)                \\\n  do {                                          \\\n    if (!TF_PREDICT_TRUE(EXP)) return (STATUS); \\\n  } while (false)\n\nStatus InitConv2DParameters(const OpKernelConstruction* context,\n                            Conv2DParameters* params) {\n  TF_RETURN_IF_ERROR(context->GetAttr(\"dilations\", &params->dilations));\n  TF_RETURN_IF_ERROR(context->GetAttr(\"strides\", &params->strides));\n  TF_RETURN_IF_ERROR(context->GetAttr(\"padding\", &params->padding));\n  if (context->HasAttr(\"explicit_paddings\")) {\n    TF_RETURN_IF_ERROR(\n        context->GetAttr(\"explicit_paddings\", &params->explicit_paddings));\n  }\n  string data_format_string;\n  TF_RETURN_IF_ERROR(context->GetAttr(\"data_format\", &data_format_string));\n  TF_REQUIRES(FormatFromString(data_format_string, &params->data_format),\n              errors::InvalidArgument(\"Invalid data format\"));\n\n  const auto& strides = params->strides;\n  const auto& dilations = params->dilations;\n  const auto& data_format = params->data_format;\n\n  TF_REQUIRES(dilations.size() == 4,\n              errors::InvalidArgument(\"Sliding window dilations field must \"\n                                      \"specify 4 dimensions\"));\n  TF_REQUIRES(strides.size() == 4,\n              errors::InvalidArgument(\"Sliding window strides field must \"\n                                      \"specify 4 dimensions\"));\n  const int64 stride_n = GetTensorDim(strides, data_format, 'N');\n  const int64 stride_c = GetTensorDim(strides, data_format, 'C');\n  const int64 stride_h = GetTensorDim(strides, data_format, 'H');\n  const int64 stride_w = GetTensorDim(strides, data_format, 'W');\n  TF_REQUIRES(\n      stride_n == 1 && stride_c == 1,\n      errors::Unimplemented(\"Current implementation does not yet support \"\n                            \"strides in the batch and depth dimensions.\"));\n  TF_REQUIRES(stride_h > 0 && stride_w > 0,\n              errors::InvalidArgument(\n                  \"Row and column strides should be larger than 0.\"));\n\n  const int64 dilation_n = GetTensorDim(dilations, data_format, 'N');\n  const int64 dilation_c = GetTensorDim(dilations, data_format, 'C');\n  const int64 dilation_h = GetTensorDim(dilations, data_format, 'H');\n  const int64 dilation_w = GetTensorDim(dilations, data_format, 'W');\n  TF_REQUIRES(\n      dilation_n == 1 && dilation_c == 1,\n      errors::Unimplemented(\"Current implementation does not yet support \"\n                            \"dilations in the batch and depth dimensions.\"));\n  TF_REQUIRES(\n      dilation_h > 0 && dilation_w > 0,\n      errors::InvalidArgument(\"Dilated rates should be larger than 0.\"));\n\n  TF_RETURN_IF_ERROR(CheckValidPadding(params->padding,\n                                       params->explicit_paddings,\n                                       /*num_dims=*/4, data_format));\n\n  return Status::OK();\n}\n\nStatus ComputeConv2DDimension(const Conv2DParameters& params,\n                              const Tensor& input, const Tensor& filter,\n                              Conv2DDimensions* dimensions) {\n  // Check that 2D convolution input and filter have exactly 4 dimensions.\n  TF_REQUIRES(input.dims() == 4,\n              errors::InvalidArgument(\"input must be 4-dimensional\",\n                                      input.shape().DebugString()));\n  TF_REQUIRES(filter.dims() == 4,\n              errors::InvalidArgument(\"filter must be 4-dimensional: \",\n                                      filter.shape().DebugString()));\n  for (int i = 0; i < 3; i++) {\n    TF_REQUIRES(\n        FastBoundsCheck(filter.dim_size(i), std::numeric_limits<int>::max()),\n        errors::InvalidArgument(\"filter too large\"));\n  }\n\n  // The last dimension for input is in_depth. Check that it is the same as the\n  // filter's in_depth or it is evenly divisible by filter's in_depth.\n  const int64 in_depth_raw = GetTensorDim(input, params.data_format, 'C');\n  const int64 patch_depth_raw = filter.dim_size(2);\n  TF_REQUIRES(FastBoundsCheck(in_depth_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Input depth too large\"));\n  TF_REQUIRES(FastBoundsCheck(patch_depth_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Patch depth too large\"));\n  const int in_depth = static_cast<int>(in_depth_raw);\n  const int patch_depth = static_cast<int>(patch_depth_raw);\n  TF_REQUIRES(in_depth % patch_depth == 0,\n              errors::InvalidArgument(\n                  \"input depth must be evenly divisible by filter depth: \",\n                  in_depth, \" vs \", patch_depth));\n\n  // The last dimension for filter is out_depth.\n  const int out_depth = static_cast<int>(filter.dim_size(3));\n\n  // The second dimension for input is rows/height.\n  // The first dimension for filter is rows/height.\n  const int64 input_rows_raw = GetTensorDim(input, params.data_format, 'H');\n  TF_REQUIRES(FastBoundsCheck(input_rows_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Input rows too large\"));\n  const int input_rows = static_cast<int>(input_rows_raw);\n  const int filter_rows = static_cast<int>(filter.dim_size(0));\n\n  // The third dimension for input is columns/width.\n  // The second dimension for filter is columns/width.\n  const int64 input_cols_raw = GetTensorDim(input, params.data_format, 'W');\n  TF_REQUIRES(FastBoundsCheck(input_cols_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Input cols too large\"));\n  const int input_cols = static_cast<int>(input_cols_raw);\n  const int filter_cols = static_cast<int>(filter.dim_size(1));\n\n  // The first dimension for input is batch.\n  const int64 batch_raw = GetTensorDim(input, params.data_format, 'N');\n  TF_REQUIRES(FastBoundsCheck(batch_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"batch is too large\"));\n  const int batch = static_cast<int>(batch_raw);\n\n  // Take the stride and dilation from the second and third dimensions only (we\n  // do not support striding or dilation on the batch or depth dimension).\n  const int stride_rows = GetTensorDim(params.strides, params.data_format, 'H');\n  const int stride_cols = GetTensorDim(params.strides, params.data_format, 'W');\n  const int dilation_rows =\n      GetTensorDim(params.dilations, params.data_format, 'H');\n  const int dilation_cols =\n      GetTensorDim(params.dilations, params.data_format, 'W');\n\n  int64 pad_rows_before, pad_rows_after, pad_cols_before, pad_cols_after;\n  if (params.padding == Padding::EXPLICIT) {\n    GetExplicitPaddingForDim(params.explicit_paddings, params.data_format, 'H',\n                             &pad_rows_before, &pad_rows_after);\n    GetExplicitPaddingForDim(params.explicit_paddings, params.data_format, 'W',\n                             &pad_cols_before, &pad_cols_after);\n  }\n\n  // Compute windowed output sizes for rows and columns.\n  int64 out_rows = 0, out_cols = 0;\n  TF_RETURN_IF_ERROR(GetWindowedOutputSizeVerboseV2(\n      input_rows, filter_rows, dilation_rows, stride_rows, params.padding,\n      &out_rows, &pad_rows_before, &pad_rows_after));\n  TF_RETURN_IF_ERROR(GetWindowedOutputSizeVerboseV2(\n      input_cols, filter_cols, dilation_cols, stride_cols, params.padding,\n      &out_cols, &pad_cols_before, &pad_cols_after));\n\n  dimensions->batch = batch;\n  dimensions->input_rows = input_rows;\n  dimensions->input_cols = input_cols;\n  dimensions->in_depth = in_depth;\n  dimensions->filter_rows = filter_rows;\n  dimensions->filter_cols = filter_cols;\n  dimensions->patch_depth = patch_depth;\n  dimensions->out_depth = out_depth;\n  dimensions->stride_rows = stride_rows;\n  dimensions->stride_cols = stride_cols;\n  dimensions->dilation_rows = dilation_rows;\n  dimensions->dilation_cols = dilation_cols;\n  dimensions->out_rows = out_rows;\n  dimensions->out_cols = out_cols;\n  dimensions->pad_rows_before = pad_rows_before;\n  dimensions->pad_rows_after = pad_rows_after;\n  dimensions->pad_cols_before = pad_cols_before;\n  dimensions->pad_cols_after = pad_cols_after;\n\n  return Status::OK();\n}\n\n#undef TF_REQUIRES\n\ntemplate <typename Device, typename T>\nclass Conv2DOp : public BinaryOp<T> {\n public:\n  explicit Conv2DOp(OpKernelConstruction* context) : BinaryOp<T>(context) {\n    OP_REQUIRES_OK(context, InitConv2DParameters(context, &params_));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"use_cudnn_on_gpu\", &use_cudnn_));\n    cudnn_use_autotune_ = CudnnUseAutotune();\n  }\n\n  void Compute(OpKernelContext* context) override {\n    // Input tensor is of the following dimensions:\n    // [ batch, in_rows, in_cols, in_depth ]\n    const Tensor& input = context->input(0);\n\n    // Input filter is of the following dimensions:\n    // [ filter_rows, filter_cols, in_depth, out_depth]\n    const Tensor& filter = context->input(1);\n\n    Conv2DDimensions dimensions;\n    OP_REQUIRES_OK(context,\n                   ComputeConv2DDimension(params_, input, filter, &dimensions));\n\n    TensorShape out_shape = ShapeFromFormat(\n        params_.data_format, dimensions.batch, dimensions.out_rows,\n        dimensions.out_cols, dimensions.out_depth);\n\n    // Output tensor is of the following dimensions:\n    // [ in_batch, out_rows, out_cols, out_depth ]\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n\n    VLOG(2) << \"Conv2D: in_depth = \" << dimensions.in_depth\n            << \", patch_depth = \" << dimensions.patch_depth\n            << \", input_cols = \" << dimensions.input_cols\n            << \", filter_cols = \" << dimensions.filter_cols\n            << \", input_rows = \" << dimensions.input_rows\n            << \", filter_rows = \" << dimensions.filter_rows\n            << \", stride_rows = \" << dimensions.stride_rows\n            << \", stride_cols = \" << dimensions.stride_cols\n            << \", dilation_rows = \" << dimensions.dilation_rows\n            << \", dilation_cols = \" << dimensions.dilation_cols\n            << \", out_depth = \" << dimensions.out_depth;\n\n    // If there is nothing to compute, return.\n    if (out_shape.num_elements() == 0) {\n      return;\n    }\n\n#ifdef TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS\n    if (params_.padding != EXPLICIT &&\n        LaunchXsmmConvOp<Device, T>::Run(\n            context, input, filter, dimensions.batch, dimensions.input_rows,\n            dimensions.input_cols, dimensions.in_depth, dimensions.filter_rows,\n            dimensions.filter_cols, dimensions.pad_rows_before,\n            dimensions.pad_cols_before, dimensions.out_rows,\n            dimensions.out_cols, dimensions.out_depth, dimensions.dilation_rows,\n            dimensions.dilation_cols, dimensions.stride_rows,\n            dimensions.stride_cols, output, params_.data_format)) {\n      return;\n    }\n#endif\n\n    if (params_.padding != EXPLICIT &&\n        LaunchDeepConvOp<Device, T>::Run(\n            context, input, filter, dimensions.batch, dimensions.input_rows,\n            dimensions.input_cols, dimensions.in_depth, dimensions.filter_rows,\n            dimensions.filter_cols, dimensions.pad_rows_before,\n            dimensions.pad_cols_before, dimensions.out_rows,\n            dimensions.out_cols, dimensions.out_depth, dimensions.dilation_rows,\n            dimensions.dilation_cols, dimensions.stride_rows,\n            dimensions.stride_cols, output, params_.data_format)) {\n      return;\n    }\n\n    launcher_(context, use_cudnn_, cudnn_use_autotune_, input, filter,\n              dimensions.dilation_rows, dimensions.dilation_cols,\n              dimensions.stride_rows, dimensions.stride_cols, params_.padding,\n              params_.explicit_paddings, output, params_.data_format);\n  }\n\n private:\n  Conv2DParameters params_;\n  bool use_cudnn_;\n  bool cudnn_use_autotune_;\n\n  LaunchConv2DOp<Device, T> launcher_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(Conv2DOp);\n};\n\n#define REGISTER_CPU(T)                                         \\\n  REGISTER_KERNEL_BUILDER(                                      \\\n      Name(\"Conv2D\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      Conv2DOp<CPUDevice, T>);\n\n// If we're using the alternative GEMM-based implementation of Conv2D for the\n// CPU implementation, don't register this EigenTensor-based version.\n#if !defined(USE_GEMM_FOR_CONV)\nTF_CALL_half(REGISTER_CPU);\nTF_CALL_float(REGISTER_CPU);\nTF_CALL_double(REGISTER_CPU);\nTF_CALL_int32(REGISTER_CPU);\n#endif  // USE_GEMM_FOR_CONV\n\n// To be used inside depthwise_conv_op.cc.\ntemplate struct LaunchConv2DOp<CPUDevice, Eigen::half>;\ntemplate struct LaunchConv2DOp<CPUDevice, float>;\ntemplate struct LaunchConv2DOp<CPUDevice, double>;\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nint64 GetDnnWorkspaceLimit(const string& envvar_in_mb,\n                           int64 default_value_in_bytes) {\n  const char* workspace_limit_in_mb_str = getenv(envvar_in_mb.c_str());\n  if (workspace_limit_in_mb_str != nullptr &&\n      strcmp(workspace_limit_in_mb_str, \"\") != 0) {\n    int64 scratch_limit_in_mb = -1;\n    if (strings::safe_strto64(workspace_limit_in_mb_str,\n                              &scratch_limit_in_mb)) {\n      return scratch_limit_in_mb * (1 << 20);\n    } else {\n      LOG(WARNING) << \"Invalid value for env-var \" << envvar_in_mb << \": \"\n                   << workspace_limit_in_mb_str;\n    }\n  }\n  return default_value_in_bytes;\n}\n\n// A dummy type to group forward convolution autotune results together.\nstruct ConvAutoTuneGroup {\n  static string name() { return \"Conv\"; }\n};\n\ntypedef AutoTuneSingleton<ConvAutoTuneGroup, ConvParameters,\n                          se::dnn::AlgorithmConfig>\n    AutoTuneConv;\n\ntemplate <typename T>\nvoid LaunchConv2DOp<GPUDevice, T>::operator()(\n    OpKernelContext* ctx, bool use_cudnn, bool cudnn_use_autotune,\n    const Tensor& input_param, const Tensor& filter, int row_dilation,\n    int col_dilation, int row_stride, int col_stride, const Padding& padding,\n    const std::vector<int64>& explicit_paddings, Tensor* output,\n    TensorFormat data_format) {\n  using se::dnn::AlgorithmConfig;\n  using se::dnn::AlgorithmDesc;\n  using se::dnn::ProfileResult;\n  auto* stream = ctx->op_device_context()->stream();\n  OP_REQUIRES(ctx, stream, errors::Internal(\"No GPU stream available.\"));\n\n  if (!use_cudnn) {\n    ctx->SetStatus(\n        errors::Unimplemented(\"Conv2D for GPU is not currently supported \"\n                              \"without cudnn\"));\n    return;\n  }\n\n  Tensor input = input_param;\n  const int64 in_batch = GetTensorDim(input, data_format, 'N');\n  int64 in_rows = GetTensorDim(input, data_format, 'H');\n  int64 in_cols = GetTensorDim(input, data_format, 'W');\n  const int64 in_depths = GetTensorDim(input, data_format, 'C');\n  const int64 patch_rows = filter.dim_size(0);\n  const int64 patch_cols = filter.dim_size(1);\n  const int64 patch_depths = filter.dim_size(2);\n\n  // If the filter in-depth (patch_depths) is 1 and smaller than the input\n  // depth, it's a depthwise convolution. More generally, if the filter in-depth\n  // divides but is smaller than the input depth, it is a grouped convolution.\n  bool is_grouped_convolution = patch_depths != in_depths;\n  if (patch_rows == 1 && patch_cols == 1 && !is_grouped_convolution &&\n      row_dilation == 1 && col_dilation == 1 && row_stride == 1 &&\n      col_stride == 1 && data_format == FORMAT_NHWC &&\n      (padding == VALID || padding == SAME)) {\n    // 1x1 filter, so call cublas directly.\n    const uint64 m = in_batch * in_rows * in_cols;\n    const uint64 k = patch_depths;\n    const uint64 n = filter.dim_size(3);\n\n    auto a_ptr = AsDeviceMemory(input.template flat<T>().data(),\n                                input.template flat<T>().size());\n    auto b_ptr = AsDeviceMemory(filter.template flat<T>().data(),\n                                filter.template flat<T>().size());\n    auto c_ptr = AsDeviceMemory(output->template flat<T>().data(),\n                                output->template flat<T>().size());\n\n    auto no_transpose = se::blas::Transpose::kNoTranspose;\n    bool blas_launch_status =\n        stream\n            ->ThenBlasGemm(no_transpose, no_transpose, n, m, k, 1.0f, b_ptr, n,\n                           a_ptr, k, 0.0f, &c_ptr, n)\n            .ok();\n    if (!blas_launch_status) {\n      ctx->SetStatus(errors::Internal(\"Blas SGEMM launch failed : m=\", m,\n                                      \", n=\", n, \", k=\", k));\n    }\n    return;\n  } else if (patch_rows == in_rows && patch_cols == in_cols &&\n             !is_grouped_convolution && row_dilation == 1 &&\n             col_dilation == 1 && padding == VALID &&\n             data_format == FORMAT_NHWC) {\n    // The input data and filter have the same height/width, so call cublas\n    // directly.\n    const uint64 m = in_batch;\n    const uint64 k = patch_rows * patch_cols * patch_depths;\n    const uint64 n = filter.dim_size(3);\n\n    auto a_ptr = AsDeviceMemory(input.template flat<T>().data(),\n                                input.template flat<T>().size());\n    auto b_ptr = AsDeviceMemory(filter.template flat<T>().data(),\n                                filter.template flat<T>().size());\n    auto c_ptr = AsDeviceMemory(output->template flat<T>().data(),\n                                output->template flat<T>().size());\n\n    auto no_transpose = se::blas::Transpose::kNoTranspose;\n    bool blas_launch_status =\n        stream\n            ->ThenBlasGemm(no_transpose, no_transpose, n, m, k, 1.0f, b_ptr, n,\n                           a_ptr, k, 0.0f, &c_ptr, n)\n            .ok();\n    if (!blas_launch_status) {\n      ctx->SetStatus(errors::Internal(\"Blas SGEMM launch failed : m=\", m,\n                                      \", n=\", n, \", k=\", k));\n    }\n    return;\n  }\n\n#if GOOGLE_CUDA\n  // Tensor Core (NVIDIA Volta+ GPUs) supports efficient convolution with fp16\n  // in NHWC data layout. In all other configurations it's more efficient to\n  // run computation in NCHW data format.\n  const bool compute_in_nhwc =\n      DataTypeToEnum<T>::value == DT_HALF && IsVoltaOrLater(*stream->parent());\n#else\n  // fast NHWC implementation is a CUDA only feature\n  const bool compute_in_nhwc = false;\n#endif\n\n  // We only do one directional conversion: NHWC->NCHW. We never convert in the\n  // other direction. Grappler layout optimizer selects preferred layout and\n  // adds necessary annotations to the graph.\n  // TODO(ezhulenev): Convert in other direction for fp16?\n  const TensorFormat compute_data_format =\n      (compute_in_nhwc && data_format == FORMAT_NHWC) ? FORMAT_NHWC\n                                                      : FORMAT_NCHW;\n\n  VLOG(3) << \"Compute Conv2D with cuDNN:\"\n          << \" data_format=\" << ToString(data_format)\n          << \" compute_data_format=\" << ToString(compute_data_format);\n\n  const int64 out_batch = GetTensorDim(*output, data_format, 'N');\n  const int64 out_rows = GetTensorDim(*output, data_format, 'H');\n  const int64 out_cols = GetTensorDim(*output, data_format, 'W');\n  const int64 out_depths = GetTensorDim(*output, data_format, 'C');\n  int64 padding_top = -1, padding_bottom = -1;\n  int64 padding_left = -1, padding_right = -1;\n  if (padding == EXPLICIT) {\n    GetExplicitPaddingForDim(explicit_paddings, data_format, 'H', &padding_top,\n                             &padding_bottom);\n    GetExplicitPaddingForDim(explicit_paddings, data_format, 'W', &padding_left,\n                             &padding_right);\n  }\n  int64 out_rows_check, out_cols_check;\n  Status status = GetWindowedOutputSizeVerboseV2(\n      in_rows, patch_rows, row_dilation, row_stride, padding, &out_rows_check,\n      &padding_top, &padding_bottom);\n  // The status is guaranteed to be OK because we checked the output and padding\n  // was valid earlier.\n  TF_CHECK_OK(status);\n  DCHECK_EQ(out_rows, out_rows_check);\n  status = GetWindowedOutputSizeVerboseV2(in_cols, patch_cols, col_dilation,\n                                          col_stride, padding, &out_cols_check,\n                                          &padding_left, &padding_right);\n  TF_CHECK_OK(status);\n  DCHECK_EQ(out_cols, out_cols_check);\n\n  const int64 common_padding_rows = std::min(padding_top, padding_bottom);\n  const int64 common_padding_cols = std::min(padding_left, padding_right);\n  if (padding_top != padding_bottom || padding_left != padding_right) {\n    // cuDNN only supports padding the same amount on the left and right sides,\n    // and on the top and bottom sides. So we manually create a new padded\n    // input tensor such that we can pass it to cuDNN.\n    VLOG(4) << \"Pad input tensor:\"\n            << \" padding_top=\" << padding_top\n            << \" padding_bottom=\" << padding_bottom\n            << \" padding_left=\" << padding_left\n            << \" padding_right=\" << padding_right;\n\n    // TODO(reedwm): In some cases, we can avoid an allocation even if the two\n    // padding sides are different. For example, if the input is 2x2, the filter\n    // is 1x1, the stride is 2, and the padding is (1, 0, 1, 0), the result is\n    // equivalent to as if the padding is (1, 1, 1, 1). Changing the padding in\n    // such a way would allow us to avoid the allocation.\n    Tensor transformed_input;\n    const int64 padding_rows_diff = std::abs(padding_bottom - padding_top);\n    const int64 padding_cols_diff = std::abs(padding_right - padding_left);\n    const int64 new_in_rows = in_rows + padding_rows_diff;\n    const int64 new_in_cols = in_cols + padding_cols_diff;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(\n                            DataTypeToEnum<T>::value,\n                            ShapeFromFormat(data_format, in_batch, new_in_rows,\n                                            new_in_cols, in_depths),\n                            &transformed_input));\n\n    const int64 input_pad_top = padding_top - common_padding_rows;\n    const int64 input_pad_bottom = padding_bottom - common_padding_rows;\n    const int64 input_pad_left = padding_left - common_padding_cols;\n    const int64 input_pad_right = padding_right - common_padding_cols;\n    bool in_bounds =\n        FastBoundsCheck(input_pad_top, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_bottom, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_left, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_right, std::numeric_limits<int>::max());\n    if (!in_bounds) {\n      ctx->SetStatus(errors::InvalidArgument(\"Padding is too large.\"));\n      return;\n    }\n    functor::PadInput<GPUDevice, T, int, 4>()(\n        ctx->eigen_device<GPUDevice>(), To32Bit(input_param.tensor<T, 4>()),\n        {{static_cast<int>(input_pad_top), static_cast<int>(input_pad_left)}},\n        {{static_cast<int>(input_pad_bottom),\n          static_cast<int>(input_pad_right)}},\n        To32Bit(transformed_input.tensor<T, 4>()), data_format, T{});\n\n    input = transformed_input;\n    in_rows = new_in_rows;\n    in_cols = new_in_cols;\n  }\n\n  if (data_format == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {\n    VLOG(4) << \"Convert the input tensor from NHWC to NCHW.\";\n\n    TensorShape nchw_shape =\n        ShapeFromFormat(FORMAT_NCHW, in_batch, in_rows, in_cols, in_depths);\n    if (in_depths > 1) {\n      Tensor transformed_input;\n      OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                             nchw_shape, &transformed_input));\n      functor::NHWCToNCHW<GPUDevice, T, 4>()(\n          ctx->eigen_device<GPUDevice>(),\n          const_cast<const Tensor&>(input).tensor<T, 4>(),\n          transformed_input.tensor<T, 4>());\n      input = transformed_input;\n    } else {\n      // If depth <= 1, then just reshape.\n      CHECK(input.CopyFrom(input, nchw_shape));\n    }\n  } else {\n    CHECK(data_format == compute_data_format)  // Crash OK\n        << \"Illegal data and compute format pair:\"\n        << \" data_format=\" << ToString(data_format)\n        << \" compute_data_format=\" << ToString(compute_data_format);\n  }\n\n  CHECK(common_padding_rows >= 0 && common_padding_cols >= 0)  // Crash OK\n      << \"Negative row or col paddings: (\" << common_padding_rows << \", \"\n      << common_padding_cols << \")\";\n\n  constexpr auto kComputeInNHWC =\n      std::make_tuple(se::dnn::DataLayout::kBatchYXDepth,\n                      se::dnn::FilterLayout::kOutputYXInput);\n  constexpr auto kComputeInNCHW =\n      std::make_tuple(se::dnn::DataLayout::kBatchDepthYX,\n                      se::dnn::FilterLayout::kOutputInputYX);\n\n  se::dnn::DataLayout compute_data_layout;\n  se::dnn::FilterLayout filter_layout;\n\n  std::tie(compute_data_layout, filter_layout) =\n      compute_data_format == FORMAT_NHWC ? kComputeInNHWC : kComputeInNCHW;\n\n  se::dnn::BatchDescriptor input_desc;\n  input_desc.set_count(in_batch)\n      .set_feature_map_count(in_depths)\n      .set_height(in_rows)\n      .set_width(in_cols)\n      .set_layout(compute_data_layout);\n  se::dnn::BatchDescriptor output_desc;\n  output_desc.set_count(out_batch)\n      .set_height(out_rows)\n      .set_width(out_cols)\n      .set_feature_map_count(out_depths)\n      .set_layout(compute_data_layout);\n  se::dnn::FilterDescriptor filter_desc;\n  filter_desc.set_input_filter_height(patch_rows)\n      .set_input_filter_width(patch_cols)\n      .set_input_feature_map_count(patch_depths)\n      .set_output_feature_map_count(filter.dim_size(3))\n      .set_layout(filter_layout);\n  se::dnn::ConvolutionDescriptor conv_desc;\n  conv_desc.set_vertical_dilation_rate(row_dilation)\n      .set_horizontal_dilation_rate(col_dilation)\n      .set_vertical_filter_stride(row_stride)\n      .set_horizontal_filter_stride(col_stride)\n      .set_zero_padding_height(common_padding_rows)\n      .set_zero_padding_width(common_padding_cols)\n      .set_group_count(in_depths / patch_depths);\n\n  Tensor transformed_filter;\n\n  const auto transform_filter = [&](FilterTensorFormat dst_format) -> Status {\n    VLOG(4) << \"Transform filter tensor from \" << ToString(FORMAT_HWIO)\n            << \" to \" << ToString(dst_format);\n\n    TensorShape dst_shape =\n        dst_format == FORMAT_OIHW\n            ? TensorShape({filter.dim_size(3), filter.dim_size(2),\n                           filter.dim_size(0), filter.dim_size(1)})\n            : TensorShape({filter.dim_size(3), filter.dim_size(0),\n                           filter.dim_size(1), filter.dim_size(2)});\n\n    TF_RETURN_IF_ERROR(ctx->allocate_temp(DataTypeToEnum<T>::value, dst_shape,\n                                          &transformed_filter));\n    functor::TransformFilter<GPUDevice, T, int, 4>()(\n        ctx->eigen_device<GPUDevice>(), dst_format,\n        To32Bit(filter.tensor<T, 4>()),\n        To32Bit(transformed_filter.tensor<T, 4>()));\n\n    return Status::OK();\n  };\n\n  if (compute_data_format == FORMAT_NCHW) {\n    OP_REQUIRES_OK(ctx, transform_filter(FORMAT_OIHW));\n  } else if (compute_data_format == FORMAT_NHWC) {\n    OP_REQUIRES_OK(ctx, transform_filter(FORMAT_OHWI));\n  } else {\n    ctx->SetStatus(errors::InvalidArgument(\"Invalid compute data format: \",\n                                           ToString(compute_data_format)));\n    return;\n  }\n\n  Tensor transformed_output;\n  if (data_format != compute_data_format) {\n    VLOG(4) << \"Allocate temporary memory for output in compute data format\";\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                ShapeFromFormat(compute_data_format, out_batch,\n                                                out_rows, out_cols, out_depths),\n                                &transformed_output));\n  } else {\n    transformed_output = *output;\n  }\n\n  auto input_ptr = AsDeviceMemory(input.template flat<T>().data(),\n                                  input.template flat<T>().size());\n  auto filter_ptr =\n      AsDeviceMemory(transformed_filter.template flat<T>().data(),\n                     transformed_filter.template flat<T>().size());\n  auto output_ptr =\n      AsDeviceMemory(transformed_output.template flat<T>().data(),\n                     transformed_output.template flat<T>().size());\n\n  static int64 ConvolveScratchSize = GetDnnWorkspaceLimit(\n      // default value is in bytes despite the name of the environment variable\n      \"TF_CUDNN_WORKSPACE_LIMIT_IN_MB\", 1LL << 32  // 4GB\n  );\n\n  int device_id = stream->parent()->device_ordinal();\n  DataType dtype = input.dtype();\n  ConvParameters conv_parameters = {in_batch,             // batch\n                                    in_depths,            // in_depths\n                                    {{in_rows,            // in_rows\n                                      in_cols}},          // in_cols\n                                    compute_data_format,  // compute_data_format\n                                    out_depths,           // out_depths\n                                    {{patch_rows,         // filter_rows\n                                      patch_cols,         // filter_cols\n                                      patch_depths}},     // filter_depths\n                                    {{row_dilation,       // dilation_rows\n                                      col_dilation}},     // dilation_cols\n                                    {{row_stride,         // stride_rows\n                                      col_stride}},       // stride_cols\n                                    {{common_padding_rows,    // padding_rows\n                                      common_padding_cols}},  // padding_cols\n                                    dtype,                    // tensor datatype\n                                    device_id,                // device_id\n                                    conv_desc.group_count()};\n  AlgorithmConfig algorithm_config;\n#if TENSORFLOW_USE_ROCM\n  // cudnn_use_autotune is applicable only the CUDA flow\n  // for ROCm/MIOpen, we need to call GetMIOpenConvolveAlgorithms explicitly\n  // if we do not have a cached algorithm_config for this conv_parameters\n  cudnn_use_autotune = true;\n#endif\n\n  if (cudnn_use_autotune &&\n      !AutoTuneConv::GetInstance()->Find(conv_parameters, &algorithm_config)) {\n    std::vector<std::unique_ptr<se::dnn::ConvolveExecutionPlan>> plans;\n#if GOOGLE_CUDA\n    std::vector<AlgorithmDesc> algorithms;\n    std::vector<AlgorithmConfig> configs;\n    if (CudnnUseFrontend()) {\n      OP_REQUIRES(\n          ctx,\n          stream->parent()->GetConvolveExecutionPlans(\n              se::dnn::ConvolutionKind::FORWARD, se::dnn::ToDataType<T>::value,\n              stream, input_desc, filter_desc, output_desc, conv_desc, &plans),\n          errors::Unknown(\"Failed to get convolution algorithm. This is \"\n                          \"probably because cuDNN failed to initialize, so try \"\n                          \"looking to see if a warning log message was printed \"\n                          \"above.\"));\n      for (const auto& plan : plans) {\n        configs.push_back(\n            AlgorithmConfig(AlgorithmDesc{plan->getTag(), plan->get_raw_desc()},\n                            plan->getWorkspaceSize()));\n      }\n    } else {\n      OP_REQUIRES(\n          ctx,\n          stream->parent()->GetConvolveAlgorithms(\n              conv_parameters.ShouldIncludeWinogradNonfusedAlgo<T>(\n                  stream->parent()),\n              &algorithms),\n          errors::Unknown(\"Failed to get convolution algorithm. This is \"\n                          \"probably because cuDNN failed to initialize, so try \"\n                          \"looking to see if a warning log message was printed \"\n                          \"above.\"));\n      for (const auto& algorithm : algorithms) {\n        configs.push_back(AlgorithmConfig(algorithm));\n      }\n    }\n\n    se::TfAllocatorAdapter tf_allocator_adapter(ctx->device()->GetAllocator({}),\n                                                stream);\n    se::RedzoneAllocator rz_allocator(stream, &tf_allocator_adapter,\n                                      se::GpuAsmOpts());\n    se::DeviceMemory<T> output_tensor(\n        WrapRedzoneBestEffort(&rz_allocator, output_ptr));\n\n    std::vector<tensorflow::AutotuneResult> results;\n    for (const auto& profile_config : configs) {\n      // TODO(zhengxq): profile each algorithm multiple times to better\n      // accuracy.\n      se::RedzoneAllocator rz_scratch_allocator(\n          stream, &tf_allocator_adapter, se::GpuAsmOpts(),\n          /*memory_limit=*/ConvolveScratchSize);\n      DnnScratchAllocator scratch_allocator(ConvolveScratchSize, ctx);\n      se::ScratchAllocator* allocator_used =\n          !RedzoneCheckDisabled()\n              ? static_cast<se::ScratchAllocator*>(&rz_scratch_allocator)\n              : static_cast<se::ScratchAllocator*>(&scratch_allocator);\n\n      ProfileResult profile_result;\n      Status cudnn_launch_status;\n      if (CudnnUseFrontend()) {\n        cudnn_launch_status = stream->ConvolveWithExecutionPlan(\n            input_desc, input_ptr, filter_desc, filter_ptr, conv_desc,\n            output_desc, &output_tensor, allocator_used, profile_config,\n            &profile_result);\n      } else {\n        cudnn_launch_status = stream->ConvolveWithAlgorithm(\n            input_desc, input_ptr, filter_desc, filter_ptr, conv_desc,\n            output_desc, &output_tensor, allocator_used, profile_config,\n            &profile_result);\n      }\n\n      if (cudnn_launch_status.ok() && profile_result.is_valid()) {\n        results.emplace_back();\n        auto& result = results.back();\n        if (CudnnUseFrontend()) {\n          result.mutable_cuda_conv_plan()->set_exec_plan_id(\n              profile_config.algorithm()->exec_plan_id());\n        } else {\n          result.mutable_conv()->set_algorithm(\n              profile_config.algorithm()->algo_id());\n          result.mutable_conv()->set_tensor_ops_enabled(\n              profile_config.algorithm()->tensor_ops_enabled());\n        }\n\n        result.set_scratch_bytes(\n            !RedzoneCheckDisabled()\n                ? rz_scratch_allocator.TotalAllocatedBytesExcludingRedzones()\n                : scratch_allocator.TotalByteSize());\n        *result.mutable_run_time() = proto_utils::ToDurationProto(\n            absl::Milliseconds(profile_result.elapsed_time_in_ms()));\n\n        CheckRedzones(rz_scratch_allocator, &result);\n        CheckRedzones(rz_allocator, &result);\n      } else if (CudnnUseFrontend()) {\n        // When CuDNN frontend APIs are used, we need to make sure the profiling\n        // results are one-to-one mapping of the \"plans\". So, we insert dummy\n        // results when the excution fails.\n        results.emplace_back();\n        auto& result = results.back();\n        result.mutable_failure()->set_kind(AutotuneResult::UNKNOWN);\n        result.mutable_failure()->set_msg(\n            absl::StrCat(\"Profiling failure on CUDNN engine: \",\n                         profile_config.algorithm()->exec_plan_id()));\n      }\n    }\n\n#elif TENSORFLOW_USE_ROCM\n    DnnScratchAllocator scratch_allocator(ConvolveScratchSize, ctx);\n\n    std::vector<ProfileResult> algorithms;\n    OP_REQUIRES(\n        ctx,\n        stream->parent()->GetMIOpenConvolveAlgorithms(\n            se::dnn::ConvolutionKind::FORWARD, se::dnn::ToDataType<T>::value,\n            stream, input_desc, input_ptr, filter_desc, filter_ptr, output_desc,\n            output_ptr, conv_desc, &scratch_allocator, &algorithms),\n        errors::Unknown(\n            \"Failed to get convolution algorithm. This is probably \"\n            \"because MIOpen failed to initialize, so try looking to \"\n            \"see if a warning log message was printed above.\"));\n    se::DeviceMemory<T> output_tensor = output_ptr;\n\n    std::vector<tensorflow::AutotuneResult> results;\n    if (algorithms.size() == 1) {\n      auto profile_result = algorithms[0];\n      results.emplace_back();\n      auto& result = results.back();\n      result.mutable_conv()->set_algorithm(\n          profile_result.algorithm().algo_id());\n      result.mutable_conv()->set_tensor_ops_enabled(\n          profile_result.algorithm().tensor_ops_enabled());\n\n      result.set_scratch_bytes(profile_result.scratch_size());\n      *result.mutable_run_time() = proto_utils::ToDurationProto(\n          absl::Milliseconds(profile_result.elapsed_time_in_ms()));\n    } else {\n      for (auto miopen_algorithm : algorithms) {\n        auto profile_algorithm = miopen_algorithm.algorithm();\n        ProfileResult profile_result;\n        auto miopen_launch_status = stream->ConvolveWithAlgorithm(\n            input_desc, input_ptr, filter_desc, filter_ptr, conv_desc,\n            output_desc, &output_ptr, &scratch_allocator,\n            AlgorithmConfig(profile_algorithm, miopen_algorithm.scratch_size()),\n            &profile_result);\n        if (miopen_launch_status.ok() && profile_result.is_valid()) {\n          results.emplace_back();\n          auto& result = results.back();\n          result.mutable_conv()->set_algorithm(profile_algorithm.algo_id());\n          result.mutable_conv()->set_tensor_ops_enabled(\n              profile_algorithm.tensor_ops_enabled());\n\n          result.set_scratch_bytes(scratch_allocator.TotalByteSize());\n          *result.mutable_run_time() = proto_utils::ToDurationProto(\n              absl::Milliseconds(profile_result.elapsed_time_in_ms()));\n        }\n      }\n    }\n#endif\n    LogConvAutotuneResults(se::dnn::ConvolutionKind::FORWARD,\n                           se::dnn::ToDataType<T>::value, input_ptr, filter_ptr,\n                           output_tensor, input_desc, filter_desc, output_desc,\n                           conv_desc, stream->parent(), results);\n\n    if (CudnnUseFrontend()) {\n      OP_REQUIRES_OK(\n          ctx, BestCudnnConvAlgorithm(results, &plans, &algorithm_config));\n\n    } else {\n      OP_REQUIRES_OK(\n          ctx, BestCudnnConvAlgorithm(results, nullptr, &algorithm_config));\n    }\n\n    AutoTuneConv::GetInstance()->Insert(conv_parameters, algorithm_config);\n  }\n\n  Status cudnn_launch_status;\n  DnnScratchAllocator scratch_allocator(ConvolveScratchSize, ctx);\n  if (CudnnUseFrontend()) {\n    if (algorithm_config.algorithm().has_value()) {\n      VLOG(4) << \"Conv2D Execution Plan: \"\n              << algorithm_config.algorithm()->exec_plan_id();\n    } else {\n      VLOG(4) << \"Convolution AutoTune has been turned off\";\n    }\n    cudnn_launch_status = stream->ConvolveWithExecutionPlan(\n        input_desc, input_ptr, filter_desc, filter_ptr, conv_desc, output_desc,\n        &output_ptr, &scratch_allocator, algorithm_config, nullptr);\n  } else {\n    VLOG(4) << \"Convolution Algorithm: \"\n            << algorithm_config.algorithm()->algo_id();\n    VLOG(4) << \"tensor_ops_enabled: \"\n            << algorithm_config.algorithm()->tensor_ops_enabled();\n\n    cudnn_launch_status = stream->ConvolveWithAlgorithm(\n        input_desc, input_ptr, filter_desc, filter_ptr, conv_desc, output_desc,\n        &output_ptr, &scratch_allocator, algorithm_config, nullptr);\n  }\n\n  if (!cudnn_launch_status.ok()) {\n    ctx->SetStatus(cudnn_launch_status);\n  }\n\n  if (data_format == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {\n    VLOG(4) << \"Convert the output tensor back from NCHW to NHWC.\";\n    functor::NCHWToNHWC<GPUDevice, T, 4>()(\n        ctx->eigen_device<GPUDevice>(),\n        const_cast<const Tensor&>(transformed_output).tensor<T, 4>(),\n        output->tensor<T, 4>());\n  }\n}\n\n// Forward declarations of the functor specializations for GPU.\nnamespace functor {\n#define DECLARE_GPU_SPEC(T)                                                 \\\n  template <>                                                               \\\n  void SpatialConvolution<GPUDevice, T>::operator()(                        \\\n      const GPUDevice& d, typename TTypes<T, 4>::Tensor output,             \\\n      typename TTypes<T, 4>::ConstTensor input,                             \\\n      typename TTypes<T, 4>::ConstTensor filter, int row_stride,            \\\n      int col_stride, int row_dilation, int col_dilation,                   \\\n      const Eigen::PaddingType& padding,                                    \\\n      const Eigen::NoOpOutputKernel& output_kernel);                        \\\n  template <>                                                               \\\n  void SpatialConvolution<GPUDevice, T>::operator()(                        \\\n      const GPUDevice& d, typename TTypes<T, 4>::Tensor output,             \\\n      typename TTypes<T, 4>::ConstTensor input,                             \\\n      typename TTypes<T, 4>::ConstTensor filter, int row_stride,            \\\n      int col_stride, int row_dilation, int col_dilation, int padding_top,  \\\n      int padding_bottom, int padding_left, int padding_right,              \\\n      const Eigen::NoOpOutputKernel& output_kernel);                        \\\n  extern template struct SpatialConvolution<GPUDevice, T>;                  \\\n  template <>                                                               \\\n  void MatMulConvFunctor<GPUDevice, T>::operator()(                         \\\n      const GPUDevice& d, typename TTypes<T, 2>::Tensor out,                \\\n      typename TTypes<T, 2>::ConstTensor in0,                               \\\n      typename TTypes<T, 2>::ConstTensor in1,                               \\\n      const Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1>& dim_pair, \\\n      const Eigen::NoOpOutputKernel& output_kernel);                        \\\n  extern template struct MatMulConvFunctor<GPUDevice, T>;                   \\\n  template <>                                                               \\\n  void TransformFilter<GPUDevice, T, int, 4>::operator()(                   \\\n      const GPUDevice& d, FilterTensorFormat dst_filter_format,             \\\n      typename TTypes<T, 4, int>::ConstTensor in,                           \\\n      typename TTypes<T, 4, int>::Tensor out);                              \\\n  extern template struct TransformFilter<GPUDevice, T, int, 4>;             \\\n  template <>                                                               \\\n  void PadInput<GPUDevice, T, int, 4>::operator()(                          \\\n      const GPUDevice& d, typename TTypes<T, 4, int>::ConstTensor in,       \\\n      const std::array<int, 2>& padding_left,                               \\\n      const std::array<int, 2>& padding_right,                              \\\n      typename TTypes<T, 4, int>::Tensor out, TensorFormat data_format,     \\\n      const T& padding_value);                                              \\\n  extern template struct PadInput<GPUDevice, T, int, 4>\n\nDECLARE_GPU_SPEC(float);\nDECLARE_GPU_SPEC(Eigen::half);\nDECLARE_GPU_SPEC(double);\nDECLARE_GPU_SPEC(int32);\n#undef DECLARE_GPU_SPEC\n\n}  // namespace functor\n\n// Registration of the GPU implementations.\nREGISTER_KERNEL_BUILDER(\n    Name(\"Conv2D\").Device(DEVICE_GPU).TypeConstraint<Eigen::half>(\"T\"),\n    Conv2DOp<GPUDevice, Eigen::half>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"Conv2D\").Device(DEVICE_GPU).TypeConstraint<float>(\"T\"),\n    Conv2DOp<GPUDevice, float>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"Conv2D\").Device(DEVICE_GPU).TypeConstraint<double>(\"T\"),\n    Conv2DOp<GPUDevice, double>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"Conv2D\").Device(DEVICE_GPU).TypeConstraint<int32>(\"T\"),\n    Conv2DOp<GPUDevice, int32>);\n\n// To be used inside depthwise_conv_op.cc.\ntemplate struct LaunchConv2DOp<GPUDevice, float>;\ntemplate struct LaunchConv2DOp<GPUDevice, Eigen::half>;\ntemplate struct LaunchConv2DOp<GPUDevice, double>;\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/nn_ops.cc.\n\n#define USE_EIGEN_TENSOR\n#define EIGEN_USE_THREADS\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define EIGEN_USE_GPU\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#include \"tensorflow/core/kernels/conv_ops.h\"\n\n#include <string.h>\n\n#include <atomic>\n#include <map>\n#include <vector>\n\n#include \"absl/synchronization/blocking_counter.h\"\n#include \"tensorflow/core/framework/allocator.h\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/kernel_shape_util.h\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_slice.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/conv_2d.h\"\n#include \"tensorflow/core/kernels/deep_conv2d.h\"\n#include \"tensorflow/core/kernels/ops_util.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/array_slice.h\"\n#include \"tensorflow/core/lib/strings/numbers.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/util/padding.h\"\n#include \"tensorflow/core/util/tensor_format.h\"\n#include \"tensorflow/core/util/use_cudnn.h\"\n\n#ifdef TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS\n#include \"tensorflow/core/kernels/xsmm_conv2d.h\"\n#endif\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/conv_ops_gpu.h\"\n#include \"tensorflow/core/platform/stream_executor.h\"\n#include \"tensorflow/core/protobuf/autotuning.pb.h\"\n#include \"tensorflow/core/util/proto/proto_utils.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#if GOOGLE_CUDA\n#include \"tensorflow/stream_executor/gpu/gpu_asm_opts.h\"\n#include \"tensorflow/stream_executor/gpu/redzone_allocator.h\"\n#include \"tensorflow/stream_executor/tf_allocator_adapter.h\"\n#endif  // GOOGLE_CUDA\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\nnamespace {\ntemplate <typename Device, typename T>\nstruct LaunchGeneric {\n  void operator()(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int row_stride, int col_stride,\n                  int row_dilation, int col_dilation, const Padding& padding,\n                  const std::vector<int64>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    CHECK(data_format == FORMAT_NHWC) << \"Generic conv implementation only \"\n                                         \"supports NHWC tensor format for now.\";\n    if (filter.dim_size(0) == 1 && filter.dim_size(1) == 1 && row_stride == 1 &&\n        col_stride == 1 && (padding == SAME || padding == VALID)) {\n      // For 1x1 kernel, the 2D convolution is reduced to matrix\n      // multiplication.\n      //\n      // TODO(vrv): We should be able to call SpatialConvolution\n      // and it will produce the same result, but doing so\n      // led to NaNs during training.  Using matmul instead for now.\n      int conv_width = 1;  // Width for the convolution step.\n      for (int i = 0; i < 3; ++i) {\n        conv_width *= output->dim_size(i);\n      }\n\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;\n      dim_pair[0] = Eigen::IndexPair<Eigen::DenseIndex>(1, 0);\n      functor::MatMulConvFunctor<Device, T>()(\n          ctx->eigen_device<Device>(),\n          output->shaped<T, 2>({conv_width, filter.dim_size(3)}),\n          input.shaped<T, 2>({conv_width, filter.dim_size(2)}),\n          filter.shaped<T, 2>({filter.dim_size(2), filter.dim_size(3)}),\n          dim_pair);\n    } else if (filter.dim_size(0) == input.dim_size(1) &&\n               filter.dim_size(1) == input.dim_size(2) && row_dilation == 1 &&\n               col_dilation == 1 && padding == VALID) {\n      // If the input data and filter have the same height/width,\n      // the 2D convolution is reduced to matrix multiplication.\n      const int k =  // Length of reduction dimension.\n          filter.dim_size(0) * filter.dim_size(1) * filter.dim_size(2);\n\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;\n      dim_pair[0] = Eigen::IndexPair<Eigen::DenseIndex>(1, 0);\n      functor::MatMulConvFunctor<Device, T>()(\n          ctx->eigen_device<Device>(),\n          output->shaped<T, 2>({input.dim_size(0), filter.dim_size(3)}),\n          input.shaped<T, 2>({input.dim_size(0), k}),\n          filter.shaped<T, 2>({k, filter.dim_size(3)}), dim_pair);\n    } else {\n      if (padding == EXPLICIT) {\n        functor::SpatialConvolution<Device, T>()(\n            ctx->eigen_device<Device>(), output->tensor<T, 4>(),\n            input.tensor<T, 4>(), filter.tensor<T, 4>(), row_stride, col_stride,\n            row_dilation, col_dilation, static_cast<int>(explicit_paddings[2]),\n            static_cast<int>(explicit_paddings[3]),\n            static_cast<int>(explicit_paddings[4]),\n            static_cast<int>(explicit_paddings[5]));\n      } else {\n        functor::SpatialConvolution<Device, T>()(\n            ctx->eigen_device<Device>(), output->tensor<T, 4>(),\n            input.tensor<T, 4>(), filter.tensor<T, 4>(), row_stride, col_stride,\n            row_dilation, col_dilation, BrainPadding2EigenPadding(padding));\n      }\n    }\n  }\n};\n\n// Compute grouped 2D convolutions on CPU. Unlike grouped convolution\n// implementation in cuDNN this is faaaaaar from optimal and needs more work\n// to deliver competitive performance. Currently it exists to close the feature\n// parity gap between convolution operations on different devices.\ntemplate <typename T>\nstruct LaunchGrouped {\n  void operator()(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int row_stride, int col_stride,\n                  int row_dilation, int col_dilation, const Padding& padding,\n                  const std::vector<int64>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    DCHECK(data_format == FORMAT_NHWC)\n        << \"Grouped conv implementation only \"\n           \"supports NHWC tensor format for now.\";\n\n    const int64 in_depth = input.dim_size(3);\n    const int64 patch_depth = filter.dim_size(2);\n    const int64 num_groups = in_depth / patch_depth;\n\n    // Shuffle input/filter tensors to have group as a leading dimension.\n    std::array<int64, 5> shuffle({3, 0, 1, 2, 4});\n\n    // Compute pre shuffle dimemnsions.\n    auto pre_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {\n      return {tensor.dim_size(0), tensor.dim_size(1), tensor.dim_size(2),\n              num_groups, tensor.dim_size(3) / num_groups};\n    };\n\n    // Compute post shuffle dimemnsions.\n    auto post_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {\n      return {num_groups, tensor.dim_size(0), tensor.dim_size(1),\n              tensor.dim_size(2), tensor.dim_size(3) / num_groups};\n    };\n\n    auto& device = ctx->eigen_device<CPUDevice>();\n\n    absl::BlockingCounter shuffles_completed(2);\n    auto on_shuffled = [&]() { shuffles_completed.DecrementCount(); };\n\n    // Shuffle input into temporary tensor.\n    Tensor input_shuffled(input.dtype(), TensorShape(post_shuffle(input)));\n    input_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        input.shaped<T, 5>(pre_shuffle(input)).shuffle(shuffle);\n\n    // Shuffle filter into temporary tensor.\n    Tensor filter_shuffled(filter.dtype(), TensorShape(post_shuffle(filter)));\n    filter_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        filter.shaped<T, 5>(pre_shuffle(filter)).shuffle(shuffle);\n\n    // Wait for the completion of input/filter shuffles.\n    shuffles_completed.Wait();\n\n    // Write group convolution results into temporary output tensor.\n    Tensor output_shuffled(output->dtype(), TensorShape(post_shuffle(*output)));\n\n    for (int64 i = 0; i < num_groups; ++i) {\n      // TODO(ezhulenev): Run this loop using `parallelFor` (regular parallelFor\n      // will lead to deadlock, SpatialConvolution has to use async Eigen\n      // assignment). This requires small changes to Eigen to support async\n      // exeuction for tensor chipping operation.\n\n      // TODO(ezhulenev): Grouped convolution should also support 1x1 filter\n      // optimization.\n\n      auto input_slice = input_shuffled.tensor<T, 5>().template chip<0>(i);\n      auto filter_slice = filter_shuffled.tensor<T, 5>().template chip<0>(i);\n      auto output_slice = output_shuffled.tensor<T, 5>().template chip<0>(i);\n\n      if (padding == EXPLICIT) {\n        functor::SpatialConvolution<CPUDevice, T>()(\n            ctx->eigen_device<CPUDevice>(), output_slice, input_slice,\n            filter_slice, row_stride, col_stride, row_dilation, col_dilation,\n            static_cast<int>(explicit_paddings[2]),\n            static_cast<int>(explicit_paddings[3]),\n            static_cast<int>(explicit_paddings[4]),\n            static_cast<int>(explicit_paddings[5]));\n      } else {\n        functor::SpatialConvolution<CPUDevice, T>()(\n            ctx->eigen_device<CPUDevice>(), output_slice, input_slice,\n            filter_slice, row_stride, col_stride, row_dilation, col_dilation,\n            BrainPadding2EigenPadding(padding));\n      }\n    }\n\n    // Shuffle temporary output back into pre-shuffled shape.\n    std::array<int64, 5> rev_shuffle({1, 2, 3, 0, 4});\n    output->shaped<T, 5>(pre_shuffle(*output)).device(device) =\n        output_shuffled.tensor<T, 5>().shuffle(rev_shuffle);\n  }\n};\n\n}  // namespace\n\ntemplate <typename T>\nstruct LaunchConv2DOp<CPUDevice, T> {\n  void operator()(OpKernelContext* ctx, bool use_cudnn, bool cudnn_use_autotune,\n                  const Tensor& input, const Tensor& filter, int row_dilation,\n                  int col_dilation, int row_stride, int col_stride,\n                  const Padding& padding,\n                  const std::vector<int64>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    if (data_format != FORMAT_NHWC) {\n      ctx->SetStatus(errors::Unimplemented(\n          \"The Conv2D op currently only supports the NHWC tensor format on the \"\n          \"CPU. The op was given the format: \",\n          ToString(data_format)));\n      return;\n    }\n\n    for (int64 explicit_padding : explicit_paddings) {\n      if (!FastBoundsCheck(explicit_padding, std::numeric_limits<int>::max())) {\n        ctx->SetStatus(errors::InvalidArgument(\"filter too large\"));\n        return;\n      }\n    }\n\n    const int64 in_depth = input.dim_size(3);\n    const int64 out_depth = output->dim_size(3);\n    const int64 patch_depth = filter.dim_size(2);\n\n    if (patch_depth <= 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"filter depth must be stricly positive, got \", patch_depth));\n      return;\n    }\n    if (in_depth % patch_depth != 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"input depth must be evenly divisible by filter depth: \", in_depth,\n          \" vs \", patch_depth));\n      return;\n    }\n\n    const int64 num_groups = in_depth / patch_depth;\n    if (num_groups <= 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"number of groups must be stricly positive, got \", num_groups));\n      return;\n    }\n    if (out_depth % num_groups != 0 || out_depth < num_groups) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"output depth must be evenly divisible by number of groups: \",\n          out_depth, \" vs \", num_groups));\n      return;\n    }\n\n    if (in_depth != patch_depth) {\n      LaunchGrouped<T>()(ctx, input, filter, row_stride, col_stride,\n                         row_dilation, col_dilation, padding, explicit_paddings,\n                         output, data_format);\n    } else {\n      LaunchGeneric<CPUDevice, T>()(ctx, input, filter, row_stride, col_stride,\n                                    row_dilation, col_dilation, padding,\n                                    explicit_paddings, output, data_format);\n    }\n  }\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\ntemplate <>\nstruct LaunchConv2DOp<GPUDevice, int32> {\n  void operator()(OpKernelContext* ctx, bool use_cudnn, bool cudnn_use_autotune,\n                  const Tensor& input, const Tensor& filter, int row_dilation,\n                  int col_dilation, int row_stride, int col_stride,\n                  const Padding& padding,\n                  const std::vector<int64>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    if (data_format != FORMAT_NHWC) {\n      ctx->SetStatus(\n          errors::Unimplemented(\"The Conv2D op currently only supports the \"\n                                \"NHWC tensor format for integer types. \"\n                                \"The op was given the format: \",\n                                ToString(data_format)));\n      return;\n    }\n    const int64 in_depth = GetTensorDim(input, data_format, 'C');\n    OP_REQUIRES(ctx, in_depth == filter.dim_size(2),\n                errors::Unimplemented(\n                    \"The Conv2D op currently does not support grouped \"\n                    \"convolutions for integer types. A grouped convolution was \"\n                    \"attempted to be run because the input depth of \",\n                    in_depth, \" does not match the filter input depth of \",\n                    filter.dim_size(2)));\n\n    for (int64 explicit_padding : explicit_paddings) {\n      if (!FastBoundsCheck(explicit_padding, std::numeric_limits<int>::max())) {\n        ctx->SetStatus(errors::InvalidArgument(\"filter too large\"));\n        return;\n      }\n    }\n    LaunchGeneric<GPUDevice, int32>()(\n        ctx, input, filter, row_stride, col_stride, row_dilation, col_dilation,\n        padding, explicit_paddings, output, data_format);\n  }\n};\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename Device, typename T>\nclass LaunchDeepConvOp {\n public:\n  static bool Run(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int batch, int input_rows,\n                  int input_cols, int in_depth, int filter_rows,\n                  int filter_cols, int pad_rows, int pad_cols, int out_rows,\n                  int /*out_cols*/, int /*out_depth*/, int /*dilation_rows*/,\n                  int /*dilation_cols*/, int /*stride_rows*/,\n                  int /*stride_cols*/, Tensor* /*output*/,\n                  TensorFormat /*data_format*/) {\n    return false;\n  }\n};\n\n// Conditionally launches DeepConv operation based on convolution parameters.\ntemplate <>\nclass LaunchDeepConvOp<CPUDevice, float> {\n public:\n  static bool Run(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int batch, int input_rows,\n                  int input_cols, int in_depth, int filter_rows,\n                  int filter_cols, int pad_rows, int pad_cols, int out_rows,\n                  int out_cols, int out_depth, int dilation_rows,\n                  int dilation_cols, int stride_rows, int stride_cols,\n                  Tensor* output, TensorFormat data_format) {\n    if (data_format != FORMAT_NHWC || dilation_rows != 1 ||\n        dilation_cols != 1 ||\n        !CanUseDeepConv2D(stride_rows, stride_cols, filter_rows, filter_cols,\n                          in_depth, out_depth, out_rows, out_cols)) {\n      return false;\n    }\n\n    Conv2DArgs args;\n    args.batch = batch;\n    args.in_rows = input_rows;\n    args.in_cols = input_cols;\n    args.in_depth = in_depth;\n    args.filter_rows = filter_rows;\n    args.filter_cols = filter_cols;\n    args.pad_rows = pad_rows;\n    args.pad_cols = pad_cols;\n    args.out_rows = out_rows;\n    args.out_cols = out_cols;\n    args.out_depth = out_depth;\n\n    auto input_ptr = input.template flat<float>().data();\n    auto filter_ptr = filter.template flat<float>().data();\n    auto output_ptr = output->template flat<float>().data();\n\n    functor::DeepConv2D<CPUDevice, float>()(ctx, args, input_ptr, filter_ptr,\n                                            output_ptr);\n    return true;\n  }\n};\n\n#ifdef TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS\ntemplate <typename Device, typename T>\nclass LaunchXsmmConvOp {\n public:\n  static bool Run(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int batch, int input_rows,\n                  int input_cols, int in_depth, int filter_rows,\n                  int filter_cols, int pad_rows, int pad_cols, int out_rows,\n                  int out_cols, int out_depth, int stride_rows, int stride_cols,\n                  int dilation_rows, int dilation_cols, Tensor* output,\n                  TensorFormat data_format) {\n    return false;\n  }\n};\n\ntemplate <>\nclass LaunchXsmmConvOp<CPUDevice, float> {\n public:\n  static bool Run(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int batch, int input_rows,\n                  int input_cols, int in_depth, int filter_rows,\n                  int filter_cols, int pad_rows, int pad_cols, int out_rows,\n                  int out_cols, int out_depth, int dilation_rows,\n                  int dilation_cols, int stride_rows, int stride_cols,\n                  Tensor* output, TensorFormat data_format) {\n    auto num_threads =\n        ctx->device()->tensorflow_cpu_worker_threads()->num_threads;\n    // See libxsmm_dnn.h for this struct definition.\n    libxsmm_dnn_conv_desc desc;\n    desc.N = batch;\n    desc.C = in_depth;\n    desc.H = input_rows;\n    desc.W = input_cols;\n    desc.K = out_depth;\n    desc.R = filter_rows;\n    desc.S = filter_cols;\n    desc.u = stride_rows;\n    desc.v = stride_cols;\n    desc.pad_h = pad_rows;\n    desc.pad_w = pad_cols;\n    desc.pad_h_in = 0;\n    desc.pad_w_in = 0;\n    desc.pad_h_out = 0;\n    desc.pad_w_out = 0;\n    desc.threads = num_threads;\n    desc.algo = LIBXSMM_DNN_CONV_ALGO_DIRECT;\n    desc.buffer_format = LIBXSMM_DNN_TENSOR_FORMAT_NHWC;\n    desc.filter_format = LIBXSMM_DNN_TENSOR_FORMAT_LIBXSMM;\n    desc.fuse_ops = LIBXSMM_DNN_CONV_FUSE_NONE;\n    desc.options = LIBXSMM_DNN_CONV_OPTION_OVERWRITE;\n    desc.datatype_out = LIBXSMM_DNN_DATATYPE_F32;\n    desc.datatype_in = LIBXSMM_DNN_DATATYPE_F32;\n    if (dilation_rows != 1 || dilation_cols != 1 ||\n        !CanUseXsmmConv2D(desc, data_format)) {\n      return false;\n    }\n\n    auto input_ptr = input.template flat<float>().data();\n    auto filter_ptr = filter.template flat<float>().data();\n    auto output_ptr = output->template flat<float>().data();\n\n    bool success = functor::XsmmFwdConv2D<CPUDevice, float>()(\n        ctx, desc, input_ptr, filter_ptr, output_ptr);\n    return success;\n  }\n};\n#endif\n\n#define TF_REQUIRES(EXP, STATUS)                \\\n  do {                                          \\\n    if (!TF_PREDICT_TRUE(EXP)) return (STATUS); \\\n  } while (false)\n\nStatus InitConv2DParameters(const OpKernelConstruction* context,\n                            Conv2DParameters* params) {\n  TF_RETURN_IF_ERROR(context->GetAttr(\"dilations\", &params->dilations));\n  TF_RETURN_IF_ERROR(context->GetAttr(\"strides\", &params->strides));\n  TF_RETURN_IF_ERROR(context->GetAttr(\"padding\", &params->padding));\n  if (context->HasAttr(\"explicit_paddings\")) {\n    TF_RETURN_IF_ERROR(\n        context->GetAttr(\"explicit_paddings\", &params->explicit_paddings));\n  }\n  string data_format_string;\n  TF_RETURN_IF_ERROR(context->GetAttr(\"data_format\", &data_format_string));\n  TF_REQUIRES(FormatFromString(data_format_string, &params->data_format),\n              errors::InvalidArgument(\"Invalid data format\"));\n\n  const auto& strides = params->strides;\n  const auto& dilations = params->dilations;\n  const auto& data_format = params->data_format;\n\n  TF_REQUIRES(dilations.size() == 4,\n              errors::InvalidArgument(\"Sliding window dilations field must \"\n                                      \"specify 4 dimensions\"));\n  TF_REQUIRES(strides.size() == 4,\n              errors::InvalidArgument(\"Sliding window strides field must \"\n                                      \"specify 4 dimensions\"));\n  const int64 stride_n = GetTensorDim(strides, data_format, 'N');\n  const int64 stride_c = GetTensorDim(strides, data_format, 'C');\n  const int64 stride_h = GetTensorDim(strides, data_format, 'H');\n  const int64 stride_w = GetTensorDim(strides, data_format, 'W');\n  TF_REQUIRES(\n      stride_n == 1 && stride_c == 1,\n      errors::Unimplemented(\"Current implementation does not yet support \"\n                            \"strides in the batch and depth dimensions.\"));\n  TF_REQUIRES(stride_h > 0 && stride_w > 0,\n              errors::InvalidArgument(\n                  \"Row and column strides should be larger than 0.\"));\n\n  const int64 dilation_n = GetTensorDim(dilations, data_format, 'N');\n  const int64 dilation_c = GetTensorDim(dilations, data_format, 'C');\n  const int64 dilation_h = GetTensorDim(dilations, data_format, 'H');\n  const int64 dilation_w = GetTensorDim(dilations, data_format, 'W');\n  TF_REQUIRES(\n      dilation_n == 1 && dilation_c == 1,\n      errors::Unimplemented(\"Current implementation does not yet support \"\n                            \"dilations in the batch and depth dimensions.\"));\n  TF_REQUIRES(\n      dilation_h > 0 && dilation_w > 0,\n      errors::InvalidArgument(\"Dilated rates should be larger than 0.\"));\n\n  TF_RETURN_IF_ERROR(CheckValidPadding(params->padding,\n                                       params->explicit_paddings,\n                                       /*num_dims=*/4, data_format));\n\n  return Status::OK();\n}\n\nStatus ComputeConv2DDimension(const Conv2DParameters& params,\n                              const Tensor& input, const Tensor& filter,\n                              Conv2DDimensions* dimensions) {\n  // Check that 2D convolution input and filter have exactly 4 dimensions.\n  TF_REQUIRES(input.dims() == 4,\n              errors::InvalidArgument(\"input must be 4-dimensional\",\n                                      input.shape().DebugString()));\n  TF_REQUIRES(filter.dims() == 4,\n              errors::InvalidArgument(\"filter must be 4-dimensional: \",\n                                      filter.shape().DebugString()));\n  for (int i = 0; i < 3; i++) {\n    TF_REQUIRES(\n        FastBoundsCheck(filter.dim_size(i), std::numeric_limits<int>::max()),\n        errors::InvalidArgument(\"filter too large\"));\n  }\n\n  // The last dimension for input is in_depth. Check that it is the same as the\n  // filter's in_depth or it is evenly divisible by filter's in_depth.\n  const int64 in_depth_raw = GetTensorDim(input, params.data_format, 'C');\n  const int64 patch_depth_raw = filter.dim_size(2);\n  TF_REQUIRES(FastBoundsCheck(in_depth_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Input depth too large\"));\n  TF_REQUIRES(FastBoundsCheck(patch_depth_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Patch depth too large\"));\n  const int in_depth = static_cast<int>(in_depth_raw);\n  const int patch_depth = static_cast<int>(patch_depth_raw);\n  TF_REQUIRES(patch_depth > 0,\n              errors::InvalidArgument(\n                  \"filter depth must be stricly positive, got \", patch_depth));\n  TF_REQUIRES(in_depth % patch_depth == 0,\n              errors::InvalidArgument(\n                  \"input depth must be evenly divisible by filter depth: \",\n                  in_depth, \" vs \", patch_depth));\n\n  // The last dimension for filter is out_depth.\n  const int out_depth = static_cast<int>(filter.dim_size(3));\n\n  // The second dimension for input is rows/height.\n  // The first dimension for filter is rows/height.\n  const int64 input_rows_raw = GetTensorDim(input, params.data_format, 'H');\n  TF_REQUIRES(FastBoundsCheck(input_rows_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Input rows too large\"));\n  const int input_rows = static_cast<int>(input_rows_raw);\n  const int filter_rows = static_cast<int>(filter.dim_size(0));\n\n  // The third dimension for input is columns/width.\n  // The second dimension for filter is columns/width.\n  const int64 input_cols_raw = GetTensorDim(input, params.data_format, 'W');\n  TF_REQUIRES(FastBoundsCheck(input_cols_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Input cols too large\"));\n  const int input_cols = static_cast<int>(input_cols_raw);\n  const int filter_cols = static_cast<int>(filter.dim_size(1));\n\n  // The first dimension for input is batch.\n  const int64 batch_raw = GetTensorDim(input, params.data_format, 'N');\n  TF_REQUIRES(FastBoundsCheck(batch_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"batch is too large\"));\n  const int batch = static_cast<int>(batch_raw);\n\n  // Take the stride and dilation from the second and third dimensions only (we\n  // do not support striding or dilation on the batch or depth dimension).\n  const int stride_rows = GetTensorDim(params.strides, params.data_format, 'H');\n  const int stride_cols = GetTensorDim(params.strides, params.data_format, 'W');\n  const int dilation_rows =\n      GetTensorDim(params.dilations, params.data_format, 'H');\n  const int dilation_cols =\n      GetTensorDim(params.dilations, params.data_format, 'W');\n\n  int64 pad_rows_before, pad_rows_after, pad_cols_before, pad_cols_after;\n  if (params.padding == Padding::EXPLICIT) {\n    GetExplicitPaddingForDim(params.explicit_paddings, params.data_format, 'H',\n                             &pad_rows_before, &pad_rows_after);\n    GetExplicitPaddingForDim(params.explicit_paddings, params.data_format, 'W',\n                             &pad_cols_before, &pad_cols_after);\n  }\n\n  // Compute windowed output sizes for rows and columns.\n  int64 out_rows = 0, out_cols = 0;\n  TF_RETURN_IF_ERROR(GetWindowedOutputSizeVerboseV2(\n      input_rows, filter_rows, dilation_rows, stride_rows, params.padding,\n      &out_rows, &pad_rows_before, &pad_rows_after));\n  TF_RETURN_IF_ERROR(GetWindowedOutputSizeVerboseV2(\n      input_cols, filter_cols, dilation_cols, stride_cols, params.padding,\n      &out_cols, &pad_cols_before, &pad_cols_after));\n\n  dimensions->batch = batch;\n  dimensions->input_rows = input_rows;\n  dimensions->input_cols = input_cols;\n  dimensions->in_depth = in_depth;\n  dimensions->filter_rows = filter_rows;\n  dimensions->filter_cols = filter_cols;\n  dimensions->patch_depth = patch_depth;\n  dimensions->out_depth = out_depth;\n  dimensions->stride_rows = stride_rows;\n  dimensions->stride_cols = stride_cols;\n  dimensions->dilation_rows = dilation_rows;\n  dimensions->dilation_cols = dilation_cols;\n  dimensions->out_rows = out_rows;\n  dimensions->out_cols = out_cols;\n  dimensions->pad_rows_before = pad_rows_before;\n  dimensions->pad_rows_after = pad_rows_after;\n  dimensions->pad_cols_before = pad_cols_before;\n  dimensions->pad_cols_after = pad_cols_after;\n\n  return Status::OK();\n}\n\n#undef TF_REQUIRES\n\ntemplate <typename Device, typename T>\nclass Conv2DOp : public BinaryOp<T> {\n public:\n  explicit Conv2DOp(OpKernelConstruction* context) : BinaryOp<T>(context) {\n    OP_REQUIRES_OK(context, InitConv2DParameters(context, &params_));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"use_cudnn_on_gpu\", &use_cudnn_));\n    cudnn_use_autotune_ = CudnnUseAutotune();\n  }\n\n  void Compute(OpKernelContext* context) override {\n    // Input tensor is of the following dimensions:\n    // [ batch, in_rows, in_cols, in_depth ]\n    const Tensor& input = context->input(0);\n\n    // Input filter is of the following dimensions:\n    // [ filter_rows, filter_cols, in_depth, out_depth]\n    const Tensor& filter = context->input(1);\n\n    Conv2DDimensions dimensions;\n    OP_REQUIRES_OK(context,\n                   ComputeConv2DDimension(params_, input, filter, &dimensions));\n\n    TensorShape out_shape = ShapeFromFormat(\n        params_.data_format, dimensions.batch, dimensions.out_rows,\n        dimensions.out_cols, dimensions.out_depth);\n\n    // Output tensor is of the following dimensions:\n    // [ in_batch, out_rows, out_cols, out_depth ]\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n\n    VLOG(2) << \"Conv2D: in_depth = \" << dimensions.in_depth\n            << \", patch_depth = \" << dimensions.patch_depth\n            << \", input_cols = \" << dimensions.input_cols\n            << \", filter_cols = \" << dimensions.filter_cols\n            << \", input_rows = \" << dimensions.input_rows\n            << \", filter_rows = \" << dimensions.filter_rows\n            << \", stride_rows = \" << dimensions.stride_rows\n            << \", stride_cols = \" << dimensions.stride_cols\n            << \", dilation_rows = \" << dimensions.dilation_rows\n            << \", dilation_cols = \" << dimensions.dilation_cols\n            << \", out_depth = \" << dimensions.out_depth;\n\n    // If there is nothing to compute, return.\n    if (out_shape.num_elements() == 0) {\n      return;\n    }\n\n#ifdef TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS\n    if (params_.padding != EXPLICIT &&\n        LaunchXsmmConvOp<Device, T>::Run(\n            context, input, filter, dimensions.batch, dimensions.input_rows,\n            dimensions.input_cols, dimensions.in_depth, dimensions.filter_rows,\n            dimensions.filter_cols, dimensions.pad_rows_before,\n            dimensions.pad_cols_before, dimensions.out_rows,\n            dimensions.out_cols, dimensions.out_depth, dimensions.dilation_rows,\n            dimensions.dilation_cols, dimensions.stride_rows,\n            dimensions.stride_cols, output, params_.data_format)) {\n      return;\n    }\n#endif\n\n    if (params_.padding != EXPLICIT &&\n        LaunchDeepConvOp<Device, T>::Run(\n            context, input, filter, dimensions.batch, dimensions.input_rows,\n            dimensions.input_cols, dimensions.in_depth, dimensions.filter_rows,\n            dimensions.filter_cols, dimensions.pad_rows_before,\n            dimensions.pad_cols_before, dimensions.out_rows,\n            dimensions.out_cols, dimensions.out_depth, dimensions.dilation_rows,\n            dimensions.dilation_cols, dimensions.stride_rows,\n            dimensions.stride_cols, output, params_.data_format)) {\n      return;\n    }\n\n    launcher_(context, use_cudnn_, cudnn_use_autotune_, input, filter,\n              dimensions.dilation_rows, dimensions.dilation_cols,\n              dimensions.stride_rows, dimensions.stride_cols, params_.padding,\n              params_.explicit_paddings, output, params_.data_format);\n  }\n\n private:\n  Conv2DParameters params_;\n  bool use_cudnn_;\n  bool cudnn_use_autotune_;\n\n  LaunchConv2DOp<Device, T> launcher_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(Conv2DOp);\n};\n\n#define REGISTER_CPU(T)                                         \\\n  REGISTER_KERNEL_BUILDER(                                      \\\n      Name(\"Conv2D\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      Conv2DOp<CPUDevice, T>);\n\n// If we're using the alternative GEMM-based implementation of Conv2D for the\n// CPU implementation, don't register this EigenTensor-based version.\n#if !defined(USE_GEMM_FOR_CONV)\nTF_CALL_half(REGISTER_CPU);\nTF_CALL_float(REGISTER_CPU);\nTF_CALL_double(REGISTER_CPU);\nTF_CALL_int32(REGISTER_CPU);\n#endif  // USE_GEMM_FOR_CONV\n\n// To be used inside depthwise_conv_op.cc.\ntemplate struct LaunchConv2DOp<CPUDevice, Eigen::half>;\ntemplate struct LaunchConv2DOp<CPUDevice, float>;\ntemplate struct LaunchConv2DOp<CPUDevice, double>;\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nint64 GetDnnWorkspaceLimit(const string& envvar_in_mb,\n                           int64 default_value_in_bytes) {\n  const char* workspace_limit_in_mb_str = getenv(envvar_in_mb.c_str());\n  if (workspace_limit_in_mb_str != nullptr &&\n      strcmp(workspace_limit_in_mb_str, \"\") != 0) {\n    int64 scratch_limit_in_mb = -1;\n    if (strings::safe_strto64(workspace_limit_in_mb_str,\n                              &scratch_limit_in_mb)) {\n      return scratch_limit_in_mb * (1 << 20);\n    } else {\n      LOG(WARNING) << \"Invalid value for env-var \" << envvar_in_mb << \": \"\n                   << workspace_limit_in_mb_str;\n    }\n  }\n  return default_value_in_bytes;\n}\n\n// A dummy type to group forward convolution autotune results together.\nstruct ConvAutoTuneGroup {\n  static string name() { return \"Conv\"; }\n};\n\ntypedef AutoTuneSingleton<ConvAutoTuneGroup, ConvParameters,\n                          se::dnn::AlgorithmConfig>\n    AutoTuneConv;\n\ntemplate <typename T>\nvoid LaunchConv2DOp<GPUDevice, T>::operator()(\n    OpKernelContext* ctx, bool use_cudnn, bool cudnn_use_autotune,\n    const Tensor& input_param, const Tensor& filter, int row_dilation,\n    int col_dilation, int row_stride, int col_stride, const Padding& padding,\n    const std::vector<int64>& explicit_paddings, Tensor* output,\n    TensorFormat data_format) {\n  using se::dnn::AlgorithmConfig;\n  using se::dnn::AlgorithmDesc;\n  using se::dnn::ProfileResult;\n  auto* stream = ctx->op_device_context()->stream();\n  OP_REQUIRES(ctx, stream, errors::Internal(\"No GPU stream available.\"));\n\n  if (!use_cudnn) {\n    ctx->SetStatus(\n        errors::Unimplemented(\"Conv2D for GPU is not currently supported \"\n                              \"without cudnn\"));\n    return;\n  }\n\n  Tensor input = input_param;\n  const int64 in_batch = GetTensorDim(input, data_format, 'N');\n  int64 in_rows = GetTensorDim(input, data_format, 'H');\n  int64 in_cols = GetTensorDim(input, data_format, 'W');\n  const int64 in_depths = GetTensorDim(input, data_format, 'C');\n  const int64 patch_rows = filter.dim_size(0);\n  const int64 patch_cols = filter.dim_size(1);\n  const int64 patch_depths = filter.dim_size(2);\n\n  // If the filter in-depth (patch_depths) is 1 and smaller than the input\n  // depth, it's a depthwise convolution. More generally, if the filter in-depth\n  // divides but is smaller than the input depth, it is a grouped convolution.\n  bool is_grouped_convolution = patch_depths != in_depths;\n  if (patch_rows == 1 && patch_cols == 1 && !is_grouped_convolution &&\n      row_dilation == 1 && col_dilation == 1 && row_stride == 1 &&\n      col_stride == 1 && data_format == FORMAT_NHWC &&\n      (padding == VALID || padding == SAME)) {\n    // 1x1 filter, so call cublas directly.\n    const uint64 m = in_batch * in_rows * in_cols;\n    const uint64 k = patch_depths;\n    const uint64 n = filter.dim_size(3);\n\n    auto a_ptr = AsDeviceMemory(input.template flat<T>().data(),\n                                input.template flat<T>().size());\n    auto b_ptr = AsDeviceMemory(filter.template flat<T>().data(),\n                                filter.template flat<T>().size());\n    auto c_ptr = AsDeviceMemory(output->template flat<T>().data(),\n                                output->template flat<T>().size());\n\n    auto no_transpose = se::blas::Transpose::kNoTranspose;\n    bool blas_launch_status =\n        stream\n            ->ThenBlasGemm(no_transpose, no_transpose, n, m, k, 1.0f, b_ptr, n,\n                           a_ptr, k, 0.0f, &c_ptr, n)\n            .ok();\n    if (!blas_launch_status) {\n      ctx->SetStatus(errors::Internal(\"Blas SGEMM launch failed : m=\", m,\n                                      \", n=\", n, \", k=\", k));\n    }\n    return;\n  } else if (patch_rows == in_rows && patch_cols == in_cols &&\n             !is_grouped_convolution && row_dilation == 1 &&\n             col_dilation == 1 && padding == VALID &&\n             data_format == FORMAT_NHWC) {\n    // The input data and filter have the same height/width, so call cublas\n    // directly.\n    const uint64 m = in_batch;\n    const uint64 k = patch_rows * patch_cols * patch_depths;\n    const uint64 n = filter.dim_size(3);\n\n    auto a_ptr = AsDeviceMemory(input.template flat<T>().data(),\n                                input.template flat<T>().size());\n    auto b_ptr = AsDeviceMemory(filter.template flat<T>().data(),\n                                filter.template flat<T>().size());\n    auto c_ptr = AsDeviceMemory(output->template flat<T>().data(),\n                                output->template flat<T>().size());\n\n    auto no_transpose = se::blas::Transpose::kNoTranspose;\n    bool blas_launch_status =\n        stream\n            ->ThenBlasGemm(no_transpose, no_transpose, n, m, k, 1.0f, b_ptr, n,\n                           a_ptr, k, 0.0f, &c_ptr, n)\n            .ok();\n    if (!blas_launch_status) {\n      ctx->SetStatus(errors::Internal(\"Blas SGEMM launch failed : m=\", m,\n                                      \", n=\", n, \", k=\", k));\n    }\n    return;\n  }\n\n#if GOOGLE_CUDA\n  // Tensor Core (NVIDIA Volta+ GPUs) supports efficient convolution with fp16\n  // in NHWC data layout. In all other configurations it's more efficient to\n  // run computation in NCHW data format.\n  const bool compute_in_nhwc =\n      DataTypeToEnum<T>::value == DT_HALF && IsVoltaOrLater(*stream->parent());\n#else\n  // fast NHWC implementation is a CUDA only feature\n  const bool compute_in_nhwc = false;\n#endif\n\n  // We only do one directional conversion: NHWC->NCHW. We never convert in the\n  // other direction. Grappler layout optimizer selects preferred layout and\n  // adds necessary annotations to the graph.\n  // TODO(ezhulenev): Convert in other direction for fp16?\n  const TensorFormat compute_data_format =\n      (compute_in_nhwc && data_format == FORMAT_NHWC) ? FORMAT_NHWC\n                                                      : FORMAT_NCHW;\n\n  VLOG(3) << \"Compute Conv2D with cuDNN:\"\n          << \" data_format=\" << ToString(data_format)\n          << \" compute_data_format=\" << ToString(compute_data_format);\n\n  const int64 out_batch = GetTensorDim(*output, data_format, 'N');\n  const int64 out_rows = GetTensorDim(*output, data_format, 'H');\n  const int64 out_cols = GetTensorDim(*output, data_format, 'W');\n  const int64 out_depths = GetTensorDim(*output, data_format, 'C');\n  int64 padding_top = -1, padding_bottom = -1;\n  int64 padding_left = -1, padding_right = -1;\n  if (padding == EXPLICIT) {\n    GetExplicitPaddingForDim(explicit_paddings, data_format, 'H', &padding_top,\n                             &padding_bottom);\n    GetExplicitPaddingForDim(explicit_paddings, data_format, 'W', &padding_left,\n                             &padding_right);\n  }\n  int64 out_rows_check, out_cols_check;\n  Status status = GetWindowedOutputSizeVerboseV2(\n      in_rows, patch_rows, row_dilation, row_stride, padding, &out_rows_check,\n      &padding_top, &padding_bottom);\n  // The status is guaranteed to be OK because we checked the output and padding\n  // was valid earlier.\n  TF_CHECK_OK(status);\n  DCHECK_EQ(out_rows, out_rows_check);\n  status = GetWindowedOutputSizeVerboseV2(in_cols, patch_cols, col_dilation,\n                                          col_stride, padding, &out_cols_check,\n                                          &padding_left, &padding_right);\n  TF_CHECK_OK(status);\n  DCHECK_EQ(out_cols, out_cols_check);\n\n  const int64 common_padding_rows = std::min(padding_top, padding_bottom);\n  const int64 common_padding_cols = std::min(padding_left, padding_right);\n  if (padding_top != padding_bottom || padding_left != padding_right) {\n    // cuDNN only supports padding the same amount on the left and right sides,\n    // and on the top and bottom sides. So we manually create a new padded\n    // input tensor such that we can pass it to cuDNN.\n    VLOG(4) << \"Pad input tensor:\"\n            << \" padding_top=\" << padding_top\n            << \" padding_bottom=\" << padding_bottom\n            << \" padding_left=\" << padding_left\n            << \" padding_right=\" << padding_right;\n\n    // TODO(reedwm): In some cases, we can avoid an allocation even if the two\n    // padding sides are different. For example, if the input is 2x2, the filter\n    // is 1x1, the stride is 2, and the padding is (1, 0, 1, 0), the result is\n    // equivalent to as if the padding is (1, 1, 1, 1). Changing the padding in\n    // such a way would allow us to avoid the allocation.\n    Tensor transformed_input;\n    const int64 padding_rows_diff = std::abs(padding_bottom - padding_top);\n    const int64 padding_cols_diff = std::abs(padding_right - padding_left);\n    const int64 new_in_rows = in_rows + padding_rows_diff;\n    const int64 new_in_cols = in_cols + padding_cols_diff;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(\n                            DataTypeToEnum<T>::value,\n                            ShapeFromFormat(data_format, in_batch, new_in_rows,\n                                            new_in_cols, in_depths),\n                            &transformed_input));\n\n    const int64 input_pad_top = padding_top - common_padding_rows;\n    const int64 input_pad_bottom = padding_bottom - common_padding_rows;\n    const int64 input_pad_left = padding_left - common_padding_cols;\n    const int64 input_pad_right = padding_right - common_padding_cols;\n    bool in_bounds =\n        FastBoundsCheck(input_pad_top, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_bottom, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_left, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_right, std::numeric_limits<int>::max());\n    if (!in_bounds) {\n      ctx->SetStatus(errors::InvalidArgument(\"Padding is too large.\"));\n      return;\n    }\n    functor::PadInput<GPUDevice, T, int, 4>()(\n        ctx->eigen_device<GPUDevice>(), To32Bit(input_param.tensor<T, 4>()),\n        {{static_cast<int>(input_pad_top), static_cast<int>(input_pad_left)}},\n        {{static_cast<int>(input_pad_bottom),\n          static_cast<int>(input_pad_right)}},\n        To32Bit(transformed_input.tensor<T, 4>()), data_format, T{});\n\n    input = transformed_input;\n    in_rows = new_in_rows;\n    in_cols = new_in_cols;\n  }\n\n  if (data_format == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {\n    VLOG(4) << \"Convert the input tensor from NHWC to NCHW.\";\n\n    TensorShape nchw_shape =\n        ShapeFromFormat(FORMAT_NCHW, in_batch, in_rows, in_cols, in_depths);\n    if (in_depths > 1) {\n      Tensor transformed_input;\n      OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                             nchw_shape, &transformed_input));\n      functor::NHWCToNCHW<GPUDevice, T, 4>()(\n          ctx->eigen_device<GPUDevice>(),\n          const_cast<const Tensor&>(input).tensor<T, 4>(),\n          transformed_input.tensor<T, 4>());\n      input = transformed_input;\n    } else {\n      // If depth <= 1, then just reshape.\n      CHECK(input.CopyFrom(input, nchw_shape));\n    }\n  } else {\n    CHECK(data_format == compute_data_format)  // Crash OK\n        << \"Illegal data and compute format pair:\"\n        << \" data_format=\" << ToString(data_format)\n        << \" compute_data_format=\" << ToString(compute_data_format);\n  }\n\n  CHECK(common_padding_rows >= 0 && common_padding_cols >= 0)  // Crash OK\n      << \"Negative row or col paddings: (\" << common_padding_rows << \", \"\n      << common_padding_cols << \")\";\n\n  constexpr auto kComputeInNHWC =\n      std::make_tuple(se::dnn::DataLayout::kBatchYXDepth,\n                      se::dnn::FilterLayout::kOutputYXInput);\n  constexpr auto kComputeInNCHW =\n      std::make_tuple(se::dnn::DataLayout::kBatchDepthYX,\n                      se::dnn::FilterLayout::kOutputInputYX);\n\n  se::dnn::DataLayout compute_data_layout;\n  se::dnn::FilterLayout filter_layout;\n\n  std::tie(compute_data_layout, filter_layout) =\n      compute_data_format == FORMAT_NHWC ? kComputeInNHWC : kComputeInNCHW;\n\n  se::dnn::BatchDescriptor input_desc;\n  input_desc.set_count(in_batch)\n      .set_feature_map_count(in_depths)\n      .set_height(in_rows)\n      .set_width(in_cols)\n      .set_layout(compute_data_layout);\n  se::dnn::BatchDescriptor output_desc;\n  output_desc.set_count(out_batch)\n      .set_height(out_rows)\n      .set_width(out_cols)\n      .set_feature_map_count(out_depths)\n      .set_layout(compute_data_layout);\n  se::dnn::FilterDescriptor filter_desc;\n  filter_desc.set_input_filter_height(patch_rows)\n      .set_input_filter_width(patch_cols)\n      .set_input_feature_map_count(patch_depths)\n      .set_output_feature_map_count(filter.dim_size(3))\n      .set_layout(filter_layout);\n  se::dnn::ConvolutionDescriptor conv_desc;\n  conv_desc.set_vertical_dilation_rate(row_dilation)\n      .set_horizontal_dilation_rate(col_dilation)\n      .set_vertical_filter_stride(row_stride)\n      .set_horizontal_filter_stride(col_stride)\n      .set_zero_padding_height(common_padding_rows)\n      .set_zero_padding_width(common_padding_cols)\n      .set_group_count(in_depths / patch_depths);\n\n  Tensor transformed_filter;\n\n  const auto transform_filter = [&](FilterTensorFormat dst_format) -> Status {\n    VLOG(4) << \"Transform filter tensor from \" << ToString(FORMAT_HWIO)\n            << \" to \" << ToString(dst_format);\n\n    TensorShape dst_shape =\n        dst_format == FORMAT_OIHW\n            ? TensorShape({filter.dim_size(3), filter.dim_size(2),\n                           filter.dim_size(0), filter.dim_size(1)})\n            : TensorShape({filter.dim_size(3), filter.dim_size(0),\n                           filter.dim_size(1), filter.dim_size(2)});\n\n    TF_RETURN_IF_ERROR(ctx->allocate_temp(DataTypeToEnum<T>::value, dst_shape,\n                                          &transformed_filter));\n    functor::TransformFilter<GPUDevice, T, int, 4>()(\n        ctx->eigen_device<GPUDevice>(), dst_format,\n        To32Bit(filter.tensor<T, 4>()),\n        To32Bit(transformed_filter.tensor<T, 4>()));\n\n    return Status::OK();\n  };\n\n  if (compute_data_format == FORMAT_NCHW) {\n    OP_REQUIRES_OK(ctx, transform_filter(FORMAT_OIHW));\n  } else if (compute_data_format == FORMAT_NHWC) {\n    OP_REQUIRES_OK(ctx, transform_filter(FORMAT_OHWI));\n  } else {\n    ctx->SetStatus(errors::InvalidArgument(\"Invalid compute data format: \",\n                                           ToString(compute_data_format)));\n    return;\n  }\n\n  Tensor transformed_output;\n  if (data_format != compute_data_format) {\n    VLOG(4) << \"Allocate temporary memory for output in compute data format\";\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                ShapeFromFormat(compute_data_format, out_batch,\n                                                out_rows, out_cols, out_depths),\n                                &transformed_output));\n  } else {\n    transformed_output = *output;\n  }\n\n  auto input_ptr = AsDeviceMemory(input.template flat<T>().data(),\n                                  input.template flat<T>().size());\n  auto filter_ptr =\n      AsDeviceMemory(transformed_filter.template flat<T>().data(),\n                     transformed_filter.template flat<T>().size());\n  auto output_ptr =\n      AsDeviceMemory(transformed_output.template flat<T>().data(),\n                     transformed_output.template flat<T>().size());\n\n  static int64 ConvolveScratchSize = GetDnnWorkspaceLimit(\n      // default value is in bytes despite the name of the environment variable\n      \"TF_CUDNN_WORKSPACE_LIMIT_IN_MB\", 1LL << 32  // 4GB\n  );\n\n  int device_id = stream->parent()->device_ordinal();\n  DataType dtype = input.dtype();\n  ConvParameters conv_parameters = {in_batch,             // batch\n                                    in_depths,            // in_depths\n                                    {{in_rows,            // in_rows\n                                      in_cols}},          // in_cols\n                                    compute_data_format,  // compute_data_format\n                                    out_depths,           // out_depths\n                                    {{patch_rows,         // filter_rows\n                                      patch_cols,         // filter_cols\n                                      patch_depths}},     // filter_depths\n                                    {{row_dilation,       // dilation_rows\n                                      col_dilation}},     // dilation_cols\n                                    {{row_stride,         // stride_rows\n                                      col_stride}},       // stride_cols\n                                    {{common_padding_rows,    // padding_rows\n                                      common_padding_cols}},  // padding_cols\n                                    dtype,                    // tensor datatype\n                                    device_id,                // device_id\n                                    conv_desc.group_count()};\n  AlgorithmConfig algorithm_config;\n#if TENSORFLOW_USE_ROCM\n  // cudnn_use_autotune is applicable only the CUDA flow\n  // for ROCm/MIOpen, we need to call GetMIOpenConvolveAlgorithms explicitly\n  // if we do not have a cached algorithm_config for this conv_parameters\n  cudnn_use_autotune = true;\n#endif\n\n  if (cudnn_use_autotune &&\n      !AutoTuneConv::GetInstance()->Find(conv_parameters, &algorithm_config)) {\n    std::vector<std::unique_ptr<se::dnn::ConvolveExecutionPlan>> plans;\n#if GOOGLE_CUDA\n    std::vector<AlgorithmDesc> algorithms;\n    std::vector<AlgorithmConfig> configs;\n    if (CudnnUseFrontend()) {\n      OP_REQUIRES(\n          ctx,\n          stream->parent()->GetConvolveExecutionPlans(\n              se::dnn::ConvolutionKind::FORWARD, se::dnn::ToDataType<T>::value,\n              stream, input_desc, filter_desc, output_desc, conv_desc, &plans),\n          errors::Unknown(\"Failed to get convolution algorithm. This is \"\n                          \"probably because cuDNN failed to initialize, so try \"\n                          \"looking to see if a warning log message was printed \"\n                          \"above.\"));\n      for (const auto& plan : plans) {\n        configs.push_back(\n            AlgorithmConfig(AlgorithmDesc{plan->getTag(), plan->get_raw_desc()},\n                            plan->getWorkspaceSize()));\n      }\n    } else {\n      OP_REQUIRES(\n          ctx,\n          stream->parent()->GetConvolveAlgorithms(\n              conv_parameters.ShouldIncludeWinogradNonfusedAlgo<T>(\n                  stream->parent()),\n              &algorithms),\n          errors::Unknown(\"Failed to get convolution algorithm. This is \"\n                          \"probably because cuDNN failed to initialize, so try \"\n                          \"looking to see if a warning log message was printed \"\n                          \"above.\"));\n      for (const auto& algorithm : algorithms) {\n        configs.push_back(AlgorithmConfig(algorithm));\n      }\n    }\n\n    se::TfAllocatorAdapter tf_allocator_adapter(ctx->device()->GetAllocator({}),\n                                                stream);\n    se::RedzoneAllocator rz_allocator(stream, &tf_allocator_adapter,\n                                      se::GpuAsmOpts());\n    se::DeviceMemory<T> output_tensor(\n        WrapRedzoneBestEffort(&rz_allocator, output_ptr));\n\n    std::vector<tensorflow::AutotuneResult> results;\n    for (const auto& profile_config : configs) {\n      // TODO(zhengxq): profile each algorithm multiple times to better\n      // accuracy.\n      se::RedzoneAllocator rz_scratch_allocator(\n          stream, &tf_allocator_adapter, se::GpuAsmOpts(),\n          /*memory_limit=*/ConvolveScratchSize);\n      DnnScratchAllocator scratch_allocator(ConvolveScratchSize, ctx);\n      se::ScratchAllocator* allocator_used =\n          !RedzoneCheckDisabled()\n              ? static_cast<se::ScratchAllocator*>(&rz_scratch_allocator)\n              : static_cast<se::ScratchAllocator*>(&scratch_allocator);\n\n      ProfileResult profile_result;\n      Status cudnn_launch_status;\n      if (CudnnUseFrontend()) {\n        cudnn_launch_status = stream->ConvolveWithExecutionPlan(\n            input_desc, input_ptr, filter_desc, filter_ptr, conv_desc,\n            output_desc, &output_tensor, allocator_used, profile_config,\n            &profile_result);\n      } else {\n        cudnn_launch_status = stream->ConvolveWithAlgorithm(\n            input_desc, input_ptr, filter_desc, filter_ptr, conv_desc,\n            output_desc, &output_tensor, allocator_used, profile_config,\n            &profile_result);\n      }\n\n      if (cudnn_launch_status.ok() && profile_result.is_valid()) {\n        results.emplace_back();\n        auto& result = results.back();\n        if (CudnnUseFrontend()) {\n          result.mutable_cuda_conv_plan()->set_exec_plan_id(\n              profile_config.algorithm()->exec_plan_id());\n        } else {\n          result.mutable_conv()->set_algorithm(\n              profile_config.algorithm()->algo_id());\n          result.mutable_conv()->set_tensor_ops_enabled(\n              profile_config.algorithm()->tensor_ops_enabled());\n        }\n\n        result.set_scratch_bytes(\n            !RedzoneCheckDisabled()\n                ? rz_scratch_allocator.TotalAllocatedBytesExcludingRedzones()\n                : scratch_allocator.TotalByteSize());\n        *result.mutable_run_time() = proto_utils::ToDurationProto(\n            absl::Milliseconds(profile_result.elapsed_time_in_ms()));\n\n        CheckRedzones(rz_scratch_allocator, &result);\n        CheckRedzones(rz_allocator, &result);\n      } else if (CudnnUseFrontend()) {\n        // When CuDNN frontend APIs are used, we need to make sure the profiling\n        // results are one-to-one mapping of the \"plans\". So, we insert dummy\n        // results when the excution fails.\n        results.emplace_back();\n        auto& result = results.back();\n        result.mutable_failure()->set_kind(AutotuneResult::UNKNOWN);\n        result.mutable_failure()->set_msg(\n            absl::StrCat(\"Profiling failure on CUDNN engine: \",\n                         profile_config.algorithm()->exec_plan_id()));\n      }\n    }\n\n#elif TENSORFLOW_USE_ROCM\n    DnnScratchAllocator scratch_allocator(ConvolveScratchSize, ctx);\n\n    std::vector<ProfileResult> algorithms;\n    OP_REQUIRES(\n        ctx,\n        stream->parent()->GetMIOpenConvolveAlgorithms(\n            se::dnn::ConvolutionKind::FORWARD, se::dnn::ToDataType<T>::value,\n            stream, input_desc, input_ptr, filter_desc, filter_ptr, output_desc,\n            output_ptr, conv_desc, &scratch_allocator, &algorithms),\n        errors::Unknown(\n            \"Failed to get convolution algorithm. This is probably \"\n            \"because MIOpen failed to initialize, so try looking to \"\n            \"see if a warning log message was printed above.\"));\n    se::DeviceMemory<T> output_tensor = output_ptr;\n\n    std::vector<tensorflow::AutotuneResult> results;\n    if (algorithms.size() == 1) {\n      auto profile_result = algorithms[0];\n      results.emplace_back();\n      auto& result = results.back();\n      result.mutable_conv()->set_algorithm(\n          profile_result.algorithm().algo_id());\n      result.mutable_conv()->set_tensor_ops_enabled(\n          profile_result.algorithm().tensor_ops_enabled());\n\n      result.set_scratch_bytes(profile_result.scratch_size());\n      *result.mutable_run_time() = proto_utils::ToDurationProto(\n          absl::Milliseconds(profile_result.elapsed_time_in_ms()));\n    } else {\n      for (auto miopen_algorithm : algorithms) {\n        auto profile_algorithm = miopen_algorithm.algorithm();\n        ProfileResult profile_result;\n        auto miopen_launch_status = stream->ConvolveWithAlgorithm(\n            input_desc, input_ptr, filter_desc, filter_ptr, conv_desc,\n            output_desc, &output_ptr, &scratch_allocator,\n            AlgorithmConfig(profile_algorithm, miopen_algorithm.scratch_size()),\n            &profile_result);\n        if (miopen_launch_status.ok() && profile_result.is_valid()) {\n          results.emplace_back();\n          auto& result = results.back();\n          result.mutable_conv()->set_algorithm(profile_algorithm.algo_id());\n          result.mutable_conv()->set_tensor_ops_enabled(\n              profile_algorithm.tensor_ops_enabled());\n\n          result.set_scratch_bytes(scratch_allocator.TotalByteSize());\n          *result.mutable_run_time() = proto_utils::ToDurationProto(\n              absl::Milliseconds(profile_result.elapsed_time_in_ms()));\n        }\n      }\n    }\n#endif\n    LogConvAutotuneResults(se::dnn::ConvolutionKind::FORWARD,\n                           se::dnn::ToDataType<T>::value, input_ptr, filter_ptr,\n                           output_tensor, input_desc, filter_desc, output_desc,\n                           conv_desc, stream->parent(), results);\n\n    if (CudnnUseFrontend()) {\n      OP_REQUIRES_OK(\n          ctx, BestCudnnConvAlgorithm(results, &plans, &algorithm_config));\n\n    } else {\n      OP_REQUIRES_OK(\n          ctx, BestCudnnConvAlgorithm(results, nullptr, &algorithm_config));\n    }\n\n    AutoTuneConv::GetInstance()->Insert(conv_parameters, algorithm_config);\n  }\n\n  Status cudnn_launch_status;\n  DnnScratchAllocator scratch_allocator(ConvolveScratchSize, ctx);\n  if (CudnnUseFrontend()) {\n    if (algorithm_config.algorithm().has_value()) {\n      VLOG(4) << \"Conv2D Execution Plan: \"\n              << algorithm_config.algorithm()->exec_plan_id();\n    } else {\n      VLOG(4) << \"Convolution AutoTune has been turned off\";\n    }\n    cudnn_launch_status = stream->ConvolveWithExecutionPlan(\n        input_desc, input_ptr, filter_desc, filter_ptr, conv_desc, output_desc,\n        &output_ptr, &scratch_allocator, algorithm_config, nullptr);\n  } else {\n    VLOG(4) << \"Convolution Algorithm: \"\n            << algorithm_config.algorithm()->algo_id();\n    VLOG(4) << \"tensor_ops_enabled: \"\n            << algorithm_config.algorithm()->tensor_ops_enabled();\n\n    cudnn_launch_status = stream->ConvolveWithAlgorithm(\n        input_desc, input_ptr, filter_desc, filter_ptr, conv_desc, output_desc,\n        &output_ptr, &scratch_allocator, algorithm_config, nullptr);\n  }\n\n  if (!cudnn_launch_status.ok()) {\n    ctx->SetStatus(cudnn_launch_status);\n  }\n\n  if (data_format == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {\n    VLOG(4) << \"Convert the output tensor back from NCHW to NHWC.\";\n    functor::NCHWToNHWC<GPUDevice, T, 4>()(\n        ctx->eigen_device<GPUDevice>(),\n        const_cast<const Tensor&>(transformed_output).tensor<T, 4>(),\n        output->tensor<T, 4>());\n  }\n}\n\n// Forward declarations of the functor specializations for GPU.\nnamespace functor {\n#define DECLARE_GPU_SPEC(T)                                                 \\\n  template <>                                                               \\\n  void SpatialConvolution<GPUDevice, T>::operator()(                        \\\n      const GPUDevice& d, typename TTypes<T, 4>::Tensor output,             \\\n      typename TTypes<T, 4>::ConstTensor input,                             \\\n      typename TTypes<T, 4>::ConstTensor filter, int row_stride,            \\\n      int col_stride, int row_dilation, int col_dilation,                   \\\n      const Eigen::PaddingType& padding,                                    \\\n      const Eigen::NoOpOutputKernel& output_kernel);                        \\\n  template <>                                                               \\\n  void SpatialConvolution<GPUDevice, T>::operator()(                        \\\n      const GPUDevice& d, typename TTypes<T, 4>::Tensor output,             \\\n      typename TTypes<T, 4>::ConstTensor input,                             \\\n      typename TTypes<T, 4>::ConstTensor filter, int row_stride,            \\\n      int col_stride, int row_dilation, int col_dilation, int padding_top,  \\\n      int padding_bottom, int padding_left, int padding_right,              \\\n      const Eigen::NoOpOutputKernel& output_kernel);                        \\\n  extern template struct SpatialConvolution<GPUDevice, T>;                  \\\n  template <>                                                               \\\n  void MatMulConvFunctor<GPUDevice, T>::operator()(                         \\\n      const GPUDevice& d, typename TTypes<T, 2>::Tensor out,                \\\n      typename TTypes<T, 2>::ConstTensor in0,                               \\\n      typename TTypes<T, 2>::ConstTensor in1,                               \\\n      const Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1>& dim_pair, \\\n      const Eigen::NoOpOutputKernel& output_kernel);                        \\\n  extern template struct MatMulConvFunctor<GPUDevice, T>;                   \\\n  template <>                                                               \\\n  void TransformFilter<GPUDevice, T, int, 4>::operator()(                   \\\n      const GPUDevice& d, FilterTensorFormat dst_filter_format,             \\\n      typename TTypes<T, 4, int>::ConstTensor in,                           \\\n      typename TTypes<T, 4, int>::Tensor out);                              \\\n  extern template struct TransformFilter<GPUDevice, T, int, 4>;             \\\n  template <>                                                               \\\n  void PadInput<GPUDevice, T, int, 4>::operator()(                          \\\n      const GPUDevice& d, typename TTypes<T, 4, int>::ConstTensor in,       \\\n      const std::array<int, 2>& padding_left,                               \\\n      const std::array<int, 2>& padding_right,                              \\\n      typename TTypes<T, 4, int>::Tensor out, TensorFormat data_format,     \\\n      const T& padding_value);                                              \\\n  extern template struct PadInput<GPUDevice, T, int, 4>\n\nDECLARE_GPU_SPEC(float);\nDECLARE_GPU_SPEC(Eigen::half);\nDECLARE_GPU_SPEC(double);\nDECLARE_GPU_SPEC(int32);\n#undef DECLARE_GPU_SPEC\n\n}  // namespace functor\n\n// Registration of the GPU implementations.\nREGISTER_KERNEL_BUILDER(\n    Name(\"Conv2D\").Device(DEVICE_GPU).TypeConstraint<Eigen::half>(\"T\"),\n    Conv2DOp<GPUDevice, Eigen::half>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"Conv2D\").Device(DEVICE_GPU).TypeConstraint<float>(\"T\"),\n    Conv2DOp<GPUDevice, float>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"Conv2D\").Device(DEVICE_GPU).TypeConstraint<double>(\"T\"),\n    Conv2DOp<GPUDevice, double>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"Conv2D\").Device(DEVICE_GPU).TypeConstraint<int32>(\"T\"),\n    Conv2DOp<GPUDevice, int32>);\n\n// To be used inside depthwise_conv_op.cc.\ntemplate struct LaunchConv2DOp<GPUDevice, float>;\ntemplate struct LaunchConv2DOp<GPUDevice, Eigen::half>;\ntemplate struct LaunchConv2DOp<GPUDevice, double>;\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/conv_ops.cc"], "buggy_code_start_loc": [262], "buggy_code_end_loc": [538], "fixing_code_start_loc": [263], "fixing_code_end_loc": [552], "type": "CWE-369", "message": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/988087bd83f144af14087fe4fecee2d250d93737/tensorflow/core/kernels/conv_ops.cc#L261-L263) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-29526", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-14T20:15:11.807", "lastModified": "2021-05-20T16:20:34.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/988087bd83f144af14087fe4fecee2d250d93737/tensorflow/core/kernels/conv_ops.cc#L261-L263) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico.&#xa0;Un atacante puede activar una divisi\u00f3n por 0 en \"tf.raw_ops.Conv2D\".&#xa0;Esto es debido a que la implementaci\u00f3n (https://github.com/tensorflow/tensorflow/blob/988087bd83f144af14087fe4fecee2d250d93737/tensorflow/core/kernels/conv_ops.cc#L261-L263) hace una divisi\u00f3n por una cantidad que es controlada por la persona que llama.&#xa0;La correcci\u00f3n ser\u00e1 inclu\u00edda en TensorFlow versi\u00f3n 2.5.0.&#xa0;Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.4.2, TensorFlow versi\u00f3n 2.3.3, TensorFlow versi\u00f3n 2.2.3 y TensorFlow versi\u00f3n 2.1.4, ya que estos tambi\u00e9n est\u00e1n afectados y a\u00fan est\u00e1n en el rango admitido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.4", "matchCriteriaId": "323ABCCE-24EB-47CC-87F6-48C101477587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.3", "matchCriteriaId": "64ABA90C-0649-4BB0-89C9-83C14BBDCC0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.3", "matchCriteriaId": "0F83E0CF-CBF6-4C24-8683-3E7A5DC95BA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.2", "matchCriteriaId": "8259531B-A8AC-4F8B-B60F-B69DE4767C03"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/b12aa1d44352de21d1a6faaf04172d8c2508b42b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-4vf2-4xcg-65cx", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/b12aa1d44352de21d1a6faaf04172d8c2508b42b"}}