{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/kernels/sdca_internal.h\"\n\n#include <limits>\n#include <numeric>\n#include <random>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/lib/gtl/flatset.h\"\n#include \"tensorflow/core/lib/math/math_util.h\"\n#include \"tensorflow/core/lib/random/simple_philox.h\"\n\n#if defined(TENSORFLOW_USE_CUSTOM_CONTRACTION_KERNEL)\n#include \"tensorflow/core/kernels/eigen_contraction_kernel.h\"\n#endif\n\nnamespace tensorflow {\nnamespace sdca {\n\nusing UnalignedFloatVector = TTypes<const float>::UnalignedConstVec;\nusing UnalignedInt64Vector = TTypes<const int64_t>::UnalignedConstVec;\n\nvoid FeatureWeightsDenseStorage::UpdateDenseDeltaWeights(\n    const Eigen::ThreadPoolDevice& device,\n    const Example::DenseVector& dense_vector,\n    const std::vector<double>& normalized_bounded_dual_delta) {\n  const size_t num_weight_vectors = normalized_bounded_dual_delta.size();\n  if (num_weight_vectors == 1) {\n    deltas_.device(device) =\n        deltas_ + dense_vector.RowAsMatrix() *\n                      deltas_.constant(normalized_bounded_dual_delta[0]);\n  } else {\n    // Transform the dual vector into a column matrix.\n    const Eigen::TensorMap<Eigen::Tensor<const double, 2, Eigen::RowMajor>>\n        dual_matrix(normalized_bounded_dual_delta.data(), num_weight_vectors,\n                    1);\n    const Eigen::array<Eigen::IndexPair<int>, 1> product_dims = {\n        Eigen::IndexPair<int>(1, 0)};\n    // This computes delta_w += delta_vector / \\lamdba * N.\n    deltas_.device(device) =\n        (deltas_.cast<double>() +\n         dual_matrix.contract(dense_vector.RowAsMatrix().cast<double>(),\n                              product_dims))\n            .cast<float>();\n  }\n}\n\nvoid FeatureWeightsSparseStorage::UpdateSparseDeltaWeights(\n    const Eigen::ThreadPoolDevice& device,\n    const Example::SparseFeatures& sparse_features,\n    const std::vector<double>& normalized_bounded_dual_delta) {\n  for (int64_t k = 0; k < sparse_features.indices->size(); ++k) {\n    const double feature_value =\n        sparse_features.values == nullptr ? 1.0 : (*sparse_features.values)(k);\n    auto it = indices_to_id_.find((*sparse_features.indices)(k));\n    for (size_t l = 0; l < normalized_bounded_dual_delta.size(); ++l) {\n      deltas_(l, it->second) +=\n          feature_value * normalized_bounded_dual_delta[l];\n    }\n  }\n}\n\nvoid ModelWeights::UpdateDeltaWeights(\n    const Eigen::ThreadPoolDevice& device, const Example& example,\n    const std::vector<double>& normalized_bounded_dual_delta) {\n  // Sparse weights.\n  for (size_t j = 0; j < sparse_weights_.size(); ++j) {\n    sparse_weights_[j].UpdateSparseDeltaWeights(\n        device, example.sparse_features_[j], normalized_bounded_dual_delta);\n  }\n\n  // Dense weights.\n  for (size_t j = 0; j < dense_weights_.size(); ++j) {\n    dense_weights_[j].UpdateDenseDeltaWeights(\n        device, *example.dense_vectors_[j], normalized_bounded_dual_delta);\n  }\n}\n\nStatus ModelWeights::Initialize(OpKernelContext* const context) {\n  OpInputList sparse_indices_inputs;\n  TF_RETURN_IF_ERROR(\n      context->input_list(\"sparse_indices\", &sparse_indices_inputs));\n  OpInputList sparse_weights_inputs;\n  TF_RETURN_IF_ERROR(\n      context->input_list(\"sparse_weights\", &sparse_weights_inputs));\n  if (sparse_indices_inputs.size() != sparse_weights_inputs.size())\n    return errors::InvalidArgument(\n        \"sparse_indices and sparse_weights must have the same length, got \",\n        sparse_indices_inputs.size(), \" and \", sparse_weights_inputs.size());\n  OpInputList dense_weights_inputs;\n  TF_RETURN_IF_ERROR(\n      context->input_list(\"dense_weights\", &dense_weights_inputs));\n\n  OpOutputList sparse_weights_outputs;\n  TF_RETURN_IF_ERROR(context->output_list(\"out_delta_sparse_weights\",\n                                          &sparse_weights_outputs));\n  if (sparse_weights_outputs.size() != sparse_weights_inputs.size())\n    return errors::InvalidArgument(\n        \"out_delta_sparse_weights and sparse_weights must have the same \"\n        \"length, got \",\n        sparse_weights_outputs.size(), \" and \", sparse_weights_inputs.size());\n\n  OpOutputList dense_weights_outputs;\n  TF_RETURN_IF_ERROR(\n      context->output_list(\"out_delta_dense_weights\", &dense_weights_outputs));\n  if (dense_weights_outputs.size() != dense_weights_inputs.size())\n    return errors::InvalidArgument(\n        \"out_delta_dense_weights and dense_weights must have the same length, \"\n        \"got \",\n        dense_weights_outputs.size(), \" and \", dense_weights_inputs.size());\n\n  for (int i = 0; i < sparse_weights_inputs.size(); ++i) {\n    Tensor* delta_t;\n    TF_RETURN_IF_ERROR(sparse_weights_outputs.allocate(\n        i, sparse_weights_inputs[i].shape(), &delta_t));\n    // Convert the input vector to a row matrix in internal representation.\n    auto deltas = delta_t->shaped<float, 2>({1, delta_t->NumElements()});\n    deltas.setZero();\n    sparse_weights_.emplace_back(FeatureWeightsSparseStorage{\n        sparse_indices_inputs[i].flat<int64_t>(),\n        sparse_weights_inputs[i].shaped<float, 2>(\n            {1, sparse_weights_inputs[i].NumElements()}),\n        deltas});\n  }\n\n  // Reads in the weights, and allocates and initializes the delta weights.\n  const auto initialize_weights =\n      [&](const OpInputList& weight_inputs, OpOutputList* const weight_outputs,\n          std::vector<FeatureWeightsDenseStorage>* const feature_weights) {\n        for (int i = 0; i < weight_inputs.size(); ++i) {\n          Tensor* delta_t;\n          TF_RETURN_IF_ERROR(\n              weight_outputs->allocate(i, weight_inputs[i].shape(), &delta_t));\n          // Convert the input vector to a row matrix in internal\n          // representation.\n          auto deltas = delta_t->shaped<float, 2>({1, delta_t->NumElements()});\n          deltas.setZero();\n          feature_weights->emplace_back(FeatureWeightsDenseStorage{\n              weight_inputs[i].shaped<float, 2>(\n                  {1, weight_inputs[i].NumElements()}),\n              deltas});\n        }\n        return OkStatus();\n      };\n\n  return initialize_weights(dense_weights_inputs, &dense_weights_outputs,\n                            &dense_weights_);\n}\n\n// Computes the example statistics for given example, and model. Defined here\n// as we need definition of ModelWeights and Regularizations.\nconst ExampleStatistics Example::ComputeWxAndWeightedExampleNorm(\n    const int num_loss_partitions, const ModelWeights& model_weights,\n    const Regularizations& regularization, const int num_weight_vectors) const {\n  ExampleStatistics result(num_weight_vectors);\n\n  result.normalized_squared_norm =\n      squared_norm_ / regularization.symmetric_l2();\n\n  // Compute w \\dot x and prev_w \\dot x.\n  // This is for sparse features contribution to the logit.\n  for (size_t j = 0; j < sparse_features_.size(); ++j) {\n    const Example::SparseFeatures& sparse_features = sparse_features_[j];\n    const FeatureWeightsSparseStorage& sparse_weights =\n        model_weights.sparse_weights()[j];\n\n    for (int64_t k = 0; k < sparse_features.indices->size(); ++k) {\n      const int64_t feature_index = (*sparse_features.indices)(k);\n      const double feature_value = sparse_features.values == nullptr\n                                       ? 1.0\n                                       : (*sparse_features.values)(k);\n      for (int l = 0; l < num_weight_vectors; ++l) {\n        const float sparse_weight = sparse_weights.nominals(l, feature_index);\n        const double feature_weight =\n            sparse_weight +\n            sparse_weights.deltas(l, feature_index) * num_loss_partitions;\n        result.prev_wx[l] +=\n            feature_value * regularization.Shrink(sparse_weight);\n        result.wx[l] += feature_value * regularization.Shrink(feature_weight);\n      }\n    }\n  }\n\n  // Compute w \\dot x and prev_w \\dot x.\n  // This is for dense features contribution to the logit.\n  for (size_t j = 0; j < dense_vectors_.size(); ++j) {\n    const Example::DenseVector& dense_vector = *dense_vectors_[j];\n    const FeatureWeightsDenseStorage& dense_weights =\n        model_weights.dense_weights()[j];\n\n    const Eigen::Tensor<float, 2, Eigen::RowMajor> feature_weights =\n        dense_weights.nominals() +\n        dense_weights.deltas() *\n            dense_weights.deltas().constant(num_loss_partitions);\n    if (num_weight_vectors == 1) {\n      const Eigen::Tensor<float, 0, Eigen::RowMajor> prev_prediction =\n          (dense_vector.Row() *\n           regularization.EigenShrinkVector(\n               Eigen::TensorMap<Eigen::Tensor<const float, 1, Eigen::RowMajor>>(\n                   dense_weights.nominals().data(),\n                   dense_weights.nominals().dimension(1))))\n              .sum();\n      const Eigen::Tensor<float, 0, Eigen::RowMajor> prediction =\n          (dense_vector.Row() *\n           regularization.EigenShrinkVector(\n               Eigen::TensorMap<Eigen::Tensor<const float, 1, Eigen::RowMajor>>(\n                   feature_weights.data(), feature_weights.dimension(1))))\n              .sum();\n      result.prev_wx[0] += prev_prediction();\n      result.wx[0] += prediction();\n    } else {\n      const Eigen::array<Eigen::IndexPair<int>, 1> product_dims = {\n          Eigen::IndexPair<int>(1, 1)};\n      const Eigen::Tensor<float, 2, Eigen::RowMajor> prev_prediction =\n          regularization.EigenShrinkMatrix(dense_weights.nominals())\n              .contract(dense_vector.RowAsMatrix(), product_dims);\n      const Eigen::Tensor<float, 2, Eigen::RowMajor> prediction =\n          regularization.EigenShrinkMatrix(feature_weights)\n              .contract(dense_vector.RowAsMatrix(), product_dims);\n      // The result of \"tensor contraction\" (multiplication)  in the code\n      // above is of dimension num_weight_vectors * 1.\n      for (int l = 0; l < num_weight_vectors; ++l) {\n        result.prev_wx[l] += prev_prediction(l, 0);\n        result.wx[l] += prediction(l, 0);\n      }\n    }\n  }\n\n  return result;\n}\n\n// Examples contains all the training examples that SDCA uses for a mini-batch.\nStatus Examples::SampleAdaptiveProbabilities(\n    const int num_loss_partitions, const Regularizations& regularization,\n    const ModelWeights& model_weights,\n    const TTypes<float>::Matrix example_state_data,\n    const std::unique_ptr<DualLossUpdater>& loss_updater,\n    const int num_weight_vectors) {\n  if (num_weight_vectors != 1) {\n    return errors::InvalidArgument(\n        \"Adaptive SDCA only works with binary SDCA, \"\n        \"where num_weight_vectors should be 1.\");\n  }\n  // Compute the probabilities\n  for (int example_id = 0; example_id < num_examples(); ++example_id) {\n    const Example& example = examples_[example_id];\n    const double example_weight = example.example_weight();\n    float label = example.example_label();\n    const Status conversion_status = loss_updater->ConvertLabel(&label);\n    const ExampleStatistics example_statistics =\n        example.ComputeWxAndWeightedExampleNorm(num_loss_partitions,\n                                                model_weights, regularization,\n                                                num_weight_vectors);\n    const double kappa = example_state_data(example_id, 0) +\n                         loss_updater->PrimalLossDerivative(\n                             example_statistics.wx[0], label, 1.0);\n    probabilities_[example_id] = example_weight *\n                                 sqrt(examples_[example_id].squared_norm_ +\n                                      regularization.symmetric_l2() *\n                                          loss_updater->SmoothnessConstant()) *\n                                 std::abs(kappa);\n  }\n\n  // Sample the index\n  random::DistributionSampler sampler(probabilities_);\n  GuardedPhiloxRandom generator;\n  generator.Init(0, 0);\n  auto local_gen = generator.ReserveSamples32(num_examples());\n  random::SimplePhilox random(&local_gen);\n  std::random_device rd;\n  std::mt19937 gen(rd());\n  std::uniform_real_distribution<> dis(0, 1);\n\n  // We use a decay of 10: the probability of an example is divided by 10\n  // once that example is picked. A good approximation of that is to only\n  // keep a picked example with probability (1 / 10) ^ k where k is the\n  // number of times we already picked that example. We add a num_retries\n  // to avoid taking too long to sample. We then fill the sampled_index with\n  // unseen examples sorted by probabilities.\n  int id = 0;\n  int num_retries = 0;\n  while (id < num_examples() && num_retries < num_examples()) {\n    int picked_id = sampler.Sample(&random);\n    if (dis(gen) > MathUtil::IPow(0.1, sampled_count_[picked_id])) {\n      num_retries++;\n      continue;\n    }\n    sampled_count_[picked_id]++;\n    sampled_index_[id++] = picked_id;\n  }\n\n  std::vector<std::pair<int, float>> examples_not_seen;\n  examples_not_seen.reserve(num_examples());\n  for (int i = 0; i < num_examples(); ++i) {\n    if (sampled_count_[i] == 0)\n      examples_not_seen.emplace_back(sampled_index_[i], probabilities_[i]);\n  }\n  std::sort(\n      examples_not_seen.begin(), examples_not_seen.end(),\n      [](const std::pair<int, float>& lhs, const std::pair<int, float>& rhs) {\n        return lhs.second > rhs.second;\n      });\n  for (int i = id; i < num_examples(); ++i) {\n    sampled_count_[i] = examples_not_seen[i - id].first;\n  }\n  return OkStatus();\n}\n\nvoid Examples::RandomShuffle() {\n  std::iota(sampled_index_.begin(), sampled_index_.end(), 0);\n\n  std::random_device rd;\n  std::mt19937 rng(rd());\n  std::shuffle(sampled_index_.begin(), sampled_index_.end(), rng);\n}\n\n// TODO(sibyl-Aix6ihai): Refactor/shorten this function.\nStatus Examples::Initialize(OpKernelContext* const context,\n                            const ModelWeights& weights,\n                            const int num_sparse_features,\n                            const int num_sparse_features_with_values,\n                            const int num_dense_features) {\n  num_features_ = num_sparse_features + num_dense_features;\n\n  OpInputList sparse_example_indices_inputs;\n  TF_RETURN_IF_ERROR(context->input_list(\"sparse_example_indices\",\n                                         &sparse_example_indices_inputs));\n  if (sparse_example_indices_inputs.size() != num_sparse_features)\n    return errors::InvalidArgument(\n        \"Expected \", num_sparse_features,\n        \" tensors in sparse_example_indices but got \",\n        sparse_example_indices_inputs.size());\n  OpInputList sparse_feature_indices_inputs;\n  TF_RETURN_IF_ERROR(context->input_list(\"sparse_feature_indices\",\n                                         &sparse_feature_indices_inputs));\n  if (sparse_feature_indices_inputs.size() != num_sparse_features)\n    return errors::InvalidArgument(\n        \"Expected \", num_sparse_features,\n        \" tensors in sparse_feature_indices but got \",\n        sparse_feature_indices_inputs.size());\n  OpInputList sparse_feature_values_inputs;\n  if (num_sparse_features_with_values > 0) {\n    TF_RETURN_IF_ERROR(context->input_list(\"sparse_feature_values\",\n                                           &sparse_feature_values_inputs));\n    if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)\n      return errors::InvalidArgument(\n          \"Expected \", num_sparse_features_with_values,\n          \" tensors in sparse_feature_values but got \",\n          sparse_feature_values_inputs.size());\n  }\n\n  const Tensor* example_weights_t;\n  TF_RETURN_IF_ERROR(context->input(\"example_weights\", &example_weights_t));\n  auto example_weights = example_weights_t->flat<float>();\n\n  if (example_weights.size() >= std::numeric_limits<int>::max()) {\n    return errors::InvalidArgument(strings::Printf(\n        \"Too many examples in a mini-batch: %zu > %d\", example_weights.size(),\n        std::numeric_limits<int>::max()));\n  }\n\n  // The static_cast here is safe since num_examples can be at max an int.\n  const int num_examples = static_cast<int>(example_weights.size());\n  const Tensor* example_labels_t;\n  TF_RETURN_IF_ERROR(context->input(\"example_labels\", &example_labels_t));\n  auto example_labels = example_labels_t->flat<float>();\n  if (example_labels.size() != num_examples) {\n    return errors::InvalidArgument(\"Expected \", num_examples,\n                                   \" example labels but got \",\n                                   example_labels.size());\n  }\n\n  OpInputList dense_features_inputs;\n  TF_RETURN_IF_ERROR(\n      context->input_list(\"dense_features\", &dense_features_inputs));\n\n  examples_.clear();\n  examples_.resize(num_examples);\n  probabilities_.resize(num_examples);\n  sampled_index_.resize(num_examples);\n  sampled_count_.resize(num_examples);\n  for (int example_id = 0; example_id < num_examples; ++example_id) {\n    Example* const example = &examples_[example_id];\n    example->sparse_features_.resize(num_sparse_features);\n    example->dense_vectors_.resize(num_dense_features);\n    example->example_weight_ = example_weights(example_id);\n    example->example_label_ = example_labels(example_id);\n  }\n  const DeviceBase::CpuWorkerThreads& worker_threads =\n      *context->device()->tensorflow_cpu_worker_threads();\n  TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(\n      worker_threads, num_examples, num_sparse_features, weights,\n      sparse_example_indices_inputs, sparse_feature_indices_inputs,\n      sparse_feature_values_inputs, &examples_));\n  TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(\n      worker_threads, num_examples, num_dense_features, weights,\n      dense_features_inputs, &examples_));\n  TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(\n      worker_threads, num_examples, num_sparse_features, num_dense_features,\n      &examples_));\n  return OkStatus();\n}\n\nStatus Examples::CreateSparseFeatureRepresentation(\n    const DeviceBase::CpuWorkerThreads& worker_threads, const int num_examples,\n    const int num_sparse_features, const ModelWeights& weights,\n    const OpInputList& sparse_example_indices_inputs,\n    const OpInputList& sparse_feature_indices_inputs,\n    const OpInputList& sparse_feature_values_inputs,\n    std::vector<Example>* const examples) {\n  mutex mu;\n  Status result;  // Guarded by mu\n  auto parse_partition = [&](const int64_t begin, const int64_t end) {\n    // The static_cast here is safe since begin and end can be at most\n    // num_examples which is an int.\n    for (int i = static_cast<int>(begin); i < end; ++i) {\n      auto example_indices =\n          sparse_example_indices_inputs[i].template flat<int64_t>();\n      auto feature_indices =\n          sparse_feature_indices_inputs[i].template flat<int64_t>();\n      if (example_indices.size() != feature_indices.size()) {\n        mutex_lock l(mu);\n        result = errors::InvalidArgument(\n            \"Found mismatched example_indices and feature_indices [\",\n            example_indices, \"] vs [\", feature_indices, \"]\");\n        return;\n      }\n\n      // Parse features for each example. Features for a particular example\n      // are at the offsets (start_id, end_id]\n      int start_id = -1;\n      int end_id = 0;\n      for (int example_id = 0; example_id < num_examples; ++example_id) {\n        start_id = end_id;\n        while (end_id < example_indices.size() &&\n               example_indices(end_id) == example_id) {\n          ++end_id;\n        }\n        Example::SparseFeatures* const sparse_features =\n            &(*examples)[example_id].sparse_features_[i];\n        if (start_id < example_indices.size() &&\n            example_indices(start_id) == example_id) {\n          sparse_features->indices.reset(new UnalignedInt64Vector(\n              &(feature_indices(start_id)), end_id - start_id));\n          if (sparse_feature_values_inputs.size() > i) {\n            auto feature_weights =\n                sparse_feature_values_inputs[i].flat<float>();\n            sparse_features->values.reset(new UnalignedFloatVector(\n                &(feature_weights(start_id)), end_id - start_id));\n          }\n          // If features are non empty.\n          if (end_id - start_id > 0) {\n            // TODO(sibyl-Aix6ihai): Write this efficiently using vectorized\n            // operations from eigen.\n            for (int64_t k = 0; k < sparse_features->indices->size(); ++k) {\n              const int64_t feature_index = (*sparse_features->indices)(k);\n              if (!weights.SparseIndexValid(i, feature_index)) {\n                mutex_lock l(mu);\n                result = errors::InvalidArgument(\n                    \"Found sparse feature indices out of valid range: \",\n                    (*sparse_features->indices)(k));\n                return;\n              }\n            }\n          }\n        } else {\n          // Add a Tensor that has size 0.\n          sparse_features->indices.reset(\n              new UnalignedInt64Vector(&(feature_indices(0)), 0));\n          // If values exist for this feature group.\n          if (sparse_feature_values_inputs.size() > i) {\n            auto feature_weights =\n                sparse_feature_values_inputs[i].flat<float>();\n            sparse_features->values.reset(\n                new UnalignedFloatVector(&(feature_weights(0)), 0));\n          }\n        }\n      }\n    }\n  };\n  // For each column, the cost of parsing it is O(num_examples). We use\n  // num_examples here, as empirically Shard() creates the right amount of\n  // threads based on the problem size.\n  // TODO(sibyl-Aix6ihai): Tune this as a function of dataset size.\n  const int64_t kCostPerUnit = num_examples;\n  Shard(worker_threads.num_threads, worker_threads.workers, num_sparse_features,\n        kCostPerUnit, parse_partition);\n  return result;\n}\n\nStatus Examples::CreateDenseFeatureRepresentation(\n    const DeviceBase::CpuWorkerThreads& worker_threads, const int num_examples,\n    const int num_dense_features, const ModelWeights& weights,\n    const OpInputList& dense_features_inputs,\n    std::vector<Example>* const examples) {\n  mutex mu;\n  Status result;  // Guarded by mu\n  auto parse_partition = [&](const int64_t begin, const int64_t end) {\n    // The static_cast here is safe since begin and end can be at most\n    // num_examples which is an int.\n    for (int i = static_cast<int>(begin); i < end; ++i) {\n      auto dense_features = dense_features_inputs[i].template matrix<float>();\n      for (int example_id = 0; example_id < num_examples; ++example_id) {\n        (*examples)[example_id].dense_vectors_[i].reset(\n            new Example::DenseVector{dense_features, example_id});\n      }\n      if (!weights.DenseIndexValid(i, dense_features.dimension(1) - 1)) {\n        mutex_lock l(mu);\n        result = errors::InvalidArgument(\n            \"More dense features than we have parameters for: \",\n            dense_features.dimension(1));\n        return;\n      }\n    }\n  };\n  // TODO(sibyl-Aix6ihai): Tune this as a function of dataset size.\n  const int64_t kCostPerUnit = num_examples;\n  Shard(worker_threads.num_threads, worker_threads.workers, num_dense_features,\n        kCostPerUnit, parse_partition);\n  return result;\n}\n\nStatus Examples::ComputeSquaredNormPerExample(\n    const DeviceBase::CpuWorkerThreads& worker_threads, const int num_examples,\n    const int num_sparse_features, const int num_dense_features,\n    std::vector<Example>* const examples) {\n  mutex mu;\n  Status result;  // Guarded by mu\n  // Compute norm of examples.\n  auto compute_example_norm = [&](const int64_t begin, const int64_t end) {\n    // The static_cast here is safe since begin and end can be at most\n    // num_examples which is an int.\n    gtl::FlatSet<int64_t> previous_indices;\n    for (int example_id = static_cast<int>(begin); example_id < end;\n         ++example_id) {\n      double squared_norm = 0;\n      Example* const example = &(*examples)[example_id];\n      for (int j = 0; j < num_sparse_features; ++j) {\n        const Example::SparseFeatures& sparse_features =\n            example->sparse_features_[j];\n        previous_indices.clear();\n        for (int64_t k = 0; k < sparse_features.indices->size(); ++k) {\n          const int64_t feature_index = (*sparse_features.indices)(k);\n          if (previous_indices.insert(feature_index).second == false) {\n            mutex_lock l(mu);\n            result =\n                errors::InvalidArgument(\"Duplicate index in sparse vector.\");\n            return;\n          }\n          const double feature_value = sparse_features.values == nullptr\n                                           ? 1.0\n                                           : (*sparse_features.values)(k);\n          squared_norm += feature_value * feature_value;\n        }\n      }\n      for (int j = 0; j < num_dense_features; ++j) {\n        const Eigen::Tensor<float, 0, Eigen::RowMajor> sn =\n            example->dense_vectors_[j]->Row().square().sum();\n        squared_norm += sn();\n      }\n      example->squared_norm_ = squared_norm;\n    }\n  };\n  // TODO(sibyl-Aix6ihai): Compute the cost optimally.\n  const int64_t kCostPerUnit = num_dense_features + num_sparse_features;\n  Shard(worker_threads.num_threads, worker_threads.workers, num_examples,\n        kCostPerUnit, compute_example_norm);\n  return result;\n}\n\n}  // namespace sdca\n}  // namespace tensorflow\n", "/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/sdca_ops.cc.\n\n#define EIGEN_USE_THREADS\n\n#include <stdint.h>\n\n#include <atomic>\n#include <limits>\n#include <memory>\n#include <new>\n#include <string>\n#include <vector>\n\n#include \"absl/strings/str_format.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_def_builder.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/hinge-loss.h\"\n#include \"tensorflow/core/kernels/logistic-loss.h\"\n#include \"tensorflow/core/kernels/loss.h\"\n#include \"tensorflow/core/kernels/poisson-loss.h\"\n#include \"tensorflow/core/kernels/sdca_internal.h\"\n#include \"tensorflow/core/kernels/smooth-hinge-loss.h\"\n#include \"tensorflow/core/kernels/squared-loss.h\"\n#include \"tensorflow/core/lib/core/coding.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/platform/fingerprint.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\nusing sdca::Example;\nusing sdca::Examples;\nusing sdca::ExampleStatistics;\nusing sdca::ModelWeights;\nusing sdca::Regularizations;\n\nstruct ComputeOptions {\n  explicit ComputeOptions(OpKernelConstruction* const context) {\n    string loss_type;\n    OP_REQUIRES_OK(context, context->GetAttr(\"loss_type\", &loss_type));\n    if (loss_type == \"logistic_loss\") {\n      loss_updater.reset(new LogisticLossUpdater);\n    } else if (loss_type == \"squared_loss\") {\n      loss_updater.reset(new SquaredLossUpdater);\n    } else if (loss_type == \"hinge_loss\") {\n      loss_updater.reset(new HingeLossUpdater);\n    } else if (loss_type == \"smooth_hinge_loss\") {\n      loss_updater.reset(new SmoothHingeLossUpdater);\n    } else if (loss_type == \"poisson_loss\") {\n      loss_updater.reset(new PoissonLossUpdater);\n    } else {\n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unsupported loss type: \", loss_type));\n    }\n    auto s = context->GetAttr(\"adaptative\", &adaptive);\n    if (!s.ok()) {\n      s = context->GetAttr(\"adaptive\", &adaptive);\n    }\n    OP_REQUIRES_OK(context, s);\n    OP_REQUIRES_OK(\n        context, context->GetAttr(\"num_sparse_features\", &num_sparse_features));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_sparse_features_with_values\",\n                                             &num_sparse_features_with_values));\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"num_dense_features\", &num_dense_features));\n    OP_REQUIRES(\n        context, num_sparse_features + num_dense_features > 0,\n        errors::InvalidArgument(\"Requires at least one feature to train.\"));\n\n    OP_REQUIRES(context,\n                static_cast<int64_t>(num_sparse_features) +\n                        static_cast<int64_t>(num_dense_features) <=\n                    std::numeric_limits<int>::max(),\n                errors::InvalidArgument(absl::StrFormat(\n                    \"Too many feature groups: %d > %d\",\n                    static_cast<int64_t>(num_sparse_features) +\n                        static_cast<int64_t>(num_dense_features),\n                    std::numeric_limits<int>::max())));\n    OP_REQUIRES_OK(\n        context, context->GetAttr(\"num_loss_partitions\", &num_loss_partitions));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_inner_iterations\",\n                                             &num_inner_iterations));\n    OP_REQUIRES_OK(context, regularizations.Initialize(context));\n  }\n\n  std::unique_ptr<DualLossUpdater> loss_updater;\n  int num_sparse_features = 0;\n  int num_sparse_features_with_values = 0;\n  int num_dense_features = 0;\n  int num_inner_iterations = 0;\n  int num_loss_partitions = 0;\n  bool adaptive = true;\n  Regularizations regularizations;\n};\n\n// TODO(shengx): The helper classes/methods are changed to support multiclass\n// SDCA, which lead to changes within this function. Need to revisit the\n// convergence once the multiclass SDCA is in.\nvoid DoCompute(const ComputeOptions& options, OpKernelContext* const context) {\n  ModelWeights model_weights;\n  OP_REQUIRES_OK(context, model_weights.Initialize(context));\n\n  Examples examples;\n  OP_REQUIRES_OK(\n      context,\n      examples.Initialize(context, model_weights, options.num_sparse_features,\n                          options.num_sparse_features_with_values,\n                          options.num_dense_features));\n\n  const Tensor* example_state_data_t;\n  OP_REQUIRES_OK(context,\n                 context->input(\"example_state_data\", &example_state_data_t));\n  TensorShape expected_example_state_shape({examples.num_examples(), 4});\n  OP_REQUIRES(context,\n              example_state_data_t->shape() == expected_example_state_shape,\n              errors::InvalidArgument(\n                  \"Expected shape \", expected_example_state_shape.DebugString(),\n                  \" for example_state_data, got \",\n                  example_state_data_t->shape().DebugString()));\n\n  Tensor mutable_example_state_data_t(*example_state_data_t);\n  auto example_state_data = mutable_example_state_data_t.matrix<float>();\n  OP_REQUIRES_OK(context, context->set_output(\"out_example_state_data\",\n                                              mutable_example_state_data_t));\n\n  if (options.adaptive) {\n    OP_REQUIRES_OK(context,\n                   examples.SampleAdaptiveProbabilities(\n                       options.num_loss_partitions, options.regularizations,\n                       model_weights, example_state_data, options.loss_updater,\n                       /*num_weight_vectors =*/1));\n  } else {\n    examples.RandomShuffle();\n  }\n  struct {\n    mutex mu;\n    Status value TF_GUARDED_BY(mu);\n  } train_step_status;\n  std::atomic<std::int64_t> atomic_index(-1);\n  auto train_step = [&](const int64_t begin, const int64_t end) {\n    // The static_cast here is safe since begin and end can be at most\n    // num_examples which is an int.\n    for (int id = static_cast<int>(begin); id < end; ++id) {\n      const int64_t example_index = examples.sampled_index(++atomic_index);\n      const Example& example = examples.example(example_index);\n      const float dual = example_state_data(example_index, 0);\n      const float example_weight = example.example_weight();\n      float example_label = example.example_label();\n      const Status conversion_status =\n          options.loss_updater->ConvertLabel(&example_label);\n      if (!conversion_status.ok()) {\n        mutex_lock l(train_step_status.mu);\n        train_step_status.value = conversion_status;\n        // Return from this worker thread - the calling thread is\n        // responsible for checking context status and returning on error.\n        return;\n      }\n\n      // Compute wx, example norm weighted by regularization, dual loss,\n      // primal loss.\n      // For binary SDCA, num_weight_vectors should be one.\n      const ExampleStatistics example_statistics =\n          example.ComputeWxAndWeightedExampleNorm(\n              options.num_loss_partitions, model_weights,\n              options.regularizations, 1 /* num_weight_vectors */);\n\n      const double new_dual = options.loss_updater->ComputeUpdatedDual(\n          options.num_loss_partitions, example_label, example_weight, dual,\n          example_statistics.wx[0], example_statistics.normalized_squared_norm);\n\n      // Compute new weights.\n      const double normalized_bounded_dual_delta =\n          (new_dual - dual) * example_weight /\n          options.regularizations.symmetric_l2();\n      model_weights.UpdateDeltaWeights(\n          context->eigen_cpu_device(), example,\n          std::vector<double>{normalized_bounded_dual_delta});\n\n      // Update example data.\n      example_state_data(example_index, 0) = new_dual;\n      example_state_data(example_index, 1) =\n          options.loss_updater->ComputePrimalLoss(\n              example_statistics.prev_wx[0], example_label, example_weight);\n      example_state_data(example_index, 2) =\n          options.loss_updater->ComputeDualLoss(dual, example_label,\n                                                example_weight);\n      example_state_data(example_index, 3) = example_weight;\n    }\n  };\n  // TODO(sibyl-Aix6ihai): Tune this properly based on sparsity of the data,\n  // number of cpus, and cost per example.\n  const int64_t kCostPerUnit = examples.num_features();\n  const DeviceBase::CpuWorkerThreads& worker_threads =\n      *context->device()->tensorflow_cpu_worker_threads();\n\n  Shard(worker_threads.num_threads, worker_threads.workers,\n        examples.num_examples(), kCostPerUnit, train_step);\n  mutex_lock l(train_step_status.mu);\n  OP_REQUIRES_OK(context, train_step_status.value);\n}\n\n}  // namespace\n\nclass SdcaOptimizer : public OpKernel {\n public:\n  explicit SdcaOptimizer(OpKernelConstruction* const context)\n      : OpKernel(context), options_(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    DoCompute(options_, context);\n  }\n\n private:\n  // TODO(sibyl-Aix6ihai): We could use the type-constraint on loss_type, and\n  // template the entire class to avoid the virtual table lookup penalty in\n  // the inner loop.\n  ComputeOptions options_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"SdcaOptimizer\").Device(DEVICE_CPU),\n                        SdcaOptimizer);\nREGISTER_KERNEL_BUILDER(Name(\"SdcaOptimizerV2\").Device(DEVICE_CPU),\n                        SdcaOptimizer);\n\nclass SdcaShrinkL1 : public OpKernel {\n public:\n  explicit SdcaShrinkL1(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, regularizations_.Initialize(context));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    OpMutableInputList weights_inputs;\n    OP_REQUIRES_OK(context,\n                   context->mutable_input_list(\"weights\", &weights_inputs));\n\n    auto do_work = [&](const int64_t begin, const int64_t end) {\n      for (int i = begin; i < end; ++i) {\n        auto prox_w = weights_inputs.at(i, /*lock_held=*/true).flat<float>();\n        prox_w.device(context->eigen_cpu_device()) =\n            regularizations_.EigenShrinkVector(prox_w);\n      }\n    };\n\n    if (weights_inputs.size() > 0) {\n      int64_t num_weights = 0;\n      for (int i = 0; i < weights_inputs.size(); ++i) {\n        num_weights += weights_inputs.at(i, /*lock_held=*/true).NumElements();\n      }\n      // TODO(sibyl-Aix6ihai): Tune this value.\n      const int64_t kCostPerUnit = (num_weights * 50) / weights_inputs.size();\n      const DeviceBase::CpuWorkerThreads& worker_threads =\n          *context->device()->tensorflow_cpu_worker_threads();\n      Shard(worker_threads.num_threads, worker_threads.workers,\n            weights_inputs.size(), kCostPerUnit, do_work);\n    }\n  }\n\n private:\n  Regularizations regularizations_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"SdcaShrinkL1\").Device(DEVICE_CPU), SdcaShrinkL1);\n\n// Computes platform independent, compact and unique (with very high\n// probability) representation of an example id. It shouldn't be put in\n// persistent storage, as its implementation may change in the future.\n//\n// The current probability of at least one collision for 1B example_ids is\n// approximately 10^-21 (ie 2^60 / 2^129).\nclass SdcaFprint : public OpKernel {\n public:\n  explicit SdcaFprint(OpKernelConstruction* const context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input.shape()),\n                errors::InvalidArgument(\"Input must be a vector, got shape \",\n                                        input.shape().DebugString()));\n    Tensor* out;\n    const int64_t num_elements = input.NumElements();\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, TensorShape({num_elements, 2}), &out));\n\n    const auto in_values = input.flat<tstring>();\n    auto out_values = out->matrix<int64_t>();\n\n    for (int64_t i = 0; i < num_elements; ++i) {\n      const Fprint128 fprint = Fingerprint128(in_values(i));\n      // Never return 0 or 1 as the first value of the hash to allow these to\n      // safely be used as sentinel values (e.g. dense hash table empty key).\n      out_values(i, 0) = TF_PREDICT_TRUE(fprint.low64 >= 2)\n                             ? fprint.low64\n                             : fprint.low64 + ~static_cast<uint64>(1);\n      out_values(i, 1) = fprint.high64;\n    }\n  }\n};\nREGISTER_KERNEL_BUILDER(Name(\"SdcaFprint\").Device(DEVICE_CPU), SdcaFprint);\n\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/kernels/sdca_internal.h\"\n\n#include <limits>\n#include <numeric>\n#include <random>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/lib/gtl/flatset.h\"\n#include \"tensorflow/core/lib/math/math_util.h\"\n#include \"tensorflow/core/lib/random/simple_philox.h\"\n\n#if defined(TENSORFLOW_USE_CUSTOM_CONTRACTION_KERNEL)\n#include \"tensorflow/core/kernels/eigen_contraction_kernel.h\"\n#endif\n\nnamespace tensorflow {\nnamespace sdca {\n\nusing UnalignedFloatVector = TTypes<const float>::UnalignedConstVec;\nusing UnalignedInt64Vector = TTypes<const int64_t>::UnalignedConstVec;\n\nvoid FeatureWeightsDenseStorage::UpdateDenseDeltaWeights(\n    const Eigen::ThreadPoolDevice& device,\n    const Example::DenseVector& dense_vector,\n    const std::vector<double>& normalized_bounded_dual_delta) {\n  const size_t num_weight_vectors = normalized_bounded_dual_delta.size();\n  if (num_weight_vectors == 1) {\n    deltas_.device(device) =\n        deltas_ + dense_vector.RowAsMatrix() *\n                      deltas_.constant(normalized_bounded_dual_delta[0]);\n  } else {\n    // Transform the dual vector into a column matrix.\n    const Eigen::TensorMap<Eigen::Tensor<const double, 2, Eigen::RowMajor>>\n        dual_matrix(normalized_bounded_dual_delta.data(), num_weight_vectors,\n                    1);\n    const Eigen::array<Eigen::IndexPair<int>, 1> product_dims = {\n        Eigen::IndexPair<int>(1, 0)};\n    // This computes delta_w += delta_vector / \\lamdba * N.\n    deltas_.device(device) =\n        (deltas_.cast<double>() +\n         dual_matrix.contract(dense_vector.RowAsMatrix().cast<double>(),\n                              product_dims))\n            .cast<float>();\n  }\n}\n\nvoid FeatureWeightsSparseStorage::UpdateSparseDeltaWeights(\n    const Eigen::ThreadPoolDevice& device,\n    const Example::SparseFeatures& sparse_features,\n    const std::vector<double>& normalized_bounded_dual_delta) {\n  for (int64_t k = 0; k < sparse_features.indices->size(); ++k) {\n    const double feature_value =\n        sparse_features.values == nullptr ? 1.0 : (*sparse_features.values)(k);\n    auto it = indices_to_id_.find((*sparse_features.indices)(k));\n    for (size_t l = 0; l < normalized_bounded_dual_delta.size(); ++l) {\n      deltas_(l, it->second) +=\n          feature_value * normalized_bounded_dual_delta[l];\n    }\n  }\n}\n\nvoid ModelWeights::UpdateDeltaWeights(\n    const Eigen::ThreadPoolDevice& device, const Example& example,\n    const std::vector<double>& normalized_bounded_dual_delta) {\n  // Sparse weights.\n  for (size_t j = 0; j < sparse_weights_.size(); ++j) {\n    sparse_weights_[j].UpdateSparseDeltaWeights(\n        device, example.sparse_features_[j], normalized_bounded_dual_delta);\n  }\n\n  // Dense weights.\n  for (size_t j = 0; j < dense_weights_.size(); ++j) {\n    dense_weights_[j].UpdateDenseDeltaWeights(\n        device, *example.dense_vectors_[j], normalized_bounded_dual_delta);\n  }\n}\n\nStatus ModelWeights::Initialize(OpKernelContext* const context) {\n  OpInputList sparse_indices_inputs;\n  TF_RETURN_IF_ERROR(\n      context->input_list(\"sparse_indices\", &sparse_indices_inputs));\n  OpInputList sparse_weights_inputs;\n  TF_RETURN_IF_ERROR(\n      context->input_list(\"sparse_weights\", &sparse_weights_inputs));\n  if (sparse_indices_inputs.size() != sparse_weights_inputs.size())\n    return errors::InvalidArgument(\n        \"sparse_indices and sparse_weights must have the same length, got \",\n        sparse_indices_inputs.size(), \" and \", sparse_weights_inputs.size());\n  OpInputList dense_weights_inputs;\n  TF_RETURN_IF_ERROR(\n      context->input_list(\"dense_weights\", &dense_weights_inputs));\n\n  OpOutputList sparse_weights_outputs;\n  TF_RETURN_IF_ERROR(context->output_list(\"out_delta_sparse_weights\",\n                                          &sparse_weights_outputs));\n  if (sparse_weights_outputs.size() != sparse_weights_inputs.size())\n    return errors::InvalidArgument(\n        \"out_delta_sparse_weights and sparse_weights must have the same \"\n        \"length, got \",\n        sparse_weights_outputs.size(), \" and \", sparse_weights_inputs.size());\n\n  OpOutputList dense_weights_outputs;\n  TF_RETURN_IF_ERROR(\n      context->output_list(\"out_delta_dense_weights\", &dense_weights_outputs));\n  if (dense_weights_outputs.size() != dense_weights_inputs.size())\n    return errors::InvalidArgument(\n        \"out_delta_dense_weights and dense_weights must have the same length, \"\n        \"got \",\n        dense_weights_outputs.size(), \" and \", dense_weights_inputs.size());\n\n  for (int i = 0; i < sparse_weights_inputs.size(); ++i) {\n    Tensor* delta_t;\n    TF_RETURN_IF_ERROR(sparse_weights_outputs.allocate(\n        i, sparse_weights_inputs[i].shape(), &delta_t));\n    // Convert the input vector to a row matrix in internal representation.\n    auto deltas = delta_t->shaped<float, 2>({1, delta_t->NumElements()});\n    deltas.setZero();\n    sparse_weights_.emplace_back(FeatureWeightsSparseStorage{\n        sparse_indices_inputs[i].flat<int64_t>(),\n        sparse_weights_inputs[i].shaped<float, 2>(\n            {1, sparse_weights_inputs[i].NumElements()}),\n        deltas});\n  }\n\n  // Reads in the weights, and allocates and initializes the delta weights.\n  const auto initialize_weights =\n      [&](const OpInputList& weight_inputs, OpOutputList* const weight_outputs,\n          std::vector<FeatureWeightsDenseStorage>* const feature_weights) {\n        for (int i = 0; i < weight_inputs.size(); ++i) {\n          Tensor* delta_t;\n          TF_RETURN_IF_ERROR(\n              weight_outputs->allocate(i, weight_inputs[i].shape(), &delta_t));\n          // Convert the input vector to a row matrix in internal\n          // representation.\n          auto deltas = delta_t->shaped<float, 2>({1, delta_t->NumElements()});\n          deltas.setZero();\n          feature_weights->emplace_back(FeatureWeightsDenseStorage{\n              weight_inputs[i].shaped<float, 2>(\n                  {1, weight_inputs[i].NumElements()}),\n              deltas});\n        }\n        return OkStatus();\n      };\n\n  return initialize_weights(dense_weights_inputs, &dense_weights_outputs,\n                            &dense_weights_);\n}\n\n// Computes the example statistics for given example, and model. Defined here\n// as we need definition of ModelWeights and Regularizations.\nconst ExampleStatistics Example::ComputeWxAndWeightedExampleNorm(\n    const int num_loss_partitions, const ModelWeights& model_weights,\n    const Regularizations& regularization, const int num_weight_vectors) const {\n  ExampleStatistics result(num_weight_vectors);\n\n  result.normalized_squared_norm =\n      squared_norm_ / regularization.symmetric_l2();\n\n  // Compute w \\dot x and prev_w \\dot x.\n  // This is for sparse features contribution to the logit.\n  for (size_t j = 0; j < sparse_features_.size(); ++j) {\n    const Example::SparseFeatures& sparse_features = sparse_features_[j];\n    const FeatureWeightsSparseStorage& sparse_weights =\n        model_weights.sparse_weights()[j];\n\n    for (int64_t k = 0; k < sparse_features.indices->size(); ++k) {\n      const int64_t feature_index = (*sparse_features.indices)(k);\n      const double feature_value = sparse_features.values == nullptr\n                                       ? 1.0\n                                       : (*sparse_features.values)(k);\n      for (int l = 0; l < num_weight_vectors; ++l) {\n        const float sparse_weight = sparse_weights.nominals(l, feature_index);\n        const double feature_weight =\n            sparse_weight +\n            sparse_weights.deltas(l, feature_index) * num_loss_partitions;\n        result.prev_wx[l] +=\n            feature_value * regularization.Shrink(sparse_weight);\n        result.wx[l] += feature_value * regularization.Shrink(feature_weight);\n      }\n    }\n  }\n\n  // Compute w \\dot x and prev_w \\dot x.\n  // This is for dense features contribution to the logit.\n  for (size_t j = 0; j < dense_vectors_.size(); ++j) {\n    const Example::DenseVector& dense_vector = *dense_vectors_[j];\n    const FeatureWeightsDenseStorage& dense_weights =\n        model_weights.dense_weights()[j];\n\n    const Eigen::Tensor<float, 2, Eigen::RowMajor> feature_weights =\n        dense_weights.nominals() +\n        dense_weights.deltas() *\n            dense_weights.deltas().constant(num_loss_partitions);\n    if (num_weight_vectors == 1) {\n      const Eigen::Tensor<float, 0, Eigen::RowMajor> prev_prediction =\n          (dense_vector.Row() *\n           regularization.EigenShrinkVector(\n               Eigen::TensorMap<Eigen::Tensor<const float, 1, Eigen::RowMajor>>(\n                   dense_weights.nominals().data(),\n                   dense_weights.nominals().dimension(1))))\n              .sum();\n      const Eigen::Tensor<float, 0, Eigen::RowMajor> prediction =\n          (dense_vector.Row() *\n           regularization.EigenShrinkVector(\n               Eigen::TensorMap<Eigen::Tensor<const float, 1, Eigen::RowMajor>>(\n                   feature_weights.data(), feature_weights.dimension(1))))\n              .sum();\n      result.prev_wx[0] += prev_prediction();\n      result.wx[0] += prediction();\n    } else {\n      const Eigen::array<Eigen::IndexPair<int>, 1> product_dims = {\n          Eigen::IndexPair<int>(1, 1)};\n      const Eigen::Tensor<float, 2, Eigen::RowMajor> prev_prediction =\n          regularization.EigenShrinkMatrix(dense_weights.nominals())\n              .contract(dense_vector.RowAsMatrix(), product_dims);\n      const Eigen::Tensor<float, 2, Eigen::RowMajor> prediction =\n          regularization.EigenShrinkMatrix(feature_weights)\n              .contract(dense_vector.RowAsMatrix(), product_dims);\n      // The result of \"tensor contraction\" (multiplication)  in the code\n      // above is of dimension num_weight_vectors * 1.\n      for (int l = 0; l < num_weight_vectors; ++l) {\n        result.prev_wx[l] += prev_prediction(l, 0);\n        result.wx[l] += prediction(l, 0);\n      }\n    }\n  }\n\n  return result;\n}\n\n// Examples contains all the training examples that SDCA uses for a mini-batch.\nStatus Examples::SampleAdaptiveProbabilities(\n    const int num_loss_partitions, const Regularizations& regularization,\n    const ModelWeights& model_weights,\n    const TTypes<float>::Matrix example_state_data,\n    const std::unique_ptr<DualLossUpdater>& loss_updater,\n    const int num_weight_vectors) {\n  if (num_weight_vectors != 1) {\n    return errors::InvalidArgument(\n        \"Adaptive SDCA only works with binary SDCA, \"\n        \"where num_weight_vectors should be 1.\");\n  }\n  // Compute the probabilities\n  for (int example_id = 0; example_id < num_examples(); ++example_id) {\n    const Example& example = examples_[example_id];\n    const double example_weight = example.example_weight();\n    float label = example.example_label();\n    const Status conversion_status = loss_updater->ConvertLabel(&label);\n    const ExampleStatistics example_statistics =\n        example.ComputeWxAndWeightedExampleNorm(num_loss_partitions,\n                                                model_weights, regularization,\n                                                num_weight_vectors);\n    const double kappa = example_state_data(example_id, 0) +\n                         loss_updater->PrimalLossDerivative(\n                             example_statistics.wx[0], label, 1.0);\n    probabilities_[example_id] = example_weight *\n                                 sqrt(examples_[example_id].squared_norm_ +\n                                      regularization.symmetric_l2() *\n                                          loss_updater->SmoothnessConstant()) *\n                                 std::abs(kappa);\n  }\n\n  // Sample the index\n  random::DistributionSampler sampler(probabilities_);\n  GuardedPhiloxRandom generator;\n  generator.Init(0, 0);\n  auto local_gen = generator.ReserveSamples32(num_examples());\n  random::SimplePhilox random(&local_gen);\n  std::random_device rd;\n  std::mt19937 gen(rd());\n  std::uniform_real_distribution<> dis(0, 1);\n\n  // We use a decay of 10: the probability of an example is divided by 10\n  // once that example is picked. A good approximation of that is to only\n  // keep a picked example with probability (1 / 10) ^ k where k is the\n  // number of times we already picked that example. We add a num_retries\n  // to avoid taking too long to sample. We then fill the sampled_index with\n  // unseen examples sorted by probabilities.\n  int id = 0;\n  int num_retries = 0;\n  while (id < num_examples() && num_retries < num_examples()) {\n    int picked_id = sampler.Sample(&random);\n    if (dis(gen) > MathUtil::IPow(0.1, sampled_count_[picked_id])) {\n      num_retries++;\n      continue;\n    }\n    sampled_count_[picked_id]++;\n    sampled_index_[id++] = picked_id;\n  }\n\n  std::vector<std::pair<int, float>> examples_not_seen;\n  examples_not_seen.reserve(num_examples());\n  for (int i = 0; i < num_examples(); ++i) {\n    if (sampled_count_[i] == 0)\n      examples_not_seen.emplace_back(sampled_index_[i], probabilities_[i]);\n  }\n  std::sort(\n      examples_not_seen.begin(), examples_not_seen.end(),\n      [](const std::pair<int, float>& lhs, const std::pair<int, float>& rhs) {\n        return lhs.second > rhs.second;\n      });\n  for (int i = id; i < num_examples(); ++i) {\n    sampled_count_[i] = examples_not_seen[i - id].first;\n  }\n  return OkStatus();\n}\n\nvoid Examples::RandomShuffle() {\n  std::iota(sampled_index_.begin(), sampled_index_.end(), 0);\n\n  std::random_device rd;\n  std::mt19937 rng(rd());\n  std::shuffle(sampled_index_.begin(), sampled_index_.end(), rng);\n}\n\n// TODO(sibyl-Aix6ihai): Refactor/shorten this function.\nStatus Examples::Initialize(OpKernelContext* const context,\n                            const ModelWeights& weights,\n                            const int num_sparse_features,\n                            const int num_sparse_features_with_values,\n                            const int num_dense_features) {\n  num_features_ = num_sparse_features + num_dense_features;\n\n  OpInputList sparse_example_indices_inputs;\n  TF_RETURN_IF_ERROR(context->input_list(\"sparse_example_indices\",\n                                         &sparse_example_indices_inputs));\n  if (sparse_example_indices_inputs.size() != num_sparse_features)\n    return errors::InvalidArgument(\n        \"Expected \", num_sparse_features,\n        \" tensors in sparse_example_indices but got \",\n        sparse_example_indices_inputs.size());\n  OpInputList sparse_feature_indices_inputs;\n  TF_RETURN_IF_ERROR(context->input_list(\"sparse_feature_indices\",\n                                         &sparse_feature_indices_inputs));\n  if (sparse_feature_indices_inputs.size() != num_sparse_features)\n    return errors::InvalidArgument(\n        \"Expected \", num_sparse_features,\n        \" tensors in sparse_feature_indices but got \",\n        sparse_feature_indices_inputs.size());\n  OpInputList sparse_feature_values_inputs;\n  if (num_sparse_features_with_values > 0) {\n    TF_RETURN_IF_ERROR(context->input_list(\"sparse_feature_values\",\n                                           &sparse_feature_values_inputs));\n    if (sparse_feature_values_inputs.size() != num_sparse_features_with_values)\n      return errors::InvalidArgument(\n          \"Expected \", num_sparse_features_with_values,\n          \" tensors in sparse_feature_values but got \",\n          sparse_feature_values_inputs.size());\n  }\n\n  const Tensor* example_weights_t;\n  TF_RETURN_IF_ERROR(context->input(\"example_weights\", &example_weights_t));\n  auto example_weights = example_weights_t->flat<float>();\n\n  if (example_weights.size() >= std::numeric_limits<int>::max()) {\n    return errors::InvalidArgument(strings::Printf(\n        \"Too many examples in a mini-batch: %zu > %d\", example_weights.size(),\n        std::numeric_limits<int>::max()));\n  }\n\n  // The static_cast here is safe since num_examples can be at max an int.\n  const int num_examples = static_cast<int>(example_weights.size());\n  const Tensor* example_labels_t;\n  TF_RETURN_IF_ERROR(context->input(\"example_labels\", &example_labels_t));\n  auto example_labels = example_labels_t->flat<float>();\n  if (example_labels.size() != num_examples) {\n    return errors::InvalidArgument(\"Expected \", num_examples,\n                                   \" example labels but got \",\n                                   example_labels.size());\n  }\n\n  OpInputList dense_features_inputs;\n  TF_RETURN_IF_ERROR(\n      context->input_list(\"dense_features\", &dense_features_inputs));\n  for (int i = 0; i < dense_features_inputs.size(); ++i) {\n    if (!TensorShapeUtils::IsMatrix(dense_features_inputs[i].shape())) {\n      return errors::InvalidArgument(\"Dense features at index \", i,\n                                     \" must be rank 2 but is rank \",\n                                     dense_features_inputs[i].dims());\n    }\n  }\n\n  examples_.clear();\n  examples_.resize(num_examples);\n  probabilities_.resize(num_examples);\n  sampled_index_.resize(num_examples);\n  sampled_count_.resize(num_examples);\n  for (int example_id = 0; example_id < num_examples; ++example_id) {\n    Example* const example = &examples_[example_id];\n    example->sparse_features_.resize(num_sparse_features);\n    example->dense_vectors_.resize(num_dense_features);\n    example->example_weight_ = example_weights(example_id);\n    example->example_label_ = example_labels(example_id);\n  }\n  const DeviceBase::CpuWorkerThreads& worker_threads =\n      *context->device()->tensorflow_cpu_worker_threads();\n  TF_RETURN_IF_ERROR(CreateSparseFeatureRepresentation(\n      worker_threads, num_examples, num_sparse_features, weights,\n      sparse_example_indices_inputs, sparse_feature_indices_inputs,\n      sparse_feature_values_inputs, &examples_));\n  TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(\n      worker_threads, num_examples, num_dense_features, weights,\n      dense_features_inputs, &examples_));\n  TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(\n      worker_threads, num_examples, num_sparse_features, num_dense_features,\n      &examples_));\n  return OkStatus();\n}\n\nStatus Examples::CreateSparseFeatureRepresentation(\n    const DeviceBase::CpuWorkerThreads& worker_threads, const int num_examples,\n    const int num_sparse_features, const ModelWeights& weights,\n    const OpInputList& sparse_example_indices_inputs,\n    const OpInputList& sparse_feature_indices_inputs,\n    const OpInputList& sparse_feature_values_inputs,\n    std::vector<Example>* const examples) {\n  mutex mu;\n  Status result;  // Guarded by mu\n  auto parse_partition = [&](const int64_t begin, const int64_t end) {\n    // The static_cast here is safe since begin and end can be at most\n    // num_examples which is an int.\n    for (int i = static_cast<int>(begin); i < end; ++i) {\n      auto example_indices =\n          sparse_example_indices_inputs[i].template flat<int64_t>();\n      auto feature_indices =\n          sparse_feature_indices_inputs[i].template flat<int64_t>();\n      if (example_indices.size() != feature_indices.size()) {\n        mutex_lock l(mu);\n        result = errors::InvalidArgument(\n            \"Found mismatched example_indices and feature_indices [\",\n            example_indices, \"] vs [\", feature_indices, \"]\");\n        return;\n      }\n\n      // Parse features for each example. Features for a particular example\n      // are at the offsets (start_id, end_id]\n      int start_id = -1;\n      int end_id = 0;\n      for (int example_id = 0; example_id < num_examples; ++example_id) {\n        start_id = end_id;\n        while (end_id < example_indices.size() &&\n               example_indices(end_id) == example_id) {\n          ++end_id;\n        }\n        Example::SparseFeatures* const sparse_features =\n            &(*examples)[example_id].sparse_features_[i];\n        if (start_id < example_indices.size() &&\n            example_indices(start_id) == example_id) {\n          sparse_features->indices.reset(new UnalignedInt64Vector(\n              &(feature_indices(start_id)), end_id - start_id));\n          if (sparse_feature_values_inputs.size() > i) {\n            auto feature_weights =\n                sparse_feature_values_inputs[i].flat<float>();\n            sparse_features->values.reset(new UnalignedFloatVector(\n                &(feature_weights(start_id)), end_id - start_id));\n          }\n          // If features are non empty.\n          if (end_id - start_id > 0) {\n            // TODO(sibyl-Aix6ihai): Write this efficiently using vectorized\n            // operations from eigen.\n            for (int64_t k = 0; k < sparse_features->indices->size(); ++k) {\n              const int64_t feature_index = (*sparse_features->indices)(k);\n              if (!weights.SparseIndexValid(i, feature_index)) {\n                mutex_lock l(mu);\n                result = errors::InvalidArgument(\n                    \"Found sparse feature indices out of valid range: \",\n                    (*sparse_features->indices)(k));\n                return;\n              }\n            }\n          }\n        } else {\n          // Add a Tensor that has size 0.\n          sparse_features->indices.reset(\n              new UnalignedInt64Vector(&(feature_indices(0)), 0));\n          // If values exist for this feature group.\n          if (sparse_feature_values_inputs.size() > i) {\n            auto feature_weights =\n                sparse_feature_values_inputs[i].flat<float>();\n            sparse_features->values.reset(\n                new UnalignedFloatVector(&(feature_weights(0)), 0));\n          }\n        }\n      }\n    }\n  };\n  // For each column, the cost of parsing it is O(num_examples). We use\n  // num_examples here, as empirically Shard() creates the right amount of\n  // threads based on the problem size.\n  // TODO(sibyl-Aix6ihai): Tune this as a function of dataset size.\n  const int64_t kCostPerUnit = num_examples;\n  Shard(worker_threads.num_threads, worker_threads.workers, num_sparse_features,\n        kCostPerUnit, parse_partition);\n  return result;\n}\n\nStatus Examples::CreateDenseFeatureRepresentation(\n    const DeviceBase::CpuWorkerThreads& worker_threads, const int num_examples,\n    const int num_dense_features, const ModelWeights& weights,\n    const OpInputList& dense_features_inputs,\n    std::vector<Example>* const examples) {\n  mutex mu;\n  Status result;  // Guarded by mu\n  auto parse_partition = [&](const int64_t begin, const int64_t end) {\n    // The static_cast here is safe since begin and end can be at most\n    // num_examples which is an int.\n    for (int i = static_cast<int>(begin); i < end; ++i) {\n      auto dense_features = dense_features_inputs[i].template matrix<float>();\n      for (int example_id = 0; example_id < num_examples; ++example_id) {\n        (*examples)[example_id].dense_vectors_[i].reset(\n            new Example::DenseVector{dense_features, example_id});\n      }\n      if (!weights.DenseIndexValid(i, dense_features.dimension(1) - 1)) {\n        mutex_lock l(mu);\n        result = errors::InvalidArgument(\n            \"More dense features than we have parameters for: \",\n            dense_features.dimension(1));\n        return;\n      }\n    }\n  };\n  // TODO(sibyl-Aix6ihai): Tune this as a function of dataset size.\n  const int64_t kCostPerUnit = num_examples;\n  Shard(worker_threads.num_threads, worker_threads.workers, num_dense_features,\n        kCostPerUnit, parse_partition);\n  return result;\n}\n\nStatus Examples::ComputeSquaredNormPerExample(\n    const DeviceBase::CpuWorkerThreads& worker_threads, const int num_examples,\n    const int num_sparse_features, const int num_dense_features,\n    std::vector<Example>* const examples) {\n  mutex mu;\n  Status result;  // Guarded by mu\n  // Compute norm of examples.\n  auto compute_example_norm = [&](const int64_t begin, const int64_t end) {\n    // The static_cast here is safe since begin and end can be at most\n    // num_examples which is an int.\n    gtl::FlatSet<int64_t> previous_indices;\n    for (int example_id = static_cast<int>(begin); example_id < end;\n         ++example_id) {\n      double squared_norm = 0;\n      Example* const example = &(*examples)[example_id];\n      for (int j = 0; j < num_sparse_features; ++j) {\n        const Example::SparseFeatures& sparse_features =\n            example->sparse_features_[j];\n        previous_indices.clear();\n        for (int64_t k = 0; k < sparse_features.indices->size(); ++k) {\n          const int64_t feature_index = (*sparse_features.indices)(k);\n          if (previous_indices.insert(feature_index).second == false) {\n            mutex_lock l(mu);\n            result =\n                errors::InvalidArgument(\"Duplicate index in sparse vector.\");\n            return;\n          }\n          const double feature_value = sparse_features.values == nullptr\n                                           ? 1.0\n                                           : (*sparse_features.values)(k);\n          squared_norm += feature_value * feature_value;\n        }\n      }\n      for (int j = 0; j < num_dense_features; ++j) {\n        const Eigen::Tensor<float, 0, Eigen::RowMajor> sn =\n            example->dense_vectors_[j]->Row().square().sum();\n        squared_norm += sn();\n      }\n      example->squared_norm_ = squared_norm;\n    }\n  };\n  // TODO(sibyl-Aix6ihai): Compute the cost optimally.\n  const int64_t kCostPerUnit = num_dense_features + num_sparse_features;\n  Shard(worker_threads.num_threads, worker_threads.workers, num_examples,\n        kCostPerUnit, compute_example_norm);\n  return result;\n}\n\n}  // namespace sdca\n}  // namespace tensorflow\n", "/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/sdca_ops.cc.\n\n#define EIGEN_USE_THREADS\n\n#include <stdint.h>\n\n#include <atomic>\n#include <limits>\n#include <memory>\n#include <new>\n#include <string>\n#include <vector>\n\n#include \"absl/strings/str_format.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_def_builder.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/hinge-loss.h\"\n#include \"tensorflow/core/kernels/logistic-loss.h\"\n#include \"tensorflow/core/kernels/loss.h\"\n#include \"tensorflow/core/kernels/poisson-loss.h\"\n#include \"tensorflow/core/kernels/sdca_internal.h\"\n#include \"tensorflow/core/kernels/smooth-hinge-loss.h\"\n#include \"tensorflow/core/kernels/squared-loss.h\"\n#include \"tensorflow/core/lib/core/coding.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/fingerprint.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\nusing sdca::Example;\nusing sdca::Examples;\nusing sdca::ExampleStatistics;\nusing sdca::ModelWeights;\nusing sdca::Regularizations;\n\nstruct ComputeOptions {\n  explicit ComputeOptions(OpKernelConstruction* const context) {\n    string loss_type;\n    OP_REQUIRES_OK(context, context->GetAttr(\"loss_type\", &loss_type));\n    if (loss_type == \"logistic_loss\") {\n      loss_updater.reset(new LogisticLossUpdater);\n    } else if (loss_type == \"squared_loss\") {\n      loss_updater.reset(new SquaredLossUpdater);\n    } else if (loss_type == \"hinge_loss\") {\n      loss_updater.reset(new HingeLossUpdater);\n    } else if (loss_type == \"smooth_hinge_loss\") {\n      loss_updater.reset(new SmoothHingeLossUpdater);\n    } else if (loss_type == \"poisson_loss\") {\n      loss_updater.reset(new PoissonLossUpdater);\n    } else {\n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unsupported loss type: \", loss_type));\n    }\n    auto s = context->GetAttr(\"adaptative\", &adaptive);\n    if (!s.ok()) {\n      s = context->GetAttr(\"adaptive\", &adaptive);\n    }\n    OP_REQUIRES_OK(context, s);\n    OP_REQUIRES_OK(\n        context, context->GetAttr(\"num_sparse_features\", &num_sparse_features));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_sparse_features_with_values\",\n                                             &num_sparse_features_with_values));\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"num_dense_features\", &num_dense_features));\n    OP_REQUIRES(\n        context, num_sparse_features + num_dense_features > 0,\n        errors::InvalidArgument(\"Requires at least one feature to train.\"));\n\n    OP_REQUIRES(context,\n                static_cast<int64_t>(num_sparse_features) +\n                        static_cast<int64_t>(num_dense_features) <=\n                    std::numeric_limits<int>::max(),\n                errors::InvalidArgument(absl::StrFormat(\n                    \"Too many feature groups: %d > %d\",\n                    static_cast<int64_t>(num_sparse_features) +\n                        static_cast<int64_t>(num_dense_features),\n                    std::numeric_limits<int>::max())));\n    OP_REQUIRES_OK(\n        context, context->GetAttr(\"num_loss_partitions\", &num_loss_partitions));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_inner_iterations\",\n                                             &num_inner_iterations));\n    OP_REQUIRES_OK(context, regularizations.Initialize(context));\n  }\n\n  std::unique_ptr<DualLossUpdater> loss_updater;\n  int num_sparse_features = 0;\n  int num_sparse_features_with_values = 0;\n  int num_dense_features = 0;\n  int num_inner_iterations = 0;\n  int num_loss_partitions = 0;\n  bool adaptive = true;\n  Regularizations regularizations;\n};\n\n// TODO(shengx): The helper classes/methods are changed to support multiclass\n// SDCA, which lead to changes within this function. Need to revisit the\n// convergence once the multiclass SDCA is in.\nvoid DoCompute(const ComputeOptions& options, OpKernelContext* const context) {\n  ModelWeights model_weights;\n  OP_REQUIRES_OK(context, model_weights.Initialize(context));\n\n  Examples examples;\n  OP_REQUIRES_OK(\n      context,\n      examples.Initialize(context, model_weights, options.num_sparse_features,\n                          options.num_sparse_features_with_values,\n                          options.num_dense_features));\n\n  const Tensor* example_state_data_t;\n  OP_REQUIRES_OK(context,\n                 context->input(\"example_state_data\", &example_state_data_t));\n  OP_REQUIRES(\n      context, TensorShapeUtils::IsMatrix(example_state_data_t->shape()),\n      errors::InvalidArgument(\"example_state_data must be rank 2 but is rank \",\n                              example_state_data_t->dims()));\n  TensorShape expected_example_state_shape({examples.num_examples(), 4});\n  OP_REQUIRES(context,\n              example_state_data_t->shape() == expected_example_state_shape,\n              errors::InvalidArgument(\n                  \"Expected shape \", expected_example_state_shape.DebugString(),\n                  \" for example_state_data, got \",\n                  example_state_data_t->shape().DebugString()));\n\n  Tensor mutable_example_state_data_t(*example_state_data_t);\n  auto example_state_data = mutable_example_state_data_t.matrix<float>();\n  OP_REQUIRES_OK(context, context->set_output(\"out_example_state_data\",\n                                              mutable_example_state_data_t));\n\n  if (options.adaptive) {\n    OP_REQUIRES_OK(context,\n                   examples.SampleAdaptiveProbabilities(\n                       options.num_loss_partitions, options.regularizations,\n                       model_weights, example_state_data, options.loss_updater,\n                       /*num_weight_vectors =*/1));\n  } else {\n    examples.RandomShuffle();\n  }\n  struct {\n    mutex mu;\n    Status value TF_GUARDED_BY(mu);\n  } train_step_status;\n  std::atomic<std::int64_t> atomic_index(-1);\n  auto train_step = [&](const int64_t begin, const int64_t end) {\n    // The static_cast here is safe since begin and end can be at most\n    // num_examples which is an int.\n    for (int id = static_cast<int>(begin); id < end; ++id) {\n      const int64_t example_index = examples.sampled_index(++atomic_index);\n      const Example& example = examples.example(example_index);\n      const float dual = example_state_data(example_index, 0);\n      const float example_weight = example.example_weight();\n      float example_label = example.example_label();\n      const Status conversion_status =\n          options.loss_updater->ConvertLabel(&example_label);\n      if (!conversion_status.ok()) {\n        mutex_lock l(train_step_status.mu);\n        train_step_status.value = conversion_status;\n        // Return from this worker thread - the calling thread is\n        // responsible for checking context status and returning on error.\n        return;\n      }\n\n      // Compute wx, example norm weighted by regularization, dual loss,\n      // primal loss.\n      // For binary SDCA, num_weight_vectors should be one.\n      const ExampleStatistics example_statistics =\n          example.ComputeWxAndWeightedExampleNorm(\n              options.num_loss_partitions, model_weights,\n              options.regularizations, 1 /* num_weight_vectors */);\n\n      const double new_dual = options.loss_updater->ComputeUpdatedDual(\n          options.num_loss_partitions, example_label, example_weight, dual,\n          example_statistics.wx[0], example_statistics.normalized_squared_norm);\n\n      // Compute new weights.\n      const double normalized_bounded_dual_delta =\n          (new_dual - dual) * example_weight /\n          options.regularizations.symmetric_l2();\n      model_weights.UpdateDeltaWeights(\n          context->eigen_cpu_device(), example,\n          std::vector<double>{normalized_bounded_dual_delta});\n\n      // Update example data.\n      example_state_data(example_index, 0) = new_dual;\n      example_state_data(example_index, 1) =\n          options.loss_updater->ComputePrimalLoss(\n              example_statistics.prev_wx[0], example_label, example_weight);\n      example_state_data(example_index, 2) =\n          options.loss_updater->ComputeDualLoss(dual, example_label,\n                                                example_weight);\n      example_state_data(example_index, 3) = example_weight;\n    }\n  };\n  // TODO(sibyl-Aix6ihai): Tune this properly based on sparsity of the data,\n  // number of cpus, and cost per example.\n  const int64_t kCostPerUnit = examples.num_features();\n  const DeviceBase::CpuWorkerThreads& worker_threads =\n      *context->device()->tensorflow_cpu_worker_threads();\n\n  Shard(worker_threads.num_threads, worker_threads.workers,\n        examples.num_examples(), kCostPerUnit, train_step);\n  mutex_lock l(train_step_status.mu);\n  OP_REQUIRES_OK(context, train_step_status.value);\n}\n\n}  // namespace\n\nclass SdcaOptimizer : public OpKernel {\n public:\n  explicit SdcaOptimizer(OpKernelConstruction* const context)\n      : OpKernel(context), options_(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    DoCompute(options_, context);\n  }\n\n private:\n  // TODO(sibyl-Aix6ihai): We could use the type-constraint on loss_type, and\n  // template the entire class to avoid the virtual table lookup penalty in\n  // the inner loop.\n  ComputeOptions options_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"SdcaOptimizer\").Device(DEVICE_CPU),\n                        SdcaOptimizer);\nREGISTER_KERNEL_BUILDER(Name(\"SdcaOptimizerV2\").Device(DEVICE_CPU),\n                        SdcaOptimizer);\n\nclass SdcaShrinkL1 : public OpKernel {\n public:\n  explicit SdcaShrinkL1(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, regularizations_.Initialize(context));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    OpMutableInputList weights_inputs;\n    OP_REQUIRES_OK(context,\n                   context->mutable_input_list(\"weights\", &weights_inputs));\n\n    auto do_work = [&](const int64_t begin, const int64_t end) {\n      for (int i = begin; i < end; ++i) {\n        auto prox_w = weights_inputs.at(i, /*lock_held=*/true).flat<float>();\n        prox_w.device(context->eigen_cpu_device()) =\n            regularizations_.EigenShrinkVector(prox_w);\n      }\n    };\n\n    if (weights_inputs.size() > 0) {\n      int64_t num_weights = 0;\n      for (int i = 0; i < weights_inputs.size(); ++i) {\n        num_weights += weights_inputs.at(i, /*lock_held=*/true).NumElements();\n      }\n      // TODO(sibyl-Aix6ihai): Tune this value.\n      const int64_t kCostPerUnit = (num_weights * 50) / weights_inputs.size();\n      const DeviceBase::CpuWorkerThreads& worker_threads =\n          *context->device()->tensorflow_cpu_worker_threads();\n      Shard(worker_threads.num_threads, worker_threads.workers,\n            weights_inputs.size(), kCostPerUnit, do_work);\n    }\n  }\n\n private:\n  Regularizations regularizations_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"SdcaShrinkL1\").Device(DEVICE_CPU), SdcaShrinkL1);\n\n// Computes platform independent, compact and unique (with very high\n// probability) representation of an example id. It shouldn't be put in\n// persistent storage, as its implementation may change in the future.\n//\n// The current probability of at least one collision for 1B example_ids is\n// approximately 10^-21 (ie 2^60 / 2^129).\nclass SdcaFprint : public OpKernel {\n public:\n  explicit SdcaFprint(OpKernelConstruction* const context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input.shape()),\n                errors::InvalidArgument(\"Input must be a vector, got shape \",\n                                        input.shape().DebugString()));\n    Tensor* out;\n    const int64_t num_elements = input.NumElements();\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, TensorShape({num_elements, 2}), &out));\n\n    const auto in_values = input.flat<tstring>();\n    auto out_values = out->matrix<int64_t>();\n\n    for (int64_t i = 0; i < num_elements; ++i) {\n      const Fprint128 fprint = Fingerprint128(in_values(i));\n      // Never return 0 or 1 as the first value of the hash to allow these to\n      // safely be used as sentinel values (e.g. dense hash table empty key).\n      out_values(i, 0) = TF_PREDICT_TRUE(fprint.low64 >= 2)\n                             ? fprint.low64\n                             : fprint.low64 + ~static_cast<uint64>(1);\n      out_values(i, 1) = fprint.high64;\n    }\n  }\n};\nREGISTER_KERNEL_BUILDER(Name(\"SdcaFprint\").Device(DEVICE_CPU), SdcaFprint);\n\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/sdca_internal.cc", "tensorflow/core/kernels/sdca_ops.cc"], "buggy_code_start_loc": [391, 51], "buggy_code_end_loc": [391, 144], "fixing_code_start_loc": [392, 52], "fixing_code_end_loc": [399, 150], "type": "CWE-20", "message": "TensorFlow is an open source platform for machine learning. Inputs `dense_features` or `example_state_data` not of rank 2 will trigger a `CHECK` fail in `SdcaOptimizer`. We have patched the issue in GitHub commit 80ff197d03db2a70c6a111f97dcdacad1b0babfa. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2022-41899", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-18T22:15:19.817", "lastModified": "2023-01-31T20:49:57.570", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. Inputs `dense_features` or `example_state_data` not of rank 2 will trigger a `CHECK` fail in `SdcaOptimizer`. We have patched the issue in GitHub commit 80ff197d03db2a70c6a111f97dcdacad1b0babfa. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.4", "matchCriteriaId": "A694EEE1-BFB9-4E6C-B275-02DC2731961C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.3", "matchCriteriaId": "9057B403-719C-4F10-BAB6-67F84786A89E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "6AE6CFC4-0232-4E1C-960D-268C87788735"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/sdca_internal.cc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/80ff197d03db2a70c6a111f97dcdacad1b0babfa", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-27rc-728f-x5w2", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/80ff197d03db2a70c6a111f97dcdacad1b0babfa"}}