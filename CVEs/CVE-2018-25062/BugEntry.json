{"buggy_code": ["/* xfrm_user.c: User interface to configure xfrm engine.\n *\n * Copyright (C) 2002 David S. Miller (davem@redhat.com)\n *\n * Changes:\n *\tMitsuru KANDA @USAGI\n * \tKazunori MIYAZAWA @USAGI\n * \tKunihiro Ishiguro <kunihiro@ipinfusion.com>\n * \t\tIPv6 support\n *\n */\n\n#include <linux/crypto.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/pfkeyv2.h>\n#include <linux/ipsec.h>\n#include <linux/init.h>\n#include <linux/security.h>\n#include <net/sock.h>\n#include <net/xfrm.h>\n#include <net/netlink.h>\n#include <net/ah.h>\n#include <asm/uaccess.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <linux/in6.h>\n#endif\n\nstatic inline int aead_len(struct xfrm_algo_aead *alg)\n{\n\treturn sizeof(*alg) + ((alg->alg_key_len + 7) / 8);\n}\n\nstatic int verify_one_alg(struct nlattr **attrs, enum xfrm_attr_type_t type)\n{\n\tstruct nlattr *rt = attrs[type];\n\tstruct xfrm_algo *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < xfrm_alg_len(algp))\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase XFRMA_ALG_AUTH:\n\tcase XFRMA_ALG_CRYPT:\n\tcase XFRMA_ALG_COMP:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}\n\nstatic int verify_auth_trunc(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_ALG_AUTH_TRUNC];\n\tstruct xfrm_algo_auth *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < xfrm_alg_auth_len(algp))\n\t\treturn -EINVAL;\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}\n\nstatic int verify_aead(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_ALG_AEAD];\n\tstruct xfrm_algo_aead *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < aead_len(algp))\n\t\treturn -EINVAL;\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}\n\nstatic void verify_one_addr(struct nlattr **attrs, enum xfrm_attr_type_t type,\n\t\t\t   xfrm_address_t **addrp)\n{\n\tstruct nlattr *rt = attrs[type];\n\n\tif (rt && addrp)\n\t\t*addrp = nla_data(rt);\n}\n\nstatic inline int verify_sec_ctx_len(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\tstruct xfrm_user_sec_ctx *uctx;\n\n\tif (!rt)\n\t\treturn 0;\n\n\tuctx = nla_data(rt);\n\tif (uctx->len != (sizeof(struct xfrm_user_sec_ctx) + uctx->ctx_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline int verify_replay(struct xfrm_usersa_info *p,\n\t\t\t\tstruct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];\n\tstruct xfrm_replay_state_esn *rs;\n\n\tif (p->flags & XFRM_STATE_ESN) {\n\t\tif (!rt)\n\t\t\treturn -EINVAL;\n\n\t\trs = nla_data(rt);\n\n\t\tif (rs->bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof(rs->bmp[0]) / 8)\n\t\t\treturn -EINVAL;\n\n\t\tif (nla_len(rt) < xfrm_replay_state_esn_len(rs) &&\n\t\t    nla_len(rt) != sizeof(*rs))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rt)\n\t\treturn 0;\n\n\tif (p->id.proto != IPPROTO_ESP)\n\t\treturn -EINVAL;\n\n\tif (p->replay_window != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int verify_newsa_info(struct xfrm_usersa_info *p,\n\t\t\t     struct nlattr **attrs)\n{\n\tint err;\n\n\terr = -EINVAL;\n\tswitch (p->family) {\n\tcase AF_INET:\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tbreak;\n#else\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto out;\n#endif\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = -EINVAL;\n\tswitch (p->id.proto) {\n\tcase IPPROTO_AH:\n\t\tif ((!attrs[XFRMA_ALG_AUTH]\t&&\n\t\t     !attrs[XFRMA_ALG_AUTH_TRUNC]) ||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_TFCPAD])\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IPPROTO_ESP:\n\t\tif (attrs[XFRMA_ALG_COMP])\n\t\t\tgoto out;\n\t\tif (!attrs[XFRMA_ALG_AUTH] &&\n\t\t    !attrs[XFRMA_ALG_AUTH_TRUNC] &&\n\t\t    !attrs[XFRMA_ALG_CRYPT] &&\n\t\t    !attrs[XFRMA_ALG_AEAD])\n\t\t\tgoto out;\n\t\tif ((attrs[XFRMA_ALG_AUTH] ||\n\t\t     attrs[XFRMA_ALG_AUTH_TRUNC] ||\n\t\t     attrs[XFRMA_ALG_CRYPT]) &&\n\t\t    attrs[XFRMA_ALG_AEAD])\n\t\t\tgoto out;\n\t\tif (attrs[XFRMA_TFCPAD] &&\n\t\t    p->mode != XFRM_MODE_TUNNEL)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IPPROTO_COMP:\n\t\tif (!attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_AUTH]\t||\n\t\t    attrs[XFRMA_ALG_AUTH_TRUNC]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_TFCPAD])\n\t\t\tgoto out;\n\t\tbreak;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase IPPROTO_DSTOPTS:\n\tcase IPPROTO_ROUTING:\n\t\tif (attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_ALG_AUTH]\t||\n\t\t    attrs[XFRMA_ALG_AUTH_TRUNC]\t||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_ENCAP]\t\t||\n\t\t    attrs[XFRMA_SEC_CTX]\t||\n\t\t    attrs[XFRMA_TFCPAD]\t\t||\n\t\t    !attrs[XFRMA_COADDR])\n\t\t\tgoto out;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif ((err = verify_aead(attrs)))\n\t\tgoto out;\n\tif ((err = verify_auth_trunc(attrs)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_AUTH)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_CRYPT)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_COMP)))\n\t\tgoto out;\n\tif ((err = verify_sec_ctx_len(attrs)))\n\t\tgoto out;\n\tif ((err = verify_replay(p, attrs)))\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tswitch (p->mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\tcase XFRM_MODE_TUNNEL:\n\tcase XFRM_MODE_ROUTEOPTIMIZATION:\n\tcase XFRM_MODE_BEET:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\nout:\n\treturn err;\n}\n\nstatic int attach_one_algo(struct xfrm_algo **algpp, u8 *props,\n\t\t\t   struct xfrm_algo_desc *(*get_byname)(const char *, int),\n\t\t\t   struct nlattr *rta)\n{\n\tstruct xfrm_algo *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, xfrm_alg_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic int attach_auth(struct xfrm_algo_auth **algpp, u8 *props,\n\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_algo *ualg;\n\tstruct xfrm_algo_auth *p;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_aalg_get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmalloc(sizeof(*p) + (ualg->alg_key_len + 7) / 8, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\tp->alg_key_len = ualg->alg_key_len;\n\tp->alg_trunc_len = algo->uinfo.auth.icv_truncbits;\n\tmemcpy(p->alg_key, ualg->alg_key, (ualg->alg_key_len + 7) / 8);\n\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic int attach_auth_trunc(struct xfrm_algo_auth **algpp, u8 *props,\n\t\t\t     struct nlattr *rta)\n{\n\tstruct xfrm_algo_auth *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_aalg_get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\tif ((ualg->alg_trunc_len / 8) > MAX_AH_AUTH_LEN ||\n\t    ualg->alg_trunc_len > algo->uinfo.auth.icv_fullbits)\n\t\treturn -EINVAL;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, xfrm_alg_auth_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\tif (!p->alg_trunc_len)\n\t\tp->alg_trunc_len = algo->uinfo.auth.icv_truncbits;\n\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic int attach_aead(struct xfrm_algo_aead **algpp, u8 *props,\n\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_algo_aead *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_aead_get_byname(ualg->alg_name, ualg->alg_icv_len, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, aead_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\n\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn,\n\t\t\t\t       struct xfrm_replay_state_esn **preplay_esn,\n\t\t\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_replay_state_esn *p, *pp, *up;\n\tint klen, ulen;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tup = nla_data(rta);\n\tklen = xfrm_replay_state_esn_len(up);\n\tulen = nla_len(rta) >= klen ? klen : sizeof(*up);\n\n\tp = kzalloc(klen, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpp = kzalloc(klen, GFP_KERNEL);\n\tif (!pp) {\n\t\tkfree(p);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(p, up, ulen);\n\tmemcpy(pp, up, ulen);\n\n\t*replay_esn = p;\n\t*preplay_esn = pp;\n\n\treturn 0;\n}\n\nstatic inline int xfrm_user_sec_ctx_size(struct xfrm_sec_ctx *xfrm_ctx)\n{\n\tint len = 0;\n\n\tif (xfrm_ctx) {\n\t\tlen += sizeof(struct xfrm_user_sec_ctx);\n\t\tlen += xfrm_ctx->ctx_len;\n\t}\n\treturn len;\n}\n\nstatic void copy_from_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemcpy(&x->id, &p->id, sizeof(x->id));\n\tmemcpy(&x->sel, &p->sel, sizeof(x->sel));\n\tmemcpy(&x->lft, &p->lft, sizeof(x->lft));\n\tx->props.mode = p->mode;\n\tx->props.replay_window = p->replay_window;\n\tx->props.reqid = p->reqid;\n\tx->props.family = p->family;\n\tmemcpy(&x->props.saddr, &p->saddr, sizeof(x->props.saddr));\n\tx->props.flags = p->flags;\n\n\tif (!x->sel.family && !(p->flags & XFRM_STATE_AF_UNSPEC))\n\t\tx->sel.family = p->family;\n}\n\n/*\n * someday when pfkey also has support, we could have the code\n * somehow made shareable and move it to xfrm_state.c - JHS\n *\n*/\nstatic void xfrm_update_ae_params(struct xfrm_state *x, struct nlattr **attrs,\n\t\t\t\t  int update_esn)\n{\n\tstruct nlattr *rp = attrs[XFRMA_REPLAY_VAL];\n\tstruct nlattr *re = update_esn ? attrs[XFRMA_REPLAY_ESN_VAL] : NULL;\n\tstruct nlattr *lt = attrs[XFRMA_LTIME_VAL];\n\tstruct nlattr *et = attrs[XFRMA_ETIMER_THRESH];\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_THRESH];\n\n\tif (re) {\n\t\tstruct xfrm_replay_state_esn *replay_esn;\n\t\treplay_esn = nla_data(re);\n\t\tmemcpy(x->replay_esn, replay_esn,\n\t\t       xfrm_replay_state_esn_len(replay_esn));\n\t\tmemcpy(x->preplay_esn, replay_esn,\n\t\t       xfrm_replay_state_esn_len(replay_esn));\n\t}\n\n\tif (rp) {\n\t\tstruct xfrm_replay_state *replay;\n\t\treplay = nla_data(rp);\n\t\tmemcpy(&x->replay, replay, sizeof(*replay));\n\t\tmemcpy(&x->preplay, replay, sizeof(*replay));\n\t}\n\n\tif (lt) {\n\t\tstruct xfrm_lifetime_cur *ltime;\n\t\tltime = nla_data(lt);\n\t\tx->curlft.bytes = ltime->bytes;\n\t\tx->curlft.packets = ltime->packets;\n\t\tx->curlft.add_time = ltime->add_time;\n\t\tx->curlft.use_time = ltime->use_time;\n\t}\n\n\tif (et)\n\t\tx->replay_maxage = nla_get_u32(et);\n\n\tif (rt)\n\t\tx->replay_maxdiff = nla_get_u32(rt);\n}\n\nstatic struct xfrm_state *xfrm_state_construct(struct net *net,\n\t\t\t\t\t       struct xfrm_usersa_info *p,\n\t\t\t\t\t       struct nlattr **attrs,\n\t\t\t\t\t       int *errp)\n{\n\tstruct xfrm_state *x = xfrm_state_alloc(net);\n\tint err = -ENOMEM;\n\n\tif (!x)\n\t\tgoto error_no_put;\n\n\tcopy_from_user_state(x, p);\n\n\tif (attrs[XFRMA_SA_EXTRA_FLAGS])\n\t\tx->props.extra_flags = nla_get_u32(attrs[XFRMA_SA_EXTRA_FLAGS]);\n\n\tif ((err = attach_aead(&x->aead, &x->props.ealgo,\n\t\t\t       attrs[XFRMA_ALG_AEAD])))\n\t\tgoto error;\n\tif ((err = attach_auth_trunc(&x->aalg, &x->props.aalgo,\n\t\t\t\t     attrs[XFRMA_ALG_AUTH_TRUNC])))\n\t\tgoto error;\n\tif (!x->props.aalgo) {\n\t\tif ((err = attach_auth(&x->aalg, &x->props.aalgo,\n\t\t\t\t       attrs[XFRMA_ALG_AUTH])))\n\t\t\tgoto error;\n\t}\n\tif ((err = attach_one_algo(&x->ealg, &x->props.ealgo,\n\t\t\t\t   xfrm_ealg_get_byname,\n\t\t\t\t   attrs[XFRMA_ALG_CRYPT])))\n\t\tgoto error;\n\tif ((err = attach_one_algo(&x->calg, &x->props.calgo,\n\t\t\t\t   xfrm_calg_get_byname,\n\t\t\t\t   attrs[XFRMA_ALG_COMP])))\n\t\tgoto error;\n\n\tif (attrs[XFRMA_ENCAP]) {\n\t\tx->encap = kmemdup(nla_data(attrs[XFRMA_ENCAP]),\n\t\t\t\t   sizeof(*x->encap), GFP_KERNEL);\n\t\tif (x->encap == NULL)\n\t\t\tgoto error;\n\t}\n\n\tif (attrs[XFRMA_TFCPAD])\n\t\tx->tfcpad = nla_get_u32(attrs[XFRMA_TFCPAD]);\n\n\tif (attrs[XFRMA_COADDR]) {\n\t\tx->coaddr = kmemdup(nla_data(attrs[XFRMA_COADDR]),\n\t\t\t\t    sizeof(*x->coaddr), GFP_KERNEL);\n\t\tif (x->coaddr == NULL)\n\t\t\tgoto error;\n\t}\n\n\txfrm_mark_get(attrs, &x->mark);\n\n\tif (attrs[XFRMA_OUTPUT_MARK])\n\t\tx->props.output_mark = nla_get_u32(attrs[XFRMA_OUTPUT_MARK]);\n\n\terr = __xfrm_init_state(x, false);\n\tif (err)\n\t\tgoto error;\n\n\tif (attrs[XFRMA_SEC_CTX] &&\n\t    security_xfrm_state_alloc(x, nla_data(attrs[XFRMA_SEC_CTX])))\n\t\tgoto error;\n\n\tif ((err = xfrm_alloc_replay_state_esn(&x->replay_esn, &x->preplay_esn,\n\t\t\t\t\t       attrs[XFRMA_REPLAY_ESN_VAL])))\n\t\tgoto error;\n\n\tx->km.seq = p->seq;\n\tx->replay_maxdiff = net->xfrm.sysctl_aevent_rseqth;\n\t/* sysctl_xfrm_aevent_etime is in 100ms units */\n\tx->replay_maxage = (net->xfrm.sysctl_aevent_etime*HZ)/XFRM_AE_ETH_M;\n\n\tif ((err = xfrm_init_replay(x)))\n\t\tgoto error;\n\n\t/* override default values from above */\n\txfrm_update_ae_params(x, attrs, 0);\n\n\treturn x;\n\nerror:\n\tx->km.state = XFRM_STATE_DEAD;\n\txfrm_state_put(x);\nerror_no_put:\n\t*errp = err;\n\treturn NULL;\n}\n\nstatic int xfrm_add_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_usersa_info *p = nlmsg_data(nlh);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct km_event c;\n\tkuid_t loginuid = audit_get_loginuid(current);\n\tu32 sessionid = audit_get_sessionid(current);\n\tu32 sid;\n\n\terr = verify_newsa_info(p, attrs);\n\tif (err)\n\t\treturn err;\n\n\tx = xfrm_state_construct(net, p, attrs, &err);\n\tif (!x)\n\t\treturn err;\n\n\txfrm_state_hold(x);\n\tif (nlh->nlmsg_type == XFRM_MSG_NEWSA)\n\t\terr = xfrm_state_add(x);\n\telse\n\t\terr = xfrm_state_update(x);\n\n\tsecurity_task_getsecid(current, &sid);\n\txfrm_audit_state_add(x, err ? 0 : 1, loginuid, sessionid, sid);\n\n\tif (err < 0) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t\tgoto out;\n\t}\n\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.event = nlh->nlmsg_type;\n\n\tkm_state_notify(x, &c);\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic struct xfrm_state *xfrm_user_state_lookup(struct net *net,\n\t\t\t\t\t\t struct xfrm_usersa_id *p,\n\t\t\t\t\t\t struct nlattr **attrs,\n\t\t\t\t\t\t int *errp)\n{\n\tstruct xfrm_state *x = NULL;\n\tstruct xfrm_mark m;\n\tint err;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tif (xfrm_id_proto_match(p->proto, IPSEC_PROTO_ANY)) {\n\t\terr = -ESRCH;\n\t\tx = xfrm_state_lookup(net, mark, &p->daddr, p->spi, p->proto, p->family);\n\t} else {\n\t\txfrm_address_t *saddr = NULL;\n\n\t\tverify_one_addr(attrs, XFRMA_SRCADDR, &saddr);\n\t\tif (!saddr) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -ESRCH;\n\t\tx = xfrm_state_lookup_byaddr(net, mark,\n\t\t\t\t\t     &p->daddr, saddr,\n\t\t\t\t\t     p->proto, p->family);\n\t}\n\n out:\n\tif (!x && errp)\n\t\t*errp = err;\n\treturn x;\n}\n\nstatic int xfrm_del_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tint err = -ESRCH;\n\tstruct km_event c;\n\tstruct xfrm_usersa_id *p = nlmsg_data(nlh);\n\tkuid_t loginuid = audit_get_loginuid(current);\n\tu32 sessionid = audit_get_sessionid(current);\n\tu32 sid;\n\n\tx = xfrm_user_state_lookup(net, p, attrs, &err);\n\tif (x == NULL)\n\t\treturn err;\n\n\tif ((err = security_xfrm_state_delete(x)) != 0)\n\t\tgoto out;\n\n\tif (xfrm_state_kern(x)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = xfrm_state_delete(x);\n\n\tif (err < 0)\n\t\tgoto out;\n\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.event = nlh->nlmsg_type;\n\tkm_state_notify(x, &c);\n\nout:\n\tsecurity_task_getsecid(current, &sid);\n\txfrm_audit_state_delete(x, err ? 0 : 1, loginuid, sessionid, sid);\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->id, &x->id, sizeof(p->id));\n\tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n\tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}\n\nstruct xfrm_dump_info {\n\tstruct sk_buff *in_skb;\n\tstruct sk_buff *out_skb;\n\tu32 nlmsg_seq;\n\tu16 nlmsg_flags;\n};\n\nstatic int copy_sec_ctx(struct xfrm_sec_ctx *s, struct sk_buff *skb)\n{\n\tstruct xfrm_user_sec_ctx *uctx;\n\tstruct nlattr *attr;\n\tint ctx_size = sizeof(*uctx) + s->ctx_len;\n\n\tattr = nla_reserve(skb, XFRMA_SEC_CTX, ctx_size);\n\tif (attr == NULL)\n\t\treturn -EMSGSIZE;\n\n\tuctx = nla_data(attr);\n\tuctx->exttype = XFRMA_SEC_CTX;\n\tuctx->len = ctx_size;\n\tuctx->ctx_doi = s->ctx_doi;\n\tuctx->ctx_alg = s->ctx_alg;\n\tuctx->ctx_len = s->ctx_len;\n\tmemcpy(uctx + 1, s->ctx_str, s->ctx_len);\n\n\treturn 0;\n}\n\nstatic int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\talgo = nla_data(nla);\n\tstrncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\n\treturn 0;\n}\n\n/* Don't change this without updating xfrm_sa_len! */\nstatic int copy_to_user_state_extra(struct xfrm_state *x,\n\t\t\t\t    struct xfrm_usersa_info *p,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tint ret = 0;\n\n\tcopy_to_user_state(x, p);\n\n\tif (x->props.extra_flags) {\n\t\tret = nla_put_u32(skb, XFRMA_SA_EXTRA_FLAGS,\n\t\t\t\t  x->props.extra_flags);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (x->coaddr) {\n\t\tret = nla_put(skb, XFRMA_COADDR, sizeof(*x->coaddr), x->coaddr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->lastused) {\n\t\tret = nla_put_u64(skb, XFRMA_LASTUSED, x->lastused);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->aead) {\n\t\tret = nla_put(skb, XFRMA_ALG_AEAD, aead_len(x->aead), x->aead);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->aalg) {\n\t\tret = copy_to_user_auth(x->aalg, skb);\n\t\tif (!ret)\n\t\t\tret = nla_put(skb, XFRMA_ALG_AUTH_TRUNC,\n\t\t\t\t      xfrm_alg_auth_len(x->aalg), x->aalg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->ealg) {\n\t\tret = nla_put(skb, XFRMA_ALG_CRYPT, xfrm_alg_len(x->ealg), x->ealg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->calg) {\n\t\tret = nla_put(skb, XFRMA_ALG_COMP, sizeof(*(x->calg)), x->calg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->encap) {\n\t\tret = nla_put(skb, XFRMA_ENCAP, sizeof(*x->encap), x->encap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->tfcpad) {\n\t\tret = nla_put_u32(skb, XFRMA_TFCPAD, x->tfcpad);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tret = xfrm_mark_put(skb, &x->mark);\n\tif (ret)\n\t\tgoto out;\n\tif (x->replay_esn) {\n\t\tret = nla_put(skb, XFRMA_REPLAY_ESN_VAL,\n\t\t\t      xfrm_replay_state_esn_len(x->replay_esn),\n\t\t\t      x->replay_esn);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->security)\n\t\tret = copy_sec_ctx(x->security, skb);\n\tif (x->props.output_mark) {\n\t\tret = nla_put_u32(skb, XFRMA_OUTPUT_MARK, x->props.output_mark);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int dump_one_state(struct xfrm_state *x, int count, void *ptr)\n{\n\tstruct xfrm_dump_info *sp = ptr;\n\tstruct sk_buff *in_skb = sp->in_skb;\n\tstruct sk_buff *skb = sp->out_skb;\n\tstruct xfrm_usersa_info *p;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, sp->nlmsg_seq,\n\t\t\tXFRM_MSG_NEWSA, sizeof(*p), sp->nlmsg_flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tp = nlmsg_data(nlh);\n\n\terr = copy_to_user_state_extra(x, p, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\txfrm_state_walk_done(walk);\n\treturn 0;\n}\n\nstatic int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_state_walk_init(walk, 0);\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}\n\nstatic struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_state *x, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = dump_one_state(x, 0, &info);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic inline size_t xfrm_spdinfo_msgsize(void)\n{\n\treturn NLMSG_ALIGN(4)\n\t       + nla_total_size(sizeof(struct xfrmu_spdinfo))\n\t       + nla_total_size(sizeof(struct xfrmu_spdhinfo));\n}\n\nstatic int build_spdinfo(struct sk_buff *skb, struct net *net,\n\t\t\t u32 portid, u32 seq, u32 flags)\n{\n\tstruct xfrmk_spdinfo si;\n\tstruct xfrmu_spdinfo spc;\n\tstruct xfrmu_spdhinfo sph;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\tu32 *f;\n\n\tnlh = nlmsg_put(skb, portid, seq, XFRM_MSG_NEWSPDINFO, sizeof(u32), 0);\n\tif (nlh == NULL) /* shouldn't really happen ... */\n\t\treturn -EMSGSIZE;\n\n\tf = nlmsg_data(nlh);\n\t*f = flags;\n\txfrm_spd_getinfo(net, &si);\n\tspc.incnt = si.incnt;\n\tspc.outcnt = si.outcnt;\n\tspc.fwdcnt = si.fwdcnt;\n\tspc.inscnt = si.inscnt;\n\tspc.outscnt = si.outscnt;\n\tspc.fwdscnt = si.fwdscnt;\n\tsph.spdhcnt = si.spdhcnt;\n\tsph.spdhmcnt = si.spdhmcnt;\n\n\terr = nla_put(skb, XFRMA_SPD_INFO, sizeof(spc), &spc);\n\tif (!err)\n\t\terr = nla_put(skb, XFRMA_SPD_HINFO, sizeof(sph), &sph);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_get_spdinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct sk_buff *r_skb;\n\tu32 *flags = nlmsg_data(nlh);\n\tu32 sportid = NETLINK_CB(skb).portid;\n\tu32 seq = nlh->nlmsg_seq;\n\n\tr_skb = nlmsg_new(xfrm_spdinfo_msgsize(), GFP_ATOMIC);\n\tif (r_skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_spdinfo(r_skb, net, sportid, seq, *flags) < 0)\n\t\tBUG();\n\n\treturn nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid);\n}\n\nstatic inline size_t xfrm_sadinfo_msgsize(void)\n{\n\treturn NLMSG_ALIGN(4)\n\t       + nla_total_size(sizeof(struct xfrmu_sadhinfo))\n\t       + nla_total_size(4); /* XFRMA_SAD_CNT */\n}\n\nstatic int build_sadinfo(struct sk_buff *skb, struct net *net,\n\t\t\t u32 portid, u32 seq, u32 flags)\n{\n\tstruct xfrmk_sadinfo si;\n\tstruct xfrmu_sadhinfo sh;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\tu32 *f;\n\n\tnlh = nlmsg_put(skb, portid, seq, XFRM_MSG_NEWSADINFO, sizeof(u32), 0);\n\tif (nlh == NULL) /* shouldn't really happen ... */\n\t\treturn -EMSGSIZE;\n\n\tf = nlmsg_data(nlh);\n\t*f = flags;\n\txfrm_sad_getinfo(net, &si);\n\n\tsh.sadhmcnt = si.sadhmcnt;\n\tsh.sadhcnt = si.sadhcnt;\n\n\terr = nla_put_u32(skb, XFRMA_SAD_CNT, si.sadcnt);\n\tif (!err)\n\t\terr = nla_put(skb, XFRMA_SAD_HINFO, sizeof(sh), &sh);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_get_sadinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct sk_buff *r_skb;\n\tu32 *flags = nlmsg_data(nlh);\n\tu32 sportid = NETLINK_CB(skb).portid;\n\tu32 seq = nlh->nlmsg_seq;\n\n\tr_skb = nlmsg_new(xfrm_sadinfo_msgsize(), GFP_ATOMIC);\n\tif (r_skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_sadinfo(r_skb, net, sportid, seq, *flags) < 0)\n\t\tBUG();\n\n\treturn nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid);\n}\n\nstatic int xfrm_get_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_usersa_id *p = nlmsg_data(nlh);\n\tstruct xfrm_state *x;\n\tstruct sk_buff *resp_skb;\n\tint err = -ESRCH;\n\n\tx = xfrm_user_state_lookup(net, p, attrs, &err);\n\tif (x == NULL)\n\t\tgoto out_noput;\n\n\tresp_skb = xfrm_state_netlink(skb, x, nlh->nlmsg_seq);\n\tif (IS_ERR(resp_skb)) {\n\t\terr = PTR_ERR(resp_skb);\n\t} else {\n\t\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);\n\t}\n\txfrm_state_put(x);\nout_noput:\n\treturn err;\n}\n\nstatic int verify_userspi_info(struct xfrm_userspi_info *p)\n{\n\tswitch (p->info.id.proto) {\n\tcase IPPROTO_AH:\n\tcase IPPROTO_ESP:\n\t\tbreak;\n\n\tcase IPPROTO_COMP:\n\t\t/* IPCOMP spi is 16-bits. */\n\t\tif (p->max >= 0x10000)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (p->min > p->max)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int xfrm_alloc_userspi(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tstruct xfrm_userspi_info *p;\n\tstruct sk_buff *resp_skb;\n\txfrm_address_t *daddr;\n\tint family;\n\tint err;\n\tu32 mark;\n\tstruct xfrm_mark m;\n\n\tp = nlmsg_data(nlh);\n\terr = verify_userspi_info(p);\n\tif (err)\n\t\tgoto out_noput;\n\n\tfamily = p->info.family;\n\tdaddr = &p->info.id.daddr;\n\n\tx = NULL;\n\n\tmark = xfrm_mark_get(attrs, &m);\n\tif (p->info.seq) {\n\t\tx = xfrm_find_acq_byseq(net, mark, p->info.seq);\n\t\tif (x && !xfrm_addr_equal(&x->id.daddr, daddr, family)) {\n\t\t\txfrm_state_put(x);\n\t\t\tx = NULL;\n\t\t}\n\t}\n\n\tif (!x)\n\t\tx = xfrm_find_acq(net, &m, p->info.mode, p->info.reqid,\n\t\t\t\t  p->info.id.proto, daddr,\n\t\t\t\t  &p->info.saddr, 1,\n\t\t\t\t  family);\n\terr = -ENOENT;\n\tif (x == NULL)\n\t\tgoto out_noput;\n\n\terr = xfrm_alloc_spi(x, p->min, p->max);\n\tif (err)\n\t\tgoto out;\n\n\tresp_skb = xfrm_state_netlink(skb, x, nlh->nlmsg_seq);\n\tif (IS_ERR(resp_skb)) {\n\t\terr = PTR_ERR(resp_skb);\n\t\tgoto out;\n\t}\n\n\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);\n\nout:\n\txfrm_state_put(x);\nout_noput:\n\treturn err;\n}\n\nstatic int verify_policy_dir(u8 dir)\n{\n\tswitch (dir) {\n\tcase XFRM_POLICY_IN:\n\tcase XFRM_POLICY_OUT:\n\tcase XFRM_POLICY_FWD:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int verify_policy_type(u8 type)\n{\n\tswitch (type) {\n\tcase XFRM_POLICY_TYPE_MAIN:\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tcase XFRM_POLICY_TYPE_SUB:\n#endif\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn verify_policy_dir(p->dir);\n}\n\nstatic int copy_from_user_sec_ctx(struct xfrm_policy *pol, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\tstruct xfrm_user_sec_ctx *uctx;\n\n\tif (!rt)\n\t\treturn 0;\n\n\tuctx = nla_data(rt);\n\treturn security_xfrm_policy_alloc(&pol->security, uctx);\n}\n\nstatic void copy_templates(struct xfrm_policy *xp, struct xfrm_user_tmpl *ut,\n\t\t\t   int nr)\n{\n\tint i;\n\n\txp->xfrm_nr = nr;\n\tfor (i = 0; i < nr; i++, ut++) {\n\t\tstruct xfrm_tmpl *t = &xp->xfrm_vec[i];\n\n\t\tmemcpy(&t->id, &ut->id, sizeof(struct xfrm_id));\n\t\tmemcpy(&t->saddr, &ut->saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tt->reqid = ut->reqid;\n\t\tt->mode = ut->mode;\n\t\tt->share = ut->share;\n\t\tt->optional = ut->optional;\n\t\tt->aalgos = ut->aalgos;\n\t\tt->ealgos = ut->ealgos;\n\t\tt->calgos = ut->calgos;\n\t\t/* If all masks are ~0, then we allow all algorithms. */\n\t\tt->allalgs = !~(t->aalgos & t->ealgos & t->calgos);\n\t\tt->encap_family = ut->family;\n\t}\n}\n\nstatic int validate_tmpl(int nr, struct xfrm_user_tmpl *ut, u16 family)\n{\n\tint i;\n\n\tif (nr > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nr; i++) {\n\t\t/* We never validated the ut->family value, so many\n\t\t * applications simply leave it at zero.  The check was\n\t\t * never made and ut->family was ignored because all\n\t\t * templates could be assumed to have the same family as\n\t\t * the policy itself.  Now that we will have ipv4-in-ipv6\n\t\t * and ipv6-in-ipv4 tunnels, this is no longer true.\n\t\t */\n\t\tif (!ut[i].family)\n\t\t\tut[i].family = family;\n\n\t\tswitch (ut[i].family) {\n\t\tcase AF_INET:\n\t\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase AF_INET6:\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int copy_from_user_tmpl(struct xfrm_policy *pol, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_TMPL];\n\n\tif (!rt) {\n\t\tpol->xfrm_nr = 0;\n\t} else {\n\t\tstruct xfrm_user_tmpl *utmpl = nla_data(rt);\n\t\tint nr = nla_len(rt) / sizeof(*utmpl);\n\t\tint err;\n\n\t\terr = validate_tmpl(nr, utmpl, pol->family);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcopy_templates(pol, utmpl, nr);\n\t}\n\treturn 0;\n}\n\nstatic int copy_from_user_policy_type(u8 *tp, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_POLICY_TYPE];\n\tstruct xfrm_userpolicy_type *upt;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\n\tif (rt) {\n\t\tupt = nla_data(rt);\n\t\ttype = upt->type;\n\t}\n\n\terr = verify_policy_type(type);\n\tif (err)\n\t\treturn err;\n\n\t*tp = type;\n\treturn 0;\n}\n\nstatic void copy_from_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p)\n{\n\txp->priority = p->priority;\n\txp->index = p->index;\n\tmemcpy(&xp->selector, &p->sel, sizeof(xp->selector));\n\tmemcpy(&xp->lft, &p->lft, sizeof(xp->lft));\n\txp->action = p->action;\n\txp->flags = p->flags;\n\txp->family = p->sel.family;\n\t/* XXX xp->share = p->share; */\n}\n\nstatic void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n\tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; /* XXX xp->share */\n}\n\nstatic struct xfrm_policy *xfrm_policy_construct(struct net *net, struct xfrm_userpolicy_info *p, struct nlattr **attrs, int *errp)\n{\n\tstruct xfrm_policy *xp = xfrm_policy_alloc(net, GFP_KERNEL);\n\tint err;\n\n\tif (!xp) {\n\t\t*errp = -ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tcopy_from_user_policy(xp, p);\n\n\terr = copy_from_user_policy_type(&xp->type, attrs);\n\tif (err)\n\t\tgoto error;\n\n\tif (!(err = copy_from_user_tmpl(xp, attrs)))\n\t\terr = copy_from_user_sec_ctx(xp, attrs);\n\tif (err)\n\t\tgoto error;\n\n\txfrm_mark_get(attrs, &xp->mark);\n\n\treturn xp;\n error:\n\t*errp = err;\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn NULL;\n}\n\nstatic int xfrm_add_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_userpolicy_info *p = nlmsg_data(nlh);\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\tint err;\n\tint excl;\n\tkuid_t loginuid = audit_get_loginuid(current);\n\tu32 sessionid = audit_get_sessionid(current);\n\tu32 sid;\n\n\terr = verify_newpolicy_info(p);\n\tif (err)\n\t\treturn err;\n\terr = verify_sec_ctx_len(attrs);\n\tif (err)\n\t\treturn err;\n\n\txp = xfrm_policy_construct(net, p, attrs, &err);\n\tif (!xp)\n\t\treturn err;\n\n\t/* shouldn't excl be based on nlh flags??\n\t * Aha! this is anti-netlink really i.e  more pfkey derived\n\t * in netlink excl is a flag and you wouldnt need\n\t * a type XFRM_MSG_UPDPOLICY - JHS */\n\texcl = nlh->nlmsg_type == XFRM_MSG_NEWPOLICY;\n\terr = xfrm_policy_insert(p->dir, xp, excl);\n\tsecurity_task_getsecid(current, &sid);\n\txfrm_audit_policy_add(xp, err ? 0 : 1, loginuid, sessionid, sid);\n\n\tif (err) {\n\t\tsecurity_xfrm_policy_free(xp->security);\n\t\tkfree(xp);\n\t\treturn err;\n\t}\n\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tkm_policy_notify(xp, p->dir, &c);\n\n\txfrm_pol_put(xp);\n\n\treturn 0;\n}\n\nstatic int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\n\t\tmemset(up, 0, sizeof(*up));\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}\n\nstatic inline int copy_to_user_state_sec_ctx(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tif (x->security) {\n\t\treturn copy_sec_ctx(x->security, skb);\n\t}\n\treturn 0;\n}\n\nstatic inline int copy_to_user_sec_ctx(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tif (xp->security)\n\t\treturn copy_sec_ctx(xp->security, skb);\n\treturn 0;\n}\nstatic inline size_t userpolicy_type_attrsize(void)\n{\n#ifdef CONFIG_XFRM_SUB_POLICY\n\treturn nla_total_size(sizeof(struct xfrm_userpolicy_type));\n#else\n\treturn 0;\n#endif\n}\n\n#ifdef CONFIG_XFRM_SUB_POLICY\nstatic int copy_to_user_policy_type(u8 type, struct sk_buff *skb)\n{\n\tstruct xfrm_userpolicy_type upt = {\n\t\t.type = type,\n\t};\n\n\treturn nla_put(skb, XFRMA_POLICY_TYPE, sizeof(upt), &upt);\n}\n\n#else\nstatic inline int copy_to_user_policy_type(u8 type, struct sk_buff *skb)\n{\n\treturn 0;\n}\n#endif\n\nstatic int dump_one_policy(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tstruct xfrm_dump_info *sp = ptr;\n\tstruct xfrm_userpolicy_info *p;\n\tstruct sk_buff *in_skb = sp->in_skb;\n\tstruct sk_buff *skb = sp->out_skb;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, sp->nlmsg_seq,\n\t\t\tXFRM_MSG_NEWPOLICY, sizeof(*p), sp->nlmsg_flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tp = nlmsg_data(nlh);\n\tcopy_to_user_policy(xp, p, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_sec_ctx(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\n\txfrm_policy_walk_done(walk);\n\treturn 0;\n}\n\nstatic int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\n\treturn skb->len;\n}\n\nstatic struct sk_buff *xfrm_policy_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_policy *xp,\n\t\t\t\t\t  int dir, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tint err;\n\n\terr = verify_policy_dir(dir);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = dump_one_policy(xp, dir, 0, &info);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic int xfrm_get_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_userpolicy_id *p;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\tstruct km_event c;\n\tint delete;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tp = nlmsg_data(nlh);\n\tdelete = nlh->nlmsg_type == XFRM_MSG_DELPOLICY;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_policy_dir(p->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (p->index)\n\t\txp = xfrm_policy_byid(net, mark, type, p->dir, p->index, delete, &err);\n\telse {\n\t\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\t\tstruct xfrm_sec_ctx *ctx;\n\n\t\terr = verify_sec_ctx_len(attrs);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tctx = NULL;\n\t\tif (rt) {\n\t\t\tstruct xfrm_user_sec_ctx *uctx = nla_data(rt);\n\n\t\t\terr = security_xfrm_policy_alloc(&ctx, uctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\txp = xfrm_policy_bysel_ctx(net, mark, type, p->dir, &p->sel,\n\t\t\t\t\t   ctx, delete, &err);\n\t\tsecurity_xfrm_policy_free(ctx);\n\t}\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (!delete) {\n\t\tstruct sk_buff *resp_skb;\n\n\t\tresp_skb = xfrm_policy_netlink(skb, xp, p->dir, nlh->nlmsg_seq);\n\t\tif (IS_ERR(resp_skb)) {\n\t\t\terr = PTR_ERR(resp_skb);\n\t\t} else {\n\t\t\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb,\n\t\t\t\t\t    NETLINK_CB(skb).portid);\n\t\t}\n\t} else {\n\t\tkuid_t loginuid = audit_get_loginuid(current);\n\t\tu32 sessionid = audit_get_sessionid(current);\n\t\tu32 sid;\n\n\t\tsecurity_task_getsecid(current, &sid);\n\t\txfrm_audit_policy_delete(xp, err ? 0 : 1, loginuid, sessionid,\n\t\t\t\t\t sid);\n\n\t\tif (err != 0)\n\t\t\tgoto out;\n\n\t\tc.data.byid = p->index;\n\t\tc.event = nlh->nlmsg_type;\n\t\tc.seq = nlh->nlmsg_seq;\n\t\tc.portid = nlh->nlmsg_pid;\n\t\tkm_policy_notify(xp, p->dir, &c);\n\t}\n\nout:\n\txfrm_pol_put(xp);\n\tif (delete && err == 0)\n\t\txfrm_garbage_collect(net);\n\treturn err;\n}\n\nstatic int xfrm_flush_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct km_event c;\n\tstruct xfrm_usersa_flush *p = nlmsg_data(nlh);\n\tstruct xfrm_audit audit_info;\n\tint err;\n\n\taudit_info.loginuid = audit_get_loginuid(current);\n\taudit_info.sessionid = audit_get_sessionid(current);\n\tsecurity_task_getsecid(current, &audit_info.secid);\n\terr = xfrm_state_flush(net, p->proto, &audit_info);\n\tif (err) {\n\t\tif (err == -ESRCH) /* empty table */\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tc.data.proto = p->proto;\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.net = net;\n\tkm_state_notify(NULL, &c);\n\n\treturn 0;\n}\n\nstatic inline size_t xfrm_aevent_msgsize(struct xfrm_state *x)\n{\n\tsize_t replay_size = x->replay_esn ?\n\t\t\t      xfrm_replay_state_esn_len(x->replay_esn) :\n\t\t\t      sizeof(struct xfrm_replay_state);\n\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_aevent_id))\n\t       + nla_total_size(replay_size)\n\t       + nla_total_size(sizeof(struct xfrm_lifetime_cur))\n\t       + nla_total_size(sizeof(struct xfrm_mark))\n\t       + nla_total_size(4) /* XFRM_AE_RTHR */\n\t       + nla_total_size(4); /* XFRM_AE_ETHR */\n}\n\nstatic int build_aevent(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct xfrm_aevent_id *id;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_NEWAE, sizeof(*id), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tid = nlmsg_data(nlh);\n\tmemcpy(&id->sa_id.daddr, &x->id.daddr,sizeof(x->id.daddr));\n\tid->sa_id.spi = x->id.spi;\n\tid->sa_id.family = x->props.family;\n\tid->sa_id.proto = x->id.proto;\n\tmemcpy(&id->saddr, &x->props.saddr,sizeof(x->props.saddr));\n\tid->reqid = x->props.reqid;\n\tid->flags = c->data.aevent;\n\n\tif (x->replay_esn) {\n\t\terr = nla_put(skb, XFRMA_REPLAY_ESN_VAL,\n\t\t\t      xfrm_replay_state_esn_len(x->replay_esn),\n\t\t\t      x->replay_esn);\n\t} else {\n\t\terr = nla_put(skb, XFRMA_REPLAY_VAL, sizeof(x->replay),\n\t\t\t      &x->replay);\n\t}\n\tif (err)\n\t\tgoto out_cancel;\n\terr = nla_put(skb, XFRMA_LTIME_VAL, sizeof(x->curlft), &x->curlft);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tif (id->flags & XFRM_AE_RTHR) {\n\t\terr = nla_put_u32(skb, XFRMA_REPLAY_THRESH, x->replay_maxdiff);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\tif (id->flags & XFRM_AE_ETHR) {\n\t\terr = nla_put_u32(skb, XFRMA_ETIMER_THRESH,\n\t\t\t\t  x->replay_maxage * 10 / HZ);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\terr = xfrm_mark_put(skb, &x->mark);\n\tif (err)\n\t\tgoto out_cancel;\n\n\treturn nlmsg_end(skb, nlh);\n\nout_cancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn err;\n}\n\nstatic int xfrm_get_ae(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tstruct sk_buff *r_skb;\n\tint err;\n\tstruct km_event c;\n\tu32 mark;\n\tstruct xfrm_mark m;\n\tstruct xfrm_aevent_id *p = nlmsg_data(nlh);\n\tstruct xfrm_usersa_id *id = &p->sa_id;\n\n\tmark = xfrm_mark_get(attrs, &m);\n\n\tx = xfrm_state_lookup(net, mark, &id->daddr, id->spi, id->proto, id->family);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tr_skb = nlmsg_new(xfrm_aevent_msgsize(x), GFP_ATOMIC);\n\tif (r_skb == NULL) {\n\t\txfrm_state_put(x);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * XXX: is this lock really needed - none of the other\n\t * gets lock (the concern is things getting updated\n\t * while we are still reading) - jhs\n\t*/\n\tspin_lock_bh(&x->lock);\n\tc.data.aevent = p->flags;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\n\tif (build_aevent(r_skb, x, &c) < 0)\n\t\tBUG();\n\terr = nlmsg_unicast(net->xfrm.nlsk, r_skb, NETLINK_CB(skb).portid);\n\tspin_unlock_bh(&x->lock);\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int xfrm_new_ae(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tstruct km_event c;\n\tint err = - EINVAL;\n\tu32 mark = 0;\n\tstruct xfrm_mark m;\n\tstruct xfrm_aevent_id *p = nlmsg_data(nlh);\n\tstruct nlattr *rp = attrs[XFRMA_REPLAY_VAL];\n\tstruct nlattr *re = attrs[XFRMA_REPLAY_ESN_VAL];\n\tstruct nlattr *lt = attrs[XFRMA_LTIME_VAL];\n\n\tif (!lt && !rp && !re)\n\t\treturn err;\n\n\t/* pedantic mode - thou shalt sayeth replaceth */\n\tif (!(nlh->nlmsg_flags&NLM_F_REPLACE))\n\t\treturn err;\n\n\tmark = xfrm_mark_get(attrs, &m);\n\n\tx = xfrm_state_lookup(net, mark, &p->sa_id.daddr, p->sa_id.spi, p->sa_id.proto, p->sa_id.family);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tif (x->km.state != XFRM_STATE_VALID)\n\t\tgoto out;\n\n\terr = xfrm_replay_verify_len(x->replay_esn, rp);\n\tif (err)\n\t\tgoto out;\n\n\tspin_lock_bh(&x->lock);\n\txfrm_update_ae_params(x, attrs, 1);\n\tspin_unlock_bh(&x->lock);\n\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.data.aevent = XFRM_AE_CU;\n\tkm_state_notify(x, &c);\n\terr = 0;\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int xfrm_flush_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct km_event c;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\tstruct xfrm_audit audit_info;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\taudit_info.loginuid = audit_get_loginuid(current);\n\taudit_info.sessionid = audit_get_sessionid(current);\n\tsecurity_task_getsecid(current, &audit_info.secid);\n\terr = xfrm_policy_flush(net, type, &audit_info);\n\tif (err) {\n\t\tif (err == -ESRCH) /* empty table */\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tc.data.type = type;\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.net = net;\n\tkm_policy_notify(NULL, 0, &c);\n\treturn 0;\n}\n\nstatic int xfrm_add_pol_expire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_user_polexpire *up = nlmsg_data(nlh);\n\tstruct xfrm_userpolicy_info *p = &up->pol;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err = -ENOENT;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_policy_dir(p->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (p->index)\n\t\txp = xfrm_policy_byid(net, mark, type, p->dir, p->index, 0, &err);\n\telse {\n\t\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\t\tstruct xfrm_sec_ctx *ctx;\n\n\t\terr = verify_sec_ctx_len(attrs);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tctx = NULL;\n\t\tif (rt) {\n\t\t\tstruct xfrm_user_sec_ctx *uctx = nla_data(rt);\n\n\t\t\terr = security_xfrm_policy_alloc(&ctx, uctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\txp = xfrm_policy_bysel_ctx(net, mark, type, p->dir,\n\t\t\t\t\t   &p->sel, ctx, 0, &err);\n\t\tsecurity_xfrm_policy_free(ctx);\n\t}\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (unlikely(xp->walk.dead))\n\t\tgoto out;\n\n\terr = 0;\n\tif (up->hard) {\n\t\tkuid_t loginuid = audit_get_loginuid(current);\n\t\tu32 sessionid = audit_get_sessionid(current);\n\t\tu32 sid;\n\n\t\tsecurity_task_getsecid(current, &sid);\n\t\txfrm_policy_delete(xp, p->dir);\n\t\txfrm_audit_policy_delete(xp, 1, loginuid, sessionid, sid);\n\n\t} else {\n\t\t// reset the timers here?\n\t\tWARN(1, \"Dont know what to do with soft policy expire\\n\");\n\t}\n\tkm_policy_expired(xp, p->dir, up->hard, nlh->nlmsg_pid);\n\nout:\n\txfrm_pol_put(xp);\n\treturn err;\n}\n\nstatic int xfrm_add_sa_expire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct xfrm_user_expire *ue = nlmsg_data(nlh);\n\tstruct xfrm_usersa_info *p = &ue->state;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tx = xfrm_state_lookup(net, mark, &p->id.daddr, p->id.spi, p->id.proto, p->family);\n\n\terr = -ENOENT;\n\tif (x == NULL)\n\t\treturn err;\n\n\tspin_lock_bh(&x->lock);\n\terr = -EINVAL;\n\tif (x->km.state != XFRM_STATE_VALID)\n\t\tgoto out;\n\tkm_state_expired(x, ue->hard, nlh->nlmsg_pid);\n\n\tif (ue->hard) {\n\t\tkuid_t loginuid = audit_get_loginuid(current);\n\t\tu32 sessionid = audit_get_sessionid(current);\n\t\tu32 sid;\n\n\t\tsecurity_task_getsecid(current, &sid);\n\t\t__xfrm_state_delete(x);\n\t\txfrm_audit_state_delete(x, 1, loginuid, sessionid, sid);\n\t}\n\terr = 0;\nout:\n\tspin_unlock_bh(&x->lock);\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int xfrm_add_acquire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_user_tmpl *ut;\n\tint i;\n\tstruct nlattr *rt = attrs[XFRMA_TMPL];\n\tstruct xfrm_mark mark;\n\n\tstruct xfrm_user_acquire *ua = nlmsg_data(nlh);\n\tstruct xfrm_state *x = xfrm_state_alloc(net);\n\tint err = -ENOMEM;\n\n\tif (!x)\n\t\tgoto nomem;\n\n\txfrm_mark_get(attrs, &mark);\n\n\terr = verify_newpolicy_info(&ua->policy);\n\tif (err)\n\t\tgoto bad_policy;\n\n\t/*   build an XP */\n\txp = xfrm_policy_construct(net, &ua->policy, attrs, &err);\n\tif (!xp)\n\t\tgoto free_state;\n\n\tmemcpy(&x->id, &ua->id, sizeof(ua->id));\n\tmemcpy(&x->props.saddr, &ua->saddr, sizeof(ua->saddr));\n\tmemcpy(&x->sel, &ua->sel, sizeof(ua->sel));\n\txp->mark.m = x->mark.m = mark.m;\n\txp->mark.v = x->mark.v = mark.v;\n\tut = nla_data(rt);\n\t/* extract the templates and for each call km_key */\n\tfor (i = 0; i < xp->xfrm_nr; i++, ut++) {\n\t\tstruct xfrm_tmpl *t = &xp->xfrm_vec[i];\n\t\tmemcpy(&x->id, &t->id, sizeof(x->id));\n\t\tx->props.mode = t->mode;\n\t\tx->props.reqid = t->reqid;\n\t\tx->props.family = ut->family;\n\t\tt->aalgos = ua->aalgos;\n\t\tt->ealgos = ua->ealgos;\n\t\tt->calgos = ua->calgos;\n\t\terr = km_query(x, t, xp);\n\n\t}\n\n\tkfree(x);\n\tkfree(xp);\n\n\treturn 0;\n\nbad_policy:\n\tWARN(1, \"BAD policy passed\\n\");\nfree_state:\n\tkfree(x);\nnomem:\n\treturn err;\n}\n\n#ifdef CONFIG_XFRM_MIGRATE\nstatic int copy_from_user_migrate(struct xfrm_migrate *ma,\n\t\t\t\t  struct xfrm_kmaddress *k,\n\t\t\t\t  struct nlattr **attrs, int *num)\n{\n\tstruct nlattr *rt = attrs[XFRMA_MIGRATE];\n\tstruct xfrm_user_migrate *um;\n\tint i, num_migrate;\n\n\tif (k != NULL) {\n\t\tstruct xfrm_user_kmaddress *uk;\n\n\t\tuk = nla_data(attrs[XFRMA_KMADDRESS]);\n\t\tmemcpy(&k->local, &uk->local, sizeof(k->local));\n\t\tmemcpy(&k->remote, &uk->remote, sizeof(k->remote));\n\t\tk->family = uk->family;\n\t\tk->reserved = uk->reserved;\n\t}\n\n\tum = nla_data(rt);\n\tnum_migrate = nla_len(rt) / sizeof(*um);\n\n\tif (num_migrate <= 0 || num_migrate > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_migrate; i++, um++, ma++) {\n\t\tmemcpy(&ma->old_daddr, &um->old_daddr, sizeof(ma->old_daddr));\n\t\tmemcpy(&ma->old_saddr, &um->old_saddr, sizeof(ma->old_saddr));\n\t\tmemcpy(&ma->new_daddr, &um->new_daddr, sizeof(ma->new_daddr));\n\t\tmemcpy(&ma->new_saddr, &um->new_saddr, sizeof(ma->new_saddr));\n\n\t\tma->proto = um->proto;\n\t\tma->mode = um->mode;\n\t\tma->reqid = um->reqid;\n\n\t\tma->old_family = um->old_family;\n\t\tma->new_family = um->new_family;\n\t}\n\n\t*num = i;\n\treturn 0;\n}\n\nstatic int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t   struct nlattr **attrs)\n{\n\tstruct xfrm_userpolicy_id *pi = nlmsg_data(nlh);\n\tstruct xfrm_migrate m[XFRM_MAX_DEPTH];\n\tstruct xfrm_kmaddress km, *kmp;\n\tu8 type;\n\tint err;\n\tint n = 0;\n\n\terr = verify_policy_dir(pi->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (attrs[XFRMA_MIGRATE] == NULL)\n\t\treturn -EINVAL;\n\n\tkmp = attrs[XFRMA_KMADDRESS] ? &km : NULL;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = copy_from_user_migrate((struct xfrm_migrate *)m, kmp, attrs, &n);\n\tif (err)\n\t\treturn err;\n\n\tif (!n)\n\t\treturn 0;\n\n\txfrm_migrate(&pi->sel, pi->dir, type, m, n, kmp);\n\n\treturn 0;\n}\n#else\nstatic int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t   struct nlattr **attrs)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\n#ifdef CONFIG_XFRM_MIGRATE\nstatic int copy_to_user_migrate(const struct xfrm_migrate *m, struct sk_buff *skb)\n{\n\tstruct xfrm_user_migrate um;\n\n\tmemset(&um, 0, sizeof(um));\n\tum.proto = m->proto;\n\tum.mode = m->mode;\n\tum.reqid = m->reqid;\n\tum.old_family = m->old_family;\n\tmemcpy(&um.old_daddr, &m->old_daddr, sizeof(um.old_daddr));\n\tmemcpy(&um.old_saddr, &m->old_saddr, sizeof(um.old_saddr));\n\tum.new_family = m->new_family;\n\tmemcpy(&um.new_daddr, &m->new_daddr, sizeof(um.new_daddr));\n\tmemcpy(&um.new_saddr, &m->new_saddr, sizeof(um.new_saddr));\n\n\treturn nla_put(skb, XFRMA_MIGRATE, sizeof(um), &um);\n}\n\nstatic int copy_to_user_kmaddress(const struct xfrm_kmaddress *k, struct sk_buff *skb)\n{\n\tstruct xfrm_user_kmaddress uk;\n\n\tmemset(&uk, 0, sizeof(uk));\n\tuk.family = k->family;\n\tuk.reserved = k->reserved;\n\tmemcpy(&uk.local, &k->local, sizeof(uk.local));\n\tmemcpy(&uk.remote, &k->remote, sizeof(uk.remote));\n\n\treturn nla_put(skb, XFRMA_KMADDRESS, sizeof(uk), &uk);\n}\n\nstatic inline size_t xfrm_migrate_msgsize(int num_migrate, int with_kma)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_userpolicy_id))\n\t      + (with_kma ? nla_total_size(sizeof(struct xfrm_kmaddress)) : 0)\n\t      + nla_total_size(sizeof(struct xfrm_user_migrate) * num_migrate)\n\t      + userpolicy_type_attrsize();\n}\n\nstatic int build_migrate(struct sk_buff *skb, const struct xfrm_migrate *m,\n\t\t\t int num_migrate, const struct xfrm_kmaddress *k,\n\t\t\t const struct xfrm_selector *sel, u8 dir, u8 type)\n{\n\tconst struct xfrm_migrate *mp;\n\tstruct xfrm_userpolicy_id *pol_id;\n\tstruct nlmsghdr *nlh;\n\tint i, err;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_MIGRATE, sizeof(*pol_id), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tpol_id = nlmsg_data(nlh);\n\t/* copy data from selector, dir, and type to the pol_id */\n\tmemset(pol_id, 0, sizeof(*pol_id));\n\tmemcpy(&pol_id->sel, sel, sizeof(pol_id->sel));\n\tpol_id->dir = dir;\n\n\tif (k != NULL) {\n\t\terr = copy_to_user_kmaddress(k, skb);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\terr = copy_to_user_policy_type(type, skb);\n\tif (err)\n\t\tgoto out_cancel;\n\tfor (i = 0, mp = m ; i < num_migrate; i++, mp++) {\n\t\terr = copy_to_user_migrate(mp, skb);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\n\treturn nlmsg_end(skb, nlh);\n\nout_cancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn err;\n}\n\nstatic int xfrm_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t     const struct xfrm_migrate *m, int num_migrate,\n\t\t\t     const struct xfrm_kmaddress *k)\n{\n\tstruct net *net = &init_net;\n\tstruct sk_buff *skb;\n\tint err;\n\n\terr = verify_policy_dir(dir);\n\tif (err)\n\t\treturn err;\n\n\tskb = nlmsg_new(xfrm_migrate_msgsize(num_migrate, !!k), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\t/* build migrate */\n\tif (build_migrate(skb, m, num_migrate, k, sel, dir, type) < 0)\n\t\tBUG();\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_MIGRATE, GFP_ATOMIC);\n}\n#else\nstatic int xfrm_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t     const struct xfrm_migrate *m, int num_migrate,\n\t\t\t     const struct xfrm_kmaddress *k)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\n#define XMSGSIZE(type) sizeof(struct type)\n\nstatic const int xfrm_msg_min[XFRM_NR_MSGTYPES] = {\n\t[XFRM_MSG_NEWSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_info),\n\t[XFRM_MSG_DELSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_id),\n\t[XFRM_MSG_GETSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_id),\n\t[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_info),\n\t[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userspi_info),\n\t[XFRM_MSG_ACQUIRE     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_acquire),\n\t[XFRM_MSG_EXPIRE      - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_expire),\n\t[XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_info),\n\t[XFRM_MSG_UPDSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_info),\n\t[XFRM_MSG_POLEXPIRE   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_polexpire),\n\t[XFRM_MSG_FLUSHSA     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_flush),\n\t[XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = 0,\n\t[XFRM_MSG_NEWAE       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_aevent_id),\n\t[XFRM_MSG_GETAE       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_aevent_id),\n\t[XFRM_MSG_REPORT      - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_report),\n\t[XFRM_MSG_MIGRATE     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_GETSADINFO  - XFRM_MSG_BASE] = sizeof(u32),\n\t[XFRM_MSG_GETSPDINFO  - XFRM_MSG_BASE] = sizeof(u32),\n};\n\n#undef XMSGSIZE\n\nstatic const struct nla_policy xfrma_policy[XFRMA_MAX+1] = {\n\t[XFRMA_SA]\t\t= { .len = sizeof(struct xfrm_usersa_info)},\n\t[XFRMA_POLICY]\t\t= { .len = sizeof(struct xfrm_userpolicy_info)},\n\t[XFRMA_LASTUSED]\t= { .type = NLA_U64},\n\t[XFRMA_ALG_AUTH_TRUNC]\t= { .len = sizeof(struct xfrm_algo_auth)},\n\t[XFRMA_ALG_AEAD]\t= { .len = sizeof(struct xfrm_algo_aead) },\n\t[XFRMA_ALG_AUTH]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ALG_CRYPT]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ALG_COMP]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ENCAP]\t\t= { .len = sizeof(struct xfrm_encap_tmpl) },\n\t[XFRMA_TMPL]\t\t= { .len = sizeof(struct xfrm_user_tmpl) },\n\t[XFRMA_SEC_CTX]\t\t= { .len = sizeof(struct xfrm_sec_ctx) },\n\t[XFRMA_LTIME_VAL]\t= { .len = sizeof(struct xfrm_lifetime_cur) },\n\t[XFRMA_REPLAY_VAL]\t= { .len = sizeof(struct xfrm_replay_state) },\n\t[XFRMA_REPLAY_THRESH]\t= { .type = NLA_U32 },\n\t[XFRMA_ETIMER_THRESH]\t= { .type = NLA_U32 },\n\t[XFRMA_SRCADDR]\t\t= { .len = sizeof(xfrm_address_t) },\n\t[XFRMA_COADDR]\t\t= { .len = sizeof(xfrm_address_t) },\n\t[XFRMA_POLICY_TYPE]\t= { .len = sizeof(struct xfrm_userpolicy_type)},\n\t[XFRMA_MIGRATE]\t\t= { .len = sizeof(struct xfrm_user_migrate) },\n\t[XFRMA_KMADDRESS]\t= { .len = sizeof(struct xfrm_user_kmaddress) },\n\t[XFRMA_MARK]\t\t= { .len = sizeof(struct xfrm_mark) },\n\t[XFRMA_TFCPAD]\t\t= { .type = NLA_U32 },\n\t[XFRMA_REPLAY_ESN_VAL]\t= { .len = sizeof(struct xfrm_replay_state_esn) },\n\t[XFRMA_SA_EXTRA_FLAGS]\t= { .type = NLA_U32 },\n\t[XFRMA_OUTPUT_MARK]\t= { .len = NLA_U32 },\n};\n\nstatic const struct xfrm_link {\n\tint (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);\n\tint (*dump)(struct sk_buff *, struct netlink_callback *);\n\tint (*done)(struct netlink_callback *);\n} xfrm_dispatch[XFRM_NR_MSGTYPES] = {\n\t[XFRM_MSG_NEWSA       - XFRM_MSG_BASE] = { .doit = xfrm_add_sa        },\n\t[XFRM_MSG_DELSA       - XFRM_MSG_BASE] = { .doit = xfrm_del_sa        },\n\t[XFRM_MSG_GETSA       - XFRM_MSG_BASE] = { .doit = xfrm_get_sa,\n\t\t\t\t\t\t   .dump = xfrm_dump_sa,\n\t\t\t\t\t\t   .done = xfrm_dump_sa_done  },\n\t[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },\n\t[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy    },\n\t[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy,\n\t\t\t\t\t\t   .dump = xfrm_dump_policy,\n\t\t\t\t\t\t   .done = xfrm_dump_policy_done },\n\t[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = { .doit = xfrm_alloc_userspi },\n\t[XFRM_MSG_ACQUIRE     - XFRM_MSG_BASE] = { .doit = xfrm_add_acquire   },\n\t[XFRM_MSG_EXPIRE      - XFRM_MSG_BASE] = { .doit = xfrm_add_sa_expire },\n\t[XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },\n\t[XFRM_MSG_UPDSA       - XFRM_MSG_BASE] = { .doit = xfrm_add_sa        },\n\t[XFRM_MSG_POLEXPIRE   - XFRM_MSG_BASE] = { .doit = xfrm_add_pol_expire},\n\t[XFRM_MSG_FLUSHSA     - XFRM_MSG_BASE] = { .doit = xfrm_flush_sa      },\n\t[XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = { .doit = xfrm_flush_policy  },\n\t[XFRM_MSG_NEWAE       - XFRM_MSG_BASE] = { .doit = xfrm_new_ae  },\n\t[XFRM_MSG_GETAE       - XFRM_MSG_BASE] = { .doit = xfrm_get_ae  },\n\t[XFRM_MSG_MIGRATE     - XFRM_MSG_BASE] = { .doit = xfrm_do_migrate    },\n\t[XFRM_MSG_GETSADINFO  - XFRM_MSG_BASE] = { .doit = xfrm_get_sadinfo   },\n\t[XFRM_MSG_GETSPDINFO  - XFRM_MSG_BASE] = { .doit = xfrm_get_spdinfo   },\n};\n\nstatic int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,\n\t\t\t  xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n\nstatic void xfrm_netlink_rcv(struct sk_buff *skb)\n{\n\tmutex_lock(&xfrm_cfg_mutex);\n\tnetlink_rcv_skb(skb, &xfrm_user_rcv_msg);\n\tmutex_unlock(&xfrm_cfg_mutex);\n}\n\nstatic inline size_t xfrm_expire_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_expire))\n\t       + nla_total_size(sizeof(struct xfrm_mark));\n}\n\nstatic int build_expire(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct xfrm_user_expire *ue;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, 0, XFRM_MSG_EXPIRE, sizeof(*ue), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tue = nlmsg_data(nlh);\n\tcopy_to_user_state(x, &ue->state);\n\tue->hard = (c->data.hard != 0) ? 1 : 0;\n\n\terr = xfrm_mark_put(skb, &x->mark);\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_exp_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_expire_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_expire(skb, x, c) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_EXPIRE, GFP_ATOMIC);\n}\n\nstatic int xfrm_aevent_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_aevent_msgsize(x), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_aevent(skb, x, c) < 0)\n\t\tBUG();\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_AEVENTS, GFP_ATOMIC);\n}\n\nstatic int xfrm_notify_sa_flush(const struct km_event *c)\n{\n\tstruct net *net = c->net;\n\tstruct xfrm_usersa_flush *p;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint len = NLMSG_ALIGN(sizeof(struct xfrm_usersa_flush));\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_FLUSHSA, sizeof(*p), 0);\n\tif (nlh == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tp = nlmsg_data(nlh);\n\tp->proto = c->data.proto;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_SA, GFP_ATOMIC);\n}\n\nstatic inline size_t xfrm_sa_len(struct xfrm_state *x)\n{\n\tsize_t l = 0;\n\tif (x->aead)\n\t\tl += nla_total_size(aead_len(x->aead));\n\tif (x->aalg) {\n\t\tl += nla_total_size(sizeof(struct xfrm_algo) +\n\t\t\t\t    (x->aalg->alg_key_len + 7) / 8);\n\t\tl += nla_total_size(xfrm_alg_auth_len(x->aalg));\n\t}\n\tif (x->ealg)\n\t\tl += nla_total_size(xfrm_alg_len(x->ealg));\n\tif (x->calg)\n\t\tl += nla_total_size(sizeof(*x->calg));\n\tif (x->encap)\n\t\tl += nla_total_size(sizeof(*x->encap));\n\tif (x->tfcpad)\n\t\tl += nla_total_size(sizeof(x->tfcpad));\n\tif (x->replay_esn)\n\t\tl += nla_total_size(xfrm_replay_state_esn_len(x->replay_esn));\n\tif (x->security)\n\t\tl += nla_total_size(sizeof(struct xfrm_user_sec_ctx) +\n\t\t\t\t    x->security->ctx_len);\n\tif (x->coaddr)\n\t\tl += nla_total_size(sizeof(*x->coaddr));\n\tif (x->props.extra_flags)\n\t\tl += nla_total_size(sizeof(x->props.extra_flags));\n\tif (x->props.output_mark)\n\t\tl += nla_total_size(sizeof(x->props.output_mark));\n\n\t/* Must count x->lastused as it may become non-zero behind our back. */\n\tl += nla_total_size(sizeof(u64));\n\n\treturn l;\n}\n\nstatic int xfrm_notify_sa(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct xfrm_usersa_info *p;\n\tstruct xfrm_usersa_id *id;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint len = xfrm_sa_len(x);\n\tint headlen, err;\n\n\theadlen = sizeof(*p);\n\tif (c->event == XFRM_MSG_DELSA) {\n\t\tlen += nla_total_size(headlen);\n\t\theadlen = sizeof(*id);\n\t\tlen += nla_total_size(sizeof(struct xfrm_mark));\n\t}\n\tlen += NLMSG_ALIGN(headlen);\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, c->event, headlen, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\n\tp = nlmsg_data(nlh);\n\tif (c->event == XFRM_MSG_DELSA) {\n\t\tstruct nlattr *attr;\n\n\t\tid = nlmsg_data(nlh);\n\t\tmemcpy(&id->daddr, &x->id.daddr, sizeof(id->daddr));\n\t\tid->spi = x->id.spi;\n\t\tid->family = x->props.family;\n\t\tid->proto = x->id.proto;\n\n\t\tattr = nla_reserve(skb, XFRMA_SA, sizeof(*p));\n\t\terr = -EMSGSIZE;\n\t\tif (attr == NULL)\n\t\t\tgoto out_free_skb;\n\n\t\tp = nla_data(attr);\n\t}\n\terr = copy_to_user_state_extra(x, p, skb);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_SA, GFP_ATOMIC);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int xfrm_send_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn xfrm_exp_state_notify(x, c);\n\tcase XFRM_MSG_NEWAE:\n\t\treturn xfrm_aevent_state_notify(x, c);\n\tcase XFRM_MSG_DELSA:\n\tcase XFRM_MSG_UPDSA:\n\tcase XFRM_MSG_NEWSA:\n\t\treturn xfrm_notify_sa(x, c);\n\tcase XFRM_MSG_FLUSHSA:\n\t\treturn xfrm_notify_sa_flush(c);\n\tdefault:\n\t\tprintk(KERN_NOTICE \"xfrm_user: Unknown SA event %d\\n\",\n\t\t       c->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n\n}\n\nstatic inline size_t xfrm_acquire_msgsize(struct xfrm_state *x,\n\t\t\t\t\t  struct xfrm_policy *xp)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_acquire))\n\t       + nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr)\n\t       + nla_total_size(sizeof(struct xfrm_mark))\n\t       + nla_total_size(xfrm_user_sec_ctx_size(x->security))\n\t       + userpolicy_type_attrsize();\n}\n\nstatic int build_acquire(struct sk_buff *skb, struct xfrm_state *x,\n\t\t\t struct xfrm_tmpl *xt, struct xfrm_policy *xp)\n{\n\t__u32 seq = xfrm_get_acqseq();\n\tstruct xfrm_user_acquire *ua;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_ACQUIRE, sizeof(*ua), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tua = nlmsg_data(nlh);\n\tmemcpy(&ua->id, &x->id, sizeof(ua->id));\n\tmemcpy(&ua->saddr, &x->props.saddr, sizeof(ua->saddr));\n\tmemcpy(&ua->sel, &x->sel, sizeof(ua->sel));\n\tcopy_to_user_policy(xp, &ua->policy, XFRM_POLICY_OUT);\n\tua->aalgos = xt->aalgos;\n\tua->ealgos = xt->ealgos;\n\tua->calgos = xt->calgos;\n\tua->seq = x->km.seq = seq;\n\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_state_sec_ctx(x, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *xt,\n\t\t\t     struct xfrm_policy *xp)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_acquire_msgsize(x, xp), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_acquire(skb, x, xt, xp) < 0)\n\t\tBUG();\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_ACQUIRE, GFP_ATOMIC);\n}\n\n/* User gives us xfrm_user_policy_info followed by an array of 0\n * or more templates.\n */\nstatic struct xfrm_policy *xfrm_compile_policy(struct sock *sk, int opt,\n\t\t\t\t\t       u8 *data, int len, int *dir)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_userpolicy_info *p = (struct xfrm_userpolicy_info *)data;\n\tstruct xfrm_user_tmpl *ut = (struct xfrm_user_tmpl *) (p + 1);\n\tstruct xfrm_policy *xp;\n\tint nr;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tif (opt != IP_XFRM_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (opt != IPV6_XFRM_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\t*dir = -EINVAL;\n\t\treturn NULL;\n\t}\n\n\t*dir = -EINVAL;\n\n\tif (len < sizeof(*p) ||\n\t    verify_newpolicy_info(p))\n\t\treturn NULL;\n\n\tnr = ((len - sizeof(*p)) / sizeof(*ut));\n\tif (validate_tmpl(nr, ut, p->sel.family))\n\t\treturn NULL;\n\n\tif (p->dir > XFRM_POLICY_OUT)\n\t\treturn NULL;\n\n\txp = xfrm_policy_alloc(net, GFP_ATOMIC);\n\tif (xp == NULL) {\n\t\t*dir = -ENOBUFS;\n\t\treturn NULL;\n\t}\n\n\tcopy_from_user_policy(xp, p);\n\txp->type = XFRM_POLICY_TYPE_MAIN;\n\tcopy_templates(xp, ut, nr);\n\n\t*dir = p->dir;\n\n\treturn xp;\n}\n\nstatic inline size_t xfrm_polexpire_msgsize(struct xfrm_policy *xp)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_polexpire))\n\t       + nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr)\n\t       + nla_total_size(xfrm_user_sec_ctx_size(xp->security))\n\t       + nla_total_size(sizeof(struct xfrm_mark))\n\t       + userpolicy_type_attrsize();\n}\n\nstatic int build_polexpire(struct sk_buff *skb, struct xfrm_policy *xp,\n\t\t\t   int dir, const struct km_event *c)\n{\n\tstruct xfrm_user_polexpire *upe;\n\tint hard = c->data.hard;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, 0, XFRM_MSG_POLEXPIRE, sizeof(*upe), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tupe = nlmsg_data(nlh);\n\tcopy_to_user_policy(xp, &upe->pol, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_sec_ctx(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tupe->hard = !!hard;\n\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tstruct net *net = xp_net(xp);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_polexpire(skb, xp, dir, c) < 0)\n\t\tBUG();\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_EXPIRE, GFP_ATOMIC);\n}\n\nstatic int xfrm_notify_policy(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tint len = nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr);\n\tstruct net *net = xp_net(xp);\n\tstruct xfrm_userpolicy_info *p;\n\tstruct xfrm_userpolicy_id *id;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint headlen, err;\n\n\theadlen = sizeof(*p);\n\tif (c->event == XFRM_MSG_DELPOLICY) {\n\t\tlen += nla_total_size(headlen);\n\t\theadlen = sizeof(*id);\n\t}\n\tlen += userpolicy_type_attrsize();\n\tlen += nla_total_size(sizeof(struct xfrm_mark));\n\tlen += NLMSG_ALIGN(headlen);\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, c->event, headlen, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\n\tp = nlmsg_data(nlh);\n\tif (c->event == XFRM_MSG_DELPOLICY) {\n\t\tstruct nlattr *attr;\n\n\t\tid = nlmsg_data(nlh);\n\t\tmemset(id, 0, sizeof(*id));\n\t\tid->dir = dir;\n\t\tif (c->data.byid)\n\t\t\tid->index = xp->index;\n\t\telse\n\t\t\tmemcpy(&id->sel, &xp->selector, sizeof(id->sel));\n\n\t\tattr = nla_reserve(skb, XFRMA_POLICY, sizeof(*p));\n\t\terr = -EMSGSIZE;\n\t\tif (attr == NULL)\n\t\t\tgoto out_free_skb;\n\n\t\tp = nla_data(attr);\n\t}\n\n\tcopy_to_user_policy(xp, p, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_POLICY, GFP_ATOMIC);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int xfrm_notify_policy_flush(const struct km_event *c)\n{\n\tstruct net *net = c->net;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(userpolicy_type_attrsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_FLUSHPOLICY, 0, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\terr = copy_to_user_policy_type(c->data.type, skb);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_POLICY, GFP_ATOMIC);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int xfrm_send_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tint err;\n\n\terr = verify_policy_dir(dir);\n\tif (err)\n\t\treturn err;\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_NEWPOLICY:\n\tcase XFRM_MSG_UPDPOLICY:\n\tcase XFRM_MSG_DELPOLICY:\n\t\treturn xfrm_notify_policy(xp, dir, c);\n\tcase XFRM_MSG_FLUSHPOLICY:\n\t\treturn xfrm_notify_policy_flush(c);\n\tcase XFRM_MSG_POLEXPIRE:\n\t\treturn xfrm_exp_policy_notify(xp, dir, c);\n\tdefault:\n\t\tprintk(KERN_NOTICE \"xfrm_user: Unknown Policy event %d\\n\",\n\t\t       c->event);\n\t}\n\n\treturn 0;\n\n}\n\nstatic inline size_t xfrm_report_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_report));\n}\n\nstatic int build_report(struct sk_buff *skb, u8 proto,\n\t\t\tstruct xfrm_selector *sel, xfrm_address_t *addr)\n{\n\tstruct xfrm_user_report *ur;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_REPORT, sizeof(*ur), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tur = nlmsg_data(nlh);\n\tur->proto = proto;\n\tmemcpy(&ur->sel, sel, sizeof(ur->sel));\n\n\tif (addr) {\n\t\tint err = nla_put(skb, XFRMA_COADDR, sizeof(*addr), addr);\n\t\tif (err) {\n\t\t\tnlmsg_cancel(skb, nlh);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_send_report(struct net *net, u8 proto,\n\t\t\t    struct xfrm_selector *sel, xfrm_address_t *addr)\n{\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_report_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_report(skb, proto, sel, addr) < 0)\n\t\tBUG();\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_REPORT, GFP_ATOMIC);\n}\n\nstatic inline size_t xfrm_mapping_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_mapping));\n}\n\nstatic int build_mapping(struct sk_buff *skb, struct xfrm_state *x,\n\t\t\t xfrm_address_t *new_saddr, __be16 new_sport)\n{\n\tstruct xfrm_user_mapping *um;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_MAPPING, sizeof(*um), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tum = nlmsg_data(nlh);\n\n\tmemcpy(&um->id.daddr, &x->id.daddr, sizeof(um->id.daddr));\n\tum->id.spi = x->id.spi;\n\tum->id.family = x->props.family;\n\tum->id.proto = x->id.proto;\n\tmemcpy(&um->new_saddr, new_saddr, sizeof(um->new_saddr));\n\tmemcpy(&um->old_saddr, &x->props.saddr, sizeof(um->old_saddr));\n\tum->new_sport = new_sport;\n\tum->old_sport = x->encap->encap_sport;\n\tum->reqid = x->props.reqid;\n\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_send_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr,\n\t\t\t     __be16 sport)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tif (x->id.proto != IPPROTO_ESP)\n\t\treturn -EINVAL;\n\n\tif (!x->encap)\n\t\treturn -EINVAL;\n\n\tskb = nlmsg_new(xfrm_mapping_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_mapping(skb, x, ipaddr, sport) < 0)\n\t\tBUG();\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_MAPPING, GFP_ATOMIC);\n}\n\nstatic struct xfrm_mgr netlink_mgr = {\n\t.id\t\t= \"netlink\",\n\t.notify\t\t= xfrm_send_state_notify,\n\t.acquire\t= xfrm_send_acquire,\n\t.compile_policy\t= xfrm_compile_policy,\n\t.notify_policy\t= xfrm_send_policy_notify,\n\t.report\t\t= xfrm_send_report,\n\t.migrate\t= xfrm_send_migrate,\n\t.new_mapping\t= xfrm_send_mapping,\n};\n\nstatic int __net_init xfrm_user_net_init(struct net *net)\n{\n\tstruct sock *nlsk;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= XFRMNLGRP_MAX,\n\t\t.input\t= xfrm_netlink_rcv,\n\t};\n\n\tnlsk = netlink_kernel_create(net, NETLINK_XFRM, &cfg);\n\tif (nlsk == NULL)\n\t\treturn -ENOMEM;\n\tnet->xfrm.nlsk_stash = nlsk; /* Don't set to NULL */\n\trcu_assign_pointer(net->xfrm.nlsk, nlsk);\n\treturn 0;\n}\n\nstatic void __net_exit xfrm_user_net_exit(struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tRCU_INIT_POINTER(net->xfrm.nlsk, NULL);\n\tsynchronize_net();\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tnetlink_kernel_release(net->xfrm.nlsk_stash);\n}\n\nstatic struct pernet_operations xfrm_user_net_ops = {\n\t.init\t    = xfrm_user_net_init,\n\t.exit_batch = xfrm_user_net_exit,\n};\n\nstatic int __init xfrm_user_init(void)\n{\n\tint rv;\n\n\tprintk(KERN_INFO \"Initializing XFRM netlink socket\\n\");\n\n\trv = register_pernet_subsys(&xfrm_user_net_ops);\n\tif (rv < 0)\n\t\treturn rv;\n\trv = xfrm_register_km(&netlink_mgr);\n\tif (rv < 0)\n\t\tunregister_pernet_subsys(&xfrm_user_net_ops);\n\treturn rv;\n}\n\nstatic void __exit xfrm_user_exit(void)\n{\n\txfrm_unregister_km(&netlink_mgr);\n\tunregister_pernet_subsys(&xfrm_user_net_ops);\n}\n\nmodule_init(xfrm_user_init);\nmodule_exit(xfrm_user_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO(PF_NETLINK, NETLINK_XFRM);\n\n"], "fixing_code": ["/* xfrm_user.c: User interface to configure xfrm engine.\n *\n * Copyright (C) 2002 David S. Miller (davem@redhat.com)\n *\n * Changes:\n *\tMitsuru KANDA @USAGI\n * \tKazunori MIYAZAWA @USAGI\n * \tKunihiro Ishiguro <kunihiro@ipinfusion.com>\n * \t\tIPv6 support\n *\n */\n\n#include <linux/crypto.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/pfkeyv2.h>\n#include <linux/ipsec.h>\n#include <linux/init.h>\n#include <linux/security.h>\n#include <net/sock.h>\n#include <net/xfrm.h>\n#include <net/netlink.h>\n#include <net/ah.h>\n#include <asm/uaccess.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <linux/in6.h>\n#endif\n\nstatic inline int aead_len(struct xfrm_algo_aead *alg)\n{\n\treturn sizeof(*alg) + ((alg->alg_key_len + 7) / 8);\n}\n\nstatic int verify_one_alg(struct nlattr **attrs, enum xfrm_attr_type_t type)\n{\n\tstruct nlattr *rt = attrs[type];\n\tstruct xfrm_algo *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < xfrm_alg_len(algp))\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase XFRMA_ALG_AUTH:\n\tcase XFRMA_ALG_CRYPT:\n\tcase XFRMA_ALG_COMP:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}\n\nstatic int verify_auth_trunc(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_ALG_AUTH_TRUNC];\n\tstruct xfrm_algo_auth *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < xfrm_alg_auth_len(algp))\n\t\treturn -EINVAL;\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}\n\nstatic int verify_aead(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_ALG_AEAD];\n\tstruct xfrm_algo_aead *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < aead_len(algp))\n\t\treturn -EINVAL;\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}\n\nstatic void verify_one_addr(struct nlattr **attrs, enum xfrm_attr_type_t type,\n\t\t\t   xfrm_address_t **addrp)\n{\n\tstruct nlattr *rt = attrs[type];\n\n\tif (rt && addrp)\n\t\t*addrp = nla_data(rt);\n}\n\nstatic inline int verify_sec_ctx_len(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\tstruct xfrm_user_sec_ctx *uctx;\n\n\tif (!rt)\n\t\treturn 0;\n\n\tuctx = nla_data(rt);\n\tif (uctx->len != (sizeof(struct xfrm_user_sec_ctx) + uctx->ctx_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline int verify_replay(struct xfrm_usersa_info *p,\n\t\t\t\tstruct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];\n\tstruct xfrm_replay_state_esn *rs;\n\n\tif (p->flags & XFRM_STATE_ESN) {\n\t\tif (!rt)\n\t\t\treturn -EINVAL;\n\n\t\trs = nla_data(rt);\n\n\t\tif (rs->bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof(rs->bmp[0]) / 8)\n\t\t\treturn -EINVAL;\n\n\t\tif (nla_len(rt) < xfrm_replay_state_esn_len(rs) &&\n\t\t    nla_len(rt) != sizeof(*rs))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rt)\n\t\treturn 0;\n\n\tif (p->id.proto != IPPROTO_ESP)\n\t\treturn -EINVAL;\n\n\tif (p->replay_window != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int verify_newsa_info(struct xfrm_usersa_info *p,\n\t\t\t     struct nlattr **attrs)\n{\n\tint err;\n\n\terr = -EINVAL;\n\tswitch (p->family) {\n\tcase AF_INET:\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tbreak;\n#else\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto out;\n#endif\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = -EINVAL;\n\tswitch (p->id.proto) {\n\tcase IPPROTO_AH:\n\t\tif ((!attrs[XFRMA_ALG_AUTH]\t&&\n\t\t     !attrs[XFRMA_ALG_AUTH_TRUNC]) ||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_TFCPAD])\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IPPROTO_ESP:\n\t\tif (attrs[XFRMA_ALG_COMP])\n\t\t\tgoto out;\n\t\tif (!attrs[XFRMA_ALG_AUTH] &&\n\t\t    !attrs[XFRMA_ALG_AUTH_TRUNC] &&\n\t\t    !attrs[XFRMA_ALG_CRYPT] &&\n\t\t    !attrs[XFRMA_ALG_AEAD])\n\t\t\tgoto out;\n\t\tif ((attrs[XFRMA_ALG_AUTH] ||\n\t\t     attrs[XFRMA_ALG_AUTH_TRUNC] ||\n\t\t     attrs[XFRMA_ALG_CRYPT]) &&\n\t\t    attrs[XFRMA_ALG_AEAD])\n\t\t\tgoto out;\n\t\tif (attrs[XFRMA_TFCPAD] &&\n\t\t    p->mode != XFRM_MODE_TUNNEL)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IPPROTO_COMP:\n\t\tif (!attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_AUTH]\t||\n\t\t    attrs[XFRMA_ALG_AUTH_TRUNC]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_TFCPAD])\n\t\t\tgoto out;\n\t\tbreak;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase IPPROTO_DSTOPTS:\n\tcase IPPROTO_ROUTING:\n\t\tif (attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_ALG_AUTH]\t||\n\t\t    attrs[XFRMA_ALG_AUTH_TRUNC]\t||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_ENCAP]\t\t||\n\t\t    attrs[XFRMA_SEC_CTX]\t||\n\t\t    attrs[XFRMA_TFCPAD]\t\t||\n\t\t    !attrs[XFRMA_COADDR])\n\t\t\tgoto out;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif ((err = verify_aead(attrs)))\n\t\tgoto out;\n\tif ((err = verify_auth_trunc(attrs)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_AUTH)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_CRYPT)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_COMP)))\n\t\tgoto out;\n\tif ((err = verify_sec_ctx_len(attrs)))\n\t\tgoto out;\n\tif ((err = verify_replay(p, attrs)))\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tswitch (p->mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\tcase XFRM_MODE_TUNNEL:\n\tcase XFRM_MODE_ROUTEOPTIMIZATION:\n\tcase XFRM_MODE_BEET:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\nout:\n\treturn err;\n}\n\nstatic int attach_one_algo(struct xfrm_algo **algpp, u8 *props,\n\t\t\t   struct xfrm_algo_desc *(*get_byname)(const char *, int),\n\t\t\t   struct nlattr *rta)\n{\n\tstruct xfrm_algo *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, xfrm_alg_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic int attach_auth(struct xfrm_algo_auth **algpp, u8 *props,\n\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_algo *ualg;\n\tstruct xfrm_algo_auth *p;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_aalg_get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmalloc(sizeof(*p) + (ualg->alg_key_len + 7) / 8, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\tp->alg_key_len = ualg->alg_key_len;\n\tp->alg_trunc_len = algo->uinfo.auth.icv_truncbits;\n\tmemcpy(p->alg_key, ualg->alg_key, (ualg->alg_key_len + 7) / 8);\n\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic int attach_auth_trunc(struct xfrm_algo_auth **algpp, u8 *props,\n\t\t\t     struct nlattr *rta)\n{\n\tstruct xfrm_algo_auth *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_aalg_get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\tif ((ualg->alg_trunc_len / 8) > MAX_AH_AUTH_LEN ||\n\t    ualg->alg_trunc_len > algo->uinfo.auth.icv_fullbits)\n\t\treturn -EINVAL;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, xfrm_alg_auth_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\tif (!p->alg_trunc_len)\n\t\tp->alg_trunc_len = algo->uinfo.auth.icv_truncbits;\n\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic int attach_aead(struct xfrm_algo_aead **algpp, u8 *props,\n\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_algo_aead *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_aead_get_byname(ualg->alg_name, ualg->alg_icv_len, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, aead_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\n\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn,\n\t\t\t\t       struct xfrm_replay_state_esn **preplay_esn,\n\t\t\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_replay_state_esn *p, *pp, *up;\n\tint klen, ulen;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tup = nla_data(rta);\n\tklen = xfrm_replay_state_esn_len(up);\n\tulen = nla_len(rta) >= klen ? klen : sizeof(*up);\n\n\tp = kzalloc(klen, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpp = kzalloc(klen, GFP_KERNEL);\n\tif (!pp) {\n\t\tkfree(p);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(p, up, ulen);\n\tmemcpy(pp, up, ulen);\n\n\t*replay_esn = p;\n\t*preplay_esn = pp;\n\n\treturn 0;\n}\n\nstatic inline int xfrm_user_sec_ctx_size(struct xfrm_sec_ctx *xfrm_ctx)\n{\n\tint len = 0;\n\n\tif (xfrm_ctx) {\n\t\tlen += sizeof(struct xfrm_user_sec_ctx);\n\t\tlen += xfrm_ctx->ctx_len;\n\t}\n\treturn len;\n}\n\nstatic void copy_from_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemcpy(&x->id, &p->id, sizeof(x->id));\n\tmemcpy(&x->sel, &p->sel, sizeof(x->sel));\n\tmemcpy(&x->lft, &p->lft, sizeof(x->lft));\n\tx->props.mode = p->mode;\n\tx->props.replay_window = p->replay_window;\n\tx->props.reqid = p->reqid;\n\tx->props.family = p->family;\n\tmemcpy(&x->props.saddr, &p->saddr, sizeof(x->props.saddr));\n\tx->props.flags = p->flags;\n\n\tif (!x->sel.family && !(p->flags & XFRM_STATE_AF_UNSPEC))\n\t\tx->sel.family = p->family;\n}\n\n/*\n * someday when pfkey also has support, we could have the code\n * somehow made shareable and move it to xfrm_state.c - JHS\n *\n*/\nstatic void xfrm_update_ae_params(struct xfrm_state *x, struct nlattr **attrs,\n\t\t\t\t  int update_esn)\n{\n\tstruct nlattr *rp = attrs[XFRMA_REPLAY_VAL];\n\tstruct nlattr *re = update_esn ? attrs[XFRMA_REPLAY_ESN_VAL] : NULL;\n\tstruct nlattr *lt = attrs[XFRMA_LTIME_VAL];\n\tstruct nlattr *et = attrs[XFRMA_ETIMER_THRESH];\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_THRESH];\n\n\tif (re) {\n\t\tstruct xfrm_replay_state_esn *replay_esn;\n\t\treplay_esn = nla_data(re);\n\t\tmemcpy(x->replay_esn, replay_esn,\n\t\t       xfrm_replay_state_esn_len(replay_esn));\n\t\tmemcpy(x->preplay_esn, replay_esn,\n\t\t       xfrm_replay_state_esn_len(replay_esn));\n\t}\n\n\tif (rp) {\n\t\tstruct xfrm_replay_state *replay;\n\t\treplay = nla_data(rp);\n\t\tmemcpy(&x->replay, replay, sizeof(*replay));\n\t\tmemcpy(&x->preplay, replay, sizeof(*replay));\n\t}\n\n\tif (lt) {\n\t\tstruct xfrm_lifetime_cur *ltime;\n\t\tltime = nla_data(lt);\n\t\tx->curlft.bytes = ltime->bytes;\n\t\tx->curlft.packets = ltime->packets;\n\t\tx->curlft.add_time = ltime->add_time;\n\t\tx->curlft.use_time = ltime->use_time;\n\t}\n\n\tif (et)\n\t\tx->replay_maxage = nla_get_u32(et);\n\n\tif (rt)\n\t\tx->replay_maxdiff = nla_get_u32(rt);\n}\n\nstatic struct xfrm_state *xfrm_state_construct(struct net *net,\n\t\t\t\t\t       struct xfrm_usersa_info *p,\n\t\t\t\t\t       struct nlattr **attrs,\n\t\t\t\t\t       int *errp)\n{\n\tstruct xfrm_state *x = xfrm_state_alloc(net);\n\tint err = -ENOMEM;\n\n\tif (!x)\n\t\tgoto error_no_put;\n\n\tcopy_from_user_state(x, p);\n\n\tif (attrs[XFRMA_SA_EXTRA_FLAGS])\n\t\tx->props.extra_flags = nla_get_u32(attrs[XFRMA_SA_EXTRA_FLAGS]);\n\n\tif ((err = attach_aead(&x->aead, &x->props.ealgo,\n\t\t\t       attrs[XFRMA_ALG_AEAD])))\n\t\tgoto error;\n\tif ((err = attach_auth_trunc(&x->aalg, &x->props.aalgo,\n\t\t\t\t     attrs[XFRMA_ALG_AUTH_TRUNC])))\n\t\tgoto error;\n\tif (!x->props.aalgo) {\n\t\tif ((err = attach_auth(&x->aalg, &x->props.aalgo,\n\t\t\t\t       attrs[XFRMA_ALG_AUTH])))\n\t\t\tgoto error;\n\t}\n\tif ((err = attach_one_algo(&x->ealg, &x->props.ealgo,\n\t\t\t\t   xfrm_ealg_get_byname,\n\t\t\t\t   attrs[XFRMA_ALG_CRYPT])))\n\t\tgoto error;\n\tif ((err = attach_one_algo(&x->calg, &x->props.calgo,\n\t\t\t\t   xfrm_calg_get_byname,\n\t\t\t\t   attrs[XFRMA_ALG_COMP])))\n\t\tgoto error;\n\n\tif (attrs[XFRMA_ENCAP]) {\n\t\tx->encap = kmemdup(nla_data(attrs[XFRMA_ENCAP]),\n\t\t\t\t   sizeof(*x->encap), GFP_KERNEL);\n\t\tif (x->encap == NULL)\n\t\t\tgoto error;\n\t}\n\n\tif (attrs[XFRMA_TFCPAD])\n\t\tx->tfcpad = nla_get_u32(attrs[XFRMA_TFCPAD]);\n\n\tif (attrs[XFRMA_COADDR]) {\n\t\tx->coaddr = kmemdup(nla_data(attrs[XFRMA_COADDR]),\n\t\t\t\t    sizeof(*x->coaddr), GFP_KERNEL);\n\t\tif (x->coaddr == NULL)\n\t\t\tgoto error;\n\t}\n\n\txfrm_mark_get(attrs, &x->mark);\n\n\tif (attrs[XFRMA_OUTPUT_MARK])\n\t\tx->props.output_mark = nla_get_u32(attrs[XFRMA_OUTPUT_MARK]);\n\n\terr = __xfrm_init_state(x, false);\n\tif (err)\n\t\tgoto error;\n\n\tif (attrs[XFRMA_SEC_CTX] &&\n\t    security_xfrm_state_alloc(x, nla_data(attrs[XFRMA_SEC_CTX])))\n\t\tgoto error;\n\n\tif ((err = xfrm_alloc_replay_state_esn(&x->replay_esn, &x->preplay_esn,\n\t\t\t\t\t       attrs[XFRMA_REPLAY_ESN_VAL])))\n\t\tgoto error;\n\n\tx->km.seq = p->seq;\n\tx->replay_maxdiff = net->xfrm.sysctl_aevent_rseqth;\n\t/* sysctl_xfrm_aevent_etime is in 100ms units */\n\tx->replay_maxage = (net->xfrm.sysctl_aevent_etime*HZ)/XFRM_AE_ETH_M;\n\n\tif ((err = xfrm_init_replay(x)))\n\t\tgoto error;\n\n\t/* override default values from above */\n\txfrm_update_ae_params(x, attrs, 0);\n\n\treturn x;\n\nerror:\n\tx->km.state = XFRM_STATE_DEAD;\n\txfrm_state_put(x);\nerror_no_put:\n\t*errp = err;\n\treturn NULL;\n}\n\nstatic int xfrm_add_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_usersa_info *p = nlmsg_data(nlh);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct km_event c;\n\tkuid_t loginuid = audit_get_loginuid(current);\n\tu32 sessionid = audit_get_sessionid(current);\n\tu32 sid;\n\n\terr = verify_newsa_info(p, attrs);\n\tif (err)\n\t\treturn err;\n\n\tx = xfrm_state_construct(net, p, attrs, &err);\n\tif (!x)\n\t\treturn err;\n\n\txfrm_state_hold(x);\n\tif (nlh->nlmsg_type == XFRM_MSG_NEWSA)\n\t\terr = xfrm_state_add(x);\n\telse\n\t\terr = xfrm_state_update(x);\n\n\tsecurity_task_getsecid(current, &sid);\n\txfrm_audit_state_add(x, err ? 0 : 1, loginuid, sessionid, sid);\n\n\tif (err < 0) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t\tgoto out;\n\t}\n\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.event = nlh->nlmsg_type;\n\n\tkm_state_notify(x, &c);\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic struct xfrm_state *xfrm_user_state_lookup(struct net *net,\n\t\t\t\t\t\t struct xfrm_usersa_id *p,\n\t\t\t\t\t\t struct nlattr **attrs,\n\t\t\t\t\t\t int *errp)\n{\n\tstruct xfrm_state *x = NULL;\n\tstruct xfrm_mark m;\n\tint err;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tif (xfrm_id_proto_match(p->proto, IPSEC_PROTO_ANY)) {\n\t\terr = -ESRCH;\n\t\tx = xfrm_state_lookup(net, mark, &p->daddr, p->spi, p->proto, p->family);\n\t} else {\n\t\txfrm_address_t *saddr = NULL;\n\n\t\tverify_one_addr(attrs, XFRMA_SRCADDR, &saddr);\n\t\tif (!saddr) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -ESRCH;\n\t\tx = xfrm_state_lookup_byaddr(net, mark,\n\t\t\t\t\t     &p->daddr, saddr,\n\t\t\t\t\t     p->proto, p->family);\n\t}\n\n out:\n\tif (!x && errp)\n\t\t*errp = err;\n\treturn x;\n}\n\nstatic int xfrm_del_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tint err = -ESRCH;\n\tstruct km_event c;\n\tstruct xfrm_usersa_id *p = nlmsg_data(nlh);\n\tkuid_t loginuid = audit_get_loginuid(current);\n\tu32 sessionid = audit_get_sessionid(current);\n\tu32 sid;\n\n\tx = xfrm_user_state_lookup(net, p, attrs, &err);\n\tif (x == NULL)\n\t\treturn err;\n\n\tif ((err = security_xfrm_state_delete(x)) != 0)\n\t\tgoto out;\n\n\tif (xfrm_state_kern(x)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = xfrm_state_delete(x);\n\n\tif (err < 0)\n\t\tgoto out;\n\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.event = nlh->nlmsg_type;\n\tkm_state_notify(x, &c);\n\nout:\n\tsecurity_task_getsecid(current, &sid);\n\txfrm_audit_state_delete(x, err ? 0 : 1, loginuid, sessionid, sid);\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->id, &x->id, sizeof(p->id));\n\tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n\tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}\n\nstruct xfrm_dump_info {\n\tstruct sk_buff *in_skb;\n\tstruct sk_buff *out_skb;\n\tu32 nlmsg_seq;\n\tu16 nlmsg_flags;\n};\n\nstatic int copy_sec_ctx(struct xfrm_sec_ctx *s, struct sk_buff *skb)\n{\n\tstruct xfrm_user_sec_ctx *uctx;\n\tstruct nlattr *attr;\n\tint ctx_size = sizeof(*uctx) + s->ctx_len;\n\n\tattr = nla_reserve(skb, XFRMA_SEC_CTX, ctx_size);\n\tif (attr == NULL)\n\t\treturn -EMSGSIZE;\n\n\tuctx = nla_data(attr);\n\tuctx->exttype = XFRMA_SEC_CTX;\n\tuctx->len = ctx_size;\n\tuctx->ctx_doi = s->ctx_doi;\n\tuctx->ctx_alg = s->ctx_alg;\n\tuctx->ctx_len = s->ctx_len;\n\tmemcpy(uctx + 1, s->ctx_str, s->ctx_len);\n\n\treturn 0;\n}\n\nstatic int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\talgo = nla_data(nla);\n\tstrncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\n\treturn 0;\n}\n\n/* Don't change this without updating xfrm_sa_len! */\nstatic int copy_to_user_state_extra(struct xfrm_state *x,\n\t\t\t\t    struct xfrm_usersa_info *p,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tint ret = 0;\n\n\tcopy_to_user_state(x, p);\n\n\tif (x->props.extra_flags) {\n\t\tret = nla_put_u32(skb, XFRMA_SA_EXTRA_FLAGS,\n\t\t\t\t  x->props.extra_flags);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (x->coaddr) {\n\t\tret = nla_put(skb, XFRMA_COADDR, sizeof(*x->coaddr), x->coaddr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->lastused) {\n\t\tret = nla_put_u64(skb, XFRMA_LASTUSED, x->lastused);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->aead) {\n\t\tret = nla_put(skb, XFRMA_ALG_AEAD, aead_len(x->aead), x->aead);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->aalg) {\n\t\tret = copy_to_user_auth(x->aalg, skb);\n\t\tif (!ret)\n\t\t\tret = nla_put(skb, XFRMA_ALG_AUTH_TRUNC,\n\t\t\t\t      xfrm_alg_auth_len(x->aalg), x->aalg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->ealg) {\n\t\tret = nla_put(skb, XFRMA_ALG_CRYPT, xfrm_alg_len(x->ealg), x->ealg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->calg) {\n\t\tret = nla_put(skb, XFRMA_ALG_COMP, sizeof(*(x->calg)), x->calg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->encap) {\n\t\tret = nla_put(skb, XFRMA_ENCAP, sizeof(*x->encap), x->encap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->tfcpad) {\n\t\tret = nla_put_u32(skb, XFRMA_TFCPAD, x->tfcpad);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tret = xfrm_mark_put(skb, &x->mark);\n\tif (ret)\n\t\tgoto out;\n\tif (x->replay_esn) {\n\t\tret = nla_put(skb, XFRMA_REPLAY_ESN_VAL,\n\t\t\t      xfrm_replay_state_esn_len(x->replay_esn),\n\t\t\t      x->replay_esn);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->security)\n\t\tret = copy_sec_ctx(x->security, skb);\n\tif (x->props.output_mark) {\n\t\tret = nla_put_u32(skb, XFRMA_OUTPUT_MARK, x->props.output_mark);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int dump_one_state(struct xfrm_state *x, int count, void *ptr)\n{\n\tstruct xfrm_dump_info *sp = ptr;\n\tstruct sk_buff *in_skb = sp->in_skb;\n\tstruct sk_buff *skb = sp->out_skb;\n\tstruct xfrm_usersa_info *p;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, sp->nlmsg_seq,\n\t\t\tXFRM_MSG_NEWSA, sizeof(*p), sp->nlmsg_flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tp = nlmsg_data(nlh);\n\n\terr = copy_to_user_state_extra(x, p, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\txfrm_state_walk_done(walk);\n\treturn 0;\n}\n\nstatic int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_state_walk_init(walk, 0);\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}\n\nstatic struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_state *x, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = dump_one_state(x, 0, &info);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic inline size_t xfrm_spdinfo_msgsize(void)\n{\n\treturn NLMSG_ALIGN(4)\n\t       + nla_total_size(sizeof(struct xfrmu_spdinfo))\n\t       + nla_total_size(sizeof(struct xfrmu_spdhinfo));\n}\n\nstatic int build_spdinfo(struct sk_buff *skb, struct net *net,\n\t\t\t u32 portid, u32 seq, u32 flags)\n{\n\tstruct xfrmk_spdinfo si;\n\tstruct xfrmu_spdinfo spc;\n\tstruct xfrmu_spdhinfo sph;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\tu32 *f;\n\n\tnlh = nlmsg_put(skb, portid, seq, XFRM_MSG_NEWSPDINFO, sizeof(u32), 0);\n\tif (nlh == NULL) /* shouldn't really happen ... */\n\t\treturn -EMSGSIZE;\n\n\tf = nlmsg_data(nlh);\n\t*f = flags;\n\txfrm_spd_getinfo(net, &si);\n\tspc.incnt = si.incnt;\n\tspc.outcnt = si.outcnt;\n\tspc.fwdcnt = si.fwdcnt;\n\tspc.inscnt = si.inscnt;\n\tspc.outscnt = si.outscnt;\n\tspc.fwdscnt = si.fwdscnt;\n\tsph.spdhcnt = si.spdhcnt;\n\tsph.spdhmcnt = si.spdhmcnt;\n\n\terr = nla_put(skb, XFRMA_SPD_INFO, sizeof(spc), &spc);\n\tif (!err)\n\t\terr = nla_put(skb, XFRMA_SPD_HINFO, sizeof(sph), &sph);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_get_spdinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct sk_buff *r_skb;\n\tu32 *flags = nlmsg_data(nlh);\n\tu32 sportid = NETLINK_CB(skb).portid;\n\tu32 seq = nlh->nlmsg_seq;\n\n\tr_skb = nlmsg_new(xfrm_spdinfo_msgsize(), GFP_ATOMIC);\n\tif (r_skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_spdinfo(r_skb, net, sportid, seq, *flags) < 0)\n\t\tBUG();\n\n\treturn nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid);\n}\n\nstatic inline size_t xfrm_sadinfo_msgsize(void)\n{\n\treturn NLMSG_ALIGN(4)\n\t       + nla_total_size(sizeof(struct xfrmu_sadhinfo))\n\t       + nla_total_size(4); /* XFRMA_SAD_CNT */\n}\n\nstatic int build_sadinfo(struct sk_buff *skb, struct net *net,\n\t\t\t u32 portid, u32 seq, u32 flags)\n{\n\tstruct xfrmk_sadinfo si;\n\tstruct xfrmu_sadhinfo sh;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\tu32 *f;\n\n\tnlh = nlmsg_put(skb, portid, seq, XFRM_MSG_NEWSADINFO, sizeof(u32), 0);\n\tif (nlh == NULL) /* shouldn't really happen ... */\n\t\treturn -EMSGSIZE;\n\n\tf = nlmsg_data(nlh);\n\t*f = flags;\n\txfrm_sad_getinfo(net, &si);\n\n\tsh.sadhmcnt = si.sadhmcnt;\n\tsh.sadhcnt = si.sadhcnt;\n\n\terr = nla_put_u32(skb, XFRMA_SAD_CNT, si.sadcnt);\n\tif (!err)\n\t\terr = nla_put(skb, XFRMA_SAD_HINFO, sizeof(sh), &sh);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_get_sadinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct sk_buff *r_skb;\n\tu32 *flags = nlmsg_data(nlh);\n\tu32 sportid = NETLINK_CB(skb).portid;\n\tu32 seq = nlh->nlmsg_seq;\n\n\tr_skb = nlmsg_new(xfrm_sadinfo_msgsize(), GFP_ATOMIC);\n\tif (r_skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_sadinfo(r_skb, net, sportid, seq, *flags) < 0)\n\t\tBUG();\n\n\treturn nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid);\n}\n\nstatic int xfrm_get_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_usersa_id *p = nlmsg_data(nlh);\n\tstruct xfrm_state *x;\n\tstruct sk_buff *resp_skb;\n\tint err = -ESRCH;\n\n\tx = xfrm_user_state_lookup(net, p, attrs, &err);\n\tif (x == NULL)\n\t\tgoto out_noput;\n\n\tresp_skb = xfrm_state_netlink(skb, x, nlh->nlmsg_seq);\n\tif (IS_ERR(resp_skb)) {\n\t\terr = PTR_ERR(resp_skb);\n\t} else {\n\t\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);\n\t}\n\txfrm_state_put(x);\nout_noput:\n\treturn err;\n}\n\nstatic int verify_userspi_info(struct xfrm_userspi_info *p)\n{\n\tswitch (p->info.id.proto) {\n\tcase IPPROTO_AH:\n\tcase IPPROTO_ESP:\n\t\tbreak;\n\n\tcase IPPROTO_COMP:\n\t\t/* IPCOMP spi is 16-bits. */\n\t\tif (p->max >= 0x10000)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (p->min > p->max)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int xfrm_alloc_userspi(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tstruct xfrm_userspi_info *p;\n\tstruct sk_buff *resp_skb;\n\txfrm_address_t *daddr;\n\tint family;\n\tint err;\n\tu32 mark;\n\tstruct xfrm_mark m;\n\n\tp = nlmsg_data(nlh);\n\terr = verify_userspi_info(p);\n\tif (err)\n\t\tgoto out_noput;\n\n\tfamily = p->info.family;\n\tdaddr = &p->info.id.daddr;\n\n\tx = NULL;\n\n\tmark = xfrm_mark_get(attrs, &m);\n\tif (p->info.seq) {\n\t\tx = xfrm_find_acq_byseq(net, mark, p->info.seq);\n\t\tif (x && !xfrm_addr_equal(&x->id.daddr, daddr, family)) {\n\t\t\txfrm_state_put(x);\n\t\t\tx = NULL;\n\t\t}\n\t}\n\n\tif (!x)\n\t\tx = xfrm_find_acq(net, &m, p->info.mode, p->info.reqid,\n\t\t\t\t  p->info.id.proto, daddr,\n\t\t\t\t  &p->info.saddr, 1,\n\t\t\t\t  family);\n\terr = -ENOENT;\n\tif (x == NULL)\n\t\tgoto out_noput;\n\n\terr = xfrm_alloc_spi(x, p->min, p->max);\n\tif (err)\n\t\tgoto out;\n\n\tresp_skb = xfrm_state_netlink(skb, x, nlh->nlmsg_seq);\n\tif (IS_ERR(resp_skb)) {\n\t\terr = PTR_ERR(resp_skb);\n\t\tgoto out;\n\t}\n\n\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);\n\nout:\n\txfrm_state_put(x);\nout_noput:\n\treturn err;\n}\n\nstatic int verify_policy_dir(u8 dir)\n{\n\tswitch (dir) {\n\tcase XFRM_POLICY_IN:\n\tcase XFRM_POLICY_OUT:\n\tcase XFRM_POLICY_FWD:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int verify_policy_type(u8 type)\n{\n\tswitch (type) {\n\tcase XFRM_POLICY_TYPE_MAIN:\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tcase XFRM_POLICY_TYPE_SUB:\n#endif\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn verify_policy_dir(p->dir);\n}\n\nstatic int copy_from_user_sec_ctx(struct xfrm_policy *pol, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\tstruct xfrm_user_sec_ctx *uctx;\n\n\tif (!rt)\n\t\treturn 0;\n\n\tuctx = nla_data(rt);\n\treturn security_xfrm_policy_alloc(&pol->security, uctx);\n}\n\nstatic void copy_templates(struct xfrm_policy *xp, struct xfrm_user_tmpl *ut,\n\t\t\t   int nr)\n{\n\tint i;\n\n\txp->xfrm_nr = nr;\n\tfor (i = 0; i < nr; i++, ut++) {\n\t\tstruct xfrm_tmpl *t = &xp->xfrm_vec[i];\n\n\t\tmemcpy(&t->id, &ut->id, sizeof(struct xfrm_id));\n\t\tmemcpy(&t->saddr, &ut->saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tt->reqid = ut->reqid;\n\t\tt->mode = ut->mode;\n\t\tt->share = ut->share;\n\t\tt->optional = ut->optional;\n\t\tt->aalgos = ut->aalgos;\n\t\tt->ealgos = ut->ealgos;\n\t\tt->calgos = ut->calgos;\n\t\t/* If all masks are ~0, then we allow all algorithms. */\n\t\tt->allalgs = !~(t->aalgos & t->ealgos & t->calgos);\n\t\tt->encap_family = ut->family;\n\t}\n}\n\nstatic int validate_tmpl(int nr, struct xfrm_user_tmpl *ut, u16 family)\n{\n\tint i;\n\n\tif (nr > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nr; i++) {\n\t\t/* We never validated the ut->family value, so many\n\t\t * applications simply leave it at zero.  The check was\n\t\t * never made and ut->family was ignored because all\n\t\t * templates could be assumed to have the same family as\n\t\t * the policy itself.  Now that we will have ipv4-in-ipv6\n\t\t * and ipv6-in-ipv4 tunnels, this is no longer true.\n\t\t */\n\t\tif (!ut[i].family)\n\t\t\tut[i].family = family;\n\n\t\tswitch (ut[i].family) {\n\t\tcase AF_INET:\n\t\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase AF_INET6:\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int copy_from_user_tmpl(struct xfrm_policy *pol, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_TMPL];\n\n\tif (!rt) {\n\t\tpol->xfrm_nr = 0;\n\t} else {\n\t\tstruct xfrm_user_tmpl *utmpl = nla_data(rt);\n\t\tint nr = nla_len(rt) / sizeof(*utmpl);\n\t\tint err;\n\n\t\terr = validate_tmpl(nr, utmpl, pol->family);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcopy_templates(pol, utmpl, nr);\n\t}\n\treturn 0;\n}\n\nstatic int copy_from_user_policy_type(u8 *tp, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_POLICY_TYPE];\n\tstruct xfrm_userpolicy_type *upt;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\n\tif (rt) {\n\t\tupt = nla_data(rt);\n\t\ttype = upt->type;\n\t}\n\n\terr = verify_policy_type(type);\n\tif (err)\n\t\treturn err;\n\n\t*tp = type;\n\treturn 0;\n}\n\nstatic void copy_from_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p)\n{\n\txp->priority = p->priority;\n\txp->index = p->index;\n\tmemcpy(&xp->selector, &p->sel, sizeof(xp->selector));\n\tmemcpy(&xp->lft, &p->lft, sizeof(xp->lft));\n\txp->action = p->action;\n\txp->flags = p->flags;\n\txp->family = p->sel.family;\n\t/* XXX xp->share = p->share; */\n}\n\nstatic void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n\tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; /* XXX xp->share */\n}\n\nstatic struct xfrm_policy *xfrm_policy_construct(struct net *net, struct xfrm_userpolicy_info *p, struct nlattr **attrs, int *errp)\n{\n\tstruct xfrm_policy *xp = xfrm_policy_alloc(net, GFP_KERNEL);\n\tint err;\n\n\tif (!xp) {\n\t\t*errp = -ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tcopy_from_user_policy(xp, p);\n\n\terr = copy_from_user_policy_type(&xp->type, attrs);\n\tif (err)\n\t\tgoto error;\n\n\tif (!(err = copy_from_user_tmpl(xp, attrs)))\n\t\terr = copy_from_user_sec_ctx(xp, attrs);\n\tif (err)\n\t\tgoto error;\n\n\txfrm_mark_get(attrs, &xp->mark);\n\n\treturn xp;\n error:\n\t*errp = err;\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn NULL;\n}\n\nstatic int xfrm_add_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_userpolicy_info *p = nlmsg_data(nlh);\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\tint err;\n\tint excl;\n\tkuid_t loginuid = audit_get_loginuid(current);\n\tu32 sessionid = audit_get_sessionid(current);\n\tu32 sid;\n\n\terr = verify_newpolicy_info(p);\n\tif (err)\n\t\treturn err;\n\terr = verify_sec_ctx_len(attrs);\n\tif (err)\n\t\treturn err;\n\n\txp = xfrm_policy_construct(net, p, attrs, &err);\n\tif (!xp)\n\t\treturn err;\n\n\t/* shouldn't excl be based on nlh flags??\n\t * Aha! this is anti-netlink really i.e  more pfkey derived\n\t * in netlink excl is a flag and you wouldnt need\n\t * a type XFRM_MSG_UPDPOLICY - JHS */\n\texcl = nlh->nlmsg_type == XFRM_MSG_NEWPOLICY;\n\terr = xfrm_policy_insert(p->dir, xp, excl);\n\tsecurity_task_getsecid(current, &sid);\n\txfrm_audit_policy_add(xp, err ? 0 : 1, loginuid, sessionid, sid);\n\n\tif (err) {\n\t\tsecurity_xfrm_policy_free(xp->security);\n\t\tkfree(xp);\n\t\treturn err;\n\t}\n\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tkm_policy_notify(xp, p->dir, &c);\n\n\txfrm_pol_put(xp);\n\n\treturn 0;\n}\n\nstatic int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\n\t\tmemset(up, 0, sizeof(*up));\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}\n\nstatic inline int copy_to_user_state_sec_ctx(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tif (x->security) {\n\t\treturn copy_sec_ctx(x->security, skb);\n\t}\n\treturn 0;\n}\n\nstatic inline int copy_to_user_sec_ctx(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tif (xp->security)\n\t\treturn copy_sec_ctx(xp->security, skb);\n\treturn 0;\n}\nstatic inline size_t userpolicy_type_attrsize(void)\n{\n#ifdef CONFIG_XFRM_SUB_POLICY\n\treturn nla_total_size(sizeof(struct xfrm_userpolicy_type));\n#else\n\treturn 0;\n#endif\n}\n\n#ifdef CONFIG_XFRM_SUB_POLICY\nstatic int copy_to_user_policy_type(u8 type, struct sk_buff *skb)\n{\n\tstruct xfrm_userpolicy_type upt = {\n\t\t.type = type,\n\t};\n\n\treturn nla_put(skb, XFRMA_POLICY_TYPE, sizeof(upt), &upt);\n}\n\n#else\nstatic inline int copy_to_user_policy_type(u8 type, struct sk_buff *skb)\n{\n\treturn 0;\n}\n#endif\n\nstatic int dump_one_policy(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tstruct xfrm_dump_info *sp = ptr;\n\tstruct xfrm_userpolicy_info *p;\n\tstruct sk_buff *in_skb = sp->in_skb;\n\tstruct sk_buff *skb = sp->out_skb;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, sp->nlmsg_seq,\n\t\t\tXFRM_MSG_NEWPOLICY, sizeof(*p), sp->nlmsg_flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tp = nlmsg_data(nlh);\n\tcopy_to_user_policy(xp, p, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_sec_ctx(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\n\txfrm_policy_walk_done(walk);\n\treturn 0;\n}\n\nstatic int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}\n\nstatic int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tstruct xfrm_dump_info info;\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\n\treturn skb->len;\n}\n\nstatic struct sk_buff *xfrm_policy_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_policy *xp,\n\t\t\t\t\t  int dir, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tint err;\n\n\terr = verify_policy_dir(dir);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = dump_one_policy(xp, dir, 0, &info);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic int xfrm_get_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_userpolicy_id *p;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\tstruct km_event c;\n\tint delete;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tp = nlmsg_data(nlh);\n\tdelete = nlh->nlmsg_type == XFRM_MSG_DELPOLICY;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_policy_dir(p->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (p->index)\n\t\txp = xfrm_policy_byid(net, mark, type, p->dir, p->index, delete, &err);\n\telse {\n\t\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\t\tstruct xfrm_sec_ctx *ctx;\n\n\t\terr = verify_sec_ctx_len(attrs);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tctx = NULL;\n\t\tif (rt) {\n\t\t\tstruct xfrm_user_sec_ctx *uctx = nla_data(rt);\n\n\t\t\terr = security_xfrm_policy_alloc(&ctx, uctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\txp = xfrm_policy_bysel_ctx(net, mark, type, p->dir, &p->sel,\n\t\t\t\t\t   ctx, delete, &err);\n\t\tsecurity_xfrm_policy_free(ctx);\n\t}\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (!delete) {\n\t\tstruct sk_buff *resp_skb;\n\n\t\tresp_skb = xfrm_policy_netlink(skb, xp, p->dir, nlh->nlmsg_seq);\n\t\tif (IS_ERR(resp_skb)) {\n\t\t\terr = PTR_ERR(resp_skb);\n\t\t} else {\n\t\t\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb,\n\t\t\t\t\t    NETLINK_CB(skb).portid);\n\t\t}\n\t} else {\n\t\tkuid_t loginuid = audit_get_loginuid(current);\n\t\tu32 sessionid = audit_get_sessionid(current);\n\t\tu32 sid;\n\n\t\tsecurity_task_getsecid(current, &sid);\n\t\txfrm_audit_policy_delete(xp, err ? 0 : 1, loginuid, sessionid,\n\t\t\t\t\t sid);\n\n\t\tif (err != 0)\n\t\t\tgoto out;\n\n\t\tc.data.byid = p->index;\n\t\tc.event = nlh->nlmsg_type;\n\t\tc.seq = nlh->nlmsg_seq;\n\t\tc.portid = nlh->nlmsg_pid;\n\t\tkm_policy_notify(xp, p->dir, &c);\n\t}\n\nout:\n\txfrm_pol_put(xp);\n\tif (delete && err == 0)\n\t\txfrm_garbage_collect(net);\n\treturn err;\n}\n\nstatic int xfrm_flush_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct km_event c;\n\tstruct xfrm_usersa_flush *p = nlmsg_data(nlh);\n\tstruct xfrm_audit audit_info;\n\tint err;\n\n\taudit_info.loginuid = audit_get_loginuid(current);\n\taudit_info.sessionid = audit_get_sessionid(current);\n\tsecurity_task_getsecid(current, &audit_info.secid);\n\terr = xfrm_state_flush(net, p->proto, &audit_info);\n\tif (err) {\n\t\tif (err == -ESRCH) /* empty table */\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tc.data.proto = p->proto;\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.net = net;\n\tkm_state_notify(NULL, &c);\n\n\treturn 0;\n}\n\nstatic inline size_t xfrm_aevent_msgsize(struct xfrm_state *x)\n{\n\tsize_t replay_size = x->replay_esn ?\n\t\t\t      xfrm_replay_state_esn_len(x->replay_esn) :\n\t\t\t      sizeof(struct xfrm_replay_state);\n\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_aevent_id))\n\t       + nla_total_size(replay_size)\n\t       + nla_total_size(sizeof(struct xfrm_lifetime_cur))\n\t       + nla_total_size(sizeof(struct xfrm_mark))\n\t       + nla_total_size(4) /* XFRM_AE_RTHR */\n\t       + nla_total_size(4); /* XFRM_AE_ETHR */\n}\n\nstatic int build_aevent(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct xfrm_aevent_id *id;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_NEWAE, sizeof(*id), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tid = nlmsg_data(nlh);\n\tmemcpy(&id->sa_id.daddr, &x->id.daddr,sizeof(x->id.daddr));\n\tid->sa_id.spi = x->id.spi;\n\tid->sa_id.family = x->props.family;\n\tid->sa_id.proto = x->id.proto;\n\tmemcpy(&id->saddr, &x->props.saddr,sizeof(x->props.saddr));\n\tid->reqid = x->props.reqid;\n\tid->flags = c->data.aevent;\n\n\tif (x->replay_esn) {\n\t\terr = nla_put(skb, XFRMA_REPLAY_ESN_VAL,\n\t\t\t      xfrm_replay_state_esn_len(x->replay_esn),\n\t\t\t      x->replay_esn);\n\t} else {\n\t\terr = nla_put(skb, XFRMA_REPLAY_VAL, sizeof(x->replay),\n\t\t\t      &x->replay);\n\t}\n\tif (err)\n\t\tgoto out_cancel;\n\terr = nla_put(skb, XFRMA_LTIME_VAL, sizeof(x->curlft), &x->curlft);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tif (id->flags & XFRM_AE_RTHR) {\n\t\terr = nla_put_u32(skb, XFRMA_REPLAY_THRESH, x->replay_maxdiff);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\tif (id->flags & XFRM_AE_ETHR) {\n\t\terr = nla_put_u32(skb, XFRMA_ETIMER_THRESH,\n\t\t\t\t  x->replay_maxage * 10 / HZ);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\terr = xfrm_mark_put(skb, &x->mark);\n\tif (err)\n\t\tgoto out_cancel;\n\n\treturn nlmsg_end(skb, nlh);\n\nout_cancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn err;\n}\n\nstatic int xfrm_get_ae(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tstruct sk_buff *r_skb;\n\tint err;\n\tstruct km_event c;\n\tu32 mark;\n\tstruct xfrm_mark m;\n\tstruct xfrm_aevent_id *p = nlmsg_data(nlh);\n\tstruct xfrm_usersa_id *id = &p->sa_id;\n\n\tmark = xfrm_mark_get(attrs, &m);\n\n\tx = xfrm_state_lookup(net, mark, &id->daddr, id->spi, id->proto, id->family);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tr_skb = nlmsg_new(xfrm_aevent_msgsize(x), GFP_ATOMIC);\n\tif (r_skb == NULL) {\n\t\txfrm_state_put(x);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * XXX: is this lock really needed - none of the other\n\t * gets lock (the concern is things getting updated\n\t * while we are still reading) - jhs\n\t*/\n\tspin_lock_bh(&x->lock);\n\tc.data.aevent = p->flags;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\n\tif (build_aevent(r_skb, x, &c) < 0)\n\t\tBUG();\n\terr = nlmsg_unicast(net->xfrm.nlsk, r_skb, NETLINK_CB(skb).portid);\n\tspin_unlock_bh(&x->lock);\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int xfrm_new_ae(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tstruct km_event c;\n\tint err = - EINVAL;\n\tu32 mark = 0;\n\tstruct xfrm_mark m;\n\tstruct xfrm_aevent_id *p = nlmsg_data(nlh);\n\tstruct nlattr *rp = attrs[XFRMA_REPLAY_VAL];\n\tstruct nlattr *re = attrs[XFRMA_REPLAY_ESN_VAL];\n\tstruct nlattr *lt = attrs[XFRMA_LTIME_VAL];\n\n\tif (!lt && !rp && !re)\n\t\treturn err;\n\n\t/* pedantic mode - thou shalt sayeth replaceth */\n\tif (!(nlh->nlmsg_flags&NLM_F_REPLACE))\n\t\treturn err;\n\n\tmark = xfrm_mark_get(attrs, &m);\n\n\tx = xfrm_state_lookup(net, mark, &p->sa_id.daddr, p->sa_id.spi, p->sa_id.proto, p->sa_id.family);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tif (x->km.state != XFRM_STATE_VALID)\n\t\tgoto out;\n\n\terr = xfrm_replay_verify_len(x->replay_esn, rp);\n\tif (err)\n\t\tgoto out;\n\n\tspin_lock_bh(&x->lock);\n\txfrm_update_ae_params(x, attrs, 1);\n\tspin_unlock_bh(&x->lock);\n\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.data.aevent = XFRM_AE_CU;\n\tkm_state_notify(x, &c);\n\terr = 0;\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int xfrm_flush_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct km_event c;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\tstruct xfrm_audit audit_info;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\taudit_info.loginuid = audit_get_loginuid(current);\n\taudit_info.sessionid = audit_get_sessionid(current);\n\tsecurity_task_getsecid(current, &audit_info.secid);\n\terr = xfrm_policy_flush(net, type, &audit_info);\n\tif (err) {\n\t\tif (err == -ESRCH) /* empty table */\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tc.data.type = type;\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.net = net;\n\tkm_policy_notify(NULL, 0, &c);\n\treturn 0;\n}\n\nstatic int xfrm_add_pol_expire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_user_polexpire *up = nlmsg_data(nlh);\n\tstruct xfrm_userpolicy_info *p = &up->pol;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err = -ENOENT;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_policy_dir(p->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (p->index)\n\t\txp = xfrm_policy_byid(net, mark, type, p->dir, p->index, 0, &err);\n\telse {\n\t\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\t\tstruct xfrm_sec_ctx *ctx;\n\n\t\terr = verify_sec_ctx_len(attrs);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tctx = NULL;\n\t\tif (rt) {\n\t\t\tstruct xfrm_user_sec_ctx *uctx = nla_data(rt);\n\n\t\t\terr = security_xfrm_policy_alloc(&ctx, uctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\txp = xfrm_policy_bysel_ctx(net, mark, type, p->dir,\n\t\t\t\t\t   &p->sel, ctx, 0, &err);\n\t\tsecurity_xfrm_policy_free(ctx);\n\t}\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (unlikely(xp->walk.dead))\n\t\tgoto out;\n\n\terr = 0;\n\tif (up->hard) {\n\t\tkuid_t loginuid = audit_get_loginuid(current);\n\t\tu32 sessionid = audit_get_sessionid(current);\n\t\tu32 sid;\n\n\t\tsecurity_task_getsecid(current, &sid);\n\t\txfrm_policy_delete(xp, p->dir);\n\t\txfrm_audit_policy_delete(xp, 1, loginuid, sessionid, sid);\n\n\t} else {\n\t\t// reset the timers here?\n\t\tWARN(1, \"Dont know what to do with soft policy expire\\n\");\n\t}\n\tkm_policy_expired(xp, p->dir, up->hard, nlh->nlmsg_pid);\n\nout:\n\txfrm_pol_put(xp);\n\treturn err;\n}\n\nstatic int xfrm_add_sa_expire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct xfrm_user_expire *ue = nlmsg_data(nlh);\n\tstruct xfrm_usersa_info *p = &ue->state;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tx = xfrm_state_lookup(net, mark, &p->id.daddr, p->id.spi, p->id.proto, p->family);\n\n\terr = -ENOENT;\n\tif (x == NULL)\n\t\treturn err;\n\n\tspin_lock_bh(&x->lock);\n\terr = -EINVAL;\n\tif (x->km.state != XFRM_STATE_VALID)\n\t\tgoto out;\n\tkm_state_expired(x, ue->hard, nlh->nlmsg_pid);\n\n\tif (ue->hard) {\n\t\tkuid_t loginuid = audit_get_loginuid(current);\n\t\tu32 sessionid = audit_get_sessionid(current);\n\t\tu32 sid;\n\n\t\tsecurity_task_getsecid(current, &sid);\n\t\t__xfrm_state_delete(x);\n\t\txfrm_audit_state_delete(x, 1, loginuid, sessionid, sid);\n\t}\n\terr = 0;\nout:\n\tspin_unlock_bh(&x->lock);\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int xfrm_add_acquire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_user_tmpl *ut;\n\tint i;\n\tstruct nlattr *rt = attrs[XFRMA_TMPL];\n\tstruct xfrm_mark mark;\n\n\tstruct xfrm_user_acquire *ua = nlmsg_data(nlh);\n\tstruct xfrm_state *x = xfrm_state_alloc(net);\n\tint err = -ENOMEM;\n\n\tif (!x)\n\t\tgoto nomem;\n\n\txfrm_mark_get(attrs, &mark);\n\n\terr = verify_newpolicy_info(&ua->policy);\n\tif (err)\n\t\tgoto bad_policy;\n\n\t/*   build an XP */\n\txp = xfrm_policy_construct(net, &ua->policy, attrs, &err);\n\tif (!xp)\n\t\tgoto free_state;\n\n\tmemcpy(&x->id, &ua->id, sizeof(ua->id));\n\tmemcpy(&x->props.saddr, &ua->saddr, sizeof(ua->saddr));\n\tmemcpy(&x->sel, &ua->sel, sizeof(ua->sel));\n\txp->mark.m = x->mark.m = mark.m;\n\txp->mark.v = x->mark.v = mark.v;\n\tut = nla_data(rt);\n\t/* extract the templates and for each call km_key */\n\tfor (i = 0; i < xp->xfrm_nr; i++, ut++) {\n\t\tstruct xfrm_tmpl *t = &xp->xfrm_vec[i];\n\t\tmemcpy(&x->id, &t->id, sizeof(x->id));\n\t\tx->props.mode = t->mode;\n\t\tx->props.reqid = t->reqid;\n\t\tx->props.family = ut->family;\n\t\tt->aalgos = ua->aalgos;\n\t\tt->ealgos = ua->ealgos;\n\t\tt->calgos = ua->calgos;\n\t\terr = km_query(x, t, xp);\n\n\t}\n\n\tkfree(x);\n\tkfree(xp);\n\n\treturn 0;\n\nbad_policy:\n\tWARN(1, \"BAD policy passed\\n\");\nfree_state:\n\tkfree(x);\nnomem:\n\treturn err;\n}\n\n#ifdef CONFIG_XFRM_MIGRATE\nstatic int copy_from_user_migrate(struct xfrm_migrate *ma,\n\t\t\t\t  struct xfrm_kmaddress *k,\n\t\t\t\t  struct nlattr **attrs, int *num)\n{\n\tstruct nlattr *rt = attrs[XFRMA_MIGRATE];\n\tstruct xfrm_user_migrate *um;\n\tint i, num_migrate;\n\n\tif (k != NULL) {\n\t\tstruct xfrm_user_kmaddress *uk;\n\n\t\tuk = nla_data(attrs[XFRMA_KMADDRESS]);\n\t\tmemcpy(&k->local, &uk->local, sizeof(k->local));\n\t\tmemcpy(&k->remote, &uk->remote, sizeof(k->remote));\n\t\tk->family = uk->family;\n\t\tk->reserved = uk->reserved;\n\t}\n\n\tum = nla_data(rt);\n\tnum_migrate = nla_len(rt) / sizeof(*um);\n\n\tif (num_migrate <= 0 || num_migrate > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_migrate; i++, um++, ma++) {\n\t\tmemcpy(&ma->old_daddr, &um->old_daddr, sizeof(ma->old_daddr));\n\t\tmemcpy(&ma->old_saddr, &um->old_saddr, sizeof(ma->old_saddr));\n\t\tmemcpy(&ma->new_daddr, &um->new_daddr, sizeof(ma->new_daddr));\n\t\tmemcpy(&ma->new_saddr, &um->new_saddr, sizeof(ma->new_saddr));\n\n\t\tma->proto = um->proto;\n\t\tma->mode = um->mode;\n\t\tma->reqid = um->reqid;\n\n\t\tma->old_family = um->old_family;\n\t\tma->new_family = um->new_family;\n\t}\n\n\t*num = i;\n\treturn 0;\n}\n\nstatic int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t   struct nlattr **attrs)\n{\n\tstruct xfrm_userpolicy_id *pi = nlmsg_data(nlh);\n\tstruct xfrm_migrate m[XFRM_MAX_DEPTH];\n\tstruct xfrm_kmaddress km, *kmp;\n\tu8 type;\n\tint err;\n\tint n = 0;\n\n\terr = verify_policy_dir(pi->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (attrs[XFRMA_MIGRATE] == NULL)\n\t\treturn -EINVAL;\n\n\tkmp = attrs[XFRMA_KMADDRESS] ? &km : NULL;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = copy_from_user_migrate((struct xfrm_migrate *)m, kmp, attrs, &n);\n\tif (err)\n\t\treturn err;\n\n\tif (!n)\n\t\treturn 0;\n\n\txfrm_migrate(&pi->sel, pi->dir, type, m, n, kmp);\n\n\treturn 0;\n}\n#else\nstatic int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t   struct nlattr **attrs)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\n#ifdef CONFIG_XFRM_MIGRATE\nstatic int copy_to_user_migrate(const struct xfrm_migrate *m, struct sk_buff *skb)\n{\n\tstruct xfrm_user_migrate um;\n\n\tmemset(&um, 0, sizeof(um));\n\tum.proto = m->proto;\n\tum.mode = m->mode;\n\tum.reqid = m->reqid;\n\tum.old_family = m->old_family;\n\tmemcpy(&um.old_daddr, &m->old_daddr, sizeof(um.old_daddr));\n\tmemcpy(&um.old_saddr, &m->old_saddr, sizeof(um.old_saddr));\n\tum.new_family = m->new_family;\n\tmemcpy(&um.new_daddr, &m->new_daddr, sizeof(um.new_daddr));\n\tmemcpy(&um.new_saddr, &m->new_saddr, sizeof(um.new_saddr));\n\n\treturn nla_put(skb, XFRMA_MIGRATE, sizeof(um), &um);\n}\n\nstatic int copy_to_user_kmaddress(const struct xfrm_kmaddress *k, struct sk_buff *skb)\n{\n\tstruct xfrm_user_kmaddress uk;\n\n\tmemset(&uk, 0, sizeof(uk));\n\tuk.family = k->family;\n\tuk.reserved = k->reserved;\n\tmemcpy(&uk.local, &k->local, sizeof(uk.local));\n\tmemcpy(&uk.remote, &k->remote, sizeof(uk.remote));\n\n\treturn nla_put(skb, XFRMA_KMADDRESS, sizeof(uk), &uk);\n}\n\nstatic inline size_t xfrm_migrate_msgsize(int num_migrate, int with_kma)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_userpolicy_id))\n\t      + (with_kma ? nla_total_size(sizeof(struct xfrm_kmaddress)) : 0)\n\t      + nla_total_size(sizeof(struct xfrm_user_migrate) * num_migrate)\n\t      + userpolicy_type_attrsize();\n}\n\nstatic int build_migrate(struct sk_buff *skb, const struct xfrm_migrate *m,\n\t\t\t int num_migrate, const struct xfrm_kmaddress *k,\n\t\t\t const struct xfrm_selector *sel, u8 dir, u8 type)\n{\n\tconst struct xfrm_migrate *mp;\n\tstruct xfrm_userpolicy_id *pol_id;\n\tstruct nlmsghdr *nlh;\n\tint i, err;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_MIGRATE, sizeof(*pol_id), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tpol_id = nlmsg_data(nlh);\n\t/* copy data from selector, dir, and type to the pol_id */\n\tmemset(pol_id, 0, sizeof(*pol_id));\n\tmemcpy(&pol_id->sel, sel, sizeof(pol_id->sel));\n\tpol_id->dir = dir;\n\n\tif (k != NULL) {\n\t\terr = copy_to_user_kmaddress(k, skb);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\terr = copy_to_user_policy_type(type, skb);\n\tif (err)\n\t\tgoto out_cancel;\n\tfor (i = 0, mp = m ; i < num_migrate; i++, mp++) {\n\t\terr = copy_to_user_migrate(mp, skb);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\n\treturn nlmsg_end(skb, nlh);\n\nout_cancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn err;\n}\n\nstatic int xfrm_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t     const struct xfrm_migrate *m, int num_migrate,\n\t\t\t     const struct xfrm_kmaddress *k)\n{\n\tstruct net *net = &init_net;\n\tstruct sk_buff *skb;\n\tint err;\n\n\terr = verify_policy_dir(dir);\n\tif (err)\n\t\treturn err;\n\n\tskb = nlmsg_new(xfrm_migrate_msgsize(num_migrate, !!k), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\t/* build migrate */\n\tif (build_migrate(skb, m, num_migrate, k, sel, dir, type) < 0)\n\t\tBUG();\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_MIGRATE, GFP_ATOMIC);\n}\n#else\nstatic int xfrm_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t     const struct xfrm_migrate *m, int num_migrate,\n\t\t\t     const struct xfrm_kmaddress *k)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\n#define XMSGSIZE(type) sizeof(struct type)\n\nstatic const int xfrm_msg_min[XFRM_NR_MSGTYPES] = {\n\t[XFRM_MSG_NEWSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_info),\n\t[XFRM_MSG_DELSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_id),\n\t[XFRM_MSG_GETSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_id),\n\t[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_info),\n\t[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userspi_info),\n\t[XFRM_MSG_ACQUIRE     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_acquire),\n\t[XFRM_MSG_EXPIRE      - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_expire),\n\t[XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_info),\n\t[XFRM_MSG_UPDSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_info),\n\t[XFRM_MSG_POLEXPIRE   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_polexpire),\n\t[XFRM_MSG_FLUSHSA     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_flush),\n\t[XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = 0,\n\t[XFRM_MSG_NEWAE       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_aevent_id),\n\t[XFRM_MSG_GETAE       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_aevent_id),\n\t[XFRM_MSG_REPORT      - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_report),\n\t[XFRM_MSG_MIGRATE     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_GETSADINFO  - XFRM_MSG_BASE] = sizeof(u32),\n\t[XFRM_MSG_GETSPDINFO  - XFRM_MSG_BASE] = sizeof(u32),\n};\n\n#undef XMSGSIZE\n\nstatic const struct nla_policy xfrma_policy[XFRMA_MAX+1] = {\n\t[XFRMA_SA]\t\t= { .len = sizeof(struct xfrm_usersa_info)},\n\t[XFRMA_POLICY]\t\t= { .len = sizeof(struct xfrm_userpolicy_info)},\n\t[XFRMA_LASTUSED]\t= { .type = NLA_U64},\n\t[XFRMA_ALG_AUTH_TRUNC]\t= { .len = sizeof(struct xfrm_algo_auth)},\n\t[XFRMA_ALG_AEAD]\t= { .len = sizeof(struct xfrm_algo_aead) },\n\t[XFRMA_ALG_AUTH]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ALG_CRYPT]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ALG_COMP]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ENCAP]\t\t= { .len = sizeof(struct xfrm_encap_tmpl) },\n\t[XFRMA_TMPL]\t\t= { .len = sizeof(struct xfrm_user_tmpl) },\n\t[XFRMA_SEC_CTX]\t\t= { .len = sizeof(struct xfrm_sec_ctx) },\n\t[XFRMA_LTIME_VAL]\t= { .len = sizeof(struct xfrm_lifetime_cur) },\n\t[XFRMA_REPLAY_VAL]\t= { .len = sizeof(struct xfrm_replay_state) },\n\t[XFRMA_REPLAY_THRESH]\t= { .type = NLA_U32 },\n\t[XFRMA_ETIMER_THRESH]\t= { .type = NLA_U32 },\n\t[XFRMA_SRCADDR]\t\t= { .len = sizeof(xfrm_address_t) },\n\t[XFRMA_COADDR]\t\t= { .len = sizeof(xfrm_address_t) },\n\t[XFRMA_POLICY_TYPE]\t= { .len = sizeof(struct xfrm_userpolicy_type)},\n\t[XFRMA_MIGRATE]\t\t= { .len = sizeof(struct xfrm_user_migrate) },\n\t[XFRMA_KMADDRESS]\t= { .len = sizeof(struct xfrm_user_kmaddress) },\n\t[XFRMA_MARK]\t\t= { .len = sizeof(struct xfrm_mark) },\n\t[XFRMA_TFCPAD]\t\t= { .type = NLA_U32 },\n\t[XFRMA_REPLAY_ESN_VAL]\t= { .len = sizeof(struct xfrm_replay_state_esn) },\n\t[XFRMA_SA_EXTRA_FLAGS]\t= { .type = NLA_U32 },\n\t[XFRMA_OUTPUT_MARK]\t= { .len = NLA_U32 },\n};\n\nstatic const struct xfrm_link {\n\tint (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);\n\tint (*start)(struct netlink_callback *);\n\tint (*dump)(struct sk_buff *, struct netlink_callback *);\n\tint (*done)(struct netlink_callback *);\n} xfrm_dispatch[XFRM_NR_MSGTYPES] = {\n\t[XFRM_MSG_NEWSA       - XFRM_MSG_BASE] = { .doit = xfrm_add_sa        },\n\t[XFRM_MSG_DELSA       - XFRM_MSG_BASE] = { .doit = xfrm_del_sa        },\n\t[XFRM_MSG_GETSA       - XFRM_MSG_BASE] = { .doit = xfrm_get_sa,\n\t\t\t\t\t\t   .dump = xfrm_dump_sa,\n\t\t\t\t\t\t   .done = xfrm_dump_sa_done  },\n\t[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },\n\t[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy    },\n\t[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy,\n\t\t\t\t\t\t   .start = xfrm_dump_policy_start,\n\t\t\t\t\t\t   .dump = xfrm_dump_policy,\n\t\t\t\t\t\t   .done = xfrm_dump_policy_done },\n\t[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = { .doit = xfrm_alloc_userspi },\n\t[XFRM_MSG_ACQUIRE     - XFRM_MSG_BASE] = { .doit = xfrm_add_acquire   },\n\t[XFRM_MSG_EXPIRE      - XFRM_MSG_BASE] = { .doit = xfrm_add_sa_expire },\n\t[XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },\n\t[XFRM_MSG_UPDSA       - XFRM_MSG_BASE] = { .doit = xfrm_add_sa        },\n\t[XFRM_MSG_POLEXPIRE   - XFRM_MSG_BASE] = { .doit = xfrm_add_pol_expire},\n\t[XFRM_MSG_FLUSHSA     - XFRM_MSG_BASE] = { .doit = xfrm_flush_sa      },\n\t[XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = { .doit = xfrm_flush_policy  },\n\t[XFRM_MSG_NEWAE       - XFRM_MSG_BASE] = { .doit = xfrm_new_ae  },\n\t[XFRM_MSG_GETAE       - XFRM_MSG_BASE] = { .doit = xfrm_get_ae  },\n\t[XFRM_MSG_MIGRATE     - XFRM_MSG_BASE] = { .doit = xfrm_do_migrate    },\n\t[XFRM_MSG_GETSADINFO  - XFRM_MSG_BASE] = { .doit = xfrm_get_sadinfo   },\n\t[XFRM_MSG_GETSPDINFO  - XFRM_MSG_BASE] = { .doit = xfrm_get_spdinfo   },\n};\n\nstatic int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,\n\t\t\t  xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n\nstatic void xfrm_netlink_rcv(struct sk_buff *skb)\n{\n\tmutex_lock(&xfrm_cfg_mutex);\n\tnetlink_rcv_skb(skb, &xfrm_user_rcv_msg);\n\tmutex_unlock(&xfrm_cfg_mutex);\n}\n\nstatic inline size_t xfrm_expire_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_expire))\n\t       + nla_total_size(sizeof(struct xfrm_mark));\n}\n\nstatic int build_expire(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct xfrm_user_expire *ue;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, 0, XFRM_MSG_EXPIRE, sizeof(*ue), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tue = nlmsg_data(nlh);\n\tcopy_to_user_state(x, &ue->state);\n\tue->hard = (c->data.hard != 0) ? 1 : 0;\n\n\terr = xfrm_mark_put(skb, &x->mark);\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_exp_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_expire_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_expire(skb, x, c) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_EXPIRE, GFP_ATOMIC);\n}\n\nstatic int xfrm_aevent_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_aevent_msgsize(x), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_aevent(skb, x, c) < 0)\n\t\tBUG();\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_AEVENTS, GFP_ATOMIC);\n}\n\nstatic int xfrm_notify_sa_flush(const struct km_event *c)\n{\n\tstruct net *net = c->net;\n\tstruct xfrm_usersa_flush *p;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint len = NLMSG_ALIGN(sizeof(struct xfrm_usersa_flush));\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_FLUSHSA, sizeof(*p), 0);\n\tif (nlh == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tp = nlmsg_data(nlh);\n\tp->proto = c->data.proto;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_SA, GFP_ATOMIC);\n}\n\nstatic inline size_t xfrm_sa_len(struct xfrm_state *x)\n{\n\tsize_t l = 0;\n\tif (x->aead)\n\t\tl += nla_total_size(aead_len(x->aead));\n\tif (x->aalg) {\n\t\tl += nla_total_size(sizeof(struct xfrm_algo) +\n\t\t\t\t    (x->aalg->alg_key_len + 7) / 8);\n\t\tl += nla_total_size(xfrm_alg_auth_len(x->aalg));\n\t}\n\tif (x->ealg)\n\t\tl += nla_total_size(xfrm_alg_len(x->ealg));\n\tif (x->calg)\n\t\tl += nla_total_size(sizeof(*x->calg));\n\tif (x->encap)\n\t\tl += nla_total_size(sizeof(*x->encap));\n\tif (x->tfcpad)\n\t\tl += nla_total_size(sizeof(x->tfcpad));\n\tif (x->replay_esn)\n\t\tl += nla_total_size(xfrm_replay_state_esn_len(x->replay_esn));\n\tif (x->security)\n\t\tl += nla_total_size(sizeof(struct xfrm_user_sec_ctx) +\n\t\t\t\t    x->security->ctx_len);\n\tif (x->coaddr)\n\t\tl += nla_total_size(sizeof(*x->coaddr));\n\tif (x->props.extra_flags)\n\t\tl += nla_total_size(sizeof(x->props.extra_flags));\n\tif (x->props.output_mark)\n\t\tl += nla_total_size(sizeof(x->props.output_mark));\n\n\t/* Must count x->lastused as it may become non-zero behind our back. */\n\tl += nla_total_size(sizeof(u64));\n\n\treturn l;\n}\n\nstatic int xfrm_notify_sa(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct xfrm_usersa_info *p;\n\tstruct xfrm_usersa_id *id;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint len = xfrm_sa_len(x);\n\tint headlen, err;\n\n\theadlen = sizeof(*p);\n\tif (c->event == XFRM_MSG_DELSA) {\n\t\tlen += nla_total_size(headlen);\n\t\theadlen = sizeof(*id);\n\t\tlen += nla_total_size(sizeof(struct xfrm_mark));\n\t}\n\tlen += NLMSG_ALIGN(headlen);\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, c->event, headlen, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\n\tp = nlmsg_data(nlh);\n\tif (c->event == XFRM_MSG_DELSA) {\n\t\tstruct nlattr *attr;\n\n\t\tid = nlmsg_data(nlh);\n\t\tmemcpy(&id->daddr, &x->id.daddr, sizeof(id->daddr));\n\t\tid->spi = x->id.spi;\n\t\tid->family = x->props.family;\n\t\tid->proto = x->id.proto;\n\n\t\tattr = nla_reserve(skb, XFRMA_SA, sizeof(*p));\n\t\terr = -EMSGSIZE;\n\t\tif (attr == NULL)\n\t\t\tgoto out_free_skb;\n\n\t\tp = nla_data(attr);\n\t}\n\terr = copy_to_user_state_extra(x, p, skb);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_SA, GFP_ATOMIC);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int xfrm_send_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn xfrm_exp_state_notify(x, c);\n\tcase XFRM_MSG_NEWAE:\n\t\treturn xfrm_aevent_state_notify(x, c);\n\tcase XFRM_MSG_DELSA:\n\tcase XFRM_MSG_UPDSA:\n\tcase XFRM_MSG_NEWSA:\n\t\treturn xfrm_notify_sa(x, c);\n\tcase XFRM_MSG_FLUSHSA:\n\t\treturn xfrm_notify_sa_flush(c);\n\tdefault:\n\t\tprintk(KERN_NOTICE \"xfrm_user: Unknown SA event %d\\n\",\n\t\t       c->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n\n}\n\nstatic inline size_t xfrm_acquire_msgsize(struct xfrm_state *x,\n\t\t\t\t\t  struct xfrm_policy *xp)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_acquire))\n\t       + nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr)\n\t       + nla_total_size(sizeof(struct xfrm_mark))\n\t       + nla_total_size(xfrm_user_sec_ctx_size(x->security))\n\t       + userpolicy_type_attrsize();\n}\n\nstatic int build_acquire(struct sk_buff *skb, struct xfrm_state *x,\n\t\t\t struct xfrm_tmpl *xt, struct xfrm_policy *xp)\n{\n\t__u32 seq = xfrm_get_acqseq();\n\tstruct xfrm_user_acquire *ua;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_ACQUIRE, sizeof(*ua), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tua = nlmsg_data(nlh);\n\tmemcpy(&ua->id, &x->id, sizeof(ua->id));\n\tmemcpy(&ua->saddr, &x->props.saddr, sizeof(ua->saddr));\n\tmemcpy(&ua->sel, &x->sel, sizeof(ua->sel));\n\tcopy_to_user_policy(xp, &ua->policy, XFRM_POLICY_OUT);\n\tua->aalgos = xt->aalgos;\n\tua->ealgos = xt->ealgos;\n\tua->calgos = xt->calgos;\n\tua->seq = x->km.seq = seq;\n\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_state_sec_ctx(x, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *xt,\n\t\t\t     struct xfrm_policy *xp)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_acquire_msgsize(x, xp), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_acquire(skb, x, xt, xp) < 0)\n\t\tBUG();\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_ACQUIRE, GFP_ATOMIC);\n}\n\n/* User gives us xfrm_user_policy_info followed by an array of 0\n * or more templates.\n */\nstatic struct xfrm_policy *xfrm_compile_policy(struct sock *sk, int opt,\n\t\t\t\t\t       u8 *data, int len, int *dir)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_userpolicy_info *p = (struct xfrm_userpolicy_info *)data;\n\tstruct xfrm_user_tmpl *ut = (struct xfrm_user_tmpl *) (p + 1);\n\tstruct xfrm_policy *xp;\n\tint nr;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tif (opt != IP_XFRM_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (opt != IPV6_XFRM_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\t*dir = -EINVAL;\n\t\treturn NULL;\n\t}\n\n\t*dir = -EINVAL;\n\n\tif (len < sizeof(*p) ||\n\t    verify_newpolicy_info(p))\n\t\treturn NULL;\n\n\tnr = ((len - sizeof(*p)) / sizeof(*ut));\n\tif (validate_tmpl(nr, ut, p->sel.family))\n\t\treturn NULL;\n\n\tif (p->dir > XFRM_POLICY_OUT)\n\t\treturn NULL;\n\n\txp = xfrm_policy_alloc(net, GFP_ATOMIC);\n\tif (xp == NULL) {\n\t\t*dir = -ENOBUFS;\n\t\treturn NULL;\n\t}\n\n\tcopy_from_user_policy(xp, p);\n\txp->type = XFRM_POLICY_TYPE_MAIN;\n\tcopy_templates(xp, ut, nr);\n\n\t*dir = p->dir;\n\n\treturn xp;\n}\n\nstatic inline size_t xfrm_polexpire_msgsize(struct xfrm_policy *xp)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_polexpire))\n\t       + nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr)\n\t       + nla_total_size(xfrm_user_sec_ctx_size(xp->security))\n\t       + nla_total_size(sizeof(struct xfrm_mark))\n\t       + userpolicy_type_attrsize();\n}\n\nstatic int build_polexpire(struct sk_buff *skb, struct xfrm_policy *xp,\n\t\t\t   int dir, const struct km_event *c)\n{\n\tstruct xfrm_user_polexpire *upe;\n\tint hard = c->data.hard;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, 0, XFRM_MSG_POLEXPIRE, sizeof(*upe), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tupe = nlmsg_data(nlh);\n\tcopy_to_user_policy(xp, &upe->pol, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_sec_ctx(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tupe->hard = !!hard;\n\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tstruct net *net = xp_net(xp);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_polexpire(skb, xp, dir, c) < 0)\n\t\tBUG();\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_EXPIRE, GFP_ATOMIC);\n}\n\nstatic int xfrm_notify_policy(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tint len = nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr);\n\tstruct net *net = xp_net(xp);\n\tstruct xfrm_userpolicy_info *p;\n\tstruct xfrm_userpolicy_id *id;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint headlen, err;\n\n\theadlen = sizeof(*p);\n\tif (c->event == XFRM_MSG_DELPOLICY) {\n\t\tlen += nla_total_size(headlen);\n\t\theadlen = sizeof(*id);\n\t}\n\tlen += userpolicy_type_attrsize();\n\tlen += nla_total_size(sizeof(struct xfrm_mark));\n\tlen += NLMSG_ALIGN(headlen);\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, c->event, headlen, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\n\tp = nlmsg_data(nlh);\n\tif (c->event == XFRM_MSG_DELPOLICY) {\n\t\tstruct nlattr *attr;\n\n\t\tid = nlmsg_data(nlh);\n\t\tmemset(id, 0, sizeof(*id));\n\t\tid->dir = dir;\n\t\tif (c->data.byid)\n\t\t\tid->index = xp->index;\n\t\telse\n\t\t\tmemcpy(&id->sel, &xp->selector, sizeof(id->sel));\n\n\t\tattr = nla_reserve(skb, XFRMA_POLICY, sizeof(*p));\n\t\terr = -EMSGSIZE;\n\t\tif (attr == NULL)\n\t\t\tgoto out_free_skb;\n\n\t\tp = nla_data(attr);\n\t}\n\n\tcopy_to_user_policy(xp, p, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_POLICY, GFP_ATOMIC);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int xfrm_notify_policy_flush(const struct km_event *c)\n{\n\tstruct net *net = c->net;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(userpolicy_type_attrsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_FLUSHPOLICY, 0, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\terr = copy_to_user_policy_type(c->data.type, skb);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_POLICY, GFP_ATOMIC);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int xfrm_send_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tint err;\n\n\terr = verify_policy_dir(dir);\n\tif (err)\n\t\treturn err;\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_NEWPOLICY:\n\tcase XFRM_MSG_UPDPOLICY:\n\tcase XFRM_MSG_DELPOLICY:\n\t\treturn xfrm_notify_policy(xp, dir, c);\n\tcase XFRM_MSG_FLUSHPOLICY:\n\t\treturn xfrm_notify_policy_flush(c);\n\tcase XFRM_MSG_POLEXPIRE:\n\t\treturn xfrm_exp_policy_notify(xp, dir, c);\n\tdefault:\n\t\tprintk(KERN_NOTICE \"xfrm_user: Unknown Policy event %d\\n\",\n\t\t       c->event);\n\t}\n\n\treturn 0;\n\n}\n\nstatic inline size_t xfrm_report_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_report));\n}\n\nstatic int build_report(struct sk_buff *skb, u8 proto,\n\t\t\tstruct xfrm_selector *sel, xfrm_address_t *addr)\n{\n\tstruct xfrm_user_report *ur;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_REPORT, sizeof(*ur), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tur = nlmsg_data(nlh);\n\tur->proto = proto;\n\tmemcpy(&ur->sel, sel, sizeof(ur->sel));\n\n\tif (addr) {\n\t\tint err = nla_put(skb, XFRMA_COADDR, sizeof(*addr), addr);\n\t\tif (err) {\n\t\t\tnlmsg_cancel(skb, nlh);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_send_report(struct net *net, u8 proto,\n\t\t\t    struct xfrm_selector *sel, xfrm_address_t *addr)\n{\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_report_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_report(skb, proto, sel, addr) < 0)\n\t\tBUG();\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_REPORT, GFP_ATOMIC);\n}\n\nstatic inline size_t xfrm_mapping_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_mapping));\n}\n\nstatic int build_mapping(struct sk_buff *skb, struct xfrm_state *x,\n\t\t\t xfrm_address_t *new_saddr, __be16 new_sport)\n{\n\tstruct xfrm_user_mapping *um;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_MAPPING, sizeof(*um), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tum = nlmsg_data(nlh);\n\n\tmemcpy(&um->id.daddr, &x->id.daddr, sizeof(um->id.daddr));\n\tum->id.spi = x->id.spi;\n\tum->id.family = x->props.family;\n\tum->id.proto = x->id.proto;\n\tmemcpy(&um->new_saddr, new_saddr, sizeof(um->new_saddr));\n\tmemcpy(&um->old_saddr, &x->props.saddr, sizeof(um->old_saddr));\n\tum->new_sport = new_sport;\n\tum->old_sport = x->encap->encap_sport;\n\tum->reqid = x->props.reqid;\n\n\treturn nlmsg_end(skb, nlh);\n}\n\nstatic int xfrm_send_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr,\n\t\t\t     __be16 sport)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tif (x->id.proto != IPPROTO_ESP)\n\t\treturn -EINVAL;\n\n\tif (!x->encap)\n\t\treturn -EINVAL;\n\n\tskb = nlmsg_new(xfrm_mapping_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_mapping(skb, x, ipaddr, sport) < 0)\n\t\tBUG();\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_MAPPING, GFP_ATOMIC);\n}\n\nstatic struct xfrm_mgr netlink_mgr = {\n\t.id\t\t= \"netlink\",\n\t.notify\t\t= xfrm_send_state_notify,\n\t.acquire\t= xfrm_send_acquire,\n\t.compile_policy\t= xfrm_compile_policy,\n\t.notify_policy\t= xfrm_send_policy_notify,\n\t.report\t\t= xfrm_send_report,\n\t.migrate\t= xfrm_send_migrate,\n\t.new_mapping\t= xfrm_send_mapping,\n};\n\nstatic int __net_init xfrm_user_net_init(struct net *net)\n{\n\tstruct sock *nlsk;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= XFRMNLGRP_MAX,\n\t\t.input\t= xfrm_netlink_rcv,\n\t};\n\n\tnlsk = netlink_kernel_create(net, NETLINK_XFRM, &cfg);\n\tif (nlsk == NULL)\n\t\treturn -ENOMEM;\n\tnet->xfrm.nlsk_stash = nlsk; /* Don't set to NULL */\n\trcu_assign_pointer(net->xfrm.nlsk, nlsk);\n\treturn 0;\n}\n\nstatic void __net_exit xfrm_user_net_exit(struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tRCU_INIT_POINTER(net->xfrm.nlsk, NULL);\n\tsynchronize_net();\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tnetlink_kernel_release(net->xfrm.nlsk_stash);\n}\n\nstatic struct pernet_operations xfrm_user_net_ops = {\n\t.init\t    = xfrm_user_net_init,\n\t.exit_batch = xfrm_user_net_exit,\n};\n\nstatic int __init xfrm_user_init(void)\n{\n\tint rv;\n\n\tprintk(KERN_INFO \"Initializing XFRM netlink socket\\n\");\n\n\trv = register_pernet_subsys(&xfrm_user_net_ops);\n\tif (rv < 0)\n\t\treturn rv;\n\trv = xfrm_register_km(&netlink_mgr);\n\tif (rv < 0)\n\t\tunregister_pernet_subsys(&xfrm_user_net_ops);\n\treturn rv;\n}\n\nstatic void __exit xfrm_user_exit(void)\n{\n\txfrm_unregister_km(&netlink_mgr);\n\tunregister_pernet_subsys(&xfrm_user_net_ops);\n}\n\nmodule_init(xfrm_user_init);\nmodule_exit(xfrm_user_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO(PF_NETLINK, NETLINK_XFRM);\n\n"], "filenames": ["net/xfrm/xfrm_user.c"], "buggy_code_start_loc": [1556], "buggy_code_end_loc": [2397], "fixing_code_start_loc": [1556], "fixing_code_end_loc": [2403], "type": "CWE-404", "message": "A vulnerability classified as problematic has been found in flar2 ElementalX up to 6.x. Affected is the function xfrm_dump_policy_done of the file net/xfrm/xfrm_user.c of the component ipsec. The manipulation leads to denial of service. Upgrading to version 7.00 is able to address this issue. The name of the patch is 1df72c9f0f61304437f4f1037df03b5fb36d5a79. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217152.", "other": {"cve": {"id": "CVE-2018-25062", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-01T09:15:09.690", "lastModified": "2023-01-09T17:13:25.427", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic has been found in flar2 ElementalX up to 6.x. Affected is the function xfrm_dump_policy_done of the file net/xfrm/xfrm_user.c of the component ipsec. The manipulation leads to denial of service. Upgrading to version 7.00 is able to address this issue. The name of the patch is 1df72c9f0f61304437f4f1037df03b5fb36d5a79. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217152."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.3}, "baseSeverity": "LOW", "exploitabilityScore": 4.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:elementalx:elementalx:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.00", "matchCriteriaId": "65E96B0D-65B0-4609-AA48-03517A8B8B12"}]}]}], "references": [{"url": "https://github.com/flar2/ElementalX-N9/commit/1df72c9f0f61304437f4f1037df03b5fb36d5a79", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217152", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217152", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/flar2/ElementalX-N9/commit/1df72c9f0f61304437f4f1037df03b5fb36d5a79"}}