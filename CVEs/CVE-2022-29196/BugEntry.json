{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#define USE_EIGEN_TENSOR\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/framework/kernel_shape_util.h\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_slice.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/kernels/conv_2d.h\"\n#include \"tensorflow/core/kernels/conv_3d.h\"\n#include \"tensorflow/core/kernels/conv_grad_ops.h\"\n#include \"tensorflow/core/kernels/conv_grad_shape_utils.h\"\n#include \"tensorflow/core/kernels/conv_ops_gpu.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/profiler/lib/scoped_annotation.h\"\n#include \"tensorflow/core/util/padding.h\"\n#include \"tensorflow/core/util/tensor_format.h\"\n#include \"tensorflow/core/util/use_cudnn.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\n#if defined(TENSORFLOW_USE_CUSTOM_CONTRACTION_KERNEL)\n#include \"tensorflow/core/kernels/eigen_contraction_kernel.h\"\n#endif\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/platform/stream_executor.h\"\nusing stream_executor::dnn::DimIndex;\n#include \"tensorflow/core/protobuf/autotuning.pb.h\"\n#include \"tensorflow/core/util/autotune_maps/conv_parameters.h\"\n#include \"tensorflow/core/util/proto/proto_utils.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#if GOOGLE_CUDA\n#include \"third_party/gpus/cudnn/cudnn.h\"\n#include \"tensorflow/stream_executor/gpu/gpu_asm_opts.h\"\n#include \"tensorflow/stream_executor/gpu/redzone_allocator.h\"\n#include \"tensorflow/stream_executor/tf_allocator_adapter.h\"\n#endif  // GOOGLE_CUDA\n\nnamespace {\n\n// TODO(ezhulenev): Split this file into conv_grad_filter_ops_3d.cc and\n// conv_grad_input_ops_3d.cc.\n\n// TODO(ezhulenev): Generalize Col2im and Im2col for 2-d and 3-d kernels.\n\n// \"Depth\" is already used for the channel dimension, so for the third spatial\n// dimension in this file we use \"plane\", although in NDHWC layout it's\n// indicated with a \"D\".\n\n// Returns in 'im_data' (assumed to be zero-initialized) image patch in storage\n// order (planes, height, width, depth), constructed from patches in 'col_data',\n// which is required to be in storage order (out_planes * out_height *\n// out_width, filter_planes, filter_height, filter_width, in_depth).\n//\n// Based on 2-dimensional implementation written by Yangqing Jia (jiayq).\ntemplate <typename T>\nvoid Col2im(const T* col_data, const int depth, const int planes,\n            const int height, const int width, const int filter_p,\n            const int filter_h, const int filter_w, const int pad_pt,\n            const int pad_t, const int pad_l, const int pad_pb, const int pad_b,\n            const int pad_r, const int stride_p, const int stride_h,\n            const int stride_w, T* im_data) {\n  const int planes_col = (planes + pad_pt + pad_pb - filter_p) / stride_p + 1;\n  const int height_col = (height + pad_t + pad_b - filter_h) / stride_h + 1;\n  const int width_col = (width + pad_l + pad_r - filter_w) / stride_w + 1;\n  int p_pad = -pad_pt;\n  for (int p = 0; p < planes_col; ++p) {\n    int h_pad = -pad_t;\n    for (int h = 0; h < height_col; ++h) {\n      int w_pad = -pad_l;\n      for (int w = 0; w < width_col; ++w) {\n        T* im_patch_data =\n            im_data + (p_pad * height * width + h_pad * width + w_pad) * depth;\n        for (int ip = p_pad; ip < p_pad + filter_p; ++ip) {\n          for (int ih = h_pad; ih < h_pad + filter_h; ++ih) {\n            for (int iw = w_pad; iw < w_pad + filter_w; ++iw) {\n              if (ip >= 0 && ip < planes && ih >= 0 && ih < height && iw >= 0 &&\n                  iw < width) {\n                for (int i = 0; i < depth; ++i) {\n                  im_patch_data[i] += col_data[i];\n                }\n              }\n              im_patch_data += depth;\n              col_data += depth;\n            }\n            // Jump over remaining number of depth.\n            im_patch_data += depth * (width - filter_w);\n          }\n          // Jump over remaining number of (depth * width).\n          im_patch_data += (depth * width) * (height - filter_h);\n        }\n        w_pad += stride_w;\n      }\n      h_pad += stride_h;\n    }\n    p_pad += stride_p;\n  }\n}\n\n// Returns in 'col_data', image patches in storage order (planes, height, width,\n// depth) extracted from image at 'input_data', which is required to be in\n// storage order (batch, planes, height, width, depth).\n//\n// Based on 2-dimensional implementation written by Yangqing Jia (jiayq).\ntemplate <typename T>\nvoid Im2col(const T* input_data, const int depth, const int planes,\n            const int height, const int width, const int filter_p,\n            const int filter_h, const int filter_w, const int pad_pt,\n            const int pad_t, const int pad_l, const int pad_pb, const int pad_b,\n            const int pad_r, const int stride_p, const int stride_h,\n            const int stride_w, T* col_data) {\n  const int planes_col = (planes + pad_pt + pad_pb - filter_p) / stride_p + 1;\n  const int height_col = (height + pad_t + pad_b - filter_h) / stride_h + 1;\n  const int width_col = (width + pad_l + pad_r - filter_w) / stride_w + 1;\n\n  int p_pad = -pad_pt;\n  for (int p = 0; p < planes_col; ++p) {\n    int h_pad = -pad_t;\n    for (int h = 0; h < height_col; ++h) {\n      int w_pad = -pad_l;\n      for (int w = 0; w < width_col; ++w) {\n        for (int ip = p_pad; ip < p_pad + filter_p; ++ip) {\n          for (int ih = h_pad; ih < h_pad + filter_h; ++ih) {\n            for (int iw = w_pad; iw < w_pad + filter_w; ++iw) {\n              if (ip >= 0 && ip < planes && ih >= 0 && ih < height && iw >= 0 &&\n                  iw < width) {\n                memcpy(col_data,\n                       input_data +\n                           (ip * height * width + ih * width + iw) * depth,\n                       sizeof(T) * depth);\n              } else {\n                // This should be simply padded with zero.\n                memset(col_data, 0, sizeof(T) * depth);\n              }\n              col_data += depth;\n            }\n          }\n        }\n        w_pad += stride_w;\n      }\n      h_pad += stride_h;\n    }\n    p_pad += stride_p;\n  }\n}\n\n}  // namespace\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\n// Backprop for input that offloads computation to\n// Eigen::CuboidConvolutionBackwardInput.\ntemplate <typename Device, class T>\nclass Conv3DBackpropInputOp : public OpKernel {\n public:\n  explicit Conv3DBackpropInputOp(OpKernelConstruction* context)\n      : OpKernel(context),\n        data_format_(FORMAT_NHWC),\n        takes_shape_(type_string().find(\"V2\") != std::string::npos) {\n    // data_format is only available in V2.\n    if (takes_shape_) {\n      string data_format;\n      OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n      OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n      OP_REQUIRES(\n          context, data_format_ == FORMAT_NHWC,\n          errors::InvalidArgument(\n              \"Conv3DBackpropInputOpV2 only supports NDHWC on the CPU.\"));\n    }\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"dilations\", &dilation_));\n    OP_REQUIRES(context, dilation_.size() == 5,\n                errors::InvalidArgument(\"Dilation rates field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, 'C') == 1 &&\n                 GetTensorDim(dilation_, data_format_, 'N') == 1),\n                errors::InvalidArgument(\n                    \"Current implementation does not yet support \"\n                    \"dilation rates in the batch and depth dimensions.\"));\n\n    // TODO(yangzihao): Add CPU version of dilated conv 3D.\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, '0') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '1') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '2') == 1),\n                errors::InvalidArgument(\n                    \"Current CPU implementation does not yet support \"\n                    \"dilation rates larger than 1.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 5,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, 'C') == 1 &&\n         GetTensorDim(stride_, data_format_, 'N') == 1),\n        errors::InvalidArgument(\"Current implementation does not yet support \"\n                                \"strides in the batch and depth dimensions.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      // tensor::MakeShape is able to handle both DT_INT32 and DT_INT64 for\n      // input_sizes.\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n\n    OP_REQUIRES(context, input_shape.dims() == 5,\n                errors::InvalidArgument(\"input tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, filter_shape.dims() == 5,\n        errors::InvalidArgument(\"filter_sizes tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dims() == 5,\n        errors::InvalidArgument(\"out_backprop tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", /*num_spatial_dims=*/3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     // input_backward\n        filter.tensor<T, 5>(),                           // filter\n        out_backprop.tensor<T, 5>(),                     // output_backward\n        static_cast<int>(dims.spatial_dims[0].stride),   // stride_planes\n        static_cast<int>(dims.spatial_dims[1].stride),   // stride_rows\n        static_cast<int>(dims.spatial_dims[2].stride));  // stride_cols\n  }\n\n private:\n  std::vector<int32> dilation_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool takes_shape_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(Conv3DBackpropInputOp);\n};\n\n// Custom backprop for input that explicitly does the work sharding and calls\n// Eigen only to multiply matrices.\ntemplate <typename Device, class T>\nclass Conv3DCustomBackpropInputOp : public OpKernel {\n  // Limit the maximum size of allocated temporary buffer to\n  // kMaxTempAllocationOverhead times the size of the input tensors (input,\n  // filter, out_backprop). If the size of the temporary buffer exceeds this\n  // limit, fallback on Eigen implementation.\n  static constexpr int kMaxTempAllocationOverhead = 25;\n\n public:\n  explicit Conv3DCustomBackpropInputOp(OpKernelConstruction* context)\n      : OpKernel(context),\n        data_format_(FORMAT_NHWC),\n        takes_shape_(type_string().find(\"V2\") != std::string::npos) {\n    // data_format is only available in V2.\n    if (takes_shape_) {\n      string data_format;\n      OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n      OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n      OP_REQUIRES(\n          context, data_format_ == FORMAT_NHWC,\n          errors::InvalidArgument(\n              \"Conv3DBackpropInputOpV2 only supports NDHWC on the CPU.\"));\n    }\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"dilations\", &dilation_));\n    OP_REQUIRES(context, dilation_.size() == 5,\n                errors::InvalidArgument(\"Dilation rates field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, 'C') == 1 &&\n                 GetTensorDim(dilation_, data_format_, 'N') == 1),\n                errors::InvalidArgument(\n                    \"Current implementation does not yet support \"\n                    \"dilation rates in the batch and depth dimensions.\"));\n\n    // TODO(yangzihao): Add CPU version of dilated conv 3D.\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, '0') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '1') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '2') == 1),\n                errors::InvalidArgument(\n                    \"Current CPU implementation does not yet support \"\n                    \"dilation rates larger than 1.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 5,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, 'C') == 1 &&\n         GetTensorDim(stride_, data_format_, 'N') == 1),\n        errors::InvalidArgument(\"Current implementation does not yet support \"\n                                \"strides in the batch and depth dimensions.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      // tensor::MakeShape is able to handle both DT_INT32 and DT_INT64 for\n      // input_sizes.\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n\n    OP_REQUIRES(context, input_shape.dims() == 5,\n                errors::InvalidArgument(\"input tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, filter_shape.dims() == 5,\n        errors::InvalidArgument(\"filter_sizes tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dims() == 5,\n        errors::InvalidArgument(\"out_backprop tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", /*num_spatial_dims=*/3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n\n    int64_t top_pad_planes, bottom_pad_planes;\n    int64_t top_pad_rows, bottom_pad_rows;\n    int64_t left_pad_cols, right_pad_cols;\n\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[0].input_size,\n                                dims.spatial_dims[0].filter_size,\n                                dims.spatial_dims[0].stride, padding_,\n                                &dims.spatial_dims[0].output_size,\n                                &top_pad_planes, &bottom_pad_planes));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[1].input_size,\n                                dims.spatial_dims[1].filter_size,\n                                dims.spatial_dims[1].stride, padding_,\n                                &dims.spatial_dims[1].output_size,\n                                &top_pad_rows, &bottom_pad_rows));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[2].input_size,\n                                dims.spatial_dims[2].filter_size,\n                                dims.spatial_dims[2].stride, padding_,\n                                &dims.spatial_dims[2].output_size,\n                                &left_pad_cols, &right_pad_cols));\n\n    // TODO(ezhulenev): Extract work size and shard estimation to shared\n    // functions in conv_grad_ops, and update 2d convolution backprop.\n\n    // The total dimension size of each kernel.\n    const int64_t filter_total_size =\n        dims.spatial_dims[0].filter_size * dims.spatial_dims[1].filter_size *\n        dims.spatial_dims[2].filter_size * dims.in_depth;\n\n    // The output image size is the spatial size of the output.\n    const int64_t output_image_size = dims.spatial_dims[0].output_size *\n                                      dims.spatial_dims[1].output_size *\n                                      dims.spatial_dims[2].output_size;\n\n    const auto cache_sizes = Eigen::internal::CacheSizes();\n    const ptrdiff_t l3_cache_size = cache_sizes.m_l3;\n\n    // Use L3 cache size as target working set size.\n    const size_t target_working_set_size = l3_cache_size / sizeof(T);\n\n    // Calculate size of matrices involved in MatMul: C = A x B.\n    const int64_t size_A = output_image_size * dims.out_depth;\n\n    const int64_t size_B = filter_total_size * dims.out_depth;\n\n    const int64_t size_C = output_image_size * filter_total_size;\n\n    const int64_t work_unit_size = size_A + size_B + size_C;\n\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n\n    // Use parallel tensor contractions if there is no batching.\n    //\n    // Compared to Conv2D code, this version is missing work size estimation. In\n    // benchmarks I didn't find a case when it's beneficial to run parallel\n    // contraction compared to sharding and matmuls.\n    const bool use_parallel_contraction = dims.batch_size == 1;\n\n    OP_REQUIRES(\n        context, work_unit_size > 0,\n        errors::InvalidArgument(\"input, filter_sizes and out_backprop tensors \"\n                                \"must all have at least 1 element\"));\n\n    const size_t shard_size =\n        use_parallel_contraction\n            ? 1\n            : (target_working_set_size + work_unit_size - 1) / work_unit_size;\n\n    // Total number of elements in all the tensors used by this kernel.\n    int64_t total_tensor_elements = input_shape.num_elements() +\n                                    filter_shape.num_elements() +\n                                    out_backprop_shape.num_elements();\n\n    // Shape of the temporary workspace buffer.\n    TensorShape col_buffer_shape = {static_cast<int64_t>(shard_size),\n                                    static_cast<int64_t>(output_image_size),\n                                    static_cast<int64_t>(filter_total_size)};\n    int64_t col_buffer_elements = col_buffer_shape.num_elements();\n\n    // If the temporary allocation overhead is too large, fallback on Eigen\n    // implementation which requires much less memory.\n    int64_t col_buffer_overhead = col_buffer_elements / total_tensor_elements;\n    if (col_buffer_overhead > kMaxTempAllocationOverhead) {\n      VLOG(2) << \"Fallback on Eigen implementation of Conv3DBackpropInputOp: \"\n                 \"col_buffer_overhead=\"\n              << col_buffer_overhead;\n\n      functor::CuboidConvolutionBackwardInput<Device, T>()(\n          context->eigen_device<Device>(),\n          in_backprop->tensor<T, 5>(),                     // input_backward\n          filter.tensor<T, 5>(),                           // filter\n          out_backprop.tensor<T, 5>(),                     // output_backward\n          static_cast<int>(dims.spatial_dims[0].stride),   // stride_planes\n          static_cast<int>(dims.spatial_dims[1].stride),   // stride_rows\n          static_cast<int>(dims.spatial_dims[2].stride));  // stride_cols\n\n      return;\n    }\n\n    Tensor col_buffer;\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value,\n                                          col_buffer_shape, &col_buffer));\n\n    // The input offset corresponding to a single input image.\n    const int64_t input_offset =\n        dims.spatial_dims[0].input_size * dims.spatial_dims[1].input_size *\n        dims.spatial_dims[2].input_size * dims.in_depth;\n\n    // The output offset corresponding to a single output image.\n    const int64_t output_offset =\n        dims.spatial_dims[0].output_size * dims.spatial_dims[1].output_size *\n        dims.spatial_dims[2].output_size * dims.out_depth;\n\n    const T* filter_data = filter.template flat<T>().data();\n    T* col_buffer_data = col_buffer.template flat<T>().data();\n    const T* out_backprop_data = out_backprop.template flat<T>().data();\n\n    auto in_backprop_flat = in_backprop->template flat<T>();\n    T* input_backprop_data = in_backprop_flat.data();\n    in_backprop_flat.device(context->eigen_device<Device>()) =\n        in_backprop_flat.constant(T(0));\n\n    if (use_parallel_contraction) {\n      typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,\n                               Eigen::Unaligned>\n          TensorMap;\n      typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,\n                               Eigen::Unaligned>\n          ConstTensorMap;\n\n      // Initialize contraction dims (we need to transpose 'B' below).\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> contract_dims;\n      contract_dims[0].first = 1;\n      contract_dims[0].second = 1;\n\n      for (int image_id = 0; image_id < dims.batch_size; ++image_id) {\n        // Compute gradient into col_buffer.\n        TensorMap C(col_buffer_data, output_image_size, filter_total_size);\n\n        ConstTensorMap A(out_backprop_data + output_offset * image_id,\n                         output_image_size, dims.out_depth);\n        ConstTensorMap B(filter_data, filter_total_size, dims.out_depth);\n\n        C.device(context->eigen_cpu_device()) = A.contract(B, contract_dims);\n\n        Col2im<T>(col_buffer_data, dims.in_depth,\n                  // Input spatial dimensions.\n                  dims.spatial_dims[0].input_size,  // input planes\n                  dims.spatial_dims[1].input_size,  // input rows\n                  dims.spatial_dims[2].input_size,  // input cols\n                  // Filter spatial dimensions.\n                  dims.spatial_dims[0].filter_size,  // filter planes\n                  dims.spatial_dims[1].filter_size,  // filter rows\n                  dims.spatial_dims[2].filter_size,  // filter cols\n                  // Spatial padding.\n                  top_pad_planes, top_pad_rows, left_pad_cols,\n                  bottom_pad_planes, bottom_pad_rows, right_pad_cols,\n                  // Spatial striding.\n                  dims.spatial_dims[0].stride,  // stride planes\n                  dims.spatial_dims[1].stride,  // stride rows\n                  dims.spatial_dims[2].stride,  // stride cols\n                  input_backprop_data);\n\n        input_backprop_data += input_offset;\n      }\n    } else {\n      typedef Eigen::Map<\n          Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>>\n          MatrixMap;\n      typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic,\n                                             Eigen::RowMajor>>\n          ConstMatrixMap;\n\n      for (int image_id = 0; image_id < dims.batch_size;\n           image_id += shard_size) {\n        const int shard_limit =\n            std::min(static_cast<int>(shard_size),\n                     static_cast<int>(dims.batch_size) - image_id);\n\n        auto shard = [&dims, &top_pad_planes, &top_pad_rows, &left_pad_cols,\n                      &bottom_pad_planes, &bottom_pad_rows, &right_pad_cols,\n                      &output_image_size, &filter_total_size,\n                      &input_backprop_data, &col_buffer_data,\n                      &out_backprop_data, &filter_data, &input_offset,\n                      &output_offset, &size_C](int64_t start, int64_t limit) {\n          for (int shard_id = start; shard_id < limit; ++shard_id) {\n            T* im2col_buf = col_buffer_data + shard_id * size_C;\n            T* input_data = input_backprop_data + shard_id * input_offset;\n            const T* out_data = out_backprop_data + shard_id * output_offset;\n\n            // Compute gradient into 'im2col_buf'.\n            MatrixMap C(im2col_buf, output_image_size, filter_total_size);\n\n            ConstMatrixMap A(out_data, output_image_size, dims.out_depth);\n            ConstMatrixMap B(filter_data, filter_total_size, dims.out_depth);\n\n            C.noalias() = A * B.transpose();\n\n            Col2im<T>(im2col_buf, dims.in_depth,\n                      // Input spatial dimensions.\n                      dims.spatial_dims[0].input_size,  // input planes\n                      dims.spatial_dims[1].input_size,  // input rows\n                      dims.spatial_dims[2].input_size,  // input cols\n                      // Filter spatial dimensions.\n                      dims.spatial_dims[0].filter_size,  // filter planes\n                      dims.spatial_dims[1].filter_size,  // filter rows\n                      dims.spatial_dims[2].filter_size,  // filter cols\n                      // Spatial padding.\n                      top_pad_planes, top_pad_rows, left_pad_cols,\n                      bottom_pad_planes, bottom_pad_rows, right_pad_cols,\n                      // Spatial striding.\n                      dims.spatial_dims[0].stride,  // stride planes\n                      dims.spatial_dims[1].stride,  // stride rows\n                      dims.spatial_dims[2].stride,  // stride cols\n                      input_data);\n          }\n        };\n        Shard(worker_threads.num_threads, worker_threads.workers, shard_limit,\n              work_unit_size, shard);\n\n        input_backprop_data += input_offset * shard_limit;\n        out_backprop_data += output_offset * shard_limit;\n      }\n    }\n  }\n\n private:\n  std::vector<int32> dilation_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool takes_shape_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(Conv3DCustomBackpropInputOp);\n};\n\n// Custom backrop input kernel is 30% - 4x faster when compiled with AVX2 than\n// default Eigen implementation (at the cost of ~2x-8x peak memory usage).\n\n#define REGISTER_CPU_KERNEL(T)                                                 \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"Conv3DBackpropInput\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"),   \\\n      Conv3DCustomBackpropInputOp<CPUDevice, T>);                              \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"Conv3DBackpropInputV2\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      Conv3DCustomBackpropInputOp<CPUDevice, T>);                              \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropInput\")                          \\\n                              .Device(DEVICE_CPU)                              \\\n                              .Label(\"custom\")                                 \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          Conv3DCustomBackpropInputOp<CPUDevice, T>);          \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropInputV2\")                        \\\n                              .Device(DEVICE_CPU)                              \\\n                              .Label(\"custom\")                                 \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          Conv3DCustomBackpropInputOp<CPUDevice, T>);          \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropInput\")                          \\\n                              .Device(DEVICE_CPU)                              \\\n                              .Label(\"eigen_tensor\")                           \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          Conv3DBackpropInputOp<CPUDevice, T>);                \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropInputV2\")                        \\\n                              .Device(DEVICE_CPU)                              \\\n                              .Label(\"eigen_tensor\")                           \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          Conv3DBackpropInputOp<CPUDevice, T>);\n\nTF_CALL_half(REGISTER_CPU_KERNEL);\nTF_CALL_float(REGISTER_CPU_KERNEL);\nTF_CALL_double(REGISTER_CPU_KERNEL);\n#undef REGISTER_CPU_KERNEL\n\n// Backprop for filter that offloads computation to\n// Eigen::CuboidConvolutionBackwardFilter.\ntemplate <typename Device, class T>\nclass Conv3DBackpropFilterOp : public OpKernel {\n public:\n  explicit Conv3DBackpropFilterOp(OpKernelConstruction* context)\n      : OpKernel(context),\n        data_format_(FORMAT_NHWC),\n        takes_shape_(type_string().find(\"V2\") != std::string::npos) {\n    // data_format is only available in V2.\n    if (takes_shape_) {\n      string data_format;\n      OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n      OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n      OP_REQUIRES(\n          context, data_format_ == FORMAT_NHWC,\n          errors::InvalidArgument(\n              \"Conv3DBackpropFilterOpV2 only supports NDHWC on the CPU.\"));\n    }\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"dilations\", &dilation_));\n    OP_REQUIRES(context, dilation_.size() == 5,\n                errors::InvalidArgument(\"Dilation rates field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, 'C') == 1 &&\n                 GetTensorDim(dilation_, data_format_, 'N') == 1),\n                errors::InvalidArgument(\n                    \"Current implementation does not yet support \"\n                    \"dilation rates in the batch and depth dimensions.\"));\n\n    // TODO(yangzihao): Add CPU version of dilated conv 3D.\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, '0') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '1') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '2') == 1),\n                errors::InvalidArgument(\n                    \"Current CPU implementation does not yet support \"\n                    \"dilation rates larger than 1.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 5,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, 'C') == 1 &&\n         GetTensorDim(stride_, data_format_, 'N') == 1),\n        errors::InvalidArgument(\"Current implementation does not yet support \"\n                                \"strides in the batch and depth dimensions.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape filter_shape;\n    if (takes_shape_) {\n      const Tensor& filter_sizes = context->input(1);\n      OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                  filter_sizes.vec<int32>(), &filter_shape));\n    } else {\n      filter_shape = context->input(1).shape();\n    }\n\n    OP_REQUIRES(context, input_shape.dims() == 5,\n                errors::InvalidArgument(\"input tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, filter_shape.dims() == 5,\n        errors::InvalidArgument(\"filter_sizes tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dims() == 5,\n        errors::InvalidArgument(\"out_backprop tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context,\n                   ConvBackpropComputeDimensions(\n                       \"Conv3DBackpropFilterOp\", /*num_spatial_dims=*/3,\n                       input_shape, filter_shape, out_backprop_shape, stride_,\n                       padding_, data_format_, &dims));\n\n    Tensor* filter_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, filter_shape, &filter_backprop));\n\n    if (input_shape.num_elements() == 0) {\n      filter_backprop->template flat<T>().setZero();\n      return;\n    }\n\n    functor::CuboidConvolutionBackwardFilter<Device, T>()(\n        context->eigen_device<Device>(),\n        filter_backprop->tensor<T, 5>(),                 // filter_backward\n        input.tensor<T, 5>(),                            // input\n        out_backprop.tensor<T, 5>(),                     // output_backward\n        static_cast<int>(dims.spatial_dims[0].stride),   // stride_planes\n        static_cast<int>(dims.spatial_dims[1].stride),   // stride_rows\n        static_cast<int>(dims.spatial_dims[2].stride));  // stride_cols\n  }\n\n private:\n  std::vector<int32> dilation_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool takes_shape_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(Conv3DBackpropFilterOp);\n};\n\n// Custom backprop for filter that explicitly does the work sharding and calls\n// Eigen only to multiply matrices.\ntemplate <typename Device, class T>\nclass Conv3DCustomBackpropFilterOp : public OpKernel {\n  // Limit the maximum size of allocated temporary buffer to\n  // kMaxTempAllocationOverhead times the size of the input tensors (input,\n  // filter, out_backprop). If the size of the temporary buffer exceeds this\n  // limit, fallback on Eigen implementation.\n  static constexpr int kMaxTempAllocationOverhead = 25;\n\n public:\n  explicit Conv3DCustomBackpropFilterOp(OpKernelConstruction* context)\n      : OpKernel(context),\n        data_format_(FORMAT_NHWC),\n        takes_shape_(type_string().find(\"V2\") != std::string::npos) {\n    // data_format is only available in V2.\n    if (takes_shape_) {\n      string data_format;\n      OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n      OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n      OP_REQUIRES(\n          context, data_format_ == FORMAT_NHWC,\n          errors::InvalidArgument(\n              \"Conv3DBackpropFilterOpV2 only supports NDHWC on the CPU.\"));\n    }\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"dilations\", &dilation_));\n    OP_REQUIRES(context, dilation_.size() == 5,\n                errors::InvalidArgument(\"Dilation rates field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, 'C') == 1 &&\n                 GetTensorDim(dilation_, data_format_, 'N') == 1),\n                errors::InvalidArgument(\n                    \"Current implementation does not yet support \"\n                    \"dilation rates in the batch and depth dimensions.\"));\n\n    // TODO(yangzihao): Add CPU version of dilated conv 3D.\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, '0') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '1') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '2') == 1),\n                errors::InvalidArgument(\n                    \"Current CPU implementation does not yet support \"\n                    \"dilation rates larger than 1.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 5,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, 'C') == 1 &&\n         GetTensorDim(stride_, data_format_, 'N') == 1),\n        errors::InvalidArgument(\"Current implementation does not yet support \"\n                                \"strides in the batch and depth dimensions.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape filter_shape;\n    if (takes_shape_) {\n      const Tensor& filter_sizes = context->input(1);\n      OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                  filter_sizes.vec<int32>(), &filter_shape));\n    } else {\n      filter_shape = context->input(1).shape();\n    }\n\n    OP_REQUIRES(context, input_shape.dims() == 5,\n                errors::InvalidArgument(\"input tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, filter_shape.dims() == 5,\n        errors::InvalidArgument(\"filter_sizes tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dims() == 5,\n        errors::InvalidArgument(\"out_backprop tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context,\n                   ConvBackpropComputeDimensions(\n                       \"Conv3DBackpropFilterOp\", /*num_spatial_dims=*/3,\n                       input_shape, filter_shape, out_backprop_shape, stride_,\n                       padding_, data_format_, &dims));\n\n    Tensor* filter_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, filter_shape, &filter_backprop));\n\n    if (input_shape.num_elements() == 0) {\n      filter_backprop->template flat<T>().setZero();\n      return;\n    }\n\n    int64_t top_pad_planes, bottom_pad_planes;\n    int64_t top_pad_rows, bottom_pad_rows;\n    int64_t left_pad_cols, right_pad_cols;\n\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[0].input_size,\n                                dims.spatial_dims[0].filter_size,\n                                dims.spatial_dims[0].stride, padding_,\n                                &dims.spatial_dims[0].output_size,\n                                &top_pad_planes, &bottom_pad_planes));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[1].input_size,\n                                dims.spatial_dims[1].filter_size,\n                                dims.spatial_dims[1].stride, padding_,\n                                &dims.spatial_dims[1].output_size,\n                                &top_pad_rows, &bottom_pad_rows));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[2].input_size,\n                                dims.spatial_dims[2].filter_size,\n                                dims.spatial_dims[2].stride, padding_,\n                                &dims.spatial_dims[2].output_size,\n                                &left_pad_cols, &right_pad_cols));\n\n    // TODO(ezhulenev): Extract work size and shard estimation to shared\n    // functions in conv_grad_ops, and update 2d convolution backprop.\n\n    // The total dimension size of each kernel.\n    const int64_t filter_total_size =\n        dims.spatial_dims[0].filter_size * dims.spatial_dims[1].filter_size *\n        dims.spatial_dims[2].filter_size * dims.in_depth;\n    // The output image size is the spatial size of the output.\n    const int64_t output_image_size = dims.spatial_dims[0].output_size *\n                                      dims.spatial_dims[1].output_size *\n                                      dims.spatial_dims[2].output_size;\n\n    // Shard 'batch' images (volumes) into 'shard_size' groups of images\n    // (volumes) to be fed into the parallel matmul. Calculate 'shard_size' by\n    // dividing the L3 cache size ('target_working_set_size') by the matmul size\n    // of an individual image ('work_unit_size').\n\n    const auto cache_sizes = Eigen::internal::CacheSizes();\n    const ptrdiff_t l3_cache_size = cache_sizes.m_l3;\n\n    // TODO(andydavis)\n    // *) Consider reducing 'target_working_set_size' if L3 is shared by\n    //    other concurrently running tensorflow ops.\n    const size_t target_working_set_size = l3_cache_size / sizeof(T);\n\n    const int64_t size_A = output_image_size * filter_total_size;\n\n    const int64_t size_B = output_image_size * dims.out_depth;\n\n    const int64_t size_C = filter_total_size * dims.out_depth;\n\n    const int64_t work_unit_size = size_A + size_B + size_C;\n\n    OP_REQUIRES(\n        context, work_unit_size > 0,\n        errors::InvalidArgument(\"input, filter_sizes and out_backprop tensors \"\n                                \"must all have at least 1 element\"));\n\n    const size_t shard_size =\n        (target_working_set_size + work_unit_size - 1) / work_unit_size;\n\n    // Total number of elements in all the tensors used by this kernel.\n    int64_t total_tensor_elements = input_shape.num_elements() +\n                                    filter_shape.num_elements() +\n                                    out_backprop_shape.num_elements();\n\n    // Shape of the temporary workspace buffer.\n    TensorShape col_buffer_shape = {static_cast<int64_t>(shard_size),\n                                    static_cast<int64_t>(output_image_size),\n                                    static_cast<int64_t>(filter_total_size)};\n    int64_t col_buffer_elements = col_buffer_shape.num_elements();\n\n    // If the temporary allocation overhead is too large, fallback on Eigen\n    // implementation which requires much less memory.\n    int64_t col_buffer_overhead = col_buffer_elements / total_tensor_elements;\n    if (col_buffer_overhead > kMaxTempAllocationOverhead) {\n      VLOG(2) << \"Fallback on Eigen implementation of Conv3DBackpropFilterOp: \"\n                 \"col_buffer_overhead=\"\n              << col_buffer_overhead;\n\n      functor::CuboidConvolutionBackwardFilter<Device, T>()(\n          context->eigen_device<Device>(),\n          filter_backprop->tensor<T, 5>(),                 // filter_backward\n          input.tensor<T, 5>(),                            // input\n          out_backprop.tensor<T, 5>(),                     // output_backward\n          static_cast<int>(dims.spatial_dims[0].stride),   // stride_planes\n          static_cast<int>(dims.spatial_dims[1].stride),   // stride_rows\n          static_cast<int>(dims.spatial_dims[2].stride));  // stride_cols\n\n      return;\n    }\n\n    Tensor col_buffer;\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value,\n                                          col_buffer_shape, &col_buffer));\n\n    // The input offset corresponding to a single input image.\n    const int64_t input_offset =\n        dims.spatial_dims[0].input_size * dims.spatial_dims[1].input_size *\n        dims.spatial_dims[2].input_size * dims.in_depth;\n    // The output offset corresponding to a single output image.\n    const int64_t output_offset =\n        dims.spatial_dims[0].output_size * dims.spatial_dims[1].output_size *\n        dims.spatial_dims[2].output_size * dims.out_depth;\n\n    const T* input_data = input.template flat<T>().data();\n    T* col_buffer_data = col_buffer.template flat<T>().data();\n    const T* out_backprop_data = out_backprop.template flat<T>().data();\n    T* filter_backprop_data = filter_backprop->template flat<T>().data();\n\n    typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,\n                             Eigen::Unaligned>\n        TensorMap;\n    typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,\n                             Eigen::Unaligned>\n        ConstTensorMap;\n\n    TensorMap C(filter_backprop_data, filter_total_size, dims.out_depth);\n    C.setZero();\n\n    // Initialize contraction dims (we need to transpose 'A' below).\n    Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> contract_dims;\n    contract_dims[0].first = 0;\n    contract_dims[0].second = 0;\n\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n\n    for (int image_id = 0; image_id < dims.batch_size; image_id += shard_size) {\n      const int shard_limit =\n          std::min(static_cast<int>(shard_size),\n                   static_cast<int>(dims.batch_size) - image_id);\n\n      auto shard = [&input_data, &col_buffer_data, &dims, &top_pad_planes,\n                    &top_pad_rows, &left_pad_cols, &bottom_pad_planes,\n                    &bottom_pad_rows, &right_pad_cols, &input_offset,\n                    &size_A](int64_t start, int64_t limit) {\n        for (int shard_id = start; shard_id < limit; ++shard_id) {\n          const T* input_data_shard = input_data + shard_id * input_offset;\n          T* col_data_shard = col_buffer_data + shard_id * size_A;\n\n          // When we compute the gradient with respect to the filters, we need\n          // to do im2col to allow gemm-type computation.\n          Im2col<T>(input_data_shard, dims.in_depth,\n                    // Input spatial dimensions.\n                    dims.spatial_dims[0].input_size,  // input planes\n                    dims.spatial_dims[1].input_size,  // input rows\n                    dims.spatial_dims[2].input_size,  // input cols\n                    // Filter spatial dimensions.\n                    dims.spatial_dims[0].filter_size,  // filter planes\n                    dims.spatial_dims[1].filter_size,  // filter rows\n                    dims.spatial_dims[2].filter_size,  // filter cols\n                    // Spatial padding.\n                    top_pad_planes, top_pad_rows, left_pad_cols,\n                    bottom_pad_planes, bottom_pad_rows, right_pad_cols,\n                    // Spatial striding.\n                    dims.spatial_dims[0].stride,  // stride planes\n                    dims.spatial_dims[1].stride,  // stride rows\n                    dims.spatial_dims[2].stride,  // stride cols\n                    col_data_shard);\n        }\n      };\n      Shard(worker_threads.num_threads, worker_threads.workers, shard_limit,\n            size_A, shard);\n\n      ConstTensorMap A(col_buffer_data, output_image_size * shard_limit,\n                       filter_total_size);\n      ConstTensorMap B(out_backprop_data, output_image_size * shard_limit,\n                       dims.out_depth);\n\n      // Gradient with respect to filter.\n      C.device(context->eigen_cpu_device()) += A.contract(B, contract_dims);\n\n      input_data += input_offset * shard_limit;\n      out_backprop_data += output_offset * shard_limit;\n    }\n  }\n\n private:\n  std::vector<int32> dilation_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool takes_shape_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(Conv3DCustomBackpropFilterOp);\n};\n\n// Custom backrop input kernel is 30% - 4x faster when compiled with AVX2 than\n// default Eigen implementation (at the cost of ~2x-8x peak memory usage).\n\n#define REGISTER_CPU_KERNEL(T)                                                \\\n  REGISTER_KERNEL_BUILDER(                                                    \\\n      Name(\"Conv3DBackpropFilter\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      Conv3DCustomBackpropFilterOp<CPUDevice, T>);                            \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilterV2\")                      \\\n                              .Device(DEVICE_CPU)                             \\\n                              .TypeConstraint<T>(\"T\"),                        \\\n                          Conv3DCustomBackpropFilterOp<CPUDevice, T>);        \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilter\")                        \\\n                              .Device(DEVICE_CPU)                             \\\n                              .Label(\"custom\")                                \\\n                              .TypeConstraint<T>(\"T\"),                        \\\n                          Conv3DCustomBackpropFilterOp<CPUDevice, T>);        \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilterV2\")                      \\\n                              .Device(DEVICE_CPU)                             \\\n                              .Label(\"custom\")                                \\\n                              .TypeConstraint<T>(\"T\"),                        \\\n                          Conv3DCustomBackpropFilterOp<CPUDevice, T>);        \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilter\")                        \\\n                              .Device(DEVICE_CPU)                             \\\n                              .Label(\"eigen_tensor\")                          \\\n                              .TypeConstraint<T>(\"T\"),                        \\\n                          Conv3DBackpropFilterOp<CPUDevice, T>);              \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilterV2\")                      \\\n                              .Device(DEVICE_CPU)                             \\\n                              .Label(\"eigen_tensor\")                          \\\n                              .TypeConstraint<T>(\"T\"),                        \\\n                          Conv3DBackpropFilterOp<CPUDevice, T>);\n\nTF_CALL_float(REGISTER_CPU_KERNEL);\nTF_CALL_double(REGISTER_CPU_KERNEL);\n#undef REGISTER_CPU_KERNEL\n\n// WARNING: Eigen::half is not trivially copyable and can't be used in\n// custom backprop filter kernel because of memcpy and memset in Im2col.\n#define REGISTER_CPU_KERNEL(T)                                                \\\n  REGISTER_KERNEL_BUILDER(                                                    \\\n      Name(\"Conv3DBackpropFilter\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      Conv3DBackpropFilterOp<CPUDevice, T>);                                  \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilterV2\")                      \\\n                              .Device(DEVICE_CPU)                             \\\n                              .TypeConstraint<T>(\"T\"),                        \\\n                          Conv3DBackpropFilterOp<CPUDevice, T>);\n\nTF_CALL_half(REGISTER_CPU_KERNEL);\n#undef REGISTER_CPU_KERNEL\n\n// GPU definitions of both ops.\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n// Forward declarations of the functor specializations for GPU.\n// This ensures that the custom implementation is used instead of the default\n// Eigen one (which is used for CPU).\nnamespace functor {\n#define DECLARE_GPU_SPEC(T)                                           \\\n  template <>                                                         \\\n  void TransformFilter<GPUDevice, T, int, 5>::operator()(             \\\n      const GPUDevice& d, FilterTensorFormat dst_filter_format,       \\\n      typename TTypes<T, 5, int>::ConstTensor in,                     \\\n      typename TTypes<T, 5, int>::Tensor out);                        \\\n  template <>                                                         \\\n  void ReverseTransformFilter<GPUDevice, T, 5>::operator()(           \\\n      const GPUDevice& d, FilterTensorFormat src_filter_format,       \\\n      typename TTypes<T, 5>::ConstTensor in,                          \\\n      typename TTypes<T, 5>::Tensor out);                             \\\n  template <>                                                         \\\n  void PadInput<GPUDevice, T, int, 5>::operator()(                    \\\n      const GPUDevice& d, typename TTypes<T, 5, int>::ConstTensor in, \\\n      const std::array<int, 3>& padding_left,                         \\\n      const std::array<int, 3>& padding_right,                        \\\n      typename TTypes<T, 5, int>::Tensor out, TensorFormat format,    \\\n      const T& padding_value);\n\nDECLARE_GPU_SPEC(Eigen::half);\nDECLARE_GPU_SPEC(float);\nDECLARE_GPU_SPEC(double);\n#undef DECLARE_GPU_SPEC\n}  // namespace functor\n\n// A dummy type to group backward data autotune results together.\nstruct Conv3dBackwardDataAutotuneGroup {\n  static string name() { return \"Conv3dBwdData\"; }\n};\n\ntypedef AutotuneSingleton<Conv3dBackwardDataAutotuneGroup, ConvParameters,\n                          AutotuneEntry<se::dnn::ConvOp>>\n\n    AutotuneConv3dBwdData;\n\ntemplate <typename T>\nclass Conv3DBackpropInputOp<GPUDevice, T> : public OpKernel {\n public:\n  explicit Conv3DBackpropInputOp(OpKernelConstruction* context)\n      : OpKernel(context),\n        data_format_(FORMAT_NHWC),\n        takes_shape_(type_string().find(\"V2\") != std::string::npos) {\n    // data_format is only available in V2.\n    if (takes_shape_) {\n      string data_format;\n      OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n      OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n    }\n    OP_REQUIRES_OK(context, context->GetAttr(\"dilations\", &dilation_));\n    OP_REQUIRES(context, dilation_.size() == 5,\n                errors::InvalidArgument(\"Dilation rates field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, 'C') == 1 &&\n                 GetTensorDim(dilation_, data_format_, 'N') == 1),\n                errors::InvalidArgument(\n                    \"Current implementation does not yet support \"\n                    \"dilation rates in the batch and depth dimensions.\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(dilation_, data_format_, '0') > 0 &&\n         GetTensorDim(dilation_, data_format_, '1') > 0 &&\n         GetTensorDim(dilation_, data_format_, '2') > 0),\n        errors::InvalidArgument(\"Dilated rates should be larger than 0.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 5,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, 'C') == 1 &&\n         GetTensorDim(stride_, data_format_, 'N') == 1),\n        errors::InvalidArgument(\"Current implementation does not yet support \"\n                                \"strides in the batch and depth dimensions.\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, '0') > 0 &&\n         GetTensorDim(stride_, data_format_, '1') > 0 &&\n         GetTensorDim(stride_, data_format_, '2') > 0),\n        errors::InvalidArgument(\"Spatial strides should be larger than 0.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    cudnn_use_autotune_ = CudnnUseAutotune();\n  }\n  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensionsV2(\n                                \"Conv3DBackpropInputOp\", /*num_spatial_dims=*/3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                dilation_, stride_, padding_,\n                                /*explicit_paddings=*/{}, data_format_, &dims));\n\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n\n    auto* stream = context->op_device_context()->stream();\n    OP_REQUIRES(context, stream, errors::Internal(\"No GPU stream available.\"));\n\n    bool is_grouped_convolution = filter_shape.dim_size(3) != dims.in_depth;\n    if (!is_grouped_convolution && dims.filter_size(0) == 1 &&\n        dims.filter_size(1) == 1 && dims.filter_size(2) == 1 &&\n        dims.dilation(0) == 1 && dims.dilation(1) == 1 &&\n        dims.dilation(2) == 1 && dims.stride(0) == 1 && dims.stride(1) == 1 &&\n        dims.stride(2) == 1 && data_format_ == FORMAT_NHWC) {\n      const uint64 m = dims.batch_size * dims.input_size(0) *\n                       dims.input_size(1) * dims.input_size(2);\n      const uint64 k = dims.out_depth;\n      const uint64 n = dims.in_depth;\n\n      auto a_ptr = AsDeviceMemory(out_backprop.template flat<T>().data(),\n                                  out_backprop.template flat<T>().size());\n      auto b_ptr = AsDeviceMemory(filter.template flat<T>().data(),\n                                  filter.template flat<T>().size());\n      auto c_ptr = AsDeviceMemory(in_backprop->template flat<T>().data(),\n                                  in_backprop->template flat<T>().size());\n\n      auto transpose = se::blas::Transpose::kTranspose;\n      auto no_transpose = se::blas::Transpose::kNoTranspose;\n\n      OP_REQUIRES_OK(\n          context, stream->ThenBlasGemm(transpose, no_transpose, n, m, k, b_ptr,\n                                        k, a_ptr, k, &c_ptr, n));\n      return;\n    } else if (!is_grouped_convolution &&\n               dims.filter_size(0) == dims.input_size(0) &&\n               dims.filter_size(1) == dims.input_size(1) &&\n               dims.filter_size(2) == dims.input_size(2) &&\n               padding_ == Padding::VALID && data_format_ == FORMAT_NHWC) {\n      const uint64 m = dims.batch_size;\n      const uint64 k = dims.out_depth;\n      const uint64 n = dims.input_size(0) * dims.input_size(1) *\n                       dims.input_size(2) * dims.in_depth;\n\n      auto a_ptr = AsDeviceMemory(out_backprop.template flat<T>().data(),\n                                  out_backprop.template flat<T>().size());\n      auto b_ptr = AsDeviceMemory(filter.template flat<T>().data(),\n                                  filter.template flat<T>().size());\n      auto c_ptr = AsDeviceMemory(in_backprop->template flat<T>().data(),\n                                  in_backprop->template flat<T>().size());\n\n      auto transpose = se::blas::Transpose::kTranspose;\n      auto no_transpose = se::blas::Transpose::kNoTranspose;\n\n      OP_REQUIRES_OK(\n          context, stream->ThenBlasGemm(transpose, no_transpose, n, m, k, b_ptr,\n                                        k, a_ptr, k, &c_ptr, n));\n      return;\n    }\n\n    int padding_planes = dims.SpatialPadding(padding_, 0);\n    int padding_rows = dims.SpatialPadding(padding_, 1);\n    int padding_cols = dims.SpatialPadding(padding_, 2);\n    const bool planes_odd = (padding_planes % 2 != 0);\n    const bool rows_odd = (padding_rows % 2 != 0);\n    const bool cols_odd = (padding_cols % 2 != 0);\n\n    TensorShape compatible_input_shape;\n    if (rows_odd || cols_odd || planes_odd) {\n      // cuDNN only supports the same amount of padding on both sides.\n      compatible_input_shape = {\n          dims.batch_size,\n          dims.in_depth,\n          dims.input_size(0) + planes_odd,\n          dims.input_size(1) + rows_odd,\n          dims.input_size(2) + cols_odd,\n      };\n    } else {\n      compatible_input_shape = {dims.batch_size, dims.in_depth,\n                                dims.input_size(0), dims.input_size(1),\n                                dims.input_size(2)};\n    }\n\n    CHECK(padding_rows >= 0 && padding_cols >= 0 && padding_planes >= 0)\n        << \"Negative paddings: (\" << padding_rows << \", \" << padding_cols\n        << \", \" << padding_planes << \")\";\n\n#if GOOGLE_CUDA\n    const bool compute_in_nhwc =\n        CUDNN_VERSION >= 8000 && DataTypeToEnum<T>::value == DT_HALF;\n#else\n    // fast NDHWC implementation is a CUDA only feature\n    const bool compute_in_nhwc = false;\n#endif\n    const TensorFormat compute_data_format =\n        (compute_in_nhwc && data_format_ == FORMAT_NHWC) ? FORMAT_NHWC\n                                                         : FORMAT_NCHW;\n\n    VLOG(3) << \"Compute Conv3DBackpropInput with cuDNN:\"\n            << \" data_format=\" << ToString(data_format_)\n            << \" compute_data_format=\" << ToString(compute_data_format);\n\n    constexpr auto kComputeInNHWC =\n        std::make_tuple(se::dnn::DataLayout::kBatchYXDepth,\n                        se::dnn::FilterLayout::kOutputYXInput);\n    constexpr auto kComputeInNCHW =\n        std::make_tuple(se::dnn::DataLayout::kBatchDepthYX,\n                        se::dnn::FilterLayout::kOutputInputYX);\n\n    se::dnn::DataLayout compute_data_layout;\n    se::dnn::FilterLayout filter_layout;\n\n    std::tie(compute_data_layout, filter_layout) =\n        compute_data_format == FORMAT_NHWC ? kComputeInNHWC : kComputeInNCHW;\n\n    se::dnn::BatchDescriptor input_desc(3);\n    input_desc.set_count(dims.batch_size)\n        .set_spatial_dim(DimIndex::X, compatible_input_shape.dim_size(4))\n        .set_spatial_dim(DimIndex::Y, compatible_input_shape.dim_size(3))\n        .set_spatial_dim(DimIndex::Z, compatible_input_shape.dim_size(2))\n        .set_feature_map_count(dims.in_depth)\n        .set_layout(compute_data_layout);\n    se::dnn::BatchDescriptor output_desc(3);\n    output_desc.set_count(dims.batch_size)\n        .set_spatial_dim(DimIndex::X, dims.output_size(2))\n        .set_spatial_dim(DimIndex::Y, dims.output_size(1))\n        .set_spatial_dim(DimIndex::Z, dims.output_size(0))\n        .set_feature_map_count(dims.out_depth)\n        .set_layout(compute_data_layout);\n    se::dnn::FilterDescriptor filter_desc(3);\n    filter_desc.set_spatial_dim(DimIndex::X, dims.filter_size(2))\n        .set_spatial_dim(DimIndex::Y, dims.filter_size(1))\n        .set_spatial_dim(DimIndex::Z, dims.filter_size(0))\n        .set_input_feature_map_count(filter_shape.dim_size(3))\n        .set_output_feature_map_count(filter_shape.dim_size(4))\n        .set_layout(filter_layout);\n    se::dnn::ConvolutionDescriptor conv_desc(3);\n    conv_desc.set_dilation_rate(DimIndex::X, dims.dilation(2))\n        .set_dilation_rate(DimIndex::Y, dims.dilation(1))\n        .set_dilation_rate(DimIndex::Z, dims.dilation(0))\n        .set_filter_stride(DimIndex::X, dims.stride(2))\n        .set_filter_stride(DimIndex::Y, dims.stride(1))\n        .set_filter_stride(DimIndex::Z, dims.stride(0))\n        .set_zero_padding(DimIndex::X, padding_cols / 2)\n        .set_zero_padding(DimIndex::Y, padding_rows / 2)\n        .set_zero_padding(DimIndex::Z, padding_planes / 2)\n        .set_group_count(dims.in_depth / filter_shape.dim_size(3));\n\n    // Shape: out, in, z, y, x.\n    Tensor transformed_filter;\n    auto dst_format =\n        compute_data_format == FORMAT_NCHW ? FORMAT_OIHW : FORMAT_OHWI;\n    TensorShape dst_shape =\n        dst_format == FORMAT_OIHW\n            ? TensorShape({filter_shape.dim_size(4), filter_shape.dim_size(3),\n                           dims.filter_size(0), dims.filter_size(1),\n                           dims.filter_size(2)})\n            : TensorShape({filter_shape.dim_size(4), dims.filter_size(0),\n                           dims.filter_size(1), dims.filter_size(2),\n                           filter_shape.dim_size(3)});\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value, dst_shape,\n                                          &transformed_filter));\n\n    functor::TransformFilter<GPUDevice, T, int, 5>()(\n        context->eigen_device<GPUDevice>(), dst_format,\n        To32Bit(filter.tensor<T, 5>()),\n        To32Bit(transformed_filter.tensor<T, 5>()));\n\n    // Shape: batch, filters, z, y, x.\n    Tensor transformed_out_backprop;\n    if (data_format_ == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {\n      TensorShape nchw_shape = {dims.batch_size, dims.out_depth,\n                                dims.output_size(0), dims.output_size(1),\n                                dims.output_size(2)};\n      if (dims.out_depth > 1) {\n        OP_REQUIRES_OK(context, context->allocate_temp(\n                                    DataTypeToEnum<T>::value, nchw_shape,\n                                    &transformed_out_backprop));\n        functor::NHWCToNCHW<GPUDevice, T, 5>()(\n            context->eigen_device<GPUDevice>(), out_backprop.tensor<T, 5>(),\n            transformed_out_backprop.tensor<T, 5>());\n      } else {\n        CHECK(transformed_out_backprop.CopyFrom(out_backprop, nchw_shape));\n      }\n    } else {\n      transformed_out_backprop = out_backprop;\n    }\n    // Shape: batch, filters, z, y, x.\n    Tensor pre_transformed_in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(\n                       DataTypeToEnum<T>::value,\n                       ShapeFromFormat(compute_data_format,\n                                       compatible_input_shape.dim_size(0),\n                                       {{compatible_input_shape.dim_size(2),\n                                         compatible_input_shape.dim_size(3),\n                                         compatible_input_shape.dim_size(4)}},\n                                       compatible_input_shape.dim_size(1)),\n                       &pre_transformed_in_backprop));\n\n    auto out_backprop_ptr =\n        AsDeviceMemory(transformed_out_backprop.template flat<T>().data(),\n                       transformed_out_backprop.template flat<T>().size());\n    auto filter_ptr =\n        AsDeviceMemory(transformed_filter.template flat<T>().data(),\n                       transformed_filter.template flat<T>().size());\n    auto in_backprop_ptr =\n        AsDeviceMemory(pre_transformed_in_backprop.template flat<T>().data(),\n                       pre_transformed_in_backprop.template flat<T>().size());\n\n    static int64_t ConvolveBackwardDataScratchSize = GetDnnWorkspaceLimit(\n        \"TF_CUDNN_WORKSPACE_LIMIT_IN_MB\", 1LL << 32);  // 4GB by default\n\n    const int device_id = stream->parent()->device_ordinal();\n    // To make sure the Conv3DBackpropInputV2 get the correct dtype, we infer\n    // the dtype from 2nd input, i.e., out_backprop.\n    DataType dtype = context->input(2).dtype();\n    const ConvParameters conv_parameters = {\n        dims.batch_size,\n        dims.in_depth,\n        {{dims.input_size(0), dims.input_size(1), dims.input_size(2)}},\n        compute_data_format,\n        dims.out_depth,\n        {{dims.filter_size(0), dims.filter_size(1), dims.filter_size(2)}},\n        {{dims.dilation(0), dims.dilation(1), dims.dilation(2)}},\n        {{dims.stride(0), dims.stride(1), dims.stride(2)}},\n        {{padding_planes, padding_rows, padding_cols}},\n        dtype,\n        device_id,\n        conv_desc.group_count()};\n\n    using se::dnn::AlgorithmConfig;\n    using se::dnn::AlgorithmDesc;\n    using se::dnn::ProfileResult;\n\n    auto entry_or = AutotuneUnfusedConv(\n        cudnn_use_autotune_, AutotuneConv3dBwdData::GetInstance(),\n        conv_parameters, context, se::dnn::ConvolutionKind::BACKWARD_DATA,\n        input_desc, in_backprop_ptr, filter_desc, filter_ptr, conv_desc,\n        output_desc, out_backprop_ptr, ConvolveBackwardDataScratchSize);\n    OP_REQUIRES_OK(context, entry_or.status());\n    auto autotune_entry = entry_or.ConsumeValueOrDie();\n\n    DnnScratchAllocator scratch_allocator(ConvolveBackwardDataScratchSize,\n                                          context);\n    Status cudnn_launch_status = LaunchAutotunedConv(\n        autotune_entry, &scratch_allocator,\n        se::dnn::ConvolutionKind::BACKWARD_DATA, stream, input_desc,\n        in_backprop_ptr, filter_desc, filter_ptr, conv_desc, output_desc,\n        out_backprop_ptr);\n    if (!cudnn_launch_status.ok()) {\n      context->SetStatus(cudnn_launch_status);\n      return;\n    }\n\n    if (rows_odd || cols_odd || planes_odd) {\n      Tensor in_backprop_remove_padding;\n      OP_REQUIRES_OK(\n          context, context->allocate_temp(\n                       DataTypeToEnum<T>::value,\n                       ShapeFromFormat(compute_data_format, dims.batch_size,\n                                       {{dims.input_size(0), dims.input_size(1),\n                                         dims.input_size(2)}},\n                                       dims.in_depth),\n                       &in_backprop_remove_padding));\n\n      // Remove the padding for odd spatial dimensions.\n      functor::PadInput<GPUDevice, T, int, 5>()(\n          context->eigen_device<GPUDevice>(),\n          To32Bit(const_cast<const Tensor&>(pre_transformed_in_backprop)\n                      .tensor<T, 5>()),\n          {{0, 0, 0}}, {{-planes_odd, -rows_odd, -cols_odd}},\n          To32Bit(in_backprop_remove_padding.tensor<T, 5>()),\n          compute_data_format, T{});\n\n      pre_transformed_in_backprop = in_backprop_remove_padding;\n    }\n\n    if (data_format_ == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {\n      auto toConstTensor = [](const Tensor& x) -> const Tensor { return x; };\n      functor::NCHWToNHWC<GPUDevice, T, 5>()(\n          context->eigen_device<GPUDevice>(),\n          toConstTensor(pre_transformed_in_backprop).template tensor<T, 5>(),\n          in_backprop->tensor<T, 5>());\n    } else {\n      *in_backprop = pre_transformed_in_backprop;\n    }\n  }\n\n private:\n  std::vector<int32> dilation_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool takes_shape_;\n  bool cudnn_use_autotune_;\n};\n\n// A dummy type to group backward filter autotune results together.\nstruct Conv3dBackwardFilterAutotuneGroup {\n  static string name() { return \"Conv3dBwdFilter\"; }\n};\n\ntypedef AutotuneSingleton<Conv3dBackwardFilterAutotuneGroup, ConvParameters,\n                          AutotuneEntry<se::dnn::ConvOp>>\n    AutotuneConv3dBwdFilter;\n\ntemplate <typename T>\nclass Conv3DBackpropFilterOp<GPUDevice, T> : public OpKernel {\n public:\n  explicit Conv3DBackpropFilterOp(OpKernelConstruction* context)\n      : OpKernel(context),\n        data_format_(FORMAT_NHWC),\n        takes_shape_(type_string().find(\"V2\") != std::string::npos) {\n    // data_format is only available in V2.\n    if (takes_shape_) {\n      string data_format;\n      OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n      OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n    }\n    OP_REQUIRES_OK(context, context->GetAttr(\"dilations\", &dilation_));\n    OP_REQUIRES(context, dilation_.size() == 5,\n                errors::InvalidArgument(\"Dilation rates field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, 'C') == 1 &&\n                 GetTensorDim(dilation_, data_format_, 'N') == 1),\n                errors::InvalidArgument(\n                    \"Current implementation does not yet support \"\n                    \"dilation rates in the batch and depth dimensions.\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(dilation_, data_format_, '0') > 0 &&\n         GetTensorDim(dilation_, data_format_, '1') > 0 &&\n         GetTensorDim(dilation_, data_format_, '2') > 0),\n        errors::InvalidArgument(\"Dilated rates should be larger than 0.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 5,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, 'C') == 1 &&\n         GetTensorDim(stride_, data_format_, 'N') == 1),\n        errors::InvalidArgument(\"Current implementation does not yet support \"\n                                \"strides in the batch and depth dimensions.\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, '0') > 0 &&\n         GetTensorDim(stride_, data_format_, '1') > 0 &&\n         GetTensorDim(stride_, data_format_, '2') > 0),\n        errors::InvalidArgument(\"Spatial strides should be larger than 0.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    cudnn_use_autotune_ = CudnnUseAutotune();\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape filter_shape;\n    if (takes_shape_) {\n      const Tensor& filter_sizes = context->input(1);\n      OP_REQUIRES_OK(context, tensor::MakeShape(filter_sizes, &filter_shape));\n    } else {\n      filter_shape = context->input(1).shape();\n    }\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(\n        context,\n        ConvBackpropComputeDimensionsV2(\n            \"Conv3DBackpropFilterOp\", /*num_spatial_dims=*/3, input_shape,\n            filter_shape, out_backprop_shape, dilation_, stride_, padding_,\n            /*explicit_paddings=*/{}, data_format_, &dims));\n\n    Tensor* filter_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, filter_shape, &filter_backprop));\n\n    auto* stream = context->op_device_context()->stream();\n    OP_REQUIRES(context, stream, errors::Internal(\"No GPU stream available.\"));\n\n    bool is_grouped_convolution = filter_shape.dim_size(3) != dims.in_depth;\n    if (!is_grouped_convolution && dims.filter_size(1) == 1 &&\n        dims.filter_size(2) == 1 && dims.filter_size(0) == 1 &&\n        dims.dilation(2) == 1 && dims.dilation(1) == 1 &&\n        dims.dilation(0) == 1 && dims.stride(2) == 1 && dims.stride(1) == 1 &&\n        dims.stride(0) == 1 && data_format_ == FORMAT_NHWC) {\n      const uint64 m = dims.in_depth;\n      const uint64 k = dims.batch_size * dims.input_size(1) *\n                       dims.input_size(2) * dims.input_size(0);\n      const uint64 n = dims.out_depth;\n\n      // The shape of output backprop is\n      //   [batch, out_z, out_y, out_x, out_depth]\n      // From cublas's perspective, it is: n x k\n      auto a_ptr = AsDeviceMemory(out_backprop.template flat<T>().data(),\n                                  out_backprop.template flat<T>().size());\n\n      // The shape of input is:\n      //   [batch, in_z, in_y, in_x, in_depth],\n      // From cublas's perspective, it is: m x k\n      auto b_ptr = AsDeviceMemory(input.template flat<T>().data(),\n                                  input.template flat<T>().size());\n\n      // The shape of the filter backprop is:\n      //   [1, 1, 1, in_depth, out_depth]\n      // From cublas's perspective, it is: n x m\n      auto c_ptr = AsDeviceMemory(filter_backprop->template flat<T>().data(),\n                                  filter_backprop->template flat<T>().size());\n\n      OP_REQUIRES_OK(context,\n                     stream->ThenBlasGemm(se::blas::Transpose::kNoTranspose,\n                                          se::blas::Transpose::kTranspose, n, m,\n                                          k, a_ptr, n, b_ptr, m, &c_ptr, n));\n      return;\n    } else if (!is_grouped_convolution &&\n               dims.filter_size(0) == dims.input_size(0) &&\n               dims.filter_size(1) == dims.input_size(1) &&\n               dims.filter_size(2) == dims.input_size(2) &&\n               padding_ == Padding::VALID && data_format_ == FORMAT_NHWC) {\n      const uint64 m = dims.input_size(0) * dims.input_size(1) *\n                       dims.input_size(2) * dims.in_depth;\n      const uint64 k = dims.batch_size;\n      const uint64 n = dims.out_depth;\n\n      auto a_ptr = AsDeviceMemory(input.template flat<T>().data(),\n                                  input.template flat<T>().size());\n      auto b_ptr = AsDeviceMemory(out_backprop.template flat<T>().data(),\n                                  out_backprop.template flat<T>().size());\n      auto c_ptr = AsDeviceMemory(filter_backprop->template flat<T>().data(),\n                                  filter_backprop->template flat<T>().size());\n\n      OP_REQUIRES_OK(context,\n                     stream->ThenBlasGemm(se::blas::Transpose::kNoTranspose,\n                                          se::blas::Transpose::kTranspose, n, m,\n                                          k, b_ptr, n, a_ptr, m, &c_ptr, n));\n      return;\n    }\n\n    int padding_planes = dims.SpatialPadding(padding_, 0);\n    int padding_rows = dims.SpatialPadding(padding_, 1);\n    int padding_cols = dims.SpatialPadding(padding_, 2);\n    const bool planes_odd = (padding_planes % 2 != 0);\n    const bool rows_odd = (padding_rows % 2 != 0);\n    const bool cols_odd = (padding_cols % 2 != 0);\n\n    Tensor compatible_input;\n    if (rows_odd || cols_odd || planes_odd) {\n      OP_REQUIRES_OK(context,\n                     context->allocate_temp(\n                         DataTypeToEnum<T>::value,\n                         ShapeFromFormat(data_format_, dims.batch_size,\n                                         {{dims.input_size(0) + planes_odd,\n                                           dims.input_size(1) + rows_odd,\n                                           dims.input_size(2) + cols_odd}},\n                                         dims.in_depth),\n                         &compatible_input));\n      functor::PadInput<GPUDevice, T, int, 5>()(\n          context->template eigen_device<GPUDevice>(),\n          To32Bit(input.tensor<T, 5>()), {{0, 0, 0}},\n          {{planes_odd, rows_odd, cols_odd}},\n          To32Bit(compatible_input.tensor<T, 5>()), data_format_, T{});\n    } else {\n      compatible_input = input;\n    }\n\n    CHECK(padding_rows >= 0 && padding_cols >= 0 && padding_planes >= 0)\n        << \"Negative paddings: (\" << padding_rows << \", \" << padding_cols\n        << \", \" << padding_planes << \")\";\n\n#if GOOGLE_CUDA\n    const bool compute_in_nhwc =\n        CUDNN_VERSION >= 8000 && DataTypeToEnum<T>::value == DT_HALF;\n#else\n    // fast NDHWC implementation is a CUDA only feature\n    const bool compute_in_nhwc = false;\n#endif\n    const TensorFormat compute_data_format =\n        (compute_in_nhwc && data_format_ == FORMAT_NHWC) ? FORMAT_NHWC\n                                                         : FORMAT_NCHW;\n\n    VLOG(3) << \"Compute Conv3DBackpropFilter with cuDNN:\"\n            << \" data_format=\" << ToString(data_format_)\n            << \" compute_data_format=\" << ToString(compute_data_format);\n\n    constexpr auto kComputeInNHWC =\n        std::make_tuple(se::dnn::DataLayout::kBatchYXDepth,\n                        se::dnn::FilterLayout::kOutputYXInput);\n    constexpr auto kComputeInNCHW =\n        std::make_tuple(se::dnn::DataLayout::kBatchDepthYX,\n                        se::dnn::FilterLayout::kOutputInputYX);\n\n    se::dnn::DataLayout compute_data_layout;\n    se::dnn::FilterLayout filter_layout;\n\n    std::tie(compute_data_layout, filter_layout) =\n        compute_data_format == FORMAT_NHWC ? kComputeInNHWC : kComputeInNCHW;\n\n    se::dnn::BatchDescriptor input_desc(3);\n    input_desc.set_count(dims.batch_size)\n        .set_spatial_dim(DimIndex::X,\n                         GetTensorDim(compatible_input, data_format_, '2'))\n        .set_spatial_dim(DimIndex::Y,\n                         GetTensorDim(compatible_input, data_format_, '1'))\n        .set_spatial_dim(DimIndex::Z,\n                         GetTensorDim(compatible_input, data_format_, '0'))\n        .set_feature_map_count(dims.in_depth)\n        .set_layout(compute_data_layout);\n    se::dnn::BatchDescriptor output_desc(3);\n    output_desc.set_count(dims.batch_size)\n        .set_spatial_dim(DimIndex::X, dims.output_size(2))\n        .set_spatial_dim(DimIndex::Y, dims.output_size(1))\n        .set_spatial_dim(DimIndex::Z, dims.output_size(0))\n        .set_feature_map_count(dims.out_depth)\n        .set_layout(compute_data_layout);\n    se::dnn::FilterDescriptor filter_desc(3);\n    filter_desc.set_spatial_dim(DimIndex::X, dims.filter_size(2))\n        .set_spatial_dim(DimIndex::Y, dims.filter_size(1))\n        .set_spatial_dim(DimIndex::Z, dims.filter_size(0))\n        .set_input_feature_map_count(filter_shape.dim_size(3))\n        .set_output_feature_map_count(filter_shape.dim_size(4))\n        .set_layout(filter_layout);\n    se::dnn::ConvolutionDescriptor conv_desc(3);\n    conv_desc.set_dilation_rate(DimIndex::X, dims.dilation(2))\n        .set_dilation_rate(DimIndex::Y, dims.dilation(1))\n        .set_dilation_rate(DimIndex::Z, dims.dilation(0))\n        .set_filter_stride(DimIndex::X, dims.stride(2))\n        .set_filter_stride(DimIndex::Y, dims.stride(1))\n        .set_filter_stride(DimIndex::Z, dims.stride(0))\n        .set_zero_padding(DimIndex::X, padding_cols / 2)\n        .set_zero_padding(DimIndex::Y, padding_rows / 2)\n        .set_zero_padding(DimIndex::Z, padding_planes / 2)\n        .set_group_count(dims.in_depth / filter_shape.dim_size(3));\n\n    Tensor pre_transformed_filter_backprop;\n    auto dst_format =\n        compute_data_format == FORMAT_NCHW ? FORMAT_OIHW : FORMAT_OHWI;\n    TensorShape dst_shape =\n        dst_format == FORMAT_OIHW\n            ? TensorShape({filter_shape.dim_size(4), filter_shape.dim_size(3),\n                           dims.filter_size(0), dims.filter_size(1),\n                           dims.filter_size(2)})\n            : TensorShape({filter_shape.dim_size(4), dims.filter_size(0),\n                           dims.filter_size(1), dims.filter_size(2),\n                           filter_shape.dim_size(3)});\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value, dst_shape,\n                                          &pre_transformed_filter_backprop));\n\n    Tensor transformed_out_backprop;\n    if (data_format_ == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {\n      VLOG(4) << \"Convert the `out_backprop` tensor from NDHWC to NCDHW.\";\n      TensorShape nchw_shape = {dims.batch_size, dims.out_depth,\n                                dims.output_size(0), dims.output_size(1),\n                                dims.output_size(2)};\n      OP_REQUIRES_OK(\n          context, context->allocate_temp(DataTypeToEnum<T>::value, nchw_shape,\n                                          &transformed_out_backprop));\n      if (dims.out_depth > 1) {\n        functor::NHWCToNCHW<GPUDevice, T, 5>()(\n            context->eigen_device<GPUDevice>(), out_backprop.tensor<T, 5>(),\n            transformed_out_backprop.tensor<T, 5>());\n      } else {\n        CHECK(transformed_out_backprop.CopyFrom(out_backprop, nchw_shape));\n      }\n    } else {\n      transformed_out_backprop = out_backprop;\n    }\n    Tensor transformed_input;\n    if (data_format_ == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {\n      VLOG(4) << \"Convert the `input` tensor from NDHWC to NCDHW.\";\n      TensorShape nchw_shape = {\n          dims.batch_size, dims.in_depth, compatible_input.dim_size(1),\n          compatible_input.dim_size(2), compatible_input.dim_size(3)};\n      if (dims.in_depth > 1) {\n        OP_REQUIRES_OK(context,\n                       context->allocate_temp(DataTypeToEnum<T>::value,\n                                              nchw_shape, &transformed_input));\n        functor::NHWCToNCHW<GPUDevice, T, 5>()(\n            context->eigen_device<GPUDevice>(),\n            const_cast<const Tensor&>(compatible_input).tensor<T, 5>(),\n            transformed_input.tensor<T, 5>());\n      } else {\n        CHECK(transformed_input.CopyFrom(compatible_input, nchw_shape));\n      }\n    } else {\n      transformed_input = compatible_input;\n    }\n\n    auto out_backprop_ptr =\n        AsDeviceMemory(transformed_out_backprop.template flat<T>().data(),\n                       transformed_out_backprop.template flat<T>().size());\n    auto filter_backprop_ptr = AsDeviceMemory(\n        pre_transformed_filter_backprop.template flat<T>().data(),\n        pre_transformed_filter_backprop.template flat<T>().size());\n    auto input_ptr =\n        AsDeviceMemory(transformed_input.template flat<T>().data(),\n                       transformed_input.template flat<T>().size());\n\n    static int64_t ConvolveBackwardFilterScratchSize = GetDnnWorkspaceLimit(\n        \"TF_CUDNN_WORKSPACE_LIMIT_IN_MB\", 1LL << 32);  // 4GB by default\n\n    const int device_id = stream->parent()->device_ordinal();\n    DataType dtype = input.dtype();\n    const ConvParameters conv_parameters = {\n        dims.batch_size,\n        dims.in_depth,\n        {{dims.input_size(0), dims.input_size(1), dims.input_size(2)}},\n        compute_data_format,\n        dims.out_depth,\n        {{dims.filter_size(0), dims.filter_size(1), dims.filter_size(2)}},\n        {{dims.dilation(0), dims.dilation(1), dims.dilation(2)}},\n        {{dims.stride(0), dims.stride(1), dims.stride(2)}},\n        {{padding_planes, padding_rows, padding_cols}},\n        dtype,\n        device_id,\n        conv_desc.group_count()};\n\n    using se::dnn::AlgorithmConfig;\n    using se::dnn::AlgorithmDesc;\n    using se::dnn::ProfileResult;\n\n    auto entry_or = AutotuneUnfusedConv(\n        cudnn_use_autotune_, AutotuneConv3dBwdFilter::GetInstance(),\n        conv_parameters, context, se::dnn::ConvolutionKind::BACKWARD_FILTER,\n        input_desc, input_ptr, filter_desc, filter_backprop_ptr, conv_desc,\n        output_desc, out_backprop_ptr, ConvolveBackwardFilterScratchSize);\n    OP_REQUIRES_OK(context, entry_or.status());\n    auto autotune_entry = entry_or.ConsumeValueOrDie();\n\n    DnnScratchAllocator scratch_allocator(ConvolveBackwardFilterScratchSize,\n                                          context);\n    Status cudnn_launch_status = LaunchAutotunedConv(\n        autotune_entry, &scratch_allocator,\n        se::dnn::ConvolutionKind::BACKWARD_FILTER, stream, input_desc,\n        input_ptr, filter_desc, filter_backprop_ptr, conv_desc, output_desc,\n        out_backprop_ptr);\n    if (!cudnn_launch_status.ok()) {\n      context->SetStatus(cudnn_launch_status);\n      return;\n    }\n\n    auto toConstTensor = [](const Tensor& x) -> const Tensor { return x; };\n    functor::ReverseTransformFilter<GPUDevice, T, 5>()(\n        context->eigen_device<GPUDevice>(), /*src_filter_format=*/dst_format,\n        toConstTensor(pre_transformed_filter_backprop).template tensor<T, 5>(),\n        filter_backprop->tensor<T, 5>());\n  }\n\n private:\n  std::vector<int32> dilation_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool takes_shape_;\n  bool cudnn_use_autotune_;\n};\n\n#define REGISTER_GPU_KERNEL(T)                                                \\\n  REGISTER_KERNEL_BUILDER(                                                    \\\n      Name(\"Conv3DBackpropInput\").Device(DEVICE_GPU).TypeConstraint<T>(\"T\"),  \\\n      Conv3DBackpropInputOp<GPUDevice, T>);                                   \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropInputV2\")                       \\\n                              .Device(DEVICE_GPU)                             \\\n                              .TypeConstraint<T>(\"T\")                         \\\n                              .HostMemory(\"input_sizes\"),                     \\\n                          Conv3DBackpropInputOp<GPUDevice, T>);               \\\n  REGISTER_KERNEL_BUILDER(                                                    \\\n      Name(\"Conv3DBackpropFilter\").Device(DEVICE_GPU).TypeConstraint<T>(\"T\"), \\\n      Conv3DBackpropFilterOp<GPUDevice, T>);                                  \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilterV2\")                      \\\n                              .Device(DEVICE_GPU)                             \\\n                              .TypeConstraint<T>(\"T\")                         \\\n                              .HostMemory(\"filter_sizes\"),                    \\\n                          Conv3DBackpropFilterOp<GPUDevice, T>);\nTF_CALL_half(REGISTER_GPU_KERNEL);\nTF_CALL_float(REGISTER_GPU_KERNEL);\nTF_CALL_double(REGISTER_GPU_KERNEL);\n#undef REGISTER_GPU_KERNEL\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for convolution related functionality in tensorflow.ops.nn.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gradient_checker\nfrom tensorflow.python.ops import nn_ops\nimport tensorflow.python.ops.nn_grad  # pylint: disable=unused-import\nfrom tensorflow.python.platform import test\n\n\nclass Conv3DBackpropFilterV2GradTest(test.TestCase):\n\n  @test_util.run_deprecated_v1\n  def testGradient(self):\n    with self.cached_session():\n      for padding in [\"SAME\", \"VALID\"]:\n        for stride in [1, 2]:\n          np.random.seed(1)\n          in_shape = [2, 4, 3, 3, 2]\n          in_val = constant_op.constant(\n              2 * np.random.random_sample(in_shape) - 1, dtype=dtypes.float32)\n          filter_shape = [3, 3, 3, 2, 3]\n          strides = [1, stride, stride, stride, 1]\n          # Make a convolution op with the current settings, just to easily get\n          # the shape of the output.\n          conv_out = nn_ops.conv3d(in_val,\n                                   array_ops.zeros(filter_shape), strides,\n                                   padding)\n          out_backprop_shape = conv_out.get_shape().as_list()\n          out_backprop_val = constant_op.constant(\n              2 * np.random.random_sample(out_backprop_shape) - 1,\n              dtype=dtypes.float32)\n          output = nn_ops.conv3d_backprop_filter_v2(in_val, filter_shape,\n                                                    out_backprop_val, strides,\n                                                    padding)\n          err = gradient_checker.compute_gradient_error(\n              [in_val, out_backprop_val], [in_shape, out_backprop_shape],\n              output, filter_shape)\n          print(\"conv3d_backprop_filter gradient err = %g \" % err)\n          err_tolerance = 1e-3\n          self.assertLess(err, err_tolerance)\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#define USE_EIGEN_TENSOR\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/framework/kernel_shape_util.h\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_slice.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/kernels/conv_2d.h\"\n#include \"tensorflow/core/kernels/conv_3d.h\"\n#include \"tensorflow/core/kernels/conv_grad_ops.h\"\n#include \"tensorflow/core/kernels/conv_grad_shape_utils.h\"\n#include \"tensorflow/core/kernels/conv_ops_gpu.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/profiler/lib/scoped_annotation.h\"\n#include \"tensorflow/core/util/padding.h\"\n#include \"tensorflow/core/util/tensor_format.h\"\n#include \"tensorflow/core/util/use_cudnn.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\n#if defined(TENSORFLOW_USE_CUSTOM_CONTRACTION_KERNEL)\n#include \"tensorflow/core/kernels/eigen_contraction_kernel.h\"\n#endif\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/platform/stream_executor.h\"\nusing stream_executor::dnn::DimIndex;\n#include \"tensorflow/core/protobuf/autotuning.pb.h\"\n#include \"tensorflow/core/util/autotune_maps/conv_parameters.h\"\n#include \"tensorflow/core/util/proto/proto_utils.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#if GOOGLE_CUDA\n#include \"third_party/gpus/cudnn/cudnn.h\"\n#include \"tensorflow/stream_executor/gpu/gpu_asm_opts.h\"\n#include \"tensorflow/stream_executor/gpu/redzone_allocator.h\"\n#include \"tensorflow/stream_executor/tf_allocator_adapter.h\"\n#endif  // GOOGLE_CUDA\n\nnamespace {\n\n// TODO(ezhulenev): Split this file into conv_grad_filter_ops_3d.cc and\n// conv_grad_input_ops_3d.cc.\n\n// TODO(ezhulenev): Generalize Col2im and Im2col for 2-d and 3-d kernels.\n\n// \"Depth\" is already used for the channel dimension, so for the third spatial\n// dimension in this file we use \"plane\", although in NDHWC layout it's\n// indicated with a \"D\".\n\n// Returns in 'im_data' (assumed to be zero-initialized) image patch in storage\n// order (planes, height, width, depth), constructed from patches in 'col_data',\n// which is required to be in storage order (out_planes * out_height *\n// out_width, filter_planes, filter_height, filter_width, in_depth).\n//\n// Based on 2-dimensional implementation written by Yangqing Jia (jiayq).\ntemplate <typename T>\nvoid Col2im(const T* col_data, const int depth, const int planes,\n            const int height, const int width, const int filter_p,\n            const int filter_h, const int filter_w, const int pad_pt,\n            const int pad_t, const int pad_l, const int pad_pb, const int pad_b,\n            const int pad_r, const int stride_p, const int stride_h,\n            const int stride_w, T* im_data) {\n  const int planes_col = (planes + pad_pt + pad_pb - filter_p) / stride_p + 1;\n  const int height_col = (height + pad_t + pad_b - filter_h) / stride_h + 1;\n  const int width_col = (width + pad_l + pad_r - filter_w) / stride_w + 1;\n  int p_pad = -pad_pt;\n  for (int p = 0; p < planes_col; ++p) {\n    int h_pad = -pad_t;\n    for (int h = 0; h < height_col; ++h) {\n      int w_pad = -pad_l;\n      for (int w = 0; w < width_col; ++w) {\n        T* im_patch_data =\n            im_data + (p_pad * height * width + h_pad * width + w_pad) * depth;\n        for (int ip = p_pad; ip < p_pad + filter_p; ++ip) {\n          for (int ih = h_pad; ih < h_pad + filter_h; ++ih) {\n            for (int iw = w_pad; iw < w_pad + filter_w; ++iw) {\n              if (ip >= 0 && ip < planes && ih >= 0 && ih < height && iw >= 0 &&\n                  iw < width) {\n                for (int i = 0; i < depth; ++i) {\n                  im_patch_data[i] += col_data[i];\n                }\n              }\n              im_patch_data += depth;\n              col_data += depth;\n            }\n            // Jump over remaining number of depth.\n            im_patch_data += depth * (width - filter_w);\n          }\n          // Jump over remaining number of (depth * width).\n          im_patch_data += (depth * width) * (height - filter_h);\n        }\n        w_pad += stride_w;\n      }\n      h_pad += stride_h;\n    }\n    p_pad += stride_p;\n  }\n}\n\n// Returns in 'col_data', image patches in storage order (planes, height, width,\n// depth) extracted from image at 'input_data', which is required to be in\n// storage order (batch, planes, height, width, depth).\n//\n// Based on 2-dimensional implementation written by Yangqing Jia (jiayq).\ntemplate <typename T>\nvoid Im2col(const T* input_data, const int depth, const int planes,\n            const int height, const int width, const int filter_p,\n            const int filter_h, const int filter_w, const int pad_pt,\n            const int pad_t, const int pad_l, const int pad_pb, const int pad_b,\n            const int pad_r, const int stride_p, const int stride_h,\n            const int stride_w, T* col_data) {\n  const int planes_col = (planes + pad_pt + pad_pb - filter_p) / stride_p + 1;\n  const int height_col = (height + pad_t + pad_b - filter_h) / stride_h + 1;\n  const int width_col = (width + pad_l + pad_r - filter_w) / stride_w + 1;\n\n  int p_pad = -pad_pt;\n  for (int p = 0; p < planes_col; ++p) {\n    int h_pad = -pad_t;\n    for (int h = 0; h < height_col; ++h) {\n      int w_pad = -pad_l;\n      for (int w = 0; w < width_col; ++w) {\n        for (int ip = p_pad; ip < p_pad + filter_p; ++ip) {\n          for (int ih = h_pad; ih < h_pad + filter_h; ++ih) {\n            for (int iw = w_pad; iw < w_pad + filter_w; ++iw) {\n              if (ip >= 0 && ip < planes && ih >= 0 && ih < height && iw >= 0 &&\n                  iw < width) {\n                memcpy(col_data,\n                       input_data +\n                           (ip * height * width + ih * width + iw) * depth,\n                       sizeof(T) * depth);\n              } else {\n                // This should be simply padded with zero.\n                memset(col_data, 0, sizeof(T) * depth);\n              }\n              col_data += depth;\n            }\n          }\n        }\n        w_pad += stride_w;\n      }\n      h_pad += stride_h;\n    }\n    p_pad += stride_p;\n  }\n}\n\n}  // namespace\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\n// Backprop for input that offloads computation to\n// Eigen::CuboidConvolutionBackwardInput.\ntemplate <typename Device, class T>\nclass Conv3DBackpropInputOp : public OpKernel {\n public:\n  explicit Conv3DBackpropInputOp(OpKernelConstruction* context)\n      : OpKernel(context),\n        data_format_(FORMAT_NHWC),\n        takes_shape_(type_string().find(\"V2\") != std::string::npos) {\n    // data_format is only available in V2.\n    if (takes_shape_) {\n      string data_format;\n      OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n      OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n      OP_REQUIRES(\n          context, data_format_ == FORMAT_NHWC,\n          errors::InvalidArgument(\n              \"Conv3DBackpropInputOpV2 only supports NDHWC on the CPU.\"));\n    }\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"dilations\", &dilation_));\n    OP_REQUIRES(context, dilation_.size() == 5,\n                errors::InvalidArgument(\"Dilation rates field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, 'C') == 1 &&\n                 GetTensorDim(dilation_, data_format_, 'N') == 1),\n                errors::InvalidArgument(\n                    \"Current implementation does not yet support \"\n                    \"dilation rates in the batch and depth dimensions.\"));\n\n    // TODO(yangzihao): Add CPU version of dilated conv 3D.\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, '0') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '1') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '2') == 1),\n                errors::InvalidArgument(\n                    \"Current CPU implementation does not yet support \"\n                    \"dilation rates larger than 1.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 5,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, 'C') == 1 &&\n         GetTensorDim(stride_, data_format_, 'N') == 1),\n        errors::InvalidArgument(\"Current implementation does not yet support \"\n                                \"strides in the batch and depth dimensions.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      // tensor::MakeShape is able to handle both DT_INT32 and DT_INT64 for\n      // input_sizes.\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n\n    OP_REQUIRES(context, input_shape.dims() == 5,\n                errors::InvalidArgument(\"input tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, filter_shape.dims() == 5,\n        errors::InvalidArgument(\"filter_sizes tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dims() == 5,\n        errors::InvalidArgument(\"out_backprop tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", /*num_spatial_dims=*/3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     // input_backward\n        filter.tensor<T, 5>(),                           // filter\n        out_backprop.tensor<T, 5>(),                     // output_backward\n        static_cast<int>(dims.spatial_dims[0].stride),   // stride_planes\n        static_cast<int>(dims.spatial_dims[1].stride),   // stride_rows\n        static_cast<int>(dims.spatial_dims[2].stride));  // stride_cols\n  }\n\n private:\n  std::vector<int32> dilation_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool takes_shape_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(Conv3DBackpropInputOp);\n};\n\n// Custom backprop for input that explicitly does the work sharding and calls\n// Eigen only to multiply matrices.\ntemplate <typename Device, class T>\nclass Conv3DCustomBackpropInputOp : public OpKernel {\n  // Limit the maximum size of allocated temporary buffer to\n  // kMaxTempAllocationOverhead times the size of the input tensors (input,\n  // filter, out_backprop). If the size of the temporary buffer exceeds this\n  // limit, fallback on Eigen implementation.\n  static constexpr int kMaxTempAllocationOverhead = 25;\n\n public:\n  explicit Conv3DCustomBackpropInputOp(OpKernelConstruction* context)\n      : OpKernel(context),\n        data_format_(FORMAT_NHWC),\n        takes_shape_(type_string().find(\"V2\") != std::string::npos) {\n    // data_format is only available in V2.\n    if (takes_shape_) {\n      string data_format;\n      OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n      OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n      OP_REQUIRES(\n          context, data_format_ == FORMAT_NHWC,\n          errors::InvalidArgument(\n              \"Conv3DBackpropInputOpV2 only supports NDHWC on the CPU.\"));\n    }\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"dilations\", &dilation_));\n    OP_REQUIRES(context, dilation_.size() == 5,\n                errors::InvalidArgument(\"Dilation rates field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, 'C') == 1 &&\n                 GetTensorDim(dilation_, data_format_, 'N') == 1),\n                errors::InvalidArgument(\n                    \"Current implementation does not yet support \"\n                    \"dilation rates in the batch and depth dimensions.\"));\n\n    // TODO(yangzihao): Add CPU version of dilated conv 3D.\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, '0') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '1') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '2') == 1),\n                errors::InvalidArgument(\n                    \"Current CPU implementation does not yet support \"\n                    \"dilation rates larger than 1.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 5,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, 'C') == 1 &&\n         GetTensorDim(stride_, data_format_, 'N') == 1),\n        errors::InvalidArgument(\"Current implementation does not yet support \"\n                                \"strides in the batch and depth dimensions.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      // tensor::MakeShape is able to handle both DT_INT32 and DT_INT64 for\n      // input_sizes.\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n\n    OP_REQUIRES(context, input_shape.dims() == 5,\n                errors::InvalidArgument(\"input tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, filter_shape.dims() == 5,\n        errors::InvalidArgument(\"filter_sizes tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dims() == 5,\n        errors::InvalidArgument(\"out_backprop tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", /*num_spatial_dims=*/3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n\n    int64_t top_pad_planes, bottom_pad_planes;\n    int64_t top_pad_rows, bottom_pad_rows;\n    int64_t left_pad_cols, right_pad_cols;\n\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[0].input_size,\n                                dims.spatial_dims[0].filter_size,\n                                dims.spatial_dims[0].stride, padding_,\n                                &dims.spatial_dims[0].output_size,\n                                &top_pad_planes, &bottom_pad_planes));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[1].input_size,\n                                dims.spatial_dims[1].filter_size,\n                                dims.spatial_dims[1].stride, padding_,\n                                &dims.spatial_dims[1].output_size,\n                                &top_pad_rows, &bottom_pad_rows));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[2].input_size,\n                                dims.spatial_dims[2].filter_size,\n                                dims.spatial_dims[2].stride, padding_,\n                                &dims.spatial_dims[2].output_size,\n                                &left_pad_cols, &right_pad_cols));\n\n    // TODO(ezhulenev): Extract work size and shard estimation to shared\n    // functions in conv_grad_ops, and update 2d convolution backprop.\n\n    // The total dimension size of each kernel.\n    const int64_t filter_total_size =\n        dims.spatial_dims[0].filter_size * dims.spatial_dims[1].filter_size *\n        dims.spatial_dims[2].filter_size * dims.in_depth;\n\n    // The output image size is the spatial size of the output.\n    const int64_t output_image_size = dims.spatial_dims[0].output_size *\n                                      dims.spatial_dims[1].output_size *\n                                      dims.spatial_dims[2].output_size;\n\n    const auto cache_sizes = Eigen::internal::CacheSizes();\n    const ptrdiff_t l3_cache_size = cache_sizes.m_l3;\n\n    // Use L3 cache size as target working set size.\n    const size_t target_working_set_size = l3_cache_size / sizeof(T);\n\n    // Calculate size of matrices involved in MatMul: C = A x B.\n    const int64_t size_A = output_image_size * dims.out_depth;\n\n    const int64_t size_B = filter_total_size * dims.out_depth;\n\n    const int64_t size_C = output_image_size * filter_total_size;\n\n    const int64_t work_unit_size = size_A + size_B + size_C;\n\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n\n    // Use parallel tensor contractions if there is no batching.\n    //\n    // Compared to Conv2D code, this version is missing work size estimation. In\n    // benchmarks I didn't find a case when it's beneficial to run parallel\n    // contraction compared to sharding and matmuls.\n    const bool use_parallel_contraction = dims.batch_size == 1;\n\n    OP_REQUIRES(\n        context, work_unit_size > 0,\n        errors::InvalidArgument(\"input, filter_sizes and out_backprop tensors \"\n                                \"must all have at least 1 element\"));\n\n    const size_t shard_size =\n        use_parallel_contraction\n            ? 1\n            : (target_working_set_size + work_unit_size - 1) / work_unit_size;\n\n    // Total number of elements in all the tensors used by this kernel.\n    int64_t total_tensor_elements = input_shape.num_elements() +\n                                    filter_shape.num_elements() +\n                                    out_backprop_shape.num_elements();\n\n    // Shape of the temporary workspace buffer.\n    TensorShape col_buffer_shape = {static_cast<int64_t>(shard_size),\n                                    static_cast<int64_t>(output_image_size),\n                                    static_cast<int64_t>(filter_total_size)};\n    int64_t col_buffer_elements = col_buffer_shape.num_elements();\n\n    // If the temporary allocation overhead is too large, fallback on Eigen\n    // implementation which requires much less memory.\n    int64_t col_buffer_overhead = col_buffer_elements / total_tensor_elements;\n    if (col_buffer_overhead > kMaxTempAllocationOverhead) {\n      VLOG(2) << \"Fallback on Eigen implementation of Conv3DBackpropInputOp: \"\n                 \"col_buffer_overhead=\"\n              << col_buffer_overhead;\n\n      functor::CuboidConvolutionBackwardInput<Device, T>()(\n          context->eigen_device<Device>(),\n          in_backprop->tensor<T, 5>(),                     // input_backward\n          filter.tensor<T, 5>(),                           // filter\n          out_backprop.tensor<T, 5>(),                     // output_backward\n          static_cast<int>(dims.spatial_dims[0].stride),   // stride_planes\n          static_cast<int>(dims.spatial_dims[1].stride),   // stride_rows\n          static_cast<int>(dims.spatial_dims[2].stride));  // stride_cols\n\n      return;\n    }\n\n    Tensor col_buffer;\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value,\n                                          col_buffer_shape, &col_buffer));\n\n    // The input offset corresponding to a single input image.\n    const int64_t input_offset =\n        dims.spatial_dims[0].input_size * dims.spatial_dims[1].input_size *\n        dims.spatial_dims[2].input_size * dims.in_depth;\n\n    // The output offset corresponding to a single output image.\n    const int64_t output_offset =\n        dims.spatial_dims[0].output_size * dims.spatial_dims[1].output_size *\n        dims.spatial_dims[2].output_size * dims.out_depth;\n\n    const T* filter_data = filter.template flat<T>().data();\n    T* col_buffer_data = col_buffer.template flat<T>().data();\n    const T* out_backprop_data = out_backprop.template flat<T>().data();\n\n    auto in_backprop_flat = in_backprop->template flat<T>();\n    T* input_backprop_data = in_backprop_flat.data();\n    in_backprop_flat.device(context->eigen_device<Device>()) =\n        in_backprop_flat.constant(T(0));\n\n    if (use_parallel_contraction) {\n      typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,\n                               Eigen::Unaligned>\n          TensorMap;\n      typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,\n                               Eigen::Unaligned>\n          ConstTensorMap;\n\n      // Initialize contraction dims (we need to transpose 'B' below).\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> contract_dims;\n      contract_dims[0].first = 1;\n      contract_dims[0].second = 1;\n\n      for (int image_id = 0; image_id < dims.batch_size; ++image_id) {\n        // Compute gradient into col_buffer.\n        TensorMap C(col_buffer_data, output_image_size, filter_total_size);\n\n        ConstTensorMap A(out_backprop_data + output_offset * image_id,\n                         output_image_size, dims.out_depth);\n        ConstTensorMap B(filter_data, filter_total_size, dims.out_depth);\n\n        C.device(context->eigen_cpu_device()) = A.contract(B, contract_dims);\n\n        Col2im<T>(col_buffer_data, dims.in_depth,\n                  // Input spatial dimensions.\n                  dims.spatial_dims[0].input_size,  // input planes\n                  dims.spatial_dims[1].input_size,  // input rows\n                  dims.spatial_dims[2].input_size,  // input cols\n                  // Filter spatial dimensions.\n                  dims.spatial_dims[0].filter_size,  // filter planes\n                  dims.spatial_dims[1].filter_size,  // filter rows\n                  dims.spatial_dims[2].filter_size,  // filter cols\n                  // Spatial padding.\n                  top_pad_planes, top_pad_rows, left_pad_cols,\n                  bottom_pad_planes, bottom_pad_rows, right_pad_cols,\n                  // Spatial striding.\n                  dims.spatial_dims[0].stride,  // stride planes\n                  dims.spatial_dims[1].stride,  // stride rows\n                  dims.spatial_dims[2].stride,  // stride cols\n                  input_backprop_data);\n\n        input_backprop_data += input_offset;\n      }\n    } else {\n      typedef Eigen::Map<\n          Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>>\n          MatrixMap;\n      typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic,\n                                             Eigen::RowMajor>>\n          ConstMatrixMap;\n\n      for (int image_id = 0; image_id < dims.batch_size;\n           image_id += shard_size) {\n        const int shard_limit =\n            std::min(static_cast<int>(shard_size),\n                     static_cast<int>(dims.batch_size) - image_id);\n\n        auto shard = [&dims, &top_pad_planes, &top_pad_rows, &left_pad_cols,\n                      &bottom_pad_planes, &bottom_pad_rows, &right_pad_cols,\n                      &output_image_size, &filter_total_size,\n                      &input_backprop_data, &col_buffer_data,\n                      &out_backprop_data, &filter_data, &input_offset,\n                      &output_offset, &size_C](int64_t start, int64_t limit) {\n          for (int shard_id = start; shard_id < limit; ++shard_id) {\n            T* im2col_buf = col_buffer_data + shard_id * size_C;\n            T* input_data = input_backprop_data + shard_id * input_offset;\n            const T* out_data = out_backprop_data + shard_id * output_offset;\n\n            // Compute gradient into 'im2col_buf'.\n            MatrixMap C(im2col_buf, output_image_size, filter_total_size);\n\n            ConstMatrixMap A(out_data, output_image_size, dims.out_depth);\n            ConstMatrixMap B(filter_data, filter_total_size, dims.out_depth);\n\n            C.noalias() = A * B.transpose();\n\n            Col2im<T>(im2col_buf, dims.in_depth,\n                      // Input spatial dimensions.\n                      dims.spatial_dims[0].input_size,  // input planes\n                      dims.spatial_dims[1].input_size,  // input rows\n                      dims.spatial_dims[2].input_size,  // input cols\n                      // Filter spatial dimensions.\n                      dims.spatial_dims[0].filter_size,  // filter planes\n                      dims.spatial_dims[1].filter_size,  // filter rows\n                      dims.spatial_dims[2].filter_size,  // filter cols\n                      // Spatial padding.\n                      top_pad_planes, top_pad_rows, left_pad_cols,\n                      bottom_pad_planes, bottom_pad_rows, right_pad_cols,\n                      // Spatial striding.\n                      dims.spatial_dims[0].stride,  // stride planes\n                      dims.spatial_dims[1].stride,  // stride rows\n                      dims.spatial_dims[2].stride,  // stride cols\n                      input_data);\n          }\n        };\n        Shard(worker_threads.num_threads, worker_threads.workers, shard_limit,\n              work_unit_size, shard);\n\n        input_backprop_data += input_offset * shard_limit;\n        out_backprop_data += output_offset * shard_limit;\n      }\n    }\n  }\n\n private:\n  std::vector<int32> dilation_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool takes_shape_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(Conv3DCustomBackpropInputOp);\n};\n\n// Custom backrop input kernel is 30% - 4x faster when compiled with AVX2 than\n// default Eigen implementation (at the cost of ~2x-8x peak memory usage).\n\n#define REGISTER_CPU_KERNEL(T)                                                 \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"Conv3DBackpropInput\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"),   \\\n      Conv3DCustomBackpropInputOp<CPUDevice, T>);                              \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"Conv3DBackpropInputV2\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      Conv3DCustomBackpropInputOp<CPUDevice, T>);                              \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropInput\")                          \\\n                              .Device(DEVICE_CPU)                              \\\n                              .Label(\"custom\")                                 \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          Conv3DCustomBackpropInputOp<CPUDevice, T>);          \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropInputV2\")                        \\\n                              .Device(DEVICE_CPU)                              \\\n                              .Label(\"custom\")                                 \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          Conv3DCustomBackpropInputOp<CPUDevice, T>);          \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropInput\")                          \\\n                              .Device(DEVICE_CPU)                              \\\n                              .Label(\"eigen_tensor\")                           \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          Conv3DBackpropInputOp<CPUDevice, T>);                \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropInputV2\")                        \\\n                              .Device(DEVICE_CPU)                              \\\n                              .Label(\"eigen_tensor\")                           \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          Conv3DBackpropInputOp<CPUDevice, T>);\n\nTF_CALL_half(REGISTER_CPU_KERNEL);\nTF_CALL_float(REGISTER_CPU_KERNEL);\nTF_CALL_double(REGISTER_CPU_KERNEL);\n#undef REGISTER_CPU_KERNEL\n\n// Backprop for filter that offloads computation to\n// Eigen::CuboidConvolutionBackwardFilter.\ntemplate <typename Device, class T>\nclass Conv3DBackpropFilterOp : public OpKernel {\n public:\n  explicit Conv3DBackpropFilterOp(OpKernelConstruction* context)\n      : OpKernel(context),\n        data_format_(FORMAT_NHWC),\n        takes_shape_(type_string().find(\"V2\") != std::string::npos) {\n    // data_format is only available in V2.\n    if (takes_shape_) {\n      string data_format;\n      OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n      OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n      OP_REQUIRES(\n          context, data_format_ == FORMAT_NHWC,\n          errors::InvalidArgument(\n              \"Conv3DBackpropFilterOpV2 only supports NDHWC on the CPU.\"));\n    }\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"dilations\", &dilation_));\n    OP_REQUIRES(context, dilation_.size() == 5,\n                errors::InvalidArgument(\"Dilation rates field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, 'C') == 1 &&\n                 GetTensorDim(dilation_, data_format_, 'N') == 1),\n                errors::InvalidArgument(\n                    \"Current implementation does not yet support \"\n                    \"dilation rates in the batch and depth dimensions.\"));\n\n    // TODO(yangzihao): Add CPU version of dilated conv 3D.\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, '0') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '1') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '2') == 1),\n                errors::InvalidArgument(\n                    \"Current CPU implementation does not yet support \"\n                    \"dilation rates larger than 1.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 5,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, 'C') == 1 &&\n         GetTensorDim(stride_, data_format_, 'N') == 1),\n        errors::InvalidArgument(\"Current implementation does not yet support \"\n                                \"strides in the batch and depth dimensions.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape filter_shape;\n    if (takes_shape_) {\n      const Tensor& filter_sizes = context->input(1);\n      OP_REQUIRES(context, TensorShapeUtils::IsVector(filter_sizes.shape()),\n                  errors::InvalidArgument(\n                      \"filter_sizes shape must be rank 1 but is rank \",\n                      filter_sizes.shape().dims()));\n      OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                  filter_sizes.vec<int32>(), &filter_shape));\n    } else {\n      filter_shape = context->input(1).shape();\n    }\n\n    OP_REQUIRES(context, input_shape.dims() == 5,\n                errors::InvalidArgument(\"input tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, filter_shape.dims() == 5,\n        errors::InvalidArgument(\"filter_sizes tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dims() == 5,\n        errors::InvalidArgument(\"out_backprop tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context,\n                   ConvBackpropComputeDimensions(\n                       \"Conv3DBackpropFilterOp\", /*num_spatial_dims=*/3,\n                       input_shape, filter_shape, out_backprop_shape, stride_,\n                       padding_, data_format_, &dims));\n\n    Tensor* filter_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, filter_shape, &filter_backprop));\n\n    if (input_shape.num_elements() == 0) {\n      filter_backprop->template flat<T>().setZero();\n      return;\n    }\n\n    functor::CuboidConvolutionBackwardFilter<Device, T>()(\n        context->eigen_device<Device>(),\n        filter_backprop->tensor<T, 5>(),                 // filter_backward\n        input.tensor<T, 5>(),                            // input\n        out_backprop.tensor<T, 5>(),                     // output_backward\n        static_cast<int>(dims.spatial_dims[0].stride),   // stride_planes\n        static_cast<int>(dims.spatial_dims[1].stride),   // stride_rows\n        static_cast<int>(dims.spatial_dims[2].stride));  // stride_cols\n  }\n\n private:\n  std::vector<int32> dilation_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool takes_shape_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(Conv3DBackpropFilterOp);\n};\n\n// Custom backprop for filter that explicitly does the work sharding and calls\n// Eigen only to multiply matrices.\ntemplate <typename Device, class T>\nclass Conv3DCustomBackpropFilterOp : public OpKernel {\n  // Limit the maximum size of allocated temporary buffer to\n  // kMaxTempAllocationOverhead times the size of the input tensors (input,\n  // filter, out_backprop). If the size of the temporary buffer exceeds this\n  // limit, fallback on Eigen implementation.\n  static constexpr int kMaxTempAllocationOverhead = 25;\n\n public:\n  explicit Conv3DCustomBackpropFilterOp(OpKernelConstruction* context)\n      : OpKernel(context),\n        data_format_(FORMAT_NHWC),\n        takes_shape_(type_string().find(\"V2\") != std::string::npos) {\n    // data_format is only available in V2.\n    if (takes_shape_) {\n      string data_format;\n      OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n      OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n      OP_REQUIRES(\n          context, data_format_ == FORMAT_NHWC,\n          errors::InvalidArgument(\n              \"Conv3DBackpropFilterOpV2 only supports NDHWC on the CPU.\"));\n    }\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"dilations\", &dilation_));\n    OP_REQUIRES(context, dilation_.size() == 5,\n                errors::InvalidArgument(\"Dilation rates field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, 'C') == 1 &&\n                 GetTensorDim(dilation_, data_format_, 'N') == 1),\n                errors::InvalidArgument(\n                    \"Current implementation does not yet support \"\n                    \"dilation rates in the batch and depth dimensions.\"));\n\n    // TODO(yangzihao): Add CPU version of dilated conv 3D.\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, '0') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '1') == 1 &&\n                 GetTensorDim(dilation_, data_format_, '2') == 1),\n                errors::InvalidArgument(\n                    \"Current CPU implementation does not yet support \"\n                    \"dilation rates larger than 1.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 5,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, 'C') == 1 &&\n         GetTensorDim(stride_, data_format_, 'N') == 1),\n        errors::InvalidArgument(\"Current implementation does not yet support \"\n                                \"strides in the batch and depth dimensions.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape filter_shape;\n    if (takes_shape_) {\n      const Tensor& filter_sizes = context->input(1);\n      OP_REQUIRES(context, TensorShapeUtils::IsVector(filter_sizes.shape()),\n                  errors::InvalidArgument(\n                      \"filter_sizes shape must be rank 1 but is rank \",\n                      filter_sizes.shape().dims()));\n      OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                  filter_sizes.vec<int32>(), &filter_shape));\n    } else {\n      filter_shape = context->input(1).shape();\n    }\n\n    OP_REQUIRES(context, input_shape.dims() == 5,\n                errors::InvalidArgument(\"input tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, filter_shape.dims() == 5,\n        errors::InvalidArgument(\"filter_sizes tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dims() == 5,\n        errors::InvalidArgument(\"out_backprop tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context,\n                   ConvBackpropComputeDimensions(\n                       \"Conv3DBackpropFilterOp\", /*num_spatial_dims=*/3,\n                       input_shape, filter_shape, out_backprop_shape, stride_,\n                       padding_, data_format_, &dims));\n\n    Tensor* filter_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, filter_shape, &filter_backprop));\n\n    if (input_shape.num_elements() == 0) {\n      filter_backprop->template flat<T>().setZero();\n      return;\n    }\n\n    int64_t top_pad_planes, bottom_pad_planes;\n    int64_t top_pad_rows, bottom_pad_rows;\n    int64_t left_pad_cols, right_pad_cols;\n\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[0].input_size,\n                                dims.spatial_dims[0].filter_size,\n                                dims.spatial_dims[0].stride, padding_,\n                                &dims.spatial_dims[0].output_size,\n                                &top_pad_planes, &bottom_pad_planes));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[1].input_size,\n                                dims.spatial_dims[1].filter_size,\n                                dims.spatial_dims[1].stride, padding_,\n                                &dims.spatial_dims[1].output_size,\n                                &top_pad_rows, &bottom_pad_rows));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                dims.spatial_dims[2].input_size,\n                                dims.spatial_dims[2].filter_size,\n                                dims.spatial_dims[2].stride, padding_,\n                                &dims.spatial_dims[2].output_size,\n                                &left_pad_cols, &right_pad_cols));\n\n    // TODO(ezhulenev): Extract work size and shard estimation to shared\n    // functions in conv_grad_ops, and update 2d convolution backprop.\n\n    // The total dimension size of each kernel.\n    const int64_t filter_total_size =\n        dims.spatial_dims[0].filter_size * dims.spatial_dims[1].filter_size *\n        dims.spatial_dims[2].filter_size * dims.in_depth;\n    // The output image size is the spatial size of the output.\n    const int64_t output_image_size = dims.spatial_dims[0].output_size *\n                                      dims.spatial_dims[1].output_size *\n                                      dims.spatial_dims[2].output_size;\n\n    // Shard 'batch' images (volumes) into 'shard_size' groups of images\n    // (volumes) to be fed into the parallel matmul. Calculate 'shard_size' by\n    // dividing the L3 cache size ('target_working_set_size') by the matmul size\n    // of an individual image ('work_unit_size').\n\n    const auto cache_sizes = Eigen::internal::CacheSizes();\n    const ptrdiff_t l3_cache_size = cache_sizes.m_l3;\n\n    // TODO(andydavis)\n    // *) Consider reducing 'target_working_set_size' if L3 is shared by\n    //    other concurrently running tensorflow ops.\n    const size_t target_working_set_size = l3_cache_size / sizeof(T);\n\n    const int64_t size_A = output_image_size * filter_total_size;\n\n    const int64_t size_B = output_image_size * dims.out_depth;\n\n    const int64_t size_C = filter_total_size * dims.out_depth;\n\n    const int64_t work_unit_size = size_A + size_B + size_C;\n\n    OP_REQUIRES(\n        context, work_unit_size > 0,\n        errors::InvalidArgument(\"input, filter_sizes and out_backprop tensors \"\n                                \"must all have at least 1 element\"));\n\n    const size_t shard_size =\n        (target_working_set_size + work_unit_size - 1) / work_unit_size;\n\n    // Total number of elements in all the tensors used by this kernel.\n    int64_t total_tensor_elements = input_shape.num_elements() +\n                                    filter_shape.num_elements() +\n                                    out_backprop_shape.num_elements();\n\n    // Shape of the temporary workspace buffer.\n    TensorShape col_buffer_shape = {static_cast<int64_t>(shard_size),\n                                    static_cast<int64_t>(output_image_size),\n                                    static_cast<int64_t>(filter_total_size)};\n    int64_t col_buffer_elements = col_buffer_shape.num_elements();\n\n    // If the temporary allocation overhead is too large, fallback on Eigen\n    // implementation which requires much less memory.\n    int64_t col_buffer_overhead = col_buffer_elements / total_tensor_elements;\n    if (col_buffer_overhead > kMaxTempAllocationOverhead) {\n      VLOG(2) << \"Fallback on Eigen implementation of Conv3DBackpropFilterOp: \"\n                 \"col_buffer_overhead=\"\n              << col_buffer_overhead;\n\n      functor::CuboidConvolutionBackwardFilter<Device, T>()(\n          context->eigen_device<Device>(),\n          filter_backprop->tensor<T, 5>(),                 // filter_backward\n          input.tensor<T, 5>(),                            // input\n          out_backprop.tensor<T, 5>(),                     // output_backward\n          static_cast<int>(dims.spatial_dims[0].stride),   // stride_planes\n          static_cast<int>(dims.spatial_dims[1].stride),   // stride_rows\n          static_cast<int>(dims.spatial_dims[2].stride));  // stride_cols\n\n      return;\n    }\n\n    Tensor col_buffer;\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value,\n                                          col_buffer_shape, &col_buffer));\n\n    // The input offset corresponding to a single input image.\n    const int64_t input_offset =\n        dims.spatial_dims[0].input_size * dims.spatial_dims[1].input_size *\n        dims.spatial_dims[2].input_size * dims.in_depth;\n    // The output offset corresponding to a single output image.\n    const int64_t output_offset =\n        dims.spatial_dims[0].output_size * dims.spatial_dims[1].output_size *\n        dims.spatial_dims[2].output_size * dims.out_depth;\n\n    const T* input_data = input.template flat<T>().data();\n    T* col_buffer_data = col_buffer.template flat<T>().data();\n    const T* out_backprop_data = out_backprop.template flat<T>().data();\n    T* filter_backprop_data = filter_backprop->template flat<T>().data();\n\n    typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,\n                             Eigen::Unaligned>\n        TensorMap;\n    typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,\n                             Eigen::Unaligned>\n        ConstTensorMap;\n\n    TensorMap C(filter_backprop_data, filter_total_size, dims.out_depth);\n    C.setZero();\n\n    // Initialize contraction dims (we need to transpose 'A' below).\n    Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> contract_dims;\n    contract_dims[0].first = 0;\n    contract_dims[0].second = 0;\n\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n\n    for (int image_id = 0; image_id < dims.batch_size; image_id += shard_size) {\n      const int shard_limit =\n          std::min(static_cast<int>(shard_size),\n                   static_cast<int>(dims.batch_size) - image_id);\n\n      auto shard = [&input_data, &col_buffer_data, &dims, &top_pad_planes,\n                    &top_pad_rows, &left_pad_cols, &bottom_pad_planes,\n                    &bottom_pad_rows, &right_pad_cols, &input_offset,\n                    &size_A](int64_t start, int64_t limit) {\n        for (int shard_id = start; shard_id < limit; ++shard_id) {\n          const T* input_data_shard = input_data + shard_id * input_offset;\n          T* col_data_shard = col_buffer_data + shard_id * size_A;\n\n          // When we compute the gradient with respect to the filters, we need\n          // to do im2col to allow gemm-type computation.\n          Im2col<T>(input_data_shard, dims.in_depth,\n                    // Input spatial dimensions.\n                    dims.spatial_dims[0].input_size,  // input planes\n                    dims.spatial_dims[1].input_size,  // input rows\n                    dims.spatial_dims[2].input_size,  // input cols\n                    // Filter spatial dimensions.\n                    dims.spatial_dims[0].filter_size,  // filter planes\n                    dims.spatial_dims[1].filter_size,  // filter rows\n                    dims.spatial_dims[2].filter_size,  // filter cols\n                    // Spatial padding.\n                    top_pad_planes, top_pad_rows, left_pad_cols,\n                    bottom_pad_planes, bottom_pad_rows, right_pad_cols,\n                    // Spatial striding.\n                    dims.spatial_dims[0].stride,  // stride planes\n                    dims.spatial_dims[1].stride,  // stride rows\n                    dims.spatial_dims[2].stride,  // stride cols\n                    col_data_shard);\n        }\n      };\n      Shard(worker_threads.num_threads, worker_threads.workers, shard_limit,\n            size_A, shard);\n\n      ConstTensorMap A(col_buffer_data, output_image_size * shard_limit,\n                       filter_total_size);\n      ConstTensorMap B(out_backprop_data, output_image_size * shard_limit,\n                       dims.out_depth);\n\n      // Gradient with respect to filter.\n      C.device(context->eigen_cpu_device()) += A.contract(B, contract_dims);\n\n      input_data += input_offset * shard_limit;\n      out_backprop_data += output_offset * shard_limit;\n    }\n  }\n\n private:\n  std::vector<int32> dilation_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool takes_shape_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(Conv3DCustomBackpropFilterOp);\n};\n\n// Custom backrop input kernel is 30% - 4x faster when compiled with AVX2 than\n// default Eigen implementation (at the cost of ~2x-8x peak memory usage).\n\n#define REGISTER_CPU_KERNEL(T)                                                \\\n  REGISTER_KERNEL_BUILDER(                                                    \\\n      Name(\"Conv3DBackpropFilter\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      Conv3DCustomBackpropFilterOp<CPUDevice, T>);                            \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilterV2\")                      \\\n                              .Device(DEVICE_CPU)                             \\\n                              .TypeConstraint<T>(\"T\"),                        \\\n                          Conv3DCustomBackpropFilterOp<CPUDevice, T>);        \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilter\")                        \\\n                              .Device(DEVICE_CPU)                             \\\n                              .Label(\"custom\")                                \\\n                              .TypeConstraint<T>(\"T\"),                        \\\n                          Conv3DCustomBackpropFilterOp<CPUDevice, T>);        \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilterV2\")                      \\\n                              .Device(DEVICE_CPU)                             \\\n                              .Label(\"custom\")                                \\\n                              .TypeConstraint<T>(\"T\"),                        \\\n                          Conv3DCustomBackpropFilterOp<CPUDevice, T>);        \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilter\")                        \\\n                              .Device(DEVICE_CPU)                             \\\n                              .Label(\"eigen_tensor\")                          \\\n                              .TypeConstraint<T>(\"T\"),                        \\\n                          Conv3DBackpropFilterOp<CPUDevice, T>);              \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilterV2\")                      \\\n                              .Device(DEVICE_CPU)                             \\\n                              .Label(\"eigen_tensor\")                          \\\n                              .TypeConstraint<T>(\"T\"),                        \\\n                          Conv3DBackpropFilterOp<CPUDevice, T>);\n\nTF_CALL_float(REGISTER_CPU_KERNEL);\nTF_CALL_double(REGISTER_CPU_KERNEL);\n#undef REGISTER_CPU_KERNEL\n\n// WARNING: Eigen::half is not trivially copyable and can't be used in\n// custom backprop filter kernel because of memcpy and memset in Im2col.\n#define REGISTER_CPU_KERNEL(T)                                                \\\n  REGISTER_KERNEL_BUILDER(                                                    \\\n      Name(\"Conv3DBackpropFilter\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      Conv3DBackpropFilterOp<CPUDevice, T>);                                  \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilterV2\")                      \\\n                              .Device(DEVICE_CPU)                             \\\n                              .TypeConstraint<T>(\"T\"),                        \\\n                          Conv3DBackpropFilterOp<CPUDevice, T>);\n\nTF_CALL_half(REGISTER_CPU_KERNEL);\n#undef REGISTER_CPU_KERNEL\n\n// GPU definitions of both ops.\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n// Forward declarations of the functor specializations for GPU.\n// This ensures that the custom implementation is used instead of the default\n// Eigen one (which is used for CPU).\nnamespace functor {\n#define DECLARE_GPU_SPEC(T)                                           \\\n  template <>                                                         \\\n  void TransformFilter<GPUDevice, T, int, 5>::operator()(             \\\n      const GPUDevice& d, FilterTensorFormat dst_filter_format,       \\\n      typename TTypes<T, 5, int>::ConstTensor in,                     \\\n      typename TTypes<T, 5, int>::Tensor out);                        \\\n  template <>                                                         \\\n  void ReverseTransformFilter<GPUDevice, T, 5>::operator()(           \\\n      const GPUDevice& d, FilterTensorFormat src_filter_format,       \\\n      typename TTypes<T, 5>::ConstTensor in,                          \\\n      typename TTypes<T, 5>::Tensor out);                             \\\n  template <>                                                         \\\n  void PadInput<GPUDevice, T, int, 5>::operator()(                    \\\n      const GPUDevice& d, typename TTypes<T, 5, int>::ConstTensor in, \\\n      const std::array<int, 3>& padding_left,                         \\\n      const std::array<int, 3>& padding_right,                        \\\n      typename TTypes<T, 5, int>::Tensor out, TensorFormat format,    \\\n      const T& padding_value);\n\nDECLARE_GPU_SPEC(Eigen::half);\nDECLARE_GPU_SPEC(float);\nDECLARE_GPU_SPEC(double);\n#undef DECLARE_GPU_SPEC\n}  // namespace functor\n\n// A dummy type to group backward data autotune results together.\nstruct Conv3dBackwardDataAutotuneGroup {\n  static string name() { return \"Conv3dBwdData\"; }\n};\n\ntypedef AutotuneSingleton<Conv3dBackwardDataAutotuneGroup, ConvParameters,\n                          AutotuneEntry<se::dnn::ConvOp>>\n\n    AutotuneConv3dBwdData;\n\ntemplate <typename T>\nclass Conv3DBackpropInputOp<GPUDevice, T> : public OpKernel {\n public:\n  explicit Conv3DBackpropInputOp(OpKernelConstruction* context)\n      : OpKernel(context),\n        data_format_(FORMAT_NHWC),\n        takes_shape_(type_string().find(\"V2\") != std::string::npos) {\n    // data_format is only available in V2.\n    if (takes_shape_) {\n      string data_format;\n      OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n      OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n    }\n    OP_REQUIRES_OK(context, context->GetAttr(\"dilations\", &dilation_));\n    OP_REQUIRES(context, dilation_.size() == 5,\n                errors::InvalidArgument(\"Dilation rates field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, 'C') == 1 &&\n                 GetTensorDim(dilation_, data_format_, 'N') == 1),\n                errors::InvalidArgument(\n                    \"Current implementation does not yet support \"\n                    \"dilation rates in the batch and depth dimensions.\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(dilation_, data_format_, '0') > 0 &&\n         GetTensorDim(dilation_, data_format_, '1') > 0 &&\n         GetTensorDim(dilation_, data_format_, '2') > 0),\n        errors::InvalidArgument(\"Dilated rates should be larger than 0.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 5,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, 'C') == 1 &&\n         GetTensorDim(stride_, data_format_, 'N') == 1),\n        errors::InvalidArgument(\"Current implementation does not yet support \"\n                                \"strides in the batch and depth dimensions.\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, '0') > 0 &&\n         GetTensorDim(stride_, data_format_, '1') > 0 &&\n         GetTensorDim(stride_, data_format_, '2') > 0),\n        errors::InvalidArgument(\"Spatial strides should be larger than 0.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    cudnn_use_autotune_ = CudnnUseAutotune();\n  }\n  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensionsV2(\n                                \"Conv3DBackpropInputOp\", /*num_spatial_dims=*/3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                dilation_, stride_, padding_,\n                                /*explicit_paddings=*/{}, data_format_, &dims));\n\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n\n    auto* stream = context->op_device_context()->stream();\n    OP_REQUIRES(context, stream, errors::Internal(\"No GPU stream available.\"));\n\n    bool is_grouped_convolution = filter_shape.dim_size(3) != dims.in_depth;\n    if (!is_grouped_convolution && dims.filter_size(0) == 1 &&\n        dims.filter_size(1) == 1 && dims.filter_size(2) == 1 &&\n        dims.dilation(0) == 1 && dims.dilation(1) == 1 &&\n        dims.dilation(2) == 1 && dims.stride(0) == 1 && dims.stride(1) == 1 &&\n        dims.stride(2) == 1 && data_format_ == FORMAT_NHWC) {\n      const uint64 m = dims.batch_size * dims.input_size(0) *\n                       dims.input_size(1) * dims.input_size(2);\n      const uint64 k = dims.out_depth;\n      const uint64 n = dims.in_depth;\n\n      auto a_ptr = AsDeviceMemory(out_backprop.template flat<T>().data(),\n                                  out_backprop.template flat<T>().size());\n      auto b_ptr = AsDeviceMemory(filter.template flat<T>().data(),\n                                  filter.template flat<T>().size());\n      auto c_ptr = AsDeviceMemory(in_backprop->template flat<T>().data(),\n                                  in_backprop->template flat<T>().size());\n\n      auto transpose = se::blas::Transpose::kTranspose;\n      auto no_transpose = se::blas::Transpose::kNoTranspose;\n\n      OP_REQUIRES_OK(\n          context, stream->ThenBlasGemm(transpose, no_transpose, n, m, k, b_ptr,\n                                        k, a_ptr, k, &c_ptr, n));\n      return;\n    } else if (!is_grouped_convolution &&\n               dims.filter_size(0) == dims.input_size(0) &&\n               dims.filter_size(1) == dims.input_size(1) &&\n               dims.filter_size(2) == dims.input_size(2) &&\n               padding_ == Padding::VALID && data_format_ == FORMAT_NHWC) {\n      const uint64 m = dims.batch_size;\n      const uint64 k = dims.out_depth;\n      const uint64 n = dims.input_size(0) * dims.input_size(1) *\n                       dims.input_size(2) * dims.in_depth;\n\n      auto a_ptr = AsDeviceMemory(out_backprop.template flat<T>().data(),\n                                  out_backprop.template flat<T>().size());\n      auto b_ptr = AsDeviceMemory(filter.template flat<T>().data(),\n                                  filter.template flat<T>().size());\n      auto c_ptr = AsDeviceMemory(in_backprop->template flat<T>().data(),\n                                  in_backprop->template flat<T>().size());\n\n      auto transpose = se::blas::Transpose::kTranspose;\n      auto no_transpose = se::blas::Transpose::kNoTranspose;\n\n      OP_REQUIRES_OK(\n          context, stream->ThenBlasGemm(transpose, no_transpose, n, m, k, b_ptr,\n                                        k, a_ptr, k, &c_ptr, n));\n      return;\n    }\n\n    int padding_planes = dims.SpatialPadding(padding_, 0);\n    int padding_rows = dims.SpatialPadding(padding_, 1);\n    int padding_cols = dims.SpatialPadding(padding_, 2);\n    const bool planes_odd = (padding_planes % 2 != 0);\n    const bool rows_odd = (padding_rows % 2 != 0);\n    const bool cols_odd = (padding_cols % 2 != 0);\n\n    TensorShape compatible_input_shape;\n    if (rows_odd || cols_odd || planes_odd) {\n      // cuDNN only supports the same amount of padding on both sides.\n      compatible_input_shape = {\n          dims.batch_size,\n          dims.in_depth,\n          dims.input_size(0) + planes_odd,\n          dims.input_size(1) + rows_odd,\n          dims.input_size(2) + cols_odd,\n      };\n    } else {\n      compatible_input_shape = {dims.batch_size, dims.in_depth,\n                                dims.input_size(0), dims.input_size(1),\n                                dims.input_size(2)};\n    }\n\n    CHECK(padding_rows >= 0 && padding_cols >= 0 && padding_planes >= 0)\n        << \"Negative paddings: (\" << padding_rows << \", \" << padding_cols\n        << \", \" << padding_planes << \")\";\n\n#if GOOGLE_CUDA\n    const bool compute_in_nhwc =\n        CUDNN_VERSION >= 8000 && DataTypeToEnum<T>::value == DT_HALF;\n#else\n    // fast NDHWC implementation is a CUDA only feature\n    const bool compute_in_nhwc = false;\n#endif\n    const TensorFormat compute_data_format =\n        (compute_in_nhwc && data_format_ == FORMAT_NHWC) ? FORMAT_NHWC\n                                                         : FORMAT_NCHW;\n\n    VLOG(3) << \"Compute Conv3DBackpropInput with cuDNN:\"\n            << \" data_format=\" << ToString(data_format_)\n            << \" compute_data_format=\" << ToString(compute_data_format);\n\n    constexpr auto kComputeInNHWC =\n        std::make_tuple(se::dnn::DataLayout::kBatchYXDepth,\n                        se::dnn::FilterLayout::kOutputYXInput);\n    constexpr auto kComputeInNCHW =\n        std::make_tuple(se::dnn::DataLayout::kBatchDepthYX,\n                        se::dnn::FilterLayout::kOutputInputYX);\n\n    se::dnn::DataLayout compute_data_layout;\n    se::dnn::FilterLayout filter_layout;\n\n    std::tie(compute_data_layout, filter_layout) =\n        compute_data_format == FORMAT_NHWC ? kComputeInNHWC : kComputeInNCHW;\n\n    se::dnn::BatchDescriptor input_desc(3);\n    input_desc.set_count(dims.batch_size)\n        .set_spatial_dim(DimIndex::X, compatible_input_shape.dim_size(4))\n        .set_spatial_dim(DimIndex::Y, compatible_input_shape.dim_size(3))\n        .set_spatial_dim(DimIndex::Z, compatible_input_shape.dim_size(2))\n        .set_feature_map_count(dims.in_depth)\n        .set_layout(compute_data_layout);\n    se::dnn::BatchDescriptor output_desc(3);\n    output_desc.set_count(dims.batch_size)\n        .set_spatial_dim(DimIndex::X, dims.output_size(2))\n        .set_spatial_dim(DimIndex::Y, dims.output_size(1))\n        .set_spatial_dim(DimIndex::Z, dims.output_size(0))\n        .set_feature_map_count(dims.out_depth)\n        .set_layout(compute_data_layout);\n    se::dnn::FilterDescriptor filter_desc(3);\n    filter_desc.set_spatial_dim(DimIndex::X, dims.filter_size(2))\n        .set_spatial_dim(DimIndex::Y, dims.filter_size(1))\n        .set_spatial_dim(DimIndex::Z, dims.filter_size(0))\n        .set_input_feature_map_count(filter_shape.dim_size(3))\n        .set_output_feature_map_count(filter_shape.dim_size(4))\n        .set_layout(filter_layout);\n    se::dnn::ConvolutionDescriptor conv_desc(3);\n    conv_desc.set_dilation_rate(DimIndex::X, dims.dilation(2))\n        .set_dilation_rate(DimIndex::Y, dims.dilation(1))\n        .set_dilation_rate(DimIndex::Z, dims.dilation(0))\n        .set_filter_stride(DimIndex::X, dims.stride(2))\n        .set_filter_stride(DimIndex::Y, dims.stride(1))\n        .set_filter_stride(DimIndex::Z, dims.stride(0))\n        .set_zero_padding(DimIndex::X, padding_cols / 2)\n        .set_zero_padding(DimIndex::Y, padding_rows / 2)\n        .set_zero_padding(DimIndex::Z, padding_planes / 2)\n        .set_group_count(dims.in_depth / filter_shape.dim_size(3));\n\n    // Shape: out, in, z, y, x.\n    Tensor transformed_filter;\n    auto dst_format =\n        compute_data_format == FORMAT_NCHW ? FORMAT_OIHW : FORMAT_OHWI;\n    TensorShape dst_shape =\n        dst_format == FORMAT_OIHW\n            ? TensorShape({filter_shape.dim_size(4), filter_shape.dim_size(3),\n                           dims.filter_size(0), dims.filter_size(1),\n                           dims.filter_size(2)})\n            : TensorShape({filter_shape.dim_size(4), dims.filter_size(0),\n                           dims.filter_size(1), dims.filter_size(2),\n                           filter_shape.dim_size(3)});\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value, dst_shape,\n                                          &transformed_filter));\n\n    functor::TransformFilter<GPUDevice, T, int, 5>()(\n        context->eigen_device<GPUDevice>(), dst_format,\n        To32Bit(filter.tensor<T, 5>()),\n        To32Bit(transformed_filter.tensor<T, 5>()));\n\n    // Shape: batch, filters, z, y, x.\n    Tensor transformed_out_backprop;\n    if (data_format_ == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {\n      TensorShape nchw_shape = {dims.batch_size, dims.out_depth,\n                                dims.output_size(0), dims.output_size(1),\n                                dims.output_size(2)};\n      if (dims.out_depth > 1) {\n        OP_REQUIRES_OK(context, context->allocate_temp(\n                                    DataTypeToEnum<T>::value, nchw_shape,\n                                    &transformed_out_backprop));\n        functor::NHWCToNCHW<GPUDevice, T, 5>()(\n            context->eigen_device<GPUDevice>(), out_backprop.tensor<T, 5>(),\n            transformed_out_backprop.tensor<T, 5>());\n      } else {\n        CHECK(transformed_out_backprop.CopyFrom(out_backprop, nchw_shape));\n      }\n    } else {\n      transformed_out_backprop = out_backprop;\n    }\n    // Shape: batch, filters, z, y, x.\n    Tensor pre_transformed_in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(\n                       DataTypeToEnum<T>::value,\n                       ShapeFromFormat(compute_data_format,\n                                       compatible_input_shape.dim_size(0),\n                                       {{compatible_input_shape.dim_size(2),\n                                         compatible_input_shape.dim_size(3),\n                                         compatible_input_shape.dim_size(4)}},\n                                       compatible_input_shape.dim_size(1)),\n                       &pre_transformed_in_backprop));\n\n    auto out_backprop_ptr =\n        AsDeviceMemory(transformed_out_backprop.template flat<T>().data(),\n                       transformed_out_backprop.template flat<T>().size());\n    auto filter_ptr =\n        AsDeviceMemory(transformed_filter.template flat<T>().data(),\n                       transformed_filter.template flat<T>().size());\n    auto in_backprop_ptr =\n        AsDeviceMemory(pre_transformed_in_backprop.template flat<T>().data(),\n                       pre_transformed_in_backprop.template flat<T>().size());\n\n    static int64_t ConvolveBackwardDataScratchSize = GetDnnWorkspaceLimit(\n        \"TF_CUDNN_WORKSPACE_LIMIT_IN_MB\", 1LL << 32);  // 4GB by default\n\n    const int device_id = stream->parent()->device_ordinal();\n    // To make sure the Conv3DBackpropInputV2 get the correct dtype, we infer\n    // the dtype from 2nd input, i.e., out_backprop.\n    DataType dtype = context->input(2).dtype();\n    const ConvParameters conv_parameters = {\n        dims.batch_size,\n        dims.in_depth,\n        {{dims.input_size(0), dims.input_size(1), dims.input_size(2)}},\n        compute_data_format,\n        dims.out_depth,\n        {{dims.filter_size(0), dims.filter_size(1), dims.filter_size(2)}},\n        {{dims.dilation(0), dims.dilation(1), dims.dilation(2)}},\n        {{dims.stride(0), dims.stride(1), dims.stride(2)}},\n        {{padding_planes, padding_rows, padding_cols}},\n        dtype,\n        device_id,\n        conv_desc.group_count()};\n\n    using se::dnn::AlgorithmConfig;\n    using se::dnn::AlgorithmDesc;\n    using se::dnn::ProfileResult;\n\n    auto entry_or = AutotuneUnfusedConv(\n        cudnn_use_autotune_, AutotuneConv3dBwdData::GetInstance(),\n        conv_parameters, context, se::dnn::ConvolutionKind::BACKWARD_DATA,\n        input_desc, in_backprop_ptr, filter_desc, filter_ptr, conv_desc,\n        output_desc, out_backprop_ptr, ConvolveBackwardDataScratchSize);\n    OP_REQUIRES_OK(context, entry_or.status());\n    auto autotune_entry = entry_or.ConsumeValueOrDie();\n\n    DnnScratchAllocator scratch_allocator(ConvolveBackwardDataScratchSize,\n                                          context);\n    Status cudnn_launch_status = LaunchAutotunedConv(\n        autotune_entry, &scratch_allocator,\n        se::dnn::ConvolutionKind::BACKWARD_DATA, stream, input_desc,\n        in_backprop_ptr, filter_desc, filter_ptr, conv_desc, output_desc,\n        out_backprop_ptr);\n    if (!cudnn_launch_status.ok()) {\n      context->SetStatus(cudnn_launch_status);\n      return;\n    }\n\n    if (rows_odd || cols_odd || planes_odd) {\n      Tensor in_backprop_remove_padding;\n      OP_REQUIRES_OK(\n          context, context->allocate_temp(\n                       DataTypeToEnum<T>::value,\n                       ShapeFromFormat(compute_data_format, dims.batch_size,\n                                       {{dims.input_size(0), dims.input_size(1),\n                                         dims.input_size(2)}},\n                                       dims.in_depth),\n                       &in_backprop_remove_padding));\n\n      // Remove the padding for odd spatial dimensions.\n      functor::PadInput<GPUDevice, T, int, 5>()(\n          context->eigen_device<GPUDevice>(),\n          To32Bit(const_cast<const Tensor&>(pre_transformed_in_backprop)\n                      .tensor<T, 5>()),\n          {{0, 0, 0}}, {{-planes_odd, -rows_odd, -cols_odd}},\n          To32Bit(in_backprop_remove_padding.tensor<T, 5>()),\n          compute_data_format, T{});\n\n      pre_transformed_in_backprop = in_backprop_remove_padding;\n    }\n\n    if (data_format_ == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {\n      auto toConstTensor = [](const Tensor& x) -> const Tensor { return x; };\n      functor::NCHWToNHWC<GPUDevice, T, 5>()(\n          context->eigen_device<GPUDevice>(),\n          toConstTensor(pre_transformed_in_backprop).template tensor<T, 5>(),\n          in_backprop->tensor<T, 5>());\n    } else {\n      *in_backprop = pre_transformed_in_backprop;\n    }\n  }\n\n private:\n  std::vector<int32> dilation_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool takes_shape_;\n  bool cudnn_use_autotune_;\n};\n\n// A dummy type to group backward filter autotune results together.\nstruct Conv3dBackwardFilterAutotuneGroup {\n  static string name() { return \"Conv3dBwdFilter\"; }\n};\n\ntypedef AutotuneSingleton<Conv3dBackwardFilterAutotuneGroup, ConvParameters,\n                          AutotuneEntry<se::dnn::ConvOp>>\n    AutotuneConv3dBwdFilter;\n\ntemplate <typename T>\nclass Conv3DBackpropFilterOp<GPUDevice, T> : public OpKernel {\n public:\n  explicit Conv3DBackpropFilterOp(OpKernelConstruction* context)\n      : OpKernel(context),\n        data_format_(FORMAT_NHWC),\n        takes_shape_(type_string().find(\"V2\") != std::string::npos) {\n    // data_format is only available in V2.\n    if (takes_shape_) {\n      string data_format;\n      OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n      OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n    }\n    OP_REQUIRES_OK(context, context->GetAttr(\"dilations\", &dilation_));\n    OP_REQUIRES(context, dilation_.size() == 5,\n                errors::InvalidArgument(\"Dilation rates field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(context,\n                (GetTensorDim(dilation_, data_format_, 'C') == 1 &&\n                 GetTensorDim(dilation_, data_format_, 'N') == 1),\n                errors::InvalidArgument(\n                    \"Current implementation does not yet support \"\n                    \"dilation rates in the batch and depth dimensions.\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(dilation_, data_format_, '0') > 0 &&\n         GetTensorDim(dilation_, data_format_, '1') > 0 &&\n         GetTensorDim(dilation_, data_format_, '2') > 0),\n        errors::InvalidArgument(\"Dilated rates should be larger than 0.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 5,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 5 dimensions\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, 'C') == 1 &&\n         GetTensorDim(stride_, data_format_, 'N') == 1),\n        errors::InvalidArgument(\"Current implementation does not yet support \"\n                                \"strides in the batch and depth dimensions.\"));\n    OP_REQUIRES(\n        context,\n        (GetTensorDim(stride_, data_format_, '0') > 0 &&\n         GetTensorDim(stride_, data_format_, '1') > 0 &&\n         GetTensorDim(stride_, data_format_, '2') > 0),\n        errors::InvalidArgument(\"Spatial strides should be larger than 0.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    cudnn_use_autotune_ = CudnnUseAutotune();\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape filter_shape;\n    if (takes_shape_) {\n      const Tensor& filter_sizes = context->input(1);\n      OP_REQUIRES(context, TensorShapeUtils::IsVector(filter_sizes.shape()),\n                  errors::InvalidArgument(\n                      \"filter_sizes shape must be rank 1 but is rank \",\n                      filter_sizes.shape().dims()));\n      OP_REQUIRES_OK(context, tensor::MakeShape(filter_sizes, &filter_shape));\n    } else {\n      filter_shape = context->input(1).shape();\n    }\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(\n        context,\n        ConvBackpropComputeDimensionsV2(\n            \"Conv3DBackpropFilterOp\", /*num_spatial_dims=*/3, input_shape,\n            filter_shape, out_backprop_shape, dilation_, stride_, padding_,\n            /*explicit_paddings=*/{}, data_format_, &dims));\n\n    Tensor* filter_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, filter_shape, &filter_backprop));\n\n    auto* stream = context->op_device_context()->stream();\n    OP_REQUIRES(context, stream, errors::Internal(\"No GPU stream available.\"));\n\n    bool is_grouped_convolution = filter_shape.dim_size(3) != dims.in_depth;\n    if (!is_grouped_convolution && dims.filter_size(1) == 1 &&\n        dims.filter_size(2) == 1 && dims.filter_size(0) == 1 &&\n        dims.dilation(2) == 1 && dims.dilation(1) == 1 &&\n        dims.dilation(0) == 1 && dims.stride(2) == 1 && dims.stride(1) == 1 &&\n        dims.stride(0) == 1 && data_format_ == FORMAT_NHWC) {\n      const uint64 m = dims.in_depth;\n      const uint64 k = dims.batch_size * dims.input_size(1) *\n                       dims.input_size(2) * dims.input_size(0);\n      const uint64 n = dims.out_depth;\n\n      // The shape of output backprop is\n      //   [batch, out_z, out_y, out_x, out_depth]\n      // From cublas's perspective, it is: n x k\n      auto a_ptr = AsDeviceMemory(out_backprop.template flat<T>().data(),\n                                  out_backprop.template flat<T>().size());\n\n      // The shape of input is:\n      //   [batch, in_z, in_y, in_x, in_depth],\n      // From cublas's perspective, it is: m x k\n      auto b_ptr = AsDeviceMemory(input.template flat<T>().data(),\n                                  input.template flat<T>().size());\n\n      // The shape of the filter backprop is:\n      //   [1, 1, 1, in_depth, out_depth]\n      // From cublas's perspective, it is: n x m\n      auto c_ptr = AsDeviceMemory(filter_backprop->template flat<T>().data(),\n                                  filter_backprop->template flat<T>().size());\n\n      OP_REQUIRES_OK(context,\n                     stream->ThenBlasGemm(se::blas::Transpose::kNoTranspose,\n                                          se::blas::Transpose::kTranspose, n, m,\n                                          k, a_ptr, n, b_ptr, m, &c_ptr, n));\n      return;\n    } else if (!is_grouped_convolution &&\n               dims.filter_size(0) == dims.input_size(0) &&\n               dims.filter_size(1) == dims.input_size(1) &&\n               dims.filter_size(2) == dims.input_size(2) &&\n               padding_ == Padding::VALID && data_format_ == FORMAT_NHWC) {\n      const uint64 m = dims.input_size(0) * dims.input_size(1) *\n                       dims.input_size(2) * dims.in_depth;\n      const uint64 k = dims.batch_size;\n      const uint64 n = dims.out_depth;\n\n      auto a_ptr = AsDeviceMemory(input.template flat<T>().data(),\n                                  input.template flat<T>().size());\n      auto b_ptr = AsDeviceMemory(out_backprop.template flat<T>().data(),\n                                  out_backprop.template flat<T>().size());\n      auto c_ptr = AsDeviceMemory(filter_backprop->template flat<T>().data(),\n                                  filter_backprop->template flat<T>().size());\n\n      OP_REQUIRES_OK(context,\n                     stream->ThenBlasGemm(se::blas::Transpose::kNoTranspose,\n                                          se::blas::Transpose::kTranspose, n, m,\n                                          k, b_ptr, n, a_ptr, m, &c_ptr, n));\n      return;\n    }\n\n    int padding_planes = dims.SpatialPadding(padding_, 0);\n    int padding_rows = dims.SpatialPadding(padding_, 1);\n    int padding_cols = dims.SpatialPadding(padding_, 2);\n    const bool planes_odd = (padding_planes % 2 != 0);\n    const bool rows_odd = (padding_rows % 2 != 0);\n    const bool cols_odd = (padding_cols % 2 != 0);\n\n    Tensor compatible_input;\n    if (rows_odd || cols_odd || planes_odd) {\n      OP_REQUIRES_OK(context,\n                     context->allocate_temp(\n                         DataTypeToEnum<T>::value,\n                         ShapeFromFormat(data_format_, dims.batch_size,\n                                         {{dims.input_size(0) + planes_odd,\n                                           dims.input_size(1) + rows_odd,\n                                           dims.input_size(2) + cols_odd}},\n                                         dims.in_depth),\n                         &compatible_input));\n      functor::PadInput<GPUDevice, T, int, 5>()(\n          context->template eigen_device<GPUDevice>(),\n          To32Bit(input.tensor<T, 5>()), {{0, 0, 0}},\n          {{planes_odd, rows_odd, cols_odd}},\n          To32Bit(compatible_input.tensor<T, 5>()), data_format_, T{});\n    } else {\n      compatible_input = input;\n    }\n\n    CHECK(padding_rows >= 0 && padding_cols >= 0 && padding_planes >= 0)\n        << \"Negative paddings: (\" << padding_rows << \", \" << padding_cols\n        << \", \" << padding_planes << \")\";\n\n#if GOOGLE_CUDA\n    const bool compute_in_nhwc =\n        CUDNN_VERSION >= 8000 && DataTypeToEnum<T>::value == DT_HALF;\n#else\n    // fast NDHWC implementation is a CUDA only feature\n    const bool compute_in_nhwc = false;\n#endif\n    const TensorFormat compute_data_format =\n        (compute_in_nhwc && data_format_ == FORMAT_NHWC) ? FORMAT_NHWC\n                                                         : FORMAT_NCHW;\n\n    VLOG(3) << \"Compute Conv3DBackpropFilter with cuDNN:\"\n            << \" data_format=\" << ToString(data_format_)\n            << \" compute_data_format=\" << ToString(compute_data_format);\n\n    constexpr auto kComputeInNHWC =\n        std::make_tuple(se::dnn::DataLayout::kBatchYXDepth,\n                        se::dnn::FilterLayout::kOutputYXInput);\n    constexpr auto kComputeInNCHW =\n        std::make_tuple(se::dnn::DataLayout::kBatchDepthYX,\n                        se::dnn::FilterLayout::kOutputInputYX);\n\n    se::dnn::DataLayout compute_data_layout;\n    se::dnn::FilterLayout filter_layout;\n\n    std::tie(compute_data_layout, filter_layout) =\n        compute_data_format == FORMAT_NHWC ? kComputeInNHWC : kComputeInNCHW;\n\n    se::dnn::BatchDescriptor input_desc(3);\n    input_desc.set_count(dims.batch_size)\n        .set_spatial_dim(DimIndex::X,\n                         GetTensorDim(compatible_input, data_format_, '2'))\n        .set_spatial_dim(DimIndex::Y,\n                         GetTensorDim(compatible_input, data_format_, '1'))\n        .set_spatial_dim(DimIndex::Z,\n                         GetTensorDim(compatible_input, data_format_, '0'))\n        .set_feature_map_count(dims.in_depth)\n        .set_layout(compute_data_layout);\n    se::dnn::BatchDescriptor output_desc(3);\n    output_desc.set_count(dims.batch_size)\n        .set_spatial_dim(DimIndex::X, dims.output_size(2))\n        .set_spatial_dim(DimIndex::Y, dims.output_size(1))\n        .set_spatial_dim(DimIndex::Z, dims.output_size(0))\n        .set_feature_map_count(dims.out_depth)\n        .set_layout(compute_data_layout);\n    se::dnn::FilterDescriptor filter_desc(3);\n    filter_desc.set_spatial_dim(DimIndex::X, dims.filter_size(2))\n        .set_spatial_dim(DimIndex::Y, dims.filter_size(1))\n        .set_spatial_dim(DimIndex::Z, dims.filter_size(0))\n        .set_input_feature_map_count(filter_shape.dim_size(3))\n        .set_output_feature_map_count(filter_shape.dim_size(4))\n        .set_layout(filter_layout);\n    se::dnn::ConvolutionDescriptor conv_desc(3);\n    conv_desc.set_dilation_rate(DimIndex::X, dims.dilation(2))\n        .set_dilation_rate(DimIndex::Y, dims.dilation(1))\n        .set_dilation_rate(DimIndex::Z, dims.dilation(0))\n        .set_filter_stride(DimIndex::X, dims.stride(2))\n        .set_filter_stride(DimIndex::Y, dims.stride(1))\n        .set_filter_stride(DimIndex::Z, dims.stride(0))\n        .set_zero_padding(DimIndex::X, padding_cols / 2)\n        .set_zero_padding(DimIndex::Y, padding_rows / 2)\n        .set_zero_padding(DimIndex::Z, padding_planes / 2)\n        .set_group_count(dims.in_depth / filter_shape.dim_size(3));\n\n    Tensor pre_transformed_filter_backprop;\n    auto dst_format =\n        compute_data_format == FORMAT_NCHW ? FORMAT_OIHW : FORMAT_OHWI;\n    TensorShape dst_shape =\n        dst_format == FORMAT_OIHW\n            ? TensorShape({filter_shape.dim_size(4), filter_shape.dim_size(3),\n                           dims.filter_size(0), dims.filter_size(1),\n                           dims.filter_size(2)})\n            : TensorShape({filter_shape.dim_size(4), dims.filter_size(0),\n                           dims.filter_size(1), dims.filter_size(2),\n                           filter_shape.dim_size(3)});\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value, dst_shape,\n                                          &pre_transformed_filter_backprop));\n\n    Tensor transformed_out_backprop;\n    if (data_format_ == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {\n      VLOG(4) << \"Convert the `out_backprop` tensor from NDHWC to NCDHW.\";\n      TensorShape nchw_shape = {dims.batch_size, dims.out_depth,\n                                dims.output_size(0), dims.output_size(1),\n                                dims.output_size(2)};\n      OP_REQUIRES_OK(\n          context, context->allocate_temp(DataTypeToEnum<T>::value, nchw_shape,\n                                          &transformed_out_backprop));\n      if (dims.out_depth > 1) {\n        functor::NHWCToNCHW<GPUDevice, T, 5>()(\n            context->eigen_device<GPUDevice>(), out_backprop.tensor<T, 5>(),\n            transformed_out_backprop.tensor<T, 5>());\n      } else {\n        CHECK(transformed_out_backprop.CopyFrom(out_backprop, nchw_shape));\n      }\n    } else {\n      transformed_out_backprop = out_backprop;\n    }\n    Tensor transformed_input;\n    if (data_format_ == FORMAT_NHWC && compute_data_format == FORMAT_NCHW) {\n      VLOG(4) << \"Convert the `input` tensor from NDHWC to NCDHW.\";\n      TensorShape nchw_shape = {\n          dims.batch_size, dims.in_depth, compatible_input.dim_size(1),\n          compatible_input.dim_size(2), compatible_input.dim_size(3)};\n      if (dims.in_depth > 1) {\n        OP_REQUIRES_OK(context,\n                       context->allocate_temp(DataTypeToEnum<T>::value,\n                                              nchw_shape, &transformed_input));\n        functor::NHWCToNCHW<GPUDevice, T, 5>()(\n            context->eigen_device<GPUDevice>(),\n            const_cast<const Tensor&>(compatible_input).tensor<T, 5>(),\n            transformed_input.tensor<T, 5>());\n      } else {\n        CHECK(transformed_input.CopyFrom(compatible_input, nchw_shape));\n      }\n    } else {\n      transformed_input = compatible_input;\n    }\n\n    auto out_backprop_ptr =\n        AsDeviceMemory(transformed_out_backprop.template flat<T>().data(),\n                       transformed_out_backprop.template flat<T>().size());\n    auto filter_backprop_ptr = AsDeviceMemory(\n        pre_transformed_filter_backprop.template flat<T>().data(),\n        pre_transformed_filter_backprop.template flat<T>().size());\n    auto input_ptr =\n        AsDeviceMemory(transformed_input.template flat<T>().data(),\n                       transformed_input.template flat<T>().size());\n\n    static int64_t ConvolveBackwardFilterScratchSize = GetDnnWorkspaceLimit(\n        \"TF_CUDNN_WORKSPACE_LIMIT_IN_MB\", 1LL << 32);  // 4GB by default\n\n    const int device_id = stream->parent()->device_ordinal();\n    DataType dtype = input.dtype();\n    const ConvParameters conv_parameters = {\n        dims.batch_size,\n        dims.in_depth,\n        {{dims.input_size(0), dims.input_size(1), dims.input_size(2)}},\n        compute_data_format,\n        dims.out_depth,\n        {{dims.filter_size(0), dims.filter_size(1), dims.filter_size(2)}},\n        {{dims.dilation(0), dims.dilation(1), dims.dilation(2)}},\n        {{dims.stride(0), dims.stride(1), dims.stride(2)}},\n        {{padding_planes, padding_rows, padding_cols}},\n        dtype,\n        device_id,\n        conv_desc.group_count()};\n\n    using se::dnn::AlgorithmConfig;\n    using se::dnn::AlgorithmDesc;\n    using se::dnn::ProfileResult;\n\n    auto entry_or = AutotuneUnfusedConv(\n        cudnn_use_autotune_, AutotuneConv3dBwdFilter::GetInstance(),\n        conv_parameters, context, se::dnn::ConvolutionKind::BACKWARD_FILTER,\n        input_desc, input_ptr, filter_desc, filter_backprop_ptr, conv_desc,\n        output_desc, out_backprop_ptr, ConvolveBackwardFilterScratchSize);\n    OP_REQUIRES_OK(context, entry_or.status());\n    auto autotune_entry = entry_or.ConsumeValueOrDie();\n\n    DnnScratchAllocator scratch_allocator(ConvolveBackwardFilterScratchSize,\n                                          context);\n    Status cudnn_launch_status = LaunchAutotunedConv(\n        autotune_entry, &scratch_allocator,\n        se::dnn::ConvolutionKind::BACKWARD_FILTER, stream, input_desc,\n        input_ptr, filter_desc, filter_backprop_ptr, conv_desc, output_desc,\n        out_backprop_ptr);\n    if (!cudnn_launch_status.ok()) {\n      context->SetStatus(cudnn_launch_status);\n      return;\n    }\n\n    auto toConstTensor = [](const Tensor& x) -> const Tensor { return x; };\n    functor::ReverseTransformFilter<GPUDevice, T, 5>()(\n        context->eigen_device<GPUDevice>(), /*src_filter_format=*/dst_format,\n        toConstTensor(pre_transformed_filter_backprop).template tensor<T, 5>(),\n        filter_backprop->tensor<T, 5>());\n  }\n\n private:\n  std::vector<int32> dilation_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool takes_shape_;\n  bool cudnn_use_autotune_;\n};\n\n#define REGISTER_GPU_KERNEL(T)                                                \\\n  REGISTER_KERNEL_BUILDER(                                                    \\\n      Name(\"Conv3DBackpropInput\").Device(DEVICE_GPU).TypeConstraint<T>(\"T\"),  \\\n      Conv3DBackpropInputOp<GPUDevice, T>);                                   \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropInputV2\")                       \\\n                              .Device(DEVICE_GPU)                             \\\n                              .TypeConstraint<T>(\"T\")                         \\\n                              .HostMemory(\"input_sizes\"),                     \\\n                          Conv3DBackpropInputOp<GPUDevice, T>);               \\\n  REGISTER_KERNEL_BUILDER(                                                    \\\n      Name(\"Conv3DBackpropFilter\").Device(DEVICE_GPU).TypeConstraint<T>(\"T\"), \\\n      Conv3DBackpropFilterOp<GPUDevice, T>);                                  \\\n  REGISTER_KERNEL_BUILDER(Name(\"Conv3DBackpropFilterV2\")                      \\\n                              .Device(DEVICE_GPU)                             \\\n                              .TypeConstraint<T>(\"T\")                         \\\n                              .HostMemory(\"filter_sizes\"),                    \\\n                          Conv3DBackpropFilterOp<GPUDevice, T>);\nTF_CALL_half(REGISTER_GPU_KERNEL);\nTF_CALL_float(REGISTER_GPU_KERNEL);\nTF_CALL_double(REGISTER_GPU_KERNEL);\n#undef REGISTER_GPU_KERNEL\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for convolution related functionality in tensorflow.ops.nn.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gradient_checker\nfrom tensorflow.python.ops import nn_ops\nimport tensorflow.python.ops.nn_grad  # pylint: disable=unused-import\nfrom tensorflow.python.platform import test\n\n\nclass Conv3DBackpropFilterV2GradTest(test.TestCase):\n\n  @test_util.run_deprecated_v1\n  def testGradient(self):\n    with self.cached_session():\n      for padding in [\"SAME\", \"VALID\"]:\n        for stride in [1, 2]:\n          np.random.seed(1)\n          in_shape = [2, 4, 3, 3, 2]\n          in_val = constant_op.constant(\n              2 * np.random.random_sample(in_shape) - 1, dtype=dtypes.float32)\n          filter_shape = [3, 3, 3, 2, 3]\n          strides = [1, stride, stride, stride, 1]\n          # Make a convolution op with the current settings, just to easily get\n          # the shape of the output.\n          conv_out = nn_ops.conv3d(in_val,\n                                   array_ops.zeros(filter_shape), strides,\n                                   padding)\n          out_backprop_shape = conv_out.get_shape().as_list()\n          out_backprop_val = constant_op.constant(\n              2 * np.random.random_sample(out_backprop_shape) - 1,\n              dtype=dtypes.float32)\n          output = nn_ops.conv3d_backprop_filter_v2(in_val, filter_shape,\n                                                    out_backprop_val, strides,\n                                                    padding)\n          err = gradient_checker.compute_gradient_error(\n              [in_val, out_backprop_val], [in_shape, out_backprop_shape],\n              output, filter_shape)\n          print(\"conv3d_backprop_filter gradient err = %g \" % err)\n          err_tolerance = 1e-3\n          self.assertLess(err, err_tolerance)\n\n  def testBadFilterShape(self):\n    strides = [1, 1, 1, 1, 1]\n    padding = \"VALID\"\n    tin = constant_op.constant(\n        .5053710941, shape=[2, 2, 2, 2, 1], dtype=dtypes.float32)\n    filter_sizes = constant_op.constant(0, shape=[], dtype=dtypes.int32)\n    out_backprop = constant_op.constant(\n        .5053710941, shape=[2, 2, 2, 2, 1], dtype=dtypes.float32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 1\"):\n      nn_ops.conv3d_backprop_filter_v2(\n          input=tin,\n          filter_sizes=filter_sizes,\n          out_backprop=out_backprop,\n          strides=strides,\n          padding=padding)\n\nif __name__ == \"__main__\":\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/conv_grad_ops_3d.cc", "tensorflow/python/kernel_tests/nn_ops/conv3d_backprop_filter_v2_grad_test.py"], "buggy_code_start_loc": [743, 20], "buggy_code_end_loc": [1640, 60], "fixing_code_start_loc": [744, 21], "fixing_code_end_loc": [1653, 79], "type": "CWE-20", "message": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.Conv3DBackpropFilterV2` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. The code does not validate that the `filter_sizes` argument is a vector. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "other": {"cve": {"id": "CVE-2022-29196", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-20T22:16:40.687", "lastModified": "2022-05-26T23:44:08.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.Conv3DBackpropFilterV2` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. The code does not validate that the `filter_sizes` argument is a vector. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. En versiones anteriores a 2.9.0, 2.8.1, 2.7.2 y 2.6.4, la implementaci\u00f3n de \"tf.raw_ops.Conv3DBackpropFilterV2\" no comprueba completamente los argumentos de entrada. Esto resulta en un fallo de \"CHECK\" que puede ser usado para desencadenar un ataque de denegaci\u00f3n de servicio. El c\u00f3digo no comprueba que el argumento \"filter_sizes\" sea un vector. Las versiones 2.9.0, 2.8.1, 2.7.2 y 2.6.4 contienen un parche para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.4", "matchCriteriaId": "D9359D32-D090-44CF-AC43-2046084A28BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C4DFBF2D-5283-42F6-8800-D653BFA5CE82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "A58EDA5C-66D6-46F1-962E-60AFB7C784A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "89522760-C2DF-400D-9624-626D8F160CBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.8.0:-:*:*:*:*:*:*", "matchCriteriaId": "E9EA1898-ACAA-4699-8BAE-54D62C1819FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.8.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "130DE3C9-6842-456F-A259-BF8FF8457217"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.8.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "BBF2FCEF-989C-409D-9F4C-81418C65B972"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.9.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "9CFB1CFC-579D-4647-A472-6DE8BE1951DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.9.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "F3F3F37E-D27F-4060-830C-0AFF16150777"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/blob/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow/core/kernels/conv_grad_ops_3d.cc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/174c5096f303d5be7ed2ca2662b08371bff4ab88", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.6.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.7.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.8.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.9.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-5v77-j66x-4c4g", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/174c5096f303d5be7ed2ca2662b08371bff4ab88"}}