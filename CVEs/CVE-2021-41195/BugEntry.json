{"buggy_code": ["/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/math_ops.cc.\n\n#ifndef TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_IMPL_H_\n#define TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_IMPL_H_\n\n#define EIGEN_USE_THREADS\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define EIGEN_USE_GPU\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#include <vector>\n\n#include \"third_party/eigen3/Eigen/Core\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/segment_reduction_ops.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/util/determinism.h\"\n#include \"tensorflow/core/util/util.h\"\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/common_runtime/gpu/gpu_event_mgr.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#if GOOGLE_CUDA\n#include \"tensorflow/core/util/gpu_solvers.h\"\n#include \"tensorflow/stream_executor/cuda/cuda_activation.h\"\n\nusing stream_executor::cuda::ScopedActivateExecutorContext;\n#elif TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/platform/rocm.h\"\n#include \"tensorflow/core/util/gpu_solvers.h\"\nusing stream_executor::rocm::ScopedActivateExecutorContext;\n#endif  // GOOGLE_CUDA\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\nnamespace internal {\nStatus ValidateSegmentReduction(OpKernelContext* c, const Tensor& input,\n                                const Tensor& segment_ids);\nStatus ValidateUnsortedSegmentReduction(OpKernel* op_kernel,\n                                        OpKernelContext* context,\n                                        const Tensor& data,\n                                        const Tensor& segment_ids,\n                                        const Tensor& num_segments);\nStatus ValidateSparseSegmentReduction(OpKernelContext* context,\n                                      const Tensor& input,\n                                      const Tensor& indices,\n                                      const Tensor& segment_ids,\n                                      bool has_num_segments);\n}  // namespace internal\n\n// This operator handles reducing segments along the first dimension.\n// See core/ops/math_ops.cc for more details.\ntemplate <typename Device, class T, class Index, typename Reducer,\n          int default_value>\nclass SegmentReductionOp : public OpKernel {\n public:\n  explicit SegmentReductionOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n\n    OP_REQUIRES_OK(context, internal::ValidateSegmentReduction(context, input,\n                                                               segment_ids));\n\n    const int64_t num_indices = segment_ids.NumElements();\n    auto input_flat = input.flat_outer_dims<T>();\n    const int64_t num_col = input_flat.dimension(1);\n\n    const auto segment_vec = segment_ids.vec<Index>();\n    // Note that the current implementation assumes that segment_vec values are\n    // sorted.\n    const Index output_rows =\n        num_indices > 0\n            ? internal::SubtleMustCopy(segment_vec(num_indices - 1)) + 1\n            : 0;\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n\n    OP_REQUIRES(context, input.dims() >= 1,\n                errors::InvalidArgument(\"Shape must be at least rank 1\"));\n\n    TensorShape output_shape = input.shape();\n    output_shape.set_dim(0, output_rows);\n\n    // Note that we do not initialize the output buffer with a default value, so\n    // we need to explicitly set missing indices to the default value.\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    if (num_indices == 0) return;\n    OP_REQUIRES(context, output_rows > 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n    auto output_flat = output->flat_outer_dims<T>();\n\n#if !defined(EIGEN_HAS_INDEX_LIST)\n    Eigen::DSizes<Eigen::DenseIndex, 1> dims_to_reduce;\n    dims_to_reduce[0] = 0;\n#else\n    Eigen::IndexList<Eigen::type2index<0> > dims_to_reduce;\n#endif\n    Index start = 0, end = 1;\n\n    Index uninitialized_index = 0;  // Index from which the output is not set.\n    Index out_index = internal::SubtleMustCopy(segment_vec(start));\n\n    // TODO(agarwal): if this loop becomes a bottleneck, consider sharding it\n    // across threads.\n    Eigen::DSizes<Eigen::DenseIndex, 1> out_slice_shape(num_col);\n    while (end <= num_indices) {\n      // We initialize next_index to 0 to avoid \"warning: 'next_index' may be\n      // used uninitialized in this function\" in the Mac build (since the\n      // compiler isn't smart enough to realize the code is safe).\n      Index next_index = 0;\n      if (end < num_indices) {\n        next_index = internal::SubtleMustCopy(segment_vec(end));\n        if (out_index == next_index) {\n          ++end;\n          continue;\n        }\n        // We have a new segment here.  Verify that the segment ids are growing.\n        OP_REQUIRES(context, out_index < next_index,\n                    errors::InvalidArgument(\"segment ids are not increasing\"));\n      }\n\n      // Process segment [start, end)\n      const T* in_slice_ptr = &input_flat(start, 0);\n      typedef Eigen::TensorMap<Eigen::Tensor<T, 1, Eigen::RowMajor>,\n                               Eigen::Unaligned>\n          OutT;\n\n      OP_REQUIRES(\n          context, FastBoundsCheck(out_index, output_rows),\n          errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\"));\n\n      // If there is a gap between two indices, we need to set that gap to the\n      // default value.\n      if (out_index > uninitialized_index) {\n        Eigen::DSizes<Eigen::DenseIndex, 2> gap_slice_shape(\n            out_index - uninitialized_index, num_col);\n        Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>\n            gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);\n        gap_slice.setConstant(T(default_value));\n      }\n\n      T* out_slice_ptr = &output_flat(out_index, 0);\n      OutT out_slice(out_slice_ptr, out_slice_shape);\n      // We don't use out_slice.device(context->eigen_device<Device>)\n      // because these pieces of work are likely to be very small and\n      // the context switching overhead dwarfs any benefit we get from\n      // using another thread to do this work.\n      if (start == end - 1) {\n        typedef Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,\n                                 Eigen::Unaligned>\n            InT;\n        InT in_slice(in_slice_ptr, out_slice_shape);\n        out_slice = in_slice;\n      } else {\n        Eigen::DSizes<Eigen::DenseIndex, 2> in_slice_shape(end - start,\n                                                           num_col);\n        typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,\n                                 Eigen::Unaligned>\n            InT;\n        InT in_slice(in_slice_ptr, in_slice_shape);\n\n        out_slice = in_slice.reduce(dims_to_reduce, Reducer());\n      }\n      if (end >= num_indices) break;\n      start = end;\n      ++end;\n      uninitialized_index = out_index + 1;\n      out_index = next_index;\n    }\n  }\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n//  SegmentReductionGPUOp is a segment reduction operator implemented for GPU\n//  only.\n//  TODO: This implementation of SegmentReductionGPUOp is sometimes slower than\n//  its unsorted counterpart (mostly when problem size is small).\n//  This is due to the following two main reasons and a cost-effective way\n//  to resolve these problems is desirable.\n//  1. Sorted segment reduction requires a memory transfer from device to host\n//     in order to know the size of the output dimension whereas unsorted\n//     segment reduction receives the size of the output dimension as an input\n//     parameter.\n//  2. Sorted segment reduction is essentially a tiled version of unsorted\n//     segment reduction and therefore such optimization comes at an inherent\n//     cost. However such cost may not be justified when the problem size is\n//     small. When to use the tiled version or the untiled version depends on\n//     many factors including data alignments, ratio of calculation to memory\n//     traffic and obviously, the problem sizes.\ntemplate <class T, class Index, class SegmentReductionFunctor, bool IsMean>\nclass SegmentReductionGPUOp : public AsyncOpKernel {\n public:\n  explicit SegmentReductionGPUOp(OpKernelConstruction* context)\n      : AsyncOpKernel(context) {}\n\n  void ComputeAsync(OpKernelContext* context, DoneCallback done) override {\n    const Tensor& input = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n\n    OP_REQUIRES_ASYNC(\n        context, TensorShapeUtils::IsVector(segment_ids.shape()),\n        errors::InvalidArgument(\"segment_ids should be a vector.\"), done);\n\n    OP_REQUIRES_ASYNC(context, input.dims() >= 1,\n                      errors::InvalidArgument(\"Shape must be at least rank 1\"),\n                      done);\n\n    const int64_t num_indices = segment_ids.NumElements();\n    OP_REQUIRES_ASYNC(\n        context, num_indices == input.dim_size(0),\n        errors::InvalidArgument(\n            \"segment_ids should be the same size as dimension 0 of\"\n            \" input.\"),\n        done);\n\n    if (num_indices == 0) {\n      TensorShape output_shape = input.shape();\n      output_shape.set_dim(0, 0);\n\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          context, context->allocate_output(0, output_shape, &output), done);\n      done();\n      return;\n    }\n\n    se::DeviceMemoryBase output_rows_device(\n        const_cast<Tensor&>(segment_ids).template flat<Index>().data() +\n        (num_indices - 1));\n    ScratchSpace<Index> output_rows_host(context, 1, /* on_host */ true);\n\n    auto stream = context->op_device_context()->stream();\n    OP_REQUIRES_ASYNC(\n        context,\n        stream\n            ->ThenMemcpy(output_rows_host.mutable_data(), output_rows_device,\n                         sizeof(Index))\n            .ok(),\n        errors::Internal(type_string() +\n                         \": failed to copy output_rows from device\"),\n        done);\n\n    SegmentReductionFunctor functor_;\n    auto create_and_check_output = [context, output_rows_host, &input,\n                                    &segment_ids, &functor_, done]() {\n      // Ensure that within the callback, the proper GPU settings are\n      // configured.\n      auto stream = context->op_device_context()->stream();\n      ScopedActivateExecutorContext scoped_activation{stream->parent()};\n\n      Index output_rows = *output_rows_host.data();\n      output_rows++;\n      OP_REQUIRES_ASYNC(context, output_rows > 0,\n                        errors::InvalidArgument(\"segment ids must be >= 0\"),\n                        done);\n\n      TensorShape output_shape = input.shape();\n      output_shape.set_dim(0, output_rows);\n\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          context, context->allocate_output(0, output_shape, &output), done);\n\n      bool use_deterministic_kernels =\n#if defined(PLATFORM_WINDOWS)\n          // See comment in segment_reduction_ops_gpu_0.cu.cc regarding Windows\n          // CI build error.\n          false;\n#else\n          UseDeterministicSegmentReductions() ||\n          (!SegmentReductionFunctor::atomic_reduction_is_associative &&\n           OpDeterminismRequired());\n#endif\n\n      // The determinism check is here, rather than inside the functor (as it is\n      // for the unsorted segment reduction ops) because the done callback\n      // (required for OP_REQUIRES_ASYNC) is not available inside the functor.\n      bool determinism_requirement_met =\n          use_deterministic_kernels ||\n          SegmentReductionFunctor::atomic_reduction_is_associative ||\n          !OpDeterminismRequired() ||\n          DisableSegmentReductionOpDeterminismExceptions();\n      OP_REQUIRES_ASYNC(\n          context, determinism_requirement_met,\n          errors::Unimplemented(\n              \"Deterministic GPU implementation of sorted segment reduction op\"\n              \" not available.\"),\n          done);\n\n      auto output_flat = output->flat_outer_dims<T>();\n      auto data_ptr = input.template flat<T>().data();\n      auto segment_flat = segment_ids.flat<Index>();\n      functor_(context, context->eigen_device<GPUDevice>(), output_rows,\n               segment_ids.shape(), IsMean, segment_flat, input.NumElements(),\n               data_ptr, output_flat);\n\n      done();\n    };\n\n    context->device()->tensorflow_gpu_device_info()->event_mgr->ThenExecute(\n        stream, create_and_check_output);\n  }\n};\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// ____________________________________________________________________________\n// Unsorted segment reduction ops.\n\nnamespace functor {\n\n// The ReductionFunctor implementation for CPU.\ntemplate <typename T, typename Index, typename InitialValueF,\n          typename ReductionF>\nstruct UnsortedSegmentFunctor<CPUDevice, T, Index, InitialValueF, ReductionF> {\n  void operator()(OpKernelContext* ctx, const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  typename TTypes<T, 2>::ConstTensor data,\n                  typename TTypes<T, 2>::Tensor output) {\n    output.setConstant(InitialValueF()());\n    if (data.size() == 0) {\n      return;\n    }\n    const int64_t N = segment_ids.dimension(0);\n    const int64_t num_segments = output.dimension(0);\n    ReductionF reduction;\n    for (int64_t i = 0; i < N; ++i) {\n      Index j = internal::SubtleMustCopy(segment_ids(i));\n      if (j < 0) {\n        continue;\n      }\n      OP_REQUIRES(ctx, FastBoundsCheck(j, num_segments),\n                  errors::InvalidArgument(\n                      \"segment_ids\", SliceDebugString(segment_ids_shape, i),\n                      \" = \", j, \" is out of range [0, \", num_segments, \")\"));\n      reduction(data.template chip<0>(i), output.template chip<0>(j));\n    }\n  }\n};\n\ntemplate <typename T>\nusing MatrixChip = Eigen::TensorChippingOp<0l, typename TTypes<T, 2>::Matrix>;\n\ntemplate <typename T>\nusing constMatrixChip =\n    Eigen::TensorChippingOp<0l, const typename TTypes<T, 2>::ConstMatrix>;\n\n// reduction functors\ntemplate <typename T>\nstruct SumOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output += data;\n  }\n};\n\ntemplate <typename T>\nstruct MaxOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output = data.cwiseMax(output);\n  }\n};\n\ntemplate <typename T>\nstruct MinOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output = data.cwiseMin(output);\n  }\n};\n\ntemplate <typename T>\nstruct ProdOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output *= data;\n  }\n};\n}  // namespace functor\n\n// The UnsortedSegmentReduction OpKernel. The DeviceReductionFunctor\n// is the device specific implementation of the reduction. These device\n// specific implementations are templated themselves with the corresponding\n// initial value functors and reduction functors.\ntemplate <typename T, typename Index, typename DeviceReductionFunctor>\nclass UnsortedSegmentReductionOp : public OpKernel {\n public:\n  explicit UnsortedSegmentReductionOp(OpKernelConstruction* context)\n      : OpKernel(context), reduction_functor_(DeviceReductionFunctor()) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n    const Tensor& num_segments = context->input(2);\n    OP_REQUIRES_OK(context,\n                   internal::ValidateUnsortedSegmentReduction(\n                       this, context, data, segment_ids, num_segments));\n    const auto segment_flat = segment_ids.flat<Index>();\n    const int64_t output_rows = internal::SubtleMustCopy(static_cast<int64_t>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64_t>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n    TensorShape output_shape;\n    output_shape.AddDim(output_rows);\n    for (int i = segment_ids.dims(); i < data.dims(); i++) {\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_flat = data.flat_inner_outer_dims<T, 2>(segment_ids.dims() - 1);\n    reduction_functor_(context, segment_ids.shape(), segment_flat, data_flat,\n                       output_flat);\n  }\n\n protected:\n  DeviceReductionFunctor reduction_functor_;\n};\n\n// ____________________________________________________________________________\n// Sparse segment reduction ops.\n\n// Same as SegmentReductionOp but takes as input a \"sparse\" tensor, represented\n// by two dense tensors, one containing the data, and the other containing\n// indices into the data.\n//\n// The template parameters are:\n// * Device: An Eigen device object, on which the kernel will execute.\n// * T: The value type.\n// * Index: The element type of the indices tensor (int32 or int64).\n// * SegmentId: The element type of the segment_ids tensor (int32 or int64).\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionOpBase : public OpKernel {\n public:\n  explicit SparseSegmentReductionOpBase(OpKernelConstruction* context,\n                                        bool is_mean, bool is_sqrtn,\n                                        bool has_num_segments, T default_value)\n      : OpKernel(context),\n        is_mean_(is_mean),\n        is_sqrtn_(is_sqrtn),\n        has_num_segments_(has_num_segments),\n        default_value_(default_value) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& indices = context->input(1);\n    const Tensor& segment_ids = context->input(2);\n\n    OP_REQUIRES_OK(\n        context, internal::ValidateSparseSegmentReduction(\n                     context, input, indices, segment_ids, has_num_segments_));\n\n    Index output_rows = -1;\n    if (has_num_segments_) {\n      const Tensor& num_segments = context->input(3);\n      // Note that there is a Tnumsegments parameter on the op, but it is not\n      // plumbed through to here and so always takes its default value of int32.\n      output_rows = internal::SubtleMustCopy(num_segments.scalar<int32>()());\n    }\n    const int64_t num_indices = indices.NumElements();\n\n    auto input_flat = input.flat_outer_dims<T>();\n    const int64_t num_col = input_flat.dimension(1);\n    const auto indices_vec = indices.vec<Index>();\n    const auto segment_vec = segment_ids.vec<SegmentId>();\n    // Note that the current implementation assumes that segment_vec values are\n    // sorted.\n    const SegmentId last_segment_id_plus_one =\n        num_indices > 0\n            ? internal::SubtleMustCopy(segment_vec(num_indices - 1)) + 1\n            : 0;\n    if (has_num_segments_) {\n      OP_REQUIRES(\n          context, output_rows >= last_segment_id_plus_one,\n          errors::InvalidArgument(\"segment ids must be < num_segments\"));\n    } else {\n      output_rows = last_segment_id_plus_one;\n    }\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n\n    TensorShape output_shape = input.shape();\n    output_shape.set_dim(0, output_rows);\n\n    // Note that we do not initialize the output buffer with a default value, so\n    // we need to explicitly set missing indices to the default value.\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    if (num_indices == 0) {\n      if (output_rows > 0) {\n        output->flat_outer_dims<T>().setConstant(default_value_);\n      }\n      return;\n    }\n    OP_REQUIRES(context, output_rows > 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n    auto output_flat = output->flat_outer_dims<T>();\n\n    Tensor temp;\n    if (input.dtype() == DT_BFLOAT16 || input.dtype() == DT_HALF) {\n      temp = tensorflow::Tensor(DT_FLOAT, output_shape);\n    }\n    auto temp_flat = temp.flat_outer_dims<float>();\n\n    int64_t start = 0, end = 1;\n    // Index from which the output is not initialized.\n    SegmentId uninitialized_index = 0;\n    SegmentId out_index = internal::SubtleMustCopy(segment_vec(start));\n\n    while (true) {\n      // We initialize next_index to 0 to avoid \"warning: 'next_index' may be\n      // used uninitialized in this function\" in the Mac build (since the\n      // compiler isn't smart enough to realize the code is safe).\n      SegmentId next_index = 0;\n      if (end < num_indices) {\n        next_index = internal::SubtleMustCopy(segment_vec(end));\n        if (out_index == next_index) {\n          ++end;\n          continue;\n        }\n        // We have a new segment here.  Verify that the segment ids are growing.\n        OP_REQUIRES(context, out_index < next_index,\n                    errors::InvalidArgument(\"segment ids are not increasing\"));\n      }\n\n      OP_REQUIRES(\n          context, FastBoundsCheck(out_index, output_rows),\n          errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\"));\n\n      // If there is a gap between two indices, we need to set that gap to the\n      // default value.\n      if (out_index > uninitialized_index) {\n        Eigen::DSizes<Eigen::DenseIndex, 2> gap_slice_shape(\n            out_index - uninitialized_index, num_col);\n        Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>\n            gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);\n        gap_slice.setConstant(default_value_);\n      }\n\n      auto out = output_flat.template chip<0>(out_index);\n      auto temp = temp_flat.template chip<0>(out_index);\n      const int bad_offset = Reduce<T, Index>(input_flat, indices_vec, start,\n                                              end - start, out, temp);\n      OP_REQUIRES(context, bad_offset < 0,\n                  errors::InvalidArgument(\n                      \"Bad: indices[\", start + bad_offset,\n                      \"] == \", indices_vec(start + bad_offset),\n                      \" out of range [0, \", input_flat.dimension(0), \")\"));\n\n      start = end;\n      ++end;\n      uninitialized_index = out_index + 1;\n      out_index = next_index;\n      if (end > num_indices) break;\n    }\n\n    // Fill the gap at the end with the default value.\n    if (uninitialized_index < output_rows) {\n      Eigen::DSizes<Eigen::DenseIndex, 2> gap_slice_shape(\n          output_rows - uninitialized_index, num_col);\n      Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>\n          gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);\n      gap_slice.setConstant(default_value_);\n    }\n  }\n\n private:\n  template <typename Tin>\n  using EnableIfBfloat16OrHalf =\n      typename std::enable_if<std::is_same<Tin, bfloat16>::value ||\n                                  std::is_same<Tin, Eigen::half>::value,\n                              int>::type;\n  template <typename Tin>\n  using EnableIfNotBfloat16OrHalf =\n      typename std::enable_if<!std::is_same<Tin, bfloat16>::value &&\n                                  !std::is_same<Tin, Eigen::half>::value,\n                              int>::type;\n\n  template <typename Tin, typename Tindex, EnableIfNotBfloat16OrHalf<Tin> = 0>\n  EIGEN_ALWAYS_INLINE auto fetch_val(\n      const typename TTypes<Tin>::ConstMatrix& input_flat, Tindex index) {\n    return input_flat.template chip<0>(index);\n  }\n\n  template <typename Tin, typename Tindex, EnableIfBfloat16OrHalf<Tin> = 0>\n  EIGEN_ALWAYS_INLINE auto fetch_val(\n      const typename TTypes<Tin>::ConstMatrix& input_flat, Tindex index) {\n    return input_flat.template chip<0>(index).template cast<float>();\n  }\n\n  template <typename Tout>\n  EIGEN_ALWAYS_INLINE Tout get_scaling_factor(int64_t num) {\n    Tout m(1);\n    if (is_mean_ && (num < 10)) {\n      m = Tout(num);\n    }\n    if (is_sqrtn_ && (num < 10)) {\n      m = Tout(sqrt(num));\n    }\n    return Tout(1) / m;\n  }\n\n  template <typename Tin, typename Tindex, EnableIfNotBfloat16OrHalf<Tin> = 0>\n  int64_t Reduce(\n      const typename TTypes<Tin>::ConstMatrix& input_flat,\n      const typename TTypes<Tindex>::ConstVec& indices_vec, int64_t start,\n      int64_t num, Eigen::TensorChippingOp<0, typename TTypes<Tin>::Matrix> out,\n      Eigen::TensorChippingOp<0, typename TTypes<float>::Matrix> temp) {\n    return ReduceImpl<Tin, Tindex, Tin>(input_flat, indices_vec, start, num,\n                                        out, get_scaling_factor<Tin>(num));\n  }\n\n  template <typename Tin, typename Tindex, EnableIfBfloat16OrHalf<Tin> = 0>\n  int64_t Reduce(\n      const typename TTypes<Tin>::ConstMatrix& input_flat,\n      const typename TTypes<Tindex>::ConstVec& indices_vec, int64_t start,\n      int64_t num, Eigen::TensorChippingOp<0, typename TTypes<Tin>::Matrix> out,\n      Eigen::TensorChippingOp<0, typename TTypes<float>::Matrix> temp) {\n    int64_t res =\n        ReduceImpl<Tin, Tindex, float>(input_flat, indices_vec, start, num,\n                                       temp, get_scaling_factor<float>(num));\n    out = temp.template cast<Tin>();\n    return res;\n  }\n\n  template <typename Tin, typename Tindex, typename Tout>\n  int64_t ReduceImpl(\n      const typename TTypes<Tin>::ConstMatrix& input_flat,\n      const typename TTypes<Tindex>::ConstVec& indices_vec, int64_t start,\n      int64_t num,\n      Eigen::TensorChippingOp<0, typename TTypes<Tout>::Matrix> out,\n      const Tout scaling_factor) {\n#define INDEX(n, i)                               \\\n  const auto index##n = indices_vec(start + (i)); \\\n  if (!FastBoundsCheck(index##n, input_flat.dimension(0))) return (i);\n\n#define L(n) fetch_val<Tin, Tindex>(input_flat, index##n)\n\n    if (num == 1) {\n      INDEX(0, 0);\n      out = L(0);\n    } else {\n      int64_t r = num & 7;\n      switch (r) {\n        case 2: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          out = (L(0) + L(1)) * scaling_factor;\n          break;\n        }\n        case 3: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          out = (L(0) + L(1) + L(2)) * scaling_factor;\n          break;\n        }\n        case 4: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          out = (L(0) + L(1) + L(2) + L(3)) * scaling_factor;\n          break;\n        }\n        case 5: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4)) * scaling_factor;\n          break;\n        }\n        case 6: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5)) * scaling_factor;\n          break;\n        }\n        case 7: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          INDEX(6, 6);\n          out =\n              (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6)) * scaling_factor;\n          break;\n        }\n        case 0: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          INDEX(6, 6);\n          INDEX(7, 7);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7)) *\n                scaling_factor;\n          r = 8;\n          break;\n        }\n        case 1: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          INDEX(6, 6);\n          INDEX(7, 7);\n          INDEX(8, 8);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7) + L(8)) *\n                scaling_factor;\n          r = 9;\n          break;\n        }\n      }\n      for (; r < num; r += 8) {\n        INDEX(0, r);\n        INDEX(1, r + 1);\n        INDEX(2, r + 2);\n        INDEX(3, r + 3);\n        INDEX(4, r + 4);\n        INDEX(5, r + 5);\n        INDEX(6, r + 6);\n        INDEX(7, r + 7);\n        out += L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7);\n      }\n      if (is_mean_ && num >= 10) {\n        out = out / static_cast<Tout>(num);\n      }\n      if (is_sqrtn_ && num >= 10) {\n        out = out / static_cast<Tout>(sqrt(num));\n      }\n    }\n\n    return -1;\n#undef L\n#undef INDEX\n  }\n\n  const bool is_mean_;\n  const bool is_sqrtn_;\n  const bool has_num_segments_;\n  const T default_value_;\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// Specialization for GPU. Must be Async because may need to wait for a host to\n// device memcpy before allocating output.\ntemplate <class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionOpBase<GPUDevice, T, Index, SegmentId>\n    : public AsyncOpKernel {\n public:\n  explicit SparseSegmentReductionOpBase(OpKernelConstruction* context,\n                                        bool is_mean, bool is_sqrtn,\n                                        bool has_num_segments, T default_value)\n      : AsyncOpKernel(context),\n        is_mean_(is_mean),\n        is_sqrtn_(is_sqrtn),\n        has_num_segments_(has_num_segments),\n        default_value_(default_value) {}\n\n  void ComputeAsync(OpKernelContext* context, DoneCallback done) override {\n    const Tensor& input = context->input(0);\n    const Tensor& indices = context->input(1);\n    const Tensor& segment_ids = context->input(2);\n\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        internal::ValidateSparseSegmentReduction(\n            context, input, indices, segment_ids, has_num_segments_),\n        done);\n\n    ScratchSpace<SegmentId> last_segment_id_host(context, 1, /*on_host=*/true);\n\n    auto create_and_check_output = [this, context, input, indices, segment_ids,\n                                    last_segment_id_host, done]() {\n      // Ensure that within the callback, the proper GPU settings are\n      // configured.\n      auto stream = context->op_device_context()->stream();\n      ScopedActivateExecutorContext scoped_activation{stream->parent()};\n\n      SegmentId last_segment_id = *last_segment_id_host.data();\n      SegmentId output_rows = last_segment_id + 1;\n      OP_REQUIRES_ASYNC(context, output_rows > 0,\n                        errors::InvalidArgument(\"segment ids must be >= 0\"),\n                        done);\n\n      TensorShape output_shape = input.shape();\n      output_shape.set_dim(0, output_rows);\n\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          context, context->allocate_output(0, output_shape, &output), done);\n\n      auto input_flat = input.flat_outer_dims<T>();\n      const auto indices_vec = indices.vec<Index>();\n      const auto segment_ids_vec = segment_ids.vec<SegmentId>();\n      auto output_flat = output->flat_outer_dims<T>();\n\n      functor::SparseSegmentReductionFunctor<T, Index, SegmentId> functor;\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          functor(context, is_mean_, is_sqrtn_, default_value_, input_flat,\n                  indices_vec, segment_ids_vec, output_flat),\n          done);\n      done();\n    };\n\n    if (has_num_segments_) {\n      // No need to do any device to host memcpy, just compute synchronously.\n      const Tensor& num_segments_t = context->input(3);\n      SegmentId num_segments =\n          internal::SubtleMustCopy(num_segments_t.dtype() == DT_INT32\n                                       ? num_segments_t.scalar<int32>()()\n                                       : num_segments_t.scalar<int64_t>()());\n      *last_segment_id_host.mutable_data() = num_segments - 1;\n      create_and_check_output();\n    } else {\n      const int64_t num_indices = indices.NumElements();\n      // Need to copy last element of segment_ids from device to host, and then\n      // asynchronously allocate the output and finish the computation.\n      se::DeviceMemoryBase last_segment_id_device(\n          const_cast<Tensor&>(segment_ids).template flat<SegmentId>().data() +\n          (num_indices - 1));\n      auto stream = context->op_device_context()->stream();\n      OP_REQUIRES_ASYNC(\n          context,\n          stream\n              ->ThenMemcpy(last_segment_id_host.mutable_data(),\n                           last_segment_id_device, sizeof(SegmentId))\n              .ok(),\n          errors::Internal(type_string() +\n                           \": failed to copy last_segment_id from device\"),\n          done);\n      context->device()->tensorflow_gpu_device_info()->event_mgr->ThenExecute(\n          stream, create_and_check_output);\n    }\n  }\n\n private:\n  const bool is_mean_;\n  const bool is_sqrtn_;\n  const bool has_num_segments_;\n  const T default_value_;\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionMeanOp\n    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentReductionMeanOp(OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(\n            context, true /*is_mean*/, false /*is_sqrtn*/,\n            false /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionMeanWithNumSegmentsOp\n    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentReductionMeanWithNumSegmentsOp(\n      OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(\n            context, true /*is_mean*/, false /*is_sqrtn*/,\n            true /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionSqrtNOp\n    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentReductionSqrtNOp(OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(\n            context, false /*is_mean*/, true /*is_sqrtn*/,\n            false /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionSqrtNWithNumSegmentsOp\n    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentReductionSqrtNWithNumSegmentsOp(\n      OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(\n            context, false /*is_mean*/, true /*is_sqrtn*/,\n            true /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionSumOp\n    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentReductionSumOp(OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(\n            context, false /*is_mean*/, false /*is_sqrtn*/,\n            false /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionSumWithNumSegmentsOp\n    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentReductionSumWithNumSegmentsOp(\n      OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(\n            context, false /*is_mean*/, false /*is_sqrtn*/,\n            true /* has_num_segments */, T(0) /* default_value */) {}\n};\n\nnamespace functor {\n\ntemplate <typename T, typename Index, typename SegmentId>\nstruct SparseSegmentGradFunctor<CPUDevice, T, Index, SegmentId> {\n  void operator()(OpKernelContext* context,\n                  SparseSegmentReductionOperation operation,\n                  typename TTypes<T>::ConstMatrix input_flat,\n                  typename TTypes<Index>::ConstVec indices_vec,\n                  typename TTypes<SegmentId>::ConstVec segment_vec,\n                  typename TTypes<T>::Matrix output_flat) {\n    const int64_t N = indices_vec.size();\n    const SegmentId M = output_flat.dimension(0);\n\n    // Note that similar to SparseSegmentMean, we assume that segment_vec is\n    // already sorted and has non-negative values.\n    const SegmentId num_segments = input_flat.dimension(0);\n    const SegmentId last_segment_id_plus_one =\n        internal::SubtleMustCopy(segment_vec(N - 1)) + 1;\n    OP_REQUIRES(context, last_segment_id_plus_one <= num_segments,\n                errors::InvalidArgument(\"Invalid number of segments\"));\n\n    // Compute scaling factors for input.\n    std::vector<double> scaling(\n        (operation == SparseSegmentReductionOperation::kSum ? 0 : num_segments),\n        0.0);\n    if (operation != SparseSegmentReductionOperation::kSum) {\n      for (int64_t i = 0; i < N; ++i) {\n        const SegmentId idx = internal::SubtleMustCopy(segment_vec(i));\n        OP_REQUIRES(\n            context, FastBoundsCheck(idx, num_segments),\n            errors::InvalidArgument(\"Segment id \", idx, \" out of range [0, \",\n                                    num_segments, \").\"));\n        scaling[idx] += 1;\n      }\n      for (size_t i = 0; i < scaling.size(); ++i) {\n        switch (operation) {\n          case SparseSegmentReductionOperation::kSum: {\n            OP_REQUIRES(\n                context, false,\n                errors::Internal(\n                    \"Should not happen: sum inside SparseSegmentReductionOp \"\n                    \"scaling generation.\"));\n          }\n          case SparseSegmentReductionOperation::kMean: {\n            scaling[i] = 1.0 / std::max(scaling[i], 1.0);\n            break;\n          }\n          case SparseSegmentReductionOperation::kSqrtN: {\n            scaling[i] = 1.0 / sqrt(std::max(scaling[i], 1.0));\n            break;\n          }\n            // No default to get compiler warnings for missing cases.\n        }\n      }\n    }\n\n    output_flat.setZero();\n    std::vector<bool> is_modified(M, false);\n\n    for (int64_t i = 0; i < N; ++i) {\n      const Index output_idx = internal::SubtleMustCopy(indices_vec(i));\n      OP_REQUIRES(context, FastBoundsCheck(output_idx, M),\n                  errors::InvalidArgument(\"Index \", output_idx,\n                                          \" out of range [0, \", M, \").\"));\n\n      const SegmentId idx = internal::SubtleMustCopy(segment_vec(i));\n      OP_REQUIRES(\n          context, FastBoundsCheck(idx, num_segments),\n          errors::InvalidArgument(\"Segment id \", idx, \" out of range [0, \",\n                                  num_segments, \").\"));\n\n      const T scale = (operation == SparseSegmentReductionOperation::kSum\n                           ? static_cast<T>(1)\n                           : static_cast<T>(scaling[idx]));\n      if (is_modified[output_idx]) {\n        if (scale == 1.0) {\n          output_flat.template chip<0>(output_idx) +=\n              input_flat.template chip<0>(idx);\n        } else {\n          output_flat.template chip<0>(output_idx) +=\n              input_flat.template chip<0>(idx) * scale;\n        }\n      } else {\n        if (scale == 1.0) {\n          output_flat.template chip<0>(output_idx) =\n              input_flat.template chip<0>(idx);\n        } else {\n          output_flat.template chip<0>(output_idx) =\n              input_flat.template chip<0>(idx) * scale;\n        }\n      }\n      is_modified[output_idx] = true;\n    }\n  }\n};\n\n}  // namespace functor\n\n// Implements the common logic for the gradients of SparseSegmentReduction\n// kernels.\n//\n// The template parameters are:\n// * Device: An Eigen device object, on which the kernel will execute.\n// * T: The value type.\n// * Index: The element type of the indices tensor (int32 or int64).\n// * SegmentId: The element type of the segment_ids tensor (int32 or int64).\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentGradOpBase : public OpKernel {\n public:\n  explicit SparseSegmentGradOpBase(OpKernelConstruction* context,\n                                   SparseSegmentReductionOperation operation)\n      : OpKernel(context), operation_(operation) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& indices = context->input(1);\n    const Tensor& segment_ids = context->input(2);\n    const Tensor& output_dim0 = context->input(3);\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(indices.shape()),\n                errors::InvalidArgument(\"indices should be a vector.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(segment_ids.shape()),\n                errors::InvalidArgument(\"segment_ids should be a vector.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(output_dim0.shape()),\n                errors::InvalidArgument(\"output_dim0 should be a scalar.\"));\n\n    const int64_t N = indices.NumElements();\n    OP_REQUIRES(context, N == segment_ids.NumElements(),\n                errors::InvalidArgument(\n                    \"segment_ids and indices should have same size.\"));\n    const SegmentId M = internal::SubtleMustCopy(output_dim0.scalar<int32>()());\n\n    auto input_flat = input.flat_outer_dims<T>();\n    const auto indices_vec = indices.vec<Index>();\n    const auto segment_vec = segment_ids.vec<SegmentId>();\n\n    TensorShape output_shape = input.shape();\n    output_shape.set_dim(0, M);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    if (M == 0 || N == 0) return;\n\n    auto output_flat = output->flat_outer_dims<T>();\n    functor::SparseSegmentGradFunctor<Device, T, Index, SegmentId>()(\n        context, operation_, input_flat, indices_vec, segment_vec, output_flat);\n  }\n\n private:\n  const SparseSegmentReductionOperation operation_;\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentSumGradOp\n    : public SparseSegmentGradOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentSumGradOp(OpKernelConstruction* context)\n      : SparseSegmentGradOpBase<Device, T, Index, SegmentId>(\n            context, SparseSegmentReductionOperation::kSum) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentMeanGradOp\n    : public SparseSegmentGradOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentMeanGradOp(OpKernelConstruction* context)\n      : SparseSegmentGradOpBase<Device, T, Index, SegmentId>(\n            context, SparseSegmentReductionOperation::kMean) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentSqrtNGradOp\n    : public SparseSegmentGradOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentSqrtNGradOp(OpKernelConstruction* context)\n      : SparseSegmentGradOpBase<Device, T, Index, SegmentId>(\n            context, SparseSegmentReductionOperation::kSqrtN) {}\n};\n\n}  // namespace tensorflow\n\n#endif  // TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_IMPL_H_\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functional tests for segment reduction ops.\"\"\"\n\nimport itertools\n\nimport numpy as np\n\nfrom tensorflow.python.client import session\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes as dtypes_lib\nfrom tensorflow.python.framework import errors_impl\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import gradient_checker\nfrom tensorflow.python.ops import gradient_checker_v2\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\n\n\nclass SegmentReductionHelper(test.TestCase):\n\n  def _input(self, input_shape, dtype=dtypes_lib.int32):\n    num_elem = 1\n    for x in input_shape:\n      num_elem *= x\n    values = np.arange(1, num_elem + 1)\n    np_values = values.reshape(input_shape).astype(dtype.as_numpy_dtype)\n    # Add a non-zero imaginary component to complex types.\n    if dtype.is_complex:\n      np_values -= 1j * np_values\n    return constant_op.constant(\n        np_values, shape=input_shape, dtype=dtype), np_values\n\n  def _segmentReduce(self, indices, x, op1, op2=None, num_segments=None,\n                     initial_value=0):\n    if not x.size:\n      return np.array([])\n    indices = np.asarray(indices)\n    if num_segments is None:\n      num_segments = indices[-1] + 1\n    output = [None] * num_segments\n    slice_shape = x.shape[indices.ndim:]\n    x_flat = x.reshape((indices.size,) + slice_shape)\n    for i, index in enumerate(indices.ravel()):\n      if (output[index] is not None) and op1 == np.max:\n        for j in range(0, output[index].shape[0]):\n          output[index][j] = op1([output[index][j], x_flat[i][j]])\n      elif output[index] is not None:\n        output[index] = op1(output[index], x_flat[i])\n      else:\n        output[index] = x_flat[i]\n    # zero initialize values that are still uncalculated.\n    initial_value_slice = np.ones(slice_shape) * initial_value\n    output = [o if o is not None else initial_value_slice for o in output]\n    if op2 is not None:\n      output = [op2(o) for o in output]\n    output = [o.reshape(slice_shape) for o in output]\n    return np.array(output)\n\n  def _mean_cum_op(self, x, y):\n    return (x[0] + y, x[1] + 1) if isinstance(x, tuple) else (x + y, 2)\n\n  def _mean_reduce_op(self, x):\n    return x[0] / x[1] if isinstance(x, tuple) else x\n\n  def _sqrt_n_reduce_op(self, x):\n    return x[0] / np.sqrt(x[1]) if isinstance(x, tuple) else x\n\n\nclass SegmentReductionOpTest(SegmentReductionHelper):\n\n  def testValues(self):\n    dtypes = [\n        dtypes_lib.float32, dtypes_lib.float64, dtypes_lib.int64,\n        dtypes_lib.int32, dtypes_lib.complex64, dtypes_lib.complex128\n    ]\n\n    # Each item is np_op1, np_op2, tf_op\n    ops_list = [(np.add, None, math_ops.segment_sum),\n                (self._mean_cum_op, self._mean_reduce_op,\n                 math_ops.segment_mean),\n                (np.ndarray.__mul__, None, math_ops.segment_prod),\n                (np.minimum, None, math_ops.segment_min),\n                (np.maximum, None, math_ops.segment_max)]\n\n    # A subset of ops has been enabled for complex numbers\n    complex_ops_list = [(np.add, None, math_ops.segment_sum),\n                        (np.ndarray.__mul__, None, math_ops.segment_prod),\n                        (self._mean_cum_op, self._mean_reduce_op,\n                         math_ops.segment_mean)]\n\n    n = 10\n    # Note that the GPU implem has different paths for different inner sizes.\n    for shape in [[n, 1], [n, 2], [n, 3], [n, 32]]:\n      indices = [i // 3 for i in range(n)]\n      for dtype in dtypes:\n        if dtype in (dtypes_lib.complex64, dtypes_lib.complex128):\n          curr_ops_list = complex_ops_list\n        else:\n          curr_ops_list = ops_list\n        for use_gpu in [True, False]:\n          with self.cached_session(use_gpu=use_gpu):\n            tf_x, np_x = self._input(shape, dtype=dtype)\n            for np_op1, np_op2, tf_op in curr_ops_list:\n              initial_value = 1 if tf_op is math_ops.segment_prod else 0\n              np_ans = self._segmentReduce(\n                  indices, np_x, np_op1, np_op2, initial_value=initial_value)\n              s = tf_op(data=tf_x, segment_ids=indices)\n              tf_ans = self.evaluate(s)\n              self.assertAllClose(np_ans, tf_ans)\n              # NOTE(mrry): The static shape inference that computes\n              # `tf_ans.shape` can only infer that sizes from dimension 1\n              # onwards, because the size of dimension 0 is data-dependent\n              # and may therefore vary dynamically.\n              self.assertAllEqual(np_ans.shape[1:], tf_ans.shape[1:])\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsShape(self):\n    shape = [4, 4]\n    tf_x, _ = self._input(shape)\n    indices = constant_op.constant([0, 1, 2, 2], shape=[2, 2])\n    with self.assertRaises(ValueError):\n      math_ops.segment_sum(data=tf_x, segment_ids=indices)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsSize(self):\n    shape = [4, 4]\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        tf_x, _ = self._input(shape)\n        indices = [0, 1]\n        s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n        with self.assertRaisesOpError(\"segment_ids should be the same size\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsValid(self):\n    # This is a baseline for the following SegmentIdsInvalid* tests.\n    shape = [4, 4]\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        tf_x, _ = self._input(shape, dtype=dtypes_lib.float32)\n        indices = [0, 0, 0, 1]\n        result = math_ops.segment_sum(data=tf_x, segment_ids=indices).eval()\n        self.assertAllEqual([[15, 18, 21, 24], [13, 14, 15, 16]], result)\n\n  def testSegmentIdsGreaterThanZero(self):\n    shape = [4, 4]\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        tf_x, np_x = self._input(shape, dtype=dtypes_lib.float32)\n        indices = [1, 1, 2, 2]\n        np_ans = self._segmentReduce(indices, np_x, np.add)\n        s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n        tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n\n  def testSegmentIdsHole(self):\n    shape = [4, 4]\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        tf_x, np_x = self._input(shape, dtype=dtypes_lib.float32)\n        indices = [0, 0, 3, 3]\n        np_ans = self._segmentReduce(indices, np_x, np.add)\n        s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n        tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsInvalid1(self):\n    shape = [4, 4]\n    with self.cached_session():\n      tf_x, _ = self._input(shape)\n      indices = [-1, -1, 0, 0]\n      s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n      with self.assertRaisesOpError(\n          r\"Segment id -1 out of range \\[0, 1\\), possibly because \"\n          \"'segment_ids' input is not sorted.\"):\n        self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsInvalid2(self):\n    shape = [4, 4]\n    with self.cached_session():\n      tf_x, _ = self._input(shape)\n      indices = [0, 1, 0, 1]\n      s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n      with self.assertRaisesOpError(\"segment ids are not increasing\"):\n        self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsInvalid3(self):\n    shape = [4, 4]\n    with self.cached_session():\n      tf_x, _ = self._input(shape)\n      indices = [0, 1, 2, 0]\n      s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n      with self.assertRaisesOpError(\n          r\"Segment id 1 out of range \\[0, 1\\), possibly \"\n          \"because 'segment_ids' input is not sorted.\"):\n        self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsInvalid4(self):\n    shape = [4, 4]\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        tf_x, _ = self._input(shape, dtype=dtypes_lib.float32)\n        indices = [0, 0, 0, -1]\n        s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n        with self.assertRaisesOpError(\"segment ids must be >= 0\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsInvalid5(self):\n    shape = [4, 4]\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        tf_x, _ = self._input(shape, dtype=dtypes_lib.float32)\n        indices = [0, 0, 0, -2]\n        s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n        with self.assertRaisesOpError(\"segment ids must be >= 0\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradient(self):\n    shape = [4, 4]\n    indices = [0, 1, 2, 2]\n    for tf_op in [\n        math_ops.segment_sum, math_ops.segment_mean, math_ops.segment_min,\n        math_ops.segment_max\n    ]:\n      with self.cached_session():\n        tf_x, np_x = self._input(shape, dtype=dtypes_lib.float64)\n        s = tf_op(data=tf_x, segment_ids=indices)\n        jacob_t, jacob_n = gradient_checker.compute_gradient(\n            tf_x,\n            shape,\n            s, [3, 4],\n            x_init_value=np_x.astype(np.double),\n            delta=1)\n      self.assertAllClose(jacob_t, jacob_n)\n\n  def testDataInvalid(self):\n    # Test case for GitHub issue 40653.\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        with self.assertRaisesRegex(\n            (ValueError, errors_impl.InvalidArgumentError),\n            \"must be at least rank 1\"):\n          s = math_ops.segment_mean(\n              data=np.uint16(10), segment_ids=np.array([]).astype(\"int64\"))\n          self.evaluate(s)\n\n\nclass UnsortedSegmentTest(SegmentReductionHelper):\n\n  def __init__(self, methodName='runTest'):\n    # Each item is np_op1, np_op2, tf_op, initial_value functor\n    self.ops_list = [(np.add, None,\n                      math_ops.unsorted_segment_sum, lambda t: 0),\n                     (self._mean_cum_op, self._mean_reduce_op,\n                      math_ops.unsorted_segment_mean, lambda t: 0),\n                     (self._mean_cum_op, self._sqrt_n_reduce_op,\n                      math_ops.unsorted_segment_sqrt_n, lambda t: 0),\n                     (np.ndarray.__mul__, None,\n                      math_ops.unsorted_segment_prod, lambda t: 1),\n                     (np.minimum, None,\n                      math_ops.unsorted_segment_min, lambda t: t.max),\n                     (np.maximum, None,\n                      math_ops.unsorted_segment_max, lambda t: t.min)]\n\n    # A subset of ops has been enabled for complex numbers\n    self.complex_ops_list = [(np.add, None,\n                              math_ops.unsorted_segment_sum, lambda t: 0),\n                             (np.ndarray.__mul__, None,\n                              math_ops.unsorted_segment_prod, lambda t: 1)]\n    self.differentiable_dtypes = [dtypes_lib.float16, dtypes_lib.float32,\n                                  dtypes_lib.float64]\n    self.all_dtypes = (self.differentiable_dtypes +\n                       [dtypes_lib.bfloat16,\n                        dtypes_lib.int64, dtypes_lib.int32,\n                        dtypes_lib.complex64, dtypes_lib.complex128])\n    super(UnsortedSegmentTest, self).__init__(methodName=methodName)\n\n  def testValues(self):\n    indices_flat = np.array([0, 4, 0, 8, 3, 8, 4, 7, 7, 3])\n    num_segments = 12\n    for indices in indices_flat, indices_flat.reshape(5, 2):\n      # Note that the GPU implem has different paths for different inner sizes.\n      for inner_size in [1, 2, 3, 32]:\n        shape = indices.shape + (inner_size,)\n        for dtype in self.all_dtypes:\n          ops_list = (\n              self.complex_ops_list if dtype.is_complex else self.ops_list)\n          tf_x, np_x = self._input(shape, dtype=dtype)\n          for use_gpu in [True, False]:\n            with self.cached_session():\n              for np_op1, np_op2, tf_op, init_op in ops_list:\n                # sqrt_n doesn't support integers\n                if (np_op2 == self._sqrt_n_reduce_op and dtype.is_integer):\n                  continue\n                # todo(philjd): enable this test once real_div supports bfloat16\n                if (np_op2 in [self._sqrt_n_reduce_op, self._mean_reduce_op] and\n                    dtype == dtypes_lib.bfloat16):\n                  continue\n                np_ans = self._segmentReduce(\n                    indices,\n                    np_x,\n                    np_op1,\n                    np_op2,\n                    num_segments=num_segments,\n                    initial_value=init_op(dtype))\n                s = tf_op(tf_x, segment_ids=indices, num_segments=num_segments)\n                tf_ans = self.evaluate(s)\n                if dtype is dtypes_lib.bfloat16:\n                  tf_ans = tf_ans.astype(np.float32)\n                self.assertAllCloseAccordingToType(np_ans, tf_ans)\n                self.assertShapeEqual(np_ans, s)\n\n  def testNumSegmentsTypes(self):\n    dtypes = [dtypes_lib.int32, dtypes_lib.int64]\n    indices_flat = np.array([0, 4, 0, 8, 3, 8, 4, 7, 7, 3])\n    num_segments = 12\n    for indices in indices_flat, indices_flat.reshape(5, 2):\n      shape = indices.shape + (2,)\n      for dtype in dtypes:\n        with self.cached_session():\n          tf_x, np_x = self._input(shape)\n          num_segments_constant = constant_op.constant(\n              num_segments, dtype=dtype)\n          np_ans = self._segmentReduce(\n              indices, np_x, np.add, op2=None, num_segments=num_segments)\n          s = math_ops.unsorted_segment_sum(\n              data=tf_x,\n              segment_ids=indices,\n              num_segments=num_segments_constant)\n          tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n        self.assertShapeEqual(np_ans, s)\n\n  @test_util.run_deprecated_v1\n  def testGradientsTFGradients(self):\n    num_cols = 2\n    indices_flat = np.array([0, 4, 0, -1, 3, -1, 4, 7, 7, 3])\n    num_segments = max(indices_flat) + 3\n    for dtype in self.differentiable_dtypes:\n      ops_list = self.complex_ops_list if dtype.is_complex else self.ops_list\n      for indices in indices_flat, indices_flat.reshape(5, 2):\n        shape = indices.shape + (num_cols,)\n        # test CPU and GPU as tf.gather behaves differently on each device\n        for use_gpu in [False, True]:\n          with self.cached_session(use_gpu=use_gpu):\n            for _, _, tf_op, _ in ops_list:\n              tf_x, np_x = self._input(shape, dtype=dtype)\n              s = tf_op(tf_x, indices, num_segments)\n              jacob_t, jacob_n = gradient_checker.compute_gradient(\n                  tf_x,\n                  shape,\n                  s, [num_segments, num_cols],\n                  x_init_value=np_x,\n                  delta=1.)\n              self.assertAllCloseAccordingToType(jacob_t, jacob_n,\n                                                 half_atol=1e-2)\n\n  @test_util.run_in_graph_and_eager_modes\n  def testGradientsGradientTape(self):\n    num_cols = 2\n    indices_flat = np.array([0, 4, 0, -1, 3, -1, 4, 7, 7, 3])\n    num_segments = max(indices_flat) + 3\n    for dtype in self.differentiable_dtypes:\n      ops_list = self.complex_ops_list if dtype.is_complex else self.ops_list\n      for indices in indices_flat, indices_flat.reshape(5, 2):\n        shape = indices.shape + (num_cols,)\n        # test CPU and GPU as tf.gather behaves differently on each device\n        for use_gpu in [test_util.use_gpu, test_util.force_cpu]:\n          with use_gpu():\n            for _, _, tf_op, _ in ops_list:\n              _, np_x = self._input(shape, dtype=dtype)\n              # pylint: disable=cell-var-from-loop\n              def f(x):\n                return tf_op(x, indices, num_segments)\n              gradient_tape_jacob_t, jacob_n = (\n                  gradient_checker_v2.compute_gradient(\n                      f, [np_x], delta=1.))\n              # pylint: enable=cell-var-from-loop\n              self.assertAllCloseAccordingToType(jacob_n, gradient_tape_jacob_t,\n                                                 half_atol=1e-2)\n\n  @test_util.run_deprecated_v1\n  def testProdGrad(self):\n    # additional test for the prod gradient to ensure correct handling of zeros\n    values = np.array([0, 0, 1, 0, 2, 2, 3, 3, 3], dtype=np.float32)\n    indices = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2], dtype=np.int32)\n    indices_neg = np.array([-1, 0, 0, -1, 1, 1, -1, 2, 2], dtype=np.int32)\n    values_tf = constant_op.constant(values)\n    # ground truth partial derivatives\n    gradients_indices = np.zeros((9, 3), dtype=np.float32)\n    gradients_indices_neg = np.zeros((9, 3), dtype=np.float32)\n    # the derivative w.r.t. to the other segments is zero, so here we only\n    # explicitly set the grad values for the corresponding segment\n    gradients_indices[range(9), indices] = [0, 0, 0, 4, 0, 0, 9, 9, 9]\n    gradients_indices_neg[range(9), indices_neg] = [0, 1, 0, 0, 2, 2, 0, 3, 3]\n    for use_gpu in [False, True]:\n      with self.cached_session(use_gpu=use_gpu):\n        for ind, grad_gt in [(indices, gradients_indices),\n                             (indices_neg, gradients_indices_neg)]:\n          s = math_ops.unsorted_segment_prod(values_tf,\n                                             constant_op.constant(ind), 3)\n          jacob_t, jacob_n = gradient_checker.compute_gradient(\n              values_tf, (9,), s, (3,), x_init_value=values, delta=1)\n          self.assertAllClose(jacob_t, jacob_n)\n          self.assertAllClose(jacob_t, grad_gt)\n\n  @test_util.run_deprecated_v1\n  def testGradientMatchesSegmentSum(self):\n    # Strategy: compute the gradient for UnsortedSegmentSum and SegmentSum\n    # and compare the outputs, which should be identical.\n    # NB: for this test to work, indices must be valid for SegmentSum, namely\n    # it must be sorted, the indices must be contiguous, and num_segments\n    # must be max(indices) + 1.\n    indices = [0, 0, 1, 1, 1, 2, 3, 4, 5]\n    n = len(indices)\n    num_cols = 2\n    shape = [n, num_cols]\n    num_segments = max(indices) + 1\n    for dtype in self.differentiable_dtypes:\n      with self.cached_session():\n        tf_x, np_x = self._input(shape, dtype=dtype)\n        # Results from UnsortedSegmentSum\n        unsorted_s = math_ops.unsorted_segment_sum(\n            data=tf_x, segment_ids=indices, num_segments=num_segments)\n        unsorted_jacob_t, unsorted_jacob_n = (\n            gradient_checker.compute_gradient(tf_x, shape, unsorted_s,\n                                              [num_segments, num_cols],\n                                              x_init_value=np_x, delta=1))\n\n        # Results from SegmentSum\n        sorted_s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n        sorted_jacob_t, sorted_jacob_n = gradient_checker.compute_gradient(\n            tf_x,\n            shape,\n            sorted_s, [num_segments, num_cols],\n            x_init_value=np_x,\n            delta=1)\n      self.assertAllClose(unsorted_jacob_t, sorted_jacob_t)\n      self.assertAllClose(unsorted_jacob_n, sorted_jacob_n)\n\n  @test_util.run_deprecated_v1\n  def testBadIndices(self):\n    # Note: GPU kernel does not return the out-of-range error needed for this\n    # test, so this test is marked as cpu-only.\n    # Note: With PR #13055 a negative index will be ignored silently.\n    with self.session(use_gpu=False):\n      for bad in [[2]], [[7]]:\n        unsorted = math_ops.unsorted_segment_sum([[17]], bad, num_segments=2)\n        with self.assertRaisesOpError(\n            r\"segment_ids\\[0,0\\] = %d is out of range \\[0, 2\\)\" % bad[0][0]):\n          self.evaluate(unsorted)\n\n  @test_util.run_deprecated_v1\n  def testEmptySecondDimension(self):\n    dtypes = [np.float16, np.float32, np.float64, np.int64, np.int32,\n              np.complex64, np.complex128]\n    with self.session():\n      for dtype in dtypes:\n        for itype in (np.int32, np.int64):\n          data = np.zeros((2, 0), dtype=dtype)\n          segment_ids = np.array([0, 1], dtype=itype)\n          unsorted = math_ops.unsorted_segment_sum(data, segment_ids, 2)\n          self.assertAllEqual(unsorted, np.zeros((2, 0), dtype=dtype))\n\n  def testDropNegatives(self):\n    # Note: the test is done by replacing segment_ids with 8 to -1\n    # for index  and replace values generated by numpy with 0.\n    indices_flat = np.array([0, 4, 0, 8, 3, 8, 4, 7, 7, 3])\n    num_segments = 12\n    for indices in indices_flat, indices_flat.reshape(5, 2):\n      shape = indices.shape + (2,)\n      for dtype in self.all_dtypes:\n        with self.session():\n          tf_x, np_x = self._input(shape, dtype=dtype)\n          np_ans = self._segmentReduce(\n              indices, np_x, np.add, op2=None, num_segments=num_segments)\n          # Replace np_ans[8] with 0 for the value\n          np_ans[8:] = 0\n          # Replace 8 with -1 in indices\n          np.place(indices, indices == 8, [-1])\n          s = math_ops.unsorted_segment_sum(\n              data=tf_x, segment_ids=indices, num_segments=num_segments)\n          tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n        self.assertShapeEqual(np_ans, s)\n\n\nclass SparseSegmentReductionHelper(SegmentReductionHelper):\n\n  def _sparse_input(self, input_shape, num_indices, dtype=dtypes_lib.int32):\n    a, b = super(SparseSegmentReductionHelper, self)._input(input_shape, dtype)\n    indices = np.random.randint(0, input_shape[0], num_indices).astype(np.int32)\n    return (constant_op.constant(\n        indices, dtype=dtypes_lib.int32), indices, a, b)\n\n  def _sparseSegmentReduce(self,\n                           x,\n                           indices,\n                           segment_indices,\n                           op1,\n                           op2=None,\n                           num_segments=None):\n    return self._segmentReduce(\n        segment_indices, x[indices], op1, op2, num_segments=num_segments)\n\n  def _sparseSegmentReduceGrad(self, ygrad, indices, segment_ids, output_dim0,\n                               mode):\n    assert mode in (\"sum\", \"mean\", \"sqrtn\")\n    if mode != \"sum\":\n      weights = np.zeros(ygrad.shape[0], ygrad.dtype)\n      for segment in segment_ids:\n        weights[segment] += 1\n      weights = 1. / weights if mode == \"mean\" else 1. / np.sqrt(weights)\n    xgrad = np.zeros([output_dim0, ygrad.shape[1]], ygrad.dtype)\n    for segment, index in zip(segment_ids, indices):\n      if mode == \"sum\":\n        xgrad[index] += ygrad[segment]\n      else:\n        xgrad[index] += ygrad[segment] * weights[segment]\n    return xgrad\n\n\nclass SparseSegmentReductionOpTest(SparseSegmentReductionHelper):\n\n  def testValues(self):\n    dtypes = [\n        dtypes_lib.float32, dtypes_lib.float64, dtypes_lib.int64,\n        dtypes_lib.int32\n    ]\n\n    index_dtypes = [dtypes_lib.int32, dtypes_lib.int64]\n    segment_ids_dtypes = [dtypes_lib.int32, dtypes_lib.int64]\n\n    mean_dtypes = [dtypes_lib.float32, dtypes_lib.float64]\n\n    # Each item is np_op1, np_op2, tf_op\n    ops_list = [(np.add, None, math_ops.sparse_segment_sum),\n                (self._mean_cum_op, self._mean_reduce_op,\n                 math_ops.sparse_segment_mean)]\n\n    n = 400\n    # Note that the GPU implem has different paths for different inner sizes.\n    for inner_size in [1, 2, 3, 32]:\n      shape = [n, inner_size]\n      segment_indices = []\n      for i in range(20):\n        for _ in range(i + 1):\n          segment_indices.append(i)\n      num_indices = len(segment_indices)\n      for dtype in dtypes:\n        for index_dtype in index_dtypes:\n          for segment_ids_dtype in segment_ids_dtypes:\n            with self.cached_session():\n              tf_indices, np_indices, tf_x, np_x = self._sparse_input(\n                  shape, num_indices, dtype=dtype)\n              for np_op1, np_op2, tf_op in ops_list:\n                if (tf_op == math_ops.sparse_segment_mean and\n                    dtype not in mean_dtypes):\n                  continue\n                np_ans = self._sparseSegmentReduce(np_x, np_indices,\n                                                   segment_indices, np_op1,\n                                                   np_op2)\n                s = tf_op(\n                    data=tf_x,\n                    indices=math_ops.cast(tf_indices, index_dtype),\n                    segment_ids=math_ops.cast(segment_indices,\n                                              segment_ids_dtype))\n                tf_ans = self.evaluate(s)\n                self.assertAllClose(np_ans, tf_ans)\n                # NOTE(mrry): The static shape inference that computes\n                # `tf_ans.shape` can only infer that sizes from dimension 1\n                # onwards, because the size of dimension 0 is data-dependent\n                # and may therefore vary dynamically.\n                self.assertAllEqual(np_ans.shape[1:], tf_ans.shape[1:])\n\n  def testSegmentIdsHole(self):\n    tf_x, np_x = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [(np.add, None, math_ops.sparse_segment_sum), (\n        self._mean_cum_op, self._mean_reduce_op, math_ops.sparse_segment_mean)]\n    segment_indices = [0, 2, 2, 2]\n    tf_indices = [8, 3, 0, 9]\n    with self.session():\n      for np_op1, np_op2, tf_op in ops_list:\n        np_ans = self._sparseSegmentReduce(np_x, tf_indices, segment_indices,\n                                           np_op1, np_op2)\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n\n  def testWithNumSegments(self):\n    tf_x, np_x = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [(np.add, None, math_ops.sparse_segment_sum_with_num_segments),\n                (self._mean_cum_op, self._mean_reduce_op,\n                 math_ops.sparse_segment_mean_with_num_segments)]\n    segment_indices = [0, 2, 2, 2]\n    tf_indices = [8, 3, 0, 9]\n    num_segments = 5\n    with self.session():\n      for np_op1, np_op2, tf_op in ops_list:\n        np_ans = self._sparseSegmentReduce(\n            np_x,\n            tf_indices,\n            segment_indices,\n            np_op1,\n            np_op2,\n            num_segments=num_segments)\n        s = tf_op(\n            data=tf_x,\n            indices=tf_indices,\n            segment_ids=segment_indices,\n            num_segments=num_segments)\n        tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n\n  def testWithEmptySegments(self):\n    tf_x = constant_op.constant([], shape=[0, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_with_num_segments,\n        math_ops.sparse_segment_mean_with_num_segments\n    ]\n    segment_indices = []\n    tf_indices = []\n    num_segments = 5\n    with self.session():\n      for tf_op in ops_list:\n        s = tf_op(\n            data=tf_x,\n            indices=tf_indices,\n            segment_ids=segment_indices,\n            num_segments=num_segments)\n        tf_ans = self.evaluate(s)\n        self.assertAllClose(np.zeros([5, 4]), tf_ans)\n\n  @test_util.run_in_graph_and_eager_modes\n  def testSegmentScalarIdiRaisesInvalidArgumentError(self):\n    \"\"\"Test for github #46897.\"\"\"\n    ops_list = [\n        math_ops.sparse_segment_sum,\n        math_ops.sparse_segment_mean,\n        math_ops.sparse_segment_sqrt_n,\n    ]\n    for op in ops_list:\n      with self.assertRaisesRegex(\n          (ValueError, errors_impl.InvalidArgumentError),\n          \"Shape must be at least rank 1\"):\n        op(data=1.0, indices=[0], segment_ids=[3])\n\n  def testSegmentIdsGreaterThanZero(self):\n    tf_x, np_x = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [(np.add, None, math_ops.sparse_segment_sum), (\n        self._mean_cum_op, self._mean_reduce_op, math_ops.sparse_segment_mean)]\n    segment_indices = [1, 2, 2, 2]\n    tf_indices = [8, 3, 0, 9]\n    with self.session():\n      for np_op1, np_op2, tf_op in ops_list:\n        np_ans = self._sparseSegmentReduce(np_x, tf_indices, segment_indices,\n                                           np_op1, np_op2)\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n\n  def testValid(self):\n    # Baseline for the test*Invalid* methods below.\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 1, 2, 2]\n    tf_indices = [8, 3, 0, 9]\n    with self.session():\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testIndicesInvalid1(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 1, 2, 2]\n    tf_indices = [8, -1, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\n            r\"indices\\[1\\] == -1 out of range \\[0, 10\\)\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testIndicesInvalid2(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 1, 2, 2]\n    tf_indices = [8, 3, 0, 10]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\n            r\"indices\\[3\\] == 10 out of range \\[0, 10\\)\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentsInvalid2(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 1, 0, 1]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\"segment ids are not increasing\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentsInvalid3(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 1, 2, 0]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\n            r\"Segment id 1 out of range \\[0, 1\\), possibly because \"\n            \"'segment_ids' input is not sorted\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentsInvalid4(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [-1, 0, 1, 1]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\n            r\"Segment id -1 out of range \\[0, 2\\), possibly because \"\n            \"'segment_ids' input is not sorted\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentsInvalid6(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 0, 0, -1]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\"segment ids must be >= 0\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentsInvalid7(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 0, 0, -2]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\"segment ids must be >= 0\"):\n          self.evaluate(s)\n\n  def testSegmentWithNumSegmentsValid(self):\n    # Baseline for the test*WithNumSegmentsInvalid* methods below.\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_with_num_segments,\n        math_ops.sparse_segment_mean_with_num_segments,\n    ]\n    num_segments = 5\n    segment_indices = [0, 1, 3, 3]\n    tf_indices = [8, 3, 0, 9]\n    with self.session():\n      for tf_op in ops_list:\n        s = tf_op(\n            data=tf_x,\n            indices=tf_indices,\n            segment_ids=segment_indices,\n            num_segments=num_segments)\n        self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentWithNumSegmentsInvalid1(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_with_num_segments,\n        math_ops.sparse_segment_mean_with_num_segments,\n    ]\n    num_segments = 5\n    segment_indices = [0, 1, 3, 5]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(\n            data=tf_x,\n            indices=tf_indices,\n            segment_ids=segment_indices,\n            num_segments=num_segments)\n        with self.assertRaisesOpError(\"segment ids must be < num_segments\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentWithNumSegmentsInvalid2(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_with_num_segments,\n        math_ops.sparse_segment_mean_with_num_segments,\n    ]\n    num_segments = -2\n    segment_indices = [0, 1, 3, 3]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        with self.assertRaisesRegex(\n            ValueError, \"Cannot specify a negative value for num_segments\"):\n          tf_op(\n              data=tf_x,\n              indices=tf_indices,\n              segment_ids=segment_indices,\n              num_segments=num_segments)\n\n  @test_util.run_deprecated_v1\n  def testGradient(self):\n    shape = [10, 4]\n\n    segment_indices = [0, 1, 2, 2]\n    num_indices = len(segment_indices)\n    for tf_op in [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]:\n      with self.cached_session():\n        tf_indices, _, tf_x, np_x = self._sparse_input(\n            shape, num_indices, dtype=dtypes_lib.float64)\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        jacob_t, jacob_n = gradient_checker.compute_gradient(\n            tf_x,\n            shape,\n            s, [3, 4],\n            x_init_value=np_x.astype(np.double),\n            delta=1)\n      self.assertAllClose(jacob_t, jacob_n)\n\n  @test_util.run_deprecated_v1\n  def testGradientWithEmptySegmentsAtEnd(self):\n    shape = [10, 4]\n\n    num_segments = 5\n    segment_indices = [0, 1, 2, 2]\n    num_indices = len(segment_indices)\n    for tf_op in [\n        math_ops.sparse_segment_sum_with_num_segments,\n        math_ops.sparse_segment_mean_with_num_segments,\n    ]:\n      with self.cached_session():\n        tf_indices, _, tf_x, np_x = self._sparse_input(\n            shape, num_indices, dtype=dtypes_lib.float64)\n        s = tf_op(\n            data=tf_x,\n            indices=tf_indices,\n            segment_ids=segment_indices,\n            num_segments=num_segments)\n        jacob_t, jacob_n = gradient_checker.compute_gradient(\n            tf_x,\n            shape,\n            s, [5, 4],\n            x_init_value=np_x.astype(np.double),\n            delta=1)\n      self.assertAllClose(jacob_t, jacob_n)\n\n  def testGradientExplicit(self):\n    # Note that the GPU implem has different paths for different inner sizes.\n    for inner_size in (1, 2, 3, 32):\n      with self.session():\n        tf_ygrad, np_ygrad = self._input([3, inner_size],\n                                         dtype=dtypes_lib.float32)\n        segment_ids = [0, 1, 2, 2, 2]\n        indices = [8, 3, 0, 9, 3]\n        output_dim0 = 10\n        ops_list = [\n            (math_ops.sparse_segment_sum_grad, \"sum\"),\n            (math_ops.sparse_segment_mean_grad, \"mean\"),\n            (math_ops.sparse_segment_sqrt_n_grad, \"sqrtn\"),\n        ]\n        for tf_op, mode in ops_list:\n          np_xgrad = self._sparseSegmentReduceGrad(np_ygrad, indices,\n                                                   segment_ids, output_dim0,\n                                                   mode)\n          tf_xgrad = tf_op(tf_ygrad, indices, segment_ids, output_dim0)\n          self.assertAllClose(tf_xgrad, np_xgrad)\n\n  def testGradientExplicitSingleOutput(self):\n    # The GPU implem has a special case when there is a single output.\n    for inner_size in (1, 2, 3, 32):\n      with self.session():\n        tf_ygrad, np_ygrad = self._input([3, inner_size],\n                                         dtype=dtypes_lib.float32)\n        segment_ids = [0, 1, 2, 2, 2]\n        indices = [0, 0, 0, 0, 0]\n        output_dim0 = 1\n        ops_list = [\n            (math_ops.sparse_segment_sum_grad, \"sum\"),\n            (math_ops.sparse_segment_mean_grad, \"mean\"),\n            (math_ops.sparse_segment_sqrt_n_grad, \"sqrtn\"),\n        ]\n        for tf_op, mode in ops_list:\n          np_xgrad = self._sparseSegmentReduceGrad(np_ygrad, indices,\n                                                   segment_ids, output_dim0,\n                                                   mode)\n          tf_xgrad = tf_op(tf_ygrad, indices, segment_ids, output_dim0)\n          self.assertAllClose(tf_xgrad, np_xgrad)\n\n  def testGradientValid(self):\n    # Baseline for the testGradient*Invalid* methods below.\n    tf_x, _ = self._input([3, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [0, 1, 2, 2]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradientIndicesInvalid1(self):\n    tf_x, _ = self._input([3, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [0, 1, 2, 2]\n    tf_indices = [8, 3, 0, 10]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        with self.assertRaisesOpError(r\"Index 10 out of range \\[0, 10\\)\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradientIndicesInvalid2(self):\n    tf_x, _ = self._input([3, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [0, 1, 2, 2]\n    tf_indices = [8, 3, -1, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        with self.assertRaisesOpError(r\"Index -1 out of range \\[0, 10\\)\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradientSegmentsInvalid1(self):\n    tf_x, _ = self._input(\n        [3, 4], dtype=dtypes_lib.float32)  # expecting 3 segments\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [0, 1, 1, 4]  # 5 segments\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        with self.assertRaisesOpError(\"Invalid number of segments\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradientSegmentsInvalid2(self):\n    tf_x, _ = self._input([1, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [0, 1, 2, 0]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        with self.assertRaisesOpError(r\"Segment id 1 out of range \\[0, 1\\)\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradientSegmentsInvalid3(self):\n    tf_x, _ = self._input([2, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [-1, 0, 1, 1]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        with self.assertRaisesOpError(r\"Segment id -1 out of range \\[0, 2\\)\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradientSegmentsInvalid4(self):\n    tf_x, _ = self._input([0, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [0, 1, 2, -1]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        with self.assertRaisesOpError(r\"Segment id 0 out of range \\[0, 0\\)\"):\n          self.evaluate(s)\n\n\nclass SegmentReductionOpBenchmark(test.Benchmark):\n  outer_dim_options = [2**x for x in range(9, 14, 2)]\n  ratio_options = [2**x for x in range(1, 6, 2)]\n  inner_dim_options = [2**x for x in range(9, 14, 2)]\n  # randomly generated sizes with less alignments\n  inner_dim_options += [\n      1120, 1215, 1856, 1302, 1329, 1531, 1313, 1672, 1851, 1584\n  ]\n  dtype_options = [np.float32, np.float64]\n  options = (outer_dim_options, ratio_options, inner_dim_options, dtype_options)\n  # pylint: disable=g-long-lambda\n  op_functors = [lambda vc, vs, seg_ids:\n                 (\"sorted\", math_ops.segment_sum(vc, vs)),\n                 lambda vc, vs, seg_ids:\n                 (\"unsorted\",\n                  math_ops.unsorted_segment_sum(vc, vs, seg_ids[-1]+1))]\n  # pylint: enable=g-long-lambda\n  repeat = 10\n\n  def _npTypeToStr(self, t):\n    if t == np.float32:\n      return \"fp32\"\n    if t == np.float64:\n      return \"fp64\"\n\n  def _runGraph(self, op_functor, outer_dim, ratio, inner_dim, dtype):\n    output_outer_dim = int(outer_dim / ratio)\n    const = np.random.randint(5, size=(outer_dim, inner_dim))\n    seg_ids = np.sort(np.random.randint(output_outer_dim, size=outer_dim))\n    vs = variables.Variable(seg_ids.astype(np.int32))\n    with ops.device(\"/gpu:0\"):\n      vc = variables.Variable(const.astype(dtype))\n    name, op = op_functor(vc, vs, seg_ids)\n    with session.Session() as sess:\n      self.evaluate(variables.global_variables_initializer())\n      r = self.run_op_benchmark(\n          sess,\n          op,\n          min_iters=self.repeat,\n          name=\"_\".join(\n              map(str,\n                  [name, outer_dim, ratio, inner_dim,\n                   self._npTypeToStr(dtype)])))\n    return name, r[\"wall_time\"]\n\n  def benchmarkSegmentSumGPU(self):\n    if not test.is_gpu_available(cuda_only=True):\n      return\n    for outer_dim, ratio, inner_dim, dtype in itertools.product(*self.options):\n      op_functor = self.op_functors[0]\n      with ops.Graph().as_default():\n        self._runGraph(op_functor, outer_dim, ratio, inner_dim, dtype)\n\n  def benchmarkUnsortedSegmentSumGPU(self):\n    if not test.is_gpu_available(cuda_only=True):\n      return\n    for outer_dim, ratio, inner_dim, dtype in itertools.product(*self.options):\n      op_functor = self.op_functors[1]\n      with ops.Graph().as_default():\n        self._runGraph(op_functor, outer_dim, ratio, inner_dim, dtype)\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "fixing_code": ["/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/math_ops.cc.\n\n#ifndef TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_IMPL_H_\n#define TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_IMPL_H_\n\n#define EIGEN_USE_THREADS\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define EIGEN_USE_GPU\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#include <vector>\n\n#include \"third_party/eigen3/Eigen/Core\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/segment_reduction_ops.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/util/determinism.h\"\n#include \"tensorflow/core/util/util.h\"\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/common_runtime/gpu/gpu_event_mgr.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#if GOOGLE_CUDA\n#include \"tensorflow/core/util/gpu_solvers.h\"\n#include \"tensorflow/stream_executor/cuda/cuda_activation.h\"\n\nusing stream_executor::cuda::ScopedActivateExecutorContext;\n#elif TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/platform/rocm.h\"\n#include \"tensorflow/core/util/gpu_solvers.h\"\nusing stream_executor::rocm::ScopedActivateExecutorContext;\n#endif  // GOOGLE_CUDA\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\nnamespace internal {\nStatus ValidateSegmentReduction(OpKernelContext* c, const Tensor& input,\n                                const Tensor& segment_ids);\nStatus ValidateUnsortedSegmentReduction(OpKernel* op_kernel,\n                                        OpKernelContext* context,\n                                        const Tensor& data,\n                                        const Tensor& segment_ids,\n                                        const Tensor& num_segments);\nStatus ValidateSparseSegmentReduction(OpKernelContext* context,\n                                      const Tensor& input,\n                                      const Tensor& indices,\n                                      const Tensor& segment_ids,\n                                      bool has_num_segments);\n}  // namespace internal\n\n// This operator handles reducing segments along the first dimension.\n// See core/ops/math_ops.cc for more details.\ntemplate <typename Device, class T, class Index, typename Reducer,\n          int default_value>\nclass SegmentReductionOp : public OpKernel {\n public:\n  explicit SegmentReductionOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n\n    OP_REQUIRES_OK(context, internal::ValidateSegmentReduction(context, input,\n                                                               segment_ids));\n\n    const int64_t num_indices = segment_ids.NumElements();\n    auto input_flat = input.flat_outer_dims<T>();\n    const int64_t num_col = input_flat.dimension(1);\n\n    const auto segment_vec = segment_ids.vec<Index>();\n    // Note that the current implementation assumes that segment_vec values are\n    // sorted.\n    const Index output_rows =\n        num_indices > 0\n            ? internal::SubtleMustCopy(segment_vec(num_indices - 1)) + 1\n            : 0;\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n\n    OP_REQUIRES(context, input.dims() >= 1,\n                errors::InvalidArgument(\"Shape must be at least rank 1\"));\n\n    TensorShape output_shape = input.shape();\n    // Since we're changing the first dimension of the shape, we need to make\n    // sure the new shape won't overflow.\n    OP_REQUIRES_OK(context, output_shape.SetDimWithStatus(0, output_rows));\n\n    // Note that we do not initialize the output buffer with a default value, so\n    // we need to explicitly set missing indices to the default value.\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    if (num_indices == 0) return;\n    OP_REQUIRES(context, output_rows > 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n    auto output_flat = output->flat_outer_dims<T>();\n\n#if !defined(EIGEN_HAS_INDEX_LIST)\n    Eigen::DSizes<Eigen::DenseIndex, 1> dims_to_reduce;\n    dims_to_reduce[0] = 0;\n#else\n    Eigen::IndexList<Eigen::type2index<0> > dims_to_reduce;\n#endif\n    Index start = 0, end = 1;\n\n    Index uninitialized_index = 0;  // Index from which the output is not set.\n    Index out_index = internal::SubtleMustCopy(segment_vec(start));\n\n    // TODO(agarwal): if this loop becomes a bottleneck, consider sharding it\n    // across threads.\n    Eigen::DSizes<Eigen::DenseIndex, 1> out_slice_shape(num_col);\n    while (end <= num_indices) {\n      // We initialize next_index to 0 to avoid \"warning: 'next_index' may be\n      // used uninitialized in this function\" in the Mac build (since the\n      // compiler isn't smart enough to realize the code is safe).\n      Index next_index = 0;\n      if (end < num_indices) {\n        next_index = internal::SubtleMustCopy(segment_vec(end));\n        if (out_index == next_index) {\n          ++end;\n          continue;\n        }\n        // We have a new segment here.  Verify that the segment ids are growing.\n        OP_REQUIRES(context, out_index < next_index,\n                    errors::InvalidArgument(\"segment ids are not increasing\"));\n      }\n\n      // Process segment [start, end)\n      const T* in_slice_ptr = &input_flat(start, 0);\n      typedef Eigen::TensorMap<Eigen::Tensor<T, 1, Eigen::RowMajor>,\n                               Eigen::Unaligned>\n          OutT;\n\n      OP_REQUIRES(\n          context, FastBoundsCheck(out_index, output_rows),\n          errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\"));\n\n      // If there is a gap between two indices, we need to set that gap to the\n      // default value.\n      if (out_index > uninitialized_index) {\n        Eigen::DSizes<Eigen::DenseIndex, 2> gap_slice_shape(\n            out_index - uninitialized_index, num_col);\n        Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>\n            gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);\n        gap_slice.setConstant(T(default_value));\n      }\n\n      T* out_slice_ptr = &output_flat(out_index, 0);\n      OutT out_slice(out_slice_ptr, out_slice_shape);\n      // We don't use out_slice.device(context->eigen_device<Device>)\n      // because these pieces of work are likely to be very small and\n      // the context switching overhead dwarfs any benefit we get from\n      // using another thread to do this work.\n      if (start == end - 1) {\n        typedef Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,\n                                 Eigen::Unaligned>\n            InT;\n        InT in_slice(in_slice_ptr, out_slice_shape);\n        out_slice = in_slice;\n      } else {\n        Eigen::DSizes<Eigen::DenseIndex, 2> in_slice_shape(end - start,\n                                                           num_col);\n        typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,\n                                 Eigen::Unaligned>\n            InT;\n        InT in_slice(in_slice_ptr, in_slice_shape);\n\n        out_slice = in_slice.reduce(dims_to_reduce, Reducer());\n      }\n      if (end >= num_indices) break;\n      start = end;\n      ++end;\n      uninitialized_index = out_index + 1;\n      out_index = next_index;\n    }\n  }\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n//  SegmentReductionGPUOp is a segment reduction operator implemented for GPU\n//  only.\n//  TODO: This implementation of SegmentReductionGPUOp is sometimes slower than\n//  its unsorted counterpart (mostly when problem size is small).\n//  This is due to the following two main reasons and a cost-effective way\n//  to resolve these problems is desirable.\n//  1. Sorted segment reduction requires a memory transfer from device to host\n//     in order to know the size of the output dimension whereas unsorted\n//     segment reduction receives the size of the output dimension as an input\n//     parameter.\n//  2. Sorted segment reduction is essentially a tiled version of unsorted\n//     segment reduction and therefore such optimization comes at an inherent\n//     cost. However such cost may not be justified when the problem size is\n//     small. When to use the tiled version or the untiled version depends on\n//     many factors including data alignments, ratio of calculation to memory\n//     traffic and obviously, the problem sizes.\ntemplate <class T, class Index, class SegmentReductionFunctor, bool IsMean>\nclass SegmentReductionGPUOp : public AsyncOpKernel {\n public:\n  explicit SegmentReductionGPUOp(OpKernelConstruction* context)\n      : AsyncOpKernel(context) {}\n\n  void ComputeAsync(OpKernelContext* context, DoneCallback done) override {\n    const Tensor& input = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n\n    OP_REQUIRES_ASYNC(\n        context, TensorShapeUtils::IsVector(segment_ids.shape()),\n        errors::InvalidArgument(\"segment_ids should be a vector.\"), done);\n\n    OP_REQUIRES_ASYNC(context, input.dims() >= 1,\n                      errors::InvalidArgument(\"Shape must be at least rank 1\"),\n                      done);\n\n    const int64_t num_indices = segment_ids.NumElements();\n    OP_REQUIRES_ASYNC(\n        context, num_indices == input.dim_size(0),\n        errors::InvalidArgument(\n            \"segment_ids should be the same size as dimension 0 of\"\n            \" input.\"),\n        done);\n\n    if (num_indices == 0) {\n      TensorShape output_shape = input.shape();\n      output_shape.set_dim(0, 0);\n\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          context, context->allocate_output(0, output_shape, &output), done);\n      done();\n      return;\n    }\n\n    se::DeviceMemoryBase output_rows_device(\n        const_cast<Tensor&>(segment_ids).template flat<Index>().data() +\n        (num_indices - 1));\n    ScratchSpace<Index> output_rows_host(context, 1, /* on_host */ true);\n\n    auto stream = context->op_device_context()->stream();\n    OP_REQUIRES_ASYNC(\n        context,\n        stream\n            ->ThenMemcpy(output_rows_host.mutable_data(), output_rows_device,\n                         sizeof(Index))\n            .ok(),\n        errors::Internal(type_string() +\n                         \": failed to copy output_rows from device\"),\n        done);\n\n    SegmentReductionFunctor functor_;\n    auto create_and_check_output = [context, output_rows_host, &input,\n                                    &segment_ids, &functor_, done]() {\n      // Ensure that within the callback, the proper GPU settings are\n      // configured.\n      auto stream = context->op_device_context()->stream();\n      ScopedActivateExecutorContext scoped_activation{stream->parent()};\n\n      Index output_rows = *output_rows_host.data();\n      output_rows++;\n      OP_REQUIRES_ASYNC(context, output_rows > 0,\n                        errors::InvalidArgument(\"segment ids must be >= 0\"),\n                        done);\n\n      TensorShape output_shape = input.shape();\n      // Since we're changing the first dimension of the shape, we need to make\n      // sure the new shape won't overflow.\n      OP_REQUIRES_OK_ASYNC(context,\n                           output_shape.SetDimWithStatus(0, output_rows), done);\n\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          context, context->allocate_output(0, output_shape, &output), done);\n\n      bool use_deterministic_kernels =\n#if defined(PLATFORM_WINDOWS)\n          // See comment in segment_reduction_ops_gpu_0.cu.cc regarding Windows\n          // CI build error.\n          false;\n#else\n          UseDeterministicSegmentReductions() ||\n          (!SegmentReductionFunctor::atomic_reduction_is_associative &&\n           OpDeterminismRequired());\n#endif\n\n      // The determinism check is here, rather than inside the functor (as it is\n      // for the unsorted segment reduction ops) because the done callback\n      // (required for OP_REQUIRES_ASYNC) is not available inside the functor.\n      bool determinism_requirement_met =\n          use_deterministic_kernels ||\n          SegmentReductionFunctor::atomic_reduction_is_associative ||\n          !OpDeterminismRequired() ||\n          DisableSegmentReductionOpDeterminismExceptions();\n      OP_REQUIRES_ASYNC(\n          context, determinism_requirement_met,\n          errors::Unimplemented(\n              \"Deterministic GPU implementation of sorted segment reduction op\"\n              \" not available.\"),\n          done);\n\n      auto output_flat = output->flat_outer_dims<T>();\n      auto data_ptr = input.template flat<T>().data();\n      auto segment_flat = segment_ids.flat<Index>();\n      functor_(context, context->eigen_device<GPUDevice>(), output_rows,\n               segment_ids.shape(), IsMean, segment_flat, input.NumElements(),\n               data_ptr, output_flat);\n\n      done();\n    };\n\n    context->device()->tensorflow_gpu_device_info()->event_mgr->ThenExecute(\n        stream, create_and_check_output);\n  }\n};\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// ____________________________________________________________________________\n// Unsorted segment reduction ops.\n\nnamespace functor {\n\n// The ReductionFunctor implementation for CPU.\ntemplate <typename T, typename Index, typename InitialValueF,\n          typename ReductionF>\nstruct UnsortedSegmentFunctor<CPUDevice, T, Index, InitialValueF, ReductionF> {\n  void operator()(OpKernelContext* ctx, const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  typename TTypes<T, 2>::ConstTensor data,\n                  typename TTypes<T, 2>::Tensor output) {\n    output.setConstant(InitialValueF()());\n    if (data.size() == 0) {\n      return;\n    }\n    const int64_t N = segment_ids.dimension(0);\n    const int64_t num_segments = output.dimension(0);\n    ReductionF reduction;\n    for (int64_t i = 0; i < N; ++i) {\n      Index j = internal::SubtleMustCopy(segment_ids(i));\n      if (j < 0) {\n        continue;\n      }\n      OP_REQUIRES(ctx, FastBoundsCheck(j, num_segments),\n                  errors::InvalidArgument(\n                      \"segment_ids\", SliceDebugString(segment_ids_shape, i),\n                      \" = \", j, \" is out of range [0, \", num_segments, \")\"));\n      reduction(data.template chip<0>(i), output.template chip<0>(j));\n    }\n  }\n};\n\ntemplate <typename T>\nusing MatrixChip = Eigen::TensorChippingOp<0l, typename TTypes<T, 2>::Matrix>;\n\ntemplate <typename T>\nusing constMatrixChip =\n    Eigen::TensorChippingOp<0l, const typename TTypes<T, 2>::ConstMatrix>;\n\n// reduction functors\ntemplate <typename T>\nstruct SumOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output += data;\n  }\n};\n\ntemplate <typename T>\nstruct MaxOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output = data.cwiseMax(output);\n  }\n};\n\ntemplate <typename T>\nstruct MinOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output = data.cwiseMin(output);\n  }\n};\n\ntemplate <typename T>\nstruct ProdOp {\n  void operator()(const constMatrixChip<T> data, MatrixChip<T> output) {\n    output *= data;\n  }\n};\n}  // namespace functor\n\n// The UnsortedSegmentReduction OpKernel. The DeviceReductionFunctor\n// is the device specific implementation of the reduction. These device\n// specific implementations are templated themselves with the corresponding\n// initial value functors and reduction functors.\ntemplate <typename T, typename Index, typename DeviceReductionFunctor>\nclass UnsortedSegmentReductionOp : public OpKernel {\n public:\n  explicit UnsortedSegmentReductionOp(OpKernelConstruction* context)\n      : OpKernel(context), reduction_functor_(DeviceReductionFunctor()) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n    const Tensor& num_segments = context->input(2);\n    OP_REQUIRES_OK(context,\n                   internal::ValidateUnsortedSegmentReduction(\n                       this, context, data, segment_ids, num_segments));\n    const auto segment_flat = segment_ids.flat<Index>();\n    const int64_t output_rows = internal::SubtleMustCopy(static_cast<int64_t>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64_t>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n    TensorShape output_shape;\n    output_shape.AddDim(output_rows);\n    for (int i = segment_ids.dims(); i < data.dims(); i++) {\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_flat = data.flat_inner_outer_dims<T, 2>(segment_ids.dims() - 1);\n    reduction_functor_(context, segment_ids.shape(), segment_flat, data_flat,\n                       output_flat);\n  }\n\n protected:\n  DeviceReductionFunctor reduction_functor_;\n};\n\n// ____________________________________________________________________________\n// Sparse segment reduction ops.\n\n// Same as SegmentReductionOp but takes as input a \"sparse\" tensor, represented\n// by two dense tensors, one containing the data, and the other containing\n// indices into the data.\n//\n// The template parameters are:\n// * Device: An Eigen device object, on which the kernel will execute.\n// * T: The value type.\n// * Index: The element type of the indices tensor (int32 or int64).\n// * SegmentId: The element type of the segment_ids tensor (int32 or int64).\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionOpBase : public OpKernel {\n public:\n  explicit SparseSegmentReductionOpBase(OpKernelConstruction* context,\n                                        bool is_mean, bool is_sqrtn,\n                                        bool has_num_segments, T default_value)\n      : OpKernel(context),\n        is_mean_(is_mean),\n        is_sqrtn_(is_sqrtn),\n        has_num_segments_(has_num_segments),\n        default_value_(default_value) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& indices = context->input(1);\n    const Tensor& segment_ids = context->input(2);\n\n    OP_REQUIRES_OK(\n        context, internal::ValidateSparseSegmentReduction(\n                     context, input, indices, segment_ids, has_num_segments_));\n\n    Index output_rows = -1;\n    if (has_num_segments_) {\n      const Tensor& num_segments = context->input(3);\n      // Note that there is a Tnumsegments parameter on the op, but it is not\n      // plumbed through to here and so always takes its default value of int32.\n      output_rows = internal::SubtleMustCopy(num_segments.scalar<int32>()());\n    }\n    const int64_t num_indices = indices.NumElements();\n\n    auto input_flat = input.flat_outer_dims<T>();\n    const int64_t num_col = input_flat.dimension(1);\n    const auto indices_vec = indices.vec<Index>();\n    const auto segment_vec = segment_ids.vec<SegmentId>();\n    // Note that the current implementation assumes that segment_vec values are\n    // sorted.\n    const SegmentId last_segment_id_plus_one =\n        num_indices > 0\n            ? internal::SubtleMustCopy(segment_vec(num_indices - 1)) + 1\n            : 0;\n    if (has_num_segments_) {\n      OP_REQUIRES(\n          context, output_rows >= last_segment_id_plus_one,\n          errors::InvalidArgument(\"segment ids must be < num_segments\"));\n    } else {\n      output_rows = last_segment_id_plus_one;\n    }\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n\n    TensorShape output_shape = input.shape();\n    output_shape.set_dim(0, output_rows);\n\n    // Note that we do not initialize the output buffer with a default value, so\n    // we need to explicitly set missing indices to the default value.\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    if (num_indices == 0) {\n      if (output_rows > 0) {\n        output->flat_outer_dims<T>().setConstant(default_value_);\n      }\n      return;\n    }\n    OP_REQUIRES(context, output_rows > 0,\n                errors::InvalidArgument(\"segment ids must be >= 0\"));\n    auto output_flat = output->flat_outer_dims<T>();\n\n    Tensor temp;\n    if (input.dtype() == DT_BFLOAT16 || input.dtype() == DT_HALF) {\n      temp = tensorflow::Tensor(DT_FLOAT, output_shape);\n    }\n    auto temp_flat = temp.flat_outer_dims<float>();\n\n    int64_t start = 0, end = 1;\n    // Index from which the output is not initialized.\n    SegmentId uninitialized_index = 0;\n    SegmentId out_index = internal::SubtleMustCopy(segment_vec(start));\n\n    while (true) {\n      // We initialize next_index to 0 to avoid \"warning: 'next_index' may be\n      // used uninitialized in this function\" in the Mac build (since the\n      // compiler isn't smart enough to realize the code is safe).\n      SegmentId next_index = 0;\n      if (end < num_indices) {\n        next_index = internal::SubtleMustCopy(segment_vec(end));\n        if (out_index == next_index) {\n          ++end;\n          continue;\n        }\n        // We have a new segment here.  Verify that the segment ids are growing.\n        OP_REQUIRES(context, out_index < next_index,\n                    errors::InvalidArgument(\"segment ids are not increasing\"));\n      }\n\n      OP_REQUIRES(\n          context, FastBoundsCheck(out_index, output_rows),\n          errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\"));\n\n      // If there is a gap between two indices, we need to set that gap to the\n      // default value.\n      if (out_index > uninitialized_index) {\n        Eigen::DSizes<Eigen::DenseIndex, 2> gap_slice_shape(\n            out_index - uninitialized_index, num_col);\n        Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>\n            gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);\n        gap_slice.setConstant(default_value_);\n      }\n\n      auto out = output_flat.template chip<0>(out_index);\n      auto temp = temp_flat.template chip<0>(out_index);\n      const int bad_offset = Reduce<T, Index>(input_flat, indices_vec, start,\n                                              end - start, out, temp);\n      OP_REQUIRES(context, bad_offset < 0,\n                  errors::InvalidArgument(\n                      \"Bad: indices[\", start + bad_offset,\n                      \"] == \", indices_vec(start + bad_offset),\n                      \" out of range [0, \", input_flat.dimension(0), \")\"));\n\n      start = end;\n      ++end;\n      uninitialized_index = out_index + 1;\n      out_index = next_index;\n      if (end > num_indices) break;\n    }\n\n    // Fill the gap at the end with the default value.\n    if (uninitialized_index < output_rows) {\n      Eigen::DSizes<Eigen::DenseIndex, 2> gap_slice_shape(\n          output_rows - uninitialized_index, num_col);\n      Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>\n          gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);\n      gap_slice.setConstant(default_value_);\n    }\n  }\n\n private:\n  template <typename Tin>\n  using EnableIfBfloat16OrHalf =\n      typename std::enable_if<std::is_same<Tin, bfloat16>::value ||\n                                  std::is_same<Tin, Eigen::half>::value,\n                              int>::type;\n  template <typename Tin>\n  using EnableIfNotBfloat16OrHalf =\n      typename std::enable_if<!std::is_same<Tin, bfloat16>::value &&\n                                  !std::is_same<Tin, Eigen::half>::value,\n                              int>::type;\n\n  template <typename Tin, typename Tindex, EnableIfNotBfloat16OrHalf<Tin> = 0>\n  EIGEN_ALWAYS_INLINE auto fetch_val(\n      const typename TTypes<Tin>::ConstMatrix& input_flat, Tindex index) {\n    return input_flat.template chip<0>(index);\n  }\n\n  template <typename Tin, typename Tindex, EnableIfBfloat16OrHalf<Tin> = 0>\n  EIGEN_ALWAYS_INLINE auto fetch_val(\n      const typename TTypes<Tin>::ConstMatrix& input_flat, Tindex index) {\n    return input_flat.template chip<0>(index).template cast<float>();\n  }\n\n  template <typename Tout>\n  EIGEN_ALWAYS_INLINE Tout get_scaling_factor(int64_t num) {\n    Tout m(1);\n    if (is_mean_ && (num < 10)) {\n      m = Tout(num);\n    }\n    if (is_sqrtn_ && (num < 10)) {\n      m = Tout(sqrt(num));\n    }\n    return Tout(1) / m;\n  }\n\n  template <typename Tin, typename Tindex, EnableIfNotBfloat16OrHalf<Tin> = 0>\n  int64_t Reduce(\n      const typename TTypes<Tin>::ConstMatrix& input_flat,\n      const typename TTypes<Tindex>::ConstVec& indices_vec, int64_t start,\n      int64_t num, Eigen::TensorChippingOp<0, typename TTypes<Tin>::Matrix> out,\n      Eigen::TensorChippingOp<0, typename TTypes<float>::Matrix> temp) {\n    return ReduceImpl<Tin, Tindex, Tin>(input_flat, indices_vec, start, num,\n                                        out, get_scaling_factor<Tin>(num));\n  }\n\n  template <typename Tin, typename Tindex, EnableIfBfloat16OrHalf<Tin> = 0>\n  int64_t Reduce(\n      const typename TTypes<Tin>::ConstMatrix& input_flat,\n      const typename TTypes<Tindex>::ConstVec& indices_vec, int64_t start,\n      int64_t num, Eigen::TensorChippingOp<0, typename TTypes<Tin>::Matrix> out,\n      Eigen::TensorChippingOp<0, typename TTypes<float>::Matrix> temp) {\n    int64_t res =\n        ReduceImpl<Tin, Tindex, float>(input_flat, indices_vec, start, num,\n                                       temp, get_scaling_factor<float>(num));\n    out = temp.template cast<Tin>();\n    return res;\n  }\n\n  template <typename Tin, typename Tindex, typename Tout>\n  int64_t ReduceImpl(\n      const typename TTypes<Tin>::ConstMatrix& input_flat,\n      const typename TTypes<Tindex>::ConstVec& indices_vec, int64_t start,\n      int64_t num,\n      Eigen::TensorChippingOp<0, typename TTypes<Tout>::Matrix> out,\n      const Tout scaling_factor) {\n#define INDEX(n, i)                               \\\n  const auto index##n = indices_vec(start + (i)); \\\n  if (!FastBoundsCheck(index##n, input_flat.dimension(0))) return (i);\n\n#define L(n) fetch_val<Tin, Tindex>(input_flat, index##n)\n\n    if (num == 1) {\n      INDEX(0, 0);\n      out = L(0);\n    } else {\n      int64_t r = num & 7;\n      switch (r) {\n        case 2: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          out = (L(0) + L(1)) * scaling_factor;\n          break;\n        }\n        case 3: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          out = (L(0) + L(1) + L(2)) * scaling_factor;\n          break;\n        }\n        case 4: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          out = (L(0) + L(1) + L(2) + L(3)) * scaling_factor;\n          break;\n        }\n        case 5: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4)) * scaling_factor;\n          break;\n        }\n        case 6: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5)) * scaling_factor;\n          break;\n        }\n        case 7: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          INDEX(6, 6);\n          out =\n              (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6)) * scaling_factor;\n          break;\n        }\n        case 0: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          INDEX(6, 6);\n          INDEX(7, 7);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7)) *\n                scaling_factor;\n          r = 8;\n          break;\n        }\n        case 1: {\n          INDEX(0, 0);\n          INDEX(1, 1);\n          INDEX(2, 2);\n          INDEX(3, 3);\n          INDEX(4, 4);\n          INDEX(5, 5);\n          INDEX(6, 6);\n          INDEX(7, 7);\n          INDEX(8, 8);\n          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7) + L(8)) *\n                scaling_factor;\n          r = 9;\n          break;\n        }\n      }\n      for (; r < num; r += 8) {\n        INDEX(0, r);\n        INDEX(1, r + 1);\n        INDEX(2, r + 2);\n        INDEX(3, r + 3);\n        INDEX(4, r + 4);\n        INDEX(5, r + 5);\n        INDEX(6, r + 6);\n        INDEX(7, r + 7);\n        out += L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7);\n      }\n      if (is_mean_ && num >= 10) {\n        out = out / static_cast<Tout>(num);\n      }\n      if (is_sqrtn_ && num >= 10) {\n        out = out / static_cast<Tout>(sqrt(num));\n      }\n    }\n\n    return -1;\n#undef L\n#undef INDEX\n  }\n\n  const bool is_mean_;\n  const bool is_sqrtn_;\n  const bool has_num_segments_;\n  const T default_value_;\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// Specialization for GPU. Must be Async because may need to wait for a host to\n// device memcpy before allocating output.\ntemplate <class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionOpBase<GPUDevice, T, Index, SegmentId>\n    : public AsyncOpKernel {\n public:\n  explicit SparseSegmentReductionOpBase(OpKernelConstruction* context,\n                                        bool is_mean, bool is_sqrtn,\n                                        bool has_num_segments, T default_value)\n      : AsyncOpKernel(context),\n        is_mean_(is_mean),\n        is_sqrtn_(is_sqrtn),\n        has_num_segments_(has_num_segments),\n        default_value_(default_value) {}\n\n  void ComputeAsync(OpKernelContext* context, DoneCallback done) override {\n    const Tensor& input = context->input(0);\n    const Tensor& indices = context->input(1);\n    const Tensor& segment_ids = context->input(2);\n\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        internal::ValidateSparseSegmentReduction(\n            context, input, indices, segment_ids, has_num_segments_),\n        done);\n\n    ScratchSpace<SegmentId> last_segment_id_host(context, 1, /*on_host=*/true);\n\n    auto create_and_check_output = [this, context, input, indices, segment_ids,\n                                    last_segment_id_host, done]() {\n      // Ensure that within the callback, the proper GPU settings are\n      // configured.\n      auto stream = context->op_device_context()->stream();\n      ScopedActivateExecutorContext scoped_activation{stream->parent()};\n\n      SegmentId last_segment_id = *last_segment_id_host.data();\n      SegmentId output_rows = last_segment_id + 1;\n      OP_REQUIRES_ASYNC(context, output_rows > 0,\n                        errors::InvalidArgument(\"segment ids must be >= 0\"),\n                        done);\n\n      TensorShape output_shape = input.shape();\n      output_shape.set_dim(0, output_rows);\n\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          context, context->allocate_output(0, output_shape, &output), done);\n\n      auto input_flat = input.flat_outer_dims<T>();\n      const auto indices_vec = indices.vec<Index>();\n      const auto segment_ids_vec = segment_ids.vec<SegmentId>();\n      auto output_flat = output->flat_outer_dims<T>();\n\n      functor::SparseSegmentReductionFunctor<T, Index, SegmentId> functor;\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          functor(context, is_mean_, is_sqrtn_, default_value_, input_flat,\n                  indices_vec, segment_ids_vec, output_flat),\n          done);\n      done();\n    };\n\n    if (has_num_segments_) {\n      // No need to do any device to host memcpy, just compute synchronously.\n      const Tensor& num_segments_t = context->input(3);\n      SegmentId num_segments =\n          internal::SubtleMustCopy(num_segments_t.dtype() == DT_INT32\n                                       ? num_segments_t.scalar<int32>()()\n                                       : num_segments_t.scalar<int64_t>()());\n      *last_segment_id_host.mutable_data() = num_segments - 1;\n      create_and_check_output();\n    } else {\n      const int64_t num_indices = indices.NumElements();\n      // Need to copy last element of segment_ids from device to host, and then\n      // asynchronously allocate the output and finish the computation.\n      se::DeviceMemoryBase last_segment_id_device(\n          const_cast<Tensor&>(segment_ids).template flat<SegmentId>().data() +\n          (num_indices - 1));\n      auto stream = context->op_device_context()->stream();\n      OP_REQUIRES_ASYNC(\n          context,\n          stream\n              ->ThenMemcpy(last_segment_id_host.mutable_data(),\n                           last_segment_id_device, sizeof(SegmentId))\n              .ok(),\n          errors::Internal(type_string() +\n                           \": failed to copy last_segment_id from device\"),\n          done);\n      context->device()->tensorflow_gpu_device_info()->event_mgr->ThenExecute(\n          stream, create_and_check_output);\n    }\n  }\n\n private:\n  const bool is_mean_;\n  const bool is_sqrtn_;\n  const bool has_num_segments_;\n  const T default_value_;\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionMeanOp\n    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentReductionMeanOp(OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(\n            context, true /*is_mean*/, false /*is_sqrtn*/,\n            false /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionMeanWithNumSegmentsOp\n    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentReductionMeanWithNumSegmentsOp(\n      OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(\n            context, true /*is_mean*/, false /*is_sqrtn*/,\n            true /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionSqrtNOp\n    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentReductionSqrtNOp(OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(\n            context, false /*is_mean*/, true /*is_sqrtn*/,\n            false /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionSqrtNWithNumSegmentsOp\n    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentReductionSqrtNWithNumSegmentsOp(\n      OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(\n            context, false /*is_mean*/, true /*is_sqrtn*/,\n            true /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionSumOp\n    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentReductionSumOp(OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(\n            context, false /*is_mean*/, false /*is_sqrtn*/,\n            false /* has_num_segments */, T(0) /* default_value */) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentReductionSumWithNumSegmentsOp\n    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentReductionSumWithNumSegmentsOp(\n      OpKernelConstruction* context)\n      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(\n            context, false /*is_mean*/, false /*is_sqrtn*/,\n            true /* has_num_segments */, T(0) /* default_value */) {}\n};\n\nnamespace functor {\n\ntemplate <typename T, typename Index, typename SegmentId>\nstruct SparseSegmentGradFunctor<CPUDevice, T, Index, SegmentId> {\n  void operator()(OpKernelContext* context,\n                  SparseSegmentReductionOperation operation,\n                  typename TTypes<T>::ConstMatrix input_flat,\n                  typename TTypes<Index>::ConstVec indices_vec,\n                  typename TTypes<SegmentId>::ConstVec segment_vec,\n                  typename TTypes<T>::Matrix output_flat) {\n    const int64_t N = indices_vec.size();\n    const SegmentId M = output_flat.dimension(0);\n\n    // Note that similar to SparseSegmentMean, we assume that segment_vec is\n    // already sorted and has non-negative values.\n    const SegmentId num_segments = input_flat.dimension(0);\n    const SegmentId last_segment_id_plus_one =\n        internal::SubtleMustCopy(segment_vec(N - 1)) + 1;\n    OP_REQUIRES(context, last_segment_id_plus_one <= num_segments,\n                errors::InvalidArgument(\"Invalid number of segments\"));\n\n    // Compute scaling factors for input.\n    std::vector<double> scaling(\n        (operation == SparseSegmentReductionOperation::kSum ? 0 : num_segments),\n        0.0);\n    if (operation != SparseSegmentReductionOperation::kSum) {\n      for (int64_t i = 0; i < N; ++i) {\n        const SegmentId idx = internal::SubtleMustCopy(segment_vec(i));\n        OP_REQUIRES(\n            context, FastBoundsCheck(idx, num_segments),\n            errors::InvalidArgument(\"Segment id \", idx, \" out of range [0, \",\n                                    num_segments, \").\"));\n        scaling[idx] += 1;\n      }\n      for (size_t i = 0; i < scaling.size(); ++i) {\n        switch (operation) {\n          case SparseSegmentReductionOperation::kSum: {\n            OP_REQUIRES(\n                context, false,\n                errors::Internal(\n                    \"Should not happen: sum inside SparseSegmentReductionOp \"\n                    \"scaling generation.\"));\n          }\n          case SparseSegmentReductionOperation::kMean: {\n            scaling[i] = 1.0 / std::max(scaling[i], 1.0);\n            break;\n          }\n          case SparseSegmentReductionOperation::kSqrtN: {\n            scaling[i] = 1.0 / sqrt(std::max(scaling[i], 1.0));\n            break;\n          }\n            // No default to get compiler warnings for missing cases.\n        }\n      }\n    }\n\n    output_flat.setZero();\n    std::vector<bool> is_modified(M, false);\n\n    for (int64_t i = 0; i < N; ++i) {\n      const Index output_idx = internal::SubtleMustCopy(indices_vec(i));\n      OP_REQUIRES(context, FastBoundsCheck(output_idx, M),\n                  errors::InvalidArgument(\"Index \", output_idx,\n                                          \" out of range [0, \", M, \").\"));\n\n      const SegmentId idx = internal::SubtleMustCopy(segment_vec(i));\n      OP_REQUIRES(\n          context, FastBoundsCheck(idx, num_segments),\n          errors::InvalidArgument(\"Segment id \", idx, \" out of range [0, \",\n                                  num_segments, \").\"));\n\n      const T scale = (operation == SparseSegmentReductionOperation::kSum\n                           ? static_cast<T>(1)\n                           : static_cast<T>(scaling[idx]));\n      if (is_modified[output_idx]) {\n        if (scale == 1.0) {\n          output_flat.template chip<0>(output_idx) +=\n              input_flat.template chip<0>(idx);\n        } else {\n          output_flat.template chip<0>(output_idx) +=\n              input_flat.template chip<0>(idx) * scale;\n        }\n      } else {\n        if (scale == 1.0) {\n          output_flat.template chip<0>(output_idx) =\n              input_flat.template chip<0>(idx);\n        } else {\n          output_flat.template chip<0>(output_idx) =\n              input_flat.template chip<0>(idx) * scale;\n        }\n      }\n      is_modified[output_idx] = true;\n    }\n  }\n};\n\n}  // namespace functor\n\n// Implements the common logic for the gradients of SparseSegmentReduction\n// kernels.\n//\n// The template parameters are:\n// * Device: An Eigen device object, on which the kernel will execute.\n// * T: The value type.\n// * Index: The element type of the indices tensor (int32 or int64).\n// * SegmentId: The element type of the segment_ids tensor (int32 or int64).\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentGradOpBase : public OpKernel {\n public:\n  explicit SparseSegmentGradOpBase(OpKernelConstruction* context,\n                                   SparseSegmentReductionOperation operation)\n      : OpKernel(context), operation_(operation) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& indices = context->input(1);\n    const Tensor& segment_ids = context->input(2);\n    const Tensor& output_dim0 = context->input(3);\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(indices.shape()),\n                errors::InvalidArgument(\"indices should be a vector.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(segment_ids.shape()),\n                errors::InvalidArgument(\"segment_ids should be a vector.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(output_dim0.shape()),\n                errors::InvalidArgument(\"output_dim0 should be a scalar.\"));\n\n    const int64_t N = indices.NumElements();\n    OP_REQUIRES(context, N == segment_ids.NumElements(),\n                errors::InvalidArgument(\n                    \"segment_ids and indices should have same size.\"));\n    const SegmentId M = internal::SubtleMustCopy(output_dim0.scalar<int32>()());\n\n    auto input_flat = input.flat_outer_dims<T>();\n    const auto indices_vec = indices.vec<Index>();\n    const auto segment_vec = segment_ids.vec<SegmentId>();\n\n    TensorShape output_shape = input.shape();\n    output_shape.set_dim(0, M);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    if (M == 0 || N == 0) return;\n\n    auto output_flat = output->flat_outer_dims<T>();\n    functor::SparseSegmentGradFunctor<Device, T, Index, SegmentId>()(\n        context, operation_, input_flat, indices_vec, segment_vec, output_flat);\n  }\n\n private:\n  const SparseSegmentReductionOperation operation_;\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentSumGradOp\n    : public SparseSegmentGradOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentSumGradOp(OpKernelConstruction* context)\n      : SparseSegmentGradOpBase<Device, T, Index, SegmentId>(\n            context, SparseSegmentReductionOperation::kSum) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentMeanGradOp\n    : public SparseSegmentGradOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentMeanGradOp(OpKernelConstruction* context)\n      : SparseSegmentGradOpBase<Device, T, Index, SegmentId>(\n            context, SparseSegmentReductionOperation::kMean) {}\n};\n\ntemplate <typename Device, class T, typename Index, typename SegmentId>\nclass SparseSegmentSqrtNGradOp\n    : public SparseSegmentGradOpBase<Device, T, Index, SegmentId> {\n public:\n  explicit SparseSegmentSqrtNGradOp(OpKernelConstruction* context)\n      : SparseSegmentGradOpBase<Device, T, Index, SegmentId>(\n            context, SparseSegmentReductionOperation::kSqrtN) {}\n};\n\n}  // namespace tensorflow\n\n#endif  // TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_IMPL_H_\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functional tests for segment reduction ops.\"\"\"\n\nimport itertools\n\nimport numpy as np\n\nfrom tensorflow.python.client import session\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes as dtypes_lib\nfrom tensorflow.python.framework import errors_impl\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import gradient_checker\nfrom tensorflow.python.ops import gradient_checker_v2\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\n\n\nclass SegmentReductionHelper(test.TestCase):\n\n  def _input(self, input_shape, dtype=dtypes_lib.int32):\n    num_elem = 1\n    for x in input_shape:\n      num_elem *= x\n    values = np.arange(1, num_elem + 1)\n    np_values = values.reshape(input_shape).astype(dtype.as_numpy_dtype)\n    # Add a non-zero imaginary component to complex types.\n    if dtype.is_complex:\n      np_values -= 1j * np_values\n    return constant_op.constant(\n        np_values, shape=input_shape, dtype=dtype), np_values\n\n  def _segmentReduce(self, indices, x, op1, op2=None, num_segments=None,\n                     initial_value=0):\n    if not x.size:\n      return np.array([])\n    indices = np.asarray(indices)\n    if num_segments is None:\n      num_segments = indices[-1] + 1\n    output = [None] * num_segments\n    slice_shape = x.shape[indices.ndim:]\n    x_flat = x.reshape((indices.size,) + slice_shape)\n    for i, index in enumerate(indices.ravel()):\n      if (output[index] is not None) and op1 == np.max:\n        for j in range(0, output[index].shape[0]):\n          output[index][j] = op1([output[index][j], x_flat[i][j]])\n      elif output[index] is not None:\n        output[index] = op1(output[index], x_flat[i])\n      else:\n        output[index] = x_flat[i]\n    # zero initialize values that are still uncalculated.\n    initial_value_slice = np.ones(slice_shape) * initial_value\n    output = [o if o is not None else initial_value_slice for o in output]\n    if op2 is not None:\n      output = [op2(o) for o in output]\n    output = [o.reshape(slice_shape) for o in output]\n    return np.array(output)\n\n  def _mean_cum_op(self, x, y):\n    return (x[0] + y, x[1] + 1) if isinstance(x, tuple) else (x + y, 2)\n\n  def _mean_reduce_op(self, x):\n    return x[0] / x[1] if isinstance(x, tuple) else x\n\n  def _sqrt_n_reduce_op(self, x):\n    return x[0] / np.sqrt(x[1]) if isinstance(x, tuple) else x\n\n\nclass SegmentReductionOpTest(SegmentReductionHelper):\n\n  def testValues(self):\n    dtypes = [\n        dtypes_lib.float32, dtypes_lib.float64, dtypes_lib.int64,\n        dtypes_lib.int32, dtypes_lib.complex64, dtypes_lib.complex128\n    ]\n\n    # Each item is np_op1, np_op2, tf_op\n    ops_list = [(np.add, None, math_ops.segment_sum),\n                (self._mean_cum_op, self._mean_reduce_op,\n                 math_ops.segment_mean),\n                (np.ndarray.__mul__, None, math_ops.segment_prod),\n                (np.minimum, None, math_ops.segment_min),\n                (np.maximum, None, math_ops.segment_max)]\n\n    # A subset of ops has been enabled for complex numbers\n    complex_ops_list = [(np.add, None, math_ops.segment_sum),\n                        (np.ndarray.__mul__, None, math_ops.segment_prod),\n                        (self._mean_cum_op, self._mean_reduce_op,\n                         math_ops.segment_mean)]\n\n    n = 10\n    # Note that the GPU implem has different paths for different inner sizes.\n    for shape in [[n, 1], [n, 2], [n, 3], [n, 32]]:\n      indices = [i // 3 for i in range(n)]\n      for dtype in dtypes:\n        if dtype in (dtypes_lib.complex64, dtypes_lib.complex128):\n          curr_ops_list = complex_ops_list\n        else:\n          curr_ops_list = ops_list\n        for use_gpu in [True, False]:\n          with self.cached_session(use_gpu=use_gpu):\n            tf_x, np_x = self._input(shape, dtype=dtype)\n            for np_op1, np_op2, tf_op in curr_ops_list:\n              initial_value = 1 if tf_op is math_ops.segment_prod else 0\n              np_ans = self._segmentReduce(\n                  indices, np_x, np_op1, np_op2, initial_value=initial_value)\n              s = tf_op(data=tf_x, segment_ids=indices)\n              tf_ans = self.evaluate(s)\n              self.assertAllClose(np_ans, tf_ans)\n              # NOTE(mrry): The static shape inference that computes\n              # `tf_ans.shape` can only infer that sizes from dimension 1\n              # onwards, because the size of dimension 0 is data-dependent\n              # and may therefore vary dynamically.\n              self.assertAllEqual(np_ans.shape[1:], tf_ans.shape[1:])\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsShape(self):\n    shape = [4, 4]\n    tf_x, _ = self._input(shape)\n    indices = constant_op.constant([0, 1, 2, 2], shape=[2, 2])\n    with self.assertRaises(ValueError):\n      math_ops.segment_sum(data=tf_x, segment_ids=indices)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsSize(self):\n    shape = [4, 4]\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        tf_x, _ = self._input(shape)\n        indices = [0, 1]\n        s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n        with self.assertRaisesOpError(\"segment_ids should be the same size\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsValid(self):\n    # This is a baseline for the following SegmentIdsInvalid* tests.\n    shape = [4, 4]\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        tf_x, _ = self._input(shape, dtype=dtypes_lib.float32)\n        indices = [0, 0, 0, 1]\n        result = math_ops.segment_sum(data=tf_x, segment_ids=indices).eval()\n        self.assertAllEqual([[15, 18, 21, 24], [13, 14, 15, 16]], result)\n\n  def testSegmentIdsGreaterThanZero(self):\n    shape = [4, 4]\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        tf_x, np_x = self._input(shape, dtype=dtypes_lib.float32)\n        indices = [1, 1, 2, 2]\n        np_ans = self._segmentReduce(indices, np_x, np.add)\n        s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n        tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n\n  def testSegmentIdsHole(self):\n    shape = [4, 4]\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        tf_x, np_x = self._input(shape, dtype=dtypes_lib.float32)\n        indices = [0, 0, 3, 3]\n        np_ans = self._segmentReduce(indices, np_x, np.add)\n        s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n        tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsInvalid1(self):\n    shape = [4, 4]\n    with self.cached_session():\n      tf_x, _ = self._input(shape)\n      indices = [-1, -1, 0, 0]\n      s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n      with self.assertRaisesOpError(\n          r\"Segment id -1 out of range \\[0, 1\\), possibly because \"\n          \"'segment_ids' input is not sorted.\"):\n        self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsInvalid2(self):\n    shape = [4, 4]\n    with self.cached_session():\n      tf_x, _ = self._input(shape)\n      indices = [0, 1, 0, 1]\n      s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n      with self.assertRaisesOpError(\"segment ids are not increasing\"):\n        self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsInvalid3(self):\n    shape = [4, 4]\n    with self.cached_session():\n      tf_x, _ = self._input(shape)\n      indices = [0, 1, 2, 0]\n      s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n      with self.assertRaisesOpError(\n          r\"Segment id 1 out of range \\[0, 1\\), possibly \"\n          \"because 'segment_ids' input is not sorted.\"):\n        self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsInvalid4(self):\n    shape = [4, 4]\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        tf_x, _ = self._input(shape, dtype=dtypes_lib.float32)\n        indices = [0, 0, 0, -1]\n        s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n        with self.assertRaisesOpError(\"segment ids must be >= 0\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentIdsInvalid5(self):\n    shape = [4, 4]\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        tf_x, _ = self._input(shape, dtype=dtypes_lib.float32)\n        indices = [0, 0, 0, -2]\n        s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n        with self.assertRaisesOpError(\"segment ids must be >= 0\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradient(self):\n    shape = [4, 4]\n    indices = [0, 1, 2, 2]\n    for tf_op in [\n        math_ops.segment_sum, math_ops.segment_mean, math_ops.segment_min,\n        math_ops.segment_max\n    ]:\n      with self.cached_session():\n        tf_x, np_x = self._input(shape, dtype=dtypes_lib.float64)\n        s = tf_op(data=tf_x, segment_ids=indices)\n        jacob_t, jacob_n = gradient_checker.compute_gradient(\n            tf_x,\n            shape,\n            s, [3, 4],\n            x_init_value=np_x.astype(np.double),\n            delta=1)\n      self.assertAllClose(jacob_t, jacob_n)\n\n  def testDataInvalid(self):\n    # Test case for GitHub issue 40653.\n    for use_gpu in [True, False]:\n      with self.cached_session(use_gpu=use_gpu):\n        with self.assertRaisesRegex(\n            (ValueError, errors_impl.InvalidArgumentError),\n            \"must be at least rank 1\"):\n          s = math_ops.segment_mean(\n              data=np.uint16(10), segment_ids=np.array([]).astype(\"int64\"))\n          self.evaluate(s)\n\n  def testInvalidIds(self):\n    # Test case for GitHub issue 46888.\n    for op in [\n        math_ops.segment_max,\n        math_ops.segment_min,\n        math_ops.segment_mean,\n        math_ops.segment_sum,\n        math_ops.segment_prod,\n    ]:\n      with self.cached_session(use_gpu=False):\n        with self.assertRaises((ValueError, errors_impl.InternalError)):\n          s = op(data=np.ones((1, 10, 1)), segment_ids=[1676240524292489355])\n          self.evaluate(s)\n\n\nclass UnsortedSegmentTest(SegmentReductionHelper):\n\n  def __init__(self, methodName='runTest'):\n    # Each item is np_op1, np_op2, tf_op, initial_value functor\n    self.ops_list = [(np.add, None,\n                      math_ops.unsorted_segment_sum, lambda t: 0),\n                     (self._mean_cum_op, self._mean_reduce_op,\n                      math_ops.unsorted_segment_mean, lambda t: 0),\n                     (self._mean_cum_op, self._sqrt_n_reduce_op,\n                      math_ops.unsorted_segment_sqrt_n, lambda t: 0),\n                     (np.ndarray.__mul__, None,\n                      math_ops.unsorted_segment_prod, lambda t: 1),\n                     (np.minimum, None,\n                      math_ops.unsorted_segment_min, lambda t: t.max),\n                     (np.maximum, None,\n                      math_ops.unsorted_segment_max, lambda t: t.min)]\n\n    # A subset of ops has been enabled for complex numbers\n    self.complex_ops_list = [(np.add, None,\n                              math_ops.unsorted_segment_sum, lambda t: 0),\n                             (np.ndarray.__mul__, None,\n                              math_ops.unsorted_segment_prod, lambda t: 1)]\n    self.differentiable_dtypes = [dtypes_lib.float16, dtypes_lib.float32,\n                                  dtypes_lib.float64]\n    self.all_dtypes = (self.differentiable_dtypes +\n                       [dtypes_lib.bfloat16,\n                        dtypes_lib.int64, dtypes_lib.int32,\n                        dtypes_lib.complex64, dtypes_lib.complex128])\n    super(UnsortedSegmentTest, self).__init__(methodName=methodName)\n\n  def testValues(self):\n    indices_flat = np.array([0, 4, 0, 8, 3, 8, 4, 7, 7, 3])\n    num_segments = 12\n    for indices in indices_flat, indices_flat.reshape(5, 2):\n      # Note that the GPU implem has different paths for different inner sizes.\n      for inner_size in [1, 2, 3, 32]:\n        shape = indices.shape + (inner_size,)\n        for dtype in self.all_dtypes:\n          ops_list = (\n              self.complex_ops_list if dtype.is_complex else self.ops_list)\n          tf_x, np_x = self._input(shape, dtype=dtype)\n          for use_gpu in [True, False]:\n            with self.cached_session():\n              for np_op1, np_op2, tf_op, init_op in ops_list:\n                # sqrt_n doesn't support integers\n                if (np_op2 == self._sqrt_n_reduce_op and dtype.is_integer):\n                  continue\n                # todo(philjd): enable this test once real_div supports bfloat16\n                if (np_op2 in [self._sqrt_n_reduce_op, self._mean_reduce_op] and\n                    dtype == dtypes_lib.bfloat16):\n                  continue\n                np_ans = self._segmentReduce(\n                    indices,\n                    np_x,\n                    np_op1,\n                    np_op2,\n                    num_segments=num_segments,\n                    initial_value=init_op(dtype))\n                s = tf_op(tf_x, segment_ids=indices, num_segments=num_segments)\n                tf_ans = self.evaluate(s)\n                if dtype is dtypes_lib.bfloat16:\n                  tf_ans = tf_ans.astype(np.float32)\n                self.assertAllCloseAccordingToType(np_ans, tf_ans)\n                self.assertShapeEqual(np_ans, s)\n\n  def testNumSegmentsTypes(self):\n    dtypes = [dtypes_lib.int32, dtypes_lib.int64]\n    indices_flat = np.array([0, 4, 0, 8, 3, 8, 4, 7, 7, 3])\n    num_segments = 12\n    for indices in indices_flat, indices_flat.reshape(5, 2):\n      shape = indices.shape + (2,)\n      for dtype in dtypes:\n        with self.cached_session():\n          tf_x, np_x = self._input(shape)\n          num_segments_constant = constant_op.constant(\n              num_segments, dtype=dtype)\n          np_ans = self._segmentReduce(\n              indices, np_x, np.add, op2=None, num_segments=num_segments)\n          s = math_ops.unsorted_segment_sum(\n              data=tf_x,\n              segment_ids=indices,\n              num_segments=num_segments_constant)\n          tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n        self.assertShapeEqual(np_ans, s)\n\n  @test_util.run_deprecated_v1\n  def testGradientsTFGradients(self):\n    num_cols = 2\n    indices_flat = np.array([0, 4, 0, -1, 3, -1, 4, 7, 7, 3])\n    num_segments = max(indices_flat) + 3\n    for dtype in self.differentiable_dtypes:\n      ops_list = self.complex_ops_list if dtype.is_complex else self.ops_list\n      for indices in indices_flat, indices_flat.reshape(5, 2):\n        shape = indices.shape + (num_cols,)\n        # test CPU and GPU as tf.gather behaves differently on each device\n        for use_gpu in [False, True]:\n          with self.cached_session(use_gpu=use_gpu):\n            for _, _, tf_op, _ in ops_list:\n              tf_x, np_x = self._input(shape, dtype=dtype)\n              s = tf_op(tf_x, indices, num_segments)\n              jacob_t, jacob_n = gradient_checker.compute_gradient(\n                  tf_x,\n                  shape,\n                  s, [num_segments, num_cols],\n                  x_init_value=np_x,\n                  delta=1.)\n              self.assertAllCloseAccordingToType(jacob_t, jacob_n,\n                                                 half_atol=1e-2)\n\n  @test_util.run_in_graph_and_eager_modes\n  def testGradientsGradientTape(self):\n    num_cols = 2\n    indices_flat = np.array([0, 4, 0, -1, 3, -1, 4, 7, 7, 3])\n    num_segments = max(indices_flat) + 3\n    for dtype in self.differentiable_dtypes:\n      ops_list = self.complex_ops_list if dtype.is_complex else self.ops_list\n      for indices in indices_flat, indices_flat.reshape(5, 2):\n        shape = indices.shape + (num_cols,)\n        # test CPU and GPU as tf.gather behaves differently on each device\n        for use_gpu in [test_util.use_gpu, test_util.force_cpu]:\n          with use_gpu():\n            for _, _, tf_op, _ in ops_list:\n              _, np_x = self._input(shape, dtype=dtype)\n              # pylint: disable=cell-var-from-loop\n              def f(x):\n                return tf_op(x, indices, num_segments)\n              gradient_tape_jacob_t, jacob_n = (\n                  gradient_checker_v2.compute_gradient(\n                      f, [np_x], delta=1.))\n              # pylint: enable=cell-var-from-loop\n              self.assertAllCloseAccordingToType(jacob_n, gradient_tape_jacob_t,\n                                                 half_atol=1e-2)\n\n  @test_util.run_deprecated_v1\n  def testProdGrad(self):\n    # additional test for the prod gradient to ensure correct handling of zeros\n    values = np.array([0, 0, 1, 0, 2, 2, 3, 3, 3], dtype=np.float32)\n    indices = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2], dtype=np.int32)\n    indices_neg = np.array([-1, 0, 0, -1, 1, 1, -1, 2, 2], dtype=np.int32)\n    values_tf = constant_op.constant(values)\n    # ground truth partial derivatives\n    gradients_indices = np.zeros((9, 3), dtype=np.float32)\n    gradients_indices_neg = np.zeros((9, 3), dtype=np.float32)\n    # the derivative w.r.t. to the other segments is zero, so here we only\n    # explicitly set the grad values for the corresponding segment\n    gradients_indices[range(9), indices] = [0, 0, 0, 4, 0, 0, 9, 9, 9]\n    gradients_indices_neg[range(9), indices_neg] = [0, 1, 0, 0, 2, 2, 0, 3, 3]\n    for use_gpu in [False, True]:\n      with self.cached_session(use_gpu=use_gpu):\n        for ind, grad_gt in [(indices, gradients_indices),\n                             (indices_neg, gradients_indices_neg)]:\n          s = math_ops.unsorted_segment_prod(values_tf,\n                                             constant_op.constant(ind), 3)\n          jacob_t, jacob_n = gradient_checker.compute_gradient(\n              values_tf, (9,), s, (3,), x_init_value=values, delta=1)\n          self.assertAllClose(jacob_t, jacob_n)\n          self.assertAllClose(jacob_t, grad_gt)\n\n  @test_util.run_deprecated_v1\n  def testGradientMatchesSegmentSum(self):\n    # Strategy: compute the gradient for UnsortedSegmentSum and SegmentSum\n    # and compare the outputs, which should be identical.\n    # NB: for this test to work, indices must be valid for SegmentSum, namely\n    # it must be sorted, the indices must be contiguous, and num_segments\n    # must be max(indices) + 1.\n    indices = [0, 0, 1, 1, 1, 2, 3, 4, 5]\n    n = len(indices)\n    num_cols = 2\n    shape = [n, num_cols]\n    num_segments = max(indices) + 1\n    for dtype in self.differentiable_dtypes:\n      with self.cached_session():\n        tf_x, np_x = self._input(shape, dtype=dtype)\n        # Results from UnsortedSegmentSum\n        unsorted_s = math_ops.unsorted_segment_sum(\n            data=tf_x, segment_ids=indices, num_segments=num_segments)\n        unsorted_jacob_t, unsorted_jacob_n = (\n            gradient_checker.compute_gradient(tf_x, shape, unsorted_s,\n                                              [num_segments, num_cols],\n                                              x_init_value=np_x, delta=1))\n\n        # Results from SegmentSum\n        sorted_s = math_ops.segment_sum(data=tf_x, segment_ids=indices)\n        sorted_jacob_t, sorted_jacob_n = gradient_checker.compute_gradient(\n            tf_x,\n            shape,\n            sorted_s, [num_segments, num_cols],\n            x_init_value=np_x,\n            delta=1)\n      self.assertAllClose(unsorted_jacob_t, sorted_jacob_t)\n      self.assertAllClose(unsorted_jacob_n, sorted_jacob_n)\n\n  @test_util.run_deprecated_v1\n  def testBadIndices(self):\n    # Note: GPU kernel does not return the out-of-range error needed for this\n    # test, so this test is marked as cpu-only.\n    # Note: With PR #13055 a negative index will be ignored silently.\n    with self.session(use_gpu=False):\n      for bad in [[2]], [[7]]:\n        unsorted = math_ops.unsorted_segment_sum([[17]], bad, num_segments=2)\n        with self.assertRaisesOpError(\n            r\"segment_ids\\[0,0\\] = %d is out of range \\[0, 2\\)\" % bad[0][0]):\n          self.evaluate(unsorted)\n\n  @test_util.run_deprecated_v1\n  def testEmptySecondDimension(self):\n    dtypes = [np.float16, np.float32, np.float64, np.int64, np.int32,\n              np.complex64, np.complex128]\n    with self.session():\n      for dtype in dtypes:\n        for itype in (np.int32, np.int64):\n          data = np.zeros((2, 0), dtype=dtype)\n          segment_ids = np.array([0, 1], dtype=itype)\n          unsorted = math_ops.unsorted_segment_sum(data, segment_ids, 2)\n          self.assertAllEqual(unsorted, np.zeros((2, 0), dtype=dtype))\n\n  def testDropNegatives(self):\n    # Note: the test is done by replacing segment_ids with 8 to -1\n    # for index  and replace values generated by numpy with 0.\n    indices_flat = np.array([0, 4, 0, 8, 3, 8, 4, 7, 7, 3])\n    num_segments = 12\n    for indices in indices_flat, indices_flat.reshape(5, 2):\n      shape = indices.shape + (2,)\n      for dtype in self.all_dtypes:\n        with self.session():\n          tf_x, np_x = self._input(shape, dtype=dtype)\n          np_ans = self._segmentReduce(\n              indices, np_x, np.add, op2=None, num_segments=num_segments)\n          # Replace np_ans[8] with 0 for the value\n          np_ans[8:] = 0\n          # Replace 8 with -1 in indices\n          np.place(indices, indices == 8, [-1])\n          s = math_ops.unsorted_segment_sum(\n              data=tf_x, segment_ids=indices, num_segments=num_segments)\n          tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n        self.assertShapeEqual(np_ans, s)\n\n\nclass SparseSegmentReductionHelper(SegmentReductionHelper):\n\n  def _sparse_input(self, input_shape, num_indices, dtype=dtypes_lib.int32):\n    a, b = super(SparseSegmentReductionHelper, self)._input(input_shape, dtype)\n    indices = np.random.randint(0, input_shape[0], num_indices).astype(np.int32)\n    return (constant_op.constant(\n        indices, dtype=dtypes_lib.int32), indices, a, b)\n\n  def _sparseSegmentReduce(self,\n                           x,\n                           indices,\n                           segment_indices,\n                           op1,\n                           op2=None,\n                           num_segments=None):\n    return self._segmentReduce(\n        segment_indices, x[indices], op1, op2, num_segments=num_segments)\n\n  def _sparseSegmentReduceGrad(self, ygrad, indices, segment_ids, output_dim0,\n                               mode):\n    assert mode in (\"sum\", \"mean\", \"sqrtn\")\n    if mode != \"sum\":\n      weights = np.zeros(ygrad.shape[0], ygrad.dtype)\n      for segment in segment_ids:\n        weights[segment] += 1\n      weights = 1. / weights if mode == \"mean\" else 1. / np.sqrt(weights)\n    xgrad = np.zeros([output_dim0, ygrad.shape[1]], ygrad.dtype)\n    for segment, index in zip(segment_ids, indices):\n      if mode == \"sum\":\n        xgrad[index] += ygrad[segment]\n      else:\n        xgrad[index] += ygrad[segment] * weights[segment]\n    return xgrad\n\n\nclass SparseSegmentReductionOpTest(SparseSegmentReductionHelper):\n\n  def testValues(self):\n    dtypes = [\n        dtypes_lib.float32, dtypes_lib.float64, dtypes_lib.int64,\n        dtypes_lib.int32\n    ]\n\n    index_dtypes = [dtypes_lib.int32, dtypes_lib.int64]\n    segment_ids_dtypes = [dtypes_lib.int32, dtypes_lib.int64]\n\n    mean_dtypes = [dtypes_lib.float32, dtypes_lib.float64]\n\n    # Each item is np_op1, np_op2, tf_op\n    ops_list = [(np.add, None, math_ops.sparse_segment_sum),\n                (self._mean_cum_op, self._mean_reduce_op,\n                 math_ops.sparse_segment_mean)]\n\n    n = 400\n    # Note that the GPU implem has different paths for different inner sizes.\n    for inner_size in [1, 2, 3, 32]:\n      shape = [n, inner_size]\n      segment_indices = []\n      for i in range(20):\n        for _ in range(i + 1):\n          segment_indices.append(i)\n      num_indices = len(segment_indices)\n      for dtype in dtypes:\n        for index_dtype in index_dtypes:\n          for segment_ids_dtype in segment_ids_dtypes:\n            with self.cached_session():\n              tf_indices, np_indices, tf_x, np_x = self._sparse_input(\n                  shape, num_indices, dtype=dtype)\n              for np_op1, np_op2, tf_op in ops_list:\n                if (tf_op == math_ops.sparse_segment_mean and\n                    dtype not in mean_dtypes):\n                  continue\n                np_ans = self._sparseSegmentReduce(np_x, np_indices,\n                                                   segment_indices, np_op1,\n                                                   np_op2)\n                s = tf_op(\n                    data=tf_x,\n                    indices=math_ops.cast(tf_indices, index_dtype),\n                    segment_ids=math_ops.cast(segment_indices,\n                                              segment_ids_dtype))\n                tf_ans = self.evaluate(s)\n                self.assertAllClose(np_ans, tf_ans)\n                # NOTE(mrry): The static shape inference that computes\n                # `tf_ans.shape` can only infer that sizes from dimension 1\n                # onwards, because the size of dimension 0 is data-dependent\n                # and may therefore vary dynamically.\n                self.assertAllEqual(np_ans.shape[1:], tf_ans.shape[1:])\n\n  def testSegmentIdsHole(self):\n    tf_x, np_x = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [(np.add, None, math_ops.sparse_segment_sum), (\n        self._mean_cum_op, self._mean_reduce_op, math_ops.sparse_segment_mean)]\n    segment_indices = [0, 2, 2, 2]\n    tf_indices = [8, 3, 0, 9]\n    with self.session():\n      for np_op1, np_op2, tf_op in ops_list:\n        np_ans = self._sparseSegmentReduce(np_x, tf_indices, segment_indices,\n                                           np_op1, np_op2)\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n\n  def testWithNumSegments(self):\n    tf_x, np_x = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [(np.add, None, math_ops.sparse_segment_sum_with_num_segments),\n                (self._mean_cum_op, self._mean_reduce_op,\n                 math_ops.sparse_segment_mean_with_num_segments)]\n    segment_indices = [0, 2, 2, 2]\n    tf_indices = [8, 3, 0, 9]\n    num_segments = 5\n    with self.session():\n      for np_op1, np_op2, tf_op in ops_list:\n        np_ans = self._sparseSegmentReduce(\n            np_x,\n            tf_indices,\n            segment_indices,\n            np_op1,\n            np_op2,\n            num_segments=num_segments)\n        s = tf_op(\n            data=tf_x,\n            indices=tf_indices,\n            segment_ids=segment_indices,\n            num_segments=num_segments)\n        tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n\n  def testWithEmptySegments(self):\n    tf_x = constant_op.constant([], shape=[0, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_with_num_segments,\n        math_ops.sparse_segment_mean_with_num_segments\n    ]\n    segment_indices = []\n    tf_indices = []\n    num_segments = 5\n    with self.session():\n      for tf_op in ops_list:\n        s = tf_op(\n            data=tf_x,\n            indices=tf_indices,\n            segment_ids=segment_indices,\n            num_segments=num_segments)\n        tf_ans = self.evaluate(s)\n        self.assertAllClose(np.zeros([5, 4]), tf_ans)\n\n  @test_util.run_in_graph_and_eager_modes\n  def testSegmentScalarIdiRaisesInvalidArgumentError(self):\n    \"\"\"Test for github #46897.\"\"\"\n    ops_list = [\n        math_ops.sparse_segment_sum,\n        math_ops.sparse_segment_mean,\n        math_ops.sparse_segment_sqrt_n,\n    ]\n    for op in ops_list:\n      with self.assertRaisesRegex(\n          (ValueError, errors_impl.InvalidArgumentError),\n          \"Shape must be at least rank 1\"):\n        op(data=1.0, indices=[0], segment_ids=[3])\n\n  def testSegmentIdsGreaterThanZero(self):\n    tf_x, np_x = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [(np.add, None, math_ops.sparse_segment_sum), (\n        self._mean_cum_op, self._mean_reduce_op, math_ops.sparse_segment_mean)]\n    segment_indices = [1, 2, 2, 2]\n    tf_indices = [8, 3, 0, 9]\n    with self.session():\n      for np_op1, np_op2, tf_op in ops_list:\n        np_ans = self._sparseSegmentReduce(np_x, tf_indices, segment_indices,\n                                           np_op1, np_op2)\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        tf_ans = self.evaluate(s)\n        self.assertAllClose(np_ans, tf_ans)\n\n  def testValid(self):\n    # Baseline for the test*Invalid* methods below.\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 1, 2, 2]\n    tf_indices = [8, 3, 0, 9]\n    with self.session():\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testIndicesInvalid1(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 1, 2, 2]\n    tf_indices = [8, -1, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\n            r\"indices\\[1\\] == -1 out of range \\[0, 10\\)\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testIndicesInvalid2(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 1, 2, 2]\n    tf_indices = [8, 3, 0, 10]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\n            r\"indices\\[3\\] == 10 out of range \\[0, 10\\)\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentsInvalid2(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 1, 0, 1]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\"segment ids are not increasing\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentsInvalid3(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 1, 2, 0]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\n            r\"Segment id 1 out of range \\[0, 1\\), possibly because \"\n            \"'segment_ids' input is not sorted\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentsInvalid4(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [-1, 0, 1, 1]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\n            r\"Segment id -1 out of range \\[0, 2\\), possibly because \"\n            \"'segment_ids' input is not sorted\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentsInvalid6(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 0, 0, -1]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\"segment ids must be >= 0\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentsInvalid7(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]\n    segment_indices = [0, 0, 0, -2]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        with self.assertRaisesOpError(\"segment ids must be >= 0\"):\n          self.evaluate(s)\n\n  def testSegmentWithNumSegmentsValid(self):\n    # Baseline for the test*WithNumSegmentsInvalid* methods below.\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_with_num_segments,\n        math_ops.sparse_segment_mean_with_num_segments,\n    ]\n    num_segments = 5\n    segment_indices = [0, 1, 3, 3]\n    tf_indices = [8, 3, 0, 9]\n    with self.session():\n      for tf_op in ops_list:\n        s = tf_op(\n            data=tf_x,\n            indices=tf_indices,\n            segment_ids=segment_indices,\n            num_segments=num_segments)\n        self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentWithNumSegmentsInvalid1(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_with_num_segments,\n        math_ops.sparse_segment_mean_with_num_segments,\n    ]\n    num_segments = 5\n    segment_indices = [0, 1, 3, 5]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(\n            data=tf_x,\n            indices=tf_indices,\n            segment_ids=segment_indices,\n            num_segments=num_segments)\n        with self.assertRaisesOpError(\"segment ids must be < num_segments\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testSegmentWithNumSegmentsInvalid2(self):\n    tf_x, _ = self._input([10, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_with_num_segments,\n        math_ops.sparse_segment_mean_with_num_segments,\n    ]\n    num_segments = -2\n    segment_indices = [0, 1, 3, 3]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        with self.assertRaisesRegex(\n            ValueError, \"Cannot specify a negative value for num_segments\"):\n          tf_op(\n              data=tf_x,\n              indices=tf_indices,\n              segment_ids=segment_indices,\n              num_segments=num_segments)\n\n  @test_util.run_deprecated_v1\n  def testGradient(self):\n    shape = [10, 4]\n\n    segment_indices = [0, 1, 2, 2]\n    num_indices = len(segment_indices)\n    for tf_op in [math_ops.sparse_segment_sum, math_ops.sparse_segment_mean]:\n      with self.cached_session():\n        tf_indices, _, tf_x, np_x = self._sparse_input(\n            shape, num_indices, dtype=dtypes_lib.float64)\n        s = tf_op(data=tf_x, indices=tf_indices, segment_ids=segment_indices)\n        jacob_t, jacob_n = gradient_checker.compute_gradient(\n            tf_x,\n            shape,\n            s, [3, 4],\n            x_init_value=np_x.astype(np.double),\n            delta=1)\n      self.assertAllClose(jacob_t, jacob_n)\n\n  @test_util.run_deprecated_v1\n  def testGradientWithEmptySegmentsAtEnd(self):\n    shape = [10, 4]\n\n    num_segments = 5\n    segment_indices = [0, 1, 2, 2]\n    num_indices = len(segment_indices)\n    for tf_op in [\n        math_ops.sparse_segment_sum_with_num_segments,\n        math_ops.sparse_segment_mean_with_num_segments,\n    ]:\n      with self.cached_session():\n        tf_indices, _, tf_x, np_x = self._sparse_input(\n            shape, num_indices, dtype=dtypes_lib.float64)\n        s = tf_op(\n            data=tf_x,\n            indices=tf_indices,\n            segment_ids=segment_indices,\n            num_segments=num_segments)\n        jacob_t, jacob_n = gradient_checker.compute_gradient(\n            tf_x,\n            shape,\n            s, [5, 4],\n            x_init_value=np_x.astype(np.double),\n            delta=1)\n      self.assertAllClose(jacob_t, jacob_n)\n\n  def testGradientExplicit(self):\n    # Note that the GPU implem has different paths for different inner sizes.\n    for inner_size in (1, 2, 3, 32):\n      with self.session():\n        tf_ygrad, np_ygrad = self._input([3, inner_size],\n                                         dtype=dtypes_lib.float32)\n        segment_ids = [0, 1, 2, 2, 2]\n        indices = [8, 3, 0, 9, 3]\n        output_dim0 = 10\n        ops_list = [\n            (math_ops.sparse_segment_sum_grad, \"sum\"),\n            (math_ops.sparse_segment_mean_grad, \"mean\"),\n            (math_ops.sparse_segment_sqrt_n_grad, \"sqrtn\"),\n        ]\n        for tf_op, mode in ops_list:\n          np_xgrad = self._sparseSegmentReduceGrad(np_ygrad, indices,\n                                                   segment_ids, output_dim0,\n                                                   mode)\n          tf_xgrad = tf_op(tf_ygrad, indices, segment_ids, output_dim0)\n          self.assertAllClose(tf_xgrad, np_xgrad)\n\n  def testGradientExplicitSingleOutput(self):\n    # The GPU implem has a special case when there is a single output.\n    for inner_size in (1, 2, 3, 32):\n      with self.session():\n        tf_ygrad, np_ygrad = self._input([3, inner_size],\n                                         dtype=dtypes_lib.float32)\n        segment_ids = [0, 1, 2, 2, 2]\n        indices = [0, 0, 0, 0, 0]\n        output_dim0 = 1\n        ops_list = [\n            (math_ops.sparse_segment_sum_grad, \"sum\"),\n            (math_ops.sparse_segment_mean_grad, \"mean\"),\n            (math_ops.sparse_segment_sqrt_n_grad, \"sqrtn\"),\n        ]\n        for tf_op, mode in ops_list:\n          np_xgrad = self._sparseSegmentReduceGrad(np_ygrad, indices,\n                                                   segment_ids, output_dim0,\n                                                   mode)\n          tf_xgrad = tf_op(tf_ygrad, indices, segment_ids, output_dim0)\n          self.assertAllClose(tf_xgrad, np_xgrad)\n\n  def testGradientValid(self):\n    # Baseline for the testGradient*Invalid* methods below.\n    tf_x, _ = self._input([3, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [0, 1, 2, 2]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradientIndicesInvalid1(self):\n    tf_x, _ = self._input([3, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [0, 1, 2, 2]\n    tf_indices = [8, 3, 0, 10]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        with self.assertRaisesOpError(r\"Index 10 out of range \\[0, 10\\)\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradientIndicesInvalid2(self):\n    tf_x, _ = self._input([3, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [0, 1, 2, 2]\n    tf_indices = [8, 3, -1, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        with self.assertRaisesOpError(r\"Index -1 out of range \\[0, 10\\)\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradientSegmentsInvalid1(self):\n    tf_x, _ = self._input(\n        [3, 4], dtype=dtypes_lib.float32)  # expecting 3 segments\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [0, 1, 1, 4]  # 5 segments\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        with self.assertRaisesOpError(\"Invalid number of segments\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradientSegmentsInvalid2(self):\n    tf_x, _ = self._input([1, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [0, 1, 2, 0]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        with self.assertRaisesOpError(r\"Segment id 1 out of range \\[0, 1\\)\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradientSegmentsInvalid3(self):\n    tf_x, _ = self._input([2, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [-1, 0, 1, 1]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        with self.assertRaisesOpError(r\"Segment id -1 out of range \\[0, 2\\)\"):\n          self.evaluate(s)\n\n  @test_util.run_deprecated_v1\n  def testGradientSegmentsInvalid4(self):\n    tf_x, _ = self._input([0, 4], dtype=dtypes_lib.float32)\n    ops_list = [\n        math_ops.sparse_segment_sum_grad, math_ops.sparse_segment_mean_grad,\n        math_ops.sparse_segment_sqrt_n_grad\n    ]\n    segment_indices = [0, 1, 2, -1]\n    tf_indices = [8, 3, 0, 9]\n    with self.session(use_gpu=False):\n      for tf_op in ops_list:\n        s = tf_op(tf_x, tf_indices, segment_indices, 10)\n        with self.assertRaisesOpError(r\"Segment id 0 out of range \\[0, 0\\)\"):\n          self.evaluate(s)\n\n\nclass SegmentReductionOpBenchmark(test.Benchmark):\n  outer_dim_options = [2**x for x in range(9, 14, 2)]\n  ratio_options = [2**x for x in range(1, 6, 2)]\n  inner_dim_options = [2**x for x in range(9, 14, 2)]\n  # randomly generated sizes with less alignments\n  inner_dim_options += [\n      1120, 1215, 1856, 1302, 1329, 1531, 1313, 1672, 1851, 1584\n  ]\n  dtype_options = [np.float32, np.float64]\n  options = (outer_dim_options, ratio_options, inner_dim_options, dtype_options)\n  # pylint: disable=g-long-lambda\n  op_functors = [lambda vc, vs, seg_ids:\n                 (\"sorted\", math_ops.segment_sum(vc, vs)),\n                 lambda vc, vs, seg_ids:\n                 (\"unsorted\",\n                  math_ops.unsorted_segment_sum(vc, vs, seg_ids[-1]+1))]\n  # pylint: enable=g-long-lambda\n  repeat = 10\n\n  def _npTypeToStr(self, t):\n    if t == np.float32:\n      return \"fp32\"\n    if t == np.float64:\n      return \"fp64\"\n\n  def _runGraph(self, op_functor, outer_dim, ratio, inner_dim, dtype):\n    output_outer_dim = int(outer_dim / ratio)\n    const = np.random.randint(5, size=(outer_dim, inner_dim))\n    seg_ids = np.sort(np.random.randint(output_outer_dim, size=outer_dim))\n    vs = variables.Variable(seg_ids.astype(np.int32))\n    with ops.device(\"/gpu:0\"):\n      vc = variables.Variable(const.astype(dtype))\n    name, op = op_functor(vc, vs, seg_ids)\n    with session.Session() as sess:\n      self.evaluate(variables.global_variables_initializer())\n      r = self.run_op_benchmark(\n          sess,\n          op,\n          min_iters=self.repeat,\n          name=\"_\".join(\n              map(str,\n                  [name, outer_dim, ratio, inner_dim,\n                   self._npTypeToStr(dtype)])))\n    return name, r[\"wall_time\"]\n\n  def benchmarkSegmentSumGPU(self):\n    if not test.is_gpu_available(cuda_only=True):\n      return\n    for outer_dim, ratio, inner_dim, dtype in itertools.product(*self.options):\n      op_functor = self.op_functors[0]\n      with ops.Graph().as_default():\n        self._runGraph(op_functor, outer_dim, ratio, inner_dim, dtype)\n\n  def benchmarkUnsortedSegmentSumGPU(self):\n    if not test.is_gpu_available(cuda_only=True):\n      return\n    for outer_dim, ratio, inner_dim, dtype in itertools.product(*self.options):\n      op_functor = self.op_functors[1]\n      with ops.Graph().as_default():\n        self._runGraph(op_functor, outer_dim, ratio, inner_dim, dtype)\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/segment_reduction_ops_impl.h", "tensorflow/python/kernel_tests/segment_reduction_ops_test.py"], "buggy_code_start_loc": [113, 266], "buggy_code_end_loc": [294, 266], "fixing_code_start_loc": [113, 267], "fixing_code_end_loc": [299, 281], "type": "CWE-190", "message": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `tf.math.segment_*` operations results in a `CHECK`-fail related abort (and denial of service) if a segment id in `segment_ids` is large. This is similar to CVE-2021-29584 (and similar other reported vulnerabilities in TensorFlow, localized to specific APIs): the implementation (both on CPU and GPU) computes the output shape using `AddDim`. However, if the number of elements in the tensor overflows an `int64_t` value, `AddDim` results in a `CHECK` failure which provokes a `std::abort`. Instead, code should use `AddDimWithStatus`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-41195", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-05T20:15:07.707", "lastModified": "2021-11-09T13:44:19.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `tf.math.segment_*` operations results in a `CHECK`-fail related abort (and denial of service) if a segment id in `segment_ids` is large. This is similar to CVE-2021-29584 (and similar other reported vulnerabilities in TensorFlow, localized to specific APIs): the implementation (both on CPU and GPU) computes the output shape using `AddDim`. However, if the number of elements in the tensor overflows an `int64_t` value, `AddDim` results in a `CHECK` failure which provokes a `std::abort`. Instead, code should use `AddDimWithStatus`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. En las versiones afectadas, la implementaci\u00f3n de las operaciones \"tf.math.segment_*\" resulta en un aborto relacionado con el fallo \"CHECK\" (y a una denegaci\u00f3n de servicio) si un id de segmento en \"segment_ids\" es grande. Esto es similar a CVE-2021-29584 (y otras vulnerabilidades similares reportadas en TensorFlow, localizadas en APIs espec\u00edficas): la implementaci\u00f3n (tanto en CPU como en GPU) computa la forma de salida usando \"AddDim\". Sin embargo, si el n\u00famero de elementos en el tensor sobrepasa un valor \"int64_t\", \"AddDim\" resulta en un fallo \"CHECK\" que provoca un \"std::abort\". En su lugar, el c\u00f3digo deber\u00eda usar \"AddDimWithStatus\". La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.7.0. Tambi\u00e9n ser\u00e1 incluida este commit en TensorFlow versi\u00f3n 2.6.1, TensorFlow versi\u00f3n 2.5.2, y TensorFlow versi\u00f3n 2.4.4, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.4", "matchCriteriaId": "455FB550-4C9C-4BD6-9F76-A627B62AB332"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.5.0", "versionEndExcluding": "2.5.2", "matchCriteriaId": "035CDF63-1548-4FB4-B8A9-B8D328FAF910"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.0", "versionEndExcluding": "2.6.1", "matchCriteriaId": "5D68D8D1-DB27-4395-9D3D-2BED901B852C"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/e9c81c1e1a9cd8dd31f4e83676cab61b60658429", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/issues/46888", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/pull/51733", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-cq76-mxrc-vchh", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/e9c81c1e1a9cd8dd31f4e83676cab61b60658429"}}