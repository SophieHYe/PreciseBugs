{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#define EIGEN_USE_THREADS\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/kernels/quantization_utils.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\n// A slow but straightforward implementation of batch normalization.\ntemplate <typename T1, typename T2>\nvoid ReferenceBatchNorm(const Tensor& input, const float input_min,\n                        const float input_max, const Tensor& mean,\n                        float mean_min, float mean_max, const Tensor& var,\n                        float var_min, float var_max, const Tensor& beta,\n                        float beta_min, float beta_max, const Tensor& gamma,\n                        float gamma_min, float gamma_max,\n                        float variance_epsilon, bool scale_after_normalization,\n                        Tensor* output, float* output_min, float* output_max) {\n  auto input_flat = input.flat<T1>();\n  auto mean_flat = mean.flat<T1>();\n  auto var_flat = var.flat<T1>();\n  auto beta_flat = beta.flat<T1>();\n  auto gamma_flat = gamma.flat<T1>();\n  auto output_flat = output->flat<T2>();\n\n  const int depth = mean.dim_size(0);\n  const int row_count = input_flat.size() / depth;\n\n  *output_min = std::numeric_limits<float>::max();\n  *output_max = std::numeric_limits<float>::lowest();\n  for (int pass = 0; pass < 2; ++pass) {\n    const bool is_range_pass = (pass == 0);\n    for (int row_index = 0; row_index < row_count; ++row_index) {\n      for (int channel = 0; channel < depth; ++channel) {\n        const int input_index = (row_index * depth) + channel;\n        const float input_value =\n            QuantizedToFloat(input_flat(input_index), input_min, input_max);\n        const float mean_value =\n            QuantizedToFloat(mean_flat(channel), mean_min, mean_max);\n        const float var_value =\n            QuantizedToFloat(var_flat(channel), var_min, var_max);\n        const float beta_value =\n            QuantizedToFloat(beta_flat(channel), beta_min, beta_max);\n        const float gamma_value =\n            QuantizedToFloat(gamma_flat(channel), gamma_min, gamma_max);\n        float output_value;\n        if (scale_after_normalization) {\n          output_value = (((input_value - mean_value) /\n                           sqrtf(var_value + variance_epsilon)) *\n                          gamma_value) +\n                         beta_value;\n        } else {\n          output_value = ((input_value - mean_value) /\n                          sqrtf(var_value + variance_epsilon)) +\n                         beta_value;\n        }\n        if (is_range_pass) {\n          *output_min = std::min(output_value, *output_min);\n          *output_max = std::max(output_value, *output_max);\n        } else {\n          output_flat(input_index) =\n              FloatToQuantized<T2>(output_value, *output_min, *output_max);\n        }\n      }\n    }\n  }\n}\n\n// An implementation of batch normalization that does the main calculations\n// using only fixed-point arithmetic. There's a prologue with some floating\n// calculations, but assuming the weights are constant these could be hoisted to\n// an offline process, or baked into the weights.\ntemplate <typename T1, typename T2>\nvoid FixedPointBatchNorm(const Tensor& input, const float input_min,\n                         const float input_max, const Tensor& mean,\n                         float mean_min, float mean_max, const Tensor& var,\n                         float var_min, float var_max, const Tensor& beta,\n                         float beta_min, float beta_max, const Tensor& gamma,\n                         float gamma_min, float gamma_max,\n                         float variance_epsilon, bool scale_after_normalization,\n                         Tensor* output, float* output_min, float* output_max) {\n  auto input_flat = input.flat<T1>();\n  auto mean_flat = mean.flat<T1>();\n  auto var_flat = var.flat<T1>();\n  auto beta_flat = beta.flat<T1>();\n  auto gamma_flat = gamma.flat<T1>();\n  auto output_flat = output->flat<T2>();\n\n  const int depth = mean.dim_size(0);\n  const int row_count = input_flat.size() / depth;\n\n  // The range here is chosen so that typical input values fit in without any\n  // overflow or loss of precision, going from +1m to -1m with 10 bits of fixed\n  // point precision.\n  *output_min = -(1 << 20);\n  *output_max = (1 << 20);\n\n  Tensor scale_tensor(DataTypeToEnum<T2>::v(), {depth});\n  auto scale_flat = scale_tensor.flat<T2>();\n  Tensor offset_tensor(DataTypeToEnum<T2>::v(), {depth});\n  auto offset_flat = offset_tensor.flat<T2>();\n  for (int channel = 0; channel < depth; ++channel) {\n    const float mean_value =\n        QuantizedToFloat(mean_flat(channel), mean_min, mean_max);\n    const float var_value =\n        QuantizedToFloat(var_flat(channel), var_min, var_max);\n    const float beta_value =\n        QuantizedToFloat(beta_flat(channel), beta_min, beta_max);\n    const float gamma_value =\n        QuantizedToFloat(gamma_flat(channel), gamma_min, gamma_max);\n    float scale_value;\n    if (scale_after_normalization) {\n      scale_value = (1.0f / sqrtf(var_value + variance_epsilon)) * gamma_value;\n    } else {\n      scale_value = (1.0f / sqrtf(var_value + variance_epsilon));\n    }\n    const float offset_value = (-mean_value * scale_value) + beta_value;\n    scale_flat(channel) =\n        FloatToQuantized<T2>(scale_value, *output_min, *output_max);\n    offset_flat(channel) =\n        FloatToQuantized<T2>(offset_value, *output_min, *output_max);\n  }\n\n  const T2 one_in_output_space =\n      FloatToQuantized<T2>(1.0f, *output_min, *output_max);\n  for (int row_index = 0; row_index < row_count; ++row_index) {\n    for (int channel = 0; channel < depth; ++channel) {\n      const int input_index = (row_index * depth) + channel;\n      const T2 input_value =\n          RequantizeInNewRange<T1, T2>(input_flat(input_index), input_min,\n                                       input_max, *output_min, *output_max);\n      const T2 scale_value = scale_flat(channel);\n      const T2 offset_value = offset_flat(channel);\n      const T2 output_value =\n          ((input_value * scale_value) / one_in_output_space) + offset_value;\n      output_flat(input_index) = output_value;\n    }\n  }\n}\n\n}  // namespace\n\ntemplate <typename T1, typename T2>\nclass QuantizedBatchNormOp : public OpKernel {\n public:\n  explicit QuantizedBatchNormOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"variance_epsilon\", &variance_epsilon_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"scale_after_normalization\",\n                                             &scale_after_normalization_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float input_min = context->input(1).flat<float>()(0);\n    const float input_max = context->input(2).flat<float>()(0);\n    const Tensor& mean = context->input(3);\n    const float mean_min = context->input(4).flat<float>()(0);\n    const float mean_max = context->input(5).flat<float>()(0);\n    const Tensor& var = context->input(6);\n    const float var_min = context->input(7).flat<float>()(0);\n    const float var_max = context->input(8).flat<float>()(0);\n    const Tensor& beta = context->input(9);\n    const float beta_min = context->input(10).flat<float>()(0);\n    const float beta_max = context->input(11).flat<float>()(0);\n    const Tensor& gamma = context->input(12);\n    const float gamma_min = context->input(13).flat<float>()(0);\n    const float gamma_max = context->input(14).flat<float>()(0);\n\n    OP_REQUIRES(context, input.dims() == 4,\n                errors::InvalidArgument(\"input must be 4-dimensional\",\n                                        input.shape().DebugString()));\n    OP_REQUIRES(context, mean.dims() == 1,\n                errors::InvalidArgument(\"mean must be 1-dimensional\",\n                                        mean.shape().DebugString()));\n    OP_REQUIRES(context, var.dims() == 1,\n                errors::InvalidArgument(\"var must be 1-dimensional\",\n                                        var.shape().DebugString()));\n    OP_REQUIRES(context, beta.dims() == 1,\n                errors::InvalidArgument(\"beta must be 1-dimensional\",\n                                        beta.shape().DebugString()));\n    OP_REQUIRES(context, gamma.dims() == 1,\n                errors::InvalidArgument(\"gamma must be 1-dimensional\",\n                                        gamma.shape().DebugString()));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    float output_min;\n    float output_max;\n    FixedPointBatchNorm<T1, T2>(input, input_min, input_max, mean, mean_min,\n                                mean_max, var, var_min, var_max, beta, beta_min,\n                                beta_max, gamma, gamma_min, gamma_max,\n                                variance_epsilon_, scale_after_normalization_,\n                                output, &output_min, &output_max);\n\n    Tensor* output_min_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, {}, &output_min_tensor));\n    output_min_tensor->flat<float>()(0) = output_min;\n\n    Tensor* output_max_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, {}, &output_max_tensor));\n    output_max_tensor->flat<float>()(0) = output_max;\n  }\n\n private:\n  float variance_epsilon_;\n  bool scale_after_normalization_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"QuantizedBatchNormWithGlobalNormalization\")\n                            .Device(DEVICE_CPU)\n                            .TypeConstraint<quint8>(\"Tinput\")\n                            .TypeConstraint<qint32>(\"out_type\"),\n                        QuantizedBatchNormOp<quint8, qint32>);\n\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#define EIGEN_USE_THREADS\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/kernels/quantization_utils.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\n// A slow but straightforward implementation of batch normalization.\ntemplate <typename T1, typename T2>\nvoid ReferenceBatchNorm(const Tensor& input, const float input_min,\n                        const float input_max, const Tensor& mean,\n                        float mean_min, float mean_max, const Tensor& var,\n                        float var_min, float var_max, const Tensor& beta,\n                        float beta_min, float beta_max, const Tensor& gamma,\n                        float gamma_min, float gamma_max,\n                        float variance_epsilon, bool scale_after_normalization,\n                        Tensor* output, float* output_min, float* output_max) {\n  auto input_flat = input.flat<T1>();\n  auto mean_flat = mean.flat<T1>();\n  auto var_flat = var.flat<T1>();\n  auto beta_flat = beta.flat<T1>();\n  auto gamma_flat = gamma.flat<T1>();\n  auto output_flat = output->flat<T2>();\n\n  const int depth = mean.dim_size(0);\n  const int row_count = input_flat.size() / depth;\n\n  *output_min = std::numeric_limits<float>::max();\n  *output_max = std::numeric_limits<float>::lowest();\n  for (int pass = 0; pass < 2; ++pass) {\n    const bool is_range_pass = (pass == 0);\n    for (int row_index = 0; row_index < row_count; ++row_index) {\n      for (int channel = 0; channel < depth; ++channel) {\n        const int input_index = (row_index * depth) + channel;\n        const float input_value =\n            QuantizedToFloat(input_flat(input_index), input_min, input_max);\n        const float mean_value =\n            QuantizedToFloat(mean_flat(channel), mean_min, mean_max);\n        const float var_value =\n            QuantizedToFloat(var_flat(channel), var_min, var_max);\n        const float beta_value =\n            QuantizedToFloat(beta_flat(channel), beta_min, beta_max);\n        const float gamma_value =\n            QuantizedToFloat(gamma_flat(channel), gamma_min, gamma_max);\n        float output_value;\n        if (scale_after_normalization) {\n          output_value = (((input_value - mean_value) /\n                           sqrtf(var_value + variance_epsilon)) *\n                          gamma_value) +\n                         beta_value;\n        } else {\n          output_value = ((input_value - mean_value) /\n                          sqrtf(var_value + variance_epsilon)) +\n                         beta_value;\n        }\n        if (is_range_pass) {\n          *output_min = std::min(output_value, *output_min);\n          *output_max = std::max(output_value, *output_max);\n        } else {\n          output_flat(input_index) =\n              FloatToQuantized<T2>(output_value, *output_min, *output_max);\n        }\n      }\n    }\n  }\n}\n\n// An implementation of batch normalization that does the main calculations\n// using only fixed-point arithmetic. There's a prologue with some floating\n// calculations, but assuming the weights are constant these could be hoisted to\n// an offline process, or baked into the weights.\ntemplate <typename T1, typename T2>\nvoid FixedPointBatchNorm(const Tensor& input, const float input_min,\n                         const float input_max, const Tensor& mean,\n                         float mean_min, float mean_max, const Tensor& var,\n                         float var_min, float var_max, const Tensor& beta,\n                         float beta_min, float beta_max, const Tensor& gamma,\n                         float gamma_min, float gamma_max,\n                         float variance_epsilon, bool scale_after_normalization,\n                         Tensor* output, float* output_min, float* output_max) {\n  auto input_flat = input.flat<T1>();\n  auto mean_flat = mean.flat<T1>();\n  auto var_flat = var.flat<T1>();\n  auto beta_flat = beta.flat<T1>();\n  auto gamma_flat = gamma.flat<T1>();\n  auto output_flat = output->flat<T2>();\n\n  const int depth = mean.dim_size(0);\n  const int row_count = input_flat.size() / depth;\n\n  // The range here is chosen so that typical input values fit in without any\n  // overflow or loss of precision, going from +1m to -1m with 10 bits of fixed\n  // point precision.\n  *output_min = -(1 << 20);\n  *output_max = (1 << 20);\n\n  Tensor scale_tensor(DataTypeToEnum<T2>::v(), {depth});\n  auto scale_flat = scale_tensor.flat<T2>();\n  Tensor offset_tensor(DataTypeToEnum<T2>::v(), {depth});\n  auto offset_flat = offset_tensor.flat<T2>();\n  for (int channel = 0; channel < depth; ++channel) {\n    const float mean_value =\n        QuantizedToFloat(mean_flat(channel), mean_min, mean_max);\n    const float var_value =\n        QuantizedToFloat(var_flat(channel), var_min, var_max);\n    const float beta_value =\n        QuantizedToFloat(beta_flat(channel), beta_min, beta_max);\n    const float gamma_value =\n        QuantizedToFloat(gamma_flat(channel), gamma_min, gamma_max);\n    float scale_value;\n    if (scale_after_normalization) {\n      scale_value = (1.0f / sqrtf(var_value + variance_epsilon)) * gamma_value;\n    } else {\n      scale_value = (1.0f / sqrtf(var_value + variance_epsilon));\n    }\n    const float offset_value = (-mean_value * scale_value) + beta_value;\n    scale_flat(channel) =\n        FloatToQuantized<T2>(scale_value, *output_min, *output_max);\n    offset_flat(channel) =\n        FloatToQuantized<T2>(offset_value, *output_min, *output_max);\n  }\n\n  const T2 one_in_output_space =\n      FloatToQuantized<T2>(1.0f, *output_min, *output_max);\n  for (int row_index = 0; row_index < row_count; ++row_index) {\n    for (int channel = 0; channel < depth; ++channel) {\n      const int input_index = (row_index * depth) + channel;\n      const T2 input_value =\n          RequantizeInNewRange<T1, T2>(input_flat(input_index), input_min,\n                                       input_max, *output_min, *output_max);\n      const T2 scale_value = scale_flat(channel);\n      const T2 offset_value = offset_flat(channel);\n      const T2 output_value =\n          ((input_value * scale_value) / one_in_output_space) + offset_value;\n      output_flat(input_index) = output_value;\n    }\n  }\n}\n\n}  // namespace\n\ntemplate <typename T1, typename T2>\nclass QuantizedBatchNormOp : public OpKernel {\n public:\n  explicit QuantizedBatchNormOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"variance_epsilon\", &variance_epsilon_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"scale_after_normalization\",\n                                             &scale_after_normalization_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const auto& input_min_tensor = context->input(1);\n    OP_REQUIRES(context, input_min_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"input_min must have 1 element\"));\n    const float input_min = input_min_tensor.flat<float>()(0);\n    const auto& input_max_tensor = context->input(2);\n    OP_REQUIRES(context, input_max_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"input_max must have 1 element\"));\n    const float input_max = input_max_tensor.flat<float>()(0);\n    const Tensor& mean = context->input(3);\n    const auto& mean_min_tensor = context->input(4);\n    OP_REQUIRES(context, mean_min_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"mean_min must have 1 element\"));\n    const float mean_min = mean_min_tensor.flat<float>()(0);\n    const auto& mean_max_tensor = context->input(5);\n    OP_REQUIRES(context, mean_max_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"mean_max must have 1 element\"));\n    const float mean_max = mean_max_tensor.flat<float>()(0);\n    const Tensor& var = context->input(6);\n    const auto& var_min_tensor = context->input(7);\n    OP_REQUIRES(context, var_min_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"var_min must have 1 element\"));\n    const float var_min = var_min_tensor.flat<float>()(0);\n    const auto& var_max_tensor = context->input(8);\n    OP_REQUIRES(context, var_max_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"var_max must have 1 element\"));\n    const float var_max = var_max_tensor.flat<float>()(0);\n    const Tensor& beta = context->input(9);\n    const auto& beta_min_tensor = context->input(10);\n    OP_REQUIRES(context, beta_min_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"beta_min must have 1 element\"));\n    const float beta_min = beta_min_tensor.flat<float>()(0);\n    const auto& beta_max_tensor = context->input(11);\n    OP_REQUIRES(context, beta_max_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"beta_max must have 1 element\"));\n    const float beta_max = beta_max_tensor.flat<float>()(0);\n    const Tensor& gamma = context->input(12);\n    const auto& gamma_min_tensor = context->input(13);\n    OP_REQUIRES(context, gamma_min_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"gamma_min must have 1 element\"));\n    const float gamma_min = gamma_min_tensor.flat<float>()(0);\n    const auto& gamma_max_tensor = context->input(14);\n    OP_REQUIRES(context, gamma_max_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"gamma_max must have 1 element\"));\n    const float gamma_max = gamma_max_tensor.flat<float>()(0);\n\n    OP_REQUIRES(context, input.dims() == 4,\n                errors::InvalidArgument(\"input must be 4-dimensional\",\n                                        input.shape().DebugString()));\n    OP_REQUIRES(context, mean.dims() == 1,\n                errors::InvalidArgument(\"mean must be 1-dimensional\",\n                                        mean.shape().DebugString()));\n    OP_REQUIRES(context, var.dims() == 1,\n                errors::InvalidArgument(\"var must be 1-dimensional\",\n                                        var.shape().DebugString()));\n    OP_REQUIRES(context, beta.dims() == 1,\n                errors::InvalidArgument(\"beta must be 1-dimensional\",\n                                        beta.shape().DebugString()));\n    OP_REQUIRES(context, gamma.dims() == 1,\n                errors::InvalidArgument(\"gamma must be 1-dimensional\",\n                                        gamma.shape().DebugString()));\n    OP_REQUIRES(context, mean.NumElements() > 1,\n                errors::InvalidArgument(\"Must have at least a mean value\",\n                                        gamma.shape().DebugString()));\n    OP_REQUIRES(context, mean.NumElements() > 1,\n                errors::InvalidArgument(\"Must have at least a mean value\"));\n    const auto last_dim = input.shape().dims() - 1;\n    OP_REQUIRES(context,\n                mean.shape().dim_size(0) == input.shape().dim_size(last_dim),\n                errors::InvalidArgument(\"Must provide as many means as the \"\n                                        \"last dimension of the input tensor: \",\n                                        mean.shape().DebugString(), \" vs. \",\n                                        input.shape().DebugString()));\n    OP_REQUIRES(\n        context, mean.shape().dim_size(0) == var.shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Mean and variance tensors must have the same shape: \",\n            mean.shape().DebugString(), \" vs. \", var.shape().DebugString()));\n    OP_REQUIRES(\n        context, mean.shape().dim_size(0) == beta.shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Mean and beta tensors must have the same shape: \",\n            mean.shape().DebugString(), \" vs. \", beta.shape().DebugString()));\n    OP_REQUIRES(\n        context, mean.shape().dim_size(0) == gamma.shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Mean and gamma tensors must have the same shape: \",\n            mean.shape().DebugString(), \" vs. \", gamma.shape().DebugString()));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    float output_min;\n    float output_max;\n    FixedPointBatchNorm<T1, T2>(input, input_min, input_max, mean, mean_min,\n                                mean_max, var, var_min, var_max, beta, beta_min,\n                                beta_max, gamma, gamma_min, gamma_max,\n                                variance_epsilon_, scale_after_normalization_,\n                                output, &output_min, &output_max);\n\n    Tensor* output_min_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, {}, &output_min_tensor));\n    output_min_tensor->flat<float>()(0) = output_min;\n\n    Tensor* output_max_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, {}, &output_max_tensor));\n    output_max_tensor->flat<float>()(0) = output_max;\n  }\n\n private:\n  float variance_epsilon_;\n  bool scale_after_normalization_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"QuantizedBatchNormWithGlobalNormalization\")\n                            .Device(DEVICE_CPU)\n                            .TypeConstraint<quint8>(\"Tinput\")\n                            .TypeConstraint<qint32>(\"out_type\"),\n                        QuantizedBatchNormOp<quint8, qint32>);\n\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/quantized_batch_norm_op.cc"], "buggy_code_start_loc": [176], "buggy_code_end_loc": [205], "fixing_code_start_loc": [176], "fixing_code_end_loc": [263], "type": "CWE-369", "message": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc) does not validate all constraints specified in the op's contract(https://www.tensorflow.org/api_docs/python/tf/raw_ops/QuantizedBatchNormWithGlobalNormalization). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-29548", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-14T20:15:12.807", "lastModified": "2021-05-20T15:17:34.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc) does not validate all constraints specified in the op's contract(https://www.tensorflow.org/api_docs/python/tf/raw_ops/QuantizedBatchNormWithGlobalNormalization). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico.&#xa0;Un atacante puede causar una divisi\u00f3n del tiempo de ejecuci\u00f3n por error cero y denegaci\u00f3n de servicio en \"tf.raw_ops.QuantizedBatchNormWithGlobalNormalization\".&#xa0;Esto es debido a que la implementaci\u00f3n (https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc) no comprueba todas las restricciones especificadas en el contrato de la operaci\u00f3n (https: //www.tensorflow .org/api_docs/python/tf/raw_ops/QuantizedBatchNormWithGlobalNormalization).&#xa0;La correcci\u00f3n ser\u00e1 inclu\u00edda en TensorFlow versi\u00f3n 2.5.0.&#xa0;Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.4.2, TensorFlow versi\u00f3n 2.3.3, TensorFlow versi\u00f3n 2.2.3 y TensorFlow versi\u00f3n 2.1.4, ya que estos tambi\u00e9n est\u00e1n afectados y a\u00fan est\u00e1n en el rango admitido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.4", "matchCriteriaId": "323ABCCE-24EB-47CC-87F6-48C101477587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.3", "matchCriteriaId": "64ABA90C-0649-4BB0-89C9-83C14BBDCC0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.3", "matchCriteriaId": "0F83E0CF-CBF6-4C24-8683-3E7A5DC95BA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.2", "matchCriteriaId": "8259531B-A8AC-4F8B-B60F-B69DE4767C03"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/d6ed5bcfe1dcab9e85a4d39931bd18d99018e75b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-p45v-v4pw-77jr", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/d6ed5bcfe1dcab9e85a4d39931bd18d99018e75b"}}