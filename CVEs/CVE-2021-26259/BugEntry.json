{"buggy_code": ["# Changes in HTMLDOC v1.9.12\n\n- Fixed a crash bug with \"data:\" URIs and EPUB output (Issue #410)\n- Fixed a crash bug with malformed URIs (Issue #418)\n- Fixed a crash bug with malformed GIF files (Issue #423)\n- Fixed some issues reported by Coverity.\n\n\n# Changes in HTMLDOC v1.9.11\n\n- Added high-resolution desktop icons for Linux.\n- Updated the internal HTTP library to fix truncation of redirection URLs\n  (Issue #396)\n- Fixed a regression in the handling of character entities for UTF-8 input\n  (Issue #401)\n- The `--numbered` option did not work when the table-of-contents was disabled\n  (Issue #405)\n\n\n# Changes in HTMLDOC v1.9.10\n\n- Updated local zlib to v1.2.11.\n- Updated local libpng to v1.6.37.\n- Fixed packaging issues on macOS and Windows (Issue #377, Issue #386)\n- Now ignore sRGB profile errors in PNG files (Issue #390)\n- The GUI would crash when saving (Issue #391)\n- Page comments are now allowed in `pre` text (Issue #394)\n\n\n# Changes in HTMLDOC v1.9.9\n\n- Fixed a redirection issue - some sites (incorrectly) provide an incomplete\n  Location: URL in the HTTP response.\n- Fixed https: support on newer versions of Windows (Issue #378)\n- Fixed a problem with remote URLs containing spaces (Issue #379)\n- Fixed a UTF-8 processing bug for Markdown files (Issue #383)\n- Added support for `<FONT FACE=\"monospace\">` (Issue #385)\n\n\n# Changes in HTMLDOC v1.9.8\n\n- Added support for a `HTMLDOC.filename` META keyword that controls the filename\n  reported in CGI mode; the default remains \"htmldoc.pdf\" (Issue #367)\n- Fixed a paragraph formatting issue with large inline images (Issue #369)\n- Fixed a buffer underflow issue (Issue #370)\n- Fixed PDF page numbers (Issue #371)\n- Added support for a new `L` header/footer format (`$LETTERHEAD`), which\n  inserts a letterhead image at its full size (Issue #372, Issue #373,\n  Issue #375)\n- Updated the build documentation (Issue #374)\n\n\n# Changes in HTMLDOC v1.9.7\n\n- Refactored the PRE rendering code to work around compiler optimization bugs\n  (Issue #349)\n- Added support for links with targets (Issue #351)\n- Fixed a table rowspan + valign bug (Issue #360)\n\n\n# Changes in HTMLDOC v1.9.6\n\n- Added support for data URIs (Issue #340)\n- HTMLDOC no longer includes a PDF table of contents when converting a single\n  web page (Issue #344)\n- Updated the markdown support with external links, additional inline markup,\n  and hard line breaks.\n- Links in markdown text no longer render with a leading space as part of the\n  link (Issue #346)\n- Fixed a buffer underflow bug discovered by AddressSanitizer.\n- Fixed a bug in UTF-8 support (Issue #348)\n- PDF output now includes the base language of the input document(s)\n  (Issue #350)\n- Optimized the loading of font widths (Issue #354)\n- Optimized PDF page resources (Issue #356)\n- Optimized the base memory used for font widths (Issue #357)\n- Added proper `&shy;` support (Issue #361)\n- Title files can now be markdown.\n\n\n# Changes in HTMLDOC v1.9.5\n\n- The GUI did not support EPUB output.\n- Empty markdown table cells were not rendered in PDF or PostScript output.\n- The automatically-generated title page now supports both \"docnumber\" and\n  \"version\" metadata.\n- Added support for dc:subject and dc:language metadata in EPUB output from the\n  HTML keywords and lang values.\n- Added support for the subject and language metadata in markdown input.\n- Fixed a buffer underflow bug (Issue #338)\n- `htmldoc --help` now reports whether HTTPS URLs are supported (Issue #339)\n- Fixed an issue with HTML title pages and EPUB output.\n\n\n# Changes in HTMLDOC v1.9.4\n\n- Inline fixed-width text is no longer reduced in size automatically\n  (Issue #309)\n- Optimized initialization of font width data (Issue #334)\n\n\n# Changes in HTMLDOC v1.9.3\n\n- Fixed formatting bugs with aligned images (Issue #322, Issue #324)\n- Fixed support for three digit \"#RGB\" color values (Issue #323)\n- Fixed character set support for markdown metadata.\n- Updated libpng to v1.6.34 (Issue #326)\n- The makefiles did not use the CPPFLAGS value (Issue #328)\n\n\n# Changes in HTMLDOC v1.9.2\n\n- Added Markdown table support.\n- Fixed parsing of TBODY, TFOOT, and THEAD elements in HTML files.\n\n\n# Changes in HTMLDOC v1.9.1\n\n- Fixed monospace font size issue (Issue #309)\n- Added support for reproducible builds (Issue #310)\n- Added limited support for the HTML 4.0 SPAN element (Issue #311)\n- Added (extremely limited) UTF-8 support for input files (Issue #314)\n- Fixed buffer underflow for (invalid) short HTML comments (Issue #316)\n- Now indent PRE text, by popular request.\n- EPUB output now makes sure that `<element property>` is written as\n  `<element property=\"property\">`.\n- Now support both NAME and ID for table-of-contents targets.\n\n\n# Changes in HTMLDOC v1.9\n\n- Added support for repeating a single header row for tables that span multiple\n  pages (Issue #16)\n- Added support for embedding the current filename/URL in the header or footer\n  (Issue #50)\n- Added EPUB support (Issue #301)\n- Added Markdown support (Issue #302)\n- Fixed a regression in header/footer image scaling (Issue #303)\n- Documentation updates (Issue #305)\n- Compiler fixes (Issue #304, Issue #306)\n- Fixed a bug when running HTMLDOC as a macOS application.\n- Updated the bundled libpng to v1.6.29.\n\n\n# Changes in HTMLDOC v1.8.30\n\n- Updated documentation to reflect new project page on Github.\n- Dropped old CDE and IRIX desktop integration files.\n- Cleaned up the GUI and adopted new default text editors for Linux and macOS.\n- PAGE BREAK comments at the end of a file in web page mode would lose the\n  first page (Issue #251)\n- Fixed the scaling of header/footer images to limit them to the height of the\n  header or footer (Issue #273)\n- Fixed an issue with the top-level makefile not exiting with an error as\n  needed (Issue #282)\n- Fixed a URL referencing bug when the same hostname but a different port was\n  used (Issue #290)\n- Fixed build issue on macOS (Issue #291)\n- Fixed handling of indexed+alpha PNG images (Issue #295)\n\n\n# Changes in HTMLDOC v1.8.29\n\n- Updated local PNG library to version 1.6.20.\n- Updated local JPEG library to version 9b.\n- Dropped support for OpenSSL.\n- Added configure script support for libjpeg-turbo.\n- Updated HTTP code to latest CUPS/ippsample sources.\n- Duplex PDF output incorrectly forced an even number of pages\n- The table of contents showed the wrong page numbers after headings containing\n  the \"_HD_OMIT_TOC\" attribute.\n- Fixed reported build issues\n- The configure script's --enable-local* options did not work.\n\n\n# Changes in HTMLDOC v1.8.28\n\n- Updated local zlib to version 1.2.8.\n- Updated local PNG library to version 1.6.8.\n- Updated local JPEG library to version 9.\n- Updated default PDF version to 1.4.\n- SECURITY: Fixed three buffer overflow issues when reading AFM files and\n  parsing page sizes.\n- Fixed incompatibility with Fortify's version of strcpy, which does not work\n  properly with variable-length arrays\n- Fixed compilation against PNG library 1.5 or later\n- Fixed documentation errors\n- Marked Zapf-Dingbats as a standard font\n- Fixed GPL license text in GUI\n- Fixed a table formatting problem when a column has multiple colspan values\n- Fixed parsing of HTML comments\n- Fixed potential out-of-bounds read in table-of-contents rendering code\n- Fixed handling of image URLs with ampersands in them\n- Fixed top/bottom margins for logo and header/footer images\n- Fixed image alignment bug\n- Fixed X11 build problem\n\n\n# Changes in HTMLDOC v1.8.27\n\n- Fixed a crash bug that appeared when more than 10 blank pages were present in\n  a document\n- Color changes were not reflected in PRE text\n- Remote URLs did not always work on older operating systems\n- Image filenames using % escapes were not decoded properly.\n- Rows using BGCOLOR that spanned across multiple pages did not render properly\n- Rows no longer start on a new page due to a cell with both HEIGHT and ROWSPAN\n  specified\n- CMYK JPEG images caused HTMLDOC to crash\n- Table cell width calculations didn't always account for the proper minimum\n  width\n- Images were not copied when generating indexed HTML output to a directory\n- Changing the bottom margin resulted in text that was formatted below the\n  bottom margin.\n- The Monospace-Oblique font was not embedded properly in PDF files.\n\n\n# Changes in HTMLDOC v1.8.26\n\n- Outline and keyword strings in PDF files are now stored as Unicode\n- The Flate compression code could get in an infinite loop if it ran out of\n  memory\n- Book files saved from the GUI did not handle filenames with spaces\n- Fixed and re-enabled the ASCII85Device filter support in PostScript Level 2/3\n  output\n- Character entities in the first word of a file were not rendered properly\n- Fixed-size table columns were incorrectly resized when a table width was also\n  specified and there was extra space to distribute\n- Text could \"walk\" up or down when in-line images were used\n- Row backgrounds incorrectly replaced cell backgrounds when the first cell in a\n  row used ROWSPAN\n- HTMLDOC did not correctly parse FONT FACE attributes\n- Images in Level 2/3 PostScript output did not work on some printers\n- The GUI did not use the first page header\n\n\n# Changes in HTMLDOC v1.8.25\n\n- Added \"--overflow\" and \"--no-overflow\" command-line options to show or hide\n  the content-too-large errors; the default is \"--no-overflow\".\n- Added \"--header1\" command-line option and \"HEADER1\" page comments to set the\n  page header for the first page of each chapter.\n- Added \"timing\" and \"remotebytes\" debug data generation.\n- Added DejaVu font collection to better support Cyrillic and Greek text; the\n  new fonts are available under the generic names \"monospace\", \"sans\", and\n  \"serif\".\n- Added \"--referer\" command-line option and corresponding CGI-mode support to\n  pass Referer: information in HTTP requests\n- On Windows, HTMLDOC now logs CGI mode errors to a file called \"htmldoc.log\" in\n  the Windows temporary directory.\n- HTMLDOC no longer uses Base-85 encoding for image data when producing Level 2\n  and 3 PostScript output. It appears that many printers and PostScript\n  interpreters cannot properly decode this data when the original image data is\n  not a multiple of 8 bits.\n- HTMLDOC now renders STRONG elements in boldface instead of bold-italic to\n  match the W3C recommendations.\n- HTMLDOC now automatically inserts a TR element before a TD or TH element as\n  needed to improve web site compatibility; this also triggers a HTML error in\n  --strict mode.\n- \"$HFIMAGEn\" didn't work in a header/footer string.\n- HTMLDOC could crash when rendering a table.\n- Book files were not used in CGI mode\n- Cookies were not sent in HTTP requests\n- Table cells were not aligned properly when the ROWSPAN attribute was set to 1\n- HTMLDOC crashed when rendering unresolved hyperlinks in aligned images\n- Documented the HTMLDOC_NOCGI environment variable\n- HTMLDOC sometimes crashed when rendering tables with background colors\n- HTMLDOC would crash when writing encrypted strings longer than 1024 bytes\n- HTMLDOC didn't set the data directory when running in CGI mode on Windows.\n- HTMLDOC could crash when loading the Symbol.afm file\n- HTMLDOC did not always honor HEIGHT attributes in table rows.\n- Tables with a mix of colspan and rowspan sometimes caused cells to be moved\n  vertically outside the cell.\n", "/*\n * PostScript + PDF output routines for HTMLDOC, a HTML document processing\n * program.\n *\n * Just in case you didn't notice it, this file is too big; it will be\n * broken into more manageable pieces once we make all of the output\n * \"drivers\" into classes...\n *\n * Copyright \u00a9 2011-2021 by Michael R Sweet.\n * Copyright \u00a9 1997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n/*\n * The GCC compiler on HP-UX has a nasty habit of incorrectly \"fixing\"\n * the vmtypes.h header file provided with HP-UX.  The following\n * conditional magic makes sure that \"page_t\" (which we use in our\n * code) is not defined...\n */\n\n#ifdef __hpux\n#  define page_t\thpux_page_t\n#endif // __hpux\n\n/*#define DEBUG*/\n#include \"htmldoc.h\"\n#include \"markdown.h\"\n#include \"md5-private.h\"\n#define md5_append _cupsMD5Append\n#define md5_finish _cupsMD5Finish\n#define md5_init _cupsMD5Init\ntypedef unsigned char md5_byte_t;\n#define md5_state_t _cups_md5_state_t\n#include \"rc4.h\"\n#include <stdarg.h>\n#include <ctype.h>\n#include <time.h>\n#include <math.h>\n\n#ifdef WIN32\n#  include <io.h>\n#else\n#  include <unistd.h>\n#endif // WIN32\n\n#include <fcntl.h>\n\n#include <zlib.h>\n\nextern \"C\" {\t\t/* Workaround for JPEG header problems... */\n#include <jpeglib.h>\t/* JPEG/JFIF image definitions */\n}\n\n#ifdef __hpux\n#  undef page_t\n#endif // __hpux\n\n\n/*\n * Output options...\n */\n\n#define HTMLDOC_ASCII85\n//#define HTMLDOC_INTERPOLATION\n#define HTMLDOC_PRODUCER \"htmldoc \" SVERSION \" Copyright 2011-2019 by Michael R Sweet\"\n\n\n/*\n * Constants...\n */\n\n#define RENDER_TEXT\t0\t\t/* Text fragment */\n#define RENDER_IMAGE\t1\t\t/* Image */\n#define RENDER_BOX\t2\t\t/* Box */\n#define RENDER_LINK\t3\t\t/* Hyperlink */\n#define RENDER_BG\t4\t\t/* Background image */\n\n\n/*\n * Structures...\n */\n\ntypedef struct render_str\t\t/**** Render entity structure ****/\n{\n  struct render_str\t*prev;\t\t/* Previous rendering entity */\n  struct render_str\t*next;\t\t/* Next rendering entity */\n  int\ttype;\t\t\t\t/* Type of entity */\n  float\tx,\t\t\t\t/* Position in points */\n\ty,\t\t\t\t/* ... */\n\twidth,\t\t\t\t/* Size in points */\n\theight;\t\t\t\t/* ... */\n  union\n  {\n    struct\n    {\n      int\ttypeface,\t\t/* Typeface for text */\n\t\tstyle;\t\t\t/* Style of text */\n      float\tsize;\t\t\t/* Size of text in points */\n      float\tspacing;\t\t/* Inter-character spacing */\n      float\trgb[3];\t\t\t/* Color of text */\n      uchar\tbuffer[1];\t\t/* String buffer */\n    }   \ttext;\n    image_t\t*image;\t\t\t/* Image pointer */\n    float\tbox[3];\t\t\t/* Box color */\n    uchar\tlink[1];\t\t/* Link URL */\n  }\tdata;\n} render_t;\n\ntypedef struct\t\t\t\t/**** Named link position structure */\n{\n  short\t\tpage,\t\t\t/* Page # */\n\t\ttop;\t\t\t/* Top position */\n  uchar\t\tname[124];\t\t/* Reference name */\n} link_t;\n\ntypedef struct\t\t\t\t//// Page information\n{\n  int\t\twidth,\t\t\t// Width of page in points\n\t\tlength,\t\t\t// Length of page in points\n\t\tleft,\t\t\t// Left margin in points\n\t\tright,\t\t\t// Right margin in points\n\t\ttop,\t\t\t// Top margin in points\n\t\tbottom,\t\t\t// Bottom margin in points\n\t\tduplex,\t\t\t// Duplex this page?\n\t\tlandscape;\t\t// Landscape orientation?\n  render_t\t*start,\t\t\t// First render element\n\t\t*end;\t\t\t// Last render element\n  uchar\t\t*url,                   // URL/file\n                *chapter,\t\t// Chapter text\n\t\t*heading;\t\t// Heading text\n  tree_t\t*headnode;\t\t// Heading node\n  uchar\t\t*header[3],\t\t// Headers for regular pages\n\t\t*header1[3],\t\t// Headers for first pages\n\t\t*footer[3];\t\t// Footers for all pages\n  char\t\tmedia_color[64],\t// Media color\n\t\tmedia_type[64];\t\t// Media type\n  int\t\tmedia_position;\t\t// Media position\n  char\t\tpage_text[64];\t\t// Page number for TOC\n  image_t\t*background_image;\t// Background image\n  float\t\tbackground_color[3];\t// Background color\n\n  // Number-up support\n  int\t\tnup;\t\t\t// Number up pages\n  int\t\toutpage;\t\t// Output page #\n  float\t\toutmatrix[2][3];\t// Transform matrix\n} page_t;\n\ntypedef struct\t\t\t\t//// Output page info\n{\n  int\t\tnup;\t\t\t// Number up pages\n  int\t\tpages[16];\t\t// Pages on this output page\n  int\t\tannot_object;\t\t// Annotation object\n} outpage_t;\n\n\n/*\n * Local globals...\n */\n\nstatic time_t\tdoc_time;\t\t// Current time\nstatic struct tm doc_date;\t\t// Current date\n\nstatic uchar    *current_url = NULL;\nstatic int\ttitle_page;\nstatic int\tchapter,\n\t\tchapter_outstarts[MAX_CHAPTERS],\n\t\tchapter_outends[MAX_CHAPTERS],\n\t\tchapter_starts[MAX_CHAPTERS],\n\t\tchapter_ends[MAX_CHAPTERS];\n\nstatic size_t\tnum_headings = 0,\n\t\talloc_headings = 0;\nstatic int\t*heading_pages = NULL,\n\t\t*heading_tops = NULL;\n\nstatic size_t\tnum_pages = 0,\n\t\talloc_pages = 0;\nstatic page_t\t*pages = NULL;\nstatic tree_t\t*current_heading;\n\nstatic size_t\tnum_outpages = 0;\nstatic outpage_t *outpages = NULL;\n\nstatic size_t\tnum_links = 0,\n\t\talloc_links = 0;\nstatic link_t\t*links = NULL;\n\nstatic uchar\tlist_types[16];\nstatic int\tlist_values[16];\n\nstatic char\tstdout_filename[256];\nstatic size_t\tnum_objects = 0,\n\t\talloc_objects = 0;\nstatic int\t*objects = NULL,\n\t\troot_object,\n\t\tinfo_object,\n\t\toutline_object,\n\t\tpages_object,\n\t\tnames_object,\n\t\tencrypt_object,\n\t\tfont_objects[TYPE_MAX * STYLE_MAX];\n\nstatic uchar\t*doc_title = NULL;\nstatic image_t\t*logo_image = NULL;\nstatic float\tlogo_width,\n\t\tlogo_height;\nstatic image_t\t*lh_image = NULL;\nstatic float\tlh_width,\n\t\tlh_height;\n\nstatic image_t\t*hfimage[MAX_HF_IMAGES];\nstatic float\thfimage_width[MAX_HF_IMAGES],\n\t\thfimage_height[MAX_HF_IMAGES];\nstatic float    maxhfheight;\n\nstatic image_t\t*background_image = NULL;\nstatic float\tbackground_color[3] = { 1.0, 1.0, 1.0 },\n\t\tlink_color[3] = { 0.0, 0.0, 1.0 };\n\nstatic int\trender_typeface,\n\t\trender_style;\nstatic float\trender_size,\n\t\trender_rgb[3],\n\t\trender_x,\n\t\trender_y,\n\t\trender_startx,\n\t\trender_spacing;\n\nstatic int\t\tcompressor_active = 0;\nstatic z_stream\t\tcompressor;\nstatic uchar\t\tcomp_buffer[8192];\nstatic uchar\t\tencrypt_key[16];\nstatic int\t\tencrypt_len;\nstatic rc4_context_t\tencrypt_state;\nstatic md5_byte_t\tfile_id[16];\n\n\n/*\n * Local functions...\n */\n\nextern \"C\" {\ntypedef int\t(*compare_func_t)(const void *, const void *);\n}\n\nstatic void\tpspdf_debug_stats();\n\nstatic void\tpspdf_transform_coords(page_t *p, float &x, float  &y);\nstatic void\tpspdf_transform_page(int outpage, int pos, int page);\n\nstatic void\tpspdf_prepare_outpages();\nstatic void\tpspdf_prepare_page(int page);\nstatic void\tpspdf_prepare_heading(int page, int print_page, uchar **format,\n\t\t                      int y, char *page_text, int page_len);\nstatic void\tps_write_document(uchar *author, uchar *creator,\n\t\t                  uchar *copyright, uchar *keywords,\n\t\t\t\t  uchar *subject, uchar *lang);\nstatic void\tps_write_outpage(FILE *out, int outpage);\nstatic void\tps_write_page(FILE *out, int page);\nstatic void\tps_write_background(FILE *out);\nstatic void\tpdf_write_document(uchar *author, uchar *creator,\n\t\t                   uchar *copyright, uchar *keywords,\n\t\t\t\t   uchar *subject, uchar *lang, tree_t *doc, tree_t *toc);\nstatic void\tpdf_write_outpage(FILE *out, int outpage);\nstatic void\tpdf_write_page(FILE *out, int page);\nstatic void\tpdf_write_resources(FILE *out, int page);\n#ifdef DEBUG_TOC\nstatic void\tpdf_text_contents(FILE *out, tree_t *toc, int indent = 0);\n#endif // DEBUG_TOC\nstatic void\tpdf_write_contents(FILE *out, tree_t *toc, int parent,\n\t\t                   int prev, int next, int *heading);\nstatic void\tpdf_write_files(FILE *out, tree_t *doc);\nstatic void\tpdf_write_links(FILE *out);\nstatic void\tpdf_write_names(FILE *out);\nstatic int\tpdf_count_headings(tree_t *toc);\n\nstatic int\tpdf_start_object(FILE *out, int array = 0);\nstatic void\tpdf_start_stream(FILE *out);\nstatic void\tpdf_end_object(FILE *out);\n\nstatic void\tencrypt_init(void);\nstatic void\tflate_open_stream(FILE *out);\nstatic void\tflate_close_stream(FILE *out);\nstatic void\tflate_puts(const char *s, FILE *out);\nstatic void\tflate_printf(FILE *out, const char *format, ...);\nstatic void\tflate_write(FILE *out, uchar *inbuf, int length, int flush=0);\n\nstatic void\tparse_contents(tree_t *t, float left, float width, float bottom,\n\t\t               float length, float *y, int *page, int *heading,\n\t\t\t       tree_t *chap);\nstatic void\tparse_doc(tree_t *t, float *left, float *right, float *bottom,\n\t\t          float *top, float *x, float *y, int *page,\n\t\t\t  tree_t *cpara, int *needspace);\nstatic void\tparse_heading(tree_t *t, float left, float width, float bottom,\n\t\t              float length, float *x, float *y, int *page,\n\t\t\t      int needspace);\nstatic void\tparse_paragraph(tree_t *t, float left, float width, float bottom,\n\t\t                float length, float *x, float *y, int *page,\n\t\t\t        int needspace);\nstatic void\tparse_pre(tree_t *t, float left, float width, float bottom,\n\t\t          float length, float *x, float *y, int *page,\n\t\t\t  int needspace);\nstatic void\tparse_table(tree_t *t, float left, float width, float bottom,\n\t\t            float length, float *x, float *y, int *page,\n\t\t\t    int needspace);\nstatic void\tparse_list(tree_t *t, float *left, float *width, float *bottom,\n\t\t           float *length, float *x, float *y, int *page,\n\t\t\t   int needspace);\nstatic void\tinit_list(tree_t *t);\nstatic void\tparse_comment(tree_t *t, float *left, float *width, float *bottom,\n\t\t              float *length, float *x, float *y, int *page,\n\t\t\t      tree_t *para, int needspace);\n\nstatic void\tcheck_pages(int page);\n\nstatic void\tadd_link(uchar *name, int page, int top);\nstatic link_t\t*find_link(uchar *name);\nstatic int\tcompare_links(link_t *n1, link_t *n2);\n\nstatic void\tfind_background(tree_t *t);\nstatic void\twrite_background(int page, FILE *out);\n\nstatic render_t\t*new_render(int page, int type, double x, double y,\n\t\t            double width, double height, void *data,\n\t\t\t    render_t *insert = 0);\nstatic float\tget_cell_size(tree_t *t, float left, float right,\n\t\t              float *minwidth, float *prefwidth,\n\t\t\t      float *minheight);\nstatic float\tget_table_size(tree_t *t, float left, float right,\n\t\t               float *minwidth, float *prefwidth,\n\t\t\t       float *minheight);\nstatic tree_t\t*flatten_tree(tree_t *t);\nstatic float\tget_width(uchar *s, int typeface, int style, int size);\nstatic void\tupdate_image_size(tree_t *t);\nstatic uchar\t*get_title(tree_t *doc);\nstatic FILE\t*open_file(void);\nstatic void\tset_color(FILE *out, float *rgb);\nstatic void\tset_font(FILE *out, int typeface, int style, float size);\nstatic void\tset_pos(FILE *out, float x, float y);\nstatic void\twrite_prolog(FILE *out, int pages, uchar *author,\n\t\t             uchar *creator, uchar *copyright,\n\t\t\t     uchar *keywords, uchar *subject);\nstatic void\tps_hex(FILE *out, uchar *data, int length);\n#ifdef HTMLDOC_ASCII85\nstatic void\tps_ascii85(FILE *out, uchar *data, int length, int eod = 0);\n#endif // HTMLDOC_ASCII85\nstatic void\tjpg_init(j_compress_ptr cinfo);\nstatic boolean\tjpg_empty(j_compress_ptr cinfo);\nstatic void\tjpg_term(j_compress_ptr cinfo);\nstatic void\tjpg_setup(FILE *out, image_t *img, j_compress_ptr cinfo);\nstatic int\tcompare_rgb(unsigned *rgb1, unsigned *rgb2);\nstatic void\twrite_image(FILE *out, render_t *r, int write_obj = 0);\nstatic void\twrite_imagemask(FILE *out, render_t *r);\nstatic void\twrite_string(FILE *out, uchar *s, int compress);\nstatic void\twrite_text(FILE *out, render_t *r);\nstatic void\twrite_trailer(FILE *out, int pages, uchar *lang);\nstatic int\twrite_type1(FILE *out, typeface_t typeface,\n\t\t\t    style_t style);\nstatic void\twrite_utf16(FILE *out, uchar *s);\n\n\n/*\n * 'pspdf_export()' - Export PostScript/PDF file(s)...\n */\n\nint\npspdf_export(tree_t *document,\t/* I - Document to export */\n             tree_t *toc)\t/* I - Table of contents for document */\n{\n  int\t\ti, j;\t\t/* Looping vars */\n  const char\t*title_file;\t/* Location of title image/file */\n  uchar\t\t*author,\t/* Author of document */\n\t\t*creator,\t/* HTML file creator (Netscape, etc) */\n\t\t*copyright,\t/* File copyright */\n\t\t*docnumber,\t/* Document number */\n\t\t*keywords,\t/* Search keywords */\n\t\t*subject,\t/* Subject */\n\t\t*lang;\t\t/* Language */\n  tree_t\t*t;\t\t/* Title page document tree */\n  FILE\t\t*fp;\t\t/* Title page file */\n  float\t\tx, y,\t\t/* Current page position */\n\t\tleft, right,\t/* Left and right margins */\n\t\tbottom, top,\t/* Bottom and top margins */\n\t\twidth,\t\t/* Width of , author, etc */\n\t\theight;\t\t/* Height of  area */\n  int\t\tpage,\t\t/* Current page # */\n\t\tpos,\t\t/* Current header/footer position */\n\t\theading,\t/* Current heading # */\n\t\ttoc_duplex,\t/* Duplex TOC pages? */\n\t\ttoc_landscape,\t/* Do TOC in landscape? */\n\t\ttoc_width,\t/* Width of TOC pages */\n\t\ttoc_length,\t/* Length of TOC pages */\n\t\ttoc_left,\t/* TOC page margins */\n\t\ttoc_right,\n\t\ttoc_bottom,\n\t\ttoc_top;\n  image_t\t*timage;\t/* Title image */\n  float\t\ttimage_width,\t/* Title image width */\n\t\ttimage_height;\t/* Title image height */\n  render_t\t*r;\t\t/* Rendering structure... */\n  float\t\trgb[3];\t\t/* Text color */\n  int\t\tneedspace;\t/* Need whitespace */\n\n\n /*\n  * Figure out the printable area of the output page...\n  */\n\n  if (Landscape)\n  {\n    PagePrintWidth  = PageLength - PageLeft - PageRight;\n    PagePrintLength = PageWidth - PageTop - PageBottom;\n  }\n  else\n  {\n    PagePrintWidth  = PageWidth - PageLeft - PageRight;\n    PagePrintLength = PageLength - PageTop - PageBottom;\n  }\n\n  toc_width     = PageWidth;\n  toc_length    = PageLength;\n  toc_left      = PageLeft;\n  toc_right     = PageRight;\n  toc_bottom    = PageBottom;\n  toc_top       = PageTop;\n  toc_landscape = Landscape;\n  toc_duplex    = PageDuplex;\n\n /*\n  * Get the document title, author, etc...\n  */\n\n  doc_title   = get_title(document);\n  author      = htmlGetMeta(document, (uchar *)\"author\");\n  creator     = htmlGetMeta(document, (uchar *)\"generator\");\n  copyright   = htmlGetMeta(document, (uchar *)\"copyright\");\n  docnumber   = htmlGetMeta(document, (uchar *)\"docnumber\");\n  keywords    = htmlGetMeta(document, (uchar *)\"keywords\");\n  subject     = htmlGetMeta(document, (uchar *)\"subject\");\n  lang        = htmlGetMeta(document, (uchar *)\"lang\");\n  logo_image  = image_load(LogoImage, !OutputColor);\n  lh_image    = image_load(Letterhead, !OutputColor);\n  maxhfheight = 0.0f;\n\n  if (docnumber == NULL)\n    docnumber = htmlGetMeta(document, (uchar *)\"version\");\n\n  if (lh_image != NULL)\n  {\n    lh_width  = (float)(lh_image->width * PagePrintWidth / _htmlBrowserWidth);\n    lh_height = (float)(lh_width * lh_image->height / lh_image->width);\n\n    if (lh_height > maxhfheight)\n      maxhfheight = lh_height;\n  }\n  else\n    lh_width = lh_height = 0.0f;\n\n  if (logo_image != NULL)\n  {\n    logo_width  = (float)(logo_image->width * PagePrintWidth / _htmlBrowserWidth);\n    logo_height = (float)(logo_width * logo_image->height / logo_image->width);\n\n    if (logo_height > (2.0 * HeadFootSize))\n    {\n      // Issue #273: too large logo image will overlap the body text, so cap\n      // the height of the logo image to the header/footer size...\n      //\n      // Issue #303: regression prevents using header/footer images for special\n      // underlining/etc. effects.\n      logo_height = (float)(2.0 * HeadFootSize);\n      logo_width  = logo_height * logo_image->width / logo_image->height;\n    }\n\n    if (logo_height > maxhfheight)\n      maxhfheight = logo_height;\n  }\n  else\n    logo_width = logo_height = 0.0f;\n\n  for (int hfi = 0; hfi < MAX_HF_IMAGES; hfi ++)\n  {\n    hfimage[hfi] = image_load(HFImage[hfi], !OutputColor);\n\n    if (hfimage[hfi])\n    {\n      hfimage_width[hfi]  = (float)(hfimage[hfi]->width * PagePrintWidth / _htmlBrowserWidth);\n      hfimage_height[hfi] = (float)(hfimage_width[hfi] * hfimage[hfi]->height / hfimage[hfi]->width);\n\n      if (hfimage_height[hfi] > (2.0 * HeadFootSize))\n      {\n        // Issue #273: too large logo image will overlap the body text, so cap\n        // the height of the logo image to the header/footer size...\n        //\n        // Issue #303: regression prevents using header/footer images for special\n        // underlining/etc. effects.\n        hfimage_height[hfi] = (float)(2.0 * HeadFootSize);\n        hfimage_width[hfi]  = hfimage_height[hfi] * hfimage[hfi]->width / hfimage[hfi]->height;\n      }\n\n      if (hfimage_height[hfi] > maxhfheight)\n        maxhfheight = hfimage_height[hfi];\n    }\n    else\n      hfimage_width[hfi] = hfimage_height[hfi] = 0.0f;\n  }\n\n  find_background(document);\n  get_color((uchar *)LinkColor, link_color);\n\n /*\n  * Initialize page rendering variables...\n  */\n\n  num_pages   = 0;\n  alloc_pages = 0;\n  pages       = NULL;\n\n  memset(list_types, 0267, sizeof(list_types));\n  memset(list_values, 0, sizeof(list_values));\n  memset(chapter_starts, -1, sizeof(chapter_starts));\n  memset(chapter_ends, -1, sizeof(chapter_starts));\n\n /*\n  * Get the current date, using the SOURCE_DATE_EPOCH environment variable, if\n  * present, for the number of seconds since the epoch - this enables\n  * reproducible builds (Issue #310).\n  */\n\n  const char *source_date_epoch = getenv(\"SOURCE_DATE_EPOCH\");\n  if (!source_date_epoch || (doc_time = (time_t)strtol(source_date_epoch, NULL, 10)) <= 0)\n    doc_time = time(NULL);\n\n  gmtime_r(&doc_time, &doc_date);\n\n  num_headings   = 0;\n  alloc_headings = 0;\n  heading_pages  = NULL;\n  heading_tops   = NULL;\n  num_links      = 0;\n  alloc_links    = 0;\n  links          = NULL;\n  num_pages      = 0;\n\n  DEBUG_printf((\"pspdf_export: TitlePage = %d, TitleImage = \\\"%s\\\"\\n\",\n                TitlePage, TitleImage));\n\n  if (TitlePage)\n  {\n    const char *title_ext = file_extension(TitleImage);\n\n#ifdef WIN32\n    if (TitleImage[0] &&\n        stricmp(title_ext, \"bmp\") != 0 &&\n\tstricmp(title_ext, \"gif\") != 0 &&\n\tstricmp(title_ext, \"jpg\") != 0 &&\n\tstricmp(title_ext, \"png\") != 0)\n#else\n    if (TitleImage[0] &&\n        strcmp(title_ext, \"bmp\") != 0 &&\n\tstrcmp(title_ext, \"gif\") != 0 &&\n\tstrcmp(title_ext, \"jpg\") != 0 &&\n\tstrcmp(title_ext, \"png\") != 0)\n#endif // WIN32\n    {\n      DEBUG_printf((\"pspdf_export: Generating a titlepage using \\\"%s\\\"\\n\",\n                    TitleImage));\n\n      // Find the title file...\n      if ((title_file = file_find(Path, TitleImage)) == NULL)\n      {\n\tprogress_error(HD_ERROR_FILE_NOT_FOUND,\n\t               \"Unable to find title file \\\"%s\\\"!\", TitleImage);\n\treturn (1);\n      }\n\n      // Write a title page from HTML source...\n      if ((fp = fopen(title_file, \"rb\")) == NULL)\n      {\n\tprogress_error(HD_ERROR_FILE_NOT_FOUND,\n\t               \"Unable to open title file \\\"%s\\\" - %s!\",\n                       TitleImage, strerror(errno));\n\treturn (1);\n      }\n\n#ifdef _WIN32\n      if (!stricmp(title_ext, \"md\"))\n#else\n      if (!strcmp(title_ext, \"md\"))\n#endif // _WIN32\n\tt = mdReadFile(NULL, fp, file_directory(TitleImage));\n      else\n\tt = htmlReadFile(NULL, fp, file_directory(TitleImage));\n\n      htmlFixLinks(t, t, (uchar *)file_directory(TitleImage));\n      fclose(fp);\n\n      page            = 0;\n      title_page      = 1;\n      current_heading = NULL;\n      x               = 0.0f;\n      bottom          = 0.0f;\n      top             = PagePrintLength;\n      y               = top;\n      needspace       = 0;\n      left            = 0.0f;\n      right           = PagePrintWidth;\n\n      parse_doc(t, &left, &right, &bottom, &top, &x, &y, &page, NULL, &needspace);\n\n      if (PageDuplex && (num_pages & 1))\n\tcheck_pages(num_pages);\n\n      htmlDeleteTree(t);\n    }\n    else\n    {\n     /*\n      * Create a standard title page...\n      */\n\n      if ((timage = image_load(TitleImage, !OutputColor)) != NULL)\n      {\n\ttimage_width  = (float)(timage->width * PagePrintWidth / _htmlBrowserWidth);\n\ttimage_height = (float)(timage_width * timage->height / timage->width);\n      }\n      else\n        timage_width = timage_height = 0.0f;\n\n      check_pages(0);\n      if (PageDuplex)\n        check_pages(1);\n\n      height = 0.0;\n\n      if (timage != NULL)\n\theight += timage_height + _htmlSpacings[SIZE_P];\n      if (doc_title != NULL)\n\theight += _htmlSpacings[SIZE_H1] + _htmlSpacings[SIZE_P];\n      if (author != NULL)\n\theight += _htmlSpacings[SIZE_P];\n      if (docnumber != NULL)\n\theight += _htmlSpacings[SIZE_P];\n      if (copyright != NULL)\n\theight += _htmlSpacings[SIZE_P];\n\n      y = 0.5f * (PagePrintLength + height);\n\n      if (timage != NULL)\n      {\n\tnew_render(0, RENDER_IMAGE, 0.5f * (PagePrintWidth - timage_width),\n                   y - timage_height, timage_width, timage_height, timage);\n\ty -= timage_height + _htmlSpacings[SIZE_P];\n      }\n\n      get_color(_htmlTextColor, rgb);\n\n      if (doc_title != NULL)\n      {\n\twidth = get_width(doc_title, _htmlHeadingFont, STYLE_BOLD, SIZE_H1);\n\tr     = new_render(0, RENDER_TEXT, (PagePrintWidth - width) * 0.5f,\n                \t   y - _htmlSpacings[SIZE_H1], width,\n\t\t\t   _htmlSizes[SIZE_H1], doc_title);\n\n\tr->data.text.typeface = _htmlHeadingFont;\n\tr->data.text.style    = STYLE_BOLD;\n\tr->data.text.size     = (float)_htmlSizes[SIZE_H1];\n\tmemcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n\ty -= _htmlSpacings[SIZE_H1];\n\n\tif (docnumber != NULL)\n\t{\n\t  width = get_width(docnumber, _htmlBodyFont, STYLE_NORMAL, SIZE_P);\n\t  r     = new_render(0, RENDER_TEXT, (PagePrintWidth - width) * 0.5f,\n                             y - _htmlSpacings[SIZE_P], width,\n\t\t\t     _htmlSizes[SIZE_P], docnumber);\n\n\t  r->data.text.typeface = _htmlBodyFont;\n\t  r->data.text.style    = STYLE_NORMAL;\n\t  r->data.text.size     = (float)_htmlSizes[SIZE_P];\n          memcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n\t  y -= _htmlSpacings[SIZE_P];\n\t}\n\n\ty -= _htmlSpacings[SIZE_P];\n      }\n\n      if (author != NULL)\n      {\n\twidth = get_width(author, _htmlBodyFont, STYLE_NORMAL, SIZE_P);\n\tr     = new_render(0, RENDER_TEXT, (PagePrintWidth - width) * 0.5f,\n                \t   y - _htmlSpacings[SIZE_P], width, _htmlSizes[SIZE_P],\n\t\t\t   author);\n\n\tr->data.text.typeface = _htmlBodyFont;\n\tr->data.text.style    = STYLE_NORMAL;\n\tr->data.text.size     = (float)_htmlSizes[SIZE_P];\n\tmemcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n\ty -= _htmlSpacings[SIZE_P];\n      }\n\n      if (copyright != NULL)\n      {\n\twidth = get_width(copyright, _htmlBodyFont, STYLE_NORMAL, SIZE_P);\n\tr     = new_render(0, RENDER_TEXT, (PagePrintWidth - width) * 0.5f,\n                \t   y - _htmlSpacings[SIZE_P], width, _htmlSizes[SIZE_P],\n\t\t\t   copyright);\n\n\tr->data.text.typeface = _htmlBodyFont;\n\tr->data.text.style    = STYLE_NORMAL;\n\tr->data.text.size     = (float)_htmlSizes[SIZE_P];\n\tmemcpy(r->data.text.rgb, rgb, sizeof(rgb));\n      }\n    }\n\n    for (page = 0; page < (int)num_pages; page ++)\n      strlcpy((char *)pages[page].page_text, (page & 1) ? \"eltit\" : \"title\", sizeof(pages[page].page_text));\n  }\n  else\n    page = 0;\n\n /*\n  * Parse the document...\n  */\n\n  if (OutputType == OUTPUT_BOOK)\n    chapter = 0;\n  else\n  {\n    chapter           = 1;\n    TocDocCount       = 1;\n    chapter_starts[1] = num_pages;\n  }\n\n  title_page      = 0;\n  current_heading = NULL;\n  x               = 0.0f;\n  needspace       = 0;\n  left            = 0.0f;\n  right           = PagePrintWidth;\n\n  // Adjust top margin as needed...\n  float adjust, image_adjust, temp_adjust;\n\n  if (maxhfheight > HeadFootSize)\n    image_adjust = (float)(maxhfheight + HeadFootSize);\n  else\n    image_adjust = (float)(2 * HeadFootSize);\n\n  for (adjust = 0.0, pos = 0; pos < 3; pos ++)\n  {\n    if (Header[pos] &&\n        (strstr(Header[pos], \"$IMAGE\") != NULL ||\n\t strstr(Header[pos], \"$HFIMAGE\") != NULL ||\n\t strstr(Header[pos], \"$LETTERHEAD\") != NULL))\n      temp_adjust = image_adjust;\n    else if (Header1[pos] &&\n\t     (strstr(Header1[pos], \"$IMAGE\") != NULL ||\n\t      strstr(Header1[pos], \"$HFIMAGE\") != NULL ||\n\t      strstr(Header1[pos], \"$LETTERHEAD\") != NULL))\n      temp_adjust = image_adjust;\n    else if (Header[pos] || Header1[pos])\n      temp_adjust = (float)(2 * HeadFootSize);\n    else\n      temp_adjust = 0.0;\n\n    if (temp_adjust > adjust)\n      adjust = temp_adjust;\n  }\n\n  top = PagePrintLength - adjust;\n\n  // Adjust bottom margin as needed...\n  for (adjust = 0.0, pos = 0; pos < 3; pos ++)\n  {\n    if (Footer[pos] &&\n        (strstr(Footer[pos], \"$IMAGE\") != NULL ||\n\t strstr(Footer[pos], \"$HFIMAGE\") != NULL ||\n\t strstr(Footer[pos], \"$LETTERHEAD\") != NULL))\n      temp_adjust = image_adjust;\n    else if (Footer[pos])\n      temp_adjust = (float)(2 * HeadFootSize);\n    else\n      temp_adjust = 0.0;\n\n    if (temp_adjust > adjust)\n      adjust = temp_adjust;\n  }\n\n  bottom = adjust;\n\n  y = top;\n\n  parse_doc(document, &left, &right, &bottom, &top, &x, &y, &page, NULL, &needspace);\n\n  if (PageDuplex && (num_pages & 1))\n  {\n    if (PSLevel == 0)\n      chapter_ends[chapter] = num_pages - 1;\n\n    check_pages(num_pages);\n\n    if (PSLevel > 0)\n      chapter_ends[chapter] = num_pages - 1;\n  }\n  else\n    chapter_ends[chapter] = num_pages - 1;\n\n  for (chapter = 1; chapter <= TocDocCount; chapter ++)\n    for (page = chapter_starts[chapter]; page <= chapter_ends[chapter]; page ++)\n      pspdf_prepare_page(page);\n\n /*\n  * Parse the table-of-contents if necessary...\n  */\n\n  if (TocLevels > 0 && num_headings > 0)\n  {\n    // Restore default page size, etc...\n    PageWidth  = toc_width;\n    PageLength = toc_length;\n    PageLeft   = toc_left;\n    PageRight  = toc_right;\n    PageBottom = toc_bottom;\n    PageTop    = toc_top;\n    Landscape  = toc_landscape;\n    PageDuplex = toc_duplex;\n\n    if (Landscape)\n    {\n      PagePrintWidth  = PageLength - PageLeft - PageRight;\n      PagePrintLength = PageWidth - PageTop - PageBottom;\n    }\n    else\n    {\n      PagePrintWidth  = PageWidth - PageLeft - PageRight;\n      PagePrintLength = PageLength - PageTop - PageBottom;\n    }\n\n    // Adjust top margin as needed...\n    for (pos = 0; pos < 3; pos ++)\n      if (TocHeader[pos])\n\tbreak;\n\n    if (pos == 3)\n      top = PagePrintLength;\n    else if (maxhfheight > HeadFootSize)\n      top = (float)(PagePrintLength - maxhfheight - HeadFootSize);\n    else\n      top = (float)(PagePrintLength - 2 * HeadFootSize);\n\n    // Adjust bottom margin as needed...\n    for (pos = 0; pos < 3; pos ++)\n      if (TocFooter[pos])\n\tbreak;\n\n    if (pos == 3)\n      bottom = 0.0f;\n    else if (maxhfheight > HeadFootSize)\n      bottom = (float)(maxhfheight + HeadFootSize);\n    else\n      bottom = (float)(2 * HeadFootSize);\n\n    y                 = 0.0;\n    page              = num_pages - 1;\n    heading           = 0;\n    chapter_starts[0] = num_pages;\n    chapter           = 0;\n\n    parse_contents(toc, 0, PagePrintWidth, bottom, top, &y, &page, &heading, 0);\n    if (PageDuplex && (num_pages & 1))\n      check_pages(num_pages);\n    chapter_ends[0] = num_pages - 1;\n\n    for (page = chapter_starts[0]; page <= chapter_ends[0]; page ++)\n      pspdf_prepare_page(page);\n  }\n\n  if (TocDocCount > MAX_CHAPTERS)\n    TocDocCount = MAX_CHAPTERS;\n\n /*\n  * Do we have any pages?\n  */\n\n  if (num_pages > 0 && TocDocCount > 0)\n  {\n   /*\n    * Yes, write the document to disk...\n    */\n\n    pspdf_prepare_outpages();\n\n    pspdf_debug_stats();\n\n    progress_error(HD_ERROR_NONE, \"PAGES: %d\", (int)num_outpages);\n\n    if (PSLevel > 0)\n      ps_write_document(author, creator, copyright, keywords, subject, lang);\n    else\n      pdf_write_document(author, creator, copyright, keywords, subject, lang,\n                         document, toc);\n  }\n  else\n  {\n   /*\n    * No, show an error...\n    */\n\n    pspdf_debug_stats();\n\n    progress_error(HD_ERROR_NO_PAGES,\n                   \"Error: no pages generated! (did you remember to use webpage mode?\");\n  }\n\n /*\n  * Free memory...\n  */\n\n  if (doc_title != NULL)\n    free(doc_title);\n\n  if (alloc_links)\n  {\n    free(links);\n\n    num_links    = 0;\n    alloc_links  = 0;\n    links        = NULL;\n  }\n\n  for (i = 0; i < (int)num_pages; i ++)\n  {\n    if ((i == 0 || pages[i].chapter != pages[i - 1].chapter) &&\n        pages[i].chapter)\n      free(pages[i].chapter);\n\n    if ((i == 0 || pages[i].heading != pages[i - 1].heading) &&\n        pages[i].heading)\n      free(pages[i].heading);\n\n    if (!pages[i].heading)\n      continue;\n\n    for (j = 0; j < 3; j ++)\n    {\n      if (!pages[i].header[j])\n        continue;\n\n      if (i == 0 || pages[i].header[j] != pages[i - 1].header[j])\n        free(pages[i].header[j]);\n    }\n\n    for (j = 0; j < 3; j ++)\n    {\n      if (!pages[i].header1[j])\n        continue;\n\n      if (i == 0 || pages[i].header1[j] != pages[i - 1].header1[j])\n        free(pages[i].header1[j]);\n    }\n\n    for (j = 0; j < 3; j ++)\n    {\n      if (!pages[i].footer[j])\n        continue;\n\n      if (i == 0 || pages[i].footer[j] != pages[i - 1].footer[j])\n        free(pages[i].footer[j]);\n    }\n  }\n\n  for (i = 0; i < 3; i ++)\n  {\n    Header[i]    = NULL;\n    Header1[i]   = NULL;\n    Footer[i]    = NULL;\n    TocHeader[i] = NULL;\n    TocFooter[i] = NULL;\n  }\n\n  if (alloc_pages)\n  {\n    free(pages);\n    free(outpages);\n\n    num_pages   = 0;\n    alloc_pages = 0;\n    pages       = NULL;\n  }\n\n  if (alloc_headings)\n  {\n    free(heading_pages);\n    free(heading_tops);\n\n    num_headings   = 0;\n    alloc_headings = 0;\n    heading_pages  = NULL;\n    heading_tops   = NULL;\n  }\n\n  return (0);\n}\n\n\n\n//\n// 'pspdf_debug_stats()' - Display debug statistics for render memory use.\n//\n\nstatic void\npspdf_debug_stats()\n{\n  const char\t*debug;\t\t\t// HTMLDOC_DEBUG env var\n  int\t\ti;\t\t\t// Looping var\n  render_t\t*r;\t\t\t// Render node\n  int\t\tbytes;\t\t\t// Number of bytes\n\n\n  if ((debug = getenv(\"HTMLDOC_DEBUG\")) == NULL ||\n      (strstr(debug, \"all\") == NULL && strstr(debug, \"memory\") == NULL))\n    return;\n\n  bytes = alloc_headings * sizeof(int) * 2;\n\n  bytes += alloc_pages * sizeof(page_t);\n  for (i = 0; i < (int)num_pages; i ++)\n  {\n    for (r = pages[i].start; r != NULL; r = r->next)\n    {\n      bytes += sizeof(render_t);\n\n      if (r->type == RENDER_TEXT)\n        bytes += strlen((char *)r->data.text.buffer);\n    }\n  }\n\n  bytes += num_outpages * sizeof(outpage_t);\n  bytes += alloc_links * sizeof(link_t);\n  bytes += alloc_objects * sizeof(int);\n\n  progress_error(HD_ERROR_NONE, \"DEBUG: Render Data = %d kbytes\",\n                 (bytes + 1023) / 1024);\n}\n\n\n/*\n * 'pspdf_transform_coords()' - Transform page coordinates.\n */\n\nstatic void\npspdf_transform_coords(page_t *p,\t// I - Page\n                       float  &x,\t// IO - X coordinate\n\t\t       float  &y)\t// IO - Y coordinate\n{\n  float tx, ty;\t\t\t\t// Temporary X and Y\n\n\n  tx = x;\n  ty = y;\n  x  = tx * p->outmatrix[0][0] + ty * p->outmatrix[0][1] + p->outmatrix[0][2];\n  y  = tx * p->outmatrix[1][0] + ty * p->outmatrix[1][1] + p->outmatrix[1][2];\n}\n\n\n/*\n * 'pspdf_transform_page()' - Transform a page.\n */\n\nstatic void\npspdf_transform_page(int outpage,\t// I - Output page\n                     int pos,\t\t// I - Position on page\n                     int page)\t\t// I - Input page\n{\n  outpage_t\t*op;\t\t\t// Current output page\n  page_t\t*bp;\t\t\t// Current base page\n  page_t\t*p;\t\t\t// Current input page\n  int\t\tx, y;\t\t\t// Position on output page\n  double\tw, l,\t\t\t// Width and length of subpage\n\t\ttx, ty;\t\t\t// Translation values for subpage\n  double\tpw, pl;\t\t\t// Printable width and length of full page\n\n\n  DEBUG_printf((\"pspdf_transform_page(outpage = %d, pos = %d, page = %d)\\n\",\n                outpage, pos, page));\n\n  if (pos > 15)\n    progress_error(HD_ERROR_INTERNAL_ERROR, \"Internal error: pos = %d\", pos);\n\n  op             = outpages + outpage;\n  op->pages[pos] = page;\n  bp             = pages + op->pages[0];\n  p              = pages + page;\n  p->outpage     = outpage;\n  pw             = bp->width;\n  pl             = bp->length;\n\n  DEBUG_printf((\"    width = %d, length = %d\\n\", p->width, p->length));\n\n  switch (op->nup)\n  {\n    default :\n    case 1 :\n        p->outmatrix[0][0] = 1.0f;\n        p->outmatrix[1][0] = 0.0f;\n        p->outmatrix[0][1] = 0.0f;\n        p->outmatrix[1][1] = 1.0f;\n        p->outmatrix[0][2] = 0.0f;\n        p->outmatrix[1][2] = 0.0f;\n\tbreak;\n\n    case 2 :\n\tx = pos & 1;\n\n        l = pw;\n        w = l * p->width / p->length;\n\n        if (w > (pl * 0.5f))\n        {\n          w = pl * 0.5f;\n          l = w * p->length / p->width;\n        }\n\n        tx = 0.5 * (pl * 0.5 - w);\n        ty = 0.5 * (pw - l);\n\n        p->outmatrix[0][0] = 0.0f;\n        p->outmatrix[1][0] = (float)(w / p->width);\n        p->outmatrix[0][1] = (float)(-w / p->width);\n        p->outmatrix[1][1] = 0.0f;\n        p->outmatrix[0][2] = (float)(ty + pl * w / p->width);\n        p->outmatrix[1][2] = (float)(tx + x * pl / 2);\n\tbreak;\n\n    case 4 :\n        x = pos & 1;\n\ty = 1 - pos / 2;\n\n        w = pw * 0.5;\n\tl = w * p->length / p->width;\n\n\tif (l > (pl * 0.5))\n\t{\n\t  l = pl * 0.5;\n\t  w = l * p->width / p->length;\n\t}\n\n        tx = 0.5 * (pw * 0.5 - w);\n        ty = 0.5 * (pl * 0.5 - l);\n\n        p->outmatrix[0][0] = (float)(w / p->width);\n        p->outmatrix[1][0] = 0.0f;\n        p->outmatrix[0][1] = 0.0f;\n        p->outmatrix[1][1] = (float)(w / p->width);\n        p->outmatrix[0][2] = (float)(tx + x * pw / 2);\n        p->outmatrix[1][2] = (float)(ty + y * pl / 2);\n\tbreak;\n\n    case 6 :\n        x = pos % 3;\n\ty = pos / 3;\n\n        l = pw * 0.5;\n        w = l * p->width / p->length;\n\n        if (w > (pl * 0.333f))\n        {\n          w = pl * 0.333f;\n          l = w * p->length / p->width;\n        }\n\n        tx = 0.5 * (pl * 0.333 - w);\n        ty = 0.5 * (pw * 0.5 - l);\n\n        p->outmatrix[0][0] = 0.0f;\n        p->outmatrix[1][0] = (float)(w / p->width);\n        p->outmatrix[0][1] = (float)(-w / p->width);\n        p->outmatrix[1][1] = 0.0f;\n        p->outmatrix[0][2] = (float)(ty + y * pw / 2 + pl * w / p->width);\n        p->outmatrix[1][2] = (float)(tx + x * pl / 3);\n\tbreak;\n\n    case 9 :\n        x = pos % 3;\n\ty = 2 - pos / 3;\n\n        w = pw * 0.333;\n\tl = w * p->length / p->width;\n\n\tif (l > (pl * 0.333))\n\t{\n\t  l = pl * 0.333;\n\t  w = l * p->width / p->length;\n\t}\n\n        tx = 0.5 * (pw * 0.333 - w);\n        ty = 0.5 * (pl * 0.333 - l);\n\n        p->outmatrix[0][0] = (float)(w / p->width);\n        p->outmatrix[1][0] = 0.0f;\n        p->outmatrix[0][1] = 0.0f;\n        p->outmatrix[1][1] = (float)(w / p->width);\n        p->outmatrix[0][2] = (float)(tx + x * pw / 3);\n        p->outmatrix[1][2] = (float)(ty + y * pl / 3);\n\tbreak;\n\n    case 16 :\n        x = pos & 3;\n\ty = 3 - pos / 4;\n\n        w = pw * 0.25;\n\tl = w * p->length / p->width;\n\n\tif (l > (pl * 0.25))\n\t{\n\t  l = pl * 0.25;\n\t  w = l * p->width / p->length;\n\t}\n\n        tx = 0.5 * (pw * 0.25 - w);\n        ty = 0.5 * (pl * 0.25 - l);\n\n        p->outmatrix[0][0] = (float)(w / p->width);\n        p->outmatrix[1][0] = 0.0f;\n        p->outmatrix[0][1] = 0.0f;\n        p->outmatrix[1][1] = (float)(w / p->width);\n        p->outmatrix[0][2] = (float)(tx + x * pw / 4);\n        p->outmatrix[1][2] = (float)(ty + y * pl / 4);\n\tbreak;\n  }\n}\n\n\n/*\n * 'pspdf_prepare_outpages()' - Prepare output pages...\n */\n\nstatic void\npspdf_prepare_outpages()\n{\n  int\t\tc, i, j;\t/* Looping vars */\n  int\t\tnup;\t\t/* Current number-up value */\n  page_t\t*page;\t\t/* Current page */\n  outpage_t\t*outpage;\t/* Current output page */\n\n\n  // Allocate an output page array...\n  outpages = (outpage_t *)malloc(sizeof(outpage_t) * num_pages);\n\n  memset(outpages, -1, sizeof(outpage_t) * num_pages);\n\n  num_outpages = 0;\n  outpage      = outpages;\n\n  // Handle the title page, as needed...\n  if (TitlePage)\n  {\n    for (i = 0, j = 0, nup = -1, page = pages;\n         i < chapter_starts[1];\n\t i ++, page ++)\n    {\n      if (nup != page->nup)\n      {\n        if (j)\n\t{\n\t  // Break the current output page...\n\t  outpage ++;\n\t  num_outpages ++;\n\t}\n\n\tnup = page->nup;\n\tj   = 0;\n      }\n\n      if (!j)\n\toutpage->nup = nup;\n\n      pspdf_transform_page(num_outpages, j, i);\n      j ++;\n\n      if (j >= nup)\n      {\n        j = 0;\n\toutpage ++;\n\tnum_outpages ++;\n      }\n    }\n\n    if (j)\n    {\n      // Break the current output page...\n      outpage ++;\n      num_outpages ++;\n    }\n  }\n\n  // Loop through each chapter, adding pages as needed...\n  if (OutputType == OUTPUT_BOOK && TocLevels > 0)\n    c = 0;\n  else\n    c = 1;\n\n  for (; c <= TocDocCount; c ++)\n  {\n    if (chapter_starts[c] < 0)\n      continue;\n\n    chapter_outstarts[c] = num_outpages;\n\n    for (i = chapter_starts[c], j = 0, nup = -1, page = pages + i;\n         i <= chapter_ends[c];\n\t i ++, page ++)\n    {\n      if (nup != page->nup)\n      {\n        if (j)\n\t{\n\t  // Break the current output page...\n\t  outpage ++;\n\t  num_outpages ++;\n\t}\n\n\tnup = page->nup;\n\tj   = 0;\n      }\n\n      if (!j)\n\toutpage->nup = nup;\n\n      pspdf_transform_page(num_outpages, j, i);\n      j ++;\n\n      if (j >= nup)\n      {\n        j = 0;\n\toutpage ++;\n\tnum_outpages ++;\n      }\n    }\n\n    if (j)\n    {\n      // Break the current output page...\n      outpage ++;\n      num_outpages ++;\n    }\n\n    chapter_outends[c] = num_outpages;\n  }\n\n#ifdef DEBUG\n  for (c = 0; c <= TocDocCount; c ++)\n    printf(\"chapter_outstarts[%d] = %d, chapter_outends[%d] = %d\\n\",\n           c, chapter_outstarts[c], c, chapter_outends[c]);\n\n  printf(\"num_outpages = %d\\n\", (int)num_outpages);\n  for (i = 0, outpage = outpages; i < (int)num_outpages; i ++, outpage ++)\n  {\n    printf(\"outpage[%d]:\\tnup=%d, pages=[\", i, outpage->nup);\n    for (j = 0; j < outpage->nup; j ++)\n      printf(\" %d\", outpage->pages[j]);\n    puts(\" ]\");\n    page = pages + outpage->pages[0];\n    printf(\"\\t\\twidth = %d, length = %d\\n\", page->width, page->length);\n  }\n\n  for (c = 0; c <= TocDocCount; c ++)\n    printf(\"chapter_starts[%d] = %d, chapter_ends[%d] = %d\\n\",\n           c, chapter_starts[c], c, chapter_ends[c]);\n\n  for (i = 0; i < (int)num_pages; i ++)\n    printf(\"pages[%d]->outpage = %d\\n\", i, pages[i].outpage);\n\n  for (i = 0; i < (int)num_headings; i ++)\n    printf(\"heading_pages[%d] = %d\\n\", i, heading_pages[i]);\n\n  for (i = 0; i < (int)num_links; i ++)\n    printf(\"links[%d].name = \\\"%s\\\", page = %d\\n\", i,\n           links[i].name, links[i].page);\n#endif // DEBUG\n}\n\n\n/*\n * 'pspdf_prepare_page()' - Add headers/footers to page before writing...\n */\n\nstatic void\npspdf_prepare_page(int page)\t\t/* I - Page number */\n{\n  int\tprint_page;\t\t\t/* Printed page # */\n  char\tpage_text[64];\t\t\t/* Page number text */\n  int\ttop;\t\t\t\t/* Top of page */\n\n\n  DEBUG_printf((\"pspdf_prepare_page(%d)\\n\", page));\n\n /*\n  * Make a page number; use roman numerals for the table of contents\n  * and arabic numbers for all others...\n  */\n\n  if (chapter == 0 && OutputType == OUTPUT_BOOK)\n  {\n    print_page = page - chapter_starts[0] + 1;\n    strlcpy(page_text, format_number(print_page, 'i'), sizeof(page_text));\n  }\n  else if (chapter < 0)\n  {\n    print_page = 0;\n    // Safe because page_text is more than 6 chars\n    strlcpy(page_text, (page & 1) ? (char *)\"eltit\" : (char *)\"title\", sizeof(page_text));\n  }\n  else\n  {\n    print_page = page - chapter_starts[1] + 1;\n    strlcpy(page_text, format_number(print_page, '1'), sizeof(page_text));\n  }\n\n  DEBUG_printf((\"BEFORE page %d page_text is \\\"%s\\\"...\\n\", page, page_text));\n\n  DEBUG_printf((\"    header[0] = \\\"%s\\\"\\n\", pages[page].header[0]));\n  DEBUG_printf((\"    header[1] = \\\"%s\\\"\\n\", pages[page].header[1]));\n  DEBUG_printf((\"    header[2] = \\\"%s\\\"\\n\", pages[page].header[2]));\n\n /*\n  * Add page headings...\n  */\n\n  if (pages[page].landscape)\n  {\n    PagePrintWidth  = pages[page].length - pages[page].right - pages[page].left;\n    PagePrintLength = pages[page].width - pages[page].top - pages[page].bottom;\n  }\n  else\n  {\n    PagePrintWidth  = pages[page].width - pages[page].right - pages[page].left;\n    PagePrintLength = pages[page].length - pages[page].top - pages[page].bottom;\n  }\n\n  top = (int)(PagePrintLength - HeadFootSize);\n\n  if (chapter == 0)\n  {\n   /*\n    * Add table-of-contents header & footer...\n    */\n\n    pspdf_prepare_heading(page, print_page, pages[page].header, top,\n                          page_text, sizeof(page_text));\n    pspdf_prepare_heading(page, print_page, pages[page].footer, 0,\n                          page_text, sizeof(page_text));\n  }\n  else if (chapter > 0 && !title_page)\n  {\n   /*\n    * Add chapter header & footer...\n    */\n\n    if (page > chapter_starts[chapter] || OutputType != OUTPUT_BOOK)\n      pspdf_prepare_heading(page, print_page, pages[page].header, top,\n                            page_text, sizeof(page_text));\n    else\n      pspdf_prepare_heading(page, print_page, pages[page].header1, top,\n                            page_text, sizeof(page_text));\n    pspdf_prepare_heading(page, print_page, pages[page].footer, 0,\n                          page_text, sizeof(page_text));\n  }\n\n /*\n  * Copy the page number for the TOC...\n  */\n\n  strlcpy(pages[page].page_text, page_text, sizeof(pages[page].page_text));\n\n  DEBUG_printf((\"AFTER page %d page_text is \\\"%s\\\"...\\n\", page, page_text));\n}\n\n\n/*\n * 'pspdf_prepare_heading()' - Add headers/footers to page before writing...\n */\n\nstatic void\npspdf_prepare_heading(int   page,\t// I - Page number\n                      int   print_page,\t// I - Printed page number\n\t\t      uchar **format,\t// I - Page headings\n\t\t      int   y,\t\t// I - Baseline of heading\n\t\t      char  *page_text,\t// O - Page number text\n\t\t      int   page_len)\t// I - Size of page text\n{\n  int\t\tpos,\t\t\t// Position in heading\n\t\tdir;\t\t\t// Direction of page\n  char\t\t*number;\t\t// Page number\n  char\t\tbuffer[1024],\t\t// String buffer\n\t\t*bufptr,\t\t// Pointer into buffer\n\t\t*formatptr;\t\t// Pointer into format string\n  int\t\tformatlen;\t\t// Length of format command string\n  render_t\t*temp;\t\t\t// Render structure for titles, etc.\n\n\n  DEBUG_printf((\"pspdf_prepare_heading(%d, %d, [\\\"%s\\\",\\\"%s\\\",\\\"%s\\\"], %d, %p, %d)\\n\",\n                page, print_page, format[0], format[1], format[2], y,\n\t\t(void *)page_text, page_len));\n\n /*\n  * Add page headings...\n  */\n\n  if (PageDuplex && (page & 1))\n  {\n    dir    = -1;\n    format += 2;\n  }\n  else\n    dir = 1;\n\n  for (pos = 0; pos < 3; pos ++, format += dir)\n  {\n   /*\n    * Add the appropriate object...\n    */\n\n    if (!*format)\n      continue;\n\n    temp = NULL;\n\n    if (strncasecmp((char *)*format, \"$LOGOIMAGE\", 10) == 0 && logo_image)\n    {\n      // Insert the logo image...\n      if (y < (PagePrintLength / 2))\n\ttemp = new_render(page, RENDER_IMAGE, 0, y, logo_width,\n\t                  logo_height, logo_image);\n      else // Offset from top\n\ttemp = new_render(page, RENDER_IMAGE, 0,\n\t                  y + HeadFootSize - logo_height,\n\t                  logo_width, logo_height, logo_image);\n    }\n    else if (strncasecmp((char *)*format, \"$LETTERHEAD\", 11) == 0 && lh_image)\n    {\n      // Insert the logo image as a letterhead...\n      if (y < (PagePrintLength / 2))\n\ttemp = new_render(page, RENDER_IMAGE, 0, y, lh_width, lh_height, lh_image);\n      else // Offset from top\n\ttemp = new_render(page, RENDER_IMAGE, 0, y + HeadFootSize - lh_height, lh_width, lh_height, lh_image);\n    }\n    else if (strncasecmp((char *)*format, \"$HFIMAGE\", 8) == 0)\n    {\n      int\thfi;\t\t\t// Header/footer image index\n      char\t*hfp;\t\t\t// Pointer into $HFIMAGE\n\n\n      hfi = strtol((char*)((*format) + 8), &hfp, 10);\n\n      if (hfi < 0 || hfi >= MAX_HF_IMAGES || !(isspace(*hfp) || !*hfp))\n        progress_error(HD_ERROR_BAD_HF_STRING,\n\t               \"Bad $HFIMAGE... substitution on page %d.\", page + 1);\n      else\n      {\n        if (y < (PagePrintLength / 2))\n          temp = new_render(page, RENDER_IMAGE, 0, y, hfimage_width[hfi],\n                            hfimage_height[hfi], hfimage[hfi]);\n        else\n          temp = new_render(page, RENDER_IMAGE, 0,\n                            y + HeadFootSize - hfimage_height[hfi],\n                            hfimage_width[hfi], hfimage_height[hfi],\n\t\t\t    hfimage[hfi]);\n      }\n    }\n    else\n    {\n      // Otherwise format the text...\n      buffer[sizeof(buffer) - 1] = '\\0';\n\n      for (bufptr = buffer, formatptr = (char *)*format; *formatptr;)\n      {\n        if (*formatptr == '$')\n\t{\n\t  if (formatptr[1] == '$')\n\t  {\n\t    if (bufptr < (buffer + sizeof(buffer) - 1))\n\t      *bufptr++ = '$';\n\n\t    formatptr += 2;\n\t    continue;\n\t  }\n\t  else if (!formatptr[1])\n\t    break;\n\n          formatptr ++;\n\t  for (formatlen = 1; isalpha(formatptr[formatlen]); formatlen ++);\n\n\t  if (formatlen == 4 && strncasecmp(formatptr, \"PAGE\", 4) == 0)\n\t  {\n\t    if (formatptr[4] == '(' && formatptr[5] && formatptr[6] == ')')\n            {\n\t      number = format_number(print_page, formatptr[5]);\n\t      formatptr += 7;\n\t    }\n\t    else\n\t    {\n\t      number = format_number(print_page, '1');\n\t      formatptr += 4;\n\t    }\n\n            strlcpy(bufptr, number, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else if (formatlen == 5 && strncasecmp(formatptr, \"PAGES\", 5) == 0)\n\t  {\n\t    if (formatptr[5] == '(' && formatptr[6] && formatptr[7] == ')')\n            {\n\t      number = format_number(chapter_ends[TocDocCount] -\n\t                             chapter_starts[1] + 1, formatptr[6]);\n\t      formatptr += 8;\n\t    }\n\t    else\n\t    {\n\t      number = format_number(chapter_ends[TocDocCount] -\n\t                             chapter_starts[1] + 1, '1');\n\t      formatptr += 5;\n\t    }\n\n            strlcpy(bufptr, number, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else if (formatlen == 11 && strncasecmp(formatptr, \"CHAPTERPAGE\", 11) == 0)\n\t  {\n\t    int chapter_page;\n\n\t    chapter_page = print_page - chapter_starts[::chapter] +\n\t                   chapter_starts[1];\n\n\t    if (formatptr[11] == '(' && formatptr[12] && formatptr[13] == ')')\n            {\n\t      number = format_number(chapter_page, formatptr[12]);\n\t      formatptr += 14;\n\t    }\n\t    else\n\t    {\n\t      number = format_number(chapter_page, '1');\n\t      formatptr += 11;\n\t    }\n\n            strlcpy(bufptr, number, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else if (formatlen == 12 && strncasecmp(formatptr, \"CHAPTERPAGES\", 12) == 0)\n\t  {\n\t    if (formatptr[12] == '(' && formatptr[13] && formatptr[14] == ')')\n            {\n\t      number = format_number(chapter_ends[::chapter] -\n\t                             chapter_starts[::chapter] + 1,\n\t\t\t\t     formatptr[13]);\n\t      formatptr += 15;\n\t    }\n\t    else\n\t    {\n\t      number = format_number(chapter_ends[::chapter] -\n\t                             chapter_starts[::chapter] + 1, '1');\n\t      formatptr += 12;\n\t    }\n\n            strlcpy(bufptr, number, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else if (formatlen == 5 && strncasecmp(formatptr, \"TITLE\", 5) == 0)\n\t  {\n            formatptr += 5;\n\t    if (doc_title)\n\t    {\n              strlcpy(bufptr, (char *)doc_title, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t      bufptr += strlen(bufptr);\n\t    }\n\t  }\n\t  else if (formatlen == 7 && strncasecmp(formatptr, \"CHAPTER\", 7) == 0)\n\t  {\n            formatptr += 7;\n\t    if (pages[page].chapter)\n\t    {\n              strlcpy(bufptr, (char *)(pages[page].chapter), sizeof(buffer) - (size_t)(bufptr - buffer));\n\t      bufptr += strlen(bufptr);\n\t    }\n\t  }\n\t  else if (formatlen == 7 && strncasecmp(formatptr, \"HEADING\", 7) == 0)\n\t  {\n            formatptr += 7;\n\t    if (pages[page].heading)\n\t    {\n              strlcpy(bufptr, (char *)(pages[page].heading), sizeof(buffer) - (size_t)(bufptr - buffer));\n\t      bufptr += strlen(bufptr);\n\t    }\n\t  }\n\t  else if (formatlen == 4 && strncasecmp(formatptr, \"TIME\", 4) == 0)\n\t  {\n            formatptr += 4;\n            strftime(bufptr, sizeof(buffer) - 1 - (size_t)(bufptr - buffer), \"%X\", &doc_date);\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else if (formatlen == 4 && strncasecmp(formatptr, \"DATE\", 4) == 0)\n\t  {\n            formatptr += 4;\n            strftime(bufptr, sizeof(buffer) - 1 - (size_t)(bufptr - buffer), \"%x\", &doc_date);\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else if (formatlen == 3 && strncasecmp(formatptr, \"URL\", 3) == 0)\n\t  {\n            uchar *url = pages[page].url ? pages[page].url : (uchar *)\"Unknown\";\n\n            formatptr += 3;\n            strlcpy(bufptr, (char *)url, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else\n\t  {\n            progress_error(HD_ERROR_BAD_HF_STRING, \"Bad header/footer $ command on page %d.\", page + 1);\n\n            strlcpy(bufptr, formatptr - 1, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t    bufptr += strlen(bufptr);\n\t    formatptr += formatlen;\n\t  }\n\t}\n\telse if (bufptr < (buffer + sizeof(buffer) - 1))\n\t  *bufptr++ = *formatptr++;\n\telse\n\t  break;\n      }\n\n      *bufptr = '\\0';\n\n      temp = new_render(page, RENDER_TEXT, 0, y,\n                \tget_width((uchar *)buffer, HeadFootType,\n\t\t\t          HeadFootStyle, SIZE_P) * HeadFootSize /\n\t\t\t    _htmlSizes[SIZE_P],\n\t        \tHeadFootSize, (uchar *)buffer);\n\n      if (strstr((char *)*format, \"$PAGE\") ||\n          strstr((char *)*format, \"$CHAPTERPAGE\"))\n        strlcpy(page_text, buffer, (size_t)page_len);\n    }\n\n    if (temp == NULL)\n      continue;\n\n   /*\n    * Justify the object...\n    */\n\n    switch (pos)\n    {\n      case 0 : /* Left justified */\n          break;\n      case 1 : /* Centered */\n          temp->x = (float)((PagePrintWidth - temp->width) * 0.5);\n          break;\n      case 2 : /* Right justified */\n          temp->x = PagePrintWidth - temp->width;\n          break;\n    }\n\n   /*\n    * Set the text font and color...\n    */\n\n    if (temp->type == RENDER_TEXT)\n    {\n      temp->data.text.typeface = HeadFootType;\n      temp->data.text.style    = HeadFootStyle;\n      temp->data.text.size     = (float)HeadFootSize;\n\n      get_color(_htmlTextColor, temp->data.text.rgb);\n    }\n  }\n}\n\n\n/*\n * 'ps_write_document()' - Write all render entities to PostScript file(s).\n */\n\nstatic void\nps_write_document(uchar *author,\t/* I - Author of document */\n        \t  uchar *creator,\t/* I - Application that generated the HTML file */\n        \t  uchar *copyright,\t/* I - Copyright (if any) on the document */\n                  uchar *keywords,\t/* I - Search keywords */\n\t\t  uchar *subject,\t/* I - Subject */\n\t\t  uchar *lang)\t\t/* I - Language */\n{\n  FILE\t\t*out;\t\t\t/* Output file */\n  int\t\tpage;\t\t\t/* Current page # */\n  int\t\tfirst;\t\t\t/* First chapter */\n\n\n /*\n  * Write the title page(s)...\n  */\n\n  chapter = -1;\n  out     = NULL;\n\n  if (!OutputFiles)\n  {\n    out = open_file();\n\n    if (out == NULL)\n    {\n      progress_error(HD_ERROR_WRITE_ERROR,\n                     \"Unable to open output file - %s\\n\", strerror(errno));\n      return;\n    }\n\n    write_prolog(out, num_outpages, author, creator, copyright, keywords, subject);\n  }\n\n  if (OutputType == OUTPUT_BOOK && TocLevels > 0)\n    first = 0;\n  else\n    first = 1;\n\n  if (TitlePage)\n  {\n    if (OutputFiles)\n    {\n      out = open_file();\n      write_prolog(out, chapter_outstarts[first], author, creator, copyright,\n                   keywords, subject);\n    }\n\n    for (page = 0; page < chapter_outstarts[first]; page ++)\n      ps_write_outpage(out, page);\n\n    if (OutputFiles)\n    {\n      write_trailer(out, 0, lang);\n\n      progress_error(HD_ERROR_NONE, \"BYTES: %ld\", ftell(out));\n\n      fclose(out);\n    }\n  }\n\n  for (chapter = first; chapter <= TocDocCount; chapter ++)\n  {\n    if (chapter_starts[chapter] < 0)\n      continue;\n\n    if (OutputFiles)\n    {\n      out = open_file();\n      if (out == NULL)\n      {\n        progress_error(HD_ERROR_WRITE_ERROR,\n\t               \"Unable to create output file - %s\\n\", strerror(errno));\n        return;\n      }\n\n      write_prolog(out, chapter_outends[chapter] - chapter_outstarts[chapter],\n                   author, creator, copyright, keywords, subject);\n    }\n\n    for (page = chapter_outstarts[chapter];\n         page < chapter_outends[chapter];\n         page ++)\n      ps_write_outpage(out, page);\n\n   /*\n    * Close the output file as necessary...\n    */\n\n    if (OutputFiles)\n    {\n      write_trailer(out, 0, lang);\n\n      progress_error(HD_ERROR_NONE, \"BYTES: %ld\", ftell(out));\n\n      fclose(out);\n    }\n  }\n\n /*\n  * Close the output file as necessary...\n  */\n\n  if (!OutputFiles)\n  {\n    write_trailer(out, 0, lang);\n\n    progress_error(HD_ERROR_NONE, \"BYTES: %ld\", ftell(out));\n\n    if (out != stdout)\n      fclose(out);\n  }\n\n  if (Verbosity)\n    progress_hide();\n}\n\n\n/*\n * 'ps_write_outpage()' - Write an output page.\n */\n\nstatic void\nps_write_outpage(FILE *out,\t/* I - Output file */\n                 int  outpage)\t/* I - Output page number */\n{\n  int\t\tfile_page;\t/* Current page # in document */\n  page_t\t*p;\t\t/* Current page */\n  outpage_t\t*op;\t\t/* Current output page */\n  int\t\ti;\t\t/* Looping var */\n\n\n  if (outpage < 0 || outpage >= (int)num_outpages)\n    return;\n\n  op = outpages + outpage;\n  p  = pages + op->pages[0];\n\n  DEBUG_printf((\"ps_write_outpage(%p, %d)\\n\", (void *)out, outpage));\n\n /*\n  * Let the user know which page we are writing...\n  */\n\n  if (Verbosity)\n  {\n    progress_show(\"Writing page %s...\", p->page_text);\n    progress_update(100 * outpage / (int)num_outpages);\n  }\n\n /*\n  * Figure out the page number in the file...\n  */\n\n  if (OutputFiles && chapter >= 0)\n    file_page = outpage - chapter_outstarts[chapter] + 1;\n  else if (chapter < 0)\n    file_page = outpage + 1;\n  else if (chapter == 0)\n  {\n    if (TitlePage)\n      file_page = outpage + 1;\n    else\n      file_page = outpage - chapter_outstarts[0] + 1;\n  }\n  else\n  {\n    if (TitlePage)\n      file_page = outpage + 1;\n    else\n      file_page = outpage - chapter_outstarts[1] + 1;\n  }\n\n /*\n  * Output the page prolog...\n  */\n\n  fprintf(out, \"%%%%Page: (%s) %d\\n\", p->page_text, file_page);\n  if (op->nup == 1)\n  {\n    if (p->duplex && !(file_page & 1))\n      fprintf(out, \"%%%%PageBoundingBox: %d %d %d %d\\n\",\n              p->right, p->bottom, p->width - p->left, p->length - p->top);\n    else\n      fprintf(out, \"%%%%PageBoundingBox: %d %d %d %d\\n\",\n              p->left, p->bottom, p->width - p->right, p->length - p->top);\n  }\n  else\n    fprintf(out, \"%%%%PageBoundingBox: 0 0 %d %d\\n\", p->width, p->length);\n\n  if (PSLevel > 1 && PSCommands)\n  {\n    fputs(\"%%BeginPageSetup\\n\", out);\n\n    if (p->width == 612 && p->length == 792)\n      fputs(\"%%BeginFeature: *PageSize Letter\\n\", out);\n    else if (p->width == 612 && p->length == 1008)\n      fputs(\"%%BeginFeature: *PageSize Legal\\n\", out);\n    else if (p->width == 792 && p->length == 1224)\n      fputs(\"%%BeginFeature: *PageSize Tabloid\\n\", out);\n    else if (p->width == 842 && p->length == 1190)\n      fputs(\"%%BeginFeature: *PageSize A3\\n\", out);\n    else if (p->width == 595 && p->length == 842)\n      fputs(\"%%BeginFeature: *PageSize A4\\n\", out);\n    else\n      fprintf(out, \"%%%%BeginFeature: *PageSize w%dh%d\\n\", p->width,\n\t      p->length);\n\n    fprintf(out, \"%d %d SetPageSize\\n\", p->width, p->length);\n    fputs(\"%%EndFeature\\n\", out);\n\n    if (p->duplex)\n    {\n      if (p->landscape)\n      {\n\tfputs(\"%%BeginFeature: *Duplex DuplexTumble\\n\", out);\n\tfputs(\"true true SetDuplexMode\\n\", out);\n        fputs(\"%%EndFeature\\n\", out);\n      }\n      else\n      {\n\tfputs(\"%%BeginFeature: *Duplex DuplexNoTumble\\n\", out);\n\tfputs(\"true false SetDuplexMode\\n\", out);\n        fputs(\"%%EndFeature\\n\", out);\n      }\n    }\n    else\n    {\n      fputs(\"%%BeginFeature: *Duplex None\\n\", out);\n      fputs(\"false false SetDuplexMode\\n\", out);\n      fputs(\"%%EndFeature\\n\", out);\n    }\n\n    if (p->media_color[0])\n    {\n      fprintf(out, \"%%%%BeginFeature: *MediaColor %s\\n\", p->media_color);\n      fprintf(out, \"(%s) SetMediaColor\\n\", p->media_color);\n      fputs(\"%%EndFeature\\n\", out);\n    }\n\n    if (p->media_position)\n    {\n      fprintf(out, \"%%%%BeginFeature: *InputSlot Tray%d\\n\",\n              p->media_position);\n      fprintf(out, \"%d SetMediaPosition\\n\", p->media_position);\n      fputs(\"%%EndFeature\\n\", out);\n    }\n\n    if (p->media_type[0])\n    {\n      fprintf(out, \"%%%%BeginFeature: *MediaType %s\\n\", p->media_type);\n      fprintf(out, \"(%s) SetMediaType\\n\", p->media_type);\n      fputs(\"%%EndFeature\\n\", out);\n    }\n\n    fputs(\"%%EndPageSetup\\n\", out);\n  }\n\n /*\n  * Render all of the pages...\n  */\n\n  switch (op->nup)\n  {\n    case 1 :\n        ps_write_page(out, op->pages[0]);\n\tbreak;\n\n    default :\n        for (i = 0; i < op->nup; i ++)\n\t{\n\t  if (op->pages[i] < 0)\n\t    break;\n\n          p = pages + op->pages[i];\n\n          fprintf(out, \"GS[%.3f %.3f %.3f %.3f %.3f %.3f]CM\\n\",\n\t          p->outmatrix[0][0], p->outmatrix[1][0],\n\t          p->outmatrix[0][1], p->outmatrix[1][1],\n\t          p->outmatrix[0][2], p->outmatrix[1][2]);\n          ps_write_page(out, op->pages[i]);\n\t  fputs(\"GR\\n\", out);\n\t}\n\tbreak;\n  }\n\n /*\n  * Output the page trailer...\n  */\n\n  fputs(\"SP\\n\", out);\n  fflush(out);\n}\n\n\n/*\n * 'ps_write_page()' - Write all render entities on a page to a PostScript file.\n */\n\nstatic void\nps_write_page(FILE  *out,\t/* I - Output file */\n              int   page)\t/* I - Page number */\n{\n  render_t\t*r,\t\t/* Render pointer */\n\t\t*next;\t\t/* Next render */\n  page_t\t*p;\t\t/* Current page */\n  const char\t*debug;\t\t/* HTMLDOC_DEBUG environment variable */\n\n\n  if (page < 0 || page >= (int)alloc_pages)\n    return;\n\n  p = pages + page;\n\n  DEBUG_printf((\"ps_write_page(%p, %d)\\n\", (void *)out, page));\n\n /*\n  * Clear the render cache...\n  */\n\n  render_typeface = -1;\n  render_style    = -1;\n  render_size     = -1;\n  render_rgb[0]   = -1.0f;\n  render_rgb[1]   = -1.0f;\n  render_rgb[2]   = -1.0f;\n  render_x        = -1.0f;\n  render_y        = -1.0f;\n  render_spacing  = -1.0f;\n\n /*\n  * Setup the page...\n  */\n\n  fputs(\"GS\\n\", out);\n\n  if (p->landscape)\n  {\n    if (p->duplex && (page & 1))\n      fprintf(out, \"0 %d T -90 RO\\n\", p->length);\n    else\n      fprintf(out, \"%d 0 T 90 RO\\n\", p->width);\n  }\n\n  write_background(page, out);\n\n  if (p->duplex && (page & 1))\n    fprintf(out, \"%d %d T\\n\", p->right, p->bottom);\n  else\n    fprintf(out, \"%d %d T\\n\", p->left, p->bottom);\n\n /*\n  * Render all graphics elements...\n  */\n\n  for (r = p->start; r != NULL; r = r->next)\n    switch (r->type)\n    {\n      case RENDER_BOX :\n\t  set_color(out, r->data.box);\n\t  set_pos(out, r->x, r->y);\n\t  if (r->height > 0.0f)\n            fprintf(out, \" %.1f %.1f F\\n\", r->width, r->height);\n\t  else\n            fprintf(out, \" %.1f L\\n\", r->width);\n\n\t  render_x = -1.0f;\n\t  break;\n\n      case RENDER_IMAGE :\n          if (r->width > 0.01f && r->height > 0.01f)\n            write_image(out, r);\n          break;\n    }\n\n /*\n  * Render all text elements, freeing used memory as we go...\n  */\n\n  for (r = p->start, next = NULL; r != NULL; r = next)\n  {\n    if (r->type == RENDER_TEXT)\n      write_text(out, r);\n\n    next = r->next;\n    free(r);\n  }\n\n  p->start = NULL;\n\n  if ((debug = getenv(\"HTMLDOC_DEBUG\")) != NULL && strstr(debug, \"margin\"))\n  {\n    // Show printable area...\n    fprintf(out, \"1 0 1 C 0 0 %d %d B\\n\", p->width - p->right - p->left,\n        \t p->length - p->top - p->bottom);\n  }\n\n /*\n  * Output the page trailer...\n  */\n\n  fputs(\"GR\\n\", out);\n}\n\n\n/*\n * 'ps_write_background()' - Write a background image...\n */\n\nstatic void\nps_write_background(FILE *out)\t\t/* I - Output file */\n{\n  int\ty,\t\t\t\t/* Current line */\n\tpwidth;\t\t\t\t/* Pixel width */\n\n\n  if (!background_image->pixels)\n    image_load(background_image->filename, !OutputColor, 1);\n\n  pwidth = background_image->width * background_image->depth;\n\n  fputs(\"/BG[\", out);\n  for (y = 0; y < background_image->height; y ++)\n  {\n    putc('<', out);\n    ps_hex(out, background_image->pixels + y * pwidth, pwidth);\n    putc('>', out);\n  }\n  fputs(\"]def\", out);\n\n  image_unload(background_image);\n}\n\n\n/*\n * 'pdf_write_document()' - Write all render entities to a PDF file.\n */\n\nstatic void\npdf_write_document(uchar  *author,\t// I - Author of document\n        \t   uchar  *creator,\t// I - Application that generated the HTML file\n        \t   uchar  *copyright,\t// I - Copyright (if any) on the document\n                   uchar  *keywords,\t// I - Search keywords\n\t\t   uchar  *subject,\t// I - Subject\n\t\t   uchar  *lang,\t// I - Language\n\t\t   tree_t *doc,\t\t// I - Document\n                   tree_t *toc)\t\t// I - Table of contents tree\n{\n  int\t\ti;\t\t\t// Looping variable\n  FILE\t\t*out;\t\t\t// Output file\n  int\t\toutpage,\t\t// Current page #\n\t\theading;\t\t// Current heading #\n  int\t\tbytes;\t\t\t// Number of bytes\n  char\t\tbuffer[8192];\t\t// Copy buffer\n  int\t\tnum_images;\t\t// Number of images in document\n  image_t\t**images;\t\t// Pointers to images\n  render_t\ttemp;\t\t\t// Dummy rendering data...\n\n\n  // Open the output file...\n  out = open_file();\n  if (out == NULL)\n  {\n    progress_error(HD_ERROR_WRITE_ERROR,\n                   \"Unable to write document file - %s\\n\", strerror(errno));\n    return;\n  }\n\n  // Clear the objects array...\n  num_objects   = 0;\n  alloc_objects = 0;\n  objects       = NULL;\n\n  // Write the prolog...\n  write_prolog(out, num_outpages, author, creator, copyright, keywords, subject);\n\n  // Write images as needed...\n  num_images = image_getlist(&images);\n\n  for (i = 0; i < num_images; i ++)\n  {\n    int\thfi;\t\t\t\t// Header/footer image index\n\n\n    for (hfi = 0; hfi < MAX_HF_IMAGES; hfi ++)\n      if (images[i] == hfimage[hfi])\n        break;\n\n    if (images[i]->use > 1 || images[i]->mask ||\n        (images[i]->width * images[i]->height * images[i]->depth) > 65536 ||\n\timages[i] == background_image ||\n\timages[i] == logo_image ||\n\thfi < MAX_HF_IMAGES)\n    {\n      progress_show(\"Writing image %d (%s)...\", i + 1, images[i]->filename);\n      progress_update(100 * i / num_images);\n\n      temp.data.image = images[i];\n      write_image(out, &temp, 1);\n    }\n  }\n\n  // Write links and target names...\n  pdf_write_links(out);\n  if (PDFVersion >= 12)\n    pdf_write_names(out);\n\n  // Verify that everything is working so far...\n  pdf_start_object(out);\n\n  if (pages_object != (int)num_objects)\n    progress_error(HD_ERROR_INTERNAL_ERROR,\n                   \"Internal error: pages_object != num_objects\");\n\n  fputs(\"/Type/Pages\", out);\n  fprintf(out, \"/Count %d\", (int)num_outpages);\n  fputs(\"/Kids[\", out);\n\n  for (outpage = 0; outpage < (int)num_outpages; outpage ++)\n    fprintf(out, \"%d 0 R\\n\", pages_object + outpage * 2 + 1);\n\n  fputs(\"]\", out);\n  pdf_end_object(out);\n\n  for (outpage = 0; outpage < (int)num_outpages; outpage ++)\n    pdf_write_outpage(out, outpage);\n\n  if (OutputType == OUTPUT_BOOK && TocLevels > 0)\n  {\n   /*\n    * Write the outline tree using the table-of-contents...\n    */\n\n    heading = 0;\n#ifdef DEBUG_TOC\n    pdf_text_contents(out, toc);\n#endif // DEBUG_TOC\n    pdf_write_contents(out, toc, 0, 0, 0, &heading);\n  }\n  else\n  {\n   /*\n    * Write the outline tree using the HTML files.\n    */\n\n    pdf_write_files(out, doc);\n  }\n\n /*\n  * Write the trailer and close the output file...\n  */\n\n  write_trailer(out, 0, lang);\n\n  progress_error(HD_ERROR_NONE, \"BYTES: %ld\", ftell(out));\n\n  if (CGIMode)\n  {\n    const char\t*meta_filename = (const char *)htmlGetMeta(doc, (uchar *)\"HTMLDOC.filename\");\n    const char\t*filename;\n\n    if (meta_filename)\n    {\n      if ((filename = strrchr(meta_filename, '/')) != NULL)\n        filename ++;\n      else\n        filename = meta_filename;\n    }\n    else\n      filename = \"htmldoc.pdf\";\n\n    // In CGI mode, we only produce PDF output to stdout...\n    printf(\"Content-Type: application/pdf\\r\\n\"\n\t   \"Content-Length: %ld\\r\\n\"\n\t   \"Content-Disposition: inline; filename=\\\"%s\\\"\\r\\n\"\n\t   \"Accept-Ranges: none\\r\\n\"\n\t   \"X-Creator: HTMLDOC \" SVERSION \"\\r\\n\"\n\t   \"\\r\\n\", ftell(out), filename);\n  }\n\n  fclose(out);\n\n  //\n  // If we are sending the output to stdout, copy the temp file now...\n  //\n\n  if (!OutputPath[0])\n  {\n#ifdef WIN32\n    // Make sure we are in binary mode...  stupid Microsoft!\n    setmode(1, O_BINARY);\n#elif defined(__EMX__)\n   // OS/2 has a setmode for FILE's...\n   fflush(stdout);\n   _fsetmode(stdout, \"b\");\n#endif // WIN32 || __EMX__\n\n    // Open the temporary file and copy it to stdout...\n    out = fopen(stdout_filename, \"rb\");\n\n    while ((bytes = fread(buffer, 1, sizeof(buffer), out)) > 0)\n      fwrite(buffer, 1, (size_t)bytes, stdout);\n\n    // Close the temporary file (it is removed when the program exits...)\n    fclose(out);\n  }\n\n  // Clear the objects array...\n  if (alloc_objects)\n  {\n    free(objects);\n\n    num_objects   = 0;\n    alloc_objects = 0;\n    objects       = NULL;\n  }\n\n  if (Verbosity)\n    progress_hide();\n}\n\n\n/*\n * 'pdf_write_resources()' - Write the resources dictionary for a page.\n */\n\nstatic void\npdf_write_resources(FILE *out,\t\t/* I - Output file */\n                    int  outpage)\t/* I - Output page for resources */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  outpage_t\t*op;\t\t\t/* Current output page */\n  page_t\t*p;\t\t\t/* Current page */\n  render_t\t*r;\t\t\t/* Render pointer */\n  int\t\tfonts_used[TYPE_MAX * STYLE_MAX];\n\t\t\t\t\t/* Non-zero if the page uses a font */\n  int\t\timages_used;\t\t/* Non-zero if the page uses an image */\n  int\t\ttext_used;\t\t/* Non-zero if the page uses text */\n  static const char *effects[] =\t/* Effects and their commands */\n\t\t{\n\t\t  \"\",\n\t\t  \"/S/Box/M/I\",\n\t\t  \"/S/Box/M/O\",\n\t\t  \"/S/Dissolve\",\n\t\t  \"/S/Glitter/Di 270\",\n\t\t  \"/S/Glitter/Di 315\",\n\t\t  \"/S/Glitter/Di 0\",\n\t\t  \"/S/Blinds/Dm/H\",\n\t\t  \"/S/Split/Dm/H/M/I\",\n\t\t  \"/S/Split/Dm/H/M/O\",\n\t\t  \"/S/Blinds/Dm/V\",\n\t\t  \"/S/Split/Dm/V/M/I\",\n\t\t  \"/S/Split/Dm/V/M/O\",\n\t\t  \"/S/Wipe/Di 270\",\n\t\t  \"/S/Wipe/Di 180\",\n\t\t  \"/S/Wipe/Di 0\",\n\t\t  \"/S/Wipe/Di 90\"\n\t\t};\n\n\n  memset(fonts_used, 0, sizeof(fonts_used));\n  images_used = background_image != NULL;\n  text_used   = 0;\n\n  op = outpages + outpage;\n  for (i = 0; i < op->nup; i ++)\n  {\n    if (op->pages[i] < 0)\n      break;\n\n    p = pages + op->pages[i];\n\n    for (r = p->start; r != NULL; r = r->next)\n      if (r->type == RENDER_IMAGE)\n\timages_used = 1;\n      else if (r->type == RENDER_TEXT)\n      {\n\ttext_used = 1;\n\tfonts_used[r->data.text.typeface * 4 + r->data.text.style] = 1;\n      }\n  }\n\n  fputs(\"/Resources<<\", out);\n\n  if (!images_used)\n    fputs(\"/ProcSet[/PDF/Text]\", out);\n  else if (PDFVersion >= 12)\n  {\n    if (OutputColor)\n      fputs(\"/ProcSet[/PDF/Text/ImageB/ImageC/ImageI]\", out);\n    else\n      fputs(\"/ProcSet[/PDF/Text/ImageB/ImageI]\", out);\n  }\n  else\n  {\n    if (OutputColor)\n      fputs(\"/ProcSet[/PDF/Text/ImageB/ImageC]\", out);\n    else\n      fputs(\"/ProcSet[/PDF/Text/ImageB]\", out);\n  }\n\n  if (text_used)\n  {\n    fputs(\"/Font<<\", out);\n    for (i = 0; i < (TYPE_MAX * STYLE_MAX); i ++)\n      if (fonts_used[i])\n\tfprintf(out, \"/F%x %d 0 R\", i, font_objects[i]);\n    fputs(\">>\", out);\n  }\n\n  fputs(\"/XObject<<\", out);\n\n  for (i = 0; i < op->nup; i ++)\n  {\n    if (op->pages[i] < 0)\n      break;\n\n    p = pages + op->pages[i];\n\n    for (r = p->start; r != NULL; r = r->next)\n      if (r->type == RENDER_IMAGE && r->data.image->obj)\n\tfprintf(out, \"/I%d %d 0 R\", r->data.image->obj, r->data.image->obj);\n  }\n\n  if (background_image)\n    fprintf(out, \"/I%d %d 0 R\", background_image->obj,\n            background_image->obj);\n\n  fputs(\">>>>\", out);\n\n  if (PDFEffect)\n    fprintf(out, \"/Dur %.0f/Trans<</Type/Trans/D %.1f%s>>\", PDFPageDuration,\n            PDFEffectDuration, effects[PDFEffect]);\n}\n\n\n/*\n * 'pdf_write_outpage()' - Write an output page.\n */\n\nstatic void\npdf_write_outpage(FILE *out,\t/* I - Output file */\n                  int  outpage)\t/* I - Output page number */\n{\n  int\t\ti;\t\t/* Looping var */\n  page_t\t*p;\t\t/* Current page */\n  outpage_t\t*op;\t\t/* Output page */\n\n\n  DEBUG_printf((\"pdf_write_outpage(out = %p, outpage = %d)\\n\", (void *)out, outpage));\n\n  if (outpage < 0 || outpage >= (int)num_outpages)\n    return;\n\n  op = outpages + outpage;\n  p  = pages + op->pages[0];\n\n  DEBUG_printf((\"op->pages[0] = %d (%dx%d)\\n\", op->pages[0], p->width,\n                p->length));\n\n /*\n  * Let the user know which page we are writing...\n  */\n\n  if (Verbosity)\n  {\n    progress_show(\"Writing page %s...\", p->page_text);\n    progress_update(100 * outpage / (int)num_outpages);\n  }\n\n /*\n  * Output the page prolog...\n  */\n\n  pdf_start_object(out);\n\n  fputs(\"/Type/Page\", out);\n  fprintf(out, \"/Parent %d 0 R\", pages_object);\n  fprintf(out, \"/Contents %d 0 R\", (int)num_objects + 1);\n  if (p->landscape)\n    fprintf(out, \"/MediaBox[0 0 %d %d]\", p->length, p->width);\n  else\n    fprintf(out, \"/MediaBox[0 0 %d %d]\", p->width, p->length);\n\n  pdf_write_resources(out, outpage);\n\n /*\n  * Actions (links)...\n  */\n\n  if (op->annot_object > 0)\n    fprintf(out, \"/Annots %d 0 R\", op->annot_object);\n\n  pdf_end_object(out);\n\n  pdf_start_object(out);\n\n  if (Compression)\n    fputs(\"/Filter/FlateDecode\", out);\n\n  pdf_start_stream(out);\n\n  flate_open_stream(out);\n\n /*\n  * Render all of the pages...\n  */\n\n  switch (op->nup)\n  {\n    case 1 :\n        pdf_write_page(out, op->pages[0]);\n\tbreak;\n\n    default :\n        for (i = 0; i < op->nup; i ++)\n\t{\n\t  if (op->pages[i] < 0)\n\t    break;\n\n          p = pages + op->pages[i];\n\n          flate_printf(out, \"q %.3f %.3f %.3f %.3f %.3f %.3f cm\\n\",\n\t               p->outmatrix[0][0], p->outmatrix[1][0],\n\t               p->outmatrix[0][1], p->outmatrix[1][1],\n\t               p->outmatrix[0][2], p->outmatrix[1][2]);\n          pdf_write_page(out, op->pages[i]);\n\t  flate_puts(\"Q\\n\", out);\n\t}\n\tbreak;\n  }\n\n /*\n  * Close out the page...\n  */\n\n  flate_close_stream(out);\n\n  pdf_end_object(out);\n}\n\n\n/*\n * 'pdf_write_page()' - Write a page to a PDF file.\n */\n\nstatic void\npdf_write_page(FILE  *out,\t/* I - Output file */\n               int   page)\t/* I - Page number */\n{\n  render_t\t*r,\t\t/* Render pointer */\n\t\t*next;\t\t/* Next render */\n  float\t\tbox[3];\t\t/* RGB color for boxes */\n  page_t\t*p;\t\t/* Current page */\n  const char\t*debug;\t\t/* HTMLDOC_DEBUG environment variable */\n\n\n  if (page < 0 || page >= (int)alloc_pages)\n    return;\n\n  p = pages + page;\n\n /*\n  * Clear the render cache...\n  */\n\n  render_rgb[0]   = -1.0f;\n  render_rgb[1]   = -1.0f;\n  render_rgb[2]   = -1.0f;\n  render_x        = -1.0f;\n  render_y        = -1.0f;\n\n /*\n  * Output the page header...\n  */\n\n  flate_puts(\"q\\n\", out);\n  write_background(page, out);\n\n  if (p->duplex && (page & 1))\n    flate_printf(out, \"1 0 0 1 %d %d cm\\n\", p->right,\n                 p->bottom);\n  else\n    flate_printf(out, \"1 0 0 1 %d %d cm\\n\", p->left,\n                 p->bottom);\n\n /*\n  * Render all graphics elements...\n  */\n\n  box[0] = -1.0f;\n  box[1] = -1.0f;\n  box[2] = -1.0f;\n\n  for (r = p->start; r != NULL; r = r->next)\n    switch (r->type)\n    {\n      case RENDER_IMAGE :\n          if (r->width > 0.01f && r->height > 0.01f)\n            write_image(out, r);\n          break;\n\n      case RENDER_BOX :\n\t  if (r->height == 0.0)\n\t  {\n            if (box[0] != r->data.box[0] ||\n\t\tbox[1] != r->data.box[1] ||\n\t\tbox[2] != r->data.box[2])\n            {\n              box[0] = r->data.box[0];\n\t      box[1] = r->data.box[1];\n\t      box[2] = r->data.box[2];\n\n\t      if (OutputColor)\n        \tflate_printf(out, \"%.2f %.2f %.2f RG\\n\", box[0], box[1], box[2]);\n              else\n        \tflate_printf(out, \"%.2f G\\n\",\n\t\t             box[0] * 0.31f + box[1] * 0.61f + box[2] * 0.08f);\n            }\n\n            flate_printf(out, \"%.1f %.1f m %.1f %.1f l S\\n\",\n                \t r->x, r->y, r->x + r->width, r->y);\n\t  }\n\t  else\n\t  {\n            set_color(out, r->data.box);\n            flate_printf(out, \"%.1f %.1f %.1f %.1f re f\\n\",\n                \t r->x, r->y, r->width, r->height);\n\t  }\n\t  break;\n    }\n\n /*\n  * Render all text elements, freeing used memory as we go...\n  */\n\n  flate_puts(\"BT\\n\", out);\n\n  render_typeface = -1;\n  render_style    = -1;\n  render_size     = -1;\n  render_x        = -1.0f;\n  render_y        = -1.0f;\n  render_spacing  = -1.0f;\n\n  for (r = p->start, next = NULL; r != NULL; r = next)\n  {\n    if (r->type == RENDER_TEXT)\n      write_text(out, r);\n\n    next = r->next;\n    free(r);\n  }\n\n  p->start = NULL;\n\n  flate_puts(\"ET\\n\", out);\n\n  if ((debug = getenv(\"HTMLDOC_DEBUG\")) != NULL && strstr(debug, \"margin\"))\n  {\n    // Show printable area...\n    flate_printf(out, \"1 0 1 RG 0 0 %d %d re S\\n\", p->width - p->right - p->left,\n        \t p->length - p->top - p->bottom);\n  }\n\n /*\n  * Output the page trailer...\n  */\n\n  flate_puts(\"Q\\n\", out);\n}\n\n\n#ifdef DEBUG_TOC\nstatic void\npdf_text_contents(FILE *out, tree_t *toc, int indent)\n{\n  static const char *spaces = \"                                \"\n                              \"                                \";\n\n  if (indent > 16)\n    indent = 16;\n\n  while (toc)\n  {\n    fprintf(out, \"%% %s<%s>\", spaces + 64 - 4 * indent,\n            _htmlMarkups[toc->markup]);\n\n    switch (toc->markup)\n    {\n      case MARKUP_A :\n          tree_t *temp;\n\n          for (temp = toc->child; temp; temp = temp->next)\n\t    fputs((char *)temp->data, out);\n          break;\n\n      default :\n          fputs(\"\\n\", out);\n\t  pdf_text_contents(out, toc->child, indent + 1);\n\t  fprintf(out, \"%% %s\", spaces + 64 - 4 * indent);\n          break;\n    }\n\n    fprintf(out, \"</%s>\\n\", _htmlMarkups[toc->markup]);\n\n    toc = toc->next;\n  }\n}\n#endif // DEBUG_TOC\n\n\n/*\n * 'pdf_write_contents()' - Write the table of contents as outline records to\n *                          a PDF file.\n */\n\nstatic void\npdf_write_contents(FILE   *out,\t\t\t/* I - Output file */\n                   tree_t *toc,\t\t\t/* I - Table of contents tree */\n                   int    parent,\t\t/* I - Parent outline object */\n                   int    prev,\t\t\t/* I - Previous outline object */\n                   int    next,\t\t\t/* I - Next outline object */\n                   int    *heading)\t\t/* IO - Current heading # */\n{\n  int\t\ti,\t\t\t\t/* Looping var */\n\t\tthisobj,\t\t\t/* This object */\n\t\tentry,\t\t\t\t/* TOC entry object */\n\t\tcount;\t\t\t\t/* Number of entries at this level */\n  uchar\t\t*text;\t\t\t\t/* Entry text */\n  tree_t\t*temp;\t\t\t\t/* Looping var */\n  int\t\t*entry_counts,\t\t\t/* Number of sub-entries for this entry */\n\t\t*entry_objects;\t\t\t/* Objects for each entry */\n  tree_t\t**entries;\t\t\t/* Pointers to each entry */\n  float\t\tx, y;\t\t\t\t/* Position of link */\n\n\n /*\n  * Make an object for this entry...\n  */\n\n  if (toc == NULL)\n  {\n   /*\n    * This is for the Table of Contents page...\n    */\n\n    thisobj = pdf_start_object(out);\n\n    fprintf(out, \"/Parent %d 0 R\", parent);\n\n    fputs(\"/Title\", out);\n    write_utf16(out, (uchar *)TocTitle);\n\n    x = 0.0f;\n    y = PagePrintLength + PageBottom;\n    pspdf_transform_coords(pages + chapter_starts[0], x, y);\n\n    fprintf(out, \"/Dest[%d 0 R/XYZ %.0f %.0f 0]\",\n            pages_object + 2 * chapter_outstarts[0] + 1, x, y);\n\n    if (prev > 0)\n      fprintf(out, \"/Prev %d 0 R\", prev);\n\n    if (next > 0)\n      fprintf(out, \"/Next %d 0 R\", next);\n\n    pdf_end_object(out);\n    return;\n  }\n\n /*\n  * Allocate the arrays...  Add 1 to hold the TOC at the top level...\n  */\n\n  if ((entry_counts = (int *)calloc(sizeof(int), num_headings + 1)) == NULL)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY,\n                   \"Unable to allocate memory for %d headings - %s\",\n                   (int)num_headings, strerror(errno));\n    return;\n  }\n\n  if ((entry_objects = (int *)calloc(sizeof(int), num_headings + 1)) == NULL)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY,\n                   \"Unable to allocate memory for %d headings - %s\",\n                   (int)num_headings, strerror(errno));\n    free(entry_counts);\n    return;\n  }\n\n  if ((entries = (tree_t **)calloc(sizeof(tree_t *), num_headings + 1)) == NULL)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY,\n                   \"Unable to allocate memory for %d headings - %s\",\n                   (int)num_headings, strerror(errno));\n    free(entry_objects);\n    free(entry_counts);\n    return;\n  }\n\n  if (parent == 0 && TocLevels > 0)\n  {\n   /*\n    * Add the table of contents to the top-level contents...\n    */\n\n    entries[0]       = NULL;\n    entry_objects[0] = num_objects + 2;\n    entry            = num_objects + 3;\n    count            = 1;\n  }\n  else\n  {\n    entry = num_objects + 2;\n    count = 0;\n  }\n\n /*\n  * Find and count the children (entries)...\n  */\n\n  if (toc->markup == MARKUP_B && toc->next && toc->next->markup == MARKUP_UL)\n    temp = toc->next->child;\n  else if (toc->markup == MARKUP_LI && toc->last_child &&\n           toc->last_child->markup == MARKUP_UL)\n    temp = toc->last_child->child;\n  else\n    temp = toc->child;\n\n  for (; temp && count <= (int)num_headings; temp = temp->next)\n  {\n    if (temp->markup == MARKUP_B)\n    {\n      entries[count]       = temp;\n      entry_objects[count] = entry;\n\n      if (temp->next && temp->next->markup == MARKUP_UL)\n        entry_counts[count] = pdf_count_headings(temp->next->child);\n      else\n        entry_counts[count] = 0;\n\n      entry += entry_counts[count] + 1;\n      count ++;\n    }\n    else if (temp->markup == MARKUP_LI)\n    {\n      entries[count]       = temp;\n      entry_objects[count] = entry;\n\n      if (temp->last_child && temp->last_child->markup == MARKUP_UL)\n        entry_counts[count] = pdf_count_headings(temp->last_child);\n      else\n        entry_counts[count] = 0;\n\n      entry += entry_counts[count] + 1;\n      count ++;\n    }\n  }\n\n /*\n  * Output the top-level object...\n  */\n\n  thisobj = pdf_start_object(out);\n\n  if (parent == 0)\n    outline_object = thisobj;\n  else\n    fprintf(out, \"/Parent %d 0 R\", parent);\n\n  if (count > 0)\n  {\n    fprintf(out, \"/Count %d\", parent == 0 ? count : -count);\n    fprintf(out, \"/First %d 0 R\", entry_objects[0]);\n    fprintf(out, \"/Last %d 0 R\", entry_objects[count - 1]);\n  }\n\n  if (parent > 0 && toc->child && toc->child->markup == MARKUP_A)\n  {\n    if ((text = htmlGetText(toc->child->child)) != NULL)\n    {\n      fputs(\"/Title\", out);\n      write_utf16(out, text);\n      free(text);\n    }\n\n    i = heading_pages[*heading];\n    x = 0.0f;\n    y = heading_tops[*heading] + pages[i].bottom;\n    pspdf_transform_coords(pages + i, x, y);\n\n    fprintf(out, \"/Dest[%d 0 R/XYZ %.0f %.0f 0]\",\n            pages_object + 2 * pages[i].outpage + 1, x, y);\n\n    (*heading) ++;\n  }\n\n  if (prev > 0)\n    fprintf(out, \"/Prev %d 0 R\", prev);\n\n  if (next > 0)\n    fprintf(out, \"/Next %d 0 R\", next);\n\n  pdf_end_object(out);\n\n  for (i = 0; i < count ; i ++)\n    pdf_write_contents(out, entries[i], thisobj, i > 0 ? entry_objects[i - 1] : 0,\n                       i < (count - 1) ? entry_objects[i + 1] : 0,\n                       heading);\n\n  free(entry_objects);\n  free(entry_counts);\n  free(entries);\n}\n\n\n//\n// 'pdf_write_files()' - Write an outline of HTML files.\n//\n\nstatic void\npdf_write_files(FILE   *out,\t\t// I - Output file\n                tree_t *doc)\t\t// I - Document tree\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tnum_files,\t\t// Number of FILE elements\n\t\talloc_text;\t\t// Allocated text?\n  uchar\t\t*text;\t\t\t// Entry text\n  tree_t\t*temp;\t\t\t// Current node\n  link_t\t*link;\t\t\t// Link to file...\n  float\t\tx, y;\t\t\t// Position of link\n\n\n  // Figure out the number of (top-level) files in the document...\n  for (num_files = 0, temp = doc; temp; temp = temp->next)\n    if (temp->markup == MARKUP_FILE)\n      num_files ++;\n\n  if (num_files < 2)\n  {\n    // No files to outline...\n    outline_object = 0;\n\n    return;\n  }\n\n  // Write the outline dictionary...\n  outline_object = pdf_start_object(out);\n\n  fprintf(out, \"/Count %d\", num_files);\n  fprintf(out, \"/First %d 0 R\", outline_object + 1);\n  fprintf(out, \"/Last %d 0 R\", outline_object + num_files);\n\n  pdf_end_object(out);\n\n  // Now write the outline items...\n  for (i = 0, temp = doc; temp; temp = temp->next)\n    if (temp->markup == MARKUP_FILE)\n    {\n      alloc_text = 0;\n\n      if ((text = get_title(temp->child)) != NULL)\n        alloc_text = 1;\n      else if ((text = htmlGetVariable(temp, (uchar *)\"_HD_FILENAME\")) == NULL)\n        text = (uchar *)\"Unknown\";\n\n      pdf_start_object(out);\n\n      fprintf(out, \"/Parent %d 0 R\", outline_object);\n\n      fputs(\"/Title\", out);\n      write_utf16(out, text);\n      if (alloc_text)\n        free(text);\n\n      if ((link = find_link(htmlGetVariable(temp, (uchar *)\"_HD_FILENAME\"))) != NULL)\n      {\n\tx = 0.0f;\n\ty = link->top + pages[link->page].bottom;\n\tpspdf_transform_coords(pages + link->page, x, y);\n\n\tfprintf(out, \"/Dest[%d 0 R/XYZ %.0f %.0f 0]\",\n        \tpages_object + 2 * pages[link->page].outpage + 1, x, y);\n      }\n\n      if (i > 0)\n        fprintf(out, \"/Prev %d 0 R\", outline_object + i);\n\n      if (i < (num_files - 1))\n        fprintf(out, \"/Next %d 0 R\", outline_object + i + 2);\n\n      pdf_end_object(out);\n\n      i ++;\n    }\n}\n\n\n/*\n * 'pdf_count_headings()' - Count the number of headings under this TOC\n *                          entry.\n */\n\nstatic int\t\t\t/* O - Number of headings found */\npdf_count_headings(tree_t *toc)\t/* I - TOC entry */\n{\n  int\theadings;\t\t/* Number of headings */\n\n\n  for (headings = 0; toc != NULL; toc = toc->next)\n  {\n    if (toc->markup == MARKUP_A)\n      headings ++;\n    if (toc->child != NULL)\n      headings += pdf_count_headings(toc->child);\n  }\n\n  return (headings);\n}\n\n\n/*\n * PDF object state variables...\n */\n\nstatic int\tpdf_stream_length = 0;\nstatic int\tpdf_stream_start = 0;\nstatic int\tpdf_object_type = 0;\n\n\n/*\n * 'pdf_start_object()' - Start a new PDF object...\n */\n\nstatic int\t\t\t// O - Object number\npdf_start_object(FILE *out,\t// I - File to write to\n                 int  array)\t// I - 1 = array, 0 = dictionary\n{\n  int\t*temp;\t\t\t// Temporary integer pointer\n\n\n  num_objects ++;\n\n  // Allocate memory as necessary...\n  if (num_objects >= alloc_objects)\n  {\n    alloc_objects += ALLOC_OBJECTS;\n\n    if (alloc_objects == ALLOC_OBJECTS)\n      temp = (int *)malloc(sizeof(int) * alloc_objects);\n    else\n      temp = (int *)realloc(objects, sizeof(int) * alloc_objects);\n\n    if (temp == NULL)\n    {\n      progress_error(HD_ERROR_OUT_OF_MEMORY,\n                     \"Unable to allocate memory for %d objects - %s\",\n                     (int)alloc_objects, strerror(errno));\n      alloc_objects -= ALLOC_OBJECTS;\n      return (0);\n    }\n\n    objects = temp;\n  }\n\n  objects[num_objects] = ftell(out);\n  fprintf(out, \"%d 0 obj\", (int)num_objects);\n\n  pdf_object_type = array;\n\n  fputs(pdf_object_type ? \"[\" : \"<<\", out);\n\n  return (num_objects);\n}\n\n\n/*\n * 'pdf_start_stream()' - Start a new PDF stream...\n */\n\nstatic void\npdf_start_stream(FILE *out)\t// I - File to write to\n{\n  // Write the \"/Length \" string, get the position, and then write 10\n  // zeroes to cover the maximum size of a stream.\n\n  fputs(\"/Length \", out);\n  pdf_stream_length = ftell(out);\n  fputs(\"0000000000>>stream\\n\", out);\n  pdf_stream_start = ftell(out);\n}\n\n\n/*\n * 'pdf_end_object()' - End a PDF object...\n */\n\nstatic void\npdf_end_object(FILE *out)\t// I - File to write to\n{\n  int\tlength;\t\t\t// Total length of stream\n\n\n  if (pdf_stream_start)\n  {\n    // For streams, go back and update the length field in the\n    // object dictionary...\n    length = ftell(out) - pdf_stream_start;\n\n    fseek(out, pdf_stream_length, SEEK_SET);\n    fprintf(out, \"%-10d\", length);\n    fseek(out, 0, SEEK_END);\n\n    pdf_stream_start = 0;\n\n    fputs(\"endstream\\n\", out);\n  }\n  else\n    fputs(pdf_object_type ? \"]\" : \">>\", out);\n\n  fputs(\"endobj\\n\", out);\n}\n\n\n/*\n * 'pdf_write_links()' - Write annotation link objects for each page in the\n *                       document.\n */\n\nstatic void\npdf_write_links(FILE *out)\t\t/* I - Output file */\n{\n  int\t\ti,\t\t\t/* Looping var */\n\t\toutpage,\t\t/* Current page */\n\t\tlobj,\t\t\t/* Current link */\n\t\tnum_lobjs,\t\t/* Number of links on this page */\n\t\talloc_lobjs,\t\t/* Number of links to allocate */\n\t\t*lobjs;\t\t\t/* Link objects */\n  float\t\tx, y;\t\t\t/* Position of last link */\n  render_t\t*r,\t\t\t/* Current render primitive */\n\t\t*rlast,\t\t\t/* Last render link primitive */\n\t\t*rprev;\t\t\t/* Previous render primitive */\n  link_t\t*link;\t\t\t/* Local link */\n  page_t\t*p;\t\t\t/* Current page */\n  outpage_t\t*op;\t\t\t/* Current output page */\n\n\n /*\n  * First combine adjacent, identical links...\n  */\n\n  for (outpage = 0, op = outpages; outpage < (int)num_outpages; outpage ++, op ++)\n  {\n    for (i = 0; i < op->nup; i ++)\n    {\n      if (op->pages[i] < 0)\n        break;\n\n      p = pages + op->pages[i];\n\n      for (r = p->start, x = 0.0f, y = 0.0f, rlast = NULL, rprev = NULL;\n           r != NULL;\n\t   rprev = r, r = r->next)\n\tif (r->type == RENDER_LINK)\n\t{\n          if (fabs(r->x - x) < 0.1f && fabs(r->y - y) < 0.1f &&\n\t      rlast != NULL && strcmp((const char *)rlast->data.link,\n\t                              (const char *)r->data.link) == 0)\n\t  {\n\t    // Combine this primitive with the previous one in rlast...\n\t    rlast->width = r->x + r->width - rlast->x;\n\t    x            = rlast->x + rlast->width;\n\n\t    // Delete this render primitive...\n\t    rprev->next = r->next;\n\t    free(r);\n\t    r = rprev;\n\t  }\n\t  else\n\t  {\n\t    // Can't combine; just save this info for later use...\n\t    rlast = r;\n\t    x     = r->x + r->width;\n\t    y     = r->y;\n\t  }\n\t}\n    }\n  }\n\n /*\n  * Setup the initial pages_object number...\n  */\n\n  pages_object = num_objects + 1;\n\n /*\n  * Add space for named links in PDF 1.2 output...\n  */\n\n  if (PDFVersion >= 12)\n    pages_object += num_links + 3;\n\n /*\n  * Stop here if we won't be generating links in the output...\n  */\n\n  if (!Links)\n    return;\n\n /*\n  * Figure out how many link objects we'll have...\n  */\n\n  for (outpage = 0, op = outpages, alloc_lobjs = 0;\n       outpage < (int)num_pages;\n       outpage ++, op ++)\n  {\n    num_lobjs = 0;\n\n    for (i = 0; i < op->nup; i ++)\n    {\n      if (op->pages[i] < 0)\n        break;\n\n      p = pages + op->pages[i];\n\n      for (r = p->start; r != NULL; r = r->next)\n\tif (r->type == RENDER_LINK)\n\t{\n          if (find_link(r->data.link) != NULL)\n            num_lobjs ++;\n          else\n            num_lobjs += 2;\n\t}\n    }\n\n    if (num_lobjs > 0)\n      pages_object += num_lobjs + 1;\n\n    if (num_lobjs > alloc_lobjs)\n      alloc_lobjs = num_lobjs;\n  }\n\n  if (alloc_lobjs == 0)\n    return;\n\n /*\n  * Allocate memory for the links...\n  */\n\n  if ((lobjs = (int *)malloc(sizeof(int) * (size_t)alloc_lobjs)) == NULL)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY,\n                   \"Unable to allocate memory for %d link objects - %s\",\n                   alloc_lobjs, strerror(errno));\n    return;\n  }\n\n /*\n  * Then generate annotation objects for all the links...\n  */\n\n  for (outpage = 0, op = outpages; outpage < (int)num_pages; outpage ++, op ++)\n  {\n    num_lobjs = 0;\n\n    for (i = 0; i < op->nup; i ++)\n    {\n      if (op->pages[i] < 0)\n        break;\n\n      p = pages + op->pages[i];\n\n      for (r = p->start; r != NULL; r = r->next)\n\tif (r->type == RENDER_LINK)\n\t{\n          if ((link = find_link(r->data.link)) != NULL)\n\t  {\n\t   /*\n            * Local link...\n            */\n\t    float x1, y1, x2, y2;\n\n            lobjs[num_lobjs ++] = pdf_start_object(out);\n\n            fputs(\"/Subtype/Link\", out);\n\n            if (PageDuplex && (op->pages[i] & 1))\n\t    {\n              x1 = r->x + p->right;\n\t      y1 = r->y + p->bottom - 2;\n              x2 = r->x + r->width + p->right;\n\t      y2 = r->y + r->height + p->bottom;\n\t    }\n            else\n\t    {\n              x1 = r->x + p->left;\n\t      y1 = r->y + p->bottom - 2;\n              x2 = r->x + r->width + p->left;\n\t      y2 = r->y + r->height + p->bottom;\n\t    }\n\n            pspdf_transform_coords(p, x1, y1);\n            pspdf_transform_coords(p, x2, y2);\n            fprintf(out, \"/Rect[%.1f %.1f %.1f %.1f]\", x1, y1, x2, y2);\n\n            fputs(\"/Border[0 0 0]\", out);\n\n            x1 = 0.0f;\n\t    y1 = link->top + pages[link->page].bottom;\n            pspdf_transform_coords(pages + link->page, x1, y1);\n\t    fprintf(out, \"/Dest[%d 0 R/XYZ %.0f %.0f 0]\",\n        \t    pages_object + 2 * pages[link->page].outpage + 1,\n        \t    x1, y1);\n\t    pdf_end_object(out);\n\t  }\n\t  else\n\t  {\n\t   /*\n            * Remote link...\n            */\n\n            pdf_start_object(out);\n\n\t    if (PDFVersion >= 12 &&\n        \tfile_method((char *)r->data.link) == NULL)\n\t    {\n#ifdef WIN32\n              if (strcasecmp(file_extension((char *)r->data.link), \"pdf\") == 0)\n#else\n              if (strcmp(file_extension((char *)r->data.link), \"pdf\") == 0)\n#endif /* WIN32 */\n              {\n\t       /*\n\t\t* Link to external PDF file...\n\t\t*/\n\n                const char *target = file_target((char *)r->data.link);\n\n        \tfputs(\"/S/GoToR\", out);\n        \tif (target)\n        \t{\n        \t  char\turl[1024], *urlptr;\n\n\t\t  fputs(\"/D\", out);\n\t\t  write_string(out, (uchar *)target, 0);\n\n                  strlcpy(url, (char *)r->data.link, sizeof(url));\n                  if ((urlptr = strrchr(url, '#')) != NULL)\n                    *urlptr = '\\0';\n\n\t\t  fputs(\"/F\", out);\n\t\t  write_string(out, (uchar *)url, 0);\n        \t}\n        \telse\n        \t{\n\t\t  fputs(\"/D[0/XYZ null null 0]/F\", out);\n\t\t  write_string(out, r->data.link, 0);\n\t\t}\n              }\n\t      else\n              {\n\t       /*\n\t\t* Link to external filename...\n\t\t*/\n\n        \tfputs(\"/S/Launch\", out);\n        \tfputs(\"/F\", out);\n\t\twrite_string(out, r->data.link, 0);\n\n\t\tif (StrictHTML)\n\t\t  progress_error(HD_ERROR_UNRESOLVED_LINK,\n\t\t                 \"Unable to resolve link to \\\"%s\\\"!\",\n\t\t                 r->data.link);\n              }\n\t    }\n\t    else\n\t    {\n\t     /*\n\t      * Link to web file...\n\t      */\n\n              fputs(\"/S/URI\", out);\n              fputs(\"/URI\", out);\n\t      write_string(out, r->data.link, 0);\n\t    }\n\n            pdf_end_object(out);\n\n            lobjs[num_lobjs ++] = pdf_start_object(out);\n\n            fputs(\"/Subtype/Link\", out);\n            if (PageDuplex && (outpage & 1))\n              fprintf(out, \"/Rect[%.1f %.1f %.1f %.1f]\",\n                      r->x + PageRight, r->y + PageBottom,\n                      r->x + r->width + PageRight, r->y + r->height + PageBottom);\n            else\n              fprintf(out, \"/Rect[%.1f %.1f %.1f %.1f]\",\n                      r->x + PageLeft, r->y + PageBottom - 2,\n                      r->x + r->width + PageLeft, r->y + r->height + PageBottom);\n            fputs(\"/Border[0 0 0]\", out);\n\t    fprintf(out, \"/A %d 0 R\", (int)num_objects - 1);\n            pdf_end_object(out);\n\t  }\n\t}\n    }\n\n    if (num_lobjs > 0)\n    {\n      outpages[outpage].annot_object = pdf_start_object(out, 1);\n\n      for (lobj = 0; lobj < num_lobjs; lobj ++)\n        fprintf(out, \"%d 0 R%s\", lobjs[lobj],\n\t        lobj < (num_lobjs - 1) ? \"\\n\" : \"\");\n\n      pdf_end_object(out);\n    }\n  }\n\n  free(lobjs);\n}\n\n\n/*\n * 'pdf_write_names()' - Write named destinations for each link.\n */\n\nstatic void\npdf_write_names(FILE *out)\t\t/* I - Output file */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  uchar\t\t*s;\t\t\t/* Current character in name */\n  link_t\t*link;\t\t\t/* Local link */\n\n\n /*\n  * Convert all link names to lowercase...\n  */\n\n  for (i = num_links, link = links; i > 0; i --, link ++)\n    for (s = link->name; *s != '\\0'; s ++)\n      *s = (uchar)tolower(*s);\n\n /*\n  * Write the root name tree entry...\n  */\n\n  names_object = pdf_start_object(out);\n  fprintf(out, \"/Dests %d 0 R\", (int)num_objects + 1);\n  pdf_end_object(out);\n\n /*\n  * Write the name tree child list...\n  */\n\n  pdf_start_object(out);\n  fprintf(out, \"/Kids[%d 0 R]\", (int)num_objects + 1);\n  pdf_end_object(out);\n\n /*\n  * Write the leaf node for the name tree...\n  */\n\n  pdf_start_object(out);\n\n  fputs(\"/Limits[\", out);\n  write_string(out, links[0].name, 0);\n  write_string(out, links[num_links - 1].name, 0);\n  fputs(\"]\", out);\n\n  fputs(\"/Names[\", out);\n  for (i = 1, link = links; i <= (int)num_links; i ++, link ++)\n  {\n    write_string(out, link->name, 0);\n    fprintf(out, \"%d 0 R\", (int)num_objects + i);\n  }\n  fputs(\"]\", out);\n\n  pdf_end_object(out);\n\n  for (i = num_links, link = links; i > 0; i --, link ++)\n  {\n    pdf_start_object(out);\n    float x, y;\n\n    x = 0.0f;\n    y = link->top + pages[link->page].bottom;\n    pspdf_transform_coords(pages + link->page, x, y);\n    fprintf(out, \"/D[%d 0 R/XYZ %.0f %.0f 0]\",\n            pages_object + 2 * pages[link->page].outpage + 1, x, y);\n    pdf_end_object(out);\n  }\n}\n\n\n/*\n * 'render_contents()' - Render a single heading.\n */\n\nstatic void\nrender_contents(tree_t *t,\t\t/* I - Tree to parse */\n                float  left,\t\t/* I - Left margin */\n                float  right,\t\t/* I - Printable width */\n                float  bottom,\t\t/* I - Bottom margin */\n                float  top,\t\t/* I - Printable top */\n                float  *y,\t\t/* IO - Y position */\n                int    *page,\t\t/* IO - Page # */\n\t        int    heading,\t\t/* I - Heading # */\n\t        tree_t *chap)\t\t/* I - Chapter heading */\n{\n  float\t\tx,\n\t\twidth,\n\t\tnumberwidth,\n\t\theight,\n\t\trgb[3];\n  int\t\thpage;\n  uchar\t\tnumber[1024],\n\t\t*nptr,\n\t\t*link;\n  tree_t\t*flat,\n\t\t*temp,\n\t\t*next;\n  render_t\t*r;\n  float\t\tdot_width;\n\n\n  DEBUG_printf((\"render_contents(t=%p, left=%.1f, right=%.1f, bottom=%.1f, top=%.1f, y=%.1f, page=%d, heading=%d, chap=%p)\\n\",\n                (void *)t, left, right, bottom, top, *y, *page, heading, (void *)chap));\n\n  if (!t)\n    return;\n\n  dot_width = _htmlSizes[SIZE_P] * _htmlWidths[t->typeface][t->style]['.'] * 0.001f;\n\n /*\n  * Put the text...\n  */\n\n  flat = flatten_tree(t->child->child);\n\n  for (height = 0.0, temp = flat; temp != NULL; temp = temp->next)\n    if (temp->height > height)\n      height = temp->height;\n\n  height *= _htmlSpacings[SIZE_P] / _htmlSizes[SIZE_P];\n\n  if (t->indent)\n    x = left + 18.0f + 18.0f * t->indent;\n  else\n    x = left;\n\n  *y -= height;\n\n /*\n  * Get the width of the page number, leave room for three dots...\n  */\n\n  if (heading >= 0 && heading < (int)num_headings)\n  {\n    hpage       = heading_pages[heading];\n    numberwidth = (float)(get_width((uchar *)pages[hpage].page_text, t->typeface, t->style, t->size) + 3.0f * dot_width);\n  }\n  else\n  {\n    hpage       = 0;\n    numberwidth = 0.0f;\n  }\n\n  for (temp = flat; temp != NULL; temp = next)\n  {\n    rgb[0] = temp->red / 255.0f;\n    rgb[1] = temp->green / 255.0f;\n    rgb[2] = temp->blue / 255.0f;\n\n    if ((x + temp->width) >= (right - numberwidth))\n    {\n     /*\n      * Too wide to fit, continue on the next line\n      */\n\n      *y -= _htmlSpacings[SIZE_P];\n      x  = left + 36.0f * t->indent;\n    }\n\n    if (*y < bottom)\n    {\n      (*page) ++;\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n\n      width = get_width((uchar *)TocTitle, _htmlHeadingFont, STYLE_BOLD, SIZE_H1);\n      *y = (float)(top - _htmlSpacings[SIZE_H1]);\n      x  = (float)(left + 0.5f * (right - left - width));\n      r = new_render(*page, RENDER_TEXT, x, *y, 0, 0, TocTitle);\n      r->data.text.typeface = _htmlHeadingFont;\n      r->data.text.style    = STYLE_BOLD;\n      r->data.text.size     = (float)_htmlSizes[SIZE_H1];\n      get_color(_htmlTextColor, r->data.text.rgb);\n\n      *y -= _htmlSpacings[SIZE_H1];\n\n      if (t->indent)\n\tx = left + 18.0f + 18.0f * t->indent;\n      else\n\tx = left;\n\n      if (chap != t)\n      {\n        *y += height;\n        render_contents(chap, left, right, bottom, top, y, page, -1, 0);\n\t*y -= _htmlSpacings[SIZE_P];\n      }\n    }\n\n    if (temp->link != NULL)\n    {\n      link = htmlGetVariable(temp->link, (uchar *)\"HREF\");\n\n     /*\n      * Add a page link...\n      */\n\n      new_render(*page, RENDER_LINK, x, *y, temp->width, temp->height, link);\n\n      if (PSLevel == 0 && Links)\n      {\n        memcpy(rgb, link_color, sizeof(rgb));\n\n\ttemp->red   = (uchar)(link_color[0] * 255.0);\n\ttemp->green = (uchar)(link_color[1] * 255.0);\n\ttemp->blue  = (uchar)(link_color[2] * 255.0);\n\n        if (LinkStyle)\n\t  new_render(*page, RENDER_BOX, x, *y - 1, temp->width, 0,\n\t             link_color);\n      }\n    }\n\n    if ((link = htmlGetVariable(temp, (uchar *)\"ID\")) != NULL)\n    {\n     /*\n      * Add a target link...\n      */\n\n      add_link(link, *page, (int)(*y + height));\n    }\n\n    switch (temp->markup)\n    {\n      case MARKUP_A :\n          if ((link = htmlGetVariable(temp, (uchar *)\"NAME\")) != NULL)\n          {\n           /*\n            * Add a target link...\n            */\n\n            add_link(link, *page, (int)(*y + height));\n          }\n          break;\n\n      case MARKUP_NONE :\n          if (temp->data == NULL)\n            break;\n\n\t  if (temp->underline)\n\t    new_render(*page, RENDER_BOX, x, *y - 1, temp->width, 0, rgb);\n\n\t  if (temp->strikethrough)\n\t    new_render(*page, RENDER_BOX, x, *y + temp->height * 0.25f,\n\t\t       temp->width, 0, rgb);\n\n          r = new_render(*page, RENDER_TEXT, x, *y, 0, 0, temp->data);\n          r->data.text.typeface = temp->typeface;\n          r->data.text.style    = temp->style;\n          r->data.text.size     = (float)_htmlSizes[temp->size];\n          memcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n          if (temp->superscript)\n            r->y += height - temp->height;\n          else if (temp->subscript)\n            r->y -= height * _htmlSizes[0] / _htmlSpacings[0] -\n\t\t    temp->height;\n\t  break;\n\n      case MARKUP_IMG :\n\t  update_image_size(temp);\n\t  new_render(*page, RENDER_IMAGE, x, *y, temp->width, temp->height,\n\t\t     image_find((char *)htmlGetVariable(temp, (uchar *)\"REALSRC\")));\n\t  break;\n\n      default :\n\t  break;\n    }\n\n    x += temp->width;\n    next = temp->next;\n    free(temp);\n  }\n\n  if (numberwidth > 0.0f)\n  {\n   /*\n    * Draw dots leading up to the page number...\n    */\n\n    width = (float)(numberwidth - 3.0 * dot_width + x);\n\n    for (nptr = number;\n         nptr < (number + sizeof(number) - 1) && width < right;\n\t width += dot_width)\n      *nptr++ = '.';\n\n    if (nptr > number)\n      nptr --;\n\n    strlcpy((char *)nptr, pages[hpage].page_text, sizeof(number) - (size_t)(nptr - number));\n\n    r = new_render(*page, RENDER_TEXT, right - width + x, *y, 0, 0, number);\n    r->data.text.typeface = t->typeface;\n    r->data.text.style    = t->style;\n    r->data.text.size     = (float)_htmlSizes[t->size];\n    memcpy(r->data.text.rgb, rgb, sizeof(rgb));\n  }\n}\n\n\n/*\n * 'count_headings()' - Count the number of headings in the TOC.\n */\n\nstatic int\ncount_headings(tree_t *t)\t\t// I - Tree to count\n{\n  int\tcount;\t\t\t\t// Number of headings...\n\n\n  count = 0;\n\n  while (t != NULL)\n  {\n    switch (t->markup)\n    {\n      case MARKUP_B :\n      case MARKUP_LI :\n          count ++;\n\t  if (t->last_child && t->last_child->markup == MARKUP_UL)\n\t    count += count_headings(t->last_child);\n\t  break;\n\n      default :\n          count += count_headings(t->child);\n          break;\n    }\n\n    t = t->next;\n  }\n\n  return (count);\n}\n\n\n/*\n * 'parse_contents()' - Parse the table of contents and produce a\n *                      rendering list...\n */\n\nstatic void\nparse_contents(tree_t *t,\t\t/* I - Tree to parse */\n               float  left,\t\t/* I - Left margin */\n               float  right,\t\t/* I - Printable width */\n               float  bottom,\t\t/* I - Bottom margin */\n               float  top,\t\t/* I - Printable top */\n               float  *y,\t\t/* IO - Y position */\n               int    *page,\t\t/* IO - Page # */\n               int    *heading,\t\t/* IO - Heading # */\n\t       tree_t *chap)\t\t/* I - Chapter heading */\n{\n  DEBUG_printf((\"parse_contents(t=%p, left=%.1f, right=%.1f, bottom=%.1f, top=%.1f, y=%.1f, page=%d, heading=%d, chap=%p)\\n\",\n                (void *)t, left, right, bottom, top, *y, *page, *heading, (void *)chap));\n\n  while (t != NULL)\n  {\n    switch (t->markup)\n    {\n      case MARKUP_B :\t/* Top-level TOC */\n          if (t->prev != NULL)\t/* Advance one line prior to top-levels... */\n            *y -= _htmlSpacings[SIZE_P];\n\n          if (*y < (bottom + _htmlSpacings[SIZE_P] * 3))\n\t    *y = 0; // Force page break\n\n          chap = t;\n\n      case MARKUP_LI :\t/* Lower-level TOC */\n          DEBUG_printf((\"parse_contents: heading=%d, page = %d\\n\", *heading,\n                        heading_pages[*heading]));\n\n         /*\n          * Put the text unless the author has flagged it otherwise...\n          */\n\n          if (htmlGetVariable(t, (uchar *)\"_HD_OMIT_TOC\") == NULL)\n\t  {\n            render_contents(t, left, right, bottom, top, y, page,\n\t                    *heading, chap);\n\n           /*\n\t    * Update current headings for header/footer strings in TOC.\n\t    */\n\n\t    check_pages(*page);\n\n\t    if (t->markup == MARKUP_B &&\n\t\tpages[*page].chapter == pages[*page - 1].chapter)\n\t      pages[*page].chapter = htmlGetText(t->child->child);\n\n\t    if (pages[*page].heading == pages[*page - 1].heading)\n\t      pages[*page].heading = htmlGetText(t->child->child);\n\n           /*\n            * Next heading...\n            */\n\n            (*heading) ++;\n\n            if (t->last_child->markup == MARKUP_UL)\n              parse_contents(t->last_child, left, right, bottom, top, y,\n\t                     page, heading, chap);\n          }\n\t  else if (t->next != NULL && t->next->markup == MARKUP_UL)\n\t  {\n\t   /*\n\t    * Skip children of omitted heading...\n\t    */\n\n\t    t = t->next;\n\n\t    (*heading) += count_headings(t->child) + 1;\n\t  }\n\t  else\n\t    (*heading) ++;\n          break;\n\n      default :\n          parse_contents(t->child, left, right, bottom, top, y, page, heading,\n\t                 chap);\n          break;\n    }\n\n    t = t->next;\n  }\n}\n\n\n/*\n * 'parse_doc()' - Parse a document tree and produce rendering list output.\n */\n\nstatic void\nparse_doc(tree_t *t,\t\t/* I - Tree to parse */\n          float  *left,\t\t/* I - Left margin */\n          float  *right,\t/* I - Printable width */\n          float  *bottom,\t/* I - Bottom margin */\n          float  *top,\t\t/* I - Printable top */\n          float  *x,\t\t/* IO - X position */\n          float  *y,\t\t/* IO - Y position */\n          int    *page,\t\t/* IO - Page # */\n\t  tree_t *cpara,\t/* I - Current paragraph */\n\t  int    *needspace)\t/* I - Need whitespace before this element */\n{\n  int\t\ti;\t\t/* Looping var */\n  tree_t\t*para,\t\t/* Phoney paragraph tree entry */\n\t\t*temp;\t\t/* Paragraph entry */\n  var_t\t\t*var;\t\t/* Variable entry */\n  uchar\t\t*name;\t\t/* ID name */\n  uchar\t\t*style;\t\t/* STYLE attribute */\n  float\t\twidth,\t\t/* Width of horizontal rule */\n\t\theight,\t\t/* Height of rule */\n\t\trgb[3];\t\t/* RGB color of rule */\n\n\n  DEBUG_printf((\"parse_doc(t=%p, left=%.1f, right=%.1f, bottom=%.1f, top=%.1f, x=%.1f, y=%.1f, page=%d, cpara=%p, needspace=%d\\n\",\n                (void *)t, *left, *right, *bottom, *top, *x, *y, *page, (void *)cpara,\n\t        *needspace));\n  DEBUG_printf((\"    title_page = %d, chapter = %d\\n\", title_page, chapter));\n\n  if (cpara == NULL)\n    para = htmlNewTree(NULL, MARKUP_P, NULL);\n  else\n    para = cpara;\n\n  while (t != NULL)\n  {\n    if (t->markup == MARKUP_FILE)\n      current_url = htmlGetVariable(t, (uchar *)\"_HD_URL\");\n\n    if (((t->markup == MARKUP_H1 && OutputType == OUTPUT_BOOK) ||\n         (t->markup == MARKUP_FILE && OutputType == OUTPUT_WEBPAGES)) &&\n\t!title_page)\n    {\n      // New page on H1 in book mode or file in webpage mode...\n      if (para->child != NULL && chapter > 0)\n      {\n        parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n        htmlDeleteTree(para->child);\n        para->child = para->last_child = NULL;\n      }\n\n      if ((chapter > 0 && OutputType == OUTPUT_BOOK) ||\n          ((*page > 0 || *y < *top) && OutputType == OUTPUT_WEBPAGES))\n      {\n        if (*y < *top)\n          (*page) ++;\n\n        if (PageDuplex && (*page & 1))\n          (*page) ++;\n\n        if (Verbosity)\n          progress_show(\"Formatting page %d\", *page);\n\n        chapter_ends[chapter] = *page - 1;\n      }\n\n      // Make sure header and footer strings are correct...\n      check_pages(*page);\n\n      memcpy(pages[*page].header, Header, sizeof(pages[*page].header));\n      memcpy(pages[*page].header1, Header1, sizeof(pages[*page].header1));\n      memcpy(pages[*page].footer, Footer, sizeof(pages[*page].footer));\n\n      // Bump the chapter/file count...\n      chapter ++;\n      if (chapter >= MAX_CHAPTERS)\n      {\n\tprogress_error(HD_ERROR_TOO_MANY_CHAPTERS,\n\t               \"Too many chapters/files in document (%d > %d)!\",\n\t               chapter, MAX_CHAPTERS);\n        chapter = MAX_CHAPTERS - 1;\n      }\n      else\n        chapter_starts[chapter] = *page;\n\n      if (chapter > TocDocCount)\n\tTocDocCount = chapter;\n\n      *y         = *top;\n      *x         = *left;\n      *needspace = 0;\n    }\n\n    if ((name = htmlGetVariable(t, (uchar *)\"ID\")) != NULL)\n    {\n     /*\n      * Add a link target using the ID=name variable...\n      */\n\n      add_link(name, *page, (int)*y);\n    }\n    else if (t->markup == MARKUP_FILE)\n    {\n     /*\n      * Add a file link...\n      */\n\n      uchar\tnewname[256],\t/* New filename */\n\t\t*sep;\t\t/* \"?\" separator in links */\n\n\n      // Strip any trailing HTTP GET data stuff...\n      strlcpy((char *)newname, (char *)htmlGetVariable(t, (uchar *)\"_HD_FILENAME\"),\n              sizeof(newname));\n\n      if ((sep = (uchar *)strchr((char *)newname, '?')) != NULL)\n        *sep = '\\0';\n\n      // Add the link\n      add_link(newname, *page, (int)*y);\n    }\n\n    if (chapter == 0 && !title_page)\n    {\n      // Need to handle page comments before the first heading...\n      if (t->markup == MARKUP_COMMENT)\n        parse_comment(t, left, right, bottom, top, x, y, page, para,\n\t              *needspace);\n\n      if (t->child != NULL)\n        parse_doc(t->child, left, right, bottom, top, x, y, page, para,\n\t          needspace);\n\n      t = t->next;\n      continue;\n    }\n\n    // Check for some basic stylesheet stuff...\n    if ((style = htmlGetStyle(t, (uchar *)\"page-break-before:\")) != NULL &&\n\tstrcasecmp((char *)style, \"avoid\") != 0)\n    {\n      // Advance to the next page...\n      (*page) ++;\n      *x         = *left;\n      *y         = *top;\n      *needspace = 0;\n\n      // See if we need to go to the next left/righthand page...\n      if (PageDuplex && ((*page) & 1) &&\n          strcasecmp((char *)style, \"right\") == 0)\n\t(*page) ++;\n      else if (PageDuplex && !((*page) & 1) &&\n               strcasecmp((char *)style, \"left\") == 0)\n\t(*page) ++;\n\n      // Update the progress as necessary...\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n    }\n\n    // Process the markup...\n    switch (t->markup)\n    {\n      case MARKUP_IMG :\n          update_image_size(t);\n      case MARKUP_NONE :\n      case MARKUP_BR :\n          if (para->child == NULL)\n          {\n\t    if (t->parent == NULL)\n\t    {\n              para->halignment = ALIGN_LEFT;\n              para->indent     = 0;\n\t    }\n\t    else\n\t    {\n              para->halignment = t->parent->halignment;\n              para->indent     = t->parent->indent;\n\t    }\n          }\n\n\t  // Skip heading whitespace...\n          if (para->child == NULL && t->markup == MARKUP_NONE &&\n\t      t->data != NULL && strcmp((char *)t->data, \" \") == 0)\n\t    break;\n\n          if ((temp = htmlAddTree(para, t->markup, t->data)) != NULL)\n          {\n\t    temp->link          = t->link;\n            temp->width         = t->width;\n            temp->height        = t->height;\n            temp->typeface      = t->typeface;\n            temp->style         = t->style;\n            temp->size          = t->size;\n            temp->underline     = t->underline;\n            temp->strikethrough = t->strikethrough;\n            temp->superscript   = t->superscript;\n            temp->subscript     = t->subscript;\n            temp->halignment    = t->halignment;\n            temp->valignment    = t->valignment;\n            temp->red           = t->red;\n            temp->green         = t->green;\n            temp->blue          = t->blue;\n            for (i = 0, var = t->vars; i < t->nvars; i ++, var ++)\n              htmlSetVariable(temp, var->name, var->value);\n          }\n          break;\n\n      case MARKUP_TABLE :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n          }\n\n          parse_table(t, *left, *right, *bottom, *top, x, y, page, *needspace);\n\t  *needspace = 0;\n          break;\n\n      case MARKUP_H1 :\n      case MARKUP_H2 :\n      case MARKUP_H3 :\n      case MARKUP_H4 :\n      case MARKUP_H5 :\n      case MARKUP_H6 :\n      case MARKUP_H7 :\n      case MARKUP_H8 :\n      case MARKUP_H9 :\n      case MARKUP_H10 :\n      case MARKUP_H11 :\n      case MARKUP_H12 :\n      case MARKUP_H13 :\n      case MARKUP_H14 :\n      case MARKUP_H15 :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 1;\n          }\n\n          parse_heading(t, *left, *right, *bottom, *top, x, y, page, *needspace);\n\t  *needspace = 1;\n          break;\n\n      case MARKUP_BLOCKQUOTE :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 1;\n          }\n\n          *left  += 36;\n\t  *right -= 36;\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page, NULL,\n\t            needspace);\n\n          *left  -= 36;\n\t  *right += 36;\n\n          *x         = *left;\n          *needspace = 1;\n          break;\n\n      case MARKUP_CENTER :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n            *needspace = 1;\n          }\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page, NULL,\n\t            needspace);\n\n          *x         = *left;\n          *needspace = 1;\n          break;\n\n      case MARKUP_P :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 1;\n          }\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page, NULL,\n\t            needspace);\n\n          *x         = *left;\n          *needspace = 1;\n          break;\n\n      case MARKUP_DIV :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n          }\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page, NULL,\n\t            needspace);\n\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n          }\n          break;\n\n      case MARKUP_PRE :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 1;\n          }\n\n          *left += 36.0f;\n          *x    = *left;\n\n          parse_pre(t, *left, *right, *bottom, *top, x, y, page, *needspace);\n\n          *left      -= 36.0f;\n          *x         = *left;\n          *needspace = 1;\n          break;\n\n      case MARKUP_DIR :\n      case MARKUP_MENU :\n      case MARKUP_UL :\n      case MARKUP_OL :\n          init_list(t);\n      case MARKUP_DL :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n          }\n\n          if (t->indent == 1)\n\t    *needspace = 1;\n\n\t  *left += 36.0f;\n          *x    = *left;\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page, para,\n\t            needspace);\n\n          *left -= 36.0f;\n\n          if (t->indent == 1)\n\t    *needspace = 1;\n          break;\n\n      case MARKUP_LI :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 0;\n          }\n\n          parse_list(t, left, right, bottom, top, x, y, page, *needspace);\n\n          *x         = *left;\n          *needspace = t->next && t->next->markup != MARKUP_LI &&\n\t               t->next->markup != MARKUP_UL &&\n\t\t       t->next->markup != MARKUP_OL;\n          break;\n\n      case MARKUP_DT :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 0;\n          }\n\n\t  *left -= 36.0f;\n          *x    = *left;\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page,\n\t            NULL, needspace);\n\n\t  *left      += 36.0f;\n          *x         = *left;\n          *needspace = 0;\n          break;\n\n      case MARKUP_DD :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 0;\n          }\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page, NULL,\n\t            needspace);\n\n          *x         = *left;\n          *needspace = 0;\n          break;\n\n      case MARKUP_HR :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n          }\n\n          if (htmlGetVariable(t, (uchar *)\"BREAK\") == NULL)\n\t  {\n\t   /*\n\t    * Generate a horizontal rule...\n\t    */\n\n            if ((name = htmlGetVariable(t, (uchar *)\"WIDTH\")) == NULL)\n\t      width = *right - *left;\n\t    else\n\t    {\n\t      if (strchr((char *)name, '%') != NULL)\n\t        width = atoi((char *)name) * (*right - *left) / 100;\n\t      else\n                width = (float)(atoi((char *)name) * PagePrintWidth / _htmlBrowserWidth);\n            }\n\n            if ((name = htmlGetVariable(t, (uchar *)\"SIZE\")) == NULL)\n\t      height = 2;\n\t    else\n\t      height = (float)(atoi((char *)name) * PagePrintWidth / _htmlBrowserWidth);\n\n            switch (t->halignment)\n\t    {\n\t      case ALIGN_LEFT :\n\t          *x = *left;\n\t\t  break;\n\t      case ALIGN_CENTER :\n\t          *x = *left + (*right - *left - width) * 0.5f;\n\t\t  break;\n\t      case ALIGN_RIGHT :\n\t          *x = *right - width;\n\t\t  break;\n\t    }\n\n            if (*y < (*bottom + height + _htmlSpacings[SIZE_P]))\n\t    {\n\t     /*\n\t      * Won't fit on this page...\n\t      */\n\n              (*page) ++;\n\t      if (Verbosity)\n\t        progress_show(\"Formatting page %d\", *page);\n              *y = *top;\n            }\n\n            (*y)   -= height + _htmlSpacings[SIZE_P];\n            rgb[0] = t->red / 255.0f;\n            rgb[1] = t->green / 255.0f;\n            rgb[2] = t->blue / 255.0f;\n\n            new_render(*page, RENDER_BOX, *x, *y + _htmlSpacings[SIZE_P] * 0.5,\n\t               width, height, rgb);\n\t  }\n\t  else\n\t  {\n\t   /*\n\t    * <HR BREAK> generates a page break...\n\t    */\n\n            (*page) ++;\n\t    if (Verbosity)\n\t      progress_show(\"Formatting page %d\", *page);\n            *y = *top;\n\t  }\n\n          *x         = *left;\n          *needspace = 0;\n          break;\n\n      case MARKUP_COMMENT :\n          // Check comments for commands...\n          parse_comment(t, left, right, bottom, top, x, y, page, para,\n\t                *needspace);\n          break;\n\n      case MARKUP_HEAD : // Ignore document HEAD section\n      case MARKUP_TITLE : // Ignore title and meta stuff\n      case MARKUP_META :\n      case MARKUP_SCRIPT : // Ignore script stuff\n      case MARKUP_INPUT : // Ignore form stuff\n      case MARKUP_SELECT :\n      case MARKUP_OPTION :\n      case MARKUP_TEXTAREA :\n          break;\n\n      case MARKUP_STYLE :\n          break;\n\n      case MARKUP_A :\n          if (htmlGetVariable(t, (uchar *)\"NAME\") != NULL)\n\t  {\n\t   /*\n\t    * Add this named destination to the paragraph tree...\n\t    */\n\n            if (para->child == NULL)\n            {\n              para->halignment = t->halignment;\n              para->indent     = t->indent;\n            }\n\n            if ((temp = htmlAddTree(para, t->markup, t->data)) != NULL)\n            {\n\t      temp->link          = t->link;\n              temp->width         = t->width;\n              temp->height        = t->height;\n              temp->typeface      = t->typeface;\n              temp->style         = t->style;\n              temp->size          = t->size;\n              temp->underline     = t->underline;\n              temp->strikethrough = t->strikethrough;\n              temp->superscript   = t->superscript;\n              temp->subscript     = t->subscript;\n              temp->halignment    = t->halignment;\n              temp->valignment    = t->valignment;\n              temp->red           = t->red;\n              temp->green         = t->green;\n              temp->blue          = t->blue;\n              for (i = 0, var = t->vars; i < t->nvars; i ++, var ++)\n        \thtmlSetVariable(temp, var->name, var->value);\n            }\n\t  }\n\n      default :\n\t  if (t->child != NULL)\n            parse_doc(t->child, left, right, bottom, top, x, y, page, para,\n\t              needspace);\n          break;\n    }\n\n\n    // Check for some basic stylesheet stuff...\n    if ((style = htmlGetStyle(t, (uchar *)\"page-break-after:\")) != NULL &&\n\tstrcasecmp((char *)style, \"avoid\") != 0)\n    {\n      // Advance to the next page...\n      (*page) ++;\n      *x         = *left;\n      *y         = *top;\n      *needspace = 0;\n\n      // See if we need to go to the next left/righthand page...\n      if (PageDuplex && ((*page) & 1) &&\n          strcasecmp((char *)style, \"right\") == 0)\n\t(*page) ++;\n      else if (PageDuplex && !((*page) & 1) &&\n               strcasecmp((char *)style, \"left\") == 0)\n\t(*page) ++;\n\n      // Update the progress as necessary...\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n    }\n\n    // Move to the next node...\n    t = t->next;\n  }\n\n  if (para->child != NULL && cpara != para)\n  {\n    parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n    htmlDeleteTree(para->child);\n    para->child = para->last_child = NULL;\n    *needspace  = 0;\n  }\n\n  if (cpara != para)\n    htmlDeleteTree(para);\n\n  DEBUG_printf((\"LEAVING parse_doc(), x = %.1f, y = %.1f, page = %d\\n\",\n                *x, *y, *page));\n}\n\n\n/*\n * 'parse_heading()' - Parse a heading tree and produce rendering list output.\n */\n\nstatic void\nparse_heading(tree_t *t,\t/* I - Tree to parse */\n              float  left,\t/* I - Left margin */\n              float  right,\t/* I - Printable width */\n              float  bottom,\t/* I - Bottom margin */\n              float  top,\t/* I - Printable top */\n              float  *x,\t/* IO - X position */\n              float  *y,\t/* IO - Y position */\n              int    *page,\t/* IO - Page # */\n              int    needspace)\t/* I - Need whitespace? */\n{\n  int\t*temp;\t\t\t// Temporary integer array pointer\n\n\n  DEBUG_printf((\"parse_heading(t=%p, left=%.1f, right=%.1f, bottom=%.1f, top=%.1f, x=%.1f, y=%.1f, page=%d, needspace=%d\\n\",\n                (void *)t, left, right, bottom, top, *x, *y, *page, needspace));\n\n  if (((t->markup - MARKUP_H1) < TocLevels || TocLevels == 0) && !title_page)\n    current_heading = t->child;\n\n  if (*y < (5 * _htmlSpacings[SIZE_P] + bottom))\n  {\n    (*page) ++;\n    *y = top;\n    if (Verbosity)\n      progress_show(\"Formatting page %d\", *page);\n  }\n\n  check_pages(*page);\n\n  if (t->markup == MARKUP_H1 && !title_page)\n    pages[*page].chapter = htmlGetText(current_heading);\n\n  if ((pages[*page].heading == NULL || t->markup == MARKUP_H1 ||\n      (*page > 0 && pages[*page].heading == pages[*page - 1].heading)) &&\n      !title_page)\n  {\n    pages[*page].heading  = htmlGetText(current_heading);\n    pages[*page].headnode = current_heading;\n  }\n\n  if ((t->markup - MARKUP_H1) < TocLevels && !title_page)\n  {\n    DEBUG_printf((\"H%d: heading_pages[%d] = %d\\n\", t->markup - MARKUP_H1 + 1,\n                  (int)num_headings, *page - 1));\n\n    // See if we need to resize the headings arrays...\n    if (num_headings >= alloc_headings)\n    {\n      alloc_headings += ALLOC_HEADINGS;\n\n      if (num_headings == 0)\n        temp = (int *)malloc(sizeof(int) * alloc_headings);\n      else\n        temp = (int *)realloc(heading_pages, sizeof(int) * alloc_headings);\n\n      if (temp == NULL)\n      {\n        progress_error(HD_ERROR_OUT_OF_MEMORY,\n                       \"Unable to allocate memory for %d headings - %s\",\n\t               (int)alloc_headings, strerror(errno));\n\talloc_headings -= ALLOC_HEADINGS;\n\treturn;\n      }\n\n      memset(temp + alloc_headings - ALLOC_HEADINGS, 0,\n             sizeof(int) * ALLOC_HEADINGS);\n\n      heading_pages = temp;\n\n      if (num_headings == 0)\n        temp = (int *)malloc(sizeof(int) * alloc_headings);\n      else\n        temp = (int *)realloc(heading_tops, sizeof(int) * alloc_headings);\n\n      if (temp == NULL)\n      {\n        progress_error(HD_ERROR_OUT_OF_MEMORY,\n                       \"Unable to allocate memory for %d headings - %s\",\n\t               (int)alloc_headings, strerror(errno));\n\talloc_headings -= ALLOC_HEADINGS;\n\treturn;\n      }\n\n      memset(temp + alloc_headings - ALLOC_HEADINGS, 0,\n             sizeof(int) * ALLOC_HEADINGS);\n\n      heading_tops = temp;\n    }\n\n    heading_pages[num_headings] = *page;\n    heading_tops[num_headings]  = (int)(*y + 4 * _htmlSpacings[SIZE_P]);\n    num_headings ++;\n  }\n\n  parse_paragraph(t, left, right, bottom, top, x, y, page, needspace);\n\n  if (t->halignment == ALIGN_RIGHT && t->markup == MARKUP_H1 &&\n      OutputType == OUTPUT_BOOK && !title_page)\n  {\n   /*\n    * Special case - chapter heading for users manual...\n    */\n\n    *y = bottom + 0.5f * (top - bottom);\n  }\n}\n\n#if defined(PARA_DEBUG) && !defined(DEBUG)\n#  undef DEBUG_printf\n#  undef DEBUG_puts\n#  define DEBUG_printf(x) printf x\n#  define DEBUG_puts(x) puts(x)\n#endif /* PARA_DEBUG && !defined(DEBUG) */\n\n\n/*\n * 'parse_paragraph()' - Parse a paragraph tree and produce rendering list\n *                       output.\n */\n\nstatic void\nparse_paragraph(tree_t *t,\t/* I - Tree to parse */\n        \tfloat  left,\t/* I - Left margin */\n        \tfloat  right,\t/* I - Printable width */\n        \tfloat  bottom,\t/* I - Bottom margin */\n        \tfloat  top,\t/* I - Printable top */\n        \tfloat  *x,\t/* IO - X position */\n        \tfloat  *y,\t/* IO - Y position */\n        \tint    *page,\t/* IO - Page # */\n        \tint    needspace)/* I - Need whitespace? */\n{\n  int\t\twhitespace;\t/* Non-zero if a fragment ends in whitespace */\n  tree_t\t*flat,\n\t\t*start,\n\t\t*end,\n\t\t*prev,\n\t\t*temp;\n  float\t\twidth,\n\t\theight,\n\t\toffset,\n\t\tspacing,\n\t\tborderspace,\n\t\ttemp_y,\n\t\ttemp_width,\n\t\ttemp_height;\n  float\t\tformat_width, image_y, image_left, image_right;\n  int\t\timage_page = *page;\n  float\t\tchar_spacing;\n  int\t\tnum_chars;\n  render_t\t*r;\n  uchar\t\t*align,\n\t\t*hspace,\n\t\t*vspace,\n\t\t*link,\n\t\t*border;\n  float\t\trgb[3];\n  uchar\t\tline[10240],\n\t\t*lineptr,\n\t\t*dataptr;\n  tree_t\t*linetype;\n  float\t\tlinex,\n\t\tlinewidth;\n  int\t\tfirstline;\n\n\n  DEBUG_printf((\"parse_paragraph(t=%p, left=%.1f, right=%.1f, bottom=%.1f, top=%.1f, x=%.1f, y=%.1f, page=%d, needspace=%d\\n\",\n                (void *)t, left, right, bottom, top, *x, *y, *page, needspace));\n\n  flat        = flatten_tree(t->child);\n  image_left  = left;\n  image_right = right;\n  image_y     = 0;\n\n  if (flat == NULL)\n    DEBUG_puts(\"parse_paragraph: flat == NULL!\");\n\n  // Add leading whitespace...\n  if (*y < top && needspace)\n    *y -= _htmlSpacings[SIZE_P];\n\n /*\n  * First scan for images with left/right alignment tags...\n  */\n\n  for (temp = flat, prev = NULL; temp != NULL;)\n  {\n    if (temp->markup == MARKUP_IMG)\n      update_image_size(temp);\n\n    if (temp->markup == MARKUP_IMG &&\n        (align = htmlGetVariable(temp, (uchar *)\"ALIGN\")))\n    {\n      if ((border = htmlGetVariable(temp, (uchar *)\"BORDER\")) != NULL)\n\tborderspace = (float)atof((char *)border);\n      else if (temp->link)\n\tborderspace = 1;\n      else\n\tborderspace = 0;\n\n      borderspace *= PagePrintWidth / _htmlBrowserWidth;\n\n      if (strcasecmp((char *)align, \"LEFT\") == 0)\n      {\n        if ((vspace = htmlGetVariable(temp, (uchar *)\"VSPACE\")) != NULL)\n\t  *y -= atoi((char *)vspace);\n\n        if (*y < (bottom + temp->height + 2 * borderspace))\n        {\n\t  (*page) ++;\n\t  *y = top;\n\n\t  if (Verbosity)\n\t    progress_show(\"Formatting page %d\", *page);\n        }\n\n        if (borderspace > 0.0f)\n\t{\n\t  if (temp->link && PSLevel == 0)\n\t    memcpy(rgb, link_color, sizeof(rgb));\n\t  else\n\t  {\n\t    rgb[0] = temp->red / 255.0f;\n\t    rgb[1] = temp->green / 255.0f;\n\t    rgb[2] = temp->blue / 255.0f;\n\t  }\n\n\t  // Top\n          new_render(*page, RENDER_BOX, image_left, *y - borderspace,\n\t\t     temp->width + 2 * borderspace, borderspace, rgb);\n\t  // Left\n          new_render(*page, RENDER_BOX, image_left,\n\t             *y - temp->height - 2 * borderspace,\n                     borderspace, temp->height + 2 * borderspace, rgb);\n\t  // Right\n          new_render(*page, RENDER_BOX, image_left + temp->width + borderspace,\n\t             *y - temp->height - 2 * borderspace,\n                     borderspace, temp->height + 2 * borderspace, rgb);\n\t  // Bottom\n          new_render(*page, RENDER_BOX, image_left,\n\t             *y - temp->height - 2 * borderspace,\n                     temp->width + 2 * borderspace, borderspace, rgb);\n\t}\n\n        *y -= borderspace;\n\n        new_render(*page, RENDER_IMAGE, image_left + borderspace,\n\t           *y - temp->height, temp->width, temp->height,\n\t\t   image_find((char *)htmlGetVariable(temp, (uchar *)\"REALSRC\")));\n\n        if (temp->link &&\n\t    (link = htmlGetVariable(temp->link, (uchar *)\"_HD_FULL_HREF\")) != NULL)\n        {\n\t /*\n\t  * Add a page link...\n\t  */\n\n\t  new_render(*page, RENDER_LINK, image_left + borderspace, *y - temp->height, temp->width, temp->height, link);\n        }\n\n        *y -= borderspace;\n\n        if (vspace != NULL)\n\t  *y -= atoi((char *)vspace);\n\n        image_left += temp->width + 2 * borderspace;\n\ttemp_y     = *y - temp->height;\n\timage_page = *page;\n\n\tif (temp_y < image_y || image_y == 0)\n\t  image_y = temp_y;\n\n        if ((hspace = htmlGetVariable(temp, (uchar *)\"HSPACE\")) != NULL)\n\t  image_left += atoi((char *)hspace);\n\n        if (prev != NULL)\n          prev->next = temp->next;\n        else\n          flat = temp->next;\n\n        free(temp);\n        temp = prev;\n      }\n      else if (strcasecmp((char *)align, \"RIGHT\") == 0)\n      {\n        if ((vspace = htmlGetVariable(temp, (uchar *)\"VSPACE\")) != NULL)\n\t  *y -= atoi((char *)vspace);\n\n        if (*y < (bottom + temp->height + 2 * borderspace))\n        {\n\t  (*page) ++;\n\t  *y = top;\n\n\t  if (Verbosity)\n\t    progress_show(\"Formatting page %d\", *page);\n        }\n\n        image_right -= temp->width + 2 * borderspace;\n\timage_page = *page;\n\n        if (borderspace > 0.0f)\n\t{\n\t  if (temp->link && PSLevel == 0)\n\t    memcpy(rgb, link_color, sizeof(rgb));\n\t  else\n\t  {\n\t    rgb[0] = temp->red / 255.0f;\n\t    rgb[1] = temp->green / 255.0f;\n\t    rgb[2] = temp->blue / 255.0f;\n\t  }\n\n\t  // Top\n          new_render(*page, RENDER_BOX, image_right, *y - borderspace,\n\t\t     temp->width + 2 * borderspace, borderspace, rgb);\n\t  // Left\n          new_render(*page, RENDER_BOX, image_right,\n\t             *y - temp->height - 2 * borderspace,\n                     borderspace, temp->height + 2 * borderspace, rgb);\n\t  // Right\n          new_render(*page, RENDER_BOX, image_right + temp->width + borderspace,\n\t             *y - temp->height - 2 * borderspace,\n                     borderspace, temp->height + 2 * borderspace, rgb);\n\t  // Bottom\n          new_render(*page, RENDER_BOX, image_right, *y - temp->height - 2 * borderspace,\n                     temp->width + 2 * borderspace, borderspace, rgb);\n\t}\n\n        *y -= borderspace;\n\n        new_render(*page, RENDER_IMAGE, image_right + borderspace,\n\t           *y - temp->height, temp->width, temp->height,\n\t\t   image_find((char *)htmlGetVariable(temp, (uchar *)\"REALSRC\")));\n\n        if (temp->link &&\n\t    (link = htmlGetVariable(temp->link, (uchar *)\"_HD_FULL_HREF\")) != NULL)\n        {\n\t /*\n\t  * Add a page link...\n\t  */\n\n\t  new_render(*page, RENDER_LINK, image_right + borderspace, *y - temp->height, temp->width, temp->height, link);\n        }\n\n        *y -= borderspace;\n\n        if (vspace != NULL)\n\t  *y -= atoi((char *)vspace);\n\n\ttemp_y = *y - temp->height;\n\n\tif (temp_y < image_y || image_y == 0)\n\t  image_y = temp_y;\n\n        if ((hspace = htmlGetVariable(temp, (uchar *)\"HSPACE\")) != NULL)\n\t  image_right -= atoi((char *)hspace);\n\n        if (prev != NULL)\n          prev->next = temp->next;\n        else\n          flat = temp->next;\n\n        free(temp);\n        temp = prev;\n      }\n    }\n\n    if (temp != NULL)\n    {\n      prev = temp;\n      temp = temp->next;\n    }\n    else\n      temp = flat;\n  }\n\n /*\n  * Then format the text and inline images...\n  */\n\n  format_width = image_right - image_left;\n  firstline    = 1;\n\n  DEBUG_printf((\"format_width = %.1f\\n\", format_width));\n\n  // Make stupid compiler warnings go away (if you can't put\n  // enough smarts in the compiler, don't add the warning!)\n  offset      = 0.0f;\n  temp_width  = 0.0f;\n  temp_height = 0.0f;\n  lineptr     = NULL;\n  linex       = 0.0f;\n  linewidth   = 0.0f;\n\n  while (flat != NULL)\n  {\n    start = flat;\n    end   = flat;\n    width = 0.0;\n\n    while (flat != NULL)\n    {\n      // Get fragments...\n      temp_width = 0.0;\n      temp       = flat;\n      whitespace = 0;\n\n      while (temp != NULL && !whitespace)\n      {\n        if (temp->markup == MARKUP_NONE && temp->data[0] == ' ')\n\t{\n          if (temp == start)\n            temp_width -= _htmlWidths[temp->typeface][temp->style][' '] *\n                          _htmlSizes[temp->size] * 0.001f;\n          else if (temp_width > 0.0f)\n\t    whitespace = 1;\n\t}\n        else\n          whitespace = 0;\n\n        if (whitespace)\n\t  break;\n\n        if (temp->markup == MARKUP_IMG)\n\t{\n\t  if ((border = htmlGetVariable(temp, (uchar *)\"BORDER\")) != NULL)\n\t    borderspace = (float)atof((char *)border);\n\t  else if (temp->link)\n\t    borderspace = 1;\n\t  else\n\t    borderspace = 0;\n\n          borderspace *= PagePrintWidth / _htmlBrowserWidth;\n\n          temp_width += 2 * borderspace;\n\t}\n\n        prev       = temp;\n        temp       = temp->next;\n        temp_width += prev->width;\n\n        if ((temp_width >= format_width && prev->markup == MARKUP_IMG) ||\n\t    prev->markup == MARKUP_BR)\n\t{\n\t  break;\n\t}\n\telse if (prev->markup == MARKUP_NONE)\n\t{\n\t  int\tch = prev->data[strlen((char *)prev->data) - 1];\n\n\t  if (_htmlUTF8)\n\t    ch = _htmlUnicode[ch];\n\n          if (ch == 173)\n            break;\n\t}\n      }\n\n      if ((width + temp_width) <= format_width)\n      {\n        width += temp_width;\n        end  = temp;\n        flat = temp;\n\n        if (prev->markup == MARKUP_BR)\n          break;\n      }\n      else if (width == 0.0)\n      {\n        width += temp_width;\n        end  = temp;\n        flat = temp;\n        break;\n      }\n      else\n        break;\n    }\n\n    if (start == end)\n    {\n      end   = start->next;\n      flat  = start->next;\n      width = start->width;\n    }\n\n    for (height = 0.0, num_chars = 0, temp = prev = start;\n         temp != end;\n\t temp = temp->next)\n    {\n      prev = temp;\n\n      if (temp->markup == MARKUP_NONE)\n        num_chars += strlen((char *)temp->data);\n\n      if (temp->height > height)\n        height = temp->height;\n    }\n\n    for (spacing = 0.0, temp = prev = start;\n         temp != end;\n\t temp = temp->next)\n    {\n      prev = temp;\n\n      if (temp->markup != MARKUP_IMG)\n        temp_height = (float)(temp->height * _htmlSpacings[0] / _htmlSizes[0]);\n      else\n      {\n\tif ((border = htmlGetVariable(temp, (uchar *)\"BORDER\")) != NULL)\n\t  borderspace = (float)atof((char *)border);\n\telse if (temp->link)\n\t  borderspace = 1;\n\telse\n\t  borderspace = 0;\n\n        borderspace *= PagePrintWidth / _htmlBrowserWidth;\n\n        temp_height = temp->height + 2 * borderspace;\n      }\n\n      if (temp_height > spacing)\n        spacing = temp_height;\n    }\n\n    if (firstline && end != NULL && *y < (bottom + height + _htmlSpacings[t->size]))\n    {\n      // Go to next page since only 1 line will fit on this one...\n      (*page) ++;\n      *y = top;\n\n      if (Verbosity)\n        progress_show(\"Formatting page %d\", *page);\n    }\n\n    firstline = 0;\n\n    if (height == 0.0f)\n      height = spacing;\n\n    for (temp = start; temp != end; temp = temp->next)\n      if (temp->markup != MARKUP_A)\n        break;\n\n    if (temp != NULL && temp->markup == MARKUP_NONE && temp->data[0] == ' ')\n    {\n      // Drop leading space...\n      for (dataptr = temp->data; *dataptr; dataptr ++)\n        *dataptr = dataptr[1];\n      *dataptr = '\\0';\n\n      temp_width = _htmlWidths[temp->typeface][temp->style][' '] * _htmlSizes[temp->size] * 0.001f;\n      temp->width -= temp_width;\n      num_chars --;\n    }\n\n    if (end != NULL)\n      temp = end->prev;\n    else\n      temp = NULL;\n\n    DEBUG_printf((\"    BEFORE page=%d, y=%.1f, height=%.1f, spacing=%.1f, bottom=%.1f\\n\", *page, *y, height, spacing, bottom));\n\n    if (*y < (spacing + bottom))\n    {\n      (*page) ++;\n      *y = top;\n\n      if (Verbosity)\n        progress_show(\"Formatting page %d\", *page);\n    }\n\n    *y -= height;\n\n    DEBUG_printf((\"    page=%d, y=%.1f, width=%.1f, height=%.1f\\n\", *page, *y, width, height));\n\n    if (Verbosity)\n      progress_update(100 - (int)(100 * (*y) / PagePrintLength));\n\n    char_spacing = 0.0f;\n    whitespace   = 0;\n    temp         = start;\n    linetype     = NULL;\n\n    rgb[0] = temp->red / 255.0f;\n    rgb[1] = temp->green / 255.0f;\n    rgb[2] = temp->blue / 255.0f;\n\n    switch (t->halignment)\n    {\n      case ALIGN_LEFT :\n          linex = image_left;\n\t  break;\n\n      case ALIGN_CENTER :\n          linex = image_left + 0.5f * (format_width - width);\n\t  break;\n\n      case ALIGN_RIGHT :\n          linex = image_right - width;\n\t  break;\n\n      case ALIGN_JUSTIFY :\n          linex = image_left;\n\t  if (flat != NULL && flat->prev->markup != MARKUP_BR && num_chars > 1)\n\t    char_spacing = (format_width - width) / (num_chars - 1);\n\t  break;\n    }\n\n    while (temp != end)\n    {\n      if (temp->link != NULL && PSLevel == 0 && Links &&\n          temp->markup == MARKUP_NONE)\n      {\n\ttemp->red   = (uchar)(link_color[0] * 255.0);\n\ttemp->green = (uchar)(link_color[1] * 255.0);\n\ttemp->blue  = (uchar)(link_color[2] * 255.0);\n      }\n\n     /*\n      * See if we are doing a run of characters in a line and need to\n      * output this run...\n      */\n\n      if (linetype != NULL &&\n\t  (temp->markup != MARKUP_NONE ||\n\t   temp->typeface != linetype->typeface ||\n\t   temp->style != linetype->style ||\n\t   temp->size != linetype->size ||\n\t   temp->superscript != linetype->superscript ||\n\t   temp->subscript != linetype->subscript ||\n\t   temp->red != linetype->red ||\n\t   temp->green != linetype->green ||\n\t   temp->blue != linetype->blue))\n      {\n        r = new_render(*page, RENDER_TEXT, linex - linewidth, *y,\n\t               linewidth, linetype->height, line);\n\tr->data.text.typeface = linetype->typeface;\n\tr->data.text.style    = linetype->style;\n\tr->data.text.size     = (float)_htmlSizes[linetype->size];\n\tr->data.text.spacing  = char_spacing;\n        memcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n\tif (linetype->superscript)\n          r->y += height - linetype->height;\n        else if (linetype->subscript)\n          r->y -= height - linetype->height;\n\n        free(linetype);\n        linetype = NULL;\n      }\n\n      if ((link = htmlGetVariable(temp, (uchar *)\"ID\")) != NULL)\n      {\n       /*\n\t* Add a target link...\n\t*/\n\n\tadd_link(link, *page, (int)(*y + height));\n      }\n\n      switch (temp->markup)\n      {\n        case MARKUP_A :\n            if ((link = htmlGetVariable(temp, (uchar *)\"NAME\")) != NULL)\n            {\n             /*\n              * Add a target link...\n              */\n\n              add_link(link, *page, (int)(*y + height));\n            }\n\n\tdefault :\n\t    temp_width = temp->width;\n            break;\n\n        case MARKUP_NONE :\n            if (temp->data == NULL)\n              break;\n\n\t    if (((temp->width - right + left) > 0.001 ||\n\t         (temp->height - top + bottom) > 0.001)  && OverflowErrors)\n\t      progress_error(HD_ERROR_CONTENT_TOO_LARGE,\n\t                     \"Text on page %d too large - \"\n\t\t\t     \"truncation or overlapping may occur!\", *page + 1);\n\n            if (linetype == NULL)\n            {\n\t      linetype  = temp;\n\t      lineptr   = line;\n\t      linewidth = 0.0;\n\n\t      rgb[0] = temp->red / 255.0f;\n\t      rgb[1] = temp->green / 255.0f;\n\t      rgb[2] = temp->blue / 255.0f;\n\t    }\n\n            strlcpy((char *)lineptr, (char *)temp->data, sizeof(line) - (size_t)(lineptr - line));\n\n            temp_width = temp->width + char_spacing * strlen((char *)lineptr);\n\n\t    if (temp->underline || (temp->link && LinkStyle && PSLevel == 0))\n\t      new_render(*page, RENDER_BOX, linex, *y - 1, temp_width, 0, rgb);\n\n\t    if (temp->strikethrough)\n\t      new_render(*page, RENDER_BOX, linex, *y + temp->height * 0.25f,\n\t                 temp_width, 0, rgb);\n\n            linewidth  += temp_width;\n            lineptr    += strlen((char *)lineptr);\n\n            if (lineptr > line && lineptr[-1] == ' ')\n              whitespace = 1;\n            else\n              whitespace = 0;\n\t    break;\n\n\tcase MARKUP_IMG :\n\t    if (((temp->width - right + left) > 0.001 ||\n\t         (temp->height - top + bottom) > 0.001) && OverflowErrors)\n\t    {\n\t      DEBUG_printf((\"IMAGE: %.3fx%.3f > %.3fx%.3f\\n\",\n\t                    temp->width, temp->height,\n\t\t\t    right - left, top - bottom));\n\n\t      progress_error(HD_ERROR_CONTENT_TOO_LARGE,\n\t                     \"Image on page %d too large - \"\n\t\t\t     \"truncation or overlapping may occur!\", *page + 1);\n            }\n\n\t    if ((border = htmlGetVariable(temp, (uchar *)\"BORDER\")) != NULL)\n\t      borderspace = (float)atof((char *)border);\n\t    else if (temp->link)\n\t      borderspace = 1;\n\t    else\n\t      borderspace = 0;\n\n            borderspace *= PagePrintWidth / _htmlBrowserWidth;\n\n            temp_width += 2 * borderspace;\n\n\t    switch (temp->valignment)\n\t    {\n\t      case ALIGN_TOP :\n\t\t  offset = height - temp->height - 2 * borderspace;\n\t\t  break;\n\t      case ALIGN_MIDDLE :\n\t\t  offset = 0.5f * (height - temp->height) - borderspace;\n\t\t  break;\n\t      case ALIGN_BOTTOM :\n\t\t  offset = 0.0f;\n\t    }\n\n            if (borderspace > 0.0f)\n\t    {\n\t      // Top\n              new_render(*page, RENDER_BOX, linex,\n\t                 *y + offset + temp->height + borderspace,\n\t\t\t temp->width + 2 * borderspace, borderspace, rgb);\n\t      // Left\n              new_render(*page, RENDER_BOX, linex, *y + offset,\n                \t borderspace, temp->height + 2 * borderspace, rgb);\n\t      // Right\n              new_render(*page, RENDER_BOX, linex + temp->width + borderspace,\n\t                 *y + offset, borderspace,\n\t\t\t temp->height + 2 * borderspace, rgb);\n\t      // Bottom\n              new_render(*page, RENDER_BOX, linex, *y + offset,\n                \t temp->width + 2 * borderspace, borderspace, rgb);\n\t    }\n\n\t    new_render(*page, RENDER_IMAGE, linex + borderspace,\n\t               *y + offset + borderspace, temp->width, temp->height,\n\t\t       image_find((char *)htmlGetVariable(temp, (uchar *)\"REALSRC\")));\n            whitespace = 0;\n\t    temp_width = temp->width + 2 * borderspace;\n\t    break;\n      }\n\n      if (temp->link != NULL &&\n          (link = htmlGetVariable(temp->link, (uchar *)\"_HD_FULL_HREF\")) != NULL)\n      {\n       /*\n\t* Add a page link...\n\t*/\n\n\tnew_render(*page, RENDER_LINK, linex, *y + offset, temp->width, temp->height, link);\n      }\n\n      linex += temp_width;\n      prev = temp;\n      temp = temp->next;\n      if (prev != linetype)\n        free(prev);\n    }\n\n   /*\n    * See if we have a run of characters that hasn't been output...\n    */\n\n    if (linetype != NULL)\n    {\n      r = new_render(*page, RENDER_TEXT, linex - linewidth, *y,\n                     linewidth, linetype->height, line);\n      r->data.text.typeface = linetype->typeface;\n      r->data.text.style    = linetype->style;\n      r->data.text.spacing  = char_spacing;\n      r->data.text.size     = (float)_htmlSizes[linetype->size];\n      memcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n      if (linetype->superscript)\n        r->y += height - linetype->height;\n      else if (linetype->subscript)\n        r->y -= height - linetype->height;\n\n      free(linetype);\n    }\n\n   /*\n    * Update the margins after we pass below the images...\n    */\n\n    *y -= spacing - height;\n\n    DEBUG_printf((\"    AFTER y=%.1f, bottom=%.1f\\n\", *y, bottom));\n\n    if (*y < bottom)\n    {\n      (*page) ++;\n      *y = top;\n\n      if (Verbosity)\n        progress_show(\"Formatting page %d\", *page);\n    }\n\n    if (*y < image_y || *page > image_page)\n    {\n      image_y      = 0.0f;\n      image_left   = left;\n      image_right  = right;\n      format_width = image_right - image_left;\n    }\n  }\n\n  *x = left;\n  if (*y > image_y && image_y > 0.0f && image_page == *page)\n    *y = image_y;\n\n  DEBUG_printf((\"LEAVING parse_paragraph(), x = %.1f, y = %.1f, page = %d, image_y = %.1f\\n\", *x, *y, *page, image_y));\n}\n\n\n#if defined(PARA_DEBUG) && !defined(DEBUG)\n#  undef DEBUG_printf\n#  undef DEBUG_puts\n#  define DEBUG_printf(x)\n#  define DEBUG_puts(x)\n#endif /* PARA_DEBUG && !DEBUG */\n\n\n/*\n * 'parse_pre()' - Parse preformatted text and produce rendering list output.\n */\n\nstatic void\nparse_pre(tree_t *t,\t\t/* I - Tree to parse */\n          float  left,\t\t/* I - Left margin */\n          float  right,\t\t/* I - Printable width */\n          float  bottom,\t/* I - Bottom margin */\n          float  top,\t\t/* I - Printable top */\n          float  *x,\t\t/* IO - X position */\n          float  *y,\t\t/* IO - Y position */\n          int    *page,\t\t/* IO - Page # */\n          int    needspace)\t/* I - Need whitespace? */\n{\n  tree_t\t*flat, *start, *next;\n  uchar\t\t*link,\n\t\tline[10240],\n\t\t*lineptr,\n\t\t*dataptr;\n  int\t\tcol;\n  float\t\twidth,\n\t\theight,\n\t\trgb[3];\n  render_t\t*r;\n\n\n  REF(right);\n\n  DEBUG_printf((\"parse_pre(t=%p, left=%.1f, right=%.1f, x=%.1f, y=%.1f, page=%d\\n\",\n                (void *)t, left, right, *x, *y, *page));\n\n  if (t->child == NULL)\n    return;\n\n  if (*y < top && needspace)\n    *y -= _htmlSpacings[SIZE_P];\n\n  flat = flatten_tree(t->child);\n\n  if (flat == NULL)\n    return;\n\n  if (flat->markup == MARKUP_NONE && flat->data != NULL)\n  {\n    // Skip leading blank line, if present...\n    for (dataptr = flat->data; isspace(*dataptr); dataptr ++);\n\n    if (!*dataptr)\n    {\n      next = flat->next;\n      free(flat);\n      flat = next;\n    }\n  }\n\n  while (flat != NULL)\n  {\n    for (height = 0.0f, start = flat; flat != NULL; flat = flat->next)\n    {\n      if (flat->height > height)\n        height = flat->height;\n\n      if (flat->markup == MARKUP_BR ||\n          (flat->markup == MARKUP_NONE && flat->data &&\n\t   flat->data[strlen((char *)flat->data) - 1] == '\\n'))\n        break;\n    }\n\n    if (flat)\n      flat = flat->next;\n\n    if (*y < (height + bottom))\n    {\n      (*page) ++;\n      *y = top;\n\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n    }\n\n    *x = left;\n    *y -= height;\n\n    if (Verbosity)\n      progress_update(100 - (int)(100 * (*y) / PagePrintLength));\n\n    col = 0;\n    while (start != flat)\n    {\n      rgb[0] = start->red / 255.0f;\n      rgb[1] = start->green / 255.0f;\n      rgb[2] = start->blue / 255.0f;\n\n      if (start->link &&\n\t  (link = htmlGetVariable(start->link, (uchar *)\"_HD_FULL_HREF\")) != NULL)\n      {\n       /*\n\t* Add a page link...\n\t*/\n\n\tnew_render(*page, RENDER_LINK, *x, *y, start->width, start->height, link);\n\n\tif (PSLevel == 0 && Links)\n\t{\n          memcpy(rgb, link_color, sizeof(rgb));\n\n\t  start->red   = (uchar)(link_color[0] * 255.0);\n\t  start->green = (uchar)(link_color[1] * 255.0);\n\t  start->blue  = (uchar)(link_color[2] * 255.0);\n\n          if (LinkStyle)\n\t    new_render(*page, RENDER_BOX, *x, *y - 1, start->width, 0,\n\t               link_color);\n\t}\n      }\n\n      if ((link = htmlGetVariable(start, (uchar *)\"ID\")) != NULL)\n      {\n       /*\n\t* Add a target link...\n\t*/\n\n\tadd_link(link, *page, (int)(*y + height));\n      }\n\n      switch (start->markup)\n      {\n        case MARKUP_COMMENT :\n\t    parse_comment(start, &left, &right, &bottom, &top, x, y, page, NULL, 0);\n            break;\n\n\tcase MARKUP_A :\n            if ((link = htmlGetVariable(start, (uchar *)\"NAME\")) != NULL)\n            {\n             /*\n              * Add a target link...\n              */\n\n              add_link(link, *page, (int)(*y + height));\n            }\n            break;\n\n\tcase MARKUP_NONE :\n            for (lineptr = line, dataptr = start->data;\n\t\t *dataptr != '\\0' && lineptr < (line + sizeof(line) - 1);\n\t\t dataptr ++)\n              if (*dataptr == '\\n')\n\t\tbreak;\n              else if (*dataptr == '\\t')\n              {\n               /* This code changed after 15 years to work around new compiler optimization bugs (Issue #349) */\n                int num_cols = 8 - (col & 7);\n\n                memcpy(lineptr, \"        \", num_cols);\n                lineptr += num_cols;\n                col += num_cols;\n              }\n              else if (*dataptr != '\\r')\n              {\n        \t*lineptr++ = *dataptr;\n        \tcol ++;\n              }\n\n            *lineptr = '\\0';\n\n            width = get_width(line, start->typeface, start->style, start->size);\n            r = new_render(*page, RENDER_TEXT, *x, *y, width, 0, line);\n            r->data.text.typeface = start->typeface;\n            r->data.text.style    = start->style;\n            r->data.text.size     = (float)_htmlSizes[start->size];\n            memcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n\t    if (start->underline)\n\t      new_render(*page, RENDER_BOX, *x, *y - 1, start->width, 0, rgb);\n\n\t    if (start->strikethrough)\n\t      new_render(*page, RENDER_BOX, *x, *y + start->height * 0.25f,\n\t        \t start->width, 0, rgb);\n\n            *x += start->width;\n            break;\n\n\tcase MARKUP_IMG :\n\t    new_render(*page, RENDER_IMAGE, *x, *y, start->width, start->height,\n\t\t       image_find((char *)htmlGetVariable(start, (uchar *)\"REALSRC\")));\n\n            *x += start->width;\n            col ++;\n\t    break;\n\n\tdefault :\n            break;\n      }\n\n      next = start->next;\n      free(start);\n      start = next;\n\n    }\n\n    if ((*x - right) > 0.001 && OverflowErrors)\n      progress_error(HD_ERROR_CONTENT_TOO_LARGE,\n\t             \"Preformatted text on page %d too long - \"\n\t\t     \"truncation or overlapping may occur!\", *page + 1);\n\n    *y -= _htmlSpacings[t->size] - _htmlSizes[t->size];\n  }\n\n  *x = left;\n}\n\n\n//#define TABLE_DEBUG 1\n#ifdef TABLE_DEBUG\n#  undef DEBUG_puts\n#  define DEBUG_puts(x) puts(x)\n#  define DEBUG 1\n#  undef DEBUG_printf\n#  define DEBUG_printf(x) printf x\n#endif /* TABLE_DEBUG */\n\n\ntypedef struct\n{\n  int           debug;\n  int           num_cols,\n                num_rows;\n  float         border,\n\t\tborder_left,\n                border_rgb[3],\n\t\tborder_size,\n                cellpadding,\n                height;\n  int\t\tcol_spans[MAX_COLUMNS],\n\t\trow_spans[MAX_COLUMNS];\n  char\t\tcol_fixed[MAX_COLUMNS],\n\t\tcol_percent[MAX_COLUMNS];\n  float\t\tcol_lefts[MAX_COLUMNS],\n\t\tcol_rights[MAX_COLUMNS],\n\t\tcol_widths[MAX_COLUMNS],\n\t\tcol_swidths[MAX_COLUMNS],\n\t\tcol_mins[MAX_COLUMNS],\n\t\tcol_smins[MAX_COLUMNS],\n\t\tcol_prefs[MAX_COLUMNS];\n  int\t\tcell_page[MAX_COLUMNS],\t// Start page for cell\n\t\tcell_endpage[MAX_COLUMNS];\n\t\t\t\t\t// End page for cell\n  float\t\tcell_y[MAX_COLUMNS],\t// Row for each cell\n\t\tcell_endy[MAX_COLUMNS],\t// Row for each cell\n\t\tcell_height[MAX_COLUMNS],\n\t\t\t\t\t// Height of each cell in a row\n\t\tspan_heights[MAX_COLUMNS];\n\t\t\t\t\t// Height of spans\n  render_t\t*cell_bg[MAX_COLUMNS];\t// Background rectangles\n  render_t\t*cell_start[MAX_COLUMNS];\n\t\t\t\t\t// Start of the content for a cell in the row\n  render_t\t*cell_end[MAX_COLUMNS];\t// End of the content for a cell in a row\n} hdtable_t;\n\n\n/*\n * 'render_table_row()' - Render a table row.\n */\n\nstatic void\nrender_table_row(hdtable_t &table,\n                 tree_t    ***cells,\n                 int       row,\n                 uchar     *height_var,\n                 float     left,\t\t// I - Left margin\n                 float     right,\t\t// I - Printable width\n                 float     bottom,\t\t// I - Bottom margin\n                 float     top,\t\t\t// I - Printable top\n                 float     *x,\n                 float     *y,\n                 int       *page)\n{\n  int\t\tcol,\n\t\ttcol,\n\t\tcolspan,\n\t\trowspan,\n\t\ttempspace;\n  float\t\twidth,\n\t\ttemp_y;\n  int\t\ttemp_page;\n  uchar\t\t*var;\n  int\t\tdo_valign;\t\t// True if we should do vertical alignment of cells\n  int           row_page;\n  float\t\trow_y,\n                row_starty,\n                row_height,\t\t// Total height of the row\n\t\ttemp_height;\t\t// Temporary holder\n  uchar\t\t*bgcolor;\n  float\t\tbgrgb[3];\n\n\n  do_valign  = 1;\n  row_height = 0.0f;\n  row_page   = *page;\n  row_y      = *y - table.cellpadding;\n  row_starty = row_y;\n\n  DEBUG_printf((\"BEFORE row_y = %.1f, *y = %.1f, row_page = %d\\n\",\n                row_y, *y, row_page));\n\n  for (col = 0, rowspan = 9999; col < table.num_cols; col += colspan)\n  {\n    if (table.row_spans[col] == 0)\n    {\n      if ((var = htmlGetVariable(cells[row][col], (uchar *)\"ROWSPAN\")) != NULL)\n        table.row_spans[col] = atoi((char *)var);\n\n      if (table.row_spans[col] == 1)\n        table.row_spans[col] = 0;\n\n      if (table.row_spans[col] > (table.num_rows - row))\n        table.row_spans[col] = table.num_rows - row;\n\n      table.span_heights[col] = 0.0f;\n    }\n\n    if (table.row_spans[col] < rowspan)\n      rowspan = table.row_spans[col];\n\n    for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)\n      if (cells[row][col] != cells[row][col + colspan])\n        break;\n  }\n\n  if (!rowspan)\n    rowspan = 1;\n\n  for (col = 0; col < table.num_cols;)\n  {\n    for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)\n      if (cells[row][col] != cells[row][col + colspan])\n        break;\n    colspan --;\n\n    DEBUG_printf((\"    col = %d, colspan = %d, left = %.1f, right = %.1f, cell = %p\\n\", col, colspan, table.col_lefts[col], table.col_rights[col + colspan], (void *)cells[row][col]));\n\n    *x        = table.col_lefts[col];\n    temp_y    = *y - table.cellpadding;\n    temp_page = *page;\n    tempspace = 0;\n\n    if (row == 0 || cells[row][col] != cells[row - 1][col])\n    {\n      check_pages(*page);\n\n      if (cells[row][col] == NULL)\n        bgcolor = NULL;\n      else if ((bgcolor = htmlGetVariable(cells[row][col], (uchar *)\"BGCOLOR\")) != NULL)\n      {\n        memcpy(bgrgb, background_color, sizeof(bgrgb));\n\n        get_color(bgcolor, bgrgb, 0);\n\n        width       = table.col_rights[col + colspan] - table.col_lefts[col] + 2 * table.cellpadding;\n        table.border_left = table.col_lefts[col] - table.cellpadding;\n\n        table.cell_bg[col] = new_render(*page, RENDER_BOX, table.border_left, row_y, width + table.border, 0.0, bgrgb);\n      }\n      else\n      {\n        table.cell_bg[col] = NULL;\n\n        new_render(*page, RENDER_TEXT, -1.0f, -1.0f, 0.0, 0.0, (void *)\"\");\n      }\n\n      DEBUG_printf((\"cell_bg[%d] = %p, pages[%d].end = %p\\n\", col, (void *)table.cell_bg[col], *page, (void *)pages[*page].end));\n\n      table.cell_start[col] = pages[*page].end;\n      table.cell_page[col]  = temp_page;\n      table.cell_y[col]     = temp_y;\n\n      if (table.debug)\n      {\n        check_pages(*page);\n\n        render_t *r;\n        char table_text[255];\n\n        snprintf(table_text, sizeof(table_text), \"cell=%p [%d,%d]\",\n                 (void *)cells[row][col], row, col);\n        r = new_render(temp_page, RENDER_TEXT, *x, temp_y,\n                       get_width((uchar *)table_text, TYPE_COURIER, STYLE_NORMAL, 1),\n                       _htmlSizes[1], table_text);\n\n        r->data.text.typeface = TYPE_COURIER;\n        r->data.text.style    = STYLE_NORMAL;\n        r->data.text.size     = (float)_htmlSizes[1];\n      }\n\n      if (cells[row][col] != NULL && cells[row][col]->child != NULL)\n      {\n        DEBUG_printf((\"    parsing cell %d,%d; width = %.1f\\n\", row, col, table.col_rights[col + colspan] - table.col_lefts[col]));\n\n        bottom += table.cellpadding;\n        top    -= table.cellpadding;\n\n        parse_doc(cells[row][col]->child, table.col_lefts + col, table.col_rights + col + colspan, &bottom, &top, x, &temp_y, &temp_page, NULL, &tempspace);\n\n        bottom -= table.cellpadding;\n        top    += table.cellpadding;\n      }\n\n      table.cell_endpage[col] = temp_page;\n      table.cell_endy[col]    = temp_y;\n      table.cell_height[col]  = *y - table.cellpadding - temp_y;\n      table.cell_end[col]     = pages[*page].end;\n\n      if (table.cell_start[col] == NULL)\n        table.cell_start[col] = pages[*page].start;\n\n      DEBUG_printf((\"row = %d, col = %d, y = %.1f, cell_y = %.1f, cell_height = %.1f\\n\", row, col, *y - table.cellpadding, temp_y, table.cell_height[col]));\n      DEBUG_printf((\"cell_start[%d] = %p, cell_end[%d] = %p\\n\", col, (void *)table.cell_start[col], col, (void *)table.cell_end[col]));\n    }\n\n    if (table.row_spans[col] == 0 &&\n        table.cell_page[col] == table.cell_endpage[col] &&\n        table.cell_height[col] > row_height)\n      row_height = table.cell_height[col];\n\n    if (table.row_spans[col] <= rowspan)\n    {\n      if (table.cell_page[col] != table.cell_endpage[col])\n        do_valign = 0;\n\n      if (table.cell_endpage[col] > row_page)\n      {\n        row_page = table.cell_endpage[col];\n        row_y    = table.cell_endy[col];\n      }\n      else if (table.cell_endy[col] < row_y && table.cell_endpage[col] == row_page)\n        row_y = table.cell_endy[col];\n    }\n\n    DEBUG_printf((\"**** col = %d, row = %d, row_y = %.1f, row_page = %d\\n\", col, row, row_y, row_page));\n\n    for (col ++; colspan > 0; colspan --, col ++)\n    {\n      table.cell_start[col]   = NULL;\n      table.cell_page[col]    = table.cell_page[col - 1];\n      table.cell_y[col]       = table.cell_y[col - 1];\n      table.cell_end[col]     = NULL;\n      table.cell_endpage[col] = table.cell_endpage[col - 1];\n      table.cell_endy[col]    = table.cell_endy[col - 1];\n      table.cell_height[col]  = table.cell_height[col - 1];\n    }\n  }\n\n  DEBUG_printf((\"row = %d, row_y = %.1f, row_height = %.1f\\n\", row, row_y, row_height));\n\n  for (col = 0; col < table.num_cols; col += colspan)\n  {\n    for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)\n      if (cells[row][col] != cells[row][col + colspan])\n        break;\n\n    if (table.row_spans[col])\n      table.span_heights[col] += row_height;\n\n    DEBUG_printf((\"col = %d, cell_y = %.1f, cell_page = %d, cell_endpage = %d, row_spans = %d, span_heights = %.1f, cell_height = %.1f\\n\", col, table.cell_y[col], table.cell_page[col], table.cell_endpage[col], table.row_spans[col], table.span_heights[col], table.cell_height[col]));\n  }\n\n  for (col = 0; col < table.num_cols; col += colspan)\n  {\n    for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)\n      if (cells[row][col] != cells[row][col + colspan])\n        break;\n\n    if (table.row_spans[col] == rowspan &&\n        table.cell_page[col] == table.cell_endpage[col] &&\n        table.cell_height[col] > table.span_heights[col])\n    {\n      temp_height = table.cell_height[col] - table.span_heights[col];\n      row_height  += temp_height;\n      DEBUG_printf((\"Adjusting row-span height by %.1f, new row_height = %.1f\\n\", temp_height, row_height));\n\n      for (tcol = 0; tcol < table.num_cols; tcol ++)\n        if (table.row_spans[tcol])\n        {\n          table.span_heights[tcol] += temp_height;\n          DEBUG_printf((\"col = %d, span_heights = %.1f\\n\", tcol, table.span_heights[tcol]));\n        }\n    }\n  }\n\n  DEBUG_printf((\"AFTER row = %d, row_page = %d, row_y = %.1f, row_height = %.1f, *y = %.1f, do_valign = %d\\n\", row, row_page, row_y, row_height, *y, do_valign));\n\n /*\n  * Do the vertical alignment\n  */\n\n  if (do_valign)\n  {\n    height_var = NULL;\n\n    if (cells[row][0] != NULL)\n    {\n      if ((height_var = htmlGetVariable(cells[row][0]->parent, (uchar *)\"HEIGHT\")) == NULL)\n\tfor (col = 0; col < table.num_cols; col ++)\n\t  if (htmlGetVariable(cells[row][col], (uchar *)\"ROWSPAN\") == NULL)\n\t    if ((height_var = htmlGetVariable(cells[row][col], (uchar *)\"HEIGHT\")) != NULL)\n\t      break;\n    }\n\n    if (height_var != NULL)\n    {\n      // Hardcode the row height...\n      if (height_var[strlen((char *)height_var) - 1] == '%')\n        temp_height = (float)(atof((char *)height_var) * 0.01f * PagePrintLength);\n      else\n        temp_height = (float)(atof((char *)height_var) * PagePrintWidth / _htmlBrowserWidth);\n\n      if (table.height > 0 && temp_height > table.height)\n        temp_height = table.height;\n\n      temp_height -= 2 * table.cellpadding;\n\n      if (temp_height > row_height)\n      {\n        // Only enforce the height if it is > the actual row height.\n        row_height = temp_height;\n        row_y      = *y - temp_height;\n      }\n    }\n\n    for (col = 0; col < table.num_cols; col += colspan + 1)\n    {\n      render_t\t*p;\n      float\tdelta_y;\n\n\n      for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)\n        if (cells[row][col] != cells[row][col + colspan])\n          break;\n\n      colspan --;\n\n      if (table.cell_start[col] == NULL || table.row_spans[col] > rowspan ||\n          cells[row][col] == NULL || cells[row][col]->child == NULL)\n        continue;\n\n      if (table.row_spans[col] == 1)\n      {\n        int tcol;\n        float span_height = 0.0f;\n\n        for (tcol = 0; tcol < table.num_cols; tcol ++)\n        {\n          if (table.row_spans[col] == 1 && table.span_heights[col] > span_height)\n            span_height = table.span_heights[col];\n        }\n\n        switch (cells[row][col]->valignment)\n        {\n          case ALIGN_MIDDLE :\n//              delta_y = (table.span_heights[col] - table.cell_height[col]) * 0.5f;\n              delta_y = (span_height - table.cell_height[col]) * 0.5f;\n              break;\n\n          case ALIGN_BOTTOM :\n//              delta_y = table.span_heights[col] - table.cell_height[col];\n              delta_y = span_height - table.cell_height[col];\n              break;\n\n          default :\n              delta_y = 0.0f;\n              break;\n        }\n      }\n      else if (table.row_spans[col])\n      {\n        delta_y = 0.0f;\n      }\n      else\n      {\n        switch (cells[row][col]->valignment)\n        {\n          case ALIGN_MIDDLE :\n              delta_y = (row_height - table.cell_height[col]) * 0.5f;\n              break;\n\n          case ALIGN_BOTTOM :\n              delta_y = row_height - table.cell_height[col];\n              break;\n\n          default :\n              delta_y = 0.0f;\n              break;\n        }\n      }\n\n      DEBUG_printf((\"row = %d, col = %d, valign = %d, rowspans = %d, cell_height = %.1f, span_heights = %.1f, delta_y = %.1f\\n\", row, col, cells[row][col]->valignment, table.row_spans[col], table.cell_height[col], table.span_heights[col], delta_y));\n\n      if (delta_y > 0.0f)\n      {\n        if (table.cell_start[col] == table.cell_end[col])\n          p = table.cell_start[col];\n        else\n          p = table.cell_start[col]->next;\n\n        for (; p != NULL; p = p->next)\n        {\n          DEBUG_printf((\"aligning %p (%s), y was %.1f, now %.1f\\n\",\n                        (void *)p, p->data.text.buffer, p->y, p->y - delta_y));\n\n          p->y -= delta_y;\n          if (p == table.cell_end[col])\n            break;\n        }\n      }\n#ifdef DEBUG\n      else\n      {\n        if (table.cell_start[col] == table.cell_end[col])\n          p = table.cell_start[col];\n        else\n          p = table.cell_start[col]->next;\n\n        for (; p != NULL; p = p->next)\n        {\n          printf(\"NOT aligning %p (%s)\\n\", (void *)p, p->data.text.buffer);\n\n          if (p == table.cell_end[col])\n            break;\n        }\n      }\n#endif /* DEBUG */\n    }\n  }\n\n  // Update all current columns with ROWSPAN <= rowspan to use the same\n  // end page and row...\n  for (col = 0, temp_page = -1, temp_y = 99999999; col < table.num_cols; col ++)\n    if (table.row_spans[col] <= rowspan &&\n        cells[row][col] != NULL && cells[row][col]->child != NULL)\n    {\n      if (table.cell_endpage[col] > temp_page)\n      {\n        temp_page = table.cell_endpage[col];\n        temp_y    = table.cell_endy[col];\n      }\n      else if (table.cell_endpage[col] == temp_page && table.cell_endy[col] < temp_y)\n        temp_y = table.cell_endy[col];\n    }\n\n  for (col = 0; col < table.num_cols; col ++)\n    if (table.row_spans[col] <= rowspan &&\n        cells[row][col] != NULL && cells[row][col]->child != NULL)\n    {\n      table.cell_endpage[col] = temp_page;\n      table.cell_endy[col]    = temp_y;\n    }\n\n  row_y -= table.cellpadding;\n\n  table.border_left = table.col_lefts[0] - table.cellpadding;\n  width       = table.col_rights[table.num_cols - 1] - table.col_lefts[0] + 2 * table.cellpadding;\n\n  for (bgcolor = NULL, col = 0; col < table.num_cols; col ++)\n    if (table.row_spans[col] <= rowspan &&\n        cells[row][col] &&\n        !htmlGetVariable(cells[row][col], (uchar *)\"ROWSPAN\") &&\n        (bgcolor = htmlGetVariable(cells[row][col]->parent,\n                                   (uchar *)\"BGCOLOR\")) != NULL)\n      break;\n\n  if (bgcolor)\n  {\n    memcpy(bgrgb, background_color, sizeof(bgrgb));\n\n    get_color(bgcolor, bgrgb, 0);\n\n    if (row_page > *page)\n    {\n      // Draw background on multiple pages...\n\n      // Bottom of first page...\n      new_render(*page, RENDER_BOX, table.border_left, bottom,\n                 width, row_starty - bottom + table.cellpadding, bgrgb,\n                 pages[*page].start);\n\n      // Intervening pages...\n      for (temp_page = *page + 1; temp_page < row_page; temp_page ++)\n      {\n        new_render(temp_page, RENDER_BOX, table.border_left, bottom,\n                   width, top - bottom, bgrgb, pages[temp_page].start);\n      }\n\n      // Top of last page...\n      check_pages(*page);\n\n      new_render(row_page, RENDER_BOX, table.border_left, row_y,\n                 width, top - row_y, bgrgb,\n                 pages[row_page].start);\n    }\n    else\n    {\n      // Draw background in row...\n      new_render(row_page, RENDER_BOX, table.border_left, row_y,\n                 width, row_height + 2 * table.cellpadding, bgrgb,\n                 pages[row_page].start);\n    }\n  }\n\n  for (col = 0; col < table.num_cols; col += colspan + 1)\n  {\n    for (colspan = 0; (col + colspan) < table.num_cols; colspan ++)\n      if (cells[row][col] != cells[row][col + colspan])\n        break;\n      else if (table.row_spans[col + colspan] > 0)\n      {\n        DEBUG_printf((\"row = %d, col = %d, decrementing row_spans (%d) to %d...\\n\", row,\n                      col, table.row_spans[col + colspan],\n                      table.row_spans[col + colspan] - rowspan));\n        table.row_spans[col + colspan] -= rowspan;\n      }\n\n    colspan --;\n\n    width = table.col_rights[col + colspan] - table.col_lefts[col] +\n            2 * table.cellpadding;\n\n    if (cells[row][col] == NULL || cells[row][col]->child == NULL ||\n        table.row_spans[col] > 0)\n      continue;\n\n    DEBUG_printf((\"DRAWING BORDER+BACKGROUND: col=%d, row=%d, cell_page=%d, cell_y=%.1f\\n\"\n                  \"                           cell_endpage=%d, cell_endy=%.1f\\n\",\n                  col, row, table.cell_page[col], table.cell_y[col],\n                  table.cell_endpage[col], table.cell_endy[col]));\n\n    if ((bgcolor = htmlGetVariable(cells[row][col],\n                                   (uchar *)\"BGCOLOR\")) != NULL)\n    {\n      memcpy(bgrgb, background_color, sizeof(bgrgb));\n\n      get_color(bgcolor, bgrgb, 0);\n    }\n\n    table.border_left = table.col_lefts[col] - table.cellpadding;\n\n    if (table.cell_page[col] != table.cell_endpage[col])\n    {\n     /*\n      * Crossing a page boundary...\n      */\n\n      if (table.border > 0)\n      {\n       /*\n        * +---+---+---+\n        * |   |   |   |\n        */\n\n        // Top\n        new_render(table.cell_page[col], RENDER_BOX, table.border_left,\n                   table.cell_y[col] + table.cellpadding,\n                   width + table.border, table.border, table.border_rgb);\n        // Left\n        new_render(table.cell_page[col], RENDER_BOX, table.border_left, bottom,\n                   table.border, table.cell_y[col] - bottom + table.cellpadding + table.border, table.border_rgb);\n        // Right\n        new_render(table.cell_page[col], RENDER_BOX,\n                   table.border_left + width, bottom,\n                   table.border, table.cell_y[col] - bottom + table.cellpadding + table.border, table.border_rgb);\n      }\n\n      if (bgcolor != NULL)\n      {\n        table.cell_bg[col]->y      = bottom;\n        table.cell_bg[col]->height = table.cell_y[col] - bottom + table.cellpadding + table.border;\n      }\n\n      for (temp_page = table.cell_page[col] + 1; temp_page < table.cell_endpage[col]; temp_page ++)\n      {\n       /*\n        * |   |   |   |\n        * |   |   |   |\n        */\n\n        if (table.border > 0.0f)\n        {\n          // Left\n          new_render(temp_page, RENDER_BOX, table.border_left, bottom,\n                     table.border, top - bottom, table.border_rgb);\n          // Right\n          new_render(temp_page, RENDER_BOX,\n                     table.border_left + width, bottom,\n                     table.border, top - bottom, table.border_rgb);\n        }\n\n        if (bgcolor != NULL)\n          new_render(temp_page, RENDER_BOX, table.border_left, bottom,\n                     width + table.border, top - bottom, bgrgb,\n                     pages[temp_page].start);\n      }\n\n      if (table.border > 0.0f)\n      {\n       /*\n        * |   |   |   |\n        * +---+---+---+\n        */\n\n        // Left\n        new_render(table.cell_endpage[col], RENDER_BOX, table.border_left, row_y,\n                   table.border, top - row_y, table.border_rgb);\n        // Right\n        new_render(table.cell_endpage[col], RENDER_BOX,\n                   table.border_left + width, row_y,\n                   table.border, top - row_y, table.border_rgb);\n        // Bottom\n        new_render(table.cell_endpage[col], RENDER_BOX, table.border_left, row_y,\n                   width + table.border, table.border, table.border_rgb);\n      }\n\n      if (bgcolor != NULL)\n      {\n        check_pages(table.cell_endpage[col]);\n\n        new_render(table.cell_endpage[col], RENDER_BOX, table.border_left, row_y,\n                   width + table.border, top - row_y, bgrgb,\n                   pages[table.cell_endpage[col]].start);\n      }\n    }\n    else\n    {\n     /*\n      * +---+---+---+\n      * |   |   |   |\n      * +---+---+---+\n      */\n\n      if (table.border > 0.0f)\n      {\n        // Top\n        new_render(table.cell_page[col], RENDER_BOX, table.border_left,\n                   table.cell_y[col] + table.cellpadding,\n                   width + table.border, table.border, table.border_rgb);\n        // Left\n        new_render(table.cell_page[col], RENDER_BOX, table.border_left, row_y,\n                   table.border, table.cell_y[col] - row_y + table.cellpadding + table.border, table.border_rgb);\n        // Right\n        new_render(table.cell_page[col], RENDER_BOX,\n                   table.border_left + width, row_y,\n                   table.border, table.cell_y[col] - row_y + table.cellpadding + table.border, table.border_rgb);\n        // Bottom\n        new_render(table.cell_page[col], RENDER_BOX, table.border_left, row_y,\n                   width + table.border, table.border, table.border_rgb);\n      }\n\n      if (bgcolor != NULL)\n      {\n        table.cell_bg[col]->y      = row_y;\n        table.cell_bg[col]->height = table.cell_y[col] - row_y + table.cellpadding + table.border;\n      }\n    }\n  }\n\n  *page = row_page;\n  *y    = row_y;\n}\n\n\n/*\n * 'parse_table()' - Parse a table and produce rendering output.\n */\n\nstatic void\nparse_table(tree_t *t,\t\t\t// I - Tree to parse\n            float  left,\t\t// I - Left margin\n            float  right,\t\t// I - Printable width\n            float  bottom,\t\t// I - Bottom margin\n            float  top,\t\t\t// I - Printable top\n            float  *x,\t\t\t// IO - X position\n            float  *y,\t\t\t// IO - Y position\n            int    *page,\t\t// IO - Page #\n            int    needspace)\t\t// I - Need whitespace?\n{\n  int\t\tcol,\n\t\trow,\n                header_row = -1,\n\t\ttcol,\n\t\tcolspan,\n\t\trowspan,\n\t\talloc_rows,\n\t\tregular_cols;\n  hdtable_t     table;\n  float\t\tcol_width,\n\t\tcol_min,\n\t\tcol_pref,\n\t\tcol_height,\n\t\tcellspacing,\n\t\twidth,\n\t\tpref_width,\n\t\tspan_width,\n\t\tregular_width,\n\t\tactual_width,\n\t\ttable_width,\n\t\tmin_width,\n\t\ttemp_width,\n                header_height = 0.0,\n\t\ttable_y,\n                temp_bottom,\n\t\ttemp_top;\n  int\t\ttemp_page, table_page;\n  uchar\t\t*var,\n\t\t*height_var,\t\t// Row HEIGHT variable\n                *header_height_var = NULL;\n  tree_t\t*temprow,\n\t\t*tempcol,\n\t\t*tempnext,\n\t\t***cells,\n\t\t*caption;\t\t// Caption for bottom, if any\n  float\t\ttemp_height;\t\t// Temporary holder\n  uchar\t\t*bgcolor;\n  float\t\tbgrgb[3];\n  const char\t*htmldoc_debug;\t\t// HTMLDOC_DEBUG env var\n\n\n  DEBUG_puts(\"\\n\\nTABLE\");\n\n  DEBUG_printf((\"parse_table(t=%p, left=%.1f, right=%.1f, x=%.1f, y=%.1f, page=%d\\n\",\n                (void *)t, left, right, *x, *y, *page));\n\n  if (t->child == NULL)\n    return;   /* Empty table... */\n\n  memset(&table, 0, sizeof(table));\n\n /*\n  * Check debug mode...\n  */\n\n  if ((htmldoc_debug = getenv(\"HTMLDOC_DEBUG\")) != NULL &&\n      (strstr(htmldoc_debug, \"table\") || strstr(htmldoc_debug, \"all\")))\n    table.debug = 1;\n  else\n    table.debug = 0;\n\n /*\n  * Figure out the # of rows, columns, and the desired widths...\n  */\n\n  cells = NULL;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"WIDTH\")) != NULL)\n  {\n    if (var[strlen((char *)var) - 1] == '%')\n      table_width = (float)(atof((char *)var) * (right - left) / 100.0f);\n    else\n      table_width = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n    table_width = right - left;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"HEIGHT\")) != NULL)\n  {\n    if (var[strlen((char *)var) - 1] == '%')\n      table.height = (float)(atof((char *)var) * (top - bottom) / 100.0f);\n    else\n      table.height = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n    table.height = -1.0f;\n\n  DEBUG_printf((\"table_width = %.1f\\n\", table_width));\n\n  if ((var = htmlGetVariable(t, (uchar *)\"CELLPADDING\")) != NULL)\n    table.cellpadding = atoi((char *)var);\n  else\n    table.cellpadding = 1.0f;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"CELLSPACING\")) != NULL)\n    cellspacing = atoi((char *)var);\n  else\n    cellspacing = 0.0f;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"BORDER\")) != NULL)\n  {\n    if ((table.border = (float)atof((char *)var)) == 0.0 && var[0] != '0')\n      table.border = 1.0f;\n\n    table.cellpadding += table.border;\n  }\n  else\n    table.border = 0.0f;\n\n  if (table.debug && table.border == 0.0f)\n    table.border = 0.01f;\n\n  table.border_rgb[0] = t->red / 255.0f;\n  table.border_rgb[1] = t->green / 255.0f;\n  table.border_rgb[2] = t->blue / 255.0f;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"BORDERCOLOR\")) != NULL)\n    get_color(var, table.border_rgb, 0);\n\n  if (table.border == 0.0f && table.cellpadding > 0.0f)\n  {\n   /*\n    * Ah, the strange table formatting nightmare that is HTML.\n    * Netscape and MSIE assign an invisible border width of 1\n    * pixel if no border is specified...\n    */\n\n    table.cellpadding += 1.0f;\n  }\n\n  table.border_size = table.border - 1.0f;\n\n  cellspacing *= PagePrintWidth / _htmlBrowserWidth;\n  table.cellpadding *= PagePrintWidth / _htmlBrowserWidth;\n  table.border      *= PagePrintWidth / _htmlBrowserWidth;\n  table.border_size *= PagePrintWidth / _htmlBrowserWidth;\n\n  DEBUG_printf((\"border = %.1f, cellpadding = %.1f\\n\", table.border, table.cellpadding));\n\n  temp_bottom = bottom - table.cellpadding;\n  temp_top    = top + table.cellpadding;\n\n  for (temprow = t->child, table.num_cols = 0, table.num_rows = 0, alloc_rows = 0, caption = NULL;\n       temprow != NULL;\n       temprow = tempnext)\n  {\n    tempnext = temprow->next;\n\n    if (temprow->markup == MARKUP_CAPTION)\n    {\n      if ((var = htmlGetVariable(temprow, (uchar *)\"ALIGN\")) == NULL ||\n          strcasecmp((char *)var, \"bottom\"))\n      {\n       /*\n        * Show caption at top...\n\t*/\n\n        parse_paragraph(temprow, left, right, bottom, top, x, y, page, needspace);\n        needspace = 1;\n      }\n      else\n      {\n       /*\n        * Flag caption for bottom of table...\n\t*/\n\n        caption = temprow;\n      }\n    }\n    else if (temprow->markup == MARKUP_TR ||\n             ((temprow->markup == MARKUP_TBODY || temprow->markup == MARKUP_THEAD ||\n               temprow->markup == MARKUP_TFOOT) && temprow->child != NULL))\n    {\n      if (temprow->markup == MARKUP_THEAD)\n        header_row = table.num_rows;\n\n      // Descend into table body as needed...\n      if (temprow->markup == MARKUP_TBODY || temprow->markup == MARKUP_THEAD ||\n          temprow->markup == MARKUP_TFOOT)\n        temprow = temprow->child;\n\n      // Figure out the next row...\n      if ((tempnext = temprow->next) == NULL)\n        if (temprow->parent->markup == MARKUP_TBODY ||\n            temprow->parent->markup == MARKUP_THEAD ||\n            temprow->parent->markup == MARKUP_TFOOT)\n          tempnext = temprow->parent->next;\n\n      // Allocate memory for the table as needed...\n      if (table.num_rows >= alloc_rows)\n      {\n        alloc_rows += ALLOC_ROWS;\n\n        if (alloc_rows == ALLOC_ROWS)\n\t  cells = (tree_t ***)malloc(sizeof(tree_t **) * (size_t)alloc_rows);\n\telse\n\t  cells = (tree_t ***)realloc(cells, sizeof(tree_t **) * (size_t)alloc_rows);\n\n        if (cells == (tree_t ***)0)\n\t{\n\t  progress_error(HD_ERROR_OUT_OF_MEMORY,\n                         \"Unable to allocate memory for table!\");\n\t  return;\n\t}\n      }\n\n      if ((cells[table.num_rows] = (tree_t **)calloc(sizeof(tree_t *), MAX_COLUMNS)) == NULL)\n      {\n\tprogress_error(HD_ERROR_OUT_OF_MEMORY,\n                       \"Unable to allocate memory for table!\");\n        free(cells);\n\treturn;\n      }\n\n#ifdef DEBUG\n      printf(\"BEFORE row %d: num_cols = %d\\n\", table.num_rows, table.num_cols);\n\n      if (table.num_rows)\n        for (col = 0; col < table.num_cols; col ++)\n\t  printf(\"    col %d: row_spans[] = %d\\n\", col, table.row_spans[col]);\n#endif // DEBUG\n\n      // Figure out the starting column...\n      if (table.num_rows)\n      {\n\tfor (col = 0, rowspan = 9999; col < table.num_cols; col ++)\n\t  if (table.row_spans[col] < rowspan)\n\t    rowspan = table.row_spans[col];\n\n\tfor (col = 0; col < table.num_cols; col ++)\n\t  table.row_spans[col] -= rowspan;\n\n\tfor (col = 0; table.row_spans[col] && col < table.num_cols; col ++)\n          cells[table.num_rows][col] = cells[table.num_rows - 1][col];\n      }\n      else\n        col = 0;\n\n      for (tempcol = temprow->child;\n           tempcol != NULL && col < MAX_COLUMNS;\n           tempcol = tempcol->next)\n      {\n        if (tempcol->markup == MARKUP_TH && table.num_rows == 0)\n          header_row = table.num_rows;\n\n        if (tempcol->markup == MARKUP_TD || tempcol->markup == MARKUP_TH)\n        {\n\t  // Handle colspan and rowspan stuff...\n          if ((var = htmlGetVariable(tempcol, (uchar *)\"COLSPAN\")) != NULL)\n            colspan = atoi((char *)var);\n          else\n            colspan = 1;\n\n          if ((var = htmlGetVariable(tempcol, (uchar *)\"ROWSPAN\")) != NULL)\n\t  {\n            table.row_spans[col] = atoi((char *)var);\n\n\t    if (table.row_spans[col] == 1)\n\t      table.row_spans[col] = 0;\n\n\t    for (tcol = 1; tcol < colspan; tcol ++)\n              table.row_spans[col + tcol] = table.row_spans[col];\n          }\n\n          // Compute the cell size...\n          col_width = get_cell_size(tempcol, 0.0f, table_width, &col_min, &col_pref, &col_height);\n          if ((var = htmlGetVariable(tempcol, (uchar *)\"WIDTH\")) != NULL)\n\t  {\n\t    if (var[strlen((char *)var) - 1] == '%')\n\t    {\n              col_width -= 2.0 * table.cellpadding - cellspacing;\n\n\t      if (colspan <= 1)\n\t        table.col_percent[col] = 1;\n\t    }\n\t    else\n\t    {\n              col_width -= 2.0 * table.cellpadding;\n\t    }\n\t  }\n\t  else\n\t    col_width = 0.0f;\n\n          tempcol->height = col_height;\n\n\t  DEBUG_printf((\"%d,%d: colsp=%d, rowsp=%d, width=%.1f, minw=%.1f, prefw=%.1f, minh=%.1f\\n\", col, table.num_rows, colspan, table.row_spans[col], col_width, col_min, col_pref, col_height));\n\n          // Add widths to columns...\n          if (colspan > 1)\n          {\n\t    if (colspan > table.col_spans[col])\n\t      table.col_spans[col] = colspan;\n\n\t    if (col_width > table.col_swidths[col])\n\t      table.col_swidths[col] = col_width;\n\n\t    if (col_min > table.col_smins[col])\n\t      table.col_smins[col] = col_min;\n\n\t    temp_width = col_width / colspan;\n\t    for (int i = 0; i < colspan; i ++)\n\t    {\n\t      if (temp_width > table.col_widths[col + i])\n\t        table.col_widths[col + i] = temp_width;\n\t    }\n          }\n\t  else\n\t  {\n\t    if (col_width > 0.0f)\n\t      table.col_fixed[col] = 1;\n\n\t    if (col_width > table.col_widths[col])\n\t      table.col_widths[col] = col_width;\n\n\t    if (col_pref > table.col_prefs[col])\n\t      table.col_prefs[col] = col_pref;\n\n\t    if (col_min > table.col_mins[col])\n\t      table.col_mins[col] = col_min;\n          }\n\n\t  while (colspan > 0 && col < MAX_COLUMNS)\n\t  {\n            cells[table.num_rows][col] = tempcol;\n            col ++;\n            colspan --;\n          }\n\n          while (table.row_spans[col] && col < table.num_cols)\n\t  {\n            cells[table.num_rows][col] = cells[table.num_rows - 1][col];\n\t    col ++;\n\t  }\n        }\n      }\n\n      DEBUG_printf((\"header_row=%d\\n\", header_row));\n\n      if (col > table.num_cols)\n        table.num_cols = col;\n\n#ifdef DEBUG\n      printf(\"AFTER row %d: num_cols = %d\\n\", table.num_rows, table.num_cols);\n\n      for (col = 0; col < table.num_cols; col ++)\n        printf(\"    col %d: row_spans[] = %d\\n\", col, table.row_spans[col]);\n#endif // DEBUG\n\n      table.num_rows ++;\n\n      for (col = 0; col < table.num_cols; col ++)\n        if (table.row_spans[col])\n\t  table.row_spans[col] --;\n    }\n  }\n\n /*\n  * OK, some people apparently create HTML tables with no columns or\n  * rows...  If this happened, return immediately...\n  */\n\n  if (table.num_cols == 0)\n    return;\n\n /*\n  * Now figure out the width of the table...\n  */\n\n  if ((var = htmlGetVariable(t, (uchar *)\"WIDTH\")) != NULL)\n  {\n    if (var[strlen((char *)var) - 1] == '%')\n      width = (float)(atof((char *)var) * (right - left) / 100.0f);\n    else\n      width = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n  {\n    for (col = 0, width = 0.0; col < table.num_cols; col ++)\n      width += table.col_prefs[col];\n\n    width += (2 * table.cellpadding + cellspacing) * table.num_cols - cellspacing;\n\n    if (width > (right - left))\n      width = right - left;\n  }\n\n /*\n  * Compute the width of each column based on the printable width.\n  */\n\n  DEBUG_printf((\"\\nTABLE: %dx%d\\n\\n\", table.num_cols, table.num_rows));\n\n  actual_width  = (2 * table.cellpadding + cellspacing) * table.num_cols -\n                  cellspacing;\n  regular_width = (width - actual_width) / table.num_cols;\n\n  DEBUG_printf((\"    width = %.1f, actual_width = %.1f, regular_width = %.1f\\n\\n\",\n                width, actual_width, regular_width));\n  DEBUG_puts(\"    Col  Width   Min     Pref    Fixed?  Percent?\");\n  DEBUG_puts(\"    ---  ------  ------  ------  ------  --------\");\n\n#ifdef DEBUG\n  for (col = 0; col < table.num_cols; col ++)\n    printf(\"    %-3d  %-6.1f  %-6.1f  %-6.1f  %-6s  %s\\n\", col, table.col_widths[col], table.col_mins[col], table.col_prefs[col], table.col_fixed[col] ? \"YES\" : \"NO\", table.col_percent[col] ? \"YES\" : \"NO\");\n\n  puts(\"\");\n#endif /* DEBUG */\n\n /*\n  * The first pass just handles columns with a specified width...\n  */\n\n  DEBUG_puts(\"PASS 1: fixed width handling\\n\");\n\n  for (col = 0, regular_cols = 0; col < table.num_cols; col ++)\n    if (table.col_widths[col] > 0.0f)\n    {\n      if (table.col_mins[col] > table.col_widths[col])\n      {\n        DEBUG_printf((\"    updating column %d to width=%.1f\\n\", col, table.col_mins[col]));\n\n        table.col_widths[col] = table.col_mins[col];\n      }\n\n      actual_width += table.col_widths[col];\n    }\n    else\n    {\n      regular_cols ++;\n\n      actual_width += table.col_mins[col];\n    }\n\n  DEBUG_printf((\"    actual_width = %.1f, regular_cols = %d\\n\\n\", actual_width,regular_cols));\n\n /*\n  * Pass two uses the \"preferred\" width whenever possible, and the\n  * minimum otherwise...\n  */\n\n  DEBUG_puts(\"PASS 2: preferred width handling\\n\");\n\n  for (col = 0, pref_width = 0.0f; col < table.num_cols; col ++)\n    if (table.col_widths[col] == 0.0f)\n      pref_width += table.col_prefs[col] - table.col_mins[col];\n\n  DEBUG_printf((\"    pref_width = %.1f\\n\", pref_width));\n\n  if (pref_width > 0.0f)\n  {\n    if ((regular_width = (width - actual_width) / pref_width) < 0.0f)\n      regular_width = 0.0f;\n    else if (regular_width > 1.0f)\n      regular_width = 1.0f;\n\n    DEBUG_printf((\"    regular_width = %.1f\\n\", regular_width));\n\n    for (col = 0; col < table.num_cols; col ++)\n      if (table.col_widths[col] == 0.0f)\n      {\n\tpref_width = (table.col_prefs[col] - table.col_mins[col]) * regular_width;\n\n\tif ((actual_width + pref_width) > width)\n\t{\n          if (col == (table.num_cols - 1) && (width - actual_width) >= table.col_mins[col])\n\t    table.col_widths[col] = width - actual_width;\n\t  else\n\t    table.col_widths[col] = table.col_mins[col];\n\t}\n\telse\n          table.col_widths[col] = pref_width + table.col_mins[col];\n\n        DEBUG_printf((\"    col_widths[%d] = %.1f\\n\", col, table.col_widths[col]));\n\n\tactual_width += table.col_widths[col] - table.col_mins[col];\n      }\n  }\n  else\n  {\n   /*\n    * Assign min widths for all cells...\n    */\n\n    for (col = 0; col < table.num_cols; col ++)\n      if (table.col_widths[col] == 0.0f)\n        table.col_widths[col] = table.col_mins[col];\n  }\n\n  DEBUG_printf((\"    actual_width = %.1f\\n\\n\", actual_width));\n\n /*\n  * Pass three enforces any hard or minimum widths for COLSPAN'd\n  * columns...\n  */\n\n  DEBUG_puts(\"PASS 3: colspan handling\\n\\n\");\n\n  for (col = 0; col < table.num_cols; col ++)\n  {\n    DEBUG_printf((\"    col %d, colspan %d\\n\", col, table.col_spans[col]));\n\n    if (table.col_spans[col] > 1)\n    {\n      for (colspan = 0, span_width = 0.0f; colspan < table.col_spans[col]; colspan ++)\n        span_width += table.col_widths[col + colspan];\n\n      pref_width = 0.0f;\n\n      if (span_width < table.col_swidths[col])\n        pref_width = table.col_swidths[col];\n      if (span_width < table.col_smins[col] && pref_width < table.col_smins[col])\n        pref_width = table.col_smins[col];\n\n      for (colspan = 0; colspan < table.col_spans[col]; colspan ++)\n        if (table.col_fixed[col + colspan])\n\t{\n          span_width -= table.col_widths[col + colspan];\n\t  pref_width -= table.col_widths[col + colspan];\n\t}\n\n      DEBUG_printf((\"    col_swidths=%.1f, col_smins=%.1f, span_width=%.1f, pref_width=%.1f\\n\", table.col_swidths[col], table.col_smins[col], span_width, pref_width));\n\n      if (pref_width > 0.0f && pref_width > span_width)\n      {\n        if (span_width >= 1.0f)\n\t{\n          // Expand cells proportionately...\n\t  regular_width = pref_width / span_width;\n\n\t  for (colspan = 0; colspan < table.col_spans[col]; colspan ++)\n\t    if (!table.col_fixed[col + colspan])\n\t    {\n\t      actual_width -= table.col_widths[col + colspan];\n\t      table.col_widths[col + colspan] *= regular_width;\n\t      actual_width += table.col_widths[col + colspan];\n\n              DEBUG_printf((\"    col_widths[%d] = %.1f\\n\", col + colspan, table.col_widths[col + colspan]));\n\t    }\n        }\n\telse\n\t{\n\t  // Divide the space up equally between columns, since the\n\t  // colspan area is always by itself... (this hack brought\n\t  // to you by Yahoo! and their single cell tables with\n\t  // colspan=2 :)\n\n\t  regular_width = pref_width / table.col_spans[col];\n\n\t  for (colspan = 0; colspan < table.col_spans[col]; colspan ++)\n\t  {\n\t    actual_width += regular_width;\n\t    table.col_widths[col + colspan] += regular_width;\n\n            DEBUG_printf((\"    col_widths[%d] = %.1f\\n\", col, table.col_widths[col]));\n\t  }\n\t}\n      }\n    }\n  }\n\n  DEBUG_printf((\"    actual_width = %.1f\\n\\n\", actual_width));\n\n /*\n  * Pass four divides up the remaining space amongst the columns...\n  */\n\n  DEBUG_puts(\"PASS 4: divide remaining space, if any...\\n\");\n\n  if (width > actual_width)\n  {\n    for (col = 0, colspan = 0; col < table.num_cols; col ++)\n      if (!table.col_fixed[col] || table.col_percent[col])\n        colspan ++;\n\n    if (colspan > 0)\n    {\n      regular_width = (width - actual_width) / table.num_cols;\n\n      for (col = 0; col < table.num_cols; col ++)\n        if (!table.col_fixed[col])\n\t{\n\t  table.col_widths[col] += regular_width;\n\t  DEBUG_printf((\"    col_widths[%d] = %.1f\\n\", col, table.col_widths[col]));\n\t}\n    }\n  }\n  else\n    width = actual_width;\n\n  DEBUG_puts(\"\");\n\n /*\n  * The final pass is only run if the width > table_width...\n  */\n\n  DEBUG_puts(\"PASS 5: Squeeze table as needed...\");\n\n  if (width > table_width)\n  {\n   /*\n    * Squeeze the table to fit the requested width or the printable width\n    * as determined at the beginning...\n    */\n\n    for (col = 0, min_width = -cellspacing; col < table.num_cols; col ++)\n      min_width += table.col_mins[col] + 2 * table.cellpadding + cellspacing;\n\n    DEBUG_printf((\"    table_width = %.1f, width = %.1f, min_width = %.1f\\n\", table_width, width, min_width));\n\n    temp_width = table_width - min_width;\n    if (temp_width < 0.0f)\n      temp_width = 0.0f;\n\n    width -= min_width;\n    if (width < 1.0f)\n      width = 1.0f;\n\n    for (col = 0; col < table.num_cols; col ++)\n    {\n      table.col_widths[col] = table.col_mins[col] + temp_width * (table.col_widths[col] - table.col_mins[col]) / width;\n\n      DEBUG_printf((\"    col_widths[%d] = %.1f\\n\", col, table.col_widths[col]));\n    }\n\n    for (col = 0, width = -cellspacing; col < table.num_cols; col ++)\n      width += table.col_widths[col] + 2 * table.cellpadding + cellspacing;\n\n    DEBUG_printf((\"    new width = %.1f, max width = %.1f\\n\", width, right - left));\n  }\n\n  if ((width - right + left) > 0.001f && OverflowErrors)\n    progress_error(HD_ERROR_CONTENT_TOO_LARGE, \"Table on page %d too wide - truncation or overlapping may occur!\", *page + 1);\n\n  DEBUG_puts(\"\");\n\n  DEBUG_printf((\"Final table width = %.1f, alignment = %d\\n\", width, t->halignment));\n\n  switch (t->halignment)\n  {\n    case ALIGN_LEFT :\n        *x = left + table.cellpadding;\n        break;\n    case ALIGN_CENTER :\n        *x = left + 0.5f * (right - left - width) + table.cellpadding;\n        break;\n    case ALIGN_RIGHT :\n        *x = right - width + table.cellpadding;\n        break;\n  }\n\n  for (col = 0; col < table.num_cols; col ++)\n  {\n    table.col_lefts[col]  = *x;\n    table.col_rights[col] = *x + table.col_widths[col];\n    *x = table.col_rights[col] + 2 * table.cellpadding + cellspacing;\n\n    DEBUG_printf((\"left[%d] = %.1f, right[%d] = %.1f\\n\", col, table.col_lefts[col], col, table.col_rights[col]));\n  }\n\n /*\n  * Now render the whole table...\n  */\n\n  if (*y < top && needspace)\n    *y -= _htmlSpacings[SIZE_P];\n\n  if (table.debug)\n  {\n    check_pages(*page);\n\n    render_t *r;\n    char table_text[255];\n\n    snprintf(table_text, sizeof(table_text), \"t=%p\", (void *)t);\n    r = new_render(*page, RENDER_TEXT, left, *y,\n                   get_width((uchar *)table_text, TYPE_COURIER, STYLE_NORMAL, 3),\n\t\t   _htmlSizes[3], table_text);\n\n    r->data.text.typeface = TYPE_COURIER;\n    r->data.text.style    = STYLE_NORMAL;\n    r->data.text.size     = (float)_htmlSizes[3];\n  }\n\n  table_page = *page;\n  table_y    = *y;\n\n  for (row = 0; row < table.num_rows; row ++)\n  {\n    height_var = NULL;\n\n    if (cells[row][0] != NULL)\n    {\n     /*\n      * Do page comments...\n      */\n\n      if (cells[row][0]->parent->prev != NULL &&\n          cells[row][0]->parent->prev->markup == MARKUP_COMMENT)\n        parse_comment(cells[row][0]->parent->prev, &left, &right, &temp_bottom, &temp_top, x, y, page, NULL, 0);\n\n     /*\n      * Get height...\n      */\n\n      if ((height_var = htmlGetVariable(cells[row][0]->parent, (uchar *)\"HEIGHT\")) == NULL)\n\tfor (col = 0; col < table.num_cols; col ++)\n\t  if (htmlGetVariable(cells[row][col], (uchar *)\"ROWSPAN\") == NULL)\n\t    if ((height_var = htmlGetVariable(cells[row][col], (uchar *)\"HEIGHT\")) != NULL)\n\t      break;\n    }\n\n    if (height_var != NULL && row == header_row)\n      header_height_var = height_var;\n\n    if (cells[row][0] != NULL && height_var != NULL)\n    {\n      // Row height specified; make sure it'll fit...\n      if (height_var[strlen((char *)height_var) - 1] == '%')\n\ttemp_height = (float)(atof((char *)height_var) * 0.01f * (PagePrintLength - 2 * table.cellpadding));\n      else\n        temp_height = (float)(atof((char *)height_var) * PagePrintWidth / _htmlBrowserWidth);\n\n      if (table.height > 0.0f && temp_height > table.height)\n        temp_height = table.height;\n\n      temp_height -= 2 * table.cellpadding;\n    }\n    else\n    {\n      // Use min height computed from get_cell_size()...\n      for (col = 0, temp_height = (float)_htmlSpacings[SIZE_P];\n           col < table.num_cols;\n\t   col ++)\n        if (cells[row][col] != NULL &&\n\t    cells[row][col]->height > temp_height &&\n\t    !htmlGetVariable(cells[row][col], (uchar *)\"ROWSPAN\"))\n\t  temp_height = cells[row][col]->height;\n\n      if (table.height > 0.0)\n      {\n\t// Table height specified; make sure it'll fit...\n\tif (temp_height > table.height)\n          temp_height = table.height;\n\ttemp_height -= 2 * table.cellpadding;\n      }\n      else if (temp_height > (PageLength / 8.0) && height_var == NULL)\n\ttemp_height = PageLength / 8.0;\n    }\n\n    DEBUG_printf((\"BEFORE row = %d, temp_height = %.1f, *y = %.1f, *page = %d\\n\",\n                  row, temp_height, *y, *page));\n\n    if (*y < (bottom + 2 * table.cellpadding + temp_height) &&\n        temp_height <= (top - bottom - 2 * table.cellpadding))\n    {\n      DEBUG_puts(\"NEW PAGE\");\n\n      *y = top - header_height;\n      (*page) ++;\n\n      if (Verbosity)\n        progress_show(\"Formatting page %d\", *page);\n\n      if (row > 0 && header_row >= 0)\n      {\n        // Render header row...\n        render_table_row(table, cells, header_row, header_height_var, left, right, bottom, top, x, y, page);\n      }\n    }\n\n    float start_y = *y;\n    temp_page = *page;\n    render_table_row(table, cells, row, height_var, left, right, bottom, top, x, y, page);\n    if (header_row >= 0 && row == header_row)\n    {\n      header_height = *y - start_y;\n      top += header_height;\n    }\n    else if (temp_page != *page && header_row >= 0)\n    {\n      // Render header row on new page(s)...\n      do\n      {\n        float temp_y = top - header_height;\n\n        temp_page ++;\n        render_table_row(table, cells, header_row, header_height_var, left, right, bottom, top, x, &temp_y, &temp_page);\n      }\n      while (temp_page < *page);\n    }\n\n    if (row < (table.num_rows - 1))\n      (*y) -= cellspacing;\n\n    DEBUG_printf((\"END row = %d, *y = %.1f, *page = %d\\n\", row, *y, *page));\n  }\n\n  top -= header_height;\n\n /*\n  * Handle table background color...\n  */\n\n  if ((bgcolor = htmlGetVariable(t, (uchar *)\"BGCOLOR\")) != NULL)\n  {\n    memcpy(bgrgb, background_color, sizeof(bgrgb));\n\n    get_color(bgcolor, bgrgb, 0);\n\n    table.border_left = table.col_lefts[0] - table.cellpadding;\n    width       = table.col_rights[table.num_cols - 1] - table.col_lefts[0] + 2 * table.cellpadding;\n\n    if (table_page != *page)\n    {\n      // Draw background on multiple pages...\n\n      // Bottom of first page...\n      new_render(table_page, RENDER_BOX, table.border_left, bottom,\n\t         width, table_y - bottom, bgrgb,\n\t\t pages[table_page].start);\n\n      // Intervening pages...\n      for (temp_page = table_page + 1; temp_page < *page; temp_page ++)\n      {\n        new_render(temp_page, RENDER_BOX, table.border_left, bottom,\n                   width, top - bottom, bgrgb, pages[temp_page].start);\n      }\n\n      // Top of last page...\n      check_pages(*page);\n\n      new_render(*page, RENDER_BOX, table.border_left, *y,\n\t         width, top - *y, bgrgb, pages[*page].start);\n    }\n    else\n    {\n      // Draw background in row...\n      new_render(table_page, RENDER_BOX, table.border_left, *y,\n\t         width, table_y - *y, bgrgb, pages[table_page].start);\n    }\n  }\n\n  *x = left;\n\n  if (caption)\n  {\n   /*\n    * Show caption at bottom...\n    */\n\n    parse_paragraph(caption, left, right, bottom, top, x, y, page, needspace);\n    needspace = 1;\n  }\n\n /*\n  * Free memory for the table...\n  */\n\n  if (table.num_rows > 0)\n  {\n    for (row = 0; row < table.num_rows; row ++)\n      free(cells[row]);\n\n    free(cells);\n  }\n}\n#ifdef TABLE_DEBUG\n#  undef DEBUG\n#  undef DEBUG_puts\n#  define DEBUG_puts(x)\n#  undef DEBUG_printf\n#  define DEBUG_printf(x)\n#endif /* TABLE_DEBUG */\n\n\n/*\n * 'parse_list()' - Parse a list entry and produce rendering output.\n */\n\nstatic void\nparse_list(tree_t *t,\t\t/* I - Tree to parse */\n           float  *left,\t/* I - Left margin */\n           float  *right,\t/* I - Printable width */\n           float  *bottom,\t/* I - Bottom margin */\n           float  *top,\t\t/* I - Printable top */\n           float  *x,\t\t/* IO - X position */\n           float  *y,\t\t/* IO - Y position */\n           int    *page,\t/* IO - Page # */\n           int    needspace)\t/* I - Need whitespace? */\n{\n  uchar\t\tnumber[255];\t/* List number (for numbered types) */\n  uchar\t\t*value;\t\t/* VALUE= variable */\n  int\t\ttypeface;\t/* Typeface of list number */\n  float\t\twidth;\t\t/* Width of list number */\n  render_t\t*r;\t\t/* Render primitive */\n  int\t\toldpage;\t/* Old page value */\n  float\t\toldy;\t\t/* Old Y value */\n  float\t\ttempx;\t\t/* Temporary X value */\n\n\n  DEBUG_printf((\"parse_list(t=%p, left=%.1f, right=%.1f, x=%.1f, y=%.1f, page=%d\\n\",\n                (void *)t, *left, *right, *x, *y, *page));\n\n  if (needspace && *y < *top)\n  {\n    *y        -= _htmlSpacings[t->size];\n    needspace = 0;\n  }\n\n  check_pages(*page);\n\n  oldy    = *y;\n  oldpage = *page;\n  r       = pages[*page].end;\n  tempx   = *x;\n\n  if (t->indent == 0)\n  {\n    // Adjust left margin when no UL/OL/DL is being used...\n    *left += _htmlSizes[t->size];\n    tempx += _htmlSizes[t->size];\n  }\n\n  parse_doc(t->child, left, right, bottom, top, &tempx, y, page, NULL,\n            &needspace);\n\n  // Handle when paragraph wrapped to new page...\n  if (*page != oldpage)\n  {\n    // First see if anything was added to the old page...\n    if ((r != NULL && r->next == NULL) || pages[oldpage].end == NULL)\n    {\n      // No, put the symbol on the next page...\n      oldpage = *page;\n      oldy    = *top;\n    }\n  }\n\n  if ((value = htmlGetVariable(t, (uchar *)\"VALUE\")) != NULL)\n  {\n    if (isdigit(value[0]))\n      list_values[t->indent] = atoi((char *)value);\n    else if (isupper(value[0]))\n      list_values[t->indent] = value[0] - 'A' + 1;\n    else\n      list_values[t->indent] = value[0] - 'a' + 1;\n  }\n\n  switch (list_types[t->indent])\n  {\n    case 'a' :\n    case 'A' :\n    case '1' :\n    case 'i' :\n    case 'I' :\n        strlcpy((char *)number, format_number(list_values[t->indent], (char)list_types[t->indent]), sizeof(number));\n        strlcat((char *)number, \". \", sizeof(number));\n        typeface = t->typeface;\n        break;\n\n    default :\n        snprintf((char *)number, sizeof(number), \"%c \", list_types[t->indent]);\n        typeface = TYPE_SYMBOL;\n        break;\n  }\n\n  width = get_width(number, typeface, t->style, t->size);\n\n  r = new_render(oldpage, RENDER_TEXT, *left - width, oldy - _htmlSizes[t->size],\n                 width, _htmlSpacings[t->size], number);\n  r->data.text.typeface = typeface;\n  r->data.text.style    = t->style;\n  r->data.text.size     = (float)_htmlSizes[t->size];\n  r->data.text.rgb[0]   = t->red / 255.0f;\n  r->data.text.rgb[1]   = t->green / 255.0f;\n  r->data.text.rgb[2]   = t->blue / 255.0f;\n\n  list_values[t->indent] ++;\n\n  if (t->indent == 0)\n  {\n    // Adjust left margin when no UL/OL/DL is being used...\n    *left -= _htmlSizes[t->size];\n  }\n}\n\n\n/*\n * 'init_list()' - Initialize the list type and value as necessary.\n */\n\nstatic void\ninit_list(tree_t *t)\t\t/* I - List entry */\n{\n  uchar\t\t*type,\t\t/* TYPE= variable */\n\t\t*value;\t\t/* VALUE= variable */\n  static uchar\t*symbols = (uchar *)\"\\327\\267\\250\\340\";\n\n\n  if ((type = htmlGetVariable(t, (uchar *)\"TYPE\")) != NULL)\n  {\n    if (strlen((char *)type) == 1)\n      list_types[t->indent] = type[0];\n    else if (strcasecmp((char *)type, \"disc\") == 0 ||\n             strcasecmp((char *)type, \"circle\") == 0)\n      list_types[t->indent] = symbols[1];\n    else\n      list_types[t->indent] = symbols[2];\n  }\n  else if (t->markup == MARKUP_UL)\n    list_types[t->indent] = symbols[t->indent & 3];\n  else if (t->markup == MARKUP_OL)\n    list_types[t->indent] = '1';\n\n  if ((value = htmlGetVariable(t, (uchar *)\"VALUE\")) == NULL)\n    value = htmlGetVariable(t, (uchar *)\"START\");\n\n  if (value != NULL)\n  {\n    if (isdigit(value[0]))\n      list_values[t->indent] = atoi((char *)value);\n    else if (isupper(value[0]))\n      list_values[t->indent] = value[0] - 'A' + 1;\n    else\n      list_values[t->indent] = value[0] - 'a' + 1;\n  }\n  else if (t->markup == MARKUP_OL)\n    list_values[t->indent] = 1;\n}\n\n\n/*\n * 'parse_comment()' - Parse a comment for HTMLDOC comments.\n */\n\n#ifdef COMMENT_DEBUG\n#  undef DEBUG_puts\n#  define DEBUG_puts(x) puts(x)\n#  define DEBUG\n#  undef DEBUG_printf\n#  define DEBUG_printf(x) printf x\n#endif /* COMMENT_DEBUG */\n\nstatic void\nparse_comment(tree_t *t,\t/* I - Tree to parse */\n              float  *left,\t/* I - Left margin */\n              float  *right,\t/* I - Printable width */\n              float  *bottom,\t/* I - Bottom margin */\n              float  *top,\t/* I - Printable top */\n              float  *x,\t/* IO - X position */\n              float  *y,\t/* IO - Y position */\n              int    *page,\t/* IO - Page # */\n\t      tree_t *para,\t/* I - Current paragraph */\n\t      int    needspace)\t/* I - Need whitespace? */\n{\n  int\t\ti;\t\t/* Looping var */\n  const char\t*comment;\t/* Comment text */\n  char\t\t*ptr,\t\t/* Pointer into value string */\n\t\tbuffer[1024];\t/* Buffer for strings */\n  int\t\tpos,\t\t/* Position (left, center, right) */\n\t\ttof;\t\t/* Top of form */\n\n\n  DEBUG_printf((\"parse_comment(t=%p, left=%.1f, right=%.1f, bottom=%.1f, \"\n                \"top=%.1f, x=%.1f, y=%.1f, page=%d, para=%p, needspace=%d\\n\",\n                (void *)t, *left, *right, *bottom, *top, *x, *y, *page, (void *)para,\n\t\tneedspace));\n\n  if (t->data == NULL)\n    return;\n\n  if (para != NULL && para->child != NULL && para->child->next == NULL &&\n      para->child->child == NULL && para->child->markup == MARKUP_NONE &&\n      strcmp((const char *)para->child->data, \" \") == 0)\n  {\n    // Remove paragraph consisting solely of whitespace...\n    htmlDeleteTree(para->child);\n    para->child = para->last_child = NULL;\n  }\n\n  // Mark if we are at the top of form...\n  tof = (*y >= *top);\n\n  DEBUG_printf((\"BEFORE tof=%d, *y=%.1f, *top=%.1f, *page=%d, t->data=\\\"%s\\\"\\n\",\n        \ttof, *y, *top, *page, t->data));\n  DEBUG_printf((\" PagePrintWidth = %d\\n\", PagePrintWidth));\n  DEBUG_printf((\"PagePrintLength = %d\\n\", PagePrintLength));\n  DEBUG_printf((\"      PageWidth = %d\\n\", PageWidth));\n  DEBUG_printf((\"     PageLength = %d\\n\", PageLength));\n  DEBUG_printf((\"       PageLeft = %d\\n\", PageLeft));\n  DEBUG_printf((\"     PageBottom = %d\\n\", PageBottom));\n  DEBUG_printf((\"      PageRight = %d\\n\", PageRight));\n  DEBUG_printf((\"        PageTop = %d\\n\", PageTop));\n  DEBUG_printf((\"      Landscape = %d\\n\", Landscape));\n\n\n  for (comment = (const char *)t->data; *comment;)\n  {\n    // Skip leading whitespace...\n    while (isspace(*comment))\n      comment ++;\n\n    if (!*comment)\n      break;\n\n    if (strncasecmp(comment, \"PAGE BREAK\", 10) == 0 &&\n\t(!comment[10] || isspace(comment[10])))\n    {\n     /*\n      * <!-- PAGE BREAK --> generates a page break...\n      */\n\n      comment += 10;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n      }\n\n      (*page) ++;\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n      *x = *left;\n      *y = *top;\n\n      tof = 1;\n    }\n    else if (strncasecmp(comment, \"NEW PAGE\", 8) == 0 &&\n\t     (!comment[8] || isspace(comment[8])))\n    {\n     /*\n      * <!-- NEW PAGE --> generates a page break...\n      */\n\n      comment += 8;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n      }\n\n      (*page) ++;\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n      *x = *left;\n      *y = *top;\n\n      tof = 1;\n    }\n    else if (strncasecmp(comment, \"NEW SHEET\", 9) == 0 &&\n\t     (!comment[9] || isspace(comment[9])))\n    {\n     /*\n      * <!-- NEW SHEET --> generate a page break to a new sheet...\n      */\n\n      comment += 9;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n      }\n\n      if (NumberUp == 1)\n      {\n        // NEW SHEET breaks to the next sheet of paper...\n        (*page) ++;\n\n\tif (PageDuplex && ((*page) & 1))\n\t  (*page) ++;\n      }\n      else\n      {\n        // NEW SHEET breaks to the next side/sheet...\n        (*page) ++;\n\n\tfor (i = *page - 1; i >= 0; i --)\n\t  if (pages[i].nup != NumberUp)\n\t    break;\n\n        i ++;\n\tfor (i = *page - i; (i % NumberUp) != 0; i ++, (*page) ++);\n      }\n\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n\n      *x = *left;\n      *y = *top;\n\n      tof = 1;\n    }\n    else if (strncasecmp(comment, \"HALF PAGE\", 9) == 0 &&\n             (!comment[9] || isspace(comment[9])))\n    {\n     /*\n      * <!-- HALF PAGE --> Go to the next half page.  If in the\n      * top half of a page, go to the bottom half.  If in the\n      * bottom half, go to the next page.\n      */\n      float halfway;\n\n\n      comment += 9;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n      }\n\n      halfway = 0.5f * (*top + *bottom);\n\n      if (*y <= halfway)\n      {\n\t(*page) ++;\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*x = *left;\n\t*y = *top;\n\n        tof = 1;\n      }\n      else\n      {\n\t*x = *left;\n\t*y = halfway;\n\n        tof = 0;\n      }\n    }\n    else if (strncasecmp(comment, \"NEED \", 5) == 0)\n    {\n     /*\n      * <!-- NEED amount --> generate a page break if there isn't\n      * enough remaining space...\n      */\n\n      comment += 5;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if ((*y - get_measurement(comment, (float)_htmlSpacings[SIZE_P])) < *bottom)\n      {\n\t(*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*y = *top;\n        tof = 1;\n      }\n\n      *x = *left;\n\n      // Skip amount...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA COLOR \", 12) == 0)\n    {\n      // Media color for page...\n      comment += 12;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (PageDuplex && ((*page) & 1))\n\t  (*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*y = *top;\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      // Get color...\n      if (*comment == '\\\"')\n      {\n\tfor (ptr = pages[*page].media_color, comment ++;\n             *comment && *comment != '\\\"';\n\t     comment ++)\n          if (ptr < (pages[*page].media_color +\n\t             sizeof(pages[*page].media_color) - 1))\n\t    *ptr++ = *comment;\n\n        if (*comment == '\\\"')\n\t  comment ++;\n      }\n      else\n      {\n\tfor (ptr = pages[*page].media_color;\n             *comment && !isspace(*comment);\n\t     comment ++)\n          if (ptr < (pages[*page].media_color +\n\t             sizeof(pages[*page].media_color) - 1))\n\t    *ptr++ = *comment;\n      }\n\n      *ptr = '\\0';\n    }\n    else if (strncasecmp(comment, \"MEDIA POSITION \", 15) == 0)\n    {\n      // Media position for page...\n      comment += 15;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (PageDuplex && ((*page) & 1))\n\t  (*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*y = *top;\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      pages[*page].media_position = atoi(comment);\n\n      // Skip position...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA TYPE \", 11) == 0)\n    {\n      // Media type for page...\n      comment += 11;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (PageDuplex && ((*page) & 1))\n\t  (*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*y = *top;\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      // Get type...\n      if (*comment == '\\\"')\n      {\n\tfor (ptr = pages[*page].media_type, comment ++;\n             *comment && *comment != '\\\"';\n\t     comment ++)\n          if (ptr < (pages[*page].media_type +\n\t             sizeof(pages[*page].media_type) - 1))\n\t    *ptr++ = *comment;\n\n        if (*comment == '\\\"')\n\t  comment ++;\n      }\n      else\n      {\n\tfor (ptr = pages[*page].media_type;\n             *comment && !isspace(*comment);\n\t     comment ++)\n          if (ptr < (pages[*page].media_type +\n\t             sizeof(pages[*page].media_type) - 1))\n\t    *ptr++ = *comment;\n      }\n\n      *ptr = '\\0';\n    }\n    else if (strncasecmp(comment, \"MEDIA SIZE \", 11) == 0)\n    {\n      // Media size...\n      comment += 11;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n        tof = 1;\n      }\n\n      if (PageDuplex && ((*page) & 1))\n\t(*page) ++;\n\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n\n      check_pages(*page);\n\n      *right = PagePrintWidth - *right;\n      *top   = PagePrintLength - *top;\n\n      set_page_size(comment);\n\n      if (Landscape)\n      {\n\tPagePrintWidth  = PageLength - PageLeft - PageRight;\n\tPagePrintLength = PageWidth - PageTop - PageBottom;\n      }\n      else\n      {\n\tPagePrintWidth  = PageWidth - PageLeft - PageRight;\n\tPagePrintLength = PageLength - PageTop - PageBottom;\n      }\n\n      *right = PagePrintWidth - *right;\n      *top   = PagePrintLength - *top;\n\n      *x = *left;\n      *y = *top;\n\n      pages[*page].width  = PageWidth;\n      pages[*page].length = PageLength;\n\n      // Skip width...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA LEFT \", 11) == 0)\n    {\n      // Left margin...\n      comment += 11;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*y = *top;\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      *right   = PagePrintWidth - *right;\n      PageLeft = pages[*page].left = get_measurement(comment);\n\n      if (Landscape)\n\tPagePrintWidth = PageLength - PageRight - PageLeft;\n      else\n\tPagePrintWidth = PageWidth - PageRight - PageLeft;\n\n      *right = PagePrintWidth - *right;\n\n      // Skip left...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA RIGHT \", 12) == 0)\n    {\n      // Right margin...\n      comment += 12;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*y = *top;\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      *right    = PagePrintWidth - *right;\n      PageRight = pages[*page].right = get_measurement(comment);\n\n      if (Landscape)\n\tPagePrintWidth = PageLength - PageRight - PageLeft;\n      else\n\tPagePrintWidth = PageWidth - PageRight - PageLeft;\n\n      *right = PagePrintWidth - *right;\n\n      // Skip right...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA BOTTOM \", 13) == 0)\n    {\n      // Bottom margin...\n      comment += 13;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      *top       = PagePrintLength - *top;\n      PageBottom = pages[*page].bottom = get_measurement(comment);\n\n      if (Landscape)\n        PagePrintLength = PageWidth - PageTop - PageBottom;\n      else\n        PagePrintLength = PageLength - PageTop - PageBottom;\n\n      *top = PagePrintLength - *top;\n      *y   = *top;\n\n      // Skip bottom...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA TOP \", 10) == 0)\n    {\n      // Top margin...\n      comment += 10;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      *top    = PagePrintLength - *top;\n      PageTop = pages[*page].top = get_measurement(comment);\n\n      if (Landscape)\n        PagePrintLength = PageWidth - PageTop - PageBottom;\n      else\n        PagePrintLength = PageLength - PageTop - PageBottom;\n\n      *top = PagePrintLength - *top;\n      *y   = *top;\n\n      // Skip top...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA LANDSCAPE \", 16) == 0)\n    {\n      // Landscape on/off...\n      comment += 16;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n        tof = 1;\n      }\n\n      if (PageDuplex && ((*page) & 1))\n\t(*page) ++;\n\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n\n      *x = *left;\n\n      check_pages(*page);\n\n      if (strncasecmp(comment, \"OFF\", 3) == 0 || tolower(comment[0]) == 'n')\n      {\n        if (Landscape)\n\t{\n\t  *right         = PageLength - PageRight - *right;\n\t  PagePrintWidth = PageWidth - PageRight - PageLeft;\n\t  *right         = PageWidth - PageRight - *right;\n\n\t  *top            = PageWidth - PageTop - *top;\n\t  PagePrintLength = PageLength - PageTop - PageBottom;\n\t  *top            = PageLength - PageTop - *top;\n        }\n\n        Landscape = pages[*page].landscape = 0;\n      }\n      else if (strncasecmp(comment, \"ON\", 2) == 0 || tolower(comment[0]) == 'y')\n      {\n        if (!Landscape)\n\t{\n\t  *top            = PageLength - PageTop - *top;\n\t  PagePrintLength = PageWidth - PageTop - PageBottom;\n\t  *top            = PageWidth - PageTop - *top;\n\n\t  *right         = PageWidth - PageRight - *right;\n\t  PagePrintWidth = PageLength - PageRight - PageLeft;\n\t  *right         = PageLength - PageRight - *right;\n        }\n\n        Landscape = pages[*page].landscape = 1;\n      }\n\n      *y = *top;\n\n      // Skip landscape...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA DUPLEX \", 13) == 0)\n    {\n      // Duplex printing on/off...\n      comment += 13;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\t*y = *top;\n        tof = 1;\n      }\n\n      if (PageDuplex && ((*page) & 1))\n\t(*page) ++;\n\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n\n      *x = *left;\n\n      check_pages(*page);\n\n      if (strncasecmp(comment, \"OFF\", 3) == 0 || tolower(comment[0]) == 'n')\n        PageDuplex = pages[*page].duplex = 0;\n      else if (strncasecmp(comment, \"ON\", 2) == 0 || tolower(comment[0]) == 'y')\n      {\n\tif ((*page) & 1)\n\t{\n\t  (*page) ++;\n\n          check_pages(*page);\n\n\t  if (Verbosity)\n\t    progress_show(\"Formatting page %d\", *page);\n\t}\n\n        PageDuplex = pages[*page].duplex = 1;\n      }\n\n      // Skip duplex...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"HEADER \", 7) == 0)\n    {\n      // Header string...\n      comment += 7;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (strncasecmp(comment, \"LEFT\", 4) == 0 && isspace(comment[4]))\n      {\n        pos     = 0;\n\tcomment += 4;\n      }\n      else if (strncasecmp(comment, \"CENTER\", 6) == 0 && isspace(comment[6]))\n      {\n        pos     = 1;\n\tcomment += 6;\n      }\n      else if (strncasecmp(comment, \"RIGHT\", 5) == 0 && isspace(comment[5]))\n      {\n        pos     = 2;\n\tcomment += 5;\n      }\n      else\n      {\n        progress_error(HD_ERROR_BAD_COMMENT,\n                       \"Bad HEADER position: \\\"%s\\\"\", comment);\n\treturn;\n      }\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (*comment != '\\\"')\n      {\n        progress_error(HD_ERROR_BAD_COMMENT,\n                       \"Bad HEADER string: \\\"%s\\\"\", comment);\n\treturn;\n      }\n\n      for (ptr = buffer, comment ++; *comment && *comment != '\\\"'; comment ++)\n      {\n        if (*comment == '\\\\')\n\t  comment ++;\n\n\tif (ptr < (buffer + sizeof(buffer) - 1))\n\t  *ptr++ = *comment;\n      }\n\n      if (*comment == '\\\"')\n        comment ++;\n\n      *ptr = '\\0';\n\n      if (ptr > buffer)\n        Header[pos] = strdup(buffer);\n      else\n        Header[pos] = NULL;\n\n      if (tof)\n      {\n        DEBUG_printf((\"Setting header %d for page %d to \\\"%s\\\"...\\n\",\n\t              pos, *page, Header[pos] ? Header[pos] : \"(null)\"));\n\n\tcheck_pages(*page);\n\n\tpages[*page].header[pos] = (uchar *)Header[pos];\n      }\n\n      // Adjust top margin as needed...\n      float adjust, image_adjust, temp_adjust;\n\n      if (maxhfheight > HeadFootSize)\n\timage_adjust = (float)(maxhfheight + HeadFootSize);\n      else\n\timage_adjust = (float)(2 * HeadFootSize);\n\n      for (adjust = 0.0, pos = 0; pos < 3; pos ++)\n      {\n\tif (Header[pos] &&\n\t    (strstr(Header[pos], \"$IMAGE\") != NULL ||\n\t     strstr(Header[pos], \"$HFIMAGE\") != NULL))\n\t  temp_adjust = image_adjust;\n\telse if (Header1[pos] &&\n\t\t (strstr(Header1[pos], \"$IMAGE\") != NULL ||\n\t\t  strstr(Header1[pos], \"$HFIMAGE\") != NULL))\n\t  temp_adjust = image_adjust;\n\telse if (Header[pos] || Header1[pos])\n\t  temp_adjust = (float)(2 * HeadFootSize);\n\telse\n\t  temp_adjust = 0.0;\n\n\tif (temp_adjust > adjust)\n\t  adjust = temp_adjust;\n      }\n\n      *top = PagePrintLength - adjust;\n\n      if (tof)\n        *y = *top;\n    }\n    else if (strncasecmp(comment, \"HEADER1 \", 8) == 0)\n    {\n      // First page header string...\n      comment += 8;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (strncasecmp(comment, \"LEFT\", 4) == 0 && isspace(comment[4]))\n      {\n        pos     = 0;\n\tcomment += 4;\n      }\n      else if (strncasecmp(comment, \"CENTER\", 6) == 0 && isspace(comment[6]))\n      {\n        pos     = 1;\n\tcomment += 6;\n      }\n      else if (strncasecmp(comment, \"RIGHT\", 5) == 0 && isspace(comment[5]))\n      {\n        pos     = 2;\n\tcomment += 5;\n      }\n      else\n      {\n        progress_error(HD_ERROR_BAD_COMMENT,\n                       \"Bad HEADER1 position: \\\"%s\\\"\", comment);\n\treturn;\n      }\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (*comment != '\\\"')\n      {\n        progress_error(HD_ERROR_BAD_COMMENT,\n                       \"Bad HEADER1 string: \\\"%s\\\"\", comment);\n\treturn;\n      }\n\n      for (ptr = buffer, comment ++; *comment && *comment != '\\\"'; comment ++)\n      {\n        if (*comment == '\\\\')\n\t  comment ++;\n\n\tif (ptr < (buffer + sizeof(buffer) - 1))\n\t  *ptr++ = *comment;\n      }\n\n      if (*comment == '\\\"')\n        comment ++;\n\n      *ptr = '\\0';\n\n      if (ptr > buffer)\n        Header1[pos] = strdup(buffer);\n      else\n        Header1[pos] = NULL;\n\n      // Adjust top margin as needed...\n      float adjust, image_adjust, temp_adjust;\n\n      if (maxhfheight > HeadFootSize)\n\timage_adjust = (float)(maxhfheight + HeadFootSize);\n      else\n\timage_adjust = (float)(2 * HeadFootSize);\n\n      for (adjust = 0.0, pos = 0; pos < 3; pos ++)\n      {\n\tif (Header[pos] &&\n\t    (strstr(Header[pos], \"$IMAGE\") != NULL ||\n\t     strstr(Header[pos], \"$HFIMAGE\") != NULL))\n\t  temp_adjust = image_adjust;\n\telse if (Header1[pos] &&\n\t\t (strstr(Header1[pos], \"$IMAGE\") != NULL ||\n\t\t  strstr(Header1[pos], \"$HFIMAGE\") != NULL))\n\t  temp_adjust = image_adjust;\n\telse if (Header[pos] || Header1[pos])\n\t  temp_adjust = (float)(2 * HeadFootSize);\n\telse\n\t  temp_adjust = 0.0;\n\n\tif (temp_adjust > adjust)\n\t  adjust = temp_adjust;\n      }\n\n      *top = PagePrintLength - adjust;\n\n      if (tof)\n        *y = *top;\n    }\n    else if (strncasecmp(comment, \"FOOTER \", 7) == 0)\n    {\n      // Footer string...\n      comment += 7;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (strncasecmp(comment, \"LEFT\", 4) == 0 && isspace(comment[4]))\n      {\n        pos     = 0;\n\tcomment += 4;\n      }\n      else if (strncasecmp(comment, \"CENTER\", 6) == 0 && isspace(comment[6]))\n      {\n        pos     = 1;\n\tcomment += 6;\n      }\n      else if (strncasecmp(comment, \"RIGHT\", 5) == 0 && isspace(comment[5]))\n      {\n        pos     = 2;\n\tcomment += 5;\n      }\n      else\n      {\n        progress_error(HD_ERROR_BAD_COMMENT,\n                       \"Bad FOOTER position: \\\"%s\\\"\", comment);\n\treturn;\n      }\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (*comment != '\\\"')\n      {\n        progress_error(HD_ERROR_BAD_COMMENT,\n                       \"Bad FOOTER string: \\\"%s\\\"\", comment);\n\treturn;\n      }\n\n      for (ptr = buffer, comment ++; *comment && *comment != '\\\"'; comment ++)\n      {\n        if (*comment == '\\\\')\n\t  comment ++;\n\n\tif (ptr < (buffer + sizeof(buffer) - 1))\n\t  *ptr++ = *comment;\n      }\n\n      if (*comment == '\\\"')\n        comment ++;\n\n      *ptr = '\\0';\n\n      if (ptr > buffer)\n        Footer[pos] = strdup(buffer);\n      else\n        Footer[pos] = NULL;\n\n      if (tof)\n      {\n\tcheck_pages(*page);\n\n\tpages[*page].footer[pos] = (uchar *)Footer[pos];\n      }\n\n      // Adjust bottom margin as needed...\n      float adjust, image_adjust, temp_adjust;\n\n      if (maxhfheight > HeadFootSize)\n\timage_adjust = (float)(maxhfheight + HeadFootSize);\n      else\n\timage_adjust = (float)(2 * HeadFootSize);\n\n      for (adjust = 0.0, pos = 0; pos < 3; pos ++)\n      {\n\tif (Footer[pos] &&\n\t    (strstr(Footer[pos], \"$IMAGE\") != NULL ||\n\t     strstr(Footer[pos], \"$HFIMAGE\") != NULL))\n\t  temp_adjust = image_adjust;\n\telse if (Footer[pos])\n\t  temp_adjust = (float)(2 * HeadFootSize);\n\telse\n\t  temp_adjust = 0.0;\n\n\tif (temp_adjust > adjust)\n\t  adjust = temp_adjust;\n      }\n\n      *bottom = adjust;\n    }\n    else if (strncasecmp(comment, \"NUMBER-UP \", 10) == 0)\n    {\n      // N-up printing...\n      comment += 10;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      NumberUp = strtol(comment, (char **)&comment, 10);\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (tof)\n      {\n\tcheck_pages(*page);\n\n        pages[*page].nup = NumberUp;\n      }\n    }\n    else\n      break;\n  }\n\n  DEBUG_printf((\"LEAVING parse_comment() x=%.1f, y=%.1f, page=%d\\n\",\n                *x, *y, *page));\n  DEBUG_printf((\" PagePrintWidth = %d\\n\", PagePrintWidth));\n  DEBUG_printf((\"PagePrintLength = %d\\n\", PagePrintLength));\n  DEBUG_printf((\"      PageWidth = %d\\n\", PageWidth));\n  DEBUG_printf((\"     PageLength = %d\\n\", PageLength));\n  DEBUG_printf((\"       PageLeft = %d\\n\", PageLeft));\n  DEBUG_printf((\"     PageBottom = %d\\n\", PageBottom));\n  DEBUG_printf((\"      PageRight = %d\\n\", PageRight));\n  DEBUG_printf((\"        PageTop = %d\\n\", PageTop));\n  DEBUG_printf((\"      Landscape = %d\\n\", Landscape));\n}\n\n#ifdef COMMENT_DEBUG\n#  undef DEBUG\n#  undef DEBUG_puts\n#  define DEBUG_puts(x)\n#  undef DEBUG_printf\n#  define DEBUG_printf(x)\n#endif /* COMMENT_DEBUG */\n\n\n/*\n * 'find_background()' - Find the background image/color for the given document.\n */\n\nstatic void\nfind_background(tree_t *t)\t/* I - Document to search */\n{\n  uchar\t\t*var;\t\t/* BGCOLOR/BACKGROUND variable */\n\n\n /*\n  * First see if the --bodycolor or --bodyimage options have been\n  * specified...\n  */\n\n  if (BodyImage[0] != '\\0')\n  {\n    background_image = image_load(BodyImage, !OutputColor);\n    return;\n  }\n  else if (BodyColor[0] != '\\0')\n  {\n    get_color((uchar *)BodyColor, background_color, 0);\n    return;\n  }\n\n /*\n  * If not, search the document tree...\n  */\n\n  while (t != NULL && background_image == NULL &&\n         background_color[0] == 1.0 && background_color[1] == 1.0 &&\n\t background_color[2] == 1.0)\n  {\n    if (t->markup == MARKUP_BODY)\n    {\n      if ((var = htmlGetVariable(t, (uchar *)\"BACKGROUND\")) != NULL)\n        background_image = image_load((char *)var, !OutputColor);\n\n      if ((var = htmlGetVariable(t, (uchar *)\"BGCOLOR\")) != NULL)\n        get_color(var, background_color, 0);\n    }\n\n    if (t->child != NULL)\n      find_background(t->child);\n\n    t = t->next;\n  }\n}\n\n\n/*\n * 'write_background()' - Write the background image/color for to the current\n *                        page.\n */\n\nstatic void\nwrite_background(int  page,\t/* I - Page we are writing for */\n                 FILE *out)\t/* I - File to write to */\n{\n  float\tx, y;\n  float\twidth, height;\n  int\tpage_width, page_length;\n\n\n  if (Landscape)\n  {\n    page_length = pages[page].width;\n    page_width  = pages[page].length;\n  }\n  else\n  {\n    page_width  = pages[page].width;\n    page_length = pages[page].length;\n  }\n\n  if (background_color[0] != 1.0 ||\n      background_color[1] != 1.0 ||\n      background_color[2] != 1.0)\n  {\n    if (PSLevel > 0)\n    {\n      render_x = -1.0;\n      render_y = -1.0;\n      set_color(out, background_color);\n      fprintf(out, \"0 0 M %d %d F\\n\", page_width, page_length);\n    }\n    else\n    {\n      set_color(out, background_color);\n      flate_printf(out, \"0 0 %d %d re f\\n\", page_width, page_length);\n    }\n  }\n\n  if (background_image != NULL)\n  {\n    width  = (float)(background_image->width * 72.0f / _htmlPPI);\n    height = (float)(background_image->height * 72.0f / _htmlPPI);\n\n    if (width < 1.0f)\n      width = 1.0f;\n    if (height < 1.0f)\n      height = 1.0f;\n\n    switch (PSLevel)\n    {\n      case 0 :\n          for (x = 0.0; x < page_width; x += width)\n            for (y = page_length; y >= 0.0f;)\n            {\n\t      y -= height;\n  \t      flate_printf(out, \"q %.1f 0 0 %.1f %.1f %.1f cm\", width, height, x, y);\n              flate_printf(out, \"/I%d Do\\n\", background_image->obj);\n\t      flate_puts(\"Q\\n\", out);\n            }\n\t  break;\n\n      default :\n          fprintf(out, \"0 %.1f %d{/y exch neg %d add def\\n\",\n\t          height, page_length + (int)height - 1, page_length);\n\t  fprintf(out, \"0 %.1f %d{/x exch def\\n\",\n\t          width, page_width);\n          fprintf(out, \"GS[%.1f 0 0 %.1f x y]CM/iy -1 def\\n\", width, height);\n\t  fprintf(out, \"%d %d 8[%d 0 0 %d 0 %d]\",\n\t          background_image->width, background_image->height,\n                  background_image->width, -background_image->height,\n\t\t  background_image->height);\n          fputs(\"{/iy iy 1 add def BG iy get}\", out);\n\t  if (background_image->depth == 1)\n\t    fputs(\"image\\n\", out);\n\t  else\n\t    fputs(\"false 3 colorimage\\n\", out);\n\t  fputs(\"GR}for}for\\n\", out);\n          break;\n    }\n  }\n}\n\n\n/*\n * 'new_render()' - Allocate memory for a new rendering structure.\n */\n\nstatic render_t *\t\t\t/* O - New render structure */\nnew_render(int      page,\t\t/* I - Page number (0-n) */\n           int      type,\t\t/* I - Type of render primitive */\n           double   x,\t\t\t/* I - Horizontal position */\n           double   y,\t\t\t/* I - Vertical position */\n           double   width,\t\t/* I - Width */\n           double   height,\t\t/* I - Height */\n           void     *data,\t\t/* I - Data */\n\t   render_t *insert)\t\t/* I - Insert before here... */\n{\n  render_t\t\t*r;\t\t/* New render primitive */\n  size_t\t\tdatalen = 0;\t/* Length of data */\n  static render_t\tdummy;\t\t/* Dummy var for errors... */\n\n\n  DEBUG_printf((\"new_render(page=%d, type=%d, x=%.1f, y=%.1f, width=%.1f, height=%.1f, data=%p, insert=%p)\\n\",\n                page, type, x, y, width, height, (void *)data, (void *)insert));\n\n  check_pages(page);\n\n  if (page < 0 || page >= (int)alloc_pages)\n  {\n    progress_error(HD_ERROR_INTERNAL_ERROR,\n                   \"Page number (%d) out of range (1...%d)\\n\", page + 1,\n                   (int)alloc_pages);\n    memset(&dummy, 0, sizeof(dummy));\n    return (&dummy);\n  }\n\n  if ((type != RENDER_TEXT && type != RENDER_LINK) || data == NULL)\n    r = (render_t *)calloc(sizeof(render_t), 1);\n  else\n  {\n    datalen = strlen((char *)data);\n    r       = (render_t *)calloc(sizeof(render_t) + datalen, 1);\n  }\n\n  if (r == NULL)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY,\n                   \"Unable to allocate memory on page %d\\n\", (int)page + 1);\n    memset(&dummy, 0, sizeof(dummy));\n    return (&dummy);\n  }\n\n  r->type   = type;\n  r->x      = (float)x;\n  r->y      = (float)y;\n  r->width  = (float)width;\n  r->height = (float)height;\n\n  switch (type)\n  {\n    case RENDER_TEXT :\n        if (data == NULL)\n        {\n          free(r);\n          return (NULL);\n        }\n\t// Safe because buffer is allocated...\n        memcpy((char *)r->data.text.buffer, (char *)data, datalen);\n        get_color(_htmlTextColor, r->data.text.rgb);\n        break;\n    case RENDER_IMAGE :\n        if (data == NULL)\n        {\n          free(r);\n          return (NULL);\n        }\n        r->data.image = (image_t *)data;\n        break;\n    case RENDER_BOX :\n        memcpy(r->data.box, data, sizeof(r->data.box));\n        break;\n    case RENDER_LINK :\n        if (data == NULL)\n        {\n          free(r);\n          return (NULL);\n        }\n\t// Safe because buffer is allocated...\n        memcpy((char *)r->data.link, (char *)data, datalen);\n        break;\n  }\n\n  if (insert)\n  {\n    if (insert->prev)\n      insert->prev->next = r;\n    else\n      pages[page].start = r;\n\n    r->prev      = insert->prev;\n    r->next      = insert;\n    insert->prev = r;\n  }\n  else\n  {\n    if (pages[page].end != NULL)\n      pages[page].end->next = r;\n    else\n      pages[page].start = r;\n\n    r->next         = NULL;\n    r->prev         = pages[page].end;\n    pages[page].end = r;\n  }\n\n  DEBUG_printf((\"    returning r = %p\\n\", (void *)r));\n\n  return (r);\n}\n\n\n/*\n * 'check_pages()' - Allocate memory for more pages as needed...\n */\n\nstatic void\ncheck_pages(int page)\t// I - Current page\n{\n  page_t\t*temp;\t// Temporary page pointer\n\n\n  DEBUG_printf((\"check_pages(%d)\\n\", page));\n\n  // See if we need to allocate memory for the page...\n  if (page >= (int)alloc_pages)\n  {\n    // Yes, allocate enough for ALLOC_PAGES more pages...\n    while (page >= (int)alloc_pages)\n      alloc_pages += ALLOC_PAGES;\n\n    // Do the pages pointers...\n    if (num_pages == 0)\n      temp = (page_t *)malloc(sizeof(page_t) * alloc_pages);\n    else\n      temp = (page_t *)realloc(pages, sizeof(page_t) * alloc_pages);\n\n    if (temp == NULL)\n    {\n      progress_error(HD_ERROR_OUT_OF_MEMORY,\n                     \"Unable to allocate memory for %d pages - %s\",\n\t             (int)alloc_pages, strerror(errno));\n      alloc_pages -= ALLOC_PAGES;\n      return;\n    }\n\n    memset(temp + num_pages, 0, (alloc_pages - num_pages) * sizeof(page_t));\n\n    pages = temp;\n  }\n\n  // Initialize the page data as needed...\n  for (temp = pages + num_pages; (int)num_pages <= page; num_pages ++, temp ++)\n  {\n    if (!temp->width)\n    {\n      if (num_pages == 0 || !temp[-1].width || !temp[-1].length || chapter == 0)\n      {\n\ttemp->width     = PageWidth;\n\ttemp->length    = PageLength;\n\ttemp->left      = PageLeft;\n\ttemp->right     = PageRight;\n\ttemp->top       = PageTop;\n\ttemp->bottom    = PageBottom;\n\ttemp->duplex    = PageDuplex;\n\ttemp->landscape = Landscape;\n\ttemp->nup       = NumberUp;\n      }\n      else\n      {\n\tmemcpy(temp, temp - 1, sizeof(page_t));\n\ttemp->start = NULL;\n\ttemp->end   = NULL;\n      }\n\n      temp->url = current_url;\n\n      if (chapter == 0)\n      {\n\tmemcpy(temp->header, TocHeader, sizeof(temp->header));\n\tmemcpy(temp->footer, TocFooter, sizeof(temp->footer));\n      }\n      else\n      {\n\tmemcpy(temp->header, Header, sizeof(temp->header));\n\tmemcpy(temp->header1, Header1, sizeof(temp->header1));\n\tmemcpy(temp->footer, Footer, sizeof(temp->footer));\n\n        if (current_heading != temp->headnode)\n\t{\n\t  temp->heading  = htmlGetText(current_heading);\n\t  temp->headnode = current_heading;\n\t}\n      }\n\n      memcpy(temp->background_color, background_color,\n             sizeof(temp->background_color));\n      temp->background_image = background_image;\n    }\n  }\n}\n\n\n/*\n * 'add_link()' - Add a named link...\n */\n\nstatic void\nadd_link(uchar *name,\t\t/* I - Name of link */\n         int   page,\t\t/* I - Page # */\n         int   top)\t\t/* I - Y position */\n{\n  link_t\t*temp;\t\t/* New name */\n\n\n  if (name == NULL)\n    return;\n\n  DEBUG_printf((\"add_link(name=\\\"%s\\\", page=%d, top=%d)\\n\", name, page, top));\n\n  if ((temp = find_link(name)) != NULL)\n  {\n    temp->page = (short)page;\n    temp->top  = (short)top;\n  }\n  else\n  {\n    // See if we need to allocate memory for links...\n    if (num_links >= alloc_links)\n    {\n      // Allocate more links...\n      alloc_links += ALLOC_LINKS;\n\n      if (num_links == 0)\n        temp = (link_t *)malloc(sizeof(link_t) * alloc_links);\n      else\n        temp = (link_t *)realloc(links, sizeof(link_t) * alloc_links);\n\n      if (temp == NULL)\n      {\n\tprogress_error(HD_ERROR_OUT_OF_MEMORY,\n                       \"Unable to allocate memory for %d links - %s\",\n\t               (int)alloc_links, strerror(errno));\n        alloc_links -= ALLOC_LINKS;\n\treturn;\n      }\n\n      links = temp;\n    }\n\n    // Add a new link...\n    temp = links + num_links;\n    num_links ++;\n\n    strlcpy((char *)temp->name, (char *)name, sizeof(temp->name));\n    temp->page = (short)page;\n    temp->top  = (short)top;\n\n    if (num_links > 1)\n      qsort(links, num_links, sizeof(link_t),\n            (compare_func_t)compare_links);\n  }\n}\n\n\n/*\n * 'find_link()' - Find a named link...\n */\n\nstatic link_t *\nfind_link(uchar *name)\t/* I - Name to find */\n{\n  link_t\tkey,\t/* Search key */\n\t\t*match;\t/* Matching name entry */\n\n\n  if (name == NULL || num_links == 0)\n    return (NULL);\n\n  if (name[0] == '#')\n    name ++;\n\n  strlcpy((char *)key.name, (char *)name, sizeof(key.name));\n  match = (link_t *)bsearch(&key, links, num_links, sizeof(link_t),\n                            (compare_func_t)compare_links);\n\n  return (match);\n}\n\n\n/*\n * 'compare_links()' - Compare two named links.\n */\n\nstatic int\t\t\t/* O - 0 = equal, -1 or 1 = not equal */\ncompare_links(link_t *n1,\t/* I - First name */\n              link_t *n2)\t/* I - Second name */\n{\n  return (strcasecmp((char *)n1->name, (char *)n2->name));\n}\n\n\n#ifdef TABLE_DEBUG\n#  undef DEBUG_printf\n#  undef DEBUG_puts\n#  define DEBUG_printf(x) printf x\n#  define DEBUG_puts(x) puts(x)\n#endif /* TABLE_DEBUG */\n\n//\n// 'get_cell_size()' - Compute the minimum width of a cell.\n//\n\nstatic float\t\t\t\t// O - Required width of cell\nget_cell_size(tree_t *t,\t\t// I - Cell\n              float  left,\t\t// I - Left margin\n\t      float  right,\t\t// I - Right margin\n\t      float  *minwidth,\t\t// O - Minimum width\n\t      float  *prefwidth,\t// O - Preferred width\n\t      float  *minheight)\t// O - Minimum height\n{\n  tree_t\t*temp,\t\t\t// Current tree entry\n\t\t*next;\t\t\t// Next tree entry\n  uchar\t\t*var;\t\t\t// Attribute value\n  int\t\tnowrap;\t\t\t// NOWRAP attribute?\n  float\t\twidth,\t\t\t// Width of cell\n\t\tfrag_width,\t\t// Fragment required width\n\t\tfrag_height,\t\t// Fragment height\n\t\tfrag_pref,\t\t// Fragment preferred width\n\t\tfrag_min,\t\t// Fragment minimum width\n\t\tminh,\t\t\t// Local minimum height\n\t\tminw,\t\t\t// Local minimum width\n\t\tprefw,\t\t\t// Local preferred width\n\t\tformat_width;\t\t// Working format width for images\n\n\n  DEBUG_printf((\"get_cell_size(%p, %.1f, %.1f, %p, %p, %p)\\n\",\n                (void *)t, left, right, (void *)minwidth, (void *)prefwidth, (void *)minheight));\n\n  // First see if the width has been specified for this cell...\n  if ((var = htmlGetVariable(t, (uchar *)\"WIDTH\")) != NULL &&\n      (var[strlen((char *)var) - 1] != '%' || (right - left) > 0.0f))\n  {\n    // Yes, use it!\n    if (var[strlen((char *)var) - 1] == '%')\n      width = (right - left) * atoi((char *)var) * 0.01f;\n    else\n      width = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n    width = 0.0f;\n\n  if ((format_width = right - left) <= 0.0f)\n    format_width = PagePrintWidth;\n\n  minw  = 0.0f;\n  prefw = 0.0f;\n\n  // Then the height...\n  if ((var = htmlGetVariable(t, (uchar *)\"HEIGHT\")) != NULL)\n  {\n    // Yes, use it!\n    if (var[strlen((char *)var) - 1] == '%')\n      minh = PagePrintLength * atoi((char *)var) * 0.01f;\n    else\n      minh = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n    minh = 0.0f;\n\n  nowrap = (htmlGetVariable(t, (uchar *)\"NOWRAP\") != NULL);\n\n  DEBUG_printf((\"nowrap = %d\\n\", nowrap));\n\n  for (temp = t->child, frag_width = 0.0f, frag_pref = 0.0f;\n       temp != NULL;\n       temp = next)\n  {\n    // Point to next markup, if any...\n    next = temp->child;\n\n    switch (temp->markup)\n    {\n      case MARKUP_TABLE :\n\t  // Update widths...\n\t  if (frag_pref > prefw)\n\t    prefw = frag_pref;\n\n\t  if (frag_width > minw)\n\t  {\n\t    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for block...\\n\",\n\t        \t  frag_width, minw));\n\t    minw = frag_width;\n\t  }\n\n\t  if (nowrap && frag_pref > minw)\n\t  {\n\t    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for break...\\n\",\n\t        \t  frag_pref, minw));\n\t    minw = frag_pref;\n\t  }\n\n          // For nested tables, compute the width of the table.\n          frag_width = get_table_size(temp, left, right, &frag_min,\n\t                              &frag_pref, &frag_height);\n\n\t  if (frag_pref > prefw)\n\t    prefw = frag_pref;\n\n\t  if (frag_min > minw)\n\t  {\n\t    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for nested table...\\n\",\n\t                  frag_min, minw));\n\t    minw = frag_min;\n\t  }\n\n\t  frag_width = 0.0f;\n\t  frag_pref  = 0.0f;\n\t  frag_min   = 0.0f;\n\t  next       = NULL;\n\t  break;\n\n      case MARKUP_IMG :\n          // Update the image width as needed...\n\t  if (temp->markup == MARKUP_IMG)\n\t    update_image_size(temp);\n      case MARKUP_NONE :\n      case MARKUP_SPACER :\n          frag_height = temp->height;\n\n#ifdef TABLE_DEBUG2\n          if (temp->markup == MARKUP_NONE)\n\t    printf(\"FRAG(%s) = %.1f\\n\", temp->data, temp->width);\n\t  else if (temp->markup == MARKUP_SPACER)\n\t    printf(\"SPACER = %.1f\\n\", temp->width);\n\t  else\n\t    printf(\"IMG(%s) = %.1f\\n\", htmlGetVariable(temp, (uchar *)\"SRC\"),\n\t           temp->width);\n#endif // TABLE_DEBUG2\n\n          // Handle min/preferred widths separately...\n          if (temp->width > minw)\n\t  {\n\t    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for fragment...\\n\",\n\t                  temp->width, minw));\n\t    minw = temp->width;\n\t  }\n\n          if (temp->preformatted && temp->data != NULL &&\n              temp->data[strlen((char *)temp->data) - 1] == '\\n')\n          {\n\t    // End of a line - check preferred width...\n\t    frag_pref += temp->width + 1;\n\n            if (frag_pref > prefw)\n              prefw = frag_pref;\n\n            if (temp->preformatted && frag_pref > minw)\n\t    {\n\t      DEBUG_printf((\"Setting minw to %.1f (was %.1f) for preformatted...\\n\",\n\t                    frag_pref, minw));\n              minw = frag_pref;\n\t    }\n\n\t    frag_pref = 0.0f;\n          }\n          else if (temp->data != NULL)\n\t    frag_pref += temp->width + 1;\n\t  else if ((frag_pref + temp->width) > format_width)\n\t  {\n\t    // parse_paragraph() will force a break\n            if (frag_pref > prefw)\n              prefw = frag_pref;\n\n\t    frag_pref = temp->width;\n\t  }\n\t  else\n\t    frag_pref += temp->width;\n\n          if (temp->preformatted && temp->data != NULL &&\n              temp->data[strlen((char *)temp->data) - 1] == '\\n')\n\t  {\n\t    // Check required width...\n            frag_width += temp->width + 1;\n\n            if (frag_width > minw)\n\t    {\n\t      DEBUG_printf((\"Setting minw to %.1f (was %.1f) for block...\\n\",\n\t                    frag_width, minw));\n              minw = frag_width;\n\t    }\n\n            frag_width = 0.0f;\n\t  }\n          else if (!temp->preformatted && temp->data != NULL &&\n\t           (isspace(temp->data[0]) ||\n\t \t    (temp->data[0] && isspace(temp->data[strlen((char *)temp->data) - 1]))))\n\t  {\n\t    // Check required width...\n\t    if (isspace(temp->data[0]))\n\t      frag_width = temp->width + 1;\n\t    else\n              frag_width += temp->width + 1;\n\n            if (frag_width > minw)\n\t    {\n\t      DEBUG_printf((\"Setting minw to %.1f (was %.1f) for block...\\n\",\n\t                    frag_width, minw));\n              minw = frag_width;\n\t    }\n\n\t    if (!isspace(temp->data[0]))\n              frag_width = 0.0f;\n\n            DEBUG_printf((\"frag_width=%.1f after whitespace processing...\\n\",\n\t                  frag_width));\n\t  }\n\t  else if (temp->data != NULL)\n            frag_width += temp->width + 1;\n\t  else if ((frag_width + temp->width) > format_width)\n\t    // parse_paragraph() will force a break\n\t    frag_width = temp->width;\n\t  else\n\t    frag_width += temp->width;\n\t  break;\n\n      case MARKUP_ADDRESS :\n      case MARKUP_BLOCKQUOTE :\n      case MARKUP_BR :\n      case MARKUP_CENTER :\n      case MARKUP_DD :\n      case MARKUP_DIV :\n      case MARKUP_DT :\n      case MARKUP_H1 :\n      case MARKUP_H2 :\n      case MARKUP_H3 :\n      case MARKUP_H4 :\n      case MARKUP_H5 :\n      case MARKUP_H6 :\n      case MARKUP_H7 :\n      case MARKUP_H8 :\n      case MARKUP_H9 :\n      case MARKUP_H10 :\n      case MARKUP_H11 :\n      case MARKUP_H12 :\n      case MARKUP_H13 :\n      case MARKUP_H14 :\n      case MARKUP_H15 :\n      case MARKUP_HR :\n      case MARKUP_LI :\n      case MARKUP_P :\n      case MARKUP_PRE :\n          DEBUG_printf((\"BREAK at %.1f\\n\", frag_pref));\n\n\t  if (frag_pref > prefw)\n\t    prefw = frag_pref;\n\n          if (frag_width > minw)\n\t  {\n\t    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for block...\\n\",\n\t                  frag_width, minw));\n            minw = frag_width;\n\t  }\n\n\t  if (nowrap && frag_pref > minw)\n\t  {\n\t    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for break...\\n\",\n\t                  frag_pref, minw));\n\t    minw = frag_pref;\n\t  }\n\n          frag_pref   = 0.0f;\n\t  frag_width  = 0.0f;\n\n      default :\n          frag_height = 0.0f;\n\t  break;\n    }\n\n    // Update minimum height...\n    if (frag_height > minh)\n      minh = frag_height;\n\n    // Update next pointer as needed...\n    if (next == NULL)\n      next = temp->next;\n\n    if (next == NULL)\n    {\n      // This code is almost funny if you say it fast... :)\n      for (next = temp->parent; next != NULL && next != t; next = next->parent)\n\tif (next->next != NULL)\n\t  break;\n\n      if (next == t)\n\tnext = NULL;\n      else if (next)\n\tnext = next->next;\n    }\n  }\n\n  // Check the last fragment's width...\n  if (frag_pref > prefw)\n    prefw = frag_pref;\n\n  if (frag_width > minw)\n  {\n    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for block...\\n\",\n\t          frag_width, minw));\n    minw = frag_width;\n  }\n\n  // Handle the \"NOWRAP\" option...\n  if (nowrap && prefw > minw)\n  {\n    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for NOWRAP...\\n\",\n\t          prefw, minw));\n    minw = prefw;\n  }\n\n  // Return the required, minimum, and preferred size of the cell...\n  *minwidth  = minw;\n  *prefwidth = prefw;\n  *minheight = minh;\n\n  DEBUG_printf((\"get_cell_size(): width=%.1f, minw=%.1f, prefw=%.1f, minh=%.1f\\n\",\n                width, minw, prefw, minh));\n\n  return (width);\n}\n\n\n//\n// 'get_table_size()' - Compute the minimum width of a table.\n//\n\nstatic float\t\t\t\t// O - Minimum width of table\nget_table_size(tree_t *t,\t\t// I - Table\n               float  left,\t\t// I - Left margin\n\t       float  right,\t\t// I - Right margin\n\t       float  *minwidth,\t// O - Minimum width\n\t       float  *prefwidth,\t// O - Preferred width\n\t       float  *minheight)\t// O - Minimum height\n{\n  tree_t\t*temp,\t\t\t// Current tree entry\n\t\t*next;\t\t\t// Next tree entry\n  uchar\t\t*var;\t\t\t// Attribute value\n  float\t\twidth,\t\t\t// Required width of table\n\t\tminw,\t\t\t// Minimum width of table\n\t\tminh,\t\t\t// Minimum height of table\n\t\tprefw,\t\t\t// Preferred width of table\n\t\tcell_width,\t\t// Cell required width\n\t\tcell_pref,\t\t// Cell preferred width\n\t\tcell_min,\t\t// Cell minimum width\n\t\tcell_height,\t\t// Cell minimum height\n\t\trow_width,\t\t// Row required width\n\t\trow_pref,\t\t// Row preferred width\n\t\trow_min,\t\t// Row minimum width\n\t\trow_height,\t\t// Row minimum height\n\t\tborder,\t\t\t// Border around cells\n\t\tcellpadding,\t\t// Padding inside cells\n\t\tcellspacing;\t\t// Spacing around cells\n  int\t\tcolumns,\t\t// Current number of columns\n\t\tmax_columns,\t\t// Maximum columns\n\t\trows;\t\t\t// Number of rows\n\n\n  DEBUG_printf((\"get_table_size(%p, %.1f, %.1f, %p, %p, %p)\\n\",\n                (void *)t, left, right, (void *)minwidth, (void *)prefwidth, (void *)minheight));\n\n  // First see if the width has been specified for this table...\n  if ((var = htmlGetVariable(t, (uchar *)\"WIDTH\")) != NULL &&\n      (var[strlen((char *)var) - 1] != '%' || (right - left) > 0.0f))\n  {\n    // Yes, use it!\n    if (var[strlen((char *)var) - 1] == '%')\n      width = (right - left) * atoi((char *)var) * 0.01f;\n    else\n      width = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n    width = 0.0f;\n\n  minw  = 0.0f;\n  prefw = 0.0f;\n\n  // Then the height...\n  if ((var = htmlGetVariable(t, (uchar *)\"HEIGHT\")) != NULL)\n  {\n    // Yes, use it!\n    if (var[strlen((char *)var) - 1] == '%')\n      minh = PagePrintLength * atoi((char *)var) * 0.01f;\n    else\n      minh = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n    minh = 0.0f;\n\n  // Update the size as needed...\n  for (temp = t->child, row_width = 0.0f, row_min = 0.0f, row_pref = 0.0f,\n\t   row_height = 0.0f, columns = 0, rows = 0, max_columns = 0;\n       temp != NULL;\n       temp = next)\n  {\n    // Point to next markup, if any...\n    next = temp->child;\n\n    // Start a new row or add the cell width as needed...\n    if (temp->markup == MARKUP_TR)\n    {\n      minh += row_height;\n\n      row_width  = 0.0f;\n      row_pref   = 0.0f;\n      row_min    = 0.0f;\n      row_height = 0.0f;\n      rows ++;\n      columns = 0;\n    }\n    else if (temp->markup == MARKUP_TD || temp->markup == MARKUP_TH)\n    {\n      // Update columns...\n      columns ++;\n      if (columns > max_columns)\n\tmax_columns = columns;\n\n      // Get widths of cell...\n      cell_width = get_cell_size(temp, left, right, &cell_min, &cell_pref,\n                                 &cell_height);\n\n      // Update row widths...\n      row_width += cell_width;\n      row_pref  += cell_pref;\n      row_min   += cell_min;\n\n      if (cell_height > row_height)\n\trow_height = cell_height;\n\n      // Check current row widths against table...\n      if (row_pref > prefw)\n\tprefw = row_pref;\n\n      if (row_min > minw)\n\tminw = row_min;\n    }\n\n    // Update next pointer as needed...\n    if (next == NULL)\n      next = temp->next;\n\n    if (next == NULL)\n    {\n      // This code is almost funny if you say it fast... :)\n      for (next = temp->parent; next != NULL && next != t; next = next->parent)\n\tif (next->next != NULL)\n\t  break;\n\n      if (next == t)\n\tnext = NULL;\n      else if (next)\n\tnext = next->next;\n    }\n  }\n\n  // Make sure last row is counted in min height calcs.\n  minh += row_height;\n\n  // Add room for spacing and padding...\n  if ((var = htmlGetVariable(t, (uchar *)\"CELLPADDING\")) != NULL)\n    cellpadding = atoi((char *)var);\n  else\n    cellpadding = 1.0f;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"CELLSPACING\")) != NULL)\n    cellspacing = atoi((char *)var);\n  else\n    cellspacing = 0.0f;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"BORDER\")) != NULL)\n  {\n    if ((border = (float)atof((char *)var)) == 0.0 && var[0] != '0')\n      border = 1.0f;\n\n    cellpadding += border;\n  }\n  else\n    border = 0.0f;\n\n  if (border == 0.0f && cellpadding > 0.0f)\n  {\n   /*\n    * Ah, the strange table formatting nightmare that is HTML.\n    * Netscape and MSIE assign an invisible border width of 1\n    * pixel if no border is specified...\n    */\n\n    cellpadding += 1.0f;\n  }\n\n  cellspacing *= PagePrintWidth / _htmlBrowserWidth;\n  cellpadding *= PagePrintWidth / _htmlBrowserWidth;\n\n  DEBUG_printf((\"ADDING %.1f for table space for %d columns...\\n\",\n                max_columns * (2 * cellpadding + cellspacing) - cellspacing,\n\t\tmax_columns));\n\n  if (width > 0.0f)\n    width += max_columns * (2 * cellpadding + cellspacing) - cellspacing;\n\n  minw  += max_columns * (2 * cellpadding + cellspacing) - cellspacing;\n  prefw += max_columns * (2 * cellpadding + cellspacing) - cellspacing;\n  minh  += rows * (2 * cellpadding + cellspacing) - cellspacing;\n\n  // Return the required, minimum, and preferred size of the table...\n  *minwidth  = minw;\n  *prefwidth = prefw;\n  *minheight = minh;\n\n  DEBUG_printf((\"get_table_size(): width=%.1f, minw=%.1f, prefw=%.1f, minh=%.1f\\n\",\n                width, minw, prefw, minh));\n\n  return (width);\n}\n\n#ifdef TABLE_DEBUG\n#  undef DEBUG_printf\n#  undef DEBUG_puts\n#  define DEBUG_printf(x)\n#  define DEBUG_puts(x)\n#endif /* TABLE_DEBUG */\n\n\n/*\n * 'flatten_tree()' - Flatten an HTML tree to only include the text, image,\n *                    link, and break markups.\n */\n\nstatic tree_t *\t\t\t/* O - Flattened markup tree */\nflatten_tree(tree_t *t)\t\t/* I - Markup tree to flatten */\n{\n  tree_t\t*temp,\t\t/* New tree node */\n\t\t*flat;\t\t/* Flattened tree */\n\n\n  flat = NULL;\n\n  while (t != NULL)\n  {\n    switch (t->markup)\n    {\n      case MARKUP_NONE :\n          if (t->data == NULL)\n\t    break;\n      case MARKUP_COMMENT :\n      case MARKUP_BR :\n      case MARKUP_SPACER :\n      case MARKUP_IMG :\n\t  temp = (tree_t *)calloc(sizeof(tree_t), 1);\n\t  memcpy(temp, t, sizeof(tree_t));\n\t  temp->parent = NULL;\n\t  temp->child  = NULL;\n\t  temp->prev   = flat;\n\t  temp->next   = NULL;\n\t  if (flat != NULL)\n            flat->next = temp;\n          flat = temp;\n\n          if (temp->markup == MARKUP_IMG)\n            update_image_size(temp);\n          break;\n\n      case MARKUP_A :\n          if (htmlGetVariable(t, (uchar *)\"NAME\") != NULL)\n          {\n\t    temp = (tree_t *)calloc(sizeof(tree_t), 1);\n\t    memcpy(temp, t, sizeof(tree_t));\n\t    temp->parent = NULL;\n\t    temp->child  = NULL;\n\t    temp->prev   = flat;\n\t    temp->next   = NULL;\n\t    if (flat != NULL)\n              flat->next = temp;\n            flat = temp;\n          }\n\t  break;\n\n      case MARKUP_P :\n      case MARKUP_PRE :\n      case MARKUP_H1 :\n      case MARKUP_H2 :\n      case MARKUP_H3 :\n      case MARKUP_H4 :\n      case MARKUP_H5 :\n      case MARKUP_H6 :\n      case MARKUP_H7 :\n      case MARKUP_H8 :\n      case MARKUP_H9 :\n      case MARKUP_H10 :\n      case MARKUP_H11 :\n      case MARKUP_H12 :\n      case MARKUP_H13 :\n      case MARKUP_H14 :\n      case MARKUP_H15 :\n      case MARKUP_UL :\n      case MARKUP_DIR :\n      case MARKUP_MENU :\n      case MARKUP_OL :\n      case MARKUP_DL :\n      case MARKUP_LI :\n      case MARKUP_DD :\n      case MARKUP_DT :\n      case MARKUP_TR :\n      case MARKUP_CAPTION :\n\t  temp = (tree_t *)calloc(sizeof(tree_t), 1);\n\t  temp->markup = MARKUP_BR;\n\t  temp->parent = NULL;\n\t  temp->child  = NULL;\n\t  temp->prev   = flat;\n\t  temp->next   = NULL;\n\t  if (flat != NULL)\n            flat->next = temp;\n          flat = temp;\n          break;\n\n      default :\n          break;\n    }\n\n    if (t->child != NULL && t->markup != MARKUP_UNKNOWN)\n    {\n      temp = flatten_tree(t->child);\n\n      if (temp != NULL)\n        temp->prev = flat;\n      if (flat != NULL)\n        flat->next = temp;\n      else\n        flat = temp;\n    }\n\n    if (flat != NULL)\n      while (flat->next != NULL)\n        flat = flat->next;\n\n    t = t->next;\n  }\n\n  if (flat == NULL)\n    return (NULL);\n\n  while (flat->prev != NULL)\n    flat = flat->prev;\n\n  return (flat);\n}\n\n\n/*\n * 'update_image_size()' - Update the size of an image based upon the\n *                         printable width.\n */\n\nstatic void\nupdate_image_size(tree_t *t)\t/* I - Tree entry */\n{\n  image_t\t*img;\t\t/* Image file */\n  uchar\t\t*width,\t\t/* Width string */\n\t\t*height;\t/* Height string */\n\n\n  width  = htmlGetVariable(t, (uchar *)\"WIDTH\");\n  height = htmlGetVariable(t, (uchar *)\"HEIGHT\");\n\n  if (width != NULL && height != NULL)\n  {\n    if (width[strlen((char *)width) - 1] == '%')\n      t->width = (float)(atof((char *)width) * PagePrintWidth / 100.0f);\n    else\n      t->width = (float)(atoi((char *)width) * PagePrintWidth / _htmlBrowserWidth);\n\n    if (height[strlen((char *)height) - 1] == '%')\n      t->height = (float)(atof((char *)height) * PagePrintWidth / 100.0f);\n    else\n      t->height = (float)(atoi((char *)height) * PagePrintWidth / _htmlBrowserWidth);\n\n    return;\n  }\n\n  img = image_find((char *)htmlGetVariable(t, (uchar *)\"REALSRC\"));\n\n  if (img == NULL)\n    return;\n\n  if (width != NULL)\n  {\n    if (width[strlen((char *)width) - 1] == '%')\n      t->width = (float)(atof((char *)width) * PagePrintWidth / 100.0f);\n    else\n      t->width = (float)(atoi((char *)width) * PagePrintWidth / _htmlBrowserWidth);\n\n    t->height = t->width * img->height / img->width;\n  }\n  else if (height != NULL)\n  {\n    if (height[strlen((char *)height) - 1] == '%')\n      t->height = (float)(atof((char *)height) * PagePrintWidth / 100.0f);\n    else\n      t->height = (float)(atoi((char *)height) * PagePrintWidth / _htmlBrowserWidth);\n\n    t->width = t->height * img->width / img->height;\n  }\n  else\n  {\n    t->width  = (float)(img->width * PagePrintWidth / _htmlBrowserWidth);\n    t->height = (float)(img->height * PagePrintWidth / _htmlBrowserWidth);\n  }\n}\n\n\n/*\n * 'get_width()' - Get the width of a string in points.\n */\n\nstatic float\t\t\t/* O - Width in points */\nget_width(uchar *s,\t\t/* I - String to scan */\n          int   typeface,\t/* I - Typeface code */\n          int   style,\t\t/* I - Style code */\n          int   size)\t\t/* I - Size */\n{\n  uchar\t*ptr;\t\t\t/* Current character */\n  int\twidth;\t\t\t/* Current width */\n\n\n  DEBUG_printf((\"get_width(\\\"%s\\\", %d, %d, %d)\\n\",\n                s == NULL ? \"(null)\" : (const char *)s,\n                typeface, style, size));\n\n  if (s == NULL)\n    return (0.0);\n\n  if (!_htmlWidthsLoaded[typeface][style])\n    htmlLoadFontWidths(typeface, style);\n\n  for (width = 0, ptr = s; *ptr != '\\0'; ptr ++)\n    width += _htmlWidths[typeface][style][*ptr];\n\n  return (width * _htmlSizes[size] * 0.001f);\n}\n\n\n/*\n * 'get_title()' - Get the title string for a document.\n */\n\nstatic uchar *\t\t/* O - Title string */\nget_title(tree_t *doc)\t/* I - Document */\n{\n  uchar\t*temp;\n\n\n  while (doc != NULL)\n  {\n    if (doc->markup == MARKUP_TITLE)\n      return (htmlGetText(doc->child));\n    else if (doc->child != NULL)\n      if ((temp = get_title(doc->child)) != NULL)\n        return (temp);\n    doc = doc->next;\n  }\n\n  return (NULL);\n}\n\n\n/*\n * 'open_file()' - Open an output file for the current chapter.\n */\n\nstatic FILE *\t\t/* O - File pointer */\nopen_file(void)\n{\n  char\tfilename[255];\t/* Filename */\n\n\n  if (OutputFiles && PSLevel > 0)\n  {\n    if (chapter == -1)\n      snprintf(filename, sizeof(filename), \"%s/cover.ps\", OutputPath);\n    else if (chapter == 0)\n      snprintf(filename, sizeof(filename), \"%s/contents.ps\", OutputPath);\n    else\n      snprintf(filename, sizeof(filename), \"%s/doc%d.ps\", OutputPath, chapter);\n\n    return (fopen(filename, \"wb+\"));\n  }\n  else if (OutputFiles)\n  {\n    snprintf(filename, sizeof(filename), \"%s/doc.pdf\", OutputPath);\n\n    return (fopen(filename, \"wb+\"));\n  }\n  else if (OutputPath[0] != '\\0')\n    return (fopen(OutputPath, \"wb+\"));\n  else if (PSLevel == 0)\n    return (file_temp(stdout_filename, sizeof(stdout_filename)));\n  else\n    return (stdout);\n}\n\n\n/*\n * 'set_color()' - Set the current text color...\n */\n\nstatic void\nset_color(FILE  *out,\t/* I - File to write to */\n          float *rgb)\t/* I - RGB color */\n{\n  if (rgb[0] == render_rgb[0] &&\n      rgb[1] == render_rgb[1] &&\n      rgb[2] == render_rgb[2])\n    return;\n\n  render_rgb[0] = rgb[0];\n  render_rgb[1] = rgb[1];\n  render_rgb[2] = rgb[2];\n\n  if (OutputColor)\n  {\n    // Output RGB color...\n    if (PSLevel > 0)\n      fprintf(out, \"%.2f %.2f %.2f C \", rgb[0], rgb[1], rgb[2]);\n    else\n      flate_printf(out, \"%.2f %.2f %.2f rg \", rgb[0], rgb[1], rgb[2]);\n  }\n  else\n  {\n    // Output grayscale...\n    if (PSLevel > 0)\n      fprintf(out, \"%.2f G \",\n              rgb[0] * 0.31f + rgb[1] * 0.61f + rgb[2] * 0.08f);\n    else\n      flate_printf(out, \"%.2f g \",\n                   rgb[0] * 0.31f + rgb[1] * 0.61f + rgb[2] * 0.08f);\n  }\n}\n\n\n/*\n * 'set_font()' - Set the current text font.\n */\n\nstatic void\nset_font(FILE  *out,\t\t\t/* I - File to write to */\n         int   typeface,\t\t/* I - Typeface code */\n         int   style,\t\t\t/* I - Style code */\n         float size)\t\t\t/* I - Size */\n{\n  char\tsizes[255],\t/* Formatted string for size... */\n\t*s;\t\t/* Pointer to end of string */\n\n\n  if (typeface == render_typeface &&\n      style == render_style &&\n      size == render_size)\n    return;\n\n /*\n  * Format size and strip trailing 0's and decimals...\n  */\n\n  snprintf(sizes, sizeof(sizes), \"%.1f\", size);\n\n  for (s = sizes + strlen(sizes) - 1; s > sizes && *s == '0'; s --)\n    *s = '\\0';\n\n  if (*s == '.')\n    *s = '\\0';\n\n /*\n  * Set the new typeface, style, and size.\n  */\n\n  if (PSLevel > 0)\n  {\n    if (size != render_size)\n      fprintf(out, \"%s FS\", sizes);\n\n    fprintf(out, \"/F%x SF \", typeface * 4 + style);\n  }\n  else\n    flate_printf(out, \"/F%x %s Tf \", typeface * 4 + style, sizes);\n\n  render_typeface = typeface;\n  render_style    = style;\n  render_size     = size;\n}\n\n\n/*\n * 'set_pos()' - Set the current text position.\n */\n\nstatic void\nset_pos(FILE  *out,\t\t\t/* I - File to write to */\n        float x,\t\t\t/* I - X position */\n        float y)\t\t\t/* I - Y position */\n{\n  char\txs[255],\t\t\t/* Formatted string for X... */\n\tys[255],\t\t\t/* Formatted string for Y... */\n\t*s;\t\t\t\t/* Pointer to end of string */\n\n\n  if (fabs(render_x - x) < 0.1 && fabs(render_y - y) < 0.1)\n    return;\n\n /*\n  * Format X and Y...\n  */\n\n  if (PSLevel > 0 || render_x == -1.0)\n  {\n    snprintf(xs, sizeof(xs), \"%.3f\", x);\n    snprintf(ys, sizeof(ys), \"%.3f\", y);\n  }\n  else\n  {\n    snprintf(xs, sizeof(xs), \"%.3f\", x - render_startx);\n    snprintf(ys, sizeof(ys), \"%.3f\", y - render_y);\n  }\n\n /*\n  * Strip trailing 0's and decimals...\n  */\n\n  for (s = xs + strlen(xs) - 1; s > xs && *s == '0'; s --)\n    *s = '\\0';\n\n  if (*s == '.')\n    *s = '\\0';\n\n  for (s = ys + strlen(ys) - 1; s > ys && *s == '0'; s --)\n    *s = '\\0';\n\n  if (*s == '.')\n    *s = '\\0';\n\n  if (PSLevel > 0)\n    fprintf(out, \"%s %s M\", xs, ys);\n  else\n    flate_printf(out, \"%s %s Td\", xs, ys);\n\n  render_x = render_startx = x;\n  render_y = y;\n}\n\n\n/*\n * 'ps_hex()' - Print binary data as a series of hexadecimal numbers.\n */\n\nstatic void\nps_hex(FILE  *out,\t\t\t/* I - File to print to */\n       uchar *data,\t\t\t/* I - Data to print */\n       int   length)\t\t\t/* I - Number of bytes to print */\n{\n  int\t\tcol;\n  static const char *hex = \"0123456789ABCDEF\";\n\n\n  col = 0;\n  while (length > 0)\n  {\n   /*\n    * Put the hex uchars out to the file; note that we don't use fprintf()\n    * for speed reasons...\n    */\n\n    putc(hex[*data >> 4], out);\n    putc(hex[*data & 15], out);\n\n    data ++;\n    length --;\n\n    col = (col + 1) % 40;\n    if (col == 0)\n      putc('\\n', out);\n  }\n\n  if (col > 0)\n    putc('\\n', out);\n}\n\n\n\n#ifdef HTMLDOC_ASCII85\n/*\n * 'ps_ascii85()' - Print binary data as a series of base-85 numbers.\n */\n\nstatic void\nps_ascii85(FILE  *out,\t\t\t/* I - File to print to */\n\t   uchar *data,\t\t\t/* I - Data to print */\n\t   int   length,\t\t/* I - Number of bytes to print */\n\t   int   eod)\t\t\t/* I - 1 = end-of-data */\n{\n  unsigned\tb = 0;\t\t\t/* Current 32-bit word */\n  uchar\t\tc[5];\t\t\t/* Base-85 encoded characters */\n  static int\tcol = 0;\t\t/* Column */\n  static uchar\tleftdata[4];\t\t/* Leftover data at the end */\n  static int\tleftcount = 0;\t\t/* Size of leftover data */\n\n\n  length += leftcount;\n\n  while (length > 3)\n  {\n    switch (leftcount)\n    {\n      case 0 :\n          b = (unsigned)((((((data[0] << 8) | data[1]) << 8) | data[2]) << 8) | data[3]);\n\t  break;\n      case 1 :\n          b = (unsigned)((((((leftdata[0] << 8) | data[0]) << 8) | data[1]) << 8) | data[2]);\n\t  break;\n      case 2 :\n          b = (unsigned)((((((leftdata[0] << 8) | leftdata[1]) << 8) | data[0]) << 8) | data[1]);\n\t  break;\n      case 3 :\n          b = (unsigned)((((((leftdata[0] << 8) | leftdata[1]) << 8) | leftdata[2]) << 8) | data[0]);\n\t  break;\n    }\n\n    if (col >= 76)\n    {\n      col = 0;\n      putc('\\n', out);\n    }\n\n    if (b == 0)\n    {\n      putc('z', out);\n      col ++;\n    }\n    else\n    {\n      c[4] = (b % 85) + '!';\n      b /= 85;\n      c[3] = (b % 85) + '!';\n      b /= 85;\n      c[2] = (b % 85) + '!';\n      b /= 85;\n      c[1] = (b % 85) + '!';\n      b /= 85;\n      c[0] = (uchar)(b + '!');\n\n      fwrite(c, 1, 5, out);\n      col += 5;\n    }\n\n    data      += 4 - leftcount;\n    length    -= 4 - leftcount;\n    leftcount = 0;\n  }\n\n  if (length > 0)\n  {\n    // Copy any remainder into the leftdata array...\n    if ((length - leftcount) > 0)\n      memcpy(leftdata + leftcount, data, (size_t)(length - leftcount));\n\n    memset(leftdata + length, 0, (size_t)(4 - length));\n\n    leftcount = length;\n  }\n\n  if (eod)\n  {\n    // Do the end-of-data dance...\n    if (col >= 76)\n    {\n      col = 0;\n      putc('\\n', out);\n    }\n\n    if (leftcount > 0)\n    {\n      // Write the remaining bytes as needed...\n      b = (unsigned)((((((leftdata[0] << 8) | leftdata[1]) << 8) | leftdata[2]) << 8) | leftdata[3]);\n\n      c[4] = (b % 85) + '!';\n      b /= 85;\n      c[3] = (b % 85) + '!';\n      b /= 85;\n      c[2] = (b % 85) + '!';\n      b /= 85;\n      c[1] = (b % 85) + '!';\n      b /= 85;\n      c[0] = (uchar)(b + '!');\n\n      fwrite(c, (size_t)(leftcount + 1), 1, out);\n\n      leftcount = 0;\n    }\n\n    fputs(\"~>\\n\", out);\n    col = 0;\n  }\n}\n#endif // HTMLDOC_ASCII85\n\n\n/*\n * JPEG library destination data manager.  These routines direct\n * compressed data from libjpeg into the PDF or PostScript file.\n */\n\nstatic FILE\t\t\t*jpg_file;\t/* JPEG file */\nstatic uchar\t\t\tjpg_buf[8192];\t/* JPEG buffer */\nstatic jpeg_destination_mgr\tjpg_dest;\t/* JPEG destination manager */\nstatic struct jpeg_error_mgr\tjerr;\t\t/* JPEG error handler */\n\n\n/*\n * 'jpg_init()' - Initialize the JPEG destination.\n */\n\nstatic void\njpg_init(j_compress_ptr cinfo)\t\t/* I - Compressor info */\n{\n  (void)cinfo;\n\n  jpg_dest.next_output_byte = jpg_buf;\n  jpg_dest.free_in_buffer   = sizeof(jpg_buf);\n}\n\n\n/*\n * 'jpg_empty()' - Empty the JPEG output buffer.\n */\n\nstatic boolean\t\t\t\t/* O - True if buffer written OK */\njpg_empty(j_compress_ptr cinfo)\t\t/* I - Compressor info */\n{\n  (void)cinfo;\n\n  if (PSLevel > 0)\n#ifdef HTMLDOC_ASCII85\n    ps_ascii85(jpg_file, jpg_buf, sizeof(jpg_buf));\n#else\n    ps_hex(jpg_file, jpg_buf, sizeof(jpg_buf));\n#endif // HTMLDOC_ASCII85\n  else\n    flate_write(jpg_file, jpg_buf, sizeof(jpg_buf));\n\n  jpg_dest.next_output_byte = jpg_buf;\n  jpg_dest.free_in_buffer   = sizeof(jpg_buf);\n\n  return (TRUE);\n}\n\n\n/*\n * 'jpg_term()' - Write the last JPEG data to the file.\n */\n\nstatic void\njpg_term(j_compress_ptr cinfo)\t\t/* I - Compressor info */\n{\n  int nbytes;\t\t\t\t/* Number of bytes to write */\n\n\n  (void)cinfo;\n\n  nbytes = sizeof(jpg_buf) - jpg_dest.free_in_buffer;\n\n  if (PSLevel > 0)\n#ifdef HTMLDOC_ASCII85\n    ps_ascii85(jpg_file, jpg_buf, nbytes);\n#else\n    ps_hex(jpg_file, jpg_buf, nbytes);\n#endif // HTMLDOC_ASCII85\n  else\n    flate_write(jpg_file, jpg_buf, nbytes);\n}\n\n\n/*\n * 'jpg_setup()' - Setup the JPEG compressor for writing an image.\n */\n\nstatic void\njpg_setup(FILE           *out,\t/* I - Output file */\n          image_t        *img,\t/* I - Output image */\n          j_compress_ptr cinfo)\t/* I - Compressor info */\n{\n  int\ti;\t\t\t// Looping var\n\n\n  jpg_file    = out;\n  cinfo->err  = jpeg_std_error(&jerr);\n\n  jpeg_create_compress(cinfo);\n\n  cinfo->dest = &jpg_dest;\n  jpg_dest.init_destination    = jpg_init;\n  jpg_dest.empty_output_buffer = jpg_empty;\n  jpg_dest.term_destination    = jpg_term;\n\n  cinfo->image_width      = (JDIMENSION)img->width;\n  cinfo->image_height     = (JDIMENSION)img->height;\n  cinfo->input_components = img->depth;\n  cinfo->in_color_space   = img->depth == 1 ? JCS_GRAYSCALE : JCS_RGB;\n\n  jpeg_set_defaults(cinfo);\n  jpeg_set_quality(cinfo, OutputJPEG, TRUE);\n\n  // Update things when writing to PS files...\n  if (PSLevel)\n  {\n    // Adobe uses sampling == 1\n    for (i = 0; i < img->depth; i ++)\n    {\n      cinfo->comp_info[i].h_samp_factor = 1;\n      cinfo->comp_info[i].v_samp_factor = 1;\n    }\n  }\n\n  cinfo->write_JFIF_header  = FALSE;\n  cinfo->write_Adobe_marker = TRUE;\n\n  jpeg_start_compress(cinfo, TRUE);\n}\n\n\n/*\n * 'compare_rgb()' - Compare two RGB colors...\n */\n\nstatic int\t\t\t\t/* O - -1 if rgb1<rgb2, etc. */\ncompare_rgb(unsigned *rgb1,\t\t/* I - First color */\n            unsigned *rgb2)\t\t/* I - Second color */\n{\n  return ((int)*rgb1 - (int)*rgb2);\n}\n\n\n/*\n * 'write_image()' - Write an image to the given output file...\n */\n\nstatic void\nwrite_image(FILE     *out,\t\t/* I - Output file */\n            render_t *r,\t\t/* I - Image to write */\n\t    int      write_obj)\t\t/* I - Write an object? */\n{\n  int\t\ti, j, k, m,\t\t/* Looping vars */\n\t\tncolors;\t\t/* Number of colors */\n  uchar\t\t*pixel,\t\t\t/* Current pixel */\n\t\t*indices,\t\t/* New indexed pixel array */\n\t\t*indptr;\t\t/* Current index */\n  int\t\tindwidth,\t\t/* Width of indexed line */\n\t\tindbits;\t\t/* Bits per index */\n  int\t\tmax_colors;\t\t/* Max colors to use */\n  unsigned\tcolors[256],\t\t/* Colormap values */\n\t\tkey,\t\t\t/* Color key */\n\t\t*match;\t\t\t/* Matching color value */\n  uchar\t\tgrays[256],\t\t/* Grayscale usage */\n\t\tcmap[256][3];\t\t/* Colormap */\n  image_t \t*img;\t\t\t/* Image */\n  struct jpeg_compress_struct cinfo;\t/* JPEG compressor */\n  uchar\t\t*data,\t\t\t/* PS Level 3 image data */\n\t\t*dataptr,\t\t/* Pointer into image data */\n\t\t*maskptr;\t\t/* Pointer into mask data */\n\n\n /*\n  * See if we can optimize the image as indexed without color loss...\n  */\n\n  img      = r->data.image;\n  ncolors  = 0;\n  indices  = NULL;\n  indwidth = 0;\n\n  if (!img->pixels && !img->obj)\n    image_load(img->filename, !OutputColor, 1);\n\n  // Note: Acrobat 6 tries to decrypt the colormap of indexed in-line images twice, which\n  //       is 1) not consistent with prior Acrobat releases and 2) in violation of their\n  //       PDF spec.  The \"img->use > 1 || !Encryption\" test prevents the use of indexed\n  //       in-line images when encryption is enabled.\n  //\n  //       We are filing a bug on this with Adobe, but if history is any indicator, we are\n  //       stuck with this workaround forever...\n  if (PSLevel != 1 && PDFVersion >= 12 && img->obj == 0 && (img->use > 1 || !Encryption))\n  {\n    if (img->depth == 1)\n    {\n     /*\n      * Greyscale image...\n      */\n\n      memset(grays, 0, sizeof(grays));\n\n      for (i = img->width * img->height, pixel = img->pixels;\n\t   i > 0;\n\t   i --, pixel ++)\n\tif (!grays[*pixel])\n\t{\n          if (ncolors >= 16)\n\t    break;\n\n\t  grays[*pixel] = 1;\n\t  ncolors ++;\n\t}\n\n      if (i == 0)\n      {\n\tfor (i = 0, j = 0; i < 256; i ++)\n\t  if (grays[i])\n\t  {\n\t    colors[j] = (unsigned)((((i << 8) | i) << 8) | i);\n\t    grays[i]  = (uchar)j;\n\t    j ++;\n\t  }\n      }\n      else\n        ncolors = 0;\n    }\n    else\n    {\n     /*\n      * Color image...\n      */\n\n      if (OutputJPEG && !Compression)\n        max_colors = 16;\n      else\n        max_colors = 256;\n\n      for (i = img->width * img->height, pixel = img->pixels, match = NULL;\n\t   i > 0;\n\t   i --, pixel += 3)\n      {\n        key = (unsigned)((((pixel[0] << 8) | pixel[1]) << 8) | pixel[2]);\n\n\tif (!match || *match != key)\n\t{\n          if (ncolors > 0)\n            match = (unsigned *)bsearch(&key, colors, (size_t)ncolors, sizeof(unsigned), (compare_func_t)compare_rgb);\n          else\n            match = NULL;\n        }\n\n        if (match == NULL)\n        {\n          if (ncolors >= max_colors)\n            break;\n\n          colors[ncolors] = key;\n          ncolors ++;\n\n          if (ncolors > 1)\n            qsort(colors, (size_t)ncolors, sizeof(unsigned), (compare_func_t)compare_rgb);\n        }\n      }\n\n      if (i > 0)\n        ncolors = 0;\n    }\n  }\n\n  if (ncolors > 0)\n  {\n    if (PSLevel == 3 && img->mask)\n      indbits = 8;\n    else if (ncolors <= 2)\n      indbits = 1;\n    else if (ncolors <= 4)\n      indbits = 2;\n    else if (ncolors <= 16)\n      indbits = 4;\n    else\n      indbits = 8;\n\n    indwidth = (img->width * indbits + 7) / 8;\n    indices  = (uchar *)calloc((size_t)indwidth, (size_t)(img->height + 1));\n\t\t\t\t\t// height + 1 for PS odd-row-count bug\n\n    if (img->depth == 1)\n    {\n     /*\n      * Convert a grayscale image...\n      */\n\n      switch (indbits)\n      {\n        case 1 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width, k = 7; j > 0; j --, k = (k + 7) & 7, pixel ++)\n\t\tswitch (k)\n\t\t{\n\t\t  case 7 :\n\t              *indptr = (uchar)(grays[*pixel] << 7);\n\t\t      break;\n\t\t  default :\n\t              *indptr |= (uchar)(grays[*pixel] << k);\n\t\t      break;\n\t\t  case 0 :\n\t              *indptr++ |= (uchar)grays[*pixel];\n\t\t      break;\n        \t}\n\n\t      if (k != 7)\n\t\tindptr ++;\n\t    }\n\t    break;\n\n        case 2 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width, k = 0; j > 0; j --, k = (k + 1) & 3, pixel ++)\n\t\tswitch (k)\n\t\t{\n\t\t  case 0 :\n\t              *indptr = (uchar)(grays[*pixel] << 6);\n\t\t      break;\n\t\t  case 1 :\n\t              *indptr |= (uchar)(grays[*pixel] << 4);\n\t\t      break;\n\t\t  case 2 :\n\t              *indptr |= (uchar)(grays[*pixel] << 2);\n\t\t      break;\n\t\t  case 3 :\n\t              *indptr++ |= (uchar)grays[*pixel];\n\t\t      break;\n        \t}\n\n\t      if (k)\n\t\tindptr ++;\n\t    }\n\t    break;\n\n        case 4 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width, k = 0; j > 0; j --, k ^= 1, pixel ++)\n\t\tif (k)\n\t\t  *indptr++ |= grays[*pixel];\n\t\telse\n\t\t  *indptr = (uchar)(grays[*pixel] << 4);\n\n\t      if (k)\n\t\tindptr ++;\n\t    }\n\t    break;\n      }\n    }\n    else\n    {\n     /*\n      * Convert a color image...\n      */\n\n      switch (indbits)\n      {\n        case 1 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices,\n\t             match = colors;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width, k = 7;\n\t           j > 0;\n\t\t   j --, k = (k + 7) & 7, pixel += 3)\n\t      {\n                key = (unsigned)((((pixel[0] << 8) | pixel[1]) << 8) | pixel[2]);\n\n\t\tif (*match != key)\n        \t  match = (unsigned *)bsearch(&key, colors, (size_t)ncolors, sizeof(unsigned), (compare_func_t)compare_rgb);\n\t        m = match - colors;\n\n\t\tswitch (k)\n\t\t{\n\t\t  case 7 :\n\t              *indptr = (uchar)(m << 7);\n\t\t      break;\n\t\t  default :\n\t              *indptr |= (uchar)(m << k);\n\t\t      break;\n\t\t  case 0 :\n\t              *indptr++ |= (uchar)m;\n\t\t      break;\n        \t}\n\t      }\n\n\t      if (k != 7)\n\t        indptr ++;\n\t    }\n\t    break;\n\n        case 2 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices,\n\t             match = colors;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width, k = 0;\n\t           j > 0;\n\t\t   j --, k = (k + 1) & 3, pixel += 3)\n\t      {\n                key = (unsigned)((((pixel[0] << 8) | pixel[1]) << 8) | pixel[2]);\n\n\t\tif (*match != key)\n        \t  match = (unsigned *)bsearch(&key, colors, (size_t)ncolors, sizeof(unsigned), (compare_func_t)compare_rgb);\n\t        m = match - colors;\n\n\t\tswitch (k)\n\t\t{\n\t\t  case 0 :\n\t              *indptr = (uchar)(m << 6);\n\t\t      break;\n\t\t  case 1 :\n\t              *indptr |= (uchar)(m << 4);\n\t\t      break;\n\t\t  case 2 :\n\t              *indptr |= (uchar)(m << 2);\n\t\t      break;\n\t\t  case 3 :\n\t              *indptr++ |= (uchar)m;\n\t\t      break;\n        \t}\n\t      }\n\n\t      if (k)\n\t        indptr ++;\n\t    }\n\t    break;\n\n        case 4 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices,\n\t             match = colors;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width, k = 0; j > 0; j --, k ^= 1, pixel += 3)\n\t      {\n                key = (unsigned)((((pixel[0] << 8) | pixel[1]) << 8) | pixel[2]);\n\n\t\tif (*match != key)\n        \t  match = (unsigned *)bsearch(&key, colors, (size_t)ncolors, sizeof(unsigned), (compare_func_t)compare_rgb);\n\t        m = match - colors;\n\n\t\tif (k)\n\t\t  *indptr++ |= (uchar)m;\n\t\telse\n\t\t  *indptr = (uchar)(m << 4);\n\t      }\n\n\t      if (k)\n\t        indptr ++;\n\t    }\n\t    break;\n\n        case 8 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices,\n\t             match = colors;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width; j > 0; j --, pixel += 3, indptr ++)\n\t      {\n                key = (unsigned)((((pixel[0] << 8) | pixel[1]) << 8) | pixel[2]);\n\n\t\tif (*match != key)\n        \t  match = (unsigned *)bsearch(&key, colors, (size_t)ncolors, sizeof(unsigned), (compare_func_t)compare_rgb);\n\t        *indptr = (uchar)(match - colors);\n\t      }\n\t    }\n\t    break;\n      }\n    }\n  }\n  else\n    indbits = 8;\n\n  if (ncolors == 1)\n  {\n   /*\n    * Adobe doesn't like 1 color images...\n    */\n\n    ncolors   = 2;\n    colors[1] = 0;\n  }\n\n /*\n  * Now write the image...\n  */\n\n  switch (PSLevel)\n  {\n    case 0 : /* PDF */\n        if (!write_obj)\n\t  flate_printf(out, \"q %.1f 0 0 %.1f %.1f %.1f cm\\n\", r->width, r->height,\n\t               r->x, r->y);\n\n        if (img->obj)\n\t{\n\t  if (img->mask && PDFVersion < 13)\n\t    write_imagemask(out, r);\n\n\t  flate_printf(out, \"/I%d Do Q\\n\", img->obj);\n\t  break;\n\t}\n\n        if (img->mask && write_obj && PDFVersion >= 13)\n\t{\n\t  // We have a mask image, write it!\n          pdf_start_object(out);\n\t  fputs(\"/Type/XObject/Subtype/Image\", out);\n          fputs(\"/ColorSpace/DeviceGray\", out);\n\t  if (img->maskscale == 8)\n\t    fprintf(out, \"/Width %d/Height %d/BitsPerComponent 8\",\n\t            img->width, img->height);\n          else\n\t    fprintf(out, \"/Width %d/Height %d/BitsPerComponent 1/ImageMask true\",\n\t            img->width * img->maskscale, img->height * img->maskscale);\n          if (Compression)\n            fputs(\"/Filter/FlateDecode\", out);\n\n          pdf_start_stream(out);\n          flate_open_stream(out);\n\t  if (img->maskscale == 8)\n  \t    flate_write(out, img->mask, img->width * img->height);\n\t  else\n  \t    flate_write(out, img->mask,\n\t                img->maskwidth * img->height * img->maskscale);\n\t  flate_close_stream(out);\n\n          pdf_end_object(out);\n\t}\n\n        if (write_obj)\n\t{\n\t  // Write an image object...\n\t  img->obj = pdf_start_object(out);\n\n\t  fputs(\"/Type/XObject/Subtype/Image\", out);\n\t  if (img->mask && PDFVersion >= 13)\n\t  {\n\t    if (img->maskscale == 8)\n\t      fprintf(out, \"/SMask %d 0 R\", img->obj - 1);\n\t    else\n\t      fprintf(out, \"/Mask %d 0 R\", img->obj - 1);\n\t  }\n\n\t  if (ncolors > 0)\n\t  {\n\t    for (i = 0; i < ncolors; i ++)\n\t    {\n\t      cmap[i][0] = (uchar)(colors[i] >> 16);\n\t      cmap[i][1] = (uchar)(colors[i] >> 8);\n\t      cmap[i][2] = (uchar)colors[i];\n\t    }\n\n\t    if (Encryption)\n\t    {\n\t      // Encrypt the colormap...\n\t      encrypt_init();\n\t      rc4_encrypt(&encrypt_state, cmap[0], cmap[0], (unsigned)(ncolors * 3));\n\t    }\n\n\t    fprintf(out, \"/ColorSpace[/Indexed/DeviceRGB %d<\", ncolors - 1);\n\t    for (i = 0; i < ncolors; i ++)\n\t      fprintf(out, \"%02X%02X%02X\", cmap[i][0], cmap[i][1],\n\t              cmap[i][2]);\n\t    fputs(\">]\", out);\n          }\n\t  else if (img->depth == 1)\n            fputs(\"/ColorSpace/DeviceGray\", out);\n          else\n            fputs(\"/ColorSpace/DeviceRGB\", out);\n\n#ifdef HTMLDOC_INTERPOLATION\n          if (ncolors != 2)\n            fputs(\"/Interpolate true\", out);\n#endif // HTMLDOC_INTERPOLATION\n\n          if (Compression && (ncolors || !OutputJPEG))\n            fputs(\"/Filter/FlateDecode\", out);\n\t  else if (OutputJPEG && ncolors == 0)\n\t  {\n\t    if (Compression)\n\t      fputs(\"/Filter[/FlateDecode/DCTDecode]\", out);\n\t    else\n\t      fputs(\"/Filter/DCTDecode\", out);\n\t  }\n\n  \t  fprintf(out, \"/Width %d/Height %d/BitsPerComponent %d\",\n\t          img->width, img->height, indbits);\n          pdf_start_stream(out);\n          flate_open_stream(out);\n\n          if (OutputJPEG && ncolors == 0)\n\t  {\n\t    jpg_setup(out, img, &cinfo);\n\n\t    for (i = img->height, pixel = img->pixels;\n\t         i > 0;\n\t         i --, pixel += img->width * img->depth)\n\t      jpeg_write_scanlines(&cinfo, &pixel, 1);\n\n\t    jpeg_finish_compress(&cinfo);\n\t    jpeg_destroy_compress(&cinfo);\n\t  }\n          else\n\t  {\n\t    if (ncolors > 0)\n   \t      flate_write(out, indices, indwidth * img->height);\n\t    else\n  \t      flate_write(out, img->pixels,\n\t                  img->width * img->height * img->depth);\n          }\n\n          flate_close_stream(out);\n          pdf_end_object(out);\n\t}\n\telse\n\t{\n\t  // Put the image in-line...\n          flate_puts(\"BI\", out);\n\n\t  if (ncolors > 0)\n\t  {\n\t    flate_printf(out, \"/CS[/I/RGB %d<\", ncolors - 1);\n\t    for (i = 0; i < ncolors; i ++)\n\t      flate_printf(out, \"%02X%02X%02X\", colors[i] >> 16,\n\t        \t   (colors[i] >> 8) & 255, colors[i] & 255);\n\t    flate_puts(\">]\", out);\n          }\n\t  else if (img->depth == 1)\n            flate_puts(\"/CS/G\", out);\n          else\n            flate_puts(\"/CS/RGB\", out);\n\n          if (ncolors != 2)\n            flate_puts(\"/I true\", out);\n\n  \t  flate_printf(out, \"/W %d/H %d/BPC %d\", img->width, img->height, indbits);\n\n\t  if (ncolors > 0)\n\t  {\n  \t    flate_puts(\" ID\\n\", out);\n  \t    flate_write(out, indices, indwidth * img->height, 1);\n\t  }\n\t  else if (OutputJPEG)\n\t  {\n  \t    flate_puts(\"/F/DCT ID\\n\", out);\n\n\t    jpg_setup(out, img, &cinfo);\n\n\t    for (i = img->height, pixel = img->pixels;\n\t         i > 0;\n\t         i --, pixel += img->width * img->depth)\n\t      jpeg_write_scanlines(&cinfo, &pixel, 1);\n\n\t    jpeg_finish_compress(&cinfo);\n\t    jpeg_destroy_compress(&cinfo);\n          }\n\t  else\n\t  {\n  \t    flate_puts(\" ID\\n\", out);\n  \t    flate_write(out, img->pixels, img->width * img->height * img->depth, 1);\n          }\n\n\t  flate_write(out, (uchar *)\"\\nEI\\nQ\\n\", 6, 1);\n\t}\n        break;\n\n    case 1 : /* PostScript, Level 1 */\n        fputs(\"GS\", out);\n\tfprintf(out, \"[%.1f 0 0 %.1f %.1f %.1f]CM\", r->width, r->height,\n\t        r->x, r->y);\n\n\tif (img->mask)\n\t  write_imagemask(out, r);\n\n\tfprintf(out, \"/picture %d string def\\n\", img->width * img->depth);\n\n\tif (img->depth == 1)\n\t  fprintf(out, \"%d %d 8 [%d 0 0 %d 0 %d] {currentfile picture readhexstring pop} image\\n\",\n        \t  img->width, img->height,\n        \t  img->width, -img->height,\n        \t  img->height);\n\telse\n\t  fprintf(out, \"%d %d 8 [%d 0 0 %d 0 %d] {currentfile picture readhexstring pop} false 3 colorimage\\n\",\n        \t  img->width, img->height,\n        \t  img->width, -img->height,\n        \t  img->height);\n\n\tps_hex(out, img->pixels, img->width * img->height * img->depth);\n\n\tfputs(\"GR\\n\", out);\n        break;\n    case 3 : /* PostScript, Level 3 */\n        // Fallthrough to Level 2 output if compression is disabled and\n\t// we aren't doing transparency...\n        if ((Compression && (!OutputJPEG || ncolors > 0)) ||\n\t    (img->mask && img->maskscale == 8))\n\t{\n          fputs(\"GS\", out);\n\t  fprintf(out, \"[%.1f 0 0 %.1f %.1f %.1f]CM\", r->width, r->height,\n\t          r->x, r->y);\n\n\t  if (img->mask && img->maskscale != 8)\n\t    write_imagemask(out, r);\n\n          if (ncolors > 0)\n          {\n\t    if (ncolors <= 2)\n\t      ncolors = 2; /* Adobe doesn't like 1 color images... */\n\n\t    fprintf(out, \"[/Indexed/DeviceRGB %d\\n<\", ncolors - 1);\n\t    for (i = 0; i < ncolors; i ++)\n\t    {\n\t      fprintf(out, \"%02X%02X%02X\", colors[i] >> 16,\n\t              (colors[i] >> 8) & 255, colors[i] & 255);\n\t      if ((i % 13) == 12)\n\t        putc('\\n', out);\n            }\n\t    fputs(\">]setcolorspace\\n\", out);\n\n\t    if (img->mask && img->maskscale == 8)\n\t      fprintf(out, \"<<\"\n\t                   \"/ImageType 3\"\n\t\t\t   \"/InterleaveType 1\"\n\t\t\t   \"/MaskDict<<\"\n\t                   \"/ImageType 1\"\n\t                   \"/Width %d\"\n\t                   \"/Height %d\"\n\t                   \"/BitsPerComponent 8\"\n\t                   \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t\t\t   \"/Decode[0 1]\"\n\t                   \">>\\n\"\n\t\t\t   \"/DataDict\",\n\t            img->width, img->height,\n        \t    img->width, -img->height, img->height);\n\n\t    fprintf(out, \"<<\"\n\t                 \"/ImageType 1\"\n\t                 \"/Width %d\"\n\t                 \"/Height %d\"\n\t                 \"/BitsPerComponent %d\"\n\t                 \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t                 \"/Decode[0 %d]\",\n\t            img->width, img->height, indbits,\n        \t    img->width, -img->height, img->height,\n        \t    (1 << indbits) - 1);\n\n#ifdef HTMLDOC_INTERPOLATION\n            if (ncolors != 2)\n\t      fputs(\"/Interpolate true\", out);\n#endif // HTMLDOC_INTERPOLATION\n\n#ifdef HTMLDOC_ASCII85\n            fputs(\"/DataSource currentfile/ASCII85Decode filter\", out);\n#else\n            fputs(\"/DataSource currentfile/ASCIIHexDecode filter\", out);\n#endif // HTMLDOC_ASCII85\n\n            if (Compression)\n\t      fputs(\"/FlateDecode filter\", out);\n\n\t    fputs(\">>\\n\", out);\n\n\t    if (img->mask && img->maskscale == 8)\n\t      fputs(\">>\\n\", out);\n\n\t    fputs(\"image\\n\", out);\n\n            flate_open_stream(out);\n\n\t    if (img->mask && img->maskscale == 8)\n\t    {\n\t      data = (uchar *)malloc((size_t)(img->width * 2));\n\n\t      for (i = 0, maskptr = img->mask, indptr = indices;\n\t           i < img->height;\n\t\t   i ++)\n\t      {\n\t        for (j = img->width, dataptr = data; j > 0; j --)\n\t\t{\n\t\t  *dataptr++ = *maskptr++;\n\t\t  *dataptr++ = *indptr++;\n\t\t}\n\n\t\tflate_write(out, data, img->width * 2);\n\t      }\n\n\t      free(data);\n\t    }\n\t    else\n\t      flate_write(out, indices, indwidth * img->height);\n\n\t    flate_close_stream(out);\n          }\n          else\n          {\n\t    if (img->depth == 1)\n\t      fputs(\"/DeviceGray setcolorspace\", out);\n\t    else\n\t      fputs(\"/DeviceRGB setcolorspace\", out);\n\n\t    if (img->mask && img->maskscale == 8)\n\t      fprintf(out, \"<<\"\n\t                   \"/ImageType 3\"\n\t\t\t   \"/InterleaveType 1\"\n\t\t\t   \"/MaskDict<<\"\n\t                   \"/ImageType 1\"\n\t                   \"/Width %d\"\n\t                   \"/Height %d\"\n\t                   \"/BitsPerComponent 8\"\n\t                   \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t\t\t   \"/Decode[0 1]\"\n\t                   \">>\\n\"\n\t\t\t   \"/DataDict\",\n\t            img->width, img->height,\n        \t    img->width, -img->height, img->height);\n\n\t    fprintf(out, \"<<\"\n\t                 \"/ImageType 1\"\n\t                 \"/Width %d\"\n\t                 \"/Height %d\"\n\t                 \"/BitsPerComponent 8\"\n\t                 \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t                 \"/Decode[%s]\",\n\t            img->width, img->height,\n        \t    img->width, -img->height, img->height,\n        \t    img->depth == 1 ? \"0 1\" : \"0 1 0 1 0 1\");\n\n#ifdef HTMLDOC_INTERPOLATION\n\t    fputs(\"/Interpolate true\", out);\n#endif // HTMLDOC_INTERPOLATION\n\n#ifdef HTMLDOC_ASCII85\n            fputs(\"/DataSource currentfile/ASCII85Decode filter\", out);\n#else\n            fputs(\"/DataSource currentfile/ASCIIHexDecode filter\", out);\n#endif // HTMLDOC_ASCII85\n\n            if (Compression)\n\t      fputs(\"/FlateDecode filter\", out);\n\n\t    fputs(\">>\\n\", out);\n\n\t    if (img->mask && img->maskscale == 8)\n\t      fputs(\">>\\n\", out);\n\n\t    fputs(\"image\\n\", out);\n\n            flate_open_stream(out);\n\n\t    if (img->mask && img->maskscale == 8)\n\t    {\n\t      data = (uchar *)malloc((size_t)(img->width * (img->depth + 1)));\n\n\t      for (i = 0, maskptr = img->mask, pixel = img->pixels;\n\t           i < img->height;\n\t\t   i ++)\n\t      {\n\t        if (img->depth == 1)\n\t\t{\n\t          for (j = img->width, dataptr = data; j > 0; j --)\n\t\t  {\n\t\t    *dataptr++ = *maskptr++;\n\t\t    *dataptr++ = *pixel++;\n\t\t  }\n\t\t}\n\t\telse\n\t\t{\n\t          for (j = img->width, dataptr = data; j > 0; j --)\n\t\t  {\n\t\t    *dataptr++ = *maskptr++;\n\t\t    *dataptr++ = *pixel++;\n\t\t    *dataptr++ = *pixel++;\n\t\t    *dataptr++ = *pixel++;\n\t\t  }\n\t\t}\n\n\t\tflate_write(out, data, img->width * (img->depth + 1));\n\t      }\n\n\t      free(data);\n\t    }\n\t    else\n\t      flate_write(out, img->pixels,\n\t                  img->width * img->height * img->depth);\n\n\t    flate_close_stream(out);\n          }\n\n\t  fputs(\"GR\\n\", out);\n          break;\n\t}\n\n    case 2 : /* PostScript, Level 2 */\n        fputs(\"GS\", out);\n\tfprintf(out, \"[%.1f 0 0 %.1f %.1f %.1f]CM\", r->width, r->height,\n\t        r->x, r->y);\n\n\tif (img->mask)\n\t  write_imagemask(out, r);\n\n        if (ncolors > 0)\n        {\n\t  fprintf(out, \"[/Indexed/DeviceRGB %d\\n<\", ncolors - 1);\n\t  for (i = 0; i < ncolors; i ++)\n\t  {\n\t    fprintf(out, \"%02X%02X%02X\", colors[i] >> 16,\n\t            (colors[i] >> 8) & 255, colors[i] & 255);\n\t    if ((i % 13) == 12)\n\t      putc('\\n', out);\n          }\n\n\t  fputs(\">]setcolorspace\\n\", out);\n\n\t  fprintf(out, \"<<\"\n\t               \"/ImageType 1\"\n\t               \"/Width %d\"\n\t               \"/Height %d\"\n\t               \"/BitsPerComponent %d\"\n\t               \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t               \"/Decode[0 %d]\",\n\t          img->width, img->height, indbits,\n        \t  img->width, -img->height, img->height,\n        \t  (1 << indbits) - 1);\n\n#ifdef HTMLDOC_INTERPOLATION\n          if (ncolors != 2)\n\t    fputs(\"/Interpolate true\", out);\n#endif // HTMLDOC_INTERPOLATION\n\n#ifdef HTMLDOC_ASCII85\n\t  fputs(\"/DataSource currentfile/ASCII85Decode filter>>image\\n\", out);\n\n          ps_ascii85(out, indices, indwidth * img->height, 1);\n#else\n\t  fputs(\"/DataSource currentfile/ASCIIHexDecode filter>>image\\n\", out);\n\n          ps_hex(out, indices, indwidth * img->height);\n\t  // End of data marker...\n\t  fputs(\">\\n\", out);\n#endif /* HTMLDOC_ASCII85 */\n        }\n\telse if (OutputJPEG)\n\t{\n\t  if (img->depth == 1)\n\t    fputs(\"/DeviceGray setcolorspace\\n\", out);\n\t  else\n\t    fputs(\"/DeviceRGB setcolorspace\\n\", out);\n\n\t  fprintf(out, \"<<\"\n\t               \"/ImageType 1\"\n\t               \"/Width %d\"\n\t               \"/Height %d\"\n\t               \"/BitsPerComponent 8\"\n\t               \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t               \"/Decode[%s]\",\n\t          img->width, img->height,\n        \t  img->width, -img->height, img->height,\n        \t  img->depth == 1 ? \"0 1\" : \"0 1 0 1 0 1\");\n\n#ifdef HTMLDOC_INTERPOLATION\n\t  fputs(\"/Interpolate true\", out);\n#endif // HTMLDOC_INTERPOLATION\n\n#ifdef HTMLDOC_ASCII85\n\t  fputs(\"/DataSource currentfile/ASCII85Decode filter/DCTDecode filter\"\n\t        \">>image\\n\", out);\n#else\n\t  fputs(\"/DataSource currentfile/ASCIIHexDecode filter/DCTDecode filter\"\n\t        \">>image\\n\", out);\n#endif // HTMLDOC_ASCII85\n\n\t  jpg_setup(out, img, &cinfo);\n\n\t  for (i = img->height, pixel = img->pixels;\n\t       i > 0;\n\t       i --, pixel += img->width * img->depth)\n\t    jpeg_write_scanlines(&cinfo, &pixel, 1);\n\n\t  jpeg_finish_compress(&cinfo);\n\t  jpeg_destroy_compress(&cinfo);\n\n#ifdef HTMLDOC_ASCII85\n          ps_ascii85(out, (uchar *)\"\", 0, 1);\n#else\n\t  // End of data marker...\n\t  fputs(\">\\n\", out);\n#endif // HTMLDOC_ASCII85\n        }\n        else\n        {\n\t  if (img->depth == 1)\n\t    fputs(\"/DeviceGray setcolorspace\\n\", out);\n\t  else\n\t    fputs(\"/DeviceRGB setcolorspace\\n\", out);\n\n\t  fprintf(out, \"<<\"\n\t               \"/ImageType 1\"\n\t               \"/Width %d\"\n\t               \"/Height %d\"\n\t               \"/BitsPerComponent 8\"\n\t               \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t               \"/Decode[%s]\",\n\t          img->width, img->height,\n        \t  img->width, -img->height, img->height,\n        \t  img->depth == 1 ? \"0 1\" : \"0 1 0 1 0 1\");\n\n#ifdef HTMLDOC_INTERPOLATION\n\t  fputs(\"/Interpolate true\", out);\n#endif // HTMLDOC_INTERPOLATION\n\n#ifdef HTMLDOC_ASCII85\n          fputs(\"/DataSource currentfile/ASCII85Decode filter\"\n\t        \">>image\\n\", out);\n\n\t  ps_ascii85(out, img->pixels, img->width * img->height *\n\t                               img->depth, 1);\n#else\n          fputs(\"/DataSource currentfile/ASCIIHexDecode filter\"\n\t        \">>image\\n\", out);\n\n          ps_hex(out, img->pixels, img->width * img->depth * img->height);\n\t  // End of data marker...\n\t  fputs(\">\\n\", out);\n#endif // HTMLDOC_ASCII85\n        }\n\n\tfputs(\"GR\\n\", out);\n        break;\n  }\n\n  if (ncolors > 0)\n    free(indices);\n\n  image_unload(img);\n}\n\n\n/*\n * 'write_imagemask()' - Write an imagemask to the output file...\n */\n\nstatic void\nwrite_imagemask(FILE     *out,\t\t/* I - Output file */\n                render_t *r)\t\t/* I - Image to write */\n{\n  image_t\t*img;\t\t\t/* Current image */\n  int\t\tx, y;\t\t\t/* Position in mask image */\n  int\t\tstartx, count;\t\t/* Start and count */\n  uchar\t\t*ptr,\t\t\t/* Pointer into mask image */\n\t\tbyte,\t\t\t/* Current byte */\n\t\tbit;\t\t\t/* Current bit */\n  float\t\tscalex, scaley;\t\t/* 1/(w-1) and 1/(h-1) scaling factors */\n  int\t\twidth, height;\t\t/* Scaled width and height */\n\n\n  img    = r->data.image;\n  width  = img->width * img->maskscale;\n  height = img->height * img->maskscale;\n  scalex = 1.0f / width;\n  scaley = 1.0f / height;\n\n  switch (PSLevel)\n  {\n    case 0 : // PDF\n        break;\n\n    default : // PostScript\n        fputs(\"\\nnewpath\\n\", out);\n        break;\n  }\n\n  for (y = 0; y < height; y ++)\n  {\n    for (x = 0, ptr = img->mask + (height - y - 1) * img->maskwidth,\n             bit = 128, byte = *ptr++, startx = 0, count = 0;\n         x < width;\n\t x ++)\n    {\n      if (!(bit & byte))\n      {\n        if (!count)\n\t  startx = x;\n\n        count ++;\n      }\n      else if (count)\n      {\n\tswitch (PSLevel)\n\t{\n\t  case 0 : // PDF\n\t      flate_printf(out, \"%.6f %.6f %.6f %.6f re\\n\",\n\t\t\t   (float)startx * scalex,\n\t\t\t   (float)y * scaley,\n\t\t\t   (float)count * scalex,\n\t\t\t   1.0f * scaley);\n              break;\n\n\t  default : // PostScript\n\t      fprintf(out, \"%.6f %.6f %.6f %.6f re\\n\",\n\t\t      (float)startx * scalex,\n\t\t      (float)y * scaley,\n\t\t      (float)count * scalex,\n\t\t      1.0f * scaley);\n              break;\n\t}\n\n\tcount = 0;\n      }\n\n      if (bit > 1)\n        bit >>= 1;\n      else\n      {\n        bit  = 128;\n\tbyte = *ptr++;\n      }\n    }\n\n    if (count)\n    {\n      switch (PSLevel)\n      {\n\tcase 0 : // PDF\n\t    flate_printf(out, \"%.6f %.6f %.6f %.6f re\\n\",\n\t\t\t (float)startx * scalex,\n\t\t\t (float)y * scaley,\n\t\t\t (float)count * scalex,\n\t\t\t 1.0f * scaley);\n            break;\n\n\tdefault : // PostScript\n\t    fprintf(out, \"%.6f %.6f %.6f %.6f re\\n\",\n\t\t    (float)startx * scalex,\n\t\t    (float)y * scaley,\n\t\t    (float)count * scalex,\n\t\t    1.0f * scaley);\n            break;\n      }\n    }\n  }\n\n  switch (PSLevel)\n  {\n    case 0 : // PDF\n        flate_puts(\"W n\\n\", out);\n        break;\n\n    default : // PostScript\n        fputs(\"clip\\n\", out);\n        break;\n  }\n}\n\n\n/*\n * 'write_prolog()' - Write the file prolog...\n */\n\nstatic void\nwrite_prolog(FILE  *out,\t\t/* I - Output file */\n             int   page_count,\t\t/* I - Number of pages (0 if not known) */\n             uchar *author,\t\t/* I - Author of document */\n             uchar *creator,\t\t/* I - Application that generated the HTML file */\n             uchar *copyright,\t\t/* I - Copyright (if any) on the document */\n             uchar *keywords,\t\t/* I - Search keywords */\n\t     uchar *subject)\t\t/* I - Subject */\n{\n  FILE\t\t*prolog;\t\t/* PostScript prolog file */\n  int\t\ti, j,\t\t\t/* Looping vars */\n\t\tencoding_object;\t/* Font encoding object */\n  int\t\tpage;\t\t\t/* Current page */\n  render_t\t*r;\t\t\t/* Current render data */\n  int\t\tfonts_used[TYPE_MAX][STYLE_MAX];\n\t\t\t\t\t/* Whether or not a font is used */\n  int\t\tfont_desc[TYPE_MAX][STYLE_MAX];\n\t\t\t\t\t/* Font descriptor objects */\n  char\t\ttemp[1024];\t\t/* Temporary string */\n  md5_state_t\tmd5;\t\t\t/* MD5 state */\n  md5_byte_t\tdigest[16];\t\t/* MD5 digest value */\n  rc4_context_t\trc4;\t\t\t/* RC4 context */\n  uchar\t\towner_pad[32],\t\t/* Padded owner password */\n\t\towner_key[32],\t\t/* Owner key */\n\t\tuser_pad[32],\t\t/* Padded user password */\n\t\tuser_key[32];\t\t/* User key */\n  uchar\t\tperm_bytes[4];\t\t/* Permission bytes */\n  unsigned\tperm_value;\t\t/* Permission value, unsigned */\n  static unsigned char pad[32] =\n\t\t{\t\t\t/* Padding for passwords */\n\t\t  0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41,\n\t\t  0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08,\n\t\t  0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80,\n\t\t  0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a\n\t\t};\n\n\n /*\n  * See what fonts are used...\n  */\n\n  memset(fonts_used, 0, sizeof(fonts_used));\n  fonts_used[HeadFootType][HeadFootStyle] = 1;\n\n  for (page = 0; page < (int)num_pages; page ++)\n    for (r = pages[page].start; r != NULL; r = r->next)\n      if (r->type == RENDER_TEXT)\n\tfonts_used[r->data.text.typeface][r->data.text.style] = 1;\n\n#ifdef DEBUG\n  puts(\"The following fonts were used:\");\n  for (i = 0; i < TYPE_MAX; i ++)\n    for (j = 0; j < STYLE_MAX; j ++)\n      if (fonts_used[i][j])\n        printf(\"    %s\\n\", _htmlFonts[i][j]);\n#endif // DEBUG\n\n /*\n  * Generate the heading...\n  */\n\n  if (PSLevel > 0)\n  {\n   /*\n    * Write PostScript prolog stuff...\n    */\n\n    if (XRXComments)\n    {\n      int start, end;\t// Start and end of document pages...\n      int count;\t// Number of exception pages in this range...\n\n\n      // The following comments are Xerox job ticket information that\n      // is used on the high-end Laser Printing Systems rather than\n      // embedded commands...\n      fputs(\"%XRXbegin: 001.0300\\n\", out);\n      fputs(\"%XRXPDLformat: PS-Adobe\\n\", out);\n      if (doc_title)\n\tfprintf(out, \"%%XRXtitle: %s\\n\", doc_title);\n\n      if (OutputFiles)\n      {\n        // Output a single chapter...\n\tif (chapter < 0)\n\t{\n\t  start = 0;\n\t  end   = chapter_outstarts[1] - 1;\n\t}\n\telse\n\t{\n\t  start = chapter_outstarts[chapter];\n\t  end   = chapter_outends[chapter];\n\t}\n      }\n      else\n      {\n        start = 0;\n\tend   = 0;\n      }\n\n      if (pages[outpages[start].pages[0]].duplex)\n      {\n\tif (pages[outpages[start].pages[0]].landscape)\n\t  fputs(\"%XRXrequirements: duplex(tumble)\\n\", out);\n\telse\n\t  fputs(\"%XRXrequirements: duplex\\n\", out);\n      }\n      else\n\tfputs(\"%XRXrequirements: simplex\\n\", out);\n\n      fputs(\"%XRXdisposition: PRINT\\n\", out);\n      fputs(\"%XRXsignature: False\\n\", out);\n      fprintf(out, \"%%XRXpaperType-size: %.0f %.0f\\n\",\n              pages[outpages[start].pages[0]].width * 25.4f / 72.0f,\n              pages[outpages[start].pages[0]].length * 25.4f / 72.0f);\n      if (pages[outpages[start].pages[0]].media_type[0])\n\tfprintf(out, \"%%XRXpaperType-preFinish: %s 0 0\\n\",\n        \tpages[start].media_type);\n      if (pages[outpages[start].pages[0]].media_color[0])\n\tfprintf(out, \"%%XRXdocumentPaperColors: %c%s\\n\",\n        \ttolower(pages[start].media_color[0]),\n\t\tpages[start].media_color + 1);\n\n      if (OutputFiles)\n      {\n        // Handle document settings per-chapter...\n\tfor (i = start + 1; i < end; i += count)\n\t{\n\t  if (pages[outpages[i].pages[0]].width != pages[0].width ||\n\t      pages[outpages[i].pages[0]].length != pages[0].length ||\n\t      strcmp(pages[outpages[i].pages[0]].media_type,\n\t             pages[0].media_type) != 0 ||\n\t      strcmp(pages[outpages[i].pages[0]].media_color,\n\t             pages[0].media_color) != 0 ||\n\t      pages[outpages[i].pages[0]].duplex != pages[0].duplex)\n\t  {\n\t    for (count = 1; (i + count) <= end; count ++)\n\t      if (pages[outpages[i].pages[0]].width !=\n\t              pages[outpages[i + count].pages[0]].width ||\n\t\t  pages[outpages[i].pages[0]].length !=\n\t\t      pages[outpages[i + count].pages[0]].length ||\n\t\t  strcmp(pages[outpages[i].pages[0]].media_type,\n\t\t         pages[outpages[i + count].pages[0]].media_type) != 0 ||\n\t\t  strcmp(pages[outpages[i].pages[0]].media_color,\n\t\t         pages[outpages[i + count].pages[0]].media_color) != 0 ||\n\t\t  pages[outpages[i].pages[0]].duplex !=\n\t\t      pages[outpages[i + count].pages[0]].duplex)\n\t\tbreak;\n\n\t    fprintf(out, \"%%XRXpageExceptions: %d %d %.0f %.0f %c%s opaque %s 0 0\\n\",\n\t            i + 1, i + count,\n\t\t    pages[outpages[i].pages[0]].width * 25.4f / 72.0f,\n\t\t    pages[outpages[i].pages[0]].length * 25.4f / 72.0f,\n\t\t    tolower(pages[outpages[i].pages[0]].media_color[0]),\n\t\t    pages[outpages[i].pages[0]].media_color + 1,\n\t\t    pages[outpages[i].pages[0]].media_type[0] ?\n\t\t        pages[outpages[i].pages[0]].media_type : \"Plain\");\n\n\t    if (pages[outpages[i].pages[0]].duplex &&\n\t        pages[outpages[i].pages[0]].landscape)\n\t      fprintf(out, \"%%XRXpageExceptions-plex: %d %d duplex(tumble)\\n\",\n\t              i + 1, i + count);\n\t    else if (pages[outpages[i].pages[0]].duplex)\n\t      fprintf(out, \"%%XRXpageExceptions-plex: %d %d duplex\\n\",\n\t              i + 1, i + count);\n            else\n\t      fprintf(out, \"%%XRXpageExceptions-plex: %d %d simplex\\n\",\n\t              i + 1, i + count);\n\t  }\n\t  else\n\t    count = 1;\n        }\n      }\n      else\n      {\n        // All pages are in a single file...\n        for (j = (TocLevels == 0); j <= TocDocCount; j ++)\n\t{\n\t  start = chapter_outstarts[j];\n\t  end   = chapter_outends[j];\n\n\t  for (i = start + 1; i < end; i += count)\n\t  {\n\t    if (pages[outpages[i].pages[0]].width != pages[0].width ||\n\t\tpages[outpages[i].pages[0]].length != pages[0].length ||\n\t\tstrcmp(pages[outpages[i].pages[0]].media_type,\n\t\t       pages[0].media_type) != 0 ||\n\t\tstrcmp(pages[outpages[i].pages[0]].media_color,\n\t\t       pages[0].media_color) != 0 ||\n\t\tpages[outpages[i].pages[0]].duplex != pages[0].duplex)\n\t    {\n\t      for (count = 1; (i + count) < end; count ++)\n\t\tif (pages[outpages[i].pages[0]].width !=\n\t\t        pages[outpages[i + count].pages[0]].width ||\n\t\t    pages[outpages[i].pages[0]].length !=\n\t\t        pages[outpages[i + count].pages[0]].length ||\n\t\t    strcmp(pages[outpages[i].pages[0]].media_type,\n\t\t           pages[outpages[i + count].pages[0]].media_type) != 0 ||\n\t\t    strcmp(pages[outpages[i].pages[0]].media_color,\n\t\t           pages[outpages[i + count].pages[0]].media_color) != 0 ||\n\t\t    pages[outpages[i].pages[0]].duplex !=\n\t\t        pages[outpages[i + count].pages[0]].duplex)\n\t\t  break;\n\n\t      fprintf(out, \"%%XRXpageExceptions: %d %d %.0f %.0f %c%s opaque %s 0 0\\n\",\n\t              i + 1, i + count,\n\t\t      pages[outpages[i].pages[0]].width * 25.4f / 72.0f,\n\t\t      pages[outpages[i].pages[0]].length * 25.4f / 72.0f,\n\t\t      tolower(pages[outpages[i].pages[0]].media_color[0]),\n\t\t      pages[outpages[i].pages[0]].media_color + 1,\n\t\t      pages[outpages[i].pages[0]].media_type[0] ?\n\t\t          pages[outpages[i].pages[0]].media_type : \"Plain\");\n\n\t      if (pages[outpages[i].pages[0]].duplex && pages[outpages[i].pages[0]].landscape)\n\t\tfprintf(out, \"%%XRXpageExceptions-plex: %d %d duplex(tumble)\\n\",\n\t        \ti + 1, i + count);\n\t      else if (pages[outpages[i].pages[0]].duplex)\n\t\tfprintf(out, \"%%XRXpageExceptions-plex: %d %d duplex\\n\",\n\t        \ti + 1, i + count);\n              else\n\t\tfprintf(out, \"%%XRXpageExceptions-plex: %d %d simplex\\n\",\n\t        \ti + 1, i + count);\n\t    }\n\t    else\n\t      count = 1;\n          }\n\t}\n      }\n\n      fputs(\"%XRXend\\n\", out);\n    }\n\n    fputs(\"%!PS-Adobe-3.0\\n\", out);\n    if (Landscape)\n      fprintf(out, \"%%%%BoundingBox: 0 0 %d %d\\n\", PageLength, PageWidth);\n    else\n      fprintf(out, \"%%%%BoundingBox: 0 0 %d %d\\n\", PageWidth, PageLength);\n    fprintf(out,\"%%%%LanguageLevel: %d\\n\", PSLevel);\n    fputs(\"%%Creator: \" HTMLDOC_PRODUCER \"\\n\", out);\n    fprintf(out, \"%%%%CreationDate: D:%04d%02d%02d%02d%02d%02d+0000\\n\",\n            doc_date.tm_year + 1900, doc_date.tm_mon + 1, doc_date.tm_mday,\n            doc_date.tm_hour, doc_date.tm_min, doc_date.tm_sec);\n    if (doc_title != NULL)\n      fprintf(out, \"%%%%Title: %s\\n\", doc_title);\n    if (author != NULL)\n      fprintf(out, \"%%%%Author: %s\\n\", author);\n    if (creator != NULL)\n      fprintf(out, \"%%%%Generator: %s\\n\", creator);\n    if (copyright != NULL)\n      fprintf(out, \"%%%%Copyright: %s\\n\", copyright);\n    if (keywords != NULL)\n      fprintf(out, \"%%%%Keywords: %s\\n\", keywords);\n    if (subject != NULL)\n      fprintf(out, \"%%%%Subject: %s\\n\", keywords);\n    if (page_count > 0)\n      fprintf(out, \"%%%%Pages: %d\\n\", page_count);\n    else\n      fputs(\"%%Pages: (atend)\\n\", out);\n\n    if (!EmbedFonts)\n    {\n      fputs(\"%%DocumentNeededResources:\\n\", out);\n\n      for (i = 0; i < TYPE_MAX; i ++)\n        for (j = 0; j < STYLE_MAX; j ++)\n          if (fonts_used[i][j] && _htmlStandardFonts[i])\n            fprintf(out, \"%%%%+ font %s\\n\", _htmlFonts[i][j]);\n    }\n\n    fputs(\"%%DocumentProvidedResources:\\n\", out);\n\n    for (i = 0; i < TYPE_MAX; i ++)\n      for (j = 0; j < STYLE_MAX; j ++)\n        if (fonts_used[i][j] && (EmbedFonts || !_htmlStandardFonts[i]))\n          fprintf(out, \"%%%%+ font %s\\n\", _htmlFonts[i][j]);\n    fputs(\"%%DocumentData: Clean7bit\\n\", out);\n    fputs(\"%%EndComments\\n\", out);\n\n    fputs(\"%%BeginProlog\\n\", out);\n\n   /*\n    * Embed fonts?\n    */\n\n    for (i = 0; i < TYPE_MAX; i ++)\n    {\n      if (EmbedFonts || !_htmlStandardFonts[i])\n\tfor (j = 0; j < STYLE_MAX; j ++)\n          if (fonts_used[i][j])\n\t    write_type1(out, (typeface_t)i, (style_t)j);\n    }\n\n   /*\n    * Procedures used throughout the document...\n    */\n\n    const char *version = SVERSION;\n\n    fprintf(out, \"%%%%BeginResource: procset htmldoc-page 1.8 %s\\n\", version + 4);\n    fputs(\"/BD{bind def}bind def\", out);\n    fputs(\"/B{dup 0 exch rlineto exch 0 rlineto neg 0 exch rlineto\\n\"\n          \"closepath stroke}BD\", out);\n    fputs(\"/C{setrgbcolor}BD\\n\", out);\n    fputs(\"/CM{concat}BD\", out);\n    fputs(\"/DF{findfont dup length dict begin{1 index/FID ne{def}{pop pop}\\n\"\n          \"ifelse}forall/Encoding fontencoding def currentdict end definefont pop}BD\\n\", out);\n    fputs(\"/F{dup 0 exch rlineto exch 0 rlineto neg 0 exch rlineto closepath fill}BD\\n\", out);\n    fputs(\"/FS{/hdFontSize exch def}BD\", out);\n    fputs(\"/G{setgray}BD\\n\", out);\n    fputs(\"/GS{gsave}BD\", out);\n    fputs(\"/GR{grestore}BD\", out);\n    fputs(\"/J{0 exch ashow}BD\\n\", out);\n    fputs(\"/L{0 rlineto stroke}BD\", out);\n    fputs(\"/M{moveto}BD\", out);\n    fputs(\"/re{4 2 roll moveto 1 index 0 rlineto 0 exch rlineto neg 0 rlineto closepath}BD\\n\", out);\n    fputs(\"/RO{rotate}BD\", out);\n    fputs(\"/S{show}BD\", out);\n    fputs(\"/SC{dup scale}BD\\n\", out);\n    fputs(\"/SF{findfont hdFontSize scalefont setfont}BD\", out);\n    fputs(\"/SP{showpage}BD\", out);\n    fputs(\"/T{translate}BD\\n\", out);\n    fputs(\"%%EndResource\\n\", out);\n\n   /*\n    * Output the font encoding for the current character set...  For now we\n    * just support 8-bit fonts since true Unicode support needs a very large\n    * number of extra fonts that aren't normally available on a PS printer.\n    */\n\n    fputs(\"/fontencoding[\\n\", out);\n    for (i = 0, j = 0; i < 256; i ++)\n    {\n      if (_htmlGlyphs[i])\n        j += strlen(_htmlGlyphs[i]) + 1;\n      else\n        j += 8;\n\n      if (j > 80)\n      {\n\tif (_htmlGlyphs[i])\n          j = strlen(_htmlGlyphs[i]) + 1;\n\telse\n          j = 8;\n\n        putc('\\n', out);\n      }\n\n      putc('/', out);\n      if (_htmlGlyphs[i])\n        fputs(_htmlGlyphs[i], out);\n      else\n        fputs(\".notdef\", out);\n    }\n\n    fputs(\"]def\\n\", out);\n\n   /*\n    * Fonts...\n    */\n\n    for (i = 0; i < TYPE_MAX; i ++)\n      for (j = 0; j < STYLE_MAX; j ++)\n        if (fonts_used[i][j])\n        {\n\t  if (i < TYPE_SYMBOL)\n\t    fprintf(out, \"/F%x/%s DF\\n\", i * 4 + j, _htmlFonts[i][j]);\n\t  else\n\t    fprintf(out, \"/F%x/%s findfont definefont pop\\n\", i * 4 + j,\n\t            _htmlFonts[i][j]);\n        }\n\n    if (PSCommands)\n    {\n      snprintf(temp, sizeof(temp), \"%s/data/prolog.ps\", _htmlData);\n      if ((prolog = fopen(temp, \"rb\")) != NULL)\n      {\n\twhile (fgets(temp, sizeof(temp), prolog) != NULL)\n          fputs(temp, out);\n\n\tfclose(prolog);\n      }\n      else\n      {\n\tprogress_error(HD_ERROR_FILE_NOT_FOUND,\n                       \"Unable to open data file \\\"%s\\\" - %s\", temp,\n                       strerror(errno));\n\n\tfprintf(out, \"%%%%BeginResource: procset htmldoc-device 1.8 %s\\n\", version + 4);\n\tfputs(\"languagelevel 1 eq{/setpagedevice{pop}BD}if\\n\", out);\n\tfputs(\"/SetDuplexMode{<</Duplex 3 index/Tumble 5 index>>setpagedevice \"\n              \"pop pop}BD\\n\", out);\n\tfputs(\"/SetMediaColor{pop}BD\\n\", out);\n\tfputs(\"/SetMediaType{pop}BD\\n\", out);\n\tfputs(\"/SetMediaPosition{pop}BD\\n\", out);\n\tfputs(\"/SetPageSize{2 array astore<</PageSize 2 index/ImageableArea \"\n              \"null>>setpagedevice pop}BD\\n\", out);\n\tfputs(\"%%EndResource\\n\", out);\n      }\n    }\n\n    if (background_image != NULL)\n      ps_write_background(out);\n\n    fputs(\"%%EndProlog\\n\", out);\n  }\n  else\n  {\n   /*\n    * Write PDF prolog stuff...\n    */\n\n    fprintf(out, \"%%PDF-%.1f\\n\", 0.1 * PDFVersion);\n    fputs(\"%\\342\\343\\317\\323\\n\", out);\n    num_objects = 0;\n\n   /*\n    * Compute the file ID...\n    */\n\n    md5_init(&md5);\n    md5_append(&md5, (md5_byte_t *)OutputPath, sizeof(OutputPath));\n    md5_append(&md5, (md5_byte_t *)&doc_time, sizeof(doc_time));\n    md5_finish(&md5, file_id);\n\n   /*\n    * Setup encryption stuff as necessary...\n    */\n\n    if (Encryption)\n    {\n     /*\n      * Copy and pad the user password...\n      */\n\n      strlcpy((char *)user_pad, UserPassword, sizeof(user_pad));\n\n      if ((i = strlen(UserPassword)) < 32)\n\tmemcpy(user_pad + i, pad, (size_t)(32 - i));\n\n      if (OwnerPassword[0])\n      {\n       /*\n        * Copy and pad the owner password...\n\t*/\n\n        strlcpy((char *)owner_pad, OwnerPassword, sizeof(owner_pad));\n\n\tif ((i = strlen(OwnerPassword)) < 32)\n\t  memcpy(owner_pad + i, pad, (size_t)(32 - i));\n      }\n      else\n      {\n       /*\n        * Generate a pseudo-random owner password...\n\t*/\n\n\tsrand(time(NULL));\n\n\tfor (i = 0; i < 32; i ++)\n\t  owner_pad[i] = (uchar)rand();\n      }\n\n     /*\n      * What is the key length?\n      *\n      * Acrobat 4.0 and earlier (PDF 1.3 and earlier) allow a maximum of\n      * 40-bits.  Acrobat 5.0 and newer support 128-bits.\n      */\n\n      if (PDFVersion > 13)\n        encrypt_len = 16;\t// 128 bits\n      else\n        encrypt_len = 5;\t// 40 bits\n\n     /*\n      * Compute the owner key...\n      */\n\n      md5_init(&md5);\n      md5_append(&md5, owner_pad, 32);\n      md5_finish(&md5, digest);\n\n      if (encrypt_len > 5)\n      {\n        // MD5 the result 50 more times...\n\tfor (i = 0; i < 50; i ++)\n\t{\n          md5_init(&md5);\n          md5_append(&md5, digest, 16);\n          md5_finish(&md5, digest);\n\t}\n\n        // Copy the padded user password...\n        memcpy(owner_key, user_pad, 32);\n\n        // Encrypt the result 20 times...\n\tfor (i = 0; i < 20; i ++)\n\t{\n\t  // XOR each byte in the key with the loop counter...\n\t  for (j = 0; j < encrypt_len; j ++)\n\t    encrypt_key[j] = (uchar)(digest[j] ^ i);\n\n          rc4_init(&rc4, encrypt_key, (size_t)encrypt_len);\n          rc4_encrypt(&rc4, owner_key, owner_key, 32);\n\t}\n      }\n      else\n      {\n        rc4_init(&rc4, digest, (size_t)encrypt_len);\n        rc4_encrypt(&rc4, user_pad, owner_key, 32);\n      }\n\n     /*\n      * Figure out the permissions word; the new N-bit security\n      * handler adds several new permission bits, which we must\n      * simulate...\n      */\n\n      perm_value = (unsigned)Permissions;\n\n      if (encrypt_len > 5)\n      {\n        // N-bit encryption...\n\tif (!(perm_value & PDF_PERM_COPY))\n\t  perm_value &= (unsigned)~0x00240000;\t// Mask additional copy perms...\n      }\n\n     /*\n      * Compute the encryption key...\n      */\n\n      md5_init(&md5);\n      md5_append(&md5, user_pad, 32);\n      md5_append(&md5, owner_key, 32);\n\n      perm_bytes[0] = (uchar)perm_value;\n      perm_bytes[1] = (uchar)(perm_value >> 8);\n      perm_bytes[2] = (uchar)(perm_value >> 16);\n      perm_bytes[3] = (uchar)(perm_value >> 24);\n\n      md5_append(&md5, perm_bytes, 4);\n      md5_append(&md5, file_id, 16);\n      md5_finish(&md5, digest);\n\n      if (encrypt_len > 5)\n      {\n        // MD5 the result 50 times..\n        for (i = 0; i < 50; i ++)\n\t{\n\t  md5_init(&md5);\n\t  md5_append(&md5, digest, 16);\n\t  md5_finish(&md5, digest);\n\t}\n      }\n\n      memcpy(encrypt_key, digest, (size_t)encrypt_len);\n\n     /*\n      * Compute the user key...\n      */\n\n      if (encrypt_len > 5)\n      {\n        md5_init(&md5);\n        md5_append(&md5, pad, 32);\n        md5_append(&md5, file_id, 16);\n        md5_finish(&md5, user_key);\n\n        memset(user_key + 16, 0, 16);\n\n        // Encrypt the result 20 times...\n        for (i = 0; i < 20; i ++)\n\t{\n\t  // XOR each byte in the key with the loop counter...\n\t  for (j = 0; j < encrypt_len; j ++)\n\t    digest[j] = (uchar)(encrypt_key[j] ^ i);\n\n          rc4_init(&rc4, digest, (size_t)encrypt_len);\n          rc4_encrypt(&rc4, user_key, user_key, 16);\n\t}\n      }\n      else\n      {\n        rc4_init(&rc4, encrypt_key, (size_t)encrypt_len);\n        rc4_encrypt(&rc4, pad, user_key, 32);\n      }\n\n     /*\n      * Write the encryption dictionary...\n      */\n\n      encrypt_object = pdf_start_object(out);\n\n      fputs(\"/Filter/Standard/O<\", out);\n      for (i = 0; i < 32; i ++)\n        fprintf(out, \"%02x\", owner_key[i]);\n      fputs(\">/U<\", out);\n      for (i = 0; i < 32; i ++)\n        fprintf(out, \"%02x\", user_key[i]);\n      fputs(\">\", out);\n\n      if (encrypt_len > 5)\n      {\n        // N-bit encryption...\n        fprintf(out, \"/P %d/V 2/R 3/Length %d\", (int)perm_value, encrypt_len * 8);\n      }\n      else\n        fprintf(out, \"/P %d/V 1/R 2\", (int)perm_value);\n\n      pdf_end_object(out);\n    }\n    else\n      encrypt_object = 0;\n\n   /*\n    * Write info object...\n    */\n\n    info_object = pdf_start_object(out);\n\n    fputs(\"/Producer\", out);\n    write_string(out, (uchar *)HTMLDOC_PRODUCER, 0);\n    fputs(\"/CreationDate\", out);\n    snprintf(temp, sizeof(temp), \"D:%04d%02d%02d%02d%02d%02d+0000\",\n            doc_date.tm_year + 1900, doc_date.tm_mon + 1, doc_date.tm_mday,\n            doc_date.tm_hour, doc_date.tm_min, doc_date.tm_sec);\n    write_string(out, (uchar *)temp, 0);\n\n    if (doc_title != NULL)\n    {\n      fputs(\"/Title\", out);\n      write_utf16(out, doc_title);\n    }\n\n    if (author != NULL || copyright != NULL)\n    {\n      if (author && copyright)\n        snprintf(temp, sizeof(temp), \"%s, %s\", author, copyright);\n      else if (author)\n        strlcpy(temp, (const char *)author, sizeof(temp));\n      else\n        strlcpy(temp, (const char *)copyright, sizeof(temp));\n\n      fputs(\"/Author\", out);\n      write_utf16(out, (uchar *)temp);\n    }\n\n    if (creator != NULL)\n    {\n      fputs(\"/Creator\", out);\n      write_utf16(out, creator);\n    }\n\n    if (keywords != NULL)\n    {\n      fputs(\"/Keywords\", out);\n      write_utf16(out, keywords);\n    }\n\n    if (subject != NULL)\n    {\n      fputs(\"/Subject\", out);\n      write_utf16(out, subject);\n    }\n\n    pdf_end_object(out);\n\n   /*\n    * Write the font encoding for the selected character set.  Note that\n    * we *should* be able to use the WinAnsiEncoding value for ISO-8859-1\n    * to make smaller files, however Acrobat Exchange does not like it\n    * despite the fact that it is defined in the PDF specification...\n    */\n\n    encoding_object = pdf_start_object(out);\n\n    fputs(\"/Type/Encoding\", out);\n    fputs(\"/Differences[\", out);\n    for (i = 0, j = -1; i < 256; i ++)\n      if (_htmlGlyphs[i])\n      {\n       /*\n        * Output a character index if we had blank ones...\n\t*/\n\n        if (j != (i - 1))\n\t  fprintf(out, \" %d\", i);\n\n        fprintf(out, \"/%s\", _htmlGlyphs[i]);\n\tj = i;\n      }\n\n    fputs(\"]\", out);\n    pdf_end_object(out);\n\n    memset(font_desc, 0, sizeof(font_desc));\n\n   /*\n    * Build font descriptors for the EmbedFonts fonts...\n    */\n\n    for (i = 0; i < TYPE_MAX; i ++)\n      if (EmbedFonts || !_htmlStandardFonts[i])\n\tfor (j = 0; j < STYLE_MAX; j ++)\n          if (fonts_used[i][j])\n\t    font_desc[i][j] = write_type1(out, (typeface_t )i, (style_t)j);\n\n    for (i = 0; i < TYPE_MAX; i ++)\n      for (j = 0; j < STYLE_MAX; j ++)\n        if (fonts_used[i][j])\n        {\n\t  font_objects[i * STYLE_MAX + j] = pdf_start_object(out);\n\n\t  fputs(\"/Type/Font\", out);\n\t  fputs(\"/Subtype/Type1\", out);\n\t  fprintf(out, \"/BaseFont/%s\", _htmlFonts[i][j]);\n\n          if (font_desc[i][j])\n\t  {\n\t    // Embed Type1 font...\n\t    fputs(\"/FirstChar 0\", out);\n\t    fputs(\"/LastChar 255\", out);\n\t    fprintf(out, \"/Widths %d 0 R\", font_desc[i][j] + 1);\n\t    fprintf(out, \"/FontDescriptor %d 0 R\", font_desc[i][j]);\n\t  }\n\n\t  if (i < TYPE_SYMBOL) /* Use native encoding for symbols */\n\t    fprintf(out, \"/Encoding %d 0 R\", encoding_object);\n\n          pdf_end_object(out);\n        }\n  }\n}\n\n\n/*\n * 'write_string()' - Write a text entity.\n */\n\nstatic void\nwrite_string(FILE  *out,\t\t/* I - Output file */\n             uchar *s,\t\t\t/* I - String */\n\t     int   compress)\t\t/* I - Compress output? */\n{\n  int\ti;\t\t\t\t/* Looping var */\n\n\n  if (Encryption && !compress && PSLevel == 0)\n  {\n    int\t\tlen,\t\t\t// Length of string\n\t\tbytes;\t\t\t// Current bytes encrypted\n    uchar\tnews[1024];\t\t// New string\n\n\n   /*\n    * Write an encrypted string...\n    */\n\n    putc('<', out);\n    encrypt_init();\n\n    for (len = strlen((char *)s); len > 0; len -= bytes, s += bytes)\n    {\n      if (len > (int)sizeof(news))\n        bytes = (int)sizeof(news);\n      else\n        bytes = len;\n\n      rc4_encrypt(&encrypt_state, s, news, (size_t)bytes);\n\n      for (i = 0; i < bytes; i ++)\n        fprintf(out, \"%02x\", news[i]);\n    }\n\n    putc('>', out);\n  }\n  else\n  {\n    uchar nbsp = 160;\t\t\t// Non-breaking space char\n\n    if (compress)\n      flate_write(out, (uchar *)\"(\", 1);\n    else\n      putc('(', out);\n\n    if (_htmlUTF8)\n      nbsp = _htmlCharacters[160];\n\n    while (*s != '\\0')\n    {\n      if (*s == nbsp)\n      {\n       /* &nbsp; */\n\tif (compress)\n\t  flate_write(out, (uchar *)\" \", 1);\n\telse\n\t  putc(' ', out);\n      }\n      else if (*s < 32 || *s > 126)\n      {\n\tif (compress)\n\t  flate_printf(out, \"\\\\%o\", *s);\n\telse\n\t  fprintf(out, \"\\\\%o\", *s);\n      }\n      else if (compress)\n      {\n\tif (*s == '(' || *s == ')' || *s == '\\\\')\n\t  flate_write(out, (uchar *)\"\\\\\", 1);\n\n\tflate_write(out, s, 1);\n      }\n      else\n      {\n\tif (*s == '(' || *s == ')' || *s == '\\\\')\n\t  putc('\\\\', out);\n\n\tputc(*s, out);\n      }\n\n      s ++;\n    }\n\n    if (compress)\n      flate_write(out, (uchar *)\")\", 1);\n    else\n      putc(')', out);\n  }\n}\n\n\n/*\n * 'write_text()' - Write a text entity.\n */\n\nstatic void\nwrite_text(FILE     *out,\t/* I - Output file */\n           render_t *r)\t\t/* I - Text entity */\n{\n  uchar\t*ptr;\t\t\t/* Pointer into text */\n\n\n  // Quick optimization - don't output spaces...\n  for (ptr = r->data.text.buffer; *ptr; ptr ++)\n    if (!isspace(*ptr) && *ptr != 0xa0)\n      break;\n\n  if (!*ptr)\n    return;\n\n  // Not just whitespace - send it out...\n  set_color(out, r->data.text.rgb);\n  set_font(out, r->data.text.typeface, r->data.text.style, r->data.text.size);\n  set_pos(out, r->x, r->y);\n\n  if (PSLevel > 0)\n  {\n    if (r->data.text.spacing > 0.0f)\n      fprintf(out, \" %.3f\", r->data.text.spacing);\n  }\n  else if (r->data.text.spacing != render_spacing)\n    flate_printf(out, \" %.3f Tc\", render_spacing = r->data.text.spacing);\n\n  write_string(out, r->data.text.buffer, PSLevel == 0);\n\n  if (PSLevel > 0)\n  {\n    if (r->data.text.spacing > 0.0f)\n      fputs(\"J\\n\", out);\n    else\n      fputs(\"S\\n\", out);\n  }\n  else\n    flate_puts(\"Tj\\n\", out);\n\n  render_x += r->width;\n}\n\n\n/*\n * 'write_trailer()' - Write the file trailer.\n */\n\nstatic void\nwrite_trailer(FILE  *out,\t\t/* I - Output file */\n              int   num_file_pages,\t/* I - Number of pages in file */\n\t      uchar *lang)\t\t/* I - Language */\n{\n  int\t\ti, j, k,\t\t/* Looping vars */\n\t\ttype,\t\t\t/* Type of number */\n\t\toffset,\t\t\t/* Offset to xref table in PDF file */\n\t\tstart;\t\t\t/* Start page number */\n  page_t\t*page;\t\t\t/* Start page of chapter */\n  char\t\tprefix[64],\t\t/* Prefix string */\n\t\t*prefptr;\t\t/* Pointer into prefix string */\n  static const char *modes[] =\t\t/* Page modes */\n\t\t{\n\t\t  \"UseNone\",\n\t\t  \"UseOutlines\",\n\t\t  \"FullScreen\"\n\t\t};\n  static const char *layouts[] =\t/* Page layouts */\n\t\t{\n\t\t  \"SinglePage\",\n\t\t  \"OneColumn\",\n\t\t  \"TwoColumnLeft\",\n\t\t  \"TwoColumnRight\"\n\t\t};\n\n\n  if (PSLevel > 0)\n  {\n   /*\n    * PostScript...\n    */\n\n    fputs(\"%%Trailer\\n\", out);\n    if (num_file_pages > 0)\n      fprintf(out, \"%%%%Pages: %d\\n\", num_file_pages);\n\n    fputs(\"%%EOF\\n\", out);\n  }\n  else\n  {\n   /*\n    * PDF...\n    */\n\n    root_object = pdf_start_object(out);\n\n    fputs(\"/Type/Catalog\", out);\n    fprintf(out, \"/Pages %d 0 R\", pages_object);\n\n    if (PDFVersion >= 12)\n    {\n      if (names_object)\n        fprintf(out, \"/Names %d 0 R\", names_object);\n\n      fprintf(out, \"/PageLayout/%s\", layouts[PDFPageLayout]);\n    }\n\n    if (lang)\n      fprintf(out, \"/Lang(%s)\", (char *)lang);\n\n    if (outline_object > 0)\n      fprintf(out, \"/Outlines %d 0 R\", outline_object);\n\n    switch (PDFFirstPage)\n    {\n      case PDF_PAGE_1 :\n          if (TitlePage)\n\t  {\n            fprintf(out, \"/OpenAction[%d 0 R/XYZ null null 0]\",\n                    pages_object + 1);\n            break;\n\t  }\n          break;\n      case PDF_TOC :\n          if (TocLevels > 0)\n\t  {\n            fprintf(out, \"/OpenAction[%d 0 R/XYZ null null 0]\",\n                    pages_object + 2 * chapter_outstarts[0] + 1);\n\t    break;\n\t  }\n          break;\n      case PDF_CHAPTER_1 :\n          fprintf(out, \"/OpenAction[%d 0 R/XYZ null null 0]\",\n                  pages_object + 2 * chapter_outstarts[1] + 1);\n          break;\n    }\n\n    fprintf(out, \"/PageMode/%s\", modes[PDFPageMode]);\n\n    if (PDFVersion > 12 && NumberUp == 1)\n    {\n      // Output the PageLabels tree...\n      fputs(\"/PageLabels<</Nums[\", out);\n\n      for (i = 0; i < chapter_starts[1]; i ++)\n      {\n        fprintf(out, \"%d<</P\", i);\n        if (i & 1)\n\t  write_string(out, (uchar *)\"eltit\", 0);\n\telse\n\t  write_string(out, (uchar *)\"title\", 0);\n\tfputs(\">>\", out);\n      }\n\n      if (TocLevels > 0 && OutputType == OUTPUT_BOOK)\n      {\n        type = 'r';\n\n        for (j = 0; j < 3; j ++)\n\t  if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(1)\")) ||\n\t      (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(1)\")))\n\t    type = 'D';\n\t  else if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(I)\")) ||\n\t           (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(I)\")))\n\t    type = 'R';\n\t  else if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(a)\")) ||\n\t           (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(a)\")))\n\t    type = 'a';\n\t  else if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(A)\")) ||\n\t           (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(A)\")))\n\t    type = 'A';\n\n        fprintf(out, \"%d<</S/%c>>\", i, type);\n\n        i += chapter_ends[0] - chapter_starts[0] + 1;\n      }\n\n      for (j = 1; j <= TocDocCount; j ++)\n      {\n        page  = pages + chapter_starts[j];\n\tstart = chapter_starts[j] - chapter_starts[1] + 1;\n\ttype  = 'D';\n\n        prefix[0] = '\\0';\n\n\tfor (k = 0; k < 3; k ++)\n\t{\n\t  if (page->header[k] && strstr((char *)page->header[k], \"PAGE\"))\n\t    strlcpy(prefix, (char *)page->header[k], sizeof(prefix));\n\t  else if (page->footer[k] && strstr((char *)page->footer[k], \"PAGE\"))\n\t    strlcpy(prefix, (char *)page->footer[k], sizeof(prefix));\n\n\t  if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(i)\")) ||\n\t      (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(i)\")))\n\t    type = 'r';\n\t  else if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(I)\")) ||\n\t           (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(I)\")))\n\t    type = 'R';\n\t  else if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(a)\")) ||\n\t           (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(a)\")))\n\t    type = 'a';\n\t  else if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(A)\")) ||\n\t           (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(A)\")))\n\t    type = 'A';\n\n\t  if ((page->header[k] && strstr((char *)page->header[k], \"$CHAPTERPAGE\")) ||\n\t      (page->footer[k] && strstr((char *)page->footer[k], \"$CHAPTERPAGE\")))\n\t    start = 1;\n        }\n\n        if ((prefptr = strstr(prefix, \"$PAGE\")) == NULL)\n\t  prefptr = strstr(prefix, \"$CHAPTERPAGE\");\n\tfprintf(out, \"%d<</S/%c/St %d\", i, type, start);\n\tif (prefptr)\n\t{\n\t  *prefptr = '\\0';\n\t  fputs(\"/P\", out);\n\t  write_string(out, (uchar *)prefix, 0);\n\t}\n\tfputs(\">>\", out);\n\n        i += chapter_ends[j] - chapter_starts[j] + 1;\n      }\n\n      fputs(\"]>>\", out);\n    }\n\n    pdf_end_object(out);\n\n    offset = ftell(out);\n\n    fputs(\"xref\\n\", out);\n    fprintf(out, \"0 %d \\n\", (int)num_objects + 1);\n    fputs(\"0000000000 65535 f \\n\", out);\n    for (i = 1; i <= (int)num_objects; i ++)\n      fprintf(out, \"%010d 00000 n \\n\", objects[i]);\n\n    fputs(\"trailer\\n\", out);\n    fputs(\"<<\", out);\n    fprintf(out, \"/Size %d\", (int)num_objects + 1);\n    fprintf(out, \"/Root %d 0 R\", root_object);\n    fprintf(out, \"/Info %d 0 R\", info_object);\n    fputs(\"/ID[<\", out);\n    for (i = 0; i < 16; i ++)\n      fprintf(out, \"%02x\", file_id[i]);\n    fputs(\"><\", out);\n    for (i = 0; i < 16; i ++)\n      fprintf(out, \"%02x\", file_id[i]);\n    fputs(\">]\", out);\n\n    if (Encryption)\n      fprintf(out, \"/Encrypt %d 0 R\", encrypt_object);\n\n    fputs(\">>\\n\", out);\n    fputs(\"startxref\\n\", out);\n    fprintf(out, \"%d\\n\", offset);\n    fputs(\"%%EOF\\n\", out);\n  }\n}\n\n\n/*\n * 'write_type1()' - Write an embedded Type 1 font.\n */\n\nstatic int\t\t\t\t/* O - Object number */\nwrite_type1(FILE       *out,\t\t/* I - File to write to */\n            typeface_t typeface,\t/* I - Typeface */\n\t    style_t    style)\t\t/* I - Style */\n{\n  char\t\tfilename[1024];\t\t/* PFA filename */\n  FILE\t\t*fp;\t\t\t/* PFA file */\n  int\t\tch;\t\t\t/* Character value */\n  int\t\twidth;\t\t\t/* Width value */\n  char\t\tglyph[64],\t\t/* Glyph name */\n\t\tline[1024],\t\t/* Line from AFM file */\n\t\t*lineptr,\t\t/* Pointer into line */\n\t\t*dataptr;\t\t/* Pointer for data */\n  int\t\tascent,\t\t\t/* Ascent above baseline */\n\t\tcap_height,\t\t/* Ascent of CAPITALS */\n\t\tx_height,\t\t/* Ascent of lowercase */\n\t\tdescent,\t\t/* Decent below baseline */\n\t\tbbox[4],\t\t/* Bounding box */\n\t\titalic_angle;\t\t/* Angle for italics */\n  int\t\twidths[256];\t\t/* Character widths */\n  int\t\tlength1,\t\t/* Length1 value for font */\n\t\tlength2,\t\t/* Length2 value for font */\n\t\tlength3;\t\t/* Length3 value for font */\n  static int\ttflags[] =\t\t/* PDF typeface flags */\n\t\t{\n\t\t  33,\t\t\t/* Courier */\n\t\t  34,\t\t\t/* Times-Roman */\n\t\t  32,\t\t\t/* Helvetica */\n\t\t  33,\t\t\t/* Monospace */\n\t\t  34,\t\t\t/* Serif */\n\t\t  32,\t\t\t/* Sans */\n\t\t  4,\t\t\t/* Symbol */\n\t\t  4\t\t\t/* Dingbats */\n\t\t};\n  static int\tsflags[] =\t\t/* PDF style flags */\n\t\t{\n\t\t  0,\t\t\t/* Normal */\n\t\t  0,\t\t\t/* Bold */\n\t\t  64,\t\t\t/* Italic */\n\t\t  64\t\t\t/* Bold-Italic */\n\t\t};\n\n\n /*\n  * This function writes a Type1 font, either as an object for PDF\n  * output or as an in-line font in PostScript output.  This is useful\n  * because the Type1 fonts that Adobe ships typically do not include\n  * the full set of characters required by some of the ISO character\n  * sets.\n  */\n\n /*\n  * Try to open the PFA file for the Type1 font...\n  */\n\n  snprintf(filename, sizeof(filename), \"%s/fonts/%s.pfa\", _htmlData,\n           _htmlFonts[typeface][style]);\n  if ((fp = fopen(filename, \"r\")) == NULL)\n  {\n#ifndef DEBUG\n    progress_error(HD_ERROR_FILE_NOT_FOUND,\n                   \"Unable to open font file %s!\", filename);\n#endif /* !DEBUG */\n    return (0);\n  }\n\n /*\n  * Write the font (object)...\n  */\n\n  if (PSLevel)\n  {\n   /*\n    * Embed a Type1 font in the PostScript output...\n    */\n\n    fprintf(out, \"%%%%BeginResource: font %s\\n\", _htmlFonts[typeface][style]);\n\n    line[0] = '\\0';\n\n    while (fgets(line, sizeof(line), fp) != NULL)\n      fputs(line, out);\n\n    if (line[strlen(line) - 1] != '\\n')\n      fputs(\"\\n\", out);\n\n    fputs(\"%%EndResource\\n\", out);\n\n    fclose(fp);\n  }\n  else\n  {\n   /*\n    * Embed a Type1 font object in the PDF output...\n    */\n\n    length1 = 0;\n    length2 = 0;\n    length3 = 0;\n\n    while (fgets(line, sizeof(line), fp) != NULL)\n    {\n      length1 += strlen(line);\n      if (strstr(line, \"currentfile eexec\") != NULL)\n        break;\n    }\n\n    while (fgets(line, sizeof(line), fp) != NULL)\n    {\n      if (!strcmp(line, \"00000000000000000000000000000000\"\n                        \"00000000000000000000000000000000\\n\"))\n        break;\n\n      length2 += (strlen(line) - 1) / 2;\n    }\n\n    length3 = strlen(line);\n    while (fgets(line, sizeof(line), fp) != NULL)\n      length3 += strlen(line);\n\n    rewind(fp);\n\n    pdf_start_object(out);\n    fprintf(out, \"/Length1 %d\", length1);\n    fprintf(out, \"/Length2 %d\", length2);\n    fprintf(out, \"/Length3 %d\", length3);\n    if (Compression)\n      fputs(\"/Filter/FlateDecode\", out);\n    pdf_start_stream(out);\n    flate_open_stream(out);\n\n    while (fgets(line, sizeof(line), fp) != NULL)\n    {\n      flate_puts(line, out);\n\n      if (strstr(line, \"currentfile eexec\") != NULL)\n        break;\n    }\n\n    while (fgets(line, sizeof(line), fp) != NULL)\n    {\n      if (!strcmp(line, \"00000000000000000000000000000000\"\n                        \"00000000000000000000000000000000\\n\"))\n        break;\n\n      for (lineptr = line, dataptr = line; isxdigit(*lineptr); lineptr += 2)\n      {\n        if (isdigit(lineptr[0]))\n\t  ch = (lineptr[0] - '0') << 4;\n\telse\n\t  ch = (tolower(lineptr[0] & 255) - 'a' + 10) << 4;\n\n        if (isdigit(lineptr[1]))\n\t  ch |= lineptr[1] - '0';\n\telse\n\t  ch |= tolower(lineptr[1] & 255) - 'a' + 10;\n\n        *dataptr++ = (char)ch;\n      }\n\n      flate_write(out, (uchar *)line, dataptr - line);\n    }\n\n    flate_puts(line, out);\n    while (fgets(line, sizeof(line), fp) != NULL)\n      flate_puts(line, out);\n\n    flate_close_stream(out);\n\n    pdf_end_object(out);\n\n    fclose(fp);\n\n   /*\n    * Try to open the AFM file for the Type1 font...\n    */\n\n    snprintf(filename, sizeof(filename), \"%s/fonts/%s.afm\", _htmlData,\n             _htmlFonts[typeface][style]);\n    if ((fp = fopen(filename, \"r\")) == NULL)\n    {\n#ifndef DEBUG\n      progress_error(HD_ERROR_FILE_NOT_FOUND,\n                     \"Unable to open font width file %s!\", filename);\n#endif /* !DEBUG */\n      return (0);\n    }\n\n   /*\n    * Set the default values (Courier)...\n    */\n\n    for (ch = 0; ch < 256; ch ++)\n      widths[ch] = 600;\n\n    ascent       = 629;\n    cap_height   = 562;\n    x_height     = 426;\n    descent      = -157;\n    bbox[0]      = -28;\n    bbox[1]      = -250;\n    bbox[2]      = 628;\n    bbox[3]      = 805;\n    italic_angle = 0;\n\n   /*\n    * Read the AFM file...\n    */\n\n    while (fgets(line, sizeof(line), fp) != NULL)\n    {\n      if (strncmp(line, \"ItalicAngle \", 12) == 0)\n\titalic_angle = atoi(line + 12);\n      else if (strncmp(line, \"FontBBox \", 9) == 0)\n\tsscanf(line + 9, \"%d%d%d%d\", bbox + 0, bbox + 1, bbox + 2, bbox + 3);\n      else if (strncmp(line, \"CapHeight \", 10) == 0)\n\tcap_height = atoi(line + 10);\n      else if (strncmp(line, \"XHeight \", 8) == 0)\n\tx_height = atoi(line + 8);\n      else if (strncmp(line, \"Ascender \", 9) == 0)\n\tascent = atoi(line + 9);\n      else if (strncmp(line, \"Descender \", 10) == 0)\n\tdescent = atoi(line + 10);\n      else if (strncmp(line, \"C \", 2) == 0)\n      {\n\tif (typeface < TYPE_SYMBOL)\n\t{\n\t /*\n\t  * Handle encoding of Courier, Times, and Helvetica using\n\t  * assigned charset...\n\t  */\n\n\t  if (sscanf(line, \"%*s%*s%*s%*s%d%*s%*s%63s\", &width, glyph) != 2)\n\t    continue;\n\n\t  for (ch = 0; ch < 256; ch ++)\n\t    if (_htmlGlyphs[ch] && strcmp(_htmlGlyphs[ch], glyph) == 0)\n\t      break;\n\n\t  if (ch < 256)\n\t    widths[ch] = width;\n\t}\n\telse\n\t{\n\t /*\n\t  * Symbol font uses its own encoding...\n\t  */\n\n\t  if (sscanf(line, \"%*s%d%*s%*s%d\", &ch, &width) != 2)\n\t    continue;\n\n\t  if (ch >= 0 && ch < 256)\n\t    widths[ch] = width;\n\t}\n      }\n    }\n\n    fclose(fp);\n\n   /*\n    * Write the font descriptor...\n    */\n\n    pdf_start_object(out);\n    fputs(\"/Type/FontDescriptor\", out);\n    fprintf(out, \"/Ascent %d\", ascent);\n    fprintf(out, \"/Descent %d\", descent);\n    fprintf(out, \"/CapHeight %d\", cap_height);\n    fprintf(out, \"/XHeight %d\", x_height);\n    fprintf(out, \"/FontBBox[%d %d %d %d]\", bbox[0], bbox[1], bbox[2], bbox[3]);\n    fprintf(out, \"/ItalicAngle %d\", italic_angle);\n    fprintf(out, \"/StemV %d\", widths['v']);\n    fprintf(out, \"/Flags %d\", tflags[typeface] | sflags[style]);\n    fprintf(out, \"/FontName/%s\", _htmlFonts[typeface][style]);\n    fprintf(out, \"/FontFile %d 0 R\", (int)num_objects - 1);\n    pdf_end_object(out);\n\n   /*\n    * Write the character widths...\n    */\n\n    pdf_start_object(out, 1);\n    fprintf(out, \"%d\", widths[0]);\n    for (ch = 1; ch < 256; ch ++)\n      fprintf(out, \" %d\", widths[ch]);\n    pdf_end_object(out);\n  }\n\n /*\n  * Return the font descriptor...\n  */\n\n  return (num_objects - 1);\n}\n\n\n/*\n * 'write_utf16()' - Write a UTF-16 string...\n */\n\nstatic void\nwrite_utf16(FILE  *out,\t\t\t// I - File to write to\n            uchar *s)\t\t\t// I - String to write\n{\n  uchar *sptr;\t\t\t\t// Pointer into string\n\n\n /*\n  * We start by checking to see if the string is composed only of\n  * ASCII characters; if so, we can just write a normal string...\n  */\n\n  for (sptr = s; *sptr && !(*sptr & 0x80); sptr ++);\n  if (!*sptr)\n  {\n   /*\n    * Write an ASCII string...\n    */\n\n    write_string(out, s, 0);\n  }\n  else if (Encryption)\n  {\n   /*\n    * Convert the string to Unicode and encrypt...\n    */\n\n    int\t\tch;\t\t\t// Character value\n    uchar\tunicode[2],\t\t// Unicode character\n\t\tenicode[2];\t\t// Encrypted unicode character\n\n\n    putc('<', out);\n    encrypt_init();\n\n    unicode[0] = 0xfe;\t\t\t// Start with BOM\n    unicode[1] = 0xff;\n\n    rc4_encrypt(&encrypt_state, unicode, enicode, 2);\n\n    fprintf(out, \"%02x%02x\", enicode[0], enicode[1]);\n\n    for (sptr = s; *sptr; sptr ++)\n    {\n      ch         = _htmlUnicode[*sptr];\n      unicode[0] = (uchar)(ch >> 8);\n      unicode[1] = (uchar)ch;\n\n      rc4_encrypt(&encrypt_state, unicode, enicode, 2);\n\n      fprintf(out, \"%02x%02x\", enicode[0], enicode[1]);\n    }\n\n    putc('>', out);\n  }\n  else\n  {\n   /*\n    * Convert the string to Unicode...\n    */\n\n    fputs(\"<feff\", out);\t\t// Start with BOM\n    for (sptr = s; *sptr; sptr ++)\n      fprintf(out, \"%04x\", _htmlUnicode[*sptr]);\n    putc('>', out);\n  }\n}\n\n\n/*\n * 'encrypt_init()' - Initialize the RC4 encryption context for the current\n *                    object.\n */\n\nstatic void\nencrypt_init(void)\n{\n  int\t\ti;\t\t\t/* Looping var */\n  uchar\t\tdata[21],\t\t/* Key data */\n\t\t*dataptr;\t\t/* Pointer to key data */\n  md5_state_t\tmd5;\t\t\t/* MD5 state */\n  md5_byte_t\tdigest[16];\t\t/* MD5 digest value */\n\n\n /*\n  * Compute the key data for the MD5 hash.\n  */\n\n  for (i = 0, dataptr = data; i < encrypt_len; i ++)\n    *dataptr++ = encrypt_key[i];\n\n  *dataptr++ = (uchar)num_objects;\n  *dataptr++ = (uchar)(num_objects >> 8);\n  *dataptr++ = (uchar)(num_objects >> 16);\n  *dataptr++ = 0;\n  *dataptr++ = 0;\n\n /*\n  * Hash it...\n  */\n\n  md5_init(&md5);\n  md5_append(&md5, data, encrypt_len + 5);\n  md5_finish(&md5, digest);\n\n /*\n  * Initialize the RC4 context using the first N+5 bytes of the digest...\n  */\n\n  if (encrypt_len > 11)\n    rc4_init(&encrypt_state, digest, 16);\n  else\n    rc4_init(&encrypt_state, digest, (size_t)(encrypt_len + 5));\n}\n\n\n/*\n * 'flate_open_stream()' - Open a deflated output stream.\n */\n\nstatic void\nflate_open_stream(FILE *out)\t\t/* I - Output file */\n{\n  if (Encryption && !PSLevel)\n    encrypt_init();\n\n  if (!Compression)\n    return;\n\n  compressor_active = 1;\n  compressor.zalloc = (alloc_func)0;\n  compressor.zfree  = (free_func)0;\n  compressor.opaque = (voidpf)0;\n\n  deflateInit(&compressor, Compression);\n\n  compressor.next_out  = (Bytef *)comp_buffer;\n  compressor.avail_out = sizeof(comp_buffer);\n}\n\n\n/*\n * 'flate_close_stream()' - Close a deflated output stream.\n */\n\nstatic void\nflate_close_stream(FILE *out)\t\t/* I - Output file */\n{\n  int\tstatus;\t\t\t\t/* Deflate status */\n\n\n  if (!Compression)\n  {\n#ifdef HTMLDOC_ASCII85\n    if (PSLevel)\n      ps_ascii85(out, (uchar *)\"\", 0, 1);\n#endif // HTMLDOC_ASCII85\n\n    return;\n  }\n\n  while ((status = deflate(&compressor, Z_FINISH)) != Z_STREAM_END)\n  {\n    if (status < Z_OK && status != Z_BUF_ERROR)\n    {\n      progress_error(HD_ERROR_OUT_OF_MEMORY, \"deflate() failed (%d)\", status);\n      return;\n    }\n\n    if (PSLevel)\n#ifdef HTMLDOC_ASCII85\n      ps_ascii85(out, comp_buffer,\n                 (uchar *)compressor.next_out - (uchar *)comp_buffer);\n#else\n      ps_hex(out, comp_buffer,\n             (uchar *)compressor.next_out - (uchar *)comp_buffer);\n#endif // HTMLDOC_ASCII85\n    else\n    {\n      if (Encryption)\n        rc4_encrypt(&encrypt_state, comp_buffer, comp_buffer,\n\t            (uchar *)compressor.next_out - (uchar *)comp_buffer);\n\n      fwrite(comp_buffer, (size_t)((uchar *)compressor.next_out - (uchar *)comp_buffer), 1, out);\n    }\n\n    compressor.next_out  = (Bytef *)comp_buffer;\n    compressor.avail_out = sizeof(comp_buffer);\n  }\n\n  if ((uchar *)compressor.next_out > (uchar *)comp_buffer)\n  {\n    if (PSLevel)\n#ifdef HTMLDOC_ASCII85\n      ps_ascii85(out, comp_buffer,\n                 (uchar *)compressor.next_out - (uchar *)comp_buffer);\n#else\n      ps_hex(out, comp_buffer,\n             (uchar *)compressor.next_out - (uchar *)comp_buffer);\n#endif // HTMLDOC_ASCII85\n    else\n    {\n      if (Encryption)\n        rc4_encrypt(&encrypt_state, comp_buffer, comp_buffer,\n\t            (uchar *)compressor.next_out - (uchar *)comp_buffer);\n\n      fwrite(comp_buffer, (size_t)((uchar *)compressor.next_out - (uchar *)comp_buffer), 1, out);\n    }\n\n  }\n\n  deflateEnd(&compressor);\n\n  compressor_active = 0;\n\n#ifdef HTMLDOC_ASCII85\n  if (PSLevel)\n    ps_ascii85(out, (uchar *)\"\", 0, 1);\n#else\n  if (PSLevel)\n  {\n    // End of data marker...\n    fputs(\">\\n\", out);\n  }\n#endif // HTMLDOC_ASCII85\n}\n\n\n/*\n * 'flate_puts()' - Write a character string to a compressed stream.\n */\n\nstatic void\nflate_puts(const char *s,\t\t/* I - String to write */\n           FILE       *out)\t\t/* I - Output file */\n{\n  flate_write(out, (uchar *)s, strlen(s));\n}\n\n\n/*\n * 'flate_printf()' - Write a formatted character string to a compressed stream.\n */\n\nstatic void\nflate_printf(FILE       *out,\t\t/* I - Output file */\n             const char *format,\t/* I - Format string */\n             ...)\t\t\t/* I - Additional args as necessary */\n{\n  int\t\tlength;\t\t\t/* Length of output string */\n  char\t\tbuf[10240];\t\t/* Output buffer */\n  va_list\tap;\t\t\t/* Argument pointer */\n\n\n  va_start(ap, format);\n  length = vsnprintf(buf, sizeof(buf), format, ap);\n  va_end(ap);\n\n  flate_write(out, (uchar *)buf, length);\n}\n\n\n/*\n * 'flate_write()' - Write data to a compressed stream.\n */\n\nstatic void\nflate_write(FILE  *out,\t\t\t/* I - Output file */\n            uchar *buf,\t\t\t/* I - Buffer */\n            int   length,\t\t/* I - Number of bytes to write */\n\t    int   flush)\t\t/* I - Flush when writing data? */\n{\n  int\tstatus;\t\t\t\t/* Deflate status */\n\n\n  if (compressor_active)\n  {\n    compressor.next_in  = buf;\n    compressor.avail_in = (unsigned)length;\n\n    while (compressor.avail_in > 0)\n    {\n      if (compressor.avail_out < (int)(sizeof(comp_buffer) / 8))\n      {\n\tif (PSLevel)\n#ifdef HTMLDOC_ASCII85\n\t  ps_ascii85(out, comp_buffer,\n                     (uchar *)compressor.next_out - (uchar *)comp_buffer);\n#else\n\t  ps_hex(out, comp_buffer,\n                 (uchar *)compressor.next_out - (uchar *)comp_buffer);\n#endif // HTMLDOC_ASCII85\n\telse\n\t{\n\t  if (Encryption)\n            rc4_encrypt(&encrypt_state, comp_buffer, comp_buffer,\n\t        \t(uchar *)compressor.next_out - (uchar *)comp_buffer);\n\n\t  fwrite(comp_buffer, (size_t)((uchar *)compressor.next_out - (uchar *)comp_buffer), 1, out);\n\t}\n\n\tcompressor.next_out  = (Bytef *)comp_buffer;\n\tcompressor.avail_out = sizeof(comp_buffer);\n      }\n\n      status = deflate(&compressor, flush ? Z_FULL_FLUSH : Z_NO_FLUSH);\n\n      if (status < Z_OK && status != Z_BUF_ERROR)\n      {\n\tprogress_error(HD_ERROR_OUT_OF_MEMORY, \"deflate() failed (%d)\", status);\n\treturn;\n      }\n\n      flush = 0;\n    }\n  }\n  else if (Encryption && !PSLevel)\n  {\n    int\t\ti,\t\t// Looping var\n\t\tbytes;\t\t// Number of bytes to encrypt/write\n    uchar\tnewbuf[1024];\t// New encrypted data buffer\n\n\n    for (i = 0; i < length; i += sizeof(newbuf))\n    {\n      if ((bytes = length - i) > (int)sizeof(newbuf))\n        bytes = sizeof(newbuf);\n\n      rc4_encrypt(&encrypt_state, buf + i, newbuf, (size_t)bytes);\n      fwrite(newbuf, (size_t)bytes, 1, out);\n    }\n  }\n  else if (PSLevel)\n#ifdef HTMLDOC_ASCII85\n    ps_ascii85(out, buf, length);\n#else\n    ps_hex(out, buf, length);\n#endif // HTMLDOC_ASCII85\n  else\n    fwrite(buf, (size_t)length, 1, out);\n}\n"], "fixing_code": ["# Changes in HTMLDOC v1.9.12\n\n- Fixed a crash bug with \"data:\" URIs and EPUB output (Issue #410)\n- Fixed a crach bug with bogus table attributes (Issue #417)\n- Fixed a crash bug with malformed URIs (Issue #418)\n- Fixed a crash bug with malformed GIF files (Issue #423)\n- Fixed some issues reported by Coverity.\n\n\n# Changes in HTMLDOC v1.9.11\n\n- Added high-resolution desktop icons for Linux.\n- Updated the internal HTTP library to fix truncation of redirection URLs\n  (Issue #396)\n- Fixed a regression in the handling of character entities for UTF-8 input\n  (Issue #401)\n- The `--numbered` option did not work when the table-of-contents was disabled\n  (Issue #405)\n\n\n# Changes in HTMLDOC v1.9.10\n\n- Updated local zlib to v1.2.11.\n- Updated local libpng to v1.6.37.\n- Fixed packaging issues on macOS and Windows (Issue #377, Issue #386)\n- Now ignore sRGB profile errors in PNG files (Issue #390)\n- The GUI would crash when saving (Issue #391)\n- Page comments are now allowed in `pre` text (Issue #394)\n\n\n# Changes in HTMLDOC v1.9.9\n\n- Fixed a redirection issue - some sites (incorrectly) provide an incomplete\n  Location: URL in the HTTP response.\n- Fixed https: support on newer versions of Windows (Issue #378)\n- Fixed a problem with remote URLs containing spaces (Issue #379)\n- Fixed a UTF-8 processing bug for Markdown files (Issue #383)\n- Added support for `<FONT FACE=\"monospace\">` (Issue #385)\n\n\n# Changes in HTMLDOC v1.9.8\n\n- Added support for a `HTMLDOC.filename` META keyword that controls the filename\n  reported in CGI mode; the default remains \"htmldoc.pdf\" (Issue #367)\n- Fixed a paragraph formatting issue with large inline images (Issue #369)\n- Fixed a buffer underflow issue (Issue #370)\n- Fixed PDF page numbers (Issue #371)\n- Added support for a new `L` header/footer format (`$LETTERHEAD`), which\n  inserts a letterhead image at its full size (Issue #372, Issue #373,\n  Issue #375)\n- Updated the build documentation (Issue #374)\n\n\n# Changes in HTMLDOC v1.9.7\n\n- Refactored the PRE rendering code to work around compiler optimization bugs\n  (Issue #349)\n- Added support for links with targets (Issue #351)\n- Fixed a table rowspan + valign bug (Issue #360)\n\n\n# Changes in HTMLDOC v1.9.6\n\n- Added support for data URIs (Issue #340)\n- HTMLDOC no longer includes a PDF table of contents when converting a single\n  web page (Issue #344)\n- Updated the markdown support with external links, additional inline markup,\n  and hard line breaks.\n- Links in markdown text no longer render with a leading space as part of the\n  link (Issue #346)\n- Fixed a buffer underflow bug discovered by AddressSanitizer.\n- Fixed a bug in UTF-8 support (Issue #348)\n- PDF output now includes the base language of the input document(s)\n  (Issue #350)\n- Optimized the loading of font widths (Issue #354)\n- Optimized PDF page resources (Issue #356)\n- Optimized the base memory used for font widths (Issue #357)\n- Added proper `&shy;` support (Issue #361)\n- Title files can now be markdown.\n\n\n# Changes in HTMLDOC v1.9.5\n\n- The GUI did not support EPUB output.\n- Empty markdown table cells were not rendered in PDF or PostScript output.\n- The automatically-generated title page now supports both \"docnumber\" and\n  \"version\" metadata.\n- Added support for dc:subject and dc:language metadata in EPUB output from the\n  HTML keywords and lang values.\n- Added support for the subject and language metadata in markdown input.\n- Fixed a buffer underflow bug (Issue #338)\n- `htmldoc --help` now reports whether HTTPS URLs are supported (Issue #339)\n- Fixed an issue with HTML title pages and EPUB output.\n\n\n# Changes in HTMLDOC v1.9.4\n\n- Inline fixed-width text is no longer reduced in size automatically\n  (Issue #309)\n- Optimized initialization of font width data (Issue #334)\n\n\n# Changes in HTMLDOC v1.9.3\n\n- Fixed formatting bugs with aligned images (Issue #322, Issue #324)\n- Fixed support for three digit \"#RGB\" color values (Issue #323)\n- Fixed character set support for markdown metadata.\n- Updated libpng to v1.6.34 (Issue #326)\n- The makefiles did not use the CPPFLAGS value (Issue #328)\n\n\n# Changes in HTMLDOC v1.9.2\n\n- Added Markdown table support.\n- Fixed parsing of TBODY, TFOOT, and THEAD elements in HTML files.\n\n\n# Changes in HTMLDOC v1.9.1\n\n- Fixed monospace font size issue (Issue #309)\n- Added support for reproducible builds (Issue #310)\n- Added limited support for the HTML 4.0 SPAN element (Issue #311)\n- Added (extremely limited) UTF-8 support for input files (Issue #314)\n- Fixed buffer underflow for (invalid) short HTML comments (Issue #316)\n- Now indent PRE text, by popular request.\n- EPUB output now makes sure that `<element property>` is written as\n  `<element property=\"property\">`.\n- Now support both NAME and ID for table-of-contents targets.\n\n\n# Changes in HTMLDOC v1.9\n\n- Added support for repeating a single header row for tables that span multiple\n  pages (Issue #16)\n- Added support for embedding the current filename/URL in the header or footer\n  (Issue #50)\n- Added EPUB support (Issue #301)\n- Added Markdown support (Issue #302)\n- Fixed a regression in header/footer image scaling (Issue #303)\n- Documentation updates (Issue #305)\n- Compiler fixes (Issue #304, Issue #306)\n- Fixed a bug when running HTMLDOC as a macOS application.\n- Updated the bundled libpng to v1.6.29.\n\n\n# Changes in HTMLDOC v1.8.30\n\n- Updated documentation to reflect new project page on Github.\n- Dropped old CDE and IRIX desktop integration files.\n- Cleaned up the GUI and adopted new default text editors for Linux and macOS.\n- PAGE BREAK comments at the end of a file in web page mode would lose the\n  first page (Issue #251)\n- Fixed the scaling of header/footer images to limit them to the height of the\n  header or footer (Issue #273)\n- Fixed an issue with the top-level makefile not exiting with an error as\n  needed (Issue #282)\n- Fixed a URL referencing bug when the same hostname but a different port was\n  used (Issue #290)\n- Fixed build issue on macOS (Issue #291)\n- Fixed handling of indexed+alpha PNG images (Issue #295)\n\n\n# Changes in HTMLDOC v1.8.29\n\n- Updated local PNG library to version 1.6.20.\n- Updated local JPEG library to version 9b.\n- Dropped support for OpenSSL.\n- Added configure script support for libjpeg-turbo.\n- Updated HTTP code to latest CUPS/ippsample sources.\n- Duplex PDF output incorrectly forced an even number of pages\n- The table of contents showed the wrong page numbers after headings containing\n  the \"_HD_OMIT_TOC\" attribute.\n- Fixed reported build issues\n- The configure script's --enable-local* options did not work.\n\n\n# Changes in HTMLDOC v1.8.28\n\n- Updated local zlib to version 1.2.8.\n- Updated local PNG library to version 1.6.8.\n- Updated local JPEG library to version 9.\n- Updated default PDF version to 1.4.\n- SECURITY: Fixed three buffer overflow issues when reading AFM files and\n  parsing page sizes.\n- Fixed incompatibility with Fortify's version of strcpy, which does not work\n  properly with variable-length arrays\n- Fixed compilation against PNG library 1.5 or later\n- Fixed documentation errors\n- Marked Zapf-Dingbats as a standard font\n- Fixed GPL license text in GUI\n- Fixed a table formatting problem when a column has multiple colspan values\n- Fixed parsing of HTML comments\n- Fixed potential out-of-bounds read in table-of-contents rendering code\n- Fixed handling of image URLs with ampersands in them\n- Fixed top/bottom margins for logo and header/footer images\n- Fixed image alignment bug\n- Fixed X11 build problem\n\n\n# Changes in HTMLDOC v1.8.27\n\n- Fixed a crash bug that appeared when more than 10 blank pages were present in\n  a document\n- Color changes were not reflected in PRE text\n- Remote URLs did not always work on older operating systems\n- Image filenames using % escapes were not decoded properly.\n- Rows using BGCOLOR that spanned across multiple pages did not render properly\n- Rows no longer start on a new page due to a cell with both HEIGHT and ROWSPAN\n  specified\n- CMYK JPEG images caused HTMLDOC to crash\n- Table cell width calculations didn't always account for the proper minimum\n  width\n- Images were not copied when generating indexed HTML output to a directory\n- Changing the bottom margin resulted in text that was formatted below the\n  bottom margin.\n- The Monospace-Oblique font was not embedded properly in PDF files.\n\n\n# Changes in HTMLDOC v1.8.26\n\n- Outline and keyword strings in PDF files are now stored as Unicode\n- The Flate compression code could get in an infinite loop if it ran out of\n  memory\n- Book files saved from the GUI did not handle filenames with spaces\n- Fixed and re-enabled the ASCII85Device filter support in PostScript Level 2/3\n  output\n- Character entities in the first word of a file were not rendered properly\n- Fixed-size table columns were incorrectly resized when a table width was also\n  specified and there was extra space to distribute\n- Text could \"walk\" up or down when in-line images were used\n- Row backgrounds incorrectly replaced cell backgrounds when the first cell in a\n  row used ROWSPAN\n- HTMLDOC did not correctly parse FONT FACE attributes\n- Images in Level 2/3 PostScript output did not work on some printers\n- The GUI did not use the first page header\n\n\n# Changes in HTMLDOC v1.8.25\n\n- Added \"--overflow\" and \"--no-overflow\" command-line options to show or hide\n  the content-too-large errors; the default is \"--no-overflow\".\n- Added \"--header1\" command-line option and \"HEADER1\" page comments to set the\n  page header for the first page of each chapter.\n- Added \"timing\" and \"remotebytes\" debug data generation.\n- Added DejaVu font collection to better support Cyrillic and Greek text; the\n  new fonts are available under the generic names \"monospace\", \"sans\", and\n  \"serif\".\n- Added \"--referer\" command-line option and corresponding CGI-mode support to\n  pass Referer: information in HTTP requests\n- On Windows, HTMLDOC now logs CGI mode errors to a file called \"htmldoc.log\" in\n  the Windows temporary directory.\n- HTMLDOC no longer uses Base-85 encoding for image data when producing Level 2\n  and 3 PostScript output. It appears that many printers and PostScript\n  interpreters cannot properly decode this data when the original image data is\n  not a multiple of 8 bits.\n- HTMLDOC now renders STRONG elements in boldface instead of bold-italic to\n  match the W3C recommendations.\n- HTMLDOC now automatically inserts a TR element before a TD or TH element as\n  needed to improve web site compatibility; this also triggers a HTML error in\n  --strict mode.\n- \"$HFIMAGEn\" didn't work in a header/footer string.\n- HTMLDOC could crash when rendering a table.\n- Book files were not used in CGI mode\n- Cookies were not sent in HTTP requests\n- Table cells were not aligned properly when the ROWSPAN attribute was set to 1\n- HTMLDOC crashed when rendering unresolved hyperlinks in aligned images\n- Documented the HTMLDOC_NOCGI environment variable\n- HTMLDOC sometimes crashed when rendering tables with background colors\n- HTMLDOC would crash when writing encrypted strings longer than 1024 bytes\n- HTMLDOC didn't set the data directory when running in CGI mode on Windows.\n- HTMLDOC could crash when loading the Symbol.afm file\n- HTMLDOC did not always honor HEIGHT attributes in table rows.\n- Tables with a mix of colspan and rowspan sometimes caused cells to be moved\n  vertically outside the cell.\n", "/*\n * PostScript + PDF output routines for HTMLDOC, a HTML document processing\n * program.\n *\n * Just in case you didn't notice it, this file is too big; it will be\n * broken into more manageable pieces once we make all of the output\n * \"drivers\" into classes...\n *\n * Copyright \u00a9 2011-2021 by Michael R Sweet.\n * Copyright \u00a9 1997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n/*\n * The GCC compiler on HP-UX has a nasty habit of incorrectly \"fixing\"\n * the vmtypes.h header file provided with HP-UX.  The following\n * conditional magic makes sure that \"page_t\" (which we use in our\n * code) is not defined...\n */\n\n#ifdef __hpux\n#  define page_t\thpux_page_t\n#endif // __hpux\n\n/*#define DEBUG*/\n#include \"htmldoc.h\"\n#include \"markdown.h\"\n#include \"md5-private.h\"\n#define md5_append _cupsMD5Append\n#define md5_finish _cupsMD5Finish\n#define md5_init _cupsMD5Init\ntypedef unsigned char md5_byte_t;\n#define md5_state_t _cups_md5_state_t\n#include \"rc4.h\"\n#include <stdarg.h>\n#include <ctype.h>\n#include <time.h>\n#include <math.h>\n\n#ifdef WIN32\n#  include <io.h>\n#else\n#  include <unistd.h>\n#endif // WIN32\n\n#include <fcntl.h>\n\n#include <zlib.h>\n\nextern \"C\" {\t\t/* Workaround for JPEG header problems... */\n#include <jpeglib.h>\t/* JPEG/JFIF image definitions */\n}\n\n#ifdef __hpux\n#  undef page_t\n#endif // __hpux\n\n\n/*\n * Output options...\n */\n\n#define HTMLDOC_ASCII85\n//#define HTMLDOC_INTERPOLATION\n#define HTMLDOC_PRODUCER \"htmldoc \" SVERSION \" Copyright 2011-2019 by Michael R Sweet\"\n\n\n/*\n * Constants...\n */\n\n#define RENDER_TEXT\t0\t\t/* Text fragment */\n#define RENDER_IMAGE\t1\t\t/* Image */\n#define RENDER_BOX\t2\t\t/* Box */\n#define RENDER_LINK\t3\t\t/* Hyperlink */\n#define RENDER_BG\t4\t\t/* Background image */\n\n\n/*\n * Structures...\n */\n\ntypedef struct render_str\t\t/**** Render entity structure ****/\n{\n  struct render_str\t*prev;\t\t/* Previous rendering entity */\n  struct render_str\t*next;\t\t/* Next rendering entity */\n  int\ttype;\t\t\t\t/* Type of entity */\n  float\tx,\t\t\t\t/* Position in points */\n\ty,\t\t\t\t/* ... */\n\twidth,\t\t\t\t/* Size in points */\n\theight;\t\t\t\t/* ... */\n  union\n  {\n    struct\n    {\n      int\ttypeface,\t\t/* Typeface for text */\n\t\tstyle;\t\t\t/* Style of text */\n      float\tsize;\t\t\t/* Size of text in points */\n      float\tspacing;\t\t/* Inter-character spacing */\n      float\trgb[3];\t\t\t/* Color of text */\n      uchar\tbuffer[1];\t\t/* String buffer */\n    }   \ttext;\n    image_t\t*image;\t\t\t/* Image pointer */\n    float\tbox[3];\t\t\t/* Box color */\n    uchar\tlink[1];\t\t/* Link URL */\n  }\tdata;\n} render_t;\n\ntypedef struct\t\t\t\t/**** Named link position structure */\n{\n  short\t\tpage,\t\t\t/* Page # */\n\t\ttop;\t\t\t/* Top position */\n  uchar\t\tname[124];\t\t/* Reference name */\n} link_t;\n\ntypedef struct\t\t\t\t//// Page information\n{\n  int\t\twidth,\t\t\t// Width of page in points\n\t\tlength,\t\t\t// Length of page in points\n\t\tleft,\t\t\t// Left margin in points\n\t\tright,\t\t\t// Right margin in points\n\t\ttop,\t\t\t// Top margin in points\n\t\tbottom,\t\t\t// Bottom margin in points\n\t\tduplex,\t\t\t// Duplex this page?\n\t\tlandscape;\t\t// Landscape orientation?\n  render_t\t*start,\t\t\t// First render element\n\t\t*end;\t\t\t// Last render element\n  uchar\t\t*url,                   // URL/file\n                *chapter,\t\t// Chapter text\n\t\t*heading;\t\t// Heading text\n  tree_t\t*headnode;\t\t// Heading node\n  uchar\t\t*header[3],\t\t// Headers for regular pages\n\t\t*header1[3],\t\t// Headers for first pages\n\t\t*footer[3];\t\t// Footers for all pages\n  char\t\tmedia_color[64],\t// Media color\n\t\tmedia_type[64];\t\t// Media type\n  int\t\tmedia_position;\t\t// Media position\n  char\t\tpage_text[64];\t\t// Page number for TOC\n  image_t\t*background_image;\t// Background image\n  float\t\tbackground_color[3];\t// Background color\n\n  // Number-up support\n  int\t\tnup;\t\t\t// Number up pages\n  int\t\toutpage;\t\t// Output page #\n  float\t\toutmatrix[2][3];\t// Transform matrix\n} page_t;\n\ntypedef struct\t\t\t\t//// Output page info\n{\n  int\t\tnup;\t\t\t// Number up pages\n  int\t\tpages[16];\t\t// Pages on this output page\n  int\t\tannot_object;\t\t// Annotation object\n} outpage_t;\n\n\n/*\n * Local globals...\n */\n\nstatic time_t\tdoc_time;\t\t// Current time\nstatic struct tm doc_date;\t\t// Current date\n\nstatic uchar    *current_url = NULL;\nstatic int\ttitle_page;\nstatic int\tchapter,\n\t\tchapter_outstarts[MAX_CHAPTERS],\n\t\tchapter_outends[MAX_CHAPTERS],\n\t\tchapter_starts[MAX_CHAPTERS],\n\t\tchapter_ends[MAX_CHAPTERS];\n\nstatic size_t\tnum_headings = 0,\n\t\talloc_headings = 0;\nstatic int\t*heading_pages = NULL,\n\t\t*heading_tops = NULL;\n\nstatic size_t\tnum_pages = 0,\n\t\talloc_pages = 0;\nstatic page_t\t*pages = NULL;\nstatic tree_t\t*current_heading;\n\nstatic size_t\tnum_outpages = 0;\nstatic outpage_t *outpages = NULL;\n\nstatic size_t\tnum_links = 0,\n\t\talloc_links = 0;\nstatic link_t\t*links = NULL;\n\nstatic uchar\tlist_types[16];\nstatic int\tlist_values[16];\n\nstatic char\tstdout_filename[256];\nstatic size_t\tnum_objects = 0,\n\t\talloc_objects = 0;\nstatic int\t*objects = NULL,\n\t\troot_object,\n\t\tinfo_object,\n\t\toutline_object,\n\t\tpages_object,\n\t\tnames_object,\n\t\tencrypt_object,\n\t\tfont_objects[TYPE_MAX * STYLE_MAX];\n\nstatic uchar\t*doc_title = NULL;\nstatic image_t\t*logo_image = NULL;\nstatic float\tlogo_width,\n\t\tlogo_height;\nstatic image_t\t*lh_image = NULL;\nstatic float\tlh_width,\n\t\tlh_height;\n\nstatic image_t\t*hfimage[MAX_HF_IMAGES];\nstatic float\thfimage_width[MAX_HF_IMAGES],\n\t\thfimage_height[MAX_HF_IMAGES];\nstatic float    maxhfheight;\n\nstatic image_t\t*background_image = NULL;\nstatic float\tbackground_color[3] = { 1.0, 1.0, 1.0 },\n\t\tlink_color[3] = { 0.0, 0.0, 1.0 };\n\nstatic int\trender_typeface,\n\t\trender_style;\nstatic float\trender_size,\n\t\trender_rgb[3],\n\t\trender_x,\n\t\trender_y,\n\t\trender_startx,\n\t\trender_spacing;\n\nstatic int\t\tcompressor_active = 0;\nstatic z_stream\t\tcompressor;\nstatic uchar\t\tcomp_buffer[8192];\nstatic uchar\t\tencrypt_key[16];\nstatic int\t\tencrypt_len;\nstatic rc4_context_t\tencrypt_state;\nstatic md5_byte_t\tfile_id[16];\n\n\n/*\n * Local functions...\n */\n\nextern \"C\" {\ntypedef int\t(*compare_func_t)(const void *, const void *);\n}\n\nstatic void\tpspdf_debug_stats();\n\nstatic void\tpspdf_transform_coords(page_t *p, float &x, float  &y);\nstatic void\tpspdf_transform_page(int outpage, int pos, int page);\n\nstatic void\tpspdf_prepare_outpages();\nstatic void\tpspdf_prepare_page(int page);\nstatic void\tpspdf_prepare_heading(int page, int print_page, uchar **format,\n\t\t                      int y, char *page_text, int page_len);\nstatic void\tps_write_document(uchar *author, uchar *creator,\n\t\t                  uchar *copyright, uchar *keywords,\n\t\t\t\t  uchar *subject, uchar *lang);\nstatic void\tps_write_outpage(FILE *out, int outpage);\nstatic void\tps_write_page(FILE *out, int page);\nstatic void\tps_write_background(FILE *out);\nstatic void\tpdf_write_document(uchar *author, uchar *creator,\n\t\t                   uchar *copyright, uchar *keywords,\n\t\t\t\t   uchar *subject, uchar *lang, tree_t *doc, tree_t *toc);\nstatic void\tpdf_write_outpage(FILE *out, int outpage);\nstatic void\tpdf_write_page(FILE *out, int page);\nstatic void\tpdf_write_resources(FILE *out, int page);\n#ifdef DEBUG_TOC\nstatic void\tpdf_text_contents(FILE *out, tree_t *toc, int indent = 0);\n#endif // DEBUG_TOC\nstatic void\tpdf_write_contents(FILE *out, tree_t *toc, int parent,\n\t\t                   int prev, int next, int *heading);\nstatic void\tpdf_write_files(FILE *out, tree_t *doc);\nstatic void\tpdf_write_links(FILE *out);\nstatic void\tpdf_write_names(FILE *out);\nstatic int\tpdf_count_headings(tree_t *toc);\n\nstatic int\tpdf_start_object(FILE *out, int array = 0);\nstatic void\tpdf_start_stream(FILE *out);\nstatic void\tpdf_end_object(FILE *out);\n\nstatic void\tencrypt_init(void);\nstatic void\tflate_open_stream(FILE *out);\nstatic void\tflate_close_stream(FILE *out);\nstatic void\tflate_puts(const char *s, FILE *out);\nstatic void\tflate_printf(FILE *out, const char *format, ...);\nstatic void\tflate_write(FILE *out, uchar *inbuf, int length, int flush=0);\n\nstatic void\tparse_contents(tree_t *t, float left, float width, float bottom,\n\t\t               float length, float *y, int *page, int *heading,\n\t\t\t       tree_t *chap);\nstatic void\tparse_doc(tree_t *t, float *left, float *right, float *bottom,\n\t\t          float *top, float *x, float *y, int *page,\n\t\t\t  tree_t *cpara, int *needspace);\nstatic void\tparse_heading(tree_t *t, float left, float width, float bottom,\n\t\t              float length, float *x, float *y, int *page,\n\t\t\t      int needspace);\nstatic void\tparse_paragraph(tree_t *t, float left, float width, float bottom,\n\t\t                float length, float *x, float *y, int *page,\n\t\t\t        int needspace);\nstatic void\tparse_pre(tree_t *t, float left, float width, float bottom,\n\t\t          float length, float *x, float *y, int *page,\n\t\t\t  int needspace);\nstatic void\tparse_table(tree_t *t, float left, float width, float bottom,\n\t\t            float length, float *x, float *y, int *page,\n\t\t\t    int needspace);\nstatic void\tparse_list(tree_t *t, float *left, float *width, float *bottom,\n\t\t           float *length, float *x, float *y, int *page,\n\t\t\t   int needspace);\nstatic void\tinit_list(tree_t *t);\nstatic void\tparse_comment(tree_t *t, float *left, float *width, float *bottom,\n\t\t              float *length, float *x, float *y, int *page,\n\t\t\t      tree_t *para, int needspace);\n\nstatic void\tcheck_pages(int page);\n\nstatic void\tadd_link(uchar *name, int page, int top);\nstatic link_t\t*find_link(uchar *name);\nstatic int\tcompare_links(link_t *n1, link_t *n2);\n\nstatic void\tfind_background(tree_t *t);\nstatic void\twrite_background(int page, FILE *out);\n\nstatic render_t\t*new_render(int page, int type, double x, double y,\n\t\t            double width, double height, void *data,\n\t\t\t    render_t *insert = 0);\nstatic float\tget_cell_size(tree_t *t, float left, float right,\n\t\t              float *minwidth, float *prefwidth,\n\t\t\t      float *minheight);\nstatic float\tget_table_size(tree_t *t, float left, float right,\n\t\t               float *minwidth, float *prefwidth,\n\t\t\t       float *minheight);\nstatic tree_t\t*flatten_tree(tree_t *t);\nstatic float\tget_width(uchar *s, int typeface, int style, int size);\nstatic void\tupdate_image_size(tree_t *t);\nstatic uchar\t*get_title(tree_t *doc);\nstatic FILE\t*open_file(void);\nstatic void\tset_color(FILE *out, float *rgb);\nstatic void\tset_font(FILE *out, int typeface, int style, float size);\nstatic void\tset_pos(FILE *out, float x, float y);\nstatic void\twrite_prolog(FILE *out, int pages, uchar *author,\n\t\t             uchar *creator, uchar *copyright,\n\t\t\t     uchar *keywords, uchar *subject);\nstatic void\tps_hex(FILE *out, uchar *data, int length);\n#ifdef HTMLDOC_ASCII85\nstatic void\tps_ascii85(FILE *out, uchar *data, int length, int eod = 0);\n#endif // HTMLDOC_ASCII85\nstatic void\tjpg_init(j_compress_ptr cinfo);\nstatic boolean\tjpg_empty(j_compress_ptr cinfo);\nstatic void\tjpg_term(j_compress_ptr cinfo);\nstatic void\tjpg_setup(FILE *out, image_t *img, j_compress_ptr cinfo);\nstatic int\tcompare_rgb(unsigned *rgb1, unsigned *rgb2);\nstatic void\twrite_image(FILE *out, render_t *r, int write_obj = 0);\nstatic void\twrite_imagemask(FILE *out, render_t *r);\nstatic void\twrite_string(FILE *out, uchar *s, int compress);\nstatic void\twrite_text(FILE *out, render_t *r);\nstatic void\twrite_trailer(FILE *out, int pages, uchar *lang);\nstatic int\twrite_type1(FILE *out, typeface_t typeface,\n\t\t\t    style_t style);\nstatic void\twrite_utf16(FILE *out, uchar *s);\n\n\n/*\n * 'pspdf_export()' - Export PostScript/PDF file(s)...\n */\n\nint\npspdf_export(tree_t *document,\t/* I - Document to export */\n             tree_t *toc)\t/* I - Table of contents for document */\n{\n  int\t\ti, j;\t\t/* Looping vars */\n  const char\t*title_file;\t/* Location of title image/file */\n  uchar\t\t*author,\t/* Author of document */\n\t\t*creator,\t/* HTML file creator (Netscape, etc) */\n\t\t*copyright,\t/* File copyright */\n\t\t*docnumber,\t/* Document number */\n\t\t*keywords,\t/* Search keywords */\n\t\t*subject,\t/* Subject */\n\t\t*lang;\t\t/* Language */\n  tree_t\t*t;\t\t/* Title page document tree */\n  FILE\t\t*fp;\t\t/* Title page file */\n  float\t\tx, y,\t\t/* Current page position */\n\t\tleft, right,\t/* Left and right margins */\n\t\tbottom, top,\t/* Bottom and top margins */\n\t\twidth,\t\t/* Width of , author, etc */\n\t\theight;\t\t/* Height of  area */\n  int\t\tpage,\t\t/* Current page # */\n\t\tpos,\t\t/* Current header/footer position */\n\t\theading,\t/* Current heading # */\n\t\ttoc_duplex,\t/* Duplex TOC pages? */\n\t\ttoc_landscape,\t/* Do TOC in landscape? */\n\t\ttoc_width,\t/* Width of TOC pages */\n\t\ttoc_length,\t/* Length of TOC pages */\n\t\ttoc_left,\t/* TOC page margins */\n\t\ttoc_right,\n\t\ttoc_bottom,\n\t\ttoc_top;\n  image_t\t*timage;\t/* Title image */\n  float\t\ttimage_width,\t/* Title image width */\n\t\ttimage_height;\t/* Title image height */\n  render_t\t*r;\t\t/* Rendering structure... */\n  float\t\trgb[3];\t\t/* Text color */\n  int\t\tneedspace;\t/* Need whitespace */\n\n\n /*\n  * Figure out the printable area of the output page...\n  */\n\n  if (Landscape)\n  {\n    PagePrintWidth  = PageLength - PageLeft - PageRight;\n    PagePrintLength = PageWidth - PageTop - PageBottom;\n  }\n  else\n  {\n    PagePrintWidth  = PageWidth - PageLeft - PageRight;\n    PagePrintLength = PageLength - PageTop - PageBottom;\n  }\n\n  toc_width     = PageWidth;\n  toc_length    = PageLength;\n  toc_left      = PageLeft;\n  toc_right     = PageRight;\n  toc_bottom    = PageBottom;\n  toc_top       = PageTop;\n  toc_landscape = Landscape;\n  toc_duplex    = PageDuplex;\n\n /*\n  * Get the document title, author, etc...\n  */\n\n  doc_title   = get_title(document);\n  author      = htmlGetMeta(document, (uchar *)\"author\");\n  creator     = htmlGetMeta(document, (uchar *)\"generator\");\n  copyright   = htmlGetMeta(document, (uchar *)\"copyright\");\n  docnumber   = htmlGetMeta(document, (uchar *)\"docnumber\");\n  keywords    = htmlGetMeta(document, (uchar *)\"keywords\");\n  subject     = htmlGetMeta(document, (uchar *)\"subject\");\n  lang        = htmlGetMeta(document, (uchar *)\"lang\");\n  logo_image  = image_load(LogoImage, !OutputColor);\n  lh_image    = image_load(Letterhead, !OutputColor);\n  maxhfheight = 0.0f;\n\n  if (docnumber == NULL)\n    docnumber = htmlGetMeta(document, (uchar *)\"version\");\n\n  if (lh_image != NULL)\n  {\n    lh_width  = (float)(lh_image->width * PagePrintWidth / _htmlBrowserWidth);\n    lh_height = (float)(lh_width * lh_image->height / lh_image->width);\n\n    if (lh_height > maxhfheight)\n      maxhfheight = lh_height;\n  }\n  else\n    lh_width = lh_height = 0.0f;\n\n  if (logo_image != NULL)\n  {\n    logo_width  = (float)(logo_image->width * PagePrintWidth / _htmlBrowserWidth);\n    logo_height = (float)(logo_width * logo_image->height / logo_image->width);\n\n    if (logo_height > (2.0 * HeadFootSize))\n    {\n      // Issue #273: too large logo image will overlap the body text, so cap\n      // the height of the logo image to the header/footer size...\n      //\n      // Issue #303: regression prevents using header/footer images for special\n      // underlining/etc. effects.\n      logo_height = (float)(2.0 * HeadFootSize);\n      logo_width  = logo_height * logo_image->width / logo_image->height;\n    }\n\n    if (logo_height > maxhfheight)\n      maxhfheight = logo_height;\n  }\n  else\n    logo_width = logo_height = 0.0f;\n\n  for (int hfi = 0; hfi < MAX_HF_IMAGES; hfi ++)\n  {\n    hfimage[hfi] = image_load(HFImage[hfi], !OutputColor);\n\n    if (hfimage[hfi])\n    {\n      hfimage_width[hfi]  = (float)(hfimage[hfi]->width * PagePrintWidth / _htmlBrowserWidth);\n      hfimage_height[hfi] = (float)(hfimage_width[hfi] * hfimage[hfi]->height / hfimage[hfi]->width);\n\n      if (hfimage_height[hfi] > (2.0 * HeadFootSize))\n      {\n        // Issue #273: too large logo image will overlap the body text, so cap\n        // the height of the logo image to the header/footer size...\n        //\n        // Issue #303: regression prevents using header/footer images for special\n        // underlining/etc. effects.\n        hfimage_height[hfi] = (float)(2.0 * HeadFootSize);\n        hfimage_width[hfi]  = hfimage_height[hfi] * hfimage[hfi]->width / hfimage[hfi]->height;\n      }\n\n      if (hfimage_height[hfi] > maxhfheight)\n        maxhfheight = hfimage_height[hfi];\n    }\n    else\n      hfimage_width[hfi] = hfimage_height[hfi] = 0.0f;\n  }\n\n  find_background(document);\n  get_color((uchar *)LinkColor, link_color);\n\n /*\n  * Initialize page rendering variables...\n  */\n\n  num_pages   = 0;\n  alloc_pages = 0;\n  pages       = NULL;\n\n  memset(list_types, 0267, sizeof(list_types));\n  memset(list_values, 0, sizeof(list_values));\n  memset(chapter_starts, -1, sizeof(chapter_starts));\n  memset(chapter_ends, -1, sizeof(chapter_starts));\n\n /*\n  * Get the current date, using the SOURCE_DATE_EPOCH environment variable, if\n  * present, for the number of seconds since the epoch - this enables\n  * reproducible builds (Issue #310).\n  */\n\n  const char *source_date_epoch = getenv(\"SOURCE_DATE_EPOCH\");\n  if (!source_date_epoch || (doc_time = (time_t)strtol(source_date_epoch, NULL, 10)) <= 0)\n    doc_time = time(NULL);\n\n  gmtime_r(&doc_time, &doc_date);\n\n  num_headings   = 0;\n  alloc_headings = 0;\n  heading_pages  = NULL;\n  heading_tops   = NULL;\n  num_links      = 0;\n  alloc_links    = 0;\n  links          = NULL;\n  num_pages      = 0;\n\n  DEBUG_printf((\"pspdf_export: TitlePage = %d, TitleImage = \\\"%s\\\"\\n\",\n                TitlePage, TitleImage));\n\n  if (TitlePage)\n  {\n    const char *title_ext = file_extension(TitleImage);\n\n#ifdef WIN32\n    if (TitleImage[0] &&\n        stricmp(title_ext, \"bmp\") != 0 &&\n\tstricmp(title_ext, \"gif\") != 0 &&\n\tstricmp(title_ext, \"jpg\") != 0 &&\n\tstricmp(title_ext, \"png\") != 0)\n#else\n    if (TitleImage[0] &&\n        strcmp(title_ext, \"bmp\") != 0 &&\n\tstrcmp(title_ext, \"gif\") != 0 &&\n\tstrcmp(title_ext, \"jpg\") != 0 &&\n\tstrcmp(title_ext, \"png\") != 0)\n#endif // WIN32\n    {\n      DEBUG_printf((\"pspdf_export: Generating a titlepage using \\\"%s\\\"\\n\",\n                    TitleImage));\n\n      // Find the title file...\n      if ((title_file = file_find(Path, TitleImage)) == NULL)\n      {\n\tprogress_error(HD_ERROR_FILE_NOT_FOUND,\n\t               \"Unable to find title file \\\"%s\\\"!\", TitleImage);\n\treturn (1);\n      }\n\n      // Write a title page from HTML source...\n      if ((fp = fopen(title_file, \"rb\")) == NULL)\n      {\n\tprogress_error(HD_ERROR_FILE_NOT_FOUND,\n\t               \"Unable to open title file \\\"%s\\\" - %s!\",\n                       TitleImage, strerror(errno));\n\treturn (1);\n      }\n\n#ifdef _WIN32\n      if (!stricmp(title_ext, \"md\"))\n#else\n      if (!strcmp(title_ext, \"md\"))\n#endif // _WIN32\n\tt = mdReadFile(NULL, fp, file_directory(TitleImage));\n      else\n\tt = htmlReadFile(NULL, fp, file_directory(TitleImage));\n\n      htmlFixLinks(t, t, (uchar *)file_directory(TitleImage));\n      fclose(fp);\n\n      page            = 0;\n      title_page      = 1;\n      current_heading = NULL;\n      x               = 0.0f;\n      bottom          = 0.0f;\n      top             = PagePrintLength;\n      y               = top;\n      needspace       = 0;\n      left            = 0.0f;\n      right           = PagePrintWidth;\n\n      parse_doc(t, &left, &right, &bottom, &top, &x, &y, &page, NULL, &needspace);\n\n      if (PageDuplex && (num_pages & 1))\n\tcheck_pages(num_pages);\n\n      htmlDeleteTree(t);\n    }\n    else\n    {\n     /*\n      * Create a standard title page...\n      */\n\n      if ((timage = image_load(TitleImage, !OutputColor)) != NULL)\n      {\n\ttimage_width  = (float)(timage->width * PagePrintWidth / _htmlBrowserWidth);\n\ttimage_height = (float)(timage_width * timage->height / timage->width);\n      }\n      else\n        timage_width = timage_height = 0.0f;\n\n      check_pages(0);\n      if (PageDuplex)\n        check_pages(1);\n\n      height = 0.0;\n\n      if (timage != NULL)\n\theight += timage_height + _htmlSpacings[SIZE_P];\n      if (doc_title != NULL)\n\theight += _htmlSpacings[SIZE_H1] + _htmlSpacings[SIZE_P];\n      if (author != NULL)\n\theight += _htmlSpacings[SIZE_P];\n      if (docnumber != NULL)\n\theight += _htmlSpacings[SIZE_P];\n      if (copyright != NULL)\n\theight += _htmlSpacings[SIZE_P];\n\n      y = 0.5f * (PagePrintLength + height);\n\n      if (timage != NULL)\n      {\n\tnew_render(0, RENDER_IMAGE, 0.5f * (PagePrintWidth - timage_width),\n                   y - timage_height, timage_width, timage_height, timage);\n\ty -= timage_height + _htmlSpacings[SIZE_P];\n      }\n\n      get_color(_htmlTextColor, rgb);\n\n      if (doc_title != NULL)\n      {\n\twidth = get_width(doc_title, _htmlHeadingFont, STYLE_BOLD, SIZE_H1);\n\tr     = new_render(0, RENDER_TEXT, (PagePrintWidth - width) * 0.5f,\n                \t   y - _htmlSpacings[SIZE_H1], width,\n\t\t\t   _htmlSizes[SIZE_H1], doc_title);\n\n\tr->data.text.typeface = _htmlHeadingFont;\n\tr->data.text.style    = STYLE_BOLD;\n\tr->data.text.size     = (float)_htmlSizes[SIZE_H1];\n\tmemcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n\ty -= _htmlSpacings[SIZE_H1];\n\n\tif (docnumber != NULL)\n\t{\n\t  width = get_width(docnumber, _htmlBodyFont, STYLE_NORMAL, SIZE_P);\n\t  r     = new_render(0, RENDER_TEXT, (PagePrintWidth - width) * 0.5f,\n                             y - _htmlSpacings[SIZE_P], width,\n\t\t\t     _htmlSizes[SIZE_P], docnumber);\n\n\t  r->data.text.typeface = _htmlBodyFont;\n\t  r->data.text.style    = STYLE_NORMAL;\n\t  r->data.text.size     = (float)_htmlSizes[SIZE_P];\n          memcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n\t  y -= _htmlSpacings[SIZE_P];\n\t}\n\n\ty -= _htmlSpacings[SIZE_P];\n      }\n\n      if (author != NULL)\n      {\n\twidth = get_width(author, _htmlBodyFont, STYLE_NORMAL, SIZE_P);\n\tr     = new_render(0, RENDER_TEXT, (PagePrintWidth - width) * 0.5f,\n                \t   y - _htmlSpacings[SIZE_P], width, _htmlSizes[SIZE_P],\n\t\t\t   author);\n\n\tr->data.text.typeface = _htmlBodyFont;\n\tr->data.text.style    = STYLE_NORMAL;\n\tr->data.text.size     = (float)_htmlSizes[SIZE_P];\n\tmemcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n\ty -= _htmlSpacings[SIZE_P];\n      }\n\n      if (copyright != NULL)\n      {\n\twidth = get_width(copyright, _htmlBodyFont, STYLE_NORMAL, SIZE_P);\n\tr     = new_render(0, RENDER_TEXT, (PagePrintWidth - width) * 0.5f,\n                \t   y - _htmlSpacings[SIZE_P], width, _htmlSizes[SIZE_P],\n\t\t\t   copyright);\n\n\tr->data.text.typeface = _htmlBodyFont;\n\tr->data.text.style    = STYLE_NORMAL;\n\tr->data.text.size     = (float)_htmlSizes[SIZE_P];\n\tmemcpy(r->data.text.rgb, rgb, sizeof(rgb));\n      }\n    }\n\n    for (page = 0; page < (int)num_pages; page ++)\n      strlcpy((char *)pages[page].page_text, (page & 1) ? \"eltit\" : \"title\", sizeof(pages[page].page_text));\n  }\n  else\n    page = 0;\n\n /*\n  * Parse the document...\n  */\n\n  if (OutputType == OUTPUT_BOOK)\n    chapter = 0;\n  else\n  {\n    chapter           = 1;\n    TocDocCount       = 1;\n    chapter_starts[1] = num_pages;\n  }\n\n  title_page      = 0;\n  current_heading = NULL;\n  x               = 0.0f;\n  needspace       = 0;\n  left            = 0.0f;\n  right           = PagePrintWidth;\n\n  // Adjust top margin as needed...\n  float adjust, image_adjust, temp_adjust;\n\n  if (maxhfheight > HeadFootSize)\n    image_adjust = (float)(maxhfheight + HeadFootSize);\n  else\n    image_adjust = (float)(2 * HeadFootSize);\n\n  for (adjust = 0.0, pos = 0; pos < 3; pos ++)\n  {\n    if (Header[pos] &&\n        (strstr(Header[pos], \"$IMAGE\") != NULL ||\n\t strstr(Header[pos], \"$HFIMAGE\") != NULL ||\n\t strstr(Header[pos], \"$LETTERHEAD\") != NULL))\n      temp_adjust = image_adjust;\n    else if (Header1[pos] &&\n\t     (strstr(Header1[pos], \"$IMAGE\") != NULL ||\n\t      strstr(Header1[pos], \"$HFIMAGE\") != NULL ||\n\t      strstr(Header1[pos], \"$LETTERHEAD\") != NULL))\n      temp_adjust = image_adjust;\n    else if (Header[pos] || Header1[pos])\n      temp_adjust = (float)(2 * HeadFootSize);\n    else\n      temp_adjust = 0.0;\n\n    if (temp_adjust > adjust)\n      adjust = temp_adjust;\n  }\n\n  top = PagePrintLength - adjust;\n\n  // Adjust bottom margin as needed...\n  for (adjust = 0.0, pos = 0; pos < 3; pos ++)\n  {\n    if (Footer[pos] &&\n        (strstr(Footer[pos], \"$IMAGE\") != NULL ||\n\t strstr(Footer[pos], \"$HFIMAGE\") != NULL ||\n\t strstr(Footer[pos], \"$LETTERHEAD\") != NULL))\n      temp_adjust = image_adjust;\n    else if (Footer[pos])\n      temp_adjust = (float)(2 * HeadFootSize);\n    else\n      temp_adjust = 0.0;\n\n    if (temp_adjust > adjust)\n      adjust = temp_adjust;\n  }\n\n  bottom = adjust;\n\n  y = top;\n\n  parse_doc(document, &left, &right, &bottom, &top, &x, &y, &page, NULL, &needspace);\n\n  if (PageDuplex && (num_pages & 1))\n  {\n    if (PSLevel == 0)\n      chapter_ends[chapter] = num_pages - 1;\n\n    check_pages(num_pages);\n\n    if (PSLevel > 0)\n      chapter_ends[chapter] = num_pages - 1;\n  }\n  else\n    chapter_ends[chapter] = num_pages - 1;\n\n  for (chapter = 1; chapter <= TocDocCount; chapter ++)\n    for (page = chapter_starts[chapter]; page <= chapter_ends[chapter]; page ++)\n      pspdf_prepare_page(page);\n\n /*\n  * Parse the table-of-contents if necessary...\n  */\n\n  if (TocLevels > 0 && num_headings > 0)\n  {\n    // Restore default page size, etc...\n    PageWidth  = toc_width;\n    PageLength = toc_length;\n    PageLeft   = toc_left;\n    PageRight  = toc_right;\n    PageBottom = toc_bottom;\n    PageTop    = toc_top;\n    Landscape  = toc_landscape;\n    PageDuplex = toc_duplex;\n\n    if (Landscape)\n    {\n      PagePrintWidth  = PageLength - PageLeft - PageRight;\n      PagePrintLength = PageWidth - PageTop - PageBottom;\n    }\n    else\n    {\n      PagePrintWidth  = PageWidth - PageLeft - PageRight;\n      PagePrintLength = PageLength - PageTop - PageBottom;\n    }\n\n    // Adjust top margin as needed...\n    for (pos = 0; pos < 3; pos ++)\n      if (TocHeader[pos])\n\tbreak;\n\n    if (pos == 3)\n      top = PagePrintLength;\n    else if (maxhfheight > HeadFootSize)\n      top = (float)(PagePrintLength - maxhfheight - HeadFootSize);\n    else\n      top = (float)(PagePrintLength - 2 * HeadFootSize);\n\n    // Adjust bottom margin as needed...\n    for (pos = 0; pos < 3; pos ++)\n      if (TocFooter[pos])\n\tbreak;\n\n    if (pos == 3)\n      bottom = 0.0f;\n    else if (maxhfheight > HeadFootSize)\n      bottom = (float)(maxhfheight + HeadFootSize);\n    else\n      bottom = (float)(2 * HeadFootSize);\n\n    y                 = 0.0;\n    page              = num_pages - 1;\n    heading           = 0;\n    chapter_starts[0] = num_pages;\n    chapter           = 0;\n\n    parse_contents(toc, 0, PagePrintWidth, bottom, top, &y, &page, &heading, 0);\n    if (PageDuplex && (num_pages & 1))\n      check_pages(num_pages);\n    chapter_ends[0] = num_pages - 1;\n\n    for (page = chapter_starts[0]; page <= chapter_ends[0]; page ++)\n      pspdf_prepare_page(page);\n  }\n\n  if (TocDocCount > MAX_CHAPTERS)\n    TocDocCount = MAX_CHAPTERS;\n\n /*\n  * Do we have any pages?\n  */\n\n  if (num_pages > 0 && TocDocCount > 0)\n  {\n   /*\n    * Yes, write the document to disk...\n    */\n\n    pspdf_prepare_outpages();\n\n    pspdf_debug_stats();\n\n    progress_error(HD_ERROR_NONE, \"PAGES: %d\", (int)num_outpages);\n\n    if (PSLevel > 0)\n      ps_write_document(author, creator, copyright, keywords, subject, lang);\n    else\n      pdf_write_document(author, creator, copyright, keywords, subject, lang,\n                         document, toc);\n  }\n  else\n  {\n   /*\n    * No, show an error...\n    */\n\n    pspdf_debug_stats();\n\n    progress_error(HD_ERROR_NO_PAGES,\n                   \"Error: no pages generated! (did you remember to use webpage mode?\");\n  }\n\n /*\n  * Free memory...\n  */\n\n  if (doc_title != NULL)\n    free(doc_title);\n\n  if (alloc_links)\n  {\n    free(links);\n\n    num_links    = 0;\n    alloc_links  = 0;\n    links        = NULL;\n  }\n\n  for (i = 0; i < (int)num_pages; i ++)\n  {\n    if ((i == 0 || pages[i].chapter != pages[i - 1].chapter) &&\n        pages[i].chapter)\n      free(pages[i].chapter);\n\n    if ((i == 0 || pages[i].heading != pages[i - 1].heading) &&\n        pages[i].heading)\n      free(pages[i].heading);\n\n    if (!pages[i].heading)\n      continue;\n\n    for (j = 0; j < 3; j ++)\n    {\n      if (!pages[i].header[j])\n        continue;\n\n      if (i == 0 || pages[i].header[j] != pages[i - 1].header[j])\n        free(pages[i].header[j]);\n    }\n\n    for (j = 0; j < 3; j ++)\n    {\n      if (!pages[i].header1[j])\n        continue;\n\n      if (i == 0 || pages[i].header1[j] != pages[i - 1].header1[j])\n        free(pages[i].header1[j]);\n    }\n\n    for (j = 0; j < 3; j ++)\n    {\n      if (!pages[i].footer[j])\n        continue;\n\n      if (i == 0 || pages[i].footer[j] != pages[i - 1].footer[j])\n        free(pages[i].footer[j]);\n    }\n  }\n\n  for (i = 0; i < 3; i ++)\n  {\n    Header[i]    = NULL;\n    Header1[i]   = NULL;\n    Footer[i]    = NULL;\n    TocHeader[i] = NULL;\n    TocFooter[i] = NULL;\n  }\n\n  if (alloc_pages)\n  {\n    free(pages);\n    free(outpages);\n\n    num_pages   = 0;\n    alloc_pages = 0;\n    pages       = NULL;\n  }\n\n  if (alloc_headings)\n  {\n    free(heading_pages);\n    free(heading_tops);\n\n    num_headings   = 0;\n    alloc_headings = 0;\n    heading_pages  = NULL;\n    heading_tops   = NULL;\n  }\n\n  return (0);\n}\n\n\n\n//\n// 'pspdf_debug_stats()' - Display debug statistics for render memory use.\n//\n\nstatic void\npspdf_debug_stats()\n{\n  const char\t*debug;\t\t\t// HTMLDOC_DEBUG env var\n  int\t\ti;\t\t\t// Looping var\n  render_t\t*r;\t\t\t// Render node\n  int\t\tbytes;\t\t\t// Number of bytes\n\n\n  if ((debug = getenv(\"HTMLDOC_DEBUG\")) == NULL ||\n      (strstr(debug, \"all\") == NULL && strstr(debug, \"memory\") == NULL))\n    return;\n\n  bytes = alloc_headings * sizeof(int) * 2;\n\n  bytes += alloc_pages * sizeof(page_t);\n  for (i = 0; i < (int)num_pages; i ++)\n  {\n    for (r = pages[i].start; r != NULL; r = r->next)\n    {\n      bytes += sizeof(render_t);\n\n      if (r->type == RENDER_TEXT)\n        bytes += strlen((char *)r->data.text.buffer);\n    }\n  }\n\n  bytes += num_outpages * sizeof(outpage_t);\n  bytes += alloc_links * sizeof(link_t);\n  bytes += alloc_objects * sizeof(int);\n\n  progress_error(HD_ERROR_NONE, \"DEBUG: Render Data = %d kbytes\",\n                 (bytes + 1023) / 1024);\n}\n\n\n/*\n * 'pspdf_transform_coords()' - Transform page coordinates.\n */\n\nstatic void\npspdf_transform_coords(page_t *p,\t// I - Page\n                       float  &x,\t// IO - X coordinate\n\t\t       float  &y)\t// IO - Y coordinate\n{\n  float tx, ty;\t\t\t\t// Temporary X and Y\n\n\n  tx = x;\n  ty = y;\n  x  = tx * p->outmatrix[0][0] + ty * p->outmatrix[0][1] + p->outmatrix[0][2];\n  y  = tx * p->outmatrix[1][0] + ty * p->outmatrix[1][1] + p->outmatrix[1][2];\n}\n\n\n/*\n * 'pspdf_transform_page()' - Transform a page.\n */\n\nstatic void\npspdf_transform_page(int outpage,\t// I - Output page\n                     int pos,\t\t// I - Position on page\n                     int page)\t\t// I - Input page\n{\n  outpage_t\t*op;\t\t\t// Current output page\n  page_t\t*bp;\t\t\t// Current base page\n  page_t\t*p;\t\t\t// Current input page\n  int\t\tx, y;\t\t\t// Position on output page\n  double\tw, l,\t\t\t// Width and length of subpage\n\t\ttx, ty;\t\t\t// Translation values for subpage\n  double\tpw, pl;\t\t\t// Printable width and length of full page\n\n\n  DEBUG_printf((\"pspdf_transform_page(outpage = %d, pos = %d, page = %d)\\n\",\n                outpage, pos, page));\n\n  if (pos > 15)\n    progress_error(HD_ERROR_INTERNAL_ERROR, \"Internal error: pos = %d\", pos);\n\n  op             = outpages + outpage;\n  op->pages[pos] = page;\n  bp             = pages + op->pages[0];\n  p              = pages + page;\n  p->outpage     = outpage;\n  pw             = bp->width;\n  pl             = bp->length;\n\n  DEBUG_printf((\"    width = %d, length = %d\\n\", p->width, p->length));\n\n  switch (op->nup)\n  {\n    default :\n    case 1 :\n        p->outmatrix[0][0] = 1.0f;\n        p->outmatrix[1][0] = 0.0f;\n        p->outmatrix[0][1] = 0.0f;\n        p->outmatrix[1][1] = 1.0f;\n        p->outmatrix[0][2] = 0.0f;\n        p->outmatrix[1][2] = 0.0f;\n\tbreak;\n\n    case 2 :\n\tx = pos & 1;\n\n        l = pw;\n        w = l * p->width / p->length;\n\n        if (w > (pl * 0.5f))\n        {\n          w = pl * 0.5f;\n          l = w * p->length / p->width;\n        }\n\n        tx = 0.5 * (pl * 0.5 - w);\n        ty = 0.5 * (pw - l);\n\n        p->outmatrix[0][0] = 0.0f;\n        p->outmatrix[1][0] = (float)(w / p->width);\n        p->outmatrix[0][1] = (float)(-w / p->width);\n        p->outmatrix[1][1] = 0.0f;\n        p->outmatrix[0][2] = (float)(ty + pl * w / p->width);\n        p->outmatrix[1][2] = (float)(tx + x * pl / 2);\n\tbreak;\n\n    case 4 :\n        x = pos & 1;\n\ty = 1 - pos / 2;\n\n        w = pw * 0.5;\n\tl = w * p->length / p->width;\n\n\tif (l > (pl * 0.5))\n\t{\n\t  l = pl * 0.5;\n\t  w = l * p->width / p->length;\n\t}\n\n        tx = 0.5 * (pw * 0.5 - w);\n        ty = 0.5 * (pl * 0.5 - l);\n\n        p->outmatrix[0][0] = (float)(w / p->width);\n        p->outmatrix[1][0] = 0.0f;\n        p->outmatrix[0][1] = 0.0f;\n        p->outmatrix[1][1] = (float)(w / p->width);\n        p->outmatrix[0][2] = (float)(tx + x * pw / 2);\n        p->outmatrix[1][2] = (float)(ty + y * pl / 2);\n\tbreak;\n\n    case 6 :\n        x = pos % 3;\n\ty = pos / 3;\n\n        l = pw * 0.5;\n        w = l * p->width / p->length;\n\n        if (w > (pl * 0.333f))\n        {\n          w = pl * 0.333f;\n          l = w * p->length / p->width;\n        }\n\n        tx = 0.5 * (pl * 0.333 - w);\n        ty = 0.5 * (pw * 0.5 - l);\n\n        p->outmatrix[0][0] = 0.0f;\n        p->outmatrix[1][0] = (float)(w / p->width);\n        p->outmatrix[0][1] = (float)(-w / p->width);\n        p->outmatrix[1][1] = 0.0f;\n        p->outmatrix[0][2] = (float)(ty + y * pw / 2 + pl * w / p->width);\n        p->outmatrix[1][2] = (float)(tx + x * pl / 3);\n\tbreak;\n\n    case 9 :\n        x = pos % 3;\n\ty = 2 - pos / 3;\n\n        w = pw * 0.333;\n\tl = w * p->length / p->width;\n\n\tif (l > (pl * 0.333))\n\t{\n\t  l = pl * 0.333;\n\t  w = l * p->width / p->length;\n\t}\n\n        tx = 0.5 * (pw * 0.333 - w);\n        ty = 0.5 * (pl * 0.333 - l);\n\n        p->outmatrix[0][0] = (float)(w / p->width);\n        p->outmatrix[1][0] = 0.0f;\n        p->outmatrix[0][1] = 0.0f;\n        p->outmatrix[1][1] = (float)(w / p->width);\n        p->outmatrix[0][2] = (float)(tx + x * pw / 3);\n        p->outmatrix[1][2] = (float)(ty + y * pl / 3);\n\tbreak;\n\n    case 16 :\n        x = pos & 3;\n\ty = 3 - pos / 4;\n\n        w = pw * 0.25;\n\tl = w * p->length / p->width;\n\n\tif (l > (pl * 0.25))\n\t{\n\t  l = pl * 0.25;\n\t  w = l * p->width / p->length;\n\t}\n\n        tx = 0.5 * (pw * 0.25 - w);\n        ty = 0.5 * (pl * 0.25 - l);\n\n        p->outmatrix[0][0] = (float)(w / p->width);\n        p->outmatrix[1][0] = 0.0f;\n        p->outmatrix[0][1] = 0.0f;\n        p->outmatrix[1][1] = (float)(w / p->width);\n        p->outmatrix[0][2] = (float)(tx + x * pw / 4);\n        p->outmatrix[1][2] = (float)(ty + y * pl / 4);\n\tbreak;\n  }\n}\n\n\n/*\n * 'pspdf_prepare_outpages()' - Prepare output pages...\n */\n\nstatic void\npspdf_prepare_outpages()\n{\n  int\t\tc, i, j;\t/* Looping vars */\n  int\t\tnup;\t\t/* Current number-up value */\n  page_t\t*page;\t\t/* Current page */\n  outpage_t\t*outpage;\t/* Current output page */\n\n\n  // Allocate an output page array...\n  outpages = (outpage_t *)malloc(sizeof(outpage_t) * num_pages);\n\n  memset(outpages, -1, sizeof(outpage_t) * num_pages);\n\n  num_outpages = 0;\n  outpage      = outpages;\n\n  // Handle the title page, as needed...\n  if (TitlePage)\n  {\n    for (i = 0, j = 0, nup = -1, page = pages;\n         i < chapter_starts[1];\n\t i ++, page ++)\n    {\n      if (nup != page->nup)\n      {\n        if (j)\n\t{\n\t  // Break the current output page...\n\t  outpage ++;\n\t  num_outpages ++;\n\t}\n\n\tnup = page->nup;\n\tj   = 0;\n      }\n\n      if (!j)\n\toutpage->nup = nup;\n\n      pspdf_transform_page(num_outpages, j, i);\n      j ++;\n\n      if (j >= nup)\n      {\n        j = 0;\n\toutpage ++;\n\tnum_outpages ++;\n      }\n    }\n\n    if (j)\n    {\n      // Break the current output page...\n      outpage ++;\n      num_outpages ++;\n    }\n  }\n\n  // Loop through each chapter, adding pages as needed...\n  if (OutputType == OUTPUT_BOOK && TocLevels > 0)\n    c = 0;\n  else\n    c = 1;\n\n  for (; c <= TocDocCount; c ++)\n  {\n    if (chapter_starts[c] < 0)\n      continue;\n\n    chapter_outstarts[c] = num_outpages;\n\n    for (i = chapter_starts[c], j = 0, nup = -1, page = pages + i;\n         i <= chapter_ends[c];\n\t i ++, page ++)\n    {\n      if (nup != page->nup)\n      {\n        if (j)\n\t{\n\t  // Break the current output page...\n\t  outpage ++;\n\t  num_outpages ++;\n\t}\n\n\tnup = page->nup;\n\tj   = 0;\n      }\n\n      if (!j)\n\toutpage->nup = nup;\n\n      pspdf_transform_page(num_outpages, j, i);\n      j ++;\n\n      if (j >= nup)\n      {\n        j = 0;\n\toutpage ++;\n\tnum_outpages ++;\n      }\n    }\n\n    if (j)\n    {\n      // Break the current output page...\n      outpage ++;\n      num_outpages ++;\n    }\n\n    chapter_outends[c] = num_outpages;\n  }\n\n#ifdef DEBUG\n  for (c = 0; c <= TocDocCount; c ++)\n    printf(\"chapter_outstarts[%d] = %d, chapter_outends[%d] = %d\\n\",\n           c, chapter_outstarts[c], c, chapter_outends[c]);\n\n  printf(\"num_outpages = %d\\n\", (int)num_outpages);\n  for (i = 0, outpage = outpages; i < (int)num_outpages; i ++, outpage ++)\n  {\n    printf(\"outpage[%d]:\\tnup=%d, pages=[\", i, outpage->nup);\n    for (j = 0; j < outpage->nup; j ++)\n      printf(\" %d\", outpage->pages[j]);\n    puts(\" ]\");\n    page = pages + outpage->pages[0];\n    printf(\"\\t\\twidth = %d, length = %d\\n\", page->width, page->length);\n  }\n\n  for (c = 0; c <= TocDocCount; c ++)\n    printf(\"chapter_starts[%d] = %d, chapter_ends[%d] = %d\\n\",\n           c, chapter_starts[c], c, chapter_ends[c]);\n\n  for (i = 0; i < (int)num_pages; i ++)\n    printf(\"pages[%d]->outpage = %d\\n\", i, pages[i].outpage);\n\n  for (i = 0; i < (int)num_headings; i ++)\n    printf(\"heading_pages[%d] = %d\\n\", i, heading_pages[i]);\n\n  for (i = 0; i < (int)num_links; i ++)\n    printf(\"links[%d].name = \\\"%s\\\", page = %d\\n\", i,\n           links[i].name, links[i].page);\n#endif // DEBUG\n}\n\n\n/*\n * 'pspdf_prepare_page()' - Add headers/footers to page before writing...\n */\n\nstatic void\npspdf_prepare_page(int page)\t\t/* I - Page number */\n{\n  int\tprint_page;\t\t\t/* Printed page # */\n  char\tpage_text[64];\t\t\t/* Page number text */\n  int\ttop;\t\t\t\t/* Top of page */\n\n\n  DEBUG_printf((\"pspdf_prepare_page(%d)\\n\", page));\n\n /*\n  * Make a page number; use roman numerals for the table of contents\n  * and arabic numbers for all others...\n  */\n\n  if (chapter == 0 && OutputType == OUTPUT_BOOK)\n  {\n    print_page = page - chapter_starts[0] + 1;\n    strlcpy(page_text, format_number(print_page, 'i'), sizeof(page_text));\n  }\n  else if (chapter < 0)\n  {\n    print_page = 0;\n    // Safe because page_text is more than 6 chars\n    strlcpy(page_text, (page & 1) ? (char *)\"eltit\" : (char *)\"title\", sizeof(page_text));\n  }\n  else\n  {\n    print_page = page - chapter_starts[1] + 1;\n    strlcpy(page_text, format_number(print_page, '1'), sizeof(page_text));\n  }\n\n  DEBUG_printf((\"BEFORE page %d page_text is \\\"%s\\\"...\\n\", page, page_text));\n\n  DEBUG_printf((\"    header[0] = \\\"%s\\\"\\n\", pages[page].header[0]));\n  DEBUG_printf((\"    header[1] = \\\"%s\\\"\\n\", pages[page].header[1]));\n  DEBUG_printf((\"    header[2] = \\\"%s\\\"\\n\", pages[page].header[2]));\n\n /*\n  * Add page headings...\n  */\n\n  if (pages[page].landscape)\n  {\n    PagePrintWidth  = pages[page].length - pages[page].right - pages[page].left;\n    PagePrintLength = pages[page].width - pages[page].top - pages[page].bottom;\n  }\n  else\n  {\n    PagePrintWidth  = pages[page].width - pages[page].right - pages[page].left;\n    PagePrintLength = pages[page].length - pages[page].top - pages[page].bottom;\n  }\n\n  top = (int)(PagePrintLength - HeadFootSize);\n\n  if (chapter == 0)\n  {\n   /*\n    * Add table-of-contents header & footer...\n    */\n\n    pspdf_prepare_heading(page, print_page, pages[page].header, top,\n                          page_text, sizeof(page_text));\n    pspdf_prepare_heading(page, print_page, pages[page].footer, 0,\n                          page_text, sizeof(page_text));\n  }\n  else if (chapter > 0 && !title_page)\n  {\n   /*\n    * Add chapter header & footer...\n    */\n\n    if (page > chapter_starts[chapter] || OutputType != OUTPUT_BOOK)\n      pspdf_prepare_heading(page, print_page, pages[page].header, top,\n                            page_text, sizeof(page_text));\n    else\n      pspdf_prepare_heading(page, print_page, pages[page].header1, top,\n                            page_text, sizeof(page_text));\n    pspdf_prepare_heading(page, print_page, pages[page].footer, 0,\n                          page_text, sizeof(page_text));\n  }\n\n /*\n  * Copy the page number for the TOC...\n  */\n\n  strlcpy(pages[page].page_text, page_text, sizeof(pages[page].page_text));\n\n  DEBUG_printf((\"AFTER page %d page_text is \\\"%s\\\"...\\n\", page, page_text));\n}\n\n\n/*\n * 'pspdf_prepare_heading()' - Add headers/footers to page before writing...\n */\n\nstatic void\npspdf_prepare_heading(int   page,\t// I - Page number\n                      int   print_page,\t// I - Printed page number\n\t\t      uchar **format,\t// I - Page headings\n\t\t      int   y,\t\t// I - Baseline of heading\n\t\t      char  *page_text,\t// O - Page number text\n\t\t      int   page_len)\t// I - Size of page text\n{\n  int\t\tpos,\t\t\t// Position in heading\n\t\tdir;\t\t\t// Direction of page\n  char\t\t*number;\t\t// Page number\n  char\t\tbuffer[1024],\t\t// String buffer\n\t\t*bufptr,\t\t// Pointer into buffer\n\t\t*formatptr;\t\t// Pointer into format string\n  int\t\tformatlen;\t\t// Length of format command string\n  render_t\t*temp;\t\t\t// Render structure for titles, etc.\n\n\n  DEBUG_printf((\"pspdf_prepare_heading(%d, %d, [\\\"%s\\\",\\\"%s\\\",\\\"%s\\\"], %d, %p, %d)\\n\",\n                page, print_page, format[0], format[1], format[2], y,\n\t\t(void *)page_text, page_len));\n\n /*\n  * Add page headings...\n  */\n\n  if (PageDuplex && (page & 1))\n  {\n    dir    = -1;\n    format += 2;\n  }\n  else\n    dir = 1;\n\n  for (pos = 0; pos < 3; pos ++, format += dir)\n  {\n   /*\n    * Add the appropriate object...\n    */\n\n    if (!*format)\n      continue;\n\n    temp = NULL;\n\n    if (strncasecmp((char *)*format, \"$LOGOIMAGE\", 10) == 0 && logo_image)\n    {\n      // Insert the logo image...\n      if (y < (PagePrintLength / 2))\n\ttemp = new_render(page, RENDER_IMAGE, 0, y, logo_width,\n\t                  logo_height, logo_image);\n      else // Offset from top\n\ttemp = new_render(page, RENDER_IMAGE, 0,\n\t                  y + HeadFootSize - logo_height,\n\t                  logo_width, logo_height, logo_image);\n    }\n    else if (strncasecmp((char *)*format, \"$LETTERHEAD\", 11) == 0 && lh_image)\n    {\n      // Insert the logo image as a letterhead...\n      if (y < (PagePrintLength / 2))\n\ttemp = new_render(page, RENDER_IMAGE, 0, y, lh_width, lh_height, lh_image);\n      else // Offset from top\n\ttemp = new_render(page, RENDER_IMAGE, 0, y + HeadFootSize - lh_height, lh_width, lh_height, lh_image);\n    }\n    else if (strncasecmp((char *)*format, \"$HFIMAGE\", 8) == 0)\n    {\n      int\thfi;\t\t\t// Header/footer image index\n      char\t*hfp;\t\t\t// Pointer into $HFIMAGE\n\n\n      hfi = strtol((char*)((*format) + 8), &hfp, 10);\n\n      if (hfi < 0 || hfi >= MAX_HF_IMAGES || !(isspace(*hfp) || !*hfp))\n        progress_error(HD_ERROR_BAD_HF_STRING,\n\t               \"Bad $HFIMAGE... substitution on page %d.\", page + 1);\n      else\n      {\n        if (y < (PagePrintLength / 2))\n          temp = new_render(page, RENDER_IMAGE, 0, y, hfimage_width[hfi],\n                            hfimage_height[hfi], hfimage[hfi]);\n        else\n          temp = new_render(page, RENDER_IMAGE, 0,\n                            y + HeadFootSize - hfimage_height[hfi],\n                            hfimage_width[hfi], hfimage_height[hfi],\n\t\t\t    hfimage[hfi]);\n      }\n    }\n    else\n    {\n      // Otherwise format the text...\n      buffer[sizeof(buffer) - 1] = '\\0';\n\n      for (bufptr = buffer, formatptr = (char *)*format; *formatptr;)\n      {\n        if (*formatptr == '$')\n\t{\n\t  if (formatptr[1] == '$')\n\t  {\n\t    if (bufptr < (buffer + sizeof(buffer) - 1))\n\t      *bufptr++ = '$';\n\n\t    formatptr += 2;\n\t    continue;\n\t  }\n\t  else if (!formatptr[1])\n\t    break;\n\n          formatptr ++;\n\t  for (formatlen = 1; isalpha(formatptr[formatlen]); formatlen ++);\n\n\t  if (formatlen == 4 && strncasecmp(formatptr, \"PAGE\", 4) == 0)\n\t  {\n\t    if (formatptr[4] == '(' && formatptr[5] && formatptr[6] == ')')\n            {\n\t      number = format_number(print_page, formatptr[5]);\n\t      formatptr += 7;\n\t    }\n\t    else\n\t    {\n\t      number = format_number(print_page, '1');\n\t      formatptr += 4;\n\t    }\n\n            strlcpy(bufptr, number, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else if (formatlen == 5 && strncasecmp(formatptr, \"PAGES\", 5) == 0)\n\t  {\n\t    if (formatptr[5] == '(' && formatptr[6] && formatptr[7] == ')')\n            {\n\t      number = format_number(chapter_ends[TocDocCount] -\n\t                             chapter_starts[1] + 1, formatptr[6]);\n\t      formatptr += 8;\n\t    }\n\t    else\n\t    {\n\t      number = format_number(chapter_ends[TocDocCount] -\n\t                             chapter_starts[1] + 1, '1');\n\t      formatptr += 5;\n\t    }\n\n            strlcpy(bufptr, number, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else if (formatlen == 11 && strncasecmp(formatptr, \"CHAPTERPAGE\", 11) == 0)\n\t  {\n\t    int chapter_page;\n\n\t    chapter_page = print_page - chapter_starts[::chapter] +\n\t                   chapter_starts[1];\n\n\t    if (formatptr[11] == '(' && formatptr[12] && formatptr[13] == ')')\n            {\n\t      number = format_number(chapter_page, formatptr[12]);\n\t      formatptr += 14;\n\t    }\n\t    else\n\t    {\n\t      number = format_number(chapter_page, '1');\n\t      formatptr += 11;\n\t    }\n\n            strlcpy(bufptr, number, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else if (formatlen == 12 && strncasecmp(formatptr, \"CHAPTERPAGES\", 12) == 0)\n\t  {\n\t    if (formatptr[12] == '(' && formatptr[13] && formatptr[14] == ')')\n            {\n\t      number = format_number(chapter_ends[::chapter] -\n\t                             chapter_starts[::chapter] + 1,\n\t\t\t\t     formatptr[13]);\n\t      formatptr += 15;\n\t    }\n\t    else\n\t    {\n\t      number = format_number(chapter_ends[::chapter] -\n\t                             chapter_starts[::chapter] + 1, '1');\n\t      formatptr += 12;\n\t    }\n\n            strlcpy(bufptr, number, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else if (formatlen == 5 && strncasecmp(formatptr, \"TITLE\", 5) == 0)\n\t  {\n            formatptr += 5;\n\t    if (doc_title)\n\t    {\n              strlcpy(bufptr, (char *)doc_title, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t      bufptr += strlen(bufptr);\n\t    }\n\t  }\n\t  else if (formatlen == 7 && strncasecmp(formatptr, \"CHAPTER\", 7) == 0)\n\t  {\n            formatptr += 7;\n\t    if (pages[page].chapter)\n\t    {\n              strlcpy(bufptr, (char *)(pages[page].chapter), sizeof(buffer) - (size_t)(bufptr - buffer));\n\t      bufptr += strlen(bufptr);\n\t    }\n\t  }\n\t  else if (formatlen == 7 && strncasecmp(formatptr, \"HEADING\", 7) == 0)\n\t  {\n            formatptr += 7;\n\t    if (pages[page].heading)\n\t    {\n              strlcpy(bufptr, (char *)(pages[page].heading), sizeof(buffer) - (size_t)(bufptr - buffer));\n\t      bufptr += strlen(bufptr);\n\t    }\n\t  }\n\t  else if (formatlen == 4 && strncasecmp(formatptr, \"TIME\", 4) == 0)\n\t  {\n            formatptr += 4;\n            strftime(bufptr, sizeof(buffer) - 1 - (size_t)(bufptr - buffer), \"%X\", &doc_date);\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else if (formatlen == 4 && strncasecmp(formatptr, \"DATE\", 4) == 0)\n\t  {\n            formatptr += 4;\n            strftime(bufptr, sizeof(buffer) - 1 - (size_t)(bufptr - buffer), \"%x\", &doc_date);\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else if (formatlen == 3 && strncasecmp(formatptr, \"URL\", 3) == 0)\n\t  {\n            uchar *url = pages[page].url ? pages[page].url : (uchar *)\"Unknown\";\n\n            formatptr += 3;\n            strlcpy(bufptr, (char *)url, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t    bufptr += strlen(bufptr);\n\t  }\n\t  else\n\t  {\n            progress_error(HD_ERROR_BAD_HF_STRING, \"Bad header/footer $ command on page %d.\", page + 1);\n\n            strlcpy(bufptr, formatptr - 1, sizeof(buffer) - (size_t)(bufptr - buffer));\n\t    bufptr += strlen(bufptr);\n\t    formatptr += formatlen;\n\t  }\n\t}\n\telse if (bufptr < (buffer + sizeof(buffer) - 1))\n\t  *bufptr++ = *formatptr++;\n\telse\n\t  break;\n      }\n\n      *bufptr = '\\0';\n\n      temp = new_render(page, RENDER_TEXT, 0, y,\n                \tget_width((uchar *)buffer, HeadFootType,\n\t\t\t          HeadFootStyle, SIZE_P) * HeadFootSize /\n\t\t\t    _htmlSizes[SIZE_P],\n\t        \tHeadFootSize, (uchar *)buffer);\n\n      if (strstr((char *)*format, \"$PAGE\") ||\n          strstr((char *)*format, \"$CHAPTERPAGE\"))\n        strlcpy(page_text, buffer, (size_t)page_len);\n    }\n\n    if (temp == NULL)\n      continue;\n\n   /*\n    * Justify the object...\n    */\n\n    switch (pos)\n    {\n      case 0 : /* Left justified */\n          break;\n      case 1 : /* Centered */\n          temp->x = (float)((PagePrintWidth - temp->width) * 0.5);\n          break;\n      case 2 : /* Right justified */\n          temp->x = PagePrintWidth - temp->width;\n          break;\n    }\n\n   /*\n    * Set the text font and color...\n    */\n\n    if (temp->type == RENDER_TEXT)\n    {\n      temp->data.text.typeface = HeadFootType;\n      temp->data.text.style    = HeadFootStyle;\n      temp->data.text.size     = (float)HeadFootSize;\n\n      get_color(_htmlTextColor, temp->data.text.rgb);\n    }\n  }\n}\n\n\n/*\n * 'ps_write_document()' - Write all render entities to PostScript file(s).\n */\n\nstatic void\nps_write_document(uchar *author,\t/* I - Author of document */\n        \t  uchar *creator,\t/* I - Application that generated the HTML file */\n        \t  uchar *copyright,\t/* I - Copyright (if any) on the document */\n                  uchar *keywords,\t/* I - Search keywords */\n\t\t  uchar *subject,\t/* I - Subject */\n\t\t  uchar *lang)\t\t/* I - Language */\n{\n  FILE\t\t*out;\t\t\t/* Output file */\n  int\t\tpage;\t\t\t/* Current page # */\n  int\t\tfirst;\t\t\t/* First chapter */\n\n\n /*\n  * Write the title page(s)...\n  */\n\n  chapter = -1;\n  out     = NULL;\n\n  if (!OutputFiles)\n  {\n    out = open_file();\n\n    if (out == NULL)\n    {\n      progress_error(HD_ERROR_WRITE_ERROR,\n                     \"Unable to open output file - %s\\n\", strerror(errno));\n      return;\n    }\n\n    write_prolog(out, num_outpages, author, creator, copyright, keywords, subject);\n  }\n\n  if (OutputType == OUTPUT_BOOK && TocLevels > 0)\n    first = 0;\n  else\n    first = 1;\n\n  if (TitlePage)\n  {\n    if (OutputFiles)\n    {\n      out = open_file();\n      write_prolog(out, chapter_outstarts[first], author, creator, copyright,\n                   keywords, subject);\n    }\n\n    for (page = 0; page < chapter_outstarts[first]; page ++)\n      ps_write_outpage(out, page);\n\n    if (OutputFiles)\n    {\n      write_trailer(out, 0, lang);\n\n      progress_error(HD_ERROR_NONE, \"BYTES: %ld\", ftell(out));\n\n      fclose(out);\n    }\n  }\n\n  for (chapter = first; chapter <= TocDocCount; chapter ++)\n  {\n    if (chapter_starts[chapter] < 0)\n      continue;\n\n    if (OutputFiles)\n    {\n      out = open_file();\n      if (out == NULL)\n      {\n        progress_error(HD_ERROR_WRITE_ERROR,\n\t               \"Unable to create output file - %s\\n\", strerror(errno));\n        return;\n      }\n\n      write_prolog(out, chapter_outends[chapter] - chapter_outstarts[chapter],\n                   author, creator, copyright, keywords, subject);\n    }\n\n    for (page = chapter_outstarts[chapter];\n         page < chapter_outends[chapter];\n         page ++)\n      ps_write_outpage(out, page);\n\n   /*\n    * Close the output file as necessary...\n    */\n\n    if (OutputFiles)\n    {\n      write_trailer(out, 0, lang);\n\n      progress_error(HD_ERROR_NONE, \"BYTES: %ld\", ftell(out));\n\n      fclose(out);\n    }\n  }\n\n /*\n  * Close the output file as necessary...\n  */\n\n  if (!OutputFiles)\n  {\n    write_trailer(out, 0, lang);\n\n    progress_error(HD_ERROR_NONE, \"BYTES: %ld\", ftell(out));\n\n    if (out != stdout)\n      fclose(out);\n  }\n\n  if (Verbosity)\n    progress_hide();\n}\n\n\n/*\n * 'ps_write_outpage()' - Write an output page.\n */\n\nstatic void\nps_write_outpage(FILE *out,\t/* I - Output file */\n                 int  outpage)\t/* I - Output page number */\n{\n  int\t\tfile_page;\t/* Current page # in document */\n  page_t\t*p;\t\t/* Current page */\n  outpage_t\t*op;\t\t/* Current output page */\n  int\t\ti;\t\t/* Looping var */\n\n\n  if (outpage < 0 || outpage >= (int)num_outpages)\n    return;\n\n  op = outpages + outpage;\n  p  = pages + op->pages[0];\n\n  DEBUG_printf((\"ps_write_outpage(%p, %d)\\n\", (void *)out, outpage));\n\n /*\n  * Let the user know which page we are writing...\n  */\n\n  if (Verbosity)\n  {\n    progress_show(\"Writing page %s...\", p->page_text);\n    progress_update(100 * outpage / (int)num_outpages);\n  }\n\n /*\n  * Figure out the page number in the file...\n  */\n\n  if (OutputFiles && chapter >= 0)\n    file_page = outpage - chapter_outstarts[chapter] + 1;\n  else if (chapter < 0)\n    file_page = outpage + 1;\n  else if (chapter == 0)\n  {\n    if (TitlePage)\n      file_page = outpage + 1;\n    else\n      file_page = outpage - chapter_outstarts[0] + 1;\n  }\n  else\n  {\n    if (TitlePage)\n      file_page = outpage + 1;\n    else\n      file_page = outpage - chapter_outstarts[1] + 1;\n  }\n\n /*\n  * Output the page prolog...\n  */\n\n  fprintf(out, \"%%%%Page: (%s) %d\\n\", p->page_text, file_page);\n  if (op->nup == 1)\n  {\n    if (p->duplex && !(file_page & 1))\n      fprintf(out, \"%%%%PageBoundingBox: %d %d %d %d\\n\",\n              p->right, p->bottom, p->width - p->left, p->length - p->top);\n    else\n      fprintf(out, \"%%%%PageBoundingBox: %d %d %d %d\\n\",\n              p->left, p->bottom, p->width - p->right, p->length - p->top);\n  }\n  else\n    fprintf(out, \"%%%%PageBoundingBox: 0 0 %d %d\\n\", p->width, p->length);\n\n  if (PSLevel > 1 && PSCommands)\n  {\n    fputs(\"%%BeginPageSetup\\n\", out);\n\n    if (p->width == 612 && p->length == 792)\n      fputs(\"%%BeginFeature: *PageSize Letter\\n\", out);\n    else if (p->width == 612 && p->length == 1008)\n      fputs(\"%%BeginFeature: *PageSize Legal\\n\", out);\n    else if (p->width == 792 && p->length == 1224)\n      fputs(\"%%BeginFeature: *PageSize Tabloid\\n\", out);\n    else if (p->width == 842 && p->length == 1190)\n      fputs(\"%%BeginFeature: *PageSize A3\\n\", out);\n    else if (p->width == 595 && p->length == 842)\n      fputs(\"%%BeginFeature: *PageSize A4\\n\", out);\n    else\n      fprintf(out, \"%%%%BeginFeature: *PageSize w%dh%d\\n\", p->width,\n\t      p->length);\n\n    fprintf(out, \"%d %d SetPageSize\\n\", p->width, p->length);\n    fputs(\"%%EndFeature\\n\", out);\n\n    if (p->duplex)\n    {\n      if (p->landscape)\n      {\n\tfputs(\"%%BeginFeature: *Duplex DuplexTumble\\n\", out);\n\tfputs(\"true true SetDuplexMode\\n\", out);\n        fputs(\"%%EndFeature\\n\", out);\n      }\n      else\n      {\n\tfputs(\"%%BeginFeature: *Duplex DuplexNoTumble\\n\", out);\n\tfputs(\"true false SetDuplexMode\\n\", out);\n        fputs(\"%%EndFeature\\n\", out);\n      }\n    }\n    else\n    {\n      fputs(\"%%BeginFeature: *Duplex None\\n\", out);\n      fputs(\"false false SetDuplexMode\\n\", out);\n      fputs(\"%%EndFeature\\n\", out);\n    }\n\n    if (p->media_color[0])\n    {\n      fprintf(out, \"%%%%BeginFeature: *MediaColor %s\\n\", p->media_color);\n      fprintf(out, \"(%s) SetMediaColor\\n\", p->media_color);\n      fputs(\"%%EndFeature\\n\", out);\n    }\n\n    if (p->media_position)\n    {\n      fprintf(out, \"%%%%BeginFeature: *InputSlot Tray%d\\n\",\n              p->media_position);\n      fprintf(out, \"%d SetMediaPosition\\n\", p->media_position);\n      fputs(\"%%EndFeature\\n\", out);\n    }\n\n    if (p->media_type[0])\n    {\n      fprintf(out, \"%%%%BeginFeature: *MediaType %s\\n\", p->media_type);\n      fprintf(out, \"(%s) SetMediaType\\n\", p->media_type);\n      fputs(\"%%EndFeature\\n\", out);\n    }\n\n    fputs(\"%%EndPageSetup\\n\", out);\n  }\n\n /*\n  * Render all of the pages...\n  */\n\n  switch (op->nup)\n  {\n    case 1 :\n        ps_write_page(out, op->pages[0]);\n\tbreak;\n\n    default :\n        for (i = 0; i < op->nup; i ++)\n\t{\n\t  if (op->pages[i] < 0)\n\t    break;\n\n          p = pages + op->pages[i];\n\n          fprintf(out, \"GS[%.3f %.3f %.3f %.3f %.3f %.3f]CM\\n\",\n\t          p->outmatrix[0][0], p->outmatrix[1][0],\n\t          p->outmatrix[0][1], p->outmatrix[1][1],\n\t          p->outmatrix[0][2], p->outmatrix[1][2]);\n          ps_write_page(out, op->pages[i]);\n\t  fputs(\"GR\\n\", out);\n\t}\n\tbreak;\n  }\n\n /*\n  * Output the page trailer...\n  */\n\n  fputs(\"SP\\n\", out);\n  fflush(out);\n}\n\n\n/*\n * 'ps_write_page()' - Write all render entities on a page to a PostScript file.\n */\n\nstatic void\nps_write_page(FILE  *out,\t/* I - Output file */\n              int   page)\t/* I - Page number */\n{\n  render_t\t*r,\t\t/* Render pointer */\n\t\t*next;\t\t/* Next render */\n  page_t\t*p;\t\t/* Current page */\n  const char\t*debug;\t\t/* HTMLDOC_DEBUG environment variable */\n\n\n  if (page < 0 || page >= (int)alloc_pages)\n    return;\n\n  p = pages + page;\n\n  DEBUG_printf((\"ps_write_page(%p, %d)\\n\", (void *)out, page));\n\n /*\n  * Clear the render cache...\n  */\n\n  render_typeface = -1;\n  render_style    = -1;\n  render_size     = -1;\n  render_rgb[0]   = -1.0f;\n  render_rgb[1]   = -1.0f;\n  render_rgb[2]   = -1.0f;\n  render_x        = -1.0f;\n  render_y        = -1.0f;\n  render_spacing  = -1.0f;\n\n /*\n  * Setup the page...\n  */\n\n  fputs(\"GS\\n\", out);\n\n  if (p->landscape)\n  {\n    if (p->duplex && (page & 1))\n      fprintf(out, \"0 %d T -90 RO\\n\", p->length);\n    else\n      fprintf(out, \"%d 0 T 90 RO\\n\", p->width);\n  }\n\n  write_background(page, out);\n\n  if (p->duplex && (page & 1))\n    fprintf(out, \"%d %d T\\n\", p->right, p->bottom);\n  else\n    fprintf(out, \"%d %d T\\n\", p->left, p->bottom);\n\n /*\n  * Render all graphics elements...\n  */\n\n  for (r = p->start; r != NULL; r = r->next)\n    switch (r->type)\n    {\n      case RENDER_BOX :\n\t  set_color(out, r->data.box);\n\t  set_pos(out, r->x, r->y);\n\t  if (r->height > 0.0f)\n            fprintf(out, \" %.1f %.1f F\\n\", r->width, r->height);\n\t  else\n            fprintf(out, \" %.1f L\\n\", r->width);\n\n\t  render_x = -1.0f;\n\t  break;\n\n      case RENDER_IMAGE :\n          if (r->width > 0.01f && r->height > 0.01f)\n            write_image(out, r);\n          break;\n    }\n\n /*\n  * Render all text elements, freeing used memory as we go...\n  */\n\n  for (r = p->start, next = NULL; r != NULL; r = next)\n  {\n    if (r->type == RENDER_TEXT)\n      write_text(out, r);\n\n    next = r->next;\n    free(r);\n  }\n\n  p->start = NULL;\n\n  if ((debug = getenv(\"HTMLDOC_DEBUG\")) != NULL && strstr(debug, \"margin\"))\n  {\n    // Show printable area...\n    fprintf(out, \"1 0 1 C 0 0 %d %d B\\n\", p->width - p->right - p->left,\n        \t p->length - p->top - p->bottom);\n  }\n\n /*\n  * Output the page trailer...\n  */\n\n  fputs(\"GR\\n\", out);\n}\n\n\n/*\n * 'ps_write_background()' - Write a background image...\n */\n\nstatic void\nps_write_background(FILE *out)\t\t/* I - Output file */\n{\n  int\ty,\t\t\t\t/* Current line */\n\tpwidth;\t\t\t\t/* Pixel width */\n\n\n  if (!background_image->pixels)\n    image_load(background_image->filename, !OutputColor, 1);\n\n  pwidth = background_image->width * background_image->depth;\n\n  fputs(\"/BG[\", out);\n  for (y = 0; y < background_image->height; y ++)\n  {\n    putc('<', out);\n    ps_hex(out, background_image->pixels + y * pwidth, pwidth);\n    putc('>', out);\n  }\n  fputs(\"]def\", out);\n\n  image_unload(background_image);\n}\n\n\n/*\n * 'pdf_write_document()' - Write all render entities to a PDF file.\n */\n\nstatic void\npdf_write_document(uchar  *author,\t// I - Author of document\n        \t   uchar  *creator,\t// I - Application that generated the HTML file\n        \t   uchar  *copyright,\t// I - Copyright (if any) on the document\n                   uchar  *keywords,\t// I - Search keywords\n\t\t   uchar  *subject,\t// I - Subject\n\t\t   uchar  *lang,\t// I - Language\n\t\t   tree_t *doc,\t\t// I - Document\n                   tree_t *toc)\t\t// I - Table of contents tree\n{\n  int\t\ti;\t\t\t// Looping variable\n  FILE\t\t*out;\t\t\t// Output file\n  int\t\toutpage,\t\t// Current page #\n\t\theading;\t\t// Current heading #\n  int\t\tbytes;\t\t\t// Number of bytes\n  char\t\tbuffer[8192];\t\t// Copy buffer\n  int\t\tnum_images;\t\t// Number of images in document\n  image_t\t**images;\t\t// Pointers to images\n  render_t\ttemp;\t\t\t// Dummy rendering data...\n\n\n  // Open the output file...\n  out = open_file();\n  if (out == NULL)\n  {\n    progress_error(HD_ERROR_WRITE_ERROR,\n                   \"Unable to write document file - %s\\n\", strerror(errno));\n    return;\n  }\n\n  // Clear the objects array...\n  num_objects   = 0;\n  alloc_objects = 0;\n  objects       = NULL;\n\n  // Write the prolog...\n  write_prolog(out, num_outpages, author, creator, copyright, keywords, subject);\n\n  // Write images as needed...\n  num_images = image_getlist(&images);\n\n  for (i = 0; i < num_images; i ++)\n  {\n    int\thfi;\t\t\t\t// Header/footer image index\n\n\n    for (hfi = 0; hfi < MAX_HF_IMAGES; hfi ++)\n      if (images[i] == hfimage[hfi])\n        break;\n\n    if (images[i]->use > 1 || images[i]->mask ||\n        (images[i]->width * images[i]->height * images[i]->depth) > 65536 ||\n\timages[i] == background_image ||\n\timages[i] == logo_image ||\n\thfi < MAX_HF_IMAGES)\n    {\n      progress_show(\"Writing image %d (%s)...\", i + 1, images[i]->filename);\n      progress_update(100 * i / num_images);\n\n      temp.data.image = images[i];\n      write_image(out, &temp, 1);\n    }\n  }\n\n  // Write links and target names...\n  pdf_write_links(out);\n  if (PDFVersion >= 12)\n    pdf_write_names(out);\n\n  // Verify that everything is working so far...\n  pdf_start_object(out);\n\n  if (pages_object != (int)num_objects)\n    progress_error(HD_ERROR_INTERNAL_ERROR,\n                   \"Internal error: pages_object != num_objects\");\n\n  fputs(\"/Type/Pages\", out);\n  fprintf(out, \"/Count %d\", (int)num_outpages);\n  fputs(\"/Kids[\", out);\n\n  for (outpage = 0; outpage < (int)num_outpages; outpage ++)\n    fprintf(out, \"%d 0 R\\n\", pages_object + outpage * 2 + 1);\n\n  fputs(\"]\", out);\n  pdf_end_object(out);\n\n  for (outpage = 0; outpage < (int)num_outpages; outpage ++)\n    pdf_write_outpage(out, outpage);\n\n  if (OutputType == OUTPUT_BOOK && TocLevels > 0)\n  {\n   /*\n    * Write the outline tree using the table-of-contents...\n    */\n\n    heading = 0;\n#ifdef DEBUG_TOC\n    pdf_text_contents(out, toc);\n#endif // DEBUG_TOC\n    pdf_write_contents(out, toc, 0, 0, 0, &heading);\n  }\n  else\n  {\n   /*\n    * Write the outline tree using the HTML files.\n    */\n\n    pdf_write_files(out, doc);\n  }\n\n /*\n  * Write the trailer and close the output file...\n  */\n\n  write_trailer(out, 0, lang);\n\n  progress_error(HD_ERROR_NONE, \"BYTES: %ld\", ftell(out));\n\n  if (CGIMode)\n  {\n    const char\t*meta_filename = (const char *)htmlGetMeta(doc, (uchar *)\"HTMLDOC.filename\");\n    const char\t*filename;\n\n    if (meta_filename)\n    {\n      if ((filename = strrchr(meta_filename, '/')) != NULL)\n        filename ++;\n      else\n        filename = meta_filename;\n    }\n    else\n      filename = \"htmldoc.pdf\";\n\n    // In CGI mode, we only produce PDF output to stdout...\n    printf(\"Content-Type: application/pdf\\r\\n\"\n\t   \"Content-Length: %ld\\r\\n\"\n\t   \"Content-Disposition: inline; filename=\\\"%s\\\"\\r\\n\"\n\t   \"Accept-Ranges: none\\r\\n\"\n\t   \"X-Creator: HTMLDOC \" SVERSION \"\\r\\n\"\n\t   \"\\r\\n\", ftell(out), filename);\n  }\n\n  fclose(out);\n\n  //\n  // If we are sending the output to stdout, copy the temp file now...\n  //\n\n  if (!OutputPath[0])\n  {\n#ifdef WIN32\n    // Make sure we are in binary mode...  stupid Microsoft!\n    setmode(1, O_BINARY);\n#elif defined(__EMX__)\n   // OS/2 has a setmode for FILE's...\n   fflush(stdout);\n   _fsetmode(stdout, \"b\");\n#endif // WIN32 || __EMX__\n\n    // Open the temporary file and copy it to stdout...\n    out = fopen(stdout_filename, \"rb\");\n\n    while ((bytes = fread(buffer, 1, sizeof(buffer), out)) > 0)\n      fwrite(buffer, 1, (size_t)bytes, stdout);\n\n    // Close the temporary file (it is removed when the program exits...)\n    fclose(out);\n  }\n\n  // Clear the objects array...\n  if (alloc_objects)\n  {\n    free(objects);\n\n    num_objects   = 0;\n    alloc_objects = 0;\n    objects       = NULL;\n  }\n\n  if (Verbosity)\n    progress_hide();\n}\n\n\n/*\n * 'pdf_write_resources()' - Write the resources dictionary for a page.\n */\n\nstatic void\npdf_write_resources(FILE *out,\t\t/* I - Output file */\n                    int  outpage)\t/* I - Output page for resources */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  outpage_t\t*op;\t\t\t/* Current output page */\n  page_t\t*p;\t\t\t/* Current page */\n  render_t\t*r;\t\t\t/* Render pointer */\n  int\t\tfonts_used[TYPE_MAX * STYLE_MAX];\n\t\t\t\t\t/* Non-zero if the page uses a font */\n  int\t\timages_used;\t\t/* Non-zero if the page uses an image */\n  int\t\ttext_used;\t\t/* Non-zero if the page uses text */\n  static const char *effects[] =\t/* Effects and their commands */\n\t\t{\n\t\t  \"\",\n\t\t  \"/S/Box/M/I\",\n\t\t  \"/S/Box/M/O\",\n\t\t  \"/S/Dissolve\",\n\t\t  \"/S/Glitter/Di 270\",\n\t\t  \"/S/Glitter/Di 315\",\n\t\t  \"/S/Glitter/Di 0\",\n\t\t  \"/S/Blinds/Dm/H\",\n\t\t  \"/S/Split/Dm/H/M/I\",\n\t\t  \"/S/Split/Dm/H/M/O\",\n\t\t  \"/S/Blinds/Dm/V\",\n\t\t  \"/S/Split/Dm/V/M/I\",\n\t\t  \"/S/Split/Dm/V/M/O\",\n\t\t  \"/S/Wipe/Di 270\",\n\t\t  \"/S/Wipe/Di 180\",\n\t\t  \"/S/Wipe/Di 0\",\n\t\t  \"/S/Wipe/Di 90\"\n\t\t};\n\n\n  memset(fonts_used, 0, sizeof(fonts_used));\n  images_used = background_image != NULL;\n  text_used   = 0;\n\n  op = outpages + outpage;\n  for (i = 0; i < op->nup; i ++)\n  {\n    if (op->pages[i] < 0)\n      break;\n\n    p = pages + op->pages[i];\n\n    for (r = p->start; r != NULL; r = r->next)\n      if (r->type == RENDER_IMAGE)\n\timages_used = 1;\n      else if (r->type == RENDER_TEXT)\n      {\n\ttext_used = 1;\n\tfonts_used[r->data.text.typeface * 4 + r->data.text.style] = 1;\n      }\n  }\n\n  fputs(\"/Resources<<\", out);\n\n  if (!images_used)\n    fputs(\"/ProcSet[/PDF/Text]\", out);\n  else if (PDFVersion >= 12)\n  {\n    if (OutputColor)\n      fputs(\"/ProcSet[/PDF/Text/ImageB/ImageC/ImageI]\", out);\n    else\n      fputs(\"/ProcSet[/PDF/Text/ImageB/ImageI]\", out);\n  }\n  else\n  {\n    if (OutputColor)\n      fputs(\"/ProcSet[/PDF/Text/ImageB/ImageC]\", out);\n    else\n      fputs(\"/ProcSet[/PDF/Text/ImageB]\", out);\n  }\n\n  if (text_used)\n  {\n    fputs(\"/Font<<\", out);\n    for (i = 0; i < (TYPE_MAX * STYLE_MAX); i ++)\n      if (fonts_used[i])\n\tfprintf(out, \"/F%x %d 0 R\", i, font_objects[i]);\n    fputs(\">>\", out);\n  }\n\n  fputs(\"/XObject<<\", out);\n\n  for (i = 0; i < op->nup; i ++)\n  {\n    if (op->pages[i] < 0)\n      break;\n\n    p = pages + op->pages[i];\n\n    for (r = p->start; r != NULL; r = r->next)\n      if (r->type == RENDER_IMAGE && r->data.image->obj)\n\tfprintf(out, \"/I%d %d 0 R\", r->data.image->obj, r->data.image->obj);\n  }\n\n  if (background_image)\n    fprintf(out, \"/I%d %d 0 R\", background_image->obj,\n            background_image->obj);\n\n  fputs(\">>>>\", out);\n\n  if (PDFEffect)\n    fprintf(out, \"/Dur %.0f/Trans<</Type/Trans/D %.1f%s>>\", PDFPageDuration,\n            PDFEffectDuration, effects[PDFEffect]);\n}\n\n\n/*\n * 'pdf_write_outpage()' - Write an output page.\n */\n\nstatic void\npdf_write_outpage(FILE *out,\t/* I - Output file */\n                  int  outpage)\t/* I - Output page number */\n{\n  int\t\ti;\t\t/* Looping var */\n  page_t\t*p;\t\t/* Current page */\n  outpage_t\t*op;\t\t/* Output page */\n\n\n  DEBUG_printf((\"pdf_write_outpage(out = %p, outpage = %d)\\n\", (void *)out, outpage));\n\n  if (outpage < 0 || outpage >= (int)num_outpages)\n    return;\n\n  op = outpages + outpage;\n  p  = pages + op->pages[0];\n\n  DEBUG_printf((\"op->pages[0] = %d (%dx%d)\\n\", op->pages[0], p->width,\n                p->length));\n\n /*\n  * Let the user know which page we are writing...\n  */\n\n  if (Verbosity)\n  {\n    progress_show(\"Writing page %s...\", p->page_text);\n    progress_update(100 * outpage / (int)num_outpages);\n  }\n\n /*\n  * Output the page prolog...\n  */\n\n  pdf_start_object(out);\n\n  fputs(\"/Type/Page\", out);\n  fprintf(out, \"/Parent %d 0 R\", pages_object);\n  fprintf(out, \"/Contents %d 0 R\", (int)num_objects + 1);\n  if (p->landscape)\n    fprintf(out, \"/MediaBox[0 0 %d %d]\", p->length, p->width);\n  else\n    fprintf(out, \"/MediaBox[0 0 %d %d]\", p->width, p->length);\n\n  pdf_write_resources(out, outpage);\n\n /*\n  * Actions (links)...\n  */\n\n  if (op->annot_object > 0)\n    fprintf(out, \"/Annots %d 0 R\", op->annot_object);\n\n  pdf_end_object(out);\n\n  pdf_start_object(out);\n\n  if (Compression)\n    fputs(\"/Filter/FlateDecode\", out);\n\n  pdf_start_stream(out);\n\n  flate_open_stream(out);\n\n /*\n  * Render all of the pages...\n  */\n\n  switch (op->nup)\n  {\n    case 1 :\n        pdf_write_page(out, op->pages[0]);\n\tbreak;\n\n    default :\n        for (i = 0; i < op->nup; i ++)\n\t{\n\t  if (op->pages[i] < 0)\n\t    break;\n\n          p = pages + op->pages[i];\n\n          flate_printf(out, \"q %.3f %.3f %.3f %.3f %.3f %.3f cm\\n\",\n\t               p->outmatrix[0][0], p->outmatrix[1][0],\n\t               p->outmatrix[0][1], p->outmatrix[1][1],\n\t               p->outmatrix[0][2], p->outmatrix[1][2]);\n          pdf_write_page(out, op->pages[i]);\n\t  flate_puts(\"Q\\n\", out);\n\t}\n\tbreak;\n  }\n\n /*\n  * Close out the page...\n  */\n\n  flate_close_stream(out);\n\n  pdf_end_object(out);\n}\n\n\n/*\n * 'pdf_write_page()' - Write a page to a PDF file.\n */\n\nstatic void\npdf_write_page(FILE  *out,\t/* I - Output file */\n               int   page)\t/* I - Page number */\n{\n  render_t\t*r,\t\t/* Render pointer */\n\t\t*next;\t\t/* Next render */\n  float\t\tbox[3];\t\t/* RGB color for boxes */\n  page_t\t*p;\t\t/* Current page */\n  const char\t*debug;\t\t/* HTMLDOC_DEBUG environment variable */\n\n\n  if (page < 0 || page >= (int)alloc_pages)\n    return;\n\n  p = pages + page;\n\n /*\n  * Clear the render cache...\n  */\n\n  render_rgb[0]   = -1.0f;\n  render_rgb[1]   = -1.0f;\n  render_rgb[2]   = -1.0f;\n  render_x        = -1.0f;\n  render_y        = -1.0f;\n\n /*\n  * Output the page header...\n  */\n\n  flate_puts(\"q\\n\", out);\n  write_background(page, out);\n\n  if (p->duplex && (page & 1))\n    flate_printf(out, \"1 0 0 1 %d %d cm\\n\", p->right,\n                 p->bottom);\n  else\n    flate_printf(out, \"1 0 0 1 %d %d cm\\n\", p->left,\n                 p->bottom);\n\n /*\n  * Render all graphics elements...\n  */\n\n  box[0] = -1.0f;\n  box[1] = -1.0f;\n  box[2] = -1.0f;\n\n  for (r = p->start; r != NULL; r = r->next)\n    switch (r->type)\n    {\n      case RENDER_IMAGE :\n          if (r->width > 0.01f && r->height > 0.01f)\n            write_image(out, r);\n          break;\n\n      case RENDER_BOX :\n\t  if (r->height == 0.0)\n\t  {\n            if (box[0] != r->data.box[0] ||\n\t\tbox[1] != r->data.box[1] ||\n\t\tbox[2] != r->data.box[2])\n            {\n              box[0] = r->data.box[0];\n\t      box[1] = r->data.box[1];\n\t      box[2] = r->data.box[2];\n\n\t      if (OutputColor)\n        \tflate_printf(out, \"%.2f %.2f %.2f RG\\n\", box[0], box[1], box[2]);\n              else\n        \tflate_printf(out, \"%.2f G\\n\",\n\t\t             box[0] * 0.31f + box[1] * 0.61f + box[2] * 0.08f);\n            }\n\n            flate_printf(out, \"%.1f %.1f m %.1f %.1f l S\\n\",\n                \t r->x, r->y, r->x + r->width, r->y);\n\t  }\n\t  else\n\t  {\n            set_color(out, r->data.box);\n            flate_printf(out, \"%.1f %.1f %.1f %.1f re f\\n\",\n                \t r->x, r->y, r->width, r->height);\n\t  }\n\t  break;\n    }\n\n /*\n  * Render all text elements, freeing used memory as we go...\n  */\n\n  flate_puts(\"BT\\n\", out);\n\n  render_typeface = -1;\n  render_style    = -1;\n  render_size     = -1;\n  render_x        = -1.0f;\n  render_y        = -1.0f;\n  render_spacing  = -1.0f;\n\n  for (r = p->start, next = NULL; r != NULL; r = next)\n  {\n    if (r->type == RENDER_TEXT)\n      write_text(out, r);\n\n    next = r->next;\n    free(r);\n  }\n\n  p->start = NULL;\n\n  flate_puts(\"ET\\n\", out);\n\n  if ((debug = getenv(\"HTMLDOC_DEBUG\")) != NULL && strstr(debug, \"margin\"))\n  {\n    // Show printable area...\n    flate_printf(out, \"1 0 1 RG 0 0 %d %d re S\\n\", p->width - p->right - p->left,\n        \t p->length - p->top - p->bottom);\n  }\n\n /*\n  * Output the page trailer...\n  */\n\n  flate_puts(\"Q\\n\", out);\n}\n\n\n#ifdef DEBUG_TOC\nstatic void\npdf_text_contents(FILE *out, tree_t *toc, int indent)\n{\n  static const char *spaces = \"                                \"\n                              \"                                \";\n\n  if (indent > 16)\n    indent = 16;\n\n  while (toc)\n  {\n    fprintf(out, \"%% %s<%s>\", spaces + 64 - 4 * indent,\n            _htmlMarkups[toc->markup]);\n\n    switch (toc->markup)\n    {\n      case MARKUP_A :\n          tree_t *temp;\n\n          for (temp = toc->child; temp; temp = temp->next)\n\t    fputs((char *)temp->data, out);\n          break;\n\n      default :\n          fputs(\"\\n\", out);\n\t  pdf_text_contents(out, toc->child, indent + 1);\n\t  fprintf(out, \"%% %s\", spaces + 64 - 4 * indent);\n          break;\n    }\n\n    fprintf(out, \"</%s>\\n\", _htmlMarkups[toc->markup]);\n\n    toc = toc->next;\n  }\n}\n#endif // DEBUG_TOC\n\n\n/*\n * 'pdf_write_contents()' - Write the table of contents as outline records to\n *                          a PDF file.\n */\n\nstatic void\npdf_write_contents(FILE   *out,\t\t\t/* I - Output file */\n                   tree_t *toc,\t\t\t/* I - Table of contents tree */\n                   int    parent,\t\t/* I - Parent outline object */\n                   int    prev,\t\t\t/* I - Previous outline object */\n                   int    next,\t\t\t/* I - Next outline object */\n                   int    *heading)\t\t/* IO - Current heading # */\n{\n  int\t\ti,\t\t\t\t/* Looping var */\n\t\tthisobj,\t\t\t/* This object */\n\t\tentry,\t\t\t\t/* TOC entry object */\n\t\tcount;\t\t\t\t/* Number of entries at this level */\n  uchar\t\t*text;\t\t\t\t/* Entry text */\n  tree_t\t*temp;\t\t\t\t/* Looping var */\n  int\t\t*entry_counts,\t\t\t/* Number of sub-entries for this entry */\n\t\t*entry_objects;\t\t\t/* Objects for each entry */\n  tree_t\t**entries;\t\t\t/* Pointers to each entry */\n  float\t\tx, y;\t\t\t\t/* Position of link */\n\n\n /*\n  * Make an object for this entry...\n  */\n\n  if (toc == NULL)\n  {\n   /*\n    * This is for the Table of Contents page...\n    */\n\n    thisobj = pdf_start_object(out);\n\n    fprintf(out, \"/Parent %d 0 R\", parent);\n\n    fputs(\"/Title\", out);\n    write_utf16(out, (uchar *)TocTitle);\n\n    x = 0.0f;\n    y = PagePrintLength + PageBottom;\n    pspdf_transform_coords(pages + chapter_starts[0], x, y);\n\n    fprintf(out, \"/Dest[%d 0 R/XYZ %.0f %.0f 0]\",\n            pages_object + 2 * chapter_outstarts[0] + 1, x, y);\n\n    if (prev > 0)\n      fprintf(out, \"/Prev %d 0 R\", prev);\n\n    if (next > 0)\n      fprintf(out, \"/Next %d 0 R\", next);\n\n    pdf_end_object(out);\n    return;\n  }\n\n /*\n  * Allocate the arrays...  Add 1 to hold the TOC at the top level...\n  */\n\n  if ((entry_counts = (int *)calloc(sizeof(int), num_headings + 1)) == NULL)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY,\n                   \"Unable to allocate memory for %d headings - %s\",\n                   (int)num_headings, strerror(errno));\n    return;\n  }\n\n  if ((entry_objects = (int *)calloc(sizeof(int), num_headings + 1)) == NULL)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY,\n                   \"Unable to allocate memory for %d headings - %s\",\n                   (int)num_headings, strerror(errno));\n    free(entry_counts);\n    return;\n  }\n\n  if ((entries = (tree_t **)calloc(sizeof(tree_t *), num_headings + 1)) == NULL)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY,\n                   \"Unable to allocate memory for %d headings - %s\",\n                   (int)num_headings, strerror(errno));\n    free(entry_objects);\n    free(entry_counts);\n    return;\n  }\n\n  if (parent == 0 && TocLevels > 0)\n  {\n   /*\n    * Add the table of contents to the top-level contents...\n    */\n\n    entries[0]       = NULL;\n    entry_objects[0] = num_objects + 2;\n    entry            = num_objects + 3;\n    count            = 1;\n  }\n  else\n  {\n    entry = num_objects + 2;\n    count = 0;\n  }\n\n /*\n  * Find and count the children (entries)...\n  */\n\n  if (toc->markup == MARKUP_B && toc->next && toc->next->markup == MARKUP_UL)\n    temp = toc->next->child;\n  else if (toc->markup == MARKUP_LI && toc->last_child &&\n           toc->last_child->markup == MARKUP_UL)\n    temp = toc->last_child->child;\n  else\n    temp = toc->child;\n\n  for (; temp && count <= (int)num_headings; temp = temp->next)\n  {\n    if (temp->markup == MARKUP_B)\n    {\n      entries[count]       = temp;\n      entry_objects[count] = entry;\n\n      if (temp->next && temp->next->markup == MARKUP_UL)\n        entry_counts[count] = pdf_count_headings(temp->next->child);\n      else\n        entry_counts[count] = 0;\n\n      entry += entry_counts[count] + 1;\n      count ++;\n    }\n    else if (temp->markup == MARKUP_LI)\n    {\n      entries[count]       = temp;\n      entry_objects[count] = entry;\n\n      if (temp->last_child && temp->last_child->markup == MARKUP_UL)\n        entry_counts[count] = pdf_count_headings(temp->last_child);\n      else\n        entry_counts[count] = 0;\n\n      entry += entry_counts[count] + 1;\n      count ++;\n    }\n  }\n\n /*\n  * Output the top-level object...\n  */\n\n  thisobj = pdf_start_object(out);\n\n  if (parent == 0)\n    outline_object = thisobj;\n  else\n    fprintf(out, \"/Parent %d 0 R\", parent);\n\n  if (count > 0)\n  {\n    fprintf(out, \"/Count %d\", parent == 0 ? count : -count);\n    fprintf(out, \"/First %d 0 R\", entry_objects[0]);\n    fprintf(out, \"/Last %d 0 R\", entry_objects[count - 1]);\n  }\n\n  if (parent > 0 && toc->child && toc->child->markup == MARKUP_A)\n  {\n    if ((text = htmlGetText(toc->child->child)) != NULL)\n    {\n      fputs(\"/Title\", out);\n      write_utf16(out, text);\n      free(text);\n    }\n\n    i = heading_pages[*heading];\n    x = 0.0f;\n    y = heading_tops[*heading] + pages[i].bottom;\n    pspdf_transform_coords(pages + i, x, y);\n\n    fprintf(out, \"/Dest[%d 0 R/XYZ %.0f %.0f 0]\",\n            pages_object + 2 * pages[i].outpage + 1, x, y);\n\n    (*heading) ++;\n  }\n\n  if (prev > 0)\n    fprintf(out, \"/Prev %d 0 R\", prev);\n\n  if (next > 0)\n    fprintf(out, \"/Next %d 0 R\", next);\n\n  pdf_end_object(out);\n\n  for (i = 0; i < count ; i ++)\n    pdf_write_contents(out, entries[i], thisobj, i > 0 ? entry_objects[i - 1] : 0,\n                       i < (count - 1) ? entry_objects[i + 1] : 0,\n                       heading);\n\n  free(entry_objects);\n  free(entry_counts);\n  free(entries);\n}\n\n\n//\n// 'pdf_write_files()' - Write an outline of HTML files.\n//\n\nstatic void\npdf_write_files(FILE   *out,\t\t// I - Output file\n                tree_t *doc)\t\t// I - Document tree\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tnum_files,\t\t// Number of FILE elements\n\t\talloc_text;\t\t// Allocated text?\n  uchar\t\t*text;\t\t\t// Entry text\n  tree_t\t*temp;\t\t\t// Current node\n  link_t\t*link;\t\t\t// Link to file...\n  float\t\tx, y;\t\t\t// Position of link\n\n\n  // Figure out the number of (top-level) files in the document...\n  for (num_files = 0, temp = doc; temp; temp = temp->next)\n    if (temp->markup == MARKUP_FILE)\n      num_files ++;\n\n  if (num_files < 2)\n  {\n    // No files to outline...\n    outline_object = 0;\n\n    return;\n  }\n\n  // Write the outline dictionary...\n  outline_object = pdf_start_object(out);\n\n  fprintf(out, \"/Count %d\", num_files);\n  fprintf(out, \"/First %d 0 R\", outline_object + 1);\n  fprintf(out, \"/Last %d 0 R\", outline_object + num_files);\n\n  pdf_end_object(out);\n\n  // Now write the outline items...\n  for (i = 0, temp = doc; temp; temp = temp->next)\n    if (temp->markup == MARKUP_FILE)\n    {\n      alloc_text = 0;\n\n      if ((text = get_title(temp->child)) != NULL)\n        alloc_text = 1;\n      else if ((text = htmlGetVariable(temp, (uchar *)\"_HD_FILENAME\")) == NULL)\n        text = (uchar *)\"Unknown\";\n\n      pdf_start_object(out);\n\n      fprintf(out, \"/Parent %d 0 R\", outline_object);\n\n      fputs(\"/Title\", out);\n      write_utf16(out, text);\n      if (alloc_text)\n        free(text);\n\n      if ((link = find_link(htmlGetVariable(temp, (uchar *)\"_HD_FILENAME\"))) != NULL)\n      {\n\tx = 0.0f;\n\ty = link->top + pages[link->page].bottom;\n\tpspdf_transform_coords(pages + link->page, x, y);\n\n\tfprintf(out, \"/Dest[%d 0 R/XYZ %.0f %.0f 0]\",\n        \tpages_object + 2 * pages[link->page].outpage + 1, x, y);\n      }\n\n      if (i > 0)\n        fprintf(out, \"/Prev %d 0 R\", outline_object + i);\n\n      if (i < (num_files - 1))\n        fprintf(out, \"/Next %d 0 R\", outline_object + i + 2);\n\n      pdf_end_object(out);\n\n      i ++;\n    }\n}\n\n\n/*\n * 'pdf_count_headings()' - Count the number of headings under this TOC\n *                          entry.\n */\n\nstatic int\t\t\t/* O - Number of headings found */\npdf_count_headings(tree_t *toc)\t/* I - TOC entry */\n{\n  int\theadings;\t\t/* Number of headings */\n\n\n  for (headings = 0; toc != NULL; toc = toc->next)\n  {\n    if (toc->markup == MARKUP_A)\n      headings ++;\n    if (toc->child != NULL)\n      headings += pdf_count_headings(toc->child);\n  }\n\n  return (headings);\n}\n\n\n/*\n * PDF object state variables...\n */\n\nstatic int\tpdf_stream_length = 0;\nstatic int\tpdf_stream_start = 0;\nstatic int\tpdf_object_type = 0;\n\n\n/*\n * 'pdf_start_object()' - Start a new PDF object...\n */\n\nstatic int\t\t\t// O - Object number\npdf_start_object(FILE *out,\t// I - File to write to\n                 int  array)\t// I - 1 = array, 0 = dictionary\n{\n  int\t*temp;\t\t\t// Temporary integer pointer\n\n\n  num_objects ++;\n\n  // Allocate memory as necessary...\n  if (num_objects >= alloc_objects)\n  {\n    alloc_objects += ALLOC_OBJECTS;\n\n    if (alloc_objects == ALLOC_OBJECTS)\n      temp = (int *)malloc(sizeof(int) * alloc_objects);\n    else\n      temp = (int *)realloc(objects, sizeof(int) * alloc_objects);\n\n    if (temp == NULL)\n    {\n      progress_error(HD_ERROR_OUT_OF_MEMORY,\n                     \"Unable to allocate memory for %d objects - %s\",\n                     (int)alloc_objects, strerror(errno));\n      alloc_objects -= ALLOC_OBJECTS;\n      return (0);\n    }\n\n    objects = temp;\n  }\n\n  objects[num_objects] = ftell(out);\n  fprintf(out, \"%d 0 obj\", (int)num_objects);\n\n  pdf_object_type = array;\n\n  fputs(pdf_object_type ? \"[\" : \"<<\", out);\n\n  return (num_objects);\n}\n\n\n/*\n * 'pdf_start_stream()' - Start a new PDF stream...\n */\n\nstatic void\npdf_start_stream(FILE *out)\t// I - File to write to\n{\n  // Write the \"/Length \" string, get the position, and then write 10\n  // zeroes to cover the maximum size of a stream.\n\n  fputs(\"/Length \", out);\n  pdf_stream_length = ftell(out);\n  fputs(\"0000000000>>stream\\n\", out);\n  pdf_stream_start = ftell(out);\n}\n\n\n/*\n * 'pdf_end_object()' - End a PDF object...\n */\n\nstatic void\npdf_end_object(FILE *out)\t// I - File to write to\n{\n  int\tlength;\t\t\t// Total length of stream\n\n\n  if (pdf_stream_start)\n  {\n    // For streams, go back and update the length field in the\n    // object dictionary...\n    length = ftell(out) - pdf_stream_start;\n\n    fseek(out, pdf_stream_length, SEEK_SET);\n    fprintf(out, \"%-10d\", length);\n    fseek(out, 0, SEEK_END);\n\n    pdf_stream_start = 0;\n\n    fputs(\"endstream\\n\", out);\n  }\n  else\n    fputs(pdf_object_type ? \"]\" : \">>\", out);\n\n  fputs(\"endobj\\n\", out);\n}\n\n\n/*\n * 'pdf_write_links()' - Write annotation link objects for each page in the\n *                       document.\n */\n\nstatic void\npdf_write_links(FILE *out)\t\t/* I - Output file */\n{\n  int\t\ti,\t\t\t/* Looping var */\n\t\toutpage,\t\t/* Current page */\n\t\tlobj,\t\t\t/* Current link */\n\t\tnum_lobjs,\t\t/* Number of links on this page */\n\t\talloc_lobjs,\t\t/* Number of links to allocate */\n\t\t*lobjs;\t\t\t/* Link objects */\n  float\t\tx, y;\t\t\t/* Position of last link */\n  render_t\t*r,\t\t\t/* Current render primitive */\n\t\t*rlast,\t\t\t/* Last render link primitive */\n\t\t*rprev;\t\t\t/* Previous render primitive */\n  link_t\t*link;\t\t\t/* Local link */\n  page_t\t*p;\t\t\t/* Current page */\n  outpage_t\t*op;\t\t\t/* Current output page */\n\n\n /*\n  * First combine adjacent, identical links...\n  */\n\n  for (outpage = 0, op = outpages; outpage < (int)num_outpages; outpage ++, op ++)\n  {\n    for (i = 0; i < op->nup; i ++)\n    {\n      if (op->pages[i] < 0)\n        break;\n\n      p = pages + op->pages[i];\n\n      for (r = p->start, x = 0.0f, y = 0.0f, rlast = NULL, rprev = NULL;\n           r != NULL;\n\t   rprev = r, r = r->next)\n\tif (r->type == RENDER_LINK)\n\t{\n          if (fabs(r->x - x) < 0.1f && fabs(r->y - y) < 0.1f &&\n\t      rlast != NULL && strcmp((const char *)rlast->data.link,\n\t                              (const char *)r->data.link) == 0)\n\t  {\n\t    // Combine this primitive with the previous one in rlast...\n\t    rlast->width = r->x + r->width - rlast->x;\n\t    x            = rlast->x + rlast->width;\n\n\t    // Delete this render primitive...\n\t    rprev->next = r->next;\n\t    free(r);\n\t    r = rprev;\n\t  }\n\t  else\n\t  {\n\t    // Can't combine; just save this info for later use...\n\t    rlast = r;\n\t    x     = r->x + r->width;\n\t    y     = r->y;\n\t  }\n\t}\n    }\n  }\n\n /*\n  * Setup the initial pages_object number...\n  */\n\n  pages_object = num_objects + 1;\n\n /*\n  * Add space for named links in PDF 1.2 output...\n  */\n\n  if (PDFVersion >= 12)\n    pages_object += num_links + 3;\n\n /*\n  * Stop here if we won't be generating links in the output...\n  */\n\n  if (!Links)\n    return;\n\n /*\n  * Figure out how many link objects we'll have...\n  */\n\n  for (outpage = 0, op = outpages, alloc_lobjs = 0;\n       outpage < (int)num_pages;\n       outpage ++, op ++)\n  {\n    num_lobjs = 0;\n\n    for (i = 0; i < op->nup; i ++)\n    {\n      if (op->pages[i] < 0)\n        break;\n\n      p = pages + op->pages[i];\n\n      for (r = p->start; r != NULL; r = r->next)\n\tif (r->type == RENDER_LINK)\n\t{\n          if (find_link(r->data.link) != NULL)\n            num_lobjs ++;\n          else\n            num_lobjs += 2;\n\t}\n    }\n\n    if (num_lobjs > 0)\n      pages_object += num_lobjs + 1;\n\n    if (num_lobjs > alloc_lobjs)\n      alloc_lobjs = num_lobjs;\n  }\n\n  if (alloc_lobjs == 0)\n    return;\n\n /*\n  * Allocate memory for the links...\n  */\n\n  if ((lobjs = (int *)malloc(sizeof(int) * (size_t)alloc_lobjs)) == NULL)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY,\n                   \"Unable to allocate memory for %d link objects - %s\",\n                   alloc_lobjs, strerror(errno));\n    return;\n  }\n\n /*\n  * Then generate annotation objects for all the links...\n  */\n\n  for (outpage = 0, op = outpages; outpage < (int)num_pages; outpage ++, op ++)\n  {\n    num_lobjs = 0;\n\n    for (i = 0; i < op->nup; i ++)\n    {\n      if (op->pages[i] < 0)\n        break;\n\n      p = pages + op->pages[i];\n\n      for (r = p->start; r != NULL; r = r->next)\n\tif (r->type == RENDER_LINK)\n\t{\n          if ((link = find_link(r->data.link)) != NULL)\n\t  {\n\t   /*\n            * Local link...\n            */\n\t    float x1, y1, x2, y2;\n\n            lobjs[num_lobjs ++] = pdf_start_object(out);\n\n            fputs(\"/Subtype/Link\", out);\n\n            if (PageDuplex && (op->pages[i] & 1))\n\t    {\n              x1 = r->x + p->right;\n\t      y1 = r->y + p->bottom - 2;\n              x2 = r->x + r->width + p->right;\n\t      y2 = r->y + r->height + p->bottom;\n\t    }\n            else\n\t    {\n              x1 = r->x + p->left;\n\t      y1 = r->y + p->bottom - 2;\n              x2 = r->x + r->width + p->left;\n\t      y2 = r->y + r->height + p->bottom;\n\t    }\n\n            pspdf_transform_coords(p, x1, y1);\n            pspdf_transform_coords(p, x2, y2);\n            fprintf(out, \"/Rect[%.1f %.1f %.1f %.1f]\", x1, y1, x2, y2);\n\n            fputs(\"/Border[0 0 0]\", out);\n\n            x1 = 0.0f;\n\t    y1 = link->top + pages[link->page].bottom;\n            pspdf_transform_coords(pages + link->page, x1, y1);\n\t    fprintf(out, \"/Dest[%d 0 R/XYZ %.0f %.0f 0]\",\n        \t    pages_object + 2 * pages[link->page].outpage + 1,\n        \t    x1, y1);\n\t    pdf_end_object(out);\n\t  }\n\t  else\n\t  {\n\t   /*\n            * Remote link...\n            */\n\n            pdf_start_object(out);\n\n\t    if (PDFVersion >= 12 &&\n        \tfile_method((char *)r->data.link) == NULL)\n\t    {\n#ifdef WIN32\n              if (strcasecmp(file_extension((char *)r->data.link), \"pdf\") == 0)\n#else\n              if (strcmp(file_extension((char *)r->data.link), \"pdf\") == 0)\n#endif /* WIN32 */\n              {\n\t       /*\n\t\t* Link to external PDF file...\n\t\t*/\n\n                const char *target = file_target((char *)r->data.link);\n\n        \tfputs(\"/S/GoToR\", out);\n        \tif (target)\n        \t{\n        \t  char\turl[1024], *urlptr;\n\n\t\t  fputs(\"/D\", out);\n\t\t  write_string(out, (uchar *)target, 0);\n\n                  strlcpy(url, (char *)r->data.link, sizeof(url));\n                  if ((urlptr = strrchr(url, '#')) != NULL)\n                    *urlptr = '\\0';\n\n\t\t  fputs(\"/F\", out);\n\t\t  write_string(out, (uchar *)url, 0);\n        \t}\n        \telse\n        \t{\n\t\t  fputs(\"/D[0/XYZ null null 0]/F\", out);\n\t\t  write_string(out, r->data.link, 0);\n\t\t}\n              }\n\t      else\n              {\n\t       /*\n\t\t* Link to external filename...\n\t\t*/\n\n        \tfputs(\"/S/Launch\", out);\n        \tfputs(\"/F\", out);\n\t\twrite_string(out, r->data.link, 0);\n\n\t\tif (StrictHTML)\n\t\t  progress_error(HD_ERROR_UNRESOLVED_LINK,\n\t\t                 \"Unable to resolve link to \\\"%s\\\"!\",\n\t\t                 r->data.link);\n              }\n\t    }\n\t    else\n\t    {\n\t     /*\n\t      * Link to web file...\n\t      */\n\n              fputs(\"/S/URI\", out);\n              fputs(\"/URI\", out);\n\t      write_string(out, r->data.link, 0);\n\t    }\n\n            pdf_end_object(out);\n\n            lobjs[num_lobjs ++] = pdf_start_object(out);\n\n            fputs(\"/Subtype/Link\", out);\n            if (PageDuplex && (outpage & 1))\n              fprintf(out, \"/Rect[%.1f %.1f %.1f %.1f]\",\n                      r->x + PageRight, r->y + PageBottom,\n                      r->x + r->width + PageRight, r->y + r->height + PageBottom);\n            else\n              fprintf(out, \"/Rect[%.1f %.1f %.1f %.1f]\",\n                      r->x + PageLeft, r->y + PageBottom - 2,\n                      r->x + r->width + PageLeft, r->y + r->height + PageBottom);\n            fputs(\"/Border[0 0 0]\", out);\n\t    fprintf(out, \"/A %d 0 R\", (int)num_objects - 1);\n            pdf_end_object(out);\n\t  }\n\t}\n    }\n\n    if (num_lobjs > 0)\n    {\n      outpages[outpage].annot_object = pdf_start_object(out, 1);\n\n      for (lobj = 0; lobj < num_lobjs; lobj ++)\n        fprintf(out, \"%d 0 R%s\", lobjs[lobj],\n\t        lobj < (num_lobjs - 1) ? \"\\n\" : \"\");\n\n      pdf_end_object(out);\n    }\n  }\n\n  free(lobjs);\n}\n\n\n/*\n * 'pdf_write_names()' - Write named destinations for each link.\n */\n\nstatic void\npdf_write_names(FILE *out)\t\t/* I - Output file */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  uchar\t\t*s;\t\t\t/* Current character in name */\n  link_t\t*link;\t\t\t/* Local link */\n\n\n /*\n  * Convert all link names to lowercase...\n  */\n\n  for (i = num_links, link = links; i > 0; i --, link ++)\n    for (s = link->name; *s != '\\0'; s ++)\n      *s = (uchar)tolower(*s);\n\n /*\n  * Write the root name tree entry...\n  */\n\n  names_object = pdf_start_object(out);\n  fprintf(out, \"/Dests %d 0 R\", (int)num_objects + 1);\n  pdf_end_object(out);\n\n /*\n  * Write the name tree child list...\n  */\n\n  pdf_start_object(out);\n  fprintf(out, \"/Kids[%d 0 R]\", (int)num_objects + 1);\n  pdf_end_object(out);\n\n /*\n  * Write the leaf node for the name tree...\n  */\n\n  pdf_start_object(out);\n\n  fputs(\"/Limits[\", out);\n  write_string(out, links[0].name, 0);\n  write_string(out, links[num_links - 1].name, 0);\n  fputs(\"]\", out);\n\n  fputs(\"/Names[\", out);\n  for (i = 1, link = links; i <= (int)num_links; i ++, link ++)\n  {\n    write_string(out, link->name, 0);\n    fprintf(out, \"%d 0 R\", (int)num_objects + i);\n  }\n  fputs(\"]\", out);\n\n  pdf_end_object(out);\n\n  for (i = num_links, link = links; i > 0; i --, link ++)\n  {\n    pdf_start_object(out);\n    float x, y;\n\n    x = 0.0f;\n    y = link->top + pages[link->page].bottom;\n    pspdf_transform_coords(pages + link->page, x, y);\n    fprintf(out, \"/D[%d 0 R/XYZ %.0f %.0f 0]\",\n            pages_object + 2 * pages[link->page].outpage + 1, x, y);\n    pdf_end_object(out);\n  }\n}\n\n\n/*\n * 'render_contents()' - Render a single heading.\n */\n\nstatic void\nrender_contents(tree_t *t,\t\t/* I - Tree to parse */\n                float  left,\t\t/* I - Left margin */\n                float  right,\t\t/* I - Printable width */\n                float  bottom,\t\t/* I - Bottom margin */\n                float  top,\t\t/* I - Printable top */\n                float  *y,\t\t/* IO - Y position */\n                int    *page,\t\t/* IO - Page # */\n\t        int    heading,\t\t/* I - Heading # */\n\t        tree_t *chap)\t\t/* I - Chapter heading */\n{\n  float\t\tx,\n\t\twidth,\n\t\tnumberwidth,\n\t\theight,\n\t\trgb[3];\n  int\t\thpage;\n  uchar\t\tnumber[1024],\n\t\t*nptr,\n\t\t*link;\n  tree_t\t*flat,\n\t\t*temp,\n\t\t*next;\n  render_t\t*r;\n  float\t\tdot_width;\n\n\n  DEBUG_printf((\"render_contents(t=%p, left=%.1f, right=%.1f, bottom=%.1f, top=%.1f, y=%.1f, page=%d, heading=%d, chap=%p)\\n\",\n                (void *)t, left, right, bottom, top, *y, *page, heading, (void *)chap));\n\n  if (!t)\n    return;\n\n  dot_width = _htmlSizes[SIZE_P] * _htmlWidths[t->typeface][t->style]['.'] * 0.001f;\n\n /*\n  * Put the text...\n  */\n\n  flat = flatten_tree(t->child->child);\n\n  for (height = 0.0, temp = flat; temp != NULL; temp = temp->next)\n    if (temp->height > height)\n      height = temp->height;\n\n  height *= _htmlSpacings[SIZE_P] / _htmlSizes[SIZE_P];\n\n  if (t->indent)\n    x = left + 18.0f + 18.0f * t->indent;\n  else\n    x = left;\n\n  *y -= height;\n\n /*\n  * Get the width of the page number, leave room for three dots...\n  */\n\n  if (heading >= 0 && heading < (int)num_headings)\n  {\n    hpage       = heading_pages[heading];\n    numberwidth = (float)(get_width((uchar *)pages[hpage].page_text, t->typeface, t->style, t->size) + 3.0f * dot_width);\n  }\n  else\n  {\n    hpage       = 0;\n    numberwidth = 0.0f;\n  }\n\n  for (temp = flat; temp != NULL; temp = next)\n  {\n    rgb[0] = temp->red / 255.0f;\n    rgb[1] = temp->green / 255.0f;\n    rgb[2] = temp->blue / 255.0f;\n\n    if ((x + temp->width) >= (right - numberwidth))\n    {\n     /*\n      * Too wide to fit, continue on the next line\n      */\n\n      *y -= _htmlSpacings[SIZE_P];\n      x  = left + 36.0f * t->indent;\n    }\n\n    if (*y < bottom)\n    {\n      (*page) ++;\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n\n      width = get_width((uchar *)TocTitle, _htmlHeadingFont, STYLE_BOLD, SIZE_H1);\n      *y = (float)(top - _htmlSpacings[SIZE_H1]);\n      x  = (float)(left + 0.5f * (right - left - width));\n      r = new_render(*page, RENDER_TEXT, x, *y, 0, 0, TocTitle);\n      r->data.text.typeface = _htmlHeadingFont;\n      r->data.text.style    = STYLE_BOLD;\n      r->data.text.size     = (float)_htmlSizes[SIZE_H1];\n      get_color(_htmlTextColor, r->data.text.rgb);\n\n      *y -= _htmlSpacings[SIZE_H1];\n\n      if (t->indent)\n\tx = left + 18.0f + 18.0f * t->indent;\n      else\n\tx = left;\n\n      if (chap != t)\n      {\n        *y += height;\n        render_contents(chap, left, right, bottom, top, y, page, -1, 0);\n\t*y -= _htmlSpacings[SIZE_P];\n      }\n    }\n\n    if (temp->link != NULL)\n    {\n      link = htmlGetVariable(temp->link, (uchar *)\"HREF\");\n\n     /*\n      * Add a page link...\n      */\n\n      new_render(*page, RENDER_LINK, x, *y, temp->width, temp->height, link);\n\n      if (PSLevel == 0 && Links)\n      {\n        memcpy(rgb, link_color, sizeof(rgb));\n\n\ttemp->red   = (uchar)(link_color[0] * 255.0);\n\ttemp->green = (uchar)(link_color[1] * 255.0);\n\ttemp->blue  = (uchar)(link_color[2] * 255.0);\n\n        if (LinkStyle)\n\t  new_render(*page, RENDER_BOX, x, *y - 1, temp->width, 0,\n\t             link_color);\n      }\n    }\n\n    if ((link = htmlGetVariable(temp, (uchar *)\"ID\")) != NULL)\n    {\n     /*\n      * Add a target link...\n      */\n\n      add_link(link, *page, (int)(*y + height));\n    }\n\n    switch (temp->markup)\n    {\n      case MARKUP_A :\n          if ((link = htmlGetVariable(temp, (uchar *)\"NAME\")) != NULL)\n          {\n           /*\n            * Add a target link...\n            */\n\n            add_link(link, *page, (int)(*y + height));\n          }\n          break;\n\n      case MARKUP_NONE :\n          if (temp->data == NULL)\n            break;\n\n\t  if (temp->underline)\n\t    new_render(*page, RENDER_BOX, x, *y - 1, temp->width, 0, rgb);\n\n\t  if (temp->strikethrough)\n\t    new_render(*page, RENDER_BOX, x, *y + temp->height * 0.25f,\n\t\t       temp->width, 0, rgb);\n\n          r = new_render(*page, RENDER_TEXT, x, *y, 0, 0, temp->data);\n          r->data.text.typeface = temp->typeface;\n          r->data.text.style    = temp->style;\n          r->data.text.size     = (float)_htmlSizes[temp->size];\n          memcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n          if (temp->superscript)\n            r->y += height - temp->height;\n          else if (temp->subscript)\n            r->y -= height * _htmlSizes[0] / _htmlSpacings[0] -\n\t\t    temp->height;\n\t  break;\n\n      case MARKUP_IMG :\n\t  update_image_size(temp);\n\t  new_render(*page, RENDER_IMAGE, x, *y, temp->width, temp->height,\n\t\t     image_find((char *)htmlGetVariable(temp, (uchar *)\"REALSRC\")));\n\t  break;\n\n      default :\n\t  break;\n    }\n\n    x += temp->width;\n    next = temp->next;\n    free(temp);\n  }\n\n  if (numberwidth > 0.0f)\n  {\n   /*\n    * Draw dots leading up to the page number...\n    */\n\n    width = (float)(numberwidth - 3.0 * dot_width + x);\n\n    for (nptr = number;\n         nptr < (number + sizeof(number) - 1) && width < right;\n\t width += dot_width)\n      *nptr++ = '.';\n\n    if (nptr > number)\n      nptr --;\n\n    strlcpy((char *)nptr, pages[hpage].page_text, sizeof(number) - (size_t)(nptr - number));\n\n    r = new_render(*page, RENDER_TEXT, right - width + x, *y, 0, 0, number);\n    r->data.text.typeface = t->typeface;\n    r->data.text.style    = t->style;\n    r->data.text.size     = (float)_htmlSizes[t->size];\n    memcpy(r->data.text.rgb, rgb, sizeof(rgb));\n  }\n}\n\n\n/*\n * 'count_headings()' - Count the number of headings in the TOC.\n */\n\nstatic int\ncount_headings(tree_t *t)\t\t// I - Tree to count\n{\n  int\tcount;\t\t\t\t// Number of headings...\n\n\n  count = 0;\n\n  while (t != NULL)\n  {\n    switch (t->markup)\n    {\n      case MARKUP_B :\n      case MARKUP_LI :\n          count ++;\n\t  if (t->last_child && t->last_child->markup == MARKUP_UL)\n\t    count += count_headings(t->last_child);\n\t  break;\n\n      default :\n          count += count_headings(t->child);\n          break;\n    }\n\n    t = t->next;\n  }\n\n  return (count);\n}\n\n\n/*\n * 'parse_contents()' - Parse the table of contents and produce a\n *                      rendering list...\n */\n\nstatic void\nparse_contents(tree_t *t,\t\t/* I - Tree to parse */\n               float  left,\t\t/* I - Left margin */\n               float  right,\t\t/* I - Printable width */\n               float  bottom,\t\t/* I - Bottom margin */\n               float  top,\t\t/* I - Printable top */\n               float  *y,\t\t/* IO - Y position */\n               int    *page,\t\t/* IO - Page # */\n               int    *heading,\t\t/* IO - Heading # */\n\t       tree_t *chap)\t\t/* I - Chapter heading */\n{\n  DEBUG_printf((\"parse_contents(t=%p, left=%.1f, right=%.1f, bottom=%.1f, top=%.1f, y=%.1f, page=%d, heading=%d, chap=%p)\\n\",\n                (void *)t, left, right, bottom, top, *y, *page, *heading, (void *)chap));\n\n  while (t != NULL)\n  {\n    switch (t->markup)\n    {\n      case MARKUP_B :\t/* Top-level TOC */\n          if (t->prev != NULL)\t/* Advance one line prior to top-levels... */\n            *y -= _htmlSpacings[SIZE_P];\n\n          if (*y < (bottom + _htmlSpacings[SIZE_P] * 3))\n\t    *y = 0; // Force page break\n\n          chap = t;\n\n      case MARKUP_LI :\t/* Lower-level TOC */\n          DEBUG_printf((\"parse_contents: heading=%d, page = %d\\n\", *heading,\n                        heading_pages[*heading]));\n\n         /*\n          * Put the text unless the author has flagged it otherwise...\n          */\n\n          if (htmlGetVariable(t, (uchar *)\"_HD_OMIT_TOC\") == NULL)\n\t  {\n            render_contents(t, left, right, bottom, top, y, page,\n\t                    *heading, chap);\n\n           /*\n\t    * Update current headings for header/footer strings in TOC.\n\t    */\n\n\t    check_pages(*page);\n\n\t    if (t->markup == MARKUP_B &&\n\t\tpages[*page].chapter == pages[*page - 1].chapter)\n\t      pages[*page].chapter = htmlGetText(t->child->child);\n\n\t    if (pages[*page].heading == pages[*page - 1].heading)\n\t      pages[*page].heading = htmlGetText(t->child->child);\n\n           /*\n            * Next heading...\n            */\n\n            (*heading) ++;\n\n            if (t->last_child->markup == MARKUP_UL)\n              parse_contents(t->last_child, left, right, bottom, top, y,\n\t                     page, heading, chap);\n          }\n\t  else if (t->next != NULL && t->next->markup == MARKUP_UL)\n\t  {\n\t   /*\n\t    * Skip children of omitted heading...\n\t    */\n\n\t    t = t->next;\n\n\t    (*heading) += count_headings(t->child) + 1;\n\t  }\n\t  else\n\t    (*heading) ++;\n          break;\n\n      default :\n          parse_contents(t->child, left, right, bottom, top, y, page, heading,\n\t                 chap);\n          break;\n    }\n\n    t = t->next;\n  }\n}\n\n\n/*\n * 'parse_doc()' - Parse a document tree and produce rendering list output.\n */\n\nstatic void\nparse_doc(tree_t *t,\t\t/* I - Tree to parse */\n          float  *left,\t\t/* I - Left margin */\n          float  *right,\t/* I - Printable width */\n          float  *bottom,\t/* I - Bottom margin */\n          float  *top,\t\t/* I - Printable top */\n          float  *x,\t\t/* IO - X position */\n          float  *y,\t\t/* IO - Y position */\n          int    *page,\t\t/* IO - Page # */\n\t  tree_t *cpara,\t/* I - Current paragraph */\n\t  int    *needspace)\t/* I - Need whitespace before this element */\n{\n  int\t\ti;\t\t/* Looping var */\n  tree_t\t*para,\t\t/* Phoney paragraph tree entry */\n\t\t*temp;\t\t/* Paragraph entry */\n  var_t\t\t*var;\t\t/* Variable entry */\n  uchar\t\t*name;\t\t/* ID name */\n  uchar\t\t*style;\t\t/* STYLE attribute */\n  float\t\twidth,\t\t/* Width of horizontal rule */\n\t\theight,\t\t/* Height of rule */\n\t\trgb[3];\t\t/* RGB color of rule */\n\n\n  DEBUG_printf((\"parse_doc(t=%p, left=%.1f, right=%.1f, bottom=%.1f, top=%.1f, x=%.1f, y=%.1f, page=%d, cpara=%p, needspace=%d\\n\",\n                (void *)t, *left, *right, *bottom, *top, *x, *y, *page, (void *)cpara,\n\t        *needspace));\n  DEBUG_printf((\"    title_page = %d, chapter = %d\\n\", title_page, chapter));\n\n  if (cpara == NULL)\n    para = htmlNewTree(NULL, MARKUP_P, NULL);\n  else\n    para = cpara;\n\n  while (t != NULL)\n  {\n    if (t->markup == MARKUP_FILE)\n      current_url = htmlGetVariable(t, (uchar *)\"_HD_URL\");\n\n    if (((t->markup == MARKUP_H1 && OutputType == OUTPUT_BOOK) ||\n         (t->markup == MARKUP_FILE && OutputType == OUTPUT_WEBPAGES)) &&\n\t!title_page)\n    {\n      // New page on H1 in book mode or file in webpage mode...\n      if (para->child != NULL && chapter > 0)\n      {\n        parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n        htmlDeleteTree(para->child);\n        para->child = para->last_child = NULL;\n      }\n\n      if ((chapter > 0 && OutputType == OUTPUT_BOOK) ||\n          ((*page > 0 || *y < *top) && OutputType == OUTPUT_WEBPAGES))\n      {\n        if (*y < *top)\n          (*page) ++;\n\n        if (PageDuplex && (*page & 1))\n          (*page) ++;\n\n        if (Verbosity)\n          progress_show(\"Formatting page %d\", *page);\n\n        chapter_ends[chapter] = *page - 1;\n      }\n\n      // Make sure header and footer strings are correct...\n      check_pages(*page);\n\n      memcpy(pages[*page].header, Header, sizeof(pages[*page].header));\n      memcpy(pages[*page].header1, Header1, sizeof(pages[*page].header1));\n      memcpy(pages[*page].footer, Footer, sizeof(pages[*page].footer));\n\n      // Bump the chapter/file count...\n      chapter ++;\n      if (chapter >= MAX_CHAPTERS)\n      {\n\tprogress_error(HD_ERROR_TOO_MANY_CHAPTERS,\n\t               \"Too many chapters/files in document (%d > %d)!\",\n\t               chapter, MAX_CHAPTERS);\n        chapter = MAX_CHAPTERS - 1;\n      }\n      else\n        chapter_starts[chapter] = *page;\n\n      if (chapter > TocDocCount)\n\tTocDocCount = chapter;\n\n      *y         = *top;\n      *x         = *left;\n      *needspace = 0;\n    }\n\n    if ((name = htmlGetVariable(t, (uchar *)\"ID\")) != NULL)\n    {\n     /*\n      * Add a link target using the ID=name variable...\n      */\n\n      add_link(name, *page, (int)*y);\n    }\n    else if (t->markup == MARKUP_FILE)\n    {\n     /*\n      * Add a file link...\n      */\n\n      uchar\tnewname[256],\t/* New filename */\n\t\t*sep;\t\t/* \"?\" separator in links */\n\n\n      // Strip any trailing HTTP GET data stuff...\n      strlcpy((char *)newname, (char *)htmlGetVariable(t, (uchar *)\"_HD_FILENAME\"),\n              sizeof(newname));\n\n      if ((sep = (uchar *)strchr((char *)newname, '?')) != NULL)\n        *sep = '\\0';\n\n      // Add the link\n      add_link(newname, *page, (int)*y);\n    }\n\n    if (chapter == 0 && !title_page)\n    {\n      // Need to handle page comments before the first heading...\n      if (t->markup == MARKUP_COMMENT)\n        parse_comment(t, left, right, bottom, top, x, y, page, para,\n\t              *needspace);\n\n      if (t->child != NULL)\n        parse_doc(t->child, left, right, bottom, top, x, y, page, para,\n\t          needspace);\n\n      t = t->next;\n      continue;\n    }\n\n    // Check for some basic stylesheet stuff...\n    if ((style = htmlGetStyle(t, (uchar *)\"page-break-before:\")) != NULL &&\n\tstrcasecmp((char *)style, \"avoid\") != 0)\n    {\n      // Advance to the next page...\n      (*page) ++;\n      *x         = *left;\n      *y         = *top;\n      *needspace = 0;\n\n      // See if we need to go to the next left/righthand page...\n      if (PageDuplex && ((*page) & 1) &&\n          strcasecmp((char *)style, \"right\") == 0)\n\t(*page) ++;\n      else if (PageDuplex && !((*page) & 1) &&\n               strcasecmp((char *)style, \"left\") == 0)\n\t(*page) ++;\n\n      // Update the progress as necessary...\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n    }\n\n    // Process the markup...\n    switch (t->markup)\n    {\n      case MARKUP_IMG :\n          update_image_size(t);\n      case MARKUP_NONE :\n      case MARKUP_BR :\n          if (para->child == NULL)\n          {\n\t    if (t->parent == NULL)\n\t    {\n              para->halignment = ALIGN_LEFT;\n              para->indent     = 0;\n\t    }\n\t    else\n\t    {\n              para->halignment = t->parent->halignment;\n              para->indent     = t->parent->indent;\n\t    }\n          }\n\n\t  // Skip heading whitespace...\n          if (para->child == NULL && t->markup == MARKUP_NONE &&\n\t      t->data != NULL && strcmp((char *)t->data, \" \") == 0)\n\t    break;\n\n          if ((temp = htmlAddTree(para, t->markup, t->data)) != NULL)\n          {\n\t    temp->link          = t->link;\n            temp->width         = t->width;\n            temp->height        = t->height;\n            temp->typeface      = t->typeface;\n            temp->style         = t->style;\n            temp->size          = t->size;\n            temp->underline     = t->underline;\n            temp->strikethrough = t->strikethrough;\n            temp->superscript   = t->superscript;\n            temp->subscript     = t->subscript;\n            temp->halignment    = t->halignment;\n            temp->valignment    = t->valignment;\n            temp->red           = t->red;\n            temp->green         = t->green;\n            temp->blue          = t->blue;\n            for (i = 0, var = t->vars; i < t->nvars; i ++, var ++)\n              htmlSetVariable(temp, var->name, var->value);\n          }\n          break;\n\n      case MARKUP_TABLE :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n          }\n\n          parse_table(t, *left, *right, *bottom, *top, x, y, page, *needspace);\n\t  *needspace = 0;\n          break;\n\n      case MARKUP_H1 :\n      case MARKUP_H2 :\n      case MARKUP_H3 :\n      case MARKUP_H4 :\n      case MARKUP_H5 :\n      case MARKUP_H6 :\n      case MARKUP_H7 :\n      case MARKUP_H8 :\n      case MARKUP_H9 :\n      case MARKUP_H10 :\n      case MARKUP_H11 :\n      case MARKUP_H12 :\n      case MARKUP_H13 :\n      case MARKUP_H14 :\n      case MARKUP_H15 :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 1;\n          }\n\n          parse_heading(t, *left, *right, *bottom, *top, x, y, page, *needspace);\n\t  *needspace = 1;\n          break;\n\n      case MARKUP_BLOCKQUOTE :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 1;\n          }\n\n          *left  += 36;\n\t  *right -= 36;\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page, NULL,\n\t            needspace);\n\n          *left  -= 36;\n\t  *right += 36;\n\n          *x         = *left;\n          *needspace = 1;\n          break;\n\n      case MARKUP_CENTER :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n            *needspace = 1;\n          }\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page, NULL,\n\t            needspace);\n\n          *x         = *left;\n          *needspace = 1;\n          break;\n\n      case MARKUP_P :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 1;\n          }\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page, NULL,\n\t            needspace);\n\n          *x         = *left;\n          *needspace = 1;\n          break;\n\n      case MARKUP_DIV :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n          }\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page, NULL,\n\t            needspace);\n\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n          }\n          break;\n\n      case MARKUP_PRE :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 1;\n          }\n\n          *left += 36.0f;\n          *x    = *left;\n\n          parse_pre(t, *left, *right, *bottom, *top, x, y, page, *needspace);\n\n          *left      -= 36.0f;\n          *x         = *left;\n          *needspace = 1;\n          break;\n\n      case MARKUP_DIR :\n      case MARKUP_MENU :\n      case MARKUP_UL :\n      case MARKUP_OL :\n          init_list(t);\n      case MARKUP_DL :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n          }\n\n          if (t->indent == 1)\n\t    *needspace = 1;\n\n\t  *left += 36.0f;\n          *x    = *left;\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page, para,\n\t            needspace);\n\n          *left -= 36.0f;\n\n          if (t->indent == 1)\n\t    *needspace = 1;\n          break;\n\n      case MARKUP_LI :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 0;\n          }\n\n          parse_list(t, left, right, bottom, top, x, y, page, *needspace);\n\n          *x         = *left;\n          *needspace = t->next && t->next->markup != MARKUP_LI &&\n\t               t->next->markup != MARKUP_UL &&\n\t\t       t->next->markup != MARKUP_OL;\n          break;\n\n      case MARKUP_DT :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 0;\n          }\n\n\t  *left -= 36.0f;\n          *x    = *left;\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page,\n\t            NULL, needspace);\n\n\t  *left      += 36.0f;\n          *x         = *left;\n          *needspace = 0;\n          break;\n\n      case MARKUP_DD :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n\n\t    *needspace = 0;\n          }\n\n          parse_doc(t->child, left, right, bottom, top, x, y, page, NULL,\n\t            needspace);\n\n          *x         = *left;\n          *needspace = 0;\n          break;\n\n      case MARKUP_HR :\n          if (para->child != NULL)\n          {\n            parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n            htmlDeleteTree(para->child);\n            para->child = para->last_child = NULL;\n          }\n\n          if (htmlGetVariable(t, (uchar *)\"BREAK\") == NULL)\n\t  {\n\t   /*\n\t    * Generate a horizontal rule...\n\t    */\n\n            if ((name = htmlGetVariable(t, (uchar *)\"WIDTH\")) == NULL)\n\t      width = *right - *left;\n\t    else\n\t    {\n\t      if (strchr((char *)name, '%') != NULL)\n\t        width = atoi((char *)name) * (*right - *left) / 100;\n\t      else\n                width = (float)(atoi((char *)name) * PagePrintWidth / _htmlBrowserWidth);\n            }\n\n            if ((name = htmlGetVariable(t, (uchar *)\"SIZE\")) == NULL)\n\t      height = 2;\n\t    else\n\t      height = (float)(atoi((char *)name) * PagePrintWidth / _htmlBrowserWidth);\n\n            switch (t->halignment)\n\t    {\n\t      case ALIGN_LEFT :\n\t          *x = *left;\n\t\t  break;\n\t      case ALIGN_CENTER :\n\t          *x = *left + (*right - *left - width) * 0.5f;\n\t\t  break;\n\t      case ALIGN_RIGHT :\n\t          *x = *right - width;\n\t\t  break;\n\t    }\n\n            if (*y < (*bottom + height + _htmlSpacings[SIZE_P]))\n\t    {\n\t     /*\n\t      * Won't fit on this page...\n\t      */\n\n              (*page) ++;\n\t      if (Verbosity)\n\t        progress_show(\"Formatting page %d\", *page);\n              *y = *top;\n            }\n\n            (*y)   -= height + _htmlSpacings[SIZE_P];\n            rgb[0] = t->red / 255.0f;\n            rgb[1] = t->green / 255.0f;\n            rgb[2] = t->blue / 255.0f;\n\n            new_render(*page, RENDER_BOX, *x, *y + _htmlSpacings[SIZE_P] * 0.5,\n\t               width, height, rgb);\n\t  }\n\t  else\n\t  {\n\t   /*\n\t    * <HR BREAK> generates a page break...\n\t    */\n\n            (*page) ++;\n\t    if (Verbosity)\n\t      progress_show(\"Formatting page %d\", *page);\n            *y = *top;\n\t  }\n\n          *x         = *left;\n          *needspace = 0;\n          break;\n\n      case MARKUP_COMMENT :\n          // Check comments for commands...\n          parse_comment(t, left, right, bottom, top, x, y, page, para,\n\t                *needspace);\n          break;\n\n      case MARKUP_HEAD : // Ignore document HEAD section\n      case MARKUP_TITLE : // Ignore title and meta stuff\n      case MARKUP_META :\n      case MARKUP_SCRIPT : // Ignore script stuff\n      case MARKUP_INPUT : // Ignore form stuff\n      case MARKUP_SELECT :\n      case MARKUP_OPTION :\n      case MARKUP_TEXTAREA :\n          break;\n\n      case MARKUP_STYLE :\n          break;\n\n      case MARKUP_A :\n          if (htmlGetVariable(t, (uchar *)\"NAME\") != NULL)\n\t  {\n\t   /*\n\t    * Add this named destination to the paragraph tree...\n\t    */\n\n            if (para->child == NULL)\n            {\n              para->halignment = t->halignment;\n              para->indent     = t->indent;\n            }\n\n            if ((temp = htmlAddTree(para, t->markup, t->data)) != NULL)\n            {\n\t      temp->link          = t->link;\n              temp->width         = t->width;\n              temp->height        = t->height;\n              temp->typeface      = t->typeface;\n              temp->style         = t->style;\n              temp->size          = t->size;\n              temp->underline     = t->underline;\n              temp->strikethrough = t->strikethrough;\n              temp->superscript   = t->superscript;\n              temp->subscript     = t->subscript;\n              temp->halignment    = t->halignment;\n              temp->valignment    = t->valignment;\n              temp->red           = t->red;\n              temp->green         = t->green;\n              temp->blue          = t->blue;\n              for (i = 0, var = t->vars; i < t->nvars; i ++, var ++)\n        \thtmlSetVariable(temp, var->name, var->value);\n            }\n\t  }\n\n      default :\n\t  if (t->child != NULL)\n            parse_doc(t->child, left, right, bottom, top, x, y, page, para,\n\t              needspace);\n          break;\n    }\n\n\n    // Check for some basic stylesheet stuff...\n    if ((style = htmlGetStyle(t, (uchar *)\"page-break-after:\")) != NULL &&\n\tstrcasecmp((char *)style, \"avoid\") != 0)\n    {\n      // Advance to the next page...\n      (*page) ++;\n      *x         = *left;\n      *y         = *top;\n      *needspace = 0;\n\n      // See if we need to go to the next left/righthand page...\n      if (PageDuplex && ((*page) & 1) &&\n          strcasecmp((char *)style, \"right\") == 0)\n\t(*page) ++;\n      else if (PageDuplex && !((*page) & 1) &&\n               strcasecmp((char *)style, \"left\") == 0)\n\t(*page) ++;\n\n      // Update the progress as necessary...\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n    }\n\n    // Move to the next node...\n    t = t->next;\n  }\n\n  if (para->child != NULL && cpara != para)\n  {\n    parse_paragraph(para, *left, *right, *bottom, *top, x, y, page, *needspace);\n    htmlDeleteTree(para->child);\n    para->child = para->last_child = NULL;\n    *needspace  = 0;\n  }\n\n  if (cpara != para)\n    htmlDeleteTree(para);\n\n  DEBUG_printf((\"LEAVING parse_doc(), x = %.1f, y = %.1f, page = %d\\n\",\n                *x, *y, *page));\n}\n\n\n/*\n * 'parse_heading()' - Parse a heading tree and produce rendering list output.\n */\n\nstatic void\nparse_heading(tree_t *t,\t/* I - Tree to parse */\n              float  left,\t/* I - Left margin */\n              float  right,\t/* I - Printable width */\n              float  bottom,\t/* I - Bottom margin */\n              float  top,\t/* I - Printable top */\n              float  *x,\t/* IO - X position */\n              float  *y,\t/* IO - Y position */\n              int    *page,\t/* IO - Page # */\n              int    needspace)\t/* I - Need whitespace? */\n{\n  int\t*temp;\t\t\t// Temporary integer array pointer\n\n\n  DEBUG_printf((\"parse_heading(t=%p, left=%.1f, right=%.1f, bottom=%.1f, top=%.1f, x=%.1f, y=%.1f, page=%d, needspace=%d\\n\",\n                (void *)t, left, right, bottom, top, *x, *y, *page, needspace));\n\n  if (((t->markup - MARKUP_H1) < TocLevels || TocLevels == 0) && !title_page)\n    current_heading = t->child;\n\n  if (*y < (5 * _htmlSpacings[SIZE_P] + bottom))\n  {\n    (*page) ++;\n    *y = top;\n    if (Verbosity)\n      progress_show(\"Formatting page %d\", *page);\n  }\n\n  check_pages(*page);\n\n  if (t->markup == MARKUP_H1 && !title_page)\n    pages[*page].chapter = htmlGetText(current_heading);\n\n  if ((pages[*page].heading == NULL || t->markup == MARKUP_H1 ||\n      (*page > 0 && pages[*page].heading == pages[*page - 1].heading)) &&\n      !title_page)\n  {\n    pages[*page].heading  = htmlGetText(current_heading);\n    pages[*page].headnode = current_heading;\n  }\n\n  if ((t->markup - MARKUP_H1) < TocLevels && !title_page)\n  {\n    DEBUG_printf((\"H%d: heading_pages[%d] = %d\\n\", t->markup - MARKUP_H1 + 1,\n                  (int)num_headings, *page - 1));\n\n    // See if we need to resize the headings arrays...\n    if (num_headings >= alloc_headings)\n    {\n      alloc_headings += ALLOC_HEADINGS;\n\n      if (num_headings == 0)\n        temp = (int *)malloc(sizeof(int) * alloc_headings);\n      else\n        temp = (int *)realloc(heading_pages, sizeof(int) * alloc_headings);\n\n      if (temp == NULL)\n      {\n        progress_error(HD_ERROR_OUT_OF_MEMORY,\n                       \"Unable to allocate memory for %d headings - %s\",\n\t               (int)alloc_headings, strerror(errno));\n\talloc_headings -= ALLOC_HEADINGS;\n\treturn;\n      }\n\n      memset(temp + alloc_headings - ALLOC_HEADINGS, 0,\n             sizeof(int) * ALLOC_HEADINGS);\n\n      heading_pages = temp;\n\n      if (num_headings == 0)\n        temp = (int *)malloc(sizeof(int) * alloc_headings);\n      else\n        temp = (int *)realloc(heading_tops, sizeof(int) * alloc_headings);\n\n      if (temp == NULL)\n      {\n        progress_error(HD_ERROR_OUT_OF_MEMORY,\n                       \"Unable to allocate memory for %d headings - %s\",\n\t               (int)alloc_headings, strerror(errno));\n\talloc_headings -= ALLOC_HEADINGS;\n\treturn;\n      }\n\n      memset(temp + alloc_headings - ALLOC_HEADINGS, 0,\n             sizeof(int) * ALLOC_HEADINGS);\n\n      heading_tops = temp;\n    }\n\n    heading_pages[num_headings] = *page;\n    heading_tops[num_headings]  = (int)(*y + 4 * _htmlSpacings[SIZE_P]);\n    num_headings ++;\n  }\n\n  parse_paragraph(t, left, right, bottom, top, x, y, page, needspace);\n\n  if (t->halignment == ALIGN_RIGHT && t->markup == MARKUP_H1 &&\n      OutputType == OUTPUT_BOOK && !title_page)\n  {\n   /*\n    * Special case - chapter heading for users manual...\n    */\n\n    *y = bottom + 0.5f * (top - bottom);\n  }\n}\n\n#if defined(PARA_DEBUG) && !defined(DEBUG)\n#  undef DEBUG_printf\n#  undef DEBUG_puts\n#  define DEBUG_printf(x) printf x\n#  define DEBUG_puts(x) puts(x)\n#endif /* PARA_DEBUG && !defined(DEBUG) */\n\n\n/*\n * 'parse_paragraph()' - Parse a paragraph tree and produce rendering list\n *                       output.\n */\n\nstatic void\nparse_paragraph(tree_t *t,\t/* I - Tree to parse */\n        \tfloat  left,\t/* I - Left margin */\n        \tfloat  right,\t/* I - Printable width */\n        \tfloat  bottom,\t/* I - Bottom margin */\n        \tfloat  top,\t/* I - Printable top */\n        \tfloat  *x,\t/* IO - X position */\n        \tfloat  *y,\t/* IO - Y position */\n        \tint    *page,\t/* IO - Page # */\n        \tint    needspace)/* I - Need whitespace? */\n{\n  int\t\twhitespace;\t/* Non-zero if a fragment ends in whitespace */\n  tree_t\t*flat,\n\t\t*start,\n\t\t*end,\n\t\t*prev,\n\t\t*temp;\n  float\t\twidth,\n\t\theight,\n\t\toffset,\n\t\tspacing,\n\t\tborderspace,\n\t\ttemp_y,\n\t\ttemp_width,\n\t\ttemp_height;\n  float\t\tformat_width, image_y, image_left, image_right;\n  int\t\timage_page = *page;\n  float\t\tchar_spacing;\n  int\t\tnum_chars;\n  render_t\t*r;\n  uchar\t\t*align,\n\t\t*hspace,\n\t\t*vspace,\n\t\t*link,\n\t\t*border;\n  float\t\trgb[3];\n  uchar\t\tline[10240],\n\t\t*lineptr,\n\t\t*dataptr;\n  tree_t\t*linetype;\n  float\t\tlinex,\n\t\tlinewidth;\n  int\t\tfirstline;\n\n\n  DEBUG_printf((\"parse_paragraph(t=%p, left=%.1f, right=%.1f, bottom=%.1f, top=%.1f, x=%.1f, y=%.1f, page=%d, needspace=%d\\n\",\n                (void *)t, left, right, bottom, top, *x, *y, *page, needspace));\n\n  flat        = flatten_tree(t->child);\n  image_left  = left;\n  image_right = right;\n  image_y     = 0;\n\n  if (flat == NULL)\n    DEBUG_puts(\"parse_paragraph: flat == NULL!\");\n\n  // Add leading whitespace...\n  if (*y < top && needspace)\n    *y -= _htmlSpacings[SIZE_P];\n\n /*\n  * First scan for images with left/right alignment tags...\n  */\n\n  for (temp = flat, prev = NULL; temp != NULL;)\n  {\n    if (temp->markup == MARKUP_IMG)\n      update_image_size(temp);\n\n    if (temp->markup == MARKUP_IMG &&\n        (align = htmlGetVariable(temp, (uchar *)\"ALIGN\")))\n    {\n      if ((border = htmlGetVariable(temp, (uchar *)\"BORDER\")) != NULL)\n\tborderspace = (float)atof((char *)border);\n      else if (temp->link)\n\tborderspace = 1;\n      else\n\tborderspace = 0;\n\n      borderspace *= PagePrintWidth / _htmlBrowserWidth;\n\n      if (strcasecmp((char *)align, \"LEFT\") == 0)\n      {\n        if ((vspace = htmlGetVariable(temp, (uchar *)\"VSPACE\")) != NULL)\n\t  *y -= atoi((char *)vspace);\n\n        if (*y < (bottom + temp->height + 2 * borderspace))\n        {\n\t  (*page) ++;\n\t  *y = top;\n\n\t  if (Verbosity)\n\t    progress_show(\"Formatting page %d\", *page);\n        }\n\n        if (borderspace > 0.0f)\n\t{\n\t  if (temp->link && PSLevel == 0)\n\t    memcpy(rgb, link_color, sizeof(rgb));\n\t  else\n\t  {\n\t    rgb[0] = temp->red / 255.0f;\n\t    rgb[1] = temp->green / 255.0f;\n\t    rgb[2] = temp->blue / 255.0f;\n\t  }\n\n\t  // Top\n          new_render(*page, RENDER_BOX, image_left, *y - borderspace,\n\t\t     temp->width + 2 * borderspace, borderspace, rgb);\n\t  // Left\n          new_render(*page, RENDER_BOX, image_left,\n\t             *y - temp->height - 2 * borderspace,\n                     borderspace, temp->height + 2 * borderspace, rgb);\n\t  // Right\n          new_render(*page, RENDER_BOX, image_left + temp->width + borderspace,\n\t             *y - temp->height - 2 * borderspace,\n                     borderspace, temp->height + 2 * borderspace, rgb);\n\t  // Bottom\n          new_render(*page, RENDER_BOX, image_left,\n\t             *y - temp->height - 2 * borderspace,\n                     temp->width + 2 * borderspace, borderspace, rgb);\n\t}\n\n        *y -= borderspace;\n\n        new_render(*page, RENDER_IMAGE, image_left + borderspace,\n\t           *y - temp->height, temp->width, temp->height,\n\t\t   image_find((char *)htmlGetVariable(temp, (uchar *)\"REALSRC\")));\n\n        if (temp->link &&\n\t    (link = htmlGetVariable(temp->link, (uchar *)\"_HD_FULL_HREF\")) != NULL)\n        {\n\t /*\n\t  * Add a page link...\n\t  */\n\n\t  new_render(*page, RENDER_LINK, image_left + borderspace, *y - temp->height, temp->width, temp->height, link);\n        }\n\n        *y -= borderspace;\n\n        if (vspace != NULL)\n\t  *y -= atoi((char *)vspace);\n\n        image_left += temp->width + 2 * borderspace;\n\ttemp_y     = *y - temp->height;\n\timage_page = *page;\n\n\tif (temp_y < image_y || image_y == 0)\n\t  image_y = temp_y;\n\n        if ((hspace = htmlGetVariable(temp, (uchar *)\"HSPACE\")) != NULL)\n\t  image_left += atoi((char *)hspace);\n\n        if (prev != NULL)\n          prev->next = temp->next;\n        else\n          flat = temp->next;\n\n        free(temp);\n        temp = prev;\n      }\n      else if (strcasecmp((char *)align, \"RIGHT\") == 0)\n      {\n        if ((vspace = htmlGetVariable(temp, (uchar *)\"VSPACE\")) != NULL)\n\t  *y -= atoi((char *)vspace);\n\n        if (*y < (bottom + temp->height + 2 * borderspace))\n        {\n\t  (*page) ++;\n\t  *y = top;\n\n\t  if (Verbosity)\n\t    progress_show(\"Formatting page %d\", *page);\n        }\n\n        image_right -= temp->width + 2 * borderspace;\n\timage_page = *page;\n\n        if (borderspace > 0.0f)\n\t{\n\t  if (temp->link && PSLevel == 0)\n\t    memcpy(rgb, link_color, sizeof(rgb));\n\t  else\n\t  {\n\t    rgb[0] = temp->red / 255.0f;\n\t    rgb[1] = temp->green / 255.0f;\n\t    rgb[2] = temp->blue / 255.0f;\n\t  }\n\n\t  // Top\n          new_render(*page, RENDER_BOX, image_right, *y - borderspace,\n\t\t     temp->width + 2 * borderspace, borderspace, rgb);\n\t  // Left\n          new_render(*page, RENDER_BOX, image_right,\n\t             *y - temp->height - 2 * borderspace,\n                     borderspace, temp->height + 2 * borderspace, rgb);\n\t  // Right\n          new_render(*page, RENDER_BOX, image_right + temp->width + borderspace,\n\t             *y - temp->height - 2 * borderspace,\n                     borderspace, temp->height + 2 * borderspace, rgb);\n\t  // Bottom\n          new_render(*page, RENDER_BOX, image_right, *y - temp->height - 2 * borderspace,\n                     temp->width + 2 * borderspace, borderspace, rgb);\n\t}\n\n        *y -= borderspace;\n\n        new_render(*page, RENDER_IMAGE, image_right + borderspace,\n\t           *y - temp->height, temp->width, temp->height,\n\t\t   image_find((char *)htmlGetVariable(temp, (uchar *)\"REALSRC\")));\n\n        if (temp->link &&\n\t    (link = htmlGetVariable(temp->link, (uchar *)\"_HD_FULL_HREF\")) != NULL)\n        {\n\t /*\n\t  * Add a page link...\n\t  */\n\n\t  new_render(*page, RENDER_LINK, image_right + borderspace, *y - temp->height, temp->width, temp->height, link);\n        }\n\n        *y -= borderspace;\n\n        if (vspace != NULL)\n\t  *y -= atoi((char *)vspace);\n\n\ttemp_y = *y - temp->height;\n\n\tif (temp_y < image_y || image_y == 0)\n\t  image_y = temp_y;\n\n        if ((hspace = htmlGetVariable(temp, (uchar *)\"HSPACE\")) != NULL)\n\t  image_right -= atoi((char *)hspace);\n\n        if (prev != NULL)\n          prev->next = temp->next;\n        else\n          flat = temp->next;\n\n        free(temp);\n        temp = prev;\n      }\n    }\n\n    if (temp != NULL)\n    {\n      prev = temp;\n      temp = temp->next;\n    }\n    else\n      temp = flat;\n  }\n\n /*\n  * Then format the text and inline images...\n  */\n\n  format_width = image_right - image_left;\n  firstline    = 1;\n\n  DEBUG_printf((\"format_width = %.1f\\n\", format_width));\n\n  // Make stupid compiler warnings go away (if you can't put\n  // enough smarts in the compiler, don't add the warning!)\n  offset      = 0.0f;\n  temp_width  = 0.0f;\n  temp_height = 0.0f;\n  lineptr     = NULL;\n  linex       = 0.0f;\n  linewidth   = 0.0f;\n\n  while (flat != NULL)\n  {\n    start = flat;\n    end   = flat;\n    width = 0.0;\n\n    while (flat != NULL)\n    {\n      // Get fragments...\n      temp_width = 0.0;\n      temp       = flat;\n      whitespace = 0;\n\n      while (temp != NULL && !whitespace)\n      {\n        if (temp->markup == MARKUP_NONE && temp->data[0] == ' ')\n\t{\n          if (temp == start)\n            temp_width -= _htmlWidths[temp->typeface][temp->style][' '] *\n                          _htmlSizes[temp->size] * 0.001f;\n          else if (temp_width > 0.0f)\n\t    whitespace = 1;\n\t}\n        else\n          whitespace = 0;\n\n        if (whitespace)\n\t  break;\n\n        if (temp->markup == MARKUP_IMG)\n\t{\n\t  if ((border = htmlGetVariable(temp, (uchar *)\"BORDER\")) != NULL)\n\t    borderspace = (float)atof((char *)border);\n\t  else if (temp->link)\n\t    borderspace = 1;\n\t  else\n\t    borderspace = 0;\n\n          borderspace *= PagePrintWidth / _htmlBrowserWidth;\n\n          temp_width += 2 * borderspace;\n\t}\n\n        prev       = temp;\n        temp       = temp->next;\n        temp_width += prev->width;\n\n        if ((temp_width >= format_width && prev->markup == MARKUP_IMG) ||\n\t    prev->markup == MARKUP_BR)\n\t{\n\t  break;\n\t}\n\telse if (prev->markup == MARKUP_NONE)\n\t{\n\t  int\tch = prev->data[strlen((char *)prev->data) - 1];\n\n\t  if (_htmlUTF8)\n\t    ch = _htmlUnicode[ch];\n\n          if (ch == 173)\n            break;\n\t}\n      }\n\n      if ((width + temp_width) <= format_width)\n      {\n        width += temp_width;\n        end  = temp;\n        flat = temp;\n\n        if (prev->markup == MARKUP_BR)\n          break;\n      }\n      else if (width == 0.0)\n      {\n        width += temp_width;\n        end  = temp;\n        flat = temp;\n        break;\n      }\n      else\n        break;\n    }\n\n    if (start == end)\n    {\n      end   = start->next;\n      flat  = start->next;\n      width = start->width;\n    }\n\n    for (height = 0.0, num_chars = 0, temp = prev = start;\n         temp != end;\n\t temp = temp->next)\n    {\n      prev = temp;\n\n      if (temp->markup == MARKUP_NONE)\n        num_chars += strlen((char *)temp->data);\n\n      if (temp->height > height)\n        height = temp->height;\n    }\n\n    for (spacing = 0.0, temp = prev = start;\n         temp != end;\n\t temp = temp->next)\n    {\n      prev = temp;\n\n      if (temp->markup != MARKUP_IMG)\n        temp_height = (float)(temp->height * _htmlSpacings[0] / _htmlSizes[0]);\n      else\n      {\n\tif ((border = htmlGetVariable(temp, (uchar *)\"BORDER\")) != NULL)\n\t  borderspace = (float)atof((char *)border);\n\telse if (temp->link)\n\t  borderspace = 1;\n\telse\n\t  borderspace = 0;\n\n        borderspace *= PagePrintWidth / _htmlBrowserWidth;\n\n        temp_height = temp->height + 2 * borderspace;\n      }\n\n      if (temp_height > spacing)\n        spacing = temp_height;\n    }\n\n    if (firstline && end != NULL && *y < (bottom + height + _htmlSpacings[t->size]))\n    {\n      // Go to next page since only 1 line will fit on this one...\n      (*page) ++;\n      *y = top;\n\n      if (Verbosity)\n        progress_show(\"Formatting page %d\", *page);\n    }\n\n    firstline = 0;\n\n    if (height == 0.0f)\n      height = spacing;\n\n    for (temp = start; temp != end; temp = temp->next)\n      if (temp->markup != MARKUP_A)\n        break;\n\n    if (temp != NULL && temp->markup == MARKUP_NONE && temp->data[0] == ' ')\n    {\n      // Drop leading space...\n      for (dataptr = temp->data; *dataptr; dataptr ++)\n        *dataptr = dataptr[1];\n      *dataptr = '\\0';\n\n      temp_width = _htmlWidths[temp->typeface][temp->style][' '] * _htmlSizes[temp->size] * 0.001f;\n      temp->width -= temp_width;\n      num_chars --;\n    }\n\n    if (end != NULL)\n      temp = end->prev;\n    else\n      temp = NULL;\n\n    DEBUG_printf((\"    BEFORE page=%d, y=%.1f, height=%.1f, spacing=%.1f, bottom=%.1f\\n\", *page, *y, height, spacing, bottom));\n\n    if (*y < (spacing + bottom))\n    {\n      (*page) ++;\n      *y = top;\n\n      if (Verbosity)\n        progress_show(\"Formatting page %d\", *page);\n    }\n\n    *y -= height;\n\n    DEBUG_printf((\"    page=%d, y=%.1f, width=%.1f, height=%.1f\\n\", *page, *y, width, height));\n\n    if (Verbosity)\n      progress_update(100 - (int)(100 * (*y) / PagePrintLength));\n\n    char_spacing = 0.0f;\n    whitespace   = 0;\n    temp         = start;\n    linetype     = NULL;\n\n    rgb[0] = temp->red / 255.0f;\n    rgb[1] = temp->green / 255.0f;\n    rgb[2] = temp->blue / 255.0f;\n\n    switch (t->halignment)\n    {\n      case ALIGN_LEFT :\n          linex = image_left;\n\t  break;\n\n      case ALIGN_CENTER :\n          linex = image_left + 0.5f * (format_width - width);\n\t  break;\n\n      case ALIGN_RIGHT :\n          linex = image_right - width;\n\t  break;\n\n      case ALIGN_JUSTIFY :\n          linex = image_left;\n\t  if (flat != NULL && flat->prev->markup != MARKUP_BR && num_chars > 1)\n\t    char_spacing = (format_width - width) / (num_chars - 1);\n\t  break;\n    }\n\n    while (temp != end)\n    {\n      if (temp->link != NULL && PSLevel == 0 && Links &&\n          temp->markup == MARKUP_NONE)\n      {\n\ttemp->red   = (uchar)(link_color[0] * 255.0);\n\ttemp->green = (uchar)(link_color[1] * 255.0);\n\ttemp->blue  = (uchar)(link_color[2] * 255.0);\n      }\n\n     /*\n      * See if we are doing a run of characters in a line and need to\n      * output this run...\n      */\n\n      if (linetype != NULL &&\n\t  (temp->markup != MARKUP_NONE ||\n\t   temp->typeface != linetype->typeface ||\n\t   temp->style != linetype->style ||\n\t   temp->size != linetype->size ||\n\t   temp->superscript != linetype->superscript ||\n\t   temp->subscript != linetype->subscript ||\n\t   temp->red != linetype->red ||\n\t   temp->green != linetype->green ||\n\t   temp->blue != linetype->blue))\n      {\n        r = new_render(*page, RENDER_TEXT, linex - linewidth, *y,\n\t               linewidth, linetype->height, line);\n\tr->data.text.typeface = linetype->typeface;\n\tr->data.text.style    = linetype->style;\n\tr->data.text.size     = (float)_htmlSizes[linetype->size];\n\tr->data.text.spacing  = char_spacing;\n        memcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n\tif (linetype->superscript)\n          r->y += height - linetype->height;\n        else if (linetype->subscript)\n          r->y -= height - linetype->height;\n\n        free(linetype);\n        linetype = NULL;\n      }\n\n      if ((link = htmlGetVariable(temp, (uchar *)\"ID\")) != NULL)\n      {\n       /*\n\t* Add a target link...\n\t*/\n\n\tadd_link(link, *page, (int)(*y + height));\n      }\n\n      switch (temp->markup)\n      {\n        case MARKUP_A :\n            if ((link = htmlGetVariable(temp, (uchar *)\"NAME\")) != NULL)\n            {\n             /*\n              * Add a target link...\n              */\n\n              add_link(link, *page, (int)(*y + height));\n            }\n\n\tdefault :\n\t    temp_width = temp->width;\n            break;\n\n        case MARKUP_NONE :\n            if (temp->data == NULL)\n              break;\n\n\t    if (((temp->width - right + left) > 0.001 ||\n\t         (temp->height - top + bottom) > 0.001)  && OverflowErrors)\n\t      progress_error(HD_ERROR_CONTENT_TOO_LARGE,\n\t                     \"Text on page %d too large - \"\n\t\t\t     \"truncation or overlapping may occur!\", *page + 1);\n\n            if (linetype == NULL)\n            {\n\t      linetype  = temp;\n\t      lineptr   = line;\n\t      linewidth = 0.0;\n\n\t      rgb[0] = temp->red / 255.0f;\n\t      rgb[1] = temp->green / 255.0f;\n\t      rgb[2] = temp->blue / 255.0f;\n\t    }\n\n            strlcpy((char *)lineptr, (char *)temp->data, sizeof(line) - (size_t)(lineptr - line));\n\n            temp_width = temp->width + char_spacing * strlen((char *)lineptr);\n\n\t    if (temp->underline || (temp->link && LinkStyle && PSLevel == 0))\n\t      new_render(*page, RENDER_BOX, linex, *y - 1, temp_width, 0, rgb);\n\n\t    if (temp->strikethrough)\n\t      new_render(*page, RENDER_BOX, linex, *y + temp->height * 0.25f,\n\t                 temp_width, 0, rgb);\n\n            linewidth  += temp_width;\n            lineptr    += strlen((char *)lineptr);\n\n            if (lineptr > line && lineptr[-1] == ' ')\n              whitespace = 1;\n            else\n              whitespace = 0;\n\t    break;\n\n\tcase MARKUP_IMG :\n\t    if (((temp->width - right + left) > 0.001 ||\n\t         (temp->height - top + bottom) > 0.001) && OverflowErrors)\n\t    {\n\t      DEBUG_printf((\"IMAGE: %.3fx%.3f > %.3fx%.3f\\n\",\n\t                    temp->width, temp->height,\n\t\t\t    right - left, top - bottom));\n\n\t      progress_error(HD_ERROR_CONTENT_TOO_LARGE,\n\t                     \"Image on page %d too large - \"\n\t\t\t     \"truncation or overlapping may occur!\", *page + 1);\n            }\n\n\t    if ((border = htmlGetVariable(temp, (uchar *)\"BORDER\")) != NULL)\n\t      borderspace = (float)atof((char *)border);\n\t    else if (temp->link)\n\t      borderspace = 1;\n\t    else\n\t      borderspace = 0;\n\n            borderspace *= PagePrintWidth / _htmlBrowserWidth;\n\n            temp_width += 2 * borderspace;\n\n\t    switch (temp->valignment)\n\t    {\n\t      case ALIGN_TOP :\n\t\t  offset = height - temp->height - 2 * borderspace;\n\t\t  break;\n\t      case ALIGN_MIDDLE :\n\t\t  offset = 0.5f * (height - temp->height) - borderspace;\n\t\t  break;\n\t      case ALIGN_BOTTOM :\n\t\t  offset = 0.0f;\n\t    }\n\n            if (borderspace > 0.0f)\n\t    {\n\t      // Top\n              new_render(*page, RENDER_BOX, linex,\n\t                 *y + offset + temp->height + borderspace,\n\t\t\t temp->width + 2 * borderspace, borderspace, rgb);\n\t      // Left\n              new_render(*page, RENDER_BOX, linex, *y + offset,\n                \t borderspace, temp->height + 2 * borderspace, rgb);\n\t      // Right\n              new_render(*page, RENDER_BOX, linex + temp->width + borderspace,\n\t                 *y + offset, borderspace,\n\t\t\t temp->height + 2 * borderspace, rgb);\n\t      // Bottom\n              new_render(*page, RENDER_BOX, linex, *y + offset,\n                \t temp->width + 2 * borderspace, borderspace, rgb);\n\t    }\n\n\t    new_render(*page, RENDER_IMAGE, linex + borderspace,\n\t               *y + offset + borderspace, temp->width, temp->height,\n\t\t       image_find((char *)htmlGetVariable(temp, (uchar *)\"REALSRC\")));\n            whitespace = 0;\n\t    temp_width = temp->width + 2 * borderspace;\n\t    break;\n      }\n\n      if (temp->link != NULL &&\n          (link = htmlGetVariable(temp->link, (uchar *)\"_HD_FULL_HREF\")) != NULL)\n      {\n       /*\n\t* Add a page link...\n\t*/\n\n\tnew_render(*page, RENDER_LINK, linex, *y + offset, temp->width, temp->height, link);\n      }\n\n      linex += temp_width;\n      prev = temp;\n      temp = temp->next;\n      if (prev != linetype)\n        free(prev);\n    }\n\n   /*\n    * See if we have a run of characters that hasn't been output...\n    */\n\n    if (linetype != NULL)\n    {\n      r = new_render(*page, RENDER_TEXT, linex - linewidth, *y,\n                     linewidth, linetype->height, line);\n      r->data.text.typeface = linetype->typeface;\n      r->data.text.style    = linetype->style;\n      r->data.text.spacing  = char_spacing;\n      r->data.text.size     = (float)_htmlSizes[linetype->size];\n      memcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n      if (linetype->superscript)\n        r->y += height - linetype->height;\n      else if (linetype->subscript)\n        r->y -= height - linetype->height;\n\n      free(linetype);\n    }\n\n   /*\n    * Update the margins after we pass below the images...\n    */\n\n    *y -= spacing - height;\n\n    DEBUG_printf((\"    AFTER y=%.1f, bottom=%.1f\\n\", *y, bottom));\n\n    if (*y < bottom)\n    {\n      (*page) ++;\n      *y = top;\n\n      if (Verbosity)\n        progress_show(\"Formatting page %d\", *page);\n    }\n\n    if (*y < image_y || *page > image_page)\n    {\n      image_y      = 0.0f;\n      image_left   = left;\n      image_right  = right;\n      format_width = image_right - image_left;\n    }\n  }\n\n  *x = left;\n  if (*y > image_y && image_y > 0.0f && image_page == *page)\n    *y = image_y;\n\n  DEBUG_printf((\"LEAVING parse_paragraph(), x = %.1f, y = %.1f, page = %d, image_y = %.1f\\n\", *x, *y, *page, image_y));\n}\n\n\n#if defined(PARA_DEBUG) && !defined(DEBUG)\n#  undef DEBUG_printf\n#  undef DEBUG_puts\n#  define DEBUG_printf(x)\n#  define DEBUG_puts(x)\n#endif /* PARA_DEBUG && !DEBUG */\n\n\n/*\n * 'parse_pre()' - Parse preformatted text and produce rendering list output.\n */\n\nstatic void\nparse_pre(tree_t *t,\t\t/* I - Tree to parse */\n          float  left,\t\t/* I - Left margin */\n          float  right,\t\t/* I - Printable width */\n          float  bottom,\t/* I - Bottom margin */\n          float  top,\t\t/* I - Printable top */\n          float  *x,\t\t/* IO - X position */\n          float  *y,\t\t/* IO - Y position */\n          int    *page,\t\t/* IO - Page # */\n          int    needspace)\t/* I - Need whitespace? */\n{\n  tree_t\t*flat, *start, *next;\n  uchar\t\t*link,\n\t\tline[10240],\n\t\t*lineptr,\n\t\t*dataptr;\n  int\t\tcol;\n  float\t\twidth,\n\t\theight,\n\t\trgb[3];\n  render_t\t*r;\n\n\n  REF(right);\n\n  DEBUG_printf((\"parse_pre(t=%p, left=%.1f, right=%.1f, x=%.1f, y=%.1f, page=%d\\n\",\n                (void *)t, left, right, *x, *y, *page));\n\n  if (t->child == NULL)\n    return;\n\n  if (*y < top && needspace)\n    *y -= _htmlSpacings[SIZE_P];\n\n  flat = flatten_tree(t->child);\n\n  if (flat == NULL)\n    return;\n\n  if (flat->markup == MARKUP_NONE && flat->data != NULL)\n  {\n    // Skip leading blank line, if present...\n    for (dataptr = flat->data; isspace(*dataptr); dataptr ++);\n\n    if (!*dataptr)\n    {\n      next = flat->next;\n      free(flat);\n      flat = next;\n    }\n  }\n\n  while (flat != NULL)\n  {\n    for (height = 0.0f, start = flat; flat != NULL; flat = flat->next)\n    {\n      if (flat->height > height)\n        height = flat->height;\n\n      if (flat->markup == MARKUP_BR ||\n          (flat->markup == MARKUP_NONE && flat->data &&\n\t   flat->data[strlen((char *)flat->data) - 1] == '\\n'))\n        break;\n    }\n\n    if (flat)\n      flat = flat->next;\n\n    if (*y < (height + bottom))\n    {\n      (*page) ++;\n      *y = top;\n\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n    }\n\n    *x = left;\n    *y -= height;\n\n    if (Verbosity)\n      progress_update(100 - (int)(100 * (*y) / PagePrintLength));\n\n    col = 0;\n    while (start != flat)\n    {\n      rgb[0] = start->red / 255.0f;\n      rgb[1] = start->green / 255.0f;\n      rgb[2] = start->blue / 255.0f;\n\n      if (start->link &&\n\t  (link = htmlGetVariable(start->link, (uchar *)\"_HD_FULL_HREF\")) != NULL)\n      {\n       /*\n\t* Add a page link...\n\t*/\n\n\tnew_render(*page, RENDER_LINK, *x, *y, start->width, start->height, link);\n\n\tif (PSLevel == 0 && Links)\n\t{\n          memcpy(rgb, link_color, sizeof(rgb));\n\n\t  start->red   = (uchar)(link_color[0] * 255.0);\n\t  start->green = (uchar)(link_color[1] * 255.0);\n\t  start->blue  = (uchar)(link_color[2] * 255.0);\n\n          if (LinkStyle)\n\t    new_render(*page, RENDER_BOX, *x, *y - 1, start->width, 0,\n\t               link_color);\n\t}\n      }\n\n      if ((link = htmlGetVariable(start, (uchar *)\"ID\")) != NULL)\n      {\n       /*\n\t* Add a target link...\n\t*/\n\n\tadd_link(link, *page, (int)(*y + height));\n      }\n\n      switch (start->markup)\n      {\n        case MARKUP_COMMENT :\n\t    parse_comment(start, &left, &right, &bottom, &top, x, y, page, NULL, 0);\n            break;\n\n\tcase MARKUP_A :\n            if ((link = htmlGetVariable(start, (uchar *)\"NAME\")) != NULL)\n            {\n             /*\n              * Add a target link...\n              */\n\n              add_link(link, *page, (int)(*y + height));\n            }\n            break;\n\n\tcase MARKUP_NONE :\n            for (lineptr = line, dataptr = start->data;\n\t\t *dataptr != '\\0' && lineptr < (line + sizeof(line) - 1);\n\t\t dataptr ++)\n              if (*dataptr == '\\n')\n\t\tbreak;\n              else if (*dataptr == '\\t')\n              {\n               /* This code changed after 15 years to work around new compiler optimization bugs (Issue #349) */\n                int num_cols = 8 - (col & 7);\n\n                memcpy(lineptr, \"        \", num_cols);\n                lineptr += num_cols;\n                col += num_cols;\n              }\n              else if (*dataptr != '\\r')\n              {\n        \t*lineptr++ = *dataptr;\n        \tcol ++;\n              }\n\n            *lineptr = '\\0';\n\n            width = get_width(line, start->typeface, start->style, start->size);\n            r = new_render(*page, RENDER_TEXT, *x, *y, width, 0, line);\n            r->data.text.typeface = start->typeface;\n            r->data.text.style    = start->style;\n            r->data.text.size     = (float)_htmlSizes[start->size];\n            memcpy(r->data.text.rgb, rgb, sizeof(rgb));\n\n\t    if (start->underline)\n\t      new_render(*page, RENDER_BOX, *x, *y - 1, start->width, 0, rgb);\n\n\t    if (start->strikethrough)\n\t      new_render(*page, RENDER_BOX, *x, *y + start->height * 0.25f,\n\t        \t start->width, 0, rgb);\n\n            *x += start->width;\n            break;\n\n\tcase MARKUP_IMG :\n\t    new_render(*page, RENDER_IMAGE, *x, *y, start->width, start->height,\n\t\t       image_find((char *)htmlGetVariable(start, (uchar *)\"REALSRC\")));\n\n            *x += start->width;\n            col ++;\n\t    break;\n\n\tdefault :\n            break;\n      }\n\n      next = start->next;\n      free(start);\n      start = next;\n\n    }\n\n    if ((*x - right) > 0.001 && OverflowErrors)\n      progress_error(HD_ERROR_CONTENT_TOO_LARGE,\n\t             \"Preformatted text on page %d too long - \"\n\t\t     \"truncation or overlapping may occur!\", *page + 1);\n\n    *y -= _htmlSpacings[t->size] - _htmlSizes[t->size];\n  }\n\n  *x = left;\n}\n\n\n//#define TABLE_DEBUG 1\n#ifdef TABLE_DEBUG\n#  undef DEBUG_puts\n#  define DEBUG_puts(x) puts(x)\n#  define DEBUG 1\n#  undef DEBUG_printf\n#  define DEBUG_printf(x) printf x\n#endif /* TABLE_DEBUG */\n\n\ntypedef struct\n{\n  int           debug;\n  int           num_cols,\n                num_rows;\n  float         border,\n\t\tborder_left,\n                border_rgb[3],\n\t\tborder_size,\n                cellpadding,\n                height;\n  int\t\tcol_spans[MAX_COLUMNS],\n\t\trow_spans[MAX_COLUMNS];\n  char\t\tcol_fixed[MAX_COLUMNS],\n\t\tcol_percent[MAX_COLUMNS];\n  float\t\tcol_lefts[MAX_COLUMNS],\n\t\tcol_rights[MAX_COLUMNS],\n\t\tcol_widths[MAX_COLUMNS],\n\t\tcol_swidths[MAX_COLUMNS],\n\t\tcol_mins[MAX_COLUMNS],\n\t\tcol_smins[MAX_COLUMNS],\n\t\tcol_prefs[MAX_COLUMNS];\n  int\t\tcell_page[MAX_COLUMNS],\t// Start page for cell\n\t\tcell_endpage[MAX_COLUMNS];\n\t\t\t\t\t// End page for cell\n  float\t\tcell_y[MAX_COLUMNS],\t// Row for each cell\n\t\tcell_endy[MAX_COLUMNS],\t// Row for each cell\n\t\tcell_height[MAX_COLUMNS],\n\t\t\t\t\t// Height of each cell in a row\n\t\tspan_heights[MAX_COLUMNS];\n\t\t\t\t\t// Height of spans\n  render_t\t*cell_bg[MAX_COLUMNS];\t// Background rectangles\n  render_t\t*cell_start[MAX_COLUMNS];\n\t\t\t\t\t// Start of the content for a cell in the row\n  render_t\t*cell_end[MAX_COLUMNS];\t// End of the content for a cell in a row\n} hdtable_t;\n\n\n/*\n * 'render_table_row()' - Render a table row.\n */\n\nstatic void\nrender_table_row(hdtable_t &table,\n                 tree_t    ***cells,\n                 int       row,\n                 uchar     *height_var,\n                 float     left,\t\t// I - Left margin\n                 float     right,\t\t// I - Printable width\n                 float     bottom,\t\t// I - Bottom margin\n                 float     top,\t\t\t// I - Printable top\n                 float     *x,\n                 float     *y,\n                 int       *page)\n{\n  int\t\tcol,\n\t\ttcol,\n\t\tcolspan,\n\t\trowspan,\n\t\ttempspace;\n  float\t\twidth,\n\t\ttemp_y;\n  int\t\ttemp_page;\n  uchar\t\t*var;\n  int\t\tdo_valign;\t\t// True if we should do vertical alignment of cells\n  int           row_page;\n  float\t\trow_y,\n                row_starty,\n                row_height,\t\t// Total height of the row\n\t\ttemp_height;\t\t// Temporary holder\n  uchar\t\t*bgcolor;\n  float\t\tbgrgb[3];\n\n\n  do_valign  = 1;\n  row_height = 0.0f;\n  row_page   = *page;\n  row_y      = *y - table.cellpadding;\n  row_starty = row_y;\n\n  DEBUG_printf((\"BEFORE row_y = %.1f, *y = %.1f, row_page = %d\\n\",\n                row_y, *y, row_page));\n\n  for (col = 0, rowspan = 9999; col < table.num_cols; col += colspan)\n  {\n    if (table.row_spans[col] == 0)\n    {\n      if ((var = htmlGetVariable(cells[row][col], (uchar *)\"ROWSPAN\")) != NULL)\n        table.row_spans[col] = atoi((char *)var);\n\n      if (table.row_spans[col] == 1)\n        table.row_spans[col] = 0;\n\n      if (table.row_spans[col] > (table.num_rows - row))\n        table.row_spans[col] = table.num_rows - row;\n\n      table.span_heights[col] = 0.0f;\n    }\n\n    if (table.row_spans[col] < rowspan)\n      rowspan = table.row_spans[col];\n\n    for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)\n      if (cells[row][col] != cells[row][col + colspan])\n        break;\n  }\n\n  if (!rowspan)\n    rowspan = 1;\n\n  for (col = 0; col < table.num_cols;)\n  {\n    for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)\n      if (cells[row][col] != cells[row][col + colspan])\n        break;\n    colspan --;\n\n    DEBUG_printf((\"    col = %d, colspan = %d, left = %.1f, right = %.1f, cell = %p\\n\", col, colspan, table.col_lefts[col], table.col_rights[col + colspan], (void *)cells[row][col]));\n\n    *x        = table.col_lefts[col];\n    temp_y    = *y - table.cellpadding;\n    temp_page = *page;\n    tempspace = 0;\n\n    if (row == 0 || cells[row][col] != cells[row - 1][col])\n    {\n      check_pages(*page);\n\n      if (cells[row][col] == NULL)\n        bgcolor = NULL;\n      else if ((bgcolor = htmlGetVariable(cells[row][col], (uchar *)\"BGCOLOR\")) != NULL)\n      {\n        memcpy(bgrgb, background_color, sizeof(bgrgb));\n\n        get_color(bgcolor, bgrgb, 0);\n\n        width       = table.col_rights[col + colspan] - table.col_lefts[col] + 2 * table.cellpadding;\n        table.border_left = table.col_lefts[col] - table.cellpadding;\n\n        table.cell_bg[col] = new_render(*page, RENDER_BOX, table.border_left, row_y, width + table.border, 0.0, bgrgb);\n      }\n      else\n      {\n        table.cell_bg[col] = NULL;\n\n        new_render(*page, RENDER_TEXT, -1.0f, -1.0f, 0.0, 0.0, (void *)\"\");\n      }\n\n      DEBUG_printf((\"cell_bg[%d] = %p, pages[%d].end = %p\\n\", col, (void *)table.cell_bg[col], *page, (void *)pages[*page].end));\n\n      table.cell_start[col] = pages[*page].end;\n      table.cell_page[col]  = temp_page;\n      table.cell_y[col]     = temp_y;\n\n      if (table.debug)\n      {\n        check_pages(*page);\n\n        render_t *r;\n        char table_text[255];\n\n        snprintf(table_text, sizeof(table_text), \"cell=%p [%d,%d]\",\n                 (void *)cells[row][col], row, col);\n        r = new_render(temp_page, RENDER_TEXT, *x, temp_y,\n                       get_width((uchar *)table_text, TYPE_COURIER, STYLE_NORMAL, 1),\n                       _htmlSizes[1], table_text);\n\n        r->data.text.typeface = TYPE_COURIER;\n        r->data.text.style    = STYLE_NORMAL;\n        r->data.text.size     = (float)_htmlSizes[1];\n      }\n\n      if (cells[row][col] != NULL && cells[row][col]->child != NULL)\n      {\n        DEBUG_printf((\"    parsing cell %d,%d; width = %.1f\\n\", row, col, table.col_rights[col + colspan] - table.col_lefts[col]));\n\n        bottom += table.cellpadding;\n        top    -= table.cellpadding;\n\n        parse_doc(cells[row][col]->child, table.col_lefts + col, table.col_rights + col + colspan, &bottom, &top, x, &temp_y, &temp_page, NULL, &tempspace);\n\n        bottom -= table.cellpadding;\n        top    += table.cellpadding;\n      }\n\n      table.cell_endpage[col] = temp_page;\n      table.cell_endy[col]    = temp_y;\n      table.cell_height[col]  = *y - table.cellpadding - temp_y;\n      table.cell_end[col]     = pages[*page].end;\n\n      if (table.cell_start[col] == NULL)\n        table.cell_start[col] = pages[*page].start;\n\n      DEBUG_printf((\"row = %d, col = %d, y = %.1f, cell_y = %.1f, cell_height = %.1f\\n\", row, col, *y - table.cellpadding, temp_y, table.cell_height[col]));\n      DEBUG_printf((\"cell_start[%d] = %p, cell_end[%d] = %p\\n\", col, (void *)table.cell_start[col], col, (void *)table.cell_end[col]));\n    }\n\n    if (table.row_spans[col] == 0 &&\n        table.cell_page[col] == table.cell_endpage[col] &&\n        table.cell_height[col] > row_height)\n      row_height = table.cell_height[col];\n\n    if (table.row_spans[col] <= rowspan)\n    {\n      if (table.cell_page[col] != table.cell_endpage[col])\n        do_valign = 0;\n\n      if (table.cell_endpage[col] > row_page)\n      {\n        row_page = table.cell_endpage[col];\n        row_y    = table.cell_endy[col];\n      }\n      else if (table.cell_endy[col] < row_y && table.cell_endpage[col] == row_page)\n        row_y = table.cell_endy[col];\n    }\n\n    DEBUG_printf((\"**** col = %d, row = %d, row_y = %.1f, row_page = %d\\n\", col, row, row_y, row_page));\n\n    for (col ++; colspan > 0; colspan --, col ++)\n    {\n      table.cell_start[col]   = NULL;\n      table.cell_page[col]    = table.cell_page[col - 1];\n      table.cell_y[col]       = table.cell_y[col - 1];\n      table.cell_end[col]     = NULL;\n      table.cell_endpage[col] = table.cell_endpage[col - 1];\n      table.cell_endy[col]    = table.cell_endy[col - 1];\n      table.cell_height[col]  = table.cell_height[col - 1];\n    }\n  }\n\n  DEBUG_printf((\"row = %d, row_y = %.1f, row_height = %.1f\\n\", row, row_y, row_height));\n\n  for (col = 0; col < table.num_cols; col += colspan)\n  {\n    for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)\n      if (cells[row][col] != cells[row][col + colspan])\n        break;\n\n    if (table.row_spans[col])\n      table.span_heights[col] += row_height;\n\n    DEBUG_printf((\"col = %d, cell_y = %.1f, cell_page = %d, cell_endpage = %d, row_spans = %d, span_heights = %.1f, cell_height = %.1f\\n\", col, table.cell_y[col], table.cell_page[col], table.cell_endpage[col], table.row_spans[col], table.span_heights[col], table.cell_height[col]));\n  }\n\n  for (col = 0; col < table.num_cols; col += colspan)\n  {\n    for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)\n      if (cells[row][col] != cells[row][col + colspan])\n        break;\n\n    if (table.row_spans[col] == rowspan &&\n        table.cell_page[col] == table.cell_endpage[col] &&\n        table.cell_height[col] > table.span_heights[col])\n    {\n      temp_height = table.cell_height[col] - table.span_heights[col];\n      row_height  += temp_height;\n      DEBUG_printf((\"Adjusting row-span height by %.1f, new row_height = %.1f\\n\", temp_height, row_height));\n\n      for (tcol = 0; tcol < table.num_cols; tcol ++)\n        if (table.row_spans[tcol])\n        {\n          table.span_heights[tcol] += temp_height;\n          DEBUG_printf((\"col = %d, span_heights = %.1f\\n\", tcol, table.span_heights[tcol]));\n        }\n    }\n  }\n\n  DEBUG_printf((\"AFTER row = %d, row_page = %d, row_y = %.1f, row_height = %.1f, *y = %.1f, do_valign = %d\\n\", row, row_page, row_y, row_height, *y, do_valign));\n\n /*\n  * Do the vertical alignment\n  */\n\n  if (do_valign)\n  {\n    height_var = NULL;\n\n    if (cells[row][0] != NULL)\n    {\n      if ((height_var = htmlGetVariable(cells[row][0]->parent, (uchar *)\"HEIGHT\")) == NULL)\n\tfor (col = 0; col < table.num_cols; col ++)\n\t  if (htmlGetVariable(cells[row][col], (uchar *)\"ROWSPAN\") == NULL)\n\t    if ((height_var = htmlGetVariable(cells[row][col], (uchar *)\"HEIGHT\")) != NULL)\n\t      break;\n    }\n\n    if (height_var != NULL)\n    {\n      // Hardcode the row height...\n      if (height_var[strlen((char *)height_var) - 1] == '%')\n        temp_height = (float)(atof((char *)height_var) * 0.01f * PagePrintLength);\n      else\n        temp_height = (float)(atof((char *)height_var) * PagePrintWidth / _htmlBrowserWidth);\n\n      if (table.height > 0 && temp_height > table.height)\n        temp_height = table.height;\n\n      temp_height -= 2 * table.cellpadding;\n\n      if (temp_height > row_height)\n      {\n        // Only enforce the height if it is > the actual row height.\n        row_height = temp_height;\n        row_y      = *y - temp_height;\n      }\n    }\n\n    for (col = 0; col < table.num_cols; col += colspan + 1)\n    {\n      render_t\t*p;\n      float\tdelta_y;\n\n\n      for (colspan = 1; (col + colspan) < table.num_cols; colspan ++)\n        if (cells[row][col] != cells[row][col + colspan])\n          break;\n\n      colspan --;\n\n      if (table.cell_start[col] == NULL || table.row_spans[col] > rowspan ||\n          cells[row][col] == NULL || cells[row][col]->child == NULL)\n        continue;\n\n      if (table.row_spans[col] == 1)\n      {\n        int tcol;\n        float span_height = 0.0f;\n\n        for (tcol = 0; tcol < table.num_cols; tcol ++)\n        {\n          if (table.row_spans[col] == 1 && table.span_heights[col] > span_height)\n            span_height = table.span_heights[col];\n        }\n\n        switch (cells[row][col]->valignment)\n        {\n          case ALIGN_MIDDLE :\n//              delta_y = (table.span_heights[col] - table.cell_height[col]) * 0.5f;\n              delta_y = (span_height - table.cell_height[col]) * 0.5f;\n              break;\n\n          case ALIGN_BOTTOM :\n//              delta_y = table.span_heights[col] - table.cell_height[col];\n              delta_y = span_height - table.cell_height[col];\n              break;\n\n          default :\n              delta_y = 0.0f;\n              break;\n        }\n      }\n      else if (table.row_spans[col])\n      {\n        delta_y = 0.0f;\n      }\n      else\n      {\n        switch (cells[row][col]->valignment)\n        {\n          case ALIGN_MIDDLE :\n              delta_y = (row_height - table.cell_height[col]) * 0.5f;\n              break;\n\n          case ALIGN_BOTTOM :\n              delta_y = row_height - table.cell_height[col];\n              break;\n\n          default :\n              delta_y = 0.0f;\n              break;\n        }\n      }\n\n      DEBUG_printf((\"row = %d, col = %d, valign = %d, rowspans = %d, cell_height = %.1f, span_heights = %.1f, delta_y = %.1f\\n\", row, col, cells[row][col]->valignment, table.row_spans[col], table.cell_height[col], table.span_heights[col], delta_y));\n\n      if (delta_y > 0.0f)\n      {\n        if (table.cell_start[col] == table.cell_end[col])\n          p = table.cell_start[col];\n        else\n          p = table.cell_start[col]->next;\n\n        for (; p != NULL; p = p->next)\n        {\n          DEBUG_printf((\"aligning %p (%s), y was %.1f, now %.1f\\n\",\n                        (void *)p, p->data.text.buffer, p->y, p->y - delta_y));\n\n          p->y -= delta_y;\n          if (p == table.cell_end[col])\n            break;\n        }\n      }\n#ifdef DEBUG\n      else\n      {\n        if (table.cell_start[col] == table.cell_end[col])\n          p = table.cell_start[col];\n        else\n          p = table.cell_start[col]->next;\n\n        for (; p != NULL; p = p->next)\n        {\n          printf(\"NOT aligning %p (%s)\\n\", (void *)p, p->data.text.buffer);\n\n          if (p == table.cell_end[col])\n            break;\n        }\n      }\n#endif /* DEBUG */\n    }\n  }\n\n  // Update all current columns with ROWSPAN <= rowspan to use the same\n  // end page and row...\n  for (col = 0, temp_page = -1, temp_y = 99999999; col < table.num_cols; col ++)\n    if (table.row_spans[col] <= rowspan &&\n        cells[row][col] != NULL && cells[row][col]->child != NULL)\n    {\n      if (table.cell_endpage[col] > temp_page)\n      {\n        temp_page = table.cell_endpage[col];\n        temp_y    = table.cell_endy[col];\n      }\n      else if (table.cell_endpage[col] == temp_page && table.cell_endy[col] < temp_y)\n        temp_y = table.cell_endy[col];\n    }\n\n  for (col = 0; col < table.num_cols; col ++)\n    if (table.row_spans[col] <= rowspan &&\n        cells[row][col] != NULL && cells[row][col]->child != NULL)\n    {\n      table.cell_endpage[col] = temp_page;\n      table.cell_endy[col]    = temp_y;\n    }\n\n  row_y -= table.cellpadding;\n\n  table.border_left = table.col_lefts[0] - table.cellpadding;\n  width       = table.col_rights[table.num_cols - 1] - table.col_lefts[0] + 2 * table.cellpadding;\n\n  for (bgcolor = NULL, col = 0; col < table.num_cols; col ++)\n    if (table.row_spans[col] <= rowspan &&\n        cells[row][col] &&\n        !htmlGetVariable(cells[row][col], (uchar *)\"ROWSPAN\") &&\n        (bgcolor = htmlGetVariable(cells[row][col]->parent,\n                                   (uchar *)\"BGCOLOR\")) != NULL)\n      break;\n\n  if (bgcolor)\n  {\n    memcpy(bgrgb, background_color, sizeof(bgrgb));\n\n    get_color(bgcolor, bgrgb, 0);\n\n    if (row_page > *page)\n    {\n      // Draw background on multiple pages...\n\n      // Bottom of first page...\n      new_render(*page, RENDER_BOX, table.border_left, bottom,\n                 width, row_starty - bottom + table.cellpadding, bgrgb,\n                 pages[*page].start);\n\n      // Intervening pages...\n      for (temp_page = *page + 1; temp_page < row_page; temp_page ++)\n      {\n        new_render(temp_page, RENDER_BOX, table.border_left, bottom,\n                   width, top - bottom, bgrgb, pages[temp_page].start);\n      }\n\n      // Top of last page...\n      check_pages(*page);\n\n      new_render(row_page, RENDER_BOX, table.border_left, row_y,\n                 width, top - row_y, bgrgb,\n                 pages[row_page].start);\n    }\n    else\n    {\n      // Draw background in row...\n      new_render(row_page, RENDER_BOX, table.border_left, row_y,\n                 width, row_height + 2 * table.cellpadding, bgrgb,\n                 pages[row_page].start);\n    }\n  }\n\n  for (col = 0; col < table.num_cols; col += colspan + 1)\n  {\n    for (colspan = 0; (col + colspan) < table.num_cols; colspan ++)\n      if (cells[row][col] != cells[row][col + colspan])\n        break;\n      else if (table.row_spans[col + colspan] > 0)\n      {\n        DEBUG_printf((\"row = %d, col = %d, decrementing row_spans (%d) to %d...\\n\", row,\n                      col, table.row_spans[col + colspan],\n                      table.row_spans[col + colspan] - rowspan));\n        table.row_spans[col + colspan] -= rowspan;\n      }\n\n    colspan --;\n\n    width = table.col_rights[col + colspan] - table.col_lefts[col] +\n            2 * table.cellpadding;\n\n    if (cells[row][col] == NULL || cells[row][col]->child == NULL ||\n        table.row_spans[col] > 0)\n      continue;\n\n    DEBUG_printf((\"DRAWING BORDER+BACKGROUND: col=%d, row=%d, cell_page=%d, cell_y=%.1f\\n\"\n                  \"                           cell_endpage=%d, cell_endy=%.1f\\n\",\n                  col, row, table.cell_page[col], table.cell_y[col],\n                  table.cell_endpage[col], table.cell_endy[col]));\n\n    if ((bgcolor = htmlGetVariable(cells[row][col],\n                                   (uchar *)\"BGCOLOR\")) != NULL)\n    {\n      memcpy(bgrgb, background_color, sizeof(bgrgb));\n\n      get_color(bgcolor, bgrgb, 0);\n    }\n\n    table.border_left = table.col_lefts[col] - table.cellpadding;\n\n    if (table.cell_page[col] != table.cell_endpage[col])\n    {\n     /*\n      * Crossing a page boundary...\n      */\n\n      if (table.border > 0)\n      {\n       /*\n        * +---+---+---+\n        * |   |   |   |\n        */\n\n        // Top\n        new_render(table.cell_page[col], RENDER_BOX, table.border_left,\n                   table.cell_y[col] + table.cellpadding,\n                   width + table.border, table.border, table.border_rgb);\n        // Left\n        new_render(table.cell_page[col], RENDER_BOX, table.border_left, bottom,\n                   table.border, table.cell_y[col] - bottom + table.cellpadding + table.border, table.border_rgb);\n        // Right\n        new_render(table.cell_page[col], RENDER_BOX,\n                   table.border_left + width, bottom,\n                   table.border, table.cell_y[col] - bottom + table.cellpadding + table.border, table.border_rgb);\n      }\n\n      if (bgcolor != NULL)\n      {\n        table.cell_bg[col]->y      = bottom;\n        table.cell_bg[col]->height = table.cell_y[col] - bottom + table.cellpadding + table.border;\n      }\n\n      for (temp_page = table.cell_page[col] + 1; temp_page < table.cell_endpage[col]; temp_page ++)\n      {\n       /*\n        * |   |   |   |\n        * |   |   |   |\n        */\n\n        if (table.border > 0.0f)\n        {\n          // Left\n          new_render(temp_page, RENDER_BOX, table.border_left, bottom,\n                     table.border, top - bottom, table.border_rgb);\n          // Right\n          new_render(temp_page, RENDER_BOX,\n                     table.border_left + width, bottom,\n                     table.border, top - bottom, table.border_rgb);\n        }\n\n        if (bgcolor != NULL)\n          new_render(temp_page, RENDER_BOX, table.border_left, bottom,\n                     width + table.border, top - bottom, bgrgb,\n                     pages[temp_page].start);\n      }\n\n      if (table.border > 0.0f)\n      {\n       /*\n        * |   |   |   |\n        * +---+---+---+\n        */\n\n        // Left\n        new_render(table.cell_endpage[col], RENDER_BOX, table.border_left, row_y,\n                   table.border, top - row_y, table.border_rgb);\n        // Right\n        new_render(table.cell_endpage[col], RENDER_BOX,\n                   table.border_left + width, row_y,\n                   table.border, top - row_y, table.border_rgb);\n        // Bottom\n        new_render(table.cell_endpage[col], RENDER_BOX, table.border_left, row_y,\n                   width + table.border, table.border, table.border_rgb);\n      }\n\n      if (bgcolor != NULL)\n      {\n        check_pages(table.cell_endpage[col]);\n\n        new_render(table.cell_endpage[col], RENDER_BOX, table.border_left, row_y,\n                   width + table.border, top - row_y, bgrgb,\n                   pages[table.cell_endpage[col]].start);\n      }\n    }\n    else\n    {\n     /*\n      * +---+---+---+\n      * |   |   |   |\n      * +---+---+---+\n      */\n\n      if (table.border > 0.0f)\n      {\n        // Top\n        new_render(table.cell_page[col], RENDER_BOX, table.border_left,\n                   table.cell_y[col] + table.cellpadding,\n                   width + table.border, table.border, table.border_rgb);\n        // Left\n        new_render(table.cell_page[col], RENDER_BOX, table.border_left, row_y,\n                   table.border, table.cell_y[col] - row_y + table.cellpadding + table.border, table.border_rgb);\n        // Right\n        new_render(table.cell_page[col], RENDER_BOX,\n                   table.border_left + width, row_y,\n                   table.border, table.cell_y[col] - row_y + table.cellpadding + table.border, table.border_rgb);\n        // Bottom\n        new_render(table.cell_page[col], RENDER_BOX, table.border_left, row_y,\n                   width + table.border, table.border, table.border_rgb);\n      }\n\n      if (bgcolor != NULL)\n      {\n        table.cell_bg[col]->y      = row_y;\n        table.cell_bg[col]->height = table.cell_y[col] - row_y + table.cellpadding + table.border;\n      }\n    }\n  }\n\n  *page = row_page;\n  *y    = row_y;\n}\n\n\n/*\n * 'parse_table()' - Parse a table and produce rendering output.\n */\n\nstatic void\nparse_table(tree_t *t,\t\t\t// I - Tree to parse\n            float  left,\t\t// I - Left margin\n            float  right,\t\t// I - Printable width\n            float  bottom,\t\t// I - Bottom margin\n            float  top,\t\t\t// I - Printable top\n            float  *x,\t\t\t// IO - X position\n            float  *y,\t\t\t// IO - Y position\n            int    *page,\t\t// IO - Page #\n            int    needspace)\t\t// I - Need whitespace?\n{\n  int\t\tcol,\n\t\trow,\n                header_row = -1,\n\t\ttcol,\n\t\tcolspan,\n\t\trowspan,\n\t\talloc_rows,\n\t\tregular_cols;\n  hdtable_t     table;\n  float\t\tcol_width,\n\t\tcol_min,\n\t\tcol_pref,\n\t\tcol_height,\n\t\tcellspacing,\n\t\twidth,\n\t\tpref_width,\n\t\tspan_width,\n\t\tregular_width,\n\t\tactual_width,\n\t\ttable_width,\n\t\tmin_width,\n\t\ttemp_width,\n                header_height = 0.0,\n\t\ttable_y,\n                temp_bottom,\n\t\ttemp_top;\n  int\t\ttemp_page, table_page;\n  uchar\t\t*var,\n\t\t*height_var,\t\t// Row HEIGHT variable\n                *header_height_var = NULL;\n  tree_t\t*temprow,\n\t\t*tempcol,\n\t\t*tempnext,\n\t\t***cells,\n\t\t*caption;\t\t// Caption for bottom, if any\n  float\t\ttemp_height;\t\t// Temporary holder\n  uchar\t\t*bgcolor;\n  float\t\tbgrgb[3];\n  const char\t*htmldoc_debug;\t\t// HTMLDOC_DEBUG env var\n\n\n  DEBUG_puts(\"\\n\\nTABLE\");\n\n  DEBUG_printf((\"parse_table(t=%p, left=%.1f, right=%.1f, x=%.1f, y=%.1f, page=%d\\n\",\n                (void *)t, left, right, *x, *y, *page));\n\n  if (t->child == NULL)\n    return;   /* Empty table... */\n\n  memset(&table, 0, sizeof(table));\n\n /*\n  * Check debug mode...\n  */\n\n  if ((htmldoc_debug = getenv(\"HTMLDOC_DEBUG\")) != NULL &&\n      (strstr(htmldoc_debug, \"table\") || strstr(htmldoc_debug, \"all\")))\n    table.debug = 1;\n  else\n    table.debug = 0;\n\n /*\n  * Figure out the # of rows, columns, and the desired widths...\n  */\n\n  cells = NULL;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"WIDTH\")) != NULL)\n  {\n    if (var[strlen((char *)var) - 1] == '%')\n      table_width = (float)(atof((char *)var) * (right - left) / 100.0f);\n    else\n      table_width = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n\n    if (table_width < 0.0f || table_width > PagePrintWidth)\n      table_width = right - left;\n  }\n  else\n    table_width = right - left;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"HEIGHT\")) != NULL)\n  {\n    if (var[strlen((char *)var) - 1] == '%')\n      table.height = (float)(atof((char *)var) * (top - bottom) / 100.0f);\n    else\n      table.height = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n    table.height = -1.0f;\n\n  DEBUG_printf((\"table_width = %.1f\\n\", table_width));\n\n  if ((var = htmlGetVariable(t, (uchar *)\"CELLPADDING\")) != NULL)\n  {\n    if ((table.cellpadding = atoi((char *)var)) < 0.0f)\n      table.cellpadding = 0.0f;\n    else if (table.cellpadding > 20.0f)\n      table.cellpadding = 20.0f;\n  }\n  else\n    table.cellpadding = 1.0f;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"CELLSPACING\")) != NULL)\n  {\n    if ((cellspacing = atoi((char *)var)) < 0.0f)\n      cellspacing = 0.0f;\n    else if (cellspacing > 20.0f)\n      cellspacing = 20.0f;\n  }\n  else\n    cellspacing = 0.0f;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"BORDER\")) != NULL)\n  {\n    if ((table.border = (float)atof((char *)var)) <= 0.0 && var[0] != '0')\n      table.border = 1.0f;\n    else if (table.border > 20.0f)\n      table.border = 20.0f;\n\n    table.cellpadding += table.border;\n  }\n  else\n    table.border = 0.0f;\n\n  if (table.debug && table.border == 0.0f)\n    table.border = 0.01f;\n\n  table.border_rgb[0] = t->red / 255.0f;\n  table.border_rgb[1] = t->green / 255.0f;\n  table.border_rgb[2] = t->blue / 255.0f;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"BORDERCOLOR\")) != NULL)\n    get_color(var, table.border_rgb, 0);\n\n  if (table.border == 0.0f && table.cellpadding > 0.0f)\n  {\n   /*\n    * Ah, the strange table formatting nightmare that is HTML.\n    * Netscape and MSIE assign an invisible border width of 1\n    * pixel if no border is specified...\n    */\n\n    table.cellpadding += 1.0f;\n  }\n\n  table.border_size = table.border - 1.0f;\n\n  cellspacing       *= PagePrintWidth / _htmlBrowserWidth;\n  table.cellpadding *= PagePrintWidth / _htmlBrowserWidth;\n  table.border      *= PagePrintWidth / _htmlBrowserWidth;\n  table.border_size *= PagePrintWidth / _htmlBrowserWidth;\n\n  DEBUG_printf((\"border = %.1f, cellpadding = %.1f\\n\", table.border, table.cellpadding));\n\n  temp_bottom = bottom - table.cellpadding;\n  temp_top    = top + table.cellpadding;\n\n  for (temprow = t->child, table.num_cols = 0, table.num_rows = 0, alloc_rows = 0, caption = NULL;\n       temprow != NULL;\n       temprow = tempnext)\n  {\n    tempnext = temprow->next;\n\n    if (temprow->markup == MARKUP_CAPTION)\n    {\n      if ((var = htmlGetVariable(temprow, (uchar *)\"ALIGN\")) == NULL ||\n          strcasecmp((char *)var, \"bottom\"))\n      {\n       /*\n        * Show caption at top...\n\t*/\n\n        parse_paragraph(temprow, left, right, bottom, top, x, y, page, needspace);\n        needspace = 1;\n      }\n      else\n      {\n       /*\n        * Flag caption for bottom of table...\n\t*/\n\n        caption = temprow;\n      }\n    }\n    else if (temprow->markup == MARKUP_TR ||\n             ((temprow->markup == MARKUP_TBODY || temprow->markup == MARKUP_THEAD ||\n               temprow->markup == MARKUP_TFOOT) && temprow->child != NULL))\n    {\n      if (temprow->markup == MARKUP_THEAD)\n        header_row = table.num_rows;\n\n      // Descend into table body as needed...\n      if (temprow->markup == MARKUP_TBODY || temprow->markup == MARKUP_THEAD ||\n          temprow->markup == MARKUP_TFOOT)\n        temprow = temprow->child;\n\n      // Figure out the next row...\n      if ((tempnext = temprow->next) == NULL)\n        if (temprow->parent->markup == MARKUP_TBODY ||\n            temprow->parent->markup == MARKUP_THEAD ||\n            temprow->parent->markup == MARKUP_TFOOT)\n          tempnext = temprow->parent->next;\n\n      // Allocate memory for the table as needed...\n      if (table.num_rows >= alloc_rows)\n      {\n        alloc_rows += ALLOC_ROWS;\n\n        if (alloc_rows == ALLOC_ROWS)\n\t  cells = (tree_t ***)malloc(sizeof(tree_t **) * (size_t)alloc_rows);\n\telse\n\t  cells = (tree_t ***)realloc(cells, sizeof(tree_t **) * (size_t)alloc_rows);\n\n        if (cells == (tree_t ***)0)\n\t{\n\t  progress_error(HD_ERROR_OUT_OF_MEMORY,\n                         \"Unable to allocate memory for table!\");\n\t  return;\n\t}\n      }\n\n      if ((cells[table.num_rows] = (tree_t **)calloc(sizeof(tree_t *), MAX_COLUMNS)) == NULL)\n      {\n\tprogress_error(HD_ERROR_OUT_OF_MEMORY,\n                       \"Unable to allocate memory for table!\");\n        free(cells);\n\treturn;\n      }\n\n#ifdef DEBUG\n      printf(\"BEFORE row %d: num_cols = %d\\n\", table.num_rows, table.num_cols);\n\n      if (table.num_rows)\n        for (col = 0; col < table.num_cols; col ++)\n\t  printf(\"    col %d: row_spans[] = %d\\n\", col, table.row_spans[col]);\n#endif // DEBUG\n\n      // Figure out the starting column...\n      if (table.num_rows)\n      {\n\tfor (col = 0, rowspan = 9999; col < table.num_cols; col ++)\n\t  if (table.row_spans[col] < rowspan)\n\t    rowspan = table.row_spans[col];\n\n\tfor (col = 0; col < table.num_cols; col ++)\n\t  table.row_spans[col] -= rowspan;\n\n\tfor (col = 0; table.row_spans[col] && col < table.num_cols; col ++)\n          cells[table.num_rows][col] = cells[table.num_rows - 1][col];\n      }\n      else\n        col = 0;\n\n      for (tempcol = temprow->child;\n           tempcol != NULL && col < MAX_COLUMNS;\n           tempcol = tempcol->next)\n      {\n        if (tempcol->markup == MARKUP_TH && table.num_rows == 0)\n          header_row = table.num_rows;\n\n        if (tempcol->markup == MARKUP_TD || tempcol->markup == MARKUP_TH)\n        {\n\t  // Handle colspan and rowspan stuff...\n          if ((var = htmlGetVariable(tempcol, (uchar *)\"COLSPAN\")) != NULL)\n            colspan = atoi((char *)var);\n          else\n            colspan = 1;\n\n          if ((var = htmlGetVariable(tempcol, (uchar *)\"ROWSPAN\")) != NULL)\n\t  {\n            table.row_spans[col] = atoi((char *)var);\n\n\t    if (table.row_spans[col] == 1)\n\t      table.row_spans[col] = 0;\n\n\t    for (tcol = 1; tcol < colspan; tcol ++)\n              table.row_spans[col + tcol] = table.row_spans[col];\n          }\n\n          // Compute the cell size...\n          col_width = get_cell_size(tempcol, 0.0f, table_width, &col_min, &col_pref, &col_height);\n          if ((var = htmlGetVariable(tempcol, (uchar *)\"WIDTH\")) != NULL)\n\t  {\n\t    if (var[strlen((char *)var) - 1] == '%')\n\t    {\n              col_width -= 2.0 * table.cellpadding - cellspacing;\n\n\t      if (colspan <= 1)\n\t        table.col_percent[col] = 1;\n\t    }\n\t    else\n\t    {\n              col_width -= 2.0 * table.cellpadding;\n\t    }\n\t  }\n\t  else\n\t    col_width = 0.0f;\n\n          tempcol->height = col_height;\n\n\t  DEBUG_printf((\"%d,%d: colsp=%d, rowsp=%d, width=%.1f, minw=%.1f, prefw=%.1f, minh=%.1f\\n\", col, table.num_rows, colspan, table.row_spans[col], col_width, col_min, col_pref, col_height));\n\n          // Add widths to columns...\n          if (colspan > 1)\n          {\n\t    if (colspan > table.col_spans[col])\n\t      table.col_spans[col] = colspan;\n\n\t    if (col_width > table.col_swidths[col])\n\t      table.col_swidths[col] = col_width;\n\n\t    if (col_min > table.col_smins[col])\n\t      table.col_smins[col] = col_min;\n\n\t    temp_width = col_width / colspan;\n\t    for (int i = 0; i < colspan; i ++)\n\t    {\n\t      if (temp_width > table.col_widths[col + i])\n\t        table.col_widths[col + i] = temp_width;\n\t    }\n          }\n\t  else\n\t  {\n\t    if (col_width > 0.0f)\n\t      table.col_fixed[col] = 1;\n\n\t    if (col_width > table.col_widths[col])\n\t      table.col_widths[col] = col_width;\n\n\t    if (col_pref > table.col_prefs[col])\n\t      table.col_prefs[col] = col_pref;\n\n\t    if (col_min > table.col_mins[col])\n\t      table.col_mins[col] = col_min;\n          }\n\n\t  while (colspan > 0 && col < MAX_COLUMNS)\n\t  {\n            cells[table.num_rows][col] = tempcol;\n            col ++;\n            colspan --;\n          }\n\n          while (table.row_spans[col] && col < table.num_cols)\n\t  {\n            cells[table.num_rows][col] = cells[table.num_rows - 1][col];\n\t    col ++;\n\t  }\n        }\n      }\n\n      DEBUG_printf((\"header_row=%d\\n\", header_row));\n\n      if (col > table.num_cols)\n        table.num_cols = col;\n\n#ifdef DEBUG\n      printf(\"AFTER row %d: num_cols = %d\\n\", table.num_rows, table.num_cols);\n\n      for (col = 0; col < table.num_cols; col ++)\n        printf(\"    col %d: row_spans[] = %d\\n\", col, table.row_spans[col]);\n#endif // DEBUG\n\n      table.num_rows ++;\n\n      for (col = 0; col < table.num_cols; col ++)\n        if (table.row_spans[col])\n\t  table.row_spans[col] --;\n    }\n  }\n\n /*\n  * OK, some people apparently create HTML tables with no columns or\n  * rows...  If this happened, return immediately...\n  */\n\n  if (table.num_cols == 0)\n    return;\n\n /*\n  * Now figure out the width of the table...\n  */\n\n  if ((var = htmlGetVariable(t, (uchar *)\"WIDTH\")) != NULL)\n  {\n    if (var[strlen((char *)var) - 1] == '%')\n      width = (float)(atof((char *)var) * (right - left) / 100.0f);\n    else\n      width = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n  {\n    for (col = 0, width = 0.0; col < table.num_cols; col ++)\n      width += table.col_prefs[col];\n\n    width += (2 * table.cellpadding + cellspacing) * table.num_cols - cellspacing;\n\n    if (width > (right - left))\n      width = right - left;\n  }\n\n /*\n  * Compute the width of each column based on the printable width.\n  */\n\n  DEBUG_printf((\"\\nTABLE: %dx%d\\n\\n\", table.num_cols, table.num_rows));\n\n  actual_width  = (2 * table.cellpadding + cellspacing) * table.num_cols -\n                  cellspacing;\n  regular_width = (width - actual_width) / table.num_cols;\n\n  DEBUG_printf((\"    width = %.1f, actual_width = %.1f, regular_width = %.1f\\n\\n\",\n                width, actual_width, regular_width));\n  DEBUG_puts(\"    Col  Width   Min     Pref    Fixed?  Percent?\");\n  DEBUG_puts(\"    ---  ------  ------  ------  ------  --------\");\n\n#ifdef DEBUG\n  for (col = 0; col < table.num_cols; col ++)\n    printf(\"    %-3d  %-6.1f  %-6.1f  %-6.1f  %-6s  %s\\n\", col, table.col_widths[col], table.col_mins[col], table.col_prefs[col], table.col_fixed[col] ? \"YES\" : \"NO\", table.col_percent[col] ? \"YES\" : \"NO\");\n\n  puts(\"\");\n#endif /* DEBUG */\n\n /*\n  * The first pass just handles columns with a specified width...\n  */\n\n  DEBUG_puts(\"PASS 1: fixed width handling\\n\");\n\n  for (col = 0, regular_cols = 0; col < table.num_cols; col ++)\n    if (table.col_widths[col] > 0.0f)\n    {\n      if (table.col_mins[col] > table.col_widths[col])\n      {\n        DEBUG_printf((\"    updating column %d to width=%.1f\\n\", col, table.col_mins[col]));\n\n        table.col_widths[col] = table.col_mins[col];\n      }\n\n      actual_width += table.col_widths[col];\n    }\n    else\n    {\n      regular_cols ++;\n\n      actual_width += table.col_mins[col];\n    }\n\n  DEBUG_printf((\"    actual_width = %.1f, regular_cols = %d\\n\\n\", actual_width,regular_cols));\n\n /*\n  * Pass two uses the \"preferred\" width whenever possible, and the\n  * minimum otherwise...\n  */\n\n  DEBUG_puts(\"PASS 2: preferred width handling\\n\");\n\n  for (col = 0, pref_width = 0.0f; col < table.num_cols; col ++)\n    if (table.col_widths[col] == 0.0f)\n      pref_width += table.col_prefs[col] - table.col_mins[col];\n\n  DEBUG_printf((\"    pref_width = %.1f\\n\", pref_width));\n\n  if (pref_width > 0.0f)\n  {\n    if ((regular_width = (width - actual_width) / pref_width) < 0.0f)\n      regular_width = 0.0f;\n    else if (regular_width > 1.0f)\n      regular_width = 1.0f;\n\n    DEBUG_printf((\"    regular_width = %.1f\\n\", regular_width));\n\n    for (col = 0; col < table.num_cols; col ++)\n      if (table.col_widths[col] == 0.0f)\n      {\n\tpref_width = (table.col_prefs[col] - table.col_mins[col]) * regular_width;\n\n\tif ((actual_width + pref_width) > width)\n\t{\n          if (col == (table.num_cols - 1) && (width - actual_width) >= table.col_mins[col])\n\t    table.col_widths[col] = width - actual_width;\n\t  else\n\t    table.col_widths[col] = table.col_mins[col];\n\t}\n\telse\n          table.col_widths[col] = pref_width + table.col_mins[col];\n\n        DEBUG_printf((\"    col_widths[%d] = %.1f\\n\", col, table.col_widths[col]));\n\n\tactual_width += table.col_widths[col] - table.col_mins[col];\n      }\n  }\n  else\n  {\n   /*\n    * Assign min widths for all cells...\n    */\n\n    for (col = 0; col < table.num_cols; col ++)\n      if (table.col_widths[col] == 0.0f)\n        table.col_widths[col] = table.col_mins[col];\n  }\n\n  DEBUG_printf((\"    actual_width = %.1f\\n\\n\", actual_width));\n\n /*\n  * Pass three enforces any hard or minimum widths for COLSPAN'd\n  * columns...\n  */\n\n  DEBUG_puts(\"PASS 3: colspan handling\\n\\n\");\n\n  for (col = 0; col < table.num_cols; col ++)\n  {\n    DEBUG_printf((\"    col %d, colspan %d\\n\", col, table.col_spans[col]));\n\n    if (table.col_spans[col] > 1)\n    {\n      for (colspan = 0, span_width = 0.0f; colspan < table.col_spans[col]; colspan ++)\n        span_width += table.col_widths[col + colspan];\n\n      pref_width = 0.0f;\n\n      if (span_width < table.col_swidths[col])\n        pref_width = table.col_swidths[col];\n      if (span_width < table.col_smins[col] && pref_width < table.col_smins[col])\n        pref_width = table.col_smins[col];\n\n      for (colspan = 0; colspan < table.col_spans[col]; colspan ++)\n        if (table.col_fixed[col + colspan])\n\t{\n          span_width -= table.col_widths[col + colspan];\n\t  pref_width -= table.col_widths[col + colspan];\n\t}\n\n      DEBUG_printf((\"    col_swidths=%.1f, col_smins=%.1f, span_width=%.1f, pref_width=%.1f\\n\", table.col_swidths[col], table.col_smins[col], span_width, pref_width));\n\n      if (pref_width > 0.0f && pref_width > span_width)\n      {\n        if (span_width >= 1.0f)\n\t{\n          // Expand cells proportionately...\n\t  regular_width = pref_width / span_width;\n\n\t  for (colspan = 0; colspan < table.col_spans[col]; colspan ++)\n\t    if (!table.col_fixed[col + colspan])\n\t    {\n\t      actual_width -= table.col_widths[col + colspan];\n\t      table.col_widths[col + colspan] *= regular_width;\n\t      actual_width += table.col_widths[col + colspan];\n\n              DEBUG_printf((\"    col_widths[%d] = %.1f\\n\", col + colspan, table.col_widths[col + colspan]));\n\t    }\n        }\n\telse\n\t{\n\t  // Divide the space up equally between columns, since the\n\t  // colspan area is always by itself... (this hack brought\n\t  // to you by Yahoo! and their single cell tables with\n\t  // colspan=2 :)\n\n\t  regular_width = pref_width / table.col_spans[col];\n\n\t  for (colspan = 0; colspan < table.col_spans[col]; colspan ++)\n\t  {\n\t    actual_width += regular_width;\n\t    table.col_widths[col + colspan] += regular_width;\n\n            DEBUG_printf((\"    col_widths[%d] = %.1f\\n\", col, table.col_widths[col]));\n\t  }\n\t}\n      }\n    }\n  }\n\n  DEBUG_printf((\"    actual_width = %.1f\\n\\n\", actual_width));\n\n /*\n  * Pass four divides up the remaining space amongst the columns...\n  */\n\n  DEBUG_puts(\"PASS 4: divide remaining space, if any...\\n\");\n\n  if (width > actual_width)\n  {\n    for (col = 0, colspan = 0; col < table.num_cols; col ++)\n      if (!table.col_fixed[col] || table.col_percent[col])\n        colspan ++;\n\n    if (colspan > 0)\n    {\n      regular_width = (width - actual_width) / table.num_cols;\n\n      for (col = 0; col < table.num_cols; col ++)\n        if (!table.col_fixed[col])\n\t{\n\t  table.col_widths[col] += regular_width;\n\t  DEBUG_printf((\"    col_widths[%d] = %.1f\\n\", col, table.col_widths[col]));\n\t}\n    }\n  }\n  else\n    width = actual_width;\n\n  DEBUG_puts(\"\");\n\n /*\n  * The final pass is only run if the width > table_width...\n  */\n\n  DEBUG_puts(\"PASS 5: Squeeze table as needed...\");\n\n  if (width > table_width)\n  {\n   /*\n    * Squeeze the table to fit the requested width or the printable width\n    * as determined at the beginning...\n    */\n\n    for (col = 0, min_width = -cellspacing; col < table.num_cols; col ++)\n      min_width += table.col_mins[col] + 2 * table.cellpadding + cellspacing;\n\n    DEBUG_printf((\"    table_width = %.1f, width = %.1f, min_width = %.1f\\n\", table_width, width, min_width));\n\n    temp_width = table_width - min_width;\n    if (temp_width < 0.0f)\n      temp_width = 0.0f;\n\n    width -= min_width;\n    if (width < 1.0f)\n      width = 1.0f;\n\n    for (col = 0; col < table.num_cols; col ++)\n    {\n      table.col_widths[col] = table.col_mins[col] + temp_width * (table.col_widths[col] - table.col_mins[col]) / width;\n\n      DEBUG_printf((\"    col_widths[%d] = %.1f\\n\", col, table.col_widths[col]));\n    }\n\n    for (col = 0, width = -cellspacing; col < table.num_cols; col ++)\n      width += table.col_widths[col] + 2 * table.cellpadding + cellspacing;\n\n    DEBUG_printf((\"    new width = %.1f, max width = %.1f\\n\", width, right - left));\n  }\n\n  if ((width - right + left) > 0.001f && OverflowErrors)\n    progress_error(HD_ERROR_CONTENT_TOO_LARGE, \"Table on page %d too wide - truncation or overlapping may occur!\", *page + 1);\n\n  DEBUG_puts(\"\");\n\n  DEBUG_printf((\"Final table width = %.1f, alignment = %d\\n\", width, t->halignment));\n\n  switch (t->halignment)\n  {\n    case ALIGN_LEFT :\n        *x = left + table.cellpadding;\n        break;\n    case ALIGN_CENTER :\n        *x = left + 0.5f * (right - left - width) + table.cellpadding;\n        break;\n    case ALIGN_RIGHT :\n        *x = right - width + table.cellpadding;\n        break;\n  }\n\n  for (col = 0; col < table.num_cols; col ++)\n  {\n    table.col_lefts[col]  = *x;\n    table.col_rights[col] = *x + table.col_widths[col];\n    *x = table.col_rights[col] + 2 * table.cellpadding + cellspacing;\n\n    DEBUG_printf((\"left[%d] = %.1f, right[%d] = %.1f\\n\", col, table.col_lefts[col], col, table.col_rights[col]));\n  }\n\n /*\n  * Now render the whole table...\n  */\n\n  if (*y < top && needspace)\n    *y -= _htmlSpacings[SIZE_P];\n\n  if (table.debug)\n  {\n    check_pages(*page);\n\n    render_t *r;\n    char table_text[255];\n\n    snprintf(table_text, sizeof(table_text), \"t=%p\", (void *)t);\n    r = new_render(*page, RENDER_TEXT, left, *y,\n                   get_width((uchar *)table_text, TYPE_COURIER, STYLE_NORMAL, 3),\n\t\t   _htmlSizes[3], table_text);\n\n    r->data.text.typeface = TYPE_COURIER;\n    r->data.text.style    = STYLE_NORMAL;\n    r->data.text.size     = (float)_htmlSizes[3];\n  }\n\n  table_page = *page;\n  table_y    = *y;\n\n  for (row = 0; row < table.num_rows; row ++)\n  {\n    height_var = NULL;\n\n    if (cells[row][0] != NULL)\n    {\n     /*\n      * Do page comments...\n      */\n\n      if (cells[row][0]->parent->prev != NULL &&\n          cells[row][0]->parent->prev->markup == MARKUP_COMMENT)\n        parse_comment(cells[row][0]->parent->prev, &left, &right, &temp_bottom, &temp_top, x, y, page, NULL, 0);\n\n     /*\n      * Get height...\n      */\n\n      if ((height_var = htmlGetVariable(cells[row][0]->parent, (uchar *)\"HEIGHT\")) == NULL)\n\tfor (col = 0; col < table.num_cols; col ++)\n\t  if (htmlGetVariable(cells[row][col], (uchar *)\"ROWSPAN\") == NULL)\n\t    if ((height_var = htmlGetVariable(cells[row][col], (uchar *)\"HEIGHT\")) != NULL)\n\t      break;\n    }\n\n    if (height_var != NULL && row == header_row)\n      header_height_var = height_var;\n\n    if (cells[row][0] != NULL && height_var != NULL)\n    {\n      // Row height specified; make sure it'll fit...\n      if (height_var[strlen((char *)height_var) - 1] == '%')\n\ttemp_height = (float)(atof((char *)height_var) * 0.01f * (PagePrintLength - 2 * table.cellpadding));\n      else\n        temp_height = (float)(atof((char *)height_var) * PagePrintWidth / _htmlBrowserWidth);\n\n      if (table.height > 0.0f && temp_height > table.height)\n        temp_height = table.height;\n\n      temp_height -= 2 * table.cellpadding;\n    }\n    else\n    {\n      // Use min height computed from get_cell_size()...\n      for (col = 0, temp_height = (float)_htmlSpacings[SIZE_P];\n           col < table.num_cols;\n\t   col ++)\n        if (cells[row][col] != NULL &&\n\t    cells[row][col]->height > temp_height &&\n\t    !htmlGetVariable(cells[row][col], (uchar *)\"ROWSPAN\"))\n\t  temp_height = cells[row][col]->height;\n\n      if (table.height > 0.0)\n      {\n\t// Table height specified; make sure it'll fit...\n\tif (temp_height > table.height)\n          temp_height = table.height;\n\ttemp_height -= 2 * table.cellpadding;\n      }\n      else if (temp_height > (PageLength / 8.0) && height_var == NULL)\n\ttemp_height = PageLength / 8.0;\n    }\n\n    DEBUG_printf((\"BEFORE row = %d, temp_height = %.1f, *y = %.1f, *page = %d\\n\",\n                  row, temp_height, *y, *page));\n\n    if (*y < (bottom + 2 * table.cellpadding + temp_height) &&\n        temp_height <= (top - bottom - 2 * table.cellpadding))\n    {\n      DEBUG_puts(\"NEW PAGE\");\n\n      *y = top - header_height;\n      (*page) ++;\n\n      if (Verbosity)\n        progress_show(\"Formatting page %d\", *page);\n\n      if (row > 0 && header_row >= 0)\n      {\n        // Render header row...\n        render_table_row(table, cells, header_row, header_height_var, left, right, bottom, top, x, y, page);\n      }\n    }\n\n    float start_y = *y;\n    temp_page = *page;\n    render_table_row(table, cells, row, height_var, left, right, bottom, top, x, y, page);\n    if (header_row >= 0 && row == header_row)\n    {\n      header_height = *y - start_y;\n      top += header_height;\n    }\n    else if (temp_page != *page && header_row >= 0)\n    {\n      // Render header row on new page(s)...\n      do\n      {\n        float temp_y = top - header_height;\n\n        temp_page ++;\n        render_table_row(table, cells, header_row, header_height_var, left, right, bottom, top, x, &temp_y, &temp_page);\n      }\n      while (temp_page < *page);\n    }\n\n    if (row < (table.num_rows - 1))\n      (*y) -= cellspacing;\n\n    DEBUG_printf((\"END row = %d, *y = %.1f, *page = %d\\n\", row, *y, *page));\n  }\n\n  top -= header_height;\n\n /*\n  * Handle table background color...\n  */\n\n  if ((bgcolor = htmlGetVariable(t, (uchar *)\"BGCOLOR\")) != NULL)\n  {\n    memcpy(bgrgb, background_color, sizeof(bgrgb));\n\n    get_color(bgcolor, bgrgb, 0);\n\n    table.border_left = table.col_lefts[0] - table.cellpadding;\n    width       = table.col_rights[table.num_cols - 1] - table.col_lefts[0] + 2 * table.cellpadding;\n\n    if (table_page != *page)\n    {\n      // Draw background on multiple pages...\n\n      // Bottom of first page...\n      new_render(table_page, RENDER_BOX, table.border_left, bottom,\n\t         width, table_y - bottom, bgrgb,\n\t\t pages[table_page].start);\n\n      // Intervening pages...\n      for (temp_page = table_page + 1; temp_page < *page; temp_page ++)\n      {\n        new_render(temp_page, RENDER_BOX, table.border_left, bottom,\n                   width, top - bottom, bgrgb, pages[temp_page].start);\n      }\n\n      // Top of last page...\n      check_pages(*page);\n\n      new_render(*page, RENDER_BOX, table.border_left, *y,\n\t         width, top - *y, bgrgb, pages[*page].start);\n    }\n    else\n    {\n      // Draw background in row...\n      new_render(table_page, RENDER_BOX, table.border_left, *y,\n\t         width, table_y - *y, bgrgb, pages[table_page].start);\n    }\n  }\n\n  *x = left;\n\n  if (caption)\n  {\n   /*\n    * Show caption at bottom...\n    */\n\n    parse_paragraph(caption, left, right, bottom, top, x, y, page, needspace);\n    needspace = 1;\n  }\n\n /*\n  * Free memory for the table...\n  */\n\n  if (table.num_rows > 0)\n  {\n    for (row = 0; row < table.num_rows; row ++)\n      free(cells[row]);\n\n    free(cells);\n  }\n}\n#ifdef TABLE_DEBUG\n#  undef DEBUG\n#  undef DEBUG_puts\n#  define DEBUG_puts(x)\n#  undef DEBUG_printf\n#  define DEBUG_printf(x)\n#endif /* TABLE_DEBUG */\n\n\n/*\n * 'parse_list()' - Parse a list entry and produce rendering output.\n */\n\nstatic void\nparse_list(tree_t *t,\t\t/* I - Tree to parse */\n           float  *left,\t/* I - Left margin */\n           float  *right,\t/* I - Printable width */\n           float  *bottom,\t/* I - Bottom margin */\n           float  *top,\t\t/* I - Printable top */\n           float  *x,\t\t/* IO - X position */\n           float  *y,\t\t/* IO - Y position */\n           int    *page,\t/* IO - Page # */\n           int    needspace)\t/* I - Need whitespace? */\n{\n  uchar\t\tnumber[255];\t/* List number (for numbered types) */\n  uchar\t\t*value;\t\t/* VALUE= variable */\n  int\t\ttypeface;\t/* Typeface of list number */\n  float\t\twidth;\t\t/* Width of list number */\n  render_t\t*r;\t\t/* Render primitive */\n  int\t\toldpage;\t/* Old page value */\n  float\t\toldy;\t\t/* Old Y value */\n  float\t\ttempx;\t\t/* Temporary X value */\n\n\n  DEBUG_printf((\"parse_list(t=%p, left=%.1f, right=%.1f, x=%.1f, y=%.1f, page=%d\\n\",\n                (void *)t, *left, *right, *x, *y, *page));\n\n  if (needspace && *y < *top)\n  {\n    *y        -= _htmlSpacings[t->size];\n    needspace = 0;\n  }\n\n  check_pages(*page);\n\n  oldy    = *y;\n  oldpage = *page;\n  r       = pages[*page].end;\n  tempx   = *x;\n\n  if (t->indent == 0)\n  {\n    // Adjust left margin when no UL/OL/DL is being used...\n    *left += _htmlSizes[t->size];\n    tempx += _htmlSizes[t->size];\n  }\n\n  parse_doc(t->child, left, right, bottom, top, &tempx, y, page, NULL,\n            &needspace);\n\n  // Handle when paragraph wrapped to new page...\n  if (*page != oldpage)\n  {\n    // First see if anything was added to the old page...\n    if ((r != NULL && r->next == NULL) || pages[oldpage].end == NULL)\n    {\n      // No, put the symbol on the next page...\n      oldpage = *page;\n      oldy    = *top;\n    }\n  }\n\n  if ((value = htmlGetVariable(t, (uchar *)\"VALUE\")) != NULL)\n  {\n    if (isdigit(value[0]))\n      list_values[t->indent] = atoi((char *)value);\n    else if (isupper(value[0]))\n      list_values[t->indent] = value[0] - 'A' + 1;\n    else\n      list_values[t->indent] = value[0] - 'a' + 1;\n  }\n\n  switch (list_types[t->indent])\n  {\n    case 'a' :\n    case 'A' :\n    case '1' :\n    case 'i' :\n    case 'I' :\n        strlcpy((char *)number, format_number(list_values[t->indent], (char)list_types[t->indent]), sizeof(number));\n        strlcat((char *)number, \". \", sizeof(number));\n        typeface = t->typeface;\n        break;\n\n    default :\n        snprintf((char *)number, sizeof(number), \"%c \", list_types[t->indent]);\n        typeface = TYPE_SYMBOL;\n        break;\n  }\n\n  width = get_width(number, typeface, t->style, t->size);\n\n  r = new_render(oldpage, RENDER_TEXT, *left - width, oldy - _htmlSizes[t->size],\n                 width, _htmlSpacings[t->size], number);\n  r->data.text.typeface = typeface;\n  r->data.text.style    = t->style;\n  r->data.text.size     = (float)_htmlSizes[t->size];\n  r->data.text.rgb[0]   = t->red / 255.0f;\n  r->data.text.rgb[1]   = t->green / 255.0f;\n  r->data.text.rgb[2]   = t->blue / 255.0f;\n\n  list_values[t->indent] ++;\n\n  if (t->indent == 0)\n  {\n    // Adjust left margin when no UL/OL/DL is being used...\n    *left -= _htmlSizes[t->size];\n  }\n}\n\n\n/*\n * 'init_list()' - Initialize the list type and value as necessary.\n */\n\nstatic void\ninit_list(tree_t *t)\t\t/* I - List entry */\n{\n  uchar\t\t*type,\t\t/* TYPE= variable */\n\t\t*value;\t\t/* VALUE= variable */\n  static uchar\t*symbols = (uchar *)\"\\327\\267\\250\\340\";\n\n\n  if ((type = htmlGetVariable(t, (uchar *)\"TYPE\")) != NULL)\n  {\n    if (strlen((char *)type) == 1)\n      list_types[t->indent] = type[0];\n    else if (strcasecmp((char *)type, \"disc\") == 0 ||\n             strcasecmp((char *)type, \"circle\") == 0)\n      list_types[t->indent] = symbols[1];\n    else\n      list_types[t->indent] = symbols[2];\n  }\n  else if (t->markup == MARKUP_UL)\n    list_types[t->indent] = symbols[t->indent & 3];\n  else if (t->markup == MARKUP_OL)\n    list_types[t->indent] = '1';\n\n  if ((value = htmlGetVariable(t, (uchar *)\"VALUE\")) == NULL)\n    value = htmlGetVariable(t, (uchar *)\"START\");\n\n  if (value != NULL)\n  {\n    if (isdigit(value[0]))\n      list_values[t->indent] = atoi((char *)value);\n    else if (isupper(value[0]))\n      list_values[t->indent] = value[0] - 'A' + 1;\n    else\n      list_values[t->indent] = value[0] - 'a' + 1;\n  }\n  else if (t->markup == MARKUP_OL)\n    list_values[t->indent] = 1;\n}\n\n\n/*\n * 'parse_comment()' - Parse a comment for HTMLDOC comments.\n */\n\n#ifdef COMMENT_DEBUG\n#  undef DEBUG_puts\n#  define DEBUG_puts(x) puts(x)\n#  define DEBUG\n#  undef DEBUG_printf\n#  define DEBUG_printf(x) printf x\n#endif /* COMMENT_DEBUG */\n\nstatic void\nparse_comment(tree_t *t,\t/* I - Tree to parse */\n              float  *left,\t/* I - Left margin */\n              float  *right,\t/* I - Printable width */\n              float  *bottom,\t/* I - Bottom margin */\n              float  *top,\t/* I - Printable top */\n              float  *x,\t/* IO - X position */\n              float  *y,\t/* IO - Y position */\n              int    *page,\t/* IO - Page # */\n\t      tree_t *para,\t/* I - Current paragraph */\n\t      int    needspace)\t/* I - Need whitespace? */\n{\n  int\t\ti;\t\t/* Looping var */\n  const char\t*comment;\t/* Comment text */\n  char\t\t*ptr,\t\t/* Pointer into value string */\n\t\tbuffer[1024];\t/* Buffer for strings */\n  int\t\tpos,\t\t/* Position (left, center, right) */\n\t\ttof;\t\t/* Top of form */\n\n\n  DEBUG_printf((\"parse_comment(t=%p, left=%.1f, right=%.1f, bottom=%.1f, \"\n                \"top=%.1f, x=%.1f, y=%.1f, page=%d, para=%p, needspace=%d\\n\",\n                (void *)t, *left, *right, *bottom, *top, *x, *y, *page, (void *)para,\n\t\tneedspace));\n\n  if (t->data == NULL)\n    return;\n\n  if (para != NULL && para->child != NULL && para->child->next == NULL &&\n      para->child->child == NULL && para->child->markup == MARKUP_NONE &&\n      strcmp((const char *)para->child->data, \" \") == 0)\n  {\n    // Remove paragraph consisting solely of whitespace...\n    htmlDeleteTree(para->child);\n    para->child = para->last_child = NULL;\n  }\n\n  // Mark if we are at the top of form...\n  tof = (*y >= *top);\n\n  DEBUG_printf((\"BEFORE tof=%d, *y=%.1f, *top=%.1f, *page=%d, t->data=\\\"%s\\\"\\n\",\n        \ttof, *y, *top, *page, t->data));\n  DEBUG_printf((\" PagePrintWidth = %d\\n\", PagePrintWidth));\n  DEBUG_printf((\"PagePrintLength = %d\\n\", PagePrintLength));\n  DEBUG_printf((\"      PageWidth = %d\\n\", PageWidth));\n  DEBUG_printf((\"     PageLength = %d\\n\", PageLength));\n  DEBUG_printf((\"       PageLeft = %d\\n\", PageLeft));\n  DEBUG_printf((\"     PageBottom = %d\\n\", PageBottom));\n  DEBUG_printf((\"      PageRight = %d\\n\", PageRight));\n  DEBUG_printf((\"        PageTop = %d\\n\", PageTop));\n  DEBUG_printf((\"      Landscape = %d\\n\", Landscape));\n\n\n  for (comment = (const char *)t->data; *comment;)\n  {\n    // Skip leading whitespace...\n    while (isspace(*comment))\n      comment ++;\n\n    if (!*comment)\n      break;\n\n    if (strncasecmp(comment, \"PAGE BREAK\", 10) == 0 &&\n\t(!comment[10] || isspace(comment[10])))\n    {\n     /*\n      * <!-- PAGE BREAK --> generates a page break...\n      */\n\n      comment += 10;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n      }\n\n      (*page) ++;\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n      *x = *left;\n      *y = *top;\n\n      tof = 1;\n    }\n    else if (strncasecmp(comment, \"NEW PAGE\", 8) == 0 &&\n\t     (!comment[8] || isspace(comment[8])))\n    {\n     /*\n      * <!-- NEW PAGE --> generates a page break...\n      */\n\n      comment += 8;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n      }\n\n      (*page) ++;\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n      *x = *left;\n      *y = *top;\n\n      tof = 1;\n    }\n    else if (strncasecmp(comment, \"NEW SHEET\", 9) == 0 &&\n\t     (!comment[9] || isspace(comment[9])))\n    {\n     /*\n      * <!-- NEW SHEET --> generate a page break to a new sheet...\n      */\n\n      comment += 9;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n      }\n\n      if (NumberUp == 1)\n      {\n        // NEW SHEET breaks to the next sheet of paper...\n        (*page) ++;\n\n\tif (PageDuplex && ((*page) & 1))\n\t  (*page) ++;\n      }\n      else\n      {\n        // NEW SHEET breaks to the next side/sheet...\n        (*page) ++;\n\n\tfor (i = *page - 1; i >= 0; i --)\n\t  if (pages[i].nup != NumberUp)\n\t    break;\n\n        i ++;\n\tfor (i = *page - i; (i % NumberUp) != 0; i ++, (*page) ++);\n      }\n\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n\n      *x = *left;\n      *y = *top;\n\n      tof = 1;\n    }\n    else if (strncasecmp(comment, \"HALF PAGE\", 9) == 0 &&\n             (!comment[9] || isspace(comment[9])))\n    {\n     /*\n      * <!-- HALF PAGE --> Go to the next half page.  If in the\n      * top half of a page, go to the bottom half.  If in the\n      * bottom half, go to the next page.\n      */\n      float halfway;\n\n\n      comment += 9;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n      }\n\n      halfway = 0.5f * (*top + *bottom);\n\n      if (*y <= halfway)\n      {\n\t(*page) ++;\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*x = *left;\n\t*y = *top;\n\n        tof = 1;\n      }\n      else\n      {\n\t*x = *left;\n\t*y = halfway;\n\n        tof = 0;\n      }\n    }\n    else if (strncasecmp(comment, \"NEED \", 5) == 0)\n    {\n     /*\n      * <!-- NEED amount --> generate a page break if there isn't\n      * enough remaining space...\n      */\n\n      comment += 5;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if ((*y - get_measurement(comment, (float)_htmlSpacings[SIZE_P])) < *bottom)\n      {\n\t(*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*y = *top;\n        tof = 1;\n      }\n\n      *x = *left;\n\n      // Skip amount...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA COLOR \", 12) == 0)\n    {\n      // Media color for page...\n      comment += 12;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (PageDuplex && ((*page) & 1))\n\t  (*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*y = *top;\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      // Get color...\n      if (*comment == '\\\"')\n      {\n\tfor (ptr = pages[*page].media_color, comment ++;\n             *comment && *comment != '\\\"';\n\t     comment ++)\n          if (ptr < (pages[*page].media_color +\n\t             sizeof(pages[*page].media_color) - 1))\n\t    *ptr++ = *comment;\n\n        if (*comment == '\\\"')\n\t  comment ++;\n      }\n      else\n      {\n\tfor (ptr = pages[*page].media_color;\n             *comment && !isspace(*comment);\n\t     comment ++)\n          if (ptr < (pages[*page].media_color +\n\t             sizeof(pages[*page].media_color) - 1))\n\t    *ptr++ = *comment;\n      }\n\n      *ptr = '\\0';\n    }\n    else if (strncasecmp(comment, \"MEDIA POSITION \", 15) == 0)\n    {\n      // Media position for page...\n      comment += 15;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (PageDuplex && ((*page) & 1))\n\t  (*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*y = *top;\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      pages[*page].media_position = atoi(comment);\n\n      // Skip position...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA TYPE \", 11) == 0)\n    {\n      // Media type for page...\n      comment += 11;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (PageDuplex && ((*page) & 1))\n\t  (*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*y = *top;\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      // Get type...\n      if (*comment == '\\\"')\n      {\n\tfor (ptr = pages[*page].media_type, comment ++;\n             *comment && *comment != '\\\"';\n\t     comment ++)\n          if (ptr < (pages[*page].media_type +\n\t             sizeof(pages[*page].media_type) - 1))\n\t    *ptr++ = *comment;\n\n        if (*comment == '\\\"')\n\t  comment ++;\n      }\n      else\n      {\n\tfor (ptr = pages[*page].media_type;\n             *comment && !isspace(*comment);\n\t     comment ++)\n          if (ptr < (pages[*page].media_type +\n\t             sizeof(pages[*page].media_type) - 1))\n\t    *ptr++ = *comment;\n      }\n\n      *ptr = '\\0';\n    }\n    else if (strncasecmp(comment, \"MEDIA SIZE \", 11) == 0)\n    {\n      // Media size...\n      comment += 11;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n        tof = 1;\n      }\n\n      if (PageDuplex && ((*page) & 1))\n\t(*page) ++;\n\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n\n      check_pages(*page);\n\n      *right = PagePrintWidth - *right;\n      *top   = PagePrintLength - *top;\n\n      set_page_size(comment);\n\n      if (Landscape)\n      {\n\tPagePrintWidth  = PageLength - PageLeft - PageRight;\n\tPagePrintLength = PageWidth - PageTop - PageBottom;\n      }\n      else\n      {\n\tPagePrintWidth  = PageWidth - PageLeft - PageRight;\n\tPagePrintLength = PageLength - PageTop - PageBottom;\n      }\n\n      *right = PagePrintWidth - *right;\n      *top   = PagePrintLength - *top;\n\n      *x = *left;\n      *y = *top;\n\n      pages[*page].width  = PageWidth;\n      pages[*page].length = PageLength;\n\n      // Skip width...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA LEFT \", 11) == 0)\n    {\n      // Left margin...\n      comment += 11;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*y = *top;\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      *right   = PagePrintWidth - *right;\n      PageLeft = pages[*page].left = get_measurement(comment);\n\n      if (Landscape)\n\tPagePrintWidth = PageLength - PageRight - PageLeft;\n      else\n\tPagePrintWidth = PageWidth - PageRight - PageLeft;\n\n      *right = PagePrintWidth - *right;\n\n      // Skip left...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA RIGHT \", 12) == 0)\n    {\n      // Right margin...\n      comment += 12;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\t*y = *top;\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      *right    = PagePrintWidth - *right;\n      PageRight = pages[*page].right = get_measurement(comment);\n\n      if (Landscape)\n\tPagePrintWidth = PageLength - PageRight - PageLeft;\n      else\n\tPagePrintWidth = PageWidth - PageRight - PageLeft;\n\n      *right = PagePrintWidth - *right;\n\n      // Skip right...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA BOTTOM \", 13) == 0)\n    {\n      // Bottom margin...\n      comment += 13;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      *top       = PagePrintLength - *top;\n      PageBottom = pages[*page].bottom = get_measurement(comment);\n\n      if (Landscape)\n        PagePrintLength = PageWidth - PageTop - PageBottom;\n      else\n        PagePrintLength = PageLength - PageTop - PageBottom;\n\n      *top = PagePrintLength - *top;\n      *y   = *top;\n\n      // Skip bottom...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA TOP \", 10) == 0)\n    {\n      // Top margin...\n      comment += 10;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\tif (Verbosity)\n\t  progress_show(\"Formatting page %d\", *page);\n\n        tof = 1;\n      }\n\n      *x = *left;\n\n      check_pages(*page);\n\n      *top    = PagePrintLength - *top;\n      PageTop = pages[*page].top = get_measurement(comment);\n\n      if (Landscape)\n        PagePrintLength = PageWidth - PageTop - PageBottom;\n      else\n        PagePrintLength = PageLength - PageTop - PageBottom;\n\n      *top = PagePrintLength - *top;\n      *y   = *top;\n\n      // Skip top...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA LANDSCAPE \", 16) == 0)\n    {\n      // Landscape on/off...\n      comment += 16;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n        tof = 1;\n      }\n\n      if (PageDuplex && ((*page) & 1))\n\t(*page) ++;\n\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n\n      *x = *left;\n\n      check_pages(*page);\n\n      if (strncasecmp(comment, \"OFF\", 3) == 0 || tolower(comment[0]) == 'n')\n      {\n        if (Landscape)\n\t{\n\t  *right         = PageLength - PageRight - *right;\n\t  PagePrintWidth = PageWidth - PageRight - PageLeft;\n\t  *right         = PageWidth - PageRight - *right;\n\n\t  *top            = PageWidth - PageTop - *top;\n\t  PagePrintLength = PageLength - PageTop - PageBottom;\n\t  *top            = PageLength - PageTop - *top;\n        }\n\n        Landscape = pages[*page].landscape = 0;\n      }\n      else if (strncasecmp(comment, \"ON\", 2) == 0 || tolower(comment[0]) == 'y')\n      {\n        if (!Landscape)\n\t{\n\t  *top            = PageLength - PageTop - *top;\n\t  PagePrintLength = PageWidth - PageTop - PageBottom;\n\t  *top            = PageWidth - PageTop - *top;\n\n\t  *right         = PageWidth - PageRight - *right;\n\t  PagePrintWidth = PageLength - PageRight - PageLeft;\n\t  *right         = PageLength - PageRight - *right;\n        }\n\n        Landscape = pages[*page].landscape = 1;\n      }\n\n      *y = *top;\n\n      // Skip landscape...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"MEDIA DUPLEX \", 13) == 0)\n    {\n      // Duplex printing on/off...\n      comment += 13;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (!tof)\n      {\n\t(*page) ++;\n\n\t*y = *top;\n        tof = 1;\n      }\n\n      if (PageDuplex && ((*page) & 1))\n\t(*page) ++;\n\n      if (Verbosity)\n\tprogress_show(\"Formatting page %d\", *page);\n\n      *x = *left;\n\n      check_pages(*page);\n\n      if (strncasecmp(comment, \"OFF\", 3) == 0 || tolower(comment[0]) == 'n')\n        PageDuplex = pages[*page].duplex = 0;\n      else if (strncasecmp(comment, \"ON\", 2) == 0 || tolower(comment[0]) == 'y')\n      {\n\tif ((*page) & 1)\n\t{\n\t  (*page) ++;\n\n          check_pages(*page);\n\n\t  if (Verbosity)\n\t    progress_show(\"Formatting page %d\", *page);\n\t}\n\n        PageDuplex = pages[*page].duplex = 1;\n      }\n\n      // Skip duplex...\n      while (*comment && !isspace(*comment))\n        comment ++;\n    }\n    else if (strncasecmp(comment, \"HEADER \", 7) == 0)\n    {\n      // Header string...\n      comment += 7;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (strncasecmp(comment, \"LEFT\", 4) == 0 && isspace(comment[4]))\n      {\n        pos     = 0;\n\tcomment += 4;\n      }\n      else if (strncasecmp(comment, \"CENTER\", 6) == 0 && isspace(comment[6]))\n      {\n        pos     = 1;\n\tcomment += 6;\n      }\n      else if (strncasecmp(comment, \"RIGHT\", 5) == 0 && isspace(comment[5]))\n      {\n        pos     = 2;\n\tcomment += 5;\n      }\n      else\n      {\n        progress_error(HD_ERROR_BAD_COMMENT,\n                       \"Bad HEADER position: \\\"%s\\\"\", comment);\n\treturn;\n      }\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (*comment != '\\\"')\n      {\n        progress_error(HD_ERROR_BAD_COMMENT,\n                       \"Bad HEADER string: \\\"%s\\\"\", comment);\n\treturn;\n      }\n\n      for (ptr = buffer, comment ++; *comment && *comment != '\\\"'; comment ++)\n      {\n        if (*comment == '\\\\')\n\t  comment ++;\n\n\tif (ptr < (buffer + sizeof(buffer) - 1))\n\t  *ptr++ = *comment;\n      }\n\n      if (*comment == '\\\"')\n        comment ++;\n\n      *ptr = '\\0';\n\n      if (ptr > buffer)\n        Header[pos] = strdup(buffer);\n      else\n        Header[pos] = NULL;\n\n      if (tof)\n      {\n        DEBUG_printf((\"Setting header %d for page %d to \\\"%s\\\"...\\n\",\n\t              pos, *page, Header[pos] ? Header[pos] : \"(null)\"));\n\n\tcheck_pages(*page);\n\n\tpages[*page].header[pos] = (uchar *)Header[pos];\n      }\n\n      // Adjust top margin as needed...\n      float adjust, image_adjust, temp_adjust;\n\n      if (maxhfheight > HeadFootSize)\n\timage_adjust = (float)(maxhfheight + HeadFootSize);\n      else\n\timage_adjust = (float)(2 * HeadFootSize);\n\n      for (adjust = 0.0, pos = 0; pos < 3; pos ++)\n      {\n\tif (Header[pos] &&\n\t    (strstr(Header[pos], \"$IMAGE\") != NULL ||\n\t     strstr(Header[pos], \"$HFIMAGE\") != NULL))\n\t  temp_adjust = image_adjust;\n\telse if (Header1[pos] &&\n\t\t (strstr(Header1[pos], \"$IMAGE\") != NULL ||\n\t\t  strstr(Header1[pos], \"$HFIMAGE\") != NULL))\n\t  temp_adjust = image_adjust;\n\telse if (Header[pos] || Header1[pos])\n\t  temp_adjust = (float)(2 * HeadFootSize);\n\telse\n\t  temp_adjust = 0.0;\n\n\tif (temp_adjust > adjust)\n\t  adjust = temp_adjust;\n      }\n\n      *top = PagePrintLength - adjust;\n\n      if (tof)\n        *y = *top;\n    }\n    else if (strncasecmp(comment, \"HEADER1 \", 8) == 0)\n    {\n      // First page header string...\n      comment += 8;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (strncasecmp(comment, \"LEFT\", 4) == 0 && isspace(comment[4]))\n      {\n        pos     = 0;\n\tcomment += 4;\n      }\n      else if (strncasecmp(comment, \"CENTER\", 6) == 0 && isspace(comment[6]))\n      {\n        pos     = 1;\n\tcomment += 6;\n      }\n      else if (strncasecmp(comment, \"RIGHT\", 5) == 0 && isspace(comment[5]))\n      {\n        pos     = 2;\n\tcomment += 5;\n      }\n      else\n      {\n        progress_error(HD_ERROR_BAD_COMMENT,\n                       \"Bad HEADER1 position: \\\"%s\\\"\", comment);\n\treturn;\n      }\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (*comment != '\\\"')\n      {\n        progress_error(HD_ERROR_BAD_COMMENT,\n                       \"Bad HEADER1 string: \\\"%s\\\"\", comment);\n\treturn;\n      }\n\n      for (ptr = buffer, comment ++; *comment && *comment != '\\\"'; comment ++)\n      {\n        if (*comment == '\\\\')\n\t  comment ++;\n\n\tif (ptr < (buffer + sizeof(buffer) - 1))\n\t  *ptr++ = *comment;\n      }\n\n      if (*comment == '\\\"')\n        comment ++;\n\n      *ptr = '\\0';\n\n      if (ptr > buffer)\n        Header1[pos] = strdup(buffer);\n      else\n        Header1[pos] = NULL;\n\n      // Adjust top margin as needed...\n      float adjust, image_adjust, temp_adjust;\n\n      if (maxhfheight > HeadFootSize)\n\timage_adjust = (float)(maxhfheight + HeadFootSize);\n      else\n\timage_adjust = (float)(2 * HeadFootSize);\n\n      for (adjust = 0.0, pos = 0; pos < 3; pos ++)\n      {\n\tif (Header[pos] &&\n\t    (strstr(Header[pos], \"$IMAGE\") != NULL ||\n\t     strstr(Header[pos], \"$HFIMAGE\") != NULL))\n\t  temp_adjust = image_adjust;\n\telse if (Header1[pos] &&\n\t\t (strstr(Header1[pos], \"$IMAGE\") != NULL ||\n\t\t  strstr(Header1[pos], \"$HFIMAGE\") != NULL))\n\t  temp_adjust = image_adjust;\n\telse if (Header[pos] || Header1[pos])\n\t  temp_adjust = (float)(2 * HeadFootSize);\n\telse\n\t  temp_adjust = 0.0;\n\n\tif (temp_adjust > adjust)\n\t  adjust = temp_adjust;\n      }\n\n      *top = PagePrintLength - adjust;\n\n      if (tof)\n        *y = *top;\n    }\n    else if (strncasecmp(comment, \"FOOTER \", 7) == 0)\n    {\n      // Footer string...\n      comment += 7;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (strncasecmp(comment, \"LEFT\", 4) == 0 && isspace(comment[4]))\n      {\n        pos     = 0;\n\tcomment += 4;\n      }\n      else if (strncasecmp(comment, \"CENTER\", 6) == 0 && isspace(comment[6]))\n      {\n        pos     = 1;\n\tcomment += 6;\n      }\n      else if (strncasecmp(comment, \"RIGHT\", 5) == 0 && isspace(comment[5]))\n      {\n        pos     = 2;\n\tcomment += 5;\n      }\n      else\n      {\n        progress_error(HD_ERROR_BAD_COMMENT,\n                       \"Bad FOOTER position: \\\"%s\\\"\", comment);\n\treturn;\n      }\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (*comment != '\\\"')\n      {\n        progress_error(HD_ERROR_BAD_COMMENT,\n                       \"Bad FOOTER string: \\\"%s\\\"\", comment);\n\treturn;\n      }\n\n      for (ptr = buffer, comment ++; *comment && *comment != '\\\"'; comment ++)\n      {\n        if (*comment == '\\\\')\n\t  comment ++;\n\n\tif (ptr < (buffer + sizeof(buffer) - 1))\n\t  *ptr++ = *comment;\n      }\n\n      if (*comment == '\\\"')\n        comment ++;\n\n      *ptr = '\\0';\n\n      if (ptr > buffer)\n        Footer[pos] = strdup(buffer);\n      else\n        Footer[pos] = NULL;\n\n      if (tof)\n      {\n\tcheck_pages(*page);\n\n\tpages[*page].footer[pos] = (uchar *)Footer[pos];\n      }\n\n      // Adjust bottom margin as needed...\n      float adjust, image_adjust, temp_adjust;\n\n      if (maxhfheight > HeadFootSize)\n\timage_adjust = (float)(maxhfheight + HeadFootSize);\n      else\n\timage_adjust = (float)(2 * HeadFootSize);\n\n      for (adjust = 0.0, pos = 0; pos < 3; pos ++)\n      {\n\tif (Footer[pos] &&\n\t    (strstr(Footer[pos], \"$IMAGE\") != NULL ||\n\t     strstr(Footer[pos], \"$HFIMAGE\") != NULL))\n\t  temp_adjust = image_adjust;\n\telse if (Footer[pos])\n\t  temp_adjust = (float)(2 * HeadFootSize);\n\telse\n\t  temp_adjust = 0.0;\n\n\tif (temp_adjust > adjust)\n\t  adjust = temp_adjust;\n      }\n\n      *bottom = adjust;\n    }\n    else if (strncasecmp(comment, \"NUMBER-UP \", 10) == 0)\n    {\n      // N-up printing...\n      comment += 10;\n\n      while (isspace(*comment))\n\tcomment ++;\n\n      if (!*comment)\n\tbreak;\n\n      NumberUp = strtol(comment, (char **)&comment, 10);\n\n      if (para != NULL && para->child != NULL)\n      {\n\tparse_paragraph(para, *left, *right, *bottom, *top, x, y, page, needspace);\n\thtmlDeleteTree(para->child);\n\tpara->child = para->last_child = NULL;\n\n\t// Mark if we are still at the top of form...\n\ttof = (*y >= *top);\n      }\n\n      if (tof)\n      {\n\tcheck_pages(*page);\n\n        pages[*page].nup = NumberUp;\n      }\n    }\n    else\n      break;\n  }\n\n  DEBUG_printf((\"LEAVING parse_comment() x=%.1f, y=%.1f, page=%d\\n\",\n                *x, *y, *page));\n  DEBUG_printf((\" PagePrintWidth = %d\\n\", PagePrintWidth));\n  DEBUG_printf((\"PagePrintLength = %d\\n\", PagePrintLength));\n  DEBUG_printf((\"      PageWidth = %d\\n\", PageWidth));\n  DEBUG_printf((\"     PageLength = %d\\n\", PageLength));\n  DEBUG_printf((\"       PageLeft = %d\\n\", PageLeft));\n  DEBUG_printf((\"     PageBottom = %d\\n\", PageBottom));\n  DEBUG_printf((\"      PageRight = %d\\n\", PageRight));\n  DEBUG_printf((\"        PageTop = %d\\n\", PageTop));\n  DEBUG_printf((\"      Landscape = %d\\n\", Landscape));\n}\n\n#ifdef COMMENT_DEBUG\n#  undef DEBUG\n#  undef DEBUG_puts\n#  define DEBUG_puts(x)\n#  undef DEBUG_printf\n#  define DEBUG_printf(x)\n#endif /* COMMENT_DEBUG */\n\n\n/*\n * 'find_background()' - Find the background image/color for the given document.\n */\n\nstatic void\nfind_background(tree_t *t)\t/* I - Document to search */\n{\n  uchar\t\t*var;\t\t/* BGCOLOR/BACKGROUND variable */\n\n\n /*\n  * First see if the --bodycolor or --bodyimage options have been\n  * specified...\n  */\n\n  if (BodyImage[0] != '\\0')\n  {\n    background_image = image_load(BodyImage, !OutputColor);\n    return;\n  }\n  else if (BodyColor[0] != '\\0')\n  {\n    get_color((uchar *)BodyColor, background_color, 0);\n    return;\n  }\n\n /*\n  * If not, search the document tree...\n  */\n\n  while (t != NULL && background_image == NULL &&\n         background_color[0] == 1.0 && background_color[1] == 1.0 &&\n\t background_color[2] == 1.0)\n  {\n    if (t->markup == MARKUP_BODY)\n    {\n      if ((var = htmlGetVariable(t, (uchar *)\"BACKGROUND\")) != NULL)\n        background_image = image_load((char *)var, !OutputColor);\n\n      if ((var = htmlGetVariable(t, (uchar *)\"BGCOLOR\")) != NULL)\n        get_color(var, background_color, 0);\n    }\n\n    if (t->child != NULL)\n      find_background(t->child);\n\n    t = t->next;\n  }\n}\n\n\n/*\n * 'write_background()' - Write the background image/color for to the current\n *                        page.\n */\n\nstatic void\nwrite_background(int  page,\t/* I - Page we are writing for */\n                 FILE *out)\t/* I - File to write to */\n{\n  float\tx, y;\n  float\twidth, height;\n  int\tpage_width, page_length;\n\n\n  if (Landscape)\n  {\n    page_length = pages[page].width;\n    page_width  = pages[page].length;\n  }\n  else\n  {\n    page_width  = pages[page].width;\n    page_length = pages[page].length;\n  }\n\n  if (background_color[0] != 1.0 ||\n      background_color[1] != 1.0 ||\n      background_color[2] != 1.0)\n  {\n    if (PSLevel > 0)\n    {\n      render_x = -1.0;\n      render_y = -1.0;\n      set_color(out, background_color);\n      fprintf(out, \"0 0 M %d %d F\\n\", page_width, page_length);\n    }\n    else\n    {\n      set_color(out, background_color);\n      flate_printf(out, \"0 0 %d %d re f\\n\", page_width, page_length);\n    }\n  }\n\n  if (background_image != NULL)\n  {\n    width  = (float)(background_image->width * 72.0f / _htmlPPI);\n    height = (float)(background_image->height * 72.0f / _htmlPPI);\n\n    if (width < 1.0f)\n      width = 1.0f;\n    if (height < 1.0f)\n      height = 1.0f;\n\n    switch (PSLevel)\n    {\n      case 0 :\n          for (x = 0.0; x < page_width; x += width)\n            for (y = page_length; y >= 0.0f;)\n            {\n\t      y -= height;\n  \t      flate_printf(out, \"q %.1f 0 0 %.1f %.1f %.1f cm\", width, height, x, y);\n              flate_printf(out, \"/I%d Do\\n\", background_image->obj);\n\t      flate_puts(\"Q\\n\", out);\n            }\n\t  break;\n\n      default :\n          fprintf(out, \"0 %.1f %d{/y exch neg %d add def\\n\",\n\t          height, page_length + (int)height - 1, page_length);\n\t  fprintf(out, \"0 %.1f %d{/x exch def\\n\",\n\t          width, page_width);\n          fprintf(out, \"GS[%.1f 0 0 %.1f x y]CM/iy -1 def\\n\", width, height);\n\t  fprintf(out, \"%d %d 8[%d 0 0 %d 0 %d]\",\n\t          background_image->width, background_image->height,\n                  background_image->width, -background_image->height,\n\t\t  background_image->height);\n          fputs(\"{/iy iy 1 add def BG iy get}\", out);\n\t  if (background_image->depth == 1)\n\t    fputs(\"image\\n\", out);\n\t  else\n\t    fputs(\"false 3 colorimage\\n\", out);\n\t  fputs(\"GR}for}for\\n\", out);\n          break;\n    }\n  }\n}\n\n\n/*\n * 'new_render()' - Allocate memory for a new rendering structure.\n */\n\nstatic render_t *\t\t\t/* O - New render structure */\nnew_render(int      page,\t\t/* I - Page number (0-n) */\n           int      type,\t\t/* I - Type of render primitive */\n           double   x,\t\t\t/* I - Horizontal position */\n           double   y,\t\t\t/* I - Vertical position */\n           double   width,\t\t/* I - Width */\n           double   height,\t\t/* I - Height */\n           void     *data,\t\t/* I - Data */\n\t   render_t *insert)\t\t/* I - Insert before here... */\n{\n  render_t\t\t*r;\t\t/* New render primitive */\n  size_t\t\tdatalen = 0;\t/* Length of data */\n  static render_t\tdummy;\t\t/* Dummy var for errors... */\n\n\n  DEBUG_printf((\"new_render(page=%d, type=%d, x=%.1f, y=%.1f, width=%.1f, height=%.1f, data=%p, insert=%p)\\n\",\n                page, type, x, y, width, height, (void *)data, (void *)insert));\n\n  check_pages(page);\n\n  if (page < 0 || page >= (int)alloc_pages)\n  {\n    progress_error(HD_ERROR_INTERNAL_ERROR,\n                   \"Page number (%d) out of range (1...%d)\\n\", page + 1,\n                   (int)alloc_pages);\n    memset(&dummy, 0, sizeof(dummy));\n    return (&dummy);\n  }\n\n  if ((type != RENDER_TEXT && type != RENDER_LINK) || data == NULL)\n    r = (render_t *)calloc(sizeof(render_t), 1);\n  else\n  {\n    datalen = strlen((char *)data);\n    r       = (render_t *)calloc(sizeof(render_t) + datalen, 1);\n  }\n\n  if (r == NULL)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY,\n                   \"Unable to allocate memory on page %d\\n\", (int)page + 1);\n    memset(&dummy, 0, sizeof(dummy));\n    return (&dummy);\n  }\n\n  r->type   = type;\n  r->x      = (float)x;\n  r->y      = (float)y;\n  r->width  = (float)width;\n  r->height = (float)height;\n\n  switch (type)\n  {\n    case RENDER_TEXT :\n        if (data == NULL)\n        {\n          free(r);\n          return (NULL);\n        }\n\t// Safe because buffer is allocated...\n        memcpy((char *)r->data.text.buffer, (char *)data, datalen);\n        get_color(_htmlTextColor, r->data.text.rgb);\n        break;\n    case RENDER_IMAGE :\n        if (data == NULL)\n        {\n          free(r);\n          return (NULL);\n        }\n        r->data.image = (image_t *)data;\n        break;\n    case RENDER_BOX :\n        memcpy(r->data.box, data, sizeof(r->data.box));\n        break;\n    case RENDER_LINK :\n        if (data == NULL)\n        {\n          free(r);\n          return (NULL);\n        }\n\t// Safe because buffer is allocated...\n        memcpy((char *)r->data.link, (char *)data, datalen);\n        break;\n  }\n\n  if (insert)\n  {\n    if (insert->prev)\n      insert->prev->next = r;\n    else\n      pages[page].start = r;\n\n    r->prev      = insert->prev;\n    r->next      = insert;\n    insert->prev = r;\n  }\n  else\n  {\n    if (pages[page].end != NULL)\n      pages[page].end->next = r;\n    else\n      pages[page].start = r;\n\n    r->next         = NULL;\n    r->prev         = pages[page].end;\n    pages[page].end = r;\n  }\n\n  DEBUG_printf((\"    returning r = %p\\n\", (void *)r));\n\n  return (r);\n}\n\n\n/*\n * 'check_pages()' - Allocate memory for more pages as needed...\n */\n\nstatic void\ncheck_pages(int page)\t// I - Current page\n{\n  page_t\t*temp;\t// Temporary page pointer\n\n\n  DEBUG_printf((\"check_pages(%d)\\n\", page));\n\n  // See if we need to allocate memory for the page...\n  if (page >= (int)alloc_pages)\n  {\n    // Yes, allocate enough for ALLOC_PAGES more pages...\n    while (page >= (int)alloc_pages)\n      alloc_pages += ALLOC_PAGES;\n\n    // Do the pages pointers...\n    if (num_pages == 0)\n      temp = (page_t *)malloc(sizeof(page_t) * alloc_pages);\n    else\n      temp = (page_t *)realloc(pages, sizeof(page_t) * alloc_pages);\n\n    if (temp == NULL)\n    {\n      progress_error(HD_ERROR_OUT_OF_MEMORY,\n                     \"Unable to allocate memory for %d pages - %s\",\n\t             (int)alloc_pages, strerror(errno));\n      alloc_pages -= ALLOC_PAGES;\n      return;\n    }\n\n    memset(temp + num_pages, 0, (alloc_pages - num_pages) * sizeof(page_t));\n\n    pages = temp;\n  }\n\n  // Initialize the page data as needed...\n  for (temp = pages + num_pages; (int)num_pages <= page; num_pages ++, temp ++)\n  {\n    if (!temp->width)\n    {\n      if (num_pages == 0 || !temp[-1].width || !temp[-1].length || chapter == 0)\n      {\n\ttemp->width     = PageWidth;\n\ttemp->length    = PageLength;\n\ttemp->left      = PageLeft;\n\ttemp->right     = PageRight;\n\ttemp->top       = PageTop;\n\ttemp->bottom    = PageBottom;\n\ttemp->duplex    = PageDuplex;\n\ttemp->landscape = Landscape;\n\ttemp->nup       = NumberUp;\n      }\n      else\n      {\n\tmemcpy(temp, temp - 1, sizeof(page_t));\n\ttemp->start = NULL;\n\ttemp->end   = NULL;\n      }\n\n      temp->url = current_url;\n\n      if (chapter == 0)\n      {\n\tmemcpy(temp->header, TocHeader, sizeof(temp->header));\n\tmemcpy(temp->footer, TocFooter, sizeof(temp->footer));\n      }\n      else\n      {\n\tmemcpy(temp->header, Header, sizeof(temp->header));\n\tmemcpy(temp->header1, Header1, sizeof(temp->header1));\n\tmemcpy(temp->footer, Footer, sizeof(temp->footer));\n\n        if (current_heading != temp->headnode)\n\t{\n\t  temp->heading  = htmlGetText(current_heading);\n\t  temp->headnode = current_heading;\n\t}\n      }\n\n      memcpy(temp->background_color, background_color,\n             sizeof(temp->background_color));\n      temp->background_image = background_image;\n    }\n  }\n}\n\n\n/*\n * 'add_link()' - Add a named link...\n */\n\nstatic void\nadd_link(uchar *name,\t\t/* I - Name of link */\n         int   page,\t\t/* I - Page # */\n         int   top)\t\t/* I - Y position */\n{\n  link_t\t*temp;\t\t/* New name */\n\n\n  if (name == NULL)\n    return;\n\n  DEBUG_printf((\"add_link(name=\\\"%s\\\", page=%d, top=%d)\\n\", name, page, top));\n\n  if ((temp = find_link(name)) != NULL)\n  {\n    temp->page = (short)page;\n    temp->top  = (short)top;\n  }\n  else\n  {\n    // See if we need to allocate memory for links...\n    if (num_links >= alloc_links)\n    {\n      // Allocate more links...\n      alloc_links += ALLOC_LINKS;\n\n      if (num_links == 0)\n        temp = (link_t *)malloc(sizeof(link_t) * alloc_links);\n      else\n        temp = (link_t *)realloc(links, sizeof(link_t) * alloc_links);\n\n      if (temp == NULL)\n      {\n\tprogress_error(HD_ERROR_OUT_OF_MEMORY,\n                       \"Unable to allocate memory for %d links - %s\",\n\t               (int)alloc_links, strerror(errno));\n        alloc_links -= ALLOC_LINKS;\n\treturn;\n      }\n\n      links = temp;\n    }\n\n    // Add a new link...\n    temp = links + num_links;\n    num_links ++;\n\n    strlcpy((char *)temp->name, (char *)name, sizeof(temp->name));\n    temp->page = (short)page;\n    temp->top  = (short)top;\n\n    if (num_links > 1)\n      qsort(links, num_links, sizeof(link_t),\n            (compare_func_t)compare_links);\n  }\n}\n\n\n/*\n * 'find_link()' - Find a named link...\n */\n\nstatic link_t *\nfind_link(uchar *name)\t/* I - Name to find */\n{\n  link_t\tkey,\t/* Search key */\n\t\t*match;\t/* Matching name entry */\n\n\n  if (name == NULL || num_links == 0)\n    return (NULL);\n\n  if (name[0] == '#')\n    name ++;\n\n  strlcpy((char *)key.name, (char *)name, sizeof(key.name));\n  match = (link_t *)bsearch(&key, links, num_links, sizeof(link_t),\n                            (compare_func_t)compare_links);\n\n  return (match);\n}\n\n\n/*\n * 'compare_links()' - Compare two named links.\n */\n\nstatic int\t\t\t/* O - 0 = equal, -1 or 1 = not equal */\ncompare_links(link_t *n1,\t/* I - First name */\n              link_t *n2)\t/* I - Second name */\n{\n  return (strcasecmp((char *)n1->name, (char *)n2->name));\n}\n\n\n#ifdef TABLE_DEBUG\n#  undef DEBUG_printf\n#  undef DEBUG_puts\n#  define DEBUG_printf(x) printf x\n#  define DEBUG_puts(x) puts(x)\n#endif /* TABLE_DEBUG */\n\n//\n// 'get_cell_size()' - Compute the minimum width of a cell.\n//\n\nstatic float\t\t\t\t// O - Required width of cell\nget_cell_size(tree_t *t,\t\t// I - Cell\n              float  left,\t\t// I - Left margin\n\t      float  right,\t\t// I - Right margin\n\t      float  *minwidth,\t\t// O - Minimum width\n\t      float  *prefwidth,\t// O - Preferred width\n\t      float  *minheight)\t// O - Minimum height\n{\n  tree_t\t*temp,\t\t\t// Current tree entry\n\t\t*next;\t\t\t// Next tree entry\n  uchar\t\t*var;\t\t\t// Attribute value\n  int\t\tnowrap;\t\t\t// NOWRAP attribute?\n  float\t\twidth,\t\t\t// Width of cell\n\t\tfrag_width,\t\t// Fragment required width\n\t\tfrag_height,\t\t// Fragment height\n\t\tfrag_pref,\t\t// Fragment preferred width\n\t\tfrag_min,\t\t// Fragment minimum width\n\t\tminh,\t\t\t// Local minimum height\n\t\tminw,\t\t\t// Local minimum width\n\t\tprefw,\t\t\t// Local preferred width\n\t\tformat_width;\t\t// Working format width for images\n\n\n  DEBUG_printf((\"get_cell_size(%p, %.1f, %.1f, %p, %p, %p)\\n\",\n                (void *)t, left, right, (void *)minwidth, (void *)prefwidth, (void *)minheight));\n\n  // First see if the width has been specified for this cell...\n  if ((var = htmlGetVariable(t, (uchar *)\"WIDTH\")) != NULL &&\n      (var[strlen((char *)var) - 1] != '%' || (right - left) > 0.0f))\n  {\n    // Yes, use it!\n    if (var[strlen((char *)var) - 1] == '%')\n      width = (right - left) * atoi((char *)var) * 0.01f;\n    else\n      width = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n    width = 0.0f;\n\n  if ((format_width = right - left) <= 0.0f)\n    format_width = PagePrintWidth;\n\n  minw  = 0.0f;\n  prefw = 0.0f;\n\n  // Then the height...\n  if ((var = htmlGetVariable(t, (uchar *)\"HEIGHT\")) != NULL)\n  {\n    // Yes, use it!\n    if (var[strlen((char *)var) - 1] == '%')\n      minh = PagePrintLength * atoi((char *)var) * 0.01f;\n    else\n      minh = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n    minh = 0.0f;\n\n  nowrap = (htmlGetVariable(t, (uchar *)\"NOWRAP\") != NULL);\n\n  DEBUG_printf((\"nowrap = %d\\n\", nowrap));\n\n  for (temp = t->child, frag_width = 0.0f, frag_pref = 0.0f;\n       temp != NULL;\n       temp = next)\n  {\n    // Point to next markup, if any...\n    next = temp->child;\n\n    switch (temp->markup)\n    {\n      case MARKUP_TABLE :\n\t  // Update widths...\n\t  if (frag_pref > prefw)\n\t    prefw = frag_pref;\n\n\t  if (frag_width > minw)\n\t  {\n\t    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for block...\\n\",\n\t        \t  frag_width, minw));\n\t    minw = frag_width;\n\t  }\n\n\t  if (nowrap && frag_pref > minw)\n\t  {\n\t    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for break...\\n\",\n\t        \t  frag_pref, minw));\n\t    minw = frag_pref;\n\t  }\n\n          // For nested tables, compute the width of the table.\n          frag_width = get_table_size(temp, left, right, &frag_min,\n\t                              &frag_pref, &frag_height);\n\n\t  if (frag_pref > prefw)\n\t    prefw = frag_pref;\n\n\t  if (frag_min > minw)\n\t  {\n\t    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for nested table...\\n\",\n\t                  frag_min, minw));\n\t    minw = frag_min;\n\t  }\n\n\t  frag_width = 0.0f;\n\t  frag_pref  = 0.0f;\n\t  frag_min   = 0.0f;\n\t  next       = NULL;\n\t  break;\n\n      case MARKUP_IMG :\n          // Update the image width as needed...\n\t  if (temp->markup == MARKUP_IMG)\n\t    update_image_size(temp);\n      case MARKUP_NONE :\n      case MARKUP_SPACER :\n          frag_height = temp->height;\n\n#ifdef TABLE_DEBUG2\n          if (temp->markup == MARKUP_NONE)\n\t    printf(\"FRAG(%s) = %.1f\\n\", temp->data, temp->width);\n\t  else if (temp->markup == MARKUP_SPACER)\n\t    printf(\"SPACER = %.1f\\n\", temp->width);\n\t  else\n\t    printf(\"IMG(%s) = %.1f\\n\", htmlGetVariable(temp, (uchar *)\"SRC\"),\n\t           temp->width);\n#endif // TABLE_DEBUG2\n\n          // Handle min/preferred widths separately...\n          if (temp->width > minw)\n\t  {\n\t    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for fragment...\\n\",\n\t                  temp->width, minw));\n\t    minw = temp->width;\n\t  }\n\n          if (temp->preformatted && temp->data != NULL &&\n              temp->data[strlen((char *)temp->data) - 1] == '\\n')\n          {\n\t    // End of a line - check preferred width...\n\t    frag_pref += temp->width + 1;\n\n            if (frag_pref > prefw)\n              prefw = frag_pref;\n\n            if (temp->preformatted && frag_pref > minw)\n\t    {\n\t      DEBUG_printf((\"Setting minw to %.1f (was %.1f) for preformatted...\\n\",\n\t                    frag_pref, minw));\n              minw = frag_pref;\n\t    }\n\n\t    frag_pref = 0.0f;\n          }\n          else if (temp->data != NULL)\n\t    frag_pref += temp->width + 1;\n\t  else if ((frag_pref + temp->width) > format_width)\n\t  {\n\t    // parse_paragraph() will force a break\n            if (frag_pref > prefw)\n              prefw = frag_pref;\n\n\t    frag_pref = temp->width;\n\t  }\n\t  else\n\t    frag_pref += temp->width;\n\n          if (temp->preformatted && temp->data != NULL &&\n              temp->data[strlen((char *)temp->data) - 1] == '\\n')\n\t  {\n\t    // Check required width...\n            frag_width += temp->width + 1;\n\n            if (frag_width > minw)\n\t    {\n\t      DEBUG_printf((\"Setting minw to %.1f (was %.1f) for block...\\n\",\n\t                    frag_width, minw));\n              minw = frag_width;\n\t    }\n\n            frag_width = 0.0f;\n\t  }\n          else if (!temp->preformatted && temp->data != NULL &&\n\t           (isspace(temp->data[0]) ||\n\t \t    (temp->data[0] && isspace(temp->data[strlen((char *)temp->data) - 1]))))\n\t  {\n\t    // Check required width...\n\t    if (isspace(temp->data[0]))\n\t      frag_width = temp->width + 1;\n\t    else\n              frag_width += temp->width + 1;\n\n            if (frag_width > minw)\n\t    {\n\t      DEBUG_printf((\"Setting minw to %.1f (was %.1f) for block...\\n\",\n\t                    frag_width, minw));\n              minw = frag_width;\n\t    }\n\n\t    if (!isspace(temp->data[0]))\n              frag_width = 0.0f;\n\n            DEBUG_printf((\"frag_width=%.1f after whitespace processing...\\n\",\n\t                  frag_width));\n\t  }\n\t  else if (temp->data != NULL)\n            frag_width += temp->width + 1;\n\t  else if ((frag_width + temp->width) > format_width)\n\t    // parse_paragraph() will force a break\n\t    frag_width = temp->width;\n\t  else\n\t    frag_width += temp->width;\n\t  break;\n\n      case MARKUP_ADDRESS :\n      case MARKUP_BLOCKQUOTE :\n      case MARKUP_BR :\n      case MARKUP_CENTER :\n      case MARKUP_DD :\n      case MARKUP_DIV :\n      case MARKUP_DT :\n      case MARKUP_H1 :\n      case MARKUP_H2 :\n      case MARKUP_H3 :\n      case MARKUP_H4 :\n      case MARKUP_H5 :\n      case MARKUP_H6 :\n      case MARKUP_H7 :\n      case MARKUP_H8 :\n      case MARKUP_H9 :\n      case MARKUP_H10 :\n      case MARKUP_H11 :\n      case MARKUP_H12 :\n      case MARKUP_H13 :\n      case MARKUP_H14 :\n      case MARKUP_H15 :\n      case MARKUP_HR :\n      case MARKUP_LI :\n      case MARKUP_P :\n      case MARKUP_PRE :\n          DEBUG_printf((\"BREAK at %.1f\\n\", frag_pref));\n\n\t  if (frag_pref > prefw)\n\t    prefw = frag_pref;\n\n          if (frag_width > minw)\n\t  {\n\t    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for block...\\n\",\n\t                  frag_width, minw));\n            minw = frag_width;\n\t  }\n\n\t  if (nowrap && frag_pref > minw)\n\t  {\n\t    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for break...\\n\",\n\t                  frag_pref, minw));\n\t    minw = frag_pref;\n\t  }\n\n          frag_pref   = 0.0f;\n\t  frag_width  = 0.0f;\n\n      default :\n          frag_height = 0.0f;\n\t  break;\n    }\n\n    // Update minimum height...\n    if (frag_height > minh)\n      minh = frag_height;\n\n    // Update next pointer as needed...\n    if (next == NULL)\n      next = temp->next;\n\n    if (next == NULL)\n    {\n      // This code is almost funny if you say it fast... :)\n      for (next = temp->parent; next != NULL && next != t; next = next->parent)\n\tif (next->next != NULL)\n\t  break;\n\n      if (next == t)\n\tnext = NULL;\n      else if (next)\n\tnext = next->next;\n    }\n  }\n\n  // Check the last fragment's width...\n  if (frag_pref > prefw)\n    prefw = frag_pref;\n\n  if (frag_width > minw)\n  {\n    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for block...\\n\",\n\t          frag_width, minw));\n    minw = frag_width;\n  }\n\n  // Handle the \"NOWRAP\" option...\n  if (nowrap && prefw > minw)\n  {\n    DEBUG_printf((\"Setting minw to %.1f (was %.1f) for NOWRAP...\\n\",\n\t          prefw, minw));\n    minw = prefw;\n  }\n\n  // Return the required, minimum, and preferred size of the cell...\n  *minwidth  = minw;\n  *prefwidth = prefw;\n  *minheight = minh;\n\n  DEBUG_printf((\"get_cell_size(): width=%.1f, minw=%.1f, prefw=%.1f, minh=%.1f\\n\",\n                width, minw, prefw, minh));\n\n  return (width);\n}\n\n\n//\n// 'get_table_size()' - Compute the minimum width of a table.\n//\n\nstatic float\t\t\t\t// O - Minimum width of table\nget_table_size(tree_t *t,\t\t// I - Table\n               float  left,\t\t// I - Left margin\n\t       float  right,\t\t// I - Right margin\n\t       float  *minwidth,\t// O - Minimum width\n\t       float  *prefwidth,\t// O - Preferred width\n\t       float  *minheight)\t// O - Minimum height\n{\n  tree_t\t*temp,\t\t\t// Current tree entry\n\t\t*next;\t\t\t// Next tree entry\n  uchar\t\t*var;\t\t\t// Attribute value\n  float\t\twidth,\t\t\t// Required width of table\n\t\tminw,\t\t\t// Minimum width of table\n\t\tminh,\t\t\t// Minimum height of table\n\t\tprefw,\t\t\t// Preferred width of table\n\t\tcell_width,\t\t// Cell required width\n\t\tcell_pref,\t\t// Cell preferred width\n\t\tcell_min,\t\t// Cell minimum width\n\t\tcell_height,\t\t// Cell minimum height\n\t\trow_width,\t\t// Row required width\n\t\trow_pref,\t\t// Row preferred width\n\t\trow_min,\t\t// Row minimum width\n\t\trow_height,\t\t// Row minimum height\n\t\tborder,\t\t\t// Border around cells\n\t\tcellpadding,\t\t// Padding inside cells\n\t\tcellspacing;\t\t// Spacing around cells\n  int\t\tcolumns,\t\t// Current number of columns\n\t\tmax_columns,\t\t// Maximum columns\n\t\trows;\t\t\t// Number of rows\n\n\n  DEBUG_printf((\"get_table_size(%p, %.1f, %.1f, %p, %p, %p)\\n\",\n                (void *)t, left, right, (void *)minwidth, (void *)prefwidth, (void *)minheight));\n\n  // First see if the width has been specified for this table...\n  if ((var = htmlGetVariable(t, (uchar *)\"WIDTH\")) != NULL &&\n      (var[strlen((char *)var) - 1] != '%' || (right - left) > 0.0f))\n  {\n    // Yes, use it!\n    if (var[strlen((char *)var) - 1] == '%')\n      width = (right - left) * atoi((char *)var) * 0.01f;\n    else\n      width = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n    width = 0.0f;\n\n  minw  = 0.0f;\n  prefw = 0.0f;\n\n  // Then the height...\n  if ((var = htmlGetVariable(t, (uchar *)\"HEIGHT\")) != NULL)\n  {\n    // Yes, use it!\n    if (var[strlen((char *)var) - 1] == '%')\n      minh = PagePrintLength * atoi((char *)var) * 0.01f;\n    else\n      minh = (float)(atoi((char *)var) * PagePrintWidth / _htmlBrowserWidth);\n  }\n  else\n    minh = 0.0f;\n\n  // Update the size as needed...\n  for (temp = t->child, row_width = 0.0f, row_min = 0.0f, row_pref = 0.0f,\n\t   row_height = 0.0f, columns = 0, rows = 0, max_columns = 0;\n       temp != NULL;\n       temp = next)\n  {\n    // Point to next markup, if any...\n    next = temp->child;\n\n    // Start a new row or add the cell width as needed...\n    if (temp->markup == MARKUP_TR)\n    {\n      minh += row_height;\n\n      row_width  = 0.0f;\n      row_pref   = 0.0f;\n      row_min    = 0.0f;\n      row_height = 0.0f;\n      rows ++;\n      columns = 0;\n    }\n    else if (temp->markup == MARKUP_TD || temp->markup == MARKUP_TH)\n    {\n      // Update columns...\n      columns ++;\n      if (columns > max_columns)\n\tmax_columns = columns;\n\n      // Get widths of cell...\n      cell_width = get_cell_size(temp, left, right, &cell_min, &cell_pref,\n                                 &cell_height);\n\n      // Update row widths...\n      row_width += cell_width;\n      row_pref  += cell_pref;\n      row_min   += cell_min;\n\n      if (cell_height > row_height)\n\trow_height = cell_height;\n\n      // Check current row widths against table...\n      if (row_pref > prefw)\n\tprefw = row_pref;\n\n      if (row_min > minw)\n\tminw = row_min;\n    }\n\n    // Update next pointer as needed...\n    if (next == NULL)\n      next = temp->next;\n\n    if (next == NULL)\n    {\n      // This code is almost funny if you say it fast... :)\n      for (next = temp->parent; next != NULL && next != t; next = next->parent)\n\tif (next->next != NULL)\n\t  break;\n\n      if (next == t)\n\tnext = NULL;\n      else if (next)\n\tnext = next->next;\n    }\n  }\n\n  // Make sure last row is counted in min height calcs.\n  minh += row_height;\n\n  // Add room for spacing and padding...\n  if ((var = htmlGetVariable(t, (uchar *)\"CELLPADDING\")) != NULL)\n    cellpadding = atoi((char *)var);\n  else\n    cellpadding = 1.0f;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"CELLSPACING\")) != NULL)\n    cellspacing = atoi((char *)var);\n  else\n    cellspacing = 0.0f;\n\n  if ((var = htmlGetVariable(t, (uchar *)\"BORDER\")) != NULL)\n  {\n    if ((border = (float)atof((char *)var)) == 0.0 && var[0] != '0')\n      border = 1.0f;\n\n    cellpadding += border;\n  }\n  else\n    border = 0.0f;\n\n  if (border == 0.0f && cellpadding > 0.0f)\n  {\n   /*\n    * Ah, the strange table formatting nightmare that is HTML.\n    * Netscape and MSIE assign an invisible border width of 1\n    * pixel if no border is specified...\n    */\n\n    cellpadding += 1.0f;\n  }\n\n  cellspacing *= PagePrintWidth / _htmlBrowserWidth;\n  cellpadding *= PagePrintWidth / _htmlBrowserWidth;\n\n  DEBUG_printf((\"ADDING %.1f for table space for %d columns...\\n\",\n                max_columns * (2 * cellpadding + cellspacing) - cellspacing,\n\t\tmax_columns));\n\n  if (width > 0.0f)\n    width += max_columns * (2 * cellpadding + cellspacing) - cellspacing;\n\n  minw  += max_columns * (2 * cellpadding + cellspacing) - cellspacing;\n  prefw += max_columns * (2 * cellpadding + cellspacing) - cellspacing;\n  minh  += rows * (2 * cellpadding + cellspacing) - cellspacing;\n\n  // Return the required, minimum, and preferred size of the table...\n  *minwidth  = minw;\n  *prefwidth = prefw;\n  *minheight = minh;\n\n  DEBUG_printf((\"get_table_size(): width=%.1f, minw=%.1f, prefw=%.1f, minh=%.1f\\n\",\n                width, minw, prefw, minh));\n\n  return (width);\n}\n\n#ifdef TABLE_DEBUG\n#  undef DEBUG_printf\n#  undef DEBUG_puts\n#  define DEBUG_printf(x)\n#  define DEBUG_puts(x)\n#endif /* TABLE_DEBUG */\n\n\n/*\n * 'flatten_tree()' - Flatten an HTML tree to only include the text, image,\n *                    link, and break markups.\n */\n\nstatic tree_t *\t\t\t/* O - Flattened markup tree */\nflatten_tree(tree_t *t)\t\t/* I - Markup tree to flatten */\n{\n  tree_t\t*temp,\t\t/* New tree node */\n\t\t*flat;\t\t/* Flattened tree */\n\n\n  flat = NULL;\n\n  while (t != NULL)\n  {\n    switch (t->markup)\n    {\n      case MARKUP_NONE :\n          if (t->data == NULL)\n\t    break;\n      case MARKUP_COMMENT :\n      case MARKUP_BR :\n      case MARKUP_SPACER :\n      case MARKUP_IMG :\n\t  temp = (tree_t *)calloc(sizeof(tree_t), 1);\n\t  memcpy(temp, t, sizeof(tree_t));\n\t  temp->parent = NULL;\n\t  temp->child  = NULL;\n\t  temp->prev   = flat;\n\t  temp->next   = NULL;\n\t  if (flat != NULL)\n            flat->next = temp;\n          flat = temp;\n\n          if (temp->markup == MARKUP_IMG)\n            update_image_size(temp);\n          break;\n\n      case MARKUP_A :\n          if (htmlGetVariable(t, (uchar *)\"NAME\") != NULL)\n          {\n\t    temp = (tree_t *)calloc(sizeof(tree_t), 1);\n\t    memcpy(temp, t, sizeof(tree_t));\n\t    temp->parent = NULL;\n\t    temp->child  = NULL;\n\t    temp->prev   = flat;\n\t    temp->next   = NULL;\n\t    if (flat != NULL)\n              flat->next = temp;\n            flat = temp;\n          }\n\t  break;\n\n      case MARKUP_P :\n      case MARKUP_PRE :\n      case MARKUP_H1 :\n      case MARKUP_H2 :\n      case MARKUP_H3 :\n      case MARKUP_H4 :\n      case MARKUP_H5 :\n      case MARKUP_H6 :\n      case MARKUP_H7 :\n      case MARKUP_H8 :\n      case MARKUP_H9 :\n      case MARKUP_H10 :\n      case MARKUP_H11 :\n      case MARKUP_H12 :\n      case MARKUP_H13 :\n      case MARKUP_H14 :\n      case MARKUP_H15 :\n      case MARKUP_UL :\n      case MARKUP_DIR :\n      case MARKUP_MENU :\n      case MARKUP_OL :\n      case MARKUP_DL :\n      case MARKUP_LI :\n      case MARKUP_DD :\n      case MARKUP_DT :\n      case MARKUP_TR :\n      case MARKUP_CAPTION :\n\t  temp = (tree_t *)calloc(sizeof(tree_t), 1);\n\t  temp->markup = MARKUP_BR;\n\t  temp->parent = NULL;\n\t  temp->child  = NULL;\n\t  temp->prev   = flat;\n\t  temp->next   = NULL;\n\t  if (flat != NULL)\n            flat->next = temp;\n          flat = temp;\n          break;\n\n      default :\n          break;\n    }\n\n    if (t->child != NULL && t->markup != MARKUP_UNKNOWN)\n    {\n      temp = flatten_tree(t->child);\n\n      if (temp != NULL)\n        temp->prev = flat;\n      if (flat != NULL)\n        flat->next = temp;\n      else\n        flat = temp;\n    }\n\n    if (flat != NULL)\n      while (flat->next != NULL)\n        flat = flat->next;\n\n    t = t->next;\n  }\n\n  if (flat == NULL)\n    return (NULL);\n\n  while (flat->prev != NULL)\n    flat = flat->prev;\n\n  return (flat);\n}\n\n\n/*\n * 'update_image_size()' - Update the size of an image based upon the\n *                         printable width.\n */\n\nstatic void\nupdate_image_size(tree_t *t)\t/* I - Tree entry */\n{\n  image_t\t*img;\t\t/* Image file */\n  uchar\t\t*width,\t\t/* Width string */\n\t\t*height;\t/* Height string */\n\n\n  width  = htmlGetVariable(t, (uchar *)\"WIDTH\");\n  height = htmlGetVariable(t, (uchar *)\"HEIGHT\");\n\n  if (width != NULL && height != NULL)\n  {\n    if (width[strlen((char *)width) - 1] == '%')\n      t->width = (float)(atof((char *)width) * PagePrintWidth / 100.0f);\n    else\n      t->width = (float)(atoi((char *)width) * PagePrintWidth / _htmlBrowserWidth);\n\n    if (height[strlen((char *)height) - 1] == '%')\n      t->height = (float)(atof((char *)height) * PagePrintWidth / 100.0f);\n    else\n      t->height = (float)(atoi((char *)height) * PagePrintWidth / _htmlBrowserWidth);\n\n    return;\n  }\n\n  img = image_find((char *)htmlGetVariable(t, (uchar *)\"REALSRC\"));\n\n  if (img == NULL)\n    return;\n\n  if (width != NULL)\n  {\n    if (width[strlen((char *)width) - 1] == '%')\n      t->width = (float)(atof((char *)width) * PagePrintWidth / 100.0f);\n    else\n      t->width = (float)(atoi((char *)width) * PagePrintWidth / _htmlBrowserWidth);\n\n    t->height = t->width * img->height / img->width;\n  }\n  else if (height != NULL)\n  {\n    if (height[strlen((char *)height) - 1] == '%')\n      t->height = (float)(atof((char *)height) * PagePrintWidth / 100.0f);\n    else\n      t->height = (float)(atoi((char *)height) * PagePrintWidth / _htmlBrowserWidth);\n\n    t->width = t->height * img->width / img->height;\n  }\n  else\n  {\n    t->width  = (float)(img->width * PagePrintWidth / _htmlBrowserWidth);\n    t->height = (float)(img->height * PagePrintWidth / _htmlBrowserWidth);\n  }\n}\n\n\n/*\n * 'get_width()' - Get the width of a string in points.\n */\n\nstatic float\t\t\t/* O - Width in points */\nget_width(uchar *s,\t\t/* I - String to scan */\n          int   typeface,\t/* I - Typeface code */\n          int   style,\t\t/* I - Style code */\n          int   size)\t\t/* I - Size */\n{\n  uchar\t*ptr;\t\t\t/* Current character */\n  int\twidth;\t\t\t/* Current width */\n\n\n  DEBUG_printf((\"get_width(\\\"%s\\\", %d, %d, %d)\\n\",\n                s == NULL ? \"(null)\" : (const char *)s,\n                typeface, style, size));\n\n  if (s == NULL)\n    return (0.0);\n\n  if (!_htmlWidthsLoaded[typeface][style])\n    htmlLoadFontWidths(typeface, style);\n\n  for (width = 0, ptr = s; *ptr != '\\0'; ptr ++)\n    width += _htmlWidths[typeface][style][*ptr];\n\n  return (width * _htmlSizes[size] * 0.001f);\n}\n\n\n/*\n * 'get_title()' - Get the title string for a document.\n */\n\nstatic uchar *\t\t/* O - Title string */\nget_title(tree_t *doc)\t/* I - Document */\n{\n  uchar\t*temp;\n\n\n  while (doc != NULL)\n  {\n    if (doc->markup == MARKUP_TITLE)\n      return (htmlGetText(doc->child));\n    else if (doc->child != NULL)\n      if ((temp = get_title(doc->child)) != NULL)\n        return (temp);\n    doc = doc->next;\n  }\n\n  return (NULL);\n}\n\n\n/*\n * 'open_file()' - Open an output file for the current chapter.\n */\n\nstatic FILE *\t\t/* O - File pointer */\nopen_file(void)\n{\n  char\tfilename[255];\t/* Filename */\n\n\n  if (OutputFiles && PSLevel > 0)\n  {\n    if (chapter == -1)\n      snprintf(filename, sizeof(filename), \"%s/cover.ps\", OutputPath);\n    else if (chapter == 0)\n      snprintf(filename, sizeof(filename), \"%s/contents.ps\", OutputPath);\n    else\n      snprintf(filename, sizeof(filename), \"%s/doc%d.ps\", OutputPath, chapter);\n\n    return (fopen(filename, \"wb+\"));\n  }\n  else if (OutputFiles)\n  {\n    snprintf(filename, sizeof(filename), \"%s/doc.pdf\", OutputPath);\n\n    return (fopen(filename, \"wb+\"));\n  }\n  else if (OutputPath[0] != '\\0')\n    return (fopen(OutputPath, \"wb+\"));\n  else if (PSLevel == 0)\n    return (file_temp(stdout_filename, sizeof(stdout_filename)));\n  else\n    return (stdout);\n}\n\n\n/*\n * 'set_color()' - Set the current text color...\n */\n\nstatic void\nset_color(FILE  *out,\t/* I - File to write to */\n          float *rgb)\t/* I - RGB color */\n{\n  if (rgb[0] == render_rgb[0] &&\n      rgb[1] == render_rgb[1] &&\n      rgb[2] == render_rgb[2])\n    return;\n\n  render_rgb[0] = rgb[0];\n  render_rgb[1] = rgb[1];\n  render_rgb[2] = rgb[2];\n\n  if (OutputColor)\n  {\n    // Output RGB color...\n    if (PSLevel > 0)\n      fprintf(out, \"%.2f %.2f %.2f C \", rgb[0], rgb[1], rgb[2]);\n    else\n      flate_printf(out, \"%.2f %.2f %.2f rg \", rgb[0], rgb[1], rgb[2]);\n  }\n  else\n  {\n    // Output grayscale...\n    if (PSLevel > 0)\n      fprintf(out, \"%.2f G \",\n              rgb[0] * 0.31f + rgb[1] * 0.61f + rgb[2] * 0.08f);\n    else\n      flate_printf(out, \"%.2f g \",\n                   rgb[0] * 0.31f + rgb[1] * 0.61f + rgb[2] * 0.08f);\n  }\n}\n\n\n/*\n * 'set_font()' - Set the current text font.\n */\n\nstatic void\nset_font(FILE  *out,\t\t\t/* I - File to write to */\n         int   typeface,\t\t/* I - Typeface code */\n         int   style,\t\t\t/* I - Style code */\n         float size)\t\t\t/* I - Size */\n{\n  char\tsizes[255],\t/* Formatted string for size... */\n\t*s;\t\t/* Pointer to end of string */\n\n\n  if (typeface == render_typeface &&\n      style == render_style &&\n      size == render_size)\n    return;\n\n /*\n  * Format size and strip trailing 0's and decimals...\n  */\n\n  snprintf(sizes, sizeof(sizes), \"%.1f\", size);\n\n  for (s = sizes + strlen(sizes) - 1; s > sizes && *s == '0'; s --)\n    *s = '\\0';\n\n  if (*s == '.')\n    *s = '\\0';\n\n /*\n  * Set the new typeface, style, and size.\n  */\n\n  if (PSLevel > 0)\n  {\n    if (size != render_size)\n      fprintf(out, \"%s FS\", sizes);\n\n    fprintf(out, \"/F%x SF \", typeface * 4 + style);\n  }\n  else\n    flate_printf(out, \"/F%x %s Tf \", typeface * 4 + style, sizes);\n\n  render_typeface = typeface;\n  render_style    = style;\n  render_size     = size;\n}\n\n\n/*\n * 'set_pos()' - Set the current text position.\n */\n\nstatic void\nset_pos(FILE  *out,\t\t\t/* I - File to write to */\n        float x,\t\t\t/* I - X position */\n        float y)\t\t\t/* I - Y position */\n{\n  char\txs[255],\t\t\t/* Formatted string for X... */\n\tys[255],\t\t\t/* Formatted string for Y... */\n\t*s;\t\t\t\t/* Pointer to end of string */\n\n\n  if (fabs(render_x - x) < 0.1 && fabs(render_y - y) < 0.1)\n    return;\n\n /*\n  * Format X and Y...\n  */\n\n  if (PSLevel > 0 || render_x == -1.0)\n  {\n    snprintf(xs, sizeof(xs), \"%.3f\", x);\n    snprintf(ys, sizeof(ys), \"%.3f\", y);\n  }\n  else\n  {\n    snprintf(xs, sizeof(xs), \"%.3f\", x - render_startx);\n    snprintf(ys, sizeof(ys), \"%.3f\", y - render_y);\n  }\n\n /*\n  * Strip trailing 0's and decimals...\n  */\n\n  for (s = xs + strlen(xs) - 1; s > xs && *s == '0'; s --)\n    *s = '\\0';\n\n  if (*s == '.')\n    *s = '\\0';\n\n  for (s = ys + strlen(ys) - 1; s > ys && *s == '0'; s --)\n    *s = '\\0';\n\n  if (*s == '.')\n    *s = '\\0';\n\n  if (PSLevel > 0)\n    fprintf(out, \"%s %s M\", xs, ys);\n  else\n    flate_printf(out, \"%s %s Td\", xs, ys);\n\n  render_x = render_startx = x;\n  render_y = y;\n}\n\n\n/*\n * 'ps_hex()' - Print binary data as a series of hexadecimal numbers.\n */\n\nstatic void\nps_hex(FILE  *out,\t\t\t/* I - File to print to */\n       uchar *data,\t\t\t/* I - Data to print */\n       int   length)\t\t\t/* I - Number of bytes to print */\n{\n  int\t\tcol;\n  static const char *hex = \"0123456789ABCDEF\";\n\n\n  col = 0;\n  while (length > 0)\n  {\n   /*\n    * Put the hex uchars out to the file; note that we don't use fprintf()\n    * for speed reasons...\n    */\n\n    putc(hex[*data >> 4], out);\n    putc(hex[*data & 15], out);\n\n    data ++;\n    length --;\n\n    col = (col + 1) % 40;\n    if (col == 0)\n      putc('\\n', out);\n  }\n\n  if (col > 0)\n    putc('\\n', out);\n}\n\n\n\n#ifdef HTMLDOC_ASCII85\n/*\n * 'ps_ascii85()' - Print binary data as a series of base-85 numbers.\n */\n\nstatic void\nps_ascii85(FILE  *out,\t\t\t/* I - File to print to */\n\t   uchar *data,\t\t\t/* I - Data to print */\n\t   int   length,\t\t/* I - Number of bytes to print */\n\t   int   eod)\t\t\t/* I - 1 = end-of-data */\n{\n  unsigned\tb = 0;\t\t\t/* Current 32-bit word */\n  uchar\t\tc[5];\t\t\t/* Base-85 encoded characters */\n  static int\tcol = 0;\t\t/* Column */\n  static uchar\tleftdata[4];\t\t/* Leftover data at the end */\n  static int\tleftcount = 0;\t\t/* Size of leftover data */\n\n\n  length += leftcount;\n\n  while (length > 3)\n  {\n    switch (leftcount)\n    {\n      case 0 :\n          b = (unsigned)((((((data[0] << 8) | data[1]) << 8) | data[2]) << 8) | data[3]);\n\t  break;\n      case 1 :\n          b = (unsigned)((((((leftdata[0] << 8) | data[0]) << 8) | data[1]) << 8) | data[2]);\n\t  break;\n      case 2 :\n          b = (unsigned)((((((leftdata[0] << 8) | leftdata[1]) << 8) | data[0]) << 8) | data[1]);\n\t  break;\n      case 3 :\n          b = (unsigned)((((((leftdata[0] << 8) | leftdata[1]) << 8) | leftdata[2]) << 8) | data[0]);\n\t  break;\n    }\n\n    if (col >= 76)\n    {\n      col = 0;\n      putc('\\n', out);\n    }\n\n    if (b == 0)\n    {\n      putc('z', out);\n      col ++;\n    }\n    else\n    {\n      c[4] = (b % 85) + '!';\n      b /= 85;\n      c[3] = (b % 85) + '!';\n      b /= 85;\n      c[2] = (b % 85) + '!';\n      b /= 85;\n      c[1] = (b % 85) + '!';\n      b /= 85;\n      c[0] = (uchar)(b + '!');\n\n      fwrite(c, 1, 5, out);\n      col += 5;\n    }\n\n    data      += 4 - leftcount;\n    length    -= 4 - leftcount;\n    leftcount = 0;\n  }\n\n  if (length > 0)\n  {\n    // Copy any remainder into the leftdata array...\n    if ((length - leftcount) > 0)\n      memcpy(leftdata + leftcount, data, (size_t)(length - leftcount));\n\n    memset(leftdata + length, 0, (size_t)(4 - length));\n\n    leftcount = length;\n  }\n\n  if (eod)\n  {\n    // Do the end-of-data dance...\n    if (col >= 76)\n    {\n      col = 0;\n      putc('\\n', out);\n    }\n\n    if (leftcount > 0)\n    {\n      // Write the remaining bytes as needed...\n      b = (unsigned)((((((leftdata[0] << 8) | leftdata[1]) << 8) | leftdata[2]) << 8) | leftdata[3]);\n\n      c[4] = (b % 85) + '!';\n      b /= 85;\n      c[3] = (b % 85) + '!';\n      b /= 85;\n      c[2] = (b % 85) + '!';\n      b /= 85;\n      c[1] = (b % 85) + '!';\n      b /= 85;\n      c[0] = (uchar)(b + '!');\n\n      fwrite(c, (size_t)(leftcount + 1), 1, out);\n\n      leftcount = 0;\n    }\n\n    fputs(\"~>\\n\", out);\n    col = 0;\n  }\n}\n#endif // HTMLDOC_ASCII85\n\n\n/*\n * JPEG library destination data manager.  These routines direct\n * compressed data from libjpeg into the PDF or PostScript file.\n */\n\nstatic FILE\t\t\t*jpg_file;\t/* JPEG file */\nstatic uchar\t\t\tjpg_buf[8192];\t/* JPEG buffer */\nstatic jpeg_destination_mgr\tjpg_dest;\t/* JPEG destination manager */\nstatic struct jpeg_error_mgr\tjerr;\t\t/* JPEG error handler */\n\n\n/*\n * 'jpg_init()' - Initialize the JPEG destination.\n */\n\nstatic void\njpg_init(j_compress_ptr cinfo)\t\t/* I - Compressor info */\n{\n  (void)cinfo;\n\n  jpg_dest.next_output_byte = jpg_buf;\n  jpg_dest.free_in_buffer   = sizeof(jpg_buf);\n}\n\n\n/*\n * 'jpg_empty()' - Empty the JPEG output buffer.\n */\n\nstatic boolean\t\t\t\t/* O - True if buffer written OK */\njpg_empty(j_compress_ptr cinfo)\t\t/* I - Compressor info */\n{\n  (void)cinfo;\n\n  if (PSLevel > 0)\n#ifdef HTMLDOC_ASCII85\n    ps_ascii85(jpg_file, jpg_buf, sizeof(jpg_buf));\n#else\n    ps_hex(jpg_file, jpg_buf, sizeof(jpg_buf));\n#endif // HTMLDOC_ASCII85\n  else\n    flate_write(jpg_file, jpg_buf, sizeof(jpg_buf));\n\n  jpg_dest.next_output_byte = jpg_buf;\n  jpg_dest.free_in_buffer   = sizeof(jpg_buf);\n\n  return (TRUE);\n}\n\n\n/*\n * 'jpg_term()' - Write the last JPEG data to the file.\n */\n\nstatic void\njpg_term(j_compress_ptr cinfo)\t\t/* I - Compressor info */\n{\n  int nbytes;\t\t\t\t/* Number of bytes to write */\n\n\n  (void)cinfo;\n\n  nbytes = sizeof(jpg_buf) - jpg_dest.free_in_buffer;\n\n  if (PSLevel > 0)\n#ifdef HTMLDOC_ASCII85\n    ps_ascii85(jpg_file, jpg_buf, nbytes);\n#else\n    ps_hex(jpg_file, jpg_buf, nbytes);\n#endif // HTMLDOC_ASCII85\n  else\n    flate_write(jpg_file, jpg_buf, nbytes);\n}\n\n\n/*\n * 'jpg_setup()' - Setup the JPEG compressor for writing an image.\n */\n\nstatic void\njpg_setup(FILE           *out,\t/* I - Output file */\n          image_t        *img,\t/* I - Output image */\n          j_compress_ptr cinfo)\t/* I - Compressor info */\n{\n  int\ti;\t\t\t// Looping var\n\n\n  jpg_file    = out;\n  cinfo->err  = jpeg_std_error(&jerr);\n\n  jpeg_create_compress(cinfo);\n\n  cinfo->dest = &jpg_dest;\n  jpg_dest.init_destination    = jpg_init;\n  jpg_dest.empty_output_buffer = jpg_empty;\n  jpg_dest.term_destination    = jpg_term;\n\n  cinfo->image_width      = (JDIMENSION)img->width;\n  cinfo->image_height     = (JDIMENSION)img->height;\n  cinfo->input_components = img->depth;\n  cinfo->in_color_space   = img->depth == 1 ? JCS_GRAYSCALE : JCS_RGB;\n\n  jpeg_set_defaults(cinfo);\n  jpeg_set_quality(cinfo, OutputJPEG, TRUE);\n\n  // Update things when writing to PS files...\n  if (PSLevel)\n  {\n    // Adobe uses sampling == 1\n    for (i = 0; i < img->depth; i ++)\n    {\n      cinfo->comp_info[i].h_samp_factor = 1;\n      cinfo->comp_info[i].v_samp_factor = 1;\n    }\n  }\n\n  cinfo->write_JFIF_header  = FALSE;\n  cinfo->write_Adobe_marker = TRUE;\n\n  jpeg_start_compress(cinfo, TRUE);\n}\n\n\n/*\n * 'compare_rgb()' - Compare two RGB colors...\n */\n\nstatic int\t\t\t\t/* O - -1 if rgb1<rgb2, etc. */\ncompare_rgb(unsigned *rgb1,\t\t/* I - First color */\n            unsigned *rgb2)\t\t/* I - Second color */\n{\n  return ((int)*rgb1 - (int)*rgb2);\n}\n\n\n/*\n * 'write_image()' - Write an image to the given output file...\n */\n\nstatic void\nwrite_image(FILE     *out,\t\t/* I - Output file */\n            render_t *r,\t\t/* I - Image to write */\n\t    int      write_obj)\t\t/* I - Write an object? */\n{\n  int\t\ti, j, k, m,\t\t/* Looping vars */\n\t\tncolors;\t\t/* Number of colors */\n  uchar\t\t*pixel,\t\t\t/* Current pixel */\n\t\t*indices,\t\t/* New indexed pixel array */\n\t\t*indptr;\t\t/* Current index */\n  int\t\tindwidth,\t\t/* Width of indexed line */\n\t\tindbits;\t\t/* Bits per index */\n  int\t\tmax_colors;\t\t/* Max colors to use */\n  unsigned\tcolors[256],\t\t/* Colormap values */\n\t\tkey,\t\t\t/* Color key */\n\t\t*match;\t\t\t/* Matching color value */\n  uchar\t\tgrays[256],\t\t/* Grayscale usage */\n\t\tcmap[256][3];\t\t/* Colormap */\n  image_t \t*img;\t\t\t/* Image */\n  struct jpeg_compress_struct cinfo;\t/* JPEG compressor */\n  uchar\t\t*data,\t\t\t/* PS Level 3 image data */\n\t\t*dataptr,\t\t/* Pointer into image data */\n\t\t*maskptr;\t\t/* Pointer into mask data */\n\n\n /*\n  * See if we can optimize the image as indexed without color loss...\n  */\n\n  img      = r->data.image;\n  ncolors  = 0;\n  indices  = NULL;\n  indwidth = 0;\n\n  if (!img->pixels && !img->obj)\n    image_load(img->filename, !OutputColor, 1);\n\n  // Note: Acrobat 6 tries to decrypt the colormap of indexed in-line images twice, which\n  //       is 1) not consistent with prior Acrobat releases and 2) in violation of their\n  //       PDF spec.  The \"img->use > 1 || !Encryption\" test prevents the use of indexed\n  //       in-line images when encryption is enabled.\n  //\n  //       We are filing a bug on this with Adobe, but if history is any indicator, we are\n  //       stuck with this workaround forever...\n  if (PSLevel != 1 && PDFVersion >= 12 && img->obj == 0 && (img->use > 1 || !Encryption))\n  {\n    if (img->depth == 1)\n    {\n     /*\n      * Greyscale image...\n      */\n\n      memset(grays, 0, sizeof(grays));\n\n      for (i = img->width * img->height, pixel = img->pixels;\n\t   i > 0;\n\t   i --, pixel ++)\n\tif (!grays[*pixel])\n\t{\n          if (ncolors >= 16)\n\t    break;\n\n\t  grays[*pixel] = 1;\n\t  ncolors ++;\n\t}\n\n      if (i == 0)\n      {\n\tfor (i = 0, j = 0; i < 256; i ++)\n\t  if (grays[i])\n\t  {\n\t    colors[j] = (unsigned)((((i << 8) | i) << 8) | i);\n\t    grays[i]  = (uchar)j;\n\t    j ++;\n\t  }\n      }\n      else\n        ncolors = 0;\n    }\n    else\n    {\n     /*\n      * Color image...\n      */\n\n      if (OutputJPEG && !Compression)\n        max_colors = 16;\n      else\n        max_colors = 256;\n\n      for (i = img->width * img->height, pixel = img->pixels, match = NULL;\n\t   i > 0;\n\t   i --, pixel += 3)\n      {\n        key = (unsigned)((((pixel[0] << 8) | pixel[1]) << 8) | pixel[2]);\n\n\tif (!match || *match != key)\n\t{\n          if (ncolors > 0)\n            match = (unsigned *)bsearch(&key, colors, (size_t)ncolors, sizeof(unsigned), (compare_func_t)compare_rgb);\n          else\n            match = NULL;\n        }\n\n        if (match == NULL)\n        {\n          if (ncolors >= max_colors)\n            break;\n\n          colors[ncolors] = key;\n          ncolors ++;\n\n          if (ncolors > 1)\n            qsort(colors, (size_t)ncolors, sizeof(unsigned), (compare_func_t)compare_rgb);\n        }\n      }\n\n      if (i > 0)\n        ncolors = 0;\n    }\n  }\n\n  if (ncolors > 0)\n  {\n    if (PSLevel == 3 && img->mask)\n      indbits = 8;\n    else if (ncolors <= 2)\n      indbits = 1;\n    else if (ncolors <= 4)\n      indbits = 2;\n    else if (ncolors <= 16)\n      indbits = 4;\n    else\n      indbits = 8;\n\n    indwidth = (img->width * indbits + 7) / 8;\n    indices  = (uchar *)calloc((size_t)indwidth, (size_t)(img->height + 1));\n\t\t\t\t\t// height + 1 for PS odd-row-count bug\n\n    if (img->depth == 1)\n    {\n     /*\n      * Convert a grayscale image...\n      */\n\n      switch (indbits)\n      {\n        case 1 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width, k = 7; j > 0; j --, k = (k + 7) & 7, pixel ++)\n\t\tswitch (k)\n\t\t{\n\t\t  case 7 :\n\t              *indptr = (uchar)(grays[*pixel] << 7);\n\t\t      break;\n\t\t  default :\n\t              *indptr |= (uchar)(grays[*pixel] << k);\n\t\t      break;\n\t\t  case 0 :\n\t              *indptr++ |= (uchar)grays[*pixel];\n\t\t      break;\n        \t}\n\n\t      if (k != 7)\n\t\tindptr ++;\n\t    }\n\t    break;\n\n        case 2 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width, k = 0; j > 0; j --, k = (k + 1) & 3, pixel ++)\n\t\tswitch (k)\n\t\t{\n\t\t  case 0 :\n\t              *indptr = (uchar)(grays[*pixel] << 6);\n\t\t      break;\n\t\t  case 1 :\n\t              *indptr |= (uchar)(grays[*pixel] << 4);\n\t\t      break;\n\t\t  case 2 :\n\t              *indptr |= (uchar)(grays[*pixel] << 2);\n\t\t      break;\n\t\t  case 3 :\n\t              *indptr++ |= (uchar)grays[*pixel];\n\t\t      break;\n        \t}\n\n\t      if (k)\n\t\tindptr ++;\n\t    }\n\t    break;\n\n        case 4 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width, k = 0; j > 0; j --, k ^= 1, pixel ++)\n\t\tif (k)\n\t\t  *indptr++ |= grays[*pixel];\n\t\telse\n\t\t  *indptr = (uchar)(grays[*pixel] << 4);\n\n\t      if (k)\n\t\tindptr ++;\n\t    }\n\t    break;\n      }\n    }\n    else\n    {\n     /*\n      * Convert a color image...\n      */\n\n      switch (indbits)\n      {\n        case 1 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices,\n\t             match = colors;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width, k = 7;\n\t           j > 0;\n\t\t   j --, k = (k + 7) & 7, pixel += 3)\n\t      {\n                key = (unsigned)((((pixel[0] << 8) | pixel[1]) << 8) | pixel[2]);\n\n\t\tif (*match != key)\n        \t  match = (unsigned *)bsearch(&key, colors, (size_t)ncolors, sizeof(unsigned), (compare_func_t)compare_rgb);\n\t        m = match - colors;\n\n\t\tswitch (k)\n\t\t{\n\t\t  case 7 :\n\t              *indptr = (uchar)(m << 7);\n\t\t      break;\n\t\t  default :\n\t              *indptr |= (uchar)(m << k);\n\t\t      break;\n\t\t  case 0 :\n\t              *indptr++ |= (uchar)m;\n\t\t      break;\n        \t}\n\t      }\n\n\t      if (k != 7)\n\t        indptr ++;\n\t    }\n\t    break;\n\n        case 2 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices,\n\t             match = colors;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width, k = 0;\n\t           j > 0;\n\t\t   j --, k = (k + 1) & 3, pixel += 3)\n\t      {\n                key = (unsigned)((((pixel[0] << 8) | pixel[1]) << 8) | pixel[2]);\n\n\t\tif (*match != key)\n        \t  match = (unsigned *)bsearch(&key, colors, (size_t)ncolors, sizeof(unsigned), (compare_func_t)compare_rgb);\n\t        m = match - colors;\n\n\t\tswitch (k)\n\t\t{\n\t\t  case 0 :\n\t              *indptr = (uchar)(m << 6);\n\t\t      break;\n\t\t  case 1 :\n\t              *indptr |= (uchar)(m << 4);\n\t\t      break;\n\t\t  case 2 :\n\t              *indptr |= (uchar)(m << 2);\n\t\t      break;\n\t\t  case 3 :\n\t              *indptr++ |= (uchar)m;\n\t\t      break;\n        \t}\n\t      }\n\n\t      if (k)\n\t        indptr ++;\n\t    }\n\t    break;\n\n        case 4 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices,\n\t             match = colors;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width, k = 0; j > 0; j --, k ^= 1, pixel += 3)\n\t      {\n                key = (unsigned)((((pixel[0] << 8) | pixel[1]) << 8) | pixel[2]);\n\n\t\tif (*match != key)\n        \t  match = (unsigned *)bsearch(&key, colors, (size_t)ncolors, sizeof(unsigned), (compare_func_t)compare_rgb);\n\t        m = match - colors;\n\n\t\tif (k)\n\t\t  *indptr++ |= (uchar)m;\n\t\telse\n\t\t  *indptr = (uchar)(m << 4);\n\t      }\n\n\t      if (k)\n\t        indptr ++;\n\t    }\n\t    break;\n\n        case 8 :\n\t    for (i = img->height, pixel = img->pixels, indptr = indices,\n\t             match = colors;\n\t\t i > 0;\n\t\t i --)\n\t    {\n\t      for (j = img->width; j > 0; j --, pixel += 3, indptr ++)\n\t      {\n                key = (unsigned)((((pixel[0] << 8) | pixel[1]) << 8) | pixel[2]);\n\n\t\tif (*match != key)\n        \t  match = (unsigned *)bsearch(&key, colors, (size_t)ncolors, sizeof(unsigned), (compare_func_t)compare_rgb);\n\t        *indptr = (uchar)(match - colors);\n\t      }\n\t    }\n\t    break;\n      }\n    }\n  }\n  else\n    indbits = 8;\n\n  if (ncolors == 1)\n  {\n   /*\n    * Adobe doesn't like 1 color images...\n    */\n\n    ncolors   = 2;\n    colors[1] = 0;\n  }\n\n /*\n  * Now write the image...\n  */\n\n  switch (PSLevel)\n  {\n    case 0 : /* PDF */\n        if (!write_obj)\n\t  flate_printf(out, \"q %.1f 0 0 %.1f %.1f %.1f cm\\n\", r->width, r->height,\n\t               r->x, r->y);\n\n        if (img->obj)\n\t{\n\t  if (img->mask && PDFVersion < 13)\n\t    write_imagemask(out, r);\n\n\t  flate_printf(out, \"/I%d Do Q\\n\", img->obj);\n\t  break;\n\t}\n\n        if (img->mask && write_obj && PDFVersion >= 13)\n\t{\n\t  // We have a mask image, write it!\n          pdf_start_object(out);\n\t  fputs(\"/Type/XObject/Subtype/Image\", out);\n          fputs(\"/ColorSpace/DeviceGray\", out);\n\t  if (img->maskscale == 8)\n\t    fprintf(out, \"/Width %d/Height %d/BitsPerComponent 8\",\n\t            img->width, img->height);\n          else\n\t    fprintf(out, \"/Width %d/Height %d/BitsPerComponent 1/ImageMask true\",\n\t            img->width * img->maskscale, img->height * img->maskscale);\n          if (Compression)\n            fputs(\"/Filter/FlateDecode\", out);\n\n          pdf_start_stream(out);\n          flate_open_stream(out);\n\t  if (img->maskscale == 8)\n  \t    flate_write(out, img->mask, img->width * img->height);\n\t  else\n  \t    flate_write(out, img->mask,\n\t                img->maskwidth * img->height * img->maskscale);\n\t  flate_close_stream(out);\n\n          pdf_end_object(out);\n\t}\n\n        if (write_obj)\n\t{\n\t  // Write an image object...\n\t  img->obj = pdf_start_object(out);\n\n\t  fputs(\"/Type/XObject/Subtype/Image\", out);\n\t  if (img->mask && PDFVersion >= 13)\n\t  {\n\t    if (img->maskscale == 8)\n\t      fprintf(out, \"/SMask %d 0 R\", img->obj - 1);\n\t    else\n\t      fprintf(out, \"/Mask %d 0 R\", img->obj - 1);\n\t  }\n\n\t  if (ncolors > 0)\n\t  {\n\t    for (i = 0; i < ncolors; i ++)\n\t    {\n\t      cmap[i][0] = (uchar)(colors[i] >> 16);\n\t      cmap[i][1] = (uchar)(colors[i] >> 8);\n\t      cmap[i][2] = (uchar)colors[i];\n\t    }\n\n\t    if (Encryption)\n\t    {\n\t      // Encrypt the colormap...\n\t      encrypt_init();\n\t      rc4_encrypt(&encrypt_state, cmap[0], cmap[0], (unsigned)(ncolors * 3));\n\t    }\n\n\t    fprintf(out, \"/ColorSpace[/Indexed/DeviceRGB %d<\", ncolors - 1);\n\t    for (i = 0; i < ncolors; i ++)\n\t      fprintf(out, \"%02X%02X%02X\", cmap[i][0], cmap[i][1],\n\t              cmap[i][2]);\n\t    fputs(\">]\", out);\n          }\n\t  else if (img->depth == 1)\n            fputs(\"/ColorSpace/DeviceGray\", out);\n          else\n            fputs(\"/ColorSpace/DeviceRGB\", out);\n\n#ifdef HTMLDOC_INTERPOLATION\n          if (ncolors != 2)\n            fputs(\"/Interpolate true\", out);\n#endif // HTMLDOC_INTERPOLATION\n\n          if (Compression && (ncolors || !OutputJPEG))\n            fputs(\"/Filter/FlateDecode\", out);\n\t  else if (OutputJPEG && ncolors == 0)\n\t  {\n\t    if (Compression)\n\t      fputs(\"/Filter[/FlateDecode/DCTDecode]\", out);\n\t    else\n\t      fputs(\"/Filter/DCTDecode\", out);\n\t  }\n\n  \t  fprintf(out, \"/Width %d/Height %d/BitsPerComponent %d\",\n\t          img->width, img->height, indbits);\n          pdf_start_stream(out);\n          flate_open_stream(out);\n\n          if (OutputJPEG && ncolors == 0)\n\t  {\n\t    jpg_setup(out, img, &cinfo);\n\n\t    for (i = img->height, pixel = img->pixels;\n\t         i > 0;\n\t         i --, pixel += img->width * img->depth)\n\t      jpeg_write_scanlines(&cinfo, &pixel, 1);\n\n\t    jpeg_finish_compress(&cinfo);\n\t    jpeg_destroy_compress(&cinfo);\n\t  }\n          else\n\t  {\n\t    if (ncolors > 0)\n   \t      flate_write(out, indices, indwidth * img->height);\n\t    else\n  \t      flate_write(out, img->pixels,\n\t                  img->width * img->height * img->depth);\n          }\n\n          flate_close_stream(out);\n          pdf_end_object(out);\n\t}\n\telse\n\t{\n\t  // Put the image in-line...\n          flate_puts(\"BI\", out);\n\n\t  if (ncolors > 0)\n\t  {\n\t    flate_printf(out, \"/CS[/I/RGB %d<\", ncolors - 1);\n\t    for (i = 0; i < ncolors; i ++)\n\t      flate_printf(out, \"%02X%02X%02X\", colors[i] >> 16,\n\t        \t   (colors[i] >> 8) & 255, colors[i] & 255);\n\t    flate_puts(\">]\", out);\n          }\n\t  else if (img->depth == 1)\n            flate_puts(\"/CS/G\", out);\n          else\n            flate_puts(\"/CS/RGB\", out);\n\n          if (ncolors != 2)\n            flate_puts(\"/I true\", out);\n\n  \t  flate_printf(out, \"/W %d/H %d/BPC %d\", img->width, img->height, indbits);\n\n\t  if (ncolors > 0)\n\t  {\n  \t    flate_puts(\" ID\\n\", out);\n  \t    flate_write(out, indices, indwidth * img->height, 1);\n\t  }\n\t  else if (OutputJPEG)\n\t  {\n  \t    flate_puts(\"/F/DCT ID\\n\", out);\n\n\t    jpg_setup(out, img, &cinfo);\n\n\t    for (i = img->height, pixel = img->pixels;\n\t         i > 0;\n\t         i --, pixel += img->width * img->depth)\n\t      jpeg_write_scanlines(&cinfo, &pixel, 1);\n\n\t    jpeg_finish_compress(&cinfo);\n\t    jpeg_destroy_compress(&cinfo);\n          }\n\t  else\n\t  {\n  \t    flate_puts(\" ID\\n\", out);\n  \t    flate_write(out, img->pixels, img->width * img->height * img->depth, 1);\n          }\n\n\t  flate_write(out, (uchar *)\"\\nEI\\nQ\\n\", 6, 1);\n\t}\n        break;\n\n    case 1 : /* PostScript, Level 1 */\n        fputs(\"GS\", out);\n\tfprintf(out, \"[%.1f 0 0 %.1f %.1f %.1f]CM\", r->width, r->height,\n\t        r->x, r->y);\n\n\tif (img->mask)\n\t  write_imagemask(out, r);\n\n\tfprintf(out, \"/picture %d string def\\n\", img->width * img->depth);\n\n\tif (img->depth == 1)\n\t  fprintf(out, \"%d %d 8 [%d 0 0 %d 0 %d] {currentfile picture readhexstring pop} image\\n\",\n        \t  img->width, img->height,\n        \t  img->width, -img->height,\n        \t  img->height);\n\telse\n\t  fprintf(out, \"%d %d 8 [%d 0 0 %d 0 %d] {currentfile picture readhexstring pop} false 3 colorimage\\n\",\n        \t  img->width, img->height,\n        \t  img->width, -img->height,\n        \t  img->height);\n\n\tps_hex(out, img->pixels, img->width * img->height * img->depth);\n\n\tfputs(\"GR\\n\", out);\n        break;\n    case 3 : /* PostScript, Level 3 */\n        // Fallthrough to Level 2 output if compression is disabled and\n\t// we aren't doing transparency...\n        if ((Compression && (!OutputJPEG || ncolors > 0)) ||\n\t    (img->mask && img->maskscale == 8))\n\t{\n          fputs(\"GS\", out);\n\t  fprintf(out, \"[%.1f 0 0 %.1f %.1f %.1f]CM\", r->width, r->height,\n\t          r->x, r->y);\n\n\t  if (img->mask && img->maskscale != 8)\n\t    write_imagemask(out, r);\n\n          if (ncolors > 0)\n          {\n\t    if (ncolors <= 2)\n\t      ncolors = 2; /* Adobe doesn't like 1 color images... */\n\n\t    fprintf(out, \"[/Indexed/DeviceRGB %d\\n<\", ncolors - 1);\n\t    for (i = 0; i < ncolors; i ++)\n\t    {\n\t      fprintf(out, \"%02X%02X%02X\", colors[i] >> 16,\n\t              (colors[i] >> 8) & 255, colors[i] & 255);\n\t      if ((i % 13) == 12)\n\t        putc('\\n', out);\n            }\n\t    fputs(\">]setcolorspace\\n\", out);\n\n\t    if (img->mask && img->maskscale == 8)\n\t      fprintf(out, \"<<\"\n\t                   \"/ImageType 3\"\n\t\t\t   \"/InterleaveType 1\"\n\t\t\t   \"/MaskDict<<\"\n\t                   \"/ImageType 1\"\n\t                   \"/Width %d\"\n\t                   \"/Height %d\"\n\t                   \"/BitsPerComponent 8\"\n\t                   \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t\t\t   \"/Decode[0 1]\"\n\t                   \">>\\n\"\n\t\t\t   \"/DataDict\",\n\t            img->width, img->height,\n        \t    img->width, -img->height, img->height);\n\n\t    fprintf(out, \"<<\"\n\t                 \"/ImageType 1\"\n\t                 \"/Width %d\"\n\t                 \"/Height %d\"\n\t                 \"/BitsPerComponent %d\"\n\t                 \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t                 \"/Decode[0 %d]\",\n\t            img->width, img->height, indbits,\n        \t    img->width, -img->height, img->height,\n        \t    (1 << indbits) - 1);\n\n#ifdef HTMLDOC_INTERPOLATION\n            if (ncolors != 2)\n\t      fputs(\"/Interpolate true\", out);\n#endif // HTMLDOC_INTERPOLATION\n\n#ifdef HTMLDOC_ASCII85\n            fputs(\"/DataSource currentfile/ASCII85Decode filter\", out);\n#else\n            fputs(\"/DataSource currentfile/ASCIIHexDecode filter\", out);\n#endif // HTMLDOC_ASCII85\n\n            if (Compression)\n\t      fputs(\"/FlateDecode filter\", out);\n\n\t    fputs(\">>\\n\", out);\n\n\t    if (img->mask && img->maskscale == 8)\n\t      fputs(\">>\\n\", out);\n\n\t    fputs(\"image\\n\", out);\n\n            flate_open_stream(out);\n\n\t    if (img->mask && img->maskscale == 8)\n\t    {\n\t      data = (uchar *)malloc((size_t)(img->width * 2));\n\n\t      for (i = 0, maskptr = img->mask, indptr = indices;\n\t           i < img->height;\n\t\t   i ++)\n\t      {\n\t        for (j = img->width, dataptr = data; j > 0; j --)\n\t\t{\n\t\t  *dataptr++ = *maskptr++;\n\t\t  *dataptr++ = *indptr++;\n\t\t}\n\n\t\tflate_write(out, data, img->width * 2);\n\t      }\n\n\t      free(data);\n\t    }\n\t    else\n\t      flate_write(out, indices, indwidth * img->height);\n\n\t    flate_close_stream(out);\n          }\n          else\n          {\n\t    if (img->depth == 1)\n\t      fputs(\"/DeviceGray setcolorspace\", out);\n\t    else\n\t      fputs(\"/DeviceRGB setcolorspace\", out);\n\n\t    if (img->mask && img->maskscale == 8)\n\t      fprintf(out, \"<<\"\n\t                   \"/ImageType 3\"\n\t\t\t   \"/InterleaveType 1\"\n\t\t\t   \"/MaskDict<<\"\n\t                   \"/ImageType 1\"\n\t                   \"/Width %d\"\n\t                   \"/Height %d\"\n\t                   \"/BitsPerComponent 8\"\n\t                   \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t\t\t   \"/Decode[0 1]\"\n\t                   \">>\\n\"\n\t\t\t   \"/DataDict\",\n\t            img->width, img->height,\n        \t    img->width, -img->height, img->height);\n\n\t    fprintf(out, \"<<\"\n\t                 \"/ImageType 1\"\n\t                 \"/Width %d\"\n\t                 \"/Height %d\"\n\t                 \"/BitsPerComponent 8\"\n\t                 \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t                 \"/Decode[%s]\",\n\t            img->width, img->height,\n        \t    img->width, -img->height, img->height,\n        \t    img->depth == 1 ? \"0 1\" : \"0 1 0 1 0 1\");\n\n#ifdef HTMLDOC_INTERPOLATION\n\t    fputs(\"/Interpolate true\", out);\n#endif // HTMLDOC_INTERPOLATION\n\n#ifdef HTMLDOC_ASCII85\n            fputs(\"/DataSource currentfile/ASCII85Decode filter\", out);\n#else\n            fputs(\"/DataSource currentfile/ASCIIHexDecode filter\", out);\n#endif // HTMLDOC_ASCII85\n\n            if (Compression)\n\t      fputs(\"/FlateDecode filter\", out);\n\n\t    fputs(\">>\\n\", out);\n\n\t    if (img->mask && img->maskscale == 8)\n\t      fputs(\">>\\n\", out);\n\n\t    fputs(\"image\\n\", out);\n\n            flate_open_stream(out);\n\n\t    if (img->mask && img->maskscale == 8)\n\t    {\n\t      data = (uchar *)malloc((size_t)(img->width * (img->depth + 1)));\n\n\t      for (i = 0, maskptr = img->mask, pixel = img->pixels;\n\t           i < img->height;\n\t\t   i ++)\n\t      {\n\t        if (img->depth == 1)\n\t\t{\n\t          for (j = img->width, dataptr = data; j > 0; j --)\n\t\t  {\n\t\t    *dataptr++ = *maskptr++;\n\t\t    *dataptr++ = *pixel++;\n\t\t  }\n\t\t}\n\t\telse\n\t\t{\n\t          for (j = img->width, dataptr = data; j > 0; j --)\n\t\t  {\n\t\t    *dataptr++ = *maskptr++;\n\t\t    *dataptr++ = *pixel++;\n\t\t    *dataptr++ = *pixel++;\n\t\t    *dataptr++ = *pixel++;\n\t\t  }\n\t\t}\n\n\t\tflate_write(out, data, img->width * (img->depth + 1));\n\t      }\n\n\t      free(data);\n\t    }\n\t    else\n\t      flate_write(out, img->pixels,\n\t                  img->width * img->height * img->depth);\n\n\t    flate_close_stream(out);\n          }\n\n\t  fputs(\"GR\\n\", out);\n          break;\n\t}\n\n    case 2 : /* PostScript, Level 2 */\n        fputs(\"GS\", out);\n\tfprintf(out, \"[%.1f 0 0 %.1f %.1f %.1f]CM\", r->width, r->height,\n\t        r->x, r->y);\n\n\tif (img->mask)\n\t  write_imagemask(out, r);\n\n        if (ncolors > 0)\n        {\n\t  fprintf(out, \"[/Indexed/DeviceRGB %d\\n<\", ncolors - 1);\n\t  for (i = 0; i < ncolors; i ++)\n\t  {\n\t    fprintf(out, \"%02X%02X%02X\", colors[i] >> 16,\n\t            (colors[i] >> 8) & 255, colors[i] & 255);\n\t    if ((i % 13) == 12)\n\t      putc('\\n', out);\n          }\n\n\t  fputs(\">]setcolorspace\\n\", out);\n\n\t  fprintf(out, \"<<\"\n\t               \"/ImageType 1\"\n\t               \"/Width %d\"\n\t               \"/Height %d\"\n\t               \"/BitsPerComponent %d\"\n\t               \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t               \"/Decode[0 %d]\",\n\t          img->width, img->height, indbits,\n        \t  img->width, -img->height, img->height,\n        \t  (1 << indbits) - 1);\n\n#ifdef HTMLDOC_INTERPOLATION\n          if (ncolors != 2)\n\t    fputs(\"/Interpolate true\", out);\n#endif // HTMLDOC_INTERPOLATION\n\n#ifdef HTMLDOC_ASCII85\n\t  fputs(\"/DataSource currentfile/ASCII85Decode filter>>image\\n\", out);\n\n          ps_ascii85(out, indices, indwidth * img->height, 1);\n#else\n\t  fputs(\"/DataSource currentfile/ASCIIHexDecode filter>>image\\n\", out);\n\n          ps_hex(out, indices, indwidth * img->height);\n\t  // End of data marker...\n\t  fputs(\">\\n\", out);\n#endif /* HTMLDOC_ASCII85 */\n        }\n\telse if (OutputJPEG)\n\t{\n\t  if (img->depth == 1)\n\t    fputs(\"/DeviceGray setcolorspace\\n\", out);\n\t  else\n\t    fputs(\"/DeviceRGB setcolorspace\\n\", out);\n\n\t  fprintf(out, \"<<\"\n\t               \"/ImageType 1\"\n\t               \"/Width %d\"\n\t               \"/Height %d\"\n\t               \"/BitsPerComponent 8\"\n\t               \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t               \"/Decode[%s]\",\n\t          img->width, img->height,\n        \t  img->width, -img->height, img->height,\n        \t  img->depth == 1 ? \"0 1\" : \"0 1 0 1 0 1\");\n\n#ifdef HTMLDOC_INTERPOLATION\n\t  fputs(\"/Interpolate true\", out);\n#endif // HTMLDOC_INTERPOLATION\n\n#ifdef HTMLDOC_ASCII85\n\t  fputs(\"/DataSource currentfile/ASCII85Decode filter/DCTDecode filter\"\n\t        \">>image\\n\", out);\n#else\n\t  fputs(\"/DataSource currentfile/ASCIIHexDecode filter/DCTDecode filter\"\n\t        \">>image\\n\", out);\n#endif // HTMLDOC_ASCII85\n\n\t  jpg_setup(out, img, &cinfo);\n\n\t  for (i = img->height, pixel = img->pixels;\n\t       i > 0;\n\t       i --, pixel += img->width * img->depth)\n\t    jpeg_write_scanlines(&cinfo, &pixel, 1);\n\n\t  jpeg_finish_compress(&cinfo);\n\t  jpeg_destroy_compress(&cinfo);\n\n#ifdef HTMLDOC_ASCII85\n          ps_ascii85(out, (uchar *)\"\", 0, 1);\n#else\n\t  // End of data marker...\n\t  fputs(\">\\n\", out);\n#endif // HTMLDOC_ASCII85\n        }\n        else\n        {\n\t  if (img->depth == 1)\n\t    fputs(\"/DeviceGray setcolorspace\\n\", out);\n\t  else\n\t    fputs(\"/DeviceRGB setcolorspace\\n\", out);\n\n\t  fprintf(out, \"<<\"\n\t               \"/ImageType 1\"\n\t               \"/Width %d\"\n\t               \"/Height %d\"\n\t               \"/BitsPerComponent 8\"\n\t               \"/ImageMatrix[%d 0 0 %d 0 %d]\"\n\t               \"/Decode[%s]\",\n\t          img->width, img->height,\n        \t  img->width, -img->height, img->height,\n        \t  img->depth == 1 ? \"0 1\" : \"0 1 0 1 0 1\");\n\n#ifdef HTMLDOC_INTERPOLATION\n\t  fputs(\"/Interpolate true\", out);\n#endif // HTMLDOC_INTERPOLATION\n\n#ifdef HTMLDOC_ASCII85\n          fputs(\"/DataSource currentfile/ASCII85Decode filter\"\n\t        \">>image\\n\", out);\n\n\t  ps_ascii85(out, img->pixels, img->width * img->height *\n\t                               img->depth, 1);\n#else\n          fputs(\"/DataSource currentfile/ASCIIHexDecode filter\"\n\t        \">>image\\n\", out);\n\n          ps_hex(out, img->pixels, img->width * img->depth * img->height);\n\t  // End of data marker...\n\t  fputs(\">\\n\", out);\n#endif // HTMLDOC_ASCII85\n        }\n\n\tfputs(\"GR\\n\", out);\n        break;\n  }\n\n  if (ncolors > 0)\n    free(indices);\n\n  image_unload(img);\n}\n\n\n/*\n * 'write_imagemask()' - Write an imagemask to the output file...\n */\n\nstatic void\nwrite_imagemask(FILE     *out,\t\t/* I - Output file */\n                render_t *r)\t\t/* I - Image to write */\n{\n  image_t\t*img;\t\t\t/* Current image */\n  int\t\tx, y;\t\t\t/* Position in mask image */\n  int\t\tstartx, count;\t\t/* Start and count */\n  uchar\t\t*ptr,\t\t\t/* Pointer into mask image */\n\t\tbyte,\t\t\t/* Current byte */\n\t\tbit;\t\t\t/* Current bit */\n  float\t\tscalex, scaley;\t\t/* 1/(w-1) and 1/(h-1) scaling factors */\n  int\t\twidth, height;\t\t/* Scaled width and height */\n\n\n  img    = r->data.image;\n  width  = img->width * img->maskscale;\n  height = img->height * img->maskscale;\n  scalex = 1.0f / width;\n  scaley = 1.0f / height;\n\n  switch (PSLevel)\n  {\n    case 0 : // PDF\n        break;\n\n    default : // PostScript\n        fputs(\"\\nnewpath\\n\", out);\n        break;\n  }\n\n  for (y = 0; y < height; y ++)\n  {\n    for (x = 0, ptr = img->mask + (height - y - 1) * img->maskwidth,\n             bit = 128, byte = *ptr++, startx = 0, count = 0;\n         x < width;\n\t x ++)\n    {\n      if (!(bit & byte))\n      {\n        if (!count)\n\t  startx = x;\n\n        count ++;\n      }\n      else if (count)\n      {\n\tswitch (PSLevel)\n\t{\n\t  case 0 : // PDF\n\t      flate_printf(out, \"%.6f %.6f %.6f %.6f re\\n\",\n\t\t\t   (float)startx * scalex,\n\t\t\t   (float)y * scaley,\n\t\t\t   (float)count * scalex,\n\t\t\t   1.0f * scaley);\n              break;\n\n\t  default : // PostScript\n\t      fprintf(out, \"%.6f %.6f %.6f %.6f re\\n\",\n\t\t      (float)startx * scalex,\n\t\t      (float)y * scaley,\n\t\t      (float)count * scalex,\n\t\t      1.0f * scaley);\n              break;\n\t}\n\n\tcount = 0;\n      }\n\n      if (bit > 1)\n        bit >>= 1;\n      else\n      {\n        bit  = 128;\n\tbyte = *ptr++;\n      }\n    }\n\n    if (count)\n    {\n      switch (PSLevel)\n      {\n\tcase 0 : // PDF\n\t    flate_printf(out, \"%.6f %.6f %.6f %.6f re\\n\",\n\t\t\t (float)startx * scalex,\n\t\t\t (float)y * scaley,\n\t\t\t (float)count * scalex,\n\t\t\t 1.0f * scaley);\n            break;\n\n\tdefault : // PostScript\n\t    fprintf(out, \"%.6f %.6f %.6f %.6f re\\n\",\n\t\t    (float)startx * scalex,\n\t\t    (float)y * scaley,\n\t\t    (float)count * scalex,\n\t\t    1.0f * scaley);\n            break;\n      }\n    }\n  }\n\n  switch (PSLevel)\n  {\n    case 0 : // PDF\n        flate_puts(\"W n\\n\", out);\n        break;\n\n    default : // PostScript\n        fputs(\"clip\\n\", out);\n        break;\n  }\n}\n\n\n/*\n * 'write_prolog()' - Write the file prolog...\n */\n\nstatic void\nwrite_prolog(FILE  *out,\t\t/* I - Output file */\n             int   page_count,\t\t/* I - Number of pages (0 if not known) */\n             uchar *author,\t\t/* I - Author of document */\n             uchar *creator,\t\t/* I - Application that generated the HTML file */\n             uchar *copyright,\t\t/* I - Copyright (if any) on the document */\n             uchar *keywords,\t\t/* I - Search keywords */\n\t     uchar *subject)\t\t/* I - Subject */\n{\n  FILE\t\t*prolog;\t\t/* PostScript prolog file */\n  int\t\ti, j,\t\t\t/* Looping vars */\n\t\tencoding_object;\t/* Font encoding object */\n  int\t\tpage;\t\t\t/* Current page */\n  render_t\t*r;\t\t\t/* Current render data */\n  int\t\tfonts_used[TYPE_MAX][STYLE_MAX];\n\t\t\t\t\t/* Whether or not a font is used */\n  int\t\tfont_desc[TYPE_MAX][STYLE_MAX];\n\t\t\t\t\t/* Font descriptor objects */\n  char\t\ttemp[1024];\t\t/* Temporary string */\n  md5_state_t\tmd5;\t\t\t/* MD5 state */\n  md5_byte_t\tdigest[16];\t\t/* MD5 digest value */\n  rc4_context_t\trc4;\t\t\t/* RC4 context */\n  uchar\t\towner_pad[32],\t\t/* Padded owner password */\n\t\towner_key[32],\t\t/* Owner key */\n\t\tuser_pad[32],\t\t/* Padded user password */\n\t\tuser_key[32];\t\t/* User key */\n  uchar\t\tperm_bytes[4];\t\t/* Permission bytes */\n  unsigned\tperm_value;\t\t/* Permission value, unsigned */\n  static unsigned char pad[32] =\n\t\t{\t\t\t/* Padding for passwords */\n\t\t  0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41,\n\t\t  0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08,\n\t\t  0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80,\n\t\t  0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a\n\t\t};\n\n\n /*\n  * See what fonts are used...\n  */\n\n  memset(fonts_used, 0, sizeof(fonts_used));\n  fonts_used[HeadFootType][HeadFootStyle] = 1;\n\n  for (page = 0; page < (int)num_pages; page ++)\n    for (r = pages[page].start; r != NULL; r = r->next)\n      if (r->type == RENDER_TEXT)\n\tfonts_used[r->data.text.typeface][r->data.text.style] = 1;\n\n#ifdef DEBUG\n  puts(\"The following fonts were used:\");\n  for (i = 0; i < TYPE_MAX; i ++)\n    for (j = 0; j < STYLE_MAX; j ++)\n      if (fonts_used[i][j])\n        printf(\"    %s\\n\", _htmlFonts[i][j]);\n#endif // DEBUG\n\n /*\n  * Generate the heading...\n  */\n\n  if (PSLevel > 0)\n  {\n   /*\n    * Write PostScript prolog stuff...\n    */\n\n    if (XRXComments)\n    {\n      int start, end;\t// Start and end of document pages...\n      int count;\t// Number of exception pages in this range...\n\n\n      // The following comments are Xerox job ticket information that\n      // is used on the high-end Laser Printing Systems rather than\n      // embedded commands...\n      fputs(\"%XRXbegin: 001.0300\\n\", out);\n      fputs(\"%XRXPDLformat: PS-Adobe\\n\", out);\n      if (doc_title)\n\tfprintf(out, \"%%XRXtitle: %s\\n\", doc_title);\n\n      if (OutputFiles)\n      {\n        // Output a single chapter...\n\tif (chapter < 0)\n\t{\n\t  start = 0;\n\t  end   = chapter_outstarts[1] - 1;\n\t}\n\telse\n\t{\n\t  start = chapter_outstarts[chapter];\n\t  end   = chapter_outends[chapter];\n\t}\n      }\n      else\n      {\n        start = 0;\n\tend   = 0;\n      }\n\n      if (pages[outpages[start].pages[0]].duplex)\n      {\n\tif (pages[outpages[start].pages[0]].landscape)\n\t  fputs(\"%XRXrequirements: duplex(tumble)\\n\", out);\n\telse\n\t  fputs(\"%XRXrequirements: duplex\\n\", out);\n      }\n      else\n\tfputs(\"%XRXrequirements: simplex\\n\", out);\n\n      fputs(\"%XRXdisposition: PRINT\\n\", out);\n      fputs(\"%XRXsignature: False\\n\", out);\n      fprintf(out, \"%%XRXpaperType-size: %.0f %.0f\\n\",\n              pages[outpages[start].pages[0]].width * 25.4f / 72.0f,\n              pages[outpages[start].pages[0]].length * 25.4f / 72.0f);\n      if (pages[outpages[start].pages[0]].media_type[0])\n\tfprintf(out, \"%%XRXpaperType-preFinish: %s 0 0\\n\",\n        \tpages[start].media_type);\n      if (pages[outpages[start].pages[0]].media_color[0])\n\tfprintf(out, \"%%XRXdocumentPaperColors: %c%s\\n\",\n        \ttolower(pages[start].media_color[0]),\n\t\tpages[start].media_color + 1);\n\n      if (OutputFiles)\n      {\n        // Handle document settings per-chapter...\n\tfor (i = start + 1; i < end; i += count)\n\t{\n\t  if (pages[outpages[i].pages[0]].width != pages[0].width ||\n\t      pages[outpages[i].pages[0]].length != pages[0].length ||\n\t      strcmp(pages[outpages[i].pages[0]].media_type,\n\t             pages[0].media_type) != 0 ||\n\t      strcmp(pages[outpages[i].pages[0]].media_color,\n\t             pages[0].media_color) != 0 ||\n\t      pages[outpages[i].pages[0]].duplex != pages[0].duplex)\n\t  {\n\t    for (count = 1; (i + count) <= end; count ++)\n\t      if (pages[outpages[i].pages[0]].width !=\n\t              pages[outpages[i + count].pages[0]].width ||\n\t\t  pages[outpages[i].pages[0]].length !=\n\t\t      pages[outpages[i + count].pages[0]].length ||\n\t\t  strcmp(pages[outpages[i].pages[0]].media_type,\n\t\t         pages[outpages[i + count].pages[0]].media_type) != 0 ||\n\t\t  strcmp(pages[outpages[i].pages[0]].media_color,\n\t\t         pages[outpages[i + count].pages[0]].media_color) != 0 ||\n\t\t  pages[outpages[i].pages[0]].duplex !=\n\t\t      pages[outpages[i + count].pages[0]].duplex)\n\t\tbreak;\n\n\t    fprintf(out, \"%%XRXpageExceptions: %d %d %.0f %.0f %c%s opaque %s 0 0\\n\",\n\t            i + 1, i + count,\n\t\t    pages[outpages[i].pages[0]].width * 25.4f / 72.0f,\n\t\t    pages[outpages[i].pages[0]].length * 25.4f / 72.0f,\n\t\t    tolower(pages[outpages[i].pages[0]].media_color[0]),\n\t\t    pages[outpages[i].pages[0]].media_color + 1,\n\t\t    pages[outpages[i].pages[0]].media_type[0] ?\n\t\t        pages[outpages[i].pages[0]].media_type : \"Plain\");\n\n\t    if (pages[outpages[i].pages[0]].duplex &&\n\t        pages[outpages[i].pages[0]].landscape)\n\t      fprintf(out, \"%%XRXpageExceptions-plex: %d %d duplex(tumble)\\n\",\n\t              i + 1, i + count);\n\t    else if (pages[outpages[i].pages[0]].duplex)\n\t      fprintf(out, \"%%XRXpageExceptions-plex: %d %d duplex\\n\",\n\t              i + 1, i + count);\n            else\n\t      fprintf(out, \"%%XRXpageExceptions-plex: %d %d simplex\\n\",\n\t              i + 1, i + count);\n\t  }\n\t  else\n\t    count = 1;\n        }\n      }\n      else\n      {\n        // All pages are in a single file...\n        for (j = (TocLevels == 0); j <= TocDocCount; j ++)\n\t{\n\t  start = chapter_outstarts[j];\n\t  end   = chapter_outends[j];\n\n\t  for (i = start + 1; i < end; i += count)\n\t  {\n\t    if (pages[outpages[i].pages[0]].width != pages[0].width ||\n\t\tpages[outpages[i].pages[0]].length != pages[0].length ||\n\t\tstrcmp(pages[outpages[i].pages[0]].media_type,\n\t\t       pages[0].media_type) != 0 ||\n\t\tstrcmp(pages[outpages[i].pages[0]].media_color,\n\t\t       pages[0].media_color) != 0 ||\n\t\tpages[outpages[i].pages[0]].duplex != pages[0].duplex)\n\t    {\n\t      for (count = 1; (i + count) < end; count ++)\n\t\tif (pages[outpages[i].pages[0]].width !=\n\t\t        pages[outpages[i + count].pages[0]].width ||\n\t\t    pages[outpages[i].pages[0]].length !=\n\t\t        pages[outpages[i + count].pages[0]].length ||\n\t\t    strcmp(pages[outpages[i].pages[0]].media_type,\n\t\t           pages[outpages[i + count].pages[0]].media_type) != 0 ||\n\t\t    strcmp(pages[outpages[i].pages[0]].media_color,\n\t\t           pages[outpages[i + count].pages[0]].media_color) != 0 ||\n\t\t    pages[outpages[i].pages[0]].duplex !=\n\t\t        pages[outpages[i + count].pages[0]].duplex)\n\t\t  break;\n\n\t      fprintf(out, \"%%XRXpageExceptions: %d %d %.0f %.0f %c%s opaque %s 0 0\\n\",\n\t              i + 1, i + count,\n\t\t      pages[outpages[i].pages[0]].width * 25.4f / 72.0f,\n\t\t      pages[outpages[i].pages[0]].length * 25.4f / 72.0f,\n\t\t      tolower(pages[outpages[i].pages[0]].media_color[0]),\n\t\t      pages[outpages[i].pages[0]].media_color + 1,\n\t\t      pages[outpages[i].pages[0]].media_type[0] ?\n\t\t          pages[outpages[i].pages[0]].media_type : \"Plain\");\n\n\t      if (pages[outpages[i].pages[0]].duplex && pages[outpages[i].pages[0]].landscape)\n\t\tfprintf(out, \"%%XRXpageExceptions-plex: %d %d duplex(tumble)\\n\",\n\t        \ti + 1, i + count);\n\t      else if (pages[outpages[i].pages[0]].duplex)\n\t\tfprintf(out, \"%%XRXpageExceptions-plex: %d %d duplex\\n\",\n\t        \ti + 1, i + count);\n              else\n\t\tfprintf(out, \"%%XRXpageExceptions-plex: %d %d simplex\\n\",\n\t        \ti + 1, i + count);\n\t    }\n\t    else\n\t      count = 1;\n          }\n\t}\n      }\n\n      fputs(\"%XRXend\\n\", out);\n    }\n\n    fputs(\"%!PS-Adobe-3.0\\n\", out);\n    if (Landscape)\n      fprintf(out, \"%%%%BoundingBox: 0 0 %d %d\\n\", PageLength, PageWidth);\n    else\n      fprintf(out, \"%%%%BoundingBox: 0 0 %d %d\\n\", PageWidth, PageLength);\n    fprintf(out,\"%%%%LanguageLevel: %d\\n\", PSLevel);\n    fputs(\"%%Creator: \" HTMLDOC_PRODUCER \"\\n\", out);\n    fprintf(out, \"%%%%CreationDate: D:%04d%02d%02d%02d%02d%02d+0000\\n\",\n            doc_date.tm_year + 1900, doc_date.tm_mon + 1, doc_date.tm_mday,\n            doc_date.tm_hour, doc_date.tm_min, doc_date.tm_sec);\n    if (doc_title != NULL)\n      fprintf(out, \"%%%%Title: %s\\n\", doc_title);\n    if (author != NULL)\n      fprintf(out, \"%%%%Author: %s\\n\", author);\n    if (creator != NULL)\n      fprintf(out, \"%%%%Generator: %s\\n\", creator);\n    if (copyright != NULL)\n      fprintf(out, \"%%%%Copyright: %s\\n\", copyright);\n    if (keywords != NULL)\n      fprintf(out, \"%%%%Keywords: %s\\n\", keywords);\n    if (subject != NULL)\n      fprintf(out, \"%%%%Subject: %s\\n\", keywords);\n    if (page_count > 0)\n      fprintf(out, \"%%%%Pages: %d\\n\", page_count);\n    else\n      fputs(\"%%Pages: (atend)\\n\", out);\n\n    if (!EmbedFonts)\n    {\n      fputs(\"%%DocumentNeededResources:\\n\", out);\n\n      for (i = 0; i < TYPE_MAX; i ++)\n        for (j = 0; j < STYLE_MAX; j ++)\n          if (fonts_used[i][j] && _htmlStandardFonts[i])\n            fprintf(out, \"%%%%+ font %s\\n\", _htmlFonts[i][j]);\n    }\n\n    fputs(\"%%DocumentProvidedResources:\\n\", out);\n\n    for (i = 0; i < TYPE_MAX; i ++)\n      for (j = 0; j < STYLE_MAX; j ++)\n        if (fonts_used[i][j] && (EmbedFonts || !_htmlStandardFonts[i]))\n          fprintf(out, \"%%%%+ font %s\\n\", _htmlFonts[i][j]);\n    fputs(\"%%DocumentData: Clean7bit\\n\", out);\n    fputs(\"%%EndComments\\n\", out);\n\n    fputs(\"%%BeginProlog\\n\", out);\n\n   /*\n    * Embed fonts?\n    */\n\n    for (i = 0; i < TYPE_MAX; i ++)\n    {\n      if (EmbedFonts || !_htmlStandardFonts[i])\n\tfor (j = 0; j < STYLE_MAX; j ++)\n          if (fonts_used[i][j])\n\t    write_type1(out, (typeface_t)i, (style_t)j);\n    }\n\n   /*\n    * Procedures used throughout the document...\n    */\n\n    const char *version = SVERSION;\n\n    fprintf(out, \"%%%%BeginResource: procset htmldoc-page 1.8 %s\\n\", version + 4);\n    fputs(\"/BD{bind def}bind def\", out);\n    fputs(\"/B{dup 0 exch rlineto exch 0 rlineto neg 0 exch rlineto\\n\"\n          \"closepath stroke}BD\", out);\n    fputs(\"/C{setrgbcolor}BD\\n\", out);\n    fputs(\"/CM{concat}BD\", out);\n    fputs(\"/DF{findfont dup length dict begin{1 index/FID ne{def}{pop pop}\\n\"\n          \"ifelse}forall/Encoding fontencoding def currentdict end definefont pop}BD\\n\", out);\n    fputs(\"/F{dup 0 exch rlineto exch 0 rlineto neg 0 exch rlineto closepath fill}BD\\n\", out);\n    fputs(\"/FS{/hdFontSize exch def}BD\", out);\n    fputs(\"/G{setgray}BD\\n\", out);\n    fputs(\"/GS{gsave}BD\", out);\n    fputs(\"/GR{grestore}BD\", out);\n    fputs(\"/J{0 exch ashow}BD\\n\", out);\n    fputs(\"/L{0 rlineto stroke}BD\", out);\n    fputs(\"/M{moveto}BD\", out);\n    fputs(\"/re{4 2 roll moveto 1 index 0 rlineto 0 exch rlineto neg 0 rlineto closepath}BD\\n\", out);\n    fputs(\"/RO{rotate}BD\", out);\n    fputs(\"/S{show}BD\", out);\n    fputs(\"/SC{dup scale}BD\\n\", out);\n    fputs(\"/SF{findfont hdFontSize scalefont setfont}BD\", out);\n    fputs(\"/SP{showpage}BD\", out);\n    fputs(\"/T{translate}BD\\n\", out);\n    fputs(\"%%EndResource\\n\", out);\n\n   /*\n    * Output the font encoding for the current character set...  For now we\n    * just support 8-bit fonts since true Unicode support needs a very large\n    * number of extra fonts that aren't normally available on a PS printer.\n    */\n\n    fputs(\"/fontencoding[\\n\", out);\n    for (i = 0, j = 0; i < 256; i ++)\n    {\n      if (_htmlGlyphs[i])\n        j += strlen(_htmlGlyphs[i]) + 1;\n      else\n        j += 8;\n\n      if (j > 80)\n      {\n\tif (_htmlGlyphs[i])\n          j = strlen(_htmlGlyphs[i]) + 1;\n\telse\n          j = 8;\n\n        putc('\\n', out);\n      }\n\n      putc('/', out);\n      if (_htmlGlyphs[i])\n        fputs(_htmlGlyphs[i], out);\n      else\n        fputs(\".notdef\", out);\n    }\n\n    fputs(\"]def\\n\", out);\n\n   /*\n    * Fonts...\n    */\n\n    for (i = 0; i < TYPE_MAX; i ++)\n      for (j = 0; j < STYLE_MAX; j ++)\n        if (fonts_used[i][j])\n        {\n\t  if (i < TYPE_SYMBOL)\n\t    fprintf(out, \"/F%x/%s DF\\n\", i * 4 + j, _htmlFonts[i][j]);\n\t  else\n\t    fprintf(out, \"/F%x/%s findfont definefont pop\\n\", i * 4 + j,\n\t            _htmlFonts[i][j]);\n        }\n\n    if (PSCommands)\n    {\n      snprintf(temp, sizeof(temp), \"%s/data/prolog.ps\", _htmlData);\n      if ((prolog = fopen(temp, \"rb\")) != NULL)\n      {\n\twhile (fgets(temp, sizeof(temp), prolog) != NULL)\n          fputs(temp, out);\n\n\tfclose(prolog);\n      }\n      else\n      {\n\tprogress_error(HD_ERROR_FILE_NOT_FOUND,\n                       \"Unable to open data file \\\"%s\\\" - %s\", temp,\n                       strerror(errno));\n\n\tfprintf(out, \"%%%%BeginResource: procset htmldoc-device 1.8 %s\\n\", version + 4);\n\tfputs(\"languagelevel 1 eq{/setpagedevice{pop}BD}if\\n\", out);\n\tfputs(\"/SetDuplexMode{<</Duplex 3 index/Tumble 5 index>>setpagedevice \"\n              \"pop pop}BD\\n\", out);\n\tfputs(\"/SetMediaColor{pop}BD\\n\", out);\n\tfputs(\"/SetMediaType{pop}BD\\n\", out);\n\tfputs(\"/SetMediaPosition{pop}BD\\n\", out);\n\tfputs(\"/SetPageSize{2 array astore<</PageSize 2 index/ImageableArea \"\n              \"null>>setpagedevice pop}BD\\n\", out);\n\tfputs(\"%%EndResource\\n\", out);\n      }\n    }\n\n    if (background_image != NULL)\n      ps_write_background(out);\n\n    fputs(\"%%EndProlog\\n\", out);\n  }\n  else\n  {\n   /*\n    * Write PDF prolog stuff...\n    */\n\n    fprintf(out, \"%%PDF-%.1f\\n\", 0.1 * PDFVersion);\n    fputs(\"%\\342\\343\\317\\323\\n\", out);\n    num_objects = 0;\n\n   /*\n    * Compute the file ID...\n    */\n\n    md5_init(&md5);\n    md5_append(&md5, (md5_byte_t *)OutputPath, sizeof(OutputPath));\n    md5_append(&md5, (md5_byte_t *)&doc_time, sizeof(doc_time));\n    md5_finish(&md5, file_id);\n\n   /*\n    * Setup encryption stuff as necessary...\n    */\n\n    if (Encryption)\n    {\n     /*\n      * Copy and pad the user password...\n      */\n\n      strlcpy((char *)user_pad, UserPassword, sizeof(user_pad));\n\n      if ((i = strlen(UserPassword)) < 32)\n\tmemcpy(user_pad + i, pad, (size_t)(32 - i));\n\n      if (OwnerPassword[0])\n      {\n       /*\n        * Copy and pad the owner password...\n\t*/\n\n        strlcpy((char *)owner_pad, OwnerPassword, sizeof(owner_pad));\n\n\tif ((i = strlen(OwnerPassword)) < 32)\n\t  memcpy(owner_pad + i, pad, (size_t)(32 - i));\n      }\n      else\n      {\n       /*\n        * Generate a pseudo-random owner password...\n\t*/\n\n\tsrand(time(NULL));\n\n\tfor (i = 0; i < 32; i ++)\n\t  owner_pad[i] = (uchar)rand();\n      }\n\n     /*\n      * What is the key length?\n      *\n      * Acrobat 4.0 and earlier (PDF 1.3 and earlier) allow a maximum of\n      * 40-bits.  Acrobat 5.0 and newer support 128-bits.\n      */\n\n      if (PDFVersion > 13)\n        encrypt_len = 16;\t// 128 bits\n      else\n        encrypt_len = 5;\t// 40 bits\n\n     /*\n      * Compute the owner key...\n      */\n\n      md5_init(&md5);\n      md5_append(&md5, owner_pad, 32);\n      md5_finish(&md5, digest);\n\n      if (encrypt_len > 5)\n      {\n        // MD5 the result 50 more times...\n\tfor (i = 0; i < 50; i ++)\n\t{\n          md5_init(&md5);\n          md5_append(&md5, digest, 16);\n          md5_finish(&md5, digest);\n\t}\n\n        // Copy the padded user password...\n        memcpy(owner_key, user_pad, 32);\n\n        // Encrypt the result 20 times...\n\tfor (i = 0; i < 20; i ++)\n\t{\n\t  // XOR each byte in the key with the loop counter...\n\t  for (j = 0; j < encrypt_len; j ++)\n\t    encrypt_key[j] = (uchar)(digest[j] ^ i);\n\n          rc4_init(&rc4, encrypt_key, (size_t)encrypt_len);\n          rc4_encrypt(&rc4, owner_key, owner_key, 32);\n\t}\n      }\n      else\n      {\n        rc4_init(&rc4, digest, (size_t)encrypt_len);\n        rc4_encrypt(&rc4, user_pad, owner_key, 32);\n      }\n\n     /*\n      * Figure out the permissions word; the new N-bit security\n      * handler adds several new permission bits, which we must\n      * simulate...\n      */\n\n      perm_value = (unsigned)Permissions;\n\n      if (encrypt_len > 5)\n      {\n        // N-bit encryption...\n\tif (!(perm_value & PDF_PERM_COPY))\n\t  perm_value &= (unsigned)~0x00240000;\t// Mask additional copy perms...\n      }\n\n     /*\n      * Compute the encryption key...\n      */\n\n      md5_init(&md5);\n      md5_append(&md5, user_pad, 32);\n      md5_append(&md5, owner_key, 32);\n\n      perm_bytes[0] = (uchar)perm_value;\n      perm_bytes[1] = (uchar)(perm_value >> 8);\n      perm_bytes[2] = (uchar)(perm_value >> 16);\n      perm_bytes[3] = (uchar)(perm_value >> 24);\n\n      md5_append(&md5, perm_bytes, 4);\n      md5_append(&md5, file_id, 16);\n      md5_finish(&md5, digest);\n\n      if (encrypt_len > 5)\n      {\n        // MD5 the result 50 times..\n        for (i = 0; i < 50; i ++)\n\t{\n\t  md5_init(&md5);\n\t  md5_append(&md5, digest, 16);\n\t  md5_finish(&md5, digest);\n\t}\n      }\n\n      memcpy(encrypt_key, digest, (size_t)encrypt_len);\n\n     /*\n      * Compute the user key...\n      */\n\n      if (encrypt_len > 5)\n      {\n        md5_init(&md5);\n        md5_append(&md5, pad, 32);\n        md5_append(&md5, file_id, 16);\n        md5_finish(&md5, user_key);\n\n        memset(user_key + 16, 0, 16);\n\n        // Encrypt the result 20 times...\n        for (i = 0; i < 20; i ++)\n\t{\n\t  // XOR each byte in the key with the loop counter...\n\t  for (j = 0; j < encrypt_len; j ++)\n\t    digest[j] = (uchar)(encrypt_key[j] ^ i);\n\n          rc4_init(&rc4, digest, (size_t)encrypt_len);\n          rc4_encrypt(&rc4, user_key, user_key, 16);\n\t}\n      }\n      else\n      {\n        rc4_init(&rc4, encrypt_key, (size_t)encrypt_len);\n        rc4_encrypt(&rc4, pad, user_key, 32);\n      }\n\n     /*\n      * Write the encryption dictionary...\n      */\n\n      encrypt_object = pdf_start_object(out);\n\n      fputs(\"/Filter/Standard/O<\", out);\n      for (i = 0; i < 32; i ++)\n        fprintf(out, \"%02x\", owner_key[i]);\n      fputs(\">/U<\", out);\n      for (i = 0; i < 32; i ++)\n        fprintf(out, \"%02x\", user_key[i]);\n      fputs(\">\", out);\n\n      if (encrypt_len > 5)\n      {\n        // N-bit encryption...\n        fprintf(out, \"/P %d/V 2/R 3/Length %d\", (int)perm_value, encrypt_len * 8);\n      }\n      else\n        fprintf(out, \"/P %d/V 1/R 2\", (int)perm_value);\n\n      pdf_end_object(out);\n    }\n    else\n      encrypt_object = 0;\n\n   /*\n    * Write info object...\n    */\n\n    info_object = pdf_start_object(out);\n\n    fputs(\"/Producer\", out);\n    write_string(out, (uchar *)HTMLDOC_PRODUCER, 0);\n    fputs(\"/CreationDate\", out);\n    snprintf(temp, sizeof(temp), \"D:%04d%02d%02d%02d%02d%02d+0000\",\n            doc_date.tm_year + 1900, doc_date.tm_mon + 1, doc_date.tm_mday,\n            doc_date.tm_hour, doc_date.tm_min, doc_date.tm_sec);\n    write_string(out, (uchar *)temp, 0);\n\n    if (doc_title != NULL)\n    {\n      fputs(\"/Title\", out);\n      write_utf16(out, doc_title);\n    }\n\n    if (author != NULL || copyright != NULL)\n    {\n      if (author && copyright)\n        snprintf(temp, sizeof(temp), \"%s, %s\", author, copyright);\n      else if (author)\n        strlcpy(temp, (const char *)author, sizeof(temp));\n      else\n        strlcpy(temp, (const char *)copyright, sizeof(temp));\n\n      fputs(\"/Author\", out);\n      write_utf16(out, (uchar *)temp);\n    }\n\n    if (creator != NULL)\n    {\n      fputs(\"/Creator\", out);\n      write_utf16(out, creator);\n    }\n\n    if (keywords != NULL)\n    {\n      fputs(\"/Keywords\", out);\n      write_utf16(out, keywords);\n    }\n\n    if (subject != NULL)\n    {\n      fputs(\"/Subject\", out);\n      write_utf16(out, subject);\n    }\n\n    pdf_end_object(out);\n\n   /*\n    * Write the font encoding for the selected character set.  Note that\n    * we *should* be able to use the WinAnsiEncoding value for ISO-8859-1\n    * to make smaller files, however Acrobat Exchange does not like it\n    * despite the fact that it is defined in the PDF specification...\n    */\n\n    encoding_object = pdf_start_object(out);\n\n    fputs(\"/Type/Encoding\", out);\n    fputs(\"/Differences[\", out);\n    for (i = 0, j = -1; i < 256; i ++)\n      if (_htmlGlyphs[i])\n      {\n       /*\n        * Output a character index if we had blank ones...\n\t*/\n\n        if (j != (i - 1))\n\t  fprintf(out, \" %d\", i);\n\n        fprintf(out, \"/%s\", _htmlGlyphs[i]);\n\tj = i;\n      }\n\n    fputs(\"]\", out);\n    pdf_end_object(out);\n\n    memset(font_desc, 0, sizeof(font_desc));\n\n   /*\n    * Build font descriptors for the EmbedFonts fonts...\n    */\n\n    for (i = 0; i < TYPE_MAX; i ++)\n      if (EmbedFonts || !_htmlStandardFonts[i])\n\tfor (j = 0; j < STYLE_MAX; j ++)\n          if (fonts_used[i][j])\n\t    font_desc[i][j] = write_type1(out, (typeface_t )i, (style_t)j);\n\n    for (i = 0; i < TYPE_MAX; i ++)\n      for (j = 0; j < STYLE_MAX; j ++)\n        if (fonts_used[i][j])\n        {\n\t  font_objects[i * STYLE_MAX + j] = pdf_start_object(out);\n\n\t  fputs(\"/Type/Font\", out);\n\t  fputs(\"/Subtype/Type1\", out);\n\t  fprintf(out, \"/BaseFont/%s\", _htmlFonts[i][j]);\n\n          if (font_desc[i][j])\n\t  {\n\t    // Embed Type1 font...\n\t    fputs(\"/FirstChar 0\", out);\n\t    fputs(\"/LastChar 255\", out);\n\t    fprintf(out, \"/Widths %d 0 R\", font_desc[i][j] + 1);\n\t    fprintf(out, \"/FontDescriptor %d 0 R\", font_desc[i][j]);\n\t  }\n\n\t  if (i < TYPE_SYMBOL) /* Use native encoding for symbols */\n\t    fprintf(out, \"/Encoding %d 0 R\", encoding_object);\n\n          pdf_end_object(out);\n        }\n  }\n}\n\n\n/*\n * 'write_string()' - Write a text entity.\n */\n\nstatic void\nwrite_string(FILE  *out,\t\t/* I - Output file */\n             uchar *s,\t\t\t/* I - String */\n\t     int   compress)\t\t/* I - Compress output? */\n{\n  int\ti;\t\t\t\t/* Looping var */\n\n\n  if (Encryption && !compress && PSLevel == 0)\n  {\n    int\t\tlen,\t\t\t// Length of string\n\t\tbytes;\t\t\t// Current bytes encrypted\n    uchar\tnews[1024];\t\t// New string\n\n\n   /*\n    * Write an encrypted string...\n    */\n\n    putc('<', out);\n    encrypt_init();\n\n    for (len = strlen((char *)s); len > 0; len -= bytes, s += bytes)\n    {\n      if (len > (int)sizeof(news))\n        bytes = (int)sizeof(news);\n      else\n        bytes = len;\n\n      rc4_encrypt(&encrypt_state, s, news, (size_t)bytes);\n\n      for (i = 0; i < bytes; i ++)\n        fprintf(out, \"%02x\", news[i]);\n    }\n\n    putc('>', out);\n  }\n  else\n  {\n    uchar nbsp = 160;\t\t\t// Non-breaking space char\n\n    if (compress)\n      flate_write(out, (uchar *)\"(\", 1);\n    else\n      putc('(', out);\n\n    if (_htmlUTF8)\n      nbsp = _htmlCharacters[160];\n\n    while (*s != '\\0')\n    {\n      if (*s == nbsp)\n      {\n       /* &nbsp; */\n\tif (compress)\n\t  flate_write(out, (uchar *)\" \", 1);\n\telse\n\t  putc(' ', out);\n      }\n      else if (*s < 32 || *s > 126)\n      {\n\tif (compress)\n\t  flate_printf(out, \"\\\\%o\", *s);\n\telse\n\t  fprintf(out, \"\\\\%o\", *s);\n      }\n      else if (compress)\n      {\n\tif (*s == '(' || *s == ')' || *s == '\\\\')\n\t  flate_write(out, (uchar *)\"\\\\\", 1);\n\n\tflate_write(out, s, 1);\n      }\n      else\n      {\n\tif (*s == '(' || *s == ')' || *s == '\\\\')\n\t  putc('\\\\', out);\n\n\tputc(*s, out);\n      }\n\n      s ++;\n    }\n\n    if (compress)\n      flate_write(out, (uchar *)\")\", 1);\n    else\n      putc(')', out);\n  }\n}\n\n\n/*\n * 'write_text()' - Write a text entity.\n */\n\nstatic void\nwrite_text(FILE     *out,\t/* I - Output file */\n           render_t *r)\t\t/* I - Text entity */\n{\n  uchar\t*ptr;\t\t\t/* Pointer into text */\n\n\n  // Quick optimization - don't output spaces...\n  for (ptr = r->data.text.buffer; *ptr; ptr ++)\n    if (!isspace(*ptr) && *ptr != 0xa0)\n      break;\n\n  if (!*ptr)\n    return;\n\n  // Not just whitespace - send it out...\n  set_color(out, r->data.text.rgb);\n  set_font(out, r->data.text.typeface, r->data.text.style, r->data.text.size);\n  set_pos(out, r->x, r->y);\n\n  if (PSLevel > 0)\n  {\n    if (r->data.text.spacing > 0.0f)\n      fprintf(out, \" %.3f\", r->data.text.spacing);\n  }\n  else if (r->data.text.spacing != render_spacing)\n    flate_printf(out, \" %.3f Tc\", render_spacing = r->data.text.spacing);\n\n  write_string(out, r->data.text.buffer, PSLevel == 0);\n\n  if (PSLevel > 0)\n  {\n    if (r->data.text.spacing > 0.0f)\n      fputs(\"J\\n\", out);\n    else\n      fputs(\"S\\n\", out);\n  }\n  else\n    flate_puts(\"Tj\\n\", out);\n\n  render_x += r->width;\n}\n\n\n/*\n * 'write_trailer()' - Write the file trailer.\n */\n\nstatic void\nwrite_trailer(FILE  *out,\t\t/* I - Output file */\n              int   num_file_pages,\t/* I - Number of pages in file */\n\t      uchar *lang)\t\t/* I - Language */\n{\n  int\t\ti, j, k,\t\t/* Looping vars */\n\t\ttype,\t\t\t/* Type of number */\n\t\toffset,\t\t\t/* Offset to xref table in PDF file */\n\t\tstart;\t\t\t/* Start page number */\n  page_t\t*page;\t\t\t/* Start page of chapter */\n  char\t\tprefix[64],\t\t/* Prefix string */\n\t\t*prefptr;\t\t/* Pointer into prefix string */\n  static const char *modes[] =\t\t/* Page modes */\n\t\t{\n\t\t  \"UseNone\",\n\t\t  \"UseOutlines\",\n\t\t  \"FullScreen\"\n\t\t};\n  static const char *layouts[] =\t/* Page layouts */\n\t\t{\n\t\t  \"SinglePage\",\n\t\t  \"OneColumn\",\n\t\t  \"TwoColumnLeft\",\n\t\t  \"TwoColumnRight\"\n\t\t};\n\n\n  if (PSLevel > 0)\n  {\n   /*\n    * PostScript...\n    */\n\n    fputs(\"%%Trailer\\n\", out);\n    if (num_file_pages > 0)\n      fprintf(out, \"%%%%Pages: %d\\n\", num_file_pages);\n\n    fputs(\"%%EOF\\n\", out);\n  }\n  else\n  {\n   /*\n    * PDF...\n    */\n\n    root_object = pdf_start_object(out);\n\n    fputs(\"/Type/Catalog\", out);\n    fprintf(out, \"/Pages %d 0 R\", pages_object);\n\n    if (PDFVersion >= 12)\n    {\n      if (names_object)\n        fprintf(out, \"/Names %d 0 R\", names_object);\n\n      fprintf(out, \"/PageLayout/%s\", layouts[PDFPageLayout]);\n    }\n\n    if (lang)\n      fprintf(out, \"/Lang(%s)\", (char *)lang);\n\n    if (outline_object > 0)\n      fprintf(out, \"/Outlines %d 0 R\", outline_object);\n\n    switch (PDFFirstPage)\n    {\n      case PDF_PAGE_1 :\n          if (TitlePage)\n\t  {\n            fprintf(out, \"/OpenAction[%d 0 R/XYZ null null 0]\",\n                    pages_object + 1);\n            break;\n\t  }\n          break;\n      case PDF_TOC :\n          if (TocLevels > 0)\n\t  {\n            fprintf(out, \"/OpenAction[%d 0 R/XYZ null null 0]\",\n                    pages_object + 2 * chapter_outstarts[0] + 1);\n\t    break;\n\t  }\n          break;\n      case PDF_CHAPTER_1 :\n          fprintf(out, \"/OpenAction[%d 0 R/XYZ null null 0]\",\n                  pages_object + 2 * chapter_outstarts[1] + 1);\n          break;\n    }\n\n    fprintf(out, \"/PageMode/%s\", modes[PDFPageMode]);\n\n    if (PDFVersion > 12 && NumberUp == 1)\n    {\n      // Output the PageLabels tree...\n      fputs(\"/PageLabels<</Nums[\", out);\n\n      for (i = 0; i < chapter_starts[1]; i ++)\n      {\n        fprintf(out, \"%d<</P\", i);\n        if (i & 1)\n\t  write_string(out, (uchar *)\"eltit\", 0);\n\telse\n\t  write_string(out, (uchar *)\"title\", 0);\n\tfputs(\">>\", out);\n      }\n\n      if (TocLevels > 0 && OutputType == OUTPUT_BOOK)\n      {\n        type = 'r';\n\n        for (j = 0; j < 3; j ++)\n\t  if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(1)\")) ||\n\t      (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(1)\")))\n\t    type = 'D';\n\t  else if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(I)\")) ||\n\t           (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(I)\")))\n\t    type = 'R';\n\t  else if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(a)\")) ||\n\t           (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(a)\")))\n\t    type = 'a';\n\t  else if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(A)\")) ||\n\t           (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(A)\")))\n\t    type = 'A';\n\n        fprintf(out, \"%d<</S/%c>>\", i, type);\n\n        i += chapter_ends[0] - chapter_starts[0] + 1;\n      }\n\n      for (j = 1; j <= TocDocCount; j ++)\n      {\n        page  = pages + chapter_starts[j];\n\tstart = chapter_starts[j] - chapter_starts[1] + 1;\n\ttype  = 'D';\n\n        prefix[0] = '\\0';\n\n\tfor (k = 0; k < 3; k ++)\n\t{\n\t  if (page->header[k] && strstr((char *)page->header[k], \"PAGE\"))\n\t    strlcpy(prefix, (char *)page->header[k], sizeof(prefix));\n\t  else if (page->footer[k] && strstr((char *)page->footer[k], \"PAGE\"))\n\t    strlcpy(prefix, (char *)page->footer[k], sizeof(prefix));\n\n\t  if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(i)\")) ||\n\t      (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(i)\")))\n\t    type = 'r';\n\t  else if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(I)\")) ||\n\t           (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(I)\")))\n\t    type = 'R';\n\t  else if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(a)\")) ||\n\t           (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(a)\")))\n\t    type = 'a';\n\t  else if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(A)\")) ||\n\t           (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(A)\")))\n\t    type = 'A';\n\n\t  if ((page->header[k] && strstr((char *)page->header[k], \"$CHAPTERPAGE\")) ||\n\t      (page->footer[k] && strstr((char *)page->footer[k], \"$CHAPTERPAGE\")))\n\t    start = 1;\n        }\n\n        if ((prefptr = strstr(prefix, \"$PAGE\")) == NULL)\n\t  prefptr = strstr(prefix, \"$CHAPTERPAGE\");\n\tfprintf(out, \"%d<</S/%c/St %d\", i, type, start);\n\tif (prefptr)\n\t{\n\t  *prefptr = '\\0';\n\t  fputs(\"/P\", out);\n\t  write_string(out, (uchar *)prefix, 0);\n\t}\n\tfputs(\">>\", out);\n\n        i += chapter_ends[j] - chapter_starts[j] + 1;\n      }\n\n      fputs(\"]>>\", out);\n    }\n\n    pdf_end_object(out);\n\n    offset = ftell(out);\n\n    fputs(\"xref\\n\", out);\n    fprintf(out, \"0 %d \\n\", (int)num_objects + 1);\n    fputs(\"0000000000 65535 f \\n\", out);\n    for (i = 1; i <= (int)num_objects; i ++)\n      fprintf(out, \"%010d 00000 n \\n\", objects[i]);\n\n    fputs(\"trailer\\n\", out);\n    fputs(\"<<\", out);\n    fprintf(out, \"/Size %d\", (int)num_objects + 1);\n    fprintf(out, \"/Root %d 0 R\", root_object);\n    fprintf(out, \"/Info %d 0 R\", info_object);\n    fputs(\"/ID[<\", out);\n    for (i = 0; i < 16; i ++)\n      fprintf(out, \"%02x\", file_id[i]);\n    fputs(\"><\", out);\n    for (i = 0; i < 16; i ++)\n      fprintf(out, \"%02x\", file_id[i]);\n    fputs(\">]\", out);\n\n    if (Encryption)\n      fprintf(out, \"/Encrypt %d 0 R\", encrypt_object);\n\n    fputs(\">>\\n\", out);\n    fputs(\"startxref\\n\", out);\n    fprintf(out, \"%d\\n\", offset);\n    fputs(\"%%EOF\\n\", out);\n  }\n}\n\n\n/*\n * 'write_type1()' - Write an embedded Type 1 font.\n */\n\nstatic int\t\t\t\t/* O - Object number */\nwrite_type1(FILE       *out,\t\t/* I - File to write to */\n            typeface_t typeface,\t/* I - Typeface */\n\t    style_t    style)\t\t/* I - Style */\n{\n  char\t\tfilename[1024];\t\t/* PFA filename */\n  FILE\t\t*fp;\t\t\t/* PFA file */\n  int\t\tch;\t\t\t/* Character value */\n  int\t\twidth;\t\t\t/* Width value */\n  char\t\tglyph[64],\t\t/* Glyph name */\n\t\tline[1024],\t\t/* Line from AFM file */\n\t\t*lineptr,\t\t/* Pointer into line */\n\t\t*dataptr;\t\t/* Pointer for data */\n  int\t\tascent,\t\t\t/* Ascent above baseline */\n\t\tcap_height,\t\t/* Ascent of CAPITALS */\n\t\tx_height,\t\t/* Ascent of lowercase */\n\t\tdescent,\t\t/* Decent below baseline */\n\t\tbbox[4],\t\t/* Bounding box */\n\t\titalic_angle;\t\t/* Angle for italics */\n  int\t\twidths[256];\t\t/* Character widths */\n  int\t\tlength1,\t\t/* Length1 value for font */\n\t\tlength2,\t\t/* Length2 value for font */\n\t\tlength3;\t\t/* Length3 value for font */\n  static int\ttflags[] =\t\t/* PDF typeface flags */\n\t\t{\n\t\t  33,\t\t\t/* Courier */\n\t\t  34,\t\t\t/* Times-Roman */\n\t\t  32,\t\t\t/* Helvetica */\n\t\t  33,\t\t\t/* Monospace */\n\t\t  34,\t\t\t/* Serif */\n\t\t  32,\t\t\t/* Sans */\n\t\t  4,\t\t\t/* Symbol */\n\t\t  4\t\t\t/* Dingbats */\n\t\t};\n  static int\tsflags[] =\t\t/* PDF style flags */\n\t\t{\n\t\t  0,\t\t\t/* Normal */\n\t\t  0,\t\t\t/* Bold */\n\t\t  64,\t\t\t/* Italic */\n\t\t  64\t\t\t/* Bold-Italic */\n\t\t};\n\n\n /*\n  * This function writes a Type1 font, either as an object for PDF\n  * output or as an in-line font in PostScript output.  This is useful\n  * because the Type1 fonts that Adobe ships typically do not include\n  * the full set of characters required by some of the ISO character\n  * sets.\n  */\n\n /*\n  * Try to open the PFA file for the Type1 font...\n  */\n\n  snprintf(filename, sizeof(filename), \"%s/fonts/%s.pfa\", _htmlData,\n           _htmlFonts[typeface][style]);\n  if ((fp = fopen(filename, \"r\")) == NULL)\n  {\n#ifndef DEBUG\n    progress_error(HD_ERROR_FILE_NOT_FOUND,\n                   \"Unable to open font file %s!\", filename);\n#endif /* !DEBUG */\n    return (0);\n  }\n\n /*\n  * Write the font (object)...\n  */\n\n  if (PSLevel)\n  {\n   /*\n    * Embed a Type1 font in the PostScript output...\n    */\n\n    fprintf(out, \"%%%%BeginResource: font %s\\n\", _htmlFonts[typeface][style]);\n\n    line[0] = '\\0';\n\n    while (fgets(line, sizeof(line), fp) != NULL)\n      fputs(line, out);\n\n    if (line[strlen(line) - 1] != '\\n')\n      fputs(\"\\n\", out);\n\n    fputs(\"%%EndResource\\n\", out);\n\n    fclose(fp);\n  }\n  else\n  {\n   /*\n    * Embed a Type1 font object in the PDF output...\n    */\n\n    length1 = 0;\n    length2 = 0;\n    length3 = 0;\n\n    while (fgets(line, sizeof(line), fp) != NULL)\n    {\n      length1 += strlen(line);\n      if (strstr(line, \"currentfile eexec\") != NULL)\n        break;\n    }\n\n    while (fgets(line, sizeof(line), fp) != NULL)\n    {\n      if (!strcmp(line, \"00000000000000000000000000000000\"\n                        \"00000000000000000000000000000000\\n\"))\n        break;\n\n      length2 += (strlen(line) - 1) / 2;\n    }\n\n    length3 = strlen(line);\n    while (fgets(line, sizeof(line), fp) != NULL)\n      length3 += strlen(line);\n\n    rewind(fp);\n\n    pdf_start_object(out);\n    fprintf(out, \"/Length1 %d\", length1);\n    fprintf(out, \"/Length2 %d\", length2);\n    fprintf(out, \"/Length3 %d\", length3);\n    if (Compression)\n      fputs(\"/Filter/FlateDecode\", out);\n    pdf_start_stream(out);\n    flate_open_stream(out);\n\n    while (fgets(line, sizeof(line), fp) != NULL)\n    {\n      flate_puts(line, out);\n\n      if (strstr(line, \"currentfile eexec\") != NULL)\n        break;\n    }\n\n    while (fgets(line, sizeof(line), fp) != NULL)\n    {\n      if (!strcmp(line, \"00000000000000000000000000000000\"\n                        \"00000000000000000000000000000000\\n\"))\n        break;\n\n      for (lineptr = line, dataptr = line; isxdigit(*lineptr); lineptr += 2)\n      {\n        if (isdigit(lineptr[0]))\n\t  ch = (lineptr[0] - '0') << 4;\n\telse\n\t  ch = (tolower(lineptr[0] & 255) - 'a' + 10) << 4;\n\n        if (isdigit(lineptr[1]))\n\t  ch |= lineptr[1] - '0';\n\telse\n\t  ch |= tolower(lineptr[1] & 255) - 'a' + 10;\n\n        *dataptr++ = (char)ch;\n      }\n\n      flate_write(out, (uchar *)line, dataptr - line);\n    }\n\n    flate_puts(line, out);\n    while (fgets(line, sizeof(line), fp) != NULL)\n      flate_puts(line, out);\n\n    flate_close_stream(out);\n\n    pdf_end_object(out);\n\n    fclose(fp);\n\n   /*\n    * Try to open the AFM file for the Type1 font...\n    */\n\n    snprintf(filename, sizeof(filename), \"%s/fonts/%s.afm\", _htmlData,\n             _htmlFonts[typeface][style]);\n    if ((fp = fopen(filename, \"r\")) == NULL)\n    {\n#ifndef DEBUG\n      progress_error(HD_ERROR_FILE_NOT_FOUND,\n                     \"Unable to open font width file %s!\", filename);\n#endif /* !DEBUG */\n      return (0);\n    }\n\n   /*\n    * Set the default values (Courier)...\n    */\n\n    for (ch = 0; ch < 256; ch ++)\n      widths[ch] = 600;\n\n    ascent       = 629;\n    cap_height   = 562;\n    x_height     = 426;\n    descent      = -157;\n    bbox[0]      = -28;\n    bbox[1]      = -250;\n    bbox[2]      = 628;\n    bbox[3]      = 805;\n    italic_angle = 0;\n\n   /*\n    * Read the AFM file...\n    */\n\n    while (fgets(line, sizeof(line), fp) != NULL)\n    {\n      if (strncmp(line, \"ItalicAngle \", 12) == 0)\n\titalic_angle = atoi(line + 12);\n      else if (strncmp(line, \"FontBBox \", 9) == 0)\n\tsscanf(line + 9, \"%d%d%d%d\", bbox + 0, bbox + 1, bbox + 2, bbox + 3);\n      else if (strncmp(line, \"CapHeight \", 10) == 0)\n\tcap_height = atoi(line + 10);\n      else if (strncmp(line, \"XHeight \", 8) == 0)\n\tx_height = atoi(line + 8);\n      else if (strncmp(line, \"Ascender \", 9) == 0)\n\tascent = atoi(line + 9);\n      else if (strncmp(line, \"Descender \", 10) == 0)\n\tdescent = atoi(line + 10);\n      else if (strncmp(line, \"C \", 2) == 0)\n      {\n\tif (typeface < TYPE_SYMBOL)\n\t{\n\t /*\n\t  * Handle encoding of Courier, Times, and Helvetica using\n\t  * assigned charset...\n\t  */\n\n\t  if (sscanf(line, \"%*s%*s%*s%*s%d%*s%*s%63s\", &width, glyph) != 2)\n\t    continue;\n\n\t  for (ch = 0; ch < 256; ch ++)\n\t    if (_htmlGlyphs[ch] && strcmp(_htmlGlyphs[ch], glyph) == 0)\n\t      break;\n\n\t  if (ch < 256)\n\t    widths[ch] = width;\n\t}\n\telse\n\t{\n\t /*\n\t  * Symbol font uses its own encoding...\n\t  */\n\n\t  if (sscanf(line, \"%*s%d%*s%*s%d\", &ch, &width) != 2)\n\t    continue;\n\n\t  if (ch >= 0 && ch < 256)\n\t    widths[ch] = width;\n\t}\n      }\n    }\n\n    fclose(fp);\n\n   /*\n    * Write the font descriptor...\n    */\n\n    pdf_start_object(out);\n    fputs(\"/Type/FontDescriptor\", out);\n    fprintf(out, \"/Ascent %d\", ascent);\n    fprintf(out, \"/Descent %d\", descent);\n    fprintf(out, \"/CapHeight %d\", cap_height);\n    fprintf(out, \"/XHeight %d\", x_height);\n    fprintf(out, \"/FontBBox[%d %d %d %d]\", bbox[0], bbox[1], bbox[2], bbox[3]);\n    fprintf(out, \"/ItalicAngle %d\", italic_angle);\n    fprintf(out, \"/StemV %d\", widths['v']);\n    fprintf(out, \"/Flags %d\", tflags[typeface] | sflags[style]);\n    fprintf(out, \"/FontName/%s\", _htmlFonts[typeface][style]);\n    fprintf(out, \"/FontFile %d 0 R\", (int)num_objects - 1);\n    pdf_end_object(out);\n\n   /*\n    * Write the character widths...\n    */\n\n    pdf_start_object(out, 1);\n    fprintf(out, \"%d\", widths[0]);\n    for (ch = 1; ch < 256; ch ++)\n      fprintf(out, \" %d\", widths[ch]);\n    pdf_end_object(out);\n  }\n\n /*\n  * Return the font descriptor...\n  */\n\n  return (num_objects - 1);\n}\n\n\n/*\n * 'write_utf16()' - Write a UTF-16 string...\n */\n\nstatic void\nwrite_utf16(FILE  *out,\t\t\t// I - File to write to\n            uchar *s)\t\t\t// I - String to write\n{\n  uchar *sptr;\t\t\t\t// Pointer into string\n\n\n /*\n  * We start by checking to see if the string is composed only of\n  * ASCII characters; if so, we can just write a normal string...\n  */\n\n  for (sptr = s; *sptr && !(*sptr & 0x80); sptr ++);\n  if (!*sptr)\n  {\n   /*\n    * Write an ASCII string...\n    */\n\n    write_string(out, s, 0);\n  }\n  else if (Encryption)\n  {\n   /*\n    * Convert the string to Unicode and encrypt...\n    */\n\n    int\t\tch;\t\t\t// Character value\n    uchar\tunicode[2],\t\t// Unicode character\n\t\tenicode[2];\t\t// Encrypted unicode character\n\n\n    putc('<', out);\n    encrypt_init();\n\n    unicode[0] = 0xfe;\t\t\t// Start with BOM\n    unicode[1] = 0xff;\n\n    rc4_encrypt(&encrypt_state, unicode, enicode, 2);\n\n    fprintf(out, \"%02x%02x\", enicode[0], enicode[1]);\n\n    for (sptr = s; *sptr; sptr ++)\n    {\n      ch         = _htmlUnicode[*sptr];\n      unicode[0] = (uchar)(ch >> 8);\n      unicode[1] = (uchar)ch;\n\n      rc4_encrypt(&encrypt_state, unicode, enicode, 2);\n\n      fprintf(out, \"%02x%02x\", enicode[0], enicode[1]);\n    }\n\n    putc('>', out);\n  }\n  else\n  {\n   /*\n    * Convert the string to Unicode...\n    */\n\n    fputs(\"<feff\", out);\t\t// Start with BOM\n    for (sptr = s; *sptr; sptr ++)\n      fprintf(out, \"%04x\", _htmlUnicode[*sptr]);\n    putc('>', out);\n  }\n}\n\n\n/*\n * 'encrypt_init()' - Initialize the RC4 encryption context for the current\n *                    object.\n */\n\nstatic void\nencrypt_init(void)\n{\n  int\t\ti;\t\t\t/* Looping var */\n  uchar\t\tdata[21],\t\t/* Key data */\n\t\t*dataptr;\t\t/* Pointer to key data */\n  md5_state_t\tmd5;\t\t\t/* MD5 state */\n  md5_byte_t\tdigest[16];\t\t/* MD5 digest value */\n\n\n /*\n  * Compute the key data for the MD5 hash.\n  */\n\n  for (i = 0, dataptr = data; i < encrypt_len; i ++)\n    *dataptr++ = encrypt_key[i];\n\n  *dataptr++ = (uchar)num_objects;\n  *dataptr++ = (uchar)(num_objects >> 8);\n  *dataptr++ = (uchar)(num_objects >> 16);\n  *dataptr++ = 0;\n  *dataptr++ = 0;\n\n /*\n  * Hash it...\n  */\n\n  md5_init(&md5);\n  md5_append(&md5, data, encrypt_len + 5);\n  md5_finish(&md5, digest);\n\n /*\n  * Initialize the RC4 context using the first N+5 bytes of the digest...\n  */\n\n  if (encrypt_len > 11)\n    rc4_init(&encrypt_state, digest, 16);\n  else\n    rc4_init(&encrypt_state, digest, (size_t)(encrypt_len + 5));\n}\n\n\n/*\n * 'flate_open_stream()' - Open a deflated output stream.\n */\n\nstatic void\nflate_open_stream(FILE *out)\t\t/* I - Output file */\n{\n  if (Encryption && !PSLevel)\n    encrypt_init();\n\n  if (!Compression)\n    return;\n\n  compressor_active = 1;\n  compressor.zalloc = (alloc_func)0;\n  compressor.zfree  = (free_func)0;\n  compressor.opaque = (voidpf)0;\n\n  deflateInit(&compressor, Compression);\n\n  compressor.next_out  = (Bytef *)comp_buffer;\n  compressor.avail_out = sizeof(comp_buffer);\n}\n\n\n/*\n * 'flate_close_stream()' - Close a deflated output stream.\n */\n\nstatic void\nflate_close_stream(FILE *out)\t\t/* I - Output file */\n{\n  int\tstatus;\t\t\t\t/* Deflate status */\n\n\n  if (!Compression)\n  {\n#ifdef HTMLDOC_ASCII85\n    if (PSLevel)\n      ps_ascii85(out, (uchar *)\"\", 0, 1);\n#endif // HTMLDOC_ASCII85\n\n    return;\n  }\n\n  while ((status = deflate(&compressor, Z_FINISH)) != Z_STREAM_END)\n  {\n    if (status < Z_OK && status != Z_BUF_ERROR)\n    {\n      progress_error(HD_ERROR_OUT_OF_MEMORY, \"deflate() failed (%d)\", status);\n      return;\n    }\n\n    if (PSLevel)\n#ifdef HTMLDOC_ASCII85\n      ps_ascii85(out, comp_buffer,\n                 (uchar *)compressor.next_out - (uchar *)comp_buffer);\n#else\n      ps_hex(out, comp_buffer,\n             (uchar *)compressor.next_out - (uchar *)comp_buffer);\n#endif // HTMLDOC_ASCII85\n    else\n    {\n      if (Encryption)\n        rc4_encrypt(&encrypt_state, comp_buffer, comp_buffer,\n\t            (uchar *)compressor.next_out - (uchar *)comp_buffer);\n\n      fwrite(comp_buffer, (size_t)((uchar *)compressor.next_out - (uchar *)comp_buffer), 1, out);\n    }\n\n    compressor.next_out  = (Bytef *)comp_buffer;\n    compressor.avail_out = sizeof(comp_buffer);\n  }\n\n  if ((uchar *)compressor.next_out > (uchar *)comp_buffer)\n  {\n    if (PSLevel)\n#ifdef HTMLDOC_ASCII85\n      ps_ascii85(out, comp_buffer,\n                 (uchar *)compressor.next_out - (uchar *)comp_buffer);\n#else\n      ps_hex(out, comp_buffer,\n             (uchar *)compressor.next_out - (uchar *)comp_buffer);\n#endif // HTMLDOC_ASCII85\n    else\n    {\n      if (Encryption)\n        rc4_encrypt(&encrypt_state, comp_buffer, comp_buffer,\n\t            (uchar *)compressor.next_out - (uchar *)comp_buffer);\n\n      fwrite(comp_buffer, (size_t)((uchar *)compressor.next_out - (uchar *)comp_buffer), 1, out);\n    }\n\n  }\n\n  deflateEnd(&compressor);\n\n  compressor_active = 0;\n\n#ifdef HTMLDOC_ASCII85\n  if (PSLevel)\n    ps_ascii85(out, (uchar *)\"\", 0, 1);\n#else\n  if (PSLevel)\n  {\n    // End of data marker...\n    fputs(\">\\n\", out);\n  }\n#endif // HTMLDOC_ASCII85\n}\n\n\n/*\n * 'flate_puts()' - Write a character string to a compressed stream.\n */\n\nstatic void\nflate_puts(const char *s,\t\t/* I - String to write */\n           FILE       *out)\t\t/* I - Output file */\n{\n  flate_write(out, (uchar *)s, strlen(s));\n}\n\n\n/*\n * 'flate_printf()' - Write a formatted character string to a compressed stream.\n */\n\nstatic void\nflate_printf(FILE       *out,\t\t/* I - Output file */\n             const char *format,\t/* I - Format string */\n             ...)\t\t\t/* I - Additional args as necessary */\n{\n  int\t\tlength;\t\t\t/* Length of output string */\n  char\t\tbuf[10240];\t\t/* Output buffer */\n  va_list\tap;\t\t\t/* Argument pointer */\n\n\n  va_start(ap, format);\n  length = vsnprintf(buf, sizeof(buf), format, ap);\n  va_end(ap);\n\n  flate_write(out, (uchar *)buf, length);\n}\n\n\n/*\n * 'flate_write()' - Write data to a compressed stream.\n */\n\nstatic void\nflate_write(FILE  *out,\t\t\t/* I - Output file */\n            uchar *buf,\t\t\t/* I - Buffer */\n            int   length,\t\t/* I - Number of bytes to write */\n\t    int   flush)\t\t/* I - Flush when writing data? */\n{\n  int\tstatus;\t\t\t\t/* Deflate status */\n\n\n  if (compressor_active)\n  {\n    compressor.next_in  = buf;\n    compressor.avail_in = (unsigned)length;\n\n    while (compressor.avail_in > 0)\n    {\n      if (compressor.avail_out < (int)(sizeof(comp_buffer) / 8))\n      {\n\tif (PSLevel)\n#ifdef HTMLDOC_ASCII85\n\t  ps_ascii85(out, comp_buffer,\n                     (uchar *)compressor.next_out - (uchar *)comp_buffer);\n#else\n\t  ps_hex(out, comp_buffer,\n                 (uchar *)compressor.next_out - (uchar *)comp_buffer);\n#endif // HTMLDOC_ASCII85\n\telse\n\t{\n\t  if (Encryption)\n            rc4_encrypt(&encrypt_state, comp_buffer, comp_buffer,\n\t        \t(uchar *)compressor.next_out - (uchar *)comp_buffer);\n\n\t  fwrite(comp_buffer, (size_t)((uchar *)compressor.next_out - (uchar *)comp_buffer), 1, out);\n\t}\n\n\tcompressor.next_out  = (Bytef *)comp_buffer;\n\tcompressor.avail_out = sizeof(comp_buffer);\n      }\n\n      status = deflate(&compressor, flush ? Z_FULL_FLUSH : Z_NO_FLUSH);\n\n      if (status < Z_OK && status != Z_BUF_ERROR)\n      {\n\tprogress_error(HD_ERROR_OUT_OF_MEMORY, \"deflate() failed (%d)\", status);\n\treturn;\n      }\n\n      flush = 0;\n    }\n  }\n  else if (Encryption && !PSLevel)\n  {\n    int\t\ti,\t\t// Looping var\n\t\tbytes;\t\t// Number of bytes to encrypt/write\n    uchar\tnewbuf[1024];\t// New encrypted data buffer\n\n\n    for (i = 0; i < length; i += sizeof(newbuf))\n    {\n      if ((bytes = length - i) > (int)sizeof(newbuf))\n        bytes = sizeof(newbuf);\n\n      rc4_encrypt(&encrypt_state, buf + i, newbuf, (size_t)bytes);\n      fwrite(newbuf, (size_t)bytes, 1, out);\n    }\n  }\n  else if (PSLevel)\n#ifdef HTMLDOC_ASCII85\n    ps_ascii85(out, buf, length);\n#else\n    ps_hex(out, buf, length);\n#endif // HTMLDOC_ASCII85\n  else\n    fwrite(buf, (size_t)length, 1, out);\n}\n"], "filenames": ["CHANGES.md", "htmldoc/ps-pdf.cxx"], "buggy_code_start_loc": [3, 6381], "buggy_code_end_loc": [3, 6442], "fixing_code_start_loc": [4, 6382], "fixing_code_end_loc": [5, 6457], "type": "CWE-787", "message": "A flaw was found in htmldoc in v1.9.12. Heap buffer overflow in render_table_row(),in ps-pdf.cxx may lead to arbitrary code execution and denial of service.", "other": {"cve": {"id": "CVE-2021-26259", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-03T23:15:08.033", "lastModified": "2022-12-02T19:46:37.503", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in htmldoc in v1.9.12. Heap buffer overflow in render_table_row(),in ps-pdf.cxx may lead to arbitrary code execution and denial of service."}, {"lang": "es", "value": "Se ha encontrado un fallo en htmldoc en versi\u00f3n v1.9.12. Un desbordamiento del b\u00fafer de la pila en la funci\u00f3n render_table_row(),en el archivo ps-pdf.cxx puede conllevar a una ejecuci\u00f3n de c\u00f3digo arbitrario y una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:htmldoc_project:htmldoc:1.9.12:*:*:*:*:*:*:*", "matchCriteriaId": "645554AD-DA7C-4B11-864A-89F423B08291"}]}]}], "references": [{"url": "https://github.com/michaelrsweet/htmldoc/commit/0ddab26a542c74770317b622e985c52430092ba5", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/michaelrsweet/htmldoc/issues/417", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/michaelrsweet/htmldoc/commit/0ddab26a542c74770317b622e985c52430092ba5"}}