{"buggy_code": ["#include \"cache.h\"\n#include \"config.h\"\n#include \"credential.h\"\n#include \"string-list.h\"\n#include \"run-command.h\"\n#include \"url.h\"\n#include \"prompt.h\"\n\nvoid credential_init(struct credential *c)\n{\n\tmemset(c, 0, sizeof(*c));\n\tc->helpers.strdup_strings = 1;\n}\n\nvoid credential_clear(struct credential *c)\n{\n\tfree(c->protocol);\n\tfree(c->host);\n\tfree(c->path);\n\tfree(c->username);\n\tfree(c->password);\n\tstring_list_clear(&c->helpers, 0);\n\n\tcredential_init(c);\n}\n\nint credential_match(const struct credential *want,\n\t\t     const struct credential *have)\n{\n#define CHECK(x) (!want->x || (have->x && !strcmp(want->x, have->x)))\n\treturn CHECK(protocol) &&\n\t       CHECK(host) &&\n\t       CHECK(path) &&\n\t       CHECK(username);\n#undef CHECK\n}\n\nstatic int credential_config_callback(const char *var, const char *value,\n\t\t\t\t      void *data)\n{\n\tstruct credential *c = data;\n\tconst char *key, *dot;\n\n\tif (!skip_prefix(var, \"credential.\", &key))\n\t\treturn 0;\n\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\n\tdot = strrchr(key, '.');\n\tif (dot) {\n\t\tstruct credential want = CREDENTIAL_INIT;\n\t\tchar *url = xmemdupz(key, dot - key);\n\t\tint matched;\n\n\t\tcredential_from_url(&want, url);\n\t\tmatched = credential_match(&want, c);\n\n\t\tcredential_clear(&want);\n\t\tfree(url);\n\n\t\tif (!matched)\n\t\t\treturn 0;\n\t\tkey = dot + 1;\n\t}\n\n\tif (!strcmp(key, \"helper\")) {\n\t\tif (*value)\n\t\t\tstring_list_append(&c->helpers, value);\n\t\telse\n\t\t\tstring_list_clear(&c->helpers, 0);\n\t} else if (!strcmp(key, \"username\")) {\n\t\tif (!c->username)\n\t\t\tc->username = xstrdup(value);\n\t}\n\telse if (!strcmp(key, \"usehttppath\"))\n\t\tc->use_http_path = git_config_bool(var, value);\n\n\treturn 0;\n}\n\nstatic int proto_is_http(const char *s)\n{\n\tif (!s)\n\t\treturn 0;\n\treturn !strcmp(s, \"https\") || !strcmp(s, \"http\");\n}\n\nstatic void credential_apply_config(struct credential *c)\n{\n\tif (!c->host)\n\t\tdie(_(\"refusing to work with credential missing host field\"));\n\tif (!c->protocol)\n\t\tdie(_(\"refusing to work with credential missing protocol field\"));\n\n\tif (c->configured)\n\t\treturn;\n\tgit_config(credential_config_callback, c);\n\tc->configured = 1;\n\n\tif (!c->use_http_path && proto_is_http(c->protocol)) {\n\t\tFREE_AND_NULL(c->path);\n\t}\n}\n\nstatic void credential_describe(struct credential *c, struct strbuf *out)\n{\n\tif (!c->protocol)\n\t\treturn;\n\tstrbuf_addf(out, \"%s://\", c->protocol);\n\tif (c->username && *c->username)\n\t\tstrbuf_addf(out, \"%s@\", c->username);\n\tif (c->host)\n\t\tstrbuf_addstr(out, c->host);\n\tif (c->path)\n\t\tstrbuf_addf(out, \"/%s\", c->path);\n}\n\nstatic char *credential_ask_one(const char *what, struct credential *c,\n\t\t\t\tint flags)\n{\n\tstruct strbuf desc = STRBUF_INIT;\n\tstruct strbuf prompt = STRBUF_INIT;\n\tchar *r;\n\n\tcredential_describe(c, &desc);\n\tif (desc.len)\n\t\tstrbuf_addf(&prompt, \"%s for '%s': \", what, desc.buf);\n\telse\n\t\tstrbuf_addf(&prompt, \"%s: \", what);\n\n\tr = git_prompt(prompt.buf, flags);\n\n\tstrbuf_release(&desc);\n\tstrbuf_release(&prompt);\n\treturn xstrdup(r);\n}\n\nstatic void credential_getpass(struct credential *c)\n{\n\tif (!c->username)\n\t\tc->username = credential_ask_one(\"Username\", c,\n\t\t\t\t\t\t PROMPT_ASKPASS|PROMPT_ECHO);\n\tif (!c->password)\n\t\tc->password = credential_ask_one(\"Password\", c,\n\t\t\t\t\t\t PROMPT_ASKPASS);\n}\n\nint credential_read(struct credential *c, FILE *fp)\n{\n\tstruct strbuf line = STRBUF_INIT;\n\n\twhile (strbuf_getline_lf(&line, fp) != EOF) {\n\t\tchar *key = line.buf;\n\t\tchar *value = strchr(key, '=');\n\n\t\tif (!line.len)\n\t\t\tbreak;\n\n\t\tif (!value) {\n\t\t\twarning(\"invalid credential line: %s\", key);\n\t\t\tstrbuf_release(&line);\n\t\t\treturn -1;\n\t\t}\n\t\t*value++ = '\\0';\n\n\t\tif (!strcmp(key, \"username\")) {\n\t\t\tfree(c->username);\n\t\t\tc->username = xstrdup(value);\n\t\t} else if (!strcmp(key, \"password\")) {\n\t\t\tfree(c->password);\n\t\t\tc->password = xstrdup(value);\n\t\t} else if (!strcmp(key, \"protocol\")) {\n\t\t\tfree(c->protocol);\n\t\t\tc->protocol = xstrdup(value);\n\t\t} else if (!strcmp(key, \"host\")) {\n\t\t\tfree(c->host);\n\t\t\tc->host = xstrdup(value);\n\t\t} else if (!strcmp(key, \"path\")) {\n\t\t\tfree(c->path);\n\t\t\tc->path = xstrdup(value);\n\t\t} else if (!strcmp(key, \"url\")) {\n\t\t\tcredential_from_url(c, value);\n\t\t} else if (!strcmp(key, \"quit\")) {\n\t\t\tc->quit = !!git_config_bool(\"quit\", value);\n\t\t}\n\t\t/*\n\t\t * Ignore other lines; we don't know what they mean, but\n\t\t * this future-proofs us when later versions of git do\n\t\t * learn new lines, and the helpers are updated to match.\n\t\t */\n\t}\n\n\tstrbuf_release(&line);\n\treturn 0;\n}\n\nstatic void credential_write_item(FILE *fp, const char *key, const char *value,\n\t\t\t\t  int required)\n{\n\tif (!value && required)\n\t\tBUG(\"credential value for %s is missing\", key);\n\tif (!value)\n\t\treturn;\n\tif (strchr(value, '\\n'))\n\t\tdie(\"credential value for %s contains newline\", key);\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}\n\nvoid credential_write(const struct credential *c, FILE *fp)\n{\n\tcredential_write_item(fp, \"protocol\", c->protocol, 1);\n\tcredential_write_item(fp, \"host\", c->host, 1);\n\tcredential_write_item(fp, \"path\", c->path, 0);\n\tcredential_write_item(fp, \"username\", c->username, 0);\n\tcredential_write_item(fp, \"password\", c->password, 0);\n}\n\nstatic int run_credential_helper(struct credential *c,\n\t\t\t\t const char *cmd,\n\t\t\t\t int want_output)\n{\n\tstruct child_process helper = CHILD_PROCESS_INIT;\n\tconst char *argv[] = { NULL, NULL };\n\tFILE *fp;\n\n\targv[0] = cmd;\n\thelper.argv = argv;\n\thelper.use_shell = 1;\n\thelper.in = -1;\n\tif (want_output)\n\t\thelper.out = -1;\n\telse\n\t\thelper.no_stdout = 1;\n\n\tif (start_command(&helper) < 0)\n\t\treturn -1;\n\n\tfp = xfdopen(helper.in, \"w\");\n\tcredential_write(c, fp);\n\tfclose(fp);\n\n\tif (want_output) {\n\t\tint r;\n\t\tfp = xfdopen(helper.out, \"r\");\n\t\tr = credential_read(c, fp);\n\t\tfclose(fp);\n\t\tif (r < 0) {\n\t\t\tfinish_command(&helper);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (finish_command(&helper))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int credential_do(struct credential *c, const char *helper,\n\t\t\t const char *operation)\n{\n\tstruct strbuf cmd = STRBUF_INIT;\n\tint r;\n\n\tif (helper[0] == '!')\n\t\tstrbuf_addstr(&cmd, helper + 1);\n\telse if (is_absolute_path(helper))\n\t\tstrbuf_addstr(&cmd, helper);\n\telse\n\t\tstrbuf_addf(&cmd, \"git credential-%s\", helper);\n\n\tstrbuf_addf(&cmd, \" %s\", operation);\n\tr = run_credential_helper(c, cmd.buf, !strcmp(operation, \"get\"));\n\n\tstrbuf_release(&cmd);\n\treturn r;\n}\n\nvoid credential_fill(struct credential *c)\n{\n\tint i;\n\n\tif (c->username && c->password)\n\t\treturn;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++) {\n\t\tcredential_do(c, c->helpers.items[i].string, \"get\");\n\t\tif (c->username && c->password)\n\t\t\treturn;\n\t\tif (c->quit)\n\t\t\tdie(\"credential helper '%s' told us to quit\",\n\t\t\t    c->helpers.items[i].string);\n\t}\n\n\tcredential_getpass(c);\n\tif (!c->username && !c->password)\n\t\tdie(\"unable to get password from user\");\n}\n\nvoid credential_approve(struct credential *c)\n{\n\tint i;\n\n\tif (c->approved)\n\t\treturn;\n\tif (!c->username || !c->password)\n\t\treturn;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++)\n\t\tcredential_do(c, c->helpers.items[i].string, \"store\");\n\tc->approved = 1;\n}\n\nvoid credential_reject(struct credential *c)\n{\n\tint i;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++)\n\t\tcredential_do(c, c->helpers.items[i].string, \"erase\");\n\n\tFREE_AND_NULL(c->username);\n\tFREE_AND_NULL(c->password);\n\tc->approved = 0;\n}\n\nstatic int check_url_component(const char *url, int quiet,\n\t\t\t       const char *name, const char *value)\n{\n\tif (!value)\n\t\treturn 0;\n\tif (!strchr(value, '\\n'))\n\t\treturn 0;\n\n\tif (!quiet)\n\t\twarning(_(\"url contains a newline in its %s component: %s\"),\n\t\t\tname, url);\n\treturn -1;\n}\n\nint credential_from_url_gently(struct credential *c, const char *url,\n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \"://\");\n\tif (!proto_end)\n\t\treturn 0;\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\n\tif (check_url_component(url, quiet, \"username\", c->username) < 0 ||\n\t    check_url_component(url, quiet, \"password\", c->password) < 0 ||\n\t    check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \"host\", c->host) < 0 ||\n\t    check_url_component(url, quiet, \"path\", c->path) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nvoid credential_from_url(struct credential *c, const char *url)\n{\n\tif (credential_from_url_gently(c, url, 0) < 0)\n\t\tdie(_(\"credential url cannot be parsed: %s\"), url);\n}\n", "#include \"cache.h\"\n#include \"object.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"tree-walk.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"fsck.h\"\n#include \"refs.h\"\n#include \"url.h\"\n#include \"utf8.h\"\n#include \"sha1-array.h\"\n#include \"decorate.h\"\n#include \"oidset.h\"\n#include \"packfile.h\"\n#include \"submodule-config.h\"\n#include \"config.h\"\n#include \"credential.h\"\n\nstatic struct oidset gitmodules_found = OIDSET_INIT;\nstatic struct oidset gitmodules_done = OIDSET_INIT;\n\n#define FSCK_FATAL -1\n#define FSCK_INFO -2\n\n#define FOREACH_MSG_ID(FUNC) \\\n\t/* fatal errors */ \\\n\tFUNC(NUL_IN_HEADER, FATAL) \\\n\tFUNC(UNTERMINATED_HEADER, FATAL) \\\n\t/* errors */ \\\n\tFUNC(BAD_DATE, ERROR) \\\n\tFUNC(BAD_DATE_OVERFLOW, ERROR) \\\n\tFUNC(BAD_EMAIL, ERROR) \\\n\tFUNC(BAD_NAME, ERROR) \\\n\tFUNC(BAD_OBJECT_SHA1, ERROR) \\\n\tFUNC(BAD_PARENT_SHA1, ERROR) \\\n\tFUNC(BAD_TAG_OBJECT, ERROR) \\\n\tFUNC(BAD_TIMEZONE, ERROR) \\\n\tFUNC(BAD_TREE, ERROR) \\\n\tFUNC(BAD_TREE_SHA1, ERROR) \\\n\tFUNC(BAD_TYPE, ERROR) \\\n\tFUNC(DUPLICATE_ENTRIES, ERROR) \\\n\tFUNC(MISSING_AUTHOR, ERROR) \\\n\tFUNC(MISSING_COMMITTER, ERROR) \\\n\tFUNC(MISSING_EMAIL, ERROR) \\\n\tFUNC(MISSING_GRAFT, ERROR) \\\n\tFUNC(MISSING_NAME_BEFORE_EMAIL, ERROR) \\\n\tFUNC(MISSING_OBJECT, ERROR) \\\n\tFUNC(MISSING_PARENT, ERROR) \\\n\tFUNC(MISSING_SPACE_BEFORE_DATE, ERROR) \\\n\tFUNC(MISSING_SPACE_BEFORE_EMAIL, ERROR) \\\n\tFUNC(MISSING_TAG, ERROR) \\\n\tFUNC(MISSING_TAG_ENTRY, ERROR) \\\n\tFUNC(MISSING_TAG_OBJECT, ERROR) \\\n\tFUNC(MISSING_TREE, ERROR) \\\n\tFUNC(MISSING_TREE_OBJECT, ERROR) \\\n\tFUNC(MISSING_TYPE, ERROR) \\\n\tFUNC(MISSING_TYPE_ENTRY, ERROR) \\\n\tFUNC(MULTIPLE_AUTHORS, ERROR) \\\n\tFUNC(TAG_OBJECT_NOT_TAG, ERROR) \\\n\tFUNC(TREE_NOT_SORTED, ERROR) \\\n\tFUNC(UNKNOWN_TYPE, ERROR) \\\n\tFUNC(ZERO_PADDED_DATE, ERROR) \\\n\tFUNC(GITMODULES_MISSING, ERROR) \\\n\tFUNC(GITMODULES_BLOB, ERROR) \\\n\tFUNC(GITMODULES_PARSE, ERROR) \\\n\tFUNC(GITMODULES_NAME, ERROR) \\\n\tFUNC(GITMODULES_SYMLINK, ERROR) \\\n\tFUNC(GITMODULES_URL, ERROR) \\\n\tFUNC(GITMODULES_PATH, ERROR) \\\n\tFUNC(GITMODULES_UPDATE, ERROR) \\\n\t/* warnings */ \\\n\tFUNC(BAD_FILEMODE, WARN) \\\n\tFUNC(EMPTY_NAME, WARN) \\\n\tFUNC(FULL_PATHNAME, WARN) \\\n\tFUNC(HAS_DOT, WARN) \\\n\tFUNC(HAS_DOTDOT, WARN) \\\n\tFUNC(HAS_DOTGIT, WARN) \\\n\tFUNC(NULL_SHA1, WARN) \\\n\tFUNC(ZERO_PADDED_FILEMODE, WARN) \\\n\tFUNC(NUL_IN_COMMIT, WARN) \\\n\t/* infos (reported as warnings, but ignored by default) */ \\\n\tFUNC(BAD_TAG_NAME, INFO) \\\n\tFUNC(MISSING_TAGGER_ENTRY, INFO)\n\n#define MSG_ID(id, msg_type) FSCK_MSG_##id,\nenum fsck_msg_id {\n\tFOREACH_MSG_ID(MSG_ID)\n\tFSCK_MSG_MAX\n};\n#undef MSG_ID\n\n#define STR(x) #x\n#define MSG_ID(id, msg_type) { STR(id), NULL, FSCK_##msg_type },\nstatic struct {\n\tconst char *id_string;\n\tconst char *downcased;\n\tint msg_type;\n} msg_id_info[FSCK_MSG_MAX + 1] = {\n\tFOREACH_MSG_ID(MSG_ID)\n\t{ NULL, NULL, -1 }\n};\n#undef MSG_ID\n\nstatic int parse_msg_id(const char *text)\n{\n\tint i;\n\n\tif (!msg_id_info[0].downcased) {\n\t\t/* convert id_string to lower case, without underscores. */\n\t\tfor (i = 0; i < FSCK_MSG_MAX; i++) {\n\t\t\tconst char *p = msg_id_info[i].id_string;\n\t\t\tint len = strlen(p);\n\t\t\tchar *q = xmalloc(len);\n\n\t\t\tmsg_id_info[i].downcased = q;\n\t\t\twhile (*p)\n\t\t\t\tif (*p == '_')\n\t\t\t\t\tp++;\n\t\t\t\telse\n\t\t\t\t\t*(q)++ = tolower(*(p)++);\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\n\tfor (i = 0; i < FSCK_MSG_MAX; i++)\n\t\tif (!strcmp(text, msg_id_info[i].downcased))\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic int fsck_msg_type(enum fsck_msg_id msg_id,\n\tstruct fsck_options *options)\n{\n\tint msg_type;\n\n\tassert(msg_id >= 0 && msg_id < FSCK_MSG_MAX);\n\n\tif (options->msg_type)\n\t\tmsg_type = options->msg_type[msg_id];\n\telse {\n\t\tmsg_type = msg_id_info[msg_id].msg_type;\n\t\tif (options->strict && msg_type == FSCK_WARN)\n\t\t\tmsg_type = FSCK_ERROR;\n\t}\n\n\treturn msg_type;\n}\n\nstatic void init_skiplist(struct fsck_options *options, const char *path)\n{\n\tstatic struct oid_array skiplist = OID_ARRAY_INIT;\n\tint sorted, fd;\n\tchar buffer[GIT_MAX_HEXSZ + 1];\n\tstruct object_id oid;\n\n\tif (options->skiplist)\n\t\tsorted = options->skiplist->sorted;\n\telse {\n\t\tsorted = 1;\n\t\toptions->skiplist = &skiplist;\n\t}\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tdie(\"Could not open skip list: %s\", path);\n\tfor (;;) {\n\t\tconst char *p;\n\t\tint result = read_in_full(fd, buffer, sizeof(buffer));\n\t\tif (result < 0)\n\t\t\tdie_errno(\"Could not read '%s'\", path);\n\t\tif (!result)\n\t\t\tbreak;\n\t\tif (parse_oid_hex(buffer, &oid, &p) || *p != '\\n')\n\t\t\tdie(\"Invalid SHA-1: %s\", buffer);\n\t\toid_array_append(&skiplist, &oid);\n\t\tif (sorted && skiplist.nr > 1 &&\n\t\t\t\toidcmp(&skiplist.oid[skiplist.nr - 2],\n\t\t\t\t       &oid) > 0)\n\t\t\tsorted = 0;\n\t}\n\tclose(fd);\n\n\tif (sorted)\n\t\tskiplist.sorted = 1;\n}\n\nstatic int parse_msg_type(const char *str)\n{\n\tif (!strcmp(str, \"error\"))\n\t\treturn FSCK_ERROR;\n\telse if (!strcmp(str, \"warn\"))\n\t\treturn FSCK_WARN;\n\telse if (!strcmp(str, \"ignore\"))\n\t\treturn FSCK_IGNORE;\n\telse\n\t\tdie(\"Unknown fsck message type: '%s'\", str);\n}\n\nint is_valid_msg_type(const char *msg_id, const char *msg_type)\n{\n\tif (parse_msg_id(msg_id) < 0)\n\t\treturn 0;\n\tparse_msg_type(msg_type);\n\treturn 1;\n}\n\nvoid fsck_set_msg_type(struct fsck_options *options,\n\t\tconst char *msg_id, const char *msg_type)\n{\n\tint id = parse_msg_id(msg_id), type;\n\n\tif (id < 0)\n\t\tdie(\"Unhandled message id: %s\", msg_id);\n\ttype = parse_msg_type(msg_type);\n\n\tif (type != FSCK_ERROR && msg_id_info[id].msg_type == FSCK_FATAL)\n\t\tdie(\"Cannot demote %s to %s\", msg_id, msg_type);\n\n\tif (!options->msg_type) {\n\t\tint i;\n\t\tint *msg_type;\n\t\tALLOC_ARRAY(msg_type, FSCK_MSG_MAX);\n\t\tfor (i = 0; i < FSCK_MSG_MAX; i++)\n\t\t\tmsg_type[i] = fsck_msg_type(i, options);\n\t\toptions->msg_type = msg_type;\n\t}\n\n\toptions->msg_type[id] = type;\n}\n\nvoid fsck_set_msg_types(struct fsck_options *options, const char *values)\n{\n\tchar *buf = xstrdup(values), *to_free = buf;\n\tint done = 0;\n\n\twhile (!done) {\n\t\tint len = strcspn(buf, \" ,|\"), equal;\n\n\t\tdone = !buf[len];\n\t\tif (!len) {\n\t\t\tbuf++;\n\t\t\tcontinue;\n\t\t}\n\t\tbuf[len] = '\\0';\n\n\t\tfor (equal = 0;\n\t\t     equal < len && buf[equal] != '=' && buf[equal] != ':';\n\t\t     equal++)\n\t\t\tbuf[equal] = tolower(buf[equal]);\n\t\tbuf[equal] = '\\0';\n\n\t\tif (!strcmp(buf, \"skiplist\")) {\n\t\t\tif (equal == len)\n\t\t\t\tdie(\"skiplist requires a path\");\n\t\t\tinit_skiplist(options, buf + equal + 1);\n\t\t\tbuf += len + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (equal == len)\n\t\t\tdie(\"Missing '=': '%s'\", buf);\n\n\t\tfsck_set_msg_type(options, buf, buf + equal + 1);\n\t\tbuf += len + 1;\n\t}\n\tfree(to_free);\n}\n\nstatic void append_msg_id(struct strbuf *sb, const char *msg_id)\n{\n\tfor (;;) {\n\t\tchar c = *(msg_id)++;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (c != '_')\n\t\t\tstrbuf_addch(sb, tolower(c));\n\t\telse {\n\t\t\tassert(*msg_id);\n\t\t\tstrbuf_addch(sb, *(msg_id)++);\n\t\t}\n\t}\n\n\tstrbuf_addstr(sb, \": \");\n}\n\n__attribute__((format (printf, 4, 5)))\nstatic int report(struct fsck_options *options, struct object *object,\n\tenum fsck_msg_id id, const char *fmt, ...)\n{\n\tva_list ap;\n\tstruct strbuf sb = STRBUF_INIT;\n\tint msg_type = fsck_msg_type(id, options), result;\n\n\tif (msg_type == FSCK_IGNORE)\n\t\treturn 0;\n\n\tif (options->skiplist && object &&\n\t\t\toid_array_lookup(options->skiplist, &object->oid) >= 0)\n\t\treturn 0;\n\n\tif (msg_type == FSCK_FATAL)\n\t\tmsg_type = FSCK_ERROR;\n\telse if (msg_type == FSCK_INFO)\n\t\tmsg_type = FSCK_WARN;\n\n\tappend_msg_id(&sb, msg_id_info[id].id_string);\n\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(&sb, fmt, ap);\n\tresult = options->error_func(options, object, msg_type, sb.buf);\n\tstrbuf_release(&sb);\n\tva_end(ap);\n\n\treturn result;\n}\n\nstatic char *get_object_name(struct fsck_options *options, struct object *obj)\n{\n\tif (!options->object_names)\n\t\treturn NULL;\n\treturn lookup_decoration(options->object_names, obj);\n}\n\nstatic void put_object_name(struct fsck_options *options, struct object *obj,\n\tconst char *fmt, ...)\n{\n\tva_list ap;\n\tstruct strbuf buf = STRBUF_INIT;\n\tchar *existing;\n\n\tif (!options->object_names)\n\t\treturn;\n\texisting = lookup_decoration(options->object_names, obj);\n\tif (existing)\n\t\treturn;\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(&buf, fmt, ap);\n\tadd_decoration(options->object_names, obj, strbuf_detach(&buf, NULL));\n\tva_end(ap);\n}\n\nstatic const char *describe_object(struct fsck_options *o, struct object *obj)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\tchar *name;\n\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, oid_to_hex(&obj->oid));\n\tif (o->object_names && (name = lookup_decoration(o->object_names, obj)))\n\t\tstrbuf_addf(&buf, \" (%s)\", name);\n\n\treturn buf.buf;\n}\n\nstatic int fsck_walk_tree(struct tree *tree, void *data, struct fsck_options *options)\n{\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tint res = 0;\n\tconst char *name;\n\n\tif (parse_tree(tree))\n\t\treturn -1;\n\n\tname = get_object_name(options, &tree->object);\n\tif (init_tree_desc_gently(&desc, tree->buffer, tree->size))\n\t\treturn -1;\n\twhile (tree_entry_gently(&desc, &entry)) {\n\t\tstruct object *obj;\n\t\tint result;\n\n\t\tif (S_ISGITLINK(entry.mode))\n\t\t\tcontinue;\n\n\t\tif (S_ISDIR(entry.mode)) {\n\t\t\tobj = (struct object *)lookup_tree(entry.oid);\n\t\t\tif (name && obj)\n\t\t\t\tput_object_name(options, obj, \"%s%s/\", name,\n\t\t\t\t\tentry.path);\n\t\t\tresult = options->walk(obj, OBJ_TREE, data, options);\n\t\t}\n\t\telse if (S_ISREG(entry.mode) || S_ISLNK(entry.mode)) {\n\t\t\tobj = (struct object *)lookup_blob(entry.oid);\n\t\t\tif (name && obj)\n\t\t\t\tput_object_name(options, obj, \"%s%s\", name,\n\t\t\t\t\tentry.path);\n\t\t\tresult = options->walk(obj, OBJ_BLOB, data, options);\n\t\t}\n\t\telse {\n\t\t\tresult = error(\"in tree %s: entry %s has bad mode %.6o\",\n\t\t\t\t\tdescribe_object(options, &tree->object), entry.path, entry.mode);\n\t\t}\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tif (!res)\n\t\t\tres = result;\n\t}\n\treturn res;\n}\n\nstatic int fsck_walk_commit(struct commit *commit, void *data, struct fsck_options *options)\n{\n\tint counter = 0, generation = 0, name_prefix_len = 0;\n\tstruct commit_list *parents;\n\tint res;\n\tint result;\n\tconst char *name;\n\n\tif (parse_commit(commit))\n\t\treturn -1;\n\n\tname = get_object_name(options, &commit->object);\n\tif (name)\n\t\tput_object_name(options, &commit->tree->object, \"%s:\", name);\n\n\tresult = options->walk((struct object *)commit->tree, OBJ_TREE, data, options);\n\tif (result < 0)\n\t\treturn result;\n\tres = result;\n\n\tparents = commit->parents;\n\tif (name && parents) {\n\t\tint len = strlen(name), power;\n\n\t\tif (len && name[len - 1] == '^') {\n\t\t\tgeneration = 1;\n\t\t\tname_prefix_len = len - 1;\n\t\t}\n\t\telse { /* parse ~<generation> suffix */\n\t\t\tfor (generation = 0, power = 1;\n\t\t\t     len && isdigit(name[len - 1]);\n\t\t\t     power *= 10)\n\t\t\t\tgeneration += power * (name[--len] - '0');\n\t\t\tif (power > 1 && len && name[len - 1] == '~')\n\t\t\t\tname_prefix_len = len - 1;\n\t\t}\n\t}\n\n\twhile (parents) {\n\t\tif (name) {\n\t\t\tstruct object *obj = &parents->item->object;\n\n\t\t\tif (++counter > 1)\n\t\t\t\tput_object_name(options, obj, \"%s^%d\",\n\t\t\t\t\tname, counter);\n\t\t\telse if (generation > 0)\n\t\t\t\tput_object_name(options, obj, \"%.*s~%d\",\n\t\t\t\t\tname_prefix_len, name, generation + 1);\n\t\t\telse\n\t\t\t\tput_object_name(options, obj, \"%s^\", name);\n\t\t}\n\t\tresult = options->walk((struct object *)parents->item, OBJ_COMMIT, data, options);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tif (!res)\n\t\t\tres = result;\n\t\tparents = parents->next;\n\t}\n\treturn res;\n}\n\nstatic int fsck_walk_tag(struct tag *tag, void *data, struct fsck_options *options)\n{\n\tchar *name = get_object_name(options, &tag->object);\n\n\tif (parse_tag(tag))\n\t\treturn -1;\n\tif (name)\n\t\tput_object_name(options, tag->tagged, \"%s\", name);\n\treturn options->walk(tag->tagged, OBJ_ANY, data, options);\n}\n\nint fsck_walk(struct object *obj, void *data, struct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn -1;\n\n\tif (obj->type == OBJ_NONE)\n\t\tparse_object(&obj->oid);\n\n\tswitch (obj->type) {\n\tcase OBJ_BLOB:\n\t\treturn 0;\n\tcase OBJ_TREE:\n\t\treturn fsck_walk_tree((struct tree *)obj, data, options);\n\tcase OBJ_COMMIT:\n\t\treturn fsck_walk_commit((struct commit *)obj, data, options);\n\tcase OBJ_TAG:\n\t\treturn fsck_walk_tag((struct tag *)obj, data, options);\n\tdefault:\n\t\terror(\"Unknown object type for %s\", describe_object(options, obj));\n\t\treturn -1;\n\t}\n}\n\n/*\n * The entries in a tree are ordered in the _path_ order,\n * which means that a directory entry is ordered by adding\n * a slash to the end of it.\n *\n * So a directory called \"a\" is ordered _after_ a file\n * called \"a.c\", because \"a/\" sorts after \"a.c\".\n */\n#define TREE_UNORDERED (-1)\n#define TREE_HAS_DUPS  (-2)\n\nstatic int verify_ordered(unsigned mode1, const char *name1, unsigned mode2, const char *name2)\n{\n\tint len1 = strlen(name1);\n\tint len2 = strlen(name2);\n\tint len = len1 < len2 ? len1 : len2;\n\tunsigned char c1, c2;\n\tint cmp;\n\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp < 0)\n\t\treturn 0;\n\tif (cmp > 0)\n\t\treturn TREE_UNORDERED;\n\n\t/*\n\t * Ok, the first <len> characters are the same.\n\t * Now we need to order the next one, but turn\n\t * a '\\0' into a '/' for a directory entry.\n\t */\n\tc1 = name1[len];\n\tc2 = name2[len];\n\tif (!c1 && !c2)\n\t\t/*\n\t\t * git-write-tree used to write out a nonsense tree that has\n\t\t * entries with the same name, one blob and one tree.  Make\n\t\t * sure we do not have duplicate entries.\n\t\t */\n\t\treturn TREE_HAS_DUPS;\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\treturn c1 < c2 ? 0 : TREE_UNORDERED;\n}\n\nstatic int fsck_tree(struct tree *item, struct fsck_options *options)\n{\n\tint retval = 0;\n\tint has_null_sha1 = 0;\n\tint has_full_path = 0;\n\tint has_empty_name = 0;\n\tint has_dot = 0;\n\tint has_dotdot = 0;\n\tint has_dotgit = 0;\n\tint has_zero_pad = 0;\n\tint has_bad_modes = 0;\n\tint has_dup_entries = 0;\n\tint not_properly_sorted = 0;\n\tstruct tree_desc desc;\n\tunsigned o_mode;\n\tconst char *o_name;\n\n\tif (init_tree_desc_gently(&desc, item->buffer, item->size)) {\n\t\tretval += report(options, &item->object, FSCK_MSG_BAD_TREE, \"cannot be parsed as a tree\");\n\t\treturn retval;\n\t}\n\n\to_mode = 0;\n\to_name = NULL;\n\n\twhile (desc.size) {\n\t\tunsigned mode;\n\t\tconst char *name, *backslash;\n\t\tconst struct object_id *oid;\n\n\t\toid = tree_entry_extract(&desc, &name, &mode);\n\n\t\thas_null_sha1 |= is_null_oid(oid);\n\t\thas_full_path |= !!strchr(name, '/');\n\t\thas_empty_name |= !*name;\n\t\thas_dot |= !strcmp(name, \".\");\n\t\thas_dotdot |= !strcmp(name, \"..\");\n\t\thas_dotgit |= is_hfs_dotgit(name) || is_ntfs_dotgit(name);\n\t\thas_zero_pad |= *(char *)desc.buffer == '0';\n\n\t\tif (is_hfs_dotgitmodules(name) || is_ntfs_dotgitmodules(name)) {\n\t\t\tif (!S_ISLNK(mode))\n\t\t\t\toidset_insert(&gitmodules_found, oid);\n\t\t\telse\n\t\t\t\tretval += report(options, &item->object,\n\t\t\t\t\t\t FSCK_MSG_GITMODULES_SYMLINK,\n\t\t\t\t\t\t \".gitmodules is a symbolic link\");\n\t\t}\n\n\t\tif ((backslash = strchr(name, '\\\\'))) {\n\t\t\twhile (backslash) {\n\t\t\t\tbackslash++;\n\t\t\t\thas_dotgit |= is_ntfs_dotgit(backslash);\n\t\t\t\tif (is_ntfs_dotgitmodules(backslash)) {\n\t\t\t\t\tif (!S_ISLNK(mode))\n\t\t\t\t\t\toidset_insert(&gitmodules_found, oid);\n\t\t\t\t\telse\n\t\t\t\t\t\tretval += report(options, &item->object,\n\t\t\t\t\t\t\t\t FSCK_MSG_GITMODULES_SYMLINK,\n\t\t\t\t\t\t\t\t \".gitmodules is a symbolic link\");\n\t\t\t\t}\n\t\t\t\tbackslash = strchr(backslash, '\\\\');\n\t\t\t}\n\t\t}\n\n\t\tif (update_tree_entry_gently(&desc)) {\n\t\t\tretval += report(options, &item->object, FSCK_MSG_BAD_TREE, \"cannot be parsed as a tree\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (mode) {\n\t\t/*\n\t\t * Standard modes..\n\t\t */\n\t\tcase S_IFREG | 0755:\n\t\tcase S_IFREG | 0644:\n\t\tcase S_IFLNK:\n\t\tcase S_IFDIR:\n\t\tcase S_IFGITLINK:\n\t\t\tbreak;\n\t\t/*\n\t\t * This is nonstandard, but we had a few of these\n\t\t * early on when we honored the full set of mode\n\t\t * bits..\n\t\t */\n\t\tcase S_IFREG | 0664:\n\t\t\tif (!options->strict)\n\t\t\t\tbreak;\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\thas_bad_modes = 1;\n\t\t}\n\n\t\tif (o_name) {\n\t\t\tswitch (verify_ordered(o_mode, o_name, mode, name)) {\n\t\t\tcase TREE_UNORDERED:\n\t\t\t\tnot_properly_sorted = 1;\n\t\t\t\tbreak;\n\t\t\tcase TREE_HAS_DUPS:\n\t\t\t\thas_dup_entries = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\to_mode = mode;\n\t\to_name = name;\n\t}\n\n\tif (has_null_sha1)\n\t\tretval += report(options, &item->object, FSCK_MSG_NULL_SHA1, \"contains entries pointing to null sha1\");\n\tif (has_full_path)\n\t\tretval += report(options, &item->object, FSCK_MSG_FULL_PATHNAME, \"contains full pathnames\");\n\tif (has_empty_name)\n\t\tretval += report(options, &item->object, FSCK_MSG_EMPTY_NAME, \"contains empty pathname\");\n\tif (has_dot)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOT, \"contains '.'\");\n\tif (has_dotdot)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOTDOT, \"contains '..'\");\n\tif (has_dotgit)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOTGIT, \"contains '.git'\");\n\tif (has_zero_pad)\n\t\tretval += report(options, &item->object, FSCK_MSG_ZERO_PADDED_FILEMODE, \"contains zero-padded file modes\");\n\tif (has_bad_modes)\n\t\tretval += report(options, &item->object, FSCK_MSG_BAD_FILEMODE, \"contains bad file modes\");\n\tif (has_dup_entries)\n\t\tretval += report(options, &item->object, FSCK_MSG_DUPLICATE_ENTRIES, \"contains duplicate file entries\");\n\tif (not_properly_sorted)\n\t\tretval += report(options, &item->object, FSCK_MSG_TREE_NOT_SORTED, \"not properly sorted\");\n\treturn retval;\n}\n\nstatic int verify_headers(const void *data, unsigned long size,\n\t\t\t  struct object *obj, struct fsck_options *options)\n{\n\tconst char *buffer = (const char *)data;\n\tunsigned long i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tswitch (buffer[i]) {\n\t\tcase '\\0':\n\t\t\treturn report(options, obj,\n\t\t\t\tFSCK_MSG_NUL_IN_HEADER,\n\t\t\t\t\"unterminated header: NUL at offset %ld\", i);\n\t\tcase '\\n':\n\t\t\tif (i + 1 < size && buffer[i + 1] == '\\n')\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * We did not find double-LF that separates the header\n\t * and the body.  Not having a body is not a crime but\n\t * we do want to see the terminating LF for the last header\n\t * line.\n\t */\n\tif (size && buffer[size - 1] == '\\n')\n\t\treturn 0;\n\n\treturn report(options, obj,\n\t\tFSCK_MSG_UNTERMINATED_HEADER, \"unterminated header\");\n}\n\nstatic int fsck_ident(const char **ident, struct object *obj, struct fsck_options *options)\n{\n\tconst char *p = *ident;\n\tchar *end;\n\n\t*ident = strchrnul(*ident, '\\n');\n\tif (**ident == '\\n')\n\t\t(*ident)++;\n\n\tif (*p == '<')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_NAME_BEFORE_EMAIL, \"invalid author/committer line - missing space before email\");\n\tp += strcspn(p, \"<>\\n\");\n\tif (*p == '>')\n\t\treturn report(options, obj, FSCK_MSG_BAD_NAME, \"invalid author/committer line - bad name\");\n\tif (*p != '<')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_EMAIL, \"invalid author/committer line - missing email\");\n\tif (p[-1] != ' ')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_SPACE_BEFORE_EMAIL, \"invalid author/committer line - missing space before email\");\n\tp++;\n\tp += strcspn(p, \"<>\\n\");\n\tif (*p != '>')\n\t\treturn report(options, obj, FSCK_MSG_BAD_EMAIL, \"invalid author/committer line - bad email\");\n\tp++;\n\tif (*p != ' ')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_SPACE_BEFORE_DATE, \"invalid author/committer line - missing space before date\");\n\tp++;\n\tif (*p == '0' && p[1] != ' ')\n\t\treturn report(options, obj, FSCK_MSG_ZERO_PADDED_DATE, \"invalid author/committer line - zero-padded date\");\n\tif (date_overflows(parse_timestamp(p, &end, 10)))\n\t\treturn report(options, obj, FSCK_MSG_BAD_DATE_OVERFLOW, \"invalid author/committer line - date causes integer overflow\");\n\tif ((end == p || *end != ' '))\n\t\treturn report(options, obj, FSCK_MSG_BAD_DATE, \"invalid author/committer line - bad date\");\n\tp = end + 1;\n\tif ((*p != '+' && *p != '-') ||\n\t    !isdigit(p[1]) ||\n\t    !isdigit(p[2]) ||\n\t    !isdigit(p[3]) ||\n\t    !isdigit(p[4]) ||\n\t    (p[5] != '\\n'))\n\t\treturn report(options, obj, FSCK_MSG_BAD_TIMEZONE, \"invalid author/committer line - bad time zone\");\n\tp += 6;\n\treturn 0;\n}\n\nstatic int fsck_commit_buffer(struct commit *commit, const char *buffer,\n\tunsigned long size, struct fsck_options *options)\n{\n\tunsigned char tree_sha1[20], sha1[20];\n\tstruct commit_graft *graft;\n\tunsigned parent_count, parent_line_count = 0, author_count;\n\tint err;\n\tconst char *buffer_begin = buffer;\n\n\tif (verify_headers(buffer, size, &commit->object, options))\n\t\treturn -1;\n\n\tif (!skip_prefix(buffer, \"tree \", &buffer))\n\t\treturn report(options, &commit->object, FSCK_MSG_MISSING_TREE, \"invalid format - expected 'tree' line\");\n\tif (get_sha1_hex(buffer, tree_sha1) || buffer[40] != '\\n') {\n\t\terr = report(options, &commit->object, FSCK_MSG_BAD_TREE_SHA1, \"invalid 'tree' line format - bad sha1\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tbuffer += 41;\n\twhile (skip_prefix(buffer, \"parent \", &buffer)) {\n\t\tif (get_sha1_hex(buffer, sha1) || buffer[40] != '\\n') {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_BAD_PARENT_SHA1, \"invalid 'parent' line format - bad sha1\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbuffer += 41;\n\t\tparent_line_count++;\n\t}\n\tgraft = lookup_commit_graft(&commit->object.oid);\n\tparent_count = commit_list_count(commit->parents);\n\tif (graft) {\n\t\tif (graft->nr_parent == -1 && !parent_count)\n\t\t\t; /* shallow commit */\n\t\telse if (graft->nr_parent != parent_count) {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_GRAFT, \"graft objects missing\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (parent_count != parent_line_count) {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_PARENT, \"parent objects missing\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tauthor_count = 0;\n\twhile (skip_prefix(buffer, \"author \", &buffer)) {\n\t\tauthor_count++;\n\t\terr = fsck_ident(&buffer, &commit->object, options);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (author_count < 1)\n\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_AUTHOR, \"invalid format - expected 'author' line\");\n\telse if (author_count > 1)\n\t\terr = report(options, &commit->object, FSCK_MSG_MULTIPLE_AUTHORS, \"invalid format - multiple 'author' lines\");\n\tif (err)\n\t\treturn err;\n\tif (!skip_prefix(buffer, \"committer \", &buffer))\n\t\treturn report(options, &commit->object, FSCK_MSG_MISSING_COMMITTER, \"invalid format - expected 'committer' line\");\n\terr = fsck_ident(&buffer, &commit->object, options);\n\tif (err)\n\t\treturn err;\n\tif (!commit->tree) {\n\t\terr = report(options, &commit->object, FSCK_MSG_BAD_TREE, \"could not load commit's tree %s\", sha1_to_hex(tree_sha1));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (memchr(buffer_begin, '\\0', size)) {\n\t\terr = report(options, &commit->object, FSCK_MSG_NUL_IN_COMMIT,\n\t\t\t     \"NUL byte in the commit object body\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int fsck_commit(struct commit *commit, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tconst char *buffer = data ?  data : get_commit_buffer(commit, &size);\n\tint ret = fsck_commit_buffer(commit, buffer, size, options);\n\tif (!data)\n\t\tunuse_commit_buffer(commit, buffer);\n\treturn ret;\n}\n\nstatic int fsck_tag_buffer(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tunsigned char sha1[20];\n\tint ret = 0;\n\tconst char *buffer;\n\tchar *to_free = NULL, *eol;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tif (data)\n\t\tbuffer = data;\n\telse {\n\t\tenum object_type type;\n\n\t\tbuffer = to_free =\n\t\t\tread_sha1_file(tag->object.oid.hash, &type, &size);\n\t\tif (!buffer)\n\t\t\treturn report(options, &tag->object,\n\t\t\t\tFSCK_MSG_MISSING_TAG_OBJECT,\n\t\t\t\t\"cannot read tag object\");\n\n\t\tif (type != OBJ_TAG) {\n\t\t\tret = report(options, &tag->object,\n\t\t\t\tFSCK_MSG_TAG_OBJECT_NOT_TAG,\n\t\t\t\t\"expected tag got %s\",\n\t\t\t    type_name(type));\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = verify_headers(buffer, size, &tag->object, options);\n\tif (ret)\n\t\tgoto done;\n\n\tif (!skip_prefix(buffer, \"object \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_OBJECT, \"invalid format - expected 'object' line\");\n\t\tgoto done;\n\t}\n\tif (get_sha1_hex(buffer, sha1) || buffer[40] != '\\n') {\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_OBJECT_SHA1, \"invalid 'object' line format - bad sha1\");\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\tbuffer += 41;\n\n\tif (!skip_prefix(buffer, \"type \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TYPE_ENTRY, \"invalid format - expected 'type' line\");\n\t\tgoto done;\n\t}\n\teol = strchr(buffer, '\\n');\n\tif (!eol) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TYPE, \"invalid format - unexpected end after 'type' line\");\n\t\tgoto done;\n\t}\n\tif (type_from_string_gently(buffer, eol - buffer, 1) < 0)\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_TYPE, \"invalid 'type' value\");\n\tif (ret)\n\t\tgoto done;\n\tbuffer = eol + 1;\n\n\tif (!skip_prefix(buffer, \"tag \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAG_ENTRY, \"invalid format - expected 'tag' line\");\n\t\tgoto done;\n\t}\n\teol = strchr(buffer, '\\n');\n\tif (!eol) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAG, \"invalid format - unexpected end after 'type' line\");\n\t\tgoto done;\n\t}\n\tstrbuf_addf(&sb, \"refs/tags/%.*s\", (int)(eol - buffer), buffer);\n\tif (check_refname_format(sb.buf, 0)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_TAG_NAME,\n\t\t\t   \"invalid 'tag' name: %.*s\",\n\t\t\t   (int)(eol - buffer), buffer);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\tbuffer = eol + 1;\n\n\tif (!skip_prefix(buffer, \"tagger \", &buffer)) {\n\t\t/* early tags do not contain 'tagger' lines; warn only */\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAGGER_ENTRY, \"invalid format - expected 'tagger' line\");\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\telse\n\t\tret = fsck_ident(&buffer, &tag->object, options);\n\ndone:\n\tstrbuf_release(&sb);\n\tfree(to_free);\n\treturn ret;\n}\n\nstatic int fsck_tag(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tstruct object *tagged = tag->tagged;\n\n\tif (!tagged)\n\t\treturn report(options, &tag->object, FSCK_MSG_BAD_TAG_OBJECT, \"could not load tagged object\");\n\n\treturn fsck_tag_buffer(tag, data, size, options);\n}\n\n/*\n * Like builtin/submodule--helper.c's starts_with_dot_slash, but without\n * relying on the platform-dependent is_dir_sep helper.\n *\n * This is for use in checking whether a submodule URL is interpreted as\n * relative to the current directory on any platform, since \\ is a\n * directory separator on Windows but not on other platforms.\n */\nstatic int starts_with_dot_slash(const char *str)\n{\n\treturn str[0] == '.' && (str[1] == '/' || str[1] == '\\\\');\n}\n\n/*\n * Like starts_with_dot_slash, this is a variant of submodule--helper's\n * helper of the same name with the twist that it accepts backslash as a\n * directory separator even on non-Windows platforms.\n */\nstatic int starts_with_dot_dot_slash(const char *str)\n{\n\treturn str[0] == '.' && starts_with_dot_slash(str + 1);\n}\n\nstatic int submodule_url_is_relative(const char *url)\n{\n\treturn starts_with_dot_slash(url) || starts_with_dot_dot_slash(url);\n}\n\n/*\n * Check whether a transport is implemented by git-remote-curl.\n *\n * If it is, returns 1 and writes the URL that would be passed to\n * git-remote-curl to the \"out\" parameter.\n *\n * Otherwise, returns 0 and leaves \"out\" untouched.\n *\n * Examples:\n *   http::https://example.com/repo.git -> 1, https://example.com/repo.git\n *   https://example.com/repo.git -> 1, https://example.com/repo.git\n *   git://example.com/repo.git -> 0\n *\n * This is for use in checking for previously exploitable bugs that\n * required a submodule URL to be passed to git-remote-curl.\n */\nstatic int url_to_curl_url(const char *url, const char **out)\n{\n\t/*\n\t * We don't need to check for case-aliases, \"http.exe\", and so\n\t * on because in the default configuration, is_transport_allowed\n\t * prevents URLs with those schemes from being cloned\n\t * automatically.\n\t */\n\tif (skip_prefix(url, \"http::\", out) ||\n\t    skip_prefix(url, \"https::\", out) ||\n\t    skip_prefix(url, \"ftp::\", out) ||\n\t    skip_prefix(url, \"ftps::\", out))\n\t\treturn 1;\n\tif (starts_with(url, \"http://\") ||\n\t    starts_with(url, \"https://\") ||\n\t    starts_with(url, \"ftp://\") ||\n\t    starts_with(url, \"ftps://\")) {\n\t\t*out = url;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstruct fsck_gitmodules_data {\n\tstruct object *obj;\n\tstruct fsck_options *options;\n\tint ret;\n};\n\nstatic int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    check_submodule_url(value) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tif (!strcmp(key, \"path\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n\t\t\t\t    \"disallowed submodule path: %s\",\n\t\t\t\t    value);\n\tif (!strcmp(key, \"update\") && value &&\n\t    parse_submodule_update_type(value) == SM_UPDATE_COMMAND)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_UPDATE,\n\t\t\t\t    \"disallowed submodule update setting: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\n\treturn 0;\n}\n\nstatic int fsck_blob(struct blob *blob, const char *buf,\n\t\t     unsigned long size, struct fsck_options *options)\n{\n\tstruct fsck_gitmodules_data data;\n\n\tif (!oidset_contains(&gitmodules_found, &blob->object.oid))\n\t\treturn 0;\n\toidset_insert(&gitmodules_done, &blob->object.oid);\n\n\tif (!buf) {\n\t\t/*\n\t\t * A missing buffer here is a sign that the caller found the\n\t\t * blob too gigantic to load into memory. Let's just consider\n\t\t * that an error.\n\t\t */\n\t\treturn report(options, &blob->object,\n\t\t\t      FSCK_MSG_GITMODULES_PARSE,\n\t\t\t      \".gitmodules too large to parse\");\n\t}\n\n\tdata.obj = &blob->object;\n\tdata.options = options;\n\tdata.ret = 0;\n\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n\t\t\t\t\".gitmodules\", buf, size, &data))\n\t\tdata.ret |= report(options, &blob->object,\n\t\t\t\t   FSCK_MSG_GITMODULES_PARSE,\n\t\t\t\t   \"could not parse gitmodules blob\");\n\n\treturn data.ret;\n}\n\nint fsck_object(struct object *obj, void *data, unsigned long size,\n\tstruct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn report(options, obj, FSCK_MSG_BAD_OBJECT_SHA1, \"no valid object to fsck\");\n\n\tif (obj->type == OBJ_BLOB)\n\t\treturn fsck_blob((struct blob *)obj, data, size, options);\n\tif (obj->type == OBJ_TREE)\n\t\treturn fsck_tree((struct tree *) obj, options);\n\tif (obj->type == OBJ_COMMIT)\n\t\treturn fsck_commit((struct commit *) obj, (const char *) data,\n\t\t\tsize, options);\n\tif (obj->type == OBJ_TAG)\n\t\treturn fsck_tag((struct tag *) obj, (const char *) data,\n\t\t\tsize, options);\n\n\treturn report(options, obj, FSCK_MSG_UNKNOWN_TYPE, \"unknown type '%d' (internal fsck error)\",\n\t\t\t  obj->type);\n}\n\nint fsck_error_function(struct fsck_options *o,\n\tstruct object *obj, int msg_type, const char *message)\n{\n\tif (msg_type == FSCK_WARN) {\n\t\twarning(\"object %s: %s\", describe_object(o, obj), message);\n\t\treturn 0;\n\t}\n\terror(\"object %s: %s\", describe_object(o, obj), message);\n\treturn 1;\n}\n\nint fsck_finish(struct fsck_options *options)\n{\n\tint ret = 0;\n\tstruct oidset_iter iter;\n\tconst struct object_id *oid;\n\n\toidset_iter_init(&gitmodules_found, &iter);\n\twhile ((oid = oidset_iter_next(&iter))) {\n\t\tstruct blob *blob;\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tchar *buf;\n\n\t\tif (oidset_contains(&gitmodules_done, oid))\n\t\t\tcontinue;\n\n\t\tblob = lookup_blob(oid);\n\t\tif (!blob) {\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n\t\t\t\t      \"non-blob found at .gitmodules\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf = read_sha1_file(oid->hash, &type, &size);\n\t\tif (!buf) {\n\t\t\tif (is_promisor_object(&blob->object.oid))\n\t\t\t\tcontinue;\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_MISSING,\n\t\t\t\t      \"unable to read .gitmodules blob\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type == OBJ_BLOB)\n\t\t\tret |= fsck_blob(blob, buf, size, options);\n\t\telse\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n\t\t\t\t      \"non-blob found at .gitmodules\");\n\t\tfree(buf);\n\t}\n\n\n\toidset_clear(&gitmodules_found);\n\toidset_clear(&gitmodules_done);\n\treturn ret;\n}\n", "#!/bin/sh\n\ntest_description='test dumb fetching over http via static file'\n. ./test-lib.sh\n. \"$TEST_DIRECTORY\"/lib-httpd.sh\nstart_httpd\n\ntest_expect_success 'setup repository' '\n\tgit config push.default matching &&\n\techo content1 >file &&\n\tgit add file &&\n\tgit commit -m one &&\n\techo content2 >file &&\n\tgit add file &&\n\tgit commit -m two\n'\n\ntest_expect_success 'create http-accessible bare repository with loose objects' '\n\tcp -R .git \"$HTTPD_DOCUMENT_ROOT_PATH/repo.git\" &&\n\t(cd \"$HTTPD_DOCUMENT_ROOT_PATH/repo.git\" &&\n\t git config core.bare true &&\n\t mkdir -p hooks &&\n\t write_script \"hooks/post-update\" <<-\\EOF &&\n\t exec git update-server-info\n\tEOF\n\t hooks/post-update\n\t) &&\n\tgit remote add public \"$HTTPD_DOCUMENT_ROOT_PATH/repo.git\" &&\n\tgit push public master:master\n'\n\ntest_expect_success 'clone http repository' '\n\tgit clone $HTTPD_URL/dumb/repo.git clone-tmpl &&\n\tcp -R clone-tmpl clone &&\n\ttest_cmp file clone/file\n'\n\ntest_expect_success 'list refs from outside any repository' '\n\tcat >expect <<-EOF &&\n\t$(git rev-parse master)\tHEAD\n\t$(git rev-parse master)\trefs/heads/master\n\tEOF\n\tnongit git ls-remote \"$HTTPD_URL/dumb/repo.git\" >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'create password-protected repository' '\n\tmkdir -p \"$HTTPD_DOCUMENT_ROOT_PATH/auth/dumb/\" &&\n\tcp -Rf \"$HTTPD_DOCUMENT_ROOT_PATH/repo.git\" \\\n\t       \"$HTTPD_DOCUMENT_ROOT_PATH/auth/dumb/repo.git\"\n'\n\nsetup_askpass_helper\n\ntest_expect_success 'cloning password-protected repository can fail' '\n\tset_askpass wrong &&\n\ttest_must_fail git clone \"$HTTPD_URL/auth/dumb/repo.git\" clone-auth-fail &&\n\texpect_askpass both wrong\n'\n\ntest_expect_success 'http auth can use user/pass in URL' '\n\tset_askpass wrong &&\n\tgit clone \"$HTTPD_URL_USER_PASS/auth/dumb/repo.git\" clone-auth-none &&\n\texpect_askpass none\n'\n\ntest_expect_success 'http auth can use just user in URL' '\n\tset_askpass wrong pass@host &&\n\tgit clone \"$HTTPD_URL_USER/auth/dumb/repo.git\" clone-auth-pass &&\n\texpect_askpass pass user@host\n'\n\ntest_expect_success 'http auth can request both user and pass' '\n\tset_askpass user@host pass@host &&\n\tgit clone \"$HTTPD_URL/auth/dumb/repo.git\" clone-auth-both &&\n\texpect_askpass both user@host\n'\n\ntest_expect_success 'http auth respects credential helper config' '\n\ttest_config_global credential.helper \"!f() {\n\t\tcat >/dev/null\n\t\techo username=user@host\n\t\techo password=pass@host\n\t}; f\" &&\n\tset_askpass wrong &&\n\tgit clone \"$HTTPD_URL/auth/dumb/repo.git\" clone-auth-helper &&\n\texpect_askpass none\n'\n\ntest_expect_success 'http auth can get username from config' '\n\ttest_config_global \"credential.$HTTPD_URL.username\" user@host &&\n\tset_askpass wrong pass@host &&\n\tgit clone \"$HTTPD_URL/auth/dumb/repo.git\" clone-auth-user &&\n\texpect_askpass pass user@host\n'\n\ntest_expect_success 'configured username does not override URL' '\n\ttest_config_global \"credential.$HTTPD_URL.username\" wrong &&\n\tset_askpass wrong pass@host &&\n\tgit clone \"$HTTPD_URL_USER/auth/dumb/repo.git\" clone-auth-user2 &&\n\texpect_askpass pass user@host\n'\n\ntest_expect_success 'set up repo with http submodules' '\n\tgit init super &&\n\tset_askpass user@host pass@host &&\n\t(\n\t\tcd super &&\n\t\tgit submodule add \"$HTTPD_URL/auth/dumb/repo.git\" sub &&\n\t\tgit commit -m \"add submodule\"\n\t)\n'\n\ntest_expect_success 'cmdline credential config passes to submodule via clone' '\n\tset_askpass wrong pass@host &&\n\ttest_must_fail git clone --recursive super super-clone &&\n\trm -rf super-clone &&\n\n\tset_askpass wrong pass@host &&\n\tgit -c \"credential.$HTTPD_URL.username=user@host\" \\\n\t\tclone --recursive super super-clone &&\n\texpect_askpass pass user@host\n'\n\ntest_expect_success 'cmdline credential config passes submodule via fetch' '\n\tset_askpass wrong pass@host &&\n\ttest_must_fail git -C super-clone fetch --recurse-submodules &&\n\n\tset_askpass wrong pass@host &&\n\tgit -C super-clone \\\n\t    -c \"credential.$HTTPD_URL.username=user@host\" \\\n\t    fetch --recurse-submodules &&\n\texpect_askpass pass user@host\n'\n\ntest_expect_success 'cmdline credential config passes submodule update' '\n\t# advance the submodule HEAD so that a fetch is required\n\tgit commit --allow-empty -m foo &&\n\tgit push \"$HTTPD_DOCUMENT_ROOT_PATH/auth/dumb/repo.git\" HEAD &&\n\tsha1=$(git rev-parse HEAD) &&\n\tgit -C super-clone update-index --cacheinfo 160000,$sha1,sub &&\n\n\tset_askpass wrong pass@host &&\n\ttest_must_fail git -C super-clone submodule update &&\n\n\tset_askpass wrong pass@host &&\n\tgit -C super-clone \\\n\t    -c \"credential.$HTTPD_URL.username=user@host\" \\\n\t    submodule update &&\n\texpect_askpass pass user@host\n'\n\ntest_expect_success 'fetch changes via http' '\n\techo content >>file &&\n\tgit commit -a -m two &&\n\tgit push public &&\n\t(cd clone && git pull) &&\n\ttest_cmp file clone/file\n'\n\ntest_expect_success 'fetch changes via manual http-fetch' '\n\tcp -R clone-tmpl clone2 &&\n\n\tHEAD=$(git rev-parse --verify HEAD) &&\n\t(cd clone2 &&\n\t git http-fetch -a -w heads/master-new $HEAD $(git config remote.origin.url) &&\n\t git checkout master-new &&\n\t test $HEAD = $(git rev-parse --verify HEAD)) &&\n\ttest_cmp file clone2/file\n'\n\ntest_expect_success 'http remote detects correct HEAD' '\n\tgit push public master:other &&\n\t(cd clone &&\n\t git remote set-head origin -d &&\n\t git remote set-head origin -a &&\n\t git symbolic-ref refs/remotes/origin/HEAD > output &&\n\t echo refs/remotes/origin/master > expect &&\n\t test_cmp expect output\n\t)\n'\n\ntest_expect_success 'fetch packed objects' '\n\tcp -R \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo.git \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_pack.git &&\n\t(cd \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_pack.git &&\n\t git --bare repack -a -d\n\t) &&\n\tgit clone $HTTPD_URL/dumb/repo_pack.git\n'\n\ntest_expect_success 'fetch notices corrupt pack' '\n\tcp -R \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_pack.git \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_bad1.git &&\n\t(cd \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_bad1.git &&\n\t p=$(ls objects/pack/pack-*.pack) &&\n\t chmod u+w $p &&\n\t printf %0256d 0 | dd of=$p bs=256 count=1 seek=1 conv=notrunc\n\t) &&\n\tmkdir repo_bad1.git &&\n\t(cd repo_bad1.git &&\n\t git --bare init &&\n\t test_must_fail git --bare fetch $HTTPD_URL/dumb/repo_bad1.git &&\n\t test 0 = $(ls objects/pack/pack-*.pack | wc -l)\n\t)\n'\n\ntest_expect_success 'fetch notices corrupt idx' '\n\tcp -R \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_pack.git \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_bad2.git &&\n\t(cd \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_bad2.git &&\n\t p=$(ls objects/pack/pack-*.idx) &&\n\t chmod u+w $p &&\n\t printf %0256d 0 | dd of=$p bs=256 count=1 seek=1 conv=notrunc\n\t) &&\n\tmkdir repo_bad2.git &&\n\t(cd repo_bad2.git &&\n\t git --bare init &&\n\t test_must_fail git --bare fetch $HTTPD_URL/dumb/repo_bad2.git &&\n\t test 0 = $(ls objects/pack | wc -l)\n\t)\n'\n\ntest_expect_success 'fetch can handle previously-fetched .idx files' '\n\tgit checkout --orphan branch1 &&\n\techo base >file &&\n\tgit add file &&\n\tgit commit -m base &&\n\tgit --bare init \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_packed_branches.git &&\n\tgit push \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_packed_branches.git branch1 &&\n\tgit --git-dir=\"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_packed_branches.git repack -d &&\n\tgit checkout -b branch2 branch1 &&\n\techo b2 >>file &&\n\tgit commit -a -m b2 &&\n\tgit push \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_packed_branches.git branch2 &&\n\tgit --git-dir=\"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_packed_branches.git repack -d &&\n\tgit --bare init clone_packed_branches.git &&\n\tgit --git-dir=clone_packed_branches.git fetch \"$HTTPD_URL\"/dumb/repo_packed_branches.git branch1:branch1 &&\n\tgit --git-dir=clone_packed_branches.git fetch \"$HTTPD_URL\"/dumb/repo_packed_branches.git branch2:branch2\n'\n\ntest_expect_success 'did not use upload-pack service' '\n\ttest_might_fail grep '/git-upload-pack' <\"$HTTPD_ROOT_PATH\"/access.log >act &&\n\t: >exp &&\n\ttest_cmp exp act\n'\n\ntest_expect_success 'git client shows text/plain errors' '\n\ttest_must_fail git clone \"$HTTPD_URL/error/text\" 2>stderr &&\n\tgrep \"this is the error message\" stderr\n'\n\ntest_expect_success 'git client does not show html errors' '\n\ttest_must_fail git clone \"$HTTPD_URL/error/html\" 2>stderr &&\n\t! grep \"this is the error message\" stderr\n'\n\ntest_expect_success 'git client shows text/plain with a charset' '\n\ttest_must_fail git clone \"$HTTPD_URL/error/charset\" 2>stderr &&\n\tgrep \"this is the error message\" stderr\n'\n\ntest_expect_success 'http error messages are reencoded' '\n\ttest_must_fail git clone \"$HTTPD_URL/error/utf16\" 2>stderr &&\n\tgrep \"this is the error message\" stderr\n'\n\ntest_expect_success 'reencoding is robust to whitespace oddities' '\n\ttest_must_fail git clone \"$HTTPD_URL/error/odd-spacing\" 2>stderr &&\n\tgrep \"this is the error message\" stderr\n'\n\ncheck_language () {\n\tcase \"$2\" in\n\t'')\n\t\t>expect\n\t\t;;\n\t?*)\n\t\techo \"=> Send header: Accept-Language: $1\" >expect\n\t\t;;\n\tesac &&\n\tGIT_TRACE_CURL=true \\\n\tLANGUAGE=$2 \\\n\tgit ls-remote \"$HTTPD_URL/dumb/repo.git\" >output 2>&1 &&\n\ttr -d '\\015' <output |\n\tsort -u |\n\tsed -ne '/^=> Send header: Accept-Language:/ p' >actual &&\n\ttest_cmp expect actual\n}\n\ntest_expect_success 'git client sends Accept-Language based on LANGUAGE' '\n\tcheck_language \"ko-KR, *;q=0.9\" ko_KR.UTF-8'\n\ntest_expect_success 'git client sends Accept-Language correctly with unordinary LANGUAGE' '\n\tcheck_language \"ko-KR, *;q=0.9\" \"ko_KR:\" &&\n\tcheck_language \"ko-KR, en-US;q=0.9, *;q=0.8\" \"ko_KR::en_US\" &&\n\tcheck_language \"ko-KR, *;q=0.9\" \":::ko_KR\" &&\n\tcheck_language \"ko-KR, en-US;q=0.9, *;q=0.8\" \"ko_KR!!:en_US\" &&\n\tcheck_language \"ko-KR, ja-JP;q=0.9, *;q=0.8\" \"ko_KR en_US:ja_JP\"'\n\ntest_expect_success 'git client sends Accept-Language with many preferred languages' '\n\tcheck_language \"ko-KR, en-US;q=0.9, fr-CA;q=0.8, de;q=0.7, sr;q=0.6, \\\nja;q=0.5, zh;q=0.4, sv;q=0.3, pt;q=0.2, *;q=0.1\" \\\n\t\tko_KR.EUC-KR:en_US.UTF-8:fr_CA:de.UTF-8@euro:sr@latin:ja:zh:sv:pt &&\n\tcheck_language \"ko-KR, en-US;q=0.99, fr-CA;q=0.98, de;q=0.97, sr;q=0.96, \\\nja;q=0.95, zh;q=0.94, sv;q=0.93, pt;q=0.92, nb;q=0.91, *;q=0.90\" \\\n\t\tko_KR.EUC-KR:en_US.UTF-8:fr_CA:de.UTF-8@euro:sr@latin:ja:zh:sv:pt:nb\n'\n\ntest_expect_success 'git client does not send an empty Accept-Language' '\n\tGIT_TRACE_CURL=true LANGUAGE= git ls-remote \"$HTTPD_URL/dumb/repo.git\" 2>stderr &&\n\t! grep \"^=> Send header: Accept-Language:\" stderr\n'\n\ntest_expect_success 'remote-http complains cleanly about malformed urls' '\n\t# do not actually issue \"list\" or other commands, as we do not\n\t# want to rely on what curl would actually do with such a broken\n\t# URL. This is just about making sure we do not segfault during\n\t# initialization.\n\ttest_must_fail git remote-http http::/example.com/repo.git\n'\n\ntest_expect_success 'redirects can be forbidden/allowed' '\n\ttest_must_fail git -c http.followRedirects=false \\\n\t\tclone $HTTPD_URL/dumb-redir/repo.git dumb-redir &&\n\tgit -c http.followRedirects=true \\\n\t\tclone $HTTPD_URL/dumb-redir/repo.git dumb-redir 2>stderr\n'\n\ntest_expect_success 'redirects are reported to stderr' '\n\t# just look for a snippet of the redirected-to URL\n\ttest_i18ngrep /dumb/ stderr\n'\n\ntest_expect_success 'non-initial redirects can be forbidden' '\n\ttest_must_fail git -c http.followRedirects=initial \\\n\t\tclone $HTTPD_URL/redir-objects/repo.git redir-objects &&\n\tgit -c http.followRedirects=true \\\n\t\tclone $HTTPD_URL/redir-objects/repo.git redir-objects\n'\n\ntest_expect_success 'http.followRedirects defaults to \"initial\"' '\n\ttest_must_fail git clone $HTTPD_URL/redir-objects/repo.git default\n'\n\n# The goal is for a clone of the \"evil\" repository, which has no objects\n# itself, to cause the client to fetch objects from the \"victim\" repository.\ntest_expect_success 'set up evil alternates scheme' '\n\tvictim=$HTTPD_DOCUMENT_ROOT_PATH/victim.git &&\n\tgit init --bare \"$victim\" &&\n\tgit -C \"$victim\" --work-tree=. commit --allow-empty -m secret &&\n\tgit -C \"$victim\" repack -ad &&\n\tgit -C \"$victim\" update-server-info &&\n\tsha1=$(git -C \"$victim\" rev-parse HEAD) &&\n\n\tevil=$HTTPD_DOCUMENT_ROOT_PATH/evil.git &&\n\tgit init --bare \"$evil\" &&\n\t# do this by hand to avoid object existence check\n\tprintf \"%s\\\\t%s\\\\n\" $sha1 refs/heads/master >\"$evil/info/refs\"\n'\n\n# Here we'll just redirect via HTTP. In a real-world attack these would be on\n# different servers, but we should reject it either way.\ntest_expect_success 'http-alternates is a non-initial redirect' '\n\techo \"$HTTPD_URL/dumb/victim.git/objects\" \\\n\t\t>\"$evil/objects/info/http-alternates\" &&\n\ttest_must_fail git -c http.followRedirects=initial \\\n\t\tclone $HTTPD_URL/dumb/evil.git evil-initial &&\n\tgit -c http.followRedirects=true \\\n\t\tclone $HTTPD_URL/dumb/evil.git evil-initial\n'\n\n# Curl supports a lot of protocols that we'd prefer not to allow\n# http-alternates to use, but it's hard to test whether curl has\n# accessed, say, the SMTP protocol, because we are not running an SMTP server.\n# But we can check that it does not allow access to file://, which would\n# otherwise allow this clone to complete.\ntest_expect_success 'http-alternates cannot point at funny protocols' '\n\techo \"file://$victim/objects\" >\"$evil/objects/info/http-alternates\" &&\n\ttest_must_fail git -c http.followRedirects=true \\\n\t\tclone \"$HTTPD_URL/dumb/evil.git\" evil-file\n'\n\ntest_expect_success 'http-alternates triggers not-from-user protocol check' '\n\techo \"$HTTPD_URL/dumb/victim.git/objects\" \\\n\t\t>\"$evil/objects/info/http-alternates\" &&\n\ttest_config_global http.followRedirects true &&\n\ttest_must_fail git -c protocol.http.allow=user \\\n\t\tclone $HTTPD_URL/dumb/evil.git evil-user &&\n\tgit -c protocol.http.allow=always \\\n\t\tclone $HTTPD_URL/dumb/evil.git evil-user\n'\n\ntest_expect_success 'can redirect through non-\"info/refs?service=git-upload-pack\" URL' '\n\tgit clone \"$HTTPD_URL/redir-to/dumb/repo.git\"\n'\n\ntest_expect_success 'print HTTP error when any intermediate redirect throws error' '\n\ttest_must_fail git clone \"$HTTPD_URL/redir-to/502\" 2> stderr &&\n\ttest_i18ngrep \"unable to access.*/redir-to/502\" stderr\n'\n\nstop_httpd\ntest_done\n", "#!/bin/sh\n\ntest_description='check handling of disallowed .gitmodule urls'\n. ./test-lib.sh\n\ntest_expect_success 'create submodule with protected dash in url' '\n\tgit init upstream &&\n\tgit -C upstream commit --allow-empty -m base &&\n\tmv upstream ./-upstream &&\n\tgit submodule add ./-upstream sub &&\n\tgit add sub .gitmodules &&\n\tgit commit -m submodule\n'\n\ntest_expect_success 'clone can recurse submodule' '\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit clone --recurse-submodules . dst &&\n\techo base >expect &&\n\tgit -C dst/sub log -1 --format=%s >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'fsck accepts protected dash' '\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\tgit push dst HEAD\n'\n\ntest_expect_success 'remove ./ protection from .gitmodules url' '\n\tperl -i -pe \"s{\\./}{}\" .gitmodules &&\n\tgit commit -am \"drop protection\"\n'\n\ntest_expect_success 'clone rejects unprotected dash' '\n\ttest_when_finished \"rm -rf dst\" &&\n\ttest_must_fail git clone --recurse-submodules . dst 2>err &&\n\ttest_i18ngrep ignoring err\n'\n\ntest_expect_success 'fsck rejects unprotected dash' '\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\ttest_must_fail git push dst HEAD 2>err &&\n\tgrep gitmodulesUrl err\n'\n\ntest_expect_success 'trailing backslash is handled correctly' '\n\tgit init testmodule &&\n\ttest_commit -C testmodule c &&\n\tgit submodule add ./testmodule &&\n\t: ensure that the name ends in a double backslash &&\n\tsed -e \"s|\\\\(submodule \\\"testmodule\\\\)\\\"|\\\\1\\\\\\\\\\\\\\\\\\\"|\" \\\n\t\t-e \"s|url = .*|url = \\\" --should-not-be-an-option\\\"|\" \\\n\t\t<.gitmodules >.new &&\n\tmv .new .gitmodules &&\n\tgit commit -am \"Add testmodule\" &&\n\ttest_must_fail git clone --verbose --recurse-submodules . dolly 2>err &&\n\ttest_i18ngrep ! \"unknown option\" err\n'\n\ntest_expect_success 'fsck permits embedded newline with unrecognized scheme' '\n\tgit checkout --orphan newscheme &&\n\tcat >.gitmodules <<-\\EOF &&\n\t[submodule \"foo\"]\n\t\turl = \"data://acjbkd%0akajfdickajkd\"\n\tEOF\n\tgit add .gitmodules &&\n\tgit commit -m \"gitmodules with unrecognized scheme\" &&\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\tgit push dst HEAD\n'\n\ntest_expect_success 'fsck rejects embedded newline in url' '\n\t# create an orphan branch to avoid existing .gitmodules objects\n\tgit checkout --orphan newline &&\n\tcat >.gitmodules <<-\\EOF &&\n\t[submodule \"foo\"]\n\turl = \"https://one.example.com?%0ahost=two.example.com/foo.git\"\n\tEOF\n\tgit add .gitmodules &&\n\tgit commit -m \"gitmodules with newline\" &&\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\ttest_must_fail git push dst HEAD 2>err &&\n\tgrep gitmodulesUrl err\n'\n\ntest_expect_success 'fsck rejects embedded newline in relative url' '\n\tgit checkout --orphan relative-newline &&\n\tcat >.gitmodules <<-\\EOF &&\n\t[submodule \"foo\"]\n\t\turl = \"./%0ahost=two.example.com/foo.git\"\n\tEOF\n\tgit add .gitmodules &&\n\tgit commit -m \"relative url with newline\" &&\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\ttest_must_fail git push dst HEAD 2>err &&\n\tgrep gitmodulesUrl err\n'\n\ntest_done\n"], "fixing_code": ["#include \"cache.h\"\n#include \"config.h\"\n#include \"credential.h\"\n#include \"string-list.h\"\n#include \"run-command.h\"\n#include \"url.h\"\n#include \"prompt.h\"\n\nvoid credential_init(struct credential *c)\n{\n\tmemset(c, 0, sizeof(*c));\n\tc->helpers.strdup_strings = 1;\n}\n\nvoid credential_clear(struct credential *c)\n{\n\tfree(c->protocol);\n\tfree(c->host);\n\tfree(c->path);\n\tfree(c->username);\n\tfree(c->password);\n\tstring_list_clear(&c->helpers, 0);\n\n\tcredential_init(c);\n}\n\nint credential_match(const struct credential *want,\n\t\t     const struct credential *have)\n{\n#define CHECK(x) (!want->x || (have->x && !strcmp(want->x, have->x)))\n\treturn CHECK(protocol) &&\n\t       CHECK(host) &&\n\t       CHECK(path) &&\n\t       CHECK(username);\n#undef CHECK\n}\n\nstatic int credential_config_callback(const char *var, const char *value,\n\t\t\t\t      void *data)\n{\n\tstruct credential *c = data;\n\tconst char *key, *dot;\n\n\tif (!skip_prefix(var, \"credential.\", &key))\n\t\treturn 0;\n\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\n\tdot = strrchr(key, '.');\n\tif (dot) {\n\t\tstruct credential want = CREDENTIAL_INIT;\n\t\tchar *url = xmemdupz(key, dot - key);\n\t\tint matched;\n\n\t\tcredential_from_url(&want, url);\n\t\tmatched = credential_match(&want, c);\n\n\t\tcredential_clear(&want);\n\t\tfree(url);\n\n\t\tif (!matched)\n\t\t\treturn 0;\n\t\tkey = dot + 1;\n\t}\n\n\tif (!strcmp(key, \"helper\")) {\n\t\tif (*value)\n\t\t\tstring_list_append(&c->helpers, value);\n\t\telse\n\t\t\tstring_list_clear(&c->helpers, 0);\n\t} else if (!strcmp(key, \"username\")) {\n\t\tif (!c->username)\n\t\t\tc->username = xstrdup(value);\n\t}\n\telse if (!strcmp(key, \"usehttppath\"))\n\t\tc->use_http_path = git_config_bool(var, value);\n\n\treturn 0;\n}\n\nstatic int proto_is_http(const char *s)\n{\n\tif (!s)\n\t\treturn 0;\n\treturn !strcmp(s, \"https\") || !strcmp(s, \"http\");\n}\n\nstatic void credential_apply_config(struct credential *c)\n{\n\tif (!c->host)\n\t\tdie(_(\"refusing to work with credential missing host field\"));\n\tif (!c->protocol)\n\t\tdie(_(\"refusing to work with credential missing protocol field\"));\n\n\tif (c->configured)\n\t\treturn;\n\tgit_config(credential_config_callback, c);\n\tc->configured = 1;\n\n\tif (!c->use_http_path && proto_is_http(c->protocol)) {\n\t\tFREE_AND_NULL(c->path);\n\t}\n}\n\nstatic void credential_describe(struct credential *c, struct strbuf *out)\n{\n\tif (!c->protocol)\n\t\treturn;\n\tstrbuf_addf(out, \"%s://\", c->protocol);\n\tif (c->username && *c->username)\n\t\tstrbuf_addf(out, \"%s@\", c->username);\n\tif (c->host)\n\t\tstrbuf_addstr(out, c->host);\n\tif (c->path)\n\t\tstrbuf_addf(out, \"/%s\", c->path);\n}\n\nstatic char *credential_ask_one(const char *what, struct credential *c,\n\t\t\t\tint flags)\n{\n\tstruct strbuf desc = STRBUF_INIT;\n\tstruct strbuf prompt = STRBUF_INIT;\n\tchar *r;\n\n\tcredential_describe(c, &desc);\n\tif (desc.len)\n\t\tstrbuf_addf(&prompt, \"%s for '%s': \", what, desc.buf);\n\telse\n\t\tstrbuf_addf(&prompt, \"%s: \", what);\n\n\tr = git_prompt(prompt.buf, flags);\n\n\tstrbuf_release(&desc);\n\tstrbuf_release(&prompt);\n\treturn xstrdup(r);\n}\n\nstatic void credential_getpass(struct credential *c)\n{\n\tif (!c->username)\n\t\tc->username = credential_ask_one(\"Username\", c,\n\t\t\t\t\t\t PROMPT_ASKPASS|PROMPT_ECHO);\n\tif (!c->password)\n\t\tc->password = credential_ask_one(\"Password\", c,\n\t\t\t\t\t\t PROMPT_ASKPASS);\n}\n\nint credential_read(struct credential *c, FILE *fp)\n{\n\tstruct strbuf line = STRBUF_INIT;\n\n\twhile (strbuf_getline_lf(&line, fp) != EOF) {\n\t\tchar *key = line.buf;\n\t\tchar *value = strchr(key, '=');\n\n\t\tif (!line.len)\n\t\t\tbreak;\n\n\t\tif (!value) {\n\t\t\twarning(\"invalid credential line: %s\", key);\n\t\t\tstrbuf_release(&line);\n\t\t\treturn -1;\n\t\t}\n\t\t*value++ = '\\0';\n\n\t\tif (!strcmp(key, \"username\")) {\n\t\t\tfree(c->username);\n\t\t\tc->username = xstrdup(value);\n\t\t} else if (!strcmp(key, \"password\")) {\n\t\t\tfree(c->password);\n\t\t\tc->password = xstrdup(value);\n\t\t} else if (!strcmp(key, \"protocol\")) {\n\t\t\tfree(c->protocol);\n\t\t\tc->protocol = xstrdup(value);\n\t\t} else if (!strcmp(key, \"host\")) {\n\t\t\tfree(c->host);\n\t\t\tc->host = xstrdup(value);\n\t\t} else if (!strcmp(key, \"path\")) {\n\t\t\tfree(c->path);\n\t\t\tc->path = xstrdup(value);\n\t\t} else if (!strcmp(key, \"url\")) {\n\t\t\tcredential_from_url(c, value);\n\t\t} else if (!strcmp(key, \"quit\")) {\n\t\t\tc->quit = !!git_config_bool(\"quit\", value);\n\t\t}\n\t\t/*\n\t\t * Ignore other lines; we don't know what they mean, but\n\t\t * this future-proofs us when later versions of git do\n\t\t * learn new lines, and the helpers are updated to match.\n\t\t */\n\t}\n\n\tstrbuf_release(&line);\n\treturn 0;\n}\n\nstatic void credential_write_item(FILE *fp, const char *key, const char *value,\n\t\t\t\t  int required)\n{\n\tif (!value && required)\n\t\tBUG(\"credential value for %s is missing\", key);\n\tif (!value)\n\t\treturn;\n\tif (strchr(value, '\\n'))\n\t\tdie(\"credential value for %s contains newline\", key);\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}\n\nvoid credential_write(const struct credential *c, FILE *fp)\n{\n\tcredential_write_item(fp, \"protocol\", c->protocol, 1);\n\tcredential_write_item(fp, \"host\", c->host, 1);\n\tcredential_write_item(fp, \"path\", c->path, 0);\n\tcredential_write_item(fp, \"username\", c->username, 0);\n\tcredential_write_item(fp, \"password\", c->password, 0);\n}\n\nstatic int run_credential_helper(struct credential *c,\n\t\t\t\t const char *cmd,\n\t\t\t\t int want_output)\n{\n\tstruct child_process helper = CHILD_PROCESS_INIT;\n\tconst char *argv[] = { NULL, NULL };\n\tFILE *fp;\n\n\targv[0] = cmd;\n\thelper.argv = argv;\n\thelper.use_shell = 1;\n\thelper.in = -1;\n\tif (want_output)\n\t\thelper.out = -1;\n\telse\n\t\thelper.no_stdout = 1;\n\n\tif (start_command(&helper) < 0)\n\t\treturn -1;\n\n\tfp = xfdopen(helper.in, \"w\");\n\tcredential_write(c, fp);\n\tfclose(fp);\n\n\tif (want_output) {\n\t\tint r;\n\t\tfp = xfdopen(helper.out, \"r\");\n\t\tr = credential_read(c, fp);\n\t\tfclose(fp);\n\t\tif (r < 0) {\n\t\t\tfinish_command(&helper);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (finish_command(&helper))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int credential_do(struct credential *c, const char *helper,\n\t\t\t const char *operation)\n{\n\tstruct strbuf cmd = STRBUF_INIT;\n\tint r;\n\n\tif (helper[0] == '!')\n\t\tstrbuf_addstr(&cmd, helper + 1);\n\telse if (is_absolute_path(helper))\n\t\tstrbuf_addstr(&cmd, helper);\n\telse\n\t\tstrbuf_addf(&cmd, \"git credential-%s\", helper);\n\n\tstrbuf_addf(&cmd, \" %s\", operation);\n\tr = run_credential_helper(c, cmd.buf, !strcmp(operation, \"get\"));\n\n\tstrbuf_release(&cmd);\n\treturn r;\n}\n\nvoid credential_fill(struct credential *c)\n{\n\tint i;\n\n\tif (c->username && c->password)\n\t\treturn;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++) {\n\t\tcredential_do(c, c->helpers.items[i].string, \"get\");\n\t\tif (c->username && c->password)\n\t\t\treturn;\n\t\tif (c->quit)\n\t\t\tdie(\"credential helper '%s' told us to quit\",\n\t\t\t    c->helpers.items[i].string);\n\t}\n\n\tcredential_getpass(c);\n\tif (!c->username && !c->password)\n\t\tdie(\"unable to get password from user\");\n}\n\nvoid credential_approve(struct credential *c)\n{\n\tint i;\n\n\tif (c->approved)\n\t\treturn;\n\tif (!c->username || !c->password)\n\t\treturn;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++)\n\t\tcredential_do(c, c->helpers.items[i].string, \"store\");\n\tc->approved = 1;\n}\n\nvoid credential_reject(struct credential *c)\n{\n\tint i;\n\n\tcredential_apply_config(c);\n\n\tfor (i = 0; i < c->helpers.nr; i++)\n\t\tcredential_do(c, c->helpers.items[i].string, \"erase\");\n\n\tFREE_AND_NULL(c->username);\n\tFREE_AND_NULL(c->password);\n\tc->approved = 0;\n}\n\nstatic int check_url_component(const char *url, int quiet,\n\t\t\t       const char *name, const char *value)\n{\n\tif (!value)\n\t\treturn 0;\n\tif (!strchr(value, '\\n'))\n\t\treturn 0;\n\n\tif (!quiet)\n\t\twarning(_(\"url contains a newline in its %s component: %s\"),\n\t\t\tname, url);\n\treturn -1;\n}\n\nint credential_from_url_gently(struct credential *c, const char *url,\n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \"://\");\n\tif (!proto_end) {\n\t\tif (!quiet)\n\t\t\twarning(_(\"url has no scheme: %s\"), url);\n\t\treturn -1;\n\t}\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\n\tif (check_url_component(url, quiet, \"username\", c->username) < 0 ||\n\t    check_url_component(url, quiet, \"password\", c->password) < 0 ||\n\t    check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \"host\", c->host) < 0 ||\n\t    check_url_component(url, quiet, \"path\", c->path) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nvoid credential_from_url(struct credential *c, const char *url)\n{\n\tif (credential_from_url_gently(c, url, 0) < 0)\n\t\tdie(_(\"credential url cannot be parsed: %s\"), url);\n}\n", "#include \"cache.h\"\n#include \"object.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"tree-walk.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"fsck.h\"\n#include \"refs.h\"\n#include \"url.h\"\n#include \"utf8.h\"\n#include \"sha1-array.h\"\n#include \"decorate.h\"\n#include \"oidset.h\"\n#include \"packfile.h\"\n#include \"submodule-config.h\"\n#include \"config.h\"\n#include \"credential.h\"\n\nstatic struct oidset gitmodules_found = OIDSET_INIT;\nstatic struct oidset gitmodules_done = OIDSET_INIT;\n\n#define FSCK_FATAL -1\n#define FSCK_INFO -2\n\n#define FOREACH_MSG_ID(FUNC) \\\n\t/* fatal errors */ \\\n\tFUNC(NUL_IN_HEADER, FATAL) \\\n\tFUNC(UNTERMINATED_HEADER, FATAL) \\\n\t/* errors */ \\\n\tFUNC(BAD_DATE, ERROR) \\\n\tFUNC(BAD_DATE_OVERFLOW, ERROR) \\\n\tFUNC(BAD_EMAIL, ERROR) \\\n\tFUNC(BAD_NAME, ERROR) \\\n\tFUNC(BAD_OBJECT_SHA1, ERROR) \\\n\tFUNC(BAD_PARENT_SHA1, ERROR) \\\n\tFUNC(BAD_TAG_OBJECT, ERROR) \\\n\tFUNC(BAD_TIMEZONE, ERROR) \\\n\tFUNC(BAD_TREE, ERROR) \\\n\tFUNC(BAD_TREE_SHA1, ERROR) \\\n\tFUNC(BAD_TYPE, ERROR) \\\n\tFUNC(DUPLICATE_ENTRIES, ERROR) \\\n\tFUNC(MISSING_AUTHOR, ERROR) \\\n\tFUNC(MISSING_COMMITTER, ERROR) \\\n\tFUNC(MISSING_EMAIL, ERROR) \\\n\tFUNC(MISSING_GRAFT, ERROR) \\\n\tFUNC(MISSING_NAME_BEFORE_EMAIL, ERROR) \\\n\tFUNC(MISSING_OBJECT, ERROR) \\\n\tFUNC(MISSING_PARENT, ERROR) \\\n\tFUNC(MISSING_SPACE_BEFORE_DATE, ERROR) \\\n\tFUNC(MISSING_SPACE_BEFORE_EMAIL, ERROR) \\\n\tFUNC(MISSING_TAG, ERROR) \\\n\tFUNC(MISSING_TAG_ENTRY, ERROR) \\\n\tFUNC(MISSING_TAG_OBJECT, ERROR) \\\n\tFUNC(MISSING_TREE, ERROR) \\\n\tFUNC(MISSING_TREE_OBJECT, ERROR) \\\n\tFUNC(MISSING_TYPE, ERROR) \\\n\tFUNC(MISSING_TYPE_ENTRY, ERROR) \\\n\tFUNC(MULTIPLE_AUTHORS, ERROR) \\\n\tFUNC(TAG_OBJECT_NOT_TAG, ERROR) \\\n\tFUNC(TREE_NOT_SORTED, ERROR) \\\n\tFUNC(UNKNOWN_TYPE, ERROR) \\\n\tFUNC(ZERO_PADDED_DATE, ERROR) \\\n\tFUNC(GITMODULES_MISSING, ERROR) \\\n\tFUNC(GITMODULES_BLOB, ERROR) \\\n\tFUNC(GITMODULES_PARSE, ERROR) \\\n\tFUNC(GITMODULES_NAME, ERROR) \\\n\tFUNC(GITMODULES_SYMLINK, ERROR) \\\n\tFUNC(GITMODULES_URL, ERROR) \\\n\tFUNC(GITMODULES_PATH, ERROR) \\\n\tFUNC(GITMODULES_UPDATE, ERROR) \\\n\t/* warnings */ \\\n\tFUNC(BAD_FILEMODE, WARN) \\\n\tFUNC(EMPTY_NAME, WARN) \\\n\tFUNC(FULL_PATHNAME, WARN) \\\n\tFUNC(HAS_DOT, WARN) \\\n\tFUNC(HAS_DOTDOT, WARN) \\\n\tFUNC(HAS_DOTGIT, WARN) \\\n\tFUNC(NULL_SHA1, WARN) \\\n\tFUNC(ZERO_PADDED_FILEMODE, WARN) \\\n\tFUNC(NUL_IN_COMMIT, WARN) \\\n\t/* infos (reported as warnings, but ignored by default) */ \\\n\tFUNC(BAD_TAG_NAME, INFO) \\\n\tFUNC(MISSING_TAGGER_ENTRY, INFO)\n\n#define MSG_ID(id, msg_type) FSCK_MSG_##id,\nenum fsck_msg_id {\n\tFOREACH_MSG_ID(MSG_ID)\n\tFSCK_MSG_MAX\n};\n#undef MSG_ID\n\n#define STR(x) #x\n#define MSG_ID(id, msg_type) { STR(id), NULL, FSCK_##msg_type },\nstatic struct {\n\tconst char *id_string;\n\tconst char *downcased;\n\tint msg_type;\n} msg_id_info[FSCK_MSG_MAX + 1] = {\n\tFOREACH_MSG_ID(MSG_ID)\n\t{ NULL, NULL, -1 }\n};\n#undef MSG_ID\n\nstatic int parse_msg_id(const char *text)\n{\n\tint i;\n\n\tif (!msg_id_info[0].downcased) {\n\t\t/* convert id_string to lower case, without underscores. */\n\t\tfor (i = 0; i < FSCK_MSG_MAX; i++) {\n\t\t\tconst char *p = msg_id_info[i].id_string;\n\t\t\tint len = strlen(p);\n\t\t\tchar *q = xmalloc(len);\n\n\t\t\tmsg_id_info[i].downcased = q;\n\t\t\twhile (*p)\n\t\t\t\tif (*p == '_')\n\t\t\t\t\tp++;\n\t\t\t\telse\n\t\t\t\t\t*(q)++ = tolower(*(p)++);\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\n\tfor (i = 0; i < FSCK_MSG_MAX; i++)\n\t\tif (!strcmp(text, msg_id_info[i].downcased))\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic int fsck_msg_type(enum fsck_msg_id msg_id,\n\tstruct fsck_options *options)\n{\n\tint msg_type;\n\n\tassert(msg_id >= 0 && msg_id < FSCK_MSG_MAX);\n\n\tif (options->msg_type)\n\t\tmsg_type = options->msg_type[msg_id];\n\telse {\n\t\tmsg_type = msg_id_info[msg_id].msg_type;\n\t\tif (options->strict && msg_type == FSCK_WARN)\n\t\t\tmsg_type = FSCK_ERROR;\n\t}\n\n\treturn msg_type;\n}\n\nstatic void init_skiplist(struct fsck_options *options, const char *path)\n{\n\tstatic struct oid_array skiplist = OID_ARRAY_INIT;\n\tint sorted, fd;\n\tchar buffer[GIT_MAX_HEXSZ + 1];\n\tstruct object_id oid;\n\n\tif (options->skiplist)\n\t\tsorted = options->skiplist->sorted;\n\telse {\n\t\tsorted = 1;\n\t\toptions->skiplist = &skiplist;\n\t}\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tdie(\"Could not open skip list: %s\", path);\n\tfor (;;) {\n\t\tconst char *p;\n\t\tint result = read_in_full(fd, buffer, sizeof(buffer));\n\t\tif (result < 0)\n\t\t\tdie_errno(\"Could not read '%s'\", path);\n\t\tif (!result)\n\t\t\tbreak;\n\t\tif (parse_oid_hex(buffer, &oid, &p) || *p != '\\n')\n\t\t\tdie(\"Invalid SHA-1: %s\", buffer);\n\t\toid_array_append(&skiplist, &oid);\n\t\tif (sorted && skiplist.nr > 1 &&\n\t\t\t\toidcmp(&skiplist.oid[skiplist.nr - 2],\n\t\t\t\t       &oid) > 0)\n\t\t\tsorted = 0;\n\t}\n\tclose(fd);\n\n\tif (sorted)\n\t\tskiplist.sorted = 1;\n}\n\nstatic int parse_msg_type(const char *str)\n{\n\tif (!strcmp(str, \"error\"))\n\t\treturn FSCK_ERROR;\n\telse if (!strcmp(str, \"warn\"))\n\t\treturn FSCK_WARN;\n\telse if (!strcmp(str, \"ignore\"))\n\t\treturn FSCK_IGNORE;\n\telse\n\t\tdie(\"Unknown fsck message type: '%s'\", str);\n}\n\nint is_valid_msg_type(const char *msg_id, const char *msg_type)\n{\n\tif (parse_msg_id(msg_id) < 0)\n\t\treturn 0;\n\tparse_msg_type(msg_type);\n\treturn 1;\n}\n\nvoid fsck_set_msg_type(struct fsck_options *options,\n\t\tconst char *msg_id, const char *msg_type)\n{\n\tint id = parse_msg_id(msg_id), type;\n\n\tif (id < 0)\n\t\tdie(\"Unhandled message id: %s\", msg_id);\n\ttype = parse_msg_type(msg_type);\n\n\tif (type != FSCK_ERROR && msg_id_info[id].msg_type == FSCK_FATAL)\n\t\tdie(\"Cannot demote %s to %s\", msg_id, msg_type);\n\n\tif (!options->msg_type) {\n\t\tint i;\n\t\tint *msg_type;\n\t\tALLOC_ARRAY(msg_type, FSCK_MSG_MAX);\n\t\tfor (i = 0; i < FSCK_MSG_MAX; i++)\n\t\t\tmsg_type[i] = fsck_msg_type(i, options);\n\t\toptions->msg_type = msg_type;\n\t}\n\n\toptions->msg_type[id] = type;\n}\n\nvoid fsck_set_msg_types(struct fsck_options *options, const char *values)\n{\n\tchar *buf = xstrdup(values), *to_free = buf;\n\tint done = 0;\n\n\twhile (!done) {\n\t\tint len = strcspn(buf, \" ,|\"), equal;\n\n\t\tdone = !buf[len];\n\t\tif (!len) {\n\t\t\tbuf++;\n\t\t\tcontinue;\n\t\t}\n\t\tbuf[len] = '\\0';\n\n\t\tfor (equal = 0;\n\t\t     equal < len && buf[equal] != '=' && buf[equal] != ':';\n\t\t     equal++)\n\t\t\tbuf[equal] = tolower(buf[equal]);\n\t\tbuf[equal] = '\\0';\n\n\t\tif (!strcmp(buf, \"skiplist\")) {\n\t\t\tif (equal == len)\n\t\t\t\tdie(\"skiplist requires a path\");\n\t\t\tinit_skiplist(options, buf + equal + 1);\n\t\t\tbuf += len + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (equal == len)\n\t\t\tdie(\"Missing '=': '%s'\", buf);\n\n\t\tfsck_set_msg_type(options, buf, buf + equal + 1);\n\t\tbuf += len + 1;\n\t}\n\tfree(to_free);\n}\n\nstatic void append_msg_id(struct strbuf *sb, const char *msg_id)\n{\n\tfor (;;) {\n\t\tchar c = *(msg_id)++;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (c != '_')\n\t\t\tstrbuf_addch(sb, tolower(c));\n\t\telse {\n\t\t\tassert(*msg_id);\n\t\t\tstrbuf_addch(sb, *(msg_id)++);\n\t\t}\n\t}\n\n\tstrbuf_addstr(sb, \": \");\n}\n\n__attribute__((format (printf, 4, 5)))\nstatic int report(struct fsck_options *options, struct object *object,\n\tenum fsck_msg_id id, const char *fmt, ...)\n{\n\tva_list ap;\n\tstruct strbuf sb = STRBUF_INIT;\n\tint msg_type = fsck_msg_type(id, options), result;\n\n\tif (msg_type == FSCK_IGNORE)\n\t\treturn 0;\n\n\tif (options->skiplist && object &&\n\t\t\toid_array_lookup(options->skiplist, &object->oid) >= 0)\n\t\treturn 0;\n\n\tif (msg_type == FSCK_FATAL)\n\t\tmsg_type = FSCK_ERROR;\n\telse if (msg_type == FSCK_INFO)\n\t\tmsg_type = FSCK_WARN;\n\n\tappend_msg_id(&sb, msg_id_info[id].id_string);\n\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(&sb, fmt, ap);\n\tresult = options->error_func(options, object, msg_type, sb.buf);\n\tstrbuf_release(&sb);\n\tva_end(ap);\n\n\treturn result;\n}\n\nstatic char *get_object_name(struct fsck_options *options, struct object *obj)\n{\n\tif (!options->object_names)\n\t\treturn NULL;\n\treturn lookup_decoration(options->object_names, obj);\n}\n\nstatic void put_object_name(struct fsck_options *options, struct object *obj,\n\tconst char *fmt, ...)\n{\n\tva_list ap;\n\tstruct strbuf buf = STRBUF_INIT;\n\tchar *existing;\n\n\tif (!options->object_names)\n\t\treturn;\n\texisting = lookup_decoration(options->object_names, obj);\n\tif (existing)\n\t\treturn;\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(&buf, fmt, ap);\n\tadd_decoration(options->object_names, obj, strbuf_detach(&buf, NULL));\n\tva_end(ap);\n}\n\nstatic const char *describe_object(struct fsck_options *o, struct object *obj)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\tchar *name;\n\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, oid_to_hex(&obj->oid));\n\tif (o->object_names && (name = lookup_decoration(o->object_names, obj)))\n\t\tstrbuf_addf(&buf, \" (%s)\", name);\n\n\treturn buf.buf;\n}\n\nstatic int fsck_walk_tree(struct tree *tree, void *data, struct fsck_options *options)\n{\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tint res = 0;\n\tconst char *name;\n\n\tif (parse_tree(tree))\n\t\treturn -1;\n\n\tname = get_object_name(options, &tree->object);\n\tif (init_tree_desc_gently(&desc, tree->buffer, tree->size))\n\t\treturn -1;\n\twhile (tree_entry_gently(&desc, &entry)) {\n\t\tstruct object *obj;\n\t\tint result;\n\n\t\tif (S_ISGITLINK(entry.mode))\n\t\t\tcontinue;\n\n\t\tif (S_ISDIR(entry.mode)) {\n\t\t\tobj = (struct object *)lookup_tree(entry.oid);\n\t\t\tif (name && obj)\n\t\t\t\tput_object_name(options, obj, \"%s%s/\", name,\n\t\t\t\t\tentry.path);\n\t\t\tresult = options->walk(obj, OBJ_TREE, data, options);\n\t\t}\n\t\telse if (S_ISREG(entry.mode) || S_ISLNK(entry.mode)) {\n\t\t\tobj = (struct object *)lookup_blob(entry.oid);\n\t\t\tif (name && obj)\n\t\t\t\tput_object_name(options, obj, \"%s%s\", name,\n\t\t\t\t\tentry.path);\n\t\t\tresult = options->walk(obj, OBJ_BLOB, data, options);\n\t\t}\n\t\telse {\n\t\t\tresult = error(\"in tree %s: entry %s has bad mode %.6o\",\n\t\t\t\t\tdescribe_object(options, &tree->object), entry.path, entry.mode);\n\t\t}\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tif (!res)\n\t\t\tres = result;\n\t}\n\treturn res;\n}\n\nstatic int fsck_walk_commit(struct commit *commit, void *data, struct fsck_options *options)\n{\n\tint counter = 0, generation = 0, name_prefix_len = 0;\n\tstruct commit_list *parents;\n\tint res;\n\tint result;\n\tconst char *name;\n\n\tif (parse_commit(commit))\n\t\treturn -1;\n\n\tname = get_object_name(options, &commit->object);\n\tif (name)\n\t\tput_object_name(options, &commit->tree->object, \"%s:\", name);\n\n\tresult = options->walk((struct object *)commit->tree, OBJ_TREE, data, options);\n\tif (result < 0)\n\t\treturn result;\n\tres = result;\n\n\tparents = commit->parents;\n\tif (name && parents) {\n\t\tint len = strlen(name), power;\n\n\t\tif (len && name[len - 1] == '^') {\n\t\t\tgeneration = 1;\n\t\t\tname_prefix_len = len - 1;\n\t\t}\n\t\telse { /* parse ~<generation> suffix */\n\t\t\tfor (generation = 0, power = 1;\n\t\t\t     len && isdigit(name[len - 1]);\n\t\t\t     power *= 10)\n\t\t\t\tgeneration += power * (name[--len] - '0');\n\t\t\tif (power > 1 && len && name[len - 1] == '~')\n\t\t\t\tname_prefix_len = len - 1;\n\t\t}\n\t}\n\n\twhile (parents) {\n\t\tif (name) {\n\t\t\tstruct object *obj = &parents->item->object;\n\n\t\t\tif (++counter > 1)\n\t\t\t\tput_object_name(options, obj, \"%s^%d\",\n\t\t\t\t\tname, counter);\n\t\t\telse if (generation > 0)\n\t\t\t\tput_object_name(options, obj, \"%.*s~%d\",\n\t\t\t\t\tname_prefix_len, name, generation + 1);\n\t\t\telse\n\t\t\t\tput_object_name(options, obj, \"%s^\", name);\n\t\t}\n\t\tresult = options->walk((struct object *)parents->item, OBJ_COMMIT, data, options);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tif (!res)\n\t\t\tres = result;\n\t\tparents = parents->next;\n\t}\n\treturn res;\n}\n\nstatic int fsck_walk_tag(struct tag *tag, void *data, struct fsck_options *options)\n{\n\tchar *name = get_object_name(options, &tag->object);\n\n\tif (parse_tag(tag))\n\t\treturn -1;\n\tif (name)\n\t\tput_object_name(options, tag->tagged, \"%s\", name);\n\treturn options->walk(tag->tagged, OBJ_ANY, data, options);\n}\n\nint fsck_walk(struct object *obj, void *data, struct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn -1;\n\n\tif (obj->type == OBJ_NONE)\n\t\tparse_object(&obj->oid);\n\n\tswitch (obj->type) {\n\tcase OBJ_BLOB:\n\t\treturn 0;\n\tcase OBJ_TREE:\n\t\treturn fsck_walk_tree((struct tree *)obj, data, options);\n\tcase OBJ_COMMIT:\n\t\treturn fsck_walk_commit((struct commit *)obj, data, options);\n\tcase OBJ_TAG:\n\t\treturn fsck_walk_tag((struct tag *)obj, data, options);\n\tdefault:\n\t\terror(\"Unknown object type for %s\", describe_object(options, obj));\n\t\treturn -1;\n\t}\n}\n\n/*\n * The entries in a tree are ordered in the _path_ order,\n * which means that a directory entry is ordered by adding\n * a slash to the end of it.\n *\n * So a directory called \"a\" is ordered _after_ a file\n * called \"a.c\", because \"a/\" sorts after \"a.c\".\n */\n#define TREE_UNORDERED (-1)\n#define TREE_HAS_DUPS  (-2)\n\nstatic int verify_ordered(unsigned mode1, const char *name1, unsigned mode2, const char *name2)\n{\n\tint len1 = strlen(name1);\n\tint len2 = strlen(name2);\n\tint len = len1 < len2 ? len1 : len2;\n\tunsigned char c1, c2;\n\tint cmp;\n\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp < 0)\n\t\treturn 0;\n\tif (cmp > 0)\n\t\treturn TREE_UNORDERED;\n\n\t/*\n\t * Ok, the first <len> characters are the same.\n\t * Now we need to order the next one, but turn\n\t * a '\\0' into a '/' for a directory entry.\n\t */\n\tc1 = name1[len];\n\tc2 = name2[len];\n\tif (!c1 && !c2)\n\t\t/*\n\t\t * git-write-tree used to write out a nonsense tree that has\n\t\t * entries with the same name, one blob and one tree.  Make\n\t\t * sure we do not have duplicate entries.\n\t\t */\n\t\treturn TREE_HAS_DUPS;\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\treturn c1 < c2 ? 0 : TREE_UNORDERED;\n}\n\nstatic int fsck_tree(struct tree *item, struct fsck_options *options)\n{\n\tint retval = 0;\n\tint has_null_sha1 = 0;\n\tint has_full_path = 0;\n\tint has_empty_name = 0;\n\tint has_dot = 0;\n\tint has_dotdot = 0;\n\tint has_dotgit = 0;\n\tint has_zero_pad = 0;\n\tint has_bad_modes = 0;\n\tint has_dup_entries = 0;\n\tint not_properly_sorted = 0;\n\tstruct tree_desc desc;\n\tunsigned o_mode;\n\tconst char *o_name;\n\n\tif (init_tree_desc_gently(&desc, item->buffer, item->size)) {\n\t\tretval += report(options, &item->object, FSCK_MSG_BAD_TREE, \"cannot be parsed as a tree\");\n\t\treturn retval;\n\t}\n\n\to_mode = 0;\n\to_name = NULL;\n\n\twhile (desc.size) {\n\t\tunsigned mode;\n\t\tconst char *name, *backslash;\n\t\tconst struct object_id *oid;\n\n\t\toid = tree_entry_extract(&desc, &name, &mode);\n\n\t\thas_null_sha1 |= is_null_oid(oid);\n\t\thas_full_path |= !!strchr(name, '/');\n\t\thas_empty_name |= !*name;\n\t\thas_dot |= !strcmp(name, \".\");\n\t\thas_dotdot |= !strcmp(name, \"..\");\n\t\thas_dotgit |= is_hfs_dotgit(name) || is_ntfs_dotgit(name);\n\t\thas_zero_pad |= *(char *)desc.buffer == '0';\n\n\t\tif (is_hfs_dotgitmodules(name) || is_ntfs_dotgitmodules(name)) {\n\t\t\tif (!S_ISLNK(mode))\n\t\t\t\toidset_insert(&gitmodules_found, oid);\n\t\t\telse\n\t\t\t\tretval += report(options, &item->object,\n\t\t\t\t\t\t FSCK_MSG_GITMODULES_SYMLINK,\n\t\t\t\t\t\t \".gitmodules is a symbolic link\");\n\t\t}\n\n\t\tif ((backslash = strchr(name, '\\\\'))) {\n\t\t\twhile (backslash) {\n\t\t\t\tbackslash++;\n\t\t\t\thas_dotgit |= is_ntfs_dotgit(backslash);\n\t\t\t\tif (is_ntfs_dotgitmodules(backslash)) {\n\t\t\t\t\tif (!S_ISLNK(mode))\n\t\t\t\t\t\toidset_insert(&gitmodules_found, oid);\n\t\t\t\t\telse\n\t\t\t\t\t\tretval += report(options, &item->object,\n\t\t\t\t\t\t\t\t FSCK_MSG_GITMODULES_SYMLINK,\n\t\t\t\t\t\t\t\t \".gitmodules is a symbolic link\");\n\t\t\t\t}\n\t\t\t\tbackslash = strchr(backslash, '\\\\');\n\t\t\t}\n\t\t}\n\n\t\tif (update_tree_entry_gently(&desc)) {\n\t\t\tretval += report(options, &item->object, FSCK_MSG_BAD_TREE, \"cannot be parsed as a tree\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (mode) {\n\t\t/*\n\t\t * Standard modes..\n\t\t */\n\t\tcase S_IFREG | 0755:\n\t\tcase S_IFREG | 0644:\n\t\tcase S_IFLNK:\n\t\tcase S_IFDIR:\n\t\tcase S_IFGITLINK:\n\t\t\tbreak;\n\t\t/*\n\t\t * This is nonstandard, but we had a few of these\n\t\t * early on when we honored the full set of mode\n\t\t * bits..\n\t\t */\n\t\tcase S_IFREG | 0664:\n\t\t\tif (!options->strict)\n\t\t\t\tbreak;\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\thas_bad_modes = 1;\n\t\t}\n\n\t\tif (o_name) {\n\t\t\tswitch (verify_ordered(o_mode, o_name, mode, name)) {\n\t\t\tcase TREE_UNORDERED:\n\t\t\t\tnot_properly_sorted = 1;\n\t\t\t\tbreak;\n\t\t\tcase TREE_HAS_DUPS:\n\t\t\t\thas_dup_entries = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\to_mode = mode;\n\t\to_name = name;\n\t}\n\n\tif (has_null_sha1)\n\t\tretval += report(options, &item->object, FSCK_MSG_NULL_SHA1, \"contains entries pointing to null sha1\");\n\tif (has_full_path)\n\t\tretval += report(options, &item->object, FSCK_MSG_FULL_PATHNAME, \"contains full pathnames\");\n\tif (has_empty_name)\n\t\tretval += report(options, &item->object, FSCK_MSG_EMPTY_NAME, \"contains empty pathname\");\n\tif (has_dot)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOT, \"contains '.'\");\n\tif (has_dotdot)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOTDOT, \"contains '..'\");\n\tif (has_dotgit)\n\t\tretval += report(options, &item->object, FSCK_MSG_HAS_DOTGIT, \"contains '.git'\");\n\tif (has_zero_pad)\n\t\tretval += report(options, &item->object, FSCK_MSG_ZERO_PADDED_FILEMODE, \"contains zero-padded file modes\");\n\tif (has_bad_modes)\n\t\tretval += report(options, &item->object, FSCK_MSG_BAD_FILEMODE, \"contains bad file modes\");\n\tif (has_dup_entries)\n\t\tretval += report(options, &item->object, FSCK_MSG_DUPLICATE_ENTRIES, \"contains duplicate file entries\");\n\tif (not_properly_sorted)\n\t\tretval += report(options, &item->object, FSCK_MSG_TREE_NOT_SORTED, \"not properly sorted\");\n\treturn retval;\n}\n\nstatic int verify_headers(const void *data, unsigned long size,\n\t\t\t  struct object *obj, struct fsck_options *options)\n{\n\tconst char *buffer = (const char *)data;\n\tunsigned long i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tswitch (buffer[i]) {\n\t\tcase '\\0':\n\t\t\treturn report(options, obj,\n\t\t\t\tFSCK_MSG_NUL_IN_HEADER,\n\t\t\t\t\"unterminated header: NUL at offset %ld\", i);\n\t\tcase '\\n':\n\t\t\tif (i + 1 < size && buffer[i + 1] == '\\n')\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * We did not find double-LF that separates the header\n\t * and the body.  Not having a body is not a crime but\n\t * we do want to see the terminating LF for the last header\n\t * line.\n\t */\n\tif (size && buffer[size - 1] == '\\n')\n\t\treturn 0;\n\n\treturn report(options, obj,\n\t\tFSCK_MSG_UNTERMINATED_HEADER, \"unterminated header\");\n}\n\nstatic int fsck_ident(const char **ident, struct object *obj, struct fsck_options *options)\n{\n\tconst char *p = *ident;\n\tchar *end;\n\n\t*ident = strchrnul(*ident, '\\n');\n\tif (**ident == '\\n')\n\t\t(*ident)++;\n\n\tif (*p == '<')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_NAME_BEFORE_EMAIL, \"invalid author/committer line - missing space before email\");\n\tp += strcspn(p, \"<>\\n\");\n\tif (*p == '>')\n\t\treturn report(options, obj, FSCK_MSG_BAD_NAME, \"invalid author/committer line - bad name\");\n\tif (*p != '<')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_EMAIL, \"invalid author/committer line - missing email\");\n\tif (p[-1] != ' ')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_SPACE_BEFORE_EMAIL, \"invalid author/committer line - missing space before email\");\n\tp++;\n\tp += strcspn(p, \"<>\\n\");\n\tif (*p != '>')\n\t\treturn report(options, obj, FSCK_MSG_BAD_EMAIL, \"invalid author/committer line - bad email\");\n\tp++;\n\tif (*p != ' ')\n\t\treturn report(options, obj, FSCK_MSG_MISSING_SPACE_BEFORE_DATE, \"invalid author/committer line - missing space before date\");\n\tp++;\n\tif (*p == '0' && p[1] != ' ')\n\t\treturn report(options, obj, FSCK_MSG_ZERO_PADDED_DATE, \"invalid author/committer line - zero-padded date\");\n\tif (date_overflows(parse_timestamp(p, &end, 10)))\n\t\treturn report(options, obj, FSCK_MSG_BAD_DATE_OVERFLOW, \"invalid author/committer line - date causes integer overflow\");\n\tif ((end == p || *end != ' '))\n\t\treturn report(options, obj, FSCK_MSG_BAD_DATE, \"invalid author/committer line - bad date\");\n\tp = end + 1;\n\tif ((*p != '+' && *p != '-') ||\n\t    !isdigit(p[1]) ||\n\t    !isdigit(p[2]) ||\n\t    !isdigit(p[3]) ||\n\t    !isdigit(p[4]) ||\n\t    (p[5] != '\\n'))\n\t\treturn report(options, obj, FSCK_MSG_BAD_TIMEZONE, \"invalid author/committer line - bad time zone\");\n\tp += 6;\n\treturn 0;\n}\n\nstatic int fsck_commit_buffer(struct commit *commit, const char *buffer,\n\tunsigned long size, struct fsck_options *options)\n{\n\tunsigned char tree_sha1[20], sha1[20];\n\tstruct commit_graft *graft;\n\tunsigned parent_count, parent_line_count = 0, author_count;\n\tint err;\n\tconst char *buffer_begin = buffer;\n\n\tif (verify_headers(buffer, size, &commit->object, options))\n\t\treturn -1;\n\n\tif (!skip_prefix(buffer, \"tree \", &buffer))\n\t\treturn report(options, &commit->object, FSCK_MSG_MISSING_TREE, \"invalid format - expected 'tree' line\");\n\tif (get_sha1_hex(buffer, tree_sha1) || buffer[40] != '\\n') {\n\t\terr = report(options, &commit->object, FSCK_MSG_BAD_TREE_SHA1, \"invalid 'tree' line format - bad sha1\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tbuffer += 41;\n\twhile (skip_prefix(buffer, \"parent \", &buffer)) {\n\t\tif (get_sha1_hex(buffer, sha1) || buffer[40] != '\\n') {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_BAD_PARENT_SHA1, \"invalid 'parent' line format - bad sha1\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbuffer += 41;\n\t\tparent_line_count++;\n\t}\n\tgraft = lookup_commit_graft(&commit->object.oid);\n\tparent_count = commit_list_count(commit->parents);\n\tif (graft) {\n\t\tif (graft->nr_parent == -1 && !parent_count)\n\t\t\t; /* shallow commit */\n\t\telse if (graft->nr_parent != parent_count) {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_GRAFT, \"graft objects missing\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (parent_count != parent_line_count) {\n\t\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_PARENT, \"parent objects missing\");\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tauthor_count = 0;\n\twhile (skip_prefix(buffer, \"author \", &buffer)) {\n\t\tauthor_count++;\n\t\terr = fsck_ident(&buffer, &commit->object, options);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (author_count < 1)\n\t\terr = report(options, &commit->object, FSCK_MSG_MISSING_AUTHOR, \"invalid format - expected 'author' line\");\n\telse if (author_count > 1)\n\t\terr = report(options, &commit->object, FSCK_MSG_MULTIPLE_AUTHORS, \"invalid format - multiple 'author' lines\");\n\tif (err)\n\t\treturn err;\n\tif (!skip_prefix(buffer, \"committer \", &buffer))\n\t\treturn report(options, &commit->object, FSCK_MSG_MISSING_COMMITTER, \"invalid format - expected 'committer' line\");\n\terr = fsck_ident(&buffer, &commit->object, options);\n\tif (err)\n\t\treturn err;\n\tif (!commit->tree) {\n\t\terr = report(options, &commit->object, FSCK_MSG_BAD_TREE, \"could not load commit's tree %s\", sha1_to_hex(tree_sha1));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (memchr(buffer_begin, '\\0', size)) {\n\t\terr = report(options, &commit->object, FSCK_MSG_NUL_IN_COMMIT,\n\t\t\t     \"NUL byte in the commit object body\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int fsck_commit(struct commit *commit, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tconst char *buffer = data ?  data : get_commit_buffer(commit, &size);\n\tint ret = fsck_commit_buffer(commit, buffer, size, options);\n\tif (!data)\n\t\tunuse_commit_buffer(commit, buffer);\n\treturn ret;\n}\n\nstatic int fsck_tag_buffer(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tunsigned char sha1[20];\n\tint ret = 0;\n\tconst char *buffer;\n\tchar *to_free = NULL, *eol;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tif (data)\n\t\tbuffer = data;\n\telse {\n\t\tenum object_type type;\n\n\t\tbuffer = to_free =\n\t\t\tread_sha1_file(tag->object.oid.hash, &type, &size);\n\t\tif (!buffer)\n\t\t\treturn report(options, &tag->object,\n\t\t\t\tFSCK_MSG_MISSING_TAG_OBJECT,\n\t\t\t\t\"cannot read tag object\");\n\n\t\tif (type != OBJ_TAG) {\n\t\t\tret = report(options, &tag->object,\n\t\t\t\tFSCK_MSG_TAG_OBJECT_NOT_TAG,\n\t\t\t\t\"expected tag got %s\",\n\t\t\t    type_name(type));\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = verify_headers(buffer, size, &tag->object, options);\n\tif (ret)\n\t\tgoto done;\n\n\tif (!skip_prefix(buffer, \"object \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_OBJECT, \"invalid format - expected 'object' line\");\n\t\tgoto done;\n\t}\n\tif (get_sha1_hex(buffer, sha1) || buffer[40] != '\\n') {\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_OBJECT_SHA1, \"invalid 'object' line format - bad sha1\");\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\tbuffer += 41;\n\n\tif (!skip_prefix(buffer, \"type \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TYPE_ENTRY, \"invalid format - expected 'type' line\");\n\t\tgoto done;\n\t}\n\teol = strchr(buffer, '\\n');\n\tif (!eol) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TYPE, \"invalid format - unexpected end after 'type' line\");\n\t\tgoto done;\n\t}\n\tif (type_from_string_gently(buffer, eol - buffer, 1) < 0)\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_TYPE, \"invalid 'type' value\");\n\tif (ret)\n\t\tgoto done;\n\tbuffer = eol + 1;\n\n\tif (!skip_prefix(buffer, \"tag \", &buffer)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAG_ENTRY, \"invalid format - expected 'tag' line\");\n\t\tgoto done;\n\t}\n\teol = strchr(buffer, '\\n');\n\tif (!eol) {\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAG, \"invalid format - unexpected end after 'type' line\");\n\t\tgoto done;\n\t}\n\tstrbuf_addf(&sb, \"refs/tags/%.*s\", (int)(eol - buffer), buffer);\n\tif (check_refname_format(sb.buf, 0)) {\n\t\tret = report(options, &tag->object, FSCK_MSG_BAD_TAG_NAME,\n\t\t\t   \"invalid 'tag' name: %.*s\",\n\t\t\t   (int)(eol - buffer), buffer);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\tbuffer = eol + 1;\n\n\tif (!skip_prefix(buffer, \"tagger \", &buffer)) {\n\t\t/* early tags do not contain 'tagger' lines; warn only */\n\t\tret = report(options, &tag->object, FSCK_MSG_MISSING_TAGGER_ENTRY, \"invalid format - expected 'tagger' line\");\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\telse\n\t\tret = fsck_ident(&buffer, &tag->object, options);\n\ndone:\n\tstrbuf_release(&sb);\n\tfree(to_free);\n\treturn ret;\n}\n\nstatic int fsck_tag(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tstruct object *tagged = tag->tagged;\n\n\tif (!tagged)\n\t\treturn report(options, &tag->object, FSCK_MSG_BAD_TAG_OBJECT, \"could not load tagged object\");\n\n\treturn fsck_tag_buffer(tag, data, size, options);\n}\n\n/*\n * Like builtin/submodule--helper.c's starts_with_dot_slash, but without\n * relying on the platform-dependent is_dir_sep helper.\n *\n * This is for use in checking whether a submodule URL is interpreted as\n * relative to the current directory on any platform, since \\ is a\n * directory separator on Windows but not on other platforms.\n */\nstatic int starts_with_dot_slash(const char *str)\n{\n\treturn str[0] == '.' && (str[1] == '/' || str[1] == '\\\\');\n}\n\n/*\n * Like starts_with_dot_slash, this is a variant of submodule--helper's\n * helper of the same name with the twist that it accepts backslash as a\n * directory separator even on non-Windows platforms.\n */\nstatic int starts_with_dot_dot_slash(const char *str)\n{\n\treturn str[0] == '.' && starts_with_dot_slash(str + 1);\n}\n\nstatic int submodule_url_is_relative(const char *url)\n{\n\treturn starts_with_dot_slash(url) || starts_with_dot_dot_slash(url);\n}\n\n/*\n * Count directory components that a relative submodule URL should chop\n * from the remote_url it is to be resolved against.\n *\n * In other words, this counts \"../\" components at the start of a\n * submodule URL.\n *\n * Returns the number of directory components to chop and writes a\n * pointer to the next character of url after all leading \"./\" and\n * \"../\" components to out.\n */\nstatic int count_leading_dotdots(const char *url, const char **out)\n{\n\tint result = 0;\n\twhile (1) {\n\t\tif (starts_with_dot_dot_slash(url)) {\n\t\t\tresult++;\n\t\t\turl += strlen(\"../\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (starts_with_dot_slash(url)) {\n\t\t\turl += strlen(\"./\");\n\t\t\tcontinue;\n\t\t}\n\t\t*out = url;\n\t\treturn result;\n\t}\n}\n/*\n * Check whether a transport is implemented by git-remote-curl.\n *\n * If it is, returns 1 and writes the URL that would be passed to\n * git-remote-curl to the \"out\" parameter.\n *\n * Otherwise, returns 0 and leaves \"out\" untouched.\n *\n * Examples:\n *   http::https://example.com/repo.git -> 1, https://example.com/repo.git\n *   https://example.com/repo.git -> 1, https://example.com/repo.git\n *   git://example.com/repo.git -> 0\n *\n * This is for use in checking for previously exploitable bugs that\n * required a submodule URL to be passed to git-remote-curl.\n */\nstatic int url_to_curl_url(const char *url, const char **out)\n{\n\t/*\n\t * We don't need to check for case-aliases, \"http.exe\", and so\n\t * on because in the default configuration, is_transport_allowed\n\t * prevents URLs with those schemes from being cloned\n\t * automatically.\n\t */\n\tif (skip_prefix(url, \"http::\", out) ||\n\t    skip_prefix(url, \"https::\", out) ||\n\t    skip_prefix(url, \"ftp::\", out) ||\n\t    skip_prefix(url, \"ftps::\", out))\n\t\treturn 1;\n\tif (starts_with(url, \"http://\") ||\n\t    starts_with(url, \"https://\") ||\n\t    starts_with(url, \"ftp://\") ||\n\t    starts_with(url, \"ftps://\")) {\n\t\t*out = url;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded;\n\t\tconst char *next;\n\t\tint has_nl;\n\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tdecoded = url_decode(url);\n\t\thas_nl = !!strchr(decoded, '\\n');\n\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * URLs which escape their root via \"../\" can overwrite\n\t\t * the host field and previous components, resolving to\n\t\t * URLs like https::example.com/submodule.git that were\n\t\t * susceptible to CVE-2020-11008.\n\t\t */\n\t\tif (count_leading_dotdots(url, &next) > 0 &&\n\t\t    *next == ':')\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstruct fsck_gitmodules_data {\n\tstruct object *obj;\n\tstruct fsck_options *options;\n\tint ret;\n};\n\nstatic int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    check_submodule_url(value) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tif (!strcmp(key, \"path\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n\t\t\t\t    \"disallowed submodule path: %s\",\n\t\t\t\t    value);\n\tif (!strcmp(key, \"update\") && value &&\n\t    parse_submodule_update_type(value) == SM_UPDATE_COMMAND)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_UPDATE,\n\t\t\t\t    \"disallowed submodule update setting: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\n\treturn 0;\n}\n\nstatic int fsck_blob(struct blob *blob, const char *buf,\n\t\t     unsigned long size, struct fsck_options *options)\n{\n\tstruct fsck_gitmodules_data data;\n\n\tif (!oidset_contains(&gitmodules_found, &blob->object.oid))\n\t\treturn 0;\n\toidset_insert(&gitmodules_done, &blob->object.oid);\n\n\tif (!buf) {\n\t\t/*\n\t\t * A missing buffer here is a sign that the caller found the\n\t\t * blob too gigantic to load into memory. Let's just consider\n\t\t * that an error.\n\t\t */\n\t\treturn report(options, &blob->object,\n\t\t\t      FSCK_MSG_GITMODULES_PARSE,\n\t\t\t      \".gitmodules too large to parse\");\n\t}\n\n\tdata.obj = &blob->object;\n\tdata.options = options;\n\tdata.ret = 0;\n\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n\t\t\t\t\".gitmodules\", buf, size, &data))\n\t\tdata.ret |= report(options, &blob->object,\n\t\t\t\t   FSCK_MSG_GITMODULES_PARSE,\n\t\t\t\t   \"could not parse gitmodules blob\");\n\n\treturn data.ret;\n}\n\nint fsck_object(struct object *obj, void *data, unsigned long size,\n\tstruct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn report(options, obj, FSCK_MSG_BAD_OBJECT_SHA1, \"no valid object to fsck\");\n\n\tif (obj->type == OBJ_BLOB)\n\t\treturn fsck_blob((struct blob *)obj, data, size, options);\n\tif (obj->type == OBJ_TREE)\n\t\treturn fsck_tree((struct tree *) obj, options);\n\tif (obj->type == OBJ_COMMIT)\n\t\treturn fsck_commit((struct commit *) obj, (const char *) data,\n\t\t\tsize, options);\n\tif (obj->type == OBJ_TAG)\n\t\treturn fsck_tag((struct tag *) obj, (const char *) data,\n\t\t\tsize, options);\n\n\treturn report(options, obj, FSCK_MSG_UNKNOWN_TYPE, \"unknown type '%d' (internal fsck error)\",\n\t\t\t  obj->type);\n}\n\nint fsck_error_function(struct fsck_options *o,\n\tstruct object *obj, int msg_type, const char *message)\n{\n\tif (msg_type == FSCK_WARN) {\n\t\twarning(\"object %s: %s\", describe_object(o, obj), message);\n\t\treturn 0;\n\t}\n\terror(\"object %s: %s\", describe_object(o, obj), message);\n\treturn 1;\n}\n\nint fsck_finish(struct fsck_options *options)\n{\n\tint ret = 0;\n\tstruct oidset_iter iter;\n\tconst struct object_id *oid;\n\n\toidset_iter_init(&gitmodules_found, &iter);\n\twhile ((oid = oidset_iter_next(&iter))) {\n\t\tstruct blob *blob;\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tchar *buf;\n\n\t\tif (oidset_contains(&gitmodules_done, oid))\n\t\t\tcontinue;\n\n\t\tblob = lookup_blob(oid);\n\t\tif (!blob) {\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n\t\t\t\t      \"non-blob found at .gitmodules\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf = read_sha1_file(oid->hash, &type, &size);\n\t\tif (!buf) {\n\t\t\tif (is_promisor_object(&blob->object.oid))\n\t\t\t\tcontinue;\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_MISSING,\n\t\t\t\t      \"unable to read .gitmodules blob\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type == OBJ_BLOB)\n\t\t\tret |= fsck_blob(blob, buf, size, options);\n\t\telse\n\t\t\tret |= report(options, &blob->object,\n\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n\t\t\t\t      \"non-blob found at .gitmodules\");\n\t\tfree(buf);\n\t}\n\n\n\toidset_clear(&gitmodules_found);\n\toidset_clear(&gitmodules_done);\n\treturn ret;\n}\n", "#!/bin/sh\n\ntest_description='test dumb fetching over http via static file'\n. ./test-lib.sh\n. \"$TEST_DIRECTORY\"/lib-httpd.sh\nstart_httpd\n\ntest_expect_success 'setup repository' '\n\tgit config push.default matching &&\n\techo content1 >file &&\n\tgit add file &&\n\tgit commit -m one &&\n\techo content2 >file &&\n\tgit add file &&\n\tgit commit -m two\n'\n\ntest_expect_success 'create http-accessible bare repository with loose objects' '\n\tcp -R .git \"$HTTPD_DOCUMENT_ROOT_PATH/repo.git\" &&\n\t(cd \"$HTTPD_DOCUMENT_ROOT_PATH/repo.git\" &&\n\t git config core.bare true &&\n\t mkdir -p hooks &&\n\t write_script \"hooks/post-update\" <<-\\EOF &&\n\t exec git update-server-info\n\tEOF\n\t hooks/post-update\n\t) &&\n\tgit remote add public \"$HTTPD_DOCUMENT_ROOT_PATH/repo.git\" &&\n\tgit push public master:master\n'\n\ntest_expect_success 'clone http repository' '\n\tgit clone $HTTPD_URL/dumb/repo.git clone-tmpl &&\n\tcp -R clone-tmpl clone &&\n\ttest_cmp file clone/file\n'\n\ntest_expect_success 'list refs from outside any repository' '\n\tcat >expect <<-EOF &&\n\t$(git rev-parse master)\tHEAD\n\t$(git rev-parse master)\trefs/heads/master\n\tEOF\n\tnongit git ls-remote \"$HTTPD_URL/dumb/repo.git\" >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'create password-protected repository' '\n\tmkdir -p \"$HTTPD_DOCUMENT_ROOT_PATH/auth/dumb/\" &&\n\tcp -Rf \"$HTTPD_DOCUMENT_ROOT_PATH/repo.git\" \\\n\t       \"$HTTPD_DOCUMENT_ROOT_PATH/auth/dumb/repo.git\"\n'\n\nsetup_askpass_helper\n\ntest_expect_success 'cloning password-protected repository can fail' '\n\tset_askpass wrong &&\n\ttest_must_fail git clone \"$HTTPD_URL/auth/dumb/repo.git\" clone-auth-fail &&\n\texpect_askpass both wrong\n'\n\ntest_expect_success 'http auth can use user/pass in URL' '\n\tset_askpass wrong &&\n\tgit clone \"$HTTPD_URL_USER_PASS/auth/dumb/repo.git\" clone-auth-none &&\n\texpect_askpass none\n'\n\ntest_expect_success 'http auth can use just user in URL' '\n\tset_askpass wrong pass@host &&\n\tgit clone \"$HTTPD_URL_USER/auth/dumb/repo.git\" clone-auth-pass &&\n\texpect_askpass pass user@host\n'\n\ntest_expect_success 'http auth can request both user and pass' '\n\tset_askpass user@host pass@host &&\n\tgit clone \"$HTTPD_URL/auth/dumb/repo.git\" clone-auth-both &&\n\texpect_askpass both user@host\n'\n\ntest_expect_success 'http auth respects credential helper config' '\n\ttest_config_global credential.helper \"!f() {\n\t\tcat >/dev/null\n\t\techo username=user@host\n\t\techo password=pass@host\n\t}; f\" &&\n\tset_askpass wrong &&\n\tgit clone \"$HTTPD_URL/auth/dumb/repo.git\" clone-auth-helper &&\n\texpect_askpass none\n'\n\ntest_expect_success 'http auth can get username from config' '\n\ttest_config_global \"credential.$HTTPD_URL.username\" user@host &&\n\tset_askpass wrong pass@host &&\n\tgit clone \"$HTTPD_URL/auth/dumb/repo.git\" clone-auth-user &&\n\texpect_askpass pass user@host\n'\n\ntest_expect_success 'configured username does not override URL' '\n\ttest_config_global \"credential.$HTTPD_URL.username\" wrong &&\n\tset_askpass wrong pass@host &&\n\tgit clone \"$HTTPD_URL_USER/auth/dumb/repo.git\" clone-auth-user2 &&\n\texpect_askpass pass user@host\n'\n\ntest_expect_success 'set up repo with http submodules' '\n\tgit init super &&\n\tset_askpass user@host pass@host &&\n\t(\n\t\tcd super &&\n\t\tgit submodule add \"$HTTPD_URL/auth/dumb/repo.git\" sub &&\n\t\tgit commit -m \"add submodule\"\n\t)\n'\n\ntest_expect_success 'cmdline credential config passes to submodule via clone' '\n\tset_askpass wrong pass@host &&\n\ttest_must_fail git clone --recursive super super-clone &&\n\trm -rf super-clone &&\n\n\tset_askpass wrong pass@host &&\n\tgit -c \"credential.$HTTPD_URL.username=user@host\" \\\n\t\tclone --recursive super super-clone &&\n\texpect_askpass pass user@host\n'\n\ntest_expect_success 'cmdline credential config passes submodule via fetch' '\n\tset_askpass wrong pass@host &&\n\ttest_must_fail git -C super-clone fetch --recurse-submodules &&\n\n\tset_askpass wrong pass@host &&\n\tgit -C super-clone \\\n\t    -c \"credential.$HTTPD_URL.username=user@host\" \\\n\t    fetch --recurse-submodules &&\n\texpect_askpass pass user@host\n'\n\ntest_expect_success 'cmdline credential config passes submodule update' '\n\t# advance the submodule HEAD so that a fetch is required\n\tgit commit --allow-empty -m foo &&\n\tgit push \"$HTTPD_DOCUMENT_ROOT_PATH/auth/dumb/repo.git\" HEAD &&\n\tsha1=$(git rev-parse HEAD) &&\n\tgit -C super-clone update-index --cacheinfo 160000,$sha1,sub &&\n\n\tset_askpass wrong pass@host &&\n\ttest_must_fail git -C super-clone submodule update &&\n\n\tset_askpass wrong pass@host &&\n\tgit -C super-clone \\\n\t    -c \"credential.$HTTPD_URL.username=user@host\" \\\n\t    submodule update &&\n\texpect_askpass pass user@host\n'\n\ntest_expect_success 'fetch changes via http' '\n\techo content >>file &&\n\tgit commit -a -m two &&\n\tgit push public &&\n\t(cd clone && git pull) &&\n\ttest_cmp file clone/file\n'\n\ntest_expect_success 'fetch changes via manual http-fetch' '\n\tcp -R clone-tmpl clone2 &&\n\n\tHEAD=$(git rev-parse --verify HEAD) &&\n\t(cd clone2 &&\n\t git http-fetch -a -w heads/master-new $HEAD $(git config remote.origin.url) &&\n\t git checkout master-new &&\n\t test $HEAD = $(git rev-parse --verify HEAD)) &&\n\ttest_cmp file clone2/file\n'\n\ntest_expect_success 'http remote detects correct HEAD' '\n\tgit push public master:other &&\n\t(cd clone &&\n\t git remote set-head origin -d &&\n\t git remote set-head origin -a &&\n\t git symbolic-ref refs/remotes/origin/HEAD > output &&\n\t echo refs/remotes/origin/master > expect &&\n\t test_cmp expect output\n\t)\n'\n\ntest_expect_success 'fetch packed objects' '\n\tcp -R \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo.git \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_pack.git &&\n\t(cd \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_pack.git &&\n\t git --bare repack -a -d\n\t) &&\n\tgit clone $HTTPD_URL/dumb/repo_pack.git\n'\n\ntest_expect_success 'fetch notices corrupt pack' '\n\tcp -R \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_pack.git \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_bad1.git &&\n\t(cd \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_bad1.git &&\n\t p=$(ls objects/pack/pack-*.pack) &&\n\t chmod u+w $p &&\n\t printf %0256d 0 | dd of=$p bs=256 count=1 seek=1 conv=notrunc\n\t) &&\n\tmkdir repo_bad1.git &&\n\t(cd repo_bad1.git &&\n\t git --bare init &&\n\t test_must_fail git --bare fetch $HTTPD_URL/dumb/repo_bad1.git &&\n\t test 0 = $(ls objects/pack/pack-*.pack | wc -l)\n\t)\n'\n\ntest_expect_success 'fetch notices corrupt idx' '\n\tcp -R \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_pack.git \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_bad2.git &&\n\t(cd \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_bad2.git &&\n\t p=$(ls objects/pack/pack-*.idx) &&\n\t chmod u+w $p &&\n\t printf %0256d 0 | dd of=$p bs=256 count=1 seek=1 conv=notrunc\n\t) &&\n\tmkdir repo_bad2.git &&\n\t(cd repo_bad2.git &&\n\t git --bare init &&\n\t test_must_fail git --bare fetch $HTTPD_URL/dumb/repo_bad2.git &&\n\t test 0 = $(ls objects/pack | wc -l)\n\t)\n'\n\ntest_expect_success 'fetch can handle previously-fetched .idx files' '\n\tgit checkout --orphan branch1 &&\n\techo base >file &&\n\tgit add file &&\n\tgit commit -m base &&\n\tgit --bare init \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_packed_branches.git &&\n\tgit push \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_packed_branches.git branch1 &&\n\tgit --git-dir=\"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_packed_branches.git repack -d &&\n\tgit checkout -b branch2 branch1 &&\n\techo b2 >>file &&\n\tgit commit -a -m b2 &&\n\tgit push \"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_packed_branches.git branch2 &&\n\tgit --git-dir=\"$HTTPD_DOCUMENT_ROOT_PATH\"/repo_packed_branches.git repack -d &&\n\tgit --bare init clone_packed_branches.git &&\n\tgit --git-dir=clone_packed_branches.git fetch \"$HTTPD_URL\"/dumb/repo_packed_branches.git branch1:branch1 &&\n\tgit --git-dir=clone_packed_branches.git fetch \"$HTTPD_URL\"/dumb/repo_packed_branches.git branch2:branch2\n'\n\ntest_expect_success 'did not use upload-pack service' '\n\ttest_might_fail grep '/git-upload-pack' <\"$HTTPD_ROOT_PATH\"/access.log >act &&\n\t: >exp &&\n\ttest_cmp exp act\n'\n\ntest_expect_success 'git client shows text/plain errors' '\n\ttest_must_fail git clone \"$HTTPD_URL/error/text\" 2>stderr &&\n\tgrep \"this is the error message\" stderr\n'\n\ntest_expect_success 'git client does not show html errors' '\n\ttest_must_fail git clone \"$HTTPD_URL/error/html\" 2>stderr &&\n\t! grep \"this is the error message\" stderr\n'\n\ntest_expect_success 'git client shows text/plain with a charset' '\n\ttest_must_fail git clone \"$HTTPD_URL/error/charset\" 2>stderr &&\n\tgrep \"this is the error message\" stderr\n'\n\ntest_expect_success 'http error messages are reencoded' '\n\ttest_must_fail git clone \"$HTTPD_URL/error/utf16\" 2>stderr &&\n\tgrep \"this is the error message\" stderr\n'\n\ntest_expect_success 'reencoding is robust to whitespace oddities' '\n\ttest_must_fail git clone \"$HTTPD_URL/error/odd-spacing\" 2>stderr &&\n\tgrep \"this is the error message\" stderr\n'\n\ncheck_language () {\n\tcase \"$2\" in\n\t'')\n\t\t>expect\n\t\t;;\n\t?*)\n\t\techo \"=> Send header: Accept-Language: $1\" >expect\n\t\t;;\n\tesac &&\n\tGIT_TRACE_CURL=true \\\n\tLANGUAGE=$2 \\\n\tgit ls-remote \"$HTTPD_URL/dumb/repo.git\" >output 2>&1 &&\n\ttr -d '\\015' <output |\n\tsort -u |\n\tsed -ne '/^=> Send header: Accept-Language:/ p' >actual &&\n\ttest_cmp expect actual\n}\n\ntest_expect_success 'git client sends Accept-Language based on LANGUAGE' '\n\tcheck_language \"ko-KR, *;q=0.9\" ko_KR.UTF-8'\n\ntest_expect_success 'git client sends Accept-Language correctly with unordinary LANGUAGE' '\n\tcheck_language \"ko-KR, *;q=0.9\" \"ko_KR:\" &&\n\tcheck_language \"ko-KR, en-US;q=0.9, *;q=0.8\" \"ko_KR::en_US\" &&\n\tcheck_language \"ko-KR, *;q=0.9\" \":::ko_KR\" &&\n\tcheck_language \"ko-KR, en-US;q=0.9, *;q=0.8\" \"ko_KR!!:en_US\" &&\n\tcheck_language \"ko-KR, ja-JP;q=0.9, *;q=0.8\" \"ko_KR en_US:ja_JP\"'\n\ntest_expect_success 'git client sends Accept-Language with many preferred languages' '\n\tcheck_language \"ko-KR, en-US;q=0.9, fr-CA;q=0.8, de;q=0.7, sr;q=0.6, \\\nja;q=0.5, zh;q=0.4, sv;q=0.3, pt;q=0.2, *;q=0.1\" \\\n\t\tko_KR.EUC-KR:en_US.UTF-8:fr_CA:de.UTF-8@euro:sr@latin:ja:zh:sv:pt &&\n\tcheck_language \"ko-KR, en-US;q=0.99, fr-CA;q=0.98, de;q=0.97, sr;q=0.96, \\\nja;q=0.95, zh;q=0.94, sv;q=0.93, pt;q=0.92, nb;q=0.91, *;q=0.90\" \\\n\t\tko_KR.EUC-KR:en_US.UTF-8:fr_CA:de.UTF-8@euro:sr@latin:ja:zh:sv:pt:nb\n'\n\ntest_expect_success 'git client does not send an empty Accept-Language' '\n\tGIT_TRACE_CURL=true LANGUAGE= git ls-remote \"$HTTPD_URL/dumb/repo.git\" 2>stderr &&\n\t! grep \"^=> Send header: Accept-Language:\" stderr\n'\n\ntest_expect_success 'remote-http complains cleanly about malformed urls' '\n\ttest_must_fail git remote-http http::/example.com/repo.git 2>stderr &&\n\ttest_i18ngrep \"url has no scheme\" stderr\n'\n\ntest_expect_success 'redirects can be forbidden/allowed' '\n\ttest_must_fail git -c http.followRedirects=false \\\n\t\tclone $HTTPD_URL/dumb-redir/repo.git dumb-redir &&\n\tgit -c http.followRedirects=true \\\n\t\tclone $HTTPD_URL/dumb-redir/repo.git dumb-redir 2>stderr\n'\n\ntest_expect_success 'redirects are reported to stderr' '\n\t# just look for a snippet of the redirected-to URL\n\ttest_i18ngrep /dumb/ stderr\n'\n\ntest_expect_success 'non-initial redirects can be forbidden' '\n\ttest_must_fail git -c http.followRedirects=initial \\\n\t\tclone $HTTPD_URL/redir-objects/repo.git redir-objects &&\n\tgit -c http.followRedirects=true \\\n\t\tclone $HTTPD_URL/redir-objects/repo.git redir-objects\n'\n\ntest_expect_success 'http.followRedirects defaults to \"initial\"' '\n\ttest_must_fail git clone $HTTPD_URL/redir-objects/repo.git default\n'\n\n# The goal is for a clone of the \"evil\" repository, which has no objects\n# itself, to cause the client to fetch objects from the \"victim\" repository.\ntest_expect_success 'set up evil alternates scheme' '\n\tvictim=$HTTPD_DOCUMENT_ROOT_PATH/victim.git &&\n\tgit init --bare \"$victim\" &&\n\tgit -C \"$victim\" --work-tree=. commit --allow-empty -m secret &&\n\tgit -C \"$victim\" repack -ad &&\n\tgit -C \"$victim\" update-server-info &&\n\tsha1=$(git -C \"$victim\" rev-parse HEAD) &&\n\n\tevil=$HTTPD_DOCUMENT_ROOT_PATH/evil.git &&\n\tgit init --bare \"$evil\" &&\n\t# do this by hand to avoid object existence check\n\tprintf \"%s\\\\t%s\\\\n\" $sha1 refs/heads/master >\"$evil/info/refs\"\n'\n\n# Here we'll just redirect via HTTP. In a real-world attack these would be on\n# different servers, but we should reject it either way.\ntest_expect_success 'http-alternates is a non-initial redirect' '\n\techo \"$HTTPD_URL/dumb/victim.git/objects\" \\\n\t\t>\"$evil/objects/info/http-alternates\" &&\n\ttest_must_fail git -c http.followRedirects=initial \\\n\t\tclone $HTTPD_URL/dumb/evil.git evil-initial &&\n\tgit -c http.followRedirects=true \\\n\t\tclone $HTTPD_URL/dumb/evil.git evil-initial\n'\n\n# Curl supports a lot of protocols that we'd prefer not to allow\n# http-alternates to use, but it's hard to test whether curl has\n# accessed, say, the SMTP protocol, because we are not running an SMTP server.\n# But we can check that it does not allow access to file://, which would\n# otherwise allow this clone to complete.\ntest_expect_success 'http-alternates cannot point at funny protocols' '\n\techo \"file://$victim/objects\" >\"$evil/objects/info/http-alternates\" &&\n\ttest_must_fail git -c http.followRedirects=true \\\n\t\tclone \"$HTTPD_URL/dumb/evil.git\" evil-file\n'\n\ntest_expect_success 'http-alternates triggers not-from-user protocol check' '\n\techo \"$HTTPD_URL/dumb/victim.git/objects\" \\\n\t\t>\"$evil/objects/info/http-alternates\" &&\n\ttest_config_global http.followRedirects true &&\n\ttest_must_fail git -c protocol.http.allow=user \\\n\t\tclone $HTTPD_URL/dumb/evil.git evil-user &&\n\tgit -c protocol.http.allow=always \\\n\t\tclone $HTTPD_URL/dumb/evil.git evil-user\n'\n\ntest_expect_success 'can redirect through non-\"info/refs?service=git-upload-pack\" URL' '\n\tgit clone \"$HTTPD_URL/redir-to/dumb/repo.git\"\n'\n\ntest_expect_success 'print HTTP error when any intermediate redirect throws error' '\n\ttest_must_fail git clone \"$HTTPD_URL/redir-to/502\" 2> stderr &&\n\ttest_i18ngrep \"unable to access.*/redir-to/502\" stderr\n'\n\nstop_httpd\ntest_done\n", "#!/bin/sh\n\ntest_description='check handling of disallowed .gitmodule urls'\n. ./test-lib.sh\n\ntest_expect_success 'create submodule with protected dash in url' '\n\tgit init upstream &&\n\tgit -C upstream commit --allow-empty -m base &&\n\tmv upstream ./-upstream &&\n\tgit submodule add ./-upstream sub &&\n\tgit add sub .gitmodules &&\n\tgit commit -m submodule\n'\n\ntest_expect_success 'clone can recurse submodule' '\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit clone --recurse-submodules . dst &&\n\techo base >expect &&\n\tgit -C dst/sub log -1 --format=%s >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'fsck accepts protected dash' '\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\tgit push dst HEAD\n'\n\ntest_expect_success 'remove ./ protection from .gitmodules url' '\n\tperl -i -pe \"s{\\./}{}\" .gitmodules &&\n\tgit commit -am \"drop protection\"\n'\n\ntest_expect_success 'clone rejects unprotected dash' '\n\ttest_when_finished \"rm -rf dst\" &&\n\ttest_must_fail git clone --recurse-submodules . dst 2>err &&\n\ttest_i18ngrep ignoring err\n'\n\ntest_expect_success 'fsck rejects unprotected dash' '\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\ttest_must_fail git push dst HEAD 2>err &&\n\tgrep gitmodulesUrl err\n'\n\ntest_expect_success 'trailing backslash is handled correctly' '\n\tgit init testmodule &&\n\ttest_commit -C testmodule c &&\n\tgit submodule add ./testmodule &&\n\t: ensure that the name ends in a double backslash &&\n\tsed -e \"s|\\\\(submodule \\\"testmodule\\\\)\\\"|\\\\1\\\\\\\\\\\\\\\\\\\"|\" \\\n\t\t-e \"s|url = .*|url = \\\" --should-not-be-an-option\\\"|\" \\\n\t\t<.gitmodules >.new &&\n\tmv .new .gitmodules &&\n\tgit commit -am \"Add testmodule\" &&\n\ttest_must_fail git clone --verbose --recurse-submodules . dolly 2>err &&\n\ttest_i18ngrep ! \"unknown option\" err\n'\n\ntest_expect_success 'fsck rejects missing URL scheme' '\n\tgit checkout --orphan missing-scheme &&\n\tcat >.gitmodules <<-\\EOF &&\n\t[submodule \"foo\"]\n\t\turl = http::one.example.com/foo.git\n\tEOF\n\tgit add .gitmodules &&\n\ttest_tick &&\n\tgit commit -m \"gitmodules with missing URL scheme\" &&\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\ttest_must_fail git push dst HEAD 2>err &&\n\tgrep gitmodulesUrl err\n'\n\ntest_expect_success 'fsck rejects relative URL resolving to missing scheme' '\n\tgit checkout --orphan relative-missing-scheme &&\n\tcat >.gitmodules <<-\\EOF &&\n\t[submodule \"foo\"]\n\t\turl = \"..\\\\../.\\\\../:one.example.com/foo.git\"\n\tEOF\n\tgit add .gitmodules &&\n\ttest_tick &&\n\tgit commit -m \"gitmodules with relative URL that strips off scheme\" &&\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\ttest_must_fail git push dst HEAD 2>err &&\n\tgrep gitmodulesUrl err\n'\n\ntest_expect_success 'fsck permits embedded newline with unrecognized scheme' '\n\tgit checkout --orphan newscheme &&\n\tcat >.gitmodules <<-\\EOF &&\n\t[submodule \"foo\"]\n\t\turl = \"data://acjbkd%0akajfdickajkd\"\n\tEOF\n\tgit add .gitmodules &&\n\tgit commit -m \"gitmodules with unrecognized scheme\" &&\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\tgit push dst HEAD\n'\n\ntest_expect_success 'fsck rejects embedded newline in url' '\n\t# create an orphan branch to avoid existing .gitmodules objects\n\tgit checkout --orphan newline &&\n\tcat >.gitmodules <<-\\EOF &&\n\t[submodule \"foo\"]\n\turl = \"https://one.example.com?%0ahost=two.example.com/foo.git\"\n\tEOF\n\tgit add .gitmodules &&\n\tgit commit -m \"gitmodules with newline\" &&\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\ttest_must_fail git push dst HEAD 2>err &&\n\tgrep gitmodulesUrl err\n'\n\ntest_expect_success 'fsck rejects embedded newline in relative url' '\n\tgit checkout --orphan relative-newline &&\n\tcat >.gitmodules <<-\\EOF &&\n\t[submodule \"foo\"]\n\t\turl = \"./%0ahost=two.example.com/foo.git\"\n\tEOF\n\tgit add .gitmodules &&\n\tgit commit -m \"relative url with newline\" &&\n\ttest_when_finished \"rm -rf dst\" &&\n\tgit init --bare dst &&\n\tgit -C dst config transfer.fsckObjects true &&\n\ttest_must_fail git push dst HEAD 2>err &&\n\tgrep gitmodulesUrl err\n'\n\ntest_done\n"], "buggy_code_start_loc": [360, 974, 313, 62], "buggy_code_end_loc": [362, 1028, 318, 62], "fixing_code_start_loc": [360, 975, 313, 63], "fixing_code_end_loc": [365, 1072, 315, 95], "type": "CWE-522", "message": "Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. This bug is similar to CVE-2020-5260(GHSA-qm7j-c969-7j4q). The fix for that bug still left the door open for an exploit where _some_ credential is leaked (but the attacker cannot control which one). Git uses external \"credential helper\" programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that are considered illegal as of the recently published Git versions can cause Git to send a \"blank\" pattern to helpers, missing hostname and protocol fields. Many helpers will interpret this as matching _any_ URL, and will return some unspecified stored password, leaking the password to an attacker's server. The vulnerability can be triggered by feeding a malicious URL to `git clone`. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. The root of the problem is in Git itself, which should not be feeding blank input to helpers. However, the ability to exploit the vulnerability in practice depends on which helpers are in use. Credential helpers which are known to trigger the vulnerability: - Git's \"store\" helper - Git's \"cache\" helper - the \"osxkeychain\" helper that ships in Git's \"contrib\" directory Credential helpers which are known to be safe even with vulnerable versions of Git: - Git Credential Manager for Windows Any helper not in this list should be assumed to trigger the vulnerability.", "other": {"cve": {"id": "CVE-2020-11008", "sourceIdentifier": "security-advisories@github.com", "published": "2020-04-21T19:15:13.457", "lastModified": "2021-01-26T14:55:48.100", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. This bug is similar to CVE-2020-5260(GHSA-qm7j-c969-7j4q). The fix for that bug still left the door open for an exploit where _some_ credential is leaked (but the attacker cannot control which one). Git uses external \"credential helper\" programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that are considered illegal as of the recently published Git versions can cause Git to send a \"blank\" pattern to helpers, missing hostname and protocol fields. Many helpers will interpret this as matching _any_ URL, and will return some unspecified stored password, leaking the password to an attacker's server. The vulnerability can be triggered by feeding a malicious URL to `git clone`. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. The root of the problem is in Git itself, which should not be feeding blank input to helpers. However, the ability to exploit the vulnerability in practice depends on which helpers are in use. Credential helpers which are known to trigger the vulnerability: - Git's \"store\" helper - Git's \"cache\" helper - the \"osxkeychain\" helper that ships in Git's \"contrib\" directory Credential helpers which are known to be safe even with vulnerable versions of Git: - Git Credential Manager for Windows Any helper not in this list should be assumed to trigger the vulnerability."}, {"lang": "es", "value": "Las versiones afectadas de Git tienen una vulnerabilidad por la que Git puede ser enga\u00f1ado para que env\u00ede credenciales privadas a un host controlado por un atacante. Este fallo es similar al CVE-2020-5260 (GHSA-qm7j-c969-7j4q). La correcci\u00f3n de ese bug todav\u00eda deja la puerta abierta para una explotaci\u00f3n donde se filtra la credencial de _some_ (pero el atacante no puede controlar cu\u00e1l). Git utiliza programas externos de \"credential helper\" para almacenar y recuperar contrase\u00f1as u otras credenciales desde el almacenamiento seguro proporcionado por el sistema operativo. Las URLs especialmente dise\u00f1adas que se consideran ilegales a partir de las versiones de Git recientemente publicadas pueden hacer que Git env\u00ede un patr\u00f3n \"blank\" a los asistentes, faltando los campos hostname y protocol. Muchos asistentes interpretar\u00e1n esto como una coincidencia con la URL _any_, y devolver\u00e1n alguna contrase\u00f1a almacenada sin especificar, filtrando la contrase\u00f1a hacia el servidor de un atacante. La vulnerabilidad puede ser desencadenada alimentando una URL maliciosa a \"git clone\". Sin embargo, las URLs afectadas parecen bastante sospechosas; el vector probable ser\u00eda por medio de sistemas que clonan autom\u00e1ticamente las URLs no visibles para el usuario, tales como los subm\u00f3dulos de Git, o sistemas de paquetes construidos alrededor de Git. La ra\u00edz del problema est\u00e1 en el propio Git, que no deber\u00eda estar alimentando con entradas en blanco a los asistentes. Sin embargo, la capacidad de explotar la vulnerabilidad en la pr\u00e1ctica depende de los asistentes que se utilicen. Los asistentes con credenciales que se sabe que desencadenan la vulnerabilidad: - El asistente \"store\" de Git - El asistente \"cache\" de Git - El asistente \"osxkeychain\" que se incluye en los asistentes de Credenciales del directorio \"contrib\" de Git que se conoce que son seguros incluso con versiones vulnerables de Git: - Cualquier asistente de Git Credential Manager para Windows que no est\u00e9 en esta lista, se debe asumir que desencadena la vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-522"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.17.5", "matchCriteriaId": "A186DC51-DE8D-4CDB-BEAD-475935A09B26"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.18.0", "versionEndExcluding": "2.18.4", "matchCriteriaId": "58AE7EAD-B185-4A6A-B0E9-9D8524C60072"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.19.0", "versionEndExcluding": "2.19.5", "matchCriteriaId": "C84AEEBC-8FBB-467E-B27F-AE89A976A2B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.20.0", "versionEndExcluding": "2.20.4", "matchCriteriaId": "E576EE5A-19AE-4DA8-B68D-E7FEC317A737"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.21.0", "versionEndExcluding": "2.21.3", "matchCriteriaId": "A3C2AA1C-4CDC-4DF7-9BFC-07313AF87903"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.22.0", "versionEndExcluding": "2.22.4", "matchCriteriaId": "75C66031-DF10-41CE-8A96-60BEFDE87B38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.23.0", "versionEndExcluding": "2.23.3", "matchCriteriaId": "34A96F37-0E8A-4C56-BF7A-0987E18F7BFB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.24.0", "versionEndExcluding": "2.24.3", "matchCriteriaId": "5FCA2D68-889E-4358-AF00-D94D7117DB5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.25.0", "versionEndExcluding": "2.25.4", "matchCriteriaId": "76FA3125-7826-4480-A06E-B81940FD22E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.26.0", "versionEndExcluding": "2.26.2", "matchCriteriaId": "8318D40D-AD16-461E-9D25-AC0069864832"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00003.html", "source": "security-advisories@github.com"}, {"url": "http://seclists.org/fulldisclosure/2020/May/41", "source": "security-advisories@github.com"}, {"url": "https://github.com/git/git/commit/c44088ecc4b0722636e0a305f9608d3047197282", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/git/git/security/advisories/GHSA-hjc9-x69f-jqj7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/git/git/security/advisories/GHSA-qm7j-c969-7j4q", "source": "security-advisories@github.com", "tags": ["Mitigation", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/04/msg00015.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/74Q7WVJ6FKLIN62VS2JD2XCNWK5TNKOW/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MOCTR2SEHCPSCOVUQJAGFPGKFMI2VE6V/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PN3FUOXKX3AXTULYV53ACABER2W2FSOU/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202004-13", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT211183", "source": "security-advisories@github.com"}, {"url": "https://usn.ubuntu.com/4334-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/git/git/commit/c44088ecc4b0722636e0a305f9608d3047197282"}}