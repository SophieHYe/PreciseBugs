{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2014-2020, NVIDIA CORPORATION.  All rights reserved.\n */\n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/phy/phy.h>\n#include <linux/phy/tegra/xusb.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include <soc/tegra/fuse.h>\n\n#include \"xusb.h\"\n\nstatic struct phy *tegra_xusb_pad_of_xlate(struct device *dev,\n\t\t\t\t\t   struct of_phandle_args *args)\n{\n\tstruct tegra_xusb_pad *pad = dev_get_drvdata(dev);\n\tstruct phy *phy = NULL;\n\tunsigned int i;\n\n\tif (args->args_count != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < pad->soc->num_lanes; i++) {\n\t\tif (!pad->lanes[i])\n\t\t\tcontinue;\n\n\t\tif (pad->lanes[i]->dev.of_node == args->np) {\n\t\t\tphy = pad->lanes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (phy == NULL)\n\t\tphy = ERR_PTR(-ENODEV);\n\n\treturn phy;\n}\n\nstatic const struct of_device_id tegra_xusb_padctl_of_match[] = {\n#if defined(CONFIG_ARCH_TEGRA_124_SOC) || defined(CONFIG_ARCH_TEGRA_132_SOC)\n\t{\n\t\t.compatible = \"nvidia,tegra124-xusb-padctl\",\n\t\t.data = &tegra124_xusb_padctl_soc,\n\t},\n#endif\n#if defined(CONFIG_ARCH_TEGRA_210_SOC)\n\t{\n\t\t.compatible = \"nvidia,tegra210-xusb-padctl\",\n\t\t.data = &tegra210_xusb_padctl_soc,\n\t},\n#endif\n#if defined(CONFIG_ARCH_TEGRA_186_SOC)\n\t{\n\t\t.compatible = \"nvidia,tegra186-xusb-padctl\",\n\t\t.data = &tegra186_xusb_padctl_soc,\n\t},\n#endif\n#if defined(CONFIG_ARCH_TEGRA_194_SOC)\n\t{\n\t\t.compatible = \"nvidia,tegra194-xusb-padctl\",\n\t\t.data = &tegra194_xusb_padctl_soc,\n\t},\n#endif\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_xusb_padctl_of_match);\n\nstatic struct device_node *\ntegra_xusb_find_pad_node(struct tegra_xusb_padctl *padctl, const char *name)\n{\n\tstruct device_node *pads, *np;\n\n\tpads = of_get_child_by_name(padctl->dev->of_node, \"pads\");\n\tif (!pads)\n\t\treturn NULL;\n\n\tnp = of_get_child_by_name(pads, name);\n\tof_node_put(pads);\n\n\treturn np;\n}\n\nstatic struct device_node *\ntegra_xusb_pad_find_phy_node(struct tegra_xusb_pad *pad, unsigned int index)\n{\n\tstruct device_node *np, *lanes;\n\n\tlanes = of_get_child_by_name(pad->dev.of_node, \"lanes\");\n\tif (!lanes)\n\t\treturn NULL;\n\n\tnp = of_get_child_by_name(lanes, pad->soc->lanes[index].name);\n\tof_node_put(lanes);\n\n\treturn np;\n}\n\nint tegra_xusb_lane_parse_dt(struct tegra_xusb_lane *lane,\n\t\t\t     struct device_node *np)\n{\n\tstruct device *dev = &lane->pad->dev;\n\tconst char *function;\n\tint err;\n\n\terr = of_property_read_string(np, \"nvidia,function\", &function);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = match_string(lane->soc->funcs, lane->soc->num_funcs, function);\n\tif (err < 0) {\n\t\tdev_err(dev, \"invalid function \\\"%s\\\" for lane \\\"%pOFn\\\"\\n\",\n\t\t\tfunction, np);\n\t\treturn err;\n\t}\n\n\tlane->function = err;\n\n\treturn 0;\n}\n\nstatic void tegra_xusb_lane_destroy(struct phy *phy)\n{\n\tif (phy) {\n\t\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\t\tlane->pad->ops->remove(lane);\n\t\tphy_destroy(phy);\n\t}\n}\n\nstatic void tegra_xusb_pad_release(struct device *dev)\n{\n\tstruct tegra_xusb_pad *pad = to_tegra_xusb_pad(dev);\n\n\tpad->soc->ops->remove(pad);\n}\n\nstatic const struct device_type tegra_xusb_pad_type = {\n\t.release = tegra_xusb_pad_release,\n};\n\nint tegra_xusb_pad_init(struct tegra_xusb_pad *pad,\n\t\t\tstruct tegra_xusb_padctl *padctl,\n\t\t\tstruct device_node *np)\n{\n\tint err;\n\n\tdevice_initialize(&pad->dev);\n\tINIT_LIST_HEAD(&pad->list);\n\tpad->dev.parent = padctl->dev;\n\tpad->dev.type = &tegra_xusb_pad_type;\n\tpad->dev.of_node = np;\n\tpad->padctl = padctl;\n\n\terr = dev_set_name(&pad->dev, \"%s\", pad->soc->name);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\terr = device_add(&pad->dev);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\treturn 0;\n\nunregister:\n\tdevice_unregister(&pad->dev);\n\treturn err;\n}\n\nint tegra_xusb_pad_register(struct tegra_xusb_pad *pad,\n\t\t\t    const struct phy_ops *ops)\n{\n\tstruct device_node *children;\n\tstruct phy *lane;\n\tunsigned int i;\n\tint err;\n\n\tchildren = of_get_child_by_name(pad->dev.of_node, \"lanes\");\n\tif (!children)\n\t\treturn -ENODEV;\n\n\tpad->lanes = devm_kcalloc(&pad->dev, pad->soc->num_lanes, sizeof(lane),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pad->lanes) {\n\t\tof_node_put(children);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < pad->soc->num_lanes; i++) {\n\t\tstruct device_node *np = tegra_xusb_pad_find_phy_node(pad, i);\n\t\tstruct tegra_xusb_lane *lane;\n\n\t\t/* skip disabled lanes */\n\t\tif (!np || !of_device_is_available(np)) {\n\t\t\tof_node_put(np);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpad->lanes[i] = phy_create(&pad->dev, np, ops);\n\t\tif (IS_ERR(pad->lanes[i])) {\n\t\t\terr = PTR_ERR(pad->lanes[i]);\n\t\t\tof_node_put(np);\n\t\t\tgoto remove;\n\t\t}\n\n\t\tlane = pad->ops->probe(pad, np, i);\n\t\tif (IS_ERR(lane)) {\n\t\t\tphy_destroy(pad->lanes[i]);\n\t\t\terr = PTR_ERR(lane);\n\t\t\tgoto remove;\n\t\t}\n\n\t\tlist_add_tail(&lane->list, &pad->padctl->lanes);\n\t\tphy_set_drvdata(pad->lanes[i], lane);\n\t}\n\n\tpad->provider = of_phy_provider_register_full(&pad->dev, children,\n\t\t\t\t\t\t      tegra_xusb_pad_of_xlate);\n\tif (IS_ERR(pad->provider)) {\n\t\terr = PTR_ERR(pad->provider);\n\t\tgoto remove;\n\t}\n\n\treturn 0;\n\nremove:\n\twhile (i--)\n\t\ttegra_xusb_lane_destroy(pad->lanes[i]);\n\n\tof_node_put(children);\n\n\treturn err;\n}\n\nvoid tegra_xusb_pad_unregister(struct tegra_xusb_pad *pad)\n{\n\tunsigned int i = pad->soc->num_lanes;\n\n\tof_phy_provider_unregister(pad->provider);\n\n\twhile (i--)\n\t\ttegra_xusb_lane_destroy(pad->lanes[i]);\n\n\tdevice_unregister(&pad->dev);\n}\n\nstatic struct tegra_xusb_pad *\ntegra_xusb_pad_create(struct tegra_xusb_padctl *padctl,\n\t\t      const struct tegra_xusb_pad_soc *soc)\n{\n\tstruct tegra_xusb_pad *pad;\n\tstruct device_node *np;\n\tint err;\n\n\tnp = tegra_xusb_find_pad_node(padctl, soc->name);\n\tif (!np || !of_device_is_available(np))\n\t\treturn NULL;\n\n\tpad = soc->ops->probe(padctl, soc, np);\n\tif (IS_ERR(pad)) {\n\t\terr = PTR_ERR(pad);\n\t\tdev_err(padctl->dev, \"failed to create pad %s: %d\\n\",\n\t\t\tsoc->name, err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* XXX move this into ->probe() to avoid string comparison */\n\tif (strcmp(soc->name, \"pcie\") == 0)\n\t\tpadctl->pcie = pad;\n\n\tif (strcmp(soc->name, \"sata\") == 0)\n\t\tpadctl->sata = pad;\n\n\tif (strcmp(soc->name, \"usb2\") == 0)\n\t\tpadctl->usb2 = pad;\n\n\tif (strcmp(soc->name, \"ulpi\") == 0)\n\t\tpadctl->ulpi = pad;\n\n\tif (strcmp(soc->name, \"hsic\") == 0)\n\t\tpadctl->hsic = pad;\n\n\treturn pad;\n}\n\nstatic void __tegra_xusb_remove_pads(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra_xusb_pad *pad, *tmp;\n\n\tlist_for_each_entry_safe_reverse(pad, tmp, &padctl->pads, list) {\n\t\tlist_del(&pad->list);\n\t\ttegra_xusb_pad_unregister(pad);\n\t}\n}\n\nstatic void tegra_xusb_remove_pads(struct tegra_xusb_padctl *padctl)\n{\n\tmutex_lock(&padctl->lock);\n\t__tegra_xusb_remove_pads(padctl);\n\tmutex_unlock(&padctl->lock);\n}\n\nstatic void tegra_xusb_lane_program(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tconst struct tegra_xusb_lane_soc *soc = lane->soc;\n\tu32 value;\n\n\t/* skip single function lanes */\n\tif (soc->num_funcs < 2)\n\t\treturn;\n\n\tif (lane->pad->ops->iddq_enable)\n\t\tlane->pad->ops->iddq_enable(lane);\n\n\t/* choose function */\n\tvalue = padctl_readl(padctl, soc->offset);\n\tvalue &= ~(soc->mask << soc->shift);\n\tvalue |= lane->function << soc->shift;\n\tpadctl_writel(padctl, value, soc->offset);\n\n\tif (lane->pad->ops->iddq_disable)\n\t\tlane->pad->ops->iddq_disable(lane);\n}\n\nstatic void tegra_xusb_pad_program(struct tegra_xusb_pad *pad)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pad->soc->num_lanes; i++) {\n\t\tstruct tegra_xusb_lane *lane;\n\n\t\tif (pad->lanes[i]) {\n\t\t\tlane = phy_get_drvdata(pad->lanes[i]);\n\t\t\ttegra_xusb_lane_program(lane);\n\t\t}\n\t}\n}\n\nstatic int tegra_xusb_setup_pads(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra_xusb_pad *pad;\n\tunsigned int i;\n\n\tmutex_lock(&padctl->lock);\n\n\tfor (i = 0; i < padctl->soc->num_pads; i++) {\n\t\tconst struct tegra_xusb_pad_soc *soc = padctl->soc->pads[i];\n\t\tint err;\n\n\t\tpad = tegra_xusb_pad_create(padctl, soc);\n\t\tif (IS_ERR(pad)) {\n\t\t\terr = PTR_ERR(pad);\n\t\t\tdev_err(padctl->dev, \"failed to create pad %s: %d\\n\",\n\t\t\t\tsoc->name, err);\n\t\t\t__tegra_xusb_remove_pads(padctl);\n\t\t\tmutex_unlock(&padctl->lock);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (!pad)\n\t\t\tcontinue;\n\n\t\tlist_add_tail(&pad->list, &padctl->pads);\n\t}\n\n\tlist_for_each_entry(pad, &padctl->pads, list)\n\t\ttegra_xusb_pad_program(pad);\n\n\tmutex_unlock(&padctl->lock);\n\treturn 0;\n}\n\nbool tegra_xusb_lane_check(struct tegra_xusb_lane *lane,\n\t\t\t\t  const char *function)\n{\n\tconst char *func = lane->soc->funcs[lane->function];\n\n\treturn strcmp(function, func) == 0;\n}\n\nstruct tegra_xusb_lane *tegra_xusb_find_lane(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\t     const char *type,\n\t\t\t\t\t     unsigned int index)\n{\n\tstruct tegra_xusb_lane *lane, *hit = ERR_PTR(-ENODEV);\n\tchar *name;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlist_for_each_entry(lane, &padctl->lanes, list) {\n\t\tif (strcmp(lane->soc->name, name) == 0) {\n\t\t\thit = lane;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(name);\n\treturn hit;\n}\n\nstruct tegra_xusb_lane *\ntegra_xusb_port_find_lane(struct tegra_xusb_port *port,\n\t\t\t  const struct tegra_xusb_lane_map *map,\n\t\t\t  const char *function)\n{\n\tstruct tegra_xusb_lane *lane, *match = ERR_PTR(-ENODEV);\n\n\tfor (; map->type; map++) {\n\t\tif (port->index != map->port)\n\t\t\tcontinue;\n\n\t\tlane = tegra_xusb_find_lane(port->padctl, map->type,\n\t\t\t\t\t    map->index);\n\t\tif (IS_ERR(lane))\n\t\t\tcontinue;\n\n\t\tif (!tegra_xusb_lane_check(lane, function))\n\t\t\tcontinue;\n\n\t\tif (!IS_ERR(match))\n\t\t\tdev_err(&port->dev, \"conflicting match: %s-%u / %s\\n\",\n\t\t\t\tmap->type, map->index, match->soc->name);\n\t\telse\n\t\t\tmatch = lane;\n\t}\n\n\treturn match;\n}\n\nstatic struct device_node *\ntegra_xusb_find_port_node(struct tegra_xusb_padctl *padctl, const char *type,\n\t\t\t  unsigned int index)\n{\n\tstruct device_node *ports, *np;\n\tchar *name;\n\n\tports = of_get_child_by_name(padctl->dev->of_node, \"ports\");\n\tif (!ports)\n\t\treturn NULL;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name) {\n\t\tof_node_put(ports);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnp = of_get_child_by_name(ports, name);\n\tkfree(name);\n\tof_node_put(ports);\n\n\treturn np;\n}\n\nstruct tegra_xusb_port *\ntegra_xusb_find_port(struct tegra_xusb_padctl *padctl, const char *type,\n\t\t     unsigned int index)\n{\n\tstruct tegra_xusb_port *port;\n\tstruct device_node *np;\n\n\tnp = tegra_xusb_find_port_node(padctl, type, index);\n\tif (!np)\n\t\treturn NULL;\n\n\tlist_for_each_entry(port, &padctl->ports, list) {\n\t\tif (np == port->dev.of_node) {\n\t\t\tof_node_put(np);\n\t\t\treturn port;\n\t\t}\n\t}\n\n\tof_node_put(np);\n\n\treturn NULL;\n}\n\nstruct tegra_xusb_usb2_port *\ntegra_xusb_find_usb2_port(struct tegra_xusb_padctl *padctl, unsigned int index)\n{\n\tstruct tegra_xusb_port *port;\n\n\tport = tegra_xusb_find_port(padctl, \"usb2\", index);\n\tif (port)\n\t\treturn to_usb2_port(port);\n\n\treturn NULL;\n}\n\nstruct tegra_xusb_usb3_port *\ntegra_xusb_find_usb3_port(struct tegra_xusb_padctl *padctl, unsigned int index)\n{\n\tstruct tegra_xusb_port *port;\n\n\tport = tegra_xusb_find_port(padctl, \"usb3\", index);\n\tif (port)\n\t\treturn to_usb3_port(port);\n\n\treturn NULL;\n}\n\nstatic void tegra_xusb_port_release(struct device *dev)\n{\n\tstruct tegra_xusb_port *port = to_tegra_xusb_port(dev);\n\n\tif (port->ops->release)\n\t\tport->ops->release(port);\n}\n\nstatic const struct device_type tegra_xusb_port_type = {\n\t.release = tegra_xusb_port_release,\n};\n\nstatic int tegra_xusb_port_init(struct tegra_xusb_port *port,\n\t\t\t\tstruct tegra_xusb_padctl *padctl,\n\t\t\t\tstruct device_node *np,\n\t\t\t\tconst char *name,\n\t\t\t\tunsigned int index)\n{\n\tint err;\n\n\tINIT_LIST_HEAD(&port->list);\n\tport->padctl = padctl;\n\tport->index = index;\n\n\tdevice_initialize(&port->dev);\n\tport->dev.type = &tegra_xusb_port_type;\n\tport->dev.of_node = of_node_get(np);\n\tport->dev.parent = padctl->dev;\n\n\terr = dev_set_name(&port->dev, \"%s-%u\", name, index);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\terr = device_add(&port->dev);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\treturn 0;\n\nunregister:\n\tdevice_unregister(&port->dev);\n\treturn err;\n}\n\nstatic void tegra_xusb_port_unregister(struct tegra_xusb_port *port)\n{\n\tif (!IS_ERR_OR_NULL(port->usb_role_sw)) {\n\t\tof_platform_depopulate(&port->dev);\n\t\tusb_role_switch_unregister(port->usb_role_sw);\n\t\tcancel_work_sync(&port->usb_phy_work);\n\t\tusb_remove_phy(&port->usb_phy);\n\t}\n\n\tif (port->ops->remove)\n\t\tport->ops->remove(port);\n\n\tdevice_unregister(&port->dev);\n}\n\nstatic const char *const modes[] = {\n\t[USB_DR_MODE_UNKNOWN] = \"\",\n\t[USB_DR_MODE_HOST] = \"host\",\n\t[USB_DR_MODE_PERIPHERAL] = \"peripheral\",\n\t[USB_DR_MODE_OTG] = \"otg\",\n};\n\nstatic const char * const usb_roles[] = {\n\t[USB_ROLE_NONE]\t\t= \"none\",\n\t[USB_ROLE_HOST]\t\t= \"host\",\n\t[USB_ROLE_DEVICE]\t= \"device\",\n};\n\nstatic enum usb_phy_events to_usb_phy_event(enum usb_role role)\n{\n\tswitch (role) {\n\tcase USB_ROLE_DEVICE:\n\t\treturn USB_EVENT_VBUS;\n\n\tcase USB_ROLE_HOST:\n\t\treturn USB_EVENT_ID;\n\n\tdefault:\n\t\treturn USB_EVENT_NONE;\n\t}\n}\n\nstatic void tegra_xusb_usb_phy_work(struct work_struct *work)\n{\n\tstruct tegra_xusb_port *port = container_of(work,\n\t\t\t\t\t\t    struct tegra_xusb_port,\n\t\t\t\t\t\t    usb_phy_work);\n\tenum usb_role role = usb_role_switch_get_role(port->usb_role_sw);\n\n\tusb_phy_set_event(&port->usb_phy, to_usb_phy_event(role));\n\n\tdev_dbg(&port->dev, \"%s(): calling notifier for role %s\\n\", __func__,\n\t\tusb_roles[role]);\n\n\tatomic_notifier_call_chain(&port->usb_phy.notifier, 0, &port->usb_phy);\n}\n\nstatic int tegra_xusb_role_sw_set(struct usb_role_switch *sw,\n\t\t\t\t  enum usb_role role)\n{\n\tstruct tegra_xusb_port *port = usb_role_switch_get_drvdata(sw);\n\n\tdev_dbg(&port->dev, \"%s(): role %s\\n\", __func__, usb_roles[role]);\n\n\tschedule_work(&port->usb_phy_work);\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_set_peripheral(struct usb_otg *otg,\n\t\t\t\t     struct usb_gadget *gadget)\n{\n\tstruct tegra_xusb_port *port = container_of(otg->usb_phy,\n\t\t\t\t\t\t    struct tegra_xusb_port,\n\t\t\t\t\t\t    usb_phy);\n\n\tif (gadget != NULL)\n\t\tschedule_work(&port->usb_phy_work);\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_set_host(struct usb_otg *otg, struct usb_bus *host)\n{\n\tstruct tegra_xusb_port *port = container_of(otg->usb_phy,\n\t\t\t\t\t\t    struct tegra_xusb_port,\n\t\t\t\t\t\t    usb_phy);\n\n\tif (host != NULL)\n\t\tschedule_work(&port->usb_phy_work);\n\n\treturn 0;\n}\n\n\nstatic int tegra_xusb_setup_usb_role_switch(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_lane *lane;\n\tstruct usb_role_switch_desc role_sx_desc = {\n\t\t.fwnode = dev_fwnode(&port->dev),\n\t\t.set = tegra_xusb_role_sw_set,\n\t};\n\tint err = 0;\n\n\t/*\n\t * USB role switch driver needs parent driver owner info. This is a\n\t * suboptimal solution. TODO: Need to revisit this in a follow-up patch\n\t * where an optimal solution is possible with changes to USB role\n\t * switch driver.\n\t */\n\tport->dev.driver = devm_kzalloc(&port->dev,\n\t\t\t\t\tsizeof(struct device_driver),\n\t\t\t\t\tGFP_KERNEL);\n\tport->dev.driver->owner\t = THIS_MODULE;\n\n\tport->usb_role_sw = usb_role_switch_register(&port->dev,\n\t\t\t\t\t\t     &role_sx_desc);\n\tif (IS_ERR(port->usb_role_sw)) {\n\t\terr = PTR_ERR(port->usb_role_sw);\n\t\tdev_err(&port->dev, \"failed to register USB role switch: %d\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tINIT_WORK(&port->usb_phy_work, tegra_xusb_usb_phy_work);\n\tusb_role_switch_set_drvdata(port->usb_role_sw, port);\n\n\tport->usb_phy.otg = devm_kzalloc(&port->dev, sizeof(struct usb_otg),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!port->usb_phy.otg)\n\t\treturn -ENOMEM;\n\n\tlane = tegra_xusb_find_lane(port->padctl, \"usb2\", port->index);\n\n\t/*\n\t * Assign phy dev to usb-phy dev. Host/device drivers can use phy\n\t * reference to retrieve usb-phy details.\n\t */\n\tport->usb_phy.dev = &lane->pad->lanes[port->index]->dev;\n\tport->usb_phy.dev->driver = port->dev.driver;\n\tport->usb_phy.otg->usb_phy = &port->usb_phy;\n\tport->usb_phy.otg->set_peripheral = tegra_xusb_set_peripheral;\n\tport->usb_phy.otg->set_host = tegra_xusb_set_host;\n\n\terr = usb_add_phy_dev(&port->usb_phy);\n\tif (err < 0) {\n\t\tdev_err(&port->dev, \"Failed to add USB PHY: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t/* populate connector entry */\n\tof_platform_populate(port->dev.of_node, NULL, NULL, &port->dev);\n\n\treturn err;\n}\n\nstatic int tegra_xusb_usb2_port_parse_dt(struct tegra_xusb_usb2_port *usb2)\n{\n\tstruct tegra_xusb_port *port = &usb2->base;\n\tstruct device_node *np = port->dev.of_node;\n\tconst char *mode;\n\tint err;\n\n\tusb2->internal = of_property_read_bool(np, \"nvidia,internal\");\n\n\tif (!of_property_read_string(np, \"mode\", &mode)) {\n\t\tint err = match_string(modes, ARRAY_SIZE(modes), mode);\n\t\tif (err < 0) {\n\t\t\tdev_err(&port->dev, \"invalid value %s for \\\"mode\\\"\\n\",\n\t\t\t\tmode);\n\t\t\tusb2->mode = USB_DR_MODE_UNKNOWN;\n\t\t} else {\n\t\t\tusb2->mode = err;\n\t\t}\n\t} else {\n\t\tusb2->mode = USB_DR_MODE_HOST;\n\t}\n\n\t/* usb-role-switch property is mandatory for OTG/Peripheral modes */\n\tif (usb2->mode == USB_DR_MODE_PERIPHERAL ||\n\t    usb2->mode == USB_DR_MODE_OTG) {\n\t\tif (of_property_read_bool(np, \"usb-role-switch\")) {\n\t\t\terr = tegra_xusb_setup_usb_role_switch(port);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tdev_err(&port->dev, \"usb-role-switch not found for %s mode\",\n\t\t\t\tmodes[usb2->mode]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tusb2->supply = regulator_get(&port->dev, \"vbus\");\n\treturn PTR_ERR_OR_ZERO(usb2->supply);\n}\n\nstatic int tegra_xusb_add_usb2_port(struct tegra_xusb_padctl *padctl,\n\t\t\t\t    unsigned int index)\n{\n\tstruct tegra_xusb_usb2_port *usb2;\n\tstruct device_node *np;\n\tint err = 0;\n\n\t/*\n\t * USB2 ports don't require additional properties, but if the port is\n\t * marked as disabled there is no reason to register it.\n\t */\n\tnp = tegra_xusb_find_port_node(padctl, \"usb2\", index);\n\tif (!np || !of_device_is_available(np))\n\t\tgoto out;\n\n\tusb2 = kzalloc(sizeof(*usb2), GFP_KERNEL);\n\tif (!usb2) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_port_init(&usb2->base, padctl, np, \"usb2\", index);\n\tif (err < 0)\n\t\tgoto out;\n\n\tusb2->base.ops = padctl->soc->ports.usb2.ops;\n\n\tusb2->base.lane = usb2->base.ops->map(&usb2->base);\n\tif (IS_ERR(usb2->base.lane)) {\n\t\terr = PTR_ERR(usb2->base.lane);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_usb2_port_parse_dt(usb2);\n\tif (err < 0) {\n\t\ttegra_xusb_port_unregister(&usb2->base);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&usb2->base.list, &padctl->ports);\n\nout:\n\tof_node_put(np);\n\treturn err;\n}\n\nvoid tegra_xusb_usb2_port_release(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_usb2_port *usb2 = to_usb2_port(port);\n\n\tkfree(usb2);\n}\n\nvoid tegra_xusb_usb2_port_remove(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_usb2_port *usb2 = to_usb2_port(port);\n\n\tregulator_put(usb2->supply);\n}\n\nstatic int tegra_xusb_ulpi_port_parse_dt(struct tegra_xusb_ulpi_port *ulpi)\n{\n\tstruct tegra_xusb_port *port = &ulpi->base;\n\tstruct device_node *np = port->dev.of_node;\n\n\tulpi->internal = of_property_read_bool(np, \"nvidia,internal\");\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_add_ulpi_port(struct tegra_xusb_padctl *padctl,\n\t\t\t\t    unsigned int index)\n{\n\tstruct tegra_xusb_ulpi_port *ulpi;\n\tstruct device_node *np;\n\tint err = 0;\n\n\tnp = tegra_xusb_find_port_node(padctl, \"ulpi\", index);\n\tif (!np || !of_device_is_available(np))\n\t\tgoto out;\n\n\tulpi = kzalloc(sizeof(*ulpi), GFP_KERNEL);\n\tif (!ulpi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_port_init(&ulpi->base, padctl, np, \"ulpi\", index);\n\tif (err < 0)\n\t\tgoto out;\n\n\tulpi->base.ops = padctl->soc->ports.ulpi.ops;\n\n\tulpi->base.lane = ulpi->base.ops->map(&ulpi->base);\n\tif (IS_ERR(ulpi->base.lane)) {\n\t\terr = PTR_ERR(ulpi->base.lane);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_ulpi_port_parse_dt(ulpi);\n\tif (err < 0) {\n\t\ttegra_xusb_port_unregister(&ulpi->base);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&ulpi->base.list, &padctl->ports);\n\nout:\n\tof_node_put(np);\n\treturn err;\n}\n\nvoid tegra_xusb_ulpi_port_release(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_ulpi_port *ulpi = to_ulpi_port(port);\n\n\tkfree(ulpi);\n}\n\nstatic int tegra_xusb_hsic_port_parse_dt(struct tegra_xusb_hsic_port *hsic)\n{\n\t/* XXX */\n\treturn 0;\n}\n\nstatic int tegra_xusb_add_hsic_port(struct tegra_xusb_padctl *padctl,\n\t\t\t\t    unsigned int index)\n{\n\tstruct tegra_xusb_hsic_port *hsic;\n\tstruct device_node *np;\n\tint err = 0;\n\n\tnp = tegra_xusb_find_port_node(padctl, \"hsic\", index);\n\tif (!np || !of_device_is_available(np))\n\t\tgoto out;\n\n\thsic = kzalloc(sizeof(*hsic), GFP_KERNEL);\n\tif (!hsic) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_port_init(&hsic->base, padctl, np, \"hsic\", index);\n\tif (err < 0)\n\t\tgoto out;\n\n\thsic->base.ops = padctl->soc->ports.hsic.ops;\n\n\thsic->base.lane = hsic->base.ops->map(&hsic->base);\n\tif (IS_ERR(hsic->base.lane)) {\n\t\terr = PTR_ERR(hsic->base.lane);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_hsic_port_parse_dt(hsic);\n\tif (err < 0) {\n\t\ttegra_xusb_port_unregister(&hsic->base);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&hsic->base.list, &padctl->ports);\n\nout:\n\tof_node_put(np);\n\treturn err;\n}\n\nvoid tegra_xusb_hsic_port_release(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_hsic_port *hsic = to_hsic_port(port);\n\n\tkfree(hsic);\n}\n\nstatic int tegra_xusb_usb3_port_parse_dt(struct tegra_xusb_usb3_port *usb3)\n{\n\tstruct tegra_xusb_port *port = &usb3->base;\n\tstruct device_node *np = port->dev.of_node;\n\tenum usb_device_speed maximum_speed;\n\tu32 value;\n\tint err;\n\n\terr = of_property_read_u32(np, \"nvidia,usb2-companion\", &value);\n\tif (err < 0) {\n\t\tdev_err(&port->dev, \"failed to read port: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tusb3->port = value;\n\n\tusb3->internal = of_property_read_bool(np, \"nvidia,internal\");\n\n\tif (device_property_present(&port->dev, \"maximum-speed\")) {\n\t\tmaximum_speed =  usb_get_maximum_speed(&port->dev);\n\t\tif (maximum_speed == USB_SPEED_SUPER)\n\t\t\tusb3->disable_gen2 = true;\n\t\telse if (maximum_speed == USB_SPEED_SUPER_PLUS)\n\t\t\tusb3->disable_gen2 = false;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tusb3->supply = regulator_get(&port->dev, \"vbus\");\n\treturn PTR_ERR_OR_ZERO(usb3->supply);\n}\n\nstatic int tegra_xusb_add_usb3_port(struct tegra_xusb_padctl *padctl,\n\t\t\t\t    unsigned int index)\n{\n\tstruct tegra_xusb_usb3_port *usb3;\n\tstruct device_node *np;\n\tint err = 0;\n\n\t/*\n\t * If there is no supplemental configuration in the device tree the\n\t * port is unusable. But it is valid to configure only a single port,\n\t * hence return 0 instead of an error to allow ports to be optional.\n\t */\n\tnp = tegra_xusb_find_port_node(padctl, \"usb3\", index);\n\tif (!np || !of_device_is_available(np))\n\t\tgoto out;\n\n\tusb3 = kzalloc(sizeof(*usb3), GFP_KERNEL);\n\tif (!usb3) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_port_init(&usb3->base, padctl, np, \"usb3\", index);\n\tif (err < 0)\n\t\tgoto out;\n\n\tusb3->base.ops = padctl->soc->ports.usb3.ops;\n\n\tusb3->base.lane = usb3->base.ops->map(&usb3->base);\n\tif (IS_ERR(usb3->base.lane)) {\n\t\terr = PTR_ERR(usb3->base.lane);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_usb3_port_parse_dt(usb3);\n\tif (err < 0) {\n\t\ttegra_xusb_port_unregister(&usb3->base);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&usb3->base.list, &padctl->ports);\n\nout:\n\tof_node_put(np);\n\treturn err;\n}\n\nvoid tegra_xusb_usb3_port_release(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_usb3_port *usb3 = to_usb3_port(port);\n\n\tkfree(usb3);\n}\n\nvoid tegra_xusb_usb3_port_remove(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_usb3_port *usb3 = to_usb3_port(port);\n\n\tregulator_put(usb3->supply);\n}\n\nstatic void __tegra_xusb_remove_ports(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra_xusb_port *port, *tmp;\n\n\tlist_for_each_entry_safe_reverse(port, tmp, &padctl->ports, list) {\n\t\tlist_del(&port->list);\n\t\ttegra_xusb_port_unregister(port);\n\t}\n}\n\nstatic int tegra_xusb_find_unused_usb3_port(struct tegra_xusb_padctl *padctl)\n{\n\tstruct device_node *np;\n\tunsigned int i;\n\n\tfor (i = 0; i < padctl->soc->ports.usb3.count; i++) {\n\t\tnp = tegra_xusb_find_port_node(padctl, \"usb3\", i);\n\t\tif (!np || !of_device_is_available(np))\n\t\t\treturn i;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic bool tegra_xusb_port_is_companion(struct tegra_xusb_usb2_port *usb2)\n{\n\tunsigned int i;\n\tstruct tegra_xusb_usb3_port *usb3;\n\tstruct tegra_xusb_padctl *padctl = usb2->base.padctl;\n\n\tfor (i = 0; i < padctl->soc->ports.usb3.count; i++) {\n\t\tusb3 = tegra_xusb_find_usb3_port(padctl, i);\n\t\tif (usb3 && usb3->port == usb2->base.index)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int tegra_xusb_update_usb3_fake_port(struct tegra_xusb_usb2_port *usb2)\n{\n\tint fake;\n\n\t/* Disable usb3_port_fake usage by default and assign if needed */\n\tusb2->usb3_port_fake = -1;\n\n\tif ((usb2->mode == USB_DR_MODE_OTG ||\n\t     usb2->mode == USB_DR_MODE_PERIPHERAL) &&\n\t\t!tegra_xusb_port_is_companion(usb2)) {\n\t\tfake = tegra_xusb_find_unused_usb3_port(usb2->base.padctl);\n\t\tif (fake < 0) {\n\t\t\tdev_err(&usb2->base.dev, \"no unused USB3 ports available\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tdev_dbg(&usb2->base.dev, \"Found unused usb3 port: %d\\n\", fake);\n\t\tusb2->usb3_port_fake = fake;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_setup_ports(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra_xusb_port *port;\n\tstruct tegra_xusb_usb2_port *usb2;\n\tunsigned int i;\n\tint err = 0;\n\n\tmutex_lock(&padctl->lock);\n\n\tfor (i = 0; i < padctl->soc->ports.usb2.count; i++) {\n\t\terr = tegra_xusb_add_usb2_port(padctl, i);\n\t\tif (err < 0)\n\t\t\tgoto remove_ports;\n\t}\n\n\tfor (i = 0; i < padctl->soc->ports.ulpi.count; i++) {\n\t\terr = tegra_xusb_add_ulpi_port(padctl, i);\n\t\tif (err < 0)\n\t\t\tgoto remove_ports;\n\t}\n\n\tfor (i = 0; i < padctl->soc->ports.hsic.count; i++) {\n\t\terr = tegra_xusb_add_hsic_port(padctl, i);\n\t\tif (err < 0)\n\t\t\tgoto remove_ports;\n\t}\n\n\tfor (i = 0; i < padctl->soc->ports.usb3.count; i++) {\n\t\terr = tegra_xusb_add_usb3_port(padctl, i);\n\t\tif (err < 0)\n\t\t\tgoto remove_ports;\n\t}\n\n\tif (padctl->soc->need_fake_usb3_port) {\n\t\tfor (i = 0; i < padctl->soc->ports.usb2.count; i++) {\n\t\t\tusb2 = tegra_xusb_find_usb2_port(padctl, i);\n\t\t\tif (!usb2)\n\t\t\t\tcontinue;\n\n\t\t\terr = tegra_xusb_update_usb3_fake_port(usb2);\n\t\t\tif (err < 0)\n\t\t\t\tgoto remove_ports;\n\t\t}\n\t}\n\n\tlist_for_each_entry(port, &padctl->ports, list) {\n\t\terr = port->ops->enable(port);\n\t\tif (err < 0)\n\t\t\tdev_err(padctl->dev, \"failed to enable port %s: %d\\n\",\n\t\t\t\tdev_name(&port->dev), err);\n\t}\n\n\tgoto unlock;\n\nremove_ports:\n\t__tegra_xusb_remove_ports(padctl);\nunlock:\n\tmutex_unlock(&padctl->lock);\n\treturn err;\n}\n\nstatic void tegra_xusb_remove_ports(struct tegra_xusb_padctl *padctl)\n{\n\tmutex_lock(&padctl->lock);\n\t__tegra_xusb_remove_ports(padctl);\n\tmutex_unlock(&padctl->lock);\n}\n\nstatic int tegra_xusb_padctl_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct tegra_xusb_padctl_soc *soc;\n\tstruct tegra_xusb_padctl *padctl;\n\tconst struct of_device_id *match;\n\tint err;\n\n\t/* for backwards compatibility with old device trees */\n\tnp = of_get_child_by_name(np, \"pads\");\n\tif (!np) {\n\t\tdev_warn(&pdev->dev, \"deprecated DT, using legacy driver\\n\");\n\t\treturn tegra_xusb_padctl_legacy_probe(pdev);\n\t}\n\n\tof_node_put(np);\n\n\tmatch = of_match_node(tegra_xusb_padctl_of_match, pdev->dev.of_node);\n\tsoc = match->data;\n\n\tpadctl = soc->ops->probe(&pdev->dev, soc);\n\tif (IS_ERR(padctl))\n\t\treturn PTR_ERR(padctl);\n\n\tplatform_set_drvdata(pdev, padctl);\n\tINIT_LIST_HEAD(&padctl->ports);\n\tINIT_LIST_HEAD(&padctl->lanes);\n\tINIT_LIST_HEAD(&padctl->pads);\n\tmutex_init(&padctl->lock);\n\n\tpadctl->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(padctl->regs)) {\n\t\terr = PTR_ERR(padctl->regs);\n\t\tgoto remove;\n\t}\n\n\tpadctl->rst = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(padctl->rst)) {\n\t\terr = PTR_ERR(padctl->rst);\n\t\tgoto remove;\n\t}\n\n\tpadctl->supplies = devm_kcalloc(&pdev->dev, padctl->soc->num_supplies,\n\t\t\t\t\tsizeof(*padctl->supplies), GFP_KERNEL);\n\tif (!padctl->supplies) {\n\t\terr = -ENOMEM;\n\t\tgoto remove;\n\t}\n\n\tregulator_bulk_set_supply_names(padctl->supplies,\n\t\t\t\t\tpadctl->soc->supply_names,\n\t\t\t\t\tpadctl->soc->num_supplies);\n\n\terr = devm_regulator_bulk_get(&pdev->dev, padctl->soc->num_supplies,\n\t\t\t\t      padctl->supplies);\n\tif (err < 0) {\n\t\tdev_err_probe(&pdev->dev, err, \"failed to get regulators\\n\");\n\t\tgoto remove;\n\t}\n\n\terr = reset_control_deassert(padctl->rst);\n\tif (err < 0)\n\t\tgoto remove;\n\n\terr = regulator_bulk_enable(padctl->soc->num_supplies,\n\t\t\t\t    padctl->supplies);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable supplies: %d\\n\", err);\n\t\tgoto reset;\n\t}\n\n\terr = tegra_xusb_setup_pads(padctl);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to setup pads: %d\\n\", err);\n\t\tgoto power_down;\n\t}\n\n\terr = tegra_xusb_setup_ports(padctl);\n\tif (err) {\n\t\tconst char *level = KERN_ERR;\n\n\t\tif (err == -EPROBE_DEFER)\n\t\t\tlevel = KERN_DEBUG;\n\n\t\tdev_printk(level, &pdev->dev,\n\t\t\t   dev_fmt(\"failed to setup XUSB ports: %d\\n\"), err);\n\t\tgoto remove_pads;\n\t}\n\n\treturn 0;\n\nremove_pads:\n\ttegra_xusb_remove_pads(padctl);\npower_down:\n\tregulator_bulk_disable(padctl->soc->num_supplies, padctl->supplies);\nreset:\n\treset_control_assert(padctl->rst);\nremove:\n\tplatform_set_drvdata(pdev, NULL);\n\tsoc->ops->remove(padctl);\n\treturn err;\n}\n\nstatic int tegra_xusb_padctl_remove(struct platform_device *pdev)\n{\n\tstruct tegra_xusb_padctl *padctl = platform_get_drvdata(pdev);\n\tint err;\n\n\ttegra_xusb_remove_ports(padctl);\n\ttegra_xusb_remove_pads(padctl);\n\n\terr = regulator_bulk_disable(padctl->soc->num_supplies,\n\t\t\t\t     padctl->supplies);\n\tif (err < 0)\n\t\tdev_err(&pdev->dev, \"failed to disable supplies: %d\\n\", err);\n\n\terr = reset_control_assert(padctl->rst);\n\tif (err < 0)\n\t\tdev_err(&pdev->dev, \"failed to assert reset: %d\\n\", err);\n\n\tpadctl->soc->ops->remove(padctl);\n\n\treturn err;\n}\n\nstatic __maybe_unused int tegra_xusb_padctl_suspend_noirq(struct device *dev)\n{\n\tstruct tegra_xusb_padctl *padctl = dev_get_drvdata(dev);\n\n\tif (padctl->soc && padctl->soc->ops && padctl->soc->ops->suspend_noirq)\n\t\treturn padctl->soc->ops->suspend_noirq(padctl);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int tegra_xusb_padctl_resume_noirq(struct device *dev)\n{\n\tstruct tegra_xusb_padctl *padctl = dev_get_drvdata(dev);\n\n\tif (padctl->soc && padctl->soc->ops && padctl->soc->ops->resume_noirq)\n\t\treturn padctl->soc->ops->resume_noirq(padctl);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_xusb_padctl_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(tegra_xusb_padctl_suspend_noirq,\n\t\t\t\t      tegra_xusb_padctl_resume_noirq)\n};\n\nstatic struct platform_driver tegra_xusb_padctl_driver = {\n\t.driver = {\n\t\t.name = \"tegra-xusb-padctl\",\n\t\t.of_match_table = tegra_xusb_padctl_of_match,\n\t\t.pm = &tegra_xusb_padctl_pm_ops,\n\t},\n\t.probe = tegra_xusb_padctl_probe,\n\t.remove = tegra_xusb_padctl_remove,\n};\nmodule_platform_driver(tegra_xusb_padctl_driver);\n\nstruct tegra_xusb_padctl *tegra_xusb_padctl_get(struct device *dev)\n{\n\tstruct tegra_xusb_padctl *padctl;\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\n\tnp = of_parse_phandle(dev->of_node, \"nvidia,xusb-padctl\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * This is slightly ugly. A better implementation would be to keep a\n\t * registry of pad controllers, but since there will almost certainly\n\t * only ever be one per SoC that would be a little overkill.\n\t */\n\tpdev = of_find_device_by_node(np);\n\tif (!pdev) {\n\t\tof_node_put(np);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tof_node_put(np);\n\n\tpadctl = platform_get_drvdata(pdev);\n\tif (!padctl) {\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\treturn padctl;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_get);\n\nvoid tegra_xusb_padctl_put(struct tegra_xusb_padctl *padctl)\n{\n\tif (padctl)\n\t\tput_device(padctl->dev);\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_put);\n\nint tegra_xusb_padctl_usb3_save_context(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\tunsigned int port)\n{\n\tif (padctl->soc->ops->usb3_save_context)\n\t\treturn padctl->soc->ops->usb3_save_context(padctl, port);\n\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_usb3_save_context);\n\nint tegra_xusb_padctl_hsic_set_idle(struct tegra_xusb_padctl *padctl,\n\t\t\t\t    unsigned int port, bool idle)\n{\n\tif (padctl->soc->ops->hsic_set_idle)\n\t\treturn padctl->soc->ops->hsic_set_idle(padctl, port, idle);\n\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_hsic_set_idle);\n\nint tegra_xusb_padctl_enable_phy_sleepwalk(struct tegra_xusb_padctl *padctl, struct phy *phy,\n\t\t\t\t\t   enum usb_device_speed speed)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\tif (lane->pad->ops->enable_phy_sleepwalk)\n\t\treturn lane->pad->ops->enable_phy_sleepwalk(lane, speed);\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_enable_phy_sleepwalk);\n\nint tegra_xusb_padctl_disable_phy_sleepwalk(struct tegra_xusb_padctl *padctl, struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\tif (lane->pad->ops->disable_phy_sleepwalk)\n\t\treturn lane->pad->ops->disable_phy_sleepwalk(lane);\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_disable_phy_sleepwalk);\n\nint tegra_xusb_padctl_enable_phy_wake(struct tegra_xusb_padctl *padctl, struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\tif (lane->pad->ops->enable_phy_wake)\n\t\treturn lane->pad->ops->enable_phy_wake(lane);\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_enable_phy_wake);\n\nint tegra_xusb_padctl_disable_phy_wake(struct tegra_xusb_padctl *padctl, struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\tif (lane->pad->ops->disable_phy_wake)\n\t\treturn lane->pad->ops->disable_phy_wake(lane);\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_disable_phy_wake);\n\nbool tegra_xusb_padctl_remote_wake_detected(struct tegra_xusb_padctl *padctl, struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\tif (lane->pad->ops->remote_wake_detected)\n\t\treturn lane->pad->ops->remote_wake_detected(lane);\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_remote_wake_detected);\n\nint tegra_xusb_padctl_usb3_set_lfps_detect(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\t   unsigned int port, bool enable)\n{\n\tif (padctl->soc->ops->usb3_set_lfps_detect)\n\t\treturn padctl->soc->ops->usb3_set_lfps_detect(padctl, port,\n\t\t\t\t\t\t\t      enable);\n\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_usb3_set_lfps_detect);\n\nint tegra_xusb_padctl_set_vbus_override(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\t\t\tbool val)\n{\n\tif (padctl->soc->ops->vbus_override)\n\t\treturn padctl->soc->ops->vbus_override(padctl, val);\n\n\treturn -ENOTSUPP;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_set_vbus_override);\n\nint tegra_phy_xusb_utmi_port_reset(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\n\tif (padctl->soc->ops->utmi_port_reset)\n\t\treturn padctl->soc->ops->utmi_port_reset(phy);\n\n\treturn -ENOTSUPP;\n}\nEXPORT_SYMBOL_GPL(tegra_phy_xusb_utmi_port_reset);\n\nint tegra_xusb_padctl_get_usb3_companion(struct tegra_xusb_padctl *padctl,\n\t\t\t\t    unsigned int port)\n{\n\tstruct tegra_xusb_usb2_port *usb2;\n\tstruct tegra_xusb_usb3_port *usb3;\n\tint i;\n\n\tusb2 = tegra_xusb_find_usb2_port(padctl, port);\n\tif (!usb2)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < padctl->soc->ports.usb3.count; i++) {\n\t\tusb3 = tegra_xusb_find_usb3_port(padctl, i);\n\t\tif (usb3 && usb3->port == usb2->base.index)\n\t\t\treturn usb3->base.index;\n\t}\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_get_usb3_companion);\n\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra XUSB Pad Controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2014-2020, NVIDIA CORPORATION.  All rights reserved.\n */\n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/phy/phy.h>\n#include <linux/phy/tegra/xusb.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include <soc/tegra/fuse.h>\n\n#include \"xusb.h\"\n\nstatic struct phy *tegra_xusb_pad_of_xlate(struct device *dev,\n\t\t\t\t\t   struct of_phandle_args *args)\n{\n\tstruct tegra_xusb_pad *pad = dev_get_drvdata(dev);\n\tstruct phy *phy = NULL;\n\tunsigned int i;\n\n\tif (args->args_count != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < pad->soc->num_lanes; i++) {\n\t\tif (!pad->lanes[i])\n\t\t\tcontinue;\n\n\t\tif (pad->lanes[i]->dev.of_node == args->np) {\n\t\t\tphy = pad->lanes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (phy == NULL)\n\t\tphy = ERR_PTR(-ENODEV);\n\n\treturn phy;\n}\n\nstatic const struct of_device_id tegra_xusb_padctl_of_match[] = {\n#if defined(CONFIG_ARCH_TEGRA_124_SOC) || defined(CONFIG_ARCH_TEGRA_132_SOC)\n\t{\n\t\t.compatible = \"nvidia,tegra124-xusb-padctl\",\n\t\t.data = &tegra124_xusb_padctl_soc,\n\t},\n#endif\n#if defined(CONFIG_ARCH_TEGRA_210_SOC)\n\t{\n\t\t.compatible = \"nvidia,tegra210-xusb-padctl\",\n\t\t.data = &tegra210_xusb_padctl_soc,\n\t},\n#endif\n#if defined(CONFIG_ARCH_TEGRA_186_SOC)\n\t{\n\t\t.compatible = \"nvidia,tegra186-xusb-padctl\",\n\t\t.data = &tegra186_xusb_padctl_soc,\n\t},\n#endif\n#if defined(CONFIG_ARCH_TEGRA_194_SOC)\n\t{\n\t\t.compatible = \"nvidia,tegra194-xusb-padctl\",\n\t\t.data = &tegra194_xusb_padctl_soc,\n\t},\n#endif\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_xusb_padctl_of_match);\n\nstatic struct device_node *\ntegra_xusb_find_pad_node(struct tegra_xusb_padctl *padctl, const char *name)\n{\n\tstruct device_node *pads, *np;\n\n\tpads = of_get_child_by_name(padctl->dev->of_node, \"pads\");\n\tif (!pads)\n\t\treturn NULL;\n\n\tnp = of_get_child_by_name(pads, name);\n\tof_node_put(pads);\n\n\treturn np;\n}\n\nstatic struct device_node *\ntegra_xusb_pad_find_phy_node(struct tegra_xusb_pad *pad, unsigned int index)\n{\n\tstruct device_node *np, *lanes;\n\n\tlanes = of_get_child_by_name(pad->dev.of_node, \"lanes\");\n\tif (!lanes)\n\t\treturn NULL;\n\n\tnp = of_get_child_by_name(lanes, pad->soc->lanes[index].name);\n\tof_node_put(lanes);\n\n\treturn np;\n}\n\nint tegra_xusb_lane_parse_dt(struct tegra_xusb_lane *lane,\n\t\t\t     struct device_node *np)\n{\n\tstruct device *dev = &lane->pad->dev;\n\tconst char *function;\n\tint err;\n\n\terr = of_property_read_string(np, \"nvidia,function\", &function);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = match_string(lane->soc->funcs, lane->soc->num_funcs, function);\n\tif (err < 0) {\n\t\tdev_err(dev, \"invalid function \\\"%s\\\" for lane \\\"%pOFn\\\"\\n\",\n\t\t\tfunction, np);\n\t\treturn err;\n\t}\n\n\tlane->function = err;\n\n\treturn 0;\n}\n\nstatic void tegra_xusb_lane_destroy(struct phy *phy)\n{\n\tif (phy) {\n\t\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\t\tlane->pad->ops->remove(lane);\n\t\tphy_destroy(phy);\n\t}\n}\n\nstatic void tegra_xusb_pad_release(struct device *dev)\n{\n\tstruct tegra_xusb_pad *pad = to_tegra_xusb_pad(dev);\n\n\tpad->soc->ops->remove(pad);\n}\n\nstatic const struct device_type tegra_xusb_pad_type = {\n\t.release = tegra_xusb_pad_release,\n};\n\nint tegra_xusb_pad_init(struct tegra_xusb_pad *pad,\n\t\t\tstruct tegra_xusb_padctl *padctl,\n\t\t\tstruct device_node *np)\n{\n\tint err;\n\n\tdevice_initialize(&pad->dev);\n\tINIT_LIST_HEAD(&pad->list);\n\tpad->dev.parent = padctl->dev;\n\tpad->dev.type = &tegra_xusb_pad_type;\n\tpad->dev.of_node = np;\n\tpad->padctl = padctl;\n\n\terr = dev_set_name(&pad->dev, \"%s\", pad->soc->name);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\terr = device_add(&pad->dev);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\treturn 0;\n\nunregister:\n\tdevice_unregister(&pad->dev);\n\treturn err;\n}\n\nint tegra_xusb_pad_register(struct tegra_xusb_pad *pad,\n\t\t\t    const struct phy_ops *ops)\n{\n\tstruct device_node *children;\n\tstruct phy *lane;\n\tunsigned int i;\n\tint err;\n\n\tchildren = of_get_child_by_name(pad->dev.of_node, \"lanes\");\n\tif (!children)\n\t\treturn -ENODEV;\n\n\tpad->lanes = devm_kcalloc(&pad->dev, pad->soc->num_lanes, sizeof(lane),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pad->lanes) {\n\t\tof_node_put(children);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < pad->soc->num_lanes; i++) {\n\t\tstruct device_node *np = tegra_xusb_pad_find_phy_node(pad, i);\n\t\tstruct tegra_xusb_lane *lane;\n\n\t\t/* skip disabled lanes */\n\t\tif (!np || !of_device_is_available(np)) {\n\t\t\tof_node_put(np);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpad->lanes[i] = phy_create(&pad->dev, np, ops);\n\t\tif (IS_ERR(pad->lanes[i])) {\n\t\t\terr = PTR_ERR(pad->lanes[i]);\n\t\t\tof_node_put(np);\n\t\t\tgoto remove;\n\t\t}\n\n\t\tlane = pad->ops->probe(pad, np, i);\n\t\tif (IS_ERR(lane)) {\n\t\t\tphy_destroy(pad->lanes[i]);\n\t\t\terr = PTR_ERR(lane);\n\t\t\tgoto remove;\n\t\t}\n\n\t\tlist_add_tail(&lane->list, &pad->padctl->lanes);\n\t\tphy_set_drvdata(pad->lanes[i], lane);\n\t}\n\n\tpad->provider = of_phy_provider_register_full(&pad->dev, children,\n\t\t\t\t\t\t      tegra_xusb_pad_of_xlate);\n\tif (IS_ERR(pad->provider)) {\n\t\terr = PTR_ERR(pad->provider);\n\t\tgoto remove;\n\t}\n\n\treturn 0;\n\nremove:\n\twhile (i--)\n\t\ttegra_xusb_lane_destroy(pad->lanes[i]);\n\n\tof_node_put(children);\n\n\treturn err;\n}\n\nvoid tegra_xusb_pad_unregister(struct tegra_xusb_pad *pad)\n{\n\tunsigned int i = pad->soc->num_lanes;\n\n\tof_phy_provider_unregister(pad->provider);\n\n\twhile (i--)\n\t\ttegra_xusb_lane_destroy(pad->lanes[i]);\n\n\tdevice_unregister(&pad->dev);\n}\n\nstatic struct tegra_xusb_pad *\ntegra_xusb_pad_create(struct tegra_xusb_padctl *padctl,\n\t\t      const struct tegra_xusb_pad_soc *soc)\n{\n\tstruct tegra_xusb_pad *pad;\n\tstruct device_node *np;\n\tint err;\n\n\tnp = tegra_xusb_find_pad_node(padctl, soc->name);\n\tif (!np || !of_device_is_available(np))\n\t\treturn NULL;\n\n\tpad = soc->ops->probe(padctl, soc, np);\n\tif (IS_ERR(pad)) {\n\t\terr = PTR_ERR(pad);\n\t\tdev_err(padctl->dev, \"failed to create pad %s: %d\\n\",\n\t\t\tsoc->name, err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* XXX move this into ->probe() to avoid string comparison */\n\tif (strcmp(soc->name, \"pcie\") == 0)\n\t\tpadctl->pcie = pad;\n\n\tif (strcmp(soc->name, \"sata\") == 0)\n\t\tpadctl->sata = pad;\n\n\tif (strcmp(soc->name, \"usb2\") == 0)\n\t\tpadctl->usb2 = pad;\n\n\tif (strcmp(soc->name, \"ulpi\") == 0)\n\t\tpadctl->ulpi = pad;\n\n\tif (strcmp(soc->name, \"hsic\") == 0)\n\t\tpadctl->hsic = pad;\n\n\treturn pad;\n}\n\nstatic void __tegra_xusb_remove_pads(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra_xusb_pad *pad, *tmp;\n\n\tlist_for_each_entry_safe_reverse(pad, tmp, &padctl->pads, list) {\n\t\tlist_del(&pad->list);\n\t\ttegra_xusb_pad_unregister(pad);\n\t}\n}\n\nstatic void tegra_xusb_remove_pads(struct tegra_xusb_padctl *padctl)\n{\n\tmutex_lock(&padctl->lock);\n\t__tegra_xusb_remove_pads(padctl);\n\tmutex_unlock(&padctl->lock);\n}\n\nstatic void tegra_xusb_lane_program(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tconst struct tegra_xusb_lane_soc *soc = lane->soc;\n\tu32 value;\n\n\t/* skip single function lanes */\n\tif (soc->num_funcs < 2)\n\t\treturn;\n\n\tif (lane->pad->ops->iddq_enable)\n\t\tlane->pad->ops->iddq_enable(lane);\n\n\t/* choose function */\n\tvalue = padctl_readl(padctl, soc->offset);\n\tvalue &= ~(soc->mask << soc->shift);\n\tvalue |= lane->function << soc->shift;\n\tpadctl_writel(padctl, value, soc->offset);\n\n\tif (lane->pad->ops->iddq_disable)\n\t\tlane->pad->ops->iddq_disable(lane);\n}\n\nstatic void tegra_xusb_pad_program(struct tegra_xusb_pad *pad)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pad->soc->num_lanes; i++) {\n\t\tstruct tegra_xusb_lane *lane;\n\n\t\tif (pad->lanes[i]) {\n\t\t\tlane = phy_get_drvdata(pad->lanes[i]);\n\t\t\ttegra_xusb_lane_program(lane);\n\t\t}\n\t}\n}\n\nstatic int tegra_xusb_setup_pads(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra_xusb_pad *pad;\n\tunsigned int i;\n\n\tmutex_lock(&padctl->lock);\n\n\tfor (i = 0; i < padctl->soc->num_pads; i++) {\n\t\tconst struct tegra_xusb_pad_soc *soc = padctl->soc->pads[i];\n\t\tint err;\n\n\t\tpad = tegra_xusb_pad_create(padctl, soc);\n\t\tif (IS_ERR(pad)) {\n\t\t\terr = PTR_ERR(pad);\n\t\t\tdev_err(padctl->dev, \"failed to create pad %s: %d\\n\",\n\t\t\t\tsoc->name, err);\n\t\t\t__tegra_xusb_remove_pads(padctl);\n\t\t\tmutex_unlock(&padctl->lock);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (!pad)\n\t\t\tcontinue;\n\n\t\tlist_add_tail(&pad->list, &padctl->pads);\n\t}\n\n\tlist_for_each_entry(pad, &padctl->pads, list)\n\t\ttegra_xusb_pad_program(pad);\n\n\tmutex_unlock(&padctl->lock);\n\treturn 0;\n}\n\nbool tegra_xusb_lane_check(struct tegra_xusb_lane *lane,\n\t\t\t\t  const char *function)\n{\n\tconst char *func = lane->soc->funcs[lane->function];\n\n\treturn strcmp(function, func) == 0;\n}\n\nstruct tegra_xusb_lane *tegra_xusb_find_lane(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\t     const char *type,\n\t\t\t\t\t     unsigned int index)\n{\n\tstruct tegra_xusb_lane *lane, *hit = ERR_PTR(-ENODEV);\n\tchar *name;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlist_for_each_entry(lane, &padctl->lanes, list) {\n\t\tif (strcmp(lane->soc->name, name) == 0) {\n\t\t\thit = lane;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(name);\n\treturn hit;\n}\n\nstruct tegra_xusb_lane *\ntegra_xusb_port_find_lane(struct tegra_xusb_port *port,\n\t\t\t  const struct tegra_xusb_lane_map *map,\n\t\t\t  const char *function)\n{\n\tstruct tegra_xusb_lane *lane, *match = ERR_PTR(-ENODEV);\n\n\tfor (; map->type; map++) {\n\t\tif (port->index != map->port)\n\t\t\tcontinue;\n\n\t\tlane = tegra_xusb_find_lane(port->padctl, map->type,\n\t\t\t\t\t    map->index);\n\t\tif (IS_ERR(lane))\n\t\t\tcontinue;\n\n\t\tif (!tegra_xusb_lane_check(lane, function))\n\t\t\tcontinue;\n\n\t\tif (!IS_ERR(match))\n\t\t\tdev_err(&port->dev, \"conflicting match: %s-%u / %s\\n\",\n\t\t\t\tmap->type, map->index, match->soc->name);\n\t\telse\n\t\t\tmatch = lane;\n\t}\n\n\treturn match;\n}\n\nstatic struct device_node *\ntegra_xusb_find_port_node(struct tegra_xusb_padctl *padctl, const char *type,\n\t\t\t  unsigned int index)\n{\n\tstruct device_node *ports, *np;\n\tchar *name;\n\n\tports = of_get_child_by_name(padctl->dev->of_node, \"ports\");\n\tif (!ports)\n\t\treturn NULL;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name) {\n\t\tof_node_put(ports);\n\t\treturn NULL;\n\t}\n\tnp = of_get_child_by_name(ports, name);\n\tkfree(name);\n\tof_node_put(ports);\n\n\treturn np;\n}\n\nstruct tegra_xusb_port *\ntegra_xusb_find_port(struct tegra_xusb_padctl *padctl, const char *type,\n\t\t     unsigned int index)\n{\n\tstruct tegra_xusb_port *port;\n\tstruct device_node *np;\n\n\tnp = tegra_xusb_find_port_node(padctl, type, index);\n\tif (!np)\n\t\treturn NULL;\n\n\tlist_for_each_entry(port, &padctl->ports, list) {\n\t\tif (np == port->dev.of_node) {\n\t\t\tof_node_put(np);\n\t\t\treturn port;\n\t\t}\n\t}\n\n\tof_node_put(np);\n\n\treturn NULL;\n}\n\nstruct tegra_xusb_usb2_port *\ntegra_xusb_find_usb2_port(struct tegra_xusb_padctl *padctl, unsigned int index)\n{\n\tstruct tegra_xusb_port *port;\n\n\tport = tegra_xusb_find_port(padctl, \"usb2\", index);\n\tif (port)\n\t\treturn to_usb2_port(port);\n\n\treturn NULL;\n}\n\nstruct tegra_xusb_usb3_port *\ntegra_xusb_find_usb3_port(struct tegra_xusb_padctl *padctl, unsigned int index)\n{\n\tstruct tegra_xusb_port *port;\n\n\tport = tegra_xusb_find_port(padctl, \"usb3\", index);\n\tif (port)\n\t\treturn to_usb3_port(port);\n\n\treturn NULL;\n}\n\nstatic void tegra_xusb_port_release(struct device *dev)\n{\n\tstruct tegra_xusb_port *port = to_tegra_xusb_port(dev);\n\n\tif (port->ops->release)\n\t\tport->ops->release(port);\n}\n\nstatic const struct device_type tegra_xusb_port_type = {\n\t.release = tegra_xusb_port_release,\n};\n\nstatic int tegra_xusb_port_init(struct tegra_xusb_port *port,\n\t\t\t\tstruct tegra_xusb_padctl *padctl,\n\t\t\t\tstruct device_node *np,\n\t\t\t\tconst char *name,\n\t\t\t\tunsigned int index)\n{\n\tint err;\n\n\tINIT_LIST_HEAD(&port->list);\n\tport->padctl = padctl;\n\tport->index = index;\n\n\tdevice_initialize(&port->dev);\n\tport->dev.type = &tegra_xusb_port_type;\n\tport->dev.of_node = of_node_get(np);\n\tport->dev.parent = padctl->dev;\n\n\terr = dev_set_name(&port->dev, \"%s-%u\", name, index);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\terr = device_add(&port->dev);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\treturn 0;\n\nunregister:\n\tdevice_unregister(&port->dev);\n\treturn err;\n}\n\nstatic void tegra_xusb_port_unregister(struct tegra_xusb_port *port)\n{\n\tif (!IS_ERR_OR_NULL(port->usb_role_sw)) {\n\t\tof_platform_depopulate(&port->dev);\n\t\tusb_role_switch_unregister(port->usb_role_sw);\n\t\tcancel_work_sync(&port->usb_phy_work);\n\t\tusb_remove_phy(&port->usb_phy);\n\t}\n\n\tif (port->ops->remove)\n\t\tport->ops->remove(port);\n\n\tdevice_unregister(&port->dev);\n}\n\nstatic const char *const modes[] = {\n\t[USB_DR_MODE_UNKNOWN] = \"\",\n\t[USB_DR_MODE_HOST] = \"host\",\n\t[USB_DR_MODE_PERIPHERAL] = \"peripheral\",\n\t[USB_DR_MODE_OTG] = \"otg\",\n};\n\nstatic const char * const usb_roles[] = {\n\t[USB_ROLE_NONE]\t\t= \"none\",\n\t[USB_ROLE_HOST]\t\t= \"host\",\n\t[USB_ROLE_DEVICE]\t= \"device\",\n};\n\nstatic enum usb_phy_events to_usb_phy_event(enum usb_role role)\n{\n\tswitch (role) {\n\tcase USB_ROLE_DEVICE:\n\t\treturn USB_EVENT_VBUS;\n\n\tcase USB_ROLE_HOST:\n\t\treturn USB_EVENT_ID;\n\n\tdefault:\n\t\treturn USB_EVENT_NONE;\n\t}\n}\n\nstatic void tegra_xusb_usb_phy_work(struct work_struct *work)\n{\n\tstruct tegra_xusb_port *port = container_of(work,\n\t\t\t\t\t\t    struct tegra_xusb_port,\n\t\t\t\t\t\t    usb_phy_work);\n\tenum usb_role role = usb_role_switch_get_role(port->usb_role_sw);\n\n\tusb_phy_set_event(&port->usb_phy, to_usb_phy_event(role));\n\n\tdev_dbg(&port->dev, \"%s(): calling notifier for role %s\\n\", __func__,\n\t\tusb_roles[role]);\n\n\tatomic_notifier_call_chain(&port->usb_phy.notifier, 0, &port->usb_phy);\n}\n\nstatic int tegra_xusb_role_sw_set(struct usb_role_switch *sw,\n\t\t\t\t  enum usb_role role)\n{\n\tstruct tegra_xusb_port *port = usb_role_switch_get_drvdata(sw);\n\n\tdev_dbg(&port->dev, \"%s(): role %s\\n\", __func__, usb_roles[role]);\n\n\tschedule_work(&port->usb_phy_work);\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_set_peripheral(struct usb_otg *otg,\n\t\t\t\t     struct usb_gadget *gadget)\n{\n\tstruct tegra_xusb_port *port = container_of(otg->usb_phy,\n\t\t\t\t\t\t    struct tegra_xusb_port,\n\t\t\t\t\t\t    usb_phy);\n\n\tif (gadget != NULL)\n\t\tschedule_work(&port->usb_phy_work);\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_set_host(struct usb_otg *otg, struct usb_bus *host)\n{\n\tstruct tegra_xusb_port *port = container_of(otg->usb_phy,\n\t\t\t\t\t\t    struct tegra_xusb_port,\n\t\t\t\t\t\t    usb_phy);\n\n\tif (host != NULL)\n\t\tschedule_work(&port->usb_phy_work);\n\n\treturn 0;\n}\n\n\nstatic int tegra_xusb_setup_usb_role_switch(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_lane *lane;\n\tstruct usb_role_switch_desc role_sx_desc = {\n\t\t.fwnode = dev_fwnode(&port->dev),\n\t\t.set = tegra_xusb_role_sw_set,\n\t};\n\tint err = 0;\n\n\t/*\n\t * USB role switch driver needs parent driver owner info. This is a\n\t * suboptimal solution. TODO: Need to revisit this in a follow-up patch\n\t * where an optimal solution is possible with changes to USB role\n\t * switch driver.\n\t */\n\tport->dev.driver = devm_kzalloc(&port->dev,\n\t\t\t\t\tsizeof(struct device_driver),\n\t\t\t\t\tGFP_KERNEL);\n\tport->dev.driver->owner\t = THIS_MODULE;\n\n\tport->usb_role_sw = usb_role_switch_register(&port->dev,\n\t\t\t\t\t\t     &role_sx_desc);\n\tif (IS_ERR(port->usb_role_sw)) {\n\t\terr = PTR_ERR(port->usb_role_sw);\n\t\tdev_err(&port->dev, \"failed to register USB role switch: %d\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tINIT_WORK(&port->usb_phy_work, tegra_xusb_usb_phy_work);\n\tusb_role_switch_set_drvdata(port->usb_role_sw, port);\n\n\tport->usb_phy.otg = devm_kzalloc(&port->dev, sizeof(struct usb_otg),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!port->usb_phy.otg)\n\t\treturn -ENOMEM;\n\n\tlane = tegra_xusb_find_lane(port->padctl, \"usb2\", port->index);\n\n\t/*\n\t * Assign phy dev to usb-phy dev. Host/device drivers can use phy\n\t * reference to retrieve usb-phy details.\n\t */\n\tport->usb_phy.dev = &lane->pad->lanes[port->index]->dev;\n\tport->usb_phy.dev->driver = port->dev.driver;\n\tport->usb_phy.otg->usb_phy = &port->usb_phy;\n\tport->usb_phy.otg->set_peripheral = tegra_xusb_set_peripheral;\n\tport->usb_phy.otg->set_host = tegra_xusb_set_host;\n\n\terr = usb_add_phy_dev(&port->usb_phy);\n\tif (err < 0) {\n\t\tdev_err(&port->dev, \"Failed to add USB PHY: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t/* populate connector entry */\n\tof_platform_populate(port->dev.of_node, NULL, NULL, &port->dev);\n\n\treturn err;\n}\n\nstatic int tegra_xusb_usb2_port_parse_dt(struct tegra_xusb_usb2_port *usb2)\n{\n\tstruct tegra_xusb_port *port = &usb2->base;\n\tstruct device_node *np = port->dev.of_node;\n\tconst char *mode;\n\tint err;\n\n\tusb2->internal = of_property_read_bool(np, \"nvidia,internal\");\n\n\tif (!of_property_read_string(np, \"mode\", &mode)) {\n\t\tint err = match_string(modes, ARRAY_SIZE(modes), mode);\n\t\tif (err < 0) {\n\t\t\tdev_err(&port->dev, \"invalid value %s for \\\"mode\\\"\\n\",\n\t\t\t\tmode);\n\t\t\tusb2->mode = USB_DR_MODE_UNKNOWN;\n\t\t} else {\n\t\t\tusb2->mode = err;\n\t\t}\n\t} else {\n\t\tusb2->mode = USB_DR_MODE_HOST;\n\t}\n\n\t/* usb-role-switch property is mandatory for OTG/Peripheral modes */\n\tif (usb2->mode == USB_DR_MODE_PERIPHERAL ||\n\t    usb2->mode == USB_DR_MODE_OTG) {\n\t\tif (of_property_read_bool(np, \"usb-role-switch\")) {\n\t\t\terr = tegra_xusb_setup_usb_role_switch(port);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tdev_err(&port->dev, \"usb-role-switch not found for %s mode\",\n\t\t\t\tmodes[usb2->mode]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tusb2->supply = regulator_get(&port->dev, \"vbus\");\n\treturn PTR_ERR_OR_ZERO(usb2->supply);\n}\n\nstatic int tegra_xusb_add_usb2_port(struct tegra_xusb_padctl *padctl,\n\t\t\t\t    unsigned int index)\n{\n\tstruct tegra_xusb_usb2_port *usb2;\n\tstruct device_node *np;\n\tint err = 0;\n\n\t/*\n\t * USB2 ports don't require additional properties, but if the port is\n\t * marked as disabled there is no reason to register it.\n\t */\n\tnp = tegra_xusb_find_port_node(padctl, \"usb2\", index);\n\tif (!np || !of_device_is_available(np))\n\t\tgoto out;\n\n\tusb2 = kzalloc(sizeof(*usb2), GFP_KERNEL);\n\tif (!usb2) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_port_init(&usb2->base, padctl, np, \"usb2\", index);\n\tif (err < 0)\n\t\tgoto out;\n\n\tusb2->base.ops = padctl->soc->ports.usb2.ops;\n\n\tusb2->base.lane = usb2->base.ops->map(&usb2->base);\n\tif (IS_ERR(usb2->base.lane)) {\n\t\terr = PTR_ERR(usb2->base.lane);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_usb2_port_parse_dt(usb2);\n\tif (err < 0) {\n\t\ttegra_xusb_port_unregister(&usb2->base);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&usb2->base.list, &padctl->ports);\n\nout:\n\tof_node_put(np);\n\treturn err;\n}\n\nvoid tegra_xusb_usb2_port_release(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_usb2_port *usb2 = to_usb2_port(port);\n\n\tkfree(usb2);\n}\n\nvoid tegra_xusb_usb2_port_remove(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_usb2_port *usb2 = to_usb2_port(port);\n\n\tregulator_put(usb2->supply);\n}\n\nstatic int tegra_xusb_ulpi_port_parse_dt(struct tegra_xusb_ulpi_port *ulpi)\n{\n\tstruct tegra_xusb_port *port = &ulpi->base;\n\tstruct device_node *np = port->dev.of_node;\n\n\tulpi->internal = of_property_read_bool(np, \"nvidia,internal\");\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_add_ulpi_port(struct tegra_xusb_padctl *padctl,\n\t\t\t\t    unsigned int index)\n{\n\tstruct tegra_xusb_ulpi_port *ulpi;\n\tstruct device_node *np;\n\tint err = 0;\n\n\tnp = tegra_xusb_find_port_node(padctl, \"ulpi\", index);\n\tif (!np || !of_device_is_available(np))\n\t\tgoto out;\n\n\tulpi = kzalloc(sizeof(*ulpi), GFP_KERNEL);\n\tif (!ulpi) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_port_init(&ulpi->base, padctl, np, \"ulpi\", index);\n\tif (err < 0)\n\t\tgoto out;\n\n\tulpi->base.ops = padctl->soc->ports.ulpi.ops;\n\n\tulpi->base.lane = ulpi->base.ops->map(&ulpi->base);\n\tif (IS_ERR(ulpi->base.lane)) {\n\t\terr = PTR_ERR(ulpi->base.lane);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_ulpi_port_parse_dt(ulpi);\n\tif (err < 0) {\n\t\ttegra_xusb_port_unregister(&ulpi->base);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&ulpi->base.list, &padctl->ports);\n\nout:\n\tof_node_put(np);\n\treturn err;\n}\n\nvoid tegra_xusb_ulpi_port_release(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_ulpi_port *ulpi = to_ulpi_port(port);\n\n\tkfree(ulpi);\n}\n\nstatic int tegra_xusb_hsic_port_parse_dt(struct tegra_xusb_hsic_port *hsic)\n{\n\t/* XXX */\n\treturn 0;\n}\n\nstatic int tegra_xusb_add_hsic_port(struct tegra_xusb_padctl *padctl,\n\t\t\t\t    unsigned int index)\n{\n\tstruct tegra_xusb_hsic_port *hsic;\n\tstruct device_node *np;\n\tint err = 0;\n\n\tnp = tegra_xusb_find_port_node(padctl, \"hsic\", index);\n\tif (!np || !of_device_is_available(np))\n\t\tgoto out;\n\n\thsic = kzalloc(sizeof(*hsic), GFP_KERNEL);\n\tif (!hsic) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_port_init(&hsic->base, padctl, np, \"hsic\", index);\n\tif (err < 0)\n\t\tgoto out;\n\n\thsic->base.ops = padctl->soc->ports.hsic.ops;\n\n\thsic->base.lane = hsic->base.ops->map(&hsic->base);\n\tif (IS_ERR(hsic->base.lane)) {\n\t\terr = PTR_ERR(hsic->base.lane);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_hsic_port_parse_dt(hsic);\n\tif (err < 0) {\n\t\ttegra_xusb_port_unregister(&hsic->base);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&hsic->base.list, &padctl->ports);\n\nout:\n\tof_node_put(np);\n\treturn err;\n}\n\nvoid tegra_xusb_hsic_port_release(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_hsic_port *hsic = to_hsic_port(port);\n\n\tkfree(hsic);\n}\n\nstatic int tegra_xusb_usb3_port_parse_dt(struct tegra_xusb_usb3_port *usb3)\n{\n\tstruct tegra_xusb_port *port = &usb3->base;\n\tstruct device_node *np = port->dev.of_node;\n\tenum usb_device_speed maximum_speed;\n\tu32 value;\n\tint err;\n\n\terr = of_property_read_u32(np, \"nvidia,usb2-companion\", &value);\n\tif (err < 0) {\n\t\tdev_err(&port->dev, \"failed to read port: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tusb3->port = value;\n\n\tusb3->internal = of_property_read_bool(np, \"nvidia,internal\");\n\n\tif (device_property_present(&port->dev, \"maximum-speed\")) {\n\t\tmaximum_speed =  usb_get_maximum_speed(&port->dev);\n\t\tif (maximum_speed == USB_SPEED_SUPER)\n\t\t\tusb3->disable_gen2 = true;\n\t\telse if (maximum_speed == USB_SPEED_SUPER_PLUS)\n\t\t\tusb3->disable_gen2 = false;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tusb3->supply = regulator_get(&port->dev, \"vbus\");\n\treturn PTR_ERR_OR_ZERO(usb3->supply);\n}\n\nstatic int tegra_xusb_add_usb3_port(struct tegra_xusb_padctl *padctl,\n\t\t\t\t    unsigned int index)\n{\n\tstruct tegra_xusb_usb3_port *usb3;\n\tstruct device_node *np;\n\tint err = 0;\n\n\t/*\n\t * If there is no supplemental configuration in the device tree the\n\t * port is unusable. But it is valid to configure only a single port,\n\t * hence return 0 instead of an error to allow ports to be optional.\n\t */\n\tnp = tegra_xusb_find_port_node(padctl, \"usb3\", index);\n\tif (!np || !of_device_is_available(np))\n\t\tgoto out;\n\n\tusb3 = kzalloc(sizeof(*usb3), GFP_KERNEL);\n\tif (!usb3) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_port_init(&usb3->base, padctl, np, \"usb3\", index);\n\tif (err < 0)\n\t\tgoto out;\n\n\tusb3->base.ops = padctl->soc->ports.usb3.ops;\n\n\tusb3->base.lane = usb3->base.ops->map(&usb3->base);\n\tif (IS_ERR(usb3->base.lane)) {\n\t\terr = PTR_ERR(usb3->base.lane);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_usb3_port_parse_dt(usb3);\n\tif (err < 0) {\n\t\ttegra_xusb_port_unregister(&usb3->base);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&usb3->base.list, &padctl->ports);\n\nout:\n\tof_node_put(np);\n\treturn err;\n}\n\nvoid tegra_xusb_usb3_port_release(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_usb3_port *usb3 = to_usb3_port(port);\n\n\tkfree(usb3);\n}\n\nvoid tegra_xusb_usb3_port_remove(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_usb3_port *usb3 = to_usb3_port(port);\n\n\tregulator_put(usb3->supply);\n}\n\nstatic void __tegra_xusb_remove_ports(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra_xusb_port *port, *tmp;\n\n\tlist_for_each_entry_safe_reverse(port, tmp, &padctl->ports, list) {\n\t\tlist_del(&port->list);\n\t\ttegra_xusb_port_unregister(port);\n\t}\n}\n\nstatic int tegra_xusb_find_unused_usb3_port(struct tegra_xusb_padctl *padctl)\n{\n\tstruct device_node *np;\n\tunsigned int i;\n\n\tfor (i = 0; i < padctl->soc->ports.usb3.count; i++) {\n\t\tnp = tegra_xusb_find_port_node(padctl, \"usb3\", i);\n\t\tif (!np || !of_device_is_available(np))\n\t\t\treturn i;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic bool tegra_xusb_port_is_companion(struct tegra_xusb_usb2_port *usb2)\n{\n\tunsigned int i;\n\tstruct tegra_xusb_usb3_port *usb3;\n\tstruct tegra_xusb_padctl *padctl = usb2->base.padctl;\n\n\tfor (i = 0; i < padctl->soc->ports.usb3.count; i++) {\n\t\tusb3 = tegra_xusb_find_usb3_port(padctl, i);\n\t\tif (usb3 && usb3->port == usb2->base.index)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int tegra_xusb_update_usb3_fake_port(struct tegra_xusb_usb2_port *usb2)\n{\n\tint fake;\n\n\t/* Disable usb3_port_fake usage by default and assign if needed */\n\tusb2->usb3_port_fake = -1;\n\n\tif ((usb2->mode == USB_DR_MODE_OTG ||\n\t     usb2->mode == USB_DR_MODE_PERIPHERAL) &&\n\t\t!tegra_xusb_port_is_companion(usb2)) {\n\t\tfake = tegra_xusb_find_unused_usb3_port(usb2->base.padctl);\n\t\tif (fake < 0) {\n\t\t\tdev_err(&usb2->base.dev, \"no unused USB3 ports available\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tdev_dbg(&usb2->base.dev, \"Found unused usb3 port: %d\\n\", fake);\n\t\tusb2->usb3_port_fake = fake;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_setup_ports(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra_xusb_port *port;\n\tstruct tegra_xusb_usb2_port *usb2;\n\tunsigned int i;\n\tint err = 0;\n\n\tmutex_lock(&padctl->lock);\n\n\tfor (i = 0; i < padctl->soc->ports.usb2.count; i++) {\n\t\terr = tegra_xusb_add_usb2_port(padctl, i);\n\t\tif (err < 0)\n\t\t\tgoto remove_ports;\n\t}\n\n\tfor (i = 0; i < padctl->soc->ports.ulpi.count; i++) {\n\t\terr = tegra_xusb_add_ulpi_port(padctl, i);\n\t\tif (err < 0)\n\t\t\tgoto remove_ports;\n\t}\n\n\tfor (i = 0; i < padctl->soc->ports.hsic.count; i++) {\n\t\terr = tegra_xusb_add_hsic_port(padctl, i);\n\t\tif (err < 0)\n\t\t\tgoto remove_ports;\n\t}\n\n\tfor (i = 0; i < padctl->soc->ports.usb3.count; i++) {\n\t\terr = tegra_xusb_add_usb3_port(padctl, i);\n\t\tif (err < 0)\n\t\t\tgoto remove_ports;\n\t}\n\n\tif (padctl->soc->need_fake_usb3_port) {\n\t\tfor (i = 0; i < padctl->soc->ports.usb2.count; i++) {\n\t\t\tusb2 = tegra_xusb_find_usb2_port(padctl, i);\n\t\t\tif (!usb2)\n\t\t\t\tcontinue;\n\n\t\t\terr = tegra_xusb_update_usb3_fake_port(usb2);\n\t\t\tif (err < 0)\n\t\t\t\tgoto remove_ports;\n\t\t}\n\t}\n\n\tlist_for_each_entry(port, &padctl->ports, list) {\n\t\terr = port->ops->enable(port);\n\t\tif (err < 0)\n\t\t\tdev_err(padctl->dev, \"failed to enable port %s: %d\\n\",\n\t\t\t\tdev_name(&port->dev), err);\n\t}\n\n\tgoto unlock;\n\nremove_ports:\n\t__tegra_xusb_remove_ports(padctl);\nunlock:\n\tmutex_unlock(&padctl->lock);\n\treturn err;\n}\n\nstatic void tegra_xusb_remove_ports(struct tegra_xusb_padctl *padctl)\n{\n\tmutex_lock(&padctl->lock);\n\t__tegra_xusb_remove_ports(padctl);\n\tmutex_unlock(&padctl->lock);\n}\n\nstatic int tegra_xusb_padctl_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct tegra_xusb_padctl_soc *soc;\n\tstruct tegra_xusb_padctl *padctl;\n\tconst struct of_device_id *match;\n\tint err;\n\n\t/* for backwards compatibility with old device trees */\n\tnp = of_get_child_by_name(np, \"pads\");\n\tif (!np) {\n\t\tdev_warn(&pdev->dev, \"deprecated DT, using legacy driver\\n\");\n\t\treturn tegra_xusb_padctl_legacy_probe(pdev);\n\t}\n\n\tof_node_put(np);\n\n\tmatch = of_match_node(tegra_xusb_padctl_of_match, pdev->dev.of_node);\n\tsoc = match->data;\n\n\tpadctl = soc->ops->probe(&pdev->dev, soc);\n\tif (IS_ERR(padctl))\n\t\treturn PTR_ERR(padctl);\n\n\tplatform_set_drvdata(pdev, padctl);\n\tINIT_LIST_HEAD(&padctl->ports);\n\tINIT_LIST_HEAD(&padctl->lanes);\n\tINIT_LIST_HEAD(&padctl->pads);\n\tmutex_init(&padctl->lock);\n\n\tpadctl->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(padctl->regs)) {\n\t\terr = PTR_ERR(padctl->regs);\n\t\tgoto remove;\n\t}\n\n\tpadctl->rst = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(padctl->rst)) {\n\t\terr = PTR_ERR(padctl->rst);\n\t\tgoto remove;\n\t}\n\n\tpadctl->supplies = devm_kcalloc(&pdev->dev, padctl->soc->num_supplies,\n\t\t\t\t\tsizeof(*padctl->supplies), GFP_KERNEL);\n\tif (!padctl->supplies) {\n\t\terr = -ENOMEM;\n\t\tgoto remove;\n\t}\n\n\tregulator_bulk_set_supply_names(padctl->supplies,\n\t\t\t\t\tpadctl->soc->supply_names,\n\t\t\t\t\tpadctl->soc->num_supplies);\n\n\terr = devm_regulator_bulk_get(&pdev->dev, padctl->soc->num_supplies,\n\t\t\t\t      padctl->supplies);\n\tif (err < 0) {\n\t\tdev_err_probe(&pdev->dev, err, \"failed to get regulators\\n\");\n\t\tgoto remove;\n\t}\n\n\terr = reset_control_deassert(padctl->rst);\n\tif (err < 0)\n\t\tgoto remove;\n\n\terr = regulator_bulk_enable(padctl->soc->num_supplies,\n\t\t\t\t    padctl->supplies);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable supplies: %d\\n\", err);\n\t\tgoto reset;\n\t}\n\n\terr = tegra_xusb_setup_pads(padctl);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to setup pads: %d\\n\", err);\n\t\tgoto power_down;\n\t}\n\n\terr = tegra_xusb_setup_ports(padctl);\n\tif (err) {\n\t\tconst char *level = KERN_ERR;\n\n\t\tif (err == -EPROBE_DEFER)\n\t\t\tlevel = KERN_DEBUG;\n\n\t\tdev_printk(level, &pdev->dev,\n\t\t\t   dev_fmt(\"failed to setup XUSB ports: %d\\n\"), err);\n\t\tgoto remove_pads;\n\t}\n\n\treturn 0;\n\nremove_pads:\n\ttegra_xusb_remove_pads(padctl);\npower_down:\n\tregulator_bulk_disable(padctl->soc->num_supplies, padctl->supplies);\nreset:\n\treset_control_assert(padctl->rst);\nremove:\n\tplatform_set_drvdata(pdev, NULL);\n\tsoc->ops->remove(padctl);\n\treturn err;\n}\n\nstatic int tegra_xusb_padctl_remove(struct platform_device *pdev)\n{\n\tstruct tegra_xusb_padctl *padctl = platform_get_drvdata(pdev);\n\tint err;\n\n\ttegra_xusb_remove_ports(padctl);\n\ttegra_xusb_remove_pads(padctl);\n\n\terr = regulator_bulk_disable(padctl->soc->num_supplies,\n\t\t\t\t     padctl->supplies);\n\tif (err < 0)\n\t\tdev_err(&pdev->dev, \"failed to disable supplies: %d\\n\", err);\n\n\terr = reset_control_assert(padctl->rst);\n\tif (err < 0)\n\t\tdev_err(&pdev->dev, \"failed to assert reset: %d\\n\", err);\n\n\tpadctl->soc->ops->remove(padctl);\n\n\treturn err;\n}\n\nstatic __maybe_unused int tegra_xusb_padctl_suspend_noirq(struct device *dev)\n{\n\tstruct tegra_xusb_padctl *padctl = dev_get_drvdata(dev);\n\n\tif (padctl->soc && padctl->soc->ops && padctl->soc->ops->suspend_noirq)\n\t\treturn padctl->soc->ops->suspend_noirq(padctl);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int tegra_xusb_padctl_resume_noirq(struct device *dev)\n{\n\tstruct tegra_xusb_padctl *padctl = dev_get_drvdata(dev);\n\n\tif (padctl->soc && padctl->soc->ops && padctl->soc->ops->resume_noirq)\n\t\treturn padctl->soc->ops->resume_noirq(padctl);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_xusb_padctl_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(tegra_xusb_padctl_suspend_noirq,\n\t\t\t\t      tegra_xusb_padctl_resume_noirq)\n};\n\nstatic struct platform_driver tegra_xusb_padctl_driver = {\n\t.driver = {\n\t\t.name = \"tegra-xusb-padctl\",\n\t\t.of_match_table = tegra_xusb_padctl_of_match,\n\t\t.pm = &tegra_xusb_padctl_pm_ops,\n\t},\n\t.probe = tegra_xusb_padctl_probe,\n\t.remove = tegra_xusb_padctl_remove,\n};\nmodule_platform_driver(tegra_xusb_padctl_driver);\n\nstruct tegra_xusb_padctl *tegra_xusb_padctl_get(struct device *dev)\n{\n\tstruct tegra_xusb_padctl *padctl;\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\n\tnp = of_parse_phandle(dev->of_node, \"nvidia,xusb-padctl\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * This is slightly ugly. A better implementation would be to keep a\n\t * registry of pad controllers, but since there will almost certainly\n\t * only ever be one per SoC that would be a little overkill.\n\t */\n\tpdev = of_find_device_by_node(np);\n\tif (!pdev) {\n\t\tof_node_put(np);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tof_node_put(np);\n\n\tpadctl = platform_get_drvdata(pdev);\n\tif (!padctl) {\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\treturn padctl;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_get);\n\nvoid tegra_xusb_padctl_put(struct tegra_xusb_padctl *padctl)\n{\n\tif (padctl)\n\t\tput_device(padctl->dev);\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_put);\n\nint tegra_xusb_padctl_usb3_save_context(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\tunsigned int port)\n{\n\tif (padctl->soc->ops->usb3_save_context)\n\t\treturn padctl->soc->ops->usb3_save_context(padctl, port);\n\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_usb3_save_context);\n\nint tegra_xusb_padctl_hsic_set_idle(struct tegra_xusb_padctl *padctl,\n\t\t\t\t    unsigned int port, bool idle)\n{\n\tif (padctl->soc->ops->hsic_set_idle)\n\t\treturn padctl->soc->ops->hsic_set_idle(padctl, port, idle);\n\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_hsic_set_idle);\n\nint tegra_xusb_padctl_enable_phy_sleepwalk(struct tegra_xusb_padctl *padctl, struct phy *phy,\n\t\t\t\t\t   enum usb_device_speed speed)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\tif (lane->pad->ops->enable_phy_sleepwalk)\n\t\treturn lane->pad->ops->enable_phy_sleepwalk(lane, speed);\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_enable_phy_sleepwalk);\n\nint tegra_xusb_padctl_disable_phy_sleepwalk(struct tegra_xusb_padctl *padctl, struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\tif (lane->pad->ops->disable_phy_sleepwalk)\n\t\treturn lane->pad->ops->disable_phy_sleepwalk(lane);\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_disable_phy_sleepwalk);\n\nint tegra_xusb_padctl_enable_phy_wake(struct tegra_xusb_padctl *padctl, struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\tif (lane->pad->ops->enable_phy_wake)\n\t\treturn lane->pad->ops->enable_phy_wake(lane);\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_enable_phy_wake);\n\nint tegra_xusb_padctl_disable_phy_wake(struct tegra_xusb_padctl *padctl, struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\tif (lane->pad->ops->disable_phy_wake)\n\t\treturn lane->pad->ops->disable_phy_wake(lane);\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_disable_phy_wake);\n\nbool tegra_xusb_padctl_remote_wake_detected(struct tegra_xusb_padctl *padctl, struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\tif (lane->pad->ops->remote_wake_detected)\n\t\treturn lane->pad->ops->remote_wake_detected(lane);\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_remote_wake_detected);\n\nint tegra_xusb_padctl_usb3_set_lfps_detect(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\t   unsigned int port, bool enable)\n{\n\tif (padctl->soc->ops->usb3_set_lfps_detect)\n\t\treturn padctl->soc->ops->usb3_set_lfps_detect(padctl, port,\n\t\t\t\t\t\t\t      enable);\n\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_usb3_set_lfps_detect);\n\nint tegra_xusb_padctl_set_vbus_override(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\t\t\tbool val)\n{\n\tif (padctl->soc->ops->vbus_override)\n\t\treturn padctl->soc->ops->vbus_override(padctl, val);\n\n\treturn -ENOTSUPP;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_set_vbus_override);\n\nint tegra_phy_xusb_utmi_port_reset(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\n\tif (padctl->soc->ops->utmi_port_reset)\n\t\treturn padctl->soc->ops->utmi_port_reset(phy);\n\n\treturn -ENOTSUPP;\n}\nEXPORT_SYMBOL_GPL(tegra_phy_xusb_utmi_port_reset);\n\nint tegra_xusb_padctl_get_usb3_companion(struct tegra_xusb_padctl *padctl,\n\t\t\t\t    unsigned int port)\n{\n\tstruct tegra_xusb_usb2_port *usb2;\n\tstruct tegra_xusb_usb3_port *usb3;\n\tint i;\n\n\tusb2 = tegra_xusb_find_usb2_port(padctl, port);\n\tif (!usb2)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < padctl->soc->ports.usb3.count; i++) {\n\t\tusb3 = tegra_xusb_find_usb3_port(padctl, i);\n\t\tif (usb3 && usb3->port == usb2->base.index)\n\t\t\treturn usb3->base.index;\n\t}\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_get_usb3_companion);\n\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra XUSB Pad Controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n"], "buggy_code_start_loc": [458], "buggy_code_end_loc": [459], "fixing_code_start_loc": [458], "fixing_code_end_loc": [459], "type": "CWE-476", "message": "In the Linux kernel before 5.17, drivers/phy/tegra/xusb.c mishandles the tegra_xusb_find_port_node return value. Callers expect NULL in the error case, but an error pointer is used.", "other": {"cve": {"id": "CVE-2023-23000", "sourceIdentifier": "cve@mitre.org", "published": "2023-03-01T19:15:25.967", "lastModified": "2023-03-31T11:15:06.983", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.17, drivers/phy/tegra/xusb.c mishandles the tegra_xusb_find_port_node return value. Callers expect NULL in the error case, but an error pointer is used."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.17", "matchCriteriaId": "A37A8EE9-3F14-4C7A-A882-DA8A6AD1897C"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/045a31b95509c8f25f5f04ec5e0dec5cd09f2c5f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.netapp.com/advisory/ntap-20230331-0004/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/045a31b95509c8f25f5f04ec5e0dec5cd09f2c5f"}}