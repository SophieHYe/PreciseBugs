{"buggy_code": ["/*\n *  linux/kernel/sys.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/utsname.h>\n#include <linux/mman.h>\n#include <linux/reboot.h>\n#include <linux/prctl.h>\n#include <linux/highuid.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/perf_event.h>\n#include <linux/resource.h>\n#include <linux/kernel.h>\n#include <linux/kexec.h>\n#include <linux/workqueue.h>\n#include <linux/capability.h>\n#include <linux/device.h>\n#include <linux/key.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/security.h>\n#include <linux/dcookies.h>\n#include <linux/suspend.h>\n#include <linux/tty.h>\n#include <linux/signal.h>\n#include <linux/cn_proc.h>\n#include <linux/getcpu.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/seccomp.h>\n#include <linux/cpu.h>\n#include <linux/personality.h>\n#include <linux/ptrace.h>\n#include <linux/fs_struct.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/syscore_ops.h>\n#include <linux/version.h>\n#include <linux/ctype.h>\n\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/user_namespace.h>\n\n#include <linux/kmsg_dump.h>\n/* Move somewhere else to avoid recompiling? */\n#include <generated/utsrelease.h>\n\n#include <asm/uaccess.h>\n#include <asm/io.h>\n#include <asm/unistd.h>\n\n#ifndef SET_UNALIGN_CTL\n# define SET_UNALIGN_CTL(a,b)\t(-EINVAL)\n#endif\n#ifndef GET_UNALIGN_CTL\n# define GET_UNALIGN_CTL(a,b)\t(-EINVAL)\n#endif\n#ifndef SET_FPEMU_CTL\n# define SET_FPEMU_CTL(a,b)\t(-EINVAL)\n#endif\n#ifndef GET_FPEMU_CTL\n# define GET_FPEMU_CTL(a,b)\t(-EINVAL)\n#endif\n#ifndef SET_FPEXC_CTL\n# define SET_FPEXC_CTL(a,b)\t(-EINVAL)\n#endif\n#ifndef GET_FPEXC_CTL\n# define GET_FPEXC_CTL(a,b)\t(-EINVAL)\n#endif\n#ifndef GET_ENDIAN\n# define GET_ENDIAN(a,b)\t(-EINVAL)\n#endif\n#ifndef SET_ENDIAN\n# define SET_ENDIAN(a,b)\t(-EINVAL)\n#endif\n#ifndef GET_TSC_CTL\n# define GET_TSC_CTL(a)\t\t(-EINVAL)\n#endif\n#ifndef SET_TSC_CTL\n# define SET_TSC_CTL(a)\t\t(-EINVAL)\n#endif\n\n/*\n * this is where the system-wide overflow UID and GID are defined, for\n * architectures that now have 32-bit UID/GID but didn't in the past\n */\n\nint overflowuid = DEFAULT_OVERFLOWUID;\nint overflowgid = DEFAULT_OVERFLOWGID;\n\nEXPORT_SYMBOL(overflowuid);\nEXPORT_SYMBOL(overflowgid);\n\n/*\n * the same as above, but for filesystems which can only store a 16-bit\n * UID and GID. as such, this is needed on all architectures\n */\n\nint fs_overflowuid = DEFAULT_FS_OVERFLOWUID;\nint fs_overflowgid = DEFAULT_FS_OVERFLOWUID;\n\nEXPORT_SYMBOL(fs_overflowuid);\nEXPORT_SYMBOL(fs_overflowgid);\n\n/*\n * this indicates whether you can reboot with ctrl-alt-del: the default is yes\n */\n\nint C_A_D = 1;\nstruct pid *cad_pid;\nEXPORT_SYMBOL(cad_pid);\n\n/*\n * If set, this is used for preparing the system to power off.\n */\n\nvoid (*pm_power_off_prepare)(void);\n\n/*\n * Returns true if current's euid is same as p's uid or euid,\n * or has CAP_SYS_NICE to p's user_ns.\n *\n * Called with rcu_read_lock, creds are safe\n */\nstatic bool set_one_prio_perm(struct task_struct *p)\n{\n\tconst struct cred *cred = current_cred(), *pcred = __task_cred(p);\n\n\tif (uid_eq(pcred->uid,  cred->euid) ||\n\t    uid_eq(pcred->euid, cred->euid))\n\t\treturn true;\n\tif (ns_capable(pcred->user_ns, CAP_SYS_NICE))\n\t\treturn true;\n\treturn false;\n}\n\n/*\n * set the priority of a task\n * - the caller must hold the RCU read lock\n */\nstatic int set_one_prio(struct task_struct *p, int niceval, int error)\n{\n\tint no_nice;\n\n\tif (!set_one_prio_perm(p)) {\n\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\tif (niceval < task_nice(p) && !can_nice(p, niceval)) {\n\t\terror = -EACCES;\n\t\tgoto out;\n\t}\n\tno_nice = security_task_setnice(p, niceval);\n\tif (no_nice) {\n\t\terror = no_nice;\n\t\tgoto out;\n\t}\n\tif (error == -ESRCH)\n\t\terror = 0;\n\tset_user_nice(p, niceval);\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE3(setpriority, int, which, int, who, int, niceval)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tconst struct cred *cred = current_cred();\n\tint error = -EINVAL;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\n\tif (which > PRIO_USER || which < PRIO_PROCESS)\n\t\tgoto out;\n\n\t/* normalize: avoid signed division (rounding problems) */\n\terror = -ESRCH;\n\tif (niceval < -20)\n\t\tniceval = -20;\n\tif (niceval > 19)\n\t\tniceval = 19;\n\n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tswitch (which) {\n\t\tcase PRIO_PROCESS:\n\t\t\tif (who)\n\t\t\t\tp = find_task_by_vpid(who);\n\t\t\telse\n\t\t\t\tp = current;\n\t\t\tif (p)\n\t\t\t\terror = set_one_prio(p, niceval, error);\n\t\t\tbreak;\n\t\tcase PRIO_PGRP:\n\t\t\tif (who)\n\t\t\t\tpgrp = find_vpid(who);\n\t\t\telse\n\t\t\t\tpgrp = task_pgrp(current);\n\t\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\t\terror = set_one_prio(p, niceval, error);\n\t\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\t\tbreak;\n\t\tcase PRIO_USER:\n\t\t\tuid = make_kuid(cred->user_ns, who);\n\t\t\tuser = cred->user;\n\t\t\tif (!who)\n\t\t\t\tuid = cred->uid;\n\t\t\telse if (!uid_eq(uid, cred->uid) &&\n\t\t\t\t !(user = find_user(uid)))\n\t\t\t\tgoto out_unlock;\t/* No processes for this user */\n\n\t\t\tdo_each_thread(g, p) {\n\t\t\t\tif (uid_eq(task_uid(p), uid))\n\t\t\t\t\terror = set_one_prio(p, niceval, error);\n\t\t\t} while_each_thread(g, p);\n\t\t\tif (!uid_eq(uid, cred->uid))\n\t\t\t\tfree_uid(user);\t\t/* For find_user() */\n\t\t\tbreak;\n\t}\nout_unlock:\n\tread_unlock(&tasklist_lock);\n\trcu_read_unlock();\nout:\n\treturn error;\n}\n\n/*\n * Ugh. To avoid negative return values, \"getpriority()\" will\n * not return the normal nice-value, but a negated value that\n * has been offset by 20 (ie it returns 40..1 instead of -20..19)\n * to stay compatible.\n */\nSYSCALL_DEFINE2(getpriority, int, which, int, who)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tconst struct cred *cred = current_cred();\n\tlong niceval, retval = -ESRCH;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\n\tif (which > PRIO_USER || which < PRIO_PROCESS)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tswitch (which) {\n\t\tcase PRIO_PROCESS:\n\t\t\tif (who)\n\t\t\t\tp = find_task_by_vpid(who);\n\t\t\telse\n\t\t\t\tp = current;\n\t\t\tif (p) {\n\t\t\t\tniceval = 20 - task_nice(p);\n\t\t\t\tif (niceval > retval)\n\t\t\t\t\tretval = niceval;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PRIO_PGRP:\n\t\t\tif (who)\n\t\t\t\tpgrp = find_vpid(who);\n\t\t\telse\n\t\t\t\tpgrp = task_pgrp(current);\n\t\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\t\tniceval = 20 - task_nice(p);\n\t\t\t\tif (niceval > retval)\n\t\t\t\t\tretval = niceval;\n\t\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\t\tbreak;\n\t\tcase PRIO_USER:\n\t\t\tuid = make_kuid(cred->user_ns, who);\n\t\t\tuser = cred->user;\n\t\t\tif (!who)\n\t\t\t\tuid = cred->uid;\n\t\t\telse if (!uid_eq(uid, cred->uid) &&\n\t\t\t\t !(user = find_user(uid)))\n\t\t\t\tgoto out_unlock;\t/* No processes for this user */\n\n\t\t\tdo_each_thread(g, p) {\n\t\t\t\tif (uid_eq(task_uid(p), uid)) {\n\t\t\t\t\tniceval = 20 - task_nice(p);\n\t\t\t\t\tif (niceval > retval)\n\t\t\t\t\t\tretval = niceval;\n\t\t\t\t}\n\t\t\t} while_each_thread(g, p);\n\t\t\tif (!uid_eq(uid, cred->uid))\n\t\t\t\tfree_uid(user);\t\t/* for find_user() */\n\t\t\tbreak;\n\t}\nout_unlock:\n\tread_unlock(&tasklist_lock);\n\trcu_read_unlock();\n\n\treturn retval;\n}\n\n/**\n *\temergency_restart - reboot the system\n *\n *\tWithout shutting down any hardware or taking any locks\n *\treboot the system.  This is called when we know we are in\n *\ttrouble so this is our best effort to reboot.  This is\n *\tsafe to call in interrupt context.\n */\nvoid emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tmachine_emergency_restart();\n}\nEXPORT_SYMBOL_GPL(emergency_restart);\n\nvoid kernel_restart_prepare(char *cmd)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);\n\tsystem_state = SYSTEM_RESTART;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n\tsyscore_shutdown();\n}\n\n/**\n *\tregister_reboot_notifier - Register function to be called at reboot time\n *\t@nb: Info about notifier function to be called\n *\n *\tRegisters a function with the list of functions\n *\tto be called at reboot time.\n *\n *\tCurrently always returns zero, as blocking_notifier_chain_register()\n *\talways returns zero.\n */\nint register_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&reboot_notifier_list, nb);\n}\nEXPORT_SYMBOL(register_reboot_notifier);\n\n/**\n *\tunregister_reboot_notifier - Unregister previously registered reboot notifier\n *\t@nb: Hook to be unregistered\n *\n *\tUnregisters a previously registered reboot\n *\tnotifier function.\n *\n *\tReturns zero on success, or %-ENOENT on failure.\n */\nint unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}\nEXPORT_SYMBOL(unregister_reboot_notifier);\n\n/**\n *\tkernel_restart - reboot the system\n *\t@cmd: pointer to buffer containing command to execute for restart\n *\t\tor %NULL\n *\n *\tShutdown everything and perform a clean reboot.\n *\tThis is not safe to call in interrupt context.\n */\nvoid kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tdisable_nonboot_cpus();\n\tif (!cmd)\n\t\tprintk(KERN_EMERG \"Restarting system.\\n\");\n\telse\n\t\tprintk(KERN_EMERG \"Restarting system with command '%s'.\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_RESTART);\n\tmachine_restart(cmd);\n}\nEXPORT_SYMBOL_GPL(kernel_restart);\n\nstatic void kernel_shutdown_prepare(enum system_states state)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list,\n\t\t(state == SYSTEM_HALT)?SYS_HALT:SYS_POWER_OFF, NULL);\n\tsystem_state = state;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}\n/**\n *\tkernel_halt - halt the system\n *\n *\tShutdown everything and perform a clean system halt.\n */\nvoid kernel_halt(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_HALT);\n\tsyscore_shutdown();\n\tprintk(KERN_EMERG \"System halted.\\n\");\n\tkmsg_dump(KMSG_DUMP_HALT);\n\tmachine_halt();\n}\n\nEXPORT_SYMBOL_GPL(kernel_halt);\n\n/**\n *\tkernel_power_off - power_off the system\n *\n *\tShutdown everything and perform a clean system power_off.\n */\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tdisable_nonboot_cpus();\n\tsyscore_shutdown();\n\tprintk(KERN_EMERG \"Power down.\\n\");\n\tkmsg_dump(KMSG_DUMP_POWEROFF);\n\tmachine_power_off();\n}\nEXPORT_SYMBOL_GPL(kernel_power_off);\n\nstatic DEFINE_MUTEX(reboot_mutex);\n\n/*\n * Reboot system call: for obvious reasons only root may call it,\n * and even root needs to set up some magic numbers in the registers\n * so that some mistake won't make this reboot the whole machine.\n * You can also set the meaning of the ctrl-alt-del-key here.\n *\n * reboot doesn't sync: do that yourself before calling this.\n */\nSYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,\n\t\tvoid __user *, arg)\n{\n\tchar buffer[256];\n\tint ret = 0;\n\n\t/* We only trust the superuser with rebooting the system. */\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\t/* For safety, we require \"magic\" arguments. */\n\tif (magic1 != LINUX_REBOOT_MAGIC1 ||\n\t    (magic2 != LINUX_REBOOT_MAGIC2 &&\n\t                magic2 != LINUX_REBOOT_MAGIC2A &&\n\t\t\tmagic2 != LINUX_REBOOT_MAGIC2B &&\n\t                magic2 != LINUX_REBOOT_MAGIC2C))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If pid namespaces are enabled and the current task is in a child\n\t * pid_namespace, the command is handled by reboot_pid_ns() which will\n\t * call do_exit().\n\t */\n\tret = reboot_pid_ns(task_active_pid_ns(current), cmd);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Instead of trying to make the power_off code look like\n\t * halt when pm_power_off is not set do it the easy way.\n\t */\n\tif ((cmd == LINUX_REBOOT_CMD_POWER_OFF) && !pm_power_off)\n\t\tcmd = LINUX_REBOOT_CMD_HALT;\n\n\tmutex_lock(&reboot_mutex);\n\tswitch (cmd) {\n\tcase LINUX_REBOOT_CMD_RESTART:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_CAD_ON:\n\t\tC_A_D = 1;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_CAD_OFF:\n\t\tC_A_D = 0;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_HALT:\n\t\tkernel_halt();\n\t\tdo_exit(0);\n\t\tpanic(\"cannot halt\");\n\n\tcase LINUX_REBOOT_CMD_POWER_OFF:\n\t\tkernel_power_off();\n\t\tdo_exit(0);\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_RESTART2:\n\t\tif (strncpy_from_user(&buffer[0], arg, sizeof(buffer) - 1) < 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\n\t\tkernel_restart(buffer);\n\t\tbreak;\n\n#ifdef CONFIG_KEXEC\n\tcase LINUX_REBOOT_CMD_KEXEC:\n\t\tret = kernel_kexec();\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_HIBERNATION\n\tcase LINUX_REBOOT_CMD_SW_SUSPEND:\n\t\tret = hibernate();\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&reboot_mutex);\n\treturn ret;\n}\n\nstatic void deferred_cad(struct work_struct *dummy)\n{\n\tkernel_restart(NULL);\n}\n\n/*\n * This function gets called by ctrl-alt-del - ie the keyboard interrupt.\n * As it's called within an interrupt, it may NOT sync: the only choice\n * is whether to reboot at once, or just ignore the ctrl-alt-del.\n */\nvoid ctrl_alt_del(void)\n{\n\tstatic DECLARE_WORK(cad_work, deferred_cad);\n\n\tif (C_A_D)\n\t\tschedule_work(&cad_work);\n\telse\n\t\tkill_cad_pid(SIGINT, 1);\n}\n\t\n/*\n * Unprivileged users may change the real gid to the effective gid\n * or vice versa.  (BSD-style)\n *\n * If you set the real gid at all, or set the effective gid to a value not\n * equal to the real gid, then the saved gid is set to the new effective gid.\n *\n * This makes it possible for a setgid program to completely drop its\n * privileges, which is often a useful assertion to make when you are doing\n * a security audit over a program.\n *\n * The general idea is that a program which uses just setregid() will be\n * 100% compatible with BSD.  A program which uses just setgid() will be\n * 100% compatible with POSIX with saved IDs. \n *\n * SMP: There are not races, the GIDs are checked only by filesystem\n *      operations (as far as semantic preservation is concerned).\n */\nSYSCALL_DEFINE2(setregid, gid_t, rgid, gid_t, egid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkgid_t krgid, kegid;\n\n\tkrgid = make_kgid(ns, rgid);\n\tkegid = make_kgid(ns, egid);\n\n\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))\n\t\treturn -EINVAL;\n\tif ((egid != (gid_t) -1) && !gid_valid(kegid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (rgid != (gid_t) -1) {\n\t\tif (gid_eq(old->gid, krgid) ||\n\t\t    gid_eq(old->egid, krgid) ||\n\t\t    nsown_capable(CAP_SETGID))\n\t\t\tnew->gid = krgid;\n\t\telse\n\t\t\tgoto error;\n\t}\n\tif (egid != (gid_t) -1) {\n\t\tif (gid_eq(old->gid, kegid) ||\n\t\t    gid_eq(old->egid, kegid) ||\n\t\t    gid_eq(old->sgid, kegid) ||\n\t\t    nsown_capable(CAP_SETGID))\n\t\t\tnew->egid = kegid;\n\t\telse\n\t\t\tgoto error;\n\t}\n\n\tif (rgid != (gid_t) -1 ||\n\t    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid)))\n\t\tnew->sgid = new->egid;\n\tnew->fsgid = new->egid;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\n/*\n * setgid() is implemented like SysV w/ SAVED_IDS \n *\n * SMP: Same implicit races as above.\n */\nSYSCALL_DEFINE1(setgid, gid_t, gid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkgid_t kgid;\n\n\tkgid = make_kgid(ns, gid);\n\tif (!gid_valid(kgid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (nsown_capable(CAP_SETGID))\n\t\tnew->gid = new->egid = new->sgid = new->fsgid = kgid;\n\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))\n\t\tnew->egid = new->fsgid = kgid;\n\telse\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\n/*\n * change the user struct in a credentials set to match the new UID\n */\nstatic int set_user(struct cred *new)\n{\n\tstruct user_struct *new_user;\n\n\tnew_user = alloc_uid(new->uid);\n\tif (!new_user)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * We don't fail in case of NPROC limit excess here because too many\n\t * poorly written programs don't check set*uid() return code, assuming\n\t * it never fails if called by root.  We may still enforce NPROC limit\n\t * for programs doing set*uid()+execve() by harmlessly deferring the\n\t * failure to the execve() stage.\n\t */\n\tif (atomic_read(&new_user->processes) >= rlimit(RLIMIT_NPROC) &&\n\t\t\tnew_user != INIT_USER)\n\t\tcurrent->flags |= PF_NPROC_EXCEEDED;\n\telse\n\t\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tfree_uid(new->user);\n\tnew->user = new_user;\n\treturn 0;\n}\n\n/*\n * Unprivileged users may change the real uid to the effective uid\n * or vice versa.  (BSD-style)\n *\n * If you set the real uid at all, or set the effective uid to a value not\n * equal to the real uid, then the saved uid is set to the new effective uid.\n *\n * This makes it possible for a setuid program to completely drop its\n * privileges, which is often a useful assertion to make when you are doing\n * a security audit over a program.\n *\n * The general idea is that a program which uses just setreuid() will be\n * 100% compatible with BSD.  A program which uses just setuid() will be\n * 100% compatible with POSIX with saved IDs. \n */\nSYSCALL_DEFINE2(setreuid, uid_t, ruid, uid_t, euid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kruid, keuid;\n\n\tkruid = make_kuid(ns, ruid);\n\tkeuid = make_kuid(ns, euid);\n\n\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))\n\t\treturn -EINVAL;\n\tif ((euid != (uid_t) -1) && !uid_valid(keuid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (ruid != (uid_t) -1) {\n\t\tnew->uid = kruid;\n\t\tif (!uid_eq(old->uid, kruid) &&\n\t\t    !uid_eq(old->euid, kruid) &&\n\t\t    !nsown_capable(CAP_SETUID))\n\t\t\tgoto error;\n\t}\n\n\tif (euid != (uid_t) -1) {\n\t\tnew->euid = keuid;\n\t\tif (!uid_eq(old->uid, keuid) &&\n\t\t    !uid_eq(old->euid, keuid) &&\n\t\t    !uid_eq(old->suid, keuid) &&\n\t\t    !nsown_capable(CAP_SETUID))\n\t\t\tgoto error;\n\t}\n\n\tif (!uid_eq(new->uid, old->uid)) {\n\t\tretval = set_user(new);\n\t\tif (retval < 0)\n\t\t\tgoto error;\n\t}\n\tif (ruid != (uid_t) -1 ||\n\t    (euid != (uid_t) -1 && !uid_eq(keuid, old->uid)))\n\t\tnew->suid = new->euid;\n\tnew->fsuid = new->euid;\n\n\tretval = security_task_fix_setuid(new, old, LSM_SETID_RE);\n\tif (retval < 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\t\t\n/*\n * setuid() is implemented like SysV with SAVED_IDS \n * \n * Note that SAVED_ID's is deficient in that a setuid root program\n * like sendmail, for example, cannot set its uid to be a normal \n * user and then switch back, because if you're root, setuid() sets\n * the saved uid too.  If you don't like this, blame the bright people\n * in the POSIX committee and/or USG.  Note that the BSD-style setreuid()\n * will allow a root program to temporarily drop privileges and be able to\n * regain them by swapping the real and effective uid.  \n */\nSYSCALL_DEFINE1(setuid, uid_t, uid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kuid;\n\n\tkuid = make_kuid(ns, uid);\n\tif (!uid_valid(kuid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (nsown_capable(CAP_SETUID)) {\n\t\tnew->suid = new->uid = kuid;\n\t\tif (!uid_eq(kuid, old->uid)) {\n\t\t\tretval = set_user(new);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t} else if (!uid_eq(kuid, old->uid) && !uid_eq(kuid, new->suid)) {\n\t\tgoto error;\n\t}\n\n\tnew->fsuid = new->euid = kuid;\n\n\tretval = security_task_fix_setuid(new, old, LSM_SETID_ID);\n\tif (retval < 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\n\n/*\n * This function implements a generic ability to update ruid, euid,\n * and suid.  This allows you to implement the 4.4 compatible seteuid().\n */\nSYSCALL_DEFINE3(setresuid, uid_t, ruid, uid_t, euid, uid_t, suid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kruid, keuid, ksuid;\n\n\tkruid = make_kuid(ns, ruid);\n\tkeuid = make_kuid(ns, euid);\n\tksuid = make_kuid(ns, suid);\n\n\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))\n\t\treturn -EINVAL;\n\n\tif ((euid != (uid_t) -1) && !uid_valid(keuid))\n\t\treturn -EINVAL;\n\n\tif ((suid != (uid_t) -1) && !uid_valid(ksuid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (!nsown_capable(CAP_SETUID)) {\n\t\tif (ruid != (uid_t) -1        && !uid_eq(kruid, old->uid) &&\n\t\t    !uid_eq(kruid, old->euid) && !uid_eq(kruid, old->suid))\n\t\t\tgoto error;\n\t\tif (euid != (uid_t) -1        && !uid_eq(keuid, old->uid) &&\n\t\t    !uid_eq(keuid, old->euid) && !uid_eq(keuid, old->suid))\n\t\t\tgoto error;\n\t\tif (suid != (uid_t) -1        && !uid_eq(ksuid, old->uid) &&\n\t\t    !uid_eq(ksuid, old->euid) && !uid_eq(ksuid, old->suid))\n\t\t\tgoto error;\n\t}\n\n\tif (ruid != (uid_t) -1) {\n\t\tnew->uid = kruid;\n\t\tif (!uid_eq(kruid, old->uid)) {\n\t\t\tretval = set_user(new);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (euid != (uid_t) -1)\n\t\tnew->euid = keuid;\n\tif (suid != (uid_t) -1)\n\t\tnew->suid = ksuid;\n\tnew->fsuid = new->euid;\n\n\tretval = security_task_fix_setuid(new, old, LSM_SETID_RES);\n\tif (retval < 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nSYSCALL_DEFINE3(getresuid, uid_t __user *, ruidp, uid_t __user *, euidp, uid_t __user *, suidp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval;\n\tuid_t ruid, euid, suid;\n\n\truid = from_kuid_munged(cred->user_ns, cred->uid);\n\teuid = from_kuid_munged(cred->user_ns, cred->euid);\n\tsuid = from_kuid_munged(cred->user_ns, cred->suid);\n\n\tif (!(retval   = put_user(ruid, ruidp)) &&\n\t    !(retval   = put_user(euid, euidp)))\n\t\tretval = put_user(suid, suidp);\n\n\treturn retval;\n}\n\n/*\n * Same as above, but for rgid, egid, sgid.\n */\nSYSCALL_DEFINE3(setresgid, gid_t, rgid, gid_t, egid, gid_t, sgid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkgid_t krgid, kegid, ksgid;\n\n\tkrgid = make_kgid(ns, rgid);\n\tkegid = make_kgid(ns, egid);\n\tksgid = make_kgid(ns, sgid);\n\n\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))\n\t\treturn -EINVAL;\n\tif ((egid != (gid_t) -1) && !gid_valid(kegid))\n\t\treturn -EINVAL;\n\tif ((sgid != (gid_t) -1) && !gid_valid(ksgid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (!nsown_capable(CAP_SETGID)) {\n\t\tif (rgid != (gid_t) -1        && !gid_eq(krgid, old->gid) &&\n\t\t    !gid_eq(krgid, old->egid) && !gid_eq(krgid, old->sgid))\n\t\t\tgoto error;\n\t\tif (egid != (gid_t) -1        && !gid_eq(kegid, old->gid) &&\n\t\t    !gid_eq(kegid, old->egid) && !gid_eq(kegid, old->sgid))\n\t\t\tgoto error;\n\t\tif (sgid != (gid_t) -1        && !gid_eq(ksgid, old->gid) &&\n\t\t    !gid_eq(ksgid, old->egid) && !gid_eq(ksgid, old->sgid))\n\t\t\tgoto error;\n\t}\n\n\tif (rgid != (gid_t) -1)\n\t\tnew->gid = krgid;\n\tif (egid != (gid_t) -1)\n\t\tnew->egid = kegid;\n\tif (sgid != (gid_t) -1)\n\t\tnew->sgid = ksgid;\n\tnew->fsgid = new->egid;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nSYSCALL_DEFINE3(getresgid, gid_t __user *, rgidp, gid_t __user *, egidp, gid_t __user *, sgidp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval;\n\tgid_t rgid, egid, sgid;\n\n\trgid = from_kgid_munged(cred->user_ns, cred->gid);\n\tegid = from_kgid_munged(cred->user_ns, cred->egid);\n\tsgid = from_kgid_munged(cred->user_ns, cred->sgid);\n\n\tif (!(retval   = put_user(rgid, rgidp)) &&\n\t    !(retval   = put_user(egid, egidp)))\n\t\tretval = put_user(sgid, sgidp);\n\n\treturn retval;\n}\n\n\n/*\n * \"setfsuid()\" sets the fsuid - the uid used for filesystem checks. This\n * is used for \"access()\" and for the NFS daemon (letting nfsd stay at\n * whatever uid it wants to). It normally shadows \"euid\", except when\n * explicitly set by setfsuid() or for access..\n */\nSYSCALL_DEFINE1(setfsuid, uid_t, uid)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tuid_t old_fsuid;\n\tkuid_t kuid;\n\n\told = current_cred();\n\told_fsuid = from_kuid_munged(old->user_ns, old->fsuid);\n\n\tkuid = make_kuid(old->user_ns, uid);\n\tif (!uid_valid(kuid))\n\t\treturn old_fsuid;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn old_fsuid;\n\n\tif (uid_eq(kuid, old->uid)  || uid_eq(kuid, old->euid)  ||\n\t    uid_eq(kuid, old->suid) || uid_eq(kuid, old->fsuid) ||\n\t    nsown_capable(CAP_SETUID)) {\n\t\tif (!uid_eq(kuid, old->fsuid)) {\n\t\t\tnew->fsuid = kuid;\n\t\t\tif (security_task_fix_setuid(new, old, LSM_SETID_FS) == 0)\n\t\t\t\tgoto change_okay;\n\t\t}\n\t}\n\n\tabort_creds(new);\n\treturn old_fsuid;\n\nchange_okay:\n\tcommit_creds(new);\n\treturn old_fsuid;\n}\n\n/*\n * Samma p\u00e5 svenska..\n */\nSYSCALL_DEFINE1(setfsgid, gid_t, gid)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tgid_t old_fsgid;\n\tkgid_t kgid;\n\n\told = current_cred();\n\told_fsgid = from_kgid_munged(old->user_ns, old->fsgid);\n\n\tkgid = make_kgid(old->user_ns, gid);\n\tif (!gid_valid(kgid))\n\t\treturn old_fsgid;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn old_fsgid;\n\n\tif (gid_eq(kgid, old->gid)  || gid_eq(kgid, old->egid)  ||\n\t    gid_eq(kgid, old->sgid) || gid_eq(kgid, old->fsgid) ||\n\t    nsown_capable(CAP_SETGID)) {\n\t\tif (!gid_eq(kgid, old->fsgid)) {\n\t\t\tnew->fsgid = kgid;\n\t\t\tgoto change_okay;\n\t\t}\n\t}\n\n\tabort_creds(new);\n\treturn old_fsgid;\n\nchange_okay:\n\tcommit_creds(new);\n\treturn old_fsgid;\n}\n\nvoid do_sys_times(struct tms *tms)\n{\n\tcputime_t tgutime, tgstime, cutime, cstime;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tthread_group_times(current, &tgutime, &tgstime);\n\tcutime = current->signal->cutime;\n\tcstime = current->signal->cstime;\n\tspin_unlock_irq(&current->sighand->siglock);\n\ttms->tms_utime = cputime_to_clock_t(tgutime);\n\ttms->tms_stime = cputime_to_clock_t(tgstime);\n\ttms->tms_cutime = cputime_to_clock_t(cutime);\n\ttms->tms_cstime = cputime_to_clock_t(cstime);\n}\n\nSYSCALL_DEFINE1(times, struct tms __user *, tbuf)\n{\n\tif (tbuf) {\n\t\tstruct tms tmp;\n\n\t\tdo_sys_times(&tmp);\n\t\tif (copy_to_user(tbuf, &tmp, sizeof(struct tms)))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn (long) jiffies_64_to_clock_t(get_jiffies_64());\n}\n\n/*\n * This needs some heavy checking ...\n * I just haven't the stomach for it. I also don't fully\n * understand sessions/pgrp etc. Let somebody who does explain it.\n *\n * OK, I think I have the protection semantics right.... this is really\n * only important on a multi-user system anyway, to make sure one user\n * can't send a signal to a process owned by another.  -TYT, 12/12/91\n *\n * Auch. Had to add the 'did_exec' flag to conform completely to POSIX.\n * LBT 04.03.94\n */\nSYSCALL_DEFINE2(setpgid, pid_t, pid, pid_t, pgid)\n{\n\tstruct task_struct *p;\n\tstruct task_struct *group_leader = current->group_leader;\n\tstruct pid *pgrp;\n\tint err;\n\n\tif (!pid)\n\t\tpid = task_pid_vnr(group_leader);\n\tif (!pgid)\n\t\tpgid = pid;\n\tif (pgid < 0)\n\t\treturn -EINVAL;\n\trcu_read_lock();\n\n\t/* From this point forward we keep holding onto the tasklist lock\n\t * so that our parent does not change from under us. -DaveM\n\t */\n\twrite_lock_irq(&tasklist_lock);\n\n\terr = -ESRCH;\n\tp = find_task_by_vpid(pid);\n\tif (!p)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (!thread_group_leader(p))\n\t\tgoto out;\n\n\tif (same_thread_group(p->real_parent, group_leader)) {\n\t\terr = -EPERM;\n\t\tif (task_session(p) != task_session(group_leader))\n\t\t\tgoto out;\n\t\terr = -EACCES;\n\t\tif (p->did_exec)\n\t\t\tgoto out;\n\t} else {\n\t\terr = -ESRCH;\n\t\tif (p != group_leader)\n\t\t\tgoto out;\n\t}\n\n\terr = -EPERM;\n\tif (p->signal->leader)\n\t\tgoto out;\n\n\tpgrp = task_pid(p);\n\tif (pgid != pid) {\n\t\tstruct task_struct *g;\n\n\t\tpgrp = find_vpid(pgid);\n\t\tg = pid_task(pgrp, PIDTYPE_PGID);\n\t\tif (!g || task_session(g) != task_session(group_leader))\n\t\t\tgoto out;\n\t}\n\n\terr = security_task_setpgid(p, pgid);\n\tif (err)\n\t\tgoto out;\n\n\tif (task_pgrp(p) != pgrp)\n\t\tchange_pid(p, PIDTYPE_PGID, pgrp);\n\n\terr = 0;\nout:\n\t/* All paths lead to here, thus we are safe. -DaveM */\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\treturn err;\n}\n\nSYSCALL_DEFINE1(getpgid, pid_t, pid)\n{\n\tstruct task_struct *p;\n\tstruct pid *grp;\n\tint retval;\n\n\trcu_read_lock();\n\tif (!pid)\n\t\tgrp = task_pgrp(current);\n\telse {\n\t\tretval = -ESRCH;\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\tgrp = task_pgrp(p);\n\t\tif (!grp)\n\t\t\tgoto out;\n\n\t\tretval = security_task_getpgid(p);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\tretval = pid_vnr(grp);\nout:\n\trcu_read_unlock();\n\treturn retval;\n}\n\n#ifdef __ARCH_WANT_SYS_GETPGRP\n\nSYSCALL_DEFINE0(getpgrp)\n{\n\treturn sys_getpgid(0);\n}\n\n#endif\n\nSYSCALL_DEFINE1(getsid, pid_t, pid)\n{\n\tstruct task_struct *p;\n\tstruct pid *sid;\n\tint retval;\n\n\trcu_read_lock();\n\tif (!pid)\n\t\tsid = task_session(current);\n\telse {\n\t\tretval = -ESRCH;\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\tsid = task_session(p);\n\t\tif (!sid)\n\t\t\tgoto out;\n\n\t\tretval = security_task_getsid(p);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\tretval = pid_vnr(sid);\nout:\n\trcu_read_unlock();\n\treturn retval;\n}\n\nSYSCALL_DEFINE0(setsid)\n{\n\tstruct task_struct *group_leader = current->group_leader;\n\tstruct pid *sid = task_pid(group_leader);\n\tpid_t session = pid_vnr(sid);\n\tint err = -EPERM;\n\n\twrite_lock_irq(&tasklist_lock);\n\t/* Fail if I am already a session leader */\n\tif (group_leader->signal->leader)\n\t\tgoto out;\n\n\t/* Fail if a process group id already exists that equals the\n\t * proposed session id.\n\t */\n\tif (pid_task(sid, PIDTYPE_PGID))\n\t\tgoto out;\n\n\tgroup_leader->signal->leader = 1;\n\t__set_special_pids(sid);\n\n\tproc_clear_tty(group_leader);\n\n\terr = session;\nout:\n\twrite_unlock_irq(&tasklist_lock);\n\tif (err > 0) {\n\t\tproc_sid_connector(group_leader);\n\t\tsched_autogroup_create_attach(group_leader);\n\t}\n\treturn err;\n}\n\nDECLARE_RWSEM(uts_sem);\n\n#ifdef COMPAT_UTS_MACHINE\n#define override_architecture(name) \\\n\t(personality(current->personality) == PER_LINUX32 && \\\n\t copy_to_user(name->machine, COMPAT_UTS_MACHINE, \\\n\t\t      sizeof(COMPAT_UTS_MACHINE)))\n#else\n#define override_architecture(name)\t0\n#endif\n\n/*\n * Work around broken programs that cannot handle \"Linux 3.0\".\n * Instead we map 3.x to 2.6.40+x, so e.g. 3.0 would be 2.6.40\n */\nstatic int override_release(char __user *release, int len)\n{\n\tint ret = 0;\n\tchar buf[65];\n\n\tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n\t\tint ndots = 0;\n\t\tunsigned v;\n\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n\t}\n\treturn ret;\n}\n\nSYSCALL_DEFINE1(newuname, struct new_utsname __user *, name)\n{\n\tint errno = 0;\n\n\tdown_read(&uts_sem);\n\tif (copy_to_user(name, utsname(), sizeof *name))\n\t\terrno = -EFAULT;\n\tup_read(&uts_sem);\n\n\tif (!errno && override_release(name->release, sizeof(name->release)))\n\t\terrno = -EFAULT;\n\tif (!errno && override_architecture(name))\n\t\terrno = -EFAULT;\n\treturn errno;\n}\n\n#ifdef __ARCH_WANT_SYS_OLD_UNAME\n/*\n * Old cruft\n */\nSYSCALL_DEFINE1(uname, struct old_utsname __user *, name)\n{\n\tint error = 0;\n\n\tif (!name)\n\t\treturn -EFAULT;\n\n\tdown_read(&uts_sem);\n\tif (copy_to_user(name, utsname(), sizeof(*name)))\n\t\terror = -EFAULT;\n\tup_read(&uts_sem);\n\n\tif (!error && override_release(name->release, sizeof(name->release)))\n\t\terror = -EFAULT;\n\tif (!error && override_architecture(name))\n\t\terror = -EFAULT;\n\treturn error;\n}\n\nSYSCALL_DEFINE1(olduname, struct oldold_utsname __user *, name)\n{\n\tint error;\n\n\tif (!name)\n\t\treturn -EFAULT;\n\tif (!access_ok(VERIFY_WRITE, name, sizeof(struct oldold_utsname)))\n\t\treturn -EFAULT;\n\n\tdown_read(&uts_sem);\n\terror = __copy_to_user(&name->sysname, &utsname()->sysname,\n\t\t\t       __OLD_UTS_LEN);\n\terror |= __put_user(0, name->sysname + __OLD_UTS_LEN);\n\terror |= __copy_to_user(&name->nodename, &utsname()->nodename,\n\t\t\t\t__OLD_UTS_LEN);\n\terror |= __put_user(0, name->nodename + __OLD_UTS_LEN);\n\terror |= __copy_to_user(&name->release, &utsname()->release,\n\t\t\t\t__OLD_UTS_LEN);\n\terror |= __put_user(0, name->release + __OLD_UTS_LEN);\n\terror |= __copy_to_user(&name->version, &utsname()->version,\n\t\t\t\t__OLD_UTS_LEN);\n\terror |= __put_user(0, name->version + __OLD_UTS_LEN);\n\terror |= __copy_to_user(&name->machine, &utsname()->machine,\n\t\t\t\t__OLD_UTS_LEN);\n\terror |= __put_user(0, name->machine + __OLD_UTS_LEN);\n\tup_read(&uts_sem);\n\n\tif (!error && override_architecture(name))\n\t\terror = -EFAULT;\n\tif (!error && override_release(name->release, sizeof(name->release)))\n\t\terror = -EFAULT;\n\treturn error ? -EFAULT : 0;\n}\n#endif\n\nSYSCALL_DEFINE2(sethostname, char __user *, name, int, len)\n{\n\tint errno;\n\tchar tmp[__NEW_UTS_LEN];\n\n\tif (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (len < 0 || len > __NEW_UTS_LEN)\n\t\treturn -EINVAL;\n\tdown_write(&uts_sem);\n\terrno = -EFAULT;\n\tif (!copy_from_user(tmp, name, len)) {\n\t\tstruct new_utsname *u = utsname();\n\n\t\tmemcpy(u->nodename, tmp, len);\n\t\tmemset(u->nodename + len, 0, sizeof(u->nodename) - len);\n\t\terrno = 0;\n\t\tuts_proc_notify(UTS_PROC_HOSTNAME);\n\t}\n\tup_write(&uts_sem);\n\treturn errno;\n}\n\n#ifdef __ARCH_WANT_SYS_GETHOSTNAME\n\nSYSCALL_DEFINE2(gethostname, char __user *, name, int, len)\n{\n\tint i, errno;\n\tstruct new_utsname *u;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tdown_read(&uts_sem);\n\tu = utsname();\n\ti = 1 + strlen(u->nodename);\n\tif (i > len)\n\t\ti = len;\n\terrno = 0;\n\tif (copy_to_user(name, u->nodename, i))\n\t\terrno = -EFAULT;\n\tup_read(&uts_sem);\n\treturn errno;\n}\n\n#endif\n\n/*\n * Only setdomainname; getdomainname can be implemented by calling\n * uname()\n */\nSYSCALL_DEFINE2(setdomainname, char __user *, name, int, len)\n{\n\tint errno;\n\tchar tmp[__NEW_UTS_LEN];\n\n\tif (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (len < 0 || len > __NEW_UTS_LEN)\n\t\treturn -EINVAL;\n\n\tdown_write(&uts_sem);\n\terrno = -EFAULT;\n\tif (!copy_from_user(tmp, name, len)) {\n\t\tstruct new_utsname *u = utsname();\n\n\t\tmemcpy(u->domainname, tmp, len);\n\t\tmemset(u->domainname + len, 0, sizeof(u->domainname) - len);\n\t\terrno = 0;\n\t\tuts_proc_notify(UTS_PROC_DOMAINNAME);\n\t}\n\tup_write(&uts_sem);\n\treturn errno;\n}\n\nSYSCALL_DEFINE2(getrlimit, unsigned int, resource, struct rlimit __user *, rlim)\n{\n\tstruct rlimit value;\n\tint ret;\n\n\tret = do_prlimit(current, resource, NULL, &value);\n\tif (!ret)\n\t\tret = copy_to_user(rlim, &value, sizeof(*rlim)) ? -EFAULT : 0;\n\n\treturn ret;\n}\n\n#ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT\n\n/*\n *\tBack compatibility for getrlimit. Needed for some apps.\n */\n \nSYSCALL_DEFINE2(old_getrlimit, unsigned int, resource,\n\t\tstruct rlimit __user *, rlim)\n{\n\tstruct rlimit x;\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\n\ttask_lock(current->group_leader);\n\tx = current->signal->rlim[resource];\n\ttask_unlock(current->group_leader);\n\tif (x.rlim_cur > 0x7FFFFFFF)\n\t\tx.rlim_cur = 0x7FFFFFFF;\n\tif (x.rlim_max > 0x7FFFFFFF)\n\t\tx.rlim_max = 0x7FFFFFFF;\n\treturn copy_to_user(rlim, &x, sizeof(x))?-EFAULT:0;\n}\n\n#endif\n\nstatic inline bool rlim64_is_infinity(__u64 rlim64)\n{\n#if BITS_PER_LONG < 64\n\treturn rlim64 >= ULONG_MAX;\n#else\n\treturn rlim64 == RLIM64_INFINITY;\n#endif\n}\n\nstatic void rlim_to_rlim64(const struct rlimit *rlim, struct rlimit64 *rlim64)\n{\n\tif (rlim->rlim_cur == RLIM_INFINITY)\n\t\trlim64->rlim_cur = RLIM64_INFINITY;\n\telse\n\t\trlim64->rlim_cur = rlim->rlim_cur;\n\tif (rlim->rlim_max == RLIM_INFINITY)\n\t\trlim64->rlim_max = RLIM64_INFINITY;\n\telse\n\t\trlim64->rlim_max = rlim->rlim_max;\n}\n\nstatic void rlim64_to_rlim(const struct rlimit64 *rlim64, struct rlimit *rlim)\n{\n\tif (rlim64_is_infinity(rlim64->rlim_cur))\n\t\trlim->rlim_cur = RLIM_INFINITY;\n\telse\n\t\trlim->rlim_cur = (unsigned long)rlim64->rlim_cur;\n\tif (rlim64_is_infinity(rlim64->rlim_max))\n\t\trlim->rlim_max = RLIM_INFINITY;\n\telse\n\t\trlim->rlim_max = (unsigned long)rlim64->rlim_max;\n}\n\n/* make sure you are allowed to change @tsk limits before calling this */\nint do_prlimit(struct task_struct *tsk, unsigned int resource,\n\t\tstruct rlimit *new_rlim, struct rlimit *old_rlim)\n{\n\tstruct rlimit *rlim;\n\tint retval = 0;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)\n\t\t\treturn -EINVAL;\n\t\tif (resource == RLIMIT_NOFILE &&\n\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* protect tsk->signal and tsk->sighand from disappearing */\n\tread_lock(&tasklist_lock);\n\tif (!tsk->sighand) {\n\t\tretval = -ESRCH;\n\t\tgoto out;\n\t}\n\n\trlim = tsk->signal->rlim + resource;\n\ttask_lock(tsk->group_leader);\n\tif (new_rlim) {\n\t\t/* Keep the capable check against init_user_ns until\n\t\t   cgroups can contain all limits */\n\t\tif (new_rlim->rlim_max > rlim->rlim_max &&\n\t\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\t\tretval = -EPERM;\n\t\tif (!retval)\n\t\t\tretval = security_task_setrlimit(tsk->group_leader,\n\t\t\t\t\tresource, new_rlim);\n\t\tif (resource == RLIMIT_CPU && new_rlim->rlim_cur == 0) {\n\t\t\t/*\n\t\t\t * The caller is asking for an immediate RLIMIT_CPU\n\t\t\t * expiry.  But we use the zero value to mean \"it was\n\t\t\t * never set\".  So let's cheat and make it one second\n\t\t\t * instead\n\t\t\t */\n\t\t\tnew_rlim->rlim_cur = 1;\n\t\t}\n\t}\n\tif (!retval) {\n\t\tif (old_rlim)\n\t\t\t*old_rlim = *rlim;\n\t\tif (new_rlim)\n\t\t\t*rlim = *new_rlim;\n\t}\n\ttask_unlock(tsk->group_leader);\n\n\t/*\n\t * RLIMIT_CPU handling.   Note that the kernel fails to return an error\n\t * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a\n\t * very long-standing error, and fixing it now risks breakage of\n\t * applications, so we live with it\n\t */\n\t if (!retval && new_rlim && resource == RLIMIT_CPU &&\n\t\t\t new_rlim->rlim_cur != RLIM_INFINITY)\n\t\tupdate_rlimit_cpu(tsk, new_rlim->rlim_cur);\nout:\n\tread_unlock(&tasklist_lock);\n\treturn retval;\n}\n\n/* rcu lock must be held */\nstatic int check_prlimit_permission(struct task_struct *task)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\n\tif (current == task)\n\t\treturn 0;\n\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\treturn 0;\n\tif (ns_capable(tcred->user_ns, CAP_SYS_RESOURCE))\n\t\treturn 0;\n\n\treturn -EPERM;\n}\n\nSYSCALL_DEFINE4(prlimit64, pid_t, pid, unsigned int, resource,\n\t\tconst struct rlimit64 __user *, new_rlim,\n\t\tstruct rlimit64 __user *, old_rlim)\n{\n\tstruct rlimit64 old64, new64;\n\tstruct rlimit old, new;\n\tstruct task_struct *tsk;\n\tint ret;\n\n\tif (new_rlim) {\n\t\tif (copy_from_user(&new64, new_rlim, sizeof(new64)))\n\t\t\treturn -EFAULT;\n\t\trlim64_to_rlim(&new64, &new);\n\t}\n\n\trcu_read_lock();\n\ttsk = pid ? find_task_by_vpid(pid) : current;\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tret = check_prlimit_permission(tsk);\n\tif (ret) {\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\tget_task_struct(tsk);\n\trcu_read_unlock();\n\n\tret = do_prlimit(tsk, resource, new_rlim ? &new : NULL,\n\t\t\told_rlim ? &old : NULL);\n\n\tif (!ret && old_rlim) {\n\t\trlim_to_rlim64(&old, &old64);\n\t\tif (copy_to_user(old_rlim, &old64, sizeof(old64)))\n\t\t\tret = -EFAULT;\n\t}\n\n\tput_task_struct(tsk);\n\treturn ret;\n}\n\nSYSCALL_DEFINE2(setrlimit, unsigned int, resource, struct rlimit __user *, rlim)\n{\n\tstruct rlimit new_rlim;\n\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\treturn do_prlimit(current, resource, &new_rlim, NULL);\n}\n\n/*\n * It would make sense to put struct rusage in the task_struct,\n * except that would make the task_struct be *really big*.  After\n * task_struct gets moved into malloc'ed memory, it would\n * make sense to do this.  It will make moving the rest of the information\n * a lot simpler!  (Which we're not doing right now because we're not\n * measuring them yet).\n *\n * When sampling multiple threads for RUSAGE_SELF, under SMP we might have\n * races with threads incrementing their own counters.  But since word\n * reads are atomic, we either get new values or old values and we don't\n * care which for the sums.  We always take the siglock to protect reading\n * the c* fields from p->signal from races with exit.c updating those\n * fields when reaping, so a sample either gets all the additions of a\n * given child after it's reaped, or none so this sample is before reaping.\n *\n * Locking:\n * We need to take the siglock for CHILDEREN, SELF and BOTH\n * for  the cases current multithreaded, non-current single threaded\n * non-current multithreaded.  Thread traversal is now safe with\n * the siglock held.\n * Strictly speaking, we donot need to take the siglock if we are current and\n * single threaded,  as no one else can take our signal_struct away, no one\n * else can  reap the  children to update signal->c* counters, and no one else\n * can race with the signal-> fields. If we do not take any lock, the\n * signal-> fields could be read out of order while another thread was just\n * exiting. So we should  place a read memory barrier when we avoid the lock.\n * On the writer side,  write memory barrier is implied in  __exit_signal\n * as __exit_signal releases  the siglock spinlock after updating the signal->\n * fields. But we don't do this yet to keep things simple.\n *\n */\n\nstatic void accumulate_thread_rusage(struct task_struct *t, struct rusage *r)\n{\n\tr->ru_nvcsw += t->nvcsw;\n\tr->ru_nivcsw += t->nivcsw;\n\tr->ru_minflt += t->min_flt;\n\tr->ru_majflt += t->maj_flt;\n\tr->ru_inblock += task_io_get_inblock(t);\n\tr->ru_oublock += task_io_get_oublock(t);\n}\n\nstatic void k_getrusage(struct task_struct *p, int who, struct rusage *r)\n{\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tcputime_t tgutime, tgstime, utime, stime;\n\tunsigned long maxrss = 0;\n\n\tmemset((char *) r, 0, sizeof *r);\n\tutime = stime = 0;\n\n\tif (who == RUSAGE_THREAD) {\n\t\ttask_times(current, &utime, &stime);\n\t\taccumulate_thread_rusage(p, r);\n\t\tmaxrss = p->signal->maxrss;\n\t\tgoto out;\n\t}\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn;\n\n\tswitch (who) {\n\t\tcase RUSAGE_BOTH:\n\t\tcase RUSAGE_CHILDREN:\n\t\t\tutime = p->signal->cutime;\n\t\t\tstime = p->signal->cstime;\n\t\t\tr->ru_nvcsw = p->signal->cnvcsw;\n\t\t\tr->ru_nivcsw = p->signal->cnivcsw;\n\t\t\tr->ru_minflt = p->signal->cmin_flt;\n\t\t\tr->ru_majflt = p->signal->cmaj_flt;\n\t\t\tr->ru_inblock = p->signal->cinblock;\n\t\t\tr->ru_oublock = p->signal->coublock;\n\t\t\tmaxrss = p->signal->cmaxrss;\n\n\t\t\tif (who == RUSAGE_CHILDREN)\n\t\t\t\tbreak;\n\n\t\tcase RUSAGE_SELF:\n\t\t\tthread_group_times(p, &tgutime, &tgstime);\n\t\t\tutime += tgutime;\n\t\t\tstime += tgstime;\n\t\t\tr->ru_nvcsw += p->signal->nvcsw;\n\t\t\tr->ru_nivcsw += p->signal->nivcsw;\n\t\t\tr->ru_minflt += p->signal->min_flt;\n\t\t\tr->ru_majflt += p->signal->maj_flt;\n\t\t\tr->ru_inblock += p->signal->inblock;\n\t\t\tr->ru_oublock += p->signal->oublock;\n\t\t\tif (maxrss < p->signal->maxrss)\n\t\t\t\tmaxrss = p->signal->maxrss;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\taccumulate_thread_rusage(t, r);\n\t\t\t\tt = next_thread(t);\n\t\t\t} while (t != p);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\tunlock_task_sighand(p, &flags);\n\nout:\n\tcputime_to_timeval(utime, &r->ru_utime);\n\tcputime_to_timeval(stime, &r->ru_stime);\n\n\tif (who != RUSAGE_CHILDREN) {\n\t\tstruct mm_struct *mm = get_task_mm(p);\n\t\tif (mm) {\n\t\t\tsetmax_mm_hiwater_rss(&maxrss, mm);\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\tr->ru_maxrss = maxrss * (PAGE_SIZE / 1024); /* convert pages to KBs */\n}\n\nint getrusage(struct task_struct *p, int who, struct rusage __user *ru)\n{\n\tstruct rusage r;\n\tk_getrusage(p, who, &r);\n\treturn copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;\n}\n\nSYSCALL_DEFINE2(getrusage, int, who, struct rusage __user *, ru)\n{\n\tif (who != RUSAGE_SELF && who != RUSAGE_CHILDREN &&\n\t    who != RUSAGE_THREAD)\n\t\treturn -EINVAL;\n\treturn getrusage(current, who, ru);\n}\n\nSYSCALL_DEFINE1(umask, int, mask)\n{\n\tmask = xchg(&current->fs->umask, mask & S_IRWXUGO);\n\treturn mask;\n}\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstatic int prctl_set_mm_exe_file(struct mm_struct *mm, unsigned int fd)\n{\n\tstruct fd exe;\n\tstruct dentry *dentry;\n\tint err;\n\n\texe = fdget(fd);\n\tif (!exe.file)\n\t\treturn -EBADF;\n\n\tdentry = exe.file->f_path.dentry;\n\n\t/*\n\t * Because the original mm->exe_file points to executable file, make\n\t * sure that this one is executable as well, to avoid breaking an\n\t * overall picture.\n\t */\n\terr = -EACCES;\n\tif (!S_ISREG(dentry->d_inode->i_mode)\t||\n\t    exe.file->f_path.mnt->mnt_flags & MNT_NOEXEC)\n\t\tgoto exit;\n\n\terr = inode_permission(dentry->d_inode, MAY_EXEC);\n\tif (err)\n\t\tgoto exit;\n\n\tdown_write(&mm->mmap_sem);\n\n\t/*\n\t * Forbid mm->exe_file change if old file still mapped.\n\t */\n\terr = -EBUSY;\n\tif (mm->exe_file) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_file &&\n\t\t\t    path_equal(&vma->vm_file->f_path,\n\t\t\t\t       &mm->exe_file->f_path))\n\t\t\t\tgoto exit_unlock;\n\t}\n\n\t/*\n\t * The symlink can be changed only once, just to disallow arbitrary\n\t * transitions malicious software might bring in. This means one\n\t * could make a snapshot over all processes running and monitor\n\t * /proc/pid/exe changes to notice unusual activity if needed.\n\t */\n\terr = -EPERM;\n\tif (test_and_set_bit(MMF_EXE_FILE_CHANGED, &mm->flags))\n\t\tgoto exit_unlock;\n\n\terr = 0;\n\tset_mm_exe_file(mm, exe.file);\t/* this grabs a reference to exe.file */\nexit_unlock:\n\tup_write(&mm->mmap_sem);\n\nexit:\n\tfdput(exe);\n\treturn err;\n}\n\nstatic int prctl_set_mm(int opt, unsigned long addr,\n\t\t\tunsigned long arg4, unsigned long arg5)\n{\n\tunsigned long rlim = rlimit(RLIMIT_DATA);\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tint error;\n\n\tif (arg5 || (arg4 && opt != PR_SET_MM_AUXV))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\tif (opt == PR_SET_MM_EXE_FILE)\n\t\treturn prctl_set_mm_exe_file(mm, (unsigned int)addr);\n\n\tif (addr >= TASK_SIZE || addr < mmap_min_addr)\n\t\treturn -EINVAL;\n\n\terror = -EINVAL;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, addr);\n\n\tswitch (opt) {\n\tcase PR_SET_MM_START_CODE:\n\t\tmm->start_code = addr;\n\t\tbreak;\n\tcase PR_SET_MM_END_CODE:\n\t\tmm->end_code = addr;\n\t\tbreak;\n\tcase PR_SET_MM_START_DATA:\n\t\tmm->start_data = addr;\n\t\tbreak;\n\tcase PR_SET_MM_END_DATA:\n\t\tmm->end_data = addr;\n\t\tbreak;\n\n\tcase PR_SET_MM_START_BRK:\n\t\tif (addr <= mm->end_data)\n\t\t\tgoto out;\n\n\t\tif (rlim < RLIM_INFINITY &&\n\t\t    (mm->brk - addr) +\n\t\t    (mm->end_data - mm->start_data) > rlim)\n\t\t\tgoto out;\n\n\t\tmm->start_brk = addr;\n\t\tbreak;\n\n\tcase PR_SET_MM_BRK:\n\t\tif (addr <= mm->end_data)\n\t\t\tgoto out;\n\n\t\tif (rlim < RLIM_INFINITY &&\n\t\t    (addr - mm->start_brk) +\n\t\t    (mm->end_data - mm->start_data) > rlim)\n\t\t\tgoto out;\n\n\t\tmm->brk = addr;\n\t\tbreak;\n\n\t/*\n\t * If command line arguments and environment\n\t * are placed somewhere else on stack, we can\n\t * set them up here, ARG_START/END to setup\n\t * command line argumets and ENV_START/END\n\t * for environment.\n\t */\n\tcase PR_SET_MM_START_STACK:\n\tcase PR_SET_MM_ARG_START:\n\tcase PR_SET_MM_ARG_END:\n\tcase PR_SET_MM_ENV_START:\n\tcase PR_SET_MM_ENV_END:\n\t\tif (!vma) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (opt == PR_SET_MM_START_STACK)\n\t\t\tmm->start_stack = addr;\n\t\telse if (opt == PR_SET_MM_ARG_START)\n\t\t\tmm->arg_start = addr;\n\t\telse if (opt == PR_SET_MM_ARG_END)\n\t\t\tmm->arg_end = addr;\n\t\telse if (opt == PR_SET_MM_ENV_START)\n\t\t\tmm->env_start = addr;\n\t\telse if (opt == PR_SET_MM_ENV_END)\n\t\t\tmm->env_end = addr;\n\t\tbreak;\n\n\t/*\n\t * This doesn't move auxiliary vector itself\n\t * since it's pinned to mm_struct, but allow\n\t * to fill vector with new values. It's up\n\t * to a caller to provide sane values here\n\t * otherwise user space tools which use this\n\t * vector might be unhappy.\n\t */\n\tcase PR_SET_MM_AUXV: {\n\t\tunsigned long user_auxv[AT_VECTOR_SIZE];\n\n\t\tif (arg4 > sizeof(user_auxv))\n\t\t\tgoto out;\n\t\tup_read(&mm->mmap_sem);\n\n\t\tif (copy_from_user(user_auxv, (const void __user *)addr, arg4))\n\t\t\treturn -EFAULT;\n\n\t\t/* Make sure the last entry is always AT_NULL */\n\t\tuser_auxv[AT_VECTOR_SIZE - 2] = 0;\n\t\tuser_auxv[AT_VECTOR_SIZE - 1] = 0;\n\n\t\tBUILD_BUG_ON(sizeof(user_auxv) != sizeof(mm->saved_auxv));\n\n\t\ttask_lock(current);\n\t\tmemcpy(mm->saved_auxv, user_auxv, arg4);\n\t\ttask_unlock(current);\n\n\t\treturn 0;\n\t}\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terror = 0;\nout:\n\tup_read(&mm->mmap_sem);\n\treturn error;\n}\n\nstatic int prctl_get_tid_address(struct task_struct *me, int __user **tid_addr)\n{\n\treturn put_user(me->clear_child_tid, tid_addr);\n}\n\n#else /* CONFIG_CHECKPOINT_RESTORE */\nstatic int prctl_set_mm(int opt, unsigned long addr,\n\t\t\tunsigned long arg4, unsigned long arg5)\n{\n\treturn -EINVAL;\n}\nstatic int prctl_get_tid_address(struct task_struct *me, int __user **tid_addr)\n{\n\treturn -EINVAL;\n}\n#endif\n\nSYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,\n\t\tunsigned long, arg4, unsigned long, arg5)\n{\n\tstruct task_struct *me = current;\n\tunsigned char comm[sizeof(me->comm)];\n\tlong error;\n\n\terror = security_task_prctl(option, arg2, arg3, arg4, arg5);\n\tif (error != -ENOSYS)\n\t\treturn error;\n\n\terror = 0;\n\tswitch (option) {\n\t\tcase PR_SET_PDEATHSIG:\n\t\t\tif (!valid_signal(arg2)) {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tme->pdeath_signal = arg2;\n\t\t\tbreak;\n\t\tcase PR_GET_PDEATHSIG:\n\t\t\terror = put_user(me->pdeath_signal, (int __user *)arg2);\n\t\t\tbreak;\n\t\tcase PR_GET_DUMPABLE:\n\t\t\terror = get_dumpable(me->mm);\n\t\t\tbreak;\n\t\tcase PR_SET_DUMPABLE:\n\t\t\tif (arg2 < 0 || arg2 > 1) {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_dumpable(me->mm, arg2);\n\t\t\tbreak;\n\n\t\tcase PR_SET_UNALIGN:\n\t\t\terror = SET_UNALIGN_CTL(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_GET_UNALIGN:\n\t\t\terror = GET_UNALIGN_CTL(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_SET_FPEMU:\n\t\t\terror = SET_FPEMU_CTL(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_GET_FPEMU:\n\t\t\terror = GET_FPEMU_CTL(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_SET_FPEXC:\n\t\t\terror = SET_FPEXC_CTL(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_GET_FPEXC:\n\t\t\terror = GET_FPEXC_CTL(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_GET_TIMING:\n\t\t\terror = PR_TIMING_STATISTICAL;\n\t\t\tbreak;\n\t\tcase PR_SET_TIMING:\n\t\t\tif (arg2 != PR_TIMING_STATISTICAL)\n\t\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\tcase PR_SET_NAME:\n\t\t\tcomm[sizeof(me->comm)-1] = 0;\n\t\t\tif (strncpy_from_user(comm, (char __user *)arg2,\n\t\t\t\t\t      sizeof(me->comm) - 1) < 0)\n\t\t\t\treturn -EFAULT;\n\t\t\tset_task_comm(me, comm);\n\t\t\tproc_comm_connector(me);\n\t\t\tbreak;\n\t\tcase PR_GET_NAME:\n\t\t\tget_task_comm(comm, me);\n\t\t\tif (copy_to_user((char __user *)arg2, comm,\n\t\t\t\t\t sizeof(comm)))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\t\tcase PR_GET_ENDIAN:\n\t\t\terror = GET_ENDIAN(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_SET_ENDIAN:\n\t\t\terror = SET_ENDIAN(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_GET_SECCOMP:\n\t\t\terror = prctl_get_seccomp();\n\t\t\tbreak;\n\t\tcase PR_SET_SECCOMP:\n\t\t\terror = prctl_set_seccomp(arg2, (char __user *)arg3);\n\t\t\tbreak;\n\t\tcase PR_GET_TSC:\n\t\t\terror = GET_TSC_CTL(arg2);\n\t\t\tbreak;\n\t\tcase PR_SET_TSC:\n\t\t\terror = SET_TSC_CTL(arg2);\n\t\t\tbreak;\n\t\tcase PR_TASK_PERF_EVENTS_DISABLE:\n\t\t\terror = perf_event_task_disable();\n\t\t\tbreak;\n\t\tcase PR_TASK_PERF_EVENTS_ENABLE:\n\t\t\terror = perf_event_task_enable();\n\t\t\tbreak;\n\t\tcase PR_GET_TIMERSLACK:\n\t\t\terror = current->timer_slack_ns;\n\t\t\tbreak;\n\t\tcase PR_SET_TIMERSLACK:\n\t\t\tif (arg2 <= 0)\n\t\t\t\tcurrent->timer_slack_ns =\n\t\t\t\t\tcurrent->default_timer_slack_ns;\n\t\t\telse\n\t\t\t\tcurrent->timer_slack_ns = arg2;\n\t\t\tbreak;\n\t\tcase PR_MCE_KILL:\n\t\t\tif (arg4 | arg5)\n\t\t\t\treturn -EINVAL;\n\t\t\tswitch (arg2) {\n\t\t\tcase PR_MCE_KILL_CLEAR:\n\t\t\t\tif (arg3 != 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tcurrent->flags &= ~PF_MCE_PROCESS;\n\t\t\t\tbreak;\n\t\t\tcase PR_MCE_KILL_SET:\n\t\t\t\tcurrent->flags |= PF_MCE_PROCESS;\n\t\t\t\tif (arg3 == PR_MCE_KILL_EARLY)\n\t\t\t\t\tcurrent->flags |= PF_MCE_EARLY;\n\t\t\t\telse if (arg3 == PR_MCE_KILL_LATE)\n\t\t\t\t\tcurrent->flags &= ~PF_MCE_EARLY;\n\t\t\t\telse if (arg3 == PR_MCE_KILL_DEFAULT)\n\t\t\t\t\tcurrent->flags &=\n\t\t\t\t\t\t~(PF_MCE_EARLY|PF_MCE_PROCESS);\n\t\t\t\telse\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PR_MCE_KILL_GET:\n\t\t\tif (arg2 | arg3 | arg4 | arg5)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (current->flags & PF_MCE_PROCESS)\n\t\t\t\terror = (current->flags & PF_MCE_EARLY) ?\n\t\t\t\t\tPR_MCE_KILL_EARLY : PR_MCE_KILL_LATE;\n\t\t\telse\n\t\t\t\terror = PR_MCE_KILL_DEFAULT;\n\t\t\tbreak;\n\t\tcase PR_SET_MM:\n\t\t\terror = prctl_set_mm(arg2, arg3, arg4, arg5);\n\t\t\tbreak;\n\t\tcase PR_GET_TID_ADDRESS:\n\t\t\terror = prctl_get_tid_address(me, (int __user **)arg2);\n\t\t\tbreak;\n\t\tcase PR_SET_CHILD_SUBREAPER:\n\t\t\tme->signal->is_child_subreaper = !!arg2;\n\t\t\tbreak;\n\t\tcase PR_GET_CHILD_SUBREAPER:\n\t\t\terror = put_user(me->signal->is_child_subreaper,\n\t\t\t\t\t (int __user *) arg2);\n\t\t\tbreak;\n\t\tcase PR_SET_NO_NEW_PRIVS:\n\t\t\tif (arg2 != 1 || arg3 || arg4 || arg5)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcurrent->no_new_privs = 1;\n\t\t\tbreak;\n\t\tcase PR_GET_NO_NEW_PRIVS:\n\t\t\tif (arg2 || arg3 || arg4 || arg5)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn current->no_new_privs ? 1 : 0;\n\t\tdefault:\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE3(getcpu, unsigned __user *, cpup, unsigned __user *, nodep,\n\t\tstruct getcpu_cache __user *, unused)\n{\n\tint err = 0;\n\tint cpu = raw_smp_processor_id();\n\tif (cpup)\n\t\terr |= put_user(cpu, cpup);\n\tif (nodep)\n\t\terr |= put_user(cpu_to_node(cpu), nodep);\n\treturn err ? -EFAULT : 0;\n}\n\nchar poweroff_cmd[POWEROFF_CMD_PATH_LEN] = \"/sbin/poweroff\";\n\nstatic void argv_cleanup(struct subprocess_info *info)\n{\n\targv_free(info->argv);\n}\n\nstatic int __orderly_poweroff(void)\n{\n\tint argc;\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tNULL\n\t};\n\tint ret;\n\n\targv = argv_split(GFP_ATOMIC, poweroff_cmd, &argc);\n\tif (argv == NULL) {\n\t\tprintk(KERN_WARNING \"%s failed to allocate memory for \\\"%s\\\"\\n\",\n\t\t       __func__, poweroff_cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = call_usermodehelper_fns(argv[0], argv, envp, UMH_WAIT_EXEC,\n\t\t\t\t      NULL, argv_cleanup, NULL);\n\tif (ret == -ENOMEM)\n\t\targv_free(argv);\n\n\treturn ret;\n}\n\n/**\n * orderly_poweroff - Trigger an orderly system poweroff\n * @force: force poweroff if command execution fails\n *\n * This may be called from any context to trigger a system shutdown.\n * If the orderly shutdown fails, it will force an immediate shutdown.\n */\nint orderly_poweroff(bool force)\n{\n\tint ret = __orderly_poweroff();\n\n\tif (ret && force) {\n\t\tprintk(KERN_WARNING \"Failed to start orderly shutdown: \"\n\t\t       \"forcing the issue\\n\");\n\n\t\t/*\n\t\t * I guess this should try to kick off some daemon to sync and\n\t\t * poweroff asap.  Or not even bother syncing if we're doing an\n\t\t * emergency shutdown?\n\t\t */\n\t\temergency_sync();\n\t\tkernel_power_off();\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(orderly_poweroff);\n"], "fixing_code": ["/*\n *  linux/kernel/sys.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/utsname.h>\n#include <linux/mman.h>\n#include <linux/reboot.h>\n#include <linux/prctl.h>\n#include <linux/highuid.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/perf_event.h>\n#include <linux/resource.h>\n#include <linux/kernel.h>\n#include <linux/kexec.h>\n#include <linux/workqueue.h>\n#include <linux/capability.h>\n#include <linux/device.h>\n#include <linux/key.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/security.h>\n#include <linux/dcookies.h>\n#include <linux/suspend.h>\n#include <linux/tty.h>\n#include <linux/signal.h>\n#include <linux/cn_proc.h>\n#include <linux/getcpu.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/seccomp.h>\n#include <linux/cpu.h>\n#include <linux/personality.h>\n#include <linux/ptrace.h>\n#include <linux/fs_struct.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/syscore_ops.h>\n#include <linux/version.h>\n#include <linux/ctype.h>\n\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/user_namespace.h>\n\n#include <linux/kmsg_dump.h>\n/* Move somewhere else to avoid recompiling? */\n#include <generated/utsrelease.h>\n\n#include <asm/uaccess.h>\n#include <asm/io.h>\n#include <asm/unistd.h>\n\n#ifndef SET_UNALIGN_CTL\n# define SET_UNALIGN_CTL(a,b)\t(-EINVAL)\n#endif\n#ifndef GET_UNALIGN_CTL\n# define GET_UNALIGN_CTL(a,b)\t(-EINVAL)\n#endif\n#ifndef SET_FPEMU_CTL\n# define SET_FPEMU_CTL(a,b)\t(-EINVAL)\n#endif\n#ifndef GET_FPEMU_CTL\n# define GET_FPEMU_CTL(a,b)\t(-EINVAL)\n#endif\n#ifndef SET_FPEXC_CTL\n# define SET_FPEXC_CTL(a,b)\t(-EINVAL)\n#endif\n#ifndef GET_FPEXC_CTL\n# define GET_FPEXC_CTL(a,b)\t(-EINVAL)\n#endif\n#ifndef GET_ENDIAN\n# define GET_ENDIAN(a,b)\t(-EINVAL)\n#endif\n#ifndef SET_ENDIAN\n# define SET_ENDIAN(a,b)\t(-EINVAL)\n#endif\n#ifndef GET_TSC_CTL\n# define GET_TSC_CTL(a)\t\t(-EINVAL)\n#endif\n#ifndef SET_TSC_CTL\n# define SET_TSC_CTL(a)\t\t(-EINVAL)\n#endif\n\n/*\n * this is where the system-wide overflow UID and GID are defined, for\n * architectures that now have 32-bit UID/GID but didn't in the past\n */\n\nint overflowuid = DEFAULT_OVERFLOWUID;\nint overflowgid = DEFAULT_OVERFLOWGID;\n\nEXPORT_SYMBOL(overflowuid);\nEXPORT_SYMBOL(overflowgid);\n\n/*\n * the same as above, but for filesystems which can only store a 16-bit\n * UID and GID. as such, this is needed on all architectures\n */\n\nint fs_overflowuid = DEFAULT_FS_OVERFLOWUID;\nint fs_overflowgid = DEFAULT_FS_OVERFLOWUID;\n\nEXPORT_SYMBOL(fs_overflowuid);\nEXPORT_SYMBOL(fs_overflowgid);\n\n/*\n * this indicates whether you can reboot with ctrl-alt-del: the default is yes\n */\n\nint C_A_D = 1;\nstruct pid *cad_pid;\nEXPORT_SYMBOL(cad_pid);\n\n/*\n * If set, this is used for preparing the system to power off.\n */\n\nvoid (*pm_power_off_prepare)(void);\n\n/*\n * Returns true if current's euid is same as p's uid or euid,\n * or has CAP_SYS_NICE to p's user_ns.\n *\n * Called with rcu_read_lock, creds are safe\n */\nstatic bool set_one_prio_perm(struct task_struct *p)\n{\n\tconst struct cred *cred = current_cred(), *pcred = __task_cred(p);\n\n\tif (uid_eq(pcred->uid,  cred->euid) ||\n\t    uid_eq(pcred->euid, cred->euid))\n\t\treturn true;\n\tif (ns_capable(pcred->user_ns, CAP_SYS_NICE))\n\t\treturn true;\n\treturn false;\n}\n\n/*\n * set the priority of a task\n * - the caller must hold the RCU read lock\n */\nstatic int set_one_prio(struct task_struct *p, int niceval, int error)\n{\n\tint no_nice;\n\n\tif (!set_one_prio_perm(p)) {\n\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\tif (niceval < task_nice(p) && !can_nice(p, niceval)) {\n\t\terror = -EACCES;\n\t\tgoto out;\n\t}\n\tno_nice = security_task_setnice(p, niceval);\n\tif (no_nice) {\n\t\terror = no_nice;\n\t\tgoto out;\n\t}\n\tif (error == -ESRCH)\n\t\terror = 0;\n\tset_user_nice(p, niceval);\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE3(setpriority, int, which, int, who, int, niceval)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tconst struct cred *cred = current_cred();\n\tint error = -EINVAL;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\n\tif (which > PRIO_USER || which < PRIO_PROCESS)\n\t\tgoto out;\n\n\t/* normalize: avoid signed division (rounding problems) */\n\terror = -ESRCH;\n\tif (niceval < -20)\n\t\tniceval = -20;\n\tif (niceval > 19)\n\t\tniceval = 19;\n\n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tswitch (which) {\n\t\tcase PRIO_PROCESS:\n\t\t\tif (who)\n\t\t\t\tp = find_task_by_vpid(who);\n\t\t\telse\n\t\t\t\tp = current;\n\t\t\tif (p)\n\t\t\t\terror = set_one_prio(p, niceval, error);\n\t\t\tbreak;\n\t\tcase PRIO_PGRP:\n\t\t\tif (who)\n\t\t\t\tpgrp = find_vpid(who);\n\t\t\telse\n\t\t\t\tpgrp = task_pgrp(current);\n\t\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\t\terror = set_one_prio(p, niceval, error);\n\t\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\t\tbreak;\n\t\tcase PRIO_USER:\n\t\t\tuid = make_kuid(cred->user_ns, who);\n\t\t\tuser = cred->user;\n\t\t\tif (!who)\n\t\t\t\tuid = cred->uid;\n\t\t\telse if (!uid_eq(uid, cred->uid) &&\n\t\t\t\t !(user = find_user(uid)))\n\t\t\t\tgoto out_unlock;\t/* No processes for this user */\n\n\t\t\tdo_each_thread(g, p) {\n\t\t\t\tif (uid_eq(task_uid(p), uid))\n\t\t\t\t\terror = set_one_prio(p, niceval, error);\n\t\t\t} while_each_thread(g, p);\n\t\t\tif (!uid_eq(uid, cred->uid))\n\t\t\t\tfree_uid(user);\t\t/* For find_user() */\n\t\t\tbreak;\n\t}\nout_unlock:\n\tread_unlock(&tasklist_lock);\n\trcu_read_unlock();\nout:\n\treturn error;\n}\n\n/*\n * Ugh. To avoid negative return values, \"getpriority()\" will\n * not return the normal nice-value, but a negated value that\n * has been offset by 20 (ie it returns 40..1 instead of -20..19)\n * to stay compatible.\n */\nSYSCALL_DEFINE2(getpriority, int, which, int, who)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tconst struct cred *cred = current_cred();\n\tlong niceval, retval = -ESRCH;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\n\tif (which > PRIO_USER || which < PRIO_PROCESS)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tswitch (which) {\n\t\tcase PRIO_PROCESS:\n\t\t\tif (who)\n\t\t\t\tp = find_task_by_vpid(who);\n\t\t\telse\n\t\t\t\tp = current;\n\t\t\tif (p) {\n\t\t\t\tniceval = 20 - task_nice(p);\n\t\t\t\tif (niceval > retval)\n\t\t\t\t\tretval = niceval;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PRIO_PGRP:\n\t\t\tif (who)\n\t\t\t\tpgrp = find_vpid(who);\n\t\t\telse\n\t\t\t\tpgrp = task_pgrp(current);\n\t\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\t\tniceval = 20 - task_nice(p);\n\t\t\t\tif (niceval > retval)\n\t\t\t\t\tretval = niceval;\n\t\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\t\tbreak;\n\t\tcase PRIO_USER:\n\t\t\tuid = make_kuid(cred->user_ns, who);\n\t\t\tuser = cred->user;\n\t\t\tif (!who)\n\t\t\t\tuid = cred->uid;\n\t\t\telse if (!uid_eq(uid, cred->uid) &&\n\t\t\t\t !(user = find_user(uid)))\n\t\t\t\tgoto out_unlock;\t/* No processes for this user */\n\n\t\t\tdo_each_thread(g, p) {\n\t\t\t\tif (uid_eq(task_uid(p), uid)) {\n\t\t\t\t\tniceval = 20 - task_nice(p);\n\t\t\t\t\tif (niceval > retval)\n\t\t\t\t\t\tretval = niceval;\n\t\t\t\t}\n\t\t\t} while_each_thread(g, p);\n\t\t\tif (!uid_eq(uid, cred->uid))\n\t\t\t\tfree_uid(user);\t\t/* for find_user() */\n\t\t\tbreak;\n\t}\nout_unlock:\n\tread_unlock(&tasklist_lock);\n\trcu_read_unlock();\n\n\treturn retval;\n}\n\n/**\n *\temergency_restart - reboot the system\n *\n *\tWithout shutting down any hardware or taking any locks\n *\treboot the system.  This is called when we know we are in\n *\ttrouble so this is our best effort to reboot.  This is\n *\tsafe to call in interrupt context.\n */\nvoid emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tmachine_emergency_restart();\n}\nEXPORT_SYMBOL_GPL(emergency_restart);\n\nvoid kernel_restart_prepare(char *cmd)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);\n\tsystem_state = SYSTEM_RESTART;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n\tsyscore_shutdown();\n}\n\n/**\n *\tregister_reboot_notifier - Register function to be called at reboot time\n *\t@nb: Info about notifier function to be called\n *\n *\tRegisters a function with the list of functions\n *\tto be called at reboot time.\n *\n *\tCurrently always returns zero, as blocking_notifier_chain_register()\n *\talways returns zero.\n */\nint register_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&reboot_notifier_list, nb);\n}\nEXPORT_SYMBOL(register_reboot_notifier);\n\n/**\n *\tunregister_reboot_notifier - Unregister previously registered reboot notifier\n *\t@nb: Hook to be unregistered\n *\n *\tUnregisters a previously registered reboot\n *\tnotifier function.\n *\n *\tReturns zero on success, or %-ENOENT on failure.\n */\nint unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}\nEXPORT_SYMBOL(unregister_reboot_notifier);\n\n/**\n *\tkernel_restart - reboot the system\n *\t@cmd: pointer to buffer containing command to execute for restart\n *\t\tor %NULL\n *\n *\tShutdown everything and perform a clean reboot.\n *\tThis is not safe to call in interrupt context.\n */\nvoid kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tdisable_nonboot_cpus();\n\tif (!cmd)\n\t\tprintk(KERN_EMERG \"Restarting system.\\n\");\n\telse\n\t\tprintk(KERN_EMERG \"Restarting system with command '%s'.\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_RESTART);\n\tmachine_restart(cmd);\n}\nEXPORT_SYMBOL_GPL(kernel_restart);\n\nstatic void kernel_shutdown_prepare(enum system_states state)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list,\n\t\t(state == SYSTEM_HALT)?SYS_HALT:SYS_POWER_OFF, NULL);\n\tsystem_state = state;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}\n/**\n *\tkernel_halt - halt the system\n *\n *\tShutdown everything and perform a clean system halt.\n */\nvoid kernel_halt(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_HALT);\n\tsyscore_shutdown();\n\tprintk(KERN_EMERG \"System halted.\\n\");\n\tkmsg_dump(KMSG_DUMP_HALT);\n\tmachine_halt();\n}\n\nEXPORT_SYMBOL_GPL(kernel_halt);\n\n/**\n *\tkernel_power_off - power_off the system\n *\n *\tShutdown everything and perform a clean system power_off.\n */\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tdisable_nonboot_cpus();\n\tsyscore_shutdown();\n\tprintk(KERN_EMERG \"Power down.\\n\");\n\tkmsg_dump(KMSG_DUMP_POWEROFF);\n\tmachine_power_off();\n}\nEXPORT_SYMBOL_GPL(kernel_power_off);\n\nstatic DEFINE_MUTEX(reboot_mutex);\n\n/*\n * Reboot system call: for obvious reasons only root may call it,\n * and even root needs to set up some magic numbers in the registers\n * so that some mistake won't make this reboot the whole machine.\n * You can also set the meaning of the ctrl-alt-del-key here.\n *\n * reboot doesn't sync: do that yourself before calling this.\n */\nSYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,\n\t\tvoid __user *, arg)\n{\n\tchar buffer[256];\n\tint ret = 0;\n\n\t/* We only trust the superuser with rebooting the system. */\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\t/* For safety, we require \"magic\" arguments. */\n\tif (magic1 != LINUX_REBOOT_MAGIC1 ||\n\t    (magic2 != LINUX_REBOOT_MAGIC2 &&\n\t                magic2 != LINUX_REBOOT_MAGIC2A &&\n\t\t\tmagic2 != LINUX_REBOOT_MAGIC2B &&\n\t                magic2 != LINUX_REBOOT_MAGIC2C))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If pid namespaces are enabled and the current task is in a child\n\t * pid_namespace, the command is handled by reboot_pid_ns() which will\n\t * call do_exit().\n\t */\n\tret = reboot_pid_ns(task_active_pid_ns(current), cmd);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Instead of trying to make the power_off code look like\n\t * halt when pm_power_off is not set do it the easy way.\n\t */\n\tif ((cmd == LINUX_REBOOT_CMD_POWER_OFF) && !pm_power_off)\n\t\tcmd = LINUX_REBOOT_CMD_HALT;\n\n\tmutex_lock(&reboot_mutex);\n\tswitch (cmd) {\n\tcase LINUX_REBOOT_CMD_RESTART:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_CAD_ON:\n\t\tC_A_D = 1;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_CAD_OFF:\n\t\tC_A_D = 0;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_HALT:\n\t\tkernel_halt();\n\t\tdo_exit(0);\n\t\tpanic(\"cannot halt\");\n\n\tcase LINUX_REBOOT_CMD_POWER_OFF:\n\t\tkernel_power_off();\n\t\tdo_exit(0);\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_RESTART2:\n\t\tif (strncpy_from_user(&buffer[0], arg, sizeof(buffer) - 1) < 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\n\t\tkernel_restart(buffer);\n\t\tbreak;\n\n#ifdef CONFIG_KEXEC\n\tcase LINUX_REBOOT_CMD_KEXEC:\n\t\tret = kernel_kexec();\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_HIBERNATION\n\tcase LINUX_REBOOT_CMD_SW_SUSPEND:\n\t\tret = hibernate();\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&reboot_mutex);\n\treturn ret;\n}\n\nstatic void deferred_cad(struct work_struct *dummy)\n{\n\tkernel_restart(NULL);\n}\n\n/*\n * This function gets called by ctrl-alt-del - ie the keyboard interrupt.\n * As it's called within an interrupt, it may NOT sync: the only choice\n * is whether to reboot at once, or just ignore the ctrl-alt-del.\n */\nvoid ctrl_alt_del(void)\n{\n\tstatic DECLARE_WORK(cad_work, deferred_cad);\n\n\tif (C_A_D)\n\t\tschedule_work(&cad_work);\n\telse\n\t\tkill_cad_pid(SIGINT, 1);\n}\n\t\n/*\n * Unprivileged users may change the real gid to the effective gid\n * or vice versa.  (BSD-style)\n *\n * If you set the real gid at all, or set the effective gid to a value not\n * equal to the real gid, then the saved gid is set to the new effective gid.\n *\n * This makes it possible for a setgid program to completely drop its\n * privileges, which is often a useful assertion to make when you are doing\n * a security audit over a program.\n *\n * The general idea is that a program which uses just setregid() will be\n * 100% compatible with BSD.  A program which uses just setgid() will be\n * 100% compatible with POSIX with saved IDs. \n *\n * SMP: There are not races, the GIDs are checked only by filesystem\n *      operations (as far as semantic preservation is concerned).\n */\nSYSCALL_DEFINE2(setregid, gid_t, rgid, gid_t, egid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkgid_t krgid, kegid;\n\n\tkrgid = make_kgid(ns, rgid);\n\tkegid = make_kgid(ns, egid);\n\n\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))\n\t\treturn -EINVAL;\n\tif ((egid != (gid_t) -1) && !gid_valid(kegid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (rgid != (gid_t) -1) {\n\t\tif (gid_eq(old->gid, krgid) ||\n\t\t    gid_eq(old->egid, krgid) ||\n\t\t    nsown_capable(CAP_SETGID))\n\t\t\tnew->gid = krgid;\n\t\telse\n\t\t\tgoto error;\n\t}\n\tif (egid != (gid_t) -1) {\n\t\tif (gid_eq(old->gid, kegid) ||\n\t\t    gid_eq(old->egid, kegid) ||\n\t\t    gid_eq(old->sgid, kegid) ||\n\t\t    nsown_capable(CAP_SETGID))\n\t\t\tnew->egid = kegid;\n\t\telse\n\t\t\tgoto error;\n\t}\n\n\tif (rgid != (gid_t) -1 ||\n\t    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid)))\n\t\tnew->sgid = new->egid;\n\tnew->fsgid = new->egid;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\n/*\n * setgid() is implemented like SysV w/ SAVED_IDS \n *\n * SMP: Same implicit races as above.\n */\nSYSCALL_DEFINE1(setgid, gid_t, gid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkgid_t kgid;\n\n\tkgid = make_kgid(ns, gid);\n\tif (!gid_valid(kgid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (nsown_capable(CAP_SETGID))\n\t\tnew->gid = new->egid = new->sgid = new->fsgid = kgid;\n\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))\n\t\tnew->egid = new->fsgid = kgid;\n\telse\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\n/*\n * change the user struct in a credentials set to match the new UID\n */\nstatic int set_user(struct cred *new)\n{\n\tstruct user_struct *new_user;\n\n\tnew_user = alloc_uid(new->uid);\n\tif (!new_user)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * We don't fail in case of NPROC limit excess here because too many\n\t * poorly written programs don't check set*uid() return code, assuming\n\t * it never fails if called by root.  We may still enforce NPROC limit\n\t * for programs doing set*uid()+execve() by harmlessly deferring the\n\t * failure to the execve() stage.\n\t */\n\tif (atomic_read(&new_user->processes) >= rlimit(RLIMIT_NPROC) &&\n\t\t\tnew_user != INIT_USER)\n\t\tcurrent->flags |= PF_NPROC_EXCEEDED;\n\telse\n\t\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tfree_uid(new->user);\n\tnew->user = new_user;\n\treturn 0;\n}\n\n/*\n * Unprivileged users may change the real uid to the effective uid\n * or vice versa.  (BSD-style)\n *\n * If you set the real uid at all, or set the effective uid to a value not\n * equal to the real uid, then the saved uid is set to the new effective uid.\n *\n * This makes it possible for a setuid program to completely drop its\n * privileges, which is often a useful assertion to make when you are doing\n * a security audit over a program.\n *\n * The general idea is that a program which uses just setreuid() will be\n * 100% compatible with BSD.  A program which uses just setuid() will be\n * 100% compatible with POSIX with saved IDs. \n */\nSYSCALL_DEFINE2(setreuid, uid_t, ruid, uid_t, euid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kruid, keuid;\n\n\tkruid = make_kuid(ns, ruid);\n\tkeuid = make_kuid(ns, euid);\n\n\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))\n\t\treturn -EINVAL;\n\tif ((euid != (uid_t) -1) && !uid_valid(keuid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (ruid != (uid_t) -1) {\n\t\tnew->uid = kruid;\n\t\tif (!uid_eq(old->uid, kruid) &&\n\t\t    !uid_eq(old->euid, kruid) &&\n\t\t    !nsown_capable(CAP_SETUID))\n\t\t\tgoto error;\n\t}\n\n\tif (euid != (uid_t) -1) {\n\t\tnew->euid = keuid;\n\t\tif (!uid_eq(old->uid, keuid) &&\n\t\t    !uid_eq(old->euid, keuid) &&\n\t\t    !uid_eq(old->suid, keuid) &&\n\t\t    !nsown_capable(CAP_SETUID))\n\t\t\tgoto error;\n\t}\n\n\tif (!uid_eq(new->uid, old->uid)) {\n\t\tretval = set_user(new);\n\t\tif (retval < 0)\n\t\t\tgoto error;\n\t}\n\tif (ruid != (uid_t) -1 ||\n\t    (euid != (uid_t) -1 && !uid_eq(keuid, old->uid)))\n\t\tnew->suid = new->euid;\n\tnew->fsuid = new->euid;\n\n\tretval = security_task_fix_setuid(new, old, LSM_SETID_RE);\n\tif (retval < 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\t\t\n/*\n * setuid() is implemented like SysV with SAVED_IDS \n * \n * Note that SAVED_ID's is deficient in that a setuid root program\n * like sendmail, for example, cannot set its uid to be a normal \n * user and then switch back, because if you're root, setuid() sets\n * the saved uid too.  If you don't like this, blame the bright people\n * in the POSIX committee and/or USG.  Note that the BSD-style setreuid()\n * will allow a root program to temporarily drop privileges and be able to\n * regain them by swapping the real and effective uid.  \n */\nSYSCALL_DEFINE1(setuid, uid_t, uid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kuid;\n\n\tkuid = make_kuid(ns, uid);\n\tif (!uid_valid(kuid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (nsown_capable(CAP_SETUID)) {\n\t\tnew->suid = new->uid = kuid;\n\t\tif (!uid_eq(kuid, old->uid)) {\n\t\t\tretval = set_user(new);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t} else if (!uid_eq(kuid, old->uid) && !uid_eq(kuid, new->suid)) {\n\t\tgoto error;\n\t}\n\n\tnew->fsuid = new->euid = kuid;\n\n\tretval = security_task_fix_setuid(new, old, LSM_SETID_ID);\n\tif (retval < 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\n\n/*\n * This function implements a generic ability to update ruid, euid,\n * and suid.  This allows you to implement the 4.4 compatible seteuid().\n */\nSYSCALL_DEFINE3(setresuid, uid_t, ruid, uid_t, euid, uid_t, suid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kruid, keuid, ksuid;\n\n\tkruid = make_kuid(ns, ruid);\n\tkeuid = make_kuid(ns, euid);\n\tksuid = make_kuid(ns, suid);\n\n\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))\n\t\treturn -EINVAL;\n\n\tif ((euid != (uid_t) -1) && !uid_valid(keuid))\n\t\treturn -EINVAL;\n\n\tif ((suid != (uid_t) -1) && !uid_valid(ksuid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (!nsown_capable(CAP_SETUID)) {\n\t\tif (ruid != (uid_t) -1        && !uid_eq(kruid, old->uid) &&\n\t\t    !uid_eq(kruid, old->euid) && !uid_eq(kruid, old->suid))\n\t\t\tgoto error;\n\t\tif (euid != (uid_t) -1        && !uid_eq(keuid, old->uid) &&\n\t\t    !uid_eq(keuid, old->euid) && !uid_eq(keuid, old->suid))\n\t\t\tgoto error;\n\t\tif (suid != (uid_t) -1        && !uid_eq(ksuid, old->uid) &&\n\t\t    !uid_eq(ksuid, old->euid) && !uid_eq(ksuid, old->suid))\n\t\t\tgoto error;\n\t}\n\n\tif (ruid != (uid_t) -1) {\n\t\tnew->uid = kruid;\n\t\tif (!uid_eq(kruid, old->uid)) {\n\t\t\tretval = set_user(new);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (euid != (uid_t) -1)\n\t\tnew->euid = keuid;\n\tif (suid != (uid_t) -1)\n\t\tnew->suid = ksuid;\n\tnew->fsuid = new->euid;\n\n\tretval = security_task_fix_setuid(new, old, LSM_SETID_RES);\n\tif (retval < 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nSYSCALL_DEFINE3(getresuid, uid_t __user *, ruidp, uid_t __user *, euidp, uid_t __user *, suidp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval;\n\tuid_t ruid, euid, suid;\n\n\truid = from_kuid_munged(cred->user_ns, cred->uid);\n\teuid = from_kuid_munged(cred->user_ns, cred->euid);\n\tsuid = from_kuid_munged(cred->user_ns, cred->suid);\n\n\tif (!(retval   = put_user(ruid, ruidp)) &&\n\t    !(retval   = put_user(euid, euidp)))\n\t\tretval = put_user(suid, suidp);\n\n\treturn retval;\n}\n\n/*\n * Same as above, but for rgid, egid, sgid.\n */\nSYSCALL_DEFINE3(setresgid, gid_t, rgid, gid_t, egid, gid_t, sgid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkgid_t krgid, kegid, ksgid;\n\n\tkrgid = make_kgid(ns, rgid);\n\tkegid = make_kgid(ns, egid);\n\tksgid = make_kgid(ns, sgid);\n\n\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))\n\t\treturn -EINVAL;\n\tif ((egid != (gid_t) -1) && !gid_valid(kegid))\n\t\treturn -EINVAL;\n\tif ((sgid != (gid_t) -1) && !gid_valid(ksgid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (!nsown_capable(CAP_SETGID)) {\n\t\tif (rgid != (gid_t) -1        && !gid_eq(krgid, old->gid) &&\n\t\t    !gid_eq(krgid, old->egid) && !gid_eq(krgid, old->sgid))\n\t\t\tgoto error;\n\t\tif (egid != (gid_t) -1        && !gid_eq(kegid, old->gid) &&\n\t\t    !gid_eq(kegid, old->egid) && !gid_eq(kegid, old->sgid))\n\t\t\tgoto error;\n\t\tif (sgid != (gid_t) -1        && !gid_eq(ksgid, old->gid) &&\n\t\t    !gid_eq(ksgid, old->egid) && !gid_eq(ksgid, old->sgid))\n\t\t\tgoto error;\n\t}\n\n\tif (rgid != (gid_t) -1)\n\t\tnew->gid = krgid;\n\tif (egid != (gid_t) -1)\n\t\tnew->egid = kegid;\n\tif (sgid != (gid_t) -1)\n\t\tnew->sgid = ksgid;\n\tnew->fsgid = new->egid;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nSYSCALL_DEFINE3(getresgid, gid_t __user *, rgidp, gid_t __user *, egidp, gid_t __user *, sgidp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval;\n\tgid_t rgid, egid, sgid;\n\n\trgid = from_kgid_munged(cred->user_ns, cred->gid);\n\tegid = from_kgid_munged(cred->user_ns, cred->egid);\n\tsgid = from_kgid_munged(cred->user_ns, cred->sgid);\n\n\tif (!(retval   = put_user(rgid, rgidp)) &&\n\t    !(retval   = put_user(egid, egidp)))\n\t\tretval = put_user(sgid, sgidp);\n\n\treturn retval;\n}\n\n\n/*\n * \"setfsuid()\" sets the fsuid - the uid used for filesystem checks. This\n * is used for \"access()\" and for the NFS daemon (letting nfsd stay at\n * whatever uid it wants to). It normally shadows \"euid\", except when\n * explicitly set by setfsuid() or for access..\n */\nSYSCALL_DEFINE1(setfsuid, uid_t, uid)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tuid_t old_fsuid;\n\tkuid_t kuid;\n\n\told = current_cred();\n\told_fsuid = from_kuid_munged(old->user_ns, old->fsuid);\n\n\tkuid = make_kuid(old->user_ns, uid);\n\tif (!uid_valid(kuid))\n\t\treturn old_fsuid;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn old_fsuid;\n\n\tif (uid_eq(kuid, old->uid)  || uid_eq(kuid, old->euid)  ||\n\t    uid_eq(kuid, old->suid) || uid_eq(kuid, old->fsuid) ||\n\t    nsown_capable(CAP_SETUID)) {\n\t\tif (!uid_eq(kuid, old->fsuid)) {\n\t\t\tnew->fsuid = kuid;\n\t\t\tif (security_task_fix_setuid(new, old, LSM_SETID_FS) == 0)\n\t\t\t\tgoto change_okay;\n\t\t}\n\t}\n\n\tabort_creds(new);\n\treturn old_fsuid;\n\nchange_okay:\n\tcommit_creds(new);\n\treturn old_fsuid;\n}\n\n/*\n * Samma p\u00e5 svenska..\n */\nSYSCALL_DEFINE1(setfsgid, gid_t, gid)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tgid_t old_fsgid;\n\tkgid_t kgid;\n\n\told = current_cred();\n\told_fsgid = from_kgid_munged(old->user_ns, old->fsgid);\n\n\tkgid = make_kgid(old->user_ns, gid);\n\tif (!gid_valid(kgid))\n\t\treturn old_fsgid;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn old_fsgid;\n\n\tif (gid_eq(kgid, old->gid)  || gid_eq(kgid, old->egid)  ||\n\t    gid_eq(kgid, old->sgid) || gid_eq(kgid, old->fsgid) ||\n\t    nsown_capable(CAP_SETGID)) {\n\t\tif (!gid_eq(kgid, old->fsgid)) {\n\t\t\tnew->fsgid = kgid;\n\t\t\tgoto change_okay;\n\t\t}\n\t}\n\n\tabort_creds(new);\n\treturn old_fsgid;\n\nchange_okay:\n\tcommit_creds(new);\n\treturn old_fsgid;\n}\n\nvoid do_sys_times(struct tms *tms)\n{\n\tcputime_t tgutime, tgstime, cutime, cstime;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tthread_group_times(current, &tgutime, &tgstime);\n\tcutime = current->signal->cutime;\n\tcstime = current->signal->cstime;\n\tspin_unlock_irq(&current->sighand->siglock);\n\ttms->tms_utime = cputime_to_clock_t(tgutime);\n\ttms->tms_stime = cputime_to_clock_t(tgstime);\n\ttms->tms_cutime = cputime_to_clock_t(cutime);\n\ttms->tms_cstime = cputime_to_clock_t(cstime);\n}\n\nSYSCALL_DEFINE1(times, struct tms __user *, tbuf)\n{\n\tif (tbuf) {\n\t\tstruct tms tmp;\n\n\t\tdo_sys_times(&tmp);\n\t\tif (copy_to_user(tbuf, &tmp, sizeof(struct tms)))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn (long) jiffies_64_to_clock_t(get_jiffies_64());\n}\n\n/*\n * This needs some heavy checking ...\n * I just haven't the stomach for it. I also don't fully\n * understand sessions/pgrp etc. Let somebody who does explain it.\n *\n * OK, I think I have the protection semantics right.... this is really\n * only important on a multi-user system anyway, to make sure one user\n * can't send a signal to a process owned by another.  -TYT, 12/12/91\n *\n * Auch. Had to add the 'did_exec' flag to conform completely to POSIX.\n * LBT 04.03.94\n */\nSYSCALL_DEFINE2(setpgid, pid_t, pid, pid_t, pgid)\n{\n\tstruct task_struct *p;\n\tstruct task_struct *group_leader = current->group_leader;\n\tstruct pid *pgrp;\n\tint err;\n\n\tif (!pid)\n\t\tpid = task_pid_vnr(group_leader);\n\tif (!pgid)\n\t\tpgid = pid;\n\tif (pgid < 0)\n\t\treturn -EINVAL;\n\trcu_read_lock();\n\n\t/* From this point forward we keep holding onto the tasklist lock\n\t * so that our parent does not change from under us. -DaveM\n\t */\n\twrite_lock_irq(&tasklist_lock);\n\n\terr = -ESRCH;\n\tp = find_task_by_vpid(pid);\n\tif (!p)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (!thread_group_leader(p))\n\t\tgoto out;\n\n\tif (same_thread_group(p->real_parent, group_leader)) {\n\t\terr = -EPERM;\n\t\tif (task_session(p) != task_session(group_leader))\n\t\t\tgoto out;\n\t\terr = -EACCES;\n\t\tif (p->did_exec)\n\t\t\tgoto out;\n\t} else {\n\t\terr = -ESRCH;\n\t\tif (p != group_leader)\n\t\t\tgoto out;\n\t}\n\n\terr = -EPERM;\n\tif (p->signal->leader)\n\t\tgoto out;\n\n\tpgrp = task_pid(p);\n\tif (pgid != pid) {\n\t\tstruct task_struct *g;\n\n\t\tpgrp = find_vpid(pgid);\n\t\tg = pid_task(pgrp, PIDTYPE_PGID);\n\t\tif (!g || task_session(g) != task_session(group_leader))\n\t\t\tgoto out;\n\t}\n\n\terr = security_task_setpgid(p, pgid);\n\tif (err)\n\t\tgoto out;\n\n\tif (task_pgrp(p) != pgrp)\n\t\tchange_pid(p, PIDTYPE_PGID, pgrp);\n\n\terr = 0;\nout:\n\t/* All paths lead to here, thus we are safe. -DaveM */\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\treturn err;\n}\n\nSYSCALL_DEFINE1(getpgid, pid_t, pid)\n{\n\tstruct task_struct *p;\n\tstruct pid *grp;\n\tint retval;\n\n\trcu_read_lock();\n\tif (!pid)\n\t\tgrp = task_pgrp(current);\n\telse {\n\t\tretval = -ESRCH;\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\tgrp = task_pgrp(p);\n\t\tif (!grp)\n\t\t\tgoto out;\n\n\t\tretval = security_task_getpgid(p);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\tretval = pid_vnr(grp);\nout:\n\trcu_read_unlock();\n\treturn retval;\n}\n\n#ifdef __ARCH_WANT_SYS_GETPGRP\n\nSYSCALL_DEFINE0(getpgrp)\n{\n\treturn sys_getpgid(0);\n}\n\n#endif\n\nSYSCALL_DEFINE1(getsid, pid_t, pid)\n{\n\tstruct task_struct *p;\n\tstruct pid *sid;\n\tint retval;\n\n\trcu_read_lock();\n\tif (!pid)\n\t\tsid = task_session(current);\n\telse {\n\t\tretval = -ESRCH;\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\tsid = task_session(p);\n\t\tif (!sid)\n\t\t\tgoto out;\n\n\t\tretval = security_task_getsid(p);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\tretval = pid_vnr(sid);\nout:\n\trcu_read_unlock();\n\treturn retval;\n}\n\nSYSCALL_DEFINE0(setsid)\n{\n\tstruct task_struct *group_leader = current->group_leader;\n\tstruct pid *sid = task_pid(group_leader);\n\tpid_t session = pid_vnr(sid);\n\tint err = -EPERM;\n\n\twrite_lock_irq(&tasklist_lock);\n\t/* Fail if I am already a session leader */\n\tif (group_leader->signal->leader)\n\t\tgoto out;\n\n\t/* Fail if a process group id already exists that equals the\n\t * proposed session id.\n\t */\n\tif (pid_task(sid, PIDTYPE_PGID))\n\t\tgoto out;\n\n\tgroup_leader->signal->leader = 1;\n\t__set_special_pids(sid);\n\n\tproc_clear_tty(group_leader);\n\n\terr = session;\nout:\n\twrite_unlock_irq(&tasklist_lock);\n\tif (err > 0) {\n\t\tproc_sid_connector(group_leader);\n\t\tsched_autogroup_create_attach(group_leader);\n\t}\n\treturn err;\n}\n\nDECLARE_RWSEM(uts_sem);\n\n#ifdef COMPAT_UTS_MACHINE\n#define override_architecture(name) \\\n\t(personality(current->personality) == PER_LINUX32 && \\\n\t copy_to_user(name->machine, COMPAT_UTS_MACHINE, \\\n\t\t      sizeof(COMPAT_UTS_MACHINE)))\n#else\n#define override_architecture(name)\t0\n#endif\n\n/*\n * Work around broken programs that cannot handle \"Linux 3.0\".\n * Instead we map 3.x to 2.6.40+x, so e.g. 3.0 would be 2.6.40\n */\nstatic int override_release(char __user *release, size_t len)\n{\n\tint ret = 0;\n\n\tif (current->personality & UNAME26) {\n\t\tconst char *rest = UTS_RELEASE;\n\t\tchar buf[65] = { 0 };\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\tsize_t copy;\n\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tcopy = min(sizeof(buf), max_t(size_t, 1, len));\n\t\tcopy = scnprintf(buf, copy, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, copy + 1);\n\t}\n\treturn ret;\n}\n\nSYSCALL_DEFINE1(newuname, struct new_utsname __user *, name)\n{\n\tint errno = 0;\n\n\tdown_read(&uts_sem);\n\tif (copy_to_user(name, utsname(), sizeof *name))\n\t\terrno = -EFAULT;\n\tup_read(&uts_sem);\n\n\tif (!errno && override_release(name->release, sizeof(name->release)))\n\t\terrno = -EFAULT;\n\tif (!errno && override_architecture(name))\n\t\terrno = -EFAULT;\n\treturn errno;\n}\n\n#ifdef __ARCH_WANT_SYS_OLD_UNAME\n/*\n * Old cruft\n */\nSYSCALL_DEFINE1(uname, struct old_utsname __user *, name)\n{\n\tint error = 0;\n\n\tif (!name)\n\t\treturn -EFAULT;\n\n\tdown_read(&uts_sem);\n\tif (copy_to_user(name, utsname(), sizeof(*name)))\n\t\terror = -EFAULT;\n\tup_read(&uts_sem);\n\n\tif (!error && override_release(name->release, sizeof(name->release)))\n\t\terror = -EFAULT;\n\tif (!error && override_architecture(name))\n\t\terror = -EFAULT;\n\treturn error;\n}\n\nSYSCALL_DEFINE1(olduname, struct oldold_utsname __user *, name)\n{\n\tint error;\n\n\tif (!name)\n\t\treturn -EFAULT;\n\tif (!access_ok(VERIFY_WRITE, name, sizeof(struct oldold_utsname)))\n\t\treturn -EFAULT;\n\n\tdown_read(&uts_sem);\n\terror = __copy_to_user(&name->sysname, &utsname()->sysname,\n\t\t\t       __OLD_UTS_LEN);\n\terror |= __put_user(0, name->sysname + __OLD_UTS_LEN);\n\terror |= __copy_to_user(&name->nodename, &utsname()->nodename,\n\t\t\t\t__OLD_UTS_LEN);\n\terror |= __put_user(0, name->nodename + __OLD_UTS_LEN);\n\terror |= __copy_to_user(&name->release, &utsname()->release,\n\t\t\t\t__OLD_UTS_LEN);\n\terror |= __put_user(0, name->release + __OLD_UTS_LEN);\n\terror |= __copy_to_user(&name->version, &utsname()->version,\n\t\t\t\t__OLD_UTS_LEN);\n\terror |= __put_user(0, name->version + __OLD_UTS_LEN);\n\terror |= __copy_to_user(&name->machine, &utsname()->machine,\n\t\t\t\t__OLD_UTS_LEN);\n\terror |= __put_user(0, name->machine + __OLD_UTS_LEN);\n\tup_read(&uts_sem);\n\n\tif (!error && override_architecture(name))\n\t\terror = -EFAULT;\n\tif (!error && override_release(name->release, sizeof(name->release)))\n\t\terror = -EFAULT;\n\treturn error ? -EFAULT : 0;\n}\n#endif\n\nSYSCALL_DEFINE2(sethostname, char __user *, name, int, len)\n{\n\tint errno;\n\tchar tmp[__NEW_UTS_LEN];\n\n\tif (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (len < 0 || len > __NEW_UTS_LEN)\n\t\treturn -EINVAL;\n\tdown_write(&uts_sem);\n\terrno = -EFAULT;\n\tif (!copy_from_user(tmp, name, len)) {\n\t\tstruct new_utsname *u = utsname();\n\n\t\tmemcpy(u->nodename, tmp, len);\n\t\tmemset(u->nodename + len, 0, sizeof(u->nodename) - len);\n\t\terrno = 0;\n\t\tuts_proc_notify(UTS_PROC_HOSTNAME);\n\t}\n\tup_write(&uts_sem);\n\treturn errno;\n}\n\n#ifdef __ARCH_WANT_SYS_GETHOSTNAME\n\nSYSCALL_DEFINE2(gethostname, char __user *, name, int, len)\n{\n\tint i, errno;\n\tstruct new_utsname *u;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tdown_read(&uts_sem);\n\tu = utsname();\n\ti = 1 + strlen(u->nodename);\n\tif (i > len)\n\t\ti = len;\n\terrno = 0;\n\tif (copy_to_user(name, u->nodename, i))\n\t\terrno = -EFAULT;\n\tup_read(&uts_sem);\n\treturn errno;\n}\n\n#endif\n\n/*\n * Only setdomainname; getdomainname can be implemented by calling\n * uname()\n */\nSYSCALL_DEFINE2(setdomainname, char __user *, name, int, len)\n{\n\tint errno;\n\tchar tmp[__NEW_UTS_LEN];\n\n\tif (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (len < 0 || len > __NEW_UTS_LEN)\n\t\treturn -EINVAL;\n\n\tdown_write(&uts_sem);\n\terrno = -EFAULT;\n\tif (!copy_from_user(tmp, name, len)) {\n\t\tstruct new_utsname *u = utsname();\n\n\t\tmemcpy(u->domainname, tmp, len);\n\t\tmemset(u->domainname + len, 0, sizeof(u->domainname) - len);\n\t\terrno = 0;\n\t\tuts_proc_notify(UTS_PROC_DOMAINNAME);\n\t}\n\tup_write(&uts_sem);\n\treturn errno;\n}\n\nSYSCALL_DEFINE2(getrlimit, unsigned int, resource, struct rlimit __user *, rlim)\n{\n\tstruct rlimit value;\n\tint ret;\n\n\tret = do_prlimit(current, resource, NULL, &value);\n\tif (!ret)\n\t\tret = copy_to_user(rlim, &value, sizeof(*rlim)) ? -EFAULT : 0;\n\n\treturn ret;\n}\n\n#ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT\n\n/*\n *\tBack compatibility for getrlimit. Needed for some apps.\n */\n \nSYSCALL_DEFINE2(old_getrlimit, unsigned int, resource,\n\t\tstruct rlimit __user *, rlim)\n{\n\tstruct rlimit x;\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\n\ttask_lock(current->group_leader);\n\tx = current->signal->rlim[resource];\n\ttask_unlock(current->group_leader);\n\tif (x.rlim_cur > 0x7FFFFFFF)\n\t\tx.rlim_cur = 0x7FFFFFFF;\n\tif (x.rlim_max > 0x7FFFFFFF)\n\t\tx.rlim_max = 0x7FFFFFFF;\n\treturn copy_to_user(rlim, &x, sizeof(x))?-EFAULT:0;\n}\n\n#endif\n\nstatic inline bool rlim64_is_infinity(__u64 rlim64)\n{\n#if BITS_PER_LONG < 64\n\treturn rlim64 >= ULONG_MAX;\n#else\n\treturn rlim64 == RLIM64_INFINITY;\n#endif\n}\n\nstatic void rlim_to_rlim64(const struct rlimit *rlim, struct rlimit64 *rlim64)\n{\n\tif (rlim->rlim_cur == RLIM_INFINITY)\n\t\trlim64->rlim_cur = RLIM64_INFINITY;\n\telse\n\t\trlim64->rlim_cur = rlim->rlim_cur;\n\tif (rlim->rlim_max == RLIM_INFINITY)\n\t\trlim64->rlim_max = RLIM64_INFINITY;\n\telse\n\t\trlim64->rlim_max = rlim->rlim_max;\n}\n\nstatic void rlim64_to_rlim(const struct rlimit64 *rlim64, struct rlimit *rlim)\n{\n\tif (rlim64_is_infinity(rlim64->rlim_cur))\n\t\trlim->rlim_cur = RLIM_INFINITY;\n\telse\n\t\trlim->rlim_cur = (unsigned long)rlim64->rlim_cur;\n\tif (rlim64_is_infinity(rlim64->rlim_max))\n\t\trlim->rlim_max = RLIM_INFINITY;\n\telse\n\t\trlim->rlim_max = (unsigned long)rlim64->rlim_max;\n}\n\n/* make sure you are allowed to change @tsk limits before calling this */\nint do_prlimit(struct task_struct *tsk, unsigned int resource,\n\t\tstruct rlimit *new_rlim, struct rlimit *old_rlim)\n{\n\tstruct rlimit *rlim;\n\tint retval = 0;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)\n\t\t\treturn -EINVAL;\n\t\tif (resource == RLIMIT_NOFILE &&\n\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* protect tsk->signal and tsk->sighand from disappearing */\n\tread_lock(&tasklist_lock);\n\tif (!tsk->sighand) {\n\t\tretval = -ESRCH;\n\t\tgoto out;\n\t}\n\n\trlim = tsk->signal->rlim + resource;\n\ttask_lock(tsk->group_leader);\n\tif (new_rlim) {\n\t\t/* Keep the capable check against init_user_ns until\n\t\t   cgroups can contain all limits */\n\t\tif (new_rlim->rlim_max > rlim->rlim_max &&\n\t\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\t\tretval = -EPERM;\n\t\tif (!retval)\n\t\t\tretval = security_task_setrlimit(tsk->group_leader,\n\t\t\t\t\tresource, new_rlim);\n\t\tif (resource == RLIMIT_CPU && new_rlim->rlim_cur == 0) {\n\t\t\t/*\n\t\t\t * The caller is asking for an immediate RLIMIT_CPU\n\t\t\t * expiry.  But we use the zero value to mean \"it was\n\t\t\t * never set\".  So let's cheat and make it one second\n\t\t\t * instead\n\t\t\t */\n\t\t\tnew_rlim->rlim_cur = 1;\n\t\t}\n\t}\n\tif (!retval) {\n\t\tif (old_rlim)\n\t\t\t*old_rlim = *rlim;\n\t\tif (new_rlim)\n\t\t\t*rlim = *new_rlim;\n\t}\n\ttask_unlock(tsk->group_leader);\n\n\t/*\n\t * RLIMIT_CPU handling.   Note that the kernel fails to return an error\n\t * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a\n\t * very long-standing error, and fixing it now risks breakage of\n\t * applications, so we live with it\n\t */\n\t if (!retval && new_rlim && resource == RLIMIT_CPU &&\n\t\t\t new_rlim->rlim_cur != RLIM_INFINITY)\n\t\tupdate_rlimit_cpu(tsk, new_rlim->rlim_cur);\nout:\n\tread_unlock(&tasklist_lock);\n\treturn retval;\n}\n\n/* rcu lock must be held */\nstatic int check_prlimit_permission(struct task_struct *task)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\n\tif (current == task)\n\t\treturn 0;\n\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\treturn 0;\n\tif (ns_capable(tcred->user_ns, CAP_SYS_RESOURCE))\n\t\treturn 0;\n\n\treturn -EPERM;\n}\n\nSYSCALL_DEFINE4(prlimit64, pid_t, pid, unsigned int, resource,\n\t\tconst struct rlimit64 __user *, new_rlim,\n\t\tstruct rlimit64 __user *, old_rlim)\n{\n\tstruct rlimit64 old64, new64;\n\tstruct rlimit old, new;\n\tstruct task_struct *tsk;\n\tint ret;\n\n\tif (new_rlim) {\n\t\tif (copy_from_user(&new64, new_rlim, sizeof(new64)))\n\t\t\treturn -EFAULT;\n\t\trlim64_to_rlim(&new64, &new);\n\t}\n\n\trcu_read_lock();\n\ttsk = pid ? find_task_by_vpid(pid) : current;\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tret = check_prlimit_permission(tsk);\n\tif (ret) {\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\tget_task_struct(tsk);\n\trcu_read_unlock();\n\n\tret = do_prlimit(tsk, resource, new_rlim ? &new : NULL,\n\t\t\told_rlim ? &old : NULL);\n\n\tif (!ret && old_rlim) {\n\t\trlim_to_rlim64(&old, &old64);\n\t\tif (copy_to_user(old_rlim, &old64, sizeof(old64)))\n\t\t\tret = -EFAULT;\n\t}\n\n\tput_task_struct(tsk);\n\treturn ret;\n}\n\nSYSCALL_DEFINE2(setrlimit, unsigned int, resource, struct rlimit __user *, rlim)\n{\n\tstruct rlimit new_rlim;\n\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\treturn do_prlimit(current, resource, &new_rlim, NULL);\n}\n\n/*\n * It would make sense to put struct rusage in the task_struct,\n * except that would make the task_struct be *really big*.  After\n * task_struct gets moved into malloc'ed memory, it would\n * make sense to do this.  It will make moving the rest of the information\n * a lot simpler!  (Which we're not doing right now because we're not\n * measuring them yet).\n *\n * When sampling multiple threads for RUSAGE_SELF, under SMP we might have\n * races with threads incrementing their own counters.  But since word\n * reads are atomic, we either get new values or old values and we don't\n * care which for the sums.  We always take the siglock to protect reading\n * the c* fields from p->signal from races with exit.c updating those\n * fields when reaping, so a sample either gets all the additions of a\n * given child after it's reaped, or none so this sample is before reaping.\n *\n * Locking:\n * We need to take the siglock for CHILDEREN, SELF and BOTH\n * for  the cases current multithreaded, non-current single threaded\n * non-current multithreaded.  Thread traversal is now safe with\n * the siglock held.\n * Strictly speaking, we donot need to take the siglock if we are current and\n * single threaded,  as no one else can take our signal_struct away, no one\n * else can  reap the  children to update signal->c* counters, and no one else\n * can race with the signal-> fields. If we do not take any lock, the\n * signal-> fields could be read out of order while another thread was just\n * exiting. So we should  place a read memory barrier when we avoid the lock.\n * On the writer side,  write memory barrier is implied in  __exit_signal\n * as __exit_signal releases  the siglock spinlock after updating the signal->\n * fields. But we don't do this yet to keep things simple.\n *\n */\n\nstatic void accumulate_thread_rusage(struct task_struct *t, struct rusage *r)\n{\n\tr->ru_nvcsw += t->nvcsw;\n\tr->ru_nivcsw += t->nivcsw;\n\tr->ru_minflt += t->min_flt;\n\tr->ru_majflt += t->maj_flt;\n\tr->ru_inblock += task_io_get_inblock(t);\n\tr->ru_oublock += task_io_get_oublock(t);\n}\n\nstatic void k_getrusage(struct task_struct *p, int who, struct rusage *r)\n{\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tcputime_t tgutime, tgstime, utime, stime;\n\tunsigned long maxrss = 0;\n\n\tmemset((char *) r, 0, sizeof *r);\n\tutime = stime = 0;\n\n\tif (who == RUSAGE_THREAD) {\n\t\ttask_times(current, &utime, &stime);\n\t\taccumulate_thread_rusage(p, r);\n\t\tmaxrss = p->signal->maxrss;\n\t\tgoto out;\n\t}\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn;\n\n\tswitch (who) {\n\t\tcase RUSAGE_BOTH:\n\t\tcase RUSAGE_CHILDREN:\n\t\t\tutime = p->signal->cutime;\n\t\t\tstime = p->signal->cstime;\n\t\t\tr->ru_nvcsw = p->signal->cnvcsw;\n\t\t\tr->ru_nivcsw = p->signal->cnivcsw;\n\t\t\tr->ru_minflt = p->signal->cmin_flt;\n\t\t\tr->ru_majflt = p->signal->cmaj_flt;\n\t\t\tr->ru_inblock = p->signal->cinblock;\n\t\t\tr->ru_oublock = p->signal->coublock;\n\t\t\tmaxrss = p->signal->cmaxrss;\n\n\t\t\tif (who == RUSAGE_CHILDREN)\n\t\t\t\tbreak;\n\n\t\tcase RUSAGE_SELF:\n\t\t\tthread_group_times(p, &tgutime, &tgstime);\n\t\t\tutime += tgutime;\n\t\t\tstime += tgstime;\n\t\t\tr->ru_nvcsw += p->signal->nvcsw;\n\t\t\tr->ru_nivcsw += p->signal->nivcsw;\n\t\t\tr->ru_minflt += p->signal->min_flt;\n\t\t\tr->ru_majflt += p->signal->maj_flt;\n\t\t\tr->ru_inblock += p->signal->inblock;\n\t\t\tr->ru_oublock += p->signal->oublock;\n\t\t\tif (maxrss < p->signal->maxrss)\n\t\t\t\tmaxrss = p->signal->maxrss;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\taccumulate_thread_rusage(t, r);\n\t\t\t\tt = next_thread(t);\n\t\t\t} while (t != p);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\tunlock_task_sighand(p, &flags);\n\nout:\n\tcputime_to_timeval(utime, &r->ru_utime);\n\tcputime_to_timeval(stime, &r->ru_stime);\n\n\tif (who != RUSAGE_CHILDREN) {\n\t\tstruct mm_struct *mm = get_task_mm(p);\n\t\tif (mm) {\n\t\t\tsetmax_mm_hiwater_rss(&maxrss, mm);\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\tr->ru_maxrss = maxrss * (PAGE_SIZE / 1024); /* convert pages to KBs */\n}\n\nint getrusage(struct task_struct *p, int who, struct rusage __user *ru)\n{\n\tstruct rusage r;\n\tk_getrusage(p, who, &r);\n\treturn copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;\n}\n\nSYSCALL_DEFINE2(getrusage, int, who, struct rusage __user *, ru)\n{\n\tif (who != RUSAGE_SELF && who != RUSAGE_CHILDREN &&\n\t    who != RUSAGE_THREAD)\n\t\treturn -EINVAL;\n\treturn getrusage(current, who, ru);\n}\n\nSYSCALL_DEFINE1(umask, int, mask)\n{\n\tmask = xchg(&current->fs->umask, mask & S_IRWXUGO);\n\treturn mask;\n}\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstatic int prctl_set_mm_exe_file(struct mm_struct *mm, unsigned int fd)\n{\n\tstruct fd exe;\n\tstruct dentry *dentry;\n\tint err;\n\n\texe = fdget(fd);\n\tif (!exe.file)\n\t\treturn -EBADF;\n\n\tdentry = exe.file->f_path.dentry;\n\n\t/*\n\t * Because the original mm->exe_file points to executable file, make\n\t * sure that this one is executable as well, to avoid breaking an\n\t * overall picture.\n\t */\n\terr = -EACCES;\n\tif (!S_ISREG(dentry->d_inode->i_mode)\t||\n\t    exe.file->f_path.mnt->mnt_flags & MNT_NOEXEC)\n\t\tgoto exit;\n\n\terr = inode_permission(dentry->d_inode, MAY_EXEC);\n\tif (err)\n\t\tgoto exit;\n\n\tdown_write(&mm->mmap_sem);\n\n\t/*\n\t * Forbid mm->exe_file change if old file still mapped.\n\t */\n\terr = -EBUSY;\n\tif (mm->exe_file) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_file &&\n\t\t\t    path_equal(&vma->vm_file->f_path,\n\t\t\t\t       &mm->exe_file->f_path))\n\t\t\t\tgoto exit_unlock;\n\t}\n\n\t/*\n\t * The symlink can be changed only once, just to disallow arbitrary\n\t * transitions malicious software might bring in. This means one\n\t * could make a snapshot over all processes running and monitor\n\t * /proc/pid/exe changes to notice unusual activity if needed.\n\t */\n\terr = -EPERM;\n\tif (test_and_set_bit(MMF_EXE_FILE_CHANGED, &mm->flags))\n\t\tgoto exit_unlock;\n\n\terr = 0;\n\tset_mm_exe_file(mm, exe.file);\t/* this grabs a reference to exe.file */\nexit_unlock:\n\tup_write(&mm->mmap_sem);\n\nexit:\n\tfdput(exe);\n\treturn err;\n}\n\nstatic int prctl_set_mm(int opt, unsigned long addr,\n\t\t\tunsigned long arg4, unsigned long arg5)\n{\n\tunsigned long rlim = rlimit(RLIMIT_DATA);\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tint error;\n\n\tif (arg5 || (arg4 && opt != PR_SET_MM_AUXV))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\tif (opt == PR_SET_MM_EXE_FILE)\n\t\treturn prctl_set_mm_exe_file(mm, (unsigned int)addr);\n\n\tif (addr >= TASK_SIZE || addr < mmap_min_addr)\n\t\treturn -EINVAL;\n\n\terror = -EINVAL;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, addr);\n\n\tswitch (opt) {\n\tcase PR_SET_MM_START_CODE:\n\t\tmm->start_code = addr;\n\t\tbreak;\n\tcase PR_SET_MM_END_CODE:\n\t\tmm->end_code = addr;\n\t\tbreak;\n\tcase PR_SET_MM_START_DATA:\n\t\tmm->start_data = addr;\n\t\tbreak;\n\tcase PR_SET_MM_END_DATA:\n\t\tmm->end_data = addr;\n\t\tbreak;\n\n\tcase PR_SET_MM_START_BRK:\n\t\tif (addr <= mm->end_data)\n\t\t\tgoto out;\n\n\t\tif (rlim < RLIM_INFINITY &&\n\t\t    (mm->brk - addr) +\n\t\t    (mm->end_data - mm->start_data) > rlim)\n\t\t\tgoto out;\n\n\t\tmm->start_brk = addr;\n\t\tbreak;\n\n\tcase PR_SET_MM_BRK:\n\t\tif (addr <= mm->end_data)\n\t\t\tgoto out;\n\n\t\tif (rlim < RLIM_INFINITY &&\n\t\t    (addr - mm->start_brk) +\n\t\t    (mm->end_data - mm->start_data) > rlim)\n\t\t\tgoto out;\n\n\t\tmm->brk = addr;\n\t\tbreak;\n\n\t/*\n\t * If command line arguments and environment\n\t * are placed somewhere else on stack, we can\n\t * set them up here, ARG_START/END to setup\n\t * command line argumets and ENV_START/END\n\t * for environment.\n\t */\n\tcase PR_SET_MM_START_STACK:\n\tcase PR_SET_MM_ARG_START:\n\tcase PR_SET_MM_ARG_END:\n\tcase PR_SET_MM_ENV_START:\n\tcase PR_SET_MM_ENV_END:\n\t\tif (!vma) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (opt == PR_SET_MM_START_STACK)\n\t\t\tmm->start_stack = addr;\n\t\telse if (opt == PR_SET_MM_ARG_START)\n\t\t\tmm->arg_start = addr;\n\t\telse if (opt == PR_SET_MM_ARG_END)\n\t\t\tmm->arg_end = addr;\n\t\telse if (opt == PR_SET_MM_ENV_START)\n\t\t\tmm->env_start = addr;\n\t\telse if (opt == PR_SET_MM_ENV_END)\n\t\t\tmm->env_end = addr;\n\t\tbreak;\n\n\t/*\n\t * This doesn't move auxiliary vector itself\n\t * since it's pinned to mm_struct, but allow\n\t * to fill vector with new values. It's up\n\t * to a caller to provide sane values here\n\t * otherwise user space tools which use this\n\t * vector might be unhappy.\n\t */\n\tcase PR_SET_MM_AUXV: {\n\t\tunsigned long user_auxv[AT_VECTOR_SIZE];\n\n\t\tif (arg4 > sizeof(user_auxv))\n\t\t\tgoto out;\n\t\tup_read(&mm->mmap_sem);\n\n\t\tif (copy_from_user(user_auxv, (const void __user *)addr, arg4))\n\t\t\treturn -EFAULT;\n\n\t\t/* Make sure the last entry is always AT_NULL */\n\t\tuser_auxv[AT_VECTOR_SIZE - 2] = 0;\n\t\tuser_auxv[AT_VECTOR_SIZE - 1] = 0;\n\n\t\tBUILD_BUG_ON(sizeof(user_auxv) != sizeof(mm->saved_auxv));\n\n\t\ttask_lock(current);\n\t\tmemcpy(mm->saved_auxv, user_auxv, arg4);\n\t\ttask_unlock(current);\n\n\t\treturn 0;\n\t}\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terror = 0;\nout:\n\tup_read(&mm->mmap_sem);\n\treturn error;\n}\n\nstatic int prctl_get_tid_address(struct task_struct *me, int __user **tid_addr)\n{\n\treturn put_user(me->clear_child_tid, tid_addr);\n}\n\n#else /* CONFIG_CHECKPOINT_RESTORE */\nstatic int prctl_set_mm(int opt, unsigned long addr,\n\t\t\tunsigned long arg4, unsigned long arg5)\n{\n\treturn -EINVAL;\n}\nstatic int prctl_get_tid_address(struct task_struct *me, int __user **tid_addr)\n{\n\treturn -EINVAL;\n}\n#endif\n\nSYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,\n\t\tunsigned long, arg4, unsigned long, arg5)\n{\n\tstruct task_struct *me = current;\n\tunsigned char comm[sizeof(me->comm)];\n\tlong error;\n\n\terror = security_task_prctl(option, arg2, arg3, arg4, arg5);\n\tif (error != -ENOSYS)\n\t\treturn error;\n\n\terror = 0;\n\tswitch (option) {\n\t\tcase PR_SET_PDEATHSIG:\n\t\t\tif (!valid_signal(arg2)) {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tme->pdeath_signal = arg2;\n\t\t\tbreak;\n\t\tcase PR_GET_PDEATHSIG:\n\t\t\terror = put_user(me->pdeath_signal, (int __user *)arg2);\n\t\t\tbreak;\n\t\tcase PR_GET_DUMPABLE:\n\t\t\terror = get_dumpable(me->mm);\n\t\t\tbreak;\n\t\tcase PR_SET_DUMPABLE:\n\t\t\tif (arg2 < 0 || arg2 > 1) {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_dumpable(me->mm, arg2);\n\t\t\tbreak;\n\n\t\tcase PR_SET_UNALIGN:\n\t\t\terror = SET_UNALIGN_CTL(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_GET_UNALIGN:\n\t\t\terror = GET_UNALIGN_CTL(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_SET_FPEMU:\n\t\t\terror = SET_FPEMU_CTL(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_GET_FPEMU:\n\t\t\terror = GET_FPEMU_CTL(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_SET_FPEXC:\n\t\t\terror = SET_FPEXC_CTL(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_GET_FPEXC:\n\t\t\terror = GET_FPEXC_CTL(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_GET_TIMING:\n\t\t\terror = PR_TIMING_STATISTICAL;\n\t\t\tbreak;\n\t\tcase PR_SET_TIMING:\n\t\t\tif (arg2 != PR_TIMING_STATISTICAL)\n\t\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\tcase PR_SET_NAME:\n\t\t\tcomm[sizeof(me->comm)-1] = 0;\n\t\t\tif (strncpy_from_user(comm, (char __user *)arg2,\n\t\t\t\t\t      sizeof(me->comm) - 1) < 0)\n\t\t\t\treturn -EFAULT;\n\t\t\tset_task_comm(me, comm);\n\t\t\tproc_comm_connector(me);\n\t\t\tbreak;\n\t\tcase PR_GET_NAME:\n\t\t\tget_task_comm(comm, me);\n\t\t\tif (copy_to_user((char __user *)arg2, comm,\n\t\t\t\t\t sizeof(comm)))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\t\tcase PR_GET_ENDIAN:\n\t\t\terror = GET_ENDIAN(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_SET_ENDIAN:\n\t\t\terror = SET_ENDIAN(me, arg2);\n\t\t\tbreak;\n\t\tcase PR_GET_SECCOMP:\n\t\t\terror = prctl_get_seccomp();\n\t\t\tbreak;\n\t\tcase PR_SET_SECCOMP:\n\t\t\terror = prctl_set_seccomp(arg2, (char __user *)arg3);\n\t\t\tbreak;\n\t\tcase PR_GET_TSC:\n\t\t\terror = GET_TSC_CTL(arg2);\n\t\t\tbreak;\n\t\tcase PR_SET_TSC:\n\t\t\terror = SET_TSC_CTL(arg2);\n\t\t\tbreak;\n\t\tcase PR_TASK_PERF_EVENTS_DISABLE:\n\t\t\terror = perf_event_task_disable();\n\t\t\tbreak;\n\t\tcase PR_TASK_PERF_EVENTS_ENABLE:\n\t\t\terror = perf_event_task_enable();\n\t\t\tbreak;\n\t\tcase PR_GET_TIMERSLACK:\n\t\t\terror = current->timer_slack_ns;\n\t\t\tbreak;\n\t\tcase PR_SET_TIMERSLACK:\n\t\t\tif (arg2 <= 0)\n\t\t\t\tcurrent->timer_slack_ns =\n\t\t\t\t\tcurrent->default_timer_slack_ns;\n\t\t\telse\n\t\t\t\tcurrent->timer_slack_ns = arg2;\n\t\t\tbreak;\n\t\tcase PR_MCE_KILL:\n\t\t\tif (arg4 | arg5)\n\t\t\t\treturn -EINVAL;\n\t\t\tswitch (arg2) {\n\t\t\tcase PR_MCE_KILL_CLEAR:\n\t\t\t\tif (arg3 != 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tcurrent->flags &= ~PF_MCE_PROCESS;\n\t\t\t\tbreak;\n\t\t\tcase PR_MCE_KILL_SET:\n\t\t\t\tcurrent->flags |= PF_MCE_PROCESS;\n\t\t\t\tif (arg3 == PR_MCE_KILL_EARLY)\n\t\t\t\t\tcurrent->flags |= PF_MCE_EARLY;\n\t\t\t\telse if (arg3 == PR_MCE_KILL_LATE)\n\t\t\t\t\tcurrent->flags &= ~PF_MCE_EARLY;\n\t\t\t\telse if (arg3 == PR_MCE_KILL_DEFAULT)\n\t\t\t\t\tcurrent->flags &=\n\t\t\t\t\t\t~(PF_MCE_EARLY|PF_MCE_PROCESS);\n\t\t\t\telse\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PR_MCE_KILL_GET:\n\t\t\tif (arg2 | arg3 | arg4 | arg5)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (current->flags & PF_MCE_PROCESS)\n\t\t\t\terror = (current->flags & PF_MCE_EARLY) ?\n\t\t\t\t\tPR_MCE_KILL_EARLY : PR_MCE_KILL_LATE;\n\t\t\telse\n\t\t\t\terror = PR_MCE_KILL_DEFAULT;\n\t\t\tbreak;\n\t\tcase PR_SET_MM:\n\t\t\terror = prctl_set_mm(arg2, arg3, arg4, arg5);\n\t\t\tbreak;\n\t\tcase PR_GET_TID_ADDRESS:\n\t\t\terror = prctl_get_tid_address(me, (int __user **)arg2);\n\t\t\tbreak;\n\t\tcase PR_SET_CHILD_SUBREAPER:\n\t\t\tme->signal->is_child_subreaper = !!arg2;\n\t\t\tbreak;\n\t\tcase PR_GET_CHILD_SUBREAPER:\n\t\t\terror = put_user(me->signal->is_child_subreaper,\n\t\t\t\t\t (int __user *) arg2);\n\t\t\tbreak;\n\t\tcase PR_SET_NO_NEW_PRIVS:\n\t\t\tif (arg2 != 1 || arg3 || arg4 || arg5)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcurrent->no_new_privs = 1;\n\t\t\tbreak;\n\t\tcase PR_GET_NO_NEW_PRIVS:\n\t\t\tif (arg2 || arg3 || arg4 || arg5)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn current->no_new_privs ? 1 : 0;\n\t\tdefault:\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE3(getcpu, unsigned __user *, cpup, unsigned __user *, nodep,\n\t\tstruct getcpu_cache __user *, unused)\n{\n\tint err = 0;\n\tint cpu = raw_smp_processor_id();\n\tif (cpup)\n\t\terr |= put_user(cpu, cpup);\n\tif (nodep)\n\t\terr |= put_user(cpu_to_node(cpu), nodep);\n\treturn err ? -EFAULT : 0;\n}\n\nchar poweroff_cmd[POWEROFF_CMD_PATH_LEN] = \"/sbin/poweroff\";\n\nstatic void argv_cleanup(struct subprocess_info *info)\n{\n\targv_free(info->argv);\n}\n\nstatic int __orderly_poweroff(void)\n{\n\tint argc;\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tNULL\n\t};\n\tint ret;\n\n\targv = argv_split(GFP_ATOMIC, poweroff_cmd, &argc);\n\tif (argv == NULL) {\n\t\tprintk(KERN_WARNING \"%s failed to allocate memory for \\\"%s\\\"\\n\",\n\t\t       __func__, poweroff_cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = call_usermodehelper_fns(argv[0], argv, envp, UMH_WAIT_EXEC,\n\t\t\t\t      NULL, argv_cleanup, NULL);\n\tif (ret == -ENOMEM)\n\t\targv_free(argv);\n\n\treturn ret;\n}\n\n/**\n * orderly_poweroff - Trigger an orderly system poweroff\n * @force: force poweroff if command execution fails\n *\n * This may be called from any context to trigger a system shutdown.\n * If the orderly shutdown fails, it will force an immediate shutdown.\n */\nint orderly_poweroff(bool force)\n{\n\tint ret = __orderly_poweroff();\n\n\tif (ret && force) {\n\t\tprintk(KERN_WARNING \"Failed to start orderly shutdown: \"\n\t\t       \"forcing the issue\\n\");\n\n\t\t/*\n\t\t * I guess this should try to kick off some daemon to sync and\n\t\t * poweroff asap.  Or not even bother syncing if we're doing an\n\t\t * emergency shutdown?\n\t\t */\n\t\temergency_sync();\n\t\tkernel_power_off();\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(orderly_poweroff);\n"], "buggy_code_start_loc": [1268], "buggy_code_end_loc": [1288], "fixing_code_start_loc": [1268], "fixing_code_end_loc": [1290], "type": "CWE-16", "message": "The override_release function in kernel/sys.c in the Linux kernel before 3.4.16 allows local users to obtain sensitive information from kernel stack memory via a uname system call in conjunction with a UNAME26 personality.", "other": {"cve": {"id": "CVE-2012-0957", "sourceIdentifier": "security@ubuntu.com", "published": "2012-12-21T11:47:35.440", "lastModified": "2013-08-22T03:51:59.083", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The override_release function in kernel/sys.c in the Linux kernel before 3.4.16 allows local users to obtain sensitive information from kernel stack memory via a uname system call in conjunction with a UNAME26 personality."}, {"lang": "es", "value": "La funci\u00f3n override_release en kernel/sys.c en el kernel de Linux antes de v3.4.16 permite a usuarios locales obtener informaci\u00f3n sensible de la memoria de la pila del n\u00facleo a trav\u00e9s de una llamada al sistema uname junto con una personalidad UNAME26.\r\n"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-16"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.4.15", "matchCriteriaId": "2F399128-7646-4F7C-83D5-1C9461024AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:x86:*", "matchCriteriaId": "7D47A395-821D-4BFF-996E-E849D9A40217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:x86:*", "matchCriteriaId": "8A603291-33B4-4195-B52D-D2A9938089C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:x86:*", "matchCriteriaId": "8C3D9C66-933A-469E-9073-75015A8AD17D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:x86:*", "matchCriteriaId": "C92F29A0-DEFF-49E4-AE86-5DBDAD51C677"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:x86:*", "matchCriteriaId": "5690A703-390D-4D8A-9258-2F47116DAB4F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:x86:*", "matchCriteriaId": "AB1EDDA7-15AF-4B45-A931-DFCBB1EEB701"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:x86:*", "matchCriteriaId": "952FE0DC-B2ED-4080-BF29-A2C265E83FEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:x86:*", "matchCriteriaId": "1CE7ABDB-6572-40E8-B952-CBE52C999858"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:x86:*", "matchCriteriaId": "0F417186-D1ED-4A31-92B2-83DEDA1AF272"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:x86:*", "matchCriteriaId": "3D4FCFAE-918C-4886-9A17-08A5B94D35F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:x86:*", "matchCriteriaId": "830D2914-C9FE-406F-AFCE-7A04BB9E2896"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:x86:*", "matchCriteriaId": "F4B791B5-2EB5-403A-90CC-B219F6277D1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:x86:*", "matchCriteriaId": "2BA5F34D-7490-4B2B-A7E6-8450F9C1FC31"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:x86:*", "matchCriteriaId": "B803FE64-FC8D-4650-9FB9-FEEED4340416"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:x86:*", "matchCriteriaId": "4C560A9A-2388-4980-9E88-118C5EB806B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=2702b1526c7278c4d65d78de209a465d4de2885e", "source": "security@ubuntu.com", "tags": ["Patch"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/091110.html", "source": "security@ubuntu.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.4.16", "source": "security@ubuntu.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/10/09/4", "source": "security@ubuntu.com", "tags": ["Exploit"]}, {"url": "http://www.ubuntu.com/usn/USN-1644-1", "source": "security@ubuntu.com"}, {"url": "http://www.ubuntu.com/usn/USN-1645-1", "source": "security@ubuntu.com"}, {"url": "http://www.ubuntu.com/usn/USN-1646-1", "source": "security@ubuntu.com"}, {"url": "http://www.ubuntu.com/usn/USN-1647-1", "source": "security@ubuntu.com"}, {"url": "http://www.ubuntu.com/usn/USN-1648-1", "source": "security@ubuntu.com"}, {"url": "http://www.ubuntu.com/usn/USN-1649-1", "source": "security@ubuntu.com"}, {"url": "http://www.ubuntu.com/usn/USN-1652-1", "source": "security@ubuntu.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=862877", "source": "security@ubuntu.com"}, {"url": "https://github.com/torvalds/linux/commit/2702b1526c7278c4d65d78de209a465d4de2885e", "source": "security@ubuntu.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2702b1526c7278c4d65d78de209a465d4de2885e"}}