{"buggy_code": ["/*\n * linux/fs/binfmt_elf.c\n *\n * These are the functions used to load ELF format executables as used\n * on SVr4 machines.  Information on the format may be found in the book\n * \"UNIX SYSTEM V RELEASE 4 Programmers Guide: Ansi C and Programming Support\n * Tools\".\n *\n * Copyright 1993, 1994: Eric Youngdale (ericy@cais.com).\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/binfmts.h>\n#include <linux/string.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/personality.h>\n#include <linux/elfcore.h>\n#include <linux/init.h>\n#include <linux/highuid.h>\n#include <linux/compiler.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/security.h>\n#include <linux/random.h>\n#include <linux/elf.h>\n#include <linux/utsname.h>\n#include <linux/coredump.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/page.h>\n\nstatic int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs);\nstatic int load_elf_library(struct file *);\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\n/*\n * If we don't support core dumping, then supply a NULL so we\n * don't even try.\n */\n#ifdef CONFIG_ELF_CORE\nstatic int elf_core_dump(struct coredump_params *cprm);\n#else\n#define elf_core_dump\tNULL\n#endif\n\n#if ELF_EXEC_PAGESIZE > PAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n#else\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#endif\n\n#ifndef ELF_CORE_EFLAGS\n#define ELF_CORE_EFLAGS\t0\n#endif\n\n#define ELF_PAGESTART(_v) ((_v) & ~(unsigned long)(ELF_MIN_ALIGN-1))\n#define ELF_PAGEOFFSET(_v) ((_v) & (ELF_MIN_ALIGN-1))\n#define ELF_PAGEALIGN(_v) (((_v) + ELF_MIN_ALIGN - 1) & ~(ELF_MIN_ALIGN - 1))\n\nstatic struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\n#define BAD_ADDR(x) ((unsigned long)(x) >= TASK_SIZE)\n\nstatic int set_brk(unsigned long start, unsigned long end)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\tunsigned long addr;\n\t\tdown_write(&current->mm->mmap_sem);\n\t\taddr = do_brk(start, end - start);\n\t\tup_write(&current->mm->mmap_sem);\n\t\tif (BAD_ADDR(addr))\n\t\t\treturn addr;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}\n\n/* We need to explicitly zero any fractional pages\n   after the data section (i.e. bss).  This would\n   contain the junk from the file that should not\n   be in memory\n */\nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n/* Let's use some macros to make this stack manipulation a little clearer */\n#ifdef CONFIG_STACK_GROWSUP\n#define STACK_ADD(sp, items) ((elf_addr_t __user *)(sp) + (items))\n#define STACK_ROUND(sp, items) \\\n\t((15 + (unsigned long) ((sp) + (items))) &~ 15UL)\n#define STACK_ALLOC(sp, len) ({ \\\n\telf_addr_t __user *old_sp = (elf_addr_t __user *)sp; sp += len; \\\n\told_sp; })\n#else\n#define STACK_ADD(sp, items) ((elf_addr_t __user *)(sp) - (items))\n#define STACK_ROUND(sp, items) \\\n\t(((unsigned long) (sp - items)) &~ 15UL)\n#define STACK_ALLOC(sp, len) ({ sp -= len ; sp; })\n#endif\n\n#ifndef ELF_BASE_PLATFORM\n/*\n * AT_BASE_PLATFORM indicates the \"real\" hardware/microarchitecture.\n * If the arch defines ELF_BASE_PLATFORM (in asm/elf.h), the value\n * will be copied to the user stack in the same manner as AT_PLATFORM.\n */\n#define ELF_BASE_PLATFORM NULL\n#endif\n\nstatic int\ncreate_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,\n\t\tunsigned long load_addr, unsigned long interp_load_addr)\n{\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *argv;\n\telf_addr_t __user *envp;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\tint ei_index = 0;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In some cases (e.g. Hyper-Threading), we want to avoid L1\n\t * evictions by the processes running on the same package. One\n\t * thing we can do is to shuffle the initial stack for them.\n\t */\n\n\tp = arch_align_stack(p);\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Generate 16 random bytes for userspace PRNG seeding.\n\t */\n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t/* Create the ELF interpreter info */\n\telf_info = (elf_addr_t *)current->mm->saved_auxv;\n\t/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */\n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\telf_info[ei_index++] = id; \\\n\t\telf_info[ei_index++] = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t/* \n\t * ARCH_DLINFO must come first so PPC can do its special alignment of\n\t * AUXV.\n\t * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in\n\t * ARCH_DLINFO changes\n\t */\n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tNEW_AUX_ENT(AT_FLAGS, 0);\n\tNEW_AUX_ENT(AT_ENTRY, exec->e_entry);\n\tNEW_AUX_ENT(AT_UID, cred->uid);\n\tNEW_AUX_ENT(AT_EUID, cred->euid);\n\tNEW_AUX_ENT(AT_GID, cred->gid);\n\tNEW_AUX_ENT(AT_EGID, cred->egid);\n \tNEW_AUX_ENT(AT_SECURE, security_bprm_secureexec(bprm));\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n#undef NEW_AUX_ENT\n\t/* AT_NULL is zero; clear the rest too */\n\tmemset(&elf_info[ei_index], 0,\n\t       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);\n\n\t/* And advance past the AT_NULL entry.  */\n\tei_index += 2;\n\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t/* Point sp at the lowest address on the stack */\n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp; /* XXX: PARISC HACK */\n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t/*\n\t * Grow the stack manually; some architectures have a limit on how\n\t * far ahead a user-space access may be in order to grow the stack.\n\t */\n\tvma = find_extend_vma(current->mm, bprm->p);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t/* Now, let's put argc (and argv, envp if appropriate) on the stack */\n\tif (__put_user(argc, sp++))\n\t\treturn -EFAULT;\n\targv = sp;\n\tenvp = argv + argc + 1;\n\n\t/* Populate argv and envp */\n\tp = current->mm->arg_end = current->mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, argv++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, argv))\n\t\treturn -EFAULT;\n\tcurrent->mm->arg_end = current->mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, envp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, envp))\n\t\treturn -EFAULT;\n\tcurrent->mm->env_end = p;\n\n\t/* Put the elf_info on the stack in the right place.  */\n\tsp = (elf_addr_t __user *)envp + 1;\n\tif (copy_to_user(sp, elf_info, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\tdown_write(&current->mm->mmap_sem);\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = do_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tdo_munmap(current->mm, map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = do_mmap(filep, addr, size, prot, type, off);\n\n\tup_write(&current->mm->mmap_sem);\n\treturn(map_addr);\n}\n\nstatic unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}\n\n\n/* This is much more generalized than the library routine read function,\n   so we keep this separate.  Technically the library read function\n   is only provided so that we can read a.out libraries that have\n   an ELF header */\n\nstatic unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter, unsigned long *interp_map_addr,\n\t\tunsigned long no_base)\n{\n\tstruct elf_phdr *elf_phdata;\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint retval, i, size;\n\n\t/* First of all, some simple consistency checks */\n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op || !interpreter->f_op->mmap)\n\t\tgoto out;\n\n\t/*\n\t * If the size of this structure has changed, then punt, since\n\t * we will be doing the wrong thing.\n\t */\n\tif (interp_elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\tif (interp_elf_ex->e_phnum < 1 ||\n\t\tinterp_elf_ex->e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* Now read in all of the header information */\n\tsize = sizeof(struct elf_phdr) * interp_elf_ex->e_phnum;\n\tif (size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\tretval = kernel_read(interpreter, interp_elf_ex->e_phoff,\n\t\t\t     (char *)elf_phdata, size);\n\terror = -EIO;\n\tif (retval != size) {\n\t\tif (retval < 0)\n\t\t\terror = retval;\t\n\t\tgoto out_close;\n\t}\n\n\ttotal_size = total_mapping_size(elf_phdata, interp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out_close;\n\t}\n\n\teppnt = elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\n\t\t\tint elf_prot = 0;\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tif (eppnt->p_flags & PF_R)\n\t\t    \t\telf_prot = PROT_READ;\n\t\t\tif (eppnt->p_flags & PF_W)\n\t\t\t\telf_prot |= PROT_WRITE;\n\t\t\tif (eppnt->p_flags & PF_X)\n\t\t\t\telf_prot |= PROT_EXEC;\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\tif (!*interp_map_addr)\n\t\t\t\t*interp_map_addr = map_addr;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out_close;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check to see if the section's size will overflow the\n\t\t\t * allowed task size. Note that p_filesz must always be\n\t\t\t * <= p_memsize so it's only necessary to check p_memsz.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the end of the file mapping for this phdr, and\n\t\t\t * keep track of the largest address we see for this.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t/*\n\t\t\t * Do the same thing for the memory mapping - between\n\t\t\t * elf_bss and last_bss is the bss section.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_memsz + eppnt->p_vaddr;\n\t\t\tif (k > last_bss)\n\t\t\t\tlast_bss = k;\n\t\t}\n\t}\n\n\tif (last_bss > elf_bss) {\n\t\t/*\n\t\t * Now fill out the bss section.  First pad the last page up\n\t\t * to the page boundary, and then perform a mmap to make sure\n\t\t * that there are zero-mapped pages up to and including the\n\t\t * last bss page.\n\t\t */\n\t\tif (padzero(elf_bss)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out_close;\n\t\t}\n\n\t\t/* What we have mapped so far */\n\t\telf_bss = ELF_PAGESTART(elf_bss + ELF_MIN_ALIGN - 1);\n\n\t\t/* Map the last of the bss segment */\n\t\tdown_write(&current->mm->mmap_sem);\n\t\terror = do_brk(elf_bss, last_bss - elf_bss);\n\t\tup_write(&current->mm->mmap_sem);\n\t\tif (BAD_ADDR(error))\n\t\t\tgoto out_close;\n\t}\n\n\terror = load_addr;\n\nout_close:\n\tkfree(elf_phdata);\nout:\n\treturn error;\n}\n\n/*\n * These are the functions used to load ELF style executables and shared\n * libraries.  There is no binary dependent code anywhere else.\n */\n\n#define INTERPRETER_NONE 0\n#define INTERPRETER_ELF 2\n\n#ifndef STACK_RND_MASK\n#define STACK_RND_MASK (0x7ff >> (PAGE_SHIFT - 12))\t/* 8MB of VA */\n#endif\n\nstatic unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned int random_variable = 0;\n\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}\n\nstatic int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned int size;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tunsigned long def_flags = 0;\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op || !bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\t/* Now read in all of the header information */\n\tif (loc->elf_ex.e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\tif (loc->elf_ex.e_phnum < 1 ||\n\t \tloc->elf_ex.e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\tgoto out;\n\tsize = loc->elf_ex.e_phnum * sizeof(struct elf_phdr);\n\tretval = -ENOMEM;\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\tretval = kernel_read(bprm->file, loc->elf_ex.e_phoff,\n\t\t\t     (char *)elf_phdata, size);\n\tif (retval != size) {\n\t\tif (retval >= 0)\n\t\t\tretval = -EIO;\n\t\tgoto out_free_ph;\n\t}\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tif (elf_ppnt->p_type == PT_GNU_STACK) {\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* OK, This is the point of no return */\n\tcurrent->flags &= ~PF_FORKNOEXEC;\n\tcurrent->mm->def_flags = def_flags;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY(loc->elf_ex);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tcurrent->mm->free_area_cache = current->mm->mmap_base;\n\tcurrent->mm->cached_hole_size = 0;\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0) {\n\t\tsend_sig(SIGKILL, current, 0);\n\t\tgoto out_free_dentry;\n\t}\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval) {\n\t\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, 0);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval) {\n\t\tsend_sig(SIGKILL, current, 0);\n\t\tgoto out_free_dentry;\n\t}\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tsend_sig(SIGSEGV, current, 0);\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long uninitialized_var(interp_map_addr);\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tforce_sig(SIGSEGV, current);\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tforce_sig(SIGSEGV, current);\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0) {\n\t\tsend_sig(SIGKILL, current, 0);\n\t\tgoto out;\n\t}\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tcurrent->flags &= ~PF_FORKNOEXEC;\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0) {\n\t\tsend_sig(SIGKILL, current, 0);\n\t\tgoto out;\n\t}\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\tdown_write(&current->mm->mmap_sem);\n\t\terror = do_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t\tup_write(&current->mm->mmap_sem);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}\n\n/* This is really simpleminded and specialized - we are loading an\n   a.out library that is given an ELF header. */\nstatic int load_elf_library(struct file *file)\n{\n\tstruct elf_phdr *elf_phdata;\n\tstruct elf_phdr *eppnt;\n\tunsigned long elf_bss, bss, len;\n\tint retval, error, i, j;\n\tstruct elfhdr elf_ex;\n\n\terror = -ENOEXEC;\n\tretval = kernel_read(file, 0, (char *)&elf_ex, sizeof(elf_ex));\n\tif (retval != sizeof(elf_ex))\n\t\tgoto out;\n\n\tif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t/* First of all, some simple consistency checks */\n\tif (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||\n\t    !elf_check_arch(&elf_ex) || !file->f_op || !file->f_op->mmap)\n\t\tgoto out;\n\n\t/* Now read in all of the header information */\n\n\tj = sizeof(struct elf_phdr) * elf_ex.e_phnum;\n\t/* j < ELF_MIN_ALIGN because elf_ex.e_phnum <= 2 */\n\n\terror = -ENOMEM;\n\telf_phdata = kmalloc(j, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\teppnt = elf_phdata;\n\terror = -ENOEXEC;\n\tretval = kernel_read(file, elf_ex.e_phoff, (char *)eppnt, j);\n\tif (retval != j)\n\t\tgoto out_free_ph;\n\n\tfor (j = 0, i = 0; i<elf_ex.e_phnum; i++)\n\t\tif ((eppnt + i)->p_type == PT_LOAD)\n\t\t\tj++;\n\tif (j != 1)\n\t\tgoto out_free_ph;\n\n\twhile (eppnt->p_type != PT_LOAD)\n\t\teppnt++;\n\n\t/* Now use mmap to map the library into memory. */\n\tdown_write(&current->mm->mmap_sem);\n\terror = do_mmap(file,\n\t\t\tELF_PAGESTART(eppnt->p_vaddr),\n\t\t\t(eppnt->p_filesz +\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)),\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\t(eppnt->p_offset -\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)));\n\tup_write(&current->mm->mmap_sem);\n\tif (error != ELF_PAGESTART(eppnt->p_vaddr))\n\t\tgoto out_free_ph;\n\n\telf_bss = eppnt->p_vaddr + eppnt->p_filesz;\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out_free_ph;\n\t}\n\n\tlen = ELF_PAGESTART(eppnt->p_filesz + eppnt->p_vaddr +\n\t\t\t    ELF_MIN_ALIGN - 1);\n\tbss = eppnt->p_memsz + eppnt->p_vaddr;\n\tif (bss > len) {\n\t\tdown_write(&current->mm->mmap_sem);\n\t\tdo_brk(len, bss - len);\n\t\tup_write(&current->mm->mmap_sem);\n\t}\n\terror = 0;\n\nout_free_ph:\n\tkfree(elf_phdata);\nout:\n\treturn error;\n}\n\n#ifdef CONFIG_ELF_CORE\n/*\n * ELF core dumper\n *\n * Modelled on fs/exec.c:aout_core_dump()\n * Jeremy Fitzhardinge <jeremy@sw.oz.au>\n */\n\n/*\n * Decide what to dump of a segment, part, all or none.\n */\nstatic unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* The vma can be set up to tell us the answer directly.  */\n\tif (vma->vm_flags & VM_ALWAYSDUMP)\n\t\tgoto whole;\n\n\t/* Hugetlb memory check */\n\tif (vma->vm_flags & VM_HUGETLB) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & (VM_IO | VM_RESERVED))\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (vma->vm_file->f_path.dentry->d_inode->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}\n\n/* An ELF note in memory */\nstruct memelfnote\n{\n\tconst char *name;\n\tint type;\n\tunsigned int datasz;\n\tvoid *data;\n};\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}\n\n#define DUMP_WRITE(addr, nr, foffset)\t\\\n\tdo { if (!dump_write(file, (addr), (nr))) return 0; *foffset += (nr); } while(0)\n\nstatic int alignfile(struct file *file, loff_t *foffset)\n{\n\tstatic const char buf[4] = { 0, };\n\tDUMP_WRITE(buf, roundup(*foffset, 4) - *foffset, foffset);\n\treturn 1;\n}\n\nstatic int writenote(struct memelfnote *men, struct file *file,\n\t\t\tloff_t *foffset)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\tDUMP_WRITE(&en, sizeof(en), foffset);\n\tDUMP_WRITE(men->name, en.n_namesz, foffset);\n\tif (!alignfile(file, foffset))\n\t\treturn 0;\n\tDUMP_WRITE(men->data, men->datasz, foffset);\n\tif (!alignfile(file, foffset))\n\t\treturn 0;\n\n\treturn 1;\n}\n#undef DUMP_WRITE\n\nstatic void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags, u8 osabi)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}\n\nstatic void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}\n\nstatic void fill_note(struct memelfnote *note, const char *name, int type, \n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}\n\n/*\n * fill up all the fields in prstatus from the given task struct, except\n * registers which need to be filled up separately.\n */\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tcputime_to_timeval(cputime.utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(cputime.stime, &prstatus->pr_stime);\n\t} else {\n\t\tcputime_to_timeval(p->utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(p->stime, &prstatus->pr_stime);\n\t}\n\tcputime_to_timeval(p->signal->cutime, &prstatus->pr_cutime);\n\tcputime_to_timeval(p->signal->cstime, &prstatus->pr_cstime);\n}\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, cred->uid);\n\tSET_GID(psinfo->pr_gid, cred->gid);\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}\n\nstatic void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}\n\n#ifdef CORE_DUMP_USE_REGSET\n#include <linux/regset.h>\n\nstruct elf_thread_core_info {\n\tstruct elf_thread_core_info *next;\n\tstruct task_struct *task;\n\tstruct elf_prstatus prstatus;\n\tstruct memelfnote notes[0];\n};\n\nstruct elf_note_info {\n\tstruct elf_thread_core_info *thread;\n\tstruct memelfnote psinfo;\n\tstruct memelfnote auxv;\n\tsize_t size;\n\tint thread_notes;\n};\n\n/*\n * When a regset has a writeback hook, we call it on each thread before\n * dumping user memory.  On register window machines, this makes sure the\n * user memory backing the register data is up to date before we read it.\n */\nstatic void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}\n\nstatic int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type &&\n\t\t    (!regset->active || regset->active(t->task, regset))) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  long signr, struct pt_regs *regs)\n{\n\tstruct task_struct *dump_task = current;\n\tconst struct user_regset_view *view = task_user_regset_view(dump_task);\n\tstruct elf_thread_core_info *t;\n\tstruct elf_prpsinfo *psinfo;\n\tstruct core_thread *ct;\n\tunsigned int i;\n\n\tinfo->size = 0;\n\tinfo->thread = NULL;\n\n\tpsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\n\tif (psinfo == NULL)\n\t\treturn 0;\n\n\tfill_note(&info->psinfo, \"CORE\", NT_PRPSINFO, sizeof(*psinfo), psinfo);\n\n\t/*\n\t * Figure out how many notes we're going to need for each thread.\n\t */\n\tinfo->thread_notes = 0;\n\tfor (i = 0; i < view->n; ++i)\n\t\tif (view->regsets[i].core_note_type != 0)\n\t\t\t++info->thread_notes;\n\n\t/*\n\t * Sanity check.  We rely on regset 0 being in NT_PRSTATUS,\n\t * since it is our one special case.\n\t */\n\tif (unlikely(info->thread_notes == 0) ||\n\t    unlikely(view->regsets[0].core_note_type != NT_PRSTATUS)) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Initialize the ELF file header.\n\t */\n\tfill_elf_header(elf, phdrs,\n\t\t\tview->e_machine, view->e_flags, view->ei_osabi);\n\n\t/*\n\t * Allocate a structure for each thread.\n\t */\n\tfor (ct = &dump_task->mm->core_state->dumper; ct; ct = ct->next) {\n\t\tt = kzalloc(offsetof(struct elf_thread_core_info,\n\t\t\t\t     notes[info->thread_notes]),\n\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(!t))\n\t\t\treturn 0;\n\n\t\tt->task = ct->task;\n\t\tif (ct->task == dump_task || !info->thread) {\n\t\t\tt->next = info->thread;\n\t\t\tinfo->thread = t;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make sure to keep the original task at\n\t\t\t * the head of the list.\n\t\t\t */\n\t\t\tt->next = info->thread->next;\n\t\t\tinfo->thread->next = t;\n\t\t}\n\t}\n\n\t/*\n\t * Now fill in each thread's information.\n\t */\n\tfor (t = info->thread; t != NULL; t = t->next)\n\t\tif (!fill_thread_core_info(t, view, signr, &info->size))\n\t\t\treturn 0;\n\n\t/*\n\t * Fill in the two process-wide notes.\n\t */\n\tfill_psinfo(psinfo, dump_task->group_leader, dump_task->mm);\n\tinfo->size += notesize(&info->psinfo);\n\n\tfill_auxv_note(&info->auxv, current->mm);\n\tinfo->size += notesize(&info->auxv);\n\n\treturn 1;\n}\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\treturn info->size;\n}\n\n/*\n * Write all the notes for each thread.  When writing the first thread, the\n * process-wide notes are interleaved after the first thread-specific note.\n */\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct file *file, loff_t *foffset)\n{\n\tbool first = 1;\n\tstruct elf_thread_core_info *t = info->thread;\n\n\tdo {\n\t\tint i;\n\n\t\tif (!writenote(&t->notes[0], file, foffset))\n\t\t\treturn 0;\n\n\t\tif (first && !writenote(&info->psinfo, file, foffset))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->auxv, file, foffset))\n\t\t\treturn 0;\n\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tif (t->notes[i].data &&\n\t\t\t    !writenote(&t->notes[i], file, foffset))\n\t\t\t\treturn 0;\n\n\t\tfirst = 0;\n\t\tt = t->next;\n\t} while (t);\n\n\treturn 1;\n}\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\tstruct elf_thread_core_info *threads = info->thread;\n\twhile (threads) {\n\t\tunsigned int i;\n\t\tstruct elf_thread_core_info *t = threads;\n\t\tthreads = t->next;\n\t\tWARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tkfree(t->notes[i].data);\n\t\tkfree(t);\n\t}\n\tkfree(info->psinfo.data);\n}\n\n#else\n\n/* Here is the structure in which status of each thread is captured. */\nstruct elf_thread_status\n{\n\tstruct list_head list;\n\tstruct elf_prstatus prstatus;\t/* NT_PRSTATUS */\n\telf_fpregset_t fpu;\t\t/* NT_PRFPREG */\n\tstruct task_struct *thread;\n#ifdef ELF_CORE_COPY_XFPREGS\n\telf_fpxregset_t xfpu;\t\t/* ELF_CORE_XFPREG_TYPE */\n#endif\n\tstruct memelfnote notes[3];\n\tint num_notes;\n};\n\n/*\n * In order to add the specific thread information for the elf file format,\n * we need to keep a linked list of every threads pr_status and then create\n * a single section for them in the final core file.\n */\nstatic int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}\n\nstruct elf_note_info {\n\tstruct memelfnote *notes;\n\tstruct elf_prstatus *prstatus;\t/* NT_PRSTATUS */\n\tstruct elf_prpsinfo *psinfo;\t/* NT_PRPSINFO */\n\tstruct list_head thread_list;\n\telf_fpregset_t *fpu;\n#ifdef ELF_CORE_COPY_XFPREGS\n\telf_fpxregset_t *xfpu;\n#endif\n\tint thread_status_size;\n\tint numnote;\n};\n\nstatic int elf_note_info_init(struct elf_note_info *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tINIT_LIST_HEAD(&info->thread_list);\n\n\t/* Allocate space for six ELF notes */\n\tinfo->notes = kmalloc(6 * sizeof(struct memelfnote), GFP_KERNEL);\n\tif (!info->notes)\n\t\treturn 0;\n\tinfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\n\tif (!info->psinfo)\n\t\tgoto notes_free;\n\tinfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\n\tif (!info->prstatus)\n\t\tgoto psinfo_free;\n\tinfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\n\tif (!info->fpu)\n\t\tgoto prstatus_free;\n#ifdef ELF_CORE_COPY_XFPREGS\n\tinfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\n\tif (!info->xfpu)\n\t\tgoto fpu_free;\n#endif\n\treturn 1;\n#ifdef ELF_CORE_COPY_XFPREGS\n fpu_free:\n\tkfree(info->fpu);\n#endif\n prstatus_free:\n\tkfree(info->prstatus);\n psinfo_free:\n\tkfree(info->psinfo);\n notes_free:\n\tkfree(info->notes);\n\treturn 0;\n}\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  long signr, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tif (signr) {\n\t\tstruct core_thread *ct;\n\t\tstruct elf_thread_status *ets;\n\n\t\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\t\tct; ct = ct->next) {\n\t\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\t\tif (!ets)\n\t\t\t\treturn 0;\n\n\t\t\tets->thread = ct->task;\n\t\t\tlist_add(&ets->list, &info->thread_list);\n\t\t}\n\n\t\tlist_for_each(t, &info->thread_list) {\n\t\t\tint sz;\n\n\t\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\t\tsz = elf_dump_thread_status(signr, ets);\n\t\t\tinfo->thread_status_size += sz;\n\t\t}\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, signr);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS, ELF_OSABI);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tinfo->numnote = 2;\n\n\tfill_auxv_note(&info->notes[info->numnote++], current->mm);\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\tint sz = 0;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tsz += notesize(info->notes + i);\n\n\tsz += info->thread_status_size;\n\n\treturn sz;\n}\n\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct file *file, loff_t *foffset)\n{\n\tint i;\n\tstruct list_head *t;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tif (!writenote(info->notes + i, file, foffset))\n\t\t\treturn 0;\n\n\t/* write out the thread status notes section */\n\tlist_for_each(t, &info->thread_list) {\n\t\tstruct elf_thread_status *tmp =\n\t\t\t\tlist_entry(t, struct elf_thread_status, list);\n\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], file, foffset))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\twhile (!list_empty(&info->thread_list)) {\n\t\tstruct list_head *tmp = info->thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\n\tkfree(info->prstatus);\n\tkfree(info->psinfo);\n\tkfree(info->notes);\n\tkfree(info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(info->xfpu);\n#endif\n}\n\n#endif\n\nstatic struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}\n/*\n * Helper function for iterating across a vma list.  It ensures that the caller\n * will visit `gate_vma' prior to terminating the search.\n */\nstatic struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret;\n\n\tret = this_vma->vm_next;\n\tif (ret)\n\t\treturn ret;\n\tif (this_vma == gate_vma)\n\t\treturn NULL;\n\treturn gate_vma;\n}\n\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}\n\nstatic size_t elf_core_vma_data_size(struct vm_area_struct *gate_vma,\n\t\t\t\t     unsigned long mm_flags)\n{\n\tstruct vm_area_struct *vma;\n\tsize_t size = 0;\n\n\tfor (vma = first_vma(current, gate_vma); vma != NULL;\n\t     vma = next_vma(vma, gate_vma))\n\t\tsize += vma_dump_size(vma, mm_flags);\n\treturn size;\n}\n\n/*\n * Actual dumper\n *\n * This is a two-pass process; first we find the offsets of the bits,\n * and then they are actually written out.  If we run out of core limit\n * we just truncate.\n */\nstatic int elf_core_dump(struct coredump_params *cprm)\n{\n\tint has_dumped = 0;\n\tmm_segment_t fs;\n\tint segs;\n\tsize_t size = 0;\n\tstruct vm_area_struct *vma, *gate_vma;\n\tstruct elfhdr *elf = NULL;\n\tloff_t offset = 0, dataoff, foffset;\n\tstruct elf_note_info info;\n\tstruct elf_phdr *phdr4note = NULL;\n\tstruct elf_shdr *shdr4extnum = NULL;\n\tElf_Half e_phnum;\n\telf_addr_t e_shoff;\n\n\t/*\n\t * We no longer stop all VM operations.\n\t * \n\t * This is because those proceses that could possibly change map_count\n\t * or the mmap / vma pages are now blocked in do_exit on current\n\t * finishing this core dump.\n\t *\n\t * Only ptrace can touch these memory addresses, but it doesn't change\n\t * the map_count or the pages allocated. So no possibility of crashing\n\t * exists while dumping the mm->vm_next areas to the core file.\n\t */\n  \n\t/* alloc memory for large data structures: too large to be on stack */\n\telf = kmalloc(sizeof(*elf), GFP_KERNEL);\n\tif (!elf)\n\t\tgoto out;\n\t/*\n\t * The number of segs are recored into ELF header as 16bit value.\n\t * Please check DEFAULT_MAX_MAP_COUNT definition when you modify here.\n\t */\n\tsegs = current->mm->map_count;\n\tsegs += elf_core_extra_phdrs();\n\n\tgate_vma = get_gate_vma(current->mm);\n\tif (gate_vma != NULL)\n\t\tsegs++;\n\n\t/* for notes section */\n\tsegs++;\n\n\t/* If segs > PN_XNUM(0xffff), then e_phnum overflows. To avoid\n\t * this, kernel supports extended numbering. Have a look at\n\t * include/linux/elf.h for further information. */\n\te_phnum = segs > PN_XNUM ? PN_XNUM : segs;\n\n\t/*\n\t * Collect all the non-memory information about the process for the\n\t * notes.  This also sets up the file header.\n\t */\n\tif (!fill_note_info(elf, e_phnum, &info, cprm->signr, cprm->regs))\n\t\tgoto cleanup;\n\n\thas_dumped = 1;\n\tcurrent->flags |= PF_DUMPCORE;\n  \n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\toffset += sizeof(*elf);\t\t\t\t/* Elf header */\n\toffset += segs * sizeof(struct elf_phdr);\t/* Program headers */\n\tfoffset = offset;\n\n\t/* Write notes phdr entry */\n\t{\n\t\tsize_t sz = get_note_info_size(&info);\n\n\t\tsz += elf_coredump_extra_notes_size();\n\n\t\tphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\n\t\tif (!phdr4note)\n\t\t\tgoto end_coredump;\n\n\t\tfill_elf_note_phdr(phdr4note, sz, offset);\n\t\toffset += sz;\n\t}\n\n\tdataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\toffset += elf_core_vma_data_size(gate_vma, cprm->mm_flags);\n\toffset += elf_core_extra_data_size();\n\te_shoff = offset;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\n\t\tif (!shdr4extnum)\n\t\t\tgoto end_coredump;\n\t\tfill_extnum_info(elf, shdr4extnum, e_shoff, segs);\n\t}\n\n\toffset = dataoff;\n\n\tsize += sizeof(*elf);\n\tif (size > cprm->limit || !dump_write(cprm->file, elf, sizeof(*elf)))\n\t\tgoto end_coredump;\n\n\tsize += sizeof(*phdr4note);\n\tif (size > cprm->limit\n\t    || !dump_write(cprm->file, phdr4note, sizeof(*phdr4note)))\n\t\tgoto end_coredump;\n\n\t/* Write program headers for segments dump */\n\tfor (vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tstruct elf_phdr phdr;\n\n\t\tphdr.p_type = PT_LOAD;\n\t\tphdr.p_offset = offset;\n\t\tphdr.p_vaddr = vma->vm_start;\n\t\tphdr.p_paddr = 0;\n\t\tphdr.p_filesz = vma_dump_size(vma, cprm->mm_flags);\n\t\tphdr.p_memsz = vma->vm_end - vma->vm_start;\n\t\toffset += phdr.p_filesz;\n\t\tphdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tphdr.p_flags |= PF_W;\n\t\tif (vma->vm_flags & VM_EXEC)\n\t\t\tphdr.p_flags |= PF_X;\n\t\tphdr.p_align = ELF_EXEC_PAGESIZE;\n\n\t\tsize += sizeof(phdr);\n\t\tif (size > cprm->limit\n\t\t    || !dump_write(cprm->file, &phdr, sizeof(phdr)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_phdrs(cprm->file, offset, &size, cprm->limit))\n\t\tgoto end_coredump;\n\n \t/* write out the notes section */\n\tif (!write_note_info(&info, cprm->file, &foffset))\n\t\tgoto end_coredump;\n\n\tif (elf_coredump_extra_notes_write(cprm->file, &foffset))\n\t\tgoto end_coredump;\n\n\t/* Align to page */\n\tif (!dump_seek(cprm->file, dataoff - foffset))\n\t\tgoto end_coredump;\n\n\tfor (vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long addr;\n\t\tunsigned long end;\n\n\t\tend = vma->vm_start + vma_dump_size(vma, cprm->mm_flags);\n\n\t\tfor (addr = vma->vm_start; addr < end; addr += PAGE_SIZE) {\n\t\t\tstruct page *page;\n\t\t\tint stop;\n\n\t\t\tpage = get_dump_page(addr);\n\t\t\tif (page) {\n\t\t\t\tvoid *kaddr = kmap(page);\n\t\t\t\tstop = ((size += PAGE_SIZE) > cprm->limit) ||\n\t\t\t\t\t!dump_write(cprm->file, kaddr,\n\t\t\t\t\t\t    PAGE_SIZE);\n\t\t\t\tkunmap(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t} else\n\t\t\t\tstop = !dump_seek(cprm->file, PAGE_SIZE);\n\t\t\tif (stop)\n\t\t\t\tgoto end_coredump;\n\t\t}\n\t}\n\n\tif (!elf_core_write_extra_data(cprm->file, &size, cprm->limit))\n\t\tgoto end_coredump;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tsize += sizeof(*shdr4extnum);\n\t\tif (size > cprm->limit\n\t\t    || !dump_write(cprm->file, shdr4extnum,\n\t\t\t\t   sizeof(*shdr4extnum)))\n\t\t\tgoto end_coredump;\n\t}\n\nend_coredump:\n\tset_fs(fs);\n\ncleanup:\n\tfree_note_info(&info);\n\tkfree(shdr4extnum);\n\tkfree(phdr4note);\n\tkfree(elf);\nout:\n\treturn has_dumped;\n}\n\n#endif\t\t/* CONFIG_ELF_CORE */\n\nstatic int __init init_elf_binfmt(void)\n{\n\treturn register_binfmt(&elf_format);\n}\n\nstatic void __exit exit_elf_binfmt(void)\n{\n\t/* Remove the COFF and ELF loaders. */\n\tunregister_binfmt(&elf_format);\n}\n\ncore_initcall(init_elf_binfmt);\nmodule_exit(exit_elf_binfmt);\nMODULE_LICENSE(\"GPL\");\n", "/*\n * User-mode machine state access\n *\n * Copyright (C) 2007 Red Hat, Inc.  All rights reserved.\n *\n * This copyrighted material is made available to anyone wishing to use,\n * modify, copy, or redistribute it subject to the terms and conditions\n * of the GNU General Public License v.2.\n *\n * Red Hat Author: Roland McGrath.\n */\n\n#ifndef _LINUX_REGSET_H\n#define _LINUX_REGSET_H\t1\n\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\nstruct task_struct;\nstruct user_regset;\n\n\n/**\n * user_regset_active_fn - type of @active function in &struct user_regset\n * @target:\tthread being examined\n * @regset:\tregset being examined\n *\n * Return -%ENODEV if not available on the hardware found.\n * Return %0 if no interesting state in this thread.\n * Return >%0 number of @size units of interesting state.\n * Any get call fetching state beyond that number will\n * see the default initialization state for this data,\n * so a caller that knows what the default state is need\n * not copy it all out.\n * This call is optional; the pointer is %NULL if there\n * is no inexpensive check to yield a value < @n.\n */\ntypedef int user_regset_active_fn(struct task_struct *target,\n\t\t\t\t  const struct user_regset *regset);\n\n/**\n * user_regset_get_fn - type of @get function in &struct user_regset\n * @target:\tthread being examined\n * @regset:\tregset being examined\n * @pos:\toffset into the regset data to access, in bytes\n * @count:\tamount of data to copy, in bytes\n * @kbuf:\tif not %NULL, a kernel-space pointer to copy into\n * @ubuf:\tif @kbuf is %NULL, a user-space pointer to copy into\n *\n * Fetch register values.  Return %0 on success; -%EIO or -%ENODEV\n * are usual failure returns.  The @pos and @count values are in\n * bytes, but must be properly aligned.  If @kbuf is non-null, that\n * buffer is used and @ubuf is ignored.  If @kbuf is %NULL, then\n * ubuf gives a userland pointer to access directly, and an -%EFAULT\n * return value is possible.\n */\ntypedef int user_regset_get_fn(struct task_struct *target,\n\t\t\t       const struct user_regset *regset,\n\t\t\t       unsigned int pos, unsigned int count,\n\t\t\t       void *kbuf, void __user *ubuf);\n\n/**\n * user_regset_set_fn - type of @set function in &struct user_regset\n * @target:\tthread being examined\n * @regset:\tregset being examined\n * @pos:\toffset into the regset data to access, in bytes\n * @count:\tamount of data to copy, in bytes\n * @kbuf:\tif not %NULL, a kernel-space pointer to copy from\n * @ubuf:\tif @kbuf is %NULL, a user-space pointer to copy from\n *\n * Store register values.  Return %0 on success; -%EIO or -%ENODEV\n * are usual failure returns.  The @pos and @count values are in\n * bytes, but must be properly aligned.  If @kbuf is non-null, that\n * buffer is used and @ubuf is ignored.  If @kbuf is %NULL, then\n * ubuf gives a userland pointer to access directly, and an -%EFAULT\n * return value is possible.\n */\ntypedef int user_regset_set_fn(struct task_struct *target,\n\t\t\t       const struct user_regset *regset,\n\t\t\t       unsigned int pos, unsigned int count,\n\t\t\t       const void *kbuf, const void __user *ubuf);\n\n/**\n * user_regset_writeback_fn - type of @writeback function in &struct user_regset\n * @target:\tthread being examined\n * @regset:\tregset being examined\n * @immediate:\tzero if writeback at completion of next context switch is OK\n *\n * This call is optional; usually the pointer is %NULL.  When\n * provided, there is some user memory associated with this regset's\n * hardware, such as memory backing cached register data on register\n * window machines; the regset's data controls what user memory is\n * used (e.g. via the stack pointer value).\n *\n * Write register data back to user memory.  If the @immediate flag\n * is nonzero, it must be written to the user memory so uaccess or\n * access_process_vm() can see it when this call returns; if zero,\n * then it must be written back by the time the task completes a\n * context switch (as synchronized with wait_task_inactive()).\n * Return %0 on success or if there was nothing to do, -%EFAULT for\n * a memory problem (bad stack pointer or whatever), or -%EIO for a\n * hardware problem.\n */\ntypedef int user_regset_writeback_fn(struct task_struct *target,\n\t\t\t\t     const struct user_regset *regset,\n\t\t\t\t     int immediate);\n\n/**\n * struct user_regset - accessible thread CPU state\n * @n:\t\t\tNumber of slots (registers).\n * @size:\t\tSize in bytes of a slot (register).\n * @align:\t\tRequired alignment, in bytes.\n * @bias:\t\tBias from natural indexing.\n * @core_note_type:\tELF note @n_type value used in core dumps.\n * @get:\t\tFunction to fetch values.\n * @set:\t\tFunction to store values.\n * @active:\t\tFunction to report if regset is active, or %NULL.\n * @writeback:\t\tFunction to write data back to user memory, or %NULL.\n *\n * This data structure describes a machine resource we call a register set.\n * This is part of the state of an individual thread, not necessarily\n * actual CPU registers per se.  A register set consists of a number of\n * similar slots, given by @n.  Each slot is @size bytes, and aligned to\n * @align bytes (which is at least @size).\n *\n * These functions must be called only on the current thread or on a\n * thread that is in %TASK_STOPPED or %TASK_TRACED state, that we are\n * guaranteed will not be woken up and return to user mode, and that we\n * have called wait_task_inactive() on.  (The target thread always might\n * wake up for SIGKILL while these functions are working, in which case\n * that thread's user_regset state might be scrambled.)\n *\n * The @pos argument must be aligned according to @align; the @count\n * argument must be a multiple of @size.  These functions are not\n * responsible for checking for invalid arguments.\n *\n * When there is a natural value to use as an index, @bias gives the\n * difference between the natural index and the slot index for the\n * register set.  For example, x86 GDT segment descriptors form a regset;\n * the segment selector produces a natural index, but only a subset of\n * that index space is available as a regset (the TLS slots); subtracting\n * @bias from a segment selector index value computes the regset slot.\n *\n * If nonzero, @core_note_type gives the n_type field (NT_* value)\n * of the core file note in which this regset's data appears.\n * NT_PRSTATUS is a special case in that the regset data starts at\n * offsetof(struct elf_prstatus, pr_reg) into the note data; that is\n * part of the per-machine ELF formats userland knows about.  In\n * other cases, the core file note contains exactly the whole regset\n * (@n * @size) and nothing else.  The core file note is normally\n * omitted when there is an @active function and it returns zero.\n */\nstruct user_regset {\n\tuser_regset_get_fn\t\t*get;\n\tuser_regset_set_fn\t\t*set;\n\tuser_regset_active_fn\t\t*active;\n\tuser_regset_writeback_fn\t*writeback;\n\tunsigned int\t\t\tn;\n\tunsigned int \t\t\tsize;\n\tunsigned int \t\t\talign;\n\tunsigned int \t\t\tbias;\n\tunsigned int \t\t\tcore_note_type;\n};\n\n/**\n * struct user_regset_view - available regsets\n * @name:\tIdentifier, e.g. UTS_MACHINE string.\n * @regsets:\tArray of @n regsets available in this view.\n * @n:\t\tNumber of elements in @regsets.\n * @e_machine:\tELF header @e_machine %EM_* value written in core dumps.\n * @e_flags:\tELF header @e_flags value written in core dumps.\n * @ei_osabi:\tELF header @e_ident[%EI_OSABI] value written in core dumps.\n *\n * A regset view is a collection of regsets (&struct user_regset,\n * above).  This describes all the state of a thread that can be seen\n * from a given architecture/ABI environment.  More than one view might\n * refer to the same &struct user_regset, or more than one regset\n * might refer to the same machine-specific state in the thread.  For\n * example, a 32-bit thread's state could be examined from the 32-bit\n * view or from the 64-bit view.  Either method reaches the same thread\n * register state, doing appropriate widening or truncation.\n */\nstruct user_regset_view {\n\tconst char *name;\n\tconst struct user_regset *regsets;\n\tunsigned int n;\n\tu32 e_flags;\n\tu16 e_machine;\n\tu8 ei_osabi;\n};\n\n/*\n * This is documented here rather than at the definition sites because its\n * implementation is machine-dependent but its interface is universal.\n */\n/**\n * task_user_regset_view - Return the process's native regset view.\n * @tsk: a thread of the process in question\n *\n * Return the &struct user_regset_view that is native for the given process.\n * For example, what it would access when it called ptrace().\n * Throughout the life of the process, this only changes at exec.\n */\nconst struct user_regset_view *task_user_regset_view(struct task_struct *tsk);\n\n\n/*\n * These are helpers for writing regset get/set functions in arch code.\n * Because @start_pos and @end_pos are always compile-time constants,\n * these are inlined into very little code though they look large.\n *\n * Use one or more calls sequentially for each chunk of regset data stored\n * contiguously in memory.  Call with constants for @start_pos and @end_pos,\n * giving the range of byte positions in the regset that data corresponds\n * to; @end_pos can be -1 if this chunk is at the end of the regset layout.\n * Each call updates the arguments to point past its chunk.\n */\n\nstatic inline int user_regset_copyout(unsigned int *pos, unsigned int *count,\n\t\t\t\t      void **kbuf,\n\t\t\t\t      void __user **ubuf, const void *data,\n\t\t\t\t      const int start_pos, const int end_pos)\n{\n\tif (*count == 0)\n\t\treturn 0;\n\tBUG_ON(*pos < start_pos);\n\tif (end_pos < 0 || *pos < end_pos) {\n\t\tunsigned int copy = (end_pos < 0 ? *count\n\t\t\t\t     : min(*count, end_pos - *pos));\n\t\tdata += *pos - start_pos;\n\t\tif (*kbuf) {\n\t\t\tmemcpy(*kbuf, data, copy);\n\t\t\t*kbuf += copy;\n\t\t} else if (__copy_to_user(*ubuf, data, copy))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\t*ubuf += copy;\n\t\t*pos += copy;\n\t\t*count -= copy;\n\t}\n\treturn 0;\n}\n\nstatic inline int user_regset_copyin(unsigned int *pos, unsigned int *count,\n\t\t\t\t     const void **kbuf,\n\t\t\t\t     const void __user **ubuf, void *data,\n\t\t\t\t     const int start_pos, const int end_pos)\n{\n\tif (*count == 0)\n\t\treturn 0;\n\tBUG_ON(*pos < start_pos);\n\tif (end_pos < 0 || *pos < end_pos) {\n\t\tunsigned int copy = (end_pos < 0 ? *count\n\t\t\t\t     : min(*count, end_pos - *pos));\n\t\tdata += *pos - start_pos;\n\t\tif (*kbuf) {\n\t\t\tmemcpy(data, *kbuf, copy);\n\t\t\t*kbuf += copy;\n\t\t} else if (__copy_from_user(data, *ubuf, copy))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\t*ubuf += copy;\n\t\t*pos += copy;\n\t\t*count -= copy;\n\t}\n\treturn 0;\n}\n\n/*\n * These two parallel the two above, but for portions of a regset layout\n * that always read as all-zero or for which writes are ignored.\n */\nstatic inline int user_regset_copyout_zero(unsigned int *pos,\n\t\t\t\t\t   unsigned int *count,\n\t\t\t\t\t   void **kbuf, void __user **ubuf,\n\t\t\t\t\t   const int start_pos,\n\t\t\t\t\t   const int end_pos)\n{\n\tif (*count == 0)\n\t\treturn 0;\n\tBUG_ON(*pos < start_pos);\n\tif (end_pos < 0 || *pos < end_pos) {\n\t\tunsigned int copy = (end_pos < 0 ? *count\n\t\t\t\t     : min(*count, end_pos - *pos));\n\t\tif (*kbuf) {\n\t\t\tmemset(*kbuf, 0, copy);\n\t\t\t*kbuf += copy;\n\t\t} else if (__clear_user(*ubuf, copy))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\t*ubuf += copy;\n\t\t*pos += copy;\n\t\t*count -= copy;\n\t}\n\treturn 0;\n}\n\nstatic inline int user_regset_copyin_ignore(unsigned int *pos,\n\t\t\t\t\t    unsigned int *count,\n\t\t\t\t\t    const void **kbuf,\n\t\t\t\t\t    const void __user **ubuf,\n\t\t\t\t\t    const int start_pos,\n\t\t\t\t\t    const int end_pos)\n{\n\tif (*count == 0)\n\t\treturn 0;\n\tBUG_ON(*pos < start_pos);\n\tif (end_pos < 0 || *pos < end_pos) {\n\t\tunsigned int copy = (end_pos < 0 ? *count\n\t\t\t\t     : min(*count, end_pos - *pos));\n\t\tif (*kbuf)\n\t\t\t*kbuf += copy;\n\t\telse\n\t\t\t*ubuf += copy;\n\t\t*pos += copy;\n\t\t*count -= copy;\n\t}\n\treturn 0;\n}\n\n/**\n * copy_regset_to_user - fetch a thread's user_regset data into user memory\n * @target:\tthread to be examined\n * @view:\t&struct user_regset_view describing user thread machine state\n * @setno:\tindex in @view->regsets\n * @offset:\toffset into the regset data, in bytes\n * @size:\tamount of data to copy, in bytes\n * @data:\tuser-mode pointer to copy into\n */\nstatic inline int copy_regset_to_user(struct task_struct *target,\n\t\t\t\t      const struct user_regset_view *view,\n\t\t\t\t      unsigned int setno,\n\t\t\t\t      unsigned int offset, unsigned int size,\n\t\t\t\t      void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\n\tif (!access_ok(VERIFY_WRITE, data, size))\n\t\treturn -EIO;\n\n\treturn regset->get(target, regset, offset, size, NULL, data);\n}\n\n/**\n * copy_regset_from_user - store into thread's user_regset data from user memory\n * @target:\tthread to be examined\n * @view:\t&struct user_regset_view describing user thread machine state\n * @setno:\tindex in @view->regsets\n * @offset:\toffset into the regset data, in bytes\n * @size:\tamount of data to copy, in bytes\n * @data:\tuser-mode pointer to copy from\n */\nstatic inline int copy_regset_from_user(struct task_struct *target,\n\t\t\t\t\tconst struct user_regset_view *view,\n\t\t\t\t\tunsigned int setno,\n\t\t\t\t\tunsigned int offset, unsigned int size,\n\t\t\t\t\tconst void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\n\tif (!access_ok(VERIFY_READ, data, size))\n\t\treturn -EIO;\n\n\treturn regset->set(target, regset, offset, size, NULL, data);\n}\n\n\n#endif\t/* <linux/regset.h> */\n"], "fixing_code": ["/*\n * linux/fs/binfmt_elf.c\n *\n * These are the functions used to load ELF format executables as used\n * on SVr4 machines.  Information on the format may be found in the book\n * \"UNIX SYSTEM V RELEASE 4 Programmers Guide: Ansi C and Programming Support\n * Tools\".\n *\n * Copyright 1993, 1994: Eric Youngdale (ericy@cais.com).\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/binfmts.h>\n#include <linux/string.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/personality.h>\n#include <linux/elfcore.h>\n#include <linux/init.h>\n#include <linux/highuid.h>\n#include <linux/compiler.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/security.h>\n#include <linux/random.h>\n#include <linux/elf.h>\n#include <linux/utsname.h>\n#include <linux/coredump.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/page.h>\n\nstatic int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs);\nstatic int load_elf_library(struct file *);\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\n/*\n * If we don't support core dumping, then supply a NULL so we\n * don't even try.\n */\n#ifdef CONFIG_ELF_CORE\nstatic int elf_core_dump(struct coredump_params *cprm);\n#else\n#define elf_core_dump\tNULL\n#endif\n\n#if ELF_EXEC_PAGESIZE > PAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n#else\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#endif\n\n#ifndef ELF_CORE_EFLAGS\n#define ELF_CORE_EFLAGS\t0\n#endif\n\n#define ELF_PAGESTART(_v) ((_v) & ~(unsigned long)(ELF_MIN_ALIGN-1))\n#define ELF_PAGEOFFSET(_v) ((_v) & (ELF_MIN_ALIGN-1))\n#define ELF_PAGEALIGN(_v) (((_v) + ELF_MIN_ALIGN - 1) & ~(ELF_MIN_ALIGN - 1))\n\nstatic struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\n#define BAD_ADDR(x) ((unsigned long)(x) >= TASK_SIZE)\n\nstatic int set_brk(unsigned long start, unsigned long end)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\tunsigned long addr;\n\t\tdown_write(&current->mm->mmap_sem);\n\t\taddr = do_brk(start, end - start);\n\t\tup_write(&current->mm->mmap_sem);\n\t\tif (BAD_ADDR(addr))\n\t\t\treturn addr;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}\n\n/* We need to explicitly zero any fractional pages\n   after the data section (i.e. bss).  This would\n   contain the junk from the file that should not\n   be in memory\n */\nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n/* Let's use some macros to make this stack manipulation a little clearer */\n#ifdef CONFIG_STACK_GROWSUP\n#define STACK_ADD(sp, items) ((elf_addr_t __user *)(sp) + (items))\n#define STACK_ROUND(sp, items) \\\n\t((15 + (unsigned long) ((sp) + (items))) &~ 15UL)\n#define STACK_ALLOC(sp, len) ({ \\\n\telf_addr_t __user *old_sp = (elf_addr_t __user *)sp; sp += len; \\\n\told_sp; })\n#else\n#define STACK_ADD(sp, items) ((elf_addr_t __user *)(sp) - (items))\n#define STACK_ROUND(sp, items) \\\n\t(((unsigned long) (sp - items)) &~ 15UL)\n#define STACK_ALLOC(sp, len) ({ sp -= len ; sp; })\n#endif\n\n#ifndef ELF_BASE_PLATFORM\n/*\n * AT_BASE_PLATFORM indicates the \"real\" hardware/microarchitecture.\n * If the arch defines ELF_BASE_PLATFORM (in asm/elf.h), the value\n * will be copied to the user stack in the same manner as AT_PLATFORM.\n */\n#define ELF_BASE_PLATFORM NULL\n#endif\n\nstatic int\ncreate_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,\n\t\tunsigned long load_addr, unsigned long interp_load_addr)\n{\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *argv;\n\telf_addr_t __user *envp;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\tint ei_index = 0;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In some cases (e.g. Hyper-Threading), we want to avoid L1\n\t * evictions by the processes running on the same package. One\n\t * thing we can do is to shuffle the initial stack for them.\n\t */\n\n\tp = arch_align_stack(p);\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Generate 16 random bytes for userspace PRNG seeding.\n\t */\n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t/* Create the ELF interpreter info */\n\telf_info = (elf_addr_t *)current->mm->saved_auxv;\n\t/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */\n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\telf_info[ei_index++] = id; \\\n\t\telf_info[ei_index++] = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t/* \n\t * ARCH_DLINFO must come first so PPC can do its special alignment of\n\t * AUXV.\n\t * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in\n\t * ARCH_DLINFO changes\n\t */\n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tNEW_AUX_ENT(AT_FLAGS, 0);\n\tNEW_AUX_ENT(AT_ENTRY, exec->e_entry);\n\tNEW_AUX_ENT(AT_UID, cred->uid);\n\tNEW_AUX_ENT(AT_EUID, cred->euid);\n\tNEW_AUX_ENT(AT_GID, cred->gid);\n\tNEW_AUX_ENT(AT_EGID, cred->egid);\n \tNEW_AUX_ENT(AT_SECURE, security_bprm_secureexec(bprm));\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n#undef NEW_AUX_ENT\n\t/* AT_NULL is zero; clear the rest too */\n\tmemset(&elf_info[ei_index], 0,\n\t       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);\n\n\t/* And advance past the AT_NULL entry.  */\n\tei_index += 2;\n\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t/* Point sp at the lowest address on the stack */\n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp; /* XXX: PARISC HACK */\n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t/*\n\t * Grow the stack manually; some architectures have a limit on how\n\t * far ahead a user-space access may be in order to grow the stack.\n\t */\n\tvma = find_extend_vma(current->mm, bprm->p);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t/* Now, let's put argc (and argv, envp if appropriate) on the stack */\n\tif (__put_user(argc, sp++))\n\t\treturn -EFAULT;\n\targv = sp;\n\tenvp = argv + argc + 1;\n\n\t/* Populate argv and envp */\n\tp = current->mm->arg_end = current->mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, argv++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, argv))\n\t\treturn -EFAULT;\n\tcurrent->mm->arg_end = current->mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, envp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, envp))\n\t\treturn -EFAULT;\n\tcurrent->mm->env_end = p;\n\n\t/* Put the elf_info on the stack in the right place.  */\n\tsp = (elf_addr_t __user *)envp + 1;\n\tif (copy_to_user(sp, elf_info, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\tdown_write(&current->mm->mmap_sem);\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = do_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tdo_munmap(current->mm, map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = do_mmap(filep, addr, size, prot, type, off);\n\n\tup_write(&current->mm->mmap_sem);\n\treturn(map_addr);\n}\n\nstatic unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}\n\n\n/* This is much more generalized than the library routine read function,\n   so we keep this separate.  Technically the library read function\n   is only provided so that we can read a.out libraries that have\n   an ELF header */\n\nstatic unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter, unsigned long *interp_map_addr,\n\t\tunsigned long no_base)\n{\n\tstruct elf_phdr *elf_phdata;\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint retval, i, size;\n\n\t/* First of all, some simple consistency checks */\n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op || !interpreter->f_op->mmap)\n\t\tgoto out;\n\n\t/*\n\t * If the size of this structure has changed, then punt, since\n\t * we will be doing the wrong thing.\n\t */\n\tif (interp_elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\tif (interp_elf_ex->e_phnum < 1 ||\n\t\tinterp_elf_ex->e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* Now read in all of the header information */\n\tsize = sizeof(struct elf_phdr) * interp_elf_ex->e_phnum;\n\tif (size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\tretval = kernel_read(interpreter, interp_elf_ex->e_phoff,\n\t\t\t     (char *)elf_phdata, size);\n\terror = -EIO;\n\tif (retval != size) {\n\t\tif (retval < 0)\n\t\t\terror = retval;\t\n\t\tgoto out_close;\n\t}\n\n\ttotal_size = total_mapping_size(elf_phdata, interp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out_close;\n\t}\n\n\teppnt = elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\n\t\t\tint elf_prot = 0;\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tif (eppnt->p_flags & PF_R)\n\t\t    \t\telf_prot = PROT_READ;\n\t\t\tif (eppnt->p_flags & PF_W)\n\t\t\t\telf_prot |= PROT_WRITE;\n\t\t\tif (eppnt->p_flags & PF_X)\n\t\t\t\telf_prot |= PROT_EXEC;\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\tif (!*interp_map_addr)\n\t\t\t\t*interp_map_addr = map_addr;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out_close;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check to see if the section's size will overflow the\n\t\t\t * allowed task size. Note that p_filesz must always be\n\t\t\t * <= p_memsize so it's only necessary to check p_memsz.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the end of the file mapping for this phdr, and\n\t\t\t * keep track of the largest address we see for this.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t/*\n\t\t\t * Do the same thing for the memory mapping - between\n\t\t\t * elf_bss and last_bss is the bss section.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_memsz + eppnt->p_vaddr;\n\t\t\tif (k > last_bss)\n\t\t\t\tlast_bss = k;\n\t\t}\n\t}\n\n\tif (last_bss > elf_bss) {\n\t\t/*\n\t\t * Now fill out the bss section.  First pad the last page up\n\t\t * to the page boundary, and then perform a mmap to make sure\n\t\t * that there are zero-mapped pages up to and including the\n\t\t * last bss page.\n\t\t */\n\t\tif (padzero(elf_bss)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out_close;\n\t\t}\n\n\t\t/* What we have mapped so far */\n\t\telf_bss = ELF_PAGESTART(elf_bss + ELF_MIN_ALIGN - 1);\n\n\t\t/* Map the last of the bss segment */\n\t\tdown_write(&current->mm->mmap_sem);\n\t\terror = do_brk(elf_bss, last_bss - elf_bss);\n\t\tup_write(&current->mm->mmap_sem);\n\t\tif (BAD_ADDR(error))\n\t\t\tgoto out_close;\n\t}\n\n\terror = load_addr;\n\nout_close:\n\tkfree(elf_phdata);\nout:\n\treturn error;\n}\n\n/*\n * These are the functions used to load ELF style executables and shared\n * libraries.  There is no binary dependent code anywhere else.\n */\n\n#define INTERPRETER_NONE 0\n#define INTERPRETER_ELF 2\n\n#ifndef STACK_RND_MASK\n#define STACK_RND_MASK (0x7ff >> (PAGE_SHIFT - 12))\t/* 8MB of VA */\n#endif\n\nstatic unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned int random_variable = 0;\n\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}\n\nstatic int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned int size;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tunsigned long def_flags = 0;\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op || !bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\t/* Now read in all of the header information */\n\tif (loc->elf_ex.e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\tif (loc->elf_ex.e_phnum < 1 ||\n\t \tloc->elf_ex.e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\tgoto out;\n\tsize = loc->elf_ex.e_phnum * sizeof(struct elf_phdr);\n\tretval = -ENOMEM;\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\tretval = kernel_read(bprm->file, loc->elf_ex.e_phoff,\n\t\t\t     (char *)elf_phdata, size);\n\tif (retval != size) {\n\t\tif (retval >= 0)\n\t\t\tretval = -EIO;\n\t\tgoto out_free_ph;\n\t}\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tif (elf_ppnt->p_type == PT_GNU_STACK) {\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* OK, This is the point of no return */\n\tcurrent->flags &= ~PF_FORKNOEXEC;\n\tcurrent->mm->def_flags = def_flags;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY(loc->elf_ex);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tcurrent->mm->free_area_cache = current->mm->mmap_base;\n\tcurrent->mm->cached_hole_size = 0;\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0) {\n\t\tsend_sig(SIGKILL, current, 0);\n\t\tgoto out_free_dentry;\n\t}\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval) {\n\t\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, 0);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval) {\n\t\tsend_sig(SIGKILL, current, 0);\n\t\tgoto out_free_dentry;\n\t}\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tsend_sig(SIGSEGV, current, 0);\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long uninitialized_var(interp_map_addr);\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tforce_sig(SIGSEGV, current);\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tforce_sig(SIGSEGV, current);\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0) {\n\t\tsend_sig(SIGKILL, current, 0);\n\t\tgoto out;\n\t}\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tcurrent->flags &= ~PF_FORKNOEXEC;\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0) {\n\t\tsend_sig(SIGKILL, current, 0);\n\t\tgoto out;\n\t}\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\tdown_write(&current->mm->mmap_sem);\n\t\terror = do_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t\tup_write(&current->mm->mmap_sem);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}\n\n/* This is really simpleminded and specialized - we are loading an\n   a.out library that is given an ELF header. */\nstatic int load_elf_library(struct file *file)\n{\n\tstruct elf_phdr *elf_phdata;\n\tstruct elf_phdr *eppnt;\n\tunsigned long elf_bss, bss, len;\n\tint retval, error, i, j;\n\tstruct elfhdr elf_ex;\n\n\terror = -ENOEXEC;\n\tretval = kernel_read(file, 0, (char *)&elf_ex, sizeof(elf_ex));\n\tif (retval != sizeof(elf_ex))\n\t\tgoto out;\n\n\tif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t/* First of all, some simple consistency checks */\n\tif (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||\n\t    !elf_check_arch(&elf_ex) || !file->f_op || !file->f_op->mmap)\n\t\tgoto out;\n\n\t/* Now read in all of the header information */\n\n\tj = sizeof(struct elf_phdr) * elf_ex.e_phnum;\n\t/* j < ELF_MIN_ALIGN because elf_ex.e_phnum <= 2 */\n\n\terror = -ENOMEM;\n\telf_phdata = kmalloc(j, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\teppnt = elf_phdata;\n\terror = -ENOEXEC;\n\tretval = kernel_read(file, elf_ex.e_phoff, (char *)eppnt, j);\n\tif (retval != j)\n\t\tgoto out_free_ph;\n\n\tfor (j = 0, i = 0; i<elf_ex.e_phnum; i++)\n\t\tif ((eppnt + i)->p_type == PT_LOAD)\n\t\t\tj++;\n\tif (j != 1)\n\t\tgoto out_free_ph;\n\n\twhile (eppnt->p_type != PT_LOAD)\n\t\teppnt++;\n\n\t/* Now use mmap to map the library into memory. */\n\tdown_write(&current->mm->mmap_sem);\n\terror = do_mmap(file,\n\t\t\tELF_PAGESTART(eppnt->p_vaddr),\n\t\t\t(eppnt->p_filesz +\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)),\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\t(eppnt->p_offset -\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)));\n\tup_write(&current->mm->mmap_sem);\n\tif (error != ELF_PAGESTART(eppnt->p_vaddr))\n\t\tgoto out_free_ph;\n\n\telf_bss = eppnt->p_vaddr + eppnt->p_filesz;\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out_free_ph;\n\t}\n\n\tlen = ELF_PAGESTART(eppnt->p_filesz + eppnt->p_vaddr +\n\t\t\t    ELF_MIN_ALIGN - 1);\n\tbss = eppnt->p_memsz + eppnt->p_vaddr;\n\tif (bss > len) {\n\t\tdown_write(&current->mm->mmap_sem);\n\t\tdo_brk(len, bss - len);\n\t\tup_write(&current->mm->mmap_sem);\n\t}\n\terror = 0;\n\nout_free_ph:\n\tkfree(elf_phdata);\nout:\n\treturn error;\n}\n\n#ifdef CONFIG_ELF_CORE\n/*\n * ELF core dumper\n *\n * Modelled on fs/exec.c:aout_core_dump()\n * Jeremy Fitzhardinge <jeremy@sw.oz.au>\n */\n\n/*\n * Decide what to dump of a segment, part, all or none.\n */\nstatic unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* The vma can be set up to tell us the answer directly.  */\n\tif (vma->vm_flags & VM_ALWAYSDUMP)\n\t\tgoto whole;\n\n\t/* Hugetlb memory check */\n\tif (vma->vm_flags & VM_HUGETLB) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & (VM_IO | VM_RESERVED))\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (vma->vm_file->f_path.dentry->d_inode->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}\n\n/* An ELF note in memory */\nstruct memelfnote\n{\n\tconst char *name;\n\tint type;\n\tunsigned int datasz;\n\tvoid *data;\n};\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}\n\n#define DUMP_WRITE(addr, nr, foffset)\t\\\n\tdo { if (!dump_write(file, (addr), (nr))) return 0; *foffset += (nr); } while(0)\n\nstatic int alignfile(struct file *file, loff_t *foffset)\n{\n\tstatic const char buf[4] = { 0, };\n\tDUMP_WRITE(buf, roundup(*foffset, 4) - *foffset, foffset);\n\treturn 1;\n}\n\nstatic int writenote(struct memelfnote *men, struct file *file,\n\t\t\tloff_t *foffset)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\tDUMP_WRITE(&en, sizeof(en), foffset);\n\tDUMP_WRITE(men->name, en.n_namesz, foffset);\n\tif (!alignfile(file, foffset))\n\t\treturn 0;\n\tDUMP_WRITE(men->data, men->datasz, foffset);\n\tif (!alignfile(file, foffset))\n\t\treturn 0;\n\n\treturn 1;\n}\n#undef DUMP_WRITE\n\nstatic void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags, u8 osabi)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}\n\nstatic void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}\n\nstatic void fill_note(struct memelfnote *note, const char *name, int type, \n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}\n\n/*\n * fill up all the fields in prstatus from the given task struct, except\n * registers which need to be filled up separately.\n */\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tcputime_to_timeval(cputime.utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(cputime.stime, &prstatus->pr_stime);\n\t} else {\n\t\tcputime_to_timeval(p->utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(p->stime, &prstatus->pr_stime);\n\t}\n\tcputime_to_timeval(p->signal->cutime, &prstatus->pr_cutime);\n\tcputime_to_timeval(p->signal->cstime, &prstatus->pr_cstime);\n}\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, cred->uid);\n\tSET_GID(psinfo->pr_gid, cred->gid);\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}\n\nstatic void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}\n\n#ifdef CORE_DUMP_USE_REGSET\n#include <linux/regset.h>\n\nstruct elf_thread_core_info {\n\tstruct elf_thread_core_info *next;\n\tstruct task_struct *task;\n\tstruct elf_prstatus prstatus;\n\tstruct memelfnote notes[0];\n};\n\nstruct elf_note_info {\n\tstruct elf_thread_core_info *thread;\n\tstruct memelfnote psinfo;\n\tstruct memelfnote auxv;\n\tsize_t size;\n\tint thread_notes;\n};\n\n/*\n * When a regset has a writeback hook, we call it on each thread before\n * dumping user memory.  On register window machines, this makes sure the\n * user memory backing the register data is up to date before we read it.\n */\nstatic void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}\n\nstatic int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset))) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  long signr, struct pt_regs *regs)\n{\n\tstruct task_struct *dump_task = current;\n\tconst struct user_regset_view *view = task_user_regset_view(dump_task);\n\tstruct elf_thread_core_info *t;\n\tstruct elf_prpsinfo *psinfo;\n\tstruct core_thread *ct;\n\tunsigned int i;\n\n\tinfo->size = 0;\n\tinfo->thread = NULL;\n\n\tpsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\n\tif (psinfo == NULL)\n\t\treturn 0;\n\n\tfill_note(&info->psinfo, \"CORE\", NT_PRPSINFO, sizeof(*psinfo), psinfo);\n\n\t/*\n\t * Figure out how many notes we're going to need for each thread.\n\t */\n\tinfo->thread_notes = 0;\n\tfor (i = 0; i < view->n; ++i)\n\t\tif (view->regsets[i].core_note_type != 0)\n\t\t\t++info->thread_notes;\n\n\t/*\n\t * Sanity check.  We rely on regset 0 being in NT_PRSTATUS,\n\t * since it is our one special case.\n\t */\n\tif (unlikely(info->thread_notes == 0) ||\n\t    unlikely(view->regsets[0].core_note_type != NT_PRSTATUS)) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Initialize the ELF file header.\n\t */\n\tfill_elf_header(elf, phdrs,\n\t\t\tview->e_machine, view->e_flags, view->ei_osabi);\n\n\t/*\n\t * Allocate a structure for each thread.\n\t */\n\tfor (ct = &dump_task->mm->core_state->dumper; ct; ct = ct->next) {\n\t\tt = kzalloc(offsetof(struct elf_thread_core_info,\n\t\t\t\t     notes[info->thread_notes]),\n\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(!t))\n\t\t\treturn 0;\n\n\t\tt->task = ct->task;\n\t\tif (ct->task == dump_task || !info->thread) {\n\t\t\tt->next = info->thread;\n\t\t\tinfo->thread = t;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make sure to keep the original task at\n\t\t\t * the head of the list.\n\t\t\t */\n\t\t\tt->next = info->thread->next;\n\t\t\tinfo->thread->next = t;\n\t\t}\n\t}\n\n\t/*\n\t * Now fill in each thread's information.\n\t */\n\tfor (t = info->thread; t != NULL; t = t->next)\n\t\tif (!fill_thread_core_info(t, view, signr, &info->size))\n\t\t\treturn 0;\n\n\t/*\n\t * Fill in the two process-wide notes.\n\t */\n\tfill_psinfo(psinfo, dump_task->group_leader, dump_task->mm);\n\tinfo->size += notesize(&info->psinfo);\n\n\tfill_auxv_note(&info->auxv, current->mm);\n\tinfo->size += notesize(&info->auxv);\n\n\treturn 1;\n}\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\treturn info->size;\n}\n\n/*\n * Write all the notes for each thread.  When writing the first thread, the\n * process-wide notes are interleaved after the first thread-specific note.\n */\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct file *file, loff_t *foffset)\n{\n\tbool first = 1;\n\tstruct elf_thread_core_info *t = info->thread;\n\n\tdo {\n\t\tint i;\n\n\t\tif (!writenote(&t->notes[0], file, foffset))\n\t\t\treturn 0;\n\n\t\tif (first && !writenote(&info->psinfo, file, foffset))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->auxv, file, foffset))\n\t\t\treturn 0;\n\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tif (t->notes[i].data &&\n\t\t\t    !writenote(&t->notes[i], file, foffset))\n\t\t\t\treturn 0;\n\n\t\tfirst = 0;\n\t\tt = t->next;\n\t} while (t);\n\n\treturn 1;\n}\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\tstruct elf_thread_core_info *threads = info->thread;\n\twhile (threads) {\n\t\tunsigned int i;\n\t\tstruct elf_thread_core_info *t = threads;\n\t\tthreads = t->next;\n\t\tWARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tkfree(t->notes[i].data);\n\t\tkfree(t);\n\t}\n\tkfree(info->psinfo.data);\n}\n\n#else\n\n/* Here is the structure in which status of each thread is captured. */\nstruct elf_thread_status\n{\n\tstruct list_head list;\n\tstruct elf_prstatus prstatus;\t/* NT_PRSTATUS */\n\telf_fpregset_t fpu;\t\t/* NT_PRFPREG */\n\tstruct task_struct *thread;\n#ifdef ELF_CORE_COPY_XFPREGS\n\telf_fpxregset_t xfpu;\t\t/* ELF_CORE_XFPREG_TYPE */\n#endif\n\tstruct memelfnote notes[3];\n\tint num_notes;\n};\n\n/*\n * In order to add the specific thread information for the elf file format,\n * we need to keep a linked list of every threads pr_status and then create\n * a single section for them in the final core file.\n */\nstatic int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}\n\nstruct elf_note_info {\n\tstruct memelfnote *notes;\n\tstruct elf_prstatus *prstatus;\t/* NT_PRSTATUS */\n\tstruct elf_prpsinfo *psinfo;\t/* NT_PRPSINFO */\n\tstruct list_head thread_list;\n\telf_fpregset_t *fpu;\n#ifdef ELF_CORE_COPY_XFPREGS\n\telf_fpxregset_t *xfpu;\n#endif\n\tint thread_status_size;\n\tint numnote;\n};\n\nstatic int elf_note_info_init(struct elf_note_info *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tINIT_LIST_HEAD(&info->thread_list);\n\n\t/* Allocate space for six ELF notes */\n\tinfo->notes = kmalloc(6 * sizeof(struct memelfnote), GFP_KERNEL);\n\tif (!info->notes)\n\t\treturn 0;\n\tinfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\n\tif (!info->psinfo)\n\t\tgoto notes_free;\n\tinfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\n\tif (!info->prstatus)\n\t\tgoto psinfo_free;\n\tinfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\n\tif (!info->fpu)\n\t\tgoto prstatus_free;\n#ifdef ELF_CORE_COPY_XFPREGS\n\tinfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\n\tif (!info->xfpu)\n\t\tgoto fpu_free;\n#endif\n\treturn 1;\n#ifdef ELF_CORE_COPY_XFPREGS\n fpu_free:\n\tkfree(info->fpu);\n#endif\n prstatus_free:\n\tkfree(info->prstatus);\n psinfo_free:\n\tkfree(info->psinfo);\n notes_free:\n\tkfree(info->notes);\n\treturn 0;\n}\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  long signr, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tif (signr) {\n\t\tstruct core_thread *ct;\n\t\tstruct elf_thread_status *ets;\n\n\t\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\t\tct; ct = ct->next) {\n\t\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\t\tif (!ets)\n\t\t\t\treturn 0;\n\n\t\t\tets->thread = ct->task;\n\t\t\tlist_add(&ets->list, &info->thread_list);\n\t\t}\n\n\t\tlist_for_each(t, &info->thread_list) {\n\t\t\tint sz;\n\n\t\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\t\tsz = elf_dump_thread_status(signr, ets);\n\t\t\tinfo->thread_status_size += sz;\n\t\t}\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, signr);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS, ELF_OSABI);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tinfo->numnote = 2;\n\n\tfill_auxv_note(&info->notes[info->numnote++], current->mm);\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\tint sz = 0;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tsz += notesize(info->notes + i);\n\n\tsz += info->thread_status_size;\n\n\treturn sz;\n}\n\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct file *file, loff_t *foffset)\n{\n\tint i;\n\tstruct list_head *t;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tif (!writenote(info->notes + i, file, foffset))\n\t\t\treturn 0;\n\n\t/* write out the thread status notes section */\n\tlist_for_each(t, &info->thread_list) {\n\t\tstruct elf_thread_status *tmp =\n\t\t\t\tlist_entry(t, struct elf_thread_status, list);\n\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], file, foffset))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\twhile (!list_empty(&info->thread_list)) {\n\t\tstruct list_head *tmp = info->thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\n\tkfree(info->prstatus);\n\tkfree(info->psinfo);\n\tkfree(info->notes);\n\tkfree(info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(info->xfpu);\n#endif\n}\n\n#endif\n\nstatic struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}\n/*\n * Helper function for iterating across a vma list.  It ensures that the caller\n * will visit `gate_vma' prior to terminating the search.\n */\nstatic struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret;\n\n\tret = this_vma->vm_next;\n\tif (ret)\n\t\treturn ret;\n\tif (this_vma == gate_vma)\n\t\treturn NULL;\n\treturn gate_vma;\n}\n\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}\n\nstatic size_t elf_core_vma_data_size(struct vm_area_struct *gate_vma,\n\t\t\t\t     unsigned long mm_flags)\n{\n\tstruct vm_area_struct *vma;\n\tsize_t size = 0;\n\n\tfor (vma = first_vma(current, gate_vma); vma != NULL;\n\t     vma = next_vma(vma, gate_vma))\n\t\tsize += vma_dump_size(vma, mm_flags);\n\treturn size;\n}\n\n/*\n * Actual dumper\n *\n * This is a two-pass process; first we find the offsets of the bits,\n * and then they are actually written out.  If we run out of core limit\n * we just truncate.\n */\nstatic int elf_core_dump(struct coredump_params *cprm)\n{\n\tint has_dumped = 0;\n\tmm_segment_t fs;\n\tint segs;\n\tsize_t size = 0;\n\tstruct vm_area_struct *vma, *gate_vma;\n\tstruct elfhdr *elf = NULL;\n\tloff_t offset = 0, dataoff, foffset;\n\tstruct elf_note_info info;\n\tstruct elf_phdr *phdr4note = NULL;\n\tstruct elf_shdr *shdr4extnum = NULL;\n\tElf_Half e_phnum;\n\telf_addr_t e_shoff;\n\n\t/*\n\t * We no longer stop all VM operations.\n\t * \n\t * This is because those proceses that could possibly change map_count\n\t * or the mmap / vma pages are now blocked in do_exit on current\n\t * finishing this core dump.\n\t *\n\t * Only ptrace can touch these memory addresses, but it doesn't change\n\t * the map_count or the pages allocated. So no possibility of crashing\n\t * exists while dumping the mm->vm_next areas to the core file.\n\t */\n  \n\t/* alloc memory for large data structures: too large to be on stack */\n\telf = kmalloc(sizeof(*elf), GFP_KERNEL);\n\tif (!elf)\n\t\tgoto out;\n\t/*\n\t * The number of segs are recored into ELF header as 16bit value.\n\t * Please check DEFAULT_MAX_MAP_COUNT definition when you modify here.\n\t */\n\tsegs = current->mm->map_count;\n\tsegs += elf_core_extra_phdrs();\n\n\tgate_vma = get_gate_vma(current->mm);\n\tif (gate_vma != NULL)\n\t\tsegs++;\n\n\t/* for notes section */\n\tsegs++;\n\n\t/* If segs > PN_XNUM(0xffff), then e_phnum overflows. To avoid\n\t * this, kernel supports extended numbering. Have a look at\n\t * include/linux/elf.h for further information. */\n\te_phnum = segs > PN_XNUM ? PN_XNUM : segs;\n\n\t/*\n\t * Collect all the non-memory information about the process for the\n\t * notes.  This also sets up the file header.\n\t */\n\tif (!fill_note_info(elf, e_phnum, &info, cprm->signr, cprm->regs))\n\t\tgoto cleanup;\n\n\thas_dumped = 1;\n\tcurrent->flags |= PF_DUMPCORE;\n  \n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\toffset += sizeof(*elf);\t\t\t\t/* Elf header */\n\toffset += segs * sizeof(struct elf_phdr);\t/* Program headers */\n\tfoffset = offset;\n\n\t/* Write notes phdr entry */\n\t{\n\t\tsize_t sz = get_note_info_size(&info);\n\n\t\tsz += elf_coredump_extra_notes_size();\n\n\t\tphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\n\t\tif (!phdr4note)\n\t\t\tgoto end_coredump;\n\n\t\tfill_elf_note_phdr(phdr4note, sz, offset);\n\t\toffset += sz;\n\t}\n\n\tdataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\toffset += elf_core_vma_data_size(gate_vma, cprm->mm_flags);\n\toffset += elf_core_extra_data_size();\n\te_shoff = offset;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\n\t\tif (!shdr4extnum)\n\t\t\tgoto end_coredump;\n\t\tfill_extnum_info(elf, shdr4extnum, e_shoff, segs);\n\t}\n\n\toffset = dataoff;\n\n\tsize += sizeof(*elf);\n\tif (size > cprm->limit || !dump_write(cprm->file, elf, sizeof(*elf)))\n\t\tgoto end_coredump;\n\n\tsize += sizeof(*phdr4note);\n\tif (size > cprm->limit\n\t    || !dump_write(cprm->file, phdr4note, sizeof(*phdr4note)))\n\t\tgoto end_coredump;\n\n\t/* Write program headers for segments dump */\n\tfor (vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tstruct elf_phdr phdr;\n\n\t\tphdr.p_type = PT_LOAD;\n\t\tphdr.p_offset = offset;\n\t\tphdr.p_vaddr = vma->vm_start;\n\t\tphdr.p_paddr = 0;\n\t\tphdr.p_filesz = vma_dump_size(vma, cprm->mm_flags);\n\t\tphdr.p_memsz = vma->vm_end - vma->vm_start;\n\t\toffset += phdr.p_filesz;\n\t\tphdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tphdr.p_flags |= PF_W;\n\t\tif (vma->vm_flags & VM_EXEC)\n\t\t\tphdr.p_flags |= PF_X;\n\t\tphdr.p_align = ELF_EXEC_PAGESIZE;\n\n\t\tsize += sizeof(phdr);\n\t\tif (size > cprm->limit\n\t\t    || !dump_write(cprm->file, &phdr, sizeof(phdr)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_phdrs(cprm->file, offset, &size, cprm->limit))\n\t\tgoto end_coredump;\n\n \t/* write out the notes section */\n\tif (!write_note_info(&info, cprm->file, &foffset))\n\t\tgoto end_coredump;\n\n\tif (elf_coredump_extra_notes_write(cprm->file, &foffset))\n\t\tgoto end_coredump;\n\n\t/* Align to page */\n\tif (!dump_seek(cprm->file, dataoff - foffset))\n\t\tgoto end_coredump;\n\n\tfor (vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long addr;\n\t\tunsigned long end;\n\n\t\tend = vma->vm_start + vma_dump_size(vma, cprm->mm_flags);\n\n\t\tfor (addr = vma->vm_start; addr < end; addr += PAGE_SIZE) {\n\t\t\tstruct page *page;\n\t\t\tint stop;\n\n\t\t\tpage = get_dump_page(addr);\n\t\t\tif (page) {\n\t\t\t\tvoid *kaddr = kmap(page);\n\t\t\t\tstop = ((size += PAGE_SIZE) > cprm->limit) ||\n\t\t\t\t\t!dump_write(cprm->file, kaddr,\n\t\t\t\t\t\t    PAGE_SIZE);\n\t\t\t\tkunmap(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t} else\n\t\t\t\tstop = !dump_seek(cprm->file, PAGE_SIZE);\n\t\t\tif (stop)\n\t\t\t\tgoto end_coredump;\n\t\t}\n\t}\n\n\tif (!elf_core_write_extra_data(cprm->file, &size, cprm->limit))\n\t\tgoto end_coredump;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tsize += sizeof(*shdr4extnum);\n\t\tif (size > cprm->limit\n\t\t    || !dump_write(cprm->file, shdr4extnum,\n\t\t\t\t   sizeof(*shdr4extnum)))\n\t\t\tgoto end_coredump;\n\t}\n\nend_coredump:\n\tset_fs(fs);\n\ncleanup:\n\tfree_note_info(&info);\n\tkfree(shdr4extnum);\n\tkfree(phdr4note);\n\tkfree(elf);\nout:\n\treturn has_dumped;\n}\n\n#endif\t\t/* CONFIG_ELF_CORE */\n\nstatic int __init init_elf_binfmt(void)\n{\n\treturn register_binfmt(&elf_format);\n}\n\nstatic void __exit exit_elf_binfmt(void)\n{\n\t/* Remove the COFF and ELF loaders. */\n\tunregister_binfmt(&elf_format);\n}\n\ncore_initcall(init_elf_binfmt);\nmodule_exit(exit_elf_binfmt);\nMODULE_LICENSE(\"GPL\");\n", "/*\n * User-mode machine state access\n *\n * Copyright (C) 2007 Red Hat, Inc.  All rights reserved.\n *\n * This copyrighted material is made available to anyone wishing to use,\n * modify, copy, or redistribute it subject to the terms and conditions\n * of the GNU General Public License v.2.\n *\n * Red Hat Author: Roland McGrath.\n */\n\n#ifndef _LINUX_REGSET_H\n#define _LINUX_REGSET_H\t1\n\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\nstruct task_struct;\nstruct user_regset;\n\n\n/**\n * user_regset_active_fn - type of @active function in &struct user_regset\n * @target:\tthread being examined\n * @regset:\tregset being examined\n *\n * Return -%ENODEV if not available on the hardware found.\n * Return %0 if no interesting state in this thread.\n * Return >%0 number of @size units of interesting state.\n * Any get call fetching state beyond that number will\n * see the default initialization state for this data,\n * so a caller that knows what the default state is need\n * not copy it all out.\n * This call is optional; the pointer is %NULL if there\n * is no inexpensive check to yield a value < @n.\n */\ntypedef int user_regset_active_fn(struct task_struct *target,\n\t\t\t\t  const struct user_regset *regset);\n\n/**\n * user_regset_get_fn - type of @get function in &struct user_regset\n * @target:\tthread being examined\n * @regset:\tregset being examined\n * @pos:\toffset into the regset data to access, in bytes\n * @count:\tamount of data to copy, in bytes\n * @kbuf:\tif not %NULL, a kernel-space pointer to copy into\n * @ubuf:\tif @kbuf is %NULL, a user-space pointer to copy into\n *\n * Fetch register values.  Return %0 on success; -%EIO or -%ENODEV\n * are usual failure returns.  The @pos and @count values are in\n * bytes, but must be properly aligned.  If @kbuf is non-null, that\n * buffer is used and @ubuf is ignored.  If @kbuf is %NULL, then\n * ubuf gives a userland pointer to access directly, and an -%EFAULT\n * return value is possible.\n */\ntypedef int user_regset_get_fn(struct task_struct *target,\n\t\t\t       const struct user_regset *regset,\n\t\t\t       unsigned int pos, unsigned int count,\n\t\t\t       void *kbuf, void __user *ubuf);\n\n/**\n * user_regset_set_fn - type of @set function in &struct user_regset\n * @target:\tthread being examined\n * @regset:\tregset being examined\n * @pos:\toffset into the regset data to access, in bytes\n * @count:\tamount of data to copy, in bytes\n * @kbuf:\tif not %NULL, a kernel-space pointer to copy from\n * @ubuf:\tif @kbuf is %NULL, a user-space pointer to copy from\n *\n * Store register values.  Return %0 on success; -%EIO or -%ENODEV\n * are usual failure returns.  The @pos and @count values are in\n * bytes, but must be properly aligned.  If @kbuf is non-null, that\n * buffer is used and @ubuf is ignored.  If @kbuf is %NULL, then\n * ubuf gives a userland pointer to access directly, and an -%EFAULT\n * return value is possible.\n */\ntypedef int user_regset_set_fn(struct task_struct *target,\n\t\t\t       const struct user_regset *regset,\n\t\t\t       unsigned int pos, unsigned int count,\n\t\t\t       const void *kbuf, const void __user *ubuf);\n\n/**\n * user_regset_writeback_fn - type of @writeback function in &struct user_regset\n * @target:\tthread being examined\n * @regset:\tregset being examined\n * @immediate:\tzero if writeback at completion of next context switch is OK\n *\n * This call is optional; usually the pointer is %NULL.  When\n * provided, there is some user memory associated with this regset's\n * hardware, such as memory backing cached register data on register\n * window machines; the regset's data controls what user memory is\n * used (e.g. via the stack pointer value).\n *\n * Write register data back to user memory.  If the @immediate flag\n * is nonzero, it must be written to the user memory so uaccess or\n * access_process_vm() can see it when this call returns; if zero,\n * then it must be written back by the time the task completes a\n * context switch (as synchronized with wait_task_inactive()).\n * Return %0 on success or if there was nothing to do, -%EFAULT for\n * a memory problem (bad stack pointer or whatever), or -%EIO for a\n * hardware problem.\n */\ntypedef int user_regset_writeback_fn(struct task_struct *target,\n\t\t\t\t     const struct user_regset *regset,\n\t\t\t\t     int immediate);\n\n/**\n * struct user_regset - accessible thread CPU state\n * @n:\t\t\tNumber of slots (registers).\n * @size:\t\tSize in bytes of a slot (register).\n * @align:\t\tRequired alignment, in bytes.\n * @bias:\t\tBias from natural indexing.\n * @core_note_type:\tELF note @n_type value used in core dumps.\n * @get:\t\tFunction to fetch values.\n * @set:\t\tFunction to store values.\n * @active:\t\tFunction to report if regset is active, or %NULL.\n * @writeback:\t\tFunction to write data back to user memory, or %NULL.\n *\n * This data structure describes a machine resource we call a register set.\n * This is part of the state of an individual thread, not necessarily\n * actual CPU registers per se.  A register set consists of a number of\n * similar slots, given by @n.  Each slot is @size bytes, and aligned to\n * @align bytes (which is at least @size).\n *\n * These functions must be called only on the current thread or on a\n * thread that is in %TASK_STOPPED or %TASK_TRACED state, that we are\n * guaranteed will not be woken up and return to user mode, and that we\n * have called wait_task_inactive() on.  (The target thread always might\n * wake up for SIGKILL while these functions are working, in which case\n * that thread's user_regset state might be scrambled.)\n *\n * The @pos argument must be aligned according to @align; the @count\n * argument must be a multiple of @size.  These functions are not\n * responsible for checking for invalid arguments.\n *\n * When there is a natural value to use as an index, @bias gives the\n * difference between the natural index and the slot index for the\n * register set.  For example, x86 GDT segment descriptors form a regset;\n * the segment selector produces a natural index, but only a subset of\n * that index space is available as a regset (the TLS slots); subtracting\n * @bias from a segment selector index value computes the regset slot.\n *\n * If nonzero, @core_note_type gives the n_type field (NT_* value)\n * of the core file note in which this regset's data appears.\n * NT_PRSTATUS is a special case in that the regset data starts at\n * offsetof(struct elf_prstatus, pr_reg) into the note data; that is\n * part of the per-machine ELF formats userland knows about.  In\n * other cases, the core file note contains exactly the whole regset\n * (@n * @size) and nothing else.  The core file note is normally\n * omitted when there is an @active function and it returns zero.\n */\nstruct user_regset {\n\tuser_regset_get_fn\t\t*get;\n\tuser_regset_set_fn\t\t*set;\n\tuser_regset_active_fn\t\t*active;\n\tuser_regset_writeback_fn\t*writeback;\n\tunsigned int\t\t\tn;\n\tunsigned int \t\t\tsize;\n\tunsigned int \t\t\talign;\n\tunsigned int \t\t\tbias;\n\tunsigned int \t\t\tcore_note_type;\n};\n\n/**\n * struct user_regset_view - available regsets\n * @name:\tIdentifier, e.g. UTS_MACHINE string.\n * @regsets:\tArray of @n regsets available in this view.\n * @n:\t\tNumber of elements in @regsets.\n * @e_machine:\tELF header @e_machine %EM_* value written in core dumps.\n * @e_flags:\tELF header @e_flags value written in core dumps.\n * @ei_osabi:\tELF header @e_ident[%EI_OSABI] value written in core dumps.\n *\n * A regset view is a collection of regsets (&struct user_regset,\n * above).  This describes all the state of a thread that can be seen\n * from a given architecture/ABI environment.  More than one view might\n * refer to the same &struct user_regset, or more than one regset\n * might refer to the same machine-specific state in the thread.  For\n * example, a 32-bit thread's state could be examined from the 32-bit\n * view or from the 64-bit view.  Either method reaches the same thread\n * register state, doing appropriate widening or truncation.\n */\nstruct user_regset_view {\n\tconst char *name;\n\tconst struct user_regset *regsets;\n\tunsigned int n;\n\tu32 e_flags;\n\tu16 e_machine;\n\tu8 ei_osabi;\n};\n\n/*\n * This is documented here rather than at the definition sites because its\n * implementation is machine-dependent but its interface is universal.\n */\n/**\n * task_user_regset_view - Return the process's native regset view.\n * @tsk: a thread of the process in question\n *\n * Return the &struct user_regset_view that is native for the given process.\n * For example, what it would access when it called ptrace().\n * Throughout the life of the process, this only changes at exec.\n */\nconst struct user_regset_view *task_user_regset_view(struct task_struct *tsk);\n\n\n/*\n * These are helpers for writing regset get/set functions in arch code.\n * Because @start_pos and @end_pos are always compile-time constants,\n * these are inlined into very little code though they look large.\n *\n * Use one or more calls sequentially for each chunk of regset data stored\n * contiguously in memory.  Call with constants for @start_pos and @end_pos,\n * giving the range of byte positions in the regset that data corresponds\n * to; @end_pos can be -1 if this chunk is at the end of the regset layout.\n * Each call updates the arguments to point past its chunk.\n */\n\nstatic inline int user_regset_copyout(unsigned int *pos, unsigned int *count,\n\t\t\t\t      void **kbuf,\n\t\t\t\t      void __user **ubuf, const void *data,\n\t\t\t\t      const int start_pos, const int end_pos)\n{\n\tif (*count == 0)\n\t\treturn 0;\n\tBUG_ON(*pos < start_pos);\n\tif (end_pos < 0 || *pos < end_pos) {\n\t\tunsigned int copy = (end_pos < 0 ? *count\n\t\t\t\t     : min(*count, end_pos - *pos));\n\t\tdata += *pos - start_pos;\n\t\tif (*kbuf) {\n\t\t\tmemcpy(*kbuf, data, copy);\n\t\t\t*kbuf += copy;\n\t\t} else if (__copy_to_user(*ubuf, data, copy))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\t*ubuf += copy;\n\t\t*pos += copy;\n\t\t*count -= copy;\n\t}\n\treturn 0;\n}\n\nstatic inline int user_regset_copyin(unsigned int *pos, unsigned int *count,\n\t\t\t\t     const void **kbuf,\n\t\t\t\t     const void __user **ubuf, void *data,\n\t\t\t\t     const int start_pos, const int end_pos)\n{\n\tif (*count == 0)\n\t\treturn 0;\n\tBUG_ON(*pos < start_pos);\n\tif (end_pos < 0 || *pos < end_pos) {\n\t\tunsigned int copy = (end_pos < 0 ? *count\n\t\t\t\t     : min(*count, end_pos - *pos));\n\t\tdata += *pos - start_pos;\n\t\tif (*kbuf) {\n\t\t\tmemcpy(data, *kbuf, copy);\n\t\t\t*kbuf += copy;\n\t\t} else if (__copy_from_user(data, *ubuf, copy))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\t*ubuf += copy;\n\t\t*pos += copy;\n\t\t*count -= copy;\n\t}\n\treturn 0;\n}\n\n/*\n * These two parallel the two above, but for portions of a regset layout\n * that always read as all-zero or for which writes are ignored.\n */\nstatic inline int user_regset_copyout_zero(unsigned int *pos,\n\t\t\t\t\t   unsigned int *count,\n\t\t\t\t\t   void **kbuf, void __user **ubuf,\n\t\t\t\t\t   const int start_pos,\n\t\t\t\t\t   const int end_pos)\n{\n\tif (*count == 0)\n\t\treturn 0;\n\tBUG_ON(*pos < start_pos);\n\tif (end_pos < 0 || *pos < end_pos) {\n\t\tunsigned int copy = (end_pos < 0 ? *count\n\t\t\t\t     : min(*count, end_pos - *pos));\n\t\tif (*kbuf) {\n\t\t\tmemset(*kbuf, 0, copy);\n\t\t\t*kbuf += copy;\n\t\t} else if (__clear_user(*ubuf, copy))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\t*ubuf += copy;\n\t\t*pos += copy;\n\t\t*count -= copy;\n\t}\n\treturn 0;\n}\n\nstatic inline int user_regset_copyin_ignore(unsigned int *pos,\n\t\t\t\t\t    unsigned int *count,\n\t\t\t\t\t    const void **kbuf,\n\t\t\t\t\t    const void __user **ubuf,\n\t\t\t\t\t    const int start_pos,\n\t\t\t\t\t    const int end_pos)\n{\n\tif (*count == 0)\n\t\treturn 0;\n\tBUG_ON(*pos < start_pos);\n\tif (end_pos < 0 || *pos < end_pos) {\n\t\tunsigned int copy = (end_pos < 0 ? *count\n\t\t\t\t     : min(*count, end_pos - *pos));\n\t\tif (*kbuf)\n\t\t\t*kbuf += copy;\n\t\telse\n\t\t\t*ubuf += copy;\n\t\t*pos += copy;\n\t\t*count -= copy;\n\t}\n\treturn 0;\n}\n\n/**\n * copy_regset_to_user - fetch a thread's user_regset data into user memory\n * @target:\tthread to be examined\n * @view:\t&struct user_regset_view describing user thread machine state\n * @setno:\tindex in @view->regsets\n * @offset:\toffset into the regset data, in bytes\n * @size:\tamount of data to copy, in bytes\n * @data:\tuser-mode pointer to copy into\n */\nstatic inline int copy_regset_to_user(struct task_struct *target,\n\t\t\t\t      const struct user_regset_view *view,\n\t\t\t\t      unsigned int setno,\n\t\t\t\t      unsigned int offset, unsigned int size,\n\t\t\t\t      void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\n\tif (!regset->get)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!access_ok(VERIFY_WRITE, data, size))\n\t\treturn -EIO;\n\n\treturn regset->get(target, regset, offset, size, NULL, data);\n}\n\n/**\n * copy_regset_from_user - store into thread's user_regset data from user memory\n * @target:\tthread to be examined\n * @view:\t&struct user_regset_view describing user thread machine state\n * @setno:\tindex in @view->regsets\n * @offset:\toffset into the regset data, in bytes\n * @size:\tamount of data to copy, in bytes\n * @data:\tuser-mode pointer to copy from\n */\nstatic inline int copy_regset_from_user(struct task_struct *target,\n\t\t\t\t\tconst struct user_regset_view *view,\n\t\t\t\t\tunsigned int setno,\n\t\t\t\t\tunsigned int offset, unsigned int size,\n\t\t\t\t\tconst void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\n\tif (!regset->set)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!access_ok(VERIFY_READ, data, size))\n\t\treturn -EIO;\n\n\treturn regset->set(target, regset, offset, size, NULL, data);\n}\n\n\n#endif\t/* <linux/regset.h> */\n"], "buggy_code_start_loc": [1424, 337], "buggy_code_end_loc": [1425, 360], "fixing_code_start_loc": [1424, 338], "fixing_code_end_loc": [1425, 367], "type": "CWE-476", "message": "The regset (aka register set) feature in the Linux kernel before 3.2.10 does not properly handle the absence of .get and .set methods, which allows local users to cause a denial of service (NULL pointer dereference) or possibly have unspecified other impact via a (1) PTRACE_GETREGSET or (2) PTRACE_SETREGSET ptrace call.", "other": {"cve": {"id": "CVE-2012-1097", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-17T11:00:37.227", "lastModified": "2023-02-13T04:32:55.757", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The regset (aka register set) feature in the Linux kernel before 3.2.10 does not properly handle the absence of .get and .set methods, which allows local users to cause a denial of service (NULL pointer dereference) or possibly have unspecified other impact via a (1) PTRACE_GETREGSET or (2) PTRACE_SETREGSET ptrace call."}, {"lang": "es", "value": "El funcionalidad regset (tambi\u00e9n conocido como conjunto de registros) en el kernel de Linux antes de v3.2.10 no controla correctamente la ausencia de m\u00e9todos .\"set\" y \".get\", lo que permite a usuarios locales causar una denegaci\u00f3n de servicio (desreferencia de puntero nulo) o, posiblemente, tener un impacto no especificado a trav\u00e9s de (1) un PTRACE_GETREGSET o (2) una llamada ptrace PTRACE_SETREGSET."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.24", "matchCriteriaId": "90D700E9-ABBF-4CA7-908E-99146F8CED6E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1", "versionEndExcluding": "3.2.10", "matchCriteriaId": "F6DAE145-A55C-472F-B276-341EA6940F6A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "6172AF57-B26D-45F8-BE3A-F75ABDF28F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_mrg:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "C60FA8B1-1802-4522-A088-22171DCF7A93"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp1:*:*:*:*:*:*", "matchCriteriaId": "60FBDD82-691C-4D9D-B71B-F9AFF6931B53"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp2:*:*:*:*:*:*", "matchCriteriaId": "00720D8C-3FF3-4B1C-B74B-91F01A544399"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_high_availability_extension:11:sp1:*:*:*:*:*:*", "matchCriteriaId": "EB74DEB4-2BD1-4A65-AFDA-C331BC20C178"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_high_availability_extension:11:sp2:*:*:*:*:*:*", "matchCriteriaId": "DF49412C-CF41-4251-B1FB-F0E63AC9E019"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp1:*:*:*:vmware:*:*", "matchCriteriaId": "A6B7CDCA-6F39-4113-B5D3-3AA9D7F3D809"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp1:*:*:-:*:*:*", "matchCriteriaId": "A5FA293A-23D8-445E-B08C-72B0A2A20EC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp2:*:*:*:vmware:*:*", "matchCriteriaId": "DB4D6749-81A1-41D7-BF4F-1C45A7F49A22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp2:*:*:-:*:*:*", "matchCriteriaId": "1A9E2971-0D30-4A8D-8BF8-99E4E9E4CF86"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=c8e252586f8d5de906385d8cf6385fee289a825e", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2012-04/msg00021.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2012-05/msg00013.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-0481.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-0531.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.2.10", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/03/05/1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=799209", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/c8e252586f8d5de906385d8cf6385fee289a825e", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c8e252586f8d5de906385d8cf6385fee289a825e"}}