{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * 6pack.c\tThis module implements the 6pack protocol for kernel-based\n *\t\tdevices like TTY. It interfaces between a raw TTY and the\n *\t\tkernel's AX.25 protocol layers.\n *\n * Authors:\tAndreas K\u00f6nsgen <ajk@comnets.uni-bremen.de>\n *              Ralf Baechle DL5RB <ralf@linux-mips.org>\n *\n * Quite a lot of stuff \"stolen\" by Joerg Reuter from slip.c, written by\n *\n *\t\tLaurence Culhane, <loz@holmes.demon.co.uk>\n *\t\tFred N. van Kempen, <waltje@uwalt.nl.mugnet.org>\n */\n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/spinlock.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/semaphore.h>\n#include <linux/refcount.h>\n\n#define SIXPACK_VERSION    \"Revision: 0.3.0\"\n\n/* sixpack priority commands */\n#define SIXP_SEOF\t\t0x40\t/* start and end of a 6pack frame */\n#define SIXP_TX_URUN\t\t0x48\t/* transmit overrun */\n#define SIXP_RX_ORUN\t\t0x50\t/* receive overrun */\n#define SIXP_RX_BUF_OVL\t\t0x58\t/* receive buffer overflow */\n\n#define SIXP_CHKSUM\t\t0xFF\t/* valid checksum of a 6pack frame */\n\n/* masks to get certain bits out of the status bytes sent by the TNC */\n\n#define SIXP_CMD_MASK\t\t0xC0\n#define SIXP_CHN_MASK\t\t0x07\n#define SIXP_PRIO_CMD_MASK\t0x80\n#define SIXP_STD_CMD_MASK\t0x40\n#define SIXP_PRIO_DATA_MASK\t0x38\n#define SIXP_TX_MASK\t\t0x20\n#define SIXP_RX_MASK\t\t0x10\n#define SIXP_RX_DCD_MASK\t0x18\n#define SIXP_LEDS_ON\t\t0x78\n#define SIXP_LEDS_OFF\t\t0x60\n#define SIXP_CON\t\t0x08\n#define SIXP_STA\t\t0x10\n\n#define SIXP_FOUND_TNC\t\t0xe9\n#define SIXP_CON_ON\t\t0x68\n#define SIXP_DCD_MASK\t\t0x08\n#define SIXP_DAMA_OFF\t\t0\n\n/* default level 2 parameters */\n#define SIXP_TXDELAY\t\t\t25\t/* 250 ms */\n#define SIXP_PERSIST\t\t\t50\t/* in 256ths */\n#define SIXP_SLOTTIME\t\t\t10\t/* 100 ms */\n#define SIXP_INIT_RESYNC_TIMEOUT\t(3*HZ/2) /* in 1 s */\n#define SIXP_RESYNC_TIMEOUT\t\t5*HZ\t/* in 1 s */\n\n/* 6pack configuration. */\n#define SIXP_NRUNIT\t\t\t31      /* MAX number of 6pack channels */\n#define SIXP_MTU\t\t\t256\t/* Default MTU */\n\nenum sixpack_flags {\n\tSIXPF_ERROR,\t/* Parity, etc. error\t*/\n};\n\nstruct sixpack {\n\t/* Various fields. */\n\tstruct tty_struct\t*tty;\t\t/* ptr to TTY structure\t*/\n\tstruct net_device\t*dev;\t\t/* easy for intr handling  */\n\n\t/* These are pointers to the malloc()ed frame buffers. */\n\tunsigned char\t\t*rbuff;\t\t/* receiver buffer\t*/\n\tint\t\t\trcount;         /* received chars counter  */\n\tunsigned char\t\t*xbuff;\t\t/* transmitter buffer\t*/\n\tunsigned char\t\t*xhead;         /* next byte to XMIT */\n\tint\t\t\txleft;          /* bytes left in XMIT queue  */\n\n\tunsigned char\t\traw_buf[4];\n\tunsigned char\t\tcooked_buf[400];\n\n\tunsigned int\t\trx_count;\n\tunsigned int\t\trx_count_cooked;\n\n\tint\t\t\tmtu;\t\t/* Our mtu (to spot changes!) */\n\tint\t\t\tbuffsize;       /* Max buffers sizes */\n\n\tunsigned long\t\tflags;\t\t/* Flag values/ mode etc */\n\tunsigned char\t\tmode;\t\t/* 6pack mode */\n\n\t/* 6pack stuff */\n\tunsigned char\t\ttx_delay;\n\tunsigned char\t\tpersistence;\n\tunsigned char\t\tslottime;\n\tunsigned char\t\tduplex;\n\tunsigned char\t\tled_state;\n\tunsigned char\t\tstatus;\n\tunsigned char\t\tstatus1;\n\tunsigned char\t\tstatus2;\n\tunsigned char\t\ttx_enable;\n\tunsigned char\t\ttnc_state;\n\n\tstruct timer_list\ttx_t;\n\tstruct timer_list\tresync_t;\n\trefcount_t\t\trefcnt;\n\tstruct completion\tdead;\n\tspinlock_t\t\tlock;\n};\n\n#define AX25_6PACK_HEADER_LEN 0\n\nstatic void sixpack_decode(struct sixpack *, const unsigned char[], int);\nstatic int encode_sixpack(unsigned char *, unsigned char *, int, unsigned char);\n\n/*\n * Perform the persistence/slottime algorithm for CSMA access. If the\n * persistence check was successful, write the data to the serial driver.\n * Note that in case of DAMA operation, the data is not sent here.\n */\n\nstatic void sp_xmit_on_air(struct timer_list *t)\n{\n\tstruct sixpack *sp = from_timer(sp, t, tx_t);\n\tint actual, when = sp->slottime;\n\tstatic unsigned char random;\n\n\trandom = random * 17 + 41;\n\n\tif (((sp->status1 & SIXP_DCD_MASK) == 0) && (random < sp->persistence)) {\n\t\tsp->led_state = 0x70;\n\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\tsp->tx_enable = 1;\n\t\tactual = sp->tty->ops->write(sp->tty, sp->xbuff, sp->status2);\n\t\tsp->xleft -= actual;\n\t\tsp->xhead += actual;\n\t\tsp->led_state = 0x60;\n\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\tsp->status2 = 0;\n\t} else\n\t\tmod_timer(&sp->tx_t, jiffies + ((when + 1) * HZ) / 100);\n}\n\n/* ----> 6pack timer interrupt handler and friends. <---- */\n\n/* Encapsulate one AX.25 frame and stuff into a TTY queue. */\nstatic void sp_encaps(struct sixpack *sp, unsigned char *icp, int len)\n{\n\tunsigned char *msg, *p = icp;\n\tint actual, count;\n\n\tif (len > sp->mtu) {\t/* sp->mtu = AX25_MTU = max. PACLEN = 256 */\n\t\tmsg = \"oversized transmit packet!\";\n\t\tgoto out_drop;\n\t}\n\n\tif (p[0] > 5) {\n\t\tmsg = \"invalid KISS command\";\n\t\tgoto out_drop;\n\t}\n\n\tif ((p[0] != 0) && (len > 2)) {\n\t\tmsg = \"KISS control packet too long\";\n\t\tgoto out_drop;\n\t}\n\n\tif ((p[0] == 0) && (len < 15)) {\n\t\tmsg = \"bad AX.25 packet to transmit\";\n\t\tgoto out_drop;\n\t}\n\n\tcount = encode_sixpack(p, sp->xbuff, len, sp->tx_delay);\n\tset_bit(TTY_DO_WRITE_WAKEUP, &sp->tty->flags);\n\n\tswitch (p[0]) {\n\tcase 1:\tsp->tx_delay = p[1];\n\t\treturn;\n\tcase 2:\tsp->persistence = p[1];\n\t\treturn;\n\tcase 3:\tsp->slottime = p[1];\n\t\treturn;\n\tcase 4:\t/* ignored */\n\t\treturn;\n\tcase 5:\tsp->duplex = p[1];\n\t\treturn;\n\t}\n\n\tif (p[0] != 0)\n\t\treturn;\n\n\t/*\n\t * In case of fullduplex or DAMA operation, we don't take care about the\n\t * state of the DCD or of any timers, as the determination of the\n\t * correct time to send is the job of the AX.25 layer. We send\n\t * immediately after data has arrived.\n\t */\n\tif (sp->duplex == 1) {\n\t\tsp->led_state = 0x70;\n\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\tsp->tx_enable = 1;\n\t\tactual = sp->tty->ops->write(sp->tty, sp->xbuff, count);\n\t\tsp->xleft = count - actual;\n\t\tsp->xhead = sp->xbuff + actual;\n\t\tsp->led_state = 0x60;\n\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t} else {\n\t\tsp->xleft = count;\n\t\tsp->xhead = sp->xbuff;\n\t\tsp->status2 = count;\n\t\tsp_xmit_on_air(&sp->tx_t);\n\t}\n\n\treturn;\n\nout_drop:\n\tsp->dev->stats.tx_dropped++;\n\tnetif_start_queue(sp->dev);\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"%s: %s - dropped.\\n\", sp->dev->name, msg);\n}\n\n/* Encapsulate an IP datagram and kick it into a TTY queue. */\n\nstatic netdev_tx_t sp_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct sixpack *sp = netdev_priv(dev);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn ax25_ip_xmit(skb);\n\n\tspin_lock_bh(&sp->lock);\n\t/* We were not busy, so we are now... :-) */\n\tnetif_stop_queue(dev);\n\tdev->stats.tx_bytes += skb->len;\n\tsp_encaps(sp, skb->data, skb->len);\n\tspin_unlock_bh(&sp->lock);\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int sp_open_dev(struct net_device *dev)\n{\n\tstruct sixpack *sp = netdev_priv(dev);\n\n\tif (sp->tty == NULL)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\n/* Close the low-level part of the 6pack channel. */\nstatic int sp_close(struct net_device *dev)\n{\n\tstruct sixpack *sp = netdev_priv(dev);\n\n\tspin_lock_bh(&sp->lock);\n\tif (sp->tty) {\n\t\t/* TTY discipline is running. */\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sp->tty->flags);\n\t}\n\tnetif_stop_queue(dev);\n\tspin_unlock_bh(&sp->lock);\n\n\treturn 0;\n}\n\nstatic int sp_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr_ax25 *sa = addr;\n\n\tnetif_tx_lock_bh(dev);\n\tnetif_addr_lock(dev);\n\t__dev_addr_set(dev, &sa->sax25_call, AX25_ADDR_LEN);\n\tnetif_addr_unlock(dev);\n\tnetif_tx_unlock_bh(dev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops sp_netdev_ops = {\n\t.ndo_open\t\t= sp_open_dev,\n\t.ndo_stop\t\t= sp_close,\n\t.ndo_start_xmit\t\t= sp_xmit,\n\t.ndo_set_mac_address    = sp_set_mac_address,\n};\n\nstatic void sp_setup(struct net_device *dev)\n{\n\t/* Finish setting up the DEVICE info. */\n\tdev->netdev_ops\t\t= &sp_netdev_ops;\n\tdev->mtu\t\t= SIXP_MTU;\n\tdev->hard_header_len\t= AX25_MAX_HEADER_LEN;\n\tdev->header_ops \t= &ax25_header_ops;\n\n\tdev->addr_len\t\t= AX25_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_AX25;\n\tdev->tx_queue_len\t= 10;\n\n\t/* Only activated in AX.25 mode */\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\n\tdev->flags\t\t= 0;\n}\n\n/* Send one completely decapsulated IP datagram to the IP layer. */\n\n/*\n * This is the routine that sends the received data to the kernel AX.25.\n * 'cmd' is the KISS command. For AX.25 data, it is zero.\n */\n\nstatic void sp_bump(struct sixpack *sp, char cmd)\n{\n\tstruct sk_buff *skb;\n\tint count;\n\tunsigned char *ptr;\n\n\tcount = sp->rcount + 1;\n\n\tsp->dev->stats.rx_bytes += count;\n\n\tif ((skb = dev_alloc_skb(count + 1)) == NULL)\n\t\tgoto out_mem;\n\n\tptr = skb_put(skb, count + 1);\n\t*ptr++ = cmd;\t/* KISS command */\n\n\tmemcpy(ptr, sp->cooked_buf + 1, count);\n\tskb->protocol = ax25_type_trans(skb, sp->dev);\n\tnetif_rx(skb);\n\tsp->dev->stats.rx_packets++;\n\n\treturn;\n\nout_mem:\n\tsp->dev->stats.rx_dropped++;\n}\n\n\n/* ----------------------------------------------------------------------- */\n\n/*\n * We have a potential race on dereferencing tty->disc_data, because the tty\n * layer provides no locking at all - thus one cpu could be running\n * sixpack_receive_buf while another calls sixpack_close, which zeroes\n * tty->disc_data and frees the memory that sixpack_receive_buf is using.  The\n * best way to fix this is to use a rwlock in the tty struct, but for now we\n * use a single global rwlock for all ttys in ppp line discipline.\n */\nstatic DEFINE_RWLOCK(disc_data_lock);\n                                                                                \nstatic struct sixpack *sp_get(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\n\tread_lock(&disc_data_lock);\n\tsp = tty->disc_data;\n\tif (sp)\n\t\trefcount_inc(&sp->refcnt);\n\tread_unlock(&disc_data_lock);\n\n\treturn sp;\n}\n\nstatic void sp_put(struct sixpack *sp)\n{\n\tif (refcount_dec_and_test(&sp->refcnt))\n\t\tcomplete(&sp->dead);\n}\n\n/*\n * Called by the TTY driver when there's room for more data.  If we have\n * more packets to send, we send them here.\n */\nstatic void sixpack_write_wakeup(struct tty_struct *tty)\n{\n\tstruct sixpack *sp = sp_get(tty);\n\tint actual;\n\n\tif (!sp)\n\t\treturn;\n\tif (sp->xleft <= 0)  {\n\t\t/* Now serial buffer is almost free & we can start\n\t\t * transmission of another packet */\n\t\tsp->dev->stats.tx_packets++;\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\t\tsp->tx_enable = 0;\n\t\tnetif_wake_queue(sp->dev);\n\t\tgoto out;\n\t}\n\n\tif (sp->tx_enable) {\n\t\tactual = tty->ops->write(tty, sp->xhead, sp->xleft);\n\t\tsp->xleft -= actual;\n\t\tsp->xhead += actual;\n\t}\n\nout:\n\tsp_put(sp);\n}\n\n/* ----------------------------------------------------------------------- */\n\n/*\n * Handle the 'receiver data ready' interrupt.\n * This function is called by the tty module in the kernel when\n * a block of 6pack data has been received, which can now be decapsulated\n * and sent on to some IP layer for further processing.\n */\nstatic void sixpack_receive_buf(struct tty_struct *tty,\n\tconst unsigned char *cp, const char *fp, int count)\n{\n\tstruct sixpack *sp;\n\tint count1;\n\n\tif (!count)\n\t\treturn;\n\n\tsp = sp_get(tty);\n\tif (!sp)\n\t\treturn;\n\n\t/* Read the characters out of the buffer */\n\tcount1 = count;\n\twhile (count) {\n\t\tcount--;\n\t\tif (fp && *fp++) {\n\t\t\tif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))\n\t\t\t\tsp->dev->stats.rx_errors++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tsixpack_decode(sp, cp, count1);\n\n\tsp_put(sp);\n\ttty_unthrottle(tty);\n}\n\n/*\n * Try to resync the TNC. Called by the resync timer defined in\n * decode_prio_command\n */\n\n#define TNC_UNINITIALIZED\t0\n#define TNC_UNSYNC_STARTUP\t1\n#define TNC_UNSYNCED\t\t2\n#define TNC_IN_SYNC\t\t3\n\nstatic void __tnc_set_sync_state(struct sixpack *sp, int new_tnc_state)\n{\n\tchar *msg;\n\n\tswitch (new_tnc_state) {\n\tdefault:\t\t\t/* gcc oh piece-o-crap ... */\n\tcase TNC_UNSYNC_STARTUP:\n\t\tmsg = \"Synchronizing with TNC\";\n\t\tbreak;\n\tcase TNC_UNSYNCED:\n\t\tmsg = \"Lost synchronization with TNC\\n\";\n\t\tbreak;\n\tcase TNC_IN_SYNC:\n\t\tmsg = \"Found TNC\";\n\t\tbreak;\n\t}\n\n\tsp->tnc_state = new_tnc_state;\n\tprintk(KERN_INFO \"%s: %s\\n\", sp->dev->name, msg);\n}\n\nstatic inline void tnc_set_sync_state(struct sixpack *sp, int new_tnc_state)\n{\n\tint old_tnc_state = sp->tnc_state;\n\n\tif (old_tnc_state != new_tnc_state)\n\t\t__tnc_set_sync_state(sp, new_tnc_state);\n}\n\nstatic void resync_tnc(struct timer_list *t)\n{\n\tstruct sixpack *sp = from_timer(sp, t, resync_t);\n\tstatic char resync_cmd = 0xe8;\n\n\t/* clear any data that might have been received */\n\n\tsp->rx_count = 0;\n\tsp->rx_count_cooked = 0;\n\n\t/* reset state machine */\n\n\tsp->status = 1;\n\tsp->status1 = 1;\n\tsp->status2 = 0;\n\n\t/* resync the TNC */\n\n\tsp->led_state = 0x60;\n\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\tsp->tty->ops->write(sp->tty, &resync_cmd, 1);\n\n\n\t/* Start resync timer again -- the TNC might be still absent */\n\tmod_timer(&sp->resync_t, jiffies + SIXP_RESYNC_TIMEOUT);\n}\n\nstatic inline int tnc_init(struct sixpack *sp)\n{\n\tunsigned char inbyte = 0xe8;\n\n\ttnc_set_sync_state(sp, TNC_UNSYNC_STARTUP);\n\n\tsp->tty->ops->write(sp->tty, &inbyte, 1);\n\n\tmod_timer(&sp->resync_t, jiffies + SIXP_RESYNC_TIMEOUT);\n\n\treturn 0;\n}\n\n/*\n * Open the high-level part of the 6pack channel.\n * This function is called by the TTY module when the\n * 6pack line discipline is called for.  Because we are\n * sure the tty line exists, we only have to link it to\n * a free 6pcack channel...\n */\nstatic int sixpack_open(struct tty_struct *tty)\n{\n\tchar *rbuff = NULL, *xbuff = NULL;\n\tstruct net_device *dev;\n\tstruct sixpack *sp;\n\tunsigned long len;\n\tint err = 0;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tdev = alloc_netdev(sizeof(struct sixpack), \"sp%d\", NET_NAME_UNKNOWN,\n\t\t\t   sp_setup);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsp = netdev_priv(dev);\n\tsp->dev = dev;\n\n\tspin_lock_init(&sp->lock);\n\trefcount_set(&sp->refcnt, 1);\n\tinit_completion(&sp->dead);\n\n\t/* !!! length of the buffers. MTU is IP MTU, not PACLEN!  */\n\n\tlen = dev->mtu * 2;\n\n\trbuff = kmalloc(len + 4, GFP_KERNEL);\n\txbuff = kmalloc(len + 4, GFP_KERNEL);\n\n\tif (rbuff == NULL || xbuff == NULL) {\n\t\terr = -ENOBUFS;\n\t\tgoto out_free;\n\t}\n\n\tspin_lock_bh(&sp->lock);\n\n\tsp->tty = tty;\n\n\tsp->rbuff\t= rbuff;\n\tsp->xbuff\t= xbuff;\n\n\tsp->mtu\t\t= AX25_MTU + 73;\n\tsp->buffsize\t= len;\n\tsp->rcount\t= 0;\n\tsp->rx_count\t= 0;\n\tsp->rx_count_cooked = 0;\n\tsp->xleft\t= 0;\n\n\tsp->flags\t= 0;\t\t/* Clear ESCAPE & ERROR flags */\n\n\tsp->duplex\t= 0;\n\tsp->tx_delay    = SIXP_TXDELAY;\n\tsp->persistence = SIXP_PERSIST;\n\tsp->slottime    = SIXP_SLOTTIME;\n\tsp->led_state   = 0x60;\n\tsp->status      = 1;\n\tsp->status1     = 1;\n\tsp->status2     = 0;\n\tsp->tx_enable   = 0;\n\n\tnetif_start_queue(dev);\n\n\ttimer_setup(&sp->tx_t, sp_xmit_on_air, 0);\n\n\ttimer_setup(&sp->resync_t, resync_tnc, 0);\n\n\tspin_unlock_bh(&sp->lock);\n\n\t/* Done.  We have linked the TTY line to a channel. */\n\ttty->disc_data = sp;\n\ttty->receive_room = 65536;\n\n\t/* Now we're ready to register. */\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out_free;\n\n\ttnc_init(sp);\n\n\treturn 0;\n\nout_free:\n\tkfree(xbuff);\n\tkfree(rbuff);\n\n\tfree_netdev(dev);\n\nout:\n\treturn err;\n}\n\n\n/*\n * Close down a 6pack channel.\n * This means flushing out any pending queues, and then restoring the\n * TTY line discipline to what it was before it got hooked to 6pack\n * (which usually is TTY again).\n */\nstatic void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\n\t/*\n\t * We have now ensured that nobody can start using ap from now on, but\n\t * we have to wait for all existing users to finish.\n\t */\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\n\t/* We must stop the queue to avoid potentially scribbling\n\t * on the free buffers. The sp->dead completion is not sufficient\n\t * to protect us from sp->xbuff access.\n\t */\n\tnetif_stop_queue(sp->dev);\n\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\n\tunregister_netdev(sp->dev);\n\n\t/* Free all 6pack frame buffers after unreg. */\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\n\tfree_netdev(sp->dev);\n}\n\n/* Perform I/O control on an active 6pack channel. */\nstatic int sixpack_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct sixpack *sp = sp_get(tty);\n\tstruct net_device *dev;\n\tunsigned int tmp, err;\n\n\tif (!sp)\n\t\treturn -ENXIO;\n\tdev = sp->dev;\n\n\tswitch(cmd) {\n\tcase SIOCGIFNAME:\n\t\terr = copy_to_user((void __user *) arg, dev->name,\n\t\t                   strlen(dev->name) + 1) ? -EFAULT : 0;\n\t\tbreak;\n\n\tcase SIOCGIFENCAP:\n\t\terr = put_user(0, (int __user *) arg);\n\t\tbreak;\n\n\tcase SIOCSIFENCAP:\n\t\tif (get_user(tmp, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tsp->mode = tmp;\n\t\tdev->addr_len        = AX25_ADDR_LEN;\n\t\tdev->hard_header_len = AX25_KISS_HEADER_LEN +\n\t\t                       AX25_MAX_HEADER_LEN + 3;\n\t\tdev->type            = ARPHRD_AX25;\n\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SIOCSIFHWADDR: {\n\t\t\tchar addr[AX25_ADDR_LEN];\n\n\t\t\tif (copy_from_user(&addr,\n\t\t\t\t\t   (void __user *)arg, AX25_ADDR_LEN)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnetif_tx_lock_bh(dev);\n\t\t\t__dev_addr_set(dev, &addr, AX25_ADDR_LEN);\n\t\t\tnetif_tx_unlock_bh(dev);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\terr = tty_mode_ioctl(tty, cmd, arg);\n\t}\n\n\tsp_put(sp);\n\n\treturn err;\n}\n\nstatic struct tty_ldisc_ops sp_ldisc = {\n\t.owner\t\t= THIS_MODULE,\n\t.num\t\t= N_6PACK,\n\t.name\t\t= \"6pack\",\n\t.open\t\t= sixpack_open,\n\t.close\t\t= sixpack_close,\n\t.ioctl\t\t= sixpack_ioctl,\n\t.receive_buf\t= sixpack_receive_buf,\n\t.write_wakeup\t= sixpack_write_wakeup,\n};\n\n/* Initialize 6pack control device -- register 6pack line discipline */\n\nstatic const char msg_banner[]  __initconst = KERN_INFO \\\n\t\"AX.25: 6pack driver, \" SIXPACK_VERSION \"\\n\";\nstatic const char msg_regfail[] __initconst = KERN_ERR  \\\n\t\"6pack: can't register line discipline (err = %d)\\n\";\n\nstatic int __init sixpack_init_driver(void)\n{\n\tint status;\n\n\tprintk(msg_banner);\n\n\t/* Register the provided line protocol discipline */\n\tstatus = tty_register_ldisc(&sp_ldisc);\n\tif (status)\n\t\tprintk(msg_regfail, status);\n\n\treturn status;\n}\n\nstatic void __exit sixpack_exit_driver(void)\n{\n\ttty_unregister_ldisc(&sp_ldisc);\n}\n\n/* encode an AX.25 packet into 6pack */\n\nstatic int encode_sixpack(unsigned char *tx_buf, unsigned char *tx_buf_raw,\n\tint length, unsigned char tx_delay)\n{\n\tint count = 0;\n\tunsigned char checksum = 0, buf[400];\n\tint raw_count = 0;\n\n\ttx_buf_raw[raw_count++] = SIXP_PRIO_CMD_MASK | SIXP_TX_MASK;\n\ttx_buf_raw[raw_count++] = SIXP_SEOF;\n\n\tbuf[0] = tx_delay;\n\tfor (count = 1; count < length; count++)\n\t\tbuf[count] = tx_buf[count];\n\n\tfor (count = 0; count < length; count++)\n\t\tchecksum += buf[count];\n\tbuf[length] = (unsigned char) 0xff - checksum;\n\n\tfor (count = 0; count <= length; count++) {\n\t\tif ((count % 3) == 0) {\n\t\t\ttx_buf_raw[raw_count++] = (buf[count] & 0x3f);\n\t\t\ttx_buf_raw[raw_count] = ((buf[count] >> 2) & 0x30);\n\t\t} else if ((count % 3) == 1) {\n\t\t\ttx_buf_raw[raw_count++] |= (buf[count] & 0x0f);\n\t\t\ttx_buf_raw[raw_count] =\t((buf[count] >> 2) & 0x3c);\n\t\t} else {\n\t\t\ttx_buf_raw[raw_count++] |= (buf[count] & 0x03);\n\t\t\ttx_buf_raw[raw_count++] = (buf[count] >> 2);\n\t\t}\n\t}\n\tif ((length % 3) != 2)\n\t\traw_count++;\n\ttx_buf_raw[raw_count++] = SIXP_SEOF;\n\treturn raw_count;\n}\n\n/* decode 4 sixpack-encoded bytes into 3 data bytes */\n\nstatic void decode_data(struct sixpack *sp, unsigned char inbyte)\n{\n\tunsigned char *buf;\n\n\tif (sp->rx_count != 3) {\n\t\tsp->raw_buf[sp->rx_count++] = inbyte;\n\n\t\treturn;\n\t}\n\n\tif (sp->rx_count_cooked + 2 >= sizeof(sp->cooked_buf)) {\n\t\tpr_err(\"6pack: cooked buffer overrun, data loss\\n\");\n\t\tsp->rx_count = 0;\n\t\treturn;\n\t}\n\n\tbuf = sp->raw_buf;\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\tbuf[0] | ((buf[1] << 2) & 0xc0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[1] & 0x0f) | ((buf[2] << 2) & 0xf0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[2] & 0x03) | (inbyte << 2);\n\tsp->rx_count = 0;\n}\n\n/* identify and execute a 6pack priority command byte */\n\nstatic void decode_prio_command(struct sixpack *sp, unsigned char cmd)\n{\n\tint actual;\n\n\tif ((cmd & SIXP_PRIO_DATA_MASK) != 0) {     /* idle ? */\n\n\t/* RX and DCD flags can only be set in the same prio command,\n\t   if the DCD flag has been set without the RX flag in the previous\n\t   prio command. If DCD has not been set before, something in the\n\t   transmission has gone wrong. In this case, RX and DCD are\n\t   cleared in order to prevent the decode_data routine from\n\t   reading further data that might be corrupt. */\n\n\t\tif (((sp->status & SIXP_DCD_MASK) == 0) &&\n\t\t\t((cmd & SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK)) {\n\t\t\t\tif (sp->status != 1)\n\t\t\t\t\tprintk(KERN_DEBUG \"6pack: protocol violation\\n\");\n\t\t\t\telse\n\t\t\t\t\tsp->status = 0;\n\t\t\t\tcmd &= ~SIXP_RX_DCD_MASK;\n\t\t}\n\t\tsp->status = cmd & SIXP_PRIO_DATA_MASK;\n\t} else { /* output watchdog char if idle */\n\t\tif ((sp->status2 != 0) && (sp->duplex == 1)) {\n\t\t\tsp->led_state = 0x70;\n\t\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\t\tsp->tx_enable = 1;\n\t\t\tactual = sp->tty->ops->write(sp->tty, sp->xbuff, sp->status2);\n\t\t\tsp->xleft -= actual;\n\t\t\tsp->xhead += actual;\n\t\t\tsp->led_state = 0x60;\n\t\t\tsp->status2 = 0;\n\n\t\t}\n\t}\n\n\t/* needed to trigger the TNC watchdog */\n\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\n        /* if the state byte has been received, the TNC is present,\n           so the resync timer can be reset. */\n\n\tif (sp->tnc_state == TNC_IN_SYNC)\n\t\tmod_timer(&sp->resync_t, jiffies + SIXP_INIT_RESYNC_TIMEOUT);\n\n\tsp->status1 = cmd & SIXP_PRIO_DATA_MASK;\n}\n\n/* identify and execute a standard 6pack command byte */\n\nstatic void decode_std_command(struct sixpack *sp, unsigned char cmd)\n{\n\tunsigned char checksum = 0, rest = 0;\n\tshort i;\n\n\tswitch (cmd & SIXP_CMD_MASK) {     /* normal command */\n\tcase SIXP_SEOF:\n\t\tif ((sp->rx_count == 0) && (sp->rx_count_cooked == 0)) {\n\t\t\tif ((sp->status & SIXP_RX_DCD_MASK) ==\n\t\t\t\tSIXP_RX_DCD_MASK) {\n\t\t\t\tsp->led_state = 0x68;\n\t\t\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tsp->led_state = 0x60;\n\t\t\t/* fill trailing bytes with zeroes */\n\t\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\t\trest = sp->rx_count;\n\t\t\tif (rest != 0)\n\t\t\t\t for (i = rest; i <= 3; i++)\n\t\t\t\t\tdecode_data(sp, 0);\n\t\t\tif (rest == 2)\n\t\t\t\tsp->rx_count_cooked -= 2;\n\t\t\telse if (rest == 3)\n\t\t\t\tsp->rx_count_cooked -= 1;\n\t\t\tfor (i = 0; i < sp->rx_count_cooked; i++)\n\t\t\t\tchecksum += sp->cooked_buf[i];\n\t\t\tif (checksum != SIXP_CHKSUM) {\n\t\t\t\tprintk(KERN_DEBUG \"6pack: bad checksum %2.2x\\n\", checksum);\n\t\t\t} else {\n\t\t\t\tsp->rcount = sp->rx_count_cooked-2;\n\t\t\t\tsp_bump(sp, 0);\n\t\t\t}\n\t\t\tsp->rx_count_cooked = 0;\n\t\t}\n\t\tbreak;\n\tcase SIXP_TX_URUN: printk(KERN_DEBUG \"6pack: TX underrun\\n\");\n\t\tbreak;\n\tcase SIXP_RX_ORUN: printk(KERN_DEBUG \"6pack: RX overrun\\n\");\n\t\tbreak;\n\tcase SIXP_RX_BUF_OVL:\n\t\tprintk(KERN_DEBUG \"6pack: RX buffer overflow\\n\");\n\t}\n}\n\n/* decode a 6pack packet */\n\nstatic void\nsixpack_decode(struct sixpack *sp, const unsigned char *pre_rbuff, int count)\n{\n\tunsigned char inbyte;\n\tint count1;\n\n\tfor (count1 = 0; count1 < count; count1++) {\n\t\tinbyte = pre_rbuff[count1];\n\t\tif (inbyte == SIXP_FOUND_TNC) {\n\t\t\ttnc_set_sync_state(sp, TNC_IN_SYNC);\n\t\t\tdel_timer(&sp->resync_t);\n\t\t}\n\t\tif ((inbyte & SIXP_PRIO_CMD_MASK) != 0)\n\t\t\tdecode_prio_command(sp, inbyte);\n\t\telse if ((inbyte & SIXP_STD_CMD_MASK) != 0)\n\t\t\tdecode_std_command(sp, inbyte);\n\t\telse if ((sp->status & SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK)\n\t\t\tdecode_data(sp, inbyte);\n\t}\n}\n\nMODULE_AUTHOR(\"Ralf Baechle DO1GRB <ralf@linux-mips.org>\");\nMODULE_DESCRIPTION(\"6pack driver for AX.25\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_6PACK);\n\nmodule_init(sixpack_init_driver);\nmodule_exit(sixpack_exit_driver);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * 6pack.c\tThis module implements the 6pack protocol for kernel-based\n *\t\tdevices like TTY. It interfaces between a raw TTY and the\n *\t\tkernel's AX.25 protocol layers.\n *\n * Authors:\tAndreas K\u00f6nsgen <ajk@comnets.uni-bremen.de>\n *              Ralf Baechle DL5RB <ralf@linux-mips.org>\n *\n * Quite a lot of stuff \"stolen\" by Joerg Reuter from slip.c, written by\n *\n *\t\tLaurence Culhane, <loz@holmes.demon.co.uk>\n *\t\tFred N. van Kempen, <waltje@uwalt.nl.mugnet.org>\n */\n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/spinlock.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/semaphore.h>\n#include <linux/refcount.h>\n\n#define SIXPACK_VERSION    \"Revision: 0.3.0\"\n\n/* sixpack priority commands */\n#define SIXP_SEOF\t\t0x40\t/* start and end of a 6pack frame */\n#define SIXP_TX_URUN\t\t0x48\t/* transmit overrun */\n#define SIXP_RX_ORUN\t\t0x50\t/* receive overrun */\n#define SIXP_RX_BUF_OVL\t\t0x58\t/* receive buffer overflow */\n\n#define SIXP_CHKSUM\t\t0xFF\t/* valid checksum of a 6pack frame */\n\n/* masks to get certain bits out of the status bytes sent by the TNC */\n\n#define SIXP_CMD_MASK\t\t0xC0\n#define SIXP_CHN_MASK\t\t0x07\n#define SIXP_PRIO_CMD_MASK\t0x80\n#define SIXP_STD_CMD_MASK\t0x40\n#define SIXP_PRIO_DATA_MASK\t0x38\n#define SIXP_TX_MASK\t\t0x20\n#define SIXP_RX_MASK\t\t0x10\n#define SIXP_RX_DCD_MASK\t0x18\n#define SIXP_LEDS_ON\t\t0x78\n#define SIXP_LEDS_OFF\t\t0x60\n#define SIXP_CON\t\t0x08\n#define SIXP_STA\t\t0x10\n\n#define SIXP_FOUND_TNC\t\t0xe9\n#define SIXP_CON_ON\t\t0x68\n#define SIXP_DCD_MASK\t\t0x08\n#define SIXP_DAMA_OFF\t\t0\n\n/* default level 2 parameters */\n#define SIXP_TXDELAY\t\t\t25\t/* 250 ms */\n#define SIXP_PERSIST\t\t\t50\t/* in 256ths */\n#define SIXP_SLOTTIME\t\t\t10\t/* 100 ms */\n#define SIXP_INIT_RESYNC_TIMEOUT\t(3*HZ/2) /* in 1 s */\n#define SIXP_RESYNC_TIMEOUT\t\t5*HZ\t/* in 1 s */\n\n/* 6pack configuration. */\n#define SIXP_NRUNIT\t\t\t31      /* MAX number of 6pack channels */\n#define SIXP_MTU\t\t\t256\t/* Default MTU */\n\nenum sixpack_flags {\n\tSIXPF_ERROR,\t/* Parity, etc. error\t*/\n};\n\nstruct sixpack {\n\t/* Various fields. */\n\tstruct tty_struct\t*tty;\t\t/* ptr to TTY structure\t*/\n\tstruct net_device\t*dev;\t\t/* easy for intr handling  */\n\n\t/* These are pointers to the malloc()ed frame buffers. */\n\tunsigned char\t\t*rbuff;\t\t/* receiver buffer\t*/\n\tint\t\t\trcount;         /* received chars counter  */\n\tunsigned char\t\t*xbuff;\t\t/* transmitter buffer\t*/\n\tunsigned char\t\t*xhead;         /* next byte to XMIT */\n\tint\t\t\txleft;          /* bytes left in XMIT queue  */\n\n\tunsigned char\t\traw_buf[4];\n\tunsigned char\t\tcooked_buf[400];\n\n\tunsigned int\t\trx_count;\n\tunsigned int\t\trx_count_cooked;\n\n\tint\t\t\tmtu;\t\t/* Our mtu (to spot changes!) */\n\tint\t\t\tbuffsize;       /* Max buffers sizes */\n\n\tunsigned long\t\tflags;\t\t/* Flag values/ mode etc */\n\tunsigned char\t\tmode;\t\t/* 6pack mode */\n\n\t/* 6pack stuff */\n\tunsigned char\t\ttx_delay;\n\tunsigned char\t\tpersistence;\n\tunsigned char\t\tslottime;\n\tunsigned char\t\tduplex;\n\tunsigned char\t\tled_state;\n\tunsigned char\t\tstatus;\n\tunsigned char\t\tstatus1;\n\tunsigned char\t\tstatus2;\n\tunsigned char\t\ttx_enable;\n\tunsigned char\t\ttnc_state;\n\n\tstruct timer_list\ttx_t;\n\tstruct timer_list\tresync_t;\n\trefcount_t\t\trefcnt;\n\tstruct completion\tdead;\n\tspinlock_t\t\tlock;\n};\n\n#define AX25_6PACK_HEADER_LEN 0\n\nstatic void sixpack_decode(struct sixpack *, const unsigned char[], int);\nstatic int encode_sixpack(unsigned char *, unsigned char *, int, unsigned char);\n\n/*\n * Perform the persistence/slottime algorithm for CSMA access. If the\n * persistence check was successful, write the data to the serial driver.\n * Note that in case of DAMA operation, the data is not sent here.\n */\n\nstatic void sp_xmit_on_air(struct timer_list *t)\n{\n\tstruct sixpack *sp = from_timer(sp, t, tx_t);\n\tint actual, when = sp->slottime;\n\tstatic unsigned char random;\n\n\trandom = random * 17 + 41;\n\n\tif (((sp->status1 & SIXP_DCD_MASK) == 0) && (random < sp->persistence)) {\n\t\tsp->led_state = 0x70;\n\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\tsp->tx_enable = 1;\n\t\tactual = sp->tty->ops->write(sp->tty, sp->xbuff, sp->status2);\n\t\tsp->xleft -= actual;\n\t\tsp->xhead += actual;\n\t\tsp->led_state = 0x60;\n\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\tsp->status2 = 0;\n\t} else\n\t\tmod_timer(&sp->tx_t, jiffies + ((when + 1) * HZ) / 100);\n}\n\n/* ----> 6pack timer interrupt handler and friends. <---- */\n\n/* Encapsulate one AX.25 frame and stuff into a TTY queue. */\nstatic void sp_encaps(struct sixpack *sp, unsigned char *icp, int len)\n{\n\tunsigned char *msg, *p = icp;\n\tint actual, count;\n\n\tif (len > sp->mtu) {\t/* sp->mtu = AX25_MTU = max. PACLEN = 256 */\n\t\tmsg = \"oversized transmit packet!\";\n\t\tgoto out_drop;\n\t}\n\n\tif (p[0] > 5) {\n\t\tmsg = \"invalid KISS command\";\n\t\tgoto out_drop;\n\t}\n\n\tif ((p[0] != 0) && (len > 2)) {\n\t\tmsg = \"KISS control packet too long\";\n\t\tgoto out_drop;\n\t}\n\n\tif ((p[0] == 0) && (len < 15)) {\n\t\tmsg = \"bad AX.25 packet to transmit\";\n\t\tgoto out_drop;\n\t}\n\n\tcount = encode_sixpack(p, sp->xbuff, len, sp->tx_delay);\n\tset_bit(TTY_DO_WRITE_WAKEUP, &sp->tty->flags);\n\n\tswitch (p[0]) {\n\tcase 1:\tsp->tx_delay = p[1];\n\t\treturn;\n\tcase 2:\tsp->persistence = p[1];\n\t\treturn;\n\tcase 3:\tsp->slottime = p[1];\n\t\treturn;\n\tcase 4:\t/* ignored */\n\t\treturn;\n\tcase 5:\tsp->duplex = p[1];\n\t\treturn;\n\t}\n\n\tif (p[0] != 0)\n\t\treturn;\n\n\t/*\n\t * In case of fullduplex or DAMA operation, we don't take care about the\n\t * state of the DCD or of any timers, as the determination of the\n\t * correct time to send is the job of the AX.25 layer. We send\n\t * immediately after data has arrived.\n\t */\n\tif (sp->duplex == 1) {\n\t\tsp->led_state = 0x70;\n\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\tsp->tx_enable = 1;\n\t\tactual = sp->tty->ops->write(sp->tty, sp->xbuff, count);\n\t\tsp->xleft = count - actual;\n\t\tsp->xhead = sp->xbuff + actual;\n\t\tsp->led_state = 0x60;\n\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t} else {\n\t\tsp->xleft = count;\n\t\tsp->xhead = sp->xbuff;\n\t\tsp->status2 = count;\n\t\tsp_xmit_on_air(&sp->tx_t);\n\t}\n\n\treturn;\n\nout_drop:\n\tsp->dev->stats.tx_dropped++;\n\tnetif_start_queue(sp->dev);\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"%s: %s - dropped.\\n\", sp->dev->name, msg);\n}\n\n/* Encapsulate an IP datagram and kick it into a TTY queue. */\n\nstatic netdev_tx_t sp_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct sixpack *sp = netdev_priv(dev);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn ax25_ip_xmit(skb);\n\n\tspin_lock_bh(&sp->lock);\n\t/* We were not busy, so we are now... :-) */\n\tnetif_stop_queue(dev);\n\tdev->stats.tx_bytes += skb->len;\n\tsp_encaps(sp, skb->data, skb->len);\n\tspin_unlock_bh(&sp->lock);\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int sp_open_dev(struct net_device *dev)\n{\n\tstruct sixpack *sp = netdev_priv(dev);\n\n\tif (sp->tty == NULL)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\n/* Close the low-level part of the 6pack channel. */\nstatic int sp_close(struct net_device *dev)\n{\n\tstruct sixpack *sp = netdev_priv(dev);\n\n\tspin_lock_bh(&sp->lock);\n\tif (sp->tty) {\n\t\t/* TTY discipline is running. */\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sp->tty->flags);\n\t}\n\tnetif_stop_queue(dev);\n\tspin_unlock_bh(&sp->lock);\n\n\treturn 0;\n}\n\nstatic int sp_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr_ax25 *sa = addr;\n\n\tnetif_tx_lock_bh(dev);\n\tnetif_addr_lock(dev);\n\t__dev_addr_set(dev, &sa->sax25_call, AX25_ADDR_LEN);\n\tnetif_addr_unlock(dev);\n\tnetif_tx_unlock_bh(dev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops sp_netdev_ops = {\n\t.ndo_open\t\t= sp_open_dev,\n\t.ndo_stop\t\t= sp_close,\n\t.ndo_start_xmit\t\t= sp_xmit,\n\t.ndo_set_mac_address    = sp_set_mac_address,\n};\n\nstatic void sp_setup(struct net_device *dev)\n{\n\t/* Finish setting up the DEVICE info. */\n\tdev->netdev_ops\t\t= &sp_netdev_ops;\n\tdev->mtu\t\t= SIXP_MTU;\n\tdev->hard_header_len\t= AX25_MAX_HEADER_LEN;\n\tdev->header_ops \t= &ax25_header_ops;\n\n\tdev->addr_len\t\t= AX25_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_AX25;\n\tdev->tx_queue_len\t= 10;\n\n\t/* Only activated in AX.25 mode */\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\n\tdev->flags\t\t= 0;\n}\n\n/* Send one completely decapsulated IP datagram to the IP layer. */\n\n/*\n * This is the routine that sends the received data to the kernel AX.25.\n * 'cmd' is the KISS command. For AX.25 data, it is zero.\n */\n\nstatic void sp_bump(struct sixpack *sp, char cmd)\n{\n\tstruct sk_buff *skb;\n\tint count;\n\tunsigned char *ptr;\n\n\tcount = sp->rcount + 1;\n\n\tsp->dev->stats.rx_bytes += count;\n\n\tif ((skb = dev_alloc_skb(count + 1)) == NULL)\n\t\tgoto out_mem;\n\n\tptr = skb_put(skb, count + 1);\n\t*ptr++ = cmd;\t/* KISS command */\n\n\tmemcpy(ptr, sp->cooked_buf + 1, count);\n\tskb->protocol = ax25_type_trans(skb, sp->dev);\n\tnetif_rx(skb);\n\tsp->dev->stats.rx_packets++;\n\n\treturn;\n\nout_mem:\n\tsp->dev->stats.rx_dropped++;\n}\n\n\n/* ----------------------------------------------------------------------- */\n\n/*\n * We have a potential race on dereferencing tty->disc_data, because the tty\n * layer provides no locking at all - thus one cpu could be running\n * sixpack_receive_buf while another calls sixpack_close, which zeroes\n * tty->disc_data and frees the memory that sixpack_receive_buf is using.  The\n * best way to fix this is to use a rwlock in the tty struct, but for now we\n * use a single global rwlock for all ttys in ppp line discipline.\n */\nstatic DEFINE_RWLOCK(disc_data_lock);\n                                                                                \nstatic struct sixpack *sp_get(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\n\tread_lock(&disc_data_lock);\n\tsp = tty->disc_data;\n\tif (sp)\n\t\trefcount_inc(&sp->refcnt);\n\tread_unlock(&disc_data_lock);\n\n\treturn sp;\n}\n\nstatic void sp_put(struct sixpack *sp)\n{\n\tif (refcount_dec_and_test(&sp->refcnt))\n\t\tcomplete(&sp->dead);\n}\n\n/*\n * Called by the TTY driver when there's room for more data.  If we have\n * more packets to send, we send them here.\n */\nstatic void sixpack_write_wakeup(struct tty_struct *tty)\n{\n\tstruct sixpack *sp = sp_get(tty);\n\tint actual;\n\n\tif (!sp)\n\t\treturn;\n\tif (sp->xleft <= 0)  {\n\t\t/* Now serial buffer is almost free & we can start\n\t\t * transmission of another packet */\n\t\tsp->dev->stats.tx_packets++;\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\t\tsp->tx_enable = 0;\n\t\tnetif_wake_queue(sp->dev);\n\t\tgoto out;\n\t}\n\n\tif (sp->tx_enable) {\n\t\tactual = tty->ops->write(tty, sp->xhead, sp->xleft);\n\t\tsp->xleft -= actual;\n\t\tsp->xhead += actual;\n\t}\n\nout:\n\tsp_put(sp);\n}\n\n/* ----------------------------------------------------------------------- */\n\n/*\n * Handle the 'receiver data ready' interrupt.\n * This function is called by the tty module in the kernel when\n * a block of 6pack data has been received, which can now be decapsulated\n * and sent on to some IP layer for further processing.\n */\nstatic void sixpack_receive_buf(struct tty_struct *tty,\n\tconst unsigned char *cp, const char *fp, int count)\n{\n\tstruct sixpack *sp;\n\tint count1;\n\n\tif (!count)\n\t\treturn;\n\n\tsp = sp_get(tty);\n\tif (!sp)\n\t\treturn;\n\n\t/* Read the characters out of the buffer */\n\tcount1 = count;\n\twhile (count) {\n\t\tcount--;\n\t\tif (fp && *fp++) {\n\t\t\tif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))\n\t\t\t\tsp->dev->stats.rx_errors++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tsixpack_decode(sp, cp, count1);\n\n\tsp_put(sp);\n\ttty_unthrottle(tty);\n}\n\n/*\n * Try to resync the TNC. Called by the resync timer defined in\n * decode_prio_command\n */\n\n#define TNC_UNINITIALIZED\t0\n#define TNC_UNSYNC_STARTUP\t1\n#define TNC_UNSYNCED\t\t2\n#define TNC_IN_SYNC\t\t3\n\nstatic void __tnc_set_sync_state(struct sixpack *sp, int new_tnc_state)\n{\n\tchar *msg;\n\n\tswitch (new_tnc_state) {\n\tdefault:\t\t\t/* gcc oh piece-o-crap ... */\n\tcase TNC_UNSYNC_STARTUP:\n\t\tmsg = \"Synchronizing with TNC\";\n\t\tbreak;\n\tcase TNC_UNSYNCED:\n\t\tmsg = \"Lost synchronization with TNC\\n\";\n\t\tbreak;\n\tcase TNC_IN_SYNC:\n\t\tmsg = \"Found TNC\";\n\t\tbreak;\n\t}\n\n\tsp->tnc_state = new_tnc_state;\n\tprintk(KERN_INFO \"%s: %s\\n\", sp->dev->name, msg);\n}\n\nstatic inline void tnc_set_sync_state(struct sixpack *sp, int new_tnc_state)\n{\n\tint old_tnc_state = sp->tnc_state;\n\n\tif (old_tnc_state != new_tnc_state)\n\t\t__tnc_set_sync_state(sp, new_tnc_state);\n}\n\nstatic void resync_tnc(struct timer_list *t)\n{\n\tstruct sixpack *sp = from_timer(sp, t, resync_t);\n\tstatic char resync_cmd = 0xe8;\n\n\t/* clear any data that might have been received */\n\n\tsp->rx_count = 0;\n\tsp->rx_count_cooked = 0;\n\n\t/* reset state machine */\n\n\tsp->status = 1;\n\tsp->status1 = 1;\n\tsp->status2 = 0;\n\n\t/* resync the TNC */\n\n\tsp->led_state = 0x60;\n\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\tsp->tty->ops->write(sp->tty, &resync_cmd, 1);\n\n\n\t/* Start resync timer again -- the TNC might be still absent */\n\tmod_timer(&sp->resync_t, jiffies + SIXP_RESYNC_TIMEOUT);\n}\n\nstatic inline int tnc_init(struct sixpack *sp)\n{\n\tunsigned char inbyte = 0xe8;\n\n\ttnc_set_sync_state(sp, TNC_UNSYNC_STARTUP);\n\n\tsp->tty->ops->write(sp->tty, &inbyte, 1);\n\n\tmod_timer(&sp->resync_t, jiffies + SIXP_RESYNC_TIMEOUT);\n\n\treturn 0;\n}\n\n/*\n * Open the high-level part of the 6pack channel.\n * This function is called by the TTY module when the\n * 6pack line discipline is called for.  Because we are\n * sure the tty line exists, we only have to link it to\n * a free 6pcack channel...\n */\nstatic int sixpack_open(struct tty_struct *tty)\n{\n\tchar *rbuff = NULL, *xbuff = NULL;\n\tstruct net_device *dev;\n\tstruct sixpack *sp;\n\tunsigned long len;\n\tint err = 0;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tdev = alloc_netdev(sizeof(struct sixpack), \"sp%d\", NET_NAME_UNKNOWN,\n\t\t\t   sp_setup);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsp = netdev_priv(dev);\n\tsp->dev = dev;\n\n\tspin_lock_init(&sp->lock);\n\trefcount_set(&sp->refcnt, 1);\n\tinit_completion(&sp->dead);\n\n\t/* !!! length of the buffers. MTU is IP MTU, not PACLEN!  */\n\n\tlen = dev->mtu * 2;\n\n\trbuff = kmalloc(len + 4, GFP_KERNEL);\n\txbuff = kmalloc(len + 4, GFP_KERNEL);\n\n\tif (rbuff == NULL || xbuff == NULL) {\n\t\terr = -ENOBUFS;\n\t\tgoto out_free;\n\t}\n\n\tspin_lock_bh(&sp->lock);\n\n\tsp->tty = tty;\n\n\tsp->rbuff\t= rbuff;\n\tsp->xbuff\t= xbuff;\n\n\tsp->mtu\t\t= AX25_MTU + 73;\n\tsp->buffsize\t= len;\n\tsp->rcount\t= 0;\n\tsp->rx_count\t= 0;\n\tsp->rx_count_cooked = 0;\n\tsp->xleft\t= 0;\n\n\tsp->flags\t= 0;\t\t/* Clear ESCAPE & ERROR flags */\n\n\tsp->duplex\t= 0;\n\tsp->tx_delay    = SIXP_TXDELAY;\n\tsp->persistence = SIXP_PERSIST;\n\tsp->slottime    = SIXP_SLOTTIME;\n\tsp->led_state   = 0x60;\n\tsp->status      = 1;\n\tsp->status1     = 1;\n\tsp->status2     = 0;\n\tsp->tx_enable   = 0;\n\n\tnetif_start_queue(dev);\n\n\ttimer_setup(&sp->tx_t, sp_xmit_on_air, 0);\n\n\ttimer_setup(&sp->resync_t, resync_tnc, 0);\n\n\tspin_unlock_bh(&sp->lock);\n\n\t/* Done.  We have linked the TTY line to a channel. */\n\ttty->disc_data = sp;\n\ttty->receive_room = 65536;\n\n\t/* Now we're ready to register. */\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out_free;\n\n\ttnc_init(sp);\n\n\treturn 0;\n\nout_free:\n\tkfree(xbuff);\n\tkfree(rbuff);\n\n\tfree_netdev(dev);\n\nout:\n\treturn err;\n}\n\n\n/*\n * Close down a 6pack channel.\n * This means flushing out any pending queues, and then restoring the\n * TTY line discipline to what it was before it got hooked to 6pack\n * (which usually is TTY again).\n */\nstatic void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\n\t/*\n\t * We have now ensured that nobody can start using ap from now on, but\n\t * we have to wait for all existing users to finish.\n\t */\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\n\t/* We must stop the queue to avoid potentially scribbling\n\t * on the free buffers. The sp->dead completion is not sufficient\n\t * to protect us from sp->xbuff access.\n\t */\n\tnetif_stop_queue(sp->dev);\n\n\tunregister_netdev(sp->dev);\n\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\n\t/* Free all 6pack frame buffers after unreg. */\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\n\tfree_netdev(sp->dev);\n}\n\n/* Perform I/O control on an active 6pack channel. */\nstatic int sixpack_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct sixpack *sp = sp_get(tty);\n\tstruct net_device *dev;\n\tunsigned int tmp, err;\n\n\tif (!sp)\n\t\treturn -ENXIO;\n\tdev = sp->dev;\n\n\tswitch(cmd) {\n\tcase SIOCGIFNAME:\n\t\terr = copy_to_user((void __user *) arg, dev->name,\n\t\t                   strlen(dev->name) + 1) ? -EFAULT : 0;\n\t\tbreak;\n\n\tcase SIOCGIFENCAP:\n\t\terr = put_user(0, (int __user *) arg);\n\t\tbreak;\n\n\tcase SIOCSIFENCAP:\n\t\tif (get_user(tmp, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tsp->mode = tmp;\n\t\tdev->addr_len        = AX25_ADDR_LEN;\n\t\tdev->hard_header_len = AX25_KISS_HEADER_LEN +\n\t\t                       AX25_MAX_HEADER_LEN + 3;\n\t\tdev->type            = ARPHRD_AX25;\n\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SIOCSIFHWADDR: {\n\t\t\tchar addr[AX25_ADDR_LEN];\n\n\t\t\tif (copy_from_user(&addr,\n\t\t\t\t\t   (void __user *)arg, AX25_ADDR_LEN)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnetif_tx_lock_bh(dev);\n\t\t\t__dev_addr_set(dev, &addr, AX25_ADDR_LEN);\n\t\t\tnetif_tx_unlock_bh(dev);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\terr = tty_mode_ioctl(tty, cmd, arg);\n\t}\n\n\tsp_put(sp);\n\n\treturn err;\n}\n\nstatic struct tty_ldisc_ops sp_ldisc = {\n\t.owner\t\t= THIS_MODULE,\n\t.num\t\t= N_6PACK,\n\t.name\t\t= \"6pack\",\n\t.open\t\t= sixpack_open,\n\t.close\t\t= sixpack_close,\n\t.ioctl\t\t= sixpack_ioctl,\n\t.receive_buf\t= sixpack_receive_buf,\n\t.write_wakeup\t= sixpack_write_wakeup,\n};\n\n/* Initialize 6pack control device -- register 6pack line discipline */\n\nstatic const char msg_banner[]  __initconst = KERN_INFO \\\n\t\"AX.25: 6pack driver, \" SIXPACK_VERSION \"\\n\";\nstatic const char msg_regfail[] __initconst = KERN_ERR  \\\n\t\"6pack: can't register line discipline (err = %d)\\n\";\n\nstatic int __init sixpack_init_driver(void)\n{\n\tint status;\n\n\tprintk(msg_banner);\n\n\t/* Register the provided line protocol discipline */\n\tstatus = tty_register_ldisc(&sp_ldisc);\n\tif (status)\n\t\tprintk(msg_regfail, status);\n\n\treturn status;\n}\n\nstatic void __exit sixpack_exit_driver(void)\n{\n\ttty_unregister_ldisc(&sp_ldisc);\n}\n\n/* encode an AX.25 packet into 6pack */\n\nstatic int encode_sixpack(unsigned char *tx_buf, unsigned char *tx_buf_raw,\n\tint length, unsigned char tx_delay)\n{\n\tint count = 0;\n\tunsigned char checksum = 0, buf[400];\n\tint raw_count = 0;\n\n\ttx_buf_raw[raw_count++] = SIXP_PRIO_CMD_MASK | SIXP_TX_MASK;\n\ttx_buf_raw[raw_count++] = SIXP_SEOF;\n\n\tbuf[0] = tx_delay;\n\tfor (count = 1; count < length; count++)\n\t\tbuf[count] = tx_buf[count];\n\n\tfor (count = 0; count < length; count++)\n\t\tchecksum += buf[count];\n\tbuf[length] = (unsigned char) 0xff - checksum;\n\n\tfor (count = 0; count <= length; count++) {\n\t\tif ((count % 3) == 0) {\n\t\t\ttx_buf_raw[raw_count++] = (buf[count] & 0x3f);\n\t\t\ttx_buf_raw[raw_count] = ((buf[count] >> 2) & 0x30);\n\t\t} else if ((count % 3) == 1) {\n\t\t\ttx_buf_raw[raw_count++] |= (buf[count] & 0x0f);\n\t\t\ttx_buf_raw[raw_count] =\t((buf[count] >> 2) & 0x3c);\n\t\t} else {\n\t\t\ttx_buf_raw[raw_count++] |= (buf[count] & 0x03);\n\t\t\ttx_buf_raw[raw_count++] = (buf[count] >> 2);\n\t\t}\n\t}\n\tif ((length % 3) != 2)\n\t\traw_count++;\n\ttx_buf_raw[raw_count++] = SIXP_SEOF;\n\treturn raw_count;\n}\n\n/* decode 4 sixpack-encoded bytes into 3 data bytes */\n\nstatic void decode_data(struct sixpack *sp, unsigned char inbyte)\n{\n\tunsigned char *buf;\n\n\tif (sp->rx_count != 3) {\n\t\tsp->raw_buf[sp->rx_count++] = inbyte;\n\n\t\treturn;\n\t}\n\n\tif (sp->rx_count_cooked + 2 >= sizeof(sp->cooked_buf)) {\n\t\tpr_err(\"6pack: cooked buffer overrun, data loss\\n\");\n\t\tsp->rx_count = 0;\n\t\treturn;\n\t}\n\n\tbuf = sp->raw_buf;\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\tbuf[0] | ((buf[1] << 2) & 0xc0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[1] & 0x0f) | ((buf[2] << 2) & 0xf0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[2] & 0x03) | (inbyte << 2);\n\tsp->rx_count = 0;\n}\n\n/* identify and execute a 6pack priority command byte */\n\nstatic void decode_prio_command(struct sixpack *sp, unsigned char cmd)\n{\n\tint actual;\n\n\tif ((cmd & SIXP_PRIO_DATA_MASK) != 0) {     /* idle ? */\n\n\t/* RX and DCD flags can only be set in the same prio command,\n\t   if the DCD flag has been set without the RX flag in the previous\n\t   prio command. If DCD has not been set before, something in the\n\t   transmission has gone wrong. In this case, RX and DCD are\n\t   cleared in order to prevent the decode_data routine from\n\t   reading further data that might be corrupt. */\n\n\t\tif (((sp->status & SIXP_DCD_MASK) == 0) &&\n\t\t\t((cmd & SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK)) {\n\t\t\t\tif (sp->status != 1)\n\t\t\t\t\tprintk(KERN_DEBUG \"6pack: protocol violation\\n\");\n\t\t\t\telse\n\t\t\t\t\tsp->status = 0;\n\t\t\t\tcmd &= ~SIXP_RX_DCD_MASK;\n\t\t}\n\t\tsp->status = cmd & SIXP_PRIO_DATA_MASK;\n\t} else { /* output watchdog char if idle */\n\t\tif ((sp->status2 != 0) && (sp->duplex == 1)) {\n\t\t\tsp->led_state = 0x70;\n\t\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\t\tsp->tx_enable = 1;\n\t\t\tactual = sp->tty->ops->write(sp->tty, sp->xbuff, sp->status2);\n\t\t\tsp->xleft -= actual;\n\t\t\tsp->xhead += actual;\n\t\t\tsp->led_state = 0x60;\n\t\t\tsp->status2 = 0;\n\n\t\t}\n\t}\n\n\t/* needed to trigger the TNC watchdog */\n\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\n        /* if the state byte has been received, the TNC is present,\n           so the resync timer can be reset. */\n\n\tif (sp->tnc_state == TNC_IN_SYNC)\n\t\tmod_timer(&sp->resync_t, jiffies + SIXP_INIT_RESYNC_TIMEOUT);\n\n\tsp->status1 = cmd & SIXP_PRIO_DATA_MASK;\n}\n\n/* identify and execute a standard 6pack command byte */\n\nstatic void decode_std_command(struct sixpack *sp, unsigned char cmd)\n{\n\tunsigned char checksum = 0, rest = 0;\n\tshort i;\n\n\tswitch (cmd & SIXP_CMD_MASK) {     /* normal command */\n\tcase SIXP_SEOF:\n\t\tif ((sp->rx_count == 0) && (sp->rx_count_cooked == 0)) {\n\t\t\tif ((sp->status & SIXP_RX_DCD_MASK) ==\n\t\t\t\tSIXP_RX_DCD_MASK) {\n\t\t\t\tsp->led_state = 0x68;\n\t\t\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tsp->led_state = 0x60;\n\t\t\t/* fill trailing bytes with zeroes */\n\t\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\t\trest = sp->rx_count;\n\t\t\tif (rest != 0)\n\t\t\t\t for (i = rest; i <= 3; i++)\n\t\t\t\t\tdecode_data(sp, 0);\n\t\t\tif (rest == 2)\n\t\t\t\tsp->rx_count_cooked -= 2;\n\t\t\telse if (rest == 3)\n\t\t\t\tsp->rx_count_cooked -= 1;\n\t\t\tfor (i = 0; i < sp->rx_count_cooked; i++)\n\t\t\t\tchecksum += sp->cooked_buf[i];\n\t\t\tif (checksum != SIXP_CHKSUM) {\n\t\t\t\tprintk(KERN_DEBUG \"6pack: bad checksum %2.2x\\n\", checksum);\n\t\t\t} else {\n\t\t\t\tsp->rcount = sp->rx_count_cooked-2;\n\t\t\t\tsp_bump(sp, 0);\n\t\t\t}\n\t\t\tsp->rx_count_cooked = 0;\n\t\t}\n\t\tbreak;\n\tcase SIXP_TX_URUN: printk(KERN_DEBUG \"6pack: TX underrun\\n\");\n\t\tbreak;\n\tcase SIXP_RX_ORUN: printk(KERN_DEBUG \"6pack: RX overrun\\n\");\n\t\tbreak;\n\tcase SIXP_RX_BUF_OVL:\n\t\tprintk(KERN_DEBUG \"6pack: RX buffer overflow\\n\");\n\t}\n}\n\n/* decode a 6pack packet */\n\nstatic void\nsixpack_decode(struct sixpack *sp, const unsigned char *pre_rbuff, int count)\n{\n\tunsigned char inbyte;\n\tint count1;\n\n\tfor (count1 = 0; count1 < count; count1++) {\n\t\tinbyte = pre_rbuff[count1];\n\t\tif (inbyte == SIXP_FOUND_TNC) {\n\t\t\ttnc_set_sync_state(sp, TNC_IN_SYNC);\n\t\t\tdel_timer(&sp->resync_t);\n\t\t}\n\t\tif ((inbyte & SIXP_PRIO_CMD_MASK) != 0)\n\t\t\tdecode_prio_command(sp, inbyte);\n\t\telse if ((inbyte & SIXP_STD_CMD_MASK) != 0)\n\t\t\tdecode_std_command(sp, inbyte);\n\t\telse if ((sp->status & SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK)\n\t\t\tdecode_data(sp, inbyte);\n\t}\n}\n\nMODULE_AUTHOR(\"Ralf Baechle DO1GRB <ralf@linux-mips.org>\");\nMODULE_DESCRIPTION(\"6pack driver for AX.25\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_6PACK);\n\nmodule_init(sixpack_init_driver);\nmodule_exit(sixpack_exit_driver);\n"], "buggy_code_start_loc": [670], "buggy_code_end_loc": [675], "fixing_code_start_loc": [671], "fixing_code_end_loc": [674], "type": "CWE-416", "message": "A use-after-free vulnerabilitity was discovered in drivers/net/hamradio/6pack.c of linux that allows an attacker to crash linux kernel by simulating ax25 device using 6pack driver from user space.", "other": {"cve": {"id": "CVE-2022-1198", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-29T15:15:10.467", "lastModified": "2022-09-06T18:23:57.490", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A use-after-free vulnerabilitity was discovered in drivers/net/hamradio/6pack.c of linux that allows an attacker to crash linux kernel by simulating ax25 device using 6pack driver from user space."}, {"lang": "es", "value": "Se ha detectado una vulnerabilidad de uso de memoria previamente liberada en el archivo drivers/net/hamradio/6pack.c de linux que permite a un atacante bloquear el kernel de linux al simular el dispositivo ax25 mediante el controlador 6pack desde el espacio de usuario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.17", "matchCriteriaId": "A37A8EE9-3F14-4C7A-A882-DA8A6AD1897C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc1:*:*:*:*:*:*", "matchCriteriaId": "7BD5F8D9-54FA-4CB0-B4F0-CB0471FDDB2D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc2:*:*:*:*:*:*", "matchCriteriaId": "E6E34B23-78B4-4516-9BD8-61B33F4AC49A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc3:*:*:*:*:*:*", "matchCriteriaId": "C030FA3D-03F4-4FB9-9DBF-D08E5CAC51AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc4:*:*:*:*:*:*", "matchCriteriaId": "B2D2677C-5389-4AE9-869D-0F881E80D923"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc5:*:*:*:*:*:*", "matchCriteriaId": "EFA3917C-C322-4D92-912D-ECE45B2E7416"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2022-1198", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2070689", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/efe4186e6a1b54bf38b9e05450d43b0da1fd7739", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2022/04/02/3", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/efe4186e6a1b54bf38b9e05450d43b0da1fd7739"}}