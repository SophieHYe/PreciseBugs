{"buggy_code": ["/*\n * IPv6 fragment reassembly for connection tracking\n *\n * Copyright (C)2004 USAGI/WIDE Project\n *\n * Author:\n *\tYasuyuki Kozakai @USAGI <yasuyuki.kozakai@toshiba.co.jp>\n *\n * Based on: net/ipv6/reassembly.c\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/jiffies.h>\n#include <linux/net.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n#include <net/inet_frag.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/rawv6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/netfilter/ipv6/nf_conntrack_ipv6.h>\n#include <linux/sysctl.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n\nstruct nf_ct_frag6_skb_cb\n{\n\tstruct inet6_skb_parm\th;\n\tint\t\t\toffset;\n\tstruct sk_buff\t\t*orig;\n};\n\n#define NFCT_FRAG6_CB(skb)\t((struct nf_ct_frag6_skb_cb*)((skb)->cb))\n\nstruct nf_ct_frag6_queue\n{\n\tstruct inet_frag_queue\tq;\n\n\t__be32\t\t\tid;\t\t/* fragment id\t\t*/\n\tu32\t\t\tuser;\n\tstruct in6_addr\t\tsaddr;\n\tstruct in6_addr\t\tdaddr;\n\n\tunsigned int\t\tcsum;\n\t__u16\t\t\tnhoffset;\n};\n\nstatic struct inet_frags nf_frags;\nstatic struct netns_frags nf_init_frags;\n\n#ifdef CONFIG_SYSCTL\nstruct ctl_table nf_ct_ipv6_sysctl_table[] = {\n\t{\n\t\t.procname\t= \"nf_conntrack_frag6_timeout\",\n\t\t.data\t\t= &nf_init_frags.timeout,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_frag6_low_thresh\",\n\t\t.data\t\t= &nf_init_frags.low_thresh,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_frag6_high_thresh\",\n\t\t.data\t\t= &nf_init_frags.high_thresh,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n#endif\n\nstatic unsigned int nf_hashfn(struct inet_frag_queue *q)\n{\n\tconst struct nf_ct_frag6_queue *nq;\n\n\tnq = container_of(q, struct nf_ct_frag6_queue, q);\n\treturn inet6_hash_frag(nq->id, &nq->saddr, &nq->daddr, nf_frags.rnd);\n}\n\nstatic void nf_skb_free(struct sk_buff *skb)\n{\n\tif (NFCT_FRAG6_CB(skb)->orig)\n\t\tkfree_skb(NFCT_FRAG6_CB(skb)->orig);\n}\n\n/* Memory Tracking Functions. */\nstatic inline void frag_kfree_skb(struct sk_buff *skb, unsigned int *work)\n{\n\tif (work)\n\t\t*work -= skb->truesize;\n\tatomic_sub(skb->truesize, &nf_init_frags.mem);\n\tnf_skb_free(skb);\n\tkfree_skb(skb);\n}\n\n/* Destruction primitives. */\n\nstatic __inline__ void fq_put(struct nf_ct_frag6_queue *fq)\n{\n\tinet_frag_put(&fq->q, &nf_frags);\n}\n\n/* Kill fq entry. It is not destroyed immediately,\n * because caller (and someone more) holds reference count.\n */\nstatic __inline__ void fq_kill(struct nf_ct_frag6_queue *fq)\n{\n\tinet_frag_kill(&fq->q, &nf_frags);\n}\n\nstatic void nf_ct_frag6_evictor(void)\n{\n\tlocal_bh_disable();\n\tinet_frag_evictor(&nf_init_frags, &nf_frags);\n\tlocal_bh_enable();\n}\n\nstatic void nf_ct_frag6_expire(unsigned long data)\n{\n\tstruct nf_ct_frag6_queue *fq;\n\n\tfq = container_of((struct inet_frag_queue *)data,\n\t\t\tstruct nf_ct_frag6_queue, q);\n\n\tspin_lock(&fq->q.lock);\n\n\tif (fq->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tfq_kill(fq);\n\nout:\n\tspin_unlock(&fq->q.lock);\n\tfq_put(fq);\n}\n\n/* Creation primitives. */\n\nstatic __inline__ struct nf_ct_frag6_queue *\nfq_find(__be32 id, u32 user, struct in6_addr *src, struct in6_addr *dst)\n{\n\tstruct inet_frag_queue *q;\n\tstruct ip6_create_arg arg;\n\tunsigned int hash;\n\n\targ.id = id;\n\targ.user = user;\n\targ.src = src;\n\targ.dst = dst;\n\n\tread_lock_bh(&nf_frags.lock);\n\thash = inet6_hash_frag(id, src, dst, nf_frags.rnd);\n\n\tq = inet_frag_find(&nf_init_frags, &nf_frags, &arg, hash);\n\tlocal_bh_enable();\n\tif (q == NULL)\n\t\tgoto oom;\n\n\treturn container_of(q, struct nf_ct_frag6_queue, q);\n\noom:\n\tpr_debug(\"Can't alloc new queue\\n\");\n\treturn NULL;\n}\n\n\nstatic int nf_ct_frag6_queue(struct nf_ct_frag6_queue *fq, struct sk_buff *skb,\n\t\t\t     const struct frag_hdr *fhdr, int nhoff)\n{\n\tstruct sk_buff *prev, *next;\n\tint offset, end;\n\n\tif (fq->q.last_in & INET_FRAG_COMPLETE) {\n\t\tpr_debug(\"Allready completed\\n\");\n\t\tgoto err;\n\t}\n\n\toffset = ntohs(fhdr->frag_off) & ~0x7;\n\tend = offset + (ntohs(ipv6_hdr(skb)->payload_len) -\n\t\t\t((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\n\n\tif ((unsigned int)end > IPV6_MAXPLEN) {\n\t\tpr_debug(\"offset is too large.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tskb->csum = csum_sub(skb->csum,\n\t\t\t\t     csum_partial(nh, (u8 *)(fhdr + 1) - nh,\n\t\t\t\t\t\t  0));\n\t}\n\n\t/* Is this the final fragment? */\n\tif (!(fhdr->frag_off & htons(IP6_MF))) {\n\t\t/* If we already have some bits beyond end\n\t\t * or have different end, the segment is corrupted.\n\t\t */\n\t\tif (end < fq->q.len ||\n\t\t    ((fq->q.last_in & INET_FRAG_LAST_IN) && end != fq->q.len)) {\n\t\t\tpr_debug(\"already received last fragment\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tfq->q.last_in |= INET_FRAG_LAST_IN;\n\t\tfq->q.len = end;\n\t} else {\n\t\t/* Check if the fragment is rounded to 8 bytes.\n\t\t * Required by the RFC.\n\t\t */\n\t\tif (end & 0x7) {\n\t\t\t/* RFC2460 says always send parameter problem in\n\t\t\t * this case. -DaveM\n\t\t\t */\n\t\t\tpr_debug(\"end of fragment not rounded to 8 bytes.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (end > fq->q.len) {\n\t\t\t/* Some bits beyond end -> corruption. */\n\t\t\tif (fq->q.last_in & INET_FRAG_LAST_IN) {\n\t\t\t\tpr_debug(\"last packet already reached.\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tfq->q.len = end;\n\t\t}\n\t}\n\n\tif (end == offset)\n\t\tgoto err;\n\n\t/* Point into the IP datagram 'data' part. */\n\tif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data)) {\n\t\tpr_debug(\"queue: message is too short.\\n\");\n\t\tgoto err;\n\t}\n\tif (pskb_trim_rcsum(skb, end - offset)) {\n\t\tpr_debug(\"Can't trim\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Find out which fragments are in front and at the back of us\n\t * in the chain of fragments so far.  We must know where to put\n\t * this fragment, right?\n\t */\n\tprev = NULL;\n\tfor (next = fq->q.fragments; next != NULL; next = next->next) {\n\t\tif (NFCT_FRAG6_CB(next)->offset >= offset)\n\t\t\tbreak;\t/* bingo! */\n\t\tprev = next;\n\t}\n\n\t/* We found where to put this one.  Check for overlap with\n\t * preceding fragment, and, if needed, align things so that\n\t * any overlaps are eliminated.\n\t */\n\tif (prev) {\n\t\tint i = (NFCT_FRAG6_CB(prev)->offset + prev->len) - offset;\n\n\t\tif (i > 0) {\n\t\t\toffset += i;\n\t\t\tif (end <= offset) {\n\t\t\t\tpr_debug(\"overlap\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (!pskb_pull(skb, i)) {\n\t\t\t\tpr_debug(\"Can't pull\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (skb->ip_summed != CHECKSUM_UNNECESSARY)\n\t\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t}\n\n\t/* Look for overlap with succeeding segments.\n\t * If we can merge fragments, do it.\n\t */\n\twhile (next && NFCT_FRAG6_CB(next)->offset < end) {\n\t\t/* overlap is 'i' bytes */\n\t\tint i = end - NFCT_FRAG6_CB(next)->offset;\n\n\t\tif (i < next->len) {\n\t\t\t/* Eat head of the next overlapped fragment\n\t\t\t * and leave the loop. The next ones cannot overlap.\n\t\t\t */\n\t\t\tpr_debug(\"Eat head of the overlapped parts.: %d\", i);\n\t\t\tif (!pskb_pull(next, i))\n\t\t\t\tgoto err;\n\n\t\t\t/* next fragment */\n\t\t\tNFCT_FRAG6_CB(next)->offset += i;\n\t\t\tfq->q.meat -= i;\n\t\t\tif (next->ip_summed != CHECKSUM_UNNECESSARY)\n\t\t\t\tnext->ip_summed = CHECKSUM_NONE;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct sk_buff *free_it = next;\n\n\t\t\t/* Old fragmnet is completely overridden with\n\t\t\t * new one drop it.\n\t\t\t */\n\t\t\tnext = next->next;\n\n\t\t\tif (prev)\n\t\t\t\tprev->next = next;\n\t\t\telse\n\t\t\t\tfq->q.fragments = next;\n\n\t\t\tfq->q.meat -= free_it->len;\n\t\t\tfrag_kfree_skb(free_it, NULL);\n\t\t}\n\t}\n\n\tNFCT_FRAG6_CB(skb)->offset = offset;\n\n\t/* Insert this fragment in the chain of fragments. */\n\tskb->next = next;\n\tif (prev)\n\t\tprev->next = skb;\n\telse\n\t\tfq->q.fragments = skb;\n\n\tskb->dev = NULL;\n\tfq->q.stamp = skb->tstamp;\n\tfq->q.meat += skb->len;\n\tatomic_add(skb->truesize, &nf_init_frags.mem);\n\n\t/* The first fragment.\n\t * nhoffset is obtained from the first fragment, of course.\n\t */\n\tif (offset == 0) {\n\t\tfq->nhoffset = nhoff;\n\t\tfq->q.last_in |= INET_FRAG_FIRST_IN;\n\t}\n\twrite_lock(&nf_frags.lock);\n\tlist_move_tail(&fq->q.lru_list, &nf_init_frags.lru_list);\n\twrite_unlock(&nf_frags.lock);\n\treturn 0;\n\nerr:\n\treturn -1;\n}\n\n/*\n *\tCheck if this packet is complete.\n *\tReturns NULL on failure by any reason, and pointer\n *\tto current nexthdr field in reassembled frame.\n *\n *\tIt is called with locked fq, and caller must check that\n *\tqueue is eligible for reassembly i.e. it is not COMPLETE,\n *\tthe last and the first frames arrived and all the bits are here.\n */\nstatic struct sk_buff *\nnf_ct_frag6_reasm(struct nf_ct_frag6_queue *fq, struct net_device *dev)\n{\n\tstruct sk_buff *fp, *op, *head = fq->q.fragments;\n\tint    payload_len;\n\n\tfq_kill(fq);\n\n\tWARN_ON(head == NULL);\n\tWARN_ON(NFCT_FRAG6_CB(head)->offset != 0);\n\n\t/* Unfragmented part is taken from the first segment. */\n\tpayload_len = ((head->data - skb_network_header(head)) -\n\t\t       sizeof(struct ipv6hdr) + fq->q.len -\n\t\t       sizeof(struct frag_hdr));\n\tif (payload_len > IPV6_MAXPLEN) {\n\t\tpr_debug(\"payload len is too large.\\n\");\n\t\tgoto out_oversize;\n\t}\n\n\t/* Head of list must not be cloned. */\n\tif (skb_cloned(head) && pskb_expand_head(head, 0, 0, GFP_ATOMIC)) {\n\t\tpr_debug(\"skb is cloned but can't expand head\");\n\t\tgoto out_oom;\n\t}\n\n\t/* If the first fragment is fragmented itself, we split\n\t * it to two chunks: the first with data and paged part\n\t * and the second, holding only fragments. */\n\tif (skb_has_frags(head)) {\n\t\tstruct sk_buff *clone;\n\t\tint i, plen = 0;\n\n\t\tif ((clone = alloc_skb(0, GFP_ATOMIC)) == NULL) {\n\t\t\tpr_debug(\"Can't alloc skb\\n\");\n\t\t\tgoto out_oom;\n\t\t}\n\t\tclone->next = head->next;\n\t\thead->next = clone;\n\t\tskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\n\t\tskb_frag_list_init(head);\n\t\tfor (i=0; i<skb_shinfo(head)->nr_frags; i++)\n\t\t\tplen += skb_shinfo(head)->frags[i].size;\n\t\tclone->len = clone->data_len = head->data_len - plen;\n\t\thead->data_len -= clone->len;\n\t\thead->len -= clone->len;\n\t\tclone->csum = 0;\n\t\tclone->ip_summed = head->ip_summed;\n\n\t\tNFCT_FRAG6_CB(clone)->orig = NULL;\n\t\tatomic_add(clone->truesize, &nf_init_frags.mem);\n\t}\n\n\t/* We have to remove fragment header from datagram and to relocate\n\t * header in order to calculate ICV correctly. */\n\tskb_network_header(head)[fq->nhoffset] = skb_transport_header(head)[0];\n\tmemmove(head->head + sizeof(struct frag_hdr), head->head,\n\t\t(head->data - head->head) - sizeof(struct frag_hdr));\n\thead->mac_header += sizeof(struct frag_hdr);\n\thead->network_header += sizeof(struct frag_hdr);\n\n\tskb_shinfo(head)->frag_list = head->next;\n\tskb_reset_transport_header(head);\n\tskb_push(head, head->data - skb_network_header(head));\n\tatomic_sub(head->truesize, &nf_init_frags.mem);\n\n\tfor (fp=head->next; fp; fp = fp->next) {\n\t\thead->data_len += fp->len;\n\t\thead->len += fp->len;\n\t\tif (head->ip_summed != fp->ip_summed)\n\t\t\thead->ip_summed = CHECKSUM_NONE;\n\t\telse if (head->ip_summed == CHECKSUM_COMPLETE)\n\t\t\thead->csum = csum_add(head->csum, fp->csum);\n\t\thead->truesize += fp->truesize;\n\t\tatomic_sub(fp->truesize, &nf_init_frags.mem);\n\t}\n\n\thead->next = NULL;\n\thead->dev = dev;\n\thead->tstamp = fq->q.stamp;\n\tipv6_hdr(head)->payload_len = htons(payload_len);\n\n\t/* Yes, and fold redundant checksum back. 8) */\n\tif (head->ip_summed == CHECKSUM_COMPLETE)\n\t\thead->csum = csum_partial(skb_network_header(head),\n\t\t\t\t\t  skb_network_header_len(head),\n\t\t\t\t\t  head->csum);\n\n\tfq->q.fragments = NULL;\n\n\t/* all original skbs are linked into the NFCT_FRAG6_CB(head).orig */\n\tfp = skb_shinfo(head)->frag_list;\n\tif (NFCT_FRAG6_CB(fp)->orig == NULL)\n\t\t/* at above code, head skb is divided into two skbs. */\n\t\tfp = fp->next;\n\n\top = NFCT_FRAG6_CB(head)->orig;\n\tfor (; fp; fp = fp->next) {\n\t\tstruct sk_buff *orig = NFCT_FRAG6_CB(fp)->orig;\n\n\t\top->next = orig;\n\t\top = orig;\n\t\tNFCT_FRAG6_CB(fp)->orig = NULL;\n\t}\n\n\treturn head;\n\nout_oversize:\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"nf_ct_frag6_reasm: payload len = %d\\n\", payload_len);\n\tgoto out_fail;\nout_oom:\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"nf_ct_frag6_reasm: no memory for reassembly\\n\");\nout_fail:\n\treturn NULL;\n}\n\n/*\n * find the header just before Fragment Header.\n *\n * if success return 0 and set ...\n * (*prevhdrp): the value of \"Next Header Field\" in the header\n *\t\tjust before Fragment Header.\n * (*prevhoff): the offset of \"Next Header Field\" in the header\n *\t\tjust before Fragment Header.\n * (*fhoff)   : the offset of Fragment Header.\n *\n * Based on ipv6_skip_hdr() in net/ipv6/exthdr.c\n *\n */\nstatic int\nfind_prev_fhdr(struct sk_buff *skb, u8 *prevhdrp, int *prevhoff, int *fhoff)\n{\n\tu8 nexthdr = ipv6_hdr(skb)->nexthdr;\n\tconst int netoff = skb_network_offset(skb);\n\tu8 prev_nhoff = netoff + offsetof(struct ipv6hdr, nexthdr);\n\tint start = netoff + sizeof(struct ipv6hdr);\n\tint len = skb->len - start;\n\tu8 prevhdr = NEXTHDR_IPV6;\n\n\twhile (nexthdr != NEXTHDR_FRAGMENT) {\n\t\tstruct ipv6_opt_hdr hdr;\n\t\tint hdrlen;\n\n\t\tif (!ipv6_ext_hdr(nexthdr)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (nexthdr == NEXTHDR_NONE) {\n\t\t\tpr_debug(\"next header is none\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (len < (int)sizeof(struct ipv6_opt_hdr)) {\n\t\t\tpr_debug(\"too short\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (skb_copy_bits(skb, start, &hdr, sizeof(hdr)))\n\t\t\tBUG();\n\t\tif (nexthdr == NEXTHDR_AUTH)\n\t\t\thdrlen = (hdr.hdrlen+2)<<2;\n\t\telse\n\t\t\thdrlen = ipv6_optlen(&hdr);\n\n\t\tprevhdr = nexthdr;\n\t\tprev_nhoff = start;\n\n\t\tnexthdr = hdr.nexthdr;\n\t\tlen -= hdrlen;\n\t\tstart += hdrlen;\n\t}\n\n\tif (len < 0)\n\t\treturn -1;\n\n\t*prevhdrp = prevhdr;\n\t*prevhoff = prev_nhoff;\n\t*fhoff = start;\n\n\treturn 0;\n}\n\nstruct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)\n{\n\tstruct sk_buff *clone;\n\tstruct net_device *dev = skb->dev;\n\tstruct frag_hdr *fhdr;\n\tstruct nf_ct_frag6_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tint fhoff, nhoff;\n\tu8 prevhdr;\n\tstruct sk_buff *ret_skb = NULL;\n\n\t/* Jumbo payload inhibits frag. header */\n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn skb;\n\t}\n\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn skb;\n\n\tclone = skb_clone(skb, GFP_ATOMIC);\n\tif (clone == NULL) {\n\t\tpr_debug(\"Can't clone skb\\n\");\n\t\treturn skb;\n\t}\n\n\tNFCT_FRAG6_CB(clone)->orig = skb;\n\n\tif (!pskb_may_pull(clone, fhoff + sizeof(*fhdr))) {\n\t\tpr_debug(\"message is too short.\\n\");\n\t\tgoto ret_orig;\n\t}\n\n\tskb_set_transport_header(clone, fhoff);\n\thdr = ipv6_hdr(clone);\n\tfhdr = (struct frag_hdr *)skb_transport_header(clone);\n\n\tif (!(fhdr->frag_off & htons(0xFFF9))) {\n\t\tpr_debug(\"Invalid fragment offset\\n\");\n\t\t/* It is not a fragmented frame */\n\t\tgoto ret_orig;\n\t}\n\n\tif (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)\n\t\tnf_ct_frag6_evictor();\n\n\tfq = fq_find(fhdr->identification, user, &hdr->saddr, &hdr->daddr);\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\tgoto ret_orig;\n\t}\n\n\tspin_lock_bh(&fq->q.lock);\n\n\tif (nf_ct_frag6_queue(fq, clone, fhdr, nhoff) < 0) {\n\t\tspin_unlock_bh(&fq->q.lock);\n\t\tpr_debug(\"Can't insert skb to queue\\n\");\n\t\tfq_put(fq);\n\t\tgoto ret_orig;\n\t}\n\n\tif (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len) {\n\t\tret_skb = nf_ct_frag6_reasm(fq, dev);\n\t\tif (ret_skb == NULL)\n\t\t\tpr_debug(\"Can't reassemble fragmented packets\\n\");\n\t}\n\tspin_unlock_bh(&fq->q.lock);\n\n\tfq_put(fq);\n\treturn ret_skb;\n\nret_orig:\n\tkfree_skb(clone);\n\treturn skb;\n}\n\nvoid nf_ct_frag6_output(unsigned int hooknum, struct sk_buff *skb,\n\t\t\tstruct net_device *in, struct net_device *out,\n\t\t\tint (*okfn)(struct sk_buff *))\n{\n\tstruct sk_buff *s, *s2;\n\n\tfor (s = NFCT_FRAG6_CB(skb)->orig; s;) {\n\t\tnf_conntrack_put_reasm(s->nfct_reasm);\n\t\tnf_conntrack_get_reasm(skb);\n\t\ts->nfct_reasm = skb;\n\n\t\ts2 = s->next;\n\t\ts->next = NULL;\n\n\t\tNF_HOOK_THRESH(PF_INET6, hooknum, s, in, out, okfn,\n\t\t\t       NF_IP6_PRI_CONNTRACK_DEFRAG + 1);\n\t\ts = s2;\n\t}\n\tnf_conntrack_put_reasm(skb);\n}\n\nint nf_ct_frag6_init(void)\n{\n\tnf_frags.hashfn = nf_hashfn;\n\tnf_frags.constructor = ip6_frag_init;\n\tnf_frags.destructor = NULL;\n\tnf_frags.skb_free = nf_skb_free;\n\tnf_frags.qsize = sizeof(struct nf_ct_frag6_queue);\n\tnf_frags.match = ip6_frag_match;\n\tnf_frags.frag_expire = nf_ct_frag6_expire;\n\tnf_frags.secret_interval = 10 * 60 * HZ;\n\tnf_init_frags.timeout = IPV6_FRAG_TIMEOUT;\n\tnf_init_frags.high_thresh = IPV6_FRAG_HIGH_THRESH;\n\tnf_init_frags.low_thresh = IPV6_FRAG_LOW_THRESH;\n\tinet_frags_init_net(&nf_init_frags);\n\tinet_frags_init(&nf_frags);\n\n\treturn 0;\n}\n\nvoid nf_ct_frag6_cleanup(void)\n{\n\tinet_frags_fini(&nf_frags);\n\n\tnf_init_frags.low_thresh = 0;\n\tnf_ct_frag6_evictor();\n}\n"], "fixing_code": ["/*\n * IPv6 fragment reassembly for connection tracking\n *\n * Copyright (C)2004 USAGI/WIDE Project\n *\n * Author:\n *\tYasuyuki Kozakai @USAGI <yasuyuki.kozakai@toshiba.co.jp>\n *\n * Based on: net/ipv6/reassembly.c\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/jiffies.h>\n#include <linux/net.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n#include <net/inet_frag.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/rawv6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/netfilter/ipv6/nf_conntrack_ipv6.h>\n#include <linux/sysctl.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n\nstruct nf_ct_frag6_skb_cb\n{\n\tstruct inet6_skb_parm\th;\n\tint\t\t\toffset;\n\tstruct sk_buff\t\t*orig;\n};\n\n#define NFCT_FRAG6_CB(skb)\t((struct nf_ct_frag6_skb_cb*)((skb)->cb))\n\nstruct nf_ct_frag6_queue\n{\n\tstruct inet_frag_queue\tq;\n\n\t__be32\t\t\tid;\t\t/* fragment id\t\t*/\n\tu32\t\t\tuser;\n\tstruct in6_addr\t\tsaddr;\n\tstruct in6_addr\t\tdaddr;\n\n\tunsigned int\t\tcsum;\n\t__u16\t\t\tnhoffset;\n};\n\nstatic struct inet_frags nf_frags;\nstatic struct netns_frags nf_init_frags;\n\n#ifdef CONFIG_SYSCTL\nstruct ctl_table nf_ct_ipv6_sysctl_table[] = {\n\t{\n\t\t.procname\t= \"nf_conntrack_frag6_timeout\",\n\t\t.data\t\t= &nf_init_frags.timeout,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_frag6_low_thresh\",\n\t\t.data\t\t= &nf_init_frags.low_thresh,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_frag6_high_thresh\",\n\t\t.data\t\t= &nf_init_frags.high_thresh,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n#endif\n\nstatic unsigned int nf_hashfn(struct inet_frag_queue *q)\n{\n\tconst struct nf_ct_frag6_queue *nq;\n\n\tnq = container_of(q, struct nf_ct_frag6_queue, q);\n\treturn inet6_hash_frag(nq->id, &nq->saddr, &nq->daddr, nf_frags.rnd);\n}\n\nstatic void nf_skb_free(struct sk_buff *skb)\n{\n\tif (NFCT_FRAG6_CB(skb)->orig)\n\t\tkfree_skb(NFCT_FRAG6_CB(skb)->orig);\n}\n\n/* Memory Tracking Functions. */\nstatic inline void frag_kfree_skb(struct sk_buff *skb, unsigned int *work)\n{\n\tif (work)\n\t\t*work -= skb->truesize;\n\tatomic_sub(skb->truesize, &nf_init_frags.mem);\n\tnf_skb_free(skb);\n\tkfree_skb(skb);\n}\n\n/* Destruction primitives. */\n\nstatic __inline__ void fq_put(struct nf_ct_frag6_queue *fq)\n{\n\tinet_frag_put(&fq->q, &nf_frags);\n}\n\n/* Kill fq entry. It is not destroyed immediately,\n * because caller (and someone more) holds reference count.\n */\nstatic __inline__ void fq_kill(struct nf_ct_frag6_queue *fq)\n{\n\tinet_frag_kill(&fq->q, &nf_frags);\n}\n\nstatic void nf_ct_frag6_evictor(void)\n{\n\tlocal_bh_disable();\n\tinet_frag_evictor(&nf_init_frags, &nf_frags);\n\tlocal_bh_enable();\n}\n\nstatic void nf_ct_frag6_expire(unsigned long data)\n{\n\tstruct nf_ct_frag6_queue *fq;\n\n\tfq = container_of((struct inet_frag_queue *)data,\n\t\t\tstruct nf_ct_frag6_queue, q);\n\n\tspin_lock(&fq->q.lock);\n\n\tif (fq->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tfq_kill(fq);\n\nout:\n\tspin_unlock(&fq->q.lock);\n\tfq_put(fq);\n}\n\n/* Creation primitives. */\n\nstatic __inline__ struct nf_ct_frag6_queue *\nfq_find(__be32 id, u32 user, struct in6_addr *src, struct in6_addr *dst)\n{\n\tstruct inet_frag_queue *q;\n\tstruct ip6_create_arg arg;\n\tunsigned int hash;\n\n\targ.id = id;\n\targ.user = user;\n\targ.src = src;\n\targ.dst = dst;\n\n\tread_lock_bh(&nf_frags.lock);\n\thash = inet6_hash_frag(id, src, dst, nf_frags.rnd);\n\n\tq = inet_frag_find(&nf_init_frags, &nf_frags, &arg, hash);\n\tlocal_bh_enable();\n\tif (q == NULL)\n\t\tgoto oom;\n\n\treturn container_of(q, struct nf_ct_frag6_queue, q);\n\noom:\n\tpr_debug(\"Can't alloc new queue\\n\");\n\treturn NULL;\n}\n\n\nstatic int nf_ct_frag6_queue(struct nf_ct_frag6_queue *fq, struct sk_buff *skb,\n\t\t\t     const struct frag_hdr *fhdr, int nhoff)\n{\n\tstruct sk_buff *prev, *next;\n\tint offset, end;\n\n\tif (fq->q.last_in & INET_FRAG_COMPLETE) {\n\t\tpr_debug(\"Allready completed\\n\");\n\t\tgoto err;\n\t}\n\n\toffset = ntohs(fhdr->frag_off) & ~0x7;\n\tend = offset + (ntohs(ipv6_hdr(skb)->payload_len) -\n\t\t\t((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\n\n\tif ((unsigned int)end > IPV6_MAXPLEN) {\n\t\tpr_debug(\"offset is too large.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tskb->csum = csum_sub(skb->csum,\n\t\t\t\t     csum_partial(nh, (u8 *)(fhdr + 1) - nh,\n\t\t\t\t\t\t  0));\n\t}\n\n\t/* Is this the final fragment? */\n\tif (!(fhdr->frag_off & htons(IP6_MF))) {\n\t\t/* If we already have some bits beyond end\n\t\t * or have different end, the segment is corrupted.\n\t\t */\n\t\tif (end < fq->q.len ||\n\t\t    ((fq->q.last_in & INET_FRAG_LAST_IN) && end != fq->q.len)) {\n\t\t\tpr_debug(\"already received last fragment\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tfq->q.last_in |= INET_FRAG_LAST_IN;\n\t\tfq->q.len = end;\n\t} else {\n\t\t/* Check if the fragment is rounded to 8 bytes.\n\t\t * Required by the RFC.\n\t\t */\n\t\tif (end & 0x7) {\n\t\t\t/* RFC2460 says always send parameter problem in\n\t\t\t * this case. -DaveM\n\t\t\t */\n\t\t\tpr_debug(\"end of fragment not rounded to 8 bytes.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (end > fq->q.len) {\n\t\t\t/* Some bits beyond end -> corruption. */\n\t\t\tif (fq->q.last_in & INET_FRAG_LAST_IN) {\n\t\t\t\tpr_debug(\"last packet already reached.\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tfq->q.len = end;\n\t\t}\n\t}\n\n\tif (end == offset)\n\t\tgoto err;\n\n\t/* Point into the IP datagram 'data' part. */\n\tif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data)) {\n\t\tpr_debug(\"queue: message is too short.\\n\");\n\t\tgoto err;\n\t}\n\tif (pskb_trim_rcsum(skb, end - offset)) {\n\t\tpr_debug(\"Can't trim\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Find out which fragments are in front and at the back of us\n\t * in the chain of fragments so far.  We must know where to put\n\t * this fragment, right?\n\t */\n\tprev = NULL;\n\tfor (next = fq->q.fragments; next != NULL; next = next->next) {\n\t\tif (NFCT_FRAG6_CB(next)->offset >= offset)\n\t\t\tbreak;\t/* bingo! */\n\t\tprev = next;\n\t}\n\n\t/* We found where to put this one.  Check for overlap with\n\t * preceding fragment, and, if needed, align things so that\n\t * any overlaps are eliminated.\n\t */\n\tif (prev) {\n\t\tint i = (NFCT_FRAG6_CB(prev)->offset + prev->len) - offset;\n\n\t\tif (i > 0) {\n\t\t\toffset += i;\n\t\t\tif (end <= offset) {\n\t\t\t\tpr_debug(\"overlap\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (!pskb_pull(skb, i)) {\n\t\t\t\tpr_debug(\"Can't pull\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (skb->ip_summed != CHECKSUM_UNNECESSARY)\n\t\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t}\n\n\t/* Look for overlap with succeeding segments.\n\t * If we can merge fragments, do it.\n\t */\n\twhile (next && NFCT_FRAG6_CB(next)->offset < end) {\n\t\t/* overlap is 'i' bytes */\n\t\tint i = end - NFCT_FRAG6_CB(next)->offset;\n\n\t\tif (i < next->len) {\n\t\t\t/* Eat head of the next overlapped fragment\n\t\t\t * and leave the loop. The next ones cannot overlap.\n\t\t\t */\n\t\t\tpr_debug(\"Eat head of the overlapped parts.: %d\", i);\n\t\t\tif (!pskb_pull(next, i))\n\t\t\t\tgoto err;\n\n\t\t\t/* next fragment */\n\t\t\tNFCT_FRAG6_CB(next)->offset += i;\n\t\t\tfq->q.meat -= i;\n\t\t\tif (next->ip_summed != CHECKSUM_UNNECESSARY)\n\t\t\t\tnext->ip_summed = CHECKSUM_NONE;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct sk_buff *free_it = next;\n\n\t\t\t/* Old fragmnet is completely overridden with\n\t\t\t * new one drop it.\n\t\t\t */\n\t\t\tnext = next->next;\n\n\t\t\tif (prev)\n\t\t\t\tprev->next = next;\n\t\t\telse\n\t\t\t\tfq->q.fragments = next;\n\n\t\t\tfq->q.meat -= free_it->len;\n\t\t\tfrag_kfree_skb(free_it, NULL);\n\t\t}\n\t}\n\n\tNFCT_FRAG6_CB(skb)->offset = offset;\n\n\t/* Insert this fragment in the chain of fragments. */\n\tskb->next = next;\n\tif (prev)\n\t\tprev->next = skb;\n\telse\n\t\tfq->q.fragments = skb;\n\n\tskb->dev = NULL;\n\tfq->q.stamp = skb->tstamp;\n\tfq->q.meat += skb->len;\n\tatomic_add(skb->truesize, &nf_init_frags.mem);\n\n\t/* The first fragment.\n\t * nhoffset is obtained from the first fragment, of course.\n\t */\n\tif (offset == 0) {\n\t\tfq->nhoffset = nhoff;\n\t\tfq->q.last_in |= INET_FRAG_FIRST_IN;\n\t}\n\twrite_lock(&nf_frags.lock);\n\tlist_move_tail(&fq->q.lru_list, &nf_init_frags.lru_list);\n\twrite_unlock(&nf_frags.lock);\n\treturn 0;\n\nerr:\n\treturn -1;\n}\n\n/*\n *\tCheck if this packet is complete.\n *\tReturns NULL on failure by any reason, and pointer\n *\tto current nexthdr field in reassembled frame.\n *\n *\tIt is called with locked fq, and caller must check that\n *\tqueue is eligible for reassembly i.e. it is not COMPLETE,\n *\tthe last and the first frames arrived and all the bits are here.\n */\nstatic struct sk_buff *\nnf_ct_frag6_reasm(struct nf_ct_frag6_queue *fq, struct net_device *dev)\n{\n\tstruct sk_buff *fp, *op, *head = fq->q.fragments;\n\tint    payload_len;\n\n\tfq_kill(fq);\n\n\tWARN_ON(head == NULL);\n\tWARN_ON(NFCT_FRAG6_CB(head)->offset != 0);\n\n\t/* Unfragmented part is taken from the first segment. */\n\tpayload_len = ((head->data - skb_network_header(head)) -\n\t\t       sizeof(struct ipv6hdr) + fq->q.len -\n\t\t       sizeof(struct frag_hdr));\n\tif (payload_len > IPV6_MAXPLEN) {\n\t\tpr_debug(\"payload len is too large.\\n\");\n\t\tgoto out_oversize;\n\t}\n\n\t/* Head of list must not be cloned. */\n\tif (skb_cloned(head) && pskb_expand_head(head, 0, 0, GFP_ATOMIC)) {\n\t\tpr_debug(\"skb is cloned but can't expand head\");\n\t\tgoto out_oom;\n\t}\n\n\t/* If the first fragment is fragmented itself, we split\n\t * it to two chunks: the first with data and paged part\n\t * and the second, holding only fragments. */\n\tif (skb_has_frags(head)) {\n\t\tstruct sk_buff *clone;\n\t\tint i, plen = 0;\n\n\t\tif ((clone = alloc_skb(0, GFP_ATOMIC)) == NULL) {\n\t\t\tpr_debug(\"Can't alloc skb\\n\");\n\t\t\tgoto out_oom;\n\t\t}\n\t\tclone->next = head->next;\n\t\thead->next = clone;\n\t\tskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\n\t\tskb_frag_list_init(head);\n\t\tfor (i=0; i<skb_shinfo(head)->nr_frags; i++)\n\t\t\tplen += skb_shinfo(head)->frags[i].size;\n\t\tclone->len = clone->data_len = head->data_len - plen;\n\t\thead->data_len -= clone->len;\n\t\thead->len -= clone->len;\n\t\tclone->csum = 0;\n\t\tclone->ip_summed = head->ip_summed;\n\n\t\tNFCT_FRAG6_CB(clone)->orig = NULL;\n\t\tatomic_add(clone->truesize, &nf_init_frags.mem);\n\t}\n\n\t/* We have to remove fragment header from datagram and to relocate\n\t * header in order to calculate ICV correctly. */\n\tskb_network_header(head)[fq->nhoffset] = skb_transport_header(head)[0];\n\tmemmove(head->head + sizeof(struct frag_hdr), head->head,\n\t\t(head->data - head->head) - sizeof(struct frag_hdr));\n\thead->mac_header += sizeof(struct frag_hdr);\n\thead->network_header += sizeof(struct frag_hdr);\n\n\tskb_shinfo(head)->frag_list = head->next;\n\tskb_reset_transport_header(head);\n\tskb_push(head, head->data - skb_network_header(head));\n\tatomic_sub(head->truesize, &nf_init_frags.mem);\n\n\tfor (fp=head->next; fp; fp = fp->next) {\n\t\thead->data_len += fp->len;\n\t\thead->len += fp->len;\n\t\tif (head->ip_summed != fp->ip_summed)\n\t\t\thead->ip_summed = CHECKSUM_NONE;\n\t\telse if (head->ip_summed == CHECKSUM_COMPLETE)\n\t\t\thead->csum = csum_add(head->csum, fp->csum);\n\t\thead->truesize += fp->truesize;\n\t\tatomic_sub(fp->truesize, &nf_init_frags.mem);\n\t}\n\n\thead->next = NULL;\n\thead->dev = dev;\n\thead->tstamp = fq->q.stamp;\n\tipv6_hdr(head)->payload_len = htons(payload_len);\n\n\t/* Yes, and fold redundant checksum back. 8) */\n\tif (head->ip_summed == CHECKSUM_COMPLETE)\n\t\thead->csum = csum_partial(skb_network_header(head),\n\t\t\t\t\t  skb_network_header_len(head),\n\t\t\t\t\t  head->csum);\n\n\tfq->q.fragments = NULL;\n\n\t/* all original skbs are linked into the NFCT_FRAG6_CB(head).orig */\n\tfp = skb_shinfo(head)->frag_list;\n\tif (fp && NFCT_FRAG6_CB(fp)->orig == NULL)\n\t\t/* at above code, head skb is divided into two skbs. */\n\t\tfp = fp->next;\n\n\top = NFCT_FRAG6_CB(head)->orig;\n\tfor (; fp; fp = fp->next) {\n\t\tstruct sk_buff *orig = NFCT_FRAG6_CB(fp)->orig;\n\n\t\top->next = orig;\n\t\top = orig;\n\t\tNFCT_FRAG6_CB(fp)->orig = NULL;\n\t}\n\n\treturn head;\n\nout_oversize:\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"nf_ct_frag6_reasm: payload len = %d\\n\", payload_len);\n\tgoto out_fail;\nout_oom:\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"nf_ct_frag6_reasm: no memory for reassembly\\n\");\nout_fail:\n\treturn NULL;\n}\n\n/*\n * find the header just before Fragment Header.\n *\n * if success return 0 and set ...\n * (*prevhdrp): the value of \"Next Header Field\" in the header\n *\t\tjust before Fragment Header.\n * (*prevhoff): the offset of \"Next Header Field\" in the header\n *\t\tjust before Fragment Header.\n * (*fhoff)   : the offset of Fragment Header.\n *\n * Based on ipv6_skip_hdr() in net/ipv6/exthdr.c\n *\n */\nstatic int\nfind_prev_fhdr(struct sk_buff *skb, u8 *prevhdrp, int *prevhoff, int *fhoff)\n{\n\tu8 nexthdr = ipv6_hdr(skb)->nexthdr;\n\tconst int netoff = skb_network_offset(skb);\n\tu8 prev_nhoff = netoff + offsetof(struct ipv6hdr, nexthdr);\n\tint start = netoff + sizeof(struct ipv6hdr);\n\tint len = skb->len - start;\n\tu8 prevhdr = NEXTHDR_IPV6;\n\n\twhile (nexthdr != NEXTHDR_FRAGMENT) {\n\t\tstruct ipv6_opt_hdr hdr;\n\t\tint hdrlen;\n\n\t\tif (!ipv6_ext_hdr(nexthdr)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (nexthdr == NEXTHDR_NONE) {\n\t\t\tpr_debug(\"next header is none\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (len < (int)sizeof(struct ipv6_opt_hdr)) {\n\t\t\tpr_debug(\"too short\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (skb_copy_bits(skb, start, &hdr, sizeof(hdr)))\n\t\t\tBUG();\n\t\tif (nexthdr == NEXTHDR_AUTH)\n\t\t\thdrlen = (hdr.hdrlen+2)<<2;\n\t\telse\n\t\t\thdrlen = ipv6_optlen(&hdr);\n\n\t\tprevhdr = nexthdr;\n\t\tprev_nhoff = start;\n\n\t\tnexthdr = hdr.nexthdr;\n\t\tlen -= hdrlen;\n\t\tstart += hdrlen;\n\t}\n\n\tif (len < 0)\n\t\treturn -1;\n\n\t*prevhdrp = prevhdr;\n\t*prevhoff = prev_nhoff;\n\t*fhoff = start;\n\n\treturn 0;\n}\n\nstruct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)\n{\n\tstruct sk_buff *clone;\n\tstruct net_device *dev = skb->dev;\n\tstruct frag_hdr *fhdr;\n\tstruct nf_ct_frag6_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tint fhoff, nhoff;\n\tu8 prevhdr;\n\tstruct sk_buff *ret_skb = NULL;\n\n\t/* Jumbo payload inhibits frag. header */\n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn skb;\n\t}\n\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn skb;\n\n\tclone = skb_clone(skb, GFP_ATOMIC);\n\tif (clone == NULL) {\n\t\tpr_debug(\"Can't clone skb\\n\");\n\t\treturn skb;\n\t}\n\n\tNFCT_FRAG6_CB(clone)->orig = skb;\n\n\tif (!pskb_may_pull(clone, fhoff + sizeof(*fhdr))) {\n\t\tpr_debug(\"message is too short.\\n\");\n\t\tgoto ret_orig;\n\t}\n\n\tskb_set_transport_header(clone, fhoff);\n\thdr = ipv6_hdr(clone);\n\tfhdr = (struct frag_hdr *)skb_transport_header(clone);\n\n\tif (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)\n\t\tnf_ct_frag6_evictor();\n\n\tfq = fq_find(fhdr->identification, user, &hdr->saddr, &hdr->daddr);\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\tgoto ret_orig;\n\t}\n\n\tspin_lock_bh(&fq->q.lock);\n\n\tif (nf_ct_frag6_queue(fq, clone, fhdr, nhoff) < 0) {\n\t\tspin_unlock_bh(&fq->q.lock);\n\t\tpr_debug(\"Can't insert skb to queue\\n\");\n\t\tfq_put(fq);\n\t\tgoto ret_orig;\n\t}\n\n\tif (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len) {\n\t\tret_skb = nf_ct_frag6_reasm(fq, dev);\n\t\tif (ret_skb == NULL)\n\t\t\tpr_debug(\"Can't reassemble fragmented packets\\n\");\n\t}\n\tspin_unlock_bh(&fq->q.lock);\n\n\tfq_put(fq);\n\treturn ret_skb;\n\nret_orig:\n\tkfree_skb(clone);\n\treturn skb;\n}\n\nvoid nf_ct_frag6_output(unsigned int hooknum, struct sk_buff *skb,\n\t\t\tstruct net_device *in, struct net_device *out,\n\t\t\tint (*okfn)(struct sk_buff *))\n{\n\tstruct sk_buff *s, *s2;\n\n\tfor (s = NFCT_FRAG6_CB(skb)->orig; s;) {\n\t\tnf_conntrack_put_reasm(s->nfct_reasm);\n\t\tnf_conntrack_get_reasm(skb);\n\t\ts->nfct_reasm = skb;\n\n\t\ts2 = s->next;\n\t\ts->next = NULL;\n\n\t\tNF_HOOK_THRESH(PF_INET6, hooknum, s, in, out, okfn,\n\t\t\t       NF_IP6_PRI_CONNTRACK_DEFRAG + 1);\n\t\ts = s2;\n\t}\n\tnf_conntrack_put_reasm(skb);\n}\n\nint nf_ct_frag6_init(void)\n{\n\tnf_frags.hashfn = nf_hashfn;\n\tnf_frags.constructor = ip6_frag_init;\n\tnf_frags.destructor = NULL;\n\tnf_frags.skb_free = nf_skb_free;\n\tnf_frags.qsize = sizeof(struct nf_ct_frag6_queue);\n\tnf_frags.match = ip6_frag_match;\n\tnf_frags.frag_expire = nf_ct_frag6_expire;\n\tnf_frags.secret_interval = 10 * 60 * HZ;\n\tnf_init_frags.timeout = IPV6_FRAG_TIMEOUT;\n\tnf_init_frags.high_thresh = IPV6_FRAG_HIGH_THRESH;\n\tnf_init_frags.low_thresh = IPV6_FRAG_LOW_THRESH;\n\tinet_frags_init_net(&nf_init_frags);\n\tinet_frags_init(&nf_frags);\n\n\treturn 0;\n}\n\nvoid nf_ct_frag6_cleanup(void)\n{\n\tinet_frags_fini(&nf_frags);\n\n\tnf_init_frags.low_thresh = 0;\n\tnf_ct_frag6_evictor();\n}\n"], "buggy_code_start_loc": [472], "buggy_code_end_loc": [603], "fixing_code_start_loc": [472], "fixing_code_end_loc": [596], "type": "NVD-CWE-Other", "message": "net/ipv6/netfilter/nf_conntrack_reasm.c in the Linux kernel before 2.6.34, when the nf_conntrack_ipv6 module is enabled, allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via certain types of fragmented IPv6 packets.", "other": {"cve": {"id": "CVE-2012-2744", "sourceIdentifier": "secalert@redhat.com", "published": "2012-08-09T10:29:46.963", "lastModified": "2023-02-13T04:33:47.950", "vulnStatus": "Modified", "evaluatorComment": "Per: http://cwe.mitre.org/data/definitions/476.html\r\n\r\n'CWE-476: NULL Pointer Dereference'", "descriptions": [{"lang": "en", "value": "net/ipv6/netfilter/nf_conntrack_reasm.c in the Linux kernel before 2.6.34, when the nf_conntrack_ipv6 module is enabled, allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via certain types of fragmented IPv6 packets."}, {"lang": "es", "value": "net/ipv6/netfilter/nf_conntrack_reasm.c en el kernel de Linux anterior a v2.6.34, cuando el m\u00f3dulo nf_conntrack_ipv6 est\u00e1 habilitado, permite a atacantes remotos causar una denegaci\u00f3n de servicio (referencia de puntero a NULL y ca\u00edda del sistema) mediante ciertos tipos de paquetes IPv6 fragmentados."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.33.20", "matchCriteriaId": "B8187F7E-B31E-4C1C-8EB3-384193B7D7EE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33:*:*:*:*:*:*:*", "matchCriteriaId": "D81C2911-5781-46A4-AD27-F946BD44EAEC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.1:*:*:*:*:*:*:*", "matchCriteriaId": "17721A7D-E955-407B-AACB-97F859CE79C3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.2:*:*:*:*:*:*:*", "matchCriteriaId": "7B04F515-29A7-4D6A-AFC5-3A115F8A5918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.3:*:*:*:*:*:*:*", "matchCriteriaId": "7514928F-8992-4B8A-8AF4-E89F1CB6EFCE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.4:*:*:*:*:*:*:*", "matchCriteriaId": "BD6324B7-1329-4C6B-8DDB-D489250E07C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.5:*:*:*:*:*:*:*", "matchCriteriaId": "A7910FE5-E02C-4B20-9F27-F488E76BDE93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.6:*:*:*:*:*:*:*", "matchCriteriaId": "96F85BC2-54C4-4450-B3BA-A2A8EB78A81C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.7:*:*:*:*:*:*:*", "matchCriteriaId": "25E5B510-1096-42E8-8BD1-E9198D588050"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.8:*:*:*:*:*:*:*", "matchCriteriaId": "29787617-FFDD-4BDE-97EB-330675B99614"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.9:*:*:*:*:*:*:*", "matchCriteriaId": "7B28D3CE-E432-4F10-BF25-D03B0D89388A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.10:*:*:*:*:*:*:*", "matchCriteriaId": "E587FF24-AA5D-454B-8928-9C3CE03C419C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.11:*:*:*:*:*:*:*", "matchCriteriaId": "9DDBAAA5-240F-4DE5-BAA1-89508BD2CD8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.12:*:*:*:*:*:*:*", "matchCriteriaId": "F5D61706-2974-4C96-8196-9F3F56F1791F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.13:*:*:*:*:*:*:*", "matchCriteriaId": "46C5D7F1-152C-435F-8694-A66D0008289B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.14:*:*:*:*:*:*:*", "matchCriteriaId": "BEA2A352-7F4F-449D-AE23-24D39BFE0DB3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.15:*:*:*:*:*:*:*", "matchCriteriaId": "D9763287-12D3-485D-9DB4-0EBBEB2858C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.16:*:*:*:*:*:*:*", "matchCriteriaId": "9CDB80CE-2F1D-47EE-AE64-EA07B0AA3C20"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.17:*:*:*:*:*:*:*", "matchCriteriaId": "E70E77F5-12EF-4E12-8D34-9C56D23CAB22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.18:*:*:*:*:*:*:*", "matchCriteriaId": "B0139175-7049-4A2D-878E-EC43325DB5B4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.19:*:*:*:*:*:*:*", "matchCriteriaId": "18483901-EC47-45AD-A9EB-30591AA1247E"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.34", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=9e2dcf72023d1447f09c47d77c99b0c49659e5ce", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1064.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1148.html", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/54367", "source": "secalert@redhat.com"}, {"url": "http://www.securitytracker.com/id?1027235", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=833402", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/9e2dcf72023d1447f09c47d77c99b0c49659e5ce", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/9e2dcf72023d1447f09c47d77c99b0c49659e5ce"}}