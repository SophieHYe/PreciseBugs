{"buggy_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tImplementation of the Transmission Control Protocol(TCP).\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\t\tMark Evans, <evansmp@uhura.aston.ac.uk>\n *\t\tCorey Minyard <wf-rch!minyard@relay.EU.net>\n *\t\tFlorian La Roche, <flla@stud.uni-sb.de>\n *\t\tCharles Hedrick, <hedrick@klinzhai.rutgers.edu>\n *\t\tLinus Torvalds, <torvalds@cs.helsinki.fi>\n *\t\tAlan Cox, <gw4pts@gw4pts.ampr.org>\n *\t\tMatthew Dillon, <dillon@apollo.west.oic.com>\n *\t\tArnt Gulbrandsen, <agulbra@nvg.unit.no>\n *\t\tJorge Cwik, <jorge@laser.satlink.net>\n */\n\n/*\n * Changes:\n *\t\tPedro Roque\t:\tFast Retransmit/Recovery.\n *\t\t\t\t\tTwo receive queues.\n *\t\t\t\t\tRetransmit queue handled by TCP.\n *\t\t\t\t\tBetter retransmit timer handling.\n *\t\t\t\t\tNew congestion avoidance.\n *\t\t\t\t\tHeader prediction.\n *\t\t\t\t\tVariable renaming.\n *\n *\t\tEric\t\t:\tFast Retransmit.\n *\t\tRandy Scott\t:\tMSS option defines.\n *\t\tEric Schenk\t:\tFixes to slow start algorithm.\n *\t\tEric Schenk\t:\tYet another double ACK bug.\n *\t\tEric Schenk\t:\tDelayed ACK bug fixes.\n *\t\tEric Schenk\t:\tFloyd style fast retrans war avoidance.\n *\t\tDavid S. Miller\t:\tDon't allow zero congestion window.\n *\t\tEric Schenk\t:\tFix retransmitter so that it sends\n *\t\t\t\t\tnext packet on ack of previous packet.\n *\t\tAndi Kleen\t:\tMoved open_request checking here\n *\t\t\t\t\tand process RSTs for open_requests.\n *\t\tAndi Kleen\t:\tBetter prune_queue, and other fixes.\n *\t\tAndrey Savochkin:\tFix RTT measurements in the presence of\n *\t\t\t\t\ttimestamps.\n *\t\tAndrey Savochkin:\tCheck sequence numbers correctly when\n *\t\t\t\t\tremoving SACKs due to in sequence incoming\n *\t\t\t\t\tdata segments.\n *\t\tAndi Kleen:\t\tMake sure we never ack data there is not\n *\t\t\t\t\tenough room for. Also make this condition\n *\t\t\t\t\ta fatal error if it might still happen.\n *\t\tAndi Kleen:\t\tAdd tcp_measure_rcv_mss to make\n *\t\t\t\t\tconnections with MSS<min(MTU,ann. MSS)\n *\t\t\t\t\twork without delayed acks.\n *\t\tAndi Kleen:\t\tProcess packets with PSH set in the\n *\t\t\t\t\tfast path.\n *\t\tJ Hadi Salim:\t\tECN support\n *\t \tAndrei Gurtov,\n *\t\tPasi Sarolahti,\n *\t\tPanu Kuhlberg:\t\tExperimental audit of TCP (re)transmission\n *\t\t\t\t\tengine. Lots of bugs are found.\n *\t\tPasi Sarolahti:\t\tF-RTO for dealing with spurious RTOs\n */\n\n#define pr_fmt(fmt) \"TCP: \" fmt\n\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/sysctl.h>\n#include <linux/kernel.h>\n#include <linux/prefetch.h>\n#include <net/dst.h>\n#include <net/tcp.h>\n#include <net/inet_common.h>\n#include <linux/ipsec.h>\n#include <asm/unaligned.h>\n#include <linux/errqueue.h>\n\nint sysctl_tcp_timestamps __read_mostly = 1;\nint sysctl_tcp_window_scaling __read_mostly = 1;\nint sysctl_tcp_sack __read_mostly = 1;\nint sysctl_tcp_fack __read_mostly = 1;\nint sysctl_tcp_reordering __read_mostly = TCP_FASTRETRANS_THRESH;\nint sysctl_tcp_max_reordering __read_mostly = 300;\nEXPORT_SYMBOL(sysctl_tcp_reordering);\nint sysctl_tcp_dsack __read_mostly = 1;\nint sysctl_tcp_app_win __read_mostly = 31;\nint sysctl_tcp_adv_win_scale __read_mostly = 1;\nEXPORT_SYMBOL(sysctl_tcp_adv_win_scale);\n\n/* rfc5961 challenge ack rate limiting */\nint sysctl_tcp_challenge_ack_limit = 100;\n\nint sysctl_tcp_stdurg __read_mostly;\nint sysctl_tcp_rfc1337 __read_mostly;\nint sysctl_tcp_max_orphans __read_mostly = NR_FILE;\nint sysctl_tcp_frto __read_mostly = 2;\nint sysctl_tcp_min_rtt_wlen __read_mostly = 300;\n\nint sysctl_tcp_thin_dupack __read_mostly;\n\nint sysctl_tcp_moderate_rcvbuf __read_mostly = 1;\nint sysctl_tcp_early_retrans __read_mostly = 3;\nint sysctl_tcp_invalid_ratelimit __read_mostly = HZ/2;\n\n#define FLAG_DATA\t\t0x01 /* Incoming frame contained data.\t\t*/\n#define FLAG_WIN_UPDATE\t\t0x02 /* Incoming ACK was a window update.\t*/\n#define FLAG_DATA_ACKED\t\t0x04 /* This ACK acknowledged new data.\t\t*/\n#define FLAG_RETRANS_DATA_ACKED\t0x08 /* \"\" \"\" some of which was retransmitted.\t*/\n#define FLAG_SYN_ACKED\t\t0x10 /* This ACK acknowledged SYN.\t\t*/\n#define FLAG_DATA_SACKED\t0x20 /* New SACK.\t\t\t\t*/\n#define FLAG_ECE\t\t0x40 /* ECE in this ACK\t\t\t\t*/\n#define FLAG_LOST_RETRANS\t0x80 /* This ACK marks some retransmission lost */\n#define FLAG_SLOWPATH\t\t0x100 /* Do not skip RFC checks for window update.*/\n#define FLAG_ORIG_SACK_ACKED\t0x200 /* Never retransmitted data are (s)acked\t*/\n#define FLAG_SND_UNA_ADVANCED\t0x400 /* Snd_una was changed (!= FLAG_DATA_ACKED) */\n#define FLAG_DSACKING_ACK\t0x800 /* SACK blocks contained D-SACK info */\n#define FLAG_SACK_RENEGING\t0x2000 /* snd_una advanced to a sacked seq */\n#define FLAG_UPDATE_TS_RECENT\t0x4000 /* tcp_replace_ts_recent() */\n\n#define FLAG_ACKED\t\t(FLAG_DATA_ACKED|FLAG_SYN_ACKED)\n#define FLAG_NOT_DUP\t\t(FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)\n#define FLAG_CA_ALERT\t\t(FLAG_DATA_SACKED|FLAG_ECE)\n#define FLAG_FORWARD_PROGRESS\t(FLAG_ACKED|FLAG_DATA_SACKED)\n\n#define TCP_REMNANT (TCP_FLAG_FIN|TCP_FLAG_URG|TCP_FLAG_SYN|TCP_FLAG_PSH)\n#define TCP_HP_BITS (~(TCP_RESERVED_BITS|TCP_FLAG_PSH))\n\n/* Adapt the MSS value used to make delayed ack decision to the\n * real world.\n */\nstatic void tcp_measure_rcv_mss(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tconst unsigned int lss = icsk->icsk_ack.last_seg_size;\n\tunsigned int len;\n\n\ticsk->icsk_ack.last_seg_size = 0;\n\n\t/* skb->len may jitter because of SACKs, even if peer\n\t * sends good full-sized frames.\n\t */\n\tlen = skb_shinfo(skb)->gso_size ? : skb->len;\n\tif (len >= icsk->icsk_ack.rcv_mss) {\n\t\ticsk->icsk_ack.rcv_mss = len;\n\t} else {\n\t\t/* Otherwise, we make more careful check taking into account,\n\t\t * that SACKs block is variable.\n\t\t *\n\t\t * \"len\" is invariant segment length, including TCP header.\n\t\t */\n\t\tlen += skb->data - skb_transport_header(skb);\n\t\tif (len >= TCP_MSS_DEFAULT + sizeof(struct tcphdr) ||\n\t\t    /* If PSH is not set, packet should be\n\t\t     * full sized, provided peer TCP is not badly broken.\n\t\t     * This observation (if it is correct 8)) allows\n\t\t     * to handle super-low mtu links fairly.\n\t\t     */\n\t\t    (len >= TCP_MIN_MSS + sizeof(struct tcphdr) &&\n\t\t     !(tcp_flag_word(tcp_hdr(skb)) & TCP_REMNANT))) {\n\t\t\t/* Subtract also invariant (if peer is RFC compliant),\n\t\t\t * tcp header plus fixed timestamp option length.\n\t\t\t * Resulting \"len\" is MSS free of SACK jitter.\n\t\t\t */\n\t\t\tlen -= tcp_sk(sk)->tcp_header_len;\n\t\t\ticsk->icsk_ack.last_seg_size = len;\n\t\t\tif (len == lss) {\n\t\t\t\ticsk->icsk_ack.rcv_mss = len;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (icsk->icsk_ack.pending & ICSK_ACK_PUSHED)\n\t\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED2;\n\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED;\n\t}\n}\n\nstatic void tcp_incr_quickack(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tunsigned int quickacks = tcp_sk(sk)->rcv_wnd / (2 * icsk->icsk_ack.rcv_mss);\n\n\tif (quickacks == 0)\n\t\tquickacks = 2;\n\tif (quickacks > icsk->icsk_ack.quick)\n\t\ticsk->icsk_ack.quick = min(quickacks, TCP_MAX_QUICKACKS);\n}\n\nstatic void tcp_enter_quickack_mode(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\ttcp_incr_quickack(sk);\n\ticsk->icsk_ack.pingpong = 0;\n\ticsk->icsk_ack.ato = TCP_ATO_MIN;\n}\n\n/* Send ACKs quickly, if \"quick\" count is not exhausted\n * and the session is not interactive.\n */\n\nstatic bool tcp_in_quickack_mode(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\n\treturn (dst && dst_metric(dst, RTAX_QUICKACK)) ||\n\t\t(icsk->icsk_ack.quick && !icsk->icsk_ack.pingpong);\n}\n\nstatic void tcp_ecn_queue_cwr(struct tcp_sock *tp)\n{\n\tif (tp->ecn_flags & TCP_ECN_OK)\n\t\ttp->ecn_flags |= TCP_ECN_QUEUE_CWR;\n}\n\nstatic void tcp_ecn_accept_cwr(struct tcp_sock *tp, const struct sk_buff *skb)\n{\n\tif (tcp_hdr(skb)->cwr)\n\t\ttp->ecn_flags &= ~TCP_ECN_DEMAND_CWR;\n}\n\nstatic void tcp_ecn_withdraw_cwr(struct tcp_sock *tp)\n{\n\ttp->ecn_flags &= ~TCP_ECN_DEMAND_CWR;\n}\n\nstatic void __tcp_ecn_check_ce(struct tcp_sock *tp, const struct sk_buff *skb)\n{\n\tswitch (TCP_SKB_CB(skb)->ip_dsfield & INET_ECN_MASK) {\n\tcase INET_ECN_NOT_ECT:\n\t\t/* Funny extension: if ECT is not set on a segment,\n\t\t * and we already seen ECT on a previous segment,\n\t\t * it is probably a retransmit.\n\t\t */\n\t\tif (tp->ecn_flags & TCP_ECN_SEEN)\n\t\t\ttcp_enter_quickack_mode((struct sock *)tp);\n\t\tbreak;\n\tcase INET_ECN_CE:\n\t\tif (tcp_ca_needs_ecn((struct sock *)tp))\n\t\t\ttcp_ca_event((struct sock *)tp, CA_EVENT_ECN_IS_CE);\n\n\t\tif (!(tp->ecn_flags & TCP_ECN_DEMAND_CWR)) {\n\t\t\t/* Better not delay acks, sender can have a very low cwnd */\n\t\t\ttcp_enter_quickack_mode((struct sock *)tp);\n\t\t\ttp->ecn_flags |= TCP_ECN_DEMAND_CWR;\n\t\t}\n\t\ttp->ecn_flags |= TCP_ECN_SEEN;\n\t\tbreak;\n\tdefault:\n\t\tif (tcp_ca_needs_ecn((struct sock *)tp))\n\t\t\ttcp_ca_event((struct sock *)tp, CA_EVENT_ECN_NO_CE);\n\t\ttp->ecn_flags |= TCP_ECN_SEEN;\n\t\tbreak;\n\t}\n}\n\nstatic void tcp_ecn_check_ce(struct tcp_sock *tp, const struct sk_buff *skb)\n{\n\tif (tp->ecn_flags & TCP_ECN_OK)\n\t\t__tcp_ecn_check_ce(tp, skb);\n}\n\nstatic void tcp_ecn_rcv_synack(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tif ((tp->ecn_flags & TCP_ECN_OK) && (!th->ece || th->cwr))\n\t\ttp->ecn_flags &= ~TCP_ECN_OK;\n}\n\nstatic void tcp_ecn_rcv_syn(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tif ((tp->ecn_flags & TCP_ECN_OK) && (!th->ece || !th->cwr))\n\t\ttp->ecn_flags &= ~TCP_ECN_OK;\n}\n\nstatic bool tcp_ecn_rcv_ecn_echo(const struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tif (th->ece && !th->syn && (tp->ecn_flags & TCP_ECN_OK))\n\t\treturn true;\n\treturn false;\n}\n\n/* Buffer size and advertised window tuning.\n *\n * 1. Tuning sk->sk_sndbuf, when connection enters established state.\n */\n\nstatic void tcp_sndbuf_expand(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tint sndmem, per_mss;\n\tu32 nr_segs;\n\n\t/* Worst case is non GSO/TSO : each frame consumes one skb\n\t * and skb->head is kmalloced using power of two area of memory\n\t */\n\tper_mss = max_t(u32, tp->rx_opt.mss_clamp, tp->mss_cache) +\n\t\t  MAX_TCP_HEADER +\n\t\t  SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\tper_mss = roundup_pow_of_two(per_mss) +\n\t\t  SKB_DATA_ALIGN(sizeof(struct sk_buff));\n\n\tnr_segs = max_t(u32, TCP_INIT_CWND, tp->snd_cwnd);\n\tnr_segs = max_t(u32, nr_segs, tp->reordering + 1);\n\n\t/* Fast Recovery (RFC 5681 3.2) :\n\t * Cubic needs 1.7 factor, rounded to 2 to include\n\t * extra cushion (application might react slowly to POLLOUT)\n\t */\n\tsndmem = 2 * nr_segs * per_mss;\n\n\tif (sk->sk_sndbuf < sndmem)\n\t\tsk->sk_sndbuf = min(sndmem, sysctl_tcp_wmem[2]);\n}\n\n/* 2. Tuning advertised window (window_clamp, rcv_ssthresh)\n *\n * All tcp_full_space() is split to two parts: \"network\" buffer, allocated\n * forward and advertised in receiver window (tp->rcv_wnd) and\n * \"application buffer\", required to isolate scheduling/application\n * latencies from network.\n * window_clamp is maximal advertised window. It can be less than\n * tcp_full_space(), in this case tcp_full_space() - window_clamp\n * is reserved for \"application\" buffer. The less window_clamp is\n * the smoother our behaviour from viewpoint of network, but the lower\n * throughput and the higher sensitivity of the connection to losses. 8)\n *\n * rcv_ssthresh is more strict window_clamp used at \"slow start\"\n * phase to predict further behaviour of this connection.\n * It is used for two goals:\n * - to enforce header prediction at sender, even when application\n *   requires some significant \"application buffer\". It is check #1.\n * - to prevent pruning of receive queue because of misprediction\n *   of receiver window. Check #2.\n *\n * The scheme does not work when sender sends good segments opening\n * window and then starts to feed us spaghetti. But it should work\n * in common situations. Otherwise, we have to rely on queue collapsing.\n */\n\n/* Slow part of check#2. */\nstatic int __tcp_grow_window(const struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t/* Optimize this! */\n\tint truesize = tcp_win_from_space(skb->truesize) >> 1;\n\tint window = tcp_win_from_space(sysctl_tcp_rmem[2]) >> 1;\n\n\twhile (tp->rcv_ssthresh <= window) {\n\t\tif (truesize <= skb->len)\n\t\t\treturn 2 * inet_csk(sk)->icsk_ack.rcv_mss;\n\n\t\ttruesize >>= 1;\n\t\twindow >>= 1;\n\t}\n\treturn 0;\n}\n\nstatic void tcp_grow_window(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Check #1 */\n\tif (tp->rcv_ssthresh < tp->window_clamp &&\n\t    (int)tp->rcv_ssthresh < tcp_space(sk) &&\n\t    !tcp_under_memory_pressure(sk)) {\n\t\tint incr;\n\n\t\t/* Check #2. Increase window, if skb with such overhead\n\t\t * will fit to rcvbuf in future.\n\t\t */\n\t\tif (tcp_win_from_space(skb->truesize) <= skb->len)\n\t\t\tincr = 2 * tp->advmss;\n\t\telse\n\t\t\tincr = __tcp_grow_window(sk, skb);\n\n\t\tif (incr) {\n\t\t\tincr = max_t(int, incr, 2 * skb->len);\n\t\t\ttp->rcv_ssthresh = min(tp->rcv_ssthresh + incr,\n\t\t\t\t\t       tp->window_clamp);\n\t\t\tinet_csk(sk)->icsk_ack.quick |= 1;\n\t\t}\n\t}\n}\n\n/* 3. Tuning rcvbuf, when connection enters established state. */\nstatic void tcp_fixup_rcvbuf(struct sock *sk)\n{\n\tu32 mss = tcp_sk(sk)->advmss;\n\tint rcvmem;\n\n\trcvmem = 2 * SKB_TRUESIZE(mss + MAX_TCP_HEADER) *\n\t\t tcp_default_init_rwnd(mss);\n\n\t/* Dynamic Right Sizing (DRS) has 2 to 3 RTT latency\n\t * Allow enough cushion so that sender is not limited by our window\n\t */\n\tif (sysctl_tcp_moderate_rcvbuf)\n\t\trcvmem <<= 2;\n\n\tif (sk->sk_rcvbuf < rcvmem)\n\t\tsk->sk_rcvbuf = min(rcvmem, sysctl_tcp_rmem[2]);\n}\n\n/* 4. Try to fixup all. It is made immediately after connection enters\n *    established state.\n */\nvoid tcp_init_buffer_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint maxwin;\n\n\tif (!(sk->sk_userlocks & SOCK_RCVBUF_LOCK))\n\t\ttcp_fixup_rcvbuf(sk);\n\tif (!(sk->sk_userlocks & SOCK_SNDBUF_LOCK))\n\t\ttcp_sndbuf_expand(sk);\n\n\ttp->rcvq_space.space = tp->rcv_wnd;\n\ttp->rcvq_space.time = tcp_time_stamp;\n\ttp->rcvq_space.seq = tp->copied_seq;\n\n\tmaxwin = tcp_full_space(sk);\n\n\tif (tp->window_clamp >= maxwin) {\n\t\ttp->window_clamp = maxwin;\n\n\t\tif (sysctl_tcp_app_win && maxwin > 4 * tp->advmss)\n\t\t\ttp->window_clamp = max(maxwin -\n\t\t\t\t\t       (maxwin >> sysctl_tcp_app_win),\n\t\t\t\t\t       4 * tp->advmss);\n\t}\n\n\t/* Force reservation of one segment. */\n\tif (sysctl_tcp_app_win &&\n\t    tp->window_clamp > 2 * tp->advmss &&\n\t    tp->window_clamp + tp->advmss > maxwin)\n\t\ttp->window_clamp = max(2 * tp->advmss, maxwin - tp->advmss);\n\n\ttp->rcv_ssthresh = min(tp->rcv_ssthresh, tp->window_clamp);\n\ttp->snd_cwnd_stamp = tcp_time_stamp;\n}\n\n/* 5. Recalculate window clamp after socket hit its memory bounds. */\nstatic void tcp_clamp_window(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ticsk->icsk_ack.quick = 0;\n\n\tif (sk->sk_rcvbuf < sysctl_tcp_rmem[2] &&\n\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK) &&\n\t    !tcp_under_memory_pressure(sk) &&\n\t    sk_memory_allocated(sk) < sk_prot_mem_limits(sk, 0)) {\n\t\tsk->sk_rcvbuf = min(atomic_read(&sk->sk_rmem_alloc),\n\t\t\t\t    sysctl_tcp_rmem[2]);\n\t}\n\tif (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)\n\t\ttp->rcv_ssthresh = min(tp->window_clamp, 2U * tp->advmss);\n}\n\n/* Initialize RCV_MSS value.\n * RCV_MSS is an our guess about MSS used by the peer.\n * We haven't any direct information about the MSS.\n * It's better to underestimate the RCV_MSS rather than overestimate.\n * Overestimations make us ACKing less frequently than needed.\n * Underestimations are more easy to detect and fix by tcp_measure_rcv_mss().\n */\nvoid tcp_initialize_rcv_mss(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tunsigned int hint = min_t(unsigned int, tp->advmss, tp->mss_cache);\n\n\thint = min(hint, tp->rcv_wnd / 2);\n\thint = min(hint, TCP_MSS_DEFAULT);\n\thint = max(hint, TCP_MIN_MSS);\n\n\tinet_csk(sk)->icsk_ack.rcv_mss = hint;\n}\nEXPORT_SYMBOL(tcp_initialize_rcv_mss);\n\n/* Receiver \"autotuning\" code.\n *\n * The algorithm for RTT estimation w/o timestamps is based on\n * Dynamic Right-Sizing (DRS) by Wu Feng and Mike Fisk of LANL.\n * <http://public.lanl.gov/radiant/pubs.html#DRS>\n *\n * More detail on this code can be found at\n * <http://staff.psc.edu/jheffner/>,\n * though this reference is out of date.  A new paper\n * is pending.\n */\nstatic void tcp_rcv_rtt_update(struct tcp_sock *tp, u32 sample, int win_dep)\n{\n\tu32 new_sample = tp->rcv_rtt_est.rtt;\n\tlong m = sample;\n\n\tif (m == 0)\n\t\tm = 1;\n\n\tif (new_sample != 0) {\n\t\t/* If we sample in larger samples in the non-timestamp\n\t\t * case, we could grossly overestimate the RTT especially\n\t\t * with chatty applications or bulk transfer apps which\n\t\t * are stalled on filesystem I/O.\n\t\t *\n\t\t * Also, since we are only going for a minimum in the\n\t\t * non-timestamp case, we do not smooth things out\n\t\t * else with timestamps disabled convergence takes too\n\t\t * long.\n\t\t */\n\t\tif (!win_dep) {\n\t\t\tm -= (new_sample >> 3);\n\t\t\tnew_sample += m;\n\t\t} else {\n\t\t\tm <<= 3;\n\t\t\tif (m < new_sample)\n\t\t\t\tnew_sample = m;\n\t\t}\n\t} else {\n\t\t/* No previous measure. */\n\t\tnew_sample = m << 3;\n\t}\n\n\tif (tp->rcv_rtt_est.rtt != new_sample)\n\t\ttp->rcv_rtt_est.rtt = new_sample;\n}\n\nstatic inline void tcp_rcv_rtt_measure(struct tcp_sock *tp)\n{\n\tif (tp->rcv_rtt_est.time == 0)\n\t\tgoto new_measure;\n\tif (before(tp->rcv_nxt, tp->rcv_rtt_est.seq))\n\t\treturn;\n\ttcp_rcv_rtt_update(tp, tcp_time_stamp - tp->rcv_rtt_est.time, 1);\n\nnew_measure:\n\ttp->rcv_rtt_est.seq = tp->rcv_nxt + tp->rcv_wnd;\n\ttp->rcv_rtt_est.time = tcp_time_stamp;\n}\n\nstatic inline void tcp_rcv_rtt_measure_ts(struct sock *sk,\n\t\t\t\t\t  const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (tp->rx_opt.rcv_tsecr &&\n\t    (TCP_SKB_CB(skb)->end_seq -\n\t     TCP_SKB_CB(skb)->seq >= inet_csk(sk)->icsk_ack.rcv_mss))\n\t\ttcp_rcv_rtt_update(tp, tcp_time_stamp - tp->rx_opt.rcv_tsecr, 0);\n}\n\n/*\n * This function should be called every time data is copied to user space.\n * It calculates the appropriate TCP receive buffer space.\n */\nvoid tcp_rcv_space_adjust(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint time;\n\tint copied;\n\n\ttime = tcp_time_stamp - tp->rcvq_space.time;\n\tif (time < (tp->rcv_rtt_est.rtt >> 3) || tp->rcv_rtt_est.rtt == 0)\n\t\treturn;\n\n\t/* Number of bytes copied to user in last RTT */\n\tcopied = tp->copied_seq - tp->rcvq_space.seq;\n\tif (copied <= tp->rcvq_space.space)\n\t\tgoto new_measure;\n\n\t/* A bit of theory :\n\t * copied = bytes received in previous RTT, our base window\n\t * To cope with packet losses, we need a 2x factor\n\t * To cope with slow start, and sender growing its cwin by 100 %\n\t * every RTT, we need a 4x factor, because the ACK we are sending\n\t * now is for the next RTT, not the current one :\n\t * <prev RTT . ><current RTT .. ><next RTT .... >\n\t */\n\n\tif (sysctl_tcp_moderate_rcvbuf &&\n\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\tint rcvwin, rcvmem, rcvbuf;\n\n\t\t/* minimal window to cope with packet losses, assuming\n\t\t * steady state. Add some cushion because of small variations.\n\t\t */\n\t\trcvwin = (copied << 1) + 16 * tp->advmss;\n\n\t\t/* If rate increased by 25%,\n\t\t *\tassume slow start, rcvwin = 3 * copied\n\t\t * If rate increased by 50%,\n\t\t *\tassume sender can use 2x growth, rcvwin = 4 * copied\n\t\t */\n\t\tif (copied >=\n\t\t    tp->rcvq_space.space + (tp->rcvq_space.space >> 2)) {\n\t\t\tif (copied >=\n\t\t\t    tp->rcvq_space.space + (tp->rcvq_space.space >> 1))\n\t\t\t\trcvwin <<= 1;\n\t\t\telse\n\t\t\t\trcvwin += (rcvwin >> 1);\n\t\t}\n\n\t\trcvmem = SKB_TRUESIZE(tp->advmss + MAX_TCP_HEADER);\n\t\twhile (tcp_win_from_space(rcvmem) < tp->advmss)\n\t\t\trcvmem += 128;\n\n\t\trcvbuf = min(rcvwin / tp->advmss * rcvmem, sysctl_tcp_rmem[2]);\n\t\tif (rcvbuf > sk->sk_rcvbuf) {\n\t\t\tsk->sk_rcvbuf = rcvbuf;\n\n\t\t\t/* Make the window clamp follow along.  */\n\t\t\ttp->window_clamp = rcvwin;\n\t\t}\n\t}\n\ttp->rcvq_space.space = copied;\n\nnew_measure:\n\ttp->rcvq_space.seq = tp->copied_seq;\n\ttp->rcvq_space.time = tcp_time_stamp;\n}\n\n/* There is something which you must keep in mind when you analyze the\n * behavior of the tp->ato delayed ack timeout interval.  When a\n * connection starts up, we want to ack as quickly as possible.  The\n * problem is that \"good\" TCP's do slow start at the beginning of data\n * transmission.  The means that until we send the first few ACK's the\n * sender will sit on his end and only queue most of his data, because\n * he can only send snd_cwnd unacked packets at any given time.  For\n * each ACK we send, he increments snd_cwnd and transmits more of his\n * queue.  -DaveM\n */\nstatic void tcp_event_data_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tu32 now;\n\n\tinet_csk_schedule_ack(sk);\n\n\ttcp_measure_rcv_mss(sk, skb);\n\n\ttcp_rcv_rtt_measure(tp);\n\n\tnow = tcp_time_stamp;\n\n\tif (!icsk->icsk_ack.ato) {\n\t\t/* The _first_ data packet received, initialize\n\t\t * delayed ACK engine.\n\t\t */\n\t\ttcp_incr_quickack(sk);\n\t\ticsk->icsk_ack.ato = TCP_ATO_MIN;\n\t} else {\n\t\tint m = now - icsk->icsk_ack.lrcvtime;\n\n\t\tif (m <= TCP_ATO_MIN / 2) {\n\t\t\t/* The fastest case is the first. */\n\t\t\ticsk->icsk_ack.ato = (icsk->icsk_ack.ato >> 1) + TCP_ATO_MIN / 2;\n\t\t} else if (m < icsk->icsk_ack.ato) {\n\t\t\ticsk->icsk_ack.ato = (icsk->icsk_ack.ato >> 1) + m;\n\t\t\tif (icsk->icsk_ack.ato > icsk->icsk_rto)\n\t\t\t\ticsk->icsk_ack.ato = icsk->icsk_rto;\n\t\t} else if (m > icsk->icsk_rto) {\n\t\t\t/* Too long gap. Apparently sender failed to\n\t\t\t * restart window, so that we send ACKs quickly.\n\t\t\t */\n\t\t\ttcp_incr_quickack(sk);\n\t\t\tsk_mem_reclaim(sk);\n\t\t}\n\t}\n\ticsk->icsk_ack.lrcvtime = now;\n\n\ttcp_ecn_check_ce(tp, skb);\n\n\tif (skb->len >= 128)\n\t\ttcp_grow_window(sk, skb);\n}\n\n/* Called to compute a smoothed rtt estimate. The data fed to this\n * routine either comes from timestamps, or from segments that were\n * known _not_ to have been retransmitted [see Karn/Partridge\n * Proceedings SIGCOMM 87]. The algorithm is from the SIGCOMM 88\n * piece by Van Jacobson.\n * NOTE: the next three routines used to be one big routine.\n * To save cycles in the RFC 1323 implementation it was better to break\n * it up into three procedures. -- erics\n */\nstatic void tcp_rtt_estimator(struct sock *sk, long mrtt_us)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tlong m = mrtt_us; /* RTT */\n\tu32 srtt = tp->srtt_us;\n\n\t/*\tThe following amusing code comes from Jacobson's\n\t *\tarticle in SIGCOMM '88.  Note that rtt and mdev\n\t *\tare scaled versions of rtt and mean deviation.\n\t *\tThis is designed to be as fast as possible\n\t *\tm stands for \"measurement\".\n\t *\n\t *\tOn a 1990 paper the rto value is changed to:\n\t *\tRTO = rtt + 4 * mdev\n\t *\n\t * Funny. This algorithm seems to be very broken.\n\t * These formulae increase RTO, when it should be decreased, increase\n\t * too slowly, when it should be increased quickly, decrease too quickly\n\t * etc. I guess in BSD RTO takes ONE value, so that it is absolutely\n\t * does not matter how to _calculate_ it. Seems, it was trap\n\t * that VJ failed to avoid. 8)\n\t */\n\tif (srtt != 0) {\n\t\tm -= (srtt >> 3);\t/* m is now error in rtt est */\n\t\tsrtt += m;\t\t/* rtt = 7/8 rtt + 1/8 new */\n\t\tif (m < 0) {\n\t\t\tm = -m;\t\t/* m is now abs(error) */\n\t\t\tm -= (tp->mdev_us >> 2);   /* similar update on mdev */\n\t\t\t/* This is similar to one of Eifel findings.\n\t\t\t * Eifel blocks mdev updates when rtt decreases.\n\t\t\t * This solution is a bit different: we use finer gain\n\t\t\t * for mdev in this case (alpha*beta).\n\t\t\t * Like Eifel it also prevents growth of rto,\n\t\t\t * but also it limits too fast rto decreases,\n\t\t\t * happening in pure Eifel.\n\t\t\t */\n\t\t\tif (m > 0)\n\t\t\t\tm >>= 3;\n\t\t} else {\n\t\t\tm -= (tp->mdev_us >> 2);   /* similar update on mdev */\n\t\t}\n\t\ttp->mdev_us += m;\t\t/* mdev = 3/4 mdev + 1/4 new */\n\t\tif (tp->mdev_us > tp->mdev_max_us) {\n\t\t\ttp->mdev_max_us = tp->mdev_us;\n\t\t\tif (tp->mdev_max_us > tp->rttvar_us)\n\t\t\t\ttp->rttvar_us = tp->mdev_max_us;\n\t\t}\n\t\tif (after(tp->snd_una, tp->rtt_seq)) {\n\t\t\tif (tp->mdev_max_us < tp->rttvar_us)\n\t\t\t\ttp->rttvar_us -= (tp->rttvar_us - tp->mdev_max_us) >> 2;\n\t\t\ttp->rtt_seq = tp->snd_nxt;\n\t\t\ttp->mdev_max_us = tcp_rto_min_us(sk);\n\t\t}\n\t} else {\n\t\t/* no previous measure. */\n\t\tsrtt = m << 3;\t\t/* take the measured time to be rtt */\n\t\ttp->mdev_us = m << 1;\t/* make sure rto = 3*rtt */\n\t\ttp->rttvar_us = max(tp->mdev_us, tcp_rto_min_us(sk));\n\t\ttp->mdev_max_us = tp->rttvar_us;\n\t\ttp->rtt_seq = tp->snd_nxt;\n\t}\n\ttp->srtt_us = max(1U, srtt);\n}\n\n/* Set the sk_pacing_rate to allow proper sizing of TSO packets.\n * Note: TCP stack does not yet implement pacing.\n * FQ packet scheduler can be used to implement cheap but effective\n * TCP pacing, to smooth the burst on large writes when packets\n * in flight is significantly lower than cwnd (or rwin)\n */\nint sysctl_tcp_pacing_ss_ratio __read_mostly = 200;\nint sysctl_tcp_pacing_ca_ratio __read_mostly = 120;\n\nstatic void tcp_update_pacing_rate(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tu64 rate;\n\n\t/* set sk_pacing_rate to 200 % of current rate (mss * cwnd / srtt) */\n\trate = (u64)tp->mss_cache * ((USEC_PER_SEC / 100) << 3);\n\n\t/* current rate is (cwnd * mss) / srtt\n\t * In Slow Start [1], set sk_pacing_rate to 200 % the current rate.\n\t * In Congestion Avoidance phase, set it to 120 % the current rate.\n\t *\n\t * [1] : Normal Slow Start condition is (tp->snd_cwnd < tp->snd_ssthresh)\n\t *\t If snd_cwnd >= (tp->snd_ssthresh / 2), we are approaching\n\t *\t end of slow start and should slow down.\n\t */\n\tif (tp->snd_cwnd < tp->snd_ssthresh / 2)\n\t\trate *= sysctl_tcp_pacing_ss_ratio;\n\telse\n\t\trate *= sysctl_tcp_pacing_ca_ratio;\n\n\trate *= max(tp->snd_cwnd, tp->packets_out);\n\n\tif (likely(tp->srtt_us))\n\t\tdo_div(rate, tp->srtt_us);\n\n\t/* ACCESS_ONCE() is needed because sch_fq fetches sk_pacing_rate\n\t * without any lock. We want to make sure compiler wont store\n\t * intermediate values in this location.\n\t */\n\tACCESS_ONCE(sk->sk_pacing_rate) = min_t(u64, rate,\n\t\t\t\t\t\tsk->sk_max_pacing_rate);\n}\n\n/* Calculate rto without backoff.  This is the second half of Van Jacobson's\n * routine referred to above.\n */\nstatic void tcp_set_rto(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\t/* Old crap is replaced with new one. 8)\n\t *\n\t * More seriously:\n\t * 1. If rtt variance happened to be less 50msec, it is hallucination.\n\t *    It cannot be less due to utterly erratic ACK generation made\n\t *    at least by solaris and freebsd. \"Erratic ACKs\" has _nothing_\n\t *    to do with delayed acks, because at cwnd>2 true delack timeout\n\t *    is invisible. Actually, Linux-2.4 also generates erratic\n\t *    ACKs in some circumstances.\n\t */\n\tinet_csk(sk)->icsk_rto = __tcp_set_rto(tp);\n\n\t/* 2. Fixups made earlier cannot be right.\n\t *    If we do not estimate RTO correctly without them,\n\t *    all the algo is pure shit and should be replaced\n\t *    with correct one. It is exactly, which we pretend to do.\n\t */\n\n\t/* NOTE: clamping at TCP_RTO_MIN is not required, current algo\n\t * guarantees that rto is higher.\n\t */\n\ttcp_bound_rto(sk);\n}\n\n__u32 tcp_init_cwnd(const struct tcp_sock *tp, const struct dst_entry *dst)\n{\n\t__u32 cwnd = (dst ? dst_metric(dst, RTAX_INITCWND) : 0);\n\n\tif (!cwnd)\n\t\tcwnd = TCP_INIT_CWND;\n\treturn min_t(__u32, cwnd, tp->snd_cwnd_clamp);\n}\n\n/*\n * Packet counting of FACK is based on in-order assumptions, therefore TCP\n * disables it when reordering is detected\n */\nvoid tcp_disable_fack(struct tcp_sock *tp)\n{\n\t/* RFC3517 uses different metric in lost marker => reset on change */\n\tif (tcp_is_fack(tp))\n\t\ttp->lost_skb_hint = NULL;\n\ttp->rx_opt.sack_ok &= ~TCP_FACK_ENABLED;\n}\n\n/* Take a notice that peer is sending D-SACKs */\nstatic void tcp_dsack_seen(struct tcp_sock *tp)\n{\n\ttp->rx_opt.sack_ok |= TCP_DSACK_SEEN;\n}\n\nstatic void tcp_update_reordering(struct sock *sk, const int metric,\n\t\t\t\t  const int ts)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (metric > tp->reordering) {\n\t\tint mib_idx;\n\n\t\ttp->reordering = min(sysctl_tcp_max_reordering, metric);\n\n\t\t/* This exciting event is worth to be remembered. 8) */\n\t\tif (ts)\n\t\t\tmib_idx = LINUX_MIB_TCPTSREORDER;\n\t\telse if (tcp_is_reno(tp))\n\t\t\tmib_idx = LINUX_MIB_TCPRENOREORDER;\n\t\telse if (tcp_is_fack(tp))\n\t\t\tmib_idx = LINUX_MIB_TCPFACKREORDER;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPSACKREORDER;\n\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n#if FASTRETRANS_DEBUG > 1\n\t\tpr_debug(\"Disorder%d %d %u f%u s%u rr%d\\n\",\n\t\t\t tp->rx_opt.sack_ok, inet_csk(sk)->icsk_ca_state,\n\t\t\t tp->reordering,\n\t\t\t tp->fackets_out,\n\t\t\t tp->sacked_out,\n\t\t\t tp->undo_marker ? tp->undo_retrans : 0);\n#endif\n\t\ttcp_disable_fack(tp);\n\t}\n\n\tif (metric > 0)\n\t\ttcp_disable_early_retrans(tp);\n\ttp->rack.reord = 1;\n}\n\n/* This must be called before lost_out is incremented */\nstatic void tcp_verify_retransmit_hint(struct tcp_sock *tp, struct sk_buff *skb)\n{\n\tif (!tp->retransmit_skb_hint ||\n\t    before(TCP_SKB_CB(skb)->seq,\n\t\t   TCP_SKB_CB(tp->retransmit_skb_hint)->seq))\n\t\ttp->retransmit_skb_hint = skb;\n\n\tif (!tp->lost_out ||\n\t    after(TCP_SKB_CB(skb)->end_seq, tp->retransmit_high))\n\t\ttp->retransmit_high = TCP_SKB_CB(skb)->end_seq;\n}\n\nstatic void tcp_skb_mark_lost(struct tcp_sock *tp, struct sk_buff *skb)\n{\n\tif (!(TCP_SKB_CB(skb)->sacked & (TCPCB_LOST|TCPCB_SACKED_ACKED))) {\n\t\ttcp_verify_retransmit_hint(tp, skb);\n\n\t\ttp->lost_out += tcp_skb_pcount(skb);\n\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_LOST;\n\t}\n}\n\nvoid tcp_skb_mark_lost_uncond_verify(struct tcp_sock *tp, struct sk_buff *skb)\n{\n\ttcp_verify_retransmit_hint(tp, skb);\n\n\tif (!(TCP_SKB_CB(skb)->sacked & (TCPCB_LOST|TCPCB_SACKED_ACKED))) {\n\t\ttp->lost_out += tcp_skb_pcount(skb);\n\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_LOST;\n\t}\n}\n\n/* This procedure tags the retransmission queue when SACKs arrive.\n *\n * We have three tag bits: SACKED(S), RETRANS(R) and LOST(L).\n * Packets in queue with these bits set are counted in variables\n * sacked_out, retrans_out and lost_out, correspondingly.\n *\n * Valid combinations are:\n * Tag  InFlight\tDescription\n * 0\t1\t\t- orig segment is in flight.\n * S\t0\t\t- nothing flies, orig reached receiver.\n * L\t0\t\t- nothing flies, orig lost by net.\n * R\t2\t\t- both orig and retransmit are in flight.\n * L|R\t1\t\t- orig is lost, retransmit is in flight.\n * S|R  1\t\t- orig reached receiver, retrans is still in flight.\n * (L|S|R is logically valid, it could occur when L|R is sacked,\n *  but it is equivalent to plain S and code short-curcuits it to S.\n *  L|S is logically invalid, it would mean -1 packet in flight 8))\n *\n * These 6 states form finite state machine, controlled by the following events:\n * 1. New ACK (+SACK) arrives. (tcp_sacktag_write_queue())\n * 2. Retransmission. (tcp_retransmit_skb(), tcp_xmit_retransmit_queue())\n * 3. Loss detection event of two flavors:\n *\tA. Scoreboard estimator decided the packet is lost.\n *\t   A'. Reno \"three dupacks\" marks head of queue lost.\n *\t   A''. Its FACK modification, head until snd.fack is lost.\n *\tB. SACK arrives sacking SND.NXT at the moment, when the\n *\t   segment was retransmitted.\n * 4. D-SACK added new rule: D-SACK changes any tag to S.\n *\n * It is pleasant to note, that state diagram turns out to be commutative,\n * so that we are allowed not to be bothered by order of our actions,\n * when multiple events arrive simultaneously. (see the function below).\n *\n * Reordering detection.\n * --------------------\n * Reordering metric is maximal distance, which a packet can be displaced\n * in packet stream. With SACKs we can estimate it:\n *\n * 1. SACK fills old hole and the corresponding segment was not\n *    ever retransmitted -> reordering. Alas, we cannot use it\n *    when segment was retransmitted.\n * 2. The last flaw is solved with D-SACK. D-SACK arrives\n *    for retransmitted and already SACKed segment -> reordering..\n * Both of these heuristics are not used in Loss state, when we cannot\n * account for retransmits accurately.\n *\n * SACK block validation.\n * ----------------------\n *\n * SACK block range validation checks that the received SACK block fits to\n * the expected sequence limits, i.e., it is between SND.UNA and SND.NXT.\n * Note that SND.UNA is not included to the range though being valid because\n * it means that the receiver is rather inconsistent with itself reporting\n * SACK reneging when it should advance SND.UNA. Such SACK block this is\n * perfectly valid, however, in light of RFC2018 which explicitly states\n * that \"SACK block MUST reflect the newest segment.  Even if the newest\n * segment is going to be discarded ...\", not that it looks very clever\n * in case of head skb. Due to potentional receiver driven attacks, we\n * choose to avoid immediate execution of a walk in write queue due to\n * reneging and defer head skb's loss recovery to standard loss recovery\n * procedure that will eventually trigger (nothing forbids us doing this).\n *\n * Implements also blockage to start_seq wrap-around. Problem lies in the\n * fact that though start_seq (s) is before end_seq (i.e., not reversed),\n * there's no guarantee that it will be before snd_nxt (n). The problem\n * happens when start_seq resides between end_seq wrap (e_w) and snd_nxt\n * wrap (s_w):\n *\n *         <- outs wnd ->                          <- wrapzone ->\n *         u     e      n                         u_w   e_w  s n_w\n *         |     |      |                          |     |   |  |\n * |<------------+------+----- TCP seqno space --------------+---------->|\n * ...-- <2^31 ->|                                           |<--------...\n * ...---- >2^31 ------>|                                    |<--------...\n *\n * Current code wouldn't be vulnerable but it's better still to discard such\n * crazy SACK blocks. Doing this check for start_seq alone closes somewhat\n * similar case (end_seq after snd_nxt wrap) as earlier reversed check in\n * snd_nxt wrap -> snd_una region will then become \"well defined\", i.e.,\n * equal to the ideal case (infinite seqno space without wrap caused issues).\n *\n * With D-SACK the lower bound is extended to cover sequence space below\n * SND.UNA down to undo_marker, which is the last point of interest. Yet\n * again, D-SACK block must not to go across snd_una (for the same reason as\n * for the normal SACK blocks, explained above). But there all simplicity\n * ends, TCP might receive valid D-SACKs below that. As long as they reside\n * fully below undo_marker they do not affect behavior in anyway and can\n * therefore be safely ignored. In rare cases (which are more or less\n * theoretical ones), the D-SACK will nicely cross that boundary due to skb\n * fragmentation and packet reordering past skb's retransmission. To consider\n * them correctly, the acceptable range must be extended even more though\n * the exact amount is rather hard to quantify. However, tp->max_window can\n * be used as an exaggerated estimate.\n */\nstatic bool tcp_is_sackblock_valid(struct tcp_sock *tp, bool is_dsack,\n\t\t\t\t   u32 start_seq, u32 end_seq)\n{\n\t/* Too far in future, or reversed (interpretation is ambiguous) */\n\tif (after(end_seq, tp->snd_nxt) || !before(start_seq, end_seq))\n\t\treturn false;\n\n\t/* Nasty start_seq wrap-around check (see comments above) */\n\tif (!before(start_seq, tp->snd_nxt))\n\t\treturn false;\n\n\t/* In outstanding window? ...This is valid exit for D-SACKs too.\n\t * start_seq == snd_una is non-sensical (see comments above)\n\t */\n\tif (after(start_seq, tp->snd_una))\n\t\treturn true;\n\n\tif (!is_dsack || !tp->undo_marker)\n\t\treturn false;\n\n\t/* ...Then it's D-SACK, and must reside below snd_una completely */\n\tif (after(end_seq, tp->snd_una))\n\t\treturn false;\n\n\tif (!before(start_seq, tp->undo_marker))\n\t\treturn true;\n\n\t/* Too old */\n\tif (!after(end_seq, tp->undo_marker))\n\t\treturn false;\n\n\t/* Undo_marker boundary crossing (overestimates a lot). Known already:\n\t *   start_seq < undo_marker and end_seq >= undo_marker.\n\t */\n\treturn !before(start_seq, end_seq - tp->max_window);\n}\n\nstatic bool tcp_check_dsack(struct sock *sk, const struct sk_buff *ack_skb,\n\t\t\t    struct tcp_sack_block_wire *sp, int num_sacks,\n\t\t\t    u32 prior_snd_una)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 start_seq_0 = get_unaligned_be32(&sp[0].start_seq);\n\tu32 end_seq_0 = get_unaligned_be32(&sp[0].end_seq);\n\tbool dup_sack = false;\n\n\tif (before(start_seq_0, TCP_SKB_CB(ack_skb)->ack_seq)) {\n\t\tdup_sack = true;\n\t\ttcp_dsack_seen(tp);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKRECV);\n\t} else if (num_sacks > 1) {\n\t\tu32 end_seq_1 = get_unaligned_be32(&sp[1].end_seq);\n\t\tu32 start_seq_1 = get_unaligned_be32(&sp[1].start_seq);\n\n\t\tif (!after(end_seq_0, end_seq_1) &&\n\t\t    !before(start_seq_0, start_seq_1)) {\n\t\t\tdup_sack = true;\n\t\t\ttcp_dsack_seen(tp);\n\t\t\tNET_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\tLINUX_MIB_TCPDSACKOFORECV);\n\t\t}\n\t}\n\n\t/* D-SACK for already forgotten data... Do dumb counting. */\n\tif (dup_sack && tp->undo_marker && tp->undo_retrans > 0 &&\n\t    !after(end_seq_0, prior_snd_una) &&\n\t    after(end_seq_0, tp->undo_marker))\n\t\ttp->undo_retrans--;\n\n\treturn dup_sack;\n}\n\nstruct tcp_sacktag_state {\n\tint\treord;\n\tint\tfack_count;\n\t/* Timestamps for earliest and latest never-retransmitted segment\n\t * that was SACKed. RTO needs the earliest RTT to stay conservative,\n\t * but congestion control should still get an accurate delay signal.\n\t */\n\tstruct skb_mstamp first_sackt;\n\tstruct skb_mstamp last_sackt;\n\tint\tflag;\n};\n\n/* Check if skb is fully within the SACK block. In presence of GSO skbs,\n * the incoming SACK may not exactly match but we can find smaller MSS\n * aligned portion of it that matches. Therefore we might need to fragment\n * which may fail and creates some hassle (caller must handle error case\n * returns).\n *\n * FIXME: this could be merged to shift decision code\n */\nstatic int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  u32 start_seq, u32 end_seq)\n{\n\tint err;\n\tbool in_sack;\n\tunsigned int pkt_len;\n\tunsigned int mss;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (tcp_skb_pcount(skb) > 1 && !in_sack &&\n\t    after(TCP_SKB_CB(skb)->end_seq, start_seq)) {\n\t\tmss = tcp_skb_mss(skb);\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\n\t\tif (!in_sack) {\n\t\t\tpkt_len = start_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\tpkt_len = mss;\n\t\t} else {\n\t\t\tpkt_len = end_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Round if necessary so that SACKs cover only full MSSes\n\t\t * and/or the remaining small portion (if present)\n\t\t */\n\t\tif (pkt_len > mss) {\n\t\t\tunsigned int new_len = (pkt_len / mss) * mss;\n\t\t\tif (!in_sack && new_len < pkt_len) {\n\t\t\t\tnew_len += mss;\n\t\t\t\tif (new_len >= skb->len)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpkt_len = new_len;\n\t\t}\n\t\terr = tcp_fragment(sk, skb, pkt_len, mss, GFP_ATOMIC);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn in_sack;\n}\n\n/* Mark the given newly-SACKed range as such, adjusting counters and hints. */\nstatic u8 tcp_sacktag_one(struct sock *sk,\n\t\t\t  struct tcp_sacktag_state *state, u8 sacked,\n\t\t\t  u32 start_seq, u32 end_seq,\n\t\t\t  int dup_sack, int pcount,\n\t\t\t  const struct skb_mstamp *xmit_time)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint fack_count = state->fack_count;\n\n\t/* Account D-SACK for retransmitted packet. */\n\tif (dup_sack && (sacked & TCPCB_RETRANS)) {\n\t\tif (tp->undo_marker && tp->undo_retrans > 0 &&\n\t\t    after(end_seq, tp->undo_marker))\n\t\t\ttp->undo_retrans--;\n\t\tif (sacked & TCPCB_SACKED_ACKED)\n\t\t\tstate->reord = min(fack_count, state->reord);\n\t}\n\n\t/* Nothing to do; acked frame is about to be dropped (was ACKed). */\n\tif (!after(end_seq, tp->snd_una))\n\t\treturn sacked;\n\n\tif (!(sacked & TCPCB_SACKED_ACKED)) {\n\t\ttcp_rack_advance(tp, xmit_time, sacked);\n\n\t\tif (sacked & TCPCB_SACKED_RETRANS) {\n\t\t\t/* If the segment is not tagged as lost,\n\t\t\t * we do not clear RETRANS, believing\n\t\t\t * that retransmission is still in flight.\n\t\t\t */\n\t\t\tif (sacked & TCPCB_LOST) {\n\t\t\t\tsacked &= ~(TCPCB_LOST|TCPCB_SACKED_RETRANS);\n\t\t\t\ttp->lost_out -= pcount;\n\t\t\t\ttp->retrans_out -= pcount;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(sacked & TCPCB_RETRANS)) {\n\t\t\t\t/* New sack for not retransmitted frame,\n\t\t\t\t * which was in hole. It is reordering.\n\t\t\t\t */\n\t\t\t\tif (before(start_seq,\n\t\t\t\t\t   tcp_highest_sack_seq(tp)))\n\t\t\t\t\tstate->reord = min(fack_count,\n\t\t\t\t\t\t\t   state->reord);\n\t\t\t\tif (!after(end_seq, tp->high_seq))\n\t\t\t\t\tstate->flag |= FLAG_ORIG_SACK_ACKED;\n\t\t\t\tif (state->first_sackt.v64 == 0)\n\t\t\t\t\tstate->first_sackt = *xmit_time;\n\t\t\t\tstate->last_sackt = *xmit_time;\n\t\t\t}\n\n\t\t\tif (sacked & TCPCB_LOST) {\n\t\t\t\tsacked &= ~TCPCB_LOST;\n\t\t\t\ttp->lost_out -= pcount;\n\t\t\t}\n\t\t}\n\n\t\tsacked |= TCPCB_SACKED_ACKED;\n\t\tstate->flag |= FLAG_DATA_SACKED;\n\t\ttp->sacked_out += pcount;\n\n\t\tfack_count += pcount;\n\n\t\t/* Lost marker hint past SACKed? Tweak RFC3517 cnt */\n\t\tif (!tcp_is_fack(tp) && tp->lost_skb_hint &&\n\t\t    before(start_seq, TCP_SKB_CB(tp->lost_skb_hint)->seq))\n\t\t\ttp->lost_cnt_hint += pcount;\n\n\t\tif (fack_count > tp->fackets_out)\n\t\t\ttp->fackets_out = fack_count;\n\t}\n\n\t/* D-SACK. We can detect redundant retransmission in S|R and plain R\n\t * frames and clear it. undo_retrans is decreased above, L|R frames\n\t * are accounted above as well.\n\t */\n\tif (dup_sack && (sacked & TCPCB_SACKED_RETRANS)) {\n\t\tsacked &= ~TCPCB_SACKED_RETRANS;\n\t\ttp->retrans_out -= pcount;\n\t}\n\n\treturn sacked;\n}\n\n/* Shift newly-SACKed bytes from this skb to the immediately previous\n * already-SACKed sk_buff. Mark the newly-SACKed bytes as such.\n */\nstatic bool tcp_shifted_skb(struct sock *sk, struct sk_buff *skb,\n\t\t\t    struct tcp_sacktag_state *state,\n\t\t\t    unsigned int pcount, int shifted, int mss,\n\t\t\t    bool dup_sack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *prev = tcp_write_queue_prev(sk, skb);\n\tu32 start_seq = TCP_SKB_CB(skb)->seq;\t/* start of newly-SACKed */\n\tu32 end_seq = start_seq + shifted;\t/* end of newly-SACKed */\n\n\tBUG_ON(!pcount);\n\n\t/* Adjust counters and hints for the newly sacked sequence\n\t * range but discard the return value since prev is already\n\t * marked. We must tag the range first because the seq\n\t * advancement below implicitly advances\n\t * tcp_highest_sack_seq() when skb is highest_sack.\n\t */\n\ttcp_sacktag_one(sk, state, TCP_SKB_CB(skb)->sacked,\n\t\t\tstart_seq, end_seq, dup_sack, pcount,\n\t\t\t&skb->skb_mstamp);\n\n\tif (skb == tp->lost_skb_hint)\n\t\ttp->lost_cnt_hint += pcount;\n\n\tTCP_SKB_CB(prev)->end_seq += shifted;\n\tTCP_SKB_CB(skb)->seq += shifted;\n\n\ttcp_skb_pcount_add(prev, pcount);\n\tBUG_ON(tcp_skb_pcount(skb) < pcount);\n\ttcp_skb_pcount_add(skb, -pcount);\n\n\t/* When we're adding to gso_segs == 1, gso_size will be zero,\n\t * in theory this shouldn't be necessary but as long as DSACK\n\t * code can come after this skb later on it's better to keep\n\t * setting gso_size to something.\n\t */\n\tif (!TCP_SKB_CB(prev)->tcp_gso_size)\n\t\tTCP_SKB_CB(prev)->tcp_gso_size = mss;\n\n\t/* CHECKME: To clear or not to clear? Mimics normal skb currently */\n\tif (tcp_skb_pcount(skb) <= 1)\n\t\tTCP_SKB_CB(skb)->tcp_gso_size = 0;\n\n\t/* Difference in this won't matter, both ACKed by the same cumul. ACK */\n\tTCP_SKB_CB(prev)->sacked |= (TCP_SKB_CB(skb)->sacked & TCPCB_EVER_RETRANS);\n\n\tif (skb->len > 0) {\n\t\tBUG_ON(!tcp_skb_pcount(skb));\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SACKSHIFTED);\n\t\treturn false;\n\t}\n\n\t/* Whole SKB was eaten :-) */\n\n\tif (skb == tp->retransmit_skb_hint)\n\t\ttp->retransmit_skb_hint = prev;\n\tif (skb == tp->lost_skb_hint) {\n\t\ttp->lost_skb_hint = prev;\n\t\ttp->lost_cnt_hint -= tcp_skb_pcount(prev);\n\t}\n\n\tTCP_SKB_CB(prev)->tcp_flags |= TCP_SKB_CB(skb)->tcp_flags;\n\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\tTCP_SKB_CB(prev)->end_seq++;\n\n\tif (skb == tcp_highest_sack(sk))\n\t\ttcp_advance_highest_sack(sk, skb);\n\n\ttcp_unlink_write_queue(skb, sk);\n\tsk_wmem_free_skb(sk, skb);\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SACKMERGED);\n\n\treturn true;\n}\n\n/* I wish gso_size would have a bit more sane initialization than\n * something-or-zero which complicates things\n */\nstatic int tcp_skb_seglen(const struct sk_buff *skb)\n{\n\treturn tcp_skb_pcount(skb) == 1 ? skb->len : tcp_skb_mss(skb);\n}\n\n/* Shifting pages past head area doesn't work */\nstatic int skb_can_shift(const struct sk_buff *skb)\n{\n\treturn !skb_headlen(skb) && skb_is_nonlinear(skb);\n}\n\n/* Try collapsing SACK blocks spanning across multiple skbs to a single\n * skb.\n */\nstatic struct sk_buff *tcp_shift_skb_data(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct tcp_sacktag_state *state,\n\t\t\t\t\t  u32 start_seq, u32 end_seq,\n\t\t\t\t\t  bool dup_sack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *prev;\n\tint mss;\n\tint pcount = 0;\n\tint len;\n\tint in_sack;\n\n\tif (!sk_can_gso(sk))\n\t\tgoto fallback;\n\n\t/* Normally R but no L won't result in plain S */\n\tif (!dup_sack &&\n\t    (TCP_SKB_CB(skb)->sacked & (TCPCB_LOST|TCPCB_SACKED_RETRANS)) == TCPCB_SACKED_RETRANS)\n\t\tgoto fallback;\n\tif (!skb_can_shift(skb))\n\t\tgoto fallback;\n\t/* This frame is about to be dropped (was ACKed). */\n\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una))\n\t\tgoto fallback;\n\n\t/* Can only happen with delayed DSACK + discard craziness */\n\tif (unlikely(skb == tcp_write_queue_head(sk)))\n\t\tgoto fallback;\n\tprev = tcp_write_queue_prev(sk, skb);\n\n\tif ((TCP_SKB_CB(prev)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED)\n\t\tgoto fallback;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (in_sack) {\n\t\tlen = skb->len;\n\t\tpcount = tcp_skb_pcount(skb);\n\t\tmss = tcp_skb_seglen(skb);\n\n\t\t/* TODO: Fix DSACKs to not fragment already SACKed and we can\n\t\t * drop this restriction as unnecessary\n\t\t */\n\t\tif (mss != tcp_skb_seglen(prev))\n\t\t\tgoto fallback;\n\t} else {\n\t\tif (!after(TCP_SKB_CB(skb)->end_seq, start_seq))\n\t\t\tgoto noop;\n\t\t/* CHECKME: This is non-MSS split case only?, this will\n\t\t * cause skipped skbs due to advancing loop btw, original\n\t\t * has that feature too\n\t\t */\n\t\tif (tcp_skb_pcount(skb) <= 1)\n\t\t\tgoto noop;\n\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\t\tif (!in_sack) {\n\t\t\t/* TODO: head merge to next could be attempted here\n\t\t\t * if (!after(TCP_SKB_CB(skb)->end_seq, end_seq)),\n\t\t\t * though it might not be worth of the additional hassle\n\t\t\t *\n\t\t\t * ...we can probably just fallback to what was done\n\t\t\t * previously. We could try merging non-SACKed ones\n\t\t\t * as well but it probably isn't going to buy off\n\t\t\t * because later SACKs might again split them, and\n\t\t\t * it would make skb timestamp tracking considerably\n\t\t\t * harder problem.\n\t\t\t */\n\t\t\tgoto fallback;\n\t\t}\n\n\t\tlen = end_seq - TCP_SKB_CB(skb)->seq;\n\t\tBUG_ON(len < 0);\n\t\tBUG_ON(len > skb->len);\n\n\t\t/* MSS boundaries should be honoured or else pcount will\n\t\t * severely break even though it makes things bit trickier.\n\t\t * Optimize common case to avoid most of the divides\n\t\t */\n\t\tmss = tcp_skb_mss(skb);\n\n\t\t/* TODO: Fix DSACKs to not fragment already SACKed and we can\n\t\t * drop this restriction as unnecessary\n\t\t */\n\t\tif (mss != tcp_skb_seglen(prev))\n\t\t\tgoto fallback;\n\n\t\tif (len == mss) {\n\t\t\tpcount = 1;\n\t\t} else if (len < mss) {\n\t\t\tgoto noop;\n\t\t} else {\n\t\t\tpcount = len / mss;\n\t\t\tlen = pcount * mss;\n\t\t}\n\t}\n\n\t/* tcp_sacktag_one() won't SACK-tag ranges below snd_una */\n\tif (!after(TCP_SKB_CB(skb)->seq + len, tp->snd_una))\n\t\tgoto fallback;\n\n\tif (!skb_shift(prev, skb, len))\n\t\tgoto fallback;\n\tif (!tcp_shifted_skb(sk, skb, state, pcount, len, mss, dup_sack))\n\t\tgoto out;\n\n\t/* Hole filled allows collapsing with the next as well, this is very\n\t * useful when hole on every nth skb pattern happens\n\t */\n\tif (prev == tcp_write_queue_tail(sk))\n\t\tgoto out;\n\tskb = tcp_write_queue_next(sk, prev);\n\n\tif (!skb_can_shift(skb) ||\n\t    (skb == tcp_send_head(sk)) ||\n\t    ((TCP_SKB_CB(skb)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED) ||\n\t    (mss != tcp_skb_seglen(skb)))\n\t\tgoto out;\n\n\tlen = skb->len;\n\tif (skb_shift(prev, skb, len)) {\n\t\tpcount += tcp_skb_pcount(skb);\n\t\ttcp_shifted_skb(sk, skb, state, tcp_skb_pcount(skb), len, mss, 0);\n\t}\n\nout:\n\tstate->fack_count += pcount;\n\treturn prev;\n\nnoop:\n\treturn skb;\n\nfallback:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SACKSHIFTFALLBACK);\n\treturn NULL;\n}\n\nstatic struct sk_buff *tcp_sacktag_walk(struct sk_buff *skb, struct sock *sk,\n\t\t\t\t\tstruct tcp_sack_block *next_dup,\n\t\t\t\t\tstruct tcp_sacktag_state *state,\n\t\t\t\t\tu32 start_seq, u32 end_seq,\n\t\t\t\t\tbool dup_sack_in)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *tmp;\n\n\ttcp_for_write_queue_from(skb, sk) {\n\t\tint in_sack = 0;\n\t\tbool dup_sack = dup_sack_in;\n\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\n\t\t/* queue is in-order => we can short-circuit the walk early */\n\t\tif (!before(TCP_SKB_CB(skb)->seq, end_seq))\n\t\t\tbreak;\n\n\t\tif (next_dup  &&\n\t\t    before(TCP_SKB_CB(skb)->seq, next_dup->end_seq)) {\n\t\t\tin_sack = tcp_match_skb_to_sack(sk, skb,\n\t\t\t\t\t\t\tnext_dup->start_seq,\n\t\t\t\t\t\t\tnext_dup->end_seq);\n\t\t\tif (in_sack > 0)\n\t\t\t\tdup_sack = true;\n\t\t}\n\n\t\t/* skb reference here is a bit tricky to get right, since\n\t\t * shifting can eat and free both this skb and the next,\n\t\t * so not even _safe variant of the loop is enough.\n\t\t */\n\t\tif (in_sack <= 0) {\n\t\t\ttmp = tcp_shift_skb_data(sk, skb, state,\n\t\t\t\t\t\t start_seq, end_seq, dup_sack);\n\t\t\tif (tmp) {\n\t\t\t\tif (tmp != skb) {\n\t\t\t\t\tskb = tmp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tin_sack = 0;\n\t\t\t} else {\n\t\t\t\tin_sack = tcp_match_skb_to_sack(sk, skb,\n\t\t\t\t\t\t\t\tstart_seq,\n\t\t\t\t\t\t\t\tend_seq);\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(in_sack < 0))\n\t\t\tbreak;\n\n\t\tif (in_sack) {\n\t\t\tTCP_SKB_CB(skb)->sacked =\n\t\t\t\ttcp_sacktag_one(sk,\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tTCP_SKB_CB(skb)->sacked,\n\t\t\t\t\t\tTCP_SKB_CB(skb)->seq,\n\t\t\t\t\t\tTCP_SKB_CB(skb)->end_seq,\n\t\t\t\t\t\tdup_sack,\n\t\t\t\t\t\ttcp_skb_pcount(skb),\n\t\t\t\t\t\t&skb->skb_mstamp);\n\n\t\t\tif (!before(TCP_SKB_CB(skb)->seq,\n\t\t\t\t    tcp_highest_sack_seq(tp)))\n\t\t\t\ttcp_advance_highest_sack(sk, skb);\n\t\t}\n\n\t\tstate->fack_count += tcp_skb_pcount(skb);\n\t}\n\treturn skb;\n}\n\n/* Avoid all extra work that is being done by sacktag while walking in\n * a normal way\n */\nstatic struct sk_buff *tcp_sacktag_skip(struct sk_buff *skb, struct sock *sk,\n\t\t\t\t\tstruct tcp_sacktag_state *state,\n\t\t\t\t\tu32 skip_to_seq)\n{\n\ttcp_for_write_queue_from(skb, sk) {\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\n\t\tif (after(TCP_SKB_CB(skb)->end_seq, skip_to_seq))\n\t\t\tbreak;\n\n\t\tstate->fack_count += tcp_skb_pcount(skb);\n\t}\n\treturn skb;\n}\n\nstatic struct sk_buff *tcp_maybe_skipping_dsack(struct sk_buff *skb,\n\t\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\t\tstruct tcp_sack_block *next_dup,\n\t\t\t\t\t\tstruct tcp_sacktag_state *state,\n\t\t\t\t\t\tu32 skip_to_seq)\n{\n\tif (!next_dup)\n\t\treturn skb;\n\n\tif (before(next_dup->start_seq, skip_to_seq)) {\n\t\tskb = tcp_sacktag_skip(skb, sk, state, next_dup->start_seq);\n\t\tskb = tcp_sacktag_walk(skb, sk, NULL, state,\n\t\t\t\t       next_dup->start_seq, next_dup->end_seq,\n\t\t\t\t       1);\n\t}\n\n\treturn skb;\n}\n\nstatic int tcp_sack_cache_ok(const struct tcp_sock *tp, const struct tcp_sack_block *cache)\n{\n\treturn cache < tp->recv_sack_cache + ARRAY_SIZE(tp->recv_sack_cache);\n}\n\nstatic int\ntcp_sacktag_write_queue(struct sock *sk, const struct sk_buff *ack_skb,\n\t\t\tu32 prior_snd_una, struct tcp_sacktag_state *state)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst unsigned char *ptr = (skb_transport_header(ack_skb) +\n\t\t\t\t    TCP_SKB_CB(ack_skb)->sacked);\n\tstruct tcp_sack_block_wire *sp_wire = (struct tcp_sack_block_wire *)(ptr+2);\n\tstruct tcp_sack_block sp[TCP_NUM_SACKS];\n\tstruct tcp_sack_block *cache;\n\tstruct sk_buff *skb;\n\tint num_sacks = min(TCP_NUM_SACKS, (ptr[1] - TCPOLEN_SACK_BASE) >> 3);\n\tint used_sacks;\n\tbool found_dup_sack = false;\n\tint i, j;\n\tint first_sack_index;\n\n\tstate->flag = 0;\n\tstate->reord = tp->packets_out;\n\n\tif (!tp->sacked_out) {\n\t\tif (WARN_ON(tp->fackets_out))\n\t\t\ttp->fackets_out = 0;\n\t\ttcp_highest_sack_reset(sk);\n\t}\n\n\tfound_dup_sack = tcp_check_dsack(sk, ack_skb, sp_wire,\n\t\t\t\t\t num_sacks, prior_snd_una);\n\tif (found_dup_sack)\n\t\tstate->flag |= FLAG_DSACKING_ACK;\n\n\t/* Eliminate too old ACKs, but take into\n\t * account more or less fresh ones, they can\n\t * contain valid SACK info.\n\t */\n\tif (before(TCP_SKB_CB(ack_skb)->ack_seq, prior_snd_una - tp->max_window))\n\t\treturn 0;\n\n\tif (!tp->packets_out)\n\t\tgoto out;\n\n\tused_sacks = 0;\n\tfirst_sack_index = 0;\n\tfor (i = 0; i < num_sacks; i++) {\n\t\tbool dup_sack = !i && found_dup_sack;\n\n\t\tsp[used_sacks].start_seq = get_unaligned_be32(&sp_wire[i].start_seq);\n\t\tsp[used_sacks].end_seq = get_unaligned_be32(&sp_wire[i].end_seq);\n\n\t\tif (!tcp_is_sackblock_valid(tp, dup_sack,\n\t\t\t\t\t    sp[used_sacks].start_seq,\n\t\t\t\t\t    sp[used_sacks].end_seq)) {\n\t\t\tint mib_idx;\n\n\t\t\tif (dup_sack) {\n\t\t\t\tif (!tp->undo_marker)\n\t\t\t\t\tmib_idx = LINUX_MIB_TCPDSACKIGNOREDNOUNDO;\n\t\t\t\telse\n\t\t\t\t\tmib_idx = LINUX_MIB_TCPDSACKIGNOREDOLD;\n\t\t\t} else {\n\t\t\t\t/* Don't count olds caused by ACK reordering */\n\t\t\t\tif ((TCP_SKB_CB(ack_skb)->ack_seq != tp->snd_una) &&\n\t\t\t\t    !after(sp[used_sacks].end_seq, tp->snd_una))\n\t\t\t\t\tcontinue;\n\t\t\t\tmib_idx = LINUX_MIB_TCPSACKDISCARD;\n\t\t\t}\n\n\t\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\t\t\tif (i == 0)\n\t\t\t\tfirst_sack_index = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ignore very old stuff early */\n\t\tif (!after(sp[used_sacks].end_seq, prior_snd_una))\n\t\t\tcontinue;\n\n\t\tused_sacks++;\n\t}\n\n\t/* order SACK blocks to allow in order walk of the retrans queue */\n\tfor (i = used_sacks - 1; i > 0; i--) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (after(sp[j].start_seq, sp[j + 1].start_seq)) {\n\t\t\t\tswap(sp[j], sp[j + 1]);\n\n\t\t\t\t/* Track where the first SACK block goes to */\n\t\t\t\tif (j == first_sack_index)\n\t\t\t\t\tfirst_sack_index = j + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tskb = tcp_write_queue_head(sk);\n\tstate->fack_count = 0;\n\ti = 0;\n\n\tif (!tp->sacked_out) {\n\t\t/* It's already past, so skip checking against it */\n\t\tcache = tp->recv_sack_cache + ARRAY_SIZE(tp->recv_sack_cache);\n\t} else {\n\t\tcache = tp->recv_sack_cache;\n\t\t/* Skip empty blocks in at head of the cache */\n\t\twhile (tcp_sack_cache_ok(tp, cache) && !cache->start_seq &&\n\t\t       !cache->end_seq)\n\t\t\tcache++;\n\t}\n\n\twhile (i < used_sacks) {\n\t\tu32 start_seq = sp[i].start_seq;\n\t\tu32 end_seq = sp[i].end_seq;\n\t\tbool dup_sack = (found_dup_sack && (i == first_sack_index));\n\t\tstruct tcp_sack_block *next_dup = NULL;\n\n\t\tif (found_dup_sack && ((i + 1) == first_sack_index))\n\t\t\tnext_dup = &sp[i + 1];\n\n\t\t/* Skip too early cached blocks */\n\t\twhile (tcp_sack_cache_ok(tp, cache) &&\n\t\t       !before(start_seq, cache->end_seq))\n\t\t\tcache++;\n\n\t\t/* Can skip some work by looking recv_sack_cache? */\n\t\tif (tcp_sack_cache_ok(tp, cache) && !dup_sack &&\n\t\t    after(end_seq, cache->start_seq)) {\n\n\t\t\t/* Head todo? */\n\t\t\tif (before(start_seq, cache->start_seq)) {\n\t\t\t\tskb = tcp_sacktag_skip(skb, sk, state,\n\t\t\t\t\t\t       start_seq);\n\t\t\t\tskb = tcp_sacktag_walk(skb, sk, next_dup,\n\t\t\t\t\t\t       state,\n\t\t\t\t\t\t       start_seq,\n\t\t\t\t\t\t       cache->start_seq,\n\t\t\t\t\t\t       dup_sack);\n\t\t\t}\n\n\t\t\t/* Rest of the block already fully processed? */\n\t\t\tif (!after(end_seq, cache->end_seq))\n\t\t\t\tgoto advance_sp;\n\n\t\t\tskb = tcp_maybe_skipping_dsack(skb, sk, next_dup,\n\t\t\t\t\t\t       state,\n\t\t\t\t\t\t       cache->end_seq);\n\n\t\t\t/* ...tail remains todo... */\n\t\t\tif (tcp_highest_sack_seq(tp) == cache->end_seq) {\n\t\t\t\t/* ...but better entrypoint exists! */\n\t\t\t\tskb = tcp_highest_sack(sk);\n\t\t\t\tif (!skb)\n\t\t\t\t\tbreak;\n\t\t\t\tstate->fack_count = tp->fackets_out;\n\t\t\t\tcache++;\n\t\t\t\tgoto walk;\n\t\t\t}\n\n\t\t\tskb = tcp_sacktag_skip(skb, sk, state, cache->end_seq);\n\t\t\t/* Check overlap against next cached too (past this one already) */\n\t\t\tcache++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!before(start_seq, tcp_highest_sack_seq(tp))) {\n\t\t\tskb = tcp_highest_sack(sk);\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\t\t\tstate->fack_count = tp->fackets_out;\n\t\t}\n\t\tskb = tcp_sacktag_skip(skb, sk, state, start_seq);\n\nwalk:\n\t\tskb = tcp_sacktag_walk(skb, sk, next_dup, state,\n\t\t\t\t       start_seq, end_seq, dup_sack);\n\nadvance_sp:\n\t\ti++;\n\t}\n\n\t/* Clear the head of the cache sack blocks so we can skip it next time */\n\tfor (i = 0; i < ARRAY_SIZE(tp->recv_sack_cache) - used_sacks; i++) {\n\t\ttp->recv_sack_cache[i].start_seq = 0;\n\t\ttp->recv_sack_cache[i].end_seq = 0;\n\t}\n\tfor (j = 0; j < used_sacks; j++)\n\t\ttp->recv_sack_cache[i++] = sp[j];\n\n\tif ((state->reord < tp->fackets_out) &&\n\t    ((inet_csk(sk)->icsk_ca_state != TCP_CA_Loss) || tp->undo_marker))\n\t\ttcp_update_reordering(sk, tp->fackets_out - state->reord, 0);\n\n\ttcp_verify_left_out(tp);\nout:\n\n#if FASTRETRANS_DEBUG > 0\n\tWARN_ON((int)tp->sacked_out < 0);\n\tWARN_ON((int)tp->lost_out < 0);\n\tWARN_ON((int)tp->retrans_out < 0);\n\tWARN_ON((int)tcp_packets_in_flight(tp) < 0);\n#endif\n\treturn state->flag;\n}\n\n/* Limits sacked_out so that sum with lost_out isn't ever larger than\n * packets_out. Returns false if sacked_out adjustement wasn't necessary.\n */\nstatic bool tcp_limit_reno_sacked(struct tcp_sock *tp)\n{\n\tu32 holes;\n\n\tholes = max(tp->lost_out, 1U);\n\tholes = min(holes, tp->packets_out);\n\n\tif ((tp->sacked_out + holes) > tp->packets_out) {\n\t\ttp->sacked_out = tp->packets_out - holes;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* If we receive more dupacks than we expected counting segments\n * in assumption of absent reordering, interpret this as reordering.\n * The only another reason could be bug in receiver TCP.\n */\nstatic void tcp_check_reno_reordering(struct sock *sk, const int addend)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (tcp_limit_reno_sacked(tp))\n\t\ttcp_update_reordering(sk, tp->packets_out + addend, 0);\n}\n\n/* Emulate SACKs for SACKless connection: account for a new dupack. */\n\nstatic void tcp_add_reno_sack(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\ttp->sacked_out++;\n\ttcp_check_reno_reordering(sk, 0);\n\ttcp_verify_left_out(tp);\n}\n\n/* Account for ACK, ACKing some data in Reno Recovery phase. */\n\nstatic void tcp_remove_reno_sacks(struct sock *sk, int acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (acked > 0) {\n\t\t/* One ACK acked hole. The rest eat duplicate ACKs. */\n\t\tif (acked - 1 >= tp->sacked_out)\n\t\t\ttp->sacked_out = 0;\n\t\telse\n\t\t\ttp->sacked_out -= acked - 1;\n\t}\n\ttcp_check_reno_reordering(sk, acked);\n\ttcp_verify_left_out(tp);\n}\n\nstatic inline void tcp_reset_reno_sack(struct tcp_sock *tp)\n{\n\ttp->sacked_out = 0;\n}\n\nvoid tcp_clear_retrans(struct tcp_sock *tp)\n{\n\ttp->retrans_out = 0;\n\ttp->lost_out = 0;\n\ttp->undo_marker = 0;\n\ttp->undo_retrans = -1;\n\ttp->fackets_out = 0;\n\ttp->sacked_out = 0;\n}\n\nstatic inline void tcp_init_undo(struct tcp_sock *tp)\n{\n\ttp->undo_marker = tp->snd_una;\n\t/* Retransmission still in flight may cause DSACKs later. */\n\ttp->undo_retrans = tp->retrans_out ? : -1;\n}\n\n/* Enter Loss state. If we detect SACK reneging, forget all SACK information\n * and reset tags completely, otherwise preserve SACKs. If receiver\n * dropped its ofo queue, we will know this due to reneging detection.\n */\nvoid tcp_enter_loss(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb;\n\tbool new_recovery = icsk->icsk_ca_state < TCP_CA_Recovery;\n\tbool is_reneg;\t\t\t/* is receiver reneging on SACKs? */\n\n\t/* Reduce ssthresh if it has not yet been made inside this window. */\n\tif (icsk->icsk_ca_state <= TCP_CA_Disorder ||\n\t    !after(tp->high_seq, tp->snd_una) ||\n\t    (icsk->icsk_ca_state == TCP_CA_Loss && !icsk->icsk_retransmits)) {\n\t\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\n\t\ttp->snd_ssthresh = icsk->icsk_ca_ops->ssthresh(sk);\n\t\ttcp_ca_event(sk, CA_EVENT_LOSS);\n\t\ttcp_init_undo(tp);\n\t}\n\ttp->snd_cwnd\t   = 1;\n\ttp->snd_cwnd_cnt   = 0;\n\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\n\ttp->retrans_out = 0;\n\ttp->lost_out = 0;\n\n\tif (tcp_is_reno(tp))\n\t\ttcp_reset_reno_sack(tp);\n\n\tskb = tcp_write_queue_head(sk);\n\tis_reneg = skb && (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED);\n\tif (is_reneg) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSACKRENEGING);\n\t\ttp->sacked_out = 0;\n\t\ttp->fackets_out = 0;\n\t}\n\ttcp_clear_all_retrans_hints(tp);\n\n\ttcp_for_write_queue(skb, sk) {\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\n\t\tTCP_SKB_CB(skb)->sacked &= (~TCPCB_TAGBITS)|TCPCB_SACKED_ACKED;\n\t\tif (!(TCP_SKB_CB(skb)->sacked&TCPCB_SACKED_ACKED) || is_reneg) {\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_ACKED;\n\t\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_LOST;\n\t\t\ttp->lost_out += tcp_skb_pcount(skb);\n\t\t\ttp->retransmit_high = TCP_SKB_CB(skb)->end_seq;\n\t\t}\n\t}\n\ttcp_verify_left_out(tp);\n\n\t/* Timeout in disordered state after receiving substantial DUPACKs\n\t * suggests that the degree of reordering is over-estimated.\n\t */\n\tif (icsk->icsk_ca_state <= TCP_CA_Disorder &&\n\t    tp->sacked_out >= sysctl_tcp_reordering)\n\t\ttp->reordering = min_t(unsigned int, tp->reordering,\n\t\t\t\t       sysctl_tcp_reordering);\n\ttcp_set_ca_state(sk, TCP_CA_Loss);\n\ttp->high_seq = tp->snd_nxt;\n\ttcp_ecn_queue_cwr(tp);\n\n\t/* F-RTO RFC5682 sec 3.1 step 1: retransmit SND.UNA if no previous\n\t * loss recovery is underway except recurring timeout(s) on\n\t * the same SND.UNA (sec 3.2). Disable F-RTO on path MTU probing\n\t */\n\ttp->frto = sysctl_tcp_frto &&\n\t\t   (new_recovery || icsk->icsk_retransmits) &&\n\t\t   !inet_csk(sk)->icsk_mtup.probe_size;\n}\n\n/* If ACK arrived pointing to a remembered SACK, it means that our\n * remembered SACKs do not reflect real state of receiver i.e.\n * receiver _host_ is heavily congested (or buggy).\n *\n * To avoid big spurious retransmission bursts due to transient SACK\n * scoreboard oddities that look like reneging, we give the receiver a\n * little time (max(RTT/2, 10ms)) to send us some more ACKs that will\n * restore sanity to the SACK scoreboard. If the apparent reneging\n * persists until this RTO then we'll clear the SACK scoreboard.\n */\nstatic bool tcp_check_sack_reneging(struct sock *sk, int flag)\n{\n\tif (flag & FLAG_SACK_RENEGING) {\n\t\tstruct tcp_sock *tp = tcp_sk(sk);\n\t\tunsigned long delay = max(usecs_to_jiffies(tp->srtt_us >> 4),\n\t\t\t\t\t  msecs_to_jiffies(10));\n\n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,\n\t\t\t\t\t  delay, TCP_RTO_MAX);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline int tcp_fackets_out(const struct tcp_sock *tp)\n{\n\treturn tcp_is_reno(tp) ? tp->sacked_out + 1 : tp->fackets_out;\n}\n\n/* Heurestics to calculate number of duplicate ACKs. There's no dupACKs\n * counter when SACK is enabled (without SACK, sacked_out is used for\n * that purpose).\n *\n * Instead, with FACK TCP uses fackets_out that includes both SACKed\n * segments up to the highest received SACK block so far and holes in\n * between them.\n *\n * With reordering, holes may still be in flight, so RFC3517 recovery\n * uses pure sacked_out (total number of SACKed segments) even though\n * it violates the RFC that uses duplicate ACKs, often these are equal\n * but when e.g. out-of-window ACKs or packet duplication occurs,\n * they differ. Since neither occurs due to loss, TCP should really\n * ignore them.\n */\nstatic inline int tcp_dupack_heuristics(const struct tcp_sock *tp)\n{\n\treturn tcp_is_fack(tp) ? tp->fackets_out : tp->sacked_out + 1;\n}\n\nstatic bool tcp_pause_early_retransmit(struct sock *sk, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tunsigned long delay;\n\n\t/* Delay early retransmit and entering fast recovery for\n\t * max(RTT/4, 2msec) unless ack has ECE mark, no RTT samples\n\t * available, or RTO is scheduled to fire first.\n\t */\n\tif (sysctl_tcp_early_retrans < 2 || sysctl_tcp_early_retrans > 3 ||\n\t    (flag & FLAG_ECE) || !tp->srtt_us)\n\t\treturn false;\n\n\tdelay = max(usecs_to_jiffies(tp->srtt_us >> 5),\n\t\t    msecs_to_jiffies(2));\n\n\tif (!time_after(inet_csk(sk)->icsk_timeout, (jiffies + delay)))\n\t\treturn false;\n\n\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_EARLY_RETRANS, delay,\n\t\t\t\t  TCP_RTO_MAX);\n\treturn true;\n}\n\n/* Linux NewReno/SACK/FACK/ECN state machine.\n * --------------------------------------\n *\n * \"Open\"\tNormal state, no dubious events, fast path.\n * \"Disorder\"   In all the respects it is \"Open\",\n *\t\tbut requires a bit more attention. It is entered when\n *\t\twe see some SACKs or dupacks. It is split of \"Open\"\n *\t\tmainly to move some processing from fast path to slow one.\n * \"CWR\"\tCWND was reduced due to some Congestion Notification event.\n *\t\tIt can be ECN, ICMP source quench, local device congestion.\n * \"Recovery\"\tCWND was reduced, we are fast-retransmitting.\n * \"Loss\"\tCWND was reduced due to RTO timeout or SACK reneging.\n *\n * tcp_fastretrans_alert() is entered:\n * - each incoming ACK, if state is not \"Open\"\n * - when arrived ACK is unusual, namely:\n *\t* SACK\n *\t* Duplicate ACK.\n *\t* ECN ECE.\n *\n * Counting packets in flight is pretty simple.\n *\n *\tin_flight = packets_out - left_out + retrans_out\n *\n *\tpackets_out is SND.NXT-SND.UNA counted in packets.\n *\n *\tretrans_out is number of retransmitted segments.\n *\n *\tleft_out is number of segments left network, but not ACKed yet.\n *\n *\t\tleft_out = sacked_out + lost_out\n *\n *     sacked_out: Packets, which arrived to receiver out of order\n *\t\t   and hence not ACKed. With SACKs this number is simply\n *\t\t   amount of SACKed data. Even without SACKs\n *\t\t   it is easy to give pretty reliable estimate of this number,\n *\t\t   counting duplicate ACKs.\n *\n *       lost_out: Packets lost by network. TCP has no explicit\n *\t\t   \"loss notification\" feedback from network (for now).\n *\t\t   It means that this number can be only _guessed_.\n *\t\t   Actually, it is the heuristics to predict lossage that\n *\t\t   distinguishes different algorithms.\n *\n *\tF.e. after RTO, when all the queue is considered as lost,\n *\tlost_out = packets_out and in_flight = retrans_out.\n *\n *\t\tEssentially, we have now two algorithms counting\n *\t\tlost packets.\n *\n *\t\tFACK: It is the simplest heuristics. As soon as we decided\n *\t\tthat something is lost, we decide that _all_ not SACKed\n *\t\tpackets until the most forward SACK are lost. I.e.\n *\t\tlost_out = fackets_out - sacked_out and left_out = fackets_out.\n *\t\tIt is absolutely correct estimate, if network does not reorder\n *\t\tpackets. And it loses any connection to reality when reordering\n *\t\ttakes place. We use FACK by default until reordering\n *\t\tis suspected on the path to this destination.\n *\n *\t\tNewReno: when Recovery is entered, we assume that one segment\n *\t\tis lost (classic Reno). While we are in Recovery and\n *\t\ta partial ACK arrives, we assume that one more packet\n *\t\tis lost (NewReno). This heuristics are the same in NewReno\n *\t\tand SACK.\n *\n *  Imagine, that's all! Forget about all this shamanism about CWND inflation\n *  deflation etc. CWND is real congestion window, never inflated, changes\n *  only according to classic VJ rules.\n *\n * Really tricky (and requiring careful tuning) part of algorithm\n * is hidden in functions tcp_time_to_recover() and tcp_xmit_retransmit_queue().\n * The first determines the moment _when_ we should reduce CWND and,\n * hence, slow down forward transmission. In fact, it determines the moment\n * when we decide that hole is caused by loss, rather than by a reorder.\n *\n * tcp_xmit_retransmit_queue() decides, _what_ we should retransmit to fill\n * holes, caused by lost packets.\n *\n * And the most logically complicated part of algorithm is undo\n * heuristics. We detect false retransmits due to both too early\n * fast retransmit (reordering) and underestimated RTO, analyzing\n * timestamps and D-SACKs. When we detect that some segments were\n * retransmitted by mistake and CWND reduction was wrong, we undo\n * window reduction and abort recovery phase. This logic is hidden\n * inside several functions named tcp_try_undo_<something>.\n */\n\n/* This function decides, when we should leave Disordered state\n * and enter Recovery phase, reducing congestion window.\n *\n * Main question: may we further continue forward transmission\n * with the same cwnd?\n */\nstatic bool tcp_time_to_recover(struct sock *sk, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t__u32 packets_out;\n\n\t/* Trick#1: The loss is proven. */\n\tif (tp->lost_out)\n\t\treturn true;\n\n\t/* Not-A-Trick#2 : Classic rule... */\n\tif (tcp_dupack_heuristics(tp) > tp->reordering)\n\t\treturn true;\n\n\t/* Trick#4: It is still not OK... But will it be useful to delay\n\t * recovery more?\n\t */\n\tpackets_out = tp->packets_out;\n\tif (packets_out <= tp->reordering &&\n\t    tp->sacked_out >= max_t(__u32, packets_out/2, sysctl_tcp_reordering) &&\n\t    !tcp_may_send_now(sk)) {\n\t\t/* We have nothing to send. This connection is limited\n\t\t * either by receiver window or by application.\n\t\t */\n\t\treturn true;\n\t}\n\n\t/* If a thin stream is detected, retransmit after first\n\t * received dupack. Employ only if SACK is supported in order\n\t * to avoid possible corner-case series of spurious retransmissions\n\t * Use only if there are no unsent data.\n\t */\n\tif ((tp->thin_dupack || sysctl_tcp_thin_dupack) &&\n\t    tcp_stream_is_thin(tp) && tcp_dupack_heuristics(tp) > 1 &&\n\t    tcp_is_sack(tp) && !tcp_send_head(sk))\n\t\treturn true;\n\n\t/* Trick#6: TCP early retransmit, per RFC5827.  To avoid spurious\n\t * retransmissions due to small network reorderings, we implement\n\t * Mitigation A.3 in the RFC and delay the retransmission for a short\n\t * interval if appropriate.\n\t */\n\tif (tp->do_early_retrans && !tp->retrans_out && tp->sacked_out &&\n\t    (tp->packets_out >= (tp->sacked_out + 1) && tp->packets_out < 4) &&\n\t    !tcp_may_send_now(sk))\n\t\treturn !tcp_pause_early_retransmit(sk, flag);\n\n\treturn false;\n}\n\n/* Detect loss in event \"A\" above by marking head of queue up as lost.\n * For FACK or non-SACK(Reno) senders, the first \"packets\" number of segments\n * are considered lost. For RFC3517 SACK, a segment is considered lost if it\n * has at least tp->reordering SACKed seqments above it; \"packets\" refers to\n * the maximum SACKed segments to pass before reaching this limit.\n */\nstatic void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb;\n\tint cnt, oldcnt;\n\tint err;\n\tunsigned int mss;\n\t/* Use SACK to deduce losses of new sequences sent during recovery */\n\tconst u32 loss_high = tcp_is_sack(tp) ?  tp->snd_nxt : tp->high_seq;\n\n\tWARN_ON(packets > tp->packets_out);\n\tif (tp->lost_skb_hint) {\n\t\tskb = tp->lost_skb_hint;\n\t\tcnt = tp->lost_cnt_hint;\n\t\t/* Head already handled? */\n\t\tif (mark_head && skb != tcp_write_queue_head(sk))\n\t\t\treturn;\n\t} else {\n\t\tskb = tcp_write_queue_head(sk);\n\t\tcnt = 0;\n\t}\n\n\ttcp_for_write_queue_from(skb, sk) {\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\t\t/* TODO: do this better */\n\t\t/* this is not the most efficient way to do this... */\n\t\ttp->lost_skb_hint = skb;\n\t\ttp->lost_cnt_hint = cnt;\n\n\t\tif (after(TCP_SKB_CB(skb)->end_seq, loss_high))\n\t\t\tbreak;\n\n\t\toldcnt = cnt;\n\t\tif (tcp_is_fack(tp) || tcp_is_reno(tp) ||\n\t\t    (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED))\n\t\t\tcnt += tcp_skb_pcount(skb);\n\n\t\tif (cnt > packets) {\n\t\t\tif ((tcp_is_sack(tp) && !tcp_is_fack(tp)) ||\n\t\t\t    (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED) ||\n\t\t\t    (oldcnt >= packets))\n\t\t\t\tbreak;\n\n\t\t\tmss = tcp_skb_mss(skb);\n\t\t\terr = tcp_fragment(sk, skb, (packets - oldcnt) * mss,\n\t\t\t\t\t   mss, GFP_ATOMIC);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\tcnt = packets;\n\t\t}\n\n\t\ttcp_skb_mark_lost(tp, skb);\n\n\t\tif (mark_head)\n\t\t\tbreak;\n\t}\n\ttcp_verify_left_out(tp);\n}\n\n/* Account newly detected lost packet(s) */\n\nstatic void tcp_update_scoreboard(struct sock *sk, int fast_rexmit)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_is_reno(tp)) {\n\t\ttcp_mark_head_lost(sk, 1, 1);\n\t} else if (tcp_is_fack(tp)) {\n\t\tint lost = tp->fackets_out - tp->reordering;\n\t\tif (lost <= 0)\n\t\t\tlost = 1;\n\t\ttcp_mark_head_lost(sk, lost, 0);\n\t} else {\n\t\tint sacked_upto = tp->sacked_out - tp->reordering;\n\t\tif (sacked_upto >= 0)\n\t\t\ttcp_mark_head_lost(sk, sacked_upto, 0);\n\t\telse if (fast_rexmit)\n\t\t\ttcp_mark_head_lost(sk, 1, 1);\n\t}\n}\n\n/* CWND moderation, preventing bursts due to too big ACKs\n * in dubious situations.\n */\nstatic inline void tcp_moderate_cwnd(struct tcp_sock *tp)\n{\n\ttp->snd_cwnd = min(tp->snd_cwnd,\n\t\t\t   tcp_packets_in_flight(tp) + tcp_max_burst(tp));\n\ttp->snd_cwnd_stamp = tcp_time_stamp;\n}\n\nstatic bool tcp_tsopt_ecr_before(const struct tcp_sock *tp, u32 when)\n{\n\treturn tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\n\t       before(tp->rx_opt.rcv_tsecr, when);\n}\n\n/* skb is spurious retransmitted if the returned timestamp echo\n * reply is prior to the skb transmission time\n */\nstatic bool tcp_skb_spurious_retrans(const struct tcp_sock *tp,\n\t\t\t\t     const struct sk_buff *skb)\n{\n\treturn (TCP_SKB_CB(skb)->sacked & TCPCB_RETRANS) &&\n\t       tcp_tsopt_ecr_before(tp, tcp_skb_timestamp(skb));\n}\n\n/* Nothing was retransmitted or returned timestamp is less\n * than timestamp of the first retransmission.\n */\nstatic inline bool tcp_packet_delayed(const struct tcp_sock *tp)\n{\n\treturn !tp->retrans_stamp ||\n\t       tcp_tsopt_ecr_before(tp, tp->retrans_stamp);\n}\n\n/* Undo procedures. */\n\n/* We can clear retrans_stamp when there are no retransmissions in the\n * window. It would seem that it is trivially available for us in\n * tp->retrans_out, however, that kind of assumptions doesn't consider\n * what will happen if errors occur when sending retransmission for the\n * second time. ...It could the that such segment has only\n * TCPCB_EVER_RETRANS set at the present time. It seems that checking\n * the head skb is enough except for some reneging corner cases that\n * are not worth the effort.\n *\n * Main reason for all this complexity is the fact that connection dying\n * time now depends on the validity of the retrans_stamp, in particular,\n * that successive retransmissions of a segment must not advance\n * retrans_stamp under any conditions.\n */\nstatic bool tcp_any_retrans_done(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb;\n\n\tif (tp->retrans_out)\n\t\treturn true;\n\n\tskb = tcp_write_queue_head(sk);\n\tif (unlikely(skb && TCP_SKB_CB(skb)->sacked & TCPCB_EVER_RETRANS))\n\t\treturn true;\n\n\treturn false;\n}\n\n#if FASTRETRANS_DEBUG > 1\nstatic void DBGUNDO(struct sock *sk, const char *msg)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\tif (sk->sk_family == AF_INET) {\n\t\tpr_debug(\"Undo %s %pI4/%u c%u l%u ss%u/%u p%u\\n\",\n\t\t\t msg,\n\t\t\t &inet->inet_daddr, ntohs(inet->inet_dport),\n\t\t\t tp->snd_cwnd, tcp_left_out(tp),\n\t\t\t tp->snd_ssthresh, tp->prior_ssthresh,\n\t\t\t tp->packets_out);\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (sk->sk_family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tpr_debug(\"Undo %s %pI6/%u c%u l%u ss%u/%u p%u\\n\",\n\t\t\t msg,\n\t\t\t &np->daddr, ntohs(inet->inet_dport),\n\t\t\t tp->snd_cwnd, tcp_left_out(tp),\n\t\t\t tp->snd_ssthresh, tp->prior_ssthresh,\n\t\t\t tp->packets_out);\n\t}\n#endif\n}\n#else\n#define DBGUNDO(x...) do { } while (0)\n#endif\n\nstatic void tcp_undo_cwnd_reduction(struct sock *sk, bool unmark_loss)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (unmark_loss) {\n\t\tstruct sk_buff *skb;\n\n\t\ttcp_for_write_queue(skb, sk) {\n\t\t\tif (skb == tcp_send_head(sk))\n\t\t\t\tbreak;\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_LOST;\n\t\t}\n\t\ttp->lost_out = 0;\n\t\ttcp_clear_all_retrans_hints(tp);\n\t}\n\n\tif (tp->prior_ssthresh) {\n\t\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\t\tif (icsk->icsk_ca_ops->undo_cwnd)\n\t\t\ttp->snd_cwnd = icsk->icsk_ca_ops->undo_cwnd(sk);\n\t\telse\n\t\t\ttp->snd_cwnd = max(tp->snd_cwnd, tp->snd_ssthresh << 1);\n\n\t\tif (tp->prior_ssthresh > tp->snd_ssthresh) {\n\t\t\ttp->snd_ssthresh = tp->prior_ssthresh;\n\t\t\ttcp_ecn_withdraw_cwr(tp);\n\t\t}\n\t} else {\n\t\ttp->snd_cwnd = max(tp->snd_cwnd, tp->snd_ssthresh);\n\t}\n\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\ttp->undo_marker = 0;\n}\n\nstatic inline bool tcp_may_undo(const struct tcp_sock *tp)\n{\n\treturn tp->undo_marker && (!tp->undo_retrans || tcp_packet_delayed(tp));\n}\n\n/* People celebrate: \"We love our President!\" */\nstatic bool tcp_try_undo_recovery(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_may_undo(tp)) {\n\t\tint mib_idx;\n\n\t\t/* Happy end! We did not retransmit anything\n\t\t * or our original transmission succeeded.\n\t\t */\n\t\tDBGUNDO(sk, inet_csk(sk)->icsk_ca_state == TCP_CA_Loss ? \"loss\" : \"retrans\");\n\t\ttcp_undo_cwnd_reduction(sk, false);\n\t\tif (inet_csk(sk)->icsk_ca_state == TCP_CA_Loss)\n\t\t\tmib_idx = LINUX_MIB_TCPLOSSUNDO;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPFULLUNDO;\n\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\t}\n\tif (tp->snd_una == tp->high_seq && tcp_is_reno(tp)) {\n\t\t/* Hold old state until something *above* high_seq\n\t\t * is ACKed. For Reno it is MUST to prevent false\n\t\t * fast retransmits (RFC2582). SACK TCP is safe. */\n\t\ttcp_moderate_cwnd(tp);\n\t\tif (!tcp_any_retrans_done(sk))\n\t\t\ttp->retrans_stamp = 0;\n\t\treturn true;\n\t}\n\ttcp_set_ca_state(sk, TCP_CA_Open);\n\treturn false;\n}\n\n/* Try to undo cwnd reduction, because D-SACKs acked all retransmitted data */\nstatic bool tcp_try_undo_dsack(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tp->undo_marker && !tp->undo_retrans) {\n\t\tDBGUNDO(sk, \"D-SACK\");\n\t\ttcp_undo_cwnd_reduction(sk, false);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKUNDO);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* Undo during loss recovery after partial ACK or using F-RTO. */\nstatic bool tcp_try_undo_loss(struct sock *sk, bool frto_undo)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (frto_undo || tcp_may_undo(tp)) {\n\t\ttcp_undo_cwnd_reduction(sk, true);\n\n\t\tDBGUNDO(sk, \"partial loss\");\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPLOSSUNDO);\n\t\tif (frto_undo)\n\t\t\tNET_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\t LINUX_MIB_TCPSPURIOUSRTOS);\n\t\tinet_csk(sk)->icsk_retransmits = 0;\n\t\tif (frto_undo || tcp_is_sack(tp))\n\t\t\ttcp_set_ca_state(sk, TCP_CA_Open);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* The cwnd reduction in CWR and Recovery uses the PRR algorithm in RFC 6937.\n * It computes the number of packets to send (sndcnt) based on packets newly\n * delivered:\n *   1) If the packets in flight is larger than ssthresh, PRR spreads the\n *\tcwnd reductions across a full RTT.\n *   2) Otherwise PRR uses packet conservation to send as much as delivered.\n *      But when the retransmits are acked without further losses, PRR\n *      slow starts cwnd up to ssthresh to speed up the recovery.\n */\nstatic void tcp_init_cwnd_reduction(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttp->high_seq = tp->snd_nxt;\n\ttp->tlp_high_seq = 0;\n\ttp->snd_cwnd_cnt = 0;\n\ttp->prior_cwnd = tp->snd_cwnd;\n\ttp->prr_delivered = 0;\n\ttp->prr_out = 0;\n\ttp->snd_ssthresh = inet_csk(sk)->icsk_ca_ops->ssthresh(sk);\n\ttcp_ecn_queue_cwr(tp);\n}\n\nstatic void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n\tint newly_acked_sacked = prior_unsacked -\n\t\t\t\t (tp->packets_out - tp->sacked_out);\n\n\ttp->prr_delivered += newly_acked_sacked;\n\tif (delta < 0) {\n\t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}\n\nstatic inline void tcp_end_cwnd_reduction(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Reset cwnd to ssthresh in CWR or Recovery (unless it's undone) */\n\tif (inet_csk(sk)->icsk_ca_state == TCP_CA_CWR ||\n\t    (tp->undo_marker && tp->snd_ssthresh < TCP_INFINITE_SSTHRESH)) {\n\t\ttp->snd_cwnd = tp->snd_ssthresh;\n\t\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\t}\n\ttcp_ca_event(sk, CA_EVENT_COMPLETE_CWR);\n}\n\n/* Enter CWR state. Disable cwnd undo since congestion is proven with ECN */\nvoid tcp_enter_cwr(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttp->prior_ssthresh = 0;\n\tif (inet_csk(sk)->icsk_ca_state < TCP_CA_CWR) {\n\t\ttp->undo_marker = 0;\n\t\ttcp_init_cwnd_reduction(sk);\n\t\ttcp_set_ca_state(sk, TCP_CA_CWR);\n\t}\n}\nEXPORT_SYMBOL(tcp_enter_cwr);\n\nstatic void tcp_try_keep_open(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint state = TCP_CA_Open;\n\n\tif (tcp_left_out(tp) || tcp_any_retrans_done(sk))\n\t\tstate = TCP_CA_Disorder;\n\n\tif (inet_csk(sk)->icsk_ca_state != state) {\n\t\ttcp_set_ca_state(sk, state);\n\t\ttp->high_seq = tp->snd_nxt;\n\t}\n}\n\nstatic void tcp_try_to_open(struct sock *sk, int flag, const int prior_unsacked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttcp_verify_left_out(tp);\n\n\tif (!tcp_any_retrans_done(sk))\n\t\ttp->retrans_stamp = 0;\n\n\tif (flag & FLAG_ECE)\n\t\ttcp_enter_cwr(sk);\n\n\tif (inet_csk(sk)->icsk_ca_state != TCP_CA_CWR) {\n\t\ttcp_try_keep_open(sk);\n\t} else {\n\t\ttcp_cwnd_reduction(sk, prior_unsacked, 0, flag);\n\t}\n}\n\nstatic void tcp_mtup_probe_failed(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ticsk->icsk_mtup.search_high = icsk->icsk_mtup.probe_size - 1;\n\ticsk->icsk_mtup.probe_size = 0;\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPMTUPFAIL);\n}\n\nstatic void tcp_mtup_probe_success(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\t/* FIXME: breaks with very large cwnd */\n\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\n\ttp->snd_cwnd = tp->snd_cwnd *\n\t\t       tcp_mss_to_mtu(sk, tp->mss_cache) /\n\t\t       icsk->icsk_mtup.probe_size;\n\ttp->snd_cwnd_cnt = 0;\n\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\ttp->snd_ssthresh = tcp_current_ssthresh(sk);\n\n\ticsk->icsk_mtup.search_low = icsk->icsk_mtup.probe_size;\n\ticsk->icsk_mtup.probe_size = 0;\n\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPMTUPSUCCESS);\n}\n\n/* Do a simple retransmit without using the backoff mechanisms in\n * tcp_timer. This is used for path mtu discovery.\n * The socket is already locked here.\n */\nvoid tcp_simple_retransmit(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned int mss = tcp_current_mss(sk);\n\tu32 prior_lost = tp->lost_out;\n\n\ttcp_for_write_queue(skb, sk) {\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\t\tif (tcp_skb_seglen(skb) > mss &&\n\t\t    !(TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED)) {\n\t\t\tif (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_RETRANS) {\n\t\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_RETRANS;\n\t\t\t\ttp->retrans_out -= tcp_skb_pcount(skb);\n\t\t\t}\n\t\t\ttcp_skb_mark_lost_uncond_verify(tp, skb);\n\t\t}\n\t}\n\n\ttcp_clear_retrans_hints_partial(tp);\n\n\tif (prior_lost == tp->lost_out)\n\t\treturn;\n\n\tif (tcp_is_reno(tp))\n\t\ttcp_limit_reno_sacked(tp);\n\n\ttcp_verify_left_out(tp);\n\n\t/* Don't muck with the congestion window here.\n\t * Reason is that we do not increase amount of _data_\n\t * in network, but units changed and effective\n\t * cwnd/ssthresh really reduced now.\n\t */\n\tif (icsk->icsk_ca_state != TCP_CA_Loss) {\n\t\ttp->high_seq = tp->snd_nxt;\n\t\ttp->snd_ssthresh = tcp_current_ssthresh(sk);\n\t\ttp->prior_ssthresh = 0;\n\t\ttp->undo_marker = 0;\n\t\ttcp_set_ca_state(sk, TCP_CA_Loss);\n\t}\n\ttcp_xmit_retransmit_queue(sk);\n}\nEXPORT_SYMBOL(tcp_simple_retransmit);\n\nstatic void tcp_enter_recovery(struct sock *sk, bool ece_ack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint mib_idx;\n\n\tif (tcp_is_reno(tp))\n\t\tmib_idx = LINUX_MIB_TCPRENORECOVERY;\n\telse\n\t\tmib_idx = LINUX_MIB_TCPSACKRECOVERY;\n\n\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\n\ttp->prior_ssthresh = 0;\n\ttcp_init_undo(tp);\n\n\tif (!tcp_in_cwnd_reduction(sk)) {\n\t\tif (!ece_ack)\n\t\t\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\n\t\ttcp_init_cwnd_reduction(sk);\n\t}\n\ttcp_set_ca_state(sk, TCP_CA_Recovery);\n}\n\n/* Process an ACK in CA_Loss state. Move to CA_Open if lost data are\n * recovered or spurious. Otherwise retransmits more on partial ACKs.\n */\nstatic void tcp_process_loss(struct sock *sk, int flag, bool is_dupack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tbool recovered = !before(tp->snd_una, tp->high_seq);\n\n\tif ((flag & FLAG_SND_UNA_ADVANCED) &&\n\t    tcp_try_undo_loss(sk, false))\n\t\treturn;\n\n\tif (tp->frto) { /* F-RTO RFC5682 sec 3.1 (sack enhanced version). */\n\t\t/* Step 3.b. A timeout is spurious if not all data are\n\t\t * lost, i.e., never-retransmitted data are (s)acked.\n\t\t */\n\t\tif ((flag & FLAG_ORIG_SACK_ACKED) &&\n\t\t    tcp_try_undo_loss(sk, true))\n\t\t\treturn;\n\n\t\tif (after(tp->snd_nxt, tp->high_seq)) {\n\t\t\tif (flag & FLAG_DATA_SACKED || is_dupack)\n\t\t\t\ttp->frto = 0; /* Step 3.a. loss was real */\n\t\t} else if (flag & FLAG_SND_UNA_ADVANCED && !recovered) {\n\t\t\ttp->high_seq = tp->snd_nxt;\n\t\t\t__tcp_push_pending_frames(sk, tcp_current_mss(sk),\n\t\t\t\t\t\t  TCP_NAGLE_OFF);\n\t\t\tif (after(tp->snd_nxt, tp->high_seq))\n\t\t\t\treturn; /* Step 2.b */\n\t\t\ttp->frto = 0;\n\t\t}\n\t}\n\n\tif (recovered) {\n\t\t/* F-RTO RFC5682 sec 3.1 step 2.a and 1st part of step 3.a */\n\t\ttcp_try_undo_recovery(sk);\n\t\treturn;\n\t}\n\tif (tcp_is_reno(tp)) {\n\t\t/* A Reno DUPACK means new data in F-RTO step 2.b above are\n\t\t * delivered. Lower inflight to clock out (re)tranmissions.\n\t\t */\n\t\tif (after(tp->snd_nxt, tp->high_seq) && is_dupack)\n\t\t\ttcp_add_reno_sack(sk);\n\t\telse if (flag & FLAG_SND_UNA_ADVANCED)\n\t\t\ttcp_reset_reno_sack(tp);\n\t}\n\ttcp_xmit_retransmit_queue(sk);\n}\n\n/* Undo during fast recovery after partial ACK. */\nstatic bool tcp_try_undo_partial(struct sock *sk, const int acked,\n\t\t\t\t const int prior_unsacked, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tp->undo_marker && tcp_packet_delayed(tp)) {\n\t\t/* Plain luck! Hole if filled with delayed\n\t\t * packet, rather than with a retransmit.\n\t\t */\n\t\ttcp_update_reordering(sk, tcp_fackets_out(tp) + acked, 1);\n\n\t\t/* We are getting evidence that the reordering degree is higher\n\t\t * than we realized. If there are no retransmits out then we\n\t\t * can undo. Otherwise we clock out new packets but do not\n\t\t * mark more packets lost or retransmit more.\n\t\t */\n\t\tif (tp->retrans_out) {\n\t\t\ttcp_cwnd_reduction(sk, prior_unsacked, 0, flag);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!tcp_any_retrans_done(sk))\n\t\t\ttp->retrans_stamp = 0;\n\n\t\tDBGUNDO(sk, \"partial recovery\");\n\t\ttcp_undo_cwnd_reduction(sk, true);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPPARTIALUNDO);\n\t\ttcp_try_keep_open(sk);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* Process an event, which can update packets-in-flight not trivially.\n * Main goal of this function is to calculate new estimate for left_out,\n * taking into account both packets sitting in receiver's buffer and\n * packets lost by network.\n *\n * Besides that it does CWND reduction, when packet loss is detected\n * and changes state of machine.\n *\n * It does _not_ decide what to send, it is made in function\n * tcp_xmit_retransmit_queue().\n */\nstatic void tcp_fastretrans_alert(struct sock *sk, const int acked,\n\t\t\t\t  const int prior_unsacked,\n\t\t\t\t  bool is_dupack, int flag)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tbool do_lost = is_dupack || ((flag & FLAG_DATA_SACKED) &&\n\t\t\t\t    (tcp_fackets_out(tp) > tp->reordering));\n\tint fast_rexmit = 0;\n\n\tif (WARN_ON(!tp->packets_out && tp->sacked_out))\n\t\ttp->sacked_out = 0;\n\tif (WARN_ON(!tp->sacked_out && tp->fackets_out))\n\t\ttp->fackets_out = 0;\n\n\t/* Now state machine starts.\n\t * A. ECE, hence prohibit cwnd undoing, the reduction is required. */\n\tif (flag & FLAG_ECE)\n\t\ttp->prior_ssthresh = 0;\n\n\t/* B. In all the states check for reneging SACKs. */\n\tif (tcp_check_sack_reneging(sk, flag))\n\t\treturn;\n\n\t/* C. Check consistency of the current state. */\n\ttcp_verify_left_out(tp);\n\n\t/* D. Check state exit conditions. State can be terminated\n\t *    when high_seq is ACKed. */\n\tif (icsk->icsk_ca_state == TCP_CA_Open) {\n\t\tWARN_ON(tp->retrans_out != 0);\n\t\ttp->retrans_stamp = 0;\n\t} else if (!before(tp->snd_una, tp->high_seq)) {\n\t\tswitch (icsk->icsk_ca_state) {\n\t\tcase TCP_CA_CWR:\n\t\t\t/* CWR is to be held something *above* high_seq\n\t\t\t * is ACKed for CWR bit to reach receiver. */\n\t\t\tif (tp->snd_una != tp->high_seq) {\n\t\t\t\ttcp_end_cwnd_reduction(sk);\n\t\t\t\ttcp_set_ca_state(sk, TCP_CA_Open);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TCP_CA_Recovery:\n\t\t\tif (tcp_is_reno(tp))\n\t\t\t\ttcp_reset_reno_sack(tp);\n\t\t\tif (tcp_try_undo_recovery(sk))\n\t\t\t\treturn;\n\t\t\ttcp_end_cwnd_reduction(sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Use RACK to detect loss */\n\tif (sysctl_tcp_recovery & TCP_RACK_LOST_RETRANS &&\n\t    tcp_rack_mark_lost(sk))\n\t\tflag |= FLAG_LOST_RETRANS;\n\n\t/* E. Process state. */\n\tswitch (icsk->icsk_ca_state) {\n\tcase TCP_CA_Recovery:\n\t\tif (!(flag & FLAG_SND_UNA_ADVANCED)) {\n\t\t\tif (tcp_is_reno(tp) && is_dupack)\n\t\t\t\ttcp_add_reno_sack(sk);\n\t\t} else {\n\t\t\tif (tcp_try_undo_partial(sk, acked, prior_unsacked, flag))\n\t\t\t\treturn;\n\t\t\t/* Partial ACK arrived. Force fast retransmit. */\n\t\t\tdo_lost = tcp_is_reno(tp) ||\n\t\t\t\t  tcp_fackets_out(tp) > tp->reordering;\n\t\t}\n\t\tif (tcp_try_undo_dsack(sk)) {\n\t\t\ttcp_try_keep_open(sk);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase TCP_CA_Loss:\n\t\ttcp_process_loss(sk, flag, is_dupack);\n\t\tif (icsk->icsk_ca_state != TCP_CA_Open &&\n\t\t    !(flag & FLAG_LOST_RETRANS))\n\t\t\treturn;\n\t\t/* Change state if cwnd is undone or retransmits are lost */\n\tdefault:\n\t\tif (tcp_is_reno(tp)) {\n\t\t\tif (flag & FLAG_SND_UNA_ADVANCED)\n\t\t\t\ttcp_reset_reno_sack(tp);\n\t\t\tif (is_dupack)\n\t\t\t\ttcp_add_reno_sack(sk);\n\t\t}\n\n\t\tif (icsk->icsk_ca_state <= TCP_CA_Disorder)\n\t\t\ttcp_try_undo_dsack(sk);\n\n\t\tif (!tcp_time_to_recover(sk, flag)) {\n\t\t\ttcp_try_to_open(sk, flag, prior_unsacked);\n\t\t\treturn;\n\t\t}\n\n\t\t/* MTU probe failure: don't reduce cwnd */\n\t\tif (icsk->icsk_ca_state < TCP_CA_CWR &&\n\t\t    icsk->icsk_mtup.probe_size &&\n\t\t    tp->snd_una == tp->mtu_probe.probe_seq_start) {\n\t\t\ttcp_mtup_probe_failed(sk);\n\t\t\t/* Restores the reduction we did in tcp_mtup_probe() */\n\t\t\ttp->snd_cwnd++;\n\t\t\ttcp_simple_retransmit(sk);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Otherwise enter Recovery state */\n\t\ttcp_enter_recovery(sk, (flag & FLAG_ECE));\n\t\tfast_rexmit = 1;\n\t}\n\n\tif (do_lost)\n\t\ttcp_update_scoreboard(sk, fast_rexmit);\n\ttcp_cwnd_reduction(sk, prior_unsacked, fast_rexmit, flag);\n\ttcp_xmit_retransmit_queue(sk);\n}\n\n/* Kathleen Nichols' algorithm for tracking the minimum value of\n * a data stream over some fixed time interval. (E.g., the minimum\n * RTT over the past five minutes.) It uses constant space and constant\n * time per update yet almost always delivers the same minimum as an\n * implementation that has to keep all the data in the window.\n *\n * The algorithm keeps track of the best, 2nd best & 3rd best min\n * values, maintaining an invariant that the measurement time of the\n * n'th best >= n-1'th best. It also makes sure that the three values\n * are widely separated in the time window since that bounds the worse\n * case error when that data is monotonically increasing over the window.\n *\n * Upon getting a new min, we can forget everything earlier because it\n * has no value - the new min is <= everything else in the window by\n * definition and it's the most recent. So we restart fresh on every new min\n * and overwrites 2nd & 3rd choices. The same property holds for 2nd & 3rd\n * best.\n */\nstatic void tcp_update_rtt_min(struct sock *sk, u32 rtt_us)\n{\n\tconst u32 now = tcp_time_stamp, wlen = sysctl_tcp_min_rtt_wlen * HZ;\n\tstruct rtt_meas *m = tcp_sk(sk)->rtt_min;\n\tstruct rtt_meas rttm = { .rtt = (rtt_us ? : 1), .ts = now };\n\tu32 elapsed;\n\n\t/* Check if the new measurement updates the 1st, 2nd, or 3rd choices */\n\tif (unlikely(rttm.rtt <= m[0].rtt))\n\t\tm[0] = m[1] = m[2] = rttm;\n\telse if (rttm.rtt <= m[1].rtt)\n\t\tm[1] = m[2] = rttm;\n\telse if (rttm.rtt <= m[2].rtt)\n\t\tm[2] = rttm;\n\n\telapsed = now - m[0].ts;\n\tif (unlikely(elapsed > wlen)) {\n\t\t/* Passed entire window without a new min so make 2nd choice\n\t\t * the new min & 3rd choice the new 2nd. So forth and so on.\n\t\t */\n\t\tm[0] = m[1];\n\t\tm[1] = m[2];\n\t\tm[2] = rttm;\n\t\tif (now - m[0].ts > wlen) {\n\t\t\tm[0] = m[1];\n\t\t\tm[1] = rttm;\n\t\t\tif (now - m[0].ts > wlen)\n\t\t\t\tm[0] = rttm;\n\t\t}\n\t} else if (m[1].ts == m[0].ts && elapsed > wlen / 4) {\n\t\t/* Passed a quarter of the window without a new min so\n\t\t * take 2nd choice from the 2nd quarter of the window.\n\t\t */\n\t\tm[2] = m[1] = rttm;\n\t} else if (m[2].ts == m[1].ts && elapsed > wlen / 2) {\n\t\t/* Passed half the window without a new min so take the 3rd\n\t\t * choice from the last half of the window.\n\t\t */\n\t\tm[2] = rttm;\n\t}\n}\n\nstatic inline bool tcp_ack_update_rtt(struct sock *sk, const int flag,\n\t\t\t\t      long seq_rtt_us, long sack_rtt_us,\n\t\t\t\t      long ca_rtt_us)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Prefer RTT measured from ACK's timing to TS-ECR. This is because\n\t * broken middle-boxes or peers may corrupt TS-ECR fields. But\n\t * Karn's algorithm forbids taking RTT if some retransmitted data\n\t * is acked (RFC6298).\n\t */\n\tif (seq_rtt_us < 0)\n\t\tseq_rtt_us = sack_rtt_us;\n\n\t/* RTTM Rule: A TSecr value received in a segment is used to\n\t * update the averaged RTT measurement only if the segment\n\t * acknowledges some new data, i.e., only if it advances the\n\t * left edge of the send window.\n\t * See draft-ietf-tcplw-high-performance-00, section 3.3.\n\t */\n\tif (seq_rtt_us < 0 && tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\n\t    flag & FLAG_ACKED)\n\t\tseq_rtt_us = ca_rtt_us = jiffies_to_usecs(tcp_time_stamp -\n\t\t\t\t\t\t\t  tp->rx_opt.rcv_tsecr);\n\tif (seq_rtt_us < 0)\n\t\treturn false;\n\n\t/* ca_rtt_us >= 0 is counting on the invariant that ca_rtt_us is\n\t * always taken together with ACK, SACK, or TS-opts. Any negative\n\t * values will be skipped with the seq_rtt_us < 0 check above.\n\t */\n\ttcp_update_rtt_min(sk, ca_rtt_us);\n\ttcp_rtt_estimator(sk, seq_rtt_us);\n\ttcp_set_rto(sk);\n\n\t/* RFC6298: only reset backoff on valid RTT measurement. */\n\tinet_csk(sk)->icsk_backoff = 0;\n\treturn true;\n}\n\n/* Compute time elapsed between (last) SYNACK and the ACK completing 3WHS. */\nvoid tcp_synack_rtt_meas(struct sock *sk, struct request_sock *req)\n{\n\tlong rtt_us = -1L;\n\n\tif (req && !req->num_retrans && tcp_rsk(req)->snt_synack.v64) {\n\t\tstruct skb_mstamp now;\n\n\t\tskb_mstamp_get(&now);\n\t\trtt_us = skb_mstamp_us_delta(&now, &tcp_rsk(req)->snt_synack);\n\t}\n\n\ttcp_ack_update_rtt(sk, FLAG_SYN_ACKED, rtt_us, -1L, rtt_us);\n}\n\n\nstatic void tcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\ticsk->icsk_ca_ops->cong_avoid(sk, ack, acked);\n\ttcp_sk(sk)->snd_cwnd_stamp = tcp_time_stamp;\n}\n\n/* Restart timer after forward progress on connection.\n * RFC2988 recommends to restart timer to now+rto.\n */\nvoid tcp_rearm_rto(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* If the retrans timer is currently being used by Fast Open\n\t * for SYN-ACK retrans purpose, stay put.\n\t */\n\tif (tp->fastopen_rsk)\n\t\treturn;\n\n\tif (!tp->packets_out) {\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);\n\t} else {\n\t\tu32 rto = inet_csk(sk)->icsk_rto;\n\t\t/* Offset the time elapsed after installing regular RTO */\n\t\tif (icsk->icsk_pending == ICSK_TIME_EARLY_RETRANS ||\n\t\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\n\t\t\tstruct sk_buff *skb = tcp_write_queue_head(sk);\n\t\t\tconst u32 rto_time_stamp =\n\t\t\t\ttcp_skb_timestamp(skb) + rto;\n\t\t\ts32 delta = (s32)(rto_time_stamp - tcp_time_stamp);\n\t\t\t/* delta may not be positive if the socket is locked\n\t\t\t * when the retrans timer fires and is rescheduled.\n\t\t\t */\n\t\t\tif (delta > 0)\n\t\t\t\trto = delta;\n\t\t}\n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, rto,\n\t\t\t\t\t  TCP_RTO_MAX);\n\t}\n}\n\n/* This function is called when the delayed ER timer fires. TCP enters\n * fast recovery and performs fast-retransmit.\n */\nvoid tcp_resume_early_retransmit(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttcp_rearm_rto(sk);\n\n\t/* Stop if ER is disabled after the delayed ER timer is scheduled */\n\tif (!tp->do_early_retrans)\n\t\treturn;\n\n\ttcp_enter_recovery(sk, false);\n\ttcp_update_scoreboard(sk, 1);\n\ttcp_xmit_retransmit_queue(sk);\n}\n\n/* If we get here, the whole TSO packet has not been acked. */\nstatic u32 tcp_tso_acked(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 packets_acked;\n\n\tBUG_ON(!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una));\n\n\tpackets_acked = tcp_skb_pcount(skb);\n\tif (tcp_trim_head(sk, skb, tp->snd_una - TCP_SKB_CB(skb)->seq))\n\t\treturn 0;\n\tpackets_acked -= tcp_skb_pcount(skb);\n\n\tif (packets_acked) {\n\t\tBUG_ON(tcp_skb_pcount(skb) == 0);\n\t\tBUG_ON(!before(TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq));\n\t}\n\n\treturn packets_acked;\n}\n\nstatic void tcp_ack_tstamp(struct sock *sk, struct sk_buff *skb,\n\t\t\t   u32 prior_snd_una)\n{\n\tconst struct skb_shared_info *shinfo;\n\n\t/* Avoid cache line misses to get skb_shinfo() and shinfo->tx_flags */\n\tif (likely(!(sk->sk_tsflags & SOF_TIMESTAMPING_TX_ACK)))\n\t\treturn;\n\n\tshinfo = skb_shinfo(skb);\n\tif ((shinfo->tx_flags & SKBTX_ACK_TSTAMP) &&\n\t    between(shinfo->tskey, prior_snd_una, tcp_sk(sk)->snd_una - 1))\n\t\t__skb_tstamp_tx(skb, NULL, sk, SCM_TSTAMP_ACK);\n}\n\n/* Remove acknowledged frames from the retransmission queue. If our packet\n * is before the ack sequence we can discard it as it's confirmed to have\n * arrived at the other end.\n */\nstatic int tcp_clean_rtx_queue(struct sock *sk, int prior_fackets,\n\t\t\t       u32 prior_snd_una,\n\t\t\t       struct tcp_sacktag_state *sack)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct skb_mstamp first_ackt, last_ackt, now;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 prior_sacked = tp->sacked_out;\n\tu32 reord = tp->packets_out;\n\tbool fully_acked = true;\n\tlong sack_rtt_us = -1L;\n\tlong seq_rtt_us = -1L;\n\tlong ca_rtt_us = -1L;\n\tstruct sk_buff *skb;\n\tu32 pkts_acked = 0;\n\tbool rtt_update;\n\tint flag = 0;\n\n\tfirst_ackt.v64 = 0;\n\n\twhile ((skb = tcp_write_queue_head(sk)) && skb != tcp_send_head(sk)) {\n\t\tstruct tcp_skb_cb *scb = TCP_SKB_CB(skb);\n\t\tu8 sacked = scb->sacked;\n\t\tu32 acked_pcount;\n\n\t\ttcp_ack_tstamp(sk, skb, prior_snd_una);\n\n\t\t/* Determine how many packets and what bytes were acked, tso and else */\n\t\tif (after(scb->end_seq, tp->snd_una)) {\n\t\t\tif (tcp_skb_pcount(skb) == 1 ||\n\t\t\t    !after(tp->snd_una, scb->seq))\n\t\t\t\tbreak;\n\n\t\t\tacked_pcount = tcp_tso_acked(sk, skb);\n\t\t\tif (!acked_pcount)\n\t\t\t\tbreak;\n\n\t\t\tfully_acked = false;\n\t\t} else {\n\t\t\t/* Speedup tcp_unlink_write_queue() and next loop */\n\t\t\tprefetchw(skb->next);\n\t\t\tacked_pcount = tcp_skb_pcount(skb);\n\t\t}\n\n\t\tif (unlikely(sacked & TCPCB_RETRANS)) {\n\t\t\tif (sacked & TCPCB_SACKED_RETRANS)\n\t\t\t\ttp->retrans_out -= acked_pcount;\n\t\t\tflag |= FLAG_RETRANS_DATA_ACKED;\n\t\t} else if (!(sacked & TCPCB_SACKED_ACKED)) {\n\t\t\tlast_ackt = skb->skb_mstamp;\n\t\t\tWARN_ON_ONCE(last_ackt.v64 == 0);\n\t\t\tif (!first_ackt.v64)\n\t\t\t\tfirst_ackt = last_ackt;\n\n\t\t\treord = min(pkts_acked, reord);\n\t\t\tif (!after(scb->end_seq, tp->high_seq))\n\t\t\t\tflag |= FLAG_ORIG_SACK_ACKED;\n\t\t}\n\n\t\tif (sacked & TCPCB_SACKED_ACKED)\n\t\t\ttp->sacked_out -= acked_pcount;\n\t\telse if (tcp_is_sack(tp) && !tcp_skb_spurious_retrans(tp, skb))\n\t\t\ttcp_rack_advance(tp, &skb->skb_mstamp, sacked);\n\t\tif (sacked & TCPCB_LOST)\n\t\t\ttp->lost_out -= acked_pcount;\n\n\t\ttp->packets_out -= acked_pcount;\n\t\tpkts_acked += acked_pcount;\n\n\t\t/* Initial outgoing SYN's get put onto the write_queue\n\t\t * just like anything else we transmit.  It is not\n\t\t * true data, and if we misinform our callers that\n\t\t * this ACK acks real data, we will erroneously exit\n\t\t * connection startup slow start one packet too\n\t\t * quickly.  This is severely frowned upon behavior.\n\t\t */\n\t\tif (likely(!(scb->tcp_flags & TCPHDR_SYN))) {\n\t\t\tflag |= FLAG_DATA_ACKED;\n\t\t} else {\n\t\t\tflag |= FLAG_SYN_ACKED;\n\t\t\ttp->retrans_stamp = 0;\n\t\t}\n\n\t\tif (!fully_acked)\n\t\t\tbreak;\n\n\t\ttcp_unlink_write_queue(skb, sk);\n\t\tsk_wmem_free_skb(sk, skb);\n\t\tif (unlikely(skb == tp->retransmit_skb_hint))\n\t\t\ttp->retransmit_skb_hint = NULL;\n\t\tif (unlikely(skb == tp->lost_skb_hint))\n\t\t\ttp->lost_skb_hint = NULL;\n\t}\n\n\tif (likely(between(tp->snd_up, prior_snd_una, tp->snd_una)))\n\t\ttp->snd_up = tp->snd_una;\n\n\tif (skb && (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED))\n\t\tflag |= FLAG_SACK_RENEGING;\n\n\tskb_mstamp_get(&now);\n\tif (likely(first_ackt.v64) && !(flag & FLAG_RETRANS_DATA_ACKED)) {\n\t\tseq_rtt_us = skb_mstamp_us_delta(&now, &first_ackt);\n\t\tca_rtt_us = skb_mstamp_us_delta(&now, &last_ackt);\n\t}\n\tif (sack->first_sackt.v64) {\n\t\tsack_rtt_us = skb_mstamp_us_delta(&now, &sack->first_sackt);\n\t\tca_rtt_us = skb_mstamp_us_delta(&now, &sack->last_sackt);\n\t}\n\n\trtt_update = tcp_ack_update_rtt(sk, flag, seq_rtt_us, sack_rtt_us,\n\t\t\t\t\tca_rtt_us);\n\n\tif (flag & FLAG_ACKED) {\n\t\ttcp_rearm_rto(sk);\n\t\tif (unlikely(icsk->icsk_mtup.probe_size &&\n\t\t\t     !after(tp->mtu_probe.probe_seq_end, tp->snd_una))) {\n\t\t\ttcp_mtup_probe_success(sk);\n\t\t}\n\n\t\tif (tcp_is_reno(tp)) {\n\t\t\ttcp_remove_reno_sacks(sk, pkts_acked);\n\t\t} else {\n\t\t\tint delta;\n\n\t\t\t/* Non-retransmitted hole got filled? That's reordering */\n\t\t\tif (reord < prior_fackets)\n\t\t\t\ttcp_update_reordering(sk, tp->fackets_out - reord, 0);\n\n\t\t\tdelta = tcp_is_fack(tp) ? pkts_acked :\n\t\t\t\t\t\t  prior_sacked - tp->sacked_out;\n\t\t\ttp->lost_cnt_hint -= min(tp->lost_cnt_hint, delta);\n\t\t}\n\n\t\ttp->fackets_out -= min(pkts_acked, tp->fackets_out);\n\n\t} else if (skb && rtt_update && sack_rtt_us >= 0 &&\n\t\t   sack_rtt_us > skb_mstamp_us_delta(&now, &skb->skb_mstamp)) {\n\t\t/* Do not re-arm RTO if the sack RTT is measured from data sent\n\t\t * after when the head was last (re)transmitted. Otherwise the\n\t\t * timeout may continue to extend in loss recovery.\n\t\t */\n\t\ttcp_rearm_rto(sk);\n\t}\n\n\tif (icsk->icsk_ca_ops->pkts_acked)\n\t\ticsk->icsk_ca_ops->pkts_acked(sk, pkts_acked, ca_rtt_us);\n\n#if FASTRETRANS_DEBUG > 0\n\tWARN_ON((int)tp->sacked_out < 0);\n\tWARN_ON((int)tp->lost_out < 0);\n\tWARN_ON((int)tp->retrans_out < 0);\n\tif (!tp->packets_out && tcp_is_sack(tp)) {\n\t\ticsk = inet_csk(sk);\n\t\tif (tp->lost_out) {\n\t\t\tpr_debug(\"Leak l=%u %d\\n\",\n\t\t\t\t tp->lost_out, icsk->icsk_ca_state);\n\t\t\ttp->lost_out = 0;\n\t\t}\n\t\tif (tp->sacked_out) {\n\t\t\tpr_debug(\"Leak s=%u %d\\n\",\n\t\t\t\t tp->sacked_out, icsk->icsk_ca_state);\n\t\t\ttp->sacked_out = 0;\n\t\t}\n\t\tif (tp->retrans_out) {\n\t\t\tpr_debug(\"Leak r=%u %d\\n\",\n\t\t\t\t tp->retrans_out, icsk->icsk_ca_state);\n\t\t\ttp->retrans_out = 0;\n\t\t}\n\t}\n#endif\n\treturn flag;\n}\n\nstatic void tcp_ack_probe(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\t/* Was it a usable window open? */\n\n\tif (!after(TCP_SKB_CB(tcp_send_head(sk))->end_seq, tcp_wnd_end(tp))) {\n\t\ticsk->icsk_backoff = 0;\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_PROBE0);\n\t\t/* Socket must be waked up by subsequent tcp_data_snd_check().\n\t\t * This function is not for random using!\n\t\t */\n\t} else {\n\t\tunsigned long when = tcp_probe0_when(sk, TCP_RTO_MAX);\n\n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_PROBE0,\n\t\t\t\t\t  when, TCP_RTO_MAX);\n\t}\n}\n\nstatic inline bool tcp_ack_is_dubious(const struct sock *sk, const int flag)\n{\n\treturn !(flag & FLAG_NOT_DUP) || (flag & FLAG_CA_ALERT) ||\n\t\tinet_csk(sk)->icsk_ca_state != TCP_CA_Open;\n}\n\n/* Decide wheather to run the increase function of congestion control. */\nstatic inline bool tcp_may_raise_cwnd(const struct sock *sk, const int flag)\n{\n\tif (tcp_in_cwnd_reduction(sk))\n\t\treturn false;\n\n\t/* If reordering is high then always grow cwnd whenever data is\n\t * delivered regardless of its ordering. Otherwise stay conservative\n\t * and only grow cwnd on in-order delivery (RFC5681). A stretched ACK w/\n\t * new SACK or ECE mark may first advance cwnd here and later reduce\n\t * cwnd in tcp_fastretrans_alert() based on more states.\n\t */\n\tif (tcp_sk(sk)->reordering > sysctl_tcp_reordering)\n\t\treturn flag & FLAG_FORWARD_PROGRESS;\n\n\treturn flag & FLAG_DATA_ACKED;\n}\n\n/* Check that window update is acceptable.\n * The function assumes that snd_una<=ack<=snd_next.\n */\nstatic inline bool tcp_may_update_window(const struct tcp_sock *tp,\n\t\t\t\t\tconst u32 ack, const u32 ack_seq,\n\t\t\t\t\tconst u32 nwin)\n{\n\treturn\tafter(ack, tp->snd_una) ||\n\t\tafter(ack_seq, tp->snd_wl1) ||\n\t\t(ack_seq == tp->snd_wl1 && nwin > tp->snd_wnd);\n}\n\n/* If we update tp->snd_una, also update tp->bytes_acked */\nstatic void tcp_snd_una_update(struct tcp_sock *tp, u32 ack)\n{\n\tu32 delta = ack - tp->snd_una;\n\n\tu64_stats_update_begin(&tp->syncp);\n\ttp->bytes_acked += delta;\n\tu64_stats_update_end(&tp->syncp);\n\ttp->snd_una = ack;\n}\n\n/* If we update tp->rcv_nxt, also update tp->bytes_received */\nstatic void tcp_rcv_nxt_update(struct tcp_sock *tp, u32 seq)\n{\n\tu32 delta = seq - tp->rcv_nxt;\n\n\tu64_stats_update_begin(&tp->syncp);\n\ttp->bytes_received += delta;\n\tu64_stats_update_end(&tp->syncp);\n\ttp->rcv_nxt = seq;\n}\n\n/* Update our send window.\n *\n * Window update algorithm, described in RFC793/RFC1122 (used in linux-2.2\n * and in FreeBSD. NetBSD's one is even worse.) is wrong.\n */\nstatic int tcp_ack_update_window(struct sock *sk, const struct sk_buff *skb, u32 ack,\n\t\t\t\t u32 ack_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint flag = 0;\n\tu32 nwin = ntohs(tcp_hdr(skb)->window);\n\n\tif (likely(!tcp_hdr(skb)->syn))\n\t\tnwin <<= tp->rx_opt.snd_wscale;\n\n\tif (tcp_may_update_window(tp, ack, ack_seq, nwin)) {\n\t\tflag |= FLAG_WIN_UPDATE;\n\t\ttcp_update_wl(tp, ack_seq);\n\n\t\tif (tp->snd_wnd != nwin) {\n\t\t\ttp->snd_wnd = nwin;\n\n\t\t\t/* Note, it is the only place, where\n\t\t\t * fast path is recovered for sending TCP.\n\t\t\t */\n\t\t\ttp->pred_flags = 0;\n\t\t\ttcp_fast_path_check(sk);\n\n\t\t\tif (tcp_send_head(sk))\n\t\t\t\ttcp_slow_start_after_idle_check(sk);\n\n\t\t\tif (nwin > tp->max_window) {\n\t\t\t\ttp->max_window = nwin;\n\t\t\t\ttcp_sync_mss(sk, inet_csk(sk)->icsk_pmtu_cookie);\n\t\t\t}\n\t\t}\n\t}\n\n\ttcp_snd_una_update(tp, ack);\n\n\treturn flag;\n}\n\n/* Return true if we're currently rate-limiting out-of-window ACKs and\n * thus shouldn't send a dupack right now. We rate-limit dupacks in\n * response to out-of-window SYNs or ACKs to mitigate ACK loops or DoS\n * attacks that send repeated SYNs or ACKs for the same connection. To\n * do this, we do not send a duplicate SYNACK or ACK if the remote\n * endpoint is sending out-of-window SYNs or pure ACKs at a high rate.\n */\nbool tcp_oow_rate_limited(struct net *net, const struct sk_buff *skb,\n\t\t\t  int mib_idx, u32 *last_oow_ack_time)\n{\n\t/* Data packets without SYNs are not likely part of an ACK loop. */\n\tif ((TCP_SKB_CB(skb)->seq != TCP_SKB_CB(skb)->end_seq) &&\n\t    !tcp_hdr(skb)->syn)\n\t\tgoto not_rate_limited;\n\n\tif (*last_oow_ack_time) {\n\t\ts32 elapsed = (s32)(tcp_time_stamp - *last_oow_ack_time);\n\n\t\tif (0 <= elapsed && elapsed < sysctl_tcp_invalid_ratelimit) {\n\t\t\tNET_INC_STATS_BH(net, mib_idx);\n\t\t\treturn true;\t/* rate-limited: don't send yet! */\n\t\t}\n\t}\n\n\t*last_oow_ack_time = tcp_time_stamp;\n\nnot_rate_limited:\n\treturn false;\t/* not rate-limited: go ahead, send dupack now! */\n}\n\n/* RFC 5961 7 [ACK Throttling] */\nstatic void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\t/* unprotected vars, we dont care of overwrites */\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\n\t/* First check our per-socket dupack rate limit. */\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\n\t/* Then check the check host-wide RFC 5961 rate limit. */\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}\n\nstatic void tcp_store_ts_recent(struct tcp_sock *tp)\n{\n\ttp->rx_opt.ts_recent = tp->rx_opt.rcv_tsval;\n\ttp->rx_opt.ts_recent_stamp = get_seconds();\n}\n\nstatic void tcp_replace_ts_recent(struct tcp_sock *tp, u32 seq)\n{\n\tif (tp->rx_opt.saw_tstamp && !after(seq, tp->rcv_wup)) {\n\t\t/* PAWS bug workaround wrt. ACK frames, the PAWS discard\n\t\t * extra check below makes sure this can only happen\n\t\t * for pure ACK frames.  -DaveM\n\t\t *\n\t\t * Not only, also it occurs for expired timestamps.\n\t\t */\n\n\t\tif (tcp_paws_check(&tp->rx_opt, 0))\n\t\t\ttcp_store_ts_recent(tp);\n\t}\n}\n\n/* This routine deals with acks during a TLP episode.\n * We mark the end of a TLP episode on receiving TLP dupack or when\n * ack is after tlp_high_seq.\n * Ref: loss detection algorithm in draft-dukkipati-tcpm-tcp-loss-probe.\n */\nstatic void tcp_process_tlp_ack(struct sock *sk, u32 ack, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (before(ack, tp->tlp_high_seq))\n\t\treturn;\n\n\tif (flag & FLAG_DSACKING_ACK) {\n\t\t/* This DSACK means original and TLP probe arrived; no loss */\n\t\ttp->tlp_high_seq = 0;\n\t} else if (after(ack, tp->tlp_high_seq)) {\n\t\t/* ACK advances: there was a loss, so reduce cwnd. Reset\n\t\t * tlp_high_seq in tcp_init_cwnd_reduction()\n\t\t */\n\t\ttcp_init_cwnd_reduction(sk);\n\t\ttcp_set_ca_state(sk, TCP_CA_CWR);\n\t\ttcp_end_cwnd_reduction(sk);\n\t\ttcp_try_keep_open(sk);\n\t\tNET_INC_STATS_BH(sock_net(sk),\n\t\t\t\t LINUX_MIB_TCPLOSSPROBERECOVERY);\n\t} else if (!(flag & (FLAG_SND_UNA_ADVANCED |\n\t\t\t     FLAG_NOT_DUP | FLAG_DATA_SACKED))) {\n\t\t/* Pure dupack: original and TLP probe arrived; no loss */\n\t\ttp->tlp_high_seq = 0;\n\t}\n}\n\nstatic inline void tcp_in_ack_event(struct sock *sk, u32 flags)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_ops->in_ack_event)\n\t\ticsk->icsk_ca_ops->in_ack_event(sk, flags);\n}\n\n/* This routine deals with incoming acks, but not outgoing ones. */\nstatic int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_sacktag_state sack_state;\n\tu32 prior_snd_una = tp->snd_una;\n\tu32 ack_seq = TCP_SKB_CB(skb)->seq;\n\tu32 ack = TCP_SKB_CB(skb)->ack_seq;\n\tbool is_dupack = false;\n\tu32 prior_fackets;\n\tint prior_packets = tp->packets_out;\n\tconst int prior_unsacked = tp->packets_out - tp->sacked_out;\n\tint acked = 0; /* Number of packets newly acked */\n\n\tsack_state.first_sackt.v64 = 0;\n\n\t/* We very likely will need to access write queue head. */\n\tprefetchw(sk->sk_write_queue.next);\n\n\t/* If the ack is older than previous acks\n\t * then we can probably ignore it.\n\t */\n\tif (before(ack, prior_snd_una)) {\n\t\t/* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */\n\t\tif (before(ack, prior_snd_una - tp->max_window)) {\n\t\t\ttcp_send_challenge_ack(sk, skb);\n\t\t\treturn -1;\n\t\t}\n\t\tgoto old_ack;\n\t}\n\n\t/* If the ack includes data we haven't sent yet, discard\n\t * this segment (RFC793 Section 3.9).\n\t */\n\tif (after(ack, tp->snd_nxt))\n\t\tgoto invalid_ack;\n\n\tif (icsk->icsk_pending == ICSK_TIME_EARLY_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE)\n\t\ttcp_rearm_rto(sk);\n\n\tif (after(ack, prior_snd_una)) {\n\t\tflag |= FLAG_SND_UNA_ADVANCED;\n\t\ticsk->icsk_retransmits = 0;\n\t}\n\n\tprior_fackets = tp->fackets_out;\n\n\t/* ts_recent update must be made after we are sure that the packet\n\t * is in window.\n\t */\n\tif (flag & FLAG_UPDATE_TS_RECENT)\n\t\ttcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq);\n\n\tif (!(flag & FLAG_SLOWPATH) && after(ack, prior_snd_una)) {\n\t\t/* Window is constant, pure forward advance.\n\t\t * No more checks are required.\n\t\t * Note, we use the fact that SND.UNA>=SND.WL2.\n\t\t */\n\t\ttcp_update_wl(tp, ack_seq);\n\t\ttcp_snd_una_update(tp, ack);\n\t\tflag |= FLAG_WIN_UPDATE;\n\n\t\ttcp_in_ack_event(sk, CA_ACK_WIN_UPDATE);\n\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPHPACKS);\n\t} else {\n\t\tu32 ack_ev_flags = CA_ACK_SLOWPATH;\n\n\t\tif (ack_seq != TCP_SKB_CB(skb)->end_seq)\n\t\t\tflag |= FLAG_DATA;\n\t\telse\n\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPPUREACKS);\n\n\t\tflag |= tcp_ack_update_window(sk, skb, ack, ack_seq);\n\n\t\tif (TCP_SKB_CB(skb)->sacked)\n\t\t\tflag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,\n\t\t\t\t\t\t\t&sack_state);\n\n\t\tif (tcp_ecn_rcv_ecn_echo(tp, tcp_hdr(skb))) {\n\t\t\tflag |= FLAG_ECE;\n\t\t\tack_ev_flags |= CA_ACK_ECE;\n\t\t}\n\n\t\tif (flag & FLAG_WIN_UPDATE)\n\t\t\tack_ev_flags |= CA_ACK_WIN_UPDATE;\n\n\t\ttcp_in_ack_event(sk, ack_ev_flags);\n\t}\n\n\t/* We passed data and got it acked, remove any soft error\n\t * log. Something worked...\n\t */\n\tsk->sk_err_soft = 0;\n\ticsk->icsk_probes_out = 0;\n\ttp->rcv_tstamp = tcp_time_stamp;\n\tif (!prior_packets)\n\t\tgoto no_queue;\n\n\t/* See if we can take anything off of the retransmit queue. */\n\tacked = tp->packets_out;\n\tflag |= tcp_clean_rtx_queue(sk, prior_fackets, prior_snd_una,\n\t\t\t\t    &sack_state);\n\tacked -= tp->packets_out;\n\n\tif (tcp_ack_is_dubious(sk, flag)) {\n\t\tis_dupack = !(flag & (FLAG_SND_UNA_ADVANCED | FLAG_NOT_DUP));\n\t\ttcp_fastretrans_alert(sk, acked, prior_unsacked,\n\t\t\t\t      is_dupack, flag);\n\t}\n\tif (tp->tlp_high_seq)\n\t\ttcp_process_tlp_ack(sk, ack, flag);\n\n\t/* Advance cwnd if state allows */\n\tif (tcp_may_raise_cwnd(sk, flag))\n\t\ttcp_cong_avoid(sk, ack, acked);\n\n\tif ((flag & FLAG_FORWARD_PROGRESS) || !(flag & FLAG_NOT_DUP)) {\n\t\tstruct dst_entry *dst = __sk_dst_get(sk);\n\t\tif (dst)\n\t\t\tdst_confirm(dst);\n\t}\n\n\tif (icsk->icsk_pending == ICSK_TIME_RETRANS)\n\t\ttcp_schedule_loss_probe(sk);\n\ttcp_update_pacing_rate(sk);\n\treturn 1;\n\nno_queue:\n\t/* If data was DSACKed, see if we can undo a cwnd reduction. */\n\tif (flag & FLAG_DSACKING_ACK)\n\t\ttcp_fastretrans_alert(sk, acked, prior_unsacked,\n\t\t\t\t      is_dupack, flag);\n\t/* If this ack opens up a zero window, clear backoff.  It was\n\t * being used to time the probes, and is probably far higher than\n\t * it needs to be for normal retransmission.\n\t */\n\tif (tcp_send_head(sk))\n\t\ttcp_ack_probe(sk);\n\n\tif (tp->tlp_high_seq)\n\t\ttcp_process_tlp_ack(sk, ack, flag);\n\treturn 1;\n\ninvalid_ack:\n\tSOCK_DEBUG(sk, \"Ack %u after %u:%u\\n\", ack, tp->snd_una, tp->snd_nxt);\n\treturn -1;\n\nold_ack:\n\t/* If data was SACKed, tag it and see if we should send more data.\n\t * If data was DSACKed, see if we can undo a cwnd reduction.\n\t */\n\tif (TCP_SKB_CB(skb)->sacked) {\n\t\tflag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,\n\t\t\t\t\t\t&sack_state);\n\t\ttcp_fastretrans_alert(sk, acked, prior_unsacked,\n\t\t\t\t      is_dupack, flag);\n\t}\n\n\tSOCK_DEBUG(sk, \"Ack %u before %u:%u\\n\", ack, tp->snd_una, tp->snd_nxt);\n\treturn 0;\n}\n\nstatic void tcp_parse_fastopen_option(int len, const unsigned char *cookie,\n\t\t\t\t      bool syn, struct tcp_fastopen_cookie *foc,\n\t\t\t\t      bool exp_opt)\n{\n\t/* Valid only in SYN or SYN-ACK with an even length.  */\n\tif (!foc || !syn || len < 0 || (len & 1))\n\t\treturn;\n\n\tif (len >= TCP_FASTOPEN_COOKIE_MIN &&\n\t    len <= TCP_FASTOPEN_COOKIE_MAX)\n\t\tmemcpy(foc->val, cookie, len);\n\telse if (len != 0)\n\t\tlen = -1;\n\tfoc->len = len;\n\tfoc->exp = exp_opt;\n}\n\n/* Look for tcp options. Normally only called on SYN and SYNACK packets.\n * But, this can also be called on packets in the established flow when\n * the fast version below fails.\n */\nvoid tcp_parse_options(const struct sk_buff *skb,\n\t\t       struct tcp_options_received *opt_rx, int estab,\n\t\t       struct tcp_fastopen_cookie *foc)\n{\n\tconst unsigned char *ptr;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tint length = (th->doff * 4) - sizeof(struct tcphdr);\n\n\tptr = (const unsigned char *)(th + 1);\n\topt_rx->saw_tstamp = 0;\n\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn;\n\t\tcase TCPOPT_NOP:\t/* Ref: RFC 793 section 3.1 */\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2) /* \"silly options\" */\n\t\t\t\treturn;\n\t\t\tif (opsize > length)\n\t\t\t\treturn;\t/* don't parse partial options */\n\t\t\tswitch (opcode) {\n\t\t\tcase TCPOPT_MSS:\n\t\t\t\tif (opsize == TCPOLEN_MSS && th->syn && !estab) {\n\t\t\t\t\tu16 in_mss = get_unaligned_be16(ptr);\n\t\t\t\t\tif (in_mss) {\n\t\t\t\t\t\tif (opt_rx->user_mss &&\n\t\t\t\t\t\t    opt_rx->user_mss < in_mss)\n\t\t\t\t\t\t\tin_mss = opt_rx->user_mss;\n\t\t\t\t\t\topt_rx->mss_clamp = in_mss;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TCPOPT_WINDOW:\n\t\t\t\tif (opsize == TCPOLEN_WINDOW && th->syn &&\n\t\t\t\t    !estab && sysctl_tcp_window_scaling) {\n\t\t\t\t\t__u8 snd_wscale = *(__u8 *)ptr;\n\t\t\t\t\topt_rx->wscale_ok = 1;\n\t\t\t\t\tif (snd_wscale > 14) {\n\t\t\t\t\t\tnet_info_ratelimited(\"%s: Illegal window scaling value %d >14 received\\n\",\n\t\t\t\t\t\t\t\t     __func__,\n\t\t\t\t\t\t\t\t     snd_wscale);\n\t\t\t\t\t\tsnd_wscale = 14;\n\t\t\t\t\t}\n\t\t\t\t\topt_rx->snd_wscale = snd_wscale;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TCPOPT_TIMESTAMP:\n\t\t\t\tif ((opsize == TCPOLEN_TIMESTAMP) &&\n\t\t\t\t    ((estab && opt_rx->tstamp_ok) ||\n\t\t\t\t     (!estab && sysctl_tcp_timestamps))) {\n\t\t\t\t\topt_rx->saw_tstamp = 1;\n\t\t\t\t\topt_rx->rcv_tsval = get_unaligned_be32(ptr);\n\t\t\t\t\topt_rx->rcv_tsecr = get_unaligned_be32(ptr + 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TCPOPT_SACK_PERM:\n\t\t\t\tif (opsize == TCPOLEN_SACK_PERM && th->syn &&\n\t\t\t\t    !estab && sysctl_tcp_sack) {\n\t\t\t\t\topt_rx->sack_ok = TCP_SACK_SEEN;\n\t\t\t\t\ttcp_sack_reset(opt_rx);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TCPOPT_SACK:\n\t\t\t\tif ((opsize >= (TCPOLEN_SACK_BASE + TCPOLEN_SACK_PERBLOCK)) &&\n\t\t\t\t   !((opsize - TCPOLEN_SACK_BASE) % TCPOLEN_SACK_PERBLOCK) &&\n\t\t\t\t   opt_rx->sack_ok) {\n\t\t\t\t\tTCP_SKB_CB(skb)->sacked = (ptr - 2) - (unsigned char *)th;\n\t\t\t\t}\n\t\t\t\tbreak;\n#ifdef CONFIG_TCP_MD5SIG\n\t\t\tcase TCPOPT_MD5SIG:\n\t\t\t\t/*\n\t\t\t\t * The MD5 Hash has already been\n\t\t\t\t * checked (see tcp_v{4,6}_do_rcv()).\n\t\t\t\t */\n\t\t\t\tbreak;\n#endif\n\t\t\tcase TCPOPT_FASTOPEN:\n\t\t\t\ttcp_parse_fastopen_option(\n\t\t\t\t\topsize - TCPOLEN_FASTOPEN_BASE,\n\t\t\t\t\tptr, th->syn, foc, false);\n\t\t\t\tbreak;\n\n\t\t\tcase TCPOPT_EXP:\n\t\t\t\t/* Fast Open option shares code 254 using a\n\t\t\t\t * 16 bits magic number.\n\t\t\t\t */\n\t\t\t\tif (opsize >= TCPOLEN_EXP_FASTOPEN_BASE &&\n\t\t\t\t    get_unaligned_be16(ptr) ==\n\t\t\t\t    TCPOPT_FASTOPEN_MAGIC)\n\t\t\t\t\ttcp_parse_fastopen_option(opsize -\n\t\t\t\t\t\tTCPOLEN_EXP_FASTOPEN_BASE,\n\t\t\t\t\t\tptr + 2, th->syn, foc, true);\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tptr += opsize-2;\n\t\t\tlength -= opsize;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(tcp_parse_options);\n\nstatic bool tcp_parse_aligned_timestamp(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tconst __be32 *ptr = (const __be32 *)(th + 1);\n\n\tif (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)\n\t\t\t  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {\n\t\ttp->rx_opt.saw_tstamp = 1;\n\t\t++ptr;\n\t\ttp->rx_opt.rcv_tsval = ntohl(*ptr);\n\t\t++ptr;\n\t\tif (*ptr)\n\t\t\ttp->rx_opt.rcv_tsecr = ntohl(*ptr) - tp->tsoffset;\n\t\telse\n\t\t\ttp->rx_opt.rcv_tsecr = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* Fast parse options. This hopes to only see timestamps.\n * If it is wrong it falls back on tcp_parse_options().\n */\nstatic bool tcp_fast_parse_options(const struct sk_buff *skb,\n\t\t\t\t   const struct tcphdr *th, struct tcp_sock *tp)\n{\n\t/* In the spirit of fast parsing, compare doff directly to constant\n\t * values.  Because equality is used, short doff can be ignored here.\n\t */\n\tif (th->doff == (sizeof(*th) / 4)) {\n\t\ttp->rx_opt.saw_tstamp = 0;\n\t\treturn false;\n\t} else if (tp->rx_opt.tstamp_ok &&\n\t\t   th->doff == ((sizeof(*th) + TCPOLEN_TSTAMP_ALIGNED) / 4)) {\n\t\tif (tcp_parse_aligned_timestamp(tp, th))\n\t\t\treturn true;\n\t}\n\n\ttcp_parse_options(skb, &tp->rx_opt, 1, NULL);\n\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)\n\t\ttp->rx_opt.rcv_tsecr -= tp->tsoffset;\n\n\treturn true;\n}\n\n#ifdef CONFIG_TCP_MD5SIG\n/*\n * Parse MD5 Signature option\n */\nconst u8 *tcp_parse_md5sig_option(const struct tcphdr *th)\n{\n\tint length = (th->doff << 2) - sizeof(*th);\n\tconst u8 *ptr = (const u8 *)(th + 1);\n\n\t/* If the TCP option is too short, we can short cut */\n\tif (length < TCPOLEN_MD5SIG)\n\t\treturn NULL;\n\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn NULL;\n\t\tcase TCPOPT_NOP:\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2 || opsize > length)\n\t\t\t\treturn NULL;\n\t\t\tif (opcode == TCPOPT_MD5SIG)\n\t\t\t\treturn opsize == TCPOLEN_MD5SIG ? ptr : NULL;\n\t\t}\n\t\tptr += opsize - 2;\n\t\tlength -= opsize;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(tcp_parse_md5sig_option);\n#endif\n\n/* Sorry, PAWS as specified is broken wrt. pure-ACKs -DaveM\n *\n * It is not fatal. If this ACK does _not_ change critical state (seqs, window)\n * it can pass through stack. So, the following predicate verifies that\n * this segment is not used for anything but congestion avoidance or\n * fast retransmit. Moreover, we even are able to eliminate most of such\n * second order effects, if we apply some small \"replay\" window (~RTO)\n * to timestamp space.\n *\n * All these measures still do not guarantee that we reject wrapped ACKs\n * on networks with high bandwidth, when sequence space is recycled fastly,\n * but it guarantees that such events will be very rare and do not affect\n * connection seriously. This doesn't look nice, but alas, PAWS is really\n * buggy extension.\n *\n * [ Later note. Even worse! It is buggy for segments _with_ data. RFC\n * states that events when retransmit arrives after original data are rare.\n * It is a blatant lie. VJ forgot about fast retransmit! 8)8) It is\n * the biggest problem on large power networks even with minor reordering.\n * OK, let's give it small replay window. If peer clock is even 1hz, it is safe\n * up to bandwidth of 18Gigabit/sec. 8) ]\n */\n\nstatic int tcp_disordered_ack(const struct sock *sk, const struct sk_buff *skb)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tu32 seq = TCP_SKB_CB(skb)->seq;\n\tu32 ack = TCP_SKB_CB(skb)->ack_seq;\n\n\treturn (/* 1. Pure ACK with correct sequence number. */\n\t\t(th->ack && seq == TCP_SKB_CB(skb)->end_seq && seq == tp->rcv_nxt) &&\n\n\t\t/* 2. ... and duplicate ACK. */\n\t\tack == tp->snd_una &&\n\n\t\t/* 3. ... and does not update window. */\n\t\t!tcp_may_update_window(tp, ack, seq, ntohs(th->window) << tp->rx_opt.snd_wscale) &&\n\n\t\t/* 4. ... and sits in replay window. */\n\t\t(s32)(tp->rx_opt.ts_recent - tp->rx_opt.rcv_tsval) <= (inet_csk(sk)->icsk_rto * 1024) / HZ);\n}\n\nstatic inline bool tcp_paws_discard(const struct sock *sk,\n\t\t\t\t   const struct sk_buff *skb)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\treturn !tcp_paws_check(&tp->rx_opt, TCP_PAWS_WINDOW) &&\n\t       !tcp_disordered_ack(sk, skb);\n}\n\n/* Check segment sequence number for validity.\n *\n * Segment controls are considered valid, if the segment\n * fits to the window after truncation to the window. Acceptability\n * of data (and SYN, FIN, of course) is checked separately.\n * See tcp_data_queue(), for example.\n *\n * Also, controls (RST is main one) are accepted using RCV.WUP instead\n * of RCV.NXT. Peer still did not advance his SND.UNA when we\n * delayed ACK, so that hisSND.UNA<=ourRCV.WUP.\n * (borrowed from freebsd)\n */\n\nstatic inline bool tcp_sequence(const struct tcp_sock *tp, u32 seq, u32 end_seq)\n{\n\treturn\t!before(end_seq, tp->rcv_wup) &&\n\t\t!after(seq, tp->rcv_nxt + tcp_receive_window(tp));\n}\n\n/* When we get a reset we do this. */\nvoid tcp_reset(struct sock *sk)\n{\n\t/* We want the right error as BSD sees it (and indeed as we do). */\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\t\tsk->sk_err = ECONNREFUSED;\n\t\tbreak;\n\tcase TCP_CLOSE_WAIT:\n\t\tsk->sk_err = EPIPE;\n\t\tbreak;\n\tcase TCP_CLOSE:\n\t\treturn;\n\tdefault:\n\t\tsk->sk_err = ECONNRESET;\n\t}\n\t/* This barrier is coupled with smp_rmb() in tcp_poll() */\n\tsmp_wmb();\n\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_error_report(sk);\n\n\ttcp_done(sk);\n}\n\n/*\n * \tProcess the FIN bit. This now behaves as it is supposed to work\n *\tand the FIN takes effect when it is validly part of sequence\n *\tspace. Not before when we get holes.\n *\n *\tIf we are ESTABLISHED, a received fin moves us to CLOSE-WAIT\n *\t(and thence onto LAST-ACK and finally, CLOSE, we never enter\n *\tTIME-WAIT)\n *\n *\tIf we are in FINWAIT-1, a received FIN indicates simultaneous\n *\tclose and we go into CLOSING (and later onto TIME-WAIT)\n *\n *\tIf we are in FINWAIT-2, a received FIN moves us to TIME-WAIT.\n */\nstatic void tcp_fin(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tinet_csk_schedule_ack(sk);\n\n\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\tsock_set_flag(sk, SOCK_DONE);\n\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_RECV:\n\tcase TCP_ESTABLISHED:\n\t\t/* Move to CLOSE_WAIT */\n\t\ttcp_set_state(sk, TCP_CLOSE_WAIT);\n\t\tinet_csk(sk)->icsk_ack.pingpong = 1;\n\t\tbreak;\n\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSING:\n\t\t/* Received a retransmission of the FIN, do\n\t\t * nothing.\n\t\t */\n\t\tbreak;\n\tcase TCP_LAST_ACK:\n\t\t/* RFC793: Remain in the LAST-ACK state. */\n\t\tbreak;\n\n\tcase TCP_FIN_WAIT1:\n\t\t/* This case occurs when a simultaneous close\n\t\t * happens, we must ack the received FIN and\n\t\t * enter the CLOSING state.\n\t\t */\n\t\ttcp_send_ack(sk);\n\t\ttcp_set_state(sk, TCP_CLOSING);\n\t\tbreak;\n\tcase TCP_FIN_WAIT2:\n\t\t/* Received a FIN -- send ACK and enter TIME_WAIT. */\n\t\ttcp_send_ack(sk);\n\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\n\t\tbreak;\n\tdefault:\n\t\t/* Only TCP_LISTEN and TCP_CLOSE are left, in these\n\t\t * cases we should never reach this piece of code.\n\t\t */\n\t\tpr_err(\"%s: Impossible, sk->sk_state=%d\\n\",\n\t\t       __func__, sk->sk_state);\n\t\tbreak;\n\t}\n\n\t/* It _is_ possible, that we have something out-of-order _after_ FIN.\n\t * Probably, we should reset in this case. For now drop them.\n\t */\n\t__skb_queue_purge(&tp->out_of_order_queue);\n\tif (tcp_is_sack(tp))\n\t\ttcp_sack_reset(&tp->rx_opt);\n\tsk_mem_reclaim(sk);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\n\t\t/* Do not send POLL_HUP for half duplex close. */\n\t\tif (sk->sk_shutdown == SHUTDOWN_MASK ||\n\t\t    sk->sk_state == TCP_CLOSE)\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t\telse\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\t}\n}\n\nstatic inline bool tcp_sack_extend(struct tcp_sack_block *sp, u32 seq,\n\t\t\t\t  u32 end_seq)\n{\n\tif (!after(seq, sp->end_seq) && !after(sp->start_seq, end_seq)) {\n\t\tif (before(seq, sp->start_seq))\n\t\t\tsp->start_seq = seq;\n\t\tif (after(end_seq, sp->end_seq))\n\t\t\tsp->end_seq = end_seq;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void tcp_dsack_set(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_is_sack(tp) && sysctl_tcp_dsack) {\n\t\tint mib_idx;\n\n\t\tif (before(seq, tp->rcv_nxt))\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOLDSENT;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOFOSENT;\n\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\n\t\ttp->rx_opt.dsack = 1;\n\t\ttp->duplicate_sack[0].start_seq = seq;\n\t\ttp->duplicate_sack[0].end_seq = end_seq;\n\t}\n}\n\nstatic void tcp_dsack_extend(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (!tp->rx_opt.dsack)\n\t\ttcp_dsack_set(sk, seq, end_seq);\n\telse\n\t\ttcp_sack_extend(tp->duplicate_sack, seq, end_seq);\n}\n\nstatic void tcp_send_dupack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t    before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);\n\t\ttcp_enter_quickack_mode(sk);\n\n\t\tif (tcp_is_sack(tp) && sysctl_tcp_dsack) {\n\t\t\tu32 end_seq = TCP_SKB_CB(skb)->end_seq;\n\n\t\t\tif (after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt))\n\t\t\t\tend_seq = tp->rcv_nxt;\n\t\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, end_seq);\n\t\t}\n\t}\n\n\ttcp_send_ack(sk);\n}\n\n/* These routines update the SACK block as out-of-order packets arrive or\n * in-order packets close up the sequence space.\n */\nstatic void tcp_sack_maybe_coalesce(struct tcp_sock *tp)\n{\n\tint this_sack;\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\n\tstruct tcp_sack_block *swalk = sp + 1;\n\n\t/* See if the recent change to the first SACK eats into\n\t * or hits the sequence space of other SACK blocks, if so coalesce.\n\t */\n\tfor (this_sack = 1; this_sack < tp->rx_opt.num_sacks;) {\n\t\tif (tcp_sack_extend(sp, swalk->start_seq, swalk->end_seq)) {\n\t\t\tint i;\n\n\t\t\t/* Zap SWALK, by moving every further SACK up by one slot.\n\t\t\t * Decrease num_sacks.\n\t\t\t */\n\t\t\ttp->rx_opt.num_sacks--;\n\t\t\tfor (i = this_sack; i < tp->rx_opt.num_sacks; i++)\n\t\t\t\tsp[i] = sp[i + 1];\n\t\t\tcontinue;\n\t\t}\n\t\tthis_sack++, swalk++;\n\t}\n}\n\nstatic void tcp_sack_new_ofo_skb(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\n\tint cur_sacks = tp->rx_opt.num_sacks;\n\tint this_sack;\n\n\tif (!cur_sacks)\n\t\tgoto new_sack;\n\n\tfor (this_sack = 0; this_sack < cur_sacks; this_sack++, sp++) {\n\t\tif (tcp_sack_extend(sp, seq, end_seq)) {\n\t\t\t/* Rotate this_sack to the first one. */\n\t\t\tfor (; this_sack > 0; this_sack--, sp--)\n\t\t\t\tswap(*sp, *(sp - 1));\n\t\t\tif (cur_sacks > 1)\n\t\t\t\ttcp_sack_maybe_coalesce(tp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Could not find an adjacent existing SACK, build a new one,\n\t * put it at the front, and shift everyone else down.  We\n\t * always know there is at least one SACK present already here.\n\t *\n\t * If the sack array is full, forget about the last one.\n\t */\n\tif (this_sack >= TCP_NUM_SACKS) {\n\t\tthis_sack--;\n\t\ttp->rx_opt.num_sacks--;\n\t\tsp--;\n\t}\n\tfor (; this_sack > 0; this_sack--, sp--)\n\t\t*sp = *(sp - 1);\n\nnew_sack:\n\t/* Build the new head SACK, and we're done. */\n\tsp->start_seq = seq;\n\tsp->end_seq = end_seq;\n\ttp->rx_opt.num_sacks++;\n}\n\n/* RCV.NXT advances, some SACKs should be eaten. */\n\nstatic void tcp_sack_remove(struct tcp_sock *tp)\n{\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\n\tint num_sacks = tp->rx_opt.num_sacks;\n\tint this_sack;\n\n\t/* Empty ofo queue, hence, all the SACKs are eaten. Clear. */\n\tif (skb_queue_empty(&tp->out_of_order_queue)) {\n\t\ttp->rx_opt.num_sacks = 0;\n\t\treturn;\n\t}\n\n\tfor (this_sack = 0; this_sack < num_sacks;) {\n\t\t/* Check if the start of the sack is covered by RCV.NXT. */\n\t\tif (!before(tp->rcv_nxt, sp->start_seq)) {\n\t\t\tint i;\n\n\t\t\t/* RCV.NXT must cover all the block! */\n\t\t\tWARN_ON(before(tp->rcv_nxt, sp->end_seq));\n\n\t\t\t/* Zap this SACK, by moving forward any other SACKS. */\n\t\t\tfor (i = this_sack+1; i < num_sacks; i++)\n\t\t\t\ttp->selective_acks[i-1] = tp->selective_acks[i];\n\t\t\tnum_sacks--;\n\t\t\tcontinue;\n\t\t}\n\t\tthis_sack++;\n\t\tsp++;\n\t}\n\ttp->rx_opt.num_sacks = num_sacks;\n}\n\n/**\n * tcp_try_coalesce - try to merge skb to prior one\n * @sk: socket\n * @to: prior buffer\n * @from: buffer to add in queue\n * @fragstolen: pointer to boolean\n *\n * Before queueing skb @from after @to, try to merge them\n * to reduce overall memory use and queue lengths, if cost is small.\n * Packets in ofo or receive queues can stay a long time.\n * Better try to coalesce them right now to avoid future collapses.\n * Returns true if caller should free @from instead of queueing it\n */\nstatic bool tcp_try_coalesce(struct sock *sk,\n\t\t\t     struct sk_buff *to,\n\t\t\t     struct sk_buff *from,\n\t\t\t     bool *fragstolen)\n{\n\tint delta;\n\n\t*fragstolen = false;\n\n\t/* Its possible this segment overlaps with prior segment in queue */\n\tif (TCP_SKB_CB(from)->seq != TCP_SKB_CB(to)->end_seq)\n\t\treturn false;\n\n\tif (!skb_try_coalesce(to, from, fragstolen, &delta))\n\t\treturn false;\n\n\tatomic_add(delta, &sk->sk_rmem_alloc);\n\tsk_mem_charge(sk, delta);\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPRCVCOALESCE);\n\tTCP_SKB_CB(to)->end_seq = TCP_SKB_CB(from)->end_seq;\n\tTCP_SKB_CB(to)->ack_seq = TCP_SKB_CB(from)->ack_seq;\n\tTCP_SKB_CB(to)->tcp_flags |= TCP_SKB_CB(from)->tcp_flags;\n\treturn true;\n}\n\n/* This one checks to see if we can put data from the\n * out_of_order queue into the receive_queue.\n */\nstatic void tcp_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t__u32 dsack_high = tp->rcv_nxt;\n\tstruct sk_buff *skb, *tail;\n\tbool fragstolen, eaten;\n\n\twhile ((skb = skb_peek(&tp->out_of_order_queue)) != NULL) {\n\t\tif (after(TCP_SKB_CB(skb)->seq, tp->rcv_nxt))\n\t\t\tbreak;\n\n\t\tif (before(TCP_SKB_CB(skb)->seq, dsack_high)) {\n\t\t\t__u32 dsack = dsack_high;\n\t\t\tif (before(TCP_SKB_CB(skb)->end_seq, dsack_high))\n\t\t\t\tdsack_high = TCP_SKB_CB(skb)->end_seq;\n\t\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb)->seq, dsack);\n\t\t}\n\n\t\t__skb_unlink(skb, &tp->out_of_order_queue);\n\t\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt)) {\n\t\t\tSOCK_DEBUG(sk, \"ofo packet was already received\\n\");\n\t\t\t__kfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tSOCK_DEBUG(sk, \"ofo requeuing : rcv_next %X seq %X - %X\\n\",\n\t\t\t   tp->rcv_nxt, TCP_SKB_CB(skb)->seq,\n\t\t\t   TCP_SKB_CB(skb)->end_seq);\n\n\t\ttail = skb_peek_tail(&sk->sk_receive_queue);\n\t\teaten = tail && tcp_try_coalesce(sk, tail, skb, &fragstolen);\n\t\ttcp_rcv_nxt_update(tp, TCP_SKB_CB(skb)->end_seq);\n\t\tif (!eaten)\n\t\t\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\t\ttcp_fin(sk);\n\t\tif (eaten)\n\t\t\tkfree_skb_partial(skb, fragstolen);\n\t}\n}\n\nstatic bool tcp_prune_ofo_queue(struct sock *sk);\nstatic int tcp_prune_queue(struct sock *sk);\n\nstatic int tcp_try_rmem_schedule(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t unsigned int size)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf ||\n\t    !sk_rmem_schedule(sk, skb, size)) {\n\n\t\tif (tcp_prune_queue(sk) < 0)\n\t\t\treturn -1;\n\n\t\tif (!sk_rmem_schedule(sk, skb, size)) {\n\t\t\tif (!tcp_prune_ofo_queue(sk))\n\t\t\t\treturn -1;\n\n\t\t\tif (!sk_rmem_schedule(sk, skb, size))\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void tcp_data_queue_ofo(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb1;\n\tu32 seq, end_seq;\n\n\ttcp_ecn_check_ce(tp, skb);\n\n\tif (unlikely(tcp_try_rmem_schedule(sk, skb, skb->truesize))) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPOFODROP);\n\t\t__kfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* Disable header prediction. */\n\ttp->pred_flags = 0;\n\tinet_csk_schedule_ack(sk);\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPOFOQUEUE);\n\tSOCK_DEBUG(sk, \"out of order segment: rcv_next %X seq %X - %X\\n\",\n\t\t   tp->rcv_nxt, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);\n\n\tskb1 = skb_peek_tail(&tp->out_of_order_queue);\n\tif (!skb1) {\n\t\t/* Initial out of order segment, build 1 SACK. */\n\t\tif (tcp_is_sack(tp)) {\n\t\t\ttp->rx_opt.num_sacks = 1;\n\t\t\ttp->selective_acks[0].start_seq = TCP_SKB_CB(skb)->seq;\n\t\t\ttp->selective_acks[0].end_seq =\n\t\t\t\t\t\tTCP_SKB_CB(skb)->end_seq;\n\t\t}\n\t\t__skb_queue_head(&tp->out_of_order_queue, skb);\n\t\tgoto end;\n\t}\n\n\tseq = TCP_SKB_CB(skb)->seq;\n\tend_seq = TCP_SKB_CB(skb)->end_seq;\n\n\tif (seq == TCP_SKB_CB(skb1)->end_seq) {\n\t\tbool fragstolen;\n\n\t\tif (!tcp_try_coalesce(sk, skb1, skb, &fragstolen)) {\n\t\t\t__skb_queue_after(&tp->out_of_order_queue, skb1, skb);\n\t\t} else {\n\t\t\ttcp_grow_window(sk, skb);\n\t\t\tkfree_skb_partial(skb, fragstolen);\n\t\t\tskb = NULL;\n\t\t}\n\n\t\tif (!tp->rx_opt.num_sacks ||\n\t\t    tp->selective_acks[0].end_seq != seq)\n\t\t\tgoto add_sack;\n\n\t\t/* Common case: data arrive in order after hole. */\n\t\ttp->selective_acks[0].end_seq = end_seq;\n\t\tgoto end;\n\t}\n\n\t/* Find place to insert this segment. */\n\twhile (1) {\n\t\tif (!after(TCP_SKB_CB(skb1)->seq, seq))\n\t\t\tbreak;\n\t\tif (skb_queue_is_first(&tp->out_of_order_queue, skb1)) {\n\t\t\tskb1 = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tskb1 = skb_queue_prev(&tp->out_of_order_queue, skb1);\n\t}\n\n\t/* Do skb overlap to previous one? */\n\tif (skb1 && before(seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\t/* All the bits are present. Drop. */\n\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPOFOMERGE);\n\t\t\t__kfree_skb(skb);\n\t\t\tskb = NULL;\n\t\t\ttcp_dsack_set(sk, seq, end_seq);\n\t\t\tgoto add_sack;\n\t\t}\n\t\tif (after(seq, TCP_SKB_CB(skb1)->seq)) {\n\t\t\t/* Partial overlap. */\n\t\t\ttcp_dsack_set(sk, seq,\n\t\t\t\t      TCP_SKB_CB(skb1)->end_seq);\n\t\t} else {\n\t\t\tif (skb_queue_is_first(&tp->out_of_order_queue,\n\t\t\t\t\t       skb1))\n\t\t\t\tskb1 = NULL;\n\t\t\telse\n\t\t\t\tskb1 = skb_queue_prev(\n\t\t\t\t\t&tp->out_of_order_queue,\n\t\t\t\t\tskb1);\n\t\t}\n\t}\n\tif (!skb1)\n\t\t__skb_queue_head(&tp->out_of_order_queue, skb);\n\telse\n\t\t__skb_queue_after(&tp->out_of_order_queue, skb1, skb);\n\n\t/* And clean segments covered by new one as whole. */\n\twhile (!skb_queue_is_last(&tp->out_of_order_queue, skb)) {\n\t\tskb1 = skb_queue_next(&tp->out_of_order_queue, skb);\n\n\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->seq))\n\t\t\tbreak;\n\t\tif (before(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\n\t\t\t\t\t end_seq);\n\t\t\tbreak;\n\t\t}\n\t\t__skb_unlink(skb1, &tp->out_of_order_queue);\n\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\n\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPOFOMERGE);\n\t\t__kfree_skb(skb1);\n\t}\n\nadd_sack:\n\tif (tcp_is_sack(tp))\n\t\ttcp_sack_new_ofo_skb(sk, seq, end_seq);\nend:\n\tif (skb) {\n\t\ttcp_grow_window(sk, skb);\n\t\tskb_set_owner_r(skb, sk);\n\t}\n}\n\nstatic int __must_check tcp_queue_rcv(struct sock *sk, struct sk_buff *skb, int hdrlen,\n\t\t  bool *fragstolen)\n{\n\tint eaten;\n\tstruct sk_buff *tail = skb_peek_tail(&sk->sk_receive_queue);\n\n\t__skb_pull(skb, hdrlen);\n\teaten = (tail &&\n\t\t tcp_try_coalesce(sk, tail, skb, fragstolen)) ? 1 : 0;\n\ttcp_rcv_nxt_update(tcp_sk(sk), TCP_SKB_CB(skb)->end_seq);\n\tif (!eaten) {\n\t\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tskb_set_owner_r(skb, sk);\n\t}\n\treturn eaten;\n}\n\nint tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\tint data_len = 0;\n\tbool fragstolen;\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tif (size > PAGE_SIZE) {\n\t\tint npages = min_t(size_t, size >> PAGE_SHIFT, MAX_SKB_FRAGS);\n\n\t\tdata_len = npages << PAGE_SHIFT;\n\t\tsize = data_len + (size & ~PAGE_MASK);\n\t}\n\tskb = alloc_skb_with_frags(size - data_len, data_len,\n\t\t\t\t   PAGE_ALLOC_COSTLY_ORDER,\n\t\t\t\t   &err, sk->sk_allocation);\n\tif (!skb)\n\t\tgoto err;\n\n\tskb_put(skb, size - data_len);\n\tskb->data_len = data_len;\n\tskb->len = size;\n\n\tif (tcp_try_rmem_schedule(sk, skb, skb->truesize))\n\t\tgoto err_free;\n\n\terr = skb_copy_datagram_from_iter(skb, 0, &msg->msg_iter, size);\n\tif (err)\n\t\tgoto err_free;\n\n\tTCP_SKB_CB(skb)->seq = tcp_sk(sk)->rcv_nxt;\n\tTCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + size;\n\tTCP_SKB_CB(skb)->ack_seq = tcp_sk(sk)->snd_una - 1;\n\n\tif (tcp_queue_rcv(sk, skb, 0, &fragstolen)) {\n\t\tWARN_ON_ONCE(fragstolen); /* should not happen */\n\t\t__kfree_skb(skb);\n\t}\n\treturn size;\n\nerr_free:\n\tkfree_skb(skb);\nerr:\n\treturn err;\n\n}\n\nstatic void tcp_data_queue(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint eaten = -1;\n\tbool fragstolen = false;\n\n\tif (TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq)\n\t\tgoto drop;\n\n\tskb_dst_drop(skb);\n\t__skb_pull(skb, tcp_hdr(skb)->doff * 4);\n\n\ttcp_ecn_accept_cwr(tp, skb);\n\n\ttp->rx_opt.dsack = 0;\n\n\t/*  Queue data for delivery to the user.\n\t *  Packets in sequence go to the receive queue.\n\t *  Out of sequence packets to the out_of_order_queue.\n\t */\n\tif (TCP_SKB_CB(skb)->seq == tp->rcv_nxt) {\n\t\tif (tcp_receive_window(tp) == 0)\n\t\t\tgoto out_of_window;\n\n\t\t/* Ok. In sequence. In window. */\n\t\tif (tp->ucopy.task == current &&\n\t\t    tp->copied_seq == tp->rcv_nxt && tp->ucopy.len &&\n\t\t    sock_owned_by_user(sk) && !tp->urg_data) {\n\t\t\tint chunk = min_t(unsigned int, skb->len,\n\t\t\t\t\t  tp->ucopy.len);\n\n\t\t\t__set_current_state(TASK_RUNNING);\n\n\t\t\tlocal_bh_enable();\n\t\t\tif (!skb_copy_datagram_msg(skb, 0, tp->ucopy.msg, chunk)) {\n\t\t\t\ttp->ucopy.len -= chunk;\n\t\t\t\ttp->copied_seq += chunk;\n\t\t\t\teaten = (chunk == skb->len);\n\t\t\t\ttcp_rcv_space_adjust(sk);\n\t\t\t}\n\t\t\tlocal_bh_disable();\n\t\t}\n\n\t\tif (eaten <= 0) {\nqueue_and_out:\n\t\t\tif (eaten < 0) {\n\t\t\t\tif (skb_queue_len(&sk->sk_receive_queue) == 0)\n\t\t\t\t\tsk_forced_mem_schedule(sk, skb->truesize);\n\t\t\t\telse if (tcp_try_rmem_schedule(sk, skb, skb->truesize))\n\t\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\teaten = tcp_queue_rcv(sk, skb, 0, &fragstolen);\n\t\t}\n\t\ttcp_rcv_nxt_update(tp, TCP_SKB_CB(skb)->end_seq);\n\t\tif (skb->len)\n\t\t\ttcp_event_data_recv(sk, skb);\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\t\ttcp_fin(sk);\n\n\t\tif (!skb_queue_empty(&tp->out_of_order_queue)) {\n\t\t\ttcp_ofo_queue(sk);\n\n\t\t\t/* RFC2581. 4.2. SHOULD send immediate ACK, when\n\t\t\t * gap in queue is filled.\n\t\t\t */\n\t\t\tif (skb_queue_empty(&tp->out_of_order_queue))\n\t\t\t\tinet_csk(sk)->icsk_ack.pingpong = 0;\n\t\t}\n\n\t\tif (tp->rx_opt.num_sacks)\n\t\t\ttcp_sack_remove(tp);\n\n\t\ttcp_fast_path_check(sk);\n\n\t\tif (eaten > 0)\n\t\t\tkfree_skb_partial(skb, fragstolen);\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_data_ready(sk);\n\t\treturn;\n\t}\n\n\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt)) {\n\t\t/* A retransmit, 2nd most common case.  Force an immediate ack. */\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);\n\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);\n\nout_of_window:\n\t\ttcp_enter_quickack_mode(sk);\n\t\tinet_csk_schedule_ack(sk);\ndrop:\n\t\t__kfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* Out of window. F.e. zero window probe. */\n\tif (!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt + tcp_receive_window(tp)))\n\t\tgoto out_of_window;\n\n\ttcp_enter_quickack_mode(sk);\n\n\tif (before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\n\t\t/* Partial packet, seq < rcv_next < end_seq */\n\t\tSOCK_DEBUG(sk, \"partial packet: rcv_next %X seq %X - %X\\n\",\n\t\t\t   tp->rcv_nxt, TCP_SKB_CB(skb)->seq,\n\t\t\t   TCP_SKB_CB(skb)->end_seq);\n\n\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, tp->rcv_nxt);\n\n\t\t/* If window is closed, drop tail of packet. But after\n\t\t * remembering D-SACK for its head made in previous line.\n\t\t */\n\t\tif (!tcp_receive_window(tp))\n\t\t\tgoto out_of_window;\n\t\tgoto queue_and_out;\n\t}\n\n\ttcp_data_queue_ofo(sk, skb);\n}\n\nstatic struct sk_buff *tcp_collapse_one(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\tstruct sk_buff_head *list)\n{\n\tstruct sk_buff *next = NULL;\n\n\tif (!skb_queue_is_last(list, skb))\n\t\tnext = skb_queue_next(list, skb);\n\n\t__skb_unlink(skb, list);\n\t__kfree_skb(skb);\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPRCVCOLLAPSED);\n\n\treturn next;\n}\n\n/* Collapse contiguous sequence of skbs head..tail with\n * sequence numbers start..end.\n *\n * If tail is NULL, this means until the end of the list.\n *\n * Segments with FIN/SYN are not collapsed (only because this\n * simplifies code)\n */\nstatic void\ntcp_collapse(struct sock *sk, struct sk_buff_head *list,\n\t     struct sk_buff *head, struct sk_buff *tail,\n\t     u32 start, u32 end)\n{\n\tstruct sk_buff *skb, *n;\n\tbool end_of_skbs;\n\n\t/* First, check that queue is collapsible and find\n\t * the point where collapsing can be useful. */\n\tskb = head;\nrestart:\n\tend_of_skbs = true;\n\tskb_queue_walk_from_safe(list, skb, n) {\n\t\tif (skb == tail)\n\t\t\tbreak;\n\t\t/* No new bits? It is possible on ofo queue. */\n\t\tif (!before(start, TCP_SKB_CB(skb)->end_seq)) {\n\t\t\tskb = tcp_collapse_one(sk, skb, list);\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/* The first skb to collapse is:\n\t\t * - not SYN/FIN and\n\t\t * - bloated or contains data before \"start\" or\n\t\t *   overlaps to the next one.\n\t\t */\n\t\tif (!(TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)) &&\n\t\t    (tcp_win_from_space(skb->truesize) > skb->len ||\n\t\t     before(TCP_SKB_CB(skb)->seq, start))) {\n\t\t\tend_of_skbs = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!skb_queue_is_last(list, skb)) {\n\t\t\tstruct sk_buff *next = skb_queue_next(list, skb);\n\t\t\tif (next != tail &&\n\t\t\t    TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(next)->seq) {\n\t\t\t\tend_of_skbs = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Decided to skip this, advance start seq. */\n\t\tstart = TCP_SKB_CB(skb)->end_seq;\n\t}\n\tif (end_of_skbs ||\n\t    (TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)))\n\t\treturn;\n\n\twhile (before(start, end)) {\n\t\tint copy = min_t(int, SKB_MAX_ORDER(0, 0), end - start);\n\t\tstruct sk_buff *nskb;\n\n\t\tnskb = alloc_skb(copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\treturn;\n\n\t\tmemcpy(nskb->cb, skb->cb, sizeof(skb->cb));\n\t\tTCP_SKB_CB(nskb)->seq = TCP_SKB_CB(nskb)->end_seq = start;\n\t\t__skb_queue_before(list, skb, nskb);\n\t\tskb_set_owner_r(nskb, sk);\n\n\t\t/* Copy data, releasing collapsed skbs. */\n\t\twhile (copy > 0) {\n\t\t\tint offset = start - TCP_SKB_CB(skb)->seq;\n\t\t\tint size = TCP_SKB_CB(skb)->end_seq - start;\n\n\t\t\tBUG_ON(offset < 0);\n\t\t\tif (size > 0) {\n\t\t\t\tsize = min(copy, size);\n\t\t\t\tif (skb_copy_bits(skb, offset, skb_put(nskb, size), size))\n\t\t\t\t\tBUG();\n\t\t\t\tTCP_SKB_CB(nskb)->end_seq += size;\n\t\t\t\tcopy -= size;\n\t\t\t\tstart += size;\n\t\t\t}\n\t\t\tif (!before(start, TCP_SKB_CB(skb)->end_seq)) {\n\t\t\t\tskb = tcp_collapse_one(sk, skb, list);\n\t\t\t\tif (!skb ||\n\t\t\t\t    skb == tail ||\n\t\t\t\t    (TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)))\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Collapse ofo queue. Algorithm: select contiguous sequence of skbs\n * and tcp_collapse() them until all the queue is collapsed.\n */\nstatic void tcp_collapse_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb = skb_peek(&tp->out_of_order_queue);\n\tstruct sk_buff *head;\n\tu32 start, end;\n\n\tif (!skb)\n\t\treturn;\n\n\tstart = TCP_SKB_CB(skb)->seq;\n\tend = TCP_SKB_CB(skb)->end_seq;\n\thead = skb;\n\n\tfor (;;) {\n\t\tstruct sk_buff *next = NULL;\n\n\t\tif (!skb_queue_is_last(&tp->out_of_order_queue, skb))\n\t\t\tnext = skb_queue_next(&tp->out_of_order_queue, skb);\n\t\tskb = next;\n\n\t\t/* Segment is terminated when we see gap or when\n\t\t * we are at the end of all the queue. */\n\t\tif (!skb ||\n\t\t    after(TCP_SKB_CB(skb)->seq, end) ||\n\t\t    before(TCP_SKB_CB(skb)->end_seq, start)) {\n\t\t\ttcp_collapse(sk, &tp->out_of_order_queue,\n\t\t\t\t     head, skb, start, end);\n\t\t\thead = skb;\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\t\t\t/* Start new segment */\n\t\t\tstart = TCP_SKB_CB(skb)->seq;\n\t\t\tend = TCP_SKB_CB(skb)->end_seq;\n\t\t} else {\n\t\t\tif (before(TCP_SKB_CB(skb)->seq, start))\n\t\t\t\tstart = TCP_SKB_CB(skb)->seq;\n\t\t\tif (after(TCP_SKB_CB(skb)->end_seq, end))\n\t\t\t\tend = TCP_SKB_CB(skb)->end_seq;\n\t\t}\n\t}\n}\n\n/*\n * Purge the out-of-order queue.\n * Return true if queue was pruned.\n */\nstatic bool tcp_prune_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tbool res = false;\n\n\tif (!skb_queue_empty(&tp->out_of_order_queue)) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_OFOPRUNED);\n\t\t__skb_queue_purge(&tp->out_of_order_queue);\n\n\t\t/* Reset SACK state.  A conforming SACK implementation will\n\t\t * do the same at a timeout based retransmit.  When a connection\n\t\t * is in a sad state like this, we care only about integrity\n\t\t * of the connection not performance.\n\t\t */\n\t\tif (tp->rx_opt.sack_ok)\n\t\t\ttcp_sack_reset(&tp->rx_opt);\n\t\tsk_mem_reclaim(sk);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\n/* Reduce allocated memory if we can, trying to get\n * the socket within its memory limits again.\n *\n * Return less than zero if we should start dropping frames\n * until the socket owning process reads some of the data\n * to stabilize the situation.\n */\nstatic int tcp_prune_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tSOCK_DEBUG(sk, \"prune_queue: c=%x\\n\", tp->copied_seq);\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PRUNECALLED);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\ttcp_clamp_window(sk);\n\telse if (tcp_under_memory_pressure(sk))\n\t\ttp->rcv_ssthresh = min(tp->rcv_ssthresh, 4U * tp->advmss);\n\n\ttcp_collapse_ofo_queue(sk);\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\ttcp_collapse(sk, &sk->sk_receive_queue,\n\t\t\t     skb_peek(&sk->sk_receive_queue),\n\t\t\t     NULL,\n\t\t\t     tp->copied_seq, tp->rcv_nxt);\n\tsk_mem_reclaim(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\treturn 0;\n\n\t/* Collapsing did not help, destructive actions follow.\n\t * This must not ever occur. */\n\n\ttcp_prune_ofo_queue(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\treturn 0;\n\n\t/* If we are really being abused, tell the caller to silently\n\t * drop receive data on the floor.  It will get retransmitted\n\t * and hopefully then we'll have sufficient space.\n\t */\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_RCVPRUNED);\n\n\t/* Massive buffer overcommit. */\n\ttp->pred_flags = 0;\n\treturn -1;\n}\n\nstatic bool tcp_should_expand_sndbuf(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t/* If the user specified a specific send buffer setting, do\n\t * not modify it.\n\t */\n\tif (sk->sk_userlocks & SOCK_SNDBUF_LOCK)\n\t\treturn false;\n\n\t/* If we are under global TCP memory pressure, do not expand.  */\n\tif (tcp_under_memory_pressure(sk))\n\t\treturn false;\n\n\t/* If we are under soft global TCP memory pressure, do not expand.  */\n\tif (sk_memory_allocated(sk) >= sk_prot_mem_limits(sk, 0))\n\t\treturn false;\n\n\t/* If we filled the congestion window, do not expand.  */\n\tif (tcp_packets_in_flight(tp) >= tp->snd_cwnd)\n\t\treturn false;\n\n\treturn true;\n}\n\n/* When incoming ACK allowed to free some skb from write_queue,\n * we remember this event in flag SOCK_QUEUE_SHRUNK and wake up socket\n * on the exit from tcp input handler.\n *\n * PROBLEM: sndbuf expansion does not work well with largesend.\n */\nstatic void tcp_new_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_should_expand_sndbuf(sk)) {\n\t\ttcp_sndbuf_expand(sk);\n\t\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\t}\n\n\tsk->sk_write_space(sk);\n}\n\nstatic void tcp_check_space(struct sock *sk)\n{\n\tif (sock_flag(sk, SOCK_QUEUE_SHRUNK)) {\n\t\tsock_reset_flag(sk, SOCK_QUEUE_SHRUNK);\n\t\t/* pairs with tcp_poll() */\n\t\tsmp_mb__after_atomic();\n\t\tif (sk->sk_socket &&\n\t\t    test_bit(SOCK_NOSPACE, &sk->sk_socket->flags))\n\t\t\ttcp_new_space(sk);\n\t}\n}\n\nstatic inline void tcp_data_snd_check(struct sock *sk)\n{\n\ttcp_push_pending_frames(sk);\n\ttcp_check_space(sk);\n}\n\n/*\n * Check if sending an ack is needed.\n */\nstatic void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t    /* More than one full frame received... */\n\tif (((tp->rcv_nxt - tp->rcv_wup) > inet_csk(sk)->icsk_ack.rcv_mss &&\n\t     /* ... and right edge of window advances far enough.\n\t      * (tcp_recvmsg() will send ACK otherwise). Or...\n\t      */\n\t     __tcp_select_window(sk) >= tp->rcv_wnd) ||\n\t    /* We ACK each frame or... */\n\t    tcp_in_quickack_mode(sk) ||\n\t    /* We have out of order data. */\n\t    (ofo_possible && skb_peek(&tp->out_of_order_queue))) {\n\t\t/* Then ack it now */\n\t\ttcp_send_ack(sk);\n\t} else {\n\t\t/* Else, send delayed ack. */\n\t\ttcp_send_delayed_ack(sk);\n\t}\n}\n\nstatic inline void tcp_ack_snd_check(struct sock *sk)\n{\n\tif (!inet_csk_ack_scheduled(sk)) {\n\t\t/* We sent a data segment already. */\n\t\treturn;\n\t}\n\t__tcp_ack_snd_check(sk, 1);\n}\n\n/*\n *\tThis routine is only called when we have urgent data\n *\tsignaled. Its the 'slow' part of tcp_urg. It could be\n *\tmoved inline now as tcp_urg is only called from one\n *\tplace. We handle URGent data wrong. We have to - as\n *\tBSD still doesn't use the correction from RFC961.\n *\tFor 1003.1g we should support a new option TCP_STDURG to permit\n *\teither form (or just set the sysctl tcp_stdurg).\n */\n\nstatic void tcp_check_urg(struct sock *sk, const struct tcphdr *th)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 ptr = ntohs(th->urg_ptr);\n\n\tif (ptr && !sysctl_tcp_stdurg)\n\t\tptr--;\n\tptr += ntohl(th->seq);\n\n\t/* Ignore urgent data that we've already seen and read. */\n\tif (after(tp->copied_seq, ptr))\n\t\treturn;\n\n\t/* Do not replay urg ptr.\n\t *\n\t * NOTE: interesting situation not covered by specs.\n\t * Misbehaving sender may send urg ptr, pointing to segment,\n\t * which we already have in ofo queue. We are not able to fetch\n\t * such data and will stay in TCP_URG_NOTYET until will be eaten\n\t * by recvmsg(). Seems, we are not obliged to handle such wicked\n\t * situations. But it is worth to think about possibility of some\n\t * DoSes using some hypothetical application level deadlock.\n\t */\n\tif (before(ptr, tp->rcv_nxt))\n\t\treturn;\n\n\t/* Do we already have a newer (or duplicate) urgent pointer? */\n\tif (tp->urg_data && !after(ptr, tp->urg_seq))\n\t\treturn;\n\n\t/* Tell the world about our new urgent pointer. */\n\tsk_send_sigurg(sk);\n\n\t/* We may be adding urgent data when the last byte read was\n\t * urgent. To do this requires some care. We cannot just ignore\n\t * tp->copied_seq since we would read the last urgent byte again\n\t * as data, nor can we alter copied_seq until this data arrives\n\t * or we break the semantics of SIOCATMARK (and thus sockatmark())\n\t *\n\t * NOTE. Double Dutch. Rendering to plain English: author of comment\n\t * above did something sort of \tsend(\"A\", MSG_OOB); send(\"B\", MSG_OOB);\n\t * and expect that both A and B disappear from stream. This is _wrong_.\n\t * Though this happens in BSD with high probability, this is occasional.\n\t * Any application relying on this is buggy. Note also, that fix \"works\"\n\t * only in this artificial test. Insert some normal data between A and B and we will\n\t * decline of BSD again. Verdict: it is better to remove to trap\n\t * buggy users.\n\t */\n\tif (tp->urg_seq == tp->copied_seq && tp->urg_data &&\n\t    !sock_flag(sk, SOCK_URGINLINE) && tp->copied_seq != tp->rcv_nxt) {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\ttp->copied_seq++;\n\t\tif (skb && !before(tp->copied_seq, TCP_SKB_CB(skb)->end_seq)) {\n\t\t\t__skb_unlink(skb, &sk->sk_receive_queue);\n\t\t\t__kfree_skb(skb);\n\t\t}\n\t}\n\n\ttp->urg_data = TCP_URG_NOTYET;\n\ttp->urg_seq = ptr;\n\n\t/* Disable header prediction. */\n\ttp->pred_flags = 0;\n}\n\n/* This is the 'fast' part of urgent handling. */\nstatic void tcp_urg(struct sock *sk, struct sk_buff *skb, const struct tcphdr *th)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Check if we get a new urgent pointer - normally not. */\n\tif (th->urg)\n\t\ttcp_check_urg(sk, th);\n\n\t/* Do we wait for any urgent data? - normally not... */\n\tif (tp->urg_data == TCP_URG_NOTYET) {\n\t\tu32 ptr = tp->urg_seq - ntohl(th->seq) + (th->doff * 4) -\n\t\t\t  th->syn;\n\n\t\t/* Is the urgent pointer pointing into this packet? */\n\t\tif (ptr < skb->len) {\n\t\t\tu8 tmp;\n\t\t\tif (skb_copy_bits(skb, ptr, &tmp, 1))\n\t\t\t\tBUG();\n\t\t\ttp->urg_data = TCP_URG_VALID | tmp;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\tsk->sk_data_ready(sk);\n\t\t}\n\t}\n}\n\nstatic int tcp_copy_to_iovec(struct sock *sk, struct sk_buff *skb, int hlen)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint chunk = skb->len - hlen;\n\tint err;\n\n\tlocal_bh_enable();\n\tif (skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_msg(skb, hlen, tp->ucopy.msg, chunk);\n\telse\n\t\terr = skb_copy_and_csum_datagram_msg(skb, hlen, tp->ucopy.msg);\n\n\tif (!err) {\n\t\ttp->ucopy.len -= chunk;\n\t\ttp->copied_seq += chunk;\n\t\ttcp_rcv_space_adjust(sk);\n\t}\n\n\tlocal_bh_disable();\n\treturn err;\n}\n\nstatic __sum16 __tcp_checksum_complete_user(struct sock *sk,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\t__sum16 result;\n\n\tif (sock_owned_by_user(sk)) {\n\t\tlocal_bh_enable();\n\t\tresult = __tcp_checksum_complete(skb);\n\t\tlocal_bh_disable();\n\t} else {\n\t\tresult = __tcp_checksum_complete(skb);\n\t}\n\treturn result;\n}\n\nstatic inline bool tcp_checksum_complete_user(struct sock *sk,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\treturn !skb_csum_unnecessary(skb) &&\n\t       __tcp_checksum_complete_user(sk, skb);\n}\n\n/* Does PAWS and seqno based validation of an incoming segment, flags will\n * play significant role here.\n */\nstatic bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  const struct tcphdr *th, int syn_inerr)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* RFC1323: H1. Apply PAWS check first. */\n\tif (tcp_fast_parse_options(skb, th, tp) && tp->rx_opt.saw_tstamp &&\n\t    tcp_paws_discard(sk, skb)) {\n\t\tif (!th->rst) {\n\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSESTABREJECTED);\n\t\t\tif (!tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t\t\t  LINUX_MIB_TCPACKSKIPPEDPAWS,\n\t\t\t\t\t\t  &tp->last_oow_ack_time))\n\t\t\t\ttcp_send_dupack(sk, skb);\n\t\t\tgoto discard;\n\t\t}\n\t\t/* Reset is accepted even if it did not pass PAWS. */\n\t}\n\n\t/* Step 1: check sequence number */\n\tif (!tcp_sequence(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq)) {\n\t\t/* RFC793, page 37: \"In all states except SYN-SENT, all reset\n\t\t * (RST) segments are validated by checking their SEQ-fields.\"\n\t\t * And page 69: \"If an incoming segment is not acceptable,\n\t\t * an acknowledgment should be sent in reply (unless the RST\n\t\t * bit is set, if so drop the segment and return)\".\n\t\t */\n\t\tif (!th->rst) {\n\t\t\tif (th->syn)\n\t\t\t\tgoto syn_challenge;\n\t\t\tif (!tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t\t\t  LINUX_MIB_TCPACKSKIPPEDSEQ,\n\t\t\t\t\t\t  &tp->last_oow_ack_time))\n\t\t\t\ttcp_send_dupack(sk, skb);\n\t\t}\n\t\tgoto discard;\n\t}\n\n\t/* Step 2: check RST bit */\n\tif (th->rst) {\n\t\t/* RFC 5961 3.2 :\n\t\t * If sequence number exactly matches RCV.NXT, then\n\t\t *     RESET the connection\n\t\t * else\n\t\t *     Send a challenge ACK\n\t\t */\n\t\tif (TCP_SKB_CB(skb)->seq == tp->rcv_nxt)\n\t\t\ttcp_reset(sk);\n\t\telse\n\t\t\ttcp_send_challenge_ack(sk, skb);\n\t\tgoto discard;\n\t}\n\n\t/* step 3: check security and precedence [ignored] */\n\n\t/* step 4: Check for a SYN\n\t * RFC 5961 4.2 : Send a challenge ack\n\t */\n\tif (th->syn) {\nsyn_challenge:\n\t\tif (syn_inerr)\n\t\t\tTCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSYNCHALLENGE);\n\t\ttcp_send_challenge_ack(sk, skb);\n\t\tgoto discard;\n\t}\n\n\treturn true;\n\ndiscard:\n\t__kfree_skb(skb);\n\treturn false;\n}\n\n/*\n *\tTCP receive function for the ESTABLISHED state.\n *\n *\tIt is split into a fast path and a slow path. The fast path is\n * \tdisabled when:\n *\t- A zero window was announced from us - zero window probing\n *        is only handled properly in the slow path.\n *\t- Out of order segments arrived.\n *\t- Urgent data is expected.\n *\t- There is no buffer space left\n *\t- Unexpected TCP flags/window values/header lengths are received\n *\t  (detected by checking the TCP header against pred_flags)\n *\t- Data is sent in both directions. Fast path only supports pure senders\n *\t  or pure receivers (this means either the sequence number or the ack\n *\t  value must stay constant)\n *\t- Unexpected TCP option.\n *\n *\tWhen these conditions are not satisfied it drops into a standard\n *\treceive procedure patterned after RFC793 to handle all cases.\n *\tThe first three cases are guaranteed by proper pred_flags setting,\n *\tthe rest is checked inline. Fast processing is turned on in\n *\ttcp_data_queue when everything is OK.\n */\nvoid tcp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct tcphdr *th, unsigned int len)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (unlikely(!sk->sk_rx_dst))\n\t\tinet_csk(sk)->icsk_af_ops->sk_rx_dst_set(sk, skb);\n\t/*\n\t *\tHeader prediction.\n\t *\tThe code loosely follows the one in the famous\n\t *\t\"30 instruction TCP receive\" Van Jacobson mail.\n\t *\n\t *\tVan's trick is to deposit buffers into socket queue\n\t *\ton a device interrupt, to call tcp_recv function\n\t *\ton the receive process context and checksum and copy\n\t *\tthe buffer to user space. smart...\n\t *\n\t *\tOur current scheme is not silly either but we take the\n\t *\textra cost of the net_bh soft interrupt processing...\n\t *\tWe do checksum and copy also but from device to kernel.\n\t */\n\n\ttp->rx_opt.saw_tstamp = 0;\n\n\t/*\tpred_flags is 0xS?10 << 16 + snd_wnd\n\t *\tif header_prediction is to be made\n\t *\t'S' will always be tp->tcp_header_len >> 2\n\t *\t'?' will be 0 for the fast path, otherwise pred_flags is 0 to\n\t *  turn it off\t(when there are holes in the receive\n\t *\t space for instance)\n\t *\tPSH flag is ignored.\n\t */\n\n\tif ((tcp_flag_word(th) & TCP_HP_BITS) == tp->pred_flags &&\n\t    TCP_SKB_CB(skb)->seq == tp->rcv_nxt &&\n\t    !after(TCP_SKB_CB(skb)->ack_seq, tp->snd_nxt)) {\n\t\tint tcp_header_len = tp->tcp_header_len;\n\n\t\t/* Timestamp header prediction: tcp_header_len\n\t\t * is automatically equal to th->doff*4 due to pred_flags\n\t\t * match.\n\t\t */\n\n\t\t/* Check timestamp */\n\t\tif (tcp_header_len == sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) {\n\t\t\t/* No? Slow path! */\n\t\t\tif (!tcp_parse_aligned_timestamp(tp, th))\n\t\t\t\tgoto slow_path;\n\n\t\t\t/* If PAWS failed, check it more carefully in slow path */\n\t\t\tif ((s32)(tp->rx_opt.rcv_tsval - tp->rx_opt.ts_recent) < 0)\n\t\t\t\tgoto slow_path;\n\n\t\t\t/* DO NOT update ts_recent here, if checksum fails\n\t\t\t * and timestamp was corrupted part, it will result\n\t\t\t * in a hung connection since we will drop all\n\t\t\t * future packets due to the PAWS test.\n\t\t\t */\n\t\t}\n\n\t\tif (len <= tcp_header_len) {\n\t\t\t/* Bulk data transfer: sender */\n\t\t\tif (len == tcp_header_len) {\n\t\t\t\t/* Predicted packet is in window by definition.\n\t\t\t\t * seq == rcv_nxt and rcv_wup <= rcv_nxt.\n\t\t\t\t * Hence, check seq<=rcv_wup reduces to:\n\t\t\t\t */\n\t\t\t\tif (tcp_header_len ==\n\t\t\t\t    (sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &&\n\t\t\t\t    tp->rcv_nxt == tp->rcv_wup)\n\t\t\t\t\ttcp_store_ts_recent(tp);\n\n\t\t\t\t/* We know that such packets are checksummed\n\t\t\t\t * on entry.\n\t\t\t\t */\n\t\t\t\ttcp_ack(sk, skb, 0);\n\t\t\t\t__kfree_skb(skb);\n\t\t\t\ttcp_data_snd_check(sk);\n\t\t\t\treturn;\n\t\t\t} else { /* Header too small */\n\t\t\t\tTCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);\n\t\t\t\tgoto discard;\n\t\t\t}\n\t\t} else {\n\t\t\tint eaten = 0;\n\t\t\tbool fragstolen = false;\n\n\t\t\tif (tp->ucopy.task == current &&\n\t\t\t    tp->copied_seq == tp->rcv_nxt &&\n\t\t\t    len - tcp_header_len <= tp->ucopy.len &&\n\t\t\t    sock_owned_by_user(sk)) {\n\t\t\t\t__set_current_state(TASK_RUNNING);\n\n\t\t\t\tif (!tcp_copy_to_iovec(sk, skb, tcp_header_len)) {\n\t\t\t\t\t/* Predicted packet is in window by definition.\n\t\t\t\t\t * seq == rcv_nxt and rcv_wup <= rcv_nxt.\n\t\t\t\t\t * Hence, check seq<=rcv_wup reduces to:\n\t\t\t\t\t */\n\t\t\t\t\tif (tcp_header_len ==\n\t\t\t\t\t    (sizeof(struct tcphdr) +\n\t\t\t\t\t     TCPOLEN_TSTAMP_ALIGNED) &&\n\t\t\t\t\t    tp->rcv_nxt == tp->rcv_wup)\n\t\t\t\t\t\ttcp_store_ts_recent(tp);\n\n\t\t\t\t\ttcp_rcv_rtt_measure_ts(sk, skb);\n\n\t\t\t\t\t__skb_pull(skb, tcp_header_len);\n\t\t\t\t\ttcp_rcv_nxt_update(tp, TCP_SKB_CB(skb)->end_seq);\n\t\t\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPHPHITSTOUSER);\n\t\t\t\t\teaten = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!eaten) {\n\t\t\t\tif (tcp_checksum_complete_user(sk, skb))\n\t\t\t\t\tgoto csum_error;\n\n\t\t\t\tif ((int)skb->truesize > sk->sk_forward_alloc)\n\t\t\t\t\tgoto step5;\n\n\t\t\t\t/* Predicted packet is in window by definition.\n\t\t\t\t * seq == rcv_nxt and rcv_wup <= rcv_nxt.\n\t\t\t\t * Hence, check seq<=rcv_wup reduces to:\n\t\t\t\t */\n\t\t\t\tif (tcp_header_len ==\n\t\t\t\t    (sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &&\n\t\t\t\t    tp->rcv_nxt == tp->rcv_wup)\n\t\t\t\t\ttcp_store_ts_recent(tp);\n\n\t\t\t\ttcp_rcv_rtt_measure_ts(sk, skb);\n\n\t\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPHPHITS);\n\n\t\t\t\t/* Bulk data transfer: receiver */\n\t\t\t\teaten = tcp_queue_rcv(sk, skb, tcp_header_len,\n\t\t\t\t\t\t      &fragstolen);\n\t\t\t}\n\n\t\t\ttcp_event_data_recv(sk, skb);\n\n\t\t\tif (TCP_SKB_CB(skb)->ack_seq != tp->snd_una) {\n\t\t\t\t/* Well, only one small jumplet in fast path... */\n\t\t\t\ttcp_ack(sk, skb, FLAG_DATA);\n\t\t\t\ttcp_data_snd_check(sk);\n\t\t\t\tif (!inet_csk_ack_scheduled(sk))\n\t\t\t\t\tgoto no_ack;\n\t\t\t}\n\n\t\t\t__tcp_ack_snd_check(sk, 0);\nno_ack:\n\t\t\tif (eaten)\n\t\t\t\tkfree_skb_partial(skb, fragstolen);\n\t\t\tsk->sk_data_ready(sk);\n\t\t\treturn;\n\t\t}\n\t}\n\nslow_path:\n\tif (len < (th->doff << 2) || tcp_checksum_complete_user(sk, skb))\n\t\tgoto csum_error;\n\n\tif (!th->ack && !th->rst && !th->syn)\n\t\tgoto discard;\n\n\t/*\n\t *\tStandard slow path.\n\t */\n\n\tif (!tcp_validate_incoming(sk, skb, th, 1))\n\t\treturn;\n\nstep5:\n\tif (tcp_ack(sk, skb, FLAG_SLOWPATH | FLAG_UPDATE_TS_RECENT) < 0)\n\t\tgoto discard;\n\n\ttcp_rcv_rtt_measure_ts(sk, skb);\n\n\t/* Process urgent data. */\n\ttcp_urg(sk, skb, th);\n\n\t/* step 7: process the segment text */\n\ttcp_data_queue(sk, skb);\n\n\ttcp_data_snd_check(sk);\n\ttcp_ack_snd_check(sk);\n\treturn;\n\ncsum_error:\n\tTCP_INC_STATS_BH(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);\n\ndiscard:\n\t__kfree_skb(skb);\n}\nEXPORT_SYMBOL(tcp_rcv_established);\n\nvoid tcp_finish_connect(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_set_state(sk, TCP_ESTABLISHED);\n\n\tif (skb) {\n\t\ticsk->icsk_af_ops->sk_rx_dst_set(sk, skb);\n\t\tsecurity_inet_conn_established(sk, skb);\n\t}\n\n\t/* Make sure socket is routed, for correct metrics.  */\n\ticsk->icsk_af_ops->rebuild_header(sk);\n\n\ttcp_init_metrics(sk);\n\n\ttcp_init_congestion_control(sk);\n\n\t/* Prevent spurious tcp_cwnd_restart() on first data\n\t * packet.\n\t */\n\ttp->lsndtime = tcp_time_stamp;\n\n\ttcp_init_buffer_space(sk);\n\n\tif (sock_flag(sk, SOCK_KEEPOPEN))\n\t\tinet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));\n\n\tif (!tp->rx_opt.snd_wscale)\n\t\t__tcp_fast_path_on(tp, tp->snd_wnd);\n\telse\n\t\ttp->pred_flags = 0;\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t}\n}\n\nstatic bool tcp_rcv_fastopen_synack(struct sock *sk, struct sk_buff *synack,\n\t\t\t\t    struct tcp_fastopen_cookie *cookie)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *data = tp->syn_data ? tcp_write_queue_head(sk) : NULL;\n\tu16 mss = tp->rx_opt.mss_clamp, try_exp = 0;\n\tbool syn_drop = false;\n\n\tif (mss == tp->rx_opt.user_mss) {\n\t\tstruct tcp_options_received opt;\n\n\t\t/* Get original SYNACK MSS value if user MSS sets mss_clamp */\n\t\ttcp_clear_options(&opt);\n\t\topt.user_mss = opt.mss_clamp = 0;\n\t\ttcp_parse_options(synack, &opt, 0, NULL);\n\t\tmss = opt.mss_clamp;\n\t}\n\n\tif (!tp->syn_fastopen) {\n\t\t/* Ignore an unsolicited cookie */\n\t\tcookie->len = -1;\n\t} else if (tp->total_retrans) {\n\t\t/* SYN timed out and the SYN-ACK neither has a cookie nor\n\t\t * acknowledges data. Presumably the remote received only\n\t\t * the retransmitted (regular) SYNs: either the original\n\t\t * SYN-data or the corresponding SYN-ACK was dropped.\n\t\t */\n\t\tsyn_drop = (cookie->len < 0 && data);\n\t} else if (cookie->len < 0 && !tp->syn_data) {\n\t\t/* We requested a cookie but didn't get it. If we did not use\n\t\t * the (old) exp opt format then try so next time (try_exp=1).\n\t\t * Otherwise we go back to use the RFC7413 opt (try_exp=2).\n\t\t */\n\t\ttry_exp = tp->syn_fastopen_exp ? 2 : 1;\n\t}\n\n\ttcp_fastopen_cache_set(sk, mss, cookie, syn_drop, try_exp);\n\n\tif (data) { /* Retransmit unacked data in SYN */\n\t\ttcp_for_write_queue_from(data, sk) {\n\t\t\tif (data == tcp_send_head(sk) ||\n\t\t\t    __tcp_retransmit_skb(sk, data))\n\t\t\t\tbreak;\n\t\t}\n\t\ttcp_rearm_rto(sk);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPFASTOPENACTIVEFAIL);\n\t\treturn true;\n\t}\n\ttp->syn_data_acked = tp->syn_data;\n\tif (tp->syn_data_acked)\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPFASTOPENACTIVE);\n\treturn false;\n}\n\nstatic int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t const struct tcphdr *th)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_fastopen_cookie foc = { .len = -1 };\n\tint saved_clamp = tp->rx_opt.mss_clamp;\n\n\ttcp_parse_options(skb, &tp->rx_opt, 0, &foc);\n\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)\n\t\ttp->rx_opt.rcv_tsecr -= tp->tsoffset;\n\n\tif (th->ack) {\n\t\t/* rfc793:\n\t\t * \"If the state is SYN-SENT then\n\t\t *    first check the ACK bit\n\t\t *      If the ACK bit is set\n\t\t *\t  If SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send\n\t\t *        a reset (unless the RST bit is set, if so drop\n\t\t *        the segment and return)\"\n\t\t */\n\t\tif (!after(TCP_SKB_CB(skb)->ack_seq, tp->snd_una) ||\n\t\t    after(TCP_SKB_CB(skb)->ack_seq, tp->snd_nxt))\n\t\t\tgoto reset_and_undo;\n\n\t\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\n\t\t    !between(tp->rx_opt.rcv_tsecr, tp->retrans_stamp,\n\t\t\t     tcp_time_stamp)) {\n\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSACTIVEREJECTED);\n\t\t\tgoto reset_and_undo;\n\t\t}\n\n\t\t/* Now ACK is acceptable.\n\t\t *\n\t\t * \"If the RST bit is set\n\t\t *    If the ACK was acceptable then signal the user \"error:\n\t\t *    connection reset\", drop the segment, enter CLOSED state,\n\t\t *    delete TCB, and return.\"\n\t\t */\n\n\t\tif (th->rst) {\n\t\t\ttcp_reset(sk);\n\t\t\tgoto discard;\n\t\t}\n\n\t\t/* rfc793:\n\t\t *   \"fifth, if neither of the SYN or RST bits is set then\n\t\t *    drop the segment and return.\"\n\t\t *\n\t\t *    See note below!\n\t\t *                                        --ANK(990513)\n\t\t */\n\t\tif (!th->syn)\n\t\t\tgoto discard_and_undo;\n\n\t\t/* rfc793:\n\t\t *   \"If the SYN bit is on ...\n\t\t *    are acceptable then ...\n\t\t *    (our SYN has been ACKed), change the connection\n\t\t *    state to ESTABLISHED...\"\n\t\t */\n\n\t\ttcp_ecn_rcv_synack(tp, th);\n\n\t\ttcp_init_wl(tp, TCP_SKB_CB(skb)->seq);\n\t\ttcp_ack(sk, skb, FLAG_SLOWPATH);\n\n\t\t/* Ok.. it's good. Set up sequence numbers and\n\t\t * move to established.\n\t\t */\n\t\ttp->rcv_nxt = TCP_SKB_CB(skb)->seq + 1;\n\t\ttp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;\n\n\t\t/* RFC1323: The window in SYN & SYN/ACK segments is\n\t\t * never scaled.\n\t\t */\n\t\ttp->snd_wnd = ntohs(th->window);\n\n\t\tif (!tp->rx_opt.wscale_ok) {\n\t\t\ttp->rx_opt.snd_wscale = tp->rx_opt.rcv_wscale = 0;\n\t\t\ttp->window_clamp = min(tp->window_clamp, 65535U);\n\t\t}\n\n\t\tif (tp->rx_opt.saw_tstamp) {\n\t\t\ttp->rx_opt.tstamp_ok\t   = 1;\n\t\t\ttp->tcp_header_len =\n\t\t\t\tsizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\n\t\t\ttp->advmss\t    -= TCPOLEN_TSTAMP_ALIGNED;\n\t\t\ttcp_store_ts_recent(tp);\n\t\t} else {\n\t\t\ttp->tcp_header_len = sizeof(struct tcphdr);\n\t\t}\n\n\t\tif (tcp_is_sack(tp) && sysctl_tcp_fack)\n\t\t\ttcp_enable_fack(tp);\n\n\t\ttcp_mtup_init(sk);\n\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\ttcp_initialize_rcv_mss(sk);\n\n\t\t/* Remember, tcp_poll() does not lock socket!\n\t\t * Change state from SYN-SENT only after copied_seq\n\t\t * is initialized. */\n\t\ttp->copied_seq = tp->rcv_nxt;\n\n\t\tsmp_mb();\n\n\t\ttcp_finish_connect(sk, skb);\n\n\t\tif ((tp->syn_fastopen || tp->syn_data) &&\n\t\t    tcp_rcv_fastopen_synack(sk, skb, &foc))\n\t\t\treturn -1;\n\n\t\tif (sk->sk_write_pending ||\n\t\t    icsk->icsk_accept_queue.rskq_defer_accept ||\n\t\t    icsk->icsk_ack.pingpong) {\n\t\t\t/* Save one ACK. Data will be ready after\n\t\t\t * several ticks, if write_pending is set.\n\t\t\t *\n\t\t\t * It may be deleted, but with this feature tcpdumps\n\t\t\t * look so _wonderfully_ clever, that I was not able\n\t\t\t * to stand against the temptation 8)     --ANK\n\t\t\t */\n\t\t\tinet_csk_schedule_ack(sk);\n\t\t\ticsk->icsk_ack.lrcvtime = tcp_time_stamp;\n\t\t\ttcp_enter_quickack_mode(sk);\n\t\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,\n\t\t\t\t\t\t  TCP_DELACK_MAX, TCP_RTO_MAX);\n\ndiscard:\n\t\t\t__kfree_skb(skb);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\ttcp_send_ack(sk);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* No ACK in the segment */\n\n\tif (th->rst) {\n\t\t/* rfc793:\n\t\t * \"If the RST bit is set\n\t\t *\n\t\t *      Otherwise (no ACK) drop the segment and return.\"\n\t\t */\n\n\t\tgoto discard_and_undo;\n\t}\n\n\t/* PAWS check. */\n\tif (tp->rx_opt.ts_recent_stamp && tp->rx_opt.saw_tstamp &&\n\t    tcp_paws_reject(&tp->rx_opt, 0))\n\t\tgoto discard_and_undo;\n\n\tif (th->syn) {\n\t\t/* We see SYN without ACK. It is attempt of\n\t\t * simultaneous connect with crossed SYNs.\n\t\t * Particularly, it can be connect to self.\n\t\t */\n\t\ttcp_set_state(sk, TCP_SYN_RECV);\n\n\t\tif (tp->rx_opt.saw_tstamp) {\n\t\t\ttp->rx_opt.tstamp_ok = 1;\n\t\t\ttcp_store_ts_recent(tp);\n\t\t\ttp->tcp_header_len =\n\t\t\t\tsizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\n\t\t} else {\n\t\t\ttp->tcp_header_len = sizeof(struct tcphdr);\n\t\t}\n\n\t\ttp->rcv_nxt = TCP_SKB_CB(skb)->seq + 1;\n\t\ttp->copied_seq = tp->rcv_nxt;\n\t\ttp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;\n\n\t\t/* RFC1323: The window in SYN & SYN/ACK segments is\n\t\t * never scaled.\n\t\t */\n\t\ttp->snd_wnd    = ntohs(th->window);\n\t\ttp->snd_wl1    = TCP_SKB_CB(skb)->seq;\n\t\ttp->max_window = tp->snd_wnd;\n\n\t\ttcp_ecn_rcv_syn(tp, th);\n\n\t\ttcp_mtup_init(sk);\n\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\ttcp_initialize_rcv_mss(sk);\n\n\t\ttcp_send_synack(sk);\n#if 0\n\t\t/* Note, we could accept data and URG from this segment.\n\t\t * There are no obstacles to make this (except that we must\n\t\t * either change tcp_recvmsg() to prevent it from returning data\n\t\t * before 3WHS completes per RFC793, or employ TCP Fast Open).\n\t\t *\n\t\t * However, if we ignore data in ACKless segments sometimes,\n\t\t * we have no reasons to accept it sometimes.\n\t\t * Also, seems the code doing it in step6 of tcp_rcv_state_process\n\t\t * is not flawless. So, discard packet for sanity.\n\t\t * Uncomment this return to process the data.\n\t\t */\n\t\treturn -1;\n#else\n\t\tgoto discard;\n#endif\n\t}\n\t/* \"fifth, if neither of the SYN or RST bits is set then\n\t * drop the segment and return.\"\n\t */\n\ndiscard_and_undo:\n\ttcp_clear_options(&tp->rx_opt);\n\ttp->rx_opt.mss_clamp = saved_clamp;\n\tgoto discard;\n\nreset_and_undo:\n\ttcp_clear_options(&tp->rx_opt);\n\ttp->rx_opt.mss_clamp = saved_clamp;\n\treturn 1;\n}\n\n/*\n *\tThis function implements the receiving procedure of RFC 793 for\n *\tall states except ESTABLISHED and TIME_WAIT.\n *\tIt's called from both tcp_v4_rcv and tcp_v6_rcv and should be\n *\taddress independent.\n */\n\nint tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct request_sock *req;\n\tint queued = 0;\n\tbool acceptable;\n\n\ttp->rx_opt.saw_tstamp = 0;\n\n\tswitch (sk->sk_state) {\n\tcase TCP_CLOSE:\n\t\tgoto discard;\n\n\tcase TCP_LISTEN:\n\t\tif (th->ack)\n\t\t\treturn 1;\n\n\t\tif (th->rst)\n\t\t\tgoto discard;\n\n\t\tif (th->syn) {\n\t\t\tif (th->fin)\n\t\t\t\tgoto discard;\n\t\t\tif (icsk->icsk_af_ops->conn_request(sk, skb) < 0)\n\t\t\t\treturn 1;\n\n\t\t\t/* Now we have several options: In theory there is\n\t\t\t * nothing else in the frame. KA9Q has an option to\n\t\t\t * send data with the syn, BSD accepts data with the\n\t\t\t * syn up to the [to be] advertised window and\n\t\t\t * Solaris 2.1 gives you a protocol error. For now\n\t\t\t * we just ignore it, that fits the spec precisely\n\t\t\t * and avoids incompatibilities. It would be nice in\n\t\t\t * future to drop through and process the data.\n\t\t\t *\n\t\t\t * Now that TTCP is starting to be used we ought to\n\t\t\t * queue this data.\n\t\t\t * But, this leaves one open to an easy denial of\n\t\t\t * service attack, and SYN cookies can't defend\n\t\t\t * against this problem. So, we drop the data\n\t\t\t * in the interest of security over speed unless\n\t\t\t * it's still in use.\n\t\t\t */\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tgoto discard;\n\n\tcase TCP_SYN_SENT:\n\t\tqueued = tcp_rcv_synsent_state_process(sk, skb, th);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\n\t\t/* Do step6 onward by hand. */\n\t\ttcp_urg(sk, skb, th);\n\t\t__kfree_skb(skb);\n\t\ttcp_data_snd_check(sk);\n\t\treturn 0;\n\t}\n\n\treq = tp->fastopen_rsk;\n\tif (req) {\n\t\tWARN_ON_ONCE(sk->sk_state != TCP_SYN_RECV &&\n\t\t    sk->sk_state != TCP_FIN_WAIT1);\n\n\t\tif (!tcp_check_req(sk, skb, req, true))\n\t\t\tgoto discard;\n\t}\n\n\tif (!th->ack && !th->rst && !th->syn)\n\t\tgoto discard;\n\n\tif (!tcp_validate_incoming(sk, skb, th, 0))\n\t\treturn 0;\n\n\t/* step 5: check the ACK field */\n\tacceptable = tcp_ack(sk, skb, FLAG_SLOWPATH |\n\t\t\t\t      FLAG_UPDATE_TS_RECENT) > 0;\n\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_RECV:\n\t\tif (!acceptable)\n\t\t\treturn 1;\n\n\t\tif (!tp->srtt_us)\n\t\t\ttcp_synack_rtt_meas(sk, req);\n\n\t\t/* Once we leave TCP_SYN_RECV, we no longer need req\n\t\t * so release it.\n\t\t */\n\t\tif (req) {\n\t\t\ttp->total_retrans = req->num_retrans;\n\t\t\treqsk_fastopen_remove(sk, req, false);\n\t\t} else {\n\t\t\t/* Make sure socket is routed, for correct metrics. */\n\t\t\ticsk->icsk_af_ops->rebuild_header(sk);\n\t\t\ttcp_init_congestion_control(sk);\n\n\t\t\ttcp_mtup_init(sk);\n\t\t\ttp->copied_seq = tp->rcv_nxt;\n\t\t\ttcp_init_buffer_space(sk);\n\t\t}\n\t\tsmp_mb();\n\t\ttcp_set_state(sk, TCP_ESTABLISHED);\n\t\tsk->sk_state_change(sk);\n\n\t\t/* Note, that this wakeup is only for marginal crossed SYN case.\n\t\t * Passively open sockets are not waked up, because\n\t\t * sk->sk_sleep == NULL and sk->sk_socket == NULL.\n\t\t */\n\t\tif (sk->sk_socket)\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\n\t\ttp->snd_una = TCP_SKB_CB(skb)->ack_seq;\n\t\ttp->snd_wnd = ntohs(th->window) << tp->rx_opt.snd_wscale;\n\t\ttcp_init_wl(tp, TCP_SKB_CB(skb)->seq);\n\n\t\tif (tp->rx_opt.tstamp_ok)\n\t\t\ttp->advmss -= TCPOLEN_TSTAMP_ALIGNED;\n\n\t\tif (req) {\n\t\t\t/* Re-arm the timer because data may have been sent out.\n\t\t\t * This is similar to the regular data transmission case\n\t\t\t * when new data has just been ack'ed.\n\t\t\t *\n\t\t\t * (TFO) - we could try to be more aggressive and\n\t\t\t * retransmitting any data sooner based on when they\n\t\t\t * are sent out.\n\t\t\t */\n\t\t\ttcp_rearm_rto(sk);\n\t\t} else\n\t\t\ttcp_init_metrics(sk);\n\n\t\ttcp_update_pacing_rate(sk);\n\n\t\t/* Prevent spurious tcp_cwnd_restart() on first data packet */\n\t\ttp->lsndtime = tcp_time_stamp;\n\n\t\ttcp_initialize_rcv_mss(sk);\n\t\ttcp_fast_path_on(tp);\n\t\tbreak;\n\n\tcase TCP_FIN_WAIT1: {\n\t\tstruct dst_entry *dst;\n\t\tint tmo;\n\n\t\t/* If we enter the TCP_FIN_WAIT1 state and we are a\n\t\t * Fast Open socket and this is the first acceptable\n\t\t * ACK we have received, this would have acknowledged\n\t\t * our SYNACK so stop the SYNACK timer.\n\t\t */\n\t\tif (req) {\n\t\t\t/* Return RST if ack_seq is invalid.\n\t\t\t * Note that RFC793 only says to generate a\n\t\t\t * DUPACK for it but for TCP Fast Open it seems\n\t\t\t * better to treat this case like TCP_SYN_RECV\n\t\t\t * above.\n\t\t\t */\n\t\t\tif (!acceptable)\n\t\t\t\treturn 1;\n\t\t\t/* We no longer need the request sock. */\n\t\t\treqsk_fastopen_remove(sk, req, false);\n\t\t\ttcp_rearm_rto(sk);\n\t\t}\n\t\tif (tp->snd_una != tp->write_seq)\n\t\t\tbreak;\n\n\t\ttcp_set_state(sk, TCP_FIN_WAIT2);\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\t\tdst = __sk_dst_get(sk);\n\t\tif (dst)\n\t\t\tdst_confirm(dst);\n\n\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\t/* Wake up lingering close() */\n\t\t\tsk->sk_state_change(sk);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tp->linger2 < 0 ||\n\t\t    (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t\t     after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt))) {\n\t\t\ttcp_done(sk);\n\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t\t\treturn 1;\n\t\t}\n\n\t\ttmo = tcp_fin_time(sk);\n\t\tif (tmo > TCP_TIMEWAIT_LEN) {\n\t\t\tinet_csk_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);\n\t\t} else if (th->fin || sock_owned_by_user(sk)) {\n\t\t\t/* Bad case. We could lose such FIN otherwise.\n\t\t\t * It is not a big problem, but it looks confusing\n\t\t\t * and not so rare event. We still can lose it now,\n\t\t\t * if it spins in bh_lock_sock(), but it is really\n\t\t\t * marginal case.\n\t\t\t */\n\t\t\tinet_csk_reset_keepalive_timer(sk, tmo);\n\t\t} else {\n\t\t\ttcp_time_wait(sk, TCP_FIN_WAIT2, tmo);\n\t\t\tgoto discard;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase TCP_CLOSING:\n\t\tif (tp->snd_una == tp->write_seq) {\n\t\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\n\t\t\tgoto discard;\n\t\t}\n\t\tbreak;\n\n\tcase TCP_LAST_ACK:\n\t\tif (tp->snd_una == tp->write_seq) {\n\t\t\ttcp_update_metrics(sk);\n\t\t\ttcp_done(sk);\n\t\t\tgoto discard;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* step 6: check the URG bit */\n\ttcp_urg(sk, skb, th);\n\n\t/* step 7: process the segment text */\n\tswitch (sk->sk_state) {\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSING:\n\tcase TCP_LAST_ACK:\n\t\tif (!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt))\n\t\t\tbreak;\n\tcase TCP_FIN_WAIT1:\n\tcase TCP_FIN_WAIT2:\n\t\t/* RFC 793 says to queue data in these states,\n\t\t * RFC 1122 says we MUST send a reset.\n\t\t * BSD 4.4 also does reset.\n\t\t */\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t\t\t    after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt)) {\n\t\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t\t\t\ttcp_reset(sk);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t/* Fall through */\n\tcase TCP_ESTABLISHED:\n\t\ttcp_data_queue(sk, skb);\n\t\tqueued = 1;\n\t\tbreak;\n\t}\n\n\t/* tcp_data could move socket to TIME-WAIT */\n\tif (sk->sk_state != TCP_CLOSE) {\n\t\ttcp_data_snd_check(sk);\n\t\ttcp_ack_snd_check(sk);\n\t}\n\n\tif (!queued) {\ndiscard:\n\t\t__kfree_skb(skb);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_rcv_state_process);\n\nstatic inline void pr_drop_req(struct request_sock *req, __u16 port, int family)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\tif (family == AF_INET)\n\t\tnet_dbg_ratelimited(\"drop open request from %pI4/%u\\n\",\n\t\t\t\t    &ireq->ir_rmt_addr, port);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (family == AF_INET6)\n\t\tnet_dbg_ratelimited(\"drop open request from %pI6/%u\\n\",\n\t\t\t\t    &ireq->ir_v6_rmt_addr, port);\n#endif\n}\n\n/* RFC3168 : 6.1.1 SYN packets must not have ECT/ECN bits set\n *\n * If we receive a SYN packet with these bits set, it means a\n * network is playing bad games with TOS bits. In order to\n * avoid possible false congestion notifications, we disable\n * TCP ECN negotiation.\n *\n * Exception: tcp_ca wants ECN. This is required for DCTCP\n * congestion control: Linux DCTCP asserts ECT on all packets,\n * including SYN, which is most optimal solution; however,\n * others, such as FreeBSD do not.\n */\nstatic void tcp_ecn_create_request(struct request_sock *req,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   const struct sock *listen_sk,\n\t\t\t\t   const struct dst_entry *dst)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tconst struct net *net = sock_net(listen_sk);\n\tbool th_ecn = th->ece && th->cwr;\n\tbool ect, ecn_ok;\n\tu32 ecn_ok_dst;\n\n\tif (!th_ecn)\n\t\treturn;\n\n\tect = !INET_ECN_is_not_ect(TCP_SKB_CB(skb)->ip_dsfield);\n\tecn_ok_dst = dst_feature(dst, DST_FEATURE_ECN_MASK);\n\tecn_ok = net->ipv4.sysctl_tcp_ecn || ecn_ok_dst;\n\n\tif ((!ect && ecn_ok) || tcp_ca_needs_ecn(listen_sk) ||\n\t    (ecn_ok_dst & DST_FEATURE_ECN_CA))\n\t\tinet_rsk(req)->ecn_ok = 1;\n}\n\nstatic void tcp_openreq_init(struct request_sock *req,\n\t\t\t     const struct tcp_options_received *rx_opt,\n\t\t\t     struct sk_buff *skb, const struct sock *sk)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\treq->rsk_rcv_wnd = 0;\t\t/* So that tcp_send_synack() knows! */\n\treq->cookie_ts = 0;\n\ttcp_rsk(req)->rcv_isn = TCP_SKB_CB(skb)->seq;\n\ttcp_rsk(req)->rcv_nxt = TCP_SKB_CB(skb)->seq + 1;\n\tskb_mstamp_get(&tcp_rsk(req)->snt_synack);\n\ttcp_rsk(req)->last_oow_ack_time = 0;\n\treq->mss = rx_opt->mss_clamp;\n\treq->ts_recent = rx_opt->saw_tstamp ? rx_opt->rcv_tsval : 0;\n\tireq->tstamp_ok = rx_opt->tstamp_ok;\n\tireq->sack_ok = rx_opt->sack_ok;\n\tireq->snd_wscale = rx_opt->snd_wscale;\n\tireq->wscale_ok = rx_opt->wscale_ok;\n\tireq->acked = 0;\n\tireq->ecn_ok = 0;\n\tireq->ir_rmt_port = tcp_hdr(skb)->source;\n\tireq->ir_num = ntohs(tcp_hdr(skb)->dest);\n\tireq->ir_mark = inet_request_mark(sk, skb);\n}\n\nstruct request_sock *inet_reqsk_alloc(const struct request_sock_ops *ops,\n\t\t\t\t      struct sock *sk_listener,\n\t\t\t\t      bool attach_listener)\n{\n\tstruct request_sock *req = reqsk_alloc(ops, sk_listener,\n\t\t\t\t\t       attach_listener);\n\n\tif (req) {\n\t\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\t\tkmemcheck_annotate_bitfield(ireq, flags);\n\t\tireq->opt = NULL;\n\t\tatomic64_set(&ireq->ir_cookie, 0);\n\t\tireq->ireq_state = TCP_NEW_SYN_RECV;\n\t\twrite_pnet(&ireq->ireq_net, sock_net(sk_listener));\n\t\tireq->ireq_family = sk_listener->sk_family;\n\t}\n\n\treturn req;\n}\nEXPORT_SYMBOL(inet_reqsk_alloc);\n\n/*\n * Return true if a syncookie should be sent\n */\nstatic bool tcp_syn_flood_action(const struct sock *sk,\n\t\t\t\t const struct sk_buff *skb,\n\t\t\t\t const char *proto)\n{\n\tstruct request_sock_queue *queue = &inet_csk(sk)->icsk_accept_queue;\n\tconst char *msg = \"Dropping request\";\n\tbool want_cookie = false;\n\n#ifdef CONFIG_SYN_COOKIES\n\tif (sysctl_tcp_syncookies) {\n\t\tmsg = \"Sending cookies\";\n\t\twant_cookie = true;\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPREQQFULLDOCOOKIES);\n\t} else\n#endif\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPREQQFULLDROP);\n\n\tif (!queue->synflood_warned &&\n\t    sysctl_tcp_syncookies != 2 &&\n\t    xchg(&queue->synflood_warned, 1) == 0)\n\t\tpr_info(\"%s: Possible SYN flooding on port %d. %s.  Check SNMP counters.\\n\",\n\t\t\tproto, ntohs(tcp_hdr(skb)->dest), msg);\n\n\treturn want_cookie;\n}\n\nstatic void tcp_reqsk_record_syn(const struct sock *sk,\n\t\t\t\t struct request_sock *req,\n\t\t\t\t const struct sk_buff *skb)\n{\n\tif (tcp_sk(sk)->save_syn) {\n\t\tu32 len = skb_network_header_len(skb) + tcp_hdrlen(skb);\n\t\tu32 *copy;\n\n\t\tcopy = kmalloc(len + sizeof(u32), GFP_ATOMIC);\n\t\tif (copy) {\n\t\t\tcopy[0] = len;\n\t\t\tmemcpy(&copy[1], skb_network_header(skb), len);\n\t\t\treq->saved_syn = copy;\n\t\t}\n\t}\n}\n\nint tcp_conn_request(struct request_sock_ops *rsk_ops,\n\t\t     const struct tcp_request_sock_ops *af_ops,\n\t\t     struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_fastopen_cookie foc = { .len = -1 };\n\t__u32 isn = TCP_SKB_CB(skb)->tcp_tw_isn;\n\tstruct tcp_options_received tmp_opt;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sock *fastopen_sk = NULL;\n\tstruct dst_entry *dst = NULL;\n\tstruct request_sock *req;\n\tbool want_cookie = false;\n\tstruct flowi fl;\n\n\t/* TW buckets are converted to open requests without\n\t * limitations, they conserve resources and peer is\n\t * evidently real one.\n\t */\n\tif ((sysctl_tcp_syncookies == 2 ||\n\t     inet_csk_reqsk_queue_is_full(sk)) && !isn) {\n\t\twant_cookie = tcp_syn_flood_action(sk, skb, rsk_ops->slab_name);\n\t\tif (!want_cookie)\n\t\t\tgoto drop;\n\t}\n\n\n\t/* Accept backlog is full. If we have already queued enough\n\t * of warm entries in syn queue, drop request. It is better than\n\t * clogging syn queue with openreqs with exponentially increasing\n\t * timeout.\n\t */\n\tif (sk_acceptq_is_full(sk) && inet_csk_reqsk_queue_young(sk) > 1) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\n\t\tgoto drop;\n\t}\n\n\treq = inet_reqsk_alloc(rsk_ops, sk, !want_cookie);\n\tif (!req)\n\t\tgoto drop;\n\n\ttcp_rsk(req)->af_specific = af_ops;\n\n\ttcp_clear_options(&tmp_opt);\n\ttmp_opt.mss_clamp = af_ops->mss_clamp;\n\ttmp_opt.user_mss  = tp->rx_opt.user_mss;\n\ttcp_parse_options(skb, &tmp_opt, 0, want_cookie ? NULL : &foc);\n\n\tif (want_cookie && !tmp_opt.saw_tstamp)\n\t\ttcp_clear_options(&tmp_opt);\n\n\ttmp_opt.tstamp_ok = tmp_opt.saw_tstamp;\n\ttcp_openreq_init(req, &tmp_opt, skb, sk);\n\n\t/* Note: tcp_v6_init_req() might override ir_iif for link locals */\n\tinet_rsk(req)->ir_iif = sk->sk_bound_dev_if;\n\n\taf_ops->init_req(req, sk, skb);\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto drop_and_free;\n\n\tif (!want_cookie && !isn) {\n\t\t/* VJ's idea. We save last timestamp seen\n\t\t * from the destination in peer table, when entering\n\t\t * state TIME-WAIT, and check against it before\n\t\t * accepting new connection request.\n\t\t *\n\t\t * If \"isn\" is not zero, this request hit alive\n\t\t * timewait bucket, so that all the necessary checks\n\t\t * are made in the function processing timewait state.\n\t\t */\n\t\tif (tcp_death_row.sysctl_tw_recycle) {\n\t\t\tbool strict;\n\n\t\t\tdst = af_ops->route_req(sk, &fl, req, &strict);\n\n\t\t\tif (dst && strict &&\n\t\t\t    !tcp_peer_is_proven(req, dst, true,\n\t\t\t\t\t\ttmp_opt.saw_tstamp)) {\n\t\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSPASSIVEREJECTED);\n\t\t\t\tgoto drop_and_release;\n\t\t\t}\n\t\t}\n\t\t/* Kill the following clause, if you dislike this way. */\n\t\telse if (!sysctl_tcp_syncookies &&\n\t\t\t (sysctl_max_syn_backlog - inet_csk_reqsk_queue_len(sk) <\n\t\t\t  (sysctl_max_syn_backlog >> 2)) &&\n\t\t\t !tcp_peer_is_proven(req, dst, false,\n\t\t\t\t\t     tmp_opt.saw_tstamp)) {\n\t\t\t/* Without syncookies last quarter of\n\t\t\t * backlog is filled with destinations,\n\t\t\t * proven to be alive.\n\t\t\t * It means that we continue to communicate\n\t\t\t * to destinations, already remembered\n\t\t\t * to the moment of synflood.\n\t\t\t */\n\t\t\tpr_drop_req(req, ntohs(tcp_hdr(skb)->source),\n\t\t\t\t    rsk_ops->family);\n\t\t\tgoto drop_and_release;\n\t\t}\n\n\t\tisn = af_ops->init_seq(skb);\n\t}\n\tif (!dst) {\n\t\tdst = af_ops->route_req(sk, &fl, req, NULL);\n\t\tif (!dst)\n\t\t\tgoto drop_and_free;\n\t}\n\n\ttcp_ecn_create_request(req, skb, sk, dst);\n\n\tif (want_cookie) {\n\t\tisn = cookie_init_sequence(af_ops, sk, skb, &req->mss);\n\t\treq->cookie_ts = tmp_opt.tstamp_ok;\n\t\tif (!tmp_opt.tstamp_ok)\n\t\t\tinet_rsk(req)->ecn_ok = 0;\n\t}\n\n\ttcp_rsk(req)->snt_isn = isn;\n\ttcp_rsk(req)->txhash = net_tx_rndhash();\n\ttcp_openreq_init_rwin(req, sk, dst);\n\tif (!want_cookie) {\n\t\ttcp_reqsk_record_syn(sk, req, skb);\n\t\tfastopen_sk = tcp_try_fastopen(sk, skb, req, &foc, dst);\n\t}\n\tif (fastopen_sk) {\n\t\taf_ops->send_synack(fastopen_sk, dst, &fl, req,\n\t\t\t\t    &foc, false);\n\t\t/* Add the child socket directly into the accept queue */\n\t\tinet_csk_reqsk_queue_add(sk, req, fastopen_sk);\n\t\tsk->sk_data_ready(sk);\n\t\tbh_unlock_sock(fastopen_sk);\n\t\tsock_put(fastopen_sk);\n\t} else {\n\t\ttcp_rsk(req)->tfo_listener = false;\n\t\tif (!want_cookie)\n\t\t\tinet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);\n\t\taf_ops->send_synack(sk, dst, &fl, req,\n\t\t\t\t    &foc, !want_cookie);\n\t\tif (want_cookie)\n\t\t\tgoto drop_and_free;\n\t}\n\treqsk_put(req);\n\treturn 0;\n\ndrop_and_release:\n\tdst_release(dst);\ndrop_and_free:\n\treqsk_free(req);\ndrop:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_conn_request);\n"], "fixing_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tImplementation of the Transmission Control Protocol(TCP).\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\t\tMark Evans, <evansmp@uhura.aston.ac.uk>\n *\t\tCorey Minyard <wf-rch!minyard@relay.EU.net>\n *\t\tFlorian La Roche, <flla@stud.uni-sb.de>\n *\t\tCharles Hedrick, <hedrick@klinzhai.rutgers.edu>\n *\t\tLinus Torvalds, <torvalds@cs.helsinki.fi>\n *\t\tAlan Cox, <gw4pts@gw4pts.ampr.org>\n *\t\tMatthew Dillon, <dillon@apollo.west.oic.com>\n *\t\tArnt Gulbrandsen, <agulbra@nvg.unit.no>\n *\t\tJorge Cwik, <jorge@laser.satlink.net>\n */\n\n/*\n * Changes:\n *\t\tPedro Roque\t:\tFast Retransmit/Recovery.\n *\t\t\t\t\tTwo receive queues.\n *\t\t\t\t\tRetransmit queue handled by TCP.\n *\t\t\t\t\tBetter retransmit timer handling.\n *\t\t\t\t\tNew congestion avoidance.\n *\t\t\t\t\tHeader prediction.\n *\t\t\t\t\tVariable renaming.\n *\n *\t\tEric\t\t:\tFast Retransmit.\n *\t\tRandy Scott\t:\tMSS option defines.\n *\t\tEric Schenk\t:\tFixes to slow start algorithm.\n *\t\tEric Schenk\t:\tYet another double ACK bug.\n *\t\tEric Schenk\t:\tDelayed ACK bug fixes.\n *\t\tEric Schenk\t:\tFloyd style fast retrans war avoidance.\n *\t\tDavid S. Miller\t:\tDon't allow zero congestion window.\n *\t\tEric Schenk\t:\tFix retransmitter so that it sends\n *\t\t\t\t\tnext packet on ack of previous packet.\n *\t\tAndi Kleen\t:\tMoved open_request checking here\n *\t\t\t\t\tand process RSTs for open_requests.\n *\t\tAndi Kleen\t:\tBetter prune_queue, and other fixes.\n *\t\tAndrey Savochkin:\tFix RTT measurements in the presence of\n *\t\t\t\t\ttimestamps.\n *\t\tAndrey Savochkin:\tCheck sequence numbers correctly when\n *\t\t\t\t\tremoving SACKs due to in sequence incoming\n *\t\t\t\t\tdata segments.\n *\t\tAndi Kleen:\t\tMake sure we never ack data there is not\n *\t\t\t\t\tenough room for. Also make this condition\n *\t\t\t\t\ta fatal error if it might still happen.\n *\t\tAndi Kleen:\t\tAdd tcp_measure_rcv_mss to make\n *\t\t\t\t\tconnections with MSS<min(MTU,ann. MSS)\n *\t\t\t\t\twork without delayed acks.\n *\t\tAndi Kleen:\t\tProcess packets with PSH set in the\n *\t\t\t\t\tfast path.\n *\t\tJ Hadi Salim:\t\tECN support\n *\t \tAndrei Gurtov,\n *\t\tPasi Sarolahti,\n *\t\tPanu Kuhlberg:\t\tExperimental audit of TCP (re)transmission\n *\t\t\t\t\tengine. Lots of bugs are found.\n *\t\tPasi Sarolahti:\t\tF-RTO for dealing with spurious RTOs\n */\n\n#define pr_fmt(fmt) \"TCP: \" fmt\n\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/sysctl.h>\n#include <linux/kernel.h>\n#include <linux/prefetch.h>\n#include <net/dst.h>\n#include <net/tcp.h>\n#include <net/inet_common.h>\n#include <linux/ipsec.h>\n#include <asm/unaligned.h>\n#include <linux/errqueue.h>\n\nint sysctl_tcp_timestamps __read_mostly = 1;\nint sysctl_tcp_window_scaling __read_mostly = 1;\nint sysctl_tcp_sack __read_mostly = 1;\nint sysctl_tcp_fack __read_mostly = 1;\nint sysctl_tcp_reordering __read_mostly = TCP_FASTRETRANS_THRESH;\nint sysctl_tcp_max_reordering __read_mostly = 300;\nEXPORT_SYMBOL(sysctl_tcp_reordering);\nint sysctl_tcp_dsack __read_mostly = 1;\nint sysctl_tcp_app_win __read_mostly = 31;\nint sysctl_tcp_adv_win_scale __read_mostly = 1;\nEXPORT_SYMBOL(sysctl_tcp_adv_win_scale);\n\n/* rfc5961 challenge ack rate limiting */\nint sysctl_tcp_challenge_ack_limit = 100;\n\nint sysctl_tcp_stdurg __read_mostly;\nint sysctl_tcp_rfc1337 __read_mostly;\nint sysctl_tcp_max_orphans __read_mostly = NR_FILE;\nint sysctl_tcp_frto __read_mostly = 2;\nint sysctl_tcp_min_rtt_wlen __read_mostly = 300;\n\nint sysctl_tcp_thin_dupack __read_mostly;\n\nint sysctl_tcp_moderate_rcvbuf __read_mostly = 1;\nint sysctl_tcp_early_retrans __read_mostly = 3;\nint sysctl_tcp_invalid_ratelimit __read_mostly = HZ/2;\n\n#define FLAG_DATA\t\t0x01 /* Incoming frame contained data.\t\t*/\n#define FLAG_WIN_UPDATE\t\t0x02 /* Incoming ACK was a window update.\t*/\n#define FLAG_DATA_ACKED\t\t0x04 /* This ACK acknowledged new data.\t\t*/\n#define FLAG_RETRANS_DATA_ACKED\t0x08 /* \"\" \"\" some of which was retransmitted.\t*/\n#define FLAG_SYN_ACKED\t\t0x10 /* This ACK acknowledged SYN.\t\t*/\n#define FLAG_DATA_SACKED\t0x20 /* New SACK.\t\t\t\t*/\n#define FLAG_ECE\t\t0x40 /* ECE in this ACK\t\t\t\t*/\n#define FLAG_LOST_RETRANS\t0x80 /* This ACK marks some retransmission lost */\n#define FLAG_SLOWPATH\t\t0x100 /* Do not skip RFC checks for window update.*/\n#define FLAG_ORIG_SACK_ACKED\t0x200 /* Never retransmitted data are (s)acked\t*/\n#define FLAG_SND_UNA_ADVANCED\t0x400 /* Snd_una was changed (!= FLAG_DATA_ACKED) */\n#define FLAG_DSACKING_ACK\t0x800 /* SACK blocks contained D-SACK info */\n#define FLAG_SACK_RENEGING\t0x2000 /* snd_una advanced to a sacked seq */\n#define FLAG_UPDATE_TS_RECENT\t0x4000 /* tcp_replace_ts_recent() */\n\n#define FLAG_ACKED\t\t(FLAG_DATA_ACKED|FLAG_SYN_ACKED)\n#define FLAG_NOT_DUP\t\t(FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)\n#define FLAG_CA_ALERT\t\t(FLAG_DATA_SACKED|FLAG_ECE)\n#define FLAG_FORWARD_PROGRESS\t(FLAG_ACKED|FLAG_DATA_SACKED)\n\n#define TCP_REMNANT (TCP_FLAG_FIN|TCP_FLAG_URG|TCP_FLAG_SYN|TCP_FLAG_PSH)\n#define TCP_HP_BITS (~(TCP_RESERVED_BITS|TCP_FLAG_PSH))\n\n/* Adapt the MSS value used to make delayed ack decision to the\n * real world.\n */\nstatic void tcp_measure_rcv_mss(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tconst unsigned int lss = icsk->icsk_ack.last_seg_size;\n\tunsigned int len;\n\n\ticsk->icsk_ack.last_seg_size = 0;\n\n\t/* skb->len may jitter because of SACKs, even if peer\n\t * sends good full-sized frames.\n\t */\n\tlen = skb_shinfo(skb)->gso_size ? : skb->len;\n\tif (len >= icsk->icsk_ack.rcv_mss) {\n\t\ticsk->icsk_ack.rcv_mss = len;\n\t} else {\n\t\t/* Otherwise, we make more careful check taking into account,\n\t\t * that SACKs block is variable.\n\t\t *\n\t\t * \"len\" is invariant segment length, including TCP header.\n\t\t */\n\t\tlen += skb->data - skb_transport_header(skb);\n\t\tif (len >= TCP_MSS_DEFAULT + sizeof(struct tcphdr) ||\n\t\t    /* If PSH is not set, packet should be\n\t\t     * full sized, provided peer TCP is not badly broken.\n\t\t     * This observation (if it is correct 8)) allows\n\t\t     * to handle super-low mtu links fairly.\n\t\t     */\n\t\t    (len >= TCP_MIN_MSS + sizeof(struct tcphdr) &&\n\t\t     !(tcp_flag_word(tcp_hdr(skb)) & TCP_REMNANT))) {\n\t\t\t/* Subtract also invariant (if peer is RFC compliant),\n\t\t\t * tcp header plus fixed timestamp option length.\n\t\t\t * Resulting \"len\" is MSS free of SACK jitter.\n\t\t\t */\n\t\t\tlen -= tcp_sk(sk)->tcp_header_len;\n\t\t\ticsk->icsk_ack.last_seg_size = len;\n\t\t\tif (len == lss) {\n\t\t\t\ticsk->icsk_ack.rcv_mss = len;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (icsk->icsk_ack.pending & ICSK_ACK_PUSHED)\n\t\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED2;\n\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED;\n\t}\n}\n\nstatic void tcp_incr_quickack(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tunsigned int quickacks = tcp_sk(sk)->rcv_wnd / (2 * icsk->icsk_ack.rcv_mss);\n\n\tif (quickacks == 0)\n\t\tquickacks = 2;\n\tif (quickacks > icsk->icsk_ack.quick)\n\t\ticsk->icsk_ack.quick = min(quickacks, TCP_MAX_QUICKACKS);\n}\n\nstatic void tcp_enter_quickack_mode(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\ttcp_incr_quickack(sk);\n\ticsk->icsk_ack.pingpong = 0;\n\ticsk->icsk_ack.ato = TCP_ATO_MIN;\n}\n\n/* Send ACKs quickly, if \"quick\" count is not exhausted\n * and the session is not interactive.\n */\n\nstatic bool tcp_in_quickack_mode(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\n\treturn (dst && dst_metric(dst, RTAX_QUICKACK)) ||\n\t\t(icsk->icsk_ack.quick && !icsk->icsk_ack.pingpong);\n}\n\nstatic void tcp_ecn_queue_cwr(struct tcp_sock *tp)\n{\n\tif (tp->ecn_flags & TCP_ECN_OK)\n\t\ttp->ecn_flags |= TCP_ECN_QUEUE_CWR;\n}\n\nstatic void tcp_ecn_accept_cwr(struct tcp_sock *tp, const struct sk_buff *skb)\n{\n\tif (tcp_hdr(skb)->cwr)\n\t\ttp->ecn_flags &= ~TCP_ECN_DEMAND_CWR;\n}\n\nstatic void tcp_ecn_withdraw_cwr(struct tcp_sock *tp)\n{\n\ttp->ecn_flags &= ~TCP_ECN_DEMAND_CWR;\n}\n\nstatic void __tcp_ecn_check_ce(struct tcp_sock *tp, const struct sk_buff *skb)\n{\n\tswitch (TCP_SKB_CB(skb)->ip_dsfield & INET_ECN_MASK) {\n\tcase INET_ECN_NOT_ECT:\n\t\t/* Funny extension: if ECT is not set on a segment,\n\t\t * and we already seen ECT on a previous segment,\n\t\t * it is probably a retransmit.\n\t\t */\n\t\tif (tp->ecn_flags & TCP_ECN_SEEN)\n\t\t\ttcp_enter_quickack_mode((struct sock *)tp);\n\t\tbreak;\n\tcase INET_ECN_CE:\n\t\tif (tcp_ca_needs_ecn((struct sock *)tp))\n\t\t\ttcp_ca_event((struct sock *)tp, CA_EVENT_ECN_IS_CE);\n\n\t\tif (!(tp->ecn_flags & TCP_ECN_DEMAND_CWR)) {\n\t\t\t/* Better not delay acks, sender can have a very low cwnd */\n\t\t\ttcp_enter_quickack_mode((struct sock *)tp);\n\t\t\ttp->ecn_flags |= TCP_ECN_DEMAND_CWR;\n\t\t}\n\t\ttp->ecn_flags |= TCP_ECN_SEEN;\n\t\tbreak;\n\tdefault:\n\t\tif (tcp_ca_needs_ecn((struct sock *)tp))\n\t\t\ttcp_ca_event((struct sock *)tp, CA_EVENT_ECN_NO_CE);\n\t\ttp->ecn_flags |= TCP_ECN_SEEN;\n\t\tbreak;\n\t}\n}\n\nstatic void tcp_ecn_check_ce(struct tcp_sock *tp, const struct sk_buff *skb)\n{\n\tif (tp->ecn_flags & TCP_ECN_OK)\n\t\t__tcp_ecn_check_ce(tp, skb);\n}\n\nstatic void tcp_ecn_rcv_synack(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tif ((tp->ecn_flags & TCP_ECN_OK) && (!th->ece || th->cwr))\n\t\ttp->ecn_flags &= ~TCP_ECN_OK;\n}\n\nstatic void tcp_ecn_rcv_syn(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tif ((tp->ecn_flags & TCP_ECN_OK) && (!th->ece || !th->cwr))\n\t\ttp->ecn_flags &= ~TCP_ECN_OK;\n}\n\nstatic bool tcp_ecn_rcv_ecn_echo(const struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tif (th->ece && !th->syn && (tp->ecn_flags & TCP_ECN_OK))\n\t\treturn true;\n\treturn false;\n}\n\n/* Buffer size and advertised window tuning.\n *\n * 1. Tuning sk->sk_sndbuf, when connection enters established state.\n */\n\nstatic void tcp_sndbuf_expand(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tint sndmem, per_mss;\n\tu32 nr_segs;\n\n\t/* Worst case is non GSO/TSO : each frame consumes one skb\n\t * and skb->head is kmalloced using power of two area of memory\n\t */\n\tper_mss = max_t(u32, tp->rx_opt.mss_clamp, tp->mss_cache) +\n\t\t  MAX_TCP_HEADER +\n\t\t  SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\tper_mss = roundup_pow_of_two(per_mss) +\n\t\t  SKB_DATA_ALIGN(sizeof(struct sk_buff));\n\n\tnr_segs = max_t(u32, TCP_INIT_CWND, tp->snd_cwnd);\n\tnr_segs = max_t(u32, nr_segs, tp->reordering + 1);\n\n\t/* Fast Recovery (RFC 5681 3.2) :\n\t * Cubic needs 1.7 factor, rounded to 2 to include\n\t * extra cushion (application might react slowly to POLLOUT)\n\t */\n\tsndmem = 2 * nr_segs * per_mss;\n\n\tif (sk->sk_sndbuf < sndmem)\n\t\tsk->sk_sndbuf = min(sndmem, sysctl_tcp_wmem[2]);\n}\n\n/* 2. Tuning advertised window (window_clamp, rcv_ssthresh)\n *\n * All tcp_full_space() is split to two parts: \"network\" buffer, allocated\n * forward and advertised in receiver window (tp->rcv_wnd) and\n * \"application buffer\", required to isolate scheduling/application\n * latencies from network.\n * window_clamp is maximal advertised window. It can be less than\n * tcp_full_space(), in this case tcp_full_space() - window_clamp\n * is reserved for \"application\" buffer. The less window_clamp is\n * the smoother our behaviour from viewpoint of network, but the lower\n * throughput and the higher sensitivity of the connection to losses. 8)\n *\n * rcv_ssthresh is more strict window_clamp used at \"slow start\"\n * phase to predict further behaviour of this connection.\n * It is used for two goals:\n * - to enforce header prediction at sender, even when application\n *   requires some significant \"application buffer\". It is check #1.\n * - to prevent pruning of receive queue because of misprediction\n *   of receiver window. Check #2.\n *\n * The scheme does not work when sender sends good segments opening\n * window and then starts to feed us spaghetti. But it should work\n * in common situations. Otherwise, we have to rely on queue collapsing.\n */\n\n/* Slow part of check#2. */\nstatic int __tcp_grow_window(const struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t/* Optimize this! */\n\tint truesize = tcp_win_from_space(skb->truesize) >> 1;\n\tint window = tcp_win_from_space(sysctl_tcp_rmem[2]) >> 1;\n\n\twhile (tp->rcv_ssthresh <= window) {\n\t\tif (truesize <= skb->len)\n\t\t\treturn 2 * inet_csk(sk)->icsk_ack.rcv_mss;\n\n\t\ttruesize >>= 1;\n\t\twindow >>= 1;\n\t}\n\treturn 0;\n}\n\nstatic void tcp_grow_window(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Check #1 */\n\tif (tp->rcv_ssthresh < tp->window_clamp &&\n\t    (int)tp->rcv_ssthresh < tcp_space(sk) &&\n\t    !tcp_under_memory_pressure(sk)) {\n\t\tint incr;\n\n\t\t/* Check #2. Increase window, if skb with such overhead\n\t\t * will fit to rcvbuf in future.\n\t\t */\n\t\tif (tcp_win_from_space(skb->truesize) <= skb->len)\n\t\t\tincr = 2 * tp->advmss;\n\t\telse\n\t\t\tincr = __tcp_grow_window(sk, skb);\n\n\t\tif (incr) {\n\t\t\tincr = max_t(int, incr, 2 * skb->len);\n\t\t\ttp->rcv_ssthresh = min(tp->rcv_ssthresh + incr,\n\t\t\t\t\t       tp->window_clamp);\n\t\t\tinet_csk(sk)->icsk_ack.quick |= 1;\n\t\t}\n\t}\n}\n\n/* 3. Tuning rcvbuf, when connection enters established state. */\nstatic void tcp_fixup_rcvbuf(struct sock *sk)\n{\n\tu32 mss = tcp_sk(sk)->advmss;\n\tint rcvmem;\n\n\trcvmem = 2 * SKB_TRUESIZE(mss + MAX_TCP_HEADER) *\n\t\t tcp_default_init_rwnd(mss);\n\n\t/* Dynamic Right Sizing (DRS) has 2 to 3 RTT latency\n\t * Allow enough cushion so that sender is not limited by our window\n\t */\n\tif (sysctl_tcp_moderate_rcvbuf)\n\t\trcvmem <<= 2;\n\n\tif (sk->sk_rcvbuf < rcvmem)\n\t\tsk->sk_rcvbuf = min(rcvmem, sysctl_tcp_rmem[2]);\n}\n\n/* 4. Try to fixup all. It is made immediately after connection enters\n *    established state.\n */\nvoid tcp_init_buffer_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint maxwin;\n\n\tif (!(sk->sk_userlocks & SOCK_RCVBUF_LOCK))\n\t\ttcp_fixup_rcvbuf(sk);\n\tif (!(sk->sk_userlocks & SOCK_SNDBUF_LOCK))\n\t\ttcp_sndbuf_expand(sk);\n\n\ttp->rcvq_space.space = tp->rcv_wnd;\n\ttp->rcvq_space.time = tcp_time_stamp;\n\ttp->rcvq_space.seq = tp->copied_seq;\n\n\tmaxwin = tcp_full_space(sk);\n\n\tif (tp->window_clamp >= maxwin) {\n\t\ttp->window_clamp = maxwin;\n\n\t\tif (sysctl_tcp_app_win && maxwin > 4 * tp->advmss)\n\t\t\ttp->window_clamp = max(maxwin -\n\t\t\t\t\t       (maxwin >> sysctl_tcp_app_win),\n\t\t\t\t\t       4 * tp->advmss);\n\t}\n\n\t/* Force reservation of one segment. */\n\tif (sysctl_tcp_app_win &&\n\t    tp->window_clamp > 2 * tp->advmss &&\n\t    tp->window_clamp + tp->advmss > maxwin)\n\t\ttp->window_clamp = max(2 * tp->advmss, maxwin - tp->advmss);\n\n\ttp->rcv_ssthresh = min(tp->rcv_ssthresh, tp->window_clamp);\n\ttp->snd_cwnd_stamp = tcp_time_stamp;\n}\n\n/* 5. Recalculate window clamp after socket hit its memory bounds. */\nstatic void tcp_clamp_window(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ticsk->icsk_ack.quick = 0;\n\n\tif (sk->sk_rcvbuf < sysctl_tcp_rmem[2] &&\n\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK) &&\n\t    !tcp_under_memory_pressure(sk) &&\n\t    sk_memory_allocated(sk) < sk_prot_mem_limits(sk, 0)) {\n\t\tsk->sk_rcvbuf = min(atomic_read(&sk->sk_rmem_alloc),\n\t\t\t\t    sysctl_tcp_rmem[2]);\n\t}\n\tif (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)\n\t\ttp->rcv_ssthresh = min(tp->window_clamp, 2U * tp->advmss);\n}\n\n/* Initialize RCV_MSS value.\n * RCV_MSS is an our guess about MSS used by the peer.\n * We haven't any direct information about the MSS.\n * It's better to underestimate the RCV_MSS rather than overestimate.\n * Overestimations make us ACKing less frequently than needed.\n * Underestimations are more easy to detect and fix by tcp_measure_rcv_mss().\n */\nvoid tcp_initialize_rcv_mss(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tunsigned int hint = min_t(unsigned int, tp->advmss, tp->mss_cache);\n\n\thint = min(hint, tp->rcv_wnd / 2);\n\thint = min(hint, TCP_MSS_DEFAULT);\n\thint = max(hint, TCP_MIN_MSS);\n\n\tinet_csk(sk)->icsk_ack.rcv_mss = hint;\n}\nEXPORT_SYMBOL(tcp_initialize_rcv_mss);\n\n/* Receiver \"autotuning\" code.\n *\n * The algorithm for RTT estimation w/o timestamps is based on\n * Dynamic Right-Sizing (DRS) by Wu Feng and Mike Fisk of LANL.\n * <http://public.lanl.gov/radiant/pubs.html#DRS>\n *\n * More detail on this code can be found at\n * <http://staff.psc.edu/jheffner/>,\n * though this reference is out of date.  A new paper\n * is pending.\n */\nstatic void tcp_rcv_rtt_update(struct tcp_sock *tp, u32 sample, int win_dep)\n{\n\tu32 new_sample = tp->rcv_rtt_est.rtt;\n\tlong m = sample;\n\n\tif (m == 0)\n\t\tm = 1;\n\n\tif (new_sample != 0) {\n\t\t/* If we sample in larger samples in the non-timestamp\n\t\t * case, we could grossly overestimate the RTT especially\n\t\t * with chatty applications or bulk transfer apps which\n\t\t * are stalled on filesystem I/O.\n\t\t *\n\t\t * Also, since we are only going for a minimum in the\n\t\t * non-timestamp case, we do not smooth things out\n\t\t * else with timestamps disabled convergence takes too\n\t\t * long.\n\t\t */\n\t\tif (!win_dep) {\n\t\t\tm -= (new_sample >> 3);\n\t\t\tnew_sample += m;\n\t\t} else {\n\t\t\tm <<= 3;\n\t\t\tif (m < new_sample)\n\t\t\t\tnew_sample = m;\n\t\t}\n\t} else {\n\t\t/* No previous measure. */\n\t\tnew_sample = m << 3;\n\t}\n\n\tif (tp->rcv_rtt_est.rtt != new_sample)\n\t\ttp->rcv_rtt_est.rtt = new_sample;\n}\n\nstatic inline void tcp_rcv_rtt_measure(struct tcp_sock *tp)\n{\n\tif (tp->rcv_rtt_est.time == 0)\n\t\tgoto new_measure;\n\tif (before(tp->rcv_nxt, tp->rcv_rtt_est.seq))\n\t\treturn;\n\ttcp_rcv_rtt_update(tp, tcp_time_stamp - tp->rcv_rtt_est.time, 1);\n\nnew_measure:\n\ttp->rcv_rtt_est.seq = tp->rcv_nxt + tp->rcv_wnd;\n\ttp->rcv_rtt_est.time = tcp_time_stamp;\n}\n\nstatic inline void tcp_rcv_rtt_measure_ts(struct sock *sk,\n\t\t\t\t\t  const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (tp->rx_opt.rcv_tsecr &&\n\t    (TCP_SKB_CB(skb)->end_seq -\n\t     TCP_SKB_CB(skb)->seq >= inet_csk(sk)->icsk_ack.rcv_mss))\n\t\ttcp_rcv_rtt_update(tp, tcp_time_stamp - tp->rx_opt.rcv_tsecr, 0);\n}\n\n/*\n * This function should be called every time data is copied to user space.\n * It calculates the appropriate TCP receive buffer space.\n */\nvoid tcp_rcv_space_adjust(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint time;\n\tint copied;\n\n\ttime = tcp_time_stamp - tp->rcvq_space.time;\n\tif (time < (tp->rcv_rtt_est.rtt >> 3) || tp->rcv_rtt_est.rtt == 0)\n\t\treturn;\n\n\t/* Number of bytes copied to user in last RTT */\n\tcopied = tp->copied_seq - tp->rcvq_space.seq;\n\tif (copied <= tp->rcvq_space.space)\n\t\tgoto new_measure;\n\n\t/* A bit of theory :\n\t * copied = bytes received in previous RTT, our base window\n\t * To cope with packet losses, we need a 2x factor\n\t * To cope with slow start, and sender growing its cwin by 100 %\n\t * every RTT, we need a 4x factor, because the ACK we are sending\n\t * now is for the next RTT, not the current one :\n\t * <prev RTT . ><current RTT .. ><next RTT .... >\n\t */\n\n\tif (sysctl_tcp_moderate_rcvbuf &&\n\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\tint rcvwin, rcvmem, rcvbuf;\n\n\t\t/* minimal window to cope with packet losses, assuming\n\t\t * steady state. Add some cushion because of small variations.\n\t\t */\n\t\trcvwin = (copied << 1) + 16 * tp->advmss;\n\n\t\t/* If rate increased by 25%,\n\t\t *\tassume slow start, rcvwin = 3 * copied\n\t\t * If rate increased by 50%,\n\t\t *\tassume sender can use 2x growth, rcvwin = 4 * copied\n\t\t */\n\t\tif (copied >=\n\t\t    tp->rcvq_space.space + (tp->rcvq_space.space >> 2)) {\n\t\t\tif (copied >=\n\t\t\t    tp->rcvq_space.space + (tp->rcvq_space.space >> 1))\n\t\t\t\trcvwin <<= 1;\n\t\t\telse\n\t\t\t\trcvwin += (rcvwin >> 1);\n\t\t}\n\n\t\trcvmem = SKB_TRUESIZE(tp->advmss + MAX_TCP_HEADER);\n\t\twhile (tcp_win_from_space(rcvmem) < tp->advmss)\n\t\t\trcvmem += 128;\n\n\t\trcvbuf = min(rcvwin / tp->advmss * rcvmem, sysctl_tcp_rmem[2]);\n\t\tif (rcvbuf > sk->sk_rcvbuf) {\n\t\t\tsk->sk_rcvbuf = rcvbuf;\n\n\t\t\t/* Make the window clamp follow along.  */\n\t\t\ttp->window_clamp = rcvwin;\n\t\t}\n\t}\n\ttp->rcvq_space.space = copied;\n\nnew_measure:\n\ttp->rcvq_space.seq = tp->copied_seq;\n\ttp->rcvq_space.time = tcp_time_stamp;\n}\n\n/* There is something which you must keep in mind when you analyze the\n * behavior of the tp->ato delayed ack timeout interval.  When a\n * connection starts up, we want to ack as quickly as possible.  The\n * problem is that \"good\" TCP's do slow start at the beginning of data\n * transmission.  The means that until we send the first few ACK's the\n * sender will sit on his end and only queue most of his data, because\n * he can only send snd_cwnd unacked packets at any given time.  For\n * each ACK we send, he increments snd_cwnd and transmits more of his\n * queue.  -DaveM\n */\nstatic void tcp_event_data_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tu32 now;\n\n\tinet_csk_schedule_ack(sk);\n\n\ttcp_measure_rcv_mss(sk, skb);\n\n\ttcp_rcv_rtt_measure(tp);\n\n\tnow = tcp_time_stamp;\n\n\tif (!icsk->icsk_ack.ato) {\n\t\t/* The _first_ data packet received, initialize\n\t\t * delayed ACK engine.\n\t\t */\n\t\ttcp_incr_quickack(sk);\n\t\ticsk->icsk_ack.ato = TCP_ATO_MIN;\n\t} else {\n\t\tint m = now - icsk->icsk_ack.lrcvtime;\n\n\t\tif (m <= TCP_ATO_MIN / 2) {\n\t\t\t/* The fastest case is the first. */\n\t\t\ticsk->icsk_ack.ato = (icsk->icsk_ack.ato >> 1) + TCP_ATO_MIN / 2;\n\t\t} else if (m < icsk->icsk_ack.ato) {\n\t\t\ticsk->icsk_ack.ato = (icsk->icsk_ack.ato >> 1) + m;\n\t\t\tif (icsk->icsk_ack.ato > icsk->icsk_rto)\n\t\t\t\ticsk->icsk_ack.ato = icsk->icsk_rto;\n\t\t} else if (m > icsk->icsk_rto) {\n\t\t\t/* Too long gap. Apparently sender failed to\n\t\t\t * restart window, so that we send ACKs quickly.\n\t\t\t */\n\t\t\ttcp_incr_quickack(sk);\n\t\t\tsk_mem_reclaim(sk);\n\t\t}\n\t}\n\ticsk->icsk_ack.lrcvtime = now;\n\n\ttcp_ecn_check_ce(tp, skb);\n\n\tif (skb->len >= 128)\n\t\ttcp_grow_window(sk, skb);\n}\n\n/* Called to compute a smoothed rtt estimate. The data fed to this\n * routine either comes from timestamps, or from segments that were\n * known _not_ to have been retransmitted [see Karn/Partridge\n * Proceedings SIGCOMM 87]. The algorithm is from the SIGCOMM 88\n * piece by Van Jacobson.\n * NOTE: the next three routines used to be one big routine.\n * To save cycles in the RFC 1323 implementation it was better to break\n * it up into three procedures. -- erics\n */\nstatic void tcp_rtt_estimator(struct sock *sk, long mrtt_us)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tlong m = mrtt_us; /* RTT */\n\tu32 srtt = tp->srtt_us;\n\n\t/*\tThe following amusing code comes from Jacobson's\n\t *\tarticle in SIGCOMM '88.  Note that rtt and mdev\n\t *\tare scaled versions of rtt and mean deviation.\n\t *\tThis is designed to be as fast as possible\n\t *\tm stands for \"measurement\".\n\t *\n\t *\tOn a 1990 paper the rto value is changed to:\n\t *\tRTO = rtt + 4 * mdev\n\t *\n\t * Funny. This algorithm seems to be very broken.\n\t * These formulae increase RTO, when it should be decreased, increase\n\t * too slowly, when it should be increased quickly, decrease too quickly\n\t * etc. I guess in BSD RTO takes ONE value, so that it is absolutely\n\t * does not matter how to _calculate_ it. Seems, it was trap\n\t * that VJ failed to avoid. 8)\n\t */\n\tif (srtt != 0) {\n\t\tm -= (srtt >> 3);\t/* m is now error in rtt est */\n\t\tsrtt += m;\t\t/* rtt = 7/8 rtt + 1/8 new */\n\t\tif (m < 0) {\n\t\t\tm = -m;\t\t/* m is now abs(error) */\n\t\t\tm -= (tp->mdev_us >> 2);   /* similar update on mdev */\n\t\t\t/* This is similar to one of Eifel findings.\n\t\t\t * Eifel blocks mdev updates when rtt decreases.\n\t\t\t * This solution is a bit different: we use finer gain\n\t\t\t * for mdev in this case (alpha*beta).\n\t\t\t * Like Eifel it also prevents growth of rto,\n\t\t\t * but also it limits too fast rto decreases,\n\t\t\t * happening in pure Eifel.\n\t\t\t */\n\t\t\tif (m > 0)\n\t\t\t\tm >>= 3;\n\t\t} else {\n\t\t\tm -= (tp->mdev_us >> 2);   /* similar update on mdev */\n\t\t}\n\t\ttp->mdev_us += m;\t\t/* mdev = 3/4 mdev + 1/4 new */\n\t\tif (tp->mdev_us > tp->mdev_max_us) {\n\t\t\ttp->mdev_max_us = tp->mdev_us;\n\t\t\tif (tp->mdev_max_us > tp->rttvar_us)\n\t\t\t\ttp->rttvar_us = tp->mdev_max_us;\n\t\t}\n\t\tif (after(tp->snd_una, tp->rtt_seq)) {\n\t\t\tif (tp->mdev_max_us < tp->rttvar_us)\n\t\t\t\ttp->rttvar_us -= (tp->rttvar_us - tp->mdev_max_us) >> 2;\n\t\t\ttp->rtt_seq = tp->snd_nxt;\n\t\t\ttp->mdev_max_us = tcp_rto_min_us(sk);\n\t\t}\n\t} else {\n\t\t/* no previous measure. */\n\t\tsrtt = m << 3;\t\t/* take the measured time to be rtt */\n\t\ttp->mdev_us = m << 1;\t/* make sure rto = 3*rtt */\n\t\ttp->rttvar_us = max(tp->mdev_us, tcp_rto_min_us(sk));\n\t\ttp->mdev_max_us = tp->rttvar_us;\n\t\ttp->rtt_seq = tp->snd_nxt;\n\t}\n\ttp->srtt_us = max(1U, srtt);\n}\n\n/* Set the sk_pacing_rate to allow proper sizing of TSO packets.\n * Note: TCP stack does not yet implement pacing.\n * FQ packet scheduler can be used to implement cheap but effective\n * TCP pacing, to smooth the burst on large writes when packets\n * in flight is significantly lower than cwnd (or rwin)\n */\nint sysctl_tcp_pacing_ss_ratio __read_mostly = 200;\nint sysctl_tcp_pacing_ca_ratio __read_mostly = 120;\n\nstatic void tcp_update_pacing_rate(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tu64 rate;\n\n\t/* set sk_pacing_rate to 200 % of current rate (mss * cwnd / srtt) */\n\trate = (u64)tp->mss_cache * ((USEC_PER_SEC / 100) << 3);\n\n\t/* current rate is (cwnd * mss) / srtt\n\t * In Slow Start [1], set sk_pacing_rate to 200 % the current rate.\n\t * In Congestion Avoidance phase, set it to 120 % the current rate.\n\t *\n\t * [1] : Normal Slow Start condition is (tp->snd_cwnd < tp->snd_ssthresh)\n\t *\t If snd_cwnd >= (tp->snd_ssthresh / 2), we are approaching\n\t *\t end of slow start and should slow down.\n\t */\n\tif (tp->snd_cwnd < tp->snd_ssthresh / 2)\n\t\trate *= sysctl_tcp_pacing_ss_ratio;\n\telse\n\t\trate *= sysctl_tcp_pacing_ca_ratio;\n\n\trate *= max(tp->snd_cwnd, tp->packets_out);\n\n\tif (likely(tp->srtt_us))\n\t\tdo_div(rate, tp->srtt_us);\n\n\t/* ACCESS_ONCE() is needed because sch_fq fetches sk_pacing_rate\n\t * without any lock. We want to make sure compiler wont store\n\t * intermediate values in this location.\n\t */\n\tACCESS_ONCE(sk->sk_pacing_rate) = min_t(u64, rate,\n\t\t\t\t\t\tsk->sk_max_pacing_rate);\n}\n\n/* Calculate rto without backoff.  This is the second half of Van Jacobson's\n * routine referred to above.\n */\nstatic void tcp_set_rto(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\t/* Old crap is replaced with new one. 8)\n\t *\n\t * More seriously:\n\t * 1. If rtt variance happened to be less 50msec, it is hallucination.\n\t *    It cannot be less due to utterly erratic ACK generation made\n\t *    at least by solaris and freebsd. \"Erratic ACKs\" has _nothing_\n\t *    to do with delayed acks, because at cwnd>2 true delack timeout\n\t *    is invisible. Actually, Linux-2.4 also generates erratic\n\t *    ACKs in some circumstances.\n\t */\n\tinet_csk(sk)->icsk_rto = __tcp_set_rto(tp);\n\n\t/* 2. Fixups made earlier cannot be right.\n\t *    If we do not estimate RTO correctly without them,\n\t *    all the algo is pure shit and should be replaced\n\t *    with correct one. It is exactly, which we pretend to do.\n\t */\n\n\t/* NOTE: clamping at TCP_RTO_MIN is not required, current algo\n\t * guarantees that rto is higher.\n\t */\n\ttcp_bound_rto(sk);\n}\n\n__u32 tcp_init_cwnd(const struct tcp_sock *tp, const struct dst_entry *dst)\n{\n\t__u32 cwnd = (dst ? dst_metric(dst, RTAX_INITCWND) : 0);\n\n\tif (!cwnd)\n\t\tcwnd = TCP_INIT_CWND;\n\treturn min_t(__u32, cwnd, tp->snd_cwnd_clamp);\n}\n\n/*\n * Packet counting of FACK is based on in-order assumptions, therefore TCP\n * disables it when reordering is detected\n */\nvoid tcp_disable_fack(struct tcp_sock *tp)\n{\n\t/* RFC3517 uses different metric in lost marker => reset on change */\n\tif (tcp_is_fack(tp))\n\t\ttp->lost_skb_hint = NULL;\n\ttp->rx_opt.sack_ok &= ~TCP_FACK_ENABLED;\n}\n\n/* Take a notice that peer is sending D-SACKs */\nstatic void tcp_dsack_seen(struct tcp_sock *tp)\n{\n\ttp->rx_opt.sack_ok |= TCP_DSACK_SEEN;\n}\n\nstatic void tcp_update_reordering(struct sock *sk, const int metric,\n\t\t\t\t  const int ts)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (metric > tp->reordering) {\n\t\tint mib_idx;\n\n\t\ttp->reordering = min(sysctl_tcp_max_reordering, metric);\n\n\t\t/* This exciting event is worth to be remembered. 8) */\n\t\tif (ts)\n\t\t\tmib_idx = LINUX_MIB_TCPTSREORDER;\n\t\telse if (tcp_is_reno(tp))\n\t\t\tmib_idx = LINUX_MIB_TCPRENOREORDER;\n\t\telse if (tcp_is_fack(tp))\n\t\t\tmib_idx = LINUX_MIB_TCPFACKREORDER;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPSACKREORDER;\n\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n#if FASTRETRANS_DEBUG > 1\n\t\tpr_debug(\"Disorder%d %d %u f%u s%u rr%d\\n\",\n\t\t\t tp->rx_opt.sack_ok, inet_csk(sk)->icsk_ca_state,\n\t\t\t tp->reordering,\n\t\t\t tp->fackets_out,\n\t\t\t tp->sacked_out,\n\t\t\t tp->undo_marker ? tp->undo_retrans : 0);\n#endif\n\t\ttcp_disable_fack(tp);\n\t}\n\n\tif (metric > 0)\n\t\ttcp_disable_early_retrans(tp);\n\ttp->rack.reord = 1;\n}\n\n/* This must be called before lost_out is incremented */\nstatic void tcp_verify_retransmit_hint(struct tcp_sock *tp, struct sk_buff *skb)\n{\n\tif (!tp->retransmit_skb_hint ||\n\t    before(TCP_SKB_CB(skb)->seq,\n\t\t   TCP_SKB_CB(tp->retransmit_skb_hint)->seq))\n\t\ttp->retransmit_skb_hint = skb;\n\n\tif (!tp->lost_out ||\n\t    after(TCP_SKB_CB(skb)->end_seq, tp->retransmit_high))\n\t\ttp->retransmit_high = TCP_SKB_CB(skb)->end_seq;\n}\n\nstatic void tcp_skb_mark_lost(struct tcp_sock *tp, struct sk_buff *skb)\n{\n\tif (!(TCP_SKB_CB(skb)->sacked & (TCPCB_LOST|TCPCB_SACKED_ACKED))) {\n\t\ttcp_verify_retransmit_hint(tp, skb);\n\n\t\ttp->lost_out += tcp_skb_pcount(skb);\n\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_LOST;\n\t}\n}\n\nvoid tcp_skb_mark_lost_uncond_verify(struct tcp_sock *tp, struct sk_buff *skb)\n{\n\ttcp_verify_retransmit_hint(tp, skb);\n\n\tif (!(TCP_SKB_CB(skb)->sacked & (TCPCB_LOST|TCPCB_SACKED_ACKED))) {\n\t\ttp->lost_out += tcp_skb_pcount(skb);\n\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_LOST;\n\t}\n}\n\n/* This procedure tags the retransmission queue when SACKs arrive.\n *\n * We have three tag bits: SACKED(S), RETRANS(R) and LOST(L).\n * Packets in queue with these bits set are counted in variables\n * sacked_out, retrans_out and lost_out, correspondingly.\n *\n * Valid combinations are:\n * Tag  InFlight\tDescription\n * 0\t1\t\t- orig segment is in flight.\n * S\t0\t\t- nothing flies, orig reached receiver.\n * L\t0\t\t- nothing flies, orig lost by net.\n * R\t2\t\t- both orig and retransmit are in flight.\n * L|R\t1\t\t- orig is lost, retransmit is in flight.\n * S|R  1\t\t- orig reached receiver, retrans is still in flight.\n * (L|S|R is logically valid, it could occur when L|R is sacked,\n *  but it is equivalent to plain S and code short-curcuits it to S.\n *  L|S is logically invalid, it would mean -1 packet in flight 8))\n *\n * These 6 states form finite state machine, controlled by the following events:\n * 1. New ACK (+SACK) arrives. (tcp_sacktag_write_queue())\n * 2. Retransmission. (tcp_retransmit_skb(), tcp_xmit_retransmit_queue())\n * 3. Loss detection event of two flavors:\n *\tA. Scoreboard estimator decided the packet is lost.\n *\t   A'. Reno \"three dupacks\" marks head of queue lost.\n *\t   A''. Its FACK modification, head until snd.fack is lost.\n *\tB. SACK arrives sacking SND.NXT at the moment, when the\n *\t   segment was retransmitted.\n * 4. D-SACK added new rule: D-SACK changes any tag to S.\n *\n * It is pleasant to note, that state diagram turns out to be commutative,\n * so that we are allowed not to be bothered by order of our actions,\n * when multiple events arrive simultaneously. (see the function below).\n *\n * Reordering detection.\n * --------------------\n * Reordering metric is maximal distance, which a packet can be displaced\n * in packet stream. With SACKs we can estimate it:\n *\n * 1. SACK fills old hole and the corresponding segment was not\n *    ever retransmitted -> reordering. Alas, we cannot use it\n *    when segment was retransmitted.\n * 2. The last flaw is solved with D-SACK. D-SACK arrives\n *    for retransmitted and already SACKed segment -> reordering..\n * Both of these heuristics are not used in Loss state, when we cannot\n * account for retransmits accurately.\n *\n * SACK block validation.\n * ----------------------\n *\n * SACK block range validation checks that the received SACK block fits to\n * the expected sequence limits, i.e., it is between SND.UNA and SND.NXT.\n * Note that SND.UNA is not included to the range though being valid because\n * it means that the receiver is rather inconsistent with itself reporting\n * SACK reneging when it should advance SND.UNA. Such SACK block this is\n * perfectly valid, however, in light of RFC2018 which explicitly states\n * that \"SACK block MUST reflect the newest segment.  Even if the newest\n * segment is going to be discarded ...\", not that it looks very clever\n * in case of head skb. Due to potentional receiver driven attacks, we\n * choose to avoid immediate execution of a walk in write queue due to\n * reneging and defer head skb's loss recovery to standard loss recovery\n * procedure that will eventually trigger (nothing forbids us doing this).\n *\n * Implements also blockage to start_seq wrap-around. Problem lies in the\n * fact that though start_seq (s) is before end_seq (i.e., not reversed),\n * there's no guarantee that it will be before snd_nxt (n). The problem\n * happens when start_seq resides between end_seq wrap (e_w) and snd_nxt\n * wrap (s_w):\n *\n *         <- outs wnd ->                          <- wrapzone ->\n *         u     e      n                         u_w   e_w  s n_w\n *         |     |      |                          |     |   |  |\n * |<------------+------+----- TCP seqno space --------------+---------->|\n * ...-- <2^31 ->|                                           |<--------...\n * ...---- >2^31 ------>|                                    |<--------...\n *\n * Current code wouldn't be vulnerable but it's better still to discard such\n * crazy SACK blocks. Doing this check for start_seq alone closes somewhat\n * similar case (end_seq after snd_nxt wrap) as earlier reversed check in\n * snd_nxt wrap -> snd_una region will then become \"well defined\", i.e.,\n * equal to the ideal case (infinite seqno space without wrap caused issues).\n *\n * With D-SACK the lower bound is extended to cover sequence space below\n * SND.UNA down to undo_marker, which is the last point of interest. Yet\n * again, D-SACK block must not to go across snd_una (for the same reason as\n * for the normal SACK blocks, explained above). But there all simplicity\n * ends, TCP might receive valid D-SACKs below that. As long as they reside\n * fully below undo_marker they do not affect behavior in anyway and can\n * therefore be safely ignored. In rare cases (which are more or less\n * theoretical ones), the D-SACK will nicely cross that boundary due to skb\n * fragmentation and packet reordering past skb's retransmission. To consider\n * them correctly, the acceptable range must be extended even more though\n * the exact amount is rather hard to quantify. However, tp->max_window can\n * be used as an exaggerated estimate.\n */\nstatic bool tcp_is_sackblock_valid(struct tcp_sock *tp, bool is_dsack,\n\t\t\t\t   u32 start_seq, u32 end_seq)\n{\n\t/* Too far in future, or reversed (interpretation is ambiguous) */\n\tif (after(end_seq, tp->snd_nxt) || !before(start_seq, end_seq))\n\t\treturn false;\n\n\t/* Nasty start_seq wrap-around check (see comments above) */\n\tif (!before(start_seq, tp->snd_nxt))\n\t\treturn false;\n\n\t/* In outstanding window? ...This is valid exit for D-SACKs too.\n\t * start_seq == snd_una is non-sensical (see comments above)\n\t */\n\tif (after(start_seq, tp->snd_una))\n\t\treturn true;\n\n\tif (!is_dsack || !tp->undo_marker)\n\t\treturn false;\n\n\t/* ...Then it's D-SACK, and must reside below snd_una completely */\n\tif (after(end_seq, tp->snd_una))\n\t\treturn false;\n\n\tif (!before(start_seq, tp->undo_marker))\n\t\treturn true;\n\n\t/* Too old */\n\tif (!after(end_seq, tp->undo_marker))\n\t\treturn false;\n\n\t/* Undo_marker boundary crossing (overestimates a lot). Known already:\n\t *   start_seq < undo_marker and end_seq >= undo_marker.\n\t */\n\treturn !before(start_seq, end_seq - tp->max_window);\n}\n\nstatic bool tcp_check_dsack(struct sock *sk, const struct sk_buff *ack_skb,\n\t\t\t    struct tcp_sack_block_wire *sp, int num_sacks,\n\t\t\t    u32 prior_snd_una)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 start_seq_0 = get_unaligned_be32(&sp[0].start_seq);\n\tu32 end_seq_0 = get_unaligned_be32(&sp[0].end_seq);\n\tbool dup_sack = false;\n\n\tif (before(start_seq_0, TCP_SKB_CB(ack_skb)->ack_seq)) {\n\t\tdup_sack = true;\n\t\ttcp_dsack_seen(tp);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKRECV);\n\t} else if (num_sacks > 1) {\n\t\tu32 end_seq_1 = get_unaligned_be32(&sp[1].end_seq);\n\t\tu32 start_seq_1 = get_unaligned_be32(&sp[1].start_seq);\n\n\t\tif (!after(end_seq_0, end_seq_1) &&\n\t\t    !before(start_seq_0, start_seq_1)) {\n\t\t\tdup_sack = true;\n\t\t\ttcp_dsack_seen(tp);\n\t\t\tNET_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\tLINUX_MIB_TCPDSACKOFORECV);\n\t\t}\n\t}\n\n\t/* D-SACK for already forgotten data... Do dumb counting. */\n\tif (dup_sack && tp->undo_marker && tp->undo_retrans > 0 &&\n\t    !after(end_seq_0, prior_snd_una) &&\n\t    after(end_seq_0, tp->undo_marker))\n\t\ttp->undo_retrans--;\n\n\treturn dup_sack;\n}\n\nstruct tcp_sacktag_state {\n\tint\treord;\n\tint\tfack_count;\n\t/* Timestamps for earliest and latest never-retransmitted segment\n\t * that was SACKed. RTO needs the earliest RTT to stay conservative,\n\t * but congestion control should still get an accurate delay signal.\n\t */\n\tstruct skb_mstamp first_sackt;\n\tstruct skb_mstamp last_sackt;\n\tint\tflag;\n};\n\n/* Check if skb is fully within the SACK block. In presence of GSO skbs,\n * the incoming SACK may not exactly match but we can find smaller MSS\n * aligned portion of it that matches. Therefore we might need to fragment\n * which may fail and creates some hassle (caller must handle error case\n * returns).\n *\n * FIXME: this could be merged to shift decision code\n */\nstatic int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  u32 start_seq, u32 end_seq)\n{\n\tint err;\n\tbool in_sack;\n\tunsigned int pkt_len;\n\tunsigned int mss;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (tcp_skb_pcount(skb) > 1 && !in_sack &&\n\t    after(TCP_SKB_CB(skb)->end_seq, start_seq)) {\n\t\tmss = tcp_skb_mss(skb);\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\n\t\tif (!in_sack) {\n\t\t\tpkt_len = start_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\tpkt_len = mss;\n\t\t} else {\n\t\t\tpkt_len = end_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Round if necessary so that SACKs cover only full MSSes\n\t\t * and/or the remaining small portion (if present)\n\t\t */\n\t\tif (pkt_len > mss) {\n\t\t\tunsigned int new_len = (pkt_len / mss) * mss;\n\t\t\tif (!in_sack && new_len < pkt_len) {\n\t\t\t\tnew_len += mss;\n\t\t\t\tif (new_len >= skb->len)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpkt_len = new_len;\n\t\t}\n\t\terr = tcp_fragment(sk, skb, pkt_len, mss, GFP_ATOMIC);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn in_sack;\n}\n\n/* Mark the given newly-SACKed range as such, adjusting counters and hints. */\nstatic u8 tcp_sacktag_one(struct sock *sk,\n\t\t\t  struct tcp_sacktag_state *state, u8 sacked,\n\t\t\t  u32 start_seq, u32 end_seq,\n\t\t\t  int dup_sack, int pcount,\n\t\t\t  const struct skb_mstamp *xmit_time)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint fack_count = state->fack_count;\n\n\t/* Account D-SACK for retransmitted packet. */\n\tif (dup_sack && (sacked & TCPCB_RETRANS)) {\n\t\tif (tp->undo_marker && tp->undo_retrans > 0 &&\n\t\t    after(end_seq, tp->undo_marker))\n\t\t\ttp->undo_retrans--;\n\t\tif (sacked & TCPCB_SACKED_ACKED)\n\t\t\tstate->reord = min(fack_count, state->reord);\n\t}\n\n\t/* Nothing to do; acked frame is about to be dropped (was ACKed). */\n\tif (!after(end_seq, tp->snd_una))\n\t\treturn sacked;\n\n\tif (!(sacked & TCPCB_SACKED_ACKED)) {\n\t\ttcp_rack_advance(tp, xmit_time, sacked);\n\n\t\tif (sacked & TCPCB_SACKED_RETRANS) {\n\t\t\t/* If the segment is not tagged as lost,\n\t\t\t * we do not clear RETRANS, believing\n\t\t\t * that retransmission is still in flight.\n\t\t\t */\n\t\t\tif (sacked & TCPCB_LOST) {\n\t\t\t\tsacked &= ~(TCPCB_LOST|TCPCB_SACKED_RETRANS);\n\t\t\t\ttp->lost_out -= pcount;\n\t\t\t\ttp->retrans_out -= pcount;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(sacked & TCPCB_RETRANS)) {\n\t\t\t\t/* New sack for not retransmitted frame,\n\t\t\t\t * which was in hole. It is reordering.\n\t\t\t\t */\n\t\t\t\tif (before(start_seq,\n\t\t\t\t\t   tcp_highest_sack_seq(tp)))\n\t\t\t\t\tstate->reord = min(fack_count,\n\t\t\t\t\t\t\t   state->reord);\n\t\t\t\tif (!after(end_seq, tp->high_seq))\n\t\t\t\t\tstate->flag |= FLAG_ORIG_SACK_ACKED;\n\t\t\t\tif (state->first_sackt.v64 == 0)\n\t\t\t\t\tstate->first_sackt = *xmit_time;\n\t\t\t\tstate->last_sackt = *xmit_time;\n\t\t\t}\n\n\t\t\tif (sacked & TCPCB_LOST) {\n\t\t\t\tsacked &= ~TCPCB_LOST;\n\t\t\t\ttp->lost_out -= pcount;\n\t\t\t}\n\t\t}\n\n\t\tsacked |= TCPCB_SACKED_ACKED;\n\t\tstate->flag |= FLAG_DATA_SACKED;\n\t\ttp->sacked_out += pcount;\n\n\t\tfack_count += pcount;\n\n\t\t/* Lost marker hint past SACKed? Tweak RFC3517 cnt */\n\t\tif (!tcp_is_fack(tp) && tp->lost_skb_hint &&\n\t\t    before(start_seq, TCP_SKB_CB(tp->lost_skb_hint)->seq))\n\t\t\ttp->lost_cnt_hint += pcount;\n\n\t\tif (fack_count > tp->fackets_out)\n\t\t\ttp->fackets_out = fack_count;\n\t}\n\n\t/* D-SACK. We can detect redundant retransmission in S|R and plain R\n\t * frames and clear it. undo_retrans is decreased above, L|R frames\n\t * are accounted above as well.\n\t */\n\tif (dup_sack && (sacked & TCPCB_SACKED_RETRANS)) {\n\t\tsacked &= ~TCPCB_SACKED_RETRANS;\n\t\ttp->retrans_out -= pcount;\n\t}\n\n\treturn sacked;\n}\n\n/* Shift newly-SACKed bytes from this skb to the immediately previous\n * already-SACKed sk_buff. Mark the newly-SACKed bytes as such.\n */\nstatic bool tcp_shifted_skb(struct sock *sk, struct sk_buff *skb,\n\t\t\t    struct tcp_sacktag_state *state,\n\t\t\t    unsigned int pcount, int shifted, int mss,\n\t\t\t    bool dup_sack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *prev = tcp_write_queue_prev(sk, skb);\n\tu32 start_seq = TCP_SKB_CB(skb)->seq;\t/* start of newly-SACKed */\n\tu32 end_seq = start_seq + shifted;\t/* end of newly-SACKed */\n\n\tBUG_ON(!pcount);\n\n\t/* Adjust counters and hints for the newly sacked sequence\n\t * range but discard the return value since prev is already\n\t * marked. We must tag the range first because the seq\n\t * advancement below implicitly advances\n\t * tcp_highest_sack_seq() when skb is highest_sack.\n\t */\n\ttcp_sacktag_one(sk, state, TCP_SKB_CB(skb)->sacked,\n\t\t\tstart_seq, end_seq, dup_sack, pcount,\n\t\t\t&skb->skb_mstamp);\n\n\tif (skb == tp->lost_skb_hint)\n\t\ttp->lost_cnt_hint += pcount;\n\n\tTCP_SKB_CB(prev)->end_seq += shifted;\n\tTCP_SKB_CB(skb)->seq += shifted;\n\n\ttcp_skb_pcount_add(prev, pcount);\n\tBUG_ON(tcp_skb_pcount(skb) < pcount);\n\ttcp_skb_pcount_add(skb, -pcount);\n\n\t/* When we're adding to gso_segs == 1, gso_size will be zero,\n\t * in theory this shouldn't be necessary but as long as DSACK\n\t * code can come after this skb later on it's better to keep\n\t * setting gso_size to something.\n\t */\n\tif (!TCP_SKB_CB(prev)->tcp_gso_size)\n\t\tTCP_SKB_CB(prev)->tcp_gso_size = mss;\n\n\t/* CHECKME: To clear or not to clear? Mimics normal skb currently */\n\tif (tcp_skb_pcount(skb) <= 1)\n\t\tTCP_SKB_CB(skb)->tcp_gso_size = 0;\n\n\t/* Difference in this won't matter, both ACKed by the same cumul. ACK */\n\tTCP_SKB_CB(prev)->sacked |= (TCP_SKB_CB(skb)->sacked & TCPCB_EVER_RETRANS);\n\n\tif (skb->len > 0) {\n\t\tBUG_ON(!tcp_skb_pcount(skb));\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SACKSHIFTED);\n\t\treturn false;\n\t}\n\n\t/* Whole SKB was eaten :-) */\n\n\tif (skb == tp->retransmit_skb_hint)\n\t\ttp->retransmit_skb_hint = prev;\n\tif (skb == tp->lost_skb_hint) {\n\t\ttp->lost_skb_hint = prev;\n\t\ttp->lost_cnt_hint -= tcp_skb_pcount(prev);\n\t}\n\n\tTCP_SKB_CB(prev)->tcp_flags |= TCP_SKB_CB(skb)->tcp_flags;\n\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\tTCP_SKB_CB(prev)->end_seq++;\n\n\tif (skb == tcp_highest_sack(sk))\n\t\ttcp_advance_highest_sack(sk, skb);\n\n\ttcp_unlink_write_queue(skb, sk);\n\tsk_wmem_free_skb(sk, skb);\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SACKMERGED);\n\n\treturn true;\n}\n\n/* I wish gso_size would have a bit more sane initialization than\n * something-or-zero which complicates things\n */\nstatic int tcp_skb_seglen(const struct sk_buff *skb)\n{\n\treturn tcp_skb_pcount(skb) == 1 ? skb->len : tcp_skb_mss(skb);\n}\n\n/* Shifting pages past head area doesn't work */\nstatic int skb_can_shift(const struct sk_buff *skb)\n{\n\treturn !skb_headlen(skb) && skb_is_nonlinear(skb);\n}\n\n/* Try collapsing SACK blocks spanning across multiple skbs to a single\n * skb.\n */\nstatic struct sk_buff *tcp_shift_skb_data(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct tcp_sacktag_state *state,\n\t\t\t\t\t  u32 start_seq, u32 end_seq,\n\t\t\t\t\t  bool dup_sack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *prev;\n\tint mss;\n\tint pcount = 0;\n\tint len;\n\tint in_sack;\n\n\tif (!sk_can_gso(sk))\n\t\tgoto fallback;\n\n\t/* Normally R but no L won't result in plain S */\n\tif (!dup_sack &&\n\t    (TCP_SKB_CB(skb)->sacked & (TCPCB_LOST|TCPCB_SACKED_RETRANS)) == TCPCB_SACKED_RETRANS)\n\t\tgoto fallback;\n\tif (!skb_can_shift(skb))\n\t\tgoto fallback;\n\t/* This frame is about to be dropped (was ACKed). */\n\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una))\n\t\tgoto fallback;\n\n\t/* Can only happen with delayed DSACK + discard craziness */\n\tif (unlikely(skb == tcp_write_queue_head(sk)))\n\t\tgoto fallback;\n\tprev = tcp_write_queue_prev(sk, skb);\n\n\tif ((TCP_SKB_CB(prev)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED)\n\t\tgoto fallback;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (in_sack) {\n\t\tlen = skb->len;\n\t\tpcount = tcp_skb_pcount(skb);\n\t\tmss = tcp_skb_seglen(skb);\n\n\t\t/* TODO: Fix DSACKs to not fragment already SACKed and we can\n\t\t * drop this restriction as unnecessary\n\t\t */\n\t\tif (mss != tcp_skb_seglen(prev))\n\t\t\tgoto fallback;\n\t} else {\n\t\tif (!after(TCP_SKB_CB(skb)->end_seq, start_seq))\n\t\t\tgoto noop;\n\t\t/* CHECKME: This is non-MSS split case only?, this will\n\t\t * cause skipped skbs due to advancing loop btw, original\n\t\t * has that feature too\n\t\t */\n\t\tif (tcp_skb_pcount(skb) <= 1)\n\t\t\tgoto noop;\n\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\t\tif (!in_sack) {\n\t\t\t/* TODO: head merge to next could be attempted here\n\t\t\t * if (!after(TCP_SKB_CB(skb)->end_seq, end_seq)),\n\t\t\t * though it might not be worth of the additional hassle\n\t\t\t *\n\t\t\t * ...we can probably just fallback to what was done\n\t\t\t * previously. We could try merging non-SACKed ones\n\t\t\t * as well but it probably isn't going to buy off\n\t\t\t * because later SACKs might again split them, and\n\t\t\t * it would make skb timestamp tracking considerably\n\t\t\t * harder problem.\n\t\t\t */\n\t\t\tgoto fallback;\n\t\t}\n\n\t\tlen = end_seq - TCP_SKB_CB(skb)->seq;\n\t\tBUG_ON(len < 0);\n\t\tBUG_ON(len > skb->len);\n\n\t\t/* MSS boundaries should be honoured or else pcount will\n\t\t * severely break even though it makes things bit trickier.\n\t\t * Optimize common case to avoid most of the divides\n\t\t */\n\t\tmss = tcp_skb_mss(skb);\n\n\t\t/* TODO: Fix DSACKs to not fragment already SACKed and we can\n\t\t * drop this restriction as unnecessary\n\t\t */\n\t\tif (mss != tcp_skb_seglen(prev))\n\t\t\tgoto fallback;\n\n\t\tif (len == mss) {\n\t\t\tpcount = 1;\n\t\t} else if (len < mss) {\n\t\t\tgoto noop;\n\t\t} else {\n\t\t\tpcount = len / mss;\n\t\t\tlen = pcount * mss;\n\t\t}\n\t}\n\n\t/* tcp_sacktag_one() won't SACK-tag ranges below snd_una */\n\tif (!after(TCP_SKB_CB(skb)->seq + len, tp->snd_una))\n\t\tgoto fallback;\n\n\tif (!skb_shift(prev, skb, len))\n\t\tgoto fallback;\n\tif (!tcp_shifted_skb(sk, skb, state, pcount, len, mss, dup_sack))\n\t\tgoto out;\n\n\t/* Hole filled allows collapsing with the next as well, this is very\n\t * useful when hole on every nth skb pattern happens\n\t */\n\tif (prev == tcp_write_queue_tail(sk))\n\t\tgoto out;\n\tskb = tcp_write_queue_next(sk, prev);\n\n\tif (!skb_can_shift(skb) ||\n\t    (skb == tcp_send_head(sk)) ||\n\t    ((TCP_SKB_CB(skb)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED) ||\n\t    (mss != tcp_skb_seglen(skb)))\n\t\tgoto out;\n\n\tlen = skb->len;\n\tif (skb_shift(prev, skb, len)) {\n\t\tpcount += tcp_skb_pcount(skb);\n\t\ttcp_shifted_skb(sk, skb, state, tcp_skb_pcount(skb), len, mss, 0);\n\t}\n\nout:\n\tstate->fack_count += pcount;\n\treturn prev;\n\nnoop:\n\treturn skb;\n\nfallback:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SACKSHIFTFALLBACK);\n\treturn NULL;\n}\n\nstatic struct sk_buff *tcp_sacktag_walk(struct sk_buff *skb, struct sock *sk,\n\t\t\t\t\tstruct tcp_sack_block *next_dup,\n\t\t\t\t\tstruct tcp_sacktag_state *state,\n\t\t\t\t\tu32 start_seq, u32 end_seq,\n\t\t\t\t\tbool dup_sack_in)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *tmp;\n\n\ttcp_for_write_queue_from(skb, sk) {\n\t\tint in_sack = 0;\n\t\tbool dup_sack = dup_sack_in;\n\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\n\t\t/* queue is in-order => we can short-circuit the walk early */\n\t\tif (!before(TCP_SKB_CB(skb)->seq, end_seq))\n\t\t\tbreak;\n\n\t\tif (next_dup  &&\n\t\t    before(TCP_SKB_CB(skb)->seq, next_dup->end_seq)) {\n\t\t\tin_sack = tcp_match_skb_to_sack(sk, skb,\n\t\t\t\t\t\t\tnext_dup->start_seq,\n\t\t\t\t\t\t\tnext_dup->end_seq);\n\t\t\tif (in_sack > 0)\n\t\t\t\tdup_sack = true;\n\t\t}\n\n\t\t/* skb reference here is a bit tricky to get right, since\n\t\t * shifting can eat and free both this skb and the next,\n\t\t * so not even _safe variant of the loop is enough.\n\t\t */\n\t\tif (in_sack <= 0) {\n\t\t\ttmp = tcp_shift_skb_data(sk, skb, state,\n\t\t\t\t\t\t start_seq, end_seq, dup_sack);\n\t\t\tif (tmp) {\n\t\t\t\tif (tmp != skb) {\n\t\t\t\t\tskb = tmp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tin_sack = 0;\n\t\t\t} else {\n\t\t\t\tin_sack = tcp_match_skb_to_sack(sk, skb,\n\t\t\t\t\t\t\t\tstart_seq,\n\t\t\t\t\t\t\t\tend_seq);\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(in_sack < 0))\n\t\t\tbreak;\n\n\t\tif (in_sack) {\n\t\t\tTCP_SKB_CB(skb)->sacked =\n\t\t\t\ttcp_sacktag_one(sk,\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tTCP_SKB_CB(skb)->sacked,\n\t\t\t\t\t\tTCP_SKB_CB(skb)->seq,\n\t\t\t\t\t\tTCP_SKB_CB(skb)->end_seq,\n\t\t\t\t\t\tdup_sack,\n\t\t\t\t\t\ttcp_skb_pcount(skb),\n\t\t\t\t\t\t&skb->skb_mstamp);\n\n\t\t\tif (!before(TCP_SKB_CB(skb)->seq,\n\t\t\t\t    tcp_highest_sack_seq(tp)))\n\t\t\t\ttcp_advance_highest_sack(sk, skb);\n\t\t}\n\n\t\tstate->fack_count += tcp_skb_pcount(skb);\n\t}\n\treturn skb;\n}\n\n/* Avoid all extra work that is being done by sacktag while walking in\n * a normal way\n */\nstatic struct sk_buff *tcp_sacktag_skip(struct sk_buff *skb, struct sock *sk,\n\t\t\t\t\tstruct tcp_sacktag_state *state,\n\t\t\t\t\tu32 skip_to_seq)\n{\n\ttcp_for_write_queue_from(skb, sk) {\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\n\t\tif (after(TCP_SKB_CB(skb)->end_seq, skip_to_seq))\n\t\t\tbreak;\n\n\t\tstate->fack_count += tcp_skb_pcount(skb);\n\t}\n\treturn skb;\n}\n\nstatic struct sk_buff *tcp_maybe_skipping_dsack(struct sk_buff *skb,\n\t\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\t\tstruct tcp_sack_block *next_dup,\n\t\t\t\t\t\tstruct tcp_sacktag_state *state,\n\t\t\t\t\t\tu32 skip_to_seq)\n{\n\tif (!next_dup)\n\t\treturn skb;\n\n\tif (before(next_dup->start_seq, skip_to_seq)) {\n\t\tskb = tcp_sacktag_skip(skb, sk, state, next_dup->start_seq);\n\t\tskb = tcp_sacktag_walk(skb, sk, NULL, state,\n\t\t\t\t       next_dup->start_seq, next_dup->end_seq,\n\t\t\t\t       1);\n\t}\n\n\treturn skb;\n}\n\nstatic int tcp_sack_cache_ok(const struct tcp_sock *tp, const struct tcp_sack_block *cache)\n{\n\treturn cache < tp->recv_sack_cache + ARRAY_SIZE(tp->recv_sack_cache);\n}\n\nstatic int\ntcp_sacktag_write_queue(struct sock *sk, const struct sk_buff *ack_skb,\n\t\t\tu32 prior_snd_una, struct tcp_sacktag_state *state)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst unsigned char *ptr = (skb_transport_header(ack_skb) +\n\t\t\t\t    TCP_SKB_CB(ack_skb)->sacked);\n\tstruct tcp_sack_block_wire *sp_wire = (struct tcp_sack_block_wire *)(ptr+2);\n\tstruct tcp_sack_block sp[TCP_NUM_SACKS];\n\tstruct tcp_sack_block *cache;\n\tstruct sk_buff *skb;\n\tint num_sacks = min(TCP_NUM_SACKS, (ptr[1] - TCPOLEN_SACK_BASE) >> 3);\n\tint used_sacks;\n\tbool found_dup_sack = false;\n\tint i, j;\n\tint first_sack_index;\n\n\tstate->flag = 0;\n\tstate->reord = tp->packets_out;\n\n\tif (!tp->sacked_out) {\n\t\tif (WARN_ON(tp->fackets_out))\n\t\t\ttp->fackets_out = 0;\n\t\ttcp_highest_sack_reset(sk);\n\t}\n\n\tfound_dup_sack = tcp_check_dsack(sk, ack_skb, sp_wire,\n\t\t\t\t\t num_sacks, prior_snd_una);\n\tif (found_dup_sack)\n\t\tstate->flag |= FLAG_DSACKING_ACK;\n\n\t/* Eliminate too old ACKs, but take into\n\t * account more or less fresh ones, they can\n\t * contain valid SACK info.\n\t */\n\tif (before(TCP_SKB_CB(ack_skb)->ack_seq, prior_snd_una - tp->max_window))\n\t\treturn 0;\n\n\tif (!tp->packets_out)\n\t\tgoto out;\n\n\tused_sacks = 0;\n\tfirst_sack_index = 0;\n\tfor (i = 0; i < num_sacks; i++) {\n\t\tbool dup_sack = !i && found_dup_sack;\n\n\t\tsp[used_sacks].start_seq = get_unaligned_be32(&sp_wire[i].start_seq);\n\t\tsp[used_sacks].end_seq = get_unaligned_be32(&sp_wire[i].end_seq);\n\n\t\tif (!tcp_is_sackblock_valid(tp, dup_sack,\n\t\t\t\t\t    sp[used_sacks].start_seq,\n\t\t\t\t\t    sp[used_sacks].end_seq)) {\n\t\t\tint mib_idx;\n\n\t\t\tif (dup_sack) {\n\t\t\t\tif (!tp->undo_marker)\n\t\t\t\t\tmib_idx = LINUX_MIB_TCPDSACKIGNOREDNOUNDO;\n\t\t\t\telse\n\t\t\t\t\tmib_idx = LINUX_MIB_TCPDSACKIGNOREDOLD;\n\t\t\t} else {\n\t\t\t\t/* Don't count olds caused by ACK reordering */\n\t\t\t\tif ((TCP_SKB_CB(ack_skb)->ack_seq != tp->snd_una) &&\n\t\t\t\t    !after(sp[used_sacks].end_seq, tp->snd_una))\n\t\t\t\t\tcontinue;\n\t\t\t\tmib_idx = LINUX_MIB_TCPSACKDISCARD;\n\t\t\t}\n\n\t\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\t\t\tif (i == 0)\n\t\t\t\tfirst_sack_index = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ignore very old stuff early */\n\t\tif (!after(sp[used_sacks].end_seq, prior_snd_una))\n\t\t\tcontinue;\n\n\t\tused_sacks++;\n\t}\n\n\t/* order SACK blocks to allow in order walk of the retrans queue */\n\tfor (i = used_sacks - 1; i > 0; i--) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (after(sp[j].start_seq, sp[j + 1].start_seq)) {\n\t\t\t\tswap(sp[j], sp[j + 1]);\n\n\t\t\t\t/* Track where the first SACK block goes to */\n\t\t\t\tif (j == first_sack_index)\n\t\t\t\t\tfirst_sack_index = j + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tskb = tcp_write_queue_head(sk);\n\tstate->fack_count = 0;\n\ti = 0;\n\n\tif (!tp->sacked_out) {\n\t\t/* It's already past, so skip checking against it */\n\t\tcache = tp->recv_sack_cache + ARRAY_SIZE(tp->recv_sack_cache);\n\t} else {\n\t\tcache = tp->recv_sack_cache;\n\t\t/* Skip empty blocks in at head of the cache */\n\t\twhile (tcp_sack_cache_ok(tp, cache) && !cache->start_seq &&\n\t\t       !cache->end_seq)\n\t\t\tcache++;\n\t}\n\n\twhile (i < used_sacks) {\n\t\tu32 start_seq = sp[i].start_seq;\n\t\tu32 end_seq = sp[i].end_seq;\n\t\tbool dup_sack = (found_dup_sack && (i == first_sack_index));\n\t\tstruct tcp_sack_block *next_dup = NULL;\n\n\t\tif (found_dup_sack && ((i + 1) == first_sack_index))\n\t\t\tnext_dup = &sp[i + 1];\n\n\t\t/* Skip too early cached blocks */\n\t\twhile (tcp_sack_cache_ok(tp, cache) &&\n\t\t       !before(start_seq, cache->end_seq))\n\t\t\tcache++;\n\n\t\t/* Can skip some work by looking recv_sack_cache? */\n\t\tif (tcp_sack_cache_ok(tp, cache) && !dup_sack &&\n\t\t    after(end_seq, cache->start_seq)) {\n\n\t\t\t/* Head todo? */\n\t\t\tif (before(start_seq, cache->start_seq)) {\n\t\t\t\tskb = tcp_sacktag_skip(skb, sk, state,\n\t\t\t\t\t\t       start_seq);\n\t\t\t\tskb = tcp_sacktag_walk(skb, sk, next_dup,\n\t\t\t\t\t\t       state,\n\t\t\t\t\t\t       start_seq,\n\t\t\t\t\t\t       cache->start_seq,\n\t\t\t\t\t\t       dup_sack);\n\t\t\t}\n\n\t\t\t/* Rest of the block already fully processed? */\n\t\t\tif (!after(end_seq, cache->end_seq))\n\t\t\t\tgoto advance_sp;\n\n\t\t\tskb = tcp_maybe_skipping_dsack(skb, sk, next_dup,\n\t\t\t\t\t\t       state,\n\t\t\t\t\t\t       cache->end_seq);\n\n\t\t\t/* ...tail remains todo... */\n\t\t\tif (tcp_highest_sack_seq(tp) == cache->end_seq) {\n\t\t\t\t/* ...but better entrypoint exists! */\n\t\t\t\tskb = tcp_highest_sack(sk);\n\t\t\t\tif (!skb)\n\t\t\t\t\tbreak;\n\t\t\t\tstate->fack_count = tp->fackets_out;\n\t\t\t\tcache++;\n\t\t\t\tgoto walk;\n\t\t\t}\n\n\t\t\tskb = tcp_sacktag_skip(skb, sk, state, cache->end_seq);\n\t\t\t/* Check overlap against next cached too (past this one already) */\n\t\t\tcache++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!before(start_seq, tcp_highest_sack_seq(tp))) {\n\t\t\tskb = tcp_highest_sack(sk);\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\t\t\tstate->fack_count = tp->fackets_out;\n\t\t}\n\t\tskb = tcp_sacktag_skip(skb, sk, state, start_seq);\n\nwalk:\n\t\tskb = tcp_sacktag_walk(skb, sk, next_dup, state,\n\t\t\t\t       start_seq, end_seq, dup_sack);\n\nadvance_sp:\n\t\ti++;\n\t}\n\n\t/* Clear the head of the cache sack blocks so we can skip it next time */\n\tfor (i = 0; i < ARRAY_SIZE(tp->recv_sack_cache) - used_sacks; i++) {\n\t\ttp->recv_sack_cache[i].start_seq = 0;\n\t\ttp->recv_sack_cache[i].end_seq = 0;\n\t}\n\tfor (j = 0; j < used_sacks; j++)\n\t\ttp->recv_sack_cache[i++] = sp[j];\n\n\tif ((state->reord < tp->fackets_out) &&\n\t    ((inet_csk(sk)->icsk_ca_state != TCP_CA_Loss) || tp->undo_marker))\n\t\ttcp_update_reordering(sk, tp->fackets_out - state->reord, 0);\n\n\ttcp_verify_left_out(tp);\nout:\n\n#if FASTRETRANS_DEBUG > 0\n\tWARN_ON((int)tp->sacked_out < 0);\n\tWARN_ON((int)tp->lost_out < 0);\n\tWARN_ON((int)tp->retrans_out < 0);\n\tWARN_ON((int)tcp_packets_in_flight(tp) < 0);\n#endif\n\treturn state->flag;\n}\n\n/* Limits sacked_out so that sum with lost_out isn't ever larger than\n * packets_out. Returns false if sacked_out adjustement wasn't necessary.\n */\nstatic bool tcp_limit_reno_sacked(struct tcp_sock *tp)\n{\n\tu32 holes;\n\n\tholes = max(tp->lost_out, 1U);\n\tholes = min(holes, tp->packets_out);\n\n\tif ((tp->sacked_out + holes) > tp->packets_out) {\n\t\ttp->sacked_out = tp->packets_out - holes;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* If we receive more dupacks than we expected counting segments\n * in assumption of absent reordering, interpret this as reordering.\n * The only another reason could be bug in receiver TCP.\n */\nstatic void tcp_check_reno_reordering(struct sock *sk, const int addend)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (tcp_limit_reno_sacked(tp))\n\t\ttcp_update_reordering(sk, tp->packets_out + addend, 0);\n}\n\n/* Emulate SACKs for SACKless connection: account for a new dupack. */\n\nstatic void tcp_add_reno_sack(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\ttp->sacked_out++;\n\ttcp_check_reno_reordering(sk, 0);\n\ttcp_verify_left_out(tp);\n}\n\n/* Account for ACK, ACKing some data in Reno Recovery phase. */\n\nstatic void tcp_remove_reno_sacks(struct sock *sk, int acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (acked > 0) {\n\t\t/* One ACK acked hole. The rest eat duplicate ACKs. */\n\t\tif (acked - 1 >= tp->sacked_out)\n\t\t\ttp->sacked_out = 0;\n\t\telse\n\t\t\ttp->sacked_out -= acked - 1;\n\t}\n\ttcp_check_reno_reordering(sk, acked);\n\ttcp_verify_left_out(tp);\n}\n\nstatic inline void tcp_reset_reno_sack(struct tcp_sock *tp)\n{\n\ttp->sacked_out = 0;\n}\n\nvoid tcp_clear_retrans(struct tcp_sock *tp)\n{\n\ttp->retrans_out = 0;\n\ttp->lost_out = 0;\n\ttp->undo_marker = 0;\n\ttp->undo_retrans = -1;\n\ttp->fackets_out = 0;\n\ttp->sacked_out = 0;\n}\n\nstatic inline void tcp_init_undo(struct tcp_sock *tp)\n{\n\ttp->undo_marker = tp->snd_una;\n\t/* Retransmission still in flight may cause DSACKs later. */\n\ttp->undo_retrans = tp->retrans_out ? : -1;\n}\n\n/* Enter Loss state. If we detect SACK reneging, forget all SACK information\n * and reset tags completely, otherwise preserve SACKs. If receiver\n * dropped its ofo queue, we will know this due to reneging detection.\n */\nvoid tcp_enter_loss(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb;\n\tbool new_recovery = icsk->icsk_ca_state < TCP_CA_Recovery;\n\tbool is_reneg;\t\t\t/* is receiver reneging on SACKs? */\n\n\t/* Reduce ssthresh if it has not yet been made inside this window. */\n\tif (icsk->icsk_ca_state <= TCP_CA_Disorder ||\n\t    !after(tp->high_seq, tp->snd_una) ||\n\t    (icsk->icsk_ca_state == TCP_CA_Loss && !icsk->icsk_retransmits)) {\n\t\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\n\t\ttp->snd_ssthresh = icsk->icsk_ca_ops->ssthresh(sk);\n\t\ttcp_ca_event(sk, CA_EVENT_LOSS);\n\t\ttcp_init_undo(tp);\n\t}\n\ttp->snd_cwnd\t   = 1;\n\ttp->snd_cwnd_cnt   = 0;\n\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\n\ttp->retrans_out = 0;\n\ttp->lost_out = 0;\n\n\tif (tcp_is_reno(tp))\n\t\ttcp_reset_reno_sack(tp);\n\n\tskb = tcp_write_queue_head(sk);\n\tis_reneg = skb && (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED);\n\tif (is_reneg) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSACKRENEGING);\n\t\ttp->sacked_out = 0;\n\t\ttp->fackets_out = 0;\n\t}\n\ttcp_clear_all_retrans_hints(tp);\n\n\ttcp_for_write_queue(skb, sk) {\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\n\t\tTCP_SKB_CB(skb)->sacked &= (~TCPCB_TAGBITS)|TCPCB_SACKED_ACKED;\n\t\tif (!(TCP_SKB_CB(skb)->sacked&TCPCB_SACKED_ACKED) || is_reneg) {\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_ACKED;\n\t\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_LOST;\n\t\t\ttp->lost_out += tcp_skb_pcount(skb);\n\t\t\ttp->retransmit_high = TCP_SKB_CB(skb)->end_seq;\n\t\t}\n\t}\n\ttcp_verify_left_out(tp);\n\n\t/* Timeout in disordered state after receiving substantial DUPACKs\n\t * suggests that the degree of reordering is over-estimated.\n\t */\n\tif (icsk->icsk_ca_state <= TCP_CA_Disorder &&\n\t    tp->sacked_out >= sysctl_tcp_reordering)\n\t\ttp->reordering = min_t(unsigned int, tp->reordering,\n\t\t\t\t       sysctl_tcp_reordering);\n\ttcp_set_ca_state(sk, TCP_CA_Loss);\n\ttp->high_seq = tp->snd_nxt;\n\ttcp_ecn_queue_cwr(tp);\n\n\t/* F-RTO RFC5682 sec 3.1 step 1: retransmit SND.UNA if no previous\n\t * loss recovery is underway except recurring timeout(s) on\n\t * the same SND.UNA (sec 3.2). Disable F-RTO on path MTU probing\n\t */\n\ttp->frto = sysctl_tcp_frto &&\n\t\t   (new_recovery || icsk->icsk_retransmits) &&\n\t\t   !inet_csk(sk)->icsk_mtup.probe_size;\n}\n\n/* If ACK arrived pointing to a remembered SACK, it means that our\n * remembered SACKs do not reflect real state of receiver i.e.\n * receiver _host_ is heavily congested (or buggy).\n *\n * To avoid big spurious retransmission bursts due to transient SACK\n * scoreboard oddities that look like reneging, we give the receiver a\n * little time (max(RTT/2, 10ms)) to send us some more ACKs that will\n * restore sanity to the SACK scoreboard. If the apparent reneging\n * persists until this RTO then we'll clear the SACK scoreboard.\n */\nstatic bool tcp_check_sack_reneging(struct sock *sk, int flag)\n{\n\tif (flag & FLAG_SACK_RENEGING) {\n\t\tstruct tcp_sock *tp = tcp_sk(sk);\n\t\tunsigned long delay = max(usecs_to_jiffies(tp->srtt_us >> 4),\n\t\t\t\t\t  msecs_to_jiffies(10));\n\n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,\n\t\t\t\t\t  delay, TCP_RTO_MAX);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline int tcp_fackets_out(const struct tcp_sock *tp)\n{\n\treturn tcp_is_reno(tp) ? tp->sacked_out + 1 : tp->fackets_out;\n}\n\n/* Heurestics to calculate number of duplicate ACKs. There's no dupACKs\n * counter when SACK is enabled (without SACK, sacked_out is used for\n * that purpose).\n *\n * Instead, with FACK TCP uses fackets_out that includes both SACKed\n * segments up to the highest received SACK block so far and holes in\n * between them.\n *\n * With reordering, holes may still be in flight, so RFC3517 recovery\n * uses pure sacked_out (total number of SACKed segments) even though\n * it violates the RFC that uses duplicate ACKs, often these are equal\n * but when e.g. out-of-window ACKs or packet duplication occurs,\n * they differ. Since neither occurs due to loss, TCP should really\n * ignore them.\n */\nstatic inline int tcp_dupack_heuristics(const struct tcp_sock *tp)\n{\n\treturn tcp_is_fack(tp) ? tp->fackets_out : tp->sacked_out + 1;\n}\n\nstatic bool tcp_pause_early_retransmit(struct sock *sk, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tunsigned long delay;\n\n\t/* Delay early retransmit and entering fast recovery for\n\t * max(RTT/4, 2msec) unless ack has ECE mark, no RTT samples\n\t * available, or RTO is scheduled to fire first.\n\t */\n\tif (sysctl_tcp_early_retrans < 2 || sysctl_tcp_early_retrans > 3 ||\n\t    (flag & FLAG_ECE) || !tp->srtt_us)\n\t\treturn false;\n\n\tdelay = max(usecs_to_jiffies(tp->srtt_us >> 5),\n\t\t    msecs_to_jiffies(2));\n\n\tif (!time_after(inet_csk(sk)->icsk_timeout, (jiffies + delay)))\n\t\treturn false;\n\n\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_EARLY_RETRANS, delay,\n\t\t\t\t  TCP_RTO_MAX);\n\treturn true;\n}\n\n/* Linux NewReno/SACK/FACK/ECN state machine.\n * --------------------------------------\n *\n * \"Open\"\tNormal state, no dubious events, fast path.\n * \"Disorder\"   In all the respects it is \"Open\",\n *\t\tbut requires a bit more attention. It is entered when\n *\t\twe see some SACKs or dupacks. It is split of \"Open\"\n *\t\tmainly to move some processing from fast path to slow one.\n * \"CWR\"\tCWND was reduced due to some Congestion Notification event.\n *\t\tIt can be ECN, ICMP source quench, local device congestion.\n * \"Recovery\"\tCWND was reduced, we are fast-retransmitting.\n * \"Loss\"\tCWND was reduced due to RTO timeout or SACK reneging.\n *\n * tcp_fastretrans_alert() is entered:\n * - each incoming ACK, if state is not \"Open\"\n * - when arrived ACK is unusual, namely:\n *\t* SACK\n *\t* Duplicate ACK.\n *\t* ECN ECE.\n *\n * Counting packets in flight is pretty simple.\n *\n *\tin_flight = packets_out - left_out + retrans_out\n *\n *\tpackets_out is SND.NXT-SND.UNA counted in packets.\n *\n *\tretrans_out is number of retransmitted segments.\n *\n *\tleft_out is number of segments left network, but not ACKed yet.\n *\n *\t\tleft_out = sacked_out + lost_out\n *\n *     sacked_out: Packets, which arrived to receiver out of order\n *\t\t   and hence not ACKed. With SACKs this number is simply\n *\t\t   amount of SACKed data. Even without SACKs\n *\t\t   it is easy to give pretty reliable estimate of this number,\n *\t\t   counting duplicate ACKs.\n *\n *       lost_out: Packets lost by network. TCP has no explicit\n *\t\t   \"loss notification\" feedback from network (for now).\n *\t\t   It means that this number can be only _guessed_.\n *\t\t   Actually, it is the heuristics to predict lossage that\n *\t\t   distinguishes different algorithms.\n *\n *\tF.e. after RTO, when all the queue is considered as lost,\n *\tlost_out = packets_out and in_flight = retrans_out.\n *\n *\t\tEssentially, we have now two algorithms counting\n *\t\tlost packets.\n *\n *\t\tFACK: It is the simplest heuristics. As soon as we decided\n *\t\tthat something is lost, we decide that _all_ not SACKed\n *\t\tpackets until the most forward SACK are lost. I.e.\n *\t\tlost_out = fackets_out - sacked_out and left_out = fackets_out.\n *\t\tIt is absolutely correct estimate, if network does not reorder\n *\t\tpackets. And it loses any connection to reality when reordering\n *\t\ttakes place. We use FACK by default until reordering\n *\t\tis suspected on the path to this destination.\n *\n *\t\tNewReno: when Recovery is entered, we assume that one segment\n *\t\tis lost (classic Reno). While we are in Recovery and\n *\t\ta partial ACK arrives, we assume that one more packet\n *\t\tis lost (NewReno). This heuristics are the same in NewReno\n *\t\tand SACK.\n *\n *  Imagine, that's all! Forget about all this shamanism about CWND inflation\n *  deflation etc. CWND is real congestion window, never inflated, changes\n *  only according to classic VJ rules.\n *\n * Really tricky (and requiring careful tuning) part of algorithm\n * is hidden in functions tcp_time_to_recover() and tcp_xmit_retransmit_queue().\n * The first determines the moment _when_ we should reduce CWND and,\n * hence, slow down forward transmission. In fact, it determines the moment\n * when we decide that hole is caused by loss, rather than by a reorder.\n *\n * tcp_xmit_retransmit_queue() decides, _what_ we should retransmit to fill\n * holes, caused by lost packets.\n *\n * And the most logically complicated part of algorithm is undo\n * heuristics. We detect false retransmits due to both too early\n * fast retransmit (reordering) and underestimated RTO, analyzing\n * timestamps and D-SACKs. When we detect that some segments were\n * retransmitted by mistake and CWND reduction was wrong, we undo\n * window reduction and abort recovery phase. This logic is hidden\n * inside several functions named tcp_try_undo_<something>.\n */\n\n/* This function decides, when we should leave Disordered state\n * and enter Recovery phase, reducing congestion window.\n *\n * Main question: may we further continue forward transmission\n * with the same cwnd?\n */\nstatic bool tcp_time_to_recover(struct sock *sk, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t__u32 packets_out;\n\n\t/* Trick#1: The loss is proven. */\n\tif (tp->lost_out)\n\t\treturn true;\n\n\t/* Not-A-Trick#2 : Classic rule... */\n\tif (tcp_dupack_heuristics(tp) > tp->reordering)\n\t\treturn true;\n\n\t/* Trick#4: It is still not OK... But will it be useful to delay\n\t * recovery more?\n\t */\n\tpackets_out = tp->packets_out;\n\tif (packets_out <= tp->reordering &&\n\t    tp->sacked_out >= max_t(__u32, packets_out/2, sysctl_tcp_reordering) &&\n\t    !tcp_may_send_now(sk)) {\n\t\t/* We have nothing to send. This connection is limited\n\t\t * either by receiver window or by application.\n\t\t */\n\t\treturn true;\n\t}\n\n\t/* If a thin stream is detected, retransmit after first\n\t * received dupack. Employ only if SACK is supported in order\n\t * to avoid possible corner-case series of spurious retransmissions\n\t * Use only if there are no unsent data.\n\t */\n\tif ((tp->thin_dupack || sysctl_tcp_thin_dupack) &&\n\t    tcp_stream_is_thin(tp) && tcp_dupack_heuristics(tp) > 1 &&\n\t    tcp_is_sack(tp) && !tcp_send_head(sk))\n\t\treturn true;\n\n\t/* Trick#6: TCP early retransmit, per RFC5827.  To avoid spurious\n\t * retransmissions due to small network reorderings, we implement\n\t * Mitigation A.3 in the RFC and delay the retransmission for a short\n\t * interval if appropriate.\n\t */\n\tif (tp->do_early_retrans && !tp->retrans_out && tp->sacked_out &&\n\t    (tp->packets_out >= (tp->sacked_out + 1) && tp->packets_out < 4) &&\n\t    !tcp_may_send_now(sk))\n\t\treturn !tcp_pause_early_retransmit(sk, flag);\n\n\treturn false;\n}\n\n/* Detect loss in event \"A\" above by marking head of queue up as lost.\n * For FACK or non-SACK(Reno) senders, the first \"packets\" number of segments\n * are considered lost. For RFC3517 SACK, a segment is considered lost if it\n * has at least tp->reordering SACKed seqments above it; \"packets\" refers to\n * the maximum SACKed segments to pass before reaching this limit.\n */\nstatic void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb;\n\tint cnt, oldcnt;\n\tint err;\n\tunsigned int mss;\n\t/* Use SACK to deduce losses of new sequences sent during recovery */\n\tconst u32 loss_high = tcp_is_sack(tp) ?  tp->snd_nxt : tp->high_seq;\n\n\tWARN_ON(packets > tp->packets_out);\n\tif (tp->lost_skb_hint) {\n\t\tskb = tp->lost_skb_hint;\n\t\tcnt = tp->lost_cnt_hint;\n\t\t/* Head already handled? */\n\t\tif (mark_head && skb != tcp_write_queue_head(sk))\n\t\t\treturn;\n\t} else {\n\t\tskb = tcp_write_queue_head(sk);\n\t\tcnt = 0;\n\t}\n\n\ttcp_for_write_queue_from(skb, sk) {\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\t\t/* TODO: do this better */\n\t\t/* this is not the most efficient way to do this... */\n\t\ttp->lost_skb_hint = skb;\n\t\ttp->lost_cnt_hint = cnt;\n\n\t\tif (after(TCP_SKB_CB(skb)->end_seq, loss_high))\n\t\t\tbreak;\n\n\t\toldcnt = cnt;\n\t\tif (tcp_is_fack(tp) || tcp_is_reno(tp) ||\n\t\t    (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED))\n\t\t\tcnt += tcp_skb_pcount(skb);\n\n\t\tif (cnt > packets) {\n\t\t\tif ((tcp_is_sack(tp) && !tcp_is_fack(tp)) ||\n\t\t\t    (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED) ||\n\t\t\t    (oldcnt >= packets))\n\t\t\t\tbreak;\n\n\t\t\tmss = tcp_skb_mss(skb);\n\t\t\terr = tcp_fragment(sk, skb, (packets - oldcnt) * mss,\n\t\t\t\t\t   mss, GFP_ATOMIC);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\tcnt = packets;\n\t\t}\n\n\t\ttcp_skb_mark_lost(tp, skb);\n\n\t\tif (mark_head)\n\t\t\tbreak;\n\t}\n\ttcp_verify_left_out(tp);\n}\n\n/* Account newly detected lost packet(s) */\n\nstatic void tcp_update_scoreboard(struct sock *sk, int fast_rexmit)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_is_reno(tp)) {\n\t\ttcp_mark_head_lost(sk, 1, 1);\n\t} else if (tcp_is_fack(tp)) {\n\t\tint lost = tp->fackets_out - tp->reordering;\n\t\tif (lost <= 0)\n\t\t\tlost = 1;\n\t\ttcp_mark_head_lost(sk, lost, 0);\n\t} else {\n\t\tint sacked_upto = tp->sacked_out - tp->reordering;\n\t\tif (sacked_upto >= 0)\n\t\t\ttcp_mark_head_lost(sk, sacked_upto, 0);\n\t\telse if (fast_rexmit)\n\t\t\ttcp_mark_head_lost(sk, 1, 1);\n\t}\n}\n\n/* CWND moderation, preventing bursts due to too big ACKs\n * in dubious situations.\n */\nstatic inline void tcp_moderate_cwnd(struct tcp_sock *tp)\n{\n\ttp->snd_cwnd = min(tp->snd_cwnd,\n\t\t\t   tcp_packets_in_flight(tp) + tcp_max_burst(tp));\n\ttp->snd_cwnd_stamp = tcp_time_stamp;\n}\n\nstatic bool tcp_tsopt_ecr_before(const struct tcp_sock *tp, u32 when)\n{\n\treturn tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\n\t       before(tp->rx_opt.rcv_tsecr, when);\n}\n\n/* skb is spurious retransmitted if the returned timestamp echo\n * reply is prior to the skb transmission time\n */\nstatic bool tcp_skb_spurious_retrans(const struct tcp_sock *tp,\n\t\t\t\t     const struct sk_buff *skb)\n{\n\treturn (TCP_SKB_CB(skb)->sacked & TCPCB_RETRANS) &&\n\t       tcp_tsopt_ecr_before(tp, tcp_skb_timestamp(skb));\n}\n\n/* Nothing was retransmitted or returned timestamp is less\n * than timestamp of the first retransmission.\n */\nstatic inline bool tcp_packet_delayed(const struct tcp_sock *tp)\n{\n\treturn !tp->retrans_stamp ||\n\t       tcp_tsopt_ecr_before(tp, tp->retrans_stamp);\n}\n\n/* Undo procedures. */\n\n/* We can clear retrans_stamp when there are no retransmissions in the\n * window. It would seem that it is trivially available for us in\n * tp->retrans_out, however, that kind of assumptions doesn't consider\n * what will happen if errors occur when sending retransmission for the\n * second time. ...It could the that such segment has only\n * TCPCB_EVER_RETRANS set at the present time. It seems that checking\n * the head skb is enough except for some reneging corner cases that\n * are not worth the effort.\n *\n * Main reason for all this complexity is the fact that connection dying\n * time now depends on the validity of the retrans_stamp, in particular,\n * that successive retransmissions of a segment must not advance\n * retrans_stamp under any conditions.\n */\nstatic bool tcp_any_retrans_done(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb;\n\n\tif (tp->retrans_out)\n\t\treturn true;\n\n\tskb = tcp_write_queue_head(sk);\n\tif (unlikely(skb && TCP_SKB_CB(skb)->sacked & TCPCB_EVER_RETRANS))\n\t\treturn true;\n\n\treturn false;\n}\n\n#if FASTRETRANS_DEBUG > 1\nstatic void DBGUNDO(struct sock *sk, const char *msg)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\tif (sk->sk_family == AF_INET) {\n\t\tpr_debug(\"Undo %s %pI4/%u c%u l%u ss%u/%u p%u\\n\",\n\t\t\t msg,\n\t\t\t &inet->inet_daddr, ntohs(inet->inet_dport),\n\t\t\t tp->snd_cwnd, tcp_left_out(tp),\n\t\t\t tp->snd_ssthresh, tp->prior_ssthresh,\n\t\t\t tp->packets_out);\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (sk->sk_family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tpr_debug(\"Undo %s %pI6/%u c%u l%u ss%u/%u p%u\\n\",\n\t\t\t msg,\n\t\t\t &np->daddr, ntohs(inet->inet_dport),\n\t\t\t tp->snd_cwnd, tcp_left_out(tp),\n\t\t\t tp->snd_ssthresh, tp->prior_ssthresh,\n\t\t\t tp->packets_out);\n\t}\n#endif\n}\n#else\n#define DBGUNDO(x...) do { } while (0)\n#endif\n\nstatic void tcp_undo_cwnd_reduction(struct sock *sk, bool unmark_loss)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (unmark_loss) {\n\t\tstruct sk_buff *skb;\n\n\t\ttcp_for_write_queue(skb, sk) {\n\t\t\tif (skb == tcp_send_head(sk))\n\t\t\t\tbreak;\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_LOST;\n\t\t}\n\t\ttp->lost_out = 0;\n\t\ttcp_clear_all_retrans_hints(tp);\n\t}\n\n\tif (tp->prior_ssthresh) {\n\t\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\t\tif (icsk->icsk_ca_ops->undo_cwnd)\n\t\t\ttp->snd_cwnd = icsk->icsk_ca_ops->undo_cwnd(sk);\n\t\telse\n\t\t\ttp->snd_cwnd = max(tp->snd_cwnd, tp->snd_ssthresh << 1);\n\n\t\tif (tp->prior_ssthresh > tp->snd_ssthresh) {\n\t\t\ttp->snd_ssthresh = tp->prior_ssthresh;\n\t\t\ttcp_ecn_withdraw_cwr(tp);\n\t\t}\n\t} else {\n\t\ttp->snd_cwnd = max(tp->snd_cwnd, tp->snd_ssthresh);\n\t}\n\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\ttp->undo_marker = 0;\n}\n\nstatic inline bool tcp_may_undo(const struct tcp_sock *tp)\n{\n\treturn tp->undo_marker && (!tp->undo_retrans || tcp_packet_delayed(tp));\n}\n\n/* People celebrate: \"We love our President!\" */\nstatic bool tcp_try_undo_recovery(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_may_undo(tp)) {\n\t\tint mib_idx;\n\n\t\t/* Happy end! We did not retransmit anything\n\t\t * or our original transmission succeeded.\n\t\t */\n\t\tDBGUNDO(sk, inet_csk(sk)->icsk_ca_state == TCP_CA_Loss ? \"loss\" : \"retrans\");\n\t\ttcp_undo_cwnd_reduction(sk, false);\n\t\tif (inet_csk(sk)->icsk_ca_state == TCP_CA_Loss)\n\t\t\tmib_idx = LINUX_MIB_TCPLOSSUNDO;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPFULLUNDO;\n\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\t}\n\tif (tp->snd_una == tp->high_seq && tcp_is_reno(tp)) {\n\t\t/* Hold old state until something *above* high_seq\n\t\t * is ACKed. For Reno it is MUST to prevent false\n\t\t * fast retransmits (RFC2582). SACK TCP is safe. */\n\t\ttcp_moderate_cwnd(tp);\n\t\tif (!tcp_any_retrans_done(sk))\n\t\t\ttp->retrans_stamp = 0;\n\t\treturn true;\n\t}\n\ttcp_set_ca_state(sk, TCP_CA_Open);\n\treturn false;\n}\n\n/* Try to undo cwnd reduction, because D-SACKs acked all retransmitted data */\nstatic bool tcp_try_undo_dsack(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tp->undo_marker && !tp->undo_retrans) {\n\t\tDBGUNDO(sk, \"D-SACK\");\n\t\ttcp_undo_cwnd_reduction(sk, false);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKUNDO);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* Undo during loss recovery after partial ACK or using F-RTO. */\nstatic bool tcp_try_undo_loss(struct sock *sk, bool frto_undo)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (frto_undo || tcp_may_undo(tp)) {\n\t\ttcp_undo_cwnd_reduction(sk, true);\n\n\t\tDBGUNDO(sk, \"partial loss\");\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPLOSSUNDO);\n\t\tif (frto_undo)\n\t\t\tNET_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\t LINUX_MIB_TCPSPURIOUSRTOS);\n\t\tinet_csk(sk)->icsk_retransmits = 0;\n\t\tif (frto_undo || tcp_is_sack(tp))\n\t\t\ttcp_set_ca_state(sk, TCP_CA_Open);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* The cwnd reduction in CWR and Recovery uses the PRR algorithm in RFC 6937.\n * It computes the number of packets to send (sndcnt) based on packets newly\n * delivered:\n *   1) If the packets in flight is larger than ssthresh, PRR spreads the\n *\tcwnd reductions across a full RTT.\n *   2) Otherwise PRR uses packet conservation to send as much as delivered.\n *      But when the retransmits are acked without further losses, PRR\n *      slow starts cwnd up to ssthresh to speed up the recovery.\n */\nstatic void tcp_init_cwnd_reduction(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttp->high_seq = tp->snd_nxt;\n\ttp->tlp_high_seq = 0;\n\ttp->snd_cwnd_cnt = 0;\n\ttp->prior_cwnd = tp->snd_cwnd;\n\ttp->prr_delivered = 0;\n\ttp->prr_out = 0;\n\ttp->snd_ssthresh = inet_csk(sk)->icsk_ca_ops->ssthresh(sk);\n\ttcp_ecn_queue_cwr(tp);\n}\n\nstatic void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n\tint newly_acked_sacked = prior_unsacked -\n\t\t\t\t (tp->packets_out - tp->sacked_out);\n\n\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))\n\t\treturn;\n\n\ttp->prr_delivered += newly_acked_sacked;\n\tif (delta < 0) {\n\t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}\n\nstatic inline void tcp_end_cwnd_reduction(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Reset cwnd to ssthresh in CWR or Recovery (unless it's undone) */\n\tif (inet_csk(sk)->icsk_ca_state == TCP_CA_CWR ||\n\t    (tp->undo_marker && tp->snd_ssthresh < TCP_INFINITE_SSTHRESH)) {\n\t\ttp->snd_cwnd = tp->snd_ssthresh;\n\t\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\t}\n\ttcp_ca_event(sk, CA_EVENT_COMPLETE_CWR);\n}\n\n/* Enter CWR state. Disable cwnd undo since congestion is proven with ECN */\nvoid tcp_enter_cwr(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttp->prior_ssthresh = 0;\n\tif (inet_csk(sk)->icsk_ca_state < TCP_CA_CWR) {\n\t\ttp->undo_marker = 0;\n\t\ttcp_init_cwnd_reduction(sk);\n\t\ttcp_set_ca_state(sk, TCP_CA_CWR);\n\t}\n}\nEXPORT_SYMBOL(tcp_enter_cwr);\n\nstatic void tcp_try_keep_open(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint state = TCP_CA_Open;\n\n\tif (tcp_left_out(tp) || tcp_any_retrans_done(sk))\n\t\tstate = TCP_CA_Disorder;\n\n\tif (inet_csk(sk)->icsk_ca_state != state) {\n\t\ttcp_set_ca_state(sk, state);\n\t\ttp->high_seq = tp->snd_nxt;\n\t}\n}\n\nstatic void tcp_try_to_open(struct sock *sk, int flag, const int prior_unsacked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttcp_verify_left_out(tp);\n\n\tif (!tcp_any_retrans_done(sk))\n\t\ttp->retrans_stamp = 0;\n\n\tif (flag & FLAG_ECE)\n\t\ttcp_enter_cwr(sk);\n\n\tif (inet_csk(sk)->icsk_ca_state != TCP_CA_CWR) {\n\t\ttcp_try_keep_open(sk);\n\t} else {\n\t\ttcp_cwnd_reduction(sk, prior_unsacked, 0, flag);\n\t}\n}\n\nstatic void tcp_mtup_probe_failed(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ticsk->icsk_mtup.search_high = icsk->icsk_mtup.probe_size - 1;\n\ticsk->icsk_mtup.probe_size = 0;\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPMTUPFAIL);\n}\n\nstatic void tcp_mtup_probe_success(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\t/* FIXME: breaks with very large cwnd */\n\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\n\ttp->snd_cwnd = tp->snd_cwnd *\n\t\t       tcp_mss_to_mtu(sk, tp->mss_cache) /\n\t\t       icsk->icsk_mtup.probe_size;\n\ttp->snd_cwnd_cnt = 0;\n\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\ttp->snd_ssthresh = tcp_current_ssthresh(sk);\n\n\ticsk->icsk_mtup.search_low = icsk->icsk_mtup.probe_size;\n\ticsk->icsk_mtup.probe_size = 0;\n\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPMTUPSUCCESS);\n}\n\n/* Do a simple retransmit without using the backoff mechanisms in\n * tcp_timer. This is used for path mtu discovery.\n * The socket is already locked here.\n */\nvoid tcp_simple_retransmit(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned int mss = tcp_current_mss(sk);\n\tu32 prior_lost = tp->lost_out;\n\n\ttcp_for_write_queue(skb, sk) {\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\t\tif (tcp_skb_seglen(skb) > mss &&\n\t\t    !(TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED)) {\n\t\t\tif (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_RETRANS) {\n\t\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_RETRANS;\n\t\t\t\ttp->retrans_out -= tcp_skb_pcount(skb);\n\t\t\t}\n\t\t\ttcp_skb_mark_lost_uncond_verify(tp, skb);\n\t\t}\n\t}\n\n\ttcp_clear_retrans_hints_partial(tp);\n\n\tif (prior_lost == tp->lost_out)\n\t\treturn;\n\n\tif (tcp_is_reno(tp))\n\t\ttcp_limit_reno_sacked(tp);\n\n\ttcp_verify_left_out(tp);\n\n\t/* Don't muck with the congestion window here.\n\t * Reason is that we do not increase amount of _data_\n\t * in network, but units changed and effective\n\t * cwnd/ssthresh really reduced now.\n\t */\n\tif (icsk->icsk_ca_state != TCP_CA_Loss) {\n\t\ttp->high_seq = tp->snd_nxt;\n\t\ttp->snd_ssthresh = tcp_current_ssthresh(sk);\n\t\ttp->prior_ssthresh = 0;\n\t\ttp->undo_marker = 0;\n\t\ttcp_set_ca_state(sk, TCP_CA_Loss);\n\t}\n\ttcp_xmit_retransmit_queue(sk);\n}\nEXPORT_SYMBOL(tcp_simple_retransmit);\n\nstatic void tcp_enter_recovery(struct sock *sk, bool ece_ack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint mib_idx;\n\n\tif (tcp_is_reno(tp))\n\t\tmib_idx = LINUX_MIB_TCPRENORECOVERY;\n\telse\n\t\tmib_idx = LINUX_MIB_TCPSACKRECOVERY;\n\n\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\n\ttp->prior_ssthresh = 0;\n\ttcp_init_undo(tp);\n\n\tif (!tcp_in_cwnd_reduction(sk)) {\n\t\tif (!ece_ack)\n\t\t\ttp->prior_ssthresh = tcp_current_ssthresh(sk);\n\t\ttcp_init_cwnd_reduction(sk);\n\t}\n\ttcp_set_ca_state(sk, TCP_CA_Recovery);\n}\n\n/* Process an ACK in CA_Loss state. Move to CA_Open if lost data are\n * recovered or spurious. Otherwise retransmits more on partial ACKs.\n */\nstatic void tcp_process_loss(struct sock *sk, int flag, bool is_dupack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tbool recovered = !before(tp->snd_una, tp->high_seq);\n\n\tif ((flag & FLAG_SND_UNA_ADVANCED) &&\n\t    tcp_try_undo_loss(sk, false))\n\t\treturn;\n\n\tif (tp->frto) { /* F-RTO RFC5682 sec 3.1 (sack enhanced version). */\n\t\t/* Step 3.b. A timeout is spurious if not all data are\n\t\t * lost, i.e., never-retransmitted data are (s)acked.\n\t\t */\n\t\tif ((flag & FLAG_ORIG_SACK_ACKED) &&\n\t\t    tcp_try_undo_loss(sk, true))\n\t\t\treturn;\n\n\t\tif (after(tp->snd_nxt, tp->high_seq)) {\n\t\t\tif (flag & FLAG_DATA_SACKED || is_dupack)\n\t\t\t\ttp->frto = 0; /* Step 3.a. loss was real */\n\t\t} else if (flag & FLAG_SND_UNA_ADVANCED && !recovered) {\n\t\t\ttp->high_seq = tp->snd_nxt;\n\t\t\t__tcp_push_pending_frames(sk, tcp_current_mss(sk),\n\t\t\t\t\t\t  TCP_NAGLE_OFF);\n\t\t\tif (after(tp->snd_nxt, tp->high_seq))\n\t\t\t\treturn; /* Step 2.b */\n\t\t\ttp->frto = 0;\n\t\t}\n\t}\n\n\tif (recovered) {\n\t\t/* F-RTO RFC5682 sec 3.1 step 2.a and 1st part of step 3.a */\n\t\ttcp_try_undo_recovery(sk);\n\t\treturn;\n\t}\n\tif (tcp_is_reno(tp)) {\n\t\t/* A Reno DUPACK means new data in F-RTO step 2.b above are\n\t\t * delivered. Lower inflight to clock out (re)tranmissions.\n\t\t */\n\t\tif (after(tp->snd_nxt, tp->high_seq) && is_dupack)\n\t\t\ttcp_add_reno_sack(sk);\n\t\telse if (flag & FLAG_SND_UNA_ADVANCED)\n\t\t\ttcp_reset_reno_sack(tp);\n\t}\n\ttcp_xmit_retransmit_queue(sk);\n}\n\n/* Undo during fast recovery after partial ACK. */\nstatic bool tcp_try_undo_partial(struct sock *sk, const int acked,\n\t\t\t\t const int prior_unsacked, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tp->undo_marker && tcp_packet_delayed(tp)) {\n\t\t/* Plain luck! Hole if filled with delayed\n\t\t * packet, rather than with a retransmit.\n\t\t */\n\t\ttcp_update_reordering(sk, tcp_fackets_out(tp) + acked, 1);\n\n\t\t/* We are getting evidence that the reordering degree is higher\n\t\t * than we realized. If there are no retransmits out then we\n\t\t * can undo. Otherwise we clock out new packets but do not\n\t\t * mark more packets lost or retransmit more.\n\t\t */\n\t\tif (tp->retrans_out) {\n\t\t\ttcp_cwnd_reduction(sk, prior_unsacked, 0, flag);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!tcp_any_retrans_done(sk))\n\t\t\ttp->retrans_stamp = 0;\n\n\t\tDBGUNDO(sk, \"partial recovery\");\n\t\ttcp_undo_cwnd_reduction(sk, true);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPPARTIALUNDO);\n\t\ttcp_try_keep_open(sk);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* Process an event, which can update packets-in-flight not trivially.\n * Main goal of this function is to calculate new estimate for left_out,\n * taking into account both packets sitting in receiver's buffer and\n * packets lost by network.\n *\n * Besides that it does CWND reduction, when packet loss is detected\n * and changes state of machine.\n *\n * It does _not_ decide what to send, it is made in function\n * tcp_xmit_retransmit_queue().\n */\nstatic void tcp_fastretrans_alert(struct sock *sk, const int acked,\n\t\t\t\t  const int prior_unsacked,\n\t\t\t\t  bool is_dupack, int flag)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tbool do_lost = is_dupack || ((flag & FLAG_DATA_SACKED) &&\n\t\t\t\t    (tcp_fackets_out(tp) > tp->reordering));\n\tint fast_rexmit = 0;\n\n\tif (WARN_ON(!tp->packets_out && tp->sacked_out))\n\t\ttp->sacked_out = 0;\n\tif (WARN_ON(!tp->sacked_out && tp->fackets_out))\n\t\ttp->fackets_out = 0;\n\n\t/* Now state machine starts.\n\t * A. ECE, hence prohibit cwnd undoing, the reduction is required. */\n\tif (flag & FLAG_ECE)\n\t\ttp->prior_ssthresh = 0;\n\n\t/* B. In all the states check for reneging SACKs. */\n\tif (tcp_check_sack_reneging(sk, flag))\n\t\treturn;\n\n\t/* C. Check consistency of the current state. */\n\ttcp_verify_left_out(tp);\n\n\t/* D. Check state exit conditions. State can be terminated\n\t *    when high_seq is ACKed. */\n\tif (icsk->icsk_ca_state == TCP_CA_Open) {\n\t\tWARN_ON(tp->retrans_out != 0);\n\t\ttp->retrans_stamp = 0;\n\t} else if (!before(tp->snd_una, tp->high_seq)) {\n\t\tswitch (icsk->icsk_ca_state) {\n\t\tcase TCP_CA_CWR:\n\t\t\t/* CWR is to be held something *above* high_seq\n\t\t\t * is ACKed for CWR bit to reach receiver. */\n\t\t\tif (tp->snd_una != tp->high_seq) {\n\t\t\t\ttcp_end_cwnd_reduction(sk);\n\t\t\t\ttcp_set_ca_state(sk, TCP_CA_Open);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TCP_CA_Recovery:\n\t\t\tif (tcp_is_reno(tp))\n\t\t\t\ttcp_reset_reno_sack(tp);\n\t\t\tif (tcp_try_undo_recovery(sk))\n\t\t\t\treturn;\n\t\t\ttcp_end_cwnd_reduction(sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Use RACK to detect loss */\n\tif (sysctl_tcp_recovery & TCP_RACK_LOST_RETRANS &&\n\t    tcp_rack_mark_lost(sk))\n\t\tflag |= FLAG_LOST_RETRANS;\n\n\t/* E. Process state. */\n\tswitch (icsk->icsk_ca_state) {\n\tcase TCP_CA_Recovery:\n\t\tif (!(flag & FLAG_SND_UNA_ADVANCED)) {\n\t\t\tif (tcp_is_reno(tp) && is_dupack)\n\t\t\t\ttcp_add_reno_sack(sk);\n\t\t} else {\n\t\t\tif (tcp_try_undo_partial(sk, acked, prior_unsacked, flag))\n\t\t\t\treturn;\n\t\t\t/* Partial ACK arrived. Force fast retransmit. */\n\t\t\tdo_lost = tcp_is_reno(tp) ||\n\t\t\t\t  tcp_fackets_out(tp) > tp->reordering;\n\t\t}\n\t\tif (tcp_try_undo_dsack(sk)) {\n\t\t\ttcp_try_keep_open(sk);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase TCP_CA_Loss:\n\t\ttcp_process_loss(sk, flag, is_dupack);\n\t\tif (icsk->icsk_ca_state != TCP_CA_Open &&\n\t\t    !(flag & FLAG_LOST_RETRANS))\n\t\t\treturn;\n\t\t/* Change state if cwnd is undone or retransmits are lost */\n\tdefault:\n\t\tif (tcp_is_reno(tp)) {\n\t\t\tif (flag & FLAG_SND_UNA_ADVANCED)\n\t\t\t\ttcp_reset_reno_sack(tp);\n\t\t\tif (is_dupack)\n\t\t\t\ttcp_add_reno_sack(sk);\n\t\t}\n\n\t\tif (icsk->icsk_ca_state <= TCP_CA_Disorder)\n\t\t\ttcp_try_undo_dsack(sk);\n\n\t\tif (!tcp_time_to_recover(sk, flag)) {\n\t\t\ttcp_try_to_open(sk, flag, prior_unsacked);\n\t\t\treturn;\n\t\t}\n\n\t\t/* MTU probe failure: don't reduce cwnd */\n\t\tif (icsk->icsk_ca_state < TCP_CA_CWR &&\n\t\t    icsk->icsk_mtup.probe_size &&\n\t\t    tp->snd_una == tp->mtu_probe.probe_seq_start) {\n\t\t\ttcp_mtup_probe_failed(sk);\n\t\t\t/* Restores the reduction we did in tcp_mtup_probe() */\n\t\t\ttp->snd_cwnd++;\n\t\t\ttcp_simple_retransmit(sk);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Otherwise enter Recovery state */\n\t\ttcp_enter_recovery(sk, (flag & FLAG_ECE));\n\t\tfast_rexmit = 1;\n\t}\n\n\tif (do_lost)\n\t\ttcp_update_scoreboard(sk, fast_rexmit);\n\ttcp_cwnd_reduction(sk, prior_unsacked, fast_rexmit, flag);\n\ttcp_xmit_retransmit_queue(sk);\n}\n\n/* Kathleen Nichols' algorithm for tracking the minimum value of\n * a data stream over some fixed time interval. (E.g., the minimum\n * RTT over the past five minutes.) It uses constant space and constant\n * time per update yet almost always delivers the same minimum as an\n * implementation that has to keep all the data in the window.\n *\n * The algorithm keeps track of the best, 2nd best & 3rd best min\n * values, maintaining an invariant that the measurement time of the\n * n'th best >= n-1'th best. It also makes sure that the three values\n * are widely separated in the time window since that bounds the worse\n * case error when that data is monotonically increasing over the window.\n *\n * Upon getting a new min, we can forget everything earlier because it\n * has no value - the new min is <= everything else in the window by\n * definition and it's the most recent. So we restart fresh on every new min\n * and overwrites 2nd & 3rd choices. The same property holds for 2nd & 3rd\n * best.\n */\nstatic void tcp_update_rtt_min(struct sock *sk, u32 rtt_us)\n{\n\tconst u32 now = tcp_time_stamp, wlen = sysctl_tcp_min_rtt_wlen * HZ;\n\tstruct rtt_meas *m = tcp_sk(sk)->rtt_min;\n\tstruct rtt_meas rttm = { .rtt = (rtt_us ? : 1), .ts = now };\n\tu32 elapsed;\n\n\t/* Check if the new measurement updates the 1st, 2nd, or 3rd choices */\n\tif (unlikely(rttm.rtt <= m[0].rtt))\n\t\tm[0] = m[1] = m[2] = rttm;\n\telse if (rttm.rtt <= m[1].rtt)\n\t\tm[1] = m[2] = rttm;\n\telse if (rttm.rtt <= m[2].rtt)\n\t\tm[2] = rttm;\n\n\telapsed = now - m[0].ts;\n\tif (unlikely(elapsed > wlen)) {\n\t\t/* Passed entire window without a new min so make 2nd choice\n\t\t * the new min & 3rd choice the new 2nd. So forth and so on.\n\t\t */\n\t\tm[0] = m[1];\n\t\tm[1] = m[2];\n\t\tm[2] = rttm;\n\t\tif (now - m[0].ts > wlen) {\n\t\t\tm[0] = m[1];\n\t\t\tm[1] = rttm;\n\t\t\tif (now - m[0].ts > wlen)\n\t\t\t\tm[0] = rttm;\n\t\t}\n\t} else if (m[1].ts == m[0].ts && elapsed > wlen / 4) {\n\t\t/* Passed a quarter of the window without a new min so\n\t\t * take 2nd choice from the 2nd quarter of the window.\n\t\t */\n\t\tm[2] = m[1] = rttm;\n\t} else if (m[2].ts == m[1].ts && elapsed > wlen / 2) {\n\t\t/* Passed half the window without a new min so take the 3rd\n\t\t * choice from the last half of the window.\n\t\t */\n\t\tm[2] = rttm;\n\t}\n}\n\nstatic inline bool tcp_ack_update_rtt(struct sock *sk, const int flag,\n\t\t\t\t      long seq_rtt_us, long sack_rtt_us,\n\t\t\t\t      long ca_rtt_us)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Prefer RTT measured from ACK's timing to TS-ECR. This is because\n\t * broken middle-boxes or peers may corrupt TS-ECR fields. But\n\t * Karn's algorithm forbids taking RTT if some retransmitted data\n\t * is acked (RFC6298).\n\t */\n\tif (seq_rtt_us < 0)\n\t\tseq_rtt_us = sack_rtt_us;\n\n\t/* RTTM Rule: A TSecr value received in a segment is used to\n\t * update the averaged RTT measurement only if the segment\n\t * acknowledges some new data, i.e., only if it advances the\n\t * left edge of the send window.\n\t * See draft-ietf-tcplw-high-performance-00, section 3.3.\n\t */\n\tif (seq_rtt_us < 0 && tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\n\t    flag & FLAG_ACKED)\n\t\tseq_rtt_us = ca_rtt_us = jiffies_to_usecs(tcp_time_stamp -\n\t\t\t\t\t\t\t  tp->rx_opt.rcv_tsecr);\n\tif (seq_rtt_us < 0)\n\t\treturn false;\n\n\t/* ca_rtt_us >= 0 is counting on the invariant that ca_rtt_us is\n\t * always taken together with ACK, SACK, or TS-opts. Any negative\n\t * values will be skipped with the seq_rtt_us < 0 check above.\n\t */\n\ttcp_update_rtt_min(sk, ca_rtt_us);\n\ttcp_rtt_estimator(sk, seq_rtt_us);\n\ttcp_set_rto(sk);\n\n\t/* RFC6298: only reset backoff on valid RTT measurement. */\n\tinet_csk(sk)->icsk_backoff = 0;\n\treturn true;\n}\n\n/* Compute time elapsed between (last) SYNACK and the ACK completing 3WHS. */\nvoid tcp_synack_rtt_meas(struct sock *sk, struct request_sock *req)\n{\n\tlong rtt_us = -1L;\n\n\tif (req && !req->num_retrans && tcp_rsk(req)->snt_synack.v64) {\n\t\tstruct skb_mstamp now;\n\n\t\tskb_mstamp_get(&now);\n\t\trtt_us = skb_mstamp_us_delta(&now, &tcp_rsk(req)->snt_synack);\n\t}\n\n\ttcp_ack_update_rtt(sk, FLAG_SYN_ACKED, rtt_us, -1L, rtt_us);\n}\n\n\nstatic void tcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\ticsk->icsk_ca_ops->cong_avoid(sk, ack, acked);\n\ttcp_sk(sk)->snd_cwnd_stamp = tcp_time_stamp;\n}\n\n/* Restart timer after forward progress on connection.\n * RFC2988 recommends to restart timer to now+rto.\n */\nvoid tcp_rearm_rto(struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* If the retrans timer is currently being used by Fast Open\n\t * for SYN-ACK retrans purpose, stay put.\n\t */\n\tif (tp->fastopen_rsk)\n\t\treturn;\n\n\tif (!tp->packets_out) {\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);\n\t} else {\n\t\tu32 rto = inet_csk(sk)->icsk_rto;\n\t\t/* Offset the time elapsed after installing regular RTO */\n\t\tif (icsk->icsk_pending == ICSK_TIME_EARLY_RETRANS ||\n\t\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\n\t\t\tstruct sk_buff *skb = tcp_write_queue_head(sk);\n\t\t\tconst u32 rto_time_stamp =\n\t\t\t\ttcp_skb_timestamp(skb) + rto;\n\t\t\ts32 delta = (s32)(rto_time_stamp - tcp_time_stamp);\n\t\t\t/* delta may not be positive if the socket is locked\n\t\t\t * when the retrans timer fires and is rescheduled.\n\t\t\t */\n\t\t\tif (delta > 0)\n\t\t\t\trto = delta;\n\t\t}\n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, rto,\n\t\t\t\t\t  TCP_RTO_MAX);\n\t}\n}\n\n/* This function is called when the delayed ER timer fires. TCP enters\n * fast recovery and performs fast-retransmit.\n */\nvoid tcp_resume_early_retransmit(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\ttcp_rearm_rto(sk);\n\n\t/* Stop if ER is disabled after the delayed ER timer is scheduled */\n\tif (!tp->do_early_retrans)\n\t\treturn;\n\n\ttcp_enter_recovery(sk, false);\n\ttcp_update_scoreboard(sk, 1);\n\ttcp_xmit_retransmit_queue(sk);\n}\n\n/* If we get here, the whole TSO packet has not been acked. */\nstatic u32 tcp_tso_acked(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 packets_acked;\n\n\tBUG_ON(!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una));\n\n\tpackets_acked = tcp_skb_pcount(skb);\n\tif (tcp_trim_head(sk, skb, tp->snd_una - TCP_SKB_CB(skb)->seq))\n\t\treturn 0;\n\tpackets_acked -= tcp_skb_pcount(skb);\n\n\tif (packets_acked) {\n\t\tBUG_ON(tcp_skb_pcount(skb) == 0);\n\t\tBUG_ON(!before(TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq));\n\t}\n\n\treturn packets_acked;\n}\n\nstatic void tcp_ack_tstamp(struct sock *sk, struct sk_buff *skb,\n\t\t\t   u32 prior_snd_una)\n{\n\tconst struct skb_shared_info *shinfo;\n\n\t/* Avoid cache line misses to get skb_shinfo() and shinfo->tx_flags */\n\tif (likely(!(sk->sk_tsflags & SOF_TIMESTAMPING_TX_ACK)))\n\t\treturn;\n\n\tshinfo = skb_shinfo(skb);\n\tif ((shinfo->tx_flags & SKBTX_ACK_TSTAMP) &&\n\t    between(shinfo->tskey, prior_snd_una, tcp_sk(sk)->snd_una - 1))\n\t\t__skb_tstamp_tx(skb, NULL, sk, SCM_TSTAMP_ACK);\n}\n\n/* Remove acknowledged frames from the retransmission queue. If our packet\n * is before the ack sequence we can discard it as it's confirmed to have\n * arrived at the other end.\n */\nstatic int tcp_clean_rtx_queue(struct sock *sk, int prior_fackets,\n\t\t\t       u32 prior_snd_una,\n\t\t\t       struct tcp_sacktag_state *sack)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct skb_mstamp first_ackt, last_ackt, now;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 prior_sacked = tp->sacked_out;\n\tu32 reord = tp->packets_out;\n\tbool fully_acked = true;\n\tlong sack_rtt_us = -1L;\n\tlong seq_rtt_us = -1L;\n\tlong ca_rtt_us = -1L;\n\tstruct sk_buff *skb;\n\tu32 pkts_acked = 0;\n\tbool rtt_update;\n\tint flag = 0;\n\n\tfirst_ackt.v64 = 0;\n\n\twhile ((skb = tcp_write_queue_head(sk)) && skb != tcp_send_head(sk)) {\n\t\tstruct tcp_skb_cb *scb = TCP_SKB_CB(skb);\n\t\tu8 sacked = scb->sacked;\n\t\tu32 acked_pcount;\n\n\t\ttcp_ack_tstamp(sk, skb, prior_snd_una);\n\n\t\t/* Determine how many packets and what bytes were acked, tso and else */\n\t\tif (after(scb->end_seq, tp->snd_una)) {\n\t\t\tif (tcp_skb_pcount(skb) == 1 ||\n\t\t\t    !after(tp->snd_una, scb->seq))\n\t\t\t\tbreak;\n\n\t\t\tacked_pcount = tcp_tso_acked(sk, skb);\n\t\t\tif (!acked_pcount)\n\t\t\t\tbreak;\n\n\t\t\tfully_acked = false;\n\t\t} else {\n\t\t\t/* Speedup tcp_unlink_write_queue() and next loop */\n\t\t\tprefetchw(skb->next);\n\t\t\tacked_pcount = tcp_skb_pcount(skb);\n\t\t}\n\n\t\tif (unlikely(sacked & TCPCB_RETRANS)) {\n\t\t\tif (sacked & TCPCB_SACKED_RETRANS)\n\t\t\t\ttp->retrans_out -= acked_pcount;\n\t\t\tflag |= FLAG_RETRANS_DATA_ACKED;\n\t\t} else if (!(sacked & TCPCB_SACKED_ACKED)) {\n\t\t\tlast_ackt = skb->skb_mstamp;\n\t\t\tWARN_ON_ONCE(last_ackt.v64 == 0);\n\t\t\tif (!first_ackt.v64)\n\t\t\t\tfirst_ackt = last_ackt;\n\n\t\t\treord = min(pkts_acked, reord);\n\t\t\tif (!after(scb->end_seq, tp->high_seq))\n\t\t\t\tflag |= FLAG_ORIG_SACK_ACKED;\n\t\t}\n\n\t\tif (sacked & TCPCB_SACKED_ACKED)\n\t\t\ttp->sacked_out -= acked_pcount;\n\t\telse if (tcp_is_sack(tp) && !tcp_skb_spurious_retrans(tp, skb))\n\t\t\ttcp_rack_advance(tp, &skb->skb_mstamp, sacked);\n\t\tif (sacked & TCPCB_LOST)\n\t\t\ttp->lost_out -= acked_pcount;\n\n\t\ttp->packets_out -= acked_pcount;\n\t\tpkts_acked += acked_pcount;\n\n\t\t/* Initial outgoing SYN's get put onto the write_queue\n\t\t * just like anything else we transmit.  It is not\n\t\t * true data, and if we misinform our callers that\n\t\t * this ACK acks real data, we will erroneously exit\n\t\t * connection startup slow start one packet too\n\t\t * quickly.  This is severely frowned upon behavior.\n\t\t */\n\t\tif (likely(!(scb->tcp_flags & TCPHDR_SYN))) {\n\t\t\tflag |= FLAG_DATA_ACKED;\n\t\t} else {\n\t\t\tflag |= FLAG_SYN_ACKED;\n\t\t\ttp->retrans_stamp = 0;\n\t\t}\n\n\t\tif (!fully_acked)\n\t\t\tbreak;\n\n\t\ttcp_unlink_write_queue(skb, sk);\n\t\tsk_wmem_free_skb(sk, skb);\n\t\tif (unlikely(skb == tp->retransmit_skb_hint))\n\t\t\ttp->retransmit_skb_hint = NULL;\n\t\tif (unlikely(skb == tp->lost_skb_hint))\n\t\t\ttp->lost_skb_hint = NULL;\n\t}\n\n\tif (likely(between(tp->snd_up, prior_snd_una, tp->snd_una)))\n\t\ttp->snd_up = tp->snd_una;\n\n\tif (skb && (TCP_SKB_CB(skb)->sacked & TCPCB_SACKED_ACKED))\n\t\tflag |= FLAG_SACK_RENEGING;\n\n\tskb_mstamp_get(&now);\n\tif (likely(first_ackt.v64) && !(flag & FLAG_RETRANS_DATA_ACKED)) {\n\t\tseq_rtt_us = skb_mstamp_us_delta(&now, &first_ackt);\n\t\tca_rtt_us = skb_mstamp_us_delta(&now, &last_ackt);\n\t}\n\tif (sack->first_sackt.v64) {\n\t\tsack_rtt_us = skb_mstamp_us_delta(&now, &sack->first_sackt);\n\t\tca_rtt_us = skb_mstamp_us_delta(&now, &sack->last_sackt);\n\t}\n\n\trtt_update = tcp_ack_update_rtt(sk, flag, seq_rtt_us, sack_rtt_us,\n\t\t\t\t\tca_rtt_us);\n\n\tif (flag & FLAG_ACKED) {\n\t\ttcp_rearm_rto(sk);\n\t\tif (unlikely(icsk->icsk_mtup.probe_size &&\n\t\t\t     !after(tp->mtu_probe.probe_seq_end, tp->snd_una))) {\n\t\t\ttcp_mtup_probe_success(sk);\n\t\t}\n\n\t\tif (tcp_is_reno(tp)) {\n\t\t\ttcp_remove_reno_sacks(sk, pkts_acked);\n\t\t} else {\n\t\t\tint delta;\n\n\t\t\t/* Non-retransmitted hole got filled? That's reordering */\n\t\t\tif (reord < prior_fackets)\n\t\t\t\ttcp_update_reordering(sk, tp->fackets_out - reord, 0);\n\n\t\t\tdelta = tcp_is_fack(tp) ? pkts_acked :\n\t\t\t\t\t\t  prior_sacked - tp->sacked_out;\n\t\t\ttp->lost_cnt_hint -= min(tp->lost_cnt_hint, delta);\n\t\t}\n\n\t\ttp->fackets_out -= min(pkts_acked, tp->fackets_out);\n\n\t} else if (skb && rtt_update && sack_rtt_us >= 0 &&\n\t\t   sack_rtt_us > skb_mstamp_us_delta(&now, &skb->skb_mstamp)) {\n\t\t/* Do not re-arm RTO if the sack RTT is measured from data sent\n\t\t * after when the head was last (re)transmitted. Otherwise the\n\t\t * timeout may continue to extend in loss recovery.\n\t\t */\n\t\ttcp_rearm_rto(sk);\n\t}\n\n\tif (icsk->icsk_ca_ops->pkts_acked)\n\t\ticsk->icsk_ca_ops->pkts_acked(sk, pkts_acked, ca_rtt_us);\n\n#if FASTRETRANS_DEBUG > 0\n\tWARN_ON((int)tp->sacked_out < 0);\n\tWARN_ON((int)tp->lost_out < 0);\n\tWARN_ON((int)tp->retrans_out < 0);\n\tif (!tp->packets_out && tcp_is_sack(tp)) {\n\t\ticsk = inet_csk(sk);\n\t\tif (tp->lost_out) {\n\t\t\tpr_debug(\"Leak l=%u %d\\n\",\n\t\t\t\t tp->lost_out, icsk->icsk_ca_state);\n\t\t\ttp->lost_out = 0;\n\t\t}\n\t\tif (tp->sacked_out) {\n\t\t\tpr_debug(\"Leak s=%u %d\\n\",\n\t\t\t\t tp->sacked_out, icsk->icsk_ca_state);\n\t\t\ttp->sacked_out = 0;\n\t\t}\n\t\tif (tp->retrans_out) {\n\t\t\tpr_debug(\"Leak r=%u %d\\n\",\n\t\t\t\t tp->retrans_out, icsk->icsk_ca_state);\n\t\t\ttp->retrans_out = 0;\n\t\t}\n\t}\n#endif\n\treturn flag;\n}\n\nstatic void tcp_ack_probe(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\t/* Was it a usable window open? */\n\n\tif (!after(TCP_SKB_CB(tcp_send_head(sk))->end_seq, tcp_wnd_end(tp))) {\n\t\ticsk->icsk_backoff = 0;\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_PROBE0);\n\t\t/* Socket must be waked up by subsequent tcp_data_snd_check().\n\t\t * This function is not for random using!\n\t\t */\n\t} else {\n\t\tunsigned long when = tcp_probe0_when(sk, TCP_RTO_MAX);\n\n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_PROBE0,\n\t\t\t\t\t  when, TCP_RTO_MAX);\n\t}\n}\n\nstatic inline bool tcp_ack_is_dubious(const struct sock *sk, const int flag)\n{\n\treturn !(flag & FLAG_NOT_DUP) || (flag & FLAG_CA_ALERT) ||\n\t\tinet_csk(sk)->icsk_ca_state != TCP_CA_Open;\n}\n\n/* Decide wheather to run the increase function of congestion control. */\nstatic inline bool tcp_may_raise_cwnd(const struct sock *sk, const int flag)\n{\n\tif (tcp_in_cwnd_reduction(sk))\n\t\treturn false;\n\n\t/* If reordering is high then always grow cwnd whenever data is\n\t * delivered regardless of its ordering. Otherwise stay conservative\n\t * and only grow cwnd on in-order delivery (RFC5681). A stretched ACK w/\n\t * new SACK or ECE mark may first advance cwnd here and later reduce\n\t * cwnd in tcp_fastretrans_alert() based on more states.\n\t */\n\tif (tcp_sk(sk)->reordering > sysctl_tcp_reordering)\n\t\treturn flag & FLAG_FORWARD_PROGRESS;\n\n\treturn flag & FLAG_DATA_ACKED;\n}\n\n/* Check that window update is acceptable.\n * The function assumes that snd_una<=ack<=snd_next.\n */\nstatic inline bool tcp_may_update_window(const struct tcp_sock *tp,\n\t\t\t\t\tconst u32 ack, const u32 ack_seq,\n\t\t\t\t\tconst u32 nwin)\n{\n\treturn\tafter(ack, tp->snd_una) ||\n\t\tafter(ack_seq, tp->snd_wl1) ||\n\t\t(ack_seq == tp->snd_wl1 && nwin > tp->snd_wnd);\n}\n\n/* If we update tp->snd_una, also update tp->bytes_acked */\nstatic void tcp_snd_una_update(struct tcp_sock *tp, u32 ack)\n{\n\tu32 delta = ack - tp->snd_una;\n\n\tu64_stats_update_begin(&tp->syncp);\n\ttp->bytes_acked += delta;\n\tu64_stats_update_end(&tp->syncp);\n\ttp->snd_una = ack;\n}\n\n/* If we update tp->rcv_nxt, also update tp->bytes_received */\nstatic void tcp_rcv_nxt_update(struct tcp_sock *tp, u32 seq)\n{\n\tu32 delta = seq - tp->rcv_nxt;\n\n\tu64_stats_update_begin(&tp->syncp);\n\ttp->bytes_received += delta;\n\tu64_stats_update_end(&tp->syncp);\n\ttp->rcv_nxt = seq;\n}\n\n/* Update our send window.\n *\n * Window update algorithm, described in RFC793/RFC1122 (used in linux-2.2\n * and in FreeBSD. NetBSD's one is even worse.) is wrong.\n */\nstatic int tcp_ack_update_window(struct sock *sk, const struct sk_buff *skb, u32 ack,\n\t\t\t\t u32 ack_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint flag = 0;\n\tu32 nwin = ntohs(tcp_hdr(skb)->window);\n\n\tif (likely(!tcp_hdr(skb)->syn))\n\t\tnwin <<= tp->rx_opt.snd_wscale;\n\n\tif (tcp_may_update_window(tp, ack, ack_seq, nwin)) {\n\t\tflag |= FLAG_WIN_UPDATE;\n\t\ttcp_update_wl(tp, ack_seq);\n\n\t\tif (tp->snd_wnd != nwin) {\n\t\t\ttp->snd_wnd = nwin;\n\n\t\t\t/* Note, it is the only place, where\n\t\t\t * fast path is recovered for sending TCP.\n\t\t\t */\n\t\t\ttp->pred_flags = 0;\n\t\t\ttcp_fast_path_check(sk);\n\n\t\t\tif (tcp_send_head(sk))\n\t\t\t\ttcp_slow_start_after_idle_check(sk);\n\n\t\t\tif (nwin > tp->max_window) {\n\t\t\t\ttp->max_window = nwin;\n\t\t\t\ttcp_sync_mss(sk, inet_csk(sk)->icsk_pmtu_cookie);\n\t\t\t}\n\t\t}\n\t}\n\n\ttcp_snd_una_update(tp, ack);\n\n\treturn flag;\n}\n\n/* Return true if we're currently rate-limiting out-of-window ACKs and\n * thus shouldn't send a dupack right now. We rate-limit dupacks in\n * response to out-of-window SYNs or ACKs to mitigate ACK loops or DoS\n * attacks that send repeated SYNs or ACKs for the same connection. To\n * do this, we do not send a duplicate SYNACK or ACK if the remote\n * endpoint is sending out-of-window SYNs or pure ACKs at a high rate.\n */\nbool tcp_oow_rate_limited(struct net *net, const struct sk_buff *skb,\n\t\t\t  int mib_idx, u32 *last_oow_ack_time)\n{\n\t/* Data packets without SYNs are not likely part of an ACK loop. */\n\tif ((TCP_SKB_CB(skb)->seq != TCP_SKB_CB(skb)->end_seq) &&\n\t    !tcp_hdr(skb)->syn)\n\t\tgoto not_rate_limited;\n\n\tif (*last_oow_ack_time) {\n\t\ts32 elapsed = (s32)(tcp_time_stamp - *last_oow_ack_time);\n\n\t\tif (0 <= elapsed && elapsed < sysctl_tcp_invalid_ratelimit) {\n\t\t\tNET_INC_STATS_BH(net, mib_idx);\n\t\t\treturn true;\t/* rate-limited: don't send yet! */\n\t\t}\n\t}\n\n\t*last_oow_ack_time = tcp_time_stamp;\n\nnot_rate_limited:\n\treturn false;\t/* not rate-limited: go ahead, send dupack now! */\n}\n\n/* RFC 5961 7 [ACK Throttling] */\nstatic void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\t/* unprotected vars, we dont care of overwrites */\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\n\t/* First check our per-socket dupack rate limit. */\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\n\t/* Then check the check host-wide RFC 5961 rate limit. */\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}\n\nstatic void tcp_store_ts_recent(struct tcp_sock *tp)\n{\n\ttp->rx_opt.ts_recent = tp->rx_opt.rcv_tsval;\n\ttp->rx_opt.ts_recent_stamp = get_seconds();\n}\n\nstatic void tcp_replace_ts_recent(struct tcp_sock *tp, u32 seq)\n{\n\tif (tp->rx_opt.saw_tstamp && !after(seq, tp->rcv_wup)) {\n\t\t/* PAWS bug workaround wrt. ACK frames, the PAWS discard\n\t\t * extra check below makes sure this can only happen\n\t\t * for pure ACK frames.  -DaveM\n\t\t *\n\t\t * Not only, also it occurs for expired timestamps.\n\t\t */\n\n\t\tif (tcp_paws_check(&tp->rx_opt, 0))\n\t\t\ttcp_store_ts_recent(tp);\n\t}\n}\n\n/* This routine deals with acks during a TLP episode.\n * We mark the end of a TLP episode on receiving TLP dupack or when\n * ack is after tlp_high_seq.\n * Ref: loss detection algorithm in draft-dukkipati-tcpm-tcp-loss-probe.\n */\nstatic void tcp_process_tlp_ack(struct sock *sk, u32 ack, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (before(ack, tp->tlp_high_seq))\n\t\treturn;\n\n\tif (flag & FLAG_DSACKING_ACK) {\n\t\t/* This DSACK means original and TLP probe arrived; no loss */\n\t\ttp->tlp_high_seq = 0;\n\t} else if (after(ack, tp->tlp_high_seq)) {\n\t\t/* ACK advances: there was a loss, so reduce cwnd. Reset\n\t\t * tlp_high_seq in tcp_init_cwnd_reduction()\n\t\t */\n\t\ttcp_init_cwnd_reduction(sk);\n\t\ttcp_set_ca_state(sk, TCP_CA_CWR);\n\t\ttcp_end_cwnd_reduction(sk);\n\t\ttcp_try_keep_open(sk);\n\t\tNET_INC_STATS_BH(sock_net(sk),\n\t\t\t\t LINUX_MIB_TCPLOSSPROBERECOVERY);\n\t} else if (!(flag & (FLAG_SND_UNA_ADVANCED |\n\t\t\t     FLAG_NOT_DUP | FLAG_DATA_SACKED))) {\n\t\t/* Pure dupack: original and TLP probe arrived; no loss */\n\t\ttp->tlp_high_seq = 0;\n\t}\n}\n\nstatic inline void tcp_in_ack_event(struct sock *sk, u32 flags)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_ops->in_ack_event)\n\t\ticsk->icsk_ca_ops->in_ack_event(sk, flags);\n}\n\n/* This routine deals with incoming acks, but not outgoing ones. */\nstatic int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_sacktag_state sack_state;\n\tu32 prior_snd_una = tp->snd_una;\n\tu32 ack_seq = TCP_SKB_CB(skb)->seq;\n\tu32 ack = TCP_SKB_CB(skb)->ack_seq;\n\tbool is_dupack = false;\n\tu32 prior_fackets;\n\tint prior_packets = tp->packets_out;\n\tconst int prior_unsacked = tp->packets_out - tp->sacked_out;\n\tint acked = 0; /* Number of packets newly acked */\n\n\tsack_state.first_sackt.v64 = 0;\n\n\t/* We very likely will need to access write queue head. */\n\tprefetchw(sk->sk_write_queue.next);\n\n\t/* If the ack is older than previous acks\n\t * then we can probably ignore it.\n\t */\n\tif (before(ack, prior_snd_una)) {\n\t\t/* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */\n\t\tif (before(ack, prior_snd_una - tp->max_window)) {\n\t\t\ttcp_send_challenge_ack(sk, skb);\n\t\t\treturn -1;\n\t\t}\n\t\tgoto old_ack;\n\t}\n\n\t/* If the ack includes data we haven't sent yet, discard\n\t * this segment (RFC793 Section 3.9).\n\t */\n\tif (after(ack, tp->snd_nxt))\n\t\tgoto invalid_ack;\n\n\tif (icsk->icsk_pending == ICSK_TIME_EARLY_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE)\n\t\ttcp_rearm_rto(sk);\n\n\tif (after(ack, prior_snd_una)) {\n\t\tflag |= FLAG_SND_UNA_ADVANCED;\n\t\ticsk->icsk_retransmits = 0;\n\t}\n\n\tprior_fackets = tp->fackets_out;\n\n\t/* ts_recent update must be made after we are sure that the packet\n\t * is in window.\n\t */\n\tif (flag & FLAG_UPDATE_TS_RECENT)\n\t\ttcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq);\n\n\tif (!(flag & FLAG_SLOWPATH) && after(ack, prior_snd_una)) {\n\t\t/* Window is constant, pure forward advance.\n\t\t * No more checks are required.\n\t\t * Note, we use the fact that SND.UNA>=SND.WL2.\n\t\t */\n\t\ttcp_update_wl(tp, ack_seq);\n\t\ttcp_snd_una_update(tp, ack);\n\t\tflag |= FLAG_WIN_UPDATE;\n\n\t\ttcp_in_ack_event(sk, CA_ACK_WIN_UPDATE);\n\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPHPACKS);\n\t} else {\n\t\tu32 ack_ev_flags = CA_ACK_SLOWPATH;\n\n\t\tif (ack_seq != TCP_SKB_CB(skb)->end_seq)\n\t\t\tflag |= FLAG_DATA;\n\t\telse\n\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPPUREACKS);\n\n\t\tflag |= tcp_ack_update_window(sk, skb, ack, ack_seq);\n\n\t\tif (TCP_SKB_CB(skb)->sacked)\n\t\t\tflag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,\n\t\t\t\t\t\t\t&sack_state);\n\n\t\tif (tcp_ecn_rcv_ecn_echo(tp, tcp_hdr(skb))) {\n\t\t\tflag |= FLAG_ECE;\n\t\t\tack_ev_flags |= CA_ACK_ECE;\n\t\t}\n\n\t\tif (flag & FLAG_WIN_UPDATE)\n\t\t\tack_ev_flags |= CA_ACK_WIN_UPDATE;\n\n\t\ttcp_in_ack_event(sk, ack_ev_flags);\n\t}\n\n\t/* We passed data and got it acked, remove any soft error\n\t * log. Something worked...\n\t */\n\tsk->sk_err_soft = 0;\n\ticsk->icsk_probes_out = 0;\n\ttp->rcv_tstamp = tcp_time_stamp;\n\tif (!prior_packets)\n\t\tgoto no_queue;\n\n\t/* See if we can take anything off of the retransmit queue. */\n\tacked = tp->packets_out;\n\tflag |= tcp_clean_rtx_queue(sk, prior_fackets, prior_snd_una,\n\t\t\t\t    &sack_state);\n\tacked -= tp->packets_out;\n\n\tif (tcp_ack_is_dubious(sk, flag)) {\n\t\tis_dupack = !(flag & (FLAG_SND_UNA_ADVANCED | FLAG_NOT_DUP));\n\t\ttcp_fastretrans_alert(sk, acked, prior_unsacked,\n\t\t\t\t      is_dupack, flag);\n\t}\n\tif (tp->tlp_high_seq)\n\t\ttcp_process_tlp_ack(sk, ack, flag);\n\n\t/* Advance cwnd if state allows */\n\tif (tcp_may_raise_cwnd(sk, flag))\n\t\ttcp_cong_avoid(sk, ack, acked);\n\n\tif ((flag & FLAG_FORWARD_PROGRESS) || !(flag & FLAG_NOT_DUP)) {\n\t\tstruct dst_entry *dst = __sk_dst_get(sk);\n\t\tif (dst)\n\t\t\tdst_confirm(dst);\n\t}\n\n\tif (icsk->icsk_pending == ICSK_TIME_RETRANS)\n\t\ttcp_schedule_loss_probe(sk);\n\ttcp_update_pacing_rate(sk);\n\treturn 1;\n\nno_queue:\n\t/* If data was DSACKed, see if we can undo a cwnd reduction. */\n\tif (flag & FLAG_DSACKING_ACK)\n\t\ttcp_fastretrans_alert(sk, acked, prior_unsacked,\n\t\t\t\t      is_dupack, flag);\n\t/* If this ack opens up a zero window, clear backoff.  It was\n\t * being used to time the probes, and is probably far higher than\n\t * it needs to be for normal retransmission.\n\t */\n\tif (tcp_send_head(sk))\n\t\ttcp_ack_probe(sk);\n\n\tif (tp->tlp_high_seq)\n\t\ttcp_process_tlp_ack(sk, ack, flag);\n\treturn 1;\n\ninvalid_ack:\n\tSOCK_DEBUG(sk, \"Ack %u after %u:%u\\n\", ack, tp->snd_una, tp->snd_nxt);\n\treturn -1;\n\nold_ack:\n\t/* If data was SACKed, tag it and see if we should send more data.\n\t * If data was DSACKed, see if we can undo a cwnd reduction.\n\t */\n\tif (TCP_SKB_CB(skb)->sacked) {\n\t\tflag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,\n\t\t\t\t\t\t&sack_state);\n\t\ttcp_fastretrans_alert(sk, acked, prior_unsacked,\n\t\t\t\t      is_dupack, flag);\n\t}\n\n\tSOCK_DEBUG(sk, \"Ack %u before %u:%u\\n\", ack, tp->snd_una, tp->snd_nxt);\n\treturn 0;\n}\n\nstatic void tcp_parse_fastopen_option(int len, const unsigned char *cookie,\n\t\t\t\t      bool syn, struct tcp_fastopen_cookie *foc,\n\t\t\t\t      bool exp_opt)\n{\n\t/* Valid only in SYN or SYN-ACK with an even length.  */\n\tif (!foc || !syn || len < 0 || (len & 1))\n\t\treturn;\n\n\tif (len >= TCP_FASTOPEN_COOKIE_MIN &&\n\t    len <= TCP_FASTOPEN_COOKIE_MAX)\n\t\tmemcpy(foc->val, cookie, len);\n\telse if (len != 0)\n\t\tlen = -1;\n\tfoc->len = len;\n\tfoc->exp = exp_opt;\n}\n\n/* Look for tcp options. Normally only called on SYN and SYNACK packets.\n * But, this can also be called on packets in the established flow when\n * the fast version below fails.\n */\nvoid tcp_parse_options(const struct sk_buff *skb,\n\t\t       struct tcp_options_received *opt_rx, int estab,\n\t\t       struct tcp_fastopen_cookie *foc)\n{\n\tconst unsigned char *ptr;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tint length = (th->doff * 4) - sizeof(struct tcphdr);\n\n\tptr = (const unsigned char *)(th + 1);\n\topt_rx->saw_tstamp = 0;\n\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn;\n\t\tcase TCPOPT_NOP:\t/* Ref: RFC 793 section 3.1 */\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2) /* \"silly options\" */\n\t\t\t\treturn;\n\t\t\tif (opsize > length)\n\t\t\t\treturn;\t/* don't parse partial options */\n\t\t\tswitch (opcode) {\n\t\t\tcase TCPOPT_MSS:\n\t\t\t\tif (opsize == TCPOLEN_MSS && th->syn && !estab) {\n\t\t\t\t\tu16 in_mss = get_unaligned_be16(ptr);\n\t\t\t\t\tif (in_mss) {\n\t\t\t\t\t\tif (opt_rx->user_mss &&\n\t\t\t\t\t\t    opt_rx->user_mss < in_mss)\n\t\t\t\t\t\t\tin_mss = opt_rx->user_mss;\n\t\t\t\t\t\topt_rx->mss_clamp = in_mss;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TCPOPT_WINDOW:\n\t\t\t\tif (opsize == TCPOLEN_WINDOW && th->syn &&\n\t\t\t\t    !estab && sysctl_tcp_window_scaling) {\n\t\t\t\t\t__u8 snd_wscale = *(__u8 *)ptr;\n\t\t\t\t\topt_rx->wscale_ok = 1;\n\t\t\t\t\tif (snd_wscale > 14) {\n\t\t\t\t\t\tnet_info_ratelimited(\"%s: Illegal window scaling value %d >14 received\\n\",\n\t\t\t\t\t\t\t\t     __func__,\n\t\t\t\t\t\t\t\t     snd_wscale);\n\t\t\t\t\t\tsnd_wscale = 14;\n\t\t\t\t\t}\n\t\t\t\t\topt_rx->snd_wscale = snd_wscale;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TCPOPT_TIMESTAMP:\n\t\t\t\tif ((opsize == TCPOLEN_TIMESTAMP) &&\n\t\t\t\t    ((estab && opt_rx->tstamp_ok) ||\n\t\t\t\t     (!estab && sysctl_tcp_timestamps))) {\n\t\t\t\t\topt_rx->saw_tstamp = 1;\n\t\t\t\t\topt_rx->rcv_tsval = get_unaligned_be32(ptr);\n\t\t\t\t\topt_rx->rcv_tsecr = get_unaligned_be32(ptr + 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TCPOPT_SACK_PERM:\n\t\t\t\tif (opsize == TCPOLEN_SACK_PERM && th->syn &&\n\t\t\t\t    !estab && sysctl_tcp_sack) {\n\t\t\t\t\topt_rx->sack_ok = TCP_SACK_SEEN;\n\t\t\t\t\ttcp_sack_reset(opt_rx);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TCPOPT_SACK:\n\t\t\t\tif ((opsize >= (TCPOLEN_SACK_BASE + TCPOLEN_SACK_PERBLOCK)) &&\n\t\t\t\t   !((opsize - TCPOLEN_SACK_BASE) % TCPOLEN_SACK_PERBLOCK) &&\n\t\t\t\t   opt_rx->sack_ok) {\n\t\t\t\t\tTCP_SKB_CB(skb)->sacked = (ptr - 2) - (unsigned char *)th;\n\t\t\t\t}\n\t\t\t\tbreak;\n#ifdef CONFIG_TCP_MD5SIG\n\t\t\tcase TCPOPT_MD5SIG:\n\t\t\t\t/*\n\t\t\t\t * The MD5 Hash has already been\n\t\t\t\t * checked (see tcp_v{4,6}_do_rcv()).\n\t\t\t\t */\n\t\t\t\tbreak;\n#endif\n\t\t\tcase TCPOPT_FASTOPEN:\n\t\t\t\ttcp_parse_fastopen_option(\n\t\t\t\t\topsize - TCPOLEN_FASTOPEN_BASE,\n\t\t\t\t\tptr, th->syn, foc, false);\n\t\t\t\tbreak;\n\n\t\t\tcase TCPOPT_EXP:\n\t\t\t\t/* Fast Open option shares code 254 using a\n\t\t\t\t * 16 bits magic number.\n\t\t\t\t */\n\t\t\t\tif (opsize >= TCPOLEN_EXP_FASTOPEN_BASE &&\n\t\t\t\t    get_unaligned_be16(ptr) ==\n\t\t\t\t    TCPOPT_FASTOPEN_MAGIC)\n\t\t\t\t\ttcp_parse_fastopen_option(opsize -\n\t\t\t\t\t\tTCPOLEN_EXP_FASTOPEN_BASE,\n\t\t\t\t\t\tptr + 2, th->syn, foc, true);\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tptr += opsize-2;\n\t\t\tlength -= opsize;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(tcp_parse_options);\n\nstatic bool tcp_parse_aligned_timestamp(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tconst __be32 *ptr = (const __be32 *)(th + 1);\n\n\tif (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)\n\t\t\t  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {\n\t\ttp->rx_opt.saw_tstamp = 1;\n\t\t++ptr;\n\t\ttp->rx_opt.rcv_tsval = ntohl(*ptr);\n\t\t++ptr;\n\t\tif (*ptr)\n\t\t\ttp->rx_opt.rcv_tsecr = ntohl(*ptr) - tp->tsoffset;\n\t\telse\n\t\t\ttp->rx_opt.rcv_tsecr = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* Fast parse options. This hopes to only see timestamps.\n * If it is wrong it falls back on tcp_parse_options().\n */\nstatic bool tcp_fast_parse_options(const struct sk_buff *skb,\n\t\t\t\t   const struct tcphdr *th, struct tcp_sock *tp)\n{\n\t/* In the spirit of fast parsing, compare doff directly to constant\n\t * values.  Because equality is used, short doff can be ignored here.\n\t */\n\tif (th->doff == (sizeof(*th) / 4)) {\n\t\ttp->rx_opt.saw_tstamp = 0;\n\t\treturn false;\n\t} else if (tp->rx_opt.tstamp_ok &&\n\t\t   th->doff == ((sizeof(*th) + TCPOLEN_TSTAMP_ALIGNED) / 4)) {\n\t\tif (tcp_parse_aligned_timestamp(tp, th))\n\t\t\treturn true;\n\t}\n\n\ttcp_parse_options(skb, &tp->rx_opt, 1, NULL);\n\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)\n\t\ttp->rx_opt.rcv_tsecr -= tp->tsoffset;\n\n\treturn true;\n}\n\n#ifdef CONFIG_TCP_MD5SIG\n/*\n * Parse MD5 Signature option\n */\nconst u8 *tcp_parse_md5sig_option(const struct tcphdr *th)\n{\n\tint length = (th->doff << 2) - sizeof(*th);\n\tconst u8 *ptr = (const u8 *)(th + 1);\n\n\t/* If the TCP option is too short, we can short cut */\n\tif (length < TCPOLEN_MD5SIG)\n\t\treturn NULL;\n\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn NULL;\n\t\tcase TCPOPT_NOP:\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2 || opsize > length)\n\t\t\t\treturn NULL;\n\t\t\tif (opcode == TCPOPT_MD5SIG)\n\t\t\t\treturn opsize == TCPOLEN_MD5SIG ? ptr : NULL;\n\t\t}\n\t\tptr += opsize - 2;\n\t\tlength -= opsize;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(tcp_parse_md5sig_option);\n#endif\n\n/* Sorry, PAWS as specified is broken wrt. pure-ACKs -DaveM\n *\n * It is not fatal. If this ACK does _not_ change critical state (seqs, window)\n * it can pass through stack. So, the following predicate verifies that\n * this segment is not used for anything but congestion avoidance or\n * fast retransmit. Moreover, we even are able to eliminate most of such\n * second order effects, if we apply some small \"replay\" window (~RTO)\n * to timestamp space.\n *\n * All these measures still do not guarantee that we reject wrapped ACKs\n * on networks with high bandwidth, when sequence space is recycled fastly,\n * but it guarantees that such events will be very rare and do not affect\n * connection seriously. This doesn't look nice, but alas, PAWS is really\n * buggy extension.\n *\n * [ Later note. Even worse! It is buggy for segments _with_ data. RFC\n * states that events when retransmit arrives after original data are rare.\n * It is a blatant lie. VJ forgot about fast retransmit! 8)8) It is\n * the biggest problem on large power networks even with minor reordering.\n * OK, let's give it small replay window. If peer clock is even 1hz, it is safe\n * up to bandwidth of 18Gigabit/sec. 8) ]\n */\n\nstatic int tcp_disordered_ack(const struct sock *sk, const struct sk_buff *skb)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tu32 seq = TCP_SKB_CB(skb)->seq;\n\tu32 ack = TCP_SKB_CB(skb)->ack_seq;\n\n\treturn (/* 1. Pure ACK with correct sequence number. */\n\t\t(th->ack && seq == TCP_SKB_CB(skb)->end_seq && seq == tp->rcv_nxt) &&\n\n\t\t/* 2. ... and duplicate ACK. */\n\t\tack == tp->snd_una &&\n\n\t\t/* 3. ... and does not update window. */\n\t\t!tcp_may_update_window(tp, ack, seq, ntohs(th->window) << tp->rx_opt.snd_wscale) &&\n\n\t\t/* 4. ... and sits in replay window. */\n\t\t(s32)(tp->rx_opt.ts_recent - tp->rx_opt.rcv_tsval) <= (inet_csk(sk)->icsk_rto * 1024) / HZ);\n}\n\nstatic inline bool tcp_paws_discard(const struct sock *sk,\n\t\t\t\t   const struct sk_buff *skb)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\treturn !tcp_paws_check(&tp->rx_opt, TCP_PAWS_WINDOW) &&\n\t       !tcp_disordered_ack(sk, skb);\n}\n\n/* Check segment sequence number for validity.\n *\n * Segment controls are considered valid, if the segment\n * fits to the window after truncation to the window. Acceptability\n * of data (and SYN, FIN, of course) is checked separately.\n * See tcp_data_queue(), for example.\n *\n * Also, controls (RST is main one) are accepted using RCV.WUP instead\n * of RCV.NXT. Peer still did not advance his SND.UNA when we\n * delayed ACK, so that hisSND.UNA<=ourRCV.WUP.\n * (borrowed from freebsd)\n */\n\nstatic inline bool tcp_sequence(const struct tcp_sock *tp, u32 seq, u32 end_seq)\n{\n\treturn\t!before(end_seq, tp->rcv_wup) &&\n\t\t!after(seq, tp->rcv_nxt + tcp_receive_window(tp));\n}\n\n/* When we get a reset we do this. */\nvoid tcp_reset(struct sock *sk)\n{\n\t/* We want the right error as BSD sees it (and indeed as we do). */\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\t\tsk->sk_err = ECONNREFUSED;\n\t\tbreak;\n\tcase TCP_CLOSE_WAIT:\n\t\tsk->sk_err = EPIPE;\n\t\tbreak;\n\tcase TCP_CLOSE:\n\t\treturn;\n\tdefault:\n\t\tsk->sk_err = ECONNRESET;\n\t}\n\t/* This barrier is coupled with smp_rmb() in tcp_poll() */\n\tsmp_wmb();\n\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_error_report(sk);\n\n\ttcp_done(sk);\n}\n\n/*\n * \tProcess the FIN bit. This now behaves as it is supposed to work\n *\tand the FIN takes effect when it is validly part of sequence\n *\tspace. Not before when we get holes.\n *\n *\tIf we are ESTABLISHED, a received fin moves us to CLOSE-WAIT\n *\t(and thence onto LAST-ACK and finally, CLOSE, we never enter\n *\tTIME-WAIT)\n *\n *\tIf we are in FINWAIT-1, a received FIN indicates simultaneous\n *\tclose and we go into CLOSING (and later onto TIME-WAIT)\n *\n *\tIf we are in FINWAIT-2, a received FIN moves us to TIME-WAIT.\n */\nstatic void tcp_fin(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tinet_csk_schedule_ack(sk);\n\n\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\tsock_set_flag(sk, SOCK_DONE);\n\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_RECV:\n\tcase TCP_ESTABLISHED:\n\t\t/* Move to CLOSE_WAIT */\n\t\ttcp_set_state(sk, TCP_CLOSE_WAIT);\n\t\tinet_csk(sk)->icsk_ack.pingpong = 1;\n\t\tbreak;\n\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSING:\n\t\t/* Received a retransmission of the FIN, do\n\t\t * nothing.\n\t\t */\n\t\tbreak;\n\tcase TCP_LAST_ACK:\n\t\t/* RFC793: Remain in the LAST-ACK state. */\n\t\tbreak;\n\n\tcase TCP_FIN_WAIT1:\n\t\t/* This case occurs when a simultaneous close\n\t\t * happens, we must ack the received FIN and\n\t\t * enter the CLOSING state.\n\t\t */\n\t\ttcp_send_ack(sk);\n\t\ttcp_set_state(sk, TCP_CLOSING);\n\t\tbreak;\n\tcase TCP_FIN_WAIT2:\n\t\t/* Received a FIN -- send ACK and enter TIME_WAIT. */\n\t\ttcp_send_ack(sk);\n\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\n\t\tbreak;\n\tdefault:\n\t\t/* Only TCP_LISTEN and TCP_CLOSE are left, in these\n\t\t * cases we should never reach this piece of code.\n\t\t */\n\t\tpr_err(\"%s: Impossible, sk->sk_state=%d\\n\",\n\t\t       __func__, sk->sk_state);\n\t\tbreak;\n\t}\n\n\t/* It _is_ possible, that we have something out-of-order _after_ FIN.\n\t * Probably, we should reset in this case. For now drop them.\n\t */\n\t__skb_queue_purge(&tp->out_of_order_queue);\n\tif (tcp_is_sack(tp))\n\t\ttcp_sack_reset(&tp->rx_opt);\n\tsk_mem_reclaim(sk);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\n\t\t/* Do not send POLL_HUP for half duplex close. */\n\t\tif (sk->sk_shutdown == SHUTDOWN_MASK ||\n\t\t    sk->sk_state == TCP_CLOSE)\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t\telse\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\t}\n}\n\nstatic inline bool tcp_sack_extend(struct tcp_sack_block *sp, u32 seq,\n\t\t\t\t  u32 end_seq)\n{\n\tif (!after(seq, sp->end_seq) && !after(sp->start_seq, end_seq)) {\n\t\tif (before(seq, sp->start_seq))\n\t\t\tsp->start_seq = seq;\n\t\tif (after(end_seq, sp->end_seq))\n\t\t\tsp->end_seq = end_seq;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void tcp_dsack_set(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_is_sack(tp) && sysctl_tcp_dsack) {\n\t\tint mib_idx;\n\n\t\tif (before(seq, tp->rcv_nxt))\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOLDSENT;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOFOSENT;\n\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\n\t\ttp->rx_opt.dsack = 1;\n\t\ttp->duplicate_sack[0].start_seq = seq;\n\t\ttp->duplicate_sack[0].end_seq = end_seq;\n\t}\n}\n\nstatic void tcp_dsack_extend(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (!tp->rx_opt.dsack)\n\t\ttcp_dsack_set(sk, seq, end_seq);\n\telse\n\t\ttcp_sack_extend(tp->duplicate_sack, seq, end_seq);\n}\n\nstatic void tcp_send_dupack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t    before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);\n\t\ttcp_enter_quickack_mode(sk);\n\n\t\tif (tcp_is_sack(tp) && sysctl_tcp_dsack) {\n\t\t\tu32 end_seq = TCP_SKB_CB(skb)->end_seq;\n\n\t\t\tif (after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt))\n\t\t\t\tend_seq = tp->rcv_nxt;\n\t\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, end_seq);\n\t\t}\n\t}\n\n\ttcp_send_ack(sk);\n}\n\n/* These routines update the SACK block as out-of-order packets arrive or\n * in-order packets close up the sequence space.\n */\nstatic void tcp_sack_maybe_coalesce(struct tcp_sock *tp)\n{\n\tint this_sack;\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\n\tstruct tcp_sack_block *swalk = sp + 1;\n\n\t/* See if the recent change to the first SACK eats into\n\t * or hits the sequence space of other SACK blocks, if so coalesce.\n\t */\n\tfor (this_sack = 1; this_sack < tp->rx_opt.num_sacks;) {\n\t\tif (tcp_sack_extend(sp, swalk->start_seq, swalk->end_seq)) {\n\t\t\tint i;\n\n\t\t\t/* Zap SWALK, by moving every further SACK up by one slot.\n\t\t\t * Decrease num_sacks.\n\t\t\t */\n\t\t\ttp->rx_opt.num_sacks--;\n\t\t\tfor (i = this_sack; i < tp->rx_opt.num_sacks; i++)\n\t\t\t\tsp[i] = sp[i + 1];\n\t\t\tcontinue;\n\t\t}\n\t\tthis_sack++, swalk++;\n\t}\n}\n\nstatic void tcp_sack_new_ofo_skb(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\n\tint cur_sacks = tp->rx_opt.num_sacks;\n\tint this_sack;\n\n\tif (!cur_sacks)\n\t\tgoto new_sack;\n\n\tfor (this_sack = 0; this_sack < cur_sacks; this_sack++, sp++) {\n\t\tif (tcp_sack_extend(sp, seq, end_seq)) {\n\t\t\t/* Rotate this_sack to the first one. */\n\t\t\tfor (; this_sack > 0; this_sack--, sp--)\n\t\t\t\tswap(*sp, *(sp - 1));\n\t\t\tif (cur_sacks > 1)\n\t\t\t\ttcp_sack_maybe_coalesce(tp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Could not find an adjacent existing SACK, build a new one,\n\t * put it at the front, and shift everyone else down.  We\n\t * always know there is at least one SACK present already here.\n\t *\n\t * If the sack array is full, forget about the last one.\n\t */\n\tif (this_sack >= TCP_NUM_SACKS) {\n\t\tthis_sack--;\n\t\ttp->rx_opt.num_sacks--;\n\t\tsp--;\n\t}\n\tfor (; this_sack > 0; this_sack--, sp--)\n\t\t*sp = *(sp - 1);\n\nnew_sack:\n\t/* Build the new head SACK, and we're done. */\n\tsp->start_seq = seq;\n\tsp->end_seq = end_seq;\n\ttp->rx_opt.num_sacks++;\n}\n\n/* RCV.NXT advances, some SACKs should be eaten. */\n\nstatic void tcp_sack_remove(struct tcp_sock *tp)\n{\n\tstruct tcp_sack_block *sp = &tp->selective_acks[0];\n\tint num_sacks = tp->rx_opt.num_sacks;\n\tint this_sack;\n\n\t/* Empty ofo queue, hence, all the SACKs are eaten. Clear. */\n\tif (skb_queue_empty(&tp->out_of_order_queue)) {\n\t\ttp->rx_opt.num_sacks = 0;\n\t\treturn;\n\t}\n\n\tfor (this_sack = 0; this_sack < num_sacks;) {\n\t\t/* Check if the start of the sack is covered by RCV.NXT. */\n\t\tif (!before(tp->rcv_nxt, sp->start_seq)) {\n\t\t\tint i;\n\n\t\t\t/* RCV.NXT must cover all the block! */\n\t\t\tWARN_ON(before(tp->rcv_nxt, sp->end_seq));\n\n\t\t\t/* Zap this SACK, by moving forward any other SACKS. */\n\t\t\tfor (i = this_sack+1; i < num_sacks; i++)\n\t\t\t\ttp->selective_acks[i-1] = tp->selective_acks[i];\n\t\t\tnum_sacks--;\n\t\t\tcontinue;\n\t\t}\n\t\tthis_sack++;\n\t\tsp++;\n\t}\n\ttp->rx_opt.num_sacks = num_sacks;\n}\n\n/**\n * tcp_try_coalesce - try to merge skb to prior one\n * @sk: socket\n * @to: prior buffer\n * @from: buffer to add in queue\n * @fragstolen: pointer to boolean\n *\n * Before queueing skb @from after @to, try to merge them\n * to reduce overall memory use and queue lengths, if cost is small.\n * Packets in ofo or receive queues can stay a long time.\n * Better try to coalesce them right now to avoid future collapses.\n * Returns true if caller should free @from instead of queueing it\n */\nstatic bool tcp_try_coalesce(struct sock *sk,\n\t\t\t     struct sk_buff *to,\n\t\t\t     struct sk_buff *from,\n\t\t\t     bool *fragstolen)\n{\n\tint delta;\n\n\t*fragstolen = false;\n\n\t/* Its possible this segment overlaps with prior segment in queue */\n\tif (TCP_SKB_CB(from)->seq != TCP_SKB_CB(to)->end_seq)\n\t\treturn false;\n\n\tif (!skb_try_coalesce(to, from, fragstolen, &delta))\n\t\treturn false;\n\n\tatomic_add(delta, &sk->sk_rmem_alloc);\n\tsk_mem_charge(sk, delta);\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPRCVCOALESCE);\n\tTCP_SKB_CB(to)->end_seq = TCP_SKB_CB(from)->end_seq;\n\tTCP_SKB_CB(to)->ack_seq = TCP_SKB_CB(from)->ack_seq;\n\tTCP_SKB_CB(to)->tcp_flags |= TCP_SKB_CB(from)->tcp_flags;\n\treturn true;\n}\n\n/* This one checks to see if we can put data from the\n * out_of_order queue into the receive_queue.\n */\nstatic void tcp_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t__u32 dsack_high = tp->rcv_nxt;\n\tstruct sk_buff *skb, *tail;\n\tbool fragstolen, eaten;\n\n\twhile ((skb = skb_peek(&tp->out_of_order_queue)) != NULL) {\n\t\tif (after(TCP_SKB_CB(skb)->seq, tp->rcv_nxt))\n\t\t\tbreak;\n\n\t\tif (before(TCP_SKB_CB(skb)->seq, dsack_high)) {\n\t\t\t__u32 dsack = dsack_high;\n\t\t\tif (before(TCP_SKB_CB(skb)->end_seq, dsack_high))\n\t\t\t\tdsack_high = TCP_SKB_CB(skb)->end_seq;\n\t\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb)->seq, dsack);\n\t\t}\n\n\t\t__skb_unlink(skb, &tp->out_of_order_queue);\n\t\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt)) {\n\t\t\tSOCK_DEBUG(sk, \"ofo packet was already received\\n\");\n\t\t\t__kfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tSOCK_DEBUG(sk, \"ofo requeuing : rcv_next %X seq %X - %X\\n\",\n\t\t\t   tp->rcv_nxt, TCP_SKB_CB(skb)->seq,\n\t\t\t   TCP_SKB_CB(skb)->end_seq);\n\n\t\ttail = skb_peek_tail(&sk->sk_receive_queue);\n\t\teaten = tail && tcp_try_coalesce(sk, tail, skb, &fragstolen);\n\t\ttcp_rcv_nxt_update(tp, TCP_SKB_CB(skb)->end_seq);\n\t\tif (!eaten)\n\t\t\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\t\ttcp_fin(sk);\n\t\tif (eaten)\n\t\t\tkfree_skb_partial(skb, fragstolen);\n\t}\n}\n\nstatic bool tcp_prune_ofo_queue(struct sock *sk);\nstatic int tcp_prune_queue(struct sock *sk);\n\nstatic int tcp_try_rmem_schedule(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t unsigned int size)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf ||\n\t    !sk_rmem_schedule(sk, skb, size)) {\n\n\t\tif (tcp_prune_queue(sk) < 0)\n\t\t\treturn -1;\n\n\t\tif (!sk_rmem_schedule(sk, skb, size)) {\n\t\t\tif (!tcp_prune_ofo_queue(sk))\n\t\t\t\treturn -1;\n\n\t\t\tif (!sk_rmem_schedule(sk, skb, size))\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void tcp_data_queue_ofo(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb1;\n\tu32 seq, end_seq;\n\n\ttcp_ecn_check_ce(tp, skb);\n\n\tif (unlikely(tcp_try_rmem_schedule(sk, skb, skb->truesize))) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPOFODROP);\n\t\t__kfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* Disable header prediction. */\n\ttp->pred_flags = 0;\n\tinet_csk_schedule_ack(sk);\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPOFOQUEUE);\n\tSOCK_DEBUG(sk, \"out of order segment: rcv_next %X seq %X - %X\\n\",\n\t\t   tp->rcv_nxt, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);\n\n\tskb1 = skb_peek_tail(&tp->out_of_order_queue);\n\tif (!skb1) {\n\t\t/* Initial out of order segment, build 1 SACK. */\n\t\tif (tcp_is_sack(tp)) {\n\t\t\ttp->rx_opt.num_sacks = 1;\n\t\t\ttp->selective_acks[0].start_seq = TCP_SKB_CB(skb)->seq;\n\t\t\ttp->selective_acks[0].end_seq =\n\t\t\t\t\t\tTCP_SKB_CB(skb)->end_seq;\n\t\t}\n\t\t__skb_queue_head(&tp->out_of_order_queue, skb);\n\t\tgoto end;\n\t}\n\n\tseq = TCP_SKB_CB(skb)->seq;\n\tend_seq = TCP_SKB_CB(skb)->end_seq;\n\n\tif (seq == TCP_SKB_CB(skb1)->end_seq) {\n\t\tbool fragstolen;\n\n\t\tif (!tcp_try_coalesce(sk, skb1, skb, &fragstolen)) {\n\t\t\t__skb_queue_after(&tp->out_of_order_queue, skb1, skb);\n\t\t} else {\n\t\t\ttcp_grow_window(sk, skb);\n\t\t\tkfree_skb_partial(skb, fragstolen);\n\t\t\tskb = NULL;\n\t\t}\n\n\t\tif (!tp->rx_opt.num_sacks ||\n\t\t    tp->selective_acks[0].end_seq != seq)\n\t\t\tgoto add_sack;\n\n\t\t/* Common case: data arrive in order after hole. */\n\t\ttp->selective_acks[0].end_seq = end_seq;\n\t\tgoto end;\n\t}\n\n\t/* Find place to insert this segment. */\n\twhile (1) {\n\t\tif (!after(TCP_SKB_CB(skb1)->seq, seq))\n\t\t\tbreak;\n\t\tif (skb_queue_is_first(&tp->out_of_order_queue, skb1)) {\n\t\t\tskb1 = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tskb1 = skb_queue_prev(&tp->out_of_order_queue, skb1);\n\t}\n\n\t/* Do skb overlap to previous one? */\n\tif (skb1 && before(seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\t/* All the bits are present. Drop. */\n\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPOFOMERGE);\n\t\t\t__kfree_skb(skb);\n\t\t\tskb = NULL;\n\t\t\ttcp_dsack_set(sk, seq, end_seq);\n\t\t\tgoto add_sack;\n\t\t}\n\t\tif (after(seq, TCP_SKB_CB(skb1)->seq)) {\n\t\t\t/* Partial overlap. */\n\t\t\ttcp_dsack_set(sk, seq,\n\t\t\t\t      TCP_SKB_CB(skb1)->end_seq);\n\t\t} else {\n\t\t\tif (skb_queue_is_first(&tp->out_of_order_queue,\n\t\t\t\t\t       skb1))\n\t\t\t\tskb1 = NULL;\n\t\t\telse\n\t\t\t\tskb1 = skb_queue_prev(\n\t\t\t\t\t&tp->out_of_order_queue,\n\t\t\t\t\tskb1);\n\t\t}\n\t}\n\tif (!skb1)\n\t\t__skb_queue_head(&tp->out_of_order_queue, skb);\n\telse\n\t\t__skb_queue_after(&tp->out_of_order_queue, skb1, skb);\n\n\t/* And clean segments covered by new one as whole. */\n\twhile (!skb_queue_is_last(&tp->out_of_order_queue, skb)) {\n\t\tskb1 = skb_queue_next(&tp->out_of_order_queue, skb);\n\n\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->seq))\n\t\t\tbreak;\n\t\tif (before(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\n\t\t\t\t\t end_seq);\n\t\t\tbreak;\n\t\t}\n\t\t__skb_unlink(skb1, &tp->out_of_order_queue);\n\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\n\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPOFOMERGE);\n\t\t__kfree_skb(skb1);\n\t}\n\nadd_sack:\n\tif (tcp_is_sack(tp))\n\t\ttcp_sack_new_ofo_skb(sk, seq, end_seq);\nend:\n\tif (skb) {\n\t\ttcp_grow_window(sk, skb);\n\t\tskb_set_owner_r(skb, sk);\n\t}\n}\n\nstatic int __must_check tcp_queue_rcv(struct sock *sk, struct sk_buff *skb, int hdrlen,\n\t\t  bool *fragstolen)\n{\n\tint eaten;\n\tstruct sk_buff *tail = skb_peek_tail(&sk->sk_receive_queue);\n\n\t__skb_pull(skb, hdrlen);\n\teaten = (tail &&\n\t\t tcp_try_coalesce(sk, tail, skb, fragstolen)) ? 1 : 0;\n\ttcp_rcv_nxt_update(tcp_sk(sk), TCP_SKB_CB(skb)->end_seq);\n\tif (!eaten) {\n\t\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tskb_set_owner_r(skb, sk);\n\t}\n\treturn eaten;\n}\n\nint tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\tint data_len = 0;\n\tbool fragstolen;\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tif (size > PAGE_SIZE) {\n\t\tint npages = min_t(size_t, size >> PAGE_SHIFT, MAX_SKB_FRAGS);\n\n\t\tdata_len = npages << PAGE_SHIFT;\n\t\tsize = data_len + (size & ~PAGE_MASK);\n\t}\n\tskb = alloc_skb_with_frags(size - data_len, data_len,\n\t\t\t\t   PAGE_ALLOC_COSTLY_ORDER,\n\t\t\t\t   &err, sk->sk_allocation);\n\tif (!skb)\n\t\tgoto err;\n\n\tskb_put(skb, size - data_len);\n\tskb->data_len = data_len;\n\tskb->len = size;\n\n\tif (tcp_try_rmem_schedule(sk, skb, skb->truesize))\n\t\tgoto err_free;\n\n\terr = skb_copy_datagram_from_iter(skb, 0, &msg->msg_iter, size);\n\tif (err)\n\t\tgoto err_free;\n\n\tTCP_SKB_CB(skb)->seq = tcp_sk(sk)->rcv_nxt;\n\tTCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq + size;\n\tTCP_SKB_CB(skb)->ack_seq = tcp_sk(sk)->snd_una - 1;\n\n\tif (tcp_queue_rcv(sk, skb, 0, &fragstolen)) {\n\t\tWARN_ON_ONCE(fragstolen); /* should not happen */\n\t\t__kfree_skb(skb);\n\t}\n\treturn size;\n\nerr_free:\n\tkfree_skb(skb);\nerr:\n\treturn err;\n\n}\n\nstatic void tcp_data_queue(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint eaten = -1;\n\tbool fragstolen = false;\n\n\tif (TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq)\n\t\tgoto drop;\n\n\tskb_dst_drop(skb);\n\t__skb_pull(skb, tcp_hdr(skb)->doff * 4);\n\n\ttcp_ecn_accept_cwr(tp, skb);\n\n\ttp->rx_opt.dsack = 0;\n\n\t/*  Queue data for delivery to the user.\n\t *  Packets in sequence go to the receive queue.\n\t *  Out of sequence packets to the out_of_order_queue.\n\t */\n\tif (TCP_SKB_CB(skb)->seq == tp->rcv_nxt) {\n\t\tif (tcp_receive_window(tp) == 0)\n\t\t\tgoto out_of_window;\n\n\t\t/* Ok. In sequence. In window. */\n\t\tif (tp->ucopy.task == current &&\n\t\t    tp->copied_seq == tp->rcv_nxt && tp->ucopy.len &&\n\t\t    sock_owned_by_user(sk) && !tp->urg_data) {\n\t\t\tint chunk = min_t(unsigned int, skb->len,\n\t\t\t\t\t  tp->ucopy.len);\n\n\t\t\t__set_current_state(TASK_RUNNING);\n\n\t\t\tlocal_bh_enable();\n\t\t\tif (!skb_copy_datagram_msg(skb, 0, tp->ucopy.msg, chunk)) {\n\t\t\t\ttp->ucopy.len -= chunk;\n\t\t\t\ttp->copied_seq += chunk;\n\t\t\t\teaten = (chunk == skb->len);\n\t\t\t\ttcp_rcv_space_adjust(sk);\n\t\t\t}\n\t\t\tlocal_bh_disable();\n\t\t}\n\n\t\tif (eaten <= 0) {\nqueue_and_out:\n\t\t\tif (eaten < 0) {\n\t\t\t\tif (skb_queue_len(&sk->sk_receive_queue) == 0)\n\t\t\t\t\tsk_forced_mem_schedule(sk, skb->truesize);\n\t\t\t\telse if (tcp_try_rmem_schedule(sk, skb, skb->truesize))\n\t\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\teaten = tcp_queue_rcv(sk, skb, 0, &fragstolen);\n\t\t}\n\t\ttcp_rcv_nxt_update(tp, TCP_SKB_CB(skb)->end_seq);\n\t\tif (skb->len)\n\t\t\ttcp_event_data_recv(sk, skb);\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\t\ttcp_fin(sk);\n\n\t\tif (!skb_queue_empty(&tp->out_of_order_queue)) {\n\t\t\ttcp_ofo_queue(sk);\n\n\t\t\t/* RFC2581. 4.2. SHOULD send immediate ACK, when\n\t\t\t * gap in queue is filled.\n\t\t\t */\n\t\t\tif (skb_queue_empty(&tp->out_of_order_queue))\n\t\t\t\tinet_csk(sk)->icsk_ack.pingpong = 0;\n\t\t}\n\n\t\tif (tp->rx_opt.num_sacks)\n\t\t\ttcp_sack_remove(tp);\n\n\t\ttcp_fast_path_check(sk);\n\n\t\tif (eaten > 0)\n\t\t\tkfree_skb_partial(skb, fragstolen);\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_data_ready(sk);\n\t\treturn;\n\t}\n\n\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt)) {\n\t\t/* A retransmit, 2nd most common case.  Force an immediate ack. */\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);\n\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);\n\nout_of_window:\n\t\ttcp_enter_quickack_mode(sk);\n\t\tinet_csk_schedule_ack(sk);\ndrop:\n\t\t__kfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* Out of window. F.e. zero window probe. */\n\tif (!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt + tcp_receive_window(tp)))\n\t\tgoto out_of_window;\n\n\ttcp_enter_quickack_mode(sk);\n\n\tif (before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {\n\t\t/* Partial packet, seq < rcv_next < end_seq */\n\t\tSOCK_DEBUG(sk, \"partial packet: rcv_next %X seq %X - %X\\n\",\n\t\t\t   tp->rcv_nxt, TCP_SKB_CB(skb)->seq,\n\t\t\t   TCP_SKB_CB(skb)->end_seq);\n\n\t\ttcp_dsack_set(sk, TCP_SKB_CB(skb)->seq, tp->rcv_nxt);\n\n\t\t/* If window is closed, drop tail of packet. But after\n\t\t * remembering D-SACK for its head made in previous line.\n\t\t */\n\t\tif (!tcp_receive_window(tp))\n\t\t\tgoto out_of_window;\n\t\tgoto queue_and_out;\n\t}\n\n\ttcp_data_queue_ofo(sk, skb);\n}\n\nstatic struct sk_buff *tcp_collapse_one(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\tstruct sk_buff_head *list)\n{\n\tstruct sk_buff *next = NULL;\n\n\tif (!skb_queue_is_last(list, skb))\n\t\tnext = skb_queue_next(list, skb);\n\n\t__skb_unlink(skb, list);\n\t__kfree_skb(skb);\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPRCVCOLLAPSED);\n\n\treturn next;\n}\n\n/* Collapse contiguous sequence of skbs head..tail with\n * sequence numbers start..end.\n *\n * If tail is NULL, this means until the end of the list.\n *\n * Segments with FIN/SYN are not collapsed (only because this\n * simplifies code)\n */\nstatic void\ntcp_collapse(struct sock *sk, struct sk_buff_head *list,\n\t     struct sk_buff *head, struct sk_buff *tail,\n\t     u32 start, u32 end)\n{\n\tstruct sk_buff *skb, *n;\n\tbool end_of_skbs;\n\n\t/* First, check that queue is collapsible and find\n\t * the point where collapsing can be useful. */\n\tskb = head;\nrestart:\n\tend_of_skbs = true;\n\tskb_queue_walk_from_safe(list, skb, n) {\n\t\tif (skb == tail)\n\t\t\tbreak;\n\t\t/* No new bits? It is possible on ofo queue. */\n\t\tif (!before(start, TCP_SKB_CB(skb)->end_seq)) {\n\t\t\tskb = tcp_collapse_one(sk, skb, list);\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/* The first skb to collapse is:\n\t\t * - not SYN/FIN and\n\t\t * - bloated or contains data before \"start\" or\n\t\t *   overlaps to the next one.\n\t\t */\n\t\tif (!(TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)) &&\n\t\t    (tcp_win_from_space(skb->truesize) > skb->len ||\n\t\t     before(TCP_SKB_CB(skb)->seq, start))) {\n\t\t\tend_of_skbs = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!skb_queue_is_last(list, skb)) {\n\t\t\tstruct sk_buff *next = skb_queue_next(list, skb);\n\t\t\tif (next != tail &&\n\t\t\t    TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(next)->seq) {\n\t\t\t\tend_of_skbs = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Decided to skip this, advance start seq. */\n\t\tstart = TCP_SKB_CB(skb)->end_seq;\n\t}\n\tif (end_of_skbs ||\n\t    (TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)))\n\t\treturn;\n\n\twhile (before(start, end)) {\n\t\tint copy = min_t(int, SKB_MAX_ORDER(0, 0), end - start);\n\t\tstruct sk_buff *nskb;\n\n\t\tnskb = alloc_skb(copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\treturn;\n\n\t\tmemcpy(nskb->cb, skb->cb, sizeof(skb->cb));\n\t\tTCP_SKB_CB(nskb)->seq = TCP_SKB_CB(nskb)->end_seq = start;\n\t\t__skb_queue_before(list, skb, nskb);\n\t\tskb_set_owner_r(nskb, sk);\n\n\t\t/* Copy data, releasing collapsed skbs. */\n\t\twhile (copy > 0) {\n\t\t\tint offset = start - TCP_SKB_CB(skb)->seq;\n\t\t\tint size = TCP_SKB_CB(skb)->end_seq - start;\n\n\t\t\tBUG_ON(offset < 0);\n\t\t\tif (size > 0) {\n\t\t\t\tsize = min(copy, size);\n\t\t\t\tif (skb_copy_bits(skb, offset, skb_put(nskb, size), size))\n\t\t\t\t\tBUG();\n\t\t\t\tTCP_SKB_CB(nskb)->end_seq += size;\n\t\t\t\tcopy -= size;\n\t\t\t\tstart += size;\n\t\t\t}\n\t\t\tif (!before(start, TCP_SKB_CB(skb)->end_seq)) {\n\t\t\t\tskb = tcp_collapse_one(sk, skb, list);\n\t\t\t\tif (!skb ||\n\t\t\t\t    skb == tail ||\n\t\t\t\t    (TCP_SKB_CB(skb)->tcp_flags & (TCPHDR_SYN | TCPHDR_FIN)))\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Collapse ofo queue. Algorithm: select contiguous sequence of skbs\n * and tcp_collapse() them until all the queue is collapsed.\n */\nstatic void tcp_collapse_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb = skb_peek(&tp->out_of_order_queue);\n\tstruct sk_buff *head;\n\tu32 start, end;\n\n\tif (!skb)\n\t\treturn;\n\n\tstart = TCP_SKB_CB(skb)->seq;\n\tend = TCP_SKB_CB(skb)->end_seq;\n\thead = skb;\n\n\tfor (;;) {\n\t\tstruct sk_buff *next = NULL;\n\n\t\tif (!skb_queue_is_last(&tp->out_of_order_queue, skb))\n\t\t\tnext = skb_queue_next(&tp->out_of_order_queue, skb);\n\t\tskb = next;\n\n\t\t/* Segment is terminated when we see gap or when\n\t\t * we are at the end of all the queue. */\n\t\tif (!skb ||\n\t\t    after(TCP_SKB_CB(skb)->seq, end) ||\n\t\t    before(TCP_SKB_CB(skb)->end_seq, start)) {\n\t\t\ttcp_collapse(sk, &tp->out_of_order_queue,\n\t\t\t\t     head, skb, start, end);\n\t\t\thead = skb;\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\t\t\t/* Start new segment */\n\t\t\tstart = TCP_SKB_CB(skb)->seq;\n\t\t\tend = TCP_SKB_CB(skb)->end_seq;\n\t\t} else {\n\t\t\tif (before(TCP_SKB_CB(skb)->seq, start))\n\t\t\t\tstart = TCP_SKB_CB(skb)->seq;\n\t\t\tif (after(TCP_SKB_CB(skb)->end_seq, end))\n\t\t\t\tend = TCP_SKB_CB(skb)->end_seq;\n\t\t}\n\t}\n}\n\n/*\n * Purge the out-of-order queue.\n * Return true if queue was pruned.\n */\nstatic bool tcp_prune_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tbool res = false;\n\n\tif (!skb_queue_empty(&tp->out_of_order_queue)) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_OFOPRUNED);\n\t\t__skb_queue_purge(&tp->out_of_order_queue);\n\n\t\t/* Reset SACK state.  A conforming SACK implementation will\n\t\t * do the same at a timeout based retransmit.  When a connection\n\t\t * is in a sad state like this, we care only about integrity\n\t\t * of the connection not performance.\n\t\t */\n\t\tif (tp->rx_opt.sack_ok)\n\t\t\ttcp_sack_reset(&tp->rx_opt);\n\t\tsk_mem_reclaim(sk);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\n/* Reduce allocated memory if we can, trying to get\n * the socket within its memory limits again.\n *\n * Return less than zero if we should start dropping frames\n * until the socket owning process reads some of the data\n * to stabilize the situation.\n */\nstatic int tcp_prune_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tSOCK_DEBUG(sk, \"prune_queue: c=%x\\n\", tp->copied_seq);\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PRUNECALLED);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\ttcp_clamp_window(sk);\n\telse if (tcp_under_memory_pressure(sk))\n\t\ttp->rcv_ssthresh = min(tp->rcv_ssthresh, 4U * tp->advmss);\n\n\ttcp_collapse_ofo_queue(sk);\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\ttcp_collapse(sk, &sk->sk_receive_queue,\n\t\t\t     skb_peek(&sk->sk_receive_queue),\n\t\t\t     NULL,\n\t\t\t     tp->copied_seq, tp->rcv_nxt);\n\tsk_mem_reclaim(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\treturn 0;\n\n\t/* Collapsing did not help, destructive actions follow.\n\t * This must not ever occur. */\n\n\ttcp_prune_ofo_queue(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\treturn 0;\n\n\t/* If we are really being abused, tell the caller to silently\n\t * drop receive data on the floor.  It will get retransmitted\n\t * and hopefully then we'll have sufficient space.\n\t */\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_RCVPRUNED);\n\n\t/* Massive buffer overcommit. */\n\ttp->pred_flags = 0;\n\treturn -1;\n}\n\nstatic bool tcp_should_expand_sndbuf(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t/* If the user specified a specific send buffer setting, do\n\t * not modify it.\n\t */\n\tif (sk->sk_userlocks & SOCK_SNDBUF_LOCK)\n\t\treturn false;\n\n\t/* If we are under global TCP memory pressure, do not expand.  */\n\tif (tcp_under_memory_pressure(sk))\n\t\treturn false;\n\n\t/* If we are under soft global TCP memory pressure, do not expand.  */\n\tif (sk_memory_allocated(sk) >= sk_prot_mem_limits(sk, 0))\n\t\treturn false;\n\n\t/* If we filled the congestion window, do not expand.  */\n\tif (tcp_packets_in_flight(tp) >= tp->snd_cwnd)\n\t\treturn false;\n\n\treturn true;\n}\n\n/* When incoming ACK allowed to free some skb from write_queue,\n * we remember this event in flag SOCK_QUEUE_SHRUNK and wake up socket\n * on the exit from tcp input handler.\n *\n * PROBLEM: sndbuf expansion does not work well with largesend.\n */\nstatic void tcp_new_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_should_expand_sndbuf(sk)) {\n\t\ttcp_sndbuf_expand(sk);\n\t\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\t}\n\n\tsk->sk_write_space(sk);\n}\n\nstatic void tcp_check_space(struct sock *sk)\n{\n\tif (sock_flag(sk, SOCK_QUEUE_SHRUNK)) {\n\t\tsock_reset_flag(sk, SOCK_QUEUE_SHRUNK);\n\t\t/* pairs with tcp_poll() */\n\t\tsmp_mb__after_atomic();\n\t\tif (sk->sk_socket &&\n\t\t    test_bit(SOCK_NOSPACE, &sk->sk_socket->flags))\n\t\t\ttcp_new_space(sk);\n\t}\n}\n\nstatic inline void tcp_data_snd_check(struct sock *sk)\n{\n\ttcp_push_pending_frames(sk);\n\ttcp_check_space(sk);\n}\n\n/*\n * Check if sending an ack is needed.\n */\nstatic void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t    /* More than one full frame received... */\n\tif (((tp->rcv_nxt - tp->rcv_wup) > inet_csk(sk)->icsk_ack.rcv_mss &&\n\t     /* ... and right edge of window advances far enough.\n\t      * (tcp_recvmsg() will send ACK otherwise). Or...\n\t      */\n\t     __tcp_select_window(sk) >= tp->rcv_wnd) ||\n\t    /* We ACK each frame or... */\n\t    tcp_in_quickack_mode(sk) ||\n\t    /* We have out of order data. */\n\t    (ofo_possible && skb_peek(&tp->out_of_order_queue))) {\n\t\t/* Then ack it now */\n\t\ttcp_send_ack(sk);\n\t} else {\n\t\t/* Else, send delayed ack. */\n\t\ttcp_send_delayed_ack(sk);\n\t}\n}\n\nstatic inline void tcp_ack_snd_check(struct sock *sk)\n{\n\tif (!inet_csk_ack_scheduled(sk)) {\n\t\t/* We sent a data segment already. */\n\t\treturn;\n\t}\n\t__tcp_ack_snd_check(sk, 1);\n}\n\n/*\n *\tThis routine is only called when we have urgent data\n *\tsignaled. Its the 'slow' part of tcp_urg. It could be\n *\tmoved inline now as tcp_urg is only called from one\n *\tplace. We handle URGent data wrong. We have to - as\n *\tBSD still doesn't use the correction from RFC961.\n *\tFor 1003.1g we should support a new option TCP_STDURG to permit\n *\teither form (or just set the sysctl tcp_stdurg).\n */\n\nstatic void tcp_check_urg(struct sock *sk, const struct tcphdr *th)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 ptr = ntohs(th->urg_ptr);\n\n\tif (ptr && !sysctl_tcp_stdurg)\n\t\tptr--;\n\tptr += ntohl(th->seq);\n\n\t/* Ignore urgent data that we've already seen and read. */\n\tif (after(tp->copied_seq, ptr))\n\t\treturn;\n\n\t/* Do not replay urg ptr.\n\t *\n\t * NOTE: interesting situation not covered by specs.\n\t * Misbehaving sender may send urg ptr, pointing to segment,\n\t * which we already have in ofo queue. We are not able to fetch\n\t * such data and will stay in TCP_URG_NOTYET until will be eaten\n\t * by recvmsg(). Seems, we are not obliged to handle such wicked\n\t * situations. But it is worth to think about possibility of some\n\t * DoSes using some hypothetical application level deadlock.\n\t */\n\tif (before(ptr, tp->rcv_nxt))\n\t\treturn;\n\n\t/* Do we already have a newer (or duplicate) urgent pointer? */\n\tif (tp->urg_data && !after(ptr, tp->urg_seq))\n\t\treturn;\n\n\t/* Tell the world about our new urgent pointer. */\n\tsk_send_sigurg(sk);\n\n\t/* We may be adding urgent data when the last byte read was\n\t * urgent. To do this requires some care. We cannot just ignore\n\t * tp->copied_seq since we would read the last urgent byte again\n\t * as data, nor can we alter copied_seq until this data arrives\n\t * or we break the semantics of SIOCATMARK (and thus sockatmark())\n\t *\n\t * NOTE. Double Dutch. Rendering to plain English: author of comment\n\t * above did something sort of \tsend(\"A\", MSG_OOB); send(\"B\", MSG_OOB);\n\t * and expect that both A and B disappear from stream. This is _wrong_.\n\t * Though this happens in BSD with high probability, this is occasional.\n\t * Any application relying on this is buggy. Note also, that fix \"works\"\n\t * only in this artificial test. Insert some normal data between A and B and we will\n\t * decline of BSD again. Verdict: it is better to remove to trap\n\t * buggy users.\n\t */\n\tif (tp->urg_seq == tp->copied_seq && tp->urg_data &&\n\t    !sock_flag(sk, SOCK_URGINLINE) && tp->copied_seq != tp->rcv_nxt) {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\ttp->copied_seq++;\n\t\tif (skb && !before(tp->copied_seq, TCP_SKB_CB(skb)->end_seq)) {\n\t\t\t__skb_unlink(skb, &sk->sk_receive_queue);\n\t\t\t__kfree_skb(skb);\n\t\t}\n\t}\n\n\ttp->urg_data = TCP_URG_NOTYET;\n\ttp->urg_seq = ptr;\n\n\t/* Disable header prediction. */\n\ttp->pred_flags = 0;\n}\n\n/* This is the 'fast' part of urgent handling. */\nstatic void tcp_urg(struct sock *sk, struct sk_buff *skb, const struct tcphdr *th)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* Check if we get a new urgent pointer - normally not. */\n\tif (th->urg)\n\t\ttcp_check_urg(sk, th);\n\n\t/* Do we wait for any urgent data? - normally not... */\n\tif (tp->urg_data == TCP_URG_NOTYET) {\n\t\tu32 ptr = tp->urg_seq - ntohl(th->seq) + (th->doff * 4) -\n\t\t\t  th->syn;\n\n\t\t/* Is the urgent pointer pointing into this packet? */\n\t\tif (ptr < skb->len) {\n\t\t\tu8 tmp;\n\t\t\tif (skb_copy_bits(skb, ptr, &tmp, 1))\n\t\t\t\tBUG();\n\t\t\ttp->urg_data = TCP_URG_VALID | tmp;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\tsk->sk_data_ready(sk);\n\t\t}\n\t}\n}\n\nstatic int tcp_copy_to_iovec(struct sock *sk, struct sk_buff *skb, int hlen)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint chunk = skb->len - hlen;\n\tint err;\n\n\tlocal_bh_enable();\n\tif (skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_msg(skb, hlen, tp->ucopy.msg, chunk);\n\telse\n\t\terr = skb_copy_and_csum_datagram_msg(skb, hlen, tp->ucopy.msg);\n\n\tif (!err) {\n\t\ttp->ucopy.len -= chunk;\n\t\ttp->copied_seq += chunk;\n\t\ttcp_rcv_space_adjust(sk);\n\t}\n\n\tlocal_bh_disable();\n\treturn err;\n}\n\nstatic __sum16 __tcp_checksum_complete_user(struct sock *sk,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\t__sum16 result;\n\n\tif (sock_owned_by_user(sk)) {\n\t\tlocal_bh_enable();\n\t\tresult = __tcp_checksum_complete(skb);\n\t\tlocal_bh_disable();\n\t} else {\n\t\tresult = __tcp_checksum_complete(skb);\n\t}\n\treturn result;\n}\n\nstatic inline bool tcp_checksum_complete_user(struct sock *sk,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\treturn !skb_csum_unnecessary(skb) &&\n\t       __tcp_checksum_complete_user(sk, skb);\n}\n\n/* Does PAWS and seqno based validation of an incoming segment, flags will\n * play significant role here.\n */\nstatic bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  const struct tcphdr *th, int syn_inerr)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t/* RFC1323: H1. Apply PAWS check first. */\n\tif (tcp_fast_parse_options(skb, th, tp) && tp->rx_opt.saw_tstamp &&\n\t    tcp_paws_discard(sk, skb)) {\n\t\tif (!th->rst) {\n\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSESTABREJECTED);\n\t\t\tif (!tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t\t\t  LINUX_MIB_TCPACKSKIPPEDPAWS,\n\t\t\t\t\t\t  &tp->last_oow_ack_time))\n\t\t\t\ttcp_send_dupack(sk, skb);\n\t\t\tgoto discard;\n\t\t}\n\t\t/* Reset is accepted even if it did not pass PAWS. */\n\t}\n\n\t/* Step 1: check sequence number */\n\tif (!tcp_sequence(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq)) {\n\t\t/* RFC793, page 37: \"In all states except SYN-SENT, all reset\n\t\t * (RST) segments are validated by checking their SEQ-fields.\"\n\t\t * And page 69: \"If an incoming segment is not acceptable,\n\t\t * an acknowledgment should be sent in reply (unless the RST\n\t\t * bit is set, if so drop the segment and return)\".\n\t\t */\n\t\tif (!th->rst) {\n\t\t\tif (th->syn)\n\t\t\t\tgoto syn_challenge;\n\t\t\tif (!tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t\t\t  LINUX_MIB_TCPACKSKIPPEDSEQ,\n\t\t\t\t\t\t  &tp->last_oow_ack_time))\n\t\t\t\ttcp_send_dupack(sk, skb);\n\t\t}\n\t\tgoto discard;\n\t}\n\n\t/* Step 2: check RST bit */\n\tif (th->rst) {\n\t\t/* RFC 5961 3.2 :\n\t\t * If sequence number exactly matches RCV.NXT, then\n\t\t *     RESET the connection\n\t\t * else\n\t\t *     Send a challenge ACK\n\t\t */\n\t\tif (TCP_SKB_CB(skb)->seq == tp->rcv_nxt)\n\t\t\ttcp_reset(sk);\n\t\telse\n\t\t\ttcp_send_challenge_ack(sk, skb);\n\t\tgoto discard;\n\t}\n\n\t/* step 3: check security and precedence [ignored] */\n\n\t/* step 4: Check for a SYN\n\t * RFC 5961 4.2 : Send a challenge ack\n\t */\n\tif (th->syn) {\nsyn_challenge:\n\t\tif (syn_inerr)\n\t\t\tTCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSYNCHALLENGE);\n\t\ttcp_send_challenge_ack(sk, skb);\n\t\tgoto discard;\n\t}\n\n\treturn true;\n\ndiscard:\n\t__kfree_skb(skb);\n\treturn false;\n}\n\n/*\n *\tTCP receive function for the ESTABLISHED state.\n *\n *\tIt is split into a fast path and a slow path. The fast path is\n * \tdisabled when:\n *\t- A zero window was announced from us - zero window probing\n *        is only handled properly in the slow path.\n *\t- Out of order segments arrived.\n *\t- Urgent data is expected.\n *\t- There is no buffer space left\n *\t- Unexpected TCP flags/window values/header lengths are received\n *\t  (detected by checking the TCP header against pred_flags)\n *\t- Data is sent in both directions. Fast path only supports pure senders\n *\t  or pure receivers (this means either the sequence number or the ack\n *\t  value must stay constant)\n *\t- Unexpected TCP option.\n *\n *\tWhen these conditions are not satisfied it drops into a standard\n *\treceive procedure patterned after RFC793 to handle all cases.\n *\tThe first three cases are guaranteed by proper pred_flags setting,\n *\tthe rest is checked inline. Fast processing is turned on in\n *\ttcp_data_queue when everything is OK.\n */\nvoid tcp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct tcphdr *th, unsigned int len)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (unlikely(!sk->sk_rx_dst))\n\t\tinet_csk(sk)->icsk_af_ops->sk_rx_dst_set(sk, skb);\n\t/*\n\t *\tHeader prediction.\n\t *\tThe code loosely follows the one in the famous\n\t *\t\"30 instruction TCP receive\" Van Jacobson mail.\n\t *\n\t *\tVan's trick is to deposit buffers into socket queue\n\t *\ton a device interrupt, to call tcp_recv function\n\t *\ton the receive process context and checksum and copy\n\t *\tthe buffer to user space. smart...\n\t *\n\t *\tOur current scheme is not silly either but we take the\n\t *\textra cost of the net_bh soft interrupt processing...\n\t *\tWe do checksum and copy also but from device to kernel.\n\t */\n\n\ttp->rx_opt.saw_tstamp = 0;\n\n\t/*\tpred_flags is 0xS?10 << 16 + snd_wnd\n\t *\tif header_prediction is to be made\n\t *\t'S' will always be tp->tcp_header_len >> 2\n\t *\t'?' will be 0 for the fast path, otherwise pred_flags is 0 to\n\t *  turn it off\t(when there are holes in the receive\n\t *\t space for instance)\n\t *\tPSH flag is ignored.\n\t */\n\n\tif ((tcp_flag_word(th) & TCP_HP_BITS) == tp->pred_flags &&\n\t    TCP_SKB_CB(skb)->seq == tp->rcv_nxt &&\n\t    !after(TCP_SKB_CB(skb)->ack_seq, tp->snd_nxt)) {\n\t\tint tcp_header_len = tp->tcp_header_len;\n\n\t\t/* Timestamp header prediction: tcp_header_len\n\t\t * is automatically equal to th->doff*4 due to pred_flags\n\t\t * match.\n\t\t */\n\n\t\t/* Check timestamp */\n\t\tif (tcp_header_len == sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) {\n\t\t\t/* No? Slow path! */\n\t\t\tif (!tcp_parse_aligned_timestamp(tp, th))\n\t\t\t\tgoto slow_path;\n\n\t\t\t/* If PAWS failed, check it more carefully in slow path */\n\t\t\tif ((s32)(tp->rx_opt.rcv_tsval - tp->rx_opt.ts_recent) < 0)\n\t\t\t\tgoto slow_path;\n\n\t\t\t/* DO NOT update ts_recent here, if checksum fails\n\t\t\t * and timestamp was corrupted part, it will result\n\t\t\t * in a hung connection since we will drop all\n\t\t\t * future packets due to the PAWS test.\n\t\t\t */\n\t\t}\n\n\t\tif (len <= tcp_header_len) {\n\t\t\t/* Bulk data transfer: sender */\n\t\t\tif (len == tcp_header_len) {\n\t\t\t\t/* Predicted packet is in window by definition.\n\t\t\t\t * seq == rcv_nxt and rcv_wup <= rcv_nxt.\n\t\t\t\t * Hence, check seq<=rcv_wup reduces to:\n\t\t\t\t */\n\t\t\t\tif (tcp_header_len ==\n\t\t\t\t    (sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &&\n\t\t\t\t    tp->rcv_nxt == tp->rcv_wup)\n\t\t\t\t\ttcp_store_ts_recent(tp);\n\n\t\t\t\t/* We know that such packets are checksummed\n\t\t\t\t * on entry.\n\t\t\t\t */\n\t\t\t\ttcp_ack(sk, skb, 0);\n\t\t\t\t__kfree_skb(skb);\n\t\t\t\ttcp_data_snd_check(sk);\n\t\t\t\treturn;\n\t\t\t} else { /* Header too small */\n\t\t\t\tTCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);\n\t\t\t\tgoto discard;\n\t\t\t}\n\t\t} else {\n\t\t\tint eaten = 0;\n\t\t\tbool fragstolen = false;\n\n\t\t\tif (tp->ucopy.task == current &&\n\t\t\t    tp->copied_seq == tp->rcv_nxt &&\n\t\t\t    len - tcp_header_len <= tp->ucopy.len &&\n\t\t\t    sock_owned_by_user(sk)) {\n\t\t\t\t__set_current_state(TASK_RUNNING);\n\n\t\t\t\tif (!tcp_copy_to_iovec(sk, skb, tcp_header_len)) {\n\t\t\t\t\t/* Predicted packet is in window by definition.\n\t\t\t\t\t * seq == rcv_nxt and rcv_wup <= rcv_nxt.\n\t\t\t\t\t * Hence, check seq<=rcv_wup reduces to:\n\t\t\t\t\t */\n\t\t\t\t\tif (tcp_header_len ==\n\t\t\t\t\t    (sizeof(struct tcphdr) +\n\t\t\t\t\t     TCPOLEN_TSTAMP_ALIGNED) &&\n\t\t\t\t\t    tp->rcv_nxt == tp->rcv_wup)\n\t\t\t\t\t\ttcp_store_ts_recent(tp);\n\n\t\t\t\t\ttcp_rcv_rtt_measure_ts(sk, skb);\n\n\t\t\t\t\t__skb_pull(skb, tcp_header_len);\n\t\t\t\t\ttcp_rcv_nxt_update(tp, TCP_SKB_CB(skb)->end_seq);\n\t\t\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPHPHITSTOUSER);\n\t\t\t\t\teaten = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!eaten) {\n\t\t\t\tif (tcp_checksum_complete_user(sk, skb))\n\t\t\t\t\tgoto csum_error;\n\n\t\t\t\tif ((int)skb->truesize > sk->sk_forward_alloc)\n\t\t\t\t\tgoto step5;\n\n\t\t\t\t/* Predicted packet is in window by definition.\n\t\t\t\t * seq == rcv_nxt and rcv_wup <= rcv_nxt.\n\t\t\t\t * Hence, check seq<=rcv_wup reduces to:\n\t\t\t\t */\n\t\t\t\tif (tcp_header_len ==\n\t\t\t\t    (sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &&\n\t\t\t\t    tp->rcv_nxt == tp->rcv_wup)\n\t\t\t\t\ttcp_store_ts_recent(tp);\n\n\t\t\t\ttcp_rcv_rtt_measure_ts(sk, skb);\n\n\t\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPHPHITS);\n\n\t\t\t\t/* Bulk data transfer: receiver */\n\t\t\t\teaten = tcp_queue_rcv(sk, skb, tcp_header_len,\n\t\t\t\t\t\t      &fragstolen);\n\t\t\t}\n\n\t\t\ttcp_event_data_recv(sk, skb);\n\n\t\t\tif (TCP_SKB_CB(skb)->ack_seq != tp->snd_una) {\n\t\t\t\t/* Well, only one small jumplet in fast path... */\n\t\t\t\ttcp_ack(sk, skb, FLAG_DATA);\n\t\t\t\ttcp_data_snd_check(sk);\n\t\t\t\tif (!inet_csk_ack_scheduled(sk))\n\t\t\t\t\tgoto no_ack;\n\t\t\t}\n\n\t\t\t__tcp_ack_snd_check(sk, 0);\nno_ack:\n\t\t\tif (eaten)\n\t\t\t\tkfree_skb_partial(skb, fragstolen);\n\t\t\tsk->sk_data_ready(sk);\n\t\t\treturn;\n\t\t}\n\t}\n\nslow_path:\n\tif (len < (th->doff << 2) || tcp_checksum_complete_user(sk, skb))\n\t\tgoto csum_error;\n\n\tif (!th->ack && !th->rst && !th->syn)\n\t\tgoto discard;\n\n\t/*\n\t *\tStandard slow path.\n\t */\n\n\tif (!tcp_validate_incoming(sk, skb, th, 1))\n\t\treturn;\n\nstep5:\n\tif (tcp_ack(sk, skb, FLAG_SLOWPATH | FLAG_UPDATE_TS_RECENT) < 0)\n\t\tgoto discard;\n\n\ttcp_rcv_rtt_measure_ts(sk, skb);\n\n\t/* Process urgent data. */\n\ttcp_urg(sk, skb, th);\n\n\t/* step 7: process the segment text */\n\ttcp_data_queue(sk, skb);\n\n\ttcp_data_snd_check(sk);\n\ttcp_ack_snd_check(sk);\n\treturn;\n\ncsum_error:\n\tTCP_INC_STATS_BH(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);\n\ndiscard:\n\t__kfree_skb(skb);\n}\nEXPORT_SYMBOL(tcp_rcv_established);\n\nvoid tcp_finish_connect(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_set_state(sk, TCP_ESTABLISHED);\n\n\tif (skb) {\n\t\ticsk->icsk_af_ops->sk_rx_dst_set(sk, skb);\n\t\tsecurity_inet_conn_established(sk, skb);\n\t}\n\n\t/* Make sure socket is routed, for correct metrics.  */\n\ticsk->icsk_af_ops->rebuild_header(sk);\n\n\ttcp_init_metrics(sk);\n\n\ttcp_init_congestion_control(sk);\n\n\t/* Prevent spurious tcp_cwnd_restart() on first data\n\t * packet.\n\t */\n\ttp->lsndtime = tcp_time_stamp;\n\n\ttcp_init_buffer_space(sk);\n\n\tif (sock_flag(sk, SOCK_KEEPOPEN))\n\t\tinet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));\n\n\tif (!tp->rx_opt.snd_wscale)\n\t\t__tcp_fast_path_on(tp, tp->snd_wnd);\n\telse\n\t\ttp->pred_flags = 0;\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t}\n}\n\nstatic bool tcp_rcv_fastopen_synack(struct sock *sk, struct sk_buff *synack,\n\t\t\t\t    struct tcp_fastopen_cookie *cookie)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *data = tp->syn_data ? tcp_write_queue_head(sk) : NULL;\n\tu16 mss = tp->rx_opt.mss_clamp, try_exp = 0;\n\tbool syn_drop = false;\n\n\tif (mss == tp->rx_opt.user_mss) {\n\t\tstruct tcp_options_received opt;\n\n\t\t/* Get original SYNACK MSS value if user MSS sets mss_clamp */\n\t\ttcp_clear_options(&opt);\n\t\topt.user_mss = opt.mss_clamp = 0;\n\t\ttcp_parse_options(synack, &opt, 0, NULL);\n\t\tmss = opt.mss_clamp;\n\t}\n\n\tif (!tp->syn_fastopen) {\n\t\t/* Ignore an unsolicited cookie */\n\t\tcookie->len = -1;\n\t} else if (tp->total_retrans) {\n\t\t/* SYN timed out and the SYN-ACK neither has a cookie nor\n\t\t * acknowledges data. Presumably the remote received only\n\t\t * the retransmitted (regular) SYNs: either the original\n\t\t * SYN-data or the corresponding SYN-ACK was dropped.\n\t\t */\n\t\tsyn_drop = (cookie->len < 0 && data);\n\t} else if (cookie->len < 0 && !tp->syn_data) {\n\t\t/* We requested a cookie but didn't get it. If we did not use\n\t\t * the (old) exp opt format then try so next time (try_exp=1).\n\t\t * Otherwise we go back to use the RFC7413 opt (try_exp=2).\n\t\t */\n\t\ttry_exp = tp->syn_fastopen_exp ? 2 : 1;\n\t}\n\n\ttcp_fastopen_cache_set(sk, mss, cookie, syn_drop, try_exp);\n\n\tif (data) { /* Retransmit unacked data in SYN */\n\t\ttcp_for_write_queue_from(data, sk) {\n\t\t\tif (data == tcp_send_head(sk) ||\n\t\t\t    __tcp_retransmit_skb(sk, data))\n\t\t\t\tbreak;\n\t\t}\n\t\ttcp_rearm_rto(sk);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPFASTOPENACTIVEFAIL);\n\t\treturn true;\n\t}\n\ttp->syn_data_acked = tp->syn_data;\n\tif (tp->syn_data_acked)\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPFASTOPENACTIVE);\n\treturn false;\n}\n\nstatic int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t const struct tcphdr *th)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_fastopen_cookie foc = { .len = -1 };\n\tint saved_clamp = tp->rx_opt.mss_clamp;\n\n\ttcp_parse_options(skb, &tp->rx_opt, 0, &foc);\n\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)\n\t\ttp->rx_opt.rcv_tsecr -= tp->tsoffset;\n\n\tif (th->ack) {\n\t\t/* rfc793:\n\t\t * \"If the state is SYN-SENT then\n\t\t *    first check the ACK bit\n\t\t *      If the ACK bit is set\n\t\t *\t  If SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send\n\t\t *        a reset (unless the RST bit is set, if so drop\n\t\t *        the segment and return)\"\n\t\t */\n\t\tif (!after(TCP_SKB_CB(skb)->ack_seq, tp->snd_una) ||\n\t\t    after(TCP_SKB_CB(skb)->ack_seq, tp->snd_nxt))\n\t\t\tgoto reset_and_undo;\n\n\t\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\n\t\t    !between(tp->rx_opt.rcv_tsecr, tp->retrans_stamp,\n\t\t\t     tcp_time_stamp)) {\n\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSACTIVEREJECTED);\n\t\t\tgoto reset_and_undo;\n\t\t}\n\n\t\t/* Now ACK is acceptable.\n\t\t *\n\t\t * \"If the RST bit is set\n\t\t *    If the ACK was acceptable then signal the user \"error:\n\t\t *    connection reset\", drop the segment, enter CLOSED state,\n\t\t *    delete TCB, and return.\"\n\t\t */\n\n\t\tif (th->rst) {\n\t\t\ttcp_reset(sk);\n\t\t\tgoto discard;\n\t\t}\n\n\t\t/* rfc793:\n\t\t *   \"fifth, if neither of the SYN or RST bits is set then\n\t\t *    drop the segment and return.\"\n\t\t *\n\t\t *    See note below!\n\t\t *                                        --ANK(990513)\n\t\t */\n\t\tif (!th->syn)\n\t\t\tgoto discard_and_undo;\n\n\t\t/* rfc793:\n\t\t *   \"If the SYN bit is on ...\n\t\t *    are acceptable then ...\n\t\t *    (our SYN has been ACKed), change the connection\n\t\t *    state to ESTABLISHED...\"\n\t\t */\n\n\t\ttcp_ecn_rcv_synack(tp, th);\n\n\t\ttcp_init_wl(tp, TCP_SKB_CB(skb)->seq);\n\t\ttcp_ack(sk, skb, FLAG_SLOWPATH);\n\n\t\t/* Ok.. it's good. Set up sequence numbers and\n\t\t * move to established.\n\t\t */\n\t\ttp->rcv_nxt = TCP_SKB_CB(skb)->seq + 1;\n\t\ttp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;\n\n\t\t/* RFC1323: The window in SYN & SYN/ACK segments is\n\t\t * never scaled.\n\t\t */\n\t\ttp->snd_wnd = ntohs(th->window);\n\n\t\tif (!tp->rx_opt.wscale_ok) {\n\t\t\ttp->rx_opt.snd_wscale = tp->rx_opt.rcv_wscale = 0;\n\t\t\ttp->window_clamp = min(tp->window_clamp, 65535U);\n\t\t}\n\n\t\tif (tp->rx_opt.saw_tstamp) {\n\t\t\ttp->rx_opt.tstamp_ok\t   = 1;\n\t\t\ttp->tcp_header_len =\n\t\t\t\tsizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\n\t\t\ttp->advmss\t    -= TCPOLEN_TSTAMP_ALIGNED;\n\t\t\ttcp_store_ts_recent(tp);\n\t\t} else {\n\t\t\ttp->tcp_header_len = sizeof(struct tcphdr);\n\t\t}\n\n\t\tif (tcp_is_sack(tp) && sysctl_tcp_fack)\n\t\t\ttcp_enable_fack(tp);\n\n\t\ttcp_mtup_init(sk);\n\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\ttcp_initialize_rcv_mss(sk);\n\n\t\t/* Remember, tcp_poll() does not lock socket!\n\t\t * Change state from SYN-SENT only after copied_seq\n\t\t * is initialized. */\n\t\ttp->copied_seq = tp->rcv_nxt;\n\n\t\tsmp_mb();\n\n\t\ttcp_finish_connect(sk, skb);\n\n\t\tif ((tp->syn_fastopen || tp->syn_data) &&\n\t\t    tcp_rcv_fastopen_synack(sk, skb, &foc))\n\t\t\treturn -1;\n\n\t\tif (sk->sk_write_pending ||\n\t\t    icsk->icsk_accept_queue.rskq_defer_accept ||\n\t\t    icsk->icsk_ack.pingpong) {\n\t\t\t/* Save one ACK. Data will be ready after\n\t\t\t * several ticks, if write_pending is set.\n\t\t\t *\n\t\t\t * It may be deleted, but with this feature tcpdumps\n\t\t\t * look so _wonderfully_ clever, that I was not able\n\t\t\t * to stand against the temptation 8)     --ANK\n\t\t\t */\n\t\t\tinet_csk_schedule_ack(sk);\n\t\t\ticsk->icsk_ack.lrcvtime = tcp_time_stamp;\n\t\t\ttcp_enter_quickack_mode(sk);\n\t\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,\n\t\t\t\t\t\t  TCP_DELACK_MAX, TCP_RTO_MAX);\n\ndiscard:\n\t\t\t__kfree_skb(skb);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\ttcp_send_ack(sk);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* No ACK in the segment */\n\n\tif (th->rst) {\n\t\t/* rfc793:\n\t\t * \"If the RST bit is set\n\t\t *\n\t\t *      Otherwise (no ACK) drop the segment and return.\"\n\t\t */\n\n\t\tgoto discard_and_undo;\n\t}\n\n\t/* PAWS check. */\n\tif (tp->rx_opt.ts_recent_stamp && tp->rx_opt.saw_tstamp &&\n\t    tcp_paws_reject(&tp->rx_opt, 0))\n\t\tgoto discard_and_undo;\n\n\tif (th->syn) {\n\t\t/* We see SYN without ACK. It is attempt of\n\t\t * simultaneous connect with crossed SYNs.\n\t\t * Particularly, it can be connect to self.\n\t\t */\n\t\ttcp_set_state(sk, TCP_SYN_RECV);\n\n\t\tif (tp->rx_opt.saw_tstamp) {\n\t\t\ttp->rx_opt.tstamp_ok = 1;\n\t\t\ttcp_store_ts_recent(tp);\n\t\t\ttp->tcp_header_len =\n\t\t\t\tsizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\n\t\t} else {\n\t\t\ttp->tcp_header_len = sizeof(struct tcphdr);\n\t\t}\n\n\t\ttp->rcv_nxt = TCP_SKB_CB(skb)->seq + 1;\n\t\ttp->copied_seq = tp->rcv_nxt;\n\t\ttp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;\n\n\t\t/* RFC1323: The window in SYN & SYN/ACK segments is\n\t\t * never scaled.\n\t\t */\n\t\ttp->snd_wnd    = ntohs(th->window);\n\t\ttp->snd_wl1    = TCP_SKB_CB(skb)->seq;\n\t\ttp->max_window = tp->snd_wnd;\n\n\t\ttcp_ecn_rcv_syn(tp, th);\n\n\t\ttcp_mtup_init(sk);\n\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\ttcp_initialize_rcv_mss(sk);\n\n\t\ttcp_send_synack(sk);\n#if 0\n\t\t/* Note, we could accept data and URG from this segment.\n\t\t * There are no obstacles to make this (except that we must\n\t\t * either change tcp_recvmsg() to prevent it from returning data\n\t\t * before 3WHS completes per RFC793, or employ TCP Fast Open).\n\t\t *\n\t\t * However, if we ignore data in ACKless segments sometimes,\n\t\t * we have no reasons to accept it sometimes.\n\t\t * Also, seems the code doing it in step6 of tcp_rcv_state_process\n\t\t * is not flawless. So, discard packet for sanity.\n\t\t * Uncomment this return to process the data.\n\t\t */\n\t\treturn -1;\n#else\n\t\tgoto discard;\n#endif\n\t}\n\t/* \"fifth, if neither of the SYN or RST bits is set then\n\t * drop the segment and return.\"\n\t */\n\ndiscard_and_undo:\n\ttcp_clear_options(&tp->rx_opt);\n\ttp->rx_opt.mss_clamp = saved_clamp;\n\tgoto discard;\n\nreset_and_undo:\n\ttcp_clear_options(&tp->rx_opt);\n\ttp->rx_opt.mss_clamp = saved_clamp;\n\treturn 1;\n}\n\n/*\n *\tThis function implements the receiving procedure of RFC 793 for\n *\tall states except ESTABLISHED and TIME_WAIT.\n *\tIt's called from both tcp_v4_rcv and tcp_v6_rcv and should be\n *\taddress independent.\n */\n\nint tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct request_sock *req;\n\tint queued = 0;\n\tbool acceptable;\n\n\ttp->rx_opt.saw_tstamp = 0;\n\n\tswitch (sk->sk_state) {\n\tcase TCP_CLOSE:\n\t\tgoto discard;\n\n\tcase TCP_LISTEN:\n\t\tif (th->ack)\n\t\t\treturn 1;\n\n\t\tif (th->rst)\n\t\t\tgoto discard;\n\n\t\tif (th->syn) {\n\t\t\tif (th->fin)\n\t\t\t\tgoto discard;\n\t\t\tif (icsk->icsk_af_ops->conn_request(sk, skb) < 0)\n\t\t\t\treturn 1;\n\n\t\t\t/* Now we have several options: In theory there is\n\t\t\t * nothing else in the frame. KA9Q has an option to\n\t\t\t * send data with the syn, BSD accepts data with the\n\t\t\t * syn up to the [to be] advertised window and\n\t\t\t * Solaris 2.1 gives you a protocol error. For now\n\t\t\t * we just ignore it, that fits the spec precisely\n\t\t\t * and avoids incompatibilities. It would be nice in\n\t\t\t * future to drop through and process the data.\n\t\t\t *\n\t\t\t * Now that TTCP is starting to be used we ought to\n\t\t\t * queue this data.\n\t\t\t * But, this leaves one open to an easy denial of\n\t\t\t * service attack, and SYN cookies can't defend\n\t\t\t * against this problem. So, we drop the data\n\t\t\t * in the interest of security over speed unless\n\t\t\t * it's still in use.\n\t\t\t */\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tgoto discard;\n\n\tcase TCP_SYN_SENT:\n\t\tqueued = tcp_rcv_synsent_state_process(sk, skb, th);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\n\t\t/* Do step6 onward by hand. */\n\t\ttcp_urg(sk, skb, th);\n\t\t__kfree_skb(skb);\n\t\ttcp_data_snd_check(sk);\n\t\treturn 0;\n\t}\n\n\treq = tp->fastopen_rsk;\n\tif (req) {\n\t\tWARN_ON_ONCE(sk->sk_state != TCP_SYN_RECV &&\n\t\t    sk->sk_state != TCP_FIN_WAIT1);\n\n\t\tif (!tcp_check_req(sk, skb, req, true))\n\t\t\tgoto discard;\n\t}\n\n\tif (!th->ack && !th->rst && !th->syn)\n\t\tgoto discard;\n\n\tif (!tcp_validate_incoming(sk, skb, th, 0))\n\t\treturn 0;\n\n\t/* step 5: check the ACK field */\n\tacceptable = tcp_ack(sk, skb, FLAG_SLOWPATH |\n\t\t\t\t      FLAG_UPDATE_TS_RECENT) > 0;\n\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_RECV:\n\t\tif (!acceptable)\n\t\t\treturn 1;\n\n\t\tif (!tp->srtt_us)\n\t\t\ttcp_synack_rtt_meas(sk, req);\n\n\t\t/* Once we leave TCP_SYN_RECV, we no longer need req\n\t\t * so release it.\n\t\t */\n\t\tif (req) {\n\t\t\ttp->total_retrans = req->num_retrans;\n\t\t\treqsk_fastopen_remove(sk, req, false);\n\t\t} else {\n\t\t\t/* Make sure socket is routed, for correct metrics. */\n\t\t\ticsk->icsk_af_ops->rebuild_header(sk);\n\t\t\ttcp_init_congestion_control(sk);\n\n\t\t\ttcp_mtup_init(sk);\n\t\t\ttp->copied_seq = tp->rcv_nxt;\n\t\t\ttcp_init_buffer_space(sk);\n\t\t}\n\t\tsmp_mb();\n\t\ttcp_set_state(sk, TCP_ESTABLISHED);\n\t\tsk->sk_state_change(sk);\n\n\t\t/* Note, that this wakeup is only for marginal crossed SYN case.\n\t\t * Passively open sockets are not waked up, because\n\t\t * sk->sk_sleep == NULL and sk->sk_socket == NULL.\n\t\t */\n\t\tif (sk->sk_socket)\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\n\t\ttp->snd_una = TCP_SKB_CB(skb)->ack_seq;\n\t\ttp->snd_wnd = ntohs(th->window) << tp->rx_opt.snd_wscale;\n\t\ttcp_init_wl(tp, TCP_SKB_CB(skb)->seq);\n\n\t\tif (tp->rx_opt.tstamp_ok)\n\t\t\ttp->advmss -= TCPOLEN_TSTAMP_ALIGNED;\n\n\t\tif (req) {\n\t\t\t/* Re-arm the timer because data may have been sent out.\n\t\t\t * This is similar to the regular data transmission case\n\t\t\t * when new data has just been ack'ed.\n\t\t\t *\n\t\t\t * (TFO) - we could try to be more aggressive and\n\t\t\t * retransmitting any data sooner based on when they\n\t\t\t * are sent out.\n\t\t\t */\n\t\t\ttcp_rearm_rto(sk);\n\t\t} else\n\t\t\ttcp_init_metrics(sk);\n\n\t\ttcp_update_pacing_rate(sk);\n\n\t\t/* Prevent spurious tcp_cwnd_restart() on first data packet */\n\t\ttp->lsndtime = tcp_time_stamp;\n\n\t\ttcp_initialize_rcv_mss(sk);\n\t\ttcp_fast_path_on(tp);\n\t\tbreak;\n\n\tcase TCP_FIN_WAIT1: {\n\t\tstruct dst_entry *dst;\n\t\tint tmo;\n\n\t\t/* If we enter the TCP_FIN_WAIT1 state and we are a\n\t\t * Fast Open socket and this is the first acceptable\n\t\t * ACK we have received, this would have acknowledged\n\t\t * our SYNACK so stop the SYNACK timer.\n\t\t */\n\t\tif (req) {\n\t\t\t/* Return RST if ack_seq is invalid.\n\t\t\t * Note that RFC793 only says to generate a\n\t\t\t * DUPACK for it but for TCP Fast Open it seems\n\t\t\t * better to treat this case like TCP_SYN_RECV\n\t\t\t * above.\n\t\t\t */\n\t\t\tif (!acceptable)\n\t\t\t\treturn 1;\n\t\t\t/* We no longer need the request sock. */\n\t\t\treqsk_fastopen_remove(sk, req, false);\n\t\t\ttcp_rearm_rto(sk);\n\t\t}\n\t\tif (tp->snd_una != tp->write_seq)\n\t\t\tbreak;\n\n\t\ttcp_set_state(sk, TCP_FIN_WAIT2);\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\t\tdst = __sk_dst_get(sk);\n\t\tif (dst)\n\t\t\tdst_confirm(dst);\n\n\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\t/* Wake up lingering close() */\n\t\t\tsk->sk_state_change(sk);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tp->linger2 < 0 ||\n\t\t    (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t\t     after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt))) {\n\t\t\ttcp_done(sk);\n\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t\t\treturn 1;\n\t\t}\n\n\t\ttmo = tcp_fin_time(sk);\n\t\tif (tmo > TCP_TIMEWAIT_LEN) {\n\t\t\tinet_csk_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);\n\t\t} else if (th->fin || sock_owned_by_user(sk)) {\n\t\t\t/* Bad case. We could lose such FIN otherwise.\n\t\t\t * It is not a big problem, but it looks confusing\n\t\t\t * and not so rare event. We still can lose it now,\n\t\t\t * if it spins in bh_lock_sock(), but it is really\n\t\t\t * marginal case.\n\t\t\t */\n\t\t\tinet_csk_reset_keepalive_timer(sk, tmo);\n\t\t} else {\n\t\t\ttcp_time_wait(sk, TCP_FIN_WAIT2, tmo);\n\t\t\tgoto discard;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase TCP_CLOSING:\n\t\tif (tp->snd_una == tp->write_seq) {\n\t\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\n\t\t\tgoto discard;\n\t\t}\n\t\tbreak;\n\n\tcase TCP_LAST_ACK:\n\t\tif (tp->snd_una == tp->write_seq) {\n\t\t\ttcp_update_metrics(sk);\n\t\t\ttcp_done(sk);\n\t\t\tgoto discard;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* step 6: check the URG bit */\n\ttcp_urg(sk, skb, th);\n\n\t/* step 7: process the segment text */\n\tswitch (sk->sk_state) {\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSING:\n\tcase TCP_LAST_ACK:\n\t\tif (!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt))\n\t\t\tbreak;\n\tcase TCP_FIN_WAIT1:\n\tcase TCP_FIN_WAIT2:\n\t\t/* RFC 793 says to queue data in these states,\n\t\t * RFC 1122 says we MUST send a reset.\n\t\t * BSD 4.4 also does reset.\n\t\t */\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t\t\t    after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt)) {\n\t\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t\t\t\ttcp_reset(sk);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t/* Fall through */\n\tcase TCP_ESTABLISHED:\n\t\ttcp_data_queue(sk, skb);\n\t\tqueued = 1;\n\t\tbreak;\n\t}\n\n\t/* tcp_data could move socket to TIME-WAIT */\n\tif (sk->sk_state != TCP_CLOSE) {\n\t\ttcp_data_snd_check(sk);\n\t\ttcp_ack_snd_check(sk);\n\t}\n\n\tif (!queued) {\ndiscard:\n\t\t__kfree_skb(skb);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_rcv_state_process);\n\nstatic inline void pr_drop_req(struct request_sock *req, __u16 port, int family)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\tif (family == AF_INET)\n\t\tnet_dbg_ratelimited(\"drop open request from %pI4/%u\\n\",\n\t\t\t\t    &ireq->ir_rmt_addr, port);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (family == AF_INET6)\n\t\tnet_dbg_ratelimited(\"drop open request from %pI6/%u\\n\",\n\t\t\t\t    &ireq->ir_v6_rmt_addr, port);\n#endif\n}\n\n/* RFC3168 : 6.1.1 SYN packets must not have ECT/ECN bits set\n *\n * If we receive a SYN packet with these bits set, it means a\n * network is playing bad games with TOS bits. In order to\n * avoid possible false congestion notifications, we disable\n * TCP ECN negotiation.\n *\n * Exception: tcp_ca wants ECN. This is required for DCTCP\n * congestion control: Linux DCTCP asserts ECT on all packets,\n * including SYN, which is most optimal solution; however,\n * others, such as FreeBSD do not.\n */\nstatic void tcp_ecn_create_request(struct request_sock *req,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   const struct sock *listen_sk,\n\t\t\t\t   const struct dst_entry *dst)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tconst struct net *net = sock_net(listen_sk);\n\tbool th_ecn = th->ece && th->cwr;\n\tbool ect, ecn_ok;\n\tu32 ecn_ok_dst;\n\n\tif (!th_ecn)\n\t\treturn;\n\n\tect = !INET_ECN_is_not_ect(TCP_SKB_CB(skb)->ip_dsfield);\n\tecn_ok_dst = dst_feature(dst, DST_FEATURE_ECN_MASK);\n\tecn_ok = net->ipv4.sysctl_tcp_ecn || ecn_ok_dst;\n\n\tif ((!ect && ecn_ok) || tcp_ca_needs_ecn(listen_sk) ||\n\t    (ecn_ok_dst & DST_FEATURE_ECN_CA))\n\t\tinet_rsk(req)->ecn_ok = 1;\n}\n\nstatic void tcp_openreq_init(struct request_sock *req,\n\t\t\t     const struct tcp_options_received *rx_opt,\n\t\t\t     struct sk_buff *skb, const struct sock *sk)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\treq->rsk_rcv_wnd = 0;\t\t/* So that tcp_send_synack() knows! */\n\treq->cookie_ts = 0;\n\ttcp_rsk(req)->rcv_isn = TCP_SKB_CB(skb)->seq;\n\ttcp_rsk(req)->rcv_nxt = TCP_SKB_CB(skb)->seq + 1;\n\tskb_mstamp_get(&tcp_rsk(req)->snt_synack);\n\ttcp_rsk(req)->last_oow_ack_time = 0;\n\treq->mss = rx_opt->mss_clamp;\n\treq->ts_recent = rx_opt->saw_tstamp ? rx_opt->rcv_tsval : 0;\n\tireq->tstamp_ok = rx_opt->tstamp_ok;\n\tireq->sack_ok = rx_opt->sack_ok;\n\tireq->snd_wscale = rx_opt->snd_wscale;\n\tireq->wscale_ok = rx_opt->wscale_ok;\n\tireq->acked = 0;\n\tireq->ecn_ok = 0;\n\tireq->ir_rmt_port = tcp_hdr(skb)->source;\n\tireq->ir_num = ntohs(tcp_hdr(skb)->dest);\n\tireq->ir_mark = inet_request_mark(sk, skb);\n}\n\nstruct request_sock *inet_reqsk_alloc(const struct request_sock_ops *ops,\n\t\t\t\t      struct sock *sk_listener,\n\t\t\t\t      bool attach_listener)\n{\n\tstruct request_sock *req = reqsk_alloc(ops, sk_listener,\n\t\t\t\t\t       attach_listener);\n\n\tif (req) {\n\t\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\t\tkmemcheck_annotate_bitfield(ireq, flags);\n\t\tireq->opt = NULL;\n\t\tatomic64_set(&ireq->ir_cookie, 0);\n\t\tireq->ireq_state = TCP_NEW_SYN_RECV;\n\t\twrite_pnet(&ireq->ireq_net, sock_net(sk_listener));\n\t\tireq->ireq_family = sk_listener->sk_family;\n\t}\n\n\treturn req;\n}\nEXPORT_SYMBOL(inet_reqsk_alloc);\n\n/*\n * Return true if a syncookie should be sent\n */\nstatic bool tcp_syn_flood_action(const struct sock *sk,\n\t\t\t\t const struct sk_buff *skb,\n\t\t\t\t const char *proto)\n{\n\tstruct request_sock_queue *queue = &inet_csk(sk)->icsk_accept_queue;\n\tconst char *msg = \"Dropping request\";\n\tbool want_cookie = false;\n\n#ifdef CONFIG_SYN_COOKIES\n\tif (sysctl_tcp_syncookies) {\n\t\tmsg = \"Sending cookies\";\n\t\twant_cookie = true;\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPREQQFULLDOCOOKIES);\n\t} else\n#endif\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPREQQFULLDROP);\n\n\tif (!queue->synflood_warned &&\n\t    sysctl_tcp_syncookies != 2 &&\n\t    xchg(&queue->synflood_warned, 1) == 0)\n\t\tpr_info(\"%s: Possible SYN flooding on port %d. %s.  Check SNMP counters.\\n\",\n\t\t\tproto, ntohs(tcp_hdr(skb)->dest), msg);\n\n\treturn want_cookie;\n}\n\nstatic void tcp_reqsk_record_syn(const struct sock *sk,\n\t\t\t\t struct request_sock *req,\n\t\t\t\t const struct sk_buff *skb)\n{\n\tif (tcp_sk(sk)->save_syn) {\n\t\tu32 len = skb_network_header_len(skb) + tcp_hdrlen(skb);\n\t\tu32 *copy;\n\n\t\tcopy = kmalloc(len + sizeof(u32), GFP_ATOMIC);\n\t\tif (copy) {\n\t\t\tcopy[0] = len;\n\t\t\tmemcpy(&copy[1], skb_network_header(skb), len);\n\t\t\treq->saved_syn = copy;\n\t\t}\n\t}\n}\n\nint tcp_conn_request(struct request_sock_ops *rsk_ops,\n\t\t     const struct tcp_request_sock_ops *af_ops,\n\t\t     struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_fastopen_cookie foc = { .len = -1 };\n\t__u32 isn = TCP_SKB_CB(skb)->tcp_tw_isn;\n\tstruct tcp_options_received tmp_opt;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sock *fastopen_sk = NULL;\n\tstruct dst_entry *dst = NULL;\n\tstruct request_sock *req;\n\tbool want_cookie = false;\n\tstruct flowi fl;\n\n\t/* TW buckets are converted to open requests without\n\t * limitations, they conserve resources and peer is\n\t * evidently real one.\n\t */\n\tif ((sysctl_tcp_syncookies == 2 ||\n\t     inet_csk_reqsk_queue_is_full(sk)) && !isn) {\n\t\twant_cookie = tcp_syn_flood_action(sk, skb, rsk_ops->slab_name);\n\t\tif (!want_cookie)\n\t\t\tgoto drop;\n\t}\n\n\n\t/* Accept backlog is full. If we have already queued enough\n\t * of warm entries in syn queue, drop request. It is better than\n\t * clogging syn queue with openreqs with exponentially increasing\n\t * timeout.\n\t */\n\tif (sk_acceptq_is_full(sk) && inet_csk_reqsk_queue_young(sk) > 1) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\n\t\tgoto drop;\n\t}\n\n\treq = inet_reqsk_alloc(rsk_ops, sk, !want_cookie);\n\tif (!req)\n\t\tgoto drop;\n\n\ttcp_rsk(req)->af_specific = af_ops;\n\n\ttcp_clear_options(&tmp_opt);\n\ttmp_opt.mss_clamp = af_ops->mss_clamp;\n\ttmp_opt.user_mss  = tp->rx_opt.user_mss;\n\ttcp_parse_options(skb, &tmp_opt, 0, want_cookie ? NULL : &foc);\n\n\tif (want_cookie && !tmp_opt.saw_tstamp)\n\t\ttcp_clear_options(&tmp_opt);\n\n\ttmp_opt.tstamp_ok = tmp_opt.saw_tstamp;\n\ttcp_openreq_init(req, &tmp_opt, skb, sk);\n\n\t/* Note: tcp_v6_init_req() might override ir_iif for link locals */\n\tinet_rsk(req)->ir_iif = sk->sk_bound_dev_if;\n\n\taf_ops->init_req(req, sk, skb);\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto drop_and_free;\n\n\tif (!want_cookie && !isn) {\n\t\t/* VJ's idea. We save last timestamp seen\n\t\t * from the destination in peer table, when entering\n\t\t * state TIME-WAIT, and check against it before\n\t\t * accepting new connection request.\n\t\t *\n\t\t * If \"isn\" is not zero, this request hit alive\n\t\t * timewait bucket, so that all the necessary checks\n\t\t * are made in the function processing timewait state.\n\t\t */\n\t\tif (tcp_death_row.sysctl_tw_recycle) {\n\t\t\tbool strict;\n\n\t\t\tdst = af_ops->route_req(sk, &fl, req, &strict);\n\n\t\t\tif (dst && strict &&\n\t\t\t    !tcp_peer_is_proven(req, dst, true,\n\t\t\t\t\t\ttmp_opt.saw_tstamp)) {\n\t\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSPASSIVEREJECTED);\n\t\t\t\tgoto drop_and_release;\n\t\t\t}\n\t\t}\n\t\t/* Kill the following clause, if you dislike this way. */\n\t\telse if (!sysctl_tcp_syncookies &&\n\t\t\t (sysctl_max_syn_backlog - inet_csk_reqsk_queue_len(sk) <\n\t\t\t  (sysctl_max_syn_backlog >> 2)) &&\n\t\t\t !tcp_peer_is_proven(req, dst, false,\n\t\t\t\t\t     tmp_opt.saw_tstamp)) {\n\t\t\t/* Without syncookies last quarter of\n\t\t\t * backlog is filled with destinations,\n\t\t\t * proven to be alive.\n\t\t\t * It means that we continue to communicate\n\t\t\t * to destinations, already remembered\n\t\t\t * to the moment of synflood.\n\t\t\t */\n\t\t\tpr_drop_req(req, ntohs(tcp_hdr(skb)->source),\n\t\t\t\t    rsk_ops->family);\n\t\t\tgoto drop_and_release;\n\t\t}\n\n\t\tisn = af_ops->init_seq(skb);\n\t}\n\tif (!dst) {\n\t\tdst = af_ops->route_req(sk, &fl, req, NULL);\n\t\tif (!dst)\n\t\t\tgoto drop_and_free;\n\t}\n\n\ttcp_ecn_create_request(req, skb, sk, dst);\n\n\tif (want_cookie) {\n\t\tisn = cookie_init_sequence(af_ops, sk, skb, &req->mss);\n\t\treq->cookie_ts = tmp_opt.tstamp_ok;\n\t\tif (!tmp_opt.tstamp_ok)\n\t\t\tinet_rsk(req)->ecn_ok = 0;\n\t}\n\n\ttcp_rsk(req)->snt_isn = isn;\n\ttcp_rsk(req)->txhash = net_tx_rndhash();\n\ttcp_openreq_init_rwin(req, sk, dst);\n\tif (!want_cookie) {\n\t\ttcp_reqsk_record_syn(sk, req, skb);\n\t\tfastopen_sk = tcp_try_fastopen(sk, skb, req, &foc, dst);\n\t}\n\tif (fastopen_sk) {\n\t\taf_ops->send_synack(fastopen_sk, dst, &fl, req,\n\t\t\t\t    &foc, false);\n\t\t/* Add the child socket directly into the accept queue */\n\t\tinet_csk_reqsk_queue_add(sk, req, fastopen_sk);\n\t\tsk->sk_data_ready(sk);\n\t\tbh_unlock_sock(fastopen_sk);\n\t\tsock_put(fastopen_sk);\n\t} else {\n\t\ttcp_rsk(req)->tfo_listener = false;\n\t\tif (!want_cookie)\n\t\t\tinet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);\n\t\taf_ops->send_synack(sk, dst, &fl, req,\n\t\t\t\t    &foc, !want_cookie);\n\t\tif (want_cookie)\n\t\t\tgoto drop_and_free;\n\t}\n\treqsk_put(req);\n\treturn 0;\n\ndrop_and_release:\n\tdst_release(dst);\ndrop_and_free:\n\treqsk_free(req);\ndrop:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn 0;\n}\nEXPORT_SYMBOL(tcp_conn_request);\n"], "buggy_code_start_loc": [2479], "buggy_code_end_loc": [2479], "fixing_code_start_loc": [2480], "fixing_code_end_loc": [2483], "type": "CWE-189", "message": "The tcp_cwnd_reduction function in net/ipv4/tcp_input.c in the Linux kernel before 4.3.5 allows remote attackers to cause a denial of service (divide-by-zero error and system crash) via crafted TCP traffic.", "other": {"cve": {"id": "CVE-2016-2070", "sourceIdentifier": "cve@mitre.org", "published": "2016-05-02T10:59:26.673", "lastModified": "2023-01-17T21:40:26.383", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The tcp_cwnd_reduction function in net/ipv4/tcp_input.c in the Linux kernel before 4.3.5 allows remote attackers to cause a denial of service (divide-by-zero error and system crash) via crafted TCP traffic."}, {"lang": "es", "value": "La funci\u00f3n tcp_cwnd_reduction en net/ipv4/tcp_input.c en el kernel de Linux en versiones anteriores a 4.3.5 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (error de divisi\u00f3n por cero y ca\u00edda de sistema) a trav\u00e9s de tr\u00e1fico TCP manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.3", "versionEndExcluding": "4.3.5", "matchCriteriaId": "3256DE6D-E1F9-46A2-B354-DAB376A4F546"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8b8a321ff72c785ed5e8b4cf6eda20b35d427390", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.3.5", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/01/25/5", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1302219", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/8b8a321ff72c785ed5e8b4cf6eda20b35d427390", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8b8a321ff72c785ed5e8b4cf6eda20b35d427390"}}