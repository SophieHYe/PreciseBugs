{"buggy_code": ["/* \n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES \n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN \n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF \n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, \n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS \n   SOFTWARE IS DISCLAIMED.\n*/\n\n#ifndef __L2CAP_H\n#define __L2CAP_H\n\n/* L2CAP defaults */\n#define L2CAP_DEFAULT_MTU\t\t672\n#define L2CAP_DEFAULT_FLUSH_TO\t\t0xffff\n#define L2CAP_DEFAULT_RX_WINDOW\t\t1\n#define L2CAP_DEFAULT_MAX_RECEIVE\t1\n#define L2CAP_DEFAULT_RETRANS_TO\t300    /* 300 milliseconds */\n#define L2CAP_DEFAULT_MONITOR_TO\t1000   /* 1 second */\n#define L2CAP_DEFAULT_MAX_RX_APDU\t0xfff7\n\n#define L2CAP_CONN_TIMEOUT\t(40000) /* 40 seconds */\n#define L2CAP_INFO_TIMEOUT\t(4000)  /*  4 seconds */\n\n/* L2CAP socket address */\nstruct sockaddr_l2 {\n\tsa_family_t\tl2_family;\n\t__le16\t\tl2_psm;\n\tbdaddr_t\tl2_bdaddr;\n\t__le16\t\tl2_cid;\n};\n\n/* L2CAP socket options */\n#define L2CAP_OPTIONS\t0x01\nstruct l2cap_options {\n\t__u16 omtu;\n\t__u16 imtu;\n\t__u16 flush_to;\n\t__u8  mode;\n};\n\n#define L2CAP_CONNINFO\t0x02\nstruct l2cap_conninfo {\n\t__u16 hci_handle;\n\t__u8  dev_class[3];\n};\n\n#define L2CAP_LM\t0x03\n#define L2CAP_LM_MASTER\t\t0x0001\n#define L2CAP_LM_AUTH\t\t0x0002\n#define L2CAP_LM_ENCRYPT\t0x0004\n#define L2CAP_LM_TRUSTED\t0x0008\n#define L2CAP_LM_RELIABLE\t0x0010\n#define L2CAP_LM_SECURE\t\t0x0020\n\n/* L2CAP command codes */\n#define L2CAP_COMMAND_REJ\t0x01\n#define L2CAP_CONN_REQ\t\t0x02\n#define L2CAP_CONN_RSP\t\t0x03\n#define L2CAP_CONF_REQ\t\t0x04\n#define L2CAP_CONF_RSP\t\t0x05\n#define L2CAP_DISCONN_REQ\t0x06\n#define L2CAP_DISCONN_RSP\t0x07\n#define L2CAP_ECHO_REQ\t\t0x08\n#define L2CAP_ECHO_RSP\t\t0x09\n#define L2CAP_INFO_REQ\t\t0x0a\n#define L2CAP_INFO_RSP\t\t0x0b\n\n/* L2CAP feature mask */\n#define L2CAP_FEAT_FLOWCTL\t0x00000001\n#define L2CAP_FEAT_RETRANS\t0x00000002\n#define L2CAP_FEAT_ERTM\t\t0x00000008\n#define L2CAP_FEAT_STREAMING\t0x00000010\n#define L2CAP_FEAT_FCS\t\t0x00000020\n#define L2CAP_FEAT_FIXED_CHAN\t0x00000080\n\n/* L2CAP checksum option */\n#define L2CAP_FCS_NONE\t\t0x00\n#define L2CAP_FCS_CRC16\t\t0x01\n\n/* L2CAP structures */\nstruct l2cap_hdr {\n\t__le16     len;\n\t__le16     cid;\n} __attribute__ ((packed));\n#define L2CAP_HDR_SIZE\t\t4\n\nstruct l2cap_cmd_hdr {\n\t__u8       code;\n\t__u8       ident;\n\t__le16     len;\n} __attribute__ ((packed));\n#define L2CAP_CMD_HDR_SIZE\t4\n\nstruct l2cap_cmd_rej {\n\t__le16     reason;\n} __attribute__ ((packed));\n\nstruct l2cap_conn_req {\n\t__le16     psm;\n\t__le16     scid;\n} __attribute__ ((packed));\n\nstruct l2cap_conn_rsp {\n\t__le16     dcid;\n\t__le16     scid;\n\t__le16     result;\n\t__le16     status;\n} __attribute__ ((packed));\n\n/* channel indentifier */\n#define L2CAP_CID_SIGNALING\t0x0001\n#define L2CAP_CID_CONN_LESS\t0x0002\n#define L2CAP_CID_DYN_START\t0x0040\n#define L2CAP_CID_DYN_END\t0xffff\n\n/* connect result */\n#define L2CAP_CR_SUCCESS\t0x0000\n#define L2CAP_CR_PEND\t\t0x0001\n#define L2CAP_CR_BAD_PSM\t0x0002\n#define L2CAP_CR_SEC_BLOCK\t0x0003\n#define L2CAP_CR_NO_MEM\t\t0x0004\n\n/* connect status */\n#define L2CAP_CS_NO_INFO\t0x0000\n#define L2CAP_CS_AUTHEN_PEND\t0x0001\n#define L2CAP_CS_AUTHOR_PEND\t0x0002\n\nstruct l2cap_conf_req {\n\t__le16     dcid;\n\t__le16     flags;\n\t__u8       data[0];\n} __attribute__ ((packed));\n\nstruct l2cap_conf_rsp {\n\t__le16     scid;\n\t__le16     flags;\n\t__le16     result;\n\t__u8       data[0];\n} __attribute__ ((packed));\n\n#define L2CAP_CONF_SUCCESS\t0x0000\n#define L2CAP_CONF_UNACCEPT\t0x0001\n#define L2CAP_CONF_REJECT\t0x0002\n#define L2CAP_CONF_UNKNOWN\t0x0003\n\nstruct l2cap_conf_opt {\n\t__u8       type;\n\t__u8       len;\n\t__u8       val[0];\n} __attribute__ ((packed));\n#define L2CAP_CONF_OPT_SIZE\t2\n\n#define L2CAP_CONF_HINT\t\t0x80\n#define L2CAP_CONF_MASK\t\t0x7f\n\n#define L2CAP_CONF_MTU\t\t0x01\n#define L2CAP_CONF_FLUSH_TO\t0x02\n#define L2CAP_CONF_QOS\t\t0x03\n#define L2CAP_CONF_RFC\t\t0x04\n#define L2CAP_CONF_FCS\t\t0x05\n\n#define L2CAP_CONF_MAX_SIZE\t22\n\nstruct l2cap_conf_rfc {\n\t__u8       mode;\n\t__u8       txwin_size;\n\t__u8       max_transmit;\n\t__le16     retrans_timeout;\n\t__le16     monitor_timeout;\n\t__le16     max_pdu_size;\n} __attribute__ ((packed));\n\n#define L2CAP_MODE_BASIC\t0x00\n#define L2CAP_MODE_RETRANS\t0x01\n#define L2CAP_MODE_FLOWCTL\t0x02\n#define L2CAP_MODE_ERTM\t\t0x03\n#define L2CAP_MODE_STREAMING\t0x04\n\nstruct l2cap_disconn_req {\n\t__le16     dcid;\n\t__le16     scid;\n} __attribute__ ((packed));\n\nstruct l2cap_disconn_rsp {\n\t__le16     dcid;\n\t__le16     scid;\n} __attribute__ ((packed));\n\nstruct l2cap_info_req {\n\t__le16      type;\n} __attribute__ ((packed));\n\nstruct l2cap_info_rsp {\n\t__le16      type;\n\t__le16      result;\n\t__u8        data[0];\n} __attribute__ ((packed));\n\n/* info type */\n#define L2CAP_IT_CL_MTU     0x0001\n#define L2CAP_IT_FEAT_MASK  0x0002\n#define L2CAP_IT_FIXED_CHAN 0x0003\n\n/* info result */\n#define L2CAP_IR_SUCCESS    0x0000\n#define L2CAP_IR_NOTSUPP    0x0001\n\n/* ----- L2CAP connections ----- */\nstruct l2cap_chan_list {\n\tstruct sock\t*head;\n\trwlock_t\tlock;\n\tlong\t\tnum;\n};\n\nstruct l2cap_conn {\n\tstruct hci_conn\t*hcon;\n\n\tbdaddr_t\t*dst;\n\tbdaddr_t\t*src;\n\n\tunsigned int\tmtu;\n\n\t__u32\t\tfeat_mask;\n\n\t__u8\t\tinfo_state;\n\t__u8\t\tinfo_ident;\n\n\tstruct timer_list info_timer;\n\n\tspinlock_t\tlock;\n\n\tstruct sk_buff *rx_skb;\n\t__u32\t\trx_len;\n\t__u8\t\trx_ident;\n\t__u8\t\ttx_ident;\n\n\t__u8\t\tdisc_reason;\n\n\tstruct l2cap_chan_list chan_list;\n};\n\n#define L2CAP_INFO_CL_MTU_REQ_SENT\t0x01\n#define L2CAP_INFO_FEAT_MASK_REQ_SENT\t0x04\n#define L2CAP_INFO_FEAT_MASK_REQ_DONE\t0x08\n\n/* ----- L2CAP channel and socket info ----- */\n#define l2cap_pi(sk) ((struct l2cap_pinfo *) sk)\n\nstruct l2cap_pinfo {\n\tstruct bt_sock\tbt;\n\t__le16\t\tpsm;\n\t__u16\t\tdcid;\n\t__u16\t\tscid;\n\n\t__u16\t\timtu;\n\t__u16\t\tomtu;\n\t__u16\t\tflush_to;\n\t__u8\t\tmode;\n\t__u8\t\tfcs;\n\t__u8\t\tsec_level;\n\t__u8\t\trole_switch;\n\t__u8\t\tforce_reliable;\n\n\t__u8\t\tconf_req[64];\n\t__u8\t\tconf_len;\n\t__u8\t\tconf_state;\n\t__u8\t\tconf_retry;\n\n\t__u8\t\tident;\n\n\t__le16\t\tsport;\n\n\tstruct l2cap_conn\t*conn;\n\tstruct sock\t\t*next_c;\n\tstruct sock\t\t*prev_c;\n};\n\n#define L2CAP_CONF_REQ_SENT\t0x01\n#define L2CAP_CONF_INPUT_DONE\t0x02\n#define L2CAP_CONF_OUTPUT_DONE\t0x04\n#define L2CAP_CONF_CONNECT_PEND\t0x80\n\n#define L2CAP_CONF_MAX_RETRIES\t2\n\nvoid l2cap_load(void);\n\n#endif /* __L2CAP_H */\n", "/*\n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/* Bluetooth L2CAP core and sockets. */\n\n#include <linux/module.h>\n\n#include <linux/types.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/fcntl.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/socket.h>\n#include <linux/skbuff.h>\n#include <linux/list.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <net/sock.h>\n\n#include <asm/system.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#define VERSION \"2.14\"\n\nstatic int enable_ertm = 0;\n\nstatic u32 l2cap_feat_mask = L2CAP_FEAT_FIXED_CHAN;\nstatic u8 l2cap_fixed_chan[8] = { 0x02, };\n\nstatic const struct proto_ops l2cap_sock_ops;\n\nstatic struct bt_sock_list l2cap_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(l2cap_sk_list.lock)\n};\n\nstatic void __l2cap_sock_close(struct sock *sk, int reason);\nstatic void l2cap_sock_close(struct sock *sk);\nstatic void l2cap_sock_kill(struct sock *sk);\n\nstatic struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,\n\t\t\t\tu8 code, u8 ident, u16 dlen, void *data);\n\n/* ---- L2CAP timers ---- */\nstatic void l2cap_sock_timeout(unsigned long arg)\n{\n\tstruct sock *sk = (struct sock *) arg;\n\tint reason;\n\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\n\tbh_lock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED || sk->sk_state == BT_CONFIG)\n\t\treason = ECONNREFUSED;\n\telse if (sk->sk_state == BT_CONNECT &&\n\t\t\t\tl2cap_pi(sk)->sec_level != BT_SECURITY_SDP)\n\t\treason = ECONNREFUSED;\n\telse\n\t\treason = ETIMEDOUT;\n\n\t__l2cap_sock_close(sk, reason);\n\n\tbh_unlock_sock(sk);\n\n\tl2cap_sock_kill(sk);\n\tsock_put(sk);\n}\n\nstatic void l2cap_sock_set_timer(struct sock *sk, long timeout)\n{\n\tBT_DBG(\"sk %p state %d timeout %ld\", sk, sk->sk_state, timeout);\n\tsk_reset_timer(sk, &sk->sk_timer, jiffies + timeout);\n}\n\nstatic void l2cap_sock_clear_timer(struct sock *sk)\n{\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tsk_stop_timer(sk, &sk->sk_timer);\n}\n\n/* ---- L2CAP channels ---- */\nstatic struct sock *__l2cap_get_chan_by_dcid(struct l2cap_chan_list *l, u16 cid)\n{\n\tstruct sock *s;\n\tfor (s = l->head; s; s = l2cap_pi(s)->next_c) {\n\t\tif (l2cap_pi(s)->dcid == cid)\n\t\t\tbreak;\n\t}\n\treturn s;\n}\n\nstatic struct sock *__l2cap_get_chan_by_scid(struct l2cap_chan_list *l, u16 cid)\n{\n\tstruct sock *s;\n\tfor (s = l->head; s; s = l2cap_pi(s)->next_c) {\n\t\tif (l2cap_pi(s)->scid == cid)\n\t\t\tbreak;\n\t}\n\treturn s;\n}\n\n/* Find channel with given SCID.\n * Returns locked socket */\nstatic inline struct sock *l2cap_get_chan_by_scid(struct l2cap_chan_list *l, u16 cid)\n{\n\tstruct sock *s;\n\tread_lock(&l->lock);\n\ts = __l2cap_get_chan_by_scid(l, cid);\n\tif (s)\n\t\tbh_lock_sock(s);\n\tread_unlock(&l->lock);\n\treturn s;\n}\n\nstatic struct sock *__l2cap_get_chan_by_ident(struct l2cap_chan_list *l, u8 ident)\n{\n\tstruct sock *s;\n\tfor (s = l->head; s; s = l2cap_pi(s)->next_c) {\n\t\tif (l2cap_pi(s)->ident == ident)\n\t\t\tbreak;\n\t}\n\treturn s;\n}\n\nstatic inline struct sock *l2cap_get_chan_by_ident(struct l2cap_chan_list *l, u8 ident)\n{\n\tstruct sock *s;\n\tread_lock(&l->lock);\n\ts = __l2cap_get_chan_by_ident(l, ident);\n\tif (s)\n\t\tbh_lock_sock(s);\n\tread_unlock(&l->lock);\n\treturn s;\n}\n\nstatic u16 l2cap_alloc_cid(struct l2cap_chan_list *l)\n{\n\tu16 cid = L2CAP_CID_DYN_START;\n\n\tfor (; cid < L2CAP_CID_DYN_END; cid++) {\n\t\tif (!__l2cap_get_chan_by_scid(l, cid))\n\t\t\treturn cid;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void __l2cap_chan_link(struct l2cap_chan_list *l, struct sock *sk)\n{\n\tsock_hold(sk);\n\n\tif (l->head)\n\t\tl2cap_pi(l->head)->prev_c = sk;\n\n\tl2cap_pi(sk)->next_c = l->head;\n\tl2cap_pi(sk)->prev_c = NULL;\n\tl->head = sk;\n}\n\nstatic inline void l2cap_chan_unlink(struct l2cap_chan_list *l, struct sock *sk)\n{\n\tstruct sock *next = l2cap_pi(sk)->next_c, *prev = l2cap_pi(sk)->prev_c;\n\n\twrite_lock_bh(&l->lock);\n\tif (sk == l->head)\n\t\tl->head = next;\n\n\tif (next)\n\t\tl2cap_pi(next)->prev_c = prev;\n\tif (prev)\n\t\tl2cap_pi(prev)->next_c = next;\n\twrite_unlock_bh(&l->lock);\n\n\t__sock_put(sk);\n}\n\nstatic void __l2cap_chan_add(struct l2cap_conn *conn, struct sock *sk, struct sock *parent)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\n\tBT_DBG(\"conn %p, psm 0x%2.2x, dcid 0x%4.4x\", conn,\n\t\t\tl2cap_pi(sk)->psm, l2cap_pi(sk)->dcid);\n\n\tconn->disc_reason = 0x13;\n\n\tl2cap_pi(sk)->conn = conn;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\t/* Alloc CID for connection-oriented socket */\n\t\tl2cap_pi(sk)->scid = l2cap_alloc_cid(l);\n\t} else if (sk->sk_type == SOCK_DGRAM) {\n\t\t/* Connectionless socket */\n\t\tl2cap_pi(sk)->scid = L2CAP_CID_CONN_LESS;\n\t\tl2cap_pi(sk)->dcid = L2CAP_CID_CONN_LESS;\n\t\tl2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;\n\t} else {\n\t\t/* Raw socket can send/recv signalling messages only */\n\t\tl2cap_pi(sk)->scid = L2CAP_CID_SIGNALING;\n\t\tl2cap_pi(sk)->dcid = L2CAP_CID_SIGNALING;\n\t\tl2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;\n\t}\n\n\t__l2cap_chan_link(l, sk);\n\n\tif (parent)\n\t\tbt_accept_enqueue(parent, sk);\n}\n\n/* Delete channel.\n * Must be called on the locked socket. */\nstatic void l2cap_chan_del(struct sock *sk, int err)\n{\n\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\tstruct sock *parent = bt_sk(sk)->parent;\n\n\tl2cap_sock_clear_timer(sk);\n\n\tBT_DBG(\"sk %p, conn %p, err %d\", sk, conn, err);\n\n\tif (conn) {\n\t\t/* Unlink from channel list */\n\t\tl2cap_chan_unlink(&conn->chan_list, sk);\n\t\tl2cap_pi(sk)->conn = NULL;\n\t\thci_conn_put(conn->hcon);\n\t}\n\n\tsk->sk_state = BT_CLOSED;\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n\tif (err)\n\t\tsk->sk_err = err;\n\n\tif (parent) {\n\t\tbt_accept_unlink(sk);\n\t\tparent->sk_data_ready(parent, 0);\n\t} else\n\t\tsk->sk_state_change(sk);\n}\n\n/* Service level security */\nstatic inline int l2cap_check_security(struct sock *sk)\n{\n\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\t__u8 auth_type;\n\n\tif (l2cap_pi(sk)->psm == cpu_to_le16(0x0001)) {\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH)\n\t\t\tauth_type = HCI_AT_NO_BONDING_MITM;\n\t\telse\n\t\t\tauth_type = HCI_AT_NO_BONDING;\n\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_LOW)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_SDP;\n\t} else {\n\t\tswitch (l2cap_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\t\tauth_type = HCI_AT_GENERAL_BONDING_MITM;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\tauth_type = HCI_AT_GENERAL_BONDING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tauth_type = HCI_AT_NO_BONDING;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn hci_conn_security(conn->hcon, l2cap_pi(sk)->sec_level,\n\t\t\t\t\t\t\t\tauth_type);\n}\n\nstatic inline u8 l2cap_get_ident(struct l2cap_conn *conn)\n{\n\tu8 id;\n\n\t/* Get next available identificator.\n\t *    1 - 128 are used by kernel.\n\t *  129 - 199 are reserved.\n\t *  200 - 254 are used by utilities like l2ping, etc.\n\t */\n\n\tspin_lock_bh(&conn->lock);\n\n\tif (++conn->tx_ident > 128)\n\t\tconn->tx_ident = 1;\n\n\tid = conn->tx_ident;\n\n\tspin_unlock_bh(&conn->lock);\n\n\treturn id;\n}\n\nstatic inline int l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data)\n{\n\tstruct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);\n\n\tBT_DBG(\"code 0x%2.2x\", code);\n\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treturn hci_send_acl(conn->hcon, skb, 0);\n}\n\nstatic void l2cap_do_start(struct sock *sk)\n{\n\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) {\n\t\tif (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))\n\t\t\treturn;\n\n\t\tif (l2cap_check_security(sk)) {\n\t\t\tstruct l2cap_conn_req req;\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\treq.psm  = l2cap_pi(sk)->psm;\n\n\t\t\tl2cap_pi(sk)->ident = l2cap_get_ident(conn);\n\n\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_REQ, sizeof(req), &req);\n\t\t}\n\t} else {\n\t\tstruct l2cap_info_req req;\n\t\treq.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;\n\t\tconn->info_ident = l2cap_get_ident(conn);\n\n\t\tmod_timer(&conn->info_timer, jiffies +\n\t\t\t\t\tmsecs_to_jiffies(L2CAP_INFO_TIMEOUT));\n\n\t\tl2cap_send_cmd(conn, conn->info_ident,\n\t\t\t\t\tL2CAP_INFO_REQ, sizeof(req), &req);\n\t}\n}\n\n/* ---- L2CAP connections ---- */\nstatic void l2cap_conn_start(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\tstruct sock *sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tbh_lock_sock(sk);\n\n\t\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk->sk_state == BT_CONNECT) {\n\t\t\tif (l2cap_check_security(sk)) {\n\t\t\t\tstruct l2cap_conn_req req;\n\t\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\t\treq.psm  = l2cap_pi(sk)->psm;\n\n\t\t\t\tl2cap_pi(sk)->ident = l2cap_get_ident(conn);\n\n\t\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_REQ, sizeof(req), &req);\n\t\t\t}\n\t\t} else if (sk->sk_state == BT_CONNECT2) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\trsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\trsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);\n\n\t\t\tif (l2cap_check_security(sk)) {\n\t\t\t\tif (bt_sk(sk)->defer_setup) {\n\t\t\t\t\tstruct sock *parent = bt_sk(sk)->parent;\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHOR_PEND);\n\t\t\t\t\tparent->sk_data_ready(parent, 0);\n\n\t\t\t\t} else {\n\t\t\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);\n\t\t\t}\n\n\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_RSP, sizeof(rsp), &rsp);\n\t\t}\n\n\t\tbh_unlock_sock(sk);\n\t}\n\n\tread_unlock(&l->lock);\n}\n\nstatic void l2cap_conn_ready(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\tstruct sock *sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tbh_lock_sock(sk);\n\n\t\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\t\tl2cap_sock_clear_timer(sk);\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\t\tsk->sk_state_change(sk);\n\t\t} else if (sk->sk_state == BT_CONNECT)\n\t\t\tl2cap_do_start(sk);\n\n\t\tbh_unlock_sock(sk);\n\t}\n\n\tread_unlock(&l->lock);\n}\n\n/* Notify sockets that we cannot guaranty reliability anymore */\nstatic void l2cap_conn_unreliable(struct l2cap_conn *conn, int err)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\tstruct sock *sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tif (l2cap_pi(sk)->force_reliable)\n\t\t\tsk->sk_err = err;\n\t}\n\n\tread_unlock(&l->lock);\n}\n\nstatic void l2cap_info_timeout(unsigned long arg)\n{\n\tstruct l2cap_conn *conn = (void *) arg;\n\n\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\tconn->info_ident = 0;\n\n\tl2cap_conn_start(conn);\n}\n\nstatic struct l2cap_conn *l2cap_conn_add(struct hci_conn *hcon, u8 status)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\n\tif (conn || status)\n\t\treturn conn;\n\n\tconn = kzalloc(sizeof(struct l2cap_conn), GFP_ATOMIC);\n\tif (!conn)\n\t\treturn NULL;\n\n\thcon->l2cap_data = conn;\n\tconn->hcon = hcon;\n\n\tBT_DBG(\"hcon %p conn %p\", hcon, conn);\n\n\tconn->mtu = hcon->hdev->acl_mtu;\n\tconn->src = &hcon->hdev->bdaddr;\n\tconn->dst = &hcon->dst;\n\n\tconn->feat_mask = 0;\n\n\tsetup_timer(&conn->info_timer, l2cap_info_timeout,\n\t\t\t\t\t\t(unsigned long) conn);\n\n\tspin_lock_init(&conn->lock);\n\trwlock_init(&conn->chan_list.lock);\n\n\tconn->disc_reason = 0x13;\n\n\treturn conn;\n}\n\nstatic void l2cap_conn_del(struct hci_conn *hcon, int err)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct sock *sk;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p conn %p, err %d\", hcon, conn, err);\n\n\tkfree_skb(conn->rx_skb);\n\n\t/* Kill channels */\n\twhile ((sk = conn->chan_list.head)) {\n\t\tbh_lock_sock(sk);\n\t\tl2cap_chan_del(sk, err);\n\t\tbh_unlock_sock(sk);\n\t\tl2cap_sock_kill(sk);\n\t}\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)\n\t\tdel_timer_sync(&conn->info_timer);\n\n\thcon->l2cap_data = NULL;\n\tkfree(conn);\n}\n\nstatic inline void l2cap_chan_add(struct l2cap_conn *conn, struct sock *sk, struct sock *parent)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\twrite_lock_bh(&l->lock);\n\t__l2cap_chan_add(conn, sk, parent);\n\twrite_unlock_bh(&l->lock);\n}\n\n/* ---- Socket interface ---- */\nstatic struct sock *__l2cap_get_sock_by_addr(__le16 psm, bdaddr_t *src)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\tsk_for_each(sk, node, &l2cap_sk_list.head)\n\t\tif (l2cap_pi(sk)->sport == psm && !bacmp(&bt_sk(sk)->src, src))\n\t\t\tgoto found;\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\n/* Find socket with psm and source bdaddr.\n * Returns closest match.\n */\nstatic struct sock *__l2cap_get_sock_by_psm(int state, __le16 psm, bdaddr_t *src)\n{\n\tstruct sock *sk = NULL, *sk1 = NULL;\n\tstruct hlist_node *node;\n\n\tsk_for_each(sk, node, &l2cap_sk_list.head) {\n\t\tif (state && sk->sk_state != state)\n\t\t\tcontinue;\n\n\t\tif (l2cap_pi(sk)->psm == psm) {\n\t\t\t/* Exact match. */\n\t\t\tif (!bacmp(&bt_sk(sk)->src, src))\n\t\t\t\tbreak;\n\n\t\t\t/* Closest match */\n\t\t\tif (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))\n\t\t\t\tsk1 = sk;\n\t\t}\n\t}\n\treturn node ? sk : sk1;\n}\n\n/* Find socket with given address (psm, src).\n * Returns locked socket */\nstatic inline struct sock *l2cap_get_sock_by_psm(int state, __le16 psm, bdaddr_t *src)\n{\n\tstruct sock *s;\n\tread_lock(&l2cap_sk_list.lock);\n\ts = __l2cap_get_sock_by_psm(state, psm, src);\n\tif (s)\n\t\tbh_lock_sock(s);\n\tread_unlock(&l2cap_sk_list.lock);\n\treturn s;\n}\n\nstatic void l2cap_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic void l2cap_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p\", parent);\n\n\t/* Close not yet accepted channels */\n\twhile ((sk = bt_accept_dequeue(parent, NULL)))\n\t\tl2cap_sock_close(sk);\n\n\tparent->sk_state = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}\n\n/* Kill socket (only if zapped and orphan)\n * Must be called on unlocked socket.\n */\nstatic void l2cap_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %d\", sk, sk->sk_state);\n\n\t/* Kill poor orphan */\n\tbt_sock_unlink(&l2cap_sk_list, sk);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic void __l2cap_sock_close(struct sock *sk, int reason)\n{\n\tBT_DBG(\"sk %p state %d socket %p\", sk, sk->sk_state, sk->sk_socket);\n\n\tswitch (sk->sk_state) {\n\tcase BT_LISTEN:\n\t\tl2cap_sock_cleanup_listen(sk);\n\t\tbreak;\n\n\tcase BT_CONNECTED:\n\tcase BT_CONFIG:\n\t\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\t\t\tstruct l2cap_disconn_req req;\n\n\t\t\tsk->sk_state = BT_DISCONN;\n\t\t\tl2cap_sock_set_timer(sk, sk->sk_sndtimeo);\n\n\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t} else\n\t\t\tl2cap_chan_del(sk, reason);\n\t\tbreak;\n\n\tcase BT_CONNECT2:\n\t\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\t__u16 result;\n\n\t\t\tif (bt_sk(sk)->defer_setup)\n\t\t\t\tresult = L2CAP_CR_SEC_BLOCK;\n\t\t\telse\n\t\t\t\tresult = L2CAP_CR_BAD_PSM;\n\n\t\t\trsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\trsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\trsp.result = cpu_to_le16(result);\n\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_RSP, sizeof(rsp), &rsp);\n\t\t} else\n\t\t\tl2cap_chan_del(sk, reason);\n\t\tbreak;\n\n\tcase BT_CONNECT:\n\tcase BT_DISCONN:\n\t\tl2cap_chan_del(sk, reason);\n\t\tbreak;\n\n\tdefault:\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tbreak;\n\t}\n}\n\n/* Must be called on unlocked socket. */\nstatic void l2cap_sock_close(struct sock *sk)\n{\n\tl2cap_sock_clear_timer(sk);\n\tlock_sock(sk);\n\t__l2cap_sock_close(sk, ECONNRESET);\n\trelease_sock(sk);\n\tl2cap_sock_kill(sk);\n}\n\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tsk->sk_type = parent->sk_type;\n\t\tbt_sk(sk)->defer_setup = bt_sk(parent)->defer_setup;\n\n\t\tpi->imtu = l2cap_pi(parent)->imtu;\n\t\tpi->omtu = l2cap_pi(parent)->omtu;\n\t\tpi->mode = l2cap_pi(parent)->mode;\n\t\tpi->fcs  = l2cap_pi(parent)->fcs;\n\t\tpi->sec_level = l2cap_pi(parent)->sec_level;\n\t\tpi->role_switch = l2cap_pi(parent)->role_switch;\n\t\tpi->force_reliable = l2cap_pi(parent)->force_reliable;\n\t} else {\n\t\tpi->imtu = L2CAP_DEFAULT_MTU;\n\t\tpi->omtu = 0;\n\t\tpi->mode = L2CAP_MODE_BASIC;\n\t\tpi->fcs  = L2CAP_FCS_CRC16;\n\t\tpi->sec_level = BT_SECURITY_LOW;\n\t\tpi->role_switch = 0;\n\t\tpi->force_reliable = 0;\n\t}\n\n\t/* Default config options */\n\tpi->conf_len = 0;\n\tpi->flush_to = L2CAP_DEFAULT_FLUSH_TO;\n}\n\nstatic struct proto l2cap_proto = {\n\t.name\t\t= \"L2CAP\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct l2cap_pinfo)\n};\n\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)\n{\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\tsk->sk_destruct = l2cap_sock_destruct;\n\tsk->sk_sndtimeo = msecs_to_jiffies(L2CAP_CONN_TIMEOUT);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state = BT_OPEN;\n\n\tsetup_timer(&sk->sk_timer, l2cap_sock_timeout, (unsigned long) sk);\n\n\tbt_sock_link(&l2cap_sk_list, sk);\n\treturn sk;\n}\n\nstatic int l2cap_sock_create(struct net *net, struct socket *sock, int protocol)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_SEQPACKET &&\n\t\t\tsock->type != SOCK_DGRAM && sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW && !capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsock->ops = &l2cap_sock_ops;\n\n\tsk = l2cap_sock_alloc(net, sock, protocol, GFP_ATOMIC);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tl2cap_sock_init(sk, NULL);\n\treturn 0;\n}\n\nstatic int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\n\tif (la.l2_cid)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (la.l2_psm && __le16_to_cpu(la.l2_psm) < 0x1001 &&\n\t\t\t\t!capable(CAP_NET_BIND_SERVICE)) {\n\t\terr = -EACCES;\n\t\tgoto done;\n\t}\n\n\twrite_lock_bh(&l2cap_sk_list.lock);\n\n\tif (la.l2_psm && __l2cap_get_sock_by_addr(la.l2_psm, &la.l2_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\t/* Save source address */\n\t\tbacpy(&bt_sk(sk)->src, &la.l2_bdaddr);\n\t\tl2cap_pi(sk)->psm   = la.l2_psm;\n\t\tl2cap_pi(sk)->sport = la.l2_psm;\n\t\tsk->sk_state = BT_BOUND;\n\n\t\tif (__le16_to_cpu(la.l2_psm) == 0x0001 ||\n\t\t\t\t\t__le16_to_cpu(la.l2_psm) == 0x0003)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_SDP;\n\t}\n\n\twrite_unlock_bh(&l2cap_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_do_connect(struct sock *sk)\n{\n\tbdaddr_t *src = &bt_sk(sk)->src;\n\tbdaddr_t *dst = &bt_sk(sk)->dst;\n\tstruct l2cap_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev *hdev;\n\t__u8 auth_type;\n\tint err;\n\n\tBT_DBG(\"%s -> %s psm 0x%2.2x\", batostr(src), batostr(dst),\n\t\t\t\t\t\t\tl2cap_pi(sk)->psm);\n\n\thdev = hci_get_route(dst, src);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\n\thci_dev_lock_bh(hdev);\n\n\terr = -ENOMEM;\n\n\tif (sk->sk_type == SOCK_RAW) {\n\t\tswitch (l2cap_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\t\tauth_type = HCI_AT_DEDICATED_BONDING_MITM;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\tauth_type = HCI_AT_DEDICATED_BONDING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tauth_type = HCI_AT_NO_BONDING;\n\t\t\tbreak;\n\t\t}\n\t} else if (l2cap_pi(sk)->psm == cpu_to_le16(0x0001)) {\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH)\n\t\t\tauth_type = HCI_AT_NO_BONDING_MITM;\n\t\telse\n\t\t\tauth_type = HCI_AT_NO_BONDING;\n\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_LOW)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_SDP;\n\t} else {\n\t\tswitch (l2cap_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\t\tauth_type = HCI_AT_GENERAL_BONDING_MITM;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\tauth_type = HCI_AT_GENERAL_BONDING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tauth_type = HCI_AT_NO_BONDING;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thcon = hci_connect(hdev, ACL_LINK, dst,\n\t\t\t\t\tl2cap_pi(sk)->sec_level, auth_type);\n\tif (!hcon)\n\t\tgoto done;\n\n\tconn = l2cap_conn_add(hcon, 0);\n\tif (!conn) {\n\t\thci_conn_put(hcon);\n\t\tgoto done;\n\t}\n\n\terr = 0;\n\n\t/* Update source addr of the socket */\n\tbacpy(src, conn->src);\n\n\tl2cap_chan_add(conn, sk, NULL);\n\n\tsk->sk_state = BT_CONNECT;\n\tl2cap_sock_set_timer(sk, sk->sk_sndtimeo);\n\n\tif (hcon->state == BT_CONNECTED) {\n\t\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\t\tl2cap_sock_clear_timer(sk);\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\t} else\n\t\t\tl2cap_do_start(sk);\n\t}\n\ndone:\n\thci_dev_unlock_bh(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}\n\nstatic int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\n\tif (la.l2_cid)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_type == SOCK_SEQPACKET && !la.l2_psm) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (l2cap_pi(sk)->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\t\tif (enable_ertm)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\t\t/* Already connecting */\n\t\tgoto wait;\n\n\tcase BT_CONNECTED:\n\t\t/* Already connected */\n\t\tgoto done;\n\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\t\t/* Can connect */\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\t/* Set destination address and psm */\n\tbacpy(&bt_sk(sk)->dst, &la.l2_bdaddr);\n\tl2cap_pi(sk)->psm = la.l2_psm;\n\n\terr = l2cap_do_connect(sk);\n\tif (err)\n\t\tgoto done;\n\nwait:\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND || sock->type != SOCK_SEQPACKET) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tswitch (l2cap_pi(sk)->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\t\tif (enable_ertm)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\n\tif (!l2cap_pi(sk)->psm) {\n\t\tbdaddr_t *src = &bt_sk(sk)->src;\n\t\tu16 psm;\n\n\t\terr = -EINVAL;\n\n\t\twrite_lock_bh(&l2cap_sk_list.lock);\n\n\t\tfor (psm = 0x1001; psm < 0x1100; psm += 2)\n\t\t\tif (!__l2cap_get_sock_by_addr(cpu_to_le16(psm), src)) {\n\t\t\t\tl2cap_pi(sk)->psm   = cpu_to_le16(psm);\n\t\t\t\tl2cap_pi(sk)->sport = cpu_to_le16(psm);\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\twrite_unlock_bh(&l2cap_sk_list.lock);\n\n\t\tif (err < 0)\n\t\t\tgoto done;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\tsk->sk_state = BT_LISTEN;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sock *sk = sock->sk, *nsk;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\tif (sk->sk_state != BT_LISTEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t/* Wait for an incoming connection. (wake-one). */\n\tadd_wait_queue_exclusive(sk->sk_sleep, &wait);\n\twhile (!(nsk = bt_accept_dequeue(sk, newsock))) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk->sk_sleep, &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", nsk);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\taddr->sa_family = AF_BLUETOOTH;\n\t*len = sizeof(struct sockaddr_l2);\n\n\tif (peer) {\n\t\tla->l2_psm = l2cap_pi(sk)->psm;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);\n\t\tla->l2_cid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t} else {\n\t\tla->l2_psm = l2cap_pi(sk)->sport;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->src);\n\t\tla->l2_cid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_do_send(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\tstruct sk_buff *skb, **frag;\n\tint err, hlen, count, sent = 0;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\n\t/* First fragment (with L2CAP header) */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\thlen = L2CAP_HDR_SIZE + 2;\n\telse\n\t\thlen = L2CAP_HDR_SIZE;\n\n\tcount = min_t(unsigned int, (conn->mtu - hlen), len);\n\n\tskb = bt_skb_send_alloc(sk, hlen + count,\n\t\t\tmsg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\t/* Create L2CAP header */\n\tlh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\tlh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));\n\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tput_unaligned(l2cap_pi(sk)->psm, (__le16 *) skb_put(skb, 2));\n\n\tif (memcpy_fromiovec(skb_put(skb, count), msg->msg_iov, count)) {\n\t\terr = -EFAULT;\n\t\tgoto fail;\n\t}\n\n\tsent += count;\n\tlen  -= count;\n\n\t/* Continuation fragments (no L2CAP header) */\n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tcount = min_t(unsigned int, conn->mtu, len);\n\n\t\t*frag = bt_skb_send_alloc(sk, count, msg->msg_flags & MSG_DONTWAIT, &err);\n\t\tif (!*frag)\n\t\t\tgoto fail;\n\n\t\tif (memcpy_fromiovec(skb_put(*frag, count), msg->msg_iov, count)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tsent += count;\n\t\tlen  -= count;\n\n\t\tfrag = &(*frag)->next;\n\t}\n\terr = hci_send_acl(conn->hcon, skb, 0);\n\tif (err < 0)\n\t\tgoto fail;\n\n\treturn sent;\n\nfail:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Check outgoing MTU */\n\tif (sk->sk_type != SOCK_RAW && len > l2cap_pi(sk)->omtu)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = l2cap_do_send(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 && bt_sk(sk)->defer_setup) {\n\t\tstruct l2cap_conn_rsp rsp;\n\n\t\tsk->sk_state = BT_CONFIG;\n\n\t\trsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\trsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\tl2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_RSP, sizeof(rsp), &rsp);\n\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}\n\nstatic int l2cap_sock_setsockopt_old(struct socket *sock, int optname, char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_options opts;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase L2CAP_OPTIONS:\n\t\topts.imtu     = l2cap_pi(sk)->imtu;\n\t\topts.omtu     = l2cap_pi(sk)->omtu;\n\t\topts.flush_to = l2cap_pi(sk)->flush_to;\n\t\topts.mode     = l2cap_pi(sk)->mode;\n\n\t\tlen = min_t(unsigned int, sizeof(opts), optlen);\n\t\tif (copy_from_user((char *) &opts, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tl2cap_pi(sk)->imtu = opts.imtu;\n\t\tl2cap_pi(sk)->omtu = opts.omtu;\n\t\tl2cap_pi(sk)->mode = opts.mode;\n\t\tbreak;\n\n\tcase L2CAP_LM:\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & L2CAP_LM_AUTH)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & L2CAP_LM_ENCRYPT)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & L2CAP_LM_SECURE)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_HIGH;\n\n\t\tl2cap_pi(sk)->role_switch    = (opt & L2CAP_LM_MASTER);\n\t\tl2cap_pi(sk)->force_reliable = (opt & L2CAP_LM_RELIABLE);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_L2CAP)\n\t\treturn l2cap_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned int, sizeof(sec), optlen);\n\t\tif (copy_from_user((char *) &sec, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level < BT_SECURITY_LOW ||\n\t\t\t\t\tsec.level > BT_SECURITY_HIGH) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tl2cap_pi(sk)->sec_level = sec.level;\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbt_sk(sk)->defer_setup = opt;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_options opts;\n\tstruct l2cap_conninfo cinfo;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase L2CAP_OPTIONS:\n\t\topts.imtu     = l2cap_pi(sk)->imtu;\n\t\topts.omtu     = l2cap_pi(sk)->omtu;\n\t\topts.flush_to = l2cap_pi(sk)->flush_to;\n\t\topts.mode     = l2cap_pi(sk)->mode;\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *) &opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase L2CAP_LM:\n\t\tswitch (l2cap_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_LOW:\n\t\t\topt = L2CAP_LM_AUTH;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_HIGH:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT |\n\t\t\t\t\t\t\tL2CAP_LM_SECURE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\topt = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l2cap_pi(sk)->role_switch)\n\t\t\topt |= L2CAP_LM_MASTER;\n\n\t\tif (l2cap_pi(sk)->force_reliable)\n\t\t\topt |= L2CAP_LM_RELIABLE;\n\n\t\tif (put_user(opt, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase L2CAP_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t\t\t\t!(sk->sk_state == BT_CONNECT2 &&\n\t\t\t\t\t\tbt_sk(sk)->defer_setup)) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tcinfo.hci_handle = l2cap_pi(sk)->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, l2cap_pi(sk)->conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *) &cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_L2CAP)\n\t\treturn l2cap_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = l2cap_pi(sk)->sec_level;\n\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(bt_sk(sk)->defer_setup, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\tif (!sk->sk_shutdown) {\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\tl2cap_sock_clear_timer(sk);\n\t\t__l2cap_sock_close(sk, 0);\n\n\t\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)\n\t\t\terr = bt_sock_wait_state(sk, BT_CLOSED,\n\t\t\t\t\t\t\tsk->sk_lingertime);\n\t}\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\terr = l2cap_sock_shutdown(sock, 2);\n\n\tsock_orphan(sk);\n\tl2cap_sock_kill(sk);\n\treturn err;\n}\n\nstatic void l2cap_chan_ready(struct sock *sk)\n{\n\tstruct sock *parent = bt_sk(sk)->parent;\n\n\tBT_DBG(\"sk %p, parent %p\", sk, parent);\n\n\tl2cap_pi(sk)->conf_state = 0;\n\tl2cap_sock_clear_timer(sk);\n\n\tif (!parent) {\n\t\t/* Outgoing channel.\n\t\t * Wake up socket sleeping on connect.\n\t\t */\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tsk->sk_state_change(sk);\n\t} else {\n\t\t/* Incoming channel.\n\t\t * Wake up socket sleeping on accept.\n\t\t */\n\t\tparent->sk_data_ready(parent, 0);\n\t}\n}\n\n/* Copy frame to all raw sockets on that connection */\nstatic void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\tstruct sk_buff *nskb;\n\tstruct sock *sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tif (sk->sk_type != SOCK_RAW)\n\t\t\tcontinue;\n\n\t\t/* Don't send frame to the socket it came from */\n\t\tif (skb->sk == sk)\n\t\t\tcontinue;\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\tread_unlock(&l->lock);\n}\n\n/* ---- L2CAP signalling commands ---- */\nstatic struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,\n\t\t\t\tu8 code, u8 ident, u16 dlen, void *data)\n{\n\tstruct sk_buff *skb, **frag;\n\tstruct l2cap_cmd_hdr *cmd;\n\tstruct l2cap_hdr *lh;\n\tint len, count;\n\n\tBT_DBG(\"conn %p, code 0x%2.2x, ident 0x%2.2x, len %d\",\n\t\t\tconn, code, ident, dlen);\n\n\tlen = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;\n\tcount = min_t(unsigned int, conn->mtu, len);\n\n\tskb = bt_skb_alloc(count, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\n\tlh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);\n\tlh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);\n\n\tcmd = (struct l2cap_cmd_hdr *) skb_put(skb, L2CAP_CMD_HDR_SIZE);\n\tcmd->code  = code;\n\tcmd->ident = ident;\n\tcmd->len   = cpu_to_le16(dlen);\n\n\tif (dlen) {\n\t\tcount -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;\n\t\tmemcpy(skb_put(skb, count), data, count);\n\t\tdata += count;\n\t}\n\n\tlen -= skb->len;\n\n\t/* Continuation fragments (no L2CAP header) */\n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tcount = min_t(unsigned int, conn->mtu, len);\n\n\t\t*frag = bt_skb_alloc(count, GFP_ATOMIC);\n\t\tif (!*frag)\n\t\t\tgoto fail;\n\n\t\tmemcpy(skb_put(*frag, count), data, count);\n\n\t\tlen  -= count;\n\t\tdata += count;\n\n\t\tfrag = &(*frag)->next;\n\t}\n\n\treturn skb;\n\nfail:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstatic inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen, unsigned long *val)\n{\n\tstruct l2cap_conf_opt *opt = *ptr;\n\tint len;\n\n\tlen = L2CAP_CONF_OPT_SIZE + opt->len;\n\t*ptr += len;\n\n\t*type = opt->type;\n\t*olen = opt->len;\n\n\tswitch (opt->len) {\n\tcase 1:\n\t\t*val = *((u8 *) opt->val);\n\t\tbreak;\n\n\tcase 2:\n\t\t*val = __le16_to_cpu(*((__le16 *) opt->val));\n\t\tbreak;\n\n\tcase 4:\n\t\t*val = __le32_to_cpu(*((__le32 *) opt->val));\n\t\tbreak;\n\n\tdefault:\n\t\t*val = (unsigned long) opt->val;\n\t\tbreak;\n\t}\n\n\tBT_DBG(\"type 0x%2.2x len %d val 0x%lx\", *type, opt->len, *val);\n\treturn len;\n}\n\nstatic void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)\n{\n\tstruct l2cap_conf_opt *opt = *ptr;\n\n\tBT_DBG(\"type 0x%2.2x len %d val 0x%lx\", type, len, val);\n\n\topt->type = type;\n\topt->len  = len;\n\n\tswitch (len) {\n\tcase 1:\n\t\t*((u8 *) opt->val)  = val;\n\t\tbreak;\n\n\tcase 2:\n\t\t*((__le16 *) opt->val) = cpu_to_le16(val);\n\t\tbreak;\n\n\tcase 4:\n\t\t*((__le32 *) opt->val) = cpu_to_le32(val);\n\t\tbreak;\n\n\tdefault:\n\t\tmemcpy(opt->val, (void *) val, len);\n\t\tbreak;\n\t}\n\n\t*ptr += L2CAP_CONF_OPT_SIZE + len;\n}\n\nstatic int l2cap_build_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_req *req = data;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tvoid *ptr = req->data;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tif (pi->imtu != L2CAP_DEFAULT_MTU)\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\t\trfc.mode            = L2CAP_MODE_ERTM;\n\t\trfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;\n\t\trfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;\n\t\trfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);\n\t\trfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);\n\t\trfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\tbreak;\n\t}\n\n\t/* FIXME: Need actual value of the flush timeout */\n\t//if (flush_to != L2CAP_DEFAULT_FLUSH_TO)\n\t//   l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2, pi->flush_to);\n\n\treq->dcid  = cpu_to_le16(pi->dcid);\n\treq->flags = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_parse_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *req = pi->conf_req;\n\tint len = pi->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tpi->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen == sizeof(rfc))\n\t\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (rfc.mode == L2CAP_MODE_BASIC) {\n\t\t\tif (mtu < pi->omtu)\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\t\telse {\n\t\t\t\tpi->omtu = mtu;\n\t\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n\t\t\t}\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n\t\t} else {\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = L2CAP_MODE_BASIC;\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\t}\n\t}\n\n\trsp->scid   = cpu_to_le16(pi->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0x0000);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_build_conf_rsp(struct sock *sk, void *data, u16 result, u16 flags)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\trsp->scid   = cpu_to_le16(l2cap_pi(sk)->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(flags);\n\n\treturn ptr - data;\n}\n\nstatic inline int l2cap_command_rej(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_cmd_rej *rej = (struct l2cap_cmd_rej *) data;\n\n\tif (rej->reason != 0x0000)\n\t\treturn 0;\n\n\tif ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&\n\t\t\t\t\tcmd->ident == conn->info_ident) {\n\t\tdel_timer(&conn->info_timer);\n\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_connect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_chan_list *list = &conn->chan_list;\n\tstruct l2cap_conn_req *req = (struct l2cap_conn_req *) data;\n\tstruct l2cap_conn_rsp rsp;\n\tstruct sock *sk, *parent;\n\tint result, status = L2CAP_CS_NO_INFO;\n\n\tu16 dcid = 0, scid = __le16_to_cpu(req->scid);\n\t__le16 psm = req->psm;\n\n\tBT_DBG(\"psm 0x%2.2x scid 0x%4.4x\", psm, scid);\n\n\t/* Check if we have socket listening on psm */\n\tparent = l2cap_get_sock_by_psm(BT_LISTEN, psm, conn->src);\n\tif (!parent) {\n\t\tresult = L2CAP_CR_BAD_PSM;\n\t\tgoto sendresp;\n\t}\n\n\t/* Check if the ACL is secure enough (if not SDP) */\n\tif (psm != cpu_to_le16(0x0001) &&\n\t\t\t\t!hci_conn_check_link_mode(conn->hcon)) {\n\t\tconn->disc_reason = 0x05;\n\t\tresult = L2CAP_CR_SEC_BLOCK;\n\t\tgoto response;\n\t}\n\n\tresult = L2CAP_CR_NO_MEM;\n\n\t/* Check for backlog size */\n\tif (sk_acceptq_is_full(parent)) {\n\t\tBT_DBG(\"backlog full %d\", parent->sk_ack_backlog);\n\t\tgoto response;\n\t}\n\n\tsk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP, GFP_ATOMIC);\n\tif (!sk)\n\t\tgoto response;\n\n\twrite_lock_bh(&list->lock);\n\n\t/* Check if we already have channel with that dcid */\n\tif (__l2cap_get_chan_by_dcid(list, scid)) {\n\t\twrite_unlock_bh(&list->lock);\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tl2cap_sock_kill(sk);\n\t\tgoto response;\n\t}\n\n\thci_conn_hold(conn->hcon);\n\n\tl2cap_sock_init(sk, parent);\n\tbacpy(&bt_sk(sk)->src, conn->src);\n\tbacpy(&bt_sk(sk)->dst, conn->dst);\n\tl2cap_pi(sk)->psm  = psm;\n\tl2cap_pi(sk)->dcid = scid;\n\n\t__l2cap_chan_add(conn, sk, parent);\n\tdcid = l2cap_pi(sk)->scid;\n\n\tl2cap_sock_set_timer(sk, sk->sk_sndtimeo);\n\n\tl2cap_pi(sk)->ident = cmd->ident;\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {\n\t\tif (l2cap_check_security(sk)) {\n\t\t\tif (bt_sk(sk)->defer_setup) {\n\t\t\t\tsk->sk_state = BT_CONNECT2;\n\t\t\t\tresult = L2CAP_CR_PEND;\n\t\t\t\tstatus = L2CAP_CS_AUTHOR_PEND;\n\t\t\t\tparent->sk_data_ready(parent, 0);\n\t\t\t} else {\n\t\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\t\tresult = L2CAP_CR_SUCCESS;\n\t\t\t\tstatus = L2CAP_CS_NO_INFO;\n\t\t\t}\n\t\t} else {\n\t\t\tsk->sk_state = BT_CONNECT2;\n\t\t\tresult = L2CAP_CR_PEND;\n\t\t\tstatus = L2CAP_CS_AUTHEN_PEND;\n\t\t}\n\t} else {\n\t\tsk->sk_state = BT_CONNECT2;\n\t\tresult = L2CAP_CR_PEND;\n\t\tstatus = L2CAP_CS_NO_INFO;\n\t}\n\n\twrite_unlock_bh(&list->lock);\n\nresponse:\n\tbh_unlock_sock(parent);\n\nsendresp:\n\trsp.scid   = cpu_to_le16(scid);\n\trsp.dcid   = cpu_to_le16(dcid);\n\trsp.result = cpu_to_le16(result);\n\trsp.status = cpu_to_le16(status);\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp);\n\n\tif (result == L2CAP_CR_PEND && status == L2CAP_CS_NO_INFO) {\n\t\tstruct l2cap_info_req info;\n\t\tinfo.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;\n\t\tconn->info_ident = l2cap_get_ident(conn);\n\n\t\tmod_timer(&conn->info_timer, jiffies +\n\t\t\t\t\tmsecs_to_jiffies(L2CAP_INFO_TIMEOUT));\n\n\t\tl2cap_send_cmd(conn, conn->info_ident,\n\t\t\t\t\tL2CAP_INFO_REQ, sizeof(info), &info);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;\n\tu16 scid, dcid, result, status;\n\tstruct sock *sk;\n\tu8 req[128];\n\n\tscid   = __le16_to_cpu(rsp->scid);\n\tdcid   = __le16_to_cpu(rsp->dcid);\n\tresult = __le16_to_cpu(rsp->result);\n\tstatus = __le16_to_cpu(rsp->status);\n\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x\", dcid, scid, result, status);\n\n\tif (scid) {\n\t\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\t\tif (!sk)\n\t\t\treturn 0;\n\t} else {\n\t\tsk = l2cap_get_chan_by_ident(&conn->chan_list, cmd->ident);\n\t\tif (!sk)\n\t\t\treturn 0;\n\t}\n\n\tswitch (result) {\n\tcase L2CAP_CR_SUCCESS:\n\t\tsk->sk_state = BT_CONFIG;\n\t\tl2cap_pi(sk)->ident = 0;\n\t\tl2cap_pi(sk)->dcid = dcid;\n\t\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;\n\n\t\tl2cap_pi(sk)->conf_state &= ~L2CAP_CONF_CONNECT_PEND;\n\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\tbreak;\n\n\tcase L2CAP_CR_PEND:\n\t\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_chan_del(sk, ECONNREFUSED);\n\t\tbreak;\n\t}\n\n\tbh_unlock_sock(sk);\n\treturn 0;\n}\n\nstatic inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct sock *sk;\n\tint len;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);\n\tif (!sk)\n\t\treturn -ENOENT;\n\n\tif (sk->sk_state == BT_DISCONN)\n\t\tgoto unlock;\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (l2cap_pi(sk)->conf_len + len > sizeof(l2cap_pi(sk)->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t\tl2cap_build_conf_rsp(sk, rsp,\n\t\t\t\t\tL2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(l2cap_pi(sk)->conf_req + l2cap_pi(sk)->conf_len, req->data, len);\n\tl2cap_pi(sk)->conf_len += len;\n\n\tif (flags & 0x0001) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t\tl2cap_build_conf_rsp(sk, rsp,\n\t\t\t\t\tL2CAP_CONF_SUCCESS, 0x0001), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Complete config. */\n\tlen = l2cap_parse_conf_req(sk, rsp);\n\tif (len < 0)\n\t\tgoto unlock;\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n\n\t/* Reset config buffer. */\n\tl2cap_pi(sk)->conf_len = 0;\n\n\tif (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE))\n\t\tgoto unlock;\n\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t\tgoto unlock;\n\t}\n\n\tif (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT)) {\n\t\tu8 buf[64];\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\tl2cap_build_conf_req(sk, buf), buf);\n\t}\n\nunlock:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}\n\nstatic inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\n\tu16 scid, flags, result;\n\tstruct sock *sk;\n\n\tscid   = __le16_to_cpu(rsp->scid);\n\tflags  = __le16_to_cpu(rsp->flags);\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x\",\n\t\t\tscid, flags, result);\n\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\tif (!sk)\n\t\treturn 0;\n\n\tswitch (result) {\n\tcase L2CAP_CONF_SUCCESS:\n\t\tbreak;\n\n\tcase L2CAP_CONF_UNACCEPT:\n\t\tif (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {\n\t\t\tchar req[128];\n\t\t\t/* It does not make sense to adjust L2CAP parameters\n\t\t\t * that are currently defined in the spec. We simply\n\t\t\t * resend config request that we sent earlier. It is\n\t\t\t * stupid, but it helps qualification testing which\n\t\t\t * expects at least some response from us. */\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\t\tgoto done;\n\t\t}\n\n\tdefault:\n\t\tsk->sk_state = BT_DISCONN;\n\t\tsk->sk_err = ECONNRESET;\n\t\tl2cap_sock_set_timer(sk, HZ * 5);\n\t\t{\n\t\t\tstruct l2cap_disconn_req req;\n\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tif (flags & 0x01)\n\t\tgoto done;\n\n\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_INPUT_DONE;\n\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t}\n\ndone:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}\n\nstatic inline int l2cap_disconnect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;\n\tstruct l2cap_disconn_rsp rsp;\n\tu16 dcid, scid;\n\tstruct sock *sk;\n\n\tscid = __le16_to_cpu(req->scid);\n\tdcid = __le16_to_cpu(req->dcid);\n\n\tBT_DBG(\"scid 0x%4.4x dcid 0x%4.4x\", scid, dcid);\n\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);\n\tif (!sk)\n\t\treturn 0;\n\n\trsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);\n\trsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);\n\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\n\tl2cap_chan_del(sk, ECONNRESET);\n\tbh_unlock_sock(sk);\n\n\tl2cap_sock_kill(sk);\n\treturn 0;\n}\n\nstatic inline int l2cap_disconnect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;\n\tu16 dcid, scid;\n\tstruct sock *sk;\n\n\tscid = __le16_to_cpu(rsp->scid);\n\tdcid = __le16_to_cpu(rsp->dcid);\n\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x\", dcid, scid);\n\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\tif (!sk)\n\t\treturn 0;\n\n\tl2cap_chan_del(sk, 0);\n\tbh_unlock_sock(sk);\n\n\tl2cap_sock_kill(sk);\n\treturn 0;\n}\n\nstatic inline int l2cap_information_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_info_req *req = (struct l2cap_info_req *) data;\n\tu16 type;\n\n\ttype = __le16_to_cpu(req->type);\n\n\tBT_DBG(\"type 0x%4.4x\", type);\n\n\tif (type == L2CAP_IT_FEAT_MASK) {\n\t\tu8 buf[8];\n\t\tu32 feat_mask = l2cap_feat_mask;\n\t\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;\n\t\trsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\t\trsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);\n\t\tif (enable_ertm)\n\t\t\tfeat_mask |= L2CAP_FEAT_ERTM;\n\t\tput_unaligned(cpu_to_le32(feat_mask), (__le32 *) rsp->data);\n\t\tl2cap_send_cmd(conn, cmd->ident,\n\t\t\t\t\tL2CAP_INFO_RSP, sizeof(buf), buf);\n\t} else if (type == L2CAP_IT_FIXED_CHAN) {\n\t\tu8 buf[12];\n\t\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;\n\t\trsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);\n\t\trsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);\n\t\tmemcpy(buf + 4, l2cap_fixed_chan, 8);\n\t\tl2cap_send_cmd(conn, cmd->ident,\n\t\t\t\t\tL2CAP_INFO_RSP, sizeof(buf), buf);\n\t} else {\n\t\tstruct l2cap_info_rsp rsp;\n\t\trsp.type   = cpu_to_le16(type);\n\t\trsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);\n\t\tl2cap_send_cmd(conn, cmd->ident,\n\t\t\t\t\tL2CAP_INFO_RSP, sizeof(rsp), &rsp);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_information_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;\n\tu16 type, result;\n\n\ttype   = __le16_to_cpu(rsp->type);\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"type 0x%4.4x result 0x%2.2x\", type, result);\n\n\tdel_timer(&conn->info_timer);\n\n\tif (type == L2CAP_IT_FEAT_MASK) {\n\t\tconn->feat_mask = get_unaligned_le32(rsp->data);\n\n\t\tif (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {\n\t\t\tstruct l2cap_info_req req;\n\t\t\treq.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);\n\n\t\t\tconn->info_ident = l2cap_get_ident(conn);\n\n\t\t\tl2cap_send_cmd(conn, conn->info_ident,\n\t\t\t\t\tL2CAP_INFO_REQ, sizeof(req), &req);\n\t\t} else {\n\t\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\t\tconn->info_ident = 0;\n\n\t\t\tl2cap_conn_start(conn);\n\t\t}\n\t} else if (type == L2CAP_IT_FIXED_CHAN) {\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\t}\n\n\treturn 0;\n}\n\nstatic inline void l2cap_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tu8 *data = skb->data;\n\tint len = skb->len;\n\tstruct l2cap_cmd_hdr cmd;\n\tint err = 0;\n\n\tl2cap_raw_recv(conn, skb);\n\n\twhile (len >= L2CAP_CMD_HDR_SIZE) {\n\t\tu16 cmd_len;\n\t\tmemcpy(&cmd, data, L2CAP_CMD_HDR_SIZE);\n\t\tdata += L2CAP_CMD_HDR_SIZE;\n\t\tlen  -= L2CAP_CMD_HDR_SIZE;\n\n\t\tcmd_len = le16_to_cpu(cmd.len);\n\n\t\tBT_DBG(\"code 0x%2.2x len %d id 0x%2.2x\", cmd.code, cmd_len, cmd.ident);\n\n\t\tif (cmd_len > len || !cmd.ident) {\n\t\t\tBT_DBG(\"corrupted command\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (cmd.code) {\n\t\tcase L2CAP_COMMAND_REJ:\n\t\t\tl2cap_command_rej(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONN_REQ:\n\t\t\terr = l2cap_connect_req(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONN_RSP:\n\t\t\terr = l2cap_connect_rsp(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_REQ:\n\t\t\terr = l2cap_config_req(conn, &cmd, cmd_len, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RSP:\n\t\t\terr = l2cap_config_rsp(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_DISCONN_REQ:\n\t\t\terr = l2cap_disconnect_req(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_DISCONN_RSP:\n\t\t\terr = l2cap_disconnect_rsp(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_ECHO_REQ:\n\t\t\tl2cap_send_cmd(conn, cmd.ident, L2CAP_ECHO_RSP, cmd_len, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_ECHO_RSP:\n\t\t\tbreak;\n\n\t\tcase L2CAP_INFO_REQ:\n\t\t\terr = l2cap_information_req(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_INFO_RSP:\n\t\t\terr = l2cap_information_rsp(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBT_ERR(\"Unknown signaling command 0x%2.2x\", cmd.code);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err) {\n\t\t\tstruct l2cap_cmd_rej rej;\n\t\t\tBT_DBG(\"error %d\", err);\n\n\t\t\t/* FIXME: Map err to a valid reason */\n\t\t\trej.reason = cpu_to_le16(0);\n\t\t\tl2cap_send_cmd(conn, cmd.ident, L2CAP_COMMAND_REJ, sizeof(rej), &rej);\n\t\t}\n\n\t\tdata += cmd_len;\n\t\tlen  -= cmd_len;\n\t}\n\n\tkfree_skb(skb);\n}\n\nstatic inline int l2cap_data_channel(struct l2cap_conn *conn, u16 cid, struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, cid);\n\tif (!sk) {\n\t\tBT_DBG(\"unknown cid 0x%4.4x\", cid);\n\t\tgoto drop;\n\t}\n\n\tBT_DBG(\"sk %p, len %d\", sk, skb->len);\n\n\tif (sk->sk_state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tif (l2cap_pi(sk)->imtu < skb->len)\n\t\tgoto drop;\n\n\t/* If socket recv buffers overflows we drop data here\n\t * which is *bad* because L2CAP has to be reliable.\n\t * But we don't have any other choice. L2CAP doesn't\n\t * provide flow control mechanism. */\n\n\tif (!sock_queue_rcv_skb(sk, skb))\n\t\tgoto done;\n\ndrop:\n\tkfree_skb(skb);\n\ndone:\n\tif (sk)\n\t\tbh_unlock_sock(sk);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_conless_channel(struct l2cap_conn *conn, __le16 psm, struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\n\tsk = l2cap_get_sock_by_psm(0, psm, conn->src);\n\tif (!sk)\n\t\tgoto drop;\n\n\tBT_DBG(\"sk %p, len %d\", sk, skb->len);\n\n\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tif (l2cap_pi(sk)->imtu < skb->len)\n\t\tgoto drop;\n\n\tif (!sock_queue_rcv_skb(sk, skb))\n\t\tgoto done;\n\ndrop:\n\tkfree_skb(skb);\n\ndone:\n\tif (sk)\n\t\tbh_unlock_sock(sk);\n\treturn 0;\n}\n\nstatic void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct l2cap_hdr *lh = (void *) skb->data;\n\tu16 cid, len;\n\t__le16 psm;\n\n\tskb_pull(skb, L2CAP_HDR_SIZE);\n\tcid = __le16_to_cpu(lh->cid);\n\tlen = __le16_to_cpu(lh->len);\n\n\tBT_DBG(\"len %d, cid 0x%4.4x\", len, cid);\n\n\tswitch (cid) {\n\tcase L2CAP_CID_SIGNALING:\n\t\tl2cap_sig_channel(conn, skb);\n\t\tbreak;\n\n\tcase L2CAP_CID_CONN_LESS:\n\t\tpsm = get_unaligned((__le16 *) skb->data);\n\t\tskb_pull(skb, 2);\n\t\tl2cap_conless_channel(conn, psm, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_data_channel(conn, cid, skb);\n\t\tbreak;\n\t}\n}\n\n/* ---- L2CAP interface with lower layer (HCI) ---- */\n\nstatic int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)\n{\n\tint exact = 0, lm1 = 0, lm2 = 0;\n\tregister struct sock *sk;\n\tstruct hlist_node *node;\n\n\tif (type != ACL_LINK)\n\t\treturn 0;\n\n\tBT_DBG(\"hdev %s, bdaddr %s\", hdev->name, batostr(bdaddr));\n\n\t/* Find listening sockets and check their link_mode */\n\tread_lock(&l2cap_sk_list.lock);\n\tsk_for_each(sk, node, &l2cap_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr)) {\n\t\t\tlm1 |= HCI_LM_ACCEPT;\n\t\t\tif (l2cap_pi(sk)->role_switch)\n\t\t\t\tlm1 |= HCI_LM_MASTER;\n\t\t\texact++;\n\t\t} else if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {\n\t\t\tlm2 |= HCI_LM_ACCEPT;\n\t\t\tif (l2cap_pi(sk)->role_switch)\n\t\t\t\tlm2 |= HCI_LM_MASTER;\n\t\t}\n\t}\n\tread_unlock(&l2cap_sk_list.lock);\n\n\treturn exact ? lm1 : lm2;\n}\n\nstatic int l2cap_connect_cfm(struct hci_conn *hcon, u8 status)\n{\n\tstruct l2cap_conn *conn;\n\n\tBT_DBG(\"hcon %p bdaddr %s status %d\", hcon, batostr(&hcon->dst), status);\n\n\tif (hcon->type != ACL_LINK)\n\t\treturn 0;\n\n\tif (!status) {\n\t\tconn = l2cap_conn_add(hcon, status);\n\t\tif (conn)\n\t\t\tl2cap_conn_ready(conn);\n\t} else\n\t\tl2cap_conn_del(hcon, bt_err(status));\n\n\treturn 0;\n}\n\nstatic int l2cap_disconn_ind(struct hci_conn *hcon)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\n\tBT_DBG(\"hcon %p\", hcon);\n\n\tif (hcon->type != ACL_LINK || !conn)\n\t\treturn 0x13;\n\n\treturn conn->disc_reason;\n}\n\nstatic int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason)\n{\n\tBT_DBG(\"hcon %p reason %d\", hcon, reason);\n\n\tif (hcon->type != ACL_LINK)\n\t\treturn 0;\n\n\tl2cap_conn_del(hcon, bt_err(reason));\n\n\treturn 0;\n}\n\nstatic inline void l2cap_check_encryption(struct sock *sk, u8 encrypt)\n{\n\tif (sk->sk_type != SOCK_SEQPACKET)\n\t\treturn;\n\n\tif (encrypt == 0x00) {\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM) {\n\t\t\tl2cap_sock_clear_timer(sk);\n\t\t\tl2cap_sock_set_timer(sk, HZ * 5);\n\t\t} else if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH)\n\t\t\t__l2cap_sock_close(sk, ECONNREFUSED);\n\t} else {\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM)\n\t\t\tl2cap_sock_clear_timer(sk);\n\t}\n}\n\nstatic int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)\n{\n\tstruct l2cap_chan_list *l;\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct sock *sk;\n\n\tif (!conn)\n\t\treturn 0;\n\n\tl = &conn->chan_list;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tbh_lock_sock(sk);\n\n\t\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_CONNECT_PEND) {\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && (sk->sk_state == BT_CONNECTED ||\n\t\t\t\t\t\tsk->sk_state == BT_CONFIG)) {\n\t\t\tl2cap_check_encryption(sk, encrypt);\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk->sk_state == BT_CONNECT) {\n\t\t\tif (!status) {\n\t\t\t\tstruct l2cap_conn_req req;\n\t\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\t\treq.psm  = l2cap_pi(sk)->psm;\n\n\t\t\t\tl2cap_pi(sk)->ident = l2cap_get_ident(conn);\n\n\t\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_REQ, sizeof(req), &req);\n\t\t\t} else {\n\t\t\t\tl2cap_sock_clear_timer(sk);\n\t\t\t\tl2cap_sock_set_timer(sk, HZ / 10);\n\t\t\t}\n\t\t} else if (sk->sk_state == BT_CONNECT2) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\t__u16 result;\n\n\t\t\tif (!status) {\n\t\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\t\tresult = L2CAP_CR_SUCCESS;\n\t\t\t} else {\n\t\t\t\tsk->sk_state = BT_DISCONN;\n\t\t\t\tl2cap_sock_set_timer(sk, HZ / 10);\n\t\t\t\tresult = L2CAP_CR_SEC_BLOCK;\n\t\t\t}\n\n\t\t\trsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\trsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\trsp.result = cpu_to_le16(result);\n\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_RSP, sizeof(rsp), &rsp);\n\t\t}\n\n\t\tbh_unlock_sock(sk);\n\t}\n\n\tread_unlock(&l->lock);\n\n\treturn 0;\n}\n\nstatic int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\n\tif (!conn && !(conn = l2cap_conn_add(hcon, 0)))\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %d flags 0x%x\", conn, skb->len, flags);\n\n\tif (flags & ACL_START) {\n\t\tstruct l2cap_hdr *hdr;\n\t\tint len;\n\n\t\tif (conn->rx_len) {\n\t\t\tBT_ERR(\"Unexpected start frame (len %d)\", skb->len);\n\t\t\tkfree_skb(conn->rx_skb);\n\t\t\tconn->rx_skb = NULL;\n\t\t\tconn->rx_len = 0;\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t}\n\n\t\tif (skb->len < 2) {\n\t\t\tBT_ERR(\"Frame is too short (len %d)\", skb->len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\thdr = (struct l2cap_hdr *) skb->data;\n\t\tlen = __le16_to_cpu(hdr->len) + L2CAP_HDR_SIZE;\n\n\t\tif (len == skb->len) {\n\t\t\t/* Complete frame received */\n\t\t\tl2cap_recv_frame(conn, skb);\n\t\t\treturn 0;\n\t\t}\n\n\t\tBT_DBG(\"Start: total len %d, frag len %d\", len, skb->len);\n\n\t\tif (skb->len > len) {\n\t\t\tBT_ERR(\"Frame is too long (len %d, expected len %d)\",\n\t\t\t\tskb->len, len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Allocate skb for the complete frame (with header) */\n\t\tconn->rx_skb = bt_skb_alloc(len, GFP_ATOMIC);\n\t\tif (!conn->rx_skb)\n\t\t\tgoto drop;\n\n\t\tskb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),\n\t\t\t\t\t\t\t\tskb->len);\n\t\tconn->rx_len = len - skb->len;\n\t} else {\n\t\tBT_DBG(\"Cont: frag len %d (expecting %d)\", skb->len, conn->rx_len);\n\n\t\tif (!conn->rx_len) {\n\t\t\tBT_ERR(\"Unexpected continuation frame (len %d)\", skb->len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (skb->len > conn->rx_len) {\n\t\t\tBT_ERR(\"Fragment is too long (len %d, expected %d)\",\n\t\t\t\t\tskb->len, conn->rx_len);\n\t\t\tkfree_skb(conn->rx_skb);\n\t\t\tconn->rx_skb = NULL;\n\t\t\tconn->rx_len = 0;\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tskb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),\n\t\t\t\t\t\t\t\tskb->len);\n\t\tconn->rx_len -= skb->len;\n\n\t\tif (!conn->rx_len) {\n\t\t\t/* Complete frame received */\n\t\t\tl2cap_recv_frame(conn, conn->rx_skb);\n\t\t\tconn->rx_skb = NULL;\n\t\t}\n\t}\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic ssize_t l2cap_sysfs_show(struct class *dev, char *buf)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\tchar *str = buf;\n\n\tread_lock_bh(&l2cap_sk_list.lock);\n\n\tsk_for_each(sk, node, &l2cap_sk_list.head) {\n\t\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\n\t\tstr += sprintf(str, \"%s %s %d %d 0x%4.4x 0x%4.4x %d %d %d\\n\",\n\t\t\t\tbatostr(&bt_sk(sk)->src), batostr(&bt_sk(sk)->dst),\n\t\t\t\tsk->sk_state, __le16_to_cpu(pi->psm), pi->scid,\n\t\t\t\tpi->dcid, pi->imtu, pi->omtu, pi->sec_level);\n\t}\n\n\tread_unlock_bh(&l2cap_sk_list.lock);\n\n\treturn str - buf;\n}\n\nstatic CLASS_ATTR(l2cap, S_IRUGO, l2cap_sysfs_show, NULL);\n\nstatic const struct proto_ops l2cap_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= l2cap_sock_release,\n\t.bind\t\t= l2cap_sock_bind,\n\t.connect\t= l2cap_sock_connect,\n\t.listen\t\t= l2cap_sock_listen,\n\t.accept\t\t= l2cap_sock_accept,\n\t.getname\t= l2cap_sock_getname,\n\t.sendmsg\t= l2cap_sock_sendmsg,\n\t.recvmsg\t= l2cap_sock_recvmsg,\n\t.poll\t\t= bt_sock_poll,\n\t.ioctl\t\t= bt_sock_ioctl,\n\t.mmap\t\t= sock_no_mmap,\n\t.socketpair\t= sock_no_socketpair,\n\t.shutdown\t= l2cap_sock_shutdown,\n\t.setsockopt\t= l2cap_sock_setsockopt,\n\t.getsockopt\t= l2cap_sock_getsockopt\n};\n\nstatic struct net_proto_family l2cap_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= l2cap_sock_create,\n};\n\nstatic struct hci_proto l2cap_hci_proto = {\n\t.name\t\t= \"L2CAP\",\n\t.id\t\t= HCI_PROTO_L2CAP,\n\t.connect_ind\t= l2cap_connect_ind,\n\t.connect_cfm\t= l2cap_connect_cfm,\n\t.disconn_ind\t= l2cap_disconn_ind,\n\t.disconn_cfm\t= l2cap_disconn_cfm,\n\t.security_cfm\t= l2cap_security_cfm,\n\t.recv_acldata\t= l2cap_recv_acldata\n};\n\nstatic int __init l2cap_init(void)\n{\n\tint err;\n\n\terr = proto_register(&l2cap_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_L2CAP, &l2cap_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"L2CAP socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = hci_register_proto(&l2cap_hci_proto);\n\tif (err < 0) {\n\t\tBT_ERR(\"L2CAP protocol registration failed\");\n\t\tbt_sock_unregister(BTPROTO_L2CAP);\n\t\tgoto error;\n\t}\n\n\tif (class_create_file(bt_class, &class_attr_l2cap) < 0)\n\t\tBT_ERR(\"Failed to create L2CAP info file\");\n\n\tBT_INFO(\"L2CAP ver %s\", VERSION);\n\tBT_INFO(\"L2CAP socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&l2cap_proto);\n\treturn err;\n}\n\nstatic void __exit l2cap_exit(void)\n{\n\tclass_remove_file(bt_class, &class_attr_l2cap);\n\n\tif (bt_sock_unregister(BTPROTO_L2CAP) < 0)\n\t\tBT_ERR(\"L2CAP socket unregistration failed\");\n\n\tif (hci_unregister_proto(&l2cap_hci_proto) < 0)\n\t\tBT_ERR(\"L2CAP protocol unregistration failed\");\n\n\tproto_unregister(&l2cap_proto);\n}\n\nvoid l2cap_load(void)\n{\n\t/* Dummy function to trigger automatic L2CAP module loading by\n\t * other modules that use L2CAP sockets but don't use any other\n\t * symbols from it. */\n\treturn;\n}\nEXPORT_SYMBOL(l2cap_load);\n\nmodule_init(l2cap_init);\nmodule_exit(l2cap_exit);\n\nmodule_param(enable_ertm, bool, 0644);\nMODULE_PARM_DESC(enable_ertm, \"Enable enhanced retransmission mode\");\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth L2CAP ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"bt-proto-0\");\n"], "fixing_code": ["/* \n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES \n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN \n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF \n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, \n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS \n   SOFTWARE IS DISCLAIMED.\n*/\n\n#ifndef __L2CAP_H\n#define __L2CAP_H\n\n/* L2CAP defaults */\n#define L2CAP_DEFAULT_MTU\t\t672\n#define L2CAP_DEFAULT_MIN_MTU\t\t48\n#define L2CAP_DEFAULT_FLUSH_TO\t\t0xffff\n#define L2CAP_DEFAULT_TX_WINDOW\t\t1\n#define L2CAP_DEFAULT_MAX_RECEIVE\t1\n#define L2CAP_DEFAULT_RETRANS_TO\t300    /* 300 milliseconds */\n#define L2CAP_DEFAULT_MONITOR_TO\t1000   /* 1 second */\n#define L2CAP_DEFAULT_MAX_RX_APDU\t0xfff7\n\n#define L2CAP_CONN_TIMEOUT\t(40000) /* 40 seconds */\n#define L2CAP_INFO_TIMEOUT\t(4000)  /*  4 seconds */\n\n/* L2CAP socket address */\nstruct sockaddr_l2 {\n\tsa_family_t\tl2_family;\n\t__le16\t\tl2_psm;\n\tbdaddr_t\tl2_bdaddr;\n\t__le16\t\tl2_cid;\n};\n\n/* L2CAP socket options */\n#define L2CAP_OPTIONS\t0x01\nstruct l2cap_options {\n\t__u16 omtu;\n\t__u16 imtu;\n\t__u16 flush_to;\n\t__u8  mode;\n};\n\n#define L2CAP_CONNINFO\t0x02\nstruct l2cap_conninfo {\n\t__u16 hci_handle;\n\t__u8  dev_class[3];\n};\n\n#define L2CAP_LM\t0x03\n#define L2CAP_LM_MASTER\t\t0x0001\n#define L2CAP_LM_AUTH\t\t0x0002\n#define L2CAP_LM_ENCRYPT\t0x0004\n#define L2CAP_LM_TRUSTED\t0x0008\n#define L2CAP_LM_RELIABLE\t0x0010\n#define L2CAP_LM_SECURE\t\t0x0020\n\n/* L2CAP command codes */\n#define L2CAP_COMMAND_REJ\t0x01\n#define L2CAP_CONN_REQ\t\t0x02\n#define L2CAP_CONN_RSP\t\t0x03\n#define L2CAP_CONF_REQ\t\t0x04\n#define L2CAP_CONF_RSP\t\t0x05\n#define L2CAP_DISCONN_REQ\t0x06\n#define L2CAP_DISCONN_RSP\t0x07\n#define L2CAP_ECHO_REQ\t\t0x08\n#define L2CAP_ECHO_RSP\t\t0x09\n#define L2CAP_INFO_REQ\t\t0x0a\n#define L2CAP_INFO_RSP\t\t0x0b\n\n/* L2CAP feature mask */\n#define L2CAP_FEAT_FLOWCTL\t0x00000001\n#define L2CAP_FEAT_RETRANS\t0x00000002\n#define L2CAP_FEAT_ERTM\t\t0x00000008\n#define L2CAP_FEAT_STREAMING\t0x00000010\n#define L2CAP_FEAT_FCS\t\t0x00000020\n#define L2CAP_FEAT_FIXED_CHAN\t0x00000080\n\n/* L2CAP checksum option */\n#define L2CAP_FCS_NONE\t\t0x00\n#define L2CAP_FCS_CRC16\t\t0x01\n\n/* L2CAP structures */\nstruct l2cap_hdr {\n\t__le16     len;\n\t__le16     cid;\n} __attribute__ ((packed));\n#define L2CAP_HDR_SIZE\t\t4\n\nstruct l2cap_cmd_hdr {\n\t__u8       code;\n\t__u8       ident;\n\t__le16     len;\n} __attribute__ ((packed));\n#define L2CAP_CMD_HDR_SIZE\t4\n\nstruct l2cap_cmd_rej {\n\t__le16     reason;\n} __attribute__ ((packed));\n\nstruct l2cap_conn_req {\n\t__le16     psm;\n\t__le16     scid;\n} __attribute__ ((packed));\n\nstruct l2cap_conn_rsp {\n\t__le16     dcid;\n\t__le16     scid;\n\t__le16     result;\n\t__le16     status;\n} __attribute__ ((packed));\n\n/* channel indentifier */\n#define L2CAP_CID_SIGNALING\t0x0001\n#define L2CAP_CID_CONN_LESS\t0x0002\n#define L2CAP_CID_DYN_START\t0x0040\n#define L2CAP_CID_DYN_END\t0xffff\n\n/* connect result */\n#define L2CAP_CR_SUCCESS\t0x0000\n#define L2CAP_CR_PEND\t\t0x0001\n#define L2CAP_CR_BAD_PSM\t0x0002\n#define L2CAP_CR_SEC_BLOCK\t0x0003\n#define L2CAP_CR_NO_MEM\t\t0x0004\n\n/* connect status */\n#define L2CAP_CS_NO_INFO\t0x0000\n#define L2CAP_CS_AUTHEN_PEND\t0x0001\n#define L2CAP_CS_AUTHOR_PEND\t0x0002\n\nstruct l2cap_conf_req {\n\t__le16     dcid;\n\t__le16     flags;\n\t__u8       data[0];\n} __attribute__ ((packed));\n\nstruct l2cap_conf_rsp {\n\t__le16     scid;\n\t__le16     flags;\n\t__le16     result;\n\t__u8       data[0];\n} __attribute__ ((packed));\n\n#define L2CAP_CONF_SUCCESS\t0x0000\n#define L2CAP_CONF_UNACCEPT\t0x0001\n#define L2CAP_CONF_REJECT\t0x0002\n#define L2CAP_CONF_UNKNOWN\t0x0003\n\nstruct l2cap_conf_opt {\n\t__u8       type;\n\t__u8       len;\n\t__u8       val[0];\n} __attribute__ ((packed));\n#define L2CAP_CONF_OPT_SIZE\t2\n\n#define L2CAP_CONF_HINT\t\t0x80\n#define L2CAP_CONF_MASK\t\t0x7f\n\n#define L2CAP_CONF_MTU\t\t0x01\n#define L2CAP_CONF_FLUSH_TO\t0x02\n#define L2CAP_CONF_QOS\t\t0x03\n#define L2CAP_CONF_RFC\t\t0x04\n#define L2CAP_CONF_FCS\t\t0x05\n\n#define L2CAP_CONF_MAX_SIZE\t22\n\nstruct l2cap_conf_rfc {\n\t__u8       mode;\n\t__u8       txwin_size;\n\t__u8       max_transmit;\n\t__le16     retrans_timeout;\n\t__le16     monitor_timeout;\n\t__le16     max_pdu_size;\n} __attribute__ ((packed));\n\n#define L2CAP_MODE_BASIC\t0x00\n#define L2CAP_MODE_RETRANS\t0x01\n#define L2CAP_MODE_FLOWCTL\t0x02\n#define L2CAP_MODE_ERTM\t\t0x03\n#define L2CAP_MODE_STREAMING\t0x04\n\nstruct l2cap_disconn_req {\n\t__le16     dcid;\n\t__le16     scid;\n} __attribute__ ((packed));\n\nstruct l2cap_disconn_rsp {\n\t__le16     dcid;\n\t__le16     scid;\n} __attribute__ ((packed));\n\nstruct l2cap_info_req {\n\t__le16      type;\n} __attribute__ ((packed));\n\nstruct l2cap_info_rsp {\n\t__le16      type;\n\t__le16      result;\n\t__u8        data[0];\n} __attribute__ ((packed));\n\n/* info type */\n#define L2CAP_IT_CL_MTU     0x0001\n#define L2CAP_IT_FEAT_MASK  0x0002\n#define L2CAP_IT_FIXED_CHAN 0x0003\n\n/* info result */\n#define L2CAP_IR_SUCCESS    0x0000\n#define L2CAP_IR_NOTSUPP    0x0001\n\n/* ----- L2CAP connections ----- */\nstruct l2cap_chan_list {\n\tstruct sock\t*head;\n\trwlock_t\tlock;\n\tlong\t\tnum;\n};\n\nstruct l2cap_conn {\n\tstruct hci_conn\t*hcon;\n\n\tbdaddr_t\t*dst;\n\tbdaddr_t\t*src;\n\n\tunsigned int\tmtu;\n\n\t__u32\t\tfeat_mask;\n\n\t__u8\t\tinfo_state;\n\t__u8\t\tinfo_ident;\n\n\tstruct timer_list info_timer;\n\n\tspinlock_t\tlock;\n\n\tstruct sk_buff *rx_skb;\n\t__u32\t\trx_len;\n\t__u8\t\trx_ident;\n\t__u8\t\ttx_ident;\n\n\t__u8\t\tdisc_reason;\n\n\tstruct l2cap_chan_list chan_list;\n};\n\n#define L2CAP_INFO_CL_MTU_REQ_SENT\t0x01\n#define L2CAP_INFO_FEAT_MASK_REQ_SENT\t0x04\n#define L2CAP_INFO_FEAT_MASK_REQ_DONE\t0x08\n\n/* ----- L2CAP channel and socket info ----- */\n#define l2cap_pi(sk) ((struct l2cap_pinfo *) sk)\n\nstruct l2cap_pinfo {\n\tstruct bt_sock\tbt;\n\t__le16\t\tpsm;\n\t__u16\t\tdcid;\n\t__u16\t\tscid;\n\n\t__u16\t\timtu;\n\t__u16\t\tomtu;\n\t__u16\t\tflush_to;\n\t__u8\t\tmode;\n\t__u8\t\tnum_conf_req;\n\t__u8\t\tnum_conf_rsp;\n\n\t__u8\t\tfcs;\n\t__u8\t\tsec_level;\n\t__u8\t\trole_switch;\n\t__u8\t\tforce_reliable;\n\n\t__u8\t\tconf_req[64];\n\t__u8\t\tconf_len;\n\t__u8\t\tconf_state;\n\n\t__u8\t\tident;\n\n\t__u8\t\tremote_tx_win;\n\t__u8\t\tremote_max_tx;\n\t__u16\t\tretrans_timeout;\n\t__u16\t\tmonitor_timeout;\n\t__u16\t\tmax_pdu_size;\n\n\t__le16\t\tsport;\n\n\tstruct l2cap_conn\t*conn;\n\tstruct sock\t\t*next_c;\n\tstruct sock\t\t*prev_c;\n};\n\n#define L2CAP_CONF_REQ_SENT       0x01\n#define L2CAP_CONF_INPUT_DONE     0x02\n#define L2CAP_CONF_OUTPUT_DONE    0x04\n#define L2CAP_CONF_MTU_DONE       0x08\n#define L2CAP_CONF_MODE_DONE      0x10\n#define L2CAP_CONF_CONNECT_PEND   0x20\n#define L2CAP_CONF_STATE2_DEVICE  0x80\n\n#define L2CAP_CONF_MAX_CONF_REQ 2\n#define L2CAP_CONF_MAX_CONF_RSP 2\n\n\nvoid l2cap_load(void);\n\n#endif /* __L2CAP_H */\n", "/*\n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/* Bluetooth L2CAP core and sockets. */\n\n#include <linux/module.h>\n\n#include <linux/types.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/fcntl.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/socket.h>\n#include <linux/skbuff.h>\n#include <linux/list.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <net/sock.h>\n\n#include <asm/system.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#define VERSION \"2.14\"\n\nstatic int enable_ertm = 0;\n\nstatic u32 l2cap_feat_mask = L2CAP_FEAT_FIXED_CHAN;\nstatic u8 l2cap_fixed_chan[8] = { 0x02, };\n\nstatic const struct proto_ops l2cap_sock_ops;\n\nstatic struct bt_sock_list l2cap_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(l2cap_sk_list.lock)\n};\n\nstatic void __l2cap_sock_close(struct sock *sk, int reason);\nstatic void l2cap_sock_close(struct sock *sk);\nstatic void l2cap_sock_kill(struct sock *sk);\n\nstatic struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,\n\t\t\t\tu8 code, u8 ident, u16 dlen, void *data);\n\n/* ---- L2CAP timers ---- */\nstatic void l2cap_sock_timeout(unsigned long arg)\n{\n\tstruct sock *sk = (struct sock *) arg;\n\tint reason;\n\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\n\tbh_lock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED || sk->sk_state == BT_CONFIG)\n\t\treason = ECONNREFUSED;\n\telse if (sk->sk_state == BT_CONNECT &&\n\t\t\t\tl2cap_pi(sk)->sec_level != BT_SECURITY_SDP)\n\t\treason = ECONNREFUSED;\n\telse\n\t\treason = ETIMEDOUT;\n\n\t__l2cap_sock_close(sk, reason);\n\n\tbh_unlock_sock(sk);\n\n\tl2cap_sock_kill(sk);\n\tsock_put(sk);\n}\n\nstatic void l2cap_sock_set_timer(struct sock *sk, long timeout)\n{\n\tBT_DBG(\"sk %p state %d timeout %ld\", sk, sk->sk_state, timeout);\n\tsk_reset_timer(sk, &sk->sk_timer, jiffies + timeout);\n}\n\nstatic void l2cap_sock_clear_timer(struct sock *sk)\n{\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tsk_stop_timer(sk, &sk->sk_timer);\n}\n\n/* ---- L2CAP channels ---- */\nstatic struct sock *__l2cap_get_chan_by_dcid(struct l2cap_chan_list *l, u16 cid)\n{\n\tstruct sock *s;\n\tfor (s = l->head; s; s = l2cap_pi(s)->next_c) {\n\t\tif (l2cap_pi(s)->dcid == cid)\n\t\t\tbreak;\n\t}\n\treturn s;\n}\n\nstatic struct sock *__l2cap_get_chan_by_scid(struct l2cap_chan_list *l, u16 cid)\n{\n\tstruct sock *s;\n\tfor (s = l->head; s; s = l2cap_pi(s)->next_c) {\n\t\tif (l2cap_pi(s)->scid == cid)\n\t\t\tbreak;\n\t}\n\treturn s;\n}\n\n/* Find channel with given SCID.\n * Returns locked socket */\nstatic inline struct sock *l2cap_get_chan_by_scid(struct l2cap_chan_list *l, u16 cid)\n{\n\tstruct sock *s;\n\tread_lock(&l->lock);\n\ts = __l2cap_get_chan_by_scid(l, cid);\n\tif (s)\n\t\tbh_lock_sock(s);\n\tread_unlock(&l->lock);\n\treturn s;\n}\n\nstatic struct sock *__l2cap_get_chan_by_ident(struct l2cap_chan_list *l, u8 ident)\n{\n\tstruct sock *s;\n\tfor (s = l->head; s; s = l2cap_pi(s)->next_c) {\n\t\tif (l2cap_pi(s)->ident == ident)\n\t\t\tbreak;\n\t}\n\treturn s;\n}\n\nstatic inline struct sock *l2cap_get_chan_by_ident(struct l2cap_chan_list *l, u8 ident)\n{\n\tstruct sock *s;\n\tread_lock(&l->lock);\n\ts = __l2cap_get_chan_by_ident(l, ident);\n\tif (s)\n\t\tbh_lock_sock(s);\n\tread_unlock(&l->lock);\n\treturn s;\n}\n\nstatic u16 l2cap_alloc_cid(struct l2cap_chan_list *l)\n{\n\tu16 cid = L2CAP_CID_DYN_START;\n\n\tfor (; cid < L2CAP_CID_DYN_END; cid++) {\n\t\tif (!__l2cap_get_chan_by_scid(l, cid))\n\t\t\treturn cid;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void __l2cap_chan_link(struct l2cap_chan_list *l, struct sock *sk)\n{\n\tsock_hold(sk);\n\n\tif (l->head)\n\t\tl2cap_pi(l->head)->prev_c = sk;\n\n\tl2cap_pi(sk)->next_c = l->head;\n\tl2cap_pi(sk)->prev_c = NULL;\n\tl->head = sk;\n}\n\nstatic inline void l2cap_chan_unlink(struct l2cap_chan_list *l, struct sock *sk)\n{\n\tstruct sock *next = l2cap_pi(sk)->next_c, *prev = l2cap_pi(sk)->prev_c;\n\n\twrite_lock_bh(&l->lock);\n\tif (sk == l->head)\n\t\tl->head = next;\n\n\tif (next)\n\t\tl2cap_pi(next)->prev_c = prev;\n\tif (prev)\n\t\tl2cap_pi(prev)->next_c = next;\n\twrite_unlock_bh(&l->lock);\n\n\t__sock_put(sk);\n}\n\nstatic void __l2cap_chan_add(struct l2cap_conn *conn, struct sock *sk, struct sock *parent)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\n\tBT_DBG(\"conn %p, psm 0x%2.2x, dcid 0x%4.4x\", conn,\n\t\t\tl2cap_pi(sk)->psm, l2cap_pi(sk)->dcid);\n\n\tconn->disc_reason = 0x13;\n\n\tl2cap_pi(sk)->conn = conn;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\t/* Alloc CID for connection-oriented socket */\n\t\tl2cap_pi(sk)->scid = l2cap_alloc_cid(l);\n\t} else if (sk->sk_type == SOCK_DGRAM) {\n\t\t/* Connectionless socket */\n\t\tl2cap_pi(sk)->scid = L2CAP_CID_CONN_LESS;\n\t\tl2cap_pi(sk)->dcid = L2CAP_CID_CONN_LESS;\n\t\tl2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;\n\t} else {\n\t\t/* Raw socket can send/recv signalling messages only */\n\t\tl2cap_pi(sk)->scid = L2CAP_CID_SIGNALING;\n\t\tl2cap_pi(sk)->dcid = L2CAP_CID_SIGNALING;\n\t\tl2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;\n\t}\n\n\t__l2cap_chan_link(l, sk);\n\n\tif (parent)\n\t\tbt_accept_enqueue(parent, sk);\n}\n\n/* Delete channel.\n * Must be called on the locked socket. */\nstatic void l2cap_chan_del(struct sock *sk, int err)\n{\n\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\tstruct sock *parent = bt_sk(sk)->parent;\n\n\tl2cap_sock_clear_timer(sk);\n\n\tBT_DBG(\"sk %p, conn %p, err %d\", sk, conn, err);\n\n\tif (conn) {\n\t\t/* Unlink from channel list */\n\t\tl2cap_chan_unlink(&conn->chan_list, sk);\n\t\tl2cap_pi(sk)->conn = NULL;\n\t\thci_conn_put(conn->hcon);\n\t}\n\n\tsk->sk_state = BT_CLOSED;\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n\tif (err)\n\t\tsk->sk_err = err;\n\n\tif (parent) {\n\t\tbt_accept_unlink(sk);\n\t\tparent->sk_data_ready(parent, 0);\n\t} else\n\t\tsk->sk_state_change(sk);\n}\n\n/* Service level security */\nstatic inline int l2cap_check_security(struct sock *sk)\n{\n\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\t__u8 auth_type;\n\n\tif (l2cap_pi(sk)->psm == cpu_to_le16(0x0001)) {\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH)\n\t\t\tauth_type = HCI_AT_NO_BONDING_MITM;\n\t\telse\n\t\t\tauth_type = HCI_AT_NO_BONDING;\n\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_LOW)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_SDP;\n\t} else {\n\t\tswitch (l2cap_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\t\tauth_type = HCI_AT_GENERAL_BONDING_MITM;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\tauth_type = HCI_AT_GENERAL_BONDING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tauth_type = HCI_AT_NO_BONDING;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn hci_conn_security(conn->hcon, l2cap_pi(sk)->sec_level,\n\t\t\t\t\t\t\t\tauth_type);\n}\n\nstatic inline u8 l2cap_get_ident(struct l2cap_conn *conn)\n{\n\tu8 id;\n\n\t/* Get next available identificator.\n\t *    1 - 128 are used by kernel.\n\t *  129 - 199 are reserved.\n\t *  200 - 254 are used by utilities like l2ping, etc.\n\t */\n\n\tspin_lock_bh(&conn->lock);\n\n\tif (++conn->tx_ident > 128)\n\t\tconn->tx_ident = 1;\n\n\tid = conn->tx_ident;\n\n\tspin_unlock_bh(&conn->lock);\n\n\treturn id;\n}\n\nstatic inline int l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data)\n{\n\tstruct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);\n\n\tBT_DBG(\"code 0x%2.2x\", code);\n\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treturn hci_send_acl(conn->hcon, skb, 0);\n}\n\nstatic void l2cap_do_start(struct sock *sk)\n{\n\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) {\n\t\tif (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))\n\t\t\treturn;\n\n\t\tif (l2cap_check_security(sk)) {\n\t\t\tstruct l2cap_conn_req req;\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\treq.psm  = l2cap_pi(sk)->psm;\n\n\t\t\tl2cap_pi(sk)->ident = l2cap_get_ident(conn);\n\n\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_REQ, sizeof(req), &req);\n\t\t}\n\t} else {\n\t\tstruct l2cap_info_req req;\n\t\treq.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;\n\t\tconn->info_ident = l2cap_get_ident(conn);\n\n\t\tmod_timer(&conn->info_timer, jiffies +\n\t\t\t\t\tmsecs_to_jiffies(L2CAP_INFO_TIMEOUT));\n\n\t\tl2cap_send_cmd(conn, conn->info_ident,\n\t\t\t\t\tL2CAP_INFO_REQ, sizeof(req), &req);\n\t}\n}\n\n/* ---- L2CAP connections ---- */\nstatic void l2cap_conn_start(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\tstruct sock *sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tbh_lock_sock(sk);\n\n\t\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk->sk_state == BT_CONNECT) {\n\t\t\tif (l2cap_check_security(sk)) {\n\t\t\t\tstruct l2cap_conn_req req;\n\t\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\t\treq.psm  = l2cap_pi(sk)->psm;\n\n\t\t\t\tl2cap_pi(sk)->ident = l2cap_get_ident(conn);\n\n\t\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_REQ, sizeof(req), &req);\n\t\t\t}\n\t\t} else if (sk->sk_state == BT_CONNECT2) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\trsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\trsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);\n\n\t\t\tif (l2cap_check_security(sk)) {\n\t\t\t\tif (bt_sk(sk)->defer_setup) {\n\t\t\t\t\tstruct sock *parent = bt_sk(sk)->parent;\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHOR_PEND);\n\t\t\t\t\tparent->sk_data_ready(parent, 0);\n\n\t\t\t\t} else {\n\t\t\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);\n\t\t\t}\n\n\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_RSP, sizeof(rsp), &rsp);\n\t\t}\n\n\t\tbh_unlock_sock(sk);\n\t}\n\n\tread_unlock(&l->lock);\n}\n\nstatic void l2cap_conn_ready(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\tstruct sock *sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tbh_lock_sock(sk);\n\n\t\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\t\tl2cap_sock_clear_timer(sk);\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\t\tsk->sk_state_change(sk);\n\t\t} else if (sk->sk_state == BT_CONNECT)\n\t\t\tl2cap_do_start(sk);\n\n\t\tbh_unlock_sock(sk);\n\t}\n\n\tread_unlock(&l->lock);\n}\n\n/* Notify sockets that we cannot guaranty reliability anymore */\nstatic void l2cap_conn_unreliable(struct l2cap_conn *conn, int err)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\tstruct sock *sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tif (l2cap_pi(sk)->force_reliable)\n\t\t\tsk->sk_err = err;\n\t}\n\n\tread_unlock(&l->lock);\n}\n\nstatic void l2cap_info_timeout(unsigned long arg)\n{\n\tstruct l2cap_conn *conn = (void *) arg;\n\n\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\tconn->info_ident = 0;\n\n\tl2cap_conn_start(conn);\n}\n\nstatic struct l2cap_conn *l2cap_conn_add(struct hci_conn *hcon, u8 status)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\n\tif (conn || status)\n\t\treturn conn;\n\n\tconn = kzalloc(sizeof(struct l2cap_conn), GFP_ATOMIC);\n\tif (!conn)\n\t\treturn NULL;\n\n\thcon->l2cap_data = conn;\n\tconn->hcon = hcon;\n\n\tBT_DBG(\"hcon %p conn %p\", hcon, conn);\n\n\tconn->mtu = hcon->hdev->acl_mtu;\n\tconn->src = &hcon->hdev->bdaddr;\n\tconn->dst = &hcon->dst;\n\n\tconn->feat_mask = 0;\n\n\tsetup_timer(&conn->info_timer, l2cap_info_timeout,\n\t\t\t\t\t\t(unsigned long) conn);\n\n\tspin_lock_init(&conn->lock);\n\trwlock_init(&conn->chan_list.lock);\n\n\tconn->disc_reason = 0x13;\n\n\treturn conn;\n}\n\nstatic void l2cap_conn_del(struct hci_conn *hcon, int err)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct sock *sk;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p conn %p, err %d\", hcon, conn, err);\n\n\tkfree_skb(conn->rx_skb);\n\n\t/* Kill channels */\n\twhile ((sk = conn->chan_list.head)) {\n\t\tbh_lock_sock(sk);\n\t\tl2cap_chan_del(sk, err);\n\t\tbh_unlock_sock(sk);\n\t\tl2cap_sock_kill(sk);\n\t}\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)\n\t\tdel_timer_sync(&conn->info_timer);\n\n\thcon->l2cap_data = NULL;\n\tkfree(conn);\n}\n\nstatic inline void l2cap_chan_add(struct l2cap_conn *conn, struct sock *sk, struct sock *parent)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\twrite_lock_bh(&l->lock);\n\t__l2cap_chan_add(conn, sk, parent);\n\twrite_unlock_bh(&l->lock);\n}\n\n/* ---- Socket interface ---- */\nstatic struct sock *__l2cap_get_sock_by_addr(__le16 psm, bdaddr_t *src)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\tsk_for_each(sk, node, &l2cap_sk_list.head)\n\t\tif (l2cap_pi(sk)->sport == psm && !bacmp(&bt_sk(sk)->src, src))\n\t\t\tgoto found;\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\n/* Find socket with psm and source bdaddr.\n * Returns closest match.\n */\nstatic struct sock *__l2cap_get_sock_by_psm(int state, __le16 psm, bdaddr_t *src)\n{\n\tstruct sock *sk = NULL, *sk1 = NULL;\n\tstruct hlist_node *node;\n\n\tsk_for_each(sk, node, &l2cap_sk_list.head) {\n\t\tif (state && sk->sk_state != state)\n\t\t\tcontinue;\n\n\t\tif (l2cap_pi(sk)->psm == psm) {\n\t\t\t/* Exact match. */\n\t\t\tif (!bacmp(&bt_sk(sk)->src, src))\n\t\t\t\tbreak;\n\n\t\t\t/* Closest match */\n\t\t\tif (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))\n\t\t\t\tsk1 = sk;\n\t\t}\n\t}\n\treturn node ? sk : sk1;\n}\n\n/* Find socket with given address (psm, src).\n * Returns locked socket */\nstatic inline struct sock *l2cap_get_sock_by_psm(int state, __le16 psm, bdaddr_t *src)\n{\n\tstruct sock *s;\n\tread_lock(&l2cap_sk_list.lock);\n\ts = __l2cap_get_sock_by_psm(state, psm, src);\n\tif (s)\n\t\tbh_lock_sock(s);\n\tread_unlock(&l2cap_sk_list.lock);\n\treturn s;\n}\n\nstatic void l2cap_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic void l2cap_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p\", parent);\n\n\t/* Close not yet accepted channels */\n\twhile ((sk = bt_accept_dequeue(parent, NULL)))\n\t\tl2cap_sock_close(sk);\n\n\tparent->sk_state = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}\n\n/* Kill socket (only if zapped and orphan)\n * Must be called on unlocked socket.\n */\nstatic void l2cap_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %d\", sk, sk->sk_state);\n\n\t/* Kill poor orphan */\n\tbt_sock_unlink(&l2cap_sk_list, sk);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic void __l2cap_sock_close(struct sock *sk, int reason)\n{\n\tBT_DBG(\"sk %p state %d socket %p\", sk, sk->sk_state, sk->sk_socket);\n\n\tswitch (sk->sk_state) {\n\tcase BT_LISTEN:\n\t\tl2cap_sock_cleanup_listen(sk);\n\t\tbreak;\n\n\tcase BT_CONNECTED:\n\tcase BT_CONFIG:\n\t\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\t\t\tstruct l2cap_disconn_req req;\n\n\t\t\tsk->sk_state = BT_DISCONN;\n\t\t\tl2cap_sock_set_timer(sk, sk->sk_sndtimeo);\n\n\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t} else\n\t\t\tl2cap_chan_del(sk, reason);\n\t\tbreak;\n\n\tcase BT_CONNECT2:\n\t\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\t__u16 result;\n\n\t\t\tif (bt_sk(sk)->defer_setup)\n\t\t\t\tresult = L2CAP_CR_SEC_BLOCK;\n\t\t\telse\n\t\t\t\tresult = L2CAP_CR_BAD_PSM;\n\n\t\t\trsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\trsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\trsp.result = cpu_to_le16(result);\n\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_RSP, sizeof(rsp), &rsp);\n\t\t} else\n\t\t\tl2cap_chan_del(sk, reason);\n\t\tbreak;\n\n\tcase BT_CONNECT:\n\tcase BT_DISCONN:\n\t\tl2cap_chan_del(sk, reason);\n\t\tbreak;\n\n\tdefault:\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tbreak;\n\t}\n}\n\n/* Must be called on unlocked socket. */\nstatic void l2cap_sock_close(struct sock *sk)\n{\n\tl2cap_sock_clear_timer(sk);\n\tlock_sock(sk);\n\t__l2cap_sock_close(sk, ECONNRESET);\n\trelease_sock(sk);\n\tl2cap_sock_kill(sk);\n}\n\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tsk->sk_type = parent->sk_type;\n\t\tbt_sk(sk)->defer_setup = bt_sk(parent)->defer_setup;\n\n\t\tpi->imtu = l2cap_pi(parent)->imtu;\n\t\tpi->omtu = l2cap_pi(parent)->omtu;\n\t\tpi->mode = l2cap_pi(parent)->mode;\n\t\tpi->fcs  = l2cap_pi(parent)->fcs;\n\t\tpi->sec_level = l2cap_pi(parent)->sec_level;\n\t\tpi->role_switch = l2cap_pi(parent)->role_switch;\n\t\tpi->force_reliable = l2cap_pi(parent)->force_reliable;\n\t} else {\n\t\tpi->imtu = L2CAP_DEFAULT_MTU;\n\t\tpi->omtu = 0;\n\t\tpi->mode = L2CAP_MODE_BASIC;\n\t\tpi->fcs  = L2CAP_FCS_CRC16;\n\t\tpi->sec_level = BT_SECURITY_LOW;\n\t\tpi->role_switch = 0;\n\t\tpi->force_reliable = 0;\n\t}\n\n\t/* Default config options */\n\tpi->conf_len = 0;\n\tpi->flush_to = L2CAP_DEFAULT_FLUSH_TO;\n}\n\nstatic struct proto l2cap_proto = {\n\t.name\t\t= \"L2CAP\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct l2cap_pinfo)\n};\n\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)\n{\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\tsk->sk_destruct = l2cap_sock_destruct;\n\tsk->sk_sndtimeo = msecs_to_jiffies(L2CAP_CONN_TIMEOUT);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state = BT_OPEN;\n\n\tsetup_timer(&sk->sk_timer, l2cap_sock_timeout, (unsigned long) sk);\n\n\tbt_sock_link(&l2cap_sk_list, sk);\n\treturn sk;\n}\n\nstatic int l2cap_sock_create(struct net *net, struct socket *sock, int protocol)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_SEQPACKET &&\n\t\t\tsock->type != SOCK_DGRAM && sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW && !capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsock->ops = &l2cap_sock_ops;\n\n\tsk = l2cap_sock_alloc(net, sock, protocol, GFP_ATOMIC);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tl2cap_sock_init(sk, NULL);\n\treturn 0;\n}\n\nstatic int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\n\tif (la.l2_cid)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (la.l2_psm && __le16_to_cpu(la.l2_psm) < 0x1001 &&\n\t\t\t\t!capable(CAP_NET_BIND_SERVICE)) {\n\t\terr = -EACCES;\n\t\tgoto done;\n\t}\n\n\twrite_lock_bh(&l2cap_sk_list.lock);\n\n\tif (la.l2_psm && __l2cap_get_sock_by_addr(la.l2_psm, &la.l2_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\t/* Save source address */\n\t\tbacpy(&bt_sk(sk)->src, &la.l2_bdaddr);\n\t\tl2cap_pi(sk)->psm   = la.l2_psm;\n\t\tl2cap_pi(sk)->sport = la.l2_psm;\n\t\tsk->sk_state = BT_BOUND;\n\n\t\tif (__le16_to_cpu(la.l2_psm) == 0x0001 ||\n\t\t\t\t\t__le16_to_cpu(la.l2_psm) == 0x0003)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_SDP;\n\t}\n\n\twrite_unlock_bh(&l2cap_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_do_connect(struct sock *sk)\n{\n\tbdaddr_t *src = &bt_sk(sk)->src;\n\tbdaddr_t *dst = &bt_sk(sk)->dst;\n\tstruct l2cap_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev *hdev;\n\t__u8 auth_type;\n\tint err;\n\n\tBT_DBG(\"%s -> %s psm 0x%2.2x\", batostr(src), batostr(dst),\n\t\t\t\t\t\t\tl2cap_pi(sk)->psm);\n\n\thdev = hci_get_route(dst, src);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\n\thci_dev_lock_bh(hdev);\n\n\terr = -ENOMEM;\n\n\tif (sk->sk_type == SOCK_RAW) {\n\t\tswitch (l2cap_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\t\tauth_type = HCI_AT_DEDICATED_BONDING_MITM;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\tauth_type = HCI_AT_DEDICATED_BONDING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tauth_type = HCI_AT_NO_BONDING;\n\t\t\tbreak;\n\t\t}\n\t} else if (l2cap_pi(sk)->psm == cpu_to_le16(0x0001)) {\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH)\n\t\t\tauth_type = HCI_AT_NO_BONDING_MITM;\n\t\telse\n\t\t\tauth_type = HCI_AT_NO_BONDING;\n\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_LOW)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_SDP;\n\t} else {\n\t\tswitch (l2cap_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\t\tauth_type = HCI_AT_GENERAL_BONDING_MITM;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\tauth_type = HCI_AT_GENERAL_BONDING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tauth_type = HCI_AT_NO_BONDING;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thcon = hci_connect(hdev, ACL_LINK, dst,\n\t\t\t\t\tl2cap_pi(sk)->sec_level, auth_type);\n\tif (!hcon)\n\t\tgoto done;\n\n\tconn = l2cap_conn_add(hcon, 0);\n\tif (!conn) {\n\t\thci_conn_put(hcon);\n\t\tgoto done;\n\t}\n\n\terr = 0;\n\n\t/* Update source addr of the socket */\n\tbacpy(src, conn->src);\n\n\tl2cap_chan_add(conn, sk, NULL);\n\n\tsk->sk_state = BT_CONNECT;\n\tl2cap_sock_set_timer(sk, sk->sk_sndtimeo);\n\n\tif (hcon->state == BT_CONNECTED) {\n\t\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\t\tl2cap_sock_clear_timer(sk);\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\t} else\n\t\t\tl2cap_do_start(sk);\n\t}\n\ndone:\n\thci_dev_unlock_bh(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}\n\nstatic int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\n\tif (la.l2_cid)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_type == SOCK_SEQPACKET && !la.l2_psm) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (l2cap_pi(sk)->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (enable_ertm)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\t\t/* Already connecting */\n\t\tgoto wait;\n\n\tcase BT_CONNECTED:\n\t\t/* Already connected */\n\t\tgoto done;\n\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\t\t/* Can connect */\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\t/* Set destination address and psm */\n\tbacpy(&bt_sk(sk)->dst, &la.l2_bdaddr);\n\tl2cap_pi(sk)->psm = la.l2_psm;\n\n\terr = l2cap_do_connect(sk);\n\tif (err)\n\t\tgoto done;\n\nwait:\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND || sock->type != SOCK_SEQPACKET) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tswitch (l2cap_pi(sk)->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (enable_ertm)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\n\tif (!l2cap_pi(sk)->psm) {\n\t\tbdaddr_t *src = &bt_sk(sk)->src;\n\t\tu16 psm;\n\n\t\terr = -EINVAL;\n\n\t\twrite_lock_bh(&l2cap_sk_list.lock);\n\n\t\tfor (psm = 0x1001; psm < 0x1100; psm += 2)\n\t\t\tif (!__l2cap_get_sock_by_addr(cpu_to_le16(psm), src)) {\n\t\t\t\tl2cap_pi(sk)->psm   = cpu_to_le16(psm);\n\t\t\t\tl2cap_pi(sk)->sport = cpu_to_le16(psm);\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\twrite_unlock_bh(&l2cap_sk_list.lock);\n\n\t\tif (err < 0)\n\t\t\tgoto done;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\tsk->sk_state = BT_LISTEN;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sock *sk = sock->sk, *nsk;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\tif (sk->sk_state != BT_LISTEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t/* Wait for an incoming connection. (wake-one). */\n\tadd_wait_queue_exclusive(sk->sk_sleep, &wait);\n\twhile (!(nsk = bt_accept_dequeue(sk, newsock))) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk->sk_sleep, &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", nsk);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\taddr->sa_family = AF_BLUETOOTH;\n\t*len = sizeof(struct sockaddr_l2);\n\n\tif (peer) {\n\t\tla->l2_psm = l2cap_pi(sk)->psm;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);\n\t\tla->l2_cid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t} else {\n\t\tla->l2_psm = l2cap_pi(sk)->sport;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->src);\n\t\tla->l2_cid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_do_send(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\tstruct sk_buff *skb, **frag;\n\tint err, hlen, count, sent = 0;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\n\t/* First fragment (with L2CAP header) */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\thlen = L2CAP_HDR_SIZE + 2;\n\telse\n\t\thlen = L2CAP_HDR_SIZE;\n\n\tcount = min_t(unsigned int, (conn->mtu - hlen), len);\n\n\tskb = bt_skb_send_alloc(sk, hlen + count,\n\t\t\tmsg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\t/* Create L2CAP header */\n\tlh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\tlh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));\n\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tput_unaligned(l2cap_pi(sk)->psm, (__le16 *) skb_put(skb, 2));\n\n\tif (memcpy_fromiovec(skb_put(skb, count), msg->msg_iov, count)) {\n\t\terr = -EFAULT;\n\t\tgoto fail;\n\t}\n\n\tsent += count;\n\tlen  -= count;\n\n\t/* Continuation fragments (no L2CAP header) */\n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tcount = min_t(unsigned int, conn->mtu, len);\n\n\t\t*frag = bt_skb_send_alloc(sk, count, msg->msg_flags & MSG_DONTWAIT, &err);\n\t\tif (!*frag)\n\t\t\tgoto fail;\n\n\t\tif (memcpy_fromiovec(skb_put(*frag, count), msg->msg_iov, count)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tsent += count;\n\t\tlen  -= count;\n\n\t\tfrag = &(*frag)->next;\n\t}\n\terr = hci_send_acl(conn->hcon, skb, 0);\n\tif (err < 0)\n\t\tgoto fail;\n\n\treturn sent;\n\nfail:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Check outgoing MTU */\n\tif (sk->sk_type != SOCK_RAW && len > l2cap_pi(sk)->omtu)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = l2cap_do_send(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 && bt_sk(sk)->defer_setup) {\n\t\tstruct l2cap_conn_rsp rsp;\n\n\t\tsk->sk_state = BT_CONFIG;\n\n\t\trsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\trsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\tl2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_RSP, sizeof(rsp), &rsp);\n\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}\n\nstatic int l2cap_sock_setsockopt_old(struct socket *sock, int optname, char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_options opts;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase L2CAP_OPTIONS:\n\t\topts.imtu     = l2cap_pi(sk)->imtu;\n\t\topts.omtu     = l2cap_pi(sk)->omtu;\n\t\topts.flush_to = l2cap_pi(sk)->flush_to;\n\t\topts.mode     = l2cap_pi(sk)->mode;\n\n\t\tlen = min_t(unsigned int, sizeof(opts), optlen);\n\t\tif (copy_from_user((char *) &opts, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tl2cap_pi(sk)->imtu = opts.imtu;\n\t\tl2cap_pi(sk)->omtu = opts.omtu;\n\t\tl2cap_pi(sk)->mode = opts.mode;\n\t\tbreak;\n\n\tcase L2CAP_LM:\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & L2CAP_LM_AUTH)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & L2CAP_LM_ENCRYPT)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & L2CAP_LM_SECURE)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_HIGH;\n\n\t\tl2cap_pi(sk)->role_switch    = (opt & L2CAP_LM_MASTER);\n\t\tl2cap_pi(sk)->force_reliable = (opt & L2CAP_LM_RELIABLE);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_L2CAP)\n\t\treturn l2cap_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned int, sizeof(sec), optlen);\n\t\tif (copy_from_user((char *) &sec, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level < BT_SECURITY_LOW ||\n\t\t\t\t\tsec.level > BT_SECURITY_HIGH) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tl2cap_pi(sk)->sec_level = sec.level;\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbt_sk(sk)->defer_setup = opt;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_options opts;\n\tstruct l2cap_conninfo cinfo;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase L2CAP_OPTIONS:\n\t\topts.imtu     = l2cap_pi(sk)->imtu;\n\t\topts.omtu     = l2cap_pi(sk)->omtu;\n\t\topts.flush_to = l2cap_pi(sk)->flush_to;\n\t\topts.mode     = l2cap_pi(sk)->mode;\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *) &opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase L2CAP_LM:\n\t\tswitch (l2cap_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_LOW:\n\t\t\topt = L2CAP_LM_AUTH;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_HIGH:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT |\n\t\t\t\t\t\t\tL2CAP_LM_SECURE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\topt = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (l2cap_pi(sk)->role_switch)\n\t\t\topt |= L2CAP_LM_MASTER;\n\n\t\tif (l2cap_pi(sk)->force_reliable)\n\t\t\topt |= L2CAP_LM_RELIABLE;\n\n\t\tif (put_user(opt, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase L2CAP_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t\t\t\t!(sk->sk_state == BT_CONNECT2 &&\n\t\t\t\t\t\tbt_sk(sk)->defer_setup)) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tcinfo.hci_handle = l2cap_pi(sk)->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, l2cap_pi(sk)->conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *) &cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_L2CAP)\n\t\treturn l2cap_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = l2cap_pi(sk)->sec_level;\n\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(bt_sk(sk)->defer_setup, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\tif (!sk->sk_shutdown) {\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\tl2cap_sock_clear_timer(sk);\n\t\t__l2cap_sock_close(sk, 0);\n\n\t\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)\n\t\t\terr = bt_sock_wait_state(sk, BT_CLOSED,\n\t\t\t\t\t\t\tsk->sk_lingertime);\n\t}\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\terr = l2cap_sock_shutdown(sock, 2);\n\n\tsock_orphan(sk);\n\tl2cap_sock_kill(sk);\n\treturn err;\n}\n\nstatic void l2cap_chan_ready(struct sock *sk)\n{\n\tstruct sock *parent = bt_sk(sk)->parent;\n\n\tBT_DBG(\"sk %p, parent %p\", sk, parent);\n\n\tl2cap_pi(sk)->conf_state = 0;\n\tl2cap_sock_clear_timer(sk);\n\n\tif (!parent) {\n\t\t/* Outgoing channel.\n\t\t * Wake up socket sleeping on connect.\n\t\t */\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tsk->sk_state_change(sk);\n\t} else {\n\t\t/* Incoming channel.\n\t\t * Wake up socket sleeping on accept.\n\t\t */\n\t\tparent->sk_data_ready(parent, 0);\n\t}\n}\n\n/* Copy frame to all raw sockets on that connection */\nstatic void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\tstruct sk_buff *nskb;\n\tstruct sock *sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tif (sk->sk_type != SOCK_RAW)\n\t\t\tcontinue;\n\n\t\t/* Don't send frame to the socket it came from */\n\t\tif (skb->sk == sk)\n\t\t\tcontinue;\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\tread_unlock(&l->lock);\n}\n\n/* ---- L2CAP signalling commands ---- */\nstatic struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,\n\t\t\t\tu8 code, u8 ident, u16 dlen, void *data)\n{\n\tstruct sk_buff *skb, **frag;\n\tstruct l2cap_cmd_hdr *cmd;\n\tstruct l2cap_hdr *lh;\n\tint len, count;\n\n\tBT_DBG(\"conn %p, code 0x%2.2x, ident 0x%2.2x, len %d\",\n\t\t\tconn, code, ident, dlen);\n\n\tlen = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;\n\tcount = min_t(unsigned int, conn->mtu, len);\n\n\tskb = bt_skb_alloc(count, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\n\tlh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);\n\tlh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);\n\n\tcmd = (struct l2cap_cmd_hdr *) skb_put(skb, L2CAP_CMD_HDR_SIZE);\n\tcmd->code  = code;\n\tcmd->ident = ident;\n\tcmd->len   = cpu_to_le16(dlen);\n\n\tif (dlen) {\n\t\tcount -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;\n\t\tmemcpy(skb_put(skb, count), data, count);\n\t\tdata += count;\n\t}\n\n\tlen -= skb->len;\n\n\t/* Continuation fragments (no L2CAP header) */\n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tcount = min_t(unsigned int, conn->mtu, len);\n\n\t\t*frag = bt_skb_alloc(count, GFP_ATOMIC);\n\t\tif (!*frag)\n\t\t\tgoto fail;\n\n\t\tmemcpy(skb_put(*frag, count), data, count);\n\n\t\tlen  -= count;\n\t\tdata += count;\n\n\t\tfrag = &(*frag)->next;\n\t}\n\n\treturn skb;\n\nfail:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstatic inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen, unsigned long *val)\n{\n\tstruct l2cap_conf_opt *opt = *ptr;\n\tint len;\n\n\tlen = L2CAP_CONF_OPT_SIZE + opt->len;\n\t*ptr += len;\n\n\t*type = opt->type;\n\t*olen = opt->len;\n\n\tswitch (opt->len) {\n\tcase 1:\n\t\t*val = *((u8 *) opt->val);\n\t\tbreak;\n\n\tcase 2:\n\t\t*val = __le16_to_cpu(*((__le16 *) opt->val));\n\t\tbreak;\n\n\tcase 4:\n\t\t*val = __le32_to_cpu(*((__le32 *) opt->val));\n\t\tbreak;\n\n\tdefault:\n\t\t*val = (unsigned long) opt->val;\n\t\tbreak;\n\t}\n\n\tBT_DBG(\"type 0x%2.2x len %d val 0x%lx\", *type, opt->len, *val);\n\treturn len;\n}\n\nstatic void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)\n{\n\tstruct l2cap_conf_opt *opt = *ptr;\n\n\tBT_DBG(\"type 0x%2.2x len %d val 0x%lx\", type, len, val);\n\n\topt->type = type;\n\topt->len  = len;\n\n\tswitch (len) {\n\tcase 1:\n\t\t*((u8 *) opt->val)  = val;\n\t\tbreak;\n\n\tcase 2:\n\t\t*((__le16 *) opt->val) = cpu_to_le16(val);\n\t\tbreak;\n\n\tcase 4:\n\t\t*((__le32 *) opt->val) = cpu_to_le32(val);\n\t\tbreak;\n\n\tdefault:\n\t\tmemcpy(opt->val, (void *) val, len);\n\t\tbreak;\n\t}\n\n\t*ptr += L2CAP_CONF_OPT_SIZE + len;\n}\n\nstatic int l2cap_mode_supported(__u8 mode, __u32 feat_mask)\n{\n\tu32 local_feat_mask = l2cap_feat_mask;\n\tif (enable_ertm)\n\t\tlocal_feat_mask |= L2CAP_FEAT_ERTM;\n\n\tswitch (mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\treturn L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}\n\nstatic inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)\n{\n\tswitch (mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (l2cap_mode_supported(mode, remote_feat_mask))\n\t\t\treturn mode;\n\t\t/* fall through */\n\tdefault:\n\t\treturn L2CAP_MODE_BASIC;\n\t}\n}\n\nstatic int l2cap_build_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_req *req = data;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_ERTM };\n\tvoid *ptr = req->data;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (pi->num_conf_req || pi->num_conf_rsp)\n\t\tgoto done;\n\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tpi->conf_state |= L2CAP_CONF_STATE2_DEVICE;\n\t\tif (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask)) {\n\t\t\tstruct l2cap_disconn_req req;\n\t\t\treq.dcid = cpu_to_le16(pi->dcid);\n\t\t\treq.scid = cpu_to_le16(pi->scid);\n\t\t\tl2cap_send_cmd(pi->conn, l2cap_get_ident(pi->conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);\n\t\tbreak;\n\t}\n\ndone:\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tif (pi->imtu != L2CAP_DEFAULT_MTU)\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\t\trfc.mode            = L2CAP_MODE_ERTM;\n\t\trfc.txwin_size      = L2CAP_DEFAULT_TX_WINDOW;\n\t\trfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;\n\t\trfc.retrans_timeout = 0;\n\t\trfc.monitor_timeout = 0;\n\t\trfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\tbreak;\n\n\tcase L2CAP_MODE_STREAMING:\n\t\trfc.mode            = L2CAP_MODE_STREAMING;\n\t\trfc.txwin_size      = 0;\n\t\trfc.max_transmit    = 0;\n\t\trfc.retrans_timeout = 0;\n\t\trfc.monitor_timeout = 0;\n\t\trfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\tbreak;\n\t}\n\n\t/* FIXME: Need actual value of the flush timeout */\n\t//if (flush_to != L2CAP_DEFAULT_FLUSH_TO)\n\t//   l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2, pi->flush_to);\n\n\treq->dcid  = cpu_to_le16(pi->dcid);\n\treq->flags = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_parse_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *req = pi->conf_req;\n\tint len = pi->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tpi->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen == sizeof(rfc))\n\t\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pi->num_conf_rsp || pi->num_conf_req)\n\t\tgoto done;\n\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tpi->conf_state |= L2CAP_CONF_STATE2_DEVICE;\n\t\tif (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))\n\t\t\treturn -ECONNREFUSED;\n\t\tbreak;\n\tdefault:\n\t\tpi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);\n\t\tbreak;\n\t}\n\ndone:\n\tif (pi->mode != rfc.mode) {\n\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\trfc.mode = pi->mode;\n\n\t\tif (pi->num_conf_rsp == 1)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t}\n\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\telse {\n\t\t\tpi->omtu = mtu;\n\t\t\tpi->conf_state |= L2CAP_CONF_MTU_DONE;\n\t\t}\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tpi->fcs = L2CAP_FCS_NONE;\n\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tpi->remote_tx_win = rfc.txwin_size;\n\t\t\tpi->remote_max_tx = rfc.max_transmit;\n\t\t\tpi->max_pdu_size = rfc.max_pdu_size;\n\n\t\t\trfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;\n\t\t\trfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;\n\n\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tpi->remote_tx_win = rfc.txwin_size;\n\t\t\tpi->max_pdu_size = rfc.max_pdu_size;\n\n\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = pi->mode;\n\t\t}\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\n\t\tif (result == L2CAP_CONF_SUCCESS)\n\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n\t}\n\trsp->scid   = cpu_to_le16(pi->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0x0000);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_parse_conf_rsp(struct sock *sk, void *rsp, int len, void *data, u16 *result)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_req *req = data;\n\tvoid *ptr = req->data;\n\tint type, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc;\n\n\tBT_DBG(\"sk %p, rsp %p, len %d, req %p\", sk, rsp, len, data);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (val < L2CAP_DEFAULT_MIN_MTU) {\n\t\t\t\t*result = L2CAP_CONF_UNACCEPT;\n\t\t\t\tpi->omtu = L2CAP_DEFAULT_MIN_MTU;\n\t\t\t} else\n\t\t\t\tpi->omtu = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tpi->flush_to = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,\n\t\t\t\t\t\t\t2, pi->flush_to);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen == sizeof(rfc))\n\t\t\t\tmemcpy(&rfc, (void *)val, olen);\n\n\t\t\tif ((pi->conf_state & L2CAP_CONF_STATE2_DEVICE) &&\n\t\t\t\t\t\t\trfc.mode != pi->mode)\n\t\t\t\treturn -ECONNREFUSED;\n\n\t\t\tpi->mode = rfc.mode;\n\t\t\tpi->fcs = 0;\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*result == L2CAP_CONF_SUCCESS) {\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tpi->remote_tx_win   = rfc.txwin_size;\n\t\t\tpi->retrans_timeout = rfc.retrans_timeout;\n\t\t\tpi->monitor_timeout = rfc.monitor_timeout;\n\t\t\tpi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);\n\t\t\tbreak;\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tpi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treq->dcid   = cpu_to_le16(pi->dcid);\n\treq->flags  = cpu_to_le16(0x0000);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_build_conf_rsp(struct sock *sk, void *data, u16 result, u16 flags)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\trsp->scid   = cpu_to_le16(l2cap_pi(sk)->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(flags);\n\n\treturn ptr - data;\n}\n\nstatic inline int l2cap_command_rej(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_cmd_rej *rej = (struct l2cap_cmd_rej *) data;\n\n\tif (rej->reason != 0x0000)\n\t\treturn 0;\n\n\tif ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&\n\t\t\t\t\tcmd->ident == conn->info_ident) {\n\t\tdel_timer(&conn->info_timer);\n\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_connect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_chan_list *list = &conn->chan_list;\n\tstruct l2cap_conn_req *req = (struct l2cap_conn_req *) data;\n\tstruct l2cap_conn_rsp rsp;\n\tstruct sock *sk, *parent;\n\tint result, status = L2CAP_CS_NO_INFO;\n\n\tu16 dcid = 0, scid = __le16_to_cpu(req->scid);\n\t__le16 psm = req->psm;\n\n\tBT_DBG(\"psm 0x%2.2x scid 0x%4.4x\", psm, scid);\n\n\t/* Check if we have socket listening on psm */\n\tparent = l2cap_get_sock_by_psm(BT_LISTEN, psm, conn->src);\n\tif (!parent) {\n\t\tresult = L2CAP_CR_BAD_PSM;\n\t\tgoto sendresp;\n\t}\n\n\t/* Check if the ACL is secure enough (if not SDP) */\n\tif (psm != cpu_to_le16(0x0001) &&\n\t\t\t\t!hci_conn_check_link_mode(conn->hcon)) {\n\t\tconn->disc_reason = 0x05;\n\t\tresult = L2CAP_CR_SEC_BLOCK;\n\t\tgoto response;\n\t}\n\n\tresult = L2CAP_CR_NO_MEM;\n\n\t/* Check for backlog size */\n\tif (sk_acceptq_is_full(parent)) {\n\t\tBT_DBG(\"backlog full %d\", parent->sk_ack_backlog);\n\t\tgoto response;\n\t}\n\n\tsk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP, GFP_ATOMIC);\n\tif (!sk)\n\t\tgoto response;\n\n\twrite_lock_bh(&list->lock);\n\n\t/* Check if we already have channel with that dcid */\n\tif (__l2cap_get_chan_by_dcid(list, scid)) {\n\t\twrite_unlock_bh(&list->lock);\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tl2cap_sock_kill(sk);\n\t\tgoto response;\n\t}\n\n\thci_conn_hold(conn->hcon);\n\n\tl2cap_sock_init(sk, parent);\n\tbacpy(&bt_sk(sk)->src, conn->src);\n\tbacpy(&bt_sk(sk)->dst, conn->dst);\n\tl2cap_pi(sk)->psm  = psm;\n\tl2cap_pi(sk)->dcid = scid;\n\n\t__l2cap_chan_add(conn, sk, parent);\n\tdcid = l2cap_pi(sk)->scid;\n\n\tl2cap_sock_set_timer(sk, sk->sk_sndtimeo);\n\n\tl2cap_pi(sk)->ident = cmd->ident;\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {\n\t\tif (l2cap_check_security(sk)) {\n\t\t\tif (bt_sk(sk)->defer_setup) {\n\t\t\t\tsk->sk_state = BT_CONNECT2;\n\t\t\t\tresult = L2CAP_CR_PEND;\n\t\t\t\tstatus = L2CAP_CS_AUTHOR_PEND;\n\t\t\t\tparent->sk_data_ready(parent, 0);\n\t\t\t} else {\n\t\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\t\tresult = L2CAP_CR_SUCCESS;\n\t\t\t\tstatus = L2CAP_CS_NO_INFO;\n\t\t\t}\n\t\t} else {\n\t\t\tsk->sk_state = BT_CONNECT2;\n\t\t\tresult = L2CAP_CR_PEND;\n\t\t\tstatus = L2CAP_CS_AUTHEN_PEND;\n\t\t}\n\t} else {\n\t\tsk->sk_state = BT_CONNECT2;\n\t\tresult = L2CAP_CR_PEND;\n\t\tstatus = L2CAP_CS_NO_INFO;\n\t}\n\n\twrite_unlock_bh(&list->lock);\n\nresponse:\n\tbh_unlock_sock(parent);\n\nsendresp:\n\trsp.scid   = cpu_to_le16(scid);\n\trsp.dcid   = cpu_to_le16(dcid);\n\trsp.result = cpu_to_le16(result);\n\trsp.status = cpu_to_le16(status);\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp);\n\n\tif (result == L2CAP_CR_PEND && status == L2CAP_CS_NO_INFO) {\n\t\tstruct l2cap_info_req info;\n\t\tinfo.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;\n\t\tconn->info_ident = l2cap_get_ident(conn);\n\n\t\tmod_timer(&conn->info_timer, jiffies +\n\t\t\t\t\tmsecs_to_jiffies(L2CAP_INFO_TIMEOUT));\n\n\t\tl2cap_send_cmd(conn, conn->info_ident,\n\t\t\t\t\tL2CAP_INFO_REQ, sizeof(info), &info);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;\n\tu16 scid, dcid, result, status;\n\tstruct sock *sk;\n\tu8 req[128];\n\n\tscid   = __le16_to_cpu(rsp->scid);\n\tdcid   = __le16_to_cpu(rsp->dcid);\n\tresult = __le16_to_cpu(rsp->result);\n\tstatus = __le16_to_cpu(rsp->status);\n\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x\", dcid, scid, result, status);\n\n\tif (scid) {\n\t\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\t\tif (!sk)\n\t\t\treturn 0;\n\t} else {\n\t\tsk = l2cap_get_chan_by_ident(&conn->chan_list, cmd->ident);\n\t\tif (!sk)\n\t\t\treturn 0;\n\t}\n\n\tswitch (result) {\n\tcase L2CAP_CR_SUCCESS:\n\t\tsk->sk_state = BT_CONFIG;\n\t\tl2cap_pi(sk)->ident = 0;\n\t\tl2cap_pi(sk)->dcid = dcid;\n\t\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;\n\n\t\tl2cap_pi(sk)->conf_state &= ~L2CAP_CONF_CONNECT_PEND;\n\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\tl2cap_pi(sk)->num_conf_req++;\n\t\tbreak;\n\n\tcase L2CAP_CR_PEND:\n\t\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_chan_del(sk, ECONNREFUSED);\n\t\tbreak;\n\t}\n\n\tbh_unlock_sock(sk);\n\treturn 0;\n}\n\nstatic inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct sock *sk;\n\tint len;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);\n\tif (!sk)\n\t\treturn -ENOENT;\n\n\tif (sk->sk_state == BT_DISCONN)\n\t\tgoto unlock;\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (l2cap_pi(sk)->conf_len + len > sizeof(l2cap_pi(sk)->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t\tl2cap_build_conf_rsp(sk, rsp,\n\t\t\t\t\tL2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(l2cap_pi(sk)->conf_req + l2cap_pi(sk)->conf_len, req->data, len);\n\tl2cap_pi(sk)->conf_len += len;\n\n\tif (flags & 0x0001) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t\tl2cap_build_conf_rsp(sk, rsp,\n\t\t\t\t\tL2CAP_CONF_SUCCESS, 0x0001), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Complete config. */\n\tlen = l2cap_parse_conf_req(sk, rsp);\n\tif (len < 0) {\n\t\tstruct l2cap_disconn_req req;\n\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\tgoto unlock;\n\t}\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n\tl2cap_pi(sk)->num_conf_rsp++;\n\n\t/* Reset config buffer. */\n\tl2cap_pi(sk)->conf_len = 0;\n\n\tif (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE))\n\t\tgoto unlock;\n\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t\tgoto unlock;\n\t}\n\n\tif (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT)) {\n\t\tu8 buf[64];\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\tl2cap_build_conf_req(sk, buf), buf);\n\t\tl2cap_pi(sk)->num_conf_req++;\n\t}\n\nunlock:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}\n\nstatic inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\n\tu16 scid, flags, result;\n\tstruct sock *sk;\n\n\tscid   = __le16_to_cpu(rsp->scid);\n\tflags  = __le16_to_cpu(rsp->flags);\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x\",\n\t\t\tscid, flags, result);\n\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\tif (!sk)\n\t\treturn 0;\n\n\tswitch (result) {\n\tcase L2CAP_CONF_SUCCESS:\n\t\tbreak;\n\n\tcase L2CAP_CONF_UNACCEPT:\n\t\tif (l2cap_pi(sk)->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {\n\t\t\tint len = cmd->len - sizeof(*rsp);\n\t\t\tchar req[64];\n\n\t\t\t/* throw out any old stored conf requests */\n\t\t\tresult = L2CAP_CONF_SUCCESS;\n\t\t\tlen = l2cap_parse_conf_rsp(sk, rsp->data,\n\t\t\t\t\t\t\tlen, req, &result);\n\t\t\tif (len < 0) {\n\t\t\t\tstruct l2cap_disconn_req req;\n\t\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\t\tL2CAP_CONF_REQ, len, req);\n\t\t\tl2cap_pi(sk)->num_conf_req++;\n\t\t\tif (result != L2CAP_CONF_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tsk->sk_state = BT_DISCONN;\n\t\tsk->sk_err = ECONNRESET;\n\t\tl2cap_sock_set_timer(sk, HZ * 5);\n\t\t{\n\t\t\tstruct l2cap_disconn_req req;\n\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tif (flags & 0x01)\n\t\tgoto done;\n\n\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_INPUT_DONE;\n\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t}\n\ndone:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}\n\nstatic inline int l2cap_disconnect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;\n\tstruct l2cap_disconn_rsp rsp;\n\tu16 dcid, scid;\n\tstruct sock *sk;\n\n\tscid = __le16_to_cpu(req->scid);\n\tdcid = __le16_to_cpu(req->dcid);\n\n\tBT_DBG(\"scid 0x%4.4x dcid 0x%4.4x\", scid, dcid);\n\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);\n\tif (!sk)\n\t\treturn 0;\n\n\trsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);\n\trsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);\n\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\n\tl2cap_chan_del(sk, ECONNRESET);\n\tbh_unlock_sock(sk);\n\n\tl2cap_sock_kill(sk);\n\treturn 0;\n}\n\nstatic inline int l2cap_disconnect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;\n\tu16 dcid, scid;\n\tstruct sock *sk;\n\n\tscid = __le16_to_cpu(rsp->scid);\n\tdcid = __le16_to_cpu(rsp->dcid);\n\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x\", dcid, scid);\n\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\tif (!sk)\n\t\treturn 0;\n\n\tl2cap_chan_del(sk, 0);\n\tbh_unlock_sock(sk);\n\n\tl2cap_sock_kill(sk);\n\treturn 0;\n}\n\nstatic inline int l2cap_information_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_info_req *req = (struct l2cap_info_req *) data;\n\tu16 type;\n\n\ttype = __le16_to_cpu(req->type);\n\n\tBT_DBG(\"type 0x%4.4x\", type);\n\n\tif (type == L2CAP_IT_FEAT_MASK) {\n\t\tu8 buf[8];\n\t\tu32 feat_mask = l2cap_feat_mask;\n\t\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;\n\t\trsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\t\trsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);\n\t\tif (enable_ertm)\n\t\t\tfeat_mask |= L2CAP_FEAT_ERTM;\n\t\tput_unaligned(cpu_to_le32(feat_mask), (__le32 *) rsp->data);\n\t\tl2cap_send_cmd(conn, cmd->ident,\n\t\t\t\t\tL2CAP_INFO_RSP, sizeof(buf), buf);\n\t} else if (type == L2CAP_IT_FIXED_CHAN) {\n\t\tu8 buf[12];\n\t\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;\n\t\trsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);\n\t\trsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);\n\t\tmemcpy(buf + 4, l2cap_fixed_chan, 8);\n\t\tl2cap_send_cmd(conn, cmd->ident,\n\t\t\t\t\tL2CAP_INFO_RSP, sizeof(buf), buf);\n\t} else {\n\t\tstruct l2cap_info_rsp rsp;\n\t\trsp.type   = cpu_to_le16(type);\n\t\trsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);\n\t\tl2cap_send_cmd(conn, cmd->ident,\n\t\t\t\t\tL2CAP_INFO_RSP, sizeof(rsp), &rsp);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_information_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;\n\tu16 type, result;\n\n\ttype   = __le16_to_cpu(rsp->type);\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"type 0x%4.4x result 0x%2.2x\", type, result);\n\n\tdel_timer(&conn->info_timer);\n\n\tif (type == L2CAP_IT_FEAT_MASK) {\n\t\tconn->feat_mask = get_unaligned_le32(rsp->data);\n\n\t\tif (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {\n\t\t\tstruct l2cap_info_req req;\n\t\t\treq.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);\n\n\t\t\tconn->info_ident = l2cap_get_ident(conn);\n\n\t\t\tl2cap_send_cmd(conn, conn->info_ident,\n\t\t\t\t\tL2CAP_INFO_REQ, sizeof(req), &req);\n\t\t} else {\n\t\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\t\tconn->info_ident = 0;\n\n\t\t\tl2cap_conn_start(conn);\n\t\t}\n\t} else if (type == L2CAP_IT_FIXED_CHAN) {\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\t}\n\n\treturn 0;\n}\n\nstatic inline void l2cap_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tu8 *data = skb->data;\n\tint len = skb->len;\n\tstruct l2cap_cmd_hdr cmd;\n\tint err = 0;\n\n\tl2cap_raw_recv(conn, skb);\n\n\twhile (len >= L2CAP_CMD_HDR_SIZE) {\n\t\tu16 cmd_len;\n\t\tmemcpy(&cmd, data, L2CAP_CMD_HDR_SIZE);\n\t\tdata += L2CAP_CMD_HDR_SIZE;\n\t\tlen  -= L2CAP_CMD_HDR_SIZE;\n\n\t\tcmd_len = le16_to_cpu(cmd.len);\n\n\t\tBT_DBG(\"code 0x%2.2x len %d id 0x%2.2x\", cmd.code, cmd_len, cmd.ident);\n\n\t\tif (cmd_len > len || !cmd.ident) {\n\t\t\tBT_DBG(\"corrupted command\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (cmd.code) {\n\t\tcase L2CAP_COMMAND_REJ:\n\t\t\tl2cap_command_rej(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONN_REQ:\n\t\t\terr = l2cap_connect_req(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONN_RSP:\n\t\t\terr = l2cap_connect_rsp(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_REQ:\n\t\t\terr = l2cap_config_req(conn, &cmd, cmd_len, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RSP:\n\t\t\terr = l2cap_config_rsp(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_DISCONN_REQ:\n\t\t\terr = l2cap_disconnect_req(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_DISCONN_RSP:\n\t\t\terr = l2cap_disconnect_rsp(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_ECHO_REQ:\n\t\t\tl2cap_send_cmd(conn, cmd.ident, L2CAP_ECHO_RSP, cmd_len, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_ECHO_RSP:\n\t\t\tbreak;\n\n\t\tcase L2CAP_INFO_REQ:\n\t\t\terr = l2cap_information_req(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tcase L2CAP_INFO_RSP:\n\t\t\terr = l2cap_information_rsp(conn, &cmd, data);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBT_ERR(\"Unknown signaling command 0x%2.2x\", cmd.code);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err) {\n\t\t\tstruct l2cap_cmd_rej rej;\n\t\t\tBT_DBG(\"error %d\", err);\n\n\t\t\t/* FIXME: Map err to a valid reason */\n\t\t\trej.reason = cpu_to_le16(0);\n\t\t\tl2cap_send_cmd(conn, cmd.ident, L2CAP_COMMAND_REJ, sizeof(rej), &rej);\n\t\t}\n\n\t\tdata += cmd_len;\n\t\tlen  -= cmd_len;\n\t}\n\n\tkfree_skb(skb);\n}\n\nstatic inline int l2cap_data_channel(struct l2cap_conn *conn, u16 cid, struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, cid);\n\tif (!sk) {\n\t\tBT_DBG(\"unknown cid 0x%4.4x\", cid);\n\t\tgoto drop;\n\t}\n\n\tBT_DBG(\"sk %p, len %d\", sk, skb->len);\n\n\tif (sk->sk_state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tif (l2cap_pi(sk)->imtu < skb->len)\n\t\tgoto drop;\n\n\t/* If socket recv buffers overflows we drop data here\n\t * which is *bad* because L2CAP has to be reliable.\n\t * But we don't have any other choice. L2CAP doesn't\n\t * provide flow control mechanism. */\n\n\tif (!sock_queue_rcv_skb(sk, skb))\n\t\tgoto done;\n\ndrop:\n\tkfree_skb(skb);\n\ndone:\n\tif (sk)\n\t\tbh_unlock_sock(sk);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_conless_channel(struct l2cap_conn *conn, __le16 psm, struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\n\tsk = l2cap_get_sock_by_psm(0, psm, conn->src);\n\tif (!sk)\n\t\tgoto drop;\n\n\tBT_DBG(\"sk %p, len %d\", sk, skb->len);\n\n\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tif (l2cap_pi(sk)->imtu < skb->len)\n\t\tgoto drop;\n\n\tif (!sock_queue_rcv_skb(sk, skb))\n\t\tgoto done;\n\ndrop:\n\tkfree_skb(skb);\n\ndone:\n\tif (sk)\n\t\tbh_unlock_sock(sk);\n\treturn 0;\n}\n\nstatic void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct l2cap_hdr *lh = (void *) skb->data;\n\tu16 cid, len;\n\t__le16 psm;\n\n\tskb_pull(skb, L2CAP_HDR_SIZE);\n\tcid = __le16_to_cpu(lh->cid);\n\tlen = __le16_to_cpu(lh->len);\n\n\tBT_DBG(\"len %d, cid 0x%4.4x\", len, cid);\n\n\tswitch (cid) {\n\tcase L2CAP_CID_SIGNALING:\n\t\tl2cap_sig_channel(conn, skb);\n\t\tbreak;\n\n\tcase L2CAP_CID_CONN_LESS:\n\t\tpsm = get_unaligned((__le16 *) skb->data);\n\t\tskb_pull(skb, 2);\n\t\tl2cap_conless_channel(conn, psm, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_data_channel(conn, cid, skb);\n\t\tbreak;\n\t}\n}\n\n/* ---- L2CAP interface with lower layer (HCI) ---- */\n\nstatic int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)\n{\n\tint exact = 0, lm1 = 0, lm2 = 0;\n\tregister struct sock *sk;\n\tstruct hlist_node *node;\n\n\tif (type != ACL_LINK)\n\t\treturn 0;\n\n\tBT_DBG(\"hdev %s, bdaddr %s\", hdev->name, batostr(bdaddr));\n\n\t/* Find listening sockets and check their link_mode */\n\tread_lock(&l2cap_sk_list.lock);\n\tsk_for_each(sk, node, &l2cap_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr)) {\n\t\t\tlm1 |= HCI_LM_ACCEPT;\n\t\t\tif (l2cap_pi(sk)->role_switch)\n\t\t\t\tlm1 |= HCI_LM_MASTER;\n\t\t\texact++;\n\t\t} else if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {\n\t\t\tlm2 |= HCI_LM_ACCEPT;\n\t\t\tif (l2cap_pi(sk)->role_switch)\n\t\t\t\tlm2 |= HCI_LM_MASTER;\n\t\t}\n\t}\n\tread_unlock(&l2cap_sk_list.lock);\n\n\treturn exact ? lm1 : lm2;\n}\n\nstatic int l2cap_connect_cfm(struct hci_conn *hcon, u8 status)\n{\n\tstruct l2cap_conn *conn;\n\n\tBT_DBG(\"hcon %p bdaddr %s status %d\", hcon, batostr(&hcon->dst), status);\n\n\tif (hcon->type != ACL_LINK)\n\t\treturn 0;\n\n\tif (!status) {\n\t\tconn = l2cap_conn_add(hcon, status);\n\t\tif (conn)\n\t\t\tl2cap_conn_ready(conn);\n\t} else\n\t\tl2cap_conn_del(hcon, bt_err(status));\n\n\treturn 0;\n}\n\nstatic int l2cap_disconn_ind(struct hci_conn *hcon)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\n\tBT_DBG(\"hcon %p\", hcon);\n\n\tif (hcon->type != ACL_LINK || !conn)\n\t\treturn 0x13;\n\n\treturn conn->disc_reason;\n}\n\nstatic int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason)\n{\n\tBT_DBG(\"hcon %p reason %d\", hcon, reason);\n\n\tif (hcon->type != ACL_LINK)\n\t\treturn 0;\n\n\tl2cap_conn_del(hcon, bt_err(reason));\n\n\treturn 0;\n}\n\nstatic inline void l2cap_check_encryption(struct sock *sk, u8 encrypt)\n{\n\tif (sk->sk_type != SOCK_SEQPACKET)\n\t\treturn;\n\n\tif (encrypt == 0x00) {\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM) {\n\t\t\tl2cap_sock_clear_timer(sk);\n\t\t\tl2cap_sock_set_timer(sk, HZ * 5);\n\t\t} else if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH)\n\t\t\t__l2cap_sock_close(sk, ECONNREFUSED);\n\t} else {\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM)\n\t\t\tl2cap_sock_clear_timer(sk);\n\t}\n}\n\nstatic int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)\n{\n\tstruct l2cap_chan_list *l;\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct sock *sk;\n\n\tif (!conn)\n\t\treturn 0;\n\n\tl = &conn->chan_list;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tbh_lock_sock(sk);\n\n\t\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_CONNECT_PEND) {\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && (sk->sk_state == BT_CONNECTED ||\n\t\t\t\t\t\tsk->sk_state == BT_CONFIG)) {\n\t\t\tl2cap_check_encryption(sk, encrypt);\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk->sk_state == BT_CONNECT) {\n\t\t\tif (!status) {\n\t\t\t\tstruct l2cap_conn_req req;\n\t\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\t\treq.psm  = l2cap_pi(sk)->psm;\n\n\t\t\t\tl2cap_pi(sk)->ident = l2cap_get_ident(conn);\n\n\t\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_REQ, sizeof(req), &req);\n\t\t\t} else {\n\t\t\t\tl2cap_sock_clear_timer(sk);\n\t\t\t\tl2cap_sock_set_timer(sk, HZ / 10);\n\t\t\t}\n\t\t} else if (sk->sk_state == BT_CONNECT2) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\t__u16 result;\n\n\t\t\tif (!status) {\n\t\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\t\tresult = L2CAP_CR_SUCCESS;\n\t\t\t} else {\n\t\t\t\tsk->sk_state = BT_DISCONN;\n\t\t\t\tl2cap_sock_set_timer(sk, HZ / 10);\n\t\t\t\tresult = L2CAP_CR_SEC_BLOCK;\n\t\t\t}\n\n\t\t\trsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\trsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\trsp.result = cpu_to_le16(result);\n\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_RSP, sizeof(rsp), &rsp);\n\t\t}\n\n\t\tbh_unlock_sock(sk);\n\t}\n\n\tread_unlock(&l->lock);\n\n\treturn 0;\n}\n\nstatic int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\n\tif (!conn && !(conn = l2cap_conn_add(hcon, 0)))\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %d flags 0x%x\", conn, skb->len, flags);\n\n\tif (flags & ACL_START) {\n\t\tstruct l2cap_hdr *hdr;\n\t\tint len;\n\n\t\tif (conn->rx_len) {\n\t\t\tBT_ERR(\"Unexpected start frame (len %d)\", skb->len);\n\t\t\tkfree_skb(conn->rx_skb);\n\t\t\tconn->rx_skb = NULL;\n\t\t\tconn->rx_len = 0;\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t}\n\n\t\tif (skb->len < 2) {\n\t\t\tBT_ERR(\"Frame is too short (len %d)\", skb->len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\thdr = (struct l2cap_hdr *) skb->data;\n\t\tlen = __le16_to_cpu(hdr->len) + L2CAP_HDR_SIZE;\n\n\t\tif (len == skb->len) {\n\t\t\t/* Complete frame received */\n\t\t\tl2cap_recv_frame(conn, skb);\n\t\t\treturn 0;\n\t\t}\n\n\t\tBT_DBG(\"Start: total len %d, frag len %d\", len, skb->len);\n\n\t\tif (skb->len > len) {\n\t\t\tBT_ERR(\"Frame is too long (len %d, expected len %d)\",\n\t\t\t\tskb->len, len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Allocate skb for the complete frame (with header) */\n\t\tconn->rx_skb = bt_skb_alloc(len, GFP_ATOMIC);\n\t\tif (!conn->rx_skb)\n\t\t\tgoto drop;\n\n\t\tskb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),\n\t\t\t\t\t\t\t\tskb->len);\n\t\tconn->rx_len = len - skb->len;\n\t} else {\n\t\tBT_DBG(\"Cont: frag len %d (expecting %d)\", skb->len, conn->rx_len);\n\n\t\tif (!conn->rx_len) {\n\t\t\tBT_ERR(\"Unexpected continuation frame (len %d)\", skb->len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (skb->len > conn->rx_len) {\n\t\t\tBT_ERR(\"Fragment is too long (len %d, expected %d)\",\n\t\t\t\t\tskb->len, conn->rx_len);\n\t\t\tkfree_skb(conn->rx_skb);\n\t\t\tconn->rx_skb = NULL;\n\t\t\tconn->rx_len = 0;\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tskb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),\n\t\t\t\t\t\t\t\tskb->len);\n\t\tconn->rx_len -= skb->len;\n\n\t\tif (!conn->rx_len) {\n\t\t\t/* Complete frame received */\n\t\t\tl2cap_recv_frame(conn, conn->rx_skb);\n\t\t\tconn->rx_skb = NULL;\n\t\t}\n\t}\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic ssize_t l2cap_sysfs_show(struct class *dev, char *buf)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\tchar *str = buf;\n\n\tread_lock_bh(&l2cap_sk_list.lock);\n\n\tsk_for_each(sk, node, &l2cap_sk_list.head) {\n\t\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\n\t\tstr += sprintf(str, \"%s %s %d %d 0x%4.4x 0x%4.4x %d %d %d\\n\",\n\t\t\t\tbatostr(&bt_sk(sk)->src), batostr(&bt_sk(sk)->dst),\n\t\t\t\tsk->sk_state, __le16_to_cpu(pi->psm), pi->scid,\n\t\t\t\tpi->dcid, pi->imtu, pi->omtu, pi->sec_level);\n\t}\n\n\tread_unlock_bh(&l2cap_sk_list.lock);\n\n\treturn str - buf;\n}\n\nstatic CLASS_ATTR(l2cap, S_IRUGO, l2cap_sysfs_show, NULL);\n\nstatic const struct proto_ops l2cap_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= l2cap_sock_release,\n\t.bind\t\t= l2cap_sock_bind,\n\t.connect\t= l2cap_sock_connect,\n\t.listen\t\t= l2cap_sock_listen,\n\t.accept\t\t= l2cap_sock_accept,\n\t.getname\t= l2cap_sock_getname,\n\t.sendmsg\t= l2cap_sock_sendmsg,\n\t.recvmsg\t= l2cap_sock_recvmsg,\n\t.poll\t\t= bt_sock_poll,\n\t.ioctl\t\t= bt_sock_ioctl,\n\t.mmap\t\t= sock_no_mmap,\n\t.socketpair\t= sock_no_socketpair,\n\t.shutdown\t= l2cap_sock_shutdown,\n\t.setsockopt\t= l2cap_sock_setsockopt,\n\t.getsockopt\t= l2cap_sock_getsockopt\n};\n\nstatic struct net_proto_family l2cap_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= l2cap_sock_create,\n};\n\nstatic struct hci_proto l2cap_hci_proto = {\n\t.name\t\t= \"L2CAP\",\n\t.id\t\t= HCI_PROTO_L2CAP,\n\t.connect_ind\t= l2cap_connect_ind,\n\t.connect_cfm\t= l2cap_connect_cfm,\n\t.disconn_ind\t= l2cap_disconn_ind,\n\t.disconn_cfm\t= l2cap_disconn_cfm,\n\t.security_cfm\t= l2cap_security_cfm,\n\t.recv_acldata\t= l2cap_recv_acldata\n};\n\nstatic int __init l2cap_init(void)\n{\n\tint err;\n\n\terr = proto_register(&l2cap_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_L2CAP, &l2cap_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"L2CAP socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = hci_register_proto(&l2cap_hci_proto);\n\tif (err < 0) {\n\t\tBT_ERR(\"L2CAP protocol registration failed\");\n\t\tbt_sock_unregister(BTPROTO_L2CAP);\n\t\tgoto error;\n\t}\n\n\tif (class_create_file(bt_class, &class_attr_l2cap) < 0)\n\t\tBT_ERR(\"Failed to create L2CAP info file\");\n\n\tBT_INFO(\"L2CAP ver %s\", VERSION);\n\tBT_INFO(\"L2CAP socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&l2cap_proto);\n\treturn err;\n}\n\nstatic void __exit l2cap_exit(void)\n{\n\tclass_remove_file(bt_class, &class_attr_l2cap);\n\n\tif (bt_sock_unregister(BTPROTO_L2CAP) < 0)\n\t\tBT_ERR(\"L2CAP socket unregistration failed\");\n\n\tif (hci_unregister_proto(&l2cap_hci_proto) < 0)\n\t\tBT_ERR(\"L2CAP protocol unregistration failed\");\n\n\tproto_unregister(&l2cap_proto);\n}\n\nvoid l2cap_load(void)\n{\n\t/* Dummy function to trigger automatic L2CAP module loading by\n\t * other modules that use L2CAP sockets but don't use any other\n\t * symbols from it. */\n\treturn;\n}\nEXPORT_SYMBOL(l2cap_load);\n\nmodule_init(l2cap_init);\nmodule_exit(l2cap_exit);\n\nmodule_param(enable_ertm, bool, 0644);\nMODULE_PARM_DESC(enable_ertm, \"Enable enhanced retransmission mode\");\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth L2CAP ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"bt-proto-0\");\n"], "buggy_code_start_loc": [29, 968], "buggy_code_end_loc": [300, 2163], "fixing_code_start_loc": [30, 969], "fixing_code_end_loc": [314, 2369], "type": "CWE-787", "message": "The native Bluetooth stack in the Linux Kernel (BlueZ), starting at the Linux kernel version 2.6.32 and up to and including 4.13.1, are vulnerable to a stack overflow vulnerability in the processing of L2CAP configuration responses resulting in Remote code execution in kernel space.", "other": {"cve": {"id": "CVE-2017-1000251", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-12T17:29:00.227", "lastModified": "2023-01-19T15:53:39.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The native Bluetooth stack in the Linux Kernel (BlueZ), starting at the Linux kernel version 2.6.32 and up to and including 4.13.1, are vulnerable to a stack overflow vulnerability in the processing of L2CAP configuration responses resulting in Remote code execution in kernel space."}, {"lang": "es", "value": "La pila Bluetooth nativa en el Kernel Linux (BlueZ), comenzando por la versi\u00f3n 2.6.32 del kernel de Linux y hasta, e incluyendo, la versi\u00f3n 4.13.1, es vulnerable a un desbordamiento de pila durante el procesado de las respuestas de configuraci\u00f3n L2CAP, lo que desemboca en la ejecuci\u00f3n remota de c\u00f3digo en el espacio del kernel."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:C/I:C/A:C", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.7}, "baseSeverity": "HIGH", "exploitabilityScore": 5.1, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": true, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.32", "versionEndExcluding": "3.2.94", "matchCriteriaId": "6085F01E-A338-4BD7-84E5-A0D347E18EDD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.16.49", "matchCriteriaId": "6D2B2AB6-A208-4834-8CF4-03EF0774B915"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.71", "matchCriteriaId": "DCD26AC7-E8BD-470E-9B64-EC9974B7DFEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.45", "matchCriteriaId": "AEF05B4A-F2FD-4E86-9798-F55AAD1C1C61"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.88", "matchCriteriaId": "7B9D9F07-3E93-4948-8810-AA3D7F5ACE4D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.50", "matchCriteriaId": "311D0EBE-84B3-4494-97BA-BBF5ADEC1D29"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.12.13", "matchCriteriaId": "75C09DA2-9A56-432C-91E8-779AE07084A7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.13", "versionEndExcluding": "4.13.2", "matchCriteriaId": "84B83CE7-CB2C-4FA6-B05A-BAAABD64C797"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nvidia:jetson_tk1:r21:*:*:*:*:*:*:*", "matchCriteriaId": "C1302746-9142-4546-B47A-7C78BD4A59AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nvidia:jetson_tk1:r24:*:*:*:*:*:*:*", "matchCriteriaId": "5C577191-AB9A-4E68-92D3-FCF567F191F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nvidia:jetson_tx1:r21:*:*:*:*:*:*:*", "matchCriteriaId": "5A8F5385-9C27-4DB0-88F6-3B41FEC6C170"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nvidia:jetson_tx1:r24:*:*:*:*:*:*:*", "matchCriteriaId": "5CC78F5C-FC3E-403A-94C6-ED43D4E66D3C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.2:*:*:*:*:*:*:*", "matchCriteriaId": "AD6D0378-F0F4-4AAA-80AF-8287C790EC96"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.4:*:*:*:*:*:*:*", "matchCriteriaId": "AF83BB87-B203-48F9-9D06-48A5FE399050"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "16E6D998-B41D-4B49-9E00-8336D2E40A4A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "1C8D871B-AEA1-4407-AEE3-47EC782250FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "7431ABC1-9252-419E-8CC1-311B41360078"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:6.7:*:*:*:*:*:*:*", "matchCriteriaId": "6C81647C-9A53-481D-A54C-36770A093F90"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "44B067C7-735E-43C9-9188-7E1522A02491"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "A8442C20-41F9-47FD-9A12-E724D3A31FD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "21690BAC-2129-4A33-9B48-1F3BF30072A9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:6.5:*:*:*:*:*:*:*", "matchCriteriaId": "835AE071-CEAE-49E5-8F0C-E5F50FB85EFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "13E02156-E748-4820-B76F-7074793837E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "6755B6AD-0422-467B-8115-34A60B1D1A40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D5F7E11E-FB34-4467-8919-2B6BEAABF665"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "17F256A9-D3B9-4C72-B013-4EFD878BFEA8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://nvidia.custhelp.com/app/answers/detail/a_id/4561", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3981", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/100809", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1039373", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2679", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2680", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2681", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2682", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2683", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2704", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2705", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2706", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2707", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2731", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2732", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/security/vulnerabilities/blueborne", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.armis.com/blueborne", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/42762/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.kb.cert.org/vuls/id/240311", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "US Government Resource"]}, {"url": "https://www.synology.com/support/security/Synology_SA_17_52_BlueBorne", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe"}}