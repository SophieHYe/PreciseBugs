{"buggy_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tDefinitions for the TCP module.\n *\n * Version:\t@(#)tcp.h\t1.0.5\t05/23/93\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n */\n#ifndef _TCP_H\n#define _TCP_H\n\n#define FASTRETRANS_DEBUG 1\n\n#include <linux/list.h>\n#include <linux/tcp.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/cryptohash.h>\n#include <linux/kref.h>\n#include <linux/ktime.h>\n\n#include <net/inet_connection_sock.h>\n#include <net/inet_timewait_sock.h>\n#include <net/inet_hashtables.h>\n#include <net/checksum.h>\n#include <net/request_sock.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n#include <net/ip.h>\n#include <net/tcp_states.h>\n#include <net/inet_ecn.h>\n#include <net/dst.h>\n\n#include <linux/seq_file.h>\n#include <linux/memcontrol.h>\n\nextern struct inet_hashinfo tcp_hashinfo;\n\nextern struct percpu_counter tcp_orphan_count;\nvoid tcp_time_wait(struct sock *sk, int state, int timeo);\n\n#define MAX_TCP_HEADER\t(128 + MAX_HEADER)\n#define MAX_TCP_OPTION_SPACE 40\n\n/*\n * Never offer a window over 32767 without using window scaling. Some\n * poor stacks do signed 16bit maths!\n */\n#define MAX_TCP_WINDOW\t\t32767U\n\n/* Minimal accepted MSS. It is (60+60+8) - (20+20). */\n#define TCP_MIN_MSS\t\t88U\n\n/* The least MTU to use for probing */\n#define TCP_BASE_MSS\t\t1024\n\n/* probing interval, default to 10 minutes as per RFC4821 */\n#define TCP_PROBE_INTERVAL\t600\n\n/* Specify interval when tcp mtu probing will stop */\n#define TCP_PROBE_THRESHOLD\t8\n\n/* After receiving this amount of duplicate ACKs fast retransmit starts. */\n#define TCP_FASTRETRANS_THRESH 3\n\n/* Maximal number of ACKs sent quickly to accelerate slow-start. */\n#define TCP_MAX_QUICKACKS\t16U\n\n/* urg_data states */\n#define TCP_URG_VALID\t0x0100\n#define TCP_URG_NOTYET\t0x0200\n#define TCP_URG_READ\t0x0400\n\n#define TCP_RETR1\t3\t/*\n\t\t\t\t * This is how many retries it does before it\n\t\t\t\t * tries to figure out if the gateway is\n\t\t\t\t * down. Minimal RFC value is 3; it corresponds\n\t\t\t\t * to ~3sec-8min depending on RTO.\n\t\t\t\t */\n\n#define TCP_RETR2\t15\t/*\n\t\t\t\t * This should take at least\n\t\t\t\t * 90 minutes to time out.\n\t\t\t\t * RFC1122 says that the limit is 100 sec.\n\t\t\t\t * 15 is ~13-30min depending on RTO.\n\t\t\t\t */\n\n#define TCP_SYN_RETRIES\t 6\t/* This is how many retries are done\n\t\t\t\t * when active opening a connection.\n\t\t\t\t * RFC1122 says the minimum retry MUST\n\t\t\t\t * be at least 180secs.  Nevertheless\n\t\t\t\t * this value is corresponding to\n\t\t\t\t * 63secs of retransmission with the\n\t\t\t\t * current initial RTO.\n\t\t\t\t */\n\n#define TCP_SYNACK_RETRIES 5\t/* This is how may retries are done\n\t\t\t\t * when passive opening a connection.\n\t\t\t\t * This is corresponding to 31secs of\n\t\t\t\t * retransmission with the current\n\t\t\t\t * initial RTO.\n\t\t\t\t */\n\n#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT\n\t\t\t\t  * state, about 60 seconds\t*/\n#define TCP_FIN_TIMEOUT\tTCP_TIMEWAIT_LEN\n                                 /* BSD style FIN_WAIT2 deadlock breaker.\n\t\t\t\t  * It used to be 3min, new value is 60sec,\n\t\t\t\t  * to combine FIN-WAIT-2 timeout with\n\t\t\t\t  * TIME-WAIT timer.\n\t\t\t\t  */\n\n#define TCP_DELACK_MAX\t((unsigned)(HZ/5))\t/* maximal time to delay before sending an ACK */\n#if HZ >= 100\n#define TCP_DELACK_MIN\t((unsigned)(HZ/25))\t/* minimal time to delay before sending an ACK */\n#define TCP_ATO_MIN\t((unsigned)(HZ/25))\n#else\n#define TCP_DELACK_MIN\t4U\n#define TCP_ATO_MIN\t4U\n#endif\n#define TCP_RTO_MAX\t((unsigned)(120*HZ))\n#define TCP_RTO_MIN\t((unsigned)(HZ/5))\n#define TCP_TIMEOUT_INIT ((unsigned)(1*HZ))\t/* RFC6298 2.1 initial RTO value\t*/\n#define TCP_TIMEOUT_FALLBACK ((unsigned)(3*HZ))\t/* RFC 1122 initial RTO value, now\n\t\t\t\t\t\t * used as a fallback RTO for the\n\t\t\t\t\t\t * initial data transmission if no\n\t\t\t\t\t\t * valid RTT sample has been acquired,\n\t\t\t\t\t\t * most likely due to retrans in 3WHS.\n\t\t\t\t\t\t */\n\n#define TCP_RESOURCE_PROBE_INTERVAL ((unsigned)(HZ/2U)) /* Maximal interval between probes\n\t\t\t\t\t                 * for local resources.\n\t\t\t\t\t                 */\n\n#define TCP_KEEPALIVE_TIME\t(120*60*HZ)\t/* two hours */\n#define TCP_KEEPALIVE_PROBES\t9\t\t/* Max of 9 keepalive probes\t*/\n#define TCP_KEEPALIVE_INTVL\t(75*HZ)\n\n#define MAX_TCP_KEEPIDLE\t32767\n#define MAX_TCP_KEEPINTVL\t32767\n#define MAX_TCP_KEEPCNT\t\t127\n#define MAX_TCP_SYNCNT\t\t127\n\n#define TCP_SYNQ_INTERVAL\t(HZ/5)\t/* Period of SYNACK timer */\n\n#define TCP_PAWS_24DAYS\t(60 * 60 * 24 * 24)\n#define TCP_PAWS_MSL\t60\t\t/* Per-host timestamps are invalidated\n\t\t\t\t\t * after this time. It should be equal\n\t\t\t\t\t * (or greater than) TCP_TIMEWAIT_LEN\n\t\t\t\t\t * to provide reliability equal to one\n\t\t\t\t\t * provided by timewait state.\n\t\t\t\t\t */\n#define TCP_PAWS_WINDOW\t1\t\t/* Replay window for per-host\n\t\t\t\t\t * timestamps. It must be less than\n\t\t\t\t\t * minimal timewait lifetime.\n\t\t\t\t\t */\n/*\n *\tTCP option\n */\n\n#define TCPOPT_NOP\t\t1\t/* Padding */\n#define TCPOPT_EOL\t\t0\t/* End of options */\n#define TCPOPT_MSS\t\t2\t/* Segment size negotiating */\n#define TCPOPT_WINDOW\t\t3\t/* Window scaling */\n#define TCPOPT_SACK_PERM        4       /* SACK Permitted */\n#define TCPOPT_SACK             5       /* SACK Block */\n#define TCPOPT_TIMESTAMP\t8\t/* Better RTT estimations/PAWS */\n#define TCPOPT_MD5SIG\t\t19\t/* MD5 Signature (RFC2385) */\n#define TCPOPT_FASTOPEN\t\t34\t/* Fast open (RFC7413) */\n#define TCPOPT_EXP\t\t254\t/* Experimental */\n/* Magic number to be after the option value for sharing TCP\n * experimental options. See draft-ietf-tcpm-experimental-options-00.txt\n */\n#define TCPOPT_FASTOPEN_MAGIC\t0xF989\n\n/*\n *     TCP option lengths\n */\n\n#define TCPOLEN_MSS            4\n#define TCPOLEN_WINDOW         3\n#define TCPOLEN_SACK_PERM      2\n#define TCPOLEN_TIMESTAMP      10\n#define TCPOLEN_MD5SIG         18\n#define TCPOLEN_FASTOPEN_BASE  2\n#define TCPOLEN_EXP_FASTOPEN_BASE  4\n\n/* But this is what stacks really send out. */\n#define TCPOLEN_TSTAMP_ALIGNED\t\t12\n#define TCPOLEN_WSCALE_ALIGNED\t\t4\n#define TCPOLEN_SACKPERM_ALIGNED\t4\n#define TCPOLEN_SACK_BASE\t\t2\n#define TCPOLEN_SACK_BASE_ALIGNED\t4\n#define TCPOLEN_SACK_PERBLOCK\t\t8\n#define TCPOLEN_MD5SIG_ALIGNED\t\t20\n#define TCPOLEN_MSS_ALIGNED\t\t4\n\n/* Flags in tp->nonagle */\n#define TCP_NAGLE_OFF\t\t1\t/* Nagle's algo is disabled */\n#define TCP_NAGLE_CORK\t\t2\t/* Socket is corked\t    */\n#define TCP_NAGLE_PUSH\t\t4\t/* Cork is overridden for already queued data */\n\n/* TCP thin-stream limits */\n#define TCP_THIN_LINEAR_RETRIES 6       /* After 6 linear retries, do exp. backoff */\n\n/* TCP initial congestion window as per rfc6928 */\n#define TCP_INIT_CWND\t\t10\n\n/* Bit Flags for sysctl_tcp_fastopen */\n#define\tTFO_CLIENT_ENABLE\t1\n#define\tTFO_SERVER_ENABLE\t2\n#define\tTFO_CLIENT_NO_COOKIE\t4\t/* Data in SYN w/o cookie option */\n\n/* Accept SYN data w/o any cookie option */\n#define\tTFO_SERVER_COOKIE_NOT_REQD\t0x200\n\n/* Force enable TFO on all listeners, i.e., not requiring the\n * TCP_FASTOPEN socket option. SOCKOPT1/2 determine how to set max_qlen.\n */\n#define\tTFO_SERVER_WO_SOCKOPT1\t0x400\n#define\tTFO_SERVER_WO_SOCKOPT2\t0x800\n\nextern struct inet_timewait_death_row tcp_death_row;\n\n/* sysctl variables for tcp */\nextern int sysctl_tcp_timestamps;\nextern int sysctl_tcp_window_scaling;\nextern int sysctl_tcp_sack;\nextern int sysctl_tcp_fastopen;\nextern int sysctl_tcp_retrans_collapse;\nextern int sysctl_tcp_stdurg;\nextern int sysctl_tcp_rfc1337;\nextern int sysctl_tcp_abort_on_overflow;\nextern int sysctl_tcp_max_orphans;\nextern int sysctl_tcp_fack;\nextern int sysctl_tcp_reordering;\nextern int sysctl_tcp_max_reordering;\nextern int sysctl_tcp_dsack;\nextern long sysctl_tcp_mem[3];\nextern int sysctl_tcp_wmem[3];\nextern int sysctl_tcp_rmem[3];\nextern int sysctl_tcp_app_win;\nextern int sysctl_tcp_adv_win_scale;\nextern int sysctl_tcp_tw_reuse;\nextern int sysctl_tcp_frto;\nextern int sysctl_tcp_low_latency;\nextern int sysctl_tcp_nometrics_save;\nextern int sysctl_tcp_moderate_rcvbuf;\nextern int sysctl_tcp_tso_win_divisor;\nextern int sysctl_tcp_workaround_signed_windows;\nextern int sysctl_tcp_slow_start_after_idle;\nextern int sysctl_tcp_thin_linear_timeouts;\nextern int sysctl_tcp_thin_dupack;\nextern int sysctl_tcp_early_retrans;\nextern int sysctl_tcp_limit_output_bytes;\nextern int sysctl_tcp_challenge_ack_limit;\nextern int sysctl_tcp_min_tso_segs;\nextern int sysctl_tcp_min_rtt_wlen;\nextern int sysctl_tcp_autocorking;\nextern int sysctl_tcp_invalid_ratelimit;\nextern int sysctl_tcp_pacing_ss_ratio;\nextern int sysctl_tcp_pacing_ca_ratio;\n\nextern atomic_long_t tcp_memory_allocated;\nextern struct percpu_counter tcp_sockets_allocated;\nextern int tcp_memory_pressure;\n\n/* optimized version of sk_under_memory_pressure() for TCP sockets */\nstatic inline bool tcp_under_memory_pressure(const struct sock *sk)\n{\n\tif (mem_cgroup_sockets_enabled && sk->sk_memcg &&\n\t    mem_cgroup_under_socket_pressure(sk->sk_memcg))\n\t\treturn true;\n\n\treturn tcp_memory_pressure;\n}\n/*\n * The next routines deal with comparing 32 bit unsigned ints\n * and worry about wraparound (automatic with unsigned arithmetic).\n */\n\nstatic inline bool before(__u32 seq1, __u32 seq2)\n{\n        return (__s32)(seq1-seq2) < 0;\n}\n#define after(seq2, seq1) \tbefore(seq1, seq2)\n\n/* is s2<=s1<=s3 ? */\nstatic inline bool between(__u32 seq1, __u32 seq2, __u32 seq3)\n{\n\treturn seq3 - seq2 >= seq1 - seq2;\n}\n\nstatic inline bool tcp_out_of_memory(struct sock *sk)\n{\n\tif (sk->sk_wmem_queued > SOCK_MIN_SNDBUF &&\n\t    sk_memory_allocated(sk) > sk_prot_mem_limits(sk, 2))\n\t\treturn true;\n\treturn false;\n}\n\nvoid sk_forced_mem_schedule(struct sock *sk, int size);\n\nstatic inline bool tcp_too_many_orphans(struct sock *sk, int shift)\n{\n\tstruct percpu_counter *ocp = sk->sk_prot->orphan_count;\n\tint orphans = percpu_counter_read_positive(ocp);\n\n\tif (orphans << shift > sysctl_tcp_max_orphans) {\n\t\torphans = percpu_counter_sum_positive(ocp);\n\t\tif (orphans << shift > sysctl_tcp_max_orphans)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool tcp_check_oom(struct sock *sk, int shift);\n\n\nextern struct proto tcp_prot;\n\n#define TCP_INC_STATS(net, field)\tSNMP_INC_STATS((net)->mib.tcp_statistics, field)\n#define __TCP_INC_STATS(net, field)\t__SNMP_INC_STATS((net)->mib.tcp_statistics, field)\n#define TCP_DEC_STATS(net, field)\tSNMP_DEC_STATS((net)->mib.tcp_statistics, field)\n#define TCP_ADD_STATS(net, field, val)\tSNMP_ADD_STATS((net)->mib.tcp_statistics, field, val)\n\nvoid tcp_tasklet_init(void);\n\nvoid tcp_v4_err(struct sk_buff *skb, u32);\n\nvoid tcp_shutdown(struct sock *sk, int how);\n\nvoid tcp_v4_early_demux(struct sk_buff *skb);\nint tcp_v4_rcv(struct sk_buff *skb);\n\nint tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);\nint tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);\nint tcp_sendpage(struct sock *sk, struct page *page, int offset, size_t size,\n\t\t int flags);\nvoid tcp_release_cb(struct sock *sk);\nvoid tcp_wfree(struct sk_buff *skb);\nvoid tcp_write_timer_handler(struct sock *sk);\nvoid tcp_delack_timer_handler(struct sock *sk);\nint tcp_ioctl(struct sock *sk, int cmd, unsigned long arg);\nint tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb);\nvoid tcp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct tcphdr *th, unsigned int len);\nvoid tcp_rcv_space_adjust(struct sock *sk);\nint tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp);\nvoid tcp_twsk_destructor(struct sock *sk);\nssize_t tcp_splice_read(struct socket *sk, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags);\n\nstatic inline void tcp_dec_quickack_mode(struct sock *sk,\n\t\t\t\t\t const unsigned int pkts)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ack.quick) {\n\t\tif (pkts >= icsk->icsk_ack.quick) {\n\t\t\ticsk->icsk_ack.quick = 0;\n\t\t\t/* Leaving quickack mode we deflate ATO. */\n\t\t\ticsk->icsk_ack.ato   = TCP_ATO_MIN;\n\t\t} else\n\t\t\ticsk->icsk_ack.quick -= pkts;\n\t}\n}\n\n#define\tTCP_ECN_OK\t\t1\n#define\tTCP_ECN_QUEUE_CWR\t2\n#define\tTCP_ECN_DEMAND_CWR\t4\n#define\tTCP_ECN_SEEN\t\t8\n\nenum tcp_tw_status {\n\tTCP_TW_SUCCESS = 0,\n\tTCP_TW_RST = 1,\n\tTCP_TW_ACK = 2,\n\tTCP_TW_SYN = 3\n};\n\n\nenum tcp_tw_status tcp_timewait_state_process(struct inet_timewait_sock *tw,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      const struct tcphdr *th);\nstruct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct request_sock *req, bool fastopen);\nint tcp_child_process(struct sock *parent, struct sock *child,\n\t\t      struct sk_buff *skb);\nvoid tcp_enter_loss(struct sock *sk);\nvoid tcp_clear_retrans(struct tcp_sock *tp);\nvoid tcp_update_metrics(struct sock *sk);\nvoid tcp_init_metrics(struct sock *sk);\nvoid tcp_metrics_init(void);\nbool tcp_peer_is_proven(struct request_sock *req, struct dst_entry *dst,\n\t\t\tbool paws_check, bool timestamps);\nbool tcp_remember_stamp(struct sock *sk);\nbool tcp_tw_remember_stamp(struct inet_timewait_sock *tw);\nvoid tcp_fetch_timewait_stamp(struct sock *sk, struct dst_entry *dst);\nvoid tcp_disable_fack(struct tcp_sock *tp);\nvoid tcp_close(struct sock *sk, long timeout);\nvoid tcp_init_sock(struct sock *sk);\nunsigned int tcp_poll(struct file *file, struct socket *sock,\n\t\t      struct poll_table_struct *wait);\nint tcp_getsockopt(struct sock *sk, int level, int optname,\n\t\t   char __user *optval, int __user *optlen);\nint tcp_setsockopt(struct sock *sk, int level, int optname,\n\t\t   char __user *optval, unsigned int optlen);\nint compat_tcp_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen);\nint compat_tcp_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen);\nvoid tcp_set_keepalive(struct sock *sk, int val);\nvoid tcp_syn_ack_timeout(const struct request_sock *req);\nint tcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,\n\t\tint flags, int *addr_len);\nvoid tcp_parse_options(const struct sk_buff *skb,\n\t\t       struct tcp_options_received *opt_rx,\n\t\t       int estab, struct tcp_fastopen_cookie *foc);\nconst u8 *tcp_parse_md5sig_option(const struct tcphdr *th);\n\n/*\n *\tTCP v4 functions exported for the inet6 API\n */\n\nvoid tcp_v4_send_check(struct sock *sk, struct sk_buff *skb);\nvoid tcp_v4_mtu_reduced(struct sock *sk);\nvoid tcp_req_err(struct sock *sk, u32 seq, bool abort);\nint tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb);\nstruct sock *tcp_create_openreq_child(const struct sock *sk,\n\t\t\t\t      struct request_sock *req,\n\t\t\t\t      struct sk_buff *skb);\nvoid tcp_ca_openreq_child(struct sock *sk, const struct dst_entry *dst);\nstruct sock *tcp_v4_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req,\n\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t  struct request_sock *req_unhash,\n\t\t\t\t  bool *own_req);\nint tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);\nint tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);\nint tcp_connect(struct sock *sk);\nenum tcp_synack_type {\n\tTCP_SYNACK_NORMAL,\n\tTCP_SYNACK_FASTOPEN,\n\tTCP_SYNACK_COOKIE,\n};\nstruct sk_buff *tcp_make_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t\tstruct request_sock *req,\n\t\t\t\tstruct tcp_fastopen_cookie *foc,\n\t\t\t\tenum tcp_synack_type synack_type);\nint tcp_disconnect(struct sock *sk, int flags);\n\nvoid tcp_finish_connect(struct sock *sk, struct sk_buff *skb);\nint tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size);\nvoid inet_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb);\n\n/* From syncookies.c */\nstruct sock *tcp_get_cookie_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t struct request_sock *req,\n\t\t\t\t struct dst_entry *dst);\nint __cookie_v4_check(const struct iphdr *iph, const struct tcphdr *th,\n\t\t      u32 cookie);\nstruct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb);\n#ifdef CONFIG_SYN_COOKIES\n\n/* Syncookies use a monotonic timer which increments every 60 seconds.\n * This counter is used both as a hash input and partially encoded into\n * the cookie value.  A cookie is only validated further if the delta\n * between the current counter value and the encoded one is less than this,\n * i.e. a sent cookie is valid only at most for 2*60 seconds (or less if\n * the counter advances immediately after a cookie is generated).\n */\n#define MAX_SYNCOOKIE_AGE\t2\n#define TCP_SYNCOOKIE_PERIOD\t(60 * HZ)\n#define TCP_SYNCOOKIE_VALID\t(MAX_SYNCOOKIE_AGE * TCP_SYNCOOKIE_PERIOD)\n\n/* syncookies: remember time of last synqueue overflow\n * But do not dirty this field too often (once per second is enough)\n * It is racy as we do not hold a lock, but race is very minor.\n */\nstatic inline void tcp_synq_overflow(const struct sock *sk)\n{\n\tunsigned long last_overflow = tcp_sk(sk)->rx_opt.ts_recent_stamp;\n\tunsigned long now = jiffies;\n\n\tif (time_after(now, last_overflow + HZ))\n\t\ttcp_sk(sk)->rx_opt.ts_recent_stamp = now;\n}\n\n/* syncookies: no recent synqueue overflow on this listening socket? */\nstatic inline bool tcp_synq_no_recent_overflow(const struct sock *sk)\n{\n\tunsigned long last_overflow = tcp_sk(sk)->rx_opt.ts_recent_stamp;\n\n\treturn time_after(jiffies, last_overflow + TCP_SYNCOOKIE_VALID);\n}\n\nstatic inline u32 tcp_cookie_time(void)\n{\n\tu64 val = get_jiffies_64();\n\n\tdo_div(val, TCP_SYNCOOKIE_PERIOD);\n\treturn val;\n}\n\nu32 __cookie_v4_init_sequence(const struct iphdr *iph, const struct tcphdr *th,\n\t\t\t      u16 *mssp);\n__u32 cookie_v4_init_sequence(const struct sk_buff *skb, __u16 *mss);\n__u32 cookie_init_timestamp(struct request_sock *req);\nbool cookie_timestamp_decode(struct tcp_options_received *opt);\nbool cookie_ecn_ok(const struct tcp_options_received *opt,\n\t\t   const struct net *net, const struct dst_entry *dst);\n\n/* From net/ipv6/syncookies.c */\nint __cookie_v6_check(const struct ipv6hdr *iph, const struct tcphdr *th,\n\t\t      u32 cookie);\nstruct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb);\n\nu32 __cookie_v6_init_sequence(const struct ipv6hdr *iph,\n\t\t\t      const struct tcphdr *th, u16 *mssp);\n__u32 cookie_v6_init_sequence(const struct sk_buff *skb, __u16 *mss);\n#endif\n/* tcp_output.c */\n\nvoid __tcp_push_pending_frames(struct sock *sk, unsigned int cur_mss,\n\t\t\t       int nonagle);\nbool tcp_may_send_now(struct sock *sk);\nint __tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs);\nint tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs);\nvoid tcp_retransmit_timer(struct sock *sk);\nvoid tcp_xmit_retransmit_queue(struct sock *);\nvoid tcp_simple_retransmit(struct sock *);\nint tcp_trim_head(struct sock *, struct sk_buff *, u32);\nint tcp_fragment(struct sock *, struct sk_buff *, u32, unsigned int, gfp_t);\n\nvoid tcp_send_probe0(struct sock *);\nvoid tcp_send_partial(struct sock *);\nint tcp_write_wakeup(struct sock *, int mib);\nvoid tcp_send_fin(struct sock *sk);\nvoid tcp_send_active_reset(struct sock *sk, gfp_t priority);\nint tcp_send_synack(struct sock *);\nvoid tcp_push_one(struct sock *, unsigned int mss_now);\nvoid tcp_send_ack(struct sock *sk);\nvoid tcp_send_delayed_ack(struct sock *sk);\nvoid tcp_send_loss_probe(struct sock *sk);\nbool tcp_schedule_loss_probe(struct sock *sk);\nvoid tcp_skb_collapse_tstamp(struct sk_buff *skb,\n\t\t\t     const struct sk_buff *next_skb);\n\n/* tcp_input.c */\nvoid tcp_resume_early_retransmit(struct sock *sk);\nvoid tcp_rearm_rto(struct sock *sk);\nvoid tcp_synack_rtt_meas(struct sock *sk, struct request_sock *req);\nvoid tcp_reset(struct sock *sk);\nvoid tcp_skb_mark_lost_uncond_verify(struct tcp_sock *tp, struct sk_buff *skb);\nvoid tcp_fin(struct sock *sk);\n\n/* tcp_timer.c */\nvoid tcp_init_xmit_timers(struct sock *);\nstatic inline void tcp_clear_xmit_timers(struct sock *sk)\n{\n\tinet_csk_clear_xmit_timers(sk);\n}\n\nunsigned int tcp_sync_mss(struct sock *sk, u32 pmtu);\nunsigned int tcp_current_mss(struct sock *sk);\n\n/* Bound MSS / TSO packet size with the half of the window */\nstatic inline int tcp_bound_to_half_wnd(struct tcp_sock *tp, int pktsize)\n{\n\tint cutoff;\n\n\t/* When peer uses tiny windows, there is no use in packetizing\n\t * to sub-MSS pieces for the sake of SWS or making sure there\n\t * are enough packets in the pipe for fast recovery.\n\t *\n\t * On the other hand, for extremely large MSS devices, handling\n\t * smaller than MSS windows in this way does make sense.\n\t */\n\tif (tp->max_window > TCP_MSS_DEFAULT)\n\t\tcutoff = (tp->max_window >> 1);\n\telse\n\t\tcutoff = tp->max_window;\n\n\tif (cutoff && pktsize > cutoff)\n\t\treturn max_t(int, cutoff, 68U - tp->tcp_header_len);\n\telse\n\t\treturn pktsize;\n}\n\n/* tcp.c */\nvoid tcp_get_info(struct sock *, struct tcp_info *);\n\n/* Read 'sendfile()'-style from a TCP socket */\ntypedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *,\n\t\t\t\tunsigned int, size_t);\nint tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor);\n\nvoid tcp_initialize_rcv_mss(struct sock *sk);\n\nint tcp_mtu_to_mss(struct sock *sk, int pmtu);\nint tcp_mss_to_mtu(struct sock *sk, int mss);\nvoid tcp_mtup_init(struct sock *sk);\nvoid tcp_init_buffer_space(struct sock *sk);\n\nstatic inline void tcp_bound_rto(const struct sock *sk)\n{\n\tif (inet_csk(sk)->icsk_rto > TCP_RTO_MAX)\n\t\tinet_csk(sk)->icsk_rto = TCP_RTO_MAX;\n}\n\nstatic inline u32 __tcp_set_rto(const struct tcp_sock *tp)\n{\n\treturn usecs_to_jiffies((tp->srtt_us >> 3) + tp->rttvar_us);\n}\n\nstatic inline void __tcp_fast_path_on(struct tcp_sock *tp, u32 snd_wnd)\n{\n\ttp->pred_flags = htonl((tp->tcp_header_len << 26) |\n\t\t\t       ntohl(TCP_FLAG_ACK) |\n\t\t\t       snd_wnd);\n}\n\nstatic inline void tcp_fast_path_on(struct tcp_sock *tp)\n{\n\t__tcp_fast_path_on(tp, tp->snd_wnd >> tp->rx_opt.snd_wscale);\n}\n\nstatic inline void tcp_fast_path_check(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (skb_queue_empty(&tp->out_of_order_queue) &&\n\t    tp->rcv_wnd &&\n\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf &&\n\t    !tp->urg_data)\n\t\ttcp_fast_path_on(tp);\n}\n\n/* Compute the actual rto_min value */\nstatic inline u32 tcp_rto_min(struct sock *sk)\n{\n\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\tu32 rto_min = TCP_RTO_MIN;\n\n\tif (dst && dst_metric_locked(dst, RTAX_RTO_MIN))\n\t\trto_min = dst_metric_rtt(dst, RTAX_RTO_MIN);\n\treturn rto_min;\n}\n\nstatic inline u32 tcp_rto_min_us(struct sock *sk)\n{\n\treturn jiffies_to_usecs(tcp_rto_min(sk));\n}\n\nstatic inline bool tcp_ca_dst_locked(const struct dst_entry *dst)\n{\n\treturn dst_metric_locked(dst, RTAX_CC_ALGO);\n}\n\n/* Minimum RTT in usec. ~0 means not available. */\nstatic inline u32 tcp_min_rtt(const struct tcp_sock *tp)\n{\n\treturn tp->rtt_min[0].rtt;\n}\n\n/* Compute the actual receive window we are currently advertising.\n * Rcv_nxt can be after the window if our peer push more data\n * than the offered window.\n */\nstatic inline u32 tcp_receive_window(const struct tcp_sock *tp)\n{\n\ts32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;\n\n\tif (win < 0)\n\t\twin = 0;\n\treturn (u32) win;\n}\n\n/* Choose a new window, without checks for shrinking, and without\n * scaling applied to the result.  The caller does these things\n * if necessary.  This is a \"raw\" window selection.\n */\nu32 __tcp_select_window(struct sock *sk);\n\nvoid tcp_send_window_probe(struct sock *sk);\n\n/* TCP timestamps are only 32-bits, this causes a slight\n * complication on 64-bit systems since we store a snapshot\n * of jiffies in the buffer control blocks below.  We decided\n * to use only the low 32-bits of jiffies and hide the ugly\n * casts with the following macro.\n */\n#define tcp_time_stamp\t\t((__u32)(jiffies))\n\nstatic inline u32 tcp_skb_timestamp(const struct sk_buff *skb)\n{\n\treturn skb->skb_mstamp.stamp_jiffies;\n}\n\n\n#define tcp_flag_byte(th) (((u_int8_t *)th)[13])\n\n#define TCPHDR_FIN 0x01\n#define TCPHDR_SYN 0x02\n#define TCPHDR_RST 0x04\n#define TCPHDR_PSH 0x08\n#define TCPHDR_ACK 0x10\n#define TCPHDR_URG 0x20\n#define TCPHDR_ECE 0x40\n#define TCPHDR_CWR 0x80\n\n#define TCPHDR_SYN_ECN\t(TCPHDR_SYN | TCPHDR_ECE | TCPHDR_CWR)\n\n/* This is what the send packet queuing engine uses to pass\n * TCP per-packet control information to the transmission code.\n * We also store the host-order sequence numbers in here too.\n * This is 44 bytes if IPV6 is enabled.\n * If this grows please adjust skbuff.h:skbuff->cb[xxx] size appropriately.\n */\nstruct tcp_skb_cb {\n\t__u32\t\tseq;\t\t/* Starting sequence number\t*/\n\t__u32\t\tend_seq;\t/* SEQ + FIN + SYN + datalen\t*/\n\tunion {\n\t\t/* Note : tcp_tw_isn is used in input path only\n\t\t *\t  (isn chosen by tcp_timewait_state_process())\n\t\t *\n\t\t * \t  tcp_gso_segs/size are used in write queue only,\n\t\t *\t  cf tcp_skb_pcount()/tcp_skb_mss()\n\t\t */\n\t\t__u32\t\ttcp_tw_isn;\n\t\tstruct {\n\t\t\tu16\ttcp_gso_segs;\n\t\t\tu16\ttcp_gso_size;\n\t\t};\n\t};\n\t__u8\t\ttcp_flags;\t/* TCP header flags. (tcp[13])\t*/\n\n\t__u8\t\tsacked;\t\t/* State flags for SACK/FACK.\t*/\n#define TCPCB_SACKED_ACKED\t0x01\t/* SKB ACK'd by a SACK block\t*/\n#define TCPCB_SACKED_RETRANS\t0x02\t/* SKB retransmitted\t\t*/\n#define TCPCB_LOST\t\t0x04\t/* SKB is lost\t\t\t*/\n#define TCPCB_TAGBITS\t\t0x07\t/* All tag bits\t\t\t*/\n#define TCPCB_REPAIRED\t\t0x10\t/* SKB repaired (no skb_mstamp)\t*/\n#define TCPCB_EVER_RETRANS\t0x80\t/* Ever retransmitted frame\t*/\n#define TCPCB_RETRANS\t\t(TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS| \\\n\t\t\t\tTCPCB_REPAIRED)\n\n\t__u8\t\tip_dsfield;\t/* IPv4 tos or IPv6 dsfield\t*/\n\t__u8\t\ttxstamp_ack:1,\t/* Record TX timestamp for ack? */\n\t\t\teor:1,\t\t/* Is skb MSG_EOR marked? */\n\t\t\tunused:6;\n\t__u32\t\tack_seq;\t/* Sequence number ACK'd\t*/\n\tunion {\n\t\tstruct {\n\t\t\t/* There is space for up to 20 bytes */\n\t\t\t__u32 in_flight;/* Bytes in flight when packet sent */\n\t\t} tx;   /* only used for outgoing skbs */\n\t\tunion {\n\t\t\tstruct inet_skb_parm\th4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tstruct inet6_skb_parm\th6;\n#endif\n\t\t} header;\t/* For incoming skbs */\n\t};\n};\n\n#define TCP_SKB_CB(__skb)\t((struct tcp_skb_cb *)&((__skb)->cb[0]))\n\n\n#if IS_ENABLED(CONFIG_IPV6)\n/* This is the variant of inet6_iif() that must be used by TCP,\n * as TCP moves IP6CB into a different location in skb->cb[]\n */\nstatic inline int tcp_v6_iif(const struct sk_buff *skb)\n{\n\tbool l3_slave = skb_l3mdev_slave(TCP_SKB_CB(skb)->header.h6.flags);\n\n\treturn l3_slave ? skb->skb_iif : TCP_SKB_CB(skb)->header.h6.iif;\n}\n#endif\n\n/* Due to TSO, an SKB can be composed of multiple actual\n * packets.  To keep these tracked properly, we use this.\n */\nstatic inline int tcp_skb_pcount(const struct sk_buff *skb)\n{\n\treturn TCP_SKB_CB(skb)->tcp_gso_segs;\n}\n\nstatic inline void tcp_skb_pcount_set(struct sk_buff *skb, int segs)\n{\n\tTCP_SKB_CB(skb)->tcp_gso_segs = segs;\n}\n\nstatic inline void tcp_skb_pcount_add(struct sk_buff *skb, int segs)\n{\n\tTCP_SKB_CB(skb)->tcp_gso_segs += segs;\n}\n\n/* This is valid iff skb is in write queue and tcp_skb_pcount() > 1. */\nstatic inline int tcp_skb_mss(const struct sk_buff *skb)\n{\n\treturn TCP_SKB_CB(skb)->tcp_gso_size;\n}\n\nstatic inline bool tcp_skb_can_collapse_to(const struct sk_buff *skb)\n{\n\treturn likely(!TCP_SKB_CB(skb)->eor);\n}\n\n/* Events passed to congestion control interface */\nenum tcp_ca_event {\n\tCA_EVENT_TX_START,\t/* first transmit when no packets in flight */\n\tCA_EVENT_CWND_RESTART,\t/* congestion window restart */\n\tCA_EVENT_COMPLETE_CWR,\t/* end of congestion recovery */\n\tCA_EVENT_LOSS,\t\t/* loss timeout */\n\tCA_EVENT_ECN_NO_CE,\t/* ECT set, but not CE marked */\n\tCA_EVENT_ECN_IS_CE,\t/* received CE marked IP packet */\n\tCA_EVENT_DELAYED_ACK,\t/* Delayed ack is sent */\n\tCA_EVENT_NON_DELAYED_ACK,\n};\n\n/* Information about inbound ACK, passed to cong_ops->in_ack_event() */\nenum tcp_ca_ack_event_flags {\n\tCA_ACK_SLOWPATH\t\t= (1 << 0),\t/* In slow path processing */\n\tCA_ACK_WIN_UPDATE\t= (1 << 1),\t/* ACK updated window */\n\tCA_ACK_ECE\t\t= (1 << 2),\t/* ECE bit is set on ack */\n};\n\n/*\n * Interface for adding new TCP congestion control handlers\n */\n#define TCP_CA_NAME_MAX\t16\n#define TCP_CA_MAX\t128\n#define TCP_CA_BUF_MAX\t(TCP_CA_NAME_MAX*TCP_CA_MAX)\n\n#define TCP_CA_UNSPEC\t0\n\n/* Algorithm can be set on socket without CAP_NET_ADMIN privileges */\n#define TCP_CONG_NON_RESTRICTED 0x1\n/* Requires ECN/ECT set on all packets */\n#define TCP_CONG_NEEDS_ECN\t0x2\n\nunion tcp_cc_info;\n\nstruct ack_sample {\n\tu32 pkts_acked;\n\ts32 rtt_us;\n\tu32 in_flight;\n};\n\nstruct tcp_congestion_ops {\n\tstruct list_head\tlist;\n\tu32 key;\n\tu32 flags;\n\n\t/* initialize private data (optional) */\n\tvoid (*init)(struct sock *sk);\n\t/* cleanup private data  (optional) */\n\tvoid (*release)(struct sock *sk);\n\n\t/* return slow start threshold (required) */\n\tu32 (*ssthresh)(struct sock *sk);\n\t/* do new cwnd calculation (required) */\n\tvoid (*cong_avoid)(struct sock *sk, u32 ack, u32 acked);\n\t/* call before changing ca_state (optional) */\n\tvoid (*set_state)(struct sock *sk, u8 new_state);\n\t/* call when cwnd event occurs (optional) */\n\tvoid (*cwnd_event)(struct sock *sk, enum tcp_ca_event ev);\n\t/* call when ack arrives (optional) */\n\tvoid (*in_ack_event)(struct sock *sk, u32 flags);\n\t/* new value of cwnd after loss (optional) */\n\tu32  (*undo_cwnd)(struct sock *sk);\n\t/* hook for packet ack accounting (optional) */\n\tvoid (*pkts_acked)(struct sock *sk, const struct ack_sample *sample);\n\t/* get info for inet_diag (optional) */\n\tsize_t (*get_info)(struct sock *sk, u32 ext, int *attr,\n\t\t\t   union tcp_cc_info *info);\n\n\tchar \t\tname[TCP_CA_NAME_MAX];\n\tstruct module \t*owner;\n};\n\nint tcp_register_congestion_control(struct tcp_congestion_ops *type);\nvoid tcp_unregister_congestion_control(struct tcp_congestion_ops *type);\n\nvoid tcp_assign_congestion_control(struct sock *sk);\nvoid tcp_init_congestion_control(struct sock *sk);\nvoid tcp_cleanup_congestion_control(struct sock *sk);\nint tcp_set_default_congestion_control(const char *name);\nvoid tcp_get_default_congestion_control(char *name);\nvoid tcp_get_available_congestion_control(char *buf, size_t len);\nvoid tcp_get_allowed_congestion_control(char *buf, size_t len);\nint tcp_set_allowed_congestion_control(char *allowed);\nint tcp_set_congestion_control(struct sock *sk, const char *name);\nu32 tcp_slow_start(struct tcp_sock *tp, u32 acked);\nvoid tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w, u32 acked);\n\nu32 tcp_reno_ssthresh(struct sock *sk);\nvoid tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 acked);\nextern struct tcp_congestion_ops tcp_reno;\n\nstruct tcp_congestion_ops *tcp_ca_find_key(u32 key);\nu32 tcp_ca_get_key_by_name(const char *name, bool *ecn_ca);\n#ifdef CONFIG_INET\nchar *tcp_ca_get_name_by_key(u32 key, char *buffer);\n#else\nstatic inline char *tcp_ca_get_name_by_key(u32 key, char *buffer)\n{\n\treturn NULL;\n}\n#endif\n\nstatic inline bool tcp_ca_needs_ecn(const struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\treturn icsk->icsk_ca_ops->flags & TCP_CONG_NEEDS_ECN;\n}\n\nstatic inline void tcp_set_ca_state(struct sock *sk, const u8 ca_state)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_ops->set_state)\n\t\ticsk->icsk_ca_ops->set_state(sk, ca_state);\n\ticsk->icsk_ca_state = ca_state;\n}\n\nstatic inline void tcp_ca_event(struct sock *sk, const enum tcp_ca_event event)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_ops->cwnd_event)\n\t\ticsk->icsk_ca_ops->cwnd_event(sk, event);\n}\n\n/* These functions determine how the current flow behaves in respect of SACK\n * handling. SACK is negotiated with the peer, and therefore it can vary\n * between different flows.\n *\n * tcp_is_sack - SACK enabled\n * tcp_is_reno - No SACK\n * tcp_is_fack - FACK enabled, implies SACK enabled\n */\nstatic inline int tcp_is_sack(const struct tcp_sock *tp)\n{\n\treturn tp->rx_opt.sack_ok;\n}\n\nstatic inline bool tcp_is_reno(const struct tcp_sock *tp)\n{\n\treturn !tcp_is_sack(tp);\n}\n\nstatic inline bool tcp_is_fack(const struct tcp_sock *tp)\n{\n\treturn tp->rx_opt.sack_ok & TCP_FACK_ENABLED;\n}\n\nstatic inline void tcp_enable_fack(struct tcp_sock *tp)\n{\n\ttp->rx_opt.sack_ok |= TCP_FACK_ENABLED;\n}\n\n/* TCP early-retransmit (ER) is similar to but more conservative than\n * the thin-dupack feature.  Enable ER only if thin-dupack is disabled.\n */\nstatic inline void tcp_enable_early_retrans(struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\ttp->do_early_retrans = sysctl_tcp_early_retrans &&\n\t\tsysctl_tcp_early_retrans < 4 && !sysctl_tcp_thin_dupack &&\n\t\tnet->ipv4.sysctl_tcp_reordering == 3;\n}\n\nstatic inline void tcp_disable_early_retrans(struct tcp_sock *tp)\n{\n\ttp->do_early_retrans = 0;\n}\n\nstatic inline unsigned int tcp_left_out(const struct tcp_sock *tp)\n{\n\treturn tp->sacked_out + tp->lost_out;\n}\n\n/* This determines how many packets are \"in the network\" to the best\n * of our knowledge.  In many cases it is conservative, but where\n * detailed information is available from the receiver (via SACK\n * blocks etc.) we can make more aggressive calculations.\n *\n * Use this for decisions involving congestion control, use just\n * tp->packets_out to determine if the send queue is empty or not.\n *\n * Read this equation as:\n *\n *\t\"Packets sent once on transmission queue\" MINUS\n *\t\"Packets left network, but not honestly ACKed yet\" PLUS\n *\t\"Packets fast retransmitted\"\n */\nstatic inline unsigned int tcp_packets_in_flight(const struct tcp_sock *tp)\n{\n\treturn tp->packets_out - tcp_left_out(tp) + tp->retrans_out;\n}\n\n#define TCP_INFINITE_SSTHRESH\t0x7fffffff\n\nstatic inline bool tcp_in_slow_start(const struct tcp_sock *tp)\n{\n\treturn tp->snd_cwnd < tp->snd_ssthresh;\n}\n\nstatic inline bool tcp_in_initial_slowstart(const struct tcp_sock *tp)\n{\n\treturn tp->snd_ssthresh >= TCP_INFINITE_SSTHRESH;\n}\n\nstatic inline bool tcp_in_cwnd_reduction(const struct sock *sk)\n{\n\treturn (TCPF_CA_CWR | TCPF_CA_Recovery) &\n\t       (1 << inet_csk(sk)->icsk_ca_state);\n}\n\n/* If cwnd > ssthresh, we may raise ssthresh to be half-way to cwnd.\n * The exception is cwnd reduction phase, when cwnd is decreasing towards\n * ssthresh.\n */\nstatic inline __u32 tcp_current_ssthresh(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_in_cwnd_reduction(sk))\n\t\treturn tp->snd_ssthresh;\n\telse\n\t\treturn max(tp->snd_ssthresh,\n\t\t\t   ((tp->snd_cwnd >> 1) +\n\t\t\t    (tp->snd_cwnd >> 2)));\n}\n\n/* Use define here intentionally to get WARN_ON location shown at the caller */\n#define tcp_verify_left_out(tp)\tWARN_ON(tcp_left_out(tp) > tp->packets_out)\n\nvoid tcp_enter_cwr(struct sock *sk);\n__u32 tcp_init_cwnd(const struct tcp_sock *tp, const struct dst_entry *dst);\n\n/* The maximum number of MSS of available cwnd for which TSO defers\n * sending if not using sysctl_tcp_tso_win_divisor.\n */\nstatic inline __u32 tcp_max_tso_deferred_mss(const struct tcp_sock *tp)\n{\n\treturn 3;\n}\n\n/* Returns end sequence number of the receiver's advertised window */\nstatic inline u32 tcp_wnd_end(const struct tcp_sock *tp)\n{\n\treturn tp->snd_una + tp->snd_wnd;\n}\n\n/* We follow the spirit of RFC2861 to validate cwnd but implement a more\n * flexible approach. The RFC suggests cwnd should not be raised unless\n * it was fully used previously. And that's exactly what we do in\n * congestion avoidance mode. But in slow start we allow cwnd to grow\n * as long as the application has used half the cwnd.\n * Example :\n *    cwnd is 10 (IW10), but application sends 9 frames.\n *    We allow cwnd to reach 18 when all frames are ACKed.\n * This check is safe because it's as aggressive as slow start which already\n * risks 100% overshoot. The advantage is that we discourage application to\n * either send more filler packets or data to artificially blow up the cwnd\n * usage, and allow application-limited process to probe bw more aggressively.\n */\nstatic inline bool tcp_is_cwnd_limited(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t/* If in slow start, ensure cwnd grows to twice what was ACKed. */\n\tif (tcp_in_slow_start(tp))\n\t\treturn tp->snd_cwnd < 2 * tp->max_packets_out;\n\n\treturn tp->is_cwnd_limited;\n}\n\n/* Something is really bad, we could not queue an additional packet,\n * because qdisc is full or receiver sent a 0 window.\n * We do not want to add fuel to the fire, or abort too early,\n * so make sure the timer we arm now is at least 200ms in the future,\n * regardless of current icsk_rto value (as it could be ~2ms)\n */\nstatic inline unsigned long tcp_probe0_base(const struct sock *sk)\n{\n\treturn max_t(unsigned long, inet_csk(sk)->icsk_rto, TCP_RTO_MIN);\n}\n\n/* Variant of inet_csk_rto_backoff() used for zero window probes */\nstatic inline unsigned long tcp_probe0_when(const struct sock *sk,\n\t\t\t\t\t    unsigned long max_when)\n{\n\tu64 when = (u64)tcp_probe0_base(sk) << inet_csk(sk)->icsk_backoff;\n\n\treturn (unsigned long)min_t(u64, when, max_when);\n}\n\nstatic inline void tcp_check_probe_timer(struct sock *sk)\n{\n\tif (!tcp_sk(sk)->packets_out && !inet_csk(sk)->icsk_pending)\n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_PROBE0,\n\t\t\t\t\t  tcp_probe0_base(sk), TCP_RTO_MAX);\n}\n\nstatic inline void tcp_init_wl(struct tcp_sock *tp, u32 seq)\n{\n\ttp->snd_wl1 = seq;\n}\n\nstatic inline void tcp_update_wl(struct tcp_sock *tp, u32 seq)\n{\n\ttp->snd_wl1 = seq;\n}\n\n/*\n * Calculate(/check) TCP checksum\n */\nstatic inline __sum16 tcp_v4_check(int len, __be32 saddr,\n\t\t\t\t   __be32 daddr, __wsum base)\n{\n\treturn csum_tcpudp_magic(saddr,daddr,len,IPPROTO_TCP,base);\n}\n\nstatic inline __sum16 __tcp_checksum_complete(struct sk_buff *skb)\n{\n\treturn __skb_checksum_complete(skb);\n}\n\nstatic inline bool tcp_checksum_complete(struct sk_buff *skb)\n{\n\treturn !skb_csum_unnecessary(skb) &&\n\t\t__tcp_checksum_complete(skb);\n}\n\n/* Prequeue for VJ style copy to user, combined with checksumming. */\n\nstatic inline void tcp_prequeue_init(struct tcp_sock *tp)\n{\n\ttp->ucopy.task = NULL;\n\ttp->ucopy.len = 0;\n\ttp->ucopy.memory = 0;\n\tskb_queue_head_init(&tp->ucopy.prequeue);\n}\n\nbool tcp_prequeue(struct sock *sk, struct sk_buff *skb);\n\n#undef STATE_TRACE\n\n#ifdef STATE_TRACE\nstatic const char *statename[]={\n\t\"Unused\",\"Established\",\"Syn Sent\",\"Syn Recv\",\n\t\"Fin Wait 1\",\"Fin Wait 2\",\"Time Wait\", \"Close\",\n\t\"Close Wait\",\"Last ACK\",\"Listen\",\"Closing\"\n};\n#endif\nvoid tcp_set_state(struct sock *sk, int state);\n\nvoid tcp_done(struct sock *sk);\n\nint tcp_abort(struct sock *sk, int err);\n\nstatic inline void tcp_sack_reset(struct tcp_options_received *rx_opt)\n{\n\trx_opt->dsack = 0;\n\trx_opt->num_sacks = 0;\n}\n\nu32 tcp_default_init_rwnd(u32 mss);\nvoid tcp_cwnd_restart(struct sock *sk, s32 delta);\n\nstatic inline void tcp_slow_start_after_idle_check(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\ts32 delta;\n\n\tif (!sysctl_tcp_slow_start_after_idle || tp->packets_out)\n\t\treturn;\n\tdelta = tcp_time_stamp - tp->lsndtime;\n\tif (delta > inet_csk(sk)->icsk_rto)\n\t\ttcp_cwnd_restart(sk, delta);\n}\n\n/* Determine a window scaling and initial window to offer. */\nvoid tcp_select_initial_window(int __space, __u32 mss, __u32 *rcv_wnd,\n\t\t\t       __u32 *window_clamp, int wscale_ok,\n\t\t\t       __u8 *rcv_wscale, __u32 init_rcv_wnd);\n\nstatic inline int tcp_win_from_space(int space)\n{\n\treturn sysctl_tcp_adv_win_scale<=0 ?\n\t\t(space>>(-sysctl_tcp_adv_win_scale)) :\n\t\tspace - (space>>sysctl_tcp_adv_win_scale);\n}\n\n/* Note: caller must be prepared to deal with negative returns */\nstatic inline int tcp_space(const struct sock *sk)\n{\n\treturn tcp_win_from_space(sk->sk_rcvbuf -\n\t\t\t\t  atomic_read(&sk->sk_rmem_alloc));\n}\n\nstatic inline int tcp_full_space(const struct sock *sk)\n{\n\treturn tcp_win_from_space(sk->sk_rcvbuf);\n}\n\nextern void tcp_openreq_init_rwin(struct request_sock *req,\n\t\t\t\t  const struct sock *sk_listener,\n\t\t\t\t  const struct dst_entry *dst);\n\nvoid tcp_enter_memory_pressure(struct sock *sk);\n\nstatic inline int keepalive_intvl_when(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\treturn tp->keepalive_intvl ? : net->ipv4.sysctl_tcp_keepalive_intvl;\n}\n\nstatic inline int keepalive_time_when(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\treturn tp->keepalive_time ? : net->ipv4.sysctl_tcp_keepalive_time;\n}\n\nstatic inline int keepalive_probes(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\treturn tp->keepalive_probes ? : net->ipv4.sysctl_tcp_keepalive_probes;\n}\n\nstatic inline u32 keepalive_time_elapsed(const struct tcp_sock *tp)\n{\n\tconst struct inet_connection_sock *icsk = &tp->inet_conn;\n\n\treturn min_t(u32, tcp_time_stamp - icsk->icsk_ack.lrcvtime,\n\t\t\t  tcp_time_stamp - tp->rcv_tstamp);\n}\n\nstatic inline int tcp_fin_time(const struct sock *sk)\n{\n\tint fin_timeout = tcp_sk(sk)->linger2 ? : sock_net(sk)->ipv4.sysctl_tcp_fin_timeout;\n\tconst int rto = inet_csk(sk)->icsk_rto;\n\n\tif (fin_timeout < (rto << 2) - (rto >> 1))\n\t\tfin_timeout = (rto << 2) - (rto >> 1);\n\n\treturn fin_timeout;\n}\n\nstatic inline bool tcp_paws_check(const struct tcp_options_received *rx_opt,\n\t\t\t\t  int paws_win)\n{\n\tif ((s32)(rx_opt->ts_recent - rx_opt->rcv_tsval) <= paws_win)\n\t\treturn true;\n\tif (unlikely(get_seconds() >= rx_opt->ts_recent_stamp + TCP_PAWS_24DAYS))\n\t\treturn true;\n\t/*\n\t * Some OSes send SYN and SYNACK messages with tsval=0 tsecr=0,\n\t * then following tcp messages have valid values. Ignore 0 value,\n\t * or else 'negative' tsval might forbid us to accept their packets.\n\t */\n\tif (!rx_opt->ts_recent)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool tcp_paws_reject(const struct tcp_options_received *rx_opt,\n\t\t\t\t   int rst)\n{\n\tif (tcp_paws_check(rx_opt, 0))\n\t\treturn false;\n\n\t/* RST segments are not recommended to carry timestamp,\n\t   and, if they do, it is recommended to ignore PAWS because\n\t   \"their cleanup function should take precedence over timestamps.\"\n\t   Certainly, it is mistake. It is necessary to understand the reasons\n\t   of this constraint to relax it: if peer reboots, clock may go\n\t   out-of-sync and half-open connections will not be reset.\n\t   Actually, the problem would be not existing if all\n\t   the implementations followed draft about maintaining clock\n\t   via reboots. Linux-2.2 DOES NOT!\n\n\t   However, we can relax time bounds for RST segments to MSL.\n\t */\n\tif (rst && get_seconds() >= rx_opt->ts_recent_stamp + TCP_PAWS_MSL)\n\t\treturn false;\n\treturn true;\n}\n\nbool tcp_oow_rate_limited(struct net *net, const struct sk_buff *skb,\n\t\t\t  int mib_idx, u32 *last_oow_ack_time);\n\nstatic inline void tcp_mib_init(struct net *net)\n{\n\t/* See RFC 2012 */\n\tTCP_ADD_STATS(net, TCP_MIB_RTOALGORITHM, 1);\n\tTCP_ADD_STATS(net, TCP_MIB_RTOMIN, TCP_RTO_MIN*1000/HZ);\n\tTCP_ADD_STATS(net, TCP_MIB_RTOMAX, TCP_RTO_MAX*1000/HZ);\n\tTCP_ADD_STATS(net, TCP_MIB_MAXCONN, -1);\n}\n\n/* from STCP */\nstatic inline void tcp_clear_retrans_hints_partial(struct tcp_sock *tp)\n{\n\ttp->lost_skb_hint = NULL;\n}\n\nstatic inline void tcp_clear_all_retrans_hints(struct tcp_sock *tp)\n{\n\ttcp_clear_retrans_hints_partial(tp);\n\ttp->retransmit_skb_hint = NULL;\n}\n\nunion tcp_md5_addr {\n\tstruct in_addr  a4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct in6_addr\ta6;\n#endif\n};\n\n/* - key database */\nstruct tcp_md5sig_key {\n\tstruct hlist_node\tnode;\n\tu8\t\t\tkeylen;\n\tu8\t\t\tfamily; /* AF_INET or AF_INET6 */\n\tunion tcp_md5_addr\taddr;\n\tu8\t\t\tkey[TCP_MD5SIG_MAXKEYLEN];\n\tstruct rcu_head\t\trcu;\n};\n\n/* - sock block */\nstruct tcp_md5sig_info {\n\tstruct hlist_head\thead;\n\tstruct rcu_head\t\trcu;\n};\n\n/* - pseudo header */\nstruct tcp4_pseudohdr {\n\t__be32\t\tsaddr;\n\t__be32\t\tdaddr;\n\t__u8\t\tpad;\n\t__u8\t\tprotocol;\n\t__be16\t\tlen;\n};\n\nstruct tcp6_pseudohdr {\n\tstruct in6_addr\tsaddr;\n\tstruct in6_addr daddr;\n\t__be32\t\tlen;\n\t__be32\t\tprotocol;\t/* including padding */\n};\n\nunion tcp_md5sum_block {\n\tstruct tcp4_pseudohdr ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct tcp6_pseudohdr ip6;\n#endif\n};\n\n/* - pool: digest algorithm, hash description and scratch buffer */\nstruct tcp_md5sig_pool {\n\tstruct ahash_request\t*md5_req;\n\tvoid\t\t\t*scratch;\n};\n\n/* - functions */\nint tcp_v4_md5_hash_skb(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\tconst struct sock *sk, const struct sk_buff *skb);\nint tcp_md5_do_add(struct sock *sk, const union tcp_md5_addr *addr,\n\t\t   int family, const u8 *newkey, u8 newkeylen, gfp_t gfp);\nint tcp_md5_do_del(struct sock *sk, const union tcp_md5_addr *addr,\n\t\t   int family);\nstruct tcp_md5sig_key *tcp_v4_md5_lookup(const struct sock *sk,\n\t\t\t\t\t const struct sock *addr_sk);\n\n#ifdef CONFIG_TCP_MD5SIG\nstruct tcp_md5sig_key *tcp_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t const union tcp_md5_addr *addr,\n\t\t\t\t\t int family);\n#define tcp_twsk_md5_key(twsk)\t((twsk)->tw_md5_key)\n#else\nstatic inline struct tcp_md5sig_key *tcp_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t const union tcp_md5_addr *addr,\n\t\t\t\t\t int family)\n{\n\treturn NULL;\n}\n#define tcp_twsk_md5_key(twsk)\tNULL\n#endif\n\nbool tcp_alloc_md5sig_pool(void);\n\nstruct tcp_md5sig_pool *tcp_get_md5sig_pool(void);\nstatic inline void tcp_put_md5sig_pool(void)\n{\n\tlocal_bh_enable();\n}\n\nint tcp_md5_hash_skb_data(struct tcp_md5sig_pool *, const struct sk_buff *,\n\t\t\t  unsigned int header_len);\nint tcp_md5_hash_key(struct tcp_md5sig_pool *hp,\n\t\t     const struct tcp_md5sig_key *key);\n\n/* From tcp_fastopen.c */\nvoid tcp_fastopen_cache_get(struct sock *sk, u16 *mss,\n\t\t\t    struct tcp_fastopen_cookie *cookie, int *syn_loss,\n\t\t\t    unsigned long *last_syn_loss);\nvoid tcp_fastopen_cache_set(struct sock *sk, u16 mss,\n\t\t\t    struct tcp_fastopen_cookie *cookie, bool syn_lost,\n\t\t\t    u16 try_exp);\nstruct tcp_fastopen_request {\n\t/* Fast Open cookie. Size 0 means a cookie request */\n\tstruct tcp_fastopen_cookie\tcookie;\n\tstruct msghdr\t\t\t*data;  /* data in MSG_FASTOPEN */\n\tsize_t\t\t\t\tsize;\n\tint\t\t\t\tcopied;\t/* queued in tcp_connect() */\n};\nvoid tcp_free_fastopen_req(struct tcp_sock *tp);\n\nextern struct tcp_fastopen_context __rcu *tcp_fastopen_ctx;\nint tcp_fastopen_reset_cipher(void *key, unsigned int len);\nvoid tcp_fastopen_add_skb(struct sock *sk, struct sk_buff *skb);\nstruct sock *tcp_try_fastopen(struct sock *sk, struct sk_buff *skb,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      struct dst_entry *dst);\nvoid tcp_fastopen_init_key_once(bool publish);\n#define TCP_FASTOPEN_KEY_LENGTH 16\n\n/* Fastopen key context */\nstruct tcp_fastopen_context {\n\tstruct crypto_cipher\t*tfm;\n\t__u8\t\t\tkey[TCP_FASTOPEN_KEY_LENGTH];\n\tstruct rcu_head\t\trcu;\n};\n\n/* write queue abstraction */\nstatic inline void tcp_write_queue_purge(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(&sk->sk_write_queue)) != NULL)\n\t\tsk_wmem_free_skb(sk, skb);\n\tsk_mem_reclaim(sk);\n\ttcp_clear_all_retrans_hints(tcp_sk(sk));\n}\n\nstatic inline struct sk_buff *tcp_write_queue_head(const struct sock *sk)\n{\n\treturn skb_peek(&sk->sk_write_queue);\n}\n\nstatic inline struct sk_buff *tcp_write_queue_tail(const struct sock *sk)\n{\n\treturn skb_peek_tail(&sk->sk_write_queue);\n}\n\nstatic inline struct sk_buff *tcp_write_queue_next(const struct sock *sk,\n\t\t\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn skb_queue_next(&sk->sk_write_queue, skb);\n}\n\nstatic inline struct sk_buff *tcp_write_queue_prev(const struct sock *sk,\n\t\t\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn skb_queue_prev(&sk->sk_write_queue, skb);\n}\n\n#define tcp_for_write_queue(skb, sk)\t\t\t\t\t\\\n\tskb_queue_walk(&(sk)->sk_write_queue, skb)\n\n#define tcp_for_write_queue_from(skb, sk)\t\t\t\t\\\n\tskb_queue_walk_from(&(sk)->sk_write_queue, skb)\n\n#define tcp_for_write_queue_from_safe(skb, tmp, sk)\t\t\t\\\n\tskb_queue_walk_from_safe(&(sk)->sk_write_queue, skb, tmp)\n\nstatic inline struct sk_buff *tcp_send_head(const struct sock *sk)\n{\n\treturn sk->sk_send_head;\n}\n\nstatic inline bool tcp_skb_is_last(const struct sock *sk,\n\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn skb_queue_is_last(&sk->sk_write_queue, skb);\n}\n\nstatic inline void tcp_advance_send_head(struct sock *sk, const struct sk_buff *skb)\n{\n\tif (tcp_skb_is_last(sk, skb))\n\t\tsk->sk_send_head = NULL;\n\telse\n\t\tsk->sk_send_head = tcp_write_queue_next(sk, skb);\n}\n\nstatic inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n}\n\nstatic inline void tcp_init_send_head(struct sock *sk)\n{\n\tsk->sk_send_head = NULL;\n}\n\nstatic inline void __tcp_add_write_queue_tail(struct sock *sk, struct sk_buff *skb)\n{\n\t__skb_queue_tail(&sk->sk_write_queue, skb);\n}\n\nstatic inline void tcp_add_write_queue_tail(struct sock *sk, struct sk_buff *skb)\n{\n\t__tcp_add_write_queue_tail(sk, skb);\n\n\t/* Queue it, remembering where we must start sending. */\n\tif (sk->sk_send_head == NULL) {\n\t\tsk->sk_send_head = skb;\n\n\t\tif (tcp_sk(sk)->highest_sack == NULL)\n\t\t\ttcp_sk(sk)->highest_sack = skb;\n\t}\n}\n\nstatic inline void __tcp_add_write_queue_head(struct sock *sk, struct sk_buff *skb)\n{\n\t__skb_queue_head(&sk->sk_write_queue, skb);\n}\n\n/* Insert buff after skb on the write queue of sk.  */\nstatic inline void tcp_insert_write_queue_after(struct sk_buff *skb,\n\t\t\t\t\t\tstruct sk_buff *buff,\n\t\t\t\t\t\tstruct sock *sk)\n{\n\t__skb_queue_after(&sk->sk_write_queue, skb, buff);\n}\n\n/* Insert new before skb on the write queue of sk.  */\nstatic inline void tcp_insert_write_queue_before(struct sk_buff *new,\n\t\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t\t  struct sock *sk)\n{\n\t__skb_queue_before(&sk->sk_write_queue, skb, new);\n\n\tif (sk->sk_send_head == skb)\n\t\tsk->sk_send_head = new;\n}\n\nstatic inline void tcp_unlink_write_queue(struct sk_buff *skb, struct sock *sk)\n{\n\t__skb_unlink(skb, &sk->sk_write_queue);\n}\n\nstatic inline bool tcp_write_queue_empty(struct sock *sk)\n{\n\treturn skb_queue_empty(&sk->sk_write_queue);\n}\n\nstatic inline void tcp_push_pending_frames(struct sock *sk)\n{\n\tif (tcp_send_head(sk)) {\n\t\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t\t__tcp_push_pending_frames(sk, tcp_current_mss(sk), tp->nonagle);\n\t}\n}\n\n/* Start sequence of the skb just after the highest skb with SACKed\n * bit, valid only if sacked_out > 0 or when the caller has ensured\n * validity by itself.\n */\nstatic inline u32 tcp_highest_sack_seq(struct tcp_sock *tp)\n{\n\tif (!tp->sacked_out)\n\t\treturn tp->snd_una;\n\n\tif (tp->highest_sack == NULL)\n\t\treturn tp->snd_nxt;\n\n\treturn TCP_SKB_CB(tp->highest_sack)->seq;\n}\n\nstatic inline void tcp_advance_highest_sack(struct sock *sk, struct sk_buff *skb)\n{\n\ttcp_sk(sk)->highest_sack = tcp_skb_is_last(sk, skb) ? NULL :\n\t\t\t\t\t\ttcp_write_queue_next(sk, skb);\n}\n\nstatic inline struct sk_buff *tcp_highest_sack(struct sock *sk)\n{\n\treturn tcp_sk(sk)->highest_sack;\n}\n\nstatic inline void tcp_highest_sack_reset(struct sock *sk)\n{\n\ttcp_sk(sk)->highest_sack = tcp_write_queue_head(sk);\n}\n\n/* Called when old skb is about to be deleted (to be combined with new skb) */\nstatic inline void tcp_highest_sack_combine(struct sock *sk,\n\t\t\t\t\t    struct sk_buff *old,\n\t\t\t\t\t    struct sk_buff *new)\n{\n\tif (tcp_sk(sk)->sacked_out && (old == tcp_sk(sk)->highest_sack))\n\t\ttcp_sk(sk)->highest_sack = new;\n}\n\n/* This helper checks if socket has IP_TRANSPARENT set */\nstatic inline bool inet_sk_transparent(const struct sock *sk)\n{\n\tswitch (sk->sk_state) {\n\tcase TCP_TIME_WAIT:\n\t\treturn inet_twsk(sk)->tw_transparent;\n\tcase TCP_NEW_SYN_RECV:\n\t\treturn inet_rsk(inet_reqsk(sk))->no_srccheck;\n\t}\n\treturn inet_sk(sk)->transparent;\n}\n\n/* Determines whether this is a thin stream (which may suffer from\n * increased latency). Used to trigger latency-reducing mechanisms.\n */\nstatic inline bool tcp_stream_is_thin(struct tcp_sock *tp)\n{\n\treturn tp->packets_out < 4 && !tcp_in_initial_slowstart(tp);\n}\n\n/* /proc */\nenum tcp_seq_states {\n\tTCP_SEQ_STATE_LISTENING,\n\tTCP_SEQ_STATE_ESTABLISHED,\n};\n\nint tcp_seq_open(struct inode *inode, struct file *file);\n\nstruct tcp_seq_afinfo {\n\tchar\t\t\t\t*name;\n\tsa_family_t\t\t\tfamily;\n\tconst struct file_operations\t*seq_fops;\n\tstruct seq_operations\t\tseq_ops;\n};\n\nstruct tcp_iter_state {\n\tstruct seq_net_private\tp;\n\tsa_family_t\t\tfamily;\n\tenum tcp_seq_states\tstate;\n\tstruct sock\t\t*syn_wait_sk;\n\tint\t\t\tbucket, offset, sbucket, num;\n\tloff_t\t\t\tlast_pos;\n};\n\nint tcp_proc_register(struct net *net, struct tcp_seq_afinfo *afinfo);\nvoid tcp_proc_unregister(struct net *net, struct tcp_seq_afinfo *afinfo);\n\nextern struct request_sock_ops tcp_request_sock_ops;\nextern struct request_sock_ops tcp6_request_sock_ops;\n\nvoid tcp_v4_destroy_sock(struct sock *sk);\n\nstruct sk_buff *tcp_gso_segment(struct sk_buff *skb,\n\t\t\t\tnetdev_features_t features);\nstruct sk_buff **tcp_gro_receive(struct sk_buff **head, struct sk_buff *skb);\nint tcp_gro_complete(struct sk_buff *skb);\n\nvoid __tcp_v4_send_check(struct sk_buff *skb, __be32 saddr, __be32 daddr);\n\nstatic inline u32 tcp_notsent_lowat(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\treturn tp->notsent_lowat ?: net->ipv4.sysctl_tcp_notsent_lowat;\n}\n\nstatic inline bool tcp_stream_memory_free(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tu32 notsent_bytes = tp->write_seq - tp->snd_nxt;\n\n\treturn notsent_bytes < tcp_notsent_lowat(tp);\n}\n\n#ifdef CONFIG_PROC_FS\nint tcp4_proc_init(void);\nvoid tcp4_proc_exit(void);\n#endif\n\nint tcp_rtx_synack(const struct sock *sk, struct request_sock *req);\nint tcp_conn_request(struct request_sock_ops *rsk_ops,\n\t\t     const struct tcp_request_sock_ops *af_ops,\n\t\t     struct sock *sk, struct sk_buff *skb);\n\n/* TCP af-specific functions */\nstruct tcp_sock_af_ops {\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key\t*(*md5_lookup) (const struct sock *sk,\n\t\t\t\t\t\tconst struct sock *addr_sk);\n\tint\t\t(*calc_md5_hash)(char *location,\n\t\t\t\t\t const struct tcp_md5sig_key *md5,\n\t\t\t\t\t const struct sock *sk,\n\t\t\t\t\t const struct sk_buff *skb);\n\tint\t\t(*md5_parse)(struct sock *sk,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int optlen);\n#endif\n};\n\nstruct tcp_request_sock_ops {\n\tu16 mss_clamp;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *(*req_md5_lookup)(const struct sock *sk,\n\t\t\t\t\t\t const struct sock *addr_sk);\n\tint\t\t(*calc_md5_hash) (char *location,\n\t\t\t\t\t  const struct tcp_md5sig_key *md5,\n\t\t\t\t\t  const struct sock *sk,\n\t\t\t\t\t  const struct sk_buff *skb);\n#endif\n\tvoid (*init_req)(struct request_sock *req,\n\t\t\t const struct sock *sk_listener,\n\t\t\t struct sk_buff *skb);\n#ifdef CONFIG_SYN_COOKIES\n\t__u32 (*cookie_init_seq)(const struct sk_buff *skb,\n\t\t\t\t __u16 *mss);\n#endif\n\tstruct dst_entry *(*route_req)(const struct sock *sk, struct flowi *fl,\n\t\t\t\t       const struct request_sock *req,\n\t\t\t\t       bool *strict);\n\t__u32 (*init_seq)(const struct sk_buff *skb);\n\tint (*send_synack)(const struct sock *sk, struct dst_entry *dst,\n\t\t\t   struct flowi *fl, struct request_sock *req,\n\t\t\t   struct tcp_fastopen_cookie *foc,\n\t\t\t   enum tcp_synack_type synack_type);\n};\n\n#ifdef CONFIG_SYN_COOKIES\nstatic inline __u32 cookie_init_sequence(const struct tcp_request_sock_ops *ops,\n\t\t\t\t\t const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t __u16 *mss)\n{\n\ttcp_synq_overflow(sk);\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESSENT);\n\treturn ops->cookie_init_seq(skb, mss);\n}\n#else\nstatic inline __u32 cookie_init_sequence(const struct tcp_request_sock_ops *ops,\n\t\t\t\t\t const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t __u16 *mss)\n{\n\treturn 0;\n}\n#endif\n\nint tcpv4_offload_init(void);\n\nvoid tcp_v4_init(void);\nvoid tcp_init(void);\n\n/* tcp_recovery.c */\n\n/* Flags to enable various loss recovery features. See below */\nextern int sysctl_tcp_recovery;\n\n/* Use TCP RACK to detect (some) tail and retransmit losses */\n#define TCP_RACK_LOST_RETRANS  0x1\n\nextern int tcp_rack_mark_lost(struct sock *sk);\n\nextern void tcp_rack_advance(struct tcp_sock *tp,\n\t\t\t     const struct skb_mstamp *xmit_time, u8 sacked);\n\n/*\n * Save and compile IPv4 options, return a pointer to it\n */\nstatic inline struct ip_options_rcu *tcp_v4_save_options(struct sk_buff *skb)\n{\n\tconst struct ip_options *opt = &TCP_SKB_CB(skb)->header.h4.opt;\n\tstruct ip_options_rcu *dopt = NULL;\n\n\tif (opt->optlen) {\n\t\tint opt_size = sizeof(*dopt) + opt->optlen;\n\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt && __ip_options_echo(&dopt->opt, skb, opt)) {\n\t\t\tkfree(dopt);\n\t\t\tdopt = NULL;\n\t\t}\n\t}\n\treturn dopt;\n}\n\n/* locally generated TCP pure ACKs have skb->truesize == 2\n * (check tcp_send_ack() in net/ipv4/tcp_output.c )\n * This is much faster than dissecting the packet to find out.\n * (Think of GRE encapsulations, IPv4, IPv6, ...)\n */\nstatic inline bool skb_is_tcp_pure_ack(const struct sk_buff *skb)\n{\n\treturn skb->truesize == 2;\n}\n\nstatic inline void skb_set_tcp_pure_ack(struct sk_buff *skb)\n{\n\tskb->truesize = 2;\n}\n\nstatic inline int tcp_inq(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint answ;\n\n\tif ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {\n\t\tansw = 0;\n\t} else if (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t   !tp->urg_data ||\n\t\t   before(tp->urg_seq, tp->copied_seq) ||\n\t\t   !before(tp->urg_seq, tp->rcv_nxt)) {\n\n\t\tansw = tp->rcv_nxt - tp->copied_seq;\n\n\t\t/* Subtract 1, if FIN was received */\n\t\tif (answ && sock_flag(sk, SOCK_DONE))\n\t\t\tansw--;\n\t} else {\n\t\tansw = tp->urg_seq - tp->copied_seq;\n\t}\n\n\treturn answ;\n}\n\nstatic inline void tcp_segs_in(struct tcp_sock *tp, const struct sk_buff *skb)\n{\n\tu16 segs_in;\n\n\tsegs_in = max_t(u16, 1, skb_shinfo(skb)->gso_segs);\n\ttp->segs_in += segs_in;\n\tif (skb->len > tcp_hdrlen(skb))\n\t\ttp->data_segs_in += segs_in;\n}\n\n/*\n * TCP listen path runs lockless.\n * We forced \"struct sock\" to be const qualified to make sure\n * we don't modify one of its field by mistake.\n * Here, we increment sk_drops which is an atomic_t, so we can safely\n * make sock writable again.\n */\nstatic inline void tcp_listendrop(const struct sock *sk)\n{\n\tatomic_inc(&((struct sock *)sk)->sk_drops);\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);\n}\n\n#endif\t/* _TCP_H */\n"], "fixing_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tDefinitions for the TCP module.\n *\n * Version:\t@(#)tcp.h\t1.0.5\t05/23/93\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n */\n#ifndef _TCP_H\n#define _TCP_H\n\n#define FASTRETRANS_DEBUG 1\n\n#include <linux/list.h>\n#include <linux/tcp.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/cryptohash.h>\n#include <linux/kref.h>\n#include <linux/ktime.h>\n\n#include <net/inet_connection_sock.h>\n#include <net/inet_timewait_sock.h>\n#include <net/inet_hashtables.h>\n#include <net/checksum.h>\n#include <net/request_sock.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n#include <net/ip.h>\n#include <net/tcp_states.h>\n#include <net/inet_ecn.h>\n#include <net/dst.h>\n\n#include <linux/seq_file.h>\n#include <linux/memcontrol.h>\n\nextern struct inet_hashinfo tcp_hashinfo;\n\nextern struct percpu_counter tcp_orphan_count;\nvoid tcp_time_wait(struct sock *sk, int state, int timeo);\n\n#define MAX_TCP_HEADER\t(128 + MAX_HEADER)\n#define MAX_TCP_OPTION_SPACE 40\n\n/*\n * Never offer a window over 32767 without using window scaling. Some\n * poor stacks do signed 16bit maths!\n */\n#define MAX_TCP_WINDOW\t\t32767U\n\n/* Minimal accepted MSS. It is (60+60+8) - (20+20). */\n#define TCP_MIN_MSS\t\t88U\n\n/* The least MTU to use for probing */\n#define TCP_BASE_MSS\t\t1024\n\n/* probing interval, default to 10 minutes as per RFC4821 */\n#define TCP_PROBE_INTERVAL\t600\n\n/* Specify interval when tcp mtu probing will stop */\n#define TCP_PROBE_THRESHOLD\t8\n\n/* After receiving this amount of duplicate ACKs fast retransmit starts. */\n#define TCP_FASTRETRANS_THRESH 3\n\n/* Maximal number of ACKs sent quickly to accelerate slow-start. */\n#define TCP_MAX_QUICKACKS\t16U\n\n/* urg_data states */\n#define TCP_URG_VALID\t0x0100\n#define TCP_URG_NOTYET\t0x0200\n#define TCP_URG_READ\t0x0400\n\n#define TCP_RETR1\t3\t/*\n\t\t\t\t * This is how many retries it does before it\n\t\t\t\t * tries to figure out if the gateway is\n\t\t\t\t * down. Minimal RFC value is 3; it corresponds\n\t\t\t\t * to ~3sec-8min depending on RTO.\n\t\t\t\t */\n\n#define TCP_RETR2\t15\t/*\n\t\t\t\t * This should take at least\n\t\t\t\t * 90 minutes to time out.\n\t\t\t\t * RFC1122 says that the limit is 100 sec.\n\t\t\t\t * 15 is ~13-30min depending on RTO.\n\t\t\t\t */\n\n#define TCP_SYN_RETRIES\t 6\t/* This is how many retries are done\n\t\t\t\t * when active opening a connection.\n\t\t\t\t * RFC1122 says the minimum retry MUST\n\t\t\t\t * be at least 180secs.  Nevertheless\n\t\t\t\t * this value is corresponding to\n\t\t\t\t * 63secs of retransmission with the\n\t\t\t\t * current initial RTO.\n\t\t\t\t */\n\n#define TCP_SYNACK_RETRIES 5\t/* This is how may retries are done\n\t\t\t\t * when passive opening a connection.\n\t\t\t\t * This is corresponding to 31secs of\n\t\t\t\t * retransmission with the current\n\t\t\t\t * initial RTO.\n\t\t\t\t */\n\n#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT\n\t\t\t\t  * state, about 60 seconds\t*/\n#define TCP_FIN_TIMEOUT\tTCP_TIMEWAIT_LEN\n                                 /* BSD style FIN_WAIT2 deadlock breaker.\n\t\t\t\t  * It used to be 3min, new value is 60sec,\n\t\t\t\t  * to combine FIN-WAIT-2 timeout with\n\t\t\t\t  * TIME-WAIT timer.\n\t\t\t\t  */\n\n#define TCP_DELACK_MAX\t((unsigned)(HZ/5))\t/* maximal time to delay before sending an ACK */\n#if HZ >= 100\n#define TCP_DELACK_MIN\t((unsigned)(HZ/25))\t/* minimal time to delay before sending an ACK */\n#define TCP_ATO_MIN\t((unsigned)(HZ/25))\n#else\n#define TCP_DELACK_MIN\t4U\n#define TCP_ATO_MIN\t4U\n#endif\n#define TCP_RTO_MAX\t((unsigned)(120*HZ))\n#define TCP_RTO_MIN\t((unsigned)(HZ/5))\n#define TCP_TIMEOUT_INIT ((unsigned)(1*HZ))\t/* RFC6298 2.1 initial RTO value\t*/\n#define TCP_TIMEOUT_FALLBACK ((unsigned)(3*HZ))\t/* RFC 1122 initial RTO value, now\n\t\t\t\t\t\t * used as a fallback RTO for the\n\t\t\t\t\t\t * initial data transmission if no\n\t\t\t\t\t\t * valid RTT sample has been acquired,\n\t\t\t\t\t\t * most likely due to retrans in 3WHS.\n\t\t\t\t\t\t */\n\n#define TCP_RESOURCE_PROBE_INTERVAL ((unsigned)(HZ/2U)) /* Maximal interval between probes\n\t\t\t\t\t                 * for local resources.\n\t\t\t\t\t                 */\n\n#define TCP_KEEPALIVE_TIME\t(120*60*HZ)\t/* two hours */\n#define TCP_KEEPALIVE_PROBES\t9\t\t/* Max of 9 keepalive probes\t*/\n#define TCP_KEEPALIVE_INTVL\t(75*HZ)\n\n#define MAX_TCP_KEEPIDLE\t32767\n#define MAX_TCP_KEEPINTVL\t32767\n#define MAX_TCP_KEEPCNT\t\t127\n#define MAX_TCP_SYNCNT\t\t127\n\n#define TCP_SYNQ_INTERVAL\t(HZ/5)\t/* Period of SYNACK timer */\n\n#define TCP_PAWS_24DAYS\t(60 * 60 * 24 * 24)\n#define TCP_PAWS_MSL\t60\t\t/* Per-host timestamps are invalidated\n\t\t\t\t\t * after this time. It should be equal\n\t\t\t\t\t * (or greater than) TCP_TIMEWAIT_LEN\n\t\t\t\t\t * to provide reliability equal to one\n\t\t\t\t\t * provided by timewait state.\n\t\t\t\t\t */\n#define TCP_PAWS_WINDOW\t1\t\t/* Replay window for per-host\n\t\t\t\t\t * timestamps. It must be less than\n\t\t\t\t\t * minimal timewait lifetime.\n\t\t\t\t\t */\n/*\n *\tTCP option\n */\n\n#define TCPOPT_NOP\t\t1\t/* Padding */\n#define TCPOPT_EOL\t\t0\t/* End of options */\n#define TCPOPT_MSS\t\t2\t/* Segment size negotiating */\n#define TCPOPT_WINDOW\t\t3\t/* Window scaling */\n#define TCPOPT_SACK_PERM        4       /* SACK Permitted */\n#define TCPOPT_SACK             5       /* SACK Block */\n#define TCPOPT_TIMESTAMP\t8\t/* Better RTT estimations/PAWS */\n#define TCPOPT_MD5SIG\t\t19\t/* MD5 Signature (RFC2385) */\n#define TCPOPT_FASTOPEN\t\t34\t/* Fast open (RFC7413) */\n#define TCPOPT_EXP\t\t254\t/* Experimental */\n/* Magic number to be after the option value for sharing TCP\n * experimental options. See draft-ietf-tcpm-experimental-options-00.txt\n */\n#define TCPOPT_FASTOPEN_MAGIC\t0xF989\n\n/*\n *     TCP option lengths\n */\n\n#define TCPOLEN_MSS            4\n#define TCPOLEN_WINDOW         3\n#define TCPOLEN_SACK_PERM      2\n#define TCPOLEN_TIMESTAMP      10\n#define TCPOLEN_MD5SIG         18\n#define TCPOLEN_FASTOPEN_BASE  2\n#define TCPOLEN_EXP_FASTOPEN_BASE  4\n\n/* But this is what stacks really send out. */\n#define TCPOLEN_TSTAMP_ALIGNED\t\t12\n#define TCPOLEN_WSCALE_ALIGNED\t\t4\n#define TCPOLEN_SACKPERM_ALIGNED\t4\n#define TCPOLEN_SACK_BASE\t\t2\n#define TCPOLEN_SACK_BASE_ALIGNED\t4\n#define TCPOLEN_SACK_PERBLOCK\t\t8\n#define TCPOLEN_MD5SIG_ALIGNED\t\t20\n#define TCPOLEN_MSS_ALIGNED\t\t4\n\n/* Flags in tp->nonagle */\n#define TCP_NAGLE_OFF\t\t1\t/* Nagle's algo is disabled */\n#define TCP_NAGLE_CORK\t\t2\t/* Socket is corked\t    */\n#define TCP_NAGLE_PUSH\t\t4\t/* Cork is overridden for already queued data */\n\n/* TCP thin-stream limits */\n#define TCP_THIN_LINEAR_RETRIES 6       /* After 6 linear retries, do exp. backoff */\n\n/* TCP initial congestion window as per rfc6928 */\n#define TCP_INIT_CWND\t\t10\n\n/* Bit Flags for sysctl_tcp_fastopen */\n#define\tTFO_CLIENT_ENABLE\t1\n#define\tTFO_SERVER_ENABLE\t2\n#define\tTFO_CLIENT_NO_COOKIE\t4\t/* Data in SYN w/o cookie option */\n\n/* Accept SYN data w/o any cookie option */\n#define\tTFO_SERVER_COOKIE_NOT_REQD\t0x200\n\n/* Force enable TFO on all listeners, i.e., not requiring the\n * TCP_FASTOPEN socket option. SOCKOPT1/2 determine how to set max_qlen.\n */\n#define\tTFO_SERVER_WO_SOCKOPT1\t0x400\n#define\tTFO_SERVER_WO_SOCKOPT2\t0x800\n\nextern struct inet_timewait_death_row tcp_death_row;\n\n/* sysctl variables for tcp */\nextern int sysctl_tcp_timestamps;\nextern int sysctl_tcp_window_scaling;\nextern int sysctl_tcp_sack;\nextern int sysctl_tcp_fastopen;\nextern int sysctl_tcp_retrans_collapse;\nextern int sysctl_tcp_stdurg;\nextern int sysctl_tcp_rfc1337;\nextern int sysctl_tcp_abort_on_overflow;\nextern int sysctl_tcp_max_orphans;\nextern int sysctl_tcp_fack;\nextern int sysctl_tcp_reordering;\nextern int sysctl_tcp_max_reordering;\nextern int sysctl_tcp_dsack;\nextern long sysctl_tcp_mem[3];\nextern int sysctl_tcp_wmem[3];\nextern int sysctl_tcp_rmem[3];\nextern int sysctl_tcp_app_win;\nextern int sysctl_tcp_adv_win_scale;\nextern int sysctl_tcp_tw_reuse;\nextern int sysctl_tcp_frto;\nextern int sysctl_tcp_low_latency;\nextern int sysctl_tcp_nometrics_save;\nextern int sysctl_tcp_moderate_rcvbuf;\nextern int sysctl_tcp_tso_win_divisor;\nextern int sysctl_tcp_workaround_signed_windows;\nextern int sysctl_tcp_slow_start_after_idle;\nextern int sysctl_tcp_thin_linear_timeouts;\nextern int sysctl_tcp_thin_dupack;\nextern int sysctl_tcp_early_retrans;\nextern int sysctl_tcp_limit_output_bytes;\nextern int sysctl_tcp_challenge_ack_limit;\nextern int sysctl_tcp_min_tso_segs;\nextern int sysctl_tcp_min_rtt_wlen;\nextern int sysctl_tcp_autocorking;\nextern int sysctl_tcp_invalid_ratelimit;\nextern int sysctl_tcp_pacing_ss_ratio;\nextern int sysctl_tcp_pacing_ca_ratio;\n\nextern atomic_long_t tcp_memory_allocated;\nextern struct percpu_counter tcp_sockets_allocated;\nextern int tcp_memory_pressure;\n\n/* optimized version of sk_under_memory_pressure() for TCP sockets */\nstatic inline bool tcp_under_memory_pressure(const struct sock *sk)\n{\n\tif (mem_cgroup_sockets_enabled && sk->sk_memcg &&\n\t    mem_cgroup_under_socket_pressure(sk->sk_memcg))\n\t\treturn true;\n\n\treturn tcp_memory_pressure;\n}\n/*\n * The next routines deal with comparing 32 bit unsigned ints\n * and worry about wraparound (automatic with unsigned arithmetic).\n */\n\nstatic inline bool before(__u32 seq1, __u32 seq2)\n{\n        return (__s32)(seq1-seq2) < 0;\n}\n#define after(seq2, seq1) \tbefore(seq1, seq2)\n\n/* is s2<=s1<=s3 ? */\nstatic inline bool between(__u32 seq1, __u32 seq2, __u32 seq3)\n{\n\treturn seq3 - seq2 >= seq1 - seq2;\n}\n\nstatic inline bool tcp_out_of_memory(struct sock *sk)\n{\n\tif (sk->sk_wmem_queued > SOCK_MIN_SNDBUF &&\n\t    sk_memory_allocated(sk) > sk_prot_mem_limits(sk, 2))\n\t\treturn true;\n\treturn false;\n}\n\nvoid sk_forced_mem_schedule(struct sock *sk, int size);\n\nstatic inline bool tcp_too_many_orphans(struct sock *sk, int shift)\n{\n\tstruct percpu_counter *ocp = sk->sk_prot->orphan_count;\n\tint orphans = percpu_counter_read_positive(ocp);\n\n\tif (orphans << shift > sysctl_tcp_max_orphans) {\n\t\torphans = percpu_counter_sum_positive(ocp);\n\t\tif (orphans << shift > sysctl_tcp_max_orphans)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool tcp_check_oom(struct sock *sk, int shift);\n\n\nextern struct proto tcp_prot;\n\n#define TCP_INC_STATS(net, field)\tSNMP_INC_STATS((net)->mib.tcp_statistics, field)\n#define __TCP_INC_STATS(net, field)\t__SNMP_INC_STATS((net)->mib.tcp_statistics, field)\n#define TCP_DEC_STATS(net, field)\tSNMP_DEC_STATS((net)->mib.tcp_statistics, field)\n#define TCP_ADD_STATS(net, field, val)\tSNMP_ADD_STATS((net)->mib.tcp_statistics, field, val)\n\nvoid tcp_tasklet_init(void);\n\nvoid tcp_v4_err(struct sk_buff *skb, u32);\n\nvoid tcp_shutdown(struct sock *sk, int how);\n\nvoid tcp_v4_early_demux(struct sk_buff *skb);\nint tcp_v4_rcv(struct sk_buff *skb);\n\nint tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);\nint tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);\nint tcp_sendpage(struct sock *sk, struct page *page, int offset, size_t size,\n\t\t int flags);\nvoid tcp_release_cb(struct sock *sk);\nvoid tcp_wfree(struct sk_buff *skb);\nvoid tcp_write_timer_handler(struct sock *sk);\nvoid tcp_delack_timer_handler(struct sock *sk);\nint tcp_ioctl(struct sock *sk, int cmd, unsigned long arg);\nint tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb);\nvoid tcp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct tcphdr *th, unsigned int len);\nvoid tcp_rcv_space_adjust(struct sock *sk);\nint tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp);\nvoid tcp_twsk_destructor(struct sock *sk);\nssize_t tcp_splice_read(struct socket *sk, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags);\n\nstatic inline void tcp_dec_quickack_mode(struct sock *sk,\n\t\t\t\t\t const unsigned int pkts)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ack.quick) {\n\t\tif (pkts >= icsk->icsk_ack.quick) {\n\t\t\ticsk->icsk_ack.quick = 0;\n\t\t\t/* Leaving quickack mode we deflate ATO. */\n\t\t\ticsk->icsk_ack.ato   = TCP_ATO_MIN;\n\t\t} else\n\t\t\ticsk->icsk_ack.quick -= pkts;\n\t}\n}\n\n#define\tTCP_ECN_OK\t\t1\n#define\tTCP_ECN_QUEUE_CWR\t2\n#define\tTCP_ECN_DEMAND_CWR\t4\n#define\tTCP_ECN_SEEN\t\t8\n\nenum tcp_tw_status {\n\tTCP_TW_SUCCESS = 0,\n\tTCP_TW_RST = 1,\n\tTCP_TW_ACK = 2,\n\tTCP_TW_SYN = 3\n};\n\n\nenum tcp_tw_status tcp_timewait_state_process(struct inet_timewait_sock *tw,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      const struct tcphdr *th);\nstruct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct request_sock *req, bool fastopen);\nint tcp_child_process(struct sock *parent, struct sock *child,\n\t\t      struct sk_buff *skb);\nvoid tcp_enter_loss(struct sock *sk);\nvoid tcp_clear_retrans(struct tcp_sock *tp);\nvoid tcp_update_metrics(struct sock *sk);\nvoid tcp_init_metrics(struct sock *sk);\nvoid tcp_metrics_init(void);\nbool tcp_peer_is_proven(struct request_sock *req, struct dst_entry *dst,\n\t\t\tbool paws_check, bool timestamps);\nbool tcp_remember_stamp(struct sock *sk);\nbool tcp_tw_remember_stamp(struct inet_timewait_sock *tw);\nvoid tcp_fetch_timewait_stamp(struct sock *sk, struct dst_entry *dst);\nvoid tcp_disable_fack(struct tcp_sock *tp);\nvoid tcp_close(struct sock *sk, long timeout);\nvoid tcp_init_sock(struct sock *sk);\nunsigned int tcp_poll(struct file *file, struct socket *sock,\n\t\t      struct poll_table_struct *wait);\nint tcp_getsockopt(struct sock *sk, int level, int optname,\n\t\t   char __user *optval, int __user *optlen);\nint tcp_setsockopt(struct sock *sk, int level, int optname,\n\t\t   char __user *optval, unsigned int optlen);\nint compat_tcp_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen);\nint compat_tcp_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen);\nvoid tcp_set_keepalive(struct sock *sk, int val);\nvoid tcp_syn_ack_timeout(const struct request_sock *req);\nint tcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,\n\t\tint flags, int *addr_len);\nvoid tcp_parse_options(const struct sk_buff *skb,\n\t\t       struct tcp_options_received *opt_rx,\n\t\t       int estab, struct tcp_fastopen_cookie *foc);\nconst u8 *tcp_parse_md5sig_option(const struct tcphdr *th);\n\n/*\n *\tTCP v4 functions exported for the inet6 API\n */\n\nvoid tcp_v4_send_check(struct sock *sk, struct sk_buff *skb);\nvoid tcp_v4_mtu_reduced(struct sock *sk);\nvoid tcp_req_err(struct sock *sk, u32 seq, bool abort);\nint tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb);\nstruct sock *tcp_create_openreq_child(const struct sock *sk,\n\t\t\t\t      struct request_sock *req,\n\t\t\t\t      struct sk_buff *skb);\nvoid tcp_ca_openreq_child(struct sock *sk, const struct dst_entry *dst);\nstruct sock *tcp_v4_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req,\n\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t  struct request_sock *req_unhash,\n\t\t\t\t  bool *own_req);\nint tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);\nint tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);\nint tcp_connect(struct sock *sk);\nenum tcp_synack_type {\n\tTCP_SYNACK_NORMAL,\n\tTCP_SYNACK_FASTOPEN,\n\tTCP_SYNACK_COOKIE,\n};\nstruct sk_buff *tcp_make_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t\tstruct request_sock *req,\n\t\t\t\tstruct tcp_fastopen_cookie *foc,\n\t\t\t\tenum tcp_synack_type synack_type);\nint tcp_disconnect(struct sock *sk, int flags);\n\nvoid tcp_finish_connect(struct sock *sk, struct sk_buff *skb);\nint tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size);\nvoid inet_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb);\n\n/* From syncookies.c */\nstruct sock *tcp_get_cookie_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t struct request_sock *req,\n\t\t\t\t struct dst_entry *dst);\nint __cookie_v4_check(const struct iphdr *iph, const struct tcphdr *th,\n\t\t      u32 cookie);\nstruct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb);\n#ifdef CONFIG_SYN_COOKIES\n\n/* Syncookies use a monotonic timer which increments every 60 seconds.\n * This counter is used both as a hash input and partially encoded into\n * the cookie value.  A cookie is only validated further if the delta\n * between the current counter value and the encoded one is less than this,\n * i.e. a sent cookie is valid only at most for 2*60 seconds (or less if\n * the counter advances immediately after a cookie is generated).\n */\n#define MAX_SYNCOOKIE_AGE\t2\n#define TCP_SYNCOOKIE_PERIOD\t(60 * HZ)\n#define TCP_SYNCOOKIE_VALID\t(MAX_SYNCOOKIE_AGE * TCP_SYNCOOKIE_PERIOD)\n\n/* syncookies: remember time of last synqueue overflow\n * But do not dirty this field too often (once per second is enough)\n * It is racy as we do not hold a lock, but race is very minor.\n */\nstatic inline void tcp_synq_overflow(const struct sock *sk)\n{\n\tunsigned long last_overflow = tcp_sk(sk)->rx_opt.ts_recent_stamp;\n\tunsigned long now = jiffies;\n\n\tif (time_after(now, last_overflow + HZ))\n\t\ttcp_sk(sk)->rx_opt.ts_recent_stamp = now;\n}\n\n/* syncookies: no recent synqueue overflow on this listening socket? */\nstatic inline bool tcp_synq_no_recent_overflow(const struct sock *sk)\n{\n\tunsigned long last_overflow = tcp_sk(sk)->rx_opt.ts_recent_stamp;\n\n\treturn time_after(jiffies, last_overflow + TCP_SYNCOOKIE_VALID);\n}\n\nstatic inline u32 tcp_cookie_time(void)\n{\n\tu64 val = get_jiffies_64();\n\n\tdo_div(val, TCP_SYNCOOKIE_PERIOD);\n\treturn val;\n}\n\nu32 __cookie_v4_init_sequence(const struct iphdr *iph, const struct tcphdr *th,\n\t\t\t      u16 *mssp);\n__u32 cookie_v4_init_sequence(const struct sk_buff *skb, __u16 *mss);\n__u32 cookie_init_timestamp(struct request_sock *req);\nbool cookie_timestamp_decode(struct tcp_options_received *opt);\nbool cookie_ecn_ok(const struct tcp_options_received *opt,\n\t\t   const struct net *net, const struct dst_entry *dst);\n\n/* From net/ipv6/syncookies.c */\nint __cookie_v6_check(const struct ipv6hdr *iph, const struct tcphdr *th,\n\t\t      u32 cookie);\nstruct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb);\n\nu32 __cookie_v6_init_sequence(const struct ipv6hdr *iph,\n\t\t\t      const struct tcphdr *th, u16 *mssp);\n__u32 cookie_v6_init_sequence(const struct sk_buff *skb, __u16 *mss);\n#endif\n/* tcp_output.c */\n\nvoid __tcp_push_pending_frames(struct sock *sk, unsigned int cur_mss,\n\t\t\t       int nonagle);\nbool tcp_may_send_now(struct sock *sk);\nint __tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs);\nint tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs);\nvoid tcp_retransmit_timer(struct sock *sk);\nvoid tcp_xmit_retransmit_queue(struct sock *);\nvoid tcp_simple_retransmit(struct sock *);\nint tcp_trim_head(struct sock *, struct sk_buff *, u32);\nint tcp_fragment(struct sock *, struct sk_buff *, u32, unsigned int, gfp_t);\n\nvoid tcp_send_probe0(struct sock *);\nvoid tcp_send_partial(struct sock *);\nint tcp_write_wakeup(struct sock *, int mib);\nvoid tcp_send_fin(struct sock *sk);\nvoid tcp_send_active_reset(struct sock *sk, gfp_t priority);\nint tcp_send_synack(struct sock *);\nvoid tcp_push_one(struct sock *, unsigned int mss_now);\nvoid tcp_send_ack(struct sock *sk);\nvoid tcp_send_delayed_ack(struct sock *sk);\nvoid tcp_send_loss_probe(struct sock *sk);\nbool tcp_schedule_loss_probe(struct sock *sk);\nvoid tcp_skb_collapse_tstamp(struct sk_buff *skb,\n\t\t\t     const struct sk_buff *next_skb);\n\n/* tcp_input.c */\nvoid tcp_resume_early_retransmit(struct sock *sk);\nvoid tcp_rearm_rto(struct sock *sk);\nvoid tcp_synack_rtt_meas(struct sock *sk, struct request_sock *req);\nvoid tcp_reset(struct sock *sk);\nvoid tcp_skb_mark_lost_uncond_verify(struct tcp_sock *tp, struct sk_buff *skb);\nvoid tcp_fin(struct sock *sk);\n\n/* tcp_timer.c */\nvoid tcp_init_xmit_timers(struct sock *);\nstatic inline void tcp_clear_xmit_timers(struct sock *sk)\n{\n\tinet_csk_clear_xmit_timers(sk);\n}\n\nunsigned int tcp_sync_mss(struct sock *sk, u32 pmtu);\nunsigned int tcp_current_mss(struct sock *sk);\n\n/* Bound MSS / TSO packet size with the half of the window */\nstatic inline int tcp_bound_to_half_wnd(struct tcp_sock *tp, int pktsize)\n{\n\tint cutoff;\n\n\t/* When peer uses tiny windows, there is no use in packetizing\n\t * to sub-MSS pieces for the sake of SWS or making sure there\n\t * are enough packets in the pipe for fast recovery.\n\t *\n\t * On the other hand, for extremely large MSS devices, handling\n\t * smaller than MSS windows in this way does make sense.\n\t */\n\tif (tp->max_window > TCP_MSS_DEFAULT)\n\t\tcutoff = (tp->max_window >> 1);\n\telse\n\t\tcutoff = tp->max_window;\n\n\tif (cutoff && pktsize > cutoff)\n\t\treturn max_t(int, cutoff, 68U - tp->tcp_header_len);\n\telse\n\t\treturn pktsize;\n}\n\n/* tcp.c */\nvoid tcp_get_info(struct sock *, struct tcp_info *);\n\n/* Read 'sendfile()'-style from a TCP socket */\ntypedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *,\n\t\t\t\tunsigned int, size_t);\nint tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor);\n\nvoid tcp_initialize_rcv_mss(struct sock *sk);\n\nint tcp_mtu_to_mss(struct sock *sk, int pmtu);\nint tcp_mss_to_mtu(struct sock *sk, int mss);\nvoid tcp_mtup_init(struct sock *sk);\nvoid tcp_init_buffer_space(struct sock *sk);\n\nstatic inline void tcp_bound_rto(const struct sock *sk)\n{\n\tif (inet_csk(sk)->icsk_rto > TCP_RTO_MAX)\n\t\tinet_csk(sk)->icsk_rto = TCP_RTO_MAX;\n}\n\nstatic inline u32 __tcp_set_rto(const struct tcp_sock *tp)\n{\n\treturn usecs_to_jiffies((tp->srtt_us >> 3) + tp->rttvar_us);\n}\n\nstatic inline void __tcp_fast_path_on(struct tcp_sock *tp, u32 snd_wnd)\n{\n\ttp->pred_flags = htonl((tp->tcp_header_len << 26) |\n\t\t\t       ntohl(TCP_FLAG_ACK) |\n\t\t\t       snd_wnd);\n}\n\nstatic inline void tcp_fast_path_on(struct tcp_sock *tp)\n{\n\t__tcp_fast_path_on(tp, tp->snd_wnd >> tp->rx_opt.snd_wscale);\n}\n\nstatic inline void tcp_fast_path_check(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (skb_queue_empty(&tp->out_of_order_queue) &&\n\t    tp->rcv_wnd &&\n\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf &&\n\t    !tp->urg_data)\n\t\ttcp_fast_path_on(tp);\n}\n\n/* Compute the actual rto_min value */\nstatic inline u32 tcp_rto_min(struct sock *sk)\n{\n\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\tu32 rto_min = TCP_RTO_MIN;\n\n\tif (dst && dst_metric_locked(dst, RTAX_RTO_MIN))\n\t\trto_min = dst_metric_rtt(dst, RTAX_RTO_MIN);\n\treturn rto_min;\n}\n\nstatic inline u32 tcp_rto_min_us(struct sock *sk)\n{\n\treturn jiffies_to_usecs(tcp_rto_min(sk));\n}\n\nstatic inline bool tcp_ca_dst_locked(const struct dst_entry *dst)\n{\n\treturn dst_metric_locked(dst, RTAX_CC_ALGO);\n}\n\n/* Minimum RTT in usec. ~0 means not available. */\nstatic inline u32 tcp_min_rtt(const struct tcp_sock *tp)\n{\n\treturn tp->rtt_min[0].rtt;\n}\n\n/* Compute the actual receive window we are currently advertising.\n * Rcv_nxt can be after the window if our peer push more data\n * than the offered window.\n */\nstatic inline u32 tcp_receive_window(const struct tcp_sock *tp)\n{\n\ts32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;\n\n\tif (win < 0)\n\t\twin = 0;\n\treturn (u32) win;\n}\n\n/* Choose a new window, without checks for shrinking, and without\n * scaling applied to the result.  The caller does these things\n * if necessary.  This is a \"raw\" window selection.\n */\nu32 __tcp_select_window(struct sock *sk);\n\nvoid tcp_send_window_probe(struct sock *sk);\n\n/* TCP timestamps are only 32-bits, this causes a slight\n * complication on 64-bit systems since we store a snapshot\n * of jiffies in the buffer control blocks below.  We decided\n * to use only the low 32-bits of jiffies and hide the ugly\n * casts with the following macro.\n */\n#define tcp_time_stamp\t\t((__u32)(jiffies))\n\nstatic inline u32 tcp_skb_timestamp(const struct sk_buff *skb)\n{\n\treturn skb->skb_mstamp.stamp_jiffies;\n}\n\n\n#define tcp_flag_byte(th) (((u_int8_t *)th)[13])\n\n#define TCPHDR_FIN 0x01\n#define TCPHDR_SYN 0x02\n#define TCPHDR_RST 0x04\n#define TCPHDR_PSH 0x08\n#define TCPHDR_ACK 0x10\n#define TCPHDR_URG 0x20\n#define TCPHDR_ECE 0x40\n#define TCPHDR_CWR 0x80\n\n#define TCPHDR_SYN_ECN\t(TCPHDR_SYN | TCPHDR_ECE | TCPHDR_CWR)\n\n/* This is what the send packet queuing engine uses to pass\n * TCP per-packet control information to the transmission code.\n * We also store the host-order sequence numbers in here too.\n * This is 44 bytes if IPV6 is enabled.\n * If this grows please adjust skbuff.h:skbuff->cb[xxx] size appropriately.\n */\nstruct tcp_skb_cb {\n\t__u32\t\tseq;\t\t/* Starting sequence number\t*/\n\t__u32\t\tend_seq;\t/* SEQ + FIN + SYN + datalen\t*/\n\tunion {\n\t\t/* Note : tcp_tw_isn is used in input path only\n\t\t *\t  (isn chosen by tcp_timewait_state_process())\n\t\t *\n\t\t * \t  tcp_gso_segs/size are used in write queue only,\n\t\t *\t  cf tcp_skb_pcount()/tcp_skb_mss()\n\t\t */\n\t\t__u32\t\ttcp_tw_isn;\n\t\tstruct {\n\t\t\tu16\ttcp_gso_segs;\n\t\t\tu16\ttcp_gso_size;\n\t\t};\n\t};\n\t__u8\t\ttcp_flags;\t/* TCP header flags. (tcp[13])\t*/\n\n\t__u8\t\tsacked;\t\t/* State flags for SACK/FACK.\t*/\n#define TCPCB_SACKED_ACKED\t0x01\t/* SKB ACK'd by a SACK block\t*/\n#define TCPCB_SACKED_RETRANS\t0x02\t/* SKB retransmitted\t\t*/\n#define TCPCB_LOST\t\t0x04\t/* SKB is lost\t\t\t*/\n#define TCPCB_TAGBITS\t\t0x07\t/* All tag bits\t\t\t*/\n#define TCPCB_REPAIRED\t\t0x10\t/* SKB repaired (no skb_mstamp)\t*/\n#define TCPCB_EVER_RETRANS\t0x80\t/* Ever retransmitted frame\t*/\n#define TCPCB_RETRANS\t\t(TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS| \\\n\t\t\t\tTCPCB_REPAIRED)\n\n\t__u8\t\tip_dsfield;\t/* IPv4 tos or IPv6 dsfield\t*/\n\t__u8\t\ttxstamp_ack:1,\t/* Record TX timestamp for ack? */\n\t\t\teor:1,\t\t/* Is skb MSG_EOR marked? */\n\t\t\tunused:6;\n\t__u32\t\tack_seq;\t/* Sequence number ACK'd\t*/\n\tunion {\n\t\tstruct {\n\t\t\t/* There is space for up to 20 bytes */\n\t\t\t__u32 in_flight;/* Bytes in flight when packet sent */\n\t\t} tx;   /* only used for outgoing skbs */\n\t\tunion {\n\t\t\tstruct inet_skb_parm\th4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tstruct inet6_skb_parm\th6;\n#endif\n\t\t} header;\t/* For incoming skbs */\n\t};\n};\n\n#define TCP_SKB_CB(__skb)\t((struct tcp_skb_cb *)&((__skb)->cb[0]))\n\n\n#if IS_ENABLED(CONFIG_IPV6)\n/* This is the variant of inet6_iif() that must be used by TCP,\n * as TCP moves IP6CB into a different location in skb->cb[]\n */\nstatic inline int tcp_v6_iif(const struct sk_buff *skb)\n{\n\tbool l3_slave = skb_l3mdev_slave(TCP_SKB_CB(skb)->header.h6.flags);\n\n\treturn l3_slave ? skb->skb_iif : TCP_SKB_CB(skb)->header.h6.iif;\n}\n#endif\n\n/* Due to TSO, an SKB can be composed of multiple actual\n * packets.  To keep these tracked properly, we use this.\n */\nstatic inline int tcp_skb_pcount(const struct sk_buff *skb)\n{\n\treturn TCP_SKB_CB(skb)->tcp_gso_segs;\n}\n\nstatic inline void tcp_skb_pcount_set(struct sk_buff *skb, int segs)\n{\n\tTCP_SKB_CB(skb)->tcp_gso_segs = segs;\n}\n\nstatic inline void tcp_skb_pcount_add(struct sk_buff *skb, int segs)\n{\n\tTCP_SKB_CB(skb)->tcp_gso_segs += segs;\n}\n\n/* This is valid iff skb is in write queue and tcp_skb_pcount() > 1. */\nstatic inline int tcp_skb_mss(const struct sk_buff *skb)\n{\n\treturn TCP_SKB_CB(skb)->tcp_gso_size;\n}\n\nstatic inline bool tcp_skb_can_collapse_to(const struct sk_buff *skb)\n{\n\treturn likely(!TCP_SKB_CB(skb)->eor);\n}\n\n/* Events passed to congestion control interface */\nenum tcp_ca_event {\n\tCA_EVENT_TX_START,\t/* first transmit when no packets in flight */\n\tCA_EVENT_CWND_RESTART,\t/* congestion window restart */\n\tCA_EVENT_COMPLETE_CWR,\t/* end of congestion recovery */\n\tCA_EVENT_LOSS,\t\t/* loss timeout */\n\tCA_EVENT_ECN_NO_CE,\t/* ECT set, but not CE marked */\n\tCA_EVENT_ECN_IS_CE,\t/* received CE marked IP packet */\n\tCA_EVENT_DELAYED_ACK,\t/* Delayed ack is sent */\n\tCA_EVENT_NON_DELAYED_ACK,\n};\n\n/* Information about inbound ACK, passed to cong_ops->in_ack_event() */\nenum tcp_ca_ack_event_flags {\n\tCA_ACK_SLOWPATH\t\t= (1 << 0),\t/* In slow path processing */\n\tCA_ACK_WIN_UPDATE\t= (1 << 1),\t/* ACK updated window */\n\tCA_ACK_ECE\t\t= (1 << 2),\t/* ECE bit is set on ack */\n};\n\n/*\n * Interface for adding new TCP congestion control handlers\n */\n#define TCP_CA_NAME_MAX\t16\n#define TCP_CA_MAX\t128\n#define TCP_CA_BUF_MAX\t(TCP_CA_NAME_MAX*TCP_CA_MAX)\n\n#define TCP_CA_UNSPEC\t0\n\n/* Algorithm can be set on socket without CAP_NET_ADMIN privileges */\n#define TCP_CONG_NON_RESTRICTED 0x1\n/* Requires ECN/ECT set on all packets */\n#define TCP_CONG_NEEDS_ECN\t0x2\n\nunion tcp_cc_info;\n\nstruct ack_sample {\n\tu32 pkts_acked;\n\ts32 rtt_us;\n\tu32 in_flight;\n};\n\nstruct tcp_congestion_ops {\n\tstruct list_head\tlist;\n\tu32 key;\n\tu32 flags;\n\n\t/* initialize private data (optional) */\n\tvoid (*init)(struct sock *sk);\n\t/* cleanup private data  (optional) */\n\tvoid (*release)(struct sock *sk);\n\n\t/* return slow start threshold (required) */\n\tu32 (*ssthresh)(struct sock *sk);\n\t/* do new cwnd calculation (required) */\n\tvoid (*cong_avoid)(struct sock *sk, u32 ack, u32 acked);\n\t/* call before changing ca_state (optional) */\n\tvoid (*set_state)(struct sock *sk, u8 new_state);\n\t/* call when cwnd event occurs (optional) */\n\tvoid (*cwnd_event)(struct sock *sk, enum tcp_ca_event ev);\n\t/* call when ack arrives (optional) */\n\tvoid (*in_ack_event)(struct sock *sk, u32 flags);\n\t/* new value of cwnd after loss (optional) */\n\tu32  (*undo_cwnd)(struct sock *sk);\n\t/* hook for packet ack accounting (optional) */\n\tvoid (*pkts_acked)(struct sock *sk, const struct ack_sample *sample);\n\t/* get info for inet_diag (optional) */\n\tsize_t (*get_info)(struct sock *sk, u32 ext, int *attr,\n\t\t\t   union tcp_cc_info *info);\n\n\tchar \t\tname[TCP_CA_NAME_MAX];\n\tstruct module \t*owner;\n};\n\nint tcp_register_congestion_control(struct tcp_congestion_ops *type);\nvoid tcp_unregister_congestion_control(struct tcp_congestion_ops *type);\n\nvoid tcp_assign_congestion_control(struct sock *sk);\nvoid tcp_init_congestion_control(struct sock *sk);\nvoid tcp_cleanup_congestion_control(struct sock *sk);\nint tcp_set_default_congestion_control(const char *name);\nvoid tcp_get_default_congestion_control(char *name);\nvoid tcp_get_available_congestion_control(char *buf, size_t len);\nvoid tcp_get_allowed_congestion_control(char *buf, size_t len);\nint tcp_set_allowed_congestion_control(char *allowed);\nint tcp_set_congestion_control(struct sock *sk, const char *name);\nu32 tcp_slow_start(struct tcp_sock *tp, u32 acked);\nvoid tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w, u32 acked);\n\nu32 tcp_reno_ssthresh(struct sock *sk);\nvoid tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 acked);\nextern struct tcp_congestion_ops tcp_reno;\n\nstruct tcp_congestion_ops *tcp_ca_find_key(u32 key);\nu32 tcp_ca_get_key_by_name(const char *name, bool *ecn_ca);\n#ifdef CONFIG_INET\nchar *tcp_ca_get_name_by_key(u32 key, char *buffer);\n#else\nstatic inline char *tcp_ca_get_name_by_key(u32 key, char *buffer)\n{\n\treturn NULL;\n}\n#endif\n\nstatic inline bool tcp_ca_needs_ecn(const struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\treturn icsk->icsk_ca_ops->flags & TCP_CONG_NEEDS_ECN;\n}\n\nstatic inline void tcp_set_ca_state(struct sock *sk, const u8 ca_state)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_ops->set_state)\n\t\ticsk->icsk_ca_ops->set_state(sk, ca_state);\n\ticsk->icsk_ca_state = ca_state;\n}\n\nstatic inline void tcp_ca_event(struct sock *sk, const enum tcp_ca_event event)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_ops->cwnd_event)\n\t\ticsk->icsk_ca_ops->cwnd_event(sk, event);\n}\n\n/* These functions determine how the current flow behaves in respect of SACK\n * handling. SACK is negotiated with the peer, and therefore it can vary\n * between different flows.\n *\n * tcp_is_sack - SACK enabled\n * tcp_is_reno - No SACK\n * tcp_is_fack - FACK enabled, implies SACK enabled\n */\nstatic inline int tcp_is_sack(const struct tcp_sock *tp)\n{\n\treturn tp->rx_opt.sack_ok;\n}\n\nstatic inline bool tcp_is_reno(const struct tcp_sock *tp)\n{\n\treturn !tcp_is_sack(tp);\n}\n\nstatic inline bool tcp_is_fack(const struct tcp_sock *tp)\n{\n\treturn tp->rx_opt.sack_ok & TCP_FACK_ENABLED;\n}\n\nstatic inline void tcp_enable_fack(struct tcp_sock *tp)\n{\n\ttp->rx_opt.sack_ok |= TCP_FACK_ENABLED;\n}\n\n/* TCP early-retransmit (ER) is similar to but more conservative than\n * the thin-dupack feature.  Enable ER only if thin-dupack is disabled.\n */\nstatic inline void tcp_enable_early_retrans(struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\ttp->do_early_retrans = sysctl_tcp_early_retrans &&\n\t\tsysctl_tcp_early_retrans < 4 && !sysctl_tcp_thin_dupack &&\n\t\tnet->ipv4.sysctl_tcp_reordering == 3;\n}\n\nstatic inline void tcp_disable_early_retrans(struct tcp_sock *tp)\n{\n\ttp->do_early_retrans = 0;\n}\n\nstatic inline unsigned int tcp_left_out(const struct tcp_sock *tp)\n{\n\treturn tp->sacked_out + tp->lost_out;\n}\n\n/* This determines how many packets are \"in the network\" to the best\n * of our knowledge.  In many cases it is conservative, but where\n * detailed information is available from the receiver (via SACK\n * blocks etc.) we can make more aggressive calculations.\n *\n * Use this for decisions involving congestion control, use just\n * tp->packets_out to determine if the send queue is empty or not.\n *\n * Read this equation as:\n *\n *\t\"Packets sent once on transmission queue\" MINUS\n *\t\"Packets left network, but not honestly ACKed yet\" PLUS\n *\t\"Packets fast retransmitted\"\n */\nstatic inline unsigned int tcp_packets_in_flight(const struct tcp_sock *tp)\n{\n\treturn tp->packets_out - tcp_left_out(tp) + tp->retrans_out;\n}\n\n#define TCP_INFINITE_SSTHRESH\t0x7fffffff\n\nstatic inline bool tcp_in_slow_start(const struct tcp_sock *tp)\n{\n\treturn tp->snd_cwnd < tp->snd_ssthresh;\n}\n\nstatic inline bool tcp_in_initial_slowstart(const struct tcp_sock *tp)\n{\n\treturn tp->snd_ssthresh >= TCP_INFINITE_SSTHRESH;\n}\n\nstatic inline bool tcp_in_cwnd_reduction(const struct sock *sk)\n{\n\treturn (TCPF_CA_CWR | TCPF_CA_Recovery) &\n\t       (1 << inet_csk(sk)->icsk_ca_state);\n}\n\n/* If cwnd > ssthresh, we may raise ssthresh to be half-way to cwnd.\n * The exception is cwnd reduction phase, when cwnd is decreasing towards\n * ssthresh.\n */\nstatic inline __u32 tcp_current_ssthresh(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_in_cwnd_reduction(sk))\n\t\treturn tp->snd_ssthresh;\n\telse\n\t\treturn max(tp->snd_ssthresh,\n\t\t\t   ((tp->snd_cwnd >> 1) +\n\t\t\t    (tp->snd_cwnd >> 2)));\n}\n\n/* Use define here intentionally to get WARN_ON location shown at the caller */\n#define tcp_verify_left_out(tp)\tWARN_ON(tcp_left_out(tp) > tp->packets_out)\n\nvoid tcp_enter_cwr(struct sock *sk);\n__u32 tcp_init_cwnd(const struct tcp_sock *tp, const struct dst_entry *dst);\n\n/* The maximum number of MSS of available cwnd for which TSO defers\n * sending if not using sysctl_tcp_tso_win_divisor.\n */\nstatic inline __u32 tcp_max_tso_deferred_mss(const struct tcp_sock *tp)\n{\n\treturn 3;\n}\n\n/* Returns end sequence number of the receiver's advertised window */\nstatic inline u32 tcp_wnd_end(const struct tcp_sock *tp)\n{\n\treturn tp->snd_una + tp->snd_wnd;\n}\n\n/* We follow the spirit of RFC2861 to validate cwnd but implement a more\n * flexible approach. The RFC suggests cwnd should not be raised unless\n * it was fully used previously. And that's exactly what we do in\n * congestion avoidance mode. But in slow start we allow cwnd to grow\n * as long as the application has used half the cwnd.\n * Example :\n *    cwnd is 10 (IW10), but application sends 9 frames.\n *    We allow cwnd to reach 18 when all frames are ACKed.\n * This check is safe because it's as aggressive as slow start which already\n * risks 100% overshoot. The advantage is that we discourage application to\n * either send more filler packets or data to artificially blow up the cwnd\n * usage, and allow application-limited process to probe bw more aggressively.\n */\nstatic inline bool tcp_is_cwnd_limited(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t/* If in slow start, ensure cwnd grows to twice what was ACKed. */\n\tif (tcp_in_slow_start(tp))\n\t\treturn tp->snd_cwnd < 2 * tp->max_packets_out;\n\n\treturn tp->is_cwnd_limited;\n}\n\n/* Something is really bad, we could not queue an additional packet,\n * because qdisc is full or receiver sent a 0 window.\n * We do not want to add fuel to the fire, or abort too early,\n * so make sure the timer we arm now is at least 200ms in the future,\n * regardless of current icsk_rto value (as it could be ~2ms)\n */\nstatic inline unsigned long tcp_probe0_base(const struct sock *sk)\n{\n\treturn max_t(unsigned long, inet_csk(sk)->icsk_rto, TCP_RTO_MIN);\n}\n\n/* Variant of inet_csk_rto_backoff() used for zero window probes */\nstatic inline unsigned long tcp_probe0_when(const struct sock *sk,\n\t\t\t\t\t    unsigned long max_when)\n{\n\tu64 when = (u64)tcp_probe0_base(sk) << inet_csk(sk)->icsk_backoff;\n\n\treturn (unsigned long)min_t(u64, when, max_when);\n}\n\nstatic inline void tcp_check_probe_timer(struct sock *sk)\n{\n\tif (!tcp_sk(sk)->packets_out && !inet_csk(sk)->icsk_pending)\n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_PROBE0,\n\t\t\t\t\t  tcp_probe0_base(sk), TCP_RTO_MAX);\n}\n\nstatic inline void tcp_init_wl(struct tcp_sock *tp, u32 seq)\n{\n\ttp->snd_wl1 = seq;\n}\n\nstatic inline void tcp_update_wl(struct tcp_sock *tp, u32 seq)\n{\n\ttp->snd_wl1 = seq;\n}\n\n/*\n * Calculate(/check) TCP checksum\n */\nstatic inline __sum16 tcp_v4_check(int len, __be32 saddr,\n\t\t\t\t   __be32 daddr, __wsum base)\n{\n\treturn csum_tcpudp_magic(saddr,daddr,len,IPPROTO_TCP,base);\n}\n\nstatic inline __sum16 __tcp_checksum_complete(struct sk_buff *skb)\n{\n\treturn __skb_checksum_complete(skb);\n}\n\nstatic inline bool tcp_checksum_complete(struct sk_buff *skb)\n{\n\treturn !skb_csum_unnecessary(skb) &&\n\t\t__tcp_checksum_complete(skb);\n}\n\n/* Prequeue for VJ style copy to user, combined with checksumming. */\n\nstatic inline void tcp_prequeue_init(struct tcp_sock *tp)\n{\n\ttp->ucopy.task = NULL;\n\ttp->ucopy.len = 0;\n\ttp->ucopy.memory = 0;\n\tskb_queue_head_init(&tp->ucopy.prequeue);\n}\n\nbool tcp_prequeue(struct sock *sk, struct sk_buff *skb);\n\n#undef STATE_TRACE\n\n#ifdef STATE_TRACE\nstatic const char *statename[]={\n\t\"Unused\",\"Established\",\"Syn Sent\",\"Syn Recv\",\n\t\"Fin Wait 1\",\"Fin Wait 2\",\"Time Wait\", \"Close\",\n\t\"Close Wait\",\"Last ACK\",\"Listen\",\"Closing\"\n};\n#endif\nvoid tcp_set_state(struct sock *sk, int state);\n\nvoid tcp_done(struct sock *sk);\n\nint tcp_abort(struct sock *sk, int err);\n\nstatic inline void tcp_sack_reset(struct tcp_options_received *rx_opt)\n{\n\trx_opt->dsack = 0;\n\trx_opt->num_sacks = 0;\n}\n\nu32 tcp_default_init_rwnd(u32 mss);\nvoid tcp_cwnd_restart(struct sock *sk, s32 delta);\n\nstatic inline void tcp_slow_start_after_idle_check(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\ts32 delta;\n\n\tif (!sysctl_tcp_slow_start_after_idle || tp->packets_out)\n\t\treturn;\n\tdelta = tcp_time_stamp - tp->lsndtime;\n\tif (delta > inet_csk(sk)->icsk_rto)\n\t\ttcp_cwnd_restart(sk, delta);\n}\n\n/* Determine a window scaling and initial window to offer. */\nvoid tcp_select_initial_window(int __space, __u32 mss, __u32 *rcv_wnd,\n\t\t\t       __u32 *window_clamp, int wscale_ok,\n\t\t\t       __u8 *rcv_wscale, __u32 init_rcv_wnd);\n\nstatic inline int tcp_win_from_space(int space)\n{\n\treturn sysctl_tcp_adv_win_scale<=0 ?\n\t\t(space>>(-sysctl_tcp_adv_win_scale)) :\n\t\tspace - (space>>sysctl_tcp_adv_win_scale);\n}\n\n/* Note: caller must be prepared to deal with negative returns */\nstatic inline int tcp_space(const struct sock *sk)\n{\n\treturn tcp_win_from_space(sk->sk_rcvbuf -\n\t\t\t\t  atomic_read(&sk->sk_rmem_alloc));\n}\n\nstatic inline int tcp_full_space(const struct sock *sk)\n{\n\treturn tcp_win_from_space(sk->sk_rcvbuf);\n}\n\nextern void tcp_openreq_init_rwin(struct request_sock *req,\n\t\t\t\t  const struct sock *sk_listener,\n\t\t\t\t  const struct dst_entry *dst);\n\nvoid tcp_enter_memory_pressure(struct sock *sk);\n\nstatic inline int keepalive_intvl_when(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\treturn tp->keepalive_intvl ? : net->ipv4.sysctl_tcp_keepalive_intvl;\n}\n\nstatic inline int keepalive_time_when(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\treturn tp->keepalive_time ? : net->ipv4.sysctl_tcp_keepalive_time;\n}\n\nstatic inline int keepalive_probes(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\n\treturn tp->keepalive_probes ? : net->ipv4.sysctl_tcp_keepalive_probes;\n}\n\nstatic inline u32 keepalive_time_elapsed(const struct tcp_sock *tp)\n{\n\tconst struct inet_connection_sock *icsk = &tp->inet_conn;\n\n\treturn min_t(u32, tcp_time_stamp - icsk->icsk_ack.lrcvtime,\n\t\t\t  tcp_time_stamp - tp->rcv_tstamp);\n}\n\nstatic inline int tcp_fin_time(const struct sock *sk)\n{\n\tint fin_timeout = tcp_sk(sk)->linger2 ? : sock_net(sk)->ipv4.sysctl_tcp_fin_timeout;\n\tconst int rto = inet_csk(sk)->icsk_rto;\n\n\tif (fin_timeout < (rto << 2) - (rto >> 1))\n\t\tfin_timeout = (rto << 2) - (rto >> 1);\n\n\treturn fin_timeout;\n}\n\nstatic inline bool tcp_paws_check(const struct tcp_options_received *rx_opt,\n\t\t\t\t  int paws_win)\n{\n\tif ((s32)(rx_opt->ts_recent - rx_opt->rcv_tsval) <= paws_win)\n\t\treturn true;\n\tif (unlikely(get_seconds() >= rx_opt->ts_recent_stamp + TCP_PAWS_24DAYS))\n\t\treturn true;\n\t/*\n\t * Some OSes send SYN and SYNACK messages with tsval=0 tsecr=0,\n\t * then following tcp messages have valid values. Ignore 0 value,\n\t * or else 'negative' tsval might forbid us to accept their packets.\n\t */\n\tif (!rx_opt->ts_recent)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool tcp_paws_reject(const struct tcp_options_received *rx_opt,\n\t\t\t\t   int rst)\n{\n\tif (tcp_paws_check(rx_opt, 0))\n\t\treturn false;\n\n\t/* RST segments are not recommended to carry timestamp,\n\t   and, if they do, it is recommended to ignore PAWS because\n\t   \"their cleanup function should take precedence over timestamps.\"\n\t   Certainly, it is mistake. It is necessary to understand the reasons\n\t   of this constraint to relax it: if peer reboots, clock may go\n\t   out-of-sync and half-open connections will not be reset.\n\t   Actually, the problem would be not existing if all\n\t   the implementations followed draft about maintaining clock\n\t   via reboots. Linux-2.2 DOES NOT!\n\n\t   However, we can relax time bounds for RST segments to MSL.\n\t */\n\tif (rst && get_seconds() >= rx_opt->ts_recent_stamp + TCP_PAWS_MSL)\n\t\treturn false;\n\treturn true;\n}\n\nbool tcp_oow_rate_limited(struct net *net, const struct sk_buff *skb,\n\t\t\t  int mib_idx, u32 *last_oow_ack_time);\n\nstatic inline void tcp_mib_init(struct net *net)\n{\n\t/* See RFC 2012 */\n\tTCP_ADD_STATS(net, TCP_MIB_RTOALGORITHM, 1);\n\tTCP_ADD_STATS(net, TCP_MIB_RTOMIN, TCP_RTO_MIN*1000/HZ);\n\tTCP_ADD_STATS(net, TCP_MIB_RTOMAX, TCP_RTO_MAX*1000/HZ);\n\tTCP_ADD_STATS(net, TCP_MIB_MAXCONN, -1);\n}\n\n/* from STCP */\nstatic inline void tcp_clear_retrans_hints_partial(struct tcp_sock *tp)\n{\n\ttp->lost_skb_hint = NULL;\n}\n\nstatic inline void tcp_clear_all_retrans_hints(struct tcp_sock *tp)\n{\n\ttcp_clear_retrans_hints_partial(tp);\n\ttp->retransmit_skb_hint = NULL;\n}\n\nunion tcp_md5_addr {\n\tstruct in_addr  a4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct in6_addr\ta6;\n#endif\n};\n\n/* - key database */\nstruct tcp_md5sig_key {\n\tstruct hlist_node\tnode;\n\tu8\t\t\tkeylen;\n\tu8\t\t\tfamily; /* AF_INET or AF_INET6 */\n\tunion tcp_md5_addr\taddr;\n\tu8\t\t\tkey[TCP_MD5SIG_MAXKEYLEN];\n\tstruct rcu_head\t\trcu;\n};\n\n/* - sock block */\nstruct tcp_md5sig_info {\n\tstruct hlist_head\thead;\n\tstruct rcu_head\t\trcu;\n};\n\n/* - pseudo header */\nstruct tcp4_pseudohdr {\n\t__be32\t\tsaddr;\n\t__be32\t\tdaddr;\n\t__u8\t\tpad;\n\t__u8\t\tprotocol;\n\t__be16\t\tlen;\n};\n\nstruct tcp6_pseudohdr {\n\tstruct in6_addr\tsaddr;\n\tstruct in6_addr daddr;\n\t__be32\t\tlen;\n\t__be32\t\tprotocol;\t/* including padding */\n};\n\nunion tcp_md5sum_block {\n\tstruct tcp4_pseudohdr ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct tcp6_pseudohdr ip6;\n#endif\n};\n\n/* - pool: digest algorithm, hash description and scratch buffer */\nstruct tcp_md5sig_pool {\n\tstruct ahash_request\t*md5_req;\n\tvoid\t\t\t*scratch;\n};\n\n/* - functions */\nint tcp_v4_md5_hash_skb(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\tconst struct sock *sk, const struct sk_buff *skb);\nint tcp_md5_do_add(struct sock *sk, const union tcp_md5_addr *addr,\n\t\t   int family, const u8 *newkey, u8 newkeylen, gfp_t gfp);\nint tcp_md5_do_del(struct sock *sk, const union tcp_md5_addr *addr,\n\t\t   int family);\nstruct tcp_md5sig_key *tcp_v4_md5_lookup(const struct sock *sk,\n\t\t\t\t\t const struct sock *addr_sk);\n\n#ifdef CONFIG_TCP_MD5SIG\nstruct tcp_md5sig_key *tcp_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t const union tcp_md5_addr *addr,\n\t\t\t\t\t int family);\n#define tcp_twsk_md5_key(twsk)\t((twsk)->tw_md5_key)\n#else\nstatic inline struct tcp_md5sig_key *tcp_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t const union tcp_md5_addr *addr,\n\t\t\t\t\t int family)\n{\n\treturn NULL;\n}\n#define tcp_twsk_md5_key(twsk)\tNULL\n#endif\n\nbool tcp_alloc_md5sig_pool(void);\n\nstruct tcp_md5sig_pool *tcp_get_md5sig_pool(void);\nstatic inline void tcp_put_md5sig_pool(void)\n{\n\tlocal_bh_enable();\n}\n\nint tcp_md5_hash_skb_data(struct tcp_md5sig_pool *, const struct sk_buff *,\n\t\t\t  unsigned int header_len);\nint tcp_md5_hash_key(struct tcp_md5sig_pool *hp,\n\t\t     const struct tcp_md5sig_key *key);\n\n/* From tcp_fastopen.c */\nvoid tcp_fastopen_cache_get(struct sock *sk, u16 *mss,\n\t\t\t    struct tcp_fastopen_cookie *cookie, int *syn_loss,\n\t\t\t    unsigned long *last_syn_loss);\nvoid tcp_fastopen_cache_set(struct sock *sk, u16 mss,\n\t\t\t    struct tcp_fastopen_cookie *cookie, bool syn_lost,\n\t\t\t    u16 try_exp);\nstruct tcp_fastopen_request {\n\t/* Fast Open cookie. Size 0 means a cookie request */\n\tstruct tcp_fastopen_cookie\tcookie;\n\tstruct msghdr\t\t\t*data;  /* data in MSG_FASTOPEN */\n\tsize_t\t\t\t\tsize;\n\tint\t\t\t\tcopied;\t/* queued in tcp_connect() */\n};\nvoid tcp_free_fastopen_req(struct tcp_sock *tp);\n\nextern struct tcp_fastopen_context __rcu *tcp_fastopen_ctx;\nint tcp_fastopen_reset_cipher(void *key, unsigned int len);\nvoid tcp_fastopen_add_skb(struct sock *sk, struct sk_buff *skb);\nstruct sock *tcp_try_fastopen(struct sock *sk, struct sk_buff *skb,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      struct dst_entry *dst);\nvoid tcp_fastopen_init_key_once(bool publish);\n#define TCP_FASTOPEN_KEY_LENGTH 16\n\n/* Fastopen key context */\nstruct tcp_fastopen_context {\n\tstruct crypto_cipher\t*tfm;\n\t__u8\t\t\tkey[TCP_FASTOPEN_KEY_LENGTH];\n\tstruct rcu_head\t\trcu;\n};\n\n/* write queue abstraction */\nstatic inline void tcp_write_queue_purge(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(&sk->sk_write_queue)) != NULL)\n\t\tsk_wmem_free_skb(sk, skb);\n\tsk_mem_reclaim(sk);\n\ttcp_clear_all_retrans_hints(tcp_sk(sk));\n}\n\nstatic inline struct sk_buff *tcp_write_queue_head(const struct sock *sk)\n{\n\treturn skb_peek(&sk->sk_write_queue);\n}\n\nstatic inline struct sk_buff *tcp_write_queue_tail(const struct sock *sk)\n{\n\treturn skb_peek_tail(&sk->sk_write_queue);\n}\n\nstatic inline struct sk_buff *tcp_write_queue_next(const struct sock *sk,\n\t\t\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn skb_queue_next(&sk->sk_write_queue, skb);\n}\n\nstatic inline struct sk_buff *tcp_write_queue_prev(const struct sock *sk,\n\t\t\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn skb_queue_prev(&sk->sk_write_queue, skb);\n}\n\n#define tcp_for_write_queue(skb, sk)\t\t\t\t\t\\\n\tskb_queue_walk(&(sk)->sk_write_queue, skb)\n\n#define tcp_for_write_queue_from(skb, sk)\t\t\t\t\\\n\tskb_queue_walk_from(&(sk)->sk_write_queue, skb)\n\n#define tcp_for_write_queue_from_safe(skb, tmp, sk)\t\t\t\\\n\tskb_queue_walk_from_safe(&(sk)->sk_write_queue, skb, tmp)\n\nstatic inline struct sk_buff *tcp_send_head(const struct sock *sk)\n{\n\treturn sk->sk_send_head;\n}\n\nstatic inline bool tcp_skb_is_last(const struct sock *sk,\n\t\t\t\t   const struct sk_buff *skb)\n{\n\treturn skb_queue_is_last(&sk->sk_write_queue, skb);\n}\n\nstatic inline void tcp_advance_send_head(struct sock *sk, const struct sk_buff *skb)\n{\n\tif (tcp_skb_is_last(sk, skb))\n\t\tsk->sk_send_head = NULL;\n\telse\n\t\tsk->sk_send_head = tcp_write_queue_next(sk, skb);\n}\n\nstatic inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n\tif (tcp_sk(sk)->highest_sack == skb_unlinked)\n\t\ttcp_sk(sk)->highest_sack = NULL;\n}\n\nstatic inline void tcp_init_send_head(struct sock *sk)\n{\n\tsk->sk_send_head = NULL;\n}\n\nstatic inline void __tcp_add_write_queue_tail(struct sock *sk, struct sk_buff *skb)\n{\n\t__skb_queue_tail(&sk->sk_write_queue, skb);\n}\n\nstatic inline void tcp_add_write_queue_tail(struct sock *sk, struct sk_buff *skb)\n{\n\t__tcp_add_write_queue_tail(sk, skb);\n\n\t/* Queue it, remembering where we must start sending. */\n\tif (sk->sk_send_head == NULL) {\n\t\tsk->sk_send_head = skb;\n\n\t\tif (tcp_sk(sk)->highest_sack == NULL)\n\t\t\ttcp_sk(sk)->highest_sack = skb;\n\t}\n}\n\nstatic inline void __tcp_add_write_queue_head(struct sock *sk, struct sk_buff *skb)\n{\n\t__skb_queue_head(&sk->sk_write_queue, skb);\n}\n\n/* Insert buff after skb on the write queue of sk.  */\nstatic inline void tcp_insert_write_queue_after(struct sk_buff *skb,\n\t\t\t\t\t\tstruct sk_buff *buff,\n\t\t\t\t\t\tstruct sock *sk)\n{\n\t__skb_queue_after(&sk->sk_write_queue, skb, buff);\n}\n\n/* Insert new before skb on the write queue of sk.  */\nstatic inline void tcp_insert_write_queue_before(struct sk_buff *new,\n\t\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t\t  struct sock *sk)\n{\n\t__skb_queue_before(&sk->sk_write_queue, skb, new);\n\n\tif (sk->sk_send_head == skb)\n\t\tsk->sk_send_head = new;\n}\n\nstatic inline void tcp_unlink_write_queue(struct sk_buff *skb, struct sock *sk)\n{\n\t__skb_unlink(skb, &sk->sk_write_queue);\n}\n\nstatic inline bool tcp_write_queue_empty(struct sock *sk)\n{\n\treturn skb_queue_empty(&sk->sk_write_queue);\n}\n\nstatic inline void tcp_push_pending_frames(struct sock *sk)\n{\n\tif (tcp_send_head(sk)) {\n\t\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t\t__tcp_push_pending_frames(sk, tcp_current_mss(sk), tp->nonagle);\n\t}\n}\n\n/* Start sequence of the skb just after the highest skb with SACKed\n * bit, valid only if sacked_out > 0 or when the caller has ensured\n * validity by itself.\n */\nstatic inline u32 tcp_highest_sack_seq(struct tcp_sock *tp)\n{\n\tif (!tp->sacked_out)\n\t\treturn tp->snd_una;\n\n\tif (tp->highest_sack == NULL)\n\t\treturn tp->snd_nxt;\n\n\treturn TCP_SKB_CB(tp->highest_sack)->seq;\n}\n\nstatic inline void tcp_advance_highest_sack(struct sock *sk, struct sk_buff *skb)\n{\n\ttcp_sk(sk)->highest_sack = tcp_skb_is_last(sk, skb) ? NULL :\n\t\t\t\t\t\ttcp_write_queue_next(sk, skb);\n}\n\nstatic inline struct sk_buff *tcp_highest_sack(struct sock *sk)\n{\n\treturn tcp_sk(sk)->highest_sack;\n}\n\nstatic inline void tcp_highest_sack_reset(struct sock *sk)\n{\n\ttcp_sk(sk)->highest_sack = tcp_write_queue_head(sk);\n}\n\n/* Called when old skb is about to be deleted (to be combined with new skb) */\nstatic inline void tcp_highest_sack_combine(struct sock *sk,\n\t\t\t\t\t    struct sk_buff *old,\n\t\t\t\t\t    struct sk_buff *new)\n{\n\tif (tcp_sk(sk)->sacked_out && (old == tcp_sk(sk)->highest_sack))\n\t\ttcp_sk(sk)->highest_sack = new;\n}\n\n/* This helper checks if socket has IP_TRANSPARENT set */\nstatic inline bool inet_sk_transparent(const struct sock *sk)\n{\n\tswitch (sk->sk_state) {\n\tcase TCP_TIME_WAIT:\n\t\treturn inet_twsk(sk)->tw_transparent;\n\tcase TCP_NEW_SYN_RECV:\n\t\treturn inet_rsk(inet_reqsk(sk))->no_srccheck;\n\t}\n\treturn inet_sk(sk)->transparent;\n}\n\n/* Determines whether this is a thin stream (which may suffer from\n * increased latency). Used to trigger latency-reducing mechanisms.\n */\nstatic inline bool tcp_stream_is_thin(struct tcp_sock *tp)\n{\n\treturn tp->packets_out < 4 && !tcp_in_initial_slowstart(tp);\n}\n\n/* /proc */\nenum tcp_seq_states {\n\tTCP_SEQ_STATE_LISTENING,\n\tTCP_SEQ_STATE_ESTABLISHED,\n};\n\nint tcp_seq_open(struct inode *inode, struct file *file);\n\nstruct tcp_seq_afinfo {\n\tchar\t\t\t\t*name;\n\tsa_family_t\t\t\tfamily;\n\tconst struct file_operations\t*seq_fops;\n\tstruct seq_operations\t\tseq_ops;\n};\n\nstruct tcp_iter_state {\n\tstruct seq_net_private\tp;\n\tsa_family_t\t\tfamily;\n\tenum tcp_seq_states\tstate;\n\tstruct sock\t\t*syn_wait_sk;\n\tint\t\t\tbucket, offset, sbucket, num;\n\tloff_t\t\t\tlast_pos;\n};\n\nint tcp_proc_register(struct net *net, struct tcp_seq_afinfo *afinfo);\nvoid tcp_proc_unregister(struct net *net, struct tcp_seq_afinfo *afinfo);\n\nextern struct request_sock_ops tcp_request_sock_ops;\nextern struct request_sock_ops tcp6_request_sock_ops;\n\nvoid tcp_v4_destroy_sock(struct sock *sk);\n\nstruct sk_buff *tcp_gso_segment(struct sk_buff *skb,\n\t\t\t\tnetdev_features_t features);\nstruct sk_buff **tcp_gro_receive(struct sk_buff **head, struct sk_buff *skb);\nint tcp_gro_complete(struct sk_buff *skb);\n\nvoid __tcp_v4_send_check(struct sk_buff *skb, __be32 saddr, __be32 daddr);\n\nstatic inline u32 tcp_notsent_lowat(const struct tcp_sock *tp)\n{\n\tstruct net *net = sock_net((struct sock *)tp);\n\treturn tp->notsent_lowat ?: net->ipv4.sysctl_tcp_notsent_lowat;\n}\n\nstatic inline bool tcp_stream_memory_free(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tu32 notsent_bytes = tp->write_seq - tp->snd_nxt;\n\n\treturn notsent_bytes < tcp_notsent_lowat(tp);\n}\n\n#ifdef CONFIG_PROC_FS\nint tcp4_proc_init(void);\nvoid tcp4_proc_exit(void);\n#endif\n\nint tcp_rtx_synack(const struct sock *sk, struct request_sock *req);\nint tcp_conn_request(struct request_sock_ops *rsk_ops,\n\t\t     const struct tcp_request_sock_ops *af_ops,\n\t\t     struct sock *sk, struct sk_buff *skb);\n\n/* TCP af-specific functions */\nstruct tcp_sock_af_ops {\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key\t*(*md5_lookup) (const struct sock *sk,\n\t\t\t\t\t\tconst struct sock *addr_sk);\n\tint\t\t(*calc_md5_hash)(char *location,\n\t\t\t\t\t const struct tcp_md5sig_key *md5,\n\t\t\t\t\t const struct sock *sk,\n\t\t\t\t\t const struct sk_buff *skb);\n\tint\t\t(*md5_parse)(struct sock *sk,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int optlen);\n#endif\n};\n\nstruct tcp_request_sock_ops {\n\tu16 mss_clamp;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *(*req_md5_lookup)(const struct sock *sk,\n\t\t\t\t\t\t const struct sock *addr_sk);\n\tint\t\t(*calc_md5_hash) (char *location,\n\t\t\t\t\t  const struct tcp_md5sig_key *md5,\n\t\t\t\t\t  const struct sock *sk,\n\t\t\t\t\t  const struct sk_buff *skb);\n#endif\n\tvoid (*init_req)(struct request_sock *req,\n\t\t\t const struct sock *sk_listener,\n\t\t\t struct sk_buff *skb);\n#ifdef CONFIG_SYN_COOKIES\n\t__u32 (*cookie_init_seq)(const struct sk_buff *skb,\n\t\t\t\t __u16 *mss);\n#endif\n\tstruct dst_entry *(*route_req)(const struct sock *sk, struct flowi *fl,\n\t\t\t\t       const struct request_sock *req,\n\t\t\t\t       bool *strict);\n\t__u32 (*init_seq)(const struct sk_buff *skb);\n\tint (*send_synack)(const struct sock *sk, struct dst_entry *dst,\n\t\t\t   struct flowi *fl, struct request_sock *req,\n\t\t\t   struct tcp_fastopen_cookie *foc,\n\t\t\t   enum tcp_synack_type synack_type);\n};\n\n#ifdef CONFIG_SYN_COOKIES\nstatic inline __u32 cookie_init_sequence(const struct tcp_request_sock_ops *ops,\n\t\t\t\t\t const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t __u16 *mss)\n{\n\ttcp_synq_overflow(sk);\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESSENT);\n\treturn ops->cookie_init_seq(skb, mss);\n}\n#else\nstatic inline __u32 cookie_init_sequence(const struct tcp_request_sock_ops *ops,\n\t\t\t\t\t const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t __u16 *mss)\n{\n\treturn 0;\n}\n#endif\n\nint tcpv4_offload_init(void);\n\nvoid tcp_v4_init(void);\nvoid tcp_init(void);\n\n/* tcp_recovery.c */\n\n/* Flags to enable various loss recovery features. See below */\nextern int sysctl_tcp_recovery;\n\n/* Use TCP RACK to detect (some) tail and retransmit losses */\n#define TCP_RACK_LOST_RETRANS  0x1\n\nextern int tcp_rack_mark_lost(struct sock *sk);\n\nextern void tcp_rack_advance(struct tcp_sock *tp,\n\t\t\t     const struct skb_mstamp *xmit_time, u8 sacked);\n\n/*\n * Save and compile IPv4 options, return a pointer to it\n */\nstatic inline struct ip_options_rcu *tcp_v4_save_options(struct sk_buff *skb)\n{\n\tconst struct ip_options *opt = &TCP_SKB_CB(skb)->header.h4.opt;\n\tstruct ip_options_rcu *dopt = NULL;\n\n\tif (opt->optlen) {\n\t\tint opt_size = sizeof(*dopt) + opt->optlen;\n\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt && __ip_options_echo(&dopt->opt, skb, opt)) {\n\t\t\tkfree(dopt);\n\t\t\tdopt = NULL;\n\t\t}\n\t}\n\treturn dopt;\n}\n\n/* locally generated TCP pure ACKs have skb->truesize == 2\n * (check tcp_send_ack() in net/ipv4/tcp_output.c )\n * This is much faster than dissecting the packet to find out.\n * (Think of GRE encapsulations, IPv4, IPv6, ...)\n */\nstatic inline bool skb_is_tcp_pure_ack(const struct sk_buff *skb)\n{\n\treturn skb->truesize == 2;\n}\n\nstatic inline void skb_set_tcp_pure_ack(struct sk_buff *skb)\n{\n\tskb->truesize = 2;\n}\n\nstatic inline int tcp_inq(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint answ;\n\n\tif ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {\n\t\tansw = 0;\n\t} else if (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t   !tp->urg_data ||\n\t\t   before(tp->urg_seq, tp->copied_seq) ||\n\t\t   !before(tp->urg_seq, tp->rcv_nxt)) {\n\n\t\tansw = tp->rcv_nxt - tp->copied_seq;\n\n\t\t/* Subtract 1, if FIN was received */\n\t\tif (answ && sock_flag(sk, SOCK_DONE))\n\t\t\tansw--;\n\t} else {\n\t\tansw = tp->urg_seq - tp->copied_seq;\n\t}\n\n\treturn answ;\n}\n\nstatic inline void tcp_segs_in(struct tcp_sock *tp, const struct sk_buff *skb)\n{\n\tu16 segs_in;\n\n\tsegs_in = max_t(u16, 1, skb_shinfo(skb)->gso_segs);\n\ttp->segs_in += segs_in;\n\tif (skb->len > tcp_hdrlen(skb))\n\t\ttp->data_segs_in += segs_in;\n}\n\n/*\n * TCP listen path runs lockless.\n * We forced \"struct sock\" to be const qualified to make sure\n * we don't modify one of its field by mistake.\n * Here, we increment sk_drops which is an atomic_t, so we can safely\n * make sock writable again.\n */\nstatic inline void tcp_listendrop(const struct sock *sk)\n{\n\tatomic_inc(&((struct sock *)sk)->sk_drops);\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);\n}\n\n#endif\t/* _TCP_H */\n"], "buggy_code_start_loc": [1525], "buggy_code_end_loc": [1525], "fixing_code_start_loc": [1526], "fixing_code_end_loc": [1528], "type": "CWE-416", "message": "The tcp_check_send_head function in include/net/tcp.h in the Linux kernel before 4.7.5 does not properly maintain certain SACK state after a failed data copy, which allows local users to cause a denial of service (tcp_xmit_retransmit_queue use-after-free and system crash) via a crafted SACK option.", "other": {"cve": {"id": "CVE-2016-6828", "sourceIdentifier": "secalert@redhat.com", "published": "2016-10-16T21:59:08.053", "lastModified": "2023-02-12T23:25:10.540", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The tcp_check_send_head function in include/net/tcp.h in the Linux kernel before 4.7.5 does not properly maintain certain SACK state after a failed data copy, which allows local users to cause a denial of service (tcp_xmit_retransmit_queue use-after-free and system crash) via a crafted SACK option."}, {"lang": "es", "value": "La funci\u00f3n tcp_check_send_head en include/net/tcp.h en el kernel de Linux en versiones anteriores a 4.7.5 no mantiene adecuadamente cierto estado SACK tras una copia de datos fallida, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n de memoria tcp_xmit_retransmit_queue y ca\u00edda de sistema ) a trav\u00e9s de una opci\u00f3n SACK manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.7.4", "matchCriteriaId": "4C613BBC-9849-4519-86AE-ECB4BBC32BD7"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=bb1fceca22492109be12640d49f5ea5a544c6bb4", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0036.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0086.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0091.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0113.html", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.7.5", "source": "secalert@redhat.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/08/15/1", "source": "secalert@redhat.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/92452", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1367091", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/bb1fceca22492109be12640d49f5ea5a544c6bb4", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://marcograss.github.io/security/linux/2016/08/18/cve-2016-6828-linux-kernel-tcp-uaf.html", "source": "secalert@redhat.com"}, {"url": "https://source.android.com/security/bulletin/2016-11-01.html", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/bb1fceca22492109be12640d49f5ea5a544c6bb4"}}