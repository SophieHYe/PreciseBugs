{"buggy_code": ["/*\n *  linux/fs/namei.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n * Some corrections by tytso.\n */\n\n/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname\n * lookup logic.\n */\n/* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.\n */\n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/personality.h>\n#include <linux/security.h>\n#include <linux/ima.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/device_cgroup.h>\n#include <linux/fs_struct.h>\n#include <linux/posix_acl.h>\n#include <asm/uaccess.h>\n\n#include \"internal.h\"\n#include \"mount.h\"\n\n/* [Feb-1997 T. Schoebel-Theuer]\n * Fundamental changes in the pathname lookup mechanisms (namei)\n * were necessary because of omirr.  The reason is that omirr needs\n * to know the _real_ pathname, not the user-supplied one, in case\n * of symlinks (and also when transname replacements occur).\n *\n * The new code replaces the old recursive symlink resolution with\n * an iterative one (in case of non-nested symlink chains).  It does\n * this with calls to <fs>_follow_link().\n * As a side effect, dir_namei(), _namei() and follow_link() are now \n * replaced with a single function lookup_dentry() that can handle all \n * the special cases of the former code.\n *\n * With the new dcache, the pathname is stored at each inode, at least as\n * long as the refcount of the inode is positive.  As a side effect, the\n * size of the dcache depends on the inode cache and thus is dynamic.\n *\n * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink\n * resolution to correspond with current state of the code.\n *\n * Note that the symlink resolution is not *completely* iterative.\n * There is still a significant amount of tail- and mid- recursion in\n * the algorithm.  Also, note that <fs>_readlink() is not used in\n * lookup_dentry(): lookup_dentry() on the result of <fs>_readlink()\n * may return different results than <fs>_follow_link().  Many virtual\n * filesystems (including /proc) exhibit this behavior.\n */\n\n/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:\n * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL\n * and the name already exists in form of a symlink, try to create the new\n * name indicated by the symlink. The old code always complained that the\n * name already exists, due to not following the symlink even if its target\n * is nonexistent.  The new semantics affects also mknod() and link() when\n * the name is a symlink pointing to a non-existent name.\n *\n * I don't know which semantics is the right one, since I have no access\n * to standards. But I found by trial that HP-UX 9.0 has the full \"new\"\n * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the\n * \"old\" one. Personally, I think the new semantics is much more logical.\n * Note that \"ln old new\" where \"new\" is a symlink pointing to a non-existing\n * file does succeed in both HP-UX and SunOs, but not in Solaris\n * and in the old Linux semantics.\n */\n\n/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink\n * semantics.  See the comments in \"open_namei\" and \"do_link\" below.\n *\n * [10-Sep-98 Alan Modra] Another symlink change.\n */\n\n/* [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:\n *\tinside the path - always follow.\n *\tin the last component in creation/removal/renaming - never follow.\n *\tif LOOKUP_FOLLOW passed - follow.\n *\tif the pathname has trailing slashes - follow.\n *\totherwise - don't follow.\n * (applied in that order).\n *\n * [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT\n * restored for 2.4. This is the last surviving part of old 4.2BSD bug.\n * During the 2.4 we need to fix the userland stuff depending on it -\n * hopefully we will be able to get rid of that wart in 2.5. So far only\n * XEmacs seems to be relying on it...\n */\n/*\n * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)\n * implemented.  Let's see if raised priority of ->s_vfs_rename_mutex gives\n * any extra contention...\n */\n\n/* In order to reduce some races, while at the same time doing additional\n * checking and hopefully speeding things up, we copy filenames to the\n * kernel data space before using them..\n *\n * POSIX.1 2.4: an empty pathname is invalid (ENOENT).\n * PATH_MAX includes the nul terminator --RR.\n */\nvoid final_putname(struct filename *name)\n{\n\tif (name->separate) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else {\n\t\t__putname(name);\n\t}\n}\n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - sizeof(struct filename))\n\nstatic struct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n\tstruct filename *result, *err;\n\tint len;\n\tlong max;\n\tchar *kname;\n\n\tresult = audit_reusename(filename);\n\tif (result)\n\t\treturn result;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * First, try to embed the struct filename inside the names_cache\n\t * allocation\n\t */\n\tkname = (char *)result + sizeof(*result);\n\tresult->name = kname;\n\tresult->separate = false;\n\tmax = EMBEDDED_NAME_MAX;\n\nrecopy:\n\tlen = strncpy_from_user(kname, filename, max);\n\tif (unlikely(len < 0)) {\n\t\terr = ERR_PTR(len);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a\n\t * separate struct filename so we can dedicate the entire\n\t * names_cache allocation for the pathname, and re-do the copy from\n\t * userland.\n\t */\n\tif (len == EMBEDDED_NAME_MAX && max == EMBEDDED_NAME_MAX) {\n\t\tkname = (char *)result;\n\n\t\tresult = kzalloc(sizeof(*result), GFP_KERNEL);\n\t\tif (!result) {\n\t\t\terr = ERR_PTR(-ENOMEM);\n\t\t\tresult = (struct filename *)kname;\n\t\t\tgoto error;\n\t\t}\n\t\tresult->name = kname;\n\t\tresult->separate = true;\n\t\tmax = PATH_MAX;\n\t\tgoto recopy;\n\t}\n\n\t/* The empty path is special. */\n\tif (unlikely(!len)) {\n\t\tif (empty)\n\t\t\t*empty = 1;\n\t\terr = ERR_PTR(-ENOENT);\n\t\tif (!(flags & LOOKUP_EMPTY))\n\t\t\tgoto error;\n\t}\n\n\terr = ERR_PTR(-ENAMETOOLONG);\n\tif (unlikely(len >= PATH_MAX))\n\t\tgoto error;\n\n\tresult->uptr = filename;\n\tresult->aname = NULL;\n\taudit_getname(result);\n\treturn result;\n\nerror:\n\tfinal_putname(result);\n\treturn err;\n}\n\nstruct filename *\ngetname(const char __user * filename)\n{\n\treturn getname_flags(filename, 0, NULL);\n}\n\n/*\n * The \"getname_kernel()\" interface doesn't do pathnames longer\n * than EMBEDDED_NAME_MAX. Deal with it - you're a kernel user.\n */\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tchar *kname;\n\tint len;\n\n\tlen = strlen(filename);\n\tif (len >= EMBEDDED_NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkname = (char *)result + sizeof(*result);\n\tresult->name = kname;\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->separate = false;\n\n\tstrlcpy(kname, filename, EMBEDDED_NAME_MAX);\n\treturn result;\n}\n\n#ifdef CONFIG_AUDITSYSCALL\nvoid putname(struct filename *name)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\treturn audit_putname(name);\n\tfinal_putname(name);\n}\n#endif\n\nstatic int check_acl(struct inode *inode, int mask)\n{\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl *acl;\n\n\tif (mask & MAY_NOT_BLOCK) {\n\t\tacl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);\n\t        if (!acl)\n\t                return -EAGAIN;\n\t\t/* no ->get_acl() calls in RCU mode... */\n\t\tif (acl == ACL_NOT_CACHED)\n\t\t\treturn -ECHILD;\n\t        return posix_acl_permission(inode, acl, mask & ~MAY_NOT_BLOCK);\n\t}\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl) {\n\t        int error = posix_acl_permission(inode, acl, mask);\n\t        posix_acl_release(acl);\n\t        return error;\n\t}\n#endif\n\n\treturn -EAGAIN;\n}\n\n/*\n * This does the basic permission checking\n */\nstatic int acl_permission_check(struct inode *inode, int mask)\n{\n\tunsigned int mode = inode->i_mode;\n\n\tif (likely(uid_eq(current_fsuid(), inode->i_uid)))\n\t\tmode >>= 6;\n\telse {\n\t\tif (IS_POSIXACL(inode) && (mode & S_IRWXG)) {\n\t\t\tint error = check_acl(inode, mask);\n\t\t\tif (error != -EAGAIN)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (in_group_p(inode->i_gid))\n\t\t\tmode >>= 3;\n\t}\n\n\t/*\n\t * If the DACs are ok we don't need any capability check.\n\t */\n\tif ((mask & ~mode & (MAY_READ | MAY_WRITE | MAY_EXEC)) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\n/**\n * generic_permission -  check for access rights on a Posix-like filesystem\n * @inode:\tinode to check access rights for\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC, ...)\n *\n * Used to check for read/write/execute permissions on a file.\n * We use \"fsuid\" for this, letting us set arbitrary permissions\n * for filesystem access without changing the \"normal\" uids which\n * are used for other things.\n *\n * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk\n * request cannot be satisfied (eg. requires blocking or too much complexity).\n * It would then be called again in ref-walk mode.\n */\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}\nEXPORT_SYMBOL(generic_permission);\n\n/*\n * We _really_ want to just do \"generic_permission()\" without\n * even looking at the inode->i_op values. So we keep a cache\n * flag in inode->i_opflags, that says \"this has not special\n * permission function, use the fast case\".\n */\nstatic inline int do_inode_permission(struct inode *inode, int mask)\n{\n\tif (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {\n\t\tif (likely(inode->i_op->permission))\n\t\t\treturn inode->i_op->permission(inode, mask);\n\n\t\t/* This gets set once for the inode lifetime */\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_opflags |= IOP_FASTPERM;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn generic_permission(inode, mask);\n}\n\n/**\n * __inode_permission - Check for access rights to a given inode\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Check for read/write/execute permissions on an inode.\n *\n * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.\n *\n * This does not check for a read-only file system.  You probably want\n * inode_permission().\n */\nint __inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}\n\n/**\n * sb_permission - Check superblock-level permissions\n * @sb: Superblock of inode to check permission on\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Separate out file-system wide checks from inode-specific permission checks.\n */\nstatic int sb_permission(struct super_block *sb, struct inode *inode, int mask)\n{\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\t/* Nobody gets write access to a read-only fs. */\n\t\tif ((sb->s_flags & MS_RDONLY) &&\n\t\t    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))\n\t\t\treturn -EROFS;\n\t}\n\treturn 0;\n}\n\n/**\n * inode_permission - Check for access rights to a given inode\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Check for read/write/execute permissions on an inode.  We use fs[ug]id for\n * this, letting us set arbitrary permissions for filesystem access without\n * changing the \"normal\" UIDs which are used for other things.\n *\n * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.\n */\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}\nEXPORT_SYMBOL(inode_permission);\n\n/**\n * path_get - get a reference to a path\n * @path: path to get the reference to\n *\n * Given a path increment the reference count to the dentry and the vfsmount.\n */\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}\nEXPORT_SYMBOL(path_get);\n\n/**\n * path_put - put a reference to a path\n * @path: path to put the reference to\n *\n * Given a path decrement the reference count to the dentry and the vfsmount.\n */\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}\nEXPORT_SYMBOL(path_put);\n\n/*\n * Path walking has 2 modes, rcu-walk and ref-walk (see\n * Documentation/filesystems/path-lookup.txt).  In situations when we can't\n * continue in RCU mode, we attempt to drop out of rcu-walk mode and grab\n * normal reference counts on dentries and vfsmounts to transition to rcu-walk\n * mode.  Refcounts are grabbed at the last known good point before rcu-walk\n * got stuck, so ref-walk may continue from there. If this is not successful\n * (eg. a seqcount has changed), then failure is returned and it's up to caller\n * to restart the path walk from the beginning in ref-walk mode.\n */\n\n/**\n * unlazy_walk - try to switch to ref-walk mode.\n * @nd: nameidata pathwalk data\n * @dentry: child of nd->path.dentry or NULL\n * Returns: 0 on success, -ECHILD on failure\n *\n * unlazy_walk attempts to legitimize the current nd->path, nd->root and dentry\n * for ref-walk mode.  @dentry must be a path found by a do_lookup call on\n * @nd or NULL.  Must be called from rcu-walk context.\n */\nstatic int unlazy_walk(struct nameidata *nd, struct dentry *dentry)\n{\n\tstruct fs_struct *fs = current->fs;\n\tstruct dentry *parent = nd->path.dentry;\n\n\tBUG_ON(!(nd->flags & LOOKUP_RCU));\n\n\t/*\n\t * After legitimizing the bastards, terminate_walk()\n\t * will do the right thing for non-RCU mode, and all our\n\t * subsequent exit cases should rcu_read_unlock()\n\t * before returning.  Do vfsmount first; if dentry\n\t * can't be legitimized, just set nd->path.dentry to NULL\n\t * and rely on dput(NULL) being a no-op.\n\t */\n\tif (!legitimize_mnt(nd->path.mnt, nd->m_seq))\n\t\treturn -ECHILD;\n\tnd->flags &= ~LOOKUP_RCU;\n\n\tif (!lockref_get_not_dead(&parent->d_lockref)) {\n\t\tnd->path.dentry = NULL;\t\n\t\tgoto out;\n\t}\n\n\t/*\n\t * For a negative lookup, the lookup sequence point is the parents\n\t * sequence point, and it only needs to revalidate the parent dentry.\n\t *\n\t * For a positive lookup, we need to move both the parent and the\n\t * dentry from the RCU domain to be properly refcounted. And the\n\t * sequence number in the dentry validates *both* dentry counters,\n\t * since we checked the sequence number of the parent after we got\n\t * the child sequence number. So we know the parent must still\n\t * be valid if the child sequence number is still valid.\n\t */\n\tif (!dentry) {\n\t\tif (read_seqcount_retry(&parent->d_seq, nd->seq))\n\t\t\tgoto out;\n\t\tBUG_ON(nd->inode != parent->d_inode);\n\t} else {\n\t\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\t\tgoto out;\n\t\tif (read_seqcount_retry(&dentry->d_seq, nd->seq))\n\t\t\tgoto drop_dentry;\n\t}\n\n\t/*\n\t * Sequence counts matched. Now make sure that the root is\n\t * still valid and get it if required.\n\t */\n\tif (nd->root.mnt && !(nd->flags & LOOKUP_ROOT)) {\n\t\tspin_lock(&fs->lock);\n\t\tif (nd->root.mnt != fs->root.mnt || nd->root.dentry != fs->root.dentry)\n\t\t\tgoto unlock_and_drop_dentry;\n\t\tpath_get(&nd->root);\n\t\tspin_unlock(&fs->lock);\n\t}\n\n\trcu_read_unlock();\n\treturn 0;\n\nunlock_and_drop_dentry:\n\tspin_unlock(&fs->lock);\ndrop_dentry:\n\trcu_read_unlock();\n\tdput(dentry);\n\tgoto drop_root_mnt;\nout:\n\trcu_read_unlock();\ndrop_root_mnt:\n\tif (!(nd->flags & LOOKUP_ROOT))\n\t\tnd->root.mnt = NULL;\n\treturn -ECHILD;\n}\n\nstatic inline int d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\treturn dentry->d_op->d_revalidate(dentry, flags);\n}\n\n/**\n * complete_walk - successful completion of path walk\n * @nd:  pointer nameidata\n *\n * If we had been in RCU mode, drop out of it and legitimize nd->path.\n * Revalidate the final result, unless we'd already done that during\n * the path walk or the filesystem doesn't ask for it.  Return 0 on\n * success, -error on failure.  In case of failure caller does not\n * need to drop nd->path.\n */\nstatic int complete_walk(struct nameidata *nd)\n{\n\tstruct dentry *dentry = nd->path.dentry;\n\tint status;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tnd->flags &= ~LOOKUP_RCU;\n\t\tif (!(nd->flags & LOOKUP_ROOT))\n\t\t\tnd->root.mnt = NULL;\n\n\t\tif (!legitimize_mnt(nd->path.mnt, nd->m_seq)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ECHILD;\n\t\t}\n\t\tif (unlikely(!lockref_get_not_dead(&dentry->d_lockref))) {\n\t\t\trcu_read_unlock();\n\t\t\tmntput(nd->path.mnt);\n\t\t\treturn -ECHILD;\n\t\t}\n\t\tif (read_seqcount_retry(&dentry->d_seq, nd->seq)) {\n\t\t\trcu_read_unlock();\n\t\t\tdput(dentry);\n\t\t\tmntput(nd->path.mnt);\n\t\t\treturn -ECHILD;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (likely(!(nd->flags & LOOKUP_JUMPED)))\n\t\treturn 0;\n\n\tif (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))\n\t\treturn 0;\n\n\tstatus = dentry->d_op->d_weak_revalidate(dentry, nd->flags);\n\tif (status > 0)\n\t\treturn 0;\n\n\tif (!status)\n\t\tstatus = -ESTALE;\n\n\tpath_put(&nd->path);\n\treturn status;\n}\n\nstatic __always_inline void set_root(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tget_fs_root(current->fs, &nd->root);\n}\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nstatic __always_inline void set_root_rcu(struct nameidata *nd)\n{\n\tif (!nd->root.mnt) {\n\t\tstruct fs_struct *fs = current->fs;\n\t\tunsigned seq;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\tnd->root = fs->root;\n\t\t\tnd->seq = __read_seqcount_begin(&nd->root.dentry->d_seq);\n\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t}\n}\n\nstatic void path_put_conditional(struct path *path, struct nameidata *nd)\n{\n\tdput(path->dentry);\n\tif (path->mnt != nd->path.mnt)\n\t\tmntput(path->mnt);\n}\n\nstatic inline void path_to_nameidata(const struct path *path,\n\t\t\t\t\tstruct nameidata *nd)\n{\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tdput(nd->path.dentry);\n\t\tif (nd->path.mnt != path->mnt)\n\t\t\tmntput(nd->path.mnt);\n\t}\n\tnd->path.mnt = path->mnt;\n\tnd->path.dentry = path->dentry;\n}\n\n/*\n * Helper to directly jump to a known parsed path from ->follow_link,\n * caller must have taken a reference to path beforehand.\n */\nvoid nd_jump_link(struct nameidata *nd, struct path *path)\n{\n\tpath_put(&nd->path);\n\n\tnd->path = *path;\n\tnd->inode = nd->path.dentry->d_inode;\n\tnd->flags |= LOOKUP_JUMPED;\n}\n\nstatic inline void put_link(struct nameidata *nd, struct path *link, void *cookie)\n{\n\tstruct inode *inode = link->dentry->d_inode;\n\tif (inode->i_op->put_link)\n\t\tinode->i_op->put_link(link->dentry, nd, cookie);\n\tpath_put(link);\n}\n\nint sysctl_protected_symlinks __read_mostly = 0;\nint sysctl_protected_hardlinks __read_mostly = 0;\n\n/**\n * may_follow_link - Check symlink following for unsafe situations\n * @link: The path of the symlink\n * @nd: nameidata pathwalk data\n *\n * In the case of the sysctl_protected_symlinks sysctl being enabled,\n * CAP_DAC_OVERRIDE needs to be specifically ignored if the symlink is\n * in a sticky world-writable directory. This is to protect privileged\n * processes from failing races against path names that may change out\n * from under them by way of other users creating malicious symlinks.\n * It will permit symlinks to be followed only when outside a sticky\n * world-writable directory, or when the uid of the symlink and follower\n * match, or when the directory owner matches the symlink's owner.\n *\n * Returns 0 if following the symlink is allowed, -ve on error.\n */\nstatic inline int may_follow_link(struct path *link, struct nameidata *nd)\n{\n\tconst struct inode *inode;\n\tconst struct inode *parent;\n\n\tif (!sysctl_protected_symlinks)\n\t\treturn 0;\n\n\t/* Allowed if owner and follower match. */\n\tinode = link->dentry->d_inode;\n\tif (uid_eq(current_cred()->fsuid, inode->i_uid))\n\t\treturn 0;\n\n\t/* Allowed if parent directory not sticky and world-writable. */\n\tparent = nd->path.dentry->d_inode;\n\tif ((parent->i_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))\n\t\treturn 0;\n\n\t/* Allowed if parent directory and link owner match. */\n\tif (uid_eq(parent->i_uid, inode->i_uid))\n\t\treturn 0;\n\n\taudit_log_link_denied(\"follow_link\", link);\n\tpath_put_conditional(link, nd);\n\tpath_put(&nd->path);\n\treturn -EACCES;\n}\n\n/**\n * safe_hardlink_source - Check for safe hardlink conditions\n * @inode: the source inode to hardlink from\n *\n * Return false if at least one of the following conditions:\n *    - inode is not a regular file\n *    - inode is setuid\n *    - inode is setgid and group-exec\n *    - access failure for read and write\n *\n * Otherwise returns true.\n */\nstatic bool safe_hardlink_source(struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\n\t/* Special files should not get pinned to the filesystem. */\n\tif (!S_ISREG(mode))\n\t\treturn false;\n\n\t/* Setuid files should not get pinned to the filesystem. */\n\tif (mode & S_ISUID)\n\t\treturn false;\n\n\t/* Executable setgid files should not get pinned to the filesystem. */\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))\n\t\treturn false;\n\n\t/* Hardlinking to unreadable or unwritable sources is dangerous. */\n\tif (inode_permission(inode, MAY_READ | MAY_WRITE))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * may_linkat - Check permissions for creating a hardlink\n * @link: the source to hardlink from\n *\n * Block hardlink when all of:\n *  - sysctl_protected_hardlinks enabled\n *  - fsuid does not match inode\n *  - hardlink source is unsafe (see safe_hardlink_source() above)\n *  - not CAP_FOWNER\n *\n * Returns 0 if successful, -ve on error.\n */\nstatic int may_linkat(struct path *link)\n{\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\n\tif (!sysctl_protected_hardlinks)\n\t\treturn 0;\n\n\tcred = current_cred();\n\tinode = link->dentry->d_inode;\n\n\t/* Source inode owner (or CAP_FOWNER) can hardlink all they like,\n\t * otherwise, it must be a safe source.\n\t */\n\tif (uid_eq(cred->fsuid, inode->i_uid) || safe_hardlink_source(inode) ||\n\t    capable(CAP_FOWNER))\n\t\treturn 0;\n\n\taudit_log_link_denied(\"linkat\", link);\n\treturn -EPERM;\n}\n\nstatic __always_inline int\nfollow_link(struct path *link, struct nameidata *nd, void **p)\n{\n\tstruct dentry *dentry = link->dentry;\n\tint error;\n\tchar *s;\n\n\tBUG_ON(nd->flags & LOOKUP_RCU);\n\n\tif (link->mnt == nd->path.mnt)\n\t\tmntget(link->mnt);\n\n\terror = -ELOOP;\n\tif (unlikely(current->total_link_count >= 40))\n\t\tgoto out_put_nd_path;\n\n\tcond_resched();\n\tcurrent->total_link_count++;\n\n\ttouch_atime(link);\n\tnd_set_link(nd, NULL);\n\n\terror = security_inode_follow_link(link->dentry, nd);\n\tif (error)\n\t\tgoto out_put_nd_path;\n\n\tnd->last_type = LAST_BIND;\n\t*p = dentry->d_inode->i_op->follow_link(dentry, nd);\n\terror = PTR_ERR(*p);\n\tif (IS_ERR(*p))\n\t\tgoto out_put_nd_path;\n\n\terror = 0;\n\ts = nd_get_link(nd);\n\tif (s) {\n\t\tif (unlikely(IS_ERR(s))) {\n\t\t\tpath_put(&nd->path);\n\t\t\tput_link(nd, link, *p);\n\t\t\treturn PTR_ERR(s);\n\t\t}\n\t\tif (*s == '/') {\n\t\t\tset_root(nd);\n\t\t\tpath_put(&nd->path);\n\t\t\tnd->path = nd->root;\n\t\t\tpath_get(&nd->root);\n\t\t\tnd->flags |= LOOKUP_JUMPED;\n\t\t}\n\t\tnd->inode = nd->path.dentry->d_inode;\n\t\terror = link_path_walk(s, nd);\n\t\tif (unlikely(error))\n\t\t\tput_link(nd, link, *p);\n\t}\n\n\treturn error;\n\nout_put_nd_path:\n\t*p = NULL;\n\tpath_put(&nd->path);\n\tpath_put(link);\n\treturn error;\n}\n\nstatic int follow_up_rcu(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tparent = mnt->mnt_parent;\n\tif (&parent->mnt == path->mnt)\n\t\treturn 0;\n\tmountpoint = mnt->mnt_mountpoint;\n\tpath->dentry = mountpoint;\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}\n\n/*\n * follow_up - Find the mountpoint of path's vfsmount\n *\n * Given a path, find the mountpoint of its source file system.\n * Replace @path with the path of the mountpoint in the parent mount.\n * Up is towards /.\n *\n * Return 1 if we went up a level and 0 if we were already at the\n * root.\n */\nint follow_up(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tread_seqlock_excl(&mount_lock);\n\tparent = mnt->mnt_parent;\n\tif (parent == mnt) {\n\t\tread_sequnlock_excl(&mount_lock);\n\t\treturn 0;\n\t}\n\tmntget(&parent->mnt);\n\tmountpoint = dget(mnt->mnt_mountpoint);\n\tread_sequnlock_excl(&mount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}\nEXPORT_SYMBOL(follow_up);\n\n/*\n * Perform an automount\n * - return -EISDIR to tell follow_managed() to stop and return the path we\n *   were called with.\n */\nstatic int follow_automount(struct path *path, unsigned flags,\n\t\t\t    bool *need_mntput)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!path->dentry->d_op || !path->dentry->d_op->d_automount)\n\t\treturn -EREMOTE;\n\n\t/* We don't want to mount if someone's just doing a stat -\n\t * unless they're stat'ing a directory and appended a '/' to\n\t * the name.\n\t *\n\t * We do, however, want to mount if someone wants to open or\n\t * create a file of any type under the mountpoint, wants to\n\t * traverse through the mountpoint or wants to open the\n\t * mounted directory.  Also, autofs may mark negative dentries\n\t * as being automount points.  These will need the attentions\n\t * of the daemon to instantiate them before they can be used.\n\t */\n\tif (!(flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY |\n\t\t     LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &&\n\t    path->dentry->d_inode)\n\t\treturn -EISDIR;\n\n\tcurrent->total_link_count++;\n\tif (current->total_link_count >= 40)\n\t\treturn -ELOOP;\n\n\tmnt = path->dentry->d_op->d_automount(path);\n\tif (IS_ERR(mnt)) {\n\t\t/*\n\t\t * The filesystem is allowed to return -EISDIR here to indicate\n\t\t * it doesn't want to automount.  For instance, autofs would do\n\t\t * this so that its userspace daemon can mount on this dentry.\n\t\t *\n\t\t * However, we can only permit this if it's a terminal point in\n\t\t * the path being looked up; if it wasn't then the remainder of\n\t\t * the path is inaccessible and we should say so.\n\t\t */\n\t\tif (PTR_ERR(mnt) == -EISDIR && (flags & LOOKUP_PARENT))\n\t\t\treturn -EREMOTE;\n\t\treturn PTR_ERR(mnt);\n\t}\n\n\tif (!mnt) /* mount collision */\n\t\treturn 0;\n\n\tif (!*need_mntput) {\n\t\t/* lock_mount() may release path->mnt on error */\n\t\tmntget(path->mnt);\n\t\t*need_mntput = true;\n\t}\n\terr = finish_automount(mnt, path);\n\n\tswitch (err) {\n\tcase -EBUSY:\n\t\t/* Someone else made a mount here whilst we were busy */\n\t\treturn 0;\n\tcase 0:\n\t\tpath_put(path);\n\t\tpath->mnt = mnt;\n\t\tpath->dentry = dget(mnt->mnt_root);\n\t\treturn 0;\n\tdefault:\n\t\treturn err;\n\t}\n\n}\n\n/*\n * Handle a dentry that is managed in some way.\n * - Flagged for transit management (autofs)\n * - Flagged as mountpoint\n * - Flagged as automount point\n *\n * This may only be called in refwalk mode.\n *\n * Serialization is taken care of in namespace.c\n */\nstatic int follow_managed(struct path *path, unsigned flags)\n{\n\tstruct vfsmount *mnt = path->mnt; /* held by caller, must be left alone */\n\tunsigned managed;\n\tbool need_mntput = false;\n\tint ret = 0;\n\n\t/* Given that we're not holding a lock here, we retain the value in a\n\t * local variable for each dentry as we look at it so that we don't see\n\t * the components of that value change under us */\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       managed &= DCACHE_MANAGED_DENTRY,\n\t       unlikely(managed != 0)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held. */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(path->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (mounted) {\n\t\t\t\tdput(path->dentry);\n\t\t\t\tif (need_mntput)\n\t\t\t\t\tmntput(path->mnt);\n\t\t\t\tpath->mnt = mounted;\n\t\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\t\tneed_mntput = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Something is mounted on this dentry in another\n\t\t\t * namespace and/or whatever was mounted there in this\n\t\t\t * namespace got unmounted before lookup_mnt() could\n\t\t\t * get it */\n\t\t}\n\n\t\t/* Handle an automount point */\n\t\tif (managed & DCACHE_NEED_AUTOMOUNT) {\n\t\t\tret = follow_automount(path, flags, &need_mntput);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We didn't change the current path point */\n\t\tbreak;\n\t}\n\n\tif (need_mntput && path->mnt == mnt)\n\t\tmntput(path->mnt);\n\tif (ret == -EISDIR)\n\t\tret = 0;\n\treturn ret < 0 ? ret : need_mntput;\n}\n\nint follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(follow_down_one);\n\nstatic inline bool managed_dentry_might_block(struct dentry *dentry)\n{\n\treturn (dentry->d_flags & DCACHE_MANAGE_TRANSIT &&\n\t\tdentry->d_op->d_manage(dentry, true) < 0);\n}\n\n/*\n * Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if\n * we meet a managed dentry that would need blocking.\n */\nstatic bool __follow_mount_rcu(struct nameidata *nd, struct path *path,\n\t\t\t       struct inode **inode)\n{\n\tfor (;;) {\n\t\tstruct mount *mounted;\n\t\t/*\n\t\t * Don't forget we might have a non-mountpoint managed dentry\n\t\t * that wants to block transit.\n\t\t */\n\t\tif (unlikely(managed_dentry_might_block(path->dentry)))\n\t\t\treturn false;\n\n\t\tif (!d_mountpoint(path->dentry))\n\t\t\treturn true;\n\n\t\tmounted = __lookup_mnt(path->mnt, path->dentry);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tpath->mnt = &mounted->mnt;\n\t\tpath->dentry = mounted->mnt.mnt_root;\n\t\tnd->flags |= LOOKUP_JUMPED;\n\t\tnd->seq = read_seqcount_begin(&path->dentry->d_seq);\n\t\t/*\n\t\t * Update the inode too. We don't need to re-check the\n\t\t * dentry sequence number here after this d_inode read,\n\t\t * because a mount-point is always pinned.\n\t\t */\n\t\t*inode = path->dentry->d_inode;\n\t}\n\treturn read_seqretry(&mount_lock, nd->m_seq);\n}\n\nstatic int follow_dotdot_rcu(struct nameidata *nd)\n{\n\tset_root_rcu(nd);\n\n\twhile (1) {\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tstruct dentry *old = nd->path.dentry;\n\t\t\tstruct dentry *parent = old->d_parent;\n\t\t\tunsigned seq;\n\n\t\t\tseq = read_seqcount_begin(&parent->d_seq);\n\t\t\tif (read_seqcount_retry(&old->d_seq, nd->seq))\n\t\t\t\tgoto failed;\n\t\t\tnd->path.dentry = parent;\n\t\t\tnd->seq = seq;\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up_rcu(&nd->path))\n\t\t\tbreak;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t}\n\twhile (d_mountpoint(nd->path.dentry)) {\n\t\tstruct mount *mounted;\n\t\tmounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tnd->path.mnt = &mounted->mnt;\n\t\tnd->path.dentry = mounted->mnt.mnt_root;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\tif (!read_seqretry(&mount_lock, nd->m_seq))\n\t\t\tgoto failed;\n\t}\n\tnd->inode = nd->path.dentry->d_inode;\n\treturn 0;\n\nfailed:\n\tnd->flags &= ~LOOKUP_RCU;\n\tif (!(nd->flags & LOOKUP_ROOT))\n\t\tnd->root.mnt = NULL;\n\trcu_read_unlock();\n\treturn -ECHILD;\n}\n\n/*\n * Follow down to the covering mount currently visible to userspace.  At each\n * point, the filesystem owning that dentry may be queried as to whether the\n * caller is permitted to proceed or not.\n */\nint follow_down(struct path *path)\n{\n\tunsigned managed;\n\tint ret;\n\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       unlikely(managed & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held.\n\t\t *\n\t\t * We indicate to the filesystem if someone is trying to mount\n\t\t * something here.  This gives autofs the chance to deny anyone\n\t\t * other than its daemon the right to mount on its\n\t\t * superstructure.\n\t\t *\n\t\t * The filesystem may sleep at this point.\n\t\t */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(\n\t\t\t\tpath->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret == -EISDIR ? 0 : ret;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (!mounted)\n\t\t\t\tbreak;\n\t\t\tdput(path->dentry);\n\t\t\tmntput(path->mnt);\n\t\t\tpath->mnt = mounted;\n\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Don't handle automount points here */\n\t\tbreak;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(follow_down);\n\n/*\n * Skip to top of mountpoint pile in refwalk mode for follow_dotdot()\n */\nstatic void follow_mount(struct path *path)\n{\n\twhile (d_mountpoint(path->dentry)) {\n\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t}\n}\n\nstatic void follow_dotdot(struct nameidata *nd)\n{\n\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\t/* rare case of legitimate dget_parent()... */\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}\n\n/*\n * This looks up the name in dcache, possibly revalidates the old dentry and\n * allocates a new one if not found or not valid.  In the need_lookup argument\n * returns whether i_op->lookup is necessary.\n *\n * dir->d_inode->i_mutex must be held\n */\nstatic struct dentry *lookup_dcache(struct qstr *name, struct dentry *dir,\n\t\t\t\t    unsigned int flags, bool *need_lookup)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\t*need_lookup = false;\n\tdentry = d_lookup(dir, name);\n\tif (dentry) {\n\t\tif (dentry->d_flags & DCACHE_OP_REVALIDATE) {\n\t\t\terror = d_revalidate(dentry, flags);\n\t\t\tif (unlikely(error <= 0)) {\n\t\t\t\tif (error < 0) {\n\t\t\t\t\tdput(dentry);\n\t\t\t\t\treturn ERR_PTR(error);\n\t\t\t\t} else if (!d_invalidate(dentry)) {\n\t\t\t\t\tdput(dentry);\n\t\t\t\t\tdentry = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!dentry) {\n\t\tdentry = d_alloc(dir, name);\n\t\tif (unlikely(!dentry))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\t*need_lookup = true;\n\t}\n\treturn dentry;\n}\n\n/*\n * Call i_op->lookup on the dentry.  The dentry must be negative and\n * unhashed.\n *\n * dir->d_inode->i_mutex must be held\n */\nstatic struct dentry *lookup_real(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct dentry *old;\n\n\t/* Don't create child dentry for a dead directory. */\n\tif (unlikely(IS_DEADDIR(dir))) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\told = dir->i_op->lookup(dir, dentry, flags);\n\tif (unlikely(old)) {\n\t\tdput(dentry);\n\t\tdentry = old;\n\t}\n\treturn dentry;\n}\n\nstatic struct dentry *__lookup_hash(struct qstr *name,\n\t\tstruct dentry *base, unsigned int flags)\n{\n\tbool need_lookup;\n\tstruct dentry *dentry;\n\n\tdentry = lookup_dcache(name, base, flags, &need_lookup);\n\tif (!need_lookup)\n\t\treturn dentry;\n\n\treturn lookup_real(base->d_inode, dentry, flags);\n}\n\n/*\n *  It's more convoluted than I'd like it to be, but... it's still fairly\n *  small and for now I'd prefer to have fast path as straight as possible.\n *  It _is_ time-critical.\n */\nstatic int lookup_fast(struct nameidata *nd,\n\t\t       struct path *path, struct inode **inode)\n{\n\tstruct vfsmount *mnt = nd->path.mnt;\n\tstruct dentry *dentry, *parent = nd->path.dentry;\n\tint need_reval = 1;\n\tint status = 1;\n\tint err;\n\n\t/*\n\t * Rename seqlock is not required here because in the off chance\n\t * of a false negative due to a concurrent rename, we're going to\n\t * do the non-racy lookup, below.\n\t */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tunsigned seq;\n\t\tdentry = __d_lookup_rcu(parent, &nd->last, &seq);\n\t\tif (!dentry)\n\t\t\tgoto unlazy;\n\n\t\t/*\n\t\t * This sequence count validates that the inode matches\n\t\t * the dentry name information from lookup.\n\t\t */\n\t\t*inode = dentry->d_inode;\n\t\tif (read_seqcount_retry(&dentry->d_seq, seq))\n\t\t\treturn -ECHILD;\n\n\t\t/*\n\t\t * This sequence count validates that the parent had no\n\t\t * changes while we did the lookup of the dentry above.\n\t\t *\n\t\t * The memory barrier in read_seqcount_begin of child is\n\t\t *  enough, we can use __read_seqcount_retry here.\n\t\t */\n\t\tif (__read_seqcount_retry(&parent->d_seq, nd->seq))\n\t\t\treturn -ECHILD;\n\t\tnd->seq = seq;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE)) {\n\t\t\tstatus = d_revalidate(dentry, nd->flags);\n\t\t\tif (unlikely(status <= 0)) {\n\t\t\t\tif (status != -ECHILD)\n\t\t\t\t\tneed_reval = 0;\n\t\t\t\tgoto unlazy;\n\t\t\t}\n\t\t}\n\t\tpath->mnt = mnt;\n\t\tpath->dentry = dentry;\n\t\tif (unlikely(!__follow_mount_rcu(nd, path, inode)))\n\t\t\tgoto unlazy;\n\t\tif (unlikely(path->dentry->d_flags & DCACHE_NEED_AUTOMOUNT))\n\t\t\tgoto unlazy;\n\t\treturn 0;\nunlazy:\n\t\tif (unlazy_walk(nd, dentry))\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tdentry = __d_lookup(parent, &nd->last);\n\t}\n\n\tif (unlikely(!dentry))\n\t\tgoto need_lookup;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE) && need_reval)\n\t\tstatus = d_revalidate(dentry, nd->flags);\n\tif (unlikely(status <= 0)) {\n\t\tif (status < 0) {\n\t\t\tdput(dentry);\n\t\t\treturn status;\n\t\t}\n\t\tif (!d_invalidate(dentry)) {\n\t\t\tdput(dentry);\n\t\t\tgoto need_lookup;\n\t\t}\n\t}\n\n\tpath->mnt = mnt;\n\tpath->dentry = dentry;\n\terr = follow_managed(path, nd->flags);\n\tif (unlikely(err < 0)) {\n\t\tpath_put_conditional(path, nd);\n\t\treturn err;\n\t}\n\tif (err)\n\t\tnd->flags |= LOOKUP_JUMPED;\n\t*inode = path->dentry->d_inode;\n\treturn 0;\n\nneed_lookup:\n\treturn 1;\n}\n\n/* Fast lookup failed, do it the slow way */\nstatic int lookup_slow(struct nameidata *nd, struct path *path)\n{\n\tstruct dentry *dentry, *parent;\n\tint err;\n\n\tparent = nd->path.dentry;\n\tBUG_ON(nd->inode != parent->d_inode);\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tdentry = __lookup_hash(&nd->last, parent, nd->flags);\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tpath->mnt = nd->path.mnt;\n\tpath->dentry = dentry;\n\terr = follow_managed(path, nd->flags);\n\tif (unlikely(err < 0)) {\n\t\tpath_put_conditional(path, nd);\n\t\treturn err;\n\t}\n\tif (err)\n\t\tnd->flags |= LOOKUP_JUMPED;\n\treturn 0;\n}\n\nstatic inline int may_lookup(struct nameidata *nd)\n{\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tint err = inode_permission(nd->inode, MAY_EXEC|MAY_NOT_BLOCK);\n\t\tif (err != -ECHILD)\n\t\t\treturn err;\n\t\tif (unlazy_walk(nd, NULL))\n\t\t\treturn -ECHILD;\n\t}\n\treturn inode_permission(nd->inode, MAY_EXEC);\n}\n\nstatic inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tif (follow_dotdot_rcu(nd))\n\t\t\t\treturn -ECHILD;\n\t\t} else\n\t\t\tfollow_dotdot(nd);\n\t}\n\treturn 0;\n}\n\nstatic void terminate_walk(struct nameidata *nd)\n{\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tpath_put(&nd->path);\n\t} else {\n\t\tnd->flags &= ~LOOKUP_RCU;\n\t\tif (!(nd->flags & LOOKUP_ROOT))\n\t\t\tnd->root.mnt = NULL;\n\t\trcu_read_unlock();\n\t}\n}\n\n/*\n * Do we need to follow links? We _really_ want to be able\n * to do this check without having to look at inode->i_op,\n * so we keep a cache of \"no, this doesn't need follow_link\"\n * for the common case.\n */\nstatic inline int should_follow_link(struct dentry *dentry, int follow)\n{\n\treturn unlikely(d_is_symlink(dentry)) ? follow : 0;\n}\n\nstatic inline int walk_component(struct nameidata *nd, struct path *path,\n\t\tint follow)\n{\n\tstruct inode *inode;\n\tint err;\n\t/*\n\t * \".\" and \"..\" are special - \"..\" especially so because it has\n\t * to be able to know about the current root directory and\n\t * parent relationships.\n\t */\n\tif (unlikely(nd->last_type != LAST_NORM))\n\t\treturn handle_dots(nd, nd->last_type);\n\terr = lookup_fast(nd, path, &inode);\n\tif (unlikely(err)) {\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\n\t\terr = lookup_slow(nd, path);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\n\t\tinode = path->dentry->d_inode;\n\t}\n\terr = -ENOENT;\n\tif (!inode || d_is_negative(path->dentry))\n\t\tgoto out_path_put;\n\n\tif (should_follow_link(path->dentry, follow)) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tif (unlikely(unlazy_walk(nd, path->dentry))) {\n\t\t\t\terr = -ECHILD;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(inode != path->dentry->d_inode);\n\t\treturn 1;\n\t}\n\tpath_to_nameidata(path, nd);\n\tnd->inode = inode;\n\treturn 0;\n\nout_path_put:\n\tpath_to_nameidata(path, nd);\nout_err:\n\tterminate_walk(nd);\n\treturn err;\n}\n\n/*\n * This limits recursive symlink follows to 8, while\n * limiting consecutive symlinks to 40.\n *\n * Without that kind of total limit, nasty chains of consecutive\n * symlinks can cause almost arbitrarily long lookups.\n */\nstatic inline int nested_symlink(struct path *path, struct nameidata *nd)\n{\n\tint res;\n\n\tif (unlikely(current->link_count >= MAX_NESTED_LINKS)) {\n\t\tpath_put_conditional(path, nd);\n\t\tpath_put(&nd->path);\n\t\treturn -ELOOP;\n\t}\n\tBUG_ON(nd->depth >= MAX_NESTED_LINKS);\n\n\tnd->depth++;\n\tcurrent->link_count++;\n\n\tdo {\n\t\tstruct path link = *path;\n\t\tvoid *cookie;\n\n\t\tres = follow_link(&link, nd, &cookie);\n\t\tif (res)\n\t\t\tbreak;\n\t\tres = walk_component(nd, path, LOOKUP_FOLLOW);\n\t\tput_link(nd, &link, cookie);\n\t} while (res > 0);\n\n\tcurrent->link_count--;\n\tnd->depth--;\n\treturn res;\n}\n\n/*\n * We can do the critical dentry name comparison and hashing\n * operations one word at a time, but we are limited to:\n *\n * - Architectures with fast unaligned word accesses. We could\n *   do a \"get_unaligned()\" if this helps and is sufficiently\n *   fast.\n *\n * - non-CONFIG_DEBUG_PAGEALLOC configurations (so that we\n *   do not trap on the (extremely unlikely) case of a page\n *   crossing operation.\n *\n * - Furthermore, we need an efficient 64-bit compile for the\n *   64-bit case in order to generate the \"number of bytes in\n *   the final mask\". Again, that could be replaced with a\n *   efficient population count instruction or similar.\n */\n#ifdef CONFIG_DCACHE_WORD_ACCESS\n\n#include <asm/word-at-a-time.h>\n\n#ifdef CONFIG_64BIT\n\nstatic inline unsigned int fold_hash(unsigned long hash)\n{\n\thash += hash >> (8*sizeof(int));\n\treturn hash;\n}\n\n#else\t/* 32-bit case */\n\n#define fold_hash(x) (x)\n\n#endif\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long a, mask;\n\tunsigned long hash = 0;\n\n\tfor (;;) {\n\t\ta = load_unaligned_zeropad(name);\n\t\tif (len < sizeof(unsigned long))\n\t\t\tbreak;\n\t\thash += a;\n\t\thash *= 9;\n\t\tname += sizeof(unsigned long);\n\t\tlen -= sizeof(unsigned long);\n\t\tif (!len)\n\t\t\tgoto done;\n\t}\n\tmask = bytemask_from_count(len);\n\thash += mask & a;\ndone:\n\treturn fold_hash(hash);\n}\nEXPORT_SYMBOL(full_name_hash);\n\n/*\n * Calculate the length and hash of the path component, and\n * return the length of the component;\n */\nstatic inline unsigned long hash_name(const char *name, unsigned int *hashp)\n{\n\tunsigned long a, b, adata, bdata, mask, hash, len;\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\n\thash = a = 0;\n\tlen = -sizeof(unsigned long);\n\tdo {\n\t\thash = (hash + a) * 9;\n\t\tlen += sizeof(unsigned long);\n\t\ta = load_unaligned_zeropad(name+len);\n\t\tb = a ^ REPEAT_BYTE('/');\n\t} while (!(has_zero(a, &adata, &constants) | has_zero(b, &bdata, &constants)));\n\n\tadata = prep_zero_mask(a, adata, &constants);\n\tbdata = prep_zero_mask(b, bdata, &constants);\n\n\tmask = create_zero_mask(adata | bdata);\n\n\thash += a & zero_bytemask(mask);\n\t*hashp = fold_hash(hash);\n\n\treturn len + find_zero(mask);\n}\n\n#else\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}\nEXPORT_SYMBOL(full_name_hash);\n\n/*\n * We know there's a real path component here of at least\n * one character.\n */\nstatic inline unsigned long hash_name(const char *name, unsigned int *hashp)\n{\n\tunsigned long hash = init_name_hash();\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\tdo {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t} while (c && c != '/');\n\t*hashp = end_name_hash(hash);\n\treturn len;\n}\n\n#endif\n\n/*\n * Name resolution.\n * This is the basic name resolution function, turning a pathname into\n * the final dentry. We expect 'base' to be positive and a directory.\n *\n * Returns 0 and nd will have valid dentry and mnt on success.\n * Returns error and drops reference to input namei data on failure.\n */\nstatic int link_path_walk(const char *name, struct nameidata *nd)\n{\n\tstruct path next;\n\tint err;\n\t\n\twhile (*name=='/')\n\t\tname++;\n\tif (!*name)\n\t\treturn 0;\n\n\t/* At this point we know we have a real path component. */\n\tfor(;;) {\n\t\tstruct qstr this;\n\t\tlong len;\n\t\tint type;\n\n\t\terr = may_lookup(nd);\n \t\tif (err)\n\t\t\tbreak;\n\n\t\tlen = hash_name(name, &this.hash);\n\t\tthis.name = name;\n\t\tthis.len = len;\n\n\t\ttype = LAST_NORM;\n\t\tif (name[0] == '.') switch (len) {\n\t\t\tcase 2:\n\t\t\t\tif (name[1] == '.') {\n\t\t\t\t\ttype = LAST_DOTDOT;\n\t\t\t\t\tnd->flags |= LOOKUP_JUMPED;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttype = LAST_DOT;\n\t\t}\n\t\tif (likely(type == LAST_NORM)) {\n\t\t\tstruct dentry *parent = nd->path.dentry;\n\t\t\tnd->flags &= ~LOOKUP_JUMPED;\n\t\t\tif (unlikely(parent->d_flags & DCACHE_OP_HASH)) {\n\t\t\t\terr = parent->d_op->d_hash(parent, &this);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tnd->last = this;\n\t\tnd->last_type = type;\n\n\t\tif (!name[len])\n\t\t\treturn 0;\n\t\t/*\n\t\t * If it wasn't NUL, we know it was '/'. Skip that\n\t\t * slash, and continue until no more slashes.\n\t\t */\n\t\tdo {\n\t\t\tlen++;\n\t\t} while (unlikely(name[len] == '/'));\n\t\tif (!name[len])\n\t\t\treturn 0;\n\n\t\tname += len;\n\n\t\terr = walk_component(nd, &next, LOOKUP_FOLLOW);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (err) {\n\t\t\terr = nested_symlink(&next, nd);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (!d_can_lookup(nd->path.dentry)) {\n\t\t\terr = -ENOTDIR; \n\t\t\tbreak;\n\t\t}\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n\nstatic int path_init(int dfd, const char *name, unsigned int flags,\n\t\t     struct nameidata *nd, struct file **fp)\n{\n\tint retval = 0;\n\n\tnd->last_type = LAST_ROOT; /* if there are only slashes... */\n\tnd->flags = flags | LOOKUP_JUMPED;\n\tnd->depth = 0;\n\tif (flags & LOOKUP_ROOT) {\n\t\tstruct dentry *root = nd->root.dentry;\n\t\tstruct inode *inode = root->d_inode;\n\t\tif (*name) {\n\t\t\tif (!d_can_lookup(root))\n\t\t\t\treturn -ENOTDIR;\n\t\t\tretval = inode_permission(inode, MAY_EXEC);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tnd->path = nd->root;\n\t\tnd->inode = inode;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\trcu_read_lock();\n\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\tnd->m_seq = read_seqbegin(&mount_lock);\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tnd->root.mnt = NULL;\n\n\tnd->m_seq = read_seqbegin(&mount_lock);\n\tif (*name=='/') {\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\trcu_read_lock();\n\t\t\tset_root_rcu(nd);\n\t\t} else {\n\t\t\tset_root(nd);\n\t\t\tpath_get(&nd->root);\n\t\t}\n\t\tnd->path = nd->root;\n\t} else if (dfd == AT_FDCWD) {\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tstruct fs_struct *fs = current->fs;\n\t\t\tunsigned seq;\n\n\t\t\trcu_read_lock();\n\n\t\t\tdo {\n\t\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\t\tnd->path = fs->pwd;\n\t\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t\t} else {\n\t\t\tget_fs_pwd(current->fs, &nd->path);\n\t\t}\n\t} else {\n\t\t/* Caller must check execute permissions on the starting path component */\n\t\tstruct fd f = fdget_raw(dfd);\n\t\tstruct dentry *dentry;\n\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\n\t\tdentry = f.file->f_path.dentry;\n\n\t\tif (*name) {\n\t\t\tif (!d_can_lookup(dentry)) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -ENOTDIR;\n\t\t\t}\n\t\t}\n\n\t\tnd->path = f.file->f_path;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tif (f.flags & FDPUT_FPUT)\n\t\t\t\t*fp = f.file;\n\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\trcu_read_lock();\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t\tfdput(f);\n\t\t}\n\t}\n\n\tnd->inode = nd->path.dentry->d_inode;\n\treturn 0;\n}\n\nstatic inline int lookup_last(struct nameidata *nd, struct path *path)\n{\n\tif (nd->last_type == LAST_NORM && nd->last.name[nd->last.len])\n\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\treturn walk_component(nd, path, nd->flags & LOOKUP_FOLLOW);\n}\n\n/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */\nstatic int path_lookupat(int dfd, const char *name,\n\t\t\t\tunsigned int flags, struct nameidata *nd)\n{\n\tstruct file *base = NULL;\n\tstruct path path;\n\tint err;\n\n\t/*\n\t * Path walking is largely split up into 2 different synchronisation\n\t * schemes, rcu-walk and ref-walk (explained in\n\t * Documentation/filesystems/path-lookup.txt). These share much of the\n\t * path walk code, but some things particularly setup, cleanup, and\n\t * following mounts are sufficiently divergent that functions are\n\t * duplicated. Typically there is a function foo(), and its RCU\n\t * analogue, foo_rcu().\n\t *\n\t * -ECHILD is the error number of choice (just to avoid clashes) that\n\t * is returned if some aspect of an rcu-walk fails. Such an error must\n\t * be handled by restarting a traditional ref-walk (which will always\n\t * be able to complete).\n\t */\n\terr = path_init(dfd, name, flags | LOOKUP_PARENT, nd, &base);\n\n\tif (unlikely(err))\n\t\treturn err;\n\n\tcurrent->total_link_count = 0;\n\terr = link_path_walk(name, nd);\n\n\tif (!err && !(flags & LOOKUP_PARENT)) {\n\t\terr = lookup_last(nd, &path);\n\t\twhile (err > 0) {\n\t\t\tvoid *cookie;\n\t\t\tstruct path link = path;\n\t\t\terr = may_follow_link(&link, nd);\n\t\t\tif (unlikely(err))\n\t\t\t\tbreak;\n\t\t\tnd->flags |= LOOKUP_PARENT;\n\t\t\terr = follow_link(&link, nd, &cookie);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\terr = lookup_last(nd, &path);\n\t\t\tput_link(nd, &link, cookie);\n\t\t}\n\t}\n\n\tif (!err)\n\t\terr = complete_walk(nd);\n\n\tif (!err && nd->flags & LOOKUP_DIRECTORY) {\n\t\tif (!d_can_lookup(nd->path.dentry)) {\n\t\t\tpath_put(&nd->path);\n\t\t\terr = -ENOTDIR;\n\t\t}\n\t}\n\n\tif (base)\n\t\tfput(base);\n\n\tif (nd->root.mnt && !(nd->flags & LOOKUP_ROOT)) {\n\t\tpath_put(&nd->root);\n\t\tnd->root.mnt = NULL;\n\t}\n\treturn err;\n}\n\nstatic int filename_lookup(int dfd, struct filename *name,\n\t\t\t\tunsigned int flags, struct nameidata *nd)\n{\n\tint retval = path_lookupat(dfd, name->name, flags | LOOKUP_RCU, nd);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_lookupat(dfd, name->name, flags, nd);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_lookupat(dfd, name->name,\n\t\t\t\t\t\tflags | LOOKUP_REVAL, nd);\n\n\tif (likely(!retval))\n\t\taudit_inode(name, nd->path.dentry, flags & LOOKUP_PARENT);\n\treturn retval;\n}\n\nstatic int do_path_lookup(int dfd, const char *name,\n\t\t\t\tunsigned int flags, struct nameidata *nd)\n{\n\tstruct filename filename = { .name = name };\n\n\treturn filename_lookup(dfd, &filename, flags, nd);\n}\n\n/* does lookup, returns the object with parent locked */\nstruct dentry *kern_path_locked(const char *name, struct path *path)\n{\n\tstruct nameidata nd;\n\tstruct dentry *d;\n\tint err = do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, &nd);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (nd.last_type != LAST_NORM) {\n\t\tpath_put(&nd.path);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\td = __lookup_hash(&nd.last, nd.path.dentry, 0);\n\tif (IS_ERR(d)) {\n\t\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\t\tpath_put(&nd.path);\n\t\treturn d;\n\t}\n\t*path = nd.path;\n\treturn d;\n}\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}\nEXPORT_SYMBOL(kern_path);\n\n/**\n * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair\n * @dentry:  pointer to dentry of the base directory\n * @mnt: pointer to vfs mount of the base directory\n * @name: pointer to file name\n * @flags: lookup flags\n * @path: pointer to struct path to fill\n */\nint vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,\n\t\t    const char *name, unsigned int flags,\n\t\t    struct path *path)\n{\n\tstruct nameidata nd;\n\tint err;\n\tnd.root.dentry = dentry;\n\tnd.root.mnt = mnt;\n\tBUG_ON(flags & LOOKUP_PARENT);\n\t/* the first argument of do_path_lookup() is ignored with LOOKUP_ROOT */\n\terr = do_path_lookup(AT_FDCWD, name, flags | LOOKUP_ROOT, &nd);\n\tif (!err)\n\t\t*path = nd.path;\n\treturn err;\n}\nEXPORT_SYMBOL(vfs_path_lookup);\n\n/*\n * Restricted form of lookup. Doesn't follow links, single-component only,\n * needs parent already locked. Doesn't follow mounts.\n * SMP-safe.\n */\nstatic struct dentry *lookup_hash(struct nameidata *nd)\n{\n\treturn __lookup_hash(&nd->last, nd->path.dentry, nd->flags);\n}\n\n/**\n * lookup_one_len - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.  Also note that by using this function the\n * nameidata argument is passed to the filesystem methods and a filesystem\n * using this helper needs to be prepared for that.\n */\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}\nEXPORT_SYMBOL(lookup_one_len);\n\nint user_path_at_empty(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path, int *empty)\n{\n\tstruct nameidata nd;\n\tstruct filename *tmp = getname_flags(name, flags, empty);\n\tint err = PTR_ERR(tmp);\n\tif (!IS_ERR(tmp)) {\n\n\t\tBUG_ON(flags & LOOKUP_PARENT);\n\n\t\terr = filename_lookup(dfd, tmp, flags, &nd);\n\t\tputname(tmp);\n\t\tif (!err)\n\t\t\t*path = nd.path;\n\t}\n\treturn err;\n}\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}\nEXPORT_SYMBOL(user_path_at);\n\n/*\n * NB: most callers don't do anything directly with the reference to the\n *     to struct filename, but the nd->last pointer points into the name string\n *     allocated by getname. So we must hold the reference to it until all\n *     path-walking is complete.\n */\nstatic struct filename *\nuser_path_parent(int dfd, const char __user *path, struct nameidata *nd,\n\t\t unsigned int flags)\n{\n\tstruct filename *s = getname(path);\n\tint error;\n\n\t/* only LOOKUP_REVAL is allowed in extra flags */\n\tflags &= LOOKUP_REVAL;\n\n\tif (IS_ERR(s))\n\t\treturn s;\n\n\terror = filename_lookup(dfd, s, flags | LOOKUP_PARENT, nd);\n\tif (error) {\n\t\tputname(s);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn s;\n}\n\n/**\n * mountpoint_last - look up last component for umount\n * @nd:   pathwalk nameidata - currently pointing at parent directory of \"last\"\n * @path: pointer to container for result\n *\n * This is a special lookup_last function just for umount. In this case, we\n * need to resolve the path without doing any revalidation.\n *\n * The nameidata should be the result of doing a LOOKUP_PARENT pathwalk. Since\n * mountpoints are always pinned in the dcache, their ancestors are too. Thus,\n * in almost all cases, this lookup will be served out of the dcache. The only\n * cases where it won't are if nd->last refers to a symlink or the path is\n * bogus and it doesn't exist.\n *\n * Returns:\n * -error: if there was an error during lookup. This includes -ENOENT if the\n *         lookup found a negative dentry. The nd->path reference will also be\n *         put in this case.\n *\n * 0:      if we successfully resolved nd->path and found it to not to be a\n *         symlink that needs to be followed. \"path\" will also be populated.\n *         The nd->path reference will also be put.\n *\n * 1:      if we successfully resolved nd->last and found it to be a symlink\n *         that needs to be followed. \"path\" will be populated with the path\n *         to the link, and nd->path will *not* be put.\n */\nstatic int\nmountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\n\t/* If we're in rcuwalk, drop out of it to handle last component */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\t/*\n\t\t * No cached dentry. Mounted dentries are pinned in the cache,\n\t\t * so that means that this dentry is probably a symlink or the\n\t\t * path doesn't actually point to a mounted dentry.\n\t\t */\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n\tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n\t\treturn 1;\n\tfollow_mount(path);\n\terror = 0;\nout:\n\tterminate_walk(nd);\n\treturn error;\n}\n\n/**\n * path_mountpoint - look up a path to be umounted\n * @dfd:\tdirectory file descriptor to start walk from\n * @name:\tfull pathname to walk\n * @path:\tpointer to container for result\n * @flags:\tlookup flags\n *\n * Look up the given name, but don't attempt to revalidate the last component.\n * Returns 0 and \"path\" will be valid on success; Returns error otherwise.\n */\nstatic int\npath_mountpoint(int dfd, const char *name, struct path *path, unsigned int flags)\n{\n\tstruct file *base = NULL;\n\tstruct nameidata nd;\n\tint err;\n\n\terr = path_init(dfd, name, flags | LOOKUP_PARENT, &nd, &base);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tcurrent->total_link_count = 0;\n\terr = link_path_walk(name, &nd);\n\tif (err)\n\t\tgoto out;\n\n\terr = mountpoint_last(&nd, path);\n\twhile (err > 0) {\n\t\tvoid *cookie;\n\t\tstruct path link = *path;\n\t\terr = may_follow_link(&link, &nd);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tnd.flags |= LOOKUP_PARENT;\n\t\terr = follow_link(&link, &nd, &cookie);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = mountpoint_last(&nd, path);\n\t\tput_link(&nd, &link, cookie);\n\t}\nout:\n\tif (base)\n\t\tfput(base);\n\n\tif (nd.root.mnt && !(nd.flags & LOOKUP_ROOT))\n\t\tpath_put(&nd.root);\n\n\treturn err;\n}\n\nstatic int\nfilename_mountpoint(int dfd, struct filename *s, struct path *path,\n\t\t\tunsigned int flags)\n{\n\tint error = path_mountpoint(dfd, s->name, path, flags | LOOKUP_RCU);\n\tif (unlikely(error == -ECHILD))\n\t\terror = path_mountpoint(dfd, s->name, path, flags);\n\tif (unlikely(error == -ESTALE))\n\t\terror = path_mountpoint(dfd, s->name, path, flags | LOOKUP_REVAL);\n\tif (likely(!error))\n\t\taudit_inode(s, path->dentry, 0);\n\treturn error;\n}\n\n/**\n * user_path_mountpoint_at - lookup a path from userland in order to umount it\n * @dfd:\tdirectory file descriptor\n * @name:\tpathname from userland\n * @flags:\tlookup flags\n * @path:\tpointer to container to hold result\n *\n * A umount is a special case for path walking. We're not actually interested\n * in the inode in this situation, and ESTALE errors can be a problem. We\n * simply want track down the dentry and vfsmount attached at the mountpoint\n * and avoid revalidating the last component.\n *\n * Returns 0 and populates \"path\" on success.\n */\nint\nuser_path_mountpoint_at(int dfd, const char __user *name, unsigned int flags,\n\t\t\tstruct path *path)\n{\n\tstruct filename *s = getname(name);\n\tint error;\n\tif (IS_ERR(s))\n\t\treturn PTR_ERR(s);\n\terror = filename_mountpoint(dfd, s, path, flags);\n\tputname(s);\n\treturn error;\n}\n\nint\nkern_path_mountpoint(int dfd, const char *name, struct path *path,\n\t\t\tunsigned int flags)\n{\n\tstruct filename s = {.name = name};\n\treturn filename_mountpoint(dfd, &s, path, flags);\n}\nEXPORT_SYMBOL(kern_path_mountpoint);\n\n/*\n * It's inline, so penalty for filesystems that don't use sticky bit is\n * minimal.\n */\nstatic inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !capable_wrt_inode_uidgid(inode, CAP_FOWNER);\n}\n\n/*\n *\tCheck whether we can remove a link victim from directory dir, check\n *  whether the type of victim is right.\n *  1. We can't do it if dir is read-only (done in permission())\n *  2. We should have write and exec permissions on dir\n *  3. We can't remove anything from append-only dir\n *  4. We can't do anything with immutable dir (done in permission())\n *  5. If the sticky bit on dir is set we should either\n *\ta. be owner of dir, or\n *\tb. be owner of victim, or\n *\tc. have CAP_FOWNER capability\n *  6. If the victim is append-only or immutable we can't do antyhing with\n *     links pointing to it.\n *  7. If we were asked to remove a directory and victim isn't one - ENOTDIR.\n *  8. If we were asked to remove a non-directory and victim isn't one - EISDIR.\n *  9. We can't remove a root or mountpoint.\n * 10. We don't allow removal of NFS sillyrenamed files; it's handled by\n *     nfs_async_unlink().\n */\nstatic int may_delete(struct inode *dir, struct dentry *victim, bool isdir)\n{\n\tstruct inode *inode = victim->d_inode;\n\tint error;\n\n\tif (d_is_negative(victim))\n\t\treturn -ENOENT;\n\tBUG_ON(!inode);\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\n\tif (check_sticky(dir, inode) || IS_APPEND(inode) ||\n\t    IS_IMMUTABLE(inode) || IS_SWAPFILE(inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!d_is_dir(victim))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (d_is_dir(victim))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n/*\tCheck whether we can create an object with dentry child in directory\n *  dir.\n *  1. We can't do it if child already exists (open has special treatment for\n *     this case, but since we are inlined it's OK)\n *  2. We can't do it if dir is read-only (done in permission())\n *  3. We should have write and exec permissions on dir\n *  4. We can't do it if dir is immutable (done in permission())\n */\nstatic inline int may_create(struct inode *dir, struct dentry *child)\n{\n\taudit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}\n\n/*\n * p1 and p2 should be directories on the same fs.\n */\nstruct dentry *lock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tif (p1 == p2) {\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\n\tp = d_ancestor(p2, p1);\n\tif (p) {\n\t\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tp = d_ancestor(p1, p2);\n\tif (p) {\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);\n\treturn NULL;\n}\nEXPORT_SYMBOL(lock_rename);\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}\nEXPORT_SYMBOL(unlock_rename);\n\nint vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool want_excl)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = dir->i_op->create(dir, dentry, mode, want_excl);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_create);\n\nstatic int may_open(struct path *path, int acc_mode, int flag)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\t/* O_PATH? */\n\tif (!acc_mode)\n\t\treturn 0;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\treturn -ELOOP;\n\tcase S_IFDIR:\n\t\tif (acc_mode & MAY_WRITE)\n\t\t\treturn -EISDIR;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tif (path->mnt->mnt_flags & MNT_NODEV)\n\t\t\treturn -EACCES;\n\t\t/*FALLTHRU*/\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tflag &= ~O_TRUNC;\n\t\tbreak;\n\t}\n\n\terror = inode_permission(inode, acc_mode);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * An append-only file must be opened in append mode for writing.\n\t */\n\tif (IS_APPEND(inode)) {\n\t\tif  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))\n\t\t\treturn -EPERM;\n\t\tif (flag & O_TRUNC)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* O_NOATIME can only be set by the owner or superuser */\n\tif (flag & O_NOATIME && !inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic int handle_truncate(struct file *filp)\n{\n\tstruct path *path = &filp->f_path;\n\tstruct inode *inode = path->dentry->d_inode;\n\tint error = get_write_access(inode);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Refuse to truncate files with mandatory locks held on them.\n\t */\n\terror = locks_verify_locked(filp);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error) {\n\t\terror = do_truncate(path->dentry, 0,\n\t\t\t\t    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,\n\t\t\t\t    filp);\n\t}\n\tput_write_access(inode);\n\treturn error;\n}\n\nstatic inline int open_to_namei_flags(int flag)\n{\n\tif ((flag & O_ACCMODE) == 3)\n\t\tflag--;\n\treturn flag;\n}\n\nstatic int may_o_create(struct path *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = security_path_mknod(dir, dentry, mode, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = inode_permission(dir->dentry->d_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn security_inode_create(dir->dentry->d_inode, dentry, mode);\n}\n\n/*\n * Attempt to atomically look up, create and open a file from a negative\n * dentry.\n *\n * Returns 0 if successful.  The file will have been created and attached to\n * @file by the filesystem calling finish_open().\n *\n * Returns 1 if the file was looked up only or didn't need creating.  The\n * caller will need to perform the open themselves.  @path will have been\n * updated to point to the new dentry.  This may be negative.\n *\n * Returns an error code otherwise.\n */\nstatic int atomic_open(struct nameidata *nd, struct dentry *dentry,\n\t\t\tstruct path *path, struct file *file,\n\t\t\tconst struct open_flags *op,\n\t\t\tbool got_write, bool need_lookup,\n\t\t\tint *opened)\n{\n\tstruct inode *dir =  nd->path.dentry->d_inode;\n\tunsigned open_flag = open_to_namei_flags(op->open_flag);\n\tumode_t mode;\n\tint error;\n\tint acc_mode;\n\tint create_error = 0;\n\tstruct dentry *const DENTRY_NOT_SET = (void *) -1UL;\n\tbool excl;\n\n\tBUG_ON(dentry->d_inode);\n\n\t/* Don't create child dentry for a dead directory. */\n\tif (unlikely(IS_DEADDIR(dir))) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tmode = op->mode;\n\tif ((open_flag & O_CREAT) && !IS_POSIXACL(dir))\n\t\tmode &= ~current_umask();\n\n\texcl = (open_flag & (O_EXCL | O_CREAT)) == (O_EXCL | O_CREAT);\n\tif (excl)\n\t\topen_flag &= ~O_TRUNC;\n\n\t/*\n\t * Checking write permission is tricky, bacuse we don't know if we are\n\t * going to actually need it: O_CREAT opens should work as long as the\n\t * file exists.  But checking existence breaks atomicity.  The trick is\n\t * to check access and if not granted clear O_CREAT from the flags.\n\t *\n\t * Another problem is returing the \"right\" error value (e.g. for an\n\t * O_EXCL open we want to return EEXIST not EROFS).\n\t */\n\tif (((open_flag & (O_CREAT | O_TRUNC)) ||\n\t    (open_flag & O_ACCMODE) != O_RDONLY) && unlikely(!got_write)) {\n\t\tif (!(open_flag & O_CREAT)) {\n\t\t\t/*\n\t\t\t * No O_CREATE -> atomicity not a requirement -> fall\n\t\t\t * back to lookup + open\n\t\t\t */\n\t\t\tgoto no_open;\n\t\t} else if (open_flag & (O_EXCL | O_TRUNC)) {\n\t\t\t/* Fall back and fail with the right error */\n\t\t\tcreate_error = -EROFS;\n\t\t\tgoto no_open;\n\t\t} else {\n\t\t\t/* No side effects, safe to clear O_CREAT */\n\t\t\tcreate_error = -EROFS;\n\t\t\topen_flag &= ~O_CREAT;\n\t\t}\n\t}\n\n\tif (open_flag & O_CREAT) {\n\t\terror = may_o_create(&nd->path, dentry, mode);\n\t\tif (error) {\n\t\t\tcreate_error = error;\n\t\t\tif (open_flag & O_EXCL)\n\t\t\t\tgoto no_open;\n\t\t\topen_flag &= ~O_CREAT;\n\t\t}\n\t}\n\n\tif (nd->flags & LOOKUP_DIRECTORY)\n\t\topen_flag |= O_DIRECTORY;\n\n\tfile->f_path.dentry = DENTRY_NOT_SET;\n\tfile->f_path.mnt = nd->path.mnt;\n\terror = dir->i_op->atomic_open(dir, dentry, file, open_flag, mode,\n\t\t\t\t      opened);\n\tif (error < 0) {\n\t\tif (create_error && error == -ENOENT)\n\t\t\terror = create_error;\n\t\tgoto out;\n\t}\n\n\tif (error) {\t/* returned 1, that is */\n\t\tif (WARN_ON(file->f_path.dentry == DENTRY_NOT_SET)) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (file->f_path.dentry) {\n\t\t\tdput(dentry);\n\t\t\tdentry = file->f_path.dentry;\n\t\t}\n\t\tif (*opened & FILE_CREATED)\n\t\t\tfsnotify_create(dir, dentry);\n\t\tif (!dentry->d_inode) {\n\t\t\tWARN_ON(*opened & FILE_CREATED);\n\t\t\tif (create_error) {\n\t\t\t\terror = create_error;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tif (excl && !(*opened & FILE_CREATED)) {\n\t\t\t\terror = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tgoto looked_up;\n\t}\n\n\t/*\n\t * We didn't have the inode before the open, so check open permission\n\t * here.\n\t */\n\tacc_mode = op->acc_mode;\n\tif (*opened & FILE_CREATED) {\n\t\tWARN_ON(!(open_flag & O_CREAT));\n\t\tfsnotify_create(dir, dentry);\n\t\tacc_mode = MAY_OPEN;\n\t}\n\terror = may_open(&file->f_path, acc_mode, open_flag);\n\tif (error)\n\t\tfput(file);\n\nout:\n\tdput(dentry);\n\treturn error;\n\nno_open:\n\tif (need_lookup) {\n\t\tdentry = lookup_real(dir, dentry, nd->flags);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn PTR_ERR(dentry);\n\n\t\tif (create_error) {\n\t\t\tint open_flag = op->open_flag;\n\n\t\t\terror = create_error;\n\t\t\tif ((open_flag & O_EXCL)) {\n\t\t\t\tif (!dentry->d_inode)\n\t\t\t\t\tgoto out;\n\t\t\t} else if (!dentry->d_inode) {\n\t\t\t\tgoto out;\n\t\t\t} else if ((open_flag & O_TRUNC) &&\n\t\t\t\t   S_ISREG(dentry->d_inode->i_mode)) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* will fail later, go on to get the right error */\n\t\t}\n\t}\nlooked_up:\n\tpath->dentry = dentry;\n\tpath->mnt = nd->path.mnt;\n\treturn 1;\n}\n\n/*\n * Look up and maybe create and open the last component.\n *\n * Must be called with i_mutex held on parent.\n *\n * Returns 0 if the file was successfully atomically created (if necessary) and\n * opened.  In this case the file will be returned attached to @file.\n *\n * Returns 1 if the file was not completely opened at this time, though lookups\n * and creations will have been performed and the dentry returned in @path will\n * be positive upon return if O_CREAT was specified.  If O_CREAT wasn't\n * specified then a negative dentry may be returned.\n *\n * An error code is returned otherwise.\n *\n * FILE_CREATE will be set in @*opened if the dentry was created and will be\n * cleared otherwise prior to returning.\n */\nstatic int lookup_open(struct nameidata *nd, struct path *path,\n\t\t\tstruct file *file,\n\t\t\tconst struct open_flags *op,\n\t\t\tbool got_write, int *opened)\n{\n\tstruct dentry *dir = nd->path.dentry;\n\tstruct inode *dir_inode = dir->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\tbool need_lookup;\n\n\t*opened &= ~FILE_CREATED;\n\tdentry = lookup_dcache(&nd->last, dir, nd->flags, &need_lookup);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\t/* Cached positive dentry: will open in f_op->open */\n\tif (!need_lookup && dentry->d_inode)\n\t\tgoto out_no_open;\n\n\tif ((nd->flags & LOOKUP_OPEN) && dir_inode->i_op->atomic_open) {\n\t\treturn atomic_open(nd, dentry, path, file, op, got_write,\n\t\t\t\t   need_lookup, opened);\n\t}\n\n\tif (need_lookup) {\n\t\tBUG_ON(dentry->d_inode);\n\n\t\tdentry = lookup_real(dir_inode, dentry, nd->flags);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn PTR_ERR(dentry);\n\t}\n\n\t/* Negative dentry, just create the file */\n\tif (!dentry->d_inode && (op->open_flag & O_CREAT)) {\n\t\tumode_t mode = op->mode;\n\t\tif (!IS_POSIXACL(dir->d_inode))\n\t\t\tmode &= ~current_umask();\n\t\t/*\n\t\t * This write is needed to ensure that a\n\t\t * rw->ro transition does not occur between\n\t\t * the time when the file is created and when\n\t\t * a permanent write count is taken through\n\t\t * the 'struct file' in finish_open().\n\t\t */\n\t\tif (!got_write) {\n\t\t\terror = -EROFS;\n\t\t\tgoto out_dput;\n\t\t}\n\t\t*opened |= FILE_CREATED;\n\t\terror = security_path_mknod(&nd->path, dentry, mode, 0);\n\t\tif (error)\n\t\t\tgoto out_dput;\n\t\terror = vfs_create(dir->d_inode, dentry, mode,\n\t\t\t\t   nd->flags & LOOKUP_EXCL);\n\t\tif (error)\n\t\t\tgoto out_dput;\n\t}\nout_no_open:\n\tpath->dentry = dentry;\n\tpath->mnt = nd->path.mnt;\n\treturn 1;\n\nout_dput:\n\tdput(dentry);\n\treturn error;\n}\n\n/*\n * Handle the last step of open()\n */\nstatic int do_last(struct nameidata *nd, struct path *path,\n\t\t   struct file *file, const struct open_flags *op,\n\t\t   int *opened, struct filename *name)\n{\n\tstruct dentry *dir = nd->path.dentry;\n\tint open_flag = op->open_flag;\n\tbool will_truncate = (open_flag & O_TRUNC) != 0;\n\tbool got_write = false;\n\tint acc_mode = op->acc_mode;\n\tstruct inode *inode;\n\tbool symlink_ok = false;\n\tstruct path save_parent = { .dentry = NULL, .mnt = NULL };\n\tbool retried = false;\n\tint error;\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\tnd->flags |= op->intent;\n\n\tif (nd->last_type != LAST_NORM) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgoto finish_open;\n\t}\n\n\tif (!(open_flag & O_CREAT)) {\n\t\tif (nd->last.name[nd->last.len])\n\t\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\t\tif (open_flag & O_PATH && !(nd->flags & LOOKUP_FOLLOW))\n\t\t\tsymlink_ok = true;\n\t\t/* we _can_ be in RCU mode here */\n\t\terror = lookup_fast(nd, path, &inode);\n\t\tif (likely(!error))\n\t\t\tgoto finish_lookup;\n\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\tBUG_ON(nd->inode != dir->d_inode);\n\t} else {\n\t\t/* create side of things */\n\t\t/*\n\t\t * This will *only* deal with leaving RCU mode - LOOKUP_JUMPED\n\t\t * has been cleared when we got to the last component we are\n\t\t * about to look up\n\t\t */\n\t\terror = complete_walk(nd);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\taudit_inode(name, dir, LOOKUP_PARENT);\n\t\terror = -EISDIR;\n\t\t/* trailing slashes? */\n\t\tif (nd->last.name[nd->last.len])\n\t\t\tgoto out;\n\t}\n\nretry_lookup:\n\tif (op->open_flag & (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) {\n\t\terror = mnt_want_write(nd->path.mnt);\n\t\tif (!error)\n\t\t\tgot_write = true;\n\t\t/*\n\t\t * do _not_ fail yet - we might not need that or fail with\n\t\t * a different error; let lookup_open() decide; we'll be\n\t\t * dropping this one anyway.\n\t\t */\n\t}\n\tmutex_lock(&dir->d_inode->i_mutex);\n\terror = lookup_open(nd, path, file, op, got_write, opened);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tif (error <= 0) {\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif ((*opened & FILE_CREATED) ||\n\t\t    !S_ISREG(file_inode(file)->i_mode))\n\t\t\twill_truncate = false;\n\n\t\taudit_inode(name, file->f_path.dentry, 0);\n\t\tgoto opened;\n\t}\n\n\tif (*opened & FILE_CREATED) {\n\t\t/* Don't check for write permission, don't truncate */\n\t\topen_flag &= ~O_TRUNC;\n\t\twill_truncate = false;\n\t\tacc_mode = MAY_OPEN;\n\t\tpath_to_nameidata(path, nd);\n\t\tgoto finish_open_created;\n\t}\n\n\t/*\n\t * create/update audit record if it already exists.\n\t */\n\tif (d_is_positive(path->dentry))\n\t\taudit_inode(name, path->dentry, 0);\n\n\t/*\n\t * If atomic_open() acquired write access it is dropped now due to\n\t * possible mount and symlink following (this might be optimized away if\n\t * necessary...)\n\t */\n\tif (got_write) {\n\t\tmnt_drop_write(nd->path.mnt);\n\t\tgot_write = false;\n\t}\n\n\terror = -EEXIST;\n\tif ((open_flag & (O_EXCL | O_CREAT)) == (O_EXCL | O_CREAT))\n\t\tgoto exit_dput;\n\n\terror = follow_managed(path, nd->flags);\n\tif (error < 0)\n\t\tgoto exit_dput;\n\n\tif (error)\n\t\tnd->flags |= LOOKUP_JUMPED;\n\n\tBUG_ON(nd->flags & LOOKUP_RCU);\n\tinode = path->dentry->d_inode;\nfinish_lookup:\n\t/* we _can_ be in RCU mode here */\n\terror = -ENOENT;\n\tif (!inode || d_is_negative(path->dentry)) {\n\t\tpath_to_nameidata(path, nd);\n\t\tgoto out;\n\t}\n\n\tif (should_follow_link(path->dentry, !symlink_ok)) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tif (unlikely(unlazy_walk(nd, path->dentry))) {\n\t\t\t\terror = -ECHILD;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(inode != path->dentry->d_inode);\n\t\treturn 1;\n\t}\n\n\tif ((nd->flags & LOOKUP_RCU) || nd->path.mnt != path->mnt) {\n\t\tpath_to_nameidata(path, nd);\n\t} else {\n\t\tsave_parent.dentry = nd->path.dentry;\n\t\tsave_parent.mnt = mntget(path->mnt);\n\t\tnd->path.dentry = path->dentry;\n\n\t}\n\tnd->inode = inode;\n\t/* Why this, you ask?  _Now_ we might have grown LOOKUP_JUMPED... */\nfinish_open:\n\terror = complete_walk(nd);\n\tif (error) {\n\t\tpath_put(&save_parent);\n\t\treturn error;\n\t}\n\taudit_inode(name, nd->path.dentry, 0);\n\terror = -EISDIR;\n\tif ((open_flag & O_CREAT) && d_is_dir(nd->path.dentry))\n\t\tgoto out;\n\terror = -ENOTDIR;\n\tif ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n\t\tgoto out;\n\tif (!S_ISREG(nd->inode->i_mode))\n\t\twill_truncate = false;\n\n\tif (will_truncate) {\n\t\terror = mnt_want_write(nd->path.mnt);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgot_write = true;\n\t}\nfinish_open_created:\n\terror = may_open(&nd->path, acc_mode, open_flag);\n\tif (error)\n\t\tgoto out;\n\tfile->f_path.mnt = nd->path.mnt;\n\terror = finish_open(file, nd->path.dentry, NULL, opened);\n\tif (error) {\n\t\tif (error == -EOPENSTALE)\n\t\t\tgoto stale_open;\n\t\tgoto out;\n\t}\nopened:\n\terror = open_check_o_direct(file);\n\tif (error)\n\t\tgoto exit_fput;\n\terror = ima_file_check(file, op->acc_mode);\n\tif (error)\n\t\tgoto exit_fput;\n\n\tif (will_truncate) {\n\t\terror = handle_truncate(file);\n\t\tif (error)\n\t\t\tgoto exit_fput;\n\t}\nout:\n\tif (got_write)\n\t\tmnt_drop_write(nd->path.mnt);\n\tpath_put(&save_parent);\n\tterminate_walk(nd);\n\treturn error;\n\nexit_dput:\n\tpath_put_conditional(path, nd);\n\tgoto out;\nexit_fput:\n\tfput(file);\n\tgoto out;\n\nstale_open:\n\t/* If no saved parent or already retried then can't retry */\n\tif (!save_parent.dentry || retried)\n\t\tgoto out;\n\n\tBUG_ON(save_parent.dentry != dir);\n\tpath_put(&nd->path);\n\tnd->path = save_parent;\n\tnd->inode = dir->d_inode;\n\tsave_parent.mnt = NULL;\n\tsave_parent.dentry = NULL;\n\tif (got_write) {\n\t\tmnt_drop_write(nd->path.mnt);\n\t\tgot_write = false;\n\t}\n\tretried = true;\n\tgoto retry_lookup;\n}\n\nstatic int do_tmpfile(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, int flags,\n\t\tconst struct open_flags *op,\n\t\tstruct file *file, int *opened)\n{\n\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\tstruct dentry *dentry, *child;\n\tstruct inode *dir;\n\tint error = path_lookupat(dfd, pathname->name,\n\t\t\t\t  flags | LOOKUP_DIRECTORY, nd);\n\tif (unlikely(error))\n\t\treturn error;\n\terror = mnt_want_write(nd->path.mnt);\n\tif (unlikely(error))\n\t\tgoto out;\n\t/* we want directory to be writable */\n\terror = inode_permission(nd->inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\tgoto out2;\n\tdentry = nd->path.dentry;\n\tdir = dentry->d_inode;\n\tif (!dir->i_op->tmpfile) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out2;\n\t}\n\tchild = d_alloc(dentry, &name);\n\tif (unlikely(!child)) {\n\t\terror = -ENOMEM;\n\t\tgoto out2;\n\t}\n\tnd->flags &= ~LOOKUP_DIRECTORY;\n\tnd->flags |= op->intent;\n\tdput(nd->path.dentry);\n\tnd->path.dentry = child;\n\terror = dir->i_op->tmpfile(dir, nd->path.dentry, op->mode);\n\tif (error)\n\t\tgoto out2;\n\taudit_inode(pathname, nd->path.dentry, 0);\n\terror = may_open(&nd->path, op->acc_mode, op->open_flag);\n\tif (error)\n\t\tgoto out2;\n\tfile->f_path.mnt = nd->path.mnt;\n\terror = finish_open(file, nd->path.dentry, NULL, opened);\n\tif (error)\n\t\tgoto out2;\n\terror = open_check_o_direct(file);\n\tif (error) {\n\t\tfput(file);\n\t} else if (!(op->open_flag & O_EXCL)) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state |= I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\nout2:\n\tmnt_drop_write(nd->path.mnt);\nout:\n\tpath_put(&nd->path);\n\treturn error;\n}\n\nstatic struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *base = NULL;\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_flags = op->open_flag;\n\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n\t}\n\n\terror = path_init(dfd, pathname->name, flags | LOOKUP_PARENT, nd, &base);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tcurrent->total_link_count = 0;\n\terror = link_path_walk(pathname->name, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { /* trailing symlink */\n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n\t}\nout:\n\tif (nd->root.mnt && !(nd->flags & LOOKUP_ROOT))\n\t\tpath_put(&nd->root);\n\tif (base)\n\t\tfput(base);\n\tif (!(opened & FILE_OPENED)) {\n\t\tBUG_ON(!error);\n\t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}\n\nstruct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_REVAL);\n\treturn filp;\n}\n\nstruct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename filename = { .name = name };\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\n\tif (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\n\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_REVAL);\n\treturn file;\n}\n\nstruct dentry *kern_path_create(int dfd, const char *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\tstruct dentry *dentry = ERR_PTR(-EEXIST);\n\tstruct nameidata nd;\n\tint err2;\n\tint error;\n\tbool is_dir = (lookup_flags & LOOKUP_DIRECTORY);\n\n\t/*\n\t * Note that only LOOKUP_REVAL and LOOKUP_DIRECTORY matter here. Any\n\t * other flags passed in are ignored!\n\t */\n\tlookup_flags &= LOOKUP_REVAL;\n\n\terror = do_path_lookup(dfd, pathname, LOOKUP_PARENT|lookup_flags, &nd);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/*\n\t * Yucky last component or no last component at all?\n\t * (foo/., foo/.., /////)\n\t */\n\tif (nd.last_type != LAST_NORM)\n\t\tgoto out;\n\tnd.flags &= ~LOOKUP_PARENT;\n\tnd.flags |= LOOKUP_CREATE | LOOKUP_EXCL;\n\n\t/* don't fail immediately if it's r/o, at least try to report other errors */\n\terr2 = mnt_want_write(nd.path.mnt);\n\t/*\n\t * Do the final lookup.\n\t */\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_hash(&nd);\n\tif (IS_ERR(dentry))\n\t\tgoto unlock;\n\n\terror = -EEXIST;\n\tif (d_is_positive(dentry))\n\t\tgoto fail;\n\n\t/*\n\t * Special case - lookup gave negative, but... we had foo/bar/\n\t * From the vfs_mknod() POV we just have a negative dentry -\n\t * all is fine. Let's be bastards - you had / on the end, you've\n\t * been asking for (non-existent) directory. -ENOENT for you.\n\t */\n\tif (unlikely(!is_dir && nd.last.name[nd.last.len])) {\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\tif (unlikely(err2)) {\n\t\terror = err2;\n\t\tgoto fail;\n\t}\n\t*path = nd.path;\n\treturn dentry;\nfail:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nunlock:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tif (!err2)\n\t\tmnt_drop_write(nd.path.mnt);\nout:\n\tpath_put(&nd.path);\n\treturn dentry;\n}\nEXPORT_SYMBOL(kern_path_create);\n\nvoid done_path_create(struct path *path, struct dentry *dentry)\n{\n\tdput(dentry);\n\tmutex_unlock(&path->dentry->d_inode->i_mutex);\n\tmnt_drop_write(path->mnt);\n\tpath_put(path);\n}\nEXPORT_SYMBOL(done_path_create);\n\nstruct dentry *user_path_create(int dfd, const char __user *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\tstruct filename *tmp = getname(pathname);\n\tstruct dentry *res;\n\tif (IS_ERR(tmp))\n\t\treturn ERR_CAST(tmp);\n\tres = kern_path_create(dfd, tmp->name, path, lookup_flags);\n\tputname(tmp);\n\treturn res;\n}\nEXPORT_SYMBOL(user_path_create);\n\nint vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mknod);\n\nstatic int may_mknod(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\tcase 0: /* zero mode translates to S_IFREG */\n\t\treturn 0;\n\tcase S_IFDIR:\n\t\treturn -EPERM;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nSYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,\n\t\tunsigned, dev)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = 0;\n\n\terror = may_mknod(mode);\n\tif (error)\n\t\treturn error;\nretry:\n\tdentry = user_path_create(dfd, filename, &path, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!IS_POSIXACL(path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mknod(&path, dentry, mode, dev);\n\tif (error)\n\t\tgoto out;\n\tswitch (mode & S_IFMT) {\n\t\tcase 0: case S_IFREG:\n\t\t\terror = vfs_create(path.dentry->d_inode,dentry,mode,true);\n\t\t\tbreak;\n\t\tcase S_IFCHR: case S_IFBLK:\n\t\t\terror = vfs_mknod(path.dentry->d_inode,dentry,mode,\n\t\t\t\t\tnew_decode_dev(dev));\n\t\t\tbreak;\n\t\tcase S_IFIFO: case S_IFSOCK:\n\t\t\terror = vfs_mknod(path.dentry->d_inode,dentry,mode,0);\n\t\t\tbreak;\n\t}\nout:\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)\n{\n\treturn sys_mknodat(AT_FDCWD, filename, mode, dev);\n}\n\nint vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mkdir);\n\nSYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_DIRECTORY;\n\nretry:\n\tdentry = user_path_create(dfd, pathname, &path, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!IS_POSIXACL(path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mkdir(&path, dentry, mode);\n\tif (!error)\n\t\terror = vfs_mkdir(path.dentry->d_inode, dentry, mode);\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)\n{\n\treturn sys_mkdirat(AT_FDCWD, pathname, mode);\n}\n\n/*\n * The dentry_unhash() helper will try to drop the dentry early: we\n * should have a usage count of 1 if we're the only user of this\n * dentry, and if that is true (possibly after pruning the dcache),\n * then we drop the dentry now.\n *\n * A low-level filesystem can, if it choses, legally\n * do a\n *\n *\tif (!d_unhashed(dentry))\n *\t\treturn -EBUSY;\n *\n * if it cannot handle the case of removing a directory\n * that is still in use by something else..\n */\nvoid dentry_unhash(struct dentry *dentry)\n{\n\tshrink_dcache_parent(dentry);\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_lockref.count == 1)\n\t\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}\nEXPORT_SYMBOL(dentry_unhash);\n\nint vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (d_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_rmdir);\n\nstatic long do_rmdir(int dfd, const char __user *pathname)\n{\n\tint error = 0;\n\tstruct filename *name;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\tunsigned int lookup_flags = 0;\nretry:\n\tname = user_path_parent(dfd, pathname, &nd, lookup_flags);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\tswitch(nd.last_type) {\n\tcase LAST_DOTDOT:\n\t\terror = -ENOTEMPTY;\n\t\tgoto exit1;\n\tcase LAST_DOT:\n\t\terror = -EINVAL;\n\t\tgoto exit1;\n\tcase LAST_ROOT:\n\t\terror = -EBUSY;\n\t\tgoto exit1;\n\t}\n\n\tnd.flags &= ~LOOKUP_PARENT;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto exit1;\n\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_hash(&nd);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto exit2;\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto exit3;\n\t}\n\terror = security_path_rmdir(&nd.path, dentry);\n\tif (error)\n\t\tgoto exit3;\n\terror = vfs_rmdir(nd.path.dentry->d_inode, dentry);\nexit3:\n\tdput(dentry);\nexit2:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tmnt_drop_write(nd.path.mnt);\nexit1:\n\tpath_put(&nd.path);\n\tputname(name);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE1(rmdir, const char __user *, pathname)\n{\n\treturn do_rmdir(AT_FDCWD, pathname);\n}\n\n/**\n * vfs_unlink - unlink a filesystem object\n * @dir:\tparent directory\n * @dentry:\tvictim\n * @delegated_inode: returns victim inode, if the inode is delegated.\n *\n * The caller must hold dir->i_mutex.\n *\n * If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and\n * return a reference to the inode in delegated_inode.  The caller\n * should then break the delegation on that inode and retry.  Because\n * breaking a delegation may take a long time, the caller should drop\n * dir->i_mutex before doing so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n */\nint vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (d_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error)\n\t\t\t\tdont_mount(dentry);\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_unlink);\n\n/*\n * Make sure that the actual truncation of the file will occur outside its\n * directory's i_mutex.  Truncate can take a long time if there is a lot of\n * writeout happening, and we don't want to prevent access to the directory\n * while waiting on the I/O.\n */\nstatic long do_unlinkat(int dfd, const char __user *pathname)\n{\n\tint error;\n\tstruct filename *name;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\tstruct inode *inode = NULL;\n\tstruct inode *delegated_inode = NULL;\n\tunsigned int lookup_flags = 0;\nretry:\n\tname = user_path_parent(dfd, pathname, &nd, lookup_flags);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\terror = -EISDIR;\n\tif (nd.last_type != LAST_NORM)\n\t\tgoto exit1;\n\n\tnd.flags &= ~LOOKUP_PARENT;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto exit1;\nretry_deleg:\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_hash(&nd);\n\terror = PTR_ERR(dentry);\n\tif (!IS_ERR(dentry)) {\n\t\t/* Why not before? Because we want correct error value */\n\t\tif (nd.last.name[nd.last.len])\n\t\t\tgoto slashes;\n\t\tinode = dentry->d_inode;\n\t\tif (d_is_negative(dentry))\n\t\t\tgoto slashes;\n\t\tihold(inode);\n\t\terror = security_path_unlink(&nd.path, dentry);\n\t\tif (error)\n\t\t\tgoto exit2;\n\t\terror = vfs_unlink(nd.path.dentry->d_inode, dentry, &delegated_inode);\nexit2:\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tif (inode)\n\t\tiput(inode);\t/* truncate the inode here */\n\tinode = NULL;\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(nd.path.mnt);\nexit1:\n\tpath_put(&nd.path);\n\tputname(name);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tinode = NULL;\n\t\tgoto retry;\n\t}\n\treturn error;\n\nslashes:\n\tif (d_is_negative(dentry))\n\t\terror = -ENOENT;\n\telse if (d_is_dir(dentry))\n\t\terror = -EISDIR;\n\telse\n\t\terror = -ENOTDIR;\n\tgoto exit2;\n}\n\nSYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)\n{\n\tif ((flag & ~AT_REMOVEDIR) != 0)\n\t\treturn -EINVAL;\n\n\tif (flag & AT_REMOVEDIR)\n\t\treturn do_rmdir(dfd, pathname);\n\n\treturn do_unlinkat(dfd, pathname);\n}\n\nSYSCALL_DEFINE1(unlink, const char __user *, pathname)\n{\n\treturn do_unlinkat(AT_FDCWD, pathname);\n}\n\nint vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->symlink)\n\t\treturn -EPERM;\n\n\terror = security_inode_symlink(dir, dentry, oldname);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->symlink(dir, dentry, oldname);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_symlink);\n\nSYSCALL_DEFINE3(symlinkat, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\tint error;\n\tstruct filename *from;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tunsigned int lookup_flags = 0;\n\n\tfrom = getname(oldname);\n\tif (IS_ERR(from))\n\t\treturn PTR_ERR(from);\nretry:\n\tdentry = user_path_create(newdfd, newname, &path, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_putname;\n\n\terror = security_path_symlink(&path, dentry, from->name);\n\tif (!error)\n\t\terror = vfs_symlink(path.dentry->d_inode, dentry, from->name);\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout_putname:\n\tputname(from);\n\treturn error;\n}\n\nSYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_symlinkat(oldname, AT_FDCWD, newname);\n}\n\n/**\n * vfs_link - create a new link\n * @old_dentry:\tobject to be linked\n * @dir:\tnew parent\n * @new_dentry:\twhere to create the new link\n * @delegated_inode: returns inode needing a delegation break\n *\n * The caller must hold dir->i_mutex\n *\n * If vfs_link discovers a delegation on the to-be-linked file in need\n * of breaking, it will return -EWOULDBLOCK and return a reference to the\n * inode in delegated_inode.  The caller should then break the delegation\n * and retry.  Because breaking a delegation may take a long time, the\n * caller should drop the i_mutex before doing so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n */\nint vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tunsigned max_links = dir->i_sb->s_max_links;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A link to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\tif (!dir->i_op->link)\n\t\treturn -EPERM;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = security_inode_link(old_dentry, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\t/* Make sure we don't allow creating hardlink to an unlinked file */\n\tif (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))\n\t\terror =  -ENOENT;\n\telse if (max_links && inode->i_nlink >= max_links)\n\t\terror = -EMLINK;\n\telse {\n\t\terror = try_break_deleg(inode, delegated_inode);\n\t\tif (!error)\n\t\t\terror = dir->i_op->link(old_dentry, dir, new_dentry);\n\t}\n\n\tif (!error && (inode->i_state & I_LINKABLE)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (!error)\n\t\tfsnotify_link(dir, inode, new_dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_link);\n\n/*\n * Hardlinks are often used in delicate situations.  We avoid\n * security-related surprises by not following symlinks on the\n * newname.  --KAB\n *\n * We don't follow them on the oldname either to be compatible\n * with linux 2.0, and to avoid hard-linking to directories\n * and other special files.  --ADM\n */\nSYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, int, flags)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tstruct inode *delegated_inode = NULL;\n\tint how = 0;\n\tint error;\n\n\tif ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn -EINVAL;\n\t/*\n\t * To use null names we require CAP_DAC_READ_SEARCH\n\t * This ensures that not everyone will be able to create\n\t * handlink using the passed filedescriptor.\n\t */\n\tif (flags & AT_EMPTY_PATH) {\n\t\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\t\treturn -ENOENT;\n\t\thow = LOOKUP_EMPTY;\n\t}\n\n\tif (flags & AT_SYMLINK_FOLLOW)\n\t\thow |= LOOKUP_FOLLOW;\nretry:\n\terror = user_path_at(olddfd, oldname, how, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tnew_dentry = user_path_create(newdfd, newname, &new_path,\n\t\t\t\t\t(how & LOOKUP_REVAL));\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out;\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto out_dput;\n\terror = may_linkat(&old_path);\n\tif (unlikely(error))\n\t\tgoto out_dput;\n\terror = security_path_link(old_path.dentry, &new_path, new_dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error) {\n\t\t\tpath_put(&old_path);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (retry_estale(error, how)) {\n\t\tpath_put(&old_path);\n\t\thow |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}\n\n/**\n * vfs_rename - rename a filesystem object\n * @old_dir:\tparent of source\n * @old_dentry:\tsource\n * @new_dir:\tparent of destination\n * @new_dentry:\tdestination\n * @delegated_inode: returns an inode needing a delegation break\n * @flags:\trename flags\n *\n * The caller must hold multiple mutexes--see lock_rename()).\n *\n * If vfs_rename discovers a delegation in need of breaking at either\n * the source or destination, it will return -EWOULDBLOCK and return a\n * reference to the inode in delegated_inode.  The caller should then\n * break the delegation and retry.  Because breaking a delegation may\n * take a long time, the caller should drop all locks before doing\n * so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n *\n * The worst of all namespace operations - renaming directory. \"Perverted\"\n * doesn't even start to describe it. Somebody in UCB had a heck of a trip...\n * Problems:\n *\ta) we can get into loop creation. Check is done in is_subdir().\n *\tb) race potential - two innocent renames can create a loop together.\n *\t   That's where 4.4 screws up. Current fix: serialization on\n *\t   sb->s_vfs_rename_mutex. We might be more accurate, but that's another\n *\t   story.\n *\tc) we have to lock _four_ objects - parents and victim (if it exists),\n *\t   and source (if it is not a directory).\n *\t   And that - after we got ->i_mutex on parents (until then we don't know\n *\t   whether the target exists).  Solution: try to be smart with locking\n *\t   order for inodes.  We rely on the fact that tree topology may change\n *\t   only under ->s_vfs_rename_mutex _and_ that parent of the object we\n *\t   move will be locked.  Thus we can rank directories by the tree\n *\t   (ancestors first) and rank all non-directories after them.\n *\t   That works since everybody except rename does \"lock parent, lookup,\n *\t   lock child\" and rename is under ->s_vfs_rename_mutex.\n *\t   HOWEVER, it relies on the assumption that any object with ->lookup()\n *\t   has no more than 1 dentry.  If \"hybrid\" objects will ever appear,\n *\t   we'd better make sure that there's no link(2) for them.\n *\td) conversion from fhandle to dentry may come in the wrong moment - when\n *\t   we are removing the target. Solution: we will have to grab ->i_mutex\n *\t   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on\n *\t   ->i_mutex on parents, which works but leads to some truly excessive\n *\t   locking].\n */\nint vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_lock(&target->i_mutex);\n\n\terror = -EBUSY;\n\tif (d_mountpoint(old_dentry) || d_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!flags) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_unlock(&target->i_mutex);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_rename);\n\nSYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, unsigned int, flags)\n{\n\tstruct dentry *old_dir, *new_dir;\n\tstruct dentry *old_dentry, *new_dentry;\n\tstruct dentry *trap;\n\tstruct nameidata oldnd, newnd;\n\tstruct inode *delegated_inode = NULL;\n\tstruct filename *from;\n\tstruct filename *to;\n\tunsigned int lookup_flags = 0;\n\tbool should_retry = false;\n\tint error;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tif ((flags & RENAME_NOREPLACE) && (flags & RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\nretry:\n\tfrom = user_path_parent(olddfd, oldname, &oldnd, lookup_flags);\n\tif (IS_ERR(from)) {\n\t\terror = PTR_ERR(from);\n\t\tgoto exit;\n\t}\n\n\tto = user_path_parent(newdfd, newname, &newnd, lookup_flags);\n\tif (IS_ERR(to)) {\n\t\terror = PTR_ERR(to);\n\t\tgoto exit1;\n\t}\n\n\terror = -EXDEV;\n\tif (oldnd.path.mnt != newnd.path.mnt)\n\t\tgoto exit2;\n\n\told_dir = oldnd.path.dentry;\n\terror = -EBUSY;\n\tif (oldnd.last_type != LAST_NORM)\n\t\tgoto exit2;\n\n\tnew_dir = newnd.path.dentry;\n\tif (flags & RENAME_NOREPLACE)\n\t\terror = -EEXIST;\n\tif (newnd.last_type != LAST_NORM)\n\t\tgoto exit2;\n\n\terror = mnt_want_write(oldnd.path.mnt);\n\tif (error)\n\t\tgoto exit2;\n\n\toldnd.flags &= ~LOOKUP_PARENT;\n\tnewnd.flags &= ~LOOKUP_PARENT;\n\tif (!(flags & RENAME_EXCHANGE))\n\t\tnewnd.flags |= LOOKUP_RENAME_TARGET;\n\nretry_deleg:\n\ttrap = lock_rename(new_dir, old_dir);\n\n\told_dentry = lookup_hash(&oldnd);\n\terror = PTR_ERR(old_dentry);\n\tif (IS_ERR(old_dentry))\n\t\tgoto exit3;\n\t/* source must exist */\n\terror = -ENOENT;\n\tif (d_is_negative(old_dentry))\n\t\tgoto exit4;\n\tnew_dentry = lookup_hash(&newnd);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto exit4;\n\terror = -EEXIST;\n\tif ((flags & RENAME_NOREPLACE) && d_is_positive(new_dentry))\n\t\tgoto exit5;\n\tif (flags & RENAME_EXCHANGE) {\n\t\terror = -ENOENT;\n\t\tif (d_is_negative(new_dentry))\n\t\t\tgoto exit5;\n\n\t\tif (!d_is_dir(new_dentry)) {\n\t\t\terror = -ENOTDIR;\n\t\t\tif (newnd.last.name[newnd.last.len])\n\t\t\t\tgoto exit5;\n\t\t}\n\t}\n\t/* unless the source is a directory trailing slashes give -ENOTDIR */\n\tif (!d_is_dir(old_dentry)) {\n\t\terror = -ENOTDIR;\n\t\tif (oldnd.last.name[oldnd.last.len])\n\t\t\tgoto exit5;\n\t\tif (!(flags & RENAME_EXCHANGE) && newnd.last.name[newnd.last.len])\n\t\t\tgoto exit5;\n\t}\n\t/* source should not be ancestor of target */\n\terror = -EINVAL;\n\tif (old_dentry == trap)\n\t\tgoto exit5;\n\t/* target should not be an ancestor of source */\n\tif (!(flags & RENAME_EXCHANGE))\n\t\terror = -ENOTEMPTY;\n\tif (new_dentry == trap)\n\t\tgoto exit5;\n\n\terror = security_path_rename(&oldnd.path, old_dentry,\n\t\t\t\t     &newnd.path, new_dentry, flags);\n\tif (error)\n\t\tgoto exit5;\n\terror = vfs_rename(old_dir->d_inode, old_dentry,\n\t\t\t   new_dir->d_inode, new_dentry,\n\t\t\t   &delegated_inode, flags);\nexit5:\n\tdput(new_dentry);\nexit4:\n\tdput(old_dentry);\nexit3:\n\tunlock_rename(new_dir, old_dir);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(oldnd.path.mnt);\nexit2:\n\tif (retry_estale(error, lookup_flags))\n\t\tshould_retry = true;\n\tpath_put(&newnd.path);\n\tputname(to);\nexit1:\n\tpath_put(&oldnd.path);\n\tputname(from);\n\tif (should_retry) {\n\t\tshould_retry = false;\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nexit:\n\treturn error;\n}\n\nSYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\treturn sys_renameat2(olddfd, oldname, newdfd, newname, 0);\n}\n\nSYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}\n\nint readlink_copy(char __user *buffer, int buflen, const char *link)\n{\n\tint len = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}\nEXPORT_SYMBOL(readlink_copy);\n\n/*\n * A helper for ->readlink().  This should be used *ONLY* for symlinks that\n * have ->follow_link() touching nd only in nd_set_link().  Using (or not\n * using) it for any given inode is up to filesystem.\n */\nint generic_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct nameidata nd;\n\tvoid *cookie;\n\tint res;\n\n\tnd.depth = 0;\n\tcookie = dentry->d_inode->i_op->follow_link(dentry, &nd);\n\tif (IS_ERR(cookie))\n\t\treturn PTR_ERR(cookie);\n\n\tres = readlink_copy(buffer, buflen, nd_get_link(&nd));\n\tif (dentry->d_inode->i_op->put_link)\n\t\tdentry->d_inode->i_op->put_link(dentry, &nd, cookie);\n\treturn res;\n}\nEXPORT_SYMBOL(generic_readlink);\n\n/* get the link contents into pagecache */\nstatic char *page_getlink(struct dentry * dentry, struct page **ppage)\n{\n\tchar *kaddr;\n\tstruct page *page;\n\tstruct address_space *mapping = dentry->d_inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\treturn (char*)page;\n\t*ppage = page;\n\tkaddr = kmap(page);\n\tnd_terminate_link(kaddr, dentry->d_inode->i_size, PAGE_SIZE - 1);\n\treturn kaddr;\n}\n\nint page_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct page *page = NULL;\n\tint res = readlink_copy(buffer, buflen, page_getlink(dentry, &page));\n\tif (page) {\n\t\tkunmap(page);\n\t\tpage_cache_release(page);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(page_readlink);\n\nvoid *page_follow_link_light(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct page *page = NULL;\n\tnd_set_link(nd, page_getlink(dentry, &page));\n\treturn page;\n}\nEXPORT_SYMBOL(page_follow_link_light);\n\nvoid page_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)\n{\n\tstruct page *page = cookie;\n\n\tif (page) {\n\t\tkunmap(page);\n\t\tpage_cache_release(page);\n\t}\n}\nEXPORT_SYMBOL(page_put_link);\n\n/*\n * The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS\n */\nint __page_symlink(struct inode *inode, const char *symname, int len, int nofs)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\tchar *kaddr;\n\tunsigned int flags = AOP_FLAG_UNINTERRUPTIBLE;\n\tif (nofs)\n\t\tflags |= AOP_FLAG_NOFS;\n\nretry:\n\terr = pagecache_write_begin(NULL, mapping, 0, len-1,\n\t\t\t\tflags, &page, &fsdata);\n\tif (err)\n\t\tgoto fail;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr, symname, len-1);\n\tkunmap_atomic(kaddr);\n\n\terr = pagecache_write_end(NULL, mapping, 0, len-1, len-1,\n\t\t\t\t\t\t\tpage, fsdata);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err < len-1)\n\t\tgoto retry;\n\n\tmark_inode_dirty(inode);\n\treturn 0;\nfail:\n\treturn err;\n}\nEXPORT_SYMBOL(__page_symlink);\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}\nEXPORT_SYMBOL(page_symlink);\n\nconst struct inode_operations page_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n};\nEXPORT_SYMBOL(page_symlink_inode_operations);\n"], "fixing_code": ["/*\n *  linux/fs/namei.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n * Some corrections by tytso.\n */\n\n/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname\n * lookup logic.\n */\n/* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.\n */\n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/personality.h>\n#include <linux/security.h>\n#include <linux/ima.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/device_cgroup.h>\n#include <linux/fs_struct.h>\n#include <linux/posix_acl.h>\n#include <asm/uaccess.h>\n\n#include \"internal.h\"\n#include \"mount.h\"\n\n/* [Feb-1997 T. Schoebel-Theuer]\n * Fundamental changes in the pathname lookup mechanisms (namei)\n * were necessary because of omirr.  The reason is that omirr needs\n * to know the _real_ pathname, not the user-supplied one, in case\n * of symlinks (and also when transname replacements occur).\n *\n * The new code replaces the old recursive symlink resolution with\n * an iterative one (in case of non-nested symlink chains).  It does\n * this with calls to <fs>_follow_link().\n * As a side effect, dir_namei(), _namei() and follow_link() are now \n * replaced with a single function lookup_dentry() that can handle all \n * the special cases of the former code.\n *\n * With the new dcache, the pathname is stored at each inode, at least as\n * long as the refcount of the inode is positive.  As a side effect, the\n * size of the dcache depends on the inode cache and thus is dynamic.\n *\n * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink\n * resolution to correspond with current state of the code.\n *\n * Note that the symlink resolution is not *completely* iterative.\n * There is still a significant amount of tail- and mid- recursion in\n * the algorithm.  Also, note that <fs>_readlink() is not used in\n * lookup_dentry(): lookup_dentry() on the result of <fs>_readlink()\n * may return different results than <fs>_follow_link().  Many virtual\n * filesystems (including /proc) exhibit this behavior.\n */\n\n/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:\n * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL\n * and the name already exists in form of a symlink, try to create the new\n * name indicated by the symlink. The old code always complained that the\n * name already exists, due to not following the symlink even if its target\n * is nonexistent.  The new semantics affects also mknod() and link() when\n * the name is a symlink pointing to a non-existent name.\n *\n * I don't know which semantics is the right one, since I have no access\n * to standards. But I found by trial that HP-UX 9.0 has the full \"new\"\n * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the\n * \"old\" one. Personally, I think the new semantics is much more logical.\n * Note that \"ln old new\" where \"new\" is a symlink pointing to a non-existing\n * file does succeed in both HP-UX and SunOs, but not in Solaris\n * and in the old Linux semantics.\n */\n\n/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink\n * semantics.  See the comments in \"open_namei\" and \"do_link\" below.\n *\n * [10-Sep-98 Alan Modra] Another symlink change.\n */\n\n/* [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:\n *\tinside the path - always follow.\n *\tin the last component in creation/removal/renaming - never follow.\n *\tif LOOKUP_FOLLOW passed - follow.\n *\tif the pathname has trailing slashes - follow.\n *\totherwise - don't follow.\n * (applied in that order).\n *\n * [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT\n * restored for 2.4. This is the last surviving part of old 4.2BSD bug.\n * During the 2.4 we need to fix the userland stuff depending on it -\n * hopefully we will be able to get rid of that wart in 2.5. So far only\n * XEmacs seems to be relying on it...\n */\n/*\n * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)\n * implemented.  Let's see if raised priority of ->s_vfs_rename_mutex gives\n * any extra contention...\n */\n\n/* In order to reduce some races, while at the same time doing additional\n * checking and hopefully speeding things up, we copy filenames to the\n * kernel data space before using them..\n *\n * POSIX.1 2.4: an empty pathname is invalid (ENOENT).\n * PATH_MAX includes the nul terminator --RR.\n */\nvoid final_putname(struct filename *name)\n{\n\tif (name->separate) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else {\n\t\t__putname(name);\n\t}\n}\n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - sizeof(struct filename))\n\nstatic struct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n\tstruct filename *result, *err;\n\tint len;\n\tlong max;\n\tchar *kname;\n\n\tresult = audit_reusename(filename);\n\tif (result)\n\t\treturn result;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * First, try to embed the struct filename inside the names_cache\n\t * allocation\n\t */\n\tkname = (char *)result + sizeof(*result);\n\tresult->name = kname;\n\tresult->separate = false;\n\tmax = EMBEDDED_NAME_MAX;\n\nrecopy:\n\tlen = strncpy_from_user(kname, filename, max);\n\tif (unlikely(len < 0)) {\n\t\terr = ERR_PTR(len);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a\n\t * separate struct filename so we can dedicate the entire\n\t * names_cache allocation for the pathname, and re-do the copy from\n\t * userland.\n\t */\n\tif (len == EMBEDDED_NAME_MAX && max == EMBEDDED_NAME_MAX) {\n\t\tkname = (char *)result;\n\n\t\tresult = kzalloc(sizeof(*result), GFP_KERNEL);\n\t\tif (!result) {\n\t\t\terr = ERR_PTR(-ENOMEM);\n\t\t\tresult = (struct filename *)kname;\n\t\t\tgoto error;\n\t\t}\n\t\tresult->name = kname;\n\t\tresult->separate = true;\n\t\tmax = PATH_MAX;\n\t\tgoto recopy;\n\t}\n\n\t/* The empty path is special. */\n\tif (unlikely(!len)) {\n\t\tif (empty)\n\t\t\t*empty = 1;\n\t\terr = ERR_PTR(-ENOENT);\n\t\tif (!(flags & LOOKUP_EMPTY))\n\t\t\tgoto error;\n\t}\n\n\terr = ERR_PTR(-ENAMETOOLONG);\n\tif (unlikely(len >= PATH_MAX))\n\t\tgoto error;\n\n\tresult->uptr = filename;\n\tresult->aname = NULL;\n\taudit_getname(result);\n\treturn result;\n\nerror:\n\tfinal_putname(result);\n\treturn err;\n}\n\nstruct filename *\ngetname(const char __user * filename)\n{\n\treturn getname_flags(filename, 0, NULL);\n}\n\n/*\n * The \"getname_kernel()\" interface doesn't do pathnames longer\n * than EMBEDDED_NAME_MAX. Deal with it - you're a kernel user.\n */\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tchar *kname;\n\tint len;\n\n\tlen = strlen(filename);\n\tif (len >= EMBEDDED_NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkname = (char *)result + sizeof(*result);\n\tresult->name = kname;\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->separate = false;\n\n\tstrlcpy(kname, filename, EMBEDDED_NAME_MAX);\n\treturn result;\n}\n\n#ifdef CONFIG_AUDITSYSCALL\nvoid putname(struct filename *name)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\treturn audit_putname(name);\n\tfinal_putname(name);\n}\n#endif\n\nstatic int check_acl(struct inode *inode, int mask)\n{\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl *acl;\n\n\tif (mask & MAY_NOT_BLOCK) {\n\t\tacl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);\n\t        if (!acl)\n\t                return -EAGAIN;\n\t\t/* no ->get_acl() calls in RCU mode... */\n\t\tif (acl == ACL_NOT_CACHED)\n\t\t\treturn -ECHILD;\n\t        return posix_acl_permission(inode, acl, mask & ~MAY_NOT_BLOCK);\n\t}\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl) {\n\t        int error = posix_acl_permission(inode, acl, mask);\n\t        posix_acl_release(acl);\n\t        return error;\n\t}\n#endif\n\n\treturn -EAGAIN;\n}\n\n/*\n * This does the basic permission checking\n */\nstatic int acl_permission_check(struct inode *inode, int mask)\n{\n\tunsigned int mode = inode->i_mode;\n\n\tif (likely(uid_eq(current_fsuid(), inode->i_uid)))\n\t\tmode >>= 6;\n\telse {\n\t\tif (IS_POSIXACL(inode) && (mode & S_IRWXG)) {\n\t\t\tint error = check_acl(inode, mask);\n\t\t\tif (error != -EAGAIN)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (in_group_p(inode->i_gid))\n\t\t\tmode >>= 3;\n\t}\n\n\t/*\n\t * If the DACs are ok we don't need any capability check.\n\t */\n\tif ((mask & ~mode & (MAY_READ | MAY_WRITE | MAY_EXEC)) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\n/**\n * generic_permission -  check for access rights on a Posix-like filesystem\n * @inode:\tinode to check access rights for\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC, ...)\n *\n * Used to check for read/write/execute permissions on a file.\n * We use \"fsuid\" for this, letting us set arbitrary permissions\n * for filesystem access without changing the \"normal\" uids which\n * are used for other things.\n *\n * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk\n * request cannot be satisfied (eg. requires blocking or too much complexity).\n * It would then be called again in ref-walk mode.\n */\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}\nEXPORT_SYMBOL(generic_permission);\n\n/*\n * We _really_ want to just do \"generic_permission()\" without\n * even looking at the inode->i_op values. So we keep a cache\n * flag in inode->i_opflags, that says \"this has not special\n * permission function, use the fast case\".\n */\nstatic inline int do_inode_permission(struct inode *inode, int mask)\n{\n\tif (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {\n\t\tif (likely(inode->i_op->permission))\n\t\t\treturn inode->i_op->permission(inode, mask);\n\n\t\t/* This gets set once for the inode lifetime */\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_opflags |= IOP_FASTPERM;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn generic_permission(inode, mask);\n}\n\n/**\n * __inode_permission - Check for access rights to a given inode\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Check for read/write/execute permissions on an inode.\n *\n * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.\n *\n * This does not check for a read-only file system.  You probably want\n * inode_permission().\n */\nint __inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}\n\n/**\n * sb_permission - Check superblock-level permissions\n * @sb: Superblock of inode to check permission on\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Separate out file-system wide checks from inode-specific permission checks.\n */\nstatic int sb_permission(struct super_block *sb, struct inode *inode, int mask)\n{\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\t/* Nobody gets write access to a read-only fs. */\n\t\tif ((sb->s_flags & MS_RDONLY) &&\n\t\t    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))\n\t\t\treturn -EROFS;\n\t}\n\treturn 0;\n}\n\n/**\n * inode_permission - Check for access rights to a given inode\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Check for read/write/execute permissions on an inode.  We use fs[ug]id for\n * this, letting us set arbitrary permissions for filesystem access without\n * changing the \"normal\" UIDs which are used for other things.\n *\n * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.\n */\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}\nEXPORT_SYMBOL(inode_permission);\n\n/**\n * path_get - get a reference to a path\n * @path: path to get the reference to\n *\n * Given a path increment the reference count to the dentry and the vfsmount.\n */\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}\nEXPORT_SYMBOL(path_get);\n\n/**\n * path_put - put a reference to a path\n * @path: path to put the reference to\n *\n * Given a path decrement the reference count to the dentry and the vfsmount.\n */\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}\nEXPORT_SYMBOL(path_put);\n\n/*\n * Path walking has 2 modes, rcu-walk and ref-walk (see\n * Documentation/filesystems/path-lookup.txt).  In situations when we can't\n * continue in RCU mode, we attempt to drop out of rcu-walk mode and grab\n * normal reference counts on dentries and vfsmounts to transition to rcu-walk\n * mode.  Refcounts are grabbed at the last known good point before rcu-walk\n * got stuck, so ref-walk may continue from there. If this is not successful\n * (eg. a seqcount has changed), then failure is returned and it's up to caller\n * to restart the path walk from the beginning in ref-walk mode.\n */\n\n/**\n * unlazy_walk - try to switch to ref-walk mode.\n * @nd: nameidata pathwalk data\n * @dentry: child of nd->path.dentry or NULL\n * Returns: 0 on success, -ECHILD on failure\n *\n * unlazy_walk attempts to legitimize the current nd->path, nd->root and dentry\n * for ref-walk mode.  @dentry must be a path found by a do_lookup call on\n * @nd or NULL.  Must be called from rcu-walk context.\n */\nstatic int unlazy_walk(struct nameidata *nd, struct dentry *dentry)\n{\n\tstruct fs_struct *fs = current->fs;\n\tstruct dentry *parent = nd->path.dentry;\n\n\tBUG_ON(!(nd->flags & LOOKUP_RCU));\n\n\t/*\n\t * After legitimizing the bastards, terminate_walk()\n\t * will do the right thing for non-RCU mode, and all our\n\t * subsequent exit cases should rcu_read_unlock()\n\t * before returning.  Do vfsmount first; if dentry\n\t * can't be legitimized, just set nd->path.dentry to NULL\n\t * and rely on dput(NULL) being a no-op.\n\t */\n\tif (!legitimize_mnt(nd->path.mnt, nd->m_seq))\n\t\treturn -ECHILD;\n\tnd->flags &= ~LOOKUP_RCU;\n\n\tif (!lockref_get_not_dead(&parent->d_lockref)) {\n\t\tnd->path.dentry = NULL;\t\n\t\tgoto out;\n\t}\n\n\t/*\n\t * For a negative lookup, the lookup sequence point is the parents\n\t * sequence point, and it only needs to revalidate the parent dentry.\n\t *\n\t * For a positive lookup, we need to move both the parent and the\n\t * dentry from the RCU domain to be properly refcounted. And the\n\t * sequence number in the dentry validates *both* dentry counters,\n\t * since we checked the sequence number of the parent after we got\n\t * the child sequence number. So we know the parent must still\n\t * be valid if the child sequence number is still valid.\n\t */\n\tif (!dentry) {\n\t\tif (read_seqcount_retry(&parent->d_seq, nd->seq))\n\t\t\tgoto out;\n\t\tBUG_ON(nd->inode != parent->d_inode);\n\t} else {\n\t\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\t\tgoto out;\n\t\tif (read_seqcount_retry(&dentry->d_seq, nd->seq))\n\t\t\tgoto drop_dentry;\n\t}\n\n\t/*\n\t * Sequence counts matched. Now make sure that the root is\n\t * still valid and get it if required.\n\t */\n\tif (nd->root.mnt && !(nd->flags & LOOKUP_ROOT)) {\n\t\tspin_lock(&fs->lock);\n\t\tif (nd->root.mnt != fs->root.mnt || nd->root.dentry != fs->root.dentry)\n\t\t\tgoto unlock_and_drop_dentry;\n\t\tpath_get(&nd->root);\n\t\tspin_unlock(&fs->lock);\n\t}\n\n\trcu_read_unlock();\n\treturn 0;\n\nunlock_and_drop_dentry:\n\tspin_unlock(&fs->lock);\ndrop_dentry:\n\trcu_read_unlock();\n\tdput(dentry);\n\tgoto drop_root_mnt;\nout:\n\trcu_read_unlock();\ndrop_root_mnt:\n\tif (!(nd->flags & LOOKUP_ROOT))\n\t\tnd->root.mnt = NULL;\n\treturn -ECHILD;\n}\n\nstatic inline int d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\treturn dentry->d_op->d_revalidate(dentry, flags);\n}\n\n/**\n * complete_walk - successful completion of path walk\n * @nd:  pointer nameidata\n *\n * If we had been in RCU mode, drop out of it and legitimize nd->path.\n * Revalidate the final result, unless we'd already done that during\n * the path walk or the filesystem doesn't ask for it.  Return 0 on\n * success, -error on failure.  In case of failure caller does not\n * need to drop nd->path.\n */\nstatic int complete_walk(struct nameidata *nd)\n{\n\tstruct dentry *dentry = nd->path.dentry;\n\tint status;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tnd->flags &= ~LOOKUP_RCU;\n\t\tif (!(nd->flags & LOOKUP_ROOT))\n\t\t\tnd->root.mnt = NULL;\n\n\t\tif (!legitimize_mnt(nd->path.mnt, nd->m_seq)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ECHILD;\n\t\t}\n\t\tif (unlikely(!lockref_get_not_dead(&dentry->d_lockref))) {\n\t\t\trcu_read_unlock();\n\t\t\tmntput(nd->path.mnt);\n\t\t\treturn -ECHILD;\n\t\t}\n\t\tif (read_seqcount_retry(&dentry->d_seq, nd->seq)) {\n\t\t\trcu_read_unlock();\n\t\t\tdput(dentry);\n\t\t\tmntput(nd->path.mnt);\n\t\t\treturn -ECHILD;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (likely(!(nd->flags & LOOKUP_JUMPED)))\n\t\treturn 0;\n\n\tif (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))\n\t\treturn 0;\n\n\tstatus = dentry->d_op->d_weak_revalidate(dentry, nd->flags);\n\tif (status > 0)\n\t\treturn 0;\n\n\tif (!status)\n\t\tstatus = -ESTALE;\n\n\tpath_put(&nd->path);\n\treturn status;\n}\n\nstatic __always_inline void set_root(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tget_fs_root(current->fs, &nd->root);\n}\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nstatic __always_inline void set_root_rcu(struct nameidata *nd)\n{\n\tif (!nd->root.mnt) {\n\t\tstruct fs_struct *fs = current->fs;\n\t\tunsigned seq;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\tnd->root = fs->root;\n\t\t\tnd->seq = __read_seqcount_begin(&nd->root.dentry->d_seq);\n\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t}\n}\n\nstatic void path_put_conditional(struct path *path, struct nameidata *nd)\n{\n\tdput(path->dentry);\n\tif (path->mnt != nd->path.mnt)\n\t\tmntput(path->mnt);\n}\n\nstatic inline void path_to_nameidata(const struct path *path,\n\t\t\t\t\tstruct nameidata *nd)\n{\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tdput(nd->path.dentry);\n\t\tif (nd->path.mnt != path->mnt)\n\t\t\tmntput(nd->path.mnt);\n\t}\n\tnd->path.mnt = path->mnt;\n\tnd->path.dentry = path->dentry;\n}\n\n/*\n * Helper to directly jump to a known parsed path from ->follow_link,\n * caller must have taken a reference to path beforehand.\n */\nvoid nd_jump_link(struct nameidata *nd, struct path *path)\n{\n\tpath_put(&nd->path);\n\n\tnd->path = *path;\n\tnd->inode = nd->path.dentry->d_inode;\n\tnd->flags |= LOOKUP_JUMPED;\n}\n\nstatic inline void put_link(struct nameidata *nd, struct path *link, void *cookie)\n{\n\tstruct inode *inode = link->dentry->d_inode;\n\tif (inode->i_op->put_link)\n\t\tinode->i_op->put_link(link->dentry, nd, cookie);\n\tpath_put(link);\n}\n\nint sysctl_protected_symlinks __read_mostly = 0;\nint sysctl_protected_hardlinks __read_mostly = 0;\n\n/**\n * may_follow_link - Check symlink following for unsafe situations\n * @link: The path of the symlink\n * @nd: nameidata pathwalk data\n *\n * In the case of the sysctl_protected_symlinks sysctl being enabled,\n * CAP_DAC_OVERRIDE needs to be specifically ignored if the symlink is\n * in a sticky world-writable directory. This is to protect privileged\n * processes from failing races against path names that may change out\n * from under them by way of other users creating malicious symlinks.\n * It will permit symlinks to be followed only when outside a sticky\n * world-writable directory, or when the uid of the symlink and follower\n * match, or when the directory owner matches the symlink's owner.\n *\n * Returns 0 if following the symlink is allowed, -ve on error.\n */\nstatic inline int may_follow_link(struct path *link, struct nameidata *nd)\n{\n\tconst struct inode *inode;\n\tconst struct inode *parent;\n\n\tif (!sysctl_protected_symlinks)\n\t\treturn 0;\n\n\t/* Allowed if owner and follower match. */\n\tinode = link->dentry->d_inode;\n\tif (uid_eq(current_cred()->fsuid, inode->i_uid))\n\t\treturn 0;\n\n\t/* Allowed if parent directory not sticky and world-writable. */\n\tparent = nd->path.dentry->d_inode;\n\tif ((parent->i_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))\n\t\treturn 0;\n\n\t/* Allowed if parent directory and link owner match. */\n\tif (uid_eq(parent->i_uid, inode->i_uid))\n\t\treturn 0;\n\n\taudit_log_link_denied(\"follow_link\", link);\n\tpath_put_conditional(link, nd);\n\tpath_put(&nd->path);\n\treturn -EACCES;\n}\n\n/**\n * safe_hardlink_source - Check for safe hardlink conditions\n * @inode: the source inode to hardlink from\n *\n * Return false if at least one of the following conditions:\n *    - inode is not a regular file\n *    - inode is setuid\n *    - inode is setgid and group-exec\n *    - access failure for read and write\n *\n * Otherwise returns true.\n */\nstatic bool safe_hardlink_source(struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\n\t/* Special files should not get pinned to the filesystem. */\n\tif (!S_ISREG(mode))\n\t\treturn false;\n\n\t/* Setuid files should not get pinned to the filesystem. */\n\tif (mode & S_ISUID)\n\t\treturn false;\n\n\t/* Executable setgid files should not get pinned to the filesystem. */\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))\n\t\treturn false;\n\n\t/* Hardlinking to unreadable or unwritable sources is dangerous. */\n\tif (inode_permission(inode, MAY_READ | MAY_WRITE))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * may_linkat - Check permissions for creating a hardlink\n * @link: the source to hardlink from\n *\n * Block hardlink when all of:\n *  - sysctl_protected_hardlinks enabled\n *  - fsuid does not match inode\n *  - hardlink source is unsafe (see safe_hardlink_source() above)\n *  - not CAP_FOWNER\n *\n * Returns 0 if successful, -ve on error.\n */\nstatic int may_linkat(struct path *link)\n{\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\n\tif (!sysctl_protected_hardlinks)\n\t\treturn 0;\n\n\tcred = current_cred();\n\tinode = link->dentry->d_inode;\n\n\t/* Source inode owner (or CAP_FOWNER) can hardlink all they like,\n\t * otherwise, it must be a safe source.\n\t */\n\tif (uid_eq(cred->fsuid, inode->i_uid) || safe_hardlink_source(inode) ||\n\t    capable(CAP_FOWNER))\n\t\treturn 0;\n\n\taudit_log_link_denied(\"linkat\", link);\n\treturn -EPERM;\n}\n\nstatic __always_inline int\nfollow_link(struct path *link, struct nameidata *nd, void **p)\n{\n\tstruct dentry *dentry = link->dentry;\n\tint error;\n\tchar *s;\n\n\tBUG_ON(nd->flags & LOOKUP_RCU);\n\n\tif (link->mnt == nd->path.mnt)\n\t\tmntget(link->mnt);\n\n\terror = -ELOOP;\n\tif (unlikely(current->total_link_count >= 40))\n\t\tgoto out_put_nd_path;\n\n\tcond_resched();\n\tcurrent->total_link_count++;\n\n\ttouch_atime(link);\n\tnd_set_link(nd, NULL);\n\n\terror = security_inode_follow_link(link->dentry, nd);\n\tif (error)\n\t\tgoto out_put_nd_path;\n\n\tnd->last_type = LAST_BIND;\n\t*p = dentry->d_inode->i_op->follow_link(dentry, nd);\n\terror = PTR_ERR(*p);\n\tif (IS_ERR(*p))\n\t\tgoto out_put_nd_path;\n\n\terror = 0;\n\ts = nd_get_link(nd);\n\tif (s) {\n\t\tif (unlikely(IS_ERR(s))) {\n\t\t\tpath_put(&nd->path);\n\t\t\tput_link(nd, link, *p);\n\t\t\treturn PTR_ERR(s);\n\t\t}\n\t\tif (*s == '/') {\n\t\t\tset_root(nd);\n\t\t\tpath_put(&nd->path);\n\t\t\tnd->path = nd->root;\n\t\t\tpath_get(&nd->root);\n\t\t\tnd->flags |= LOOKUP_JUMPED;\n\t\t}\n\t\tnd->inode = nd->path.dentry->d_inode;\n\t\terror = link_path_walk(s, nd);\n\t\tif (unlikely(error))\n\t\t\tput_link(nd, link, *p);\n\t}\n\n\treturn error;\n\nout_put_nd_path:\n\t*p = NULL;\n\tpath_put(&nd->path);\n\tpath_put(link);\n\treturn error;\n}\n\nstatic int follow_up_rcu(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tparent = mnt->mnt_parent;\n\tif (&parent->mnt == path->mnt)\n\t\treturn 0;\n\tmountpoint = mnt->mnt_mountpoint;\n\tpath->dentry = mountpoint;\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}\n\n/*\n * follow_up - Find the mountpoint of path's vfsmount\n *\n * Given a path, find the mountpoint of its source file system.\n * Replace @path with the path of the mountpoint in the parent mount.\n * Up is towards /.\n *\n * Return 1 if we went up a level and 0 if we were already at the\n * root.\n */\nint follow_up(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tread_seqlock_excl(&mount_lock);\n\tparent = mnt->mnt_parent;\n\tif (parent == mnt) {\n\t\tread_sequnlock_excl(&mount_lock);\n\t\treturn 0;\n\t}\n\tmntget(&parent->mnt);\n\tmountpoint = dget(mnt->mnt_mountpoint);\n\tread_sequnlock_excl(&mount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}\nEXPORT_SYMBOL(follow_up);\n\n/*\n * Perform an automount\n * - return -EISDIR to tell follow_managed() to stop and return the path we\n *   were called with.\n */\nstatic int follow_automount(struct path *path, unsigned flags,\n\t\t\t    bool *need_mntput)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!path->dentry->d_op || !path->dentry->d_op->d_automount)\n\t\treturn -EREMOTE;\n\n\t/* We don't want to mount if someone's just doing a stat -\n\t * unless they're stat'ing a directory and appended a '/' to\n\t * the name.\n\t *\n\t * We do, however, want to mount if someone wants to open or\n\t * create a file of any type under the mountpoint, wants to\n\t * traverse through the mountpoint or wants to open the\n\t * mounted directory.  Also, autofs may mark negative dentries\n\t * as being automount points.  These will need the attentions\n\t * of the daemon to instantiate them before they can be used.\n\t */\n\tif (!(flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY |\n\t\t     LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &&\n\t    path->dentry->d_inode)\n\t\treturn -EISDIR;\n\n\tcurrent->total_link_count++;\n\tif (current->total_link_count >= 40)\n\t\treturn -ELOOP;\n\n\tmnt = path->dentry->d_op->d_automount(path);\n\tif (IS_ERR(mnt)) {\n\t\t/*\n\t\t * The filesystem is allowed to return -EISDIR here to indicate\n\t\t * it doesn't want to automount.  For instance, autofs would do\n\t\t * this so that its userspace daemon can mount on this dentry.\n\t\t *\n\t\t * However, we can only permit this if it's a terminal point in\n\t\t * the path being looked up; if it wasn't then the remainder of\n\t\t * the path is inaccessible and we should say so.\n\t\t */\n\t\tif (PTR_ERR(mnt) == -EISDIR && (flags & LOOKUP_PARENT))\n\t\t\treturn -EREMOTE;\n\t\treturn PTR_ERR(mnt);\n\t}\n\n\tif (!mnt) /* mount collision */\n\t\treturn 0;\n\n\tif (!*need_mntput) {\n\t\t/* lock_mount() may release path->mnt on error */\n\t\tmntget(path->mnt);\n\t\t*need_mntput = true;\n\t}\n\terr = finish_automount(mnt, path);\n\n\tswitch (err) {\n\tcase -EBUSY:\n\t\t/* Someone else made a mount here whilst we were busy */\n\t\treturn 0;\n\tcase 0:\n\t\tpath_put(path);\n\t\tpath->mnt = mnt;\n\t\tpath->dentry = dget(mnt->mnt_root);\n\t\treturn 0;\n\tdefault:\n\t\treturn err;\n\t}\n\n}\n\n/*\n * Handle a dentry that is managed in some way.\n * - Flagged for transit management (autofs)\n * - Flagged as mountpoint\n * - Flagged as automount point\n *\n * This may only be called in refwalk mode.\n *\n * Serialization is taken care of in namespace.c\n */\nstatic int follow_managed(struct path *path, unsigned flags)\n{\n\tstruct vfsmount *mnt = path->mnt; /* held by caller, must be left alone */\n\tunsigned managed;\n\tbool need_mntput = false;\n\tint ret = 0;\n\n\t/* Given that we're not holding a lock here, we retain the value in a\n\t * local variable for each dentry as we look at it so that we don't see\n\t * the components of that value change under us */\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       managed &= DCACHE_MANAGED_DENTRY,\n\t       unlikely(managed != 0)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held. */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(path->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (mounted) {\n\t\t\t\tdput(path->dentry);\n\t\t\t\tif (need_mntput)\n\t\t\t\t\tmntput(path->mnt);\n\t\t\t\tpath->mnt = mounted;\n\t\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\t\tneed_mntput = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Something is mounted on this dentry in another\n\t\t\t * namespace and/or whatever was mounted there in this\n\t\t\t * namespace got unmounted before lookup_mnt() could\n\t\t\t * get it */\n\t\t}\n\n\t\t/* Handle an automount point */\n\t\tif (managed & DCACHE_NEED_AUTOMOUNT) {\n\t\t\tret = follow_automount(path, flags, &need_mntput);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We didn't change the current path point */\n\t\tbreak;\n\t}\n\n\tif (need_mntput && path->mnt == mnt)\n\t\tmntput(path->mnt);\n\tif (ret == -EISDIR)\n\t\tret = 0;\n\treturn ret < 0 ? ret : need_mntput;\n}\n\nint follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(follow_down_one);\n\nstatic inline bool managed_dentry_might_block(struct dentry *dentry)\n{\n\treturn (dentry->d_flags & DCACHE_MANAGE_TRANSIT &&\n\t\tdentry->d_op->d_manage(dentry, true) < 0);\n}\n\n/*\n * Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if\n * we meet a managed dentry that would need blocking.\n */\nstatic bool __follow_mount_rcu(struct nameidata *nd, struct path *path,\n\t\t\t       struct inode **inode)\n{\n\tfor (;;) {\n\t\tstruct mount *mounted;\n\t\t/*\n\t\t * Don't forget we might have a non-mountpoint managed dentry\n\t\t * that wants to block transit.\n\t\t */\n\t\tif (unlikely(managed_dentry_might_block(path->dentry)))\n\t\t\treturn false;\n\n\t\tif (!d_mountpoint(path->dentry))\n\t\t\treturn true;\n\n\t\tmounted = __lookup_mnt(path->mnt, path->dentry);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tpath->mnt = &mounted->mnt;\n\t\tpath->dentry = mounted->mnt.mnt_root;\n\t\tnd->flags |= LOOKUP_JUMPED;\n\t\tnd->seq = read_seqcount_begin(&path->dentry->d_seq);\n\t\t/*\n\t\t * Update the inode too. We don't need to re-check the\n\t\t * dentry sequence number here after this d_inode read,\n\t\t * because a mount-point is always pinned.\n\t\t */\n\t\t*inode = path->dentry->d_inode;\n\t}\n\treturn read_seqretry(&mount_lock, nd->m_seq);\n}\n\nstatic int follow_dotdot_rcu(struct nameidata *nd)\n{\n\tset_root_rcu(nd);\n\n\twhile (1) {\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tstruct dentry *old = nd->path.dentry;\n\t\t\tstruct dentry *parent = old->d_parent;\n\t\t\tunsigned seq;\n\n\t\t\tseq = read_seqcount_begin(&parent->d_seq);\n\t\t\tif (read_seqcount_retry(&old->d_seq, nd->seq))\n\t\t\t\tgoto failed;\n\t\t\tnd->path.dentry = parent;\n\t\t\tnd->seq = seq;\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up_rcu(&nd->path))\n\t\t\tbreak;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t}\n\twhile (d_mountpoint(nd->path.dentry)) {\n\t\tstruct mount *mounted;\n\t\tmounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tnd->path.mnt = &mounted->mnt;\n\t\tnd->path.dentry = mounted->mnt.mnt_root;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\tif (!read_seqretry(&mount_lock, nd->m_seq))\n\t\t\tgoto failed;\n\t}\n\tnd->inode = nd->path.dentry->d_inode;\n\treturn 0;\n\nfailed:\n\tnd->flags &= ~LOOKUP_RCU;\n\tif (!(nd->flags & LOOKUP_ROOT))\n\t\tnd->root.mnt = NULL;\n\trcu_read_unlock();\n\treturn -ECHILD;\n}\n\n/*\n * Follow down to the covering mount currently visible to userspace.  At each\n * point, the filesystem owning that dentry may be queried as to whether the\n * caller is permitted to proceed or not.\n */\nint follow_down(struct path *path)\n{\n\tunsigned managed;\n\tint ret;\n\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       unlikely(managed & DCACHE_MANAGED_DENTRY)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held.\n\t\t *\n\t\t * We indicate to the filesystem if someone is trying to mount\n\t\t * something here.  This gives autofs the chance to deny anyone\n\t\t * other than its daemon the right to mount on its\n\t\t * superstructure.\n\t\t *\n\t\t * The filesystem may sleep at this point.\n\t\t */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(\n\t\t\t\tpath->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret == -EISDIR ? 0 : ret;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (!mounted)\n\t\t\t\tbreak;\n\t\t\tdput(path->dentry);\n\t\t\tmntput(path->mnt);\n\t\t\tpath->mnt = mounted;\n\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Don't handle automount points here */\n\t\tbreak;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(follow_down);\n\n/*\n * Skip to top of mountpoint pile in refwalk mode for follow_dotdot()\n */\nstatic void follow_mount(struct path *path)\n{\n\twhile (d_mountpoint(path->dentry)) {\n\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t}\n}\n\nstatic void follow_dotdot(struct nameidata *nd)\n{\n\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\t/* rare case of legitimate dget_parent()... */\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}\n\n/*\n * This looks up the name in dcache, possibly revalidates the old dentry and\n * allocates a new one if not found or not valid.  In the need_lookup argument\n * returns whether i_op->lookup is necessary.\n *\n * dir->d_inode->i_mutex must be held\n */\nstatic struct dentry *lookup_dcache(struct qstr *name, struct dentry *dir,\n\t\t\t\t    unsigned int flags, bool *need_lookup)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\t*need_lookup = false;\n\tdentry = d_lookup(dir, name);\n\tif (dentry) {\n\t\tif (dentry->d_flags & DCACHE_OP_REVALIDATE) {\n\t\t\terror = d_revalidate(dentry, flags);\n\t\t\tif (unlikely(error <= 0)) {\n\t\t\t\tif (error < 0) {\n\t\t\t\t\tdput(dentry);\n\t\t\t\t\treturn ERR_PTR(error);\n\t\t\t\t} else if (!d_invalidate(dentry)) {\n\t\t\t\t\tdput(dentry);\n\t\t\t\t\tdentry = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!dentry) {\n\t\tdentry = d_alloc(dir, name);\n\t\tif (unlikely(!dentry))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\t*need_lookup = true;\n\t}\n\treturn dentry;\n}\n\n/*\n * Call i_op->lookup on the dentry.  The dentry must be negative and\n * unhashed.\n *\n * dir->d_inode->i_mutex must be held\n */\nstatic struct dentry *lookup_real(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct dentry *old;\n\n\t/* Don't create child dentry for a dead directory. */\n\tif (unlikely(IS_DEADDIR(dir))) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\told = dir->i_op->lookup(dir, dentry, flags);\n\tif (unlikely(old)) {\n\t\tdput(dentry);\n\t\tdentry = old;\n\t}\n\treturn dentry;\n}\n\nstatic struct dentry *__lookup_hash(struct qstr *name,\n\t\tstruct dentry *base, unsigned int flags)\n{\n\tbool need_lookup;\n\tstruct dentry *dentry;\n\n\tdentry = lookup_dcache(name, base, flags, &need_lookup);\n\tif (!need_lookup)\n\t\treturn dentry;\n\n\treturn lookup_real(base->d_inode, dentry, flags);\n}\n\n/*\n *  It's more convoluted than I'd like it to be, but... it's still fairly\n *  small and for now I'd prefer to have fast path as straight as possible.\n *  It _is_ time-critical.\n */\nstatic int lookup_fast(struct nameidata *nd,\n\t\t       struct path *path, struct inode **inode)\n{\n\tstruct vfsmount *mnt = nd->path.mnt;\n\tstruct dentry *dentry, *parent = nd->path.dentry;\n\tint need_reval = 1;\n\tint status = 1;\n\tint err;\n\n\t/*\n\t * Rename seqlock is not required here because in the off chance\n\t * of a false negative due to a concurrent rename, we're going to\n\t * do the non-racy lookup, below.\n\t */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tunsigned seq;\n\t\tdentry = __d_lookup_rcu(parent, &nd->last, &seq);\n\t\tif (!dentry)\n\t\t\tgoto unlazy;\n\n\t\t/*\n\t\t * This sequence count validates that the inode matches\n\t\t * the dentry name information from lookup.\n\t\t */\n\t\t*inode = dentry->d_inode;\n\t\tif (read_seqcount_retry(&dentry->d_seq, seq))\n\t\t\treturn -ECHILD;\n\n\t\t/*\n\t\t * This sequence count validates that the parent had no\n\t\t * changes while we did the lookup of the dentry above.\n\t\t *\n\t\t * The memory barrier in read_seqcount_begin of child is\n\t\t *  enough, we can use __read_seqcount_retry here.\n\t\t */\n\t\tif (__read_seqcount_retry(&parent->d_seq, nd->seq))\n\t\t\treturn -ECHILD;\n\t\tnd->seq = seq;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE)) {\n\t\t\tstatus = d_revalidate(dentry, nd->flags);\n\t\t\tif (unlikely(status <= 0)) {\n\t\t\t\tif (status != -ECHILD)\n\t\t\t\t\tneed_reval = 0;\n\t\t\t\tgoto unlazy;\n\t\t\t}\n\t\t}\n\t\tpath->mnt = mnt;\n\t\tpath->dentry = dentry;\n\t\tif (unlikely(!__follow_mount_rcu(nd, path, inode)))\n\t\t\tgoto unlazy;\n\t\tif (unlikely(path->dentry->d_flags & DCACHE_NEED_AUTOMOUNT))\n\t\t\tgoto unlazy;\n\t\treturn 0;\nunlazy:\n\t\tif (unlazy_walk(nd, dentry))\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tdentry = __d_lookup(parent, &nd->last);\n\t}\n\n\tif (unlikely(!dentry))\n\t\tgoto need_lookup;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE) && need_reval)\n\t\tstatus = d_revalidate(dentry, nd->flags);\n\tif (unlikely(status <= 0)) {\n\t\tif (status < 0) {\n\t\t\tdput(dentry);\n\t\t\treturn status;\n\t\t}\n\t\tif (!d_invalidate(dentry)) {\n\t\t\tdput(dentry);\n\t\t\tgoto need_lookup;\n\t\t}\n\t}\n\n\tpath->mnt = mnt;\n\tpath->dentry = dentry;\n\terr = follow_managed(path, nd->flags);\n\tif (unlikely(err < 0)) {\n\t\tpath_put_conditional(path, nd);\n\t\treturn err;\n\t}\n\tif (err)\n\t\tnd->flags |= LOOKUP_JUMPED;\n\t*inode = path->dentry->d_inode;\n\treturn 0;\n\nneed_lookup:\n\treturn 1;\n}\n\n/* Fast lookup failed, do it the slow way */\nstatic int lookup_slow(struct nameidata *nd, struct path *path)\n{\n\tstruct dentry *dentry, *parent;\n\tint err;\n\n\tparent = nd->path.dentry;\n\tBUG_ON(nd->inode != parent->d_inode);\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tdentry = __lookup_hash(&nd->last, parent, nd->flags);\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tpath->mnt = nd->path.mnt;\n\tpath->dentry = dentry;\n\terr = follow_managed(path, nd->flags);\n\tif (unlikely(err < 0)) {\n\t\tpath_put_conditional(path, nd);\n\t\treturn err;\n\t}\n\tif (err)\n\t\tnd->flags |= LOOKUP_JUMPED;\n\treturn 0;\n}\n\nstatic inline int may_lookup(struct nameidata *nd)\n{\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tint err = inode_permission(nd->inode, MAY_EXEC|MAY_NOT_BLOCK);\n\t\tif (err != -ECHILD)\n\t\t\treturn err;\n\t\tif (unlazy_walk(nd, NULL))\n\t\t\treturn -ECHILD;\n\t}\n\treturn inode_permission(nd->inode, MAY_EXEC);\n}\n\nstatic inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tif (follow_dotdot_rcu(nd))\n\t\t\t\treturn -ECHILD;\n\t\t} else\n\t\t\tfollow_dotdot(nd);\n\t}\n\treturn 0;\n}\n\nstatic void terminate_walk(struct nameidata *nd)\n{\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tpath_put(&nd->path);\n\t} else {\n\t\tnd->flags &= ~LOOKUP_RCU;\n\t\tif (!(nd->flags & LOOKUP_ROOT))\n\t\t\tnd->root.mnt = NULL;\n\t\trcu_read_unlock();\n\t}\n}\n\n/*\n * Do we need to follow links? We _really_ want to be able\n * to do this check without having to look at inode->i_op,\n * so we keep a cache of \"no, this doesn't need follow_link\"\n * for the common case.\n */\nstatic inline int should_follow_link(struct dentry *dentry, int follow)\n{\n\treturn unlikely(d_is_symlink(dentry)) ? follow : 0;\n}\n\nstatic inline int walk_component(struct nameidata *nd, struct path *path,\n\t\tint follow)\n{\n\tstruct inode *inode;\n\tint err;\n\t/*\n\t * \".\" and \"..\" are special - \"..\" especially so because it has\n\t * to be able to know about the current root directory and\n\t * parent relationships.\n\t */\n\tif (unlikely(nd->last_type != LAST_NORM))\n\t\treturn handle_dots(nd, nd->last_type);\n\terr = lookup_fast(nd, path, &inode);\n\tif (unlikely(err)) {\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\n\t\terr = lookup_slow(nd, path);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\n\t\tinode = path->dentry->d_inode;\n\t}\n\terr = -ENOENT;\n\tif (!inode || d_is_negative(path->dentry))\n\t\tgoto out_path_put;\n\n\tif (should_follow_link(path->dentry, follow)) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tif (unlikely(unlazy_walk(nd, path->dentry))) {\n\t\t\t\terr = -ECHILD;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(inode != path->dentry->d_inode);\n\t\treturn 1;\n\t}\n\tpath_to_nameidata(path, nd);\n\tnd->inode = inode;\n\treturn 0;\n\nout_path_put:\n\tpath_to_nameidata(path, nd);\nout_err:\n\tterminate_walk(nd);\n\treturn err;\n}\n\n/*\n * This limits recursive symlink follows to 8, while\n * limiting consecutive symlinks to 40.\n *\n * Without that kind of total limit, nasty chains of consecutive\n * symlinks can cause almost arbitrarily long lookups.\n */\nstatic inline int nested_symlink(struct path *path, struct nameidata *nd)\n{\n\tint res;\n\n\tif (unlikely(current->link_count >= MAX_NESTED_LINKS)) {\n\t\tpath_put_conditional(path, nd);\n\t\tpath_put(&nd->path);\n\t\treturn -ELOOP;\n\t}\n\tBUG_ON(nd->depth >= MAX_NESTED_LINKS);\n\n\tnd->depth++;\n\tcurrent->link_count++;\n\n\tdo {\n\t\tstruct path link = *path;\n\t\tvoid *cookie;\n\n\t\tres = follow_link(&link, nd, &cookie);\n\t\tif (res)\n\t\t\tbreak;\n\t\tres = walk_component(nd, path, LOOKUP_FOLLOW);\n\t\tput_link(nd, &link, cookie);\n\t} while (res > 0);\n\n\tcurrent->link_count--;\n\tnd->depth--;\n\treturn res;\n}\n\n/*\n * We can do the critical dentry name comparison and hashing\n * operations one word at a time, but we are limited to:\n *\n * - Architectures with fast unaligned word accesses. We could\n *   do a \"get_unaligned()\" if this helps and is sufficiently\n *   fast.\n *\n * - non-CONFIG_DEBUG_PAGEALLOC configurations (so that we\n *   do not trap on the (extremely unlikely) case of a page\n *   crossing operation.\n *\n * - Furthermore, we need an efficient 64-bit compile for the\n *   64-bit case in order to generate the \"number of bytes in\n *   the final mask\". Again, that could be replaced with a\n *   efficient population count instruction or similar.\n */\n#ifdef CONFIG_DCACHE_WORD_ACCESS\n\n#include <asm/word-at-a-time.h>\n\n#ifdef CONFIG_64BIT\n\nstatic inline unsigned int fold_hash(unsigned long hash)\n{\n\thash += hash >> (8*sizeof(int));\n\treturn hash;\n}\n\n#else\t/* 32-bit case */\n\n#define fold_hash(x) (x)\n\n#endif\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long a, mask;\n\tunsigned long hash = 0;\n\n\tfor (;;) {\n\t\ta = load_unaligned_zeropad(name);\n\t\tif (len < sizeof(unsigned long))\n\t\t\tbreak;\n\t\thash += a;\n\t\thash *= 9;\n\t\tname += sizeof(unsigned long);\n\t\tlen -= sizeof(unsigned long);\n\t\tif (!len)\n\t\t\tgoto done;\n\t}\n\tmask = bytemask_from_count(len);\n\thash += mask & a;\ndone:\n\treturn fold_hash(hash);\n}\nEXPORT_SYMBOL(full_name_hash);\n\n/*\n * Calculate the length and hash of the path component, and\n * return the length of the component;\n */\nstatic inline unsigned long hash_name(const char *name, unsigned int *hashp)\n{\n\tunsigned long a, b, adata, bdata, mask, hash, len;\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\n\thash = a = 0;\n\tlen = -sizeof(unsigned long);\n\tdo {\n\t\thash = (hash + a) * 9;\n\t\tlen += sizeof(unsigned long);\n\t\ta = load_unaligned_zeropad(name+len);\n\t\tb = a ^ REPEAT_BYTE('/');\n\t} while (!(has_zero(a, &adata, &constants) | has_zero(b, &bdata, &constants)));\n\n\tadata = prep_zero_mask(a, adata, &constants);\n\tbdata = prep_zero_mask(b, bdata, &constants);\n\n\tmask = create_zero_mask(adata | bdata);\n\n\thash += a & zero_bytemask(mask);\n\t*hashp = fold_hash(hash);\n\n\treturn len + find_zero(mask);\n}\n\n#else\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}\nEXPORT_SYMBOL(full_name_hash);\n\n/*\n * We know there's a real path component here of at least\n * one character.\n */\nstatic inline unsigned long hash_name(const char *name, unsigned int *hashp)\n{\n\tunsigned long hash = init_name_hash();\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\tdo {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t} while (c && c != '/');\n\t*hashp = end_name_hash(hash);\n\treturn len;\n}\n\n#endif\n\n/*\n * Name resolution.\n * This is the basic name resolution function, turning a pathname into\n * the final dentry. We expect 'base' to be positive and a directory.\n *\n * Returns 0 and nd will have valid dentry and mnt on success.\n * Returns error and drops reference to input namei data on failure.\n */\nstatic int link_path_walk(const char *name, struct nameidata *nd)\n{\n\tstruct path next;\n\tint err;\n\t\n\twhile (*name=='/')\n\t\tname++;\n\tif (!*name)\n\t\treturn 0;\n\n\t/* At this point we know we have a real path component. */\n\tfor(;;) {\n\t\tstruct qstr this;\n\t\tlong len;\n\t\tint type;\n\n\t\terr = may_lookup(nd);\n \t\tif (err)\n\t\t\tbreak;\n\n\t\tlen = hash_name(name, &this.hash);\n\t\tthis.name = name;\n\t\tthis.len = len;\n\n\t\ttype = LAST_NORM;\n\t\tif (name[0] == '.') switch (len) {\n\t\t\tcase 2:\n\t\t\t\tif (name[1] == '.') {\n\t\t\t\t\ttype = LAST_DOTDOT;\n\t\t\t\t\tnd->flags |= LOOKUP_JUMPED;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttype = LAST_DOT;\n\t\t}\n\t\tif (likely(type == LAST_NORM)) {\n\t\t\tstruct dentry *parent = nd->path.dentry;\n\t\t\tnd->flags &= ~LOOKUP_JUMPED;\n\t\t\tif (unlikely(parent->d_flags & DCACHE_OP_HASH)) {\n\t\t\t\terr = parent->d_op->d_hash(parent, &this);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tnd->last = this;\n\t\tnd->last_type = type;\n\n\t\tif (!name[len])\n\t\t\treturn 0;\n\t\t/*\n\t\t * If it wasn't NUL, we know it was '/'. Skip that\n\t\t * slash, and continue until no more slashes.\n\t\t */\n\t\tdo {\n\t\t\tlen++;\n\t\t} while (unlikely(name[len] == '/'));\n\t\tif (!name[len])\n\t\t\treturn 0;\n\n\t\tname += len;\n\n\t\terr = walk_component(nd, &next, LOOKUP_FOLLOW);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (err) {\n\t\t\terr = nested_symlink(&next, nd);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (!d_can_lookup(nd->path.dentry)) {\n\t\t\terr = -ENOTDIR; \n\t\t\tbreak;\n\t\t}\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n\nstatic int path_init(int dfd, const char *name, unsigned int flags,\n\t\t     struct nameidata *nd, struct file **fp)\n{\n\tint retval = 0;\n\n\tnd->last_type = LAST_ROOT; /* if there are only slashes... */\n\tnd->flags = flags | LOOKUP_JUMPED;\n\tnd->depth = 0;\n\tif (flags & LOOKUP_ROOT) {\n\t\tstruct dentry *root = nd->root.dentry;\n\t\tstruct inode *inode = root->d_inode;\n\t\tif (*name) {\n\t\t\tif (!d_can_lookup(root))\n\t\t\t\treturn -ENOTDIR;\n\t\t\tretval = inode_permission(inode, MAY_EXEC);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tnd->path = nd->root;\n\t\tnd->inode = inode;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\trcu_read_lock();\n\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\tnd->m_seq = read_seqbegin(&mount_lock);\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tnd->root.mnt = NULL;\n\n\tnd->m_seq = read_seqbegin(&mount_lock);\n\tif (*name=='/') {\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\trcu_read_lock();\n\t\t\tset_root_rcu(nd);\n\t\t} else {\n\t\t\tset_root(nd);\n\t\t\tpath_get(&nd->root);\n\t\t}\n\t\tnd->path = nd->root;\n\t} else if (dfd == AT_FDCWD) {\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tstruct fs_struct *fs = current->fs;\n\t\t\tunsigned seq;\n\n\t\t\trcu_read_lock();\n\n\t\t\tdo {\n\t\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\t\tnd->path = fs->pwd;\n\t\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t\t} else {\n\t\t\tget_fs_pwd(current->fs, &nd->path);\n\t\t}\n\t} else {\n\t\t/* Caller must check execute permissions on the starting path component */\n\t\tstruct fd f = fdget_raw(dfd);\n\t\tstruct dentry *dentry;\n\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\n\t\tdentry = f.file->f_path.dentry;\n\n\t\tif (*name) {\n\t\t\tif (!d_can_lookup(dentry)) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -ENOTDIR;\n\t\t\t}\n\t\t}\n\n\t\tnd->path = f.file->f_path;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tif (f.flags & FDPUT_FPUT)\n\t\t\t\t*fp = f.file;\n\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\trcu_read_lock();\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t\tfdput(f);\n\t\t}\n\t}\n\n\tnd->inode = nd->path.dentry->d_inode;\n\treturn 0;\n}\n\nstatic inline int lookup_last(struct nameidata *nd, struct path *path)\n{\n\tif (nd->last_type == LAST_NORM && nd->last.name[nd->last.len])\n\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\treturn walk_component(nd, path, nd->flags & LOOKUP_FOLLOW);\n}\n\n/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */\nstatic int path_lookupat(int dfd, const char *name,\n\t\t\t\tunsigned int flags, struct nameidata *nd)\n{\n\tstruct file *base = NULL;\n\tstruct path path;\n\tint err;\n\n\t/*\n\t * Path walking is largely split up into 2 different synchronisation\n\t * schemes, rcu-walk and ref-walk (explained in\n\t * Documentation/filesystems/path-lookup.txt). These share much of the\n\t * path walk code, but some things particularly setup, cleanup, and\n\t * following mounts are sufficiently divergent that functions are\n\t * duplicated. Typically there is a function foo(), and its RCU\n\t * analogue, foo_rcu().\n\t *\n\t * -ECHILD is the error number of choice (just to avoid clashes) that\n\t * is returned if some aspect of an rcu-walk fails. Such an error must\n\t * be handled by restarting a traditional ref-walk (which will always\n\t * be able to complete).\n\t */\n\terr = path_init(dfd, name, flags | LOOKUP_PARENT, nd, &base);\n\n\tif (unlikely(err))\n\t\treturn err;\n\n\tcurrent->total_link_count = 0;\n\terr = link_path_walk(name, nd);\n\n\tif (!err && !(flags & LOOKUP_PARENT)) {\n\t\terr = lookup_last(nd, &path);\n\t\twhile (err > 0) {\n\t\t\tvoid *cookie;\n\t\t\tstruct path link = path;\n\t\t\terr = may_follow_link(&link, nd);\n\t\t\tif (unlikely(err))\n\t\t\t\tbreak;\n\t\t\tnd->flags |= LOOKUP_PARENT;\n\t\t\terr = follow_link(&link, nd, &cookie);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\terr = lookup_last(nd, &path);\n\t\t\tput_link(nd, &link, cookie);\n\t\t}\n\t}\n\n\tif (!err)\n\t\terr = complete_walk(nd);\n\n\tif (!err && nd->flags & LOOKUP_DIRECTORY) {\n\t\tif (!d_can_lookup(nd->path.dentry)) {\n\t\t\tpath_put(&nd->path);\n\t\t\terr = -ENOTDIR;\n\t\t}\n\t}\n\n\tif (base)\n\t\tfput(base);\n\n\tif (nd->root.mnt && !(nd->flags & LOOKUP_ROOT)) {\n\t\tpath_put(&nd->root);\n\t\tnd->root.mnt = NULL;\n\t}\n\treturn err;\n}\n\nstatic int filename_lookup(int dfd, struct filename *name,\n\t\t\t\tunsigned int flags, struct nameidata *nd)\n{\n\tint retval = path_lookupat(dfd, name->name, flags | LOOKUP_RCU, nd);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_lookupat(dfd, name->name, flags, nd);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_lookupat(dfd, name->name,\n\t\t\t\t\t\tflags | LOOKUP_REVAL, nd);\n\n\tif (likely(!retval))\n\t\taudit_inode(name, nd->path.dentry, flags & LOOKUP_PARENT);\n\treturn retval;\n}\n\nstatic int do_path_lookup(int dfd, const char *name,\n\t\t\t\tunsigned int flags, struct nameidata *nd)\n{\n\tstruct filename filename = { .name = name };\n\n\treturn filename_lookup(dfd, &filename, flags, nd);\n}\n\n/* does lookup, returns the object with parent locked */\nstruct dentry *kern_path_locked(const char *name, struct path *path)\n{\n\tstruct nameidata nd;\n\tstruct dentry *d;\n\tint err = do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, &nd);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (nd.last_type != LAST_NORM) {\n\t\tpath_put(&nd.path);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\td = __lookup_hash(&nd.last, nd.path.dentry, 0);\n\tif (IS_ERR(d)) {\n\t\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\t\tpath_put(&nd.path);\n\t\treturn d;\n\t}\n\t*path = nd.path;\n\treturn d;\n}\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}\nEXPORT_SYMBOL(kern_path);\n\n/**\n * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair\n * @dentry:  pointer to dentry of the base directory\n * @mnt: pointer to vfs mount of the base directory\n * @name: pointer to file name\n * @flags: lookup flags\n * @path: pointer to struct path to fill\n */\nint vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,\n\t\t    const char *name, unsigned int flags,\n\t\t    struct path *path)\n{\n\tstruct nameidata nd;\n\tint err;\n\tnd.root.dentry = dentry;\n\tnd.root.mnt = mnt;\n\tBUG_ON(flags & LOOKUP_PARENT);\n\t/* the first argument of do_path_lookup() is ignored with LOOKUP_ROOT */\n\terr = do_path_lookup(AT_FDCWD, name, flags | LOOKUP_ROOT, &nd);\n\tif (!err)\n\t\t*path = nd.path;\n\treturn err;\n}\nEXPORT_SYMBOL(vfs_path_lookup);\n\n/*\n * Restricted form of lookup. Doesn't follow links, single-component only,\n * needs parent already locked. Doesn't follow mounts.\n * SMP-safe.\n */\nstatic struct dentry *lookup_hash(struct nameidata *nd)\n{\n\treturn __lookup_hash(&nd->last, nd->path.dentry, nd->flags);\n}\n\n/**\n * lookup_one_len - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.  Also note that by using this function the\n * nameidata argument is passed to the filesystem methods and a filesystem\n * using this helper needs to be prepared for that.\n */\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}\nEXPORT_SYMBOL(lookup_one_len);\n\nint user_path_at_empty(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path, int *empty)\n{\n\tstruct nameidata nd;\n\tstruct filename *tmp = getname_flags(name, flags, empty);\n\tint err = PTR_ERR(tmp);\n\tif (!IS_ERR(tmp)) {\n\n\t\tBUG_ON(flags & LOOKUP_PARENT);\n\n\t\terr = filename_lookup(dfd, tmp, flags, &nd);\n\t\tputname(tmp);\n\t\tif (!err)\n\t\t\t*path = nd.path;\n\t}\n\treturn err;\n}\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}\nEXPORT_SYMBOL(user_path_at);\n\n/*\n * NB: most callers don't do anything directly with the reference to the\n *     to struct filename, but the nd->last pointer points into the name string\n *     allocated by getname. So we must hold the reference to it until all\n *     path-walking is complete.\n */\nstatic struct filename *\nuser_path_parent(int dfd, const char __user *path, struct nameidata *nd,\n\t\t unsigned int flags)\n{\n\tstruct filename *s = getname(path);\n\tint error;\n\n\t/* only LOOKUP_REVAL is allowed in extra flags */\n\tflags &= LOOKUP_REVAL;\n\n\tif (IS_ERR(s))\n\t\treturn s;\n\n\terror = filename_lookup(dfd, s, flags | LOOKUP_PARENT, nd);\n\tif (error) {\n\t\tputname(s);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn s;\n}\n\n/**\n * mountpoint_last - look up last component for umount\n * @nd:   pathwalk nameidata - currently pointing at parent directory of \"last\"\n * @path: pointer to container for result\n *\n * This is a special lookup_last function just for umount. In this case, we\n * need to resolve the path without doing any revalidation.\n *\n * The nameidata should be the result of doing a LOOKUP_PARENT pathwalk. Since\n * mountpoints are always pinned in the dcache, their ancestors are too. Thus,\n * in almost all cases, this lookup will be served out of the dcache. The only\n * cases where it won't are if nd->last refers to a symlink or the path is\n * bogus and it doesn't exist.\n *\n * Returns:\n * -error: if there was an error during lookup. This includes -ENOENT if the\n *         lookup found a negative dentry. The nd->path reference will also be\n *         put in this case.\n *\n * 0:      if we successfully resolved nd->path and found it to not to be a\n *         symlink that needs to be followed. \"path\" will also be populated.\n *         The nd->path reference will also be put.\n *\n * 1:      if we successfully resolved nd->last and found it to be a symlink\n *         that needs to be followed. \"path\" will be populated with the path\n *         to the link, and nd->path will *not* be put.\n */\nstatic int\nmountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\n\t/* If we're in rcuwalk, drop out of it to handle last component */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\t/*\n\t\t * No cached dentry. Mounted dentries are pinned in the cache,\n\t\t * so that means that this dentry is probably a symlink or the\n\t\t * path doesn't actually point to a mounted dentry.\n\t\t */\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\tpath->dentry = dentry;\n\tpath->mnt = nd->path.mnt;\n\tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n\t\treturn 1;\n\tmntget(path->mnt);\n\tfollow_mount(path);\n\terror = 0;\nout:\n\tterminate_walk(nd);\n\treturn error;\n}\n\n/**\n * path_mountpoint - look up a path to be umounted\n * @dfd:\tdirectory file descriptor to start walk from\n * @name:\tfull pathname to walk\n * @path:\tpointer to container for result\n * @flags:\tlookup flags\n *\n * Look up the given name, but don't attempt to revalidate the last component.\n * Returns 0 and \"path\" will be valid on success; Returns error otherwise.\n */\nstatic int\npath_mountpoint(int dfd, const char *name, struct path *path, unsigned int flags)\n{\n\tstruct file *base = NULL;\n\tstruct nameidata nd;\n\tint err;\n\n\terr = path_init(dfd, name, flags | LOOKUP_PARENT, &nd, &base);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tcurrent->total_link_count = 0;\n\terr = link_path_walk(name, &nd);\n\tif (err)\n\t\tgoto out;\n\n\terr = mountpoint_last(&nd, path);\n\twhile (err > 0) {\n\t\tvoid *cookie;\n\t\tstruct path link = *path;\n\t\terr = may_follow_link(&link, &nd);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tnd.flags |= LOOKUP_PARENT;\n\t\terr = follow_link(&link, &nd, &cookie);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = mountpoint_last(&nd, path);\n\t\tput_link(&nd, &link, cookie);\n\t}\nout:\n\tif (base)\n\t\tfput(base);\n\n\tif (nd.root.mnt && !(nd.flags & LOOKUP_ROOT))\n\t\tpath_put(&nd.root);\n\n\treturn err;\n}\n\nstatic int\nfilename_mountpoint(int dfd, struct filename *s, struct path *path,\n\t\t\tunsigned int flags)\n{\n\tint error = path_mountpoint(dfd, s->name, path, flags | LOOKUP_RCU);\n\tif (unlikely(error == -ECHILD))\n\t\terror = path_mountpoint(dfd, s->name, path, flags);\n\tif (unlikely(error == -ESTALE))\n\t\terror = path_mountpoint(dfd, s->name, path, flags | LOOKUP_REVAL);\n\tif (likely(!error))\n\t\taudit_inode(s, path->dentry, 0);\n\treturn error;\n}\n\n/**\n * user_path_mountpoint_at - lookup a path from userland in order to umount it\n * @dfd:\tdirectory file descriptor\n * @name:\tpathname from userland\n * @flags:\tlookup flags\n * @path:\tpointer to container to hold result\n *\n * A umount is a special case for path walking. We're not actually interested\n * in the inode in this situation, and ESTALE errors can be a problem. We\n * simply want track down the dentry and vfsmount attached at the mountpoint\n * and avoid revalidating the last component.\n *\n * Returns 0 and populates \"path\" on success.\n */\nint\nuser_path_mountpoint_at(int dfd, const char __user *name, unsigned int flags,\n\t\t\tstruct path *path)\n{\n\tstruct filename *s = getname(name);\n\tint error;\n\tif (IS_ERR(s))\n\t\treturn PTR_ERR(s);\n\terror = filename_mountpoint(dfd, s, path, flags);\n\tputname(s);\n\treturn error;\n}\n\nint\nkern_path_mountpoint(int dfd, const char *name, struct path *path,\n\t\t\tunsigned int flags)\n{\n\tstruct filename s = {.name = name};\n\treturn filename_mountpoint(dfd, &s, path, flags);\n}\nEXPORT_SYMBOL(kern_path_mountpoint);\n\n/*\n * It's inline, so penalty for filesystems that don't use sticky bit is\n * minimal.\n */\nstatic inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !capable_wrt_inode_uidgid(inode, CAP_FOWNER);\n}\n\n/*\n *\tCheck whether we can remove a link victim from directory dir, check\n *  whether the type of victim is right.\n *  1. We can't do it if dir is read-only (done in permission())\n *  2. We should have write and exec permissions on dir\n *  3. We can't remove anything from append-only dir\n *  4. We can't do anything with immutable dir (done in permission())\n *  5. If the sticky bit on dir is set we should either\n *\ta. be owner of dir, or\n *\tb. be owner of victim, or\n *\tc. have CAP_FOWNER capability\n *  6. If the victim is append-only or immutable we can't do antyhing with\n *     links pointing to it.\n *  7. If we were asked to remove a directory and victim isn't one - ENOTDIR.\n *  8. If we were asked to remove a non-directory and victim isn't one - EISDIR.\n *  9. We can't remove a root or mountpoint.\n * 10. We don't allow removal of NFS sillyrenamed files; it's handled by\n *     nfs_async_unlink().\n */\nstatic int may_delete(struct inode *dir, struct dentry *victim, bool isdir)\n{\n\tstruct inode *inode = victim->d_inode;\n\tint error;\n\n\tif (d_is_negative(victim))\n\t\treturn -ENOENT;\n\tBUG_ON(!inode);\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\n\tif (check_sticky(dir, inode) || IS_APPEND(inode) ||\n\t    IS_IMMUTABLE(inode) || IS_SWAPFILE(inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!d_is_dir(victim))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (d_is_dir(victim))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n/*\tCheck whether we can create an object with dentry child in directory\n *  dir.\n *  1. We can't do it if child already exists (open has special treatment for\n *     this case, but since we are inlined it's OK)\n *  2. We can't do it if dir is read-only (done in permission())\n *  3. We should have write and exec permissions on dir\n *  4. We can't do it if dir is immutable (done in permission())\n */\nstatic inline int may_create(struct inode *dir, struct dentry *child)\n{\n\taudit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}\n\n/*\n * p1 and p2 should be directories on the same fs.\n */\nstruct dentry *lock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tif (p1 == p2) {\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\n\tp = d_ancestor(p2, p1);\n\tif (p) {\n\t\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tp = d_ancestor(p1, p2);\n\tif (p) {\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);\n\treturn NULL;\n}\nEXPORT_SYMBOL(lock_rename);\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}\nEXPORT_SYMBOL(unlock_rename);\n\nint vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool want_excl)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = dir->i_op->create(dir, dentry, mode, want_excl);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_create);\n\nstatic int may_open(struct path *path, int acc_mode, int flag)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\t/* O_PATH? */\n\tif (!acc_mode)\n\t\treturn 0;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\treturn -ELOOP;\n\tcase S_IFDIR:\n\t\tif (acc_mode & MAY_WRITE)\n\t\t\treturn -EISDIR;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tif (path->mnt->mnt_flags & MNT_NODEV)\n\t\t\treturn -EACCES;\n\t\t/*FALLTHRU*/\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tflag &= ~O_TRUNC;\n\t\tbreak;\n\t}\n\n\terror = inode_permission(inode, acc_mode);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * An append-only file must be opened in append mode for writing.\n\t */\n\tif (IS_APPEND(inode)) {\n\t\tif  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))\n\t\t\treturn -EPERM;\n\t\tif (flag & O_TRUNC)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* O_NOATIME can only be set by the owner or superuser */\n\tif (flag & O_NOATIME && !inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic int handle_truncate(struct file *filp)\n{\n\tstruct path *path = &filp->f_path;\n\tstruct inode *inode = path->dentry->d_inode;\n\tint error = get_write_access(inode);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Refuse to truncate files with mandatory locks held on them.\n\t */\n\terror = locks_verify_locked(filp);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error) {\n\t\terror = do_truncate(path->dentry, 0,\n\t\t\t\t    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,\n\t\t\t\t    filp);\n\t}\n\tput_write_access(inode);\n\treturn error;\n}\n\nstatic inline int open_to_namei_flags(int flag)\n{\n\tif ((flag & O_ACCMODE) == 3)\n\t\tflag--;\n\treturn flag;\n}\n\nstatic int may_o_create(struct path *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = security_path_mknod(dir, dentry, mode, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = inode_permission(dir->dentry->d_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn security_inode_create(dir->dentry->d_inode, dentry, mode);\n}\n\n/*\n * Attempt to atomically look up, create and open a file from a negative\n * dentry.\n *\n * Returns 0 if successful.  The file will have been created and attached to\n * @file by the filesystem calling finish_open().\n *\n * Returns 1 if the file was looked up only or didn't need creating.  The\n * caller will need to perform the open themselves.  @path will have been\n * updated to point to the new dentry.  This may be negative.\n *\n * Returns an error code otherwise.\n */\nstatic int atomic_open(struct nameidata *nd, struct dentry *dentry,\n\t\t\tstruct path *path, struct file *file,\n\t\t\tconst struct open_flags *op,\n\t\t\tbool got_write, bool need_lookup,\n\t\t\tint *opened)\n{\n\tstruct inode *dir =  nd->path.dentry->d_inode;\n\tunsigned open_flag = open_to_namei_flags(op->open_flag);\n\tumode_t mode;\n\tint error;\n\tint acc_mode;\n\tint create_error = 0;\n\tstruct dentry *const DENTRY_NOT_SET = (void *) -1UL;\n\tbool excl;\n\n\tBUG_ON(dentry->d_inode);\n\n\t/* Don't create child dentry for a dead directory. */\n\tif (unlikely(IS_DEADDIR(dir))) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tmode = op->mode;\n\tif ((open_flag & O_CREAT) && !IS_POSIXACL(dir))\n\t\tmode &= ~current_umask();\n\n\texcl = (open_flag & (O_EXCL | O_CREAT)) == (O_EXCL | O_CREAT);\n\tif (excl)\n\t\topen_flag &= ~O_TRUNC;\n\n\t/*\n\t * Checking write permission is tricky, bacuse we don't know if we are\n\t * going to actually need it: O_CREAT opens should work as long as the\n\t * file exists.  But checking existence breaks atomicity.  The trick is\n\t * to check access and if not granted clear O_CREAT from the flags.\n\t *\n\t * Another problem is returing the \"right\" error value (e.g. for an\n\t * O_EXCL open we want to return EEXIST not EROFS).\n\t */\n\tif (((open_flag & (O_CREAT | O_TRUNC)) ||\n\t    (open_flag & O_ACCMODE) != O_RDONLY) && unlikely(!got_write)) {\n\t\tif (!(open_flag & O_CREAT)) {\n\t\t\t/*\n\t\t\t * No O_CREATE -> atomicity not a requirement -> fall\n\t\t\t * back to lookup + open\n\t\t\t */\n\t\t\tgoto no_open;\n\t\t} else if (open_flag & (O_EXCL | O_TRUNC)) {\n\t\t\t/* Fall back and fail with the right error */\n\t\t\tcreate_error = -EROFS;\n\t\t\tgoto no_open;\n\t\t} else {\n\t\t\t/* No side effects, safe to clear O_CREAT */\n\t\t\tcreate_error = -EROFS;\n\t\t\topen_flag &= ~O_CREAT;\n\t\t}\n\t}\n\n\tif (open_flag & O_CREAT) {\n\t\terror = may_o_create(&nd->path, dentry, mode);\n\t\tif (error) {\n\t\t\tcreate_error = error;\n\t\t\tif (open_flag & O_EXCL)\n\t\t\t\tgoto no_open;\n\t\t\topen_flag &= ~O_CREAT;\n\t\t}\n\t}\n\n\tif (nd->flags & LOOKUP_DIRECTORY)\n\t\topen_flag |= O_DIRECTORY;\n\n\tfile->f_path.dentry = DENTRY_NOT_SET;\n\tfile->f_path.mnt = nd->path.mnt;\n\terror = dir->i_op->atomic_open(dir, dentry, file, open_flag, mode,\n\t\t\t\t      opened);\n\tif (error < 0) {\n\t\tif (create_error && error == -ENOENT)\n\t\t\terror = create_error;\n\t\tgoto out;\n\t}\n\n\tif (error) {\t/* returned 1, that is */\n\t\tif (WARN_ON(file->f_path.dentry == DENTRY_NOT_SET)) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (file->f_path.dentry) {\n\t\t\tdput(dentry);\n\t\t\tdentry = file->f_path.dentry;\n\t\t}\n\t\tif (*opened & FILE_CREATED)\n\t\t\tfsnotify_create(dir, dentry);\n\t\tif (!dentry->d_inode) {\n\t\t\tWARN_ON(*opened & FILE_CREATED);\n\t\t\tif (create_error) {\n\t\t\t\terror = create_error;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tif (excl && !(*opened & FILE_CREATED)) {\n\t\t\t\terror = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tgoto looked_up;\n\t}\n\n\t/*\n\t * We didn't have the inode before the open, so check open permission\n\t * here.\n\t */\n\tacc_mode = op->acc_mode;\n\tif (*opened & FILE_CREATED) {\n\t\tWARN_ON(!(open_flag & O_CREAT));\n\t\tfsnotify_create(dir, dentry);\n\t\tacc_mode = MAY_OPEN;\n\t}\n\terror = may_open(&file->f_path, acc_mode, open_flag);\n\tif (error)\n\t\tfput(file);\n\nout:\n\tdput(dentry);\n\treturn error;\n\nno_open:\n\tif (need_lookup) {\n\t\tdentry = lookup_real(dir, dentry, nd->flags);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn PTR_ERR(dentry);\n\n\t\tif (create_error) {\n\t\t\tint open_flag = op->open_flag;\n\n\t\t\terror = create_error;\n\t\t\tif ((open_flag & O_EXCL)) {\n\t\t\t\tif (!dentry->d_inode)\n\t\t\t\t\tgoto out;\n\t\t\t} else if (!dentry->d_inode) {\n\t\t\t\tgoto out;\n\t\t\t} else if ((open_flag & O_TRUNC) &&\n\t\t\t\t   S_ISREG(dentry->d_inode->i_mode)) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* will fail later, go on to get the right error */\n\t\t}\n\t}\nlooked_up:\n\tpath->dentry = dentry;\n\tpath->mnt = nd->path.mnt;\n\treturn 1;\n}\n\n/*\n * Look up and maybe create and open the last component.\n *\n * Must be called with i_mutex held on parent.\n *\n * Returns 0 if the file was successfully atomically created (if necessary) and\n * opened.  In this case the file will be returned attached to @file.\n *\n * Returns 1 if the file was not completely opened at this time, though lookups\n * and creations will have been performed and the dentry returned in @path will\n * be positive upon return if O_CREAT was specified.  If O_CREAT wasn't\n * specified then a negative dentry may be returned.\n *\n * An error code is returned otherwise.\n *\n * FILE_CREATE will be set in @*opened if the dentry was created and will be\n * cleared otherwise prior to returning.\n */\nstatic int lookup_open(struct nameidata *nd, struct path *path,\n\t\t\tstruct file *file,\n\t\t\tconst struct open_flags *op,\n\t\t\tbool got_write, int *opened)\n{\n\tstruct dentry *dir = nd->path.dentry;\n\tstruct inode *dir_inode = dir->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\tbool need_lookup;\n\n\t*opened &= ~FILE_CREATED;\n\tdentry = lookup_dcache(&nd->last, dir, nd->flags, &need_lookup);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\t/* Cached positive dentry: will open in f_op->open */\n\tif (!need_lookup && dentry->d_inode)\n\t\tgoto out_no_open;\n\n\tif ((nd->flags & LOOKUP_OPEN) && dir_inode->i_op->atomic_open) {\n\t\treturn atomic_open(nd, dentry, path, file, op, got_write,\n\t\t\t\t   need_lookup, opened);\n\t}\n\n\tif (need_lookup) {\n\t\tBUG_ON(dentry->d_inode);\n\n\t\tdentry = lookup_real(dir_inode, dentry, nd->flags);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn PTR_ERR(dentry);\n\t}\n\n\t/* Negative dentry, just create the file */\n\tif (!dentry->d_inode && (op->open_flag & O_CREAT)) {\n\t\tumode_t mode = op->mode;\n\t\tif (!IS_POSIXACL(dir->d_inode))\n\t\t\tmode &= ~current_umask();\n\t\t/*\n\t\t * This write is needed to ensure that a\n\t\t * rw->ro transition does not occur between\n\t\t * the time when the file is created and when\n\t\t * a permanent write count is taken through\n\t\t * the 'struct file' in finish_open().\n\t\t */\n\t\tif (!got_write) {\n\t\t\terror = -EROFS;\n\t\t\tgoto out_dput;\n\t\t}\n\t\t*opened |= FILE_CREATED;\n\t\terror = security_path_mknod(&nd->path, dentry, mode, 0);\n\t\tif (error)\n\t\t\tgoto out_dput;\n\t\terror = vfs_create(dir->d_inode, dentry, mode,\n\t\t\t\t   nd->flags & LOOKUP_EXCL);\n\t\tif (error)\n\t\t\tgoto out_dput;\n\t}\nout_no_open:\n\tpath->dentry = dentry;\n\tpath->mnt = nd->path.mnt;\n\treturn 1;\n\nout_dput:\n\tdput(dentry);\n\treturn error;\n}\n\n/*\n * Handle the last step of open()\n */\nstatic int do_last(struct nameidata *nd, struct path *path,\n\t\t   struct file *file, const struct open_flags *op,\n\t\t   int *opened, struct filename *name)\n{\n\tstruct dentry *dir = nd->path.dentry;\n\tint open_flag = op->open_flag;\n\tbool will_truncate = (open_flag & O_TRUNC) != 0;\n\tbool got_write = false;\n\tint acc_mode = op->acc_mode;\n\tstruct inode *inode;\n\tbool symlink_ok = false;\n\tstruct path save_parent = { .dentry = NULL, .mnt = NULL };\n\tbool retried = false;\n\tint error;\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\tnd->flags |= op->intent;\n\n\tif (nd->last_type != LAST_NORM) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgoto finish_open;\n\t}\n\n\tif (!(open_flag & O_CREAT)) {\n\t\tif (nd->last.name[nd->last.len])\n\t\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\t\tif (open_flag & O_PATH && !(nd->flags & LOOKUP_FOLLOW))\n\t\t\tsymlink_ok = true;\n\t\t/* we _can_ be in RCU mode here */\n\t\terror = lookup_fast(nd, path, &inode);\n\t\tif (likely(!error))\n\t\t\tgoto finish_lookup;\n\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\tBUG_ON(nd->inode != dir->d_inode);\n\t} else {\n\t\t/* create side of things */\n\t\t/*\n\t\t * This will *only* deal with leaving RCU mode - LOOKUP_JUMPED\n\t\t * has been cleared when we got to the last component we are\n\t\t * about to look up\n\t\t */\n\t\terror = complete_walk(nd);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\taudit_inode(name, dir, LOOKUP_PARENT);\n\t\terror = -EISDIR;\n\t\t/* trailing slashes? */\n\t\tif (nd->last.name[nd->last.len])\n\t\t\tgoto out;\n\t}\n\nretry_lookup:\n\tif (op->open_flag & (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) {\n\t\terror = mnt_want_write(nd->path.mnt);\n\t\tif (!error)\n\t\t\tgot_write = true;\n\t\t/*\n\t\t * do _not_ fail yet - we might not need that or fail with\n\t\t * a different error; let lookup_open() decide; we'll be\n\t\t * dropping this one anyway.\n\t\t */\n\t}\n\tmutex_lock(&dir->d_inode->i_mutex);\n\terror = lookup_open(nd, path, file, op, got_write, opened);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tif (error <= 0) {\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif ((*opened & FILE_CREATED) ||\n\t\t    !S_ISREG(file_inode(file)->i_mode))\n\t\t\twill_truncate = false;\n\n\t\taudit_inode(name, file->f_path.dentry, 0);\n\t\tgoto opened;\n\t}\n\n\tif (*opened & FILE_CREATED) {\n\t\t/* Don't check for write permission, don't truncate */\n\t\topen_flag &= ~O_TRUNC;\n\t\twill_truncate = false;\n\t\tacc_mode = MAY_OPEN;\n\t\tpath_to_nameidata(path, nd);\n\t\tgoto finish_open_created;\n\t}\n\n\t/*\n\t * create/update audit record if it already exists.\n\t */\n\tif (d_is_positive(path->dentry))\n\t\taudit_inode(name, path->dentry, 0);\n\n\t/*\n\t * If atomic_open() acquired write access it is dropped now due to\n\t * possible mount and symlink following (this might be optimized away if\n\t * necessary...)\n\t */\n\tif (got_write) {\n\t\tmnt_drop_write(nd->path.mnt);\n\t\tgot_write = false;\n\t}\n\n\terror = -EEXIST;\n\tif ((open_flag & (O_EXCL | O_CREAT)) == (O_EXCL | O_CREAT))\n\t\tgoto exit_dput;\n\n\terror = follow_managed(path, nd->flags);\n\tif (error < 0)\n\t\tgoto exit_dput;\n\n\tif (error)\n\t\tnd->flags |= LOOKUP_JUMPED;\n\n\tBUG_ON(nd->flags & LOOKUP_RCU);\n\tinode = path->dentry->d_inode;\nfinish_lookup:\n\t/* we _can_ be in RCU mode here */\n\terror = -ENOENT;\n\tif (!inode || d_is_negative(path->dentry)) {\n\t\tpath_to_nameidata(path, nd);\n\t\tgoto out;\n\t}\n\n\tif (should_follow_link(path->dentry, !symlink_ok)) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tif (unlikely(unlazy_walk(nd, path->dentry))) {\n\t\t\t\terror = -ECHILD;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(inode != path->dentry->d_inode);\n\t\treturn 1;\n\t}\n\n\tif ((nd->flags & LOOKUP_RCU) || nd->path.mnt != path->mnt) {\n\t\tpath_to_nameidata(path, nd);\n\t} else {\n\t\tsave_parent.dentry = nd->path.dentry;\n\t\tsave_parent.mnt = mntget(path->mnt);\n\t\tnd->path.dentry = path->dentry;\n\n\t}\n\tnd->inode = inode;\n\t/* Why this, you ask?  _Now_ we might have grown LOOKUP_JUMPED... */\nfinish_open:\n\terror = complete_walk(nd);\n\tif (error) {\n\t\tpath_put(&save_parent);\n\t\treturn error;\n\t}\n\taudit_inode(name, nd->path.dentry, 0);\n\terror = -EISDIR;\n\tif ((open_flag & O_CREAT) && d_is_dir(nd->path.dentry))\n\t\tgoto out;\n\terror = -ENOTDIR;\n\tif ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n\t\tgoto out;\n\tif (!S_ISREG(nd->inode->i_mode))\n\t\twill_truncate = false;\n\n\tif (will_truncate) {\n\t\terror = mnt_want_write(nd->path.mnt);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgot_write = true;\n\t}\nfinish_open_created:\n\terror = may_open(&nd->path, acc_mode, open_flag);\n\tif (error)\n\t\tgoto out;\n\tfile->f_path.mnt = nd->path.mnt;\n\terror = finish_open(file, nd->path.dentry, NULL, opened);\n\tif (error) {\n\t\tif (error == -EOPENSTALE)\n\t\t\tgoto stale_open;\n\t\tgoto out;\n\t}\nopened:\n\terror = open_check_o_direct(file);\n\tif (error)\n\t\tgoto exit_fput;\n\terror = ima_file_check(file, op->acc_mode);\n\tif (error)\n\t\tgoto exit_fput;\n\n\tif (will_truncate) {\n\t\terror = handle_truncate(file);\n\t\tif (error)\n\t\t\tgoto exit_fput;\n\t}\nout:\n\tif (got_write)\n\t\tmnt_drop_write(nd->path.mnt);\n\tpath_put(&save_parent);\n\tterminate_walk(nd);\n\treturn error;\n\nexit_dput:\n\tpath_put_conditional(path, nd);\n\tgoto out;\nexit_fput:\n\tfput(file);\n\tgoto out;\n\nstale_open:\n\t/* If no saved parent or already retried then can't retry */\n\tif (!save_parent.dentry || retried)\n\t\tgoto out;\n\n\tBUG_ON(save_parent.dentry != dir);\n\tpath_put(&nd->path);\n\tnd->path = save_parent;\n\tnd->inode = dir->d_inode;\n\tsave_parent.mnt = NULL;\n\tsave_parent.dentry = NULL;\n\tif (got_write) {\n\t\tmnt_drop_write(nd->path.mnt);\n\t\tgot_write = false;\n\t}\n\tretried = true;\n\tgoto retry_lookup;\n}\n\nstatic int do_tmpfile(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, int flags,\n\t\tconst struct open_flags *op,\n\t\tstruct file *file, int *opened)\n{\n\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\tstruct dentry *dentry, *child;\n\tstruct inode *dir;\n\tint error = path_lookupat(dfd, pathname->name,\n\t\t\t\t  flags | LOOKUP_DIRECTORY, nd);\n\tif (unlikely(error))\n\t\treturn error;\n\terror = mnt_want_write(nd->path.mnt);\n\tif (unlikely(error))\n\t\tgoto out;\n\t/* we want directory to be writable */\n\terror = inode_permission(nd->inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\tgoto out2;\n\tdentry = nd->path.dentry;\n\tdir = dentry->d_inode;\n\tif (!dir->i_op->tmpfile) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out2;\n\t}\n\tchild = d_alloc(dentry, &name);\n\tif (unlikely(!child)) {\n\t\terror = -ENOMEM;\n\t\tgoto out2;\n\t}\n\tnd->flags &= ~LOOKUP_DIRECTORY;\n\tnd->flags |= op->intent;\n\tdput(nd->path.dentry);\n\tnd->path.dentry = child;\n\terror = dir->i_op->tmpfile(dir, nd->path.dentry, op->mode);\n\tif (error)\n\t\tgoto out2;\n\taudit_inode(pathname, nd->path.dentry, 0);\n\terror = may_open(&nd->path, op->acc_mode, op->open_flag);\n\tif (error)\n\t\tgoto out2;\n\tfile->f_path.mnt = nd->path.mnt;\n\terror = finish_open(file, nd->path.dentry, NULL, opened);\n\tif (error)\n\t\tgoto out2;\n\terror = open_check_o_direct(file);\n\tif (error) {\n\t\tfput(file);\n\t} else if (!(op->open_flag & O_EXCL)) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state |= I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\nout2:\n\tmnt_drop_write(nd->path.mnt);\nout:\n\tpath_put(&nd->path);\n\treturn error;\n}\n\nstatic struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *base = NULL;\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_flags = op->open_flag;\n\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n\t}\n\n\terror = path_init(dfd, pathname->name, flags | LOOKUP_PARENT, nd, &base);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tcurrent->total_link_count = 0;\n\terror = link_path_walk(pathname->name, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { /* trailing symlink */\n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n\t}\nout:\n\tif (nd->root.mnt && !(nd->flags & LOOKUP_ROOT))\n\t\tpath_put(&nd->root);\n\tif (base)\n\t\tfput(base);\n\tif (!(opened & FILE_OPENED)) {\n\t\tBUG_ON(!error);\n\t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}\n\nstruct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_REVAL);\n\treturn filp;\n}\n\nstruct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename filename = { .name = name };\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\n\tif (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\n\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_REVAL);\n\treturn file;\n}\n\nstruct dentry *kern_path_create(int dfd, const char *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\tstruct dentry *dentry = ERR_PTR(-EEXIST);\n\tstruct nameidata nd;\n\tint err2;\n\tint error;\n\tbool is_dir = (lookup_flags & LOOKUP_DIRECTORY);\n\n\t/*\n\t * Note that only LOOKUP_REVAL and LOOKUP_DIRECTORY matter here. Any\n\t * other flags passed in are ignored!\n\t */\n\tlookup_flags &= LOOKUP_REVAL;\n\n\terror = do_path_lookup(dfd, pathname, LOOKUP_PARENT|lookup_flags, &nd);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/*\n\t * Yucky last component or no last component at all?\n\t * (foo/., foo/.., /////)\n\t */\n\tif (nd.last_type != LAST_NORM)\n\t\tgoto out;\n\tnd.flags &= ~LOOKUP_PARENT;\n\tnd.flags |= LOOKUP_CREATE | LOOKUP_EXCL;\n\n\t/* don't fail immediately if it's r/o, at least try to report other errors */\n\terr2 = mnt_want_write(nd.path.mnt);\n\t/*\n\t * Do the final lookup.\n\t */\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_hash(&nd);\n\tif (IS_ERR(dentry))\n\t\tgoto unlock;\n\n\terror = -EEXIST;\n\tif (d_is_positive(dentry))\n\t\tgoto fail;\n\n\t/*\n\t * Special case - lookup gave negative, but... we had foo/bar/\n\t * From the vfs_mknod() POV we just have a negative dentry -\n\t * all is fine. Let's be bastards - you had / on the end, you've\n\t * been asking for (non-existent) directory. -ENOENT for you.\n\t */\n\tif (unlikely(!is_dir && nd.last.name[nd.last.len])) {\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\tif (unlikely(err2)) {\n\t\terror = err2;\n\t\tgoto fail;\n\t}\n\t*path = nd.path;\n\treturn dentry;\nfail:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nunlock:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tif (!err2)\n\t\tmnt_drop_write(nd.path.mnt);\nout:\n\tpath_put(&nd.path);\n\treturn dentry;\n}\nEXPORT_SYMBOL(kern_path_create);\n\nvoid done_path_create(struct path *path, struct dentry *dentry)\n{\n\tdput(dentry);\n\tmutex_unlock(&path->dentry->d_inode->i_mutex);\n\tmnt_drop_write(path->mnt);\n\tpath_put(path);\n}\nEXPORT_SYMBOL(done_path_create);\n\nstruct dentry *user_path_create(int dfd, const char __user *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\tstruct filename *tmp = getname(pathname);\n\tstruct dentry *res;\n\tif (IS_ERR(tmp))\n\t\treturn ERR_CAST(tmp);\n\tres = kern_path_create(dfd, tmp->name, path, lookup_flags);\n\tputname(tmp);\n\treturn res;\n}\nEXPORT_SYMBOL(user_path_create);\n\nint vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mknod);\n\nstatic int may_mknod(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\tcase 0: /* zero mode translates to S_IFREG */\n\t\treturn 0;\n\tcase S_IFDIR:\n\t\treturn -EPERM;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nSYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,\n\t\tunsigned, dev)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = 0;\n\n\terror = may_mknod(mode);\n\tif (error)\n\t\treturn error;\nretry:\n\tdentry = user_path_create(dfd, filename, &path, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!IS_POSIXACL(path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mknod(&path, dentry, mode, dev);\n\tif (error)\n\t\tgoto out;\n\tswitch (mode & S_IFMT) {\n\t\tcase 0: case S_IFREG:\n\t\t\terror = vfs_create(path.dentry->d_inode,dentry,mode,true);\n\t\t\tbreak;\n\t\tcase S_IFCHR: case S_IFBLK:\n\t\t\terror = vfs_mknod(path.dentry->d_inode,dentry,mode,\n\t\t\t\t\tnew_decode_dev(dev));\n\t\t\tbreak;\n\t\tcase S_IFIFO: case S_IFSOCK:\n\t\t\terror = vfs_mknod(path.dentry->d_inode,dentry,mode,0);\n\t\t\tbreak;\n\t}\nout:\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)\n{\n\treturn sys_mknodat(AT_FDCWD, filename, mode, dev);\n}\n\nint vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mkdir);\n\nSYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_DIRECTORY;\n\nretry:\n\tdentry = user_path_create(dfd, pathname, &path, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!IS_POSIXACL(path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mkdir(&path, dentry, mode);\n\tif (!error)\n\t\terror = vfs_mkdir(path.dentry->d_inode, dentry, mode);\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)\n{\n\treturn sys_mkdirat(AT_FDCWD, pathname, mode);\n}\n\n/*\n * The dentry_unhash() helper will try to drop the dentry early: we\n * should have a usage count of 1 if we're the only user of this\n * dentry, and if that is true (possibly after pruning the dcache),\n * then we drop the dentry now.\n *\n * A low-level filesystem can, if it choses, legally\n * do a\n *\n *\tif (!d_unhashed(dentry))\n *\t\treturn -EBUSY;\n *\n * if it cannot handle the case of removing a directory\n * that is still in use by something else..\n */\nvoid dentry_unhash(struct dentry *dentry)\n{\n\tshrink_dcache_parent(dentry);\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_lockref.count == 1)\n\t\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}\nEXPORT_SYMBOL(dentry_unhash);\n\nint vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (d_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_rmdir);\n\nstatic long do_rmdir(int dfd, const char __user *pathname)\n{\n\tint error = 0;\n\tstruct filename *name;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\tunsigned int lookup_flags = 0;\nretry:\n\tname = user_path_parent(dfd, pathname, &nd, lookup_flags);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\tswitch(nd.last_type) {\n\tcase LAST_DOTDOT:\n\t\terror = -ENOTEMPTY;\n\t\tgoto exit1;\n\tcase LAST_DOT:\n\t\terror = -EINVAL;\n\t\tgoto exit1;\n\tcase LAST_ROOT:\n\t\terror = -EBUSY;\n\t\tgoto exit1;\n\t}\n\n\tnd.flags &= ~LOOKUP_PARENT;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto exit1;\n\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_hash(&nd);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto exit2;\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto exit3;\n\t}\n\terror = security_path_rmdir(&nd.path, dentry);\n\tif (error)\n\t\tgoto exit3;\n\terror = vfs_rmdir(nd.path.dentry->d_inode, dentry);\nexit3:\n\tdput(dentry);\nexit2:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tmnt_drop_write(nd.path.mnt);\nexit1:\n\tpath_put(&nd.path);\n\tputname(name);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE1(rmdir, const char __user *, pathname)\n{\n\treturn do_rmdir(AT_FDCWD, pathname);\n}\n\n/**\n * vfs_unlink - unlink a filesystem object\n * @dir:\tparent directory\n * @dentry:\tvictim\n * @delegated_inode: returns victim inode, if the inode is delegated.\n *\n * The caller must hold dir->i_mutex.\n *\n * If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and\n * return a reference to the inode in delegated_inode.  The caller\n * should then break the delegation on that inode and retry.  Because\n * breaking a delegation may take a long time, the caller should drop\n * dir->i_mutex before doing so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n */\nint vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (d_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error)\n\t\t\t\tdont_mount(dentry);\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_unlink);\n\n/*\n * Make sure that the actual truncation of the file will occur outside its\n * directory's i_mutex.  Truncate can take a long time if there is a lot of\n * writeout happening, and we don't want to prevent access to the directory\n * while waiting on the I/O.\n */\nstatic long do_unlinkat(int dfd, const char __user *pathname)\n{\n\tint error;\n\tstruct filename *name;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\tstruct inode *inode = NULL;\n\tstruct inode *delegated_inode = NULL;\n\tunsigned int lookup_flags = 0;\nretry:\n\tname = user_path_parent(dfd, pathname, &nd, lookup_flags);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\terror = -EISDIR;\n\tif (nd.last_type != LAST_NORM)\n\t\tgoto exit1;\n\n\tnd.flags &= ~LOOKUP_PARENT;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto exit1;\nretry_deleg:\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_hash(&nd);\n\terror = PTR_ERR(dentry);\n\tif (!IS_ERR(dentry)) {\n\t\t/* Why not before? Because we want correct error value */\n\t\tif (nd.last.name[nd.last.len])\n\t\t\tgoto slashes;\n\t\tinode = dentry->d_inode;\n\t\tif (d_is_negative(dentry))\n\t\t\tgoto slashes;\n\t\tihold(inode);\n\t\terror = security_path_unlink(&nd.path, dentry);\n\t\tif (error)\n\t\t\tgoto exit2;\n\t\terror = vfs_unlink(nd.path.dentry->d_inode, dentry, &delegated_inode);\nexit2:\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tif (inode)\n\t\tiput(inode);\t/* truncate the inode here */\n\tinode = NULL;\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(nd.path.mnt);\nexit1:\n\tpath_put(&nd.path);\n\tputname(name);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tinode = NULL;\n\t\tgoto retry;\n\t}\n\treturn error;\n\nslashes:\n\tif (d_is_negative(dentry))\n\t\terror = -ENOENT;\n\telse if (d_is_dir(dentry))\n\t\terror = -EISDIR;\n\telse\n\t\terror = -ENOTDIR;\n\tgoto exit2;\n}\n\nSYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)\n{\n\tif ((flag & ~AT_REMOVEDIR) != 0)\n\t\treturn -EINVAL;\n\n\tif (flag & AT_REMOVEDIR)\n\t\treturn do_rmdir(dfd, pathname);\n\n\treturn do_unlinkat(dfd, pathname);\n}\n\nSYSCALL_DEFINE1(unlink, const char __user *, pathname)\n{\n\treturn do_unlinkat(AT_FDCWD, pathname);\n}\n\nint vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->symlink)\n\t\treturn -EPERM;\n\n\terror = security_inode_symlink(dir, dentry, oldname);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->symlink(dir, dentry, oldname);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_symlink);\n\nSYSCALL_DEFINE3(symlinkat, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\tint error;\n\tstruct filename *from;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tunsigned int lookup_flags = 0;\n\n\tfrom = getname(oldname);\n\tif (IS_ERR(from))\n\t\treturn PTR_ERR(from);\nretry:\n\tdentry = user_path_create(newdfd, newname, &path, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_putname;\n\n\terror = security_path_symlink(&path, dentry, from->name);\n\tif (!error)\n\t\terror = vfs_symlink(path.dentry->d_inode, dentry, from->name);\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout_putname:\n\tputname(from);\n\treturn error;\n}\n\nSYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_symlinkat(oldname, AT_FDCWD, newname);\n}\n\n/**\n * vfs_link - create a new link\n * @old_dentry:\tobject to be linked\n * @dir:\tnew parent\n * @new_dentry:\twhere to create the new link\n * @delegated_inode: returns inode needing a delegation break\n *\n * The caller must hold dir->i_mutex\n *\n * If vfs_link discovers a delegation on the to-be-linked file in need\n * of breaking, it will return -EWOULDBLOCK and return a reference to the\n * inode in delegated_inode.  The caller should then break the delegation\n * and retry.  Because breaking a delegation may take a long time, the\n * caller should drop the i_mutex before doing so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n */\nint vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tunsigned max_links = dir->i_sb->s_max_links;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A link to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\tif (!dir->i_op->link)\n\t\treturn -EPERM;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = security_inode_link(old_dentry, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\t/* Make sure we don't allow creating hardlink to an unlinked file */\n\tif (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))\n\t\terror =  -ENOENT;\n\telse if (max_links && inode->i_nlink >= max_links)\n\t\terror = -EMLINK;\n\telse {\n\t\terror = try_break_deleg(inode, delegated_inode);\n\t\tif (!error)\n\t\t\terror = dir->i_op->link(old_dentry, dir, new_dentry);\n\t}\n\n\tif (!error && (inode->i_state & I_LINKABLE)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (!error)\n\t\tfsnotify_link(dir, inode, new_dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_link);\n\n/*\n * Hardlinks are often used in delicate situations.  We avoid\n * security-related surprises by not following symlinks on the\n * newname.  --KAB\n *\n * We don't follow them on the oldname either to be compatible\n * with linux 2.0, and to avoid hard-linking to directories\n * and other special files.  --ADM\n */\nSYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, int, flags)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tstruct inode *delegated_inode = NULL;\n\tint how = 0;\n\tint error;\n\n\tif ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn -EINVAL;\n\t/*\n\t * To use null names we require CAP_DAC_READ_SEARCH\n\t * This ensures that not everyone will be able to create\n\t * handlink using the passed filedescriptor.\n\t */\n\tif (flags & AT_EMPTY_PATH) {\n\t\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\t\treturn -ENOENT;\n\t\thow = LOOKUP_EMPTY;\n\t}\n\n\tif (flags & AT_SYMLINK_FOLLOW)\n\t\thow |= LOOKUP_FOLLOW;\nretry:\n\terror = user_path_at(olddfd, oldname, how, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tnew_dentry = user_path_create(newdfd, newname, &new_path,\n\t\t\t\t\t(how & LOOKUP_REVAL));\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out;\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto out_dput;\n\terror = may_linkat(&old_path);\n\tif (unlikely(error))\n\t\tgoto out_dput;\n\terror = security_path_link(old_path.dentry, &new_path, new_dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error) {\n\t\t\tpath_put(&old_path);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (retry_estale(error, how)) {\n\t\tpath_put(&old_path);\n\t\thow |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}\n\n/**\n * vfs_rename - rename a filesystem object\n * @old_dir:\tparent of source\n * @old_dentry:\tsource\n * @new_dir:\tparent of destination\n * @new_dentry:\tdestination\n * @delegated_inode: returns an inode needing a delegation break\n * @flags:\trename flags\n *\n * The caller must hold multiple mutexes--see lock_rename()).\n *\n * If vfs_rename discovers a delegation in need of breaking at either\n * the source or destination, it will return -EWOULDBLOCK and return a\n * reference to the inode in delegated_inode.  The caller should then\n * break the delegation and retry.  Because breaking a delegation may\n * take a long time, the caller should drop all locks before doing\n * so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n *\n * The worst of all namespace operations - renaming directory. \"Perverted\"\n * doesn't even start to describe it. Somebody in UCB had a heck of a trip...\n * Problems:\n *\ta) we can get into loop creation. Check is done in is_subdir().\n *\tb) race potential - two innocent renames can create a loop together.\n *\t   That's where 4.4 screws up. Current fix: serialization on\n *\t   sb->s_vfs_rename_mutex. We might be more accurate, but that's another\n *\t   story.\n *\tc) we have to lock _four_ objects - parents and victim (if it exists),\n *\t   and source (if it is not a directory).\n *\t   And that - after we got ->i_mutex on parents (until then we don't know\n *\t   whether the target exists).  Solution: try to be smart with locking\n *\t   order for inodes.  We rely on the fact that tree topology may change\n *\t   only under ->s_vfs_rename_mutex _and_ that parent of the object we\n *\t   move will be locked.  Thus we can rank directories by the tree\n *\t   (ancestors first) and rank all non-directories after them.\n *\t   That works since everybody except rename does \"lock parent, lookup,\n *\t   lock child\" and rename is under ->s_vfs_rename_mutex.\n *\t   HOWEVER, it relies on the assumption that any object with ->lookup()\n *\t   has no more than 1 dentry.  If \"hybrid\" objects will ever appear,\n *\t   we'd better make sure that there's no link(2) for them.\n *\td) conversion from fhandle to dentry may come in the wrong moment - when\n *\t   we are removing the target. Solution: we will have to grab ->i_mutex\n *\t   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on\n *\t   ->i_mutex on parents, which works but leads to some truly excessive\n *\t   locking].\n */\nint vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_lock(&target->i_mutex);\n\n\terror = -EBUSY;\n\tif (d_mountpoint(old_dentry) || d_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!flags) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tmutex_unlock(&target->i_mutex);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_rename);\n\nSYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, unsigned int, flags)\n{\n\tstruct dentry *old_dir, *new_dir;\n\tstruct dentry *old_dentry, *new_dentry;\n\tstruct dentry *trap;\n\tstruct nameidata oldnd, newnd;\n\tstruct inode *delegated_inode = NULL;\n\tstruct filename *from;\n\tstruct filename *to;\n\tunsigned int lookup_flags = 0;\n\tbool should_retry = false;\n\tint error;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tif ((flags & RENAME_NOREPLACE) && (flags & RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\nretry:\n\tfrom = user_path_parent(olddfd, oldname, &oldnd, lookup_flags);\n\tif (IS_ERR(from)) {\n\t\terror = PTR_ERR(from);\n\t\tgoto exit;\n\t}\n\n\tto = user_path_parent(newdfd, newname, &newnd, lookup_flags);\n\tif (IS_ERR(to)) {\n\t\terror = PTR_ERR(to);\n\t\tgoto exit1;\n\t}\n\n\terror = -EXDEV;\n\tif (oldnd.path.mnt != newnd.path.mnt)\n\t\tgoto exit2;\n\n\told_dir = oldnd.path.dentry;\n\terror = -EBUSY;\n\tif (oldnd.last_type != LAST_NORM)\n\t\tgoto exit2;\n\n\tnew_dir = newnd.path.dentry;\n\tif (flags & RENAME_NOREPLACE)\n\t\terror = -EEXIST;\n\tif (newnd.last_type != LAST_NORM)\n\t\tgoto exit2;\n\n\terror = mnt_want_write(oldnd.path.mnt);\n\tif (error)\n\t\tgoto exit2;\n\n\toldnd.flags &= ~LOOKUP_PARENT;\n\tnewnd.flags &= ~LOOKUP_PARENT;\n\tif (!(flags & RENAME_EXCHANGE))\n\t\tnewnd.flags |= LOOKUP_RENAME_TARGET;\n\nretry_deleg:\n\ttrap = lock_rename(new_dir, old_dir);\n\n\told_dentry = lookup_hash(&oldnd);\n\terror = PTR_ERR(old_dentry);\n\tif (IS_ERR(old_dentry))\n\t\tgoto exit3;\n\t/* source must exist */\n\terror = -ENOENT;\n\tif (d_is_negative(old_dentry))\n\t\tgoto exit4;\n\tnew_dentry = lookup_hash(&newnd);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto exit4;\n\terror = -EEXIST;\n\tif ((flags & RENAME_NOREPLACE) && d_is_positive(new_dentry))\n\t\tgoto exit5;\n\tif (flags & RENAME_EXCHANGE) {\n\t\terror = -ENOENT;\n\t\tif (d_is_negative(new_dentry))\n\t\t\tgoto exit5;\n\n\t\tif (!d_is_dir(new_dentry)) {\n\t\t\terror = -ENOTDIR;\n\t\t\tif (newnd.last.name[newnd.last.len])\n\t\t\t\tgoto exit5;\n\t\t}\n\t}\n\t/* unless the source is a directory trailing slashes give -ENOTDIR */\n\tif (!d_is_dir(old_dentry)) {\n\t\terror = -ENOTDIR;\n\t\tif (oldnd.last.name[oldnd.last.len])\n\t\t\tgoto exit5;\n\t\tif (!(flags & RENAME_EXCHANGE) && newnd.last.name[newnd.last.len])\n\t\t\tgoto exit5;\n\t}\n\t/* source should not be ancestor of target */\n\terror = -EINVAL;\n\tif (old_dentry == trap)\n\t\tgoto exit5;\n\t/* target should not be an ancestor of source */\n\tif (!(flags & RENAME_EXCHANGE))\n\t\terror = -ENOTEMPTY;\n\tif (new_dentry == trap)\n\t\tgoto exit5;\n\n\terror = security_path_rename(&oldnd.path, old_dentry,\n\t\t\t\t     &newnd.path, new_dentry, flags);\n\tif (error)\n\t\tgoto exit5;\n\terror = vfs_rename(old_dir->d_inode, old_dentry,\n\t\t\t   new_dir->d_inode, new_dentry,\n\t\t\t   &delegated_inode, flags);\nexit5:\n\tdput(new_dentry);\nexit4:\n\tdput(old_dentry);\nexit3:\n\tunlock_rename(new_dir, old_dir);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(oldnd.path.mnt);\nexit2:\n\tif (retry_estale(error, lookup_flags))\n\t\tshould_retry = true;\n\tpath_put(&newnd.path);\n\tputname(to);\nexit1:\n\tpath_put(&oldnd.path);\n\tputname(from);\n\tif (should_retry) {\n\t\tshould_retry = false;\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nexit:\n\treturn error;\n}\n\nSYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\treturn sys_renameat2(olddfd, oldname, newdfd, newname, 0);\n}\n\nSYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}\n\nint readlink_copy(char __user *buffer, int buflen, const char *link)\n{\n\tint len = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}\nEXPORT_SYMBOL(readlink_copy);\n\n/*\n * A helper for ->readlink().  This should be used *ONLY* for symlinks that\n * have ->follow_link() touching nd only in nd_set_link().  Using (or not\n * using) it for any given inode is up to filesystem.\n */\nint generic_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct nameidata nd;\n\tvoid *cookie;\n\tint res;\n\n\tnd.depth = 0;\n\tcookie = dentry->d_inode->i_op->follow_link(dentry, &nd);\n\tif (IS_ERR(cookie))\n\t\treturn PTR_ERR(cookie);\n\n\tres = readlink_copy(buffer, buflen, nd_get_link(&nd));\n\tif (dentry->d_inode->i_op->put_link)\n\t\tdentry->d_inode->i_op->put_link(dentry, &nd, cookie);\n\treturn res;\n}\nEXPORT_SYMBOL(generic_readlink);\n\n/* get the link contents into pagecache */\nstatic char *page_getlink(struct dentry * dentry, struct page **ppage)\n{\n\tchar *kaddr;\n\tstruct page *page;\n\tstruct address_space *mapping = dentry->d_inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\treturn (char*)page;\n\t*ppage = page;\n\tkaddr = kmap(page);\n\tnd_terminate_link(kaddr, dentry->d_inode->i_size, PAGE_SIZE - 1);\n\treturn kaddr;\n}\n\nint page_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct page *page = NULL;\n\tint res = readlink_copy(buffer, buflen, page_getlink(dentry, &page));\n\tif (page) {\n\t\tkunmap(page);\n\t\tpage_cache_release(page);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(page_readlink);\n\nvoid *page_follow_link_light(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct page *page = NULL;\n\tnd_set_link(nd, page_getlink(dentry, &page));\n\treturn page;\n}\nEXPORT_SYMBOL(page_follow_link_light);\n\nvoid page_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)\n{\n\tstruct page *page = cookie;\n\n\tif (page) {\n\t\tkunmap(page);\n\t\tpage_cache_release(page);\n\t}\n}\nEXPORT_SYMBOL(page_put_link);\n\n/*\n * The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS\n */\nint __page_symlink(struct inode *inode, const char *symname, int len, int nofs)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\tchar *kaddr;\n\tunsigned int flags = AOP_FLAG_UNINTERRUPTIBLE;\n\tif (nofs)\n\t\tflags |= AOP_FLAG_NOFS;\n\nretry:\n\terr = pagecache_write_begin(NULL, mapping, 0, len-1,\n\t\t\t\tflags, &page, &fsdata);\n\tif (err)\n\t\tgoto fail;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr, symname, len-1);\n\tkunmap_atomic(kaddr);\n\n\terr = pagecache_write_end(NULL, mapping, 0, len-1, len-1,\n\t\t\t\t\t\t\tpage, fsdata);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err < len-1)\n\t\tgoto retry;\n\n\tmark_inode_dirty(inode);\n\treturn 0;\nfail:\n\treturn err;\n}\nEXPORT_SYMBOL(__page_symlink);\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}\nEXPORT_SYMBOL(page_symlink);\n\nconst struct inode_operations page_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n};\nEXPORT_SYMBOL(page_symlink_inode_operations);\n"], "buggy_code_start_loc": [2259], "buggy_code_end_loc": [2261], "fixing_code_start_loc": [2259], "fixing_code_end_loc": [2263], "type": "CWE-59", "message": "The mountpoint_last function in fs/namei.c in the Linux kernel before 3.15.8 does not properly maintain a certain reference count during attempts to use the umount system call in conjunction with a symlink, which allows local users to cause a denial of service (memory consumption or use-after-free) or possibly have unspecified other impact via the umount program.", "other": {"cve": {"id": "CVE-2014-5045", "sourceIdentifier": "cve@mitre.org", "published": "2014-08-01T11:13:09.460", "lastModified": "2020-08-14T18:11:12.670", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The mountpoint_last function in fs/namei.c in the Linux kernel before 3.15.8 does not properly maintain a certain reference count during attempts to use the umount system call in conjunction with a symlink, which allows local users to cause a denial of service (memory consumption or use-after-free) or possibly have unspecified other impact via the umount program."}, {"lang": "es", "value": "La funci\u00f3n mountpoint_last en fs/namei.c en el kernel de Linux anterior a 3.15.8 no mantiene debidamente cierta cuenta de referencias durante intentos de utilizar la llamada al sistema umount en conjunto con un enlace simb\u00f3lico, lo que permite a usuarios locales causar una denegaci\u00f3n de servicio (consumo de memoria o uso despu\u00e9s de liberaci\u00f3n) o posiblemente tener otro impacto no especificado a trav\u00e9s del programa umount."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 1.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.15.8", "matchCriteriaId": "6505A94B-8DAC-4406-BBB0-12893B537922"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:6.5:*:*:*:*:*:*:*", "matchCriteriaId": "569964DA-31BE-4520-A66D-C3B09D557AB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.5:*:*:*:*:*:*:*", "matchCriteriaId": "1F3BEFDB-5156-4E1C-80BB-8BE9FEAA7623"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:6.5:*:*:*:*:*:*:*", "matchCriteriaId": "835AE071-CEAE-49E5-8F0C-E5F50FB85EFC"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=295dc39d941dc2ae53d5c170365af4c9d5c16212", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0062.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/60353", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.15.8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/07/24/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/68862", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1122472", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212"}}