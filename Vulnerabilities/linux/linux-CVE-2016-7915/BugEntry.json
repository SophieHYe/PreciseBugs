{"buggy_code": ["/*\n *  HID support for Linux\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2012 Jiri Kosina\n */\n\n/*\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/input.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/sched.h>\n#include <linux/semaphore.h>\n\n#include <linux/hid.h>\n#include <linux/hiddev.h>\n#include <linux/hid-debug.h>\n#include <linux/hidraw.h>\n\n#include \"hid-ids.h\"\n\n/*\n * Version Information\n */\n\n#define DRIVER_DESC \"HID core driver\"\n#define DRIVER_LICENSE \"GPL\"\n\nint hid_debug = 0;\nmodule_param_named(debug, hid_debug, int, 0600);\nMODULE_PARM_DESC(debug, \"toggle HID debugging messages\");\nEXPORT_SYMBOL_GPL(hid_debug);\n\nstatic int hid_ignore_special_drivers = 0;\nmodule_param_named(ignore_special_drivers, hid_ignore_special_drivers, int, 0600);\nMODULE_PARM_DESC(ignore_special_drivers, \"Ignore any special drivers and handle all devices by generic driver\");\n\n/*\n * Register a new report for a device.\n */\n\nstruct hid_report *hid_register_report(struct hid_device *device, unsigned type, unsigned id)\n{\n\tstruct hid_report_enum *report_enum = device->report_enum + type;\n\tstruct hid_report *report;\n\n\tif (id >= HID_MAX_IDS)\n\t\treturn NULL;\n\tif (report_enum->report_id_hash[id])\n\t\treturn report_enum->report_id_hash[id];\n\n\treport = kzalloc(sizeof(struct hid_report), GFP_KERNEL);\n\tif (!report)\n\t\treturn NULL;\n\n\tif (id != 0)\n\t\treport_enum->numbered = 1;\n\n\treport->id = id;\n\treport->type = type;\n\treport->size = 0;\n\treport->device = device;\n\treport_enum->report_id_hash[id] = report;\n\n\tlist_add_tail(&report->list, &report_enum->report_list);\n\n\treturn report;\n}\nEXPORT_SYMBOL_GPL(hid_register_report);\n\n/*\n * Register a new field for this report.\n */\n\nstatic struct hid_field *hid_register_field(struct hid_report *report, unsigned usages, unsigned values)\n{\n\tstruct hid_field *field;\n\n\tif (report->maxfield == HID_MAX_FIELDS) {\n\t\thid_err(report->device, \"too many fields in report\\n\");\n\t\treturn NULL;\n\t}\n\n\tfield = kzalloc((sizeof(struct hid_field) +\n\t\t\t usages * sizeof(struct hid_usage) +\n\t\t\t values * sizeof(unsigned)), GFP_KERNEL);\n\tif (!field)\n\t\treturn NULL;\n\n\tfield->index = report->maxfield++;\n\treport->field[field->index] = field;\n\tfield->usage = (struct hid_usage *)(field + 1);\n\tfield->value = (s32 *)(field->usage + usages);\n\tfield->report = report;\n\n\treturn field;\n}\n\n/*\n * Open a collection. The type/usage is pushed on the stack.\n */\n\nstatic int open_collection(struct hid_parser *parser, unsigned type)\n{\n\tstruct hid_collection *collection;\n\tunsigned usage;\n\n\tusage = parser->local.usage[0];\n\n\tif (parser->collection_stack_ptr == HID_COLLECTION_STACK_SIZE) {\n\t\thid_err(parser->device, \"collection stack overflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (parser->device->maxcollection == parser->device->collection_size) {\n\t\tcollection = kmalloc(sizeof(struct hid_collection) *\n\t\t\t\tparser->device->collection_size * 2, GFP_KERNEL);\n\t\tif (collection == NULL) {\n\t\t\thid_err(parser->device, \"failed to reallocate collection array\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(collection, parser->device->collection,\n\t\t\tsizeof(struct hid_collection) *\n\t\t\tparser->device->collection_size);\n\t\tmemset(collection + parser->device->collection_size, 0,\n\t\t\tsizeof(struct hid_collection) *\n\t\t\tparser->device->collection_size);\n\t\tkfree(parser->device->collection);\n\t\tparser->device->collection = collection;\n\t\tparser->device->collection_size *= 2;\n\t}\n\n\tparser->collection_stack[parser->collection_stack_ptr++] =\n\t\tparser->device->maxcollection;\n\n\tcollection = parser->device->collection +\n\t\tparser->device->maxcollection++;\n\tcollection->type = type;\n\tcollection->usage = usage;\n\tcollection->level = parser->collection_stack_ptr - 1;\n\n\tif (type == HID_COLLECTION_APPLICATION)\n\t\tparser->device->maxapplication++;\n\n\treturn 0;\n}\n\n/*\n * Close a collection.\n */\n\nstatic int close_collection(struct hid_parser *parser)\n{\n\tif (!parser->collection_stack_ptr) {\n\t\thid_err(parser->device, \"collection stack underflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\tparser->collection_stack_ptr--;\n\treturn 0;\n}\n\n/*\n * Climb up the stack, search for the specified collection type\n * and return the usage.\n */\n\nstatic unsigned hid_lookup_collection(struct hid_parser *parser, unsigned type)\n{\n\tstruct hid_collection *collection = parser->device->collection;\n\tint n;\n\n\tfor (n = parser->collection_stack_ptr - 1; n >= 0; n--) {\n\t\tunsigned index = parser->collection_stack[n];\n\t\tif (collection[index].type == type)\n\t\t\treturn collection[index].usage;\n\t}\n\treturn 0; /* we know nothing about this usage type */\n}\n\n/*\n * Add a usage to the temporary parser table.\n */\n\nstatic int hid_add_usage(struct hid_parser *parser, unsigned usage)\n{\n\tif (parser->local.usage_index >= HID_MAX_USAGES) {\n\t\thid_err(parser->device, \"usage index exceeded\\n\");\n\t\treturn -1;\n\t}\n\tparser->local.usage[parser->local.usage_index] = usage;\n\tparser->local.collection_index[parser->local.usage_index] =\n\t\tparser->collection_stack_ptr ?\n\t\tparser->collection_stack[parser->collection_stack_ptr - 1] : 0;\n\tparser->local.usage_index++;\n\treturn 0;\n}\n\n/*\n * Register a new field for this report.\n */\n\nstatic int hid_add_field(struct hid_parser *parser, unsigned report_type, unsigned flags)\n{\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tunsigned usages;\n\tunsigned offset;\n\tunsigned i;\n\n\treport = hid_register_report(parser->device, report_type, parser->global.report_id);\n\tif (!report) {\n\t\thid_err(parser->device, \"hid_register_report failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Handle both signed and unsigned cases properly */\n\tif ((parser->global.logical_minimum < 0 &&\n\t\tparser->global.logical_maximum <\n\t\tparser->global.logical_minimum) ||\n\t\t(parser->global.logical_minimum >= 0 &&\n\t\t(__u32)parser->global.logical_maximum <\n\t\t(__u32)parser->global.logical_minimum)) {\n\t\tdbg_hid(\"logical range invalid 0x%x 0x%x\\n\",\n\t\t\tparser->global.logical_minimum,\n\t\t\tparser->global.logical_maximum);\n\t\treturn -1;\n\t}\n\n\toffset = report->size;\n\treport->size += parser->global.report_size * parser->global.report_count;\n\n\tif (!parser->local.usage_index) /* Ignore padding fields */\n\t\treturn 0;\n\n\tusages = max_t(unsigned, parser->local.usage_index,\n\t\t\t\t parser->global.report_count);\n\n\tfield = hid_register_field(report, usages, parser->global.report_count);\n\tif (!field)\n\t\treturn 0;\n\n\tfield->physical = hid_lookup_collection(parser, HID_COLLECTION_PHYSICAL);\n\tfield->logical = hid_lookup_collection(parser, HID_COLLECTION_LOGICAL);\n\tfield->application = hid_lookup_collection(parser, HID_COLLECTION_APPLICATION);\n\n\tfor (i = 0; i < usages; i++) {\n\t\tunsigned j = i;\n\t\t/* Duplicate the last usage we parsed if we have excess values */\n\t\tif (i >= parser->local.usage_index)\n\t\t\tj = parser->local.usage_index - 1;\n\t\tfield->usage[i].hid = parser->local.usage[j];\n\t\tfield->usage[i].collection_index =\n\t\t\tparser->local.collection_index[j];\n\t\tfield->usage[i].usage_index = i;\n\t}\n\n\tfield->maxusage = usages;\n\tfield->flags = flags;\n\tfield->report_offset = offset;\n\tfield->report_type = report_type;\n\tfield->report_size = parser->global.report_size;\n\tfield->report_count = parser->global.report_count;\n\tfield->logical_minimum = parser->global.logical_minimum;\n\tfield->logical_maximum = parser->global.logical_maximum;\n\tfield->physical_minimum = parser->global.physical_minimum;\n\tfield->physical_maximum = parser->global.physical_maximum;\n\tfield->unit_exponent = parser->global.unit_exponent;\n\tfield->unit = parser->global.unit;\n\n\treturn 0;\n}\n\n/*\n * Read data value from item.\n */\n\nstatic u32 item_udata(struct hid_item *item)\n{\n\tswitch (item->size) {\n\tcase 1: return item->data.u8;\n\tcase 2: return item->data.u16;\n\tcase 4: return item->data.u32;\n\t}\n\treturn 0;\n}\n\nstatic s32 item_sdata(struct hid_item *item)\n{\n\tswitch (item->size) {\n\tcase 1: return item->data.s8;\n\tcase 2: return item->data.s16;\n\tcase 4: return item->data.s32;\n\t}\n\treturn 0;\n}\n\n/*\n * Process a global item.\n */\n\nstatic int hid_parser_global(struct hid_parser *parser, struct hid_item *item)\n{\n\t__s32 raw_value;\n\tswitch (item->tag) {\n\tcase HID_GLOBAL_ITEM_TAG_PUSH:\n\n\t\tif (parser->global_stack_ptr == HID_GLOBAL_STACK_SIZE) {\n\t\t\thid_err(parser->device, \"global environment stack overflow\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(parser->global_stack + parser->global_stack_ptr++,\n\t\t\t&parser->global, sizeof(struct hid_global));\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_POP:\n\n\t\tif (!parser->global_stack_ptr) {\n\t\t\thid_err(parser->device, \"global environment stack underflow\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(&parser->global, parser->global_stack +\n\t\t\t--parser->global_stack_ptr, sizeof(struct hid_global));\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_USAGE_PAGE:\n\t\tparser->global.usage_page = item_udata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_LOGICAL_MINIMUM:\n\t\tparser->global.logical_minimum = item_sdata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_LOGICAL_MAXIMUM:\n\t\tif (parser->global.logical_minimum < 0)\n\t\t\tparser->global.logical_maximum = item_sdata(item);\n\t\telse\n\t\t\tparser->global.logical_maximum = item_udata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_PHYSICAL_MINIMUM:\n\t\tparser->global.physical_minimum = item_sdata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_PHYSICAL_MAXIMUM:\n\t\tif (parser->global.physical_minimum < 0)\n\t\t\tparser->global.physical_maximum = item_sdata(item);\n\t\telse\n\t\t\tparser->global.physical_maximum = item_udata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT:\n\t\t/* Many devices provide unit exponent as a two's complement\n\t\t * nibble due to the common misunderstanding of HID\n\t\t * specification 1.11, 6.2.2.7 Global Items. Attempt to handle\n\t\t * both this and the standard encoding. */\n\t\traw_value = item_sdata(item);\n\t\tif (!(raw_value & 0xfffffff0))\n\t\t\tparser->global.unit_exponent = hid_snto32(raw_value, 4);\n\t\telse\n\t\t\tparser->global.unit_exponent = raw_value;\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_UNIT:\n\t\tparser->global.unit = item_udata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_SIZE:\n\t\tparser->global.report_size = item_udata(item);\n\t\tif (parser->global.report_size > 128) {\n\t\t\thid_err(parser->device, \"invalid report_size %d\\n\",\n\t\t\t\t\tparser->global.report_size);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_COUNT:\n\t\tparser->global.report_count = item_udata(item);\n\t\tif (parser->global.report_count > HID_MAX_USAGES) {\n\t\t\thid_err(parser->device, \"invalid report_count %d\\n\",\n\t\t\t\t\tparser->global.report_count);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_ID:\n\t\tparser->global.report_id = item_udata(item);\n\t\tif (parser->global.report_id == 0 ||\n\t\t    parser->global.report_id >= HID_MAX_IDS) {\n\t\t\thid_err(parser->device, \"report_id %u is invalid\\n\",\n\t\t\t\tparser->global.report_id);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\thid_err(parser->device, \"unknown global tag 0x%x\\n\", item->tag);\n\t\treturn -1;\n\t}\n}\n\n/*\n * Process a local item.\n */\n\nstatic int hid_parser_local(struct hid_parser *parser, struct hid_item *item)\n{\n\t__u32 data;\n\tunsigned n;\n\t__u32 count;\n\n\tdata = item_udata(item);\n\n\tswitch (item->tag) {\n\tcase HID_LOCAL_ITEM_TAG_DELIMITER:\n\n\t\tif (data) {\n\t\t\t/*\n\t\t\t * We treat items before the first delimiter\n\t\t\t * as global to all usage sets (branch 0).\n\t\t\t * In the moment we process only these global\n\t\t\t * items and the first delimiter set.\n\t\t\t */\n\t\t\tif (parser->local.delimiter_depth != 0) {\n\t\t\t\thid_err(parser->device, \"nested delimiters\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tparser->local.delimiter_depth++;\n\t\t\tparser->local.delimiter_branch++;\n\t\t} else {\n\t\t\tif (parser->local.delimiter_depth < 1) {\n\t\t\t\thid_err(parser->device, \"bogus close delimiter\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tparser->local.delimiter_depth--;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_LOCAL_ITEM_TAG_USAGE:\n\n\t\tif (parser->local.delimiter_branch > 1) {\n\t\t\tdbg_hid(\"alternative usage ignored\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (item->size <= 2)\n\t\t\tdata = (parser->global.usage_page << 16) + data;\n\n\t\treturn hid_add_usage(parser, data);\n\n\tcase HID_LOCAL_ITEM_TAG_USAGE_MINIMUM:\n\n\t\tif (parser->local.delimiter_branch > 1) {\n\t\t\tdbg_hid(\"alternative usage ignored\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (item->size <= 2)\n\t\t\tdata = (parser->global.usage_page << 16) + data;\n\n\t\tparser->local.usage_minimum = data;\n\t\treturn 0;\n\n\tcase HID_LOCAL_ITEM_TAG_USAGE_MAXIMUM:\n\n\t\tif (parser->local.delimiter_branch > 1) {\n\t\t\tdbg_hid(\"alternative usage ignored\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (item->size <= 2)\n\t\t\tdata = (parser->global.usage_page << 16) + data;\n\n\t\tcount = data - parser->local.usage_minimum;\n\t\tif (count + parser->local.usage_index >= HID_MAX_USAGES) {\n\t\t\t/*\n\t\t\t * We do not warn if the name is not set, we are\n\t\t\t * actually pre-scanning the device.\n\t\t\t */\n\t\t\tif (dev_name(&parser->device->dev))\n\t\t\t\thid_warn(parser->device,\n\t\t\t\t\t \"ignoring exceeding usage max\\n\");\n\t\t\tdata = HID_MAX_USAGES - parser->local.usage_index +\n\t\t\t\tparser->local.usage_minimum - 1;\n\t\t\tif (data <= 0) {\n\t\t\t\thid_err(parser->device,\n\t\t\t\t\t\"no more usage index available\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (n = parser->local.usage_minimum; n <= data; n++)\n\t\t\tif (hid_add_usage(parser, n)) {\n\t\t\t\tdbg_hid(\"hid_add_usage failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\treturn 0;\n\n\tdefault:\n\n\t\tdbg_hid(\"unknown local item tag 0x%x\\n\", item->tag);\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n/*\n * Process a main item.\n */\n\nstatic int hid_parser_main(struct hid_parser *parser, struct hid_item *item)\n{\n\t__u32 data;\n\tint ret;\n\n\tdata = item_udata(item);\n\n\tswitch (item->tag) {\n\tcase HID_MAIN_ITEM_TAG_BEGIN_COLLECTION:\n\t\tret = open_collection(parser, data & 0xff);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_END_COLLECTION:\n\t\tret = close_collection(parser);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_INPUT:\n\t\tret = hid_add_field(parser, HID_INPUT_REPORT, data);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_OUTPUT:\n\t\tret = hid_add_field(parser, HID_OUTPUT_REPORT, data);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_FEATURE:\n\t\tret = hid_add_field(parser, HID_FEATURE_REPORT, data);\n\t\tbreak;\n\tdefault:\n\t\thid_err(parser->device, \"unknown main item tag 0x%x\\n\", item->tag);\n\t\tret = 0;\n\t}\n\n\tmemset(&parser->local, 0, sizeof(parser->local));\t/* Reset the local parser environment */\n\n\treturn ret;\n}\n\n/*\n * Process a reserved item.\n */\n\nstatic int hid_parser_reserved(struct hid_parser *parser, struct hid_item *item)\n{\n\tdbg_hid(\"reserved item type, tag 0x%x\\n\", item->tag);\n\treturn 0;\n}\n\n/*\n * Free a report and all registered fields. The field->usage and\n * field->value table's are allocated behind the field, so we need\n * only to free(field) itself.\n */\n\nstatic void hid_free_report(struct hid_report *report)\n{\n\tunsigned n;\n\n\tfor (n = 0; n < report->maxfield; n++)\n\t\tkfree(report->field[n]);\n\tkfree(report);\n}\n\n/*\n * Close report. This function returns the device\n * state to the point prior to hid_open_report().\n */\nstatic void hid_close_report(struct hid_device *device)\n{\n\tunsigned i, j;\n\n\tfor (i = 0; i < HID_REPORT_TYPES; i++) {\n\t\tstruct hid_report_enum *report_enum = device->report_enum + i;\n\n\t\tfor (j = 0; j < HID_MAX_IDS; j++) {\n\t\t\tstruct hid_report *report = report_enum->report_id_hash[j];\n\t\t\tif (report)\n\t\t\t\thid_free_report(report);\n\t\t}\n\t\tmemset(report_enum, 0, sizeof(*report_enum));\n\t\tINIT_LIST_HEAD(&report_enum->report_list);\n\t}\n\n\tkfree(device->rdesc);\n\tdevice->rdesc = NULL;\n\tdevice->rsize = 0;\n\n\tkfree(device->collection);\n\tdevice->collection = NULL;\n\tdevice->collection_size = 0;\n\tdevice->maxcollection = 0;\n\tdevice->maxapplication = 0;\n\n\tdevice->status &= ~HID_STAT_PARSED;\n}\n\n/*\n * Free a device structure, all reports, and all fields.\n */\n\nstatic void hid_device_release(struct device *dev)\n{\n\tstruct hid_device *hid = to_hid_device(dev);\n\n\thid_close_report(hid);\n\tkfree(hid->dev_rdesc);\n\tkfree(hid);\n}\n\n/*\n * Fetch a report description item from the data stream. We support long\n * items, though they are not used yet.\n */\n\nstatic u8 *fetch_item(__u8 *start, __u8 *end, struct hid_item *item)\n{\n\tu8 b;\n\n\tif ((end - start) <= 0)\n\t\treturn NULL;\n\n\tb = *start++;\n\n\titem->type = (b >> 2) & 3;\n\titem->tag  = (b >> 4) & 15;\n\n\tif (item->tag == HID_ITEM_TAG_LONG) {\n\n\t\titem->format = HID_ITEM_FORMAT_LONG;\n\n\t\tif ((end - start) < 2)\n\t\t\treturn NULL;\n\n\t\titem->size = *start++;\n\t\titem->tag  = *start++;\n\n\t\tif ((end - start) < item->size)\n\t\t\treturn NULL;\n\n\t\titem->data.longdata = start;\n\t\tstart += item->size;\n\t\treturn start;\n\t}\n\n\titem->format = HID_ITEM_FORMAT_SHORT;\n\titem->size = b & 3;\n\n\tswitch (item->size) {\n\tcase 0:\n\t\treturn start;\n\n\tcase 1:\n\t\tif ((end - start) < 1)\n\t\t\treturn NULL;\n\t\titem->data.u8 = *start++;\n\t\treturn start;\n\n\tcase 2:\n\t\tif ((end - start) < 2)\n\t\t\treturn NULL;\n\t\titem->data.u16 = get_unaligned_le16(start);\n\t\tstart = (__u8 *)((__le16 *)start + 1);\n\t\treturn start;\n\n\tcase 3:\n\t\titem->size++;\n\t\tif ((end - start) < 4)\n\t\t\treturn NULL;\n\t\titem->data.u32 = get_unaligned_le32(start);\n\t\tstart = (__u8 *)((__le32 *)start + 1);\n\t\treturn start;\n\t}\n\n\treturn NULL;\n}\n\nstatic void hid_scan_input_usage(struct hid_parser *parser, u32 usage)\n{\n\tstruct hid_device *hid = parser->device;\n\n\tif (usage == HID_DG_CONTACTID)\n\t\thid->group = HID_GROUP_MULTITOUCH;\n}\n\nstatic void hid_scan_feature_usage(struct hid_parser *parser, u32 usage)\n{\n\tif (usage == 0xff0000c5 && parser->global.report_count == 256 &&\n\t    parser->global.report_size == 8)\n\t\tparser->scan_flags |= HID_SCAN_FLAG_MT_WIN_8;\n}\n\nstatic void hid_scan_collection(struct hid_parser *parser, unsigned type)\n{\n\tstruct hid_device *hid = parser->device;\n\tint i;\n\n\tif (((parser->global.usage_page << 16) == HID_UP_SENSOR) &&\n\t    type == HID_COLLECTION_PHYSICAL)\n\t\thid->group = HID_GROUP_SENSOR_HUB;\n\n\tif (hid->vendor == USB_VENDOR_ID_MICROSOFT &&\n\t    (hid->product == USB_DEVICE_ID_MS_TYPE_COVER_PRO_3 ||\n\t     hid->product == USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_2 ||\n\t     hid->product == USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_JP ||\n\t     hid->product == USB_DEVICE_ID_MS_TYPE_COVER_3 ||\n\t     hid->product == USB_DEVICE_ID_MS_POWER_COVER) &&\n\t    hid->group == HID_GROUP_MULTITOUCH)\n\t\thid->group = HID_GROUP_GENERIC;\n\n\tif ((parser->global.usage_page << 16) == HID_UP_GENDESK)\n\t\tfor (i = 0; i < parser->local.usage_index; i++)\n\t\t\tif (parser->local.usage[i] == HID_GD_POINTER)\n\t\t\t\tparser->scan_flags |= HID_SCAN_FLAG_GD_POINTER;\n\n\tif ((parser->global.usage_page << 16) >= HID_UP_MSVENDOR)\n\t\tparser->scan_flags |= HID_SCAN_FLAG_VENDOR_SPECIFIC;\n}\n\nstatic int hid_scan_main(struct hid_parser *parser, struct hid_item *item)\n{\n\t__u32 data;\n\tint i;\n\n\tdata = item_udata(item);\n\n\tswitch (item->tag) {\n\tcase HID_MAIN_ITEM_TAG_BEGIN_COLLECTION:\n\t\thid_scan_collection(parser, data & 0xff);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_END_COLLECTION:\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_INPUT:\n\t\t/* ignore constant inputs, they will be ignored by hid-input */\n\t\tif (data & HID_MAIN_ITEM_CONSTANT)\n\t\t\tbreak;\n\t\tfor (i = 0; i < parser->local.usage_index; i++)\n\t\t\thid_scan_input_usage(parser, parser->local.usage[i]);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_OUTPUT:\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_FEATURE:\n\t\tfor (i = 0; i < parser->local.usage_index; i++)\n\t\t\thid_scan_feature_usage(parser, parser->local.usage[i]);\n\t\tbreak;\n\t}\n\n\t/* Reset the local parser environment */\n\tmemset(&parser->local, 0, sizeof(parser->local));\n\n\treturn 0;\n}\n\n/*\n * Scan a report descriptor before the device is added to the bus.\n * Sets device groups and other properties that determine what driver\n * to load.\n */\nstatic int hid_scan_report(struct hid_device *hid)\n{\n\tstruct hid_parser *parser;\n\tstruct hid_item item;\n\t__u8 *start = hid->dev_rdesc;\n\t__u8 *end = start + hid->dev_rsize;\n\tstatic int (*dispatch_type[])(struct hid_parser *parser,\n\t\t\t\t      struct hid_item *item) = {\n\t\thid_scan_main,\n\t\thid_parser_global,\n\t\thid_parser_local,\n\t\thid_parser_reserved\n\t};\n\n\tparser = vzalloc(sizeof(struct hid_parser));\n\tif (!parser)\n\t\treturn -ENOMEM;\n\n\tparser->device = hid;\n\thid->group = HID_GROUP_GENERIC;\n\n\t/*\n\t * The parsing is simpler than the one in hid_open_report() as we should\n\t * be robust against hid errors. Those errors will be raised by\n\t * hid_open_report() anyway.\n\t */\n\twhile ((start = fetch_item(start, end, &item)) != NULL)\n\t\tdispatch_type[item.type](parser, &item);\n\n\t/*\n\t * Handle special flags set during scanning.\n\t */\n\tif ((parser->scan_flags & HID_SCAN_FLAG_MT_WIN_8) &&\n\t    (hid->group == HID_GROUP_MULTITOUCH))\n\t\thid->group = HID_GROUP_MULTITOUCH_WIN_8;\n\n\t/*\n\t * Vendor specific handlings\n\t */\n\tswitch (hid->vendor) {\n\tcase USB_VENDOR_ID_WACOM:\n\t\thid->group = HID_GROUP_WACOM;\n\t\tbreak;\n\tcase USB_VENDOR_ID_SYNAPTICS:\n\t\tif (hid->group == HID_GROUP_GENERIC)\n\t\t\tif ((parser->scan_flags & HID_SCAN_FLAG_VENDOR_SPECIFIC)\n\t\t\t    && (parser->scan_flags & HID_SCAN_FLAG_GD_POINTER))\n\t\t\t\t/*\n\t\t\t\t * hid-rmi should take care of them,\n\t\t\t\t * not hid-generic\n\t\t\t\t */\n\t\t\t\thid->group = HID_GROUP_RMI;\n\t\tbreak;\n\t}\n\n\tvfree(parser);\n\treturn 0;\n}\n\n/**\n * hid_parse_report - parse device report\n *\n * @device: hid device\n * @start: report start\n * @size: report size\n *\n * Allocate the device report as read by the bus driver. This function should\n * only be called from parse() in ll drivers.\n */\nint hid_parse_report(struct hid_device *hid, __u8 *start, unsigned size)\n{\n\thid->dev_rdesc = kmemdup(start, size, GFP_KERNEL);\n\tif (!hid->dev_rdesc)\n\t\treturn -ENOMEM;\n\thid->dev_rsize = size;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_parse_report);\n\nstatic const char * const hid_report_names[] = {\n\t\"HID_INPUT_REPORT\",\n\t\"HID_OUTPUT_REPORT\",\n\t\"HID_FEATURE_REPORT\",\n};\n/**\n * hid_validate_values - validate existing device report's value indexes\n *\n * @device: hid device\n * @type: which report type to examine\n * @id: which report ID to examine (0 for first)\n * @field_index: which report field to examine\n * @report_counts: expected number of values\n *\n * Validate the number of values in a given field of a given report, after\n * parsing.\n */\nstruct hid_report *hid_validate_values(struct hid_device *hid,\n\t\t\t\t       unsigned int type, unsigned int id,\n\t\t\t\t       unsigned int field_index,\n\t\t\t\t       unsigned int report_counts)\n{\n\tstruct hid_report *report;\n\n\tif (type > HID_FEATURE_REPORT) {\n\t\thid_err(hid, \"invalid HID report type %u\\n\", type);\n\t\treturn NULL;\n\t}\n\n\tif (id >= HID_MAX_IDS) {\n\t\thid_err(hid, \"invalid HID report id %u\\n\", id);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Explicitly not using hid_get_report() here since it depends on\n\t * ->numbered being checked, which may not always be the case when\n\t * drivers go to access report values.\n\t */\n\tif (id == 0) {\n\t\t/*\n\t\t * Validating on id 0 means we should examine the first\n\t\t * report in the list.\n\t\t */\n\t\treport = list_entry(\n\t\t\t\thid->report_enum[type].report_list.next,\n\t\t\t\tstruct hid_report, list);\n\t} else {\n\t\treport = hid->report_enum[type].report_id_hash[id];\n\t}\n\tif (!report) {\n\t\thid_err(hid, \"missing %s %u\\n\", hid_report_names[type], id);\n\t\treturn NULL;\n\t}\n\tif (report->maxfield <= field_index) {\n\t\thid_err(hid, \"not enough fields in %s %u\\n\",\n\t\t\thid_report_names[type], id);\n\t\treturn NULL;\n\t}\n\tif (report->field[field_index]->report_count < report_counts) {\n\t\thid_err(hid, \"not enough values in %s %u field %u\\n\",\n\t\t\thid_report_names[type], id, field_index);\n\t\treturn NULL;\n\t}\n\treturn report;\n}\nEXPORT_SYMBOL_GPL(hid_validate_values);\n\n/**\n * hid_open_report - open a driver-specific device report\n *\n * @device: hid device\n *\n * Parse a report description into a hid_device structure. Reports are\n * enumerated, fields are attached to these reports.\n * 0 returned on success, otherwise nonzero error value.\n *\n * This function (or the equivalent hid_parse() macro) should only be\n * called from probe() in drivers, before starting the device.\n */\nint hid_open_report(struct hid_device *device)\n{\n\tstruct hid_parser *parser;\n\tstruct hid_item item;\n\tunsigned int size;\n\t__u8 *start;\n\t__u8 *buf;\n\t__u8 *end;\n\tint ret;\n\tstatic int (*dispatch_type[])(struct hid_parser *parser,\n\t\t\t\t      struct hid_item *item) = {\n\t\thid_parser_main,\n\t\thid_parser_global,\n\t\thid_parser_local,\n\t\thid_parser_reserved\n\t};\n\n\tif (WARN_ON(device->status & HID_STAT_PARSED))\n\t\treturn -EBUSY;\n\n\tstart = device->dev_rdesc;\n\tif (WARN_ON(!start))\n\t\treturn -ENODEV;\n\tsize = device->dev_rsize;\n\n\tbuf = kmemdup(start, size, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tif (device->driver->report_fixup)\n\t\tstart = device->driver->report_fixup(device, buf, &size);\n\telse\n\t\tstart = buf;\n\n\tstart = kmemdup(start, size, GFP_KERNEL);\n\tkfree(buf);\n\tif (start == NULL)\n\t\treturn -ENOMEM;\n\n\tdevice->rdesc = start;\n\tdevice->rsize = size;\n\n\tparser = vzalloc(sizeof(struct hid_parser));\n\tif (!parser) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tparser->device = device;\n\n\tend = start + size;\n\n\tdevice->collection = kcalloc(HID_DEFAULT_NUM_COLLECTIONS,\n\t\t\t\t     sizeof(struct hid_collection), GFP_KERNEL);\n\tif (!device->collection) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdevice->collection_size = HID_DEFAULT_NUM_COLLECTIONS;\n\n\tret = -EINVAL;\n\twhile ((start = fetch_item(start, end, &item)) != NULL) {\n\n\t\tif (item.format != HID_ITEM_FORMAT_SHORT) {\n\t\t\thid_err(device, \"unexpected long global item\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (dispatch_type[item.type](parser, &item)) {\n\t\t\thid_err(device, \"item %u %u %u %u parsing failed\\n\",\n\t\t\t\titem.format, (unsigned)item.size,\n\t\t\t\t(unsigned)item.type, (unsigned)item.tag);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (start == end) {\n\t\t\tif (parser->collection_stack_ptr) {\n\t\t\t\thid_err(device, \"unbalanced collection at end of report description\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (parser->local.delimiter_depth) {\n\t\t\t\thid_err(device, \"unbalanced delimiter at end of report description\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tvfree(parser);\n\t\t\tdevice->status |= HID_STAT_PARSED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\thid_err(device, \"item fetching failed at offset %d\\n\", (int)(end - start));\nerr:\n\tvfree(parser);\n\thid_close_report(device);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_open_report);\n\n/*\n * Convert a signed n-bit integer to signed 32-bit integer. Common\n * cases are done through the compiler, the screwed things has to be\n * done by hand.\n */\n\nstatic s32 snto32(__u32 value, unsigned n)\n{\n\tswitch (n) {\n\tcase 8:  return ((__s8)value);\n\tcase 16: return ((__s16)value);\n\tcase 32: return ((__s32)value);\n\t}\n\treturn value & (1 << (n - 1)) ? value | (-1 << n) : value;\n}\n\ns32 hid_snto32(__u32 value, unsigned n)\n{\n\treturn snto32(value, n);\n}\nEXPORT_SYMBOL_GPL(hid_snto32);\n\n/*\n * Convert a signed 32-bit integer to a signed n-bit integer.\n */\n\nstatic u32 s32ton(__s32 value, unsigned n)\n{\n\ts32 a = value >> (n - 1);\n\tif (a && a != -1)\n\t\treturn value < 0 ? 1 << (n - 1) : (1 << (n - 1)) - 1;\n\treturn value & ((1 << n) - 1);\n}\n\n/*\n * Extract/implement a data field from/to a little endian report (bit array).\n *\n * Code sort-of follows HID spec:\n *     http://www.usb.org/developers/hidpage/HID1_11.pdf\n *\n * While the USB HID spec allows unlimited length bit fields in \"report\n * descriptors\", most devices never use more than 16 bits.\n * One model of UPS is claimed to report \"LINEV\" as a 32-bit field.\n * Search linux-kernel and linux-usb-devel archives for \"hid-core extract\".\n */\n\nstatic u32 __extract(u8 *report, unsigned offset, int n)\n{\n\tunsigned int idx = offset / 8;\n\tunsigned int bit_nr = 0;\n\tunsigned int bit_shift = offset % 8;\n\tint bits_to_copy = 8 - bit_shift;\n\tu32 value = 0;\n\tu32 mask = n < 32 ? (1U << n) - 1 : ~0U;\n\n\twhile (n > 0) {\n\t\tvalue |= ((u32)report[idx] >> bit_shift) << bit_nr;\n\t\tn -= bits_to_copy;\n\t\tbit_nr += bits_to_copy;\n\t\tbits_to_copy = 8;\n\t\tbit_shift = 0;\n\t\tidx++;\n\t}\n\n\treturn value & mask;\n}\n\nu32 hid_field_extract(const struct hid_device *hid, u8 *report,\n\t\t\tunsigned offset, unsigned n)\n{\n\tif (n > 32) {\n\t\thid_warn(hid, \"hid_field_extract() called with n (%d) > 32! (%s)\\n\",\n\t\t\t n, current->comm);\n\t\tn = 32;\n\t}\n\n\treturn __extract(report, offset, n);\n}\nEXPORT_SYMBOL_GPL(hid_field_extract);\n\n/*\n * \"implement\" : set bits in a little endian bit stream.\n * Same concepts as \"extract\" (see comments above).\n * The data mangled in the bit stream remains in little endian\n * order the whole time. It make more sense to talk about\n * endianness of register values by considering a register\n * a \"cached\" copy of the little endian bit stream.\n */\n\nstatic void __implement(u8 *report, unsigned offset, int n, u32 value)\n{\n\tunsigned int idx = offset / 8;\n\tunsigned int size = offset + n;\n\tunsigned int bit_shift = offset % 8;\n\tint bits_to_set = 8 - bit_shift;\n\tu8 bit_mask = 0xff << bit_shift;\n\n\twhile (n - bits_to_set >= 0) {\n\t\treport[idx] &= ~bit_mask;\n\t\treport[idx] |= value << bit_shift;\n\t\tvalue >>= bits_to_set;\n\t\tn -= bits_to_set;\n\t\tbits_to_set = 8;\n\t\tbit_mask = 0xff;\n\t\tbit_shift = 0;\n\t\tidx++;\n\t}\n\n\t/* last nibble */\n\tif (n) {\n\t\tif (size % 8)\n\t\t\tbit_mask &= (1U << (size % 8)) - 1;\n\t\treport[idx] &= ~bit_mask;\n\t\treport[idx] |= (value << bit_shift) & bit_mask;\n\t}\n}\n\nstatic void implement(const struct hid_device *hid, u8 *report,\n\t\t      unsigned offset, unsigned n, u32 value)\n{\n\tu64 m;\n\n\tif (n > 32) {\n\t\thid_warn(hid, \"%s() called with n (%d) > 32! (%s)\\n\",\n\t\t\t __func__, n, current->comm);\n\t\tn = 32;\n\t}\n\n\tm = (1ULL << n) - 1;\n\tif (value > m)\n\t\thid_warn(hid, \"%s() called with too large value %d! (%s)\\n\",\n\t\t\t __func__, value, current->comm);\n\tWARN_ON(value > m);\n\tvalue &= m;\n\n\t__implement(report, offset, n, value);\n}\n\n/*\n * Search an array for a value.\n */\n\nstatic int search(__s32 *array, __s32 value, unsigned n)\n{\n\twhile (n--) {\n\t\tif (*array++ == value)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n/**\n * hid_match_report - check if driver's raw_event should be called\n *\n * @hid: hid device\n * @report_type: type to match against\n *\n * compare hid->driver->report_table->report_type to report->type\n */\nstatic int hid_match_report(struct hid_device *hid, struct hid_report *report)\n{\n\tconst struct hid_report_id *id = hid->driver->report_table;\n\n\tif (!id) /* NULL means all */\n\t\treturn 1;\n\n\tfor (; id->report_type != HID_TERMINATOR; id++)\n\t\tif (id->report_type == HID_ANY_ID ||\n\t\t\t\tid->report_type == report->type)\n\t\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * hid_match_usage - check if driver's event should be called\n *\n * @hid: hid device\n * @usage: usage to match against\n *\n * compare hid->driver->usage_table->usage_{type,code} to\n * usage->usage_{type,code}\n */\nstatic int hid_match_usage(struct hid_device *hid, struct hid_usage *usage)\n{\n\tconst struct hid_usage_id *id = hid->driver->usage_table;\n\n\tif (!id) /* NULL means all */\n\t\treturn 1;\n\n\tfor (; id->usage_type != HID_ANY_ID - 1; id++)\n\t\tif ((id->usage_hid == HID_ANY_ID ||\n\t\t\t\tid->usage_hid == usage->hid) &&\n\t\t\t\t(id->usage_type == HID_ANY_ID ||\n\t\t\t\tid->usage_type == usage->type) &&\n\t\t\t\t(id->usage_code == HID_ANY_ID ||\n\t\t\t\t id->usage_code == usage->code))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic void hid_process_event(struct hid_device *hid, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value, int interrupt)\n{\n\tstruct hid_driver *hdrv = hid->driver;\n\tint ret;\n\n\tif (!list_empty(&hid->debug_list))\n\t\thid_dump_input(hid, usage, value);\n\n\tif (hdrv && hdrv->event && hid_match_usage(hid, usage)) {\n\t\tret = hdrv->event(hid, field, usage, value);\n\t\tif (ret != 0) {\n\t\t\tif (ret < 0)\n\t\t\t\thid_err(hid, \"%s's event failed with %d\\n\",\n\t\t\t\t\t\thdrv->name, ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (hid->claimed & HID_CLAIMED_INPUT)\n\t\thidinput_hid_event(hid, field, usage, value);\n\tif (hid->claimed & HID_CLAIMED_HIDDEV && interrupt && hid->hiddev_hid_event)\n\t\thid->hiddev_hid_event(hid, field, usage, value);\n}\n\n/*\n * Analyse a received field, and fetch the data from it. The field\n * content is stored for next report processing (we do differential\n * reporting to the layer).\n */\n\nstatic void hid_input_field(struct hid_device *hid, struct hid_field *field,\n\t\t\t    __u8 *data, int interrupt)\n{\n\tunsigned n;\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\t__s32 min = field->logical_minimum;\n\t__s32 max = field->logical_maximum;\n\t__s32 *value;\n\n\tvalue = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);\n\tif (!value)\n\t\treturn;\n\n\tfor (n = 0; n < count; n++) {\n\n\t\tvalue[n] = min < 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n\n\t\t/* Ignore report if ErrorRollOver */\n\t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n\t\t    value[n] >= min && value[n] <= max &&\n\t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n\t\t\tgoto exit;\n\t}\n\n\tfor (n = 0; n < count; n++) {\n\n\t\tif (HID_MAIN_ITEM_VARIABLE & field->flags) {\n\t\t\thid_process_event(hid, field, &field->usage[n], value[n], interrupt);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (field->value[n] >= min && field->value[n] <= max\n\t\t\t&& field->usage[field->value[n] - min].hid\n\t\t\t&& search(value, field->value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n\n\t\tif (value[n] >= min && value[n] <= max\n\t\t\t&& field->usage[value[n] - min].hid\n\t\t\t&& search(field->value, value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);\n\t}\n\n\tmemcpy(field->value, value, count * sizeof(__s32));\nexit:\n\tkfree(value);\n}\n\n/*\n * Output the field into the report.\n */\n\nstatic void hid_output_field(const struct hid_device *hid,\n\t\t\t     struct hid_field *field, __u8 *data)\n{\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\tunsigned n;\n\n\tfor (n = 0; n < count; n++) {\n\t\tif (field->logical_minimum < 0)\t/* signed values */\n\t\t\timplement(hid, data, offset + n * size, size,\n\t\t\t\t  s32ton(field->value[n], size));\n\t\telse\t\t\t\t/* unsigned values */\n\t\t\timplement(hid, data, offset + n * size, size,\n\t\t\t\t  field->value[n]);\n\t}\n}\n\n/*\n * Create a report. 'data' has to be allocated using\n * hid_alloc_report_buf() so that it has proper size.\n */\n\nvoid hid_output_report(struct hid_report *report, __u8 *data)\n{\n\tunsigned n;\n\n\tif (report->id > 0)\n\t\t*data++ = report->id;\n\n\tmemset(data, 0, ((report->size - 1) >> 3) + 1);\n\tfor (n = 0; n < report->maxfield; n++)\n\t\thid_output_field(report->device, report->field[n], data);\n}\nEXPORT_SYMBOL_GPL(hid_output_report);\n\n/*\n * Allocator for buffer that is going to be passed to hid_output_report()\n */\nu8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags)\n{\n\t/*\n\t * 7 extra bytes are necessary to achieve proper functionality\n\t * of implement() working on 8 byte chunks\n\t */\n\n\tint len = hid_report_len(report) + 7;\n\n\treturn kmalloc(len, flags);\n}\nEXPORT_SYMBOL_GPL(hid_alloc_report_buf);\n\n/*\n * Set a field value. The report this field belongs to has to be\n * created and transferred to the device, to set this value in the\n * device.\n */\n\nint hid_set_field(struct hid_field *field, unsigned offset, __s32 value)\n{\n\tunsigned size;\n\n\tif (!field)\n\t\treturn -1;\n\n\tsize = field->report_size;\n\n\thid_dump_input(field->report->device, field->usage + offset, value);\n\n\tif (offset >= field->report_count) {\n\t\thid_err(field->report->device, \"offset (%d) exceeds report_count (%d)\\n\",\n\t\t\t\toffset, field->report_count);\n\t\treturn -1;\n\t}\n\tif (field->logical_minimum < 0) {\n\t\tif (value != snto32(s32ton(value, size), size)) {\n\t\t\thid_err(field->report->device, \"value %d is out of range\\n\", value);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfield->value[offset] = value;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_set_field);\n\nstatic struct hid_report *hid_get_report(struct hid_report_enum *report_enum,\n\t\tconst u8 *data)\n{\n\tstruct hid_report *report;\n\tunsigned int n = 0;\t/* Normally report number is 0 */\n\n\t/* Device uses numbered reports, data[0] is report number */\n\tif (report_enum->numbered)\n\t\tn = *data;\n\n\treport = report_enum->report_id_hash[n];\n\tif (report == NULL)\n\t\tdbg_hid(\"undefined report_id %u received\\n\", n);\n\n\treturn report;\n}\n\n/*\n * Implement a generic .request() callback, using .raw_request()\n * DO NOT USE in hid drivers directly, but through hid_hw_request instead.\n */\nvoid __hid_request(struct hid_device *hid, struct hid_report *report,\n\t\tint reqtype)\n{\n\tchar *buf;\n\tint ret;\n\tint len;\n\n\tbuf = hid_alloc_report_buf(report, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tlen = hid_report_len(report);\n\n\tif (reqtype == HID_REQ_SET_REPORT)\n\t\thid_output_report(report, buf);\n\n\tret = hid->ll_driver->raw_request(hid, report->id, buf, len,\n\t\t\t\t\t  report->type, reqtype);\n\tif (ret < 0) {\n\t\tdbg_hid(\"unable to complete request: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (reqtype == HID_REQ_GET_REPORT)\n\t\thid_input_report(hid, report->type, buf, ret, 0);\n\nout:\n\tkfree(buf);\n}\nEXPORT_SYMBOL_GPL(__hid_request);\n\nint hid_report_raw_event(struct hid_device *hid, int type, u8 *data, int size,\n\t\tint interrupt)\n{\n\tstruct hid_report_enum *report_enum = hid->report_enum + type;\n\tstruct hid_report *report;\n\tstruct hid_driver *hdrv;\n\tunsigned int a;\n\tint rsize, csize = size;\n\tu8 *cdata = data;\n\tint ret = 0;\n\n\treport = hid_get_report(report_enum, data);\n\tif (!report)\n\t\tgoto out;\n\n\tif (report_enum->numbered) {\n\t\tcdata++;\n\t\tcsize--;\n\t}\n\n\trsize = ((report->size - 1) >> 3) + 1;\n\n\tif (rsize > HID_MAX_BUFFER_SIZE)\n\t\trsize = HID_MAX_BUFFER_SIZE;\n\n\tif (csize < rsize) {\n\t\tdbg_hid(\"report %d is too short, (%d < %d)\\n\", report->id,\n\t\t\t\tcsize, rsize);\n\t\tmemset(cdata + csize, 0, rsize - csize);\n\t}\n\n\tif ((hid->claimed & HID_CLAIMED_HIDDEV) && hid->hiddev_report_event)\n\t\thid->hiddev_report_event(hid, report);\n\tif (hid->claimed & HID_CLAIMED_HIDRAW) {\n\t\tret = hidraw_report_event(hid, data, size);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (hid->claimed != HID_CLAIMED_HIDRAW && report->maxfield) {\n\t\tfor (a = 0; a < report->maxfield; a++)\n\t\t\thid_input_field(hid, report->field[a], cdata, interrupt);\n\t\thdrv = hid->driver;\n\t\tif (hdrv && hdrv->report)\n\t\t\thdrv->report(hid, report);\n\t}\n\n\tif (hid->claimed & HID_CLAIMED_INPUT)\n\t\thidinput_report_event(hid, report);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_report_raw_event);\n\n/**\n * hid_input_report - report data from lower layer (usb, bt...)\n *\n * @hid: hid device\n * @type: HID report type (HID_*_REPORT)\n * @data: report contents\n * @size: size of data parameter\n * @interrupt: distinguish between interrupt and control transfers\n *\n * This is data entry for lower layers.\n */\nint hid_input_report(struct hid_device *hid, int type, u8 *data, int size, int interrupt)\n{\n\tstruct hid_report_enum *report_enum;\n\tstruct hid_driver *hdrv;\n\tstruct hid_report *report;\n\tint ret = 0;\n\n\tif (!hid)\n\t\treturn -ENODEV;\n\n\tif (down_trylock(&hid->driver_input_lock))\n\t\treturn -EBUSY;\n\n\tif (!hid->driver) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\treport_enum = hid->report_enum + type;\n\thdrv = hid->driver;\n\n\tif (!size) {\n\t\tdbg_hid(\"empty report\\n\");\n\t\tret = -1;\n\t\tgoto unlock;\n\t}\n\n\t/* Avoid unnecessary overhead if debugfs is disabled */\n\tif (!list_empty(&hid->debug_list))\n\t\thid_dump_report(hid, type, data, size);\n\n\treport = hid_get_report(report_enum, data);\n\n\tif (!report) {\n\t\tret = -1;\n\t\tgoto unlock;\n\t}\n\n\tif (hdrv && hdrv->raw_event && hid_match_report(hid, report)) {\n\t\tret = hdrv->raw_event(hid, report, data, size);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tret = hid_report_raw_event(hid, type, data, size, interrupt);\n\nunlock:\n\tup(&hid->driver_input_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_input_report);\n\nstatic bool hid_match_one_id(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\treturn (id->bus == HID_BUS_ANY || id->bus == hdev->bus) &&\n\t\t(id->group == HID_GROUP_ANY || id->group == hdev->group) &&\n\t\t(id->vendor == HID_ANY_ID || id->vendor == hdev->vendor) &&\n\t\t(id->product == HID_ANY_ID || id->product == hdev->product);\n}\n\nconst struct hid_device_id *hid_match_id(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tfor (; id->bus; id++)\n\t\tif (hid_match_one_id(hdev, id))\n\t\t\treturn id;\n\n\treturn NULL;\n}\n\nstatic const struct hid_device_id hid_hiddev_list[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS1) },\n\t{ }\n};\n\nstatic bool hid_hiddev(struct hid_device *hdev)\n{\n\treturn !!hid_match_id(hdev, hid_hiddev_list);\n}\n\n\nstatic ssize_t\nread_report_descriptor(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr,\n\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct hid_device *hdev = to_hid_device(dev);\n\n\tif (off >= hdev->rsize)\n\t\treturn 0;\n\n\tif (off + count > hdev->rsize)\n\t\tcount = hdev->rsize - off;\n\n\tmemcpy(buf, hdev->rdesc + off, count);\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_country(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\n\treturn sprintf(buf, \"%02x\\n\", hdev->country & 0xff);\n}\n\nstatic struct bin_attribute dev_bin_attr_report_desc = {\n\t.attr = { .name = \"report_descriptor\", .mode = 0444 },\n\t.read = read_report_descriptor,\n\t.size = HID_MAX_DESCRIPTOR_SIZE,\n};\n\nstatic struct device_attribute dev_attr_country = {\n\t.attr = { .name = \"country\", .mode = 0444 },\n\t.show = show_country,\n};\n\nint hid_connect(struct hid_device *hdev, unsigned int connect_mask)\n{\n\tstatic const char *types[] = { \"Device\", \"Pointer\", \"Mouse\", \"Device\",\n\t\t\"Joystick\", \"Gamepad\", \"Keyboard\", \"Keypad\",\n\t\t\"Multi-Axis Controller\"\n\t};\n\tconst char *type, *bus;\n\tchar buf[64] = \"\";\n\tunsigned int i;\n\tint len;\n\tint ret;\n\n\tif (hdev->quirks & HID_QUIRK_HIDDEV_FORCE)\n\t\tconnect_mask |= (HID_CONNECT_HIDDEV_FORCE | HID_CONNECT_HIDDEV);\n\tif (hdev->quirks & HID_QUIRK_HIDINPUT_FORCE)\n\t\tconnect_mask |= HID_CONNECT_HIDINPUT_FORCE;\n\tif (hdev->bus != BUS_USB)\n\t\tconnect_mask &= ~HID_CONNECT_HIDDEV;\n\tif (hid_hiddev(hdev))\n\t\tconnect_mask |= HID_CONNECT_HIDDEV_FORCE;\n\n\tif ((connect_mask & HID_CONNECT_HIDINPUT) && !hidinput_connect(hdev,\n\t\t\t\tconnect_mask & HID_CONNECT_HIDINPUT_FORCE))\n\t\thdev->claimed |= HID_CLAIMED_INPUT;\n\n\tif ((connect_mask & HID_CONNECT_HIDDEV) && hdev->hiddev_connect &&\n\t\t\t!hdev->hiddev_connect(hdev,\n\t\t\t\tconnect_mask & HID_CONNECT_HIDDEV_FORCE))\n\t\thdev->claimed |= HID_CLAIMED_HIDDEV;\n\tif ((connect_mask & HID_CONNECT_HIDRAW) && !hidraw_connect(hdev))\n\t\thdev->claimed |= HID_CLAIMED_HIDRAW;\n\n\tif (connect_mask & HID_CONNECT_DRIVER)\n\t\thdev->claimed |= HID_CLAIMED_DRIVER;\n\n\t/* Drivers with the ->raw_event callback set are not required to connect\n\t * to any other listener. */\n\tif (!hdev->claimed && !hdev->driver->raw_event) {\n\t\thid_err(hdev, \"device has no listeners, quitting\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif ((hdev->claimed & HID_CLAIMED_INPUT) &&\n\t\t\t(connect_mask & HID_CONNECT_FF) && hdev->ff_init)\n\t\thdev->ff_init(hdev);\n\n\tlen = 0;\n\tif (hdev->claimed & HID_CLAIMED_INPUT)\n\t\tlen += sprintf(buf + len, \"input\");\n\tif (hdev->claimed & HID_CLAIMED_HIDDEV)\n\t\tlen += sprintf(buf + len, \"%shiddev%d\", len ? \",\" : \"\",\n\t\t\t\thdev->minor);\n\tif (hdev->claimed & HID_CLAIMED_HIDRAW)\n\t\tlen += sprintf(buf + len, \"%shidraw%d\", len ? \",\" : \"\",\n\t\t\t\t((struct hidraw *)hdev->hidraw)->minor);\n\n\ttype = \"Device\";\n\tfor (i = 0; i < hdev->maxcollection; i++) {\n\t\tstruct hid_collection *col = &hdev->collection[i];\n\t\tif (col->type == HID_COLLECTION_APPLICATION &&\n\t\t   (col->usage & HID_USAGE_PAGE) == HID_UP_GENDESK &&\n\t\t   (col->usage & 0xffff) < ARRAY_SIZE(types)) {\n\t\t\ttype = types[col->usage & 0xffff];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (hdev->bus) {\n\tcase BUS_USB:\n\t\tbus = \"USB\";\n\t\tbreak;\n\tcase BUS_BLUETOOTH:\n\t\tbus = \"BLUETOOTH\";\n\t\tbreak;\n\tcase BUS_I2C:\n\t\tbus = \"I2C\";\n\t\tbreak;\n\tdefault:\n\t\tbus = \"<UNKNOWN>\";\n\t}\n\n\tret = device_create_file(&hdev->dev, &dev_attr_country);\n\tif (ret)\n\t\thid_warn(hdev,\n\t\t\t \"can't create sysfs country code attribute err: %d\\n\", ret);\n\n\thid_info(hdev, \"%s: %s HID v%x.%02x %s [%s] on %s\\n\",\n\t\t buf, bus, hdev->version >> 8, hdev->version & 0xff,\n\t\t type, hdev->name, hdev->phys);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_connect);\n\nvoid hid_disconnect(struct hid_device *hdev)\n{\n\tdevice_remove_file(&hdev->dev, &dev_attr_country);\n\tif (hdev->claimed & HID_CLAIMED_INPUT)\n\t\thidinput_disconnect(hdev);\n\tif (hdev->claimed & HID_CLAIMED_HIDDEV)\n\t\thdev->hiddev_disconnect(hdev);\n\tif (hdev->claimed & HID_CLAIMED_HIDRAW)\n\t\thidraw_disconnect(hdev);\n\thdev->claimed = 0;\n}\nEXPORT_SYMBOL_GPL(hid_disconnect);\n\n/*\n * A list of devices for which there is a specialized driver on HID bus.\n *\n * Please note that for multitouch devices (driven by hid-multitouch driver),\n * there is a proper autodetection and autoloading in place (based on presence\n * of HID_DG_CONTACTID), so those devices don't need to be added to this list,\n * as we are doing the right thing in hid_scan_usage().\n *\n * Autodetection for (USB) HID sensor hubs exists too. If a collection of type\n * physical is found inside a usage page of type sensor, hid-sensor-hub will be\n * used as a driver. See hid_scan_report().\n */\nstatic const struct hid_device_id hid_have_special_driver[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_WCP32PU) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_X5_005D) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_RP_649) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ACRUX, 0x0802) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ACRUX, 0xf705) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MIGHTYMOUSE) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICMOUSE) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICTRACKPAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_MINI_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_MINI_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_MINI_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL4) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL5) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_ISO) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_REVB_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_REVB_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_REVB_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_JIS) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AUREAL, USB_DEVICE_ID_AUREAL_W01RN) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BELKIN, USB_DEVICE_ID_FLIP_KVM) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BETOP_2185BFM, 0x2208) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BETOP_2185PC, 0x5506) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BETOP_2185V2PC, 0x1850) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BETOP_2185V2BFM, 0x5500) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BTC, USB_DEVICE_ID_BTC_EMPREX_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BTC, USB_DEVICE_ID_BTC_EMPREX_REMOTE_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHERRY, USB_DEVICE_ID_CHERRY_CYMOTION) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHERRY, USB_DEVICE_ID_CHERRY_CYMOTION_SOLAR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_TACTICAL_PAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_WIRELESS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_WIRELESS2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_AK1D) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_ACER_SWITCH12) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_K90) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CREATIVELABS, USB_DEVICE_ID_PRODIKEYS_PCMIDI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_CP2112) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_1) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_4) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_MOUSE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, 0x0006) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, 0x0011) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_BM084) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELO, 0x0009) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELO, 0x0030) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_EMS, USB_DEVICE_ID_EMS_TRIO_LINKER_PLUS_II) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_EZKEY, USB_DEVICE_ID_BTC_8193) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GAMERON, USB_DEVICE_ID_GAMERON_DUAL_PSX_ADAPTOR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GAMERON, USB_DEVICE_ID_GAMERON_DUAL_PCS_ADAPTOR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GEMBIRD, USB_DEVICE_ID_GEMBIRD_JPD_DUALFORCE2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GREENASIA, 0x0003) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GREENASIA, 0x0012) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GYRATION, USB_DEVICE_ID_GYRATION_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GYRATION, USB_DEVICE_ID_GYRATION_REMOTE_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GYRATION, USB_DEVICE_ID_GYRATION_REMOTE_3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK, USB_DEVICE_ID_HOLTEK_ON_LINE_GRIP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A04A) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A067) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A070) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A072) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A081) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A0C2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HUION, USB_DEVICE_ID_HUION_TABLET) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_JESS2, USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ION, USB_DEVICE_ID_ICADE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KENSINGTON, USB_DEVICE_ID_KS_SLIMBLADE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KEYTOUCH, USB_DEVICE_ID_KEYTOUCH_IEC) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_GENIUS_MANTICORE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_GENIUS_GX_IMPERATOR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_ERGO_525V) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_EASYPEN_I405X) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_MOUSEPEN_I608X) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_MOUSEPEN_I608X_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_EASYPEN_M610X) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_PENSKETCH_M912) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LABTEC, USB_DEVICE_ID_LABTEC_WIRELESS_KEYBOARD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LCPOWER, USB_DEVICE_ID_LCPOWER_LC1000 ) },\n#if IS_ENABLED(CONFIG_HID_LENOVO)\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_TPKBD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_CUSBKBD) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_CBTKBD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_TPPRODOCK) },\n#endif\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_MX3000_RECEIVER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_S510_RECEIVER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_S510_RECEIVER_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RECEIVER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_HARMONY_PS3) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_T651) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_DESKTOP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_EDGE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_MINI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_ELITE_KBD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_CORDLESS_DESKTOP_LX500) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_EXTREME_3D) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD_CORD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD2_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G29_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G920_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WINGMAN_F3D) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WINGMAN_FFG ) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_FORCE3D_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_FLIGHT_SYSTEM_G940) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_MOMO_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DFP_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DFGT_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G25_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G27_WHEEL) },\n#if IS_ENABLED(CONFIG_HID_LOGITECH_DJ)\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER_2) },\n#endif\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WII_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_SPACETRAVELLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_SPACENAVIGATOR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICOLCD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICOLCD_BOOTLOADER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_COMFORT_MOUSE_4500) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_SIDEWINDER_GV) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE4K) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE4K_JP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE7K) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_LK6K) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_PRESENTER_8K_USB) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_3K) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_WIRELESS_OPTICAL_DESKTOP_3_0) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_OFFICE_KB) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_JP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_POWER_COVER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MONTEREY, USB_DEVICE_ID_GENIUS_KB29E) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MSI, USB_DEVICE_ID_MSI_GT683R_LED_PANEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_1) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_4) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_5) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_6) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_7) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_8) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_9) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_10) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_11) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_12) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_13) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_14) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_15) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_16) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_17) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_18) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ORTEK, USB_DEVICE_ID_ORTEK_PKB1700) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ORTEK, USB_DEVICE_ID_ORTEK_WKB2000) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PENMOUNT, USB_DEVICE_ID_PENMOUNT_6000) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PETALYNX, USB_DEVICE_ID_PETALYNX_MAXTER_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PLANTRONICS, HID_ANY_ID) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PRIMAX, USB_DEVICE_ID_PRIMAX_KEYBOARD) },\n#if IS_ENABLED(CONFIG_HID_ROCCAT)\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ARVO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ISKU) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ISKUFX) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEPLUS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEPURE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEPURE_OPTICAL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEXTD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KOVAPLUS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_LUA) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_PYRA_WIRED) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_RYOS_MK) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_RYOS_MK_GLOW) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_RYOS_MK_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_SAVU) },\n#endif\n#if IS_ENABLED(CONFIG_HID_SAITEK)\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_PS1000) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_RAT7_OLD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_RAT7) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_MMO7) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MADCATZ, USB_DEVICE_ID_MADCATZ_RAT5) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MADCATZ, USB_DEVICE_ID_MADCATZ_RAT9) },\n#endif\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_IR_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SKYCABLE, USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SMK, USB_DEVICE_ID_SMK_PS3_BDREMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_BUZZ_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_WIRELESS_BUZZ_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_MOTION_CONTROLLER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_MOTION_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_BDREMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_VAIO_VGP_MOUSE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_STEELSERIES, USB_DEVICE_ID_STEELSERIES_SRWS1) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SUNPLUS, USB_DEVICE_ID_SUNPLUS_WDESKTOP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THINGM, USB_DEVICE_ID_BLINK1) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb300) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb304) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb323) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb324) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb651) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb653) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb654) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb65a) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_TIVO, USB_DEVICE_ID_TIVO_SLIDE_BT) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TIVO, USB_DEVICE_ID_TIVO_SLIDE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TIVO, USB_DEVICE_ID_TIVO_SLIDE_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TOPSEED, USB_DEVICE_ID_TOPSEED_CYBERLINK) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TOPSEED2, USB_DEVICE_ID_TOPSEED2_RF_COMBO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TWINHAN, USB_DEVICE_ID_TWINHAN_IR_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_PF1209) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_WP1062) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_SMARTJOY_PLUS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_SUPER_JOY_BOX_3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_DUAL_USB_JOYPAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP_LTD, USB_DEVICE_ID_SUPER_JOY_BOX_3_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP_LTD, USB_DEVICE_ID_SUPER_DUAL_BOX_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP_LTD, USB_DEVICE_ID_SUPER_JOY_BOX_5_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PLAYDOTCOM, USB_DEVICE_ID_PLAYDOTCOM_EMS_USBII) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SLIM_TABLET_5_8_INCH) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SLIM_TABLET_12_1_INCH) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_Q_PAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_PID_0038) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_MEDIA_TABLET_10_6_INCH) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_MEDIA_TABLET_14_1_INCH) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SIRIUS_BATTERY_FREE_TABLET) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_X_TENSIONS, USB_DEVICE_ID_SPEEDLINK_VAD_CEZANNE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_XIN_MO, USB_DEVICE_ID_XIN_MO_DUAL_ARCADE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ZEROPLUS, 0x0005) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ZEROPLUS, 0x0030) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ZYDACRON, USB_DEVICE_ID_ZYDACRON_REMOTE_CONTROL) },\n\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_PRESENTER_8K_BT) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_WIIMOTE) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_WIIMOTE2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_RAZER, USB_DEVICE_ID_RAZER_BLADE_14) },\n\t{ }\n};\n\nstruct hid_dynid {\n\tstruct list_head list;\n\tstruct hid_device_id id;\n};\n\n/**\n * store_new_id - add a new HID device ID to this driver and re-probe devices\n * @driver: target device driver\n * @buf: buffer for scanning device ID data\n * @count: input size\n *\n * Adds a new dynamic hid device ID to this driver,\n * and causes the driver to probe for all devices again.\n */\nstatic ssize_t store_new_id(struct device_driver *drv, const char *buf,\n\t\tsize_t count)\n{\n\tstruct hid_driver *hdrv = to_hid_driver(drv);\n\tstruct hid_dynid *dynid;\n\t__u32 bus, vendor, product;\n\tunsigned long driver_data = 0;\n\tint ret;\n\n\tret = sscanf(buf, \"%x %x %x %lx\",\n\t\t\t&bus, &vendor, &product, &driver_data);\n\tif (ret < 3)\n\t\treturn -EINVAL;\n\n\tdynid = kzalloc(sizeof(*dynid), GFP_KERNEL);\n\tif (!dynid)\n\t\treturn -ENOMEM;\n\n\tdynid->id.bus = bus;\n\tdynid->id.group = HID_GROUP_ANY;\n\tdynid->id.vendor = vendor;\n\tdynid->id.product = product;\n\tdynid->id.driver_data = driver_data;\n\n\tspin_lock(&hdrv->dyn_lock);\n\tlist_add_tail(&dynid->list, &hdrv->dyn_list);\n\tspin_unlock(&hdrv->dyn_lock);\n\n\tret = driver_attach(&hdrv->driver);\n\n\treturn ret ? : count;\n}\nstatic DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);\n\nstatic void hid_free_dynids(struct hid_driver *hdrv)\n{\n\tstruct hid_dynid *dynid, *n;\n\n\tspin_lock(&hdrv->dyn_lock);\n\tlist_for_each_entry_safe(dynid, n, &hdrv->dyn_list, list) {\n\t\tlist_del(&dynid->list);\n\t\tkfree(dynid);\n\t}\n\tspin_unlock(&hdrv->dyn_lock);\n}\n\nstatic const struct hid_device_id *hid_match_device(struct hid_device *hdev,\n\t\tstruct hid_driver *hdrv)\n{\n\tstruct hid_dynid *dynid;\n\n\tspin_lock(&hdrv->dyn_lock);\n\tlist_for_each_entry(dynid, &hdrv->dyn_list, list) {\n\t\tif (hid_match_one_id(hdev, &dynid->id)) {\n\t\t\tspin_unlock(&hdrv->dyn_lock);\n\t\t\treturn &dynid->id;\n\t\t}\n\t}\n\tspin_unlock(&hdrv->dyn_lock);\n\n\treturn hid_match_id(hdev, hdrv->id_table);\n}\n\nstatic int hid_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct hid_driver *hdrv = to_hid_driver(drv);\n\tstruct hid_device *hdev = to_hid_device(dev);\n\n\treturn hid_match_device(hdev, hdrv) != NULL;\n}\n\nstatic int hid_device_probe(struct device *dev)\n{\n\tstruct hid_driver *hdrv = to_hid_driver(dev->driver);\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tconst struct hid_device_id *id;\n\tint ret = 0;\n\n\tif (down_interruptible(&hdev->driver_lock))\n\t\treturn -EINTR;\n\tif (down_interruptible(&hdev->driver_input_lock)) {\n\t\tret = -EINTR;\n\t\tgoto unlock_driver_lock;\n\t}\n\thdev->io_started = false;\n\n\tif (!hdev->driver) {\n\t\tid = hid_match_device(hdev, hdrv);\n\t\tif (id == NULL) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\thdev->driver = hdrv;\n\t\tif (hdrv->probe) {\n\t\t\tret = hdrv->probe(hdev, id);\n\t\t} else { /* default probe */\n\t\t\tret = hid_open_report(hdev);\n\t\t\tif (!ret)\n\t\t\t\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t\t}\n\t\tif (ret) {\n\t\t\thid_close_report(hdev);\n\t\t\thdev->driver = NULL;\n\t\t}\n\t}\nunlock:\n\tif (!hdev->io_started)\n\t\tup(&hdev->driver_input_lock);\nunlock_driver_lock:\n\tup(&hdev->driver_lock);\n\treturn ret;\n}\n\nstatic int hid_device_remove(struct device *dev)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct hid_driver *hdrv;\n\tint ret = 0;\n\n\tif (down_interruptible(&hdev->driver_lock))\n\t\treturn -EINTR;\n\tif (down_interruptible(&hdev->driver_input_lock)) {\n\t\tret = -EINTR;\n\t\tgoto unlock_driver_lock;\n\t}\n\thdev->io_started = false;\n\n\thdrv = hdev->driver;\n\tif (hdrv) {\n\t\tif (hdrv->remove)\n\t\t\thdrv->remove(hdev);\n\t\telse /* default remove */\n\t\t\thid_hw_stop(hdev);\n\t\thid_close_report(hdev);\n\t\thdev->driver = NULL;\n\t}\n\n\tif (!hdev->io_started)\n\t\tup(&hdev->driver_input_lock);\nunlock_driver_lock:\n\tup(&hdev->driver_lock);\n\treturn ret;\n}\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *a,\n\t\t\t     char *buf)\n{\n\tstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"hid:b%04Xg%04Xv%08Xp%08X\\n\",\n\t\t\t hdev->bus, hdev->group, hdev->vendor, hdev->product);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *hid_dev_attrs[] = {\n\t&dev_attr_modalias.attr,\n\tNULL,\n};\nstatic struct bin_attribute *hid_dev_bin_attrs[] = {\n\t&dev_bin_attr_report_desc,\n\tNULL\n};\nstatic const struct attribute_group hid_dev_group = {\n\t.attrs = hid_dev_attrs,\n\t.bin_attrs = hid_dev_bin_attrs,\n};\n__ATTRIBUTE_GROUPS(hid_dev);\n\nstatic int hid_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\t\n\n\tif (add_uevent_var(env, \"HID_ID=%04X:%08X:%08X\",\n\t\t\thdev->bus, hdev->vendor, hdev->product))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"HID_NAME=%s\", hdev->name))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"HID_PHYS=%s\", hdev->phys))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"HID_UNIQ=%s\", hdev->uniq))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"MODALIAS=hid:b%04Xg%04Xv%08Xp%08X\",\n\t\t\t   hdev->bus, hdev->group, hdev->vendor, hdev->product))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic struct bus_type hid_bus_type = {\n\t.name\t\t= \"hid\",\n\t.dev_groups\t= hid_dev_groups,\n\t.match\t\t= hid_bus_match,\n\t.probe\t\t= hid_device_probe,\n\t.remove\t\t= hid_device_remove,\n\t.uevent\t\t= hid_uevent,\n};\n\n/* a list of devices that shouldn't be handled by HID core at all */\nstatic const struct hid_device_id hid_ignore_list[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ACECAD, USB_DEVICE_ID_ACECAD_FLAIR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ACECAD, USB_DEVICE_ID_ACECAD_302) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ADS_TECH, USB_DEVICE_ID_ADS_TECH_RADIO_SI470X) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_01) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_10) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_20) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_21) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_22) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_23) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_24) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIRCABLE, USB_DEVICE_ID_AIRCABLE1) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ALCOR, USB_DEVICE_ID_ALCOR_USBRS232) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_LCM)},\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_LCM2)},\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AVERMEDIA, USB_DEVICE_ID_AVER_FM_MR800) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AXENTIA, USB_DEVICE_ID_AXENTIA_FM_RADIO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BERKSHIRE, USB_DEVICE_ID_BERKSHIRE_PCWD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CIDC, 0x0103) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_RADIO_SI470X) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_RADIO_SI4713) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CMEDIA, USB_DEVICE_ID_CM109) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_HIDCOM) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_ULTRAMOUSE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DEALEXTREAME, USB_DEVICE_ID_DEALEXTREAME_RADIO_SI4701) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DELORME, USB_DEVICE_ID_DELORME_EARTHMATE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DELORME, USB_DEVICE_ID_DELORME_EM_LT20) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DREAM_CHEEKY, 0x0004) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DREAM_CHEEKY, 0x000a) },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, 0x0400) },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, 0x0401) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ESSENTIAL_REALITY, USB_DEVICE_ID_ESSENTIAL_REALITY_P5) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ETT, USB_DEVICE_ID_TC5UH) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ETT, USB_DEVICE_ID_TC4UM) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH, 0x0001) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH, 0x0002) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH, 0x0004) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GOTOP, USB_DEVICE_ID_SUPER_Q2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GOTOP, USB_DEVICE_ID_GOGOPEN) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GOTOP, USB_DEVICE_ID_PENPOWER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GRETAGMACBETH, USB_DEVICE_ID_GRETAGMACBETH_HUEY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_POWERMATE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_SOUNDKNOB) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_RADIOSHARK) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_90) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_100) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_101) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_103) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_104) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_105) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_106) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_107) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_108) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_200) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_201) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_202) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_203) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_204) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_205) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_206) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_207) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_300) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_301) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_302) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_303) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_304) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_305) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_306) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_307) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_308) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_309) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_400) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_401) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_402) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_403) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_404) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_405) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_500) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_501) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_502) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_503) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_504) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1000) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1001) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1002) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1003) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1004) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1005) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1006) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1007) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_IMATION, USB_DEVICE_ID_DISC_STAKKA) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_JABRA, USB_DEVICE_ID_JABRA_SPEAK_410) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_JABRA, USB_DEVICE_ID_JABRA_SPEAK_510) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_JABRA, USB_DEVICE_ID_JABRA_GN9350E) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KBGEAR, USB_DEVICE_ID_KBGEAR_JAMSTUDIO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KWORLD, USB_DEVICE_ID_KWORLD_RADIO_FM700) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_GPEN_560) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_KYE, 0x0058) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_CASSY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_CASSY2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_POCKETCASSY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_POCKETCASSY2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOBILECASSY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOBILECASSY2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYVOLTAGE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYCURRENT) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYTIME) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYTEMPERATURE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYPH) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_JWM) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_DMMP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_UMIP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_UMIC) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_UMIB) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_XRAY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_XRAY2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_VIDEOCOM) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOTOR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_COM3LAB) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_TELEPORT) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_NETWORKANALYSER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_POWERCONTROL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MACHINETEST) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOSTANALYSER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOSTANALYSER2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_ABSESP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_AUTODATABUS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MCT) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_HYBRID) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_HEATCONTROL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MADCATZ, USB_DEVICE_ID_MADCATZ_BEATPAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MCC, USB_DEVICE_ID_MCC_PMD1024LS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MCC, USB_DEVICE_ID_MCC_PMD1208LS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICKIT1) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICKIT2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICK16F1454) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICK16F1454_V2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NATIONAL_SEMICONDUCTOR, USB_DEVICE_ID_N_S_HARMONY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 20) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 30) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 100) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 108) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 118) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 200) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 300) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 400) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 500) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0001) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0002) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0003) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0004) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PHILIPS, USB_DEVICE_ID_PHILIPS_IEEE802154_DONGLE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_POWERCOM, USB_DEVICE_ID_POWERCOM_UPS) },\n#if defined(CONFIG_MOUSE_SYNAPTICS_USB) || defined(CONFIG_MOUSE_SYNAPTICS_USB_MODULE)\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_TP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_INT_TP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_CPAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_STICK) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_WP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_COMP_TP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_WTP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_DPAD) },\n#endif\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_YEALINK, USB_DEVICE_ID_YEALINK_P1K_P4K_B2K) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_RISO_KAGAKU, USB_DEVICE_ID_RI_KA_WEBMAIL) },\n\t{ }\n};\n\n/**\n * hid_mouse_ignore_list - mouse devices which should not be handled by the hid layer\n *\n * There are composite devices for which we want to ignore only a certain\n * interface. This is a list of devices for which only the mouse interface will\n * be ignored. This allows a dedicated driver to take care of the interface.\n */\nstatic const struct hid_device_id hid_mouse_ignore_list[] = {\n\t/* appletouch driver */\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY) },\n\t{ }\n};\n\nbool hid_ignore(struct hid_device *hdev)\n{\n\tif (hdev->quirks & HID_QUIRK_NO_IGNORE)\n\t\treturn false;\n\tif (hdev->quirks & HID_QUIRK_IGNORE)\n\t\treturn true;\n\n\tswitch (hdev->vendor) {\n\tcase USB_VENDOR_ID_CODEMERCS:\n\t\t/* ignore all Code Mercenaries IOWarrior devices */\n\t\tif (hdev->product >= USB_DEVICE_ID_CODEMERCS_IOW_FIRST &&\n\t\t\t\thdev->product <= USB_DEVICE_ID_CODEMERCS_IOW_LAST)\n\t\t\treturn true;\n\t\tbreak;\n\tcase USB_VENDOR_ID_LOGITECH:\n\t\tif (hdev->product >= USB_DEVICE_ID_LOGITECH_HARMONY_FIRST &&\n\t\t\t\thdev->product <= USB_DEVICE_ID_LOGITECH_HARMONY_LAST)\n\t\t\treturn true;\n\t\t/*\n\t\t * The Keene FM transmitter USB device has the same USB ID as\n\t\t * the Logitech AudioHub Speaker, but it should ignore the hid.\n\t\t * Check if the name is that of the Keene device.\n\t\t * For reference: the name of the AudioHub is\n\t\t * \"HOLTEK  AudioHub Speaker\".\n\t\t */\n\t\tif (hdev->product == USB_DEVICE_ID_LOGITECH_AUDIOHUB &&\n\t\t\t!strcmp(hdev->name, \"HOLTEK  B-LINK USB Audio  \"))\n\t\t\t\treturn true;\n\t\tbreak;\n\tcase USB_VENDOR_ID_SOUNDGRAPH:\n\t\tif (hdev->product >= USB_DEVICE_ID_SOUNDGRAPH_IMON_FIRST &&\n\t\t    hdev->product <= USB_DEVICE_ID_SOUNDGRAPH_IMON_LAST)\n\t\t\treturn true;\n\t\tbreak;\n\tcase USB_VENDOR_ID_HANWANG:\n\t\tif (hdev->product >= USB_DEVICE_ID_HANWANG_TABLET_FIRST &&\n\t\t    hdev->product <= USB_DEVICE_ID_HANWANG_TABLET_LAST)\n\t\t\treturn true;\n\t\tbreak;\n\tcase USB_VENDOR_ID_JESS:\n\t\tif (hdev->product == USB_DEVICE_ID_JESS_YUREX &&\n\t\t\t\thdev->type == HID_TYPE_USBNONE)\n\t\t\treturn true;\n\t\tbreak;\n\tcase USB_VENDOR_ID_VELLEMAN:\n\t\t/* These are not HID devices.  They are handled by comedi. */\n\t\tif ((hdev->product >= USB_DEVICE_ID_VELLEMAN_K8055_FIRST &&\n\t\t     hdev->product <= USB_DEVICE_ID_VELLEMAN_K8055_LAST) ||\n\t\t    (hdev->product >= USB_DEVICE_ID_VELLEMAN_K8061_FIRST &&\n\t\t     hdev->product <= USB_DEVICE_ID_VELLEMAN_K8061_LAST))\n\t\t\treturn true;\n\t\tbreak;\n\tcase USB_VENDOR_ID_ATMEL_V_USB:\n\t\t/* Masterkit MA901 usb radio based on Atmel tiny85 chip and\n\t\t * it has the same USB ID as many Atmel V-USB devices. This\n\t\t * usb radio is handled by radio-ma901.c driver so we want\n\t\t * ignore the hid. Check the name, bus, product and ignore\n\t\t * if we have MA901 usb radio.\n\t\t */\n\t\tif (hdev->product == USB_DEVICE_ID_ATMEL_V_USB &&\n\t\t\thdev->bus == BUS_USB &&\n\t\t\tstrncmp(hdev->name, \"www.masterkit.ru MA901\", 22) == 0)\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\n\tif (hdev->type == HID_TYPE_USBMOUSE &&\n\t\t\thid_match_id(hdev, hid_mouse_ignore_list))\n\t\treturn true;\n\n\treturn !!hid_match_id(hdev, hid_ignore_list);\n}\nEXPORT_SYMBOL_GPL(hid_ignore);\n\nint hid_add_device(struct hid_device *hdev)\n{\n\tstatic atomic_t id = ATOMIC_INIT(0);\n\tint ret;\n\n\tif (WARN_ON(hdev->status & HID_STAT_ADDED))\n\t\treturn -EBUSY;\n\n\t/* we need to kill them here, otherwise they will stay allocated to\n\t * wait for coming driver */\n\tif (hid_ignore(hdev))\n\t\treturn -ENODEV;\n\n\t/*\n\t * Check for the mandatory transport channel.\n\t */\n\t if (!hdev->ll_driver->raw_request) {\n\t\thid_err(hdev, \"transport driver missing .raw_request()\\n\");\n\t\treturn -EINVAL;\n\t }\n\n\t/*\n\t * Read the device report descriptor once and use as template\n\t * for the driver-specific modifications.\n\t */\n\tret = hdev->ll_driver->parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\tif (!hdev->dev_rdesc)\n\t\treturn -ENODEV;\n\n\t/*\n\t * Scan generic devices for group information\n\t */\n\tif (hid_ignore_special_drivers ||\n\t    (!hdev->group &&\n\t     !hid_match_id(hdev, hid_have_special_driver))) {\n\t\tret = hid_scan_report(hdev);\n\t\tif (ret)\n\t\t\thid_warn(hdev, \"bad device descriptor (%d)\\n\", ret);\n\t}\n\n\t/* XXX hack, any other cleaner solution after the driver core\n\t * is converted to allow more than 20 bytes as the device name? */\n\tdev_set_name(&hdev->dev, \"%04X:%04X:%04X.%04X\", hdev->bus,\n\t\t     hdev->vendor, hdev->product, atomic_inc_return(&id));\n\n\thid_debug_register(hdev, dev_name(&hdev->dev));\n\tret = device_add(&hdev->dev);\n\tif (!ret)\n\t\thdev->status |= HID_STAT_ADDED;\n\telse\n\t\thid_debug_unregister(hdev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_add_device);\n\n/**\n * hid_allocate_device - allocate new hid device descriptor\n *\n * Allocate and initialize hid device, so that hid_destroy_device might be\n * used to free it.\n *\n * New hid_device pointer is returned on success, otherwise ERR_PTR encoded\n * error value.\n */\nstruct hid_device *hid_allocate_device(void)\n{\n\tstruct hid_device *hdev;\n\tint ret = -ENOMEM;\n\n\thdev = kzalloc(sizeof(*hdev), GFP_KERNEL);\n\tif (hdev == NULL)\n\t\treturn ERR_PTR(ret);\n\n\tdevice_initialize(&hdev->dev);\n\thdev->dev.release = hid_device_release;\n\thdev->dev.bus = &hid_bus_type;\n\tdevice_enable_async_suspend(&hdev->dev);\n\n\thid_close_report(hdev);\n\n\tinit_waitqueue_head(&hdev->debug_wait);\n\tINIT_LIST_HEAD(&hdev->debug_list);\n\tspin_lock_init(&hdev->debug_list_lock);\n\tsema_init(&hdev->driver_lock, 1);\n\tsema_init(&hdev->driver_input_lock, 1);\n\n\treturn hdev;\n}\nEXPORT_SYMBOL_GPL(hid_allocate_device);\n\nstatic void hid_remove_device(struct hid_device *hdev)\n{\n\tif (hdev->status & HID_STAT_ADDED) {\n\t\tdevice_del(&hdev->dev);\n\t\thid_debug_unregister(hdev);\n\t\thdev->status &= ~HID_STAT_ADDED;\n\t}\n\tkfree(hdev->dev_rdesc);\n\thdev->dev_rdesc = NULL;\n\thdev->dev_rsize = 0;\n}\n\n/**\n * hid_destroy_device - free previously allocated device\n *\n * @hdev: hid device\n *\n * If you allocate hid_device through hid_allocate_device, you should ever\n * free by this function.\n */\nvoid hid_destroy_device(struct hid_device *hdev)\n{\n\thid_remove_device(hdev);\n\tput_device(&hdev->dev);\n}\nEXPORT_SYMBOL_GPL(hid_destroy_device);\n\nint __hid_register_driver(struct hid_driver *hdrv, struct module *owner,\n\t\tconst char *mod_name)\n{\n\tint ret;\n\n\thdrv->driver.name = hdrv->name;\n\thdrv->driver.bus = &hid_bus_type;\n\thdrv->driver.owner = owner;\n\thdrv->driver.mod_name = mod_name;\n\n\tINIT_LIST_HEAD(&hdrv->dyn_list);\n\tspin_lock_init(&hdrv->dyn_lock);\n\n\tret = driver_register(&hdrv->driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = driver_create_file(&hdrv->driver, &driver_attr_new_id);\n\tif (ret)\n\t\tdriver_unregister(&hdrv->driver);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__hid_register_driver);\n\nvoid hid_unregister_driver(struct hid_driver *hdrv)\n{\n\tdriver_remove_file(&hdrv->driver, &driver_attr_new_id);\n\tdriver_unregister(&hdrv->driver);\n\thid_free_dynids(hdrv);\n}\nEXPORT_SYMBOL_GPL(hid_unregister_driver);\n\nint hid_check_keys_pressed(struct hid_device *hid)\n{\n\tstruct hid_input *hidinput;\n\tint i;\n\n\tif (!(hid->claimed & HID_CLAIMED_INPUT))\n\t\treturn 0;\n\n\tlist_for_each_entry(hidinput, &hid->inputs, list) {\n\t\tfor (i = 0; i < BITS_TO_LONGS(KEY_MAX); i++)\n\t\t\tif (hidinput->input->key[i])\n\t\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(hid_check_keys_pressed);\n\nstatic int __init hid_init(void)\n{\n\tint ret;\n\n\tif (hid_debug)\n\t\tpr_warn(\"hid_debug is now used solely for parser and driver debugging.\\n\"\n\t\t\t\"debugfs is now used for inspecting the device (report descriptor, reports)\\n\");\n\n\tret = bus_register(&hid_bus_type);\n\tif (ret) {\n\t\tpr_err(\"can't register hid bus\\n\");\n\t\tgoto err;\n\t}\n\n\tret = hidraw_init();\n\tif (ret)\n\t\tgoto err_bus;\n\n\thid_debug_init();\n\n\treturn 0;\nerr_bus:\n\tbus_unregister(&hid_bus_type);\nerr:\n\treturn ret;\n}\n\nstatic void __exit hid_exit(void)\n{\n\thid_debug_exit();\n\thidraw_exit();\n\tbus_unregister(&hid_bus_type);\n}\n\nmodule_init(hid_init);\nmodule_exit(hid_exit);\n\nMODULE_AUTHOR(\"Andreas Gal\");\nMODULE_AUTHOR(\"Vojtech Pavlik\");\nMODULE_AUTHOR(\"Jiri Kosina\");\nMODULE_LICENSE(DRIVER_LICENSE);\n\n"], "fixing_code": ["/*\n *  HID support for Linux\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2012 Jiri Kosina\n */\n\n/*\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/input.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/sched.h>\n#include <linux/semaphore.h>\n\n#include <linux/hid.h>\n#include <linux/hiddev.h>\n#include <linux/hid-debug.h>\n#include <linux/hidraw.h>\n\n#include \"hid-ids.h\"\n\n/*\n * Version Information\n */\n\n#define DRIVER_DESC \"HID core driver\"\n#define DRIVER_LICENSE \"GPL\"\n\nint hid_debug = 0;\nmodule_param_named(debug, hid_debug, int, 0600);\nMODULE_PARM_DESC(debug, \"toggle HID debugging messages\");\nEXPORT_SYMBOL_GPL(hid_debug);\n\nstatic int hid_ignore_special_drivers = 0;\nmodule_param_named(ignore_special_drivers, hid_ignore_special_drivers, int, 0600);\nMODULE_PARM_DESC(ignore_special_drivers, \"Ignore any special drivers and handle all devices by generic driver\");\n\n/*\n * Register a new report for a device.\n */\n\nstruct hid_report *hid_register_report(struct hid_device *device, unsigned type, unsigned id)\n{\n\tstruct hid_report_enum *report_enum = device->report_enum + type;\n\tstruct hid_report *report;\n\n\tif (id >= HID_MAX_IDS)\n\t\treturn NULL;\n\tif (report_enum->report_id_hash[id])\n\t\treturn report_enum->report_id_hash[id];\n\n\treport = kzalloc(sizeof(struct hid_report), GFP_KERNEL);\n\tif (!report)\n\t\treturn NULL;\n\n\tif (id != 0)\n\t\treport_enum->numbered = 1;\n\n\treport->id = id;\n\treport->type = type;\n\treport->size = 0;\n\treport->device = device;\n\treport_enum->report_id_hash[id] = report;\n\n\tlist_add_tail(&report->list, &report_enum->report_list);\n\n\treturn report;\n}\nEXPORT_SYMBOL_GPL(hid_register_report);\n\n/*\n * Register a new field for this report.\n */\n\nstatic struct hid_field *hid_register_field(struct hid_report *report, unsigned usages, unsigned values)\n{\n\tstruct hid_field *field;\n\n\tif (report->maxfield == HID_MAX_FIELDS) {\n\t\thid_err(report->device, \"too many fields in report\\n\");\n\t\treturn NULL;\n\t}\n\n\tfield = kzalloc((sizeof(struct hid_field) +\n\t\t\t usages * sizeof(struct hid_usage) +\n\t\t\t values * sizeof(unsigned)), GFP_KERNEL);\n\tif (!field)\n\t\treturn NULL;\n\n\tfield->index = report->maxfield++;\n\treport->field[field->index] = field;\n\tfield->usage = (struct hid_usage *)(field + 1);\n\tfield->value = (s32 *)(field->usage + usages);\n\tfield->report = report;\n\n\treturn field;\n}\n\n/*\n * Open a collection. The type/usage is pushed on the stack.\n */\n\nstatic int open_collection(struct hid_parser *parser, unsigned type)\n{\n\tstruct hid_collection *collection;\n\tunsigned usage;\n\n\tusage = parser->local.usage[0];\n\n\tif (parser->collection_stack_ptr == HID_COLLECTION_STACK_SIZE) {\n\t\thid_err(parser->device, \"collection stack overflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (parser->device->maxcollection == parser->device->collection_size) {\n\t\tcollection = kmalloc(sizeof(struct hid_collection) *\n\t\t\t\tparser->device->collection_size * 2, GFP_KERNEL);\n\t\tif (collection == NULL) {\n\t\t\thid_err(parser->device, \"failed to reallocate collection array\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(collection, parser->device->collection,\n\t\t\tsizeof(struct hid_collection) *\n\t\t\tparser->device->collection_size);\n\t\tmemset(collection + parser->device->collection_size, 0,\n\t\t\tsizeof(struct hid_collection) *\n\t\t\tparser->device->collection_size);\n\t\tkfree(parser->device->collection);\n\t\tparser->device->collection = collection;\n\t\tparser->device->collection_size *= 2;\n\t}\n\n\tparser->collection_stack[parser->collection_stack_ptr++] =\n\t\tparser->device->maxcollection;\n\n\tcollection = parser->device->collection +\n\t\tparser->device->maxcollection++;\n\tcollection->type = type;\n\tcollection->usage = usage;\n\tcollection->level = parser->collection_stack_ptr - 1;\n\n\tif (type == HID_COLLECTION_APPLICATION)\n\t\tparser->device->maxapplication++;\n\n\treturn 0;\n}\n\n/*\n * Close a collection.\n */\n\nstatic int close_collection(struct hid_parser *parser)\n{\n\tif (!parser->collection_stack_ptr) {\n\t\thid_err(parser->device, \"collection stack underflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\tparser->collection_stack_ptr--;\n\treturn 0;\n}\n\n/*\n * Climb up the stack, search for the specified collection type\n * and return the usage.\n */\n\nstatic unsigned hid_lookup_collection(struct hid_parser *parser, unsigned type)\n{\n\tstruct hid_collection *collection = parser->device->collection;\n\tint n;\n\n\tfor (n = parser->collection_stack_ptr - 1; n >= 0; n--) {\n\t\tunsigned index = parser->collection_stack[n];\n\t\tif (collection[index].type == type)\n\t\t\treturn collection[index].usage;\n\t}\n\treturn 0; /* we know nothing about this usage type */\n}\n\n/*\n * Add a usage to the temporary parser table.\n */\n\nstatic int hid_add_usage(struct hid_parser *parser, unsigned usage)\n{\n\tif (parser->local.usage_index >= HID_MAX_USAGES) {\n\t\thid_err(parser->device, \"usage index exceeded\\n\");\n\t\treturn -1;\n\t}\n\tparser->local.usage[parser->local.usage_index] = usage;\n\tparser->local.collection_index[parser->local.usage_index] =\n\t\tparser->collection_stack_ptr ?\n\t\tparser->collection_stack[parser->collection_stack_ptr - 1] : 0;\n\tparser->local.usage_index++;\n\treturn 0;\n}\n\n/*\n * Register a new field for this report.\n */\n\nstatic int hid_add_field(struct hid_parser *parser, unsigned report_type, unsigned flags)\n{\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tunsigned usages;\n\tunsigned offset;\n\tunsigned i;\n\n\treport = hid_register_report(parser->device, report_type, parser->global.report_id);\n\tif (!report) {\n\t\thid_err(parser->device, \"hid_register_report failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Handle both signed and unsigned cases properly */\n\tif ((parser->global.logical_minimum < 0 &&\n\t\tparser->global.logical_maximum <\n\t\tparser->global.logical_minimum) ||\n\t\t(parser->global.logical_minimum >= 0 &&\n\t\t(__u32)parser->global.logical_maximum <\n\t\t(__u32)parser->global.logical_minimum)) {\n\t\tdbg_hid(\"logical range invalid 0x%x 0x%x\\n\",\n\t\t\tparser->global.logical_minimum,\n\t\t\tparser->global.logical_maximum);\n\t\treturn -1;\n\t}\n\n\toffset = report->size;\n\treport->size += parser->global.report_size * parser->global.report_count;\n\n\tif (!parser->local.usage_index) /* Ignore padding fields */\n\t\treturn 0;\n\n\tusages = max_t(unsigned, parser->local.usage_index,\n\t\t\t\t parser->global.report_count);\n\n\tfield = hid_register_field(report, usages, parser->global.report_count);\n\tif (!field)\n\t\treturn 0;\n\n\tfield->physical = hid_lookup_collection(parser, HID_COLLECTION_PHYSICAL);\n\tfield->logical = hid_lookup_collection(parser, HID_COLLECTION_LOGICAL);\n\tfield->application = hid_lookup_collection(parser, HID_COLLECTION_APPLICATION);\n\n\tfor (i = 0; i < usages; i++) {\n\t\tunsigned j = i;\n\t\t/* Duplicate the last usage we parsed if we have excess values */\n\t\tif (i >= parser->local.usage_index)\n\t\t\tj = parser->local.usage_index - 1;\n\t\tfield->usage[i].hid = parser->local.usage[j];\n\t\tfield->usage[i].collection_index =\n\t\t\tparser->local.collection_index[j];\n\t\tfield->usage[i].usage_index = i;\n\t}\n\n\tfield->maxusage = usages;\n\tfield->flags = flags;\n\tfield->report_offset = offset;\n\tfield->report_type = report_type;\n\tfield->report_size = parser->global.report_size;\n\tfield->report_count = parser->global.report_count;\n\tfield->logical_minimum = parser->global.logical_minimum;\n\tfield->logical_maximum = parser->global.logical_maximum;\n\tfield->physical_minimum = parser->global.physical_minimum;\n\tfield->physical_maximum = parser->global.physical_maximum;\n\tfield->unit_exponent = parser->global.unit_exponent;\n\tfield->unit = parser->global.unit;\n\n\treturn 0;\n}\n\n/*\n * Read data value from item.\n */\n\nstatic u32 item_udata(struct hid_item *item)\n{\n\tswitch (item->size) {\n\tcase 1: return item->data.u8;\n\tcase 2: return item->data.u16;\n\tcase 4: return item->data.u32;\n\t}\n\treturn 0;\n}\n\nstatic s32 item_sdata(struct hid_item *item)\n{\n\tswitch (item->size) {\n\tcase 1: return item->data.s8;\n\tcase 2: return item->data.s16;\n\tcase 4: return item->data.s32;\n\t}\n\treturn 0;\n}\n\n/*\n * Process a global item.\n */\n\nstatic int hid_parser_global(struct hid_parser *parser, struct hid_item *item)\n{\n\t__s32 raw_value;\n\tswitch (item->tag) {\n\tcase HID_GLOBAL_ITEM_TAG_PUSH:\n\n\t\tif (parser->global_stack_ptr == HID_GLOBAL_STACK_SIZE) {\n\t\t\thid_err(parser->device, \"global environment stack overflow\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(parser->global_stack + parser->global_stack_ptr++,\n\t\t\t&parser->global, sizeof(struct hid_global));\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_POP:\n\n\t\tif (!parser->global_stack_ptr) {\n\t\t\thid_err(parser->device, \"global environment stack underflow\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(&parser->global, parser->global_stack +\n\t\t\t--parser->global_stack_ptr, sizeof(struct hid_global));\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_USAGE_PAGE:\n\t\tparser->global.usage_page = item_udata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_LOGICAL_MINIMUM:\n\t\tparser->global.logical_minimum = item_sdata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_LOGICAL_MAXIMUM:\n\t\tif (parser->global.logical_minimum < 0)\n\t\t\tparser->global.logical_maximum = item_sdata(item);\n\t\telse\n\t\t\tparser->global.logical_maximum = item_udata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_PHYSICAL_MINIMUM:\n\t\tparser->global.physical_minimum = item_sdata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_PHYSICAL_MAXIMUM:\n\t\tif (parser->global.physical_minimum < 0)\n\t\t\tparser->global.physical_maximum = item_sdata(item);\n\t\telse\n\t\t\tparser->global.physical_maximum = item_udata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT:\n\t\t/* Many devices provide unit exponent as a two's complement\n\t\t * nibble due to the common misunderstanding of HID\n\t\t * specification 1.11, 6.2.2.7 Global Items. Attempt to handle\n\t\t * both this and the standard encoding. */\n\t\traw_value = item_sdata(item);\n\t\tif (!(raw_value & 0xfffffff0))\n\t\t\tparser->global.unit_exponent = hid_snto32(raw_value, 4);\n\t\telse\n\t\t\tparser->global.unit_exponent = raw_value;\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_UNIT:\n\t\tparser->global.unit = item_udata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_SIZE:\n\t\tparser->global.report_size = item_udata(item);\n\t\tif (parser->global.report_size > 128) {\n\t\t\thid_err(parser->device, \"invalid report_size %d\\n\",\n\t\t\t\t\tparser->global.report_size);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_COUNT:\n\t\tparser->global.report_count = item_udata(item);\n\t\tif (parser->global.report_count > HID_MAX_USAGES) {\n\t\t\thid_err(parser->device, \"invalid report_count %d\\n\",\n\t\t\t\t\tparser->global.report_count);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_ID:\n\t\tparser->global.report_id = item_udata(item);\n\t\tif (parser->global.report_id == 0 ||\n\t\t    parser->global.report_id >= HID_MAX_IDS) {\n\t\t\thid_err(parser->device, \"report_id %u is invalid\\n\",\n\t\t\t\tparser->global.report_id);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\thid_err(parser->device, \"unknown global tag 0x%x\\n\", item->tag);\n\t\treturn -1;\n\t}\n}\n\n/*\n * Process a local item.\n */\n\nstatic int hid_parser_local(struct hid_parser *parser, struct hid_item *item)\n{\n\t__u32 data;\n\tunsigned n;\n\t__u32 count;\n\n\tdata = item_udata(item);\n\n\tswitch (item->tag) {\n\tcase HID_LOCAL_ITEM_TAG_DELIMITER:\n\n\t\tif (data) {\n\t\t\t/*\n\t\t\t * We treat items before the first delimiter\n\t\t\t * as global to all usage sets (branch 0).\n\t\t\t * In the moment we process only these global\n\t\t\t * items and the first delimiter set.\n\t\t\t */\n\t\t\tif (parser->local.delimiter_depth != 0) {\n\t\t\t\thid_err(parser->device, \"nested delimiters\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tparser->local.delimiter_depth++;\n\t\t\tparser->local.delimiter_branch++;\n\t\t} else {\n\t\t\tif (parser->local.delimiter_depth < 1) {\n\t\t\t\thid_err(parser->device, \"bogus close delimiter\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tparser->local.delimiter_depth--;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_LOCAL_ITEM_TAG_USAGE:\n\n\t\tif (parser->local.delimiter_branch > 1) {\n\t\t\tdbg_hid(\"alternative usage ignored\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (item->size <= 2)\n\t\t\tdata = (parser->global.usage_page << 16) + data;\n\n\t\treturn hid_add_usage(parser, data);\n\n\tcase HID_LOCAL_ITEM_TAG_USAGE_MINIMUM:\n\n\t\tif (parser->local.delimiter_branch > 1) {\n\t\t\tdbg_hid(\"alternative usage ignored\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (item->size <= 2)\n\t\t\tdata = (parser->global.usage_page << 16) + data;\n\n\t\tparser->local.usage_minimum = data;\n\t\treturn 0;\n\n\tcase HID_LOCAL_ITEM_TAG_USAGE_MAXIMUM:\n\n\t\tif (parser->local.delimiter_branch > 1) {\n\t\t\tdbg_hid(\"alternative usage ignored\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (item->size <= 2)\n\t\t\tdata = (parser->global.usage_page << 16) + data;\n\n\t\tcount = data - parser->local.usage_minimum;\n\t\tif (count + parser->local.usage_index >= HID_MAX_USAGES) {\n\t\t\t/*\n\t\t\t * We do not warn if the name is not set, we are\n\t\t\t * actually pre-scanning the device.\n\t\t\t */\n\t\t\tif (dev_name(&parser->device->dev))\n\t\t\t\thid_warn(parser->device,\n\t\t\t\t\t \"ignoring exceeding usage max\\n\");\n\t\t\tdata = HID_MAX_USAGES - parser->local.usage_index +\n\t\t\t\tparser->local.usage_minimum - 1;\n\t\t\tif (data <= 0) {\n\t\t\t\thid_err(parser->device,\n\t\t\t\t\t\"no more usage index available\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (n = parser->local.usage_minimum; n <= data; n++)\n\t\t\tif (hid_add_usage(parser, n)) {\n\t\t\t\tdbg_hid(\"hid_add_usage failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\treturn 0;\n\n\tdefault:\n\n\t\tdbg_hid(\"unknown local item tag 0x%x\\n\", item->tag);\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n/*\n * Process a main item.\n */\n\nstatic int hid_parser_main(struct hid_parser *parser, struct hid_item *item)\n{\n\t__u32 data;\n\tint ret;\n\n\tdata = item_udata(item);\n\n\tswitch (item->tag) {\n\tcase HID_MAIN_ITEM_TAG_BEGIN_COLLECTION:\n\t\tret = open_collection(parser, data & 0xff);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_END_COLLECTION:\n\t\tret = close_collection(parser);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_INPUT:\n\t\tret = hid_add_field(parser, HID_INPUT_REPORT, data);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_OUTPUT:\n\t\tret = hid_add_field(parser, HID_OUTPUT_REPORT, data);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_FEATURE:\n\t\tret = hid_add_field(parser, HID_FEATURE_REPORT, data);\n\t\tbreak;\n\tdefault:\n\t\thid_err(parser->device, \"unknown main item tag 0x%x\\n\", item->tag);\n\t\tret = 0;\n\t}\n\n\tmemset(&parser->local, 0, sizeof(parser->local));\t/* Reset the local parser environment */\n\n\treturn ret;\n}\n\n/*\n * Process a reserved item.\n */\n\nstatic int hid_parser_reserved(struct hid_parser *parser, struct hid_item *item)\n{\n\tdbg_hid(\"reserved item type, tag 0x%x\\n\", item->tag);\n\treturn 0;\n}\n\n/*\n * Free a report and all registered fields. The field->usage and\n * field->value table's are allocated behind the field, so we need\n * only to free(field) itself.\n */\n\nstatic void hid_free_report(struct hid_report *report)\n{\n\tunsigned n;\n\n\tfor (n = 0; n < report->maxfield; n++)\n\t\tkfree(report->field[n]);\n\tkfree(report);\n}\n\n/*\n * Close report. This function returns the device\n * state to the point prior to hid_open_report().\n */\nstatic void hid_close_report(struct hid_device *device)\n{\n\tunsigned i, j;\n\n\tfor (i = 0; i < HID_REPORT_TYPES; i++) {\n\t\tstruct hid_report_enum *report_enum = device->report_enum + i;\n\n\t\tfor (j = 0; j < HID_MAX_IDS; j++) {\n\t\t\tstruct hid_report *report = report_enum->report_id_hash[j];\n\t\t\tif (report)\n\t\t\t\thid_free_report(report);\n\t\t}\n\t\tmemset(report_enum, 0, sizeof(*report_enum));\n\t\tINIT_LIST_HEAD(&report_enum->report_list);\n\t}\n\n\tkfree(device->rdesc);\n\tdevice->rdesc = NULL;\n\tdevice->rsize = 0;\n\n\tkfree(device->collection);\n\tdevice->collection = NULL;\n\tdevice->collection_size = 0;\n\tdevice->maxcollection = 0;\n\tdevice->maxapplication = 0;\n\n\tdevice->status &= ~HID_STAT_PARSED;\n}\n\n/*\n * Free a device structure, all reports, and all fields.\n */\n\nstatic void hid_device_release(struct device *dev)\n{\n\tstruct hid_device *hid = to_hid_device(dev);\n\n\thid_close_report(hid);\n\tkfree(hid->dev_rdesc);\n\tkfree(hid);\n}\n\n/*\n * Fetch a report description item from the data stream. We support long\n * items, though they are not used yet.\n */\n\nstatic u8 *fetch_item(__u8 *start, __u8 *end, struct hid_item *item)\n{\n\tu8 b;\n\n\tif ((end - start) <= 0)\n\t\treturn NULL;\n\n\tb = *start++;\n\n\titem->type = (b >> 2) & 3;\n\titem->tag  = (b >> 4) & 15;\n\n\tif (item->tag == HID_ITEM_TAG_LONG) {\n\n\t\titem->format = HID_ITEM_FORMAT_LONG;\n\n\t\tif ((end - start) < 2)\n\t\t\treturn NULL;\n\n\t\titem->size = *start++;\n\t\titem->tag  = *start++;\n\n\t\tif ((end - start) < item->size)\n\t\t\treturn NULL;\n\n\t\titem->data.longdata = start;\n\t\tstart += item->size;\n\t\treturn start;\n\t}\n\n\titem->format = HID_ITEM_FORMAT_SHORT;\n\titem->size = b & 3;\n\n\tswitch (item->size) {\n\tcase 0:\n\t\treturn start;\n\n\tcase 1:\n\t\tif ((end - start) < 1)\n\t\t\treturn NULL;\n\t\titem->data.u8 = *start++;\n\t\treturn start;\n\n\tcase 2:\n\t\tif ((end - start) < 2)\n\t\t\treturn NULL;\n\t\titem->data.u16 = get_unaligned_le16(start);\n\t\tstart = (__u8 *)((__le16 *)start + 1);\n\t\treturn start;\n\n\tcase 3:\n\t\titem->size++;\n\t\tif ((end - start) < 4)\n\t\t\treturn NULL;\n\t\titem->data.u32 = get_unaligned_le32(start);\n\t\tstart = (__u8 *)((__le32 *)start + 1);\n\t\treturn start;\n\t}\n\n\treturn NULL;\n}\n\nstatic void hid_scan_input_usage(struct hid_parser *parser, u32 usage)\n{\n\tstruct hid_device *hid = parser->device;\n\n\tif (usage == HID_DG_CONTACTID)\n\t\thid->group = HID_GROUP_MULTITOUCH;\n}\n\nstatic void hid_scan_feature_usage(struct hid_parser *parser, u32 usage)\n{\n\tif (usage == 0xff0000c5 && parser->global.report_count == 256 &&\n\t    parser->global.report_size == 8)\n\t\tparser->scan_flags |= HID_SCAN_FLAG_MT_WIN_8;\n}\n\nstatic void hid_scan_collection(struct hid_parser *parser, unsigned type)\n{\n\tstruct hid_device *hid = parser->device;\n\tint i;\n\n\tif (((parser->global.usage_page << 16) == HID_UP_SENSOR) &&\n\t    type == HID_COLLECTION_PHYSICAL)\n\t\thid->group = HID_GROUP_SENSOR_HUB;\n\n\tif (hid->vendor == USB_VENDOR_ID_MICROSOFT &&\n\t    (hid->product == USB_DEVICE_ID_MS_TYPE_COVER_PRO_3 ||\n\t     hid->product == USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_2 ||\n\t     hid->product == USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_JP ||\n\t     hid->product == USB_DEVICE_ID_MS_TYPE_COVER_3 ||\n\t     hid->product == USB_DEVICE_ID_MS_POWER_COVER) &&\n\t    hid->group == HID_GROUP_MULTITOUCH)\n\t\thid->group = HID_GROUP_GENERIC;\n\n\tif ((parser->global.usage_page << 16) == HID_UP_GENDESK)\n\t\tfor (i = 0; i < parser->local.usage_index; i++)\n\t\t\tif (parser->local.usage[i] == HID_GD_POINTER)\n\t\t\t\tparser->scan_flags |= HID_SCAN_FLAG_GD_POINTER;\n\n\tif ((parser->global.usage_page << 16) >= HID_UP_MSVENDOR)\n\t\tparser->scan_flags |= HID_SCAN_FLAG_VENDOR_SPECIFIC;\n}\n\nstatic int hid_scan_main(struct hid_parser *parser, struct hid_item *item)\n{\n\t__u32 data;\n\tint i;\n\n\tdata = item_udata(item);\n\n\tswitch (item->tag) {\n\tcase HID_MAIN_ITEM_TAG_BEGIN_COLLECTION:\n\t\thid_scan_collection(parser, data & 0xff);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_END_COLLECTION:\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_INPUT:\n\t\t/* ignore constant inputs, they will be ignored by hid-input */\n\t\tif (data & HID_MAIN_ITEM_CONSTANT)\n\t\t\tbreak;\n\t\tfor (i = 0; i < parser->local.usage_index; i++)\n\t\t\thid_scan_input_usage(parser, parser->local.usage[i]);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_OUTPUT:\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_FEATURE:\n\t\tfor (i = 0; i < parser->local.usage_index; i++)\n\t\t\thid_scan_feature_usage(parser, parser->local.usage[i]);\n\t\tbreak;\n\t}\n\n\t/* Reset the local parser environment */\n\tmemset(&parser->local, 0, sizeof(parser->local));\n\n\treturn 0;\n}\n\n/*\n * Scan a report descriptor before the device is added to the bus.\n * Sets device groups and other properties that determine what driver\n * to load.\n */\nstatic int hid_scan_report(struct hid_device *hid)\n{\n\tstruct hid_parser *parser;\n\tstruct hid_item item;\n\t__u8 *start = hid->dev_rdesc;\n\t__u8 *end = start + hid->dev_rsize;\n\tstatic int (*dispatch_type[])(struct hid_parser *parser,\n\t\t\t\t      struct hid_item *item) = {\n\t\thid_scan_main,\n\t\thid_parser_global,\n\t\thid_parser_local,\n\t\thid_parser_reserved\n\t};\n\n\tparser = vzalloc(sizeof(struct hid_parser));\n\tif (!parser)\n\t\treturn -ENOMEM;\n\n\tparser->device = hid;\n\thid->group = HID_GROUP_GENERIC;\n\n\t/*\n\t * The parsing is simpler than the one in hid_open_report() as we should\n\t * be robust against hid errors. Those errors will be raised by\n\t * hid_open_report() anyway.\n\t */\n\twhile ((start = fetch_item(start, end, &item)) != NULL)\n\t\tdispatch_type[item.type](parser, &item);\n\n\t/*\n\t * Handle special flags set during scanning.\n\t */\n\tif ((parser->scan_flags & HID_SCAN_FLAG_MT_WIN_8) &&\n\t    (hid->group == HID_GROUP_MULTITOUCH))\n\t\thid->group = HID_GROUP_MULTITOUCH_WIN_8;\n\n\t/*\n\t * Vendor specific handlings\n\t */\n\tswitch (hid->vendor) {\n\tcase USB_VENDOR_ID_WACOM:\n\t\thid->group = HID_GROUP_WACOM;\n\t\tbreak;\n\tcase USB_VENDOR_ID_SYNAPTICS:\n\t\tif (hid->group == HID_GROUP_GENERIC)\n\t\t\tif ((parser->scan_flags & HID_SCAN_FLAG_VENDOR_SPECIFIC)\n\t\t\t    && (parser->scan_flags & HID_SCAN_FLAG_GD_POINTER))\n\t\t\t\t/*\n\t\t\t\t * hid-rmi should take care of them,\n\t\t\t\t * not hid-generic\n\t\t\t\t */\n\t\t\t\thid->group = HID_GROUP_RMI;\n\t\tbreak;\n\t}\n\n\tvfree(parser);\n\treturn 0;\n}\n\n/**\n * hid_parse_report - parse device report\n *\n * @device: hid device\n * @start: report start\n * @size: report size\n *\n * Allocate the device report as read by the bus driver. This function should\n * only be called from parse() in ll drivers.\n */\nint hid_parse_report(struct hid_device *hid, __u8 *start, unsigned size)\n{\n\thid->dev_rdesc = kmemdup(start, size, GFP_KERNEL);\n\tif (!hid->dev_rdesc)\n\t\treturn -ENOMEM;\n\thid->dev_rsize = size;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_parse_report);\n\nstatic const char * const hid_report_names[] = {\n\t\"HID_INPUT_REPORT\",\n\t\"HID_OUTPUT_REPORT\",\n\t\"HID_FEATURE_REPORT\",\n};\n/**\n * hid_validate_values - validate existing device report's value indexes\n *\n * @device: hid device\n * @type: which report type to examine\n * @id: which report ID to examine (0 for first)\n * @field_index: which report field to examine\n * @report_counts: expected number of values\n *\n * Validate the number of values in a given field of a given report, after\n * parsing.\n */\nstruct hid_report *hid_validate_values(struct hid_device *hid,\n\t\t\t\t       unsigned int type, unsigned int id,\n\t\t\t\t       unsigned int field_index,\n\t\t\t\t       unsigned int report_counts)\n{\n\tstruct hid_report *report;\n\n\tif (type > HID_FEATURE_REPORT) {\n\t\thid_err(hid, \"invalid HID report type %u\\n\", type);\n\t\treturn NULL;\n\t}\n\n\tif (id >= HID_MAX_IDS) {\n\t\thid_err(hid, \"invalid HID report id %u\\n\", id);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Explicitly not using hid_get_report() here since it depends on\n\t * ->numbered being checked, which may not always be the case when\n\t * drivers go to access report values.\n\t */\n\tif (id == 0) {\n\t\t/*\n\t\t * Validating on id 0 means we should examine the first\n\t\t * report in the list.\n\t\t */\n\t\treport = list_entry(\n\t\t\t\thid->report_enum[type].report_list.next,\n\t\t\t\tstruct hid_report, list);\n\t} else {\n\t\treport = hid->report_enum[type].report_id_hash[id];\n\t}\n\tif (!report) {\n\t\thid_err(hid, \"missing %s %u\\n\", hid_report_names[type], id);\n\t\treturn NULL;\n\t}\n\tif (report->maxfield <= field_index) {\n\t\thid_err(hid, \"not enough fields in %s %u\\n\",\n\t\t\thid_report_names[type], id);\n\t\treturn NULL;\n\t}\n\tif (report->field[field_index]->report_count < report_counts) {\n\t\thid_err(hid, \"not enough values in %s %u field %u\\n\",\n\t\t\thid_report_names[type], id, field_index);\n\t\treturn NULL;\n\t}\n\treturn report;\n}\nEXPORT_SYMBOL_GPL(hid_validate_values);\n\n/**\n * hid_open_report - open a driver-specific device report\n *\n * @device: hid device\n *\n * Parse a report description into a hid_device structure. Reports are\n * enumerated, fields are attached to these reports.\n * 0 returned on success, otherwise nonzero error value.\n *\n * This function (or the equivalent hid_parse() macro) should only be\n * called from probe() in drivers, before starting the device.\n */\nint hid_open_report(struct hid_device *device)\n{\n\tstruct hid_parser *parser;\n\tstruct hid_item item;\n\tunsigned int size;\n\t__u8 *start;\n\t__u8 *buf;\n\t__u8 *end;\n\tint ret;\n\tstatic int (*dispatch_type[])(struct hid_parser *parser,\n\t\t\t\t      struct hid_item *item) = {\n\t\thid_parser_main,\n\t\thid_parser_global,\n\t\thid_parser_local,\n\t\thid_parser_reserved\n\t};\n\n\tif (WARN_ON(device->status & HID_STAT_PARSED))\n\t\treturn -EBUSY;\n\n\tstart = device->dev_rdesc;\n\tif (WARN_ON(!start))\n\t\treturn -ENODEV;\n\tsize = device->dev_rsize;\n\n\tbuf = kmemdup(start, size, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tif (device->driver->report_fixup)\n\t\tstart = device->driver->report_fixup(device, buf, &size);\n\telse\n\t\tstart = buf;\n\n\tstart = kmemdup(start, size, GFP_KERNEL);\n\tkfree(buf);\n\tif (start == NULL)\n\t\treturn -ENOMEM;\n\n\tdevice->rdesc = start;\n\tdevice->rsize = size;\n\n\tparser = vzalloc(sizeof(struct hid_parser));\n\tif (!parser) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tparser->device = device;\n\n\tend = start + size;\n\n\tdevice->collection = kcalloc(HID_DEFAULT_NUM_COLLECTIONS,\n\t\t\t\t     sizeof(struct hid_collection), GFP_KERNEL);\n\tif (!device->collection) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdevice->collection_size = HID_DEFAULT_NUM_COLLECTIONS;\n\n\tret = -EINVAL;\n\twhile ((start = fetch_item(start, end, &item)) != NULL) {\n\n\t\tif (item.format != HID_ITEM_FORMAT_SHORT) {\n\t\t\thid_err(device, \"unexpected long global item\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (dispatch_type[item.type](parser, &item)) {\n\t\t\thid_err(device, \"item %u %u %u %u parsing failed\\n\",\n\t\t\t\titem.format, (unsigned)item.size,\n\t\t\t\t(unsigned)item.type, (unsigned)item.tag);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (start == end) {\n\t\t\tif (parser->collection_stack_ptr) {\n\t\t\t\thid_err(device, \"unbalanced collection at end of report description\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (parser->local.delimiter_depth) {\n\t\t\t\thid_err(device, \"unbalanced delimiter at end of report description\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tvfree(parser);\n\t\t\tdevice->status |= HID_STAT_PARSED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\thid_err(device, \"item fetching failed at offset %d\\n\", (int)(end - start));\nerr:\n\tvfree(parser);\n\thid_close_report(device);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_open_report);\n\n/*\n * Convert a signed n-bit integer to signed 32-bit integer. Common\n * cases are done through the compiler, the screwed things has to be\n * done by hand.\n */\n\nstatic s32 snto32(__u32 value, unsigned n)\n{\n\tswitch (n) {\n\tcase 8:  return ((__s8)value);\n\tcase 16: return ((__s16)value);\n\tcase 32: return ((__s32)value);\n\t}\n\treturn value & (1 << (n - 1)) ? value | (-1 << n) : value;\n}\n\ns32 hid_snto32(__u32 value, unsigned n)\n{\n\treturn snto32(value, n);\n}\nEXPORT_SYMBOL_GPL(hid_snto32);\n\n/*\n * Convert a signed 32-bit integer to a signed n-bit integer.\n */\n\nstatic u32 s32ton(__s32 value, unsigned n)\n{\n\ts32 a = value >> (n - 1);\n\tif (a && a != -1)\n\t\treturn value < 0 ? 1 << (n - 1) : (1 << (n - 1)) - 1;\n\treturn value & ((1 << n) - 1);\n}\n\n/*\n * Extract/implement a data field from/to a little endian report (bit array).\n *\n * Code sort-of follows HID spec:\n *     http://www.usb.org/developers/hidpage/HID1_11.pdf\n *\n * While the USB HID spec allows unlimited length bit fields in \"report\n * descriptors\", most devices never use more than 16 bits.\n * One model of UPS is claimed to report \"LINEV\" as a 32-bit field.\n * Search linux-kernel and linux-usb-devel archives for \"hid-core extract\".\n */\n\nstatic u32 __extract(u8 *report, unsigned offset, int n)\n{\n\tunsigned int idx = offset / 8;\n\tunsigned int bit_nr = 0;\n\tunsigned int bit_shift = offset % 8;\n\tint bits_to_copy = 8 - bit_shift;\n\tu32 value = 0;\n\tu32 mask = n < 32 ? (1U << n) - 1 : ~0U;\n\n\twhile (n > 0) {\n\t\tvalue |= ((u32)report[idx] >> bit_shift) << bit_nr;\n\t\tn -= bits_to_copy;\n\t\tbit_nr += bits_to_copy;\n\t\tbits_to_copy = 8;\n\t\tbit_shift = 0;\n\t\tidx++;\n\t}\n\n\treturn value & mask;\n}\n\nu32 hid_field_extract(const struct hid_device *hid, u8 *report,\n\t\t\tunsigned offset, unsigned n)\n{\n\tif (n > 32) {\n\t\thid_warn(hid, \"hid_field_extract() called with n (%d) > 32! (%s)\\n\",\n\t\t\t n, current->comm);\n\t\tn = 32;\n\t}\n\n\treturn __extract(report, offset, n);\n}\nEXPORT_SYMBOL_GPL(hid_field_extract);\n\n/*\n * \"implement\" : set bits in a little endian bit stream.\n * Same concepts as \"extract\" (see comments above).\n * The data mangled in the bit stream remains in little endian\n * order the whole time. It make more sense to talk about\n * endianness of register values by considering a register\n * a \"cached\" copy of the little endian bit stream.\n */\n\nstatic void __implement(u8 *report, unsigned offset, int n, u32 value)\n{\n\tunsigned int idx = offset / 8;\n\tunsigned int size = offset + n;\n\tunsigned int bit_shift = offset % 8;\n\tint bits_to_set = 8 - bit_shift;\n\tu8 bit_mask = 0xff << bit_shift;\n\n\twhile (n - bits_to_set >= 0) {\n\t\treport[idx] &= ~bit_mask;\n\t\treport[idx] |= value << bit_shift;\n\t\tvalue >>= bits_to_set;\n\t\tn -= bits_to_set;\n\t\tbits_to_set = 8;\n\t\tbit_mask = 0xff;\n\t\tbit_shift = 0;\n\t\tidx++;\n\t}\n\n\t/* last nibble */\n\tif (n) {\n\t\tif (size % 8)\n\t\t\tbit_mask &= (1U << (size % 8)) - 1;\n\t\treport[idx] &= ~bit_mask;\n\t\treport[idx] |= (value << bit_shift) & bit_mask;\n\t}\n}\n\nstatic void implement(const struct hid_device *hid, u8 *report,\n\t\t      unsigned offset, unsigned n, u32 value)\n{\n\tu64 m;\n\n\tif (n > 32) {\n\t\thid_warn(hid, \"%s() called with n (%d) > 32! (%s)\\n\",\n\t\t\t __func__, n, current->comm);\n\t\tn = 32;\n\t}\n\n\tm = (1ULL << n) - 1;\n\tif (value > m)\n\t\thid_warn(hid, \"%s() called with too large value %d! (%s)\\n\",\n\t\t\t __func__, value, current->comm);\n\tWARN_ON(value > m);\n\tvalue &= m;\n\n\t__implement(report, offset, n, value);\n}\n\n/*\n * Search an array for a value.\n */\n\nstatic int search(__s32 *array, __s32 value, unsigned n)\n{\n\twhile (n--) {\n\t\tif (*array++ == value)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n/**\n * hid_match_report - check if driver's raw_event should be called\n *\n * @hid: hid device\n * @report_type: type to match against\n *\n * compare hid->driver->report_table->report_type to report->type\n */\nstatic int hid_match_report(struct hid_device *hid, struct hid_report *report)\n{\n\tconst struct hid_report_id *id = hid->driver->report_table;\n\n\tif (!id) /* NULL means all */\n\t\treturn 1;\n\n\tfor (; id->report_type != HID_TERMINATOR; id++)\n\t\tif (id->report_type == HID_ANY_ID ||\n\t\t\t\tid->report_type == report->type)\n\t\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * hid_match_usage - check if driver's event should be called\n *\n * @hid: hid device\n * @usage: usage to match against\n *\n * compare hid->driver->usage_table->usage_{type,code} to\n * usage->usage_{type,code}\n */\nstatic int hid_match_usage(struct hid_device *hid, struct hid_usage *usage)\n{\n\tconst struct hid_usage_id *id = hid->driver->usage_table;\n\n\tif (!id) /* NULL means all */\n\t\treturn 1;\n\n\tfor (; id->usage_type != HID_ANY_ID - 1; id++)\n\t\tif ((id->usage_hid == HID_ANY_ID ||\n\t\t\t\tid->usage_hid == usage->hid) &&\n\t\t\t\t(id->usage_type == HID_ANY_ID ||\n\t\t\t\tid->usage_type == usage->type) &&\n\t\t\t\t(id->usage_code == HID_ANY_ID ||\n\t\t\t\t id->usage_code == usage->code))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic void hid_process_event(struct hid_device *hid, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value, int interrupt)\n{\n\tstruct hid_driver *hdrv = hid->driver;\n\tint ret;\n\n\tif (!list_empty(&hid->debug_list))\n\t\thid_dump_input(hid, usage, value);\n\n\tif (hdrv && hdrv->event && hid_match_usage(hid, usage)) {\n\t\tret = hdrv->event(hid, field, usage, value);\n\t\tif (ret != 0) {\n\t\t\tif (ret < 0)\n\t\t\t\thid_err(hid, \"%s's event failed with %d\\n\",\n\t\t\t\t\t\thdrv->name, ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (hid->claimed & HID_CLAIMED_INPUT)\n\t\thidinput_hid_event(hid, field, usage, value);\n\tif (hid->claimed & HID_CLAIMED_HIDDEV && interrupt && hid->hiddev_hid_event)\n\t\thid->hiddev_hid_event(hid, field, usage, value);\n}\n\n/*\n * Analyse a received field, and fetch the data from it. The field\n * content is stored for next report processing (we do differential\n * reporting to the layer).\n */\n\nstatic void hid_input_field(struct hid_device *hid, struct hid_field *field,\n\t\t\t    __u8 *data, int interrupt)\n{\n\tunsigned n;\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\t__s32 min = field->logical_minimum;\n\t__s32 max = field->logical_maximum;\n\t__s32 *value;\n\n\tvalue = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);\n\tif (!value)\n\t\treturn;\n\n\tfor (n = 0; n < count; n++) {\n\n\t\tvalue[n] = min < 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n\n\t\t/* Ignore report if ErrorRollOver */\n\t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n\t\t    value[n] >= min && value[n] <= max &&\n\t\t    value[n] - min < field->maxusage &&\n\t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n\t\t\tgoto exit;\n\t}\n\n\tfor (n = 0; n < count; n++) {\n\n\t\tif (HID_MAIN_ITEM_VARIABLE & field->flags) {\n\t\t\thid_process_event(hid, field, &field->usage[n], value[n], interrupt);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (field->value[n] >= min && field->value[n] <= max\n\t\t\t&& field->value[n] - min < field->maxusage\n\t\t\t&& field->usage[field->value[n] - min].hid\n\t\t\t&& search(value, field->value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n\n\t\tif (value[n] >= min && value[n] <= max\n\t\t\t&& value[n] - min < field->maxusage\n\t\t\t&& field->usage[value[n] - min].hid\n\t\t\t&& search(field->value, value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);\n\t}\n\n\tmemcpy(field->value, value, count * sizeof(__s32));\nexit:\n\tkfree(value);\n}\n\n/*\n * Output the field into the report.\n */\n\nstatic void hid_output_field(const struct hid_device *hid,\n\t\t\t     struct hid_field *field, __u8 *data)\n{\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\tunsigned n;\n\n\tfor (n = 0; n < count; n++) {\n\t\tif (field->logical_minimum < 0)\t/* signed values */\n\t\t\timplement(hid, data, offset + n * size, size,\n\t\t\t\t  s32ton(field->value[n], size));\n\t\telse\t\t\t\t/* unsigned values */\n\t\t\timplement(hid, data, offset + n * size, size,\n\t\t\t\t  field->value[n]);\n\t}\n}\n\n/*\n * Create a report. 'data' has to be allocated using\n * hid_alloc_report_buf() so that it has proper size.\n */\n\nvoid hid_output_report(struct hid_report *report, __u8 *data)\n{\n\tunsigned n;\n\n\tif (report->id > 0)\n\t\t*data++ = report->id;\n\n\tmemset(data, 0, ((report->size - 1) >> 3) + 1);\n\tfor (n = 0; n < report->maxfield; n++)\n\t\thid_output_field(report->device, report->field[n], data);\n}\nEXPORT_SYMBOL_GPL(hid_output_report);\n\n/*\n * Allocator for buffer that is going to be passed to hid_output_report()\n */\nu8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags)\n{\n\t/*\n\t * 7 extra bytes are necessary to achieve proper functionality\n\t * of implement() working on 8 byte chunks\n\t */\n\n\tint len = hid_report_len(report) + 7;\n\n\treturn kmalloc(len, flags);\n}\nEXPORT_SYMBOL_GPL(hid_alloc_report_buf);\n\n/*\n * Set a field value. The report this field belongs to has to be\n * created and transferred to the device, to set this value in the\n * device.\n */\n\nint hid_set_field(struct hid_field *field, unsigned offset, __s32 value)\n{\n\tunsigned size;\n\n\tif (!field)\n\t\treturn -1;\n\n\tsize = field->report_size;\n\n\thid_dump_input(field->report->device, field->usage + offset, value);\n\n\tif (offset >= field->report_count) {\n\t\thid_err(field->report->device, \"offset (%d) exceeds report_count (%d)\\n\",\n\t\t\t\toffset, field->report_count);\n\t\treturn -1;\n\t}\n\tif (field->logical_minimum < 0) {\n\t\tif (value != snto32(s32ton(value, size), size)) {\n\t\t\thid_err(field->report->device, \"value %d is out of range\\n\", value);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfield->value[offset] = value;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_set_field);\n\nstatic struct hid_report *hid_get_report(struct hid_report_enum *report_enum,\n\t\tconst u8 *data)\n{\n\tstruct hid_report *report;\n\tunsigned int n = 0;\t/* Normally report number is 0 */\n\n\t/* Device uses numbered reports, data[0] is report number */\n\tif (report_enum->numbered)\n\t\tn = *data;\n\n\treport = report_enum->report_id_hash[n];\n\tif (report == NULL)\n\t\tdbg_hid(\"undefined report_id %u received\\n\", n);\n\n\treturn report;\n}\n\n/*\n * Implement a generic .request() callback, using .raw_request()\n * DO NOT USE in hid drivers directly, but through hid_hw_request instead.\n */\nvoid __hid_request(struct hid_device *hid, struct hid_report *report,\n\t\tint reqtype)\n{\n\tchar *buf;\n\tint ret;\n\tint len;\n\n\tbuf = hid_alloc_report_buf(report, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tlen = hid_report_len(report);\n\n\tif (reqtype == HID_REQ_SET_REPORT)\n\t\thid_output_report(report, buf);\n\n\tret = hid->ll_driver->raw_request(hid, report->id, buf, len,\n\t\t\t\t\t  report->type, reqtype);\n\tif (ret < 0) {\n\t\tdbg_hid(\"unable to complete request: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (reqtype == HID_REQ_GET_REPORT)\n\t\thid_input_report(hid, report->type, buf, ret, 0);\n\nout:\n\tkfree(buf);\n}\nEXPORT_SYMBOL_GPL(__hid_request);\n\nint hid_report_raw_event(struct hid_device *hid, int type, u8 *data, int size,\n\t\tint interrupt)\n{\n\tstruct hid_report_enum *report_enum = hid->report_enum + type;\n\tstruct hid_report *report;\n\tstruct hid_driver *hdrv;\n\tunsigned int a;\n\tint rsize, csize = size;\n\tu8 *cdata = data;\n\tint ret = 0;\n\n\treport = hid_get_report(report_enum, data);\n\tif (!report)\n\t\tgoto out;\n\n\tif (report_enum->numbered) {\n\t\tcdata++;\n\t\tcsize--;\n\t}\n\n\trsize = ((report->size - 1) >> 3) + 1;\n\n\tif (rsize > HID_MAX_BUFFER_SIZE)\n\t\trsize = HID_MAX_BUFFER_SIZE;\n\n\tif (csize < rsize) {\n\t\tdbg_hid(\"report %d is too short, (%d < %d)\\n\", report->id,\n\t\t\t\tcsize, rsize);\n\t\tmemset(cdata + csize, 0, rsize - csize);\n\t}\n\n\tif ((hid->claimed & HID_CLAIMED_HIDDEV) && hid->hiddev_report_event)\n\t\thid->hiddev_report_event(hid, report);\n\tif (hid->claimed & HID_CLAIMED_HIDRAW) {\n\t\tret = hidraw_report_event(hid, data, size);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (hid->claimed != HID_CLAIMED_HIDRAW && report->maxfield) {\n\t\tfor (a = 0; a < report->maxfield; a++)\n\t\t\thid_input_field(hid, report->field[a], cdata, interrupt);\n\t\thdrv = hid->driver;\n\t\tif (hdrv && hdrv->report)\n\t\t\thdrv->report(hid, report);\n\t}\n\n\tif (hid->claimed & HID_CLAIMED_INPUT)\n\t\thidinput_report_event(hid, report);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_report_raw_event);\n\n/**\n * hid_input_report - report data from lower layer (usb, bt...)\n *\n * @hid: hid device\n * @type: HID report type (HID_*_REPORT)\n * @data: report contents\n * @size: size of data parameter\n * @interrupt: distinguish between interrupt and control transfers\n *\n * This is data entry for lower layers.\n */\nint hid_input_report(struct hid_device *hid, int type, u8 *data, int size, int interrupt)\n{\n\tstruct hid_report_enum *report_enum;\n\tstruct hid_driver *hdrv;\n\tstruct hid_report *report;\n\tint ret = 0;\n\n\tif (!hid)\n\t\treturn -ENODEV;\n\n\tif (down_trylock(&hid->driver_input_lock))\n\t\treturn -EBUSY;\n\n\tif (!hid->driver) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\treport_enum = hid->report_enum + type;\n\thdrv = hid->driver;\n\n\tif (!size) {\n\t\tdbg_hid(\"empty report\\n\");\n\t\tret = -1;\n\t\tgoto unlock;\n\t}\n\n\t/* Avoid unnecessary overhead if debugfs is disabled */\n\tif (!list_empty(&hid->debug_list))\n\t\thid_dump_report(hid, type, data, size);\n\n\treport = hid_get_report(report_enum, data);\n\n\tif (!report) {\n\t\tret = -1;\n\t\tgoto unlock;\n\t}\n\n\tif (hdrv && hdrv->raw_event && hid_match_report(hid, report)) {\n\t\tret = hdrv->raw_event(hid, report, data, size);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tret = hid_report_raw_event(hid, type, data, size, interrupt);\n\nunlock:\n\tup(&hid->driver_input_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_input_report);\n\nstatic bool hid_match_one_id(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\treturn (id->bus == HID_BUS_ANY || id->bus == hdev->bus) &&\n\t\t(id->group == HID_GROUP_ANY || id->group == hdev->group) &&\n\t\t(id->vendor == HID_ANY_ID || id->vendor == hdev->vendor) &&\n\t\t(id->product == HID_ANY_ID || id->product == hdev->product);\n}\n\nconst struct hid_device_id *hid_match_id(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tfor (; id->bus; id++)\n\t\tif (hid_match_one_id(hdev, id))\n\t\t\treturn id;\n\n\treturn NULL;\n}\n\nstatic const struct hid_device_id hid_hiddev_list[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS1) },\n\t{ }\n};\n\nstatic bool hid_hiddev(struct hid_device *hdev)\n{\n\treturn !!hid_match_id(hdev, hid_hiddev_list);\n}\n\n\nstatic ssize_t\nread_report_descriptor(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr,\n\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct hid_device *hdev = to_hid_device(dev);\n\n\tif (off >= hdev->rsize)\n\t\treturn 0;\n\n\tif (off + count > hdev->rsize)\n\t\tcount = hdev->rsize - off;\n\n\tmemcpy(buf, hdev->rdesc + off, count);\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_country(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\n\treturn sprintf(buf, \"%02x\\n\", hdev->country & 0xff);\n}\n\nstatic struct bin_attribute dev_bin_attr_report_desc = {\n\t.attr = { .name = \"report_descriptor\", .mode = 0444 },\n\t.read = read_report_descriptor,\n\t.size = HID_MAX_DESCRIPTOR_SIZE,\n};\n\nstatic struct device_attribute dev_attr_country = {\n\t.attr = { .name = \"country\", .mode = 0444 },\n\t.show = show_country,\n};\n\nint hid_connect(struct hid_device *hdev, unsigned int connect_mask)\n{\n\tstatic const char *types[] = { \"Device\", \"Pointer\", \"Mouse\", \"Device\",\n\t\t\"Joystick\", \"Gamepad\", \"Keyboard\", \"Keypad\",\n\t\t\"Multi-Axis Controller\"\n\t};\n\tconst char *type, *bus;\n\tchar buf[64] = \"\";\n\tunsigned int i;\n\tint len;\n\tint ret;\n\n\tif (hdev->quirks & HID_QUIRK_HIDDEV_FORCE)\n\t\tconnect_mask |= (HID_CONNECT_HIDDEV_FORCE | HID_CONNECT_HIDDEV);\n\tif (hdev->quirks & HID_QUIRK_HIDINPUT_FORCE)\n\t\tconnect_mask |= HID_CONNECT_HIDINPUT_FORCE;\n\tif (hdev->bus != BUS_USB)\n\t\tconnect_mask &= ~HID_CONNECT_HIDDEV;\n\tif (hid_hiddev(hdev))\n\t\tconnect_mask |= HID_CONNECT_HIDDEV_FORCE;\n\n\tif ((connect_mask & HID_CONNECT_HIDINPUT) && !hidinput_connect(hdev,\n\t\t\t\tconnect_mask & HID_CONNECT_HIDINPUT_FORCE))\n\t\thdev->claimed |= HID_CLAIMED_INPUT;\n\n\tif ((connect_mask & HID_CONNECT_HIDDEV) && hdev->hiddev_connect &&\n\t\t\t!hdev->hiddev_connect(hdev,\n\t\t\t\tconnect_mask & HID_CONNECT_HIDDEV_FORCE))\n\t\thdev->claimed |= HID_CLAIMED_HIDDEV;\n\tif ((connect_mask & HID_CONNECT_HIDRAW) && !hidraw_connect(hdev))\n\t\thdev->claimed |= HID_CLAIMED_HIDRAW;\n\n\tif (connect_mask & HID_CONNECT_DRIVER)\n\t\thdev->claimed |= HID_CLAIMED_DRIVER;\n\n\t/* Drivers with the ->raw_event callback set are not required to connect\n\t * to any other listener. */\n\tif (!hdev->claimed && !hdev->driver->raw_event) {\n\t\thid_err(hdev, \"device has no listeners, quitting\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif ((hdev->claimed & HID_CLAIMED_INPUT) &&\n\t\t\t(connect_mask & HID_CONNECT_FF) && hdev->ff_init)\n\t\thdev->ff_init(hdev);\n\n\tlen = 0;\n\tif (hdev->claimed & HID_CLAIMED_INPUT)\n\t\tlen += sprintf(buf + len, \"input\");\n\tif (hdev->claimed & HID_CLAIMED_HIDDEV)\n\t\tlen += sprintf(buf + len, \"%shiddev%d\", len ? \",\" : \"\",\n\t\t\t\thdev->minor);\n\tif (hdev->claimed & HID_CLAIMED_HIDRAW)\n\t\tlen += sprintf(buf + len, \"%shidraw%d\", len ? \",\" : \"\",\n\t\t\t\t((struct hidraw *)hdev->hidraw)->minor);\n\n\ttype = \"Device\";\n\tfor (i = 0; i < hdev->maxcollection; i++) {\n\t\tstruct hid_collection *col = &hdev->collection[i];\n\t\tif (col->type == HID_COLLECTION_APPLICATION &&\n\t\t   (col->usage & HID_USAGE_PAGE) == HID_UP_GENDESK &&\n\t\t   (col->usage & 0xffff) < ARRAY_SIZE(types)) {\n\t\t\ttype = types[col->usage & 0xffff];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (hdev->bus) {\n\tcase BUS_USB:\n\t\tbus = \"USB\";\n\t\tbreak;\n\tcase BUS_BLUETOOTH:\n\t\tbus = \"BLUETOOTH\";\n\t\tbreak;\n\tcase BUS_I2C:\n\t\tbus = \"I2C\";\n\t\tbreak;\n\tdefault:\n\t\tbus = \"<UNKNOWN>\";\n\t}\n\n\tret = device_create_file(&hdev->dev, &dev_attr_country);\n\tif (ret)\n\t\thid_warn(hdev,\n\t\t\t \"can't create sysfs country code attribute err: %d\\n\", ret);\n\n\thid_info(hdev, \"%s: %s HID v%x.%02x %s [%s] on %s\\n\",\n\t\t buf, bus, hdev->version >> 8, hdev->version & 0xff,\n\t\t type, hdev->name, hdev->phys);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_connect);\n\nvoid hid_disconnect(struct hid_device *hdev)\n{\n\tdevice_remove_file(&hdev->dev, &dev_attr_country);\n\tif (hdev->claimed & HID_CLAIMED_INPUT)\n\t\thidinput_disconnect(hdev);\n\tif (hdev->claimed & HID_CLAIMED_HIDDEV)\n\t\thdev->hiddev_disconnect(hdev);\n\tif (hdev->claimed & HID_CLAIMED_HIDRAW)\n\t\thidraw_disconnect(hdev);\n\thdev->claimed = 0;\n}\nEXPORT_SYMBOL_GPL(hid_disconnect);\n\n/*\n * A list of devices for which there is a specialized driver on HID bus.\n *\n * Please note that for multitouch devices (driven by hid-multitouch driver),\n * there is a proper autodetection and autoloading in place (based on presence\n * of HID_DG_CONTACTID), so those devices don't need to be added to this list,\n * as we are doing the right thing in hid_scan_usage().\n *\n * Autodetection for (USB) HID sensor hubs exists too. If a collection of type\n * physical is found inside a usage page of type sensor, hid-sensor-hub will be\n * used as a driver. See hid_scan_report().\n */\nstatic const struct hid_device_id hid_have_special_driver[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_WCP32PU) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_X5_005D) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_RP_649) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ACRUX, 0x0802) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ACRUX, 0xf705) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MIGHTYMOUSE) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICMOUSE) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICTRACKPAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_MINI_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_MINI_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_MINI_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL4) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL5) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_ISO) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_REVB_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_REVB_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_REVB_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_JIS) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AUREAL, USB_DEVICE_ID_AUREAL_W01RN) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BELKIN, USB_DEVICE_ID_FLIP_KVM) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BETOP_2185BFM, 0x2208) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BETOP_2185PC, 0x5506) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BETOP_2185V2PC, 0x1850) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BETOP_2185V2BFM, 0x5500) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BTC, USB_DEVICE_ID_BTC_EMPREX_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BTC, USB_DEVICE_ID_BTC_EMPREX_REMOTE_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHERRY, USB_DEVICE_ID_CHERRY_CYMOTION) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHERRY, USB_DEVICE_ID_CHERRY_CYMOTION_SOLAR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_TACTICAL_PAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_WIRELESS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_WIRELESS2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_AK1D) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_ACER_SWITCH12) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_K90) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CREATIVELABS, USB_DEVICE_ID_PRODIKEYS_PCMIDI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_CP2112) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_1) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_4) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_MOUSE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, 0x0006) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, 0x0011) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_BM084) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELO, 0x0009) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELO, 0x0030) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_EMS, USB_DEVICE_ID_EMS_TRIO_LINKER_PLUS_II) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_EZKEY, USB_DEVICE_ID_BTC_8193) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GAMERON, USB_DEVICE_ID_GAMERON_DUAL_PSX_ADAPTOR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GAMERON, USB_DEVICE_ID_GAMERON_DUAL_PCS_ADAPTOR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GEMBIRD, USB_DEVICE_ID_GEMBIRD_JPD_DUALFORCE2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GREENASIA, 0x0003) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GREENASIA, 0x0012) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GYRATION, USB_DEVICE_ID_GYRATION_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GYRATION, USB_DEVICE_ID_GYRATION_REMOTE_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GYRATION, USB_DEVICE_ID_GYRATION_REMOTE_3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK, USB_DEVICE_ID_HOLTEK_ON_LINE_GRIP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A04A) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A067) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A070) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A072) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A081) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A0C2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HUION, USB_DEVICE_ID_HUION_TABLET) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_JESS2, USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ION, USB_DEVICE_ID_ICADE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KENSINGTON, USB_DEVICE_ID_KS_SLIMBLADE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KEYTOUCH, USB_DEVICE_ID_KEYTOUCH_IEC) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_GENIUS_MANTICORE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_GENIUS_GX_IMPERATOR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_ERGO_525V) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_EASYPEN_I405X) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_MOUSEPEN_I608X) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_MOUSEPEN_I608X_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_EASYPEN_M610X) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_PENSKETCH_M912) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LABTEC, USB_DEVICE_ID_LABTEC_WIRELESS_KEYBOARD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LCPOWER, USB_DEVICE_ID_LCPOWER_LC1000 ) },\n#if IS_ENABLED(CONFIG_HID_LENOVO)\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_TPKBD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_CUSBKBD) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_CBTKBD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_TPPRODOCK) },\n#endif\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_MX3000_RECEIVER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_S510_RECEIVER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_S510_RECEIVER_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RECEIVER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_HARMONY_PS3) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_T651) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_DESKTOP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_EDGE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_MINI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_ELITE_KBD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_CORDLESS_DESKTOP_LX500) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_EXTREME_3D) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD_CORD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD2_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G29_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G920_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WINGMAN_F3D) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WINGMAN_FFG ) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_FORCE3D_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_FLIGHT_SYSTEM_G940) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_MOMO_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DFP_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DFGT_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G25_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G27_WHEEL) },\n#if IS_ENABLED(CONFIG_HID_LOGITECH_DJ)\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER_2) },\n#endif\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WII_WHEEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_SPACETRAVELLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_SPACENAVIGATOR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICOLCD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICOLCD_BOOTLOADER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_COMFORT_MOUSE_4500) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_SIDEWINDER_GV) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE4K) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE4K_JP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE7K) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_LK6K) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_PRESENTER_8K_USB) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_3K) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_WIRELESS_OPTICAL_DESKTOP_3_0) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_OFFICE_KB) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_PRO_3_JP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_POWER_COVER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MONTEREY, USB_DEVICE_ID_GENIUS_KB29E) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MSI, USB_DEVICE_ID_MSI_GT683R_LED_PANEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_1) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_4) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_5) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_6) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_7) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_8) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_9) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_10) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_11) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_12) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_13) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_14) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_15) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_16) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_17) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_18) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ORTEK, USB_DEVICE_ID_ORTEK_PKB1700) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ORTEK, USB_DEVICE_ID_ORTEK_WKB2000) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PENMOUNT, USB_DEVICE_ID_PENMOUNT_6000) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PETALYNX, USB_DEVICE_ID_PETALYNX_MAXTER_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PLANTRONICS, HID_ANY_ID) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PRIMAX, USB_DEVICE_ID_PRIMAX_KEYBOARD) },\n#if IS_ENABLED(CONFIG_HID_ROCCAT)\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ARVO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ISKU) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ISKUFX) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEPLUS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEPURE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEPURE_OPTICAL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEXTD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KOVAPLUS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_LUA) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_PYRA_WIRED) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_RYOS_MK) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_RYOS_MK_GLOW) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_RYOS_MK_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_SAVU) },\n#endif\n#if IS_ENABLED(CONFIG_HID_SAITEK)\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_PS1000) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_RAT7_OLD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_RAT7) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_MMO7) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MADCATZ, USB_DEVICE_ID_MADCATZ_RAT5) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MADCATZ, USB_DEVICE_ID_MADCATZ_RAT9) },\n#endif\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_IR_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SKYCABLE, USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SMK, USB_DEVICE_ID_SMK_PS3_BDREMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_BUZZ_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_WIRELESS_BUZZ_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_MOTION_CONTROLLER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_MOTION_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_BDREMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_VAIO_VGP_MOUSE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_STEELSERIES, USB_DEVICE_ID_STEELSERIES_SRWS1) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SUNPLUS, USB_DEVICE_ID_SUNPLUS_WDESKTOP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THINGM, USB_DEVICE_ID_BLINK1) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb300) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb304) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb323) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb324) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb651) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb653) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb654) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb65a) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_TIVO, USB_DEVICE_ID_TIVO_SLIDE_BT) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TIVO, USB_DEVICE_ID_TIVO_SLIDE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TIVO, USB_DEVICE_ID_TIVO_SLIDE_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TOPSEED, USB_DEVICE_ID_TOPSEED_CYBERLINK) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TOPSEED2, USB_DEVICE_ID_TOPSEED2_RF_COMBO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TWINHAN, USB_DEVICE_ID_TWINHAN_IR_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_PF1209) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_WP1062) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_SMARTJOY_PLUS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_SUPER_JOY_BOX_3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_DUAL_USB_JOYPAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP_LTD, USB_DEVICE_ID_SUPER_JOY_BOX_3_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP_LTD, USB_DEVICE_ID_SUPER_DUAL_BOX_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP_LTD, USB_DEVICE_ID_SUPER_JOY_BOX_5_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PLAYDOTCOM, USB_DEVICE_ID_PLAYDOTCOM_EMS_USBII) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SLIM_TABLET_5_8_INCH) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SLIM_TABLET_12_1_INCH) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_Q_PAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_PID_0038) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_MEDIA_TABLET_10_6_INCH) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_MEDIA_TABLET_14_1_INCH) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SIRIUS_BATTERY_FREE_TABLET) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_X_TENSIONS, USB_DEVICE_ID_SPEEDLINK_VAD_CEZANNE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_XIN_MO, USB_DEVICE_ID_XIN_MO_DUAL_ARCADE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ZEROPLUS, 0x0005) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ZEROPLUS, 0x0030) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ZYDACRON, USB_DEVICE_ID_ZYDACRON_REMOTE_CONTROL) },\n\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_PRESENTER_8K_BT) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_WIIMOTE) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_WIIMOTE2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_RAZER, USB_DEVICE_ID_RAZER_BLADE_14) },\n\t{ }\n};\n\nstruct hid_dynid {\n\tstruct list_head list;\n\tstruct hid_device_id id;\n};\n\n/**\n * store_new_id - add a new HID device ID to this driver and re-probe devices\n * @driver: target device driver\n * @buf: buffer for scanning device ID data\n * @count: input size\n *\n * Adds a new dynamic hid device ID to this driver,\n * and causes the driver to probe for all devices again.\n */\nstatic ssize_t store_new_id(struct device_driver *drv, const char *buf,\n\t\tsize_t count)\n{\n\tstruct hid_driver *hdrv = to_hid_driver(drv);\n\tstruct hid_dynid *dynid;\n\t__u32 bus, vendor, product;\n\tunsigned long driver_data = 0;\n\tint ret;\n\n\tret = sscanf(buf, \"%x %x %x %lx\",\n\t\t\t&bus, &vendor, &product, &driver_data);\n\tif (ret < 3)\n\t\treturn -EINVAL;\n\n\tdynid = kzalloc(sizeof(*dynid), GFP_KERNEL);\n\tif (!dynid)\n\t\treturn -ENOMEM;\n\n\tdynid->id.bus = bus;\n\tdynid->id.group = HID_GROUP_ANY;\n\tdynid->id.vendor = vendor;\n\tdynid->id.product = product;\n\tdynid->id.driver_data = driver_data;\n\n\tspin_lock(&hdrv->dyn_lock);\n\tlist_add_tail(&dynid->list, &hdrv->dyn_list);\n\tspin_unlock(&hdrv->dyn_lock);\n\n\tret = driver_attach(&hdrv->driver);\n\n\treturn ret ? : count;\n}\nstatic DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);\n\nstatic void hid_free_dynids(struct hid_driver *hdrv)\n{\n\tstruct hid_dynid *dynid, *n;\n\n\tspin_lock(&hdrv->dyn_lock);\n\tlist_for_each_entry_safe(dynid, n, &hdrv->dyn_list, list) {\n\t\tlist_del(&dynid->list);\n\t\tkfree(dynid);\n\t}\n\tspin_unlock(&hdrv->dyn_lock);\n}\n\nstatic const struct hid_device_id *hid_match_device(struct hid_device *hdev,\n\t\tstruct hid_driver *hdrv)\n{\n\tstruct hid_dynid *dynid;\n\n\tspin_lock(&hdrv->dyn_lock);\n\tlist_for_each_entry(dynid, &hdrv->dyn_list, list) {\n\t\tif (hid_match_one_id(hdev, &dynid->id)) {\n\t\t\tspin_unlock(&hdrv->dyn_lock);\n\t\t\treturn &dynid->id;\n\t\t}\n\t}\n\tspin_unlock(&hdrv->dyn_lock);\n\n\treturn hid_match_id(hdev, hdrv->id_table);\n}\n\nstatic int hid_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct hid_driver *hdrv = to_hid_driver(drv);\n\tstruct hid_device *hdev = to_hid_device(dev);\n\n\treturn hid_match_device(hdev, hdrv) != NULL;\n}\n\nstatic int hid_device_probe(struct device *dev)\n{\n\tstruct hid_driver *hdrv = to_hid_driver(dev->driver);\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tconst struct hid_device_id *id;\n\tint ret = 0;\n\n\tif (down_interruptible(&hdev->driver_lock))\n\t\treturn -EINTR;\n\tif (down_interruptible(&hdev->driver_input_lock)) {\n\t\tret = -EINTR;\n\t\tgoto unlock_driver_lock;\n\t}\n\thdev->io_started = false;\n\n\tif (!hdev->driver) {\n\t\tid = hid_match_device(hdev, hdrv);\n\t\tif (id == NULL) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\thdev->driver = hdrv;\n\t\tif (hdrv->probe) {\n\t\t\tret = hdrv->probe(hdev, id);\n\t\t} else { /* default probe */\n\t\t\tret = hid_open_report(hdev);\n\t\t\tif (!ret)\n\t\t\t\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t\t}\n\t\tif (ret) {\n\t\t\thid_close_report(hdev);\n\t\t\thdev->driver = NULL;\n\t\t}\n\t}\nunlock:\n\tif (!hdev->io_started)\n\t\tup(&hdev->driver_input_lock);\nunlock_driver_lock:\n\tup(&hdev->driver_lock);\n\treturn ret;\n}\n\nstatic int hid_device_remove(struct device *dev)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct hid_driver *hdrv;\n\tint ret = 0;\n\n\tif (down_interruptible(&hdev->driver_lock))\n\t\treturn -EINTR;\n\tif (down_interruptible(&hdev->driver_input_lock)) {\n\t\tret = -EINTR;\n\t\tgoto unlock_driver_lock;\n\t}\n\thdev->io_started = false;\n\n\thdrv = hdev->driver;\n\tif (hdrv) {\n\t\tif (hdrv->remove)\n\t\t\thdrv->remove(hdev);\n\t\telse /* default remove */\n\t\t\thid_hw_stop(hdev);\n\t\thid_close_report(hdev);\n\t\thdev->driver = NULL;\n\t}\n\n\tif (!hdev->io_started)\n\t\tup(&hdev->driver_input_lock);\nunlock_driver_lock:\n\tup(&hdev->driver_lock);\n\treturn ret;\n}\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *a,\n\t\t\t     char *buf)\n{\n\tstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"hid:b%04Xg%04Xv%08Xp%08X\\n\",\n\t\t\t hdev->bus, hdev->group, hdev->vendor, hdev->product);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *hid_dev_attrs[] = {\n\t&dev_attr_modalias.attr,\n\tNULL,\n};\nstatic struct bin_attribute *hid_dev_bin_attrs[] = {\n\t&dev_bin_attr_report_desc,\n\tNULL\n};\nstatic const struct attribute_group hid_dev_group = {\n\t.attrs = hid_dev_attrs,\n\t.bin_attrs = hid_dev_bin_attrs,\n};\n__ATTRIBUTE_GROUPS(hid_dev);\n\nstatic int hid_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\t\n\n\tif (add_uevent_var(env, \"HID_ID=%04X:%08X:%08X\",\n\t\t\thdev->bus, hdev->vendor, hdev->product))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"HID_NAME=%s\", hdev->name))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"HID_PHYS=%s\", hdev->phys))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"HID_UNIQ=%s\", hdev->uniq))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"MODALIAS=hid:b%04Xg%04Xv%08Xp%08X\",\n\t\t\t   hdev->bus, hdev->group, hdev->vendor, hdev->product))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic struct bus_type hid_bus_type = {\n\t.name\t\t= \"hid\",\n\t.dev_groups\t= hid_dev_groups,\n\t.match\t\t= hid_bus_match,\n\t.probe\t\t= hid_device_probe,\n\t.remove\t\t= hid_device_remove,\n\t.uevent\t\t= hid_uevent,\n};\n\n/* a list of devices that shouldn't be handled by HID core at all */\nstatic const struct hid_device_id hid_ignore_list[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ACECAD, USB_DEVICE_ID_ACECAD_FLAIR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ACECAD, USB_DEVICE_ID_ACECAD_302) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ADS_TECH, USB_DEVICE_ID_ADS_TECH_RADIO_SI470X) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_01) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_10) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_20) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_21) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_22) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_23) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIPTEK, USB_DEVICE_ID_AIPTEK_24) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AIRCABLE, USB_DEVICE_ID_AIRCABLE1) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ALCOR, USB_DEVICE_ID_ALCOR_USBRS232) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_LCM)},\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_LCM2)},\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AVERMEDIA, USB_DEVICE_ID_AVER_FM_MR800) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_AXENTIA, USB_DEVICE_ID_AXENTIA_FM_RADIO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BERKSHIRE, USB_DEVICE_ID_BERKSHIRE_PCWD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CIDC, 0x0103) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_RADIO_SI470X) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_RADIO_SI4713) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CMEDIA, USB_DEVICE_ID_CM109) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_HIDCOM) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_ULTRAMOUSE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DEALEXTREAME, USB_DEVICE_ID_DEALEXTREAME_RADIO_SI4701) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DELORME, USB_DEVICE_ID_DELORME_EARTHMATE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DELORME, USB_DEVICE_ID_DELORME_EM_LT20) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DREAM_CHEEKY, 0x0004) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DREAM_CHEEKY, 0x000a) },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, 0x0400) },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, 0x0401) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ESSENTIAL_REALITY, USB_DEVICE_ID_ESSENTIAL_REALITY_P5) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ETT, USB_DEVICE_ID_TC5UH) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ETT, USB_DEVICE_ID_TC4UM) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH, 0x0001) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH, 0x0002) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH, 0x0004) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GOTOP, USB_DEVICE_ID_SUPER_Q2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GOTOP, USB_DEVICE_ID_GOGOPEN) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GOTOP, USB_DEVICE_ID_PENPOWER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GRETAGMACBETH, USB_DEVICE_ID_GRETAGMACBETH_HUEY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_POWERMATE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_SOUNDKNOB) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_RADIOSHARK) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_90) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_100) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_101) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_103) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_104) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_105) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_106) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_107) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_108) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_200) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_201) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_202) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_203) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_204) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_205) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_206) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_207) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_300) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_301) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_302) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_303) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_304) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_305) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_306) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_307) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_308) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_309) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_400) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_401) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_402) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_403) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_404) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_405) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_500) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_501) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_502) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_503) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_504) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1000) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1001) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1002) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1003) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1004) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1005) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1006) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1007) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_IMATION, USB_DEVICE_ID_DISC_STAKKA) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_JABRA, USB_DEVICE_ID_JABRA_SPEAK_410) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_JABRA, USB_DEVICE_ID_JABRA_SPEAK_510) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_JABRA, USB_DEVICE_ID_JABRA_GN9350E) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KBGEAR, USB_DEVICE_ID_KBGEAR_JAMSTUDIO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KWORLD, USB_DEVICE_ID_KWORLD_RADIO_FM700) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_GPEN_560) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_KYE, 0x0058) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_CASSY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_CASSY2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_POCKETCASSY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_POCKETCASSY2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOBILECASSY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOBILECASSY2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYVOLTAGE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYCURRENT) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYTIME) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYTEMPERATURE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYPH) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_JWM) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_DMMP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_UMIP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_UMIC) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_UMIB) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_XRAY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_XRAY2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_VIDEOCOM) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOTOR) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_COM3LAB) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_TELEPORT) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_NETWORKANALYSER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_POWERCONTROL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MACHINETEST) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOSTANALYSER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOSTANALYSER2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_ABSESP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_AUTODATABUS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MCT) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_HYBRID) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_HEATCONTROL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MADCATZ, USB_DEVICE_ID_MADCATZ_BEATPAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MCC, USB_DEVICE_ID_MCC_PMD1024LS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MCC, USB_DEVICE_ID_MCC_PMD1208LS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICKIT1) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICKIT2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICK16F1454) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICK16F1454_V2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NATIONAL_SEMICONDUCTOR, USB_DEVICE_ID_N_S_HARMONY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 20) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 30) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 100) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 108) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 118) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 200) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 300) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 400) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 500) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0001) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0002) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0003) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0004) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PHILIPS, USB_DEVICE_ID_PHILIPS_IEEE802154_DONGLE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_POWERCOM, USB_DEVICE_ID_POWERCOM_UPS) },\n#if defined(CONFIG_MOUSE_SYNAPTICS_USB) || defined(CONFIG_MOUSE_SYNAPTICS_USB_MODULE)\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_TP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_INT_TP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_CPAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_STICK) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_WP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_COMP_TP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_WTP) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_DPAD) },\n#endif\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_YEALINK, USB_DEVICE_ID_YEALINK_P1K_P4K_B2K) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_RISO_KAGAKU, USB_DEVICE_ID_RI_KA_WEBMAIL) },\n\t{ }\n};\n\n/**\n * hid_mouse_ignore_list - mouse devices which should not be handled by the hid layer\n *\n * There are composite devices for which we want to ignore only a certain\n * interface. This is a list of devices for which only the mouse interface will\n * be ignored. This allows a dedicated driver to take care of the interface.\n */\nstatic const struct hid_device_id hid_mouse_ignore_list[] = {\n\t/* appletouch driver */\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_ANSI) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_ISO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_JIS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY) },\n\t{ }\n};\n\nbool hid_ignore(struct hid_device *hdev)\n{\n\tif (hdev->quirks & HID_QUIRK_NO_IGNORE)\n\t\treturn false;\n\tif (hdev->quirks & HID_QUIRK_IGNORE)\n\t\treturn true;\n\n\tswitch (hdev->vendor) {\n\tcase USB_VENDOR_ID_CODEMERCS:\n\t\t/* ignore all Code Mercenaries IOWarrior devices */\n\t\tif (hdev->product >= USB_DEVICE_ID_CODEMERCS_IOW_FIRST &&\n\t\t\t\thdev->product <= USB_DEVICE_ID_CODEMERCS_IOW_LAST)\n\t\t\treturn true;\n\t\tbreak;\n\tcase USB_VENDOR_ID_LOGITECH:\n\t\tif (hdev->product >= USB_DEVICE_ID_LOGITECH_HARMONY_FIRST &&\n\t\t\t\thdev->product <= USB_DEVICE_ID_LOGITECH_HARMONY_LAST)\n\t\t\treturn true;\n\t\t/*\n\t\t * The Keene FM transmitter USB device has the same USB ID as\n\t\t * the Logitech AudioHub Speaker, but it should ignore the hid.\n\t\t * Check if the name is that of the Keene device.\n\t\t * For reference: the name of the AudioHub is\n\t\t * \"HOLTEK  AudioHub Speaker\".\n\t\t */\n\t\tif (hdev->product == USB_DEVICE_ID_LOGITECH_AUDIOHUB &&\n\t\t\t!strcmp(hdev->name, \"HOLTEK  B-LINK USB Audio  \"))\n\t\t\t\treturn true;\n\t\tbreak;\n\tcase USB_VENDOR_ID_SOUNDGRAPH:\n\t\tif (hdev->product >= USB_DEVICE_ID_SOUNDGRAPH_IMON_FIRST &&\n\t\t    hdev->product <= USB_DEVICE_ID_SOUNDGRAPH_IMON_LAST)\n\t\t\treturn true;\n\t\tbreak;\n\tcase USB_VENDOR_ID_HANWANG:\n\t\tif (hdev->product >= USB_DEVICE_ID_HANWANG_TABLET_FIRST &&\n\t\t    hdev->product <= USB_DEVICE_ID_HANWANG_TABLET_LAST)\n\t\t\treturn true;\n\t\tbreak;\n\tcase USB_VENDOR_ID_JESS:\n\t\tif (hdev->product == USB_DEVICE_ID_JESS_YUREX &&\n\t\t\t\thdev->type == HID_TYPE_USBNONE)\n\t\t\treturn true;\n\t\tbreak;\n\tcase USB_VENDOR_ID_VELLEMAN:\n\t\t/* These are not HID devices.  They are handled by comedi. */\n\t\tif ((hdev->product >= USB_DEVICE_ID_VELLEMAN_K8055_FIRST &&\n\t\t     hdev->product <= USB_DEVICE_ID_VELLEMAN_K8055_LAST) ||\n\t\t    (hdev->product >= USB_DEVICE_ID_VELLEMAN_K8061_FIRST &&\n\t\t     hdev->product <= USB_DEVICE_ID_VELLEMAN_K8061_LAST))\n\t\t\treturn true;\n\t\tbreak;\n\tcase USB_VENDOR_ID_ATMEL_V_USB:\n\t\t/* Masterkit MA901 usb radio based on Atmel tiny85 chip and\n\t\t * it has the same USB ID as many Atmel V-USB devices. This\n\t\t * usb radio is handled by radio-ma901.c driver so we want\n\t\t * ignore the hid. Check the name, bus, product and ignore\n\t\t * if we have MA901 usb radio.\n\t\t */\n\t\tif (hdev->product == USB_DEVICE_ID_ATMEL_V_USB &&\n\t\t\thdev->bus == BUS_USB &&\n\t\t\tstrncmp(hdev->name, \"www.masterkit.ru MA901\", 22) == 0)\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\n\tif (hdev->type == HID_TYPE_USBMOUSE &&\n\t\t\thid_match_id(hdev, hid_mouse_ignore_list))\n\t\treturn true;\n\n\treturn !!hid_match_id(hdev, hid_ignore_list);\n}\nEXPORT_SYMBOL_GPL(hid_ignore);\n\nint hid_add_device(struct hid_device *hdev)\n{\n\tstatic atomic_t id = ATOMIC_INIT(0);\n\tint ret;\n\n\tif (WARN_ON(hdev->status & HID_STAT_ADDED))\n\t\treturn -EBUSY;\n\n\t/* we need to kill them here, otherwise they will stay allocated to\n\t * wait for coming driver */\n\tif (hid_ignore(hdev))\n\t\treturn -ENODEV;\n\n\t/*\n\t * Check for the mandatory transport channel.\n\t */\n\t if (!hdev->ll_driver->raw_request) {\n\t\thid_err(hdev, \"transport driver missing .raw_request()\\n\");\n\t\treturn -EINVAL;\n\t }\n\n\t/*\n\t * Read the device report descriptor once and use as template\n\t * for the driver-specific modifications.\n\t */\n\tret = hdev->ll_driver->parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\tif (!hdev->dev_rdesc)\n\t\treturn -ENODEV;\n\n\t/*\n\t * Scan generic devices for group information\n\t */\n\tif (hid_ignore_special_drivers ||\n\t    (!hdev->group &&\n\t     !hid_match_id(hdev, hid_have_special_driver))) {\n\t\tret = hid_scan_report(hdev);\n\t\tif (ret)\n\t\t\thid_warn(hdev, \"bad device descriptor (%d)\\n\", ret);\n\t}\n\n\t/* XXX hack, any other cleaner solution after the driver core\n\t * is converted to allow more than 20 bytes as the device name? */\n\tdev_set_name(&hdev->dev, \"%04X:%04X:%04X.%04X\", hdev->bus,\n\t\t     hdev->vendor, hdev->product, atomic_inc_return(&id));\n\n\thid_debug_register(hdev, dev_name(&hdev->dev));\n\tret = device_add(&hdev->dev);\n\tif (!ret)\n\t\thdev->status |= HID_STAT_ADDED;\n\telse\n\t\thid_debug_unregister(hdev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_add_device);\n\n/**\n * hid_allocate_device - allocate new hid device descriptor\n *\n * Allocate and initialize hid device, so that hid_destroy_device might be\n * used to free it.\n *\n * New hid_device pointer is returned on success, otherwise ERR_PTR encoded\n * error value.\n */\nstruct hid_device *hid_allocate_device(void)\n{\n\tstruct hid_device *hdev;\n\tint ret = -ENOMEM;\n\n\thdev = kzalloc(sizeof(*hdev), GFP_KERNEL);\n\tif (hdev == NULL)\n\t\treturn ERR_PTR(ret);\n\n\tdevice_initialize(&hdev->dev);\n\thdev->dev.release = hid_device_release;\n\thdev->dev.bus = &hid_bus_type;\n\tdevice_enable_async_suspend(&hdev->dev);\n\n\thid_close_report(hdev);\n\n\tinit_waitqueue_head(&hdev->debug_wait);\n\tINIT_LIST_HEAD(&hdev->debug_list);\n\tspin_lock_init(&hdev->debug_list_lock);\n\tsema_init(&hdev->driver_lock, 1);\n\tsema_init(&hdev->driver_input_lock, 1);\n\n\treturn hdev;\n}\nEXPORT_SYMBOL_GPL(hid_allocate_device);\n\nstatic void hid_remove_device(struct hid_device *hdev)\n{\n\tif (hdev->status & HID_STAT_ADDED) {\n\t\tdevice_del(&hdev->dev);\n\t\thid_debug_unregister(hdev);\n\t\thdev->status &= ~HID_STAT_ADDED;\n\t}\n\tkfree(hdev->dev_rdesc);\n\thdev->dev_rdesc = NULL;\n\thdev->dev_rsize = 0;\n}\n\n/**\n * hid_destroy_device - free previously allocated device\n *\n * @hdev: hid device\n *\n * If you allocate hid_device through hid_allocate_device, you should ever\n * free by this function.\n */\nvoid hid_destroy_device(struct hid_device *hdev)\n{\n\thid_remove_device(hdev);\n\tput_device(&hdev->dev);\n}\nEXPORT_SYMBOL_GPL(hid_destroy_device);\n\nint __hid_register_driver(struct hid_driver *hdrv, struct module *owner,\n\t\tconst char *mod_name)\n{\n\tint ret;\n\n\thdrv->driver.name = hdrv->name;\n\thdrv->driver.bus = &hid_bus_type;\n\thdrv->driver.owner = owner;\n\thdrv->driver.mod_name = mod_name;\n\n\tINIT_LIST_HEAD(&hdrv->dyn_list);\n\tspin_lock_init(&hdrv->dyn_lock);\n\n\tret = driver_register(&hdrv->driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = driver_create_file(&hdrv->driver, &driver_attr_new_id);\n\tif (ret)\n\t\tdriver_unregister(&hdrv->driver);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__hid_register_driver);\n\nvoid hid_unregister_driver(struct hid_driver *hdrv)\n{\n\tdriver_remove_file(&hdrv->driver, &driver_attr_new_id);\n\tdriver_unregister(&hdrv->driver);\n\thid_free_dynids(hdrv);\n}\nEXPORT_SYMBOL_GPL(hid_unregister_driver);\n\nint hid_check_keys_pressed(struct hid_device *hid)\n{\n\tstruct hid_input *hidinput;\n\tint i;\n\n\tif (!(hid->claimed & HID_CLAIMED_INPUT))\n\t\treturn 0;\n\n\tlist_for_each_entry(hidinput, &hid->inputs, list) {\n\t\tfor (i = 0; i < BITS_TO_LONGS(KEY_MAX); i++)\n\t\t\tif (hidinput->input->key[i])\n\t\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(hid_check_keys_pressed);\n\nstatic int __init hid_init(void)\n{\n\tint ret;\n\n\tif (hid_debug)\n\t\tpr_warn(\"hid_debug is now used solely for parser and driver debugging.\\n\"\n\t\t\t\"debugfs is now used for inspecting the device (report descriptor, reports)\\n\");\n\n\tret = bus_register(&hid_bus_type);\n\tif (ret) {\n\t\tpr_err(\"can't register hid bus\\n\");\n\t\tgoto err;\n\t}\n\n\tret = hidraw_init();\n\tif (ret)\n\t\tgoto err_bus;\n\n\thid_debug_init();\n\n\treturn 0;\nerr_bus:\n\tbus_unregister(&hid_bus_type);\nerr:\n\treturn ret;\n}\n\nstatic void __exit hid_exit(void)\n{\n\thid_debug_exit();\n\thidraw_exit();\n\tbus_unregister(&hid_bus_type);\n}\n\nmodule_init(hid_init);\nmodule_exit(hid_exit);\n\nMODULE_AUTHOR(\"Andreas Gal\");\nMODULE_AUTHOR(\"Vojtech Pavlik\");\nMODULE_AUTHOR(\"Jiri Kosina\");\nMODULE_LICENSE(DRIVER_LICENSE);\n\n"], "buggy_code_start_loc": [1295], "buggy_code_end_loc": [1312], "fixing_code_start_loc": [1296], "fixing_code_end_loc": [1316], "type": "CWE-125", "message": "The hid_input_field function in drivers/hid/hid-core.c in the Linux kernel before 4.6 allows physically proximate attackers to obtain sensitive information from kernel memory or cause a denial of service (out-of-bounds read) by connecting a device, as demonstrated by a Logitech DJ receiver.", "other": {"cve": {"id": "CVE-2016-7915", "sourceIdentifier": "security@android.com", "published": "2016-11-16T05:59:09.923", "lastModified": "2018-01-05T02:31:15.997", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The hid_input_field function in drivers/hid/hid-core.c in the Linux kernel before 4.6 allows physically proximate attackers to obtain sensitive information from kernel memory or cause a denial of service (out-of-bounds read) by connecting a device, as demonstrated by a Logitech DJ receiver."}, {"lang": "es", "value": "La funci\u00f3n hid_input_field en drivers/hid/hid-core.c en el kernel de Linux en versiones anteriores a 4.6 Permite que atacantes f\u00edsicamente pr\u00f3ximos obtengan informaci\u00f3n sensible de la memoria del n\u00facleo o causen una denegaci\u00f3n de servicio (lectura fuera de rango) conectando un dispositivo, como lo demuestra un receptor Logitech DJ."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.5.7", "matchCriteriaId": "02606D90-EB6B-45DE-B022-6E5783BD64FA"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=50220dead1650609206efe91f0cc116132d59b3f", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2574.html", "source": "security@android.com"}, {"url": "http://source.android.com/security/bulletin/2016-11-01.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94138", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/50220dead1650609206efe91f0cc116132d59b3f", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/50220dead1650609206efe91f0cc116132d59b3f"}}