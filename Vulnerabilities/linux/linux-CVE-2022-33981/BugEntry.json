{"buggy_code": ["# SPDX-License-Identifier: GPL-2.0\n#\n# Block device driver configuration\n#\n\nmenuconfig BLK_DEV\n\tbool \"Block devices\"\n\tdepends on BLOCK\n\tdefault y\n\thelp\n\t  Say Y here to get to see options for various different block device\n\t  drivers. This option alone does not add any kernel code.\n\n\t  If you say N, all options in this submenu will be skipped and disabled;\n\t  only do this if you know what you are doing.\n\nif BLK_DEV\n\nsource \"drivers/block/null_blk/Kconfig\"\n\nconfig BLK_DEV_FD\n\ttristate \"Normal floppy disk support\"\n\tdepends on ARCH_MAY_HAVE_PC_FDC\n\thelp\n\t  If you want to use the floppy disk drive(s) of your PC under Linux,\n\t  say Y. Information about this driver, especially important for IBM\n\t  Thinkpad users, is contained in\n\t  <file:Documentation/admin-guide/blockdev/floppy.rst>.\n\t  That file also contains the location of the Floppy driver FAQ as\n\t  well as location of the fdutils package used to configure additional\n\t  parameters of the driver at run time.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called floppy.\n\nconfig AMIGA_FLOPPY\n\ttristate \"Amiga floppy support\"\n\tdepends on AMIGA\n\nconfig ATARI_FLOPPY\n\ttristate \"Atari floppy support\"\n\tdepends on ATARI\n\nconfig MAC_FLOPPY\n\ttristate \"Support for PowerMac floppy\"\n\tdepends on PPC_PMAC && !PPC_PMAC64\n\thelp\n\t  If you have a SWIM-3 (Super Woz Integrated Machine 3; from Apple)\n\t  floppy controller, say Y here. Most commonly found in PowerMacs.\n\nconfig BLK_DEV_SWIM\n\ttristate \"Support for SWIM Macintosh floppy\"\n\tdepends on M68K && MAC && !HIGHMEM\n\thelp\n\t  You should select this option if you want floppy support\n\t  and you don't have a II, IIfx, Q900, Q950 or AV series.\n\nconfig AMIGA_Z2RAM\n\ttristate \"Amiga Zorro II ramdisk support\"\n\tdepends on ZORRO\n\thelp\n\t  This enables support for using Chip RAM and Zorro II RAM as a\n\t  ramdisk or as a swap partition. Say Y if you want to include this\n\t  driver in the kernel.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called z2ram.\n\nconfig N64CART\n\tbool \"N64 cart support\"\n\tdepends on MACH_NINTENDO64\n\thelp\n\t  Support for the N64 cart.\n\nconfig CDROM\n\ttristate\n\nconfig GDROM\n\ttristate \"SEGA Dreamcast GD-ROM drive\"\n\tdepends on SH_DREAMCAST\n\tselect CDROM\n\thelp\n\t  A standard SEGA Dreamcast comes with a modified CD ROM drive called a\n\t  \"GD-ROM\" by SEGA to signify it is capable of reading special disks\n\t  with up to 1 GB of data. This drive will also read standard CD ROM\n\t  disks. Select this option to access any disks in your GD ROM drive.\n\t  Most users will want to say \"Y\" here.\n\t  You can also build this as a module which will be called gdrom.\n\nconfig PARIDE\n\ttristate \"Parallel port IDE device support\"\n\tdepends on PARPORT_PC\n\thelp\n\t  There are many external CD-ROM and disk devices that connect through\n\t  your computer's parallel port. Most of them are actually IDE devices\n\t  using a parallel port IDE adapter. This option enables the PARIDE\n\t  subsystem which contains drivers for many of these external drives.\n\t  Read <file:Documentation/admin-guide/blockdev/paride.rst> for more information.\n\n\t  If you have said Y to the \"Parallel-port support\" configuration\n\t  option, you may share a single port between your printer and other\n\t  parallel port devices. Answer Y to build PARIDE support into your\n\t  kernel, or M if you would like to build it as a loadable module. If\n\t  your parallel port support is in a loadable module, you must build\n\t  PARIDE as a module. If you built PARIDE support into your kernel,\n\t  you may still build the individual protocol modules and high-level\n\t  drivers as loadable modules. If you build this support as a module,\n\t  it will be called paride.\n\n\t  To use the PARIDE support, you must say Y or M here and also to at\n\t  least one high-level driver (e.g. \"Parallel port IDE disks\",\n\t  \"Parallel port ATAPI CD-ROMs\", \"Parallel port ATAPI disks\" etc.) and\n\t  to at least one protocol driver (e.g. \"ATEN EH-100 protocol\",\n\t  \"MicroSolutions backpack protocol\", \"DataStor Commuter protocol\"\n\t  etc.).\n\nsource \"drivers/block/paride/Kconfig\"\n\nsource \"drivers/block/mtip32xx/Kconfig\"\n\nsource \"drivers/block/zram/Kconfig\"\n\nconfig BLK_DEV_UBD\n\tbool \"Virtual block device\"\n\tdepends on UML\n\thelp\n          The User-Mode Linux port includes a driver called UBD which will let\n          you access arbitrary files on the host computer as block devices.\n          Unless you know that you do not need such virtual block devices say\n          Y here.\n\nconfig BLK_DEV_UBD_SYNC\n\tbool \"Always do synchronous disk IO for UBD\"\n\tdepends on BLK_DEV_UBD\n\thelp\n\t  Writes to the virtual block device are not immediately written to the\n\t  host's disk; this may cause problems if, for example, the User-Mode\n\t  Linux 'Virtual Machine' uses a journalling filesystem and the host\n\t  computer crashes.\n\n          Synchronous operation (i.e. always writing data to the host's disk\n          immediately) is configurable on a per-UBD basis by using a special\n          kernel command line option.  Alternatively, you can say Y here to\n          turn on synchronous operation by default for all block devices.\n\n          If you're running a journalling file system (like reiserfs, for\n          example) in your virtual machine, you will want to say Y here.  If\n          you care for the safety of the data in your virtual machine, Y is a\n          wise choice too.  In all other cases (for example, if you're just\n          playing around with User-Mode Linux) you can choose N.\n\nconfig BLK_DEV_COW_COMMON\n\tbool\n\tdefault BLK_DEV_UBD\n\nconfig BLK_DEV_LOOP\n\ttristate \"Loopback device support\"\n\thelp\n\t  Saying Y here will allow you to use a regular file as a block\n\t  device; you can then create a file system on that block device and\n\t  mount it just as you would mount other block devices such as hard\n\t  drive partitions, CD-ROM drives or floppy drives. The loop devices\n\t  are block special device files with major number 7 and typically\n\t  called /dev/loop0, /dev/loop1 etc.\n\n\t  This is useful if you want to check an ISO 9660 file system before\n\t  burning the CD, or if you want to use floppy images without first\n\t  writing them to floppy. Furthermore, some Linux distributions avoid\n\t  the need for a dedicated Linux partition by keeping their complete\n\t  root file system inside a DOS FAT file using this loop device\n\t  driver.\n\n\t  To use the loop device, you need the losetup utility, found in the\n\t  util-linux package, see\n\t  <https://www.kernel.org/pub/linux/utils/util-linux/>.\n\n\t  The loop device driver can also be used to \"hide\" a file system in\n\t  a disk partition, floppy, or regular file, either using encryption\n\t  (scrambling the data) or steganography (hiding the data in the low\n\t  bits of, say, a sound file). This is also safe if the file resides\n\t  on a remote file server.\n\n\t  Note that this loop device has nothing to do with the loopback\n\t  device used for network connections from the machine to itself.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called loop.\n\n\t  Most users will answer N here.\n\nconfig BLK_DEV_LOOP_MIN_COUNT\n\tint \"Number of loop devices to pre-create at init time\"\n\tdepends on BLK_DEV_LOOP\n\tdefault 8\n\thelp\n\t  Static number of loop devices to be unconditionally pre-created\n\t  at init time.\n\n\t  This default value can be overwritten on the kernel command\n\t  line or with module-parameter loop.max_loop.\n\n\t  The historic default is 8. If a late 2011 version of losetup(8)\n\t  is used, it can be set to 0, since needed loop devices can be\n\t  dynamically allocated with the /dev/loop-control interface.\n\nsource \"drivers/block/drbd/Kconfig\"\n\nconfig BLK_DEV_NBD\n\ttristate \"Network block device support\"\n\tdepends on NET\n\thelp\n\t  Saying Y here will allow your computer to be a client for network\n\t  block devices, i.e. it will be able to use block devices exported by\n\t  servers (mount file systems on them etc.). Communication between\n\t  client and server works over TCP/IP networking, but to the client\n\t  program this is hidden: it looks like a regular local file access to\n\t  a block device special file such as /dev/nd0.\n\n\t  Network block devices also allows you to run a block-device in\n\t  userland (making server and client physically the same computer,\n\t  communicating using the loopback network device).\n\n\t  Read <file:Documentation/admin-guide/blockdev/nbd.rst> for more information,\n\t  especially about where to find the server code, which runs in user\n\t  space and does not need special kernel support.\n\n\t  Note that this has nothing to do with the network file systems NFS\n\t  or Coda; you can say N here even if you intend to use NFS or Coda.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called nbd.\n\n\t  If unsure, say N.\n\nconfig BLK_DEV_SX8\n\ttristate \"Promise SATA SX8 support\"\n\tdepends on PCI\n\thelp\n\t  Saying Y or M here will enable support for the \n\t  Promise SATA SX8 controllers.\n\n\t  Use devices /dev/sx8/$N and /dev/sx8/$Np$M.\n\nconfig BLK_DEV_RAM\n\ttristate \"RAM block device support\"\n\thelp\n\t  Saying Y here will allow you to use a portion of your RAM memory as\n\t  a block device, so that you can make file systems on it, read and\n\t  write to it and do all the other things that you can do with normal\n\t  block devices (such as hard drives). It is usually used to load and\n\t  store a copy of a minimal root file system off of a floppy into RAM\n\t  during the initial install of Linux.\n\n\t  Note that the kernel command line option \"ramdisk=XX\" is now obsolete.\n\t  For details, read <file:Documentation/admin-guide/blockdev/ramdisk.rst>.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called brd. An alias \"rd\" has been defined\n\t  for historical reasons.\n\n\t  Most normal users won't need the RAM disk functionality, and can\n\t  thus say N here.\n\nconfig BLK_DEV_RAM_COUNT\n\tint \"Default number of RAM disks\"\n\tdefault \"16\"\n\tdepends on BLK_DEV_RAM\n\thelp\n\t  The default value is 16 RAM disks. Change this if you know what you\n\t  are doing. If you boot from a filesystem that needs to be extracted\n\t  in memory, you will need at least one RAM disk (e.g. root on cramfs).\n\nconfig BLK_DEV_RAM_SIZE\n\tint \"Default RAM disk size (kbytes)\"\n\tdepends on BLK_DEV_RAM\n\tdefault \"4096\"\n\thelp\n\t  The default value is 4096 kilobytes. Only change this if you know\n\t  what you are doing.\n\nconfig CDROM_PKTCDVD\n\ttristate \"Packet writing on CD/DVD media (DEPRECATED)\"\n\tdepends on !UML\n\tdepends on SCSI\n\tselect CDROM\n\thelp\n\t  Note: This driver is deprecated and will be removed from the\n\t  kernel in the near future!\n\n\t  If you have a CDROM/DVD drive that supports packet writing, say\n\t  Y to include support. It should work with any MMC/Mt Fuji\n\t  compliant ATAPI or SCSI drive, which is just about any newer\n\t  DVD/CD writer.\n\n\t  Currently only writing to CD-RW, DVD-RW, DVD+RW and DVDRAM discs\n\t  is possible.\n\t  DVD-RW disks must be in restricted overwrite mode.\n\n\t  See the file <file:Documentation/cdrom/packet-writing.rst>\n\t  for further information on the use of this driver.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called pktcdvd.\n\nconfig CDROM_PKTCDVD_BUFFERS\n\tint \"Free buffers for data gathering\"\n\tdepends on CDROM_PKTCDVD\n\tdefault \"8\"\n\thelp\n\t  This controls the maximum number of active concurrent packets. More\n\t  concurrent packets can increase write performance, but also require\n\t  more memory. Each concurrent packet will require approximately 64Kb\n\t  of non-swappable kernel memory, memory which will be allocated when\n\t  a disc is opened for writing.\n\nconfig CDROM_PKTCDVD_WCACHE\n\tbool \"Enable write caching\"\n\tdepends on CDROM_PKTCDVD\n\thelp\n\t  If enabled, write caching will be set for the CD-R/W device. For now\n\t  this option is dangerous unless the CD-RW media is known good, as we\n\t  don't do deferred write error handling yet.\n\nconfig ATA_OVER_ETH\n\ttristate \"ATA over Ethernet support\"\n\tdepends on NET\n\thelp\n\tThis driver provides Support for ATA over Ethernet block\n\tdevices like the Coraid EtherDrive (R) Storage Blade.\n\nconfig SUNVDC\n\ttristate \"Sun Virtual Disk Client support\"\n\tdepends on SUN_LDOMS\n\thelp\n\t  Support for virtual disk devices as a client under Sun\n\t  Logical Domains.\n\nsource \"drivers/s390/block/Kconfig\"\n\nconfig XEN_BLKDEV_FRONTEND\n\ttristate \"Xen virtual block device support\"\n\tdepends on XEN\n\tdefault y\n\tselect XEN_XENBUS_FRONTEND\n\thelp\n\t  This driver implements the front-end of the Xen virtual\n\t  block device driver.  It communicates with a back-end driver\n\t  in another domain which drives the actual block device.\n\nconfig XEN_BLKDEV_BACKEND\n\ttristate \"Xen block-device backend driver\"\n\tdepends on XEN_BACKEND\n\thelp\n\t  The block-device backend driver allows the kernel to export its\n\t  block devices to other guests via a high-performance shared-memory\n\t  interface.\n\n\t  The corresponding Linux frontend driver is enabled by the\n\t  CONFIG_XEN_BLKDEV_FRONTEND configuration option.\n\n\t  The backend driver attaches itself to a any block device specified\n\t  in the XenBus configuration. There are no limits to what the block\n\t  device as long as it has a major and minor.\n\n\t  If you are compiling a kernel to run in a Xen block backend driver\n\t  domain (often this is domain 0) you should say Y here. To\n\t  compile this driver as a module, chose M here: the module\n\t  will be called xen-blkback.\n\n\nconfig VIRTIO_BLK\n\ttristate \"Virtio block driver\"\n\tdepends on VIRTIO\n\tselect SG_POOL\n\thelp\n\t  This is the virtual block driver for virtio.  It can be used with\n          QEMU based VMMs (like KVM or Xen).  Say Y or M.\n\nconfig BLK_DEV_RBD\n\ttristate \"Rados block device (RBD)\"\n\tdepends on INET && BLOCK\n\tselect CEPH_LIB\n\tselect LIBCRC32C\n\tselect CRYPTO_AES\n\tselect CRYPTO\n\thelp\n\t  Say Y here if you want include the Rados block device, which stripes\n\t  a block device over objects stored in the Ceph distributed object\n\t  store.\n\n\t  More information at http://ceph.newdream.net/.\n\n\t  If unsure, say N.\n\nsource \"drivers/block/rnbd/Kconfig\"\n\nendif # BLK_DEV\n", "// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/drivers/block/floppy.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *  Copyright (C) 1993, 1994  Alain Knaff\n *  Copyright (C) 1998 Alan Cox\n */\n\n/*\n * 02.12.91 - Changed to static variables to indicate need for reset\n * and recalibrate. This makes some things easier (output_byte reset\n * checking etc), and means less interrupt jumping in case of errors,\n * so the code is hopefully easier to understand.\n */\n\n/*\n * This file is certainly a mess. I've tried my best to get it working,\n * but I don't like programming floppies, and I have only one anyway.\n * Urgel. I should check for more errors, and do more graceful error\n * recovery. Seems there are problems with several drives. I've tried to\n * correct them. No promises.\n */\n\n/*\n * As with hd.c, all routines within this file can (and will) be called\n * by interrupts, so extreme caution is needed. A hardware interrupt\n * handler may not sleep, or a kernel panic will happen. Thus I cannot\n * call \"floppy-on\" directly, but have to set a special timer interrupt\n * etc.\n */\n\n/*\n * 28.02.92 - made track-buffering routines, based on the routines written\n * by entropy@wintermute.wpi.edu (Lawrence Foard). Linus.\n */\n\n/*\n * Automatic floppy-detection and formatting written by Werner Almesberger\n * (almesber@nessie.cs.id.ethz.ch), who also corrected some problems with\n * the floppy-change signal detection.\n */\n\n/*\n * 1992/7/22 -- Hennus Bergman: Added better error reporting, fixed\n * FDC data overrun bug, added some preliminary stuff for vertical\n * recording support.\n *\n * 1992/9/17: Added DMA allocation & DMA functions. -- hhb.\n *\n * TODO: Errors are still not counted properly.\n */\n\n/* 1992/9/20\n * Modifications for ``Sector Shifting'' by Rob Hooft (hooft@chem.ruu.nl)\n * modeled after the freeware MS-DOS program fdformat/88 V1.8 by\n * Christoph H. Hochst\\\"atter.\n * I have fixed the shift values to the ones I always use. Maybe a new\n * ioctl() should be created to be able to modify them.\n * There is a bug in the driver that makes it impossible to format a\n * floppy as the first thing after bootup.\n */\n\n/*\n * 1993/4/29 -- Linus -- cleaned up the timer handling in the kernel, and\n * this helped the floppy driver as well. Much cleaner, and still seems to\n * work.\n */\n\n/* 1994/6/24 --bbroad-- added the floppy table entries and made\n * minor modifications to allow 2.88 floppies to be run.\n */\n\n/* 1994/7/13 -- Paul Vojta -- modified the probing code to allow three or more\n * disk types.\n */\n\n/*\n * 1994/8/8 -- Alain Knaff -- Switched to fdpatch driver: Support for bigger\n * format bug fixes, but unfortunately some new bugs too...\n */\n\n/* 1994/9/17 -- Koen Holtman -- added logging of physical floppy write\n * errors to allow safe writing by specialized programs.\n */\n\n/* 1995/4/24 -- Dan Fandrich -- added support for Commodore 1581 3.5\" disks\n * by defining bit 1 of the \"stretch\" parameter to mean put sectors on the\n * opposite side of the disk, leaving the sector IDs alone (i.e. Commodore's\n * drives are \"upside-down\").\n */\n\n/*\n * 1995/8/26 -- Andreas Busse -- added Mips support.\n */\n\n/*\n * 1995/10/18 -- Ralf Baechle -- Portability cleanup; move machine dependent\n * features to asm/floppy.h.\n */\n\n/*\n * 1998/1/21 -- Richard Gooch <rgooch@atnf.csiro.au> -- devfs support\n */\n\n/*\n * 1998/05/07 -- Russell King -- More portability cleanups; moved definition of\n * interrupt and dma channel to asm/floppy.h. Cleaned up some formatting &\n * use of '0' for NULL.\n */\n\n/*\n * 1998/06/07 -- Alan Cox -- Merged the 2.0.34 fixes for resource allocation\n * failures.\n */\n\n/*\n * 1998/09/20 -- David Weinehall -- Added slow-down code for buggy PS/2-drives.\n */\n\n/*\n * 1999/08/13 -- Paul Slootman -- floppy stopped working on Alpha after 24\n * days, 6 hours, 32 minutes and 32 seconds (i.e. MAXINT jiffies; ints were\n * being used to store jiffies, which are unsigned longs).\n */\n\n/*\n * 2000/08/28 -- Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n * - get rid of check_region\n * - s/suser/capable/\n */\n\n/*\n * 2001/08/26 -- Paul Gortmaker - fix insmod oops on machines with no\n * floppy controller (lingering task on list after module is gone... boom.)\n */\n\n/*\n * 2002/02/07 -- Anton Altaparmakov - Fix io ports reservation to correct range\n * (0x3f2-0x3f5, 0x3f7). This fix is a bit of a hack but the proper fix\n * requires many non-obvious changes in arch dependent code.\n */\n\n/* 2003/07/28 -- Daniele Bellucci <bellucda@tiscali.it>.\n * Better audit of register_blkdev.\n */\n\n#define REALLY_SLOW_IO\n\n#define DEBUGT 2\n\n#define DPRINT(format, args...) \\\n\tpr_info(\"floppy%d: \" format, current_drive, ##args)\n\n#define DCL_DEBUG\t\t/* debug disk change line */\n#ifdef DCL_DEBUG\n#define debug_dcl(test, fmt, args...) \\\n\tdo { if ((test) & FD_DEBUG) DPRINT(fmt, ##args); } while (0)\n#else\n#define debug_dcl(test, fmt, args...) \\\n\tdo { if (0) DPRINT(fmt, ##args); } while (0)\n#endif\n\n/* do print messages for unexpected interrupts */\nstatic int print_unex = 1;\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/fdreg.h>\n#include <linux/fd.h>\n#include <linux/hdreg.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/string.h>\n#include <linux/jiffies.h>\n#include <linux/fcntl.h>\n#include <linux/delay.h>\n#include <linux/mc146818rtc.h>\t/* CMOS defines */\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/major.h>\n#include <linux/platform_device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/compat.h>\n\n/*\n * PS/2 floppies have much slower step rates than regular floppies.\n * It's been recommended that take about 1/4 of the default speed\n * in some more extreme cases.\n */\nstatic DEFINE_MUTEX(floppy_mutex);\nstatic int slow_floppy;\n\n#include <asm/dma.h>\n#include <asm/irq.h>\n\nstatic int FLOPPY_IRQ = 6;\nstatic int FLOPPY_DMA = 2;\nstatic int can_use_virtual_dma = 2;\n/* =======\n * can use virtual DMA:\n * 0 = use of virtual DMA disallowed by config\n * 1 = use of virtual DMA prescribed by config\n * 2 = no virtual DMA preference configured.  By default try hard DMA,\n * but fall back on virtual DMA when not enough memory available\n */\n\nstatic int use_virtual_dma;\n/* =======\n * use virtual DMA\n * 0 using hard DMA\n * 1 using virtual DMA\n * This variable is set to virtual when a DMA mem problem arises, and\n * reset back in floppy_grab_irq_and_dma.\n * It is not safe to reset it in other circumstances, because the floppy\n * driver may have several buffers in use at once, and we do currently not\n * record each buffers capabilities\n */\n\nstatic DEFINE_SPINLOCK(floppy_lock);\n\nstatic unsigned short virtual_dma_port = 0x3f0;\nirqreturn_t floppy_interrupt(int irq, void *dev_id);\nstatic int set_dor(int fdc, char mask, char data);\n\n#define K_64\t0x10000\t\t/* 64KB */\n\n/* the following is the mask of allowed drives. By default units 2 and\n * 3 of both floppy controllers are disabled, because switching on the\n * motor of these drives causes system hangs on some PCI computers. drive\n * 0 is the low bit (0x1), and drive 7 is the high bit (0x80). Bits are on if\n * a drive is allowed.\n *\n * NOTE: This must come before we include the arch floppy header because\n *       some ports reference this variable from there. -DaveM\n */\n\nstatic int allowed_drive_mask = 0x33;\n\n#include <asm/floppy.h>\n\nstatic int irqdma_allocated;\n\n#include <linux/blk-mq.h>\n#include <linux/blkpg.h>\n#include <linux/cdrom.h>\t/* for the compatibility eject ioctl */\n#include <linux/completion.h>\n\nstatic LIST_HEAD(floppy_reqs);\nstatic struct request *current_req;\nstatic int set_next_request(void);\n\n#ifndef fd_get_dma_residue\n#define fd_get_dma_residue() get_dma_residue(FLOPPY_DMA)\n#endif\n\n/* Dma Memory related stuff */\n\n#ifndef fd_dma_mem_free\n#define fd_dma_mem_free(addr, size) free_pages(addr, get_order(size))\n#endif\n\n#ifndef fd_dma_mem_alloc\n#define fd_dma_mem_alloc(size) __get_dma_pages(GFP_KERNEL, get_order(size))\n#endif\n\n#ifndef fd_cacheflush\n#define fd_cacheflush(addr, size) /* nothing... */\n#endif\n\nstatic inline void fallback_on_nodma_alloc(char **addr, size_t l)\n{\n#ifdef FLOPPY_CAN_FALLBACK_ON_NODMA\n\tif (*addr)\n\t\treturn;\t\t/* we have the memory */\n\tif (can_use_virtual_dma != 2)\n\t\treturn;\t\t/* no fallback allowed */\n\tpr_info(\"DMA memory shortage. Temporarily falling back on virtual DMA\\n\");\n\t*addr = (char *)nodma_mem_alloc(l);\n#else\n\treturn;\n#endif\n}\n\n/* End dma memory related stuff */\n\nstatic unsigned long fake_change;\nstatic bool initialized;\n\n#define ITYPE(x)\t(((x) >> 2) & 0x1f)\n#define TOMINOR(x)\t((x & 3) | ((x & 4) << 5))\n#define UNIT(x)\t\t((x) & 0x03)\t\t/* drive on fdc */\n#define FDC(x)\t\t(((x) & 0x04) >> 2)\t/* fdc of drive */\n\t/* reverse mapping from unit and fdc to drive */\n#define REVDRIVE(fdc, unit) ((unit) + ((fdc) << 2))\n\n#define PH_HEAD(floppy, head) (((((floppy)->stretch & 2) >> 1) ^ head) << 2)\n#define STRETCH(floppy)\t((floppy)->stretch & FD_STRETCH)\n\n/* read/write commands */\n#define COMMAND\t\t\t0\n#define DR_SELECT\t\t1\n#define TRACK\t\t\t2\n#define HEAD\t\t\t3\n#define SECTOR\t\t\t4\n#define SIZECODE\t\t5\n#define SECT_PER_TRACK\t\t6\n#define GAP\t\t\t7\n#define SIZECODE2\t\t8\n#define NR_RW 9\n\n/* format commands */\n#define F_SIZECODE\t\t2\n#define F_SECT_PER_TRACK\t3\n#define F_GAP\t\t\t4\n#define F_FILL\t\t\t5\n#define NR_F 6\n\n/*\n * Maximum disk size (in kilobytes).\n * This default is used whenever the current disk size is unknown.\n * [Now it is rather a minimum]\n */\n#define MAX_DISK_SIZE 4\t\t/* 3984 */\n\n/*\n * globals used by 'result()'\n */\nstatic unsigned char reply_buffer[FD_RAW_REPLY_SIZE];\nstatic int inr;\t\t/* size of reply buffer, when called from interrupt */\n#define ST0\t\t0\n#define ST1\t\t1\n#define ST2\t\t2\n#define ST3\t\t0\t/* result of GETSTATUS */\n#define R_TRACK\t\t3\n#define R_HEAD\t\t4\n#define R_SECTOR\t5\n#define R_SIZECODE\t6\n\n#define SEL_DLY\t\t(2 * HZ / 100)\n\n/*\n * this struct defines the different floppy drive types.\n */\nstatic struct {\n\tstruct floppy_drive_params params;\n\tconst char *name;\t/* name printed while booting */\n} default_drive_params[] = {\n/* NOTE: the time values in jiffies should be in msec!\n CMOS drive type\n  |     Maximum data rate supported by drive type\n  |     |   Head load time, msec\n  |     |   |   Head unload time, msec (not used)\n  |     |   |   |     Step rate interval, usec\n  |     |   |   |     |       Time needed for spinup time (jiffies)\n  |     |   |   |     |       |      Timeout for spinning down (jiffies)\n  |     |   |   |     |       |      |   Spindown offset (where disk stops)\n  |     |   |   |     |       |      |   |     Select delay\n  |     |   |   |     |       |      |   |     |     RPS\n  |     |   |   |     |       |      |   |     |     |    Max number of tracks\n  |     |   |   |     |       |      |   |     |     |    |     Interrupt timeout\n  |     |   |   |     |       |      |   |     |     |    |     |   Max nonintlv. sectors\n  |     |   |   |     |       |      |   |     |     |    |     |   | -Max Errors- flags */\n{{0,  500, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  80, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 7, 4, 8, 2, 1, 5, 3,10}, 3*HZ/2, 0 }, \"unknown\" },\n\n{{1,  300, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  40, 3*HZ, 17, {3,1,2,0,2}, 0,\n      0, { 1, 0, 0, 0, 0, 0, 0, 0}, 3*HZ/2, 1 }, \"360K PC\" }, /*5 1/4 360 KB PC*/\n\n{{2,  500, 16, 16, 6000, 4*HZ/10, 3*HZ, 14, SEL_DLY, 6,  83, 3*HZ, 17, {3,1,2,0,2}, 0,\n      0, { 2, 5, 6,23,10,20,12, 0}, 3*HZ/2, 2 }, \"1.2M\" }, /*5 1/4 HD AT*/\n\n{{3,  250, 16, 16, 3000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 4,22,21,30, 3, 0, 0, 0}, 3*HZ/2, 4 }, \"720k\" }, /*3 1/2 DD*/\n\n{{4,  500, 16, 16, 4000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 7, 4,25,22,31,21,29,11}, 3*HZ/2, 7 }, \"1.44M\" }, /*3 1/2 HD*/\n\n{{5, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0,\n      0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, \"2.88M AMI BIOS\" }, /*3 1/2 ED*/\n\n{{6, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0,\n      0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, \"2.88M\" } /*3 1/2 ED*/\n/*    |  --autodetected formats---    |      |      |\n *    read_track                      |      |    Name printed when booting\n *\t\t\t\t      |     Native format\n *\t            Frequency of disk change checks */\n};\n\nstatic struct floppy_drive_params drive_params[N_DRIVE];\nstatic struct floppy_drive_struct drive_state[N_DRIVE];\nstatic struct floppy_write_errors write_errors[N_DRIVE];\nstatic struct timer_list motor_off_timer[N_DRIVE];\nstatic struct blk_mq_tag_set tag_sets[N_DRIVE];\nstatic struct block_device *opened_bdev[N_DRIVE];\nstatic DEFINE_MUTEX(open_lock);\nstatic struct floppy_raw_cmd *raw_cmd, default_raw_cmd;\n\n/*\n * This struct defines the different floppy types.\n *\n * Bit 0 of 'stretch' tells if the tracks need to be doubled for some\n * types (e.g. 360kB diskette in 1.2MB drive, etc.).  Bit 1 of 'stretch'\n * tells if the disk is in Commodore 1581 format, which means side 0 sectors\n * are located on side 1 of the disk but with a side 0 ID, and vice-versa.\n * This is the same as the Sharp MZ-80 5.25\" CP/M disk format, except that the\n * 1581's logical side 0 is on physical side 1, whereas the Sharp's logical\n * side 0 is on physical side 0 (but with the misnamed sector IDs).\n * 'stretch' should probably be renamed to something more general, like\n * 'options'.\n *\n * Bits 2 through 9 of 'stretch' tell the number of the first sector.\n * The LSB (bit 2) is flipped. For most disks, the first sector\n * is 1 (represented by 0x00<<2).  For some CP/M and music sampler\n * disks (such as Ensoniq EPS 16plus) it is 0 (represented as 0x01<<2).\n * For Amstrad CPC disks it is 0xC1 (represented as 0xC0<<2).\n *\n * Other parameters should be self-explanatory (see also setfdprm(8)).\n */\n/*\n\t    Size\n\t     |  Sectors per track\n\t     |  | Head\n\t     |  | |  Tracks\n\t     |  | |  | Stretch\n\t     |  | |  | |  Gap 1 size\n\t     |  | |  | |    |  Data rate, | 0x40 for perp\n\t     |  | |  | |    |    |  Spec1 (stepping rate, head unload\n\t     |  | |  | |    |    |    |    /fmt gap (gap2) */\nstatic struct floppy_struct floppy_type[32] = {\n\t{    0, 0,0, 0,0,0x00,0x00,0x00,0x00,NULL    },\t/*  0 no testing    */\n\t{  720, 9,2,40,0,0x2A,0x02,0xDF,0x50,\"d360\"  }, /*  1 360KB PC      */\n\t{ 2400,15,2,80,0,0x1B,0x00,0xDF,0x54,\"h1200\" },\t/*  2 1.2MB AT      */\n\t{  720, 9,1,80,0,0x2A,0x02,0xDF,0x50,\"D360\"  },\t/*  3 360KB SS 3.5\" */\n\t{ 1440, 9,2,80,0,0x2A,0x02,0xDF,0x50,\"D720\"  },\t/*  4 720KB 3.5\"    */\n\t{  720, 9,2,40,1,0x23,0x01,0xDF,0x50,\"h360\"  },\t/*  5 360KB AT      */\n\t{ 1440, 9,2,80,0,0x23,0x01,0xDF,0x50,\"h720\"  },\t/*  6 720KB AT      */\n\t{ 2880,18,2,80,0,0x1B,0x00,0xCF,0x6C,\"H1440\" },\t/*  7 1.44MB 3.5\"   */\n\t{ 5760,36,2,80,0,0x1B,0x43,0xAF,0x54,\"E2880\" },\t/*  8 2.88MB 3.5\"   */\n\t{ 6240,39,2,80,0,0x1B,0x43,0xAF,0x28,\"E3120\" },\t/*  9 3.12MB 3.5\"   */\n\n\t{ 2880,18,2,80,0,0x25,0x00,0xDF,0x02,\"h1440\" }, /* 10 1.44MB 5.25\"  */\n\t{ 3360,21,2,80,0,0x1C,0x00,0xCF,0x0C,\"H1680\" }, /* 11 1.68MB 3.5\"   */\n\t{  820,10,2,41,1,0x25,0x01,0xDF,0x2E,\"h410\"  },\t/* 12 410KB 5.25\"   */\n\t{ 1640,10,2,82,0,0x25,0x02,0xDF,0x2E,\"H820\"  },\t/* 13 820KB 3.5\"    */\n\t{ 2952,18,2,82,0,0x25,0x00,0xDF,0x02,\"h1476\" },\t/* 14 1.48MB 5.25\"  */\n\t{ 3444,21,2,82,0,0x25,0x00,0xDF,0x0C,\"H1722\" },\t/* 15 1.72MB 3.5\"   */\n\t{  840,10,2,42,1,0x25,0x01,0xDF,0x2E,\"h420\"  },\t/* 16 420KB 5.25\"   */\n\t{ 1660,10,2,83,0,0x25,0x02,0xDF,0x2E,\"H830\"  },\t/* 17 830KB 3.5\"    */\n\t{ 2988,18,2,83,0,0x25,0x00,0xDF,0x02,\"h1494\" },\t/* 18 1.49MB 5.25\"  */\n\t{ 3486,21,2,83,0,0x25,0x00,0xDF,0x0C,\"H1743\" }, /* 19 1.74 MB 3.5\"  */\n\n\t{ 1760,11,2,80,0,0x1C,0x09,0xCF,0x00,\"h880\"  }, /* 20 880KB 5.25\"   */\n\t{ 2080,13,2,80,0,0x1C,0x01,0xCF,0x00,\"D1040\" }, /* 21 1.04MB 3.5\"   */\n\t{ 2240,14,2,80,0,0x1C,0x19,0xCF,0x00,\"D1120\" }, /* 22 1.12MB 3.5\"   */\n\t{ 3200,20,2,80,0,0x1C,0x20,0xCF,0x2C,\"h1600\" }, /* 23 1.6MB 5.25\"   */\n\t{ 3520,22,2,80,0,0x1C,0x08,0xCF,0x2e,\"H1760\" }, /* 24 1.76MB 3.5\"   */\n\t{ 3840,24,2,80,0,0x1C,0x20,0xCF,0x00,\"H1920\" }, /* 25 1.92MB 3.5\"   */\n\t{ 6400,40,2,80,0,0x25,0x5B,0xCF,0x00,\"E3200\" }, /* 26 3.20MB 3.5\"   */\n\t{ 7040,44,2,80,0,0x25,0x5B,0xCF,0x00,\"E3520\" }, /* 27 3.52MB 3.5\"   */\n\t{ 7680,48,2,80,0,0x25,0x63,0xCF,0x00,\"E3840\" }, /* 28 3.84MB 3.5\"   */\n\t{ 3680,23,2,80,0,0x1C,0x10,0xCF,0x00,\"H1840\" }, /* 29 1.84MB 3.5\"   */\n\n\t{ 1600,10,2,80,0,0x25,0x02,0xDF,0x2E,\"D800\"  },\t/* 30 800KB 3.5\"    */\n\t{ 3200,20,2,80,0,0x1C,0x00,0xCF,0x2C,\"H1600\" }, /* 31 1.6MB 3.5\"    */\n};\n\nstatic struct gendisk *disks[N_DRIVE][ARRAY_SIZE(floppy_type)];\n\n#define SECTSIZE (_FD_SECTSIZE(*floppy))\n\n/* Auto-detection: Disk type used until the next media change occurs. */\nstatic struct floppy_struct *current_type[N_DRIVE];\n\n/*\n * User-provided type information. current_type points to\n * the respective entry of this array.\n */\nstatic struct floppy_struct user_params[N_DRIVE];\n\nstatic sector_t floppy_sizes[256];\n\nstatic char floppy_device_name[] = \"floppy\";\n\n/*\n * The driver is trying to determine the correct media format\n * while probing is set. rw_interrupt() clears it after a\n * successful access.\n */\nstatic int probing;\n\n/* Synchronization of FDC access. */\n#define FD_COMMAND_NONE\t\t-1\n#define FD_COMMAND_ERROR\t2\n#define FD_COMMAND_OKAY\t\t3\n\nstatic volatile int command_status = FD_COMMAND_NONE;\nstatic unsigned long fdc_busy;\nstatic DECLARE_WAIT_QUEUE_HEAD(fdc_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(command_done);\n\n/* Errors during formatting are counted here. */\nstatic int format_errors;\n\n/* Format request descriptor. */\nstatic struct format_descr format_req;\n\n/*\n * Rate is 0 for 500kb/s, 1 for 300kbps, 2 for 250kbps\n * Spec1 is 0xSH, where S is stepping rate (F=1ms, E=2ms, D=3ms etc),\n * H is head unload time (1=16ms, 2=32ms, etc)\n */\n\n/*\n * Track buffer\n * Because these are written to by the DMA controller, they must\n * not contain a 64k byte boundary crossing, or data will be\n * corrupted/lost.\n */\nstatic char *floppy_track_buffer;\nstatic int max_buffer_sectors;\n\nstatic int *errors;\ntypedef void (*done_f)(int);\nstatic const struct cont_t {\n\tvoid (*interrupt)(void);\n\t\t\t\t/* this is called after the interrupt of the\n\t\t\t\t * main command */\n\tvoid (*redo)(void);\t/* this is called to retry the operation */\n\tvoid (*error)(void);\t/* this is called to tally an error */\n\tdone_f done;\t\t/* this is called to say if the operation has\n\t\t\t\t * succeeded/failed */\n} *cont;\n\nstatic void floppy_ready(void);\nstatic void floppy_start(void);\nstatic void process_fd_request(void);\nstatic void recalibrate_floppy(void);\nstatic void floppy_shutdown(struct work_struct *);\n\nstatic int floppy_request_regions(int);\nstatic void floppy_release_regions(int);\nstatic int floppy_grab_irq_and_dma(void);\nstatic void floppy_release_irq_and_dma(void);\n\n/*\n * The \"reset\" variable should be tested whenever an interrupt is scheduled,\n * after the commands have been sent. This is to ensure that the driver doesn't\n * get wedged when the interrupt doesn't come because of a failed command.\n * reset doesn't need to be tested before sending commands, because\n * output_byte is automatically disabled when reset is set.\n */\nstatic void reset_fdc(void);\nstatic int floppy_revalidate(struct gendisk *disk);\n\n/*\n * These are global variables, as that's the easiest way to give\n * information to interrupts. They are the data used for the current\n * request.\n */\n#define NO_TRACK\t-1\n#define NEED_1_RECAL\t-2\n#define NEED_2_RECAL\t-3\n\nstatic atomic_t usage_count = ATOMIC_INIT(0);\n\n/* buffer related variables */\nstatic int buffer_track = -1;\nstatic int buffer_drive = -1;\nstatic int buffer_min = -1;\nstatic int buffer_max = -1;\n\n/* fdc related variables, should end up in a struct */\nstatic struct floppy_fdc_state fdc_state[N_FDC];\nstatic int current_fdc;\t\t\t/* current fdc */\n\nstatic struct workqueue_struct *floppy_wq;\n\nstatic struct floppy_struct *_floppy = floppy_type;\nstatic unsigned char current_drive;\nstatic long current_count_sectors;\nstatic unsigned char fsector_t;\t/* sector in track */\nstatic unsigned char in_sector_offset;\t/* offset within physical sector,\n\t\t\t\t\t * expressed in units of 512 bytes */\n\nstatic inline unsigned char fdc_inb(int fdc, int reg)\n{\n\treturn fd_inb(fdc_state[fdc].address, reg);\n}\n\nstatic inline void fdc_outb(unsigned char value, int fdc, int reg)\n{\n\tfd_outb(value, fdc_state[fdc].address, reg);\n}\n\nstatic inline bool drive_no_geom(int drive)\n{\n\treturn !current_type[drive] && !ITYPE(drive_state[drive].fd_device);\n}\n\n#ifndef fd_eject\nstatic inline int fd_eject(int drive)\n{\n\treturn -EINVAL;\n}\n#endif\n\n/*\n * Debugging\n * =========\n */\n#ifdef DEBUGT\nstatic long unsigned debugtimer;\n\nstatic inline void set_debugt(void)\n{\n\tdebugtimer = jiffies;\n}\n\nstatic inline void debugt(const char *func, const char *msg)\n{\n\tif (drive_params[current_drive].flags & DEBUGT)\n\t\tpr_info(\"%s:%s dtime=%lu\\n\", func, msg, jiffies - debugtimer);\n}\n#else\nstatic inline void set_debugt(void) { }\nstatic inline void debugt(const char *func, const char *msg) { }\n#endif /* DEBUGT */\n\n\nstatic DECLARE_DELAYED_WORK(fd_timeout, floppy_shutdown);\nstatic const char *timeout_message;\n\nstatic void is_alive(const char *func, const char *message)\n{\n\t/* this routine checks whether the floppy driver is \"alive\" */\n\tif (test_bit(0, &fdc_busy) && command_status < 2 &&\n\t    !delayed_work_pending(&fd_timeout)) {\n\t\tDPRINT(\"%s: timeout handler died.  %s\\n\", func, message);\n\t}\n}\n\nstatic void (*do_floppy)(void) = NULL;\n\n#define OLOGSIZE 20\n\nstatic void (*lasthandler)(void);\nstatic unsigned long interruptjiffies;\nstatic unsigned long resultjiffies;\nstatic int resultsize;\nstatic unsigned long lastredo;\n\nstatic struct output_log {\n\tunsigned char data;\n\tunsigned char status;\n\tunsigned long jiffies;\n} output_log[OLOGSIZE];\n\nstatic int output_log_pos;\n\n#define MAXTIMEOUT -2\n\nstatic void __reschedule_timeout(int drive, const char *message)\n{\n\tunsigned long delay;\n\n\tif (drive < 0 || drive >= N_DRIVE) {\n\t\tdelay = 20UL * HZ;\n\t\tdrive = 0;\n\t} else\n\t\tdelay = drive_params[drive].timeout;\n\n\tmod_delayed_work(floppy_wq, &fd_timeout, delay);\n\tif (drive_params[drive].flags & FD_DEBUG)\n\t\tDPRINT(\"reschedule timeout %s\\n\", message);\n\ttimeout_message = message;\n}\n\nstatic void reschedule_timeout(int drive, const char *message)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&floppy_lock, flags);\n\t__reschedule_timeout(drive, message);\n\tspin_unlock_irqrestore(&floppy_lock, flags);\n}\n\n#define INFBOUND(a, b) (a) = max_t(int, a, b)\n#define SUPBOUND(a, b) (a) = min_t(int, a, b)\n\n/*\n * Bottom half floppy driver.\n * ==========================\n *\n * This part of the file contains the code talking directly to the hardware,\n * and also the main service loop (seek-configure-spinup-command)\n */\n\n/*\n * disk change.\n * This routine is responsible for maintaining the FD_DISK_CHANGE flag,\n * and the last_checked date.\n *\n * last_checked is the date of the last check which showed 'no disk change'\n * FD_DISK_CHANGE is set under two conditions:\n * 1. The floppy has been changed after some i/o to that floppy already\n *    took place.\n * 2. No floppy disk is in the drive. This is done in order to ensure that\n *    requests are quickly flushed in case there is no disk in the drive. It\n *    follows that FD_DISK_CHANGE can only be cleared if there is a disk in\n *    the drive.\n *\n * For 1., maxblock is observed. Maxblock is 0 if no i/o has taken place yet.\n * For 2., FD_DISK_NEWCHANGE is watched. FD_DISK_NEWCHANGE is cleared on\n *  each seek. If a disk is present, the disk change line should also be\n *  cleared on each seek. Thus, if FD_DISK_NEWCHANGE is clear, but the disk\n *  change line is set, this means either that no disk is in the drive, or\n *  that it has been removed since the last seek.\n *\n * This means that we really have a third possibility too:\n *  The floppy has been changed after the last seek.\n */\n\nstatic int disk_change(int drive)\n{\n\tint fdc = FDC(drive);\n\n\tif (time_before(jiffies, drive_state[drive].select_date + drive_params[drive].select_delay))\n\t\tDPRINT(\"WARNING disk change called early\\n\");\n\tif (!(fdc_state[fdc].dor & (0x10 << UNIT(drive))) ||\n\t    (fdc_state[fdc].dor & 3) != UNIT(drive) || fdc != FDC(drive)) {\n\t\tDPRINT(\"probing disk change on unselected drive\\n\");\n\t\tDPRINT(\"drive=%d fdc=%d dor=%x\\n\", drive, FDC(drive),\n\t\t       (unsigned int)fdc_state[fdc].dor);\n\t}\n\n\tdebug_dcl(drive_params[drive].flags,\n\t\t  \"checking disk change line for drive %d\\n\", drive);\n\tdebug_dcl(drive_params[drive].flags, \"jiffies=%lu\\n\", jiffies);\n\tdebug_dcl(drive_params[drive].flags, \"disk change line=%x\\n\",\n\t\t  fdc_inb(fdc, FD_DIR) & 0x80);\n\tdebug_dcl(drive_params[drive].flags, \"flags=%lx\\n\",\n\t\t  drive_state[drive].flags);\n\n\tif (drive_params[drive].flags & FD_BROKEN_DCL)\n\t\treturn test_bit(FD_DISK_CHANGED_BIT,\n\t\t\t\t&drive_state[drive].flags);\n\tif ((fdc_inb(fdc, FD_DIR) ^ drive_params[drive].flags) & 0x80) {\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\t\t\t\t/* verify write protection */\n\n\t\tif (drive_state[drive].maxblock)\t/* mark it changed */\n\t\t\tset_bit(FD_DISK_CHANGED_BIT,\n\t\t\t\t&drive_state[drive].flags);\n\n\t\t/* invalidate its geometry */\n\t\tif (drive_state[drive].keep_data >= 0) {\n\t\t\tif ((drive_params[drive].flags & FTD_MSG) &&\n\t\t\t    current_type[drive] != NULL)\n\t\t\t\tDPRINT(\"Disk type is undefined after disk change\\n\");\n\t\t\tcurrent_type[drive] = NULL;\n\t\t\tfloppy_sizes[TOMINOR(drive)] = MAX_DISK_SIZE << 1;\n\t\t}\n\n\t\treturn 1;\n\t} else {\n\t\tdrive_state[drive].last_checked = jiffies;\n\t\tclear_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[drive].flags);\n\t}\n\treturn 0;\n}\n\nstatic inline int is_selected(int dor, int unit)\n{\n\treturn ((dor & (0x10 << unit)) && (dor & 3) == unit);\n}\n\nstatic bool is_ready_state(int status)\n{\n\tint state = status & (STATUS_READY | STATUS_DIR | STATUS_DMA);\n\treturn state == STATUS_READY;\n}\n\nstatic int set_dor(int fdc, char mask, char data)\n{\n\tunsigned char unit;\n\tunsigned char drive;\n\tunsigned char newdor;\n\tunsigned char olddor;\n\n\tif (fdc_state[fdc].address == -1)\n\t\treturn -1;\n\n\tolddor = fdc_state[fdc].dor;\n\tnewdor = (olddor & mask) | data;\n\tif (newdor != olddor) {\n\t\tunit = olddor & 0x3;\n\t\tif (is_selected(olddor, unit) && !is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tdebug_dcl(drive_params[drive].flags,\n\t\t\t\t  \"calling disk change from set_dor\\n\");\n\t\t\tdisk_change(drive);\n\t\t}\n\t\tfdc_state[fdc].dor = newdor;\n\t\tfdc_outb(newdor, fdc, FD_DOR);\n\n\t\tunit = newdor & 0x3;\n\t\tif (!is_selected(olddor, unit) && is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tdrive_state[drive].select_date = jiffies;\n\t\t}\n\t}\n\treturn olddor;\n}\n\nstatic void twaddle(int fdc, int drive)\n{\n\tif (drive_params[drive].select_delay)\n\t\treturn;\n\tfdc_outb(fdc_state[fdc].dor & ~(0x10 << UNIT(drive)),\n\t\t fdc, FD_DOR);\n\tfdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);\n\tdrive_state[drive].select_date = jiffies;\n}\n\n/*\n * Reset all driver information about the specified fdc.\n * This is needed after a reset, and after a raw command.\n */\nstatic void reset_fdc_info(int fdc, int mode)\n{\n\tint drive;\n\n\tfdc_state[fdc].spec1 = fdc_state[fdc].spec2 = -1;\n\tfdc_state[fdc].need_configure = 1;\n\tfdc_state[fdc].perp_mode = 1;\n\tfdc_state[fdc].rawcmd = 0;\n\tfor (drive = 0; drive < N_DRIVE; drive++)\n\t\tif (FDC(drive) == fdc &&\n\t\t    (mode || drive_state[drive].track != NEED_1_RECAL))\n\t\t\tdrive_state[drive].track = NEED_2_RECAL;\n}\n\n/*\n * selects the fdc and drive, and enables the fdc's input/dma.\n * Both current_drive and current_fdc are changed to match the new drive.\n */\nstatic void set_fdc(int drive)\n{\n\tunsigned int fdc;\n\n\tif (drive < 0 || drive >= N_DRIVE) {\n\t\tpr_info(\"bad drive value %d\\n\", drive);\n\t\treturn;\n\t}\n\n\tfdc = FDC(drive);\n\tif (fdc >= N_FDC) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (fdc_state[fdc].rawcmd == 2)\n\t\treset_fdc_info(fdc, 1);\n\tif (fdc_inb(fdc, FD_STATUS) != STATUS_READY)\n\t\tfdc_state[fdc].reset = 1;\n\n\tcurrent_drive = drive;\n\tcurrent_fdc = fdc;\n}\n\n/*\n * locks the driver.\n * Both current_drive and current_fdc are changed to match the new drive.\n */\nstatic int lock_fdc(int drive)\n{\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"Trying to lock fdc while usage count=0\\n\"))\n\t\treturn -1;\n\n\tif (wait_event_interruptible(fdc_wait, !test_and_set_bit(0, &fdc_busy)))\n\t\treturn -EINTR;\n\n\tcommand_status = FD_COMMAND_NONE;\n\n\treschedule_timeout(drive, \"lock fdc\");\n\tset_fdc(drive);\n\treturn 0;\n}\n\n/* unlocks the driver */\nstatic void unlock_fdc(void)\n{\n\tif (!test_bit(0, &fdc_busy))\n\t\tDPRINT(\"FDC access conflict!\\n\");\n\n\traw_cmd = NULL;\n\tcommand_status = FD_COMMAND_NONE;\n\tcancel_delayed_work(&fd_timeout);\n\tdo_floppy = NULL;\n\tcont = NULL;\n\tclear_bit(0, &fdc_busy);\n\twake_up(&fdc_wait);\n}\n\n/* switches the motor off after a given timeout */\nstatic void motor_off_callback(struct timer_list *t)\n{\n\tunsigned long nr = t - motor_off_timer;\n\tunsigned char mask = ~(0x10 << UNIT(nr));\n\n\tif (WARN_ON_ONCE(nr >= N_DRIVE))\n\t\treturn;\n\n\tset_dor(FDC(nr), mask, 0);\n}\n\n/* schedules motor off */\nstatic void floppy_off(unsigned int drive)\n{\n\tunsigned long volatile delta;\n\tint fdc = FDC(drive);\n\n\tif (!(fdc_state[fdc].dor & (0x10 << UNIT(drive))))\n\t\treturn;\n\n\tdel_timer(motor_off_timer + drive);\n\n\t/* make spindle stop in a position which minimizes spinup time\n\t * next time */\n\tif (drive_params[drive].rps) {\n\t\tdelta = jiffies - drive_state[drive].first_read_date + HZ -\n\t\t    drive_params[drive].spindown_offset;\n\t\tdelta = ((delta * drive_params[drive].rps) % HZ) / drive_params[drive].rps;\n\t\tmotor_off_timer[drive].expires =\n\t\t    jiffies + drive_params[drive].spindown - delta;\n\t}\n\tadd_timer(motor_off_timer + drive);\n}\n\n/*\n * cycle through all N_DRIVE floppy drives, for disk change testing.\n * stopping at current drive. This is done before any long operation, to\n * be sure to have up to date disk change information.\n */\nstatic void scandrives(void)\n{\n\tint i;\n\tint drive;\n\tint saved_drive;\n\n\tif (drive_params[current_drive].select_delay)\n\t\treturn;\n\n\tsaved_drive = current_drive;\n\tfor (i = 0; i < N_DRIVE; i++) {\n\t\tdrive = (saved_drive + i + 1) % N_DRIVE;\n\t\tif (drive_state[drive].fd_ref == 0 || drive_params[drive].select_delay != 0)\n\t\t\tcontinue;\t/* skip closed drives */\n\t\tset_fdc(drive);\n\t\tif (!(set_dor(current_fdc, ~3, UNIT(drive) | (0x10 << UNIT(drive))) &\n\t\t      (0x10 << UNIT(drive))))\n\t\t\t/* switch the motor off again, if it was off to\n\t\t\t * begin with */\n\t\t\tset_dor(current_fdc, ~(0x10 << UNIT(drive)), 0);\n\t}\n\tset_fdc(saved_drive);\n}\n\nstatic void empty(void)\n{\n}\n\nstatic void (*floppy_work_fn)(void);\n\nstatic void floppy_work_workfn(struct work_struct *work)\n{\n\tfloppy_work_fn();\n}\n\nstatic DECLARE_WORK(floppy_work, floppy_work_workfn);\n\nstatic void schedule_bh(void (*handler)(void))\n{\n\tWARN_ON(work_pending(&floppy_work));\n\n\tfloppy_work_fn = handler;\n\tqueue_work(floppy_wq, &floppy_work);\n}\n\nstatic void (*fd_timer_fn)(void) = NULL;\n\nstatic void fd_timer_workfn(struct work_struct *work)\n{\n\tfd_timer_fn();\n}\n\nstatic DECLARE_DELAYED_WORK(fd_timer, fd_timer_workfn);\n\nstatic void cancel_activity(void)\n{\n\tdo_floppy = NULL;\n\tcancel_delayed_work(&fd_timer);\n\tcancel_work_sync(&floppy_work);\n}\n\n/* this function makes sure that the disk stays in the drive during the\n * transfer */\nstatic void fd_watchdog(void)\n{\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from watchdog\\n\");\n\n\tif (disk_change(current_drive)) {\n\t\tDPRINT(\"disk removed during i/o\\n\");\n\t\tcancel_activity();\n\t\tcont->done(0);\n\t\treset_fdc();\n\t} else {\n\t\tcancel_delayed_work(&fd_timer);\n\t\tfd_timer_fn = fd_watchdog;\n\t\tqueue_delayed_work(floppy_wq, &fd_timer, HZ / 10);\n\t}\n}\n\nstatic void main_command_interrupt(void)\n{\n\tcancel_delayed_work(&fd_timer);\n\tcont->interrupt();\n}\n\n/* waits for a delay (spinup or select) to pass */\nstatic int fd_wait_for_completion(unsigned long expires,\n\t\t\t\t  void (*function)(void))\n{\n\tif (fdc_state[current_fdc].reset) {\n\t\treset_fdc();\t/* do the reset during sleep to win time\n\t\t\t\t * if we don't need to sleep, it's a good\n\t\t\t\t * occasion anyways */\n\t\treturn 1;\n\t}\n\n\tif (time_before(jiffies, expires)) {\n\t\tcancel_delayed_work(&fd_timer);\n\t\tfd_timer_fn = function;\n\t\tqueue_delayed_work(floppy_wq, &fd_timer, expires - jiffies);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void setup_DMA(void)\n{\n\tunsigned long f;\n\n\tif (raw_cmd->length == 0) {\n\t\tprint_hex_dump(KERN_INFO, \"zero dma transfer size: \",\n\t\t\t       DUMP_PREFIX_NONE, 16, 1,\n\t\t\t       raw_cmd->fullcmd, raw_cmd->cmd_count, false);\n\t\tcont->done(0);\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn;\n\t}\n\tif (((unsigned long)raw_cmd->kernel_data) % 512) {\n\t\tpr_info(\"non aligned address: %p\\n\", raw_cmd->kernel_data);\n\t\tcont->done(0);\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn;\n\t}\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n#ifdef fd_dma_setup\n\tif (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length,\n\t\t\t (raw_cmd->flags & FD_RAW_READ) ?\n\t\t\t DMA_MODE_READ : DMA_MODE_WRITE,\n\t\t\t fdc_state[current_fdc].address) < 0) {\n\t\trelease_dma_lock(f);\n\t\tcont->done(0);\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn;\n\t}\n\trelease_dma_lock(f);\n#else\n\tfd_clear_dma_ff();\n\tfd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);\n\tfd_set_dma_mode((raw_cmd->flags & FD_RAW_READ) ?\n\t\t\tDMA_MODE_READ : DMA_MODE_WRITE);\n\tfd_set_dma_addr(raw_cmd->kernel_data);\n\tfd_set_dma_count(raw_cmd->length);\n\tvirtual_dma_port = fdc_state[current_fdc].address;\n\tfd_enable_dma();\n\trelease_dma_lock(f);\n#endif\n}\n\nstatic void show_floppy(int fdc);\n\n/* waits until the fdc becomes ready */\nstatic int wait_til_ready(int fdc)\n{\n\tint status;\n\tint counter;\n\n\tif (fdc_state[fdc].reset)\n\t\treturn -1;\n\tfor (counter = 0; counter < 10000; counter++) {\n\t\tstatus = fdc_inb(fdc, FD_STATUS);\n\t\tif (status & STATUS_READY)\n\t\t\treturn status;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"Getstatus times out (%x) on fdc %d\\n\", status, fdc);\n\t\tshow_floppy(fdc);\n\t}\n\tfdc_state[fdc].reset = 1;\n\treturn -1;\n}\n\n/* sends a command byte to the fdc */\nstatic int output_byte(int fdc, char byte)\n{\n\tint status = wait_til_ready(fdc);\n\n\tif (status < 0)\n\t\treturn -1;\n\n\tif (is_ready_state(status)) {\n\t\tfdc_outb(byte, fdc, FD_DATA);\n\t\toutput_log[output_log_pos].data = byte;\n\t\toutput_log[output_log_pos].status = status;\n\t\toutput_log[output_log_pos].jiffies = jiffies;\n\t\toutput_log_pos = (output_log_pos + 1) % OLOGSIZE;\n\t\treturn 0;\n\t}\n\tfdc_state[fdc].reset = 1;\n\tif (initialized) {\n\t\tDPRINT(\"Unable to send byte %x to FDC. Fdc=%x Status=%x\\n\",\n\t\t       byte, fdc, status);\n\t\tshow_floppy(fdc);\n\t}\n\treturn -1;\n}\n\n/* gets the response from the fdc */\nstatic int result(int fdc)\n{\n\tint i;\n\tint status = 0;\n\n\tfor (i = 0; i < FD_RAW_REPLY_SIZE; i++) {\n\t\tstatus = wait_til_ready(fdc);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;\n\t\tif ((status & ~STATUS_BUSY) == STATUS_READY) {\n\t\t\tresultjiffies = jiffies;\n\t\t\tresultsize = i;\n\t\t\treturn i;\n\t\t}\n\t\tif (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))\n\t\t\treply_buffer[i] = fdc_inb(fdc, FD_DATA);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"get result error. Fdc=%d Last status=%x Read bytes=%d\\n\",\n\t\t       fdc, status, i);\n\t\tshow_floppy(fdc);\n\t}\n\tfdc_state[fdc].reset = 1;\n\treturn -1;\n}\n\n#define MORE_OUTPUT -2\n/* does the fdc need more output? */\nstatic int need_more_output(int fdc)\n{\n\tint status = wait_til_ready(fdc);\n\n\tif (status < 0)\n\t\treturn -1;\n\n\tif (is_ready_state(status))\n\t\treturn MORE_OUTPUT;\n\n\treturn result(fdc);\n}\n\n/* Set perpendicular mode as required, based on data rate, if supported.\n * 82077 Now tested. 1Mbps data rate only possible with 82077-1.\n */\nstatic void perpendicular_mode(int fdc)\n{\n\tunsigned char perp_mode;\n\n\tif (raw_cmd->rate & 0x40) {\n\t\tswitch (raw_cmd->rate & 3) {\n\t\tcase 0:\n\t\t\tperp_mode = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tperp_mode = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINT(\"Invalid data rate for perpendicular mode!\\n\");\n\t\t\tcont->done(0);\n\t\t\tfdc_state[fdc].reset = 1;\n\t\t\t\t\t/*\n\t\t\t\t\t * convenient way to return to\n\t\t\t\t\t * redo without too much hassle\n\t\t\t\t\t * (deep stack et al.)\n\t\t\t\t\t */\n\t\t\treturn;\n\t\t}\n\t} else\n\t\tperp_mode = 0;\n\n\tif (fdc_state[fdc].perp_mode == perp_mode)\n\t\treturn;\n\tif (fdc_state[fdc].version >= FDC_82077_ORIG) {\n\t\toutput_byte(fdc, FD_PERPENDICULAR);\n\t\toutput_byte(fdc, perp_mode);\n\t\tfdc_state[fdc].perp_mode = perp_mode;\n\t} else if (perp_mode) {\n\t\tDPRINT(\"perpendicular mode not supported by this FDC.\\n\");\n\t}\n}\t\t\t\t/* perpendicular_mode */\n\nstatic int fifo_depth = 0xa;\nstatic int no_fifo;\n\nstatic int fdc_configure(int fdc)\n{\n\t/* Turn on FIFO */\n\toutput_byte(fdc, FD_CONFIGURE);\n\tif (need_more_output(fdc) != MORE_OUTPUT)\n\t\treturn 0;\n\toutput_byte(fdc, 0);\n\toutput_byte(fdc, 0x10 | (no_fifo & 0x20) | (fifo_depth & 0xf));\n\toutput_byte(fdc, 0);    /* pre-compensation from track 0 upwards */\n\treturn 1;\n}\n\n#define NOMINAL_DTR 500\n\n/* Issue a \"SPECIFY\" command to set the step rate time, head unload time,\n * head load time, and DMA disable flag to values needed by floppy.\n *\n * The value \"dtr\" is the data transfer rate in Kbps.  It is needed\n * to account for the data rate-based scaling done by the 82072 and 82077\n * FDC types.  This parameter is ignored for other types of FDCs (i.e.\n * 8272a).\n *\n * Note that changing the data transfer rate has a (probably deleterious)\n * effect on the parameters subject to scaling for 82072/82077 FDCs, so\n * fdc_specify is called again after each data transfer rate\n * change.\n *\n * srt: 1000 to 16000 in microseconds\n * hut: 16 to 240 milliseconds\n * hlt: 2 to 254 milliseconds\n *\n * These values are rounded up to the next highest available delay time.\n */\nstatic void fdc_specify(int fdc, int drive)\n{\n\tunsigned char spec1;\n\tunsigned char spec2;\n\tunsigned long srt;\n\tunsigned long hlt;\n\tunsigned long hut;\n\tunsigned long dtr = NOMINAL_DTR;\n\tunsigned long scale_dtr = NOMINAL_DTR;\n\tint hlt_max_code = 0x7f;\n\tint hut_max_code = 0xf;\n\n\tif (fdc_state[fdc].need_configure &&\n\t    fdc_state[fdc].version >= FDC_82072A) {\n\t\tfdc_configure(fdc);\n\t\tfdc_state[fdc].need_configure = 0;\n\t}\n\n\tswitch (raw_cmd->rate & 0x03) {\n\tcase 3:\n\t\tdtr = 1000;\n\t\tbreak;\n\tcase 1:\n\t\tdtr = 300;\n\t\tif (fdc_state[fdc].version >= FDC_82078) {\n\t\t\t/* chose the default rate table, not the one\n\t\t\t * where 1 = 2 Mbps */\n\t\t\toutput_byte(fdc, FD_DRIVESPEC);\n\t\t\tif (need_more_output(fdc) == MORE_OUTPUT) {\n\t\t\t\toutput_byte(fdc, UNIT(drive));\n\t\t\t\toutput_byte(fdc, 0xc0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tdtr = 250;\n\t\tbreak;\n\t}\n\n\tif (fdc_state[fdc].version >= FDC_82072) {\n\t\tscale_dtr = dtr;\n\t\thlt_max_code = 0x00;\t/* 0==256msec*dtr0/dtr (not linear!) */\n\t\thut_max_code = 0x0;\t/* 0==256msec*dtr0/dtr (not linear!) */\n\t}\n\n\t/* Convert step rate from microseconds to milliseconds and 4 bits */\n\tsrt = 16 - DIV_ROUND_UP(drive_params[drive].srt * scale_dtr / 1000,\n\t\t\t\tNOMINAL_DTR);\n\tif (slow_floppy)\n\t\tsrt = srt / 4;\n\n\tSUPBOUND(srt, 0xf);\n\tINFBOUND(srt, 0);\n\n\thlt = DIV_ROUND_UP(drive_params[drive].hlt * scale_dtr / 2,\n\t\t\t   NOMINAL_DTR);\n\tif (hlt < 0x01)\n\t\thlt = 0x01;\n\telse if (hlt > 0x7f)\n\t\thlt = hlt_max_code;\n\n\thut = DIV_ROUND_UP(drive_params[drive].hut * scale_dtr / 16,\n\t\t\t   NOMINAL_DTR);\n\tif (hut < 0x1)\n\t\thut = 0x1;\n\telse if (hut > 0xf)\n\t\thut = hut_max_code;\n\n\tspec1 = (srt << 4) | hut;\n\tspec2 = (hlt << 1) | (use_virtual_dma & 1);\n\n\t/* If these parameters did not change, just return with success */\n\tif (fdc_state[fdc].spec1 != spec1 ||\n\t    fdc_state[fdc].spec2 != spec2) {\n\t\t/* Go ahead and set spec1 and spec2 */\n\t\toutput_byte(fdc, FD_SPECIFY);\n\t\toutput_byte(fdc, fdc_state[fdc].spec1 = spec1);\n\t\toutput_byte(fdc, fdc_state[fdc].spec2 = spec2);\n\t}\n}\t\t\t\t/* fdc_specify */\n\n/* Set the FDC's data transfer rate on behalf of the specified drive.\n * NOTE: with 82072/82077 FDCs, changing the data rate requires a reissue\n * of the specify command (i.e. using the fdc_specify function).\n */\nstatic int fdc_dtr(void)\n{\n\t/* If data rate not already set to desired value, set it. */\n\tif ((raw_cmd->rate & 3) == fdc_state[current_fdc].dtr)\n\t\treturn 0;\n\n\t/* Set dtr */\n\tfdc_outb(raw_cmd->rate & 3, current_fdc, FD_DCR);\n\n\t/* TODO: some FDC/drive combinations (C&T 82C711 with TEAC 1.2MB)\n\t * need a stabilization period of several milliseconds to be\n\t * enforced after data rate changes before R/W operations.\n\t * Pause 5 msec to avoid trouble. (Needs to be 2 jiffies)\n\t */\n\tfdc_state[current_fdc].dtr = raw_cmd->rate & 3;\n\treturn fd_wait_for_completion(jiffies + 2UL * HZ / 100, floppy_ready);\n}\t\t\t\t/* fdc_dtr */\n\nstatic void tell_sector(void)\n{\n\tpr_cont(\": track %d, head %d, sector %d, size %d\",\n\t\treply_buffer[R_TRACK], reply_buffer[R_HEAD],\n\t\treply_buffer[R_SECTOR],\n\t\treply_buffer[R_SIZECODE]);\n}\t\t\t\t/* tell_sector */\n\nstatic void print_errors(void)\n{\n\tDPRINT(\"\");\n\tif (reply_buffer[ST0] & ST0_ECE) {\n\t\tpr_cont(\"Recalibrate failed!\");\n\t} else if (reply_buffer[ST2] & ST2_CRC) {\n\t\tpr_cont(\"data CRC error\");\n\t\ttell_sector();\n\t} else if (reply_buffer[ST1] & ST1_CRC) {\n\t\tpr_cont(\"CRC error\");\n\t\ttell_sector();\n\t} else if ((reply_buffer[ST1] & (ST1_MAM | ST1_ND)) ||\n\t\t   (reply_buffer[ST2] & ST2_MAM)) {\n\t\tif (!probing) {\n\t\t\tpr_cont(\"sector not found\");\n\t\t\ttell_sector();\n\t\t} else\n\t\t\tpr_cont(\"probe failed...\");\n\t} else if (reply_buffer[ST2] & ST2_WC) {\t/* seek error */\n\t\tpr_cont(\"wrong cylinder\");\n\t} else if (reply_buffer[ST2] & ST2_BC) {\t/* cylinder marked as bad */\n\t\tpr_cont(\"bad cylinder\");\n\t} else {\n\t\tpr_cont(\"unknown error. ST[0..2] are: 0x%x 0x%x 0x%x\",\n\t\t\treply_buffer[ST0], reply_buffer[ST1],\n\t\t\treply_buffer[ST2]);\n\t\ttell_sector();\n\t}\n\tpr_cont(\"\\n\");\n}\n\n/*\n * OK, this error interpreting routine is called after a\n * DMA read/write has succeeded\n * or failed, so we check the results, and copy any buffers.\n * hhb: Added better error reporting.\n * ak: Made this into a separate routine.\n */\nstatic int interpret_errors(void)\n{\n\tchar bad;\n\n\tif (inr != 7) {\n\t\tDPRINT(\"-- FDC reply error\\n\");\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn 1;\n\t}\n\n\t/* check IC to find cause of interrupt */\n\tswitch (reply_buffer[ST0] & ST0_INTR) {\n\tcase 0x40:\t\t/* error occurred during command execution */\n\t\tif (reply_buffer[ST1] & ST1_EOC)\n\t\t\treturn 0;\t/* occurs with pseudo-DMA */\n\t\tbad = 1;\n\t\tif (reply_buffer[ST1] & ST1_WP) {\n\t\t\tDPRINT(\"Drive is write protected\\n\");\n\t\t\tclear_bit(FD_DISK_WRITABLE_BIT,\n\t\t\t\t  &drive_state[current_drive].flags);\n\t\t\tcont->done(0);\n\t\t\tbad = 2;\n\t\t} else if (reply_buffer[ST1] & ST1_ND) {\n\t\t\tset_bit(FD_NEED_TWADDLE_BIT,\n\t\t\t\t&drive_state[current_drive].flags);\n\t\t} else if (reply_buffer[ST1] & ST1_OR) {\n\t\t\tif (drive_params[current_drive].flags & FTD_MSG)\n\t\t\t\tDPRINT(\"Over/Underrun - retrying\\n\");\n\t\t\tbad = 0;\n\t\t} else if (*errors >= drive_params[current_drive].max_errors.reporting) {\n\t\t\tprint_errors();\n\t\t}\n\t\tif (reply_buffer[ST2] & ST2_WC || reply_buffer[ST2] & ST2_BC)\n\t\t\t/* wrong cylinder => recal */\n\t\t\tdrive_state[current_drive].track = NEED_2_RECAL;\n\t\treturn bad;\n\tcase 0x80:\t\t/* invalid command given */\n\t\tDPRINT(\"Invalid FDC command given!\\n\");\n\t\tcont->done(0);\n\t\treturn 2;\n\tcase 0xc0:\n\t\tDPRINT(\"Abnormal termination caused by polling\\n\");\n\t\tcont->error();\n\t\treturn 2;\n\tdefault:\t\t/* (0) Normal command termination */\n\t\treturn 0;\n\t}\n}\n\n/*\n * This routine is called when everything should be correctly set up\n * for the transfer (i.e. floppy motor is on, the correct floppy is\n * selected, and the head is sitting on the right track).\n */\nstatic void setup_rw_floppy(void)\n{\n\tint i;\n\tint r;\n\tint flags;\n\tunsigned long ready_date;\n\tvoid (*function)(void);\n\n\tflags = raw_cmd->flags;\n\tif (flags & (FD_RAW_READ | FD_RAW_WRITE))\n\t\tflags |= FD_RAW_INTR;\n\n\tif ((flags & FD_RAW_SPIN) && !(flags & FD_RAW_NO_MOTOR)) {\n\t\tready_date = drive_state[current_drive].spinup_date + drive_params[current_drive].spinup;\n\t\t/* If spinup will take a long time, rerun scandrives\n\t\t * again just before spinup completion. Beware that\n\t\t * after scandrives, we must again wait for selection.\n\t\t */\n\t\tif (time_after(ready_date, jiffies + drive_params[current_drive].select_delay)) {\n\t\t\tready_date -= drive_params[current_drive].select_delay;\n\t\t\tfunction = floppy_start;\n\t\t} else\n\t\t\tfunction = setup_rw_floppy;\n\n\t\t/* wait until the floppy is spinning fast enough */\n\t\tif (fd_wait_for_completion(ready_date, function))\n\t\t\treturn;\n\t}\n\tif ((flags & FD_RAW_READ) || (flags & FD_RAW_WRITE))\n\t\tsetup_DMA();\n\n\tif (flags & FD_RAW_INTR)\n\t\tdo_floppy = main_command_interrupt;\n\n\tr = 0;\n\tfor (i = 0; i < raw_cmd->cmd_count; i++)\n\t\tr |= output_byte(current_fdc, raw_cmd->fullcmd[i]);\n\n\tdebugt(__func__, \"rw_command\");\n\n\tif (r) {\n\t\tcont->error();\n\t\treset_fdc();\n\t\treturn;\n\t}\n\n\tif (!(flags & FD_RAW_INTR)) {\n\t\tinr = result(current_fdc);\n\t\tcont->interrupt();\n\t} else if (flags & FD_RAW_NEED_DISK)\n\t\tfd_watchdog();\n}\n\nstatic int blind_seek;\n\n/*\n * This is the routine called after every seek (or recalibrate) interrupt\n * from the floppy controller.\n */\nstatic void seek_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tif (inr != 2 || (reply_buffer[ST0] & 0xF8) != 0x20) {\n\t\tDPRINT(\"seek failed\\n\");\n\t\tdrive_state[current_drive].track = NEED_2_RECAL;\n\t\tcont->error();\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (drive_state[current_drive].track >= 0 &&\n\t    drive_state[current_drive].track != reply_buffer[ST1] &&\n\t    !blind_seek) {\n\t\tdebug_dcl(drive_params[current_drive].flags,\n\t\t\t  \"clearing NEWCHANGE flag because of effective seek\\n\");\n\t\tdebug_dcl(drive_params[current_drive].flags, \"jiffies=%lu\\n\",\n\t\t\t  jiffies);\n\t\tclear_bit(FD_DISK_NEWCHANGE_BIT,\n\t\t\t  &drive_state[current_drive].flags);\n\t\t\t\t\t/* effective seek */\n\t\tdrive_state[current_drive].select_date = jiffies;\n\t}\n\tdrive_state[current_drive].track = reply_buffer[ST1];\n\tfloppy_ready();\n}\n\nstatic void check_wp(int fdc, int drive)\n{\n\tif (test_bit(FD_VERIFY_BIT, &drive_state[drive].flags)) {\n\t\t\t\t\t/* check write protection */\n\t\toutput_byte(fdc, FD_GETSTATUS);\n\t\toutput_byte(fdc, UNIT(drive));\n\t\tif (result(fdc) != 1) {\n\t\t\tfdc_state[fdc].reset = 1;\n\t\t\treturn;\n\t\t}\n\t\tclear_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tclear_bit(FD_NEED_TWADDLE_BIT,\n\t\t\t  &drive_state[drive].flags);\n\t\tdebug_dcl(drive_params[drive].flags,\n\t\t\t  \"checking whether disk is write protected\\n\");\n\t\tdebug_dcl(drive_params[drive].flags, \"wp=%x\\n\",\n\t\t\t  reply_buffer[ST3] & 0x40);\n\t\tif (!(reply_buffer[ST3] & 0x40))\n\t\t\tset_bit(FD_DISK_WRITABLE_BIT,\n\t\t\t\t&drive_state[drive].flags);\n\t\telse\n\t\t\tclear_bit(FD_DISK_WRITABLE_BIT,\n\t\t\t\t  &drive_state[drive].flags);\n\t}\n}\n\nstatic void seek_floppy(void)\n{\n\tint track;\n\n\tblind_seek = 0;\n\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from %s\\n\", __func__);\n\n\tif (!test_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags) &&\n\t    disk_change(current_drive) && (raw_cmd->flags & FD_RAW_NEED_DISK)) {\n\t\t/* the media changed flag should be cleared after the seek.\n\t\t * If it isn't, this means that there is really no disk in\n\t\t * the drive.\n\t\t */\n\t\tset_bit(FD_DISK_CHANGED_BIT,\n\t\t\t&drive_state[current_drive].flags);\n\t\tcont->done(0);\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (drive_state[current_drive].track <= NEED_1_RECAL) {\n\t\trecalibrate_floppy();\n\t\treturn;\n\t} else if (test_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags) &&\n\t\t   (raw_cmd->flags & FD_RAW_NEED_DISK) &&\n\t\t   (drive_state[current_drive].track <= NO_TRACK || drive_state[current_drive].track == raw_cmd->track)) {\n\t\t/* we seek to clear the media-changed condition. Does anybody\n\t\t * know a more elegant way, which works on all drives? */\n\t\tif (raw_cmd->track)\n\t\t\ttrack = raw_cmd->track - 1;\n\t\telse {\n\t\t\tif (drive_params[current_drive].flags & FD_SILENT_DCL_CLEAR) {\n\t\t\t\tset_dor(current_fdc, ~(0x10 << UNIT(current_drive)), 0);\n\t\t\t\tblind_seek = 1;\n\t\t\t\traw_cmd->flags |= FD_RAW_NEED_SEEK;\n\t\t\t}\n\t\t\ttrack = 1;\n\t\t}\n\t} else {\n\t\tcheck_wp(current_fdc, current_drive);\n\t\tif (raw_cmd->track != drive_state[current_drive].track &&\n\t\t    (raw_cmd->flags & FD_RAW_NEED_SEEK))\n\t\t\ttrack = raw_cmd->track;\n\t\telse {\n\t\t\tsetup_rw_floppy();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdo_floppy = seek_interrupt;\n\toutput_byte(current_fdc, FD_SEEK);\n\toutput_byte(current_fdc, UNIT(current_drive));\n\tif (output_byte(current_fdc, track) < 0) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tdebugt(__func__, \"\");\n}\n\nstatic void recal_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tif (inr != 2)\n\t\tfdc_state[current_fdc].reset = 1;\n\telse if (reply_buffer[ST0] & ST0_ECE) {\n\t\tswitch (drive_state[current_drive].track) {\n\t\tcase NEED_1_RECAL:\n\t\t\tdebugt(__func__, \"need 1 recal\");\n\t\t\t/* after a second recalibrate, we still haven't\n\t\t\t * reached track 0. Probably no drive. Raise an\n\t\t\t * error, as failing immediately might upset\n\t\t\t * computers possessed by the Devil :-) */\n\t\t\tcont->error();\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\tcase NEED_2_RECAL:\n\t\t\tdebugt(__func__, \"need 2 recal\");\n\t\t\t/* If we already did a recalibrate,\n\t\t\t * and we are not at track 0, this\n\t\t\t * means we have moved. (The only way\n\t\t\t * not to move at recalibration is to\n\t\t\t * be already at track 0.) Clear the\n\t\t\t * new change flag */\n\t\t\tdebug_dcl(drive_params[current_drive].flags,\n\t\t\t\t  \"clearing NEWCHANGE flag because of second recalibrate\\n\");\n\n\t\t\tclear_bit(FD_DISK_NEWCHANGE_BIT,\n\t\t\t\t  &drive_state[current_drive].flags);\n\t\t\tdrive_state[current_drive].select_date = jiffies;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tdebugt(__func__, \"default\");\n\t\t\t/* Recalibrate moves the head by at\n\t\t\t * most 80 steps. If after one\n\t\t\t * recalibrate we don't have reached\n\t\t\t * track 0, this might mean that we\n\t\t\t * started beyond track 80.  Try\n\t\t\t * again.  */\n\t\t\tdrive_state[current_drive].track = NEED_1_RECAL;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tdrive_state[current_drive].track = reply_buffer[ST1];\n\tfloppy_ready();\n}\n\nstatic void print_result(char *message, int inr)\n{\n\tint i;\n\n\tDPRINT(\"%s \", message);\n\tif (inr >= 0)\n\t\tfor (i = 0; i < inr; i++)\n\t\t\tpr_cont(\"repl[%d]=%x \", i, reply_buffer[i]);\n\tpr_cont(\"\\n\");\n}\n\n/* interrupt handler. Note that this can be called externally on the Sparc */\nirqreturn_t floppy_interrupt(int irq, void *dev_id)\n{\n\tint do_print;\n\tunsigned long f;\n\tvoid (*handler)(void) = do_floppy;\n\n\tlasthandler = handler;\n\tinterruptjiffies = jiffies;\n\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(f);\n\n\tdo_floppy = NULL;\n\tif (current_fdc >= N_FDC || fdc_state[current_fdc].address == -1) {\n\t\t/* we don't even know which FDC is the culprit */\n\t\tpr_info(\"DOR0=%x\\n\", fdc_state[0].dor);\n\t\tpr_info(\"floppy interrupt on bizarre fdc %d\\n\", current_fdc);\n\t\tpr_info(\"handler=%ps\\n\", handler);\n\t\tis_alive(__func__, \"bizarre fdc\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tfdc_state[current_fdc].reset = 0;\n\t/* We have to clear the reset flag here, because apparently on boxes\n\t * with level triggered interrupts (PS/2, Sparc, ...), it is needed to\n\t * emit SENSEI's to clear the interrupt line. And fdc_state[fdc].reset\n\t * blocks the emission of the SENSEI's.\n\t * It is OK to emit floppy commands because we are in an interrupt\n\t * handler here, and thus we have to fear no interference of other\n\t * activity.\n\t */\n\n\tdo_print = !handler && print_unex && initialized;\n\n\tinr = result(current_fdc);\n\tif (do_print)\n\t\tprint_result(\"unexpected interrupt\", inr);\n\tif (inr == 0) {\n\t\tint max_sensei = 4;\n\t\tdo {\n\t\t\toutput_byte(current_fdc, FD_SENSEI);\n\t\t\tinr = result(current_fdc);\n\t\t\tif (do_print)\n\t\t\t\tprint_result(\"sensei\", inr);\n\t\t\tmax_sensei--;\n\t\t} while ((reply_buffer[ST0] & 0x83) != UNIT(current_drive) &&\n\t\t\t inr == 2 && max_sensei);\n\t}\n\tif (!handler) {\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn IRQ_NONE;\n\t}\n\tschedule_bh(handler);\n\tis_alive(__func__, \"normal interrupt end\");\n\n\t/* FIXME! Was it really for us? */\n\treturn IRQ_HANDLED;\n}\n\nstatic void recalibrate_floppy(void)\n{\n\tdebugt(__func__, \"\");\n\tdo_floppy = recal_interrupt;\n\toutput_byte(current_fdc, FD_RECALIBRATE);\n\tif (output_byte(current_fdc, UNIT(current_drive)) < 0)\n\t\treset_fdc();\n}\n\n/*\n * Must do 4 FD_SENSEIs after reset because of ``drive polling''.\n */\nstatic void reset_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tresult(current_fdc);\t\t/* get the status ready for set_fdc */\n\tif (fdc_state[current_fdc].reset) {\n\t\tpr_info(\"reset set in interrupt, calling %ps\\n\", cont->error);\n\t\tcont->error();\t/* a reset just after a reset. BAD! */\n\t}\n\tcont->redo();\n}\n\n/*\n * reset is done by pulling bit 2 of DOR low for a while (old FDCs),\n * or by setting the self clearing bit 7 of STATUS (newer FDCs).\n * This WILL trigger an interrupt, causing the handlers in the current\n * cont's ->redo() to be called via reset_interrupt().\n */\nstatic void reset_fdc(void)\n{\n\tunsigned long flags;\n\n\tdo_floppy = reset_interrupt;\n\tfdc_state[current_fdc].reset = 0;\n\treset_fdc_info(current_fdc, 0);\n\n\t/* Pseudo-DMA may intercept 'reset finished' interrupt.  */\n\t/* Irrelevant for systems with true DMA (i386).          */\n\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\n\tif (fdc_state[current_fdc].version >= FDC_82072A)\n\t\tfdc_outb(0x80 | (fdc_state[current_fdc].dtr & 3),\n\t\t\t current_fdc, FD_STATUS);\n\telse {\n\t\tfdc_outb(fdc_state[current_fdc].dor & ~0x04, current_fdc, FD_DOR);\n\t\tudelay(FD_RESET_DELAY);\n\t\tfdc_outb(fdc_state[current_fdc].dor, current_fdc, FD_DOR);\n\t}\n}\n\nstatic void show_floppy(int fdc)\n{\n\tint i;\n\n\tpr_info(\"\\n\");\n\tpr_info(\"floppy driver state\\n\");\n\tpr_info(\"-------------------\\n\");\n\tpr_info(\"now=%lu last interrupt=%lu diff=%lu last called handler=%ps\\n\",\n\t\tjiffies, interruptjiffies, jiffies - interruptjiffies,\n\t\tlasthandler);\n\n\tpr_info(\"timeout_message=%s\\n\", timeout_message);\n\tpr_info(\"last output bytes:\\n\");\n\tfor (i = 0; i < OLOGSIZE; i++)\n\t\tpr_info(\"%2x %2x %lu\\n\",\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].data,\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].status,\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].jiffies);\n\tpr_info(\"last result at %lu\\n\", resultjiffies);\n\tpr_info(\"last redo_fd_request at %lu\\n\", lastredo);\n\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_NONE, 16, 1,\n\t\t       reply_buffer, resultsize, true);\n\n\tpr_info(\"status=%x\\n\", fdc_inb(fdc, FD_STATUS));\n\tpr_info(\"fdc_busy=%lu\\n\", fdc_busy);\n\tif (do_floppy)\n\t\tpr_info(\"do_floppy=%ps\\n\", do_floppy);\n\tif (work_pending(&floppy_work))\n\t\tpr_info(\"floppy_work.func=%ps\\n\", floppy_work.func);\n\tif (delayed_work_pending(&fd_timer))\n\t\tpr_info(\"delayed work.function=%p expires=%ld\\n\",\n\t\t       fd_timer.work.func,\n\t\t       fd_timer.timer.expires - jiffies);\n\tif (delayed_work_pending(&fd_timeout))\n\t\tpr_info(\"timer_function=%p expires=%ld\\n\",\n\t\t       fd_timeout.work.func,\n\t\t       fd_timeout.timer.expires - jiffies);\n\n\tpr_info(\"cont=%p\\n\", cont);\n\tpr_info(\"current_req=%p\\n\", current_req);\n\tpr_info(\"command_status=%d\\n\", command_status);\n\tpr_info(\"\\n\");\n}\n\nstatic void floppy_shutdown(struct work_struct *arg)\n{\n\tunsigned long flags;\n\n\tif (initialized)\n\t\tshow_floppy(current_fdc);\n\tcancel_activity();\n\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\n\t/* avoid dma going to a random drive after shutdown */\n\n\tif (initialized)\n\t\tDPRINT(\"floppy timeout called\\n\");\n\tfdc_state[current_fdc].reset = 1;\n\tif (cont) {\n\t\tcont->done(0);\n\t\tcont->redo();\t/* this will recall reset when needed */\n\t} else {\n\t\tpr_info(\"no cont in shutdown!\\n\");\n\t\tprocess_fd_request();\n\t}\n\tis_alive(__func__, \"\");\n}\n\n/* start motor, check media-changed condition and write protection */\nstatic int start_motor(void (*function)(void))\n{\n\tint mask;\n\tint data;\n\n\tmask = 0xfc;\n\tdata = UNIT(current_drive);\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR)) {\n\t\tif (!(fdc_state[current_fdc].dor & (0x10 << UNIT(current_drive)))) {\n\t\t\tset_debugt();\n\t\t\t/* no read since this drive is running */\n\t\t\tdrive_state[current_drive].first_read_date = 0;\n\t\t\t/* note motor start time if motor is not yet running */\n\t\t\tdrive_state[current_drive].spinup_date = jiffies;\n\t\t\tdata |= (0x10 << UNIT(current_drive));\n\t\t}\n\t} else if (fdc_state[current_fdc].dor & (0x10 << UNIT(current_drive)))\n\t\tmask &= ~(0x10 << UNIT(current_drive));\n\n\t/* starts motor and selects floppy */\n\tdel_timer(motor_off_timer + current_drive);\n\tset_dor(current_fdc, mask, data);\n\n\t/* wait_for_completion also schedules reset if needed. */\n\treturn fd_wait_for_completion(drive_state[current_drive].select_date + drive_params[current_drive].select_delay,\n\t\t\t\t      function);\n}\n\nstatic void floppy_ready(void)\n{\n\tif (fdc_state[current_fdc].reset) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tif (start_motor(floppy_ready))\n\t\treturn;\n\tif (fdc_dtr())\n\t\treturn;\n\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from floppy_ready\\n\");\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR) &&\n\t    disk_change(current_drive) && !drive_params[current_drive].select_delay)\n\t\ttwaddle(current_fdc, current_drive);\t/* this clears the dcl on certain\n\t\t\t\t * drive/controller combinations */\n\n#ifdef fd_chose_dma_mode\n\tif ((raw_cmd->flags & FD_RAW_READ) || (raw_cmd->flags & FD_RAW_WRITE)) {\n\t\tunsigned long flags = claim_dma_lock();\n\t\tfd_chose_dma_mode(raw_cmd->kernel_data, raw_cmd->length);\n\t\trelease_dma_lock(flags);\n\t}\n#endif\n\n\tif (raw_cmd->flags & (FD_RAW_NEED_SEEK | FD_RAW_NEED_DISK)) {\n\t\tperpendicular_mode(current_fdc);\n\t\tfdc_specify(current_fdc, current_drive); /* must be done here because of hut, hlt ... */\n\t\tseek_floppy();\n\t} else {\n\t\tif ((raw_cmd->flags & FD_RAW_READ) ||\n\t\t    (raw_cmd->flags & FD_RAW_WRITE))\n\t\t\tfdc_specify(current_fdc, current_drive);\n\t\tsetup_rw_floppy();\n\t}\n}\n\nstatic void floppy_start(void)\n{\n\treschedule_timeout(current_drive, \"floppy start\");\n\n\tscandrives();\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"setting NEWCHANGE in floppy_start\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags);\n\tfloppy_ready();\n}\n\n/*\n * ========================================================================\n * here ends the bottom half. Exported routines are:\n * floppy_start, floppy_off, floppy_ready, lock_fdc, unlock_fdc, set_fdc,\n * start_motor, reset_fdc, reset_fdc_info, interpret_errors.\n * Initialization also uses output_byte, result, set_dor, floppy_interrupt\n * and set_dor.\n * ========================================================================\n */\n/*\n * General purpose continuations.\n * ==============================\n */\n\nstatic void do_wakeup(void)\n{\n\treschedule_timeout(MAXTIMEOUT, \"do wakeup\");\n\tcont = NULL;\n\tcommand_status += 2;\n\twake_up(&command_done);\n}\n\nstatic const struct cont_t wakeup_cont = {\n\t.interrupt\t= empty,\n\t.redo\t\t= do_wakeup,\n\t.error\t\t= empty,\n\t.done\t\t= (done_f)empty\n};\n\nstatic const struct cont_t intr_cont = {\n\t.interrupt\t= empty,\n\t.redo\t\t= process_fd_request,\n\t.error\t\t= empty,\n\t.done\t\t= (done_f)empty\n};\n\n/* schedules handler, waiting for completion. May be interrupted, will then\n * return -EINTR, in which case the driver will automatically be unlocked.\n */\nstatic int wait_til_done(void (*handler)(void), bool interruptible)\n{\n\tint ret;\n\n\tschedule_bh(handler);\n\n\tif (interruptible)\n\t\twait_event_interruptible(command_done, command_status >= 2);\n\telse\n\t\twait_event(command_done, command_status >= 2);\n\n\tif (command_status < 2) {\n\t\tcancel_activity();\n\t\tcont = &intr_cont;\n\t\treset_fdc();\n\t\treturn -EINTR;\n\t}\n\n\tif (fdc_state[current_fdc].reset)\n\t\tcommand_status = FD_COMMAND_ERROR;\n\tif (command_status == FD_COMMAND_OKAY)\n\t\tret = 0;\n\telse\n\t\tret = -EIO;\n\tcommand_status = FD_COMMAND_NONE;\n\treturn ret;\n}\n\nstatic void generic_done(int result)\n{\n\tcommand_status = result;\n\tcont = &wakeup_cont;\n}\n\nstatic void generic_success(void)\n{\n\tcont->done(1);\n}\n\nstatic void generic_failure(void)\n{\n\tcont->done(0);\n}\n\nstatic void success_and_wakeup(void)\n{\n\tgeneric_success();\n\tcont->redo();\n}\n\n/*\n * formatting and rw support.\n * ==========================\n */\n\nstatic int next_valid_format(int drive)\n{\n\tint probed_format;\n\n\tprobed_format = drive_state[drive].probed_format;\n\twhile (1) {\n\t\tif (probed_format >= FD_AUTODETECT_SIZE ||\n\t\t    !drive_params[drive].autodetect[probed_format]) {\n\t\t\tdrive_state[drive].probed_format = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif (floppy_type[drive_params[drive].autodetect[probed_format]].sect) {\n\t\t\tdrive_state[drive].probed_format = probed_format;\n\t\t\treturn 0;\n\t\t}\n\t\tprobed_format++;\n\t}\n}\n\nstatic void bad_flp_intr(void)\n{\n\tint err_count;\n\n\tif (probing) {\n\t\tdrive_state[current_drive].probed_format++;\n\t\tif (!next_valid_format(current_drive))\n\t\t\treturn;\n\t}\n\terr_count = ++(*errors);\n\tINFBOUND(write_errors[current_drive].badness, err_count);\n\tif (err_count > drive_params[current_drive].max_errors.abort)\n\t\tcont->done(0);\n\tif (err_count > drive_params[current_drive].max_errors.reset)\n\t\tfdc_state[current_fdc].reset = 1;\n\telse if (err_count > drive_params[current_drive].max_errors.recal)\n\t\tdrive_state[current_drive].track = NEED_2_RECAL;\n}\n\nstatic void set_floppy(int drive)\n{\n\tint type = ITYPE(drive_state[drive].fd_device);\n\n\tif (type)\n\t\t_floppy = floppy_type + type;\n\telse\n\t\t_floppy = current_type[drive];\n}\n\n/*\n * formatting support.\n * ===================\n */\nstatic void format_interrupt(void)\n{\n\tswitch (interpret_errors()) {\n\tcase 1:\n\t\tcont->error();\n\t\tbreak;\n\tcase 2:\n\t\tbreak;\n\tcase 0:\n\t\tcont->done(1);\n\t}\n\tcont->redo();\n}\n\n#define FM_MODE(x, y) ((y) & ~(((x)->rate & 0x80) >> 1))\n#define CT(x) ((x) | 0xc0)\n\nstatic void setup_format_params(int track)\n{\n\tint n;\n\tint il;\n\tint count;\n\tint head_shift;\n\tint track_shift;\n\tstruct fparm {\n\t\tunsigned char track, head, sect, size;\n\t} *here = (struct fparm *)floppy_track_buffer;\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->track = track;\n\n\traw_cmd->flags = (FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN |\n\t\t\t  FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\traw_cmd->cmd_count = NR_F;\n\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_FORMAT);\n\traw_cmd->cmd[DR_SELECT] = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);\n\traw_cmd->cmd[F_SIZECODE] = FD_SIZECODE(_floppy);\n\traw_cmd->cmd[F_SECT_PER_TRACK] = _floppy->sect << 2 >> raw_cmd->cmd[F_SIZECODE];\n\traw_cmd->cmd[F_GAP] = _floppy->fmt_gap;\n\traw_cmd->cmd[F_FILL] = FD_FILL_BYTE;\n\n\traw_cmd->kernel_data = floppy_track_buffer;\n\traw_cmd->length = 4 * raw_cmd->cmd[F_SECT_PER_TRACK];\n\n\tif (!raw_cmd->cmd[F_SECT_PER_TRACK])\n\t\treturn;\n\n\t/* allow for about 30ms for data transport per track */\n\thead_shift = (raw_cmd->cmd[F_SECT_PER_TRACK] + 5) / 6;\n\n\t/* a ``cylinder'' is two tracks plus a little stepping time */\n\ttrack_shift = 2 * head_shift + 3;\n\n\t/* position of logical sector 1 on this track */\n\tn = (track_shift * format_req.track + head_shift * format_req.head)\n\t    % raw_cmd->cmd[F_SECT_PER_TRACK];\n\n\t/* determine interleave */\n\til = 1;\n\tif (_floppy->fmt_gap < 0x22)\n\t\til++;\n\n\t/* initialize field */\n\tfor (count = 0; count < raw_cmd->cmd[F_SECT_PER_TRACK]; ++count) {\n\t\there[count].track = format_req.track;\n\t\there[count].head = format_req.head;\n\t\there[count].sect = 0;\n\t\there[count].size = raw_cmd->cmd[F_SIZECODE];\n\t}\n\t/* place logical sectors */\n\tfor (count = 1; count <= raw_cmd->cmd[F_SECT_PER_TRACK]; ++count) {\n\t\there[n].sect = count;\n\t\tn = (n + il) % raw_cmd->cmd[F_SECT_PER_TRACK];\n\t\tif (here[n].sect) {\t/* sector busy, find next free sector */\n\t\t\t++n;\n\t\t\tif (n >= raw_cmd->cmd[F_SECT_PER_TRACK]) {\n\t\t\t\tn -= raw_cmd->cmd[F_SECT_PER_TRACK];\n\t\t\t\twhile (here[n].sect)\n\t\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t}\n\tif (_floppy->stretch & FD_SECTBASEMASK) {\n\t\tfor (count = 0; count < raw_cmd->cmd[F_SECT_PER_TRACK]; count++)\n\t\t\there[count].sect += FD_SECTBASE(_floppy) - 1;\n\t}\n}\n\nstatic void redo_format(void)\n{\n\tbuffer_track = -1;\n\tsetup_format_params(format_req.track << STRETCH(_floppy));\n\tfloppy_start();\n\tdebugt(__func__, \"queue format request\");\n}\n\nstatic const struct cont_t format_cont = {\n\t.interrupt\t= format_interrupt,\n\t.redo\t\t= redo_format,\n\t.error\t\t= bad_flp_intr,\n\t.done\t\t= generic_done\n};\n\nstatic int do_format(int drive, struct format_descr *tmp_format_req)\n{\n\tint ret;\n\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\n\tset_floppy(drive);\n\tif (!_floppy ||\n\t    _floppy->track > drive_params[current_drive].tracks ||\n\t    tmp_format_req->track >= _floppy->track ||\n\t    tmp_format_req->head >= _floppy->head ||\n\t    (_floppy->sect << 2) % (1 << FD_SIZECODE(_floppy)) ||\n\t    !_floppy->fmt_gap) {\n\t\tprocess_fd_request();\n\t\treturn -EINVAL;\n\t}\n\tformat_req = *tmp_format_req;\n\tformat_errors = 0;\n\tcont = &format_cont;\n\terrors = &format_errors;\n\tret = wait_til_done(redo_format, true);\n\tif (ret == -EINTR)\n\t\treturn -EINTR;\n\tprocess_fd_request();\n\treturn ret;\n}\n\n/*\n * Buffer read/write and support\n * =============================\n */\n\nstatic void floppy_end_request(struct request *req, blk_status_t error)\n{\n\tunsigned int nr_sectors = current_count_sectors;\n\tunsigned int drive = (unsigned long)req->q->disk->private_data;\n\n\t/* current_count_sectors can be zero if transfer failed */\n\tif (error)\n\t\tnr_sectors = blk_rq_cur_sectors(req);\n\tif (blk_update_request(req, error, nr_sectors << 9))\n\t\treturn;\n\t__blk_mq_end_request(req, error);\n\n\t/* We're done with the request */\n\tfloppy_off(drive);\n\tcurrent_req = NULL;\n}\n\n/* new request_done. Can handle physical sectors which are smaller than a\n * logical buffer */\nstatic void request_done(int uptodate)\n{\n\tstruct request *req = current_req;\n\tint block;\n\tchar msg[sizeof(\"request done \") + sizeof(int) * 3];\n\n\tprobing = 0;\n\tsnprintf(msg, sizeof(msg), \"request done %d\", uptodate);\n\treschedule_timeout(MAXTIMEOUT, msg);\n\n\tif (!req) {\n\t\tpr_info(\"floppy.c: no request in request_done\\n\");\n\t\treturn;\n\t}\n\n\tif (uptodate) {\n\t\t/* maintain values for invalidation on geometry\n\t\t * change */\n\t\tblock = current_count_sectors + blk_rq_pos(req);\n\t\tINFBOUND(drive_state[current_drive].maxblock, block);\n\t\tif (block > _floppy->sect)\n\t\t\tdrive_state[current_drive].maxtrack = 1;\n\n\t\tfloppy_end_request(req, 0);\n\t} else {\n\t\tif (rq_data_dir(req) == WRITE) {\n\t\t\t/* record write error information */\n\t\t\twrite_errors[current_drive].write_errors++;\n\t\t\tif (write_errors[current_drive].write_errors == 1) {\n\t\t\t\twrite_errors[current_drive].first_error_sector = blk_rq_pos(req);\n\t\t\t\twrite_errors[current_drive].first_error_generation = drive_state[current_drive].generation;\n\t\t\t}\n\t\t\twrite_errors[current_drive].last_error_sector = blk_rq_pos(req);\n\t\t\twrite_errors[current_drive].last_error_generation = drive_state[current_drive].generation;\n\t\t}\n\t\tfloppy_end_request(req, BLK_STS_IOERR);\n\t}\n}\n\n/* Interrupt handler evaluating the result of the r/w operation */\nstatic void rw_interrupt(void)\n{\n\tint eoc;\n\tint ssize;\n\tint heads;\n\tint nr_sectors;\n\n\tif (reply_buffer[R_HEAD] >= 2) {\n\t\t/* some Toshiba floppy controllers occasionnally seem to\n\t\t * return bogus interrupts after read/write operations, which\n\t\t * can be recognized by a bad head number (>= 2) */\n\t\treturn;\n\t}\n\n\tif (!drive_state[current_drive].first_read_date)\n\t\tdrive_state[current_drive].first_read_date = jiffies;\n\n\tssize = DIV_ROUND_UP(1 << raw_cmd->cmd[SIZECODE], 4);\n\n\tif (reply_buffer[ST1] & ST1_EOC)\n\t\teoc = 1;\n\telse\n\t\teoc = 0;\n\n\tif (raw_cmd->cmd[COMMAND] & 0x80)\n\t\theads = 2;\n\telse\n\t\theads = 1;\n\n\tnr_sectors = (((reply_buffer[R_TRACK] - raw_cmd->cmd[TRACK]) * heads +\n\t\t       reply_buffer[R_HEAD] - raw_cmd->cmd[HEAD]) * raw_cmd->cmd[SECT_PER_TRACK] +\n\t\t      reply_buffer[R_SECTOR] - raw_cmd->cmd[SECTOR] + eoc) << raw_cmd->cmd[SIZECODE] >> 2;\n\n\tif (nr_sectors / ssize >\n\t    DIV_ROUND_UP(in_sector_offset + current_count_sectors, ssize)) {\n\t\tDPRINT(\"long rw: %x instead of %lx\\n\",\n\t\t       nr_sectors, current_count_sectors);\n\t\tpr_info(\"rs=%d s=%d\\n\", reply_buffer[R_SECTOR],\n\t\t\traw_cmd->cmd[SECTOR]);\n\t\tpr_info(\"rh=%d h=%d\\n\", reply_buffer[R_HEAD],\n\t\t\traw_cmd->cmd[HEAD]);\n\t\tpr_info(\"rt=%d t=%d\\n\", reply_buffer[R_TRACK],\n\t\t\traw_cmd->cmd[TRACK]);\n\t\tpr_info(\"heads=%d eoc=%d\\n\", heads, eoc);\n\t\tpr_info(\"spt=%d st=%d ss=%d\\n\",\n\t\t\traw_cmd->cmd[SECT_PER_TRACK], fsector_t, ssize);\n\t\tpr_info(\"in_sector_offset=%d\\n\", in_sector_offset);\n\t}\n\n\tnr_sectors -= in_sector_offset;\n\tINFBOUND(nr_sectors, 0);\n\tSUPBOUND(current_count_sectors, nr_sectors);\n\n\tswitch (interpret_errors()) {\n\tcase 2:\n\t\tcont->redo();\n\t\treturn;\n\tcase 1:\n\t\tif (!current_count_sectors) {\n\t\t\tcont->error();\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tif (!current_count_sectors) {\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\t}\n\t\tcurrent_type[current_drive] = _floppy;\n\t\tfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\n\t\tbreak;\n\t}\n\n\tif (probing) {\n\t\tif (drive_params[current_drive].flags & FTD_MSG)\n\t\t\tDPRINT(\"Auto-detected floppy type %s in fd%d\\n\",\n\t\t\t       _floppy->name, current_drive);\n\t\tcurrent_type[current_drive] = _floppy;\n\t\tfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\n\t\tprobing = 0;\n\t}\n\n\tif (CT(raw_cmd->cmd[COMMAND]) != FD_READ) {\n\t\t/* transfer directly from buffer */\n\t\tcont->done(1);\n\t} else {\n\t\tbuffer_track = raw_cmd->track;\n\t\tbuffer_drive = current_drive;\n\t\tINFBOUND(buffer_max, nr_sectors + fsector_t);\n\t}\n\tcont->redo();\n}\n\n/* Compute the maximal transfer size */\nstatic int transfer_size(int ssize, int max_sector, int max_size)\n{\n\tSUPBOUND(max_sector, fsector_t + max_size);\n\n\t/* alignment */\n\tmax_sector -= (max_sector % _floppy->sect) % ssize;\n\n\t/* transfer size, beginning not aligned */\n\tcurrent_count_sectors = max_sector - fsector_t;\n\n\treturn max_sector;\n}\n\n/*\n * Move data from/to the track buffer to/from the buffer cache.\n */\nstatic void copy_buffer(int ssize, int max_sector, int max_sector_2)\n{\n\tint remaining;\t\t/* number of transferred 512-byte sectors */\n\tstruct bio_vec bv;\n\tchar *dma_buffer;\n\tint size;\n\tstruct req_iterator iter;\n\n\tmax_sector = transfer_size(ssize,\n\t\t\t\t   min(max_sector, max_sector_2),\n\t\t\t\t   blk_rq_sectors(current_req));\n\n\tif (current_count_sectors <= 0 && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE &&\n\t    buffer_max > fsector_t + blk_rq_sectors(current_req))\n\t\tcurrent_count_sectors = min_t(int, buffer_max - fsector_t,\n\t\t\t\t\t      blk_rq_sectors(current_req));\n\n\tremaining = current_count_sectors << 9;\n\tif (remaining > blk_rq_bytes(current_req) && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\tDPRINT(\"in copy buffer\\n\");\n\t\tpr_info(\"current_count_sectors=%ld\\n\", current_count_sectors);\n\t\tpr_info(\"remaining=%d\\n\", remaining >> 9);\n\t\tpr_info(\"current_req->nr_sectors=%u\\n\",\n\t\t\tblk_rq_sectors(current_req));\n\t\tpr_info(\"current_req->current_nr_sectors=%u\\n\",\n\t\t\tblk_rq_cur_sectors(current_req));\n\t\tpr_info(\"max_sector=%d\\n\", max_sector);\n\t\tpr_info(\"ssize=%d\\n\", ssize);\n\t}\n\n\tbuffer_max = max(max_sector, buffer_max);\n\n\tdma_buffer = floppy_track_buffer + ((fsector_t - buffer_min) << 9);\n\n\tsize = blk_rq_cur_bytes(current_req);\n\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (!remaining)\n\t\t\tbreak;\n\n\t\tsize = bv.bv_len;\n\t\tSUPBOUND(size, remaining);\n\t\tif (dma_buffer + size >\n\t\t    floppy_track_buffer + (max_buffer_sectors << 10) ||\n\t\t    dma_buffer < floppy_track_buffer) {\n\t\t\tDPRINT(\"buffer overrun in copy buffer %d\\n\",\n\t\t\t       (int)((floppy_track_buffer - dma_buffer) >> 9));\n\t\t\tpr_info(\"fsector_t=%d buffer_min=%d\\n\",\n\t\t\t\tfsector_t, buffer_min);\n\t\t\tpr_info(\"current_count_sectors=%ld\\n\",\n\t\t\t\tcurrent_count_sectors);\n\t\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\t\t\tpr_info(\"read\\n\");\n\t\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE)\n\t\t\t\tpr_info(\"write\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\t\tmemcpy_to_bvec(&bv, dma_buffer);\n\t\telse\n\t\t\tmemcpy_from_bvec(dma_buffer, &bv);\n\n\t\tremaining -= size;\n\t\tdma_buffer += size;\n\t}\n\tif (remaining) {\n\t\tif (remaining > 0)\n\t\t\tmax_sector -= remaining >> 9;\n\t\tDPRINT(\"weirdness: remaining %d\\n\", remaining >> 9);\n\t}\n}\n\n/* work around a bug in pseudo DMA\n * (on some FDCs) pseudo DMA does not stop when the CPU stops\n * sending data.  Hence we need a different way to signal the\n * transfer length:  We use raw_cmd->cmd[SECT_PER_TRACK].  Unfortunately, this\n * does not work with MT, hence we can only transfer one head at\n * a time\n */\nstatic void virtualdmabug_workaround(void)\n{\n\tint hard_sectors;\n\tint end_sector;\n\n\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\traw_cmd->cmd[COMMAND] &= ~0x80;\t/* switch off multiple track mode */\n\n\t\thard_sectors = raw_cmd->length >> (7 + raw_cmd->cmd[SIZECODE]);\n\t\tend_sector = raw_cmd->cmd[SECTOR] + hard_sectors - 1;\n\t\tif (end_sector > raw_cmd->cmd[SECT_PER_TRACK]) {\n\t\t\tpr_info(\"too many sectors %d > %d\\n\",\n\t\t\t\tend_sector, raw_cmd->cmd[SECT_PER_TRACK]);\n\t\t\treturn;\n\t\t}\n\t\traw_cmd->cmd[SECT_PER_TRACK] = end_sector;\n\t\t\t\t\t/* make sure raw_cmd->cmd[SECT_PER_TRACK]\n\t\t\t\t\t * points to end of transfer */\n\t}\n}\n\n/*\n * Formulate a read/write request.\n * this routine decides where to load the data (directly to buffer, or to\n * tmp floppy area), how much data to load (the size of the buffer, the whole\n * track, or a single sector)\n * All floppy_track_buffer handling goes in here. If we ever add track buffer\n * allocation on the fly, it should be done here. No other part should need\n * modification.\n */\n\nstatic int make_raw_rw_request(void)\n{\n\tint aligned_sector_t;\n\tint max_sector;\n\tint max_size;\n\tint tracksize;\n\tint ssize;\n\n\tif (WARN(max_buffer_sectors == 0, \"VFS: Block I/O scheduled on unopened device\\n\"))\n\t\treturn 0;\n\n\tset_fdc((long)current_req->q->disk->private_data);\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK;\n\traw_cmd->cmd_count = NR_RW;\n\tif (rq_data_dir(current_req) == READ) {\n\t\traw_cmd->flags |= FD_RAW_READ;\n\t\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_READ);\n\t} else if (rq_data_dir(current_req) == WRITE) {\n\t\traw_cmd->flags |= FD_RAW_WRITE;\n\t\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_WRITE);\n\t} else {\n\t\tDPRINT(\"%s: unknown command\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tmax_sector = _floppy->sect * _floppy->head;\n\n\traw_cmd->cmd[TRACK] = (int)blk_rq_pos(current_req) / max_sector;\n\tfsector_t = (int)blk_rq_pos(current_req) % max_sector;\n\tif (_floppy->track && raw_cmd->cmd[TRACK] >= _floppy->track) {\n\t\tif (blk_rq_cur_sectors(current_req) & 1) {\n\t\t\tcurrent_count_sectors = 1;\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\traw_cmd->cmd[HEAD] = fsector_t / _floppy->sect;\n\n\tif (((_floppy->stretch & (FD_SWAPSIDES | FD_SECTBASEMASK)) ||\n\t     test_bit(FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags)) &&\n\t    fsector_t < _floppy->sect)\n\t\tmax_sector = _floppy->sect;\n\n\t/* 2M disks have phantom sectors on the first track */\n\tif ((_floppy->rate & FD_2M) && (!raw_cmd->cmd[TRACK]) && (!raw_cmd->cmd[HEAD])) {\n\t\tmax_sector = 2 * _floppy->sect / 3;\n\t\tif (fsector_t >= max_sector) {\n\t\t\tcurrent_count_sectors =\n\t\t\t    min_t(int, _floppy->sect - fsector_t,\n\t\t\t\t  blk_rq_sectors(current_req));\n\t\t\treturn 1;\n\t\t}\n\t\traw_cmd->cmd[SIZECODE] = 2;\n\t} else\n\t\traw_cmd->cmd[SIZECODE] = FD_SIZECODE(_floppy);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\tif ((_floppy->rate & FD_2M) &&\n\t    (raw_cmd->cmd[TRACK] || raw_cmd->cmd[HEAD]) && raw_cmd->rate == 2)\n\t\traw_cmd->rate = 1;\n\n\tif (raw_cmd->cmd[SIZECODE])\n\t\traw_cmd->cmd[SIZECODE2] = 0xff;\n\telse\n\t\traw_cmd->cmd[SIZECODE2] = 0x80;\n\traw_cmd->track = raw_cmd->cmd[TRACK] << STRETCH(_floppy);\n\traw_cmd->cmd[DR_SELECT] = UNIT(current_drive) + PH_HEAD(_floppy, raw_cmd->cmd[HEAD]);\n\traw_cmd->cmd[GAP] = _floppy->gap;\n\tssize = DIV_ROUND_UP(1 << raw_cmd->cmd[SIZECODE], 4);\n\traw_cmd->cmd[SECT_PER_TRACK] = _floppy->sect << 2 >> raw_cmd->cmd[SIZECODE];\n\traw_cmd->cmd[SECTOR] = ((fsector_t % _floppy->sect) << 2 >> raw_cmd->cmd[SIZECODE]) +\n\t    FD_SECTBASE(_floppy);\n\n\t/* tracksize describes the size which can be filled up with sectors\n\t * of size ssize.\n\t */\n\ttracksize = _floppy->sect - _floppy->sect % ssize;\n\tif (tracksize < _floppy->sect) {\n\t\traw_cmd->cmd[SECT_PER_TRACK]++;\n\t\tif (tracksize <= fsector_t % _floppy->sect)\n\t\t\traw_cmd->cmd[SECTOR]--;\n\n\t\t/* if we are beyond tracksize, fill up using smaller sectors */\n\t\twhile (tracksize <= fsector_t % _floppy->sect) {\n\t\t\twhile (tracksize + ssize > _floppy->sect) {\n\t\t\t\traw_cmd->cmd[SIZECODE]--;\n\t\t\t\tssize >>= 1;\n\t\t\t}\n\t\t\traw_cmd->cmd[SECTOR]++;\n\t\t\traw_cmd->cmd[SECT_PER_TRACK]++;\n\t\t\ttracksize += ssize;\n\t\t}\n\t\tmax_sector = raw_cmd->cmd[HEAD] * _floppy->sect + tracksize;\n\t} else if (!raw_cmd->cmd[TRACK] && !raw_cmd->cmd[HEAD] && !(_floppy->rate & FD_2M) && probing) {\n\t\tmax_sector = _floppy->sect;\n\t} else if (!raw_cmd->cmd[HEAD] && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\t/* for virtual DMA bug workaround */\n\t\tmax_sector = _floppy->sect;\n\t}\n\n\tin_sector_offset = (fsector_t % _floppy->sect) % ssize;\n\taligned_sector_t = fsector_t - in_sector_offset;\n\tmax_size = blk_rq_sectors(current_req);\n\tif ((raw_cmd->track == buffer_track) &&\n\t    (current_drive == buffer_drive) &&\n\t    (fsector_t >= buffer_min) && (fsector_t < buffer_max)) {\n\t\t/* data already in track buffer */\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ) {\n\t\t\tcopy_buffer(1, max_sector, buffer_max);\n\t\t\treturn 1;\n\t\t}\n\t} else if (in_sector_offset || blk_rq_sectors(current_req) < ssize) {\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\t\tunsigned int sectors;\n\n\t\t\tsectors = fsector_t + blk_rq_sectors(current_req);\n\t\t\tif (sectors > ssize && sectors < ssize + ssize)\n\t\t\t\tmax_size = ssize + ssize;\n\t\t\telse\n\t\t\t\tmax_size = ssize;\n\t\t}\n\t\traw_cmd->flags &= ~FD_RAW_WRITE;\n\t\traw_cmd->flags |= FD_RAW_READ;\n\t\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_READ);\n\t}\n\n\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\tmax_size = max_sector;\t/* unbounded */\n\n\t/* claim buffer track if needed */\n\tif (buffer_track != raw_cmd->track ||\t/* bad track */\n\t    buffer_drive != current_drive ||\t/* bad drive */\n\t    fsector_t > buffer_max ||\n\t    fsector_t < buffer_min ||\n\t    ((CT(raw_cmd->cmd[COMMAND]) == FD_READ ||\n\t      (!in_sector_offset && blk_rq_sectors(current_req) >= ssize)) &&\n\t     max_sector > 2 * max_buffer_sectors + buffer_min &&\n\t     max_size + fsector_t > 2 * max_buffer_sectors + buffer_min)) {\n\t\t/* not enough space */\n\t\tbuffer_track = -1;\n\t\tbuffer_drive = current_drive;\n\t\tbuffer_max = buffer_min = aligned_sector_t;\n\t}\n\traw_cmd->kernel_data = floppy_track_buffer +\n\t\t((aligned_sector_t - buffer_min) << 9);\n\n\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\t/* copy write buffer to track buffer.\n\t\t * if we get here, we know that the write\n\t\t * is either aligned or the data already in the buffer\n\t\t * (buffer will be overwritten) */\n\t\tif (in_sector_offset && buffer_track == -1)\n\t\t\tDPRINT(\"internal error offset !=0 on write\\n\");\n\t\tbuffer_track = raw_cmd->track;\n\t\tbuffer_drive = current_drive;\n\t\tcopy_buffer(ssize, max_sector,\n\t\t\t    2 * max_buffer_sectors + buffer_min);\n\t} else\n\t\ttransfer_size(ssize, max_sector,\n\t\t\t      2 * max_buffer_sectors + buffer_min -\n\t\t\t      aligned_sector_t);\n\n\t/* round up current_count_sectors to get dma xfer size */\n\traw_cmd->length = in_sector_offset + current_count_sectors;\n\traw_cmd->length = ((raw_cmd->length - 1) | (ssize - 1)) + 1;\n\traw_cmd->length <<= 9;\n\tif ((raw_cmd->length < current_count_sectors << 9) ||\n\t    (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE &&\n\t     (aligned_sector_t + (raw_cmd->length >> 9) > buffer_max ||\n\t      aligned_sector_t < buffer_min)) ||\n\t    raw_cmd->length % (128 << raw_cmd->cmd[SIZECODE]) ||\n\t    raw_cmd->length <= 0 || current_count_sectors <= 0) {\n\t\tDPRINT(\"fractionary current count b=%lx s=%lx\\n\",\n\t\t       raw_cmd->length, current_count_sectors);\n\t\tpr_info(\"addr=%d, length=%ld\\n\",\n\t\t\t(int)((raw_cmd->kernel_data -\n\t\t\t       floppy_track_buffer) >> 9),\n\t\t\tcurrent_count_sectors);\n\t\tpr_info(\"st=%d ast=%d mse=%d msi=%d\\n\",\n\t\t\tfsector_t, aligned_sector_t, max_sector, max_size);\n\t\tpr_info(\"ssize=%x SIZECODE=%d\\n\", ssize, raw_cmd->cmd[SIZECODE]);\n\t\tpr_info(\"command=%x SECTOR=%d HEAD=%d, TRACK=%d\\n\",\n\t\t\traw_cmd->cmd[COMMAND], raw_cmd->cmd[SECTOR],\n\t\t\traw_cmd->cmd[HEAD], raw_cmd->cmd[TRACK]);\n\t\tpr_info(\"buffer drive=%d\\n\", buffer_drive);\n\t\tpr_info(\"buffer track=%d\\n\", buffer_track);\n\t\tpr_info(\"buffer_min=%d\\n\", buffer_min);\n\t\tpr_info(\"buffer_max=%d\\n\", buffer_max);\n\t\treturn 0;\n\t}\n\n\tif (raw_cmd->kernel_data < floppy_track_buffer ||\n\t    current_count_sectors < 0 ||\n\t    raw_cmd->length < 0 ||\n\t    raw_cmd->kernel_data + raw_cmd->length >\n\t    floppy_track_buffer + (max_buffer_sectors << 10)) {\n\t\tDPRINT(\"buffer overrun in schedule dma\\n\");\n\t\tpr_info(\"fsector_t=%d buffer_min=%d current_count=%ld\\n\",\n\t\t\tfsector_t, buffer_min, raw_cmd->length >> 9);\n\t\tpr_info(\"current_count_sectors=%ld\\n\",\n\t\t\tcurrent_count_sectors);\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\t\tpr_info(\"read\\n\");\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE)\n\t\t\tpr_info(\"write\\n\");\n\t\treturn 0;\n\t}\n\tif (raw_cmd->length == 0) {\n\t\tDPRINT(\"zero dma transfer attempted from make_raw_request\\n\");\n\t\treturn 0;\n\t}\n\n\tvirtualdmabug_workaround();\n\treturn 2;\n}\n\nstatic int set_next_request(void)\n{\n\tcurrent_req = list_first_entry_or_null(&floppy_reqs, struct request,\n\t\t\t\t\t       queuelist);\n\tif (current_req) {\n\t\tcurrent_req->error_count = 0;\n\t\tlist_del_init(&current_req->queuelist);\n\t}\n\treturn current_req != NULL;\n}\n\n/* Starts or continues processing request. Will automatically unlock the\n * driver at end of request.\n */\nstatic void redo_fd_request(void)\n{\n\tint drive;\n\tint tmp;\n\n\tlastredo = jiffies;\n\tif (current_drive < N_DRIVE)\n\t\tfloppy_off(current_drive);\n\ndo_request:\n\tif (!current_req) {\n\t\tint pending;\n\n\t\tspin_lock_irq(&floppy_lock);\n\t\tpending = set_next_request();\n\t\tspin_unlock_irq(&floppy_lock);\n\t\tif (!pending) {\n\t\t\tdo_floppy = NULL;\n\t\t\tunlock_fdc();\n\t\t\treturn;\n\t\t}\n\t}\n\tdrive = (long)current_req->q->disk->private_data;\n\tset_fdc(drive);\n\treschedule_timeout(current_drive, \"redo fd request\");\n\n\tset_floppy(drive);\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = 0;\n\tif (start_motor(redo_fd_request))\n\t\treturn;\n\n\tdisk_change(current_drive);\n\tif (test_bit(current_drive, &fake_change) ||\n\t    test_bit(FD_DISK_CHANGED_BIT, &drive_state[current_drive].flags)) {\n\t\tDPRINT(\"disk absent or changed during operation\\n\");\n\t\trequest_done(0);\n\t\tgoto do_request;\n\t}\n\tif (!_floppy) {\t/* Autodetection */\n\t\tif (!probing) {\n\t\t\tdrive_state[current_drive].probed_format = 0;\n\t\t\tif (next_valid_format(current_drive)) {\n\t\t\t\tDPRINT(\"no autodetectable formats\\n\");\n\t\t\t\t_floppy = NULL;\n\t\t\t\trequest_done(0);\n\t\t\t\tgoto do_request;\n\t\t\t}\n\t\t}\n\t\tprobing = 1;\n\t\t_floppy = floppy_type + drive_params[current_drive].autodetect[drive_state[current_drive].probed_format];\n\t} else\n\t\tprobing = 0;\n\terrors = &(current_req->error_count);\n\ttmp = make_raw_rw_request();\n\tif (tmp < 2) {\n\t\trequest_done(tmp);\n\t\tgoto do_request;\n\t}\n\n\tif (test_bit(FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags))\n\t\ttwaddle(current_fdc, current_drive);\n\tschedule_bh(floppy_start);\n\tdebugt(__func__, \"queue fd request\");\n\treturn;\n}\n\nstatic const struct cont_t rw_cont = {\n\t.interrupt\t= rw_interrupt,\n\t.redo\t\t= redo_fd_request,\n\t.error\t\t= bad_flp_intr,\n\t.done\t\t= request_done\n};\n\n/* schedule the request and automatically unlock the driver on completion */\nstatic void process_fd_request(void)\n{\n\tcont = &rw_cont;\n\tschedule_bh(redo_fd_request);\n}\n\nstatic blk_status_t floppy_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t    const struct blk_mq_queue_data *bd)\n{\n\tblk_mq_start_request(bd->rq);\n\n\tif (WARN(max_buffer_sectors == 0,\n\t\t \"VFS: %s called on non-open device\\n\", __func__))\n\t\treturn BLK_STS_IOERR;\n\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"warning: usage count=0, current_req=%p sect=%ld flags=%llx\\n\",\n\t\t current_req, (long)blk_rq_pos(current_req),\n\t\t (unsigned long long) current_req->cmd_flags))\n\t\treturn BLK_STS_IOERR;\n\n\tif (test_and_set_bit(0, &fdc_busy)) {\n\t\t/* fdc busy, this new request will be treated when the\n\t\t   current one is done */\n\t\tis_alive(__func__, \"old request running\");\n\t\treturn BLK_STS_RESOURCE;\n\t}\n\n\tspin_lock_irq(&floppy_lock);\n\tlist_add_tail(&bd->rq->queuelist, &floppy_reqs);\n\tspin_unlock_irq(&floppy_lock);\n\n\tcommand_status = FD_COMMAND_NONE;\n\t__reschedule_timeout(MAXTIMEOUT, \"fd_request\");\n\tset_fdc(0);\n\tprocess_fd_request();\n\tis_alive(__func__, \"\");\n\treturn BLK_STS_OK;\n}\n\nstatic const struct cont_t poll_cont = {\n\t.interrupt\t= success_and_wakeup,\n\t.redo\t\t= floppy_ready,\n\t.error\t\t= generic_failure,\n\t.done\t\t= generic_done\n};\n\nstatic int poll_drive(bool interruptible, int flag)\n{\n\t/* no auto-sense, just clear dcl */\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = flag;\n\traw_cmd->track = 0;\n\traw_cmd->cmd_count = 0;\n\tcont = &poll_cont;\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"setting NEWCHANGE in poll_drive\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags);\n\n\treturn wait_til_done(floppy_ready, interruptible);\n}\n\n/*\n * User triggered reset\n * ====================\n */\n\nstatic void reset_intr(void)\n{\n\tpr_info(\"weird, reset interrupt called\\n\");\n}\n\nstatic const struct cont_t reset_cont = {\n\t.interrupt\t= reset_intr,\n\t.redo\t\t= success_and_wakeup,\n\t.error\t\t= generic_failure,\n\t.done\t\t= generic_done\n};\n\n/*\n * Resets the FDC connected to drive <drive>.\n * Both current_drive and current_fdc are changed to match the new drive.\n */\nstatic int user_reset_fdc(int drive, int arg, bool interruptible)\n{\n\tint ret;\n\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\n\tif (arg == FD_RESET_ALWAYS)\n\t\tfdc_state[current_fdc].reset = 1;\n\tif (fdc_state[current_fdc].reset) {\n\t\t/* note: reset_fdc will take care of unlocking the driver\n\t\t * on completion.\n\t\t */\n\t\tcont = &reset_cont;\n\t\tret = wait_til_done(reset_fdc, interruptible);\n\t\tif (ret == -EINTR)\n\t\t\treturn -EINTR;\n\t}\n\tprocess_fd_request();\n\treturn 0;\n}\n\n/*\n * Misc Ioctl's and support\n * ========================\n */\nstatic inline int fd_copyout(void __user *param, const void *address,\n\t\t\t     unsigned long size)\n{\n\treturn copy_to_user(param, address, size) ? -EFAULT : 0;\n}\n\nstatic inline int fd_copyin(void __user *param, void *address,\n\t\t\t    unsigned long size)\n{\n\treturn copy_from_user(address, param, size) ? -EFAULT : 0;\n}\n\nstatic const char *drive_name(int type, int drive)\n{\n\tstruct floppy_struct *floppy;\n\n\tif (type)\n\t\tfloppy = floppy_type + type;\n\telse {\n\t\tif (drive_params[drive].native_format)\n\t\t\tfloppy = floppy_type + drive_params[drive].native_format;\n\t\telse\n\t\t\treturn \"(null)\";\n\t}\n\tif (floppy->name)\n\t\treturn floppy->name;\n\telse\n\t\treturn \"(null)\";\n}\n\n/* raw commands */\nstatic void raw_cmd_done(int flag)\n{\n\tif (!flag) {\n\t\traw_cmd->flags |= FD_RAW_FAILURE;\n\t\traw_cmd->flags |= FD_RAW_HARDFAILURE;\n\t} else {\n\t\traw_cmd->reply_count = inr;\n\t\tif (raw_cmd->reply_count > FD_RAW_REPLY_SIZE)\n\t\t\traw_cmd->reply_count = 0;\n\t\tmemcpy(raw_cmd->reply, reply_buffer, raw_cmd->reply_count);\n\n\t\tif (raw_cmd->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\t\tunsigned long flags;\n\t\t\tflags = claim_dma_lock();\n\t\t\traw_cmd->length = fd_get_dma_residue();\n\t\t\trelease_dma_lock(flags);\n\t\t}\n\n\t\tif ((raw_cmd->flags & FD_RAW_SOFTFAILURE) &&\n\t\t    (!raw_cmd->reply_count || (raw_cmd->reply[0] & 0xc0)))\n\t\t\traw_cmd->flags |= FD_RAW_FAILURE;\n\n\t\tif (disk_change(current_drive))\n\t\t\traw_cmd->flags |= FD_RAW_DISK_CHANGE;\n\t\telse\n\t\t\traw_cmd->flags &= ~FD_RAW_DISK_CHANGE;\n\t\tif (raw_cmd->flags & FD_RAW_NO_MOTOR_AFTER)\n\t\t\tmotor_off_callback(&motor_off_timer[current_drive]);\n\n\t\tif (raw_cmd->next &&\n\t\t    (!(raw_cmd->flags & FD_RAW_FAILURE) ||\n\t\t     !(raw_cmd->flags & FD_RAW_STOP_IF_FAILURE)) &&\n\t\t    ((raw_cmd->flags & FD_RAW_FAILURE) ||\n\t\t     !(raw_cmd->flags & FD_RAW_STOP_IF_SUCCESS))) {\n\t\t\traw_cmd = raw_cmd->next;\n\t\t\treturn;\n\t\t}\n\t}\n\tgeneric_done(flag);\n}\n\nstatic const struct cont_t raw_cmd_cont = {\n\t.interrupt\t= success_and_wakeup,\n\t.redo\t\t= floppy_start,\n\t.error\t\t= generic_failure,\n\t.done\t\t= raw_cmd_done\n};\n\nstatic int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}\n\nstatic void raw_cmd_free(struct floppy_raw_cmd **ptr)\n{\n\tstruct floppy_raw_cmd *next;\n\tstruct floppy_raw_cmd *this;\n\n\tthis = *ptr;\n\t*ptr = NULL;\n\twhile (this) {\n\t\tif (this->buffer_length) {\n\t\t\tfd_dma_mem_free((unsigned long)this->kernel_data,\n\t\t\t\t\tthis->buffer_length);\n\t\t\tthis->buffer_length = 0;\n\t\t}\n\t\tnext = this->next;\n\t\tkfree(this);\n\t\tthis = next;\n\t}\n}\n\n#define MAX_LEN (1UL << MAX_ORDER << PAGE_SHIFT)\n\nstatic int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tptr->kernel_data = NULL;\n\tif (ret)\n\t\treturn -EFAULT;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > FD_RAW_CMD_FULLSIZE)\n\t\treturn -EINVAL;\n\n\tmemset(ptr->reply, 0, FD_RAW_REPLY_SIZE);\n\tptr->resultcode = 0;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0 || ptr->length >= MAX_LEN)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\n\treturn 0;\n}\n\nstatic int raw_cmd_ioctl(int cmd, void __user *param)\n{\n\tstruct floppy_raw_cmd *my_raw_cmd;\n\tint drive;\n\tint ret2;\n\tint ret;\n\n\tif (fdc_state[current_fdc].rawcmd <= 1)\n\t\tfdc_state[current_fdc].rawcmd = 1;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (FDC(drive) != current_fdc)\n\t\t\tcontinue;\n\t\tif (drive == current_drive) {\n\t\t\tif (drive_state[drive].fd_ref > 1) {\n\t\t\t\tfdc_state[current_fdc].rawcmd = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (drive_state[drive].fd_ref) {\n\t\t\tfdc_state[current_fdc].rawcmd = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fdc_state[current_fdc].reset)\n\t\treturn -EIO;\n\n\tret = raw_cmd_copyin(cmd, param, &my_raw_cmd);\n\tif (ret) {\n\t\traw_cmd_free(&my_raw_cmd);\n\t\treturn ret;\n\t}\n\n\traw_cmd = my_raw_cmd;\n\tcont = &raw_cmd_cont;\n\tret = wait_til_done(floppy_start, true);\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from raw_cmd ioctl\\n\");\n\n\tif (ret != -EINTR && fdc_state[current_fdc].reset)\n\t\tret = -EIO;\n\n\tdrive_state[current_drive].track = NO_TRACK;\n\n\tret2 = raw_cmd_copyout(cmd, param, my_raw_cmd);\n\tif (!ret)\n\t\tret = ret2;\n\traw_cmd_free(&my_raw_cmd);\n\treturn ret;\n}\n\nstatic int invalidate_drive(struct block_device *bdev)\n{\n\t/* invalidate the buffer track to force a reread */\n\tset_bit((long)bdev->bd_disk->private_data, &fake_change);\n\tprocess_fd_request();\n\tif (bdev_check_media_change(bdev))\n\t\tfloppy_revalidate(bdev->bd_disk);\n\treturn 0;\n}\n\nstatic int set_geometry(unsigned int cmd, struct floppy_struct *g,\n\t\t\t       int drive, int type, struct block_device *bdev)\n{\n\tint cnt;\n\n\t/* sanity checking for parameters. */\n\tif ((int)g->sect <= 0 ||\n\t    (int)g->head <= 0 ||\n\t    /* check for overflow in max_sector */\n\t    (int)(g->sect * g->head) <= 0 ||\n\t    /* check for zero in raw_cmd->cmd[F_SECT_PER_TRACK] */\n\t    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||\n\t    g->track <= 0 || g->track > drive_params[drive].tracks >> STRETCH(g) ||\n\t    /* check if reserved bits are set */\n\t    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)\n\t\treturn -EINVAL;\n\tif (type) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmutex_lock(&open_lock);\n\t\tif (lock_fdc(drive)) {\n\t\t\tmutex_unlock(&open_lock);\n\t\t\treturn -EINTR;\n\t\t}\n\t\tfloppy_type[type] = *g;\n\t\tfloppy_type[type].name = \"user format\";\n\t\tfor (cnt = type << 2; cnt < (type << 2) + 4; cnt++)\n\t\t\tfloppy_sizes[cnt] = floppy_sizes[cnt + 0x80] =\n\t\t\t    floppy_type[type].size + 1;\n\t\tprocess_fd_request();\n\t\tfor (cnt = 0; cnt < N_DRIVE; cnt++) {\n\t\t\tstruct block_device *bdev = opened_bdev[cnt];\n\t\t\tif (!bdev || ITYPE(drive_state[cnt].fd_device) != type)\n\t\t\t\tcontinue;\n\t\t\t__invalidate_device(bdev, true);\n\t\t}\n\t\tmutex_unlock(&open_lock);\n\t} else {\n\t\tint oldStretch;\n\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (cmd != FDDEFPRM) {\n\t\t\t/* notice a disk change immediately, else\n\t\t\t * we lose our settings immediately*/\n\t\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\t\treturn -EINTR;\n\t\t}\n\t\toldStretch = g->stretch;\n\t\tuser_params[drive] = *g;\n\t\tif (buffer_drive == drive)\n\t\t\tSUPBOUND(buffer_max, user_params[drive].sect);\n\t\tcurrent_type[drive] = &user_params[drive];\n\t\tfloppy_sizes[drive] = user_params[drive].size;\n\t\tif (cmd == FDDEFPRM)\n\t\t\tdrive_state[current_drive].keep_data = -1;\n\t\telse\n\t\t\tdrive_state[current_drive].keep_data = 1;\n\t\t/* invalidation. Invalidate only when needed, i.e.\n\t\t * when there are already sectors in the buffer cache\n\t\t * whose number will change. This is useful, because\n\t\t * mtools often changes the geometry of the disk after\n\t\t * looking at the boot block */\n\t\tif (drive_state[current_drive].maxblock > user_params[drive].sect ||\n\t\t    drive_state[current_drive].maxtrack ||\n\t\t    ((user_params[drive].sect ^ oldStretch) &\n\t\t     (FD_SWAPSIDES | FD_SECTBASEMASK)))\n\t\t\tinvalidate_drive(bdev);\n\t\telse\n\t\t\tprocess_fd_request();\n\t}\n\treturn 0;\n}\n\n/* handle obsolete ioctl's */\nstatic unsigned int ioctl_table[] = {\n\tFDCLRPRM,\n\tFDSETPRM,\n\tFDDEFPRM,\n\tFDGETPRM,\n\tFDMSGON,\n\tFDMSGOFF,\n\tFDFMTBEG,\n\tFDFMTTRK,\n\tFDFMTEND,\n\tFDSETEMSGTRESH,\n\tFDFLUSH,\n\tFDSETMAXERRS,\n\tFDGETMAXERRS,\n\tFDGETDRVTYP,\n\tFDSETDRVPRM,\n\tFDGETDRVPRM,\n\tFDGETDRVSTAT,\n\tFDPOLLDRVSTAT,\n\tFDRESET,\n\tFDGETFDCSTAT,\n\tFDWERRORCLR,\n\tFDWERRORGET,\n\tFDRAWCMD,\n\tFDEJECT,\n\tFDTWADDLE\n};\n\nstatic int normalize_ioctl(unsigned int *cmd, int *size)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ioctl_table); i++) {\n\t\tif ((*cmd & 0xffff) == (ioctl_table[i] & 0xffff)) {\n\t\t\t*size = _IOC_SIZE(*cmd);\n\t\t\t*cmd = ioctl_table[i];\n\t\t\tif (*size > _IOC_SIZE(*cmd)) {\n\t\t\t\tpr_info(\"ioctl not yet supported\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int get_floppy_geometry(int drive, int type, struct floppy_struct **g)\n{\n\tif (type)\n\t\t*g = &floppy_type[type];\n\telse {\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(false, 0) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\t*g = current_type[drive];\n\t}\n\tif (!*g)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tstruct floppy_struct *g;\n\tint ret;\n\n\tret = get_floppy_geometry(drive, type, &g);\n\tif (ret)\n\t\treturn ret;\n\n\tgeo->heads = g->head;\n\tgeo->sectors = g->sect;\n\tgeo->cylinders = g->track;\n\treturn 0;\n}\n\nstatic bool valid_floppy_drive_params(const short autodetect[FD_AUTODETECT_SIZE],\n\t\tint native_format)\n{\n\tsize_t floppy_type_size = ARRAY_SIZE(floppy_type);\n\tsize_t i = 0;\n\n\tfor (i = 0; i < FD_AUTODETECT_SIZE; ++i) {\n\t\tif (autodetect[i] < 0 ||\n\t\t    autodetect[i] >= floppy_type_size)\n\t\t\treturn false;\n\t}\n\n\tif (native_format < 0 || native_format >= floppy_type_size)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int fd_locked_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tint i;\n\tint ret;\n\tint size;\n\tunion inparam {\n\t\tstruct floppy_struct g;\t/* geometry */\n\t\tstruct format_descr f;\n\t\tstruct floppy_max_errors max_errors;\n\t\tstruct floppy_drive_params dp;\n\t} inparam;\t\t/* parameters coming from user space */\n\tconst void *outparam;\t/* parameters passed back to user space */\n\n\t/* convert compatibility eject ioctls into floppy eject ioctl.\n\t * We do this in order to provide a means to eject floppy disks before\n\t * installing the new fdutils package */\n\tif (cmd == CDROMEJECT ||\t/* CD-ROM eject */\n\t    cmd == 0x6470) {\t\t/* SunOS floppy eject */\n\t\tDPRINT(\"obsolete eject ioctl\\n\");\n\t\tDPRINT(\"please use floppycontrol --eject\\n\");\n\t\tcmd = FDEJECT;\n\t}\n\n\tif (!((cmd & 0xff00) == 0x0200))\n\t\treturn -EINVAL;\n\n\t/* convert the old style command into a new style command */\n\tret = normalize_ioctl(&cmd, &size);\n\tif (ret)\n\t\treturn ret;\n\n\t/* permission checks */\n\tif (((cmd & 0x40) && !(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL))) ||\n\t    ((cmd & 0x80) && !capable(CAP_SYS_ADMIN)))\n\t\treturn -EPERM;\n\n\tif (WARN_ON(size < 0 || size > sizeof(inparam)))\n\t\treturn -EINVAL;\n\n\t/* copyin */\n\tmemset(&inparam, 0, sizeof(inparam));\n\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\tret = fd_copyin((void __user *)param, &inparam, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (cmd) {\n\tcase FDEJECT:\n\t\tif (drive_state[drive].fd_ref != 1)\n\t\t\t/* somebody else has this drive open */\n\t\t\treturn -EBUSY;\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\n\t\t/* do the actual eject. Fails on\n\t\t * non-Sparc architectures */\n\t\tret = fd_eject(UNIT(drive));\n\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tprocess_fd_request();\n\t\treturn ret;\n\tcase FDCLRPRM:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tcurrent_type[drive] = NULL;\n\t\tfloppy_sizes[drive] = MAX_DISK_SIZE << 1;\n\t\tdrive_state[drive].keep_data = 0;\n\t\treturn invalidate_drive(bdev);\n\tcase FDSETPRM:\n\tcase FDDEFPRM:\n\t\treturn set_geometry(cmd, &inparam.g, drive, type, bdev);\n\tcase FDGETPRM:\n\t\tret = get_floppy_geometry(drive, type,\n\t\t\t\t\t  (struct floppy_struct **)&outparam);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmemcpy(&inparam.g, outparam,\n\t\t\t\toffsetof(struct floppy_struct, name));\n\t\toutparam = &inparam.g;\n\t\tbreak;\n\tcase FDMSGON:\n\t\tdrive_params[drive].flags |= FTD_MSG;\n\t\treturn 0;\n\tcase FDMSGOFF:\n\t\tdrive_params[drive].flags &= ~FTD_MSG;\n\t\treturn 0;\n\tcase FDFMTBEG:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tret = drive_state[drive].flags;\n\t\tprocess_fd_request();\n\t\tif (ret & FD_VERIFY)\n\t\t\treturn -ENODEV;\n\t\tif (!(ret & FD_DISK_WRITABLE))\n\t\t\treturn -EROFS;\n\t\treturn 0;\n\tcase FDFMTTRK:\n\t\tif (drive_state[drive].fd_ref != 1)\n\t\t\treturn -EBUSY;\n\t\treturn do_format(drive, &inparam.f);\n\tcase FDFMTEND:\n\tcase FDFLUSH:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\treturn invalidate_drive(bdev);\n\tcase FDSETEMSGTRESH:\n\t\tdrive_params[drive].max_errors.reporting = (unsigned short)(param & 0x0f);\n\t\treturn 0;\n\tcase FDGETMAXERRS:\n\t\toutparam = &drive_params[drive].max_errors;\n\t\tbreak;\n\tcase FDSETMAXERRS:\n\t\tdrive_params[drive].max_errors = inparam.max_errors;\n\t\tbreak;\n\tcase FDGETDRVTYP:\n\t\toutparam = drive_name(type, drive);\n\t\tSUPBOUND(size, strlen((const char *)outparam) + 1);\n\t\tbreak;\n\tcase FDSETDRVPRM:\n\t\tif (!valid_floppy_drive_params(inparam.dp.autodetect,\n\t\t\t\tinparam.dp.native_format))\n\t\t\treturn -EINVAL;\n\t\tdrive_params[drive] = inparam.dp;\n\t\tbreak;\n\tcase FDGETDRVPRM:\n\t\toutparam = &drive_params[drive];\n\t\tbreak;\n\tcase FDPOLLDRVSTAT:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\tfallthrough;\n\tcase FDGETDRVSTAT:\n\t\toutparam = &drive_state[drive];\n\t\tbreak;\n\tcase FDRESET:\n\t\treturn user_reset_fdc(drive, (int)param, true);\n\tcase FDGETFDCSTAT:\n\t\toutparam = &fdc_state[FDC(drive)];\n\t\tbreak;\n\tcase FDWERRORCLR:\n\t\tmemset(&write_errors[drive], 0, sizeof(write_errors[drive]));\n\t\treturn 0;\n\tcase FDWERRORGET:\n\t\toutparam = &write_errors[drive];\n\t\tbreak;\n\tcase FDRAWCMD:\n\t\tif (type)\n\t\t\treturn -EINVAL;\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tset_floppy(drive);\n\t\ti = raw_cmd_ioctl(cmd, (void __user *)param);\n\t\tif (i == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\treturn i;\n\tcase FDTWADDLE:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\ttwaddle(current_fdc, current_drive);\n\t\tprocess_fd_request();\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\treturn fd_copyout((void __user *)param, outparam, size);\n\n\treturn 0;\n}\n\nstatic int fd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t     unsigned int cmd, unsigned long param)\n{\n\tint ret;\n\n\tmutex_lock(&floppy_mutex);\n\tret = fd_locked_ioctl(bdev, mode, cmd, param);\n\tmutex_unlock(&floppy_mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_floppy_drive_params {\n\tchar\t\tcmos;\n\tcompat_ulong_t\tmax_dtr;\n\tcompat_ulong_t\thlt;\n\tcompat_ulong_t\thut;\n\tcompat_ulong_t\tsrt;\n\tcompat_ulong_t\tspinup;\n\tcompat_ulong_t\tspindown;\n\tunsigned char\tspindown_offset;\n\tunsigned char\tselect_delay;\n\tunsigned char\trps;\n\tunsigned char\ttracks;\n\tcompat_ulong_t\ttimeout;\n\tunsigned char\tinterleave_sect;\n\tstruct floppy_max_errors max_errors;\n\tchar\t\tflags;\n\tchar\t\tread_track;\n\tshort\t\tautodetect[FD_AUTODETECT_SIZE];\n\tcompat_int_t\tcheckfreq;\n\tcompat_int_t\tnative_format;\n};\n\nstruct compat_floppy_drive_struct {\n\tsigned char\tflags;\n\tcompat_ulong_t\tspinup_date;\n\tcompat_ulong_t\tselect_date;\n\tcompat_ulong_t\tfirst_read_date;\n\tshort\t\tprobed_format;\n\tshort\t\ttrack;\n\tshort\t\tmaxblock;\n\tshort\t\tmaxtrack;\n\tcompat_int_t\tgeneration;\n\tcompat_int_t\tkeep_data;\n\tcompat_int_t\tfd_ref;\n\tcompat_int_t\tfd_device;\n\tcompat_int_t\tlast_checked;\n\tcompat_caddr_t dmabuf;\n\tcompat_int_t\tbufblocks;\n};\n\nstruct compat_floppy_fdc_state {\n\tcompat_int_t\tspec1;\n\tcompat_int_t\tspec2;\n\tcompat_int_t\tdtr;\n\tunsigned char\tversion;\n\tunsigned char\tdor;\n\tcompat_ulong_t\taddress;\n\tunsigned int\trawcmd:2;\n\tunsigned int\treset:1;\n\tunsigned int\tneed_configure:1;\n\tunsigned int\tperp_mode:2;\n\tunsigned int\thas_fifo:1;\n\tunsigned int\tdriver_version;\n\tunsigned char\ttrack[4];\n};\n\nstruct compat_floppy_write_errors {\n\tunsigned int\twrite_errors;\n\tcompat_ulong_t\tfirst_error_sector;\n\tcompat_int_t\tfirst_error_generation;\n\tcompat_ulong_t\tlast_error_sector;\n\tcompat_int_t\tlast_error_generation;\n\tcompat_uint_t\tbadness;\n};\n\n#define FDSETPRM32 _IOW(2, 0x42, struct compat_floppy_struct)\n#define FDDEFPRM32 _IOW(2, 0x43, struct compat_floppy_struct)\n#define FDSETDRVPRM32 _IOW(2, 0x90, struct compat_floppy_drive_params)\n#define FDGETDRVPRM32 _IOR(2, 0x11, struct compat_floppy_drive_params)\n#define FDGETDRVSTAT32 _IOR(2, 0x12, struct compat_floppy_drive_struct)\n#define FDPOLLDRVSTAT32 _IOR(2, 0x13, struct compat_floppy_drive_struct)\n#define FDGETFDCSTAT32 _IOR(2, 0x15, struct compat_floppy_fdc_state)\n#define FDWERRORGET32  _IOR(2, 0x17, struct compat_floppy_write_errors)\n\nstatic int compat_set_geometry(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    struct compat_floppy_struct __user *arg)\n{\n\tstruct floppy_struct v;\n\tint drive, type;\n\tint err;\n\n\tBUILD_BUG_ON(offsetof(struct floppy_struct, name) !=\n\t\t     offsetof(struct compat_floppy_struct, name));\n\n\tif (!(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL)))\n\t\treturn -EPERM;\n\n\tmemset(&v, 0, sizeof(struct floppy_struct));\n\tif (copy_from_user(&v, arg, offsetof(struct floppy_struct, name)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&floppy_mutex);\n\tdrive = (long)bdev->bd_disk->private_data;\n\ttype = ITYPE(drive_state[drive].fd_device);\n\terr = set_geometry(cmd == FDSETPRM32 ? FDSETPRM : FDDEFPRM,\n\t\t\t&v, drive, type, bdev);\n\tmutex_unlock(&floppy_mutex);\n\treturn err;\n}\n\nstatic int compat_get_prm(int drive,\n\t\t\t  struct compat_floppy_struct __user *arg)\n{\n\tstruct compat_floppy_struct v;\n\tstruct floppy_struct *p;\n\tint err;\n\n\tmemset(&v, 0, sizeof(v));\n\tmutex_lock(&floppy_mutex);\n\terr = get_floppy_geometry(drive, ITYPE(drive_state[drive].fd_device),\n\t\t\t\t  &p);\n\tif (err) {\n\t\tmutex_unlock(&floppy_mutex);\n\t\treturn err;\n\t}\n\tmemcpy(&v, p, offsetof(struct floppy_struct, name));\n\tmutex_unlock(&floppy_mutex);\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_setdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&v, arg, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\tif (!valid_floppy_drive_params(v.autodetect, v.native_format))\n\t\treturn -EINVAL;\n\tmutex_lock(&floppy_mutex);\n\tdrive_params[drive].cmos = v.cmos;\n\tdrive_params[drive].max_dtr = v.max_dtr;\n\tdrive_params[drive].hlt = v.hlt;\n\tdrive_params[drive].hut = v.hut;\n\tdrive_params[drive].srt = v.srt;\n\tdrive_params[drive].spinup = v.spinup;\n\tdrive_params[drive].spindown = v.spindown;\n\tdrive_params[drive].spindown_offset = v.spindown_offset;\n\tdrive_params[drive].select_delay = v.select_delay;\n\tdrive_params[drive].rps = v.rps;\n\tdrive_params[drive].tracks = v.tracks;\n\tdrive_params[drive].timeout = v.timeout;\n\tdrive_params[drive].interleave_sect = v.interleave_sect;\n\tdrive_params[drive].max_errors = v.max_errors;\n\tdrive_params[drive].flags = v.flags;\n\tdrive_params[drive].read_track = v.read_track;\n\tmemcpy(drive_params[drive].autodetect, v.autodetect,\n\t       sizeof(v.autodetect));\n\tdrive_params[drive].checkfreq = v.checkfreq;\n\tdrive_params[drive].native_format = v.native_format;\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\n}\n\nstatic int compat_getdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_params));\n\tmutex_lock(&floppy_mutex);\n\tv.cmos = drive_params[drive].cmos;\n\tv.max_dtr = drive_params[drive].max_dtr;\n\tv.hlt = drive_params[drive].hlt;\n\tv.hut = drive_params[drive].hut;\n\tv.srt = drive_params[drive].srt;\n\tv.spinup = drive_params[drive].spinup;\n\tv.spindown = drive_params[drive].spindown;\n\tv.spindown_offset = drive_params[drive].spindown_offset;\n\tv.select_delay = drive_params[drive].select_delay;\n\tv.rps = drive_params[drive].rps;\n\tv.tracks = drive_params[drive].tracks;\n\tv.timeout = drive_params[drive].timeout;\n\tv.interleave_sect = drive_params[drive].interleave_sect;\n\tv.max_errors = drive_params[drive].max_errors;\n\tv.flags = drive_params[drive].flags;\n\tv.read_track = drive_params[drive].read_track;\n\tmemcpy(v.autodetect, drive_params[drive].autodetect,\n\t       sizeof(v.autodetect));\n\tv.checkfreq = drive_params[drive].checkfreq;\n\tv.native_format = drive_params[drive].native_format;\n\tmutex_unlock(&floppy_mutex);\n\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_getdrvstat(int drive, bool poll,\n\t\t\t    struct compat_floppy_drive_struct __user *arg)\n{\n\tstruct compat_floppy_drive_struct v;\n\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_struct));\n\tmutex_lock(&floppy_mutex);\n\n\tif (poll) {\n\t\tif (lock_fdc(drive))\n\t\t\tgoto Eintr;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\tgoto Eintr;\n\t\tprocess_fd_request();\n\t}\n\tv.spinup_date = drive_state[drive].spinup_date;\n\tv.select_date = drive_state[drive].select_date;\n\tv.first_read_date = drive_state[drive].first_read_date;\n\tv.probed_format = drive_state[drive].probed_format;\n\tv.track = drive_state[drive].track;\n\tv.maxblock = drive_state[drive].maxblock;\n\tv.maxtrack = drive_state[drive].maxtrack;\n\tv.generation = drive_state[drive].generation;\n\tv.keep_data = drive_state[drive].keep_data;\n\tv.fd_ref = drive_state[drive].fd_ref;\n\tv.fd_device = drive_state[drive].fd_device;\n\tv.last_checked = drive_state[drive].last_checked;\n\tv.dmabuf = (uintptr_t) drive_state[drive].dmabuf;\n\tv.bufblocks = drive_state[drive].bufblocks;\n\tmutex_unlock(&floppy_mutex);\n\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_drive_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\nEintr:\n\tmutex_unlock(&floppy_mutex);\n\treturn -EINTR;\n}\n\nstatic int compat_getfdcstat(int drive,\n\t\t\t    struct compat_floppy_fdc_state __user *arg)\n{\n\tstruct compat_floppy_fdc_state v32;\n\tstruct floppy_fdc_state v;\n\n\tmutex_lock(&floppy_mutex);\n\tv = fdc_state[FDC(drive)];\n\tmutex_unlock(&floppy_mutex);\n\n\tmemset(&v32, 0, sizeof(struct compat_floppy_fdc_state));\n\tv32.spec1 = v.spec1;\n\tv32.spec2 = v.spec2;\n\tv32.dtr = v.dtr;\n\tv32.version = v.version;\n\tv32.dor = v.dor;\n\tv32.address = v.address;\n\tv32.rawcmd = v.rawcmd;\n\tv32.reset = v.reset;\n\tv32.need_configure = v.need_configure;\n\tv32.perp_mode = v.perp_mode;\n\tv32.has_fifo = v.has_fifo;\n\tv32.driver_version = v.driver_version;\n\tmemcpy(v32.track, v.track, 4);\n\tif (copy_to_user(arg, &v32, sizeof(struct compat_floppy_fdc_state)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_werrorget(int drive,\n\t\t\t    struct compat_floppy_write_errors __user *arg)\n{\n\tstruct compat_floppy_write_errors v32;\n\tstruct floppy_write_errors v;\n\n\tmemset(&v32, 0, sizeof(struct compat_floppy_write_errors));\n\tmutex_lock(&floppy_mutex);\n\tv = write_errors[drive];\n\tmutex_unlock(&floppy_mutex);\n\tv32.write_errors = v.write_errors;\n\tv32.first_error_sector = v.first_error_sector;\n\tv32.first_error_generation = v.first_error_generation;\n\tv32.last_error_sector = v.last_error_sector;\n\tv32.last_error_generation = v.last_error_generation;\n\tv32.badness = v.badness;\n\tif (copy_to_user(arg, &v32, sizeof(struct compat_floppy_write_errors)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int fd_compat_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tswitch (cmd) {\n\tcase CDROMEJECT: /* CD-ROM eject */\n\tcase 0x6470:\t /* SunOS floppy eject */\n\n\tcase FDMSGON:\n\tcase FDMSGOFF:\n\tcase FDSETEMSGTRESH:\n\tcase FDFLUSH:\n\tcase FDWERRORCLR:\n\tcase FDEJECT:\n\tcase FDCLRPRM:\n\tcase FDFMTBEG:\n\tcase FDRESET:\n\tcase FDTWADDLE:\n\t\treturn fd_ioctl(bdev, mode, cmd, param);\n\tcase FDSETMAXERRS:\n\tcase FDGETMAXERRS:\n\tcase FDGETDRVTYP:\n\tcase FDFMTEND:\n\tcase FDFMTTRK:\n\tcase FDRAWCMD:\n\t\treturn fd_ioctl(bdev, mode, cmd,\n\t\t\t\t(unsigned long)compat_ptr(param));\n\tcase FDSETPRM32:\n\tcase FDDEFPRM32:\n\t\treturn compat_set_geometry(bdev, mode, cmd, compat_ptr(param));\n\tcase FDGETPRM32:\n\t\treturn compat_get_prm(drive, compat_ptr(param));\n\tcase FDSETDRVPRM32:\n\t\treturn compat_setdrvprm(drive, compat_ptr(param));\n\tcase FDGETDRVPRM32:\n\t\treturn compat_getdrvprm(drive, compat_ptr(param));\n\tcase FDPOLLDRVSTAT32:\n\t\treturn compat_getdrvstat(drive, true, compat_ptr(param));\n\tcase FDGETDRVSTAT32:\n\t\treturn compat_getdrvstat(drive, false, compat_ptr(param));\n\tcase FDGETFDCSTAT32:\n\t\treturn compat_getfdcstat(drive, compat_ptr(param));\n\tcase FDWERRORGET32:\n\t\treturn compat_werrorget(drive, compat_ptr(param));\n\t}\n\treturn -EINVAL;\n}\n#endif\n\nstatic void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\n\t/* read drive info out of physical CMOS */\n\tdrive = 0;\n\tif (!drive_params[drive].cmos)\n\t\tdrive_params[drive].cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!drive_params[drive].cmos)\n\t\tdrive_params[drive].cmos = FLOPPY1_TYPE;\n\n\t/* FIXME: additional physical CMOS drive detection should go here */\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = drive_params[drive].cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tchar temparea[32];\n\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsnprintf(temparea, sizeof(temparea),\n\t\t\t\t \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\tdrive_params[drive] = *params;\n\t}\n\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}\n\nstatic void floppy_release(struct gendisk *disk, fmode_t mode)\n{\n\tint drive = (long)disk->private_data;\n\n\tmutex_lock(&floppy_mutex);\n\tmutex_lock(&open_lock);\n\tif (!drive_state[drive].fd_ref--) {\n\t\tDPRINT(\"floppy_release with fd_ref == 0\");\n\t\tdrive_state[drive].fd_ref = 0;\n\t}\n\tif (!drive_state[drive].fd_ref)\n\t\topened_bdev[drive] = NULL;\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n}\n\n/*\n * floppy_open check for aliasing (/dev/fd0 can be the same as\n * /dev/PS0 etc), and disallows simultaneous access to the same\n * drive with different device numbers.\n */\nstatic int floppy_open(struct block_device *bdev, fmode_t mode)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint old_dev, new_dev;\n\tint try;\n\tint res = -EBUSY;\n\tchar *tmp;\n\n\tmutex_lock(&floppy_mutex);\n\tmutex_lock(&open_lock);\n\told_dev = drive_state[drive].fd_device;\n\tif (opened_bdev[drive] && opened_bdev[drive] != bdev)\n\t\tgoto out2;\n\n\tif (!drive_state[drive].fd_ref && (drive_params[drive].flags & FD_BROKEN_DCL)) {\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t}\n\n\tdrive_state[drive].fd_ref++;\n\n\topened_bdev[drive] = bdev;\n\n\tres = -ENXIO;\n\n\tif (!floppy_track_buffer) {\n\t\t/* if opening an ED drive, reserve a big buffer,\n\t\t * else reserve a small one */\n\t\tif ((drive_params[drive].cmos == 6) || (drive_params[drive].cmos == 5))\n\t\t\ttry = 64;\t/* Only 48 actually useful */\n\t\telse\n\t\t\ttry = 32;\t/* Only 24 actually useful */\n\n\t\ttmp = (char *)fd_dma_mem_alloc(1024 * try);\n\t\tif (!tmp && !floppy_track_buffer) {\n\t\t\ttry >>= 1;\t/* buffer only one side */\n\t\t\tINFBOUND(try, 16);\n\t\t\ttmp = (char *)fd_dma_mem_alloc(1024 * try);\n\t\t}\n\t\tif (!tmp && !floppy_track_buffer)\n\t\t\tfallback_on_nodma_alloc(&tmp, 2048 * try);\n\t\tif (!tmp && !floppy_track_buffer) {\n\t\t\tDPRINT(\"Unable to allocate DMA memory\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (floppy_track_buffer) {\n\t\t\tif (tmp)\n\t\t\t\tfd_dma_mem_free((unsigned long)tmp, try * 1024);\n\t\t} else {\n\t\t\tbuffer_min = buffer_max = -1;\n\t\t\tfloppy_track_buffer = tmp;\n\t\t\tmax_buffer_sectors = try;\n\t\t}\n\t}\n\n\tnew_dev = MINOR(bdev->bd_dev);\n\tdrive_state[drive].fd_device = new_dev;\n\tset_capacity(disks[drive][ITYPE(new_dev)], floppy_sizes[new_dev]);\n\tif (old_dev != -1 && old_dev != new_dev) {\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t}\n\n\tif (fdc_state[FDC(drive)].rawcmd == 1)\n\t\tfdc_state[FDC(drive)].rawcmd = 2;\n\n\tif (!(mode & FMODE_NDELAY)) {\n\t\tif (mode & (FMODE_READ|FMODE_WRITE)) {\n\t\t\tdrive_state[drive].last_checked = 0;\n\t\t\tclear_bit(FD_OPEN_SHOULD_FAIL_BIT,\n\t\t\t\t  &drive_state[drive].flags);\n\t\t\tif (bdev_check_media_change(bdev))\n\t\t\t\tfloppy_revalidate(bdev->bd_disk);\n\t\t\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags))\n\t\t\t\tgoto out;\n\t\t\tif (test_bit(FD_OPEN_SHOULD_FAIL_BIT, &drive_state[drive].flags))\n\t\t\t\tgoto out;\n\t\t}\n\t\tres = -EROFS;\n\t\tif ((mode & FMODE_WRITE) &&\n\t\t    !test_bit(FD_DISK_WRITABLE_BIT, &drive_state[drive].flags))\n\t\t\tgoto out;\n\t}\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\nout:\n\tdrive_state[drive].fd_ref--;\n\n\tif (!drive_state[drive].fd_ref)\n\t\topened_bdev[drive] = NULL;\nout2:\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n\treturn res;\n}\n\n/*\n * Check if the disk has been changed or if a change has been faked.\n */\nstatic unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tint drive = (long)disk->private_data;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t    test_bit(FD_VERIFY_BIT, &drive_state[drive].flags))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\n\tif (time_after(jiffies, drive_state[drive].last_checked + drive_params[drive].checkfreq)) {\n\t\tif (lock_fdc(drive))\n\t\t\treturn 0;\n\t\tpoll_drive(false, 0);\n\t\tprocess_fd_request();\n\t}\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t    test_bit(FD_VERIFY_BIT, &drive_state[drive].flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\treturn 0;\n}\n\n/*\n * This implements \"read block 0\" for floppy_revalidate().\n * Needed for format autodetection, checking whether there is\n * a disk in the drive, and whether that disk is writable.\n */\n\nstruct rb0_cbdata {\n\tint drive;\n\tstruct completion complete;\n};\n\nstatic void floppy_rb0_cb(struct bio *bio)\n{\n\tstruct rb0_cbdata *cbdata = (struct rb0_cbdata *)bio->bi_private;\n\tint drive = cbdata->drive;\n\n\tif (bio->bi_status) {\n\t\tpr_info(\"floppy: error %d while reading block 0\\n\",\n\t\t\tbio->bi_status);\n\t\tset_bit(FD_OPEN_SHOULD_FAIL_BIT, &drive_state[drive].flags);\n\t}\n\tcomplete(&cbdata->complete);\n}\n\nstatic int __floppy_read_block_0(struct block_device *bdev, int drive)\n{\n\tstruct bio bio;\n\tstruct bio_vec bio_vec;\n\tstruct page *page;\n\tstruct rb0_cbdata cbdata;\n\n\tpage = alloc_page(GFP_NOIO);\n\tif (!page) {\n\t\tprocess_fd_request();\n\t\treturn -ENOMEM;\n\t}\n\n\tcbdata.drive = drive;\n\n\tbio_init(&bio, bdev, &bio_vec, 1, REQ_OP_READ);\n\tbio_add_page(&bio, page, block_size(bdev), 0);\n\n\tbio.bi_iter.bi_sector = 0;\n\tbio.bi_flags |= (1 << BIO_QUIET);\n\tbio.bi_private = &cbdata;\n\tbio.bi_end_io = floppy_rb0_cb;\n\n\tinit_completion(&cbdata.complete);\n\n\tsubmit_bio(&bio);\n\tprocess_fd_request();\n\n\twait_for_completion(&cbdata.complete);\n\n\t__free_page(page);\n\n\treturn 0;\n}\n\n/* revalidate the floppy disk, i.e. trigger format autodetection by reading\n * the bootblock (block 0). \"Autodetection\" is also needed to check whether\n * there is a disk in the drive at all... Thus we also do it for fixed\n * geometry formats */\nstatic int floppy_revalidate(struct gendisk *disk)\n{\n\tint drive = (long)disk->private_data;\n\tint cf;\n\tint res = 0;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t    test_bit(FD_VERIFY_BIT, &drive_state[drive].flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive)) {\n\t\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t\t \"VFS: revalidate called on non-open device.\\n\"))\n\t\t\treturn -EFAULT;\n\n\t\tres = lock_fdc(drive);\n\t\tif (res)\n\t\t\treturn res;\n\t\tcf = (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t\t      test_bit(FD_VERIFY_BIT, &drive_state[drive].flags));\n\t\tif (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {\n\t\t\tprocess_fd_request();\t/*already done by another thread */\n\t\t\treturn 0;\n\t\t}\n\t\tdrive_state[drive].maxblock = 0;\n\t\tdrive_state[drive].maxtrack = 0;\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t\tclear_bit(drive, &fake_change);\n\t\tclear_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tif (cf)\n\t\t\tdrive_state[drive].generation++;\n\t\tif (drive_no_geom(drive)) {\n\t\t\t/* auto-sensing */\n\t\t\tres = __floppy_read_block_0(opened_bdev[drive], drive);\n\t\t} else {\n\t\t\tif (cf)\n\t\t\t\tpoll_drive(false, FD_RAW_NEED_DISK);\n\t\t\tprocess_fd_request();\n\t\t}\n\t}\n\tset_capacity(disk, floppy_sizes[drive_state[drive].fd_device]);\n\treturn res;\n}\n\nstatic const struct block_device_operations floppy_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= floppy_open,\n\t.release\t\t= floppy_release,\n\t.ioctl\t\t\t= fd_ioctl,\n\t.getgeo\t\t\t= fd_getgeo,\n\t.check_events\t\t= floppy_check_events,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= fd_compat_ioctl,\n#endif\n};\n\n/*\n * Floppy Driver initialization\n * =============================\n */\n\n/* Determine the floppy disk controller type */\n/* This routine was written by David C. Niemi */\nstatic char __init get_fdc_version(int fdc)\n{\n\tint r;\n\n\toutput_byte(fdc, FD_DUMPREGS);\t/* 82072 and better know DUMPREGS */\n\tif (fdc_state[fdc].reset)\n\t\treturn FDC_NONE;\n\tr = result(fdc);\n\tif (r <= 0x00)\n\t\treturn FDC_NONE;\t/* No FDC present ??? */\n\tif ((r == 1) && (reply_buffer[ST0] == 0x80)) {\n\t\tpr_info(\"FDC %d is an 8272A\\n\", fdc);\n\t\treturn FDC_8272A;\t/* 8272a/765 don't know DUMPREGS */\n\t}\n\tif (r != 10) {\n\t\tpr_info(\"FDC %d init: DUMPREGS: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\n\tif (!fdc_configure(fdc)) {\n\t\tpr_info(\"FDC %d is an 82072\\n\", fdc);\n\t\treturn FDC_82072;\t/* 82072 doesn't know CONFIGURE */\n\t}\n\n\toutput_byte(fdc, FD_PERPENDICULAR);\n\tif (need_more_output(fdc) == MORE_OUTPUT) {\n\t\toutput_byte(fdc, 0);\n\t} else {\n\t\tpr_info(\"FDC %d is an 82072A\\n\", fdc);\n\t\treturn FDC_82072A;\t/* 82072A as found on Sparcs. */\n\t}\n\n\toutput_byte(fdc, FD_UNLOCK);\n\tr = result(fdc);\n\tif ((r == 1) && (reply_buffer[ST0] == 0x80)) {\n\t\tpr_info(\"FDC %d is a pre-1991 82077\\n\", fdc);\n\t\treturn FDC_82077_ORIG;\t/* Pre-1991 82077, doesn't know\n\t\t\t\t\t * LOCK/UNLOCK */\n\t}\n\tif ((r != 1) || (reply_buffer[ST0] != 0x00)) {\n\t\tpr_info(\"FDC %d init: UNLOCK: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\toutput_byte(fdc, FD_PARTID);\n\tr = result(fdc);\n\tif (r != 1) {\n\t\tpr_info(\"FDC %d init: PARTID: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\tif (reply_buffer[ST0] == 0x80) {\n\t\tpr_info(\"FDC %d is a post-1991 82077\\n\", fdc);\n\t\treturn FDC_82077;\t/* Revised 82077AA passes all the tests */\n\t}\n\tswitch (reply_buffer[ST0] >> 5) {\n\tcase 0x0:\n\t\t/* Either a 82078-1 or a 82078SL running at 5Volt */\n\t\tpr_info(\"FDC %d is an 82078.\\n\", fdc);\n\t\treturn FDC_82078;\n\tcase 0x1:\n\t\tpr_info(\"FDC %d is a 44pin 82078\\n\", fdc);\n\t\treturn FDC_82078;\n\tcase 0x2:\n\t\tpr_info(\"FDC %d is a S82078B\\n\", fdc);\n\t\treturn FDC_S82078B;\n\tcase 0x3:\n\t\tpr_info(\"FDC %d is a National Semiconductor PC87306\\n\", fdc);\n\t\treturn FDC_87306;\n\tdefault:\n\t\tpr_info(\"FDC %d init: 82078 variant with unknown PARTID=%d.\\n\",\n\t\t\tfdc, reply_buffer[ST0] >> 5);\n\t\treturn FDC_82078_UNKN;\n\t}\n}\t\t\t\t/* get_fdc_version */\n\n/* lilo configuration */\n\nstatic void __init floppy_set_flags(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param)\n\t\t\tdefault_drive_params[i].params.flags |= param2;\n\t\telse\n\t\t\tdefault_drive_params[i].params.flags &= ~param2;\n\t}\n\tDPRINT(\"%s flag 0x%x\\n\", param2 ? \"Setting\" : \"Clearing\", param);\n}\n\nstatic void __init daring(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param) {\n\t\t\tdefault_drive_params[i].params.select_delay = 0;\n\t\t\tdefault_drive_params[i].params.flags |=\n\t\t\t    FD_SILENT_DCL_CLEAR;\n\t\t} else {\n\t\t\tdefault_drive_params[i].params.select_delay =\n\t\t\t    2 * HZ / 100;\n\t\t\tdefault_drive_params[i].params.flags &=\n\t\t\t    ~FD_SILENT_DCL_CLEAR;\n\t\t}\n\t}\n\tDPRINT(\"Assuming %s floppy hardware\\n\", param ? \"standard\" : \"broken\");\n}\n\nstatic void __init set_cmos(int *ints, int dummy, int dummy2)\n{\n\tint current_drive = 0;\n\n\tif (ints[0] != 2) {\n\t\tDPRINT(\"wrong number of parameters for CMOS\\n\");\n\t\treturn;\n\t}\n\tcurrent_drive = ints[1];\n\tif (current_drive < 0 || current_drive >= 8) {\n\t\tDPRINT(\"bad drive for set_cmos\\n\");\n\t\treturn;\n\t}\n#if N_FDC > 1\n\tif (current_drive >= 4 && !FDC2)\n\t\tFDC2 = 0x370;\n#endif\n\tdrive_params[current_drive].cmos = ints[2];\n\tDPRINT(\"setting CMOS code to %d\\n\", ints[2]);\n}\n\nstatic struct param_table {\n\tconst char *name;\n\tvoid (*fn) (int *ints, int param, int param2);\n\tint *var;\n\tint def_param;\n\tint param2;\n} config_params[] __initdata = {\n\t{\"allowed_drive_mask\", NULL, &allowed_drive_mask, 0xff, 0}, /* obsolete */\n\t{\"all_drives\", NULL, &allowed_drive_mask, 0xff, 0},\t/* obsolete */\n\t{\"asus_pci\", NULL, &allowed_drive_mask, 0x33, 0},\n\t{\"irq\", NULL, &FLOPPY_IRQ, 6, 0},\n\t{\"dma\", NULL, &FLOPPY_DMA, 2, 0},\n\t{\"daring\", daring, NULL, 1, 0},\n#if N_FDC > 1\n\t{\"two_fdc\", NULL, &FDC2, 0x370, 0},\n\t{\"one_fdc\", NULL, &FDC2, 0, 0},\n#endif\n\t{\"thinkpad\", floppy_set_flags, NULL, 1, FD_INVERTED_DCL},\n\t{\"broken_dcl\", floppy_set_flags, NULL, 1, FD_BROKEN_DCL},\n\t{\"messages\", floppy_set_flags, NULL, 1, FTD_MSG},\n\t{\"silent_dcl_clear\", floppy_set_flags, NULL, 1, FD_SILENT_DCL_CLEAR},\n\t{\"debug\", floppy_set_flags, NULL, 1, FD_DEBUG},\n\t{\"nodma\", NULL, &can_use_virtual_dma, 1, 0},\n\t{\"omnibook\", NULL, &can_use_virtual_dma, 1, 0},\n\t{\"yesdma\", NULL, &can_use_virtual_dma, 0, 0},\n\t{\"fifo_depth\", NULL, &fifo_depth, 0xa, 0},\n\t{\"nofifo\", NULL, &no_fifo, 0x20, 0},\n\t{\"usefifo\", NULL, &no_fifo, 0, 0},\n\t{\"cmos\", set_cmos, NULL, 0, 0},\n\t{\"slow\", NULL, &slow_floppy, 1, 0},\n\t{\"unexpected_interrupts\", NULL, &print_unex, 1, 0},\n\t{\"no_unexpected_interrupts\", NULL, &print_unex, 0, 0},\n\t{\"L40SX\", NULL, &print_unex, 0, 0}\n\n\tEXTRA_FLOPPY_PARAMS\n};\n\nstatic int __init floppy_setup(char *str)\n{\n\tint i;\n\tint param;\n\tint ints[11];\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\tif (str) {\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++) {\n\t\t\tif (strcmp(str, config_params[i].name) == 0) {\n\t\t\t\tif (ints[0])\n\t\t\t\t\tparam = ints[1];\n\t\t\t\telse\n\t\t\t\t\tparam = config_params[i].def_param;\n\t\t\t\tif (config_params[i].fn)\n\t\t\t\t\tconfig_params[i].fn(ints, param,\n\t\t\t\t\t\t\t    config_params[i].\n\t\t\t\t\t\t\t    param2);\n\t\t\t\tif (config_params[i].var) {\n\t\t\t\t\tDPRINT(\"%s=%d\\n\", str, param);\n\t\t\t\t\t*config_params[i].var = param;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (str) {\n\t\tDPRINT(\"unknown floppy option [%s]\\n\", str);\n\n\t\tDPRINT(\"allowed options are:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++)\n\t\t\tpr_cont(\" %s\", config_params[i].name);\n\t\tpr_cont(\"\\n\");\n\t} else\n\t\tDPRINT(\"botched floppy option\\n\");\n\tDPRINT(\"Read Documentation/admin-guide/blockdev/floppy.rst\\n\");\n\treturn 0;\n}\n\nstatic int have_no_fdc = -ENODEV;\n\nstatic ssize_t floppy_cmos_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *p = to_platform_device(dev);\n\tint drive;\n\n\tdrive = p->id;\n\treturn sprintf(buf, \"%X\\n\", drive_params[drive].cmos);\n}\n\nstatic DEVICE_ATTR(cmos, 0444, floppy_cmos_show, NULL);\n\nstatic struct attribute *floppy_dev_attrs[] = {\n\t&dev_attr_cmos.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(floppy_dev);\n\nstatic void floppy_device_release(struct device *dev)\n{\n}\n\nstatic int floppy_resume(struct device *dev)\n{\n\tint fdc;\n\tint saved_drive;\n\n\tsaved_drive = current_drive;\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (fdc_state[fdc].address != -1)\n\t\t\tuser_reset_fdc(REVDRIVE(fdc, 0), FD_RESET_ALWAYS, false);\n\tset_fdc(saved_drive);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops floppy_pm_ops = {\n\t.resume = floppy_resume,\n\t.restore = floppy_resume,\n};\n\nstatic struct platform_driver floppy_driver = {\n\t.driver = {\n\t\t   .name = \"floppy\",\n\t\t   .pm = &floppy_pm_ops,\n\t},\n};\n\nstatic const struct blk_mq_ops floppy_mq_ops = {\n\t.queue_rq = floppy_queue_rq,\n};\n\nstatic struct platform_device floppy_device[N_DRIVE];\nstatic bool registered[N_DRIVE];\n\nstatic bool floppy_available(int drive)\n{\n\tif (!(allowed_drive_mask & (1 << drive)))\n\t\treturn false;\n\tif (fdc_state[FDC(drive)].version == FDC_NONE)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int floppy_alloc_disk(unsigned int drive, unsigned int type)\n{\n\tstruct gendisk *disk;\n\n\tdisk = blk_mq_alloc_disk(&tag_sets[drive], NULL);\n\tif (IS_ERR(disk))\n\t\treturn PTR_ERR(disk);\n\n\tblk_queue_max_hw_sectors(disk->queue, 64);\n\tdisk->major = FLOPPY_MAJOR;\n\tdisk->first_minor = TOMINOR(drive) | (type << 2);\n\tdisk->minors = 1;\n\tdisk->fops = &floppy_fops;\n\tdisk->flags |= GENHD_FL_NO_PART;\n\tdisk->events = DISK_EVENT_MEDIA_CHANGE;\n\tif (type)\n\t\tsprintf(disk->disk_name, \"fd%d_type%d\", drive, type);\n\telse\n\t\tsprintf(disk->disk_name, \"fd%d\", drive);\n\t/* to be cleaned up... */\n\tdisk->private_data = (void *)(long)drive;\n\tdisk->flags |= GENHD_FL_REMOVABLE;\n\n\tdisks[drive][type] = disk;\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(floppy_probe_lock);\n\nstatic void floppy_probe(dev_t dev)\n{\n\tunsigned int drive = (MINOR(dev) & 3) | ((MINOR(dev) & 0x80) >> 5);\n\tunsigned int type = (MINOR(dev) >> 2) & 0x1f;\n\n\tif (drive >= N_DRIVE || !floppy_available(drive) ||\n\t    type >= ARRAY_SIZE(floppy_type))\n\t\treturn;\n\n\tmutex_lock(&floppy_probe_lock);\n\tif (disks[drive][type])\n\t\tgoto out;\n\tif (floppy_alloc_disk(drive, type))\n\t\tgoto out;\n\tif (add_disk(disks[drive][type]))\n\t\tgoto cleanup_disk;\nout:\n\tmutex_unlock(&floppy_probe_lock);\n\treturn;\n\ncleanup_disk:\n\tblk_cleanup_disk(disks[drive][type]);\n\tdisks[drive][type] = NULL;\n\tmutex_unlock(&floppy_probe_lock);\n}\n\nstatic int __init do_floppy_init(void)\n{\n\tint i, unit, drive, err;\n\n\tset_debugt();\n\tinterruptjiffies = resultjiffies = jiffies;\n\n#if defined(CONFIG_PPC)\n\tif (check_legacy_ioport(FDC1))\n\t\treturn -ENODEV;\n#endif\n\n\traw_cmd = NULL;\n\n\tfloppy_wq = alloc_ordered_workqueue(\"floppy\", 0);\n\tif (!floppy_wq)\n\t\treturn -ENOMEM;\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tmemset(&tag_sets[drive], 0, sizeof(tag_sets[drive]));\n\t\ttag_sets[drive].ops = &floppy_mq_ops;\n\t\ttag_sets[drive].nr_hw_queues = 1;\n\t\ttag_sets[drive].nr_maps = 1;\n\t\ttag_sets[drive].queue_depth = 2;\n\t\ttag_sets[drive].numa_node = NUMA_NO_NODE;\n\t\ttag_sets[drive].flags = BLK_MQ_F_SHOULD_MERGE;\n\t\terr = blk_mq_alloc_tag_set(&tag_sets[drive]);\n\t\tif (err)\n\t\t\tgoto out_put_disk;\n\n\t\terr = floppy_alloc_disk(drive, 0);\n\t\tif (err)\n\t\t\tgoto out_put_disk;\n\n\t\ttimer_setup(&motor_off_timer[drive], motor_off_callback, 0);\n\t}\n\n\terr = __register_blkdev(FLOPPY_MAJOR, \"fd\", floppy_probe);\n\tif (err)\n\t\tgoto out_put_disk;\n\n\terr = platform_driver_register(&floppy_driver);\n\tif (err)\n\t\tgoto out_unreg_blkdev;\n\n\tfor (i = 0; i < 256; i++)\n\t\tif (ITYPE(i))\n\t\t\tfloppy_sizes[i] = floppy_type[ITYPE(i)].size;\n\t\telse\n\t\t\tfloppy_sizes[i] = MAX_DISK_SIZE << 1;\n\n\treschedule_timeout(MAXTIMEOUT, \"floppy init\");\n\tconfig_types();\n\n\tfor (i = 0; i < N_FDC; i++) {\n\t\tmemset(&fdc_state[i], 0, sizeof(*fdc_state));\n\t\tfdc_state[i].dtr = -1;\n\t\tfdc_state[i].dor = 0x4;\n#if defined(__sparc__) || defined(__mc68000__)\n\t/*sparcs/sun3x don't have a DOR reset which we can fall back on to */\n#ifdef __mc68000__\n\t\tif (MACH_IS_SUN3X)\n#endif\n\t\t\tfdc_state[i].version = FDC_82072A;\n#endif\n\t}\n\n\tuse_virtual_dma = can_use_virtual_dma & 1;\n\tfdc_state[0].address = FDC1;\n\tif (fdc_state[0].address == -1) {\n\t\tcancel_delayed_work(&fd_timeout);\n\t\terr = -ENODEV;\n\t\tgoto out_unreg_driver;\n\t}\n#if N_FDC > 1\n\tfdc_state[1].address = FDC2;\n#endif\n\n\tcurrent_fdc = 0;\t/* reset fdc in case of unexpected interrupt */\n\terr = floppy_grab_irq_and_dma();\n\tif (err) {\n\t\tcancel_delayed_work(&fd_timeout);\n\t\terr = -EBUSY;\n\t\tgoto out_unreg_driver;\n\t}\n\n\t/* initialise drive state */\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tmemset(&drive_state[drive], 0, sizeof(drive_state[drive]));\n\t\tmemset(&write_errors[drive], 0, sizeof(write_errors[drive]));\n\t\tset_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tdrive_state[drive].fd_device = -1;\n\t\tfloppy_track_buffer = NULL;\n\t\tmax_buffer_sectors = 0;\n\t}\n\t/*\n\t * Small 10 msec delay to let through any interrupt that\n\t * initialization might have triggered, to not\n\t * confuse detection:\n\t */\n\tmsleep(10);\n\n\tfor (i = 0; i < N_FDC; i++) {\n\t\tfdc_state[i].driver_version = FD_DRIVER_VERSION;\n\t\tfor (unit = 0; unit < 4; unit++)\n\t\t\tfdc_state[i].track[unit] = 0;\n\t\tif (fdc_state[i].address == -1)\n\t\t\tcontinue;\n\t\tfdc_state[i].rawcmd = 2;\n\t\tif (user_reset_fdc(REVDRIVE(i, 0), FD_RESET_ALWAYS, false)) {\n\t\t\t/* free ioports reserved by floppy_grab_irq_and_dma() */\n\t\t\tfloppy_release_regions(i);\n\t\t\tfdc_state[i].address = -1;\n\t\t\tfdc_state[i].version = FDC_NONE;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Try to determine the floppy controller type */\n\t\tfdc_state[i].version = get_fdc_version(i);\n\t\tif (fdc_state[i].version == FDC_NONE) {\n\t\t\t/* free ioports reserved by floppy_grab_irq_and_dma() */\n\t\t\tfloppy_release_regions(i);\n\t\t\tfdc_state[i].address = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (can_use_virtual_dma == 2 &&\n\t\t    fdc_state[i].version < FDC_82072A)\n\t\t\tcan_use_virtual_dma = 0;\n\n\t\thave_no_fdc = 0;\n\t\t/* Not all FDCs seem to be able to handle the version command\n\t\t * properly, so force a reset for the standard FDC clones,\n\t\t * to avoid interrupt garbage.\n\t\t */\n\t\tuser_reset_fdc(REVDRIVE(i, 0), FD_RESET_ALWAYS, false);\n\t}\n\tcurrent_fdc = 0;\n\tcancel_delayed_work(&fd_timeout);\n\tcurrent_drive = 0;\n\tinitialized = true;\n\tif (have_no_fdc) {\n\t\tDPRINT(\"no floppy controllers found\\n\");\n\t\terr = have_no_fdc;\n\t\tgoto out_release_dma;\n\t}\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (!floppy_available(drive))\n\t\t\tcontinue;\n\n\t\tfloppy_device[drive].name = floppy_device_name;\n\t\tfloppy_device[drive].id = drive;\n\t\tfloppy_device[drive].dev.release = floppy_device_release;\n\t\tfloppy_device[drive].dev.groups = floppy_dev_groups;\n\n\t\terr = platform_device_register(&floppy_device[drive]);\n\t\tif (err)\n\t\t\tgoto out_remove_drives;\n\n\t\tregistered[drive] = true;\n\n\t\terr = device_add_disk(&floppy_device[drive].dev,\n\t\t\t\t      disks[drive][0], NULL);\n\t\tif (err)\n\t\t\tgoto out_remove_drives;\n\t}\n\n\treturn 0;\n\nout_remove_drives:\n\twhile (drive--) {\n\t\tif (floppy_available(drive)) {\n\t\t\tdel_gendisk(disks[drive][0]);\n\t\t\tif (registered[drive])\n\t\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t}\nout_release_dma:\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\nout_unreg_driver:\n\tplatform_driver_unregister(&floppy_driver);\nout_unreg_blkdev:\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\nout_put_disk:\n\tdestroy_workqueue(floppy_wq);\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (!disks[drive][0])\n\t\t\tbreak;\n\t\tdel_timer_sync(&motor_off_timer[drive]);\n\t\tblk_cleanup_disk(disks[drive][0]);\n\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\t}\n\treturn err;\n}\n\n#ifndef MODULE\nstatic __init void floppy_async_init(void *data, async_cookie_t cookie)\n{\n\tdo_floppy_init();\n}\n#endif\n\nstatic int __init floppy_init(void)\n{\n#ifdef MODULE\n\treturn do_floppy_init();\n#else\n\t/* Don't hold up the bootup by the floppy initialization */\n\tasync_schedule(floppy_async_init, NULL);\n\treturn 0;\n#endif\n}\n\nstatic const struct io_region {\n\tint offset;\n\tint size;\n} io_regions[] = {\n\t{ 2, 1 },\n\t/* address + 3 is sometimes reserved by pnp bios for motherboard */\n\t{ 4, 2 },\n\t/* address + 6 is reserved, and may be taken by IDE.\n\t * Unfortunately, Adaptec doesn't know this :-(, */\n\t{ 7, 1 },\n};\n\nstatic void floppy_release_allocated_regions(int fdc, const struct io_region *p)\n{\n\twhile (p != io_regions) {\n\t\tp--;\n\t\trelease_region(fdc_state[fdc].address + p->offset, p->size);\n\t}\n}\n\n#define ARRAY_END(X) (&((X)[ARRAY_SIZE(X)]))\n\nstatic int floppy_request_regions(int fdc)\n{\n\tconst struct io_region *p;\n\n\tfor (p = io_regions; p < ARRAY_END(io_regions); p++) {\n\t\tif (!request_region(fdc_state[fdc].address + p->offset,\n\t\t\t\t    p->size, \"floppy\")) {\n\t\t\tDPRINT(\"Floppy io-port 0x%04lx in use\\n\",\n\t\t\t       fdc_state[fdc].address + p->offset);\n\t\t\tfloppy_release_allocated_regions(fdc, p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void floppy_release_regions(int fdc)\n{\n\tfloppy_release_allocated_regions(fdc, ARRAY_END(io_regions));\n}\n\nstatic int floppy_grab_irq_and_dma(void)\n{\n\tint fdc;\n\n\tif (atomic_inc_return(&usage_count) > 1)\n\t\treturn 0;\n\n\t/*\n\t * We might have scheduled a free_irq(), wait it to\n\t * drain first:\n\t */\n\tflush_workqueue(floppy_wq);\n\n\tif (fd_request_irq()) {\n\t\tDPRINT(\"Unable to grab IRQ%d for the floppy driver\\n\",\n\t\t       FLOPPY_IRQ);\n\t\tatomic_dec(&usage_count);\n\t\treturn -1;\n\t}\n\tif (fd_request_dma()) {\n\t\tDPRINT(\"Unable to grab DMA%d for the floppy driver\\n\",\n\t\t       FLOPPY_DMA);\n\t\tif (can_use_virtual_dma & 2)\n\t\t\tuse_virtual_dma = can_use_virtual_dma = 1;\n\t\tif (!(can_use_virtual_dma & 1)) {\n\t\t\tfd_free_irq();\n\t\t\tatomic_dec(&usage_count);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++) {\n\t\tif (fdc_state[fdc].address != -1) {\n\t\t\tif (floppy_request_regions(fdc))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tfor (fdc = 0; fdc < N_FDC; fdc++) {\n\t\tif (fdc_state[fdc].address != -1) {\n\t\t\treset_fdc_info(fdc, 1);\n\t\t\tfdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);\n\t\t}\n\t}\n\n\tset_dor(0, ~0, 8);\t/* avoid immediate interrupt */\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (fdc_state[fdc].address != -1)\n\t\t\tfdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);\n\t/*\n\t * The driver will try and free resources and relies on us\n\t * to know if they were allocated or not.\n\t */\n\tcurrent_fdc = 0;\n\tirqdma_allocated = 1;\n\treturn 0;\ncleanup:\n\tfd_free_irq();\n\tfd_free_dma();\n\twhile (--fdc >= 0)\n\t\tfloppy_release_regions(fdc);\n\tcurrent_fdc = 0;\n\tatomic_dec(&usage_count);\n\treturn -1;\n}\n\nstatic void floppy_release_irq_and_dma(void)\n{\n\tint fdc;\n#ifndef __sparc__\n\tint drive;\n#endif\n\tlong tmpsize;\n\tunsigned long tmpaddr;\n\n\tif (!atomic_dec_and_test(&usage_count))\n\t\treturn;\n\n\tif (irqdma_allocated) {\n\t\tfd_disable_dma();\n\t\tfd_free_dma();\n\t\tfd_free_irq();\n\t\tirqdma_allocated = 0;\n\t}\n\tset_dor(0, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1, ~8, 0);\n#endif\n\n\tif (floppy_track_buffer && max_buffer_sectors) {\n\t\ttmpsize = max_buffer_sectors * 1024;\n\t\ttmpaddr = (unsigned long)floppy_track_buffer;\n\t\tfloppy_track_buffer = NULL;\n\t\tmax_buffer_sectors = 0;\n\t\tbuffer_min = buffer_max = -1;\n\t\tfd_dma_mem_free(tmpaddr, tmpsize);\n\t}\n#ifndef __sparc__\n\tfor (drive = 0; drive < N_FDC * 4; drive++)\n\t\tif (timer_pending(motor_off_timer + drive))\n\t\t\tpr_info(\"motor off timer %d still active\\n\", drive);\n#endif\n\n\tif (delayed_work_pending(&fd_timeout))\n\t\tpr_info(\"floppy timer still active:%s\\n\", timeout_message);\n\tif (delayed_work_pending(&fd_timer))\n\t\tpr_info(\"auxiliary floppy timer still active\\n\");\n\tif (work_pending(&floppy_work))\n\t\tpr_info(\"work still pending\\n\");\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (fdc_state[fdc].address != -1)\n\t\t\tfloppy_release_regions(fdc);\n}\n\n#ifdef MODULE\n\nstatic char *floppy;\n\nstatic void __init parse_floppy_cfg_string(char *cfg)\n{\n\tchar *ptr;\n\n\twhile (*cfg) {\n\t\tptr = cfg;\n\t\twhile (*cfg && *cfg != ' ' && *cfg != '\\t')\n\t\t\tcfg++;\n\t\tif (*cfg) {\n\t\t\t*cfg = '\\0';\n\t\t\tcfg++;\n\t\t}\n\t\tif (*ptr)\n\t\t\tfloppy_setup(ptr);\n\t}\n}\n\nstatic int __init floppy_module_init(void)\n{\n\tif (floppy)\n\t\tparse_floppy_cfg_string(floppy);\n\treturn floppy_init();\n}\nmodule_init(floppy_module_init);\n\nstatic void __exit floppy_module_exit(void)\n{\n\tint drive, i;\n\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\n\tplatform_driver_unregister(&floppy_driver);\n\n\tdestroy_workqueue(floppy_wq);\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tdel_timer_sync(&motor_off_timer[drive]);\n\n\t\tif (floppy_available(drive)) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(floppy_type); i++) {\n\t\t\t\tif (disks[drive][i])\n\t\t\t\t\tdel_gendisk(disks[drive][i]);\n\t\t\t}\n\t\t\tif (registered[drive])\n\t\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(floppy_type); i++) {\n\t\t\tif (disks[drive][i])\n\t\t\t\tblk_cleanup_disk(disks[drive][i]);\n\t\t}\n\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\t}\n\n\tcancel_delayed_work_sync(&fd_timeout);\n\tcancel_delayed_work_sync(&fd_timer);\n\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\n\n\t/* eject disk, if any */\n\tfd_eject(0);\n}\n\nmodule_exit(floppy_module_exit);\n\nmodule_param(floppy, charp, 0);\nmodule_param(FLOPPY_IRQ, int, 0);\nmodule_param(FLOPPY_DMA, int, 0);\nMODULE_AUTHOR(\"Alain L. Knaff\");\nMODULE_LICENSE(\"GPL\");\n\n/* This doesn't actually get used other than for module information */\nstatic const struct pnp_device_id floppy_pnpids[] = {\n\t{\"PNP0700\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pnp, floppy_pnpids);\n\n#else\n\n__setup(\"floppy=\", floppy_setup);\nmodule_init(floppy_init)\n#endif\n\nMODULE_ALIAS_BLOCKDEV_MAJOR(FLOPPY_MAJOR);\n"], "fixing_code": ["# SPDX-License-Identifier: GPL-2.0\n#\n# Block device driver configuration\n#\n\nmenuconfig BLK_DEV\n\tbool \"Block devices\"\n\tdepends on BLOCK\n\tdefault y\n\thelp\n\t  Say Y here to get to see options for various different block device\n\t  drivers. This option alone does not add any kernel code.\n\n\t  If you say N, all options in this submenu will be skipped and disabled;\n\t  only do this if you know what you are doing.\n\nif BLK_DEV\n\nsource \"drivers/block/null_blk/Kconfig\"\n\nconfig BLK_DEV_FD\n\ttristate \"Normal floppy disk support\"\n\tdepends on ARCH_MAY_HAVE_PC_FDC\n\thelp\n\t  If you want to use the floppy disk drive(s) of your PC under Linux,\n\t  say Y. Information about this driver, especially important for IBM\n\t  Thinkpad users, is contained in\n\t  <file:Documentation/admin-guide/blockdev/floppy.rst>.\n\t  That file also contains the location of the Floppy driver FAQ as\n\t  well as location of the fdutils package used to configure additional\n\t  parameters of the driver at run time.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called floppy.\n\nconfig BLK_DEV_FD_RAWCMD\n\tbool \"Support for raw floppy disk commands (DEPRECATED)\"\n\tdepends on BLK_DEV_FD\n\thelp\n\t  If you want to use actual physical floppies and expect to do\n\t  special low-level hardware accesses to them (access and use\n\t  non-standard formats, for example), then enable this.\n\n\t  Note that the code enabled by this option is rarely used and\n\t  might be unstable or insecure, and distros should not enable it.\n\n\t  Note: FDRAWCMD is deprecated and will be removed from the kernel\n\t  in the near future.\n\n\t  If unsure, say N.\n\nconfig AMIGA_FLOPPY\n\ttristate \"Amiga floppy support\"\n\tdepends on AMIGA\n\nconfig ATARI_FLOPPY\n\ttristate \"Atari floppy support\"\n\tdepends on ATARI\n\nconfig MAC_FLOPPY\n\ttristate \"Support for PowerMac floppy\"\n\tdepends on PPC_PMAC && !PPC_PMAC64\n\thelp\n\t  If you have a SWIM-3 (Super Woz Integrated Machine 3; from Apple)\n\t  floppy controller, say Y here. Most commonly found in PowerMacs.\n\nconfig BLK_DEV_SWIM\n\ttristate \"Support for SWIM Macintosh floppy\"\n\tdepends on M68K && MAC && !HIGHMEM\n\thelp\n\t  You should select this option if you want floppy support\n\t  and you don't have a II, IIfx, Q900, Q950 or AV series.\n\nconfig AMIGA_Z2RAM\n\ttristate \"Amiga Zorro II ramdisk support\"\n\tdepends on ZORRO\n\thelp\n\t  This enables support for using Chip RAM and Zorro II RAM as a\n\t  ramdisk or as a swap partition. Say Y if you want to include this\n\t  driver in the kernel.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called z2ram.\n\nconfig N64CART\n\tbool \"N64 cart support\"\n\tdepends on MACH_NINTENDO64\n\thelp\n\t  Support for the N64 cart.\n\nconfig CDROM\n\ttristate\n\nconfig GDROM\n\ttristate \"SEGA Dreamcast GD-ROM drive\"\n\tdepends on SH_DREAMCAST\n\tselect CDROM\n\thelp\n\t  A standard SEGA Dreamcast comes with a modified CD ROM drive called a\n\t  \"GD-ROM\" by SEGA to signify it is capable of reading special disks\n\t  with up to 1 GB of data. This drive will also read standard CD ROM\n\t  disks. Select this option to access any disks in your GD ROM drive.\n\t  Most users will want to say \"Y\" here.\n\t  You can also build this as a module which will be called gdrom.\n\nconfig PARIDE\n\ttristate \"Parallel port IDE device support\"\n\tdepends on PARPORT_PC\n\thelp\n\t  There are many external CD-ROM and disk devices that connect through\n\t  your computer's parallel port. Most of them are actually IDE devices\n\t  using a parallel port IDE adapter. This option enables the PARIDE\n\t  subsystem which contains drivers for many of these external drives.\n\t  Read <file:Documentation/admin-guide/blockdev/paride.rst> for more information.\n\n\t  If you have said Y to the \"Parallel-port support\" configuration\n\t  option, you may share a single port between your printer and other\n\t  parallel port devices. Answer Y to build PARIDE support into your\n\t  kernel, or M if you would like to build it as a loadable module. If\n\t  your parallel port support is in a loadable module, you must build\n\t  PARIDE as a module. If you built PARIDE support into your kernel,\n\t  you may still build the individual protocol modules and high-level\n\t  drivers as loadable modules. If you build this support as a module,\n\t  it will be called paride.\n\n\t  To use the PARIDE support, you must say Y or M here and also to at\n\t  least one high-level driver (e.g. \"Parallel port IDE disks\",\n\t  \"Parallel port ATAPI CD-ROMs\", \"Parallel port ATAPI disks\" etc.) and\n\t  to at least one protocol driver (e.g. \"ATEN EH-100 protocol\",\n\t  \"MicroSolutions backpack protocol\", \"DataStor Commuter protocol\"\n\t  etc.).\n\nsource \"drivers/block/paride/Kconfig\"\n\nsource \"drivers/block/mtip32xx/Kconfig\"\n\nsource \"drivers/block/zram/Kconfig\"\n\nconfig BLK_DEV_UBD\n\tbool \"Virtual block device\"\n\tdepends on UML\n\thelp\n          The User-Mode Linux port includes a driver called UBD which will let\n          you access arbitrary files on the host computer as block devices.\n          Unless you know that you do not need such virtual block devices say\n          Y here.\n\nconfig BLK_DEV_UBD_SYNC\n\tbool \"Always do synchronous disk IO for UBD\"\n\tdepends on BLK_DEV_UBD\n\thelp\n\t  Writes to the virtual block device are not immediately written to the\n\t  host's disk; this may cause problems if, for example, the User-Mode\n\t  Linux 'Virtual Machine' uses a journalling filesystem and the host\n\t  computer crashes.\n\n          Synchronous operation (i.e. always writing data to the host's disk\n          immediately) is configurable on a per-UBD basis by using a special\n          kernel command line option.  Alternatively, you can say Y here to\n          turn on synchronous operation by default for all block devices.\n\n          If you're running a journalling file system (like reiserfs, for\n          example) in your virtual machine, you will want to say Y here.  If\n          you care for the safety of the data in your virtual machine, Y is a\n          wise choice too.  In all other cases (for example, if you're just\n          playing around with User-Mode Linux) you can choose N.\n\nconfig BLK_DEV_COW_COMMON\n\tbool\n\tdefault BLK_DEV_UBD\n\nconfig BLK_DEV_LOOP\n\ttristate \"Loopback device support\"\n\thelp\n\t  Saying Y here will allow you to use a regular file as a block\n\t  device; you can then create a file system on that block device and\n\t  mount it just as you would mount other block devices such as hard\n\t  drive partitions, CD-ROM drives or floppy drives. The loop devices\n\t  are block special device files with major number 7 and typically\n\t  called /dev/loop0, /dev/loop1 etc.\n\n\t  This is useful if you want to check an ISO 9660 file system before\n\t  burning the CD, or if you want to use floppy images without first\n\t  writing them to floppy. Furthermore, some Linux distributions avoid\n\t  the need for a dedicated Linux partition by keeping their complete\n\t  root file system inside a DOS FAT file using this loop device\n\t  driver.\n\n\t  To use the loop device, you need the losetup utility, found in the\n\t  util-linux package, see\n\t  <https://www.kernel.org/pub/linux/utils/util-linux/>.\n\n\t  The loop device driver can also be used to \"hide\" a file system in\n\t  a disk partition, floppy, or regular file, either using encryption\n\t  (scrambling the data) or steganography (hiding the data in the low\n\t  bits of, say, a sound file). This is also safe if the file resides\n\t  on a remote file server.\n\n\t  Note that this loop device has nothing to do with the loopback\n\t  device used for network connections from the machine to itself.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called loop.\n\n\t  Most users will answer N here.\n\nconfig BLK_DEV_LOOP_MIN_COUNT\n\tint \"Number of loop devices to pre-create at init time\"\n\tdepends on BLK_DEV_LOOP\n\tdefault 8\n\thelp\n\t  Static number of loop devices to be unconditionally pre-created\n\t  at init time.\n\n\t  This default value can be overwritten on the kernel command\n\t  line or with module-parameter loop.max_loop.\n\n\t  The historic default is 8. If a late 2011 version of losetup(8)\n\t  is used, it can be set to 0, since needed loop devices can be\n\t  dynamically allocated with the /dev/loop-control interface.\n\nsource \"drivers/block/drbd/Kconfig\"\n\nconfig BLK_DEV_NBD\n\ttristate \"Network block device support\"\n\tdepends on NET\n\thelp\n\t  Saying Y here will allow your computer to be a client for network\n\t  block devices, i.e. it will be able to use block devices exported by\n\t  servers (mount file systems on them etc.). Communication between\n\t  client and server works over TCP/IP networking, but to the client\n\t  program this is hidden: it looks like a regular local file access to\n\t  a block device special file such as /dev/nd0.\n\n\t  Network block devices also allows you to run a block-device in\n\t  userland (making server and client physically the same computer,\n\t  communicating using the loopback network device).\n\n\t  Read <file:Documentation/admin-guide/blockdev/nbd.rst> for more information,\n\t  especially about where to find the server code, which runs in user\n\t  space and does not need special kernel support.\n\n\t  Note that this has nothing to do with the network file systems NFS\n\t  or Coda; you can say N here even if you intend to use NFS or Coda.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called nbd.\n\n\t  If unsure, say N.\n\nconfig BLK_DEV_SX8\n\ttristate \"Promise SATA SX8 support\"\n\tdepends on PCI\n\thelp\n\t  Saying Y or M here will enable support for the \n\t  Promise SATA SX8 controllers.\n\n\t  Use devices /dev/sx8/$N and /dev/sx8/$Np$M.\n\nconfig BLK_DEV_RAM\n\ttristate \"RAM block device support\"\n\thelp\n\t  Saying Y here will allow you to use a portion of your RAM memory as\n\t  a block device, so that you can make file systems on it, read and\n\t  write to it and do all the other things that you can do with normal\n\t  block devices (such as hard drives). It is usually used to load and\n\t  store a copy of a minimal root file system off of a floppy into RAM\n\t  during the initial install of Linux.\n\n\t  Note that the kernel command line option \"ramdisk=XX\" is now obsolete.\n\t  For details, read <file:Documentation/admin-guide/blockdev/ramdisk.rst>.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called brd. An alias \"rd\" has been defined\n\t  for historical reasons.\n\n\t  Most normal users won't need the RAM disk functionality, and can\n\t  thus say N here.\n\nconfig BLK_DEV_RAM_COUNT\n\tint \"Default number of RAM disks\"\n\tdefault \"16\"\n\tdepends on BLK_DEV_RAM\n\thelp\n\t  The default value is 16 RAM disks. Change this if you know what you\n\t  are doing. If you boot from a filesystem that needs to be extracted\n\t  in memory, you will need at least one RAM disk (e.g. root on cramfs).\n\nconfig BLK_DEV_RAM_SIZE\n\tint \"Default RAM disk size (kbytes)\"\n\tdepends on BLK_DEV_RAM\n\tdefault \"4096\"\n\thelp\n\t  The default value is 4096 kilobytes. Only change this if you know\n\t  what you are doing.\n\nconfig CDROM_PKTCDVD\n\ttristate \"Packet writing on CD/DVD media (DEPRECATED)\"\n\tdepends on !UML\n\tdepends on SCSI\n\tselect CDROM\n\thelp\n\t  Note: This driver is deprecated and will be removed from the\n\t  kernel in the near future!\n\n\t  If you have a CDROM/DVD drive that supports packet writing, say\n\t  Y to include support. It should work with any MMC/Mt Fuji\n\t  compliant ATAPI or SCSI drive, which is just about any newer\n\t  DVD/CD writer.\n\n\t  Currently only writing to CD-RW, DVD-RW, DVD+RW and DVDRAM discs\n\t  is possible.\n\t  DVD-RW disks must be in restricted overwrite mode.\n\n\t  See the file <file:Documentation/cdrom/packet-writing.rst>\n\t  for further information on the use of this driver.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called pktcdvd.\n\nconfig CDROM_PKTCDVD_BUFFERS\n\tint \"Free buffers for data gathering\"\n\tdepends on CDROM_PKTCDVD\n\tdefault \"8\"\n\thelp\n\t  This controls the maximum number of active concurrent packets. More\n\t  concurrent packets can increase write performance, but also require\n\t  more memory. Each concurrent packet will require approximately 64Kb\n\t  of non-swappable kernel memory, memory which will be allocated when\n\t  a disc is opened for writing.\n\nconfig CDROM_PKTCDVD_WCACHE\n\tbool \"Enable write caching\"\n\tdepends on CDROM_PKTCDVD\n\thelp\n\t  If enabled, write caching will be set for the CD-R/W device. For now\n\t  this option is dangerous unless the CD-RW media is known good, as we\n\t  don't do deferred write error handling yet.\n\nconfig ATA_OVER_ETH\n\ttristate \"ATA over Ethernet support\"\n\tdepends on NET\n\thelp\n\tThis driver provides Support for ATA over Ethernet block\n\tdevices like the Coraid EtherDrive (R) Storage Blade.\n\nconfig SUNVDC\n\ttristate \"Sun Virtual Disk Client support\"\n\tdepends on SUN_LDOMS\n\thelp\n\t  Support for virtual disk devices as a client under Sun\n\t  Logical Domains.\n\nsource \"drivers/s390/block/Kconfig\"\n\nconfig XEN_BLKDEV_FRONTEND\n\ttristate \"Xen virtual block device support\"\n\tdepends on XEN\n\tdefault y\n\tselect XEN_XENBUS_FRONTEND\n\thelp\n\t  This driver implements the front-end of the Xen virtual\n\t  block device driver.  It communicates with a back-end driver\n\t  in another domain which drives the actual block device.\n\nconfig XEN_BLKDEV_BACKEND\n\ttristate \"Xen block-device backend driver\"\n\tdepends on XEN_BACKEND\n\thelp\n\t  The block-device backend driver allows the kernel to export its\n\t  block devices to other guests via a high-performance shared-memory\n\t  interface.\n\n\t  The corresponding Linux frontend driver is enabled by the\n\t  CONFIG_XEN_BLKDEV_FRONTEND configuration option.\n\n\t  The backend driver attaches itself to a any block device specified\n\t  in the XenBus configuration. There are no limits to what the block\n\t  device as long as it has a major and minor.\n\n\t  If you are compiling a kernel to run in a Xen block backend driver\n\t  domain (often this is domain 0) you should say Y here. To\n\t  compile this driver as a module, chose M here: the module\n\t  will be called xen-blkback.\n\n\nconfig VIRTIO_BLK\n\ttristate \"Virtio block driver\"\n\tdepends on VIRTIO\n\tselect SG_POOL\n\thelp\n\t  This is the virtual block driver for virtio.  It can be used with\n          QEMU based VMMs (like KVM or Xen).  Say Y or M.\n\nconfig BLK_DEV_RBD\n\ttristate \"Rados block device (RBD)\"\n\tdepends on INET && BLOCK\n\tselect CEPH_LIB\n\tselect LIBCRC32C\n\tselect CRYPTO_AES\n\tselect CRYPTO\n\thelp\n\t  Say Y here if you want include the Rados block device, which stripes\n\t  a block device over objects stored in the Ceph distributed object\n\t  store.\n\n\t  More information at http://ceph.newdream.net/.\n\n\t  If unsure, say N.\n\nsource \"drivers/block/rnbd/Kconfig\"\n\nendif # BLK_DEV\n", "// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/drivers/block/floppy.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *  Copyright (C) 1993, 1994  Alain Knaff\n *  Copyright (C) 1998 Alan Cox\n */\n\n/*\n * 02.12.91 - Changed to static variables to indicate need for reset\n * and recalibrate. This makes some things easier (output_byte reset\n * checking etc), and means less interrupt jumping in case of errors,\n * so the code is hopefully easier to understand.\n */\n\n/*\n * This file is certainly a mess. I've tried my best to get it working,\n * but I don't like programming floppies, and I have only one anyway.\n * Urgel. I should check for more errors, and do more graceful error\n * recovery. Seems there are problems with several drives. I've tried to\n * correct them. No promises.\n */\n\n/*\n * As with hd.c, all routines within this file can (and will) be called\n * by interrupts, so extreme caution is needed. A hardware interrupt\n * handler may not sleep, or a kernel panic will happen. Thus I cannot\n * call \"floppy-on\" directly, but have to set a special timer interrupt\n * etc.\n */\n\n/*\n * 28.02.92 - made track-buffering routines, based on the routines written\n * by entropy@wintermute.wpi.edu (Lawrence Foard). Linus.\n */\n\n/*\n * Automatic floppy-detection and formatting written by Werner Almesberger\n * (almesber@nessie.cs.id.ethz.ch), who also corrected some problems with\n * the floppy-change signal detection.\n */\n\n/*\n * 1992/7/22 -- Hennus Bergman: Added better error reporting, fixed\n * FDC data overrun bug, added some preliminary stuff for vertical\n * recording support.\n *\n * 1992/9/17: Added DMA allocation & DMA functions. -- hhb.\n *\n * TODO: Errors are still not counted properly.\n */\n\n/* 1992/9/20\n * Modifications for ``Sector Shifting'' by Rob Hooft (hooft@chem.ruu.nl)\n * modeled after the freeware MS-DOS program fdformat/88 V1.8 by\n * Christoph H. Hochst\\\"atter.\n * I have fixed the shift values to the ones I always use. Maybe a new\n * ioctl() should be created to be able to modify them.\n * There is a bug in the driver that makes it impossible to format a\n * floppy as the first thing after bootup.\n */\n\n/*\n * 1993/4/29 -- Linus -- cleaned up the timer handling in the kernel, and\n * this helped the floppy driver as well. Much cleaner, and still seems to\n * work.\n */\n\n/* 1994/6/24 --bbroad-- added the floppy table entries and made\n * minor modifications to allow 2.88 floppies to be run.\n */\n\n/* 1994/7/13 -- Paul Vojta -- modified the probing code to allow three or more\n * disk types.\n */\n\n/*\n * 1994/8/8 -- Alain Knaff -- Switched to fdpatch driver: Support for bigger\n * format bug fixes, but unfortunately some new bugs too...\n */\n\n/* 1994/9/17 -- Koen Holtman -- added logging of physical floppy write\n * errors to allow safe writing by specialized programs.\n */\n\n/* 1995/4/24 -- Dan Fandrich -- added support for Commodore 1581 3.5\" disks\n * by defining bit 1 of the \"stretch\" parameter to mean put sectors on the\n * opposite side of the disk, leaving the sector IDs alone (i.e. Commodore's\n * drives are \"upside-down\").\n */\n\n/*\n * 1995/8/26 -- Andreas Busse -- added Mips support.\n */\n\n/*\n * 1995/10/18 -- Ralf Baechle -- Portability cleanup; move machine dependent\n * features to asm/floppy.h.\n */\n\n/*\n * 1998/1/21 -- Richard Gooch <rgooch@atnf.csiro.au> -- devfs support\n */\n\n/*\n * 1998/05/07 -- Russell King -- More portability cleanups; moved definition of\n * interrupt and dma channel to asm/floppy.h. Cleaned up some formatting &\n * use of '0' for NULL.\n */\n\n/*\n * 1998/06/07 -- Alan Cox -- Merged the 2.0.34 fixes for resource allocation\n * failures.\n */\n\n/*\n * 1998/09/20 -- David Weinehall -- Added slow-down code for buggy PS/2-drives.\n */\n\n/*\n * 1999/08/13 -- Paul Slootman -- floppy stopped working on Alpha after 24\n * days, 6 hours, 32 minutes and 32 seconds (i.e. MAXINT jiffies; ints were\n * being used to store jiffies, which are unsigned longs).\n */\n\n/*\n * 2000/08/28 -- Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n * - get rid of check_region\n * - s/suser/capable/\n */\n\n/*\n * 2001/08/26 -- Paul Gortmaker - fix insmod oops on machines with no\n * floppy controller (lingering task on list after module is gone... boom.)\n */\n\n/*\n * 2002/02/07 -- Anton Altaparmakov - Fix io ports reservation to correct range\n * (0x3f2-0x3f5, 0x3f7). This fix is a bit of a hack but the proper fix\n * requires many non-obvious changes in arch dependent code.\n */\n\n/* 2003/07/28 -- Daniele Bellucci <bellucda@tiscali.it>.\n * Better audit of register_blkdev.\n */\n\n#define REALLY_SLOW_IO\n\n#define DEBUGT 2\n\n#define DPRINT(format, args...) \\\n\tpr_info(\"floppy%d: \" format, current_drive, ##args)\n\n#define DCL_DEBUG\t\t/* debug disk change line */\n#ifdef DCL_DEBUG\n#define debug_dcl(test, fmt, args...) \\\n\tdo { if ((test) & FD_DEBUG) DPRINT(fmt, ##args); } while (0)\n#else\n#define debug_dcl(test, fmt, args...) \\\n\tdo { if (0) DPRINT(fmt, ##args); } while (0)\n#endif\n\n/* do print messages for unexpected interrupts */\nstatic int print_unex = 1;\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/fdreg.h>\n#include <linux/fd.h>\n#include <linux/hdreg.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/string.h>\n#include <linux/jiffies.h>\n#include <linux/fcntl.h>\n#include <linux/delay.h>\n#include <linux/mc146818rtc.h>\t/* CMOS defines */\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/major.h>\n#include <linux/platform_device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/compat.h>\n\n/*\n * PS/2 floppies have much slower step rates than regular floppies.\n * It's been recommended that take about 1/4 of the default speed\n * in some more extreme cases.\n */\nstatic DEFINE_MUTEX(floppy_mutex);\nstatic int slow_floppy;\n\n#include <asm/dma.h>\n#include <asm/irq.h>\n\nstatic int FLOPPY_IRQ = 6;\nstatic int FLOPPY_DMA = 2;\nstatic int can_use_virtual_dma = 2;\n/* =======\n * can use virtual DMA:\n * 0 = use of virtual DMA disallowed by config\n * 1 = use of virtual DMA prescribed by config\n * 2 = no virtual DMA preference configured.  By default try hard DMA,\n * but fall back on virtual DMA when not enough memory available\n */\n\nstatic int use_virtual_dma;\n/* =======\n * use virtual DMA\n * 0 using hard DMA\n * 1 using virtual DMA\n * This variable is set to virtual when a DMA mem problem arises, and\n * reset back in floppy_grab_irq_and_dma.\n * It is not safe to reset it in other circumstances, because the floppy\n * driver may have several buffers in use at once, and we do currently not\n * record each buffers capabilities\n */\n\nstatic DEFINE_SPINLOCK(floppy_lock);\n\nstatic unsigned short virtual_dma_port = 0x3f0;\nirqreturn_t floppy_interrupt(int irq, void *dev_id);\nstatic int set_dor(int fdc, char mask, char data);\n\n#define K_64\t0x10000\t\t/* 64KB */\n\n/* the following is the mask of allowed drives. By default units 2 and\n * 3 of both floppy controllers are disabled, because switching on the\n * motor of these drives causes system hangs on some PCI computers. drive\n * 0 is the low bit (0x1), and drive 7 is the high bit (0x80). Bits are on if\n * a drive is allowed.\n *\n * NOTE: This must come before we include the arch floppy header because\n *       some ports reference this variable from there. -DaveM\n */\n\nstatic int allowed_drive_mask = 0x33;\n\n#include <asm/floppy.h>\n\nstatic int irqdma_allocated;\n\n#include <linux/blk-mq.h>\n#include <linux/blkpg.h>\n#include <linux/cdrom.h>\t/* for the compatibility eject ioctl */\n#include <linux/completion.h>\n\nstatic LIST_HEAD(floppy_reqs);\nstatic struct request *current_req;\nstatic int set_next_request(void);\n\n#ifndef fd_get_dma_residue\n#define fd_get_dma_residue() get_dma_residue(FLOPPY_DMA)\n#endif\n\n/* Dma Memory related stuff */\n\n#ifndef fd_dma_mem_free\n#define fd_dma_mem_free(addr, size) free_pages(addr, get_order(size))\n#endif\n\n#ifndef fd_dma_mem_alloc\n#define fd_dma_mem_alloc(size) __get_dma_pages(GFP_KERNEL, get_order(size))\n#endif\n\n#ifndef fd_cacheflush\n#define fd_cacheflush(addr, size) /* nothing... */\n#endif\n\nstatic inline void fallback_on_nodma_alloc(char **addr, size_t l)\n{\n#ifdef FLOPPY_CAN_FALLBACK_ON_NODMA\n\tif (*addr)\n\t\treturn;\t\t/* we have the memory */\n\tif (can_use_virtual_dma != 2)\n\t\treturn;\t\t/* no fallback allowed */\n\tpr_info(\"DMA memory shortage. Temporarily falling back on virtual DMA\\n\");\n\t*addr = (char *)nodma_mem_alloc(l);\n#else\n\treturn;\n#endif\n}\n\n/* End dma memory related stuff */\n\nstatic unsigned long fake_change;\nstatic bool initialized;\n\n#define ITYPE(x)\t(((x) >> 2) & 0x1f)\n#define TOMINOR(x)\t((x & 3) | ((x & 4) << 5))\n#define UNIT(x)\t\t((x) & 0x03)\t\t/* drive on fdc */\n#define FDC(x)\t\t(((x) & 0x04) >> 2)\t/* fdc of drive */\n\t/* reverse mapping from unit and fdc to drive */\n#define REVDRIVE(fdc, unit) ((unit) + ((fdc) << 2))\n\n#define PH_HEAD(floppy, head) (((((floppy)->stretch & 2) >> 1) ^ head) << 2)\n#define STRETCH(floppy)\t((floppy)->stretch & FD_STRETCH)\n\n/* read/write commands */\n#define COMMAND\t\t\t0\n#define DR_SELECT\t\t1\n#define TRACK\t\t\t2\n#define HEAD\t\t\t3\n#define SECTOR\t\t\t4\n#define SIZECODE\t\t5\n#define SECT_PER_TRACK\t\t6\n#define GAP\t\t\t7\n#define SIZECODE2\t\t8\n#define NR_RW 9\n\n/* format commands */\n#define F_SIZECODE\t\t2\n#define F_SECT_PER_TRACK\t3\n#define F_GAP\t\t\t4\n#define F_FILL\t\t\t5\n#define NR_F 6\n\n/*\n * Maximum disk size (in kilobytes).\n * This default is used whenever the current disk size is unknown.\n * [Now it is rather a minimum]\n */\n#define MAX_DISK_SIZE 4\t\t/* 3984 */\n\n/*\n * globals used by 'result()'\n */\nstatic unsigned char reply_buffer[FD_RAW_REPLY_SIZE];\nstatic int inr;\t\t/* size of reply buffer, when called from interrupt */\n#define ST0\t\t0\n#define ST1\t\t1\n#define ST2\t\t2\n#define ST3\t\t0\t/* result of GETSTATUS */\n#define R_TRACK\t\t3\n#define R_HEAD\t\t4\n#define R_SECTOR\t5\n#define R_SIZECODE\t6\n\n#define SEL_DLY\t\t(2 * HZ / 100)\n\n/*\n * this struct defines the different floppy drive types.\n */\nstatic struct {\n\tstruct floppy_drive_params params;\n\tconst char *name;\t/* name printed while booting */\n} default_drive_params[] = {\n/* NOTE: the time values in jiffies should be in msec!\n CMOS drive type\n  |     Maximum data rate supported by drive type\n  |     |   Head load time, msec\n  |     |   |   Head unload time, msec (not used)\n  |     |   |   |     Step rate interval, usec\n  |     |   |   |     |       Time needed for spinup time (jiffies)\n  |     |   |   |     |       |      Timeout for spinning down (jiffies)\n  |     |   |   |     |       |      |   Spindown offset (where disk stops)\n  |     |   |   |     |       |      |   |     Select delay\n  |     |   |   |     |       |      |   |     |     RPS\n  |     |   |   |     |       |      |   |     |     |    Max number of tracks\n  |     |   |   |     |       |      |   |     |     |    |     Interrupt timeout\n  |     |   |   |     |       |      |   |     |     |    |     |   Max nonintlv. sectors\n  |     |   |   |     |       |      |   |     |     |    |     |   | -Max Errors- flags */\n{{0,  500, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  80, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 7, 4, 8, 2, 1, 5, 3,10}, 3*HZ/2, 0 }, \"unknown\" },\n\n{{1,  300, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  40, 3*HZ, 17, {3,1,2,0,2}, 0,\n      0, { 1, 0, 0, 0, 0, 0, 0, 0}, 3*HZ/2, 1 }, \"360K PC\" }, /*5 1/4 360 KB PC*/\n\n{{2,  500, 16, 16, 6000, 4*HZ/10, 3*HZ, 14, SEL_DLY, 6,  83, 3*HZ, 17, {3,1,2,0,2}, 0,\n      0, { 2, 5, 6,23,10,20,12, 0}, 3*HZ/2, 2 }, \"1.2M\" }, /*5 1/4 HD AT*/\n\n{{3,  250, 16, 16, 3000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 4,22,21,30, 3, 0, 0, 0}, 3*HZ/2, 4 }, \"720k\" }, /*3 1/2 DD*/\n\n{{4,  500, 16, 16, 4000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 7, 4,25,22,31,21,29,11}, 3*HZ/2, 7 }, \"1.44M\" }, /*3 1/2 HD*/\n\n{{5, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0,\n      0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, \"2.88M AMI BIOS\" }, /*3 1/2 ED*/\n\n{{6, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0,\n      0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, \"2.88M\" } /*3 1/2 ED*/\n/*    |  --autodetected formats---    |      |      |\n *    read_track                      |      |    Name printed when booting\n *\t\t\t\t      |     Native format\n *\t            Frequency of disk change checks */\n};\n\nstatic struct floppy_drive_params drive_params[N_DRIVE];\nstatic struct floppy_drive_struct drive_state[N_DRIVE];\nstatic struct floppy_write_errors write_errors[N_DRIVE];\nstatic struct timer_list motor_off_timer[N_DRIVE];\nstatic struct blk_mq_tag_set tag_sets[N_DRIVE];\nstatic struct block_device *opened_bdev[N_DRIVE];\nstatic DEFINE_MUTEX(open_lock);\nstatic struct floppy_raw_cmd *raw_cmd, default_raw_cmd;\n\n/*\n * This struct defines the different floppy types.\n *\n * Bit 0 of 'stretch' tells if the tracks need to be doubled for some\n * types (e.g. 360kB diskette in 1.2MB drive, etc.).  Bit 1 of 'stretch'\n * tells if the disk is in Commodore 1581 format, which means side 0 sectors\n * are located on side 1 of the disk but with a side 0 ID, and vice-versa.\n * This is the same as the Sharp MZ-80 5.25\" CP/M disk format, except that the\n * 1581's logical side 0 is on physical side 1, whereas the Sharp's logical\n * side 0 is on physical side 0 (but with the misnamed sector IDs).\n * 'stretch' should probably be renamed to something more general, like\n * 'options'.\n *\n * Bits 2 through 9 of 'stretch' tell the number of the first sector.\n * The LSB (bit 2) is flipped. For most disks, the first sector\n * is 1 (represented by 0x00<<2).  For some CP/M and music sampler\n * disks (such as Ensoniq EPS 16plus) it is 0 (represented as 0x01<<2).\n * For Amstrad CPC disks it is 0xC1 (represented as 0xC0<<2).\n *\n * Other parameters should be self-explanatory (see also setfdprm(8)).\n */\n/*\n\t    Size\n\t     |  Sectors per track\n\t     |  | Head\n\t     |  | |  Tracks\n\t     |  | |  | Stretch\n\t     |  | |  | |  Gap 1 size\n\t     |  | |  | |    |  Data rate, | 0x40 for perp\n\t     |  | |  | |    |    |  Spec1 (stepping rate, head unload\n\t     |  | |  | |    |    |    |    /fmt gap (gap2) */\nstatic struct floppy_struct floppy_type[32] = {\n\t{    0, 0,0, 0,0,0x00,0x00,0x00,0x00,NULL    },\t/*  0 no testing    */\n\t{  720, 9,2,40,0,0x2A,0x02,0xDF,0x50,\"d360\"  }, /*  1 360KB PC      */\n\t{ 2400,15,2,80,0,0x1B,0x00,0xDF,0x54,\"h1200\" },\t/*  2 1.2MB AT      */\n\t{  720, 9,1,80,0,0x2A,0x02,0xDF,0x50,\"D360\"  },\t/*  3 360KB SS 3.5\" */\n\t{ 1440, 9,2,80,0,0x2A,0x02,0xDF,0x50,\"D720\"  },\t/*  4 720KB 3.5\"    */\n\t{  720, 9,2,40,1,0x23,0x01,0xDF,0x50,\"h360\"  },\t/*  5 360KB AT      */\n\t{ 1440, 9,2,80,0,0x23,0x01,0xDF,0x50,\"h720\"  },\t/*  6 720KB AT      */\n\t{ 2880,18,2,80,0,0x1B,0x00,0xCF,0x6C,\"H1440\" },\t/*  7 1.44MB 3.5\"   */\n\t{ 5760,36,2,80,0,0x1B,0x43,0xAF,0x54,\"E2880\" },\t/*  8 2.88MB 3.5\"   */\n\t{ 6240,39,2,80,0,0x1B,0x43,0xAF,0x28,\"E3120\" },\t/*  9 3.12MB 3.5\"   */\n\n\t{ 2880,18,2,80,0,0x25,0x00,0xDF,0x02,\"h1440\" }, /* 10 1.44MB 5.25\"  */\n\t{ 3360,21,2,80,0,0x1C,0x00,0xCF,0x0C,\"H1680\" }, /* 11 1.68MB 3.5\"   */\n\t{  820,10,2,41,1,0x25,0x01,0xDF,0x2E,\"h410\"  },\t/* 12 410KB 5.25\"   */\n\t{ 1640,10,2,82,0,0x25,0x02,0xDF,0x2E,\"H820\"  },\t/* 13 820KB 3.5\"    */\n\t{ 2952,18,2,82,0,0x25,0x00,0xDF,0x02,\"h1476\" },\t/* 14 1.48MB 5.25\"  */\n\t{ 3444,21,2,82,0,0x25,0x00,0xDF,0x0C,\"H1722\" },\t/* 15 1.72MB 3.5\"   */\n\t{  840,10,2,42,1,0x25,0x01,0xDF,0x2E,\"h420\"  },\t/* 16 420KB 5.25\"   */\n\t{ 1660,10,2,83,0,0x25,0x02,0xDF,0x2E,\"H830\"  },\t/* 17 830KB 3.5\"    */\n\t{ 2988,18,2,83,0,0x25,0x00,0xDF,0x02,\"h1494\" },\t/* 18 1.49MB 5.25\"  */\n\t{ 3486,21,2,83,0,0x25,0x00,0xDF,0x0C,\"H1743\" }, /* 19 1.74 MB 3.5\"  */\n\n\t{ 1760,11,2,80,0,0x1C,0x09,0xCF,0x00,\"h880\"  }, /* 20 880KB 5.25\"   */\n\t{ 2080,13,2,80,0,0x1C,0x01,0xCF,0x00,\"D1040\" }, /* 21 1.04MB 3.5\"   */\n\t{ 2240,14,2,80,0,0x1C,0x19,0xCF,0x00,\"D1120\" }, /* 22 1.12MB 3.5\"   */\n\t{ 3200,20,2,80,0,0x1C,0x20,0xCF,0x2C,\"h1600\" }, /* 23 1.6MB 5.25\"   */\n\t{ 3520,22,2,80,0,0x1C,0x08,0xCF,0x2e,\"H1760\" }, /* 24 1.76MB 3.5\"   */\n\t{ 3840,24,2,80,0,0x1C,0x20,0xCF,0x00,\"H1920\" }, /* 25 1.92MB 3.5\"   */\n\t{ 6400,40,2,80,0,0x25,0x5B,0xCF,0x00,\"E3200\" }, /* 26 3.20MB 3.5\"   */\n\t{ 7040,44,2,80,0,0x25,0x5B,0xCF,0x00,\"E3520\" }, /* 27 3.52MB 3.5\"   */\n\t{ 7680,48,2,80,0,0x25,0x63,0xCF,0x00,\"E3840\" }, /* 28 3.84MB 3.5\"   */\n\t{ 3680,23,2,80,0,0x1C,0x10,0xCF,0x00,\"H1840\" }, /* 29 1.84MB 3.5\"   */\n\n\t{ 1600,10,2,80,0,0x25,0x02,0xDF,0x2E,\"D800\"  },\t/* 30 800KB 3.5\"    */\n\t{ 3200,20,2,80,0,0x1C,0x00,0xCF,0x2C,\"H1600\" }, /* 31 1.6MB 3.5\"    */\n};\n\nstatic struct gendisk *disks[N_DRIVE][ARRAY_SIZE(floppy_type)];\n\n#define SECTSIZE (_FD_SECTSIZE(*floppy))\n\n/* Auto-detection: Disk type used until the next media change occurs. */\nstatic struct floppy_struct *current_type[N_DRIVE];\n\n/*\n * User-provided type information. current_type points to\n * the respective entry of this array.\n */\nstatic struct floppy_struct user_params[N_DRIVE];\n\nstatic sector_t floppy_sizes[256];\n\nstatic char floppy_device_name[] = \"floppy\";\n\n/*\n * The driver is trying to determine the correct media format\n * while probing is set. rw_interrupt() clears it after a\n * successful access.\n */\nstatic int probing;\n\n/* Synchronization of FDC access. */\n#define FD_COMMAND_NONE\t\t-1\n#define FD_COMMAND_ERROR\t2\n#define FD_COMMAND_OKAY\t\t3\n\nstatic volatile int command_status = FD_COMMAND_NONE;\nstatic unsigned long fdc_busy;\nstatic DECLARE_WAIT_QUEUE_HEAD(fdc_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(command_done);\n\n/* Errors during formatting are counted here. */\nstatic int format_errors;\n\n/* Format request descriptor. */\nstatic struct format_descr format_req;\n\n/*\n * Rate is 0 for 500kb/s, 1 for 300kbps, 2 for 250kbps\n * Spec1 is 0xSH, where S is stepping rate (F=1ms, E=2ms, D=3ms etc),\n * H is head unload time (1=16ms, 2=32ms, etc)\n */\n\n/*\n * Track buffer\n * Because these are written to by the DMA controller, they must\n * not contain a 64k byte boundary crossing, or data will be\n * corrupted/lost.\n */\nstatic char *floppy_track_buffer;\nstatic int max_buffer_sectors;\n\nstatic int *errors;\ntypedef void (*done_f)(int);\nstatic const struct cont_t {\n\tvoid (*interrupt)(void);\n\t\t\t\t/* this is called after the interrupt of the\n\t\t\t\t * main command */\n\tvoid (*redo)(void);\t/* this is called to retry the operation */\n\tvoid (*error)(void);\t/* this is called to tally an error */\n\tdone_f done;\t\t/* this is called to say if the operation has\n\t\t\t\t * succeeded/failed */\n} *cont;\n\nstatic void floppy_ready(void);\nstatic void floppy_start(void);\nstatic void process_fd_request(void);\nstatic void recalibrate_floppy(void);\nstatic void floppy_shutdown(struct work_struct *);\n\nstatic int floppy_request_regions(int);\nstatic void floppy_release_regions(int);\nstatic int floppy_grab_irq_and_dma(void);\nstatic void floppy_release_irq_and_dma(void);\n\n/*\n * The \"reset\" variable should be tested whenever an interrupt is scheduled,\n * after the commands have been sent. This is to ensure that the driver doesn't\n * get wedged when the interrupt doesn't come because of a failed command.\n * reset doesn't need to be tested before sending commands, because\n * output_byte is automatically disabled when reset is set.\n */\nstatic void reset_fdc(void);\nstatic int floppy_revalidate(struct gendisk *disk);\n\n/*\n * These are global variables, as that's the easiest way to give\n * information to interrupts. They are the data used for the current\n * request.\n */\n#define NO_TRACK\t-1\n#define NEED_1_RECAL\t-2\n#define NEED_2_RECAL\t-3\n\nstatic atomic_t usage_count = ATOMIC_INIT(0);\n\n/* buffer related variables */\nstatic int buffer_track = -1;\nstatic int buffer_drive = -1;\nstatic int buffer_min = -1;\nstatic int buffer_max = -1;\n\n/* fdc related variables, should end up in a struct */\nstatic struct floppy_fdc_state fdc_state[N_FDC];\nstatic int current_fdc;\t\t\t/* current fdc */\n\nstatic struct workqueue_struct *floppy_wq;\n\nstatic struct floppy_struct *_floppy = floppy_type;\nstatic unsigned char current_drive;\nstatic long current_count_sectors;\nstatic unsigned char fsector_t;\t/* sector in track */\nstatic unsigned char in_sector_offset;\t/* offset within physical sector,\n\t\t\t\t\t * expressed in units of 512 bytes */\n\nstatic inline unsigned char fdc_inb(int fdc, int reg)\n{\n\treturn fd_inb(fdc_state[fdc].address, reg);\n}\n\nstatic inline void fdc_outb(unsigned char value, int fdc, int reg)\n{\n\tfd_outb(value, fdc_state[fdc].address, reg);\n}\n\nstatic inline bool drive_no_geom(int drive)\n{\n\treturn !current_type[drive] && !ITYPE(drive_state[drive].fd_device);\n}\n\n#ifndef fd_eject\nstatic inline int fd_eject(int drive)\n{\n\treturn -EINVAL;\n}\n#endif\n\n/*\n * Debugging\n * =========\n */\n#ifdef DEBUGT\nstatic long unsigned debugtimer;\n\nstatic inline void set_debugt(void)\n{\n\tdebugtimer = jiffies;\n}\n\nstatic inline void debugt(const char *func, const char *msg)\n{\n\tif (drive_params[current_drive].flags & DEBUGT)\n\t\tpr_info(\"%s:%s dtime=%lu\\n\", func, msg, jiffies - debugtimer);\n}\n#else\nstatic inline void set_debugt(void) { }\nstatic inline void debugt(const char *func, const char *msg) { }\n#endif /* DEBUGT */\n\n\nstatic DECLARE_DELAYED_WORK(fd_timeout, floppy_shutdown);\nstatic const char *timeout_message;\n\nstatic void is_alive(const char *func, const char *message)\n{\n\t/* this routine checks whether the floppy driver is \"alive\" */\n\tif (test_bit(0, &fdc_busy) && command_status < 2 &&\n\t    !delayed_work_pending(&fd_timeout)) {\n\t\tDPRINT(\"%s: timeout handler died.  %s\\n\", func, message);\n\t}\n}\n\nstatic void (*do_floppy)(void) = NULL;\n\n#define OLOGSIZE 20\n\nstatic void (*lasthandler)(void);\nstatic unsigned long interruptjiffies;\nstatic unsigned long resultjiffies;\nstatic int resultsize;\nstatic unsigned long lastredo;\n\nstatic struct output_log {\n\tunsigned char data;\n\tunsigned char status;\n\tunsigned long jiffies;\n} output_log[OLOGSIZE];\n\nstatic int output_log_pos;\n\n#define MAXTIMEOUT -2\n\nstatic void __reschedule_timeout(int drive, const char *message)\n{\n\tunsigned long delay;\n\n\tif (drive < 0 || drive >= N_DRIVE) {\n\t\tdelay = 20UL * HZ;\n\t\tdrive = 0;\n\t} else\n\t\tdelay = drive_params[drive].timeout;\n\n\tmod_delayed_work(floppy_wq, &fd_timeout, delay);\n\tif (drive_params[drive].flags & FD_DEBUG)\n\t\tDPRINT(\"reschedule timeout %s\\n\", message);\n\ttimeout_message = message;\n}\n\nstatic void reschedule_timeout(int drive, const char *message)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&floppy_lock, flags);\n\t__reschedule_timeout(drive, message);\n\tspin_unlock_irqrestore(&floppy_lock, flags);\n}\n\n#define INFBOUND(a, b) (a) = max_t(int, a, b)\n#define SUPBOUND(a, b) (a) = min_t(int, a, b)\n\n/*\n * Bottom half floppy driver.\n * ==========================\n *\n * This part of the file contains the code talking directly to the hardware,\n * and also the main service loop (seek-configure-spinup-command)\n */\n\n/*\n * disk change.\n * This routine is responsible for maintaining the FD_DISK_CHANGE flag,\n * and the last_checked date.\n *\n * last_checked is the date of the last check which showed 'no disk change'\n * FD_DISK_CHANGE is set under two conditions:\n * 1. The floppy has been changed after some i/o to that floppy already\n *    took place.\n * 2. No floppy disk is in the drive. This is done in order to ensure that\n *    requests are quickly flushed in case there is no disk in the drive. It\n *    follows that FD_DISK_CHANGE can only be cleared if there is a disk in\n *    the drive.\n *\n * For 1., maxblock is observed. Maxblock is 0 if no i/o has taken place yet.\n * For 2., FD_DISK_NEWCHANGE is watched. FD_DISK_NEWCHANGE is cleared on\n *  each seek. If a disk is present, the disk change line should also be\n *  cleared on each seek. Thus, if FD_DISK_NEWCHANGE is clear, but the disk\n *  change line is set, this means either that no disk is in the drive, or\n *  that it has been removed since the last seek.\n *\n * This means that we really have a third possibility too:\n *  The floppy has been changed after the last seek.\n */\n\nstatic int disk_change(int drive)\n{\n\tint fdc = FDC(drive);\n\n\tif (time_before(jiffies, drive_state[drive].select_date + drive_params[drive].select_delay))\n\t\tDPRINT(\"WARNING disk change called early\\n\");\n\tif (!(fdc_state[fdc].dor & (0x10 << UNIT(drive))) ||\n\t    (fdc_state[fdc].dor & 3) != UNIT(drive) || fdc != FDC(drive)) {\n\t\tDPRINT(\"probing disk change on unselected drive\\n\");\n\t\tDPRINT(\"drive=%d fdc=%d dor=%x\\n\", drive, FDC(drive),\n\t\t       (unsigned int)fdc_state[fdc].dor);\n\t}\n\n\tdebug_dcl(drive_params[drive].flags,\n\t\t  \"checking disk change line for drive %d\\n\", drive);\n\tdebug_dcl(drive_params[drive].flags, \"jiffies=%lu\\n\", jiffies);\n\tdebug_dcl(drive_params[drive].flags, \"disk change line=%x\\n\",\n\t\t  fdc_inb(fdc, FD_DIR) & 0x80);\n\tdebug_dcl(drive_params[drive].flags, \"flags=%lx\\n\",\n\t\t  drive_state[drive].flags);\n\n\tif (drive_params[drive].flags & FD_BROKEN_DCL)\n\t\treturn test_bit(FD_DISK_CHANGED_BIT,\n\t\t\t\t&drive_state[drive].flags);\n\tif ((fdc_inb(fdc, FD_DIR) ^ drive_params[drive].flags) & 0x80) {\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\t\t\t\t/* verify write protection */\n\n\t\tif (drive_state[drive].maxblock)\t/* mark it changed */\n\t\t\tset_bit(FD_DISK_CHANGED_BIT,\n\t\t\t\t&drive_state[drive].flags);\n\n\t\t/* invalidate its geometry */\n\t\tif (drive_state[drive].keep_data >= 0) {\n\t\t\tif ((drive_params[drive].flags & FTD_MSG) &&\n\t\t\t    current_type[drive] != NULL)\n\t\t\t\tDPRINT(\"Disk type is undefined after disk change\\n\");\n\t\t\tcurrent_type[drive] = NULL;\n\t\t\tfloppy_sizes[TOMINOR(drive)] = MAX_DISK_SIZE << 1;\n\t\t}\n\n\t\treturn 1;\n\t} else {\n\t\tdrive_state[drive].last_checked = jiffies;\n\t\tclear_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[drive].flags);\n\t}\n\treturn 0;\n}\n\nstatic inline int is_selected(int dor, int unit)\n{\n\treturn ((dor & (0x10 << unit)) && (dor & 3) == unit);\n}\n\nstatic bool is_ready_state(int status)\n{\n\tint state = status & (STATUS_READY | STATUS_DIR | STATUS_DMA);\n\treturn state == STATUS_READY;\n}\n\nstatic int set_dor(int fdc, char mask, char data)\n{\n\tunsigned char unit;\n\tunsigned char drive;\n\tunsigned char newdor;\n\tunsigned char olddor;\n\n\tif (fdc_state[fdc].address == -1)\n\t\treturn -1;\n\n\tolddor = fdc_state[fdc].dor;\n\tnewdor = (olddor & mask) | data;\n\tif (newdor != olddor) {\n\t\tunit = olddor & 0x3;\n\t\tif (is_selected(olddor, unit) && !is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tdebug_dcl(drive_params[drive].flags,\n\t\t\t\t  \"calling disk change from set_dor\\n\");\n\t\t\tdisk_change(drive);\n\t\t}\n\t\tfdc_state[fdc].dor = newdor;\n\t\tfdc_outb(newdor, fdc, FD_DOR);\n\n\t\tunit = newdor & 0x3;\n\t\tif (!is_selected(olddor, unit) && is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tdrive_state[drive].select_date = jiffies;\n\t\t}\n\t}\n\treturn olddor;\n}\n\nstatic void twaddle(int fdc, int drive)\n{\n\tif (drive_params[drive].select_delay)\n\t\treturn;\n\tfdc_outb(fdc_state[fdc].dor & ~(0x10 << UNIT(drive)),\n\t\t fdc, FD_DOR);\n\tfdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);\n\tdrive_state[drive].select_date = jiffies;\n}\n\n/*\n * Reset all driver information about the specified fdc.\n * This is needed after a reset, and after a raw command.\n */\nstatic void reset_fdc_info(int fdc, int mode)\n{\n\tint drive;\n\n\tfdc_state[fdc].spec1 = fdc_state[fdc].spec2 = -1;\n\tfdc_state[fdc].need_configure = 1;\n\tfdc_state[fdc].perp_mode = 1;\n\tfdc_state[fdc].rawcmd = 0;\n\tfor (drive = 0; drive < N_DRIVE; drive++)\n\t\tif (FDC(drive) == fdc &&\n\t\t    (mode || drive_state[drive].track != NEED_1_RECAL))\n\t\t\tdrive_state[drive].track = NEED_2_RECAL;\n}\n\n/*\n * selects the fdc and drive, and enables the fdc's input/dma.\n * Both current_drive and current_fdc are changed to match the new drive.\n */\nstatic void set_fdc(int drive)\n{\n\tunsigned int fdc;\n\n\tif (drive < 0 || drive >= N_DRIVE) {\n\t\tpr_info(\"bad drive value %d\\n\", drive);\n\t\treturn;\n\t}\n\n\tfdc = FDC(drive);\n\tif (fdc >= N_FDC) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (fdc_state[fdc].rawcmd == 2)\n\t\treset_fdc_info(fdc, 1);\n\tif (fdc_inb(fdc, FD_STATUS) != STATUS_READY)\n\t\tfdc_state[fdc].reset = 1;\n\n\tcurrent_drive = drive;\n\tcurrent_fdc = fdc;\n}\n\n/*\n * locks the driver.\n * Both current_drive and current_fdc are changed to match the new drive.\n */\nstatic int lock_fdc(int drive)\n{\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"Trying to lock fdc while usage count=0\\n\"))\n\t\treturn -1;\n\n\tif (wait_event_interruptible(fdc_wait, !test_and_set_bit(0, &fdc_busy)))\n\t\treturn -EINTR;\n\n\tcommand_status = FD_COMMAND_NONE;\n\n\treschedule_timeout(drive, \"lock fdc\");\n\tset_fdc(drive);\n\treturn 0;\n}\n\n/* unlocks the driver */\nstatic void unlock_fdc(void)\n{\n\tif (!test_bit(0, &fdc_busy))\n\t\tDPRINT(\"FDC access conflict!\\n\");\n\n\traw_cmd = NULL;\n\tcommand_status = FD_COMMAND_NONE;\n\tcancel_delayed_work(&fd_timeout);\n\tdo_floppy = NULL;\n\tcont = NULL;\n\tclear_bit(0, &fdc_busy);\n\twake_up(&fdc_wait);\n}\n\n/* switches the motor off after a given timeout */\nstatic void motor_off_callback(struct timer_list *t)\n{\n\tunsigned long nr = t - motor_off_timer;\n\tunsigned char mask = ~(0x10 << UNIT(nr));\n\n\tif (WARN_ON_ONCE(nr >= N_DRIVE))\n\t\treturn;\n\n\tset_dor(FDC(nr), mask, 0);\n}\n\n/* schedules motor off */\nstatic void floppy_off(unsigned int drive)\n{\n\tunsigned long volatile delta;\n\tint fdc = FDC(drive);\n\n\tif (!(fdc_state[fdc].dor & (0x10 << UNIT(drive))))\n\t\treturn;\n\n\tdel_timer(motor_off_timer + drive);\n\n\t/* make spindle stop in a position which minimizes spinup time\n\t * next time */\n\tif (drive_params[drive].rps) {\n\t\tdelta = jiffies - drive_state[drive].first_read_date + HZ -\n\t\t    drive_params[drive].spindown_offset;\n\t\tdelta = ((delta * drive_params[drive].rps) % HZ) / drive_params[drive].rps;\n\t\tmotor_off_timer[drive].expires =\n\t\t    jiffies + drive_params[drive].spindown - delta;\n\t}\n\tadd_timer(motor_off_timer + drive);\n}\n\n/*\n * cycle through all N_DRIVE floppy drives, for disk change testing.\n * stopping at current drive. This is done before any long operation, to\n * be sure to have up to date disk change information.\n */\nstatic void scandrives(void)\n{\n\tint i;\n\tint drive;\n\tint saved_drive;\n\n\tif (drive_params[current_drive].select_delay)\n\t\treturn;\n\n\tsaved_drive = current_drive;\n\tfor (i = 0; i < N_DRIVE; i++) {\n\t\tdrive = (saved_drive + i + 1) % N_DRIVE;\n\t\tif (drive_state[drive].fd_ref == 0 || drive_params[drive].select_delay != 0)\n\t\t\tcontinue;\t/* skip closed drives */\n\t\tset_fdc(drive);\n\t\tif (!(set_dor(current_fdc, ~3, UNIT(drive) | (0x10 << UNIT(drive))) &\n\t\t      (0x10 << UNIT(drive))))\n\t\t\t/* switch the motor off again, if it was off to\n\t\t\t * begin with */\n\t\t\tset_dor(current_fdc, ~(0x10 << UNIT(drive)), 0);\n\t}\n\tset_fdc(saved_drive);\n}\n\nstatic void empty(void)\n{\n}\n\nstatic void (*floppy_work_fn)(void);\n\nstatic void floppy_work_workfn(struct work_struct *work)\n{\n\tfloppy_work_fn();\n}\n\nstatic DECLARE_WORK(floppy_work, floppy_work_workfn);\n\nstatic void schedule_bh(void (*handler)(void))\n{\n\tWARN_ON(work_pending(&floppy_work));\n\n\tfloppy_work_fn = handler;\n\tqueue_work(floppy_wq, &floppy_work);\n}\n\nstatic void (*fd_timer_fn)(void) = NULL;\n\nstatic void fd_timer_workfn(struct work_struct *work)\n{\n\tfd_timer_fn();\n}\n\nstatic DECLARE_DELAYED_WORK(fd_timer, fd_timer_workfn);\n\nstatic void cancel_activity(void)\n{\n\tdo_floppy = NULL;\n\tcancel_delayed_work(&fd_timer);\n\tcancel_work_sync(&floppy_work);\n}\n\n/* this function makes sure that the disk stays in the drive during the\n * transfer */\nstatic void fd_watchdog(void)\n{\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from watchdog\\n\");\n\n\tif (disk_change(current_drive)) {\n\t\tDPRINT(\"disk removed during i/o\\n\");\n\t\tcancel_activity();\n\t\tcont->done(0);\n\t\treset_fdc();\n\t} else {\n\t\tcancel_delayed_work(&fd_timer);\n\t\tfd_timer_fn = fd_watchdog;\n\t\tqueue_delayed_work(floppy_wq, &fd_timer, HZ / 10);\n\t}\n}\n\nstatic void main_command_interrupt(void)\n{\n\tcancel_delayed_work(&fd_timer);\n\tcont->interrupt();\n}\n\n/* waits for a delay (spinup or select) to pass */\nstatic int fd_wait_for_completion(unsigned long expires,\n\t\t\t\t  void (*function)(void))\n{\n\tif (fdc_state[current_fdc].reset) {\n\t\treset_fdc();\t/* do the reset during sleep to win time\n\t\t\t\t * if we don't need to sleep, it's a good\n\t\t\t\t * occasion anyways */\n\t\treturn 1;\n\t}\n\n\tif (time_before(jiffies, expires)) {\n\t\tcancel_delayed_work(&fd_timer);\n\t\tfd_timer_fn = function;\n\t\tqueue_delayed_work(floppy_wq, &fd_timer, expires - jiffies);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void setup_DMA(void)\n{\n\tunsigned long f;\n\n\tif (raw_cmd->length == 0) {\n\t\tprint_hex_dump(KERN_INFO, \"zero dma transfer size: \",\n\t\t\t       DUMP_PREFIX_NONE, 16, 1,\n\t\t\t       raw_cmd->fullcmd, raw_cmd->cmd_count, false);\n\t\tcont->done(0);\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn;\n\t}\n\tif (((unsigned long)raw_cmd->kernel_data) % 512) {\n\t\tpr_info(\"non aligned address: %p\\n\", raw_cmd->kernel_data);\n\t\tcont->done(0);\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn;\n\t}\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n#ifdef fd_dma_setup\n\tif (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length,\n\t\t\t (raw_cmd->flags & FD_RAW_READ) ?\n\t\t\t DMA_MODE_READ : DMA_MODE_WRITE,\n\t\t\t fdc_state[current_fdc].address) < 0) {\n\t\trelease_dma_lock(f);\n\t\tcont->done(0);\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn;\n\t}\n\trelease_dma_lock(f);\n#else\n\tfd_clear_dma_ff();\n\tfd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);\n\tfd_set_dma_mode((raw_cmd->flags & FD_RAW_READ) ?\n\t\t\tDMA_MODE_READ : DMA_MODE_WRITE);\n\tfd_set_dma_addr(raw_cmd->kernel_data);\n\tfd_set_dma_count(raw_cmd->length);\n\tvirtual_dma_port = fdc_state[current_fdc].address;\n\tfd_enable_dma();\n\trelease_dma_lock(f);\n#endif\n}\n\nstatic void show_floppy(int fdc);\n\n/* waits until the fdc becomes ready */\nstatic int wait_til_ready(int fdc)\n{\n\tint status;\n\tint counter;\n\n\tif (fdc_state[fdc].reset)\n\t\treturn -1;\n\tfor (counter = 0; counter < 10000; counter++) {\n\t\tstatus = fdc_inb(fdc, FD_STATUS);\n\t\tif (status & STATUS_READY)\n\t\t\treturn status;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"Getstatus times out (%x) on fdc %d\\n\", status, fdc);\n\t\tshow_floppy(fdc);\n\t}\n\tfdc_state[fdc].reset = 1;\n\treturn -1;\n}\n\n/* sends a command byte to the fdc */\nstatic int output_byte(int fdc, char byte)\n{\n\tint status = wait_til_ready(fdc);\n\n\tif (status < 0)\n\t\treturn -1;\n\n\tif (is_ready_state(status)) {\n\t\tfdc_outb(byte, fdc, FD_DATA);\n\t\toutput_log[output_log_pos].data = byte;\n\t\toutput_log[output_log_pos].status = status;\n\t\toutput_log[output_log_pos].jiffies = jiffies;\n\t\toutput_log_pos = (output_log_pos + 1) % OLOGSIZE;\n\t\treturn 0;\n\t}\n\tfdc_state[fdc].reset = 1;\n\tif (initialized) {\n\t\tDPRINT(\"Unable to send byte %x to FDC. Fdc=%x Status=%x\\n\",\n\t\t       byte, fdc, status);\n\t\tshow_floppy(fdc);\n\t}\n\treturn -1;\n}\n\n/* gets the response from the fdc */\nstatic int result(int fdc)\n{\n\tint i;\n\tint status = 0;\n\n\tfor (i = 0; i < FD_RAW_REPLY_SIZE; i++) {\n\t\tstatus = wait_til_ready(fdc);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;\n\t\tif ((status & ~STATUS_BUSY) == STATUS_READY) {\n\t\t\tresultjiffies = jiffies;\n\t\t\tresultsize = i;\n\t\t\treturn i;\n\t\t}\n\t\tif (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))\n\t\t\treply_buffer[i] = fdc_inb(fdc, FD_DATA);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"get result error. Fdc=%d Last status=%x Read bytes=%d\\n\",\n\t\t       fdc, status, i);\n\t\tshow_floppy(fdc);\n\t}\n\tfdc_state[fdc].reset = 1;\n\treturn -1;\n}\n\n#define MORE_OUTPUT -2\n/* does the fdc need more output? */\nstatic int need_more_output(int fdc)\n{\n\tint status = wait_til_ready(fdc);\n\n\tif (status < 0)\n\t\treturn -1;\n\n\tif (is_ready_state(status))\n\t\treturn MORE_OUTPUT;\n\n\treturn result(fdc);\n}\n\n/* Set perpendicular mode as required, based on data rate, if supported.\n * 82077 Now tested. 1Mbps data rate only possible with 82077-1.\n */\nstatic void perpendicular_mode(int fdc)\n{\n\tunsigned char perp_mode;\n\n\tif (raw_cmd->rate & 0x40) {\n\t\tswitch (raw_cmd->rate & 3) {\n\t\tcase 0:\n\t\t\tperp_mode = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tperp_mode = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINT(\"Invalid data rate for perpendicular mode!\\n\");\n\t\t\tcont->done(0);\n\t\t\tfdc_state[fdc].reset = 1;\n\t\t\t\t\t/*\n\t\t\t\t\t * convenient way to return to\n\t\t\t\t\t * redo without too much hassle\n\t\t\t\t\t * (deep stack et al.)\n\t\t\t\t\t */\n\t\t\treturn;\n\t\t}\n\t} else\n\t\tperp_mode = 0;\n\n\tif (fdc_state[fdc].perp_mode == perp_mode)\n\t\treturn;\n\tif (fdc_state[fdc].version >= FDC_82077_ORIG) {\n\t\toutput_byte(fdc, FD_PERPENDICULAR);\n\t\toutput_byte(fdc, perp_mode);\n\t\tfdc_state[fdc].perp_mode = perp_mode;\n\t} else if (perp_mode) {\n\t\tDPRINT(\"perpendicular mode not supported by this FDC.\\n\");\n\t}\n}\t\t\t\t/* perpendicular_mode */\n\nstatic int fifo_depth = 0xa;\nstatic int no_fifo;\n\nstatic int fdc_configure(int fdc)\n{\n\t/* Turn on FIFO */\n\toutput_byte(fdc, FD_CONFIGURE);\n\tif (need_more_output(fdc) != MORE_OUTPUT)\n\t\treturn 0;\n\toutput_byte(fdc, 0);\n\toutput_byte(fdc, 0x10 | (no_fifo & 0x20) | (fifo_depth & 0xf));\n\toutput_byte(fdc, 0);    /* pre-compensation from track 0 upwards */\n\treturn 1;\n}\n\n#define NOMINAL_DTR 500\n\n/* Issue a \"SPECIFY\" command to set the step rate time, head unload time,\n * head load time, and DMA disable flag to values needed by floppy.\n *\n * The value \"dtr\" is the data transfer rate in Kbps.  It is needed\n * to account for the data rate-based scaling done by the 82072 and 82077\n * FDC types.  This parameter is ignored for other types of FDCs (i.e.\n * 8272a).\n *\n * Note that changing the data transfer rate has a (probably deleterious)\n * effect on the parameters subject to scaling for 82072/82077 FDCs, so\n * fdc_specify is called again after each data transfer rate\n * change.\n *\n * srt: 1000 to 16000 in microseconds\n * hut: 16 to 240 milliseconds\n * hlt: 2 to 254 milliseconds\n *\n * These values are rounded up to the next highest available delay time.\n */\nstatic void fdc_specify(int fdc, int drive)\n{\n\tunsigned char spec1;\n\tunsigned char spec2;\n\tunsigned long srt;\n\tunsigned long hlt;\n\tunsigned long hut;\n\tunsigned long dtr = NOMINAL_DTR;\n\tunsigned long scale_dtr = NOMINAL_DTR;\n\tint hlt_max_code = 0x7f;\n\tint hut_max_code = 0xf;\n\n\tif (fdc_state[fdc].need_configure &&\n\t    fdc_state[fdc].version >= FDC_82072A) {\n\t\tfdc_configure(fdc);\n\t\tfdc_state[fdc].need_configure = 0;\n\t}\n\n\tswitch (raw_cmd->rate & 0x03) {\n\tcase 3:\n\t\tdtr = 1000;\n\t\tbreak;\n\tcase 1:\n\t\tdtr = 300;\n\t\tif (fdc_state[fdc].version >= FDC_82078) {\n\t\t\t/* chose the default rate table, not the one\n\t\t\t * where 1 = 2 Mbps */\n\t\t\toutput_byte(fdc, FD_DRIVESPEC);\n\t\t\tif (need_more_output(fdc) == MORE_OUTPUT) {\n\t\t\t\toutput_byte(fdc, UNIT(drive));\n\t\t\t\toutput_byte(fdc, 0xc0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tdtr = 250;\n\t\tbreak;\n\t}\n\n\tif (fdc_state[fdc].version >= FDC_82072) {\n\t\tscale_dtr = dtr;\n\t\thlt_max_code = 0x00;\t/* 0==256msec*dtr0/dtr (not linear!) */\n\t\thut_max_code = 0x0;\t/* 0==256msec*dtr0/dtr (not linear!) */\n\t}\n\n\t/* Convert step rate from microseconds to milliseconds and 4 bits */\n\tsrt = 16 - DIV_ROUND_UP(drive_params[drive].srt * scale_dtr / 1000,\n\t\t\t\tNOMINAL_DTR);\n\tif (slow_floppy)\n\t\tsrt = srt / 4;\n\n\tSUPBOUND(srt, 0xf);\n\tINFBOUND(srt, 0);\n\n\thlt = DIV_ROUND_UP(drive_params[drive].hlt * scale_dtr / 2,\n\t\t\t   NOMINAL_DTR);\n\tif (hlt < 0x01)\n\t\thlt = 0x01;\n\telse if (hlt > 0x7f)\n\t\thlt = hlt_max_code;\n\n\thut = DIV_ROUND_UP(drive_params[drive].hut * scale_dtr / 16,\n\t\t\t   NOMINAL_DTR);\n\tif (hut < 0x1)\n\t\thut = 0x1;\n\telse if (hut > 0xf)\n\t\thut = hut_max_code;\n\n\tspec1 = (srt << 4) | hut;\n\tspec2 = (hlt << 1) | (use_virtual_dma & 1);\n\n\t/* If these parameters did not change, just return with success */\n\tif (fdc_state[fdc].spec1 != spec1 ||\n\t    fdc_state[fdc].spec2 != spec2) {\n\t\t/* Go ahead and set spec1 and spec2 */\n\t\toutput_byte(fdc, FD_SPECIFY);\n\t\toutput_byte(fdc, fdc_state[fdc].spec1 = spec1);\n\t\toutput_byte(fdc, fdc_state[fdc].spec2 = spec2);\n\t}\n}\t\t\t\t/* fdc_specify */\n\n/* Set the FDC's data transfer rate on behalf of the specified drive.\n * NOTE: with 82072/82077 FDCs, changing the data rate requires a reissue\n * of the specify command (i.e. using the fdc_specify function).\n */\nstatic int fdc_dtr(void)\n{\n\t/* If data rate not already set to desired value, set it. */\n\tif ((raw_cmd->rate & 3) == fdc_state[current_fdc].dtr)\n\t\treturn 0;\n\n\t/* Set dtr */\n\tfdc_outb(raw_cmd->rate & 3, current_fdc, FD_DCR);\n\n\t/* TODO: some FDC/drive combinations (C&T 82C711 with TEAC 1.2MB)\n\t * need a stabilization period of several milliseconds to be\n\t * enforced after data rate changes before R/W operations.\n\t * Pause 5 msec to avoid trouble. (Needs to be 2 jiffies)\n\t */\n\tfdc_state[current_fdc].dtr = raw_cmd->rate & 3;\n\treturn fd_wait_for_completion(jiffies + 2UL * HZ / 100, floppy_ready);\n}\t\t\t\t/* fdc_dtr */\n\nstatic void tell_sector(void)\n{\n\tpr_cont(\": track %d, head %d, sector %d, size %d\",\n\t\treply_buffer[R_TRACK], reply_buffer[R_HEAD],\n\t\treply_buffer[R_SECTOR],\n\t\treply_buffer[R_SIZECODE]);\n}\t\t\t\t/* tell_sector */\n\nstatic void print_errors(void)\n{\n\tDPRINT(\"\");\n\tif (reply_buffer[ST0] & ST0_ECE) {\n\t\tpr_cont(\"Recalibrate failed!\");\n\t} else if (reply_buffer[ST2] & ST2_CRC) {\n\t\tpr_cont(\"data CRC error\");\n\t\ttell_sector();\n\t} else if (reply_buffer[ST1] & ST1_CRC) {\n\t\tpr_cont(\"CRC error\");\n\t\ttell_sector();\n\t} else if ((reply_buffer[ST1] & (ST1_MAM | ST1_ND)) ||\n\t\t   (reply_buffer[ST2] & ST2_MAM)) {\n\t\tif (!probing) {\n\t\t\tpr_cont(\"sector not found\");\n\t\t\ttell_sector();\n\t\t} else\n\t\t\tpr_cont(\"probe failed...\");\n\t} else if (reply_buffer[ST2] & ST2_WC) {\t/* seek error */\n\t\tpr_cont(\"wrong cylinder\");\n\t} else if (reply_buffer[ST2] & ST2_BC) {\t/* cylinder marked as bad */\n\t\tpr_cont(\"bad cylinder\");\n\t} else {\n\t\tpr_cont(\"unknown error. ST[0..2] are: 0x%x 0x%x 0x%x\",\n\t\t\treply_buffer[ST0], reply_buffer[ST1],\n\t\t\treply_buffer[ST2]);\n\t\ttell_sector();\n\t}\n\tpr_cont(\"\\n\");\n}\n\n/*\n * OK, this error interpreting routine is called after a\n * DMA read/write has succeeded\n * or failed, so we check the results, and copy any buffers.\n * hhb: Added better error reporting.\n * ak: Made this into a separate routine.\n */\nstatic int interpret_errors(void)\n{\n\tchar bad;\n\n\tif (inr != 7) {\n\t\tDPRINT(\"-- FDC reply error\\n\");\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn 1;\n\t}\n\n\t/* check IC to find cause of interrupt */\n\tswitch (reply_buffer[ST0] & ST0_INTR) {\n\tcase 0x40:\t\t/* error occurred during command execution */\n\t\tif (reply_buffer[ST1] & ST1_EOC)\n\t\t\treturn 0;\t/* occurs with pseudo-DMA */\n\t\tbad = 1;\n\t\tif (reply_buffer[ST1] & ST1_WP) {\n\t\t\tDPRINT(\"Drive is write protected\\n\");\n\t\t\tclear_bit(FD_DISK_WRITABLE_BIT,\n\t\t\t\t  &drive_state[current_drive].flags);\n\t\t\tcont->done(0);\n\t\t\tbad = 2;\n\t\t} else if (reply_buffer[ST1] & ST1_ND) {\n\t\t\tset_bit(FD_NEED_TWADDLE_BIT,\n\t\t\t\t&drive_state[current_drive].flags);\n\t\t} else if (reply_buffer[ST1] & ST1_OR) {\n\t\t\tif (drive_params[current_drive].flags & FTD_MSG)\n\t\t\t\tDPRINT(\"Over/Underrun - retrying\\n\");\n\t\t\tbad = 0;\n\t\t} else if (*errors >= drive_params[current_drive].max_errors.reporting) {\n\t\t\tprint_errors();\n\t\t}\n\t\tif (reply_buffer[ST2] & ST2_WC || reply_buffer[ST2] & ST2_BC)\n\t\t\t/* wrong cylinder => recal */\n\t\t\tdrive_state[current_drive].track = NEED_2_RECAL;\n\t\treturn bad;\n\tcase 0x80:\t\t/* invalid command given */\n\t\tDPRINT(\"Invalid FDC command given!\\n\");\n\t\tcont->done(0);\n\t\treturn 2;\n\tcase 0xc0:\n\t\tDPRINT(\"Abnormal termination caused by polling\\n\");\n\t\tcont->error();\n\t\treturn 2;\n\tdefault:\t\t/* (0) Normal command termination */\n\t\treturn 0;\n\t}\n}\n\n/*\n * This routine is called when everything should be correctly set up\n * for the transfer (i.e. floppy motor is on, the correct floppy is\n * selected, and the head is sitting on the right track).\n */\nstatic void setup_rw_floppy(void)\n{\n\tint i;\n\tint r;\n\tint flags;\n\tunsigned long ready_date;\n\tvoid (*function)(void);\n\n\tflags = raw_cmd->flags;\n\tif (flags & (FD_RAW_READ | FD_RAW_WRITE))\n\t\tflags |= FD_RAW_INTR;\n\n\tif ((flags & FD_RAW_SPIN) && !(flags & FD_RAW_NO_MOTOR)) {\n\t\tready_date = drive_state[current_drive].spinup_date + drive_params[current_drive].spinup;\n\t\t/* If spinup will take a long time, rerun scandrives\n\t\t * again just before spinup completion. Beware that\n\t\t * after scandrives, we must again wait for selection.\n\t\t */\n\t\tif (time_after(ready_date, jiffies + drive_params[current_drive].select_delay)) {\n\t\t\tready_date -= drive_params[current_drive].select_delay;\n\t\t\tfunction = floppy_start;\n\t\t} else\n\t\t\tfunction = setup_rw_floppy;\n\n\t\t/* wait until the floppy is spinning fast enough */\n\t\tif (fd_wait_for_completion(ready_date, function))\n\t\t\treturn;\n\t}\n\tif ((flags & FD_RAW_READ) || (flags & FD_RAW_WRITE))\n\t\tsetup_DMA();\n\n\tif (flags & FD_RAW_INTR)\n\t\tdo_floppy = main_command_interrupt;\n\n\tr = 0;\n\tfor (i = 0; i < raw_cmd->cmd_count; i++)\n\t\tr |= output_byte(current_fdc, raw_cmd->fullcmd[i]);\n\n\tdebugt(__func__, \"rw_command\");\n\n\tif (r) {\n\t\tcont->error();\n\t\treset_fdc();\n\t\treturn;\n\t}\n\n\tif (!(flags & FD_RAW_INTR)) {\n\t\tinr = result(current_fdc);\n\t\tcont->interrupt();\n\t} else if (flags & FD_RAW_NEED_DISK)\n\t\tfd_watchdog();\n}\n\nstatic int blind_seek;\n\n/*\n * This is the routine called after every seek (or recalibrate) interrupt\n * from the floppy controller.\n */\nstatic void seek_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tif (inr != 2 || (reply_buffer[ST0] & 0xF8) != 0x20) {\n\t\tDPRINT(\"seek failed\\n\");\n\t\tdrive_state[current_drive].track = NEED_2_RECAL;\n\t\tcont->error();\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (drive_state[current_drive].track >= 0 &&\n\t    drive_state[current_drive].track != reply_buffer[ST1] &&\n\t    !blind_seek) {\n\t\tdebug_dcl(drive_params[current_drive].flags,\n\t\t\t  \"clearing NEWCHANGE flag because of effective seek\\n\");\n\t\tdebug_dcl(drive_params[current_drive].flags, \"jiffies=%lu\\n\",\n\t\t\t  jiffies);\n\t\tclear_bit(FD_DISK_NEWCHANGE_BIT,\n\t\t\t  &drive_state[current_drive].flags);\n\t\t\t\t\t/* effective seek */\n\t\tdrive_state[current_drive].select_date = jiffies;\n\t}\n\tdrive_state[current_drive].track = reply_buffer[ST1];\n\tfloppy_ready();\n}\n\nstatic void check_wp(int fdc, int drive)\n{\n\tif (test_bit(FD_VERIFY_BIT, &drive_state[drive].flags)) {\n\t\t\t\t\t/* check write protection */\n\t\toutput_byte(fdc, FD_GETSTATUS);\n\t\toutput_byte(fdc, UNIT(drive));\n\t\tif (result(fdc) != 1) {\n\t\t\tfdc_state[fdc].reset = 1;\n\t\t\treturn;\n\t\t}\n\t\tclear_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tclear_bit(FD_NEED_TWADDLE_BIT,\n\t\t\t  &drive_state[drive].flags);\n\t\tdebug_dcl(drive_params[drive].flags,\n\t\t\t  \"checking whether disk is write protected\\n\");\n\t\tdebug_dcl(drive_params[drive].flags, \"wp=%x\\n\",\n\t\t\t  reply_buffer[ST3] & 0x40);\n\t\tif (!(reply_buffer[ST3] & 0x40))\n\t\t\tset_bit(FD_DISK_WRITABLE_BIT,\n\t\t\t\t&drive_state[drive].flags);\n\t\telse\n\t\t\tclear_bit(FD_DISK_WRITABLE_BIT,\n\t\t\t\t  &drive_state[drive].flags);\n\t}\n}\n\nstatic void seek_floppy(void)\n{\n\tint track;\n\n\tblind_seek = 0;\n\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from %s\\n\", __func__);\n\n\tif (!test_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags) &&\n\t    disk_change(current_drive) && (raw_cmd->flags & FD_RAW_NEED_DISK)) {\n\t\t/* the media changed flag should be cleared after the seek.\n\t\t * If it isn't, this means that there is really no disk in\n\t\t * the drive.\n\t\t */\n\t\tset_bit(FD_DISK_CHANGED_BIT,\n\t\t\t&drive_state[current_drive].flags);\n\t\tcont->done(0);\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (drive_state[current_drive].track <= NEED_1_RECAL) {\n\t\trecalibrate_floppy();\n\t\treturn;\n\t} else if (test_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags) &&\n\t\t   (raw_cmd->flags & FD_RAW_NEED_DISK) &&\n\t\t   (drive_state[current_drive].track <= NO_TRACK || drive_state[current_drive].track == raw_cmd->track)) {\n\t\t/* we seek to clear the media-changed condition. Does anybody\n\t\t * know a more elegant way, which works on all drives? */\n\t\tif (raw_cmd->track)\n\t\t\ttrack = raw_cmd->track - 1;\n\t\telse {\n\t\t\tif (drive_params[current_drive].flags & FD_SILENT_DCL_CLEAR) {\n\t\t\t\tset_dor(current_fdc, ~(0x10 << UNIT(current_drive)), 0);\n\t\t\t\tblind_seek = 1;\n\t\t\t\traw_cmd->flags |= FD_RAW_NEED_SEEK;\n\t\t\t}\n\t\t\ttrack = 1;\n\t\t}\n\t} else {\n\t\tcheck_wp(current_fdc, current_drive);\n\t\tif (raw_cmd->track != drive_state[current_drive].track &&\n\t\t    (raw_cmd->flags & FD_RAW_NEED_SEEK))\n\t\t\ttrack = raw_cmd->track;\n\t\telse {\n\t\t\tsetup_rw_floppy();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdo_floppy = seek_interrupt;\n\toutput_byte(current_fdc, FD_SEEK);\n\toutput_byte(current_fdc, UNIT(current_drive));\n\tif (output_byte(current_fdc, track) < 0) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tdebugt(__func__, \"\");\n}\n\nstatic void recal_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tif (inr != 2)\n\t\tfdc_state[current_fdc].reset = 1;\n\telse if (reply_buffer[ST0] & ST0_ECE) {\n\t\tswitch (drive_state[current_drive].track) {\n\t\tcase NEED_1_RECAL:\n\t\t\tdebugt(__func__, \"need 1 recal\");\n\t\t\t/* after a second recalibrate, we still haven't\n\t\t\t * reached track 0. Probably no drive. Raise an\n\t\t\t * error, as failing immediately might upset\n\t\t\t * computers possessed by the Devil :-) */\n\t\t\tcont->error();\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\tcase NEED_2_RECAL:\n\t\t\tdebugt(__func__, \"need 2 recal\");\n\t\t\t/* If we already did a recalibrate,\n\t\t\t * and we are not at track 0, this\n\t\t\t * means we have moved. (The only way\n\t\t\t * not to move at recalibration is to\n\t\t\t * be already at track 0.) Clear the\n\t\t\t * new change flag */\n\t\t\tdebug_dcl(drive_params[current_drive].flags,\n\t\t\t\t  \"clearing NEWCHANGE flag because of second recalibrate\\n\");\n\n\t\t\tclear_bit(FD_DISK_NEWCHANGE_BIT,\n\t\t\t\t  &drive_state[current_drive].flags);\n\t\t\tdrive_state[current_drive].select_date = jiffies;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tdebugt(__func__, \"default\");\n\t\t\t/* Recalibrate moves the head by at\n\t\t\t * most 80 steps. If after one\n\t\t\t * recalibrate we don't have reached\n\t\t\t * track 0, this might mean that we\n\t\t\t * started beyond track 80.  Try\n\t\t\t * again.  */\n\t\t\tdrive_state[current_drive].track = NEED_1_RECAL;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tdrive_state[current_drive].track = reply_buffer[ST1];\n\tfloppy_ready();\n}\n\nstatic void print_result(char *message, int inr)\n{\n\tint i;\n\n\tDPRINT(\"%s \", message);\n\tif (inr >= 0)\n\t\tfor (i = 0; i < inr; i++)\n\t\t\tpr_cont(\"repl[%d]=%x \", i, reply_buffer[i]);\n\tpr_cont(\"\\n\");\n}\n\n/* interrupt handler. Note that this can be called externally on the Sparc */\nirqreturn_t floppy_interrupt(int irq, void *dev_id)\n{\n\tint do_print;\n\tunsigned long f;\n\tvoid (*handler)(void) = do_floppy;\n\n\tlasthandler = handler;\n\tinterruptjiffies = jiffies;\n\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(f);\n\n\tdo_floppy = NULL;\n\tif (current_fdc >= N_FDC || fdc_state[current_fdc].address == -1) {\n\t\t/* we don't even know which FDC is the culprit */\n\t\tpr_info(\"DOR0=%x\\n\", fdc_state[0].dor);\n\t\tpr_info(\"floppy interrupt on bizarre fdc %d\\n\", current_fdc);\n\t\tpr_info(\"handler=%ps\\n\", handler);\n\t\tis_alive(__func__, \"bizarre fdc\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tfdc_state[current_fdc].reset = 0;\n\t/* We have to clear the reset flag here, because apparently on boxes\n\t * with level triggered interrupts (PS/2, Sparc, ...), it is needed to\n\t * emit SENSEI's to clear the interrupt line. And fdc_state[fdc].reset\n\t * blocks the emission of the SENSEI's.\n\t * It is OK to emit floppy commands because we are in an interrupt\n\t * handler here, and thus we have to fear no interference of other\n\t * activity.\n\t */\n\n\tdo_print = !handler && print_unex && initialized;\n\n\tinr = result(current_fdc);\n\tif (do_print)\n\t\tprint_result(\"unexpected interrupt\", inr);\n\tif (inr == 0) {\n\t\tint max_sensei = 4;\n\t\tdo {\n\t\t\toutput_byte(current_fdc, FD_SENSEI);\n\t\t\tinr = result(current_fdc);\n\t\t\tif (do_print)\n\t\t\t\tprint_result(\"sensei\", inr);\n\t\t\tmax_sensei--;\n\t\t} while ((reply_buffer[ST0] & 0x83) != UNIT(current_drive) &&\n\t\t\t inr == 2 && max_sensei);\n\t}\n\tif (!handler) {\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn IRQ_NONE;\n\t}\n\tschedule_bh(handler);\n\tis_alive(__func__, \"normal interrupt end\");\n\n\t/* FIXME! Was it really for us? */\n\treturn IRQ_HANDLED;\n}\n\nstatic void recalibrate_floppy(void)\n{\n\tdebugt(__func__, \"\");\n\tdo_floppy = recal_interrupt;\n\toutput_byte(current_fdc, FD_RECALIBRATE);\n\tif (output_byte(current_fdc, UNIT(current_drive)) < 0)\n\t\treset_fdc();\n}\n\n/*\n * Must do 4 FD_SENSEIs after reset because of ``drive polling''.\n */\nstatic void reset_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tresult(current_fdc);\t\t/* get the status ready for set_fdc */\n\tif (fdc_state[current_fdc].reset) {\n\t\tpr_info(\"reset set in interrupt, calling %ps\\n\", cont->error);\n\t\tcont->error();\t/* a reset just after a reset. BAD! */\n\t}\n\tcont->redo();\n}\n\n/*\n * reset is done by pulling bit 2 of DOR low for a while (old FDCs),\n * or by setting the self clearing bit 7 of STATUS (newer FDCs).\n * This WILL trigger an interrupt, causing the handlers in the current\n * cont's ->redo() to be called via reset_interrupt().\n */\nstatic void reset_fdc(void)\n{\n\tunsigned long flags;\n\n\tdo_floppy = reset_interrupt;\n\tfdc_state[current_fdc].reset = 0;\n\treset_fdc_info(current_fdc, 0);\n\n\t/* Pseudo-DMA may intercept 'reset finished' interrupt.  */\n\t/* Irrelevant for systems with true DMA (i386).          */\n\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\n\tif (fdc_state[current_fdc].version >= FDC_82072A)\n\t\tfdc_outb(0x80 | (fdc_state[current_fdc].dtr & 3),\n\t\t\t current_fdc, FD_STATUS);\n\telse {\n\t\tfdc_outb(fdc_state[current_fdc].dor & ~0x04, current_fdc, FD_DOR);\n\t\tudelay(FD_RESET_DELAY);\n\t\tfdc_outb(fdc_state[current_fdc].dor, current_fdc, FD_DOR);\n\t}\n}\n\nstatic void show_floppy(int fdc)\n{\n\tint i;\n\n\tpr_info(\"\\n\");\n\tpr_info(\"floppy driver state\\n\");\n\tpr_info(\"-------------------\\n\");\n\tpr_info(\"now=%lu last interrupt=%lu diff=%lu last called handler=%ps\\n\",\n\t\tjiffies, interruptjiffies, jiffies - interruptjiffies,\n\t\tlasthandler);\n\n\tpr_info(\"timeout_message=%s\\n\", timeout_message);\n\tpr_info(\"last output bytes:\\n\");\n\tfor (i = 0; i < OLOGSIZE; i++)\n\t\tpr_info(\"%2x %2x %lu\\n\",\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].data,\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].status,\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].jiffies);\n\tpr_info(\"last result at %lu\\n\", resultjiffies);\n\tpr_info(\"last redo_fd_request at %lu\\n\", lastredo);\n\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_NONE, 16, 1,\n\t\t       reply_buffer, resultsize, true);\n\n\tpr_info(\"status=%x\\n\", fdc_inb(fdc, FD_STATUS));\n\tpr_info(\"fdc_busy=%lu\\n\", fdc_busy);\n\tif (do_floppy)\n\t\tpr_info(\"do_floppy=%ps\\n\", do_floppy);\n\tif (work_pending(&floppy_work))\n\t\tpr_info(\"floppy_work.func=%ps\\n\", floppy_work.func);\n\tif (delayed_work_pending(&fd_timer))\n\t\tpr_info(\"delayed work.function=%p expires=%ld\\n\",\n\t\t       fd_timer.work.func,\n\t\t       fd_timer.timer.expires - jiffies);\n\tif (delayed_work_pending(&fd_timeout))\n\t\tpr_info(\"timer_function=%p expires=%ld\\n\",\n\t\t       fd_timeout.work.func,\n\t\t       fd_timeout.timer.expires - jiffies);\n\n\tpr_info(\"cont=%p\\n\", cont);\n\tpr_info(\"current_req=%p\\n\", current_req);\n\tpr_info(\"command_status=%d\\n\", command_status);\n\tpr_info(\"\\n\");\n}\n\nstatic void floppy_shutdown(struct work_struct *arg)\n{\n\tunsigned long flags;\n\n\tif (initialized)\n\t\tshow_floppy(current_fdc);\n\tcancel_activity();\n\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\n\t/* avoid dma going to a random drive after shutdown */\n\n\tif (initialized)\n\t\tDPRINT(\"floppy timeout called\\n\");\n\tfdc_state[current_fdc].reset = 1;\n\tif (cont) {\n\t\tcont->done(0);\n\t\tcont->redo();\t/* this will recall reset when needed */\n\t} else {\n\t\tpr_info(\"no cont in shutdown!\\n\");\n\t\tprocess_fd_request();\n\t}\n\tis_alive(__func__, \"\");\n}\n\n/* start motor, check media-changed condition and write protection */\nstatic int start_motor(void (*function)(void))\n{\n\tint mask;\n\tint data;\n\n\tmask = 0xfc;\n\tdata = UNIT(current_drive);\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR)) {\n\t\tif (!(fdc_state[current_fdc].dor & (0x10 << UNIT(current_drive)))) {\n\t\t\tset_debugt();\n\t\t\t/* no read since this drive is running */\n\t\t\tdrive_state[current_drive].first_read_date = 0;\n\t\t\t/* note motor start time if motor is not yet running */\n\t\t\tdrive_state[current_drive].spinup_date = jiffies;\n\t\t\tdata |= (0x10 << UNIT(current_drive));\n\t\t}\n\t} else if (fdc_state[current_fdc].dor & (0x10 << UNIT(current_drive)))\n\t\tmask &= ~(0x10 << UNIT(current_drive));\n\n\t/* starts motor and selects floppy */\n\tdel_timer(motor_off_timer + current_drive);\n\tset_dor(current_fdc, mask, data);\n\n\t/* wait_for_completion also schedules reset if needed. */\n\treturn fd_wait_for_completion(drive_state[current_drive].select_date + drive_params[current_drive].select_delay,\n\t\t\t\t      function);\n}\n\nstatic void floppy_ready(void)\n{\n\tif (fdc_state[current_fdc].reset) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tif (start_motor(floppy_ready))\n\t\treturn;\n\tif (fdc_dtr())\n\t\treturn;\n\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from floppy_ready\\n\");\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR) &&\n\t    disk_change(current_drive) && !drive_params[current_drive].select_delay)\n\t\ttwaddle(current_fdc, current_drive);\t/* this clears the dcl on certain\n\t\t\t\t * drive/controller combinations */\n\n#ifdef fd_chose_dma_mode\n\tif ((raw_cmd->flags & FD_RAW_READ) || (raw_cmd->flags & FD_RAW_WRITE)) {\n\t\tunsigned long flags = claim_dma_lock();\n\t\tfd_chose_dma_mode(raw_cmd->kernel_data, raw_cmd->length);\n\t\trelease_dma_lock(flags);\n\t}\n#endif\n\n\tif (raw_cmd->flags & (FD_RAW_NEED_SEEK | FD_RAW_NEED_DISK)) {\n\t\tperpendicular_mode(current_fdc);\n\t\tfdc_specify(current_fdc, current_drive); /* must be done here because of hut, hlt ... */\n\t\tseek_floppy();\n\t} else {\n\t\tif ((raw_cmd->flags & FD_RAW_READ) ||\n\t\t    (raw_cmd->flags & FD_RAW_WRITE))\n\t\t\tfdc_specify(current_fdc, current_drive);\n\t\tsetup_rw_floppy();\n\t}\n}\n\nstatic void floppy_start(void)\n{\n\treschedule_timeout(current_drive, \"floppy start\");\n\n\tscandrives();\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"setting NEWCHANGE in floppy_start\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags);\n\tfloppy_ready();\n}\n\n/*\n * ========================================================================\n * here ends the bottom half. Exported routines are:\n * floppy_start, floppy_off, floppy_ready, lock_fdc, unlock_fdc, set_fdc,\n * start_motor, reset_fdc, reset_fdc_info, interpret_errors.\n * Initialization also uses output_byte, result, set_dor, floppy_interrupt\n * and set_dor.\n * ========================================================================\n */\n/*\n * General purpose continuations.\n * ==============================\n */\n\nstatic void do_wakeup(void)\n{\n\treschedule_timeout(MAXTIMEOUT, \"do wakeup\");\n\tcont = NULL;\n\tcommand_status += 2;\n\twake_up(&command_done);\n}\n\nstatic const struct cont_t wakeup_cont = {\n\t.interrupt\t= empty,\n\t.redo\t\t= do_wakeup,\n\t.error\t\t= empty,\n\t.done\t\t= (done_f)empty\n};\n\nstatic const struct cont_t intr_cont = {\n\t.interrupt\t= empty,\n\t.redo\t\t= process_fd_request,\n\t.error\t\t= empty,\n\t.done\t\t= (done_f)empty\n};\n\n/* schedules handler, waiting for completion. May be interrupted, will then\n * return -EINTR, in which case the driver will automatically be unlocked.\n */\nstatic int wait_til_done(void (*handler)(void), bool interruptible)\n{\n\tint ret;\n\n\tschedule_bh(handler);\n\n\tif (interruptible)\n\t\twait_event_interruptible(command_done, command_status >= 2);\n\telse\n\t\twait_event(command_done, command_status >= 2);\n\n\tif (command_status < 2) {\n\t\tcancel_activity();\n\t\tcont = &intr_cont;\n\t\treset_fdc();\n\t\treturn -EINTR;\n\t}\n\n\tif (fdc_state[current_fdc].reset)\n\t\tcommand_status = FD_COMMAND_ERROR;\n\tif (command_status == FD_COMMAND_OKAY)\n\t\tret = 0;\n\telse\n\t\tret = -EIO;\n\tcommand_status = FD_COMMAND_NONE;\n\treturn ret;\n}\n\nstatic void generic_done(int result)\n{\n\tcommand_status = result;\n\tcont = &wakeup_cont;\n}\n\nstatic void generic_success(void)\n{\n\tcont->done(1);\n}\n\nstatic void generic_failure(void)\n{\n\tcont->done(0);\n}\n\nstatic void success_and_wakeup(void)\n{\n\tgeneric_success();\n\tcont->redo();\n}\n\n/*\n * formatting and rw support.\n * ==========================\n */\n\nstatic int next_valid_format(int drive)\n{\n\tint probed_format;\n\n\tprobed_format = drive_state[drive].probed_format;\n\twhile (1) {\n\t\tif (probed_format >= FD_AUTODETECT_SIZE ||\n\t\t    !drive_params[drive].autodetect[probed_format]) {\n\t\t\tdrive_state[drive].probed_format = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif (floppy_type[drive_params[drive].autodetect[probed_format]].sect) {\n\t\t\tdrive_state[drive].probed_format = probed_format;\n\t\t\treturn 0;\n\t\t}\n\t\tprobed_format++;\n\t}\n}\n\nstatic void bad_flp_intr(void)\n{\n\tint err_count;\n\n\tif (probing) {\n\t\tdrive_state[current_drive].probed_format++;\n\t\tif (!next_valid_format(current_drive))\n\t\t\treturn;\n\t}\n\terr_count = ++(*errors);\n\tINFBOUND(write_errors[current_drive].badness, err_count);\n\tif (err_count > drive_params[current_drive].max_errors.abort)\n\t\tcont->done(0);\n\tif (err_count > drive_params[current_drive].max_errors.reset)\n\t\tfdc_state[current_fdc].reset = 1;\n\telse if (err_count > drive_params[current_drive].max_errors.recal)\n\t\tdrive_state[current_drive].track = NEED_2_RECAL;\n}\n\nstatic void set_floppy(int drive)\n{\n\tint type = ITYPE(drive_state[drive].fd_device);\n\n\tif (type)\n\t\t_floppy = floppy_type + type;\n\telse\n\t\t_floppy = current_type[drive];\n}\n\n/*\n * formatting support.\n * ===================\n */\nstatic void format_interrupt(void)\n{\n\tswitch (interpret_errors()) {\n\tcase 1:\n\t\tcont->error();\n\t\tbreak;\n\tcase 2:\n\t\tbreak;\n\tcase 0:\n\t\tcont->done(1);\n\t}\n\tcont->redo();\n}\n\n#define FM_MODE(x, y) ((y) & ~(((x)->rate & 0x80) >> 1))\n#define CT(x) ((x) | 0xc0)\n\nstatic void setup_format_params(int track)\n{\n\tint n;\n\tint il;\n\tint count;\n\tint head_shift;\n\tint track_shift;\n\tstruct fparm {\n\t\tunsigned char track, head, sect, size;\n\t} *here = (struct fparm *)floppy_track_buffer;\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->track = track;\n\n\traw_cmd->flags = (FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN |\n\t\t\t  FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\traw_cmd->cmd_count = NR_F;\n\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_FORMAT);\n\traw_cmd->cmd[DR_SELECT] = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);\n\traw_cmd->cmd[F_SIZECODE] = FD_SIZECODE(_floppy);\n\traw_cmd->cmd[F_SECT_PER_TRACK] = _floppy->sect << 2 >> raw_cmd->cmd[F_SIZECODE];\n\traw_cmd->cmd[F_GAP] = _floppy->fmt_gap;\n\traw_cmd->cmd[F_FILL] = FD_FILL_BYTE;\n\n\traw_cmd->kernel_data = floppy_track_buffer;\n\traw_cmd->length = 4 * raw_cmd->cmd[F_SECT_PER_TRACK];\n\n\tif (!raw_cmd->cmd[F_SECT_PER_TRACK])\n\t\treturn;\n\n\t/* allow for about 30ms for data transport per track */\n\thead_shift = (raw_cmd->cmd[F_SECT_PER_TRACK] + 5) / 6;\n\n\t/* a ``cylinder'' is two tracks plus a little stepping time */\n\ttrack_shift = 2 * head_shift + 3;\n\n\t/* position of logical sector 1 on this track */\n\tn = (track_shift * format_req.track + head_shift * format_req.head)\n\t    % raw_cmd->cmd[F_SECT_PER_TRACK];\n\n\t/* determine interleave */\n\til = 1;\n\tif (_floppy->fmt_gap < 0x22)\n\t\til++;\n\n\t/* initialize field */\n\tfor (count = 0; count < raw_cmd->cmd[F_SECT_PER_TRACK]; ++count) {\n\t\there[count].track = format_req.track;\n\t\there[count].head = format_req.head;\n\t\there[count].sect = 0;\n\t\there[count].size = raw_cmd->cmd[F_SIZECODE];\n\t}\n\t/* place logical sectors */\n\tfor (count = 1; count <= raw_cmd->cmd[F_SECT_PER_TRACK]; ++count) {\n\t\there[n].sect = count;\n\t\tn = (n + il) % raw_cmd->cmd[F_SECT_PER_TRACK];\n\t\tif (here[n].sect) {\t/* sector busy, find next free sector */\n\t\t\t++n;\n\t\t\tif (n >= raw_cmd->cmd[F_SECT_PER_TRACK]) {\n\t\t\t\tn -= raw_cmd->cmd[F_SECT_PER_TRACK];\n\t\t\t\twhile (here[n].sect)\n\t\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t}\n\tif (_floppy->stretch & FD_SECTBASEMASK) {\n\t\tfor (count = 0; count < raw_cmd->cmd[F_SECT_PER_TRACK]; count++)\n\t\t\there[count].sect += FD_SECTBASE(_floppy) - 1;\n\t}\n}\n\nstatic void redo_format(void)\n{\n\tbuffer_track = -1;\n\tsetup_format_params(format_req.track << STRETCH(_floppy));\n\tfloppy_start();\n\tdebugt(__func__, \"queue format request\");\n}\n\nstatic const struct cont_t format_cont = {\n\t.interrupt\t= format_interrupt,\n\t.redo\t\t= redo_format,\n\t.error\t\t= bad_flp_intr,\n\t.done\t\t= generic_done\n};\n\nstatic int do_format(int drive, struct format_descr *tmp_format_req)\n{\n\tint ret;\n\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\n\tset_floppy(drive);\n\tif (!_floppy ||\n\t    _floppy->track > drive_params[current_drive].tracks ||\n\t    tmp_format_req->track >= _floppy->track ||\n\t    tmp_format_req->head >= _floppy->head ||\n\t    (_floppy->sect << 2) % (1 << FD_SIZECODE(_floppy)) ||\n\t    !_floppy->fmt_gap) {\n\t\tprocess_fd_request();\n\t\treturn -EINVAL;\n\t}\n\tformat_req = *tmp_format_req;\n\tformat_errors = 0;\n\tcont = &format_cont;\n\terrors = &format_errors;\n\tret = wait_til_done(redo_format, true);\n\tif (ret == -EINTR)\n\t\treturn -EINTR;\n\tprocess_fd_request();\n\treturn ret;\n}\n\n/*\n * Buffer read/write and support\n * =============================\n */\n\nstatic void floppy_end_request(struct request *req, blk_status_t error)\n{\n\tunsigned int nr_sectors = current_count_sectors;\n\tunsigned int drive = (unsigned long)req->q->disk->private_data;\n\n\t/* current_count_sectors can be zero if transfer failed */\n\tif (error)\n\t\tnr_sectors = blk_rq_cur_sectors(req);\n\tif (blk_update_request(req, error, nr_sectors << 9))\n\t\treturn;\n\t__blk_mq_end_request(req, error);\n\n\t/* We're done with the request */\n\tfloppy_off(drive);\n\tcurrent_req = NULL;\n}\n\n/* new request_done. Can handle physical sectors which are smaller than a\n * logical buffer */\nstatic void request_done(int uptodate)\n{\n\tstruct request *req = current_req;\n\tint block;\n\tchar msg[sizeof(\"request done \") + sizeof(int) * 3];\n\n\tprobing = 0;\n\tsnprintf(msg, sizeof(msg), \"request done %d\", uptodate);\n\treschedule_timeout(MAXTIMEOUT, msg);\n\n\tif (!req) {\n\t\tpr_info(\"floppy.c: no request in request_done\\n\");\n\t\treturn;\n\t}\n\n\tif (uptodate) {\n\t\t/* maintain values for invalidation on geometry\n\t\t * change */\n\t\tblock = current_count_sectors + blk_rq_pos(req);\n\t\tINFBOUND(drive_state[current_drive].maxblock, block);\n\t\tif (block > _floppy->sect)\n\t\t\tdrive_state[current_drive].maxtrack = 1;\n\n\t\tfloppy_end_request(req, 0);\n\t} else {\n\t\tif (rq_data_dir(req) == WRITE) {\n\t\t\t/* record write error information */\n\t\t\twrite_errors[current_drive].write_errors++;\n\t\t\tif (write_errors[current_drive].write_errors == 1) {\n\t\t\t\twrite_errors[current_drive].first_error_sector = blk_rq_pos(req);\n\t\t\t\twrite_errors[current_drive].first_error_generation = drive_state[current_drive].generation;\n\t\t\t}\n\t\t\twrite_errors[current_drive].last_error_sector = blk_rq_pos(req);\n\t\t\twrite_errors[current_drive].last_error_generation = drive_state[current_drive].generation;\n\t\t}\n\t\tfloppy_end_request(req, BLK_STS_IOERR);\n\t}\n}\n\n/* Interrupt handler evaluating the result of the r/w operation */\nstatic void rw_interrupt(void)\n{\n\tint eoc;\n\tint ssize;\n\tint heads;\n\tint nr_sectors;\n\n\tif (reply_buffer[R_HEAD] >= 2) {\n\t\t/* some Toshiba floppy controllers occasionnally seem to\n\t\t * return bogus interrupts after read/write operations, which\n\t\t * can be recognized by a bad head number (>= 2) */\n\t\treturn;\n\t}\n\n\tif (!drive_state[current_drive].first_read_date)\n\t\tdrive_state[current_drive].first_read_date = jiffies;\n\n\tssize = DIV_ROUND_UP(1 << raw_cmd->cmd[SIZECODE], 4);\n\n\tif (reply_buffer[ST1] & ST1_EOC)\n\t\teoc = 1;\n\telse\n\t\teoc = 0;\n\n\tif (raw_cmd->cmd[COMMAND] & 0x80)\n\t\theads = 2;\n\telse\n\t\theads = 1;\n\n\tnr_sectors = (((reply_buffer[R_TRACK] - raw_cmd->cmd[TRACK]) * heads +\n\t\t       reply_buffer[R_HEAD] - raw_cmd->cmd[HEAD]) * raw_cmd->cmd[SECT_PER_TRACK] +\n\t\t      reply_buffer[R_SECTOR] - raw_cmd->cmd[SECTOR] + eoc) << raw_cmd->cmd[SIZECODE] >> 2;\n\n\tif (nr_sectors / ssize >\n\t    DIV_ROUND_UP(in_sector_offset + current_count_sectors, ssize)) {\n\t\tDPRINT(\"long rw: %x instead of %lx\\n\",\n\t\t       nr_sectors, current_count_sectors);\n\t\tpr_info(\"rs=%d s=%d\\n\", reply_buffer[R_SECTOR],\n\t\t\traw_cmd->cmd[SECTOR]);\n\t\tpr_info(\"rh=%d h=%d\\n\", reply_buffer[R_HEAD],\n\t\t\traw_cmd->cmd[HEAD]);\n\t\tpr_info(\"rt=%d t=%d\\n\", reply_buffer[R_TRACK],\n\t\t\traw_cmd->cmd[TRACK]);\n\t\tpr_info(\"heads=%d eoc=%d\\n\", heads, eoc);\n\t\tpr_info(\"spt=%d st=%d ss=%d\\n\",\n\t\t\traw_cmd->cmd[SECT_PER_TRACK], fsector_t, ssize);\n\t\tpr_info(\"in_sector_offset=%d\\n\", in_sector_offset);\n\t}\n\n\tnr_sectors -= in_sector_offset;\n\tINFBOUND(nr_sectors, 0);\n\tSUPBOUND(current_count_sectors, nr_sectors);\n\n\tswitch (interpret_errors()) {\n\tcase 2:\n\t\tcont->redo();\n\t\treturn;\n\tcase 1:\n\t\tif (!current_count_sectors) {\n\t\t\tcont->error();\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tif (!current_count_sectors) {\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\t}\n\t\tcurrent_type[current_drive] = _floppy;\n\t\tfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\n\t\tbreak;\n\t}\n\n\tif (probing) {\n\t\tif (drive_params[current_drive].flags & FTD_MSG)\n\t\t\tDPRINT(\"Auto-detected floppy type %s in fd%d\\n\",\n\t\t\t       _floppy->name, current_drive);\n\t\tcurrent_type[current_drive] = _floppy;\n\t\tfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\n\t\tprobing = 0;\n\t}\n\n\tif (CT(raw_cmd->cmd[COMMAND]) != FD_READ) {\n\t\t/* transfer directly from buffer */\n\t\tcont->done(1);\n\t} else {\n\t\tbuffer_track = raw_cmd->track;\n\t\tbuffer_drive = current_drive;\n\t\tINFBOUND(buffer_max, nr_sectors + fsector_t);\n\t}\n\tcont->redo();\n}\n\n/* Compute the maximal transfer size */\nstatic int transfer_size(int ssize, int max_sector, int max_size)\n{\n\tSUPBOUND(max_sector, fsector_t + max_size);\n\n\t/* alignment */\n\tmax_sector -= (max_sector % _floppy->sect) % ssize;\n\n\t/* transfer size, beginning not aligned */\n\tcurrent_count_sectors = max_sector - fsector_t;\n\n\treturn max_sector;\n}\n\n/*\n * Move data from/to the track buffer to/from the buffer cache.\n */\nstatic void copy_buffer(int ssize, int max_sector, int max_sector_2)\n{\n\tint remaining;\t\t/* number of transferred 512-byte sectors */\n\tstruct bio_vec bv;\n\tchar *dma_buffer;\n\tint size;\n\tstruct req_iterator iter;\n\n\tmax_sector = transfer_size(ssize,\n\t\t\t\t   min(max_sector, max_sector_2),\n\t\t\t\t   blk_rq_sectors(current_req));\n\n\tif (current_count_sectors <= 0 && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE &&\n\t    buffer_max > fsector_t + blk_rq_sectors(current_req))\n\t\tcurrent_count_sectors = min_t(int, buffer_max - fsector_t,\n\t\t\t\t\t      blk_rq_sectors(current_req));\n\n\tremaining = current_count_sectors << 9;\n\tif (remaining > blk_rq_bytes(current_req) && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\tDPRINT(\"in copy buffer\\n\");\n\t\tpr_info(\"current_count_sectors=%ld\\n\", current_count_sectors);\n\t\tpr_info(\"remaining=%d\\n\", remaining >> 9);\n\t\tpr_info(\"current_req->nr_sectors=%u\\n\",\n\t\t\tblk_rq_sectors(current_req));\n\t\tpr_info(\"current_req->current_nr_sectors=%u\\n\",\n\t\t\tblk_rq_cur_sectors(current_req));\n\t\tpr_info(\"max_sector=%d\\n\", max_sector);\n\t\tpr_info(\"ssize=%d\\n\", ssize);\n\t}\n\n\tbuffer_max = max(max_sector, buffer_max);\n\n\tdma_buffer = floppy_track_buffer + ((fsector_t - buffer_min) << 9);\n\n\tsize = blk_rq_cur_bytes(current_req);\n\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (!remaining)\n\t\t\tbreak;\n\n\t\tsize = bv.bv_len;\n\t\tSUPBOUND(size, remaining);\n\t\tif (dma_buffer + size >\n\t\t    floppy_track_buffer + (max_buffer_sectors << 10) ||\n\t\t    dma_buffer < floppy_track_buffer) {\n\t\t\tDPRINT(\"buffer overrun in copy buffer %d\\n\",\n\t\t\t       (int)((floppy_track_buffer - dma_buffer) >> 9));\n\t\t\tpr_info(\"fsector_t=%d buffer_min=%d\\n\",\n\t\t\t\tfsector_t, buffer_min);\n\t\t\tpr_info(\"current_count_sectors=%ld\\n\",\n\t\t\t\tcurrent_count_sectors);\n\t\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\t\t\tpr_info(\"read\\n\");\n\t\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE)\n\t\t\t\tpr_info(\"write\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\t\tmemcpy_to_bvec(&bv, dma_buffer);\n\t\telse\n\t\t\tmemcpy_from_bvec(dma_buffer, &bv);\n\n\t\tremaining -= size;\n\t\tdma_buffer += size;\n\t}\n\tif (remaining) {\n\t\tif (remaining > 0)\n\t\t\tmax_sector -= remaining >> 9;\n\t\tDPRINT(\"weirdness: remaining %d\\n\", remaining >> 9);\n\t}\n}\n\n/* work around a bug in pseudo DMA\n * (on some FDCs) pseudo DMA does not stop when the CPU stops\n * sending data.  Hence we need a different way to signal the\n * transfer length:  We use raw_cmd->cmd[SECT_PER_TRACK].  Unfortunately, this\n * does not work with MT, hence we can only transfer one head at\n * a time\n */\nstatic void virtualdmabug_workaround(void)\n{\n\tint hard_sectors;\n\tint end_sector;\n\n\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\traw_cmd->cmd[COMMAND] &= ~0x80;\t/* switch off multiple track mode */\n\n\t\thard_sectors = raw_cmd->length >> (7 + raw_cmd->cmd[SIZECODE]);\n\t\tend_sector = raw_cmd->cmd[SECTOR] + hard_sectors - 1;\n\t\tif (end_sector > raw_cmd->cmd[SECT_PER_TRACK]) {\n\t\t\tpr_info(\"too many sectors %d > %d\\n\",\n\t\t\t\tend_sector, raw_cmd->cmd[SECT_PER_TRACK]);\n\t\t\treturn;\n\t\t}\n\t\traw_cmd->cmd[SECT_PER_TRACK] = end_sector;\n\t\t\t\t\t/* make sure raw_cmd->cmd[SECT_PER_TRACK]\n\t\t\t\t\t * points to end of transfer */\n\t}\n}\n\n/*\n * Formulate a read/write request.\n * this routine decides where to load the data (directly to buffer, or to\n * tmp floppy area), how much data to load (the size of the buffer, the whole\n * track, or a single sector)\n * All floppy_track_buffer handling goes in here. If we ever add track buffer\n * allocation on the fly, it should be done here. No other part should need\n * modification.\n */\n\nstatic int make_raw_rw_request(void)\n{\n\tint aligned_sector_t;\n\tint max_sector;\n\tint max_size;\n\tint tracksize;\n\tint ssize;\n\n\tif (WARN(max_buffer_sectors == 0, \"VFS: Block I/O scheduled on unopened device\\n\"))\n\t\treturn 0;\n\n\tset_fdc((long)current_req->q->disk->private_data);\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK;\n\traw_cmd->cmd_count = NR_RW;\n\tif (rq_data_dir(current_req) == READ) {\n\t\traw_cmd->flags |= FD_RAW_READ;\n\t\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_READ);\n\t} else if (rq_data_dir(current_req) == WRITE) {\n\t\traw_cmd->flags |= FD_RAW_WRITE;\n\t\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_WRITE);\n\t} else {\n\t\tDPRINT(\"%s: unknown command\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tmax_sector = _floppy->sect * _floppy->head;\n\n\traw_cmd->cmd[TRACK] = (int)blk_rq_pos(current_req) / max_sector;\n\tfsector_t = (int)blk_rq_pos(current_req) % max_sector;\n\tif (_floppy->track && raw_cmd->cmd[TRACK] >= _floppy->track) {\n\t\tif (blk_rq_cur_sectors(current_req) & 1) {\n\t\t\tcurrent_count_sectors = 1;\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\traw_cmd->cmd[HEAD] = fsector_t / _floppy->sect;\n\n\tif (((_floppy->stretch & (FD_SWAPSIDES | FD_SECTBASEMASK)) ||\n\t     test_bit(FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags)) &&\n\t    fsector_t < _floppy->sect)\n\t\tmax_sector = _floppy->sect;\n\n\t/* 2M disks have phantom sectors on the first track */\n\tif ((_floppy->rate & FD_2M) && (!raw_cmd->cmd[TRACK]) && (!raw_cmd->cmd[HEAD])) {\n\t\tmax_sector = 2 * _floppy->sect / 3;\n\t\tif (fsector_t >= max_sector) {\n\t\t\tcurrent_count_sectors =\n\t\t\t    min_t(int, _floppy->sect - fsector_t,\n\t\t\t\t  blk_rq_sectors(current_req));\n\t\t\treturn 1;\n\t\t}\n\t\traw_cmd->cmd[SIZECODE] = 2;\n\t} else\n\t\traw_cmd->cmd[SIZECODE] = FD_SIZECODE(_floppy);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\tif ((_floppy->rate & FD_2M) &&\n\t    (raw_cmd->cmd[TRACK] || raw_cmd->cmd[HEAD]) && raw_cmd->rate == 2)\n\t\traw_cmd->rate = 1;\n\n\tif (raw_cmd->cmd[SIZECODE])\n\t\traw_cmd->cmd[SIZECODE2] = 0xff;\n\telse\n\t\traw_cmd->cmd[SIZECODE2] = 0x80;\n\traw_cmd->track = raw_cmd->cmd[TRACK] << STRETCH(_floppy);\n\traw_cmd->cmd[DR_SELECT] = UNIT(current_drive) + PH_HEAD(_floppy, raw_cmd->cmd[HEAD]);\n\traw_cmd->cmd[GAP] = _floppy->gap;\n\tssize = DIV_ROUND_UP(1 << raw_cmd->cmd[SIZECODE], 4);\n\traw_cmd->cmd[SECT_PER_TRACK] = _floppy->sect << 2 >> raw_cmd->cmd[SIZECODE];\n\traw_cmd->cmd[SECTOR] = ((fsector_t % _floppy->sect) << 2 >> raw_cmd->cmd[SIZECODE]) +\n\t    FD_SECTBASE(_floppy);\n\n\t/* tracksize describes the size which can be filled up with sectors\n\t * of size ssize.\n\t */\n\ttracksize = _floppy->sect - _floppy->sect % ssize;\n\tif (tracksize < _floppy->sect) {\n\t\traw_cmd->cmd[SECT_PER_TRACK]++;\n\t\tif (tracksize <= fsector_t % _floppy->sect)\n\t\t\traw_cmd->cmd[SECTOR]--;\n\n\t\t/* if we are beyond tracksize, fill up using smaller sectors */\n\t\twhile (tracksize <= fsector_t % _floppy->sect) {\n\t\t\twhile (tracksize + ssize > _floppy->sect) {\n\t\t\t\traw_cmd->cmd[SIZECODE]--;\n\t\t\t\tssize >>= 1;\n\t\t\t}\n\t\t\traw_cmd->cmd[SECTOR]++;\n\t\t\traw_cmd->cmd[SECT_PER_TRACK]++;\n\t\t\ttracksize += ssize;\n\t\t}\n\t\tmax_sector = raw_cmd->cmd[HEAD] * _floppy->sect + tracksize;\n\t} else if (!raw_cmd->cmd[TRACK] && !raw_cmd->cmd[HEAD] && !(_floppy->rate & FD_2M) && probing) {\n\t\tmax_sector = _floppy->sect;\n\t} else if (!raw_cmd->cmd[HEAD] && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\t/* for virtual DMA bug workaround */\n\t\tmax_sector = _floppy->sect;\n\t}\n\n\tin_sector_offset = (fsector_t % _floppy->sect) % ssize;\n\taligned_sector_t = fsector_t - in_sector_offset;\n\tmax_size = blk_rq_sectors(current_req);\n\tif ((raw_cmd->track == buffer_track) &&\n\t    (current_drive == buffer_drive) &&\n\t    (fsector_t >= buffer_min) && (fsector_t < buffer_max)) {\n\t\t/* data already in track buffer */\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ) {\n\t\t\tcopy_buffer(1, max_sector, buffer_max);\n\t\t\treturn 1;\n\t\t}\n\t} else if (in_sector_offset || blk_rq_sectors(current_req) < ssize) {\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\t\tunsigned int sectors;\n\n\t\t\tsectors = fsector_t + blk_rq_sectors(current_req);\n\t\t\tif (sectors > ssize && sectors < ssize + ssize)\n\t\t\t\tmax_size = ssize + ssize;\n\t\t\telse\n\t\t\t\tmax_size = ssize;\n\t\t}\n\t\traw_cmd->flags &= ~FD_RAW_WRITE;\n\t\traw_cmd->flags |= FD_RAW_READ;\n\t\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_READ);\n\t}\n\n\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\tmax_size = max_sector;\t/* unbounded */\n\n\t/* claim buffer track if needed */\n\tif (buffer_track != raw_cmd->track ||\t/* bad track */\n\t    buffer_drive != current_drive ||\t/* bad drive */\n\t    fsector_t > buffer_max ||\n\t    fsector_t < buffer_min ||\n\t    ((CT(raw_cmd->cmd[COMMAND]) == FD_READ ||\n\t      (!in_sector_offset && blk_rq_sectors(current_req) >= ssize)) &&\n\t     max_sector > 2 * max_buffer_sectors + buffer_min &&\n\t     max_size + fsector_t > 2 * max_buffer_sectors + buffer_min)) {\n\t\t/* not enough space */\n\t\tbuffer_track = -1;\n\t\tbuffer_drive = current_drive;\n\t\tbuffer_max = buffer_min = aligned_sector_t;\n\t}\n\traw_cmd->kernel_data = floppy_track_buffer +\n\t\t((aligned_sector_t - buffer_min) << 9);\n\n\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\t/* copy write buffer to track buffer.\n\t\t * if we get here, we know that the write\n\t\t * is either aligned or the data already in the buffer\n\t\t * (buffer will be overwritten) */\n\t\tif (in_sector_offset && buffer_track == -1)\n\t\t\tDPRINT(\"internal error offset !=0 on write\\n\");\n\t\tbuffer_track = raw_cmd->track;\n\t\tbuffer_drive = current_drive;\n\t\tcopy_buffer(ssize, max_sector,\n\t\t\t    2 * max_buffer_sectors + buffer_min);\n\t} else\n\t\ttransfer_size(ssize, max_sector,\n\t\t\t      2 * max_buffer_sectors + buffer_min -\n\t\t\t      aligned_sector_t);\n\n\t/* round up current_count_sectors to get dma xfer size */\n\traw_cmd->length = in_sector_offset + current_count_sectors;\n\traw_cmd->length = ((raw_cmd->length - 1) | (ssize - 1)) + 1;\n\traw_cmd->length <<= 9;\n\tif ((raw_cmd->length < current_count_sectors << 9) ||\n\t    (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE &&\n\t     (aligned_sector_t + (raw_cmd->length >> 9) > buffer_max ||\n\t      aligned_sector_t < buffer_min)) ||\n\t    raw_cmd->length % (128 << raw_cmd->cmd[SIZECODE]) ||\n\t    raw_cmd->length <= 0 || current_count_sectors <= 0) {\n\t\tDPRINT(\"fractionary current count b=%lx s=%lx\\n\",\n\t\t       raw_cmd->length, current_count_sectors);\n\t\tpr_info(\"addr=%d, length=%ld\\n\",\n\t\t\t(int)((raw_cmd->kernel_data -\n\t\t\t       floppy_track_buffer) >> 9),\n\t\t\tcurrent_count_sectors);\n\t\tpr_info(\"st=%d ast=%d mse=%d msi=%d\\n\",\n\t\t\tfsector_t, aligned_sector_t, max_sector, max_size);\n\t\tpr_info(\"ssize=%x SIZECODE=%d\\n\", ssize, raw_cmd->cmd[SIZECODE]);\n\t\tpr_info(\"command=%x SECTOR=%d HEAD=%d, TRACK=%d\\n\",\n\t\t\traw_cmd->cmd[COMMAND], raw_cmd->cmd[SECTOR],\n\t\t\traw_cmd->cmd[HEAD], raw_cmd->cmd[TRACK]);\n\t\tpr_info(\"buffer drive=%d\\n\", buffer_drive);\n\t\tpr_info(\"buffer track=%d\\n\", buffer_track);\n\t\tpr_info(\"buffer_min=%d\\n\", buffer_min);\n\t\tpr_info(\"buffer_max=%d\\n\", buffer_max);\n\t\treturn 0;\n\t}\n\n\tif (raw_cmd->kernel_data < floppy_track_buffer ||\n\t    current_count_sectors < 0 ||\n\t    raw_cmd->length < 0 ||\n\t    raw_cmd->kernel_data + raw_cmd->length >\n\t    floppy_track_buffer + (max_buffer_sectors << 10)) {\n\t\tDPRINT(\"buffer overrun in schedule dma\\n\");\n\t\tpr_info(\"fsector_t=%d buffer_min=%d current_count=%ld\\n\",\n\t\t\tfsector_t, buffer_min, raw_cmd->length >> 9);\n\t\tpr_info(\"current_count_sectors=%ld\\n\",\n\t\t\tcurrent_count_sectors);\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\t\tpr_info(\"read\\n\");\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE)\n\t\t\tpr_info(\"write\\n\");\n\t\treturn 0;\n\t}\n\tif (raw_cmd->length == 0) {\n\t\tDPRINT(\"zero dma transfer attempted from make_raw_request\\n\");\n\t\treturn 0;\n\t}\n\n\tvirtualdmabug_workaround();\n\treturn 2;\n}\n\nstatic int set_next_request(void)\n{\n\tcurrent_req = list_first_entry_or_null(&floppy_reqs, struct request,\n\t\t\t\t\t       queuelist);\n\tif (current_req) {\n\t\tcurrent_req->error_count = 0;\n\t\tlist_del_init(&current_req->queuelist);\n\t}\n\treturn current_req != NULL;\n}\n\n/* Starts or continues processing request. Will automatically unlock the\n * driver at end of request.\n */\nstatic void redo_fd_request(void)\n{\n\tint drive;\n\tint tmp;\n\n\tlastredo = jiffies;\n\tif (current_drive < N_DRIVE)\n\t\tfloppy_off(current_drive);\n\ndo_request:\n\tif (!current_req) {\n\t\tint pending;\n\n\t\tspin_lock_irq(&floppy_lock);\n\t\tpending = set_next_request();\n\t\tspin_unlock_irq(&floppy_lock);\n\t\tif (!pending) {\n\t\t\tdo_floppy = NULL;\n\t\t\tunlock_fdc();\n\t\t\treturn;\n\t\t}\n\t}\n\tdrive = (long)current_req->q->disk->private_data;\n\tset_fdc(drive);\n\treschedule_timeout(current_drive, \"redo fd request\");\n\n\tset_floppy(drive);\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = 0;\n\tif (start_motor(redo_fd_request))\n\t\treturn;\n\n\tdisk_change(current_drive);\n\tif (test_bit(current_drive, &fake_change) ||\n\t    test_bit(FD_DISK_CHANGED_BIT, &drive_state[current_drive].flags)) {\n\t\tDPRINT(\"disk absent or changed during operation\\n\");\n\t\trequest_done(0);\n\t\tgoto do_request;\n\t}\n\tif (!_floppy) {\t/* Autodetection */\n\t\tif (!probing) {\n\t\t\tdrive_state[current_drive].probed_format = 0;\n\t\t\tif (next_valid_format(current_drive)) {\n\t\t\t\tDPRINT(\"no autodetectable formats\\n\");\n\t\t\t\t_floppy = NULL;\n\t\t\t\trequest_done(0);\n\t\t\t\tgoto do_request;\n\t\t\t}\n\t\t}\n\t\tprobing = 1;\n\t\t_floppy = floppy_type + drive_params[current_drive].autodetect[drive_state[current_drive].probed_format];\n\t} else\n\t\tprobing = 0;\n\terrors = &(current_req->error_count);\n\ttmp = make_raw_rw_request();\n\tif (tmp < 2) {\n\t\trequest_done(tmp);\n\t\tgoto do_request;\n\t}\n\n\tif (test_bit(FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags))\n\t\ttwaddle(current_fdc, current_drive);\n\tschedule_bh(floppy_start);\n\tdebugt(__func__, \"queue fd request\");\n\treturn;\n}\n\nstatic const struct cont_t rw_cont = {\n\t.interrupt\t= rw_interrupt,\n\t.redo\t\t= redo_fd_request,\n\t.error\t\t= bad_flp_intr,\n\t.done\t\t= request_done\n};\n\n/* schedule the request and automatically unlock the driver on completion */\nstatic void process_fd_request(void)\n{\n\tcont = &rw_cont;\n\tschedule_bh(redo_fd_request);\n}\n\nstatic blk_status_t floppy_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t    const struct blk_mq_queue_data *bd)\n{\n\tblk_mq_start_request(bd->rq);\n\n\tif (WARN(max_buffer_sectors == 0,\n\t\t \"VFS: %s called on non-open device\\n\", __func__))\n\t\treturn BLK_STS_IOERR;\n\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"warning: usage count=0, current_req=%p sect=%ld flags=%llx\\n\",\n\t\t current_req, (long)blk_rq_pos(current_req),\n\t\t (unsigned long long) current_req->cmd_flags))\n\t\treturn BLK_STS_IOERR;\n\n\tif (test_and_set_bit(0, &fdc_busy)) {\n\t\t/* fdc busy, this new request will be treated when the\n\t\t   current one is done */\n\t\tis_alive(__func__, \"old request running\");\n\t\treturn BLK_STS_RESOURCE;\n\t}\n\n\tspin_lock_irq(&floppy_lock);\n\tlist_add_tail(&bd->rq->queuelist, &floppy_reqs);\n\tspin_unlock_irq(&floppy_lock);\n\n\tcommand_status = FD_COMMAND_NONE;\n\t__reschedule_timeout(MAXTIMEOUT, \"fd_request\");\n\tset_fdc(0);\n\tprocess_fd_request();\n\tis_alive(__func__, \"\");\n\treturn BLK_STS_OK;\n}\n\nstatic const struct cont_t poll_cont = {\n\t.interrupt\t= success_and_wakeup,\n\t.redo\t\t= floppy_ready,\n\t.error\t\t= generic_failure,\n\t.done\t\t= generic_done\n};\n\nstatic int poll_drive(bool interruptible, int flag)\n{\n\t/* no auto-sense, just clear dcl */\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = flag;\n\traw_cmd->track = 0;\n\traw_cmd->cmd_count = 0;\n\tcont = &poll_cont;\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"setting NEWCHANGE in poll_drive\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags);\n\n\treturn wait_til_done(floppy_ready, interruptible);\n}\n\n/*\n * User triggered reset\n * ====================\n */\n\nstatic void reset_intr(void)\n{\n\tpr_info(\"weird, reset interrupt called\\n\");\n}\n\nstatic const struct cont_t reset_cont = {\n\t.interrupt\t= reset_intr,\n\t.redo\t\t= success_and_wakeup,\n\t.error\t\t= generic_failure,\n\t.done\t\t= generic_done\n};\n\n/*\n * Resets the FDC connected to drive <drive>.\n * Both current_drive and current_fdc are changed to match the new drive.\n */\nstatic int user_reset_fdc(int drive, int arg, bool interruptible)\n{\n\tint ret;\n\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\n\tif (arg == FD_RESET_ALWAYS)\n\t\tfdc_state[current_fdc].reset = 1;\n\tif (fdc_state[current_fdc].reset) {\n\t\t/* note: reset_fdc will take care of unlocking the driver\n\t\t * on completion.\n\t\t */\n\t\tcont = &reset_cont;\n\t\tret = wait_til_done(reset_fdc, interruptible);\n\t\tif (ret == -EINTR)\n\t\t\treturn -EINTR;\n\t}\n\tprocess_fd_request();\n\treturn 0;\n}\n\n/*\n * Misc Ioctl's and support\n * ========================\n */\nstatic inline int fd_copyout(void __user *param, const void *address,\n\t\t\t     unsigned long size)\n{\n\treturn copy_to_user(param, address, size) ? -EFAULT : 0;\n}\n\nstatic inline int fd_copyin(void __user *param, void *address,\n\t\t\t    unsigned long size)\n{\n\treturn copy_from_user(address, param, size) ? -EFAULT : 0;\n}\n\nstatic const char *drive_name(int type, int drive)\n{\n\tstruct floppy_struct *floppy;\n\n\tif (type)\n\t\tfloppy = floppy_type + type;\n\telse {\n\t\tif (drive_params[drive].native_format)\n\t\t\tfloppy = floppy_type + drive_params[drive].native_format;\n\t\telse\n\t\t\treturn \"(null)\";\n\t}\n\tif (floppy->name)\n\t\treturn floppy->name;\n\telse\n\t\treturn \"(null)\";\n}\n\n#ifdef CONFIG_BLK_DEV_FD_RAWCMD\n\n/* raw commands */\nstatic void raw_cmd_done(int flag)\n{\n\tif (!flag) {\n\t\traw_cmd->flags |= FD_RAW_FAILURE;\n\t\traw_cmd->flags |= FD_RAW_HARDFAILURE;\n\t} else {\n\t\traw_cmd->reply_count = inr;\n\t\tif (raw_cmd->reply_count > FD_RAW_REPLY_SIZE)\n\t\t\traw_cmd->reply_count = 0;\n\t\tmemcpy(raw_cmd->reply, reply_buffer, raw_cmd->reply_count);\n\n\t\tif (raw_cmd->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\t\tunsigned long flags;\n\t\t\tflags = claim_dma_lock();\n\t\t\traw_cmd->length = fd_get_dma_residue();\n\t\t\trelease_dma_lock(flags);\n\t\t}\n\n\t\tif ((raw_cmd->flags & FD_RAW_SOFTFAILURE) &&\n\t\t    (!raw_cmd->reply_count || (raw_cmd->reply[0] & 0xc0)))\n\t\t\traw_cmd->flags |= FD_RAW_FAILURE;\n\n\t\tif (disk_change(current_drive))\n\t\t\traw_cmd->flags |= FD_RAW_DISK_CHANGE;\n\t\telse\n\t\t\traw_cmd->flags &= ~FD_RAW_DISK_CHANGE;\n\t\tif (raw_cmd->flags & FD_RAW_NO_MOTOR_AFTER)\n\t\t\tmotor_off_callback(&motor_off_timer[current_drive]);\n\n\t\tif (raw_cmd->next &&\n\t\t    (!(raw_cmd->flags & FD_RAW_FAILURE) ||\n\t\t     !(raw_cmd->flags & FD_RAW_STOP_IF_FAILURE)) &&\n\t\t    ((raw_cmd->flags & FD_RAW_FAILURE) ||\n\t\t     !(raw_cmd->flags & FD_RAW_STOP_IF_SUCCESS))) {\n\t\t\traw_cmd = raw_cmd->next;\n\t\t\treturn;\n\t\t}\n\t}\n\tgeneric_done(flag);\n}\n\nstatic const struct cont_t raw_cmd_cont = {\n\t.interrupt\t= success_and_wakeup,\n\t.redo\t\t= floppy_start,\n\t.error\t\t= generic_failure,\n\t.done\t\t= raw_cmd_done\n};\n\nstatic int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}\n\nstatic void raw_cmd_free(struct floppy_raw_cmd **ptr)\n{\n\tstruct floppy_raw_cmd *next;\n\tstruct floppy_raw_cmd *this;\n\n\tthis = *ptr;\n\t*ptr = NULL;\n\twhile (this) {\n\t\tif (this->buffer_length) {\n\t\t\tfd_dma_mem_free((unsigned long)this->kernel_data,\n\t\t\t\t\tthis->buffer_length);\n\t\t\tthis->buffer_length = 0;\n\t\t}\n\t\tnext = this->next;\n\t\tkfree(this);\n\t\tthis = next;\n\t}\n}\n\n#define MAX_LEN (1UL << MAX_ORDER << PAGE_SHIFT)\n\nstatic int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tptr->kernel_data = NULL;\n\tif (ret)\n\t\treturn -EFAULT;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > FD_RAW_CMD_FULLSIZE)\n\t\treturn -EINVAL;\n\n\tmemset(ptr->reply, 0, FD_RAW_REPLY_SIZE);\n\tptr->resultcode = 0;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0 || ptr->length >= MAX_LEN)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\n\treturn 0;\n}\n\nstatic int raw_cmd_ioctl(int cmd, void __user *param)\n{\n\tstruct floppy_raw_cmd *my_raw_cmd;\n\tint drive;\n\tint ret2;\n\tint ret;\n\n\tif (fdc_state[current_fdc].rawcmd <= 1)\n\t\tfdc_state[current_fdc].rawcmd = 1;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (FDC(drive) != current_fdc)\n\t\t\tcontinue;\n\t\tif (drive == current_drive) {\n\t\t\tif (drive_state[drive].fd_ref > 1) {\n\t\t\t\tfdc_state[current_fdc].rawcmd = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (drive_state[drive].fd_ref) {\n\t\t\tfdc_state[current_fdc].rawcmd = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fdc_state[current_fdc].reset)\n\t\treturn -EIO;\n\n\tret = raw_cmd_copyin(cmd, param, &my_raw_cmd);\n\tif (ret) {\n\t\traw_cmd_free(&my_raw_cmd);\n\t\treturn ret;\n\t}\n\n\traw_cmd = my_raw_cmd;\n\tcont = &raw_cmd_cont;\n\tret = wait_til_done(floppy_start, true);\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from raw_cmd ioctl\\n\");\n\n\tif (ret != -EINTR && fdc_state[current_fdc].reset)\n\t\tret = -EIO;\n\n\tdrive_state[current_drive].track = NO_TRACK;\n\n\tret2 = raw_cmd_copyout(cmd, param, my_raw_cmd);\n\tif (!ret)\n\t\tret = ret2;\n\traw_cmd_free(&my_raw_cmd);\n\treturn ret;\n}\n\nstatic int floppy_raw_cmd_ioctl(int type, int drive, int cmd,\n\t\t\t\tvoid __user *param)\n{\n\tint ret;\n\n\tpr_warn_once(\"Note: FDRAWCMD is deprecated and will be removed from the kernel in the near future.\\n\");\n\n\tif (type)\n\t\treturn -EINVAL;\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\tset_floppy(drive);\n\tret = raw_cmd_ioctl(cmd, param);\n\tif (ret == -EINTR)\n\t\treturn -EINTR;\n\tprocess_fd_request();\n\treturn ret;\n}\n\n#else /* CONFIG_BLK_DEV_FD_RAWCMD */\n\nstatic int floppy_raw_cmd_ioctl(int type, int drive, int cmd,\n\t\t\t\tvoid __user *param)\n{\n\treturn -EOPNOTSUPP;\n}\n\n#endif\n\nstatic int invalidate_drive(struct block_device *bdev)\n{\n\t/* invalidate the buffer track to force a reread */\n\tset_bit((long)bdev->bd_disk->private_data, &fake_change);\n\tprocess_fd_request();\n\tif (bdev_check_media_change(bdev))\n\t\tfloppy_revalidate(bdev->bd_disk);\n\treturn 0;\n}\n\nstatic int set_geometry(unsigned int cmd, struct floppy_struct *g,\n\t\t\t       int drive, int type, struct block_device *bdev)\n{\n\tint cnt;\n\n\t/* sanity checking for parameters. */\n\tif ((int)g->sect <= 0 ||\n\t    (int)g->head <= 0 ||\n\t    /* check for overflow in max_sector */\n\t    (int)(g->sect * g->head) <= 0 ||\n\t    /* check for zero in raw_cmd->cmd[F_SECT_PER_TRACK] */\n\t    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||\n\t    g->track <= 0 || g->track > drive_params[drive].tracks >> STRETCH(g) ||\n\t    /* check if reserved bits are set */\n\t    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)\n\t\treturn -EINVAL;\n\tif (type) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmutex_lock(&open_lock);\n\t\tif (lock_fdc(drive)) {\n\t\t\tmutex_unlock(&open_lock);\n\t\t\treturn -EINTR;\n\t\t}\n\t\tfloppy_type[type] = *g;\n\t\tfloppy_type[type].name = \"user format\";\n\t\tfor (cnt = type << 2; cnt < (type << 2) + 4; cnt++)\n\t\t\tfloppy_sizes[cnt] = floppy_sizes[cnt + 0x80] =\n\t\t\t    floppy_type[type].size + 1;\n\t\tprocess_fd_request();\n\t\tfor (cnt = 0; cnt < N_DRIVE; cnt++) {\n\t\t\tstruct block_device *bdev = opened_bdev[cnt];\n\t\t\tif (!bdev || ITYPE(drive_state[cnt].fd_device) != type)\n\t\t\t\tcontinue;\n\t\t\t__invalidate_device(bdev, true);\n\t\t}\n\t\tmutex_unlock(&open_lock);\n\t} else {\n\t\tint oldStretch;\n\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (cmd != FDDEFPRM) {\n\t\t\t/* notice a disk change immediately, else\n\t\t\t * we lose our settings immediately*/\n\t\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\t\treturn -EINTR;\n\t\t}\n\t\toldStretch = g->stretch;\n\t\tuser_params[drive] = *g;\n\t\tif (buffer_drive == drive)\n\t\t\tSUPBOUND(buffer_max, user_params[drive].sect);\n\t\tcurrent_type[drive] = &user_params[drive];\n\t\tfloppy_sizes[drive] = user_params[drive].size;\n\t\tif (cmd == FDDEFPRM)\n\t\t\tdrive_state[current_drive].keep_data = -1;\n\t\telse\n\t\t\tdrive_state[current_drive].keep_data = 1;\n\t\t/* invalidation. Invalidate only when needed, i.e.\n\t\t * when there are already sectors in the buffer cache\n\t\t * whose number will change. This is useful, because\n\t\t * mtools often changes the geometry of the disk after\n\t\t * looking at the boot block */\n\t\tif (drive_state[current_drive].maxblock > user_params[drive].sect ||\n\t\t    drive_state[current_drive].maxtrack ||\n\t\t    ((user_params[drive].sect ^ oldStretch) &\n\t\t     (FD_SWAPSIDES | FD_SECTBASEMASK)))\n\t\t\tinvalidate_drive(bdev);\n\t\telse\n\t\t\tprocess_fd_request();\n\t}\n\treturn 0;\n}\n\n/* handle obsolete ioctl's */\nstatic unsigned int ioctl_table[] = {\n\tFDCLRPRM,\n\tFDSETPRM,\n\tFDDEFPRM,\n\tFDGETPRM,\n\tFDMSGON,\n\tFDMSGOFF,\n\tFDFMTBEG,\n\tFDFMTTRK,\n\tFDFMTEND,\n\tFDSETEMSGTRESH,\n\tFDFLUSH,\n\tFDSETMAXERRS,\n\tFDGETMAXERRS,\n\tFDGETDRVTYP,\n\tFDSETDRVPRM,\n\tFDGETDRVPRM,\n\tFDGETDRVSTAT,\n\tFDPOLLDRVSTAT,\n\tFDRESET,\n\tFDGETFDCSTAT,\n\tFDWERRORCLR,\n\tFDWERRORGET,\n\tFDRAWCMD,\n\tFDEJECT,\n\tFDTWADDLE\n};\n\nstatic int normalize_ioctl(unsigned int *cmd, int *size)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ioctl_table); i++) {\n\t\tif ((*cmd & 0xffff) == (ioctl_table[i] & 0xffff)) {\n\t\t\t*size = _IOC_SIZE(*cmd);\n\t\t\t*cmd = ioctl_table[i];\n\t\t\tif (*size > _IOC_SIZE(*cmd)) {\n\t\t\t\tpr_info(\"ioctl not yet supported\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int get_floppy_geometry(int drive, int type, struct floppy_struct **g)\n{\n\tif (type)\n\t\t*g = &floppy_type[type];\n\telse {\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(false, 0) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\t*g = current_type[drive];\n\t}\n\tif (!*g)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tstruct floppy_struct *g;\n\tint ret;\n\n\tret = get_floppy_geometry(drive, type, &g);\n\tif (ret)\n\t\treturn ret;\n\n\tgeo->heads = g->head;\n\tgeo->sectors = g->sect;\n\tgeo->cylinders = g->track;\n\treturn 0;\n}\n\nstatic bool valid_floppy_drive_params(const short autodetect[FD_AUTODETECT_SIZE],\n\t\tint native_format)\n{\n\tsize_t floppy_type_size = ARRAY_SIZE(floppy_type);\n\tsize_t i = 0;\n\n\tfor (i = 0; i < FD_AUTODETECT_SIZE; ++i) {\n\t\tif (autodetect[i] < 0 ||\n\t\t    autodetect[i] >= floppy_type_size)\n\t\t\treturn false;\n\t}\n\n\tif (native_format < 0 || native_format >= floppy_type_size)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int fd_locked_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tint ret;\n\tint size;\n\tunion inparam {\n\t\tstruct floppy_struct g;\t/* geometry */\n\t\tstruct format_descr f;\n\t\tstruct floppy_max_errors max_errors;\n\t\tstruct floppy_drive_params dp;\n\t} inparam;\t\t/* parameters coming from user space */\n\tconst void *outparam;\t/* parameters passed back to user space */\n\n\t/* convert compatibility eject ioctls into floppy eject ioctl.\n\t * We do this in order to provide a means to eject floppy disks before\n\t * installing the new fdutils package */\n\tif (cmd == CDROMEJECT ||\t/* CD-ROM eject */\n\t    cmd == 0x6470) {\t\t/* SunOS floppy eject */\n\t\tDPRINT(\"obsolete eject ioctl\\n\");\n\t\tDPRINT(\"please use floppycontrol --eject\\n\");\n\t\tcmd = FDEJECT;\n\t}\n\n\tif (!((cmd & 0xff00) == 0x0200))\n\t\treturn -EINVAL;\n\n\t/* convert the old style command into a new style command */\n\tret = normalize_ioctl(&cmd, &size);\n\tif (ret)\n\t\treturn ret;\n\n\t/* permission checks */\n\tif (((cmd & 0x40) && !(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL))) ||\n\t    ((cmd & 0x80) && !capable(CAP_SYS_ADMIN)))\n\t\treturn -EPERM;\n\n\tif (WARN_ON(size < 0 || size > sizeof(inparam)))\n\t\treturn -EINVAL;\n\n\t/* copyin */\n\tmemset(&inparam, 0, sizeof(inparam));\n\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\tret = fd_copyin((void __user *)param, &inparam, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (cmd) {\n\tcase FDEJECT:\n\t\tif (drive_state[drive].fd_ref != 1)\n\t\t\t/* somebody else has this drive open */\n\t\t\treturn -EBUSY;\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\n\t\t/* do the actual eject. Fails on\n\t\t * non-Sparc architectures */\n\t\tret = fd_eject(UNIT(drive));\n\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tprocess_fd_request();\n\t\treturn ret;\n\tcase FDCLRPRM:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tcurrent_type[drive] = NULL;\n\t\tfloppy_sizes[drive] = MAX_DISK_SIZE << 1;\n\t\tdrive_state[drive].keep_data = 0;\n\t\treturn invalidate_drive(bdev);\n\tcase FDSETPRM:\n\tcase FDDEFPRM:\n\t\treturn set_geometry(cmd, &inparam.g, drive, type, bdev);\n\tcase FDGETPRM:\n\t\tret = get_floppy_geometry(drive, type,\n\t\t\t\t\t  (struct floppy_struct **)&outparam);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmemcpy(&inparam.g, outparam,\n\t\t\t\toffsetof(struct floppy_struct, name));\n\t\toutparam = &inparam.g;\n\t\tbreak;\n\tcase FDMSGON:\n\t\tdrive_params[drive].flags |= FTD_MSG;\n\t\treturn 0;\n\tcase FDMSGOFF:\n\t\tdrive_params[drive].flags &= ~FTD_MSG;\n\t\treturn 0;\n\tcase FDFMTBEG:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tret = drive_state[drive].flags;\n\t\tprocess_fd_request();\n\t\tif (ret & FD_VERIFY)\n\t\t\treturn -ENODEV;\n\t\tif (!(ret & FD_DISK_WRITABLE))\n\t\t\treturn -EROFS;\n\t\treturn 0;\n\tcase FDFMTTRK:\n\t\tif (drive_state[drive].fd_ref != 1)\n\t\t\treturn -EBUSY;\n\t\treturn do_format(drive, &inparam.f);\n\tcase FDFMTEND:\n\tcase FDFLUSH:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\treturn invalidate_drive(bdev);\n\tcase FDSETEMSGTRESH:\n\t\tdrive_params[drive].max_errors.reporting = (unsigned short)(param & 0x0f);\n\t\treturn 0;\n\tcase FDGETMAXERRS:\n\t\toutparam = &drive_params[drive].max_errors;\n\t\tbreak;\n\tcase FDSETMAXERRS:\n\t\tdrive_params[drive].max_errors = inparam.max_errors;\n\t\tbreak;\n\tcase FDGETDRVTYP:\n\t\toutparam = drive_name(type, drive);\n\t\tSUPBOUND(size, strlen((const char *)outparam) + 1);\n\t\tbreak;\n\tcase FDSETDRVPRM:\n\t\tif (!valid_floppy_drive_params(inparam.dp.autodetect,\n\t\t\t\tinparam.dp.native_format))\n\t\t\treturn -EINVAL;\n\t\tdrive_params[drive] = inparam.dp;\n\t\tbreak;\n\tcase FDGETDRVPRM:\n\t\toutparam = &drive_params[drive];\n\t\tbreak;\n\tcase FDPOLLDRVSTAT:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\tfallthrough;\n\tcase FDGETDRVSTAT:\n\t\toutparam = &drive_state[drive];\n\t\tbreak;\n\tcase FDRESET:\n\t\treturn user_reset_fdc(drive, (int)param, true);\n\tcase FDGETFDCSTAT:\n\t\toutparam = &fdc_state[FDC(drive)];\n\t\tbreak;\n\tcase FDWERRORCLR:\n\t\tmemset(&write_errors[drive], 0, sizeof(write_errors[drive]));\n\t\treturn 0;\n\tcase FDWERRORGET:\n\t\toutparam = &write_errors[drive];\n\t\tbreak;\n\tcase FDRAWCMD:\n\t\treturn floppy_raw_cmd_ioctl(type, drive, cmd, (void __user *)param);\n\tcase FDTWADDLE:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\ttwaddle(current_fdc, current_drive);\n\t\tprocess_fd_request();\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\treturn fd_copyout((void __user *)param, outparam, size);\n\n\treturn 0;\n}\n\nstatic int fd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t     unsigned int cmd, unsigned long param)\n{\n\tint ret;\n\n\tmutex_lock(&floppy_mutex);\n\tret = fd_locked_ioctl(bdev, mode, cmd, param);\n\tmutex_unlock(&floppy_mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_floppy_drive_params {\n\tchar\t\tcmos;\n\tcompat_ulong_t\tmax_dtr;\n\tcompat_ulong_t\thlt;\n\tcompat_ulong_t\thut;\n\tcompat_ulong_t\tsrt;\n\tcompat_ulong_t\tspinup;\n\tcompat_ulong_t\tspindown;\n\tunsigned char\tspindown_offset;\n\tunsigned char\tselect_delay;\n\tunsigned char\trps;\n\tunsigned char\ttracks;\n\tcompat_ulong_t\ttimeout;\n\tunsigned char\tinterleave_sect;\n\tstruct floppy_max_errors max_errors;\n\tchar\t\tflags;\n\tchar\t\tread_track;\n\tshort\t\tautodetect[FD_AUTODETECT_SIZE];\n\tcompat_int_t\tcheckfreq;\n\tcompat_int_t\tnative_format;\n};\n\nstruct compat_floppy_drive_struct {\n\tsigned char\tflags;\n\tcompat_ulong_t\tspinup_date;\n\tcompat_ulong_t\tselect_date;\n\tcompat_ulong_t\tfirst_read_date;\n\tshort\t\tprobed_format;\n\tshort\t\ttrack;\n\tshort\t\tmaxblock;\n\tshort\t\tmaxtrack;\n\tcompat_int_t\tgeneration;\n\tcompat_int_t\tkeep_data;\n\tcompat_int_t\tfd_ref;\n\tcompat_int_t\tfd_device;\n\tcompat_int_t\tlast_checked;\n\tcompat_caddr_t dmabuf;\n\tcompat_int_t\tbufblocks;\n};\n\nstruct compat_floppy_fdc_state {\n\tcompat_int_t\tspec1;\n\tcompat_int_t\tspec2;\n\tcompat_int_t\tdtr;\n\tunsigned char\tversion;\n\tunsigned char\tdor;\n\tcompat_ulong_t\taddress;\n\tunsigned int\trawcmd:2;\n\tunsigned int\treset:1;\n\tunsigned int\tneed_configure:1;\n\tunsigned int\tperp_mode:2;\n\tunsigned int\thas_fifo:1;\n\tunsigned int\tdriver_version;\n\tunsigned char\ttrack[4];\n};\n\nstruct compat_floppy_write_errors {\n\tunsigned int\twrite_errors;\n\tcompat_ulong_t\tfirst_error_sector;\n\tcompat_int_t\tfirst_error_generation;\n\tcompat_ulong_t\tlast_error_sector;\n\tcompat_int_t\tlast_error_generation;\n\tcompat_uint_t\tbadness;\n};\n\n#define FDSETPRM32 _IOW(2, 0x42, struct compat_floppy_struct)\n#define FDDEFPRM32 _IOW(2, 0x43, struct compat_floppy_struct)\n#define FDSETDRVPRM32 _IOW(2, 0x90, struct compat_floppy_drive_params)\n#define FDGETDRVPRM32 _IOR(2, 0x11, struct compat_floppy_drive_params)\n#define FDGETDRVSTAT32 _IOR(2, 0x12, struct compat_floppy_drive_struct)\n#define FDPOLLDRVSTAT32 _IOR(2, 0x13, struct compat_floppy_drive_struct)\n#define FDGETFDCSTAT32 _IOR(2, 0x15, struct compat_floppy_fdc_state)\n#define FDWERRORGET32  _IOR(2, 0x17, struct compat_floppy_write_errors)\n\nstatic int compat_set_geometry(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    struct compat_floppy_struct __user *arg)\n{\n\tstruct floppy_struct v;\n\tint drive, type;\n\tint err;\n\n\tBUILD_BUG_ON(offsetof(struct floppy_struct, name) !=\n\t\t     offsetof(struct compat_floppy_struct, name));\n\n\tif (!(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL)))\n\t\treturn -EPERM;\n\n\tmemset(&v, 0, sizeof(struct floppy_struct));\n\tif (copy_from_user(&v, arg, offsetof(struct floppy_struct, name)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&floppy_mutex);\n\tdrive = (long)bdev->bd_disk->private_data;\n\ttype = ITYPE(drive_state[drive].fd_device);\n\terr = set_geometry(cmd == FDSETPRM32 ? FDSETPRM : FDDEFPRM,\n\t\t\t&v, drive, type, bdev);\n\tmutex_unlock(&floppy_mutex);\n\treturn err;\n}\n\nstatic int compat_get_prm(int drive,\n\t\t\t  struct compat_floppy_struct __user *arg)\n{\n\tstruct compat_floppy_struct v;\n\tstruct floppy_struct *p;\n\tint err;\n\n\tmemset(&v, 0, sizeof(v));\n\tmutex_lock(&floppy_mutex);\n\terr = get_floppy_geometry(drive, ITYPE(drive_state[drive].fd_device),\n\t\t\t\t  &p);\n\tif (err) {\n\t\tmutex_unlock(&floppy_mutex);\n\t\treturn err;\n\t}\n\tmemcpy(&v, p, offsetof(struct floppy_struct, name));\n\tmutex_unlock(&floppy_mutex);\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_setdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&v, arg, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\tif (!valid_floppy_drive_params(v.autodetect, v.native_format))\n\t\treturn -EINVAL;\n\tmutex_lock(&floppy_mutex);\n\tdrive_params[drive].cmos = v.cmos;\n\tdrive_params[drive].max_dtr = v.max_dtr;\n\tdrive_params[drive].hlt = v.hlt;\n\tdrive_params[drive].hut = v.hut;\n\tdrive_params[drive].srt = v.srt;\n\tdrive_params[drive].spinup = v.spinup;\n\tdrive_params[drive].spindown = v.spindown;\n\tdrive_params[drive].spindown_offset = v.spindown_offset;\n\tdrive_params[drive].select_delay = v.select_delay;\n\tdrive_params[drive].rps = v.rps;\n\tdrive_params[drive].tracks = v.tracks;\n\tdrive_params[drive].timeout = v.timeout;\n\tdrive_params[drive].interleave_sect = v.interleave_sect;\n\tdrive_params[drive].max_errors = v.max_errors;\n\tdrive_params[drive].flags = v.flags;\n\tdrive_params[drive].read_track = v.read_track;\n\tmemcpy(drive_params[drive].autodetect, v.autodetect,\n\t       sizeof(v.autodetect));\n\tdrive_params[drive].checkfreq = v.checkfreq;\n\tdrive_params[drive].native_format = v.native_format;\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\n}\n\nstatic int compat_getdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_params));\n\tmutex_lock(&floppy_mutex);\n\tv.cmos = drive_params[drive].cmos;\n\tv.max_dtr = drive_params[drive].max_dtr;\n\tv.hlt = drive_params[drive].hlt;\n\tv.hut = drive_params[drive].hut;\n\tv.srt = drive_params[drive].srt;\n\tv.spinup = drive_params[drive].spinup;\n\tv.spindown = drive_params[drive].spindown;\n\tv.spindown_offset = drive_params[drive].spindown_offset;\n\tv.select_delay = drive_params[drive].select_delay;\n\tv.rps = drive_params[drive].rps;\n\tv.tracks = drive_params[drive].tracks;\n\tv.timeout = drive_params[drive].timeout;\n\tv.interleave_sect = drive_params[drive].interleave_sect;\n\tv.max_errors = drive_params[drive].max_errors;\n\tv.flags = drive_params[drive].flags;\n\tv.read_track = drive_params[drive].read_track;\n\tmemcpy(v.autodetect, drive_params[drive].autodetect,\n\t       sizeof(v.autodetect));\n\tv.checkfreq = drive_params[drive].checkfreq;\n\tv.native_format = drive_params[drive].native_format;\n\tmutex_unlock(&floppy_mutex);\n\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_getdrvstat(int drive, bool poll,\n\t\t\t    struct compat_floppy_drive_struct __user *arg)\n{\n\tstruct compat_floppy_drive_struct v;\n\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_struct));\n\tmutex_lock(&floppy_mutex);\n\n\tif (poll) {\n\t\tif (lock_fdc(drive))\n\t\t\tgoto Eintr;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\tgoto Eintr;\n\t\tprocess_fd_request();\n\t}\n\tv.spinup_date = drive_state[drive].spinup_date;\n\tv.select_date = drive_state[drive].select_date;\n\tv.first_read_date = drive_state[drive].first_read_date;\n\tv.probed_format = drive_state[drive].probed_format;\n\tv.track = drive_state[drive].track;\n\tv.maxblock = drive_state[drive].maxblock;\n\tv.maxtrack = drive_state[drive].maxtrack;\n\tv.generation = drive_state[drive].generation;\n\tv.keep_data = drive_state[drive].keep_data;\n\tv.fd_ref = drive_state[drive].fd_ref;\n\tv.fd_device = drive_state[drive].fd_device;\n\tv.last_checked = drive_state[drive].last_checked;\n\tv.dmabuf = (uintptr_t) drive_state[drive].dmabuf;\n\tv.bufblocks = drive_state[drive].bufblocks;\n\tmutex_unlock(&floppy_mutex);\n\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_drive_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\nEintr:\n\tmutex_unlock(&floppy_mutex);\n\treturn -EINTR;\n}\n\nstatic int compat_getfdcstat(int drive,\n\t\t\t    struct compat_floppy_fdc_state __user *arg)\n{\n\tstruct compat_floppy_fdc_state v32;\n\tstruct floppy_fdc_state v;\n\n\tmutex_lock(&floppy_mutex);\n\tv = fdc_state[FDC(drive)];\n\tmutex_unlock(&floppy_mutex);\n\n\tmemset(&v32, 0, sizeof(struct compat_floppy_fdc_state));\n\tv32.spec1 = v.spec1;\n\tv32.spec2 = v.spec2;\n\tv32.dtr = v.dtr;\n\tv32.version = v.version;\n\tv32.dor = v.dor;\n\tv32.address = v.address;\n\tv32.rawcmd = v.rawcmd;\n\tv32.reset = v.reset;\n\tv32.need_configure = v.need_configure;\n\tv32.perp_mode = v.perp_mode;\n\tv32.has_fifo = v.has_fifo;\n\tv32.driver_version = v.driver_version;\n\tmemcpy(v32.track, v.track, 4);\n\tif (copy_to_user(arg, &v32, sizeof(struct compat_floppy_fdc_state)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_werrorget(int drive,\n\t\t\t    struct compat_floppy_write_errors __user *arg)\n{\n\tstruct compat_floppy_write_errors v32;\n\tstruct floppy_write_errors v;\n\n\tmemset(&v32, 0, sizeof(struct compat_floppy_write_errors));\n\tmutex_lock(&floppy_mutex);\n\tv = write_errors[drive];\n\tmutex_unlock(&floppy_mutex);\n\tv32.write_errors = v.write_errors;\n\tv32.first_error_sector = v.first_error_sector;\n\tv32.first_error_generation = v.first_error_generation;\n\tv32.last_error_sector = v.last_error_sector;\n\tv32.last_error_generation = v.last_error_generation;\n\tv32.badness = v.badness;\n\tif (copy_to_user(arg, &v32, sizeof(struct compat_floppy_write_errors)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int fd_compat_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tswitch (cmd) {\n\tcase CDROMEJECT: /* CD-ROM eject */\n\tcase 0x6470:\t /* SunOS floppy eject */\n\n\tcase FDMSGON:\n\tcase FDMSGOFF:\n\tcase FDSETEMSGTRESH:\n\tcase FDFLUSH:\n\tcase FDWERRORCLR:\n\tcase FDEJECT:\n\tcase FDCLRPRM:\n\tcase FDFMTBEG:\n\tcase FDRESET:\n\tcase FDTWADDLE:\n\t\treturn fd_ioctl(bdev, mode, cmd, param);\n\tcase FDSETMAXERRS:\n\tcase FDGETMAXERRS:\n\tcase FDGETDRVTYP:\n\tcase FDFMTEND:\n\tcase FDFMTTRK:\n\tcase FDRAWCMD:\n\t\treturn fd_ioctl(bdev, mode, cmd,\n\t\t\t\t(unsigned long)compat_ptr(param));\n\tcase FDSETPRM32:\n\tcase FDDEFPRM32:\n\t\treturn compat_set_geometry(bdev, mode, cmd, compat_ptr(param));\n\tcase FDGETPRM32:\n\t\treturn compat_get_prm(drive, compat_ptr(param));\n\tcase FDSETDRVPRM32:\n\t\treturn compat_setdrvprm(drive, compat_ptr(param));\n\tcase FDGETDRVPRM32:\n\t\treturn compat_getdrvprm(drive, compat_ptr(param));\n\tcase FDPOLLDRVSTAT32:\n\t\treturn compat_getdrvstat(drive, true, compat_ptr(param));\n\tcase FDGETDRVSTAT32:\n\t\treturn compat_getdrvstat(drive, false, compat_ptr(param));\n\tcase FDGETFDCSTAT32:\n\t\treturn compat_getfdcstat(drive, compat_ptr(param));\n\tcase FDWERRORGET32:\n\t\treturn compat_werrorget(drive, compat_ptr(param));\n\t}\n\treturn -EINVAL;\n}\n#endif\n\nstatic void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\n\t/* read drive info out of physical CMOS */\n\tdrive = 0;\n\tif (!drive_params[drive].cmos)\n\t\tdrive_params[drive].cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!drive_params[drive].cmos)\n\t\tdrive_params[drive].cmos = FLOPPY1_TYPE;\n\n\t/* FIXME: additional physical CMOS drive detection should go here */\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = drive_params[drive].cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tchar temparea[32];\n\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsnprintf(temparea, sizeof(temparea),\n\t\t\t\t \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\tdrive_params[drive] = *params;\n\t}\n\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}\n\nstatic void floppy_release(struct gendisk *disk, fmode_t mode)\n{\n\tint drive = (long)disk->private_data;\n\n\tmutex_lock(&floppy_mutex);\n\tmutex_lock(&open_lock);\n\tif (!drive_state[drive].fd_ref--) {\n\t\tDPRINT(\"floppy_release with fd_ref == 0\");\n\t\tdrive_state[drive].fd_ref = 0;\n\t}\n\tif (!drive_state[drive].fd_ref)\n\t\topened_bdev[drive] = NULL;\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n}\n\n/*\n * floppy_open check for aliasing (/dev/fd0 can be the same as\n * /dev/PS0 etc), and disallows simultaneous access to the same\n * drive with different device numbers.\n */\nstatic int floppy_open(struct block_device *bdev, fmode_t mode)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint old_dev, new_dev;\n\tint try;\n\tint res = -EBUSY;\n\tchar *tmp;\n\n\tmutex_lock(&floppy_mutex);\n\tmutex_lock(&open_lock);\n\told_dev = drive_state[drive].fd_device;\n\tif (opened_bdev[drive] && opened_bdev[drive] != bdev)\n\t\tgoto out2;\n\n\tif (!drive_state[drive].fd_ref && (drive_params[drive].flags & FD_BROKEN_DCL)) {\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t}\n\n\tdrive_state[drive].fd_ref++;\n\n\topened_bdev[drive] = bdev;\n\n\tres = -ENXIO;\n\n\tif (!floppy_track_buffer) {\n\t\t/* if opening an ED drive, reserve a big buffer,\n\t\t * else reserve a small one */\n\t\tif ((drive_params[drive].cmos == 6) || (drive_params[drive].cmos == 5))\n\t\t\ttry = 64;\t/* Only 48 actually useful */\n\t\telse\n\t\t\ttry = 32;\t/* Only 24 actually useful */\n\n\t\ttmp = (char *)fd_dma_mem_alloc(1024 * try);\n\t\tif (!tmp && !floppy_track_buffer) {\n\t\t\ttry >>= 1;\t/* buffer only one side */\n\t\t\tINFBOUND(try, 16);\n\t\t\ttmp = (char *)fd_dma_mem_alloc(1024 * try);\n\t\t}\n\t\tif (!tmp && !floppy_track_buffer)\n\t\t\tfallback_on_nodma_alloc(&tmp, 2048 * try);\n\t\tif (!tmp && !floppy_track_buffer) {\n\t\t\tDPRINT(\"Unable to allocate DMA memory\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (floppy_track_buffer) {\n\t\t\tif (tmp)\n\t\t\t\tfd_dma_mem_free((unsigned long)tmp, try * 1024);\n\t\t} else {\n\t\t\tbuffer_min = buffer_max = -1;\n\t\t\tfloppy_track_buffer = tmp;\n\t\t\tmax_buffer_sectors = try;\n\t\t}\n\t}\n\n\tnew_dev = MINOR(bdev->bd_dev);\n\tdrive_state[drive].fd_device = new_dev;\n\tset_capacity(disks[drive][ITYPE(new_dev)], floppy_sizes[new_dev]);\n\tif (old_dev != -1 && old_dev != new_dev) {\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t}\n\n\tif (fdc_state[FDC(drive)].rawcmd == 1)\n\t\tfdc_state[FDC(drive)].rawcmd = 2;\n\n\tif (!(mode & FMODE_NDELAY)) {\n\t\tif (mode & (FMODE_READ|FMODE_WRITE)) {\n\t\t\tdrive_state[drive].last_checked = 0;\n\t\t\tclear_bit(FD_OPEN_SHOULD_FAIL_BIT,\n\t\t\t\t  &drive_state[drive].flags);\n\t\t\tif (bdev_check_media_change(bdev))\n\t\t\t\tfloppy_revalidate(bdev->bd_disk);\n\t\t\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags))\n\t\t\t\tgoto out;\n\t\t\tif (test_bit(FD_OPEN_SHOULD_FAIL_BIT, &drive_state[drive].flags))\n\t\t\t\tgoto out;\n\t\t}\n\t\tres = -EROFS;\n\t\tif ((mode & FMODE_WRITE) &&\n\t\t    !test_bit(FD_DISK_WRITABLE_BIT, &drive_state[drive].flags))\n\t\t\tgoto out;\n\t}\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\nout:\n\tdrive_state[drive].fd_ref--;\n\n\tif (!drive_state[drive].fd_ref)\n\t\topened_bdev[drive] = NULL;\nout2:\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n\treturn res;\n}\n\n/*\n * Check if the disk has been changed or if a change has been faked.\n */\nstatic unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tint drive = (long)disk->private_data;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t    test_bit(FD_VERIFY_BIT, &drive_state[drive].flags))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\n\tif (time_after(jiffies, drive_state[drive].last_checked + drive_params[drive].checkfreq)) {\n\t\tif (lock_fdc(drive))\n\t\t\treturn 0;\n\t\tpoll_drive(false, 0);\n\t\tprocess_fd_request();\n\t}\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t    test_bit(FD_VERIFY_BIT, &drive_state[drive].flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\treturn 0;\n}\n\n/*\n * This implements \"read block 0\" for floppy_revalidate().\n * Needed for format autodetection, checking whether there is\n * a disk in the drive, and whether that disk is writable.\n */\n\nstruct rb0_cbdata {\n\tint drive;\n\tstruct completion complete;\n};\n\nstatic void floppy_rb0_cb(struct bio *bio)\n{\n\tstruct rb0_cbdata *cbdata = (struct rb0_cbdata *)bio->bi_private;\n\tint drive = cbdata->drive;\n\n\tif (bio->bi_status) {\n\t\tpr_info(\"floppy: error %d while reading block 0\\n\",\n\t\t\tbio->bi_status);\n\t\tset_bit(FD_OPEN_SHOULD_FAIL_BIT, &drive_state[drive].flags);\n\t}\n\tcomplete(&cbdata->complete);\n}\n\nstatic int __floppy_read_block_0(struct block_device *bdev, int drive)\n{\n\tstruct bio bio;\n\tstruct bio_vec bio_vec;\n\tstruct page *page;\n\tstruct rb0_cbdata cbdata;\n\n\tpage = alloc_page(GFP_NOIO);\n\tif (!page) {\n\t\tprocess_fd_request();\n\t\treturn -ENOMEM;\n\t}\n\n\tcbdata.drive = drive;\n\n\tbio_init(&bio, bdev, &bio_vec, 1, REQ_OP_READ);\n\tbio_add_page(&bio, page, block_size(bdev), 0);\n\n\tbio.bi_iter.bi_sector = 0;\n\tbio.bi_flags |= (1 << BIO_QUIET);\n\tbio.bi_private = &cbdata;\n\tbio.bi_end_io = floppy_rb0_cb;\n\n\tinit_completion(&cbdata.complete);\n\n\tsubmit_bio(&bio);\n\tprocess_fd_request();\n\n\twait_for_completion(&cbdata.complete);\n\n\t__free_page(page);\n\n\treturn 0;\n}\n\n/* revalidate the floppy disk, i.e. trigger format autodetection by reading\n * the bootblock (block 0). \"Autodetection\" is also needed to check whether\n * there is a disk in the drive at all... Thus we also do it for fixed\n * geometry formats */\nstatic int floppy_revalidate(struct gendisk *disk)\n{\n\tint drive = (long)disk->private_data;\n\tint cf;\n\tint res = 0;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t    test_bit(FD_VERIFY_BIT, &drive_state[drive].flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive)) {\n\t\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t\t \"VFS: revalidate called on non-open device.\\n\"))\n\t\t\treturn -EFAULT;\n\n\t\tres = lock_fdc(drive);\n\t\tif (res)\n\t\t\treturn res;\n\t\tcf = (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t\t      test_bit(FD_VERIFY_BIT, &drive_state[drive].flags));\n\t\tif (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {\n\t\t\tprocess_fd_request();\t/*already done by another thread */\n\t\t\treturn 0;\n\t\t}\n\t\tdrive_state[drive].maxblock = 0;\n\t\tdrive_state[drive].maxtrack = 0;\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t\tclear_bit(drive, &fake_change);\n\t\tclear_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tif (cf)\n\t\t\tdrive_state[drive].generation++;\n\t\tif (drive_no_geom(drive)) {\n\t\t\t/* auto-sensing */\n\t\t\tres = __floppy_read_block_0(opened_bdev[drive], drive);\n\t\t} else {\n\t\t\tif (cf)\n\t\t\t\tpoll_drive(false, FD_RAW_NEED_DISK);\n\t\t\tprocess_fd_request();\n\t\t}\n\t}\n\tset_capacity(disk, floppy_sizes[drive_state[drive].fd_device]);\n\treturn res;\n}\n\nstatic const struct block_device_operations floppy_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= floppy_open,\n\t.release\t\t= floppy_release,\n\t.ioctl\t\t\t= fd_ioctl,\n\t.getgeo\t\t\t= fd_getgeo,\n\t.check_events\t\t= floppy_check_events,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= fd_compat_ioctl,\n#endif\n};\n\n/*\n * Floppy Driver initialization\n * =============================\n */\n\n/* Determine the floppy disk controller type */\n/* This routine was written by David C. Niemi */\nstatic char __init get_fdc_version(int fdc)\n{\n\tint r;\n\n\toutput_byte(fdc, FD_DUMPREGS);\t/* 82072 and better know DUMPREGS */\n\tif (fdc_state[fdc].reset)\n\t\treturn FDC_NONE;\n\tr = result(fdc);\n\tif (r <= 0x00)\n\t\treturn FDC_NONE;\t/* No FDC present ??? */\n\tif ((r == 1) && (reply_buffer[ST0] == 0x80)) {\n\t\tpr_info(\"FDC %d is an 8272A\\n\", fdc);\n\t\treturn FDC_8272A;\t/* 8272a/765 don't know DUMPREGS */\n\t}\n\tif (r != 10) {\n\t\tpr_info(\"FDC %d init: DUMPREGS: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\n\tif (!fdc_configure(fdc)) {\n\t\tpr_info(\"FDC %d is an 82072\\n\", fdc);\n\t\treturn FDC_82072;\t/* 82072 doesn't know CONFIGURE */\n\t}\n\n\toutput_byte(fdc, FD_PERPENDICULAR);\n\tif (need_more_output(fdc) == MORE_OUTPUT) {\n\t\toutput_byte(fdc, 0);\n\t} else {\n\t\tpr_info(\"FDC %d is an 82072A\\n\", fdc);\n\t\treturn FDC_82072A;\t/* 82072A as found on Sparcs. */\n\t}\n\n\toutput_byte(fdc, FD_UNLOCK);\n\tr = result(fdc);\n\tif ((r == 1) && (reply_buffer[ST0] == 0x80)) {\n\t\tpr_info(\"FDC %d is a pre-1991 82077\\n\", fdc);\n\t\treturn FDC_82077_ORIG;\t/* Pre-1991 82077, doesn't know\n\t\t\t\t\t * LOCK/UNLOCK */\n\t}\n\tif ((r != 1) || (reply_buffer[ST0] != 0x00)) {\n\t\tpr_info(\"FDC %d init: UNLOCK: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\toutput_byte(fdc, FD_PARTID);\n\tr = result(fdc);\n\tif (r != 1) {\n\t\tpr_info(\"FDC %d init: PARTID: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\tif (reply_buffer[ST0] == 0x80) {\n\t\tpr_info(\"FDC %d is a post-1991 82077\\n\", fdc);\n\t\treturn FDC_82077;\t/* Revised 82077AA passes all the tests */\n\t}\n\tswitch (reply_buffer[ST0] >> 5) {\n\tcase 0x0:\n\t\t/* Either a 82078-1 or a 82078SL running at 5Volt */\n\t\tpr_info(\"FDC %d is an 82078.\\n\", fdc);\n\t\treturn FDC_82078;\n\tcase 0x1:\n\t\tpr_info(\"FDC %d is a 44pin 82078\\n\", fdc);\n\t\treturn FDC_82078;\n\tcase 0x2:\n\t\tpr_info(\"FDC %d is a S82078B\\n\", fdc);\n\t\treturn FDC_S82078B;\n\tcase 0x3:\n\t\tpr_info(\"FDC %d is a National Semiconductor PC87306\\n\", fdc);\n\t\treturn FDC_87306;\n\tdefault:\n\t\tpr_info(\"FDC %d init: 82078 variant with unknown PARTID=%d.\\n\",\n\t\t\tfdc, reply_buffer[ST0] >> 5);\n\t\treturn FDC_82078_UNKN;\n\t}\n}\t\t\t\t/* get_fdc_version */\n\n/* lilo configuration */\n\nstatic void __init floppy_set_flags(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param)\n\t\t\tdefault_drive_params[i].params.flags |= param2;\n\t\telse\n\t\t\tdefault_drive_params[i].params.flags &= ~param2;\n\t}\n\tDPRINT(\"%s flag 0x%x\\n\", param2 ? \"Setting\" : \"Clearing\", param);\n}\n\nstatic void __init daring(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param) {\n\t\t\tdefault_drive_params[i].params.select_delay = 0;\n\t\t\tdefault_drive_params[i].params.flags |=\n\t\t\t    FD_SILENT_DCL_CLEAR;\n\t\t} else {\n\t\t\tdefault_drive_params[i].params.select_delay =\n\t\t\t    2 * HZ / 100;\n\t\t\tdefault_drive_params[i].params.flags &=\n\t\t\t    ~FD_SILENT_DCL_CLEAR;\n\t\t}\n\t}\n\tDPRINT(\"Assuming %s floppy hardware\\n\", param ? \"standard\" : \"broken\");\n}\n\nstatic void __init set_cmos(int *ints, int dummy, int dummy2)\n{\n\tint current_drive = 0;\n\n\tif (ints[0] != 2) {\n\t\tDPRINT(\"wrong number of parameters for CMOS\\n\");\n\t\treturn;\n\t}\n\tcurrent_drive = ints[1];\n\tif (current_drive < 0 || current_drive >= 8) {\n\t\tDPRINT(\"bad drive for set_cmos\\n\");\n\t\treturn;\n\t}\n#if N_FDC > 1\n\tif (current_drive >= 4 && !FDC2)\n\t\tFDC2 = 0x370;\n#endif\n\tdrive_params[current_drive].cmos = ints[2];\n\tDPRINT(\"setting CMOS code to %d\\n\", ints[2]);\n}\n\nstatic struct param_table {\n\tconst char *name;\n\tvoid (*fn) (int *ints, int param, int param2);\n\tint *var;\n\tint def_param;\n\tint param2;\n} config_params[] __initdata = {\n\t{\"allowed_drive_mask\", NULL, &allowed_drive_mask, 0xff, 0}, /* obsolete */\n\t{\"all_drives\", NULL, &allowed_drive_mask, 0xff, 0},\t/* obsolete */\n\t{\"asus_pci\", NULL, &allowed_drive_mask, 0x33, 0},\n\t{\"irq\", NULL, &FLOPPY_IRQ, 6, 0},\n\t{\"dma\", NULL, &FLOPPY_DMA, 2, 0},\n\t{\"daring\", daring, NULL, 1, 0},\n#if N_FDC > 1\n\t{\"two_fdc\", NULL, &FDC2, 0x370, 0},\n\t{\"one_fdc\", NULL, &FDC2, 0, 0},\n#endif\n\t{\"thinkpad\", floppy_set_flags, NULL, 1, FD_INVERTED_DCL},\n\t{\"broken_dcl\", floppy_set_flags, NULL, 1, FD_BROKEN_DCL},\n\t{\"messages\", floppy_set_flags, NULL, 1, FTD_MSG},\n\t{\"silent_dcl_clear\", floppy_set_flags, NULL, 1, FD_SILENT_DCL_CLEAR},\n\t{\"debug\", floppy_set_flags, NULL, 1, FD_DEBUG},\n\t{\"nodma\", NULL, &can_use_virtual_dma, 1, 0},\n\t{\"omnibook\", NULL, &can_use_virtual_dma, 1, 0},\n\t{\"yesdma\", NULL, &can_use_virtual_dma, 0, 0},\n\t{\"fifo_depth\", NULL, &fifo_depth, 0xa, 0},\n\t{\"nofifo\", NULL, &no_fifo, 0x20, 0},\n\t{\"usefifo\", NULL, &no_fifo, 0, 0},\n\t{\"cmos\", set_cmos, NULL, 0, 0},\n\t{\"slow\", NULL, &slow_floppy, 1, 0},\n\t{\"unexpected_interrupts\", NULL, &print_unex, 1, 0},\n\t{\"no_unexpected_interrupts\", NULL, &print_unex, 0, 0},\n\t{\"L40SX\", NULL, &print_unex, 0, 0}\n\n\tEXTRA_FLOPPY_PARAMS\n};\n\nstatic int __init floppy_setup(char *str)\n{\n\tint i;\n\tint param;\n\tint ints[11];\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\tif (str) {\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++) {\n\t\t\tif (strcmp(str, config_params[i].name) == 0) {\n\t\t\t\tif (ints[0])\n\t\t\t\t\tparam = ints[1];\n\t\t\t\telse\n\t\t\t\t\tparam = config_params[i].def_param;\n\t\t\t\tif (config_params[i].fn)\n\t\t\t\t\tconfig_params[i].fn(ints, param,\n\t\t\t\t\t\t\t    config_params[i].\n\t\t\t\t\t\t\t    param2);\n\t\t\t\tif (config_params[i].var) {\n\t\t\t\t\tDPRINT(\"%s=%d\\n\", str, param);\n\t\t\t\t\t*config_params[i].var = param;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (str) {\n\t\tDPRINT(\"unknown floppy option [%s]\\n\", str);\n\n\t\tDPRINT(\"allowed options are:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++)\n\t\t\tpr_cont(\" %s\", config_params[i].name);\n\t\tpr_cont(\"\\n\");\n\t} else\n\t\tDPRINT(\"botched floppy option\\n\");\n\tDPRINT(\"Read Documentation/admin-guide/blockdev/floppy.rst\\n\");\n\treturn 0;\n}\n\nstatic int have_no_fdc = -ENODEV;\n\nstatic ssize_t floppy_cmos_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *p = to_platform_device(dev);\n\tint drive;\n\n\tdrive = p->id;\n\treturn sprintf(buf, \"%X\\n\", drive_params[drive].cmos);\n}\n\nstatic DEVICE_ATTR(cmos, 0444, floppy_cmos_show, NULL);\n\nstatic struct attribute *floppy_dev_attrs[] = {\n\t&dev_attr_cmos.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(floppy_dev);\n\nstatic void floppy_device_release(struct device *dev)\n{\n}\n\nstatic int floppy_resume(struct device *dev)\n{\n\tint fdc;\n\tint saved_drive;\n\n\tsaved_drive = current_drive;\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (fdc_state[fdc].address != -1)\n\t\t\tuser_reset_fdc(REVDRIVE(fdc, 0), FD_RESET_ALWAYS, false);\n\tset_fdc(saved_drive);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops floppy_pm_ops = {\n\t.resume = floppy_resume,\n\t.restore = floppy_resume,\n};\n\nstatic struct platform_driver floppy_driver = {\n\t.driver = {\n\t\t   .name = \"floppy\",\n\t\t   .pm = &floppy_pm_ops,\n\t},\n};\n\nstatic const struct blk_mq_ops floppy_mq_ops = {\n\t.queue_rq = floppy_queue_rq,\n};\n\nstatic struct platform_device floppy_device[N_DRIVE];\nstatic bool registered[N_DRIVE];\n\nstatic bool floppy_available(int drive)\n{\n\tif (!(allowed_drive_mask & (1 << drive)))\n\t\treturn false;\n\tif (fdc_state[FDC(drive)].version == FDC_NONE)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int floppy_alloc_disk(unsigned int drive, unsigned int type)\n{\n\tstruct gendisk *disk;\n\n\tdisk = blk_mq_alloc_disk(&tag_sets[drive], NULL);\n\tif (IS_ERR(disk))\n\t\treturn PTR_ERR(disk);\n\n\tblk_queue_max_hw_sectors(disk->queue, 64);\n\tdisk->major = FLOPPY_MAJOR;\n\tdisk->first_minor = TOMINOR(drive) | (type << 2);\n\tdisk->minors = 1;\n\tdisk->fops = &floppy_fops;\n\tdisk->flags |= GENHD_FL_NO_PART;\n\tdisk->events = DISK_EVENT_MEDIA_CHANGE;\n\tif (type)\n\t\tsprintf(disk->disk_name, \"fd%d_type%d\", drive, type);\n\telse\n\t\tsprintf(disk->disk_name, \"fd%d\", drive);\n\t/* to be cleaned up... */\n\tdisk->private_data = (void *)(long)drive;\n\tdisk->flags |= GENHD_FL_REMOVABLE;\n\n\tdisks[drive][type] = disk;\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(floppy_probe_lock);\n\nstatic void floppy_probe(dev_t dev)\n{\n\tunsigned int drive = (MINOR(dev) & 3) | ((MINOR(dev) & 0x80) >> 5);\n\tunsigned int type = (MINOR(dev) >> 2) & 0x1f;\n\n\tif (drive >= N_DRIVE || !floppy_available(drive) ||\n\t    type >= ARRAY_SIZE(floppy_type))\n\t\treturn;\n\n\tmutex_lock(&floppy_probe_lock);\n\tif (disks[drive][type])\n\t\tgoto out;\n\tif (floppy_alloc_disk(drive, type))\n\t\tgoto out;\n\tif (add_disk(disks[drive][type]))\n\t\tgoto cleanup_disk;\nout:\n\tmutex_unlock(&floppy_probe_lock);\n\treturn;\n\ncleanup_disk:\n\tblk_cleanup_disk(disks[drive][type]);\n\tdisks[drive][type] = NULL;\n\tmutex_unlock(&floppy_probe_lock);\n}\n\nstatic int __init do_floppy_init(void)\n{\n\tint i, unit, drive, err;\n\n\tset_debugt();\n\tinterruptjiffies = resultjiffies = jiffies;\n\n#if defined(CONFIG_PPC)\n\tif (check_legacy_ioport(FDC1))\n\t\treturn -ENODEV;\n#endif\n\n\traw_cmd = NULL;\n\n\tfloppy_wq = alloc_ordered_workqueue(\"floppy\", 0);\n\tif (!floppy_wq)\n\t\treturn -ENOMEM;\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tmemset(&tag_sets[drive], 0, sizeof(tag_sets[drive]));\n\t\ttag_sets[drive].ops = &floppy_mq_ops;\n\t\ttag_sets[drive].nr_hw_queues = 1;\n\t\ttag_sets[drive].nr_maps = 1;\n\t\ttag_sets[drive].queue_depth = 2;\n\t\ttag_sets[drive].numa_node = NUMA_NO_NODE;\n\t\ttag_sets[drive].flags = BLK_MQ_F_SHOULD_MERGE;\n\t\terr = blk_mq_alloc_tag_set(&tag_sets[drive]);\n\t\tif (err)\n\t\t\tgoto out_put_disk;\n\n\t\terr = floppy_alloc_disk(drive, 0);\n\t\tif (err)\n\t\t\tgoto out_put_disk;\n\n\t\ttimer_setup(&motor_off_timer[drive], motor_off_callback, 0);\n\t}\n\n\terr = __register_blkdev(FLOPPY_MAJOR, \"fd\", floppy_probe);\n\tif (err)\n\t\tgoto out_put_disk;\n\n\terr = platform_driver_register(&floppy_driver);\n\tif (err)\n\t\tgoto out_unreg_blkdev;\n\n\tfor (i = 0; i < 256; i++)\n\t\tif (ITYPE(i))\n\t\t\tfloppy_sizes[i] = floppy_type[ITYPE(i)].size;\n\t\telse\n\t\t\tfloppy_sizes[i] = MAX_DISK_SIZE << 1;\n\n\treschedule_timeout(MAXTIMEOUT, \"floppy init\");\n\tconfig_types();\n\n\tfor (i = 0; i < N_FDC; i++) {\n\t\tmemset(&fdc_state[i], 0, sizeof(*fdc_state));\n\t\tfdc_state[i].dtr = -1;\n\t\tfdc_state[i].dor = 0x4;\n#if defined(__sparc__) || defined(__mc68000__)\n\t/*sparcs/sun3x don't have a DOR reset which we can fall back on to */\n#ifdef __mc68000__\n\t\tif (MACH_IS_SUN3X)\n#endif\n\t\t\tfdc_state[i].version = FDC_82072A;\n#endif\n\t}\n\n\tuse_virtual_dma = can_use_virtual_dma & 1;\n\tfdc_state[0].address = FDC1;\n\tif (fdc_state[0].address == -1) {\n\t\tcancel_delayed_work(&fd_timeout);\n\t\terr = -ENODEV;\n\t\tgoto out_unreg_driver;\n\t}\n#if N_FDC > 1\n\tfdc_state[1].address = FDC2;\n#endif\n\n\tcurrent_fdc = 0;\t/* reset fdc in case of unexpected interrupt */\n\terr = floppy_grab_irq_and_dma();\n\tif (err) {\n\t\tcancel_delayed_work(&fd_timeout);\n\t\terr = -EBUSY;\n\t\tgoto out_unreg_driver;\n\t}\n\n\t/* initialise drive state */\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tmemset(&drive_state[drive], 0, sizeof(drive_state[drive]));\n\t\tmemset(&write_errors[drive], 0, sizeof(write_errors[drive]));\n\t\tset_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tdrive_state[drive].fd_device = -1;\n\t\tfloppy_track_buffer = NULL;\n\t\tmax_buffer_sectors = 0;\n\t}\n\t/*\n\t * Small 10 msec delay to let through any interrupt that\n\t * initialization might have triggered, to not\n\t * confuse detection:\n\t */\n\tmsleep(10);\n\n\tfor (i = 0; i < N_FDC; i++) {\n\t\tfdc_state[i].driver_version = FD_DRIVER_VERSION;\n\t\tfor (unit = 0; unit < 4; unit++)\n\t\t\tfdc_state[i].track[unit] = 0;\n\t\tif (fdc_state[i].address == -1)\n\t\t\tcontinue;\n\t\tfdc_state[i].rawcmd = 2;\n\t\tif (user_reset_fdc(REVDRIVE(i, 0), FD_RESET_ALWAYS, false)) {\n\t\t\t/* free ioports reserved by floppy_grab_irq_and_dma() */\n\t\t\tfloppy_release_regions(i);\n\t\t\tfdc_state[i].address = -1;\n\t\t\tfdc_state[i].version = FDC_NONE;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Try to determine the floppy controller type */\n\t\tfdc_state[i].version = get_fdc_version(i);\n\t\tif (fdc_state[i].version == FDC_NONE) {\n\t\t\t/* free ioports reserved by floppy_grab_irq_and_dma() */\n\t\t\tfloppy_release_regions(i);\n\t\t\tfdc_state[i].address = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (can_use_virtual_dma == 2 &&\n\t\t    fdc_state[i].version < FDC_82072A)\n\t\t\tcan_use_virtual_dma = 0;\n\n\t\thave_no_fdc = 0;\n\t\t/* Not all FDCs seem to be able to handle the version command\n\t\t * properly, so force a reset for the standard FDC clones,\n\t\t * to avoid interrupt garbage.\n\t\t */\n\t\tuser_reset_fdc(REVDRIVE(i, 0), FD_RESET_ALWAYS, false);\n\t}\n\tcurrent_fdc = 0;\n\tcancel_delayed_work(&fd_timeout);\n\tcurrent_drive = 0;\n\tinitialized = true;\n\tif (have_no_fdc) {\n\t\tDPRINT(\"no floppy controllers found\\n\");\n\t\terr = have_no_fdc;\n\t\tgoto out_release_dma;\n\t}\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (!floppy_available(drive))\n\t\t\tcontinue;\n\n\t\tfloppy_device[drive].name = floppy_device_name;\n\t\tfloppy_device[drive].id = drive;\n\t\tfloppy_device[drive].dev.release = floppy_device_release;\n\t\tfloppy_device[drive].dev.groups = floppy_dev_groups;\n\n\t\terr = platform_device_register(&floppy_device[drive]);\n\t\tif (err)\n\t\t\tgoto out_remove_drives;\n\n\t\tregistered[drive] = true;\n\n\t\terr = device_add_disk(&floppy_device[drive].dev,\n\t\t\t\t      disks[drive][0], NULL);\n\t\tif (err)\n\t\t\tgoto out_remove_drives;\n\t}\n\n\treturn 0;\n\nout_remove_drives:\n\twhile (drive--) {\n\t\tif (floppy_available(drive)) {\n\t\t\tdel_gendisk(disks[drive][0]);\n\t\t\tif (registered[drive])\n\t\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t}\nout_release_dma:\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\nout_unreg_driver:\n\tplatform_driver_unregister(&floppy_driver);\nout_unreg_blkdev:\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\nout_put_disk:\n\tdestroy_workqueue(floppy_wq);\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (!disks[drive][0])\n\t\t\tbreak;\n\t\tdel_timer_sync(&motor_off_timer[drive]);\n\t\tblk_cleanup_disk(disks[drive][0]);\n\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\t}\n\treturn err;\n}\n\n#ifndef MODULE\nstatic __init void floppy_async_init(void *data, async_cookie_t cookie)\n{\n\tdo_floppy_init();\n}\n#endif\n\nstatic int __init floppy_init(void)\n{\n#ifdef MODULE\n\treturn do_floppy_init();\n#else\n\t/* Don't hold up the bootup by the floppy initialization */\n\tasync_schedule(floppy_async_init, NULL);\n\treturn 0;\n#endif\n}\n\nstatic const struct io_region {\n\tint offset;\n\tint size;\n} io_regions[] = {\n\t{ 2, 1 },\n\t/* address + 3 is sometimes reserved by pnp bios for motherboard */\n\t{ 4, 2 },\n\t/* address + 6 is reserved, and may be taken by IDE.\n\t * Unfortunately, Adaptec doesn't know this :-(, */\n\t{ 7, 1 },\n};\n\nstatic void floppy_release_allocated_regions(int fdc, const struct io_region *p)\n{\n\twhile (p != io_regions) {\n\t\tp--;\n\t\trelease_region(fdc_state[fdc].address + p->offset, p->size);\n\t}\n}\n\n#define ARRAY_END(X) (&((X)[ARRAY_SIZE(X)]))\n\nstatic int floppy_request_regions(int fdc)\n{\n\tconst struct io_region *p;\n\n\tfor (p = io_regions; p < ARRAY_END(io_regions); p++) {\n\t\tif (!request_region(fdc_state[fdc].address + p->offset,\n\t\t\t\t    p->size, \"floppy\")) {\n\t\t\tDPRINT(\"Floppy io-port 0x%04lx in use\\n\",\n\t\t\t       fdc_state[fdc].address + p->offset);\n\t\t\tfloppy_release_allocated_regions(fdc, p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void floppy_release_regions(int fdc)\n{\n\tfloppy_release_allocated_regions(fdc, ARRAY_END(io_regions));\n}\n\nstatic int floppy_grab_irq_and_dma(void)\n{\n\tint fdc;\n\n\tif (atomic_inc_return(&usage_count) > 1)\n\t\treturn 0;\n\n\t/*\n\t * We might have scheduled a free_irq(), wait it to\n\t * drain first:\n\t */\n\tflush_workqueue(floppy_wq);\n\n\tif (fd_request_irq()) {\n\t\tDPRINT(\"Unable to grab IRQ%d for the floppy driver\\n\",\n\t\t       FLOPPY_IRQ);\n\t\tatomic_dec(&usage_count);\n\t\treturn -1;\n\t}\n\tif (fd_request_dma()) {\n\t\tDPRINT(\"Unable to grab DMA%d for the floppy driver\\n\",\n\t\t       FLOPPY_DMA);\n\t\tif (can_use_virtual_dma & 2)\n\t\t\tuse_virtual_dma = can_use_virtual_dma = 1;\n\t\tif (!(can_use_virtual_dma & 1)) {\n\t\t\tfd_free_irq();\n\t\t\tatomic_dec(&usage_count);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++) {\n\t\tif (fdc_state[fdc].address != -1) {\n\t\t\tif (floppy_request_regions(fdc))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tfor (fdc = 0; fdc < N_FDC; fdc++) {\n\t\tif (fdc_state[fdc].address != -1) {\n\t\t\treset_fdc_info(fdc, 1);\n\t\t\tfdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);\n\t\t}\n\t}\n\n\tset_dor(0, ~0, 8);\t/* avoid immediate interrupt */\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (fdc_state[fdc].address != -1)\n\t\t\tfdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);\n\t/*\n\t * The driver will try and free resources and relies on us\n\t * to know if they were allocated or not.\n\t */\n\tcurrent_fdc = 0;\n\tirqdma_allocated = 1;\n\treturn 0;\ncleanup:\n\tfd_free_irq();\n\tfd_free_dma();\n\twhile (--fdc >= 0)\n\t\tfloppy_release_regions(fdc);\n\tcurrent_fdc = 0;\n\tatomic_dec(&usage_count);\n\treturn -1;\n}\n\nstatic void floppy_release_irq_and_dma(void)\n{\n\tint fdc;\n#ifndef __sparc__\n\tint drive;\n#endif\n\tlong tmpsize;\n\tunsigned long tmpaddr;\n\n\tif (!atomic_dec_and_test(&usage_count))\n\t\treturn;\n\n\tif (irqdma_allocated) {\n\t\tfd_disable_dma();\n\t\tfd_free_dma();\n\t\tfd_free_irq();\n\t\tirqdma_allocated = 0;\n\t}\n\tset_dor(0, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1, ~8, 0);\n#endif\n\n\tif (floppy_track_buffer && max_buffer_sectors) {\n\t\ttmpsize = max_buffer_sectors * 1024;\n\t\ttmpaddr = (unsigned long)floppy_track_buffer;\n\t\tfloppy_track_buffer = NULL;\n\t\tmax_buffer_sectors = 0;\n\t\tbuffer_min = buffer_max = -1;\n\t\tfd_dma_mem_free(tmpaddr, tmpsize);\n\t}\n#ifndef __sparc__\n\tfor (drive = 0; drive < N_FDC * 4; drive++)\n\t\tif (timer_pending(motor_off_timer + drive))\n\t\t\tpr_info(\"motor off timer %d still active\\n\", drive);\n#endif\n\n\tif (delayed_work_pending(&fd_timeout))\n\t\tpr_info(\"floppy timer still active:%s\\n\", timeout_message);\n\tif (delayed_work_pending(&fd_timer))\n\t\tpr_info(\"auxiliary floppy timer still active\\n\");\n\tif (work_pending(&floppy_work))\n\t\tpr_info(\"work still pending\\n\");\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (fdc_state[fdc].address != -1)\n\t\t\tfloppy_release_regions(fdc);\n}\n\n#ifdef MODULE\n\nstatic char *floppy;\n\nstatic void __init parse_floppy_cfg_string(char *cfg)\n{\n\tchar *ptr;\n\n\twhile (*cfg) {\n\t\tptr = cfg;\n\t\twhile (*cfg && *cfg != ' ' && *cfg != '\\t')\n\t\t\tcfg++;\n\t\tif (*cfg) {\n\t\t\t*cfg = '\\0';\n\t\t\tcfg++;\n\t\t}\n\t\tif (*ptr)\n\t\t\tfloppy_setup(ptr);\n\t}\n}\n\nstatic int __init floppy_module_init(void)\n{\n\tif (floppy)\n\t\tparse_floppy_cfg_string(floppy);\n\treturn floppy_init();\n}\nmodule_init(floppy_module_init);\n\nstatic void __exit floppy_module_exit(void)\n{\n\tint drive, i;\n\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\n\tplatform_driver_unregister(&floppy_driver);\n\n\tdestroy_workqueue(floppy_wq);\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tdel_timer_sync(&motor_off_timer[drive]);\n\n\t\tif (floppy_available(drive)) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(floppy_type); i++) {\n\t\t\t\tif (disks[drive][i])\n\t\t\t\t\tdel_gendisk(disks[drive][i]);\n\t\t\t}\n\t\t\tif (registered[drive])\n\t\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(floppy_type); i++) {\n\t\t\tif (disks[drive][i])\n\t\t\t\tblk_cleanup_disk(disks[drive][i]);\n\t\t}\n\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\t}\n\n\tcancel_delayed_work_sync(&fd_timeout);\n\tcancel_delayed_work_sync(&fd_timer);\n\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\n\n\t/* eject disk, if any */\n\tfd_eject(0);\n}\n\nmodule_exit(floppy_module_exit);\n\nmodule_param(floppy, charp, 0);\nmodule_param(FLOPPY_IRQ, int, 0);\nmodule_param(FLOPPY_DMA, int, 0);\nMODULE_AUTHOR(\"Alain L. Knaff\");\nMODULE_LICENSE(\"GPL\");\n\n/* This doesn't actually get used other than for module information */\nstatic const struct pnp_device_id floppy_pnpids[] = {\n\t{\"PNP0700\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pnp, floppy_pnpids);\n\n#else\n\n__setup(\"floppy=\", floppy_setup);\nmodule_init(floppy_init)\n#endif\n\nMODULE_ALIAS_BLOCKDEV_MAJOR(FLOPPY_MAJOR);\n"], "buggy_code_start_loc": [34, 2984], "buggy_code_end_loc": [34, 3533], "fixing_code_start_loc": [35, 2985], "fixing_code_end_loc": [51, 3554], "type": "CWE-416", "message": "drivers/block/floppy.c in the Linux kernel before 5.17.6 is vulnerable to a denial of service, because of a concurrency use-after-free flaw after deallocating raw_cmd in the raw_cmd_ioctl function.", "other": {"cve": {"id": "CVE-2022-33981", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-18T16:15:08.227", "lastModified": "2022-11-05T02:28:44.963", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/block/floppy.c in the Linux kernel before 5.17.6 is vulnerable to a denial of service, because of a concurrency use-after-free flaw after deallocating raw_cmd in the raw_cmd_ioctl function."}, {"lang": "es", "value": "El archivo drivers/block/floppy.c en el kernel de Linux versiones anteriores a 5.17.6, es vulnerable a una denegaci\u00f3n de servicio, debido a un fallo de uso de concurrencia despu\u00e9s de la asignaci\u00f3n de raw_cmd en la funci\u00f3n raw_cmd_ioctl"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.17.6", "matchCriteriaId": "E5AA6133-D018-4ECD-9533-5505A0E585D7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.6", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/225362", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/233087ca063686964a53c829d547c7571e3f67bf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/oss-sec/2022/q2/66", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5173", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/233087ca063686964a53c829d547c7571e3f67bf"}}