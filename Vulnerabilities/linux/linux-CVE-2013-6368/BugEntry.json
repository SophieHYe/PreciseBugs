{"buggy_code": ["\n/*\n * Local APIC virtualization\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright (C) 2007 Novell\n * Copyright (C) 2007 Intel\n * Copyright 2009 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Dor Laor <dor.laor@qumranet.com>\n *   Gregory Haskins <ghaskins@novell.com>\n *   Yaozu (Eddie) Dong <eddie.dong@intel.com>\n *\n * Based on Xen 3.1 code, Copyright (c) 2004, Intel Corporation.\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n */\n\n#include <linux/kvm_host.h>\n#include <linux/kvm.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/smp.h>\n#include <linux/hrtimer.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <asm/processor.h>\n#include <asm/msr.h>\n#include <asm/page.h>\n#include <asm/current.h>\n#include <asm/apicdef.h>\n#include <linux/atomic.h>\n#include <linux/jump_label.h>\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"trace.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n\n#ifndef CONFIG_X86_64\n#define mod_64(x, y) ((x) - (y) * div64_u64(x, y))\n#else\n#define mod_64(x, y) ((x) % (y))\n#endif\n\n#define PRId64 \"d\"\n#define PRIx64 \"llx\"\n#define PRIu64 \"u\"\n#define PRIo64 \"o\"\n\n#define APIC_BUS_CYCLE_NS 1\n\n/* #define apic_debug(fmt,arg...) printk(KERN_WARNING fmt,##arg) */\n#define apic_debug(fmt, arg...)\n\n#define APIC_LVT_NUM\t\t\t6\n/* 14 is the version for Xeon and Pentium 8.4.8*/\n#define APIC_VERSION\t\t\t(0x14UL | ((APIC_LVT_NUM - 1) << 16))\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n/* followed define is not in apicdef.h */\n#define APIC_SHORT_MASK\t\t\t0xc0000\n#define APIC_DEST_NOSHORT\t\t0x0\n#define APIC_DEST_MASK\t\t\t0x800\n#define MAX_APIC_VECTOR\t\t\t256\n#define APIC_VECTORS_PER_REG\t\t32\n\n#define VEC_POS(v) ((v) & (32 - 1))\n#define REG_POS(v) (((v) >> 5) << 4)\n\nstatic unsigned int min_timer_period_us = 500;\nmodule_param(min_timer_period_us, uint, S_IRUGO | S_IWUSR);\n\nstatic inline void apic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}\n\nstatic inline void apic_set_vector(int vec, void *bitmap)\n{\n\tset_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstatic inline void apic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstatic inline int __apic_test_and_set_vector(int vec, void *bitmap)\n{\n\treturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstatic inline int __apic_test_and_clear_vector(int vec, void *bitmap)\n{\n\treturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstruct static_key_deferred apic_hw_disabled __read_mostly;\nstruct static_key_deferred apic_sw_disabled __read_mostly;\n\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tif ((kvm_apic_get_reg(apic, APIC_SPIV) ^ val) & APIC_SPIV_APIC_ENABLED) {\n\t\tif (val & APIC_SPIV_APIC_ENABLED)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n\tapic_set_reg(apic, APIC_SPIV, val);\n}\n\nstatic inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}\n\n#define LVT_MASK\t\\\n\t(APIC_LVT_MASKED | APIC_SEND_PENDING | APIC_VECTOR_MASK)\n\n#define LINT_MASK\t\\\n\t(LVT_MASK | APIC_MODE_MASK | APIC_INPUT_POLARITY | \\\n\t APIC_LVT_REMOTE_IRR | APIC_LVT_LEVEL_TRIGGER)\n\nstatic inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_apic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}\n\nstatic void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->ldr_bits = 8;\n\t/* flat mode is default */\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All APICs have to be configured in the same mode by an OS.\n\t\t * We take advatage of this while building logical id loockup\n\t\t * table. After reset APICs are in xapic/flat mode, so if we\n\t\t * find apic with different setting we assume this is the mode\n\t\t * OS wants all apics to be in; build lookup table accordingly.\n\t\t */\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask /* flat mode */ &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}\n\nstatic inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}\n\nstatic inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tapic_set_reg(apic, APIC_LDR, id);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}\n\nstatic inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn !(kvm_apic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\n}\n\nstatic inline int apic_lvt_vector(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn kvm_apic_get_reg(apic, lvt_type) & APIC_VECTOR_MASK;\n}\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\tapic->lapic_timer.timer_mode_mask) == APIC_LVT_TIMER_ONESHOT);\n}\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\tapic->lapic_timer.timer_mode_mask) == APIC_LVT_TIMER_PERIODIC);\n}\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\tapic->lapic_timer.timer_mode_mask) ==\n\t\t\tAPIC_LVT_TIMER_TSCDEADLINE);\n}\n\nstatic inline int apic_lvt_nmi_mode(u32 lvt_val)\n{\n\treturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\n}\n\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tapic_set_reg(apic, APIC_LVR, v);\n}\n\nstatic const unsigned int apic_lvt_mask[APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\n\nstatic int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn fls(*reg) - 1 + vec;\n\t}\n\n\treturn -1;\n}\n\nstatic u8 count_vectors(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\tu8 count = 0;\n\n\tfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tcount += hweight32(*reg);\n\t}\n\n\treturn count;\n}\n\nvoid kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir)\n{\n\tu32 i, pir_val;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tfor (i = 0; i <= 7; i++) {\n\t\tpir_val = xchg(&pir[i], 0);\n\t\tif (pir_val)\n\t\t\t*((u32 *)(apic->regs + APIC_IRR + i * 0x10)) |= pir_val;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_apic_update_irr);\n\nstatic inline void apic_set_irr(int vec, struct kvm_lapic *apic)\n{\n\tapic->irr_pending = true;\n\tapic_set_vector(vec, apic->regs + APIC_IRR);\n}\n\nstatic inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}\n\nstatic inline int apic_find_highest_irr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that irr_pending is just a hint. It will be always\n\t * true with virtual interrupt delivery enabled.\n\t */\n\tif (!apic->irr_pending)\n\t\treturn -1;\n\n\tkvm_x86_ops->sync_pir_to_irr(apic->vcpu);\n\tresult = apic_search_irr(apic);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}\n\nstatic inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\n{\n\tapic->irr_pending = false;\n\tapic_clear_vector(vec, apic->regs + APIC_IRR);\n\tif (apic_search_irr(apic) != -1)\n\t\tapic->irr_pending = true;\n}\n\nstatic inline void apic_set_isr(int vec, struct kvm_lapic *apic)\n{\n\tif (!__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\n\t\t++apic->isr_count;\n\tBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\n\t/*\n\t * ISR (in service register) bit is set when injecting an interrupt.\n\t * The highest vector is injected. Thus the latest bit set matches\n\t * the highest bit in ISR.\n\t */\n\tapic->highest_isr_cache = vec;\n}\n\nstatic inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tif (__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\t--apic->isr_count;\n\tBUG_ON(apic->isr_count < 0);\n\tapic->highest_isr_cache = -1;\n}\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\tint highest_irr;\n\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 0;\n\thighest_irr = apic_find_highest_irr(vcpu->arch.apic);\n\n\treturn highest_irr;\n}\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     unsigned long *dest_map);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\tunsigned long *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}\n\nstatic int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}\n\nstatic int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}\n\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}\n\nstatic bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\n{\n\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0)\n\t\tapic_debug(\"Can't read EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\treturn val & 0x1;\n}\n\nstatic void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\n\t\tapic_debug(\"Can't set EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}\n\nstatic void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tapic_debug(\"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/* Note that isr_count is always 1 with vid enabled */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}\n\nvoid kvm_apic_update_tmr(struct kvm_vcpu *vcpu, u32 *tmr)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tapic_set_reg(apic, APIC_TMR + 0x10 * i, tmr[i]);\n}\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_apic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}\n\nstatic void apic_set_tpr(struct kvm_lapic *apic, u32 tpr)\n{\n\tapic_set_reg(apic, APIC_TASKPRI, tpr);\n\tapic_update_ppr(apic);\n}\n\nint kvm_apic_match_physical_addr(struct kvm_lapic *apic, u16 dest)\n{\n\treturn dest == 0xff || kvm_apic_id(apic) == dest;\n}\n\nint kvm_apic_match_logical_addr(struct kvm_lapic *apic, u8 mda)\n{\n\tint result = 0;\n\tu32 logical_id;\n\n\tif (apic_x2apic_mode(apic)) {\n\t\tlogical_id = kvm_apic_get_reg(apic, APIC_LDR);\n\t\treturn logical_id & mda;\n\t}\n\n\tlogical_id = GET_APIC_LOGICAL_ID(kvm_apic_get_reg(apic, APIC_LDR));\n\n\tswitch (kvm_apic_get_reg(apic, APIC_DFR)) {\n\tcase APIC_DFR_FLAT:\n\t\tif (logical_id & mda)\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase APIC_DFR_CLUSTER:\n\t\tif (((logical_id >> 4) == (mda >> 0x4))\n\t\t    && (logical_id & mda & 0xf))\n\t\t\tresult = 1;\n\t\tbreak;\n\tdefault:\n\t\tapic_debug(\"Bad DFR vcpu %d: %08x\\n\",\n\t\t\t   apic->vcpu->vcpu_id, kvm_apic_get_reg(apic, APIC_DFR));\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nint kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, int dest, int dest_mode)\n{\n\tint result = 0;\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == 0)\n\t\t\t/* Physical mode. */\n\t\t\tresult = kvm_apic_match_physical_addr(target, dest);\n\t\telse\n\t\t\t/* Logical mode. */\n\t\t\tresult = kvm_apic_match_logical_addr(target, dest);\n\t\tbreak;\n\tcase APIC_DEST_SELF:\n\t\tresult = (target == source);\n\t\tbreak;\n\tcase APIC_DEST_ALLINC:\n\t\tresult = 1;\n\t\tbreak;\n\tcase APIC_DEST_ALLBUT:\n\t\tresult = (target != source);\n\t\tbreak;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, unsigned long *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap = 1;\n\tstruct kvm_lapic **dst;\n\tint i;\n\tbool ret = false;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map)\n\t\tgoto out;\n\n\tif (irq->dest_mode == 0) { /* physical mode */\n\t\tif (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\t\tirq->dest_id == 0xff)\n\t\t\tgoto out;\n\t\tdst = &map->phys_map[irq->dest_id & 0xff];\n\t} else {\n\t\tu32 mda = irq->dest_id << (32 - map->ldr_bits);\n\n\t\tdst = map->logical_map[apic_cluster_id(map, mda)];\n\n\t\tbitmap = apic_logical_id(map, mda);\n\n\t\tif (irq->delivery_mode == APIC_DM_LOWEST) {\n\t\t\tint l = -1;\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tif (!dst[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (l < 0)\n\t\t\t\t\tl = i;\n\t\t\t\telse if (kvm_apic_compare_prio(dst[i]->vcpu, dst[l]->vcpu) < 0)\n\t\t\t\t\tl = i;\n\t\t\t}\n\n\t\t\tbitmap = (l >= 0) ? 1 << l : 0;\n\t\t}\n\t}\n\n\tfor_each_set_bit(i, &bitmap, 16) {\n\t\tif (!dst[i])\n\t\t\tcontinue;\n\t\tif (*r < 0)\n\t\t\t*r = 0;\n\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t}\n\n\tret = true;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n/*\n * Add a pending IRQ into lapic.\n * Return 1 if successfully added and 0 if discarded.\n */\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     unsigned long *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\tcase APIC_DM_FIXED:\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map)\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map);\n\n\t\tif (kvm_x86_ops->deliver_posted_interrupt)\n\t\t\tkvm_x86_ops->deliver_posted_interrupt(vcpu, vector);\n\t\telse {\n\t\t\tapic_set_irr(vector, apic);\n\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t\t  trig_mode, vector, false);\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tapic_debug(\"Ignoring guest SMI\\n\");\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\t/* make sure pending_events is visible before sending\n\t\t\t * the request */\n\t\t\tsmp_wmb();\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t} else {\n\t\t\tapic_debug(\"Ignoring de-assert INIT to vcpu %d\\n\",\n\t\t\t\t   vcpu->vcpu_id);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tapic_debug(\"SIPI to vcpu %d vector 0x%02x\\n\",\n\t\t\t   vcpu->vcpu_id, vector);\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nint kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}\n\nstatic void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tif (!(kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI) &&\n\t    kvm_ioapic_handles_vector(apic->vcpu->kvm, vector)) {\n\t\tint trigger_mode;\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\t\telse\n\t\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\t\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n\t}\n}\n\nstatic int apic_set_eoi(struct kvm_lapic *apic)\n{\n\tint vector = apic_find_highest_isr(apic);\n\n\ttrace_kvm_eoi(apic, vector);\n\n\t/*\n\t * Not every write EOI will has corresponding ISR,\n\t * one example is when Kernel check timer on setup_IO_APIC\n\t */\n\tif (vector == -1)\n\t\treturn vector;\n\n\tapic_clear_isr(vector, apic);\n\tapic_update_ppr(apic);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\treturn vector;\n}\n\n/*\n * this interface assumes a trap-like exit, which has already finished\n * desired side effect including vISR and vPPR update.\n */\nvoid kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\ttrace_kvm_eoi(apic, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_apic_set_eoi_accelerated);\n\nstatic void apic_send_ipi(struct kvm_lapic *apic)\n{\n\tu32 icr_low = kvm_apic_get_reg(apic, APIC_ICR);\n\tu32 icr_high = kvm_apic_get_reg(apic, APIC_ICR2);\n\tstruct kvm_lapic_irq irq;\n\n\tirq.vector = icr_low & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr_low & APIC_MODE_MASK;\n\tirq.dest_mode = icr_low & APIC_DEST_MASK;\n\tirq.level = icr_low & APIC_INT_ASSERT;\n\tirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\n\tirq.shorthand = icr_low & APIC_SHORT_MASK;\n\tif (apic_x2apic_mode(apic))\n\t\tirq.dest_id = icr_high;\n\telse\n\t\tirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\n\n\ttrace_kvm_apic_ipi(icr_low, irq.dest_id);\n\n\tapic_debug(\"icr_high 0x%x, icr_low 0x%x, \"\n\t\t   \"short_hand 0x%x, dest 0x%x, trig_mode 0x%x, level 0x%x, \"\n\t\t   \"dest_mode 0x%x, delivery_mode 0x%x, vector 0x%x\\n\",\n\t\t   icr_high, icr_low, irq.shorthand, irq.dest_id,\n\t\t   irq.trig_mode, irq.level, irq.dest_mode, irq.delivery_mode,\n\t\t   irq.vector);\n\n\tkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\n}\n\nstatic u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}\n\nstatic void __report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\n\trun->tpr_access.rip = kvm_rip_read(vcpu);\n\trun->tpr_access.is_write = write;\n}\n\nstatic inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}\n\nstatic u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\n{\n\tu32 val = 0;\n\n\tif (offset >= LAPIC_MMIO_LENGTH)\n\t\treturn 0;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (apic_x2apic_mode(apic))\n\t\t\tval = kvm_apic_id(apic);\n\t\telse\n\t\t\tval = kvm_apic_id(apic) << 24;\n\t\tbreak;\n\tcase APIC_ARBPRI:\n\t\tapic_debug(\"Access APIC ARBPRI register which is for P6\\n\");\n\t\tbreak;\n\n\tcase APIC_TMCCT:\t/* Timer CCR */\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\treturn 0;\n\n\t\tval = apic_get_tmcct(apic);\n\t\tbreak;\n\tcase APIC_PROCPRI:\n\t\tapic_update_ppr(apic);\n\t\tval = kvm_apic_get_reg(apic, offset);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, false);\n\t\t/* fall thru */\n\tdefault:\n\t\tval = kvm_apic_get_reg(apic, offset);\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nstatic inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}\n\nstatic int apic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn kvm_apic_hw_enabled(apic) &&\n\t    addr >= apic->base_address &&\n\t    addr < apic->base_address + LAPIC_MMIO_LENGTH;\n}\n\nstatic int apic_mmio_read(struct kvm_io_device *this,\n\t\t\t   gpa_t address, int len, void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tu32 offset = address - apic->base_address;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\tapic_reg_read(apic, offset, len, data);\n\n\treturn 0;\n}\n\nstatic void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_apic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n\n\tapic_debug(\"timer divide count is 0x%x\\n\",\n\t\t\t\t   apic->divide_count);\n}\n\nstatic void start_apic_timer(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\n\t\t/* lapic timer in oneshot or periodic mode */\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tapic->lapic_timer.period = (u64)kvm_apic_get_reg(apic, APIC_TMICT)\n\t\t\t    * APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\t\tif (!apic->lapic_timer.period)\n\t\t\treturn;\n\t\t/*\n\t\t * Do not allow the guest to program periodic timers with small\n\t\t * interval, since the hrtimers are not throttled by the host\n\t\t * scheduler.\n\t\t */\n\t\tif (apic_lvtt_period(apic)) {\n\t\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\t\tpr_info_ratelimited(\n\t\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\t\tapic->lapic_timer.period = min_period;\n\t\t\t}\n\t\t}\n\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t      ktime_add_ns(now, apic->lapic_timer.period),\n\t\t\t      HRTIMER_MODE_ABS);\n\n\t\tapic_debug(\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\", __func__,\n\t\t\t   APIC_BUS_CYCLE_NS, ktime_to_ns(now),\n\t\t\t   kvm_apic_get_reg(apic, APIC_TMICT),\n\t\t\t   apic->lapic_timer.period,\n\t\t\t   ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)));\n\t} else if (apic_lvtt_tscdeadline(apic)) {\n\t\t/* lapic timer in tsc deadline mode */\n\t\tu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\n\t\tu64 ns = 0;\n\t\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\t\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\t\treturn;\n\n\t\tlocal_irq_save(flags);\n\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tguest_tsc = kvm_x86_ops->read_l1_tsc(vcpu, native_read_tsc());\n\t\tif (likely(tscdeadline > guest_tsc)) {\n\t\t\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\t\t\tdo_div(ns, this_tsc_khz);\n\t\t}\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\tktime_add_ns(now, ns), HRTIMER_MODE_ABS);\n\n\t\tlocal_irq_restore(flags);\n\t}\n}\n\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tint nmi_wd_enabled = apic_lvt_nmi_mode(kvm_apic_get_reg(apic, APIC_LVT0));\n\n\tif (apic_lvt_nmi_mode(lvt0_val)) {\n\t\tif (!nmi_wd_enabled) {\n\t\t\tapic_debug(\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\", apic->vcpu->vcpu_id);\n\t\t\tapic->vcpu->kvm->arch.vapics_in_nmi_mode++;\n\t\t}\n\t} else if (nmi_wd_enabled)\n\t\tapic->vcpu->kvm->arch.vapics_in_nmi_mode--;\n}\n\nstatic int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_apic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_apic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\t    apic->lapic_timer.timer_mode_mask) !=\n\t\t   (val & apic->lapic_timer.timer_mode_mask))\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tapic_set_reg(apic, APIC_LVTT, val);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}\n\nstatic int apic_mmio_write(struct kvm_io_device *this,\n\t\t\t    gpa_t address, int len, const void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tunsigned int offset = address - apic->base_address;\n\tu32 val;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * APIC register must be aligned on 128-bits boundary.\n\t * 32/64/128 bits registers must be accessed thru 32 bits.\n\t * Refer SDM 8.4.1\n\t */\n\tif (len != 4 || (offset & 0xf)) {\n\t\t/* Don't shout loud, $infamous_os would cause only noise. */\n\t\tapic_debug(\"apic write: bad size=%d %lx\\n\", len, (long)address);\n\t\treturn 0;\n\t}\n\n\tval = *(u32*)data;\n\n\t/* too common printing */\n\tif (offset != APIC_EOI)\n\t\tapic_debug(\"%s: offset 0x%x with length 0x%x, and value is \"\n\t\t\t   \"0x%x\\n\", __func__, offset, len, val);\n\n\tapic_reg_write(apic, offset & 0xff0, val);\n\n\treturn 0;\n}\n\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_vcpu_has_lapic(vcpu))\n\t\tapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}\nEXPORT_SYMBOL_GPL(kvm_lapic_set_eoi);\n\n/* emulate APIC access in a trap manner */\nvoid kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)\n{\n\tu32 val = 0;\n\n\t/* hw has done the conditional check and inst decode */\n\toffset &= 0xff0;\n\n\tapic_reg_read(vcpu->arch.apic, offset, 4, &val);\n\n\t/* TODO: optimize to just emulate side effect w/o one more write */\n\tapic_reg_write(vcpu->arch.apic, offset, val);\n}\nEXPORT_SYMBOL_GPL(kvm_apic_write_nodecode);\n\nvoid kvm_free_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\n\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\n\tif (!(kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_APIC_ENABLED))\n\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\n\tif (apic->regs)\n\t\tfree_page((unsigned long)apic->regs);\n\n\tkfree(apic);\n}\n\n/*\n *----------------------------------------------------------------------\n * LAPIC interface\n *----------------------------------------------------------------------\n */\n\nu64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn 0;\n\n\treturn apic->lapic_timer.tscdeadline;\n}\n\nvoid kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic->lapic_timer.tscdeadline = data;\n\tstart_apic_timer(apic);\n}\n\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_apic_get_reg(apic, APIC_TASKPRI) & 4));\n}\n\nu64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 0;\n\n\ttpr = (u64) kvm_apic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}\n\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\t/* update jump label if enable bit changes */\n\tif ((vcpu->arch.apic_base ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif (!kvm_vcpu_is_bsp(apic->vcpu))\n\t\tvalue &= ~MSR_IA32_APICBASE_BSP;\n\n\tvcpu->arch.apic_base = value;\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tu32 id = kvm_apic_id(apic);\n\t\t\tu32 ldr = ((id >> 4) << 16) | (1 << (id & 0xf));\n\t\t\tkvm_apic_set_ldr(apic, ldr);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}\n\nvoid kvm_lapic_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic;\n\tint i;\n\n\tapic_debug(\"%s\\n\", __func__);\n\n\tASSERT(vcpu);\n\tapic = vcpu->arch.apic;\n\tASSERT(apic != NULL);\n\n\t/* Stop the timer in case it's a reset to an active apic */\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tkvm_apic_set_id(apic, vcpu->vcpu_id);\n\tkvm_apic_set_version(apic->vcpu);\n\n\tfor (i = 0; i < APIC_LVT_NUM; i++)\n\t\tapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\n\tapic_set_reg(apic, APIC_LVT0,\n\t\t     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\n\n\tapic_set_reg(apic, APIC_DFR, 0xffffffffU);\n\tapic_set_spiv(apic, 0xff);\n\tapic_set_reg(apic, APIC_TASKPRI, 0);\n\tkvm_apic_set_ldr(apic, 0);\n\tapic_set_reg(apic, APIC_ESR, 0);\n\tapic_set_reg(apic, APIC_ICR, 0);\n\tapic_set_reg(apic, APIC_ICR2, 0);\n\tapic_set_reg(apic, APIC_TDCR, 0);\n\tapic_set_reg(apic, APIC_TMICT, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\tapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\n\t\tapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\n\t\tapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\n\t}\n\tapic->irr_pending = kvm_apic_vid_enabled(vcpu->kvm);\n\tapic->isr_count = kvm_apic_vid_enabled(vcpu->kvm);\n\tapic->highest_isr_cache = -1;\n\tupdate_divide_count(apic);\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\tif (kvm_vcpu_is_bsp(vcpu))\n\t\tkvm_lapic_set_base(vcpu,\n\t\t\t\tvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\n\tvcpu->arch.pv_eoi.msr_val = 0;\n\tapic_update_ppr(apic);\n\n\tvcpu->arch.apic_arb_prio = 0;\n\tvcpu->arch.apic_attention = 0;\n\n\tapic_debug(KERN_INFO \"%s: vcpu=%p, id=%d, base_msr=\"\n\t\t   \"0x%016\" PRIx64 \", base_address=0x%0lx.\\n\", __func__,\n\t\t   vcpu, kvm_apic_id(apic),\n\t\t   vcpu->arch.apic_base, apic->base_address);\n}\n\n/*\n *----------------------------------------------------------------------\n * timer interface\n *----------------------------------------------------------------------\n */\n\nstatic bool lapic_is_periodic(struct kvm_lapic *apic)\n{\n\treturn apic_lvtt_period(apic);\n}\n\nint apic_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (kvm_vcpu_has_lapic(vcpu) && apic_enabled(apic) &&\n\t\t\tapic_lvt_enabled(apic, APIC_LVTT))\n\t\treturn atomic_read(&apic->lapic_timer.pending);\n\n\treturn 0;\n}\n\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_apic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\nvoid kvm_apic_nmi_wd_deliver(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic)\n\t\tkvm_apic_local_deliver(apic, APIC_LVT0);\n}\n\nstatic const struct kvm_io_device_ops apic_mmio_ops = {\n\t.read     = apic_mmio_read,\n\t.write    = apic_mmio_write,\n};\n\nstatic enum hrtimer_restart apic_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_timer *ktimer = container_of(data, struct kvm_timer, timer);\n\tstruct kvm_lapic *apic = container_of(ktimer, struct kvm_lapic, lapic_timer);\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\twait_queue_head_t *q = &vcpu->wq;\n\n\t/*\n\t * There is a race window between reading and incrementing, but we do\n\t * not care about potentially losing timer events in the !reinject\n\t * case anyway. Note: KVM_REQ_PENDING_TIMER is implicitly checked\n\t * in vcpu_enter_guest.\n\t */\n\tif (!atomic_read(&ktimer->pending)) {\n\t\tatomic_inc(&ktimer->pending);\n\t\t/* FIXME: this code should not know anything about vcpus */\n\t\tkvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);\n\t}\n\n\tif (waitqueue_active(q))\n\t\twake_up_interruptible(q);\n\n\tif (lapic_is_periodic(apic)) {\n\t\thrtimer_add_expires_ns(&ktimer->timer, ktimer->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}\n\nint kvm_create_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic;\n\n\tASSERT(vcpu != NULL);\n\tapic_debug(\"apic_init %d\\n\", vcpu->vcpu_id);\n\n\tapic = kzalloc(sizeof(*apic), GFP_KERNEL);\n\tif (!apic)\n\t\tgoto nomem;\n\n\tvcpu->arch.apic = apic;\n\n\tapic->regs = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!apic->regs) {\n\t\tprintk(KERN_ERR \"malloc apic regs error for vcpu %x\\n\",\n\t\t       vcpu->vcpu_id);\n\t\tgoto nomem_free_apic;\n\t}\n\tapic->vcpu = vcpu;\n\n\thrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_ABS);\n\tapic->lapic_timer.timer.function = apic_timer_fn;\n\n\t/*\n\t * APIC is created enabled. This will prevent kvm_lapic_set_base from\n\t * thinking that APIC satet has changed.\n\t */\n\tvcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;\n\tkvm_lapic_set_base(vcpu,\n\t\t\tAPIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE);\n\n\tstatic_key_slow_inc(&apic_sw_disabled.key); /* sw disabled at reset */\n\tkvm_lapic_reset(vcpu);\n\tkvm_iodevice_init(&apic->dev, &apic_mmio_ops);\n\n\treturn 0;\nnomem_free_apic:\n\tkfree(apic);\nnomem:\n\treturn -ENOMEM;\n}\n\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint highest_irr;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || !apic_enabled(apic))\n\t\treturn -1;\n\n\tapic_update_ppr(apic);\n\thighest_irr = apic_find_highest_irr(apic);\n\tif ((highest_irr == -1) ||\n\t    ((highest_irr & 0xF0) <= kvm_apic_get_reg(apic, APIC_PROCPRI)))\n\t\treturn -1;\n\treturn highest_irr;\n}\n\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_apic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\tint r = 0;\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\tr = 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\tr = 1;\n\treturn r;\n}\n\nvoid kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tif (atomic_read(&apic->lapic_timer.pending) > 0) {\n\t\tkvm_apic_local_deliver(apic, APIC_LVTT);\n\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\t}\n}\n\nint kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)\n{\n\tint vector = kvm_apic_has_interrupt(vcpu);\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (vector == -1)\n\t\treturn -1;\n\n\tapic_set_isr(vector, apic);\n\tapic_update_ppr(apic);\n\tapic_clear_irr(vector, apic);\n\treturn vector;\n}\n\nvoid kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tkvm_lapic_set_base(vcpu, vcpu->arch.apic_base);\n\t/* set SPIV separately to get count of SW disabled APICs right */\n\tapic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));\n\tmemcpy(vcpu->arch.apic->regs, s->regs, sizeof *s);\n\t/* call kvm_apic_set_id() to put apic into apic_map */\n\tkvm_apic_set_id(apic, kvm_apic_id(apic));\n\tkvm_apic_set_version(vcpu);\n\n\tapic_update_ppr(apic);\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tupdate_divide_count(apic);\n\tstart_apic_timer(apic);\n\tapic->irr_pending = true;\n\tapic->isr_count = kvm_apic_vid_enabled(vcpu->kvm) ?\n\t\t\t\t1 : count_vectors(apic->regs + APIC_ISR);\n\tapic->highest_isr_cache = -1;\n\tkvm_x86_ops->hwapic_isr_update(vcpu->kvm, apic_find_highest_isr(apic));\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tkvm_rtc_eoi_tracking_restore_one(vcpu);\n}\n\nvoid __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\ttimer = &vcpu->arch.apic->lapic_timer.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}\n\n/*\n * apic_sync_pv_eoi_from_guest - called on vmexit or cancel interrupt\n *\n * Detect whether guest triggered PV EOI since the\n * last entry. If yes, set EOI on guests's behalf.\n * Clear PV EOI in guest memory in any case.\n */\nstatic void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}\n\nvoid kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\tvoid *vapic;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\tdata = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));\n\tkunmap_atomic(vapic);\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}\n\n/*\n * apic_sync_pv_eoi_to_guest - called before vmentry\n *\n * Detect whether it's safe to enable PV EOI and\n * if yes do so.\n */\nstatic void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tif (!pv_eoi_enabled(vcpu) ||\n\t    /* IRR set or many bits in ISR: could be nested. */\n\t    apic->irr_pending ||\n\t    /* Cache not set: could be safe but we don't bother. */\n\t    apic->highest_isr_cache == -1 ||\n\t    /* Need EOI to update ioapic. */\n\t    kvm_ioapic_handles_vector(vcpu->kvm, apic->highest_isr_cache)) {\n\t\t/*\n\t\t * PV EOI was disabled by apic_sync_pv_eoi_from_guest\n\t\t * so we need not do anything here.\n\t\t */\n\t\treturn;\n\t}\n\n\tpv_eoi_set_pending(apic->vcpu);\n}\n\nvoid kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}\n\nvoid kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}\n\nint kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4;\n\n\tif (!irqchip_in_kernel(vcpu->kvm) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (msr == 0x830)\n\t\tapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn apic_reg_write(apic, reg, (u32)data);\n}\n\nint kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4, low, high = 0;\n\n\tif (!irqchip_in_kernel(vcpu->kvm) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (apic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (msr == 0x830)\n\t\tapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}\n\nint kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn apic_reg_write(apic, reg, (u32)data);\n}\n\nint kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 low, high = 0;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 1;\n\n\tif (apic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}\n\nint kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t\t addr, sizeof(u8));\n}\n\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tunsigned int sipi_vector;\n\tunsigned long pe;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\tpe = xchg(&apic->pending_events, 0);\n\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu);\n\t\tkvm_vcpu_reset(vcpu);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tpr_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}\n\nvoid kvm_lapic_init(void)\n{\n\t/* do not patch jump label more than once per second */\n\tjump_label_rate_limit(&apic_hw_disabled, HZ);\n\tjump_label_rate_limit(&apic_sw_disabled, HZ);\n}\n", "#ifndef __KVM_X86_LAPIC_H\n#define __KVM_X86_LAPIC_H\n\n#include \"iodev.h\"\n\n#include <linux/kvm_host.h>\n\n#define KVM_APIC_INIT\t\t0\n#define KVM_APIC_SIPI\t\t1\n\nstruct kvm_timer {\n\tstruct hrtimer timer;\n\ts64 period; \t\t\t\t/* unit: ns */\n\tu32 timer_mode_mask;\n\tu64 tscdeadline;\n\tatomic_t pending;\t\t\t/* accumulated triggered timers */\n};\n\nstruct kvm_lapic {\n\tunsigned long base_address;\n\tstruct kvm_io_device dev;\n\tstruct kvm_timer lapic_timer;\n\tu32 divide_count;\n\tstruct kvm_vcpu *vcpu;\n\tbool irr_pending;\n\t/* Number of bits set in ISR. */\n\ts16 isr_count;\n\t/* The highest vector set in ISR; if -1 - invalid, must scan ISR. */\n\tint highest_isr_cache;\n\t/**\n\t * APIC register page.  The layout matches the register layout seen by\n\t * the guest 1:1, because it is accessed by the vmx microcode.\n\t * Note: Only one register, the TPR, is used by the microcode.\n\t */\n\tvoid *regs;\n\tgpa_t vapic_addr;\n\tstruct page *vapic_page;\n\tunsigned long pending_events;\n\tunsigned int sipi_vector;\n};\nint kvm_create_lapic(struct kvm_vcpu *vcpu);\nvoid kvm_free_lapic(struct kvm_vcpu *vcpu);\n\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu);\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu);\nint kvm_get_apic_interrupt(struct kvm_vcpu *vcpu);\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu);\nvoid kvm_lapic_reset(struct kvm_vcpu *vcpu);\nu64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu);\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8);\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu);\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value);\nu64 kvm_lapic_get_base(struct kvm_vcpu *vcpu);\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu);\n\nvoid kvm_apic_update_tmr(struct kvm_vcpu *vcpu, u32 *tmr);\nvoid kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir);\nint kvm_apic_match_physical_addr(struct kvm_lapic *apic, u16 dest);\nint kvm_apic_match_logical_addr(struct kvm_lapic *apic, u8 mda);\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\tunsigned long *dest_map);\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type);\n\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, unsigned long *dest_map);\n\nu64 kvm_get_apic_base(struct kvm_vcpu *vcpu);\nvoid kvm_set_apic_base(struct kvm_vcpu *vcpu, u64 data);\nvoid kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s);\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu);\n\nu64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu);\nvoid kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data);\n\nvoid kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset);\nvoid kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector);\n\nvoid kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr);\nvoid kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu);\nvoid kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu);\n\nint kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data);\nint kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data);\n\nint kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data);\nint kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data);\n\nstatic inline bool kvm_hv_vapic_assist_page_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hv_vapic & HV_X64_MSR_APIC_ASSIST_PAGE_ENABLE;\n}\n\nint kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data);\nvoid kvm_lapic_init(void);\n\nstatic inline u32 kvm_apic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\t        return *((u32 *) (apic->regs + reg_off));\n}\n\nextern struct static_key kvm_no_apic_vcpu;\n\nstatic inline bool kvm_vcpu_has_lapic(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}\n\nextern struct static_key_deferred apic_hw_disabled;\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}\n\nextern struct static_key_deferred apic_sw_disabled;\n\nstatic inline int kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_APIC_ENABLED;\n\treturn APIC_SPIV_APIC_ENABLED;\n}\n\nstatic inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_has_lapic(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}\n\nstatic inline int kvm_lapic_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);\n}\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}\n\nstatic inline bool kvm_apic_vid_enabled(struct kvm *kvm)\n{\n\treturn kvm_x86_ops->vm_has_apicv(kvm);\n}\n\nstatic inline u16 apic_cluster_id(struct kvm_apic_map *map, u32 ldr)\n{\n\tu16 cid;\n\tldr >>= 32 - map->ldr_bits;\n\tcid = (ldr >> map->cid_shift) & map->cid_mask;\n\n\tBUG_ON(cid >= ARRAY_SIZE(map->logical_map));\n\n\treturn cid;\n}\n\nstatic inline u16 apic_logical_id(struct kvm_apic_map *map, u32 ldr)\n{\n\tldr >>= (32 - map->ldr_bits);\n\treturn ldr & map->lid_mask;\n}\n\nstatic inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector);\n\n#endif\n", "/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * derived from drivers/kvm/kvm_main.c\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright (C) 2008 Qumranet, Inc.\n * Copyright IBM Corporation, 2008\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *   Amit Shah    <amit.shah@qumranet.com>\n *   Ben-Ami Yassour <benami@il.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include \"mmu.h\"\n#include \"i8254.h\"\n#include \"tss.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n\n#include <linux/clocksource.h>\n#include <linux/interrupt.h>\n#include <linux/kvm.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/mman.h>\n#include <linux/highmem.h>\n#include <linux/iommu.h>\n#include <linux/intel-iommu.h>\n#include <linux/cpufreq.h>\n#include <linux/user-return-notifier.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/uaccess.h>\n#include <linux/hash.h>\n#include <linux/pci.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pvclock_gtod.h>\n#include <trace/events/kvm.h>\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\n#include <asm/debugreg.h>\n#include <asm/msr.h>\n#include <asm/desc.h>\n#include <asm/mtrr.h>\n#include <asm/mce.h>\n#include <asm/i387.h>\n#include <asm/fpu-internal.h> /* Ugh! */\n#include <asm/xcr.h>\n#include <asm/pvclock.h>\n#include <asm/div64.h>\n\n#define MAX_IO_MSRS 256\n#define KVM_MAX_MCE_BANKS 32\n#define KVM_MCE_CAP_SUPPORTED (MCG_CTL_P | MCG_SER_P)\n\n#define emul_to_vcpu(ctxt) \\\n\tcontainer_of(ctxt, struct kvm_vcpu, arch.emulate_ctxt)\n\n/* EFER defaults:\n * - enable syscall per default because its emulated by KVM\n * - enable LME and LMA per default on 64 bit KVM\n */\n#ifdef CONFIG_X86_64\nstatic\nu64 __read_mostly efer_reserved_bits = ~((u64)(EFER_SCE | EFER_LME | EFER_LMA));\n#else\nstatic u64 __read_mostly efer_reserved_bits = ~((u64)EFER_SCE);\n#endif\n\n#define VM_STAT(x) offsetof(struct kvm, stat.x), KVM_STAT_VM\n#define VCPU_STAT(x) offsetof(struct kvm_vcpu, stat.x), KVM_STAT_VCPU\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstruct kvm_x86_ops *kvm_x86_ops;\nEXPORT_SYMBOL_GPL(kvm_x86_ops);\n\nstatic bool ignore_msrs = 0;\nmodule_param(ignore_msrs, bool, S_IRUGO | S_IWUSR);\n\nbool kvm_has_tsc_control;\nEXPORT_SYMBOL_GPL(kvm_has_tsc_control);\nu32  kvm_max_guest_tsc_khz;\nEXPORT_SYMBOL_GPL(kvm_max_guest_tsc_khz);\n\n/* tsc tolerance in parts per million - default to 1/2 of the NTP threshold */\nstatic u32 tsc_tolerance_ppm = 250;\nmodule_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);\n\n#define KVM_NR_SHARED_MSRS 16\n\nstruct kvm_shared_msrs_global {\n\tint nr;\n\tu32 msrs[KVM_NR_SHARED_MSRS];\n};\n\nstruct kvm_shared_msrs {\n\tstruct user_return_notifier urn;\n\tbool registered;\n\tstruct kvm_shared_msr_values {\n\t\tu64 host;\n\t\tu64 curr;\n\t} values[KVM_NR_SHARED_MSRS];\n};\n\nstatic struct kvm_shared_msrs_global __read_mostly shared_msrs_global;\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\n\nstruct kvm_stats_debugfs_item debugfs_entries[] = {\n\t{ \"pf_fixed\", VCPU_STAT(pf_fixed) },\n\t{ \"pf_guest\", VCPU_STAT(pf_guest) },\n\t{ \"tlb_flush\", VCPU_STAT(tlb_flush) },\n\t{ \"invlpg\", VCPU_STAT(invlpg) },\n\t{ \"exits\", VCPU_STAT(exits) },\n\t{ \"io_exits\", VCPU_STAT(io_exits) },\n\t{ \"mmio_exits\", VCPU_STAT(mmio_exits) },\n\t{ \"signal_exits\", VCPU_STAT(signal_exits) },\n\t{ \"irq_window\", VCPU_STAT(irq_window_exits) },\n\t{ \"nmi_window\", VCPU_STAT(nmi_window_exits) },\n\t{ \"halt_exits\", VCPU_STAT(halt_exits) },\n\t{ \"halt_wakeup\", VCPU_STAT(halt_wakeup) },\n\t{ \"hypercalls\", VCPU_STAT(hypercalls) },\n\t{ \"request_irq\", VCPU_STAT(request_irq_exits) },\n\t{ \"irq_exits\", VCPU_STAT(irq_exits) },\n\t{ \"host_state_reload\", VCPU_STAT(host_state_reload) },\n\t{ \"efer_reload\", VCPU_STAT(efer_reload) },\n\t{ \"fpu_reload\", VCPU_STAT(fpu_reload) },\n\t{ \"insn_emulation\", VCPU_STAT(insn_emulation) },\n\t{ \"insn_emulation_fail\", VCPU_STAT(insn_emulation_fail) },\n\t{ \"irq_injections\", VCPU_STAT(irq_injections) },\n\t{ \"nmi_injections\", VCPU_STAT(nmi_injections) },\n\t{ \"mmu_shadow_zapped\", VM_STAT(mmu_shadow_zapped) },\n\t{ \"mmu_pte_write\", VM_STAT(mmu_pte_write) },\n\t{ \"mmu_pte_updated\", VM_STAT(mmu_pte_updated) },\n\t{ \"mmu_pde_zapped\", VM_STAT(mmu_pde_zapped) },\n\t{ \"mmu_flooded\", VM_STAT(mmu_flooded) },\n\t{ \"mmu_recycled\", VM_STAT(mmu_recycled) },\n\t{ \"mmu_cache_miss\", VM_STAT(mmu_cache_miss) },\n\t{ \"mmu_unsync\", VM_STAT(mmu_unsync) },\n\t{ \"remote_tlb_flush\", VM_STAT(remote_tlb_flush) },\n\t{ \"largepages\", VM_STAT(lpages) },\n\t{ NULL }\n};\n\nu64 __read_mostly host_xcr0;\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}\n\nstatic void kvm_on_user_return(struct user_return_notifier *urn)\n{\n\tunsigned slot;\n\tstruct kvm_shared_msrs *locals\n\t\t= container_of(urn, struct kvm_shared_msrs, urn);\n\tstruct kvm_shared_msr_values *values;\n\n\tfor (slot = 0; slot < shared_msrs_global.nr; ++slot) {\n\t\tvalues = &locals->values[slot];\n\t\tif (values->host != values->curr) {\n\t\t\twrmsrl(shared_msrs_global.msrs[slot], values->host);\n\t\t\tvalues->curr = values->host;\n\t\t}\n\t}\n\tlocals->registered = false;\n\tuser_return_notifier_unregister(urn);\n}\n\nstatic void shared_msr_update(unsigned slot, u32 msr)\n{\n\tu64 value;\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\t/* only read, and nobody should modify it at this time,\n\t * so don't need lock */\n\tif (slot >= shared_msrs_global.nr) {\n\t\tprintk(KERN_ERR \"kvm: invalid MSR slot!\");\n\t\treturn;\n\t}\n\trdmsrl_safe(msr, &value);\n\tsmsr->values[slot].host = value;\n\tsmsr->values[slot].curr = value;\n}\n\nvoid kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n\tshared_msrs_global.msrs[slot] = msr;\n\t/* we need ensured the shared_msr_global have been updated */\n\tsmp_wmb();\n}\nEXPORT_SYMBOL_GPL(kvm_define_shared_msr);\n\nstatic void kvm_shared_msr_cpu_online(void)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < shared_msrs_global.nr; ++i)\n\t\tshared_msr_update(i, shared_msrs_global.msrs[i]);\n}\n\nvoid kvm_set_shared_msr(unsigned slot, u64 value, u64 mask)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\tif (((value ^ smsr->values[slot].curr) & mask) == 0)\n\t\treturn;\n\tsmsr->values[slot].curr = value;\n\twrmsrl(shared_msrs_global.msrs[slot], value);\n\tif (!smsr->registered) {\n\t\tsmsr->urn.on_user_return = kvm_on_user_return;\n\t\tuser_return_notifier_register(&smsr->urn);\n\t\tsmsr->registered = true;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_set_shared_msr);\n\nstatic void drop_user_return_notifiers(void *ignore)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\tif (smsr->registered)\n\t\tkvm_on_user_return(&smsr->urn);\n}\n\nu64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}\nEXPORT_SYMBOL_GPL(kvm_get_apic_base);\n\nvoid kvm_set_apic_base(struct kvm_vcpu *vcpu, u64 data)\n{\n\t/* TODO: reserve bits check */\n\tkvm_lapic_set_base(vcpu, data);\n}\nEXPORT_SYMBOL_GPL(kvm_set_apic_base);\n\nasmlinkage void kvm_spurious_fault(void)\n{\n\t/* Fault while not rebooting.  We want the trace. */\n\tBUG();\n}\nEXPORT_SYMBOL_GPL(kvm_spurious_fault);\n\n#define EXCPT_BENIGN\t\t0\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_PF\t\t2\n\nstatic int exception_class(int vector)\n{\n\tswitch (vector) {\n\tcase PF_VECTOR:\n\t\treturn EXCPT_PF;\n\tcase DE_VECTOR:\n\tcase TS_VECTOR:\n\tcase NP_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\t\treturn EXCPT_CONTRIBUTORY;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn EXCPT_BENIGN;\n}\n\nstatic void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception);\n\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true);\n}\nEXPORT_SYMBOL_GPL(kvm_requeue_exception);\n\nvoid kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_complete_insn_gp);\n\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.cr2 = fault->address;\n\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n}\nEXPORT_SYMBOL_GPL(kvm_inject_page_fault);\n\nvoid kvm_propagate_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\tif (mmu_is_nested(vcpu) && !fault->nested_page_fault)\n\t\tvcpu->arch.nested_mmu.inject_page_fault(vcpu, fault);\n\telse\n\t\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n}\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_inject_nmi);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception_e);\n\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, true);\n}\nEXPORT_SYMBOL_GPL(kvm_requeue_exception_e);\n\n/*\n * Checks if cpl <= required_cpl; if true, return true.  Otherwise queue\n * a #GP and return false.\n */\nbool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) <= required_cpl)\n\t\treturn true;\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(kvm_require_cpl);\n\n/*\n * This function will be used to read from the physical memory of the currently\n * running guest. The difference to kvm_read_guest_page is that this function\n * can read from guest physical or from the guest's guest physical memory.\n */\nint kvm_read_guest_page_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gfn_t ngfn, void *data, int offset, int len,\n\t\t\t    u32 access)\n{\n\tgfn_t real_gfn;\n\tgpa_t ngpa;\n\n\tngpa     = gfn_to_gpa(ngfn);\n\treal_gfn = mmu->translate_gpa(vcpu, ngpa, access);\n\tif (real_gfn == UNMAPPED_GVA)\n\t\treturn -EFAULT;\n\n\treal_gfn = gpa_to_gfn(real_gfn);\n\n\treturn kvm_read_guest_page(vcpu->kvm, real_gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_page_mmu);\n\nint kvm_read_nested_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t       void *data, int offset, int len, u32 access)\n{\n\treturn kvm_read_guest_page_mmu(vcpu, vcpu->arch.walk_mmu, gfn,\n\t\t\t\t       data, offset, len, access);\n}\n\n/*\n * Load the pae pdptrs.  Return true is they are all valid.\n */\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] & vcpu->arch.mmu.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(load_pdptrs);\n\nstatic bool pdptrs_changed(struct kvm_vcpu *vcpu)\n{\n\tu64 pdpte[ARRAY_SIZE(vcpu->arch.walk_mmu->pdptrs)];\n\tbool changed = true;\n\tint offset;\n\tgfn_t gfn;\n\tint r;\n\n\tif (is_long_mode(vcpu) || !is_pae(vcpu))\n\t\treturn false;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_avail))\n\t\treturn true;\n\n\tgfn = (kvm_read_cr3(vcpu) & ~31u) >> PAGE_SHIFT;\n\toffset = (kvm_read_cr3(vcpu) & ~31u) & (PAGE_SIZE - 1);\n\tr = kvm_read_nested_guest_page(vcpu, gfn, pdpte, offset, sizeof(pdpte),\n\t\t\t\t       PFERR_USER_MASK | PFERR_WRITE_MASK);\n\tif (r < 0)\n\t\tgoto out;\n\tchanged = memcmp(pdpte, vcpu->arch.walk_mmu->pdptrs, sizeof(pdpte)) != 0;\nout:\n\n\treturn changed;\n}\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP |\n\t\t\t\t    X86_CR0_CD | X86_CR0_NW;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr0);\n\nvoid kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)\n{\n\t(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));\n}\nEXPORT_SYMBOL_GPL(kvm_lmsw);\n\nstatic void kvm_load_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE) &&\n\t\t\t!vcpu->guest_xcr0_loaded) {\n\t\t/* kvm_set_xcr() also depends on this */\n\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\t\tvcpu->guest_xcr0_loaded = 1;\n\t}\n}\n\nstatic void kvm_put_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_xcr0_loaded) {\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\t\tvcpu->guest_xcr0_loaded = 0;\n\t}\n}\n\nint __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\txcr0 = xcr;\n\tif (!(xcr0 & XSTATE_FP))\n\t\treturn 1;\n\tif ((xcr0 & XSTATE_YMM) && !(xcr0 & XSTATE_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see fx_init).\n\t */\n\tvalid_bits = vcpu->arch.guest_supported_xcr0 | XSTATE_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tkvm_put_guest_xcr0(vcpu);\n\tvcpu->arch.xcr0 = xcr0;\n\treturn 0;\n}\n\nint kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_xcr);\n\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE |\n\t\t\t\t   X86_CR4_PAE | X86_CR4_SMEP;\n\tif (cr4 & CR4_RESERVED_BITS)\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (cr4 & X86_CR4_OSXSAVE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_FSGSBASE))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has_pcid(vcpu))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops->set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & X86_CR4_OSXSAVE)\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr4);\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_mmu_flush_tlb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE)) {\n\t\t\tif (cr3 & CR3_PCID_ENABLED_RESERVED_BITS)\n\t\t\t\treturn 1;\n\t\t} else\n\t\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\t\treturn 1;\n\t} else {\n\t\tif (is_pae(vcpu)) {\n\t\t\tif (cr3 & CR3_PAE_RESERVED_BITS)\n\t\t\t\treturn 1;\n\t\t\tif (is_paging(vcpu) &&\n\t\t\t    !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\t\t\treturn 1;\n\t\t}\n\t\t/*\n\t\t * We don't check reserved bits in nonpae mode, because\n\t\t * this isn't enforced, and VMware depends on this.\n\t\t */\n\t}\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr3);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr8);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}\nEXPORT_SYMBOL_GPL(kvm_get_cr8);\n\nstatic void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs = (dr7 & DR7_BP_EN_MASK);\n}\n\nstatic int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1; /* #UD */\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | DR6_FIXED_1;\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1; /* #UD */\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tint res;\n\n\tres = __kvm_set_dr(vcpu, dr, val);\n\tif (res > 0)\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\telse if (res < 0)\n\t\tkvm_inject_gp(vcpu, 0);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(kvm_set_dr);\n\nstatic int _kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\t\t/* fall through */\n\tcase 6:\n\t\t*val = vcpu->arch.dr6;\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tif (_kvm_get_dr(vcpu, dr, val)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_get_dr);\n\nbool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tu64 data;\n\tint err;\n\n\terr = kvm_pmu_read_pmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, (u32)data);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, data >> 32);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(kvm_rdpmc);\n\n/*\n * List of msr numbers which we expose to userspace through KVM_GET_MSRS\n * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.\n *\n * This list is modified at module load time to reflect the\n * capabilities of the host cpu. This capabilities test skips MSRs that are\n * kvm-specific. Those are put in the beginning of the list.\n */\n\n#define KVM_SAVE_MSRS_BEGIN\t10\nstatic u32 msrs_to_save[] = {\n\tMSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,\n\tMSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,\n\tHV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,\n\tHV_X64_MSR_APIC_ASSIST_PAGE, MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,\n\tMSR_KVM_PV_EOI_EN,\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_STAR,\n#ifdef CONFIG_X86_64\n\tMSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,\n#endif\n\tMSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,\n\tMSR_IA32_FEATURE_CONTROL\n};\n\nstatic unsigned num_msrs_to_save;\n\nstatic const u32 emulated_msrs[] = {\n\tMSR_IA32_TSC_ADJUST,\n\tMSR_IA32_TSCDEADLINE,\n\tMSR_IA32_MISC_ENABLE,\n\tMSR_IA32_MCG_STATUS,\n\tMSR_IA32_MCG_CTL,\n};\n\nbool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & efer_reserved_bits)\n\t\treturn false;\n\n\tif (efer & EFER_FFXSR) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->edx & bit(X86_FEATURE_FXSR_OPT)))\n\t\t\treturn false;\n\t}\n\n\tif (efer & EFER_SVME) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->ecx & bit(X86_FEATURE_SVM)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(kvm_valid_efer);\n\nstatic int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}\n\nvoid kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}\nEXPORT_SYMBOL_GPL(kvm_enable_efer_bits);\n\n\n/*\n * Writes msr value into into the appropriate \"register\".\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nint kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\treturn kvm_x86_ops->set_msr(vcpu, msr);\n}\n\n/*\n * Adapt set_msr() to msr_io()'s calling convention\n */\nstatic int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\tstruct msr_data msr;\n\n\tmsr.data = *data;\n\tmsr.index = index;\n\tmsr.host_initiated = true;\n\treturn kvm_set_msr(vcpu, &msr);\n}\n\n#ifdef CONFIG_X86_64\nstruct pvclock_gtod_data {\n\tseqcount_t\tseq;\n\n\tstruct { /* extract of a clocksource struct */\n\t\tint vclock_mode;\n\t\tcycle_t\tcycle_last;\n\t\tcycle_t\tmask;\n\t\tu32\tmult;\n\t\tu32\tshift;\n\t} clock;\n\n\t/* open coded 'struct timespec' */\n\tu64\t\tmonotonic_time_snsec;\n\ttime_t\t\tmonotonic_time_sec;\n};\n\nstatic struct pvclock_gtod_data pvclock_gtod_data;\n\nstatic void update_pvclock_gtod(struct timekeeper *tk)\n{\n\tstruct pvclock_gtod_data *vdata = &pvclock_gtod_data;\n\n\twrite_seqcount_begin(&vdata->seq);\n\n\t/* copy pvclock gtod data */\n\tvdata->clock.vclock_mode\t= tk->clock->archdata.vclock_mode;\n\tvdata->clock.cycle_last\t\t= tk->clock->cycle_last;\n\tvdata->clock.mask\t\t= tk->clock->mask;\n\tvdata->clock.mult\t\t= tk->mult;\n\tvdata->clock.shift\t\t= tk->shift;\n\n\tvdata->monotonic_time_sec\t= tk->xtime_sec\n\t\t\t\t\t+ tk->wall_to_monotonic.tv_sec;\n\tvdata->monotonic_time_snsec\t= tk->xtime_nsec\n\t\t\t\t\t+ (tk->wall_to_monotonic.tv_nsec\n\t\t\t\t\t\t<< tk->shift);\n\twhile (vdata->monotonic_time_snsec >=\n\t\t\t\t\t(((u64)NSEC_PER_SEC) << tk->shift)) {\n\t\tvdata->monotonic_time_snsec -=\n\t\t\t\t\t((u64)NSEC_PER_SEC) << tk->shift;\n\t\tvdata->monotonic_time_sec++;\n\t}\n\n\twrite_seqcount_end(&vdata->seq);\n}\n#endif\n\n\nstatic void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock)\n{\n\tint version;\n\tint r;\n\tstruct pvclock_wall_clock wc;\n\tstruct timespec boot;\n\n\tif (!wall_clock)\n\t\treturn;\n\n\tr = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));\n\tif (r)\n\t\treturn;\n\n\tif (version & 1)\n\t\t++version;  /* first time write, random junk */\n\n\t++version;\n\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n\n\t/*\n\t * The guest calculates current wall clock time by adding\n\t * system time (updated by kvm_guest_time_update below) to the\n\t * wall clock specified here.  guest system time equals host\n\t * system time for us, thus we must fill in host boot time here.\n\t */\n\tgetboottime(&boot);\n\n\tif (kvm->arch.kvmclock_offset) {\n\t\tstruct timespec ts = ns_to_timespec(kvm->arch.kvmclock_offset);\n\t\tboot = timespec_sub(boot, ts);\n\t}\n\twc.sec = boot.tv_sec;\n\twc.nsec = boot.tv_nsec;\n\twc.version = version;\n\n\tkvm_write_guest(kvm, wall_clock, &wc, sizeof(wc));\n\n\tversion++;\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n}\n\nstatic uint32_t div_frac(uint32_t dividend, uint32_t divisor)\n{\n\tuint32_t quotient, remainder;\n\n\t/* Don't try to replace with do_div(), this one calculates\n\t * \"(dividend << 32) / divisor\" */\n\t__asm__ ( \"divl %4\"\n\t\t  : \"=a\" (quotient), \"=d\" (remainder)\n\t\t  : \"0\" (0), \"1\" (dividend), \"r\" (divisor) );\n\treturn quotient;\n}\n\nstatic void kvm_get_time_scale(uint32_t scaled_khz, uint32_t base_khz,\n\t\t\t       s8 *pshift, u32 *pmultiplier)\n{\n\tuint64_t scaled64;\n\tint32_t  shift = 0;\n\tuint64_t tps64;\n\tuint32_t tps32;\n\n\ttps64 = base_khz * 1000LL;\n\tscaled64 = scaled_khz * 1000LL;\n\twhile (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {\n\t\ttps64 >>= 1;\n\t\tshift--;\n\t}\n\n\ttps32 = (uint32_t)tps64;\n\twhile (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {\n\t\tif (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)\n\t\t\tscaled64 >>= 1;\n\t\telse\n\t\t\ttps32 <<= 1;\n\t\tshift++;\n\t}\n\n\t*pshift = shift;\n\t*pmultiplier = div_frac(scaled64, tps32);\n\n\tpr_debug(\"%s: base_khz %u => %u, shift %d, mul %u\\n\",\n\t\t __func__, base_khz, scaled_khz, shift, *pmultiplier);\n}\n\nstatic inline u64 get_kernel_ns(void)\n{\n\tstruct timespec ts;\n\n\tWARN_ON(preemptible());\n\tktime_get_ts(&ts);\n\tmonotonic_to_bootbased(&ts);\n\treturn timespec_to_ns(&ts);\n}\n\n#ifdef CONFIG_X86_64\nstatic atomic_t kvm_guest_has_master_clock = ATOMIC_INIT(0);\n#endif\n\nstatic DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);\nunsigned long max_tsc_khz;\n\nstatic inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}\n\nstatic u32 adjust_tsc_khz(u32 khz, s32 ppm)\n{\n\tu64 v = (u64)khz * (1000000 + ppm);\n\tdo_div(v, 1000000);\n\treturn v;\n}\n\nstatic void kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 this_tsc_khz)\n{\n\tu32 thresh_lo, thresh_hi;\n\tint use_scaling = 0;\n\n\t/* tsc_khz can be zero if TSC calibration fails */\n\tif (this_tsc_khz == 0)\n\t\treturn;\n\n\t/* Compute a scale to convert nanoseconds in TSC cycles */\n\tkvm_get_time_scale(this_tsc_khz, NSEC_PER_SEC / 1000,\n\t\t\t   &vcpu->arch.virtual_tsc_shift,\n\t\t\t   &vcpu->arch.virtual_tsc_mult);\n\tvcpu->arch.virtual_tsc_khz = this_tsc_khz;\n\n\t/*\n\t * Compute the variation in TSC rate which is acceptable\n\t * within the range of tolerance and decide if the\n\t * rate being applied is within that bounds of the hardware\n\t * rate.  If so, no scaling or compensation need be done.\n\t */\n\tthresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);\n\tthresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);\n\tif (this_tsc_khz < thresh_lo || this_tsc_khz > thresh_hi) {\n\t\tpr_debug(\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\", this_tsc_khz, thresh_lo, thresh_hi);\n\t\tuse_scaling = 1;\n\t}\n\tkvm_x86_ops->set_tsc_khz(vcpu, this_tsc_khz, use_scaling);\n}\n\nstatic u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)\n{\n\tu64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,\n\t\t\t\t      vcpu->arch.virtual_tsc_mult,\n\t\t\t\t      vcpu->arch.virtual_tsc_shift);\n\ttsc += vcpu->arch.this_tsc_write;\n\treturn tsc;\n}\n\nvoid kvm_track_tsc_matching(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\tbool vcpus_matched;\n\tbool do_request = false;\n\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\t atomic_read(&vcpu->kvm->online_vcpus));\n\n\tif (vcpus_matched && gtod->clock.vclock_mode == VCLOCK_TSC)\n\t\tif (!ka->use_master_clock)\n\t\t\tdo_request = 1;\n\n\tif (!vcpus_matched && ka->use_master_clock)\n\t\t\tdo_request = 1;\n\n\tif (do_request)\n\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\ttrace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,\n\t\t\t    atomic_read(&vcpu->kvm->online_vcpus),\n\t\t            ka->use_master_clock, gtod->clock.vclock_mode);\n#endif\n}\n\nstatic void update_ia32_tsc_adjust_msr(struct kvm_vcpu *vcpu, s64 offset)\n{\n\tu64 curr_offset = kvm_x86_ops->read_tsc_offset(vcpu);\n\tvcpu->arch.ia32_tsc_adjust_msr += offset - curr_offset;\n}\n\nvoid kvm_write_tsc(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tu64 offset, ns, elapsed;\n\tunsigned long flags;\n\ts64 usdiff;\n\tbool matched;\n\tu64 data = msr->data;\n\n\traw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);\n\toffset = kvm_x86_ops->compute_tsc_offset(vcpu, data);\n\tns = get_kernel_ns();\n\telapsed = ns - kvm->arch.last_tsc_nsec;\n\n\tif (vcpu->arch.virtual_tsc_khz) {\n\t\tint faulted = 0;\n\n\t\t/* n.b - signed multiplication and division required */\n\t\tusdiff = data - kvm->arch.last_tsc_write;\n#ifdef CONFIG_X86_64\n\t\tusdiff = (usdiff * 1000) / vcpu->arch.virtual_tsc_khz;\n#else\n\t\t/* do_div() only does unsigned */\n\t\tasm(\"1: idivl %[divisor]\\n\"\n\t\t    \"2: xor %%edx, %%edx\\n\"\n\t\t    \"   movl $0, %[faulted]\\n\"\n\t\t    \"3:\\n\"\n\t\t    \".section .fixup,\\\"ax\\\"\\n\"\n\t\t    \"4: movl $1, %[faulted]\\n\"\n\t\t    \"   jmp  3b\\n\"\n\t\t    \".previous\\n\"\n\n\t\t_ASM_EXTABLE(1b, 4b)\n\n\t\t: \"=A\"(usdiff), [faulted] \"=r\" (faulted)\n\t\t: \"A\"(usdiff * 1000), [divisor] \"rm\"(vcpu->arch.virtual_tsc_khz));\n\n#endif\n\t\tdo_div(elapsed, 1000);\n\t\tusdiff -= elapsed;\n\t\tif (usdiff < 0)\n\t\t\tusdiff = -usdiff;\n\n\t\t/* idivl overflow => difference is larger than USEC_PER_SEC */\n\t\tif (faulted)\n\t\t\tusdiff = USEC_PER_SEC;\n\t} else\n\t\tusdiff = USEC_PER_SEC; /* disable TSC match window below */\n\n\t/*\n\t * Special case: TSC write with a small delta (1 second) of virtual\n\t * cycle time against real time is interpreted as an attempt to\n\t * synchronize the CPU.\n         *\n\t * For a reliable TSC, we can match TSC offsets, and for an unstable\n\t * TSC, we add elapsed time in this computation.  We could let the\n\t * compensation code attempt to catch up if we fall behind, but\n\t * it's better to try to match offsets from the beginning.\n         */\n\tif (usdiff < USEC_PER_SEC &&\n\t    vcpu->arch.virtual_tsc_khz == kvm->arch.last_tsc_khz) {\n\t\tif (!check_tsc_unstable()) {\n\t\t\toffset = kvm->arch.cur_tsc_offset;\n\t\t\tpr_debug(\"kvm: matched tsc offset for %llu\\n\", data);\n\t\t} else {\n\t\t\tu64 delta = nsec_to_cycles(vcpu, elapsed);\n\t\t\tdata += delta;\n\t\t\toffset = kvm_x86_ops->compute_tsc_offset(vcpu, data);\n\t\t\tpr_debug(\"kvm: adjusted tsc offset by %llu\\n\", delta);\n\t\t}\n\t\tmatched = true;\n\t} else {\n\t\t/*\n\t\t * We split periods of matched TSC writes into generations.\n\t\t * For each generation, we track the original measured\n\t\t * nanosecond time, offset, and write, so if TSCs are in\n\t\t * sync, we can match exact offset, and if not, we can match\n\t\t * exact software computation in compute_guest_tsc()\n\t\t *\n\t\t * These values are tracked in kvm->arch.cur_xxx variables.\n\t\t */\n\t\tkvm->arch.cur_tsc_generation++;\n\t\tkvm->arch.cur_tsc_nsec = ns;\n\t\tkvm->arch.cur_tsc_write = data;\n\t\tkvm->arch.cur_tsc_offset = offset;\n\t\tmatched = false;\n\t\tpr_debug(\"kvm: new tsc generation %u, clock %llu\\n\",\n\t\t\t kvm->arch.cur_tsc_generation, data);\n\t}\n\n\t/*\n\t * We also track th most recent recorded KHZ, write and time to\n\t * allow the matching interval to be extended at each write.\n\t */\n\tkvm->arch.last_tsc_nsec = ns;\n\tkvm->arch.last_tsc_write = data;\n\tkvm->arch.last_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\n\t/* Reset of TSC must disable overshoot protection below */\n\tvcpu->arch.hv_clock.tsc_timestamp = 0;\n\tvcpu->arch.last_guest_tsc = data;\n\n\t/* Keep track of which generation this VCPU has synchronized to */\n\tvcpu->arch.this_tsc_generation = kvm->arch.cur_tsc_generation;\n\tvcpu->arch.this_tsc_nsec = kvm->arch.cur_tsc_nsec;\n\tvcpu->arch.this_tsc_write = kvm->arch.cur_tsc_write;\n\n\tif (guest_cpuid_has_tsc_adjust(vcpu) && !msr->host_initiated)\n\t\tupdate_ia32_tsc_adjust_msr(vcpu, offset);\n\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\traw_spin_unlock_irqrestore(&kvm->arch.tsc_write_lock, flags);\n\n\tspin_lock(&kvm->arch.pvclock_gtod_sync_lock);\n\tif (matched)\n\t\tkvm->arch.nr_vcpus_matched_tsc++;\n\telse\n\t\tkvm->arch.nr_vcpus_matched_tsc = 0;\n\n\tkvm_track_tsc_matching(vcpu);\n\tspin_unlock(&kvm->arch.pvclock_gtod_sync_lock);\n}\n\nEXPORT_SYMBOL_GPL(kvm_write_tsc);\n\n#ifdef CONFIG_X86_64\n\nstatic cycle_t read_tsc(void)\n{\n\tcycle_t ret;\n\tu64 last;\n\n\t/*\n\t * Empirically, a fence (of type that depends on the CPU)\n\t * before rdtsc is enough to ensure that rdtsc is ordered\n\t * with respect to loads.  The various CPU manuals are unclear\n\t * as to whether rdtsc can be reordered with later loads,\n\t * but no one has ever seen it happen.\n\t */\n\trdtsc_barrier();\n\tret = (cycle_t)vget_cycles();\n\n\tlast = pvclock_gtod_data.clock.cycle_last;\n\n\tif (likely(ret >= last))\n\t\treturn ret;\n\n\t/*\n\t * GCC likes to generate cmov here, but this branch is extremely\n\t * predictable (it's just a funciton of time and the likely is\n\t * very likely) and there's a data dependence, so force GCC\n\t * to generate a branch instead.  I don't barrier() because\n\t * we don't actually need a barrier, and if this function\n\t * ever gets inlined it will generate worse code.\n\t */\n\tasm volatile (\"\");\n\treturn last;\n}\n\nstatic inline u64 vgettsc(cycle_t *cycle_now)\n{\n\tlong v;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\t*cycle_now = read_tsc();\n\n\tv = (*cycle_now - gtod->clock.cycle_last) & gtod->clock.mask;\n\treturn v * gtod->clock.mult;\n}\n\nstatic int do_monotonic(struct timespec *ts, cycle_t *cycle_now)\n{\n\tunsigned long seq;\n\tu64 ns;\n\tint mode;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tts->tv_nsec = 0;\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tmode = gtod->clock.vclock_mode;\n\t\tts->tv_sec = gtod->monotonic_time_sec;\n\t\tns = gtod->monotonic_time_snsec;\n\t\tns += vgettsc(cycle_now);\n\t\tns >>= gtod->clock.shift;\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\ttimespec_add_ns(ts, ns);\n\n\treturn mode;\n}\n\n/* returns true if host is using tsc clocksource */\nstatic bool kvm_get_time_and_clockread(s64 *kernel_ns, cycle_t *cycle_now)\n{\n\tstruct timespec ts;\n\n\t/* checked again under seqlock below */\n\tif (pvclock_gtod_data.clock.vclock_mode != VCLOCK_TSC)\n\t\treturn false;\n\n\tif (do_monotonic(&ts, cycle_now) != VCLOCK_TSC)\n\t\treturn false;\n\n\tmonotonic_to_bootbased(&ts);\n\t*kernel_ns = timespec_to_ns(&ts);\n\n\treturn true;\n}\n#endif\n\n/*\n *\n * Assuming a stable TSC across physical CPUS, and a stable TSC\n * across virtual CPUs, the following condition is possible.\n * Each numbered line represents an event visible to both\n * CPUs at the next numbered event.\n *\n * \"timespecX\" represents host monotonic time. \"tscX\" represents\n * RDTSC value.\n *\n * \t\tVCPU0 on CPU0\t\t|\tVCPU1 on CPU1\n *\n * 1.  read timespec0,tsc0\n * 2.\t\t\t\t\t| timespec1 = timespec0 + N\n * \t\t\t\t\t| tsc1 = tsc0 + M\n * 3. transition to guest\t\t| transition to guest\n * 4. ret0 = timespec0 + (rdtsc - tsc0) |\n * 5.\t\t\t\t        | ret1 = timespec1 + (rdtsc - tsc1)\n * \t\t\t\t        | ret1 = timespec0 + N + (rdtsc - (tsc0 + M))\n *\n * Since ret0 update is visible to VCPU1 at time 5, to obey monotonicity:\n *\n * \t- ret0 < ret1\n *\t- timespec0 + (rdtsc - tsc0) < timespec0 + N + (rdtsc - (tsc0 + M))\n *\t\t...\n *\t- 0 < N - M => M < N\n *\n * That is, when timespec0 != timespec1, M < N. Unfortunately that is not\n * always the case (the difference between two distinct xtime instances\n * might be smaller then the difference between corresponding TSC reads,\n * when updating guest vcpus pvclock areas).\n *\n * To avoid that problem, do not allow visibility of distinct\n * system_timestamp/tsc_timestamp values simultaneously: use a master\n * copy of host monotonic time values. Update that master copy\n * in lockstep.\n *\n * Rely on synchronization of host TSCs and guest TSCs for monotonicity.\n *\n */\n\nstatic void pvclock_update_vm_gtod_copy(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tstruct kvm_arch *ka = &kvm->arch;\n\tint vclock_mode;\n\tbool host_tsc_clocksource, vcpus_matched;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\tatomic_read(&kvm->online_vcpus));\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\thost_tsc_clocksource = kvm_get_time_and_clockread(\n\t\t\t\t\t&ka->master_kernel_ns,\n\t\t\t\t\t&ka->master_cycle_now);\n\n\tka->use_master_clock = host_tsc_clocksource & vcpus_matched;\n\n\tif (ka->use_master_clock)\n\t\tatomic_set(&kvm_guest_has_master_clock, 1);\n\n\tvclock_mode = pvclock_gtod_data.clock.vclock_mode;\n\ttrace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,\n\t\t\t\t\tvcpus_matched);\n#endif\n}\n\nstatic void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\t/* no guest entries from this point */\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\n\t/* guest entries allowed */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}\n\nstatic int kvm_guest_time_update(struct kvm_vcpu *v)\n{\n\tunsigned long flags, this_tsc_khz;\n\tstruct kvm_vcpu_arch *vcpu = &v->arch;\n\tstruct kvm_arch *ka = &v->kvm->arch;\n\ts64 kernel_ns, max_kernel_ns;\n\tu64 tsc_timestamp, host_tsc;\n\tstruct pvclock_vcpu_time_info guest_hv_clock;\n\tu8 pvclock_flags;\n\tbool use_master_clock;\n\n\tkernel_ns = 0;\n\thost_tsc = 0;\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tuse_master_clock = ka->use_master_clock;\n\tif (use_master_clock) {\n\t\thost_tsc = ka->master_cycle_now;\n\t\tkernel_ns = ka->master_kernel_ns;\n\t}\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n\n\t/* Keep irq disabled to prevent changes to the clock */\n\tlocal_irq_save(flags);\n\tthis_tsc_khz = __get_cpu_var(cpu_tsc_khz);\n\tif (unlikely(this_tsc_khz == 0)) {\n\t\tlocal_irq_restore(flags);\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\t\treturn 1;\n\t}\n\tif (!use_master_clock) {\n\t\thost_tsc = native_read_tsc();\n\t\tkernel_ns = get_kernel_ns();\n\t}\n\n\ttsc_timestamp = kvm_x86_ops->read_l1_tsc(v, host_tsc);\n\n\t/*\n\t * We may have to catch up the TSC to match elapsed wall clock\n\t * time for two reasons, even if kvmclock is used.\n\t *   1) CPU could have been running below the maximum TSC rate\n\t *   2) Broken TSC compensation resets the base at each VCPU\n\t *      entry to avoid unknown leaps of TSC even when running\n\t *      again on the same CPU.  This may cause apparent elapsed\n\t *      time to disappear, and the guest to stand still or run\n\t *\tvery slowly.\n\t */\n\tif (vcpu->tsc_catchup) {\n\t\tu64 tsc = compute_guest_tsc(v, kernel_ns);\n\t\tif (tsc > tsc_timestamp) {\n\t\t\tadjust_tsc_offset_guest(v, tsc - tsc_timestamp);\n\t\t\ttsc_timestamp = tsc;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\tif (!vcpu->pv_time_enabled)\n\t\treturn 0;\n\n\t/*\n\t * Time as measured by the TSC may go backwards when resetting the base\n\t * tsc_timestamp.  The reason for this is that the TSC resolution is\n\t * higher than the resolution of the other clock scales.  Thus, many\n\t * possible measurments of the TSC correspond to one measurement of any\n\t * other clock, and so a spread of values is possible.  This is not a\n\t * problem for the computation of the nanosecond clock; with TSC rates\n\t * around 1GHZ, there can only be a few cycles which correspond to one\n\t * nanosecond value, and any path through this code will inevitably\n\t * take longer than that.  However, with the kernel_ns value itself,\n\t * the precision may be much lower, down to HZ granularity.  If the\n\t * first sampling of TSC against kernel_ns ends in the low part of the\n\t * range, and the second in the high end of the range, we can get:\n\t *\n\t * (TSC - offset_low) * S + kns_old > (TSC - offset_high) * S + kns_new\n\t *\n\t * As the sampling errors potentially range in the thousands of cycles,\n\t * it is possible such a time value has already been observed by the\n\t * guest.  To protect against this, we must compute the system time as\n\t * observed by the guest and ensure the new system time is greater.\n\t */\n\tmax_kernel_ns = 0;\n\tif (vcpu->hv_clock.tsc_timestamp) {\n\t\tmax_kernel_ns = vcpu->last_guest_tsc -\n\t\t\t\tvcpu->hv_clock.tsc_timestamp;\n\t\tmax_kernel_ns = pvclock_scale_delta(max_kernel_ns,\n\t\t\t\t    vcpu->hv_clock.tsc_to_system_mul,\n\t\t\t\t    vcpu->hv_clock.tsc_shift);\n\t\tmax_kernel_ns += vcpu->last_kernel_ns;\n\t}\n\n\tif (unlikely(vcpu->hw_tsc_khz != this_tsc_khz)) {\n\t\tkvm_get_time_scale(NSEC_PER_SEC / 1000, this_tsc_khz,\n\t\t\t\t   &vcpu->hv_clock.tsc_shift,\n\t\t\t\t   &vcpu->hv_clock.tsc_to_system_mul);\n\t\tvcpu->hw_tsc_khz = this_tsc_khz;\n\t}\n\n\t/* with a master <monotonic time, tsc value> tuple,\n\t * pvclock clock reads always increase at the (scaled) rate\n\t * of guest TSC - no need to deal with sampling errors.\n\t */\n\tif (!use_master_clock) {\n\t\tif (max_kernel_ns > kernel_ns)\n\t\t\tkernel_ns = max_kernel_ns;\n\t}\n\t/* With all the info we got, fill in the values */\n\tvcpu->hv_clock.tsc_timestamp = tsc_timestamp;\n\tvcpu->hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;\n\tvcpu->last_kernel_ns = kernel_ns;\n\tvcpu->last_guest_tsc = tsc_timestamp;\n\n\t/*\n\t * The interface expects us to write an even number signaling that the\n\t * update is finished. Since the guest won't see the intermediate\n\t * state, we just increase by 2 at the end.\n\t */\n\tvcpu->hv_clock.version += 2;\n\n\tif (unlikely(kvm_read_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t&guest_hv_clock, sizeof(guest_hv_clock))))\n\t\treturn 0;\n\n\t/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */\n\tpvclock_flags = (guest_hv_clock.flags & PVCLOCK_GUEST_STOPPED);\n\n\tif (vcpu->pvclock_set_guest_stopped_request) {\n\t\tpvclock_flags |= PVCLOCK_GUEST_STOPPED;\n\t\tvcpu->pvclock_set_guest_stopped_request = false;\n\t}\n\n\t/* If the host uses TSC clocksource, then it is stable */\n\tif (use_master_clock)\n\t\tpvclock_flags |= PVCLOCK_TSC_STABLE_BIT;\n\n\tvcpu->hv_clock.flags = pvclock_flags;\n\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock));\n\treturn 0;\n}\n\n/*\n * kvmclock updates which are isolated to a given vcpu, such as\n * vcpu->cpu migration, should not allow system_timestamp from\n * the rest of the vcpus to remain static. Otherwise ntp frequency\n * correction applies to one vcpu's system_timestamp but not\n * the others.\n *\n * So in those cases, request a kvmclock update for all vcpus.\n * The worst case for a remote vcpu to update its kvmclock\n * is then bounded by maximum nohz sleep latency.\n */\n\nstatic void kvm_gen_kvmclock_update(struct kvm_vcpu *v)\n{\n\tint i;\n\tstruct kvm *kvm = v->kvm;\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t\tkvm_vcpu_kick(vcpu);\n\t}\n}\n\nstatic bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool valid_pat_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0xf3; /* 0, 1, 4, 5, 6, 7 */\n}\n\nstatic bool valid_mtrr_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0x73; /* 0, 1, 4, 5, 6 */\n}\n\nstatic bool mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint i;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn false;\n\n\tif (msr == MSR_IA32_CR_PAT) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tif (!valid_pat_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tif (data & ~0xcff)\n\t\t\treturn false;\n\t\treturn valid_mtrr_type(data & 0xff);\n\t} else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {\n\t\tfor (i = 0; i < 8 ; i++)\n\t\t\tif (!valid_mtrr_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/* variable MTRRs */\n\treturn valid_mtrr_type(data & 0xff);\n}\n\nstatic int set_msr_mtrr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;\n\n\tif (!mtrr_valid(vcpu, msr, data))\n\t\treturn 1;\n\n\tif (msr == MSR_MTRRdefType) {\n\t\tvcpu->arch.mtrr_state.def_type = data;\n\t\tvcpu->arch.mtrr_state.enabled = (data & 0xc00) >> 10;\n\t} else if (msr == MSR_MTRRfix64K_00000)\n\t\tp[0] = data;\n\telse if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)\n\t\tp[1 + msr - MSR_MTRRfix16K_80000] = data;\n\telse if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)\n\t\tp[3 + msr - MSR_MTRRfix4K_C0000] = data;\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\tvcpu->arch.pat = data;\n\telse {\t/* Variable MTRRs */\n\t\tint idx, is_mtrr_mask;\n\t\tu64 *pt;\n\n\t\tidx = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * idx;\n\t\tif (!is_mtrr_mask)\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;\n\t\telse\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;\n\t\t*pt = data;\n\t}\n\n\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}\n\nstatic int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MC0_CTL + 4 * bank_num) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\t/* only 0 or all 1s can be written to IA32_MCi_CTL\n\t\t\t * some Linux kernels though clear bit 10 in bank 4 to\n\t\t\t * workaround a BIOS/GART TBL issue on AMD K8s, ignore\n\t\t\t * this to avoid an uncatched #GP in the guest\n\t\t\t */\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int xen_hvm_config(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tint lm = is_long_mode(vcpu);\n\tu8 *blob_addr = lm ? (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_64\n\t\t: (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_32;\n\tu8 blob_size = lm ? kvm->arch.xen_hvm_config.blob_size_64\n\t\t: kvm->arch.xen_hvm_config.blob_size_32;\n\tu32 page_num = data & ~PAGE_MASK;\n\tu64 page_addr = data & PAGE_MASK;\n\tu8 *page;\n\tint r;\n\n\tr = -E2BIG;\n\tif (page_num >= blob_size)\n\t\tgoto out;\n\tr = -ENOMEM;\n\tpage = memdup_user(blob_addr + (page_num * PAGE_SIZE), PAGE_SIZE);\n\tif (IS_ERR(page)) {\n\t\tr = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\tif (kvm_write_guest(kvm, page_addr, page, PAGE_SIZE))\n\t\tgoto out_free;\n\tr = 0;\nout_free:\n\tkfree(page);\nout:\n\treturn r;\n}\n\nstatic bool kvm_hv_hypercall_enabled(struct kvm *kvm)\n{\n\treturn kvm->arch.hv_hypercall & HV_X64_MSR_HYPERCALL_ENABLE;\n}\n\nstatic bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic int set_msr_hyperv_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tkvm->arch.hv_guest_os_id = data;\n\t\t/* setting guest os id to zero disables hypercall page */\n\t\tif (!kvm->arch.hv_guest_os_id)\n\t\t\tkvm->arch.hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\n\t\t/* if guest os id is not set hypercall should remain disabled */\n\t\tif (!kvm->arch.hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\tkvm->arch.hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops->patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; /* ret */\n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\tkvm->arch.hv_hypercall = data;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"HYPER-V unimplemented wrmsr: 0x%x \"\n\t\t\t    \"data 0x%llx\\n\", msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int set_msr_hyperv(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tswitch (msr) {\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE: {\n\t\tunsigned long addr;\n\n\t\tif (!(data & HV_X64_MSR_APIC_ASSIST_PAGE_ENABLE)) {\n\t\t\tvcpu->arch.hv_vapic = data;\n\t\t\tbreak;\n\t\t}\n\t\taddr = gfn_to_hva(vcpu->kvm, data >>\n\t\t\t\t  HV_X64_MSR_APIC_ASSIST_PAGE_ADDRESS_SHIFT);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tif (__clear_user((void __user *)addr, PAGE_SIZE))\n\t\t\treturn 1;\n\t\tvcpu->arch.hv_vapic = data;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data);\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"HYPER-V unimplemented wrmsr: 0x%x \"\n\t\t\t    \"data 0x%llx\\n\", msr, data);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)\n{\n\tgpa_t gpa = data & ~0x3f;\n\n\t/* Bits 2:5 are reserved, Should be zero */\n\tif (data & 0x3c)\n\t\treturn 1;\n\n\tvcpu->arch.apf.msr_val = data;\n\n\tif (!(data & KVM_ASYNC_PF_ENABLED)) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,\n\t\t\t\t\tsizeof(u32)))\n\t\treturn 1;\n\n\tvcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);\n\tkvm_async_pf_wakeup_all(vcpu);\n\treturn 0;\n}\n\nstatic void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}\n\nstatic void accumulate_steal_time(struct kvm_vcpu *vcpu)\n{\n\tu64 delta;\n\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tdelta = current->sched_info.run_delay - vcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\tvcpu->arch.st.accum_steal = delta;\n}\n\nstatic void record_steal_time(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tif (unlikely(kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time))))\n\t\treturn;\n\n\tvcpu->arch.st.steal.steal += vcpu->arch.st.accum_steal;\n\tvcpu->arch.st.steal.version += 2;\n\tvcpu->arch.st.accum_steal = 0;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n}\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn set_msr_mtrr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\tkvm_set_apic_base(vcpu, data);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\tu64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tkvm_x86_ops->adjust_tsc_offset(vcpu, adj, true);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tkvmclock_reset(vcpu);\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\n\t\tpreempt_disable();\n\t\taccumulate_steal_time(vcpu);\n\t\tpreempt_enable();\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\t/* Performance counters are not protected by a CPUID bit,\n\t * so we should check all of them in the generic path for the sake of\n\t * cross vendor migration.\n\t * Writing a zero into the event select MSRs disables them,\n\t * which we perfectly emulate ;-). Any other value should be at least\n\t * reported, some guests depend on them.\n\t */\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_EVNTSEL1:\n\tcase MSR_K7_EVNTSEL2:\n\tcase MSR_K7_EVNTSEL3:\n\t\tif (data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\t/* at least RHEL 4 unconditionally writes to the perfctr registers,\n\t * so we ignore writes to make it happy.\n\t */\n\tcase MSR_K7_PERFCTR0:\n\tcase MSR_K7_PERFCTR1:\n\tcase MSR_K7_PERFCTR2:\n\tcase MSR_K7_PERFCTR3:\n\t\tvcpu_unimpl(vcpu, \"unimplemented perfctr wrmsr: \"\n\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\t\tpr = true;\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\t\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\t\tint r;\n\t\t\tmutex_lock(&vcpu->kvm->lock);\n\t\t\tr = set_msr_hyperv_pw(vcpu, msr, data);\n\t\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\t\treturn r;\n\t\t} else\n\t\t\treturn set_msr_hyperv(vcpu, msr, data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_msr_common);\n\n\n/*\n * Reads an msr value (of 'msr_index') into 'pdata'.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nint kvm_get_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata)\n{\n\treturn kvm_x86_ops->get_msr(vcpu, msr_index, pdata);\n}\n\nstatic int get_msr_mtrr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn 1;\n\n\tif (msr == MSR_MTRRdefType)\n\t\t*pdata = vcpu->arch.mtrr_state.def_type +\n\t\t\t (vcpu->arch.mtrr_state.enabled << 10);\n\telse if (msr == MSR_MTRRfix64K_00000)\n\t\t*pdata = p[0];\n\telse if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)\n\t\t*pdata = p[1 + msr - MSR_MTRRfix16K_80000];\n\telse if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)\n\t\t*pdata = p[3 + msr - MSR_MTRRfix4K_C0000];\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\t*pdata = vcpu->arch.pat;\n\telse {\t/* Variable MTRRs */\n\t\tint idx, is_mtrr_mask;\n\t\tu64 *pt;\n\n\t\tidx = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * idx;\n\t\tif (!is_mtrr_mask)\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;\n\t\telse\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;\n\t\t*pdata = *pt;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MC0_CTL + 4 * bank_num) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\n\nstatic int get_msr_hyperv_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = kvm->arch.hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = kvm->arch.hv_hypercall;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}\n\nstatic int get_msr_hyperv(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX: {\n\t\tint r;\n\t\tstruct kvm_vcpu *v;\n\t\tkvm_for_each_vcpu(r, v, vcpu->kvm)\n\t\t\tif (v == vcpu)\n\t\t\t\tdata = r;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE:\n\t\tdata = vcpu->arch.hv_vapic;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\n\tswitch (msr) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K7_HWCR:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_PERFCTR0:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr, pdata);\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tdata = 0x100000000ULL;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\t\tdata = 0x500 | KVM_NR_VAR_MTRR;\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn get_msr_mtrr(vcpu, msr, pdata);\n\tcase 0xcd: /* fsb frequency */\n\t\tdata = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tdata = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tdata = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr, pdata);\n\t\tbreak;\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tdata = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tdata = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tdata = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tdata = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tdata |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tdata = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tdata = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tdata = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tdata = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tdata = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tdata = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1:\n\t\treturn get_msr_mce(vcpu, msr, pdata);\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tdata = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\t\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\t\tint r;\n\t\t\tmutex_lock(&vcpu->kvm->lock);\n\t\t\tr = get_msr_hyperv_pw(vcpu, msr, pdata);\n\t\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\t\treturn r;\n\t\t} else\n\t\t\treturn get_msr_hyperv(vcpu, msr, pdata);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tdata = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.osvw.status;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr, pdata);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled rdmsr: 0x%x\\n\", msr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\", msr);\n\t\t\tdata = 0;\n\t\t}\n\t\tbreak;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_get_msr_common);\n\n/*\n * Read or write a bunch of msrs. All parameters are kernel addresses.\n *\n * @return number of msrs set successfully.\n */\nstatic int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}\n\n/*\n * Read or write a bunch of msrs. Parameters are user addresses.\n *\n * @return number of msrs set successfully.\n */\nstatic int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,\n\t\t  int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned index, u64 *data),\n\t\t  int writeback)\n{\n\tstruct kvm_msrs msrs;\n\tstruct kvm_msr_entry *entries;\n\tint r, n;\n\tunsigned size;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&msrs, user_msrs, sizeof msrs))\n\t\tgoto out;\n\n\tr = -E2BIG;\n\tif (msrs.nmsrs >= MAX_IO_MSRS)\n\t\tgoto out;\n\n\tsize = sizeof(struct kvm_msr_entry) * msrs.nmsrs;\n\tentries = memdup_user(user_msrs->entries, size);\n\tif (IS_ERR(entries)) {\n\t\tr = PTR_ERR(entries);\n\t\tgoto out;\n\t}\n\n\tr = n = __msr_io(vcpu, &msrs, entries, do_msr);\n\tif (r < 0)\n\t\tgoto out_free;\n\n\tr = -EFAULT;\n\tif (writeback && copy_to_user(user_msrs->entries, entries, size))\n\t\tgoto out_free;\n\n\tr = n;\n\nout_free:\n\tkfree(entries);\nout:\n\treturn r;\n}\n\nint kvm_dev_ioctl_check_extension(long ext)\n{\n\tint r;\n\n\tswitch (ext) {\n\tcase KVM_CAP_IRQCHIP:\n\tcase KVM_CAP_HLT:\n\tcase KVM_CAP_MMU_SHADOW_CACHE_CONTROL:\n\tcase KVM_CAP_SET_TSS_ADDR:\n\tcase KVM_CAP_EXT_CPUID:\n\tcase KVM_CAP_EXT_EMUL_CPUID:\n\tcase KVM_CAP_CLOCKSOURCE:\n\tcase KVM_CAP_PIT:\n\tcase KVM_CAP_NOP_IO_DELAY:\n\tcase KVM_CAP_MP_STATE:\n\tcase KVM_CAP_SYNC_MMU:\n\tcase KVM_CAP_USER_NMI:\n\tcase KVM_CAP_REINJECT_CONTROL:\n\tcase KVM_CAP_IRQ_INJECT_STATUS:\n\tcase KVM_CAP_IRQFD:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_PIT2:\n\tcase KVM_CAP_PIT_STATE2:\n\tcase KVM_CAP_SET_IDENTITY_MAP_ADDR:\n\tcase KVM_CAP_XEN_HVM:\n\tcase KVM_CAP_ADJUST_CLOCK:\n\tcase KVM_CAP_VCPU_EVENTS:\n\tcase KVM_CAP_HYPERV:\n\tcase KVM_CAP_HYPERV_VAPIC:\n\tcase KVM_CAP_HYPERV_SPIN:\n\tcase KVM_CAP_PCI_SEGMENT:\n\tcase KVM_CAP_DEBUGREGS:\n\tcase KVM_CAP_X86_ROBUST_SINGLESTEP:\n\tcase KVM_CAP_XSAVE:\n\tcase KVM_CAP_ASYNC_PF:\n\tcase KVM_CAP_GET_TSC_KHZ:\n\tcase KVM_CAP_KVMCLOCK_CTRL:\n\tcase KVM_CAP_READONLY_MEM:\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n\tcase KVM_CAP_ASSIGN_DEV_IRQ:\n\tcase KVM_CAP_PCI_2_3:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_COALESCED_MMIO:\n\t\tr = KVM_COALESCED_MMIO_PAGE_OFFSET;\n\t\tbreak;\n\tcase KVM_CAP_VAPIC:\n\t\tr = !kvm_x86_ops->cpu_has_accelerated_tpr();\n\t\tbreak;\n\tcase KVM_CAP_NR_VCPUS:\n\t\tr = KVM_SOFT_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_PV_MMU:\t/* obsolete */\n\t\tr = 0;\n\t\tbreak;\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n\tcase KVM_CAP_IOMMU:\n\t\tr = iommu_present(&pci_bus_type);\n\t\tbreak;\n#endif\n\tcase KVM_CAP_MCE:\n\t\tr = KVM_MAX_MCE_BANKS;\n\t\tbreak;\n\tcase KVM_CAP_XCRS:\n\t\tr = cpu_has_xsave;\n\t\tbreak;\n\tcase KVM_CAP_TSC_CONTROL:\n\t\tr = kvm_has_tsc_control;\n\t\tbreak;\n\tcase KVM_CAP_TSC_DEADLINE_TIMER:\n\t\tr = boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER);\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}\n\nlong kvm_arch_dev_ioctl(struct file *filp,\n\t\t\tunsigned int ioctl, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tlong r;\n\n\tswitch (ioctl) {\n\tcase KVM_GET_MSR_INDEX_LIST: {\n\t\tstruct kvm_msr_list __user *user_msr_list = argp;\n\t\tstruct kvm_msr_list msr_list;\n\t\tunsigned n;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msr_list, user_msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tn = msr_list.nmsrs;\n\t\tmsr_list.nmsrs = num_msrs_to_save + ARRAY_SIZE(emulated_msrs);\n\t\tif (copy_to_user(user_msr_list, &msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tr = -E2BIG;\n\t\tif (n < msr_list.nmsrs)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(user_msr_list->indices, &msrs_to_save,\n\t\t\t\t num_msrs_to_save * sizeof(u32)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(user_msr_list->indices + num_msrs_to_save,\n\t\t\t\t &emulated_msrs,\n\t\t\t\t ARRAY_SIZE(emulated_msrs) * sizeof(u32)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_SUPPORTED_CPUID:\n\tcase KVM_GET_EMULATED_CPUID: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\n\t\tr = kvm_dev_ioctl_get_cpuid(&cpuid, cpuid_arg->entries,\n\t\t\t\t\t    ioctl);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_X86_GET_MCE_CAP_SUPPORTED: {\n\t\tu64 mce_cap;\n\n\t\tmce_cap = KVM_MCE_CAP_SUPPORTED;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &mce_cap, sizeof mce_cap))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\treturn r;\n}\n\nstatic void wbinvd_ipi(void *garbage)\n{\n\twbinvd();\n}\n\nstatic bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_has_noncoherent_dma(vcpu->kvm);\n}\n\nvoid kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\t/* Address WBINVD may be executed by guest */\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\n\t/* Apply any externally detected TSC adjustments (due to suspend) */\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t}\n\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\tnative_read_tsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_x86_ops->compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\t/*\n\t\t * On a host with synchronized TSC, there is no need to update\n\t\t * kvmclock on vcpu->cpu migration\n\t\t */\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\n\taccumulate_steal_time(vcpu);\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}\n\nvoid kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = native_read_tsc();\n}\n\nstatic int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\tmemcpy(s->regs, vcpu->arch.apic->regs, sizeof *s);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tkvm_apic_post_state_restore(vcpu, s);\n\tupdate_cr8_intercept(vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_interrupt *irq)\n{\n\tif (irq->irq >= KVM_NR_INTERRUPTS)\n\t\treturn -EINVAL;\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\treturn -ENXIO;\n\n\tkvm_queue_interrupt(vcpu, irq->irq, false);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)\n{\n\tkvm_inject_nmi(vcpu);\n\n\treturn 0;\n}\n\nstatic int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   struct kvm_tpr_access_ctl *tac)\n{\n\tif (tac->flags)\n\t\treturn -EINVAL;\n\tvcpu->arch.tpr_access_reporting = !!tac->enabled;\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu64 mcg_cap)\n{\n\tint r;\n\tunsigned bank_num = mcg_cap & 0xff, bank;\n\n\tr = -EINVAL;\n\tif (!bank_num || bank_num >= KVM_MAX_MCE_BANKS)\n\t\tgoto out;\n\tif (mcg_cap & ~(KVM_MCE_CAP_SUPPORTED | 0xff | 0xff0000))\n\t\tgoto out;\n\tr = 0;\n\tvcpu->arch.mcg_cap = mcg_cap;\n\t/* Init IA32_MCG_CTL to all 1s */\n\tif (mcg_cap & MCG_CTL_P)\n\t\tvcpu->arch.mcg_ctl = ~(u64)0;\n\t/* Init IA32_MCi_CTL to all 1s */\n\tfor (bank = 0; bank < bank_num; bank++)\n\t\tvcpu->arch.mce_banks[bank*4] = ~(u64)0;\nout:\n\treturn r;\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_x86_mce *mce)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu64 *banks = vcpu->arch.mce_banks;\n\n\tif (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))\n\t\treturn -EINVAL;\n\t/*\n\t * if IA32_MCG_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\t    vcpu->arch.mcg_ctl != ~(u64)0)\n\t\treturn 0;\n\tbanks += 4 * mce->bank;\n\t/*\n\t * if IA32_MCi_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled for the bank\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)\n\t\treturn 0;\n\tif (mce->status & MCI_STATUS_UC) {\n\t\tif ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||\n\t\t    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\t\treturn 0;\n\t\t}\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tvcpu->arch.mcg_status = mce->mcg_status;\n\t\tbanks[1] = mce->status;\n\t\tkvm_queue_exception(vcpu, MC_VECTOR);\n\t} else if (!(banks[1] & MCI_STATUS_VAL)\n\t\t   || !(banks[1] & MCI_STATUS_UC)) {\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tbanks[1] = mce->status;\n\t} else\n\t\tbanks[1] |= MCI_STATUS_OVER;\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tprocess_nmi(vcpu);\n\tevents->exception.injected =\n\t\tvcpu->arch.exception.pending &&\n\t\t!kvm_exception_is_soft(vcpu->arch.exception.nr);\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.pad = 0;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow =\n\t\tkvm_x86_ops->get_interrupt_shadow(vcpu,\n\t\t\tKVM_X86_SHADOW_INT_MOV_SS | KVM_X86_SHADOW_INT_STI);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending != 0;\n\tevents->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);\n\tevents->nmi.pad = 0;\n\n\tevents->sipi_vector = 0; /* never valid when reporting to user space */\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW);\n\tmemset(&events->reserved, 0, sizeof(events->reserved));\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct kvm_vcpu_events *events)\n{\n\tif (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t      | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t      | KVM_VCPUEVENT_VALID_SHADOW))\n\t\treturn -EINVAL;\n\n\tprocess_nmi(vcpu);\n\tvcpu->arch.exception.pending = events->exception.injected;\n\tvcpu->arch.exception.nr = events->exception.nr;\n\tvcpu->arch.exception.has_error_code = events->exception.has_error_code;\n\tvcpu->arch.exception.error_code = events->exception.error_code;\n\n\tvcpu->arch.interrupt.pending = events->interrupt.injected;\n\tvcpu->arch.interrupt.nr = events->interrupt.nr;\n\tvcpu->arch.interrupt.soft = events->interrupt.soft;\n\tif (events->flags & KVM_VCPUEVENT_VALID_SHADOW)\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu,\n\t\t\t\t\t\t  events->interrupt.shadow);\n\n\tvcpu->arch.nmi_injected = events->nmi.injected;\n\tif (events->flags & KVM_VCPUEVENT_VALID_NMI_PENDING)\n\t\tvcpu->arch.nmi_pending = events->nmi.pending;\n\tkvm_x86_ops->set_nmi_mask(vcpu, events->nmi.masked);\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SIPI_VECTOR &&\n\t    kvm_vcpu_has_lapic(vcpu))\n\t\tvcpu->arch.apic->sipi_vector = events->sipi_vector;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tdbgregs->dr6 = vcpu->arch.dr6;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_debugregs *dbgregs)\n{\n\tif (dbgregs->flags)\n\t\treturn -EINVAL;\n\n\tmemcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));\n\tvcpu->arch.dr6 = dbgregs->dr6;\n\tvcpu->arch.dr7 = dbgregs->dr7;\n\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_xsave *guest_xsave)\n{\n\tif (cpu_has_xsave) {\n\t\tmemcpy(guest_xsave->region,\n\t\t\t&vcpu->arch.guest_fpu.state->xsave,\n\t\t\tvcpu->arch.guest_xstate_size);\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] &=\n\t\t\tvcpu->arch.guest_supported_xcr0 | XSTATE_FPSSE;\n\t} else {\n\t\tmemcpy(guest_xsave->region,\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave,\n\t\t\tsizeof(struct i387_fxsave_struct));\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] =\n\t\t\tXSTATE_FPSSE;\n\t}\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xsave *guest_xsave)\n{\n\tu64 xstate_bv =\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)];\n\n\tif (cpu_has_xsave) {\n\t\t/*\n\t\t * Here we allow setting states that are not present in\n\t\t * CPUID leaf 0xD, index 0, EDX:EAX.  This is for compatibility\n\t\t * with old userspace.\n\t\t */\n\t\tif (xstate_bv & ~KVM_SUPPORTED_XCR0)\n\t\t\treturn -EINVAL;\n\t\tif (xstate_bv & ~host_xcr0)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&vcpu->arch.guest_fpu.state->xsave,\n\t\t\tguest_xsave->region, vcpu->arch.guest_xstate_size);\n\t} else {\n\t\tif (xstate_bv & ~XSTATE_FPSSE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&vcpu->arch.guest_fpu.state->fxsave,\n\t\t\tguest_xsave->region, sizeof(struct i387_fxsave_struct));\n\t}\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!cpu_has_xsave) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct kvm_xcrs *guest_xcrs)\n{\n\tint i, r = 0;\n\n\tif (!cpu_has_xsave)\n\t\treturn -EINVAL;\n\n\tif (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < guest_xcrs->nr_xcrs; i++)\n\t\t/* Only support XCR0 currently */\n\t\tif (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {\n\t\t\tr = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,\n\t\t\t\tguest_xcrs->xcrs[i].value);\n\t\t\tbreak;\n\t\t}\n\tif (r)\n\t\tr = -EINVAL;\n\treturn r;\n}\n\n/*\n * kvm_set_guest_paused() indicates to the guest kernel that it has been\n * stopped by the hypervisor.  This function will be called from the host only.\n * EINVAL is returned when the host attempts to set the flag for a guest that\n * does not support pv clocks.\n */\nstatic int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.pv_time_enabled)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}\n\nlong kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tunion {\n\t\tstruct kvm_lapic_state *lapic;\n\t\tstruct kvm_xsave *xsave;\n\t\tstruct kvm_xcrs *xcrs;\n\t\tvoid *buffer;\n\t} u;\n\n\tu.buffer = NULL;\n\tswitch (ioctl) {\n\tcase KVM_GET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!vcpu->arch.apic)\n\t\t\tgoto out;\n\t\tu.lapic = kzalloc(sizeof(struct kvm_lapic_state), GFP_KERNEL);\n\n\t\tr = -ENOMEM;\n\t\tif (!u.lapic)\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_lapic(vcpu, u.lapic);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.lapic, sizeof(struct kvm_lapic_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!vcpu->arch.apic)\n\t\t\tgoto out;\n\t\tu.lapic = memdup_user(argp, sizeof(*u.lapic));\n\t\tif (IS_ERR(u.lapic))\n\t\t\treturn PTR_ERR(u.lapic);\n\n\t\tr = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);\n\t\tbreak;\n\t}\n\tcase KVM_INTERRUPT: {\n\t\tstruct kvm_interrupt irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq, argp, sizeof irq))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_interrupt(vcpu, &irq);\n\t\tbreak;\n\t}\n\tcase KVM_NMI: {\n\t\tr = kvm_vcpu_ioctl_nmi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID: {\n\t\tstruct kvm_cpuid __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid(vcpu, &cpuid, cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_MSRS:\n\t\tr = msr_io(vcpu, argp, kvm_get_msr, 1);\n\t\tbreak;\n\tcase KVM_SET_MSRS:\n\t\tr = msr_io(vcpu, argp, do_set_msr, 0);\n\t\tbreak;\n\tcase KVM_TPR_ACCESS_REPORTING: {\n\t\tstruct kvm_tpr_access_ctl tac;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tac, argp, sizeof tac))\n\t\t\tgoto out;\n\t\tr = vcpu_ioctl_tpr_access_reporting(vcpu, &tac);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tac, sizeof tac))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t};\n\tcase KVM_SET_VAPIC_ADDR: {\n\t\tstruct kvm_vapic_addr va;\n\n\t\tr = -EINVAL;\n\t\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&va, argp, sizeof va))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tkvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SETUP_MCE: {\n\t\tu64 mcg_cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mcg_cap, argp, sizeof mcg_cap))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SET_MCE: {\n\t\tstruct kvm_x86_mce mce;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mce, argp, sizeof mce))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);\n\t\tbreak;\n\t}\n\tcase KVM_GET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &events, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tkvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &dbgregs,\n\t\t\t\t sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbgregs, argp,\n\t\t\t\t   sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XSAVE: {\n\t\tu.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XSAVE: {\n\t\tu.xsave = memdup_user(argp, sizeof(*u.xsave));\n\t\tif (IS_ERR(u.xsave))\n\t\t\treturn PTR_ERR(u.xsave);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XCRS: {\n\t\tu.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xcrs)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xcrs,\n\t\t\t\t sizeof(struct kvm_xcrs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XCRS: {\n\t\tu.xcrs = memdup_user(argp, sizeof(*u.xcrs));\n\t\tif (IS_ERR(u.xcrs))\n\t\t\treturn PTR_ERR(u.xcrs);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\n\t\tr = -EINVAL;\n\t\tuser_tsc_khz = (u32)arg;\n\n\t\tif (user_tsc_khz >= kvm_max_guest_tsc_khz)\n\t\t\tgoto out;\n\n\t\tif (user_tsc_khz == 0)\n\t\t\tuser_tsc_khz = tsc_khz;\n\n\t\tkvm_set_tsc_khz(vcpu, user_tsc_khz);\n\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tcase KVM_GET_TSC_KHZ: {\n\t\tr = vcpu->arch.virtual_tsc_khz;\n\t\tgoto out;\n\t}\n\tcase KVM_KVMCLOCK_CTRL: {\n\t\tr = kvm_set_guest_paused(vcpu);\n\t\tgoto out;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\tkfree(u.buffer);\n\treturn r;\n}\n\nint kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)\n{\n\treturn VM_FAULT_SIGBUS;\n}\n\nstatic int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)\n{\n\tint ret;\n\n\tif (addr > (unsigned int)(-3 * PAGE_SIZE))\n\t\treturn -EINVAL;\n\tret = kvm_x86_ops->set_tss_addr(kvm, addr);\n\treturn ret;\n}\n\nstatic int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,\n\t\t\t\t\t      u64 ident_addr)\n{\n\tkvm->arch.ept_identity_map_addr = ident_addr;\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,\n\t\t\t\t\t  u32 kvm_nr_mmu_pages)\n{\n\tif (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);\n\tkvm->arch.n_requested_mmu_pages = kvm_nr_mmu_pages;\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)\n{\n\treturn kvm->arch.n_max_mmu_pages;\n}\n\nstatic int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[0],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[1],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_get_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[0],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[1],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_set_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\tkvm_pic_update_irq(pic_irqchip(kvm));\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps, &kvm->arch.vpit->pit_state, sizeof(struct kvm_pit_state));\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps->channels, &kvm->arch.vpit->pit_state.channels,\n\t\tsizeof(ps->channels));\n\tps->flags = kvm->arch.vpit->pit_state.flags;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\tmemset(&ps->reserved, 0, sizeof(ps->reserved));\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint r = 0, start = 0;\n\tu32 prev_legacy, cur_legacy;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n\t       sizeof(kvm->arch.vpit->pit_state.channels));\n\tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tif (!kvm->arch.vpit)\n\t\treturn -ENXIO;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tkvm->arch.vpit->pit_state.reinject = control->pit_reinject;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}\n\n/**\n * kvm_vm_ioctl_get_dirty_log - get and clear the log of dirty pages in a slot\n * @kvm: kvm instance\n * @log: slot id and address to which we copy the log\n *\n * We need to keep it in mind that VCPU threads can write to the bitmap\n * concurrently.  So, to avoid losing data, we keep the following order for\n * each bit:\n *\n *   1. Take a snapshot of the bit and clear it if needed.\n *   2. Write protect the corresponding page.\n *   3. Flush TLB's if needed.\n *   4. Copy the snapshot to the userspace.\n *\n * Between 2 and 3, the guest may write to the page using the remaining TLB\n * entry.  This is not a problem because the page will be reported dirty at\n * step 4 using the snapshot taken before and step 3 ensures that successive\n * writes will be logged for the next call.\n */\nint kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)\n{\n\tint r;\n\tstruct kvm_memory_slot *memslot;\n\tunsigned long n, i;\n\tunsigned long *dirty_bitmap;\n\tunsigned long *dirty_bitmap_buffer;\n\tbool is_dirty = false;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tr = -EINVAL;\n\tif (log->slot >= KVM_USER_MEM_SLOTS)\n\t\tgoto out;\n\n\tmemslot = id_to_memslot(kvm->memslots, log->slot);\n\n\tdirty_bitmap = memslot->dirty_bitmap;\n\tr = -ENOENT;\n\tif (!dirty_bitmap)\n\t\tgoto out;\n\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\n\tdirty_bitmap_buffer = dirty_bitmap + n / sizeof(long);\n\tmemset(dirty_bitmap_buffer, 0, n);\n\n\tspin_lock(&kvm->mmu_lock);\n\n\tfor (i = 0; i < n / sizeof(long); i++) {\n\t\tunsigned long mask;\n\t\tgfn_t offset;\n\n\t\tif (!dirty_bitmap[i])\n\t\t\tcontinue;\n\n\t\tis_dirty = true;\n\n\t\tmask = xchg(&dirty_bitmap[i], 0);\n\t\tdirty_bitmap_buffer[i] = mask;\n\n\t\toffset = i * BITS_PER_LONG;\n\t\tkvm_mmu_write_protect_pt_masked(kvm, memslot, offset, mask);\n\t}\n\tif (is_dirty)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\tspin_unlock(&kvm->mmu_lock);\n\n\tr = -EFAULT;\n\tif (copy_to_user(log->dirty_bitmap, dirty_bitmap_buffer, n))\n\t\tgoto out;\n\n\tr = 0;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nint kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,\n\t\t\tbool line_status)\n{\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -ENXIO;\n\n\tirq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event->irq, irq_event->level,\n\t\t\t\t\tline_status);\n\treturn 0;\n}\n\nlong kvm_arch_vm_ioctl(struct file *filp,\n\t\t       unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r = -ENOTTY;\n\t/*\n\t * This union makes it completely explicit to gcc-3.x\n\t * that these two variables' stack usage should be\n\t * combined, not added together.\n\t */\n\tunion {\n\t\tstruct kvm_pit_state ps;\n\t\tstruct kvm_pit_state2 ps2;\n\t\tstruct kvm_pit_config pit_config;\n\t} u;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_TSS_ADDR:\n\t\tr = kvm_vm_ioctl_set_tss_addr(kvm, arg);\n\t\tbreak;\n\tcase KVM_SET_IDENTITY_MAP_ADDR: {\n\t\tu64 ident_addr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&ident_addr, argp, sizeof ident_addr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);\n\t\tbreak;\n\t}\n\tcase KVM_SET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);\n\t\tbreak;\n\tcase KVM_GET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_get_nr_mmu_pages(kvm);\n\t\tbreak;\n\tcase KVM_CREATE_IRQCHIP: {\n\t\tstruct kvm_pic *vpic;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpic)\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -EINVAL;\n\t\tif (atomic_read(&kvm->online_vcpus))\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -ENOMEM;\n\t\tvpic = kvm_create_pic(kvm);\n\t\tif (vpic) {\n\t\t\tr = kvm_ioapic_init(kvm);\n\t\t\tif (r) {\n\t\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_master);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_slave);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_eclr);\n\t\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t\t\tkfree(vpic);\n\t\t\t\tgoto create_irqchip_unlock;\n\t\t\t}\n\t\t} else\n\t\t\tgoto create_irqchip_unlock;\n\t\tsmp_wmb();\n\t\tkvm->arch.vpic = vpic;\n\t\tsmp_wmb();\n\t\tr = kvm_setup_default_irq_routing(kvm);\n\t\tif (r) {\n\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\tmutex_lock(&kvm->irq_lock);\n\t\t\tkvm_ioapic_destroy(kvm);\n\t\t\tkvm_destroy_pic(kvm);\n\t\t\tmutex_unlock(&kvm->irq_lock);\n\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t}\n\tcreate_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CREATE_PIT:\n\t\tu.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;\n\t\tgoto create_pit;\n\tcase KVM_CREATE_PIT2:\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.pit_config, argp,\n\t\t\t\t   sizeof(struct kvm_pit_config)))\n\t\t\tgoto out;\n\tcreate_pit:\n\t\tmutex_lock(&kvm->slots_lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpit)\n\t\t\tgoto create_pit_unlock;\n\t\tr = -ENOMEM;\n\t\tkvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);\n\t\tif (kvm->arch.vpit)\n\t\t\tr = 0;\n\tcreate_pit_unlock:\n\t\tmutex_unlock(&kvm->slots_lock);\n\t\tbreak;\n\tcase KVM_GET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto get_irqchip_out;\n\t\tr = kvm_vm_ioctl_get_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto get_irqchip_out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, chip, sizeof *chip))\n\t\t\tgoto get_irqchip_out;\n\t\tr = 0;\n\tget_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_SET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto set_irqchip_out;\n\t\tr = kvm_vm_ioctl_set_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto set_irqchip_out;\n\t\tr = 0;\n\tset_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof u.ps))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit(kvm, &u.ps);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT2: {\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps2, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT2: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);\n\t\tbreak;\n\t}\n\tcase KVM_REINJECT_CONTROL: {\n\t\tstruct kvm_reinject_control control;\n\t\tr =  -EFAULT;\n\t\tif (copy_from_user(&control, argp, sizeof(control)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_reinject(kvm, &control);\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_CONFIG: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm->arch.xen_hvm_config, argp,\n\t\t\t\t   sizeof(struct kvm_xen_hvm_config)))\n\t\t\tgoto out;\n\t\tr = -EINVAL;\n\t\tif (kvm->arch.xen_hvm_config.flags)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\t\ts64 delta;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&user_ns, argp, sizeof(user_ns)))\n\t\t\tgoto out;\n\n\t\tr = -EINVAL;\n\t\tif (user_ns.flags)\n\t\t\tgoto out;\n\n\t\tr = 0;\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tdelta = user_ns.clock - now_ns;\n\t\tlocal_irq_enable();\n\t\tkvm->arch.kvmclock_offset = delta;\n\t\tkvm_gen_update_masterclock(kvm);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tuser_ns.clock = kvm->arch.kvmclock_offset + now_ns;\n\t\tlocal_irq_enable();\n\t\tuser_ns.flags = 0;\n\t\tmemset(&user_ns.pad, 0, sizeof(user_ns.pad));\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &user_ns, sizeof(user_ns)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t;\n\t}\nout:\n\treturn r;\n}\n\nstatic void kvm_init_msr_list(void)\n{\n\tu32 dummy[2];\n\tunsigned i, j;\n\n\t/* skip the first msrs in the list. KVM-specific */\n\tfor (i = j = KVM_SAVE_MSRS_BEGIN; i < ARRAY_SIZE(msrs_to_save); i++) {\n\t\tif (rdmsr_safe(msrs_to_save[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\t\tif (j < i)\n\t\t\tmsrs_to_save[j] = msrs_to_save[i];\n\t\tj++;\n\t}\n\tnum_msrs_to_save = j;\n}\n\nstatic int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,\n\t\t\t   const void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(vcpu->arch.apic &&\n\t\t      !kvm_iodevice_write(&vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_write(vcpu->kvm, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n\nstatic int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(vcpu->arch.apic &&\n\t\t      !kvm_iodevice_read(&vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_read(vcpu->kvm, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, *(u64 *)v);\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n\nstatic void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}\n\ngpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u32 access)\n{\n\tgpa_t t_gpa;\n\tstruct x86_exception exception;\n\n\tBUG_ON(!mmu_is_nested(vcpu));\n\n\t/* NPT walks are always user-walks */\n\taccess |= PFERR_USER_MASK;\n\tt_gpa  = vcpu->arch.mmu.gva_to_gpa(vcpu, gpa, access, &exception);\n\n\treturn t_gpa;\n}\n\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}\n\n gpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_FETCH_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}\n\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}\n\n/* uses this to access any guest's mapped memory without checking CPL */\ngpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, 0, exception);\n}\n\nstatic int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access,\n\t\t\t\t\t\t\t    exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_read_guest(vcpu->kvm, gpa, data, toread);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= toread;\n\t\tdata += toread;\n\t\taddr += toread;\n\t}\nout:\n\treturn r;\n}\n\n/* used for instruction fetching */\nstatic int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tgva_t addr, void *val, unsigned int bytes,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu,\n\t\t\t\t\t  access | PFERR_FETCH_MASK,\n\t\t\t\t\t  exception);\n}\n\nint kvm_read_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t       gva_t addr, void *val, unsigned int bytes,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,\n\t\t\t\t\t  exception);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_virt);\n\nstatic int kvm_read_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t      gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, 0, exception);\n}\n\nint kvm_write_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       gva_t addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa =  vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr,\n\t\t\t\t\t\t\t     PFERR_WRITE_MASK,\n\t\t\t\t\t\t\t     exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_write_guest(vcpu->kvm, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest_virt_system);\n\nstatic int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,\n\t\t\t\tgpa_t *gpa, struct x86_exception *exception,\n\t\t\t\tbool write)\n{\n\tu32 access = ((kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0)\n\t\t| (write ? PFERR_WRITE_MASK : 0);\n\n\tif (vcpu_match_mmio_gva(vcpu, gva)\n\t    && !permission_fault(vcpu->arch.walk_mmu, vcpu->arch.access, access)) {\n\t\t*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |\n\t\t\t\t\t(gva & (PAGE_SIZE - 1));\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, false);\n\t\treturn 1;\n\t}\n\n\t*gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n\n\tif (*gpa == UNMAPPED_GVA)\n\t\treturn -1;\n\n\t/* For APIC access vmexit */\n\tif ((*gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\treturn 1;\n\n\tif (vcpu_match_mmio_gpa(vcpu, *gpa)) {\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tconst void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_mmu_pte_write(vcpu, gpa, val, bytes);\n\treturn 1;\n}\n\nstruct read_write_emulator_ops {\n\tint (*read_write_prepare)(struct kvm_vcpu *vcpu, void *val,\n\t\t\t\t  int bytes);\n\tint (*read_write_emulate)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\t  void *val, int bytes);\n\tint (*read_write_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t       int bytes, void *val);\n\tint (*read_write_exit_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\t    void *val, int bytes);\n\tbool write;\n};\n\nstatic int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_fragments[0].gpa, *(u64 *)val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tvoid *val, int bytes)\n{\n\treturn !kvm_read_guest(vcpu->kvm, gpa, val, bytes);\n}\n\nstatic int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t void *val, int bytes)\n{\n\treturn emulator_write_phys(vcpu, gpa, val, bytes);\n}\n\nstatic int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, *(u64 *)val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}\n\nstatic int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, 0);\n\treturn X86EMUL_IO_NEEDED;\n}\n\nstatic int write_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t   void *val, int bytes)\n{\n\tstruct kvm_mmio_fragment *frag = &vcpu->mmio_fragments[0];\n\n\tmemcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic const struct read_write_emulator_ops read_emultor = {\n\t.read_write_prepare = read_prepare,\n\t.read_write_emulate = read_emulate,\n\t.read_write_mmio = vcpu_mmio_read,\n\t.read_write_exit_mmio = read_exit_mmio,\n};\n\nstatic const struct read_write_emulator_ops write_emultor = {\n\t.read_write_emulate = write_emulate,\n\t.read_write_mmio = write_mmio,\n\t.read_write_exit_mmio = write_exit_mmio,\n\t.write = true,\n};\n\nstatic int emulator_read_write_onepage(unsigned long addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception,\n\t\t\t\t       struct kvm_vcpu *vcpu,\n\t\t\t\t       const struct read_write_emulator_ops *ops)\n{\n\tgpa_t gpa;\n\tint handled, ret;\n\tbool write = ops->write;\n\tstruct kvm_mmio_fragment *frag;\n\n\tret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);\n\n\tif (ret < 0)\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\t/* For APIC access vmexit */\n\tif (ret)\n\t\tgoto mmio;\n\n\tif (ops->read_write_emulate(vcpu, gpa, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\nmmio:\n\t/*\n\t * Is this MMIO handled locally?\n\t */\n\thandled = ops->read_write_mmio(vcpu, gpa, bytes, val);\n\tif (handled == bytes)\n\t\treturn X86EMUL_CONTINUE;\n\n\tgpa += handled;\n\tbytes -= handled;\n\tval += handled;\n\n\tWARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];\n\tfrag->gpa = gpa;\n\tfrag->data = val;\n\tfrag->len = bytes;\n\treturn X86EMUL_CONTINUE;\n}\n\nint emulator_read_write(struct x86_emulate_ctxt *ctxt, unsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tconst struct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tint rc;\n\n\tif (ops->read_write_prepare &&\n\t\t  ops->read_write_prepare(vcpu, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\tvcpu->mmio_nr_fragments = 0;\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\trc = emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t vcpu, ops);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (!vcpu->mmio_nr_fragments)\n\t\treturn rc;\n\n\tgpa = vcpu->mmio_fragments[0].gpa;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.len = min(8u, vcpu->mmio_fragments[0].len);\n\tvcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\tvcpu->run->mmio.phys_addr = gpa;\n\n\treturn ops->read_write_exit_mmio(vcpu, gpa, val, bytes);\n}\n\nstatic int emulator_read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  unsigned long addr,\n\t\t\t\t  void *val,\n\t\t\t\t  unsigned int bytes,\n\t\t\t\t  struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, val, bytes,\n\t\t\t\t   exception, &read_emultor);\n}\n\nint emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}\n\n#define CMPXCHG_TYPE(t, ptr, old, new) \\\n\t(cmpxchg((t *)(ptr), *(t *)(old), *(t *)(new)) == *(t *)(old))\n\n#ifdef CONFIG_X86_64\n#  define CMPXCHG64(ptr, old, new) CMPXCHG_TYPE(u64, ptr, old, new)\n#else\n#  define CMPXCHG64(ptr, old, new) \\\n\t(cmpxchg64((u64 *)(ptr), *(u64 *)(old), *(u64 *)(new)) == *(u64 *)(old))\n#endif\n\nstatic int emulator_cmpxchg_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     unsigned long addr,\n\t\t\t\t     const void *old,\n\t\t\t\t     const void *new,\n\t\t\t\t     unsigned int bytes,\n\t\t\t\t     struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tstruct page *page;\n\tchar *kaddr;\n\tbool exchanged;\n\n\t/* guests cmpxchg8b have to be emulated atomically */\n\tif (bytes > 8 || (bytes & (bytes - 1)))\n\t\tgoto emul_write;\n\n\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, addr, NULL);\n\n\tif (gpa == UNMAPPED_GVA ||\n\t    (gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\tgoto emul_write;\n\n\tif (((gpa + bytes - 1) & PAGE_MASK) != (gpa & PAGE_MASK))\n\t\tgoto emul_write;\n\n\tpage = gfn_to_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto emul_write;\n\n\tkaddr = kmap_atomic(page);\n\tkaddr += offset_in_page(gpa);\n\tswitch (bytes) {\n\tcase 1:\n\t\texchanged = CMPXCHG_TYPE(u8, kaddr, old, new);\n\t\tbreak;\n\tcase 2:\n\t\texchanged = CMPXCHG_TYPE(u16, kaddr, old, new);\n\t\tbreak;\n\tcase 4:\n\t\texchanged = CMPXCHG_TYPE(u32, kaddr, old, new);\n\t\tbreak;\n\tcase 8:\n\t\texchanged = CMPXCHG64(kaddr, old, new);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tkunmap_atomic(kaddr);\n\tkvm_release_page_dirty(page);\n\n\tif (!exchanged)\n\t\treturn X86EMUL_CMPXCHG_FAILED;\n\n\tkvm_mmu_pte_write(vcpu, gpa, new, bytes);\n\n\treturn X86EMUL_CONTINUE;\n\nemul_write:\n\tprintk_once(KERN_WARNING \"kvm: emulating exchange as write\\n\");\n\n\treturn emulator_write_emulated(ctxt, addr, new, bytes, exception);\n}\n\nstatic int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\t/* TODO: String I/O for in kernel device */\n\tint r;\n\n\tif (vcpu->arch.pio.in)\n\t\tr = kvm_io_bus_read(vcpu->kvm, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t    vcpu->arch.pio.size, pd);\n\telse\n\t\tr = kvm_io_bus_write(vcpu->kvm, KVM_PIO_BUS,\n\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t     pd);\n\treturn r;\n}\n\nstatic int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\ttrace_kvm_pio(!in, port, size, count);\n\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\n\treturn 0;\n}\n\nstatic int emulator_pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    int size, unsigned short port, void *val,\n\t\t\t\t    unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint ret;\n\n\tif (vcpu->arch.pio.count)\n\t\tgoto data_avail;\n\n\tret = emulator_pio_in_out(vcpu, size, port, val, count, true);\n\tif (ret) {\ndata_avail:\n\t\tmemcpy(val, vcpu->arch.pio_data, size * count);\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     int size, unsigned short port,\n\t\t\t\t     const void *val, unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tmemcpy(vcpu->arch.pio_data, val, size * count);\n\treturn emulator_pio_in_out(vcpu, size, port, (void *)val, count, false);\n}\n\nstatic unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}\n\nstatic void emulator_invlpg(struct x86_emulate_ctxt *ctxt, ulong address)\n{\n\tkvm_mmu_invlpg(emul_to_vcpu(ctxt), address);\n}\n\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_wbinvd);\n\nstatic void emulator_wbinvd(struct x86_emulate_ctxt *ctxt)\n{\n\tkvm_emulate_wbinvd(emul_to_vcpu(ctxt));\n}\n\nint emulator_get_dr(struct x86_emulate_ctxt *ctxt, int dr, unsigned long *dest)\n{\n\treturn _kvm_get_dr(emul_to_vcpu(ctxt), dr, dest);\n}\n\nint emulator_set_dr(struct x86_emulate_ctxt *ctxt, int dr, unsigned long value)\n{\n\n\treturn __kvm_set_dr(emul_to_vcpu(ctxt), dr, value);\n}\n\nstatic u64 mk_cr_64(u64 curr_cr, u32 new_val)\n{\n\treturn (curr_cr & ~((1ULL << 32) - 1)) | new_val;\n}\n\nstatic unsigned long emulator_get_cr(struct x86_emulate_ctxt *ctxt, int cr)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long value;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tvalue = kvm_read_cr0(vcpu);\n\t\tbreak;\n\tcase 2:\n\t\tvalue = vcpu->arch.cr2;\n\t\tbreak;\n\tcase 3:\n\t\tvalue = kvm_read_cr3(vcpu);\n\t\tbreak;\n\tcase 4:\n\t\tvalue = kvm_read_cr4(vcpu);\n\t\tbreak;\n\tcase 8:\n\t\tvalue = kvm_get_cr8(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\treturn 0;\n\t}\n\n\treturn value;\n}\n\nstatic int emulator_set_cr(struct x86_emulate_ctxt *ctxt, int cr, ulong val)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint res = 0;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tres = kvm_set_cr0(vcpu, mk_cr_64(kvm_read_cr0(vcpu), val));\n\t\tbreak;\n\tcase 2:\n\t\tvcpu->arch.cr2 = val;\n\t\tbreak;\n\tcase 3:\n\t\tres = kvm_set_cr3(vcpu, val);\n\t\tbreak;\n\tcase 4:\n\t\tres = kvm_set_cr4(vcpu, mk_cr_64(kvm_read_cr4(vcpu), val));\n\t\tbreak;\n\tcase 8:\n\t\tres = kvm_set_cr8(vcpu, val);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\tres = -1;\n\t}\n\n\treturn res;\n}\n\nstatic void emulator_set_rflags(struct x86_emulate_ctxt *ctxt, ulong val)\n{\n\tkvm_set_rflags(emul_to_vcpu(ctxt), val);\n}\n\nstatic int emulator_get_cpl(struct x86_emulate_ctxt *ctxt)\n{\n\treturn kvm_x86_ops->get_cpl(emul_to_vcpu(ctxt));\n}\n\nstatic void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_gdt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_get_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_idt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_set_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_gdt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_set_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_idt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic unsigned long emulator_get_cached_segment_base(\n\tstruct x86_emulate_ctxt *ctxt, int seg)\n{\n\treturn get_segment_base(emul_to_vcpu(ctxt), seg);\n}\n\nstatic bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,\n\t\t\t\t struct desc_struct *desc, u32 *base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_segment var;\n\n\tkvm_get_segment(emul_to_vcpu(ctxt), &var, seg);\n\t*selector = var.selector;\n\n\tif (var.unusable) {\n\t\tmemset(desc, 0, sizeof(*desc));\n\t\treturn false;\n\t}\n\n\tif (var.g)\n\t\tvar.limit >>= 12;\n\tset_desc_limit(desc, var.limit);\n\tset_desc_base(desc, (unsigned long)var.base);\n#ifdef CONFIG_X86_64\n\tif (base3)\n\t\t*base3 = var.base >> 32;\n#endif\n\tdesc->type = var.type;\n\tdesc->s = var.s;\n\tdesc->dpl = var.dpl;\n\tdesc->p = var.present;\n\tdesc->avl = var.avl;\n\tdesc->l = var.l;\n\tdesc->d = var.db;\n\tdesc->g = var.g;\n\n\treturn true;\n}\n\nstatic void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t struct desc_struct *desc, u32 base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tstruct kvm_segment var;\n\n\tvar.selector = selector;\n\tvar.base = get_desc_base(desc);\n#ifdef CONFIG_X86_64\n\tvar.base |= ((u64)base3) << 32;\n#endif\n\tvar.limit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tvar.limit = (var.limit << 12) | 0xfff;\n\tvar.type = desc->type;\n\tvar.present = desc->p;\n\tvar.dpl = desc->dpl;\n\tvar.db = desc->d;\n\tvar.s = desc->s;\n\tvar.l = desc->l;\n\tvar.g = desc->g;\n\tvar.avl = desc->avl;\n\tvar.present = desc->p;\n\tvar.unusable = !var.present;\n\tvar.padding = 0;\n\n\tkvm_set_segment(vcpu, &var, seg);\n\treturn;\n}\n\nstatic int emulator_get_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 *pdata)\n{\n\treturn kvm_get_msr(emul_to_vcpu(ctxt), msr_index, pdata);\n}\n\nstatic int emulator_set_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 data)\n{\n\tstruct msr_data msr;\n\n\tmsr.data = data;\n\tmsr.index = msr_index;\n\tmsr.host_initiated = false;\n\treturn kvm_set_msr(emul_to_vcpu(ctxt), &msr);\n}\n\nstatic int emulator_read_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t     u32 pmc, u64 *pdata)\n{\n\treturn kvm_pmu_read_pmc(emul_to_vcpu(ctxt), pmc, pdata);\n}\n\nstatic void emulator_halt(struct x86_emulate_ctxt *ctxt)\n{\n\temul_to_vcpu(ctxt)->arch.halt_request = 1;\n}\n\nstatic void emulator_get_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_disable();\n\tkvm_load_guest_fpu(emul_to_vcpu(ctxt));\n\t/*\n\t * CR0.TS may reference the host fpu state, not the guest fpu state,\n\t * so it may be clear at this point.\n\t */\n\tclts();\n}\n\nstatic void emulator_put_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_enable();\n}\n\nstatic int emulator_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct x86_instruction_info *info,\n\t\t\t      enum x86_intercept_stage stage)\n{\n\treturn kvm_x86_ops->check_intercept(emul_to_vcpu(ctxt), info, stage);\n}\n\nstatic void emulator_get_cpuid(struct x86_emulate_ctxt *ctxt,\n\t\t\t       u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tkvm_cpuid(emul_to_vcpu(ctxt), eax, ebx, ecx, edx);\n}\n\nstatic ulong emulator_read_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg)\n{\n\treturn kvm_register_read(emul_to_vcpu(ctxt), reg);\n}\n\nstatic void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)\n{\n\tkvm_register_write(emul_to_vcpu(ctxt), reg, val);\n}\n\nstatic const struct x86_emulate_ops emulate_ops = {\n\t.read_gpr            = emulator_read_gpr,\n\t.write_gpr           = emulator_write_gpr,\n\t.read_std            = kvm_read_guest_virt_system,\n\t.write_std           = kvm_write_guest_virt_system,\n\t.fetch               = kvm_fetch_guest_virt,\n\t.read_emulated       = emulator_read_emulated,\n\t.write_emulated      = emulator_write_emulated,\n\t.cmpxchg_emulated    = emulator_cmpxchg_emulated,\n\t.invlpg              = emulator_invlpg,\n\t.pio_in_emulated     = emulator_pio_in_emulated,\n\t.pio_out_emulated    = emulator_pio_out_emulated,\n\t.get_segment         = emulator_get_segment,\n\t.set_segment         = emulator_set_segment,\n\t.get_cached_segment_base = emulator_get_cached_segment_base,\n\t.get_gdt             = emulator_get_gdt,\n\t.get_idt\t     = emulator_get_idt,\n\t.set_gdt             = emulator_set_gdt,\n\t.set_idt\t     = emulator_set_idt,\n\t.get_cr              = emulator_get_cr,\n\t.set_cr              = emulator_set_cr,\n\t.set_rflags          = emulator_set_rflags,\n\t.cpl                 = emulator_get_cpl,\n\t.get_dr              = emulator_get_dr,\n\t.set_dr              = emulator_set_dr,\n\t.set_msr             = emulator_set_msr,\n\t.get_msr             = emulator_get_msr,\n\t.read_pmc            = emulator_read_pmc,\n\t.halt                = emulator_halt,\n\t.wbinvd              = emulator_wbinvd,\n\t.fix_hypercall       = emulator_fix_hypercall,\n\t.get_fpu             = emulator_get_fpu,\n\t.put_fpu             = emulator_put_fpu,\n\t.intercept           = emulator_intercept,\n\t.get_cpuid           = emulator_get_cpuid,\n};\n\nstatic void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)\n{\n\tu32 int_shadow = kvm_x86_ops->get_interrupt_shadow(vcpu, mask);\n\t/*\n\t * an sti; sti; sequence only disable interrupts for the first\n\t * instruction. So, if the last instruction, be it emulated or\n\t * not, left the system with the INT_STI flag enabled, it\n\t * means that the last instruction is an sti. We should not\n\t * leave the flag on in this case. The same goes for mov ss\n\t */\n\tif (!(int_shadow & mask))\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu, mask);\n}\n\nstatic void inject_emulated_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tif (ctxt->exception.vector == PF_VECTOR)\n\t\tkvm_propagate_fault(vcpu, &ctxt->exception);\n\telse if (ctxt->exception.error_code_valid)\n\t\tkvm_queue_exception_e(vcpu, ctxt->exception.vector,\n\t\t\t\t      ctxt->exception.error_code);\n\telse\n\t\tkvm_queue_exception(vcpu, ctxt->exception.vector);\n}\n\nstatic void init_decode_cache(struct x86_emulate_ctxt *ctxt)\n{\n\tmemset(&ctxt->opcode_len, 0,\n\t       (void *)&ctxt->_regs - (void *)&ctxt->opcode_len);\n\n\tctxt->fetch.start = 0;\n\tctxt->fetch.end = 0;\n\tctxt->io_read.pos = 0;\n\tctxt->io_read.end = 0;\n\tctxt->mem_read.pos = 0;\n\tctxt->mem_read.end = 0;\n}\n\nstatic void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     cs_l\t\t\t\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tctxt->guest_mode = is_guest_mode(vcpu);\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}\n\nint kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\n\tctxt->eip = ctxt->_eip;\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = 0;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\n\treturn EMULATE_DONE;\n}\nEXPORT_SYMBOL_GPL(kvm_inject_realmode_interrupt);\n\nstatic int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}\n\nstatic bool reexecute_instruction(struct kvm_vcpu *vcpu, gva_t cr2,\n\t\t\t\t  bool write_fault_to_shadow_pgtable,\n\t\t\t\t  int emulation_type)\n{\n\tgpa_t gpa = cr2;\n\tpfn_t pfn;\n\n\tif (emulation_type & EMULTYPE_NO_REEXECUTE)\n\t\treturn false;\n\n\tif (!vcpu->arch.mmu.direct_map) {\n\t\t/*\n\t\t * Write permission should be allowed since only\n\t\t * write access need to be emulated.\n\t\t */\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\t\t/*\n\t\t * If the mapping is invalid in guest, let cpu retry\n\t\t * it to generate fault.\n\t\t */\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Do not retry the unhandleable instruction if it faults on the\n\t * readonly host memory, otherwise it will goto a infinite loop:\n\t * retry instruction -> write #PF -> emulation fail -> retry\n\t * instruction -> ...\n\t */\n\tpfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the instruction failed on the error pfn, it can not be fixed,\n\t * report the error to userspace.\n\t */\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn false;\n\n\tkvm_release_pfn_clean(pfn);\n\n\t/* The instructions are well-emulated on direct mmu. */\n\tif (vcpu->arch.mmu.direct_map) {\n\t\tunsigned int indirect_shadow_pages;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tindirect_shadow_pages = vcpu->kvm->arch.indirect_shadow_pages;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tif (indirect_shadow_pages)\n\t\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * if emulation was due to access to shadowed page table\n\t * and it failed try to unshadow page and re-enter the\n\t * guest to let CPU execute the instruction.\n\t */\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the access faults on its page table, it can not\n\t * be fixed by unprotecting shadow page and it should\n\t * be reported to userspace.\n\t */\n\treturn !write_fault_to_shadow_pgtable;\n}\n\nstatic bool retry_instruction(struct x86_emulate_ctxt *ctxt,\n\t\t\t      unsigned long cr2,  int emulation_type)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long last_retry_eip, last_retry_addr, gpa = cr2;\n\n\tlast_retry_eip = vcpu->arch.last_retry_eip;\n\tlast_retry_addr = vcpu->arch.last_retry_addr;\n\n\t/*\n\t * If the emulation is caused by #PF and it is non-page_table\n\t * writing instruction, it means the VM-EXIT is caused by shadow\n\t * page protected, we can zap the shadow page and retry this\n\t * instruction directly.\n\t *\n\t * Note: if the guest uses a non-page-table modifying instruction\n\t * on the PDE that points to the instruction, then we will unmap\n\t * the instruction and go to an infinite loop. So, we cache the\n\t * last retried eip and the last fault address, if we meet the eip\n\t * and the address again, we can break out of the potential infinite\n\t * loop.\n\t */\n\tvcpu->arch.last_retry_eip = vcpu->arch.last_retry_addr = 0;\n\n\tif (!(emulation_type & EMULTYPE_RETRY))\n\t\treturn false;\n\n\tif (x86_page_table_writing_insn(ctxt))\n\t\treturn false;\n\n\tif (ctxt->eip == last_retry_eip && last_retry_addr == cr2)\n\t\treturn false;\n\n\tvcpu->arch.last_retry_eip = ctxt->eip;\n\tvcpu->arch.last_retry_addr = cr2;\n\n\tif (!vcpu->arch.mmu.direct_map)\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\treturn true;\n}\n\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,\n\t\t\t\tunsigned long *db)\n{\n\tu32 dr6 = 0;\n\tint i;\n\tu32 enable, rwlen;\n\n\tenable = dr7;\n\trwlen = dr7 >> 16;\n\tfor (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)\n\t\tif ((enable & 3) && (rwlen & 15) == type && db[i] == addr)\n\t\t\tdr6 |= (1 << i);\n\treturn dr6;\n}\n\nstatic void kvm_vcpu_check_singlestep(struct kvm_vcpu *vcpu, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\t/*\n\t * Use the \"raw\" value to see if TF was passed to the processor.\n\t * Note that the new value of the flags has not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tunsigned long rflags = kvm_x86_ops->get_rflags(vcpu);\n\n\tif (unlikely(rflags & X86_EFLAGS_TF)) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP) {\n\t\t\tkvm_run->debug.arch.dr6 = DR6_BS | DR6_FIXED_1;\n\t\t\tkvm_run->debug.arch.pc = vcpu->arch.singlestep_rip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t} else {\n\t\t\tvcpu->arch.emulate_ctxt.eflags &= ~X86_EFLAGS_TF;\n\t\t\t/*\n\t\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t\t * remaining contents of the DR6 register are never\n\t\t\t * cleared by the processor\".\n\t\t\t */\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= DR6_BS;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t}\n\t}\n}\n\nstatic bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tunsigned long eip = vcpu->arch.emulate_ctxt.eip;\n\tu32 dr6 = 0;\n\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;\n\t\t\tkvm_run->debug.arch.pc = kvm_rip_read(vcpu) +\n\t\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\n\t\tif (dr6 != 0) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\t*r = EMULATE_DONE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint x86_emulate_instruction(struct kvm_vcpu *vcpu,\n\t\t\t    unsigned long cr2,\n\t\t\t    int emulation_type,\n\t\t\t    void *insn,\n\t\t\t    int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\tkvm_clear_exception_queue(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tinit_emulate_ctxt(vcpu);\n\n\t\t/*\n\t\t * We will reenter on the same instruction since\n\t\t * we do not set complete_userspace_io.  This does not\n\t\t * handle watchpoints yet, those would be handled in\n\t\t * the emulate_ops.\n\t\t */\n\t\tif (kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tctxt->interruptibility = 0;\n\t\tctxt->have_exception = false;\n\t\tctxt->perm_ok = false;\n\n\t\tctxt->ud = emulation_type & EMULTYPE_TRAP_UD;\n\n\t\tr = x86_decode_insn(ctxt, insn, insn_len);\n\n\t\ttrace_kvm_emulate_insn_start(vcpu);\n\t\t++vcpu->stat.insn_emulation;\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif (emulation_type & EMULTYPE_TRAP_UD)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\t\temulation_type))\n\t\t\t\treturn EMULATE_DONE;\n\t\t\tif (emulation_type & EMULTYPE_SKIP)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\treturn handle_emulation_failure(vcpu);\n\t\t}\n\t}\n\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tkvm_rip_write(vcpu, ctxt->_eip);\n\t\treturn EMULATE_DONE;\n\t}\n\n\tif (retry_instruction(ctxt, cr2, emulation_type))\n\t\treturn EMULATE_DONE;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn EMULATE_DONE;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn EMULATE_DONE;\n\n\t\treturn handle_emulation_failure(vcpu);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tinject_emulated_exception(vcpu);\n\t\tr = EMULATE_DONE;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = EMULATE_USER_EXIT;\n\t} else if (vcpu->mmio_needed) {\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = EMULATE_USER_EXIT;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = EMULATE_DONE;\n\n\tif (writeback) {\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (r == EMULATE_DONE)\n\t\t\tkvm_vcpu_check_singlestep(vcpu, &r);\n\t\tkvm_set_rflags(vcpu, ctxt->eflags);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(x86_emulate_instruction);\n\nint kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size, unsigned short port)\n{\n\tunsigned long val = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tint ret = emulator_pio_out_emulated(&vcpu->arch.emulate_ctxt,\n\t\t\t\t\t    size, port, &val, 1);\n\t/* do not return to emulator after return from userspace */\n\tvcpu->arch.pio.count = 0;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kvm_fast_pio_out);\n\nstatic void tsc_bad(void *info)\n{\n\t__this_cpu_write(cpu_tsc_khz, 0);\n}\n\nstatic void tsc_khz_changed(void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tunsigned long khz = 0;\n\n\tif (data)\n\t\tkhz = freq->new;\n\telse if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tkhz = cpufreq_quick_get(raw_smp_processor_id());\n\tif (!khz)\n\t\tkhz = tsc_khz;\n\t__this_cpu_write(cpu_tsc_khz, khz);\n}\n\nstatic int kvmclock_cpufreq_notifier(struct notifier_block *nb, unsigned long val,\n\t\t\t\t     void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i, send_ipi = 0;\n\n\t/*\n\t * We allow guests to temporarily run on slowing clocks,\n\t * provided we notify them after, or to run on accelerating\n\t * clocks, provided we notify them before.  Thus time never\n\t * goes backwards.\n\t *\n\t * However, we have a problem.  We can't atomically update\n\t * the frequency of a given CPU from this function; it is\n\t * merely a notifier, which can be called from any CPU.\n\t * Changing the TSC frequency at arbitrary points in time\n\t * requires a recomputation of local variables related to\n\t * the TSC for each VCPU.  We must flag these local variables\n\t * to be updated and be sure the update takes place with the\n\t * new frequency before any guests proceed.\n\t *\n\t * Unfortunately, the combination of hotplug CPU and frequency\n\t * change creates an intractable locking scenario; the order\n\t * of when these callouts happen is undefined with respect to\n\t * CPU hotplug, and they can race with each other.  As such,\n\t * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is\n\t * undefined; you can actually have a CPU frequency change take\n\t * place in between the computation of X and the setting of the\n\t * variable.  To protect against this problem, all updates of\n\t * the per_cpu tsc_khz variable are done in an interrupt\n\t * protected IPI, and all callers wishing to update the value\n\t * must wait for a synchronous IPI to complete (which is trivial\n\t * if the caller is on the CPU already).  This establishes the\n\t * necessary total order on variable updates.\n\t *\n\t * Note that because a guest time update may take place\n\t * anytime after the setting of the VCPU's request bit, the\n\t * correct TSC value must be set before the request.  However,\n\t * to ensure the update actually makes it to any guest which\n\t * starts running in hardware virtualization between the set\n\t * and the acquisition of the spinlock, we must also ping the\n\t * CPU after setting the request bit.\n\t *\n\t */\n\n\tif (val == CPUFREQ_PRECHANGE && freq->old > freq->new)\n\t\treturn 0;\n\tif (val == CPUFREQ_POSTCHANGE && freq->old < freq->new)\n\t\treturn 0;\n\n\tsmp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);\n\n\tspin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (vcpu->cpu != freq->cpu)\n\t\t\t\tcontinue;\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (vcpu->cpu != smp_processor_id())\n\t\t\t\tsend_ipi = 1;\n\t\t}\n\t}\n\tspin_unlock(&kvm_lock);\n\n\tif (freq->old < freq->new && send_ipi) {\n\t\t/*\n\t\t * We upscale the frequency.  Must make the guest\n\t\t * doesn't see old kvmclock values while running with\n\t\t * the new frequency, otherwise we risk the guest sees\n\t\t * time go backwards.\n\t\t *\n\t\t * In case we update the frequency for another cpu\n\t\t * (which might be in guest context) send an interrupt\n\t\t * to kick the cpu out of guest context.  Next time\n\t\t * guest context is entered kvmclock will be updated,\n\t\t * so the guest will not see stale values.\n\t\t */\n\t\tsmp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block kvmclock_cpufreq_notifier_block = {\n\t.notifier_call  = kvmclock_cpufreq_notifier\n};\n\nstatic int kvmclock_cpu_notifier(struct notifier_block *nfb,\n\t\t\t\t\tunsigned long action, void *hcpu)\n{\n\tunsigned int cpu = (unsigned long)hcpu;\n\n\tswitch (action) {\n\t\tcase CPU_ONLINE:\n\t\tcase CPU_DOWN_FAILED:\n\t\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n\t\t\tbreak;\n\t\tcase CPU_DOWN_PREPARE:\n\t\t\tsmp_call_function_single(cpu, tsc_bad, NULL, 1);\n\t\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block kvmclock_cpu_notifier_block = {\n\t.notifier_call  = kvmclock_cpu_notifier,\n\t.priority = -INT_MAX\n};\n\nstatic void kvm_timer_init(void)\n{\n\tint cpu;\n\n\tmax_tsc_khz = tsc_khz;\n\tregister_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {\n#ifdef CONFIG_CPU_FREQ\n\t\tstruct cpufreq_policy policy;\n\t\tmemset(&policy, 0, sizeof(policy));\n\t\tcpu = get_cpu();\n\t\tcpufreq_get_policy(&policy, cpu);\n\t\tif (policy.cpuinfo.max_freq)\n\t\t\tmax_tsc_khz = policy.cpuinfo.max_freq;\n\t\tput_cpu();\n#endif\n\t\tcpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t  CPUFREQ_TRANSITION_NOTIFIER);\n\t}\n\tpr_debug(\"kvm: max_tsc_khz = %ld\\n\", max_tsc_khz);\n\tfor_each_online_cpu(cpu)\n\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n}\n\nstatic DEFINE_PER_CPU(struct kvm_vcpu *, current_vcpu);\n\nint kvm_is_in_guest(void)\n{\n\treturn __this_cpu_read(current_vcpu) != NULL;\n}\n\nstatic int kvm_is_user_mode(void)\n{\n\tint user_mode = 3;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tuser_mode = kvm_x86_ops->get_cpl(__this_cpu_read(current_vcpu));\n\n\treturn user_mode != 0;\n}\n\nstatic unsigned long kvm_get_guest_ip(void)\n{\n\tunsigned long ip = 0;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tip = kvm_rip_read(__this_cpu_read(current_vcpu));\n\n\treturn ip;\n}\n\nstatic struct perf_guest_info_callbacks kvm_guest_cbs = {\n\t.is_in_guest\t\t= kvm_is_in_guest,\n\t.is_user_mode\t\t= kvm_is_user_mode,\n\t.get_guest_ip\t\t= kvm_get_guest_ip,\n};\n\nvoid kvm_before_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_before_handle_nmi);\n\nvoid kvm_after_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}\nEXPORT_SYMBOL_GPL(kvm_after_handle_nmi);\n\nstatic void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\tint maxphyaddr = boot_cpu_data.x86_phys_bits;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\t /* Mask the reserved physical address bits. */\n\tmask = ((1ull << (51 - maxphyaddr + 1)) - 1) << maxphyaddr;\n\n\t/* Bit 62 is always reserved for 32bit host. */\n\tmask |= 0x3ull << 62;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (maxphyaddr == 52)\n\t\tmask &= ~1ull;\n#endif\n\n\tkvm_mmu_set_mmio_spte_mask(mask);\n}\n\n#ifdef CONFIG_X86_64\nstatic void pvclock_gtod_update_fn(struct work_struct *work)\n{\n\tstruct kvm *kvm;\n\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tspin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE, &vcpu->requests);\n\tatomic_set(&kvm_guest_has_master_clock, 0);\n\tspin_unlock(&kvm_lock);\n}\n\nstatic DECLARE_WORK(pvclock_gtod_work, pvclock_gtod_update_fn);\n\n/*\n * Notification about pvclock gtod data update.\n */\nstatic int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,\n\t\t\t       void *priv)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tstruct timekeeper *tk = priv;\n\n\tupdate_pvclock_gtod(tk);\n\n\t/* disable master clock if host does not trust, or does not\n\t * use, TSC clocksource\n\t */\n\tif (gtod->clock.vclock_mode != VCLOCK_TSC &&\n\t    atomic_read(&kvm_guest_has_master_clock) != 0)\n\t\tqueue_work(system_long_wq, &pvclock_gtod_work);\n\n\treturn 0;\n}\n\nstatic struct notifier_block pvclock_gtod_notifier = {\n\t.notifier_call = pvclock_gtod_notify,\n};\n#endif\n\nint kvm_arch_init(void *opaque)\n{\n\tint r;\n\tstruct kvm_x86_ops *ops = opaque;\n\n\tif (kvm_x86_ops) {\n\t\tprintk(KERN_ERR \"kvm: already loaded the other module\\n\");\n\t\tr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (!ops->cpu_has_kvm_support()) {\n\t\tprintk(KERN_ERR \"kvm: no hardware support\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (ops->disabled_by_bios()) {\n\t\tprintk(KERN_ERR \"kvm: disabled by bios\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tr = -ENOMEM;\n\tshared_msrs = alloc_percpu(struct kvm_shared_msrs);\n\tif (!shared_msrs) {\n\t\tprintk(KERN_ERR \"kvm: failed to allocate percpu kvm_shared_msrs\\n\");\n\t\tgoto out;\n\t}\n\n\tr = kvm_mmu_module_init();\n\tif (r)\n\t\tgoto out_free_percpu;\n\n\tkvm_set_mmio_spte_mask();\n\tkvm_init_msr_list();\n\n\tkvm_x86_ops = ops;\n\tkvm_mmu_set_mask_ptes(PT_USER_MASK, PT_ACCESSED_MASK,\n\t\t\tPT_DIRTY_MASK, PT64_NX_MASK, 0);\n\n\tkvm_timer_init();\n\n\tperf_register_guest_info_callbacks(&kvm_guest_cbs);\n\n\tif (cpu_has_xsave)\n\t\thost_xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);\n\n\tkvm_lapic_init();\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_register_notifier(&pvclock_gtod_notifier);\n#endif\n\n\treturn 0;\n\nout_free_percpu:\n\tfree_percpu(shared_msrs);\nout:\n\treturn r;\n}\n\nvoid kvm_arch_exit(void)\n{\n\tperf_unregister_guest_info_callbacks(&kvm_guest_cbs);\n\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tcpufreq_unregister_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n\tunregister_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_unregister_notifier(&pvclock_gtod_notifier);\n#endif\n\tkvm_x86_ops = NULL;\n\tkvm_mmu_module_exit();\n\tfree_percpu(shared_msrs);\n}\n\nint kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.halt_exits;\n\tif (irqchip_in_kernel(vcpu->kvm)) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = KVM_EXIT_HLT;\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_halt);\n\nint kvm_hv_hypercall(struct kvm_vcpu *vcpu)\n{\n\tu64 param, ingpa, outgpa, ret;\n\tuint16_t code, rep_idx, rep_cnt, res = HV_STATUS_SUCCESS, rep_done = 0;\n\tbool fast, longmode;\n\tint cs_db, cs_l;\n\n\t/*\n\t * hypercall generates UD from non zero cpl and real mode\n\t * per HYPER-V spec\n\t */\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 || !is_protmode(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\tlongmode = is_long_mode(vcpu) && cs_l == 1;\n\n\tif (!longmode) {\n\t\tparam = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RAX) & 0xffffffff);\n\t\tingpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RBX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RCX) & 0xffffffff);\n\t\toutgpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDI) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RSI) & 0xffffffff);\n\t}\n#ifdef CONFIG_X86_64\n\telse {\n\t\tparam = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\t\tingpa = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\t\toutgpa = kvm_register_read(vcpu, VCPU_REGS_R8);\n\t}\n#endif\n\n\tcode = param & 0xffff;\n\tfast = (param >> 16) & 0x1;\n\trep_cnt = (param >> 32) & 0xfff;\n\trep_idx = (param >> 48) & 0xfff;\n\n\ttrace_kvm_hv_hypercall(code, fast, rep_cnt, rep_idx, ingpa, outgpa);\n\n\tswitch (code) {\n\tcase HV_X64_HV_NOTIFY_LONG_SPIN_WAIT:\n\t\tkvm_vcpu_on_spin(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tbreak;\n\t}\n\n\tret = res | (((u64)rep_done & 0xfff) << 32);\n\tif (longmode) {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t} else {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RDX, ret >> 32);\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret & 0xffffffff);\n\t}\n\n\treturn 1;\n}\n\n/*\n * kvm_pv_kick_cpu_op:  Kick a vcpu.\n *\n * @apicid - apicid of vcpu to be kicked.\n */\nstatic void kvm_pv_kick_cpu_op(struct kvm *kvm, unsigned long flags, int apicid)\n{\n\tstruct kvm_lapic_irq lapic_irq;\n\n\tlapic_irq.shorthand = 0;\n\tlapic_irq.dest_mode = 0;\n\tlapic_irq.dest_id = apicid;\n\n\tlapic_irq.delivery_mode = APIC_DM_REMRD;\n\tkvm_irq_delivery_to_apic(kvm, 0, &lapic_irq, NULL);\n}\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint r = 1;\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\tif (!is_long_mode(vcpu)) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_hypercall);\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tchar instruction[3];\n\tunsigned long rip = kvm_rip_read(vcpu);\n\n\tkvm_x86_ops->patch_hypercall(vcpu, instruction);\n\n\treturn emulator_write_emulated(ctxt, rip, instruction, 3, NULL);\n}\n\n/*\n * Check if userspace requested an interrupt window, and that the\n * interrupt window is open.\n *\n * No need to exit to userspace if we already have an interrupt queued.\n */\nstatic int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn (!irqchip_in_kernel(vcpu->kvm) && !kvm_cpu_has_interrupt(vcpu) &&\n\t\tvcpu->run->request_interrupt_window &&\n\t\tkvm_arch_interrupt_allowed(vcpu));\n}\n\nstatic void post_kvm_run_save(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->if_flag = (kvm_get_rflags(vcpu) & X86_EFLAGS_IF) != 0;\n\tkvm_run->cr8 = kvm_get_cr8(vcpu);\n\tkvm_run->apic_base = kvm_get_apic_base(vcpu);\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_run->ready_for_interrupt_injection = 1;\n\telse\n\t\tkvm_run->ready_for_interrupt_injection =\n\t\t\tkvm_arch_interrupt_allowed(vcpu) &&\n\t\t\t!kvm_cpu_has_interrupt(vcpu) &&\n\t\t\t!kvm_event_needs_reinjection(vcpu);\n}\n\nstatic int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}\n\nstatic void vapic_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint idx;\n\n\tif (!apic || !apic->vapic_addr)\n\t\treturn;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_release_page_dirty(apic->vapic_page);\n\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n}\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}\n\nstatic void inject_pending_event(struct kvm_vcpu *vcpu)\n{\n\t/* try to reinject previous events if any */\n\tif (vcpu->arch.exception.pending) {\n\t\ttrace_kvm_inj_exception(vcpu->arch.exception.nr,\n\t\t\t\t\tvcpu->arch.exception.has_error_code,\n\t\t\t\t\tvcpu->arch.exception.error_code);\n\t\tkvm_x86_ops->queue_exception(vcpu, vcpu->arch.exception.nr,\n\t\t\t\t\t  vcpu->arch.exception.has_error_code,\n\t\t\t\t\t  vcpu->arch.exception.error_code,\n\t\t\t\t\t  vcpu->arch.exception.reinject);\n\t\treturn;\n\t}\n\n\tif (vcpu->arch.nmi_injected) {\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\treturn;\n\t}\n\n\tif (vcpu->arch.interrupt.pending) {\n\t\tkvm_x86_ops->set_irq(vcpu);\n\t\treturn;\n\t}\n\n\t/* try to inject new event if pending */\n\tif (vcpu->arch.nmi_pending) {\n\t\tif (kvm_x86_ops->nmi_allowed(vcpu)) {\n\t\t\t--vcpu->arch.nmi_pending;\n\t\t\tvcpu->arch.nmi_injected = true;\n\t\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\t}\n\t} else if (kvm_cpu_has_injectable_intr(vcpu)) {\n\t\tif (kvm_x86_ops->interrupt_allowed(vcpu)) {\n\t\t\tkvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu),\n\t\t\t\t\t    false);\n\t\t\tkvm_x86_ops->set_irq(vcpu);\n\t\t}\n\t}\n}\n\nstatic void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\n\nstatic void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tu64 eoi_exit_bitmap[4];\n\tu32 tmr[8];\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tmemset(eoi_exit_bitmap, 0, 32);\n\tmemset(tmr, 0, 32);\n\n\tkvm_ioapic_scan_entry(vcpu, eoi_exit_bitmap, tmr);\n\tkvm_x86_ops->load_eoi_exitmap(vcpu, eoi_exit_bitmap);\n\tkvm_apic_update_tmr(vcpu, tmr);\n}\n\nstatic int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win = !irqchip_in_kernel(vcpu->kvm) &&\n\t\tvcpu->run->request_interrupt_window;\n\tbool req_immediate_exit = false;\n\n\tif (vcpu->requests) {\n\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))\n\t\t\tkvm_mmu_unload(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu))\n\t\t\tkvm_x86_ops->tlb_flush(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_DEACTIVATE_FPU, vcpu)) {\n\t\t\tvcpu->fpu_active = 0;\n\t\t\tkvm_x86_ops->fpu_deactivate(vcpu);\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_handle_pmu_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {\n\t\tkvm_apic_accept_events(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinject_pending_event(vcpu);\n\n\t\t/* enable NMI/IRQ window open exits if needed */\n\t\tif (vcpu->arch.nmi_pending)\n\t\t\treq_immediate_exit =\n\t\t\t\tkvm_x86_ops->enable_nmi_window(vcpu) != 0;\n\t\telse if (kvm_cpu_has_injectable_intr(vcpu) || req_int_win)\n\t\t\treq_immediate_exit =\n\t\t\t\tkvm_x86_ops->enable_irq_window(vcpu) != 0;\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\t/*\n\t\t\t * Update architecture specific hints for APIC\n\t\t\t * virtual interrupt delivery.\n\t\t\t */\n\t\t\tif (kvm_x86_ops->hwapic_irr_update)\n\t\t\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\t\tkvm_lapic_find_highest_irr(vcpu));\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tkvm_load_guest_xcr0(vcpu);\n\n\tvcpu->mode = IN_GUEST_MODE;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\n\t/* We should set ->mode before check ->requests,\n\t * see the comment in make_all_cpus_request.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\tlocal_irq_disable();\n\n\tif (vcpu->mode == EXITING_GUEST_MODE || vcpu->requests\n\t    || need_resched() || signal_pending(current)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tif (req_immediate_exit)\n\t\tsmp_send_reschedule(vcpu->cpu);\n\n\tkvm_guest_enter();\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t}\n\n\ttrace_kvm_entry(vcpu->vcpu_id);\n\tkvm_x86_ops->run(vcpu);\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_guest_tsc = kvm_x86_ops->read_l1_tsc(vcpu,\n\t\t\t\t\t\t\t   native_read_tsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\t/* Interrupt is enabled by handle_external_intr() */\n\tkvm_x86_ops->handle_external_intr(vcpu);\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t * We must have an instruction between local_irq_enable() and\n\t * kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t * the interrupt shadow.  The stat.exits increment will do nicely.\n\t * But we need to prevent reordering, hence this barrier():\n\t */\n\tbarrier();\n\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = kvm_x86_ops->handle_exit(vcpu);\n\treturn r;\n\ncancel_injection:\n\tkvm_x86_ops->cancel_injection(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}\n\n\nstatic int __vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\tr = vapic_enter(vcpu);\n\tif (r) {\n\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\treturn r;\n\t}\n\n\tr = 1;\n\twhile (r > 0) {\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t    !vcpu->arch.apf.halted)\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\telse {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_vcpu_block(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t\tif (kvm_check_request(KVM_REQ_UNHALT, vcpu)) {\n\t\t\t\tkvm_apic_accept_events(vcpu);\n\t\t\t\tswitch(vcpu->arch.mp_state) {\n\t\t\t\tcase KVM_MP_STATE_HALTED:\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\t\t\t\tvcpu->arch.mp_state =\n\t\t\t\t\t\tKVM_MP_STATE_RUNNABLE;\n\t\t\t\tcase KVM_MP_STATE_RUNNABLE:\n\t\t\t\t\tvcpu->arch.apf.halted = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tr = -EINTR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (r <= 0)\n\t\t\tbreak;\n\n\t\tclear_bit(KVM_REQ_PENDING_TIMER, &vcpu->requests);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\n\t\tif (dm_request_for_irq_injection(vcpu)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t}\n\n\t\tkvm_check_async_pf_completion(vcpu);\n\n\t\tif (signal_pending(current)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.signal_exits;\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_resched(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t}\n\t}\n\n\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\n\tvapic_exit(vcpu);\n\n\treturn r;\n}\n\nstatic inline int complete_emulated_io(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\tr = emulate_instruction(vcpu, EMULTYPE_NO_DECODE);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (r != EMULATE_DONE)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu)\n{\n\tBUG_ON(!vcpu->arch.pio.count);\n\n\treturn complete_emulated_io(vcpu);\n}\n\n/*\n * Implements the following, as a state machine:\n *\n * read:\n *   for each fragment\n *     for each mmio piece in the fragment\n *       write gpa, len\n *       exit\n *       copy data\n *   execute insn\n *\n * write:\n *   for each fragment\n *     for each mmio piece in the fragment\n *       write gpa, len\n *       copy data\n *       exit\n */\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}\n\n\nint kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\n{\n\tint r;\n\tsigset_t sigsaved;\n\n\tif (!tsk_used_math(current) && init_fpu(current))\n\t\treturn -ENOMEM;\n\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\n\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {\n\t\tkvm_vcpu_block(vcpu);\n\t\tkvm_apic_accept_events(vcpu);\n\t\tclear_bit(KVM_REQ_UNHALT, &vcpu->requests);\n\t\tr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\t/* re-sync apic's tpr */\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tif (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.complete_userspace_io)) {\n\t\tint (*cui)(struct kvm_vcpu *) = vcpu->arch.complete_userspace_io;\n\t\tvcpu->arch.complete_userspace_io = NULL;\n\t\tr = cui(vcpu);\n\t\tif (r <= 0)\n\t\t\tgoto out;\n\t} else\n\t\tWARN_ON(vcpu->arch.pio.count || vcpu->mmio_needed);\n\n\tr = __vcpu_run(vcpu);\n\nout:\n\tpost_kvm_run_save(vcpu);\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn r;\n}\n\nint kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tif (vcpu->arch.emulate_regs_need_sync_to_vcpu) {\n\t\t/*\n\t\t * We are here if userspace calls get_regs() in the middle of\n\t\t * instruction emulation. Registers state needs to be copied\n\t\t * back from emulation context to vcpu. Userspace shouldn't do\n\t\t * that usually, but some bad designed PV devices (vmware\n\t\t * backdoor interface) need this to work\n\t\t */\n\t\temulator_writeback_register_cache(&vcpu->arch.emulate_ctxt);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t}\n\tregs->rax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tregs->rbx = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\tregs->rcx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tregs->rdx = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\tregs->rsi = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\tregs->rdi = kvm_register_read(vcpu, VCPU_REGS_RDI);\n\tregs->rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tregs->rbp = kvm_register_read(vcpu, VCPU_REGS_RBP);\n#ifdef CONFIG_X86_64\n\tregs->r8 = kvm_register_read(vcpu, VCPU_REGS_R8);\n\tregs->r9 = kvm_register_read(vcpu, VCPU_REGS_R9);\n\tregs->r10 = kvm_register_read(vcpu, VCPU_REGS_R10);\n\tregs->r11 = kvm_register_read(vcpu, VCPU_REGS_R11);\n\tregs->r12 = kvm_register_read(vcpu, VCPU_REGS_R12);\n\tregs->r13 = kvm_register_read(vcpu, VCPU_REGS_R13);\n\tregs->r14 = kvm_register_read(vcpu, VCPU_REGS_R14);\n\tregs->r15 = kvm_register_read(vcpu, VCPU_REGS_R15);\n#endif\n\n\tregs->rip = kvm_rip_read(vcpu);\n\tregs->rflags = kvm_get_rflags(vcpu);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = true;\n\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, regs->rax);\n\tkvm_register_write(vcpu, VCPU_REGS_RBX, regs->rbx);\n\tkvm_register_write(vcpu, VCPU_REGS_RCX, regs->rcx);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, regs->rdx);\n\tkvm_register_write(vcpu, VCPU_REGS_RSI, regs->rsi);\n\tkvm_register_write(vcpu, VCPU_REGS_RDI, regs->rdi);\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, regs->rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RBP, regs->rbp);\n#ifdef CONFIG_X86_64\n\tkvm_register_write(vcpu, VCPU_REGS_R8, regs->r8);\n\tkvm_register_write(vcpu, VCPU_REGS_R9, regs->r9);\n\tkvm_register_write(vcpu, VCPU_REGS_R10, regs->r10);\n\tkvm_register_write(vcpu, VCPU_REGS_R11, regs->r11);\n\tkvm_register_write(vcpu, VCPU_REGS_R12, regs->r12);\n\tkvm_register_write(vcpu, VCPU_REGS_R13, regs->r13);\n\tkvm_register_write(vcpu, VCPU_REGS_R14, regs->r14);\n\tkvm_register_write(vcpu, VCPU_REGS_R15, regs->r15);\n#endif\n\n\tkvm_rip_write(vcpu, regs->rip);\n\tkvm_set_rflags(vcpu, regs->rflags);\n\n\tvcpu->arch.exception.pending = false;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nvoid kvm_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\t*db = cs.db;\n\t*l = cs.l;\n}\nEXPORT_SYMBOL_GPL(kvm_get_cs_db_l_bits);\n\nint kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tstruct desc_ptr dt;\n\n\tkvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_get_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_get_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_get_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_get_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_get_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_get_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_get_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tsregs->idt.limit = dt.size;\n\tsregs->idt.base = dt.address;\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tsregs->gdt.limit = dt.size;\n\tsregs->gdt.base = dt.address;\n\n\tsregs->cr0 = kvm_read_cr0(vcpu);\n\tsregs->cr2 = vcpu->arch.cr2;\n\tsregs->cr3 = kvm_read_cr3(vcpu);\n\tsregs->cr4 = kvm_read_cr4(vcpu);\n\tsregs->cr8 = kvm_get_cr8(vcpu);\n\tsregs->efer = vcpu->arch.efer;\n\tsregs->apic_base = kvm_get_apic_base(vcpu);\n\n\tmemset(sregs->interrupt_bitmap, 0, sizeof sregs->interrupt_bitmap);\n\n\tif (vcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft)\n\t\tset_bit(vcpu->arch.interrupt.nr,\n\t\t\t(unsigned long *)sregs->interrupt_bitmap);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tkvm_apic_accept_events(vcpu);\n\tif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED &&\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted)\n\t\tmp_state->mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tmp_state->mp_state = vcpu->arch.mp_state;\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tif (!kvm_vcpu_has_lapic(vcpu) &&\n\t    mp_state->mp_state != KVM_MP_STATE_RUNNABLE)\n\t\treturn -EINVAL;\n\n\tif (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t\tset_bit(KVM_APIC_SIPI, &vcpu->arch.apic->pending_events);\n\t} else\n\t\tvcpu->arch.mp_state = mp_state->mp_state;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 0;\n}\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\n\tif (ret)\n\t\treturn EMULATE_FAIL;\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn EMULATE_DONE;\n}\nEXPORT_SYMBOL_GPL(kvm_task_switch);\n\nint kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tint mmu_reset_needed = 0;\n\tint pending_vec, max_bits, idx;\n\tstruct desc_ptr dt;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (sregs->cr4 & X86_CR4_OSXSAVE))\n\t\treturn -EINVAL;\n\n\tdt.size = sregs->idt.limit;\n\tdt.address = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.size = sregs->gdt.limit;\n\tdt.address = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tkvm_set_apic_base(vcpu, sregs->apic_base);\n\n\tmmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (sregs->cr4 & X86_CR4_OSXSAVE)\n\t\tkvm_update_cpuid(vcpu);\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu)) {\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tmmu_reset_needed = 1;\n\t}\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tmax_bits = KVM_NR_INTERRUPTS;\n\tpending_vec = find_first_bit(\n\t\t(const unsigned long *)sregs->interrupt_bitmap, max_bits);\n\tif (pending_vec < max_bits) {\n\t\tkvm_queue_interrupt(vcpu, pending_vec, false);\n\t\tpr_debug(\"Set back pending irq %d\\n\", pending_vec);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tupdate_cr8_intercept(vcpu);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !is_protmode(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_guest_debug *dbg)\n{\n\tunsigned long rflags;\n\tint i, r;\n\n\tif (dbg->control & (KVM_GUESTDBG_INJECT_DB | KVM_GUESTDBG_INJECT_BP)) {\n\t\tr = -EBUSY;\n\t\tif (vcpu->arch.exception.pending)\n\t\t\tgoto out;\n\t\tif (dbg->control & KVM_GUESTDBG_INJECT_DB)\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\telse\n\t\t\tkvm_queue_exception(vcpu, BP_VECTOR);\n\t}\n\n\t/*\n\t * Read rflags as long as potentially injected trace flags are still\n\t * filtered out.\n\t */\n\trflags = kvm_get_rflags(vcpu);\n\n\tvcpu->guest_debug = dbg->control;\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_ENABLE))\n\t\tvcpu->guest_debug = 0;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; ++i)\n\t\t\tvcpu->arch.eff_db[i] = dbg->arch.debugreg[i];\n\t\tvcpu->arch.guest_debug_dr7 = dbg->arch.debugreg[7];\n\t} else {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\tkvm_update_dr7(vcpu);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvcpu->arch.singlestep_rip = kvm_rip_read(vcpu) +\n\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\t/*\n\t * Trigger an rflags update that will inject or remove the trace\n\t * flags.\n\t */\n\tkvm_set_rflags(vcpu, rflags);\n\n\tkvm_x86_ops->update_db_bp_intercept(vcpu);\n\n\tr = 0;\n\nout:\n\n\treturn r;\n}\n\n/*\n * Translate a guest virtual address to a guest physical address.\n */\nint kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_translation *tr)\n{\n\tunsigned long vaddr = tr->linear_address;\n\tgpa_t gpa;\n\tint idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tgpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\ttr->physical_address = gpa;\n\ttr->valid = gpa != UNMAPPED_GVA;\n\ttr->writeable = 1;\n\ttr->usermode = 0;\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct i387_fxsave_struct *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave;\n\n\tmemcpy(fpu->fpr, fxsave->st_space, 128);\n\tfpu->fcw = fxsave->cwd;\n\tfpu->fsw = fxsave->swd;\n\tfpu->ftwx = fxsave->twd;\n\tfpu->last_opcode = fxsave->fop;\n\tfpu->last_ip = fxsave->rip;\n\tfpu->last_dp = fxsave->rdp;\n\tmemcpy(fpu->xmm, fxsave->xmm_space, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct i387_fxsave_struct *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave;\n\n\tmemcpy(fxsave->st_space, fpu->fpr, 128);\n\tfxsave->cwd = fpu->fcw;\n\tfxsave->swd = fpu->fsw;\n\tfxsave->twd = fpu->ftwx;\n\tfxsave->fop = fpu->last_opcode;\n\tfxsave->rip = fpu->last_ip;\n\tfxsave->rdp = fpu->last_dp;\n\tmemcpy(fxsave->xmm_space, fpu->xmm, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}\n\nint fx_init(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\n\terr = fpu_alloc(&vcpu->arch.guest_fpu);\n\tif (err)\n\t\treturn err;\n\n\tfpu_finit(&vcpu->arch.guest_fpu);\n\n\t/*\n\t * Ensure guest xcr0 is valid for loading\n\t */\n\tvcpu->arch.xcr0 = XSTATE_FP;\n\n\tvcpu->arch.cr0 |= X86_CR0_ET;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fx_init);\n\nstatic void fx_free(struct kvm_vcpu *vcpu)\n{\n\tfpu_free(&vcpu->arch.guest_fpu);\n}\n\nvoid kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\t/*\n\t * Restore all possible states in the guest,\n\t * and assume host would use all available bits.\n\t * Guest xcr0 would be loaded later.\n\t */\n\tkvm_put_guest_xcr0(vcpu);\n\tvcpu->guest_fpu_loaded = 1;\n\t__kernel_fpu_begin();\n\tfpu_restore_checking(&vcpu->arch.guest_fpu);\n\ttrace_kvm_fpu(1);\n}\n\nvoid kvm_put_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tkvm_put_guest_xcr0(vcpu);\n\n\tif (!vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\tvcpu->guest_fpu_loaded = 0;\n\tfpu_save_init(&vcpu->arch.guest_fpu);\n\t__kernel_fpu_end();\n\t++vcpu->stat.fpu_reload;\n\tkvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);\n\ttrace_kvm_fpu(0);\n}\n\nvoid kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tkvmclock_reset(vcpu);\n\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\n\tfx_free(vcpu);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}\n\nstruct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,\n\t\t\t\t\t\tunsigned int id)\n{\n\tif (check_tsc_unstable() && atomic_read(&kvm->online_vcpus) != 0)\n\t\tprintk_once(KERN_WARNING\n\t\t\"kvm: SMP vm created on host with unstable TSC; \"\n\t\t\"guest TSC will not be reliable\\n\");\n\treturn kvm_x86_ops->vcpu_create(kvm, id);\n}\n\nint kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tvcpu->arch.mtrr_state.have_fixed = 1;\n\tr = vcpu_load(vcpu);\n\tif (r)\n\t\treturn r;\n\tkvm_vcpu_reset(vcpu);\n\tkvm_mmu_setup(vcpu);\n\tvcpu_put(vcpu);\n\n\treturn r;\n}\n\nint kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct msr_data msr;\n\n\tr = vcpu_load(vcpu);\n\tif (r)\n\t\treturn r;\n\tmsr.data = 0x0;\n\tmsr.index = MSR_IA32_TSC;\n\tmsr.host_initiated = true;\n\tkvm_write_tsc(vcpu, &msr);\n\tvcpu_put(vcpu);\n\n\treturn r;\n}\n\nvoid kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->arch.apf.msr_val = 0;\n\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n\n\tfx_free(vcpu);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}\n\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tvcpu->arch.dr6 = DR6_FIXED_1;\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tkvm_pmu_reset(vcpu);\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tkvm_x86_ops->vcpu_reset(vcpu);\n}\n\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, unsigned int vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}\n\nint kvm_arch_hardware_enable(void *garbage)\n{\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tint ret;\n\tu64 local_tsc;\n\tu64 max_tsc = 0;\n\tbool stable, backwards_tsc = false;\n\n\tkvm_shared_msr_cpu_online();\n\tret = kvm_x86_ops->hardware_enable(garbage);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tlocal_tsc = native_read_tsc();\n\tstable = !check_tsc_unstable();\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!stable && vcpu->cpu == smp_processor_id())\n\t\t\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t\t\tif (stable && vcpu->arch.last_host_tsc > local_tsc) {\n\t\t\t\tbackwards_tsc = true;\n\t\t\t\tif (vcpu->arch.last_host_tsc > max_tsc)\n\t\t\t\t\tmax_tsc = vcpu->arch.last_host_tsc;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Sometimes, even reliable TSCs go backwards.  This happens on\n\t * platforms that reset TSC during suspend or hibernate actions, but\n\t * maintain synchronization.  We must compensate.  Fortunately, we can\n\t * detect that condition here, which happens early in CPU bringup,\n\t * before any KVM threads can be running.  Unfortunately, we can't\n\t * bring the TSCs fully up to date with real time, as we aren't yet far\n\t * enough into CPU bringup that we know how much real time has actually\n\t * elapsed; our helper function, get_kernel_ns() will be using boot\n\t * variables that haven't been updated yet.\n\t *\n\t * So we simply find the maximum observed TSC above, then record the\n\t * adjustment to TSC in each VCPU.  When the VCPU later gets loaded,\n\t * the adjustment will be applied.  Note that we accumulate\n\t * adjustments, in case multiple suspend cycles happen before some VCPU\n\t * gets a chance to run again.  In the event that no KVM threads get a\n\t * chance to run, we will miss the entire elapsed period, as we'll have\n\t * reset last_host_tsc, so VCPUs will not have the TSC adjusted and may\n\t * loose cycle time.  This isn't too big a deal, since the loss will be\n\t * uniform across all VCPUs (not to mention the scenario is extremely\n\t * unlikely). It is possible that a second hibernate recovery happens\n\t * much faster than a first, causing the observed TSC here to be\n\t * smaller; this would require additional padding adjustment, which is\n\t * why we set last_host_tsc to the local tsc observed here.\n\t *\n\t * N.B. - this code below runs only on platforms with reliable TSC,\n\t * as that is the only way backwards_tsc is set above.  Also note\n\t * that this runs for ALL vcpus, which is not a bug; all VCPUs should\n\t * have the same delta_cyc adjustment applied if backwards_tsc\n\t * is detected.  Note further, this adjustment is only done once,\n\t * as we reset last_host_tsc on all VCPUs to stop this from being\n\t * called multiple times (one for each physical CPU bringup).\n\t *\n\t * Platforms with unreliable TSCs don't have to deal with this, they\n\t * will be compensated by the logic in vcpu_load, which sets the TSC to\n\t * catchup mode.  This will catchup all VCPUs to real time, but cannot\n\t * guarantee that they stay in perfect synchronization.\n\t */\n\tif (backwards_tsc) {\n\t\tu64 delta_cyc = max_tsc - local_tsc;\n\t\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\t\tvcpu->arch.tsc_offset_adjustment += delta_cyc;\n\t\t\t\tvcpu->arch.last_host_tsc = local_tsc;\n\t\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE,\n\t\t\t\t\t&vcpu->requests);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have to disable TSC offset matching.. if you were\n\t\t\t * booting a VM while issuing an S4 host suspend....\n\t\t\t * you may have some problem.  Solving this issue is\n\t\t\t * left as an exercise to the reader.\n\t\t\t */\n\t\t\tkvm->arch.last_tsc_nsec = 0;\n\t\t\tkvm->arch.last_tsc_write = 0;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\nvoid kvm_arch_hardware_disable(void *garbage)\n{\n\tkvm_x86_ops->hardware_disable(garbage);\n\tdrop_user_return_notifiers(garbage);\n}\n\nint kvm_arch_hardware_setup(void)\n{\n\treturn kvm_x86_ops->hardware_setup();\n}\n\nvoid kvm_arch_hardware_unsetup(void)\n{\n\tkvm_x86_ops->hardware_unsetup();\n}\n\nvoid kvm_arch_check_processor_compat(void *rtn)\n{\n\tkvm_x86_ops->check_processor_compatibility(rtn);\n}\n\nbool kvm_vcpu_compatible(struct kvm_vcpu *vcpu)\n{\n\treturn irqchip_in_kernel(vcpu->kvm) == (vcpu->arch.apic != NULL);\n}\n\nstruct static_key kvm_no_apic_vcpu __read_mostly;\n\nint kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tstruct kvm *kvm;\n\tint r;\n\n\tBUG_ON(vcpu->kvm == NULL);\n\tkvm = vcpu->kvm;\n\n\tvcpu->arch.pv.pv_unhalted = false;\n\tvcpu->arch.emulate_ctxt.ops = &emulate_ops;\n\tif (!irqchip_in_kernel(kvm) || kvm_vcpu_is_bsp(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page) {\n\t\tr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tvcpu->arch.pio_data = page_address(page);\n\n\tkvm_set_tsc_khz(vcpu, max_tsc_khz);\n\n\tr = kvm_mmu_create(vcpu);\n\tif (r < 0)\n\t\tgoto fail_free_pio_data;\n\n\tif (irqchip_in_kernel(kvm)) {\n\t\tr = kvm_create_lapic(vcpu);\n\t\tif (r < 0)\n\t\t\tgoto fail_mmu_destroy;\n\t} else\n\t\tstatic_key_slow_inc(&kvm_no_apic_vcpu);\n\n\tvcpu->arch.mce_banks = kzalloc(KVM_MAX_MCE_BANKS * sizeof(u64) * 4,\n\t\t\t\t       GFP_KERNEL);\n\tif (!vcpu->arch.mce_banks) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_lapic;\n\t}\n\tvcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;\n\n\tif (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask, GFP_KERNEL)) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_mce_banks;\n\t}\n\n\tr = fx_init(vcpu);\n\tif (r)\n\t\tgoto fail_free_wbinvd_dirty_mask;\n\n\tvcpu->arch.ia32_tsc_adjust_msr = 0x0;\n\tvcpu->arch.pv_time_enabled = false;\n\n\tvcpu->arch.guest_supported_xcr0 = 0;\n\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\tkvm_async_pf_hash_reset(vcpu);\n\tkvm_pmu_init(vcpu);\n\n\treturn 0;\nfail_free_wbinvd_dirty_mask:\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\nfail_free_mce_banks:\n\tkfree(vcpu->arch.mce_banks);\nfail_free_lapic:\n\tkvm_free_lapic(vcpu);\nfail_mmu_destroy:\n\tkvm_mmu_destroy(vcpu);\nfail_free_pio_data:\n\tfree_page((unsigned long)vcpu->arch.pio_data);\nfail:\n\treturn r;\n}\n\nvoid kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\tstatic_key_slow_dec(&kvm_no_apic_vcpu);\n}\n\nint kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tatomic_set(&kvm->arch.noncoherent_dma_count, 0);\n\n\t/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\t/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\treturn 0;\n}\n\nstatic void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}\n\nstatic void kvm_free_vcpus(struct kvm *kvm)\n{\n\tunsigned int i;\n\tstruct kvm_vcpu *vcpu;\n\n\t/*\n\t * Unpin any mmu pages first.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_unload_vcpu_mmu(vcpu);\n\t}\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_arch_vcpu_free(vcpu);\n\n\tmutex_lock(&kvm->lock);\n\tfor (i = 0; i < atomic_read(&kvm->online_vcpus); i++)\n\t\tkvm->vcpus[i] = NULL;\n\n\tatomic_set(&kvm->online_vcpus, 0);\n\tmutex_unlock(&kvm->lock);\n}\n\nvoid kvm_arch_sync_events(struct kvm *kvm)\n{\n\tkvm_free_all_assigned_devices(kvm);\n\tkvm_free_pit(kvm);\n}\n\nvoid kvm_arch_destroy_vm(struct kvm *kvm)\n{\n\tif (current->mm == kvm->mm) {\n\t\t/*\n\t\t * Free memory regions allocated on behalf of userspace,\n\t\t * unless the the memory map has changed due to process exit\n\t\t * or fd copying.\n\t\t */\n\t\tstruct kvm_userspace_memory_region mem;\n\t\tmemset(&mem, 0, sizeof(mem));\n\t\tmem.slot = APIC_ACCESS_PAGE_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\n\t\tmem.slot = IDENTITY_PAGETABLE_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\n\t\tmem.slot = TSS_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\t}\n\tkvm_iommu_unmap_guest(kvm);\n\tkfree(kvm->arch.vpic);\n\tkfree(kvm->arch.vioapic);\n\tkvm_free_vcpus(kvm);\n\tif (kvm->arch.apic_access_page)\n\t\tput_page(kvm->arch.apic_access_page);\n\tif (kvm->arch.ept_identity_pagetable)\n\t\tput_page(kvm->arch.ept_identity_pagetable);\n\tkfree(rcu_dereference_check(kvm->arch.apic_map, 1));\n}\n\nvoid kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *free,\n\t\t\t   struct kvm_memory_slot *dont)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tif (!dont || free->arch.rmap[i] != dont->arch.rmap[i]) {\n\t\t\tkvm_kvfree(free->arch.rmap[i]);\n\t\t\tfree->arch.rmap[i] = NULL;\n\t\t}\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tif (!dont || free->arch.lpage_info[i - 1] !=\n\t\t\t     dont->arch.lpage_info[i - 1]) {\n\t\t\tkvm_kvfree(free->arch.lpage_info[i - 1]);\n\t\t\tfree->arch.lpage_info[i - 1] = NULL;\n\t\t}\n\t}\n}\n\nint kvm_arch_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,\n\t\t\t    unsigned long npages)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tunsigned long ugfn;\n\t\tint lpages;\n\t\tint level = i + 1;\n\n\t\tlpages = gfn_to_index(slot->base_gfn + npages - 1,\n\t\t\t\t      slot->base_gfn, level) + 1;\n\n\t\tslot->arch.rmap[i] =\n\t\t\tkvm_kvzalloc(lpages * sizeof(*slot->arch.rmap[i]));\n\t\tif (!slot->arch.rmap[i])\n\t\t\tgoto out_free;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tslot->arch.lpage_info[i - 1] = kvm_kvzalloc(lpages *\n\t\t\t\t\tsizeof(*slot->arch.lpage_info[i - 1]));\n\t\tif (!slot->arch.lpage_info[i - 1])\n\t\t\tgoto out_free;\n\n\t\tif (slot->base_gfn & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tslot->arch.lpage_info[i - 1][0].write_count = 1;\n\t\tif ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tslot->arch.lpage_info[i - 1][lpages - 1].write_count = 1;\n\t\tugfn = slot->userspace_addr >> PAGE_SHIFT;\n\t\t/*\n\t\t * If the gfn and userspace address are not aligned wrt each\n\t\t * other, or if explicitly asked to, disable large page\n\t\t * support for this slot\n\t\t */\n\t\tif ((slot->base_gfn ^ ugfn) & (KVM_PAGES_PER_HPAGE(level) - 1) ||\n\t\t    !kvm_largepages_enabled()) {\n\t\t\tunsigned long j;\n\n\t\t\tfor (j = 0; j < lpages; ++j)\n\t\t\t\tslot->arch.lpage_info[i - 1][j].write_count = 1;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_free:\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvm_kvfree(slot->arch.rmap[i]);\n\t\tslot->arch.rmap[i] = NULL;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tkvm_kvfree(slot->arch.lpage_info[i - 1]);\n\t\tslot->arch.lpage_info[i - 1] = NULL;\n\t}\n\treturn -ENOMEM;\n}\n\nvoid kvm_arch_memslots_updated(struct kvm *kvm)\n{\n\t/*\n\t * memslots->generation has been incremented.\n\t * mmio generation may have reached its maximum value.\n\t */\n\tkvm_mmu_invalidate_mmio_sptes(kvm);\n}\n\nint kvm_arch_prepare_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *memslot,\n\t\t\t\tstruct kvm_userspace_memory_region *mem,\n\t\t\t\tenum kvm_mr_change change)\n{\n\t/*\n\t * Only private memory slots need to be mapped here since\n\t * KVM_SET_MEMORY_REGION ioctl is no longer supported.\n\t */\n\tif ((memslot->id >= KVM_USER_MEM_SLOTS) && (change == KVM_MR_CREATE)) {\n\t\tunsigned long userspace_addr;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\tuserspace_addr = vm_mmap(NULL, 0, memslot->npages * PAGE_SIZE,\n\t\t\t\t\t PROT_READ | PROT_WRITE,\n\t\t\t\t\t MAP_SHARED | MAP_ANONYMOUS, 0);\n\n\t\tif (IS_ERR((void *)userspace_addr))\n\t\t\treturn PTR_ERR((void *)userspace_addr);\n\n\t\tmemslot->userspace_addr = userspace_addr;\n\t}\n\n\treturn 0;\n}\n\nvoid kvm_arch_commit_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_userspace_memory_region *mem,\n\t\t\t\tconst struct kvm_memory_slot *old,\n\t\t\t\tenum kvm_mr_change change)\n{\n\n\tint nr_mmu_pages = 0;\n\n\tif ((mem->slot >= KVM_USER_MEM_SLOTS) && (change == KVM_MR_DELETE)) {\n\t\tint ret;\n\n\t\tret = vm_munmap(old->userspace_addr,\n\t\t\t\told->npages * PAGE_SIZE);\n\t\tif (ret < 0)\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"kvm_vm_ioctl_set_memory_region: \"\n\t\t\t       \"failed to munmap memory\\n\");\n\t}\n\n\tif (!kvm->arch.n_requested_mmu_pages)\n\t\tnr_mmu_pages = kvm_mmu_calculate_mmu_pages(kvm);\n\n\tif (nr_mmu_pages)\n\t\tkvm_mmu_change_mmu_pages(kvm, nr_mmu_pages);\n\t/*\n\t * Write protect all pages for dirty logging.\n\t * Existing largepage mappings are destroyed here and new ones will\n\t * not be created until the end of the logging.\n\t */\n\tif ((change != KVM_MR_DELETE) && (mem->flags & KVM_MEM_LOG_DIRTY_PAGES))\n\t\tkvm_mmu_slot_remove_write_access(kvm, mem->slot);\n}\n\nvoid kvm_arch_flush_shadow_all(struct kvm *kvm)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}\n\nvoid kvm_arch_flush_shadow_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}\n\nint kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t!vcpu->arch.apf.halted)\n\t\t|| !list_empty_careful(&vcpu->async_pf.done)\n\t\t|| kvm_apic_has_events(vcpu)\n\t\t|| vcpu->arch.pv.pv_unhalted\n\t\t|| atomic_read(&vcpu->arch.nmi_queued) ||\n\t\t(kvm_arch_interrupt_allowed(vcpu) &&\n\t\t kvm_cpu_has_interrupt(vcpu));\n}\n\nint kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_exiting_guest_mode(vcpu) == IN_GUEST_MODE;\n}\n\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}\n\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\tunsigned long current_rip = kvm_rip_read(vcpu) +\n\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\treturn current_rip == linear_rip;\n}\nEXPORT_SYMBOL_GPL(kvm_is_linear_rip);\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}\nEXPORT_SYMBOL_GPL(kvm_get_rflags);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_set_rflags);\n\nvoid kvm_arch_async_page_ready(struct kvm_vcpu *vcpu, struct kvm_async_pf *work)\n{\n\tint r;\n\n\tif ((vcpu->arch.mmu.direct_map != work->arch.direct_map) ||\n\t      work->wakeup_all)\n\t\treturn;\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r))\n\t\treturn;\n\n\tif (!vcpu->arch.mmu.direct_map &&\n\t      work->arch.cr3 != vcpu->arch.mmu.get_cr3(vcpu))\n\t\treturn;\n\n\tvcpu->arch.mmu.page_fault(vcpu, work->gva, 0, true);\n}\n\nstatic inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}\n\nstatic inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (roundup_pow_of_two(ASYNC_PF_PER_VCPU) - 1);\n}\n\nstatic void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\twhile (vcpu->arch.apf.gfns[key] != ~0)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\tvcpu->arch.apf.gfns[key] = gfn;\n}\n\nstatic u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tint i;\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU) &&\n\t\t     (vcpu->arch.apf.gfns[key] != gfn &&\n\t\t      vcpu->arch.apf.gfns[key] != ~0); i++)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\treturn key;\n}\n\nbool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;\n}\n\nstatic void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}\n\nstatic int apf_put_user(struct kvm_vcpu *vcpu, u32 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &val,\n\t\t\t\t      sizeof(val));\n}\n\nvoid kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_not_present(work->arch.token, work->gva);\n\tkvm_add_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif (!(vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED) ||\n\t    (vcpu->arch.apf.send_user_only &&\n\t     kvm_x86_ops->get_cpl(vcpu) == 0))\n\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\telse if (!apf_put_user(vcpu, KVM_PV_REASON_PAGE_NOT_PRESENT)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t}\n}\n\nvoid kvm_arch_async_page_present(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_ready(work->arch.token, work->gva);\n\tif (work->wakeup_all)\n\t\twork->arch.token = ~0; /* broadcast wakeup */\n\telse\n\t\tkvm_del_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif ((vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED) &&\n\t    !apf_put_user(vcpu, KVM_PV_REASON_PAGE_READY)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t}\n\tvcpu->arch.apf.halted = false;\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n}\n\nbool kvm_arch_can_inject_async_page_present(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED))\n\t\treturn true;\n\telse\n\t\treturn !kvm_event_needs_reinjection(vcpu) &&\n\t\t\tkvm_x86_ops->interrupt_allowed(vcpu);\n}\n\nvoid kvm_arch_register_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_register_noncoherent_dma);\n\nvoid kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_unregister_noncoherent_dma);\n\nbool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_has_noncoherent_dma);\n\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_exit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_inj_virq);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_page_fault);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_msr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_cr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmrun);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit_inject);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intr_vmexit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_invlpga);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_skinit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intercepts);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_write_tsc_offset);\n"], "fixing_code": ["\n/*\n * Local APIC virtualization\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright (C) 2007 Novell\n * Copyright (C) 2007 Intel\n * Copyright 2009 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Dor Laor <dor.laor@qumranet.com>\n *   Gregory Haskins <ghaskins@novell.com>\n *   Yaozu (Eddie) Dong <eddie.dong@intel.com>\n *\n * Based on Xen 3.1 code, Copyright (c) 2004, Intel Corporation.\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n */\n\n#include <linux/kvm_host.h>\n#include <linux/kvm.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/smp.h>\n#include <linux/hrtimer.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <asm/processor.h>\n#include <asm/msr.h>\n#include <asm/page.h>\n#include <asm/current.h>\n#include <asm/apicdef.h>\n#include <linux/atomic.h>\n#include <linux/jump_label.h>\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"trace.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n\n#ifndef CONFIG_X86_64\n#define mod_64(x, y) ((x) - (y) * div64_u64(x, y))\n#else\n#define mod_64(x, y) ((x) % (y))\n#endif\n\n#define PRId64 \"d\"\n#define PRIx64 \"llx\"\n#define PRIu64 \"u\"\n#define PRIo64 \"o\"\n\n#define APIC_BUS_CYCLE_NS 1\n\n/* #define apic_debug(fmt,arg...) printk(KERN_WARNING fmt,##arg) */\n#define apic_debug(fmt, arg...)\n\n#define APIC_LVT_NUM\t\t\t6\n/* 14 is the version for Xeon and Pentium 8.4.8*/\n#define APIC_VERSION\t\t\t(0x14UL | ((APIC_LVT_NUM - 1) << 16))\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n/* followed define is not in apicdef.h */\n#define APIC_SHORT_MASK\t\t\t0xc0000\n#define APIC_DEST_NOSHORT\t\t0x0\n#define APIC_DEST_MASK\t\t\t0x800\n#define MAX_APIC_VECTOR\t\t\t256\n#define APIC_VECTORS_PER_REG\t\t32\n\n#define VEC_POS(v) ((v) & (32 - 1))\n#define REG_POS(v) (((v) >> 5) << 4)\n\nstatic unsigned int min_timer_period_us = 500;\nmodule_param(min_timer_period_us, uint, S_IRUGO | S_IWUSR);\n\nstatic inline void apic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}\n\nstatic inline void apic_set_vector(int vec, void *bitmap)\n{\n\tset_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstatic inline void apic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstatic inline int __apic_test_and_set_vector(int vec, void *bitmap)\n{\n\treturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstatic inline int __apic_test_and_clear_vector(int vec, void *bitmap)\n{\n\treturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n\nstruct static_key_deferred apic_hw_disabled __read_mostly;\nstruct static_key_deferred apic_sw_disabled __read_mostly;\n\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tif ((kvm_apic_get_reg(apic, APIC_SPIV) ^ val) & APIC_SPIV_APIC_ENABLED) {\n\t\tif (val & APIC_SPIV_APIC_ENABLED)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n\tapic_set_reg(apic, APIC_SPIV, val);\n}\n\nstatic inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}\n\n#define LVT_MASK\t\\\n\t(APIC_LVT_MASKED | APIC_SEND_PENDING | APIC_VECTOR_MASK)\n\n#define LINT_MASK\t\\\n\t(LVT_MASK | APIC_MODE_MASK | APIC_INPUT_POLARITY | \\\n\t APIC_LVT_REMOTE_IRR | APIC_LVT_LEVEL_TRIGGER)\n\nstatic inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_apic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}\n\nstatic void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->ldr_bits = 8;\n\t/* flat mode is default */\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All APICs have to be configured in the same mode by an OS.\n\t\t * We take advatage of this while building logical id loockup\n\t\t * table. After reset APICs are in xapic/flat mode, so if we\n\t\t * find apic with different setting we assume this is the mode\n\t\t * OS wants all apics to be in; build lookup table accordingly.\n\t\t */\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask /* flat mode */ &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}\n\nstatic inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}\n\nstatic inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tapic_set_reg(apic, APIC_LDR, id);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}\n\nstatic inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn !(kvm_apic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\n}\n\nstatic inline int apic_lvt_vector(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn kvm_apic_get_reg(apic, lvt_type) & APIC_VECTOR_MASK;\n}\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\tapic->lapic_timer.timer_mode_mask) == APIC_LVT_TIMER_ONESHOT);\n}\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\tapic->lapic_timer.timer_mode_mask) == APIC_LVT_TIMER_PERIODIC);\n}\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\tapic->lapic_timer.timer_mode_mask) ==\n\t\t\tAPIC_LVT_TIMER_TSCDEADLINE);\n}\n\nstatic inline int apic_lvt_nmi_mode(u32 lvt_val)\n{\n\treturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\n}\n\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tapic_set_reg(apic, APIC_LVR, v);\n}\n\nstatic const unsigned int apic_lvt_mask[APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\n\nstatic int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn fls(*reg) - 1 + vec;\n\t}\n\n\treturn -1;\n}\n\nstatic u8 count_vectors(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\tu8 count = 0;\n\n\tfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tcount += hweight32(*reg);\n\t}\n\n\treturn count;\n}\n\nvoid kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir)\n{\n\tu32 i, pir_val;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tfor (i = 0; i <= 7; i++) {\n\t\tpir_val = xchg(&pir[i], 0);\n\t\tif (pir_val)\n\t\t\t*((u32 *)(apic->regs + APIC_IRR + i * 0x10)) |= pir_val;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_apic_update_irr);\n\nstatic inline void apic_set_irr(int vec, struct kvm_lapic *apic)\n{\n\tapic->irr_pending = true;\n\tapic_set_vector(vec, apic->regs + APIC_IRR);\n}\n\nstatic inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}\n\nstatic inline int apic_find_highest_irr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that irr_pending is just a hint. It will be always\n\t * true with virtual interrupt delivery enabled.\n\t */\n\tif (!apic->irr_pending)\n\t\treturn -1;\n\n\tkvm_x86_ops->sync_pir_to_irr(apic->vcpu);\n\tresult = apic_search_irr(apic);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}\n\nstatic inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\n{\n\tapic->irr_pending = false;\n\tapic_clear_vector(vec, apic->regs + APIC_IRR);\n\tif (apic_search_irr(apic) != -1)\n\t\tapic->irr_pending = true;\n}\n\nstatic inline void apic_set_isr(int vec, struct kvm_lapic *apic)\n{\n\tif (!__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\n\t\t++apic->isr_count;\n\tBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\n\t/*\n\t * ISR (in service register) bit is set when injecting an interrupt.\n\t * The highest vector is injected. Thus the latest bit set matches\n\t * the highest bit in ISR.\n\t */\n\tapic->highest_isr_cache = vec;\n}\n\nstatic inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tif (__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\t--apic->isr_count;\n\tBUG_ON(apic->isr_count < 0);\n\tapic->highest_isr_cache = -1;\n}\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\tint highest_irr;\n\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 0;\n\thighest_irr = apic_find_highest_irr(vcpu->arch.apic);\n\n\treturn highest_irr;\n}\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     unsigned long *dest_map);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\tunsigned long *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}\n\nstatic int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}\n\nstatic int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}\n\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}\n\nstatic bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\n{\n\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0)\n\t\tapic_debug(\"Can't read EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\treturn val & 0x1;\n}\n\nstatic void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\n\t\tapic_debug(\"Can't set EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}\n\nstatic void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tapic_debug(\"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpi->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/* Note that isr_count is always 1 with vid enabled */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}\n\nvoid kvm_apic_update_tmr(struct kvm_vcpu *vcpu, u32 *tmr)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tapic_set_reg(apic, APIC_TMR + 0x10 * i, tmr[i]);\n}\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_apic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}\n\nstatic void apic_set_tpr(struct kvm_lapic *apic, u32 tpr)\n{\n\tapic_set_reg(apic, APIC_TASKPRI, tpr);\n\tapic_update_ppr(apic);\n}\n\nint kvm_apic_match_physical_addr(struct kvm_lapic *apic, u16 dest)\n{\n\treturn dest == 0xff || kvm_apic_id(apic) == dest;\n}\n\nint kvm_apic_match_logical_addr(struct kvm_lapic *apic, u8 mda)\n{\n\tint result = 0;\n\tu32 logical_id;\n\n\tif (apic_x2apic_mode(apic)) {\n\t\tlogical_id = kvm_apic_get_reg(apic, APIC_LDR);\n\t\treturn logical_id & mda;\n\t}\n\n\tlogical_id = GET_APIC_LOGICAL_ID(kvm_apic_get_reg(apic, APIC_LDR));\n\n\tswitch (kvm_apic_get_reg(apic, APIC_DFR)) {\n\tcase APIC_DFR_FLAT:\n\t\tif (logical_id & mda)\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase APIC_DFR_CLUSTER:\n\t\tif (((logical_id >> 4) == (mda >> 0x4))\n\t\t    && (logical_id & mda & 0xf))\n\t\t\tresult = 1;\n\t\tbreak;\n\tdefault:\n\t\tapic_debug(\"Bad DFR vcpu %d: %08x\\n\",\n\t\t\t   apic->vcpu->vcpu_id, kvm_apic_get_reg(apic, APIC_DFR));\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nint kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, int dest, int dest_mode)\n{\n\tint result = 0;\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == 0)\n\t\t\t/* Physical mode. */\n\t\t\tresult = kvm_apic_match_physical_addr(target, dest);\n\t\telse\n\t\t\t/* Logical mode. */\n\t\t\tresult = kvm_apic_match_logical_addr(target, dest);\n\t\tbreak;\n\tcase APIC_DEST_SELF:\n\t\tresult = (target == source);\n\t\tbreak;\n\tcase APIC_DEST_ALLINC:\n\t\tresult = 1;\n\t\tbreak;\n\tcase APIC_DEST_ALLBUT:\n\t\tresult = (target != source);\n\t\tbreak;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, unsigned long *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap = 1;\n\tstruct kvm_lapic **dst;\n\tint i;\n\tbool ret = false;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map)\n\t\tgoto out;\n\n\tif (irq->dest_mode == 0) { /* physical mode */\n\t\tif (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\t\tirq->dest_id == 0xff)\n\t\t\tgoto out;\n\t\tdst = &map->phys_map[irq->dest_id & 0xff];\n\t} else {\n\t\tu32 mda = irq->dest_id << (32 - map->ldr_bits);\n\n\t\tdst = map->logical_map[apic_cluster_id(map, mda)];\n\n\t\tbitmap = apic_logical_id(map, mda);\n\n\t\tif (irq->delivery_mode == APIC_DM_LOWEST) {\n\t\t\tint l = -1;\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tif (!dst[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (l < 0)\n\t\t\t\t\tl = i;\n\t\t\t\telse if (kvm_apic_compare_prio(dst[i]->vcpu, dst[l]->vcpu) < 0)\n\t\t\t\t\tl = i;\n\t\t\t}\n\n\t\t\tbitmap = (l >= 0) ? 1 << l : 0;\n\t\t}\n\t}\n\n\tfor_each_set_bit(i, &bitmap, 16) {\n\t\tif (!dst[i])\n\t\t\tcontinue;\n\t\tif (*r < 0)\n\t\t\t*r = 0;\n\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t}\n\n\tret = true;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n/*\n * Add a pending IRQ into lapic.\n * Return 1 if successfully added and 0 if discarded.\n */\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     unsigned long *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\tcase APIC_DM_FIXED:\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map)\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map);\n\n\t\tif (kvm_x86_ops->deliver_posted_interrupt)\n\t\t\tkvm_x86_ops->deliver_posted_interrupt(vcpu, vector);\n\t\telse {\n\t\t\tapic_set_irr(vector, apic);\n\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t\t  trig_mode, vector, false);\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tapic_debug(\"Ignoring guest SMI\\n\");\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\t/* make sure pending_events is visible before sending\n\t\t\t * the request */\n\t\t\tsmp_wmb();\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t} else {\n\t\t\tapic_debug(\"Ignoring de-assert INIT to vcpu %d\\n\",\n\t\t\t\t   vcpu->vcpu_id);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tapic_debug(\"SIPI to vcpu %d vector 0x%02x\\n\",\n\t\t\t   vcpu->vcpu_id, vector);\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nint kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}\n\nstatic void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tif (!(kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI) &&\n\t    kvm_ioapic_handles_vector(apic->vcpu->kvm, vector)) {\n\t\tint trigger_mode;\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\t\telse\n\t\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\t\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n\t}\n}\n\nstatic int apic_set_eoi(struct kvm_lapic *apic)\n{\n\tint vector = apic_find_highest_isr(apic);\n\n\ttrace_kvm_eoi(apic, vector);\n\n\t/*\n\t * Not every write EOI will has corresponding ISR,\n\t * one example is when Kernel check timer on setup_IO_APIC\n\t */\n\tif (vector == -1)\n\t\treturn vector;\n\n\tapic_clear_isr(vector, apic);\n\tapic_update_ppr(apic);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\treturn vector;\n}\n\n/*\n * this interface assumes a trap-like exit, which has already finished\n * desired side effect including vISR and vPPR update.\n */\nvoid kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\ttrace_kvm_eoi(apic, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_apic_set_eoi_accelerated);\n\nstatic void apic_send_ipi(struct kvm_lapic *apic)\n{\n\tu32 icr_low = kvm_apic_get_reg(apic, APIC_ICR);\n\tu32 icr_high = kvm_apic_get_reg(apic, APIC_ICR2);\n\tstruct kvm_lapic_irq irq;\n\n\tirq.vector = icr_low & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr_low & APIC_MODE_MASK;\n\tirq.dest_mode = icr_low & APIC_DEST_MASK;\n\tirq.level = icr_low & APIC_INT_ASSERT;\n\tirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\n\tirq.shorthand = icr_low & APIC_SHORT_MASK;\n\tif (apic_x2apic_mode(apic))\n\t\tirq.dest_id = icr_high;\n\telse\n\t\tirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\n\n\ttrace_kvm_apic_ipi(icr_low, irq.dest_id);\n\n\tapic_debug(\"icr_high 0x%x, icr_low 0x%x, \"\n\t\t   \"short_hand 0x%x, dest 0x%x, trig_mode 0x%x, level 0x%x, \"\n\t\t   \"dest_mode 0x%x, delivery_mode 0x%x, vector 0x%x\\n\",\n\t\t   icr_high, icr_low, irq.shorthand, irq.dest_id,\n\t\t   irq.trig_mode, irq.level, irq.dest_mode, irq.delivery_mode,\n\t\t   irq.vector);\n\n\tkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\n}\n\nstatic u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}\n\nstatic void __report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\n\trun->tpr_access.rip = kvm_rip_read(vcpu);\n\trun->tpr_access.is_write = write;\n}\n\nstatic inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}\n\nstatic u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\n{\n\tu32 val = 0;\n\n\tif (offset >= LAPIC_MMIO_LENGTH)\n\t\treturn 0;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (apic_x2apic_mode(apic))\n\t\t\tval = kvm_apic_id(apic);\n\t\telse\n\t\t\tval = kvm_apic_id(apic) << 24;\n\t\tbreak;\n\tcase APIC_ARBPRI:\n\t\tapic_debug(\"Access APIC ARBPRI register which is for P6\\n\");\n\t\tbreak;\n\n\tcase APIC_TMCCT:\t/* Timer CCR */\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\treturn 0;\n\n\t\tval = apic_get_tmcct(apic);\n\t\tbreak;\n\tcase APIC_PROCPRI:\n\t\tapic_update_ppr(apic);\n\t\tval = kvm_apic_get_reg(apic, offset);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, false);\n\t\t/* fall thru */\n\tdefault:\n\t\tval = kvm_apic_get_reg(apic, offset);\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nstatic inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}\n\nstatic int apic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn kvm_apic_hw_enabled(apic) &&\n\t    addr >= apic->base_address &&\n\t    addr < apic->base_address + LAPIC_MMIO_LENGTH;\n}\n\nstatic int apic_mmio_read(struct kvm_io_device *this,\n\t\t\t   gpa_t address, int len, void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tu32 offset = address - apic->base_address;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\tapic_reg_read(apic, offset, len, data);\n\n\treturn 0;\n}\n\nstatic void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_apic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n\n\tapic_debug(\"timer divide count is 0x%x\\n\",\n\t\t\t\t   apic->divide_count);\n}\n\nstatic void start_apic_timer(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\n\t\t/* lapic timer in oneshot or periodic mode */\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tapic->lapic_timer.period = (u64)kvm_apic_get_reg(apic, APIC_TMICT)\n\t\t\t    * APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\t\tif (!apic->lapic_timer.period)\n\t\t\treturn;\n\t\t/*\n\t\t * Do not allow the guest to program periodic timers with small\n\t\t * interval, since the hrtimers are not throttled by the host\n\t\t * scheduler.\n\t\t */\n\t\tif (apic_lvtt_period(apic)) {\n\t\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\t\tpr_info_ratelimited(\n\t\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\t\tapic->lapic_timer.period = min_period;\n\t\t\t}\n\t\t}\n\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t      ktime_add_ns(now, apic->lapic_timer.period),\n\t\t\t      HRTIMER_MODE_ABS);\n\n\t\tapic_debug(\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\", __func__,\n\t\t\t   APIC_BUS_CYCLE_NS, ktime_to_ns(now),\n\t\t\t   kvm_apic_get_reg(apic, APIC_TMICT),\n\t\t\t   apic->lapic_timer.period,\n\t\t\t   ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)));\n\t} else if (apic_lvtt_tscdeadline(apic)) {\n\t\t/* lapic timer in tsc deadline mode */\n\t\tu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\n\t\tu64 ns = 0;\n\t\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\t\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\t\treturn;\n\n\t\tlocal_irq_save(flags);\n\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tguest_tsc = kvm_x86_ops->read_l1_tsc(vcpu, native_read_tsc());\n\t\tif (likely(tscdeadline > guest_tsc)) {\n\t\t\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\t\t\tdo_div(ns, this_tsc_khz);\n\t\t}\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\tktime_add_ns(now, ns), HRTIMER_MODE_ABS);\n\n\t\tlocal_irq_restore(flags);\n\t}\n}\n\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tint nmi_wd_enabled = apic_lvt_nmi_mode(kvm_apic_get_reg(apic, APIC_LVT0));\n\n\tif (apic_lvt_nmi_mode(lvt0_val)) {\n\t\tif (!nmi_wd_enabled) {\n\t\t\tapic_debug(\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\", apic->vcpu->vcpu_id);\n\t\t\tapic->vcpu->kvm->arch.vapics_in_nmi_mode++;\n\t\t}\n\t} else if (nmi_wd_enabled)\n\t\tapic->vcpu->kvm->arch.vapics_in_nmi_mode--;\n}\n\nstatic int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_apic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_apic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif ((kvm_apic_get_reg(apic, APIC_LVTT) &\n\t\t    apic->lapic_timer.timer_mode_mask) !=\n\t\t   (val & apic->lapic_timer.timer_mode_mask))\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tapic_set_reg(apic, APIC_LVTT, val);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}\n\nstatic int apic_mmio_write(struct kvm_io_device *this,\n\t\t\t    gpa_t address, int len, const void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tunsigned int offset = address - apic->base_address;\n\tu32 val;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * APIC register must be aligned on 128-bits boundary.\n\t * 32/64/128 bits registers must be accessed thru 32 bits.\n\t * Refer SDM 8.4.1\n\t */\n\tif (len != 4 || (offset & 0xf)) {\n\t\t/* Don't shout loud, $infamous_os would cause only noise. */\n\t\tapic_debug(\"apic write: bad size=%d %lx\\n\", len, (long)address);\n\t\treturn 0;\n\t}\n\n\tval = *(u32*)data;\n\n\t/* too common printing */\n\tif (offset != APIC_EOI)\n\t\tapic_debug(\"%s: offset 0x%x with length 0x%x, and value is \"\n\t\t\t   \"0x%x\\n\", __func__, offset, len, val);\n\n\tapic_reg_write(apic, offset & 0xff0, val);\n\n\treturn 0;\n}\n\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_vcpu_has_lapic(vcpu))\n\t\tapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}\nEXPORT_SYMBOL_GPL(kvm_lapic_set_eoi);\n\n/* emulate APIC access in a trap manner */\nvoid kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)\n{\n\tu32 val = 0;\n\n\t/* hw has done the conditional check and inst decode */\n\toffset &= 0xff0;\n\n\tapic_reg_read(vcpu->arch.apic, offset, 4, &val);\n\n\t/* TODO: optimize to just emulate side effect w/o one more write */\n\tapic_reg_write(vcpu->arch.apic, offset, val);\n}\nEXPORT_SYMBOL_GPL(kvm_apic_write_nodecode);\n\nvoid kvm_free_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\n\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\n\tif (!(kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_APIC_ENABLED))\n\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\n\tif (apic->regs)\n\t\tfree_page((unsigned long)apic->regs);\n\n\tkfree(apic);\n}\n\n/*\n *----------------------------------------------------------------------\n * LAPIC interface\n *----------------------------------------------------------------------\n */\n\nu64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn 0;\n\n\treturn apic->lapic_timer.tscdeadline;\n}\n\nvoid kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic->lapic_timer.tscdeadline = data;\n\tstart_apic_timer(apic);\n}\n\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_apic_get_reg(apic, APIC_TASKPRI) & 4));\n}\n\nu64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 0;\n\n\ttpr = (u64) kvm_apic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}\n\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\t/* update jump label if enable bit changes */\n\tif ((vcpu->arch.apic_base ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif (!kvm_vcpu_is_bsp(apic->vcpu))\n\t\tvalue &= ~MSR_IA32_APICBASE_BSP;\n\n\tvcpu->arch.apic_base = value;\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tu32 id = kvm_apic_id(apic);\n\t\t\tu32 ldr = ((id >> 4) << 16) | (1 << (id & 0xf));\n\t\t\tkvm_apic_set_ldr(apic, ldr);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}\n\nvoid kvm_lapic_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic;\n\tint i;\n\n\tapic_debug(\"%s\\n\", __func__);\n\n\tASSERT(vcpu);\n\tapic = vcpu->arch.apic;\n\tASSERT(apic != NULL);\n\n\t/* Stop the timer in case it's a reset to an active apic */\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tkvm_apic_set_id(apic, vcpu->vcpu_id);\n\tkvm_apic_set_version(apic->vcpu);\n\n\tfor (i = 0; i < APIC_LVT_NUM; i++)\n\t\tapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\n\tapic_set_reg(apic, APIC_LVT0,\n\t\t     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\n\n\tapic_set_reg(apic, APIC_DFR, 0xffffffffU);\n\tapic_set_spiv(apic, 0xff);\n\tapic_set_reg(apic, APIC_TASKPRI, 0);\n\tkvm_apic_set_ldr(apic, 0);\n\tapic_set_reg(apic, APIC_ESR, 0);\n\tapic_set_reg(apic, APIC_ICR, 0);\n\tapic_set_reg(apic, APIC_ICR2, 0);\n\tapic_set_reg(apic, APIC_TDCR, 0);\n\tapic_set_reg(apic, APIC_TMICT, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\tapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\n\t\tapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\n\t\tapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\n\t}\n\tapic->irr_pending = kvm_apic_vid_enabled(vcpu->kvm);\n\tapic->isr_count = kvm_apic_vid_enabled(vcpu->kvm);\n\tapic->highest_isr_cache = -1;\n\tupdate_divide_count(apic);\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\tif (kvm_vcpu_is_bsp(vcpu))\n\t\tkvm_lapic_set_base(vcpu,\n\t\t\t\tvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\n\tvcpu->arch.pv_eoi.msr_val = 0;\n\tapic_update_ppr(apic);\n\n\tvcpu->arch.apic_arb_prio = 0;\n\tvcpu->arch.apic_attention = 0;\n\n\tapic_debug(KERN_INFO \"%s: vcpu=%p, id=%d, base_msr=\"\n\t\t   \"0x%016\" PRIx64 \", base_address=0x%0lx.\\n\", __func__,\n\t\t   vcpu, kvm_apic_id(apic),\n\t\t   vcpu->arch.apic_base, apic->base_address);\n}\n\n/*\n *----------------------------------------------------------------------\n * timer interface\n *----------------------------------------------------------------------\n */\n\nstatic bool lapic_is_periodic(struct kvm_lapic *apic)\n{\n\treturn apic_lvtt_period(apic);\n}\n\nint apic_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (kvm_vcpu_has_lapic(vcpu) && apic_enabled(apic) &&\n\t\t\tapic_lvt_enabled(apic, APIC_LVTT))\n\t\treturn atomic_read(&apic->lapic_timer.pending);\n\n\treturn 0;\n}\n\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_apic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\nvoid kvm_apic_nmi_wd_deliver(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic)\n\t\tkvm_apic_local_deliver(apic, APIC_LVT0);\n}\n\nstatic const struct kvm_io_device_ops apic_mmio_ops = {\n\t.read     = apic_mmio_read,\n\t.write    = apic_mmio_write,\n};\n\nstatic enum hrtimer_restart apic_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_timer *ktimer = container_of(data, struct kvm_timer, timer);\n\tstruct kvm_lapic *apic = container_of(ktimer, struct kvm_lapic, lapic_timer);\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\twait_queue_head_t *q = &vcpu->wq;\n\n\t/*\n\t * There is a race window between reading and incrementing, but we do\n\t * not care about potentially losing timer events in the !reinject\n\t * case anyway. Note: KVM_REQ_PENDING_TIMER is implicitly checked\n\t * in vcpu_enter_guest.\n\t */\n\tif (!atomic_read(&ktimer->pending)) {\n\t\tatomic_inc(&ktimer->pending);\n\t\t/* FIXME: this code should not know anything about vcpus */\n\t\tkvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);\n\t}\n\n\tif (waitqueue_active(q))\n\t\twake_up_interruptible(q);\n\n\tif (lapic_is_periodic(apic)) {\n\t\thrtimer_add_expires_ns(&ktimer->timer, ktimer->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}\n\nint kvm_create_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic;\n\n\tASSERT(vcpu != NULL);\n\tapic_debug(\"apic_init %d\\n\", vcpu->vcpu_id);\n\n\tapic = kzalloc(sizeof(*apic), GFP_KERNEL);\n\tif (!apic)\n\t\tgoto nomem;\n\n\tvcpu->arch.apic = apic;\n\n\tapic->regs = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!apic->regs) {\n\t\tprintk(KERN_ERR \"malloc apic regs error for vcpu %x\\n\",\n\t\t       vcpu->vcpu_id);\n\t\tgoto nomem_free_apic;\n\t}\n\tapic->vcpu = vcpu;\n\n\thrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_ABS);\n\tapic->lapic_timer.timer.function = apic_timer_fn;\n\n\t/*\n\t * APIC is created enabled. This will prevent kvm_lapic_set_base from\n\t * thinking that APIC satet has changed.\n\t */\n\tvcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;\n\tkvm_lapic_set_base(vcpu,\n\t\t\tAPIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE);\n\n\tstatic_key_slow_inc(&apic_sw_disabled.key); /* sw disabled at reset */\n\tkvm_lapic_reset(vcpu);\n\tkvm_iodevice_init(&apic->dev, &apic_mmio_ops);\n\n\treturn 0;\nnomem_free_apic:\n\tkfree(apic);\nnomem:\n\treturn -ENOMEM;\n}\n\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint highest_irr;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || !apic_enabled(apic))\n\t\treturn -1;\n\n\tapic_update_ppr(apic);\n\thighest_irr = apic_find_highest_irr(apic);\n\tif ((highest_irr == -1) ||\n\t    ((highest_irr & 0xF0) <= kvm_apic_get_reg(apic, APIC_PROCPRI)))\n\t\treturn -1;\n\treturn highest_irr;\n}\n\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_apic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\tint r = 0;\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\tr = 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\tr = 1;\n\treturn r;\n}\n\nvoid kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tif (atomic_read(&apic->lapic_timer.pending) > 0) {\n\t\tkvm_apic_local_deliver(apic, APIC_LVTT);\n\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\t}\n}\n\nint kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)\n{\n\tint vector = kvm_apic_has_interrupt(vcpu);\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (vector == -1)\n\t\treturn -1;\n\n\tapic_set_isr(vector, apic);\n\tapic_update_ppr(apic);\n\tapic_clear_irr(vector, apic);\n\treturn vector;\n}\n\nvoid kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tkvm_lapic_set_base(vcpu, vcpu->arch.apic_base);\n\t/* set SPIV separately to get count of SW disabled APICs right */\n\tapic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));\n\tmemcpy(vcpu->arch.apic->regs, s->regs, sizeof *s);\n\t/* call kvm_apic_set_id() to put apic into apic_map */\n\tkvm_apic_set_id(apic, kvm_apic_id(apic));\n\tkvm_apic_set_version(vcpu);\n\n\tapic_update_ppr(apic);\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tupdate_divide_count(apic);\n\tstart_apic_timer(apic);\n\tapic->irr_pending = true;\n\tapic->isr_count = kvm_apic_vid_enabled(vcpu->kvm) ?\n\t\t\t\t1 : count_vectors(apic->regs + APIC_ISR);\n\tapic->highest_isr_cache = -1;\n\tkvm_x86_ops->hwapic_isr_update(vcpu->kvm, apic_find_highest_isr(apic));\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tkvm_rtc_eoi_tracking_restore_one(vcpu);\n}\n\nvoid __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\ttimer = &vcpu->arch.apic->lapic_timer.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}\n\n/*\n * apic_sync_pv_eoi_from_guest - called on vmexit or cancel interrupt\n *\n * Detect whether guest triggered PV EOI since the\n * last entry. If yes, set EOI on guests's behalf.\n * Clear PV EOI in guest memory in any case.\n */\nstatic void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}\n\nvoid kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tkvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}\n\n/*\n * apic_sync_pv_eoi_to_guest - called before vmentry\n *\n * Detect whether it's safe to enable PV EOI and\n * if yes do so.\n */\nstatic void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tif (!pv_eoi_enabled(vcpu) ||\n\t    /* IRR set or many bits in ISR: could be nested. */\n\t    apic->irr_pending ||\n\t    /* Cache not set: could be safe but we don't bother. */\n\t    apic->highest_isr_cache == -1 ||\n\t    /* Need EOI to update ioapic. */\n\t    kvm_ioapic_handles_vector(vcpu->kvm, apic->highest_isr_cache)) {\n\t\t/*\n\t\t * PV EOI was disabled by apic_sync_pv_eoi_from_guest\n\t\t * so we need not do anything here.\n\t\t */\n\t\treturn;\n\t}\n\n\tpv_eoi_set_pending(apic->vcpu);\n}\n\nvoid kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}\n\nint kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}\n\nint kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4;\n\n\tif (!irqchip_in_kernel(vcpu->kvm) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (msr == 0x830)\n\t\tapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn apic_reg_write(apic, reg, (u32)data);\n}\n\nint kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4, low, high = 0;\n\n\tif (!irqchip_in_kernel(vcpu->kvm) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (apic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (msr == 0x830)\n\t\tapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}\n\nint kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn apic_reg_write(apic, reg, (u32)data);\n}\n\nint kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 low, high = 0;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 1;\n\n\tif (apic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}\n\nint kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t\t addr, sizeof(u8));\n}\n\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tunsigned int sipi_vector;\n\tunsigned long pe;\n\n\tif (!kvm_vcpu_has_lapic(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\tpe = xchg(&apic->pending_events, 0);\n\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu);\n\t\tkvm_vcpu_reset(vcpu);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tpr_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}\n\nvoid kvm_lapic_init(void)\n{\n\t/* do not patch jump label more than once per second */\n\tjump_label_rate_limit(&apic_hw_disabled, HZ);\n\tjump_label_rate_limit(&apic_sw_disabled, HZ);\n}\n", "#ifndef __KVM_X86_LAPIC_H\n#define __KVM_X86_LAPIC_H\n\n#include \"iodev.h\"\n\n#include <linux/kvm_host.h>\n\n#define KVM_APIC_INIT\t\t0\n#define KVM_APIC_SIPI\t\t1\n\nstruct kvm_timer {\n\tstruct hrtimer timer;\n\ts64 period; \t\t\t\t/* unit: ns */\n\tu32 timer_mode_mask;\n\tu64 tscdeadline;\n\tatomic_t pending;\t\t\t/* accumulated triggered timers */\n};\n\nstruct kvm_lapic {\n\tunsigned long base_address;\n\tstruct kvm_io_device dev;\n\tstruct kvm_timer lapic_timer;\n\tu32 divide_count;\n\tstruct kvm_vcpu *vcpu;\n\tbool irr_pending;\n\t/* Number of bits set in ISR. */\n\ts16 isr_count;\n\t/* The highest vector set in ISR; if -1 - invalid, must scan ISR. */\n\tint highest_isr_cache;\n\t/**\n\t * APIC register page.  The layout matches the register layout seen by\n\t * the guest 1:1, because it is accessed by the vmx microcode.\n\t * Note: Only one register, the TPR, is used by the microcode.\n\t */\n\tvoid *regs;\n\tgpa_t vapic_addr;\n\tstruct gfn_to_hva_cache vapic_cache;\n\tunsigned long pending_events;\n\tunsigned int sipi_vector;\n};\nint kvm_create_lapic(struct kvm_vcpu *vcpu);\nvoid kvm_free_lapic(struct kvm_vcpu *vcpu);\n\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu);\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu);\nint kvm_get_apic_interrupt(struct kvm_vcpu *vcpu);\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu);\nvoid kvm_lapic_reset(struct kvm_vcpu *vcpu);\nu64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu);\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8);\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu);\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value);\nu64 kvm_lapic_get_base(struct kvm_vcpu *vcpu);\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu);\n\nvoid kvm_apic_update_tmr(struct kvm_vcpu *vcpu, u32 *tmr);\nvoid kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir);\nint kvm_apic_match_physical_addr(struct kvm_lapic *apic, u16 dest);\nint kvm_apic_match_logical_addr(struct kvm_lapic *apic, u8 mda);\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\tunsigned long *dest_map);\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type);\n\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, unsigned long *dest_map);\n\nu64 kvm_get_apic_base(struct kvm_vcpu *vcpu);\nvoid kvm_set_apic_base(struct kvm_vcpu *vcpu, u64 data);\nvoid kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s);\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu);\n\nu64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu);\nvoid kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data);\n\nvoid kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset);\nvoid kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector);\n\nint kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr);\nvoid kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu);\nvoid kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu);\n\nint kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data);\nint kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data);\n\nint kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data);\nint kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data);\n\nstatic inline bool kvm_hv_vapic_assist_page_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hv_vapic & HV_X64_MSR_APIC_ASSIST_PAGE_ENABLE;\n}\n\nint kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data);\nvoid kvm_lapic_init(void);\n\nstatic inline u32 kvm_apic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\t        return *((u32 *) (apic->regs + reg_off));\n}\n\nextern struct static_key kvm_no_apic_vcpu;\n\nstatic inline bool kvm_vcpu_has_lapic(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}\n\nextern struct static_key_deferred apic_hw_disabled;\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}\n\nextern struct static_key_deferred apic_sw_disabled;\n\nstatic inline int kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_APIC_ENABLED;\n\treturn APIC_SPIV_APIC_ENABLED;\n}\n\nstatic inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_has_lapic(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}\n\nstatic inline int kvm_lapic_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);\n}\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}\n\nstatic inline bool kvm_apic_vid_enabled(struct kvm *kvm)\n{\n\treturn kvm_x86_ops->vm_has_apicv(kvm);\n}\n\nstatic inline u16 apic_cluster_id(struct kvm_apic_map *map, u32 ldr)\n{\n\tu16 cid;\n\tldr >>= 32 - map->ldr_bits;\n\tcid = (ldr >> map->cid_shift) & map->cid_mask;\n\n\tBUG_ON(cid >= ARRAY_SIZE(map->logical_map));\n\n\treturn cid;\n}\n\nstatic inline u16 apic_logical_id(struct kvm_apic_map *map, u32 ldr)\n{\n\tldr >>= (32 - map->ldr_bits);\n\treturn ldr & map->lid_mask;\n}\n\nstatic inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector);\n\n#endif\n", "/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * derived from drivers/kvm/kvm_main.c\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright (C) 2008 Qumranet, Inc.\n * Copyright IBM Corporation, 2008\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *   Amit Shah    <amit.shah@qumranet.com>\n *   Ben-Ami Yassour <benami@il.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n */\n\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include \"mmu.h\"\n#include \"i8254.h\"\n#include \"tss.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n\n#include <linux/clocksource.h>\n#include <linux/interrupt.h>\n#include <linux/kvm.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/mman.h>\n#include <linux/highmem.h>\n#include <linux/iommu.h>\n#include <linux/intel-iommu.h>\n#include <linux/cpufreq.h>\n#include <linux/user-return-notifier.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/uaccess.h>\n#include <linux/hash.h>\n#include <linux/pci.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pvclock_gtod.h>\n#include <trace/events/kvm.h>\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\n#include <asm/debugreg.h>\n#include <asm/msr.h>\n#include <asm/desc.h>\n#include <asm/mtrr.h>\n#include <asm/mce.h>\n#include <asm/i387.h>\n#include <asm/fpu-internal.h> /* Ugh! */\n#include <asm/xcr.h>\n#include <asm/pvclock.h>\n#include <asm/div64.h>\n\n#define MAX_IO_MSRS 256\n#define KVM_MAX_MCE_BANKS 32\n#define KVM_MCE_CAP_SUPPORTED (MCG_CTL_P | MCG_SER_P)\n\n#define emul_to_vcpu(ctxt) \\\n\tcontainer_of(ctxt, struct kvm_vcpu, arch.emulate_ctxt)\n\n/* EFER defaults:\n * - enable syscall per default because its emulated by KVM\n * - enable LME and LMA per default on 64 bit KVM\n */\n#ifdef CONFIG_X86_64\nstatic\nu64 __read_mostly efer_reserved_bits = ~((u64)(EFER_SCE | EFER_LME | EFER_LMA));\n#else\nstatic u64 __read_mostly efer_reserved_bits = ~((u64)EFER_SCE);\n#endif\n\n#define VM_STAT(x) offsetof(struct kvm, stat.x), KVM_STAT_VM\n#define VCPU_STAT(x) offsetof(struct kvm_vcpu, stat.x), KVM_STAT_VCPU\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstruct kvm_x86_ops *kvm_x86_ops;\nEXPORT_SYMBOL_GPL(kvm_x86_ops);\n\nstatic bool ignore_msrs = 0;\nmodule_param(ignore_msrs, bool, S_IRUGO | S_IWUSR);\n\nbool kvm_has_tsc_control;\nEXPORT_SYMBOL_GPL(kvm_has_tsc_control);\nu32  kvm_max_guest_tsc_khz;\nEXPORT_SYMBOL_GPL(kvm_max_guest_tsc_khz);\n\n/* tsc tolerance in parts per million - default to 1/2 of the NTP threshold */\nstatic u32 tsc_tolerance_ppm = 250;\nmodule_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);\n\n#define KVM_NR_SHARED_MSRS 16\n\nstruct kvm_shared_msrs_global {\n\tint nr;\n\tu32 msrs[KVM_NR_SHARED_MSRS];\n};\n\nstruct kvm_shared_msrs {\n\tstruct user_return_notifier urn;\n\tbool registered;\n\tstruct kvm_shared_msr_values {\n\t\tu64 host;\n\t\tu64 curr;\n\t} values[KVM_NR_SHARED_MSRS];\n};\n\nstatic struct kvm_shared_msrs_global __read_mostly shared_msrs_global;\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\n\nstruct kvm_stats_debugfs_item debugfs_entries[] = {\n\t{ \"pf_fixed\", VCPU_STAT(pf_fixed) },\n\t{ \"pf_guest\", VCPU_STAT(pf_guest) },\n\t{ \"tlb_flush\", VCPU_STAT(tlb_flush) },\n\t{ \"invlpg\", VCPU_STAT(invlpg) },\n\t{ \"exits\", VCPU_STAT(exits) },\n\t{ \"io_exits\", VCPU_STAT(io_exits) },\n\t{ \"mmio_exits\", VCPU_STAT(mmio_exits) },\n\t{ \"signal_exits\", VCPU_STAT(signal_exits) },\n\t{ \"irq_window\", VCPU_STAT(irq_window_exits) },\n\t{ \"nmi_window\", VCPU_STAT(nmi_window_exits) },\n\t{ \"halt_exits\", VCPU_STAT(halt_exits) },\n\t{ \"halt_wakeup\", VCPU_STAT(halt_wakeup) },\n\t{ \"hypercalls\", VCPU_STAT(hypercalls) },\n\t{ \"request_irq\", VCPU_STAT(request_irq_exits) },\n\t{ \"irq_exits\", VCPU_STAT(irq_exits) },\n\t{ \"host_state_reload\", VCPU_STAT(host_state_reload) },\n\t{ \"efer_reload\", VCPU_STAT(efer_reload) },\n\t{ \"fpu_reload\", VCPU_STAT(fpu_reload) },\n\t{ \"insn_emulation\", VCPU_STAT(insn_emulation) },\n\t{ \"insn_emulation_fail\", VCPU_STAT(insn_emulation_fail) },\n\t{ \"irq_injections\", VCPU_STAT(irq_injections) },\n\t{ \"nmi_injections\", VCPU_STAT(nmi_injections) },\n\t{ \"mmu_shadow_zapped\", VM_STAT(mmu_shadow_zapped) },\n\t{ \"mmu_pte_write\", VM_STAT(mmu_pte_write) },\n\t{ \"mmu_pte_updated\", VM_STAT(mmu_pte_updated) },\n\t{ \"mmu_pde_zapped\", VM_STAT(mmu_pde_zapped) },\n\t{ \"mmu_flooded\", VM_STAT(mmu_flooded) },\n\t{ \"mmu_recycled\", VM_STAT(mmu_recycled) },\n\t{ \"mmu_cache_miss\", VM_STAT(mmu_cache_miss) },\n\t{ \"mmu_unsync\", VM_STAT(mmu_unsync) },\n\t{ \"remote_tlb_flush\", VM_STAT(remote_tlb_flush) },\n\t{ \"largepages\", VM_STAT(lpages) },\n\t{ NULL }\n};\n\nu64 __read_mostly host_xcr0;\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}\n\nstatic void kvm_on_user_return(struct user_return_notifier *urn)\n{\n\tunsigned slot;\n\tstruct kvm_shared_msrs *locals\n\t\t= container_of(urn, struct kvm_shared_msrs, urn);\n\tstruct kvm_shared_msr_values *values;\n\n\tfor (slot = 0; slot < shared_msrs_global.nr; ++slot) {\n\t\tvalues = &locals->values[slot];\n\t\tif (values->host != values->curr) {\n\t\t\twrmsrl(shared_msrs_global.msrs[slot], values->host);\n\t\t\tvalues->curr = values->host;\n\t\t}\n\t}\n\tlocals->registered = false;\n\tuser_return_notifier_unregister(urn);\n}\n\nstatic void shared_msr_update(unsigned slot, u32 msr)\n{\n\tu64 value;\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\t/* only read, and nobody should modify it at this time,\n\t * so don't need lock */\n\tif (slot >= shared_msrs_global.nr) {\n\t\tprintk(KERN_ERR \"kvm: invalid MSR slot!\");\n\t\treturn;\n\t}\n\trdmsrl_safe(msr, &value);\n\tsmsr->values[slot].host = value;\n\tsmsr->values[slot].curr = value;\n}\n\nvoid kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n\tshared_msrs_global.msrs[slot] = msr;\n\t/* we need ensured the shared_msr_global have been updated */\n\tsmp_wmb();\n}\nEXPORT_SYMBOL_GPL(kvm_define_shared_msr);\n\nstatic void kvm_shared_msr_cpu_online(void)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < shared_msrs_global.nr; ++i)\n\t\tshared_msr_update(i, shared_msrs_global.msrs[i]);\n}\n\nvoid kvm_set_shared_msr(unsigned slot, u64 value, u64 mask)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\tif (((value ^ smsr->values[slot].curr) & mask) == 0)\n\t\treturn;\n\tsmsr->values[slot].curr = value;\n\twrmsrl(shared_msrs_global.msrs[slot], value);\n\tif (!smsr->registered) {\n\t\tsmsr->urn.on_user_return = kvm_on_user_return;\n\t\tuser_return_notifier_register(&smsr->urn);\n\t\tsmsr->registered = true;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_set_shared_msr);\n\nstatic void drop_user_return_notifiers(void *ignore)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\n\tif (smsr->registered)\n\t\tkvm_on_user_return(&smsr->urn);\n}\n\nu64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}\nEXPORT_SYMBOL_GPL(kvm_get_apic_base);\n\nvoid kvm_set_apic_base(struct kvm_vcpu *vcpu, u64 data)\n{\n\t/* TODO: reserve bits check */\n\tkvm_lapic_set_base(vcpu, data);\n}\nEXPORT_SYMBOL_GPL(kvm_set_apic_base);\n\nasmlinkage void kvm_spurious_fault(void)\n{\n\t/* Fault while not rebooting.  We want the trace. */\n\tBUG();\n}\nEXPORT_SYMBOL_GPL(kvm_spurious_fault);\n\n#define EXCPT_BENIGN\t\t0\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_PF\t\t2\n\nstatic int exception_class(int vector)\n{\n\tswitch (vector) {\n\tcase PF_VECTOR:\n\t\treturn EXCPT_PF;\n\tcase DE_VECTOR:\n\tcase TS_VECTOR:\n\tcase NP_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\t\treturn EXCPT_CONTRIBUTORY;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn EXCPT_BENIGN;\n}\n\nstatic void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception);\n\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true);\n}\nEXPORT_SYMBOL_GPL(kvm_requeue_exception);\n\nvoid kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_complete_insn_gp);\n\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.cr2 = fault->address;\n\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n}\nEXPORT_SYMBOL_GPL(kvm_inject_page_fault);\n\nvoid kvm_propagate_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\tif (mmu_is_nested(vcpu) && !fault->nested_page_fault)\n\t\tvcpu->arch.nested_mmu.inject_page_fault(vcpu, fault);\n\telse\n\t\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n}\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_inject_nmi);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception_e);\n\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, true);\n}\nEXPORT_SYMBOL_GPL(kvm_requeue_exception_e);\n\n/*\n * Checks if cpl <= required_cpl; if true, return true.  Otherwise queue\n * a #GP and return false.\n */\nbool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) <= required_cpl)\n\t\treturn true;\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(kvm_require_cpl);\n\n/*\n * This function will be used to read from the physical memory of the currently\n * running guest. The difference to kvm_read_guest_page is that this function\n * can read from guest physical or from the guest's guest physical memory.\n */\nint kvm_read_guest_page_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gfn_t ngfn, void *data, int offset, int len,\n\t\t\t    u32 access)\n{\n\tgfn_t real_gfn;\n\tgpa_t ngpa;\n\n\tngpa     = gfn_to_gpa(ngfn);\n\treal_gfn = mmu->translate_gpa(vcpu, ngpa, access);\n\tif (real_gfn == UNMAPPED_GVA)\n\t\treturn -EFAULT;\n\n\treal_gfn = gpa_to_gfn(real_gfn);\n\n\treturn kvm_read_guest_page(vcpu->kvm, real_gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_page_mmu);\n\nint kvm_read_nested_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t       void *data, int offset, int len, u32 access)\n{\n\treturn kvm_read_guest_page_mmu(vcpu, vcpu->arch.walk_mmu, gfn,\n\t\t\t\t       data, offset, len, access);\n}\n\n/*\n * Load the pae pdptrs.  Return true is they are all valid.\n */\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif (is_present_gpte(pdpte[i]) &&\n\t\t    (pdpte[i] & vcpu->arch.mmu.rsvd_bits_mask[0][2])) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(VCPU_EXREG_PDPTR,\n\t\t  (unsigned long *)&vcpu->arch.regs_dirty);\nout:\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(load_pdptrs);\n\nstatic bool pdptrs_changed(struct kvm_vcpu *vcpu)\n{\n\tu64 pdpte[ARRAY_SIZE(vcpu->arch.walk_mmu->pdptrs)];\n\tbool changed = true;\n\tint offset;\n\tgfn_t gfn;\n\tint r;\n\n\tif (is_long_mode(vcpu) || !is_pae(vcpu))\n\t\treturn false;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_avail))\n\t\treturn true;\n\n\tgfn = (kvm_read_cr3(vcpu) & ~31u) >> PAGE_SHIFT;\n\toffset = (kvm_read_cr3(vcpu) & ~31u) & (PAGE_SIZE - 1);\n\tr = kvm_read_nested_guest_page(vcpu, gfn, pdpte, offset, sizeof(pdpte),\n\t\t\t\t       PFERR_USER_MASK | PFERR_WRITE_MASK);\n\tif (r < 0)\n\t\tgoto out;\n\tchanged = memcmp(pdpte, vcpu->arch.walk_mmu->pdptrs, sizeof(pdpte)) != 0;\nout:\n\n\treturn changed;\n}\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP |\n\t\t\t\t    X86_CR0_CD | X86_CR0_NW;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr0);\n\nvoid kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)\n{\n\t(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));\n}\nEXPORT_SYMBOL_GPL(kvm_lmsw);\n\nstatic void kvm_load_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE) &&\n\t\t\t!vcpu->guest_xcr0_loaded) {\n\t\t/* kvm_set_xcr() also depends on this */\n\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\t\tvcpu->guest_xcr0_loaded = 1;\n\t}\n}\n\nstatic void kvm_put_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_xcr0_loaded) {\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\t\tvcpu->guest_xcr0_loaded = 0;\n\t}\n}\n\nint __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\txcr0 = xcr;\n\tif (!(xcr0 & XSTATE_FP))\n\t\treturn 1;\n\tif ((xcr0 & XSTATE_YMM) && !(xcr0 & XSTATE_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see fx_init).\n\t */\n\tvalid_bits = vcpu->arch.guest_supported_xcr0 | XSTATE_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tkvm_put_guest_xcr0(vcpu);\n\tvcpu->arch.xcr0 = xcr0;\n\treturn 0;\n}\n\nint kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_xcr);\n\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE |\n\t\t\t\t   X86_CR4_PAE | X86_CR4_SMEP;\n\tif (cr4 & CR4_RESERVED_BITS)\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (cr4 & X86_CR4_OSXSAVE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_FSGSBASE))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has_pcid(vcpu))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops->set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & X86_CR4_OSXSAVE)\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr4);\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_mmu_flush_tlb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE)) {\n\t\t\tif (cr3 & CR3_PCID_ENABLED_RESERVED_BITS)\n\t\t\t\treturn 1;\n\t\t} else\n\t\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\t\treturn 1;\n\t} else {\n\t\tif (is_pae(vcpu)) {\n\t\t\tif (cr3 & CR3_PAE_RESERVED_BITS)\n\t\t\t\treturn 1;\n\t\t\tif (is_paging(vcpu) &&\n\t\t\t    !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\t\t\treturn 1;\n\t\t}\n\t\t/*\n\t\t * We don't check reserved bits in nonpae mode, because\n\t\t * this isn't enforced, and VMware depends on this.\n\t\t */\n\t}\n\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tkvm_mmu_new_cr3(vcpu);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr3);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr8);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}\nEXPORT_SYMBOL_GPL(kvm_get_cr8);\n\nstatic void kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tkvm_x86_ops->set_dr7(vcpu, dr7);\n\tvcpu->arch.switch_db_regs = (dr7 & DR7_BP_EN_MASK);\n}\n\nstatic int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1; /* #UD */\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | DR6_FIXED_1;\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1; /* #UD */\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tint res;\n\n\tres = __kvm_set_dr(vcpu, dr, val);\n\tif (res > 0)\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\telse if (res < 0)\n\t\tkvm_inject_gp(vcpu, 0);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(kvm_set_dr);\n\nstatic int _kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\t\t/* fall through */\n\tcase 6:\n\t\t*val = vcpu->arch.dr6;\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tif (_kvm_get_dr(vcpu, dr, val)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_get_dr);\n\nbool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tu64 data;\n\tint err;\n\n\terr = kvm_pmu_read_pmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, (u32)data);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, data >> 32);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(kvm_rdpmc);\n\n/*\n * List of msr numbers which we expose to userspace through KVM_GET_MSRS\n * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.\n *\n * This list is modified at module load time to reflect the\n * capabilities of the host cpu. This capabilities test skips MSRs that are\n * kvm-specific. Those are put in the beginning of the list.\n */\n\n#define KVM_SAVE_MSRS_BEGIN\t10\nstatic u32 msrs_to_save[] = {\n\tMSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,\n\tMSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,\n\tHV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,\n\tHV_X64_MSR_APIC_ASSIST_PAGE, MSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,\n\tMSR_KVM_PV_EOI_EN,\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_STAR,\n#ifdef CONFIG_X86_64\n\tMSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,\n#endif\n\tMSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,\n\tMSR_IA32_FEATURE_CONTROL\n};\n\nstatic unsigned num_msrs_to_save;\n\nstatic const u32 emulated_msrs[] = {\n\tMSR_IA32_TSC_ADJUST,\n\tMSR_IA32_TSCDEADLINE,\n\tMSR_IA32_MISC_ENABLE,\n\tMSR_IA32_MCG_STATUS,\n\tMSR_IA32_MCG_CTL,\n};\n\nbool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & efer_reserved_bits)\n\t\treturn false;\n\n\tif (efer & EFER_FFXSR) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->edx & bit(X86_FEATURE_FXSR_OPT)))\n\t\t\treturn false;\n\t}\n\n\tif (efer & EFER_SVME) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->ecx & bit(X86_FEATURE_SVM)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(kvm_valid_efer);\n\nstatic int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\n\tif (!kvm_valid_efer(vcpu, efer))\n\t\treturn 1;\n\n\tif (is_paging(vcpu)\n\t    && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\treturn 1;\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tkvm_x86_ops->set_efer(vcpu, efer);\n\n\t/* Update reserved bits */\n\tif ((efer ^ old_efer) & EFER_NX)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}\n\nvoid kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}\nEXPORT_SYMBOL_GPL(kvm_enable_efer_bits);\n\n\n/*\n * Writes msr value into into the appropriate \"register\".\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nint kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\treturn kvm_x86_ops->set_msr(vcpu, msr);\n}\n\n/*\n * Adapt set_msr() to msr_io()'s calling convention\n */\nstatic int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\tstruct msr_data msr;\n\n\tmsr.data = *data;\n\tmsr.index = index;\n\tmsr.host_initiated = true;\n\treturn kvm_set_msr(vcpu, &msr);\n}\n\n#ifdef CONFIG_X86_64\nstruct pvclock_gtod_data {\n\tseqcount_t\tseq;\n\n\tstruct { /* extract of a clocksource struct */\n\t\tint vclock_mode;\n\t\tcycle_t\tcycle_last;\n\t\tcycle_t\tmask;\n\t\tu32\tmult;\n\t\tu32\tshift;\n\t} clock;\n\n\t/* open coded 'struct timespec' */\n\tu64\t\tmonotonic_time_snsec;\n\ttime_t\t\tmonotonic_time_sec;\n};\n\nstatic struct pvclock_gtod_data pvclock_gtod_data;\n\nstatic void update_pvclock_gtod(struct timekeeper *tk)\n{\n\tstruct pvclock_gtod_data *vdata = &pvclock_gtod_data;\n\n\twrite_seqcount_begin(&vdata->seq);\n\n\t/* copy pvclock gtod data */\n\tvdata->clock.vclock_mode\t= tk->clock->archdata.vclock_mode;\n\tvdata->clock.cycle_last\t\t= tk->clock->cycle_last;\n\tvdata->clock.mask\t\t= tk->clock->mask;\n\tvdata->clock.mult\t\t= tk->mult;\n\tvdata->clock.shift\t\t= tk->shift;\n\n\tvdata->monotonic_time_sec\t= tk->xtime_sec\n\t\t\t\t\t+ tk->wall_to_monotonic.tv_sec;\n\tvdata->monotonic_time_snsec\t= tk->xtime_nsec\n\t\t\t\t\t+ (tk->wall_to_monotonic.tv_nsec\n\t\t\t\t\t\t<< tk->shift);\n\twhile (vdata->monotonic_time_snsec >=\n\t\t\t\t\t(((u64)NSEC_PER_SEC) << tk->shift)) {\n\t\tvdata->monotonic_time_snsec -=\n\t\t\t\t\t((u64)NSEC_PER_SEC) << tk->shift;\n\t\tvdata->monotonic_time_sec++;\n\t}\n\n\twrite_seqcount_end(&vdata->seq);\n}\n#endif\n\n\nstatic void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock)\n{\n\tint version;\n\tint r;\n\tstruct pvclock_wall_clock wc;\n\tstruct timespec boot;\n\n\tif (!wall_clock)\n\t\treturn;\n\n\tr = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));\n\tif (r)\n\t\treturn;\n\n\tif (version & 1)\n\t\t++version;  /* first time write, random junk */\n\n\t++version;\n\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n\n\t/*\n\t * The guest calculates current wall clock time by adding\n\t * system time (updated by kvm_guest_time_update below) to the\n\t * wall clock specified here.  guest system time equals host\n\t * system time for us, thus we must fill in host boot time here.\n\t */\n\tgetboottime(&boot);\n\n\tif (kvm->arch.kvmclock_offset) {\n\t\tstruct timespec ts = ns_to_timespec(kvm->arch.kvmclock_offset);\n\t\tboot = timespec_sub(boot, ts);\n\t}\n\twc.sec = boot.tv_sec;\n\twc.nsec = boot.tv_nsec;\n\twc.version = version;\n\n\tkvm_write_guest(kvm, wall_clock, &wc, sizeof(wc));\n\n\tversion++;\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n}\n\nstatic uint32_t div_frac(uint32_t dividend, uint32_t divisor)\n{\n\tuint32_t quotient, remainder;\n\n\t/* Don't try to replace with do_div(), this one calculates\n\t * \"(dividend << 32) / divisor\" */\n\t__asm__ ( \"divl %4\"\n\t\t  : \"=a\" (quotient), \"=d\" (remainder)\n\t\t  : \"0\" (0), \"1\" (dividend), \"r\" (divisor) );\n\treturn quotient;\n}\n\nstatic void kvm_get_time_scale(uint32_t scaled_khz, uint32_t base_khz,\n\t\t\t       s8 *pshift, u32 *pmultiplier)\n{\n\tuint64_t scaled64;\n\tint32_t  shift = 0;\n\tuint64_t tps64;\n\tuint32_t tps32;\n\n\ttps64 = base_khz * 1000LL;\n\tscaled64 = scaled_khz * 1000LL;\n\twhile (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {\n\t\ttps64 >>= 1;\n\t\tshift--;\n\t}\n\n\ttps32 = (uint32_t)tps64;\n\twhile (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {\n\t\tif (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)\n\t\t\tscaled64 >>= 1;\n\t\telse\n\t\t\ttps32 <<= 1;\n\t\tshift++;\n\t}\n\n\t*pshift = shift;\n\t*pmultiplier = div_frac(scaled64, tps32);\n\n\tpr_debug(\"%s: base_khz %u => %u, shift %d, mul %u\\n\",\n\t\t __func__, base_khz, scaled_khz, shift, *pmultiplier);\n}\n\nstatic inline u64 get_kernel_ns(void)\n{\n\tstruct timespec ts;\n\n\tWARN_ON(preemptible());\n\tktime_get_ts(&ts);\n\tmonotonic_to_bootbased(&ts);\n\treturn timespec_to_ns(&ts);\n}\n\n#ifdef CONFIG_X86_64\nstatic atomic_t kvm_guest_has_master_clock = ATOMIC_INIT(0);\n#endif\n\nstatic DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);\nunsigned long max_tsc_khz;\n\nstatic inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}\n\nstatic u32 adjust_tsc_khz(u32 khz, s32 ppm)\n{\n\tu64 v = (u64)khz * (1000000 + ppm);\n\tdo_div(v, 1000000);\n\treturn v;\n}\n\nstatic void kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 this_tsc_khz)\n{\n\tu32 thresh_lo, thresh_hi;\n\tint use_scaling = 0;\n\n\t/* tsc_khz can be zero if TSC calibration fails */\n\tif (this_tsc_khz == 0)\n\t\treturn;\n\n\t/* Compute a scale to convert nanoseconds in TSC cycles */\n\tkvm_get_time_scale(this_tsc_khz, NSEC_PER_SEC / 1000,\n\t\t\t   &vcpu->arch.virtual_tsc_shift,\n\t\t\t   &vcpu->arch.virtual_tsc_mult);\n\tvcpu->arch.virtual_tsc_khz = this_tsc_khz;\n\n\t/*\n\t * Compute the variation in TSC rate which is acceptable\n\t * within the range of tolerance and decide if the\n\t * rate being applied is within that bounds of the hardware\n\t * rate.  If so, no scaling or compensation need be done.\n\t */\n\tthresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);\n\tthresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);\n\tif (this_tsc_khz < thresh_lo || this_tsc_khz > thresh_hi) {\n\t\tpr_debug(\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\", this_tsc_khz, thresh_lo, thresh_hi);\n\t\tuse_scaling = 1;\n\t}\n\tkvm_x86_ops->set_tsc_khz(vcpu, this_tsc_khz, use_scaling);\n}\n\nstatic u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)\n{\n\tu64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,\n\t\t\t\t      vcpu->arch.virtual_tsc_mult,\n\t\t\t\t      vcpu->arch.virtual_tsc_shift);\n\ttsc += vcpu->arch.this_tsc_write;\n\treturn tsc;\n}\n\nvoid kvm_track_tsc_matching(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\tbool vcpus_matched;\n\tbool do_request = false;\n\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\t atomic_read(&vcpu->kvm->online_vcpus));\n\n\tif (vcpus_matched && gtod->clock.vclock_mode == VCLOCK_TSC)\n\t\tif (!ka->use_master_clock)\n\t\t\tdo_request = 1;\n\n\tif (!vcpus_matched && ka->use_master_clock)\n\t\t\tdo_request = 1;\n\n\tif (do_request)\n\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\ttrace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,\n\t\t\t    atomic_read(&vcpu->kvm->online_vcpus),\n\t\t            ka->use_master_clock, gtod->clock.vclock_mode);\n#endif\n}\n\nstatic void update_ia32_tsc_adjust_msr(struct kvm_vcpu *vcpu, s64 offset)\n{\n\tu64 curr_offset = kvm_x86_ops->read_tsc_offset(vcpu);\n\tvcpu->arch.ia32_tsc_adjust_msr += offset - curr_offset;\n}\n\nvoid kvm_write_tsc(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tu64 offset, ns, elapsed;\n\tunsigned long flags;\n\ts64 usdiff;\n\tbool matched;\n\tu64 data = msr->data;\n\n\traw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);\n\toffset = kvm_x86_ops->compute_tsc_offset(vcpu, data);\n\tns = get_kernel_ns();\n\telapsed = ns - kvm->arch.last_tsc_nsec;\n\n\tif (vcpu->arch.virtual_tsc_khz) {\n\t\tint faulted = 0;\n\n\t\t/* n.b - signed multiplication and division required */\n\t\tusdiff = data - kvm->arch.last_tsc_write;\n#ifdef CONFIG_X86_64\n\t\tusdiff = (usdiff * 1000) / vcpu->arch.virtual_tsc_khz;\n#else\n\t\t/* do_div() only does unsigned */\n\t\tasm(\"1: idivl %[divisor]\\n\"\n\t\t    \"2: xor %%edx, %%edx\\n\"\n\t\t    \"   movl $0, %[faulted]\\n\"\n\t\t    \"3:\\n\"\n\t\t    \".section .fixup,\\\"ax\\\"\\n\"\n\t\t    \"4: movl $1, %[faulted]\\n\"\n\t\t    \"   jmp  3b\\n\"\n\t\t    \".previous\\n\"\n\n\t\t_ASM_EXTABLE(1b, 4b)\n\n\t\t: \"=A\"(usdiff), [faulted] \"=r\" (faulted)\n\t\t: \"A\"(usdiff * 1000), [divisor] \"rm\"(vcpu->arch.virtual_tsc_khz));\n\n#endif\n\t\tdo_div(elapsed, 1000);\n\t\tusdiff -= elapsed;\n\t\tif (usdiff < 0)\n\t\t\tusdiff = -usdiff;\n\n\t\t/* idivl overflow => difference is larger than USEC_PER_SEC */\n\t\tif (faulted)\n\t\t\tusdiff = USEC_PER_SEC;\n\t} else\n\t\tusdiff = USEC_PER_SEC; /* disable TSC match window below */\n\n\t/*\n\t * Special case: TSC write with a small delta (1 second) of virtual\n\t * cycle time against real time is interpreted as an attempt to\n\t * synchronize the CPU.\n         *\n\t * For a reliable TSC, we can match TSC offsets, and for an unstable\n\t * TSC, we add elapsed time in this computation.  We could let the\n\t * compensation code attempt to catch up if we fall behind, but\n\t * it's better to try to match offsets from the beginning.\n         */\n\tif (usdiff < USEC_PER_SEC &&\n\t    vcpu->arch.virtual_tsc_khz == kvm->arch.last_tsc_khz) {\n\t\tif (!check_tsc_unstable()) {\n\t\t\toffset = kvm->arch.cur_tsc_offset;\n\t\t\tpr_debug(\"kvm: matched tsc offset for %llu\\n\", data);\n\t\t} else {\n\t\t\tu64 delta = nsec_to_cycles(vcpu, elapsed);\n\t\t\tdata += delta;\n\t\t\toffset = kvm_x86_ops->compute_tsc_offset(vcpu, data);\n\t\t\tpr_debug(\"kvm: adjusted tsc offset by %llu\\n\", delta);\n\t\t}\n\t\tmatched = true;\n\t} else {\n\t\t/*\n\t\t * We split periods of matched TSC writes into generations.\n\t\t * For each generation, we track the original measured\n\t\t * nanosecond time, offset, and write, so if TSCs are in\n\t\t * sync, we can match exact offset, and if not, we can match\n\t\t * exact software computation in compute_guest_tsc()\n\t\t *\n\t\t * These values are tracked in kvm->arch.cur_xxx variables.\n\t\t */\n\t\tkvm->arch.cur_tsc_generation++;\n\t\tkvm->arch.cur_tsc_nsec = ns;\n\t\tkvm->arch.cur_tsc_write = data;\n\t\tkvm->arch.cur_tsc_offset = offset;\n\t\tmatched = false;\n\t\tpr_debug(\"kvm: new tsc generation %u, clock %llu\\n\",\n\t\t\t kvm->arch.cur_tsc_generation, data);\n\t}\n\n\t/*\n\t * We also track th most recent recorded KHZ, write and time to\n\t * allow the matching interval to be extended at each write.\n\t */\n\tkvm->arch.last_tsc_nsec = ns;\n\tkvm->arch.last_tsc_write = data;\n\tkvm->arch.last_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\n\t/* Reset of TSC must disable overshoot protection below */\n\tvcpu->arch.hv_clock.tsc_timestamp = 0;\n\tvcpu->arch.last_guest_tsc = data;\n\n\t/* Keep track of which generation this VCPU has synchronized to */\n\tvcpu->arch.this_tsc_generation = kvm->arch.cur_tsc_generation;\n\tvcpu->arch.this_tsc_nsec = kvm->arch.cur_tsc_nsec;\n\tvcpu->arch.this_tsc_write = kvm->arch.cur_tsc_write;\n\n\tif (guest_cpuid_has_tsc_adjust(vcpu) && !msr->host_initiated)\n\t\tupdate_ia32_tsc_adjust_msr(vcpu, offset);\n\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\traw_spin_unlock_irqrestore(&kvm->arch.tsc_write_lock, flags);\n\n\tspin_lock(&kvm->arch.pvclock_gtod_sync_lock);\n\tif (matched)\n\t\tkvm->arch.nr_vcpus_matched_tsc++;\n\telse\n\t\tkvm->arch.nr_vcpus_matched_tsc = 0;\n\n\tkvm_track_tsc_matching(vcpu);\n\tspin_unlock(&kvm->arch.pvclock_gtod_sync_lock);\n}\n\nEXPORT_SYMBOL_GPL(kvm_write_tsc);\n\n#ifdef CONFIG_X86_64\n\nstatic cycle_t read_tsc(void)\n{\n\tcycle_t ret;\n\tu64 last;\n\n\t/*\n\t * Empirically, a fence (of type that depends on the CPU)\n\t * before rdtsc is enough to ensure that rdtsc is ordered\n\t * with respect to loads.  The various CPU manuals are unclear\n\t * as to whether rdtsc can be reordered with later loads,\n\t * but no one has ever seen it happen.\n\t */\n\trdtsc_barrier();\n\tret = (cycle_t)vget_cycles();\n\n\tlast = pvclock_gtod_data.clock.cycle_last;\n\n\tif (likely(ret >= last))\n\t\treturn ret;\n\n\t/*\n\t * GCC likes to generate cmov here, but this branch is extremely\n\t * predictable (it's just a funciton of time and the likely is\n\t * very likely) and there's a data dependence, so force GCC\n\t * to generate a branch instead.  I don't barrier() because\n\t * we don't actually need a barrier, and if this function\n\t * ever gets inlined it will generate worse code.\n\t */\n\tasm volatile (\"\");\n\treturn last;\n}\n\nstatic inline u64 vgettsc(cycle_t *cycle_now)\n{\n\tlong v;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\t*cycle_now = read_tsc();\n\n\tv = (*cycle_now - gtod->clock.cycle_last) & gtod->clock.mask;\n\treturn v * gtod->clock.mult;\n}\n\nstatic int do_monotonic(struct timespec *ts, cycle_t *cycle_now)\n{\n\tunsigned long seq;\n\tu64 ns;\n\tint mode;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tts->tv_nsec = 0;\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tmode = gtod->clock.vclock_mode;\n\t\tts->tv_sec = gtod->monotonic_time_sec;\n\t\tns = gtod->monotonic_time_snsec;\n\t\tns += vgettsc(cycle_now);\n\t\tns >>= gtod->clock.shift;\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\ttimespec_add_ns(ts, ns);\n\n\treturn mode;\n}\n\n/* returns true if host is using tsc clocksource */\nstatic bool kvm_get_time_and_clockread(s64 *kernel_ns, cycle_t *cycle_now)\n{\n\tstruct timespec ts;\n\n\t/* checked again under seqlock below */\n\tif (pvclock_gtod_data.clock.vclock_mode != VCLOCK_TSC)\n\t\treturn false;\n\n\tif (do_monotonic(&ts, cycle_now) != VCLOCK_TSC)\n\t\treturn false;\n\n\tmonotonic_to_bootbased(&ts);\n\t*kernel_ns = timespec_to_ns(&ts);\n\n\treturn true;\n}\n#endif\n\n/*\n *\n * Assuming a stable TSC across physical CPUS, and a stable TSC\n * across virtual CPUs, the following condition is possible.\n * Each numbered line represents an event visible to both\n * CPUs at the next numbered event.\n *\n * \"timespecX\" represents host monotonic time. \"tscX\" represents\n * RDTSC value.\n *\n * \t\tVCPU0 on CPU0\t\t|\tVCPU1 on CPU1\n *\n * 1.  read timespec0,tsc0\n * 2.\t\t\t\t\t| timespec1 = timespec0 + N\n * \t\t\t\t\t| tsc1 = tsc0 + M\n * 3. transition to guest\t\t| transition to guest\n * 4. ret0 = timespec0 + (rdtsc - tsc0) |\n * 5.\t\t\t\t        | ret1 = timespec1 + (rdtsc - tsc1)\n * \t\t\t\t        | ret1 = timespec0 + N + (rdtsc - (tsc0 + M))\n *\n * Since ret0 update is visible to VCPU1 at time 5, to obey monotonicity:\n *\n * \t- ret0 < ret1\n *\t- timespec0 + (rdtsc - tsc0) < timespec0 + N + (rdtsc - (tsc0 + M))\n *\t\t...\n *\t- 0 < N - M => M < N\n *\n * That is, when timespec0 != timespec1, M < N. Unfortunately that is not\n * always the case (the difference between two distinct xtime instances\n * might be smaller then the difference between corresponding TSC reads,\n * when updating guest vcpus pvclock areas).\n *\n * To avoid that problem, do not allow visibility of distinct\n * system_timestamp/tsc_timestamp values simultaneously: use a master\n * copy of host monotonic time values. Update that master copy\n * in lockstep.\n *\n * Rely on synchronization of host TSCs and guest TSCs for monotonicity.\n *\n */\n\nstatic void pvclock_update_vm_gtod_copy(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tstruct kvm_arch *ka = &kvm->arch;\n\tint vclock_mode;\n\tbool host_tsc_clocksource, vcpus_matched;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\tatomic_read(&kvm->online_vcpus));\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\thost_tsc_clocksource = kvm_get_time_and_clockread(\n\t\t\t\t\t&ka->master_kernel_ns,\n\t\t\t\t\t&ka->master_cycle_now);\n\n\tka->use_master_clock = host_tsc_clocksource & vcpus_matched;\n\n\tif (ka->use_master_clock)\n\t\tatomic_set(&kvm_guest_has_master_clock, 1);\n\n\tvclock_mode = pvclock_gtod_data.clock.vclock_mode;\n\ttrace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,\n\t\t\t\t\tvcpus_matched);\n#endif\n}\n\nstatic void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\t/* no guest entries from this point */\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\n\t/* guest entries allowed */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}\n\nstatic int kvm_guest_time_update(struct kvm_vcpu *v)\n{\n\tunsigned long flags, this_tsc_khz;\n\tstruct kvm_vcpu_arch *vcpu = &v->arch;\n\tstruct kvm_arch *ka = &v->kvm->arch;\n\ts64 kernel_ns, max_kernel_ns;\n\tu64 tsc_timestamp, host_tsc;\n\tstruct pvclock_vcpu_time_info guest_hv_clock;\n\tu8 pvclock_flags;\n\tbool use_master_clock;\n\n\tkernel_ns = 0;\n\thost_tsc = 0;\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tuse_master_clock = ka->use_master_clock;\n\tif (use_master_clock) {\n\t\thost_tsc = ka->master_cycle_now;\n\t\tkernel_ns = ka->master_kernel_ns;\n\t}\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n\n\t/* Keep irq disabled to prevent changes to the clock */\n\tlocal_irq_save(flags);\n\tthis_tsc_khz = __get_cpu_var(cpu_tsc_khz);\n\tif (unlikely(this_tsc_khz == 0)) {\n\t\tlocal_irq_restore(flags);\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\t\treturn 1;\n\t}\n\tif (!use_master_clock) {\n\t\thost_tsc = native_read_tsc();\n\t\tkernel_ns = get_kernel_ns();\n\t}\n\n\ttsc_timestamp = kvm_x86_ops->read_l1_tsc(v, host_tsc);\n\n\t/*\n\t * We may have to catch up the TSC to match elapsed wall clock\n\t * time for two reasons, even if kvmclock is used.\n\t *   1) CPU could have been running below the maximum TSC rate\n\t *   2) Broken TSC compensation resets the base at each VCPU\n\t *      entry to avoid unknown leaps of TSC even when running\n\t *      again on the same CPU.  This may cause apparent elapsed\n\t *      time to disappear, and the guest to stand still or run\n\t *\tvery slowly.\n\t */\n\tif (vcpu->tsc_catchup) {\n\t\tu64 tsc = compute_guest_tsc(v, kernel_ns);\n\t\tif (tsc > tsc_timestamp) {\n\t\t\tadjust_tsc_offset_guest(v, tsc - tsc_timestamp);\n\t\t\ttsc_timestamp = tsc;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\tif (!vcpu->pv_time_enabled)\n\t\treturn 0;\n\n\t/*\n\t * Time as measured by the TSC may go backwards when resetting the base\n\t * tsc_timestamp.  The reason for this is that the TSC resolution is\n\t * higher than the resolution of the other clock scales.  Thus, many\n\t * possible measurments of the TSC correspond to one measurement of any\n\t * other clock, and so a spread of values is possible.  This is not a\n\t * problem for the computation of the nanosecond clock; with TSC rates\n\t * around 1GHZ, there can only be a few cycles which correspond to one\n\t * nanosecond value, and any path through this code will inevitably\n\t * take longer than that.  However, with the kernel_ns value itself,\n\t * the precision may be much lower, down to HZ granularity.  If the\n\t * first sampling of TSC against kernel_ns ends in the low part of the\n\t * range, and the second in the high end of the range, we can get:\n\t *\n\t * (TSC - offset_low) * S + kns_old > (TSC - offset_high) * S + kns_new\n\t *\n\t * As the sampling errors potentially range in the thousands of cycles,\n\t * it is possible such a time value has already been observed by the\n\t * guest.  To protect against this, we must compute the system time as\n\t * observed by the guest and ensure the new system time is greater.\n\t */\n\tmax_kernel_ns = 0;\n\tif (vcpu->hv_clock.tsc_timestamp) {\n\t\tmax_kernel_ns = vcpu->last_guest_tsc -\n\t\t\t\tvcpu->hv_clock.tsc_timestamp;\n\t\tmax_kernel_ns = pvclock_scale_delta(max_kernel_ns,\n\t\t\t\t    vcpu->hv_clock.tsc_to_system_mul,\n\t\t\t\t    vcpu->hv_clock.tsc_shift);\n\t\tmax_kernel_ns += vcpu->last_kernel_ns;\n\t}\n\n\tif (unlikely(vcpu->hw_tsc_khz != this_tsc_khz)) {\n\t\tkvm_get_time_scale(NSEC_PER_SEC / 1000, this_tsc_khz,\n\t\t\t\t   &vcpu->hv_clock.tsc_shift,\n\t\t\t\t   &vcpu->hv_clock.tsc_to_system_mul);\n\t\tvcpu->hw_tsc_khz = this_tsc_khz;\n\t}\n\n\t/* with a master <monotonic time, tsc value> tuple,\n\t * pvclock clock reads always increase at the (scaled) rate\n\t * of guest TSC - no need to deal with sampling errors.\n\t */\n\tif (!use_master_clock) {\n\t\tif (max_kernel_ns > kernel_ns)\n\t\t\tkernel_ns = max_kernel_ns;\n\t}\n\t/* With all the info we got, fill in the values */\n\tvcpu->hv_clock.tsc_timestamp = tsc_timestamp;\n\tvcpu->hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;\n\tvcpu->last_kernel_ns = kernel_ns;\n\tvcpu->last_guest_tsc = tsc_timestamp;\n\n\t/*\n\t * The interface expects us to write an even number signaling that the\n\t * update is finished. Since the guest won't see the intermediate\n\t * state, we just increase by 2 at the end.\n\t */\n\tvcpu->hv_clock.version += 2;\n\n\tif (unlikely(kvm_read_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t&guest_hv_clock, sizeof(guest_hv_clock))))\n\t\treturn 0;\n\n\t/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */\n\tpvclock_flags = (guest_hv_clock.flags & PVCLOCK_GUEST_STOPPED);\n\n\tif (vcpu->pvclock_set_guest_stopped_request) {\n\t\tpvclock_flags |= PVCLOCK_GUEST_STOPPED;\n\t\tvcpu->pvclock_set_guest_stopped_request = false;\n\t}\n\n\t/* If the host uses TSC clocksource, then it is stable */\n\tif (use_master_clock)\n\t\tpvclock_flags |= PVCLOCK_TSC_STABLE_BIT;\n\n\tvcpu->hv_clock.flags = pvclock_flags;\n\n\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n\t\t\t\t&vcpu->hv_clock,\n\t\t\t\tsizeof(vcpu->hv_clock));\n\treturn 0;\n}\n\n/*\n * kvmclock updates which are isolated to a given vcpu, such as\n * vcpu->cpu migration, should not allow system_timestamp from\n * the rest of the vcpus to remain static. Otherwise ntp frequency\n * correction applies to one vcpu's system_timestamp but not\n * the others.\n *\n * So in those cases, request a kvmclock update for all vcpus.\n * The worst case for a remote vcpu to update its kvmclock\n * is then bounded by maximum nohz sleep latency.\n */\n\nstatic void kvm_gen_kvmclock_update(struct kvm_vcpu *v)\n{\n\tint i;\n\tstruct kvm *kvm = v->kvm;\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t\tkvm_vcpu_kick(vcpu);\n\t}\n}\n\nstatic bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool valid_pat_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0xf3; /* 0, 1, 4, 5, 6, 7 */\n}\n\nstatic bool valid_mtrr_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0x73; /* 0, 1, 4, 5, 6 */\n}\n\nstatic bool mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint i;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn false;\n\n\tif (msr == MSR_IA32_CR_PAT) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tif (!valid_pat_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tif (data & ~0xcff)\n\t\t\treturn false;\n\t\treturn valid_mtrr_type(data & 0xff);\n\t} else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {\n\t\tfor (i = 0; i < 8 ; i++)\n\t\t\tif (!valid_mtrr_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/* variable MTRRs */\n\treturn valid_mtrr_type(data & 0xff);\n}\n\nstatic int set_msr_mtrr(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;\n\n\tif (!mtrr_valid(vcpu, msr, data))\n\t\treturn 1;\n\n\tif (msr == MSR_MTRRdefType) {\n\t\tvcpu->arch.mtrr_state.def_type = data;\n\t\tvcpu->arch.mtrr_state.enabled = (data & 0xc00) >> 10;\n\t} else if (msr == MSR_MTRRfix64K_00000)\n\t\tp[0] = data;\n\telse if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)\n\t\tp[1 + msr - MSR_MTRRfix16K_80000] = data;\n\telse if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)\n\t\tp[3 + msr - MSR_MTRRfix4K_C0000] = data;\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\tvcpu->arch.pat = data;\n\telse {\t/* Variable MTRRs */\n\t\tint idx, is_mtrr_mask;\n\t\tu64 *pt;\n\n\t\tidx = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * idx;\n\t\tif (!is_mtrr_mask)\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;\n\t\telse\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;\n\t\t*pt = data;\n\t}\n\n\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}\n\nstatic int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MC0_CTL + 4 * bank_num) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\t/* only 0 or all 1s can be written to IA32_MCi_CTL\n\t\t\t * some Linux kernels though clear bit 10 in bank 4 to\n\t\t\t * workaround a BIOS/GART TBL issue on AMD K8s, ignore\n\t\t\t * this to avoid an uncatched #GP in the guest\n\t\t\t */\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int xen_hvm_config(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tint lm = is_long_mode(vcpu);\n\tu8 *blob_addr = lm ? (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_64\n\t\t: (u8 *)(long)kvm->arch.xen_hvm_config.blob_addr_32;\n\tu8 blob_size = lm ? kvm->arch.xen_hvm_config.blob_size_64\n\t\t: kvm->arch.xen_hvm_config.blob_size_32;\n\tu32 page_num = data & ~PAGE_MASK;\n\tu64 page_addr = data & PAGE_MASK;\n\tu8 *page;\n\tint r;\n\n\tr = -E2BIG;\n\tif (page_num >= blob_size)\n\t\tgoto out;\n\tr = -ENOMEM;\n\tpage = memdup_user(blob_addr + (page_num * PAGE_SIZE), PAGE_SIZE);\n\tif (IS_ERR(page)) {\n\t\tr = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\tif (kvm_write_guest(kvm, page_addr, page, PAGE_SIZE))\n\t\tgoto out_free;\n\tr = 0;\nout_free:\n\tkfree(page);\nout:\n\treturn r;\n}\n\nstatic bool kvm_hv_hypercall_enabled(struct kvm *kvm)\n{\n\treturn kvm->arch.hv_hypercall & HV_X64_MSR_HYPERCALL_ENABLE;\n}\n\nstatic bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic int set_msr_hyperv_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tkvm->arch.hv_guest_os_id = data;\n\t\t/* setting guest os id to zero disables hypercall page */\n\t\tif (!kvm->arch.hv_guest_os_id)\n\t\t\tkvm->arch.hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\n\t\t/* if guest os id is not set hypercall should remain disabled */\n\t\tif (!kvm->arch.hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\tkvm->arch.hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops->patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; /* ret */\n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\tkvm->arch.hv_hypercall = data;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"HYPER-V unimplemented wrmsr: 0x%x \"\n\t\t\t    \"data 0x%llx\\n\", msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int set_msr_hyperv(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tswitch (msr) {\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE: {\n\t\tunsigned long addr;\n\n\t\tif (!(data & HV_X64_MSR_APIC_ASSIST_PAGE_ENABLE)) {\n\t\t\tvcpu->arch.hv_vapic = data;\n\t\t\tbreak;\n\t\t}\n\t\taddr = gfn_to_hva(vcpu->kvm, data >>\n\t\t\t\t  HV_X64_MSR_APIC_ASSIST_PAGE_ADDRESS_SHIFT);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tif (__clear_user((void __user *)addr, PAGE_SIZE))\n\t\t\treturn 1;\n\t\tvcpu->arch.hv_vapic = data;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data);\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"HYPER-V unimplemented wrmsr: 0x%x \"\n\t\t\t    \"data 0x%llx\\n\", msr, data);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)\n{\n\tgpa_t gpa = data & ~0x3f;\n\n\t/* Bits 2:5 are reserved, Should be zero */\n\tif (data & 0x3c)\n\t\treturn 1;\n\n\tvcpu->arch.apf.msr_val = data;\n\n\tif (!(data & KVM_ASYNC_PF_ENABLED)) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,\n\t\t\t\t\tsizeof(u32)))\n\t\treturn 1;\n\n\tvcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);\n\tkvm_async_pf_wakeup_all(vcpu);\n\treturn 0;\n}\n\nstatic void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}\n\nstatic void accumulate_steal_time(struct kvm_vcpu *vcpu)\n{\n\tu64 delta;\n\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tdelta = current->sched_info.run_delay - vcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\tvcpu->arch.st.accum_steal = delta;\n}\n\nstatic void record_steal_time(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tif (unlikely(kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time))))\n\t\treturn;\n\n\tvcpu->arch.st.steal.steal += vcpu->arch.st.accum_steal;\n\tvcpu->arch.st.steal.version += 2;\n\tvcpu->arch.st.accum_steal = 0;\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));\n}\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn set_msr_mtrr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\tkvm_set_apic_base(vcpu, data);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\tu64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tkvm_x86_ops->adjust_tsc_offset(vcpu, adj, true);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tu64 gpa_offset;\n\t\tkvmclock_reset(vcpu);\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = false;\n\t\telse\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS,\n\t\t\t\t\t\tsizeof(struct kvm_steal_time)))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\n\t\tpreempt_disable();\n\t\taccumulate_steal_time(vcpu);\n\t\tpreempt_enable();\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\t/* Performance counters are not protected by a CPUID bit,\n\t * so we should check all of them in the generic path for the sake of\n\t * cross vendor migration.\n\t * Writing a zero into the event select MSRs disables them,\n\t * which we perfectly emulate ;-). Any other value should be at least\n\t * reported, some guests depend on them.\n\t */\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_EVNTSEL1:\n\tcase MSR_K7_EVNTSEL2:\n\tcase MSR_K7_EVNTSEL3:\n\t\tif (data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\t/* at least RHEL 4 unconditionally writes to the perfctr registers,\n\t * so we ignore writes to make it happy.\n\t */\n\tcase MSR_K7_PERFCTR0:\n\tcase MSR_K7_PERFCTR1:\n\tcase MSR_K7_PERFCTR2:\n\tcase MSR_K7_PERFCTR3:\n\t\tvcpu_unimpl(vcpu, \"unimplemented perfctr wrmsr: \"\n\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\t\tpr = true;\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\t\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\t\tint r;\n\t\t\tmutex_lock(&vcpu->kvm->lock);\n\t\t\tr = set_msr_hyperv_pw(vcpu, msr, data);\n\t\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\t\treturn r;\n\t\t} else\n\t\t\treturn set_msr_hyperv(vcpu, msr, data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_msr_common);\n\n\n/*\n * Reads an msr value (of 'msr_index') into 'pdata'.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nint kvm_get_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata)\n{\n\treturn kvm_x86_ops->get_msr(vcpu, msr_index, pdata);\n}\n\nstatic int get_msr_mtrr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn 1;\n\n\tif (msr == MSR_MTRRdefType)\n\t\t*pdata = vcpu->arch.mtrr_state.def_type +\n\t\t\t (vcpu->arch.mtrr_state.enabled << 10);\n\telse if (msr == MSR_MTRRfix64K_00000)\n\t\t*pdata = p[0];\n\telse if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)\n\t\t*pdata = p[1 + msr - MSR_MTRRfix16K_80000];\n\telse if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)\n\t\t*pdata = p[3 + msr - MSR_MTRRfix4K_C0000];\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\t*pdata = vcpu->arch.pat;\n\telse {\t/* Variable MTRRs */\n\t\tint idx, is_mtrr_mask;\n\t\tu64 *pt;\n\n\t\tidx = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * idx;\n\t\tif (!is_mtrr_mask)\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;\n\t\telse\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;\n\t\t*pdata = *pt;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MC0_CTL + 4 * bank_num) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\n\nstatic int get_msr_hyperv_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = kvm->arch.hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = kvm->arch.hv_hypercall;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}\n\nstatic int get_msr_hyperv(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX: {\n\t\tint r;\n\t\tstruct kvm_vcpu *v;\n\t\tkvm_for_each_vcpu(r, v, vcpu->kvm)\n\t\t\tif (v == vcpu)\n\t\t\t\tdata = r;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE:\n\t\tdata = vcpu->arch.hv_vapic;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\n\tswitch (msr) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K7_HWCR:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_PERFCTR0:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr, pdata);\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tdata = 0x100000000ULL;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\t\tdata = 0x500 | KVM_NR_VAR_MTRR;\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn get_msr_mtrr(vcpu, msr, pdata);\n\tcase 0xcd: /* fsb frequency */\n\t\tdata = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tdata = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tdata = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr, pdata);\n\t\tbreak;\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tdata = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tdata = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tdata = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tdata = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tdata |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tdata = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tdata = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tdata = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tdata = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tdata = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tdata = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1:\n\t\treturn get_msr_mce(vcpu, msr, pdata);\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tdata = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\t\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\t\tint r;\n\t\t\tmutex_lock(&vcpu->kvm->lock);\n\t\t\tr = get_msr_hyperv_pw(vcpu, msr, pdata);\n\t\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\t\treturn r;\n\t\t} else\n\t\t\treturn get_msr_hyperv(vcpu, msr, pdata);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tdata = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.osvw.status;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr, pdata);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled rdmsr: 0x%x\\n\", msr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\", msr);\n\t\t\tdata = 0;\n\t\t}\n\t\tbreak;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_get_msr_common);\n\n/*\n * Read or write a bunch of msrs. All parameters are kernel addresses.\n *\n * @return number of msrs set successfully.\n */\nstatic int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}\n\n/*\n * Read or write a bunch of msrs. Parameters are user addresses.\n *\n * @return number of msrs set successfully.\n */\nstatic int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,\n\t\t  int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned index, u64 *data),\n\t\t  int writeback)\n{\n\tstruct kvm_msrs msrs;\n\tstruct kvm_msr_entry *entries;\n\tint r, n;\n\tunsigned size;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&msrs, user_msrs, sizeof msrs))\n\t\tgoto out;\n\n\tr = -E2BIG;\n\tif (msrs.nmsrs >= MAX_IO_MSRS)\n\t\tgoto out;\n\n\tsize = sizeof(struct kvm_msr_entry) * msrs.nmsrs;\n\tentries = memdup_user(user_msrs->entries, size);\n\tif (IS_ERR(entries)) {\n\t\tr = PTR_ERR(entries);\n\t\tgoto out;\n\t}\n\n\tr = n = __msr_io(vcpu, &msrs, entries, do_msr);\n\tif (r < 0)\n\t\tgoto out_free;\n\n\tr = -EFAULT;\n\tif (writeback && copy_to_user(user_msrs->entries, entries, size))\n\t\tgoto out_free;\n\n\tr = n;\n\nout_free:\n\tkfree(entries);\nout:\n\treturn r;\n}\n\nint kvm_dev_ioctl_check_extension(long ext)\n{\n\tint r;\n\n\tswitch (ext) {\n\tcase KVM_CAP_IRQCHIP:\n\tcase KVM_CAP_HLT:\n\tcase KVM_CAP_MMU_SHADOW_CACHE_CONTROL:\n\tcase KVM_CAP_SET_TSS_ADDR:\n\tcase KVM_CAP_EXT_CPUID:\n\tcase KVM_CAP_EXT_EMUL_CPUID:\n\tcase KVM_CAP_CLOCKSOURCE:\n\tcase KVM_CAP_PIT:\n\tcase KVM_CAP_NOP_IO_DELAY:\n\tcase KVM_CAP_MP_STATE:\n\tcase KVM_CAP_SYNC_MMU:\n\tcase KVM_CAP_USER_NMI:\n\tcase KVM_CAP_REINJECT_CONTROL:\n\tcase KVM_CAP_IRQ_INJECT_STATUS:\n\tcase KVM_CAP_IRQFD:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_PIT2:\n\tcase KVM_CAP_PIT_STATE2:\n\tcase KVM_CAP_SET_IDENTITY_MAP_ADDR:\n\tcase KVM_CAP_XEN_HVM:\n\tcase KVM_CAP_ADJUST_CLOCK:\n\tcase KVM_CAP_VCPU_EVENTS:\n\tcase KVM_CAP_HYPERV:\n\tcase KVM_CAP_HYPERV_VAPIC:\n\tcase KVM_CAP_HYPERV_SPIN:\n\tcase KVM_CAP_PCI_SEGMENT:\n\tcase KVM_CAP_DEBUGREGS:\n\tcase KVM_CAP_X86_ROBUST_SINGLESTEP:\n\tcase KVM_CAP_XSAVE:\n\tcase KVM_CAP_ASYNC_PF:\n\tcase KVM_CAP_GET_TSC_KHZ:\n\tcase KVM_CAP_KVMCLOCK_CTRL:\n\tcase KVM_CAP_READONLY_MEM:\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n\tcase KVM_CAP_ASSIGN_DEV_IRQ:\n\tcase KVM_CAP_PCI_2_3:\n#endif\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_COALESCED_MMIO:\n\t\tr = KVM_COALESCED_MMIO_PAGE_OFFSET;\n\t\tbreak;\n\tcase KVM_CAP_VAPIC:\n\t\tr = !kvm_x86_ops->cpu_has_accelerated_tpr();\n\t\tbreak;\n\tcase KVM_CAP_NR_VCPUS:\n\t\tr = KVM_SOFT_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\tr = KVM_USER_MEM_SLOTS;\n\t\tbreak;\n\tcase KVM_CAP_PV_MMU:\t/* obsolete */\n\t\tr = 0;\n\t\tbreak;\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n\tcase KVM_CAP_IOMMU:\n\t\tr = iommu_present(&pci_bus_type);\n\t\tbreak;\n#endif\n\tcase KVM_CAP_MCE:\n\t\tr = KVM_MAX_MCE_BANKS;\n\t\tbreak;\n\tcase KVM_CAP_XCRS:\n\t\tr = cpu_has_xsave;\n\t\tbreak;\n\tcase KVM_CAP_TSC_CONTROL:\n\t\tr = kvm_has_tsc_control;\n\t\tbreak;\n\tcase KVM_CAP_TSC_DEADLINE_TIMER:\n\t\tr = boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER);\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t\tbreak;\n\t}\n\treturn r;\n\n}\n\nlong kvm_arch_dev_ioctl(struct file *filp,\n\t\t\tunsigned int ioctl, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tlong r;\n\n\tswitch (ioctl) {\n\tcase KVM_GET_MSR_INDEX_LIST: {\n\t\tstruct kvm_msr_list __user *user_msr_list = argp;\n\t\tstruct kvm_msr_list msr_list;\n\t\tunsigned n;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msr_list, user_msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tn = msr_list.nmsrs;\n\t\tmsr_list.nmsrs = num_msrs_to_save + ARRAY_SIZE(emulated_msrs);\n\t\tif (copy_to_user(user_msr_list, &msr_list, sizeof msr_list))\n\t\t\tgoto out;\n\t\tr = -E2BIG;\n\t\tif (n < msr_list.nmsrs)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(user_msr_list->indices, &msrs_to_save,\n\t\t\t\t num_msrs_to_save * sizeof(u32)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(user_msr_list->indices + num_msrs_to_save,\n\t\t\t\t &emulated_msrs,\n\t\t\t\t ARRAY_SIZE(emulated_msrs) * sizeof(u32)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_SUPPORTED_CPUID:\n\tcase KVM_GET_EMULATED_CPUID: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\n\t\tr = kvm_dev_ioctl_get_cpuid(&cpuid, cpuid_arg->entries,\n\t\t\t\t\t    ioctl);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_X86_GET_MCE_CAP_SUPPORTED: {\n\t\tu64 mce_cap;\n\n\t\tmce_cap = KVM_MCE_CAP_SUPPORTED;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &mce_cap, sizeof mce_cap))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\treturn r;\n}\n\nstatic void wbinvd_ipi(void *garbage)\n{\n\twbinvd();\n}\n\nstatic bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_has_noncoherent_dma(vcpu->kvm);\n}\n\nvoid kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\t/* Address WBINVD may be executed by guest */\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\n\t/* Apply any externally detected TSC adjustments (due to suspend) */\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t}\n\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\tnative_read_tsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_x86_ops->compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\t/*\n\t\t * On a host with synchronized TSC, there is no need to update\n\t\t * kvmclock on vcpu->cpu migration\n\t\t */\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\n\taccumulate_steal_time(vcpu);\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}\n\nvoid kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n\tvcpu->arch.last_host_tsc = native_read_tsc();\n}\n\nstatic int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\tmemcpy(s->regs, vcpu->arch.apic->regs, sizeof *s);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tkvm_apic_post_state_restore(vcpu, s);\n\tupdate_cr8_intercept(vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_interrupt *irq)\n{\n\tif (irq->irq >= KVM_NR_INTERRUPTS)\n\t\treturn -EINVAL;\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\treturn -ENXIO;\n\n\tkvm_queue_interrupt(vcpu, irq->irq, false);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)\n{\n\tkvm_inject_nmi(vcpu);\n\n\treturn 0;\n}\n\nstatic int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   struct kvm_tpr_access_ctl *tac)\n{\n\tif (tac->flags)\n\t\treturn -EINVAL;\n\tvcpu->arch.tpr_access_reporting = !!tac->enabled;\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu64 mcg_cap)\n{\n\tint r;\n\tunsigned bank_num = mcg_cap & 0xff, bank;\n\n\tr = -EINVAL;\n\tif (!bank_num || bank_num >= KVM_MAX_MCE_BANKS)\n\t\tgoto out;\n\tif (mcg_cap & ~(KVM_MCE_CAP_SUPPORTED | 0xff | 0xff0000))\n\t\tgoto out;\n\tr = 0;\n\tvcpu->arch.mcg_cap = mcg_cap;\n\t/* Init IA32_MCG_CTL to all 1s */\n\tif (mcg_cap & MCG_CTL_P)\n\t\tvcpu->arch.mcg_ctl = ~(u64)0;\n\t/* Init IA32_MCi_CTL to all 1s */\n\tfor (bank = 0; bank < bank_num; bank++)\n\t\tvcpu->arch.mce_banks[bank*4] = ~(u64)0;\nout:\n\treturn r;\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_x86_mce *mce)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu64 *banks = vcpu->arch.mce_banks;\n\n\tif (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))\n\t\treturn -EINVAL;\n\t/*\n\t * if IA32_MCG_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\t    vcpu->arch.mcg_ctl != ~(u64)0)\n\t\treturn 0;\n\tbanks += 4 * mce->bank;\n\t/*\n\t * if IA32_MCi_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled for the bank\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)\n\t\treturn 0;\n\tif (mce->status & MCI_STATUS_UC) {\n\t\tif ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||\n\t\t    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\t\treturn 0;\n\t\t}\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tvcpu->arch.mcg_status = mce->mcg_status;\n\t\tbanks[1] = mce->status;\n\t\tkvm_queue_exception(vcpu, MC_VECTOR);\n\t} else if (!(banks[1] & MCI_STATUS_VAL)\n\t\t   || !(banks[1] & MCI_STATUS_UC)) {\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tbanks[1] = mce->status;\n\t} else\n\t\tbanks[1] |= MCI_STATUS_OVER;\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tprocess_nmi(vcpu);\n\tevents->exception.injected =\n\t\tvcpu->arch.exception.pending &&\n\t\t!kvm_exception_is_soft(vcpu->arch.exception.nr);\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.pad = 0;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow =\n\t\tkvm_x86_ops->get_interrupt_shadow(vcpu,\n\t\t\tKVM_X86_SHADOW_INT_MOV_SS | KVM_X86_SHADOW_INT_STI);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending != 0;\n\tevents->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);\n\tevents->nmi.pad = 0;\n\n\tevents->sipi_vector = 0; /* never valid when reporting to user space */\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW);\n\tmemset(&events->reserved, 0, sizeof(events->reserved));\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct kvm_vcpu_events *events)\n{\n\tif (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t      | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t      | KVM_VCPUEVENT_VALID_SHADOW))\n\t\treturn -EINVAL;\n\n\tprocess_nmi(vcpu);\n\tvcpu->arch.exception.pending = events->exception.injected;\n\tvcpu->arch.exception.nr = events->exception.nr;\n\tvcpu->arch.exception.has_error_code = events->exception.has_error_code;\n\tvcpu->arch.exception.error_code = events->exception.error_code;\n\n\tvcpu->arch.interrupt.pending = events->interrupt.injected;\n\tvcpu->arch.interrupt.nr = events->interrupt.nr;\n\tvcpu->arch.interrupt.soft = events->interrupt.soft;\n\tif (events->flags & KVM_VCPUEVENT_VALID_SHADOW)\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu,\n\t\t\t\t\t\t  events->interrupt.shadow);\n\n\tvcpu->arch.nmi_injected = events->nmi.injected;\n\tif (events->flags & KVM_VCPUEVENT_VALID_NMI_PENDING)\n\t\tvcpu->arch.nmi_pending = events->nmi.pending;\n\tkvm_x86_ops->set_nmi_mask(vcpu, events->nmi.masked);\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SIPI_VECTOR &&\n\t    kvm_vcpu_has_lapic(vcpu))\n\t\tvcpu->arch.apic->sipi_vector = events->sipi_vector;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tdbgregs->dr6 = vcpu->arch.dr6;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_debugregs *dbgregs)\n{\n\tif (dbgregs->flags)\n\t\treturn -EINVAL;\n\n\tmemcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));\n\tvcpu->arch.dr6 = dbgregs->dr6;\n\tvcpu->arch.dr7 = dbgregs->dr7;\n\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_xsave *guest_xsave)\n{\n\tif (cpu_has_xsave) {\n\t\tmemcpy(guest_xsave->region,\n\t\t\t&vcpu->arch.guest_fpu.state->xsave,\n\t\t\tvcpu->arch.guest_xstate_size);\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] &=\n\t\t\tvcpu->arch.guest_supported_xcr0 | XSTATE_FPSSE;\n\t} else {\n\t\tmemcpy(guest_xsave->region,\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave,\n\t\t\tsizeof(struct i387_fxsave_struct));\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] =\n\t\t\tXSTATE_FPSSE;\n\t}\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xsave *guest_xsave)\n{\n\tu64 xstate_bv =\n\t\t*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)];\n\n\tif (cpu_has_xsave) {\n\t\t/*\n\t\t * Here we allow setting states that are not present in\n\t\t * CPUID leaf 0xD, index 0, EDX:EAX.  This is for compatibility\n\t\t * with old userspace.\n\t\t */\n\t\tif (xstate_bv & ~KVM_SUPPORTED_XCR0)\n\t\t\treturn -EINVAL;\n\t\tif (xstate_bv & ~host_xcr0)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&vcpu->arch.guest_fpu.state->xsave,\n\t\t\tguest_xsave->region, vcpu->arch.guest_xstate_size);\n\t} else {\n\t\tif (xstate_bv & ~XSTATE_FPSSE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&vcpu->arch.guest_fpu.state->fxsave,\n\t\t\tguest_xsave->region, sizeof(struct i387_fxsave_struct));\n\t}\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!cpu_has_xsave) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct kvm_xcrs *guest_xcrs)\n{\n\tint i, r = 0;\n\n\tif (!cpu_has_xsave)\n\t\treturn -EINVAL;\n\n\tif (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < guest_xcrs->nr_xcrs; i++)\n\t\t/* Only support XCR0 currently */\n\t\tif (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {\n\t\t\tr = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,\n\t\t\t\tguest_xcrs->xcrs[i].value);\n\t\t\tbreak;\n\t\t}\n\tif (r)\n\t\tr = -EINVAL;\n\treturn r;\n}\n\n/*\n * kvm_set_guest_paused() indicates to the guest kernel that it has been\n * stopped by the hypervisor.  This function will be called from the host only.\n * EINVAL is returned when the host attempts to set the flag for a guest that\n * does not support pv clocks.\n */\nstatic int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.pv_time_enabled)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}\n\nlong kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tunion {\n\t\tstruct kvm_lapic_state *lapic;\n\t\tstruct kvm_xsave *xsave;\n\t\tstruct kvm_xcrs *xcrs;\n\t\tvoid *buffer;\n\t} u;\n\n\tu.buffer = NULL;\n\tswitch (ioctl) {\n\tcase KVM_GET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!vcpu->arch.apic)\n\t\t\tgoto out;\n\t\tu.lapic = kzalloc(sizeof(struct kvm_lapic_state), GFP_KERNEL);\n\n\t\tr = -ENOMEM;\n\t\tif (!u.lapic)\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_lapic(vcpu, u.lapic);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.lapic, sizeof(struct kvm_lapic_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!vcpu->arch.apic)\n\t\t\tgoto out;\n\t\tu.lapic = memdup_user(argp, sizeof(*u.lapic));\n\t\tif (IS_ERR(u.lapic))\n\t\t\treturn PTR_ERR(u.lapic);\n\n\t\tr = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);\n\t\tbreak;\n\t}\n\tcase KVM_INTERRUPT: {\n\t\tstruct kvm_interrupt irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq, argp, sizeof irq))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_interrupt(vcpu, &irq);\n\t\tbreak;\n\t}\n\tcase KVM_NMI: {\n\t\tr = kvm_vcpu_ioctl_nmi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID: {\n\t\tstruct kvm_cpuid __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid(vcpu, &cpuid, cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_MSRS:\n\t\tr = msr_io(vcpu, argp, kvm_get_msr, 1);\n\t\tbreak;\n\tcase KVM_SET_MSRS:\n\t\tr = msr_io(vcpu, argp, do_set_msr, 0);\n\t\tbreak;\n\tcase KVM_TPR_ACCESS_REPORTING: {\n\t\tstruct kvm_tpr_access_ctl tac;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tac, argp, sizeof tac))\n\t\t\tgoto out;\n\t\tr = vcpu_ioctl_tpr_access_reporting(vcpu, &tac);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tac, sizeof tac))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t};\n\tcase KVM_SET_VAPIC_ADDR: {\n\t\tstruct kvm_vapic_addr va;\n\n\t\tr = -EINVAL;\n\t\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&va, argp, sizeof va))\n\t\t\tgoto out;\n\t\tr = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SETUP_MCE: {\n\t\tu64 mcg_cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mcg_cap, argp, sizeof mcg_cap))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SET_MCE: {\n\t\tstruct kvm_x86_mce mce;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mce, argp, sizeof mce))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);\n\t\tbreak;\n\t}\n\tcase KVM_GET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &events, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tkvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &dbgregs,\n\t\t\t\t sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbgregs, argp,\n\t\t\t\t   sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XSAVE: {\n\t\tu.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XSAVE: {\n\t\tu.xsave = memdup_user(argp, sizeof(*u.xsave));\n\t\tif (IS_ERR(u.xsave))\n\t\t\treturn PTR_ERR(u.xsave);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XCRS: {\n\t\tu.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xcrs)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xcrs,\n\t\t\t\t sizeof(struct kvm_xcrs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XCRS: {\n\t\tu.xcrs = memdup_user(argp, sizeof(*u.xcrs));\n\t\tif (IS_ERR(u.xcrs))\n\t\t\treturn PTR_ERR(u.xcrs);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\n\t\tr = -EINVAL;\n\t\tuser_tsc_khz = (u32)arg;\n\n\t\tif (user_tsc_khz >= kvm_max_guest_tsc_khz)\n\t\t\tgoto out;\n\n\t\tif (user_tsc_khz == 0)\n\t\t\tuser_tsc_khz = tsc_khz;\n\n\t\tkvm_set_tsc_khz(vcpu, user_tsc_khz);\n\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tcase KVM_GET_TSC_KHZ: {\n\t\tr = vcpu->arch.virtual_tsc_khz;\n\t\tgoto out;\n\t}\n\tcase KVM_KVMCLOCK_CTRL: {\n\t\tr = kvm_set_guest_paused(vcpu);\n\t\tgoto out;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\tkfree(u.buffer);\n\treturn r;\n}\n\nint kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)\n{\n\treturn VM_FAULT_SIGBUS;\n}\n\nstatic int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)\n{\n\tint ret;\n\n\tif (addr > (unsigned int)(-3 * PAGE_SIZE))\n\t\treturn -EINVAL;\n\tret = kvm_x86_ops->set_tss_addr(kvm, addr);\n\treturn ret;\n}\n\nstatic int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,\n\t\t\t\t\t      u64 ident_addr)\n{\n\tkvm->arch.ept_identity_map_addr = ident_addr;\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,\n\t\t\t\t\t  u32 kvm_nr_mmu_pages)\n{\n\tif (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);\n\tkvm->arch.n_requested_mmu_pages = kvm_nr_mmu_pages;\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)\n{\n\treturn kvm->arch.n_max_mmu_pages;\n}\n\nstatic int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[0],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tmemcpy(&chip->chip.pic,\n\t\t\t&pic_irqchip(kvm)->pics[1],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_get_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[0],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tspin_lock(&pic_irqchip(kvm)->lock);\n\t\tmemcpy(&pic_irqchip(kvm)->pics[1],\n\t\t\t&chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic_irqchip(kvm)->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tr = kvm_set_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\tkvm_pic_update_irq(pic_irqchip(kvm));\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps, &kvm->arch.vpit->pit_state, sizeof(struct kvm_pit_state));\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps->channels, &kvm->arch.vpit->pit_state.channels,\n\t\tsizeof(ps->channels));\n\tps->flags = kvm->arch.vpit->pit_state.flags;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\tmemset(&ps->reserved, 0, sizeof(ps->reserved));\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint r = 0, start = 0;\n\tu32 prev_legacy, cur_legacy;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n\t       sizeof(kvm->arch.vpit->pit_state.channels));\n\tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tif (!kvm->arch.vpit)\n\t\treturn -ENXIO;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tkvm->arch.vpit->pit_state.reinject = control->pit_reinject;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}\n\n/**\n * kvm_vm_ioctl_get_dirty_log - get and clear the log of dirty pages in a slot\n * @kvm: kvm instance\n * @log: slot id and address to which we copy the log\n *\n * We need to keep it in mind that VCPU threads can write to the bitmap\n * concurrently.  So, to avoid losing data, we keep the following order for\n * each bit:\n *\n *   1. Take a snapshot of the bit and clear it if needed.\n *   2. Write protect the corresponding page.\n *   3. Flush TLB's if needed.\n *   4. Copy the snapshot to the userspace.\n *\n * Between 2 and 3, the guest may write to the page using the remaining TLB\n * entry.  This is not a problem because the page will be reported dirty at\n * step 4 using the snapshot taken before and step 3 ensures that successive\n * writes will be logged for the next call.\n */\nint kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)\n{\n\tint r;\n\tstruct kvm_memory_slot *memslot;\n\tunsigned long n, i;\n\tunsigned long *dirty_bitmap;\n\tunsigned long *dirty_bitmap_buffer;\n\tbool is_dirty = false;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tr = -EINVAL;\n\tif (log->slot >= KVM_USER_MEM_SLOTS)\n\t\tgoto out;\n\n\tmemslot = id_to_memslot(kvm->memslots, log->slot);\n\n\tdirty_bitmap = memslot->dirty_bitmap;\n\tr = -ENOENT;\n\tif (!dirty_bitmap)\n\t\tgoto out;\n\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\n\tdirty_bitmap_buffer = dirty_bitmap + n / sizeof(long);\n\tmemset(dirty_bitmap_buffer, 0, n);\n\n\tspin_lock(&kvm->mmu_lock);\n\n\tfor (i = 0; i < n / sizeof(long); i++) {\n\t\tunsigned long mask;\n\t\tgfn_t offset;\n\n\t\tif (!dirty_bitmap[i])\n\t\t\tcontinue;\n\n\t\tis_dirty = true;\n\n\t\tmask = xchg(&dirty_bitmap[i], 0);\n\t\tdirty_bitmap_buffer[i] = mask;\n\n\t\toffset = i * BITS_PER_LONG;\n\t\tkvm_mmu_write_protect_pt_masked(kvm, memslot, offset, mask);\n\t}\n\tif (is_dirty)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\tspin_unlock(&kvm->mmu_lock);\n\n\tr = -EFAULT;\n\tif (copy_to_user(log->dirty_bitmap, dirty_bitmap_buffer, n))\n\t\tgoto out;\n\n\tr = 0;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nint kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,\n\t\t\tbool line_status)\n{\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -ENXIO;\n\n\tirq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event->irq, irq_event->level,\n\t\t\t\t\tline_status);\n\treturn 0;\n}\n\nlong kvm_arch_vm_ioctl(struct file *filp,\n\t\t       unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r = -ENOTTY;\n\t/*\n\t * This union makes it completely explicit to gcc-3.x\n\t * that these two variables' stack usage should be\n\t * combined, not added together.\n\t */\n\tunion {\n\t\tstruct kvm_pit_state ps;\n\t\tstruct kvm_pit_state2 ps2;\n\t\tstruct kvm_pit_config pit_config;\n\t} u;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_TSS_ADDR:\n\t\tr = kvm_vm_ioctl_set_tss_addr(kvm, arg);\n\t\tbreak;\n\tcase KVM_SET_IDENTITY_MAP_ADDR: {\n\t\tu64 ident_addr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&ident_addr, argp, sizeof ident_addr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);\n\t\tbreak;\n\t}\n\tcase KVM_SET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);\n\t\tbreak;\n\tcase KVM_GET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_get_nr_mmu_pages(kvm);\n\t\tbreak;\n\tcase KVM_CREATE_IRQCHIP: {\n\t\tstruct kvm_pic *vpic;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpic)\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -EINVAL;\n\t\tif (atomic_read(&kvm->online_vcpus))\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -ENOMEM;\n\t\tvpic = kvm_create_pic(kvm);\n\t\tif (vpic) {\n\t\t\tr = kvm_ioapic_init(kvm);\n\t\t\tif (r) {\n\t\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_master);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_slave);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_eclr);\n\t\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t\t\tkfree(vpic);\n\t\t\t\tgoto create_irqchip_unlock;\n\t\t\t}\n\t\t} else\n\t\t\tgoto create_irqchip_unlock;\n\t\tsmp_wmb();\n\t\tkvm->arch.vpic = vpic;\n\t\tsmp_wmb();\n\t\tr = kvm_setup_default_irq_routing(kvm);\n\t\tif (r) {\n\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\tmutex_lock(&kvm->irq_lock);\n\t\t\tkvm_ioapic_destroy(kvm);\n\t\t\tkvm_destroy_pic(kvm);\n\t\t\tmutex_unlock(&kvm->irq_lock);\n\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t}\n\tcreate_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CREATE_PIT:\n\t\tu.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;\n\t\tgoto create_pit;\n\tcase KVM_CREATE_PIT2:\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.pit_config, argp,\n\t\t\t\t   sizeof(struct kvm_pit_config)))\n\t\t\tgoto out;\n\tcreate_pit:\n\t\tmutex_lock(&kvm->slots_lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpit)\n\t\t\tgoto create_pit_unlock;\n\t\tr = -ENOMEM;\n\t\tkvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);\n\t\tif (kvm->arch.vpit)\n\t\t\tr = 0;\n\tcreate_pit_unlock:\n\t\tmutex_unlock(&kvm->slots_lock);\n\t\tbreak;\n\tcase KVM_GET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto get_irqchip_out;\n\t\tr = kvm_vm_ioctl_get_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto get_irqchip_out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, chip, sizeof *chip))\n\t\t\tgoto get_irqchip_out;\n\t\tr = 0;\n\tget_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_SET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto set_irqchip_out;\n\t\tr = kvm_vm_ioctl_set_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto set_irqchip_out;\n\t\tr = 0;\n\tset_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof u.ps))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit(kvm, &u.ps);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT2: {\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps2, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT2: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);\n\t\tbreak;\n\t}\n\tcase KVM_REINJECT_CONTROL: {\n\t\tstruct kvm_reinject_control control;\n\t\tr =  -EFAULT;\n\t\tif (copy_from_user(&control, argp, sizeof(control)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_reinject(kvm, &control);\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_CONFIG: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm->arch.xen_hvm_config, argp,\n\t\t\t\t   sizeof(struct kvm_xen_hvm_config)))\n\t\t\tgoto out;\n\t\tr = -EINVAL;\n\t\tif (kvm->arch.xen_hvm_config.flags)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\t\ts64 delta;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&user_ns, argp, sizeof(user_ns)))\n\t\t\tgoto out;\n\n\t\tr = -EINVAL;\n\t\tif (user_ns.flags)\n\t\t\tgoto out;\n\n\t\tr = 0;\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tdelta = user_ns.clock - now_ns;\n\t\tlocal_irq_enable();\n\t\tkvm->arch.kvmclock_offset = delta;\n\t\tkvm_gen_update_masterclock(kvm);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tuser_ns.clock = kvm->arch.kvmclock_offset + now_ns;\n\t\tlocal_irq_enable();\n\t\tuser_ns.flags = 0;\n\t\tmemset(&user_ns.pad, 0, sizeof(user_ns.pad));\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &user_ns, sizeof(user_ns)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t;\n\t}\nout:\n\treturn r;\n}\n\nstatic void kvm_init_msr_list(void)\n{\n\tu32 dummy[2];\n\tunsigned i, j;\n\n\t/* skip the first msrs in the list. KVM-specific */\n\tfor (i = j = KVM_SAVE_MSRS_BEGIN; i < ARRAY_SIZE(msrs_to_save); i++) {\n\t\tif (rdmsr_safe(msrs_to_save[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\t\tif (j < i)\n\t\t\tmsrs_to_save[j] = msrs_to_save[i];\n\t\tj++;\n\t}\n\tnum_msrs_to_save = j;\n}\n\nstatic int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,\n\t\t\t   const void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(vcpu->arch.apic &&\n\t\t      !kvm_iodevice_write(&vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_write(vcpu->kvm, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n\nstatic int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(vcpu->arch.apic &&\n\t\t      !kvm_iodevice_read(&vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_read(vcpu->kvm, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, *(u64 *)v);\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n\nstatic void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->set_segment(vcpu, var, seg);\n}\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}\n\ngpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u32 access)\n{\n\tgpa_t t_gpa;\n\tstruct x86_exception exception;\n\n\tBUG_ON(!mmu_is_nested(vcpu));\n\n\t/* NPT walks are always user-walks */\n\taccess |= PFERR_USER_MASK;\n\tt_gpa  = vcpu->arch.mmu.gva_to_gpa(vcpu, gpa, access, &exception);\n\n\treturn t_gpa;\n}\n\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}\n\n gpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_FETCH_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}\n\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}\n\n/* uses this to access any guest's mapped memory without checking CPL */\ngpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, 0, exception);\n}\n\nstatic int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr, access,\n\t\t\t\t\t\t\t    exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_read_guest(vcpu->kvm, gpa, data, toread);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= toread;\n\t\tdata += toread;\n\t\taddr += toread;\n\t}\nout:\n\treturn r;\n}\n\n/* used for instruction fetching */\nstatic int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tgva_t addr, void *val, unsigned int bytes,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu,\n\t\t\t\t\t  access | PFERR_FETCH_MASK,\n\t\t\t\t\t  exception);\n}\n\nint kvm_read_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t       gva_t addr, void *val, unsigned int bytes,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,\n\t\t\t\t\t  exception);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_virt);\n\nstatic int kvm_read_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t      gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, 0, exception);\n}\n\nint kvm_write_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       gva_t addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa =  vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr,\n\t\t\t\t\t\t\t     PFERR_WRITE_MASK,\n\t\t\t\t\t\t\t     exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_write_guest(vcpu->kvm, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest_virt_system);\n\nstatic int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,\n\t\t\t\tgpa_t *gpa, struct x86_exception *exception,\n\t\t\t\tbool write)\n{\n\tu32 access = ((kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0)\n\t\t| (write ? PFERR_WRITE_MASK : 0);\n\n\tif (vcpu_match_mmio_gva(vcpu, gva)\n\t    && !permission_fault(vcpu->arch.walk_mmu, vcpu->arch.access, access)) {\n\t\t*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |\n\t\t\t\t\t(gva & (PAGE_SIZE - 1));\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, false);\n\t\treturn 1;\n\t}\n\n\t*gpa = vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n\n\tif (*gpa == UNMAPPED_GVA)\n\t\treturn -1;\n\n\t/* For APIC access vmexit */\n\tif ((*gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\treturn 1;\n\n\tif (vcpu_match_mmio_gpa(vcpu, *gpa)) {\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tconst void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_mmu_pte_write(vcpu, gpa, val, bytes);\n\treturn 1;\n}\n\nstruct read_write_emulator_ops {\n\tint (*read_write_prepare)(struct kvm_vcpu *vcpu, void *val,\n\t\t\t\t  int bytes);\n\tint (*read_write_emulate)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\t  void *val, int bytes);\n\tint (*read_write_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t       int bytes, void *val);\n\tint (*read_write_exit_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\t    void *val, int bytes);\n\tbool write;\n};\n\nstatic int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_fragments[0].gpa, *(u64 *)val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tvoid *val, int bytes)\n{\n\treturn !kvm_read_guest(vcpu->kvm, gpa, val, bytes);\n}\n\nstatic int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t void *val, int bytes)\n{\n\treturn emulator_write_phys(vcpu, gpa, val, bytes);\n}\n\nstatic int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, *(u64 *)val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}\n\nstatic int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, 0);\n\treturn X86EMUL_IO_NEEDED;\n}\n\nstatic int write_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t   void *val, int bytes)\n{\n\tstruct kvm_mmio_fragment *frag = &vcpu->mmio_fragments[0];\n\n\tmemcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic const struct read_write_emulator_ops read_emultor = {\n\t.read_write_prepare = read_prepare,\n\t.read_write_emulate = read_emulate,\n\t.read_write_mmio = vcpu_mmio_read,\n\t.read_write_exit_mmio = read_exit_mmio,\n};\n\nstatic const struct read_write_emulator_ops write_emultor = {\n\t.read_write_emulate = write_emulate,\n\t.read_write_mmio = write_mmio,\n\t.read_write_exit_mmio = write_exit_mmio,\n\t.write = true,\n};\n\nstatic int emulator_read_write_onepage(unsigned long addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception,\n\t\t\t\t       struct kvm_vcpu *vcpu,\n\t\t\t\t       const struct read_write_emulator_ops *ops)\n{\n\tgpa_t gpa;\n\tint handled, ret;\n\tbool write = ops->write;\n\tstruct kvm_mmio_fragment *frag;\n\n\tret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);\n\n\tif (ret < 0)\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\t/* For APIC access vmexit */\n\tif (ret)\n\t\tgoto mmio;\n\n\tif (ops->read_write_emulate(vcpu, gpa, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\nmmio:\n\t/*\n\t * Is this MMIO handled locally?\n\t */\n\thandled = ops->read_write_mmio(vcpu, gpa, bytes, val);\n\tif (handled == bytes)\n\t\treturn X86EMUL_CONTINUE;\n\n\tgpa += handled;\n\tbytes -= handled;\n\tval += handled;\n\n\tWARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];\n\tfrag->gpa = gpa;\n\tfrag->data = val;\n\tfrag->len = bytes;\n\treturn X86EMUL_CONTINUE;\n}\n\nint emulator_read_write(struct x86_emulate_ctxt *ctxt, unsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tconst struct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tint rc;\n\n\tif (ops->read_write_prepare &&\n\t\t  ops->read_write_prepare(vcpu, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\tvcpu->mmio_nr_fragments = 0;\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\trc = emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t vcpu, ops);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (!vcpu->mmio_nr_fragments)\n\t\treturn rc;\n\n\tgpa = vcpu->mmio_fragments[0].gpa;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.len = min(8u, vcpu->mmio_fragments[0].len);\n\tvcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\tvcpu->run->mmio.phys_addr = gpa;\n\n\treturn ops->read_write_exit_mmio(vcpu, gpa, val, bytes);\n}\n\nstatic int emulator_read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  unsigned long addr,\n\t\t\t\t  void *val,\n\t\t\t\t  unsigned int bytes,\n\t\t\t\t  struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, val, bytes,\n\t\t\t\t   exception, &read_emultor);\n}\n\nint emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}\n\n#define CMPXCHG_TYPE(t, ptr, old, new) \\\n\t(cmpxchg((t *)(ptr), *(t *)(old), *(t *)(new)) == *(t *)(old))\n\n#ifdef CONFIG_X86_64\n#  define CMPXCHG64(ptr, old, new) CMPXCHG_TYPE(u64, ptr, old, new)\n#else\n#  define CMPXCHG64(ptr, old, new) \\\n\t(cmpxchg64((u64 *)(ptr), *(u64 *)(old), *(u64 *)(new)) == *(u64 *)(old))\n#endif\n\nstatic int emulator_cmpxchg_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     unsigned long addr,\n\t\t\t\t     const void *old,\n\t\t\t\t     const void *new,\n\t\t\t\t     unsigned int bytes,\n\t\t\t\t     struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tstruct page *page;\n\tchar *kaddr;\n\tbool exchanged;\n\n\t/* guests cmpxchg8b have to be emulated atomically */\n\tif (bytes > 8 || (bytes & (bytes - 1)))\n\t\tgoto emul_write;\n\n\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, addr, NULL);\n\n\tif (gpa == UNMAPPED_GVA ||\n\t    (gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\tgoto emul_write;\n\n\tif (((gpa + bytes - 1) & PAGE_MASK) != (gpa & PAGE_MASK))\n\t\tgoto emul_write;\n\n\tpage = gfn_to_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto emul_write;\n\n\tkaddr = kmap_atomic(page);\n\tkaddr += offset_in_page(gpa);\n\tswitch (bytes) {\n\tcase 1:\n\t\texchanged = CMPXCHG_TYPE(u8, kaddr, old, new);\n\t\tbreak;\n\tcase 2:\n\t\texchanged = CMPXCHG_TYPE(u16, kaddr, old, new);\n\t\tbreak;\n\tcase 4:\n\t\texchanged = CMPXCHG_TYPE(u32, kaddr, old, new);\n\t\tbreak;\n\tcase 8:\n\t\texchanged = CMPXCHG64(kaddr, old, new);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tkunmap_atomic(kaddr);\n\tkvm_release_page_dirty(page);\n\n\tif (!exchanged)\n\t\treturn X86EMUL_CMPXCHG_FAILED;\n\n\tkvm_mmu_pte_write(vcpu, gpa, new, bytes);\n\n\treturn X86EMUL_CONTINUE;\n\nemul_write:\n\tprintk_once(KERN_WARNING \"kvm: emulating exchange as write\\n\");\n\n\treturn emulator_write_emulated(ctxt, addr, new, bytes, exception);\n}\n\nstatic int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\t/* TODO: String I/O for in kernel device */\n\tint r;\n\n\tif (vcpu->arch.pio.in)\n\t\tr = kvm_io_bus_read(vcpu->kvm, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t    vcpu->arch.pio.size, pd);\n\telse\n\t\tr = kvm_io_bus_write(vcpu->kvm, KVM_PIO_BUS,\n\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t     pd);\n\treturn r;\n}\n\nstatic int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\ttrace_kvm_pio(!in, port, size, count);\n\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\n\treturn 0;\n}\n\nstatic int emulator_pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    int size, unsigned short port, void *val,\n\t\t\t\t    unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint ret;\n\n\tif (vcpu->arch.pio.count)\n\t\tgoto data_avail;\n\n\tret = emulator_pio_in_out(vcpu, size, port, val, count, true);\n\tif (ret) {\ndata_avail:\n\t\tmemcpy(val, vcpu->arch.pio_data, size * count);\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     int size, unsigned short port,\n\t\t\t\t     const void *val, unsigned int count)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tmemcpy(vcpu->arch.pio_data, val, size * count);\n\treturn emulator_pio_in_out(vcpu, size, port, (void *)val, count, false);\n}\n\nstatic unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn kvm_x86_ops->get_segment_base(vcpu, seg);\n}\n\nstatic void emulator_invlpg(struct x86_emulate_ctxt *ctxt, ulong address)\n{\n\tkvm_mmu_invlpg(emul_to_vcpu(ctxt), address);\n}\n\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_wbinvd);\n\nstatic void emulator_wbinvd(struct x86_emulate_ctxt *ctxt)\n{\n\tkvm_emulate_wbinvd(emul_to_vcpu(ctxt));\n}\n\nint emulator_get_dr(struct x86_emulate_ctxt *ctxt, int dr, unsigned long *dest)\n{\n\treturn _kvm_get_dr(emul_to_vcpu(ctxt), dr, dest);\n}\n\nint emulator_set_dr(struct x86_emulate_ctxt *ctxt, int dr, unsigned long value)\n{\n\n\treturn __kvm_set_dr(emul_to_vcpu(ctxt), dr, value);\n}\n\nstatic u64 mk_cr_64(u64 curr_cr, u32 new_val)\n{\n\treturn (curr_cr & ~((1ULL << 32) - 1)) | new_val;\n}\n\nstatic unsigned long emulator_get_cr(struct x86_emulate_ctxt *ctxt, int cr)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long value;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tvalue = kvm_read_cr0(vcpu);\n\t\tbreak;\n\tcase 2:\n\t\tvalue = vcpu->arch.cr2;\n\t\tbreak;\n\tcase 3:\n\t\tvalue = kvm_read_cr3(vcpu);\n\t\tbreak;\n\tcase 4:\n\t\tvalue = kvm_read_cr4(vcpu);\n\t\tbreak;\n\tcase 8:\n\t\tvalue = kvm_get_cr8(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\treturn 0;\n\t}\n\n\treturn value;\n}\n\nstatic int emulator_set_cr(struct x86_emulate_ctxt *ctxt, int cr, ulong val)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint res = 0;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tres = kvm_set_cr0(vcpu, mk_cr_64(kvm_read_cr0(vcpu), val));\n\t\tbreak;\n\tcase 2:\n\t\tvcpu->arch.cr2 = val;\n\t\tbreak;\n\tcase 3:\n\t\tres = kvm_set_cr3(vcpu, val);\n\t\tbreak;\n\tcase 4:\n\t\tres = kvm_set_cr4(vcpu, mk_cr_64(kvm_read_cr4(vcpu), val));\n\t\tbreak;\n\tcase 8:\n\t\tres = kvm_set_cr8(vcpu, val);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\tres = -1;\n\t}\n\n\treturn res;\n}\n\nstatic void emulator_set_rflags(struct x86_emulate_ctxt *ctxt, ulong val)\n{\n\tkvm_set_rflags(emul_to_vcpu(ctxt), val);\n}\n\nstatic int emulator_get_cpl(struct x86_emulate_ctxt *ctxt)\n{\n\treturn kvm_x86_ops->get_cpl(emul_to_vcpu(ctxt));\n}\n\nstatic void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_gdt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_get_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_idt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_set_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_gdt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_set_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->set_idt(emul_to_vcpu(ctxt), dt);\n}\n\nstatic unsigned long emulator_get_cached_segment_base(\n\tstruct x86_emulate_ctxt *ctxt, int seg)\n{\n\treturn get_segment_base(emul_to_vcpu(ctxt), seg);\n}\n\nstatic bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,\n\t\t\t\t struct desc_struct *desc, u32 *base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_segment var;\n\n\tkvm_get_segment(emul_to_vcpu(ctxt), &var, seg);\n\t*selector = var.selector;\n\n\tif (var.unusable) {\n\t\tmemset(desc, 0, sizeof(*desc));\n\t\treturn false;\n\t}\n\n\tif (var.g)\n\t\tvar.limit >>= 12;\n\tset_desc_limit(desc, var.limit);\n\tset_desc_base(desc, (unsigned long)var.base);\n#ifdef CONFIG_X86_64\n\tif (base3)\n\t\t*base3 = var.base >> 32;\n#endif\n\tdesc->type = var.type;\n\tdesc->s = var.s;\n\tdesc->dpl = var.dpl;\n\tdesc->p = var.present;\n\tdesc->avl = var.avl;\n\tdesc->l = var.l;\n\tdesc->d = var.db;\n\tdesc->g = var.g;\n\n\treturn true;\n}\n\nstatic void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t struct desc_struct *desc, u32 base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tstruct kvm_segment var;\n\n\tvar.selector = selector;\n\tvar.base = get_desc_base(desc);\n#ifdef CONFIG_X86_64\n\tvar.base |= ((u64)base3) << 32;\n#endif\n\tvar.limit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tvar.limit = (var.limit << 12) | 0xfff;\n\tvar.type = desc->type;\n\tvar.present = desc->p;\n\tvar.dpl = desc->dpl;\n\tvar.db = desc->d;\n\tvar.s = desc->s;\n\tvar.l = desc->l;\n\tvar.g = desc->g;\n\tvar.avl = desc->avl;\n\tvar.present = desc->p;\n\tvar.unusable = !var.present;\n\tvar.padding = 0;\n\n\tkvm_set_segment(vcpu, &var, seg);\n\treturn;\n}\n\nstatic int emulator_get_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 *pdata)\n{\n\treturn kvm_get_msr(emul_to_vcpu(ctxt), msr_index, pdata);\n}\n\nstatic int emulator_set_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 data)\n{\n\tstruct msr_data msr;\n\n\tmsr.data = data;\n\tmsr.index = msr_index;\n\tmsr.host_initiated = false;\n\treturn kvm_set_msr(emul_to_vcpu(ctxt), &msr);\n}\n\nstatic int emulator_read_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t     u32 pmc, u64 *pdata)\n{\n\treturn kvm_pmu_read_pmc(emul_to_vcpu(ctxt), pmc, pdata);\n}\n\nstatic void emulator_halt(struct x86_emulate_ctxt *ctxt)\n{\n\temul_to_vcpu(ctxt)->arch.halt_request = 1;\n}\n\nstatic void emulator_get_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_disable();\n\tkvm_load_guest_fpu(emul_to_vcpu(ctxt));\n\t/*\n\t * CR0.TS may reference the host fpu state, not the guest fpu state,\n\t * so it may be clear at this point.\n\t */\n\tclts();\n}\n\nstatic void emulator_put_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_enable();\n}\n\nstatic int emulator_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct x86_instruction_info *info,\n\t\t\t      enum x86_intercept_stage stage)\n{\n\treturn kvm_x86_ops->check_intercept(emul_to_vcpu(ctxt), info, stage);\n}\n\nstatic void emulator_get_cpuid(struct x86_emulate_ctxt *ctxt,\n\t\t\t       u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tkvm_cpuid(emul_to_vcpu(ctxt), eax, ebx, ecx, edx);\n}\n\nstatic ulong emulator_read_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg)\n{\n\treturn kvm_register_read(emul_to_vcpu(ctxt), reg);\n}\n\nstatic void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)\n{\n\tkvm_register_write(emul_to_vcpu(ctxt), reg, val);\n}\n\nstatic const struct x86_emulate_ops emulate_ops = {\n\t.read_gpr            = emulator_read_gpr,\n\t.write_gpr           = emulator_write_gpr,\n\t.read_std            = kvm_read_guest_virt_system,\n\t.write_std           = kvm_write_guest_virt_system,\n\t.fetch               = kvm_fetch_guest_virt,\n\t.read_emulated       = emulator_read_emulated,\n\t.write_emulated      = emulator_write_emulated,\n\t.cmpxchg_emulated    = emulator_cmpxchg_emulated,\n\t.invlpg              = emulator_invlpg,\n\t.pio_in_emulated     = emulator_pio_in_emulated,\n\t.pio_out_emulated    = emulator_pio_out_emulated,\n\t.get_segment         = emulator_get_segment,\n\t.set_segment         = emulator_set_segment,\n\t.get_cached_segment_base = emulator_get_cached_segment_base,\n\t.get_gdt             = emulator_get_gdt,\n\t.get_idt\t     = emulator_get_idt,\n\t.set_gdt             = emulator_set_gdt,\n\t.set_idt\t     = emulator_set_idt,\n\t.get_cr              = emulator_get_cr,\n\t.set_cr              = emulator_set_cr,\n\t.set_rflags          = emulator_set_rflags,\n\t.cpl                 = emulator_get_cpl,\n\t.get_dr              = emulator_get_dr,\n\t.set_dr              = emulator_set_dr,\n\t.set_msr             = emulator_set_msr,\n\t.get_msr             = emulator_get_msr,\n\t.read_pmc            = emulator_read_pmc,\n\t.halt                = emulator_halt,\n\t.wbinvd              = emulator_wbinvd,\n\t.fix_hypercall       = emulator_fix_hypercall,\n\t.get_fpu             = emulator_get_fpu,\n\t.put_fpu             = emulator_put_fpu,\n\t.intercept           = emulator_intercept,\n\t.get_cpuid           = emulator_get_cpuid,\n};\n\nstatic void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)\n{\n\tu32 int_shadow = kvm_x86_ops->get_interrupt_shadow(vcpu, mask);\n\t/*\n\t * an sti; sti; sequence only disable interrupts for the first\n\t * instruction. So, if the last instruction, be it emulated or\n\t * not, left the system with the INT_STI flag enabled, it\n\t * means that the last instruction is an sti. We should not\n\t * leave the flag on in this case. The same goes for mov ss\n\t */\n\tif (!(int_shadow & mask))\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu, mask);\n}\n\nstatic void inject_emulated_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tif (ctxt->exception.vector == PF_VECTOR)\n\t\tkvm_propagate_fault(vcpu, &ctxt->exception);\n\telse if (ctxt->exception.error_code_valid)\n\t\tkvm_queue_exception_e(vcpu, ctxt->exception.vector,\n\t\t\t\t      ctxt->exception.error_code);\n\telse\n\t\tkvm_queue_exception(vcpu, ctxt->exception.vector);\n}\n\nstatic void init_decode_cache(struct x86_emulate_ctxt *ctxt)\n{\n\tmemset(&ctxt->opcode_len, 0,\n\t       (void *)&ctxt->_regs - (void *)&ctxt->opcode_len);\n\n\tctxt->fetch.start = 0;\n\tctxt->fetch.end = 0;\n\tctxt->io_read.pos = 0;\n\tctxt->io_read.end = 0;\n\tctxt->mem_read.pos = 0;\n\tctxt->mem_read.end = 0;\n}\n\nstatic void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     cs_l\t\t\t\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tctxt->guest_mode = is_guest_mode(vcpu);\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}\n\nint kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\n\tctxt->eip = ctxt->_eip;\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = 0;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\n\treturn EMULATE_DONE;\n}\nEXPORT_SYMBOL_GPL(kvm_inject_realmode_interrupt);\n\nstatic int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}\n\nstatic bool reexecute_instruction(struct kvm_vcpu *vcpu, gva_t cr2,\n\t\t\t\t  bool write_fault_to_shadow_pgtable,\n\t\t\t\t  int emulation_type)\n{\n\tgpa_t gpa = cr2;\n\tpfn_t pfn;\n\n\tif (emulation_type & EMULTYPE_NO_REEXECUTE)\n\t\treturn false;\n\n\tif (!vcpu->arch.mmu.direct_map) {\n\t\t/*\n\t\t * Write permission should be allowed since only\n\t\t * write access need to be emulated.\n\t\t */\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\t\t/*\n\t\t * If the mapping is invalid in guest, let cpu retry\n\t\t * it to generate fault.\n\t\t */\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Do not retry the unhandleable instruction if it faults on the\n\t * readonly host memory, otherwise it will goto a infinite loop:\n\t * retry instruction -> write #PF -> emulation fail -> retry\n\t * instruction -> ...\n\t */\n\tpfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the instruction failed on the error pfn, it can not be fixed,\n\t * report the error to userspace.\n\t */\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn false;\n\n\tkvm_release_pfn_clean(pfn);\n\n\t/* The instructions are well-emulated on direct mmu. */\n\tif (vcpu->arch.mmu.direct_map) {\n\t\tunsigned int indirect_shadow_pages;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tindirect_shadow_pages = vcpu->kvm->arch.indirect_shadow_pages;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tif (indirect_shadow_pages)\n\t\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * if emulation was due to access to shadowed page table\n\t * and it failed try to unshadow page and re-enter the\n\t * guest to let CPU execute the instruction.\n\t */\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the access faults on its page table, it can not\n\t * be fixed by unprotecting shadow page and it should\n\t * be reported to userspace.\n\t */\n\treturn !write_fault_to_shadow_pgtable;\n}\n\nstatic bool retry_instruction(struct x86_emulate_ctxt *ctxt,\n\t\t\t      unsigned long cr2,  int emulation_type)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long last_retry_eip, last_retry_addr, gpa = cr2;\n\n\tlast_retry_eip = vcpu->arch.last_retry_eip;\n\tlast_retry_addr = vcpu->arch.last_retry_addr;\n\n\t/*\n\t * If the emulation is caused by #PF and it is non-page_table\n\t * writing instruction, it means the VM-EXIT is caused by shadow\n\t * page protected, we can zap the shadow page and retry this\n\t * instruction directly.\n\t *\n\t * Note: if the guest uses a non-page-table modifying instruction\n\t * on the PDE that points to the instruction, then we will unmap\n\t * the instruction and go to an infinite loop. So, we cache the\n\t * last retried eip and the last fault address, if we meet the eip\n\t * and the address again, we can break out of the potential infinite\n\t * loop.\n\t */\n\tvcpu->arch.last_retry_eip = vcpu->arch.last_retry_addr = 0;\n\n\tif (!(emulation_type & EMULTYPE_RETRY))\n\t\treturn false;\n\n\tif (x86_page_table_writing_insn(ctxt))\n\t\treturn false;\n\n\tif (ctxt->eip == last_retry_eip && last_retry_addr == cr2)\n\t\treturn false;\n\n\tvcpu->arch.last_retry_eip = ctxt->eip;\n\tvcpu->arch.last_retry_addr = cr2;\n\n\tif (!vcpu->arch.mmu.direct_map)\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2, NULL);\n\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\treturn true;\n}\n\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nstatic int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,\n\t\t\t\tunsigned long *db)\n{\n\tu32 dr6 = 0;\n\tint i;\n\tu32 enable, rwlen;\n\n\tenable = dr7;\n\trwlen = dr7 >> 16;\n\tfor (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)\n\t\tif ((enable & 3) && (rwlen & 15) == type && db[i] == addr)\n\t\t\tdr6 |= (1 << i);\n\treturn dr6;\n}\n\nstatic void kvm_vcpu_check_singlestep(struct kvm_vcpu *vcpu, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\t/*\n\t * Use the \"raw\" value to see if TF was passed to the processor.\n\t * Note that the new value of the flags has not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tunsigned long rflags = kvm_x86_ops->get_rflags(vcpu);\n\n\tif (unlikely(rflags & X86_EFLAGS_TF)) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP) {\n\t\t\tkvm_run->debug.arch.dr6 = DR6_BS | DR6_FIXED_1;\n\t\t\tkvm_run->debug.arch.pc = vcpu->arch.singlestep_rip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t} else {\n\t\t\tvcpu->arch.emulate_ctxt.eflags &= ~X86_EFLAGS_TF;\n\t\t\t/*\n\t\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t\t * remaining contents of the DR6 register are never\n\t\t\t * cleared by the processor\".\n\t\t\t */\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= DR6_BS;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t}\n\t}\n}\n\nstatic bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tunsigned long eip = vcpu->arch.emulate_ctxt.eip;\n\tu32 dr6 = 0;\n\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;\n\t\t\tkvm_run->debug.arch.pc = kvm_rip_read(vcpu) +\n\t\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\n\t\tif (dr6 != 0) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\t*r = EMULATE_DONE;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint x86_emulate_instruction(struct kvm_vcpu *vcpu,\n\t\t\t    unsigned long cr2,\n\t\t\t    int emulation_type,\n\t\t\t    void *insn,\n\t\t\t    int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\tkvm_clear_exception_queue(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tinit_emulate_ctxt(vcpu);\n\n\t\t/*\n\t\t * We will reenter on the same instruction since\n\t\t * we do not set complete_userspace_io.  This does not\n\t\t * handle watchpoints yet, those would be handled in\n\t\t * the emulate_ops.\n\t\t */\n\t\tif (kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tctxt->interruptibility = 0;\n\t\tctxt->have_exception = false;\n\t\tctxt->perm_ok = false;\n\n\t\tctxt->ud = emulation_type & EMULTYPE_TRAP_UD;\n\n\t\tr = x86_decode_insn(ctxt, insn, insn_len);\n\n\t\ttrace_kvm_emulate_insn_start(vcpu);\n\t\t++vcpu->stat.insn_emulation;\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif (emulation_type & EMULTYPE_TRAP_UD)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\t\temulation_type))\n\t\t\t\treturn EMULATE_DONE;\n\t\t\tif (emulation_type & EMULTYPE_SKIP)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\treturn handle_emulation_failure(vcpu);\n\t\t}\n\t}\n\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tkvm_rip_write(vcpu, ctxt->_eip);\n\t\treturn EMULATE_DONE;\n\t}\n\n\tif (retry_instruction(ctxt, cr2, emulation_type))\n\t\treturn EMULATE_DONE;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn EMULATE_DONE;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn EMULATE_DONE;\n\n\t\treturn handle_emulation_failure(vcpu);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tinject_emulated_exception(vcpu);\n\t\tr = EMULATE_DONE;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = EMULATE_USER_EXIT;\n\t} else if (vcpu->mmio_needed) {\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = EMULATE_USER_EXIT;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = EMULATE_DONE;\n\n\tif (writeback) {\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (r == EMULATE_DONE)\n\t\t\tkvm_vcpu_check_singlestep(vcpu, &r);\n\t\tkvm_set_rflags(vcpu, ctxt->eflags);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(x86_emulate_instruction);\n\nint kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size, unsigned short port)\n{\n\tunsigned long val = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tint ret = emulator_pio_out_emulated(&vcpu->arch.emulate_ctxt,\n\t\t\t\t\t    size, port, &val, 1);\n\t/* do not return to emulator after return from userspace */\n\tvcpu->arch.pio.count = 0;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kvm_fast_pio_out);\n\nstatic void tsc_bad(void *info)\n{\n\t__this_cpu_write(cpu_tsc_khz, 0);\n}\n\nstatic void tsc_khz_changed(void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tunsigned long khz = 0;\n\n\tif (data)\n\t\tkhz = freq->new;\n\telse if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tkhz = cpufreq_quick_get(raw_smp_processor_id());\n\tif (!khz)\n\t\tkhz = tsc_khz;\n\t__this_cpu_write(cpu_tsc_khz, khz);\n}\n\nstatic int kvmclock_cpufreq_notifier(struct notifier_block *nb, unsigned long val,\n\t\t\t\t     void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i, send_ipi = 0;\n\n\t/*\n\t * We allow guests to temporarily run on slowing clocks,\n\t * provided we notify them after, or to run on accelerating\n\t * clocks, provided we notify them before.  Thus time never\n\t * goes backwards.\n\t *\n\t * However, we have a problem.  We can't atomically update\n\t * the frequency of a given CPU from this function; it is\n\t * merely a notifier, which can be called from any CPU.\n\t * Changing the TSC frequency at arbitrary points in time\n\t * requires a recomputation of local variables related to\n\t * the TSC for each VCPU.  We must flag these local variables\n\t * to be updated and be sure the update takes place with the\n\t * new frequency before any guests proceed.\n\t *\n\t * Unfortunately, the combination of hotplug CPU and frequency\n\t * change creates an intractable locking scenario; the order\n\t * of when these callouts happen is undefined with respect to\n\t * CPU hotplug, and they can race with each other.  As such,\n\t * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is\n\t * undefined; you can actually have a CPU frequency change take\n\t * place in between the computation of X and the setting of the\n\t * variable.  To protect against this problem, all updates of\n\t * the per_cpu tsc_khz variable are done in an interrupt\n\t * protected IPI, and all callers wishing to update the value\n\t * must wait for a synchronous IPI to complete (which is trivial\n\t * if the caller is on the CPU already).  This establishes the\n\t * necessary total order on variable updates.\n\t *\n\t * Note that because a guest time update may take place\n\t * anytime after the setting of the VCPU's request bit, the\n\t * correct TSC value must be set before the request.  However,\n\t * to ensure the update actually makes it to any guest which\n\t * starts running in hardware virtualization between the set\n\t * and the acquisition of the spinlock, we must also ping the\n\t * CPU after setting the request bit.\n\t *\n\t */\n\n\tif (val == CPUFREQ_PRECHANGE && freq->old > freq->new)\n\t\treturn 0;\n\tif (val == CPUFREQ_POSTCHANGE && freq->old < freq->new)\n\t\treturn 0;\n\n\tsmp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);\n\n\tspin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (vcpu->cpu != freq->cpu)\n\t\t\t\tcontinue;\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (vcpu->cpu != smp_processor_id())\n\t\t\t\tsend_ipi = 1;\n\t\t}\n\t}\n\tspin_unlock(&kvm_lock);\n\n\tif (freq->old < freq->new && send_ipi) {\n\t\t/*\n\t\t * We upscale the frequency.  Must make the guest\n\t\t * doesn't see old kvmclock values while running with\n\t\t * the new frequency, otherwise we risk the guest sees\n\t\t * time go backwards.\n\t\t *\n\t\t * In case we update the frequency for another cpu\n\t\t * (which might be in guest context) send an interrupt\n\t\t * to kick the cpu out of guest context.  Next time\n\t\t * guest context is entered kvmclock will be updated,\n\t\t * so the guest will not see stale values.\n\t\t */\n\t\tsmp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block kvmclock_cpufreq_notifier_block = {\n\t.notifier_call  = kvmclock_cpufreq_notifier\n};\n\nstatic int kvmclock_cpu_notifier(struct notifier_block *nfb,\n\t\t\t\t\tunsigned long action, void *hcpu)\n{\n\tunsigned int cpu = (unsigned long)hcpu;\n\n\tswitch (action) {\n\t\tcase CPU_ONLINE:\n\t\tcase CPU_DOWN_FAILED:\n\t\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n\t\t\tbreak;\n\t\tcase CPU_DOWN_PREPARE:\n\t\t\tsmp_call_function_single(cpu, tsc_bad, NULL, 1);\n\t\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block kvmclock_cpu_notifier_block = {\n\t.notifier_call  = kvmclock_cpu_notifier,\n\t.priority = -INT_MAX\n};\n\nstatic void kvm_timer_init(void)\n{\n\tint cpu;\n\n\tmax_tsc_khz = tsc_khz;\n\tregister_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {\n#ifdef CONFIG_CPU_FREQ\n\t\tstruct cpufreq_policy policy;\n\t\tmemset(&policy, 0, sizeof(policy));\n\t\tcpu = get_cpu();\n\t\tcpufreq_get_policy(&policy, cpu);\n\t\tif (policy.cpuinfo.max_freq)\n\t\t\tmax_tsc_khz = policy.cpuinfo.max_freq;\n\t\tput_cpu();\n#endif\n\t\tcpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t  CPUFREQ_TRANSITION_NOTIFIER);\n\t}\n\tpr_debug(\"kvm: max_tsc_khz = %ld\\n\", max_tsc_khz);\n\tfor_each_online_cpu(cpu)\n\t\tsmp_call_function_single(cpu, tsc_khz_changed, NULL, 1);\n}\n\nstatic DEFINE_PER_CPU(struct kvm_vcpu *, current_vcpu);\n\nint kvm_is_in_guest(void)\n{\n\treturn __this_cpu_read(current_vcpu) != NULL;\n}\n\nstatic int kvm_is_user_mode(void)\n{\n\tint user_mode = 3;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tuser_mode = kvm_x86_ops->get_cpl(__this_cpu_read(current_vcpu));\n\n\treturn user_mode != 0;\n}\n\nstatic unsigned long kvm_get_guest_ip(void)\n{\n\tunsigned long ip = 0;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tip = kvm_rip_read(__this_cpu_read(current_vcpu));\n\n\treturn ip;\n}\n\nstatic struct perf_guest_info_callbacks kvm_guest_cbs = {\n\t.is_in_guest\t\t= kvm_is_in_guest,\n\t.is_user_mode\t\t= kvm_is_user_mode,\n\t.get_guest_ip\t\t= kvm_get_guest_ip,\n};\n\nvoid kvm_before_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_before_handle_nmi);\n\nvoid kvm_after_handle_nmi(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}\nEXPORT_SYMBOL_GPL(kvm_after_handle_nmi);\n\nstatic void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\tint maxphyaddr = boot_cpu_data.x86_phys_bits;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\t /* Mask the reserved physical address bits. */\n\tmask = ((1ull << (51 - maxphyaddr + 1)) - 1) << maxphyaddr;\n\n\t/* Bit 62 is always reserved for 32bit host. */\n\tmask |= 0x3ull << 62;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (maxphyaddr == 52)\n\t\tmask &= ~1ull;\n#endif\n\n\tkvm_mmu_set_mmio_spte_mask(mask);\n}\n\n#ifdef CONFIG_X86_64\nstatic void pvclock_gtod_update_fn(struct work_struct *work)\n{\n\tstruct kvm *kvm;\n\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tspin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE, &vcpu->requests);\n\tatomic_set(&kvm_guest_has_master_clock, 0);\n\tspin_unlock(&kvm_lock);\n}\n\nstatic DECLARE_WORK(pvclock_gtod_work, pvclock_gtod_update_fn);\n\n/*\n * Notification about pvclock gtod data update.\n */\nstatic int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,\n\t\t\t       void *priv)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tstruct timekeeper *tk = priv;\n\n\tupdate_pvclock_gtod(tk);\n\n\t/* disable master clock if host does not trust, or does not\n\t * use, TSC clocksource\n\t */\n\tif (gtod->clock.vclock_mode != VCLOCK_TSC &&\n\t    atomic_read(&kvm_guest_has_master_clock) != 0)\n\t\tqueue_work(system_long_wq, &pvclock_gtod_work);\n\n\treturn 0;\n}\n\nstatic struct notifier_block pvclock_gtod_notifier = {\n\t.notifier_call = pvclock_gtod_notify,\n};\n#endif\n\nint kvm_arch_init(void *opaque)\n{\n\tint r;\n\tstruct kvm_x86_ops *ops = opaque;\n\n\tif (kvm_x86_ops) {\n\t\tprintk(KERN_ERR \"kvm: already loaded the other module\\n\");\n\t\tr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (!ops->cpu_has_kvm_support()) {\n\t\tprintk(KERN_ERR \"kvm: no hardware support\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (ops->disabled_by_bios()) {\n\t\tprintk(KERN_ERR \"kvm: disabled by bios\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tr = -ENOMEM;\n\tshared_msrs = alloc_percpu(struct kvm_shared_msrs);\n\tif (!shared_msrs) {\n\t\tprintk(KERN_ERR \"kvm: failed to allocate percpu kvm_shared_msrs\\n\");\n\t\tgoto out;\n\t}\n\n\tr = kvm_mmu_module_init();\n\tif (r)\n\t\tgoto out_free_percpu;\n\n\tkvm_set_mmio_spte_mask();\n\tkvm_init_msr_list();\n\n\tkvm_x86_ops = ops;\n\tkvm_mmu_set_mask_ptes(PT_USER_MASK, PT_ACCESSED_MASK,\n\t\t\tPT_DIRTY_MASK, PT64_NX_MASK, 0);\n\n\tkvm_timer_init();\n\n\tperf_register_guest_info_callbacks(&kvm_guest_cbs);\n\n\tif (cpu_has_xsave)\n\t\thost_xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);\n\n\tkvm_lapic_init();\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_register_notifier(&pvclock_gtod_notifier);\n#endif\n\n\treturn 0;\n\nout_free_percpu:\n\tfree_percpu(shared_msrs);\nout:\n\treturn r;\n}\n\nvoid kvm_arch_exit(void)\n{\n\tperf_unregister_guest_info_callbacks(&kvm_guest_cbs);\n\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tcpufreq_unregister_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n\tunregister_hotcpu_notifier(&kvmclock_cpu_notifier_block);\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_unregister_notifier(&pvclock_gtod_notifier);\n#endif\n\tkvm_x86_ops = NULL;\n\tkvm_mmu_module_exit();\n\tfree_percpu(shared_msrs);\n}\n\nint kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.halt_exits;\n\tif (irqchip_in_kernel(vcpu->kvm)) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = KVM_EXIT_HLT;\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_halt);\n\nint kvm_hv_hypercall(struct kvm_vcpu *vcpu)\n{\n\tu64 param, ingpa, outgpa, ret;\n\tuint16_t code, rep_idx, rep_cnt, res = HV_STATUS_SUCCESS, rep_done = 0;\n\tbool fast, longmode;\n\tint cs_db, cs_l;\n\n\t/*\n\t * hypercall generates UD from non zero cpl and real mode\n\t * per HYPER-V spec\n\t */\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0 || !is_protmode(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\tlongmode = is_long_mode(vcpu) && cs_l == 1;\n\n\tif (!longmode) {\n\t\tparam = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RAX) & 0xffffffff);\n\t\tingpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RBX) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RCX) & 0xffffffff);\n\t\toutgpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDI) << 32) |\n\t\t\t(kvm_register_read(vcpu, VCPU_REGS_RSI) & 0xffffffff);\n\t}\n#ifdef CONFIG_X86_64\n\telse {\n\t\tparam = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\t\tingpa = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\t\toutgpa = kvm_register_read(vcpu, VCPU_REGS_R8);\n\t}\n#endif\n\n\tcode = param & 0xffff;\n\tfast = (param >> 16) & 0x1;\n\trep_cnt = (param >> 32) & 0xfff;\n\trep_idx = (param >> 48) & 0xfff;\n\n\ttrace_kvm_hv_hypercall(code, fast, rep_cnt, rep_idx, ingpa, outgpa);\n\n\tswitch (code) {\n\tcase HV_X64_HV_NOTIFY_LONG_SPIN_WAIT:\n\t\tkvm_vcpu_on_spin(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tres = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tbreak;\n\t}\n\n\tret = res | (((u64)rep_done & 0xfff) << 32);\n\tif (longmode) {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t} else {\n\t\tkvm_register_write(vcpu, VCPU_REGS_RDX, ret >> 32);\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret & 0xffffffff);\n\t}\n\n\treturn 1;\n}\n\n/*\n * kvm_pv_kick_cpu_op:  Kick a vcpu.\n *\n * @apicid - apicid of vcpu to be kicked.\n */\nstatic void kvm_pv_kick_cpu_op(struct kvm *kvm, unsigned long flags, int apicid)\n{\n\tstruct kvm_lapic_irq lapic_irq;\n\n\tlapic_irq.shorthand = 0;\n\tlapic_irq.dest_mode = 0;\n\tlapic_irq.dest_id = apicid;\n\n\tlapic_irq.delivery_mode = APIC_DM_REMRD;\n\tkvm_irq_delivery_to_apic(kvm, 0, &lapic_irq, NULL);\n}\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint r = 1;\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\tif (!is_long_mode(vcpu)) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_hypercall);\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tchar instruction[3];\n\tunsigned long rip = kvm_rip_read(vcpu);\n\n\tkvm_x86_ops->patch_hypercall(vcpu, instruction);\n\n\treturn emulator_write_emulated(ctxt, rip, instruction, 3, NULL);\n}\n\n/*\n * Check if userspace requested an interrupt window, and that the\n * interrupt window is open.\n *\n * No need to exit to userspace if we already have an interrupt queued.\n */\nstatic int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn (!irqchip_in_kernel(vcpu->kvm) && !kvm_cpu_has_interrupt(vcpu) &&\n\t\tvcpu->run->request_interrupt_window &&\n\t\tkvm_arch_interrupt_allowed(vcpu));\n}\n\nstatic void post_kvm_run_save(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->if_flag = (kvm_get_rflags(vcpu) & X86_EFLAGS_IF) != 0;\n\tkvm_run->cr8 = kvm_get_cr8(vcpu);\n\tkvm_run->apic_base = kvm_get_apic_base(vcpu);\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_run->ready_for_interrupt_injection = 1;\n\telse\n\t\tkvm_run->ready_for_interrupt_injection =\n\t\t\tkvm_arch_interrupt_allowed(vcpu) &&\n\t\t\t!kvm_cpu_has_interrupt(vcpu) &&\n\t\t\t!kvm_event_needs_reinjection(vcpu);\n}\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}\n\nstatic void inject_pending_event(struct kvm_vcpu *vcpu)\n{\n\t/* try to reinject previous events if any */\n\tif (vcpu->arch.exception.pending) {\n\t\ttrace_kvm_inj_exception(vcpu->arch.exception.nr,\n\t\t\t\t\tvcpu->arch.exception.has_error_code,\n\t\t\t\t\tvcpu->arch.exception.error_code);\n\t\tkvm_x86_ops->queue_exception(vcpu, vcpu->arch.exception.nr,\n\t\t\t\t\t  vcpu->arch.exception.has_error_code,\n\t\t\t\t\t  vcpu->arch.exception.error_code,\n\t\t\t\t\t  vcpu->arch.exception.reinject);\n\t\treturn;\n\t}\n\n\tif (vcpu->arch.nmi_injected) {\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\treturn;\n\t}\n\n\tif (vcpu->arch.interrupt.pending) {\n\t\tkvm_x86_ops->set_irq(vcpu);\n\t\treturn;\n\t}\n\n\t/* try to inject new event if pending */\n\tif (vcpu->arch.nmi_pending) {\n\t\tif (kvm_x86_ops->nmi_allowed(vcpu)) {\n\t\t\t--vcpu->arch.nmi_pending;\n\t\t\tvcpu->arch.nmi_injected = true;\n\t\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\t}\n\t} else if (kvm_cpu_has_injectable_intr(vcpu)) {\n\t\tif (kvm_x86_ops->interrupt_allowed(vcpu)) {\n\t\t\tkvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu),\n\t\t\t\t\t    false);\n\t\t\tkvm_x86_ops->set_irq(vcpu);\n\t\t}\n\t}\n}\n\nstatic void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\n\nstatic void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tu64 eoi_exit_bitmap[4];\n\tu32 tmr[8];\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tmemset(eoi_exit_bitmap, 0, 32);\n\tmemset(tmr, 0, 32);\n\n\tkvm_ioapic_scan_entry(vcpu, eoi_exit_bitmap, tmr);\n\tkvm_x86_ops->load_eoi_exitmap(vcpu, eoi_exit_bitmap);\n\tkvm_apic_update_tmr(vcpu, tmr);\n}\n\nstatic int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win = !irqchip_in_kernel(vcpu->kvm) &&\n\t\tvcpu->run->request_interrupt_window;\n\tbool req_immediate_exit = false;\n\n\tif (vcpu->requests) {\n\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))\n\t\t\tkvm_mmu_unload(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu))\n\t\t\tkvm_x86_ops->tlb_flush(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_DEACTIVATE_FPU, vcpu)) {\n\t\t\tvcpu->fpu_active = 0;\n\t\t\tkvm_x86_ops->fpu_deactivate(vcpu);\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_handle_pmu_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {\n\t\tkvm_apic_accept_events(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinject_pending_event(vcpu);\n\n\t\t/* enable NMI/IRQ window open exits if needed */\n\t\tif (vcpu->arch.nmi_pending)\n\t\t\treq_immediate_exit =\n\t\t\t\tkvm_x86_ops->enable_nmi_window(vcpu) != 0;\n\t\telse if (kvm_cpu_has_injectable_intr(vcpu) || req_int_win)\n\t\t\treq_immediate_exit =\n\t\t\t\tkvm_x86_ops->enable_irq_window(vcpu) != 0;\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\t/*\n\t\t\t * Update architecture specific hints for APIC\n\t\t\t * virtual interrupt delivery.\n\t\t\t */\n\t\t\tif (kvm_x86_ops->hwapic_irr_update)\n\t\t\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\t\tkvm_lapic_find_highest_irr(vcpu));\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tkvm_load_guest_xcr0(vcpu);\n\n\tvcpu->mode = IN_GUEST_MODE;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\n\t/* We should set ->mode before check ->requests,\n\t * see the comment in make_all_cpus_request.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\tlocal_irq_disable();\n\n\tif (vcpu->mode == EXITING_GUEST_MODE || vcpu->requests\n\t    || need_resched() || signal_pending(current)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tif (req_immediate_exit)\n\t\tsmp_send_reschedule(vcpu->cpu);\n\n\tkvm_guest_enter();\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t}\n\n\ttrace_kvm_entry(vcpu->vcpu_id);\n\tkvm_x86_ops->run(vcpu);\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_guest_tsc = kvm_x86_ops->read_l1_tsc(vcpu,\n\t\t\t\t\t\t\t   native_read_tsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\t/* Interrupt is enabled by handle_external_intr() */\n\tkvm_x86_ops->handle_external_intr(vcpu);\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t * We must have an instruction between local_irq_enable() and\n\t * kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t * the interrupt shadow.  The stat.exits increment will do nicely.\n\t * But we need to prevent reordering, hence this barrier():\n\t */\n\tbarrier();\n\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = kvm_x86_ops->handle_exit(vcpu);\n\treturn r;\n\ncancel_injection:\n\tkvm_x86_ops->cancel_injection(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}\n\n\nstatic int __vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\n\tr = 1;\n\twhile (r > 0) {\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t    !vcpu->arch.apf.halted)\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\telse {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_vcpu_block(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t\tif (kvm_check_request(KVM_REQ_UNHALT, vcpu)) {\n\t\t\t\tkvm_apic_accept_events(vcpu);\n\t\t\t\tswitch(vcpu->arch.mp_state) {\n\t\t\t\tcase KVM_MP_STATE_HALTED:\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\t\t\t\tvcpu->arch.mp_state =\n\t\t\t\t\t\tKVM_MP_STATE_RUNNABLE;\n\t\t\t\tcase KVM_MP_STATE_RUNNABLE:\n\t\t\t\t\tvcpu->arch.apf.halted = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tr = -EINTR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (r <= 0)\n\t\t\tbreak;\n\n\t\tclear_bit(KVM_REQ_PENDING_TIMER, &vcpu->requests);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\n\t\tif (dm_request_for_irq_injection(vcpu)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t}\n\n\t\tkvm_check_async_pf_completion(vcpu);\n\n\t\tif (signal_pending(current)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.signal_exits;\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_resched(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t}\n\t}\n\n\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\n\treturn r;\n}\n\nstatic inline int complete_emulated_io(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\tr = emulate_instruction(vcpu, EMULTYPE_NO_DECODE);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (r != EMULATE_DONE)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu)\n{\n\tBUG_ON(!vcpu->arch.pio.count);\n\n\treturn complete_emulated_io(vcpu);\n}\n\n/*\n * Implements the following, as a state machine:\n *\n * read:\n *   for each fragment\n *     for each mmio piece in the fragment\n *       write gpa, len\n *       exit\n *       copy data\n *   execute insn\n *\n * write:\n *   for each fragment\n *     for each mmio piece in the fragment\n *       write gpa, len\n *       copy data\n *       exit\n */\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}\n\n\nint kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\n{\n\tint r;\n\tsigset_t sigsaved;\n\n\tif (!tsk_used_math(current) && init_fpu(current))\n\t\treturn -ENOMEM;\n\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\n\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {\n\t\tkvm_vcpu_block(vcpu);\n\t\tkvm_apic_accept_events(vcpu);\n\t\tclear_bit(KVM_REQ_UNHALT, &vcpu->requests);\n\t\tr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\t/* re-sync apic's tpr */\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tif (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.complete_userspace_io)) {\n\t\tint (*cui)(struct kvm_vcpu *) = vcpu->arch.complete_userspace_io;\n\t\tvcpu->arch.complete_userspace_io = NULL;\n\t\tr = cui(vcpu);\n\t\tif (r <= 0)\n\t\t\tgoto out;\n\t} else\n\t\tWARN_ON(vcpu->arch.pio.count || vcpu->mmio_needed);\n\n\tr = __vcpu_run(vcpu);\n\nout:\n\tpost_kvm_run_save(vcpu);\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn r;\n}\n\nint kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tif (vcpu->arch.emulate_regs_need_sync_to_vcpu) {\n\t\t/*\n\t\t * We are here if userspace calls get_regs() in the middle of\n\t\t * instruction emulation. Registers state needs to be copied\n\t\t * back from emulation context to vcpu. Userspace shouldn't do\n\t\t * that usually, but some bad designed PV devices (vmware\n\t\t * backdoor interface) need this to work\n\t\t */\n\t\temulator_writeback_register_cache(&vcpu->arch.emulate_ctxt);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t}\n\tregs->rax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tregs->rbx = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\tregs->rcx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tregs->rdx = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\tregs->rsi = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\tregs->rdi = kvm_register_read(vcpu, VCPU_REGS_RDI);\n\tregs->rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tregs->rbp = kvm_register_read(vcpu, VCPU_REGS_RBP);\n#ifdef CONFIG_X86_64\n\tregs->r8 = kvm_register_read(vcpu, VCPU_REGS_R8);\n\tregs->r9 = kvm_register_read(vcpu, VCPU_REGS_R9);\n\tregs->r10 = kvm_register_read(vcpu, VCPU_REGS_R10);\n\tregs->r11 = kvm_register_read(vcpu, VCPU_REGS_R11);\n\tregs->r12 = kvm_register_read(vcpu, VCPU_REGS_R12);\n\tregs->r13 = kvm_register_read(vcpu, VCPU_REGS_R13);\n\tregs->r14 = kvm_register_read(vcpu, VCPU_REGS_R14);\n\tregs->r15 = kvm_register_read(vcpu, VCPU_REGS_R15);\n#endif\n\n\tregs->rip = kvm_rip_read(vcpu);\n\tregs->rflags = kvm_get_rflags(vcpu);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = true;\n\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, regs->rax);\n\tkvm_register_write(vcpu, VCPU_REGS_RBX, regs->rbx);\n\tkvm_register_write(vcpu, VCPU_REGS_RCX, regs->rcx);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, regs->rdx);\n\tkvm_register_write(vcpu, VCPU_REGS_RSI, regs->rsi);\n\tkvm_register_write(vcpu, VCPU_REGS_RDI, regs->rdi);\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, regs->rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RBP, regs->rbp);\n#ifdef CONFIG_X86_64\n\tkvm_register_write(vcpu, VCPU_REGS_R8, regs->r8);\n\tkvm_register_write(vcpu, VCPU_REGS_R9, regs->r9);\n\tkvm_register_write(vcpu, VCPU_REGS_R10, regs->r10);\n\tkvm_register_write(vcpu, VCPU_REGS_R11, regs->r11);\n\tkvm_register_write(vcpu, VCPU_REGS_R12, regs->r12);\n\tkvm_register_write(vcpu, VCPU_REGS_R13, regs->r13);\n\tkvm_register_write(vcpu, VCPU_REGS_R14, regs->r14);\n\tkvm_register_write(vcpu, VCPU_REGS_R15, regs->r15);\n#endif\n\n\tkvm_rip_write(vcpu, regs->rip);\n\tkvm_set_rflags(vcpu, regs->rflags);\n\n\tvcpu->arch.exception.pending = false;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nvoid kvm_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\t*db = cs.db;\n\t*l = cs.l;\n}\nEXPORT_SYMBOL_GPL(kvm_get_cs_db_l_bits);\n\nint kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tstruct desc_ptr dt;\n\n\tkvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_get_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_get_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_get_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_get_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_get_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_get_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_get_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tsregs->idt.limit = dt.size;\n\tsregs->idt.base = dt.address;\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tsregs->gdt.limit = dt.size;\n\tsregs->gdt.base = dt.address;\n\n\tsregs->cr0 = kvm_read_cr0(vcpu);\n\tsregs->cr2 = vcpu->arch.cr2;\n\tsregs->cr3 = kvm_read_cr3(vcpu);\n\tsregs->cr4 = kvm_read_cr4(vcpu);\n\tsregs->cr8 = kvm_get_cr8(vcpu);\n\tsregs->efer = vcpu->arch.efer;\n\tsregs->apic_base = kvm_get_apic_base(vcpu);\n\n\tmemset(sregs->interrupt_bitmap, 0, sizeof sregs->interrupt_bitmap);\n\n\tif (vcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft)\n\t\tset_bit(vcpu->arch.interrupt.nr,\n\t\t\t(unsigned long *)sregs->interrupt_bitmap);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tkvm_apic_accept_events(vcpu);\n\tif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED &&\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted)\n\t\tmp_state->mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tmp_state->mp_state = vcpu->arch.mp_state;\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tif (!kvm_vcpu_has_lapic(vcpu) &&\n\t    mp_state->mp_state != KVM_MP_STATE_RUNNABLE)\n\t\treturn -EINVAL;\n\n\tif (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t\tset_bit(KVM_APIC_SIPI, &vcpu->arch.apic->pending_events);\n\t} else\n\t\tvcpu->arch.mp_state = mp_state->mp_state;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 0;\n}\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\n\tif (ret)\n\t\treturn EMULATE_FAIL;\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn EMULATE_DONE;\n}\nEXPORT_SYMBOL_GPL(kvm_task_switch);\n\nint kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tint mmu_reset_needed = 0;\n\tint pending_vec, max_bits, idx;\n\tstruct desc_ptr dt;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (sregs->cr4 & X86_CR4_OSXSAVE))\n\t\treturn -EINVAL;\n\n\tdt.size = sregs->idt.limit;\n\tdt.address = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.size = sregs->gdt.limit;\n\tdt.address = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tkvm_set_apic_base(vcpu, sregs->apic_base);\n\n\tmmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (sregs->cr4 & X86_CR4_OSXSAVE)\n\t\tkvm_update_cpuid(vcpu);\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu)) {\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tmmu_reset_needed = 1;\n\t}\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tmax_bits = KVM_NR_INTERRUPTS;\n\tpending_vec = find_first_bit(\n\t\t(const unsigned long *)sregs->interrupt_bitmap, max_bits);\n\tif (pending_vec < max_bits) {\n\t\tkvm_queue_interrupt(vcpu, pending_vec, false);\n\t\tpr_debug(\"Set back pending irq %d\\n\", pending_vec);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tupdate_cr8_intercept(vcpu);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !is_protmode(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_guest_debug *dbg)\n{\n\tunsigned long rflags;\n\tint i, r;\n\n\tif (dbg->control & (KVM_GUESTDBG_INJECT_DB | KVM_GUESTDBG_INJECT_BP)) {\n\t\tr = -EBUSY;\n\t\tif (vcpu->arch.exception.pending)\n\t\t\tgoto out;\n\t\tif (dbg->control & KVM_GUESTDBG_INJECT_DB)\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\telse\n\t\t\tkvm_queue_exception(vcpu, BP_VECTOR);\n\t}\n\n\t/*\n\t * Read rflags as long as potentially injected trace flags are still\n\t * filtered out.\n\t */\n\trflags = kvm_get_rflags(vcpu);\n\n\tvcpu->guest_debug = dbg->control;\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_ENABLE))\n\t\tvcpu->guest_debug = 0;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; ++i)\n\t\t\tvcpu->arch.eff_db[i] = dbg->arch.debugreg[i];\n\t\tvcpu->arch.guest_debug_dr7 = dbg->arch.debugreg[7];\n\t} else {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\tkvm_update_dr7(vcpu);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvcpu->arch.singlestep_rip = kvm_rip_read(vcpu) +\n\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\t/*\n\t * Trigger an rflags update that will inject or remove the trace\n\t * flags.\n\t */\n\tkvm_set_rflags(vcpu, rflags);\n\n\tkvm_x86_ops->update_db_bp_intercept(vcpu);\n\n\tr = 0;\n\nout:\n\n\treturn r;\n}\n\n/*\n * Translate a guest virtual address to a guest physical address.\n */\nint kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_translation *tr)\n{\n\tunsigned long vaddr = tr->linear_address;\n\tgpa_t gpa;\n\tint idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tgpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\ttr->physical_address = gpa;\n\ttr->valid = gpa != UNMAPPED_GVA;\n\ttr->writeable = 1;\n\ttr->usermode = 0;\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct i387_fxsave_struct *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave;\n\n\tmemcpy(fpu->fpr, fxsave->st_space, 128);\n\tfpu->fcw = fxsave->cwd;\n\tfpu->fsw = fxsave->swd;\n\tfpu->ftwx = fxsave->twd;\n\tfpu->last_opcode = fxsave->fop;\n\tfpu->last_ip = fxsave->rip;\n\tfpu->last_dp = fxsave->rdp;\n\tmemcpy(fpu->xmm, fxsave->xmm_space, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct i387_fxsave_struct *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave;\n\n\tmemcpy(fxsave->st_space, fpu->fpr, 128);\n\tfxsave->cwd = fpu->fcw;\n\tfxsave->swd = fpu->fsw;\n\tfxsave->twd = fpu->ftwx;\n\tfxsave->fop = fpu->last_opcode;\n\tfxsave->rip = fpu->last_ip;\n\tfxsave->rdp = fpu->last_dp;\n\tmemcpy(fxsave->xmm_space, fpu->xmm, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}\n\nint fx_init(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\n\terr = fpu_alloc(&vcpu->arch.guest_fpu);\n\tif (err)\n\t\treturn err;\n\n\tfpu_finit(&vcpu->arch.guest_fpu);\n\n\t/*\n\t * Ensure guest xcr0 is valid for loading\n\t */\n\tvcpu->arch.xcr0 = XSTATE_FP;\n\n\tvcpu->arch.cr0 |= X86_CR0_ET;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fx_init);\n\nstatic void fx_free(struct kvm_vcpu *vcpu)\n{\n\tfpu_free(&vcpu->arch.guest_fpu);\n}\n\nvoid kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\t/*\n\t * Restore all possible states in the guest,\n\t * and assume host would use all available bits.\n\t * Guest xcr0 would be loaded later.\n\t */\n\tkvm_put_guest_xcr0(vcpu);\n\tvcpu->guest_fpu_loaded = 1;\n\t__kernel_fpu_begin();\n\tfpu_restore_checking(&vcpu->arch.guest_fpu);\n\ttrace_kvm_fpu(1);\n}\n\nvoid kvm_put_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tkvm_put_guest_xcr0(vcpu);\n\n\tif (!vcpu->guest_fpu_loaded)\n\t\treturn;\n\n\tvcpu->guest_fpu_loaded = 0;\n\tfpu_save_init(&vcpu->arch.guest_fpu);\n\t__kernel_fpu_end();\n\t++vcpu->stat.fpu_reload;\n\tkvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);\n\ttrace_kvm_fpu(0);\n}\n\nvoid kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tkvmclock_reset(vcpu);\n\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\n\tfx_free(vcpu);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}\n\nstruct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,\n\t\t\t\t\t\tunsigned int id)\n{\n\tif (check_tsc_unstable() && atomic_read(&kvm->online_vcpus) != 0)\n\t\tprintk_once(KERN_WARNING\n\t\t\"kvm: SMP vm created on host with unstable TSC; \"\n\t\t\"guest TSC will not be reliable\\n\");\n\treturn kvm_x86_ops->vcpu_create(kvm, id);\n}\n\nint kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tvcpu->arch.mtrr_state.have_fixed = 1;\n\tr = vcpu_load(vcpu);\n\tif (r)\n\t\treturn r;\n\tkvm_vcpu_reset(vcpu);\n\tkvm_mmu_setup(vcpu);\n\tvcpu_put(vcpu);\n\n\treturn r;\n}\n\nint kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct msr_data msr;\n\n\tr = vcpu_load(vcpu);\n\tif (r)\n\t\treturn r;\n\tmsr.data = 0x0;\n\tmsr.index = MSR_IA32_TSC;\n\tmsr.host_initiated = true;\n\tkvm_write_tsc(vcpu, &msr);\n\tvcpu_put(vcpu);\n\n\treturn r;\n}\n\nvoid kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->arch.apf.msr_val = 0;\n\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n\n\tfx_free(vcpu);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}\n\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tvcpu->arch.dr6 = DR6_FIXED_1;\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tkvm_pmu_reset(vcpu);\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tkvm_x86_ops->vcpu_reset(vcpu);\n}\n\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, unsigned int vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}\n\nint kvm_arch_hardware_enable(void *garbage)\n{\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tint ret;\n\tu64 local_tsc;\n\tu64 max_tsc = 0;\n\tbool stable, backwards_tsc = false;\n\n\tkvm_shared_msr_cpu_online();\n\tret = kvm_x86_ops->hardware_enable(garbage);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tlocal_tsc = native_read_tsc();\n\tstable = !check_tsc_unstable();\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!stable && vcpu->cpu == smp_processor_id())\n\t\t\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t\t\tif (stable && vcpu->arch.last_host_tsc > local_tsc) {\n\t\t\t\tbackwards_tsc = true;\n\t\t\t\tif (vcpu->arch.last_host_tsc > max_tsc)\n\t\t\t\t\tmax_tsc = vcpu->arch.last_host_tsc;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Sometimes, even reliable TSCs go backwards.  This happens on\n\t * platforms that reset TSC during suspend or hibernate actions, but\n\t * maintain synchronization.  We must compensate.  Fortunately, we can\n\t * detect that condition here, which happens early in CPU bringup,\n\t * before any KVM threads can be running.  Unfortunately, we can't\n\t * bring the TSCs fully up to date with real time, as we aren't yet far\n\t * enough into CPU bringup that we know how much real time has actually\n\t * elapsed; our helper function, get_kernel_ns() will be using boot\n\t * variables that haven't been updated yet.\n\t *\n\t * So we simply find the maximum observed TSC above, then record the\n\t * adjustment to TSC in each VCPU.  When the VCPU later gets loaded,\n\t * the adjustment will be applied.  Note that we accumulate\n\t * adjustments, in case multiple suspend cycles happen before some VCPU\n\t * gets a chance to run again.  In the event that no KVM threads get a\n\t * chance to run, we will miss the entire elapsed period, as we'll have\n\t * reset last_host_tsc, so VCPUs will not have the TSC adjusted and may\n\t * loose cycle time.  This isn't too big a deal, since the loss will be\n\t * uniform across all VCPUs (not to mention the scenario is extremely\n\t * unlikely). It is possible that a second hibernate recovery happens\n\t * much faster than a first, causing the observed TSC here to be\n\t * smaller; this would require additional padding adjustment, which is\n\t * why we set last_host_tsc to the local tsc observed here.\n\t *\n\t * N.B. - this code below runs only on platforms with reliable TSC,\n\t * as that is the only way backwards_tsc is set above.  Also note\n\t * that this runs for ALL vcpus, which is not a bug; all VCPUs should\n\t * have the same delta_cyc adjustment applied if backwards_tsc\n\t * is detected.  Note further, this adjustment is only done once,\n\t * as we reset last_host_tsc on all VCPUs to stop this from being\n\t * called multiple times (one for each physical CPU bringup).\n\t *\n\t * Platforms with unreliable TSCs don't have to deal with this, they\n\t * will be compensated by the logic in vcpu_load, which sets the TSC to\n\t * catchup mode.  This will catchup all VCPUs to real time, but cannot\n\t * guarantee that they stay in perfect synchronization.\n\t */\n\tif (backwards_tsc) {\n\t\tu64 delta_cyc = max_tsc - local_tsc;\n\t\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\t\tvcpu->arch.tsc_offset_adjustment += delta_cyc;\n\t\t\t\tvcpu->arch.last_host_tsc = local_tsc;\n\t\t\t\tset_bit(KVM_REQ_MASTERCLOCK_UPDATE,\n\t\t\t\t\t&vcpu->requests);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have to disable TSC offset matching.. if you were\n\t\t\t * booting a VM while issuing an S4 host suspend....\n\t\t\t * you may have some problem.  Solving this issue is\n\t\t\t * left as an exercise to the reader.\n\t\t\t */\n\t\t\tkvm->arch.last_tsc_nsec = 0;\n\t\t\tkvm->arch.last_tsc_write = 0;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\nvoid kvm_arch_hardware_disable(void *garbage)\n{\n\tkvm_x86_ops->hardware_disable(garbage);\n\tdrop_user_return_notifiers(garbage);\n}\n\nint kvm_arch_hardware_setup(void)\n{\n\treturn kvm_x86_ops->hardware_setup();\n}\n\nvoid kvm_arch_hardware_unsetup(void)\n{\n\tkvm_x86_ops->hardware_unsetup();\n}\n\nvoid kvm_arch_check_processor_compat(void *rtn)\n{\n\tkvm_x86_ops->check_processor_compatibility(rtn);\n}\n\nbool kvm_vcpu_compatible(struct kvm_vcpu *vcpu)\n{\n\treturn irqchip_in_kernel(vcpu->kvm) == (vcpu->arch.apic != NULL);\n}\n\nstruct static_key kvm_no_apic_vcpu __read_mostly;\n\nint kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tstruct kvm *kvm;\n\tint r;\n\n\tBUG_ON(vcpu->kvm == NULL);\n\tkvm = vcpu->kvm;\n\n\tvcpu->arch.pv.pv_unhalted = false;\n\tvcpu->arch.emulate_ctxt.ops = &emulate_ops;\n\tif (!irqchip_in_kernel(kvm) || kvm_vcpu_is_bsp(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page) {\n\t\tr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tvcpu->arch.pio_data = page_address(page);\n\n\tkvm_set_tsc_khz(vcpu, max_tsc_khz);\n\n\tr = kvm_mmu_create(vcpu);\n\tif (r < 0)\n\t\tgoto fail_free_pio_data;\n\n\tif (irqchip_in_kernel(kvm)) {\n\t\tr = kvm_create_lapic(vcpu);\n\t\tif (r < 0)\n\t\t\tgoto fail_mmu_destroy;\n\t} else\n\t\tstatic_key_slow_inc(&kvm_no_apic_vcpu);\n\n\tvcpu->arch.mce_banks = kzalloc(KVM_MAX_MCE_BANKS * sizeof(u64) * 4,\n\t\t\t\t       GFP_KERNEL);\n\tif (!vcpu->arch.mce_banks) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_lapic;\n\t}\n\tvcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;\n\n\tif (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask, GFP_KERNEL)) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_mce_banks;\n\t}\n\n\tr = fx_init(vcpu);\n\tif (r)\n\t\tgoto fail_free_wbinvd_dirty_mask;\n\n\tvcpu->arch.ia32_tsc_adjust_msr = 0x0;\n\tvcpu->arch.pv_time_enabled = false;\n\n\tvcpu->arch.guest_supported_xcr0 = 0;\n\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\tkvm_async_pf_hash_reset(vcpu);\n\tkvm_pmu_init(vcpu);\n\n\treturn 0;\nfail_free_wbinvd_dirty_mask:\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\nfail_free_mce_banks:\n\tkfree(vcpu->arch.mce_banks);\nfail_free_lapic:\n\tkvm_free_lapic(vcpu);\nfail_mmu_destroy:\n\tkvm_mmu_destroy(vcpu);\nfail_free_pio_data:\n\tfree_page((unsigned long)vcpu->arch.pio_data);\nfail:\n\treturn r;\n}\n\nvoid kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\tstatic_key_slow_dec(&kvm_no_apic_vcpu);\n}\n\nint kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tatomic_set(&kvm->arch.noncoherent_dma_count, 0);\n\n\t/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\t/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\treturn 0;\n}\n\nstatic void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}\n\nstatic void kvm_free_vcpus(struct kvm *kvm)\n{\n\tunsigned int i;\n\tstruct kvm_vcpu *vcpu;\n\n\t/*\n\t * Unpin any mmu pages first.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_unload_vcpu_mmu(vcpu);\n\t}\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_arch_vcpu_free(vcpu);\n\n\tmutex_lock(&kvm->lock);\n\tfor (i = 0; i < atomic_read(&kvm->online_vcpus); i++)\n\t\tkvm->vcpus[i] = NULL;\n\n\tatomic_set(&kvm->online_vcpus, 0);\n\tmutex_unlock(&kvm->lock);\n}\n\nvoid kvm_arch_sync_events(struct kvm *kvm)\n{\n\tkvm_free_all_assigned_devices(kvm);\n\tkvm_free_pit(kvm);\n}\n\nvoid kvm_arch_destroy_vm(struct kvm *kvm)\n{\n\tif (current->mm == kvm->mm) {\n\t\t/*\n\t\t * Free memory regions allocated on behalf of userspace,\n\t\t * unless the the memory map has changed due to process exit\n\t\t * or fd copying.\n\t\t */\n\t\tstruct kvm_userspace_memory_region mem;\n\t\tmemset(&mem, 0, sizeof(mem));\n\t\tmem.slot = APIC_ACCESS_PAGE_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\n\t\tmem.slot = IDENTITY_PAGETABLE_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\n\t\tmem.slot = TSS_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\t}\n\tkvm_iommu_unmap_guest(kvm);\n\tkfree(kvm->arch.vpic);\n\tkfree(kvm->arch.vioapic);\n\tkvm_free_vcpus(kvm);\n\tif (kvm->arch.apic_access_page)\n\t\tput_page(kvm->arch.apic_access_page);\n\tif (kvm->arch.ept_identity_pagetable)\n\t\tput_page(kvm->arch.ept_identity_pagetable);\n\tkfree(rcu_dereference_check(kvm->arch.apic_map, 1));\n}\n\nvoid kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *free,\n\t\t\t   struct kvm_memory_slot *dont)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tif (!dont || free->arch.rmap[i] != dont->arch.rmap[i]) {\n\t\t\tkvm_kvfree(free->arch.rmap[i]);\n\t\t\tfree->arch.rmap[i] = NULL;\n\t\t}\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tif (!dont || free->arch.lpage_info[i - 1] !=\n\t\t\t     dont->arch.lpage_info[i - 1]) {\n\t\t\tkvm_kvfree(free->arch.lpage_info[i - 1]);\n\t\t\tfree->arch.lpage_info[i - 1] = NULL;\n\t\t}\n\t}\n}\n\nint kvm_arch_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,\n\t\t\t    unsigned long npages)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tunsigned long ugfn;\n\t\tint lpages;\n\t\tint level = i + 1;\n\n\t\tlpages = gfn_to_index(slot->base_gfn + npages - 1,\n\t\t\t\t      slot->base_gfn, level) + 1;\n\n\t\tslot->arch.rmap[i] =\n\t\t\tkvm_kvzalloc(lpages * sizeof(*slot->arch.rmap[i]));\n\t\tif (!slot->arch.rmap[i])\n\t\t\tgoto out_free;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tslot->arch.lpage_info[i - 1] = kvm_kvzalloc(lpages *\n\t\t\t\t\tsizeof(*slot->arch.lpage_info[i - 1]));\n\t\tif (!slot->arch.lpage_info[i - 1])\n\t\t\tgoto out_free;\n\n\t\tif (slot->base_gfn & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tslot->arch.lpage_info[i - 1][0].write_count = 1;\n\t\tif ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tslot->arch.lpage_info[i - 1][lpages - 1].write_count = 1;\n\t\tugfn = slot->userspace_addr >> PAGE_SHIFT;\n\t\t/*\n\t\t * If the gfn and userspace address are not aligned wrt each\n\t\t * other, or if explicitly asked to, disable large page\n\t\t * support for this slot\n\t\t */\n\t\tif ((slot->base_gfn ^ ugfn) & (KVM_PAGES_PER_HPAGE(level) - 1) ||\n\t\t    !kvm_largepages_enabled()) {\n\t\t\tunsigned long j;\n\n\t\t\tfor (j = 0; j < lpages; ++j)\n\t\t\t\tslot->arch.lpage_info[i - 1][j].write_count = 1;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_free:\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvm_kvfree(slot->arch.rmap[i]);\n\t\tslot->arch.rmap[i] = NULL;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tkvm_kvfree(slot->arch.lpage_info[i - 1]);\n\t\tslot->arch.lpage_info[i - 1] = NULL;\n\t}\n\treturn -ENOMEM;\n}\n\nvoid kvm_arch_memslots_updated(struct kvm *kvm)\n{\n\t/*\n\t * memslots->generation has been incremented.\n\t * mmio generation may have reached its maximum value.\n\t */\n\tkvm_mmu_invalidate_mmio_sptes(kvm);\n}\n\nint kvm_arch_prepare_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *memslot,\n\t\t\t\tstruct kvm_userspace_memory_region *mem,\n\t\t\t\tenum kvm_mr_change change)\n{\n\t/*\n\t * Only private memory slots need to be mapped here since\n\t * KVM_SET_MEMORY_REGION ioctl is no longer supported.\n\t */\n\tif ((memslot->id >= KVM_USER_MEM_SLOTS) && (change == KVM_MR_CREATE)) {\n\t\tunsigned long userspace_addr;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\tuserspace_addr = vm_mmap(NULL, 0, memslot->npages * PAGE_SIZE,\n\t\t\t\t\t PROT_READ | PROT_WRITE,\n\t\t\t\t\t MAP_SHARED | MAP_ANONYMOUS, 0);\n\n\t\tif (IS_ERR((void *)userspace_addr))\n\t\t\treturn PTR_ERR((void *)userspace_addr);\n\n\t\tmemslot->userspace_addr = userspace_addr;\n\t}\n\n\treturn 0;\n}\n\nvoid kvm_arch_commit_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_userspace_memory_region *mem,\n\t\t\t\tconst struct kvm_memory_slot *old,\n\t\t\t\tenum kvm_mr_change change)\n{\n\n\tint nr_mmu_pages = 0;\n\n\tif ((mem->slot >= KVM_USER_MEM_SLOTS) && (change == KVM_MR_DELETE)) {\n\t\tint ret;\n\n\t\tret = vm_munmap(old->userspace_addr,\n\t\t\t\told->npages * PAGE_SIZE);\n\t\tif (ret < 0)\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"kvm_vm_ioctl_set_memory_region: \"\n\t\t\t       \"failed to munmap memory\\n\");\n\t}\n\n\tif (!kvm->arch.n_requested_mmu_pages)\n\t\tnr_mmu_pages = kvm_mmu_calculate_mmu_pages(kvm);\n\n\tif (nr_mmu_pages)\n\t\tkvm_mmu_change_mmu_pages(kvm, nr_mmu_pages);\n\t/*\n\t * Write protect all pages for dirty logging.\n\t * Existing largepage mappings are destroyed here and new ones will\n\t * not be created until the end of the logging.\n\t */\n\tif ((change != KVM_MR_DELETE) && (mem->flags & KVM_MEM_LOG_DIRTY_PAGES))\n\t\tkvm_mmu_slot_remove_write_access(kvm, mem->slot);\n}\n\nvoid kvm_arch_flush_shadow_all(struct kvm *kvm)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}\n\nvoid kvm_arch_flush_shadow_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}\n\nint kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t!vcpu->arch.apf.halted)\n\t\t|| !list_empty_careful(&vcpu->async_pf.done)\n\t\t|| kvm_apic_has_events(vcpu)\n\t\t|| vcpu->arch.pv.pv_unhalted\n\t\t|| atomic_read(&vcpu->arch.nmi_queued) ||\n\t\t(kvm_arch_interrupt_allowed(vcpu) &&\n\t\t kvm_cpu_has_interrupt(vcpu));\n}\n\nint kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_exiting_guest_mode(vcpu) == IN_GUEST_MODE;\n}\n\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}\n\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\tunsigned long current_rip = kvm_rip_read(vcpu) +\n\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\treturn current_rip == linear_rip;\n}\nEXPORT_SYMBOL_GPL(kvm_is_linear_rip);\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops->get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}\nEXPORT_SYMBOL_GPL(kvm_get_rflags);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_set_rflags);\n\nvoid kvm_arch_async_page_ready(struct kvm_vcpu *vcpu, struct kvm_async_pf *work)\n{\n\tint r;\n\n\tif ((vcpu->arch.mmu.direct_map != work->arch.direct_map) ||\n\t      work->wakeup_all)\n\t\treturn;\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r))\n\t\treturn;\n\n\tif (!vcpu->arch.mmu.direct_map &&\n\t      work->arch.cr3 != vcpu->arch.mmu.get_cr3(vcpu))\n\t\treturn;\n\n\tvcpu->arch.mmu.page_fault(vcpu, work->gva, 0, true);\n}\n\nstatic inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}\n\nstatic inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (roundup_pow_of_two(ASYNC_PF_PER_VCPU) - 1);\n}\n\nstatic void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\twhile (vcpu->arch.apf.gfns[key] != ~0)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\tvcpu->arch.apf.gfns[key] = gfn;\n}\n\nstatic u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tint i;\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU) &&\n\t\t     (vcpu->arch.apf.gfns[key] != gfn &&\n\t\t      vcpu->arch.apf.gfns[key] != ~0); i++)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\treturn key;\n}\n\nbool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;\n}\n\nstatic void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}\n\nstatic int apf_put_user(struct kvm_vcpu *vcpu, u32 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &val,\n\t\t\t\t      sizeof(val));\n}\n\nvoid kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_not_present(work->arch.token, work->gva);\n\tkvm_add_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif (!(vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED) ||\n\t    (vcpu->arch.apf.send_user_only &&\n\t     kvm_x86_ops->get_cpl(vcpu) == 0))\n\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\telse if (!apf_put_user(vcpu, KVM_PV_REASON_PAGE_NOT_PRESENT)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t}\n}\n\nvoid kvm_arch_async_page_present(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_ready(work->arch.token, work->gva);\n\tif (work->wakeup_all)\n\t\twork->arch.token = ~0; /* broadcast wakeup */\n\telse\n\t\tkvm_del_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif ((vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED) &&\n\t    !apf_put_user(vcpu, KVM_PV_REASON_PAGE_READY)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t}\n\tvcpu->arch.apf.halted = false;\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n}\n\nbool kvm_arch_can_inject_async_page_present(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.apf.msr_val & KVM_ASYNC_PF_ENABLED))\n\t\treturn true;\n\telse\n\t\treturn !kvm_event_needs_reinjection(vcpu) &&\n\t\t\tkvm_x86_ops->interrupt_allowed(vcpu);\n}\n\nvoid kvm_arch_register_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_register_noncoherent_dma);\n\nvoid kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_unregister_noncoherent_dma);\n\nbool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_has_noncoherent_dma);\n\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_exit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_inj_virq);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_page_fault);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_msr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_cr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmrun);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit_inject);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intr_vmexit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_invlpga);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_skinit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intercepts);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_write_tsc_offset);\n"], "buggy_code_start_loc": [1695, 37, 3217], "buggy_code_end_loc": [1769, 80, 6136], "fixing_code_start_loc": [1694, 37, 3217], "fixing_code_end_loc": [1772, 80, 6097], "type": "CWE-20", "message": "The KVM subsystem in the Linux kernel through 3.12.5 allows local users to gain privileges or cause a denial of service (system crash) via a VAPIC synchronization operation involving a page-end address.", "other": {"cve": {"id": "CVE-2013-6368", "sourceIdentifier": "secalert@redhat.com", "published": "2013-12-14T18:08:45.653", "lastModified": "2023-02-13T04:49:26.957", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The KVM subsystem in the Linux kernel through 3.12.5 allows local users to gain privileges or cause a denial of service (system crash) via a VAPIC synchronization operation involving a page-end address."}, {"lang": "es", "value": "El subsistema de KVM en el kernel de Linux hasta 3.12.5 permite a usuarios locales conseguir privilegios o causar una denegaci\u00f3n de servicio (ca\u00edda del sistema) a trav\u00e9s de una operaci\u00f3n de sincronizaci\u00f3n VAPIC que implica una direcci\u00f3n de final de p\u00e1gina"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 1.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.12.5", "matchCriteriaId": "AEE329D0-23A3-4E91-9A33-E14415E60BA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "0A498D90-BB99-405E-9FA6-1FBFE179787E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "D0D32776-8ADB-4E79-846A-C0C99FED19E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B7D01673-D13F-487F-81B6-1279C187277E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "ADB27A3E-78E4-40F7-9716-A1099B0D85FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "16E7136A-A8A6-4BF5-AF5D-AFB5C7A10712"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "6FE127AC-E61D-427A-B998-D60DF5AABA21"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "3819FF99-AEC5-4466-8542-D395419E4308"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "E621FA1A-464B-4D2A-A0D6-EDA475A3709B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "B760B422-EA11-43AB-B6D2-CA54E7229663"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "D2CA7BBC-917C-4F31-A442-465C30444836"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "AE778000-4FD5-4032-86CE-5930EF4CB7C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "B3344EEB-F037-48FE-81DC-67F6384F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "0244B0CA-9C67-4F06-BFBA-1F257112AC08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.13:*:*:*:*:*:*:*", "matchCriteriaId": "2148C13F-4BB0-4D46-A688-F7C726D12497"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.14:*:*:*:*:*:*:*", "matchCriteriaId": "9871AF57-9158-4A41-8340-596B4463289A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.15:*:*:*:*:*:*:*", "matchCriteriaId": "2A875207-DF01-4240-8895-49B62693D27B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.16:*:*:*:*:*:*:*", "matchCriteriaId": "FE04A172-6F3B-4E3B-8D4D-564740FABAAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.17:*:*:*:*:*:*:*", "matchCriteriaId": "CFEEF8C4-7DC2-4230-B58C-337F39A4DFAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.18:*:*:*:*:*:*:*", "matchCriteriaId": "9F74DB5C-5096-438C-8C8A-6D337A2FD06A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "639E3A57-A9E7-40E6-8929-81CCC0060EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "07012ADD-F521-40A8-B067-E87C2238A3D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3F5FF393-3F89-4274-B82B-F671358072ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "E348698F-54D1-4F5E-B701-CFAF50881E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "932205D9-3514-4289-9B55-C7A169276930"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "2ECB2D33-F517-480F-8A6F-99D9D6C49596"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.6:*:*:*:*:*:*:*", "matchCriteriaId": "D16F68DD-E2D4-4AA4-AB81-3796C2947E37"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.7:*:*:*:*:*:*:*", "matchCriteriaId": "2422AC23-8410-4524-A733-25E4ABC7515D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12:*:*:*:*:*:*:*", "matchCriteriaId": "B291154A-4B91-4A0E-AAAE-716A8BB7BF99"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "D835FBA1-49DE-4184-BEC8-7ED2B3F7B0BB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.2:*:*:*:*:*:*:*", "matchCriteriaId": "080BD3C9-0606-4D9A-B7AE-3DF9F75B8FF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.3:*:*:*:*:*:*:*", "matchCriteriaId": "CCDF0F11-3DB4-41F6-B6D3-383857884258"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.4:*:*:*:*:*:*:*", "matchCriteriaId": "2FB1772A-F4AA-4AB8-9FC9-10993A6A5B46"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=fda4e2e85589191b123d31cdc21fd33ee70f50fd", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-02/msg00002.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-02/msg00003.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-updates/2014-02/msg00045.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1801.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0163.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0284.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/12/12/12", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/64291", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2113-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2117-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2133-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2134-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2135-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2136-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2138-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2139-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2141-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1032210", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd"}}