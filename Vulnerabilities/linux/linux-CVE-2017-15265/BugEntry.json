{"buggy_code": ["/*\n *  ALSA sequencer Client Manager\n *  Copyright (c) 1998-2001 by Frank van de Pol <fvdpol@coil.demon.nl>\n *                             Jaroslav Kysela <perex@perex.cz>\n *                             Takashi Iwai <tiwai@suse.de>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <linux/kmod.h>\n\n#include <sound/seq_kernel.h>\n#include \"seq_clientmgr.h\"\n#include \"seq_memory.h\"\n#include \"seq_queue.h\"\n#include \"seq_timer.h\"\n#include \"seq_info.h\"\n#include \"seq_system.h\"\n#include <sound/seq_device.h>\n#ifdef CONFIG_COMPAT\n#include <linux/compat.h>\n#endif\n\n/* Client Manager\n\n * this module handles the connections of userland and kernel clients\n * \n */\n\n/*\n * There are four ranges of client numbers (last two shared):\n * 0..15: global clients\n * 16..127: statically allocated client numbers for cards 0..27\n * 128..191: dynamically allocated client numbers for cards 28..31\n * 128..191: dynamically allocated client numbers for applications\n */\n\n/* number of kernel non-card clients */\n#define SNDRV_SEQ_GLOBAL_CLIENTS\t16\n/* clients per cards, for static clients */\n#define SNDRV_SEQ_CLIENTS_PER_CARD\t4\n/* dynamically allocated client numbers (both kernel drivers and user space) */\n#define SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN\t128\n\n#define SNDRV_SEQ_LFLG_INPUT\t0x0001\n#define SNDRV_SEQ_LFLG_OUTPUT\t0x0002\n#define SNDRV_SEQ_LFLG_OPEN\t(SNDRV_SEQ_LFLG_INPUT|SNDRV_SEQ_LFLG_OUTPUT)\n\nstatic DEFINE_SPINLOCK(clients_lock);\nstatic DEFINE_MUTEX(register_mutex);\n\n/*\n * client table\n */\nstatic char clienttablock[SNDRV_SEQ_MAX_CLIENTS];\nstatic struct snd_seq_client *clienttab[SNDRV_SEQ_MAX_CLIENTS];\nstatic struct snd_seq_usage client_usage;\n\n/*\n * prototypes\n */\nstatic int bounce_error_event(struct snd_seq_client *client,\n\t\t\t      struct snd_seq_event *event,\n\t\t\t      int err, int atomic, int hop);\nstatic int snd_seq_deliver_single_event(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\t\tint filter, int atomic, int hop);\n\n/*\n */\nstatic inline unsigned short snd_seq_file_flags(struct file *file)\n{\n        switch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\n        case FMODE_WRITE:\n                return SNDRV_SEQ_LFLG_OUTPUT;\n        case FMODE_READ:\n                return SNDRV_SEQ_LFLG_INPUT;\n        default:\n                return SNDRV_SEQ_LFLG_OPEN;\n        }\n}\n\nstatic inline int snd_seq_write_pool_allocated(struct snd_seq_client *client)\n{\n\treturn snd_seq_total_cells(client->pool) > 0;\n}\n\n/* return pointer to client structure for specified id */\nstatic struct snd_seq_client *clientptr(int clientid)\n{\n\tif (clientid < 0 || clientid >= SNDRV_SEQ_MAX_CLIENTS) {\n\t\tpr_debug(\"ALSA: seq: oops. Trying to get pointer to client %d\\n\",\n\t\t\t   clientid);\n\t\treturn NULL;\n\t}\n\treturn clienttab[clientid];\n}\n\nstruct snd_seq_client *snd_seq_client_use_ptr(int clientid)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client *client;\n\n\tif (clientid < 0 || clientid >= SNDRV_SEQ_MAX_CLIENTS) {\n\t\tpr_debug(\"ALSA: seq: oops. Trying to get pointer to client %d\\n\",\n\t\t\t   clientid);\n\t\treturn NULL;\n\t}\n\tspin_lock_irqsave(&clients_lock, flags);\n\tclient = clientptr(clientid);\n\tif (client)\n\t\tgoto __lock;\n\tif (clienttablock[clientid]) {\n\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t\treturn NULL;\n\t}\n\tspin_unlock_irqrestore(&clients_lock, flags);\n#ifdef CONFIG_MODULES\n\tif (!in_interrupt()) {\n\t\tstatic char client_requested[SNDRV_SEQ_GLOBAL_CLIENTS];\n\t\tstatic char card_requested[SNDRV_CARDS];\n\t\tif (clientid < SNDRV_SEQ_GLOBAL_CLIENTS) {\n\t\t\tint idx;\n\t\t\t\n\t\t\tif (!client_requested[clientid]) {\n\t\t\t\tclient_requested[clientid] = 1;\n\t\t\t\tfor (idx = 0; idx < 15; idx++) {\n\t\t\t\t\tif (seq_client_load[idx] < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (seq_client_load[idx] == clientid) {\n\t\t\t\t\t\trequest_module(\"snd-seq-client-%i\",\n\t\t\t\t\t\t\t       clientid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (clientid < SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN) {\n\t\t\tint card = (clientid - SNDRV_SEQ_GLOBAL_CLIENTS) /\n\t\t\t\tSNDRV_SEQ_CLIENTS_PER_CARD;\n\t\t\tif (card < snd_ecards_limit) {\n\t\t\t\tif (! card_requested[card]) {\n\t\t\t\t\tcard_requested[card] = 1;\n\t\t\t\t\tsnd_request_card(card);\n\t\t\t\t}\n\t\t\t\tsnd_seq_device_load_drivers();\n\t\t\t}\n\t\t}\n\t\tspin_lock_irqsave(&clients_lock, flags);\n\t\tclient = clientptr(clientid);\n\t\tif (client)\n\t\t\tgoto __lock;\n\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t}\n#endif\n\treturn NULL;\n\n      __lock:\n\tsnd_use_lock_use(&client->use_lock);\n\tspin_unlock_irqrestore(&clients_lock, flags);\n\treturn client;\n}\n\nstatic void usage_alloc(struct snd_seq_usage *res, int num)\n{\n\tres->cur += num;\n\tif (res->cur > res->peak)\n\t\tres->peak = res->cur;\n}\n\nstatic void usage_free(struct snd_seq_usage *res, int num)\n{\n\tres->cur -= num;\n}\n\n/* initialise data structures */\nint __init client_init_data(void)\n{\n\t/* zap out the client table */\n\tmemset(&clienttablock, 0, sizeof(clienttablock));\n\tmemset(&clienttab, 0, sizeof(clienttab));\n\treturn 0;\n}\n\n\nstatic struct snd_seq_client *seq_create_client1(int client_index, int poolsize)\n{\n\tunsigned long flags;\n\tint c;\n\tstruct snd_seq_client *client;\n\n\t/* init client data */\n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (client == NULL)\n\t\treturn NULL;\n\tclient->pool = snd_seq_pool_new(poolsize);\n\tif (client->pool == NULL) {\n\t\tkfree(client);\n\t\treturn NULL;\n\t}\n\tclient->type = NO_CLIENT;\n\tsnd_use_lock_init(&client->use_lock);\n\trwlock_init(&client->ports_lock);\n\tmutex_init(&client->ports_mutex);\n\tINIT_LIST_HEAD(&client->ports_list_head);\n\n\t/* find free slot in the client table */\n\tspin_lock_irqsave(&clients_lock, flags);\n\tif (client_index < 0) {\n\t\tfor (c = SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN;\n\t\t     c < SNDRV_SEQ_MAX_CLIENTS;\n\t\t     c++) {\n\t\t\tif (clienttab[c] || clienttablock[c])\n\t\t\t\tcontinue;\n\t\t\tclienttab[client->number = c] = client;\n\t\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t\t\treturn client;\n\t\t}\n\t} else {\n\t\tif (clienttab[client_index] == NULL && !clienttablock[client_index]) {\n\t\t\tclienttab[client->number = client_index] = client;\n\t\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t\t\treturn client;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&clients_lock, flags);\n\tsnd_seq_pool_delete(&client->pool);\n\tkfree(client);\n\treturn NULL;\t/* no free slot found or busy, return failure code */\n}\n\n\nstatic int seq_free_client1(struct snd_seq_client *client)\n{\n\tunsigned long flags;\n\n\tif (!client)\n\t\treturn 0;\n\tsnd_seq_delete_all_ports(client);\n\tsnd_seq_queue_client_leave(client->number);\n\tspin_lock_irqsave(&clients_lock, flags);\n\tclienttablock[client->number] = 1;\n\tclienttab[client->number] = NULL;\n\tspin_unlock_irqrestore(&clients_lock, flags);\n\tsnd_use_lock_sync(&client->use_lock);\n\tsnd_seq_queue_client_termination(client->number);\n\tif (client->pool)\n\t\tsnd_seq_pool_delete(&client->pool);\n\tspin_lock_irqsave(&clients_lock, flags);\n\tclienttablock[client->number] = 0;\n\tspin_unlock_irqrestore(&clients_lock, flags);\n\treturn 0;\n}\n\n\nstatic void seq_free_client(struct snd_seq_client * client)\n{\n\tmutex_lock(&register_mutex);\n\tswitch (client->type) {\n\tcase NO_CLIENT:\n\t\tpr_warn(\"ALSA: seq: Trying to free unused client %d\\n\",\n\t\t\tclient->number);\n\t\tbreak;\n\tcase USER_CLIENT:\n\tcase KERNEL_CLIENT:\n\t\tseq_free_client1(client);\n\t\tusage_free(&client_usage, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"ALSA: seq: Trying to free client %d with undefined type = %d\\n\",\n\t\t\t   client->number, client->type);\n\t}\n\tmutex_unlock(&register_mutex);\n\n\tsnd_seq_system_client_ev_client_exit(client->number);\n}\n\n\n\n/* -------------------------------------------------------- */\n\n/* create a user client */\nstatic int snd_seq_open(struct inode *inode, struct file *file)\n{\n\tint c, mode;\t\t\t/* client id */\n\tstruct snd_seq_client *client;\n\tstruct snd_seq_user_client *user;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (mutex_lock_interruptible(&register_mutex))\n\t\treturn -ERESTARTSYS;\n\tclient = seq_create_client1(-1, SNDRV_SEQ_DEFAULT_EVENTS);\n\tif (client == NULL) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -ENOMEM;\t/* failure code */\n\t}\n\n\tmode = snd_seq_file_flags(file);\n\tif (mode & SNDRV_SEQ_LFLG_INPUT)\n\t\tclient->accept_input = 1;\n\tif (mode & SNDRV_SEQ_LFLG_OUTPUT)\n\t\tclient->accept_output = 1;\n\n\tuser = &client->data.user;\n\tuser->fifo = NULL;\n\tuser->fifo_pool_size = 0;\n\n\tif (mode & SNDRV_SEQ_LFLG_INPUT) {\n\t\tuser->fifo_pool_size = SNDRV_SEQ_DEFAULT_CLIENT_EVENTS;\n\t\tuser->fifo = snd_seq_fifo_new(user->fifo_pool_size);\n\t\tif (user->fifo == NULL) {\n\t\t\tseq_free_client1(client);\n\t\t\tkfree(client);\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tusage_alloc(&client_usage, 1);\n\tclient->type = USER_CLIENT;\n\tmutex_unlock(&register_mutex);\n\n\tc = client->number;\n\tfile->private_data = client;\n\n\t/* fill client data */\n\tuser->file = file;\n\tsprintf(client->name, \"Client-%d\", c);\n\tclient->data.user.owner = get_pid(task_pid(current));\n\n\t/* make others aware this new client */\n\tsnd_seq_system_client_ev_client_start(c);\n\n\treturn 0;\n}\n\n/* delete a user client */\nstatic int snd_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\n\tif (client) {\n\t\tseq_free_client(client);\n\t\tif (client->data.user.fifo)\n\t\t\tsnd_seq_fifo_delete(&client->data.user.fifo);\n\t\tput_pid(client->data.user.owner);\n\t\tkfree(client);\n\t}\n\n\treturn 0;\n}\n\n\n/* handle client read() */\n/* possible error values:\n *\t-ENXIO\tinvalid client or file open mode\n *\t-ENOSPC\tFIFO overflow (the flag is cleared after this error report)\n *\t-EINVAL\tno enough user-space buffer to write the whole event\n *\t-EFAULT\tseg. fault during copy to user space\n */\nstatic ssize_t snd_seq_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *offset)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tstruct snd_seq_fifo *fifo;\n\tint err;\n\tlong result = 0;\n\tstruct snd_seq_event_cell *cell;\n\n\tif (!(snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_INPUT))\n\t\treturn -ENXIO;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\t/* check client structures are in place */\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\n\tif (!client->accept_input || (fifo = client->data.user.fifo) == NULL)\n\t\treturn -ENXIO;\n\n\tif (atomic_read(&fifo->overflow) > 0) {\n\t\t/* buffer overflow is detected */\n\t\tsnd_seq_fifo_clear(fifo);\n\t\t/* return error code */\n\t\treturn -ENOSPC;\n\t}\n\n\tcell = NULL;\n\terr = 0;\n\tsnd_seq_fifo_lock(fifo);\n\n\t/* while data available in queue */\n\twhile (count >= sizeof(struct snd_seq_event)) {\n\t\tint nonblock;\n\n\t\tnonblock = (file->f_flags & O_NONBLOCK) || result > 0;\n\t\tif ((err = snd_seq_fifo_cell_out(fifo, &cell, nonblock)) < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (snd_seq_ev_is_variable(&cell->event)) {\n\t\t\tstruct snd_seq_event tmpev;\n\t\t\ttmpev = cell->event;\n\t\t\ttmpev.data.ext.len &= ~SNDRV_SEQ_EXT_MASK;\n\t\t\tif (copy_to_user(buf, &tmpev, sizeof(struct snd_seq_event))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount -= sizeof(struct snd_seq_event);\n\t\t\tbuf += sizeof(struct snd_seq_event);\n\t\t\terr = snd_seq_expand_var_event(&cell->event, count,\n\t\t\t\t\t\t       (char __force *)buf, 0,\n\t\t\t\t\t\t       sizeof(struct snd_seq_event));\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\tresult += err;\n\t\t\tcount -= err;\n\t\t\tbuf += err;\n\t\t} else {\n\t\t\tif (copy_to_user(buf, &cell->event, sizeof(struct snd_seq_event))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount -= sizeof(struct snd_seq_event);\n\t\t\tbuf += sizeof(struct snd_seq_event);\n\t\t}\n\t\tsnd_seq_cell_free(cell);\n\t\tcell = NULL; /* to be sure */\n\t\tresult += sizeof(struct snd_seq_event);\n\t}\n\n\tif (err < 0) {\n\t\tif (cell)\n\t\t\tsnd_seq_fifo_cell_putback(fifo, cell);\n\t\tif (err == -EAGAIN && result > 0)\n\t\t\terr = 0;\n\t}\n\tsnd_seq_fifo_unlock(fifo);\n\n\treturn (err < 0) ? err : result;\n}\n\n\n/*\n * check access permission to the port\n */\nstatic int check_port_perm(struct snd_seq_client_port *port, unsigned int flags)\n{\n\tif ((port->capability & flags) != flags)\n\t\treturn 0;\n\treturn flags;\n}\n\n/*\n * check if the destination client is available, and return the pointer\n * if filter is non-zero, client filter bitmap is tested.\n */\nstatic struct snd_seq_client *get_event_dest_client(struct snd_seq_event *event,\n\t\t\t\t\t\t    int filter)\n{\n\tstruct snd_seq_client *dest;\n\n\tdest = snd_seq_client_use_ptr(event->dest.client);\n\tif (dest == NULL)\n\t\treturn NULL;\n\tif (! dest->accept_input)\n\t\tgoto __not_avail;\n\tif ((dest->filter & SNDRV_SEQ_FILTER_USE_EVENT) &&\n\t    ! test_bit(event->type, dest->event_filter))\n\t\tgoto __not_avail;\n\tif (filter && !(dest->filter & filter))\n\t\tgoto __not_avail;\n\n\treturn dest; /* ok - accessible */\n__not_avail:\n\tsnd_seq_client_unlock(dest);\n\treturn NULL;\n}\n\n\n/*\n * Return the error event.\n *\n * If the receiver client is a user client, the original event is\n * encapsulated in SNDRV_SEQ_EVENT_BOUNCE as variable length event.  If\n * the original event is also variable length, the external data is\n * copied after the event record. \n * If the receiver client is a kernel client, the original event is\n * quoted in SNDRV_SEQ_EVENT_KERNEL_ERROR, since this requires no extra\n * kmalloc.\n */\nstatic int bounce_error_event(struct snd_seq_client *client,\n\t\t\t      struct snd_seq_event *event,\n\t\t\t      int err, int atomic, int hop)\n{\n\tstruct snd_seq_event bounce_ev;\n\tint result;\n\n\tif (client == NULL ||\n\t    ! (client->filter & SNDRV_SEQ_FILTER_BOUNCE) ||\n\t    ! client->accept_input)\n\t\treturn 0; /* ignored */\n\n\t/* set up quoted error */\n\tmemset(&bounce_ev, 0, sizeof(bounce_ev));\n\tbounce_ev.type = SNDRV_SEQ_EVENT_KERNEL_ERROR;\n\tbounce_ev.flags = SNDRV_SEQ_EVENT_LENGTH_FIXED;\n\tbounce_ev.queue = SNDRV_SEQ_QUEUE_DIRECT;\n\tbounce_ev.source.client = SNDRV_SEQ_CLIENT_SYSTEM;\n\tbounce_ev.source.port = SNDRV_SEQ_PORT_SYSTEM_ANNOUNCE;\n\tbounce_ev.dest.client = client->number;\n\tbounce_ev.dest.port = event->source.port;\n\tbounce_ev.data.quote.origin = event->dest;\n\tbounce_ev.data.quote.event = event;\n\tbounce_ev.data.quote.value = -err; /* use positive value */\n\tresult = snd_seq_deliver_single_event(NULL, &bounce_ev, 0, atomic, hop + 1);\n\tif (result < 0) {\n\t\tclient->event_lost++;\n\t\treturn result;\n\t}\n\n\treturn result;\n}\n\n\n/*\n * rewrite the time-stamp of the event record with the curren time\n * of the given queue.\n * return non-zero if updated.\n */\nstatic int update_timestamp_of_queue(struct snd_seq_event *event,\n\t\t\t\t     int queue, int real_time)\n{\n\tstruct snd_seq_queue *q;\n\n\tq = queueptr(queue);\n\tif (! q)\n\t\treturn 0;\n\tevent->queue = queue;\n\tevent->flags &= ~SNDRV_SEQ_TIME_STAMP_MASK;\n\tif (real_time) {\n\t\tevent->time.time = snd_seq_timer_get_cur_time(q->timer);\n\t\tevent->flags |= SNDRV_SEQ_TIME_STAMP_REAL;\n\t} else {\n\t\tevent->time.tick = snd_seq_timer_get_cur_tick(q->timer);\n\t\tevent->flags |= SNDRV_SEQ_TIME_STAMP_TICK;\n\t}\n\tqueuefree(q);\n\treturn 1;\n}\n\n\n/*\n * deliver an event to the specified destination.\n * if filter is non-zero, client filter bitmap is tested.\n *\n *  RETURN VALUE: 0 : if succeeded\n *\t\t <0 : error\n */\nstatic int snd_seq_deliver_single_event(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\t\tint filter, int atomic, int hop)\n{\n\tstruct snd_seq_client *dest = NULL;\n\tstruct snd_seq_client_port *dest_port = NULL;\n\tint result = -ENOENT;\n\tint direct;\n\n\tdirect = snd_seq_ev_is_direct(event);\n\n\tdest = get_event_dest_client(event, filter);\n\tif (dest == NULL)\n\t\tgoto __skip;\n\tdest_port = snd_seq_port_use_ptr(dest, event->dest.port);\n\tif (dest_port == NULL)\n\t\tgoto __skip;\n\n\t/* check permission */\n\tif (! check_port_perm(dest_port, SNDRV_SEQ_PORT_CAP_WRITE)) {\n\t\tresult = -EPERM;\n\t\tgoto __skip;\n\t}\n\t\t\n\tif (dest_port->timestamping)\n\t\tupdate_timestamp_of_queue(event, dest_port->time_queue,\n\t\t\t\t\t  dest_port->time_real);\n\n\tswitch (dest->type) {\n\tcase USER_CLIENT:\n\t\tif (dest->data.user.fifo)\n\t\t\tresult = snd_seq_fifo_event_in(dest->data.user.fifo, event);\n\t\tbreak;\n\n\tcase KERNEL_CLIENT:\n\t\tif (dest_port->event_input == NULL)\n\t\t\tbreak;\n\t\tresult = dest_port->event_input(event, direct,\n\t\t\t\t\t\tdest_port->private_data,\n\t\t\t\t\t\tatomic, hop);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n  __skip:\n\tif (dest_port)\n\t\tsnd_seq_port_unlock(dest_port);\n\tif (dest)\n\t\tsnd_seq_client_unlock(dest);\n\n\tif (result < 0 && !direct) {\n\t\tresult = bounce_error_event(client, event, result, atomic, hop);\n\t}\n\treturn result;\n}\n\n\n/*\n * send the event to all subscribers:\n */\nstatic int deliver_to_subscribers(struct snd_seq_client *client,\n\t\t\t\t  struct snd_seq_event *event,\n\t\t\t\t  int atomic, int hop)\n{\n\tstruct snd_seq_subscribers *subs;\n\tint err, result = 0, num_ev = 0;\n\tstruct snd_seq_event event_saved;\n\tstruct snd_seq_client_port *src_port;\n\tstruct snd_seq_port_subs_info *grp;\n\n\tsrc_port = snd_seq_port_use_ptr(client, event->source.port);\n\tif (src_port == NULL)\n\t\treturn -EINVAL; /* invalid source port */\n\t/* save original event record */\n\tevent_saved = *event;\n\tgrp = &src_port->c_src;\n\t\n\t/* lock list */\n\tif (atomic)\n\t\tread_lock(&grp->list_lock);\n\telse\n\t\tdown_read(&grp->list_mutex);\n\tlist_for_each_entry(subs, &grp->list_head, src_list) {\n\t\t/* both ports ready? */\n\t\tif (atomic_read(&subs->ref_count) != 2)\n\t\t\tcontinue;\n\t\tevent->dest = subs->info.dest;\n\t\tif (subs->info.flags & SNDRV_SEQ_PORT_SUBS_TIMESTAMP)\n\t\t\t/* convert time according to flag with subscription */\n\t\t\tupdate_timestamp_of_queue(event, subs->info.queue,\n\t\t\t\t\t\t  subs->info.flags & SNDRV_SEQ_PORT_SUBS_TIME_REAL);\n\t\terr = snd_seq_deliver_single_event(client, event,\n\t\t\t\t\t\t   0, atomic, hop);\n\t\tif (err < 0) {\n\t\t\t/* save first error that occurs and continue */\n\t\t\tif (!result)\n\t\t\t\tresult = err;\n\t\t\tcontinue;\n\t\t}\n\t\tnum_ev++;\n\t\t/* restore original event record */\n\t\t*event = event_saved;\n\t}\n\tif (atomic)\n\t\tread_unlock(&grp->list_lock);\n\telse\n\t\tup_read(&grp->list_mutex);\n\t*event = event_saved; /* restore */\n\tsnd_seq_port_unlock(src_port);\n\treturn (result < 0) ? result : num_ev;\n}\n\n\n#ifdef SUPPORT_BROADCAST \n/*\n * broadcast to all ports:\n */\nstatic int port_broadcast_event(struct snd_seq_client *client,\n\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\tint atomic, int hop)\n{\n\tint num_ev = 0, err, result = 0;\n\tstruct snd_seq_client *dest_client;\n\tstruct snd_seq_client_port *port;\n\n\tdest_client = get_event_dest_client(event, SNDRV_SEQ_FILTER_BROADCAST);\n\tif (dest_client == NULL)\n\t\treturn 0; /* no matching destination */\n\n\tread_lock(&dest_client->ports_lock);\n\tlist_for_each_entry(port, &dest_client->ports_list_head, list) {\n\t\tevent->dest.port = port->addr.port;\n\t\t/* pass NULL as source client to avoid error bounce */\n\t\terr = snd_seq_deliver_single_event(NULL, event,\n\t\t\t\t\t\t   SNDRV_SEQ_FILTER_BROADCAST,\n\t\t\t\t\t\t   atomic, hop);\n\t\tif (err < 0) {\n\t\t\t/* save first error that occurs and continue */\n\t\t\tif (!result)\n\t\t\t\tresult = err;\n\t\t\tcontinue;\n\t\t}\n\t\tnum_ev++;\n\t}\n\tread_unlock(&dest_client->ports_lock);\n\tsnd_seq_client_unlock(dest_client);\n\tevent->dest.port = SNDRV_SEQ_ADDRESS_BROADCAST; /* restore */\n\treturn (result < 0) ? result : num_ev;\n}\n\n/*\n * send the event to all clients:\n * if destination port is also ADDRESS_BROADCAST, deliver to all ports.\n */\nstatic int broadcast_event(struct snd_seq_client *client,\n\t\t\t   struct snd_seq_event *event, int atomic, int hop)\n{\n\tint err, result = 0, num_ev = 0;\n\tint dest;\n\tstruct snd_seq_addr addr;\n\n\taddr = event->dest; /* save */\n\n\tfor (dest = 0; dest < SNDRV_SEQ_MAX_CLIENTS; dest++) {\n\t\t/* don't send to itself */\n\t\tif (dest == client->number)\n\t\t\tcontinue;\n\t\tevent->dest.client = dest;\n\t\tevent->dest.port = addr.port;\n\t\tif (addr.port == SNDRV_SEQ_ADDRESS_BROADCAST)\n\t\t\terr = port_broadcast_event(client, event, atomic, hop);\n\t\telse\n\t\t\t/* pass NULL as source client to avoid error bounce */\n\t\t\terr = snd_seq_deliver_single_event(NULL, event,\n\t\t\t\t\t\t\t   SNDRV_SEQ_FILTER_BROADCAST,\n\t\t\t\t\t\t\t   atomic, hop);\n\t\tif (err < 0) {\n\t\t\t/* save first error that occurs and continue */\n\t\t\tif (!result)\n\t\t\t\tresult = err;\n\t\t\tcontinue;\n\t\t}\n\t\tnum_ev += err;\n\t}\n\tevent->dest = addr; /* restore */\n\treturn (result < 0) ? result : num_ev;\n}\n\n\n/* multicast - not supported yet */\nstatic int multicast_event(struct snd_seq_client *client, struct snd_seq_event *event,\n\t\t\t   int atomic, int hop)\n{\n\tpr_debug(\"ALSA: seq: multicast not supported yet.\\n\");\n\treturn 0; /* ignored */\n}\n#endif /* SUPPORT_BROADCAST */\n\n\n/* deliver an event to the destination port(s).\n * if the event is to subscribers or broadcast, the event is dispatched\n * to multiple targets.\n *\n * RETURN VALUE: n > 0  : the number of delivered events.\n *               n == 0 : the event was not passed to any client.\n *               n < 0  : error - event was not processed.\n */\nstatic int snd_seq_deliver_event(struct snd_seq_client *client, struct snd_seq_event *event,\n\t\t\t\t int atomic, int hop)\n{\n\tint result;\n\n\thop++;\n\tif (hop >= SNDRV_SEQ_MAX_HOPS) {\n\t\tpr_debug(\"ALSA: seq: too long delivery path (%d:%d->%d:%d)\\n\",\n\t\t\t   event->source.client, event->source.port,\n\t\t\t   event->dest.client, event->dest.port);\n\t\treturn -EMLINK;\n\t}\n\n\tif (event->queue == SNDRV_SEQ_ADDRESS_SUBSCRIBERS ||\n\t    event->dest.client == SNDRV_SEQ_ADDRESS_SUBSCRIBERS)\n\t\tresult = deliver_to_subscribers(client, event, atomic, hop);\n#ifdef SUPPORT_BROADCAST\n\telse if (event->queue == SNDRV_SEQ_ADDRESS_BROADCAST ||\n\t\t event->dest.client == SNDRV_SEQ_ADDRESS_BROADCAST)\n\t\tresult = broadcast_event(client, event, atomic, hop);\n\telse if (event->dest.client >= SNDRV_SEQ_MAX_CLIENTS)\n\t\tresult = multicast_event(client, event, atomic, hop);\n\telse if (event->dest.port == SNDRV_SEQ_ADDRESS_BROADCAST)\n\t\tresult = port_broadcast_event(client, event, atomic, hop);\n#endif\n\telse\n\t\tresult = snd_seq_deliver_single_event(client, event, 0, atomic, hop);\n\n\treturn result;\n}\n\n/*\n * dispatch an event cell:\n * This function is called only from queue check routines in timer\n * interrupts or after enqueued.\n * The event cell shall be released or re-queued in this function.\n *\n * RETURN VALUE: n > 0  : the number of delivered events.\n *\t\t n == 0 : the event was not passed to any client.\n *\t\t n < 0  : error - event was not processed.\n */\nint snd_seq_dispatch_event(struct snd_seq_event_cell *cell, int atomic, int hop)\n{\n\tstruct snd_seq_client *client;\n\tint result;\n\n\tif (snd_BUG_ON(!cell))\n\t\treturn -EINVAL;\n\n\tclient = snd_seq_client_use_ptr(cell->event.source.client);\n\tif (client == NULL) {\n\t\tsnd_seq_cell_free(cell); /* release this cell */\n\t\treturn -EINVAL;\n\t}\n\n\tif (cell->event.type == SNDRV_SEQ_EVENT_NOTE) {\n\t\t/* NOTE event:\n\t\t * the event cell is re-used as a NOTE-OFF event and\n\t\t * enqueued again.\n\t\t */\n\t\tstruct snd_seq_event tmpev, *ev;\n\n\t\t/* reserve this event to enqueue note-off later */\n\t\ttmpev = cell->event;\n\t\ttmpev.type = SNDRV_SEQ_EVENT_NOTEON;\n\t\tresult = snd_seq_deliver_event(client, &tmpev, atomic, hop);\n\n\t\t/*\n\t\t * This was originally a note event.  We now re-use the\n\t\t * cell for the note-off event.\n\t\t */\n\n\t\tev = &cell->event;\n\t\tev->type = SNDRV_SEQ_EVENT_NOTEOFF;\n\t\tev->flags |= SNDRV_SEQ_PRIORITY_HIGH;\n\n\t\t/* add the duration time */\n\t\tswitch (ev->flags & SNDRV_SEQ_TIME_STAMP_MASK) {\n\t\tcase SNDRV_SEQ_TIME_STAMP_TICK:\n\t\t\tev->time.tick += ev->data.note.duration;\n\t\t\tbreak;\n\t\tcase SNDRV_SEQ_TIME_STAMP_REAL:\n\t\t\t/* unit for duration is ms */\n\t\t\tev->time.time.tv_nsec += 1000000 * (ev->data.note.duration % 1000);\n\t\t\tev->time.time.tv_sec += ev->data.note.duration / 1000 +\n\t\t\t\t\t\tev->time.time.tv_nsec / 1000000000;\n\t\t\tev->time.time.tv_nsec %= 1000000000;\n\t\t\tbreak;\n\t\t}\n\t\tev->data.note.velocity = ev->data.note.off_velocity;\n\n\t\t/* Now queue this cell as the note off event */\n\t\tif (snd_seq_enqueue_event(cell, atomic, hop) < 0)\n\t\t\tsnd_seq_cell_free(cell); /* release this cell */\n\n\t} else {\n\t\t/* Normal events:\n\t\t * event cell is freed after processing the event\n\t\t */\n\n\t\tresult = snd_seq_deliver_event(client, &cell->event, atomic, hop);\n\t\tsnd_seq_cell_free(cell);\n\t}\n\n\tsnd_seq_client_unlock(client);\n\treturn result;\n}\n\n\n/* Allocate a cell from client pool and enqueue it to queue:\n * if pool is empty and blocking is TRUE, sleep until a new cell is\n * available.\n */\nstatic int snd_seq_client_enqueue_event(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\t\tstruct file *file, int blocking,\n\t\t\t\t\tint atomic, int hop)\n{\n\tstruct snd_seq_event_cell *cell;\n\tint err;\n\n\t/* special queue values - force direct passing */\n\tif (event->queue == SNDRV_SEQ_ADDRESS_SUBSCRIBERS) {\n\t\tevent->dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\t\tevent->queue = SNDRV_SEQ_QUEUE_DIRECT;\n\t} else\n#ifdef SUPPORT_BROADCAST\n\t\tif (event->queue == SNDRV_SEQ_ADDRESS_BROADCAST) {\n\t\t\tevent->dest.client = SNDRV_SEQ_ADDRESS_BROADCAST;\n\t\t\tevent->queue = SNDRV_SEQ_QUEUE_DIRECT;\n\t\t}\n#endif\n\tif (event->dest.client == SNDRV_SEQ_ADDRESS_SUBSCRIBERS) {\n\t\t/* check presence of source port */\n\t\tstruct snd_seq_client_port *src_port = snd_seq_port_use_ptr(client, event->source.port);\n\t\tif (src_port == NULL)\n\t\t\treturn -EINVAL;\n\t\tsnd_seq_port_unlock(src_port);\n\t}\n\n\t/* direct event processing without enqueued */\n\tif (snd_seq_ev_is_direct(event)) {\n\t\tif (event->type == SNDRV_SEQ_EVENT_NOTE)\n\t\t\treturn -EINVAL; /* this event must be enqueued! */\n\t\treturn snd_seq_deliver_event(client, event, atomic, hop);\n\t}\n\n\t/* Not direct, normal queuing */\n\tif (snd_seq_queue_is_used(event->queue, client->number) <= 0)\n\t\treturn -EINVAL;  /* invalid queue */\n\tif (! snd_seq_write_pool_allocated(client))\n\t\treturn -ENXIO; /* queue is not allocated */\n\n\t/* allocate an event cell */\n\terr = snd_seq_event_dup(client->pool, event, &cell, !blocking || atomic, file);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* we got a cell. enqueue it. */\n\tif ((err = snd_seq_enqueue_event(cell, atomic, hop)) < 0) {\n\t\tsnd_seq_cell_free(cell);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n\n/*\n * check validity of event type and data length.\n * return non-zero if invalid.\n */\nstatic int check_event_type_and_length(struct snd_seq_event *ev)\n{\n\tswitch (snd_seq_ev_length_type(ev)) {\n\tcase SNDRV_SEQ_EVENT_LENGTH_FIXED:\n\t\tif (snd_seq_ev_is_variable_type(ev))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_LENGTH_VARIABLE:\n\t\tif (! snd_seq_ev_is_variable_type(ev) ||\n\t\t    (ev->data.ext.len & ~SNDRV_SEQ_EXT_MASK) >= SNDRV_SEQ_MAX_EVENT_LEN)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_LENGTH_VARUSR:\n\t\tif (! snd_seq_ev_is_direct(ev))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\n/* handle write() */\n/* possible error values:\n *\t-ENXIO\tinvalid client or file open mode\n *\t-ENOMEM\tmalloc failed\n *\t-EFAULT\tseg. fault during copy from user space\n *\t-EINVAL\tinvalid event\n *\t-EAGAIN\tno space in output pool\n *\t-EINTR\tinterrupts while sleep\n *\t-EMLINK\ttoo many hops\n *\tothers\tdepends on return value from driver callback\n */\nstatic ssize_t snd_seq_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *offset)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tint written = 0, len;\n\tint err = -EINVAL;\n\tstruct snd_seq_event event;\n\n\tif (!(snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_OUTPUT))\n\t\treturn -ENXIO;\n\n\t/* check client structures are in place */\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\t\t\n\tif (!client->accept_output || client->pool == NULL)\n\t\treturn -ENXIO;\n\n\t/* allocate the pool now if the pool is not allocated yet */ \n\tif (client->pool->size > 0 && !snd_seq_write_pool_allocated(client)) {\n\t\tif (snd_seq_pool_init(client->pool) < 0)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* only process whole events */\n\twhile (count >= sizeof(struct snd_seq_event)) {\n\t\t/* Read in the event header from the user */\n\t\tlen = sizeof(event);\n\t\tif (copy_from_user(&event, buf, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tevent.source.client = client->number;\t/* fill in client number */\n\t\t/* Check for extension data length */\n\t\tif (check_event_type_and_length(&event)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check for special events */\n\t\tif (event.type == SNDRV_SEQ_EVENT_NONE)\n\t\t\tgoto __skip_event;\n\t\telse if (snd_seq_ev_is_reserved(&event)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (snd_seq_ev_is_variable(&event)) {\n\t\t\tint extlen = event.data.ext.len & ~SNDRV_SEQ_EXT_MASK;\n\t\t\tif ((size_t)(extlen + len) > count) {\n\t\t\t\t/* back out, will get an error this time or next */\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* set user space pointer */\n\t\t\tevent.data.ext.len = extlen | SNDRV_SEQ_EXT_USRPTR;\n\t\t\tevent.data.ext.ptr = (char __force *)buf\n\t\t\t\t\t\t+ sizeof(struct snd_seq_event);\n\t\t\tlen += extlen; /* increment data length */\n\t\t} else {\n#ifdef CONFIG_COMPAT\n\t\t\tif (client->convert32 && snd_seq_ev_is_varusr(&event)) {\n\t\t\t\tvoid *ptr = (void __force *)compat_ptr(event.data.raw32.d[1]);\n\t\t\t\tevent.data.ext.ptr = ptr;\n\t\t\t}\n#endif\n\t\t}\n\n\t\t/* ok, enqueue it */\n\t\terr = snd_seq_client_enqueue_event(client, &event, file,\n\t\t\t\t\t\t   !(file->f_flags & O_NONBLOCK),\n\t\t\t\t\t\t   0, 0);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t__skip_event:\n\t\t/* Update pointers and counts */\n\t\tcount -= len;\n\t\tbuf += len;\n\t\twritten += len;\n\t}\n\n\treturn written ? written : err;\n}\n\n\n/*\n * handle polling\n */\nstatic unsigned int snd_seq_poll(struct file *file, poll_table * wait)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tunsigned int mask = 0;\n\n\t/* check client structures are in place */\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\n\tif ((snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_INPUT) &&\n\t    client->data.user.fifo) {\n\n\t\t/* check if data is available in the outqueue */\n\t\tif (snd_seq_fifo_poll_wait(client->data.user.fifo, file, wait))\n\t\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\n\tif (snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_OUTPUT) {\n\n\t\t/* check if data is available in the pool */\n\t\tif (!snd_seq_write_pool_allocated(client) ||\n\t\t    snd_seq_pool_poll_wait(client->pool, file, wait))\n\t\t\tmask |= POLLOUT | POLLWRNORM;\n\t}\n\n\treturn mask;\n}\n\n\n/*-----------------------------------------------------*/\n\nstatic int snd_seq_ioctl_pversion(struct snd_seq_client *client, void *arg)\n{\n\tint *pversion = arg;\n\n\t*pversion = SNDRV_SEQ_VERSION;\n\treturn 0;\n}\n\nstatic int snd_seq_ioctl_client_id(struct snd_seq_client *client, void *arg)\n{\n\tint *client_id = arg;\n\n\t*client_id = client->number;\n\treturn 0;\n}\n\n/* SYSTEM_INFO ioctl() */\nstatic int snd_seq_ioctl_system_info(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_system_info *info = arg;\n\n\tmemset(info, 0, sizeof(*info));\n\t/* fill the info fields */\n\tinfo->queues = SNDRV_SEQ_MAX_QUEUES;\n\tinfo->clients = SNDRV_SEQ_MAX_CLIENTS;\n\tinfo->ports = SNDRV_SEQ_MAX_PORTS;\n\tinfo->channels = 256;\t/* fixed limit */\n\tinfo->cur_clients = client_usage.cur;\n\tinfo->cur_queues = snd_seq_queue_get_cur_queues();\n\n\treturn 0;\n}\n\n\n/* RUNNING_MODE ioctl() */\nstatic int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)\n{\n\tstruct snd_seq_running_info *info = arg;\n\tstruct snd_seq_client *cptr;\n\tint err = 0;\n\n\t/* requested client number */\n\tcptr = snd_seq_client_use_ptr(info->client);\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\t\t/* don't change !!! */\n\n#ifdef SNDRV_BIG_ENDIAN\n\tif (!info->big_endian) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n#else\n\tif (info->big_endian) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n\n#endif\n\tif (info->cpu_mode > sizeof(long)) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n\tcptr->convert32 = (info->cpu_mode < sizeof(long));\n __err:\n\tsnd_seq_client_unlock(cptr);\n\treturn err;\n}\n\n/* CLIENT_INFO ioctl() */\nstatic void get_client_info(struct snd_seq_client *cptr,\n\t\t\t    struct snd_seq_client_info *info)\n{\n\tinfo->client = cptr->number;\n\n\t/* fill the info fields */\n\tinfo->type = cptr->type;\n\tstrcpy(info->name, cptr->name);\n\tinfo->filter = cptr->filter;\n\tinfo->event_lost = cptr->event_lost;\n\tmemcpy(info->event_filter, cptr->event_filter, 32);\n\tinfo->num_ports = cptr->num_ports;\n\n\tif (cptr->type == USER_CLIENT)\n\t\tinfo->pid = pid_vnr(cptr->data.user.owner);\n\telse\n\t\tinfo->pid = -1;\n\n\tif (cptr->type == KERNEL_CLIENT)\n\t\tinfo->card = cptr->data.kernel.card ? cptr->data.kernel.card->number : -1;\n\telse\n\t\tinfo->card = -1;\n\n\tmemset(info->reserved, 0, sizeof(info->reserved));\n}\n\nstatic int snd_seq_ioctl_get_client_info(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_client_info *client_info = arg;\n\tstruct snd_seq_client *cptr;\n\n\t/* requested client number */\n\tcptr = snd_seq_client_use_ptr(client_info->client);\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\t\t/* don't change !!! */\n\n\tget_client_info(cptr, client_info);\n\tsnd_seq_client_unlock(cptr);\n\n\treturn 0;\n}\n\n\n/* CLIENT_INFO ioctl() */\nstatic int snd_seq_ioctl_set_client_info(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_client_info *client_info = arg;\n\n\t/* it is not allowed to set the info fields for an another client */\n\tif (client->number != client_info->client)\n\t\treturn -EPERM;\n\t/* also client type must be set now */\n\tif (client->type != client_info->type)\n\t\treturn -EINVAL;\n\n\t/* fill the info fields */\n\tif (client_info->name[0])\n\t\tstrlcpy(client->name, client_info->name, sizeof(client->name));\n\n\tclient->filter = client_info->filter;\n\tclient->event_lost = client_info->event_lost;\n\tmemcpy(client->event_filter, client_info->event_filter, 32);\n\n\treturn 0;\n}\n\n\n/* \n * CREATE PORT ioctl() \n */\nstatic int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\n\t/* it is not allowed to create the port for an another client */\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\n\tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n\t\treturn -EINVAL;\n\t}\n\tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\n\tinfo->addr = port->addr;\n\n\tsnd_seq_set_port_info(port, info);\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\n\treturn 0;\n}\n\n/* \n * DELETE PORT ioctl() \n */\nstatic int snd_seq_ioctl_delete_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tint err;\n\n\t/* it is not allowed to remove the port for an another client */\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\n\terr = snd_seq_delete_port(client, info->addr.port);\n\tif (err >= 0)\n\t\tsnd_seq_system_client_ev_port_exit(client->number, info->addr.port);\n\treturn err;\n}\n\n\n/* \n * GET_PORT_INFO ioctl() (on any client) \n */\nstatic int snd_seq_ioctl_get_port_info(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client *cptr;\n\tstruct snd_seq_client_port *port;\n\n\tcptr = snd_seq_client_use_ptr(info->addr.client);\n\tif (cptr == NULL)\n\t\treturn -ENXIO;\n\n\tport = snd_seq_port_use_ptr(cptr, info->addr.port);\n\tif (port == NULL) {\n\t\tsnd_seq_client_unlock(cptr);\n\t\treturn -ENOENT;\t\t\t/* don't change */\n\t}\n\n\t/* get port info */\n\tsnd_seq_get_port_info(port, info);\n\tsnd_seq_port_unlock(port);\n\tsnd_seq_client_unlock(cptr);\n\n\treturn 0;\n}\n\n\n/* \n * SET_PORT_INFO ioctl() (only ports on this/own client) \n */\nstatic int snd_seq_ioctl_set_port_info(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\n\tif (info->addr.client != client->number) /* only set our own ports ! */\n\t\treturn -EPERM;\n\tport = snd_seq_port_use_ptr(client, info->addr.port);\n\tif (port) {\n\t\tsnd_seq_set_port_info(port, info);\n\t\tsnd_seq_port_unlock(port);\n\t}\n\treturn 0;\n}\n\n\n/*\n * port subscription (connection)\n */\n#define PERM_RD\t\t(SNDRV_SEQ_PORT_CAP_READ|SNDRV_SEQ_PORT_CAP_SUBS_READ)\n#define PERM_WR\t\t(SNDRV_SEQ_PORT_CAP_WRITE|SNDRV_SEQ_PORT_CAP_SUBS_WRITE)\n\nstatic int check_subscription_permission(struct snd_seq_client *client,\n\t\t\t\t\t struct snd_seq_client_port *sport,\n\t\t\t\t\t struct snd_seq_client_port *dport,\n\t\t\t\t\t struct snd_seq_port_subscribe *subs)\n{\n\tif (client->number != subs->sender.client &&\n\t    client->number != subs->dest.client) {\n\t\t/* connection by third client - check export permission */\n\t\tif (check_port_perm(sport, SNDRV_SEQ_PORT_CAP_NO_EXPORT))\n\t\t\treturn -EPERM;\n\t\tif (check_port_perm(dport, SNDRV_SEQ_PORT_CAP_NO_EXPORT))\n\t\t\treturn -EPERM;\n\t}\n\n\t/* check read permission */\n\t/* if sender or receiver is the subscribing client itself,\n\t * no permission check is necessary\n\t */\n\tif (client->number != subs->sender.client) {\n\t\tif (! check_port_perm(sport, PERM_RD))\n\t\t\treturn -EPERM;\n\t}\n\t/* check write permission */\n\tif (client->number != subs->dest.client) {\n\t\tif (! check_port_perm(dport, PERM_WR))\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\n/*\n * send an subscription notify event to user client:\n * client must be user client.\n */\nint snd_seq_client_notify_subscription(int client, int port,\n\t\t\t\t       struct snd_seq_port_subscribe *info,\n\t\t\t\t       int evtype)\n{\n\tstruct snd_seq_event event;\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.type = evtype;\n\tevent.data.connect.dest = info->dest;\n\tevent.data.connect.sender = info->sender;\n\n\treturn snd_seq_system_notify(client, port, &event);  /* non-atomic */\n}\n\n\n/* \n * add to port's subscription list IOCTL interface \n */\nstatic int snd_seq_ioctl_subscribe_port(struct snd_seq_client *client,\n\t\t\t\t\tvoid *arg)\n{\n\tstruct snd_seq_port_subscribe *subs = arg;\n\tint result = -EINVAL;\n\tstruct snd_seq_client *receiver = NULL, *sender = NULL;\n\tstruct snd_seq_client_port *sport = NULL, *dport = NULL;\n\n\tif ((receiver = snd_seq_client_use_ptr(subs->dest.client)) == NULL)\n\t\tgoto __end;\n\tif ((sender = snd_seq_client_use_ptr(subs->sender.client)) == NULL)\n\t\tgoto __end;\n\tif ((sport = snd_seq_port_use_ptr(sender, subs->sender.port)) == NULL)\n\t\tgoto __end;\n\tif ((dport = snd_seq_port_use_ptr(receiver, subs->dest.port)) == NULL)\n\t\tgoto __end;\n\n\tresult = check_subscription_permission(client, sport, dport, subs);\n\tif (result < 0)\n\t\tgoto __end;\n\n\t/* connect them */\n\tresult = snd_seq_port_connect(client, sender, sport, receiver, dport, subs);\n\tif (! result) /* broadcast announce */\n\t\tsnd_seq_client_notify_subscription(SNDRV_SEQ_ADDRESS_SUBSCRIBERS, 0,\n\t\t\t\t\t\t   subs, SNDRV_SEQ_EVENT_PORT_SUBSCRIBED);\n      __end:\n      \tif (sport)\n\t\tsnd_seq_port_unlock(sport);\n\tif (dport)\n\t\tsnd_seq_port_unlock(dport);\n\tif (sender)\n\t\tsnd_seq_client_unlock(sender);\n\tif (receiver)\n\t\tsnd_seq_client_unlock(receiver);\n\treturn result;\n}\n\n\n/* \n * remove from port's subscription list \n */\nstatic int snd_seq_ioctl_unsubscribe_port(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_port_subscribe *subs = arg;\n\tint result = -ENXIO;\n\tstruct snd_seq_client *receiver = NULL, *sender = NULL;\n\tstruct snd_seq_client_port *sport = NULL, *dport = NULL;\n\n\tif ((receiver = snd_seq_client_use_ptr(subs->dest.client)) == NULL)\n\t\tgoto __end;\n\tif ((sender = snd_seq_client_use_ptr(subs->sender.client)) == NULL)\n\t\tgoto __end;\n\tif ((sport = snd_seq_port_use_ptr(sender, subs->sender.port)) == NULL)\n\t\tgoto __end;\n\tif ((dport = snd_seq_port_use_ptr(receiver, subs->dest.port)) == NULL)\n\t\tgoto __end;\n\n\tresult = check_subscription_permission(client, sport, dport, subs);\n\tif (result < 0)\n\t\tgoto __end;\n\n\tresult = snd_seq_port_disconnect(client, sender, sport, receiver, dport, subs);\n\tif (! result) /* broadcast announce */\n\t\tsnd_seq_client_notify_subscription(SNDRV_SEQ_ADDRESS_SUBSCRIBERS, 0,\n\t\t\t\t\t\t   subs, SNDRV_SEQ_EVENT_PORT_UNSUBSCRIBED);\n      __end:\n      \tif (sport)\n\t\tsnd_seq_port_unlock(sport);\n\tif (dport)\n\t\tsnd_seq_port_unlock(dport);\n\tif (sender)\n\t\tsnd_seq_client_unlock(sender);\n\tif (receiver)\n\t\tsnd_seq_client_unlock(receiver);\n\treturn result;\n}\n\n\n/* CREATE_QUEUE ioctl() */\nstatic int snd_seq_ioctl_create_queue(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\tstruct snd_seq_queue *q;\n\n\tq = snd_seq_queue_alloc(client->number, info->locked, info->flags);\n\tif (IS_ERR(q))\n\t\treturn PTR_ERR(q);\n\n\tinfo->queue = q->queue;\n\tinfo->locked = q->locked;\n\tinfo->owner = q->owner;\n\n\t/* set queue name */\n\tif (!info->name[0])\n\t\tsnprintf(info->name, sizeof(info->name), \"Queue-%d\", q->queue);\n\tstrlcpy(q->name, info->name, sizeof(q->name));\n\tsnd_use_lock_free(&q->use_lock);\n\n\treturn 0;\n}\n\n/* DELETE_QUEUE ioctl() */\nstatic int snd_seq_ioctl_delete_queue(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\n\treturn snd_seq_queue_delete(client->number, info->queue);\n}\n\n/* GET_QUEUE_INFO ioctl() */\nstatic int snd_seq_ioctl_get_queue_info(struct snd_seq_client *client,\n\t\t\t\t\tvoid *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\tstruct snd_seq_queue *q;\n\n\tq = queueptr(info->queue);\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->queue = q->queue;\n\tinfo->owner = q->owner;\n\tinfo->locked = q->locked;\n\tstrlcpy(info->name, q->name, sizeof(info->name));\n\tqueuefree(q);\n\n\treturn 0;\n}\n\n/* SET_QUEUE_INFO ioctl() */\nstatic int snd_seq_ioctl_set_queue_info(struct snd_seq_client *client,\n\t\t\t\t\tvoid *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\tstruct snd_seq_queue *q;\n\n\tif (info->owner != client->number)\n\t\treturn -EINVAL;\n\n\t/* change owner/locked permission */\n\tif (snd_seq_queue_check_access(info->queue, client->number)) {\n\t\tif (snd_seq_queue_set_owner(info->queue, client->number, info->locked) < 0)\n\t\t\treturn -EPERM;\n\t\tif (info->locked)\n\t\t\tsnd_seq_queue_use(info->queue, client->number, 1);\n\t} else {\n\t\treturn -EPERM;\n\t}\t\n\n\tq = queueptr(info->queue);\n\tif (! q)\n\t\treturn -EINVAL;\n\tif (q->owner != client->number) {\n\t\tqueuefree(q);\n\t\treturn -EPERM;\n\t}\n\tstrlcpy(q->name, info->name, sizeof(q->name));\n\tqueuefree(q);\n\n\treturn 0;\n}\n\n/* GET_NAMED_QUEUE ioctl() */\nstatic int snd_seq_ioctl_get_named_queue(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\tstruct snd_seq_queue *q;\n\n\tq = snd_seq_queue_find_name(info->name);\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\tinfo->queue = q->queue;\n\tinfo->owner = q->owner;\n\tinfo->locked = q->locked;\n\tqueuefree(q);\n\n\treturn 0;\n}\n\n/* GET_QUEUE_STATUS ioctl() */\nstatic int snd_seq_ioctl_get_queue_status(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_queue_status *status = arg;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tqueue = queueptr(status->queue);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\tmemset(status, 0, sizeof(*status));\n\tstatus->queue = queue->queue;\n\t\n\ttmr = queue->timer;\n\tstatus->events = queue->tickq->cells + queue->timeq->cells;\n\n\tstatus->time = snd_seq_timer_get_cur_time(tmr);\n\tstatus->tick = snd_seq_timer_get_cur_tick(tmr);\n\n\tstatus->running = tmr->running;\n\n\tstatus->flags = queue->flags;\n\tqueuefree(queue);\n\n\treturn 0;\n}\n\n\n/* GET_QUEUE_TEMPO ioctl() */\nstatic int snd_seq_ioctl_get_queue_tempo(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_tempo *tempo = arg;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tqueue = queueptr(tempo->queue);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\tmemset(tempo, 0, sizeof(*tempo));\n\ttempo->queue = queue->queue;\n\t\n\ttmr = queue->timer;\n\n\ttempo->tempo = tmr->tempo;\n\ttempo->ppq = tmr->ppq;\n\ttempo->skew_value = tmr->skew;\n\ttempo->skew_base = tmr->skew_base;\n\tqueuefree(queue);\n\n\treturn 0;\n}\n\n\n/* SET_QUEUE_TEMPO ioctl() */\nint snd_seq_set_queue_tempo(int client, struct snd_seq_queue_tempo *tempo)\n{\n\tif (!snd_seq_queue_check_access(tempo->queue, client))\n\t\treturn -EPERM;\n\treturn snd_seq_queue_timer_set_tempo(tempo->queue, client, tempo);\n}\nEXPORT_SYMBOL(snd_seq_set_queue_tempo);\n\nstatic int snd_seq_ioctl_set_queue_tempo(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_tempo *tempo = arg;\n\tint result;\n\n\tresult = snd_seq_set_queue_tempo(client->number, tempo);\n\treturn result < 0 ? result : 0;\n}\n\n\n/* GET_QUEUE_TIMER ioctl() */\nstatic int snd_seq_ioctl_get_queue_timer(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_timer *timer = arg;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tqueue = queueptr(timer->queue);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&queue->timer_mutex)) {\n\t\tqueuefree(queue);\n\t\treturn -ERESTARTSYS;\n\t}\n\ttmr = queue->timer;\n\tmemset(timer, 0, sizeof(*timer));\n\ttimer->queue = queue->queue;\n\n\ttimer->type = tmr->type;\n\tif (tmr->type == SNDRV_SEQ_TIMER_ALSA) {\n\t\ttimer->u.alsa.id = tmr->alsa_id;\n\t\ttimer->u.alsa.resolution = tmr->preferred_resolution;\n\t}\n\tmutex_unlock(&queue->timer_mutex);\n\tqueuefree(queue);\n\t\n\treturn 0;\n}\n\n\n/* SET_QUEUE_TIMER ioctl() */\nstatic int snd_seq_ioctl_set_queue_timer(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_timer *timer = arg;\n\tint result = 0;\n\n\tif (timer->type != SNDRV_SEQ_TIMER_ALSA)\n\t\treturn -EINVAL;\n\n\tif (snd_seq_queue_check_access(timer->queue, client->number)) {\n\t\tstruct snd_seq_queue *q;\n\t\tstruct snd_seq_timer *tmr;\n\n\t\tq = queueptr(timer->queue);\n\t\tif (q == NULL)\n\t\t\treturn -ENXIO;\n\t\tif (mutex_lock_interruptible(&q->timer_mutex)) {\n\t\t\tqueuefree(q);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\ttmr = q->timer;\n\t\tsnd_seq_queue_timer_close(timer->queue);\n\t\ttmr->type = timer->type;\n\t\tif (tmr->type == SNDRV_SEQ_TIMER_ALSA) {\n\t\t\ttmr->alsa_id = timer->u.alsa.id;\n\t\t\ttmr->preferred_resolution = timer->u.alsa.resolution;\n\t\t}\n\t\tresult = snd_seq_queue_timer_open(timer->queue);\n\t\tmutex_unlock(&q->timer_mutex);\n\t\tqueuefree(q);\n\t} else {\n\t\treturn -EPERM;\n\t}\t\n\n\treturn result;\n}\n\n\n/* GET_QUEUE_CLIENT ioctl() */\nstatic int snd_seq_ioctl_get_queue_client(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_queue_client *info = arg;\n\tint used;\n\n\tused = snd_seq_queue_is_used(info->queue, client->number);\n\tif (used < 0)\n\t\treturn -EINVAL;\n\tinfo->used = used;\n\tinfo->client = client->number;\n\n\treturn 0;\n}\n\n\n/* SET_QUEUE_CLIENT ioctl() */\nstatic int snd_seq_ioctl_set_queue_client(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_queue_client *info = arg;\n\tint err;\n\n\tif (info->used >= 0) {\n\t\terr = snd_seq_queue_use(info->queue, client->number, info->used);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn snd_seq_ioctl_get_queue_client(client, arg);\n}\n\n\n/* GET_CLIENT_POOL ioctl() */\nstatic int snd_seq_ioctl_get_client_pool(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_client_pool *info = arg;\n\tstruct snd_seq_client *cptr;\n\n\tcptr = snd_seq_client_use_ptr(info->client);\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\n\tmemset(info, 0, sizeof(*info));\n\tinfo->client = cptr->number;\n\tinfo->output_pool = cptr->pool->size;\n\tinfo->output_room = cptr->pool->room;\n\tinfo->output_free = info->output_pool;\n\tinfo->output_free = snd_seq_unused_cells(cptr->pool);\n\tif (cptr->type == USER_CLIENT) {\n\t\tinfo->input_pool = cptr->data.user.fifo_pool_size;\n\t\tinfo->input_free = info->input_pool;\n\t\tif (cptr->data.user.fifo)\n\t\t\tinfo->input_free = snd_seq_unused_cells(cptr->data.user.fifo->pool);\n\t} else {\n\t\tinfo->input_pool = 0;\n\t\tinfo->input_free = 0;\n\t}\n\tsnd_seq_client_unlock(cptr);\n\t\n\treturn 0;\n}\n\n/* SET_CLIENT_POOL ioctl() */\nstatic int snd_seq_ioctl_set_client_pool(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_client_pool *info = arg;\n\tint rc;\n\n\tif (client->number != info->client)\n\t\treturn -EINVAL; /* can't change other clients */\n\n\tif (info->output_pool >= 1 && info->output_pool <= SNDRV_SEQ_MAX_EVENTS &&\n\t    (! snd_seq_write_pool_allocated(client) ||\n\t     info->output_pool != client->pool->size)) {\n\t\tif (snd_seq_write_pool_allocated(client)) {\n\t\t\t/* remove all existing cells */\n\t\t\tsnd_seq_pool_mark_closing(client->pool);\n\t\t\tsnd_seq_queue_client_leave_cells(client->number);\n\t\t\tsnd_seq_pool_done(client->pool);\n\t\t}\n\t\tclient->pool->size = info->output_pool;\n\t\trc = snd_seq_pool_init(client->pool);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\tif (client->type == USER_CLIENT && client->data.user.fifo != NULL &&\n\t    info->input_pool >= 1 &&\n\t    info->input_pool <= SNDRV_SEQ_MAX_CLIENT_EVENTS &&\n\t    info->input_pool != client->data.user.fifo_pool_size) {\n\t\t/* change pool size */\n\t\trc = snd_seq_fifo_resize(client->data.user.fifo, info->input_pool);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tclient->data.user.fifo_pool_size = info->input_pool;\n\t}\n\tif (info->output_room >= 1 &&\n\t    info->output_room <= client->pool->size) {\n\t\tclient->pool->room  = info->output_room;\n\t}\n\n\treturn snd_seq_ioctl_get_client_pool(client, arg);\n}\n\n\n/* REMOVE_EVENTS ioctl() */\nstatic int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void *arg)\n{\n\tstruct snd_seq_remove_events *info = arg;\n\n\t/*\n\t * Input mostly not implemented XXX.\n\t */\n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\t/*\n\t\t * No restrictions so for a user client we can clear\n\t\t * the whole fifo\n\t\t */\n\t\tif (client->type == USER_CLIENT && client->data.user.fifo)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, info);\n\n\treturn 0;\n}\n\n\n/*\n * get subscription info\n */\nstatic int snd_seq_ioctl_get_subscription(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_port_subscribe *subs = arg;\n\tint result;\n\tstruct snd_seq_client *sender = NULL;\n\tstruct snd_seq_client_port *sport = NULL;\n\tstruct snd_seq_subscribers *p;\n\n\tresult = -EINVAL;\n\tif ((sender = snd_seq_client_use_ptr(subs->sender.client)) == NULL)\n\t\tgoto __end;\n\tif ((sport = snd_seq_port_use_ptr(sender, subs->sender.port)) == NULL)\n\t\tgoto __end;\n\tp = snd_seq_port_get_subscription(&sport->c_src, &subs->dest);\n\tif (p) {\n\t\tresult = 0;\n\t\t*subs = p->info;\n\t} else\n\t\tresult = -ENOENT;\n\n      __end:\n      \tif (sport)\n\t\tsnd_seq_port_unlock(sport);\n\tif (sender)\n\t\tsnd_seq_client_unlock(sender);\n\n\treturn result;\n}\n\n\n/*\n * get subscription info - check only its presence\n */\nstatic int snd_seq_ioctl_query_subs(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_query_subs *subs = arg;\n\tint result = -ENXIO;\n\tstruct snd_seq_client *cptr = NULL;\n\tstruct snd_seq_client_port *port = NULL;\n\tstruct snd_seq_port_subs_info *group;\n\tstruct list_head *p;\n\tint i;\n\n\tif ((cptr = snd_seq_client_use_ptr(subs->root.client)) == NULL)\n\t\tgoto __end;\n\tif ((port = snd_seq_port_use_ptr(cptr, subs->root.port)) == NULL)\n\t\tgoto __end;\n\n\tswitch (subs->type) {\n\tcase SNDRV_SEQ_QUERY_SUBS_READ:\n\t\tgroup = &port->c_src;\n\t\tbreak;\n\tcase SNDRV_SEQ_QUERY_SUBS_WRITE:\n\t\tgroup = &port->c_dest;\n\t\tbreak;\n\tdefault:\n\t\tgoto __end;\n\t}\n\n\tdown_read(&group->list_mutex);\n\t/* search for the subscriber */\n\tsubs->num_subs = group->count;\n\ti = 0;\n\tresult = -ENOENT;\n\tlist_for_each(p, &group->list_head) {\n\t\tif (i++ == subs->index) {\n\t\t\t/* found! */\n\t\t\tstruct snd_seq_subscribers *s;\n\t\t\tif (subs->type == SNDRV_SEQ_QUERY_SUBS_READ) {\n\t\t\t\ts = list_entry(p, struct snd_seq_subscribers, src_list);\n\t\t\t\tsubs->addr = s->info.dest;\n\t\t\t} else {\n\t\t\t\ts = list_entry(p, struct snd_seq_subscribers, dest_list);\n\t\t\t\tsubs->addr = s->info.sender;\n\t\t\t}\n\t\t\tsubs->flags = s->info.flags;\n\t\t\tsubs->queue = s->info.queue;\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&group->list_mutex);\n\n      __end:\n   \tif (port)\n\t\tsnd_seq_port_unlock(port);\n\tif (cptr)\n\t\tsnd_seq_client_unlock(cptr);\n\n\treturn result;\n}\n\n\n/*\n * query next client\n */\nstatic int snd_seq_ioctl_query_next_client(struct snd_seq_client *client,\n\t\t\t\t\t   void *arg)\n{\n\tstruct snd_seq_client_info *info = arg;\n\tstruct snd_seq_client *cptr = NULL;\n\n\t/* search for next client */\n\tinfo->client++;\n\tif (info->client < 0)\n\t\tinfo->client = 0;\n\tfor (; info->client < SNDRV_SEQ_MAX_CLIENTS; info->client++) {\n\t\tcptr = snd_seq_client_use_ptr(info->client);\n\t\tif (cptr)\n\t\t\tbreak; /* found */\n\t}\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\n\n\tget_client_info(cptr, info);\n\tsnd_seq_client_unlock(cptr);\n\n\treturn 0;\n}\n\n/* \n * query next port\n */\nstatic int snd_seq_ioctl_query_next_port(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client *cptr;\n\tstruct snd_seq_client_port *port = NULL;\n\n\tcptr = snd_seq_client_use_ptr(info->addr.client);\n\tif (cptr == NULL)\n\t\treturn -ENXIO;\n\n\t/* search for next port */\n\tinfo->addr.port++;\n\tport = snd_seq_port_query_nearest(cptr, info);\n\tif (port == NULL) {\n\t\tsnd_seq_client_unlock(cptr);\n\t\treturn -ENOENT;\n\t}\n\n\t/* get port info */\n\tinfo->addr = port->addr;\n\tsnd_seq_get_port_info(port, info);\n\tsnd_seq_port_unlock(port);\n\tsnd_seq_client_unlock(cptr);\n\n\treturn 0;\n}\n\n/* -------------------------------------------------------- */\n\nstatic const struct ioctl_handler {\n\tunsigned int cmd;\n\tint (*func)(struct snd_seq_client *client, void *arg);\n} ioctl_handlers[] = {\n\t{ SNDRV_SEQ_IOCTL_PVERSION, snd_seq_ioctl_pversion },\n\t{ SNDRV_SEQ_IOCTL_CLIENT_ID, snd_seq_ioctl_client_id },\n\t{ SNDRV_SEQ_IOCTL_SYSTEM_INFO, snd_seq_ioctl_system_info },\n\t{ SNDRV_SEQ_IOCTL_RUNNING_MODE, snd_seq_ioctl_running_mode },\n\t{ SNDRV_SEQ_IOCTL_GET_CLIENT_INFO, snd_seq_ioctl_get_client_info },\n\t{ SNDRV_SEQ_IOCTL_SET_CLIENT_INFO, snd_seq_ioctl_set_client_info },\n\t{ SNDRV_SEQ_IOCTL_CREATE_PORT, snd_seq_ioctl_create_port },\n\t{ SNDRV_SEQ_IOCTL_DELETE_PORT, snd_seq_ioctl_delete_port },\n\t{ SNDRV_SEQ_IOCTL_GET_PORT_INFO, snd_seq_ioctl_get_port_info },\n\t{ SNDRV_SEQ_IOCTL_SET_PORT_INFO, snd_seq_ioctl_set_port_info },\n\t{ SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT, snd_seq_ioctl_subscribe_port },\n\t{ SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT, snd_seq_ioctl_unsubscribe_port },\n\t{ SNDRV_SEQ_IOCTL_CREATE_QUEUE, snd_seq_ioctl_create_queue },\n\t{ SNDRV_SEQ_IOCTL_DELETE_QUEUE, snd_seq_ioctl_delete_queue },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_INFO, snd_seq_ioctl_get_queue_info },\n\t{ SNDRV_SEQ_IOCTL_SET_QUEUE_INFO, snd_seq_ioctl_set_queue_info },\n\t{ SNDRV_SEQ_IOCTL_GET_NAMED_QUEUE, snd_seq_ioctl_get_named_queue },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_STATUS, snd_seq_ioctl_get_queue_status },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_TEMPO, snd_seq_ioctl_get_queue_tempo },\n\t{ SNDRV_SEQ_IOCTL_SET_QUEUE_TEMPO, snd_seq_ioctl_set_queue_tempo },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_TIMER, snd_seq_ioctl_get_queue_timer },\n\t{ SNDRV_SEQ_IOCTL_SET_QUEUE_TIMER, snd_seq_ioctl_set_queue_timer },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_CLIENT, snd_seq_ioctl_get_queue_client },\n\t{ SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT, snd_seq_ioctl_set_queue_client },\n\t{ SNDRV_SEQ_IOCTL_GET_CLIENT_POOL, snd_seq_ioctl_get_client_pool },\n\t{ SNDRV_SEQ_IOCTL_SET_CLIENT_POOL, snd_seq_ioctl_set_client_pool },\n\t{ SNDRV_SEQ_IOCTL_GET_SUBSCRIPTION, snd_seq_ioctl_get_subscription },\n\t{ SNDRV_SEQ_IOCTL_QUERY_NEXT_CLIENT, snd_seq_ioctl_query_next_client },\n\t{ SNDRV_SEQ_IOCTL_QUERY_NEXT_PORT, snd_seq_ioctl_query_next_port },\n\t{ SNDRV_SEQ_IOCTL_REMOVE_EVENTS, snd_seq_ioctl_remove_events },\n\t{ SNDRV_SEQ_IOCTL_QUERY_SUBS, snd_seq_ioctl_query_subs },\n\t{ 0, NULL },\n};\n\nstatic long snd_seq_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\t/* To use kernel stack for ioctl data. */\n\tunion {\n\t\tint pversion;\n\t\tint client_id;\n\t\tstruct snd_seq_system_info\tsystem_info;\n\t\tstruct snd_seq_running_info\trunning_info;\n\t\tstruct snd_seq_client_info\tclient_info;\n\t\tstruct snd_seq_port_info\tport_info;\n\t\tstruct snd_seq_port_subscribe\tport_subscribe;\n\t\tstruct snd_seq_queue_info\tqueue_info;\n\t\tstruct snd_seq_queue_status\tqueue_status;\n\t\tstruct snd_seq_queue_tempo\ttempo;\n\t\tstruct snd_seq_queue_timer\tqueue_timer;\n\t\tstruct snd_seq_queue_client\tqueue_client;\n\t\tstruct snd_seq_client_pool\tclient_pool;\n\t\tstruct snd_seq_remove_events\tremove_events;\n\t\tstruct snd_seq_query_subs\tquery_subs;\n\t} buf;\n\tconst struct ioctl_handler *handler;\n\tunsigned long size;\n\tint err;\n\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\n\tfor (handler = ioctl_handlers; handler->cmd > 0; ++handler) {\n\t\tif (handler->cmd == cmd)\n\t\t\tbreak;\n\t}\n\tif (handler->cmd == 0)\n\t\treturn -ENOTTY;\n\n\tmemset(&buf, 0, sizeof(buf));\n\n\t/*\n\t * All of ioctl commands for ALSA sequencer get an argument of size\n\t * within 13 bits. We can safely pick up the size from the command.\n\t */\n\tsize = _IOC_SIZE(handler->cmd);\n\tif (handler->cmd & IOC_IN) {\n\t\tif (copy_from_user(&buf, (const void __user *)arg, size))\n\t\t\treturn -EFAULT;\n\t}\n\n\terr = handler->func(client, &buf);\n\tif (err >= 0) {\n\t\t/* Some commands includes a bug in 'dir' field. */\n\t\tif (handler->cmd == SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT ||\n\t\t    handler->cmd == SNDRV_SEQ_IOCTL_SET_CLIENT_POOL ||\n\t\t    (handler->cmd & IOC_OUT))\n\t\t\tif (copy_to_user((void __user *)arg, &buf, size))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\n#include \"seq_compat.c\"\n#else\n#define snd_seq_ioctl_compat\tNULL\n#endif\n\n/* -------------------------------------------------------- */\n\n\n/* exported to kernel modules */\nint snd_seq_create_kernel_client(struct snd_card *card, int client_index,\n\t\t\t\t const char *name_fmt, ...)\n{\n\tstruct snd_seq_client *client;\n\tva_list args;\n\n\tif (snd_BUG_ON(in_interrupt()))\n\t\treturn -EBUSY;\n\n\tif (card && client_index >= SNDRV_SEQ_CLIENTS_PER_CARD)\n\t\treturn -EINVAL;\n\tif (card == NULL && client_index >= SNDRV_SEQ_GLOBAL_CLIENTS)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&register_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (card) {\n\t\tclient_index += SNDRV_SEQ_GLOBAL_CLIENTS\n\t\t\t+ card->number * SNDRV_SEQ_CLIENTS_PER_CARD;\n\t\tif (client_index >= SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN)\n\t\t\tclient_index = -1;\n\t}\n\n\t/* empty write queue as default */\n\tclient = seq_create_client1(client_index, 0);\n\tif (client == NULL) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -EBUSY;\t/* failure code */\n\t}\n\tusage_alloc(&client_usage, 1);\n\n\tclient->accept_input = 1;\n\tclient->accept_output = 1;\n\tclient->data.kernel.card = card;\n\t\t\n\tva_start(args, name_fmt);\n\tvsnprintf(client->name, sizeof(client->name), name_fmt, args);\n\tva_end(args);\n\n\tclient->type = KERNEL_CLIENT;\n\tmutex_unlock(&register_mutex);\n\n\t/* make others aware this new client */\n\tsnd_seq_system_client_ev_client_start(client->number);\n\t\n\t/* return client number to caller */\n\treturn client->number;\n}\nEXPORT_SYMBOL(snd_seq_create_kernel_client);\n\n/* exported to kernel modules */\nint snd_seq_delete_kernel_client(int client)\n{\n\tstruct snd_seq_client *ptr;\n\n\tif (snd_BUG_ON(in_interrupt()))\n\t\treturn -EBUSY;\n\n\tptr = clientptr(client);\n\tif (ptr == NULL)\n\t\treturn -EINVAL;\n\n\tseq_free_client(ptr);\n\tkfree(ptr);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_seq_delete_kernel_client);\n\n/* skeleton to enqueue event, called from snd_seq_kernel_client_enqueue\n * and snd_seq_kernel_client_enqueue_blocking\n */\nstatic int kernel_client_enqueue(int client, struct snd_seq_event *ev,\n\t\t\t\t struct file *file, int blocking,\n\t\t\t\t int atomic, int hop)\n{\n\tstruct snd_seq_client *cptr;\n\tint result;\n\n\tif (snd_BUG_ON(!ev))\n\t\treturn -EINVAL;\n\n\tif (ev->type == SNDRV_SEQ_EVENT_NONE)\n\t\treturn 0; /* ignore this */\n\tif (ev->type == SNDRV_SEQ_EVENT_KERNEL_ERROR)\n\t\treturn -EINVAL; /* quoted events can't be enqueued */\n\n\t/* fill in client number */\n\tev->source.client = client;\n\n\tif (check_event_type_and_length(ev))\n\t\treturn -EINVAL;\n\n\tcptr = snd_seq_client_use_ptr(client);\n\tif (cptr == NULL)\n\t\treturn -EINVAL;\n\t\n\tif (! cptr->accept_output)\n\t\tresult = -EPERM;\n\telse /* send it */\n\t\tresult = snd_seq_client_enqueue_event(cptr, ev, file, blocking, atomic, hop);\n\n\tsnd_seq_client_unlock(cptr);\n\treturn result;\n}\n\n/*\n * exported, called by kernel clients to enqueue events (w/o blocking)\n *\n * RETURN VALUE: zero if succeed, negative if error\n */\nint snd_seq_kernel_client_enqueue(int client, struct snd_seq_event * ev,\n\t\t\t\t  int atomic, int hop)\n{\n\treturn kernel_client_enqueue(client, ev, NULL, 0, atomic, hop);\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_enqueue);\n\n/*\n * exported, called by kernel clients to enqueue events (with blocking)\n *\n * RETURN VALUE: zero if succeed, negative if error\n */\nint snd_seq_kernel_client_enqueue_blocking(int client, struct snd_seq_event * ev,\n\t\t\t\t\t   struct file *file,\n\t\t\t\t\t   int atomic, int hop)\n{\n\treturn kernel_client_enqueue(client, ev, file, 1, atomic, hop);\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_enqueue_blocking);\n\n/* \n * exported, called by kernel clients to dispatch events directly to other\n * clients, bypassing the queues.  Event time-stamp will be updated.\n *\n * RETURN VALUE: negative = delivery failed,\n *\t\t zero, or positive: the number of delivered events\n */\nint snd_seq_kernel_client_dispatch(int client, struct snd_seq_event * ev,\n\t\t\t\t   int atomic, int hop)\n{\n\tstruct snd_seq_client *cptr;\n\tint result;\n\n\tif (snd_BUG_ON(!ev))\n\t\treturn -EINVAL;\n\n\t/* fill in client number */\n\tev->queue = SNDRV_SEQ_QUEUE_DIRECT;\n\tev->source.client = client;\n\n\tif (check_event_type_and_length(ev))\n\t\treturn -EINVAL;\n\n\tcptr = snd_seq_client_use_ptr(client);\n\tif (cptr == NULL)\n\t\treturn -EINVAL;\n\n\tif (!cptr->accept_output)\n\t\tresult = -EPERM;\n\telse\n\t\tresult = snd_seq_deliver_event(cptr, ev, atomic, hop);\n\n\tsnd_seq_client_unlock(cptr);\n\treturn result;\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_dispatch);\n\n/**\n * snd_seq_kernel_client_ctl - operate a command for a client with data in\n *\t\t\t       kernel space.\n * @clientid:\tA numerical ID for a client.\n * @cmd:\tAn ioctl(2) command for ALSA sequencer operation.\n * @arg:\tA pointer to data in kernel space.\n *\n * Against its name, both kernel/application client can be handled by this\n * kernel API. A pointer of 'arg' argument should be in kernel space.\n *\n * Return: 0 at success. Negative error code at failure.\n */\nint snd_seq_kernel_client_ctl(int clientid, unsigned int cmd, void *arg)\n{\n\tconst struct ioctl_handler *handler;\n\tstruct snd_seq_client *client;\n\n\tclient = clientptr(clientid);\n\tif (client == NULL)\n\t\treturn -ENXIO;\n\n\tfor (handler = ioctl_handlers; handler->cmd > 0; ++handler) {\n\t\tif (handler->cmd == cmd)\n\t\t\treturn handler->func(client, arg);\n\t}\n\n\tpr_debug(\"ALSA: seq unknown ioctl() 0x%x (type='%c', number=0x%02x)\\n\",\n\t\t cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));\n\treturn -ENOTTY;\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_ctl);\n\n/* exported (for OSS emulator) */\nint snd_seq_kernel_client_write_poll(int clientid, struct file *file, poll_table *wait)\n{\n\tstruct snd_seq_client *client;\n\n\tclient = clientptr(clientid);\n\tif (client == NULL)\n\t\treturn -ENXIO;\n\n\tif (! snd_seq_write_pool_allocated(client))\n\t\treturn 1;\n\tif (snd_seq_pool_poll_wait(client->pool, file, wait))\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_write_poll);\n\n/*---------------------------------------------------------------------------*/\n\n#ifdef CONFIG_SND_PROC_FS\n/*\n *  /proc interface\n */\nstatic void snd_seq_info_dump_subscribers(struct snd_info_buffer *buffer,\n\t\t\t\t\t  struct snd_seq_port_subs_info *group,\n\t\t\t\t\t  int is_src, char *msg)\n{\n\tstruct list_head *p;\n\tstruct snd_seq_subscribers *s;\n\tint count = 0;\n\n\tdown_read(&group->list_mutex);\n\tif (list_empty(&group->list_head)) {\n\t\tup_read(&group->list_mutex);\n\t\treturn;\n\t}\n\tsnd_iprintf(buffer, msg);\n\tlist_for_each(p, &group->list_head) {\n\t\tif (is_src)\n\t\t\ts = list_entry(p, struct snd_seq_subscribers, src_list);\n\t\telse\n\t\t\ts = list_entry(p, struct snd_seq_subscribers, dest_list);\n\t\tif (count++)\n\t\t\tsnd_iprintf(buffer, \", \");\n\t\tsnd_iprintf(buffer, \"%d:%d\",\n\t\t\t    is_src ? s->info.dest.client : s->info.sender.client,\n\t\t\t    is_src ? s->info.dest.port : s->info.sender.port);\n\t\tif (s->info.flags & SNDRV_SEQ_PORT_SUBS_TIMESTAMP)\n\t\t\tsnd_iprintf(buffer, \"[%c:%d]\", ((s->info.flags & SNDRV_SEQ_PORT_SUBS_TIME_REAL) ? 'r' : 't'), s->info.queue);\n\t\tif (group->exclusive)\n\t\t\tsnd_iprintf(buffer, \"[ex]\");\n\t}\n\tup_read(&group->list_mutex);\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\n#define FLAG_PERM_RD(perm) ((perm) & SNDRV_SEQ_PORT_CAP_READ ? ((perm) & SNDRV_SEQ_PORT_CAP_SUBS_READ ? 'R' : 'r') : '-')\n#define FLAG_PERM_WR(perm) ((perm) & SNDRV_SEQ_PORT_CAP_WRITE ? ((perm) & SNDRV_SEQ_PORT_CAP_SUBS_WRITE ? 'W' : 'w') : '-')\n#define FLAG_PERM_EX(perm) ((perm) & SNDRV_SEQ_PORT_CAP_NO_EXPORT ? '-' : 'e')\n\n#define FLAG_PERM_DUPLEX(perm) ((perm) & SNDRV_SEQ_PORT_CAP_DUPLEX ? 'X' : '-')\n\nstatic void snd_seq_info_dump_ports(struct snd_info_buffer *buffer,\n\t\t\t\t    struct snd_seq_client *client)\n{\n\tstruct snd_seq_client_port *p;\n\n\tmutex_lock(&client->ports_mutex);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tsnd_iprintf(buffer, \"  Port %3d : \\\"%s\\\" (%c%c%c%c)\\n\",\n\t\t\t    p->addr.port, p->name,\n\t\t\t    FLAG_PERM_RD(p->capability),\n\t\t\t    FLAG_PERM_WR(p->capability),\n\t\t\t    FLAG_PERM_EX(p->capability),\n\t\t\t    FLAG_PERM_DUPLEX(p->capability));\n\t\tsnd_seq_info_dump_subscribers(buffer, &p->c_src, 1, \"    Connecting To: \");\n\t\tsnd_seq_info_dump_subscribers(buffer, &p->c_dest, 0, \"    Connected From: \");\n\t}\n\tmutex_unlock(&client->ports_mutex);\n}\n\n\n/* exported to seq_info.c */\nvoid snd_seq_info_clients_read(struct snd_info_entry *entry, \n\t\t\t       struct snd_info_buffer *buffer)\n{\n\tint c;\n\tstruct snd_seq_client *client;\n\n\tsnd_iprintf(buffer, \"Client info\\n\");\n\tsnd_iprintf(buffer, \"  cur  clients : %d\\n\", client_usage.cur);\n\tsnd_iprintf(buffer, \"  peak clients : %d\\n\", client_usage.peak);\n\tsnd_iprintf(buffer, \"  max  clients : %d\\n\", SNDRV_SEQ_MAX_CLIENTS);\n\tsnd_iprintf(buffer, \"\\n\");\n\n\t/* list the client table */\n\tfor (c = 0; c < SNDRV_SEQ_MAX_CLIENTS; c++) {\n\t\tclient = snd_seq_client_use_ptr(c);\n\t\tif (client == NULL)\n\t\t\tcontinue;\n\t\tif (client->type == NO_CLIENT) {\n\t\t\tsnd_seq_client_unlock(client);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsnd_iprintf(buffer, \"Client %3d : \\\"%s\\\" [%s]\\n\",\n\t\t\t    c, client->name,\n\t\t\t    client->type == USER_CLIENT ? \"User\" : \"Kernel\");\n\t\tsnd_seq_info_dump_ports(buffer, client);\n\t\tif (snd_seq_write_pool_allocated(client)) {\n\t\t\tsnd_iprintf(buffer, \"  Output pool :\\n\");\n\t\t\tsnd_seq_info_pool(buffer, client->pool, \"    \");\n\t\t}\n\t\tif (client->type == USER_CLIENT && client->data.user.fifo &&\n\t\t    client->data.user.fifo->pool) {\n\t\t\tsnd_iprintf(buffer, \"  Input pool :\\n\");\n\t\t\tsnd_seq_info_pool(buffer, client->data.user.fifo->pool, \"    \");\n\t\t}\n\t\tsnd_seq_client_unlock(client);\n\t}\n}\n#endif /* CONFIG_SND_PROC_FS */\n\n/*---------------------------------------------------------------------------*/\n\n\n/*\n *  REGISTRATION PART\n */\n\nstatic const struct file_operations snd_seq_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_seq_read,\n\t.write =\tsnd_seq_write,\n\t.open =\t\tsnd_seq_open,\n\t.release =\tsnd_seq_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_seq_poll,\n\t.unlocked_ioctl =\tsnd_seq_ioctl,\n\t.compat_ioctl =\tsnd_seq_ioctl_compat,\n};\n\nstatic struct device seq_dev;\n\n/* \n * register sequencer device \n */\nint __init snd_sequencer_device_init(void)\n{\n\tint err;\n\n\tsnd_device_initialize(&seq_dev, NULL);\n\tdev_set_name(&seq_dev, \"seq\");\n\n\tif (mutex_lock_interruptible(&register_mutex))\n\t\treturn -ERESTARTSYS;\n\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_SEQUENCER, NULL, 0,\n\t\t\t\t  &snd_seq_f_ops, NULL, &seq_dev);\n\tif (err < 0) {\n\t\tmutex_unlock(&register_mutex);\n\t\tput_device(&seq_dev);\n\t\treturn err;\n\t}\n\t\n\tmutex_unlock(&register_mutex);\n\n\treturn 0;\n}\n\n\n\n/* \n * unregister sequencer device \n */\nvoid __exit snd_sequencer_device_done(void)\n{\n\tsnd_unregister_device(&seq_dev);\n\tput_device(&seq_dev);\n}\n", "/*\n *   ALSA sequencer Ports\n *   Copyright (c) 1998 by Frank van de Pol <fvdpol@coil.demon.nl>\n *                         Jaroslav Kysela <perex@perex.cz>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <sound/core.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include \"seq_system.h\"\n#include \"seq_ports.h\"\n#include \"seq_clientmgr.h\"\n\n/*\n\n   registration of client ports\n\n */\n\n\n/* \n\nNOTE: the current implementation of the port structure as a linked list is\nnot optimal for clients that have many ports. For sending messages to all\nsubscribers of a port we first need to find the address of the port\nstructure, which means we have to traverse the list. A direct access table\n(array) would be better, but big preallocated arrays waste memory.\n\nPossible actions:\n\n1) leave it this way, a client does normaly does not have more than a few\nports\n\n2) replace the linked list of ports by a array of pointers which is\ndynamicly kmalloced. When a port is added or deleted we can simply allocate\na new array, copy the corresponding pointers, and delete the old one. We\nthen only need a pointer to this array, and an integer that tells us how\nmuch elements are in array.\n\n*/\n\n/* return pointer to port structure - port is locked if found */\nstruct snd_seq_client_port *snd_seq_port_use_ptr(struct snd_seq_client *client,\n\t\t\t\t\t\t int num)\n{\n\tstruct snd_seq_client_port *port;\n\n\tif (client == NULL)\n\t\treturn NULL;\n\tread_lock(&client->ports_lock);\n\tlist_for_each_entry(port, &client->ports_list_head, list) {\n\t\tif (port->addr.port == num) {\n\t\t\tif (port->closing)\n\t\t\t\tbreak; /* deleting now */\n\t\t\tsnd_use_lock_use(&port->use_lock);\n\t\t\tread_unlock(&client->ports_lock);\n\t\t\treturn port;\n\t\t}\n\t}\n\tread_unlock(&client->ports_lock);\n\treturn NULL;\t\t/* not found */\n}\n\n\n/* search for the next port - port is locked if found */\nstruct snd_seq_client_port *snd_seq_port_query_nearest(struct snd_seq_client *client,\n\t\t\t\t\t\t       struct snd_seq_port_info *pinfo)\n{\n\tint num;\n\tstruct snd_seq_client_port *port, *found;\n\n\tnum = pinfo->addr.port;\n\tfound = NULL;\n\tread_lock(&client->ports_lock);\n\tlist_for_each_entry(port, &client->ports_list_head, list) {\n\t\tif (port->addr.port < num)\n\t\t\tcontinue;\n\t\tif (port->addr.port == num) {\n\t\t\tfound = port;\n\t\t\tbreak;\n\t\t}\n\t\tif (found == NULL || port->addr.port < found->addr.port)\n\t\t\tfound = port;\n\t}\n\tif (found) {\n\t\tif (found->closing)\n\t\t\tfound = NULL;\n\t\telse\n\t\t\tsnd_use_lock_use(&found->use_lock);\n\t}\n\tread_unlock(&client->ports_lock);\n\treturn found;\n}\n\n\n/* initialize snd_seq_port_subs_info */\nstatic void port_subs_info_init(struct snd_seq_port_subs_info *grp)\n{\n\tINIT_LIST_HEAD(&grp->list_head);\n\tgrp->count = 0;\n\tgrp->exclusive = 0;\n\trwlock_init(&grp->list_lock);\n\tinit_rwsem(&grp->list_mutex);\n\tgrp->open = NULL;\n\tgrp->close = NULL;\n}\n\n\n/* create a port, port number is returned (-1 on failure) */\nstruct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n\t\t\t\t\t\tint port)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\t\n\t/* sanity check */\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\n\t/* create a new port */\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t/* failure, out of memory */\n\t/* init port data */\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n\tsnd_use_lock_init(&new_port->use_lock);\n\tport_subs_info_init(&new_port->c_src);\n\tport_subs_info_init(&new_port->c_dest);\n\n\tnum = port >= 0 ? port : 0;\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) /* auto-probe mode */\n\t\t\tnum = p->addr.port + 1;\n\t}\n\t/* insert the new port */\n\tlist_add_tail(&new_port->list, &p->list);\n\tclient->num_ports++;\n\tnew_port->addr.port = num;\t/* store the port number in the port */\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n\n\treturn new_port;\n}\n\n/* */\nstatic int subscribe_port(struct snd_seq_client *client,\n\t\t\t  struct snd_seq_client_port *port,\n\t\t\t  struct snd_seq_port_subs_info *grp,\n\t\t\t  struct snd_seq_port_subscribe *info, int send_ack);\nstatic int unsubscribe_port(struct snd_seq_client *client,\n\t\t\t    struct snd_seq_client_port *port,\n\t\t\t    struct snd_seq_port_subs_info *grp,\n\t\t\t    struct snd_seq_port_subscribe *info, int send_ack);\n\n\nstatic struct snd_seq_client_port *get_client_port(struct snd_seq_addr *addr,\n\t\t\t\t\t\t   struct snd_seq_client **cp)\n{\n\tstruct snd_seq_client_port *p;\n\t*cp = snd_seq_client_use_ptr(addr->client);\n\tif (*cp) {\n\t\tp = snd_seq_port_use_ptr(*cp, addr->port);\n\t\tif (! p) {\n\t\t\tsnd_seq_client_unlock(*cp);\n\t\t\t*cp = NULL;\n\t\t}\n\t\treturn p;\n\t}\n\treturn NULL;\n}\n\nstatic void delete_and_unsubscribe_port(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_client_port *port,\n\t\t\t\t\tstruct snd_seq_subscribers *subs,\n\t\t\t\t\tbool is_src, bool ack);\n\nstatic inline struct snd_seq_subscribers *\nget_subscriber(struct list_head *p, bool is_src)\n{\n\tif (is_src)\n\t\treturn list_entry(p, struct snd_seq_subscribers, src_list);\n\telse\n\t\treturn list_entry(p, struct snd_seq_subscribers, dest_list);\n}\n\n/*\n * remove all subscribers on the list\n * this is called from port_delete, for each src and dest list.\n */\nstatic void clear_subscriber_list(struct snd_seq_client *client,\n\t\t\t\t  struct snd_seq_client_port *port,\n\t\t\t\t  struct snd_seq_port_subs_info *grp,\n\t\t\t\t  int is_src)\n{\n\tstruct list_head *p, *n;\n\n\tlist_for_each_safe(p, n, &grp->list_head) {\n\t\tstruct snd_seq_subscribers *subs;\n\t\tstruct snd_seq_client *c;\n\t\tstruct snd_seq_client_port *aport;\n\n\t\tsubs = get_subscriber(p, is_src);\n\t\tif (is_src)\n\t\t\taport = get_client_port(&subs->info.dest, &c);\n\t\telse\n\t\t\taport = get_client_port(&subs->info.sender, &c);\n\t\tdelete_and_unsubscribe_port(client, port, subs, is_src, false);\n\n\t\tif (!aport) {\n\t\t\t/* looks like the connected port is being deleted.\n\t\t\t * we decrease the counter, and when both ports are deleted\n\t\t\t * remove the subscriber info\n\t\t\t */\n\t\t\tif (atomic_dec_and_test(&subs->ref_count))\n\t\t\t\tkfree(subs);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* ok we got the connected port */\n\t\tdelete_and_unsubscribe_port(c, aport, subs, !is_src, true);\n\t\tkfree(subs);\n\t\tsnd_seq_port_unlock(aport);\n\t\tsnd_seq_client_unlock(c);\n\t}\n}\n\n/* delete port data */\nstatic int port_delete(struct snd_seq_client *client,\n\t\t       struct snd_seq_client_port *port)\n{\n\t/* set closing flag and wait for all port access are gone */\n\tport->closing = 1;\n\tsnd_use_lock_sync(&port->use_lock); \n\n\t/* clear subscribers info */\n\tclear_subscriber_list(client, port, &port->c_src, true);\n\tclear_subscriber_list(client, port, &port->c_dest, false);\n\n\tif (port->private_free)\n\t\tport->private_free(port->private_data);\n\n\tsnd_BUG_ON(port->c_src.count != 0);\n\tsnd_BUG_ON(port->c_dest.count != 0);\n\n\tkfree(port);\n\treturn 0;\n}\n\n\n/* delete a port with the given port id */\nint snd_seq_delete_port(struct snd_seq_client *client, int port)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client_port *found = NULL, *p;\n\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port == port) {\n\t\t\t/* ok found.  delete from the list at first */\n\t\t\tlist_del(&p->list);\n\t\t\tclient->num_ports--;\n\t\t\tfound = p;\n\t\t\tbreak;\n\t\t}\n\t}\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\tmutex_unlock(&client->ports_mutex);\n\tif (found)\n\t\treturn port_delete(client, found);\n\telse\n\t\treturn -ENOENT;\n}\n\n/* delete the all ports belonging to the given client */\nint snd_seq_delete_all_ports(struct snd_seq_client *client)\n{\n\tunsigned long flags;\n\tstruct list_head deleted_list;\n\tstruct snd_seq_client_port *port, *tmp;\n\t\n\t/* move the port list to deleted_list, and\n\t * clear the port list in the client data.\n\t */\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tif (! list_empty(&client->ports_list_head)) {\n\t\tlist_add(&deleted_list, &client->ports_list_head);\n\t\tlist_del_init(&client->ports_list_head);\n\t} else {\n\t\tINIT_LIST_HEAD(&deleted_list);\n\t}\n\tclient->num_ports = 0;\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\n\t/* remove each port in deleted_list */\n\tlist_for_each_entry_safe(port, tmp, &deleted_list, list) {\n\t\tlist_del(&port->list);\n\t\tsnd_seq_system_client_ev_port_exit(port->addr.client, port->addr.port);\n\t\tport_delete(client, port);\n\t}\n\tmutex_unlock(&client->ports_mutex);\n\treturn 0;\n}\n\n/* set port info fields */\nint snd_seq_set_port_info(struct snd_seq_client_port * port,\n\t\t\t  struct snd_seq_port_info * info)\n{\n\tif (snd_BUG_ON(!port || !info))\n\t\treturn -EINVAL;\n\n\t/* set port name */\n\tif (info->name[0])\n\t\tstrlcpy(port->name, info->name, sizeof(port->name));\n\t\n\t/* set capabilities */\n\tport->capability = info->capability;\n\t\n\t/* get port type */\n\tport->type = info->type;\n\n\t/* information about supported channels/voices */\n\tport->midi_channels = info->midi_channels;\n\tport->midi_voices = info->midi_voices;\n\tport->synth_voices = info->synth_voices;\n\n\t/* timestamping */\n\tport->timestamping = (info->flags & SNDRV_SEQ_PORT_FLG_TIMESTAMP) ? 1 : 0;\n\tport->time_real = (info->flags & SNDRV_SEQ_PORT_FLG_TIME_REAL) ? 1 : 0;\n\tport->time_queue = info->time_queue;\n\n\treturn 0;\n}\n\n/* get port info fields */\nint snd_seq_get_port_info(struct snd_seq_client_port * port,\n\t\t\t  struct snd_seq_port_info * info)\n{\n\tif (snd_BUG_ON(!port || !info))\n\t\treturn -EINVAL;\n\n\t/* get port name */\n\tstrlcpy(info->name, port->name, sizeof(info->name));\n\t\n\t/* get capabilities */\n\tinfo->capability = port->capability;\n\n\t/* get port type */\n\tinfo->type = port->type;\n\n\t/* information about supported channels/voices */\n\tinfo->midi_channels = port->midi_channels;\n\tinfo->midi_voices = port->midi_voices;\n\tinfo->synth_voices = port->synth_voices;\n\n\t/* get subscriber counts */\n\tinfo->read_use = port->c_src.count;\n\tinfo->write_use = port->c_dest.count;\n\t\n\t/* timestamping */\n\tinfo->flags = 0;\n\tif (port->timestamping) {\n\t\tinfo->flags |= SNDRV_SEQ_PORT_FLG_TIMESTAMP;\n\t\tif (port->time_real)\n\t\t\tinfo->flags |= SNDRV_SEQ_PORT_FLG_TIME_REAL;\n\t\tinfo->time_queue = port->time_queue;\n\t}\n\n\treturn 0;\n}\n\n\n\n/*\n * call callback functions (if any):\n * the callbacks are invoked only when the first (for connection) or\n * the last subscription (for disconnection) is done.  Second or later\n * subscription results in increment of counter, but no callback is\n * invoked.\n * This feature is useful if these callbacks are associated with\n * initialization or termination of devices (see seq_midi.c).\n */\n\nstatic int subscribe_port(struct snd_seq_client *client,\n\t\t\t  struct snd_seq_client_port *port,\n\t\t\t  struct snd_seq_port_subs_info *grp,\n\t\t\t  struct snd_seq_port_subscribe *info,\n\t\t\t  int send_ack)\n{\n\tint err = 0;\n\n\tif (!try_module_get(port->owner))\n\t\treturn -EFAULT;\n\tgrp->count++;\n\tif (grp->open && grp->count == 1) {\n\t\terr = grp->open(port->private_data, info);\n\t\tif (err < 0) {\n\t\t\tmodule_put(port->owner);\n\t\t\tgrp->count--;\n\t\t}\n\t}\n\tif (err >= 0 && send_ack && client->type == USER_CLIENT)\n\t\tsnd_seq_client_notify_subscription(port->addr.client, port->addr.port,\n\t\t\t\t\t\t   info, SNDRV_SEQ_EVENT_PORT_SUBSCRIBED);\n\n\treturn err;\n}\n\nstatic int unsubscribe_port(struct snd_seq_client *client,\n\t\t\t    struct snd_seq_client_port *port,\n\t\t\t    struct snd_seq_port_subs_info *grp,\n\t\t\t    struct snd_seq_port_subscribe *info,\n\t\t\t    int send_ack)\n{\n\tint err = 0;\n\n\tif (! grp->count)\n\t\treturn -EINVAL;\n\tgrp->count--;\n\tif (grp->close && grp->count == 0)\n\t\terr = grp->close(port->private_data, info);\n\tif (send_ack && client->type == USER_CLIENT)\n\t\tsnd_seq_client_notify_subscription(port->addr.client, port->addr.port,\n\t\t\t\t\t\t   info, SNDRV_SEQ_EVENT_PORT_UNSUBSCRIBED);\n\tmodule_put(port->owner);\n\treturn err;\n}\n\n\n\n/* check if both addresses are identical */\nstatic inline int addr_match(struct snd_seq_addr *r, struct snd_seq_addr *s)\n{\n\treturn (r->client == s->client) && (r->port == s->port);\n}\n\n/* check the two subscribe info match */\n/* if flags is zero, checks only sender and destination addresses */\nstatic int match_subs_info(struct snd_seq_port_subscribe *r,\n\t\t\t   struct snd_seq_port_subscribe *s)\n{\n\tif (addr_match(&r->sender, &s->sender) &&\n\t    addr_match(&r->dest, &s->dest)) {\n\t\tif (r->flags && r->flags == s->flags)\n\t\t\treturn r->queue == s->queue;\n\t\telse if (! r->flags)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int check_and_subscribe_port(struct snd_seq_client *client,\n\t\t\t\t    struct snd_seq_client_port *port,\n\t\t\t\t    struct snd_seq_subscribers *subs,\n\t\t\t\t    bool is_src, bool exclusive, bool ack)\n{\n\tstruct snd_seq_port_subs_info *grp;\n\tstruct list_head *p;\n\tstruct snd_seq_subscribers *s;\n\tint err;\n\n\tgrp = is_src ? &port->c_src : &port->c_dest;\n\terr = -EBUSY;\n\tdown_write(&grp->list_mutex);\n\tif (exclusive) {\n\t\tif (!list_empty(&grp->list_head))\n\t\t\tgoto __error;\n\t} else {\n\t\tif (grp->exclusive)\n\t\t\tgoto __error;\n\t\t/* check whether already exists */\n\t\tlist_for_each(p, &grp->list_head) {\n\t\t\ts = get_subscriber(p, is_src);\n\t\t\tif (match_subs_info(&subs->info, &s->info))\n\t\t\t\tgoto __error;\n\t\t}\n\t}\n\n\terr = subscribe_port(client, port, grp, &subs->info, ack);\n\tif (err < 0) {\n\t\tgrp->exclusive = 0;\n\t\tgoto __error;\n\t}\n\n\t/* add to list */\n\twrite_lock_irq(&grp->list_lock);\n\tif (is_src)\n\t\tlist_add_tail(&subs->src_list, &grp->list_head);\n\telse\n\t\tlist_add_tail(&subs->dest_list, &grp->list_head);\n\tgrp->exclusive = exclusive;\n\tatomic_inc(&subs->ref_count);\n\twrite_unlock_irq(&grp->list_lock);\n\terr = 0;\n\n __error:\n\tup_write(&grp->list_mutex);\n\treturn err;\n}\n\nstatic void delete_and_unsubscribe_port(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_client_port *port,\n\t\t\t\t\tstruct snd_seq_subscribers *subs,\n\t\t\t\t\tbool is_src, bool ack)\n{\n\tstruct snd_seq_port_subs_info *grp;\n\tstruct list_head *list;\n\tbool empty;\n\n\tgrp = is_src ? &port->c_src : &port->c_dest;\n\tlist = is_src ? &subs->src_list : &subs->dest_list;\n\tdown_write(&grp->list_mutex);\n\twrite_lock_irq(&grp->list_lock);\n\tempty = list_empty(list);\n\tif (!empty)\n\t\tlist_del_init(list);\n\tgrp->exclusive = 0;\n\twrite_unlock_irq(&grp->list_lock);\n\tup_write(&grp->list_mutex);\n\n\tif (!empty)\n\t\tunsubscribe_port(client, port, grp, &subs->info, ack);\n}\n\n/* connect two ports */\nint snd_seq_port_connect(struct snd_seq_client *connector,\n\t\t\t struct snd_seq_client *src_client,\n\t\t\t struct snd_seq_client_port *src_port,\n\t\t\t struct snd_seq_client *dest_client,\n\t\t\t struct snd_seq_client_port *dest_port,\n\t\t\t struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_seq_subscribers *subs;\n\tbool exclusive;\n\tint err;\n\n\tsubs = kzalloc(sizeof(*subs), GFP_KERNEL);\n\tif (!subs)\n\t\treturn -ENOMEM;\n\n\tsubs->info = *info;\n\tatomic_set(&subs->ref_count, 0);\n\tINIT_LIST_HEAD(&subs->src_list);\n\tINIT_LIST_HEAD(&subs->dest_list);\n\n\texclusive = !!(info->flags & SNDRV_SEQ_PORT_SUBS_EXCLUSIVE);\n\n\terr = check_and_subscribe_port(src_client, src_port, subs, true,\n\t\t\t\t       exclusive,\n\t\t\t\t       connector->number != src_client->number);\n\tif (err < 0)\n\t\tgoto error;\n\terr = check_and_subscribe_port(dest_client, dest_port, subs, false,\n\t\t\t\t       exclusive,\n\t\t\t\t       connector->number != dest_client->number);\n\tif (err < 0)\n\t\tgoto error_dest;\n\n\treturn 0;\n\n error_dest:\n\tdelete_and_unsubscribe_port(src_client, src_port, subs, true,\n\t\t\t\t    connector->number != src_client->number);\n error:\n\tkfree(subs);\n\treturn err;\n}\n\n/* remove the connection */\nint snd_seq_port_disconnect(struct snd_seq_client *connector,\n\t\t\t    struct snd_seq_client *src_client,\n\t\t\t    struct snd_seq_client_port *src_port,\n\t\t\t    struct snd_seq_client *dest_client,\n\t\t\t    struct snd_seq_client_port *dest_port,\n\t\t\t    struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_seq_port_subs_info *src = &src_port->c_src;\n\tstruct snd_seq_subscribers *subs;\n\tint err = -ENOENT;\n\n\tdown_write(&src->list_mutex);\n\t/* look for the connection */\n\tlist_for_each_entry(subs, &src->list_head, src_list) {\n\t\tif (match_subs_info(info, &subs->info)) {\n\t\t\tatomic_dec(&subs->ref_count); /* mark as not ready */\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&src->list_mutex);\n\tif (err < 0)\n\t\treturn err;\n\n\tdelete_and_unsubscribe_port(src_client, src_port, subs, true,\n\t\t\t\t    connector->number != src_client->number);\n\tdelete_and_unsubscribe_port(dest_client, dest_port, subs, false,\n\t\t\t\t    connector->number != dest_client->number);\n\tkfree(subs);\n\treturn 0;\n}\n\n\n/* get matched subscriber */\nstruct snd_seq_subscribers *snd_seq_port_get_subscription(struct snd_seq_port_subs_info *src_grp,\n\t\t\t\t\t\t\t  struct snd_seq_addr *dest_addr)\n{\n\tstruct snd_seq_subscribers *s, *found = NULL;\n\n\tdown_read(&src_grp->list_mutex);\n\tlist_for_each_entry(s, &src_grp->list_head, src_list) {\n\t\tif (addr_match(dest_addr, &s->info.dest)) {\n\t\t\tfound = s;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&src_grp->list_mutex);\n\treturn found;\n}\n\n/*\n * Attach a device driver that wants to receive events from the\n * sequencer.  Returns the new port number on success.\n * A driver that wants to receive the events converted to midi, will\n * use snd_seq_midisynth_register_port().\n */\n/* exported */\nint snd_seq_event_port_attach(int client,\n\t\t\t      struct snd_seq_port_callback *pcbp,\n\t\t\t      int cap, int type, int midi_channels,\n\t\t\t      int midi_voices, char *portname)\n{\n\tstruct snd_seq_port_info portinfo;\n\tint  ret;\n\n\t/* Set up the port */\n\tmemset(&portinfo, 0, sizeof(portinfo));\n\tportinfo.addr.client = client;\n\tstrlcpy(portinfo.name, portname ? portname : \"Unamed port\",\n\t\tsizeof(portinfo.name));\n\n\tportinfo.capability = cap;\n\tportinfo.type = type;\n\tportinfo.kernel = pcbp;\n\tportinfo.midi_channels = midi_channels;\n\tportinfo.midi_voices = midi_voices;\n\n\t/* Create it */\n\tret = snd_seq_kernel_client_ctl(client,\n\t\t\t\t\tSNDRV_SEQ_IOCTL_CREATE_PORT,\n\t\t\t\t\t&portinfo);\n\n\tif (ret >= 0)\n\t\tret = portinfo.addr.port;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_seq_event_port_attach);\n\n/*\n * Detach the driver from a port.\n */\n/* exported */\nint snd_seq_event_port_detach(int client, int port)\n{\n\tstruct snd_seq_port_info portinfo;\n\tint  err;\n\n\tmemset(&portinfo, 0, sizeof(portinfo));\n\tportinfo.addr.client = client;\n\tportinfo.addr.port   = port;\n\terr = snd_seq_kernel_client_ctl(client,\n\t\t\t\t\tSNDRV_SEQ_IOCTL_DELETE_PORT,\n\t\t\t\t\t&portinfo);\n\n\treturn err;\n}\nEXPORT_SYMBOL(snd_seq_event_port_detach);\n"], "fixing_code": ["/*\n *  ALSA sequencer Client Manager\n *  Copyright (c) 1998-2001 by Frank van de Pol <fvdpol@coil.demon.nl>\n *                             Jaroslav Kysela <perex@perex.cz>\n *                             Takashi Iwai <tiwai@suse.de>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <linux/kmod.h>\n\n#include <sound/seq_kernel.h>\n#include \"seq_clientmgr.h\"\n#include \"seq_memory.h\"\n#include \"seq_queue.h\"\n#include \"seq_timer.h\"\n#include \"seq_info.h\"\n#include \"seq_system.h\"\n#include <sound/seq_device.h>\n#ifdef CONFIG_COMPAT\n#include <linux/compat.h>\n#endif\n\n/* Client Manager\n\n * this module handles the connections of userland and kernel clients\n * \n */\n\n/*\n * There are four ranges of client numbers (last two shared):\n * 0..15: global clients\n * 16..127: statically allocated client numbers for cards 0..27\n * 128..191: dynamically allocated client numbers for cards 28..31\n * 128..191: dynamically allocated client numbers for applications\n */\n\n/* number of kernel non-card clients */\n#define SNDRV_SEQ_GLOBAL_CLIENTS\t16\n/* clients per cards, for static clients */\n#define SNDRV_SEQ_CLIENTS_PER_CARD\t4\n/* dynamically allocated client numbers (both kernel drivers and user space) */\n#define SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN\t128\n\n#define SNDRV_SEQ_LFLG_INPUT\t0x0001\n#define SNDRV_SEQ_LFLG_OUTPUT\t0x0002\n#define SNDRV_SEQ_LFLG_OPEN\t(SNDRV_SEQ_LFLG_INPUT|SNDRV_SEQ_LFLG_OUTPUT)\n\nstatic DEFINE_SPINLOCK(clients_lock);\nstatic DEFINE_MUTEX(register_mutex);\n\n/*\n * client table\n */\nstatic char clienttablock[SNDRV_SEQ_MAX_CLIENTS];\nstatic struct snd_seq_client *clienttab[SNDRV_SEQ_MAX_CLIENTS];\nstatic struct snd_seq_usage client_usage;\n\n/*\n * prototypes\n */\nstatic int bounce_error_event(struct snd_seq_client *client,\n\t\t\t      struct snd_seq_event *event,\n\t\t\t      int err, int atomic, int hop);\nstatic int snd_seq_deliver_single_event(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\t\tint filter, int atomic, int hop);\n\n/*\n */\nstatic inline unsigned short snd_seq_file_flags(struct file *file)\n{\n        switch (file->f_mode & (FMODE_READ | FMODE_WRITE)) {\n        case FMODE_WRITE:\n                return SNDRV_SEQ_LFLG_OUTPUT;\n        case FMODE_READ:\n                return SNDRV_SEQ_LFLG_INPUT;\n        default:\n                return SNDRV_SEQ_LFLG_OPEN;\n        }\n}\n\nstatic inline int snd_seq_write_pool_allocated(struct snd_seq_client *client)\n{\n\treturn snd_seq_total_cells(client->pool) > 0;\n}\n\n/* return pointer to client structure for specified id */\nstatic struct snd_seq_client *clientptr(int clientid)\n{\n\tif (clientid < 0 || clientid >= SNDRV_SEQ_MAX_CLIENTS) {\n\t\tpr_debug(\"ALSA: seq: oops. Trying to get pointer to client %d\\n\",\n\t\t\t   clientid);\n\t\treturn NULL;\n\t}\n\treturn clienttab[clientid];\n}\n\nstruct snd_seq_client *snd_seq_client_use_ptr(int clientid)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client *client;\n\n\tif (clientid < 0 || clientid >= SNDRV_SEQ_MAX_CLIENTS) {\n\t\tpr_debug(\"ALSA: seq: oops. Trying to get pointer to client %d\\n\",\n\t\t\t   clientid);\n\t\treturn NULL;\n\t}\n\tspin_lock_irqsave(&clients_lock, flags);\n\tclient = clientptr(clientid);\n\tif (client)\n\t\tgoto __lock;\n\tif (clienttablock[clientid]) {\n\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t\treturn NULL;\n\t}\n\tspin_unlock_irqrestore(&clients_lock, flags);\n#ifdef CONFIG_MODULES\n\tif (!in_interrupt()) {\n\t\tstatic char client_requested[SNDRV_SEQ_GLOBAL_CLIENTS];\n\t\tstatic char card_requested[SNDRV_CARDS];\n\t\tif (clientid < SNDRV_SEQ_GLOBAL_CLIENTS) {\n\t\t\tint idx;\n\t\t\t\n\t\t\tif (!client_requested[clientid]) {\n\t\t\t\tclient_requested[clientid] = 1;\n\t\t\t\tfor (idx = 0; idx < 15; idx++) {\n\t\t\t\t\tif (seq_client_load[idx] < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (seq_client_load[idx] == clientid) {\n\t\t\t\t\t\trequest_module(\"snd-seq-client-%i\",\n\t\t\t\t\t\t\t       clientid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (clientid < SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN) {\n\t\t\tint card = (clientid - SNDRV_SEQ_GLOBAL_CLIENTS) /\n\t\t\t\tSNDRV_SEQ_CLIENTS_PER_CARD;\n\t\t\tif (card < snd_ecards_limit) {\n\t\t\t\tif (! card_requested[card]) {\n\t\t\t\t\tcard_requested[card] = 1;\n\t\t\t\t\tsnd_request_card(card);\n\t\t\t\t}\n\t\t\t\tsnd_seq_device_load_drivers();\n\t\t\t}\n\t\t}\n\t\tspin_lock_irqsave(&clients_lock, flags);\n\t\tclient = clientptr(clientid);\n\t\tif (client)\n\t\t\tgoto __lock;\n\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t}\n#endif\n\treturn NULL;\n\n      __lock:\n\tsnd_use_lock_use(&client->use_lock);\n\tspin_unlock_irqrestore(&clients_lock, flags);\n\treturn client;\n}\n\nstatic void usage_alloc(struct snd_seq_usage *res, int num)\n{\n\tres->cur += num;\n\tif (res->cur > res->peak)\n\t\tres->peak = res->cur;\n}\n\nstatic void usage_free(struct snd_seq_usage *res, int num)\n{\n\tres->cur -= num;\n}\n\n/* initialise data structures */\nint __init client_init_data(void)\n{\n\t/* zap out the client table */\n\tmemset(&clienttablock, 0, sizeof(clienttablock));\n\tmemset(&clienttab, 0, sizeof(clienttab));\n\treturn 0;\n}\n\n\nstatic struct snd_seq_client *seq_create_client1(int client_index, int poolsize)\n{\n\tunsigned long flags;\n\tint c;\n\tstruct snd_seq_client *client;\n\n\t/* init client data */\n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (client == NULL)\n\t\treturn NULL;\n\tclient->pool = snd_seq_pool_new(poolsize);\n\tif (client->pool == NULL) {\n\t\tkfree(client);\n\t\treturn NULL;\n\t}\n\tclient->type = NO_CLIENT;\n\tsnd_use_lock_init(&client->use_lock);\n\trwlock_init(&client->ports_lock);\n\tmutex_init(&client->ports_mutex);\n\tINIT_LIST_HEAD(&client->ports_list_head);\n\n\t/* find free slot in the client table */\n\tspin_lock_irqsave(&clients_lock, flags);\n\tif (client_index < 0) {\n\t\tfor (c = SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN;\n\t\t     c < SNDRV_SEQ_MAX_CLIENTS;\n\t\t     c++) {\n\t\t\tif (clienttab[c] || clienttablock[c])\n\t\t\t\tcontinue;\n\t\t\tclienttab[client->number = c] = client;\n\t\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t\t\treturn client;\n\t\t}\n\t} else {\n\t\tif (clienttab[client_index] == NULL && !clienttablock[client_index]) {\n\t\t\tclienttab[client->number = client_index] = client;\n\t\t\tspin_unlock_irqrestore(&clients_lock, flags);\n\t\t\treturn client;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&clients_lock, flags);\n\tsnd_seq_pool_delete(&client->pool);\n\tkfree(client);\n\treturn NULL;\t/* no free slot found or busy, return failure code */\n}\n\n\nstatic int seq_free_client1(struct snd_seq_client *client)\n{\n\tunsigned long flags;\n\n\tif (!client)\n\t\treturn 0;\n\tsnd_seq_delete_all_ports(client);\n\tsnd_seq_queue_client_leave(client->number);\n\tspin_lock_irqsave(&clients_lock, flags);\n\tclienttablock[client->number] = 1;\n\tclienttab[client->number] = NULL;\n\tspin_unlock_irqrestore(&clients_lock, flags);\n\tsnd_use_lock_sync(&client->use_lock);\n\tsnd_seq_queue_client_termination(client->number);\n\tif (client->pool)\n\t\tsnd_seq_pool_delete(&client->pool);\n\tspin_lock_irqsave(&clients_lock, flags);\n\tclienttablock[client->number] = 0;\n\tspin_unlock_irqrestore(&clients_lock, flags);\n\treturn 0;\n}\n\n\nstatic void seq_free_client(struct snd_seq_client * client)\n{\n\tmutex_lock(&register_mutex);\n\tswitch (client->type) {\n\tcase NO_CLIENT:\n\t\tpr_warn(\"ALSA: seq: Trying to free unused client %d\\n\",\n\t\t\tclient->number);\n\t\tbreak;\n\tcase USER_CLIENT:\n\tcase KERNEL_CLIENT:\n\t\tseq_free_client1(client);\n\t\tusage_free(&client_usage, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"ALSA: seq: Trying to free client %d with undefined type = %d\\n\",\n\t\t\t   client->number, client->type);\n\t}\n\tmutex_unlock(&register_mutex);\n\n\tsnd_seq_system_client_ev_client_exit(client->number);\n}\n\n\n\n/* -------------------------------------------------------- */\n\n/* create a user client */\nstatic int snd_seq_open(struct inode *inode, struct file *file)\n{\n\tint c, mode;\t\t\t/* client id */\n\tstruct snd_seq_client *client;\n\tstruct snd_seq_user_client *user;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (mutex_lock_interruptible(&register_mutex))\n\t\treturn -ERESTARTSYS;\n\tclient = seq_create_client1(-1, SNDRV_SEQ_DEFAULT_EVENTS);\n\tif (client == NULL) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -ENOMEM;\t/* failure code */\n\t}\n\n\tmode = snd_seq_file_flags(file);\n\tif (mode & SNDRV_SEQ_LFLG_INPUT)\n\t\tclient->accept_input = 1;\n\tif (mode & SNDRV_SEQ_LFLG_OUTPUT)\n\t\tclient->accept_output = 1;\n\n\tuser = &client->data.user;\n\tuser->fifo = NULL;\n\tuser->fifo_pool_size = 0;\n\n\tif (mode & SNDRV_SEQ_LFLG_INPUT) {\n\t\tuser->fifo_pool_size = SNDRV_SEQ_DEFAULT_CLIENT_EVENTS;\n\t\tuser->fifo = snd_seq_fifo_new(user->fifo_pool_size);\n\t\tif (user->fifo == NULL) {\n\t\t\tseq_free_client1(client);\n\t\t\tkfree(client);\n\t\t\tmutex_unlock(&register_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tusage_alloc(&client_usage, 1);\n\tclient->type = USER_CLIENT;\n\tmutex_unlock(&register_mutex);\n\n\tc = client->number;\n\tfile->private_data = client;\n\n\t/* fill client data */\n\tuser->file = file;\n\tsprintf(client->name, \"Client-%d\", c);\n\tclient->data.user.owner = get_pid(task_pid(current));\n\n\t/* make others aware this new client */\n\tsnd_seq_system_client_ev_client_start(c);\n\n\treturn 0;\n}\n\n/* delete a user client */\nstatic int snd_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\n\tif (client) {\n\t\tseq_free_client(client);\n\t\tif (client->data.user.fifo)\n\t\t\tsnd_seq_fifo_delete(&client->data.user.fifo);\n\t\tput_pid(client->data.user.owner);\n\t\tkfree(client);\n\t}\n\n\treturn 0;\n}\n\n\n/* handle client read() */\n/* possible error values:\n *\t-ENXIO\tinvalid client or file open mode\n *\t-ENOSPC\tFIFO overflow (the flag is cleared after this error report)\n *\t-EINVAL\tno enough user-space buffer to write the whole event\n *\t-EFAULT\tseg. fault during copy to user space\n */\nstatic ssize_t snd_seq_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *offset)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tstruct snd_seq_fifo *fifo;\n\tint err;\n\tlong result = 0;\n\tstruct snd_seq_event_cell *cell;\n\n\tif (!(snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_INPUT))\n\t\treturn -ENXIO;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\t/* check client structures are in place */\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\n\tif (!client->accept_input || (fifo = client->data.user.fifo) == NULL)\n\t\treturn -ENXIO;\n\n\tif (atomic_read(&fifo->overflow) > 0) {\n\t\t/* buffer overflow is detected */\n\t\tsnd_seq_fifo_clear(fifo);\n\t\t/* return error code */\n\t\treturn -ENOSPC;\n\t}\n\n\tcell = NULL;\n\terr = 0;\n\tsnd_seq_fifo_lock(fifo);\n\n\t/* while data available in queue */\n\twhile (count >= sizeof(struct snd_seq_event)) {\n\t\tint nonblock;\n\n\t\tnonblock = (file->f_flags & O_NONBLOCK) || result > 0;\n\t\tif ((err = snd_seq_fifo_cell_out(fifo, &cell, nonblock)) < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (snd_seq_ev_is_variable(&cell->event)) {\n\t\t\tstruct snd_seq_event tmpev;\n\t\t\ttmpev = cell->event;\n\t\t\ttmpev.data.ext.len &= ~SNDRV_SEQ_EXT_MASK;\n\t\t\tif (copy_to_user(buf, &tmpev, sizeof(struct snd_seq_event))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount -= sizeof(struct snd_seq_event);\n\t\t\tbuf += sizeof(struct snd_seq_event);\n\t\t\terr = snd_seq_expand_var_event(&cell->event, count,\n\t\t\t\t\t\t       (char __force *)buf, 0,\n\t\t\t\t\t\t       sizeof(struct snd_seq_event));\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\tresult += err;\n\t\t\tcount -= err;\n\t\t\tbuf += err;\n\t\t} else {\n\t\t\tif (copy_to_user(buf, &cell->event, sizeof(struct snd_seq_event))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount -= sizeof(struct snd_seq_event);\n\t\t\tbuf += sizeof(struct snd_seq_event);\n\t\t}\n\t\tsnd_seq_cell_free(cell);\n\t\tcell = NULL; /* to be sure */\n\t\tresult += sizeof(struct snd_seq_event);\n\t}\n\n\tif (err < 0) {\n\t\tif (cell)\n\t\t\tsnd_seq_fifo_cell_putback(fifo, cell);\n\t\tif (err == -EAGAIN && result > 0)\n\t\t\terr = 0;\n\t}\n\tsnd_seq_fifo_unlock(fifo);\n\n\treturn (err < 0) ? err : result;\n}\n\n\n/*\n * check access permission to the port\n */\nstatic int check_port_perm(struct snd_seq_client_port *port, unsigned int flags)\n{\n\tif ((port->capability & flags) != flags)\n\t\treturn 0;\n\treturn flags;\n}\n\n/*\n * check if the destination client is available, and return the pointer\n * if filter is non-zero, client filter bitmap is tested.\n */\nstatic struct snd_seq_client *get_event_dest_client(struct snd_seq_event *event,\n\t\t\t\t\t\t    int filter)\n{\n\tstruct snd_seq_client *dest;\n\n\tdest = snd_seq_client_use_ptr(event->dest.client);\n\tif (dest == NULL)\n\t\treturn NULL;\n\tif (! dest->accept_input)\n\t\tgoto __not_avail;\n\tif ((dest->filter & SNDRV_SEQ_FILTER_USE_EVENT) &&\n\t    ! test_bit(event->type, dest->event_filter))\n\t\tgoto __not_avail;\n\tif (filter && !(dest->filter & filter))\n\t\tgoto __not_avail;\n\n\treturn dest; /* ok - accessible */\n__not_avail:\n\tsnd_seq_client_unlock(dest);\n\treturn NULL;\n}\n\n\n/*\n * Return the error event.\n *\n * If the receiver client is a user client, the original event is\n * encapsulated in SNDRV_SEQ_EVENT_BOUNCE as variable length event.  If\n * the original event is also variable length, the external data is\n * copied after the event record. \n * If the receiver client is a kernel client, the original event is\n * quoted in SNDRV_SEQ_EVENT_KERNEL_ERROR, since this requires no extra\n * kmalloc.\n */\nstatic int bounce_error_event(struct snd_seq_client *client,\n\t\t\t      struct snd_seq_event *event,\n\t\t\t      int err, int atomic, int hop)\n{\n\tstruct snd_seq_event bounce_ev;\n\tint result;\n\n\tif (client == NULL ||\n\t    ! (client->filter & SNDRV_SEQ_FILTER_BOUNCE) ||\n\t    ! client->accept_input)\n\t\treturn 0; /* ignored */\n\n\t/* set up quoted error */\n\tmemset(&bounce_ev, 0, sizeof(bounce_ev));\n\tbounce_ev.type = SNDRV_SEQ_EVENT_KERNEL_ERROR;\n\tbounce_ev.flags = SNDRV_SEQ_EVENT_LENGTH_FIXED;\n\tbounce_ev.queue = SNDRV_SEQ_QUEUE_DIRECT;\n\tbounce_ev.source.client = SNDRV_SEQ_CLIENT_SYSTEM;\n\tbounce_ev.source.port = SNDRV_SEQ_PORT_SYSTEM_ANNOUNCE;\n\tbounce_ev.dest.client = client->number;\n\tbounce_ev.dest.port = event->source.port;\n\tbounce_ev.data.quote.origin = event->dest;\n\tbounce_ev.data.quote.event = event;\n\tbounce_ev.data.quote.value = -err; /* use positive value */\n\tresult = snd_seq_deliver_single_event(NULL, &bounce_ev, 0, atomic, hop + 1);\n\tif (result < 0) {\n\t\tclient->event_lost++;\n\t\treturn result;\n\t}\n\n\treturn result;\n}\n\n\n/*\n * rewrite the time-stamp of the event record with the curren time\n * of the given queue.\n * return non-zero if updated.\n */\nstatic int update_timestamp_of_queue(struct snd_seq_event *event,\n\t\t\t\t     int queue, int real_time)\n{\n\tstruct snd_seq_queue *q;\n\n\tq = queueptr(queue);\n\tif (! q)\n\t\treturn 0;\n\tevent->queue = queue;\n\tevent->flags &= ~SNDRV_SEQ_TIME_STAMP_MASK;\n\tif (real_time) {\n\t\tevent->time.time = snd_seq_timer_get_cur_time(q->timer);\n\t\tevent->flags |= SNDRV_SEQ_TIME_STAMP_REAL;\n\t} else {\n\t\tevent->time.tick = snd_seq_timer_get_cur_tick(q->timer);\n\t\tevent->flags |= SNDRV_SEQ_TIME_STAMP_TICK;\n\t}\n\tqueuefree(q);\n\treturn 1;\n}\n\n\n/*\n * deliver an event to the specified destination.\n * if filter is non-zero, client filter bitmap is tested.\n *\n *  RETURN VALUE: 0 : if succeeded\n *\t\t <0 : error\n */\nstatic int snd_seq_deliver_single_event(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\t\tint filter, int atomic, int hop)\n{\n\tstruct snd_seq_client *dest = NULL;\n\tstruct snd_seq_client_port *dest_port = NULL;\n\tint result = -ENOENT;\n\tint direct;\n\n\tdirect = snd_seq_ev_is_direct(event);\n\n\tdest = get_event_dest_client(event, filter);\n\tif (dest == NULL)\n\t\tgoto __skip;\n\tdest_port = snd_seq_port_use_ptr(dest, event->dest.port);\n\tif (dest_port == NULL)\n\t\tgoto __skip;\n\n\t/* check permission */\n\tif (! check_port_perm(dest_port, SNDRV_SEQ_PORT_CAP_WRITE)) {\n\t\tresult = -EPERM;\n\t\tgoto __skip;\n\t}\n\t\t\n\tif (dest_port->timestamping)\n\t\tupdate_timestamp_of_queue(event, dest_port->time_queue,\n\t\t\t\t\t  dest_port->time_real);\n\n\tswitch (dest->type) {\n\tcase USER_CLIENT:\n\t\tif (dest->data.user.fifo)\n\t\t\tresult = snd_seq_fifo_event_in(dest->data.user.fifo, event);\n\t\tbreak;\n\n\tcase KERNEL_CLIENT:\n\t\tif (dest_port->event_input == NULL)\n\t\t\tbreak;\n\t\tresult = dest_port->event_input(event, direct,\n\t\t\t\t\t\tdest_port->private_data,\n\t\t\t\t\t\tatomic, hop);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n  __skip:\n\tif (dest_port)\n\t\tsnd_seq_port_unlock(dest_port);\n\tif (dest)\n\t\tsnd_seq_client_unlock(dest);\n\n\tif (result < 0 && !direct) {\n\t\tresult = bounce_error_event(client, event, result, atomic, hop);\n\t}\n\treturn result;\n}\n\n\n/*\n * send the event to all subscribers:\n */\nstatic int deliver_to_subscribers(struct snd_seq_client *client,\n\t\t\t\t  struct snd_seq_event *event,\n\t\t\t\t  int atomic, int hop)\n{\n\tstruct snd_seq_subscribers *subs;\n\tint err, result = 0, num_ev = 0;\n\tstruct snd_seq_event event_saved;\n\tstruct snd_seq_client_port *src_port;\n\tstruct snd_seq_port_subs_info *grp;\n\n\tsrc_port = snd_seq_port_use_ptr(client, event->source.port);\n\tif (src_port == NULL)\n\t\treturn -EINVAL; /* invalid source port */\n\t/* save original event record */\n\tevent_saved = *event;\n\tgrp = &src_port->c_src;\n\t\n\t/* lock list */\n\tif (atomic)\n\t\tread_lock(&grp->list_lock);\n\telse\n\t\tdown_read(&grp->list_mutex);\n\tlist_for_each_entry(subs, &grp->list_head, src_list) {\n\t\t/* both ports ready? */\n\t\tif (atomic_read(&subs->ref_count) != 2)\n\t\t\tcontinue;\n\t\tevent->dest = subs->info.dest;\n\t\tif (subs->info.flags & SNDRV_SEQ_PORT_SUBS_TIMESTAMP)\n\t\t\t/* convert time according to flag with subscription */\n\t\t\tupdate_timestamp_of_queue(event, subs->info.queue,\n\t\t\t\t\t\t  subs->info.flags & SNDRV_SEQ_PORT_SUBS_TIME_REAL);\n\t\terr = snd_seq_deliver_single_event(client, event,\n\t\t\t\t\t\t   0, atomic, hop);\n\t\tif (err < 0) {\n\t\t\t/* save first error that occurs and continue */\n\t\t\tif (!result)\n\t\t\t\tresult = err;\n\t\t\tcontinue;\n\t\t}\n\t\tnum_ev++;\n\t\t/* restore original event record */\n\t\t*event = event_saved;\n\t}\n\tif (atomic)\n\t\tread_unlock(&grp->list_lock);\n\telse\n\t\tup_read(&grp->list_mutex);\n\t*event = event_saved; /* restore */\n\tsnd_seq_port_unlock(src_port);\n\treturn (result < 0) ? result : num_ev;\n}\n\n\n#ifdef SUPPORT_BROADCAST \n/*\n * broadcast to all ports:\n */\nstatic int port_broadcast_event(struct snd_seq_client *client,\n\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\tint atomic, int hop)\n{\n\tint num_ev = 0, err, result = 0;\n\tstruct snd_seq_client *dest_client;\n\tstruct snd_seq_client_port *port;\n\n\tdest_client = get_event_dest_client(event, SNDRV_SEQ_FILTER_BROADCAST);\n\tif (dest_client == NULL)\n\t\treturn 0; /* no matching destination */\n\n\tread_lock(&dest_client->ports_lock);\n\tlist_for_each_entry(port, &dest_client->ports_list_head, list) {\n\t\tevent->dest.port = port->addr.port;\n\t\t/* pass NULL as source client to avoid error bounce */\n\t\terr = snd_seq_deliver_single_event(NULL, event,\n\t\t\t\t\t\t   SNDRV_SEQ_FILTER_BROADCAST,\n\t\t\t\t\t\t   atomic, hop);\n\t\tif (err < 0) {\n\t\t\t/* save first error that occurs and continue */\n\t\t\tif (!result)\n\t\t\t\tresult = err;\n\t\t\tcontinue;\n\t\t}\n\t\tnum_ev++;\n\t}\n\tread_unlock(&dest_client->ports_lock);\n\tsnd_seq_client_unlock(dest_client);\n\tevent->dest.port = SNDRV_SEQ_ADDRESS_BROADCAST; /* restore */\n\treturn (result < 0) ? result : num_ev;\n}\n\n/*\n * send the event to all clients:\n * if destination port is also ADDRESS_BROADCAST, deliver to all ports.\n */\nstatic int broadcast_event(struct snd_seq_client *client,\n\t\t\t   struct snd_seq_event *event, int atomic, int hop)\n{\n\tint err, result = 0, num_ev = 0;\n\tint dest;\n\tstruct snd_seq_addr addr;\n\n\taddr = event->dest; /* save */\n\n\tfor (dest = 0; dest < SNDRV_SEQ_MAX_CLIENTS; dest++) {\n\t\t/* don't send to itself */\n\t\tif (dest == client->number)\n\t\t\tcontinue;\n\t\tevent->dest.client = dest;\n\t\tevent->dest.port = addr.port;\n\t\tif (addr.port == SNDRV_SEQ_ADDRESS_BROADCAST)\n\t\t\terr = port_broadcast_event(client, event, atomic, hop);\n\t\telse\n\t\t\t/* pass NULL as source client to avoid error bounce */\n\t\t\terr = snd_seq_deliver_single_event(NULL, event,\n\t\t\t\t\t\t\t   SNDRV_SEQ_FILTER_BROADCAST,\n\t\t\t\t\t\t\t   atomic, hop);\n\t\tif (err < 0) {\n\t\t\t/* save first error that occurs and continue */\n\t\t\tif (!result)\n\t\t\t\tresult = err;\n\t\t\tcontinue;\n\t\t}\n\t\tnum_ev += err;\n\t}\n\tevent->dest = addr; /* restore */\n\treturn (result < 0) ? result : num_ev;\n}\n\n\n/* multicast - not supported yet */\nstatic int multicast_event(struct snd_seq_client *client, struct snd_seq_event *event,\n\t\t\t   int atomic, int hop)\n{\n\tpr_debug(\"ALSA: seq: multicast not supported yet.\\n\");\n\treturn 0; /* ignored */\n}\n#endif /* SUPPORT_BROADCAST */\n\n\n/* deliver an event to the destination port(s).\n * if the event is to subscribers or broadcast, the event is dispatched\n * to multiple targets.\n *\n * RETURN VALUE: n > 0  : the number of delivered events.\n *               n == 0 : the event was not passed to any client.\n *               n < 0  : error - event was not processed.\n */\nstatic int snd_seq_deliver_event(struct snd_seq_client *client, struct snd_seq_event *event,\n\t\t\t\t int atomic, int hop)\n{\n\tint result;\n\n\thop++;\n\tif (hop >= SNDRV_SEQ_MAX_HOPS) {\n\t\tpr_debug(\"ALSA: seq: too long delivery path (%d:%d->%d:%d)\\n\",\n\t\t\t   event->source.client, event->source.port,\n\t\t\t   event->dest.client, event->dest.port);\n\t\treturn -EMLINK;\n\t}\n\n\tif (event->queue == SNDRV_SEQ_ADDRESS_SUBSCRIBERS ||\n\t    event->dest.client == SNDRV_SEQ_ADDRESS_SUBSCRIBERS)\n\t\tresult = deliver_to_subscribers(client, event, atomic, hop);\n#ifdef SUPPORT_BROADCAST\n\telse if (event->queue == SNDRV_SEQ_ADDRESS_BROADCAST ||\n\t\t event->dest.client == SNDRV_SEQ_ADDRESS_BROADCAST)\n\t\tresult = broadcast_event(client, event, atomic, hop);\n\telse if (event->dest.client >= SNDRV_SEQ_MAX_CLIENTS)\n\t\tresult = multicast_event(client, event, atomic, hop);\n\telse if (event->dest.port == SNDRV_SEQ_ADDRESS_BROADCAST)\n\t\tresult = port_broadcast_event(client, event, atomic, hop);\n#endif\n\telse\n\t\tresult = snd_seq_deliver_single_event(client, event, 0, atomic, hop);\n\n\treturn result;\n}\n\n/*\n * dispatch an event cell:\n * This function is called only from queue check routines in timer\n * interrupts or after enqueued.\n * The event cell shall be released or re-queued in this function.\n *\n * RETURN VALUE: n > 0  : the number of delivered events.\n *\t\t n == 0 : the event was not passed to any client.\n *\t\t n < 0  : error - event was not processed.\n */\nint snd_seq_dispatch_event(struct snd_seq_event_cell *cell, int atomic, int hop)\n{\n\tstruct snd_seq_client *client;\n\tint result;\n\n\tif (snd_BUG_ON(!cell))\n\t\treturn -EINVAL;\n\n\tclient = snd_seq_client_use_ptr(cell->event.source.client);\n\tif (client == NULL) {\n\t\tsnd_seq_cell_free(cell); /* release this cell */\n\t\treturn -EINVAL;\n\t}\n\n\tif (cell->event.type == SNDRV_SEQ_EVENT_NOTE) {\n\t\t/* NOTE event:\n\t\t * the event cell is re-used as a NOTE-OFF event and\n\t\t * enqueued again.\n\t\t */\n\t\tstruct snd_seq_event tmpev, *ev;\n\n\t\t/* reserve this event to enqueue note-off later */\n\t\ttmpev = cell->event;\n\t\ttmpev.type = SNDRV_SEQ_EVENT_NOTEON;\n\t\tresult = snd_seq_deliver_event(client, &tmpev, atomic, hop);\n\n\t\t/*\n\t\t * This was originally a note event.  We now re-use the\n\t\t * cell for the note-off event.\n\t\t */\n\n\t\tev = &cell->event;\n\t\tev->type = SNDRV_SEQ_EVENT_NOTEOFF;\n\t\tev->flags |= SNDRV_SEQ_PRIORITY_HIGH;\n\n\t\t/* add the duration time */\n\t\tswitch (ev->flags & SNDRV_SEQ_TIME_STAMP_MASK) {\n\t\tcase SNDRV_SEQ_TIME_STAMP_TICK:\n\t\t\tev->time.tick += ev->data.note.duration;\n\t\t\tbreak;\n\t\tcase SNDRV_SEQ_TIME_STAMP_REAL:\n\t\t\t/* unit for duration is ms */\n\t\t\tev->time.time.tv_nsec += 1000000 * (ev->data.note.duration % 1000);\n\t\t\tev->time.time.tv_sec += ev->data.note.duration / 1000 +\n\t\t\t\t\t\tev->time.time.tv_nsec / 1000000000;\n\t\t\tev->time.time.tv_nsec %= 1000000000;\n\t\t\tbreak;\n\t\t}\n\t\tev->data.note.velocity = ev->data.note.off_velocity;\n\n\t\t/* Now queue this cell as the note off event */\n\t\tif (snd_seq_enqueue_event(cell, atomic, hop) < 0)\n\t\t\tsnd_seq_cell_free(cell); /* release this cell */\n\n\t} else {\n\t\t/* Normal events:\n\t\t * event cell is freed after processing the event\n\t\t */\n\n\t\tresult = snd_seq_deliver_event(client, &cell->event, atomic, hop);\n\t\tsnd_seq_cell_free(cell);\n\t}\n\n\tsnd_seq_client_unlock(client);\n\treturn result;\n}\n\n\n/* Allocate a cell from client pool and enqueue it to queue:\n * if pool is empty and blocking is TRUE, sleep until a new cell is\n * available.\n */\nstatic int snd_seq_client_enqueue_event(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\t\tstruct file *file, int blocking,\n\t\t\t\t\tint atomic, int hop)\n{\n\tstruct snd_seq_event_cell *cell;\n\tint err;\n\n\t/* special queue values - force direct passing */\n\tif (event->queue == SNDRV_SEQ_ADDRESS_SUBSCRIBERS) {\n\t\tevent->dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\t\tevent->queue = SNDRV_SEQ_QUEUE_DIRECT;\n\t} else\n#ifdef SUPPORT_BROADCAST\n\t\tif (event->queue == SNDRV_SEQ_ADDRESS_BROADCAST) {\n\t\t\tevent->dest.client = SNDRV_SEQ_ADDRESS_BROADCAST;\n\t\t\tevent->queue = SNDRV_SEQ_QUEUE_DIRECT;\n\t\t}\n#endif\n\tif (event->dest.client == SNDRV_SEQ_ADDRESS_SUBSCRIBERS) {\n\t\t/* check presence of source port */\n\t\tstruct snd_seq_client_port *src_port = snd_seq_port_use_ptr(client, event->source.port);\n\t\tif (src_port == NULL)\n\t\t\treturn -EINVAL;\n\t\tsnd_seq_port_unlock(src_port);\n\t}\n\n\t/* direct event processing without enqueued */\n\tif (snd_seq_ev_is_direct(event)) {\n\t\tif (event->type == SNDRV_SEQ_EVENT_NOTE)\n\t\t\treturn -EINVAL; /* this event must be enqueued! */\n\t\treturn snd_seq_deliver_event(client, event, atomic, hop);\n\t}\n\n\t/* Not direct, normal queuing */\n\tif (snd_seq_queue_is_used(event->queue, client->number) <= 0)\n\t\treturn -EINVAL;  /* invalid queue */\n\tif (! snd_seq_write_pool_allocated(client))\n\t\treturn -ENXIO; /* queue is not allocated */\n\n\t/* allocate an event cell */\n\terr = snd_seq_event_dup(client->pool, event, &cell, !blocking || atomic, file);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* we got a cell. enqueue it. */\n\tif ((err = snd_seq_enqueue_event(cell, atomic, hop)) < 0) {\n\t\tsnd_seq_cell_free(cell);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n\n/*\n * check validity of event type and data length.\n * return non-zero if invalid.\n */\nstatic int check_event_type_and_length(struct snd_seq_event *ev)\n{\n\tswitch (snd_seq_ev_length_type(ev)) {\n\tcase SNDRV_SEQ_EVENT_LENGTH_FIXED:\n\t\tif (snd_seq_ev_is_variable_type(ev))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_LENGTH_VARIABLE:\n\t\tif (! snd_seq_ev_is_variable_type(ev) ||\n\t\t    (ev->data.ext.len & ~SNDRV_SEQ_EXT_MASK) >= SNDRV_SEQ_MAX_EVENT_LEN)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_SEQ_EVENT_LENGTH_VARUSR:\n\t\tif (! snd_seq_ev_is_direct(ev))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\n/* handle write() */\n/* possible error values:\n *\t-ENXIO\tinvalid client or file open mode\n *\t-ENOMEM\tmalloc failed\n *\t-EFAULT\tseg. fault during copy from user space\n *\t-EINVAL\tinvalid event\n *\t-EAGAIN\tno space in output pool\n *\t-EINTR\tinterrupts while sleep\n *\t-EMLINK\ttoo many hops\n *\tothers\tdepends on return value from driver callback\n */\nstatic ssize_t snd_seq_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *offset)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tint written = 0, len;\n\tint err = -EINVAL;\n\tstruct snd_seq_event event;\n\n\tif (!(snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_OUTPUT))\n\t\treturn -ENXIO;\n\n\t/* check client structures are in place */\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\t\t\n\tif (!client->accept_output || client->pool == NULL)\n\t\treturn -ENXIO;\n\n\t/* allocate the pool now if the pool is not allocated yet */ \n\tif (client->pool->size > 0 && !snd_seq_write_pool_allocated(client)) {\n\t\tif (snd_seq_pool_init(client->pool) < 0)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* only process whole events */\n\twhile (count >= sizeof(struct snd_seq_event)) {\n\t\t/* Read in the event header from the user */\n\t\tlen = sizeof(event);\n\t\tif (copy_from_user(&event, buf, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tevent.source.client = client->number;\t/* fill in client number */\n\t\t/* Check for extension data length */\n\t\tif (check_event_type_and_length(&event)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check for special events */\n\t\tif (event.type == SNDRV_SEQ_EVENT_NONE)\n\t\t\tgoto __skip_event;\n\t\telse if (snd_seq_ev_is_reserved(&event)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (snd_seq_ev_is_variable(&event)) {\n\t\t\tint extlen = event.data.ext.len & ~SNDRV_SEQ_EXT_MASK;\n\t\t\tif ((size_t)(extlen + len) > count) {\n\t\t\t\t/* back out, will get an error this time or next */\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* set user space pointer */\n\t\t\tevent.data.ext.len = extlen | SNDRV_SEQ_EXT_USRPTR;\n\t\t\tevent.data.ext.ptr = (char __force *)buf\n\t\t\t\t\t\t+ sizeof(struct snd_seq_event);\n\t\t\tlen += extlen; /* increment data length */\n\t\t} else {\n#ifdef CONFIG_COMPAT\n\t\t\tif (client->convert32 && snd_seq_ev_is_varusr(&event)) {\n\t\t\t\tvoid *ptr = (void __force *)compat_ptr(event.data.raw32.d[1]);\n\t\t\t\tevent.data.ext.ptr = ptr;\n\t\t\t}\n#endif\n\t\t}\n\n\t\t/* ok, enqueue it */\n\t\terr = snd_seq_client_enqueue_event(client, &event, file,\n\t\t\t\t\t\t   !(file->f_flags & O_NONBLOCK),\n\t\t\t\t\t\t   0, 0);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t__skip_event:\n\t\t/* Update pointers and counts */\n\t\tcount -= len;\n\t\tbuf += len;\n\t\twritten += len;\n\t}\n\n\treturn written ? written : err;\n}\n\n\n/*\n * handle polling\n */\nstatic unsigned int snd_seq_poll(struct file *file, poll_table * wait)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tunsigned int mask = 0;\n\n\t/* check client structures are in place */\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\n\tif ((snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_INPUT) &&\n\t    client->data.user.fifo) {\n\n\t\t/* check if data is available in the outqueue */\n\t\tif (snd_seq_fifo_poll_wait(client->data.user.fifo, file, wait))\n\t\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\n\tif (snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_OUTPUT) {\n\n\t\t/* check if data is available in the pool */\n\t\tif (!snd_seq_write_pool_allocated(client) ||\n\t\t    snd_seq_pool_poll_wait(client->pool, file, wait))\n\t\t\tmask |= POLLOUT | POLLWRNORM;\n\t}\n\n\treturn mask;\n}\n\n\n/*-----------------------------------------------------*/\n\nstatic int snd_seq_ioctl_pversion(struct snd_seq_client *client, void *arg)\n{\n\tint *pversion = arg;\n\n\t*pversion = SNDRV_SEQ_VERSION;\n\treturn 0;\n}\n\nstatic int snd_seq_ioctl_client_id(struct snd_seq_client *client, void *arg)\n{\n\tint *client_id = arg;\n\n\t*client_id = client->number;\n\treturn 0;\n}\n\n/* SYSTEM_INFO ioctl() */\nstatic int snd_seq_ioctl_system_info(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_system_info *info = arg;\n\n\tmemset(info, 0, sizeof(*info));\n\t/* fill the info fields */\n\tinfo->queues = SNDRV_SEQ_MAX_QUEUES;\n\tinfo->clients = SNDRV_SEQ_MAX_CLIENTS;\n\tinfo->ports = SNDRV_SEQ_MAX_PORTS;\n\tinfo->channels = 256;\t/* fixed limit */\n\tinfo->cur_clients = client_usage.cur;\n\tinfo->cur_queues = snd_seq_queue_get_cur_queues();\n\n\treturn 0;\n}\n\n\n/* RUNNING_MODE ioctl() */\nstatic int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)\n{\n\tstruct snd_seq_running_info *info = arg;\n\tstruct snd_seq_client *cptr;\n\tint err = 0;\n\n\t/* requested client number */\n\tcptr = snd_seq_client_use_ptr(info->client);\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\t\t/* don't change !!! */\n\n#ifdef SNDRV_BIG_ENDIAN\n\tif (!info->big_endian) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n#else\n\tif (info->big_endian) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n\n#endif\n\tif (info->cpu_mode > sizeof(long)) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n\tcptr->convert32 = (info->cpu_mode < sizeof(long));\n __err:\n\tsnd_seq_client_unlock(cptr);\n\treturn err;\n}\n\n/* CLIENT_INFO ioctl() */\nstatic void get_client_info(struct snd_seq_client *cptr,\n\t\t\t    struct snd_seq_client_info *info)\n{\n\tinfo->client = cptr->number;\n\n\t/* fill the info fields */\n\tinfo->type = cptr->type;\n\tstrcpy(info->name, cptr->name);\n\tinfo->filter = cptr->filter;\n\tinfo->event_lost = cptr->event_lost;\n\tmemcpy(info->event_filter, cptr->event_filter, 32);\n\tinfo->num_ports = cptr->num_ports;\n\n\tif (cptr->type == USER_CLIENT)\n\t\tinfo->pid = pid_vnr(cptr->data.user.owner);\n\telse\n\t\tinfo->pid = -1;\n\n\tif (cptr->type == KERNEL_CLIENT)\n\t\tinfo->card = cptr->data.kernel.card ? cptr->data.kernel.card->number : -1;\n\telse\n\t\tinfo->card = -1;\n\n\tmemset(info->reserved, 0, sizeof(info->reserved));\n}\n\nstatic int snd_seq_ioctl_get_client_info(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_client_info *client_info = arg;\n\tstruct snd_seq_client *cptr;\n\n\t/* requested client number */\n\tcptr = snd_seq_client_use_ptr(client_info->client);\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\t\t/* don't change !!! */\n\n\tget_client_info(cptr, client_info);\n\tsnd_seq_client_unlock(cptr);\n\n\treturn 0;\n}\n\n\n/* CLIENT_INFO ioctl() */\nstatic int snd_seq_ioctl_set_client_info(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_client_info *client_info = arg;\n\n\t/* it is not allowed to set the info fields for an another client */\n\tif (client->number != client_info->client)\n\t\treturn -EPERM;\n\t/* also client type must be set now */\n\tif (client->type != client_info->type)\n\t\treturn -EINVAL;\n\n\t/* fill the info fields */\n\tif (client_info->name[0])\n\t\tstrlcpy(client->name, client_info->name, sizeof(client->name));\n\n\tclient->filter = client_info->filter;\n\tclient->event_lost = client_info->event_lost;\n\tmemcpy(client->event_filter, client_info->event_filter, 32);\n\n\treturn 0;\n}\n\n\n/* \n * CREATE PORT ioctl() \n */\nstatic int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\tint port_idx;\n\n\t/* it is not allowed to create the port for an another client */\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\n\tif (client->type == USER_CLIENT && info->kernel) {\n\t\tport_idx = port->addr.port;\n\t\tsnd_seq_port_unlock(port);\n\t\tsnd_seq_delete_port(client, port_idx);\n\t\treturn -EINVAL;\n\t}\n\tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\n\tinfo->addr = port->addr;\n\n\tsnd_seq_set_port_info(port, info);\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\tsnd_seq_port_unlock(port);\n\n\treturn 0;\n}\n\n/* \n * DELETE PORT ioctl() \n */\nstatic int snd_seq_ioctl_delete_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tint err;\n\n\t/* it is not allowed to remove the port for an another client */\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\n\terr = snd_seq_delete_port(client, info->addr.port);\n\tif (err >= 0)\n\t\tsnd_seq_system_client_ev_port_exit(client->number, info->addr.port);\n\treturn err;\n}\n\n\n/* \n * GET_PORT_INFO ioctl() (on any client) \n */\nstatic int snd_seq_ioctl_get_port_info(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client *cptr;\n\tstruct snd_seq_client_port *port;\n\n\tcptr = snd_seq_client_use_ptr(info->addr.client);\n\tif (cptr == NULL)\n\t\treturn -ENXIO;\n\n\tport = snd_seq_port_use_ptr(cptr, info->addr.port);\n\tif (port == NULL) {\n\t\tsnd_seq_client_unlock(cptr);\n\t\treturn -ENOENT;\t\t\t/* don't change */\n\t}\n\n\t/* get port info */\n\tsnd_seq_get_port_info(port, info);\n\tsnd_seq_port_unlock(port);\n\tsnd_seq_client_unlock(cptr);\n\n\treturn 0;\n}\n\n\n/* \n * SET_PORT_INFO ioctl() (only ports on this/own client) \n */\nstatic int snd_seq_ioctl_set_port_info(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\n\tif (info->addr.client != client->number) /* only set our own ports ! */\n\t\treturn -EPERM;\n\tport = snd_seq_port_use_ptr(client, info->addr.port);\n\tif (port) {\n\t\tsnd_seq_set_port_info(port, info);\n\t\tsnd_seq_port_unlock(port);\n\t}\n\treturn 0;\n}\n\n\n/*\n * port subscription (connection)\n */\n#define PERM_RD\t\t(SNDRV_SEQ_PORT_CAP_READ|SNDRV_SEQ_PORT_CAP_SUBS_READ)\n#define PERM_WR\t\t(SNDRV_SEQ_PORT_CAP_WRITE|SNDRV_SEQ_PORT_CAP_SUBS_WRITE)\n\nstatic int check_subscription_permission(struct snd_seq_client *client,\n\t\t\t\t\t struct snd_seq_client_port *sport,\n\t\t\t\t\t struct snd_seq_client_port *dport,\n\t\t\t\t\t struct snd_seq_port_subscribe *subs)\n{\n\tif (client->number != subs->sender.client &&\n\t    client->number != subs->dest.client) {\n\t\t/* connection by third client - check export permission */\n\t\tif (check_port_perm(sport, SNDRV_SEQ_PORT_CAP_NO_EXPORT))\n\t\t\treturn -EPERM;\n\t\tif (check_port_perm(dport, SNDRV_SEQ_PORT_CAP_NO_EXPORT))\n\t\t\treturn -EPERM;\n\t}\n\n\t/* check read permission */\n\t/* if sender or receiver is the subscribing client itself,\n\t * no permission check is necessary\n\t */\n\tif (client->number != subs->sender.client) {\n\t\tif (! check_port_perm(sport, PERM_RD))\n\t\t\treturn -EPERM;\n\t}\n\t/* check write permission */\n\tif (client->number != subs->dest.client) {\n\t\tif (! check_port_perm(dport, PERM_WR))\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\n/*\n * send an subscription notify event to user client:\n * client must be user client.\n */\nint snd_seq_client_notify_subscription(int client, int port,\n\t\t\t\t       struct snd_seq_port_subscribe *info,\n\t\t\t\t       int evtype)\n{\n\tstruct snd_seq_event event;\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.type = evtype;\n\tevent.data.connect.dest = info->dest;\n\tevent.data.connect.sender = info->sender;\n\n\treturn snd_seq_system_notify(client, port, &event);  /* non-atomic */\n}\n\n\n/* \n * add to port's subscription list IOCTL interface \n */\nstatic int snd_seq_ioctl_subscribe_port(struct snd_seq_client *client,\n\t\t\t\t\tvoid *arg)\n{\n\tstruct snd_seq_port_subscribe *subs = arg;\n\tint result = -EINVAL;\n\tstruct snd_seq_client *receiver = NULL, *sender = NULL;\n\tstruct snd_seq_client_port *sport = NULL, *dport = NULL;\n\n\tif ((receiver = snd_seq_client_use_ptr(subs->dest.client)) == NULL)\n\t\tgoto __end;\n\tif ((sender = snd_seq_client_use_ptr(subs->sender.client)) == NULL)\n\t\tgoto __end;\n\tif ((sport = snd_seq_port_use_ptr(sender, subs->sender.port)) == NULL)\n\t\tgoto __end;\n\tif ((dport = snd_seq_port_use_ptr(receiver, subs->dest.port)) == NULL)\n\t\tgoto __end;\n\n\tresult = check_subscription_permission(client, sport, dport, subs);\n\tif (result < 0)\n\t\tgoto __end;\n\n\t/* connect them */\n\tresult = snd_seq_port_connect(client, sender, sport, receiver, dport, subs);\n\tif (! result) /* broadcast announce */\n\t\tsnd_seq_client_notify_subscription(SNDRV_SEQ_ADDRESS_SUBSCRIBERS, 0,\n\t\t\t\t\t\t   subs, SNDRV_SEQ_EVENT_PORT_SUBSCRIBED);\n      __end:\n      \tif (sport)\n\t\tsnd_seq_port_unlock(sport);\n\tif (dport)\n\t\tsnd_seq_port_unlock(dport);\n\tif (sender)\n\t\tsnd_seq_client_unlock(sender);\n\tif (receiver)\n\t\tsnd_seq_client_unlock(receiver);\n\treturn result;\n}\n\n\n/* \n * remove from port's subscription list \n */\nstatic int snd_seq_ioctl_unsubscribe_port(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_port_subscribe *subs = arg;\n\tint result = -ENXIO;\n\tstruct snd_seq_client *receiver = NULL, *sender = NULL;\n\tstruct snd_seq_client_port *sport = NULL, *dport = NULL;\n\n\tif ((receiver = snd_seq_client_use_ptr(subs->dest.client)) == NULL)\n\t\tgoto __end;\n\tif ((sender = snd_seq_client_use_ptr(subs->sender.client)) == NULL)\n\t\tgoto __end;\n\tif ((sport = snd_seq_port_use_ptr(sender, subs->sender.port)) == NULL)\n\t\tgoto __end;\n\tif ((dport = snd_seq_port_use_ptr(receiver, subs->dest.port)) == NULL)\n\t\tgoto __end;\n\n\tresult = check_subscription_permission(client, sport, dport, subs);\n\tif (result < 0)\n\t\tgoto __end;\n\n\tresult = snd_seq_port_disconnect(client, sender, sport, receiver, dport, subs);\n\tif (! result) /* broadcast announce */\n\t\tsnd_seq_client_notify_subscription(SNDRV_SEQ_ADDRESS_SUBSCRIBERS, 0,\n\t\t\t\t\t\t   subs, SNDRV_SEQ_EVENT_PORT_UNSUBSCRIBED);\n      __end:\n      \tif (sport)\n\t\tsnd_seq_port_unlock(sport);\n\tif (dport)\n\t\tsnd_seq_port_unlock(dport);\n\tif (sender)\n\t\tsnd_seq_client_unlock(sender);\n\tif (receiver)\n\t\tsnd_seq_client_unlock(receiver);\n\treturn result;\n}\n\n\n/* CREATE_QUEUE ioctl() */\nstatic int snd_seq_ioctl_create_queue(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\tstruct snd_seq_queue *q;\n\n\tq = snd_seq_queue_alloc(client->number, info->locked, info->flags);\n\tif (IS_ERR(q))\n\t\treturn PTR_ERR(q);\n\n\tinfo->queue = q->queue;\n\tinfo->locked = q->locked;\n\tinfo->owner = q->owner;\n\n\t/* set queue name */\n\tif (!info->name[0])\n\t\tsnprintf(info->name, sizeof(info->name), \"Queue-%d\", q->queue);\n\tstrlcpy(q->name, info->name, sizeof(q->name));\n\tsnd_use_lock_free(&q->use_lock);\n\n\treturn 0;\n}\n\n/* DELETE_QUEUE ioctl() */\nstatic int snd_seq_ioctl_delete_queue(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\n\treturn snd_seq_queue_delete(client->number, info->queue);\n}\n\n/* GET_QUEUE_INFO ioctl() */\nstatic int snd_seq_ioctl_get_queue_info(struct snd_seq_client *client,\n\t\t\t\t\tvoid *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\tstruct snd_seq_queue *q;\n\n\tq = queueptr(info->queue);\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->queue = q->queue;\n\tinfo->owner = q->owner;\n\tinfo->locked = q->locked;\n\tstrlcpy(info->name, q->name, sizeof(info->name));\n\tqueuefree(q);\n\n\treturn 0;\n}\n\n/* SET_QUEUE_INFO ioctl() */\nstatic int snd_seq_ioctl_set_queue_info(struct snd_seq_client *client,\n\t\t\t\t\tvoid *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\tstruct snd_seq_queue *q;\n\n\tif (info->owner != client->number)\n\t\treturn -EINVAL;\n\n\t/* change owner/locked permission */\n\tif (snd_seq_queue_check_access(info->queue, client->number)) {\n\t\tif (snd_seq_queue_set_owner(info->queue, client->number, info->locked) < 0)\n\t\t\treturn -EPERM;\n\t\tif (info->locked)\n\t\t\tsnd_seq_queue_use(info->queue, client->number, 1);\n\t} else {\n\t\treturn -EPERM;\n\t}\t\n\n\tq = queueptr(info->queue);\n\tif (! q)\n\t\treturn -EINVAL;\n\tif (q->owner != client->number) {\n\t\tqueuefree(q);\n\t\treturn -EPERM;\n\t}\n\tstrlcpy(q->name, info->name, sizeof(q->name));\n\tqueuefree(q);\n\n\treturn 0;\n}\n\n/* GET_NAMED_QUEUE ioctl() */\nstatic int snd_seq_ioctl_get_named_queue(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_info *info = arg;\n\tstruct snd_seq_queue *q;\n\n\tq = snd_seq_queue_find_name(info->name);\n\tif (q == NULL)\n\t\treturn -EINVAL;\n\tinfo->queue = q->queue;\n\tinfo->owner = q->owner;\n\tinfo->locked = q->locked;\n\tqueuefree(q);\n\n\treturn 0;\n}\n\n/* GET_QUEUE_STATUS ioctl() */\nstatic int snd_seq_ioctl_get_queue_status(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_queue_status *status = arg;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tqueue = queueptr(status->queue);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\tmemset(status, 0, sizeof(*status));\n\tstatus->queue = queue->queue;\n\t\n\ttmr = queue->timer;\n\tstatus->events = queue->tickq->cells + queue->timeq->cells;\n\n\tstatus->time = snd_seq_timer_get_cur_time(tmr);\n\tstatus->tick = snd_seq_timer_get_cur_tick(tmr);\n\n\tstatus->running = tmr->running;\n\n\tstatus->flags = queue->flags;\n\tqueuefree(queue);\n\n\treturn 0;\n}\n\n\n/* GET_QUEUE_TEMPO ioctl() */\nstatic int snd_seq_ioctl_get_queue_tempo(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_tempo *tempo = arg;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tqueue = queueptr(tempo->queue);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\tmemset(tempo, 0, sizeof(*tempo));\n\ttempo->queue = queue->queue;\n\t\n\ttmr = queue->timer;\n\n\ttempo->tempo = tmr->tempo;\n\ttempo->ppq = tmr->ppq;\n\ttempo->skew_value = tmr->skew;\n\ttempo->skew_base = tmr->skew_base;\n\tqueuefree(queue);\n\n\treturn 0;\n}\n\n\n/* SET_QUEUE_TEMPO ioctl() */\nint snd_seq_set_queue_tempo(int client, struct snd_seq_queue_tempo *tempo)\n{\n\tif (!snd_seq_queue_check_access(tempo->queue, client))\n\t\treturn -EPERM;\n\treturn snd_seq_queue_timer_set_tempo(tempo->queue, client, tempo);\n}\nEXPORT_SYMBOL(snd_seq_set_queue_tempo);\n\nstatic int snd_seq_ioctl_set_queue_tempo(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_tempo *tempo = arg;\n\tint result;\n\n\tresult = snd_seq_set_queue_tempo(client->number, tempo);\n\treturn result < 0 ? result : 0;\n}\n\n\n/* GET_QUEUE_TIMER ioctl() */\nstatic int snd_seq_ioctl_get_queue_timer(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_timer *timer = arg;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tqueue = queueptr(timer->queue);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&queue->timer_mutex)) {\n\t\tqueuefree(queue);\n\t\treturn -ERESTARTSYS;\n\t}\n\ttmr = queue->timer;\n\tmemset(timer, 0, sizeof(*timer));\n\ttimer->queue = queue->queue;\n\n\ttimer->type = tmr->type;\n\tif (tmr->type == SNDRV_SEQ_TIMER_ALSA) {\n\t\ttimer->u.alsa.id = tmr->alsa_id;\n\t\ttimer->u.alsa.resolution = tmr->preferred_resolution;\n\t}\n\tmutex_unlock(&queue->timer_mutex);\n\tqueuefree(queue);\n\t\n\treturn 0;\n}\n\n\n/* SET_QUEUE_TIMER ioctl() */\nstatic int snd_seq_ioctl_set_queue_timer(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_timer *timer = arg;\n\tint result = 0;\n\n\tif (timer->type != SNDRV_SEQ_TIMER_ALSA)\n\t\treturn -EINVAL;\n\n\tif (snd_seq_queue_check_access(timer->queue, client->number)) {\n\t\tstruct snd_seq_queue *q;\n\t\tstruct snd_seq_timer *tmr;\n\n\t\tq = queueptr(timer->queue);\n\t\tif (q == NULL)\n\t\t\treturn -ENXIO;\n\t\tif (mutex_lock_interruptible(&q->timer_mutex)) {\n\t\t\tqueuefree(q);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\ttmr = q->timer;\n\t\tsnd_seq_queue_timer_close(timer->queue);\n\t\ttmr->type = timer->type;\n\t\tif (tmr->type == SNDRV_SEQ_TIMER_ALSA) {\n\t\t\ttmr->alsa_id = timer->u.alsa.id;\n\t\t\ttmr->preferred_resolution = timer->u.alsa.resolution;\n\t\t}\n\t\tresult = snd_seq_queue_timer_open(timer->queue);\n\t\tmutex_unlock(&q->timer_mutex);\n\t\tqueuefree(q);\n\t} else {\n\t\treturn -EPERM;\n\t}\t\n\n\treturn result;\n}\n\n\n/* GET_QUEUE_CLIENT ioctl() */\nstatic int snd_seq_ioctl_get_queue_client(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_queue_client *info = arg;\n\tint used;\n\n\tused = snd_seq_queue_is_used(info->queue, client->number);\n\tif (used < 0)\n\t\treturn -EINVAL;\n\tinfo->used = used;\n\tinfo->client = client->number;\n\n\treturn 0;\n}\n\n\n/* SET_QUEUE_CLIENT ioctl() */\nstatic int snd_seq_ioctl_set_queue_client(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_queue_client *info = arg;\n\tint err;\n\n\tif (info->used >= 0) {\n\t\terr = snd_seq_queue_use(info->queue, client->number, info->used);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn snd_seq_ioctl_get_queue_client(client, arg);\n}\n\n\n/* GET_CLIENT_POOL ioctl() */\nstatic int snd_seq_ioctl_get_client_pool(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_client_pool *info = arg;\n\tstruct snd_seq_client *cptr;\n\n\tcptr = snd_seq_client_use_ptr(info->client);\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\n\tmemset(info, 0, sizeof(*info));\n\tinfo->client = cptr->number;\n\tinfo->output_pool = cptr->pool->size;\n\tinfo->output_room = cptr->pool->room;\n\tinfo->output_free = info->output_pool;\n\tinfo->output_free = snd_seq_unused_cells(cptr->pool);\n\tif (cptr->type == USER_CLIENT) {\n\t\tinfo->input_pool = cptr->data.user.fifo_pool_size;\n\t\tinfo->input_free = info->input_pool;\n\t\tif (cptr->data.user.fifo)\n\t\t\tinfo->input_free = snd_seq_unused_cells(cptr->data.user.fifo->pool);\n\t} else {\n\t\tinfo->input_pool = 0;\n\t\tinfo->input_free = 0;\n\t}\n\tsnd_seq_client_unlock(cptr);\n\t\n\treturn 0;\n}\n\n/* SET_CLIENT_POOL ioctl() */\nstatic int snd_seq_ioctl_set_client_pool(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_client_pool *info = arg;\n\tint rc;\n\n\tif (client->number != info->client)\n\t\treturn -EINVAL; /* can't change other clients */\n\n\tif (info->output_pool >= 1 && info->output_pool <= SNDRV_SEQ_MAX_EVENTS &&\n\t    (! snd_seq_write_pool_allocated(client) ||\n\t     info->output_pool != client->pool->size)) {\n\t\tif (snd_seq_write_pool_allocated(client)) {\n\t\t\t/* remove all existing cells */\n\t\t\tsnd_seq_pool_mark_closing(client->pool);\n\t\t\tsnd_seq_queue_client_leave_cells(client->number);\n\t\t\tsnd_seq_pool_done(client->pool);\n\t\t}\n\t\tclient->pool->size = info->output_pool;\n\t\trc = snd_seq_pool_init(client->pool);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\tif (client->type == USER_CLIENT && client->data.user.fifo != NULL &&\n\t    info->input_pool >= 1 &&\n\t    info->input_pool <= SNDRV_SEQ_MAX_CLIENT_EVENTS &&\n\t    info->input_pool != client->data.user.fifo_pool_size) {\n\t\t/* change pool size */\n\t\trc = snd_seq_fifo_resize(client->data.user.fifo, info->input_pool);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tclient->data.user.fifo_pool_size = info->input_pool;\n\t}\n\tif (info->output_room >= 1 &&\n\t    info->output_room <= client->pool->size) {\n\t\tclient->pool->room  = info->output_room;\n\t}\n\n\treturn snd_seq_ioctl_get_client_pool(client, arg);\n}\n\n\n/* REMOVE_EVENTS ioctl() */\nstatic int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void *arg)\n{\n\tstruct snd_seq_remove_events *info = arg;\n\n\t/*\n\t * Input mostly not implemented XXX.\n\t */\n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\t/*\n\t\t * No restrictions so for a user client we can clear\n\t\t * the whole fifo\n\t\t */\n\t\tif (client->type == USER_CLIENT && client->data.user.fifo)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\n\tif (info->remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, info);\n\n\treturn 0;\n}\n\n\n/*\n * get subscription info\n */\nstatic int snd_seq_ioctl_get_subscription(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_port_subscribe *subs = arg;\n\tint result;\n\tstruct snd_seq_client *sender = NULL;\n\tstruct snd_seq_client_port *sport = NULL;\n\tstruct snd_seq_subscribers *p;\n\n\tresult = -EINVAL;\n\tif ((sender = snd_seq_client_use_ptr(subs->sender.client)) == NULL)\n\t\tgoto __end;\n\tif ((sport = snd_seq_port_use_ptr(sender, subs->sender.port)) == NULL)\n\t\tgoto __end;\n\tp = snd_seq_port_get_subscription(&sport->c_src, &subs->dest);\n\tif (p) {\n\t\tresult = 0;\n\t\t*subs = p->info;\n\t} else\n\t\tresult = -ENOENT;\n\n      __end:\n      \tif (sport)\n\t\tsnd_seq_port_unlock(sport);\n\tif (sender)\n\t\tsnd_seq_client_unlock(sender);\n\n\treturn result;\n}\n\n\n/*\n * get subscription info - check only its presence\n */\nstatic int snd_seq_ioctl_query_subs(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_query_subs *subs = arg;\n\tint result = -ENXIO;\n\tstruct snd_seq_client *cptr = NULL;\n\tstruct snd_seq_client_port *port = NULL;\n\tstruct snd_seq_port_subs_info *group;\n\tstruct list_head *p;\n\tint i;\n\n\tif ((cptr = snd_seq_client_use_ptr(subs->root.client)) == NULL)\n\t\tgoto __end;\n\tif ((port = snd_seq_port_use_ptr(cptr, subs->root.port)) == NULL)\n\t\tgoto __end;\n\n\tswitch (subs->type) {\n\tcase SNDRV_SEQ_QUERY_SUBS_READ:\n\t\tgroup = &port->c_src;\n\t\tbreak;\n\tcase SNDRV_SEQ_QUERY_SUBS_WRITE:\n\t\tgroup = &port->c_dest;\n\t\tbreak;\n\tdefault:\n\t\tgoto __end;\n\t}\n\n\tdown_read(&group->list_mutex);\n\t/* search for the subscriber */\n\tsubs->num_subs = group->count;\n\ti = 0;\n\tresult = -ENOENT;\n\tlist_for_each(p, &group->list_head) {\n\t\tif (i++ == subs->index) {\n\t\t\t/* found! */\n\t\t\tstruct snd_seq_subscribers *s;\n\t\t\tif (subs->type == SNDRV_SEQ_QUERY_SUBS_READ) {\n\t\t\t\ts = list_entry(p, struct snd_seq_subscribers, src_list);\n\t\t\t\tsubs->addr = s->info.dest;\n\t\t\t} else {\n\t\t\t\ts = list_entry(p, struct snd_seq_subscribers, dest_list);\n\t\t\t\tsubs->addr = s->info.sender;\n\t\t\t}\n\t\t\tsubs->flags = s->info.flags;\n\t\t\tsubs->queue = s->info.queue;\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&group->list_mutex);\n\n      __end:\n   \tif (port)\n\t\tsnd_seq_port_unlock(port);\n\tif (cptr)\n\t\tsnd_seq_client_unlock(cptr);\n\n\treturn result;\n}\n\n\n/*\n * query next client\n */\nstatic int snd_seq_ioctl_query_next_client(struct snd_seq_client *client,\n\t\t\t\t\t   void *arg)\n{\n\tstruct snd_seq_client_info *info = arg;\n\tstruct snd_seq_client *cptr = NULL;\n\n\t/* search for next client */\n\tinfo->client++;\n\tif (info->client < 0)\n\t\tinfo->client = 0;\n\tfor (; info->client < SNDRV_SEQ_MAX_CLIENTS; info->client++) {\n\t\tcptr = snd_seq_client_use_ptr(info->client);\n\t\tif (cptr)\n\t\t\tbreak; /* found */\n\t}\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\n\n\tget_client_info(cptr, info);\n\tsnd_seq_client_unlock(cptr);\n\n\treturn 0;\n}\n\n/* \n * query next port\n */\nstatic int snd_seq_ioctl_query_next_port(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client *cptr;\n\tstruct snd_seq_client_port *port = NULL;\n\n\tcptr = snd_seq_client_use_ptr(info->addr.client);\n\tif (cptr == NULL)\n\t\treturn -ENXIO;\n\n\t/* search for next port */\n\tinfo->addr.port++;\n\tport = snd_seq_port_query_nearest(cptr, info);\n\tif (port == NULL) {\n\t\tsnd_seq_client_unlock(cptr);\n\t\treturn -ENOENT;\n\t}\n\n\t/* get port info */\n\tinfo->addr = port->addr;\n\tsnd_seq_get_port_info(port, info);\n\tsnd_seq_port_unlock(port);\n\tsnd_seq_client_unlock(cptr);\n\n\treturn 0;\n}\n\n/* -------------------------------------------------------- */\n\nstatic const struct ioctl_handler {\n\tunsigned int cmd;\n\tint (*func)(struct snd_seq_client *client, void *arg);\n} ioctl_handlers[] = {\n\t{ SNDRV_SEQ_IOCTL_PVERSION, snd_seq_ioctl_pversion },\n\t{ SNDRV_SEQ_IOCTL_CLIENT_ID, snd_seq_ioctl_client_id },\n\t{ SNDRV_SEQ_IOCTL_SYSTEM_INFO, snd_seq_ioctl_system_info },\n\t{ SNDRV_SEQ_IOCTL_RUNNING_MODE, snd_seq_ioctl_running_mode },\n\t{ SNDRV_SEQ_IOCTL_GET_CLIENT_INFO, snd_seq_ioctl_get_client_info },\n\t{ SNDRV_SEQ_IOCTL_SET_CLIENT_INFO, snd_seq_ioctl_set_client_info },\n\t{ SNDRV_SEQ_IOCTL_CREATE_PORT, snd_seq_ioctl_create_port },\n\t{ SNDRV_SEQ_IOCTL_DELETE_PORT, snd_seq_ioctl_delete_port },\n\t{ SNDRV_SEQ_IOCTL_GET_PORT_INFO, snd_seq_ioctl_get_port_info },\n\t{ SNDRV_SEQ_IOCTL_SET_PORT_INFO, snd_seq_ioctl_set_port_info },\n\t{ SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT, snd_seq_ioctl_subscribe_port },\n\t{ SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT, snd_seq_ioctl_unsubscribe_port },\n\t{ SNDRV_SEQ_IOCTL_CREATE_QUEUE, snd_seq_ioctl_create_queue },\n\t{ SNDRV_SEQ_IOCTL_DELETE_QUEUE, snd_seq_ioctl_delete_queue },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_INFO, snd_seq_ioctl_get_queue_info },\n\t{ SNDRV_SEQ_IOCTL_SET_QUEUE_INFO, snd_seq_ioctl_set_queue_info },\n\t{ SNDRV_SEQ_IOCTL_GET_NAMED_QUEUE, snd_seq_ioctl_get_named_queue },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_STATUS, snd_seq_ioctl_get_queue_status },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_TEMPO, snd_seq_ioctl_get_queue_tempo },\n\t{ SNDRV_SEQ_IOCTL_SET_QUEUE_TEMPO, snd_seq_ioctl_set_queue_tempo },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_TIMER, snd_seq_ioctl_get_queue_timer },\n\t{ SNDRV_SEQ_IOCTL_SET_QUEUE_TIMER, snd_seq_ioctl_set_queue_timer },\n\t{ SNDRV_SEQ_IOCTL_GET_QUEUE_CLIENT, snd_seq_ioctl_get_queue_client },\n\t{ SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT, snd_seq_ioctl_set_queue_client },\n\t{ SNDRV_SEQ_IOCTL_GET_CLIENT_POOL, snd_seq_ioctl_get_client_pool },\n\t{ SNDRV_SEQ_IOCTL_SET_CLIENT_POOL, snd_seq_ioctl_set_client_pool },\n\t{ SNDRV_SEQ_IOCTL_GET_SUBSCRIPTION, snd_seq_ioctl_get_subscription },\n\t{ SNDRV_SEQ_IOCTL_QUERY_NEXT_CLIENT, snd_seq_ioctl_query_next_client },\n\t{ SNDRV_SEQ_IOCTL_QUERY_NEXT_PORT, snd_seq_ioctl_query_next_port },\n\t{ SNDRV_SEQ_IOCTL_REMOVE_EVENTS, snd_seq_ioctl_remove_events },\n\t{ SNDRV_SEQ_IOCTL_QUERY_SUBS, snd_seq_ioctl_query_subs },\n\t{ 0, NULL },\n};\n\nstatic long snd_seq_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\t/* To use kernel stack for ioctl data. */\n\tunion {\n\t\tint pversion;\n\t\tint client_id;\n\t\tstruct snd_seq_system_info\tsystem_info;\n\t\tstruct snd_seq_running_info\trunning_info;\n\t\tstruct snd_seq_client_info\tclient_info;\n\t\tstruct snd_seq_port_info\tport_info;\n\t\tstruct snd_seq_port_subscribe\tport_subscribe;\n\t\tstruct snd_seq_queue_info\tqueue_info;\n\t\tstruct snd_seq_queue_status\tqueue_status;\n\t\tstruct snd_seq_queue_tempo\ttempo;\n\t\tstruct snd_seq_queue_timer\tqueue_timer;\n\t\tstruct snd_seq_queue_client\tqueue_client;\n\t\tstruct snd_seq_client_pool\tclient_pool;\n\t\tstruct snd_seq_remove_events\tremove_events;\n\t\tstruct snd_seq_query_subs\tquery_subs;\n\t} buf;\n\tconst struct ioctl_handler *handler;\n\tunsigned long size;\n\tint err;\n\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\n\tfor (handler = ioctl_handlers; handler->cmd > 0; ++handler) {\n\t\tif (handler->cmd == cmd)\n\t\t\tbreak;\n\t}\n\tif (handler->cmd == 0)\n\t\treturn -ENOTTY;\n\n\tmemset(&buf, 0, sizeof(buf));\n\n\t/*\n\t * All of ioctl commands for ALSA sequencer get an argument of size\n\t * within 13 bits. We can safely pick up the size from the command.\n\t */\n\tsize = _IOC_SIZE(handler->cmd);\n\tif (handler->cmd & IOC_IN) {\n\t\tif (copy_from_user(&buf, (const void __user *)arg, size))\n\t\t\treturn -EFAULT;\n\t}\n\n\terr = handler->func(client, &buf);\n\tif (err >= 0) {\n\t\t/* Some commands includes a bug in 'dir' field. */\n\t\tif (handler->cmd == SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT ||\n\t\t    handler->cmd == SNDRV_SEQ_IOCTL_SET_CLIENT_POOL ||\n\t\t    (handler->cmd & IOC_OUT))\n\t\t\tif (copy_to_user((void __user *)arg, &buf, size))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\n#include \"seq_compat.c\"\n#else\n#define snd_seq_ioctl_compat\tNULL\n#endif\n\n/* -------------------------------------------------------- */\n\n\n/* exported to kernel modules */\nint snd_seq_create_kernel_client(struct snd_card *card, int client_index,\n\t\t\t\t const char *name_fmt, ...)\n{\n\tstruct snd_seq_client *client;\n\tva_list args;\n\n\tif (snd_BUG_ON(in_interrupt()))\n\t\treturn -EBUSY;\n\n\tif (card && client_index >= SNDRV_SEQ_CLIENTS_PER_CARD)\n\t\treturn -EINVAL;\n\tif (card == NULL && client_index >= SNDRV_SEQ_GLOBAL_CLIENTS)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&register_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (card) {\n\t\tclient_index += SNDRV_SEQ_GLOBAL_CLIENTS\n\t\t\t+ card->number * SNDRV_SEQ_CLIENTS_PER_CARD;\n\t\tif (client_index >= SNDRV_SEQ_DYNAMIC_CLIENTS_BEGIN)\n\t\t\tclient_index = -1;\n\t}\n\n\t/* empty write queue as default */\n\tclient = seq_create_client1(client_index, 0);\n\tif (client == NULL) {\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -EBUSY;\t/* failure code */\n\t}\n\tusage_alloc(&client_usage, 1);\n\n\tclient->accept_input = 1;\n\tclient->accept_output = 1;\n\tclient->data.kernel.card = card;\n\t\t\n\tva_start(args, name_fmt);\n\tvsnprintf(client->name, sizeof(client->name), name_fmt, args);\n\tva_end(args);\n\n\tclient->type = KERNEL_CLIENT;\n\tmutex_unlock(&register_mutex);\n\n\t/* make others aware this new client */\n\tsnd_seq_system_client_ev_client_start(client->number);\n\t\n\t/* return client number to caller */\n\treturn client->number;\n}\nEXPORT_SYMBOL(snd_seq_create_kernel_client);\n\n/* exported to kernel modules */\nint snd_seq_delete_kernel_client(int client)\n{\n\tstruct snd_seq_client *ptr;\n\n\tif (snd_BUG_ON(in_interrupt()))\n\t\treturn -EBUSY;\n\n\tptr = clientptr(client);\n\tif (ptr == NULL)\n\t\treturn -EINVAL;\n\n\tseq_free_client(ptr);\n\tkfree(ptr);\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_seq_delete_kernel_client);\n\n/* skeleton to enqueue event, called from snd_seq_kernel_client_enqueue\n * and snd_seq_kernel_client_enqueue_blocking\n */\nstatic int kernel_client_enqueue(int client, struct snd_seq_event *ev,\n\t\t\t\t struct file *file, int blocking,\n\t\t\t\t int atomic, int hop)\n{\n\tstruct snd_seq_client *cptr;\n\tint result;\n\n\tif (snd_BUG_ON(!ev))\n\t\treturn -EINVAL;\n\n\tif (ev->type == SNDRV_SEQ_EVENT_NONE)\n\t\treturn 0; /* ignore this */\n\tif (ev->type == SNDRV_SEQ_EVENT_KERNEL_ERROR)\n\t\treturn -EINVAL; /* quoted events can't be enqueued */\n\n\t/* fill in client number */\n\tev->source.client = client;\n\n\tif (check_event_type_and_length(ev))\n\t\treturn -EINVAL;\n\n\tcptr = snd_seq_client_use_ptr(client);\n\tif (cptr == NULL)\n\t\treturn -EINVAL;\n\t\n\tif (! cptr->accept_output)\n\t\tresult = -EPERM;\n\telse /* send it */\n\t\tresult = snd_seq_client_enqueue_event(cptr, ev, file, blocking, atomic, hop);\n\n\tsnd_seq_client_unlock(cptr);\n\treturn result;\n}\n\n/*\n * exported, called by kernel clients to enqueue events (w/o blocking)\n *\n * RETURN VALUE: zero if succeed, negative if error\n */\nint snd_seq_kernel_client_enqueue(int client, struct snd_seq_event * ev,\n\t\t\t\t  int atomic, int hop)\n{\n\treturn kernel_client_enqueue(client, ev, NULL, 0, atomic, hop);\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_enqueue);\n\n/*\n * exported, called by kernel clients to enqueue events (with blocking)\n *\n * RETURN VALUE: zero if succeed, negative if error\n */\nint snd_seq_kernel_client_enqueue_blocking(int client, struct snd_seq_event * ev,\n\t\t\t\t\t   struct file *file,\n\t\t\t\t\t   int atomic, int hop)\n{\n\treturn kernel_client_enqueue(client, ev, file, 1, atomic, hop);\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_enqueue_blocking);\n\n/* \n * exported, called by kernel clients to dispatch events directly to other\n * clients, bypassing the queues.  Event time-stamp will be updated.\n *\n * RETURN VALUE: negative = delivery failed,\n *\t\t zero, or positive: the number of delivered events\n */\nint snd_seq_kernel_client_dispatch(int client, struct snd_seq_event * ev,\n\t\t\t\t   int atomic, int hop)\n{\n\tstruct snd_seq_client *cptr;\n\tint result;\n\n\tif (snd_BUG_ON(!ev))\n\t\treturn -EINVAL;\n\n\t/* fill in client number */\n\tev->queue = SNDRV_SEQ_QUEUE_DIRECT;\n\tev->source.client = client;\n\n\tif (check_event_type_and_length(ev))\n\t\treturn -EINVAL;\n\n\tcptr = snd_seq_client_use_ptr(client);\n\tif (cptr == NULL)\n\t\treturn -EINVAL;\n\n\tif (!cptr->accept_output)\n\t\tresult = -EPERM;\n\telse\n\t\tresult = snd_seq_deliver_event(cptr, ev, atomic, hop);\n\n\tsnd_seq_client_unlock(cptr);\n\treturn result;\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_dispatch);\n\n/**\n * snd_seq_kernel_client_ctl - operate a command for a client with data in\n *\t\t\t       kernel space.\n * @clientid:\tA numerical ID for a client.\n * @cmd:\tAn ioctl(2) command for ALSA sequencer operation.\n * @arg:\tA pointer to data in kernel space.\n *\n * Against its name, both kernel/application client can be handled by this\n * kernel API. A pointer of 'arg' argument should be in kernel space.\n *\n * Return: 0 at success. Negative error code at failure.\n */\nint snd_seq_kernel_client_ctl(int clientid, unsigned int cmd, void *arg)\n{\n\tconst struct ioctl_handler *handler;\n\tstruct snd_seq_client *client;\n\n\tclient = clientptr(clientid);\n\tif (client == NULL)\n\t\treturn -ENXIO;\n\n\tfor (handler = ioctl_handlers; handler->cmd > 0; ++handler) {\n\t\tif (handler->cmd == cmd)\n\t\t\treturn handler->func(client, arg);\n\t}\n\n\tpr_debug(\"ALSA: seq unknown ioctl() 0x%x (type='%c', number=0x%02x)\\n\",\n\t\t cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));\n\treturn -ENOTTY;\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_ctl);\n\n/* exported (for OSS emulator) */\nint snd_seq_kernel_client_write_poll(int clientid, struct file *file, poll_table *wait)\n{\n\tstruct snd_seq_client *client;\n\n\tclient = clientptr(clientid);\n\tif (client == NULL)\n\t\treturn -ENXIO;\n\n\tif (! snd_seq_write_pool_allocated(client))\n\t\treturn 1;\n\tif (snd_seq_pool_poll_wait(client->pool, file, wait))\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_seq_kernel_client_write_poll);\n\n/*---------------------------------------------------------------------------*/\n\n#ifdef CONFIG_SND_PROC_FS\n/*\n *  /proc interface\n */\nstatic void snd_seq_info_dump_subscribers(struct snd_info_buffer *buffer,\n\t\t\t\t\t  struct snd_seq_port_subs_info *group,\n\t\t\t\t\t  int is_src, char *msg)\n{\n\tstruct list_head *p;\n\tstruct snd_seq_subscribers *s;\n\tint count = 0;\n\n\tdown_read(&group->list_mutex);\n\tif (list_empty(&group->list_head)) {\n\t\tup_read(&group->list_mutex);\n\t\treturn;\n\t}\n\tsnd_iprintf(buffer, msg);\n\tlist_for_each(p, &group->list_head) {\n\t\tif (is_src)\n\t\t\ts = list_entry(p, struct snd_seq_subscribers, src_list);\n\t\telse\n\t\t\ts = list_entry(p, struct snd_seq_subscribers, dest_list);\n\t\tif (count++)\n\t\t\tsnd_iprintf(buffer, \", \");\n\t\tsnd_iprintf(buffer, \"%d:%d\",\n\t\t\t    is_src ? s->info.dest.client : s->info.sender.client,\n\t\t\t    is_src ? s->info.dest.port : s->info.sender.port);\n\t\tif (s->info.flags & SNDRV_SEQ_PORT_SUBS_TIMESTAMP)\n\t\t\tsnd_iprintf(buffer, \"[%c:%d]\", ((s->info.flags & SNDRV_SEQ_PORT_SUBS_TIME_REAL) ? 'r' : 't'), s->info.queue);\n\t\tif (group->exclusive)\n\t\t\tsnd_iprintf(buffer, \"[ex]\");\n\t}\n\tup_read(&group->list_mutex);\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\n#define FLAG_PERM_RD(perm) ((perm) & SNDRV_SEQ_PORT_CAP_READ ? ((perm) & SNDRV_SEQ_PORT_CAP_SUBS_READ ? 'R' : 'r') : '-')\n#define FLAG_PERM_WR(perm) ((perm) & SNDRV_SEQ_PORT_CAP_WRITE ? ((perm) & SNDRV_SEQ_PORT_CAP_SUBS_WRITE ? 'W' : 'w') : '-')\n#define FLAG_PERM_EX(perm) ((perm) & SNDRV_SEQ_PORT_CAP_NO_EXPORT ? '-' : 'e')\n\n#define FLAG_PERM_DUPLEX(perm) ((perm) & SNDRV_SEQ_PORT_CAP_DUPLEX ? 'X' : '-')\n\nstatic void snd_seq_info_dump_ports(struct snd_info_buffer *buffer,\n\t\t\t\t    struct snd_seq_client *client)\n{\n\tstruct snd_seq_client_port *p;\n\n\tmutex_lock(&client->ports_mutex);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tsnd_iprintf(buffer, \"  Port %3d : \\\"%s\\\" (%c%c%c%c)\\n\",\n\t\t\t    p->addr.port, p->name,\n\t\t\t    FLAG_PERM_RD(p->capability),\n\t\t\t    FLAG_PERM_WR(p->capability),\n\t\t\t    FLAG_PERM_EX(p->capability),\n\t\t\t    FLAG_PERM_DUPLEX(p->capability));\n\t\tsnd_seq_info_dump_subscribers(buffer, &p->c_src, 1, \"    Connecting To: \");\n\t\tsnd_seq_info_dump_subscribers(buffer, &p->c_dest, 0, \"    Connected From: \");\n\t}\n\tmutex_unlock(&client->ports_mutex);\n}\n\n\n/* exported to seq_info.c */\nvoid snd_seq_info_clients_read(struct snd_info_entry *entry, \n\t\t\t       struct snd_info_buffer *buffer)\n{\n\tint c;\n\tstruct snd_seq_client *client;\n\n\tsnd_iprintf(buffer, \"Client info\\n\");\n\tsnd_iprintf(buffer, \"  cur  clients : %d\\n\", client_usage.cur);\n\tsnd_iprintf(buffer, \"  peak clients : %d\\n\", client_usage.peak);\n\tsnd_iprintf(buffer, \"  max  clients : %d\\n\", SNDRV_SEQ_MAX_CLIENTS);\n\tsnd_iprintf(buffer, \"\\n\");\n\n\t/* list the client table */\n\tfor (c = 0; c < SNDRV_SEQ_MAX_CLIENTS; c++) {\n\t\tclient = snd_seq_client_use_ptr(c);\n\t\tif (client == NULL)\n\t\t\tcontinue;\n\t\tif (client->type == NO_CLIENT) {\n\t\t\tsnd_seq_client_unlock(client);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsnd_iprintf(buffer, \"Client %3d : \\\"%s\\\" [%s]\\n\",\n\t\t\t    c, client->name,\n\t\t\t    client->type == USER_CLIENT ? \"User\" : \"Kernel\");\n\t\tsnd_seq_info_dump_ports(buffer, client);\n\t\tif (snd_seq_write_pool_allocated(client)) {\n\t\t\tsnd_iprintf(buffer, \"  Output pool :\\n\");\n\t\t\tsnd_seq_info_pool(buffer, client->pool, \"    \");\n\t\t}\n\t\tif (client->type == USER_CLIENT && client->data.user.fifo &&\n\t\t    client->data.user.fifo->pool) {\n\t\t\tsnd_iprintf(buffer, \"  Input pool :\\n\");\n\t\t\tsnd_seq_info_pool(buffer, client->data.user.fifo->pool, \"    \");\n\t\t}\n\t\tsnd_seq_client_unlock(client);\n\t}\n}\n#endif /* CONFIG_SND_PROC_FS */\n\n/*---------------------------------------------------------------------------*/\n\n\n/*\n *  REGISTRATION PART\n */\n\nstatic const struct file_operations snd_seq_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_seq_read,\n\t.write =\tsnd_seq_write,\n\t.open =\t\tsnd_seq_open,\n\t.release =\tsnd_seq_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_seq_poll,\n\t.unlocked_ioctl =\tsnd_seq_ioctl,\n\t.compat_ioctl =\tsnd_seq_ioctl_compat,\n};\n\nstatic struct device seq_dev;\n\n/* \n * register sequencer device \n */\nint __init snd_sequencer_device_init(void)\n{\n\tint err;\n\n\tsnd_device_initialize(&seq_dev, NULL);\n\tdev_set_name(&seq_dev, \"seq\");\n\n\tif (mutex_lock_interruptible(&register_mutex))\n\t\treturn -ERESTARTSYS;\n\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_SEQUENCER, NULL, 0,\n\t\t\t\t  &snd_seq_f_ops, NULL, &seq_dev);\n\tif (err < 0) {\n\t\tmutex_unlock(&register_mutex);\n\t\tput_device(&seq_dev);\n\t\treturn err;\n\t}\n\t\n\tmutex_unlock(&register_mutex);\n\n\treturn 0;\n}\n\n\n\n/* \n * unregister sequencer device \n */\nvoid __exit snd_sequencer_device_done(void)\n{\n\tsnd_unregister_device(&seq_dev);\n\tput_device(&seq_dev);\n}\n", "/*\n *   ALSA sequencer Ports\n *   Copyright (c) 1998 by Frank van de Pol <fvdpol@coil.demon.nl>\n *                         Jaroslav Kysela <perex@perex.cz>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <sound/core.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include \"seq_system.h\"\n#include \"seq_ports.h\"\n#include \"seq_clientmgr.h\"\n\n/*\n\n   registration of client ports\n\n */\n\n\n/* \n\nNOTE: the current implementation of the port structure as a linked list is\nnot optimal for clients that have many ports. For sending messages to all\nsubscribers of a port we first need to find the address of the port\nstructure, which means we have to traverse the list. A direct access table\n(array) would be better, but big preallocated arrays waste memory.\n\nPossible actions:\n\n1) leave it this way, a client does normaly does not have more than a few\nports\n\n2) replace the linked list of ports by a array of pointers which is\ndynamicly kmalloced. When a port is added or deleted we can simply allocate\na new array, copy the corresponding pointers, and delete the old one. We\nthen only need a pointer to this array, and an integer that tells us how\nmuch elements are in array.\n\n*/\n\n/* return pointer to port structure - port is locked if found */\nstruct snd_seq_client_port *snd_seq_port_use_ptr(struct snd_seq_client *client,\n\t\t\t\t\t\t int num)\n{\n\tstruct snd_seq_client_port *port;\n\n\tif (client == NULL)\n\t\treturn NULL;\n\tread_lock(&client->ports_lock);\n\tlist_for_each_entry(port, &client->ports_list_head, list) {\n\t\tif (port->addr.port == num) {\n\t\t\tif (port->closing)\n\t\t\t\tbreak; /* deleting now */\n\t\t\tsnd_use_lock_use(&port->use_lock);\n\t\t\tread_unlock(&client->ports_lock);\n\t\t\treturn port;\n\t\t}\n\t}\n\tread_unlock(&client->ports_lock);\n\treturn NULL;\t\t/* not found */\n}\n\n\n/* search for the next port - port is locked if found */\nstruct snd_seq_client_port *snd_seq_port_query_nearest(struct snd_seq_client *client,\n\t\t\t\t\t\t       struct snd_seq_port_info *pinfo)\n{\n\tint num;\n\tstruct snd_seq_client_port *port, *found;\n\n\tnum = pinfo->addr.port;\n\tfound = NULL;\n\tread_lock(&client->ports_lock);\n\tlist_for_each_entry(port, &client->ports_list_head, list) {\n\t\tif (port->addr.port < num)\n\t\t\tcontinue;\n\t\tif (port->addr.port == num) {\n\t\t\tfound = port;\n\t\t\tbreak;\n\t\t}\n\t\tif (found == NULL || port->addr.port < found->addr.port)\n\t\t\tfound = port;\n\t}\n\tif (found) {\n\t\tif (found->closing)\n\t\t\tfound = NULL;\n\t\telse\n\t\t\tsnd_use_lock_use(&found->use_lock);\n\t}\n\tread_unlock(&client->ports_lock);\n\treturn found;\n}\n\n\n/* initialize snd_seq_port_subs_info */\nstatic void port_subs_info_init(struct snd_seq_port_subs_info *grp)\n{\n\tINIT_LIST_HEAD(&grp->list_head);\n\tgrp->count = 0;\n\tgrp->exclusive = 0;\n\trwlock_init(&grp->list_lock);\n\tinit_rwsem(&grp->list_mutex);\n\tgrp->open = NULL;\n\tgrp->close = NULL;\n}\n\n\n/* create a port, port number is returned (-1 on failure);\n * the caller needs to unref the port via snd_seq_port_unlock() appropriately\n */\nstruct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n\t\t\t\t\t\tint port)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\t\n\t/* sanity check */\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\n\t/* create a new port */\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t/* failure, out of memory */\n\t/* init port data */\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n\tsnd_use_lock_init(&new_port->use_lock);\n\tport_subs_info_init(&new_port->c_src);\n\tport_subs_info_init(&new_port->c_dest);\n\tsnd_use_lock_use(&new_port->use_lock);\n\n\tnum = port >= 0 ? port : 0;\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) /* auto-probe mode */\n\t\t\tnum = p->addr.port + 1;\n\t}\n\t/* insert the new port */\n\tlist_add_tail(&new_port->list, &p->list);\n\tclient->num_ports++;\n\tnew_port->addr.port = num;\t/* store the port number in the port */\n\tsprintf(new_port->name, \"port-%d\", num);\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\tmutex_unlock(&client->ports_mutex);\n\n\treturn new_port;\n}\n\n/* */\nstatic int subscribe_port(struct snd_seq_client *client,\n\t\t\t  struct snd_seq_client_port *port,\n\t\t\t  struct snd_seq_port_subs_info *grp,\n\t\t\t  struct snd_seq_port_subscribe *info, int send_ack);\nstatic int unsubscribe_port(struct snd_seq_client *client,\n\t\t\t    struct snd_seq_client_port *port,\n\t\t\t    struct snd_seq_port_subs_info *grp,\n\t\t\t    struct snd_seq_port_subscribe *info, int send_ack);\n\n\nstatic struct snd_seq_client_port *get_client_port(struct snd_seq_addr *addr,\n\t\t\t\t\t\t   struct snd_seq_client **cp)\n{\n\tstruct snd_seq_client_port *p;\n\t*cp = snd_seq_client_use_ptr(addr->client);\n\tif (*cp) {\n\t\tp = snd_seq_port_use_ptr(*cp, addr->port);\n\t\tif (! p) {\n\t\t\tsnd_seq_client_unlock(*cp);\n\t\t\t*cp = NULL;\n\t\t}\n\t\treturn p;\n\t}\n\treturn NULL;\n}\n\nstatic void delete_and_unsubscribe_port(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_client_port *port,\n\t\t\t\t\tstruct snd_seq_subscribers *subs,\n\t\t\t\t\tbool is_src, bool ack);\n\nstatic inline struct snd_seq_subscribers *\nget_subscriber(struct list_head *p, bool is_src)\n{\n\tif (is_src)\n\t\treturn list_entry(p, struct snd_seq_subscribers, src_list);\n\telse\n\t\treturn list_entry(p, struct snd_seq_subscribers, dest_list);\n}\n\n/*\n * remove all subscribers on the list\n * this is called from port_delete, for each src and dest list.\n */\nstatic void clear_subscriber_list(struct snd_seq_client *client,\n\t\t\t\t  struct snd_seq_client_port *port,\n\t\t\t\t  struct snd_seq_port_subs_info *grp,\n\t\t\t\t  int is_src)\n{\n\tstruct list_head *p, *n;\n\n\tlist_for_each_safe(p, n, &grp->list_head) {\n\t\tstruct snd_seq_subscribers *subs;\n\t\tstruct snd_seq_client *c;\n\t\tstruct snd_seq_client_port *aport;\n\n\t\tsubs = get_subscriber(p, is_src);\n\t\tif (is_src)\n\t\t\taport = get_client_port(&subs->info.dest, &c);\n\t\telse\n\t\t\taport = get_client_port(&subs->info.sender, &c);\n\t\tdelete_and_unsubscribe_port(client, port, subs, is_src, false);\n\n\t\tif (!aport) {\n\t\t\t/* looks like the connected port is being deleted.\n\t\t\t * we decrease the counter, and when both ports are deleted\n\t\t\t * remove the subscriber info\n\t\t\t */\n\t\t\tif (atomic_dec_and_test(&subs->ref_count))\n\t\t\t\tkfree(subs);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* ok we got the connected port */\n\t\tdelete_and_unsubscribe_port(c, aport, subs, !is_src, true);\n\t\tkfree(subs);\n\t\tsnd_seq_port_unlock(aport);\n\t\tsnd_seq_client_unlock(c);\n\t}\n}\n\n/* delete port data */\nstatic int port_delete(struct snd_seq_client *client,\n\t\t       struct snd_seq_client_port *port)\n{\n\t/* set closing flag and wait for all port access are gone */\n\tport->closing = 1;\n\tsnd_use_lock_sync(&port->use_lock); \n\n\t/* clear subscribers info */\n\tclear_subscriber_list(client, port, &port->c_src, true);\n\tclear_subscriber_list(client, port, &port->c_dest, false);\n\n\tif (port->private_free)\n\t\tport->private_free(port->private_data);\n\n\tsnd_BUG_ON(port->c_src.count != 0);\n\tsnd_BUG_ON(port->c_dest.count != 0);\n\n\tkfree(port);\n\treturn 0;\n}\n\n\n/* delete a port with the given port id */\nint snd_seq_delete_port(struct snd_seq_client *client, int port)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client_port *found = NULL, *p;\n\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port == port) {\n\t\t\t/* ok found.  delete from the list at first */\n\t\t\tlist_del(&p->list);\n\t\t\tclient->num_ports--;\n\t\t\tfound = p;\n\t\t\tbreak;\n\t\t}\n\t}\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\tmutex_unlock(&client->ports_mutex);\n\tif (found)\n\t\treturn port_delete(client, found);\n\telse\n\t\treturn -ENOENT;\n}\n\n/* delete the all ports belonging to the given client */\nint snd_seq_delete_all_ports(struct snd_seq_client *client)\n{\n\tunsigned long flags;\n\tstruct list_head deleted_list;\n\tstruct snd_seq_client_port *port, *tmp;\n\t\n\t/* move the port list to deleted_list, and\n\t * clear the port list in the client data.\n\t */\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tif (! list_empty(&client->ports_list_head)) {\n\t\tlist_add(&deleted_list, &client->ports_list_head);\n\t\tlist_del_init(&client->ports_list_head);\n\t} else {\n\t\tINIT_LIST_HEAD(&deleted_list);\n\t}\n\tclient->num_ports = 0;\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\n\t/* remove each port in deleted_list */\n\tlist_for_each_entry_safe(port, tmp, &deleted_list, list) {\n\t\tlist_del(&port->list);\n\t\tsnd_seq_system_client_ev_port_exit(port->addr.client, port->addr.port);\n\t\tport_delete(client, port);\n\t}\n\tmutex_unlock(&client->ports_mutex);\n\treturn 0;\n}\n\n/* set port info fields */\nint snd_seq_set_port_info(struct snd_seq_client_port * port,\n\t\t\t  struct snd_seq_port_info * info)\n{\n\tif (snd_BUG_ON(!port || !info))\n\t\treturn -EINVAL;\n\n\t/* set port name */\n\tif (info->name[0])\n\t\tstrlcpy(port->name, info->name, sizeof(port->name));\n\t\n\t/* set capabilities */\n\tport->capability = info->capability;\n\t\n\t/* get port type */\n\tport->type = info->type;\n\n\t/* information about supported channels/voices */\n\tport->midi_channels = info->midi_channels;\n\tport->midi_voices = info->midi_voices;\n\tport->synth_voices = info->synth_voices;\n\n\t/* timestamping */\n\tport->timestamping = (info->flags & SNDRV_SEQ_PORT_FLG_TIMESTAMP) ? 1 : 0;\n\tport->time_real = (info->flags & SNDRV_SEQ_PORT_FLG_TIME_REAL) ? 1 : 0;\n\tport->time_queue = info->time_queue;\n\n\treturn 0;\n}\n\n/* get port info fields */\nint snd_seq_get_port_info(struct snd_seq_client_port * port,\n\t\t\t  struct snd_seq_port_info * info)\n{\n\tif (snd_BUG_ON(!port || !info))\n\t\treturn -EINVAL;\n\n\t/* get port name */\n\tstrlcpy(info->name, port->name, sizeof(info->name));\n\t\n\t/* get capabilities */\n\tinfo->capability = port->capability;\n\n\t/* get port type */\n\tinfo->type = port->type;\n\n\t/* information about supported channels/voices */\n\tinfo->midi_channels = port->midi_channels;\n\tinfo->midi_voices = port->midi_voices;\n\tinfo->synth_voices = port->synth_voices;\n\n\t/* get subscriber counts */\n\tinfo->read_use = port->c_src.count;\n\tinfo->write_use = port->c_dest.count;\n\t\n\t/* timestamping */\n\tinfo->flags = 0;\n\tif (port->timestamping) {\n\t\tinfo->flags |= SNDRV_SEQ_PORT_FLG_TIMESTAMP;\n\t\tif (port->time_real)\n\t\t\tinfo->flags |= SNDRV_SEQ_PORT_FLG_TIME_REAL;\n\t\tinfo->time_queue = port->time_queue;\n\t}\n\n\treturn 0;\n}\n\n\n\n/*\n * call callback functions (if any):\n * the callbacks are invoked only when the first (for connection) or\n * the last subscription (for disconnection) is done.  Second or later\n * subscription results in increment of counter, but no callback is\n * invoked.\n * This feature is useful if these callbacks are associated with\n * initialization or termination of devices (see seq_midi.c).\n */\n\nstatic int subscribe_port(struct snd_seq_client *client,\n\t\t\t  struct snd_seq_client_port *port,\n\t\t\t  struct snd_seq_port_subs_info *grp,\n\t\t\t  struct snd_seq_port_subscribe *info,\n\t\t\t  int send_ack)\n{\n\tint err = 0;\n\n\tif (!try_module_get(port->owner))\n\t\treturn -EFAULT;\n\tgrp->count++;\n\tif (grp->open && grp->count == 1) {\n\t\terr = grp->open(port->private_data, info);\n\t\tif (err < 0) {\n\t\t\tmodule_put(port->owner);\n\t\t\tgrp->count--;\n\t\t}\n\t}\n\tif (err >= 0 && send_ack && client->type == USER_CLIENT)\n\t\tsnd_seq_client_notify_subscription(port->addr.client, port->addr.port,\n\t\t\t\t\t\t   info, SNDRV_SEQ_EVENT_PORT_SUBSCRIBED);\n\n\treturn err;\n}\n\nstatic int unsubscribe_port(struct snd_seq_client *client,\n\t\t\t    struct snd_seq_client_port *port,\n\t\t\t    struct snd_seq_port_subs_info *grp,\n\t\t\t    struct snd_seq_port_subscribe *info,\n\t\t\t    int send_ack)\n{\n\tint err = 0;\n\n\tif (! grp->count)\n\t\treturn -EINVAL;\n\tgrp->count--;\n\tif (grp->close && grp->count == 0)\n\t\terr = grp->close(port->private_data, info);\n\tif (send_ack && client->type == USER_CLIENT)\n\t\tsnd_seq_client_notify_subscription(port->addr.client, port->addr.port,\n\t\t\t\t\t\t   info, SNDRV_SEQ_EVENT_PORT_UNSUBSCRIBED);\n\tmodule_put(port->owner);\n\treturn err;\n}\n\n\n\n/* check if both addresses are identical */\nstatic inline int addr_match(struct snd_seq_addr *r, struct snd_seq_addr *s)\n{\n\treturn (r->client == s->client) && (r->port == s->port);\n}\n\n/* check the two subscribe info match */\n/* if flags is zero, checks only sender and destination addresses */\nstatic int match_subs_info(struct snd_seq_port_subscribe *r,\n\t\t\t   struct snd_seq_port_subscribe *s)\n{\n\tif (addr_match(&r->sender, &s->sender) &&\n\t    addr_match(&r->dest, &s->dest)) {\n\t\tif (r->flags && r->flags == s->flags)\n\t\t\treturn r->queue == s->queue;\n\t\telse if (! r->flags)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int check_and_subscribe_port(struct snd_seq_client *client,\n\t\t\t\t    struct snd_seq_client_port *port,\n\t\t\t\t    struct snd_seq_subscribers *subs,\n\t\t\t\t    bool is_src, bool exclusive, bool ack)\n{\n\tstruct snd_seq_port_subs_info *grp;\n\tstruct list_head *p;\n\tstruct snd_seq_subscribers *s;\n\tint err;\n\n\tgrp = is_src ? &port->c_src : &port->c_dest;\n\terr = -EBUSY;\n\tdown_write(&grp->list_mutex);\n\tif (exclusive) {\n\t\tif (!list_empty(&grp->list_head))\n\t\t\tgoto __error;\n\t} else {\n\t\tif (grp->exclusive)\n\t\t\tgoto __error;\n\t\t/* check whether already exists */\n\t\tlist_for_each(p, &grp->list_head) {\n\t\t\ts = get_subscriber(p, is_src);\n\t\t\tif (match_subs_info(&subs->info, &s->info))\n\t\t\t\tgoto __error;\n\t\t}\n\t}\n\n\terr = subscribe_port(client, port, grp, &subs->info, ack);\n\tif (err < 0) {\n\t\tgrp->exclusive = 0;\n\t\tgoto __error;\n\t}\n\n\t/* add to list */\n\twrite_lock_irq(&grp->list_lock);\n\tif (is_src)\n\t\tlist_add_tail(&subs->src_list, &grp->list_head);\n\telse\n\t\tlist_add_tail(&subs->dest_list, &grp->list_head);\n\tgrp->exclusive = exclusive;\n\tatomic_inc(&subs->ref_count);\n\twrite_unlock_irq(&grp->list_lock);\n\terr = 0;\n\n __error:\n\tup_write(&grp->list_mutex);\n\treturn err;\n}\n\nstatic void delete_and_unsubscribe_port(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_client_port *port,\n\t\t\t\t\tstruct snd_seq_subscribers *subs,\n\t\t\t\t\tbool is_src, bool ack)\n{\n\tstruct snd_seq_port_subs_info *grp;\n\tstruct list_head *list;\n\tbool empty;\n\n\tgrp = is_src ? &port->c_src : &port->c_dest;\n\tlist = is_src ? &subs->src_list : &subs->dest_list;\n\tdown_write(&grp->list_mutex);\n\twrite_lock_irq(&grp->list_lock);\n\tempty = list_empty(list);\n\tif (!empty)\n\t\tlist_del_init(list);\n\tgrp->exclusive = 0;\n\twrite_unlock_irq(&grp->list_lock);\n\tup_write(&grp->list_mutex);\n\n\tif (!empty)\n\t\tunsubscribe_port(client, port, grp, &subs->info, ack);\n}\n\n/* connect two ports */\nint snd_seq_port_connect(struct snd_seq_client *connector,\n\t\t\t struct snd_seq_client *src_client,\n\t\t\t struct snd_seq_client_port *src_port,\n\t\t\t struct snd_seq_client *dest_client,\n\t\t\t struct snd_seq_client_port *dest_port,\n\t\t\t struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_seq_subscribers *subs;\n\tbool exclusive;\n\tint err;\n\n\tsubs = kzalloc(sizeof(*subs), GFP_KERNEL);\n\tif (!subs)\n\t\treturn -ENOMEM;\n\n\tsubs->info = *info;\n\tatomic_set(&subs->ref_count, 0);\n\tINIT_LIST_HEAD(&subs->src_list);\n\tINIT_LIST_HEAD(&subs->dest_list);\n\n\texclusive = !!(info->flags & SNDRV_SEQ_PORT_SUBS_EXCLUSIVE);\n\n\terr = check_and_subscribe_port(src_client, src_port, subs, true,\n\t\t\t\t       exclusive,\n\t\t\t\t       connector->number != src_client->number);\n\tif (err < 0)\n\t\tgoto error;\n\terr = check_and_subscribe_port(dest_client, dest_port, subs, false,\n\t\t\t\t       exclusive,\n\t\t\t\t       connector->number != dest_client->number);\n\tif (err < 0)\n\t\tgoto error_dest;\n\n\treturn 0;\n\n error_dest:\n\tdelete_and_unsubscribe_port(src_client, src_port, subs, true,\n\t\t\t\t    connector->number != src_client->number);\n error:\n\tkfree(subs);\n\treturn err;\n}\n\n/* remove the connection */\nint snd_seq_port_disconnect(struct snd_seq_client *connector,\n\t\t\t    struct snd_seq_client *src_client,\n\t\t\t    struct snd_seq_client_port *src_port,\n\t\t\t    struct snd_seq_client *dest_client,\n\t\t\t    struct snd_seq_client_port *dest_port,\n\t\t\t    struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_seq_port_subs_info *src = &src_port->c_src;\n\tstruct snd_seq_subscribers *subs;\n\tint err = -ENOENT;\n\n\tdown_write(&src->list_mutex);\n\t/* look for the connection */\n\tlist_for_each_entry(subs, &src->list_head, src_list) {\n\t\tif (match_subs_info(info, &subs->info)) {\n\t\t\tatomic_dec(&subs->ref_count); /* mark as not ready */\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&src->list_mutex);\n\tif (err < 0)\n\t\treturn err;\n\n\tdelete_and_unsubscribe_port(src_client, src_port, subs, true,\n\t\t\t\t    connector->number != src_client->number);\n\tdelete_and_unsubscribe_port(dest_client, dest_port, subs, false,\n\t\t\t\t    connector->number != dest_client->number);\n\tkfree(subs);\n\treturn 0;\n}\n\n\n/* get matched subscriber */\nstruct snd_seq_subscribers *snd_seq_port_get_subscription(struct snd_seq_port_subs_info *src_grp,\n\t\t\t\t\t\t\t  struct snd_seq_addr *dest_addr)\n{\n\tstruct snd_seq_subscribers *s, *found = NULL;\n\n\tdown_read(&src_grp->list_mutex);\n\tlist_for_each_entry(s, &src_grp->list_head, src_list) {\n\t\tif (addr_match(dest_addr, &s->info.dest)) {\n\t\t\tfound = s;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&src_grp->list_mutex);\n\treturn found;\n}\n\n/*\n * Attach a device driver that wants to receive events from the\n * sequencer.  Returns the new port number on success.\n * A driver that wants to receive the events converted to midi, will\n * use snd_seq_midisynth_register_port().\n */\n/* exported */\nint snd_seq_event_port_attach(int client,\n\t\t\t      struct snd_seq_port_callback *pcbp,\n\t\t\t      int cap, int type, int midi_channels,\n\t\t\t      int midi_voices, char *portname)\n{\n\tstruct snd_seq_port_info portinfo;\n\tint  ret;\n\n\t/* Set up the port */\n\tmemset(&portinfo, 0, sizeof(portinfo));\n\tportinfo.addr.client = client;\n\tstrlcpy(portinfo.name, portname ? portname : \"Unamed port\",\n\t\tsizeof(portinfo.name));\n\n\tportinfo.capability = cap;\n\tportinfo.type = type;\n\tportinfo.kernel = pcbp;\n\tportinfo.midi_channels = midi_channels;\n\tportinfo.midi_voices = midi_voices;\n\n\t/* Create it */\n\tret = snd_seq_kernel_client_ctl(client,\n\t\t\t\t\tSNDRV_SEQ_IOCTL_CREATE_PORT,\n\t\t\t\t\t&portinfo);\n\n\tif (ret >= 0)\n\t\tret = portinfo.addr.port;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_seq_event_port_attach);\n\n/*\n * Detach the driver from a port.\n */\n/* exported */\nint snd_seq_event_port_detach(int client, int port)\n{\n\tstruct snd_seq_port_info portinfo;\n\tint  err;\n\n\tmemset(&portinfo, 0, sizeof(portinfo));\n\tportinfo.addr.client = client;\n\tportinfo.addr.port   = port;\n\terr = snd_seq_kernel_client_ctl(client,\n\t\t\t\t\tSNDRV_SEQ_IOCTL_DELETE_PORT,\n\t\t\t\t\t&portinfo);\n\n\treturn err;\n}\nEXPORT_SYMBOL(snd_seq_event_port_detach);\n"], "buggy_code_start_loc": [1261, 125], "buggy_code_end_loc": [1292, 171], "fixing_code_start_loc": [1262, 125], "fixing_code_end_loc": [1297, 173], "type": "CWE-362", "message": "Race condition in the ALSA subsystem in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted /dev/snd/seq ioctl calls, related to sound/core/seq/seq_clientmgr.c and sound/core/seq/seq_ports.c.", "other": {"cve": {"id": "CVE-2017-15265", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-16T18:29:00.577", "lastModified": "2020-07-15T03:15:18.623", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in the ALSA subsystem in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted /dev/snd/seq ioctl calls, related to sound/core/seq/seq_clientmgr.c and sound/core/seq/seq_ports.c."}, {"lang": "es", "value": "Condici\u00c3\u00b3n de carrera en el subsistema ALSA en el kernel de Linux en versiones anteriores a la 4.13.8 permite que usuarios locales provoquen una denegaci\u00c3\u00b3n de servicio (uso de memoria previamente liberada) o posiblemente otro impacto mediante llamadas ioctl /dev/snd/seq ioctl manipuladas. Esto est\u00c3\u00a1 relacionado con sound/core/seq/seq_clientmgr.c y sound/core/seq/seq_ports.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}, {"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.13.7", "matchCriteriaId": "11C6B206-8716-4A16-81BD-F3B8C8ACBE19"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=71105998845fb012937332fe2e806d443c09e026", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://mailman.alsa-project.org/pipermail/alsa-devel/2017-October/126292.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.13.8", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/10/11/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/101288", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1039561", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0676", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:1062", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:1130", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:1170", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:2390", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3822", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3823", "source": "cve@mitre.org"}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1062520", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://help.ecostruxureit.com/display/public/UADCE725/Security+fixes+in+StruxureWare+Data+Center+Expert+v7.6.0", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2017/12/msg00004.html", "source": "cve@mitre.org"}, {"url": "https://source.android.com/security/bulletin/2018-02-01", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3698-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3698-2/", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpujul2020.html", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuapr2019-5072813.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026"}}