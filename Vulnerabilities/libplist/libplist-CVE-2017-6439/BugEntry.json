{"buggy_code": ["/*\n * bplist.c\n * Binary plist implementation\n *\n * Copyright (c) 2011-2017 Nikias Bassen, All Rights Reserved.\n * Copyright (c) 2008-2010 Jonathan Beck, All Rights Reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include <ctype.h>\n#include <inttypes.h>\n\n#include <plist/plist.h>\n#include \"plist.h\"\n#include \"hashtable.h\"\n#include \"bytearray.h\"\n#include \"ptrarray.h\"\n\n#include <node.h>\n#include <node_iterator.h>\n\n/* Magic marker and size. */\n#define BPLIST_MAGIC            ((uint8_t*)\"bplist\")\n#define BPLIST_MAGIC_SIZE       6\n\n#define BPLIST_VERSION          ((uint8_t*)\"00\")\n#define BPLIST_VERSION_SIZE     2\n\ntypedef struct __attribute__((packed)) {\n    uint8_t unused[6];\n    uint8_t offset_size;\n    uint8_t ref_size;\n    uint64_t num_objects;\n    uint64_t root_object_index;\n    uint64_t offset_table_offset;\n} bplist_trailer_t;\n\nenum\n{\n    BPLIST_NULL = 0x00,\n    BPLIST_FALSE = 0x08,\n    BPLIST_TRUE = 0x09,\n    BPLIST_FILL = 0x0F,\t\t\t/* will be used for length grabbing */\n    BPLIST_UINT = 0x10,\n    BPLIST_REAL = 0x20,\n    BPLIST_DATE = 0x30,\n    BPLIST_DATA = 0x40,\n    BPLIST_STRING = 0x50,\n    BPLIST_UNICODE = 0x60,\n    BPLIST_UNK_0x70 = 0x70,\n    BPLIST_UID = 0x80,\n    BPLIST_ARRAY = 0xA0,\n    BPLIST_SET = 0xC0,\n    BPLIST_DICT = 0xD0,\n    BPLIST_MASK = 0xF0\n};\n\nunion plist_uint_ptr\n{\n    const void *src;\n    uint8_t *u8ptr;\n    uint16_t *u16ptr;\n    uint32_t *u32ptr;\n    uint64_t *u64ptr;\n};\n\n#define get_unaligned(ptr)\t\t\t  \\\n  ({                                              \\\n    struct __attribute__((packed)) {\t\t  \\\n      typeof(*(ptr)) __v;\t\t\t  \\\n    } *__p = (void *) (ptr);\t\t\t  \\\n    __p->__v;\t\t\t\t\t  \\\n  })\n\n\n#ifndef bswap16\n#define bswap16(x)   ((((x) & 0xFF00) >> 8) | (((x) & 0x00FF) << 8))\n#endif\n\n#ifndef bswap32\n#define bswap32(x)   ((((x) & 0xFF000000) >> 24) \\\n                    | (((x) & 0x00FF0000) >>  8) \\\n                    | (((x) & 0x0000FF00) <<  8) \\\n                    | (((x) & 0x000000FF) << 24))\n#endif\n\n#ifndef bswap64\n#define bswap64(x)   ((((x) & 0xFF00000000000000ull) >> 56) \\\n                    | (((x) & 0x00FF000000000000ull) >> 40) \\\n                    | (((x) & 0x0000FF0000000000ull) >> 24) \\\n                    | (((x) & 0x000000FF00000000ull) >>  8) \\\n                    | (((x) & 0x00000000FF000000ull) <<  8) \\\n                    | (((x) & 0x0000000000FF0000ull) << 24) \\\n                    | (((x) & 0x000000000000FF00ull) << 40) \\\n                    | (((x) & 0x00000000000000FFull) << 56))\n#endif\n\n#ifndef be16toh\n#ifdef __BIG_ENDIAN__\n#define be16toh(x) (x)\n#else\n#define be16toh(x) bswap16(x)\n#endif\n#endif\n\n#ifndef be32toh\n#ifdef __BIG_ENDIAN__\n#define be32toh(x) (x)\n#else\n#define be32toh(x) bswap32(x)\n#endif\n#endif\n\n#ifndef be64toh\n#ifdef __BIG_ENDIAN__\n#define be64toh(x) (x)\n#else\n#define be64toh(x) bswap64(x)\n#endif\n#endif\n\n#ifdef __BIG_ENDIAN__\n#define beNtoh(x,n) (x >> ((8-n) << 3))\n#else\n#define beNtoh(x,n) be64toh(x << ((8-n) << 3))\n#endif\n\n#define UINT_TO_HOST(x, n) \\\n\t({ \\\n\t\tunion plist_uint_ptr __up; \\\n\t\t__up.src = (n > 8) ? x + (n - 8) : x; \\\n\t\t(n >= 8 ? be64toh( get_unaligned(__up.u64ptr) ) : \\\n\t\t(n == 4 ? be32toh( get_unaligned(__up.u32ptr) ) : \\\n\t\t(n == 2 ? be16toh( get_unaligned(__up.u16ptr) ) : \\\n                (n == 1 ? *__up.u8ptr : \\\n\t\tbeNtoh( get_unaligned(__up.u64ptr), n) \\\n\t\t)))); \\\n\t})\n\n#define get_needed_bytes(x) \\\n\t\t( ((uint64_t)x) < (1ULL << 8) ? 1 : \\\n\t\t( ((uint64_t)x) < (1ULL << 16) ? 2 : \\\n\t\t( ((uint64_t)x) < (1ULL << 24) ? 3 : \\\n\t\t( ((uint64_t)x) < (1ULL << 32) ? 4 : 8))))\n\n#define get_real_bytes(x) (x == (float) x ? sizeof(float) : sizeof(double))\n\n#if (defined(__LITTLE_ENDIAN__) \\\n     && !defined(__FLOAT_WORD_ORDER__)) \\\n || (defined(__FLOAT_WORD_ORDER__) \\\n     && __FLOAT_WORD_ORDER__ == __ORDER_LITTLE_ENDIAN__)\n#define float_bswap64(x) bswap64(x)\n#define float_bswap32(x) bswap32(x)\n#else\n#define float_bswap64(x) (x)\n#define float_bswap32(x) (x)\n#endif\n\n\n#define NODE_IS_ROOT(x) (((node_t*)x)->isRoot)\n\nstruct bplist_data {\n    const char* data;\n    uint64_t size;\n    uint64_t num_objects;\n    uint8_t ref_size;\n    uint8_t offset_size;\n    const char* offset_table;\n    uint32_t level;\n    plist_t used_indexes;\n};\n\n#ifdef DEBUG\nstatic int plist_bin_debug = 0;\n#define PLIST_BIN_ERR(...) if (plist_bin_debug) { fprintf(stderr, \"libplist[binparser] ERROR: \" __VA_ARGS__); }\n#else\n#define PLIST_BIN_ERR(...)\n#endif\n\nvoid plist_bin_init(void)\n{\n    /* init binary plist stuff */\n#ifdef DEBUG\n    char *env_debug = getenv(\"PLIST_BIN_DEBUG\");\n    if (env_debug && !strcmp(env_debug, \"1\")) {\n        plist_bin_debug = 1;\n    }\n#endif\n}\n\nvoid plist_bin_deinit(void)\n{\n    /* deinit binary plist stuff */\n}\n\nstatic plist_t parse_bin_node_at_index(struct bplist_data *bplist, uint32_t node_index);\n\nstatic plist_t parse_uint_node(const char **bnode, uint8_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n\n    size = 1 << size;\t\t\t// make length less misleading\n    switch (size)\n    {\n    case sizeof(uint8_t):\n    case sizeof(uint16_t):\n    case sizeof(uint32_t):\n    case sizeof(uint64_t):\n        data->length = sizeof(uint64_t);\n        break;\n    case 16:\n        data->length = size;\n        break;\n    default:\n        free(data);\n        PLIST_BIN_ERR(\"%s: Invalid byte size for integer node\\n\", __func__);\n        return NULL;\n    };\n\n    data->intval = UINT_TO_HOST(*bnode, size);\n\n    (*bnode) += size;\n    data->type = PLIST_UINT;\n\n    return node_create(NULL, data);\n}\n\nstatic plist_t parse_real_node(const char **bnode, uint8_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n    uint8_t buf[8];\n\n    size = 1 << size;\t\t\t// make length less misleading\n    switch (size)\n    {\n    case sizeof(uint32_t):\n        *(uint32_t*)buf = float_bswap32(*(uint32_t*)*bnode);\n        data->realval = *(float *) buf;\n        break;\n    case sizeof(uint64_t):\n        *(uint64_t*)buf = float_bswap64(*(uint64_t*)*bnode);\n        data->realval = *(double *) buf;\n        break;\n    default:\n        free(data);\n        PLIST_BIN_ERR(\"%s: Invalid byte size for real node\\n\", __func__);\n        return NULL;\n    }\n    data->type = PLIST_REAL;\n    data->length = sizeof(double);\n\n    return node_create(NULL, data);\n}\n\nstatic plist_t parse_date_node(const char **bnode, uint8_t size)\n{\n    plist_t node = parse_real_node(bnode, size);\n    plist_data_t data = plist_get_data(node);\n\n    data->type = PLIST_DATE;\n\n    return node;\n}\n\nstatic plist_t parse_string_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n\n    data->type = PLIST_STRING;\n    data->strval = (char *) malloc(sizeof(char) * (size + 1));\n    if (!data->strval) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(char) * (size + 1));\n        return NULL;\n    }\n    memcpy(data->strval, *bnode, size);\n    data->strval[size] = '\\0';\n    data->length = strlen(data->strval);\n\n    return node_create(NULL, data);\n}\n\nstatic char *plist_utf16_to_utf8(uint16_t *unistr, long len, long *items_read, long *items_written)\n{\n\tif (!unistr || (len <= 0)) return NULL;\n\tchar *outbuf;\n\tint p = 0;\n\tlong i = 0;\n\n\tuint16_t wc;\n\tuint32_t w;\n\tint read_lead_surrogate = 0;\n\n\toutbuf = (char*)malloc(4*(len+1));\n\tif (!outbuf) {\n\t\tPLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, (uint64_t)(4*(len+1)));\n\t\treturn NULL;\n\t}\n\n\twhile (i < len) {\n\t\twc = unistr[i++];\n\t\tif (wc >= 0xD800 && wc <= 0xDBFF) {\n\t\t\tif (!read_lead_surrogate) {\n\t\t\t\tread_lead_surrogate = 1;\n\t\t\t\tw = 0x010000 + ((wc & 0x3FF) << 10);\n\t\t\t} else {\n\t\t\t\t// This is invalid, the next 16 bit char should be a trail surrogate. \n\t\t\t\t// Handling error by skipping.\n\t\t\t\tread_lead_surrogate = 0;\n\t\t\t}\n\t\t} else if (wc >= 0xDC00 && wc <= 0xDFFF) {\n\t\t\tif (read_lead_surrogate) {\n\t\t\t\tread_lead_surrogate = 0;\n\t\t\t\tw = w | (wc & 0x3FF);\n\t\t\t\toutbuf[p++] = (char)(0xF0 + ((w >> 18) & 0x7));\n\t\t\t\toutbuf[p++] = (char)(0x80 + ((w >> 12) & 0x3F));\n\t\t\t\toutbuf[p++] = (char)(0x80 + ((w >> 6) & 0x3F));\n\t\t\t\toutbuf[p++] = (char)(0x80 + (w & 0x3F));\n\t\t\t} else {\n\t\t\t\t// This is invalid.  A trail surrogate should always follow a lead surrogate.\n\t\t\t\t// Handling error by skipping\n\t\t\t}\n\t\t} else if (wc >= 0x800) {\n\t\t\toutbuf[p++] = (char)(0xE0 + ((wc >> 12) & 0xF));\n\t\t\toutbuf[p++] = (char)(0x80 + ((wc >> 6) & 0x3F));\n\t\t\toutbuf[p++] = (char)(0x80 + (wc & 0x3F));\n\t\t} else if (wc >= 0x80) {\n\t\t\toutbuf[p++] = (char)(0xC0 + ((wc >> 6) & 0x1F));\n\t\t\toutbuf[p++] = (char)(0x80 + (wc & 0x3F));\n\t\t} else {\n\t\t\toutbuf[p++] = (char)(wc & 0x7F);\n\t\t}\n\t}\n\tif (items_read) {\n\t\t*items_read = i;\n\t}\n\tif (items_written) {\n\t\t*items_written = p;\n\t}\n\toutbuf[p] = 0;\n\n\treturn outbuf;\n}\n\nstatic plist_t parse_unicode_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n    uint64_t i = 0;\n    uint16_t *unicodestr = NULL;\n    char *tmpstr = NULL;\n    long items_read = 0;\n    long items_written = 0;\n\n    data->type = PLIST_STRING;\n    unicodestr = (uint16_t*) malloc(sizeof(uint16_t) * size);\n    if (!unicodestr) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(uint16_t) * size);\n        return NULL;\n    }\n    for (i = 0; i < size; i++)\n        unicodestr[i] = be16toh(((uint16_t*)*bnode)[i]);\n\n    tmpstr = plist_utf16_to_utf8(unicodestr, size, &items_read, &items_written);\n    free(unicodestr);\n    if (!tmpstr) {\n        plist_free_data(data);\n        return NULL;\n    }\n    tmpstr[items_written] = '\\0';\n\n    data->type = PLIST_STRING;\n    data->strval = realloc(tmpstr, items_written+1);\n    if (!data->strval)\n        data->strval = tmpstr;\n    data->length = items_written;\n    return node_create(NULL, data);\n}\n\nstatic plist_t parse_data_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n\n    data->type = PLIST_DATA;\n    data->length = size;\n    data->buff = (uint8_t *) malloc(sizeof(uint8_t) * size);\n    if (!data->strval) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(uint8_t) * size);\n        return NULL;\n    }\n    memcpy(data->buff, *bnode, sizeof(uint8_t) * size);\n\n    return node_create(NULL, data);\n}\n\nstatic plist_t parse_dict_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_i = 0, str_j = 0;\n    uint64_t index1, index2;\n    plist_data_t data = plist_new_plist_data();\n    const char *index1_ptr = NULL;\n    const char *index2_ptr = NULL;\n\n    data->type = PLIST_DICT;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_i = j * bplist->ref_size;\n        str_j = (j + size) * bplist->ref_size;\n        index1_ptr = (*bnode) + str_i;\n        index2_ptr = (*bnode) + str_j;\n\n        if ((index1_ptr < bplist->data || index1_ptr + bplist->ref_size > bplist->offset_table) ||\n            (index2_ptr < bplist->data || index2_ptr + bplist->ref_size > bplist->offset_table)) {\n            plist_free(node);\n            PLIST_BIN_ERR(\"%s: dict entry %\" PRIu64 \" is outside of valid range\\n\", __func__, j);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->ref_size);\n        index2 = UINT_TO_HOST(index2_ptr, bplist->ref_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            PLIST_BIN_ERR(\"%s: dict entry %\" PRIu64 \": key index (%\" PRIu64 \") must be smaller than the number of objects (%\" PRIu64 \")\\n\", __func__, j, index1, bplist->num_objects);\n            return NULL;\n        }\n        if (index2 >= bplist->num_objects) {\n            plist_free(node);\n            PLIST_BIN_ERR(\"%s: dict entry %\" PRIu64 \": value index (%\" PRIu64 \") must be smaller than the number of objects (%\" PRIu64 \")\\n\", __func__, j, index1, bplist->num_objects);\n            return NULL;\n        }\n\n        /* process key node */\n        plist_t key = parse_bin_node_at_index(bplist, index1);\n        if (!key) {\n            plist_free(node);\n            return NULL;\n        }\n\n        if (plist_get_data(key)->type != PLIST_STRING) {\n            PLIST_BIN_ERR(\"%s: dict entry %\" PRIu64 \": invalid node type for key\\n\", __func__, j);\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        /* enforce key type */\n        plist_get_data(key)->type = PLIST_KEY;\n        if (!plist_get_data(key)->strval) {\n            PLIST_BIN_ERR(\"%s: dict entry %\" PRIu64 \": key must not be NULL\\n\", __func__, j);\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index2);\n        if (!val) {\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, key);\n        node_attach(node, val);\n    }\n\n    return node;\n}\n\nstatic plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_j = 0;\n    uint64_t index1;\n    plist_data_t data = plist_new_plist_data();\n    const char *index1_ptr = NULL;\n\n    data->type = PLIST_ARRAY;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_j = j * bplist->ref_size;\n        index1_ptr = (*bnode) + str_j;\n\n        if (index1_ptr < bplist->data || index1_ptr + bplist->ref_size > bplist->offset_table) {\n            plist_free(node);\n            PLIST_BIN_ERR(\"%s: array item %\" PRIu64 \" is outside of valid range\\n\", __func__, j);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->ref_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            PLIST_BIN_ERR(\"%s: array item %\" PRIu64 \" object index (%\" PRIu64 \") must be smaller than the number of objects (%\" PRIu64 \")\\n\", __func__, j, index1, bplist->num_objects);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index1);\n        if (!val) {\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, val);\n    }\n\n    return node;\n}\n\nstatic plist_t parse_uid_node(const char **bnode, uint8_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n    size = size + 1;\n    data->intval = UINT_TO_HOST(*bnode, size);\n    if (data->intval > UINT32_MAX) {\n        PLIST_BIN_ERR(\"%s: value %\" PRIu64 \" too large for UID node (must be <= %u)\\n\", __func__, (uint64_t)data->intval, UINT32_MAX);\n        free(data);\n        return NULL;\n    }\n\n    (*bnode) += size;\n    data->type = PLIST_UID;\n    data->length = sizeof(uint64_t);\n\n    return node_create(NULL, data);\n}\n\nstatic plist_t parse_bin_node(struct bplist_data *bplist, const char** object)\n{\n    uint16_t type = 0;\n    uint64_t size = 0;\n\n    if (!object)\n        return NULL;\n\n    type = (**object) & BPLIST_MASK;\n    size = (**object) & BPLIST_FILL;\n    (*object)++;\n\n    if (size == BPLIST_FILL) {\n        switch (type) {\n        case BPLIST_DATA:\n        case BPLIST_STRING:\n        case BPLIST_UNICODE:\n        case BPLIST_ARRAY:\n        case BPLIST_SET:\n        case BPLIST_DICT:\n        {\n            uint16_t next_size = **object & BPLIST_FILL;\n            if ((**object & BPLIST_MASK) != BPLIST_UINT) {\n                PLIST_BIN_ERR(\"%s: invalid size node type for node type 0x%02x: found 0x%02x, expected 0x%02x\\n\", __func__, type, **object & BPLIST_MASK, BPLIST_UINT);\n                return NULL;\n            }\n            (*object)++;\n            next_size = 1 << next_size;\n            if (*object + next_size > bplist->offset_table) {\n                PLIST_BIN_ERR(\"%s: size node data bytes for node type 0x%02x point outside of valid range\\n\", __func__, type);\n                return NULL;\n            }\n            size = UINT_TO_HOST(*object, next_size);\n            (*object) += next_size;\n            break;\n        }\n        default:\n            break;\n        }\n    }\n\n    switch (type)\n    {\n\n    case BPLIST_NULL:\n        switch (size)\n        {\n\n        case BPLIST_TRUE:\n        {\n            plist_data_t data = plist_new_plist_data();\n            data->type = PLIST_BOOLEAN;\n            data->boolval = TRUE;\n            data->length = 1;\n            return node_create(NULL, data);\n        }\n\n        case BPLIST_FALSE:\n        {\n            plist_data_t data = plist_new_plist_data();\n            data->type = PLIST_BOOLEAN;\n            data->boolval = FALSE;\n            data->length = 1;\n            return node_create(NULL, data);\n        }\n\n        case BPLIST_NULL:\n        default:\n            return NULL;\n        }\n\n    case BPLIST_UINT:\n        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_UINT data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_uint_node(object, size);\n\n    case BPLIST_REAL:\n        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_REAL data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_real_node(object, size);\n\n    case BPLIST_DATE:\n        if (3 != size) {\n            PLIST_BIN_ERR(\"%s: invalid data size for BPLIST_DATE node\\n\", __func__);\n            return NULL;\n        }\n        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_DATE data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_date_node(object, size);\n\n    case BPLIST_DATA:\n        if (*object + size > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_DATA data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_data_node(object, size);\n\n    case BPLIST_STRING:\n        if (*object + size > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_STRING data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_string_node(object, size);\n\n    case BPLIST_UNICODE:\n        if (size*2 < size) {\n            PLIST_BIN_ERR(\"%s: Integer overflow when calculating BPLIST_UNICODE data size.\\n\", __func__);\n            return NULL;\n        }\n        if (*object + size*2 > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_UNICODE data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_unicode_node(object, size);\n\n    case BPLIST_SET:\n    case BPLIST_ARRAY:\n        if (*object + size > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_ARRAY data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_array_node(bplist, object, size);\n\n    case BPLIST_UID:\n        if (*object + size+1 > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_UID data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_uid_node(object, size);\n\n    case BPLIST_DICT:\n        if (*object + size > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_REAL data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_dict_node(bplist, object, size);\n\n    default:\n        PLIST_BIN_ERR(\"%s: unexpected node type 0x%02x\\n\", __func__, type);\n        return NULL;\n    }\n    return NULL;\n}\n\nstatic plist_t parse_bin_node_at_index(struct bplist_data *bplist, uint32_t node_index)\n{\n    int i = 0;\n    const char* ptr = NULL;\n    plist_t plist = NULL;\n    const char* idx_ptr = NULL;\n\n    if (node_index >= bplist->num_objects) {\n        PLIST_BIN_ERR(\"node index (%u) must be smaller than the number of objects (%\" PRIu64 \")\\n\", node_index, bplist->num_objects);\n        return NULL;\n    }\n\n    idx_ptr = bplist->offset_table + node_index * bplist->offset_size;\n    if (idx_ptr < bplist->offset_table ||\n        idx_ptr >= bplist->offset_table + bplist->num_objects * bplist->offset_size) {\n        PLIST_BIN_ERR(\"node index %u points outside of valid range\\n\", node_index);\n        return NULL;\n    }\n\n    ptr = bplist->data + UINT_TO_HOST(idx_ptr, bplist->offset_size);\n    /* make sure the node offset is in a sane range */\n    if ((ptr < bplist->data) || (ptr >= bplist->offset_table)) {\n        PLIST_BIN_ERR(\"offset for node index %u points outside of valid range\\n\", node_index);\n        return NULL;\n    }\n\n    /* store node_index for current recursion level */\n    if (plist_array_get_size(bplist->used_indexes) < bplist->level+1) {\n        while (plist_array_get_size(bplist->used_indexes) < bplist->level+1) {\n            plist_array_append_item(bplist->used_indexes, plist_new_uint(node_index));\n        }\n    } else {\n        plist_array_set_item(bplist->used_indexes, plist_new_uint(node_index), bplist->level);\n    }\n\n    /* recursion check */\n    if (bplist->level > 0) {\n        for (i = bplist->level-1; i >= 0; i--) {\n            plist_t node_i = plist_array_get_item(bplist->used_indexes, i);\n            plist_t node_level = plist_array_get_item(bplist->used_indexes, bplist->level);\n            if (plist_compare_node_value(node_i, node_level)) {\n                PLIST_BIN_ERR(\"recursion detected in binary plist\\n\");\n                return NULL;\n            }\n        }\n    }\n\n    /* finally parse node */\n    bplist->level++;\n    plist = parse_bin_node(bplist, &ptr);\n    bplist->level--;\n    return plist;\n}\n\nPLIST_API void plist_from_bin(const char *plist_bin, uint32_t length, plist_t * plist)\n{\n    bplist_trailer_t *trailer = NULL;\n    uint8_t offset_size = 0;\n    uint8_t ref_size = 0;\n    uint64_t num_objects = 0;\n    uint64_t root_object = 0;\n    const char *offset_table = NULL;\n    const char *start_data = NULL;\n    const char *end_data = NULL;\n\n    //first check we have enough data\n    if (!(length >= BPLIST_MAGIC_SIZE + BPLIST_VERSION_SIZE + sizeof(bplist_trailer_t))) {\n        PLIST_BIN_ERR(\"plist data is to small to hold a binary plist\\n\");\n        return;\n    }\n    //check that plist_bin in actually a plist\n    if (memcmp(plist_bin, BPLIST_MAGIC, BPLIST_MAGIC_SIZE) != 0) {\n        PLIST_BIN_ERR(\"bplist magic mismatch\\n\");\n        return;\n    }\n    //check for known version\n    if (memcmp(plist_bin + BPLIST_MAGIC_SIZE, BPLIST_VERSION, BPLIST_VERSION_SIZE) != 0) {\n        PLIST_BIN_ERR(\"unsupported binary plist version '%.2s\\n\", plist_bin+BPLIST_MAGIC_SIZE);\n        return;\n    }\n\n    start_data = plist_bin + BPLIST_MAGIC_SIZE + BPLIST_VERSION_SIZE;\n    end_data = plist_bin + length - sizeof(bplist_trailer_t);\n\n    //now parse trailer\n    trailer = (bplist_trailer_t*)end_data;\n\n    offset_size = trailer->offset_size;\n    ref_size = trailer->ref_size;\n    num_objects = be64toh(trailer->num_objects);\n    root_object = be64toh(trailer->root_object_index);\n    offset_table = (char *)(plist_bin + be64toh(trailer->offset_table_offset));\n\n    if (num_objects == 0) {\n        PLIST_BIN_ERR(\"number of objects must be larger than 0\\n\");\n        return;\n    }\n\n    if (offset_size == 0) {\n        PLIST_BIN_ERR(\"offset size in trailer must be larger than 0\\n\");\n        return;\n    }\n\n    if (ref_size == 0) {\n        PLIST_BIN_ERR(\"object reference size in trailer must be larger than 0\\n\");\n        return;\n    }\n\n    if (root_object >= num_objects) {\n        PLIST_BIN_ERR(\"root object index (%\" PRIu64 \") must be smaller than number of objects (%\" PRIu64 \")\\n\", root_object, num_objects);\n        return;\n    }\n\n    if (offset_table < start_data || offset_table >= end_data) {\n        PLIST_BIN_ERR(\"offset table offset points outside of valid range\\n\");\n        return;\n    }\n\n    if (num_objects * offset_size < num_objects) {\n        PLIST_BIN_ERR(\"integer overflow when calculating offset table size (too many objects)\\n\");\n        return;\n    }\n\n    if (offset_table + num_objects * offset_size > end_data) {\n        PLIST_BIN_ERR(\"offset table points outside of valid range\\n\");\n        return;\n    }\n\n    struct bplist_data bplist;\n    bplist.data = plist_bin;\n    bplist.size = length;\n    bplist.num_objects = num_objects;\n    bplist.ref_size = ref_size;\n    bplist.offset_size = offset_size;\n    bplist.offset_table = offset_table;\n    bplist.level = 0;\n    bplist.used_indexes = plist_new_array();\n\n    if (!bplist.used_indexes) {\n        PLIST_BIN_ERR(\"failed to create array to hold used node indexes. Out of memory?\\n\");\n        return;\n    }\n\n    *plist = parse_bin_node_at_index(&bplist, root_object);\n\n    plist_free(bplist.used_indexes);\n}\n\nstatic unsigned int plist_data_hash(const void* key)\n{\n    plist_data_t data = plist_get_data((plist_t) key);\n\n    unsigned int hash = data->type;\n    unsigned int i = 0;\n\n    char *buff = NULL;\n    unsigned int size = 0;\n\n    switch (data->type)\n    {\n    case PLIST_BOOLEAN:\n    case PLIST_UINT:\n    case PLIST_REAL:\n    case PLIST_DATE:\n    case PLIST_UID:\n        buff = (char *) &data->intval;\t//works also for real as we use an union\n        size = 8;\n        break;\n    case PLIST_KEY:\n    case PLIST_STRING:\n        buff = data->strval;\n        size = data->length;\n        break;\n    case PLIST_DATA:\n    case PLIST_ARRAY:\n    case PLIST_DICT:\n        //for these types only hash pointer\n        buff = (char *) &key;\n        size = sizeof(const void*);\n        break;\n    default:\n        break;\n    }\n\n    // now perform hash using djb2 hashing algorithm\n    // see: http://www.cse.yorku.ca/~oz/hash.html\n    hash += 5381;\n    for (i = 0; i < size; buff++, i++) {\n        hash = ((hash << 5) + hash) + *buff;\n    }\n\n    return hash;\n}\n\nstruct serialize_s\n{\n    ptrarray_t* objects;\n    hashtable_t* ref_table;\n};\n\nstatic void serialize_plist(node_t* node, void* data)\n{\n    uint64_t *index_val = NULL;\n    struct serialize_s *ser = (struct serialize_s *) data;\n    uint64_t current_index = ser->objects->len;\n\n    //first check that node is not yet in objects\n    void* val = hash_table_lookup(ser->ref_table, node);\n    if (val)\n    {\n        //data is already in table\n        return;\n    }\n    //insert new ref\n    index_val = (uint64_t *) malloc(sizeof(uint64_t));\n    assert(index_val != NULL);\n    *index_val = current_index;\n    hash_table_insert(ser->ref_table, node, index_val);\n\n    //now append current node to object array\n    ptr_array_add(ser->objects, node);\n\n    //now recurse on children\n    node_iterator_t *ni = node_iterator_create(node->children);\n    node_t *ch;\n    while ((ch = node_iterator_next(ni))) {\n        serialize_plist(ch, data);\n    }\n    node_iterator_destroy(ni);\n\n    return;\n}\n\n#define Log2(x) (x == 8 ? 3 : (x == 4 ? 2 : (x == 2 ? 1 : 0)))\n\nstatic void write_int(bytearray_t * bplist, uint64_t val)\n{\n    int size = get_needed_bytes(val);\n    uint8_t sz;\n    //do not write 3bytes int node\n    if (size == 3)\n        size++;\n    sz = BPLIST_UINT | Log2(size);\n\n    val = be64toh(val);\n    byte_array_append(bplist, &sz, 1);\n    byte_array_append(bplist, (uint8_t*)&val + (8-size), size);\n}\n\nstatic void write_uint(bytearray_t * bplist, uint64_t val)\n{\n    uint8_t sz = BPLIST_UINT | 4;\n    uint64_t zero = 0;\n\n    val = be64toh(val);\n    byte_array_append(bplist, &sz, 1);\n    byte_array_append(bplist, &zero, sizeof(uint64_t));\n    byte_array_append(bplist, &val, sizeof(uint64_t));\n}\n\nstatic void write_real(bytearray_t * bplist, double val)\n{\n    int size = get_real_bytes(val);\t//cheat to know used space\n    uint8_t buff[9];\n    buff[0] = BPLIST_REAL | Log2(size);\n    if (size == sizeof(float)) {\n        float floatval = (float)val;\n        *(uint32_t*)(buff+1) = float_bswap32(*(uint32_t*)&floatval);\n    } else {\n        *(uint64_t*)(buff+1) = float_bswap64(*(uint64_t*)&val);\n    }\n    byte_array_append(bplist, buff, size+1);\n}\n\nstatic void write_date(bytearray_t * bplist, double val)\n{\n    uint8_t buff[9];\n    buff[0] = BPLIST_DATE | 3;\n    *(uint64_t*)(buff+1) = float_bswap64(*(uint64_t*)&val);\n    byte_array_append(bplist, buff, sizeof(buff));\n}\n\nstatic void write_raw_data(bytearray_t * bplist, uint8_t mark, uint8_t * val, uint64_t size)\n{\n    uint8_t marker = mark | (size < 15 ? size : 0xf);\n    byte_array_append(bplist, &marker, sizeof(uint8_t));\n    if (size >= 15) {\n        write_int(bplist, size);\n    }\n    if (BPLIST_UNICODE==mark) size <<= 1;\n    byte_array_append(bplist, val, size);\n}\n\nstatic void write_data(bytearray_t * bplist, uint8_t * val, uint64_t size)\n{\n    write_raw_data(bplist, BPLIST_DATA, val, size);\n}\n\nstatic void write_string(bytearray_t * bplist, char *val)\n{\n    uint64_t size = strlen(val);\n    write_raw_data(bplist, BPLIST_STRING, (uint8_t *) val, size);\n}\n\nstatic void write_unicode(bytearray_t * bplist, uint16_t * val, uint64_t size)\n{\n    uint64_t i = 0;\n    uint16_t *buff = (uint16_t*)malloc(size << 1);\n    for (i = 0; i < size; i++)\n        buff[i] = be16toh(val[i]);\n    write_raw_data(bplist, BPLIST_UNICODE, (uint8_t*)buff, size);\n    free(buff);\n}\n\nstatic void write_array(bytearray_t * bplist, node_t* node, hashtable_t* ref_table, uint8_t ref_size)\n{\n    node_t* cur = NULL;\n    uint64_t i = 0;\n\n    uint64_t size = node_n_children(node);\n    uint8_t marker = BPLIST_ARRAY | (size < 15 ? size : 0xf);\n    byte_array_append(bplist, &marker, sizeof(uint8_t));\n    if (size >= 15) {\n        write_int(bplist, size);\n    }\n\n    for (i = 0, cur = node_first_child(node); cur && i < size; cur = node_next_sibling(cur), i++) {\n        uint64_t idx = *(uint64_t *) (hash_table_lookup(ref_table, cur));\n        idx = be64toh(idx);\n        byte_array_append(bplist, (uint8_t*)&idx + (sizeof(uint64_t) - ref_size), ref_size);\n    }\n}\n\nstatic void write_dict(bytearray_t * bplist, node_t* node, hashtable_t* ref_table, uint8_t ref_size)\n{\n    node_t* cur = NULL;\n    uint64_t i = 0;\n\n    uint64_t size = node_n_children(node) / 2;\n    uint8_t marker = BPLIST_DICT | (size < 15 ? size : 0xf);\n    byte_array_append(bplist, &marker, sizeof(uint8_t));\n    if (size >= 15) {\n        write_int(bplist, size);\n    }\n\n    for (i = 0, cur = node_first_child(node); cur && i < size; cur = node_next_sibling(node_next_sibling(cur)), i++) {\n        uint64_t idx1 = *(uint64_t *) (hash_table_lookup(ref_table, cur));\n        idx1 = be64toh(idx1);\n        byte_array_append(bplist, (uint8_t*)&idx1 + (sizeof(uint64_t) - ref_size), ref_size);\n    }\n\n    for (i = 0, cur = node_first_child(node); cur && i < size; cur = node_next_sibling(node_next_sibling(cur)), i++) {\n        uint64_t idx2 = *(uint64_t *) (hash_table_lookup(ref_table, cur->next));\n        idx2 = be64toh(idx2);\n        byte_array_append(bplist, (uint8_t*)&idx2 + (sizeof(uint64_t) - ref_size), ref_size);\n    }\n}\n\nstatic void write_uid(bytearray_t * bplist, uint64_t val)\n{\n    val = (uint32_t)val;\n    int size = get_needed_bytes(val);\n    uint8_t sz;\n    //do not write 3bytes int node\n    if (size == 3)\n        size++;\n    sz = BPLIST_UID | (size-1); // yes, this is what Apple does...\n\n    val = be64toh(val);\n    byte_array_append(bplist, &sz, 1);\n    byte_array_append(bplist, (uint8_t*)&val + (8-size), size);\n}\n\nstatic int is_ascii_string(char* s, int len)\n{\n  int ret = 1, i = 0;\n  for(i = 0; i < len; i++)\n  {\n      if ( !isascii( s[i] ) )\n      {\n          ret = 0;\n          break;\n      }\n  }\n  return ret;\n}\n\nstatic uint16_t *plist_utf8_to_utf16(char *unistr, long size, long *items_read, long *items_written)\n{\n\tuint16_t *outbuf;\n\tint p = 0;\n\tlong i = 0;\n\n\tunsigned char c0;\n\tunsigned char c1;\n\tunsigned char c2;\n\tunsigned char c3;\n\n\tuint32_t w;\n\n\toutbuf = (uint16_t*)malloc(((size*2)+1)*sizeof(uint16_t));\n\tif (!outbuf) {\n\t\tPLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, (uint64_t)((size*2)+1)*sizeof(uint16_t));\n\t\treturn NULL;\n\t}\n\n\twhile (i < size) {\n\t\tc0 = unistr[i];\n\t\tc1 = (i < size-1) ? unistr[i+1] : 0;\n\t\tc2 = (i < size-2) ? unistr[i+2] : 0;\n\t\tc3 = (i < size-3) ? unistr[i+3] : 0;\n\t\tif ((c0 >= 0xF0) && (i < size-3) && (c1 >= 0x80) && (c2 >= 0x80) && (c3 >= 0x80)) {\n\t\t\t// 4 byte sequence.  Need to generate UTF-16 surrogate pair\n\t\t\tw = ((((c0 & 7) << 18) + ((c1 & 0x3F) << 12) + ((c2 & 0x3F) << 6) + (c3 & 0x3F)) & 0x1FFFFF) - 0x010000;\n\t\t\toutbuf[p++] = 0xD800 + (w >> 10);\n\t\t\toutbuf[p++] = 0xDC00 + (w & 0x3FF);\n\t\t\ti+=4;\n\t\t} else if ((c0 >= 0xE0) && (i < size-2) && (c1 >= 0x80) && (c2 >= 0x80)) {\n\t\t\t// 3 byte sequence\n\t\t\toutbuf[p++] = ((c2 & 0x3F) + ((c1 & 3) << 6)) + (((c1 >> 2) & 15) << 8) + ((c0 & 15) << 12);\n\t\t\ti+=3;\n\t\t} else if ((c0 >= 0xC0) && (i < size-1) && (c1 >= 0x80)) {\n\t\t\t// 2 byte sequence\n\t\t\toutbuf[p++] = ((c1 & 0x3F) + ((c0 & 3) << 6)) + (((c0 >> 2) & 7) << 8);\n\t\t\ti+=2;\n\t\t} else if (c0 < 0x80) {\n\t\t\t// 1 byte sequence\n\t\t\toutbuf[p++] = c0;\n\t\t\ti+=1;\n\t\t} else {\n\t\t\t// invalid character\n\t\t\tPLIST_BIN_ERR(\"%s: invalid utf8 sequence in string at index %lu\\n\", __func__, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (items_read) {\n\t\t*items_read = i;\n\t}\n\tif (items_written) {\n\t\t*items_written = p;\n\t}\n\toutbuf[p] = 0;\n\n\treturn outbuf;\n\n}\n\nPLIST_API void plist_to_bin(plist_t plist, char **plist_bin, uint32_t * length)\n{\n    ptrarray_t* objects = NULL;\n    hashtable_t* ref_table = NULL;\n    struct serialize_s ser_s;\n    uint8_t offset_size = 0;\n    uint8_t ref_size = 0;\n    uint64_t num_objects = 0;\n    uint64_t root_object = 0;\n    uint64_t offset_table_index = 0;\n    bytearray_t *bplist_buff = NULL;\n    uint64_t i = 0;\n    uint8_t *buff = NULL;\n    uint64_t *offsets = NULL;\n    bplist_trailer_t trailer;\n    //for string\n    long len = 0;\n    long items_read = 0;\n    long items_written = 0;\n    uint16_t *unicodestr = NULL;\n    uint64_t objects_len = 0;\n    uint64_t buff_len = 0;\n\n    //check for valid input\n    if (!plist || !plist_bin || *plist_bin || !length)\n        return;\n\n    //list of objects\n    objects = ptr_array_new(256);\n    //hashtable to write only once same nodes\n    ref_table = hash_table_new(plist_data_hash, plist_data_compare, free);\n\n    //serialize plist\n    ser_s.objects = objects;\n    ser_s.ref_table = ref_table;\n    serialize_plist(plist, &ser_s);\n\n    //now stream to output buffer\n    offset_size = 0;\t\t\t//unknown yet\n    objects_len = objects->len;\n    ref_size = get_needed_bytes(objects_len);\n    num_objects = objects->len;\n    root_object = 0;\t\t\t//root is first in list\n    offset_table_index = 0;\t\t//unknown yet\n\n    //setup a dynamic bytes array to store bplist in\n    bplist_buff = byte_array_new();\n\n    //set magic number and version\n    byte_array_append(bplist_buff, BPLIST_MAGIC, BPLIST_MAGIC_SIZE);\n    byte_array_append(bplist_buff, BPLIST_VERSION, BPLIST_VERSION_SIZE);\n\n    //write objects and table\n    offsets = (uint64_t *) malloc(num_objects * sizeof(uint64_t));\n    assert(offsets != NULL);\n    for (i = 0; i < num_objects; i++)\n    {\n\n        plist_data_t data = plist_get_data(ptr_array_index(objects, i));\n        offsets[i] = bplist_buff->len;\n\n        switch (data->type)\n        {\n        case PLIST_BOOLEAN:\n            buff = (uint8_t *) malloc(sizeof(uint8_t));\n            buff[0] = data->boolval ? BPLIST_TRUE : BPLIST_FALSE;\n            byte_array_append(bplist_buff, buff, sizeof(uint8_t));\n            free(buff);\n            break;\n\n        case PLIST_UINT:\n            if (data->length == 16) {\n                write_uint(bplist_buff, data->intval);\n            } else {\n                write_int(bplist_buff, data->intval);\n            }\n            break;\n\n        case PLIST_REAL:\n            write_real(bplist_buff, data->realval);\n            break;\n\n        case PLIST_KEY:\n        case PLIST_STRING:\n            len = strlen(data->strval);\n            if ( is_ascii_string(data->strval, len) )\n            {\n                write_string(bplist_buff, data->strval);\n            }\n            else\n            {\n                unicodestr = plist_utf8_to_utf16(data->strval, len, &items_read, &items_written);\n                write_unicode(bplist_buff, unicodestr, items_written);\n                free(unicodestr);\n            }\n            break;\n        case PLIST_DATA:\n            write_data(bplist_buff, data->buff, data->length);\n        case PLIST_ARRAY:\n            write_array(bplist_buff, ptr_array_index(objects, i), ref_table, ref_size);\n            break;\n        case PLIST_DICT:\n            write_dict(bplist_buff, ptr_array_index(objects, i), ref_table, ref_size);\n            break;\n        case PLIST_DATE:\n            write_date(bplist_buff, data->realval);\n            break;\n        case PLIST_UID:\n            write_uid(bplist_buff, data->intval);\n            break;\n        default:\n            break;\n        }\n    }\n\n    //free intermediate objects\n    ptr_array_free(objects);\n    hash_table_destroy(ref_table);\n\n    //write offsets\n    buff_len = bplist_buff->len;\n    offset_size = get_needed_bytes(buff_len);\n    offset_table_index = bplist_buff->len;\n    for (i = 0; i < num_objects; i++) {\n        uint64_t offset = be64toh(offsets[i]);\n        byte_array_append(bplist_buff, (uint8_t*)&offset + (sizeof(uint64_t) - offset_size), offset_size);\n    }\n    free(offsets);\n\n    //setup trailer\n    memset(trailer.unused, '\\0', sizeof(trailer.unused));\n    trailer.offset_size = offset_size;\n    trailer.ref_size = ref_size;\n    trailer.num_objects = be64toh(num_objects);\n    trailer.root_object_index = be64toh(root_object);\n    trailer.offset_table_offset = be64toh(offset_table_index);\n\n    byte_array_append(bplist_buff, &trailer, sizeof(bplist_trailer_t));\n\n    //set output buffer and size\n    *plist_bin = bplist_buff->data;\n    *length = bplist_buff->len;\n\n    bplist_buff->data = NULL; // make sure we don't free the output buffer\n    byte_array_free(bplist_buff);\n}\n"], "fixing_code": ["/*\n * bplist.c\n * Binary plist implementation\n *\n * Copyright (c) 2011-2017 Nikias Bassen, All Rights Reserved.\n * Copyright (c) 2008-2010 Jonathan Beck, All Rights Reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include <ctype.h>\n#include <inttypes.h>\n\n#include <plist/plist.h>\n#include \"plist.h\"\n#include \"hashtable.h\"\n#include \"bytearray.h\"\n#include \"ptrarray.h\"\n\n#include <node.h>\n#include <node_iterator.h>\n\n/* Magic marker and size. */\n#define BPLIST_MAGIC            ((uint8_t*)\"bplist\")\n#define BPLIST_MAGIC_SIZE       6\n\n#define BPLIST_VERSION          ((uint8_t*)\"00\")\n#define BPLIST_VERSION_SIZE     2\n\ntypedef struct __attribute__((packed)) {\n    uint8_t unused[6];\n    uint8_t offset_size;\n    uint8_t ref_size;\n    uint64_t num_objects;\n    uint64_t root_object_index;\n    uint64_t offset_table_offset;\n} bplist_trailer_t;\n\nenum\n{\n    BPLIST_NULL = 0x00,\n    BPLIST_FALSE = 0x08,\n    BPLIST_TRUE = 0x09,\n    BPLIST_FILL = 0x0F,\t\t\t/* will be used for length grabbing */\n    BPLIST_UINT = 0x10,\n    BPLIST_REAL = 0x20,\n    BPLIST_DATE = 0x30,\n    BPLIST_DATA = 0x40,\n    BPLIST_STRING = 0x50,\n    BPLIST_UNICODE = 0x60,\n    BPLIST_UNK_0x70 = 0x70,\n    BPLIST_UID = 0x80,\n    BPLIST_ARRAY = 0xA0,\n    BPLIST_SET = 0xC0,\n    BPLIST_DICT = 0xD0,\n    BPLIST_MASK = 0xF0\n};\n\nunion plist_uint_ptr\n{\n    const void *src;\n    uint8_t *u8ptr;\n    uint16_t *u16ptr;\n    uint32_t *u32ptr;\n    uint64_t *u64ptr;\n};\n\n#define get_unaligned(ptr)\t\t\t  \\\n  ({                                              \\\n    struct __attribute__((packed)) {\t\t  \\\n      typeof(*(ptr)) __v;\t\t\t  \\\n    } *__p = (void *) (ptr);\t\t\t  \\\n    __p->__v;\t\t\t\t\t  \\\n  })\n\n\n#ifndef bswap16\n#define bswap16(x)   ((((x) & 0xFF00) >> 8) | (((x) & 0x00FF) << 8))\n#endif\n\n#ifndef bswap32\n#define bswap32(x)   ((((x) & 0xFF000000) >> 24) \\\n                    | (((x) & 0x00FF0000) >>  8) \\\n                    | (((x) & 0x0000FF00) <<  8) \\\n                    | (((x) & 0x000000FF) << 24))\n#endif\n\n#ifndef bswap64\n#define bswap64(x)   ((((x) & 0xFF00000000000000ull) >> 56) \\\n                    | (((x) & 0x00FF000000000000ull) >> 40) \\\n                    | (((x) & 0x0000FF0000000000ull) >> 24) \\\n                    | (((x) & 0x000000FF00000000ull) >>  8) \\\n                    | (((x) & 0x00000000FF000000ull) <<  8) \\\n                    | (((x) & 0x0000000000FF0000ull) << 24) \\\n                    | (((x) & 0x000000000000FF00ull) << 40) \\\n                    | (((x) & 0x00000000000000FFull) << 56))\n#endif\n\n#ifndef be16toh\n#ifdef __BIG_ENDIAN__\n#define be16toh(x) (x)\n#else\n#define be16toh(x) bswap16(x)\n#endif\n#endif\n\n#ifndef be32toh\n#ifdef __BIG_ENDIAN__\n#define be32toh(x) (x)\n#else\n#define be32toh(x) bswap32(x)\n#endif\n#endif\n\n#ifndef be64toh\n#ifdef __BIG_ENDIAN__\n#define be64toh(x) (x)\n#else\n#define be64toh(x) bswap64(x)\n#endif\n#endif\n\n#ifdef __BIG_ENDIAN__\n#define beNtoh(x,n) (x >> ((8-n) << 3))\n#else\n#define beNtoh(x,n) be64toh(x << ((8-n) << 3))\n#endif\n\n#define UINT_TO_HOST(x, n) \\\n\t({ \\\n\t\tunion plist_uint_ptr __up; \\\n\t\t__up.src = (n > 8) ? x + (n - 8) : x; \\\n\t\t(n >= 8 ? be64toh( get_unaligned(__up.u64ptr) ) : \\\n\t\t(n == 4 ? be32toh( get_unaligned(__up.u32ptr) ) : \\\n\t\t(n == 2 ? be16toh( get_unaligned(__up.u16ptr) ) : \\\n                (n == 1 ? *__up.u8ptr : \\\n\t\tbeNtoh( get_unaligned(__up.u64ptr), n) \\\n\t\t)))); \\\n\t})\n\n#define get_needed_bytes(x) \\\n\t\t( ((uint64_t)x) < (1ULL << 8) ? 1 : \\\n\t\t( ((uint64_t)x) < (1ULL << 16) ? 2 : \\\n\t\t( ((uint64_t)x) < (1ULL << 24) ? 3 : \\\n\t\t( ((uint64_t)x) < (1ULL << 32) ? 4 : 8))))\n\n#define get_real_bytes(x) (x == (float) x ? sizeof(float) : sizeof(double))\n\n#if (defined(__LITTLE_ENDIAN__) \\\n     && !defined(__FLOAT_WORD_ORDER__)) \\\n || (defined(__FLOAT_WORD_ORDER__) \\\n     && __FLOAT_WORD_ORDER__ == __ORDER_LITTLE_ENDIAN__)\n#define float_bswap64(x) bswap64(x)\n#define float_bswap32(x) bswap32(x)\n#else\n#define float_bswap64(x) (x)\n#define float_bswap32(x) (x)\n#endif\n\n\n#define NODE_IS_ROOT(x) (((node_t*)x)->isRoot)\n\nstruct bplist_data {\n    const char* data;\n    uint64_t size;\n    uint64_t num_objects;\n    uint8_t ref_size;\n    uint8_t offset_size;\n    const char* offset_table;\n    uint32_t level;\n    plist_t used_indexes;\n};\n\n#ifdef DEBUG\nstatic int plist_bin_debug = 0;\n#define PLIST_BIN_ERR(...) if (plist_bin_debug) { fprintf(stderr, \"libplist[binparser] ERROR: \" __VA_ARGS__); }\n#else\n#define PLIST_BIN_ERR(...)\n#endif\n\nvoid plist_bin_init(void)\n{\n    /* init binary plist stuff */\n#ifdef DEBUG\n    char *env_debug = getenv(\"PLIST_BIN_DEBUG\");\n    if (env_debug && !strcmp(env_debug, \"1\")) {\n        plist_bin_debug = 1;\n    }\n#endif\n}\n\nvoid plist_bin_deinit(void)\n{\n    /* deinit binary plist stuff */\n}\n\nstatic plist_t parse_bin_node_at_index(struct bplist_data *bplist, uint32_t node_index);\n\nstatic plist_t parse_uint_node(const char **bnode, uint8_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n\n    size = 1 << size;\t\t\t// make length less misleading\n    switch (size)\n    {\n    case sizeof(uint8_t):\n    case sizeof(uint16_t):\n    case sizeof(uint32_t):\n    case sizeof(uint64_t):\n        data->length = sizeof(uint64_t);\n        break;\n    case 16:\n        data->length = size;\n        break;\n    default:\n        free(data);\n        PLIST_BIN_ERR(\"%s: Invalid byte size for integer node\\n\", __func__);\n        return NULL;\n    };\n\n    data->intval = UINT_TO_HOST(*bnode, size);\n\n    (*bnode) += size;\n    data->type = PLIST_UINT;\n\n    return node_create(NULL, data);\n}\n\nstatic plist_t parse_real_node(const char **bnode, uint8_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n    uint8_t buf[8];\n\n    size = 1 << size;\t\t\t// make length less misleading\n    switch (size)\n    {\n    case sizeof(uint32_t):\n        *(uint32_t*)buf = float_bswap32(*(uint32_t*)*bnode);\n        data->realval = *(float *) buf;\n        break;\n    case sizeof(uint64_t):\n        *(uint64_t*)buf = float_bswap64(*(uint64_t*)*bnode);\n        data->realval = *(double *) buf;\n        break;\n    default:\n        free(data);\n        PLIST_BIN_ERR(\"%s: Invalid byte size for real node\\n\", __func__);\n        return NULL;\n    }\n    data->type = PLIST_REAL;\n    data->length = sizeof(double);\n\n    return node_create(NULL, data);\n}\n\nstatic plist_t parse_date_node(const char **bnode, uint8_t size)\n{\n    plist_t node = parse_real_node(bnode, size);\n    plist_data_t data = plist_get_data(node);\n\n    data->type = PLIST_DATE;\n\n    return node;\n}\n\nstatic plist_t parse_string_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n\n    data->type = PLIST_STRING;\n    data->strval = (char *) malloc(sizeof(char) * (size + 1));\n    if (!data->strval) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(char) * (size + 1));\n        return NULL;\n    }\n    memcpy(data->strval, *bnode, size);\n    data->strval[size] = '\\0';\n    data->length = strlen(data->strval);\n\n    return node_create(NULL, data);\n}\n\nstatic char *plist_utf16_to_utf8(uint16_t *unistr, long len, long *items_read, long *items_written)\n{\n\tif (!unistr || (len <= 0)) return NULL;\n\tchar *outbuf;\n\tint p = 0;\n\tlong i = 0;\n\n\tuint16_t wc;\n\tuint32_t w;\n\tint read_lead_surrogate = 0;\n\n\toutbuf = (char*)malloc(4*(len+1));\n\tif (!outbuf) {\n\t\tPLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, (uint64_t)(4*(len+1)));\n\t\treturn NULL;\n\t}\n\n\twhile (i < len) {\n\t\twc = unistr[i++];\n\t\tif (wc >= 0xD800 && wc <= 0xDBFF) {\n\t\t\tif (!read_lead_surrogate) {\n\t\t\t\tread_lead_surrogate = 1;\n\t\t\t\tw = 0x010000 + ((wc & 0x3FF) << 10);\n\t\t\t} else {\n\t\t\t\t// This is invalid, the next 16 bit char should be a trail surrogate. \n\t\t\t\t// Handling error by skipping.\n\t\t\t\tread_lead_surrogate = 0;\n\t\t\t}\n\t\t} else if (wc >= 0xDC00 && wc <= 0xDFFF) {\n\t\t\tif (read_lead_surrogate) {\n\t\t\t\tread_lead_surrogate = 0;\n\t\t\t\tw = w | (wc & 0x3FF);\n\t\t\t\toutbuf[p++] = (char)(0xF0 + ((w >> 18) & 0x7));\n\t\t\t\toutbuf[p++] = (char)(0x80 + ((w >> 12) & 0x3F));\n\t\t\t\toutbuf[p++] = (char)(0x80 + ((w >> 6) & 0x3F));\n\t\t\t\toutbuf[p++] = (char)(0x80 + (w & 0x3F));\n\t\t\t} else {\n\t\t\t\t// This is invalid.  A trail surrogate should always follow a lead surrogate.\n\t\t\t\t// Handling error by skipping\n\t\t\t}\n\t\t} else if (wc >= 0x800) {\n\t\t\toutbuf[p++] = (char)(0xE0 + ((wc >> 12) & 0xF));\n\t\t\toutbuf[p++] = (char)(0x80 + ((wc >> 6) & 0x3F));\n\t\t\toutbuf[p++] = (char)(0x80 + (wc & 0x3F));\n\t\t} else if (wc >= 0x80) {\n\t\t\toutbuf[p++] = (char)(0xC0 + ((wc >> 6) & 0x1F));\n\t\t\toutbuf[p++] = (char)(0x80 + (wc & 0x3F));\n\t\t} else {\n\t\t\toutbuf[p++] = (char)(wc & 0x7F);\n\t\t}\n\t}\n\tif (items_read) {\n\t\t*items_read = i;\n\t}\n\tif (items_written) {\n\t\t*items_written = p;\n\t}\n\toutbuf[p] = 0;\n\n\treturn outbuf;\n}\n\nstatic plist_t parse_unicode_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n    uint64_t i = 0;\n    uint16_t *unicodestr = NULL;\n    char *tmpstr = NULL;\n    long items_read = 0;\n    long items_written = 0;\n\n    data->type = PLIST_STRING;\n    unicodestr = (uint16_t*) malloc(sizeof(uint16_t) * size);\n    if (!unicodestr) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(uint16_t) * size);\n        return NULL;\n    }\n    for (i = 0; i < size; i++)\n        unicodestr[i] = be16toh(((uint16_t*)*bnode)[i]);\n\n    tmpstr = plist_utf16_to_utf8(unicodestr, size, &items_read, &items_written);\n    free(unicodestr);\n    if (!tmpstr) {\n        plist_free_data(data);\n        return NULL;\n    }\n    tmpstr[items_written] = '\\0';\n\n    data->type = PLIST_STRING;\n    data->strval = realloc(tmpstr, items_written+1);\n    if (!data->strval)\n        data->strval = tmpstr;\n    data->length = items_written;\n    return node_create(NULL, data);\n}\n\nstatic plist_t parse_data_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n\n    data->type = PLIST_DATA;\n    data->length = size;\n    data->buff = (uint8_t *) malloc(sizeof(uint8_t) * size);\n    if (!data->strval) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(uint8_t) * size);\n        return NULL;\n    }\n    memcpy(data->buff, *bnode, sizeof(uint8_t) * size);\n\n    return node_create(NULL, data);\n}\n\nstatic plist_t parse_dict_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_i = 0, str_j = 0;\n    uint64_t index1, index2;\n    plist_data_t data = plist_new_plist_data();\n    const char *index1_ptr = NULL;\n    const char *index2_ptr = NULL;\n\n    data->type = PLIST_DICT;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_i = j * bplist->ref_size;\n        str_j = (j + size) * bplist->ref_size;\n        index1_ptr = (*bnode) + str_i;\n        index2_ptr = (*bnode) + str_j;\n\n        if ((index1_ptr < bplist->data || index1_ptr + bplist->ref_size > bplist->offset_table) ||\n            (index2_ptr < bplist->data || index2_ptr + bplist->ref_size > bplist->offset_table)) {\n            plist_free(node);\n            PLIST_BIN_ERR(\"%s: dict entry %\" PRIu64 \" is outside of valid range\\n\", __func__, j);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->ref_size);\n        index2 = UINT_TO_HOST(index2_ptr, bplist->ref_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            PLIST_BIN_ERR(\"%s: dict entry %\" PRIu64 \": key index (%\" PRIu64 \") must be smaller than the number of objects (%\" PRIu64 \")\\n\", __func__, j, index1, bplist->num_objects);\n            return NULL;\n        }\n        if (index2 >= bplist->num_objects) {\n            plist_free(node);\n            PLIST_BIN_ERR(\"%s: dict entry %\" PRIu64 \": value index (%\" PRIu64 \") must be smaller than the number of objects (%\" PRIu64 \")\\n\", __func__, j, index1, bplist->num_objects);\n            return NULL;\n        }\n\n        /* process key node */\n        plist_t key = parse_bin_node_at_index(bplist, index1);\n        if (!key) {\n            plist_free(node);\n            return NULL;\n        }\n\n        if (plist_get_data(key)->type != PLIST_STRING) {\n            PLIST_BIN_ERR(\"%s: dict entry %\" PRIu64 \": invalid node type for key\\n\", __func__, j);\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        /* enforce key type */\n        plist_get_data(key)->type = PLIST_KEY;\n        if (!plist_get_data(key)->strval) {\n            PLIST_BIN_ERR(\"%s: dict entry %\" PRIu64 \": key must not be NULL\\n\", __func__, j);\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index2);\n        if (!val) {\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, key);\n        node_attach(node, val);\n    }\n\n    return node;\n}\n\nstatic plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_j = 0;\n    uint64_t index1;\n    plist_data_t data = plist_new_plist_data();\n    const char *index1_ptr = NULL;\n\n    data->type = PLIST_ARRAY;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_j = j * bplist->ref_size;\n        index1_ptr = (*bnode) + str_j;\n\n        if (index1_ptr < bplist->data || index1_ptr + bplist->ref_size > bplist->offset_table) {\n            plist_free(node);\n            PLIST_BIN_ERR(\"%s: array item %\" PRIu64 \" is outside of valid range\\n\", __func__, j);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->ref_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            PLIST_BIN_ERR(\"%s: array item %\" PRIu64 \" object index (%\" PRIu64 \") must be smaller than the number of objects (%\" PRIu64 \")\\n\", __func__, j, index1, bplist->num_objects);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index1);\n        if (!val) {\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, val);\n    }\n\n    return node;\n}\n\nstatic plist_t parse_uid_node(const char **bnode, uint8_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n    size = size + 1;\n    data->intval = UINT_TO_HOST(*bnode, size);\n    if (data->intval > UINT32_MAX) {\n        PLIST_BIN_ERR(\"%s: value %\" PRIu64 \" too large for UID node (must be <= %u)\\n\", __func__, (uint64_t)data->intval, UINT32_MAX);\n        free(data);\n        return NULL;\n    }\n\n    (*bnode) += size;\n    data->type = PLIST_UID;\n    data->length = sizeof(uint64_t);\n\n    return node_create(NULL, data);\n}\n\nstatic plist_t parse_bin_node(struct bplist_data *bplist, const char** object)\n{\n    uint16_t type = 0;\n    uint64_t size = 0;\n\n    if (!object)\n        return NULL;\n\n    type = (**object) & BPLIST_MASK;\n    size = (**object) & BPLIST_FILL;\n    (*object)++;\n\n    if (size == BPLIST_FILL) {\n        switch (type) {\n        case BPLIST_DATA:\n        case BPLIST_STRING:\n        case BPLIST_UNICODE:\n        case BPLIST_ARRAY:\n        case BPLIST_SET:\n        case BPLIST_DICT:\n        {\n            uint16_t next_size = **object & BPLIST_FILL;\n            if ((**object & BPLIST_MASK) != BPLIST_UINT) {\n                PLIST_BIN_ERR(\"%s: invalid size node type for node type 0x%02x: found 0x%02x, expected 0x%02x\\n\", __func__, type, **object & BPLIST_MASK, BPLIST_UINT);\n                return NULL;\n            }\n            (*object)++;\n            next_size = 1 << next_size;\n            if (*object + next_size > bplist->offset_table) {\n                PLIST_BIN_ERR(\"%s: size node data bytes for node type 0x%02x point outside of valid range\\n\", __func__, type);\n                return NULL;\n            }\n            size = UINT_TO_HOST(*object, next_size);\n            (*object) += next_size;\n            break;\n        }\n        default:\n            break;\n        }\n    }\n\n    switch (type)\n    {\n\n    case BPLIST_NULL:\n        switch (size)\n        {\n\n        case BPLIST_TRUE:\n        {\n            plist_data_t data = plist_new_plist_data();\n            data->type = PLIST_BOOLEAN;\n            data->boolval = TRUE;\n            data->length = 1;\n            return node_create(NULL, data);\n        }\n\n        case BPLIST_FALSE:\n        {\n            plist_data_t data = plist_new_plist_data();\n            data->type = PLIST_BOOLEAN;\n            data->boolval = FALSE;\n            data->length = 1;\n            return node_create(NULL, data);\n        }\n\n        case BPLIST_NULL:\n        default:\n            return NULL;\n        }\n\n    case BPLIST_UINT:\n        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_UINT data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_uint_node(object, size);\n\n    case BPLIST_REAL:\n        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_REAL data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_real_node(object, size);\n\n    case BPLIST_DATE:\n        if (3 != size) {\n            PLIST_BIN_ERR(\"%s: invalid data size for BPLIST_DATE node\\n\", __func__);\n            return NULL;\n        }\n        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_DATE data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_date_node(object, size);\n\n    case BPLIST_DATA:\n        if (*object + size < *object || *object + size > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_DATA data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_data_node(object, size);\n\n    case BPLIST_STRING:\n        if (*object + size < *object || *object + size > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_STRING data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_string_node(object, size);\n\n    case BPLIST_UNICODE:\n        if (size*2 < size) {\n            PLIST_BIN_ERR(\"%s: Integer overflow when calculating BPLIST_UNICODE data size.\\n\", __func__);\n            return NULL;\n        }\n        if (*object + size*2 < *object || *object + size*2 > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_UNICODE data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_unicode_node(object, size);\n\n    case BPLIST_SET:\n    case BPLIST_ARRAY:\n        if (*object + size < *object || *object + size > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_ARRAY data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_array_node(bplist, object, size);\n\n    case BPLIST_UID:\n        if (*object + size+1 > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_UID data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_uid_node(object, size);\n\n    case BPLIST_DICT:\n        if (*object + size < *object || *object + size > bplist->offset_table) {\n            PLIST_BIN_ERR(\"%s: BPLIST_DICT data bytes point outside of valid range\\n\", __func__);\n            return NULL;\n        }\n        return parse_dict_node(bplist, object, size);\n\n    default:\n        PLIST_BIN_ERR(\"%s: unexpected node type 0x%02x\\n\", __func__, type);\n        return NULL;\n    }\n    return NULL;\n}\n\nstatic plist_t parse_bin_node_at_index(struct bplist_data *bplist, uint32_t node_index)\n{\n    int i = 0;\n    const char* ptr = NULL;\n    plist_t plist = NULL;\n    const char* idx_ptr = NULL;\n\n    if (node_index >= bplist->num_objects) {\n        PLIST_BIN_ERR(\"node index (%u) must be smaller than the number of objects (%\" PRIu64 \")\\n\", node_index, bplist->num_objects);\n        return NULL;\n    }\n\n    idx_ptr = bplist->offset_table + node_index * bplist->offset_size;\n    if (idx_ptr < bplist->offset_table ||\n        idx_ptr >= bplist->offset_table + bplist->num_objects * bplist->offset_size) {\n        PLIST_BIN_ERR(\"node index %u points outside of valid range\\n\", node_index);\n        return NULL;\n    }\n\n    ptr = bplist->data + UINT_TO_HOST(idx_ptr, bplist->offset_size);\n    /* make sure the node offset is in a sane range */\n    if ((ptr < bplist->data) || (ptr >= bplist->offset_table)) {\n        PLIST_BIN_ERR(\"offset for node index %u points outside of valid range\\n\", node_index);\n        return NULL;\n    }\n\n    /* store node_index for current recursion level */\n    if (plist_array_get_size(bplist->used_indexes) < bplist->level+1) {\n        while (plist_array_get_size(bplist->used_indexes) < bplist->level+1) {\n            plist_array_append_item(bplist->used_indexes, plist_new_uint(node_index));\n        }\n    } else {\n        plist_array_set_item(bplist->used_indexes, plist_new_uint(node_index), bplist->level);\n    }\n\n    /* recursion check */\n    if (bplist->level > 0) {\n        for (i = bplist->level-1; i >= 0; i--) {\n            plist_t node_i = plist_array_get_item(bplist->used_indexes, i);\n            plist_t node_level = plist_array_get_item(bplist->used_indexes, bplist->level);\n            if (plist_compare_node_value(node_i, node_level)) {\n                PLIST_BIN_ERR(\"recursion detected in binary plist\\n\");\n                return NULL;\n            }\n        }\n    }\n\n    /* finally parse node */\n    bplist->level++;\n    plist = parse_bin_node(bplist, &ptr);\n    bplist->level--;\n    return plist;\n}\n\nPLIST_API void plist_from_bin(const char *plist_bin, uint32_t length, plist_t * plist)\n{\n    bplist_trailer_t *trailer = NULL;\n    uint8_t offset_size = 0;\n    uint8_t ref_size = 0;\n    uint64_t num_objects = 0;\n    uint64_t root_object = 0;\n    const char *offset_table = NULL;\n    const char *start_data = NULL;\n    const char *end_data = NULL;\n\n    //first check we have enough data\n    if (!(length >= BPLIST_MAGIC_SIZE + BPLIST_VERSION_SIZE + sizeof(bplist_trailer_t))) {\n        PLIST_BIN_ERR(\"plist data is to small to hold a binary plist\\n\");\n        return;\n    }\n    //check that plist_bin in actually a plist\n    if (memcmp(plist_bin, BPLIST_MAGIC, BPLIST_MAGIC_SIZE) != 0) {\n        PLIST_BIN_ERR(\"bplist magic mismatch\\n\");\n        return;\n    }\n    //check for known version\n    if (memcmp(plist_bin + BPLIST_MAGIC_SIZE, BPLIST_VERSION, BPLIST_VERSION_SIZE) != 0) {\n        PLIST_BIN_ERR(\"unsupported binary plist version '%.2s\\n\", plist_bin+BPLIST_MAGIC_SIZE);\n        return;\n    }\n\n    start_data = plist_bin + BPLIST_MAGIC_SIZE + BPLIST_VERSION_SIZE;\n    end_data = plist_bin + length - sizeof(bplist_trailer_t);\n\n    //now parse trailer\n    trailer = (bplist_trailer_t*)end_data;\n\n    offset_size = trailer->offset_size;\n    ref_size = trailer->ref_size;\n    num_objects = be64toh(trailer->num_objects);\n    root_object = be64toh(trailer->root_object_index);\n    offset_table = (char *)(plist_bin + be64toh(trailer->offset_table_offset));\n\n    if (num_objects == 0) {\n        PLIST_BIN_ERR(\"number of objects must be larger than 0\\n\");\n        return;\n    }\n\n    if (offset_size == 0) {\n        PLIST_BIN_ERR(\"offset size in trailer must be larger than 0\\n\");\n        return;\n    }\n\n    if (ref_size == 0) {\n        PLIST_BIN_ERR(\"object reference size in trailer must be larger than 0\\n\");\n        return;\n    }\n\n    if (root_object >= num_objects) {\n        PLIST_BIN_ERR(\"root object index (%\" PRIu64 \") must be smaller than number of objects (%\" PRIu64 \")\\n\", root_object, num_objects);\n        return;\n    }\n\n    if (offset_table < start_data || offset_table >= end_data) {\n        PLIST_BIN_ERR(\"offset table offset points outside of valid range\\n\");\n        return;\n    }\n\n    if (num_objects * offset_size < num_objects) {\n        PLIST_BIN_ERR(\"integer overflow when calculating offset table size (too many objects)\\n\");\n        return;\n    }\n\n    if (offset_table + num_objects * offset_size > end_data) {\n        PLIST_BIN_ERR(\"offset table points outside of valid range\\n\");\n        return;\n    }\n\n    struct bplist_data bplist;\n    bplist.data = plist_bin;\n    bplist.size = length;\n    bplist.num_objects = num_objects;\n    bplist.ref_size = ref_size;\n    bplist.offset_size = offset_size;\n    bplist.offset_table = offset_table;\n    bplist.level = 0;\n    bplist.used_indexes = plist_new_array();\n\n    if (!bplist.used_indexes) {\n        PLIST_BIN_ERR(\"failed to create array to hold used node indexes. Out of memory?\\n\");\n        return;\n    }\n\n    *plist = parse_bin_node_at_index(&bplist, root_object);\n\n    plist_free(bplist.used_indexes);\n}\n\nstatic unsigned int plist_data_hash(const void* key)\n{\n    plist_data_t data = plist_get_data((plist_t) key);\n\n    unsigned int hash = data->type;\n    unsigned int i = 0;\n\n    char *buff = NULL;\n    unsigned int size = 0;\n\n    switch (data->type)\n    {\n    case PLIST_BOOLEAN:\n    case PLIST_UINT:\n    case PLIST_REAL:\n    case PLIST_DATE:\n    case PLIST_UID:\n        buff = (char *) &data->intval;\t//works also for real as we use an union\n        size = 8;\n        break;\n    case PLIST_KEY:\n    case PLIST_STRING:\n        buff = data->strval;\n        size = data->length;\n        break;\n    case PLIST_DATA:\n    case PLIST_ARRAY:\n    case PLIST_DICT:\n        //for these types only hash pointer\n        buff = (char *) &key;\n        size = sizeof(const void*);\n        break;\n    default:\n        break;\n    }\n\n    // now perform hash using djb2 hashing algorithm\n    // see: http://www.cse.yorku.ca/~oz/hash.html\n    hash += 5381;\n    for (i = 0; i < size; buff++, i++) {\n        hash = ((hash << 5) + hash) + *buff;\n    }\n\n    return hash;\n}\n\nstruct serialize_s\n{\n    ptrarray_t* objects;\n    hashtable_t* ref_table;\n};\n\nstatic void serialize_plist(node_t* node, void* data)\n{\n    uint64_t *index_val = NULL;\n    struct serialize_s *ser = (struct serialize_s *) data;\n    uint64_t current_index = ser->objects->len;\n\n    //first check that node is not yet in objects\n    void* val = hash_table_lookup(ser->ref_table, node);\n    if (val)\n    {\n        //data is already in table\n        return;\n    }\n    //insert new ref\n    index_val = (uint64_t *) malloc(sizeof(uint64_t));\n    assert(index_val != NULL);\n    *index_val = current_index;\n    hash_table_insert(ser->ref_table, node, index_val);\n\n    //now append current node to object array\n    ptr_array_add(ser->objects, node);\n\n    //now recurse on children\n    node_iterator_t *ni = node_iterator_create(node->children);\n    node_t *ch;\n    while ((ch = node_iterator_next(ni))) {\n        serialize_plist(ch, data);\n    }\n    node_iterator_destroy(ni);\n\n    return;\n}\n\n#define Log2(x) (x == 8 ? 3 : (x == 4 ? 2 : (x == 2 ? 1 : 0)))\n\nstatic void write_int(bytearray_t * bplist, uint64_t val)\n{\n    int size = get_needed_bytes(val);\n    uint8_t sz;\n    //do not write 3bytes int node\n    if (size == 3)\n        size++;\n    sz = BPLIST_UINT | Log2(size);\n\n    val = be64toh(val);\n    byte_array_append(bplist, &sz, 1);\n    byte_array_append(bplist, (uint8_t*)&val + (8-size), size);\n}\n\nstatic void write_uint(bytearray_t * bplist, uint64_t val)\n{\n    uint8_t sz = BPLIST_UINT | 4;\n    uint64_t zero = 0;\n\n    val = be64toh(val);\n    byte_array_append(bplist, &sz, 1);\n    byte_array_append(bplist, &zero, sizeof(uint64_t));\n    byte_array_append(bplist, &val, sizeof(uint64_t));\n}\n\nstatic void write_real(bytearray_t * bplist, double val)\n{\n    int size = get_real_bytes(val);\t//cheat to know used space\n    uint8_t buff[9];\n    buff[0] = BPLIST_REAL | Log2(size);\n    if (size == sizeof(float)) {\n        float floatval = (float)val;\n        *(uint32_t*)(buff+1) = float_bswap32(*(uint32_t*)&floatval);\n    } else {\n        *(uint64_t*)(buff+1) = float_bswap64(*(uint64_t*)&val);\n    }\n    byte_array_append(bplist, buff, size+1);\n}\n\nstatic void write_date(bytearray_t * bplist, double val)\n{\n    uint8_t buff[9];\n    buff[0] = BPLIST_DATE | 3;\n    *(uint64_t*)(buff+1) = float_bswap64(*(uint64_t*)&val);\n    byte_array_append(bplist, buff, sizeof(buff));\n}\n\nstatic void write_raw_data(bytearray_t * bplist, uint8_t mark, uint8_t * val, uint64_t size)\n{\n    uint8_t marker = mark | (size < 15 ? size : 0xf);\n    byte_array_append(bplist, &marker, sizeof(uint8_t));\n    if (size >= 15) {\n        write_int(bplist, size);\n    }\n    if (BPLIST_UNICODE==mark) size <<= 1;\n    byte_array_append(bplist, val, size);\n}\n\nstatic void write_data(bytearray_t * bplist, uint8_t * val, uint64_t size)\n{\n    write_raw_data(bplist, BPLIST_DATA, val, size);\n}\n\nstatic void write_string(bytearray_t * bplist, char *val)\n{\n    uint64_t size = strlen(val);\n    write_raw_data(bplist, BPLIST_STRING, (uint8_t *) val, size);\n}\n\nstatic void write_unicode(bytearray_t * bplist, uint16_t * val, uint64_t size)\n{\n    uint64_t i = 0;\n    uint16_t *buff = (uint16_t*)malloc(size << 1);\n    for (i = 0; i < size; i++)\n        buff[i] = be16toh(val[i]);\n    write_raw_data(bplist, BPLIST_UNICODE, (uint8_t*)buff, size);\n    free(buff);\n}\n\nstatic void write_array(bytearray_t * bplist, node_t* node, hashtable_t* ref_table, uint8_t ref_size)\n{\n    node_t* cur = NULL;\n    uint64_t i = 0;\n\n    uint64_t size = node_n_children(node);\n    uint8_t marker = BPLIST_ARRAY | (size < 15 ? size : 0xf);\n    byte_array_append(bplist, &marker, sizeof(uint8_t));\n    if (size >= 15) {\n        write_int(bplist, size);\n    }\n\n    for (i = 0, cur = node_first_child(node); cur && i < size; cur = node_next_sibling(cur), i++) {\n        uint64_t idx = *(uint64_t *) (hash_table_lookup(ref_table, cur));\n        idx = be64toh(idx);\n        byte_array_append(bplist, (uint8_t*)&idx + (sizeof(uint64_t) - ref_size), ref_size);\n    }\n}\n\nstatic void write_dict(bytearray_t * bplist, node_t* node, hashtable_t* ref_table, uint8_t ref_size)\n{\n    node_t* cur = NULL;\n    uint64_t i = 0;\n\n    uint64_t size = node_n_children(node) / 2;\n    uint8_t marker = BPLIST_DICT | (size < 15 ? size : 0xf);\n    byte_array_append(bplist, &marker, sizeof(uint8_t));\n    if (size >= 15) {\n        write_int(bplist, size);\n    }\n\n    for (i = 0, cur = node_first_child(node); cur && i < size; cur = node_next_sibling(node_next_sibling(cur)), i++) {\n        uint64_t idx1 = *(uint64_t *) (hash_table_lookup(ref_table, cur));\n        idx1 = be64toh(idx1);\n        byte_array_append(bplist, (uint8_t*)&idx1 + (sizeof(uint64_t) - ref_size), ref_size);\n    }\n\n    for (i = 0, cur = node_first_child(node); cur && i < size; cur = node_next_sibling(node_next_sibling(cur)), i++) {\n        uint64_t idx2 = *(uint64_t *) (hash_table_lookup(ref_table, cur->next));\n        idx2 = be64toh(idx2);\n        byte_array_append(bplist, (uint8_t*)&idx2 + (sizeof(uint64_t) - ref_size), ref_size);\n    }\n}\n\nstatic void write_uid(bytearray_t * bplist, uint64_t val)\n{\n    val = (uint32_t)val;\n    int size = get_needed_bytes(val);\n    uint8_t sz;\n    //do not write 3bytes int node\n    if (size == 3)\n        size++;\n    sz = BPLIST_UID | (size-1); // yes, this is what Apple does...\n\n    val = be64toh(val);\n    byte_array_append(bplist, &sz, 1);\n    byte_array_append(bplist, (uint8_t*)&val + (8-size), size);\n}\n\nstatic int is_ascii_string(char* s, int len)\n{\n  int ret = 1, i = 0;\n  for(i = 0; i < len; i++)\n  {\n      if ( !isascii( s[i] ) )\n      {\n          ret = 0;\n          break;\n      }\n  }\n  return ret;\n}\n\nstatic uint16_t *plist_utf8_to_utf16(char *unistr, long size, long *items_read, long *items_written)\n{\n\tuint16_t *outbuf;\n\tint p = 0;\n\tlong i = 0;\n\n\tunsigned char c0;\n\tunsigned char c1;\n\tunsigned char c2;\n\tunsigned char c3;\n\n\tuint32_t w;\n\n\toutbuf = (uint16_t*)malloc(((size*2)+1)*sizeof(uint16_t));\n\tif (!outbuf) {\n\t\tPLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, (uint64_t)((size*2)+1)*sizeof(uint16_t));\n\t\treturn NULL;\n\t}\n\n\twhile (i < size) {\n\t\tc0 = unistr[i];\n\t\tc1 = (i < size-1) ? unistr[i+1] : 0;\n\t\tc2 = (i < size-2) ? unistr[i+2] : 0;\n\t\tc3 = (i < size-3) ? unistr[i+3] : 0;\n\t\tif ((c0 >= 0xF0) && (i < size-3) && (c1 >= 0x80) && (c2 >= 0x80) && (c3 >= 0x80)) {\n\t\t\t// 4 byte sequence.  Need to generate UTF-16 surrogate pair\n\t\t\tw = ((((c0 & 7) << 18) + ((c1 & 0x3F) << 12) + ((c2 & 0x3F) << 6) + (c3 & 0x3F)) & 0x1FFFFF) - 0x010000;\n\t\t\toutbuf[p++] = 0xD800 + (w >> 10);\n\t\t\toutbuf[p++] = 0xDC00 + (w & 0x3FF);\n\t\t\ti+=4;\n\t\t} else if ((c0 >= 0xE0) && (i < size-2) && (c1 >= 0x80) && (c2 >= 0x80)) {\n\t\t\t// 3 byte sequence\n\t\t\toutbuf[p++] = ((c2 & 0x3F) + ((c1 & 3) << 6)) + (((c1 >> 2) & 15) << 8) + ((c0 & 15) << 12);\n\t\t\ti+=3;\n\t\t} else if ((c0 >= 0xC0) && (i < size-1) && (c1 >= 0x80)) {\n\t\t\t// 2 byte sequence\n\t\t\toutbuf[p++] = ((c1 & 0x3F) + ((c0 & 3) << 6)) + (((c0 >> 2) & 7) << 8);\n\t\t\ti+=2;\n\t\t} else if (c0 < 0x80) {\n\t\t\t// 1 byte sequence\n\t\t\toutbuf[p++] = c0;\n\t\t\ti+=1;\n\t\t} else {\n\t\t\t// invalid character\n\t\t\tPLIST_BIN_ERR(\"%s: invalid utf8 sequence in string at index %lu\\n\", __func__, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (items_read) {\n\t\t*items_read = i;\n\t}\n\tif (items_written) {\n\t\t*items_written = p;\n\t}\n\toutbuf[p] = 0;\n\n\treturn outbuf;\n\n}\n\nPLIST_API void plist_to_bin(plist_t plist, char **plist_bin, uint32_t * length)\n{\n    ptrarray_t* objects = NULL;\n    hashtable_t* ref_table = NULL;\n    struct serialize_s ser_s;\n    uint8_t offset_size = 0;\n    uint8_t ref_size = 0;\n    uint64_t num_objects = 0;\n    uint64_t root_object = 0;\n    uint64_t offset_table_index = 0;\n    bytearray_t *bplist_buff = NULL;\n    uint64_t i = 0;\n    uint8_t *buff = NULL;\n    uint64_t *offsets = NULL;\n    bplist_trailer_t trailer;\n    //for string\n    long len = 0;\n    long items_read = 0;\n    long items_written = 0;\n    uint16_t *unicodestr = NULL;\n    uint64_t objects_len = 0;\n    uint64_t buff_len = 0;\n\n    //check for valid input\n    if (!plist || !plist_bin || *plist_bin || !length)\n        return;\n\n    //list of objects\n    objects = ptr_array_new(256);\n    //hashtable to write only once same nodes\n    ref_table = hash_table_new(plist_data_hash, plist_data_compare, free);\n\n    //serialize plist\n    ser_s.objects = objects;\n    ser_s.ref_table = ref_table;\n    serialize_plist(plist, &ser_s);\n\n    //now stream to output buffer\n    offset_size = 0;\t\t\t//unknown yet\n    objects_len = objects->len;\n    ref_size = get_needed_bytes(objects_len);\n    num_objects = objects->len;\n    root_object = 0;\t\t\t//root is first in list\n    offset_table_index = 0;\t\t//unknown yet\n\n    //setup a dynamic bytes array to store bplist in\n    bplist_buff = byte_array_new();\n\n    //set magic number and version\n    byte_array_append(bplist_buff, BPLIST_MAGIC, BPLIST_MAGIC_SIZE);\n    byte_array_append(bplist_buff, BPLIST_VERSION, BPLIST_VERSION_SIZE);\n\n    //write objects and table\n    offsets = (uint64_t *) malloc(num_objects * sizeof(uint64_t));\n    assert(offsets != NULL);\n    for (i = 0; i < num_objects; i++)\n    {\n\n        plist_data_t data = plist_get_data(ptr_array_index(objects, i));\n        offsets[i] = bplist_buff->len;\n\n        switch (data->type)\n        {\n        case PLIST_BOOLEAN:\n            buff = (uint8_t *) malloc(sizeof(uint8_t));\n            buff[0] = data->boolval ? BPLIST_TRUE : BPLIST_FALSE;\n            byte_array_append(bplist_buff, buff, sizeof(uint8_t));\n            free(buff);\n            break;\n\n        case PLIST_UINT:\n            if (data->length == 16) {\n                write_uint(bplist_buff, data->intval);\n            } else {\n                write_int(bplist_buff, data->intval);\n            }\n            break;\n\n        case PLIST_REAL:\n            write_real(bplist_buff, data->realval);\n            break;\n\n        case PLIST_KEY:\n        case PLIST_STRING:\n            len = strlen(data->strval);\n            if ( is_ascii_string(data->strval, len) )\n            {\n                write_string(bplist_buff, data->strval);\n            }\n            else\n            {\n                unicodestr = plist_utf8_to_utf16(data->strval, len, &items_read, &items_written);\n                write_unicode(bplist_buff, unicodestr, items_written);\n                free(unicodestr);\n            }\n            break;\n        case PLIST_DATA:\n            write_data(bplist_buff, data->buff, data->length);\n        case PLIST_ARRAY:\n            write_array(bplist_buff, ptr_array_index(objects, i), ref_table, ref_size);\n            break;\n        case PLIST_DICT:\n            write_dict(bplist_buff, ptr_array_index(objects, i), ref_table, ref_size);\n            break;\n        case PLIST_DATE:\n            write_date(bplist_buff, data->realval);\n            break;\n        case PLIST_UID:\n            write_uid(bplist_buff, data->intval);\n            break;\n        default:\n            break;\n        }\n    }\n\n    //free intermediate objects\n    ptr_array_free(objects);\n    hash_table_destroy(ref_table);\n\n    //write offsets\n    buff_len = bplist_buff->len;\n    offset_size = get_needed_bytes(buff_len);\n    offset_table_index = bplist_buff->len;\n    for (i = 0; i < num_objects; i++) {\n        uint64_t offset = be64toh(offsets[i]);\n        byte_array_append(bplist_buff, (uint8_t*)&offset + (sizeof(uint64_t) - offset_size), offset_size);\n    }\n    free(offsets);\n\n    //setup trailer\n    memset(trailer.unused, '\\0', sizeof(trailer.unused));\n    trailer.offset_size = offset_size;\n    trailer.ref_size = ref_size;\n    trailer.num_objects = be64toh(num_objects);\n    trailer.root_object_index = be64toh(root_object);\n    trailer.offset_table_offset = be64toh(offset_table_index);\n\n    byte_array_append(bplist_buff, &trailer, sizeof(bplist_trailer_t));\n\n    //set output buffer and size\n    *plist_bin = bplist_buff->data;\n    *length = bplist_buff->len;\n\n    bplist_buff->data = NULL; // make sure we don't free the output buffer\n    byte_array_free(bplist_buff);\n}\n"], "buggy_code_start_loc": [657], "buggy_code_end_loc": [699], "fixing_code_start_loc": [657], "fixing_code_end_loc": [699], "type": "CWE-787", "message": "Heap-based buffer overflow in the parse_string_node function in bplist.c in libimobiledevice libplist 1.12 allows local users to cause a denial of service (out-of-bounds write) via a crafted plist file.", "other": {"cve": {"id": "CVE-2017-6439", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T14:59:01.087", "lastModified": "2017-04-04T01:59:07.293", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in the parse_string_node function in bplist.c in libimobiledevice libplist 1.12 allows local users to cause a denial of service (out-of-bounds write) via a crafted plist file."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en memoria din\u00e1mica en la funci\u00f3n parse_string_node en bplist.c en libimobiledevice libplist 1.12 permite a usuarios locales provocar una denegaci\u00f3n de servicio (escritura fuera de l\u00edmites) a trav\u00e9s de un archivo plist manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libplist_project:libplist:1.12:*:*:*:*:*:*:*", "matchCriteriaId": "B6673CC0-FAB1-4A77-8B0F-0D8103A81437"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97278", "source": "cve@mitre.org"}, {"url": "https://github.com/libimobiledevice/libplist/commit/32ee5213fe64f1e10ec76c1ee861ee6f233120dd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libimobiledevice/libplist/issues/95", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/04/msg00002.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/libimobiledevice/libplist/commit/32ee5213fe64f1e10ec76c1ee861ee6f233120dd"}}