{"buggy_code": ["# import stuff\nimport logging\nFORMAT = '%(levelname)s | TIME - %(asctime)s | PROCESS - %(processName)s %(process)d | MSG - %(message)s'\nlogging.basicConfig(filename='LiuOS.log', encoding='utf-8', level=logging.DEBUG, format=FORMAT)\nlogging.debug(\"Created logging config\")\nimport api\nlogging.debug(f\"Loaded LiuOS API {api.VerAPI}\")\nimport hashlib\nlogging.debug(\"Imported hashlib\")\nimport getpass\nlogging.debug(\"Imported getpass\")\nimport lang\nlogging.debug(f\"Loaded LiuOS {lang.CURRENT_LANG}\")\nimport cred\nlogging.debug(\"Imported cred.py\")\nimport os\nlogging.debug(\"Imported os\")\nimport sys\nlogging.debug(\"Imported sys\")\nimport cmd\nlogging.debug(\"Imported cmd\")\nimport runpy\nlogging.debug(\"Imported runpy\")\n\nclass LiuShell(cmd.Cmd):\n    intro = lang.SHELL_INTRO\n    prompt = 'LiuOS: '\n    file = None\n\n    # ----- LiuOS Shell commands -----\n    def do_runcmd(self, arg):\n        'Runs the host shell command specified. Ex: runcmd echo'\n        logging.info(\"Running command using runcmd in shell\")\n        os.system(arg)\n    def do_runline(self, arg):\n        'Runs the Python line specified. Ex: runline print(\"hello\")'\n        logging.info(\"Running Python code using runline in shell\")\n        exec(arg)\n    def do_run(self, arg):\n        'Runs the script specified, it must be in the programs dir in the same dir as LiuOS and exist, or Python will crash. Ex: run eteled.py'\n        logging.info(f\"Running Python file using run in shell\")\n        runpy.run_path(path_name=\"programs/{arg}\")\n    def do_clear(self, arg):\n        'Clears the terminal'\n        os.system('cls' if os.name == 'nt' else 'clear')\n    def do_logout(self, arg):\n        'Closes the shell. Ex: logout'\n        logging.warning(\"Logging out shell session\")\n        print('Logging out...')\n        self.close()\n        return True\n    def do_shutdown(self, arg):\n        'Closes the shell, and quits the script. Ex: shutdown'\n        print('Logging out...')\n        logging.info(\"Shut down using shell command\")\n        exit()\n        return True\n\n    # ----- record and playback -----\n    def do_savecmd(self, arg):\n        'Save future commands to filename:  RECORD rose.cmd'\n        self.file = open(arg, 'w')\n    def do_opencmd(self, arg):\n        'Playback commands from a file:  PLAYBACK rose.cmd'\n        self.close()\n        with open(arg) as f:\n            self.cmdqueue.extend(f.read().splitlines())\n    def precmd(self, line):\n        line = line.lower()\n        if self.file and 'playback' not in line:\n            print(line, file=self.file)\n        return line\n    def close(self):\n        if self.file:\n            self.file.close()\n            self.file = None\n\ndef parse(arg):\n    'Convert a series of zero or more numbers to an argument tuple'\n    return tuple(map(int, arg.split()))\n# Counter\nattemps = 0\ndef actualsys() :\n        logging.debug(\"Launched main system\")\n        os.system('cls' if os.name == 'nt' else 'clear')\n        logging.debug(\"Loaded LiuOS Shell\")\n        LiuShell().cmdloop()\nlogging.debug(\"Assigned main system function\")\nif os.environ.get('GITHUB_ACTIONS') == \"true\":\n        logging.info('Running on GitHub Actions, not using the LiuOS Shell')\n        print(lang.ENTER_USERNAME_LOGIN)\n        print(lang.ENTER_PASSWD_LOGIN)\n        print(lang.FAKE_SUCCESSFUL_LOGIN)\n        logging.warning(\"Fake login completed\")\n        print(lang.SHELL_INTRO)\n        print(lang.SAMPLE_ABC)\n        print(lang.SAMPLE_STRING)\n        TestProg = \"programs/helloworld.py\"\n        runpy.run_path(path_name=TestProg)\n        print(\"Code completed\")\nelse:\n # Authentication system\n\n       while attemps < 7:\n        username = input(lang.ENTER_USERNAME_LOGIN)\n        logging.debug('Entered username')\n        password = getpass.getpass(lang.ENTER_PASSWD_LOGIN)\n        logging.debug('Entered password')\n        bytehash = hashlib.sha512(password.encode())\n        pwdreshash = bytehash.hexdigest()\n        logging.debug('Generated hash of password')\n        if attemps == 6:\n        ## Brute force protection\n           raise Exception(\"Too many password attempts. Because of the risk of a brute force attack, after 6 attempts, you will need to rerun LiuOS to try 6 more times.\")\n        if os.environ.get('GITHUB_ACTIONS') != \"\":\n            logging.warning(\"Running on Github Actions\")\n            actualsys()\n        elif username == cred.loginname and pwdreshash == cred.loginpass:\n            print(lang.SUCCESSFUL_LOGIN)\n            logging.debug('Correct login credentials, logged in')\n            actualsys()\n        else:\n            print(lang.INCORRECT_LOGIN)\n            logging.error(\"Incorrect login credentials\")\n            attemps += 1\n            continue\n        \n"], "fixing_code": ["# import stuff\nimport logging\nFORMAT = '%(levelname)s | TIME - %(asctime)s | PROCESS - %(processName)s %(process)d | MSG - %(message)s'\nlogging.basicConfig(filename='LiuOS.log', encoding='utf-8', level=logging.DEBUG, format=FORMAT)\nlogging.debug(\"Created logging config\")\nimport api\nlogging.debug(f\"Loaded LiuOS API {api.VerAPI}\")\nimport hashlib\nlogging.debug(\"Imported hashlib\")\nimport getpass\nlogging.debug(\"Imported getpass\")\nimport lang\nlogging.debug(f\"Loaded LiuOS {lang.CURRENT_LANG}\")\nimport cred\nlogging.debug(\"Imported cred.py\")\nimport os\nlogging.debug(\"Imported os\")\nimport sys\nlogging.debug(\"Imported sys\")\nimport cmd\nlogging.debug(\"Imported cmd\")\nimport runpy\nlogging.debug(\"Imported runpy\")\n\nclass LiuShell(cmd.Cmd):\n    intro = lang.SHELL_INTRO\n    prompt = 'LiuOS: '\n    file = None\n\n    # ----- LiuOS Shell commands -----\n    def do_runcmd(self, arg):\n        'Runs the host shell command specified. Ex: runcmd echo'\n        logging.info(\"Running command using runcmd in shell\")\n        os.system(arg)\n    def do_runline(self, arg):\n        'Runs the Python line specified. Ex: runline print(\"hello\")'\n        logging.info(\"Running Python code using runline in shell\")\n        exec(arg)\n    def do_run(self, arg):\n        'Runs the script specified, it must be in the programs dir in the same dir as LiuOS and exist, or Python will crash. Ex: run eteled.py'\n        logging.info(f\"Running Python file using run in shell\")\n        runpy.run_path(path_name=\"programs/{arg}\")\n    def do_clear(self, arg):\n        'Clears the terminal'\n        os.system('cls' if os.name == 'nt' else 'clear')\n    def do_logout(self, arg):\n        'Closes the shell. Ex: logout'\n        logging.warning(\"Logging out shell session\")\n        print('Logging out...')\n        self.close()\n        return True\n    def do_shutdown(self, arg):\n        'Closes the shell, and quits the script. Ex: shutdown'\n        print('Logging out...')\n        logging.info(\"Shut down using shell command\")\n        exit()\n        return True\n\n    # ----- record and playback -----\n    def do_savecmd(self, arg):\n        'Save future commands to filename:  RECORD rose.cmd'\n        self.file = open(arg, 'w')\n    def do_opencmd(self, arg):\n        'Playback commands from a file:  PLAYBACK rose.cmd'\n        self.close()\n        with open(arg) as f:\n            self.cmdqueue.extend(f.read().splitlines())\n    def precmd(self, line):\n        line = line.lower()\n        if self.file and 'playback' not in line:\n            print(line, file=self.file)\n        return line\n    def close(self):\n        if self.file:\n            self.file.close()\n            self.file = None\n\ndef parse(arg):\n    'Convert a series of zero or more numbers to an argument tuple'\n    return tuple(map(int, arg.split()))\n# Counter\nattemps = 0\ndef actualsys() :\n        logging.debug(\"Launched main system\")\n        os.system('cls' if os.name == 'nt' else 'clear')\n        logging.debug(\"Loaded LiuOS Shell\")\n        LiuShell().cmdloop()\nlogging.debug(\"Assigned main system function\")\nif os.environ.get('GITHUB_ACTIONS') == \"true\":\n        logging.info('Running on GitHub Actions, not using the LiuOS Shell')\n        print(lang.ENTER_USERNAME_LOGIN)\n        print(lang.ENTER_PASSWD_LOGIN)\n        print(lang.FAKE_SUCCESSFUL_LOGIN)\n        logging.warning(\"Fake login completed\")\n        print(lang.SHELL_INTRO)\n        print(lang.SAMPLE_ABC)\n        print(lang.SAMPLE_STRING)\n        TestProg = \"programs/helloworld.py\"\n        runpy.run_path(path_name=TestProg)\n        print(\"Code completed\")\nelse:\n # Authentication system\n\n       while attemps < 7:\n        username = input(lang.ENTER_USERNAME_LOGIN)\n        logging.debug('Entered username')\n        password = getpass.getpass(lang.ENTER_PASSWD_LOGIN)\n        logging.debug('Entered password')\n        bytehash = hashlib.sha512(password.encode())\n        pwdreshash = bytehash.hexdigest()\n        logging.debug('Generated hash of password')\n        if attemps == 6:\n        ## Brute force protection\n           raise Exception(\"Too many password attempts. Because of the risk of a brute force attack, after 6 attempts, you will need to rerun LiuOS to try 6 more times.\")\n        if os.environ.get('GITHUB_ACTIONS') == \"true\":\n            logging.warning(\"Running on Github Actions\")\n            actualsys()\n        elif username == cred.loginname and pwdreshash == cred.loginpass:\n            print(lang.SUCCESSFUL_LOGIN)\n            logging.debug('Correct login credentials, logged in')\n            actualsys()\n        else:\n            print(lang.INCORRECT_LOGIN)\n            logging.error(\"Incorrect login credentials\")\n            attemps += 1\n            continue\n        \n"], "buggy_code_start_loc": [115], "buggy_code_end_loc": [116], "fixing_code_start_loc": [115], "fixing_code_end_loc": [116], "type": "CWE-639", "message": "LiuOS is a small Python project meant to imitate the functions of a regular operating system. Version 0.1.0 and prior of LiuOS allow an attacker to set the GITHUB_ACTIONS environment variable to anything other than null or true and skip authentication checks. This issue is patched in the latest commit (c658b4f3e57258acf5f6207a90c2f2169698ae22) by requiring the var to be set to true, causing a test script to run instead of being able to login. A potential workaround is to check for the GITHUB_ACTIONS environment variable and set it to \"\" (no quotes) to null the variable and force credential checks.", "other": {"cve": {"id": "CVE-2022-46179", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-28T08:15:08.417", "lastModified": "2023-01-13T15:40:19.647", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "LiuOS is a small Python project meant to imitate the functions of a regular operating system. Version 0.1.0 and prior of LiuOS allow an attacker to set the GITHUB_ACTIONS environment variable to anything other than null or true and skip authentication checks. This issue is patched in the latest commit (c658b4f3e57258acf5f6207a90c2f2169698ae22) by requiring the var to be set to true, causing a test script to run instead of being able to login. A potential workaround is to check for the GITHUB_ACTIONS environment variable and set it to \"\" (no quotes) to null the variable and force credential checks."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:L/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.2, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.5, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-639"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:liuos_project:liuos:0.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "5B503DD9-74D7-4990-9F26-0919B1CE7344"}]}]}], "references": [{"url": "https://github.com/LiuWoodsCode/LiuOS/commit/c658b4f3e57258acf5f6207a90c2f2169698ae22", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LiuWoodsCode/LiuOS/security/advisories/GHSA-f9x3-mj2r-cqmf", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LiuWoodsCode/LiuOS/commit/c658b4f3e57258acf5f6207a90c2f2169698ae22"}}