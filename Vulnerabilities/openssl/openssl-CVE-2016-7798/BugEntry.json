{"buggy_code": ["/*\n * 'OpenSSL for Ruby' project\n * Copyright (C) 2001-2002  Michal Rokos <m.rokos@sh.cvut.cz>\n * All rights reserved.\n */\n/*\n * This program is licensed under the same licence as Ruby.\n * (See the file 'LICENCE'.)\n */\n#include \"ossl.h\"\n\n#define NewCipher(klass) \\\n    TypedData_Wrap_Struct((klass), &ossl_cipher_type, 0)\n#define AllocCipher(obj, ctx) do { \\\n    (ctx) = EVP_CIPHER_CTX_new(); \\\n    if (!(ctx)) \\\n\tossl_raise(rb_eRuntimeError, NULL); \\\n    RTYPEDDATA_DATA(obj) = (ctx); \\\n} while (0)\n#define GetCipherInit(obj, ctx) do { \\\n    TypedData_Get_Struct((obj), EVP_CIPHER_CTX, &ossl_cipher_type, (ctx)); \\\n} while (0)\n#define GetCipher(obj, ctx) do { \\\n    GetCipherInit((obj), (ctx)); \\\n    if (!(ctx)) { \\\n\tossl_raise(rb_eRuntimeError, \"Cipher not inititalized!\"); \\\n    } \\\n} while (0)\n#define SafeGetCipher(obj, ctx) do { \\\n    OSSL_Check_Kind((obj), cCipher); \\\n    GetCipher((obj), (ctx)); \\\n} while (0)\n\n/*\n * Classes\n */\nVALUE cCipher;\nVALUE eCipherError;\nstatic ID id_auth_tag_len;\n\nstatic VALUE ossl_cipher_alloc(VALUE klass);\nstatic void ossl_cipher_free(void *ptr);\n\nstatic const rb_data_type_t ossl_cipher_type = {\n    \"OpenSSL/Cipher\",\n    {\n\t0, ossl_cipher_free,\n    },\n    0, 0, RUBY_TYPED_FREE_IMMEDIATELY,\n};\n\n/*\n * PUBLIC\n */\nconst EVP_CIPHER *\nGetCipherPtr(VALUE obj)\n{\n    if (rb_obj_is_kind_of(obj, cCipher)) {\n\tEVP_CIPHER_CTX *ctx;\n\n\tGetCipher(obj, ctx);\n\n\treturn EVP_CIPHER_CTX_cipher(ctx);\n    }\n    else {\n\tconst EVP_CIPHER *cipher;\n\n\tStringValueCStr(obj);\n\tcipher = EVP_get_cipherbyname(RSTRING_PTR(obj));\n\tif (!cipher)\n\t    ossl_raise(rb_eArgError,\n\t\t       \"unsupported cipher algorithm: %\"PRIsVALUE, obj);\n\n\treturn cipher;\n    }\n}\n\nVALUE\nossl_cipher_new(const EVP_CIPHER *cipher)\n{\n    VALUE ret;\n    EVP_CIPHER_CTX *ctx;\n\n    ret = ossl_cipher_alloc(cCipher);\n    AllocCipher(ret, ctx);\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return ret;\n}\n\n/*\n * PRIVATE\n */\nstatic void\nossl_cipher_free(void *ptr)\n{\n    EVP_CIPHER_CTX_free(ptr);\n}\n\nstatic VALUE\nossl_cipher_alloc(VALUE klass)\n{\n    return NewCipher(klass);\n}\n\n/*\n *  call-seq:\n *     Cipher.new(string) -> cipher\n *\n *  The string must contain a valid cipher name like \"AES-128-CBC\" or \"3DES\".\n *\n *  A list of cipher names is available by calling OpenSSL::Cipher.ciphers.\n */\nstatic VALUE\nossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    /*\n     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some\n     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]\n     *\n     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows\n     * uninitialized key, but other EVPs (such as AES) does not allow it.\n     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we\n     * set the data filled with \"\\0\" as the key by default.\n     */\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return self;\n}\n\nstatic VALUE\nossl_cipher_copy(VALUE self, VALUE other)\n{\n    EVP_CIPHER_CTX *ctx1, *ctx2;\n\n    rb_check_frozen(self);\n    if (self == other) return self;\n\n    GetCipherInit(self, ctx1);\n    if (!ctx1) {\n\tAllocCipher(self, ctx1);\n    }\n    SafeGetCipher(other, ctx2);\n    if (EVP_CIPHER_CTX_copy(ctx1, ctx2) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return self;\n}\n\nstatic void*\nadd_cipher_name_to_ary(const OBJ_NAME *name, VALUE ary)\n{\n    rb_ary_push(ary, rb_str_new2(name->name));\n    return NULL;\n}\n\n/*\n *  call-seq:\n *     OpenSSL::Cipher.ciphers -> array[string...]\n *\n *  Returns the names of all available ciphers in an array.\n */\nstatic VALUE\nossl_s_ciphers(VALUE self)\n{\n    VALUE ary;\n\n    ary = rb_ary_new();\n    OBJ_NAME_do_all_sorted(OBJ_NAME_TYPE_CIPHER_METH,\n                    (void(*)(const OBJ_NAME*,void*))add_cipher_name_to_ary,\n                    (void*)ary);\n\n    return ary;\n}\n\n/*\n *  call-seq:\n *     cipher.reset -> self\n *\n *  Fully resets the internal state of the Cipher. By using this, the same\n *  Cipher instance may be used several times for encryption or decryption tasks.\n *\n *  Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1).\n */\nstatic VALUE\nossl_cipher_reset(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return self;\n}\n\nstatic VALUE\nossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char key[EVP_MAX_KEY_LENGTH], *p_key = NULL;\n    unsigned char iv[EVP_MAX_IV_LENGTH], *p_iv = NULL;\n    VALUE pass, init_v;\n\n    if(rb_scan_args(argc, argv, \"02\", &pass, &init_v) > 0){\n\t/*\n\t * oops. this code mistakes salt for IV.\n\t * We deprecated the arguments for this method, but we decided\n\t * keeping this behaviour for backward compatibility.\n\t */\n\tVALUE cname  = rb_class_path(rb_obj_class(self));\n\trb_warn(\"arguments for %\"PRIsVALUE\"#encrypt and %\"PRIsVALUE\"#decrypt were deprecated; \"\n                \"use %\"PRIsVALUE\"#pkcs5_keyivgen to derive key and IV\",\n                cname, cname, cname);\n\tStringValue(pass);\n\tGetCipher(self, ctx);\n\tif (NIL_P(init_v)) memcpy(iv, \"OpenSSL for Ruby rulez!\", sizeof(iv));\n\telse{\n\t    StringValue(init_v);\n\t    if (EVP_MAX_IV_LENGTH > RSTRING_LEN(init_v)) {\n\t\tmemset(iv, 0, EVP_MAX_IV_LENGTH);\n\t\tmemcpy(iv, RSTRING_PTR(init_v), RSTRING_LEN(init_v));\n\t    }\n\t    else memcpy(iv, RSTRING_PTR(init_v), sizeof(iv));\n\t}\n\tEVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), EVP_md5(), iv,\n\t\t       (unsigned char *)RSTRING_PTR(pass), RSTRING_LENINT(pass), 1, key, NULL);\n\tp_key = key;\n\tp_iv = iv;\n    }\n    else {\n\tGetCipher(self, ctx);\n    }\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, p_key, p_iv, mode) != 1) {\n\tossl_raise(eCipherError, NULL);\n    }\n\n    return self;\n}\n\n/*\n *  call-seq:\n *     cipher.encrypt -> self\n *\n *  Initializes the Cipher for encryption.\n *\n *  Make sure to call Cipher#encrypt or Cipher#decrypt before using any of the\n *  following methods:\n *  * [#key=, #iv=, #random_key, #random_iv, #pkcs5_keyivgen]\n *\n *  Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 1).\n */\nstatic VALUE\nossl_cipher_encrypt(int argc, VALUE *argv, VALUE self)\n{\n    return ossl_cipher_init(argc, argv, self, 1);\n}\n\n/*\n *  call-seq:\n *     cipher.decrypt -> self\n *\n *  Initializes the Cipher for decryption.\n *\n *  Make sure to call Cipher#encrypt or Cipher#decrypt before using any of the\n *  following methods:\n *  * [#key=, #iv=, #random_key, #random_iv, #pkcs5_keyivgen]\n *\n *  Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 0).\n */\nstatic VALUE\nossl_cipher_decrypt(int argc, VALUE *argv, VALUE self)\n{\n    return ossl_cipher_init(argc, argv, self, 0);\n}\n\n/*\n *  call-seq:\n *     cipher.pkcs5_keyivgen(pass, salt = nil, iterations = 2048, digest = \"MD5\") -> nil\n *\n *  Generates and sets the key/IV based on a password.\n *\n *  *WARNING*: This method is only PKCS5 v1.5 compliant when using RC2, RC4-40,\n *  or DES with MD5 or SHA1. Using anything else (like AES) will generate the\n *  key/iv using an OpenSSL specific method. This method is deprecated and\n *  should no longer be used. Use a PKCS5 v2 key generation method from\n *  OpenSSL::PKCS5 instead.\n *\n *  === Parameters\n *  * +salt+ must be an 8 byte string if provided.\n *  * +iterations+ is a integer with a default of 2048.\n *  * +digest+ is a Digest object that defaults to 'MD5'\n *\n *  A minimum of 1000 iterations is recommended.\n *\n */\nstatic VALUE\nossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_MD *digest;\n    VALUE vpass, vsalt, viter, vdigest;\n    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH], *salt = NULL;\n    int iter;\n\n    rb_scan_args(argc, argv, \"13\", &vpass, &vsalt, &viter, &vdigest);\n    StringValue(vpass);\n    if(!NIL_P(vsalt)){\n\tStringValue(vsalt);\n\tif(RSTRING_LEN(vsalt) != PKCS5_SALT_LEN)\n\t    ossl_raise(eCipherError, \"salt must be an 8-octet string\");\n\tsalt = (unsigned char *)RSTRING_PTR(vsalt);\n    }\n    iter = NIL_P(viter) ? 2048 : NUM2INT(viter);\n    digest = NIL_P(vdigest) ? EVP_md5() : GetDigestPtr(vdigest);\n    GetCipher(self, ctx);\n    EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), digest, salt,\n\t\t   (unsigned char *)RSTRING_PTR(vpass), RSTRING_LENINT(vpass), iter, key, iv);\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    OPENSSL_cleanse(key, sizeof key);\n    OPENSSL_cleanse(iv, sizeof iv);\n\n    return Qnil;\n}\n\nstatic int\nossl_cipher_update_long(EVP_CIPHER_CTX *ctx, unsigned char *out, long *out_len_ptr,\n\t\t\tconst unsigned char *in, long in_len)\n{\n    int out_part_len;\n    int limit = INT_MAX / 2 + 1;\n    long out_len = 0;\n\n    do {\n\tint in_part_len = in_len > limit ? limit : (int)in_len;\n\n\tif (!EVP_CipherUpdate(ctx, out ? (out + out_len) : 0,\n\t\t\t      &out_part_len, in, in_part_len))\n\t    return 0;\n\n\tout_len += out_part_len;\n\tin += in_part_len;\n    } while ((in_len -= limit) > 0);\n\n    if (out_len_ptr)\n\t*out_len_ptr = out_len;\n\n    return 1;\n}\n\n/*\n *  call-seq:\n *     cipher.update(data [, buffer]) -> string or buffer\n *\n *  Encrypts data in a streaming fashion. Hand consecutive blocks of data\n *  to the +update+ method in order to encrypt it. Returns the encrypted\n *  data chunk. When done, the output of Cipher#final should be additionally\n *  added to the result.\n *\n *  If +buffer+ is given, the encryption/decryption result will be written to\n *  it. +buffer+ will be resized automatically.\n */\nstatic VALUE\nossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n\n    return str;\n}\n\n/*\n *  call-seq:\n *     cipher.final -> string\n *\n *  Returns the remaining data held in the cipher object. Further calls to\n *  Cipher#update or Cipher#final will return garbage. This call should always\n *  be made as the last call of an encryption or decryption operation, after\n *  after having fed the entire plaintext or ciphertext to the Cipher instance.\n *\n *  If an authenticated cipher was used, a CipherError is raised if the tag\n *  could not be authenticated successfully. Only call this method after\n *  setting the authentication tag and passing the entire contents of the\n *  ciphertext into the cipher.\n */\nstatic VALUE\nossl_cipher_final(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    int out_len;\n    VALUE str;\n\n    GetCipher(self, ctx);\n    str = rb_str_new(0, EVP_CIPHER_CTX_block_size(ctx));\n    if (!EVP_CipherFinal_ex(ctx, (unsigned char *)RSTRING_PTR(str), &out_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len <= RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n\n    return str;\n}\n\n/*\n *  call-seq:\n *     cipher.name -> string\n *\n *  Returns the name of the cipher which may differ slightly from the original\n *  name provided.\n */\nstatic VALUE\nossl_cipher_name(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n\n    return rb_str_new2(EVP_CIPHER_name(EVP_CIPHER_CTX_cipher(ctx)));\n}\n\n/*\n *  call-seq:\n *     cipher.key = string -> string\n *\n *  Sets the cipher key. To generate a key, you should either use a secure\n *  random byte string or, if the key is to be derived from a password, you\n *  should rely on PBKDF2 functionality provided by OpenSSL::PKCS5. To\n *  generate a secure random-based key, Cipher#random_key may be used.\n *\n *  Only call this method after calling Cipher#encrypt or Cipher#decrypt.\n */\nstatic VALUE\nossl_cipher_set_key(VALUE self, VALUE key)\n{\n    EVP_CIPHER_CTX *ctx;\n    int key_len;\n\n    StringValue(key);\n    GetCipher(self, ctx);\n\n    key_len = EVP_CIPHER_CTX_key_length(ctx);\n    if (RSTRING_LEN(key) != key_len)\n\tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return key;\n}\n\n/*\n *  call-seq:\n *     cipher.iv = string -> string\n *\n *  Sets the cipher IV. Please note that since you should never be using ECB\n *  mode, an IV is always explicitly required and should be set prior to\n *  encryption. The IV itself can be safely transmitted in public, but it\n *  should be unpredictable to prevent certain kinds of attacks. You may use\n *  Cipher#random_iv to create a secure random IV.\n *\n *  Only call this method after calling Cipher#encrypt or Cipher#decrypt.\n *\n *  If not explicitly set, the OpenSSL default of an all-zeroes (\"\\\\0\") IV is\n *  used.\n */\nstatic VALUE\nossl_cipher_set_iv(VALUE self, VALUE iv)\n{\n    EVP_CIPHER_CTX *ctx;\n    int iv_len = 0;\n\n    StringValue(iv);\n    GetCipher(self, ctx);\n\n#if defined(HAVE_AUTHENTICATED_ENCRYPTION)\n    if (EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER)\n\tiv_len = (int)(VALUE)EVP_CIPHER_CTX_get_app_data(ctx);\n#endif\n    if (!iv_len)\n\tiv_len = EVP_CIPHER_CTX_iv_length(ctx);\n    if (RSTRING_LEN(iv) != iv_len)\n\tossl_raise(rb_eArgError, \"iv must be %d bytes\", iv_len);\n\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, NULL, (unsigned char *)RSTRING_PTR(iv), -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return iv;\n}\n\n#ifdef HAVE_AUTHENTICATED_ENCRYPTION\n/*\n *  call-seq:\n *     cipher.auth_data = string -> string\n *\n *  Sets the cipher's additional authenticated data. This field must be\n *  set when using AEAD cipher modes such as GCM or CCM. If no associated\n *  data shall be used, this method must *still* be called with a value of \"\".\n *  The contents of this field should be non-sensitive data which will be\n *  added to the ciphertext to generate the authentication tag which validates\n *  the contents of the ciphertext.\n *\n *  The AAD must be set prior to encryption or decryption. In encryption mode,\n *  it must be set after calling Cipher#encrypt and setting Cipher#key= and\n *  Cipher#iv=. When decrypting, the authenticated data must be set after key,\n *  iv and especially *after* the authentication tag has been set. I.e. set it\n *  only after calling Cipher#decrypt, Cipher#key=, Cipher#iv= and\n *  Cipher#auth_tag= first.\n */\nstatic VALUE\nossl_cipher_set_auth_data(VALUE self, VALUE data)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n\n    StringValue(data);\n\n    in = (unsigned char *) RSTRING_PTR(data);\n    in_len = RSTRING_LEN(data);\n\n    GetCipher(self, ctx);\n\n    if (!ossl_cipher_update_long(ctx, NULL, &out_len, in, in_len))\n        ossl_raise(eCipherError, \"couldn't set additional authenticated data\");\n\n    return data;\n}\n\n/*\n *  call-seq:\n *     cipher.auth_tag(tag_len = 16) -> String\n *\n *  Gets the authentication tag generated by Authenticated Encryption Cipher\n *  modes (GCM for example). This tag may be stored along with the ciphertext,\n *  then set on the decryption cipher to authenticate the contents of the\n *  ciphertext against changes. If the optional integer parameter +tag_len+ is\n *  given, the returned tag will be +tag_len+ bytes long. If the parameter is\n *  omitted, the default length of 16 bytes or the length previously set by\n *  #auth_tag_len= will be used. For maximum security, the longest possible\n *  should be chosen.\n *\n *  The tag may only be retrieved after calling Cipher#final.\n */\nstatic VALUE\nossl_cipher_get_auth_tag(int argc, VALUE *argv, VALUE self)\n{\n    VALUE vtag_len, ret;\n    EVP_CIPHER_CTX *ctx;\n    int tag_len = 16;\n\n    rb_scan_args(argc, argv, \"01\", &vtag_len);\n    if (NIL_P(vtag_len))\n\tvtag_len = rb_attr_get(self, id_auth_tag_len);\n    if (!NIL_P(vtag_len))\n\ttag_len = NUM2INT(vtag_len);\n\n    GetCipher(self, ctx);\n\n    if (!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER))\n\tossl_raise(eCipherError, \"authentication tag not supported by this cipher\");\n\n    ret = rb_str_new(NULL, tag_len);\n    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, tag_len, RSTRING_PTR(ret)))\n\tossl_raise(eCipherError, \"retrieving the authentication tag failed\");\n\n    return ret;\n}\n\n/*\n *  call-seq:\n *     cipher.auth_tag = string -> string\n *\n *  Sets the authentication tag to verify the contents of the\n *  ciphertext. The tag must be set after calling Cipher#decrypt,\n *  Cipher#key= and Cipher#iv=, but before assigning the associated\n *  authenticated data using Cipher#auth_data= and of course, before\n *  decrypting any of the ciphertext. After all decryption is\n *  performed, the tag is verified automatically in the call to\n *  Cipher#final.\n *\n *  For OCB mode, the tag length must be supplied with #auth_tag_len=\n *  beforehand.\n */\nstatic VALUE\nossl_cipher_set_auth_tag(VALUE self, VALUE vtag)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *tag;\n    int tag_len;\n\n    StringValue(vtag);\n    tag = (unsigned char *) RSTRING_PTR(vtag);\n    tag_len = RSTRING_LENINT(vtag);\n\n    GetCipher(self, ctx);\n    if (!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER))\n\tossl_raise(eCipherError, \"authentication tag not supported by this cipher\");\n\n    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, tag_len, tag))\n\tossl_raise(eCipherError, \"unable to set AEAD tag\");\n\n    return vtag;\n}\n\n/*\n *  call-seq:\n *     cipher.auth_tag_len = Integer -> Integer\n *\n *  Sets the length of the authentication tag to be generated or to be given for\n *  AEAD ciphers that requires it as in input parameter. Note that not all AEAD\n *  ciphers support this method.\n *\n *  In OCB mode, the length must be supplied both when encrypting and when\n *  decrypting, and must be before specifying an IV.\n */\nstatic VALUE\nossl_cipher_set_auth_tag_len(VALUE self, VALUE vlen)\n{\n    int tag_len = NUM2INT(vlen);\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n    if (!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER))\n\tossl_raise(eCipherError, \"AEAD not supported by this cipher\");\n\n    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, tag_len, NULL))\n\tossl_raise(eCipherError, \"unable to set authentication tag length\");\n\n    /* for #auth_tag */\n    rb_ivar_set(self, id_auth_tag_len, INT2NUM(tag_len));\n\n    return vlen;\n}\n\n/*\n *  call-seq:\n *     cipher.authenticated? -> boolean\n *\n *  Indicated whether this Cipher instance uses an Authenticated Encryption\n *  mode.\n */\nstatic VALUE\nossl_cipher_is_authenticated(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n\n    return (EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER) ? Qtrue : Qfalse;\n}\n\n/*\n * call-seq:\n *   cipher.iv_len = integer -> integer\n *\n * Sets the IV/nonce length of the Cipher. Normally block ciphers don't allow\n * changing the IV length, but some make use of IV for 'nonce'. You may need\n * this for interoperability with other applications.\n */\nstatic VALUE\nossl_cipher_set_iv_length(VALUE self, VALUE iv_length)\n{\n    int len = NUM2INT(iv_length);\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n    if (!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER))\n\tossl_raise(eCipherError, \"cipher does not support AEAD\");\n\n    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, len, NULL))\n\tossl_raise(eCipherError, \"unable to set IV length\");\n\n    /*\n     * EVP_CIPHER_CTX_iv_length() returns the default length. So we need to save\n     * the length somewhere. Luckily currently we aren't using app_data.\n     */\n    EVP_CIPHER_CTX_set_app_data(ctx, (void *)(VALUE)len);\n\n    return iv_length;\n}\n#else\n#define ossl_cipher_set_auth_data rb_f_notimplement\n#define ossl_cipher_get_auth_tag rb_f_notimplement\n#define ossl_cipher_set_auth_tag rb_f_notimplement\n#define ossl_cipher_set_auth_tag_len rb_f_notimplement\n#define ossl_cipher_is_authenticated rb_f_notimplement\n#define ossl_cipher_set_iv_length rb_f_notimplement\n#endif\n\n/*\n *  call-seq:\n *     cipher.key_len = integer -> integer\n *\n *  Sets the key length of the cipher.  If the cipher is a fixed length cipher\n *  then attempting to set the key length to any value other than the fixed\n *  value is an error.\n *\n *  Under normal circumstances you do not need to call this method (and probably shouldn't).\n *\n *  See EVP_CIPHER_CTX_set_key_length for further information.\n */\nstatic VALUE\nossl_cipher_set_key_length(VALUE self, VALUE key_length)\n{\n    int len = NUM2INT(key_length);\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n    if (EVP_CIPHER_CTX_set_key_length(ctx, len) != 1)\n        ossl_raise(eCipherError, NULL);\n\n    return key_length;\n}\n\n/*\n *  call-seq:\n *     cipher.padding = integer -> integer\n *\n *  Enables or disables padding. By default encryption operations are padded using standard block padding and the\n *  padding is checked and removed when decrypting. If the pad parameter is zero then no padding is performed, the\n *  total amount of data encrypted or decrypted must then be a multiple of the block size or an error will occur.\n *\n *  See EVP_CIPHER_CTX_set_padding for further information.\n */\nstatic VALUE\nossl_cipher_set_padding(VALUE self, VALUE padding)\n{\n    EVP_CIPHER_CTX *ctx;\n    int pad = NUM2INT(padding);\n\n    GetCipher(self, ctx);\n    if (EVP_CIPHER_CTX_set_padding(ctx, pad) != 1)\n\tossl_raise(eCipherError, NULL);\n    return padding;\n}\n\n/*\n *  call-seq:\n *     cipher.key_len -> integer\n *\n *  Returns the key length in bytes of the Cipher.\n */\nstatic VALUE\nossl_cipher_key_length(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n\n    return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));\n}\n\n/*\n *  call-seq:\n *     cipher.iv_len -> integer\n *\n *  Returns the expected length in bytes for an IV for this Cipher.\n */\nstatic VALUE\nossl_cipher_iv_length(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    int len = 0;\n\n    GetCipher(self, ctx);\n#if defined(HAVE_AUTHENTICATED_ENCRYPTION)\n    if (EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER)\n\tlen = (int)(VALUE)EVP_CIPHER_CTX_get_app_data(ctx);\n#endif\n    if (!len)\n\tlen = EVP_CIPHER_CTX_iv_length(ctx);\n\n    return INT2NUM(len);\n}\n\n/*\n *  call-seq:\n *     cipher.block_size -> integer\n *\n *  Returns the size in bytes of the blocks on which this Cipher operates on.\n */\nstatic VALUE\nossl_cipher_block_size(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n\n    return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));\n}\n\n/*\n * INIT\n */\nvoid\nInit_ossl_cipher(void)\n{\n#if 0\n    mOSSL = rb_define_module(\"OpenSSL\");\n    eOSSLError = rb_define_class_under(mOSSL, \"OpenSSLError\", rb_eStandardError);\n#endif\n\n    /* Document-class: OpenSSL::Cipher\n     *\n     * Provides symmetric algorithms for encryption and decryption. The\n     * algorithms that are available depend on the particular version\n     * of OpenSSL that is installed.\n     *\n     * === Listing all supported algorithms\n     *\n     * A list of supported algorithms can be obtained by\n     *\n     *   puts OpenSSL::Cipher.ciphers\n     *\n     * === Instantiating a Cipher\n     *\n     * There are several ways to create a Cipher instance. Generally, a\n     * Cipher algorithm is categorized by its name, the key length in bits\n     * and the cipher mode to be used. The most generic way to create a\n     * Cipher is the following\n     *\n     *   cipher = OpenSSL::Cipher.new('<name>-<key length>-<mode>')\n     *\n     * That is, a string consisting of the hyphenated concatenation of the\n     * individual components name, key length and mode. Either all uppercase\n     * or all lowercase strings may be used, for example:\n     *\n     *  cipher = OpenSSL::Cipher.new('AES-128-CBC')\n     *\n     * For each algorithm supported, there is a class defined under the\n     * Cipher class that goes by the name of the cipher, e.g. to obtain an\n     * instance of AES, you could also use\n     *\n     *   # these are equivalent\n     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   cipher = OpenSSL::Cipher::AES.new(128, 'CBC')\n     *   cipher = OpenSSL::Cipher::AES.new('128-CBC')\n     *\n     * Finally, due to its wide-spread use, there are also extra classes\n     * defined for the different key sizes of AES\n     *\n     *   cipher = OpenSSL::Cipher::AES128.new(:CBC)\n     *   cipher = OpenSSL::Cipher::AES192.new(:CBC)\n     *   cipher = OpenSSL::Cipher::AES256.new(:CBC)\n     *\n     * === Choosing either encryption or decryption mode\n     *\n     * Encryption and decryption are often very similar operations for\n     * symmetric algorithms, this is reflected by not having to choose\n     * different classes for either operation, both can be done using the\n     * same class. Still, after obtaining a Cipher instance, we need to\n     * tell the instance what it is that we intend to do with it, so we\n     * need to call either\n     *\n     *   cipher.encrypt\n     *\n     * or\n     *\n     *   cipher.decrypt\n     *\n     * on the Cipher instance. This should be the first call after creating\n     * the instance, otherwise configuration that has already been set could\n     * get lost in the process.\n     *\n     * === Choosing a key\n     *\n     * Symmetric encryption requires a key that is the same for the encrypting\n     * and for the decrypting party and after initial key establishment should\n     * be kept as private information. There are a lot of ways to create\n     * insecure keys, the most notable is to simply take a password as the key\n     * without processing the password further. A simple and secure way to\n     * create a key for a particular Cipher is\n     *\n     *  cipher = OpenSSL::AES256.new(:CFB)\n     *  cipher.encrypt\n     *  key = cipher.random_key # also sets the generated key on the Cipher\n     *\n     * If you absolutely need to use passwords as encryption keys, you\n     * should use Password-Based Key Derivation Function 2 (PBKDF2) by\n     * generating the key with the help of the functionality provided by\n     * OpenSSL::PKCS5.pbkdf2_hmac_sha1 or OpenSSL::PKCS5.pbkdf2_hmac.\n     *\n     * Although there is Cipher#pkcs5_keyivgen, its use is deprecated and\n     * it should only be used in legacy applications because it does not use\n     * the newer PKCS#5 v2 algorithms.\n     *\n     * === Choosing an IV\n     *\n     * The cipher modes CBC, CFB, OFB and CTR all need an \"initialization\n     * vector\", or short, IV. ECB mode is the only mode that does not require\n     * an IV, but there is almost no legitimate use case for this mode\n     * because of the fact that it does not sufficiently hide plaintext\n     * patterns. Therefore\n     *\n     * <b>You should never use ECB mode unless you are absolutely sure that\n     * you absolutely need it</b>\n     *\n     * Because of this, you will end up with a mode that explicitly requires\n     * an IV in any case. Note that for backwards compatibility reasons,\n     * setting an IV is not explicitly mandated by the Cipher API. If not\n     * set, OpenSSL itself defaults to an all-zeroes IV (\"\\\\0\", not the\n     * character). Although the IV can be seen as public information, i.e.\n     * it may be transmitted in public once generated, it should still stay\n     * unpredictable to prevent certain kinds of attacks. Therefore, ideally\n     *\n     * <b>Always create a secure random IV for every encryption of your\n     * Cipher</b>\n     *\n     * A new, random IV should be created for every encryption of data. Think\n     * of the IV as a nonce (number used once) - it's public but random and\n     * unpredictable. A secure random IV can be created as follows\n     *\n     *   cipher = ...\n     *   cipher.encrypt\n     *   key = cipher.random_key\n     *   iv = cipher.random_iv # also sets the generated IV on the Cipher\n     *\n     * Although the key is generally a random value, too, it is a bad choice\n     * as an IV. There are elaborate ways how an attacker can take advantage\n     * of such an IV. As a general rule of thumb, exposing the key directly\n     * or indirectly should be avoided at all cost and exceptions only be\n     * made with good reason.\n     *\n     * === Calling Cipher#final\n     *\n     * ECB (which should not be used) and CBC are both block-based modes.\n     * This means that unlike for the other streaming-based modes, they\n     * operate on fixed-size blocks of data, and therefore they require a\n     * \"finalization\" step to produce or correctly decrypt the last block of\n     * data by appropriately handling some form of padding. Therefore it is\n     * essential to add the output of OpenSSL::Cipher#final to your\n     * encryption/decryption buffer or you will end up with decryption errors\n     * or truncated data.\n     *\n     * Although this is not really necessary for streaming-mode ciphers, it is\n     * still recommended to apply the same pattern of adding the output of\n     * Cipher#final there as well - it also enables you to switch between\n     * modes more easily in the future.\n     *\n     * === Encrypting and decrypting some data\n     *\n     *   data = \"Very, very confidential data\"\n     *\n     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   cipher.encrypt\n     *   key = cipher.random_key\n     *   iv = cipher.random_iv\n     *\n     *   encrypted = cipher.update(data) + cipher.final\n     *   ...\n     *   decipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   decipher.decrypt\n     *   decipher.key = key\n     *   decipher.iv = iv\n     *\n     *   plain = decipher.update(encrypted) + decipher.final\n     *\n     *   puts data == plain #=> true\n     *\n     * === Authenticated Encryption and Associated Data (AEAD)\n     *\n     * If the OpenSSL version used supports it, an Authenticated Encryption\n     * mode (such as GCM or CCM) should always be preferred over any\n     * unauthenticated mode. Currently, OpenSSL supports AE only in combination\n     * with Associated Data (AEAD) where additional associated data is included\n     * in the encryption process to compute a tag at the end of the encryption.\n     * This tag will also be used in the decryption process and by verifying\n     * its validity, the authenticity of a given ciphertext is established.\n     *\n     * This is superior to unauthenticated modes in that it allows to detect\n     * if somebody effectively changed the ciphertext after it had been\n     * encrypted. This prevents malicious modifications of the ciphertext that\n     * could otherwise be exploited to modify ciphertexts in ways beneficial to\n     * potential attackers.\n     *\n     * An associated data is used where there is additional information, such as\n     * headers or some metadata, that must be also authenticated but not\n     * necessarily need to be encrypted. If no associated data is needed for\n     * encryption and later decryption, the OpenSSL library still requires a\n     * value to be set - \"\" may be used in case none is available.\n     *\n     * An example using the GCM (Galois/Counter Mode). You have 16 bytes +key+,\n     * 12 bytes (96 bits) +nonce+ and the associated data +auth_data+. Be sure\n     * not to reuse the +key+ and +nonce+ pair. Reusing an nonce ruins the\n     * security gurantees of GCM mode.\n     *\n     *   cipher = OpenSSL::Cipher::AES.new(128, :GCM).encrypt\n     *   cipher.key = key\n     *   cipher.iv = nonce\n     *   cipher.auth_data = auth_data\n     *\n     *   encrypted = cipher.update(data) + cipher.final\n     *   tag = cipher.auth_tag # produces 16 bytes tag by default\n     *\n     * Now you are the receiver. You know the +key+ and have received +nonce+,\n     * +auth_data+, +encrypted+ and +tag+ through an untrusted network. Note\n     * that GCM accepts an arbitrary length tag between 1 and 16 bytes. You may\n     * additionally need to check that the received tag has the correct length,\n     * or you allow attackers to forge a valid single byte tag for the tampered\n     * ciphertext with a probability of 1/256.\n     *\n     *   raise \"tag is truncated!\" unless tag.bytesize == 16\n     *   decipher = OpenSSL::Cipher::AES.new(128, :GCM).decrypt\n     *   decipher.key = key\n     *   decipher.iv = nonce\n     *   decipher.auth_tag = tag\n     *   decipher.auth_data = auth_data\n     *\n     *   decrypted = decipher.update(encrypted) + decipher.final\n     *\n     *   puts data == decrypted #=> true\n     */\n    cCipher = rb_define_class_under(mOSSL, \"Cipher\", rb_cObject);\n    eCipherError = rb_define_class_under(cCipher, \"CipherError\", eOSSLError);\n\n    rb_define_alloc_func(cCipher, ossl_cipher_alloc);\n    rb_define_copy_func(cCipher, ossl_cipher_copy);\n    rb_define_module_function(cCipher, \"ciphers\", ossl_s_ciphers, 0);\n    rb_define_method(cCipher, \"initialize\", ossl_cipher_initialize, 1);\n    rb_define_method(cCipher, \"reset\", ossl_cipher_reset, 0);\n    rb_define_method(cCipher, \"encrypt\", ossl_cipher_encrypt, -1);\n    rb_define_method(cCipher, \"decrypt\", ossl_cipher_decrypt, -1);\n    rb_define_method(cCipher, \"pkcs5_keyivgen\", ossl_cipher_pkcs5_keyivgen, -1);\n    rb_define_method(cCipher, \"update\", ossl_cipher_update, -1);\n    rb_define_method(cCipher, \"final\", ossl_cipher_final, 0);\n    rb_define_method(cCipher, \"name\", ossl_cipher_name, 0);\n    rb_define_method(cCipher, \"key=\", ossl_cipher_set_key, 1);\n    rb_define_method(cCipher, \"auth_data=\", ossl_cipher_set_auth_data, 1);\n    rb_define_method(cCipher, \"auth_tag=\", ossl_cipher_set_auth_tag, 1);\n    rb_define_method(cCipher, \"auth_tag\", ossl_cipher_get_auth_tag, -1);\n    rb_define_method(cCipher, \"auth_tag_len=\", ossl_cipher_set_auth_tag_len, 1);\n    rb_define_method(cCipher, \"authenticated?\", ossl_cipher_is_authenticated, 0);\n    rb_define_method(cCipher, \"key_len=\", ossl_cipher_set_key_length, 1);\n    rb_define_method(cCipher, \"key_len\", ossl_cipher_key_length, 0);\n    rb_define_method(cCipher, \"iv=\", ossl_cipher_set_iv, 1);\n    rb_define_method(cCipher, \"iv_len=\", ossl_cipher_set_iv_length, 1);\n    rb_define_method(cCipher, \"iv_len\", ossl_cipher_iv_length, 0);\n    rb_define_method(cCipher, \"block_size\", ossl_cipher_block_size, 0);\n    rb_define_method(cCipher, \"padding=\", ossl_cipher_set_padding, 1);\n\n    id_auth_tag_len = rb_intern_const(\"auth_tag_len\");\n}\n", "# frozen_string_literal: false\nrequire_relative 'utils'\n\nif defined?(OpenSSL::TestUtils)\n\nclass OpenSSL::TestCipher < OpenSSL::TestCase\n\n  @ciphers = OpenSSL::Cipher.ciphers\n\n  class << self\n\n    def has_cipher?(name)\n      @ciphers.include?(name)\n    end\n\n    def has_ciphers?(list)\n      list.all? { |name| has_cipher?(name) }\n    end\n\n  end\n\n  def setup\n    @c1 = OpenSSL::Cipher.new(\"DES-EDE3-CBC\")\n    @c2 = OpenSSL::Cipher::DES.new(:EDE3, \"CBC\")\n    @key = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n    @iv = \"\\0\\0\\0\\0\\0\\0\\0\\0\"\n    @hexkey = \"0000000000000000000000000000000000000000000000\"\n    @hexiv = \"0000000000000000\"\n    @data = \"DATA\"\n  end\n\n  def teardown\n    super\n    @c1 = @c2 = nil\n  end\n\n  def test_crypt\n    @c1.encrypt.pkcs5_keyivgen(@key, @iv)\n    @c2.encrypt.pkcs5_keyivgen(@key, @iv)\n    s1 = @c1.update(@data) + @c1.final\n    s2 = @c2.update(@data) + @c2.final\n    assert_equal(s1, s2, \"encrypt\")\n\n    @c1.decrypt.pkcs5_keyivgen(@key, @iv)\n    @c2.decrypt.pkcs5_keyivgen(@key, @iv)\n    assert_equal(@data, @c1.update(s1)+@c1.final, \"decrypt\")\n    assert_equal(@data, @c2.update(s2)+@c2.final, \"decrypt\")\n  end\n\n  def test_info\n    assert_equal(\"DES-EDE3-CBC\", @c1.name, \"name\")\n    assert_equal(\"DES-EDE3-CBC\", @c2.name, \"name\")\n    assert_kind_of(Integer, @c1.key_len, \"key_len\")\n    assert_kind_of(Integer, @c1.iv_len, \"iv_len\")\n  end\n\n  def test_dup\n    assert_equal(@c1.name, @c1.dup.name, \"dup\")\n    assert_equal(@c1.name, @c1.clone.name, \"clone\")\n    @c1.encrypt\n    @c1.key = @key\n    @c1.iv = @iv\n    tmpc = @c1.dup\n    s1 = @c1.update(@data) + @c1.final\n    s2 = tmpc.update(@data) + tmpc.final\n    assert_equal(s1, s2, \"encrypt dup\")\n  end\n\n  def test_reset\n    @c1.encrypt\n    @c1.key = @key\n    @c1.iv = @iv\n    s1 = @c1.update(@data) + @c1.final\n    @c1.reset\n    s2 = @c1.update(@data) + @c1.final\n    assert_equal(s1, s2, \"encrypt reset\")\n  end\n\n  def test_key_iv_set\n    # default value for DES-EDE3-CBC\n    assert_equal(24, @c1.key_len)\n    assert_equal(8, @c1.iv_len)\n    assert_raise(ArgumentError) { @c1.key = \"\\x01\" * 23 }\n    @c1.key = \"\\x01\" * 24\n    assert_raise(ArgumentError) { @c1.key = \"\\x01\" * 25 }\n    assert_raise(ArgumentError) { @c1.iv = \"\\x01\" * 7 }\n    @c1.iv = \"\\x01\" * 8\n    assert_raise(ArgumentError) { @c1.iv = \"\\x01\" * 9 }\n  end\n\n  def test_empty_data\n    @c1.encrypt\n    assert_raise(ArgumentError){ @c1.update(\"\") }\n  end\n\n  def test_initialize\n    assert_raise(RuntimeError) {@c1.__send__(:initialize, \"DES-EDE3-CBC\")}\n    assert_raise(RuntimeError) {OpenSSL::Cipher.allocate.final}\n  end\n\n  def test_ctr_if_exists\n    begin\n      cipher = OpenSSL::Cipher.new('aes-128-ctr')\n      cipher.encrypt\n      cipher.pkcs5_keyivgen('password')\n      c = cipher.update('hello,world') + cipher.final\n      cipher.decrypt\n      cipher.pkcs5_keyivgen('password')\n      assert_equal('hello,world', cipher.update(c) + cipher.final)\n    end\n  end if has_cipher?('aes-128-ctr')\n\n  def test_ciphers\n    OpenSSL::Cipher.ciphers.each{|name|\n      next if /netbsd/ =~ RUBY_PLATFORM && /idea|rc5/i =~ name\n      begin\n        assert_kind_of(OpenSSL::Cipher, OpenSSL::Cipher.new(name))\n      rescue OpenSSL::Cipher::CipherError => e\n        raise unless /wrap/ =~ name and /wrap mode not allowed/ =~ e.message\n      end\n    }\n  end\n\n  def test_AES\n    pt = File.read(__FILE__)\n    %w(ECB CBC CFB OFB).each{|mode|\n      c1 = OpenSSL::Cipher::AES256.new(mode)\n      c1.encrypt\n      c1.pkcs5_keyivgen(\"passwd\")\n      ct = c1.update(pt) + c1.final\n\n      c2 = OpenSSL::Cipher::AES256.new(mode)\n      c2.decrypt\n      c2.pkcs5_keyivgen(\"passwd\")\n      assert_equal(pt, c2.update(ct) + c2.final)\n    }\n  end\n\n  def test_AES_crush\n    500.times do\n      assert_nothing_raised(\"[Bug #2768]\") do\n        # it caused OpenSSL SEGV by uninitialized key\n        OpenSSL::Cipher::AES128.new(\"ECB\").update \".\" * 17\n      end\n    end\n  end\n\n  if has_ciphers?(['aes-128-gcm', 'aes-192-gcm', 'aes-256-gcm'])\n\n    def test_authenticated\n      cipher = OpenSSL::Cipher.new('aes-128-gcm')\n      assert_predicate(cipher, :authenticated?)\n      cipher = OpenSSL::Cipher.new('aes-128-cbc')\n      assert_not_predicate(cipher, :authenticated?)\n    end\n\n    def test_aes_gcm\n      ['aes-128-gcm', 'aes-192-gcm', 'aes-256-gcm'].each do |algo|\n        pt = \"You should all use Authenticated Encryption!\"\n        cipher, key, iv = new_encryptor(algo)\n\n        cipher.auth_data = \"aad\"\n        ct  = cipher.update(pt) + cipher.final\n        tag = cipher.auth_tag\n        assert_equal(16, tag.size)\n\n        decipher = new_decryptor(algo, key, iv)\n        decipher.auth_tag = tag\n        decipher.auth_data = \"aad\"\n\n        assert_equal(pt, decipher.update(ct) + decipher.final)\n      end\n    end\n\n    def test_aes_gcm_short_tag\n      ['aes-128-gcm', 'aes-192-gcm', 'aes-256-gcm'].each do |algo|\n        pt = \"You should all use Authenticated Encryption!\"\n        cipher, key, iv = new_encryptor(algo)\n\n        cipher.auth_data = \"aad\"\n        ct  = cipher.update(pt) + cipher.final\n        tag = cipher.auth_tag(8)\n        assert_equal(8, tag.size)\n\n        decipher = new_decryptor(algo, key, iv)\n        decipher.auth_tag = tag\n        decipher.auth_data = \"aad\"\n\n        assert_equal(pt, decipher.update(ct) + decipher.final)\n      end\n    end\n\n    def test_aes_gcm_wrong_tag\n      pt = \"You should all use Authenticated Encryption!\"\n      cipher, key, iv = new_encryptor('aes-128-gcm')\n\n      cipher.auth_data = \"aad\"\n      ct  = cipher.update(pt) + cipher.final\n      tag = cipher.auth_tag\n\n      decipher = new_decryptor('aes-128-gcm', key, iv)\n      tag.setbyte(-1, (tag.getbyte(-1) + 1) & 0xff)\n      decipher.auth_tag = tag\n      decipher.auth_data = \"aad\"\n\n      assert_raise OpenSSL::Cipher::CipherError do\n        decipher.update(ct) + decipher.final\n      end\n    end\n\n    def test_aes_gcm_wrong_auth_data\n      pt = \"You should all use Authenticated Encryption!\"\n      cipher, key, iv = new_encryptor('aes-128-gcm')\n\n      cipher.auth_data = \"aad\"\n      ct  = cipher.update(pt) + cipher.final\n      tag = cipher.auth_tag\n\n      decipher = new_decryptor('aes-128-gcm', key, iv)\n      decipher.auth_tag = tag\n      decipher.auth_data = \"daa\"\n\n      assert_raise OpenSSL::Cipher::CipherError do\n        decipher.update(ct) + decipher.final\n      end\n    end\n\n    def test_aes_gcm_wrong_ciphertext\n      pt = \"You should all use Authenticated Encryption!\"\n      cipher, key, iv = new_encryptor('aes-128-gcm')\n\n      cipher.auth_data = \"aad\"\n      ct  = cipher.update(pt) + cipher.final\n      tag = cipher.auth_tag\n\n      decipher = new_decryptor('aes-128-gcm', key, iv)\n      decipher.auth_tag = tag\n      decipher.auth_data = \"aad\"\n\n      assert_raise OpenSSL::Cipher::CipherError do\n        decipher.update(ct[0..-2] << ct[-1].succ) + decipher.final\n      end\n    end\n\n    def test_aes_gcm_variable_iv_len\n      pt = \"You should all use Authenticated Encryption!\"\n      cipher = OpenSSL::Cipher.new(\"aes-128-gcm\").encrypt\n      cipher.key = \"x\" * 16\n      assert_equal(12, cipher.iv_len)\n      cipher.iv = \"a\" * 12\n      ct1 = cipher.update(pt) << cipher.final\n      tag1 = cipher.auth_tag\n\n      cipher = OpenSSL::Cipher.new(\"aes-128-gcm\").encrypt\n      cipher.key = \"x\" * 16\n      cipher.iv_len = 10\n      assert_equal(10, cipher.iv_len)\n      cipher.iv = \"a\" * 10\n      ct2 = cipher.update(pt) << cipher.final\n      tag2 = cipher.auth_tag\n\n      assert_not_equal ct1, ct2\n      assert_not_equal tag1, tag2\n\n      decipher = OpenSSL::Cipher.new(\"aes-128-gcm\").decrypt\n      decipher.auth_tag = tag1\n      decipher.key = \"x\" * 16\n      decipher.iv_len = 12\n      decipher.iv = \"a\" * 12\n      assert_equal(pt, decipher.update(ct1) << decipher.final)\n\n      decipher.reset\n      decipher.auth_tag = tag2\n      assert_raise(OpenSSL::Cipher::CipherError) {\n        decipher.update(ct2) << decipher.final\n      }\n\n      decipher.reset\n      decipher.auth_tag = tag2\n      decipher.iv_len = 10\n      decipher.iv = \"a\" * 10\n      assert_equal(pt, decipher.update(ct2) << decipher.final)\n    end\n\n  end\n\n  def test_aes_ocb_tag_len\n    pt = \"You should all use Authenticated Encryption!\"\n    cipher = OpenSSL::Cipher.new(\"aes-128-ocb\").encrypt\n    cipher.auth_tag_len = 14\n    cipher.iv_len = 8\n    key = cipher.random_key\n    iv = cipher.random_iv\n    cipher.auth_data = \"aad\"\n    ct  = cipher.update(pt) + cipher.final\n    tag = cipher.auth_tag\n    assert_equal(14, tag.size)\n\n    decipher = OpenSSL::Cipher.new(\"aes-128-ocb\").decrypt\n    decipher.auth_tag_len = 14\n    decipher.auth_tag = tag\n    decipher.iv_len = 8\n    decipher.key = key\n    decipher.iv = iv\n    decipher.auth_data = \"aad\"\n    assert_equal(pt, decipher.update(ct) + decipher.final)\n\n    decipher = OpenSSL::Cipher.new(\"aes-128-ocb\").decrypt\n    decipher.auth_tag_len = 9\n    decipher.auth_tag = tag[0, 9]\n    decipher.iv_len = 8\n    decipher.key = key\n    decipher.iv = iv\n    decipher.auth_data = \"aad\"\n    assert_raise(OpenSSL::Cipher::CipherError) {\n      decipher.update(ct) + decipher.final\n    }\n  end if has_cipher?(\"aes-128-ocb\")\n\n  private\n\n  def new_encryptor(algo)\n    cipher = OpenSSL::Cipher.new(algo)\n    cipher.encrypt\n    key = cipher.random_key\n    iv = cipher.random_iv\n    [cipher, key, iv]\n  end\n\n  def new_decryptor(algo, key, iv)\n    OpenSSL::Cipher.new(algo).tap do |cipher|\n      cipher.decrypt\n      cipher.key = key\n      cipher.iv = iv\n    end\n  end\n\nend\n\nend\n"], "fixing_code": ["/*\n * 'OpenSSL for Ruby' project\n * Copyright (C) 2001-2002  Michal Rokos <m.rokos@sh.cvut.cz>\n * All rights reserved.\n */\n/*\n * This program is licensed under the same licence as Ruby.\n * (See the file 'LICENCE'.)\n */\n#include \"ossl.h\"\n\n#define NewCipher(klass) \\\n    TypedData_Wrap_Struct((klass), &ossl_cipher_type, 0)\n#define AllocCipher(obj, ctx) do { \\\n    (ctx) = EVP_CIPHER_CTX_new(); \\\n    if (!(ctx)) \\\n\tossl_raise(rb_eRuntimeError, NULL); \\\n    RTYPEDDATA_DATA(obj) = (ctx); \\\n} while (0)\n#define GetCipherInit(obj, ctx) do { \\\n    TypedData_Get_Struct((obj), EVP_CIPHER_CTX, &ossl_cipher_type, (ctx)); \\\n} while (0)\n#define GetCipher(obj, ctx) do { \\\n    GetCipherInit((obj), (ctx)); \\\n    if (!(ctx)) { \\\n\tossl_raise(rb_eRuntimeError, \"Cipher not inititalized!\"); \\\n    } \\\n} while (0)\n#define SafeGetCipher(obj, ctx) do { \\\n    OSSL_Check_Kind((obj), cCipher); \\\n    GetCipher((obj), (ctx)); \\\n} while (0)\n\n/*\n * Classes\n */\nVALUE cCipher;\nVALUE eCipherError;\nstatic ID id_auth_tag_len, id_key_set;\n\nstatic VALUE ossl_cipher_alloc(VALUE klass);\nstatic void ossl_cipher_free(void *ptr);\n\nstatic const rb_data_type_t ossl_cipher_type = {\n    \"OpenSSL/Cipher\",\n    {\n\t0, ossl_cipher_free,\n    },\n    0, 0, RUBY_TYPED_FREE_IMMEDIATELY,\n};\n\n/*\n * PUBLIC\n */\nconst EVP_CIPHER *\nGetCipherPtr(VALUE obj)\n{\n    if (rb_obj_is_kind_of(obj, cCipher)) {\n\tEVP_CIPHER_CTX *ctx;\n\n\tGetCipher(obj, ctx);\n\n\treturn EVP_CIPHER_CTX_cipher(ctx);\n    }\n    else {\n\tconst EVP_CIPHER *cipher;\n\n\tStringValueCStr(obj);\n\tcipher = EVP_get_cipherbyname(RSTRING_PTR(obj));\n\tif (!cipher)\n\t    ossl_raise(rb_eArgError,\n\t\t       \"unsupported cipher algorithm: %\"PRIsVALUE, obj);\n\n\treturn cipher;\n    }\n}\n\nVALUE\nossl_cipher_new(const EVP_CIPHER *cipher)\n{\n    VALUE ret;\n    EVP_CIPHER_CTX *ctx;\n\n    ret = ossl_cipher_alloc(cCipher);\n    AllocCipher(ret, ctx);\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return ret;\n}\n\n/*\n * PRIVATE\n */\nstatic void\nossl_cipher_free(void *ptr)\n{\n    EVP_CIPHER_CTX_free(ptr);\n}\n\nstatic VALUE\nossl_cipher_alloc(VALUE klass)\n{\n    return NewCipher(klass);\n}\n\n/*\n *  call-seq:\n *     Cipher.new(string) -> cipher\n *\n *  The string must contain a valid cipher name like \"AES-128-CBC\" or \"3DES\".\n *\n *  A list of cipher names is available by calling OpenSSL::Cipher.ciphers.\n */\nstatic VALUE\nossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return self;\n}\n\nstatic VALUE\nossl_cipher_copy(VALUE self, VALUE other)\n{\n    EVP_CIPHER_CTX *ctx1, *ctx2;\n\n    rb_check_frozen(self);\n    if (self == other) return self;\n\n    GetCipherInit(self, ctx1);\n    if (!ctx1) {\n\tAllocCipher(self, ctx1);\n    }\n    SafeGetCipher(other, ctx2);\n    if (EVP_CIPHER_CTX_copy(ctx1, ctx2) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return self;\n}\n\nstatic void*\nadd_cipher_name_to_ary(const OBJ_NAME *name, VALUE ary)\n{\n    rb_ary_push(ary, rb_str_new2(name->name));\n    return NULL;\n}\n\n/*\n *  call-seq:\n *     OpenSSL::Cipher.ciphers -> array[string...]\n *\n *  Returns the names of all available ciphers in an array.\n */\nstatic VALUE\nossl_s_ciphers(VALUE self)\n{\n    VALUE ary;\n\n    ary = rb_ary_new();\n    OBJ_NAME_do_all_sorted(OBJ_NAME_TYPE_CIPHER_METH,\n                    (void(*)(const OBJ_NAME*,void*))add_cipher_name_to_ary,\n                    (void*)ary);\n\n    return ary;\n}\n\n/*\n *  call-seq:\n *     cipher.reset -> self\n *\n *  Fully resets the internal state of the Cipher. By using this, the same\n *  Cipher instance may be used several times for encryption or decryption tasks.\n *\n *  Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1).\n */\nstatic VALUE\nossl_cipher_reset(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return self;\n}\n\nstatic VALUE\nossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char key[EVP_MAX_KEY_LENGTH], *p_key = NULL;\n    unsigned char iv[EVP_MAX_IV_LENGTH], *p_iv = NULL;\n    VALUE pass, init_v;\n\n    if(rb_scan_args(argc, argv, \"02\", &pass, &init_v) > 0){\n\t/*\n\t * oops. this code mistakes salt for IV.\n\t * We deprecated the arguments for this method, but we decided\n\t * keeping this behaviour for backward compatibility.\n\t */\n\tVALUE cname  = rb_class_path(rb_obj_class(self));\n\trb_warn(\"arguments for %\"PRIsVALUE\"#encrypt and %\"PRIsVALUE\"#decrypt were deprecated; \"\n                \"use %\"PRIsVALUE\"#pkcs5_keyivgen to derive key and IV\",\n                cname, cname, cname);\n\tStringValue(pass);\n\tGetCipher(self, ctx);\n\tif (NIL_P(init_v)) memcpy(iv, \"OpenSSL for Ruby rulez!\", sizeof(iv));\n\telse{\n\t    StringValue(init_v);\n\t    if (EVP_MAX_IV_LENGTH > RSTRING_LEN(init_v)) {\n\t\tmemset(iv, 0, EVP_MAX_IV_LENGTH);\n\t\tmemcpy(iv, RSTRING_PTR(init_v), RSTRING_LEN(init_v));\n\t    }\n\t    else memcpy(iv, RSTRING_PTR(init_v), sizeof(iv));\n\t}\n\tEVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), EVP_md5(), iv,\n\t\t       (unsigned char *)RSTRING_PTR(pass), RSTRING_LENINT(pass), 1, key, NULL);\n\tp_key = key;\n\tp_iv = iv;\n    }\n    else {\n\tGetCipher(self, ctx);\n    }\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, p_key, p_iv, mode) != 1) {\n\tossl_raise(eCipherError, NULL);\n    }\n\n    if (p_key)\n\trb_ivar_set(self, id_key_set, Qtrue);\n\n    return self;\n}\n\n/*\n *  call-seq:\n *     cipher.encrypt -> self\n *\n *  Initializes the Cipher for encryption.\n *\n *  Make sure to call Cipher#encrypt or Cipher#decrypt before using any of the\n *  following methods:\n *  * [#key=, #iv=, #random_key, #random_iv, #pkcs5_keyivgen]\n *\n *  Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 1).\n */\nstatic VALUE\nossl_cipher_encrypt(int argc, VALUE *argv, VALUE self)\n{\n    return ossl_cipher_init(argc, argv, self, 1);\n}\n\n/*\n *  call-seq:\n *     cipher.decrypt -> self\n *\n *  Initializes the Cipher for decryption.\n *\n *  Make sure to call Cipher#encrypt or Cipher#decrypt before using any of the\n *  following methods:\n *  * [#key=, #iv=, #random_key, #random_iv, #pkcs5_keyivgen]\n *\n *  Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 0).\n */\nstatic VALUE\nossl_cipher_decrypt(int argc, VALUE *argv, VALUE self)\n{\n    return ossl_cipher_init(argc, argv, self, 0);\n}\n\n/*\n *  call-seq:\n *     cipher.pkcs5_keyivgen(pass, salt = nil, iterations = 2048, digest = \"MD5\") -> nil\n *\n *  Generates and sets the key/IV based on a password.\n *\n *  *WARNING*: This method is only PKCS5 v1.5 compliant when using RC2, RC4-40,\n *  or DES with MD5 or SHA1. Using anything else (like AES) will generate the\n *  key/iv using an OpenSSL specific method. This method is deprecated and\n *  should no longer be used. Use a PKCS5 v2 key generation method from\n *  OpenSSL::PKCS5 instead.\n *\n *  === Parameters\n *  * +salt+ must be an 8 byte string if provided.\n *  * +iterations+ is a integer with a default of 2048.\n *  * +digest+ is a Digest object that defaults to 'MD5'\n *\n *  A minimum of 1000 iterations is recommended.\n *\n */\nstatic VALUE\nossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_MD *digest;\n    VALUE vpass, vsalt, viter, vdigest;\n    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH], *salt = NULL;\n    int iter;\n\n    rb_scan_args(argc, argv, \"13\", &vpass, &vsalt, &viter, &vdigest);\n    StringValue(vpass);\n    if(!NIL_P(vsalt)){\n\tStringValue(vsalt);\n\tif(RSTRING_LEN(vsalt) != PKCS5_SALT_LEN)\n\t    ossl_raise(eCipherError, \"salt must be an 8-octet string\");\n\tsalt = (unsigned char *)RSTRING_PTR(vsalt);\n    }\n    iter = NIL_P(viter) ? 2048 : NUM2INT(viter);\n    digest = NIL_P(vdigest) ? EVP_md5() : GetDigestPtr(vdigest);\n    GetCipher(self, ctx);\n    EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), digest, salt,\n\t\t   (unsigned char *)RSTRING_PTR(vpass), RSTRING_LENINT(vpass), iter, key, iv);\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    OPENSSL_cleanse(key, sizeof key);\n    OPENSSL_cleanse(iv, sizeof iv);\n\n    rb_ivar_set(self, id_key_set, Qtrue);\n\n    return Qnil;\n}\n\nstatic int\nossl_cipher_update_long(EVP_CIPHER_CTX *ctx, unsigned char *out, long *out_len_ptr,\n\t\t\tconst unsigned char *in, long in_len)\n{\n    int out_part_len;\n    int limit = INT_MAX / 2 + 1;\n    long out_len = 0;\n\n    do {\n\tint in_part_len = in_len > limit ? limit : (int)in_len;\n\n\tif (!EVP_CipherUpdate(ctx, out ? (out + out_len) : 0,\n\t\t\t      &out_part_len, in, in_part_len))\n\t    return 0;\n\n\tout_len += out_part_len;\n\tin += in_part_len;\n    } while ((in_len -= limit) > 0);\n\n    if (out_len_ptr)\n\t*out_len_ptr = out_len;\n\n    return 1;\n}\n\n/*\n *  call-seq:\n *     cipher.update(data [, buffer]) -> string or buffer\n *\n *  Encrypts data in a streaming fashion. Hand consecutive blocks of data\n *  to the +update+ method in order to encrypt it. Returns the encrypted\n *  data chunk. When done, the output of Cipher#final should be additionally\n *  added to the result.\n *\n *  If +buffer+ is given, the encryption/decryption result will be written to\n *  it. +buffer+ will be resized automatically.\n */\nstatic VALUE\nossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n\n    if (!RTEST(rb_attr_get(self, id_key_set)))\n\tossl_raise(eCipherError, \"key not set\");\n\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n\n    return str;\n}\n\n/*\n *  call-seq:\n *     cipher.final -> string\n *\n *  Returns the remaining data held in the cipher object. Further calls to\n *  Cipher#update or Cipher#final will return garbage. This call should always\n *  be made as the last call of an encryption or decryption operation, after\n *  after having fed the entire plaintext or ciphertext to the Cipher instance.\n *\n *  If an authenticated cipher was used, a CipherError is raised if the tag\n *  could not be authenticated successfully. Only call this method after\n *  setting the authentication tag and passing the entire contents of the\n *  ciphertext into the cipher.\n */\nstatic VALUE\nossl_cipher_final(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    int out_len;\n    VALUE str;\n\n    GetCipher(self, ctx);\n    str = rb_str_new(0, EVP_CIPHER_CTX_block_size(ctx));\n    if (!EVP_CipherFinal_ex(ctx, (unsigned char *)RSTRING_PTR(str), &out_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len <= RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n\n    return str;\n}\n\n/*\n *  call-seq:\n *     cipher.name -> string\n *\n *  Returns the name of the cipher which may differ slightly from the original\n *  name provided.\n */\nstatic VALUE\nossl_cipher_name(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n\n    return rb_str_new2(EVP_CIPHER_name(EVP_CIPHER_CTX_cipher(ctx)));\n}\n\n/*\n *  call-seq:\n *     cipher.key = string -> string\n *\n *  Sets the cipher key. To generate a key, you should either use a secure\n *  random byte string or, if the key is to be derived from a password, you\n *  should rely on PBKDF2 functionality provided by OpenSSL::PKCS5. To\n *  generate a secure random-based key, Cipher#random_key may be used.\n *\n *  Only call this method after calling Cipher#encrypt or Cipher#decrypt.\n */\nstatic VALUE\nossl_cipher_set_key(VALUE self, VALUE key)\n{\n    EVP_CIPHER_CTX *ctx;\n    int key_len;\n\n    StringValue(key);\n    GetCipher(self, ctx);\n\n    key_len = EVP_CIPHER_CTX_key_length(ctx);\n    if (RSTRING_LEN(key) != key_len)\n\tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    rb_ivar_set(self, id_key_set, Qtrue);\n\n    return key;\n}\n\n/*\n *  call-seq:\n *     cipher.iv = string -> string\n *\n *  Sets the cipher IV. Please note that since you should never be using ECB\n *  mode, an IV is always explicitly required and should be set prior to\n *  encryption. The IV itself can be safely transmitted in public, but it\n *  should be unpredictable to prevent certain kinds of attacks. You may use\n *  Cipher#random_iv to create a secure random IV.\n *\n *  Only call this method after calling Cipher#encrypt or Cipher#decrypt.\n *\n *  If not explicitly set, the OpenSSL default of an all-zeroes (\"\\\\0\") IV is\n *  used.\n */\nstatic VALUE\nossl_cipher_set_iv(VALUE self, VALUE iv)\n{\n    EVP_CIPHER_CTX *ctx;\n    int iv_len = 0;\n\n    StringValue(iv);\n    GetCipher(self, ctx);\n\n#if defined(HAVE_AUTHENTICATED_ENCRYPTION)\n    if (EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER)\n\tiv_len = (int)(VALUE)EVP_CIPHER_CTX_get_app_data(ctx);\n#endif\n    if (!iv_len)\n\tiv_len = EVP_CIPHER_CTX_iv_length(ctx);\n    if (RSTRING_LEN(iv) != iv_len)\n\tossl_raise(rb_eArgError, \"iv must be %d bytes\", iv_len);\n\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, NULL, (unsigned char *)RSTRING_PTR(iv), -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return iv;\n}\n\n#ifdef HAVE_AUTHENTICATED_ENCRYPTION\n/*\n *  call-seq:\n *     cipher.auth_data = string -> string\n *\n *  Sets the cipher's additional authenticated data. This field must be\n *  set when using AEAD cipher modes such as GCM or CCM. If no associated\n *  data shall be used, this method must *still* be called with a value of \"\".\n *  The contents of this field should be non-sensitive data which will be\n *  added to the ciphertext to generate the authentication tag which validates\n *  the contents of the ciphertext.\n *\n *  The AAD must be set prior to encryption or decryption. In encryption mode,\n *  it must be set after calling Cipher#encrypt and setting Cipher#key= and\n *  Cipher#iv=. When decrypting, the authenticated data must be set after key,\n *  iv and especially *after* the authentication tag has been set. I.e. set it\n *  only after calling Cipher#decrypt, Cipher#key=, Cipher#iv= and\n *  Cipher#auth_tag= first.\n */\nstatic VALUE\nossl_cipher_set_auth_data(VALUE self, VALUE data)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n\n    StringValue(data);\n\n    in = (unsigned char *) RSTRING_PTR(data);\n    in_len = RSTRING_LEN(data);\n\n    GetCipher(self, ctx);\n\n    if (!ossl_cipher_update_long(ctx, NULL, &out_len, in, in_len))\n        ossl_raise(eCipherError, \"couldn't set additional authenticated data\");\n\n    return data;\n}\n\n/*\n *  call-seq:\n *     cipher.auth_tag(tag_len = 16) -> String\n *\n *  Gets the authentication tag generated by Authenticated Encryption Cipher\n *  modes (GCM for example). This tag may be stored along with the ciphertext,\n *  then set on the decryption cipher to authenticate the contents of the\n *  ciphertext against changes. If the optional integer parameter +tag_len+ is\n *  given, the returned tag will be +tag_len+ bytes long. If the parameter is\n *  omitted, the default length of 16 bytes or the length previously set by\n *  #auth_tag_len= will be used. For maximum security, the longest possible\n *  should be chosen.\n *\n *  The tag may only be retrieved after calling Cipher#final.\n */\nstatic VALUE\nossl_cipher_get_auth_tag(int argc, VALUE *argv, VALUE self)\n{\n    VALUE vtag_len, ret;\n    EVP_CIPHER_CTX *ctx;\n    int tag_len = 16;\n\n    rb_scan_args(argc, argv, \"01\", &vtag_len);\n    if (NIL_P(vtag_len))\n\tvtag_len = rb_attr_get(self, id_auth_tag_len);\n    if (!NIL_P(vtag_len))\n\ttag_len = NUM2INT(vtag_len);\n\n    GetCipher(self, ctx);\n\n    if (!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER))\n\tossl_raise(eCipherError, \"authentication tag not supported by this cipher\");\n\n    ret = rb_str_new(NULL, tag_len);\n    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, tag_len, RSTRING_PTR(ret)))\n\tossl_raise(eCipherError, \"retrieving the authentication tag failed\");\n\n    return ret;\n}\n\n/*\n *  call-seq:\n *     cipher.auth_tag = string -> string\n *\n *  Sets the authentication tag to verify the contents of the\n *  ciphertext. The tag must be set after calling Cipher#decrypt,\n *  Cipher#key= and Cipher#iv=, but before assigning the associated\n *  authenticated data using Cipher#auth_data= and of course, before\n *  decrypting any of the ciphertext. After all decryption is\n *  performed, the tag is verified automatically in the call to\n *  Cipher#final.\n *\n *  For OCB mode, the tag length must be supplied with #auth_tag_len=\n *  beforehand.\n */\nstatic VALUE\nossl_cipher_set_auth_tag(VALUE self, VALUE vtag)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *tag;\n    int tag_len;\n\n    StringValue(vtag);\n    tag = (unsigned char *) RSTRING_PTR(vtag);\n    tag_len = RSTRING_LENINT(vtag);\n\n    GetCipher(self, ctx);\n    if (!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER))\n\tossl_raise(eCipherError, \"authentication tag not supported by this cipher\");\n\n    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, tag_len, tag))\n\tossl_raise(eCipherError, \"unable to set AEAD tag\");\n\n    return vtag;\n}\n\n/*\n *  call-seq:\n *     cipher.auth_tag_len = Integer -> Integer\n *\n *  Sets the length of the authentication tag to be generated or to be given for\n *  AEAD ciphers that requires it as in input parameter. Note that not all AEAD\n *  ciphers support this method.\n *\n *  In OCB mode, the length must be supplied both when encrypting and when\n *  decrypting, and must be before specifying an IV.\n */\nstatic VALUE\nossl_cipher_set_auth_tag_len(VALUE self, VALUE vlen)\n{\n    int tag_len = NUM2INT(vlen);\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n    if (!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER))\n\tossl_raise(eCipherError, \"AEAD not supported by this cipher\");\n\n    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, tag_len, NULL))\n\tossl_raise(eCipherError, \"unable to set authentication tag length\");\n\n    /* for #auth_tag */\n    rb_ivar_set(self, id_auth_tag_len, INT2NUM(tag_len));\n\n    return vlen;\n}\n\n/*\n *  call-seq:\n *     cipher.authenticated? -> boolean\n *\n *  Indicated whether this Cipher instance uses an Authenticated Encryption\n *  mode.\n */\nstatic VALUE\nossl_cipher_is_authenticated(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n\n    return (EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER) ? Qtrue : Qfalse;\n}\n\n/*\n * call-seq:\n *   cipher.iv_len = integer -> integer\n *\n * Sets the IV/nonce length of the Cipher. Normally block ciphers don't allow\n * changing the IV length, but some make use of IV for 'nonce'. You may need\n * this for interoperability with other applications.\n */\nstatic VALUE\nossl_cipher_set_iv_length(VALUE self, VALUE iv_length)\n{\n    int len = NUM2INT(iv_length);\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n    if (!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER))\n\tossl_raise(eCipherError, \"cipher does not support AEAD\");\n\n    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, len, NULL))\n\tossl_raise(eCipherError, \"unable to set IV length\");\n\n    /*\n     * EVP_CIPHER_CTX_iv_length() returns the default length. So we need to save\n     * the length somewhere. Luckily currently we aren't using app_data.\n     */\n    EVP_CIPHER_CTX_set_app_data(ctx, (void *)(VALUE)len);\n\n    return iv_length;\n}\n#else\n#define ossl_cipher_set_auth_data rb_f_notimplement\n#define ossl_cipher_get_auth_tag rb_f_notimplement\n#define ossl_cipher_set_auth_tag rb_f_notimplement\n#define ossl_cipher_set_auth_tag_len rb_f_notimplement\n#define ossl_cipher_is_authenticated rb_f_notimplement\n#define ossl_cipher_set_iv_length rb_f_notimplement\n#endif\n\n/*\n *  call-seq:\n *     cipher.key_len = integer -> integer\n *\n *  Sets the key length of the cipher.  If the cipher is a fixed length cipher\n *  then attempting to set the key length to any value other than the fixed\n *  value is an error.\n *\n *  Under normal circumstances you do not need to call this method (and probably shouldn't).\n *\n *  See EVP_CIPHER_CTX_set_key_length for further information.\n */\nstatic VALUE\nossl_cipher_set_key_length(VALUE self, VALUE key_length)\n{\n    int len = NUM2INT(key_length);\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n    if (EVP_CIPHER_CTX_set_key_length(ctx, len) != 1)\n        ossl_raise(eCipherError, NULL);\n\n    return key_length;\n}\n\n/*\n *  call-seq:\n *     cipher.padding = integer -> integer\n *\n *  Enables or disables padding. By default encryption operations are padded using standard block padding and the\n *  padding is checked and removed when decrypting. If the pad parameter is zero then no padding is performed, the\n *  total amount of data encrypted or decrypted must then be a multiple of the block size or an error will occur.\n *\n *  See EVP_CIPHER_CTX_set_padding for further information.\n */\nstatic VALUE\nossl_cipher_set_padding(VALUE self, VALUE padding)\n{\n    EVP_CIPHER_CTX *ctx;\n    int pad = NUM2INT(padding);\n\n    GetCipher(self, ctx);\n    if (EVP_CIPHER_CTX_set_padding(ctx, pad) != 1)\n\tossl_raise(eCipherError, NULL);\n    return padding;\n}\n\n/*\n *  call-seq:\n *     cipher.key_len -> integer\n *\n *  Returns the key length in bytes of the Cipher.\n */\nstatic VALUE\nossl_cipher_key_length(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n\n    return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));\n}\n\n/*\n *  call-seq:\n *     cipher.iv_len -> integer\n *\n *  Returns the expected length in bytes for an IV for this Cipher.\n */\nstatic VALUE\nossl_cipher_iv_length(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    int len = 0;\n\n    GetCipher(self, ctx);\n#if defined(HAVE_AUTHENTICATED_ENCRYPTION)\n    if (EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_FLAG_AEAD_CIPHER)\n\tlen = (int)(VALUE)EVP_CIPHER_CTX_get_app_data(ctx);\n#endif\n    if (!len)\n\tlen = EVP_CIPHER_CTX_iv_length(ctx);\n\n    return INT2NUM(len);\n}\n\n/*\n *  call-seq:\n *     cipher.block_size -> integer\n *\n *  Returns the size in bytes of the blocks on which this Cipher operates on.\n */\nstatic VALUE\nossl_cipher_block_size(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n\n    return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));\n}\n\n/*\n * INIT\n */\nvoid\nInit_ossl_cipher(void)\n{\n#if 0\n    mOSSL = rb_define_module(\"OpenSSL\");\n    eOSSLError = rb_define_class_under(mOSSL, \"OpenSSLError\", rb_eStandardError);\n#endif\n\n    /* Document-class: OpenSSL::Cipher\n     *\n     * Provides symmetric algorithms for encryption and decryption. The\n     * algorithms that are available depend on the particular version\n     * of OpenSSL that is installed.\n     *\n     * === Listing all supported algorithms\n     *\n     * A list of supported algorithms can be obtained by\n     *\n     *   puts OpenSSL::Cipher.ciphers\n     *\n     * === Instantiating a Cipher\n     *\n     * There are several ways to create a Cipher instance. Generally, a\n     * Cipher algorithm is categorized by its name, the key length in bits\n     * and the cipher mode to be used. The most generic way to create a\n     * Cipher is the following\n     *\n     *   cipher = OpenSSL::Cipher.new('<name>-<key length>-<mode>')\n     *\n     * That is, a string consisting of the hyphenated concatenation of the\n     * individual components name, key length and mode. Either all uppercase\n     * or all lowercase strings may be used, for example:\n     *\n     *  cipher = OpenSSL::Cipher.new('AES-128-CBC')\n     *\n     * For each algorithm supported, there is a class defined under the\n     * Cipher class that goes by the name of the cipher, e.g. to obtain an\n     * instance of AES, you could also use\n     *\n     *   # these are equivalent\n     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   cipher = OpenSSL::Cipher::AES.new(128, 'CBC')\n     *   cipher = OpenSSL::Cipher::AES.new('128-CBC')\n     *\n     * Finally, due to its wide-spread use, there are also extra classes\n     * defined for the different key sizes of AES\n     *\n     *   cipher = OpenSSL::Cipher::AES128.new(:CBC)\n     *   cipher = OpenSSL::Cipher::AES192.new(:CBC)\n     *   cipher = OpenSSL::Cipher::AES256.new(:CBC)\n     *\n     * === Choosing either encryption or decryption mode\n     *\n     * Encryption and decryption are often very similar operations for\n     * symmetric algorithms, this is reflected by not having to choose\n     * different classes for either operation, both can be done using the\n     * same class. Still, after obtaining a Cipher instance, we need to\n     * tell the instance what it is that we intend to do with it, so we\n     * need to call either\n     *\n     *   cipher.encrypt\n     *\n     * or\n     *\n     *   cipher.decrypt\n     *\n     * on the Cipher instance. This should be the first call after creating\n     * the instance, otherwise configuration that has already been set could\n     * get lost in the process.\n     *\n     * === Choosing a key\n     *\n     * Symmetric encryption requires a key that is the same for the encrypting\n     * and for the decrypting party and after initial key establishment should\n     * be kept as private information. There are a lot of ways to create\n     * insecure keys, the most notable is to simply take a password as the key\n     * without processing the password further. A simple and secure way to\n     * create a key for a particular Cipher is\n     *\n     *  cipher = OpenSSL::AES256.new(:CFB)\n     *  cipher.encrypt\n     *  key = cipher.random_key # also sets the generated key on the Cipher\n     *\n     * If you absolutely need to use passwords as encryption keys, you\n     * should use Password-Based Key Derivation Function 2 (PBKDF2) by\n     * generating the key with the help of the functionality provided by\n     * OpenSSL::PKCS5.pbkdf2_hmac_sha1 or OpenSSL::PKCS5.pbkdf2_hmac.\n     *\n     * Although there is Cipher#pkcs5_keyivgen, its use is deprecated and\n     * it should only be used in legacy applications because it does not use\n     * the newer PKCS#5 v2 algorithms.\n     *\n     * === Choosing an IV\n     *\n     * The cipher modes CBC, CFB, OFB and CTR all need an \"initialization\n     * vector\", or short, IV. ECB mode is the only mode that does not require\n     * an IV, but there is almost no legitimate use case for this mode\n     * because of the fact that it does not sufficiently hide plaintext\n     * patterns. Therefore\n     *\n     * <b>You should never use ECB mode unless you are absolutely sure that\n     * you absolutely need it</b>\n     *\n     * Because of this, you will end up with a mode that explicitly requires\n     * an IV in any case. Note that for backwards compatibility reasons,\n     * setting an IV is not explicitly mandated by the Cipher API. If not\n     * set, OpenSSL itself defaults to an all-zeroes IV (\"\\\\0\", not the\n     * character). Although the IV can be seen as public information, i.e.\n     * it may be transmitted in public once generated, it should still stay\n     * unpredictable to prevent certain kinds of attacks. Therefore, ideally\n     *\n     * <b>Always create a secure random IV for every encryption of your\n     * Cipher</b>\n     *\n     * A new, random IV should be created for every encryption of data. Think\n     * of the IV as a nonce (number used once) - it's public but random and\n     * unpredictable. A secure random IV can be created as follows\n     *\n     *   cipher = ...\n     *   cipher.encrypt\n     *   key = cipher.random_key\n     *   iv = cipher.random_iv # also sets the generated IV on the Cipher\n     *\n     * Although the key is generally a random value, too, it is a bad choice\n     * as an IV. There are elaborate ways how an attacker can take advantage\n     * of such an IV. As a general rule of thumb, exposing the key directly\n     * or indirectly should be avoided at all cost and exceptions only be\n     * made with good reason.\n     *\n     * === Calling Cipher#final\n     *\n     * ECB (which should not be used) and CBC are both block-based modes.\n     * This means that unlike for the other streaming-based modes, they\n     * operate on fixed-size blocks of data, and therefore they require a\n     * \"finalization\" step to produce or correctly decrypt the last block of\n     * data by appropriately handling some form of padding. Therefore it is\n     * essential to add the output of OpenSSL::Cipher#final to your\n     * encryption/decryption buffer or you will end up with decryption errors\n     * or truncated data.\n     *\n     * Although this is not really necessary for streaming-mode ciphers, it is\n     * still recommended to apply the same pattern of adding the output of\n     * Cipher#final there as well - it also enables you to switch between\n     * modes more easily in the future.\n     *\n     * === Encrypting and decrypting some data\n     *\n     *   data = \"Very, very confidential data\"\n     *\n     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   cipher.encrypt\n     *   key = cipher.random_key\n     *   iv = cipher.random_iv\n     *\n     *   encrypted = cipher.update(data) + cipher.final\n     *   ...\n     *   decipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   decipher.decrypt\n     *   decipher.key = key\n     *   decipher.iv = iv\n     *\n     *   plain = decipher.update(encrypted) + decipher.final\n     *\n     *   puts data == plain #=> true\n     *\n     * === Authenticated Encryption and Associated Data (AEAD)\n     *\n     * If the OpenSSL version used supports it, an Authenticated Encryption\n     * mode (such as GCM or CCM) should always be preferred over any\n     * unauthenticated mode. Currently, OpenSSL supports AE only in combination\n     * with Associated Data (AEAD) where additional associated data is included\n     * in the encryption process to compute a tag at the end of the encryption.\n     * This tag will also be used in the decryption process and by verifying\n     * its validity, the authenticity of a given ciphertext is established.\n     *\n     * This is superior to unauthenticated modes in that it allows to detect\n     * if somebody effectively changed the ciphertext after it had been\n     * encrypted. This prevents malicious modifications of the ciphertext that\n     * could otherwise be exploited to modify ciphertexts in ways beneficial to\n     * potential attackers.\n     *\n     * An associated data is used where there is additional information, such as\n     * headers or some metadata, that must be also authenticated but not\n     * necessarily need to be encrypted. If no associated data is needed for\n     * encryption and later decryption, the OpenSSL library still requires a\n     * value to be set - \"\" may be used in case none is available.\n     *\n     * An example using the GCM (Galois/Counter Mode). You have 16 bytes +key+,\n     * 12 bytes (96 bits) +nonce+ and the associated data +auth_data+. Be sure\n     * not to reuse the +key+ and +nonce+ pair. Reusing an nonce ruins the\n     * security gurantees of GCM mode.\n     *\n     *   cipher = OpenSSL::Cipher::AES.new(128, :GCM).encrypt\n     *   cipher.key = key\n     *   cipher.iv = nonce\n     *   cipher.auth_data = auth_data\n     *\n     *   encrypted = cipher.update(data) + cipher.final\n     *   tag = cipher.auth_tag # produces 16 bytes tag by default\n     *\n     * Now you are the receiver. You know the +key+ and have received +nonce+,\n     * +auth_data+, +encrypted+ and +tag+ through an untrusted network. Note\n     * that GCM accepts an arbitrary length tag between 1 and 16 bytes. You may\n     * additionally need to check that the received tag has the correct length,\n     * or you allow attackers to forge a valid single byte tag for the tampered\n     * ciphertext with a probability of 1/256.\n     *\n     *   raise \"tag is truncated!\" unless tag.bytesize == 16\n     *   decipher = OpenSSL::Cipher::AES.new(128, :GCM).decrypt\n     *   decipher.key = key\n     *   decipher.iv = nonce\n     *   decipher.auth_tag = tag\n     *   decipher.auth_data = auth_data\n     *\n     *   decrypted = decipher.update(encrypted) + decipher.final\n     *\n     *   puts data == decrypted #=> true\n     */\n    cCipher = rb_define_class_under(mOSSL, \"Cipher\", rb_cObject);\n    eCipherError = rb_define_class_under(cCipher, \"CipherError\", eOSSLError);\n\n    rb_define_alloc_func(cCipher, ossl_cipher_alloc);\n    rb_define_copy_func(cCipher, ossl_cipher_copy);\n    rb_define_module_function(cCipher, \"ciphers\", ossl_s_ciphers, 0);\n    rb_define_method(cCipher, \"initialize\", ossl_cipher_initialize, 1);\n    rb_define_method(cCipher, \"reset\", ossl_cipher_reset, 0);\n    rb_define_method(cCipher, \"encrypt\", ossl_cipher_encrypt, -1);\n    rb_define_method(cCipher, \"decrypt\", ossl_cipher_decrypt, -1);\n    rb_define_method(cCipher, \"pkcs5_keyivgen\", ossl_cipher_pkcs5_keyivgen, -1);\n    rb_define_method(cCipher, \"update\", ossl_cipher_update, -1);\n    rb_define_method(cCipher, \"final\", ossl_cipher_final, 0);\n    rb_define_method(cCipher, \"name\", ossl_cipher_name, 0);\n    rb_define_method(cCipher, \"key=\", ossl_cipher_set_key, 1);\n    rb_define_method(cCipher, \"auth_data=\", ossl_cipher_set_auth_data, 1);\n    rb_define_method(cCipher, \"auth_tag=\", ossl_cipher_set_auth_tag, 1);\n    rb_define_method(cCipher, \"auth_tag\", ossl_cipher_get_auth_tag, -1);\n    rb_define_method(cCipher, \"auth_tag_len=\", ossl_cipher_set_auth_tag_len, 1);\n    rb_define_method(cCipher, \"authenticated?\", ossl_cipher_is_authenticated, 0);\n    rb_define_method(cCipher, \"key_len=\", ossl_cipher_set_key_length, 1);\n    rb_define_method(cCipher, \"key_len\", ossl_cipher_key_length, 0);\n    rb_define_method(cCipher, \"iv=\", ossl_cipher_set_iv, 1);\n    rb_define_method(cCipher, \"iv_len=\", ossl_cipher_set_iv_length, 1);\n    rb_define_method(cCipher, \"iv_len\", ossl_cipher_iv_length, 0);\n    rb_define_method(cCipher, \"block_size\", ossl_cipher_block_size, 0);\n    rb_define_method(cCipher, \"padding=\", ossl_cipher_set_padding, 1);\n\n    id_auth_tag_len = rb_intern_const(\"auth_tag_len\");\n    id_key_set = rb_intern_const(\"key_set\");\n}\n", "# frozen_string_literal: false\nrequire_relative 'utils'\n\nif defined?(OpenSSL::TestUtils)\n\nclass OpenSSL::TestCipher < OpenSSL::TestCase\n\n  @ciphers = OpenSSL::Cipher.ciphers\n\n  class << self\n\n    def has_cipher?(name)\n      @ciphers.include?(name)\n    end\n\n    def has_ciphers?(list)\n      list.all? { |name| has_cipher?(name) }\n    end\n\n  end\n\n  def setup\n    @c1 = OpenSSL::Cipher.new(\"DES-EDE3-CBC\")\n    @c2 = OpenSSL::Cipher::DES.new(:EDE3, \"CBC\")\n    @key = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n    @iv = \"\\0\\0\\0\\0\\0\\0\\0\\0\"\n    @hexkey = \"0000000000000000000000000000000000000000000000\"\n    @hexiv = \"0000000000000000\"\n    @data = \"DATA\"\n  end\n\n  def teardown\n    super\n    @c1 = @c2 = nil\n  end\n\n  def test_crypt\n    @c1.encrypt.pkcs5_keyivgen(@key, @iv)\n    @c2.encrypt.pkcs5_keyivgen(@key, @iv)\n    s1 = @c1.update(@data) + @c1.final\n    s2 = @c2.update(@data) + @c2.final\n    assert_equal(s1, s2, \"encrypt\")\n\n    @c1.decrypt.pkcs5_keyivgen(@key, @iv)\n    @c2.decrypt.pkcs5_keyivgen(@key, @iv)\n    assert_equal(@data, @c1.update(s1)+@c1.final, \"decrypt\")\n    assert_equal(@data, @c2.update(s2)+@c2.final, \"decrypt\")\n  end\n\n  def test_info\n    assert_equal(\"DES-EDE3-CBC\", @c1.name, \"name\")\n    assert_equal(\"DES-EDE3-CBC\", @c2.name, \"name\")\n    assert_kind_of(Integer, @c1.key_len, \"key_len\")\n    assert_kind_of(Integer, @c1.iv_len, \"iv_len\")\n  end\n\n  def test_dup\n    assert_equal(@c1.name, @c1.dup.name, \"dup\")\n    assert_equal(@c1.name, @c1.clone.name, \"clone\")\n    @c1.encrypt\n    @c1.key = @key\n    @c1.iv = @iv\n    tmpc = @c1.dup\n    s1 = @c1.update(@data) + @c1.final\n    s2 = tmpc.update(@data) + tmpc.final\n    assert_equal(s1, s2, \"encrypt dup\")\n  end\n\n  def test_reset\n    @c1.encrypt\n    @c1.key = @key\n    @c1.iv = @iv\n    s1 = @c1.update(@data) + @c1.final\n    @c1.reset\n    s2 = @c1.update(@data) + @c1.final\n    assert_equal(s1, s2, \"encrypt reset\")\n  end\n\n  def test_key_iv_set\n    # default value for DES-EDE3-CBC\n    assert_equal(24, @c1.key_len)\n    assert_equal(8, @c1.iv_len)\n    assert_raise(ArgumentError) { @c1.key = \"\\x01\" * 23 }\n    @c1.key = \"\\x01\" * 24\n    assert_raise(ArgumentError) { @c1.key = \"\\x01\" * 25 }\n    assert_raise(ArgumentError) { @c1.iv = \"\\x01\" * 7 }\n    @c1.iv = \"\\x01\" * 8\n    assert_raise(ArgumentError) { @c1.iv = \"\\x01\" * 9 }\n  end\n\n  def test_empty_data\n    @c1.encrypt\n    @c1.random_key\n    assert_raise(ArgumentError){ @c1.update(\"\") }\n  end\n\n  def test_initialize\n    assert_raise(RuntimeError) {@c1.__send__(:initialize, \"DES-EDE3-CBC\")}\n    assert_raise(RuntimeError) {OpenSSL::Cipher.allocate.final}\n  end\n\n  def test_ctr_if_exists\n    begin\n      cipher = OpenSSL::Cipher.new('aes-128-ctr')\n      cipher.encrypt\n      cipher.pkcs5_keyivgen('password')\n      c = cipher.update('hello,world') + cipher.final\n      cipher.decrypt\n      cipher.pkcs5_keyivgen('password')\n      assert_equal('hello,world', cipher.update(c) + cipher.final)\n    end\n  end if has_cipher?('aes-128-ctr')\n\n  def test_ciphers\n    OpenSSL::Cipher.ciphers.each{|name|\n      next if /netbsd/ =~ RUBY_PLATFORM && /idea|rc5/i =~ name\n      begin\n        assert_kind_of(OpenSSL::Cipher, OpenSSL::Cipher.new(name))\n      rescue OpenSSL::Cipher::CipherError => e\n        raise unless /wrap/ =~ name and /wrap mode not allowed/ =~ e.message\n      end\n    }\n  end\n\n  def test_AES\n    pt = File.read(__FILE__)\n    %w(ECB CBC CFB OFB).each{|mode|\n      c1 = OpenSSL::Cipher::AES256.new(mode)\n      c1.encrypt\n      c1.pkcs5_keyivgen(\"passwd\")\n      ct = c1.update(pt) + c1.final\n\n      c2 = OpenSSL::Cipher::AES256.new(mode)\n      c2.decrypt\n      c2.pkcs5_keyivgen(\"passwd\")\n      assert_equal(pt, c2.update(ct) + c2.final)\n    }\n  end\n\n  def test_update_raise_if_key_not_set\n    assert_raise(OpenSSL::Cipher::CipherError) do\n      # it caused OpenSSL SEGV by uninitialized key [Bug #2768]\n      OpenSSL::Cipher::AES128.new(\"ECB\").update \".\" * 17\n    end\n  end\n\n  if has_ciphers?(['aes-128-gcm', 'aes-192-gcm', 'aes-256-gcm'])\n\n    def test_authenticated\n      cipher = OpenSSL::Cipher.new('aes-128-gcm')\n      assert_predicate(cipher, :authenticated?)\n      cipher = OpenSSL::Cipher.new('aes-128-cbc')\n      assert_not_predicate(cipher, :authenticated?)\n    end\n\n    def test_aes_gcm\n      ['aes-128-gcm', 'aes-192-gcm', 'aes-256-gcm'].each do |algo|\n        pt = \"You should all use Authenticated Encryption!\"\n        cipher, key, iv = new_encryptor(algo)\n\n        cipher.auth_data = \"aad\"\n        ct  = cipher.update(pt) + cipher.final\n        tag = cipher.auth_tag\n        assert_equal(16, tag.size)\n\n        decipher = new_decryptor(algo, key, iv)\n        decipher.auth_tag = tag\n        decipher.auth_data = \"aad\"\n\n        assert_equal(pt, decipher.update(ct) + decipher.final)\n      end\n    end\n\n    def test_aes_gcm_short_tag\n      ['aes-128-gcm', 'aes-192-gcm', 'aes-256-gcm'].each do |algo|\n        pt = \"You should all use Authenticated Encryption!\"\n        cipher, key, iv = new_encryptor(algo)\n\n        cipher.auth_data = \"aad\"\n        ct  = cipher.update(pt) + cipher.final\n        tag = cipher.auth_tag(8)\n        assert_equal(8, tag.size)\n\n        decipher = new_decryptor(algo, key, iv)\n        decipher.auth_tag = tag\n        decipher.auth_data = \"aad\"\n\n        assert_equal(pt, decipher.update(ct) + decipher.final)\n      end\n    end\n\n    def test_aes_gcm_wrong_tag\n      pt = \"You should all use Authenticated Encryption!\"\n      cipher, key, iv = new_encryptor('aes-128-gcm')\n\n      cipher.auth_data = \"aad\"\n      ct  = cipher.update(pt) + cipher.final\n      tag = cipher.auth_tag\n\n      decipher = new_decryptor('aes-128-gcm', key, iv)\n      tag.setbyte(-1, (tag.getbyte(-1) + 1) & 0xff)\n      decipher.auth_tag = tag\n      decipher.auth_data = \"aad\"\n\n      assert_raise OpenSSL::Cipher::CipherError do\n        decipher.update(ct) + decipher.final\n      end\n    end\n\n    def test_aes_gcm_wrong_auth_data\n      pt = \"You should all use Authenticated Encryption!\"\n      cipher, key, iv = new_encryptor('aes-128-gcm')\n\n      cipher.auth_data = \"aad\"\n      ct  = cipher.update(pt) + cipher.final\n      tag = cipher.auth_tag\n\n      decipher = new_decryptor('aes-128-gcm', key, iv)\n      decipher.auth_tag = tag\n      decipher.auth_data = \"daa\"\n\n      assert_raise OpenSSL::Cipher::CipherError do\n        decipher.update(ct) + decipher.final\n      end\n    end\n\n    def test_aes_gcm_wrong_ciphertext\n      pt = \"You should all use Authenticated Encryption!\"\n      cipher, key, iv = new_encryptor('aes-128-gcm')\n\n      cipher.auth_data = \"aad\"\n      ct  = cipher.update(pt) + cipher.final\n      tag = cipher.auth_tag\n\n      decipher = new_decryptor('aes-128-gcm', key, iv)\n      decipher.auth_tag = tag\n      decipher.auth_data = \"aad\"\n\n      assert_raise OpenSSL::Cipher::CipherError do\n        decipher.update(ct[0..-2] << ct[-1].succ) + decipher.final\n      end\n    end\n\n    def test_aes_gcm_variable_iv_len\n      pt = \"You should all use Authenticated Encryption!\"\n      cipher = OpenSSL::Cipher.new(\"aes-128-gcm\").encrypt\n      cipher.key = \"x\" * 16\n      assert_equal(12, cipher.iv_len)\n      cipher.iv = \"a\" * 12\n      ct1 = cipher.update(pt) << cipher.final\n      tag1 = cipher.auth_tag\n\n      cipher = OpenSSL::Cipher.new(\"aes-128-gcm\").encrypt\n      cipher.key = \"x\" * 16\n      cipher.iv_len = 10\n      assert_equal(10, cipher.iv_len)\n      cipher.iv = \"a\" * 10\n      ct2 = cipher.update(pt) << cipher.final\n      tag2 = cipher.auth_tag\n\n      assert_not_equal ct1, ct2\n      assert_not_equal tag1, tag2\n\n      decipher = OpenSSL::Cipher.new(\"aes-128-gcm\").decrypt\n      decipher.auth_tag = tag1\n      decipher.key = \"x\" * 16\n      decipher.iv_len = 12\n      decipher.iv = \"a\" * 12\n      assert_equal(pt, decipher.update(ct1) << decipher.final)\n\n      decipher.reset\n      decipher.auth_tag = tag2\n      assert_raise(OpenSSL::Cipher::CipherError) {\n        decipher.update(ct2) << decipher.final\n      }\n\n      decipher.reset\n      decipher.auth_tag = tag2\n      decipher.iv_len = 10\n      decipher.iv = \"a\" * 10\n      assert_equal(pt, decipher.update(ct2) << decipher.final)\n    end\n\n  end\n\n  def test_aes_ocb_tag_len\n    pt = \"You should all use Authenticated Encryption!\"\n    cipher = OpenSSL::Cipher.new(\"aes-128-ocb\").encrypt\n    cipher.auth_tag_len = 14\n    cipher.iv_len = 8\n    key = cipher.random_key\n    iv = cipher.random_iv\n    cipher.auth_data = \"aad\"\n    ct  = cipher.update(pt) + cipher.final\n    tag = cipher.auth_tag\n    assert_equal(14, tag.size)\n\n    decipher = OpenSSL::Cipher.new(\"aes-128-ocb\").decrypt\n    decipher.auth_tag_len = 14\n    decipher.auth_tag = tag\n    decipher.iv_len = 8\n    decipher.key = key\n    decipher.iv = iv\n    decipher.auth_data = \"aad\"\n    assert_equal(pt, decipher.update(ct) + decipher.final)\n\n    decipher = OpenSSL::Cipher.new(\"aes-128-ocb\").decrypt\n    decipher.auth_tag_len = 9\n    decipher.auth_tag = tag[0, 9]\n    decipher.iv_len = 8\n    decipher.key = key\n    decipher.iv = iv\n    decipher.auth_data = \"aad\"\n    assert_raise(OpenSSL::Cipher::CipherError) {\n      decipher.update(ct) + decipher.final\n    }\n  end if has_cipher?(\"aes-128-ocb\")\n\n  def test_aes_gcm_key_iv_order_issue\n    pt = \"[ruby/openssl#49]\"\n    cipher = OpenSSL::Cipher.new(\"aes-128-gcm\").encrypt\n    cipher.key = \"x\" * 16\n    cipher.iv = \"a\" * 12\n    ct1 = cipher.update(pt) << cipher.final\n    tag1 = cipher.auth_tag\n\n    cipher = OpenSSL::Cipher.new(\"aes-128-gcm\").encrypt\n    cipher.iv = \"a\" * 12\n    cipher.key = \"x\" * 16\n    ct2 = cipher.update(pt) << cipher.final\n    tag2 = cipher.auth_tag\n\n    assert_equal ct1, ct2\n    assert_equal tag1, tag2\n  end if has_cipher?(\"aes-128-gcm\")\n\n  private\n\n  def new_encryptor(algo)\n    cipher = OpenSSL::Cipher.new(algo)\n    cipher.encrypt\n    key = cipher.random_key\n    iv = cipher.random_iv\n    [cipher, key, iv]\n  end\n\n  def new_decryptor(algo, key, iv)\n    OpenSSL::Cipher.new(algo).tap do |cipher|\n      cipher.decrypt\n      cipher.key = key\n      cipher.iv = iv\n    end\n  end\n\nend\n\nend\n"], "buggy_code_start_loc": [39, 92], "buggy_code_end_loc": [1086, 319], "fixing_code_start_loc": [39, 93], "fixing_code_end_loc": [1087, 337], "type": "CWE-326", "message": "The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.", "other": {"cve": {"id": "CVE-2016-7798", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-30T22:59:00.747", "lastModified": "2020-11-05T14:56:15.433", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism."}, {"lang": "es", "value": "La openssl gem para Ruby utiliza el mismo vector de inicializaci\u00f3n (IV) en el modo GCM (aes - * - gcm) cuando el IV se establece en versiones anteriores a la clave, lo que facilita que los atacantes dependiendo del contexto eludan el mecanismo de protecci\u00f3n del cifrado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-326"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:openssl:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "2.0.0", "matchCriteriaId": "5A99A902-22BC-4E8A-92CD-58A7ABA19A5E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/19/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/30/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/01/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93031", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ruby/openssl/issues/49", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-3966", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062"}}