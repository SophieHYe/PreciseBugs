{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_cmds.c: some functions for command line commands\n */\n\n#include \"vim.h\"\n#include \"version.h\"\n\n#ifdef FEAT_FLOAT\n# include <float.h>\n#endif\n\nstatic int linelen(int *has_tab);\nstatic void do_filter(linenr_T line1, linenr_T line2, exarg_T *eap, char_u *cmd, int do_in, int do_out);\nstatic int not_writing(void);\nstatic int check_readonly(int *forceit, buf_T *buf);\nstatic void delbuf_msg(char_u *name);\n\n/*\n * \":ascii\" and \"ga\".\n */\n    void\ndo_ascii(exarg_T *eap UNUSED)\n{\n    int\t\tc;\n    int\t\tcval;\n    char\tbuf1[20];\n    char\tbuf2[20];\n    char_u\tbuf3[7];\n#ifdef FEAT_DIGRAPHS\n    char_u      *dig;\n#endif\n    int\t\tcc[MAX_MCO];\n    int\t\tci = 0;\n    int\t\tlen;\n\n    if (enc_utf8)\n\tc = utfc_ptr2char(ml_get_cursor(), cc);\n    else\n\tc = gchar_cursor();\n    if (c == NUL)\n    {\n\tmsg(\"NUL\");\n\treturn;\n    }\n\n    IObuff[0] = NUL;\n    if (!has_mbyte || (enc_dbcs != 0 && c < 0x100) || c < 0x80)\n    {\n\tif (c == NL)\t    // NUL is stored as NL\n\t    c = NUL;\n\tif (c == CAR && get_fileformat(curbuf) == EOL_MAC)\n\t    cval = NL;\t    // NL is stored as CR\n\telse\n\t    cval = c;\n\tif (vim_isprintc_strict(c) && (c < ' ' || c > '~'))\n\t{\n\t    transchar_nonprint(curbuf, buf3, c);\n\t    vim_snprintf(buf1, sizeof(buf1), \"  <%s>\", (char *)buf3);\n\t}\n\telse\n\t    buf1[0] = NUL;\n\tif (c >= 0x80)\n\t    vim_snprintf(buf2, sizeof(buf2), \"  <M-%s>\",\n\t\t\t\t\t\t (char *)transchar(c & 0x7f));\n\telse\n\t    buf2[0] = NUL;\n#ifdef FEAT_DIGRAPHS\n\tdig = get_digraph_for_char(cval);\n\tif (dig != NULL)\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t_(\"<%s>%s%s  %d,  Hex %02x,  Oct %03o, Digr %s\"),\n\t\t\t      transchar(c), buf1, buf2, cval, cval, cval, dig);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t_(\"<%s>%s%s  %d,  Hex %02x,  Octal %03o\"),\n\t\t\t\t  transchar(c), buf1, buf2, cval, cval, cval);\n\tif (enc_utf8)\n\t    c = cc[ci++];\n\telse\n\t    c = 0;\n    }\n\n    // Repeat for combining characters.\n    while (has_mbyte && (c >= 0x100 || (enc_utf8 && c >= 0x80)))\n    {\n\tlen = (int)STRLEN(IObuff);\n\t// This assumes every multi-byte char is printable...\n\tif (len > 0)\n\t    IObuff[len++] = ' ';\n\tIObuff[len++] = '<';\n\tif (enc_utf8 && utf_iscomposing(c)\n#ifdef USE_GUI\n\t\t&& !gui.in_use\n#endif\n\t\t)\n\t    IObuff[len++] = ' '; // draw composing char on top of a space\n\tlen += (*mb_char2bytes)(c, IObuff + len);\n#ifdef FEAT_DIGRAPHS\n\tdig = get_digraph_for_char(c);\n\tif (dig != NULL)\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\tc < 0x10000 ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")\n\t\t\t\t    : _(\"> %d, Hex %08x, Oct %o, Digr %s\"),\n\t\t\t\t\tc, c, c, dig);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\t c < 0x10000 ? _(\"> %d, Hex %04x, Octal %o\")\n\t\t\t\t     : _(\"> %d, Hex %08x, Octal %o\"),\n\t\t\t\t     c, c, c);\n\tif (ci == MAX_MCO)\n\t    break;\n\tif (enc_utf8)\n\t    c = cc[ci++];\n\telse\n\t    c = 0;\n    }\n\n    msg((char *)IObuff);\n}\n\n/*\n * \":left\", \":center\" and \":right\": align text.\n */\n    void\nex_align(exarg_T *eap)\n{\n    pos_T\tsave_curpos;\n    int\t\tlen;\n    int\t\tindent = 0;\n    int\t\tnew_indent;\n    int\t\thas_tab;\n    int\t\twidth;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl)\n    {\n\t// switch left and right aligning\n\tif (eap->cmdidx == CMD_right)\n\t    eap->cmdidx = CMD_left;\n\telse if (eap->cmdidx == CMD_left)\n\t    eap->cmdidx = CMD_right;\n    }\n#endif\n\n    width = atoi((char *)eap->arg);\n    save_curpos = curwin->w_cursor;\n    if (eap->cmdidx == CMD_left)    // width is used for new indent\n    {\n\tif (width >= 0)\n\t    indent = width;\n    }\n    else\n    {\n\t/*\n\t * if 'textwidth' set, use it\n\t * else if 'wrapmargin' set, use it\n\t * if invalid value, use 80\n\t */\n\tif (width <= 0)\n\t    width = curbuf->b_p_tw;\n\tif (width == 0 && curbuf->b_p_wm > 0)\n\t    width = curwin->w_width - curbuf->b_p_wm;\n\tif (width <= 0)\n\t    width = 80;\n    }\n\n    if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)\n\treturn;\n\n    for (curwin->w_cursor.lnum = eap->line1;\n\t\t curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum)\n    {\n\tif (eap->cmdidx == CMD_left)\t\t// left align\n\t    new_indent = indent;\n\telse\n\t{\n\t    has_tab = FALSE;\t// avoid uninit warnings\n\t    len = linelen(eap->cmdidx == CMD_right ? &has_tab\n\t\t\t\t\t\t   : NULL) - get_indent();\n\n\t    if (len <= 0)\t\t\t// skip blank lines\n\t\tcontinue;\n\n\t    if (eap->cmdidx == CMD_center)\n\t\tnew_indent = (width - len) / 2;\n\t    else\n\t    {\n\t\tnew_indent = width - len;\t// right align\n\n\t\t/*\n\t\t * Make sure that embedded TABs don't make the text go too far\n\t\t * to the right.\n\t\t */\n\t\tif (has_tab)\n\t\t    while (new_indent > 0)\n\t\t    {\n\t\t\t(void)set_indent(new_indent, 0);\n\t\t\tif (linelen(NULL) <= width)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Now try to move the line as much as possible to\n\t\t\t     * the right.  Stop when it moves too far.\n\t\t\t     */\n\t\t\t    do\n\t\t\t\t(void)set_indent(++new_indent, 0);\n\t\t\t    while (linelen(NULL) <= width);\n\t\t\t    --new_indent;\n\t\t\t    break;\n\t\t\t}\n\t\t\t--new_indent;\n\t\t    }\n\t    }\n\t}\n\tif (new_indent < 0)\n\t    new_indent = 0;\n\t(void)set_indent(new_indent, 0);\t\t// set indent\n    }\n    changed_lines(eap->line1, 0, eap->line2 + 1, 0L);\n    curwin->w_cursor = save_curpos;\n    beginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * Get the length of the current line, excluding trailing white space.\n */\n    static int\nlinelen(int *has_tab)\n{\n    char_u  *line;\n    char_u  *first;\n    char_u  *last;\n    int\t    save;\n    int\t    len;\n\n    // Get the line.  If it's empty bail out early (could be the empty string\n    // for an unloaded buffer).\n    line = ml_get_curline();\n    if (*line == NUL)\n\treturn 0;\n\n    // find the first non-blank character\n    first = skipwhite(line);\n\n    // find the character after the last non-blank character\n    for (last = first + STRLEN(first);\n\t\t\t\tlast > first && VIM_ISWHITE(last[-1]); --last)\n\t;\n    save = *last;\n    *last = NUL;\n    len = linetabsize(line);\t\t// get line length\n    if (has_tab != NULL)\t\t// check for embedded TAB\n\t*has_tab = (vim_strchr(first, TAB) != NULL);\n    *last = save;\n\n    return len;\n}\n\n// Buffer for two lines used during sorting.  They are allocated to\n// contain the longest line being sorted.\nstatic char_u\t*sortbuf1;\nstatic char_u\t*sortbuf2;\n\nstatic int\tsort_lc;\t// sort using locale\nstatic int\tsort_ic;\t// ignore case\nstatic int\tsort_nr;\t// sort on number\nstatic int\tsort_rx;\t// sort on regex instead of skipping it\n#ifdef FEAT_FLOAT\nstatic int\tsort_flt;\t// sort on floating number\n#endif\n\nstatic int\tsort_abort;\t// flag to indicate if sorting has been interrupted\n\n// Struct to store info to be sorted.\ntypedef struct\n{\n    linenr_T\tlnum;\t\t\t// line number\n    union {\n\tstruct\n\t{\n\t    varnumber_T\tstart_col_nr;\t// starting column number\n\t    varnumber_T\tend_col_nr;\t// ending column number\n\t} line;\n\tstruct\n\t{\n\t    varnumber_T\tvalue;\t\t// value if sorting by integer\n\t    int is_number;\t\t// TRUE when line contains a number\n\t} num;\n#ifdef FEAT_FLOAT\n\tfloat_T value_flt;\t\t// value if sorting by float\n#endif\n    } st_u;\n} sorti_T;\n\n    static int\nstring_compare(const void *s1, const void *s2)\n{\n    if (sort_lc)\n\treturn strcoll((char *)s1, (char *)s2);\n    return sort_ic ? STRICMP(s1, s2) : STRCMP(s1, s2);\n}\n\n    static int\nsort_compare(const void *s1, const void *s2)\n{\n    sorti_T\tl1 = *(sorti_T *)s1;\n    sorti_T\tl2 = *(sorti_T *)s2;\n    int\t\tresult = 0;\n\n    // If the user interrupts, there's no way to stop qsort() immediately, but\n    // if we return 0 every time, qsort will assume it's done sorting and\n    // exit.\n    if (sort_abort)\n\treturn 0;\n    fast_breakcheck();\n    if (got_int)\n\tsort_abort = TRUE;\n\n    if (sort_nr)\n    {\n\tif (l1.st_u.num.is_number != l2.st_u.num.is_number)\n\t    result = l1.st_u.num.is_number - l2.st_u.num.is_number;\n\telse\n\t    result = l1.st_u.num.value == l2.st_u.num.value ? 0\n\t\t\t     : l1.st_u.num.value > l2.st_u.num.value ? 1 : -1;\n    }\n#ifdef FEAT_FLOAT\n    else if (sort_flt)\n\tresult = l1.st_u.value_flt == l2.st_u.value_flt ? 0\n\t\t\t     : l1.st_u.value_flt > l2.st_u.value_flt ? 1 : -1;\n#endif\n    else\n    {\n\t// We need to copy one line into \"sortbuf1\", because there is no\n\t// guarantee that the first pointer becomes invalid when obtaining the\n\t// second one.\n\tSTRNCPY(sortbuf1, ml_get(l1.lnum) + l1.st_u.line.start_col_nr,\n\t\t     l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr + 1);\n\tsortbuf1[l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr] = 0;\n\tSTRNCPY(sortbuf2, ml_get(l2.lnum) + l2.st_u.line.start_col_nr,\n\t\t     l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr + 1);\n\tsortbuf2[l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr] = 0;\n\n\tresult = string_compare(sortbuf1, sortbuf2);\n    }\n\n    // If two lines have the same value, preserve the original line order.\n    if (result == 0)\n\treturn (int)(l1.lnum - l2.lnum);\n    return result;\n}\n\n/*\n * \":sort\".\n */\n    void\nex_sort(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    int\t\tlen;\n    linenr_T\tlnum;\n    long\tmaxlen = 0;\n    sorti_T\t*nrs;\n    size_t\tcount = (size_t)(eap->line2 - eap->line1 + 1);\n    size_t\ti;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*s2;\n    char_u\tc;\t\t\t// temporary character storage\n    int\t\tunique = FALSE;\n    long\tdeleted;\n    colnr_T\tstart_col;\n    colnr_T\tend_col;\n    int\t\tsort_what = 0;\n    int\t\tformat_found = 0;\n    int\t\tchange_occurred = FALSE; // Buffer contents changed.\n\n    // Sorting one line is really quick!\n    if (count <= 1)\n\treturn;\n\n    if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)\n\treturn;\n    sortbuf1 = NULL;\n    sortbuf2 = NULL;\n    regmatch.regprog = NULL;\n    nrs = ALLOC_MULT(sorti_T, count);\n    if (nrs == NULL)\n\tgoto sortend;\n\n    sort_abort = sort_ic = sort_lc = sort_rx = sort_nr = 0;\n#ifdef FEAT_FLOAT\n    sort_flt = 0;\n#endif\n\n    for (p = eap->arg; *p != NUL; ++p)\n    {\n\tif (VIM_ISWHITE(*p))\n\t    ;\n\telse if (*p == 'i')\n\t    sort_ic = TRUE;\n\telse if (*p == 'l')\n\t    sort_lc = TRUE;\n\telse if (*p == 'r')\n\t    sort_rx = TRUE;\n\telse if (*p == 'n')\n\t{\n\t    sort_nr = 1;\n\t    ++format_found;\n\t}\n#ifdef FEAT_FLOAT\n\telse if (*p == 'f')\n\t{\n\t    sort_flt = 1;\n\t    ++format_found;\n\t}\n#endif\n\telse if (*p == 'b')\n\t{\n\t    sort_what = STR2NR_BIN + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'o')\n\t{\n\t    sort_what = STR2NR_OCT + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'x')\n\t{\n\t    sort_what = STR2NR_HEX + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'u')\n\t    unique = TRUE;\n\telse if (*p == '\"')\t// comment start\n\t    break;\n\telse if (eap->nextcmd == NULL && check_nextcmd(p) != NULL)\n\t{\n\t    eap->nextcmd = check_nextcmd(p);\n\t    break;\n\t}\n\telse if (!ASCII_ISALPHA(*p) && regmatch.regprog == NULL)\n\t{\n\t    s = skip_regexp_err(p + 1, *p, TRUE);\n\t    if (s == NULL)\n\t\tgoto sortend;\n\t    *s = NUL;\n\t    // Use last search pattern if sort pattern is empty.\n\t    if (s == p + 1)\n\t    {\n\t\tif (last_search_pat() == NULL)\n\t\t{\n\t\t    emsg(_(e_no_previous_regular_expression));\n\t\t    goto sortend;\n\t\t}\n\t\tregmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);\n\t    }\n\t    else\n\t\tregmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);\n\t    if (regmatch.regprog == NULL)\n\t\tgoto sortend;\n\t    p = s;\t\t// continue after the regexp\n\t    regmatch.rm_ic = p_ic;\n\t}\n\telse\n\t{\n\t    semsg(_(e_invalid_argument_str), p);\n\t    goto sortend;\n\t}\n    }\n\n    // Can only have one of 'n', 'b', 'o' and 'x'.\n    if (format_found > 1)\n    {\n\temsg(_(e_invalid_argument));\n\tgoto sortend;\n    }\n\n    // From here on \"sort_nr\" is used as a flag for any integer number\n    // sorting.\n    sort_nr += sort_what;\n\n    /*\n     * Make an array with all line numbers.  This avoids having to copy all\n     * the lines into allocated memory.\n     * When sorting on strings \"start_col_nr\" is the offset in the line, for\n     * numbers sorting it's the number to sort on.  This means the pattern\n     * matching and number conversion only has to be done once per line.\n     * Also get the longest line length for allocating \"sortbuf\".\n     */\n    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)\n    {\n\ts = ml_get(lnum);\n\tlen = (int)STRLEN(s);\n\tif (maxlen < len)\n\t    maxlen = len;\n\n\tstart_col = 0;\n\tend_col = len;\n\tif (regmatch.regprog != NULL && vim_regexec(&regmatch, s, 0))\n\t{\n\t    if (sort_rx)\n\t    {\n\t\tstart_col = (colnr_T)(regmatch.startp[0] - s);\n\t\tend_col = (colnr_T)(regmatch.endp[0] - s);\n\t    }\n\t    else\n\t\tstart_col = (colnr_T)(regmatch.endp[0] - s);\n\t}\n\telse\n\t    if (regmatch.regprog != NULL)\n\t\tend_col = 0;\n\n\tif (sort_nr\n#ifdef FEAT_FLOAT\n\t\t|| sort_flt\n#endif\n\t\t)\n\t{\n\t    // Make sure vim_str2nr doesn't read any digits past the end\n\t    // of the match, by temporarily terminating the string there\n\t    s2 = s + end_col;\n\t    c = *s2;\n\t    *s2 = NUL;\n\t    // Sorting on number: Store the number itself.\n\t    p = s + start_col;\n\t    if (sort_nr)\n\t    {\n\t\tif (sort_what & STR2NR_HEX)\n\t\t    s = skiptohex(p);\n\t\telse if (sort_what & STR2NR_BIN)\n\t\t    s = skiptobin(p);\n\t\telse\n\t\t    s = skiptodigit(p);\n\t\tif (s > p && s[-1] == '-')\n\t\t    --s;  // include preceding negative sign\n\t\tif (*s == NUL)\n\t\t{\n\t\t    // line without number should sort before any number\n\t\t    nrs[lnum - eap->line1].st_u.num.is_number = FALSE;\n\t\t    nrs[lnum - eap->line1].st_u.num.value = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    nrs[lnum - eap->line1].st_u.num.is_number = TRUE;\n\t\t    vim_str2nr(s, NULL, NULL, sort_what,\n\t\t\t&nrs[lnum - eap->line1].st_u.num.value,\n\t\t\tNULL, 0, FALSE);\n\t\t}\n\t    }\n#ifdef FEAT_FLOAT\n\t    else\n\t    {\n\t\ts = skipwhite(p);\n\t\tif (*s == '+')\n\t\t    s = skipwhite(s + 1);\n\n\t\tif (*s == NUL)\n\t\t    // empty line should sort before any number\n\t\t    nrs[lnum - eap->line1].st_u.value_flt = -DBL_MAX;\n\t\telse\n\t\t    nrs[lnum - eap->line1].st_u.value_flt =\n\t\t\t\t\t\t      strtod((char *)s, NULL);\n\t    }\n#endif\n\t    *s2 = c;\n\t}\n\telse\n\t{\n\t    // Store the column to sort at.\n\t    nrs[lnum - eap->line1].st_u.line.start_col_nr = start_col;\n\t    nrs[lnum - eap->line1].st_u.line.end_col_nr = end_col;\n\t}\n\n\tnrs[lnum - eap->line1].lnum = lnum;\n\n\tif (regmatch.regprog != NULL)\n\t    fast_breakcheck();\n\tif (got_int)\n\t    goto sortend;\n    }\n\n    // Allocate a buffer that can hold the longest line.\n    sortbuf1 = alloc(maxlen + 1);\n    if (sortbuf1 == NULL)\n\tgoto sortend;\n    sortbuf2 = alloc(maxlen + 1);\n    if (sortbuf2 == NULL)\n\tgoto sortend;\n\n    // Sort the array of line numbers.  Note: can't be interrupted!\n    qsort((void *)nrs, count, sizeof(sorti_T), sort_compare);\n\n    if (sort_abort)\n\tgoto sortend;\n\n    // Insert the lines in the sorted order below the last one.\n    lnum = eap->line2;\n    for (i = 0; i < count; ++i)\n    {\n\tlinenr_T get_lnum = nrs[eap->forceit ? count - i - 1 : i].lnum;\n\n\t// If the original line number of the line being placed is not the same\n\t// as \"lnum\" (accounting for offset), we know that the buffer changed.\n\tif (get_lnum + ((linenr_T)count - 1) != lnum)\n\t    change_occurred = TRUE;\n\n\ts = ml_get(get_lnum);\n\tif (!unique || i == 0 || string_compare(s, sortbuf1) != 0)\n\t{\n\t    // Copy the line into a buffer, it may become invalid in\n\t    // ml_append(). And it's needed for \"unique\".\n\t    STRCPY(sortbuf1, s);\n\t    if (ml_append(lnum++, sortbuf1, (colnr_T)0, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\tfast_breakcheck();\n\tif (got_int)\n\t    goto sortend;\n    }\n\n    // delete the original lines if appending worked\n    if (i == count)\n\tfor (i = 0; i < count; ++i)\n\t    ml_delete(eap->line1);\n    else\n\tcount = 0;\n\n    // Adjust marks for deleted (or added) lines and prepare for displaying.\n    deleted = (long)(count - (lnum - eap->line2));\n    if (deleted > 0)\n    {\n\tmark_adjust(eap->line2 - deleted, eap->line2, (long)MAXLNUM, -deleted);\n\tmsgmore(-deleted);\n    }\n    else if (deleted < 0)\n\tmark_adjust(eap->line2, MAXLNUM, -deleted, 0L);\n\n    if (change_occurred || deleted != 0)\n\tchanged_lines(eap->line1, 0, eap->line2 + 1, -deleted);\n\n    curwin->w_cursor.lnum = eap->line1;\n    beginline(BL_WHITE | BL_FIX);\n\nsortend:\n    vim_free(nrs);\n    vim_free(sortbuf1);\n    vim_free(sortbuf2);\n    vim_regfree(regmatch.regprog);\n    if (got_int)\n\temsg(_(e_interrupted));\n}\n\n/*\n * :move command - move lines line1-line2 to line dest\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_move(linenr_T line1, linenr_T line2, linenr_T dest)\n{\n    char_u\t*str;\n    linenr_T\tl;\n    linenr_T\textra;\t    // Num lines added before line1\n    linenr_T\tnum_lines;  // Num lines moved\n    linenr_T\tlast_line;  // Last line in file after adding new text\n#ifdef FEAT_FOLDING\n    win_T\t*win;\n    tabpage_T\t*tp;\n#endif\n\n    if (dest >= line1 && dest < line2)\n    {\n\temsg(_(e_cannot_move_range_of_lines_into_itself));\n\treturn FAIL;\n    }\n\n    // Do nothing if we are not actually moving any lines.  This will prevent\n    // the 'modified' flag from being set without cause.\n    if (dest == line1 - 1 || dest == line2)\n    {\n\t// Move the cursor as if lines were moved (see below) to be backwards\n\t// compatible.\n\tif (dest >= line1)\n\t    curwin->w_cursor.lnum = dest;\n\telse\n\t    curwin->w_cursor.lnum = dest + (line2 - line1) + 1;\n\n\treturn OK;\n    }\n\n    num_lines = line2 - line1 + 1;\n\n    /*\n     * First we copy the old text to its new location -- webb\n     * Also copy the flag that \":global\" command uses.\n     */\n    if (u_save(dest, dest + 1) == FAIL)\n\treturn FAIL;\n    for (extra = 0, l = line1; l <= line2; l++)\n    {\n\tstr = vim_strsave(ml_get(l + extra));\n\tif (str != NULL)\n\t{\n\t    ml_append(dest + l - line1, str, (colnr_T)0, FALSE);\n\t    vim_free(str);\n\t    if (dest < line1)\n\t\textra++;\n\t}\n    }\n\n    /*\n     * Now we must be careful adjusting our marks so that we don't overlap our\n     * mark_adjust() calls.\n     *\n     * We adjust the marks within the old text so that they refer to the\n     * last lines of the file (temporarily), because we know no other marks\n     * will be set there since these line numbers did not exist until we added\n     * our new lines.\n     *\n     * Then we adjust the marks on lines between the old and new text positions\n     * (either forwards or backwards).\n     *\n     * And Finally we adjust the marks we put at the end of the file back to\n     * their final destination at the new text position -- webb\n     */\n    last_line = curbuf->b_ml.ml_line_count;\n    mark_adjust_nofold(line1, line2, last_line - line2, 0L);\n    if (dest >= line2)\n    {\n\tmark_adjust_nofold(line2 + 1, dest, -num_lines, 0L);\n#ifdef FEAT_FOLDING\n\tFOR_ALL_TAB_WINDOWS(tp, win) {\n\t    if (win->w_buffer == curbuf)\n\t\tfoldMoveRange(&win->w_folds, line1, line2, dest);\n\t}\n#endif\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    curbuf->b_op_start.lnum = dest - num_lines + 1;\n\t    curbuf->b_op_end.lnum = dest;\n\t}\n    }\n    else\n    {\n\tmark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L);\n#ifdef FEAT_FOLDING\n\tFOR_ALL_TAB_WINDOWS(tp, win) {\n\t    if (win->w_buffer == curbuf)\n\t\tfoldMoveRange(&win->w_folds, dest + 1, line1 - 1, line2);\n\t}\n#endif\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    curbuf->b_op_start.lnum = dest + 1;\n\t    curbuf->b_op_end.lnum = dest + num_lines;\n\t}\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    mark_adjust_nofold(last_line - num_lines + 1, last_line,\n\t\t\t\t\t     -(last_line - dest - extra), 0L);\n\n    /*\n     * Now we delete the original text -- webb\n     */\n    if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL)\n\treturn FAIL;\n\n    for (l = line1; l <= line2; l++)\n\tml_delete_flags(line1 + extra, ML_DEL_MESSAGE);\n\n    if (!global_busy && num_lines > p_report)\n\tsmsg(NGETTEXT(\"%ld line moved\", \"%ld lines moved\", num_lines),\n\t\t\t(long)num_lines);\n\n    /*\n     * Leave the cursor on the last of the moved lines.\n     */\n    if (dest >= line1)\n\tcurwin->w_cursor.lnum = dest;\n    else\n\tcurwin->w_cursor.lnum = dest + (line2 - line1) + 1;\n\n    if (line1 < dest)\n    {\n\tdest += num_lines + 1;\n\tlast_line = curbuf->b_ml.ml_line_count;\n\tif (dest > last_line + 1)\n\t    dest = last_line + 1;\n\tchanged_lines(line1, 0, dest, 0L);\n    }\n    else\n\tchanged_lines(dest + 1, 0, line1 + num_lines, 0L);\n\n    return OK;\n}\n\n/*\n * \":copy\"\n */\n    void\nex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin->w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\t// need to use vim_strsave() because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n\n    msgmore((long)count);\n}\n\nstatic char_u\t*prevcmd = NULL;\t// the previous command\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_prev_shellcmd(void)\n{\n    vim_free(prevcmd);\n}\n#endif\n\n/*\n * Handle the \":!cmd\" command.\tAlso for \":r !cmd\" and \":w !cmd\"\n * Bangs in the argument are replaced with the previously entered command.\n * Remember the argument.\n */\n    void\ndo_bang(\n    int\t\taddr_count,\n    exarg_T\t*eap,\n    int\t\tforceit,\n    int\t\tdo_in,\n    int\t\tdo_out)\n{\n    char_u\t\t*arg = eap->arg;\t// command\n    linenr_T\t\tline1 = eap->line1;\t// start of range\n    linenr_T\t\tline2 = eap->line2;\t// end of range\n    char_u\t\t*newcmd = NULL;\t\t// the new command\n    int\t\t\tfree_newcmd = FALSE;    // need to free() newcmd\n    int\t\t\tins_prevcmd;\n    char_u\t\t*t;\n    char_u\t\t*p;\n    char_u\t\t*trailarg;\n    int\t\t\tlen;\n    int\t\t\tscroll_save = msg_scroll;\n\n    /*\n     * Disallow shell commands for \"rvim\".\n     * Disallow shell commands from .exrc and .vimrc in current directory for\n     * security reasons.\n     */\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (addr_count == 0)\t\t// :!\n    {\n\tmsg_scroll = FALSE;\t    // don't scroll here\n\tautowrite_all();\n\tmsg_scroll = scroll_save;\n    }\n\n    /*\n     * Try to find an embedded bang, like in :!<cmd> ! [args]\n     * (:!! is indicated by the 'forceit' variable)\n     */\n    ins_prevcmd = forceit;\n    trailarg = arg;\n    do\n    {\n\tlen = (int)STRLEN(trailarg) + 1;\n\tif (newcmd != NULL)\n\t    len += (int)STRLEN(newcmd);\n\tif (ins_prevcmd)\n\t{\n\t    if (prevcmd == NULL)\n\t    {\n\t\temsg(_(e_no_previous_command));\n\t\tvim_free(newcmd);\n\t\treturn;\n\t    }\n\t    len += (int)STRLEN(prevcmd);\n\t}\n\tif ((t = alloc(len)) == NULL)\n\t{\n\t    vim_free(newcmd);\n\t    return;\n\t}\n\t*t = NUL;\n\tif (newcmd != NULL)\n\t    STRCAT(t, newcmd);\n\tif (ins_prevcmd)\n\t    STRCAT(t, prevcmd);\n\tp = t + STRLEN(t);\n\tSTRCAT(t, trailarg);\n\tvim_free(newcmd);\n\tnewcmd = t;\n\n\t/*\n\t * Scan the rest of the argument for '!', which is replaced by the\n\t * previous command.  \"\\!\" is replaced by \"!\" (this is vi compatible).\n\t */\n\ttrailarg = NULL;\n\twhile (*p)\n\t{\n\t    if (*p == '!')\n\t    {\n\t\tif (p > newcmd && p[-1] == '\\\\')\n\t\t    STRMOVE(p - 1, p);\n\t\telse\n\t\t{\n\t\t    trailarg = p;\n\t\t    *trailarg++ = NUL;\n\t\t    ins_prevcmd = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t    ++p;\n\t}\n    } while (trailarg != NULL);\n\n    vim_free(prevcmd);\n    prevcmd = newcmd;\n\n    if (bangredo)\t    // put cmd in redo buffer for ! command\n    {\n\t// If % or # appears in the command, it must have been escaped.\n\t// Reescape them, so that redoing them does not substitute them by the\n\t// buffername.\n\tchar_u *cmd = vim_strsave_escaped(prevcmd, (char_u *)\"%#\");\n\n\tif (cmd != NULL)\n\t{\n\t    AppendToRedobuffLit(cmd, -1);\n\t    vim_free(cmd);\n\t}\n\telse\n\t    AppendToRedobuffLit(prevcmd, -1);\n\tAppendToRedobuff((char_u *)\"\\n\");\n\tbangredo = FALSE;\n    }\n    /*\n     * Add quotes around the command, for shells that need them.\n     */\n    if (*p_shq != NUL)\n    {\n\tnewcmd = alloc(STRLEN(prevcmd) + 2 * STRLEN(p_shq) + 1);\n\tif (newcmd == NULL)\n\t    return;\n\tSTRCPY(newcmd, p_shq);\n\tSTRCAT(newcmd, prevcmd);\n\tSTRCAT(newcmd, p_shq);\n\tfree_newcmd = TRUE;\n    }\n    if (addr_count == 0)\t\t// :!\n    {\n\t// echo the command\n\tmsg_start();\n\tmsg_putchar(':');\n\tmsg_putchar('!');\n\tmsg_outtrans(newcmd);\n\tmsg_clr_eos();\n\twindgoto(msg_row, msg_col);\n\n\tdo_shell(newcmd, 0);\n    }\n    else\t\t\t\t// :range!\n    {\n\t// Careful: This may recursively call do_bang() again! (because of\n\t// autocommands)\n\tdo_filter(line1, line2, eap, newcmd, do_in, do_out);\n\tapply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, FALSE, curbuf);\n    }\n    if (free_newcmd)\n\tvim_free(newcmd);\n}\n\n/*\n * do_filter: filter lines through a command given by the user\n *\n * We mostly use temp files and the call_shell() routine here. This would\n * normally be done using pipes on a UNIX machine, but this is more portable\n * to non-unix machines. The call_shell() routine needs to be able\n * to deal with redirection somehow, and should handle things like looking\n * at the PATH env. variable, and adding reasonable extensions to the\n * command name given by the user. All reasonable versions of call_shell()\n * do this.\n * Alternatively, if on Unix and redirecting input or output, but not both,\n * and the 'shelltemp' option isn't set, use pipes.\n * We use input redirection if do_in is TRUE.\n * We use output redirection if do_out is TRUE.\n */\n    static void\ndo_filter(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    exarg_T\t*eap,\t\t// for forced 'ff' and 'fenc'\n    char_u\t*cmd,\n    int\t\tdo_in,\n    int\t\tdo_out)\n{\n    char_u\t*itmp = NULL;\n    char_u\t*otmp = NULL;\n    linenr_T\tlinecount;\n    linenr_T\tread_linecount;\n    pos_T\tcursor_save;\n    char_u\t*cmd_buf;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\tshell_flags = 0;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#ifdef FEAT_FILTERPIPE\n    int\t\tstmp = p_stmp;\n#endif\n\n    if (*cmd == NUL)\t    // no filter command\n\treturn;\n\n    // Temporarily disable lockmarks since that's needed to propagate changed\n    // regions of the buffer for foldUpdate(), linecount, etc.\n    cmdmod.cmod_flags &= ~CMOD_LOCKMARKS;\n\n    cursor_save = curwin->w_cursor;\n    linecount = line2 - line1 + 1;\n    curwin->w_cursor.lnum = line1;\n    curwin->w_cursor.col = 0;\n    changed_line_abv_curs();\n    invalidate_botline();\n\n    /*\n     * When using temp files:\n     * 1. * Form temp file names\n     * 2. * Write the lines to a temp file\n     * 3.   Run the filter command on the temp file\n     * 4. * Read the output of the command into the buffer\n     * 5. * Delete the original lines to be filtered\n     * 6. * Remove the temp files\n     *\n     * When writing the input with a pipe or when catching the output with a\n     * pipe only need to do 3.\n     */\n\n    if (do_out)\n\tshell_flags |= SHELL_DOOUT;\n\n#ifdef FEAT_FILTERPIPE\n# ifdef VIMDLL\n    if (!gui.in_use && !gui.starting)\n\tstmp = 1;   // Console mode doesn't support filterpipe.\n# endif\n\n    if (!do_in && do_out && !stmp)\n    {\n\t// Use a pipe to fetch stdout of the command, do not use a temp file.\n\tshell_flags |= SHELL_READ;\n\tcurwin->w_cursor.lnum = line2;\n    }\n    else if (do_in && !do_out && !stmp)\n    {\n\t// Use a pipe to write stdin of the command, do not use a temp file.\n\tshell_flags |= SHELL_WRITE;\n\tcurbuf->b_op_start.lnum = line1;\n\tcurbuf->b_op_end.lnum = line2;\n    }\n    else if (do_in && do_out && !stmp)\n    {\n\t// Use a pipe to write stdin and fetch stdout of the command, do not\n\t// use a temp file.\n\tshell_flags |= SHELL_READ|SHELL_WRITE;\n\tcurbuf->b_op_start.lnum = line1;\n\tcurbuf->b_op_end.lnum = line2;\n\tcurwin->w_cursor.lnum = line2;\n    }\n    else\n#endif\n\tif ((do_in && (itmp = vim_tempname('i', FALSE)) == NULL)\n\t\t|| (do_out && (otmp = vim_tempname('o', FALSE)) == NULL))\n\t{\n\t    emsg(_(e_cant_get_temp_file_name));\n\t    goto filterend;\n\t}\n\n/*\n * The writing and reading of temp files will not be shown.\n * Vi also doesn't do this and the messages are not very informative.\n */\n    ++no_wait_return;\t\t// don't call wait_return() while busy\n    if (itmp != NULL && buf_write(curbuf, itmp, NULL, line1, line2, eap,\n\t\t\t\t\t   FALSE, FALSE, FALSE, TRUE) == FAIL)\n    {\n\tmsg_putchar('\\n');\t\t// keep message from buf_write()\n\t--no_wait_return;\n#if defined(FEAT_EVAL)\n\tif (!aborting())\n#endif\n\t    (void)semsg(_(e_cant_create_file_str), itmp);\t// will call wait_return\n\tgoto filterend;\n    }\n    if (curbuf != old_curbuf)\n\tgoto filterend;\n\n    if (!do_out)\n\tmsg_putchar('\\n');\n\n    // Create the shell command in allocated memory.\n    cmd_buf = make_filter_cmd(cmd, itmp, otmp);\n    if (cmd_buf == NULL)\n\tgoto filterend;\n\n    windgoto((int)Rows - 1, 0);\n    cursor_on();\n\n    /*\n     * When not redirecting the output the command can write anything to the\n     * screen. If 'shellredir' is equal to \">\", screen may be messed up by\n     * stderr output of external command. Clear the screen later.\n     * If do_in is FALSE, this could be something like \":r !cat\", which may\n     * also mess up the screen, clear it later.\n     */\n    if (!do_out || STRCMP(p_srr, \">\") == 0 || !do_in)\n\tredraw_later_clear();\n\n    if (do_out)\n    {\n\tif (u_save(line2, (linenr_T)(line2 + 1)) == FAIL)\n\t{\n\t    vim_free(cmd_buf);\n\t    goto error;\n\t}\n\tredraw_curbuf_later(VALID);\n    }\n    read_linecount = curbuf->b_ml.ml_line_count;\n\n    /*\n     * When call_shell() fails wait_return() is called to give the user a\n     * chance to read the error messages. Otherwise errors are ignored, so you\n     * can see the error messages from the command that appear on stdout; use\n     * 'u' to fix the text\n     * Switch to cooked mode when not redirecting stdin, avoids that something\n     * like \":r !cat\" hangs.\n     * Pass on the SHELL_DOOUT flag when the output is being redirected.\n     */\n    if (call_shell(cmd_buf, SHELL_FILTER | SHELL_COOKED | shell_flags))\n    {\n\tredraw_later_clear();\n\twait_return(FALSE);\n    }\n    vim_free(cmd_buf);\n\n    did_check_timestamps = FALSE;\n    need_check_timestamps = TRUE;\n\n    // When interrupting the shell command, it may still have produced some\n    // useful output.  Reset got_int here, so that readfile() won't cancel\n    // reading.\n    ui_breakcheck();\n    got_int = FALSE;\n\n    if (do_out)\n    {\n\tif (otmp != NULL)\n\t{\n\t    if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t\t    eap, READ_FILTER) != OK)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tif (!aborting())\n#endif\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    semsg(_(e_cant_read_file_str), otmp);\n\t\t}\n\t\tgoto error;\n\t    }\n\t    if (curbuf != old_curbuf)\n\t\tgoto filterend;\n\t}\n\n\tread_linecount = curbuf->b_ml.ml_line_count - read_linecount;\n\n\tif (shell_flags & SHELL_READ)\n\t{\n\t    curbuf->b_op_start.lnum = line2 + 1;\n\t    curbuf->b_op_end.lnum = curwin->w_cursor.lnum;\n\t    appended_lines_mark(line2, read_linecount);\n\t}\n\n\tif (do_in)\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_KEEPMARKS)\n\t\t\t\t     || vim_strchr(p_cpo, CPO_REMMARK) == NULL)\n\t    {\n\t\tif (read_linecount >= linecount)\n\t\t    // move all marks from old lines to new lines\n\t\t    mark_adjust(line1, line2, linecount, 0L);\n\t\telse if (save_cmod_flags & CMOD_LOCKMARKS)\n\t\t{\n\t\t    // Move marks from the lines below the new lines down by\n\t\t    // the number of lines lost.\n\t\t    // Move marks from the lines that will be deleted to the\n\t\t    // new lines and below.\n\t\t    mark_adjust(line2 + 1, (linenr_T)MAXLNUM,\n\t\t\t\t\t       linecount - read_linecount, 0L);\n\t\t    mark_adjust(line1, line2, linecount, 0L);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // move marks from old lines to new lines, delete marks\n\t\t    // that are in deleted lines\n\t\t    mark_adjust(line1, line1 + read_linecount - 1,\n\t\t\t\t\t\t\t\tlinecount, 0L);\n\t\t    mark_adjust(line1 + read_linecount, line2, MAXLNUM, 0L);\n\t\t}\n\t    }\n\n\t    /*\n\t     * Put cursor on first filtered line for \":range!cmd\".\n\t     * Adjust '[ and '] (set by buf_write()).\n\t     */\n\t    curwin->w_cursor.lnum = line1;\n\t    del_lines(linecount, TRUE);\n\t    curbuf->b_op_start.lnum -= linecount;\t// adjust '[\n\t    curbuf->b_op_end.lnum -= linecount;\t\t// adjust ']\n\t    write_lnum_adjust(-linecount);\t\t// adjust last line\n\t\t\t\t\t\t\t// for next write\n#ifdef FEAT_FOLDING\n\t    foldUpdate(curwin, curbuf->b_op_start.lnum, curbuf->b_op_end.lnum);\n#endif\n\t}\n\telse\n\t{\n\t    /*\n\t     * Put cursor on last new line for \":r !cmd\".\n\t     */\n\t    linecount = curbuf->b_op_end.lnum - curbuf->b_op_start.lnum + 1;\n\t    curwin->w_cursor.lnum = curbuf->b_op_end.lnum;\n\t}\n\n\tbeginline(BL_WHITE | BL_FIX);\t    // cursor on first non-blank\n\t--no_wait_return;\n\n\tif (linecount > p_report)\n\t{\n\t    if (do_in)\n\t    {\n\t\tvim_snprintf(msg_buf, sizeof(msg_buf),\n\t\t\t\t    _(\"%ld lines filtered\"), (long)linecount);\n\t\tif (msg(msg_buf) && !msg_scroll)\n\t\t    // save message to display it after redraw\n\t\t    set_keep_msg((char_u *)msg_buf, 0);\n\t    }\n\t    else\n\t\tmsgmore((long)linecount);\n\t}\n    }\n    else\n    {\nerror:\n\t// put cursor back in same position for \":w !cmd\"\n\tcurwin->w_cursor = cursor_save;\n\t--no_wait_return;\n\twait_return(FALSE);\n    }\n\nfilterend:\n\n    cmdmod.cmod_flags = save_cmod_flags;\n    if (curbuf != old_curbuf)\n    {\n\t--no_wait_return;\n\temsg(_(e_filter_autocommands_must_not_change_current_buffer));\n    }\n    else if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n\n    if (itmp != NULL)\n\tmch_remove(itmp);\n    if (otmp != NULL)\n\tmch_remove(otmp);\n    vim_free(itmp);\n    vim_free(otmp);\n}\n\n/*\n * Call a shell to execute a command.\n * When \"cmd\" is NULL start an interactive shell.\n */\n    void\ndo_shell(\n    char_u\t*cmd,\n    int\t\tflags)\t// may be SHELL_DOOUT when output is redirected\n{\n    buf_T\t*buf;\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n    int\t\tsave_nwr;\n#endif\n#ifdef MSWIN\n    int\t\twinstart = FALSE;\n#endif\n    int\t\tkeep_termcap = !termcap_active;\n\n    /*\n     * Disallow shell commands for \"rvim\".\n     * Disallow shell commands from .exrc and .vimrc in current directory for\n     * security reasons.\n     */\n    if (check_restricted() || check_secure())\n    {\n\tmsg_end();\n\treturn;\n    }\n\n#ifdef MSWIN\n    /*\n     * Check if \":!start\" is used.  This implies not stopping termcap mode.\n     */\n    if (cmd != NULL)\n\tkeep_termcap = winstart = (STRNICMP(cmd, \"start \", 6) == 0);\n\n# if defined(FEAT_GUI) && defined(FEAT_TERMINAL)\n    // Don't stop termcap mode when using a terminal window for the shell.\n    if (gui.in_use && vim_strchr(p_go, GO_TERMINAL) != NULL)\n\tkeep_termcap = TRUE;\n# endif\n#endif\n\n    /*\n     * For autocommands we want to get the output on the current screen, to\n     * avoid having to type return below.\n     */\n    msg_putchar('\\r');\t\t\t// put cursor at start of line\n    if (!autocmd_busy)\n    {\n\tif (!keep_termcap)\n\t    stoptermcap();\n    }\n#ifdef MSWIN\n    if (!winstart)\n#endif\n\tmsg_putchar('\\n');\t\t// may shift screen one line up\n\n    // warning message before calling the shell\n    if (p_warn && !autocmd_busy && msg_silent == 0)\n\tFOR_ALL_BUFFERS(buf)\n\t    if (bufIsChangedNotTerm(buf))\n\t    {\n#ifdef FEAT_GUI_MSWIN\n\t\tif (!keep_termcap)\n\t\t    starttermcap();\t// don't want a message box here\n#endif\n\t\tmsg_puts(_(\"[No write since last change]\\n\"));\n#ifdef FEAT_GUI_MSWIN\n\t\tif (!keep_termcap)\n\t\t    stoptermcap();\n#endif\n\t\tbreak;\n\t    }\n\n    // This windgoto is required for when the '\\n' resulted in a \"delete line\n    // 1\" command to the terminal.\n    if (!swapping_screen())\n\twindgoto(msg_row, msg_col);\n    cursor_on();\n    (void)call_shell(cmd, SHELL_COOKED | flags);\n    did_check_timestamps = FALSE;\n    need_check_timestamps = TRUE;\n\n    /*\n     * put the message cursor at the end of the screen, avoids wait_return()\n     * to overwrite the text that the external command showed\n     */\n    if (!swapping_screen())\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\n    }\n\n    if (autocmd_busy)\n    {\n\tif (msg_silent == 0)\n\t    redraw_later_clear();\n    }\n    else\n    {\n\t/*\n\t * For \":sh\" there is no need to call wait_return(), just redraw.\n\t * Also for the Win32 GUI (the output is in a console window).\n\t * Otherwise there is probably text on the screen that the user wants\n\t * to read before redrawing, so call wait_return().\n\t */\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t{\n\t    if (cmd == NULL\n# ifdef MSWIN\n\t\t    || (keep_termcap && !need_wait_return)\n# endif\n\t       )\n\t    {\n\t\tif (msg_silent == 0)\n\t\t    redraw_later_clear();\n\t\tneed_wait_return = FALSE;\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * If we switch screens when starttermcap() is called, we\n\t\t * really want to wait for \"hit return to continue\".\n\t\t */\n\t\tsave_nwr = no_wait_return;\n\t\tif (swapping_screen())\n\t\t    no_wait_return = FALSE;\n# ifdef AMIGA\n\t\twait_return(term_console ? -1 : msg_silent == 0); // see below\n# else\n\t\twait_return(msg_silent == 0);\n# endif\n\t\tno_wait_return = save_nwr;\n\t    }\n\t}\n#endif // FEAT_GUI_MSWIN\n\n\tif (!keep_termcap)\t// if keep_termcap is TRUE didn't stop termcap\n\t    starttermcap();\t// start termcap if not done by wait_return()\n\n\t/*\n\t * In an Amiga window redrawing is caused by asking the window size.\n\t * If we got an interrupt this will not work. The chance that the\n\t * window size is wrong is very small, but we need to redraw the\n\t * screen.  Don't do this if ':' hit in wait_return().\tTHIS IS UGLY\n\t * but it saves an extra redraw.\n\t */\n#ifdef AMIGA\n\tif (skip_redraw)\t\t// ':' hit in wait_return()\n\t{\n\t    if (msg_silent == 0)\n\t\tredraw_later_clear();\n\t}\n\telse if (term_console)\n\t{\n\t    OUT_STR(\"\\033[0 q\");\t// get window size\n\t    if (got_int && msg_silent == 0)\n\t\tredraw_later_clear();\t// if got_int is TRUE, redraw needed\n\t    else\n\t\tmust_redraw = 0;\t// no extra redraw needed\n\t}\n#endif\n    }\n\n    // display any error messages now\n    display_errors();\n\n    apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, FALSE, curbuf);\n}\n\n#if !defined(UNIX)\n    static char_u *\nfind_pipe(char_u *cmd)\n{\n    char_u  *p;\n    int\t    inquote = FALSE;\n\n    for (p = cmd; *p != NUL; ++p)\n    {\n\tif (!inquote && *p == '|')\n\t    return p;\n\tif (*p == '\"')\n\t    inquote = !inquote;\n\telse if (rem_backslash(p))\n\t    ++p;\n    }\n    return NULL;\n}\n#endif\n\n/*\n * Create a shell command from a command string, input redirection file and\n * output redirection file.\n * Returns an allocated string with the shell command, or NULL for failure.\n */\n    char_u *\nmake_filter_cmd(\n    char_u\t*cmd,\t\t// command\n    char_u\t*itmp,\t\t// NULL or name of input file\n    char_u\t*otmp)\t\t// NULL or name of output file\n{\n    char_u\t*buf;\n    long_u\tlen;\n\n#if defined(UNIX)\n    int\t\tis_fish_shell;\n    char_u\t*shell_name = get_isolated_shell_name();\n\n    if (shell_name == NULL)\n\treturn NULL;\n\n    // Account for fish's different syntax for subshells\n    is_fish_shell = (fnamecmp(shell_name, \"fish\") == 0);\n    vim_free(shell_name);\n    if (is_fish_shell)\n\tlen = (long_u)STRLEN(cmd) + 13;\t\t// \"begin; \" + \"; end\" + NUL\n    else\n#endif\n\tlen = (long_u)STRLEN(cmd) + 3;\t\t\t// \"()\" + NUL\n    if (itmp != NULL)\n\tlen += (long_u)STRLEN(itmp) + 9;\t\t// \" { < \" + \" } \"\n    if (otmp != NULL)\n\tlen += (long_u)STRLEN(otmp) + (long_u)STRLEN(p_srr) + 2; // \"  \"\n    buf = alloc(len);\n    if (buf == NULL)\n\treturn NULL;\n\n#if defined(UNIX)\n    /*\n     * Put braces around the command (for concatenated commands) when\n     * redirecting input and/or output.\n     */\n    if (itmp != NULL || otmp != NULL)\n    {\n\tif (is_fish_shell)\n\t    vim_snprintf((char *)buf, len, \"begin; %s; end\", (char *)cmd);\n\telse\n\t    vim_snprintf((char *)buf, len, \"(%s)\", (char *)cmd);\n    }\n    else\n\tSTRCPY(buf, cmd);\n    if (itmp != NULL)\n    {\n\tSTRCAT(buf, \" < \");\n\tSTRCAT(buf, itmp);\n    }\n#else\n    // For shells that don't understand braces around commands, at least allow\n    // the use of commands in a pipe.\n    if (*p_sxe != NUL && *p_sxq == '(')\n    {\n\tif (itmp != NULL || otmp != NULL)\n\t    vim_snprintf((char *)buf, len, \"(%s)\", (char *)cmd);\n\telse\n\t    STRCPY(buf, cmd);\n\tif (itmp != NULL)\n\t{\n\t    STRCAT(buf, \" < \");\n\t    STRCAT(buf, itmp);\n\t}\n    }\n    else\n    {\n\tSTRCPY(buf, cmd);\n\tif (itmp != NULL)\n\t{\n\t    char_u\t*p;\n\n\t    // If there is a pipe, we have to put the '<' in front of it.\n\t    // Don't do this when 'shellquote' is not empty, otherwise the\n\t    // redirection would be inside the quotes.\n\t    if (*p_shq == NUL)\n\t    {\n\t\tp = find_pipe(buf);\n\t\tif (p != NULL)\n\t\t    *p = NUL;\n\t    }\n\t    STRCAT(buf, \" <\");\t// \" < \" causes problems on Amiga\n\t    STRCAT(buf, itmp);\n\t    if (*p_shq == NUL)\n\t    {\n\t\tp = find_pipe(cmd);\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(buf, \" \");  // insert a space before the '|' for DOS\n\t\t    STRCAT(buf, p);\n\t\t}\n\t    }\n\t}\n    }\n#endif\n    if (otmp != NULL)\n\tappend_redir(buf, (int)len, p_srr, otmp);\n\n    return buf;\n}\n\n/*\n * Append output redirection for file \"fname\" to the end of string buffer\n * \"buf[buflen]\"\n * Works with the 'shellredir' and 'shellpipe' options.\n * The caller should make sure that there is enough room:\n *\tSTRLEN(opt) + STRLEN(fname) + 3\n */\n    void\nappend_redir(\n    char_u\t*buf,\n    int\t\tbuflen,\n    char_u\t*opt,\n    char_u\t*fname)\n{\n    char_u\t*p;\n    char_u\t*end;\n\n    end = buf + STRLEN(buf);\n    // find \"%s\"\n    for (p = opt; (p = vim_strchr(p, '%')) != NULL; ++p)\n    {\n\tif (p[1] == 's') // found %s\n\t    break;\n\tif (p[1] == '%') // skip %%\n\t    ++p;\n    }\n    if (p != NULL)\n    {\n#ifdef MSWIN\n\t*end++ = ' '; // not really needed? Not with sh, ksh or bash\n#endif\n\tvim_snprintf((char *)end, (size_t)(buflen - (end - buf)),\n\t\t\t\t\t\t  (char *)opt, (char *)fname);\n    }\n    else\n\tvim_snprintf((char *)end, (size_t)(buflen - (end - buf)),\n#ifdef FEAT_QUICKFIX\n\t\t\" %s %s\",\n#else\n\t\t\" %s%s\",\t// \" > %s\" causes problems on Amiga\n#endif\n\t\t(char *)opt, (char *)fname);\n}\n\n/*\n * Implementation of \":fixdel\", also used by get_stty().\n *  <BS>    resulting <Del>\n *   ^?\t\t^H\n * not ^?\t^?\n */\n    void\ndo_fixdel(exarg_T *eap UNUSED)\n{\n    char_u  *p;\n\n    p = find_termcode((char_u *)\"kb\");\n    add_termcode((char_u *)\"kD\", p != NULL\n\t    && *p == DEL ? (char_u *)CTRL_H_STR : DEL_STR, FALSE);\n}\n\n    void\nprint_line_no_prefix(\n    linenr_T\tlnum,\n    int\t\tuse_number,\n    int\t\tlist)\n{\n    char\tnumbuf[30];\n\n    if (curwin->w_p_nu || use_number)\n    {\n\tvim_snprintf(numbuf, sizeof(numbuf),\n\t\t\t\t   \"%*ld \", number_width(curwin), (long)lnum);\n\tmsg_puts_attr(numbuf, HL_ATTR(HLF_N));\t// Highlight line nrs\n    }\n    msg_prt_line(ml_get(lnum), list);\n}\n\n/*\n * Print a text line.  Also in silent mode (\"ex -s\").\n */\n    void\nprint_line(linenr_T lnum, int use_number, int list)\n{\n    int\t\tsave_silent = silent_mode;\n\n    // apply :filter /pat/\n    if (message_filtered(ml_get(lnum)))\n\treturn;\n\n    msg_start();\n    silent_mode = FALSE;\n    info_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n    print_line_no_prefix(lnum, use_number, list);\n    if (save_silent)\n    {\n\tmsg_putchar('\\n');\n\tcursor_on();\t\t// msg_start() switches it off\n\tout_flush();\n\tsilent_mode = save_silent;\n    }\n    info_message = FALSE;\n}\n\n    int\nrename_buffer(char_u *new_fname)\n{\n    char_u\t*fname, *sfname, *xfname;\n    buf_T\t*buf;\n\n    buf = curbuf;\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    // buffer changed, don't change name now\n    if (buf != curbuf)\n\treturn FAIL;\n#ifdef FEAT_EVAL\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n    /*\n     * The name of the current buffer will be changed.\n     * A new (unlisted) buffer entry needs to be made to hold the old file\n     * name, which will become the alternate file name.\n     * But don't set the alternate file name if the buffer didn't have a\n     * name.\n     */\n    fname = curbuf->b_ffname;\n    sfname = curbuf->b_sfname;\n    xfname = curbuf->b_fname;\n    curbuf->b_ffname = NULL;\n    curbuf->b_sfname = NULL;\n    if (setfname(curbuf, new_fname, NULL, TRUE) == FAIL)\n    {\n\tcurbuf->b_ffname = fname;\n\tcurbuf->b_sfname = sfname;\n\treturn FAIL;\n    }\n    curbuf->b_flags |= BF_NOTEDITED;\n    if (xfname != NULL && *xfname != NUL)\n    {\n\tbuf = buflist_new(fname, xfname, curwin->w_cursor.lnum, 0);\n\tif (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t    curwin->w_alt_fnum = buf->b_fnum;\n    }\n    vim_free(fname);\n    vim_free(sfname);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n    return OK;\n}\n\n/*\n * \":file[!] [fname]\".\n */\n    void\nex_file(exarg_T *eap)\n{\n    // \":0file\" removes the file name.  Check for illegal uses \":3file\",\n    // \"0file name\", etc.\n    if (eap->addr_count > 0\n\t    && (*eap->arg != NUL\n\t\t|| eap->line2 > 0\n\t\t|| eap->addr_count > 1))\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    if (*eap->arg != NUL || eap->addr_count == 1)\n    {\n\tif (rename_buffer(eap->arg) == FAIL)\n\t    return;\n\tredraw_tabline = TRUE;\n    }\n\n    // print file name if no argument or 'F' is not in 'shortmess'\n    if (*eap->arg == NUL || !shortmess(SHM_FILEINFO))\n\tfileinfo(FALSE, FALSE, eap->forceit);\n}\n\n/*\n * \":update\".\n */\n    void\nex_update(exarg_T *eap)\n{\n    if (curbufIsChanged())\n\t(void)do_write(eap);\n}\n\n/*\n * \":write\" and \":saveas\".\n */\n    void\nex_write(exarg_T *eap)\n{\n    if (eap->cmdidx == CMD_saveas)\n    {\n\t// :saveas does not take a range, uses all lines.\n\teap->line1 = 1;\n\teap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    if (eap->usefilter)\t\t// input lines to shell command\n\tdo_bang(1, eap, FALSE, TRUE, FALSE);\n    else\n\t(void)do_write(eap);\n}\n\n#ifdef UNIX\n    static int\ncheck_writable(char_u *fname)\n{\n    if (mch_nodetype(fname) == NODE_OTHER)\n    {\n\tsemsg(_(e_str_is_not_file_or_writable_device), fname);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * write current buffer to file 'eap->arg'\n * if 'eap->append' is TRUE, append to the file\n *\n * if *eap->arg == NUL write to current file\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_write(exarg_T *eap)\n{\n    int\t\tother;\n    char_u\t*fname = NULL;\t\t// init to shut up gcc\n    char_u\t*ffname;\n    int\t\tretval = FAIL;\n    char_u\t*free_fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\t*browse_file = NULL;\n#endif\n    buf_T\t*alt_buf = NULL;\n    int\t\tname_was_missing;\n\n    if (not_writing())\t\t// check 'write' option\n\treturn FAIL;\n\n    ffname = eap->arg;\n#ifdef FEAT_BROWSE\n    if ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)\n    {\n\tbrowse_file = do_browse(BROWSE_SAVE, (char_u *)_(\"Save As\"), ffname,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\tif (browse_file == NULL)\n\t    goto theend;\n\tffname = browse_file;\n    }\n#endif\n    if (*ffname == NUL)\n    {\n\tif (eap->cmdidx == CMD_saveas)\n\t{\n\t    emsg(_(e_argument_required));\n\t    goto theend;\n\t}\n\tother = FALSE;\n    }\n    else\n    {\n\tfname = ffname;\n\tfree_fname = fix_fname(ffname);\n\t/*\n\t * When out-of-memory, keep unexpanded file name, because we MUST be\n\t * able to write the file in this situation.\n\t */\n\tif (free_fname != NULL)\n\t    ffname = free_fname;\n\tother = otherfile(ffname);\n    }\n\n    /*\n     * If we have a new file, put its name in the list of alternate file names.\n     */\n    if (other)\n    {\n\tif (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL\n\t\t\t\t\t\t || eap->cmdidx == CMD_saveas)\n\t    alt_buf = setaltfname(ffname, fname, (linenr_T)1);\n\telse\n\t    alt_buf = buflist_findname(ffname);\n\tif (alt_buf != NULL && alt_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    // Overwriting a file that is loaded in another buffer is not a\n\t    // good idea.\n\t    emsg(_(e_file_is_loaded_in_another_buffer));\n\t    goto theend;\n\t}\n    }\n\n    /*\n     * Writing to the current file is not allowed in readonly mode\n     * and a file name is required.\n     * \"nofile\" and \"nowrite\" buffers cannot be written implicitly either.\n     */\n    if (!other && (\n#ifdef FEAT_QUICKFIX\n\t\tbt_dontwrite_msg(curbuf) ||\n#endif\n\t\tcheck_fname() == FAIL\n#ifdef UNIX\n\t\t|| check_writable(curbuf->b_ffname) == FAIL\n#endif\n\t\t|| check_readonly(&eap->forceit, curbuf)))\n\tgoto theend;\n\n    if (!other)\n    {\n\tffname = curbuf->b_ffname;\n\tfname = curbuf->b_fname;\n\t/*\n\t * Not writing the whole file is only allowed with '!'.\n\t */\n\tif (\t   (eap->line1 != 1\n\t\t    || eap->line2 != curbuf->b_ml.ml_line_count)\n\t\t&& !eap->forceit\n\t\t&& !eap->append\n\t\t&& !p_wa)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t    {\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL,\n\t\t\t       (char_u *)_(\"Write partial file?\"), 2) != VIM_YES)\n\t\t    goto theend;\n\t\teap->forceit = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\temsg(_(e_use_bang_to_write_partial_buffer));\n\t\tgoto theend;\n\t    }\n\t}\n    }\n\n    if (check_overwrite(eap, curbuf, fname, ffname, other) == OK)\n    {\n\tif (eap->cmdidx == CMD_saveas && alt_buf != NULL)\n\t{\n\t    buf_T\t*was_curbuf = curbuf;\n\n\t    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n\t    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);\n#ifdef FEAT_EVAL\n\t    if (curbuf != was_curbuf || aborting())\n#else\n\t    if (curbuf != was_curbuf)\n#endif\n\t    {\n\t\t// buffer changed, don't change name now\n\t\tretval = FAIL;\n\t\tgoto theend;\n\t    }\n\t    // Exchange the file names for the current and the alternate\n\t    // buffer.  This makes it look like we are now editing the buffer\n\t    // under the new name.  Must be done before buf_write(), because\n\t    // if there is no file name and 'cpo' contains 'F', it will set\n\t    // the file name.\n\t    fname = alt_buf->b_fname;\n\t    alt_buf->b_fname = curbuf->b_fname;\n\t    curbuf->b_fname = fname;\n\t    fname = alt_buf->b_ffname;\n\t    alt_buf->b_ffname = curbuf->b_ffname;\n\t    curbuf->b_ffname = fname;\n\t    fname = alt_buf->b_sfname;\n\t    alt_buf->b_sfname = curbuf->b_sfname;\n\t    curbuf->b_sfname = fname;\n\t    buf_name_changed(curbuf);\n\n\t    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n\t    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);\n\t    if (!alt_buf->b_p_bl)\n\t    {\n\t\talt_buf->b_p_bl = TRUE;\n\t\tapply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);\n\t    }\n#ifdef FEAT_EVAL\n\t    if (curbuf != was_curbuf || aborting())\n#else\n\t    if (curbuf != was_curbuf)\n#endif\n\t    {\n\t\t// buffer changed, don't write the file\n\t\tretval = FAIL;\n\t\tgoto theend;\n\t    }\n\n\t    // If 'filetype' was empty try detecting it now.\n\t    if (*curbuf->b_p_ft == NUL)\n\t    {\n\t\tif (au_has_group((char_u *)\"filetypedetect\"))\n\t\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\",\n\t\t\t\t\t\t\t\t  TRUE, NULL);\n\t\tdo_modelines(0);\n\t    }\n\n\t    // Autocommands may have changed buffer names, esp. when\n\t    // 'autochdir' is set.\n\t    fname = curbuf->b_sfname;\n\t}\n\n\tname_was_missing = curbuf->b_ffname == NULL;\n\n\tretval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2,\n\t\t\t\t eap, eap->append, eap->forceit, TRUE, FALSE);\n\n\t// After \":saveas fname\" reset 'readonly'.\n\tif (eap->cmdidx == CMD_saveas)\n\t{\n\t    if (retval == OK)\n\t    {\n\t\tcurbuf->b_p_ro = FALSE;\n\t\tredraw_tabline = TRUE;\n\t    }\n\t}\n\n\t// Change directories when the 'acd' option is set and the file name\n\t// got changed or set.\n\tif (eap->cmdidx == CMD_saveas || name_was_missing)\n\t    DO_AUTOCHDIR;\n    }\n\ntheend:\n#ifdef FEAT_BROWSE\n    vim_free(browse_file);\n#endif\n    vim_free(free_fname);\n    return retval;\n}\n\n/*\n * Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,\n * BF_NEW or BF_READERR, check for overwriting current file.\n * May set eap->forceit if a dialog says it's OK to overwrite.\n * Return OK if it's OK, FAIL if it is not.\n */\n    int\ncheck_overwrite(\n    exarg_T\t*eap,\n    buf_T\t*buf,\n    char_u\t*fname,\t    // file name to be used (can differ from\n\t\t\t    // buf->ffname)\n    char_u\t*ffname,    // full path version of fname\n    int\t\tother)\t    // writing under other name\n{\n    /*\n     * Write to another file or b_flags set or not writing the whole file:\n     * overwriting only allowed with '!'.\n     */\n    if (       (other\n\t\t|| (buf->b_flags & BF_NOTEDITED)\n\t\t|| ((buf->b_flags & BF_NEW)\n\t\t    && vim_strchr(p_cpo, CPO_OVERNEW) == NULL)\n\t\t|| (buf->b_flags & BF_READERR))\n\t    && !p_wa\n\t    && vim_fexists(ffname))\n    {\n\tif (!eap->forceit && !eap->append)\n\t{\n#ifdef UNIX\n\t    // with UNIX it is possible to open a directory\n\t    if (mch_isdir(ffname))\n\t    {\n\t\tsemsg(_(e_str_is_directory), ffname);\n\t\treturn FAIL;\n\t    }\n#endif\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t    {\n\t\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\tdialog_msg(buff, _(\"Overwrite existing file \\\"%s\\\"?\"), fname);\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES)\n\t\t    return FAIL;\n\t\teap->forceit = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\temsg(_(e_file_exists));\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// For \":w! filename\" check that no swap file exists for \"filename\".\n\tif (other && !emsg_silent)\n\t{\n\t    char_u\t*dir;\n\t    char_u\t*p;\n\t    int\t\tr;\n\t    char_u\t*swapname;\n\n\t    // We only try the first entry in 'directory', without checking if\n\t    // it's writable.  If the \".\" directory is not writable the write\n\t    // will probably fail anyway.\n\t    // Use 'shortname' of the current buffer, since there is no buffer\n\t    // for the written file.\n\t    if (*p_dir == NUL)\n\t    {\n\t\tdir = alloc(5);\n\t\tif (dir == NULL)\n\t\t    return FAIL;\n\t\tSTRCPY(dir, \".\");\n\t    }\n\t    else\n\t    {\n\t\tdir = alloc(MAXPATHL);\n\t\tif (dir == NULL)\n\t\t    return FAIL;\n\t\tp = p_dir;\n\t\tcopy_option_part(&p, dir, MAXPATHL, \",\");\n\t    }\n\t    swapname = makeswapname(fname, ffname, curbuf, dir);\n\t    vim_free(dir);\n\t    r = vim_fexists(swapname);\n\t    if (r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t{\n\t\t    char_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\t    dialog_msg(buff,\n\t\t\t    _(\"Swap file \\\"%s\\\" exists, overwrite anyway?\"),\n\t\t\t\t\t\t\t\t    swapname);\n\t\t    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)\n\t\t\t\t\t\t\t\t   != VIM_YES)\n\t\t    {\n\t\t\tvim_free(swapname);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    eap->forceit = TRUE;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    semsg(_(e_swap_file_exists_str_silent_overrides), swapname);\n\t\t    vim_free(swapname);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    vim_free(swapname);\n\t}\n    }\n    return OK;\n}\n\n/*\n * Handle \":wnext\", \":wNext\" and \":wprevious\" commands.\n */\n    void\nex_wnext(exarg_T *eap)\n{\n    int\t\ti;\n\n    if (eap->cmd[1] == 'n')\n\ti = curwin->w_arg_idx + (int)eap->line2;\n    else\n\ti = curwin->w_arg_idx - (int)eap->line2;\n    eap->line1 = 1;\n    eap->line2 = curbuf->b_ml.ml_line_count;\n    if (do_write(eap) != FAIL)\n\tdo_argfile(eap, i);\n}\n\n/*\n * \":wall\", \":wqall\" and \":xall\": Write all changed files (and exit).\n */\n    void\ndo_wqall(exarg_T *eap)\n{\n    buf_T\t*buf;\n    int\t\terror = 0;\n    int\t\tsave_forceit = eap->forceit;\n\n    if (eap->cmdidx == CMD_xall || eap->cmdidx == CMD_wqall)\n\texiting = TRUE;\n\n    FOR_ALL_BUFFERS(buf)\n    {\n#ifdef FEAT_TERMINAL\n\tif (exiting && term_job_running(buf->b_term))\n\t{\n\t    no_write_message_nobang(buf);\n\t    ++error;\n\t}\n\telse\n#endif\n\tif (bufIsChanged(buf) && !bt_dontwrite(buf))\n\t{\n\t    /*\n\t     * Check if there is a reason the buffer cannot be written:\n\t     * 1. if the 'write' option is set\n\t     * 2. if there is no file name (even after browsing)\n\t     * 3. if the 'readonly' is set (even after a dialog)\n\t     * 4. if overwriting is allowed (even after a dialog)\n\t     */\n\t    if (not_writing())\n\t    {\n\t\t++error;\n\t\tbreak;\n\t    }\n#ifdef FEAT_BROWSE\n\t    // \":browse wall\": ask for file name if there isn't one\n\t    if (buf->b_ffname == NULL && (cmdmod.cmod_flags & CMOD_BROWSE))\n\t\tbrowse_save_fname(buf);\n#endif\n\t    if (buf->b_ffname == NULL)\n\t    {\n\t\tsemsg(_(e_no_file_name_for_buffer_nr), (long)buf->b_fnum);\n\t\t++error;\n\t    }\n\t    else if (check_readonly(&eap->forceit, buf)\n\t\t    || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,\n\t\t\t\t\t\t\t       FALSE) == FAIL)\n\t    {\n\t\t++error;\n\t    }\n\t    else\n\t    {\n\t\tbufref_T bufref;\n\n\t\tset_bufref(&bufref, buf);\n\t\tif (buf_write_all(buf, eap->forceit) == FAIL)\n\t\t    ++error;\n\t\t// an autocommand may have deleted the buffer\n\t\tif (!bufref_valid(&bufref))\n\t\t    buf = firstbuf;\n\t    }\n\t    eap->forceit = save_forceit;    // check_overwrite() may set it\n\t}\n    }\n    if (exiting)\n    {\n\tif (!error)\n\t    getout(0);\t\t// exit Vim\n\tnot_exiting();\n    }\n}\n\n/*\n * Check the 'write' option.\n * Return TRUE and give a message when it's not set.\n */\n    static int\nnot_writing(void)\n{\n    if (p_write)\n\treturn FALSE;\n    emsg(_(e_file_not_written_writing_is_disabled_by_write_option));\n    return TRUE;\n}\n\n/*\n * Check if a buffer is read-only (either 'readonly' option is set or file is\n * read-only). Ask for overruling in a dialog. Return TRUE and give an error\n * message when the buffer is readonly.\n */\n    static int\ncheck_readonly(int *forceit, buf_T *buf)\n{\n    stat_T\tst;\n\n    // Handle a file being readonly when the 'readonly' option is set or when\n    // the file exists and permissions are read-only.\n    // We will send 0777 to check_file_readonly(), as the \"perm\" variable is\n    // important for device checks but not here.\n    if (!*forceit && (buf->b_p_ro\n\t\t|| (mch_stat((char *)buf->b_ffname, &st) >= 0\n\t\t    && check_file_readonly(buf->b_ffname, 0777))))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t\t\t\t\t       && buf->b_fname != NULL)\n\t{\n\t    char_u\tbuff[DIALOG_MSG_SIZE];\n\n\t    if (buf->b_p_ro)\n\t\tdialog_msg(buff, _(\"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),\n\t\t    buf->b_fname);\n\t    else\n\t\tdialog_msg(buff, _(\"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),\n\t\t    buf->b_fname);\n\n\t    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES)\n\t    {\n\t\t// Set forceit, to force the writing of a readonly file\n\t\t*forceit = TRUE;\n\t\treturn FALSE;\n\t    }\n\t    else\n\t\treturn TRUE;\n\t}\n\telse\n#endif\n\tif (buf->b_p_ro)\n\t    emsg(_(e_readonly_option_is_set_add_bang_to_override));\n\telse\n\t    semsg(_(e_str_is_read_only_add_bang_to_override), buf->b_fname);\n\treturn TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Try to abandon the current file and edit a new or existing file.\n * \"fnum\" is the number of the file, if zero use \"ffname_arg\"/\"sfname_arg\".\n * \"lnum\" is the line number for the cursor in the new file (if non-zero).\n *\n * Return:\n * GETFILE_ERROR for \"normal\" error,\n * GETFILE_NOT_WRITTEN for \"not written\" error,\n * GETFILE_SAME_FILE for success\n * GETFILE_OPEN_OTHER for successfully opening another file.\n */\n    int\ngetfile(\n    int\t\tfnum,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tsetpm,\n    linenr_T\tlnum,\n    int\t\tforceit)\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    int\t\tother;\n    int\t\tretval;\n    char_u\t*free_me = NULL;\n\n    if (text_locked())\n\treturn GETFILE_ERROR;\n    if (curbuf_locked())\n\treturn GETFILE_ERROR;\n\n    if (fnum == 0)\n    {\n\t\t\t\t\t// make ffname full path, set sfname\n\tfname_expand(curbuf, &ffname, &sfname);\n\tother = otherfile(ffname);\n\tfree_me = ffname;\t\t// has been allocated, free() later\n    }\n    else\n\tother = (fnum != curbuf->b_fnum);\n\n    if (other)\n\t++no_wait_return;\t    // don't wait for autowrite message\n    if (other && !forceit && curbuf->b_nwindows == 1 && !buf_hide(curbuf)\n\t\t   && curbufIsChanged() && autowrite(curbuf, forceit) == FAIL)\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif (p_confirm && p_write)\n\t    dialog_changed(curbuf, FALSE);\n\tif (curbufIsChanged())\n#endif\n\t{\n\t    --no_wait_return;\n\t    no_write_message();\n\t    retval = GETFILE_NOT_WRITTEN;\t// file has been changed\n\t    goto theend;\n\t}\n    }\n    if (other)\n\t--no_wait_return;\n    if (setpm)\n\tsetpcmark();\n    if (!other)\n    {\n\tif (lnum != 0)\n\t    curwin->w_cursor.lnum = lnum;\n\tcheck_cursor_lnum();\n\tbeginline(BL_SOL | BL_FIX);\n\tretval = GETFILE_SAME_FILE;\t// it's in the same file\n    }\n    else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,\n\t     (buf_hide(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0),\n\t\tcurwin) == OK)\n\tretval = GETFILE_OPEN_OTHER;\t// opened another file\n    else\n\tretval = GETFILE_ERROR;\t\t// error encountered\n\ntheend:\n    vim_free(free_me);\n    return retval;\n}\n\n/*\n * start editing a new file\n *\n *     fnum: file number; if zero use ffname/sfname\n *   ffname: the file name\n *\t\t- full path if sfname used,\n *\t\t- any file name if sfname is NULL\n *\t\t- empty string to re-edit with the same file name (but may be\n *\t\t    in a different directory)\n *\t\t- NULL to start an empty buffer\n *   sfname: the short file name (or NULL)\n *\teap: contains the command to be executed after loading the file and\n *\t     forced 'ff' and 'fenc'\n *  newlnum: if > 0: put cursor on this line number (if possible)\n *\t     if ECMD_LASTL: use last position in loaded file\n *\t     if ECMD_LAST: use last position in all files\n *\t     if ECMD_ONE: use first line\n *    flags:\n *\t   ECMD_HIDE: if TRUE don't free the current buffer\n *     ECMD_SET_HELP: set b_help flag of (new) buffer before opening file\n *\t ECMD_OLDBUF: use existing buffer if it exists\n *\tECMD_FORCEIT: ! used for Ex command\n *\t ECMD_ADDBUF: don't edit, just add to buffer list\n *\t ECMD_ALTBUF: like ECMD_ADDBUF and also set the alternate file\n *   ECMD_NOWINENTER: Do not trigger BufWinEnter\n *   oldwin: Should be \"curwin\" when editing a new buffer in the current\n *\t     window, NULL when splitting the window first.  When not NULL info\n *\t     of the previous buffer for \"oldwin\" is stored.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_ecmd(\n    int\t\tfnum,\n    char_u\t*ffname,\n    char_u\t*sfname,\n    exarg_T\t*eap,\t\t\t// can be NULL!\n    linenr_T\tnewlnum,\n    int\t\tflags,\n    win_T\t*oldwin)\n{\n    int\t\tother_file;\t\t// TRUE if editing another file\n    int\t\toldbuf;\t\t\t// TRUE if using existing buffer\n    int\t\tauto_buf = FALSE;\t// TRUE if autocommands brought us\n\t\t\t\t\t// into the buffer unexpectedly\n    char_u\t*new_name = NULL;\n#if defined(FEAT_EVAL)\n    int\t\tdid_set_swapcommand = FALSE;\n#endif\n    buf_T\t*buf;\n    bufref_T\tbufref;\n    bufref_T\told_curbuf;\n    char_u\t*free_fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    char_u\t*browse_file = NULL;\n#endif\n    int\t\tretval = FAIL;\n    long\tn;\n    pos_T\torig_pos;\n    linenr_T\ttopline = 0;\n    int\t\tnewcol = -1;\n    int\t\tsolcol = -1;\n    pos_T\t*pos;\n    char_u\t*command = NULL;\n#ifdef FEAT_SPELL\n    int\t\tdid_get_winopts = FALSE;\n#endif\n    int\t\treadfile_flags = 0;\n    int\t\tdid_inc_redrawing_disabled = FALSE;\n    long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn FAIL;\n#endif\n\n    if (eap != NULL)\n\tcommand = eap->do_ecmd_cmd;\n    set_bufref(&old_curbuf, curbuf);\n\n    if (fnum != 0)\n    {\n\tif (fnum == curbuf->b_fnum)\t// file is already being edited\n\t    return OK;\t\t\t// nothing to do\n\tother_file = TRUE;\n    }\n    else\n    {\n#ifdef FEAT_BROWSE\n\tif ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)\n\t{\n\t    if (\n# ifdef FEAT_GUI\n\t\t!gui.in_use &&\n# endif\n\t\t    au_has_group((char_u *)\"FileExplorer\"))\n\t    {\n\t\t// No browsing supported but we do have the file explorer:\n\t\t// Edit the directory.\n\t\tif (ffname == NULL || !mch_isdir(ffname))\n\t\t    ffname = dot_path;\n\t    }\n\t    else\n\t    {\n\t\tbrowse_file = do_browse(0, (char_u *)_(\"Edit File\"), ffname,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\t\tif (browse_file == NULL)\n\t\t    goto theend;\n\t\tffname = browse_file;\n\t    }\n\t}\n#endif\n\t// if no short name given, use ffname for short name\n\tif (sfname == NULL)\n\t    sfname = ffname;\n#ifdef USE_FNAME_CASE\n\tif (sfname != NULL)\n\t    fname_case(sfname, 0);   // set correct case for sfname\n#endif\n\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t\t\t\t\t && (ffname == NULL || *ffname == NUL))\n\t    goto theend;\n\n\tif (ffname == NULL)\n\t    other_file = TRUE;\n\t\t\t\t\t    // there is no file name\n\telse if (*ffname == NUL && curbuf->b_ffname == NULL)\n\t    other_file = FALSE;\n\telse\n\t{\n\t    if (*ffname == NUL)\t\t    // re-edit with same file name\n\t    {\n\t\tffname = curbuf->b_ffname;\n\t\tsfname = curbuf->b_fname;\n\t    }\n\t    free_fname = fix_fname(ffname); // may expand to full path name\n\t    if (free_fname != NULL)\n\t\tffname = free_fname;\n\t    other_file = otherfile(ffname);\n\t}\n    }\n\n    /*\n     * If the file was changed we may not be allowed to abandon it:\n     * - if we are going to re-edit the same file\n     * - or if we are the only window on this file and if ECMD_HIDE is FALSE\n     */\n    if (  ((!other_file && !(flags & ECMD_OLDBUF))\n\t    || (curbuf->b_nwindows == 1\n\t\t&& !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))\n\t&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t       | (other_file ? 0 : CCGD_MULTWIN)\n\t\t\t       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)\n\t\t\t       | (eap == NULL ? 0 : CCGD_EXCMD)))\n    {\n\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n    /*\n     * End Visual mode before switching to another buffer, so the text can be\n     * copied into the GUI selection buffer.\n     */\n    reset_VIsual();\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {\n\tint\tlen;\n\tchar_u\t*p;\n\n\t// Set v:swapcommand for the SwapExists autocommands.\n\tif (command != NULL)\n\t    len = (int)STRLEN(command) + 3;\n\telse\n\t    len = 30;\n\tp = alloc(len);\n\tif (p != NULL)\n\t{\n\t    if (command != NULL)\n\t\tvim_snprintf((char *)p, len, \":%s\\r\", command);\n\t    else\n\t\tvim_snprintf((char *)p, len, \"%ldG\", (long)newlnum);\n\t    set_vim_var_string(VV_SWAPCOMMAND, p, -1);\n\t    did_set_swapcommand = TRUE;\n\t    vim_free(p);\n\t}\n    }\n#endif\n\n    /*\n     * If we are starting to edit another file, open a (new) buffer.\n     * Otherwise we re-use the current buffer.\n     */\n    if (other_file)\n    {\n\tint prev_alt_fnum = curwin->w_alt_fnum;\n\n\tif (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF)))\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\tcurwin->w_alt_fnum = curbuf->b_fnum;\n\t    if (oldwin != NULL)\n\t\tbuflist_altfpos(oldwin);\n\t}\n\n\tif (fnum)\n\t    buf = buflist_findnr(fnum);\n\telse\n\t{\n\t    if (flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t    {\n\t\t// Default the line number to zero to avoid that a wininfo item\n\t\t// is added for the current window.\n\t\tlinenr_T\ttlnum = 0;\n\t\tbuf_T\t\t*newbuf;\n\n\t\tif (command != NULL)\n\t\t{\n\t\t    tlnum = atol((char *)command);\n\t\t    if (tlnum <= 0)\n\t\t\ttlnum = 1L;\n\t\t}\n\t\t// Add BLN_NOCURWIN to avoid a new wininfo items are associated\n\t\t// with the current window.\n\t\tnewbuf = buflist_new(ffname, sfname, tlnum,\n\t\t\t\t\t\t    BLN_LISTED | BLN_NOCURWIN);\n\t\tif (newbuf != NULL && (flags & ECMD_ALTBUF))\n\t\t    curwin->w_alt_fnum = newbuf->b_fnum;\n\t\tgoto theend;\n\t    }\n\t    buf = buflist_new(ffname, sfname, 0L,\n\t\t    BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));\n\n\t    // autocommands may change curwin and curbuf\n\t    if (oldwin != NULL)\n\t\toldwin = curwin;\n\t    set_bufref(&old_curbuf, curbuf);\n\t}\n\tif (buf == NULL)\n\t    goto theend;\n\tif (curwin->w_alt_fnum == buf->b_fnum && prev_alt_fnum != 0)\n\t    // reusing the buffer, keep the old alternate file\n\t    curwin->w_alt_fnum = prev_alt_fnum;\n\n\tif (buf->b_ml.ml_mfp == NULL)\t\t// no memfile yet\n\t{\n\t    oldbuf = FALSE;\n\t}\n\telse\t\t\t\t\t// existing memfile\n\t{\n\t    oldbuf = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    (void)buf_check_timestamp(buf, FALSE);\n\t    // Check if autocommands made the buffer invalid or changed the\n\t    // current buffer.\n\t    if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)\n\t\tgoto theend;\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t\tgoto theend;\n#endif\n\t}\n\n\t// May jump to last used line number for a loaded buffer or when asked\n\t// for explicitly\n\tif ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)\n\t{\n\t    pos = buflist_findfpos(buf);\n\t    newlnum = pos->lnum;\n\t    solcol = pos->col;\n\t}\n\n\t/*\n\t * Make the (new) buffer the one used by the current window.\n\t * If the old buffer becomes unused, free it if ECMD_HIDE is FALSE.\n\t * If the current buffer was empty and has no file name, curbuf\n\t * is returned by buflist_new(), nothing to do here.\n\t */\n\tif (buf != curbuf)\n\t{\n\t    bufref_T\tsave_au_new_curbuf;\n#ifdef FEAT_CMDWIN\n\t    int\t\tsave_cmdwin_type = cmdwin_type;\n\n\t    // BufLeave applies to the old buffer.\n\t    cmdwin_type = 0;\n#endif\n\t    /*\n\t     * Be careful: The autocommands may delete any buffer and change\n\t     * the current buffer.\n\t     * - If the buffer we are going to edit is deleted, give up.\n\t     * - If the current buffer is deleted, prefer to load the new\n\t     *   buffer when loading a buffer is required.  This avoids\n\t     *   loading another buffer which then must be closed again.\n\t     * - If we ended up in the new buffer already, need to skip a few\n\t     *\t things, set auto_buf.\n\t     */\n\t    if (buf->b_fname != NULL)\n\t\tnew_name = vim_strsave(buf->b_fname);\n\t    save_au_new_curbuf = au_new_curbuf;\n\t    set_bufref(&au_new_curbuf, buf);\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n#ifdef FEAT_CMDWIN\n\t    cmdwin_type = save_cmdwin_type;\n#endif\n\t    if (!bufref_valid(&au_new_curbuf))\n\t    {\n\t\t// new buffer has been deleted\n\t\tdelbuf_msg(new_name);\t// frees new_name\n\t\tau_new_curbuf = save_au_new_curbuf;\n\t\tgoto theend;\n\t    }\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t    {\n\t\tvim_free(new_name);\n\t\tau_new_curbuf = save_au_new_curbuf;\n\t\tgoto theend;\n\t    }\n#endif\n\t    if (buf == curbuf)\t\t// already in new buffer\n\t\tauto_buf = TRUE;\n\t    else\n\t    {\n\t\twin_T\t    *the_curwin = curwin;\n\t\tint\t    did_decrement;\n\t\tbuf_T\t    *was_curbuf = curbuf;\n\n\t\t// Set the w_closing flag to avoid that autocommands close the\n\t\t// window.  And set b_locked for the same reason.\n\t\tthe_curwin->w_closing = TRUE;\n\t\t++buf->b_locked;\n\n\t\tif (curbuf == old_curbuf.br_buf)\n\t\t    buf_copy_options(buf, BCO_ENTER);\n\n\t\t// Close the link to the current buffer. This will set\n\t\t// oldwin->w_buffer to NULL.\n\t\tu_sync(FALSE);\n\t\tdid_decrement = close_buffer(oldwin, curbuf,\n\t\t\t (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);\n\n\t\t// Autocommands may have closed the window.\n\t\tif (win_valid(the_curwin))\n\t\t    the_curwin->w_closing = FALSE;\n\t\t--buf->b_locked;\n\n#ifdef FEAT_EVAL\n\t\t// autocmds may abort script processing\n\t\tif (aborting() && curwin->w_buffer != NULL)\n\t\t{\n\t\t    vim_free(new_name);\n\t\t    au_new_curbuf = save_au_new_curbuf;\n\t\t    goto theend;\n\t\t}\n#endif\n\t\t// Be careful again, like above.\n\t\tif (!bufref_valid(&au_new_curbuf))\n\t\t{\n\t\t    // new buffer has been deleted\n\t\t    delbuf_msg(new_name);\t// frees new_name\n\t\t    au_new_curbuf = save_au_new_curbuf;\n\t\t    goto theend;\n\t\t}\n\t\tif (buf == curbuf)\t\t// already in new buffer\n\t\t{\n\t\t    // close_buffer() has decremented the window count,\n\t\t    // increment it again here and restore w_buffer.\n\t\t    if (did_decrement && buf_valid(was_curbuf))\n\t\t\t++was_curbuf->b_nwindows;\n\t\t    if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)\n\t\t\toldwin->w_buffer = was_curbuf;\n\t\t    auto_buf = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_SYN_HL\n\t\t    /*\n\t\t     * <VN> We could instead free the synblock\n\t\t     * and re-attach to buffer, perhaps.\n\t\t     */\n\t\t    if (curwin->w_buffer == NULL\n\t\t\t    || curwin->w_s == &(curwin->w_buffer->b_s))\n\t\t\tcurwin->w_s = &(buf->b_s);\n#endif\n\t\t    curwin->w_buffer = buf;\n\t\t    curbuf = buf;\n\t\t    ++curbuf->b_nwindows;\n\n\t\t    // Set 'fileformat', 'binary' and 'fenc' when forced.\n\t\t    if (!oldbuf && eap != NULL)\n\t\t    {\n\t\t\tset_file_options(TRUE, eap);\n\t\t\tset_forced_fenc(eap);\n\t\t    }\n\t\t}\n\n\t\t// May get the window options from the last time this buffer\n\t\t// was in this window (or another window).  If not used\n\t\t// before, reset the local window options to the global\n\t\t// values.  Also restores old folding stuff.\n\t\tget_winopts(curbuf);\n#ifdef FEAT_SPELL\n\t\tdid_get_winopts = TRUE;\n#endif\n\t    }\n\t    vim_free(new_name);\n\t    au_new_curbuf = save_au_new_curbuf;\n\t}\n\n\tcurwin->w_pcmark.lnum = 1;\n\tcurwin->w_pcmark.col = 0;\n    }\n    else // !other_file\n    {\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL)\n\t    goto theend;\n\n\toldbuf = (flags & ECMD_OLDBUF);\n    }\n\n    // Don't redraw until the cursor is in the right line, otherwise\n    // autocommands may cause ml_get errors.\n    ++RedrawingDisabled;\n    did_inc_redrawing_disabled = TRUE;\n\n    buf = curbuf;\n    if ((flags & ECMD_SET_HELP) || keep_help_flag)\n    {\n\tprepare_help_buffer();\n    }\n    else\n    {\n\t// Don't make a buffer listed if it's a help buffer.  Useful when\n\t// using CTRL-O to go back to a help file.\n\tif (!curbuf->b_help)\n\t    set_buflisted(TRUE);\n    }\n\n    // If autocommands change buffers under our fingers, forget about\n    // editing the file.\n    if (buf != curbuf)\n\tgoto theend;\n#ifdef FEAT_EVAL\n    if (aborting())\t    // autocmds may abort script processing\n\tgoto theend;\n#endif\n\n    // Since we are starting to edit a file, consider the filetype to be\n    // unset.  Helps for when an autocommand changes files and expects syntax\n    // highlighting to work in the other file.\n    did_filetype = FALSE;\n\n/*\n * other_file\toldbuf\n *  FALSE\tFALSE\t    re-edit same file, buffer is re-used\n *  FALSE\tTRUE\t    re-edit same file, nothing changes\n *  TRUE\tFALSE\t    start editing new file, new buffer\n *  TRUE\tTRUE\t    start editing in existing buffer (nothing to do)\n */\n    if (!other_file && !oldbuf)\t\t// re-use the buffer\n    {\n\tset_last_cursor(curwin);\t// may set b_last_cursor\n\tif (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)\n\t{\n\t    newlnum = curwin->w_cursor.lnum;\n\t    solcol = curwin->w_cursor.col;\n\t}\n\tbuf = curbuf;\n\tif (buf->b_fname != NULL)\n\t    new_name = vim_strsave(buf->b_fname);\n\telse\n\t    new_name = NULL;\n\tset_bufref(&bufref, buf);\n\n\t// If the buffer was used before, store the current contents so that\n\t// the reload can be undone.  Do not do this if the (empty) buffer is\n\t// being re-used for another file.\n\tif (!(curbuf->b_flags & BF_NEVERLOADED)\n\t\t&& (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur))\n\t{\n\t    // Sync first so that this is a separate undo-able action.\n\t    u_sync(FALSE);\n\t    if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)\n\t\t\t\t\t\t\t\t     == FAIL)\n\t    {\n\t\tvim_free(new_name);\n\t\tgoto theend;\n\t    }\n\t    u_unchanged(curbuf);\n\t    buf_freeall(curbuf, BFA_KEEP_UNDO);\n\n\t    // tell readfile() not to clear or reload undo info\n\t    readfile_flags = READ_KEEP_UNDO;\n\t}\n\telse\n\t    buf_freeall(curbuf, 0);   // free all things for buffer\n\n\t// If autocommands deleted the buffer we were going to re-edit, give\n\t// up and jump to the end.\n\tif (!bufref_valid(&bufref))\n\t{\n\t    delbuf_msg(new_name);\t// frees new_name\n\t    goto theend;\n\t}\n\tvim_free(new_name);\n\n\t// If autocommands change buffers under our fingers, forget about\n\t// re-editing the file.  Should do the buf_clear_file(), but perhaps\n\t// the autocommands changed the buffer...\n\tif (buf != curbuf)\n\t    goto theend;\n#ifdef FEAT_EVAL\n\tif (aborting())\t    // autocmds may abort script processing\n\t    goto theend;\n#endif\n\tbuf_clear_file(curbuf);\n\tcurbuf->b_op_start.lnum = 0;\t// clear '[ and '] marks\n\tcurbuf->b_op_end.lnum = 0;\n    }\n\n/*\n * If we get here we are sure to start editing\n */\n    // Assume success now\n    retval = OK;\n\n    /*\n     * Check if we are editing the w_arg_idx file in the argument list.\n     */\n    check_arg_idx(curwin);\n\n    if (!auto_buf)\n    {\n\t/*\n\t * Set cursor and init window before reading the file and executing\n\t * autocommands.  This allows for the autocommands to position the\n\t * cursor.\n\t */\n\tcurwin_init();\n\n#ifdef FEAT_FOLDING\n\t// It's possible that all lines in the buffer changed.  Need to update\n\t// automatic folding for all windows where it's used.\n\t{\n\t    win_T\t    *win;\n\t    tabpage_T\t    *tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, win)\n\t\tif (win->w_buffer == curbuf)\n\t\t    foldUpdateAll(win);\n\t}\n#endif\n\n\t// Change directories when the 'acd' option is set.\n\tDO_AUTOCHDIR;\n\n\t/*\n\t * Careful: open_buffer() and apply_autocmds() may change the current\n\t * buffer and window.\n\t */\n\torig_pos = curwin->w_cursor;\n\ttopline = curwin->w_topline;\n\tif (!oldbuf)\t\t\t    // need to read the file\n\t{\n#ifdef FEAT_PROP_POPUP\n\t    // Don't use the swap-exists dialog for a popup window, can't edit\n\t    // the buffer.\n\t    if (WIN_IS_POPUP(curwin))\n\t\tcurbuf->b_flags |= BF_NO_SEA;\n#endif\n\t    swap_exists_action = SEA_DIALOG;\n\t    curbuf->b_flags |= BF_CHECK_RO; // set/reset 'ro' flag\n\n\t    /*\n\t     * Open the buffer and read the file.\n\t     */\n\t    if (flags & ECMD_NOWINENTER)\n\t\treadfile_flags |= READ_NOWINENTER;\n#if defined(FEAT_EVAL)\n\t    if (should_abort(open_buffer(FALSE, eap, readfile_flags)))\n\t\tretval = FAIL;\n#else\n\t    (void)open_buffer(FALSE, eap, readfile_flags);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n\t    curbuf->b_flags &= ~BF_NO_SEA;\n#endif\n\t    if (swap_exists_action == SEA_QUIT)\n\t\tretval = FAIL;\n\t    handle_swap_exists(&old_curbuf);\n\t}\n\telse\n\t{\n\t    // Read the modelines, but only to set window-local options.  Any\n\t    // buffer-local options have already been set and may have been\n\t    // changed by the user.\n\t    do_modelines(OPT_WINONLY);\n\n\t    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n\t    if ((flags & ECMD_NOWINENTER) == 0)\n\t\tapply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n\t}\n\tcheck_arg_idx(curwin);\n\n\t// If autocommands change the cursor position or topline, we should\n\t// keep it.  Also when it moves within a line. But not when it moves\n\t// to the first non-blank.\n\tif (!EQUAL_POS(curwin->w_cursor, orig_pos))\n\t{\n\t    char_u *text = ml_get_curline();\n\n\t    if (curwin->w_cursor.lnum != orig_pos.lnum\n\t\t    || curwin->w_cursor.col != (int)(skipwhite(text) - text))\n\t    {\n\t\tnewlnum = curwin->w_cursor.lnum;\n\t\tnewcol = curwin->w_cursor.col;\n\t    }\n\t}\n\tif (curwin->w_topline == topline)\n\t    topline = 0;\n\n\t// Even when cursor didn't move we need to recompute topline.\n\tchanged_line_abv_curs();\n\n\tmaketitle();\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)\n\tif (WIN_IS_POPUP(curwin) && curwin->w_p_pvw && retval != FAIL)\n\t    popup_set_title(curwin);\n#endif\n    }\n\n#ifdef FEAT_DIFF\n    // Tell the diff stuff that this buffer is new and/or needs updating.\n    // Also needed when re-editing the same buffer, because unloading will\n    // have removed it as a diff buffer.\n    if (curwin->w_p_diff)\n    {\n\tdiff_buf_add(curbuf);\n\tdiff_invalidate(curbuf);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // If the window options were changed may need to set the spell language.\n    // Can only do this after the buffer has been properly setup.\n    if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)did_set_spelllang(curwin);\n#endif\n\n    if (command == NULL)\n    {\n\tif (newcol >= 0)\t// position set by autocommands\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    curwin->w_cursor.col = newcol;\n\t    check_cursor();\n\t}\n\telse if (newlnum > 0)\t// line number from caller or old position\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    check_cursor_lnum();\n\t    if (solcol >= 0 && !p_sol)\n\t    {\n\t\t// 'sol' is off: Use last known column.\n\t\tcurwin->w_cursor.col = solcol;\n\t\tcheck_cursor_col();\n\t\tcurwin->w_cursor.coladd = 0;\n\t\tcurwin->w_set_curswant = TRUE;\n\t    }\n\t    else\n\t\tbeginline(BL_SOL | BL_FIX);\n\t}\n\telse\t\t\t// no line number, go to last line in Ex mode\n\t{\n\t    if (exmode_active)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n    }\n\n    // Check if cursors in other windows on the same buffer are still valid\n    check_lnums(FALSE);\n\n    /*\n     * Did not read the file, need to show some info about the file.\n     * Do this after setting the cursor.\n     */\n    if (oldbuf && !auto_buf)\n    {\n\tint\tmsg_scroll_save = msg_scroll;\n\n\t// Obey the 'O' flag in 'cpoptions': overwrite any previous file\n\t// message.\n\tif (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)\n\t    msg_scroll = FALSE;\n\tif (!msg_scroll)\t// wait a bit when overwriting an error msg\n\t    check_for_delay(FALSE);\n\tmsg_start();\n\tmsg_scroll = msg_scroll_save;\n\tmsg_scrolled_ign = TRUE;\n\n\tif (!shortmess(SHM_FILEINFO))\n\t    fileinfo(FALSE, TRUE, FALSE);\n\n\tmsg_scrolled_ign = FALSE;\n    }\n\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    if (command != NULL)\n\tdo_cmdline(command, NULL, NULL, DOCMD_VERBOSE|DOCMD_RANGEOK);\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n\n    --RedrawingDisabled;\n    did_inc_redrawing_disabled = FALSE;\n    if (!skip_redraw)\n    {\n\tn = *so_ptr;\n\tif (topline == 0 && command == NULL)\n\t    *so_ptr = 9999;\t\t// force cursor halfway the window\n\tupdate_topline();\n\tcurwin->w_scbind_pos = curwin->w_topline;\n\t*so_ptr = n;\n\tredraw_curbuf_later(NOT_VALID);\t// redraw this buffer later\n    }\n\n    if (p_im && (State & MODE_INSERT) == 0)\n\tneed_start_insertmode = TRUE;\n\n#ifdef FEAT_AUTOCHDIR\n    // Change directories when the 'acd' option is set and we aren't already in\n    // that directory (should already be done above). Expect getcwd() to be\n    // faster than calling shorten_fnames() unnecessarily.\n    if (p_acd && curbuf->b_ffname != NULL)\n    {\n\tchar_u\tcurdir[MAXPATHL];\n\tchar_u\tfiledir[MAXPATHL];\n\n\tvim_strncpy(filedir, curbuf->b_ffname, MAXPATHL - 1);\n\t*gettail_sep(filedir) = NUL;\n\tif (mch_dirname(curdir, MAXPATHL) != FAIL\n\t\t&& vim_fnamecmp(curdir, filedir) != 0)\n\t    do_autochdir();\n    }\n#endif\n\n#if defined(FEAT_NETBEANS_INTG)\n    if (curbuf->b_ffname != NULL)\n    {\n# ifdef FEAT_NETBEANS_INTG\n\tif ((flags & ECMD_SET_HELP) != ECMD_SET_HELP)\n\t    netbeans_file_opened(curbuf);\n# endif\n    }\n#endif\n\ntheend:\n    if (did_inc_redrawing_disabled)\n\t--RedrawingDisabled;\n#if defined(FEAT_EVAL)\n    if (did_set_swapcommand)\n\tset_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n#ifdef FEAT_BROWSE\n    vim_free(browse_file);\n#endif\n    vim_free(free_fname);\n    return retval;\n}\n\n    static void\ndelbuf_msg(char_u *name)\n{\n    semsg(_(e_autocommands_unexpectedly_deleted_new_buffer_str),\n\t\t\t\t\t   name == NULL ? (char_u *)\"\" : name);\n    vim_free(name);\n    au_new_curbuf.br_buf = NULL;\n    au_new_curbuf.br_buf_free_count = 0;\n}\n\nstatic int append_indent = 0;\t    // autoindent for first line\n\n/*\n * \":insert\" and \":append\", also used by \":change\"\n */\n    void\nex_append(exarg_T *eap)\n{\n    char_u\t*theline;\n    int\t\tdid_undo = FALSE;\n    linenr_T\tlnum = eap->line2;\n    int\t\tindent = 0;\n    char_u\t*p;\n    int\t\tvcol;\n    int\t\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    // the ! flag toggles autoindent\n    if (eap->forceit)\n\tcurbuf->b_p_ai = !curbuf->b_p_ai;\n\n    // First autoindent comes from the line we start on\n    if (eap->cmdidx != CMD_change && curbuf->b_p_ai && lnum > 0)\n\tappend_indent = get_indent_lnum(lnum);\n\n    if (eap->cmdidx != CMD_append)\n\t--lnum;\n\n    // when the buffer is empty need to delete the dummy line\n    if (empty && lnum == 1)\n\tlnum = 0;\n\n    State = MODE_INSERT;\t\t    // behave like in Insert mode\n    if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\tState |= MODE_LANGMAP;\n\n    for (;;)\n    {\n\tmsg_scroll = TRUE;\n\tneed_wait_return = FALSE;\n\tif (curbuf->b_p_ai)\n\t{\n\t    if (append_indent >= 0)\n\t    {\n\t\tindent = append_indent;\n\t\tappend_indent = -1;\n\t    }\n\t    else if (lnum > 0)\n\t\tindent = get_indent_lnum(lnum);\n\t}\n\tex_keep_indent = FALSE;\n\tif (eap->getline == NULL)\n\t{\n\t    // No getline() function, use the lines that follow. This ends\n\t    // when there is no more.\n\t    if (eap->nextcmd == NULL || *eap->nextcmd == NUL)\n\t\tbreak;\n\t    p = vim_strchr(eap->nextcmd, NL);\n\t    if (p == NULL)\n\t\tp = eap->nextcmd + STRLEN(eap->nextcmd);\n\t    theline = vim_strnsave(eap->nextcmd, p - eap->nextcmd);\n\t    if (*p != NUL)\n\t\t++p;\n\t    eap->nextcmd = p;\n\t}\n\telse\n\t{\n\t    int save_State = State;\n\n\t    // Set State to avoid the cursor shape to be set to MODE_INSERT\n\t    // state when getline() returns.\n\t    State = MODE_CMDLINE;\n\t    theline = eap->getline(\n#ifdef FEAT_EVAL\n\t\t    eap->cstack->cs_looplevel > 0 ? -1 :\n#endif\n\t\t    NUL, eap->cookie, indent, TRUE);\n\t    State = save_State;\n\t}\n\tlines_left = Rows - 1;\n\tif (theline == NULL)\n\t    break;\n\n\t// Using ^ CTRL-D in getexmodeline() makes us repeat the indent.\n\tif (ex_keep_indent)\n\t    append_indent = indent;\n\n\t// Look for the \".\" after automatic indent.\n\tvcol = 0;\n\tfor (p = theline; indent > vcol; ++p)\n\t{\n\t    if (*p == ' ')\n\t\t++vcol;\n\t    else if (*p == TAB)\n\t\tvcol += 8 - vcol % 8;\n\t    else\n\t\tbreak;\n\t}\n\tif ((p[0] == '.' && p[1] == NUL)\n\t\t|| (!did_undo && u_save(lnum, lnum + 1 + (empty ? 1 : 0))\n\t\t\t\t\t\t\t\t     == FAIL))\n\t{\n\t    vim_free(theline);\n\t    break;\n\t}\n\n\t// don't use autoindent if nothing was typed.\n\tif (p[0] == NUL)\n\t    theline[0] = NUL;\n\n\tdid_undo = TRUE;\n\tml_append(lnum, theline, (colnr_T)0, FALSE);\n\tif (empty)\n\t    // there are no marks below the inserted lines\n\t    appended_lines(lnum, 1L);\n\telse\n\t    appended_lines_mark(lnum, 1L);\n\n\tvim_free(theline);\n\t++lnum;\n\n\tif (empty)\n\t{\n\t    ml_delete(2L);\n\t    empty = FALSE;\n\t}\n    }\n    State = MODE_NORMAL;\n\n    if (eap->forceit)\n\tcurbuf->b_p_ai = !curbuf->b_p_ai;\n\n    // \"start\" is set to eap->line2+1 unless that position is invalid (when\n    // eap->line2 pointed to the end of the buffer and nothing was appended)\n    // \"end\" is set to lnum when something has been appended, otherwise\n    // it is the same as \"start\"  -- Acevedo\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = (eap->line2 < curbuf->b_ml.ml_line_count) ?\n\t    eap->line2 + 1 : curbuf->b_ml.ml_line_count;\n\tif (eap->cmdidx != CMD_append)\n\t    --curbuf->b_op_start.lnum;\n\tcurbuf->b_op_end.lnum = (eap->line2 < lnum)\n\t\t\t\t\t      ? lnum : curbuf->b_op_start.lnum;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n    curwin->w_cursor.lnum = lnum;\n    check_cursor_lnum();\n    beginline(BL_SOL | BL_FIX);\n\n    need_wait_return = FALSE;\t// don't use wait_return() now\n    ex_no_reprint = TRUE;\n}\n\n/*\n * \":change\"\n */\n    void\nex_change(exarg_T *eap)\n{\n    linenr_T\tlnum;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (eap->line2 >= eap->line1\n\t    && u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)\n\treturn;\n\n    // the ! flag toggles autoindent\n    if (eap->forceit ? !curbuf->b_p_ai : curbuf->b_p_ai)\n\tappend_indent = get_indent_lnum(eap->line1);\n\n    for (lnum = eap->line2; lnum >= eap->line1; --lnum)\n    {\n\tif (curbuf->b_ml.ml_flags & ML_EMPTY)\t    // nothing to delete\n\t    break;\n\tml_delete(eap->line1);\n    }\n\n    // make sure the cursor is not beyond the end of the file now\n    check_cursor_lnum();\n    deleted_lines_mark(eap->line1, (long)(eap->line2 - lnum));\n\n    // \":append\" on the line above the deleted lines.\n    eap->line2 = eap->line1;\n    ex_append(eap);\n}\n\n    void\nex_z(exarg_T *eap)\n{\n    char_u\t*x;\n    long\tbigness;\n    char_u\t*kind;\n    int\t\tminus = 0;\n    linenr_T\tstart, end, curs, i;\n    int\t\tj;\n    linenr_T\tlnum = eap->line2;\n\n    // Vi compatible: \":z!\" uses display height, without a count uses\n    // 'scroll'\n    if (eap->forceit)\n\tbigness = Rows - 1;\n    else if (!ONE_WINDOW)\n\tbigness = curwin->w_height - 3;\n    else\n\tbigness = curwin->w_p_scr * 2;\n    if (bigness < 1)\n\tbigness = 1;\n\n    x = eap->arg;\n    kind = x;\n    if (*kind == '-' || *kind == '+' || *kind == '='\n\t\t\t\t\t      || *kind == '^' || *kind == '.')\n\t++x;\n    while (*x == '-' || *x == '+')\n\t++x;\n\n    if (*x != 0)\n    {\n\tif (!VIM_ISDIGIT(*x))\n\t{\n\t    emsg(_(e_non_numeric_argument_to_z));\n\t    return;\n\t}\n\telse\n\t{\n\t    bigness = atol((char *)x);\n\n\t    // bigness could be < 0 if atol(x) overflows.\n\t    if (bigness > 2 * curbuf->b_ml.ml_line_count || bigness < 0)\n\t\tbigness = 2 * curbuf->b_ml.ml_line_count;\n\n\t    p_window = bigness;\n\t    if (*kind == '=')\n\t\tbigness += 2;\n\t}\n    }\n\n    // the number of '-' and '+' multiplies the distance\n    if (*kind == '-' || *kind == '+')\n\tfor (x = kind + 1; *x == *kind; ++x)\n\t    ;\n\n    switch (*kind)\n    {\n\tcase '-':\n\t    start = lnum - bigness * (linenr_T)(x - kind) + 1;\n\t    end = start + bigness - 1;\n\t    curs = end;\n\t    break;\n\n\tcase '=':\n\t    start = lnum - (bigness + 1) / 2 + 1;\n\t    end = lnum + (bigness + 1) / 2 - 1;\n\t    curs = lnum;\n\t    minus = 1;\n\t    break;\n\n\tcase '^':\n\t    start = lnum - bigness * 2;\n\t    end = lnum - bigness;\n\t    curs = lnum - bigness;\n\t    break;\n\n\tcase '.':\n\t    start = lnum - (bigness + 1) / 2 + 1;\n\t    end = lnum + (bigness + 1) / 2 - 1;\n\t    curs = end;\n\t    break;\n\n\tdefault:  // '+'\n\t    start = lnum;\n\t    if (*kind == '+')\n\t\tstart += bigness * (linenr_T)(x - kind - 1) + 1;\n\t    else if (eap->addr_count == 0)\n\t\t++start;\n\t    end = start + bigness - 1;\n\t    curs = end;\n\t    break;\n    }\n\n    if (start < 1)\n\tstart = 1;\n\n    if (end > curbuf->b_ml.ml_line_count)\n\tend = curbuf->b_ml.ml_line_count;\n\n    if (curs > curbuf->b_ml.ml_line_count)\n\tcurs = curbuf->b_ml.ml_line_count;\n    else if (curs < 1)\n\tcurs = 1;\n\n    for (i = start; i <= end; i++)\n    {\n\tif (minus && i == lnum)\n\t{\n\t    msg_putchar('\\n');\n\n\t    for (j = 1; j < Columns; j++)\n\t\tmsg_putchar('-');\n\t}\n\n\tprint_line(i, eap->flags & EXFLAG_NR, eap->flags & EXFLAG_LIST);\n\n\tif (minus && i == lnum)\n\t{\n\t    msg_putchar('\\n');\n\n\t    for (j = 1; j < Columns; j++)\n\t\tmsg_putchar('-');\n\t}\n    }\n\n    if (curwin->w_cursor.lnum != curs)\n    {\n\tcurwin->w_cursor.lnum = curs;\n\tcurwin->w_cursor.col = 0;\n    }\n    ex_no_reprint = TRUE;\n}\n\n/*\n * Check if the restricted flag is set.\n * If so, give an error message and return TRUE.\n * Otherwise, return FALSE.\n */\n    int\ncheck_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(e_shell_commands_and_some_functionality_not_allowed_in_rvim));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check if the secure flag is set (.exrc or .vimrc in current directory).\n * If so, give an error message and return TRUE.\n * Otherwise, return FALSE.\n */\n    int\ncheck_secure(void)\n{\n    if (secure)\n    {\n\tsecure = 2;\n\temsg(_(e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search));\n\treturn TRUE;\n    }\n#ifdef HAVE_SANDBOX\n    /*\n     * In the sandbox more things are not allowed, including the things\n     * disallowed in secure mode.\n     */\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn TRUE;\n    }\n#endif\n    return FALSE;\n}\n\nstatic char_u\t*old_sub = NULL;\t// previous substitute pattern\nstatic int\tglobal_need_beginline;\t// call beginline() after \":g\"\n\n/*\n * Flags that are kept between calls to :substitute.\n */\ntypedef struct {\n    int\tdo_all;\t\t// do multiple substitutions per line\n    int\tdo_ask;\t\t// ask for confirmation\n    int\tdo_count;\t// count only\n    int\tdo_error;\t// if false, ignore errors\n    int\tdo_print;\t// print last line with subs.\n    int\tdo_list;\t// list last line with subs.\n    int\tdo_number;\t// list last line with line nr\n    int\tdo_ic;\t\t// ignore case flag\n} subflags_T;\n\n/*\n * Skip over the \"sub\" part in :s/pat/sub/ where \"delimiter\" is the separating\n * character.\n */\n    char_u *\nskip_substitute(char_u *start, int delimiter)\n{\n    char_u *p = start;\n\n    while (p[0])\n    {\n\tif (p[0] == delimiter)\t\t// end delimiter found\n\t{\n\t    *p++ = NUL;\t\t\t// replace it with a NUL\n\t    break;\n\t}\n\tif (p[0] == '\\\\' && p[1] != 0)\t// skip escaped characters\n\t    ++p;\n\tMB_PTR_ADV(p);\n    }\n    return p;\n}\n\n    static int\ncheck_regexp_delim(int c)\n{\n    if (isalpha(c))\n    {\n\temsg(_(e_regular_expressions_cant_be_delimited_by_letters));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Perform a substitution from line eap->line1 to line eap->line2 using the\n * command pointed to by eap->arg which should be of the form:\n *\n * /pattern/substitution/{flags}\n *\n * The usual escapes are supported as described in the regexp docs.\n */\n    void\nex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    char_u\t*sub_copy = NULL;\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n    int\t\tsave_sandbox = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    if (in_vim9script())\n\t    {\n\t\temsg(_(e_cannot_use_s_backslash_in_vim9_script));\n\t\treturn;\n\t    }\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST, pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * If the substitute pattern starts with \"\\=\" then it's an expression.\n     * Make a copy, a recursive function may free it.\n     * Otherwise, '~' in the substitute pattern is replaced with the old\n     * pattern.  We do it here once to avoid it to be replaced over and over\n     * again.\n     */\n    if (sub[0] == '\\\\' && sub[1] == '=')\n    {\n\tsub = vim_strsave(sub);\n\tif (sub == NULL)\n\t    return;\n\tsub_copy = sub;\n    }\n    else\n\tsub = regtilde(sub, magic_isset());\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to MODE_CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = MODE_CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t\t// When \":normal\" runs out of characters we get\n\t\t\t\t// an empty line.  Use \"q\" to get out of the\n\t\t\t\t// loop.\n\t\t\t\tif (ex_normal_busy && typed == NUL)\n\t\t\t\t    typed = 'q';\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tsave_sandbox = sandbox;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n\n\t\t// Disallow changing text or switching window in an expression.\n\t\t++textlock;\n#endif\n\t\t// Get length of substitution part, including the NUL.\n\t\t// When it fails sublen is zero.\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, 0,\n\t\t\t       REGSUB_BACKSLASH\n\t\t\t\t    | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (sublen == 0 || aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    sandbox = save_sandbox;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n#ifdef FEAT_EVAL\n\t\t++textlock;\n#endif\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, sublen,\n\t\t\t\t      REGSUB_COPY | REGSUB_BACKSLASH\n\t\t\t\t\t | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n#endif\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n    vim_free(sub_copy);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}\n\n/*\n * Give message for number of substitutions.\n * Can also be used after a \":global\" command.\n * Return TRUE if a message was given.\n */\n    int\ndo_sub_msg(\n    int\t    count_only)\t\t// used 'n' flag for \":s\"\n{\n    /*\n     * Only report substitutions when:\n     * - more than 'report' substitutions\n     * - command was typed by user, or number of changed lines > 'report'\n     * - giving messages is not disabled by 'lazyredraw'\n     */\n    if (((sub_nsubs > p_report && (KeyTyped || sub_nlines > 1 || p_report < 1))\n\t\t|| count_only)\n\t    && messaging())\n    {\n\tchar\t*msg_single;\n\tchar\t*msg_plural;\n\n\tif (got_int)\n\t    STRCPY(msg_buf, _(\"(Interrupted) \"));\n\telse\n\t    *msg_buf = NUL;\n\n\tmsg_single = count_only\n\t\t    ? NGETTEXT(\"%ld match on %ld line\",\n\t\t\t\t\t  \"%ld matches on %ld line\", sub_nsubs)\n\t\t    : NGETTEXT(\"%ld substitution on %ld line\",\n\t\t\t\t   \"%ld substitutions on %ld line\", sub_nsubs);\n\tmsg_plural = count_only\n\t\t    ? NGETTEXT(\"%ld match on %ld lines\",\n\t\t\t\t\t \"%ld matches on %ld lines\", sub_nsubs)\n\t\t    : NGETTEXT(\"%ld substitution on %ld lines\",\n\t\t\t\t  \"%ld substitutions on %ld lines\", sub_nsubs);\n\n\tvim_snprintf_add(msg_buf, sizeof(msg_buf),\n\t\t\t\t NGETTEXT(msg_single, msg_plural, sub_nlines),\n\t\t\t\t sub_nsubs, (long)sub_nlines);\n\n\tif (msg(msg_buf))\n\t    // save message to display it after redraw\n\t    set_keep_msg((char_u *)msg_buf, 0);\n\treturn TRUE;\n    }\n    if (got_int)\n    {\n\temsg(_(e_interrupted));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nglobal_exe_one(char_u *cmd, linenr_T lnum)\n{\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    if (*cmd == NUL || *cmd == '\\n')\n\tdo_cmdline((char_u *)\"p\", NULL, NULL, DOCMD_NOWAIT);\n    else\n\tdo_cmdline(cmd, NULL, NULL, DOCMD_NOWAIT);\n}\n\n/*\n * Execute a global command of the form:\n *\n * g/pattern/X : execute X on all lines where pattern matches\n * v/pattern/X : execute X on all lines where pattern does not match\n *\n * where 'X' is an EX command\n *\n * The command character (as well as the trailing slash) is optional, and\n * is assumed to be 'p' if missing.\n *\n * This is implemented in two passes: first we scan the file for the pattern and\n * set a mark for each line that (not) matches. Secondly we execute the command\n * for each line that has a mark. This is required because after deleting\n * lines we do not know where to search for the next match.\n */\n    void\nex_global(exarg_T *eap)\n{\n    linenr_T\tlnum;\t\t// line number according to old situation\n    int\t\tndone = 0;\n    int\t\ttype;\t\t// first char of cmd: 'v' or 'g'\n    char_u\t*cmd;\t\t// command argument\n\n    char_u\tdelim;\t\t// delimiter, normally '/'\n    char_u\t*pat;\n    regmmatch_T\tregmatch;\n    int\t\tmatch;\n    int\t\twhich_pat;\n\n    // When nesting the command works on one line.  This allows for\n    // \":g/found/v/notfound/command\".\n    if (global_busy && (eap->line1 != 1\n\t\t\t\t  || eap->line2 != curbuf->b_ml.ml_line_count))\n    {\n\t// will increment global_busy to break out of the loop\n\temsg(_(e_cannot_do_global_recursive_with_range));\n\treturn;\n    }\n\n    if (eap->forceit)\t\t    // \":global!\" is like \":vglobal\"\n\ttype = 'v';\n    else\n\ttype = *eap->cmd;\n    cmd = eap->arg;\n    which_pat = RE_LAST;\t    // default: use last used regexp\n\n#ifdef FEAT_EVAL\n    if (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg) == FAIL)\n\treturn;\n#endif\n\n    /*\n     * undocumented vi feature:\n     *\t\"\\/\" and \"\\?\": use previous search pattern.\n     *\t\t \"\\&\": use previous substitute pattern.\n     */\n    if (*cmd == '\\\\')\n    {\n\t++cmd;\n\tif (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t{\n\t    emsg(_(e_backslash_should_be_followed_by));\n\t    return;\n\t}\n\tif (*cmd == '&')\n\t    which_pat = RE_SUBST;\t// use previous substitute pattern\n\telse\n\t    which_pat = RE_SEARCH;\t// use previous search pattern\n\t++cmd;\n\tpat = (char_u *)\"\";\n    }\n    else if (*cmd == NUL)\n    {\n\temsg(_(e_regular_expression_missing_from_global));\n\treturn;\n    }\n    else if (check_regexp_delim(*cmd) == FAIL)\n    {\n\treturn;\n    }\n    else\n    {\n\tdelim = *cmd;\t\t// get the delimiter\n\t++cmd;\t\t\t// skip delimiter if there is one\n\tpat = cmd;\t\t// remember start of pattern\n\tcmd = skip_regexp_ex(cmd, delim, magic_isset(), &eap->arg, NULL, NULL);\n\tif (cmd[0] == delim)\t\t    // end delimiter found\n\t    *cmd++ = NUL;\t\t    // replace it with a NUL\n    }\n\n    if (search_regcomp(pat, RE_BOTH, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\temsg(_(e_invalid_command));\n\treturn;\n    }\n\n    if (global_busy)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\tmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\tif ((type == 'g' && match) || (type == 'v' && !match))\n\t    global_exe_one(cmd, lnum);\n    }\n    else\n    {\n\t/*\n\t * pass 1: set marks for each (not) matching line\n\t */\n\tfor (lnum = eap->line1; lnum <= eap->line2 && !got_int; ++lnum)\n\t{\n\t    // a match on this line?\n\t    match = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\t    if (regmatch.regprog == NULL)\n\t\tbreak;  // re-compiling regprog failed\n\t    if ((type == 'g' && match) || (type == 'v' && !match))\n\t    {\n\t\tml_setmarked(lnum);\n\t\tndone++;\n\t    }\n\t    line_breakcheck();\n\t}\n\n\t/*\n\t * pass 2: execute the command for each line that has been marked\n\t */\n\tif (got_int)\n\t    msg(_(e_interrupted));\n\telse if (ndone == 0)\n\t{\n\t    if (type == 'v')\n\t    {\n\t\tif (in_vim9script())\n\t\t    semsg(_(e_pattern_found_in_every_line_str), pat);\n\t\telse\n\t\t    smsg(_(\"Pattern found in every line: %s\"), pat);\n\t    }\n\t    else\n\t    {\n\t\tif (in_vim9script())\n\t\t    semsg(_(e_pattern_not_found_str), pat);\n\t\telse\n\t\t    smsg(_(\"Pattern not found: %s\"), pat);\n\t    }\n\t}\n\telse\n\t{\n#ifdef FEAT_CLIPBOARD\n\t    start_global_changes();\n#endif\n\t    global_exe(cmd);\n#ifdef FEAT_CLIPBOARD\n\t    end_global_changes();\n#endif\n\t}\n\n\tml_clearmarked();\t   // clear rest of the marks\n    }\n\n    vim_regfree(regmatch.regprog);\n}\n\n/*\n * Execute \"cmd\" on lines marked with ml_setmarked().\n */\n    void\nglobal_exe(char_u *cmd)\n{\n    linenr_T old_lcount;\t// b_ml.ml_line_count before the command\n    buf_T    *old_buf = curbuf;\t// remember what buffer we started in\n    linenr_T lnum;\t\t// line number according to old situation\n\n    /*\n     * Set current position only once for a global command.\n     * If global_busy is set, setpcmark() will not do anything.\n     * If there is an error, global_busy will be incremented.\n     */\n    setpcmark();\n\n    // When the command writes a message, don't overwrite the command.\n    msg_didout = TRUE;\n\n    sub_nsubs = 0;\n    sub_nlines = 0;\n    global_need_beginline = FALSE;\n    global_busy = 1;\n    old_lcount = curbuf->b_ml.ml_line_count;\n    while (!got_int && (lnum = ml_firstmarked()) != 0 && global_busy == 1)\n    {\n\tglobal_exe_one(cmd, lnum);\n\tui_breakcheck();\n    }\n\n    global_busy = 0;\n    if (global_need_beginline)\n\tbeginline(BL_WHITE | BL_FIX);\n    else\n\tcheck_cursor();\t// cursor may be beyond the end of the line\n\n    // the cursor may not have moved in the text but a change in a previous\n    // line may move it on the screen\n    changed_line_abv_curs();\n\n    // If it looks like no message was written, allow overwriting the\n    // command with the report for number of changes.\n    if (msg_col == 0 && msg_scrolled == 0)\n\tmsg_didout = FALSE;\n\n    // If substitutes done, report number of substitutes, otherwise report\n    // number of extra or deleted lines.\n    // Don't report extra or deleted lines in the edge case where the buffer\n    // we are in after execution is different from the buffer we started in.\n    if (!do_sub_msg(FALSE) && curbuf == old_buf)\n\tmsgmore(curbuf->b_ml.ml_line_count - old_lcount);\n}\n\n#ifdef FEAT_VIMINFO\n/*\n * Get the previous substitute pattern.\n */\n    char_u *\nget_old_sub(void)\n{\n    return old_sub;\n}\n\n/*\n * Set the previous substitute pattern.  \"val\" must be allocated.\n */\n    void\nset_old_sub(char_u *val)\n{\n    vim_free(old_sub);\n    old_sub = val;\n}\n#endif // FEAT_VIMINFO\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_old_sub(void)\n{\n    vim_free(old_sub);\n}\n#endif\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Set up for a tagpreview.\n * Makes the preview window the current window.\n * Return TRUE when it was created.\n */\n    int\nprepare_tagpreview(\n    int\t\tundo_sync,\t    // sync undo when leaving the window\n    int\t\tuse_previewpopup,   // use popup if 'previewpopup' set\n    use_popup_T\tuse_popup)\t    // use other popup window\n{\n    win_T\t*wp;\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n\n    /*\n     * If there is already a preview window open, use that one.\n     */\n    if (!curwin->w_p_pvw)\n    {\n# ifdef FEAT_PROP_POPUP\n\tif (use_previewpopup && *p_pvp != NUL)\n\t{\n\t    wp = popup_find_preview_window();\n\t    if (wp != NULL)\n\t\tpopup_set_wantpos_cursor(wp, wp->w_minwidth, NULL);\n\t}\n\telse if (use_popup != USEPOPUP_NONE)\n\t{\n\t    wp = popup_find_info_window();\n\t    if (wp != NULL)\n\t    {\n\t\tif (use_popup == USEPOPUP_NORMAL)\n\t\t    popup_show(wp);\n\t\telse\n\t\t    popup_hide(wp);\n\t\t// When the popup moves or resizes it may reveal part of\n\t\t// another window.  TODO: can this be done more efficiently?\n\t\tredraw_all_later(NOT_VALID);\n\t    }\n\t}\n\telse\n# endif\n\t{\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_p_pvw)\n\t\t    break;\n\t}\n\tif (wp != NULL)\n\t    win_enter(wp, undo_sync);\n\telse\n\t{\n\t    /*\n\t     * There is no preview window open yet.  Create one.\n\t     */\n# ifdef FEAT_PROP_POPUP\n\t    if ((use_previewpopup && *p_pvp != NUL)\n\t\t\t\t\t\t || use_popup != USEPOPUP_NONE)\n\t\treturn popup_create_preview_window(use_popup != USEPOPUP_NONE);\n# endif\n\t    if (win_split(g_do_tagpreview > 0 ? g_do_tagpreview : 0, 0) == FAIL)\n\t\treturn FALSE;\n\t    curwin->w_p_pvw = TRUE;\n\t    curwin->w_p_wfh = TRUE;\n\t    RESET_BINDING(curwin);\t    // don't take over 'scrollbind'\n\t    // and 'cursorbind'\n# ifdef FEAT_DIFF\n\t    curwin->w_p_diff = FALSE;\t    // no 'diff'\n# endif\n# ifdef FEAT_FOLDING\n\t    curwin->w_p_fdc = 0;\t    // no 'foldcolumn'\n# endif\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n#endif\n\n/*\n * Make the user happy.\n */\n    void\nex_smile(exarg_T *eap UNUSED)\n{\n    static char *code[] = {\n\t\"\\34 \\4o\\14$\\4ox\\30 \\2o\\30$\\1ox\\25 \\2o\\36$\\1o\\11 \\1o\\1$\\3 \\2$\\1 \\1o\\1$x\\5 \\1o\\1 \\1$\\1 \\2o\\10 \\1o\\44$\\1o\\7 \\2$\\1 \\2$\\1 \\2$\\1o\\1$x\\2 \\2o\\1 \\1$\\1 \\1$\\1 \\1\\\"\\1$\\6 \\1o\\11$\\4 \\15$\\4 \\11$\\1o\\7 \\3$\\1o\\2$\\1o\\1$x\\2 \\1\\\"\\6$\\1o\\1$\\5 \\1o\\11$\\6 \\13$\\6 \\12$\\1o\\4 \\10$x\\4 \\7$\\4 \\13$\\6 \\13$\\6 \\27$x\\4 \\27$\\4 \\15$\\4 \\16$\\2 \\3\\\"\\3$x\\5 \\1\\\"\\3$\\4\\\"\\61$\\5 \\1\\\"\\3$x\\6 \\3$\\3 \\1o\\62$\\5 \\1\\\"\\3$\\1ox\\5 \\1o\\2$\\1\\\"\\3 \\63$\\7 \\3$\\1ox\\5 \\3$\\4 \\55$\\1\\\"\\1 \\1\\\"\\6$\",\n\t\"\\5o\\4$\\1ox\\4 \\1o\\3$\\4o\\5$\\2 \\45$\\3 \\1o\\21$x\\4 \\10$\\1\\\"\\4$\\3 \\42$\\5 \\4$\\10\\\"x\\3 \\4\\\"\\7 \\4$\\4 \\1\\\"\\34$\\1\\\"\\6 \\1o\\3$x\\16 \\1\\\"\\3$\\1o\\5 \\3\\\"\\22$\\1\\\"\\2$\\1\\\"\\11 \\3$x\\20 \\3$\\1o\\12 \\1\\\"\\2$\\2\\\"\\6$\\4\\\"\\13 \\1o\\3$x\\21 \\4$\\1o\\40 \\1o\\3$\\1\\\"x\\22 \\1\\\"\\4$\\1o\\6 \\1o\\6$\\1o\\1\\\"\\4$\\1o\\10 \\1o\\4$x\\24 \\1\\\"\\5$\\2o\\5 \\2\\\"\\4$\\1o\\5$\\1o\\3 \\1o\\4$\\2\\\"x\\27 \\2\\\"\\5$\\4o\\2 \\1\\\"\\3$\\1o\\11$\\3\\\"x\\32 \\2\\\"\\7$\\2o\\1 \\12$x\\42 \\4\\\"\\13$x\\46 \\14$x\\47 \\12$\\1\\\"x\\50 \\1\\\"\\3$\\4\\\"x\"\n    };\n    char *p;\n    int n;\n    int i;\n\n    msg_start();\n    msg_putchar('\\n');\n    for (i = 0; i < 2; ++i)\n\tfor (p = code[i]; *p != NUL; ++p)\n\t    if (*p == 'x')\n\t\tmsg_putchar('\\n');\n\t    else\n\t\tfor (n = *p++; n > 0; --n)\n\t\t    if (*p == 'o' || *p == '$')\n\t\t\tmsg_putchar_attr(*p, HL_ATTR(HLF_L));\n\t\t    else\n\t\t\tmsg_putchar(*p);\n    msg_clr_eos();\n}\n\n/*\n * \":drop\"\n * Opens the first argument in a window.  When there are two or more arguments\n * the argument list is redefined.\n */\n    void\nex_drop(exarg_T *eap)\n{\n    int\t\tsplit = FALSE;\n    win_T\t*wp;\n    buf_T\t*buf;\n    tabpage_T\t*tp;\n\n    if (ERROR_IF_POPUP_WINDOW || ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n\n    /*\n     * Check if the first argument is already being edited in a window.  If\n     * so, jump to that window.\n     * We would actually need to check all arguments, but that's complicated\n     * and mostly only one file is dropped.\n     * This also ignores wildcards, since it is very unlikely the user is\n     * editing a file name with a wildcard character.\n     */\n    set_arglist(eap->arg);\n\n    /*\n     * Expanding wildcards may result in an empty argument list.  E.g. when\n     * editing \"foo.pyc\" and \".pyc\" is in 'wildignore'.  Assume that we\n     * already did an error message for this.\n     */\n    if (ARGCOUNT == 0)\n\treturn;\n\n    if (cmdmod.cmod_tab)\n    {\n\t// \":tab drop file ...\": open a tab for each argument that isn't\n\t// edited in a window yet.  It's like \":tab all\" but without closing\n\t// windows or tabs.\n\tex_all(eap);\n    }\n    else\n    {\n\t// \":drop file ...\": Edit the first argument.  Jump to an existing\n\t// window if possible, edit in current window if the current buffer\n\t// can be abandoned, otherwise open a new window.\n\tbuf = buflist_findnr(ARGLIST[0].ae_fnum);\n\n\tFOR_ALL_TAB_WINDOWS(tp, wp)\n\t{\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tcurwin->w_arg_idx = 0;\n\t\tif (!bufIsChanged(curbuf))\n\t\t{\n\t\t    int save_ar = curbuf->b_p_ar;\n\n\t\t    // reload the file if it is newer\n\t\t    curbuf->b_p_ar = TRUE;\n\t\t    buf_check_timestamp(curbuf, FALSE);\n\t\t    curbuf->b_p_ar = save_ar;\n\t\t}\n\t\treturn;\n\t    }\n\t}\n\n\t/*\n\t * Check whether the current buffer is changed. If so, we will need\n\t * to split the current window or data could be lost.\n\t * Skip the check if the 'hidden' option is set, as in this case the\n\t * buffer won't be lost.\n\t */\n\tif (!buf_hide(curbuf))\n\t{\n\t    ++emsg_off;\n\t    split = check_changed(curbuf, CCGD_AW | CCGD_EXCMD);\n\t    --emsg_off;\n\t}\n\n\t// Fake a \":sfirst\" or \":first\" command edit the first argument.\n\tif (split)\n\t{\n\t    eap->cmdidx = CMD_sfirst;\n\t    eap->cmd[0] = 's';\n\t}\n\telse\n\t    eap->cmdidx = CMD_first;\n\tex_rewind(eap);\n    }\n}\n\n/*\n * Skip over the pattern argument of \":vimgrep /pat/[g][j]\".\n * Put the start of the pattern in \"*s\", unless \"s\" is NULL.\n * If \"flags\" is not NULL put the flags in it: VGR_GLOBAL, VGR_NOJUMP.\n * If \"s\" is not NULL terminate the pattern with a NUL.\n * Return a pointer to the char just past the pattern plus flags.\n */\n    char_u *\nskip_vimgrep_pat(char_u *p, char_u **s, int *flags)\n{\n    return skip_vimgrep_pat_ext(p, s, flags, NULL, NULL);\n}\n\n/*\n * As skip_vimgrep_pat() and store the character overwritten by NUL in \"cp\"\n * and the pointer to it in \"nulp\".\n */\n    char_u *\nskip_vimgrep_pat_ext(char_u *p, char_u **s, int *flags, char_u **nulp, int *cp)\n{\n    int\t\tc;\n\n    if (vim_isIDc(*p))\n    {\n\t// \":vimgrep pattern fname\"\n\tif (s != NULL)\n\t    *s = p;\n\tp = skiptowhite(p);\n\tif (s != NULL && *p != NUL)\n\t{\n\t    if (nulp != NULL)\n\t    {\n\t\t*nulp = p;\n\t\t*cp = *p;\n\t    }\n\t    *p++ = NUL;\n\t}\n    }\n    else\n    {\n\t// \":vimgrep /pattern/[g][j] fname\"\n\tif (s != NULL)\n\t    *s = p + 1;\n\tc = *p;\n\tp = skip_regexp(p + 1, c, TRUE);\n\tif (*p != c)\n\t    return NULL;\n\n\t// Truncate the pattern.\n\tif (s != NULL)\n\t{\n\t    if (nulp != NULL)\n\t    {\n\t\t*nulp = p;\n\t\t*cp = *p;\n\t    }\n\t    *p = NUL;\n\t}\n\t++p;\n\n\t// Find the flags\n\twhile (*p == 'g' || *p == 'j' || *p == 'f')\n\t{\n\t    if (flags != NULL)\n\t    {\n\t\tif (*p == 'g')\n\t\t    *flags |= VGR_GLOBAL;\n\t\telse if (*p == 'j')\n\t\t    *flags |= VGR_NOJUMP;\n\t\telse\n\t\t    *flags |= VGR_FUZZY;\n\t    }\n\t    ++p;\n\t}\n    }\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * List v:oldfiles in a nice way.\n */\n    void\nex_oldfiles(exarg_T *eap UNUSED)\n{\n    list_T\t*l = get_vim_var_list(VV_OLDFILES);\n    listitem_T\t*li;\n    int\t\tnr = 0;\n    char_u\t*fname;\n\n    if (l == NULL)\n\tmsg(_(\"No old files\"));\n    else\n    {\n\tmsg_start();\n\tmsg_scroll = TRUE;\n\tfor (li = l->lv_first; li != NULL && !got_int; li = li->li_next)\n\t{\n\t    ++nr;\n\t    fname = tv_get_string(&li->li_tv);\n\t    if (!message_filtered(fname))\n\t    {\n\t\tmsg_outnum((long)nr);\n\t\tmsg_puts(\": \");\n\t\tmsg_outtrans(fname);\n\t\tmsg_clr_eos();\n\t\tmsg_putchar('\\n');\n\t\tout_flush();\t    // output one line at a time\n\t\tui_breakcheck();\n\t    }\n\t}\n\n\t// Assume \"got_int\" was set to truncate the listing.\n\tgot_int = FALSE;\n\n# ifdef FEAT_BROWSE_CMD\n\tif (cmdmod.cmod_flags & CMOD_BROWSE)\n\t{\n\t    quit_more = FALSE;\n\t    nr = prompt_for_number(FALSE);\n\t    msg_starthere();\n\t    if (nr > 0)\n\t    {\n\t\tchar_u *p = list_find_str(get_vim_var_list(VV_OLDFILES),\n\t\t\t\t\t\t\t\t    (long)nr);\n\n\t\tif (p != NULL)\n\t\t{\n\t\t    p = expand_env_save(p);\n\t\t    eap->arg = p;\n\t\t    eap->cmdidx = CMD_edit;\n\t\t    cmdmod.cmod_flags &= ~CMOD_BROWSE;\n\t\t    do_exedit(eap, NULL);\n\t\t    vim_free(p);\n\t\t}\n\t    }\n\t}\n# endif\n    }\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()\n */\n\n// By default: do not create debugging logs or files related to regular\n// expressions, even when compiling with -DDEBUG.\n// Uncomment the second line to get the regexp debugging.\n#undef DEBUG\n// #define DEBUG\n\n#include \"vim.h\"\n\n#ifdef DEBUG\n// show/save debugging data when BT engine is used\n# define BT_REGEXP_DUMP\n// save the debugging data to a file instead of displaying it\n# define BT_REGEXP_LOG\n# define BT_REGEXP_DEBUG_LOG\n# define BT_REGEXP_DEBUG_LOG_NAME\t\"bt_regexp_debug.log\"\n#endif\n\n#ifdef FEAT_RELTIME\nstatic sig_atomic_t dummy_timeout_flag = 0;\nstatic volatile sig_atomic_t *timeout_flag = &dummy_timeout_flag;\n#endif\n\n/*\n * Magic characters have a special meaning, they don't match literally.\n * Magic characters are negative.  This separates them from literal characters\n * (possibly multi-byte).  Only ASCII characters can be Magic.\n */\n#define Magic(x)\t((int)(x) - 256)\n#define un_Magic(x)\t((x) + 256)\n#define is_Magic(x)\t((x) < 0)\n\n    static int\nno_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return x;\n}\n\n    static int\ntoggle_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return Magic(x);\n}\n\n#ifdef FEAT_RELTIME\n    void\ninit_regexp_timeout(long msec)\n{\n    timeout_flag = start_timeout(msec);\n}\n\n    void\ndisable_regexp_timeout(void)\n{\n    stop_timeout();\n    timeout_flag = &dummy_timeout_flag;\n}\n#endif\n\n/*\n * The first byte of the BT regexp internal \"program\" is actually this magic\n * number; the start node begins in the second byte.  It's used to catch the\n * most severe mutilation of the program by the caller.\n */\n\n#define REGMAGIC\t0234\n\n/*\n * Utility definitions.\n */\n#define UCHARAT(p)\t((int)*(char_u *)(p))\n\n// Used for an error (down from) vim_regcomp(): give the error message, set\n// rc_did_emsg and return NULL\n#define EMSG_RET_NULL(m) return (emsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define IEMSG_RET_NULL(m) return (iemsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG_RET_FAIL(m) return (emsg((m)), rc_did_emsg = TRUE, FAIL)\n#define EMSG2_RET_NULL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG3_RET_NULL(m, c, a) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\", (a)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG2_RET_FAIL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, FAIL)\n#define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_(e_invalid_item_in_str_brackets), reg_magic == MAGIC_ALL)\n\n\n#define MAX_LIMIT\t(32767L << 16L)\n\n#define NOT_MULTI\t0\n#define MULTI_ONE\t1\n#define MULTI_MULT\t2\n\n// return values for regmatch()\n#define RA_FAIL\t\t1\t// something failed, abort\n#define RA_CONT\t\t2\t// continue in inner loop\n#define RA_BREAK\t3\t// break inner loop\n#define RA_MATCH\t4\t// successful match\n#define RA_NOMATCH\t5\t// didn't match\n\n/*\n * Return NOT_MULTI if c is not a \"multi\" operator.\n * Return MULTI_ONE if c is a single \"multi\" operator.\n * Return MULTI_MULT if c is a multi \"multi\" operator.\n */\n    static int\nre_multi_type(int c)\n{\n    if (c == Magic('@') || c == Magic('=') || c == Magic('?'))\n\treturn MULTI_ONE;\n    if (c == Magic('*') || c == Magic('+') || c == Magic('{'))\n\treturn MULTI_MULT;\n    return NOT_MULTI;\n}\n\nstatic char_u\t\t*reg_prev_sub = NULL;\n\n/*\n * REGEXP_INRANGE contains all characters which are always special in a []\n * range after '\\'.\n * REGEXP_ABBR contains all characters which act as abbreviations after '\\'.\n * These are:\n *  \\n\t- New line (NL).\n *  \\r\t- Carriage Return (CR).\n *  \\t\t- Tab (TAB).\n *  \\e\t- Escape (ESC).\n *  \\b\t- Backspace (Ctrl_H).\n *  \\d  - Character code in decimal, eg \\d123\n *  \\o\t- Character code in octal, eg \\o80\n *  \\x\t- Character code in hex, eg \\x4a\n *  \\u\t- Multibyte character code, eg \\u20ac\n *  \\U\t- Long multibyte character code, eg \\U12345678\n */\nstatic char_u REGEXP_INRANGE[] = \"]^-n\\\\\";\nstatic char_u REGEXP_ABBR[] = \"nrtebdoxuU\";\n\n/*\n * Translate '\\x' to its control character, except \"\\n\", which is Magic.\n */\n    static int\nbackslash_trans(int c)\n{\n    switch (c)\n    {\n\tcase 'r':   return CAR;\n\tcase 't':   return TAB;\n\tcase 'e':   return ESC;\n\tcase 'b':   return BS;\n    }\n    return c;\n}\n\n/*\n * Check for a character class name \"[:name:]\".  \"pp\" points to the '['.\n * Returns one of the CLASS_ items. CLASS_NONE means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_char_class(char_u **pp)\n{\n    static const char *(class_names[]) =\n    {\n\t\"alnum:]\",\n#define CLASS_ALNUM 0\n\t\"alpha:]\",\n#define CLASS_ALPHA 1\n\t\"blank:]\",\n#define CLASS_BLANK 2\n\t\"cntrl:]\",\n#define CLASS_CNTRL 3\n\t\"digit:]\",\n#define CLASS_DIGIT 4\n\t\"graph:]\",\n#define CLASS_GRAPH 5\n\t\"lower:]\",\n#define CLASS_LOWER 6\n\t\"print:]\",\n#define CLASS_PRINT 7\n\t\"punct:]\",\n#define CLASS_PUNCT 8\n\t\"space:]\",\n#define CLASS_SPACE 9\n\t\"upper:]\",\n#define CLASS_UPPER 10\n\t\"xdigit:]\",\n#define CLASS_XDIGIT 11\n\t\"tab:]\",\n#define CLASS_TAB 12\n\t\"return:]\",\n#define CLASS_RETURN 13\n\t\"backspace:]\",\n#define CLASS_BACKSPACE 14\n\t\"escape:]\",\n#define CLASS_ESCAPE 15\n\t\"ident:]\",\n#define CLASS_IDENT 16\n\t\"keyword:]\",\n#define CLASS_KEYWORD 17\n\t\"fname:]\",\n#define CLASS_FNAME 18\n    };\n#define CLASS_NONE 99\n    int i;\n\n    if ((*pp)[1] == ':')\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(class_names); ++i)\n\t    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)\n\t    {\n\t\t*pp += STRLEN(class_names[i]) + 2;\n\t\treturn i;\n\t    }\n    }\n    return CLASS_NONE;\n}\n\n/*\n * Specific version of character class functions.\n * Using a table to keep this fast.\n */\nstatic short\tclass_tab[256];\n\n#define\t    RI_DIGIT\t0x01\n#define\t    RI_HEX\t0x02\n#define\t    RI_OCTAL\t0x04\n#define\t    RI_WORD\t0x08\n#define\t    RI_HEAD\t0x10\n#define\t    RI_ALPHA\t0x20\n#define\t    RI_LOWER\t0x40\n#define\t    RI_UPPER\t0x80\n#define\t    RI_WHITE\t0x100\n\n    static void\ninit_class_tab(void)\n{\n    int\t\ti;\n    static int\tdone = FALSE;\n\n    if (done)\n\treturn;\n\n    for (i = 0; i < 256; ++i)\n    {\n\tif (i >= '0' && i <= '7')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;\n\telse if (i >= '8' && i <= '9')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;\n\telse if (i >= 'a' && i <= 'f')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'g' && i <= 'z')\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'A' && i <= 'F')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i >= 'G' && i <= 'Z')\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i == '_')\n\t    class_tab[i] = RI_WORD + RI_HEAD;\n\telse\n\t    class_tab[i] = 0;\n    }\n    class_tab[' '] |= RI_WHITE;\n    class_tab['\\t'] |= RI_WHITE;\n    done = TRUE;\n}\n\n#define ri_digit(c)\t((c) < 0x100 && (class_tab[c] & RI_DIGIT))\n#define ri_hex(c)\t((c) < 0x100 && (class_tab[c] & RI_HEX))\n#define ri_octal(c)\t((c) < 0x100 && (class_tab[c] & RI_OCTAL))\n#define ri_word(c)\t((c) < 0x100 && (class_tab[c] & RI_WORD))\n#define ri_head(c)\t((c) < 0x100 && (class_tab[c] & RI_HEAD))\n#define ri_alpha(c)\t((c) < 0x100 && (class_tab[c] & RI_ALPHA))\n#define ri_lower(c)\t((c) < 0x100 && (class_tab[c] & RI_LOWER))\n#define ri_upper(c)\t((c) < 0x100 && (class_tab[c] & RI_UPPER))\n#define ri_white(c)\t((c) < 0x100 && (class_tab[c] & RI_WHITE))\n\n// flags for regflags\n#define RF_ICASE    1\t// ignore case\n#define RF_NOICASE  2\t// don't ignore case\n#define RF_HASNL    4\t// can match a NL\n#define RF_ICOMBINE 8\t// ignore combining characters\n#define RF_LOOKBH   16\t// uses \"\\@<=\" or \"\\@<!\"\n\n/*\n * Global work variables for vim_regcomp().\n */\n\nstatic char_u\t*regparse;\t// Input-scan pointer.\nstatic int\tregnpar;\t// () count.\nstatic int\twants_nfa;\t// regex should use NFA engine\n#ifdef FEAT_SYN_HL\nstatic int\tregnzpar;\t// \\z() count.\nstatic int\tre_has_z;\t// \\z item detected\n#endif\nstatic unsigned\tregflags;\t// RF_ flags for prog\n#if defined(FEAT_SYN_HL) || defined(PROTO)\nstatic int\thad_eol;\t// TRUE when EOL found by vim_regcomp()\n#endif\n\nstatic magic_T\treg_magic;\t// magicness of the pattern\n\nstatic int\treg_string;\t// matching with a string instead of a buffer\n\t\t\t\t// line\nstatic int\treg_strict;\t// \"[abc\" is illegal\n\n/*\n * META contains all characters that may be magic, except '^' and '$'.\n */\n\n// META[] is used often enough to justify turning it into a table.\nstatic char_u META_flags[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//\t\t   %  &     (  )  *  +\t      .\n    0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,\n//     1  2  3\t4  5  6  7  8  9\t<  =  >  ?\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,\n//  @  A     C\tD     F     H  I     K\tL  M\t O\n    1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,\n//  P\t     S\t   U  V  W  X\t  Z  [\t\t _\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,\n//     a     c\td     f     h  i     k\tl  m  n  o\n    0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,\n//  p\t     s\t   u  v  w  x\t  z  {\t|     ~\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1\n};\n\nstatic int\tcurchr;\t\t// currently parsed character\n// Previous character.  Note: prevchr is sometimes -1 when we are not at the\n// start, eg in /[ ^I]^ the pattern was never found even if it existed,\n// because ^ was taken to be magic -- webb\nstatic int\tprevchr;\nstatic int\tprevprevchr;\t// previous-previous character\nstatic int\tnextchr;\t// used for ungetchr()\n\n// arguments for reg()\n#define REG_NOPAREN\t0\t// toplevel reg()\n#define REG_PAREN\t1\t// \\(\\)\n#define REG_ZPAREN\t2\t// \\z(\\)\n#define REG_NPAREN\t3\t// \\%(\\)\n\ntypedef struct\n{\n     char_u\t*regparse;\n     int\tprevchr_len;\n     int\tcurchr;\n     int\tprevchr;\n     int\tprevprevchr;\n     int\tnextchr;\n     int\tat_start;\n     int\tprev_at_start;\n     int\tregnpar;\n} parse_state_T;\n\nstatic void\tinitchr(char_u *);\nstatic int\tgetchr(void);\nstatic void\tskipchr_keepstart(void);\nstatic int\tpeekchr(void);\nstatic void\tskipchr(void);\nstatic void\tungetchr(void);\nstatic long\tgethexchrs(int maxinputlen);\nstatic long\tgetoctchrs(void);\nstatic long\tgetdecchrs(void);\nstatic int\tcoll_get_char(void);\nstatic int\tprog_magic_wrong(void);\nstatic int\tcstrncmp(char_u *s1, char_u *s2, int *n);\nstatic char_u\t*cstrchr(char_u *, int);\nstatic int\tre_mult_next(char *what);\nstatic int\treg_iswordc(int);\n#ifdef FEAT_EVAL\nstatic void report_re_switch(char_u *pat);\n#endif\n\nstatic regengine_T bt_regengine;\nstatic regengine_T nfa_regengine;\n\n/*\n * Return TRUE if compiled regular expression \"prog\" can match a line break.\n */\n    int\nre_multiline(regprog_T *prog)\n{\n    return (prog->regflags & RF_HASNL);\n}\n\n/*\n * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['.\n * Returns a character representing the class. Zero means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_equi_class(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[1] == '=' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '=' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\n/*\n * Check for a collating element \"[.a.]\".  \"pp\" points to the '['.\n * Returns a character. Zero means that no item was recognized.  Otherwise\n * \"pp\" is advanced to after the item.\n * Currently only single characters are recognized!\n */\n    static int\nget_coll_element(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[0] != NUL && p[1] == '.' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '.' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\nstatic int reg_cpo_lit; // 'cpoptions' contains 'l' flag\nstatic int reg_cpo_bsl; // 'cpoptions' contains '\\' flag\n\n    static void\nget_cpo_flags(void)\n{\n    reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;\n    reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;\n}\n\n/*\n * Skip over a \"[]\" range.\n * \"p\" must point to the character after the '['.\n * The returned pointer is on the matching ']', or the terminating NUL.\n */\n    static char_u *\nskip_anyof(char_u *p)\n{\n    int\t\tl;\n\n    if (*p == '^')\t// Complement of range.\n\t++p;\n    if (*p == ']' || *p == '-')\n\t++p;\n    while (*p != NUL && *p != ']')\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t    p += l;\n\telse\n\t    if (*p == '-')\n\t    {\n\t\t++p;\n\t\tif (*p != ']' && *p != NUL)\n\t\t    MB_PTR_ADV(p);\n\t    }\n\telse if (*p == '\\\\'\n\t\t&& !reg_cpo_bsl\n\t\t&& (vim_strchr(REGEXP_INRANGE, p[1]) != NULL\n\t\t    || (!reg_cpo_lit && vim_strchr(REGEXP_ABBR, p[1]) != NULL)))\n\t    p += 2;\n\telse if (*p == '[')\n\t{\n\t    if (get_char_class(&p) == CLASS_NONE\n\t\t    && get_equi_class(&p) == 0\n\t\t    && get_coll_element(&p) == 0\n\t\t    && *p != NUL)\n\t\t++p; // it is not a class name and not NUL\n\t}\n\telse\n\t    ++p;\n    }\n\n    return p;\n}\n\n/*\n * Skip past regular expression.\n * Stop at end of \"startp\" or where \"delim\" is found ('/', '?', etc).\n * Take care of characters with a backslash in front of it.\n * Skip strings inside [ and ].\n */\n    char_u *\nskip_regexp(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    return skip_regexp_ex(startp, delim, magic, NULL, NULL, NULL);\n}\n\n/*\n * Call skip_regexp() and when the delimiter does not match give an error and\n * return NULL.\n */\n    char_u *\nskip_regexp_err(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    char_u *p = skip_regexp(startp, delim, magic);\n\n    if (*p != delim)\n    {\n\tsemsg(_(e_missing_delimiter_after_search_pattern_str), startp);\n\treturn NULL;\n    }\n    return p;\n}\n\n/*\n * skip_regexp() with extra arguments:\n * When \"newp\" is not NULL and \"dirc\" is '?', make an allocated copy of the\n * expression and change \"\\?\" to \"?\".  If \"*newp\" is not NULL the expression\n * is changed in-place.\n * If a \"\\?\" is changed to \"?\" then \"dropped\" is incremented, unless NULL.\n * If \"magic_val\" is not NULL, returns the effective magicness of the pattern\n */\n    char_u *\nskip_regexp_ex(\n    char_u\t*startp,\n    int\t\tdirc,\n    int\t\tmagic,\n    char_u\t**newp,\n    int\t\t*dropped,\n    magic_T\t*magic_val)\n{\n    magic_T\tmymagic;\n    char_u\t*p = startp;\n\n    if (magic)\n\tmymagic = MAGIC_ON;\n    else\n\tmymagic = MAGIC_OFF;\n    get_cpo_flags();\n\n    for (; p[0] != NUL; MB_PTR_ADV(p))\n    {\n\tif (p[0] == dirc)\t// found end of regexp\n\t    break;\n\tif ((p[0] == '[' && mymagic >= MAGIC_ON)\n\t\t|| (p[0] == '\\\\' && p[1] == '[' && mymagic <= MAGIC_OFF))\n\t{\n\t    p = skip_anyof(p + 1);\n\t    if (p[0] == NUL)\n\t\tbreak;\n\t}\n\telse if (p[0] == '\\\\' && p[1] != NUL)\n\t{\n\t    if (dirc == '?' && newp != NULL && p[1] == '?')\n\t    {\n\t\t// change \"\\?\" to \"?\", make a copy first.\n\t\tif (*newp == NULL)\n\t\t{\n\t\t    *newp = vim_strsave(startp);\n\t\t    if (*newp != NULL)\n\t\t\tp = *newp + (p - startp);\n\t\t}\n\t\tif (dropped != NULL)\n\t\t    ++*dropped;\n\t\tif (*newp != NULL)\n\t\t    STRMOVE(p, p + 1);\n\t\telse\n\t\t    ++p;\n\t    }\n\t    else\n\t\t++p;    // skip next character\n\t    if (*p == 'v')\n\t\tmymagic = MAGIC_ALL;\n\t    else if (*p == 'V')\n\t\tmymagic = MAGIC_NONE;\n\t}\n    }\n    if (magic_val != NULL)\n\t*magic_val = mymagic;\n    return p;\n}\n\n/*\n * Functions for getting characters from the regexp input.\n */\nstatic int\tprevchr_len;\t// byte length of previous char\nstatic int\tat_start;\t// True when on the first character\nstatic int\tprev_at_start;  // True when on the second character\n\n/*\n * Start parsing at \"str\".\n */\n    static void\ninitchr(char_u *str)\n{\n    regparse = str;\n    prevchr_len = 0;\n    curchr = prevprevchr = prevchr = nextchr = -1;\n    at_start = TRUE;\n    prev_at_start = FALSE;\n}\n\n/*\n * Save the current parse state, so that it can be restored and parsing\n * starts in the same state again.\n */\n    static void\nsave_parse_state(parse_state_T *ps)\n{\n    ps->regparse = regparse;\n    ps->prevchr_len = prevchr_len;\n    ps->curchr = curchr;\n    ps->prevchr = prevchr;\n    ps->prevprevchr = prevprevchr;\n    ps->nextchr = nextchr;\n    ps->at_start = at_start;\n    ps->prev_at_start = prev_at_start;\n    ps->regnpar = regnpar;\n}\n\n/*\n * Restore a previously saved parse state.\n */\n    static void\nrestore_parse_state(parse_state_T *ps)\n{\n    regparse = ps->regparse;\n    prevchr_len = ps->prevchr_len;\n    curchr = ps->curchr;\n    prevchr = ps->prevchr;\n    prevprevchr = ps->prevprevchr;\n    nextchr = ps->nextchr;\n    at_start = ps->at_start;\n    prev_at_start = ps->prev_at_start;\n    regnpar = ps->regnpar;\n}\n\n\n/*\n * Get the next character without advancing.\n */\n    static int\npeekchr(void)\n{\n    static int\tafter_slash = FALSE;\n\n    if (curchr == -1)\n    {\n\tswitch (curchr = regparse[0])\n\t{\n\tcase '.':\n\tcase '[':\n\tcase '~':\n\t    // magic when 'magic' is on\n\t    if (reg_magic >= MAGIC_ON)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '(':\n\tcase ')':\n\tcase '{':\n\tcase '%':\n\tcase '+':\n\tcase '=':\n\tcase '?':\n\tcase '@':\n\tcase '!':\n\tcase '&':\n\tcase '|':\n\tcase '<':\n\tcase '>':\n\tcase '#':\t// future ext.\n\tcase '\"':\t// future ext.\n\tcase '\\'':\t// future ext.\n\tcase ',':\t// future ext.\n\tcase '-':\t// future ext.\n\tcase ':':\t// future ext.\n\tcase ';':\t// future ext.\n\tcase '`':\t// future ext.\n\tcase '/':\t// Can't be used in / command\n\t    // magic only after \"\\v\"\n\t    if (reg_magic == MAGIC_ALL)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '*':\n\t    // * is not magic as the very first character, eg \"?*ptr\", when\n\t    // after '^', eg \"/^*ptr\" and when after \"\\(\", \"\\|\", \"\\&\".  But\n\t    // \"\\(\\*\" is not magic, thus must be magic if \"after_slash\"\n\t    if (reg_magic >= MAGIC_ON\n\t\t    && !at_start\n\t\t    && !(prev_at_start && prevchr == Magic('^'))\n\t\t    && (after_slash\n\t\t\t|| (prevchr != Magic('(')\n\t\t\t    && prevchr != Magic('&')\n\t\t\t    && prevchr != Magic('|'))))\n\t\tcurchr = Magic('*');\n\t    break;\n\tcase '^':\n\t    // '^' is only magic as the very first character and if it's after\n\t    // \"\\(\", \"\\|\", \"\\&' or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF\n\t\t    && (at_start\n\t\t\t|| reg_magic == MAGIC_ALL\n\t\t\t|| prevchr == Magic('(')\n\t\t\t|| prevchr == Magic('|')\n\t\t\t|| prevchr == Magic('&')\n\t\t\t|| prevchr == Magic('n')\n\t\t\t|| (no_Magic(prevchr) == '('\n\t\t\t    && prevprevchr == Magic('%'))))\n\t    {\n\t\tcurchr = Magic('^');\n\t\tat_start = TRUE;\n\t\tprev_at_start = FALSE;\n\t    }\n\t    break;\n\tcase '$':\n\t    // '$' is only magic as the very last char and if it's in front of\n\t    // either \"\\|\", \"\\)\", \"\\&\", or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF)\n\t    {\n\t\tchar_u *p = regparse + 1;\n\t\tint is_magic_all = (reg_magic == MAGIC_ALL);\n\n\t\t// ignore \\c \\C \\m \\M \\v \\V and \\Z after '$'\n\t\twhile (p[0] == '\\\\' && (p[1] == 'c' || p[1] == 'C'\n\t\t\t\t|| p[1] == 'm' || p[1] == 'M'\n\t\t\t\t|| p[1] == 'v' || p[1] == 'V' || p[1] == 'Z'))\n\t\t{\n\t\t    if (p[1] == 'v')\n\t\t\tis_magic_all = TRUE;\n\t\t    else if (p[1] == 'm' || p[1] == 'M' || p[1] == 'V')\n\t\t\tis_magic_all = FALSE;\n\t\t    p += 2;\n\t\t}\n\t\tif (p[0] == NUL\n\t\t\t|| (p[0] == '\\\\'\n\t\t\t    && (p[1] == '|' || p[1] == '&' || p[1] == ')'\n\t\t\t\t|| p[1] == 'n'))\n\t\t\t|| (is_magic_all\n\t\t\t       && (p[0] == '|' || p[0] == '&' || p[0] == ')'))\n\t\t\t|| reg_magic == MAGIC_ALL)\n\t\t    curchr = Magic('$');\n\t    }\n\t    break;\n\tcase '\\\\':\n\t    {\n\t\tint c = regparse[1];\n\n\t\tif (c == NUL)\n\t\t    curchr = '\\\\';\t// trailing '\\'\n\t\telse if (c <= '~' && META_flags[c])\n\t\t{\n\t\t    /*\n\t\t     * META contains everything that may be magic sometimes,\n\t\t     * except ^ and $ (\"\\^\" and \"\\$\" are only magic after\n\t\t     * \"\\V\").  We now fetch the next character and toggle its\n\t\t     * magicness.  Therefore, \\ is so meta-magic that it is\n\t\t     * not in META.\n\t\t     */\n\t\t    curchr = -1;\n\t\t    prev_at_start = at_start;\n\t\t    at_start = FALSE;\t// be able to say \"/\\*ptr\"\n\t\t    ++regparse;\n\t\t    ++after_slash;\n\t\t    peekchr();\n\t\t    --regparse;\n\t\t    --after_slash;\n\t\t    curchr = toggle_Magic(curchr);\n\t\t}\n\t\telse if (vim_strchr(REGEXP_ABBR, c))\n\t\t{\n\t\t    /*\n\t\t     * Handle abbreviations, like \"\\t\" for TAB -- webb\n\t\t     */\n\t\t    curchr = backslash_trans(c);\n\t\t}\n\t\telse if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))\n\t\t    curchr = toggle_Magic(c);\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Next character can never be (made) magic?\n\t\t     * Then backslashing it won't do anything.\n\t\t     */\n\t\t    if (has_mbyte)\n\t\t\tcurchr = (*mb_ptr2char)(regparse + 1);\n\t\t    else\n\t\t\tcurchr = c;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tdefault:\n\t    if (has_mbyte)\n\t\tcurchr = (*mb_ptr2char)(regparse);\n\t}\n    }\n\n    return curchr;\n}\n\n/*\n * Eat one lexed character.  Do this in a way that we can undo it.\n */\n    static void\nskipchr(void)\n{\n    // peekchr() eats a backslash, do the same here\n    if (*regparse == '\\\\')\n\tprevchr_len = 1;\n    else\n\tprevchr_len = 0;\n    if (regparse[prevchr_len] != NUL)\n    {\n\tif (enc_utf8)\n\t    // exclude composing chars that mb_ptr2len does include\n\t    prevchr_len += utf_ptr2len(regparse + prevchr_len);\n\telse if (has_mbyte)\n\t    prevchr_len += (*mb_ptr2len)(regparse + prevchr_len);\n\telse\n\t    ++prevchr_len;\n    }\n    regparse += prevchr_len;\n    prev_at_start = at_start;\n    at_start = FALSE;\n    prevprevchr = prevchr;\n    prevchr = curchr;\n    curchr = nextchr;\t    // use previously unget char, or -1\n    nextchr = -1;\n}\n\n/*\n * Skip a character while keeping the value of prev_at_start for at_start.\n * prevchr and prevprevchr are also kept.\n */\n    static void\nskipchr_keepstart(void)\n{\n    int as = prev_at_start;\n    int pr = prevchr;\n    int prpr = prevprevchr;\n\n    skipchr();\n    at_start = as;\n    prevchr = pr;\n    prevprevchr = prpr;\n}\n\n/*\n * Get the next character from the pattern. We know about magic and such, so\n * therefore we need a lexical analyzer.\n */\n    static int\ngetchr(void)\n{\n    int chr = peekchr();\n\n    skipchr();\n    return chr;\n}\n\n/*\n * put character back.  Works only once!\n */\n    static void\nungetchr(void)\n{\n    nextchr = curchr;\n    curchr = prevchr;\n    prevchr = prevprevchr;\n    at_start = prev_at_start;\n    prev_at_start = FALSE;\n\n    // Backup regparse, so that it's at the same position as before the\n    // getchr().\n    regparse -= prevchr_len;\n}\n\n/*\n * Get and return the value of the hex string at the current position.\n * Return -1 if there is no valid hex number.\n * The position is updated:\n *     blahblah\\%x20asdf\n *\t   before-^ ^-after\n * The parameter controls the maximum number of input characters. This will be\n * 2 when reading a \\%x20 sequence and 4 when reading a \\%u20AC sequence.\n */\n    static long\ngethexchrs(int maxinputlen)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < maxinputlen; ++i)\n    {\n\tc = regparse[0];\n\tif (!vim_isxdigit(c))\n\t    break;\n\tnr <<= 4;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * Get and return the value of the decimal string immediately after the\n * current position. Return -1 for invalid.  Consumes all digits.\n */\n    static long\ngetdecchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; ; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '9')\n\t    break;\n\tnr *= 10;\n\tnr += c - '0';\n\t++regparse;\n\tcurchr = -1; // no longer valid\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * get and return the value of the octal string immediately after the current\n * position. Return -1 for invalid, or 0-255 for valid. Smart enough to handle\n * numbers > 377 correctly (for example, 400 is treated as 40) and doesn't\n * treat 8 or 9 as recognised characters. Position is updated:\n *     blahblah\\%o210asdf\n *\t   before-^  ^-after\n */\n    static long\ngetoctchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < 3 && nr < 040; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '7')\n\t    break;\n\tnr <<= 3;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * read_limits - Read two integers to be taken as a minimum and maximum.\n * If the first character is '-', then the range is reversed.\n * Should end with 'end'.  If minval is missing, zero is default, if maxval is\n * missing, a very big number is the default.\n */\n    static int\nread_limits(long *minval, long *maxval)\n{\n    int\t\treverse = FALSE;\n    char_u\t*first_char;\n    long\ttmp;\n\n    if (*regparse == '-')\n    {\n\t// Starts with '-', so reverse the range later\n\tregparse++;\n\treverse = TRUE;\n    }\n    first_char = regparse;\n    *minval = getdigits(&regparse);\n    if (*regparse == ',')\t    // There is a comma\n    {\n\tif (vim_isdigit(*++regparse))\n\t    *maxval = getdigits(&regparse);\n\telse\n\t    *maxval = MAX_LIMIT;\n    }\n    else if (VIM_ISDIGIT(*first_char))\n\t*maxval = *minval;\t    // It was \\{n} or \\{-n}\n    else\n\t*maxval = MAX_LIMIT;\t    // It was \\{} or \\{-}\n    if (*regparse == '\\\\')\n\tregparse++;\t// Allow either \\{...} or \\{...\\}\n    if (*regparse != '}')\n\tEMSG2_RET_FAIL(_(e_syntax_error_in_str_curlies),\n\t\t\t\t\t\t       reg_magic == MAGIC_ALL);\n\n    /*\n     * Reverse the range if there was a '-', or make sure it is in the right\n     * order otherwise.\n     */\n    if ((!reverse && *minval > *maxval) || (reverse && *minval < *maxval))\n    {\n\ttmp = *minval;\n\t*minval = *maxval;\n\t*maxval = tmp;\n    }\n    skipchr();\t\t// let's be friends with the lexer again\n    return OK;\n}\n\n/*\n * vim_regexec and friends\n */\n\n/*\n * Global work variables for vim_regexec().\n */\n\nstatic void\tcleanup_subexpr(void);\n#ifdef FEAT_SYN_HL\nstatic void\tcleanup_zsubexpr(void);\n#endif\nstatic void\treg_nextline(void);\nstatic int\tmatch_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen);\n\n/*\n * Sometimes need to save a copy of a line.  Since alloc()/free() is very\n * slow, we keep one allocated piece of memory and only re-allocate it when\n * it's too small.  It's freed in bt_regexec_both() when finished.\n */\nstatic char_u\t*reg_tofree = NULL;\nstatic unsigned\treg_tofreelen;\n\n/*\n * Structure used to store the execution state of the regex engine.\n * Which ones are set depends on whether a single-line or multi-line match is\n * done:\n *\t\t\tsingle-line\t\tmulti-line\n * reg_match\t\t&regmatch_T\t\tNULL\n * reg_mmatch\t\tNULL\t\t\t&regmmatch_T\n * reg_startp\t\treg_match->startp\t<invalid>\n * reg_endp\t\treg_match->endp\t\t<invalid>\n * reg_startpos\t\t<invalid>\t\treg_mmatch->startpos\n * reg_endpos\t\t<invalid>\t\treg_mmatch->endpos\n * reg_win\t\tNULL\t\t\twindow in which to search\n * reg_buf\t\tcurbuf\t\t\tbuffer in which to search\n * reg_firstlnum\t<invalid>\t\tfirst line in which to search\n * reg_maxline\t\t0\t\t\tlast line nr\n * reg_line_lbr\t\tFALSE or TRUE\t\tFALSE\n */\ntypedef struct {\n    regmatch_T\t\t*reg_match;\n    regmmatch_T\t\t*reg_mmatch;\n    char_u\t\t**reg_startp;\n    char_u\t\t**reg_endp;\n    lpos_T\t\t*reg_startpos;\n    lpos_T\t\t*reg_endpos;\n    win_T\t\t*reg_win;\n    buf_T\t\t*reg_buf;\n    linenr_T\t\treg_firstlnum;\n    linenr_T\t\treg_maxline;\n    int\t\t\treg_line_lbr;\t// \"\\n\" in string is line break\n\n    // The current match-position is stord in these variables:\n    linenr_T\tlnum;\t\t// line number, relative to first line\n    char_u\t*line;\t\t// start of current line\n    char_u\t*input;\t\t// current input, points into \"line\"\n\n    int\tneed_clear_subexpr;\t// subexpressions still need to be cleared\n#ifdef FEAT_SYN_HL\n    int\tneed_clear_zsubexpr;\t// extmatch subexpressions still need to be\n\t\t\t\t// cleared\n#endif\n\n    // Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().\n    // Normally it gets the value of \"rm_ic\" or \"rmm_ic\", but when the pattern\n    // contains '\\c' or '\\C' the value is overruled.\n    int\t\t\treg_ic;\n\n    // Similar to \"reg_ic\", but only for 'combining' characters.  Set with \\Z\n    // flag in the regexp.  Defaults to false, always.\n    int\t\t\treg_icombine;\n\n    // Copy of \"rmm_maxcol\": maximum column to search for a match.  Zero when\n    // there is no maximum.\n    colnr_T\t\treg_maxcol;\n\n    // State for the NFA engine regexec.\n    int nfa_has_zend;\t    // NFA regexp \\ze operator encountered.\n    int nfa_has_backref;    // NFA regexp \\1 .. \\9 encountered.\n    int nfa_nsubexpr;\t    // Number of sub expressions actually being used\n\t\t\t    // during execution. 1 if only the whole match\n\t\t\t    // (subexpr 0) is used.\n    // listid is global, so that it increases on recursive calls to\n    // nfa_regmatch(), which means we don't have to clear the lastlist field of\n    // all the states.\n    int nfa_listid;\n    int nfa_alt_listid;\n\n#ifdef FEAT_SYN_HL\n    int nfa_has_zsubexpr;   // NFA regexp has \\z( ), set zsubexpr.\n#endif\n} regexec_T;\n\nstatic regexec_T\trex;\nstatic int\t\trex_in_use = FALSE;\n\n/*\n * Return TRUE if character 'c' is included in 'iskeyword' option for\n * \"reg_buf\" buffer.\n */\n    static int\nreg_iswordc(int c)\n{\n    return vim_iswordc_buf(c, rex.reg_buf);\n}\n\n/*\n * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\".\n */\n    static char_u *\nreg_getline(linenr_T lnum)\n{\n    // when looking behind for a match/no-match lnum is negative.  But we\n    // can't go before line 1\n    if (rex.reg_firstlnum + lnum < 1)\n\treturn NULL;\n    if (lnum > rex.reg_maxline)\n\t// Must have matched the \"\\n\" in the last line.\n\treturn (char_u *)\"\";\n    return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, FALSE);\n}\n\n#ifdef FEAT_SYN_HL\nstatic char_u\t*reg_startzp[NSUBEXP];\t// Workspace to mark beginning\nstatic char_u\t*reg_endzp[NSUBEXP];\t//   and end of \\z(...\\) matches\nstatic lpos_T\treg_startzpos[NSUBEXP];\t// idem, beginning pos\nstatic lpos_T\treg_endzpos[NSUBEXP];\t// idem, end pos\n#endif\n\n// TRUE if using multi-line regexp.\n#define REG_MULTI\t(rex.reg_match == NULL)\n\n#ifdef FEAT_SYN_HL\n/*\n * Create a new extmatch and mark it as referenced once.\n */\n    static reg_extmatch_T *\nmake_extmatch(void)\n{\n    reg_extmatch_T\t*em;\n\n    em = ALLOC_CLEAR_ONE(reg_extmatch_T);\n    if (em != NULL)\n\tem->refcnt = 1;\n    return em;\n}\n\n/*\n * Add a reference to an extmatch.\n */\n    reg_extmatch_T *\nref_extmatch(reg_extmatch_T *em)\n{\n    if (em != NULL)\n\tem->refcnt++;\n    return em;\n}\n\n/*\n * Remove a reference to an extmatch.  If there are no references left, free\n * the info.\n */\n    void\nunref_extmatch(reg_extmatch_T *em)\n{\n    int i;\n\n    if (em != NULL && --em->refcnt <= 0)\n    {\n\tfor (i = 0; i < NSUBEXP; ++i)\n\t    vim_free(em->matches[i]);\n\tvim_free(em);\n    }\n}\n#endif\n\n/*\n * Get class of previous character.\n */\n    static int\nreg_prev_class(void)\n{\n    if (rex.input > rex.line)\n\treturn mb_get_class_buf(rex.input - 1\n\t\t       - (*mb_head_off)(rex.line, rex.input - 1), rex.reg_buf);\n    return -1;\n}\n\n/*\n * Return TRUE if the current rex.input position matches the Visual area.\n */\n    static int\nreg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n\n    // Check if the buffer is the current buffer and not using a string.\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0 || !REG_MULTI)\n\treturn FALSE;\n\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    col = (colnr_T)(rex.input - rex.line);\n    if (mode == 'v')\n    {\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\n\t// getvvcol() flushes rex.line, need to get it again\n\trex.line = reg_getline(rex.lnum);\n\trex.input = rex.line + col;\n\n\tcols = win_linetabsize(wp, rex.line, col);\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Check the regexp program for its magic number.\n * Return TRUE if it's wrong.\n */\n    static int\nprog_magic_wrong(void)\n{\n    regprog_T\t*prog;\n\n    prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;\n    if (prog->engine == &nfa_regengine)\n\t// For NFA matcher we don't check the magic\n\treturn FALSE;\n\n    if (UCHARAT(((bt_regprog_T *)prog)->program) != REGMAGIC)\n    {\n\temsg(_(e_corrupted_regexp_program));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Cleanup the subexpressions, if this wasn't done yet.\n * This construction is used to clear the subexpressions only when they are\n * used (to increase speed).\n */\n    static void\ncleanup_subexpr(void)\n{\n    if (rex.need_clear_subexpr)\n    {\n\tif (REG_MULTI)\n\t{\n\t    // Use 0xff to set lnum to -1\n\t    vim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t    vim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t}\n\telse\n\t{\n\t    vim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);\n\t    vim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);\n\t}\n\trex.need_clear_subexpr = FALSE;\n    }\n}\n\n#ifdef FEAT_SYN_HL\n    static void\ncleanup_zsubexpr(void)\n{\n    if (rex.need_clear_zsubexpr)\n    {\n\tif (REG_MULTI)\n\t{\n\t    // Use 0xff to set lnum to -1\n\t    vim_memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t    vim_memset(reg_endzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t}\n\telse\n\t{\n\t    vim_memset(reg_startzp, 0, sizeof(char_u *) * NSUBEXP);\n\t    vim_memset(reg_endzp, 0, sizeof(char_u *) * NSUBEXP);\n\t}\n\trex.need_clear_zsubexpr = FALSE;\n    }\n}\n#endif\n\n/*\n * Advance rex.lnum, rex.line and rex.input to the next line.\n */\n    static void\nreg_nextline(void)\n{\n    rex.line = reg_getline(++rex.lnum);\n    rex.input = rex.line;\n    fast_breakcheck();\n}\n\n/*\n * Check whether a backreference matches.\n * Returns RA_FAIL, RA_NOMATCH or RA_MATCH.\n * If \"bytelen\" is not NULL, it is set to the byte length of the match in the\n * last line.\n */\n    static int\nmatch_with_backref(\n    linenr_T start_lnum,\n    colnr_T  start_col,\n    linenr_T end_lnum,\n    colnr_T  end_col,\n    int\t     *bytelen)\n{\n    linenr_T\tclnum = start_lnum;\n    colnr_T\tccol = start_col;\n    int\t\tlen;\n    char_u\t*p;\n\n    if (bytelen != NULL)\n\t*bytelen = 0;\n    for (;;)\n    {\n\t// Since getting one line may invalidate the other, need to make copy.\n\t// Slow!\n\tif (rex.line != reg_tofree)\n\t{\n\t    len = (int)STRLEN(rex.line);\n\t    if (reg_tofree == NULL || len >= (int)reg_tofreelen)\n\t    {\n\t\tlen += 50;\t// get some extra\n\t\tvim_free(reg_tofree);\n\t\treg_tofree = alloc(len);\n\t\tif (reg_tofree == NULL)\n\t\t    return RA_FAIL; // out of memory!\n\t\treg_tofreelen = len;\n\t    }\n\t    STRCPY(reg_tofree, rex.line);\n\t    rex.input = reg_tofree + (rex.input - rex.line);\n\t    rex.line = reg_tofree;\n\t}\n\n\t// Get the line to compare with.\n\tp = reg_getline(clnum);\n\tif (clnum == end_lnum)\n\t    len = end_col - ccol;\n\telse\n\t    len = (int)STRLEN(p + ccol);\n\n\tif (cstrncmp(p + ccol, rex.input, &len) != 0)\n\t    return RA_NOMATCH;  // doesn't match\n\tif (bytelen != NULL)\n\t    *bytelen += len;\n\tif (clnum == end_lnum)\n\t    break;\t\t// match and at end!\n\tif (rex.lnum >= rex.reg_maxline)\n\t    return RA_NOMATCH;  // text too short\n\n\t// Advance to next line.\n\treg_nextline();\n\tif (bytelen != NULL)\n\t    *bytelen = 0;\n\t++clnum;\n\tccol = 0;\n\tif (got_int)\n\t    return RA_FAIL;\n    }\n\n    // found a match!  Note that rex.line may now point to a copy of the line,\n    // that should not matter.\n    return RA_MATCH;\n}\n\n/*\n * Used in a place where no * or \\+ can follow.\n */\n    static int\nre_mult_next(char *what)\n{\n    if (re_multi_type(peekchr()) == MULTI_MULT)\n    {\n       semsg(_(e_nfa_regexp_cannot_repeat_str), what);\n       rc_did_emsg = TRUE;\n       return FAIL;\n    }\n    return OK;\n}\n\ntypedef struct\n{\n    int a, b, c;\n} decomp_T;\n\n\n// 0xfb20 - 0xfb4f\nstatic decomp_T decomp_table[0xfb4f-0xfb20+1] =\n{\n    {0x5e2,0,0},\t\t// 0xfb20\talt ayin\n    {0x5d0,0,0},\t\t// 0xfb21\talt alef\n    {0x5d3,0,0},\t\t// 0xfb22\talt dalet\n    {0x5d4,0,0},\t\t// 0xfb23\talt he\n    {0x5db,0,0},\t\t// 0xfb24\talt kaf\n    {0x5dc,0,0},\t\t// 0xfb25\talt lamed\n    {0x5dd,0,0},\t\t// 0xfb26\talt mem-sofit\n    {0x5e8,0,0},\t\t// 0xfb27\talt resh\n    {0x5ea,0,0},\t\t// 0xfb28\talt tav\n    {'+', 0, 0},\t\t// 0xfb29\talt plus\n    {0x5e9, 0x5c1, 0},\t\t// 0xfb2a\tshin+shin-dot\n    {0x5e9, 0x5c2, 0},\t\t// 0xfb2b\tshin+sin-dot\n    {0x5e9, 0x5c1, 0x5bc},\t// 0xfb2c\tshin+shin-dot+dagesh\n    {0x5e9, 0x5c2, 0x5bc},\t// 0xfb2d\tshin+sin-dot+dagesh\n    {0x5d0, 0x5b7, 0},\t\t// 0xfb2e\talef+patah\n    {0x5d0, 0x5b8, 0},\t\t// 0xfb2f\talef+qamats\n    {0x5d0, 0x5b4, 0},\t\t// 0xfb30\talef+hiriq\n    {0x5d1, 0x5bc, 0},\t\t// 0xfb31\tbet+dagesh\n    {0x5d2, 0x5bc, 0},\t\t// 0xfb32\tgimel+dagesh\n    {0x5d3, 0x5bc, 0},\t\t// 0xfb33\tdalet+dagesh\n    {0x5d4, 0x5bc, 0},\t\t// 0xfb34\the+dagesh\n    {0x5d5, 0x5bc, 0},\t\t// 0xfb35\tvav+dagesh\n    {0x5d6, 0x5bc, 0},\t\t// 0xfb36\tzayin+dagesh\n    {0xfb37, 0, 0},\t\t// 0xfb37 -- UNUSED\n    {0x5d8, 0x5bc, 0},\t\t// 0xfb38\ttet+dagesh\n    {0x5d9, 0x5bc, 0},\t\t// 0xfb39\tyud+dagesh\n    {0x5da, 0x5bc, 0},\t\t// 0xfb3a\tkaf sofit+dagesh\n    {0x5db, 0x5bc, 0},\t\t// 0xfb3b\tkaf+dagesh\n    {0x5dc, 0x5bc, 0},\t\t// 0xfb3c\tlamed+dagesh\n    {0xfb3d, 0, 0},\t\t// 0xfb3d -- UNUSED\n    {0x5de, 0x5bc, 0},\t\t// 0xfb3e\tmem+dagesh\n    {0xfb3f, 0, 0},\t\t// 0xfb3f -- UNUSED\n    {0x5e0, 0x5bc, 0},\t\t// 0xfb40\tnun+dagesh\n    {0x5e1, 0x5bc, 0},\t\t// 0xfb41\tsamech+dagesh\n    {0xfb42, 0, 0},\t\t// 0xfb42 -- UNUSED\n    {0x5e3, 0x5bc, 0},\t\t// 0xfb43\tpe sofit+dagesh\n    {0x5e4, 0x5bc,0},\t\t// 0xfb44\tpe+dagesh\n    {0xfb45, 0, 0},\t\t// 0xfb45 -- UNUSED\n    {0x5e6, 0x5bc, 0},\t\t// 0xfb46\ttsadi+dagesh\n    {0x5e7, 0x5bc, 0},\t\t// 0xfb47\tqof+dagesh\n    {0x5e8, 0x5bc, 0},\t\t// 0xfb48\tresh+dagesh\n    {0x5e9, 0x5bc, 0},\t\t// 0xfb49\tshin+dagesh\n    {0x5ea, 0x5bc, 0},\t\t// 0xfb4a\ttav+dagesh\n    {0x5d5, 0x5b9, 0},\t\t// 0xfb4b\tvav+holam\n    {0x5d1, 0x5bf, 0},\t\t// 0xfb4c\tbet+rafe\n    {0x5db, 0x5bf, 0},\t\t// 0xfb4d\tkaf+rafe\n    {0x5e4, 0x5bf, 0},\t\t// 0xfb4e\tpe+rafe\n    {0x5d0, 0x5dc, 0}\t\t// 0xfb4f\talef-lamed\n};\n\n    static void\nmb_decompose(int c, int *c1, int *c2, int *c3)\n{\n    decomp_T d;\n\n    if (c >= 0xfb20 && c <= 0xfb4f)\n    {\n\td = decomp_table[c - 0xfb20];\n\t*c1 = d.a;\n\t*c2 = d.b;\n\t*c3 = d.c;\n    }\n    else\n    {\n\t*c1 = c;\n\t*c2 = *c3 = 0;\n    }\n}\n\n/*\n * Compare two strings, ignore case if rex.reg_ic set.\n * Return 0 if strings match, non-zero otherwise.\n * Correct the length \"*n\" when composing characters are ignored.\n */\n    static int\ncstrncmp(char_u *s1, char_u *s2, int *n)\n{\n    int\t\tresult;\n\n    if (!rex.reg_ic)\n\tresult = STRNCMP(s1, s2, *n);\n    else\n\tresult = MB_STRNICMP(s1, s2, *n);\n\n    // if it failed and it's utf8 and we want to combineignore:\n    if (result != 0 && enc_utf8 && rex.reg_icombine)\n    {\n\tchar_u\t*str1, *str2;\n\tint\tc1, c2, c11, c12;\n\tint\tjunk;\n\n\t// we have to handle the strcmp ourselves, since it is necessary to\n\t// deal with the composing characters by ignoring them:\n\tstr1 = s1;\n\tstr2 = s2;\n\tc1 = c2 = 0;\n\twhile ((int)(str1 - s1) < *n)\n\t{\n\t    c1 = mb_ptr2char_adv(&str1);\n\t    c2 = mb_ptr2char_adv(&str2);\n\n\t    // Decompose the character if necessary, into 'base' characters.\n\t    // Currently hard-coded for Hebrew, Arabic to be done...\n\t    if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))\n\t    {\n\t\t// decomposition necessary?\n\t\tmb_decompose(c1, &c11, &junk, &junk);\n\t\tmb_decompose(c2, &c12, &junk, &junk);\n\t\tc1 = c11;\n\t\tc2 = c12;\n\t\tif (c11 != c12\n\t\t\t    && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12)))\n\t\t    break;\n\t    }\n\t}\n\tresult = c2 - c1;\n\tif (result == 0)\n\t    *n = (int)(str2 - s2);\n    }\n\n    return result;\n}\n\n/*\n * cstrchr: This function is used a lot for simple searches, keep it fast!\n */\n    static char_u *\ncstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    // tolower() and toupper() can be slow, comparing twice should be a lot\n    // faster (esp. when using MS Visual C++!).\n    // For UTF-8 need to use folded case.\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tif (utf_fold(utf_ptr2char(p)) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\t// Faster version for when there are no multi-byte characters.\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}\n\n////////////////////////////////////////////////////////////////\n//\t\t      regsub stuff\t\t\t      //\n////////////////////////////////////////////////////////////////\n\n/*\n * We should define ftpr as a pointer to a function returning a pointer to\n * a function returning a pointer to a function ...\n * This is impossible, so we declare a pointer to a function returning a\n * void pointer. This should work for all compilers.\n */\ntypedef void (*(*fptr_T)(int *, int));\n\nstatic int vim_regsub_both(char_u *source, typval_T *expr, char_u *dest, int destlen, int flags);\n\n    static fptr_T\ndo_upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)do_Upper;\n}\n\n    static fptr_T\ndo_lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)do_Lower;\n}\n\n/*\n * regtilde(): Replace tildes in the pattern by the old pattern.\n *\n * Short explanation of the tilde: It stands for the previous replacement\n * pattern.  If that previous pattern also contains a ~ we should go back a\n * step further...  But we insert the previous pattern into the current one\n * and remember that.\n * This still does not handle the case where \"magic\" changes.  So require the\n * user to keep his hands off of \"magic\".\n *\n * The tildes are parsed once before the first call to vim_regsub().\n */\n    char_u *\nregtilde(char_u *source, int magic)\n{\n    char_u\t*newsub = source;\n    char_u\t*tmpsub;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tprevlen;\n\n    for (p = newsub; *p; ++p)\n    {\n\tif ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic))\n\t{\n\t    if (reg_prev_sub != NULL)\n\t    {\n\t\t// length = len(newsub) - 1 + len(prev_sub) + 1\n\t\tprevlen = (int)STRLEN(reg_prev_sub);\n\t\ttmpsub = alloc(STRLEN(newsub) + prevlen);\n\t\tif (tmpsub != NULL)\n\t\t{\n\t\t    // copy prefix\n\t\t    len = (int)(p - newsub);\t// not including ~\n\t\t    mch_memmove(tmpsub, newsub, (size_t)len);\n\t\t    // interpret tilde\n\t\t    mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);\n\t\t    // copy postfix\n\t\t    if (!magic)\n\t\t\t++p;\t\t\t// back off backslash\n\t\t    STRCPY(tmpsub + len + prevlen, p + 1);\n\n\t\t    if (newsub != source)\t// already allocated newsub\n\t\t\tvim_free(newsub);\n\t\t    newsub = tmpsub;\n\t\t    p = newsub + len + prevlen;\n\t\t}\n\t    }\n\t    else if (magic)\n\t\tSTRMOVE(p, p + 1);\t// remove '~'\n\t    else\n\t\tSTRMOVE(p, p + 2);\t// remove '\\~'\n\t    --p;\n\t}\n\telse\n\t{\n\t    if (*p == '\\\\' && p[1])\t\t// skip escaped characters\n\t\t++p;\n\t    if (has_mbyte)\n\t\tp += (*mb_ptr2len)(p) - 1;\n\t}\n    }\n\n    vim_free(reg_prev_sub);\n    if (newsub != source)\t// newsub was allocated, just keep it\n\treg_prev_sub = newsub;\n    else\t\t\t// no ~ found, need to save newsub\n\treg_prev_sub = vim_strsave(newsub);\n    return newsub;\n}\n\n#ifdef FEAT_EVAL\nstatic int can_f_submatch = FALSE;\t// TRUE when submatch() can be used\n\n// These pointers are used for reg_submatch().  Needed for when the\n// substitution string is an expression that contains a call to substitute()\n// and submatch().\ntypedef struct {\n    regmatch_T\t*sm_match;\n    regmmatch_T\t*sm_mmatch;\n    linenr_T\tsm_firstlnum;\n    linenr_T\tsm_maxline;\n    int\t\tsm_line_lbr;\n} regsubmatch_T;\n\nstatic regsubmatch_T rsm;  // can only be used when can_f_submatch is TRUE\n#endif\n\n#ifdef FEAT_EVAL\n\n/*\n * Put the submatches in \"argv[argskip]\" which is a list passed into\n * call_func() by vim_regsub_both().\n */\n    static int\nfill_submatch_list(int argc UNUSED, typval_T *argv, int argskip, int argcount)\n{\n    listitem_T\t*li;\n    int\t\ti;\n    char_u\t*s;\n    typval_T\t*listarg = argv + argskip;\n\n    if (argcount == argskip)\n\t// called function doesn't take a submatches argument\n\treturn argskip;\n\n    // Relies on sl_list to be the first item in staticList10_T.\n    init_static_list((staticList10_T *)(listarg->vval.v_list));\n\n    // There are always 10 list items in staticList10_T.\n    li = listarg->vval.v_list->lv_first;\n    for (i = 0; i < 10; ++i)\n    {\n\ts = rsm.sm_match->startp[i];\n\tif (s == NULL || rsm.sm_match->endp[i] == NULL)\n\t    s = NULL;\n\telse\n\t    s = vim_strnsave(s, rsm.sm_match->endp[i] - s);\n\tli->li_tv.v_type = VAR_STRING;\n\tli->li_tv.vval.v_string = s;\n\tli = li->li_next;\n    }\n    return argskip + 1;\n}\n\n    static void\nclear_submatch_list(staticList10_T *sl)\n{\n    int i;\n\n    for (i = 0; i < 10; ++i)\n\tvim_free(sl->sl_items[i].li_tv.vval.v_string);\n}\n#endif\n\n/*\n * vim_regsub() - perform substitutions after a vim_regexec() or\n * vim_regexec_multi() match.\n *\n * If \"flags\" has REGSUB_COPY really copy into \"dest[destlen]\".\n * Oterwise nothing is copied, only compue the length of the result.\n *\n * If \"flags\" has REGSUB_MAGIC then behave like 'magic' is set.\n *\n * If \"flags\" has REGSUB_BACKSLASH a backslash will be removed later, need to\n * double them to keep them, and insert a backslash before a CR to avoid it\n * being replaced with a line break later.\n *\n * Note: The matched text must not change between the call of\n * vim_regexec()/vim_regexec_multi() and vim_regsub()!  It would make the back\n * references invalid!\n *\n * Returns the size of the replacement, including terminating NUL.\n */\n    int\nvim_regsub(\n    regmatch_T\t*rmp,\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = rmp;\n    rex.reg_mmatch = NULL;\n    rex.reg_maxline = 0;\n    rex.reg_buf = curbuf;\n    rex.reg_line_lbr = TRUE;\n    result = vim_regsub_both(source, expr, dest, destlen, flags);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n    int\nvim_regsub_multi(\n    regmmatch_T\t*rmp,\n    linenr_T\tlnum,\n    char_u\t*source,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = curbuf;\t// always works on the current buffer!\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    result = vim_regsub_both(source, NULL, dest, destlen, flags);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n// When nesting more than a couple levels it's probably a mistake.\n# define MAX_REGSUB_NESTING 4\nstatic char_u   *eval_result[MAX_REGSUB_NESTING] = {NULL, NULL, NULL, NULL};\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_resub_eval_result(void)\n{\n    int i;\n\n    for (i = 0; i < MAX_REGSUB_NESTING; ++i)\n\tVIM_CLEAR(eval_result[i]);\n}\n# endif\n#endif\n\n    static int\nvim_regsub_both(\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*s;\n    int\t\tc;\n    int\t\tcc;\n    int\t\tno = -1;\n    fptr_T\tfunc_all = (fptr_T)NULL;\n    fptr_T\tfunc_one = (fptr_T)NULL;\n    linenr_T\tclnum = 0;\t// init for GCC\n    int\t\tlen = 0;\t// init for GCC\n#ifdef FEAT_EVAL\n    static int  nesting = 0;\n    int\t\tnested;\n#endif\n    int\t\tcopy = flags & REGSUB_COPY;\n\n    // Be paranoid...\n    if ((source == NULL && expr == NULL) || dest == NULL)\n    {\n\temsg(_(e_null_argument));\n\treturn 0;\n    }\n    if (prog_magic_wrong())\n\treturn 0;\n#ifdef FEAT_EVAL\n    if (nesting == MAX_REGSUB_NESTING)\n    {\n\temsg(_(e_substitute_nesting_too_deep));\n\treturn 0;\n    }\n    nested = nesting;\n#endif\n    src = source;\n    dst = dest;\n\n    /*\n     * When the substitute part starts with \"\\=\" evaluate it as an expression.\n     */\n    if (expr != NULL || (source[0] == '\\\\' && source[1] == '='))\n    {\n#ifdef FEAT_EVAL\n\t// To make sure that the length doesn't change between checking the\n\t// length and copying the string, and to speed up things, the\n\t// resulting string is saved from the call with\n\t// \"flags & REGSUB_COPY\" == 0 to the call with\n\t// \"flags & REGSUB_COPY\" != 0.\n\tif (copy)\n\t{\n\t    if (eval_result[nested] != NULL)\n\t    {\n\t\tSTRCPY(dest, eval_result[nested]);\n\t\tdst += STRLEN(eval_result[nested]);\n\t\tVIM_CLEAR(eval_result[nested]);\n\t    }\n\t}\n\telse\n\t{\n\t    int\t\t    prev_can_f_submatch = can_f_submatch;\n\t    regsubmatch_T   rsm_save;\n\n\t    VIM_CLEAR(eval_result[nested]);\n\n\t    // The expression may contain substitute(), which calls us\n\t    // recursively.  Make sure submatch() gets the text from the first\n\t    // level.\n\t    if (can_f_submatch)\n\t\trsm_save = rsm;\n\t    can_f_submatch = TRUE;\n\t    rsm.sm_match = rex.reg_match;\n\t    rsm.sm_mmatch = rex.reg_mmatch;\n\t    rsm.sm_firstlnum = rex.reg_firstlnum;\n\t    rsm.sm_maxline = rex.reg_maxline;\n\t    rsm.sm_line_lbr = rex.reg_line_lbr;\n\n\t    // Although unlikely, it is possible that the expression invokes a\n\t    // substitute command (it might fail, but still).  Therefore keep\n\t    // an array of eval results.\n\t    ++nesting;\n\n\t    if (expr != NULL)\n\t    {\n\t\ttypval_T\targv[2];\n\t\tchar_u\t\tbuf[NUMBUFLEN];\n\t\ttypval_T\trettv;\n\t\tstaticList10_T\tmatchList;\n\t\tfuncexe_T\tfuncexe;\n\n\t\trettv.v_type = VAR_STRING;\n\t\trettv.vval.v_string = NULL;\n\t\targv[0].v_type = VAR_LIST;\n\t\targv[0].vval.v_list = &matchList.sl_list;\n\t\tmatchList.sl_list.lv_len = 0;\n\t\tCLEAR_FIELD(funcexe);\n\t\tfuncexe.fe_argv_func = fill_submatch_list;\n\t\tfuncexe.fe_evaluate = TRUE;\n\t\tif (expr->v_type == VAR_FUNC)\n\t\t{\n\t\t    s = expr->vval.v_string;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_PARTIAL)\n\t\t{\n\t\t    partial_T   *partial = expr->vval.v_partial;\n\n\t\t    s = partial_name(partial);\n\t\t    funcexe.fe_partial = partial;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_INSTR)\n\t\t{\n\t\t    exe_typval_instr(expr, &rettv);\n\t\t}\n\t\tif (matchList.sl_list.lv_len > 0)\n\t\t    // fill_submatch_list() was called\n\t\t    clear_submatch_list(&matchList);\n\n\t\tif (rettv.v_type == VAR_UNKNOWN)\n\t\t    // something failed, no need to report another error\n\t\t    eval_result[nested] = NULL;\n\t\telse\n\t\t{\n\t\t    eval_result[nested] = tv_get_string_buf_chk(&rettv, buf);\n\t\t    if (eval_result[nested] != NULL)\n\t\t\teval_result[nested] = vim_strsave(eval_result[nested]);\n\t\t}\n\t\tclear_tv(&rettv);\n\t    }\n\t    else if (substitute_instr != NULL)\n\t\t// Execute instructions from ISN_SUBSTITUTE.\n\t\teval_result[nested] = exe_substitute_instr();\n\t    else\n\t\teval_result[nested] = eval_to_string(source + 2, TRUE);\n\t    --nesting;\n\n\t    if (eval_result[nested] != NULL)\n\t    {\n\t\tint had_backslash = FALSE;\n\n\t\tfor (s = eval_result[nested]; *s != NUL; MB_PTR_ADV(s))\n\t\t{\n\t\t    // Change NL to CR, so that it becomes a line break,\n\t\t    // unless called from vim_regexec_nl().\n\t\t    // Skip over a backslashed character.\n\t\t    if (*s == NL && !rsm.sm_line_lbr)\n\t\t\t*s = CAR;\n\t\t    else if (*s == '\\\\' && s[1] != NUL)\n\t\t    {\n\t\t\t++s;\n\t\t\t/* Change NL to CR here too, so that this works:\n\t\t\t * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:\n\t\t\t *   abc\\\n\t\t\t *   def\n\t\t\t * Not when called from vim_regexec_nl().\n\t\t\t */\n\t\t\tif (*s == NL && !rsm.sm_line_lbr)\n\t\t\t    *s = CAR;\n\t\t\thad_backslash = TRUE;\n\t\t    }\n\t\t}\n\t\tif (had_backslash && (flags & REGSUB_BACKSLASH))\n\t\t{\n\t\t    // Backslashes will be consumed, need to double them.\n\t\t    s = vim_strsave_escaped(eval_result[nested], (char_u *)\"\\\\\");\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tvim_free(eval_result[nested]);\n\t\t\teval_result[nested] = s;\n\t\t    }\n\t\t}\n\n\t\tdst += STRLEN(eval_result[nested]);\n\t    }\n\n\t    can_f_submatch = prev_can_f_submatch;\n\t    if (can_f_submatch)\n\t\trsm = rsm_save;\n\t}\n#endif\n    }\n    else\n      while ((c = *src++) != NUL)\n      {\n\tif (c == '&' && (flags & REGSUB_MAGIC))\n\t    no = 0;\n\telse if (c == '\\\\' && *src != NUL)\n\t{\n\t    if (*src == '&' && !(flags & REGSUB_MAGIC))\n\t    {\n\t\t++src;\n\t\tno = 0;\n\t    }\n\t    else if ('0' <= *src && *src <= '9')\n\t    {\n\t\tno = *src++ - '0';\n\t    }\n\t    else if (vim_strchr((char_u *)\"uUlLeE\", *src))\n\t    {\n\t\tswitch (*src++)\n\t\t{\n\t\tcase 'u':   func_one = (fptr_T)do_upper;\n\t\t\t    continue;\n\t\tcase 'U':   func_all = (fptr_T)do_Upper;\n\t\t\t    continue;\n\t\tcase 'l':   func_one = (fptr_T)do_lower;\n\t\t\t    continue;\n\t\tcase 'L':   func_all = (fptr_T)do_Lower;\n\t\t\t    continue;\n\t\tcase 'e':\n\t\tcase 'E':   func_one = func_all = (fptr_T)NULL;\n\t\t\t    continue;\n\t\t}\n\t    }\n\t}\n\tif (no < 0)\t      // Ordinary character.\n\t{\n\t    if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL)\n\t    {\n\t\t// Copy a special key as-is.\n\t\tif (copy)\n\t\t{\n\t\t    if (dst + 3 > dest + destlen)\n\t\t    {\n\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\treturn 0;\n\t\t    }\n\t\t    *dst++ = c;\n\t\t    *dst++ = *src++;\n\t\t    *dst++ = *src++;\n\t\t}\n\t\telse\n\t\t{\n\t\t    dst += 3;\n\t\t    src += 2;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c == '\\\\' && *src != NUL)\n\t    {\n\t\t// Check for abbreviations -- webb\n\t\tswitch (*src)\n\t\t{\n\t\t    case 'r':\tc = CAR;\t++src;\tbreak;\n\t\t    case 'n':\tc = NL;\t\t++src;\tbreak;\n\t\t    case 't':\tc = TAB;\t++src;\tbreak;\n\t\t // Oh no!  \\e already has meaning in subst pat :-(\n\t\t // case 'e':   c = ESC;\t++src;\tbreak;\n\t\t    case 'b':\tc = Ctrl_H;\t++src;\tbreak;\n\n\t\t    // If \"backslash\" is TRUE the backslash will be removed\n\t\t    // later.  Used to insert a literal CR.\n\t\t    default:\tif (flags & REGSUB_BACKSLASH)\n\t\t\t\t{\n\t\t\t\t    if (copy)\n\t\t\t\t    {\n\t\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t\t{\n\t\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t\t    return 0;\n\t\t\t\t\t}\n\t\t\t\t\t*dst = '\\\\';\n\t\t\t\t    }\n\t\t\t\t    ++dst;\n\t\t\t\t}\n\t\t\t\tc = *src++;\n\t\t}\n\t    }\n\t    else if (has_mbyte)\n\t\tc = mb_ptr2char(src - 1);\n\n\t    // Write to buffer, if copy is set.\n\t    if (func_one != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t    else if (func_all != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t    else // just copy\n\t\tcc = c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tint totlen = mb_ptr2len(src - 1);\n\t\tint charlen = mb_char2len(cc);\n\n\t\tif (copy)\n\t\t{\n\t\t    if (dst + charlen > dest + destlen)\n\t\t    {\n\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\treturn 0;\n\t\t    }\n\t\t    mb_char2bytes(cc, dst);\n\t\t}\n\t\tdst += charlen - 1;\n\t\tif (enc_utf8)\n\t\t{\n\t\t    int clen = utf_ptr2len(src - 1);\n\n\t\t    // If the character length is shorter than \"totlen\", there\n\t\t    // are composing characters; copy them as-is.\n\t\t    if (clen < totlen)\n\t\t    {\n\t\t\tif (copy)\n\t\t\t{\n\t\t\t    if (dst + totlen - clen > dest + destlen)\n\t\t\t    {\n\t\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\treturn 0;\n\t\t\t    }\n\t\t\t    mch_memmove(dst + 1, src - 1 + clen,\n\t\t\t\t\t\t     (size_t)(totlen - clen));\n\t\t\t}\n\t\t\tdst += totlen - clen;\n\t\t    }\n\t\t}\n\t\tsrc += totlen - 1;\n\t    }\n\t    else if (copy)\n\t    {\n\t\tif (dst + 1 > dest + destlen)\n\t\t{\n\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t    return 0;\n\t\t}\n\t\t*dst = cc;\n\t    }\n\t    dst++;\n\t}\n\telse\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\tclnum = rex.reg_mmatch->startpos[no].lnum;\n\t\tif (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0)\n\t\t    s = NULL;\n\t\telse\n\t\t{\n\t\t    s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;\n\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\tlen = rex.reg_mmatch->endpos[no].col\n\t\t\t\t\t    - rex.reg_mmatch->startpos[no].col;\n\t\t    else\n\t\t\tlen = (int)STRLEN(s);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ts = rex.reg_match->startp[no];\n\t\tif (rex.reg_match->endp[no] == NULL)\n\t\t    s = NULL;\n\t\telse\n\t\t    len = (int)(rex.reg_match->endp[no] - s);\n\t    }\n\t    if (s != NULL)\n\t    {\n\t\tfor (;;)\n\t\t{\n\t\t    if (len == 0)\n\t\t    {\n\t\t\tif (REG_MULTI)\n\t\t\t{\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tbreak;\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\t*dst = CAR;\n\t\t\t    }\n\t\t\t    ++dst;\n\t\t\t    s = reg_getline(++clnum);\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tlen = rex.reg_mmatch->endpos[no].col;\n\t\t\t    else\n\t\t\t\tlen = (int)STRLEN(s);\n\t\t\t}\n\t\t\telse\n\t\t\t    break;\n\t\t    }\n\t\t    else if (*s == NUL) // we hit NUL.\n\t\t    {\n\t\t\tif (copy)\n\t\t\t    iemsg(_(e_damaged_match_string));\n\t\t\tgoto exit;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif ((flags & REGSUB_BACKSLASH)\n\t\t\t\t\t\t  && (*s == CAR || *s == '\\\\'))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Insert a backslash in front of a CR, otherwise\n\t\t\t     * it will be replaced by a line break.\n\t\t\t     * Number of backslashes will be halved later,\n\t\t\t     * double them here.\n\t\t\t     */\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 2 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\tdst[0] = '\\\\';\n\t\t\t\tdst[1] = *s;\n\t\t\t    }\n\t\t\t    dst += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (has_mbyte)\n\t\t\t\tc = mb_ptr2char(s);\n\t\t\t    else\n\t\t\t\tc = *s;\n\n\t\t\t    if (func_one != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t\t\t    else if (func_all != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t\t\t    else // just copy\n\t\t\t\tcc = c;\n\n\t\t\t    if (has_mbyte)\n\t\t\t    {\n\t\t\t\tint l;\n\t\t\t\tint charlen;\n\n\t\t\t\t// Copy composing characters separately, one\n\t\t\t\t// at a time.\n\t\t\t\tif (enc_utf8)\n\t\t\t\t    l = utf_ptr2len(s) - 1;\n\t\t\t\telse\n\t\t\t\t    l = mb_ptr2len(s) - 1;\n\n\t\t\t\ts += l;\n\t\t\t\tlen -= l;\n\t\t\t\tcharlen = mb_char2len(cc);\n\t\t\t\tif (copy)\n\t\t\t\t{\n\t\t\t\t    if (dst + charlen > dest + destlen)\n\t\t\t\t    {\n\t\t\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t\treturn 0;\n\t\t\t\t    }\n\t\t\t\t    mb_char2bytes(cc, dst);\n\t\t\t\t}\n\t\t\t\tdst += charlen - 1;\n\t\t\t    }\n\t\t\t    else if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\t*dst = cc;\n\t\t\t    }\n\t\t\t    dst++;\n\t\t\t}\n\n\t\t\t++s;\n\t\t\t--len;\n\t\t    }\n\t\t}\n\t    }\n\t    no = -1;\n\t}\n      }\n    if (copy)\n\t*dst = NUL;\n\nexit:\n    return (int)((dst - dest) + 1);\n}\n\n#ifdef FEAT_EVAL\n/*\n * Call reg_getline() with the line numbers from the submatch.  If a\n * substitute() was used the reg_maxline and other values have been\n * overwritten.\n */\n    static char_u *\nreg_getline_submatch(linenr_T lnum)\n{\n    char_u *s;\n    linenr_T save_first = rex.reg_firstlnum;\n    linenr_T save_max = rex.reg_maxline;\n\n    rex.reg_firstlnum = rsm.sm_firstlnum;\n    rex.reg_maxline = rsm.sm_maxline;\n\n    s = reg_getline(lnum);\n\n    rex.reg_firstlnum = save_first;\n    rex.reg_maxline = save_max;\n    return s;\n}\n\n/*\n * Used for the submatch() function: get the string from the n'th submatch in\n * allocated memory.\n * Returns NULL when not in a \":s\" command and for a non-existing submatch.\n */\n    char_u *\nreg_submatch(int no)\n{\n    char_u\t*retval = NULL;\n    char_u\t*s;\n    int\t\tlen;\n    int\t\tround;\n    linenr_T\tlnum;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\t/*\n\t * First round: compute the length and allocate memory.\n\t * Second round: copy the text.\n\t */\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    lnum = rsm.sm_mmatch->startpos[no].lnum;\n\t    if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0)\n\t\treturn NULL;\n\n\t    s = reg_getline_submatch(lnum);\n\t    if (s == NULL)  // anti-crash check, cannot happen?\n\t\tbreak;\n\t    s += rsm.sm_mmatch->startpos[no].col;\n\t    if (rsm.sm_mmatch->endpos[no].lnum == lnum)\n\t    {\n\t\t// Within one line: take form start to end col.\n\t\tlen = rsm.sm_mmatch->endpos[no].col\n\t\t\t\t\t  - rsm.sm_mmatch->startpos[no].col;\n\t\tif (round == 2)\n\t\t    vim_strncpy(retval, s, len);\n\t\t++len;\n\t    }\n\t    else\n\t    {\n\t\t// Multiple lines: take start line from start col, middle\n\t\t// lines completely and end line up to end col.\n\t\tlen = (int)STRLEN(s);\n\t\tif (round == 2)\n\t\t{\n\t\t    STRCPY(retval, s);\n\t\t    retval[len] = '\\n';\n\t\t}\n\t\t++len;\n\t\t++lnum;\n\t\twhile (lnum < rsm.sm_mmatch->endpos[no].lnum)\n\t\t{\n\t\t    s = reg_getline_submatch(lnum++);\n\t\t    if (round == 2)\n\t\t\tSTRCPY(retval + len, s);\n\t\t    len += (int)STRLEN(s);\n\t\t    if (round == 2)\n\t\t\tretval[len] = '\\n';\n\t\t    ++len;\n\t\t}\n\t\tif (round == 2)\n\t\t    STRNCPY(retval + len, reg_getline_submatch(lnum),\n\t\t\t\t\t     rsm.sm_mmatch->endpos[no].col);\n\t\tlen += rsm.sm_mmatch->endpos[no].col;\n\t\tif (round == 2)\n\t\t    retval[len] = NUL;\n\t\t++len;\n\t    }\n\n\t    if (retval == NULL)\n\t    {\n\t\tretval = alloc(len);\n\t\tif (retval == NULL)\n\t\t    return NULL;\n\t    }\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    retval = NULL;\n\telse\n\t    retval = vim_strnsave(s, rsm.sm_match->endp[no] - s);\n    }\n\n    return retval;\n}\n\n/*\n * Used for the submatch() function with the optional non-zero argument: get\n * the list of strings from the n'th submatch in allocated memory with NULs\n * represented in NLs.\n * Returns a list of allocated strings.  Returns NULL when not in a \":s\"\n * command, for a non-existing submatch and for any error.\n */\n    list_T *\nreg_submatch_list(int no)\n{\n    char_u\t*s;\n    linenr_T\tslnum;\n    linenr_T\telnum;\n    colnr_T\tscol;\n    colnr_T\tecol;\n    int\t\ti;\n    list_T\t*list;\n    int\t\terror = FALSE;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\tslnum = rsm.sm_mmatch->startpos[no].lnum;\n\telnum = rsm.sm_mmatch->endpos[no].lnum;\n\tif (slnum < 0 || elnum < 0)\n\t    return NULL;\n\n\tscol = rsm.sm_mmatch->startpos[no].col;\n\tecol = rsm.sm_mmatch->endpos[no].col;\n\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\n\ts = reg_getline_submatch(slnum) + scol;\n\tif (slnum == elnum)\n\t{\n\t    if (list_append_string(list, s, ecol - scol) == FAIL)\n\t\terror = TRUE;\n\t}\n\telse\n\t{\n\t    if (list_append_string(list, s, -1) == FAIL)\n\t\terror = TRUE;\n\t    for (i = 1; i < elnum - slnum; i++)\n\t    {\n\t\ts = reg_getline_submatch(slnum + i);\n\t\tif (list_append_string(list, s, -1) == FAIL)\n\t\t    error = TRUE;\n\t    }\n\t    s = reg_getline_submatch(elnum);\n\t    if (list_append_string(list, s, ecol) == FAIL)\n\t\terror = TRUE;\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    return NULL;\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\tif (list_append_string(list, s,\n\t\t\t\t (int)(rsm.sm_match->endp[no] - s)) == FAIL)\n\t    error = TRUE;\n    }\n\n    if (error)\n    {\n\tlist_free(list);\n\treturn NULL;\n    }\n    ++list->lv_refcount;\n    return list;\n}\n#endif\n\n/*\n * Initialize the values used for matching against multiple lines\n */\n    static void\ninit_regexec_multi(\n\tregmmatch_T\t*rmp,\n\twin_T\t\t*win,\t// window in which to search or NULL\n\tbuf_T\t\t*buf,\t// buffer in which to search\n\tlinenr_T\tlnum)\t// nr of line to start looking for match\n{\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = buf;\n    rex.reg_win = win;\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    rex.reg_ic = rmp->rmm_ic;\n    rex.reg_icombine = FALSE;\n    rex.reg_maxcol = rmp->rmm_maxcol;\n}\n\n#include \"regexp_bt.c\"\n\nstatic regengine_T bt_regengine =\n{\n    bt_regcomp,\n    bt_regfree,\n    bt_regexec_nl,\n    bt_regexec_multi,\n};\n\n#include \"regexp_nfa.c\"\n\nstatic regengine_T nfa_regengine =\n{\n    nfa_regcomp,\n    nfa_regfree,\n    nfa_regexec_nl,\n    nfa_regexec_multi,\n};\n\n// Which regexp engine to use? Needed for vim_regcomp().\n// Must match with 'regexpengine'.\nstatic int regexp_engine = 0;\n\n#ifdef DEBUG\nstatic char_u regname[][30] = {\n\t\t    \"AUTOMATIC Regexp Engine\",\n\t\t    \"BACKTRACKING Regexp Engine\",\n\t\t    \"NFA Regexp Engine\"\n\t\t\t    };\n#endif\n\n/*\n * Compile a regular expression into internal code.\n * Returns the program in allocated memory.\n * Use vim_regfree() to free the memory.\n * Returns NULL for an error.\n */\n    regprog_T *\nvim_regcomp(char_u *expr_arg, int re_flags)\n{\n    regprog_T   *prog = NULL;\n    char_u\t*expr = expr_arg;\n    int\t\tcalled_emsg_before;\n\n    regexp_engine = p_re;\n\n    // Check for prefix \"\\%#=\", that sets the regexp engine\n    if (STRNCMP(expr, \"\\\\%#=\", 4) == 0)\n    {\n\tint newengine = expr[4] - '0';\n\n\tif (newengine == AUTOMATIC_ENGINE\n\t    || newengine == BACKTRACKING_ENGINE\n\t    || newengine == NFA_ENGINE)\n\t{\n\t    regexp_engine = expr[4] - '0';\n\t    expr += 5;\n#ifdef DEBUG\n\t    smsg(\"New regexp mode selected (%d): %s\",\n\t\t\t\t\t   regexp_engine, regname[newengine]);\n#endif\n\t}\n\telse\n\t{\n\t    emsg(_(e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used));\n\t    regexp_engine = AUTOMATIC_ENGINE;\n\t}\n    }\n#ifdef DEBUG\n    bt_regengine.expr = expr;\n    nfa_regengine.expr = expr;\n#endif\n    // reg_iswordc() uses rex.reg_buf\n    rex.reg_buf = curbuf;\n\n    /*\n     * First try the NFA engine, unless backtracking was requested.\n     */\n    called_emsg_before = called_emsg;\n    if (regexp_engine != BACKTRACKING_ENGINE)\n\tprog = nfa_regengine.regcomp(expr,\n\t\tre_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n    else\n\tprog = bt_regengine.regcomp(expr, re_flags);\n\n    // Check for error compiling regexp with initial engine.\n    if (prog == NULL)\n    {\n#ifdef BT_REGEXP_DEBUG_LOG\n\tif (regexp_engine == BACKTRACKING_ENGINE)   // debugging log for BT engine\n\t{\n\t    FILE *f;\n\t    f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \"a\");\n\t    if (f)\n\t    {\n\t\tfprintf(f, \"Syntax error in \\\"%s\\\"\\n\", expr);\n\t\tfclose(f);\n\t    }\n\t    else\n\t\tsemsg(\"(NFA) Could not open \\\"%s\\\" to write !!!\",\n\t\t\tBT_REGEXP_DEBUG_LOG_NAME);\n\t}\n#endif\n\t/*\n\t * If the NFA engine failed, try the backtracking engine.\n\t * The NFA engine also fails for patterns that it can't handle well\n\t * but are still valid patterns, thus a retry should work.\n\t * But don't try if an error message was given.\n\t */\n\tif (regexp_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t{\n\t    regexp_engine = BACKTRACKING_ENGINE;\n#ifdef FEAT_EVAL\n\t    report_re_switch(expr);\n#endif\n\t    prog = bt_regengine.regcomp(expr, re_flags);\n\t}\n    }\n\n    if (prog != NULL)\n    {\n\t// Store the info needed to call regcomp() again when the engine turns\n\t// out to be very slow when executing it.\n\tprog->re_engine = regexp_engine;\n\tprog->re_flags  = re_flags;\n    }\n\n    return prog;\n}\n\n/*\n * Free a compiled regexp program, returned by vim_regcomp().\n */\n    void\nvim_regfree(regprog_T *prog)\n{\n    if (prog != NULL)\n\tprog->engine->regfree(prog);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_regexp_stuff(void)\n{\n    ga_clear(&regstack);\n    ga_clear(&backpos);\n    vim_free(reg_tofree);\n    vim_free(reg_prev_sub);\n}\n#endif\n\n#ifdef FEAT_EVAL\n    static void\nreport_re_switch(char_u *pat)\n{\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tmsg_puts(_(\"Switching to backtracking RE engine for pattern: \"));\n\tmsg_puts((char *)pat);\n\tverbose_leave();\n    }\n}\n#endif\n\n#if defined(FEAT_X11) || defined(PROTO)\n/*\n * Return whether \"prog\" is currently being executed.\n */\n    int\nregprog_in_use(regprog_T *prog)\n{\n    return prog->re_in_use;\n}\n#endif\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed.\n * Uses curbuf for line count and 'iskeyword'.\n * When \"nl\" is TRUE consider a \"\\n\" in \"line\" to be a line break.\n *\n * Return TRUE if there is a match, FALSE if not.\n */\n    static int\nvim_regexec_string(\n    regmatch_T\t*rmp,\n    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_startp = NULL;\n    rex.reg_endp = NULL;\n    rex.reg_startpos = NULL;\n    rex.reg_endpos = NULL;\n\n    result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tvim_regfree(rmp->regprog);\n\tif (pat != NULL)\n\t{\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n\t    if (rmp->regprog != NULL)\n\t    {\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result > 0;\n}\n\n/*\n * Note: \"*prog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_prog(\n    regprog_T\t**prog,\n    int\t\tignore_case,\n    char_u\t*line,\n    colnr_T\tcol)\n{\n    int\t\tr;\n    regmatch_T\tregmatch;\n\n    regmatch.regprog = *prog;\n    regmatch.rm_ic = ignore_case;\n    r = vim_regexec_string(&regmatch, line, col, FALSE);\n    *prog = regmatch.regprog;\n    return r;\n}\n\n/*\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, FALSE);\n}\n\n/*\n * Like vim_regexec(), but consider a \"\\n\" in \"line\" to be a line break.\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, TRUE);\n}\n\n/*\n * Match a regexp against multiple lines.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed, even set to NULL.\n * Uses curbuf for line count and 'iskeyword'.\n *\n * Return zero if there is no match.  Return number of lines contained in the\n * match otherwise.\n */\n    long\nvim_regexec_multi(\n    regmmatch_T *rmp,\n    win_T       *win,\t\t// window in which to search or NULL\n    buf_T       *buf,\t\t// buffer in which to search\n    linenr_T\tlnum,\t\t// nr of line to start looking for match\n    colnr_T\tcol,\t\t// column to start looking for match\n    int\t\t*timed_out)\t// flag is set when timeout limit reached\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    result = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, timed_out);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tif (pat != NULL)\n\t{\n\t    regprog_T *prev_prog = rmp->regprog;\n\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // checking for \\z misuse was already done when compiling for NFA,\n\t    // allow all here\n\t    reg_do_extmatch = REX_ALL;\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n#ifdef FEAT_SYN_HL\n\t    reg_do_extmatch = 0;\n#endif\n\t    if (rmp->regprog == NULL)\n\t    {\n\t\t// Somehow compiling the pattern failed now, put back the\n\t\t// previous one to avoid \"regprog\" becoming NULL.\n\t\trmp->regprog = prev_prog;\n\t    }\n\t    else\n\t    {\n\t\tvim_regfree(prev_prog);\n\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, timed_out);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result <= 0 ? 0 : result;\n}\n", "\" Tests for regexp in latin1 encoding\n\nset encoding=latin1\nscriptencoding latin1\n\nsource check.vim\n\nfunc s:equivalence_test()\n  let str = 'A\u0410\u0411\u0412\u0413\u0414\u0415 B C D E\u0418\u0419\u041a\u041b F G H I\u041c\u041d\u041e\u041f J K L M N\u0421 O\u0422\u0423\u0424\u0425\u0426\u0428 P Q R S T U\u0429\u042a\u042b\u042c V W X Y\u042d Z '\n  \\      .. 'a\u0430\u0431\u0432\u0433\u0434\u0435 b c d e\u0438\u0439\u043a\u043b f g h i\u043c\u043d\u043e\u043f j k l m n\u0441 o\u0442\u0443\u0444\u0445\u0446\u0448 p q r s t u\u0449\u044a\u044b\u044c v w x y\u044d\u044f z '\n  \\      .. \"0 1 2 3 4 5 6 7 8 9 \"\n  \\      .. \"` ~ ! ? ; : . , / \\\\ ' \\\" | < > [ ] { } ( ) @ # $ % ^ & * _ - + \\b \\e \\f \\n \\r \\t\"\n  let groups = split(str)\n  for group1 in groups\n      for c in split(group1, '\\zs')\n\t\" next statement confirms that equivalence class matches every\n\t\" character in group\n        call assert_match('^[[=' . c . '=]]*$', group1)\n        for group2 in groups\n          if group2 != group1\n\t    \" next statement converts that equivalence class doesn't match\n\t    \" a character in any other group\n            call assert_equal(-1, match(group2, '[[=' . c . '=]]'))\n          endif\n        endfor\n      endfor\n  endfor\nendfunc\n\nfunc Test_equivalence_re1()\n  set re=1\n  call s:equivalence_test()\nendfunc\n\nfunc Test_equivalence_re2()\n  set re=2\n  call s:equivalence_test()\nendfunc\n\nfunc Test_recursive_substitute()\n  new\n  s/^/\\=execute(\"s#^##gn\")\n  \" check we are now not in the sandbox\n  call setwinvar(1, 'myvar', 1)\n  bwipe!\nendfunc\n\nfunc Test_nested_backrefs()\n  \" Check example in change.txt.\n  new\n  for re in range(0, 2)\n    exe 'set re=' . re\n    call setline(1, 'aa ab x')\n    1s/\\(\\(a[a-d] \\)*\\)\\(x\\)/-\\1- -\\2- -\\3-/\n    call assert_equal('-aa ab - -ab - -x-', getline(1))\n\n    call assert_equal('-aa ab - -ab - -x-', substitute('aa ab x', '\\(\\(a[a-d] \\)*\\)\\(x\\)', '-\\1- -\\2- -\\3-', ''))\n  endfor\n  bwipe!\n  set re=0\nendfunc\n\nfunc Test_eow_with_optional()\n  let expected = ['abc def', 'abc', 'def', '', '', '', '', '', '', '']\n  for re in range(0, 2)\n    exe 'set re=' . re\n    let actual = matchlist('abc def', '\\(abc\\>\\)\\?\\s*\\(def\\)')\n    call assert_equal(expected, actual)\n  endfor\nendfunc\n\nfunc Test_backref()\n  new\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  call assert_equal(3, search('\\%#=1\\(e\\)\\1'))\n  call assert_equal(3, search('\\%#=2\\(e\\)\\1'))\n  call assert_fails('call search(\"\\\\%#=1\\\\(e\\\\1\\\\)\")', 'E65:')\n  call assert_fails('call search(\"\\\\%#=2\\\\(e\\\\1\\\\)\")', 'E65:')\n  bwipe!\nendfunc\n\nfunc Test_multi_failure()\n  set re=1\n  call assert_fails('/a**', 'E61:')\n  call assert_fails('/a*\\+', 'E62:')\n  call assert_fails('/a\\{a}', 'E554:')\n  set re=2\n  call assert_fails('/a**', 'E871:')\n  call assert_fails('/a*\\+', 'E871:')\n  call assert_fails('/a\\{a}', 'E554:')\n  set re=0\nendfunc\n\nfunc Test_column_success_failure()\n  new\n  call setline(1, 'xbar')\n\n  set re=1\n  %s/\\%>0v./A/\n  call assert_equal('Abar', getline(1))\n  call assert_fails('/\\%v', 'E71:')\n  call assert_fails('/\\%>v', 'E71:')\n  call assert_fails('/\\%c', 'E71:')\n  call assert_fails('/\\%<c', 'E71:')\n  call assert_fails('/\\%l', 'E71:')\n  set re=2\n  %s/\\%>0v./B/\n  call assert_equal('Bbar', getline(1))\n  call assert_fails('/\\%v', 'E1273:')\n  call assert_fails('/\\%>v', 'E1273:')\n  call assert_fails('/\\%c', 'E1273:')\n  call assert_fails('/\\%<c', 'E1273:')\n  call assert_fails('/\\%l', 'E1273:')\n\n  set re=0\n  bwipe!\nendfunc\n\nfunc Test_recursive_addstate()\n  \" This will call addstate() recursively until it runs into the limit.\n  let lnum = search('\\v((){328}){389}')\n  call assert_equal(0, lnum)\nendfunc\n\nfunc Test_out_of_memory()\n  new\n  s/^/,n\n  \" This will be slow...\n  call assert_fails('call search(\"\\\\v((n||<)+);\")', 'E363:')\nendfunc\n\nfunc Test_get_equi_class()\n  new\n  \" Incomplete equivalence class caused invalid memory access\n  s/^/[[=\n  call assert_equal(1, search(getline(1)))\n  s/.*/[[.\n  call assert_equal(1, search(getline(1)))\nendfunc\n\nfunc Test_rex_init()\n  set noincsearch\n  set re=1\n  new\n  setlocal iskeyword=a-z\n  call setline(1, ['abc', 'ABC'])\n  call assert_equal(1, search('[[:keyword:]]'))\n  new\n  setlocal iskeyword=A-Z\n  call setline(1, ['abc', 'ABC'])\n  call assert_equal(2, search('[[:keyword:]]'))\n  bwipe!\n  bwipe!\n  set re=0\nendfunc\n\nfunc Test_range_with_newline()\n  new\n  call setline(1, \"a\")\n  call assert_equal(0, search(\"[ -*\\\\n- ]\"))\n  call assert_equal(0, search(\"[ -*\\\\t-\\\\n]\"))\n  bwipe!\nendfunc\n\nfunc Test_pattern_compile_speed()\n  CheckOption spellcapcheck\n  CheckFunction reltimefloat\n\n  let start = reltime()\n  \" this used to be very slow, not it should be about a second\n  set spc=\\\\v(((((Nxxxxxxx&&xxxx){179})+)+)+){179}\n  call assert_inrange(0.01, 10.0, reltimefloat(reltime(start)))\n  set spc=\nendfunc\n\n\" Tests for regexp patterns without multi-byte support.\nfunc Test_regexp_single_line_pat()\n  \" tl is a List of Lists with:\n  \"    regexp engines to test\n  \"       0 - test with 'regexpengine' values 0 and 1\n  \"       1 - test with 'regexpengine' values 0 and 2\n  \"       2 - test with 'regexpengine' values 0, 1 and 2\n  \"    regexp pattern\n  \"    text to test the pattern on\n  \"    expected match (optional)\n  \"    expected submatch 1 (optional)\n  \"    expected submatch 2 (optional)\n  \"    etc.\n  \"  When there is no match use only the first two items.\n  let tl = []\n\n  call add(tl, [2, 'ab', 'aab', 'ab'])\n  call add(tl, [2, 'b', 'abcdef', 'b'])\n  call add(tl, [2, 'bc*', 'abccccdef', 'bcccc'])\n  call add(tl, [2, 'bc\\{-}', 'abccccdef', 'b'])\n  call add(tl, [2, 'bc\\{-}\\(d\\)', 'abccccdef', 'bccccd', 'd'])\n  call add(tl, [2, 'bc*', 'abbdef', 'b'])\n  call add(tl, [2, 'c*', 'ccc', 'ccc'])\n  call add(tl, [2, 'bc*', 'abdef', 'b'])\n  call add(tl, [2, 'c*', 'abdef', ''])\n  call add(tl, [2, 'bc\\+', 'abccccdef', 'bcccc'])\n  call add(tl, [2, 'bc\\+', 'abdef']) \" no match\n  \" match escape character in a string\n  call add(tl, [2, '.\\e.', \"one\\<Esc>two\", \"e\\<Esc>t\"])\n  \" match backspace character in a string\n  call add(tl, [2, '.\\b.', \"one\\<C-H>two\", \"e\\<C-H>t\"])\n  \" match newline character in a string\n  call add(tl, [2, 'o\\nb', \"foo\\nbar\", \"o\\nb\"])\n\n  \" operator \\|\n  call add(tl, [2, 'a\\|ab', 'cabd', 'a']) \" alternation is ordered\n\n  call add(tl, [2, 'c\\?', 'ccb', 'c'])\n  call add(tl, [2, 'bc\\?', 'abd', 'b'])\n  call add(tl, [2, 'bc\\?', 'abccd', 'bc'])\n\n  call add(tl, [2, '\\va{1}', 'ab', 'a'])\n\n  call add(tl, [2, '\\va{2}', 'aa', 'aa'])\n  call add(tl, [2, '\\va{2}', 'caad', 'aa'])\n  call add(tl, [2, '\\va{2}', 'aba'])\n  call add(tl, [2, '\\va{2}', 'ab'])\n  call add(tl, [2, '\\va{2}', 'abaa', 'aa'])\n  call add(tl, [2, '\\va{2}', 'aaa', 'aa'])\n\n  call add(tl, [2, '\\vb{1}', 'abca', 'b'])\n  call add(tl, [2, '\\vba{2}', 'abaa', 'baa'])\n  call add(tl, [2, '\\vba{3}', 'aabaac'])\n\n  call add(tl, [2, '\\v(ab){1}', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1}', 'dabc', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1}', 'acb'])\n\n  call add(tl, [2, '\\v(ab){0,2}', 'acb', \"\", \"\"])\n  call add(tl, [2, '\\v(ab){0,2}', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1,2}', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1,2}', 'ababc', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2,4}', 'ababcab', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2,4}', 'abcababa', 'abab', 'ab'])\n\n  call add(tl, [2, '\\v(ab){2}', 'abab', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2}', 'cdababe', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2}', 'abac'])\n  call add(tl, [2, '\\v(ab){2}', 'abacabab', 'abab', 'ab'])\n  call add(tl, [2, '\\v((ab){2}){2}', 'abababab', 'abababab', 'abab', 'ab'])\n  call add(tl, [2, '\\v((ab){2}){2}', 'abacabababab', 'abababab', 'abab', 'ab'])\n\n  call add(tl, [2, '\\v(a{1}){1}', 'a', 'a', 'a'])\n  call add(tl, [2, '\\v(a{2}){1}', 'aa', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){1}', 'aaac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){1}', 'daaac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{1}){2}', 'daaac', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{1}){2}', 'aaa', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{2})+', 'adaac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2})+', 'aa', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){1}', 'aa', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{1}){2}', 'aa', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{1}){1}', 'a', 'a', 'a'])\n  call add(tl, [2, '\\v(a{2}){2}', 'aaaa', 'aaaa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){2}', 'aaabaaaa', 'aaaa', 'aa'])\n\n  call add(tl, [2, '\\v(a+){2}', 'dadaac', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{3}){2}', 'aaaaaaa', 'aaaaaa', 'aaa'])\n\n  call add(tl, [2, '\\v(a{1,2}){2}', 'daaac', 'aaa', 'a'])\n  call add(tl, [2, '\\v(a{1,3}){2}', 'daaaac', 'aaaa', 'a'])\n  call add(tl, [2, '\\v(a{1,3}){2}', 'daaaaac', 'aaaaa', 'aa'])\n  call add(tl, [2, '\\v(a{1,3}){3}', 'daac'])\n  call add(tl, [2, '\\v(a{1,2}){2}', 'dac'])\n  call add(tl, [2, '\\v(a+)+', 'daac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a+)+', 'aaa', 'aaa', 'aaa'])\n  call add(tl, [2, '\\v(a+){1,2}', 'aaa', 'aaa', 'aaa'])\n  call add(tl, [2, '\\v(a+)(a+)', 'aaa', 'aaa', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{3})+', 'daaaac', 'aaa', 'aaa'])\n  call add(tl, [2, '\\v(a|b|c)+', 'aacb', 'aacb', 'b'])\n  call add(tl, [2, '\\v(a|b|c){2}', 'abcb', 'ab', 'b'])\n  call add(tl, [2, '\\v(abc){2}', 'abcabd', ])\n  call add(tl, [2, '\\v(abc){2}', 'abdabcabc','abcabc', 'abc'])\n\n  call add(tl, [2, 'a*', 'cc', ''])\n  call add(tl, [2, '\\v(a*)+', 'cc', ''])\n  call add(tl, [2, '\\v((ab)+)+', 'ab', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(((ab)+)+)+', 'ab', 'ab', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(((ab)+)+)+', 'dababc', 'abab', 'abab', 'abab', 'ab'])\n  call add(tl, [2, '\\v(a{0,2})+', 'cc', ''])\n  call add(tl, [2, '\\v(a*)+', '', ''])\n  call add(tl, [2, '\\v((a*)+)+', '', ''])\n  call add(tl, [2, '\\v((ab)*)+', '', ''])\n  call add(tl, [2, '\\va{1,3}', 'aab', 'aa'])\n  call add(tl, [2, '\\va{2,3}', 'abaa', 'aa'])\n\n  call add(tl, [2, '\\v((ab)+|c*)+', 'abcccaba', 'abcccab', '', 'ab'])\n  call add(tl, [2, '\\v(a{2})|(b{3})', 'bbabbbb', 'bbb', '', 'bbb'])\n  call add(tl, [2, '\\va{2}|b{2}', 'abab'])\n  call add(tl, [2, '\\v(a)+|(c)+', 'bbacbaacbbb', 'a', 'a'])\n  call add(tl, [2, '\\vab{2,3}c', 'aabbccccccccccccc', 'abbc'])\n  call add(tl, [2, '\\vab{2,3}c', 'aabbbccccccccccccc', 'abbbc'])\n  call add(tl, [2, '\\vab{2,3}cd{2,3}e', 'aabbbcddee', 'abbbcdde'])\n  call add(tl, [2, '\\va(bc){2}d', 'aabcbfbc' ])\n  call add(tl, [2, '\\va*a{2}', 'a', ])\n  call add(tl, [2, '\\va*a{2}', 'aa', 'aa' ])\n  call add(tl, [2, '\\va*a{2}', 'aaa', 'aaa' ])\n  call add(tl, [2, '\\va*a{2}', 'bbbabcc', ])\n  call add(tl, [2, '\\va*b*|a*c*', 'a', 'a'])\n  call add(tl, [2, '\\va{1}b{1}|a{1}b{1}', ''])\n\n  \" submatches\n  call add(tl, [2, '\\v(a)', 'ab', 'a', 'a'])\n  call add(tl, [2, '\\v(a)(b)', 'ab', 'ab', 'a', 'b'])\n  call add(tl, [2, '\\v(ab)(b)(c)', 'abbc', 'abbc', 'ab', 'b', 'c'])\n  call add(tl, [2, '\\v((a)(b))', 'ab', 'ab', 'ab', 'a', 'b'])\n  call add(tl, [2, '\\v(a)|(b)', 'ab', 'a', 'a'])\n\n  call add(tl, [2, '\\v(a*)+', 'aaaa', 'aaaa', ''])\n  call add(tl, [2, 'x', 'abcdef'])\n\n  \"\n  \" Simple tests\n  \"\n\n  \" Search single groups\n  call add(tl, [2, 'ab', 'aab', 'ab'])\n  call add(tl, [2, 'ab', 'baced'])\n  call add(tl, [2, 'ab', '                    ab           ', 'ab'])\n\n  \" Search multi-modifiers\n  call add(tl, [2, 'x*', 'xcd', 'x'])\n  call add(tl, [2, 'x*', 'xxxxxxxxxxxxxxxxsofijiojgf', 'xxxxxxxxxxxxxxxx'])\n  \" empty match is good\n  call add(tl, [2, 'x*', 'abcdoij', ''])\n  \" no match here\n  call add(tl, [2, 'x\\+', 'abcdoin'])\n  call add(tl, [2, 'x\\+', 'abcdeoijdfxxiuhfij', 'xx'])\n  call add(tl, [2, 'x\\+', 'xxxxx', 'xxxxx'])\n  call add(tl, [2, 'x\\+', 'abc x siufhiush xxxxxxxxx', 'x'])\n  call add(tl, [2, 'x\\=', 'x sdfoij', 'x'])\n  call add(tl, [2, 'x\\=', 'abc sfoij', '']) \" empty match is good\n  call add(tl, [2, 'x\\=', 'xxxxxxxxx c', 'x'])\n  call add(tl, [2, 'x\\?', 'x sdfoij', 'x'])\n  \" empty match is good\n  call add(tl, [2, 'x\\?', 'abc sfoij', ''])\n  call add(tl, [2, 'x\\?', 'xxxxxxxxxx c', 'x'])\n\n  call add(tl, [2, 'a\\{0,0}', 'abcdfdoij', ''])\n  \" same thing as 'a?'\n  call add(tl, [2, 'a\\{0,1}', 'asiubid axxxaaa', 'a'])\n  \" same thing as 'a\\{0,1}'\n  call add(tl, [2, 'a\\{1,0}', 'asiubid axxxaaa', 'a'])\n  call add(tl, [2, 'a\\{3,6}', 'aa siofuh'])\n  call add(tl, [2, 'a\\{3,6}', 'aaaaa asfoij afaa', 'aaaaa'])\n  call add(tl, [2, 'a\\{3,6}', 'aaaaaaaa', 'aaaaaa'])\n  call add(tl, [2, 'a\\{0}', 'asoiuj', ''])\n  call add(tl, [2, 'a\\{2}', 'aaaa', 'aa'])\n  call add(tl, [2, 'a\\{2}', 'iuash fiusahfliusah fiushfilushfi uhsaifuh askfj nasfvius afg aaaa sfiuhuhiushf', 'aa'])\n  call add(tl, [2, 'a\\{2}', 'abcdefghijklmnopqrestuvwxyz1234567890'])\n  \" same thing as 'a*'\n  call add(tl, [2, 'a\\{0,}', 'oij sdigfusnf', ''])\n  call add(tl, [2, 'a\\{0,}', 'aaaaa aa', 'aaaaa'])\n  call add(tl, [2, 'a\\{2,}', 'sdfiougjdsafg'])\n  call add(tl, [2, 'a\\{2,}', 'aaaaasfoij ', 'aaaaa'])\n  call add(tl, [2, 'a\\{5,}', 'xxaaaaxxx '])\n  call add(tl, [2, 'a\\{5,}', 'xxaaaaaxxx ', 'aaaaa'])\n  call add(tl, [2, 'a\\{,0}', 'oidfguih iuhi hiu aaaa', ''])\n  call add(tl, [2, 'a\\{,5}', 'abcd', 'a'])\n  call add(tl, [2, 'a\\{,5}', 'aaaaaaaaaa', 'aaaaa'])\n  \" leading star as normal char when \\{} follows\n  call add(tl, [2, '^*\\{4,}$', '***'])\n  call add(tl, [2, '^*\\{4,}$', '****', '****'])\n  call add(tl, [2, '^*\\{4,}$', '*****', '*****'])\n  \" same thing as 'a*'\n  call add(tl, [2, 'a\\{}', 'bbbcddiuhfcd', ''])\n  call add(tl, [2, 'a\\{}', 'aaaaioudfh coisf jda', 'aaaa'])\n\n  call add(tl, [2, 'a\\{-0,0}', 'abcdfdoij', ''])\n  \" anti-greedy version of 'a?'\n  call add(tl, [2, 'a\\{-0,1}', 'asiubid axxxaaa', ''])\n  call add(tl, [2, 'a\\{-3,6}', 'aa siofuh'])\n  call add(tl, [2, 'a\\{-3,6}', 'aaaaa asfoij afaa', 'aaa'])\n  call add(tl, [2, 'a\\{-3,6}', 'aaaaaaaa', 'aaa'])\n  call add(tl, [2, 'a\\{-0}', 'asoiuj', ''])\n  call add(tl, [2, 'a\\{-2}', 'aaaa', 'aa'])\n  call add(tl, [2, 'a\\{-2}', 'abcdefghijklmnopqrestuvwxyz1234567890'])\n  call add(tl, [2, 'a\\{-0,}', 'oij sdigfusnf', ''])\n  call add(tl, [2, 'a\\{-0,}', 'aaaaa aa', ''])\n  call add(tl, [2, 'a\\{-2,}', 'sdfiougjdsafg'])\n  call add(tl, [2, 'a\\{-2,}', 'aaaaasfoij ', 'aa'])\n  call add(tl, [2, 'a\\{-,0}', 'oidfguih iuhi hiu aaaa', ''])\n  call add(tl, [2, 'a\\{-,5}', 'abcd', ''])\n  call add(tl, [2, 'a\\{-,5}', 'aaaaaaaaaa', ''])\n  \" anti-greedy version of 'a*'\n  call add(tl, [2, 'a\\{-}', 'bbbcddiuhfcd', ''])\n  call add(tl, [2, 'a\\{-}', 'aaaaioudfh coisf jda', ''])\n\n  \" Test groups of characters and submatches\n  call add(tl, [2, '\\(abc\\)*', 'abcabcabc', 'abcabcabc', 'abc'])\n  call add(tl, [2, '\\(ab\\)\\+', 'abababaaaaa', 'ababab', 'ab'])\n  call add(tl, [2, '\\(abaaaaa\\)*cd', 'cd', 'cd', ''])\n  call add(tl, [2, '\\(test1\\)\\? \\(test2\\)\\?', 'test1 test3', 'test1 ', 'test1', ''])\n  call add(tl, [2, '\\(test1\\)\\= \\(test2\\) \\(test4443\\)\\=', ' test2 test4443 yupiiiiiiiiiii', ' test2 test4443', '', 'test2', 'test4443'])\n  call add(tl, [2, '\\(\\(sub1\\) hello \\(sub 2\\)\\)', 'asterix sub1 hello sub 2 obelix', 'sub1 hello sub 2', 'sub1 hello sub 2', 'sub1', 'sub 2'])\n  call add(tl, [2, '\\(\\(\\(yyxxzz\\)\\)\\)', 'abcdddsfiusfyyzzxxyyxxzz', 'yyxxzz', 'yyxxzz', 'yyxxzz', 'yyxxzz'])\n  call add(tl, [2, '\\v((ab)+|c+)+', 'abcccaba', 'abcccab', 'ab', 'ab'])\n  call add(tl, [2, '\\v((ab)|c*)+', 'abcccaba', 'abcccab', '', 'ab'])\n  call add(tl, [2, '\\v(a(c*)+b)+', 'acbababaaa', 'acbabab', 'ab', ''])\n  call add(tl, [2, '\\v(a|b*)+', 'aaaa', 'aaaa', ''])\n  call add(tl, [2, '\\p*', 'a\u0431 \t', 'a\u0431 '])\n\n  \" Test greedy-ness and lazy-ness\n  call add(tl, [2, 'a\\{-2,7}','aaaaaaaaaaaaa', 'aa'])\n  call add(tl, [2, 'a\\{-2,7}x','aaaaaaaaax', 'aaaaaaax'])\n  call add(tl, [2, 'a\\{2,7}','aaaaaaaaaaaaaaaaaaaa', 'aaaaaaa'])\n  call add(tl, [2, 'a\\{2,7}x','aaaaaaaaax', 'aaaaaaax'])\n  call add(tl, [2, '\\vx(.{-,8})yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz','ayxa','xayzxayz'])\n  call add(tl, [2, '\\vx(.*)yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz', 'ayxayzxayzxa',''])\n  call add(tl, [2, '\\v(a{1,2}){-2,3}','aaaaaaa','aaaa','aa'])\n  call add(tl, [2, '\\v(a{-1,3})+', 'aa', 'aa', 'a'])\n  call add(tl, [2, '^\\s\\{-}\\zs\\( x\\|x$\\)', ' x', ' x', ' x'])\n  call add(tl, [2, '^\\s\\{-}\\zs\\(x\\| x$\\)', ' x', ' x', ' x'])\n  call add(tl, [2, '^\\s\\{-}\\ze\\(x\\| x$\\)', ' x', '', ' x'])\n  call add(tl, [2, '^\\(\\s\\{-}\\)\\(x\\| x$\\)', ' x', ' x', '', ' x'])\n\n  \" Test Character classes\n  call add(tl, [2, '\\d\\+e\\d\\d','test 10e23 fd','10e23'])\n\n  \" Test collections and character range []\n  call add(tl, [2, '\\v[a]', 'abcd', 'a'])\n  call add(tl, [2, 'a[bcd]', 'abcd', 'ab'])\n  call add(tl, [2, 'a[b-d]', 'acbd', 'ac'])\n  call add(tl, [2, '[a-d][e-f][x-x]d', 'cexdxx', 'cexd'])\n  call add(tl, [2, '\\v[[:alpha:]]+', 'abcdefghijklmnopqrstuvwxyz6','abcdefghijklmnopqrstuvwxyz'])\n  call add(tl, [2, '[[:alpha:]\\+]', '6x8','x'])\n  call add(tl, [2, '[^abc]\\+','abcabcabc'])\n  call add(tl, [2, '[^abc]','defghiasijvoinasoiunbvb','d'])\n  call add(tl, [2, '[^abc]\\+','ddddddda','ddddddd'])\n  call add(tl, [2, '[^a-d]\\+','aaaAAAZIHFNCddd','AAAZIHFNC'])\n  call add(tl, [2, '[a-f]*','iiiiiiii',''])\n  call add(tl, [2, '[a-f]*','abcdefgh','abcdef'])\n  call add(tl, [2, '[^a-f]\\+','abcdefgh','gh'])\n  call add(tl, [2, '[a-c]\\{-3,6}','abcabc','abc'])\n  call add(tl, [2, '[^[:alpha:]]\\+','abcccadfoij7787ysf287yrnccdu','7787'])\n  call add(tl, [2, '[-a]', '-', '-'])\n  call add(tl, [2, '[a-]', '-', '-'])\n  call add(tl, [2, '[a-f]*\\c','ABCDEFGH','ABCDEF'])\n  call add(tl, [2, '[abc][xyz]\\c','-af-AF-BY--','BY'])\n  \" filename regexp\n  call add(tl, [2, '[-./[:alnum:]_~]\\+', 'log13.file', 'log13.file'])\n  \" special chars\n  call add(tl, [2, '[\\]\\^\\-\\\\]\\+', '\\^\\\\\\-\\---^', '\\^\\\\\\-\\---^'])\n  \" collation elem\n  call add(tl, [2, '[[.a.]]\\+', 'aa', 'aa'])\n  \" middle of regexp\n  call add(tl, [2, 'abc[0-9]*ddd', 'siuhabc ii'])\n  call add(tl, [2, 'abc[0-9]*ddd', 'adf abc44482ddd oijs', 'abc44482ddd'])\n  call add(tl, [2, '\\_[0-9]\\+', 'asfi9888u', '9888'])\n  call add(tl, [2, '[0-9\\n]\\+', 'asfi9888u', '9888'])\n  call add(tl, [2, '\\_[0-9]\\+', \"asfi\\n9888u\", \"\\n9888\"])\n  call add(tl, [2, '\\_f', \"  \\na \", \"\\n\"])\n  call add(tl, [2, '\\_f\\+', \"  \\na \", \"\\na\"])\n  call add(tl, [2, '[0-9A-Za-z-_.]\\+', \" @0_a.A-{ \", \"0_a.A-\"])\n\n  \" Test start/end of line, start/end of file\n  call add(tl, [2, '^a.', \"a_\\nb \", \"a_\"])\n  call add(tl, [2, '^a.', \"b a \\na_\"])\n  call add(tl, [2, '.a$', \" a\\n \"])\n  call add(tl, [2, '.a$', \" a b\\n_a\", \"_a\"])\n  call add(tl, [2, '\\%^a.', \"a a\\na\", \"a \"])\n  call add(tl, [2, '\\%^a', \" a \\na \"])\n  call add(tl, [2, '.a\\%$', \" a\\n \"])\n  call add(tl, [2, '.a\\%$', \" a\\n_a\", \"_a\"])\n\n  \" Test recognition of character classes\n  call add(tl, [2, '[0-7]\\+', 'x0123456789x', '01234567'])\n  call add(tl, [2, '[^0-7]\\+', '0a;X+% 897', 'a;X+% 89'])\n  call add(tl, [2, '[0-9]\\+', 'x0123456789x', '0123456789'])\n  call add(tl, [2, '[^0-9]\\+', '0a;X+% 9', 'a;X+% '])\n  call add(tl, [2, '[0-9a-fA-F]\\+', 'x0189abcdefg', '0189abcdef'])\n  call add(tl, [2, '[^0-9A-Fa-f]\\+', '0189g;X+% ab', 'g;X+% '])\n  call add(tl, [2, '[a-z_A-Z0-9]\\+', ';+aso_SfOij ', 'aso_SfOij'])\n  call add(tl, [2, '[^a-z_A-Z0-9]\\+', 'aSo_;+% sfOij', ';+% '])\n  call add(tl, [2, '[a-z_A-Z]\\+', '0abyz_ABYZ;', 'abyz_ABYZ'])\n  call add(tl, [2, '[^a-z_A-Z]\\+', 'abAB_09;+% yzYZ', '09;+% '])\n  call add(tl, [2, '[a-z]\\+', '0abcxyz1', 'abcxyz'])\n  call add(tl, [2, '[a-z]\\+', 'AabxyzZ', 'abxyz'])\n  call add(tl, [2, '[^a-z]\\+', 'a;X09+% x', ';X09+% '])\n  call add(tl, [2, '[^a-z]\\+', 'abX0;%yz', 'X0;%'])\n  call add(tl, [2, '[a-zA-Z]\\+', '0abABxzXZ9', 'abABxzXZ'])\n  call add(tl, [2, '[^a-zA-Z]\\+', 'ab09_;+ XZ', '09_;+ '])\n  call add(tl, [2, '[A-Z]\\+', 'aABXYZz', 'ABXYZ'])\n  call add(tl, [2, '[^A-Z]\\+', 'ABx0;%YZ', 'x0;%'])\n  call add(tl, [2, '[a-z]\\+\\c', '0abxyzABXYZ;', 'abxyzABXYZ'])\n  call add(tl, [2, '[A-Z]\\+\\c', '0abABxzXZ9', 'abABxzXZ'])\n  call add(tl, [2, '\\c[^a-z]\\+', 'ab09_;+ XZ', '09_;+ '])\n  call add(tl, [2, '\\c[^A-Z]\\+', 'ab09_;+ XZ', '09_;+ '])\n  call add(tl, [2, '\\C[^A-Z]\\+', 'ABCOIJDEOIFNSD jsfoij sa', ' jsfoij sa'])\n\n  \" Tests for \\z features\n  \" match ends at \\ze\n  call add(tl, [2, 'xx \\ze test', 'xx '])\n  call add(tl, [2, 'abc\\zeend', 'oij abcend', 'abc'])\n  call add(tl, [2, 'aa\\zebb\\|aaxx', ' aabb ', 'aa'])\n  call add(tl, [2, 'aa\\zebb\\|aaxx', ' aaxx ', 'aaxx'])\n  call add(tl, [2, 'aabb\\|aa\\zebb', ' aabb ', 'aabb'])\n  call add(tl, [2, 'aa\\zebb\\|aaebb', ' aabb ', 'aa'])\n  \" match starts at \\zs\n  call add(tl, [2, 'abc\\zsdd', 'ddabcddxyzt', 'dd'])\n  call add(tl, [2, 'aa \\zsax', ' ax'])\n  call add(tl, [2, 'abc \\zsmatch\\ze abc', 'abc abc abc match abc abc', 'match'])\n  call add(tl, [2, '\\v(a \\zsif .*){2}', 'a if then a if last', 'if last', 'a if last'])\n  call add(tl, [2, '\\>\\zs.', 'aword. ', '.'])\n  call add(tl, [2, '\\s\\+\\ze\\[/\\|\\s\\zs\\s\\+', 'is   [a t', '  '])\n\n  \" Tests for \\@= and \\& features\n  call add(tl, [2, 'abc\\@=', 'abc', 'ab'])\n  call add(tl, [2, 'abc\\@=cd', 'abcd', 'abcd'])\n  call add(tl, [2, 'abc\\@=', 'ababc', 'ab'])\n  \" will never match, no matter the input text\n  call add(tl, [2, 'abcd\\@=e', 'abcd'])\n  \" will never match\n  call add(tl, [2, 'abcd\\@=e', 'any text in here ... '])\n  call add(tl, [2, '\\v(abc)@=..', 'xabcd', 'ab', 'abc'])\n  call add(tl, [2, '\\(.*John\\)\\@=.*Bob', 'here is John, and here is B'])\n  call add(tl, [2, '\\(John.*\\)\\@=.*Bob', 'John is Bobs friend', 'John is Bob', 'John is Bobs friend'])\n  call add(tl, [2, '\\<\\S\\+\\())\\)\\@=', '$((i=i+1))', 'i=i+1', '))'])\n  call add(tl, [2, '.*John\\&.*Bob', 'here is John, and here is B'])\n  call add(tl, [2, '.*John\\&.*Bob', 'John is Bobs friend', 'John is Bob'])\n  call add(tl, [2, '\\v(test1)@=.*yep', 'this is a test1, yep it is', 'test1, yep', 'test1'])\n  call add(tl, [2, 'foo\\(bar\\)\\@!', 'foobar'])\n  call add(tl, [2, 'foo\\(bar\\)\\@!', 'foo bar', 'foo'])\n  call add(tl, [2, 'if \\(\\(then\\)\\@!.\\)*$', ' if then else'])\n  call add(tl, [2, 'if \\(\\(then\\)\\@!.\\)*$', ' if else ', 'if else ', ' '])\n  call add(tl, [2, '\\(foo\\)\\@!bar', 'foobar', 'bar'])\n  call add(tl, [2, '\\(foo\\)\\@!...bar', 'foobar'])\n  call add(tl, [2, '^\\%(.*bar\\)\\@!.*\\zsfoo', ' bar foo '])\n  call add(tl, [2, '^\\%(.*bar\\)\\@!.*\\zsfoo', ' foo bar '])\n  call add(tl, [2, '^\\%(.*bar\\)\\@!.*\\zsfoo', ' foo xxx ', 'foo'])\n  call add(tl, [2, '[ ]\\@!\\p\\%([ ]\\@!\\p\\)*:', 'implicit mappings:', 'mappings:'])\n  call add(tl, [2, '[ ]\\@!\\p\\([ ]\\@!\\p\\)*:', 'implicit mappings:', 'mappings:', 's'])\n  call add(tl, [2, 'm\\k\\+_\\@=\\%(_\\@!\\k\\)\\@<=\\k\\+e', 'mx__xe', 'mx__xe'])\n  call add(tl, [2, '\\%(\\U\\@<=S\\k*\\|S\\l\\)R', 'SuR', 'SuR'])\n\n  \" Combining different tests and features\n  call add(tl, [2, '[[:alpha:]]\\{-2,6}', '787abcdiuhsasiuhb4', 'ab'])\n  call add(tl, [2, '', 'abcd', ''])\n  call add(tl, [2, '\\v(())', 'any possible text', ''])\n  call add(tl, [2, '\\v%(ab(xyz)c)', '   abxyzc ', 'abxyzc', 'xyz'])\n  call add(tl, [2, '\\v(test|)empty', 'tesempty', 'empty', ''])\n  call add(tl, [2, '\\v(a|aa)(a|aa)', 'aaa', 'aa', 'a', 'a'])\n\n  \" \\%u and friends\n  call add(tl, [2, '\\%d32', 'yes no', ' '])\n  call add(tl, [2, '\\%o40', 'yes no', ' '])\n  call add(tl, [2, '\\%x20', 'yes no', ' '])\n  call add(tl, [2, '\\%u0020', 'yes no', ' '])\n  call add(tl, [2, '\\%U00000020', 'yes no', ' '])\n  call add(tl, [2, '\\%d0', \"yes\\x0ano\", \"\\x0a\"])\n\n  \"\" \\%[abc]\n  call add(tl, [2, 'foo\\%[bar]', 'fobar'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobar', 'foobar'])\n  call add(tl, [2, 'foo\\%[bar]', 'fooxx', 'foo'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobxx', 'foob'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobaxx', 'fooba'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobarxx', 'foobar'])\n  call add(tl, [2, 'foo\\%[bar]x', 'foobxx', 'foobx'])\n  call add(tl, [2, 'foo\\%[bar]x', 'foobarxx', 'foobarx'])\n  call add(tl, [2, '\\%[bar]x', 'barxx', 'barx'])\n  call add(tl, [2, '\\%[bar]x', 'bxx', 'bx'])\n  call add(tl, [2, '\\%[bar]x', 'xxx', 'x'])\n  call add(tl, [2, 'b\\%[[ao]r]', 'bar bor', 'bar'])\n  call add(tl, [2, 'b\\%[[]]r]', 'b]r bor', 'b]r'])\n  call add(tl, [2, '@\\%[\\w\\-]*', '<http://john.net/pandoc/>[@pandoc]', '@pandoc'])\n\n  \" Alternatives, must use first longest match\n  call add(tl, [2, 'goo\\|go', 'google', 'goo'])\n  call add(tl, [2, '\\<goo\\|\\<go', 'google', 'goo'])\n  call add(tl, [2, '\\<goo\\|go', 'google', 'goo'])\n\n  \" Back references\n  call add(tl, [2, '\\(\\i\\+\\) \\1', ' abc abc', 'abc abc', 'abc'])\n  call add(tl, [2, '\\(\\i\\+\\) \\1', 'xgoo goox', 'goo goo', 'goo'])\n  call add(tl, [2, '\\(a\\)\\(b\\)\\(c\\)\\(dd\\)\\(e\\)\\(f\\)\\(g\\)\\(h\\)\\(i\\)\\1\\2\\3\\4\\5\\6\\7\\8\\9', 'xabcddefghiabcddefghix', 'abcddefghiabcddefghi', 'a', 'b', 'c', 'dd', 'e', 'f', 'g', 'h', 'i'])\n  call add(tl, [2, '\\(\\d*\\)a \\1b', ' a b ', 'a b', ''])\n  call add(tl, [2, '^.\\(.\\).\\_..\\1.', \"aaa\\naaa\\nb\", \"aaa\\naaa\", 'a'])\n  call add(tl, [2, '^.*\\.\\(.*\\)/.\\+\\(\\1\\)\\@<!$', 'foo.bat/foo.com', 'foo.bat/foo.com', 'bat'])\n  call add(tl, [2, '^.*\\.\\(.*\\)/.\\+\\(\\1\\)\\@<!$', 'foo.bat/foo.bat'])\n  call add(tl, [2, '^.*\\.\\(.*\\)/.\\+\\(\\1\\)\\@<=$', 'foo.bat/foo.bat', 'foo.bat/foo.bat', 'bat', 'bat'])\n  call add(tl, [2, '\\\\\\@<!\\${\\(\\d\\+\\%(:.\\{-}\\)\\?\\\\\\@<!\\)}', '2013-06-27${0}', '${0}', '0'])\n  call add(tl, [2, '^\\(a*\\)\\1$', 'aaaaaaaa', 'aaaaaaaa', 'aaaa'])\n  call add(tl, [2, '^\\(a\\{-2,}\\)\\1\\+$', 'aaaaaaaaa', 'aaaaaaaaa', 'aaa'])\n\n  \" Look-behind with limit\n  call add(tl, [2, '<\\@<=span.', 'xxspanxx<spanyyy', 'spany'])\n  call add(tl, [2, '<\\@1<=span.', 'xxspanxx<spanyyy', 'spany'])\n  call add(tl, [2, '<\\@2<=span.', 'xxspanxx<spanyyy', 'spany'])\n  call add(tl, [2, '\\(<<\\)\\@<=span.', 'xxspanxxxx<spanxx<<spanyyy', 'spany', '<<'])\n  call add(tl, [2, '\\(<<\\)\\@1<=span.', 'xxspanxxxx<spanxx<<spanyyy'])\n  call add(tl, [2, '\\(<<\\)\\@2<=span.', 'xxspanxxxx<spanxx<<spanyyy', 'spany', '<<'])\n  call add(tl, [2, '\\(foo\\)\\@<!bar.', 'xx foobar1 xbar2 xx', 'bar2'])\n\n  \" look-behind match in front of a zero-width item\n  call add(tl, [2, '\\v\\C%(<Last Changed:\\s+)@<=.*$', '\" test header'])\n  call add(tl, [2, '\\v\\C%(<Last Changed:\\s+)@<=.*$', '\" Last Changed: 1970', '1970'])\n  call add(tl, [2, '\\(foo\\)\\@<=\\>', 'foobar'])\n  call add(tl, [2, '\\(foo\\)\\@<=\\>', 'barfoo', '', 'foo'])\n  call add(tl, [2, '\\(foo\\)\\@<=.*', 'foobar', 'bar', 'foo'])\n\n  \" complicated look-behind match\n  call add(tl, [2, '\\(r\\@<=\\|\\w\\@<!\\)\\/', 'x = /word/;', '/'])\n  call add(tl, [2, '^[a-z]\\+\\ze \\&\\(asdf\\)\\@<!', 'foo bar', 'foo'])\n\n  \"\" \\@>\n  call add(tl, [2, '\\(a*\\)\\@>a', 'aaaa'])\n  call add(tl, [2, '\\(a*\\)\\@>b', 'aaab', 'aaab', 'aaa'])\n  call add(tl, [2, '^\\(.\\{-}b\\)\\@>.', '  abcbd', '  abc', '  ab'])\n  call add(tl, [2, '\\(.\\{-}\\)\\(\\)\\@>$', 'abc', 'abc', 'abc', ''])\n  \" TODO: BT engine does not restore submatch after failure\n  call add(tl, [1, '\\(a*\\)\\@>a\\|a\\+', 'aaaa', 'aaaa'])\n\n  \" \"\\_\" prepended negated collection matches EOL\n  call add(tl, [2, '\\_[^8-9]\\+', \"asfi\\n9888\", \"asfi\\n\"])\n  call add(tl, [2, '\\_[^a]\\+', \"asfi\\n9888\", \"sfi\\n9888\"])\n\n  \" Requiring lots of states.\n  call add(tl, [2, '[0-9a-zA-Z]\\{8}-\\([0-9a-zA-Z]\\{4}-\\)\\{3}[0-9a-zA-Z]\\{12}', \" 12345678-1234-1234-1234-123456789012 \", \"12345678-1234-1234-1234-123456789012\", \"1234-\"])\n\n  \" Skip adding state twice\n  call add(tl, [2, '^\\%(\\%(^\\s*#\\s*if\\>\\|#\\s*if\\)\\)\\(\\%>1c.*$\\)\\@=', \"#if FOO\", \"#if\", ' FOO'])\n\n  \" Test \\%V atom\n  call add(tl, [2, '\\%>70vGesamt', 'Jean-Michel Charlier & Victor Hubinon\\Gesamtausgabe [Salleck]    Buck Danny {Jean-Michel Charlier & Victor Hubinon}\\Gesamtausgabe', 'Gesamt'])\n\n  \" Test for ignoring case and matching repeated characters\n  call add(tl, [2, '\\cb\\+', 'aAbBbBcC', 'bBbB'])\n\n  \" Run the tests\n  for t in tl\n    let re = t[0]\n    let pat = t[1]\n    let text = t[2]\n    let matchidx = 3\n    for engine in [0, 1, 2]\n      if engine == 2 && re == 0 || engine == 1 && re == 1\n        continue\n      endif\n      let &regexpengine = engine\n      try\n        let l = matchlist(text, pat)\n      catch\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", caused an exception: \\\"'\n              \\ . v:exception . '\\\"')\n      endtry\n      \" check the match itself\n      if len(l) == 0 && len(t) > matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", did not match, expected: \\\"'\n              \\ . t[matchidx] . '\\\"')\n      elseif len(l) > 0 && len(t) == matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0]\n              \\ . '\\\", expected no match')\n      elseif len(t) > matchidx && l[0] != t[matchidx]\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0]\n              \\ . '\\\", expected: \\\"' . t[matchidx] . '\\\"')\n      else\n        \" Test passed\n      endif\n\n      \" check all the nine submatches\n      if len(l) > 0\n        for i in range(1, 9)\n          if len(t) <= matchidx + i\n            let e = ''\n          else\n            let e = t[matchidx + i]\n          endif\n          if l[i] != e\n            call assert_report('Error ' . engine . ': pat: \\\"' . pat\n                  \\ . '\\\", text: \\\"' . text . '\\\", submatch ' . i . ': \\\"'\n                  \\ . l[i] . '\\\", expected: \\\"' . e . '\\\"')\n          endif\n        endfor\n        unlet i\n      endif\n    endfor\n  endfor\n\n  unlet t tl e l\nendfunc\n\n\" Tests for multi-line regexp patterns without multi-byte support.\nfunc Test_regexp_multiline_pat()\n  \" tl is a List of Lists with:\n  \"    regexp engines to test\n  \"       0 - test with 'regexpengine' values 0 and 1\n  \"       1 - test with 'regexpengine' values 0 and 2\n  \"       2 - test with 'regexpengine' values 0, 1 and 2\n  \"    regexp pattern\n  \"    List with text to test the pattern on\n  \"    List with the expected match\n  let tl = []\n\n  \" back references\n  call add(tl, [2, '^.\\(.\\).\\_..\\1.', ['aaa', 'aaa', 'b'], ['XX', 'b']])\n  call add(tl, [2, '\\v.*\\/(.*)\\n.*\\/\\1$', ['./Dir1/Dir2/zyxwvuts.txt', './Dir1/Dir2/abcdefgh.bat', '', './Dir1/Dir2/file1.txt', './OtherDir1/OtherDir2/file1.txt'], ['./Dir1/Dir2/zyxwvuts.txt', './Dir1/Dir2/abcdefgh.bat', '', 'XX']])\n\n  \" line breaks\n  call add(tl, [2, '\\S.*\\nx', ['abc', 'def', 'ghi', 'xjk', 'lmn'], ['abc', 'def', 'XXjk', 'lmn']])\n\n  \" Any single character or end-of-line\n  call add(tl, [2, '\\_.\\+', ['a', 'b', 'c'], ['XX']])\n  \" Any identifier or end-of-line\n  call add(tl, [2, '\\_i\\+', ['a', 'b', ';', '2'], ['XX;XX']])\n  \" Any identifier but excluding digits or end-of-line\n  call add(tl, [2, '\\_I\\+', ['a', 'b', ';', '2'], ['XX;XX2XX']])\n  \" Any keyword or end-of-line\n  call add(tl, [2, '\\_k\\+', ['a', 'b', '=', '2'], ['XX=XX']])\n  \" Any keyword but excluding digits or end-of-line\n  call add(tl, [2, '\\_K\\+', ['a', 'b', '=', '2'], ['XX=XX2XX']])\n  \" Any filename character or end-of-line\n  call add(tl, [2, '\\_f\\+', ['a', 'b', '.', '5'], ['XX']])\n  \" Any filename character but excluding digits or end-of-line\n  call add(tl, [2, '\\_F\\+', ['a', 'b', '.', '5'], ['XX5XX']])\n  \" Any printable character or end-of-line\n  call add(tl, [2, '\\_p\\+', ['a', 'b', '=', '4'], ['XX']])\n  \" Any printable character excluding digits or end-of-line\n  call add(tl, [2, '\\_P\\+', ['a', 'b', '=', '4'], ['XX4XX']])\n  \" Any whitespace character or end-of-line\n  call add(tl, [2, '\\_s\\+', [' ', ' ', 'a', 'b'], ['XXaXXbXX']])\n  \" Any non-whitespace character or end-of-line\n  call add(tl, [2, '\\_S\\+', [' ', ' ', 'a', 'b'], [' XX XX']])\n  \" Any decimal digit or end-of-line\n  call add(tl, [2, '\\_d\\+', ['1', 'a', '2', 'b', '3'], ['XXaXXbXX']])\n  \" Any non-decimal digit or end-of-line\n  call add(tl, [2, '\\_D\\+', ['1', 'a', '2', 'b', '3'], ['1XX2XX3XX']])\n  \" Any hexadecimal digit or end-of-line\n  call add(tl, [2, '\\_x\\+', ['1', 'a', 'g', '9', '8'], ['XXgXX']])\n  \" Any non-hexadecimal digit or end-of-line\n  call add(tl, [2, '\\_X\\+', ['1', 'a', 'g', '9', '8'], ['1XXaXX9XX8XX']])\n  \" Any octal digit or end-of-line\n  call add(tl, [2, '\\_o\\+', ['0', '7', '8', '9', '0'], ['XX8XX9XX']])\n  \" Any non-octal digit or end-of-line\n  call add(tl, [2, '\\_O\\+', ['0', '7', '8', '9', '0'], ['0XX7XX0XX']])\n  \" Any word character or end-of-line\n  call add(tl, [2, '\\_w\\+', ['A', 'B', '=', 'C', 'D'], ['XX=XX']])\n  \" Any non-word character or end-of-line\n  call add(tl, [2, '\\_W\\+', ['A', 'B', '=', 'C', 'D'], ['AXXBXXCXXDXX']])\n  \" Any head-of-word character or end-of-line\n  call add(tl, [2, '\\_h\\+', ['a', '1', 'b', '2', 'c'], ['XX1XX2XX']])\n  \" Any non-head-of-word character or end-of-line\n  call add(tl, [2, '\\_H\\+', ['a', '1', 'b', '2', 'c'], ['aXXbXXcXX']])\n  \" Any alphabetic character or end-of-line\n  call add(tl, [2, '\\_a\\+', ['a', '1', 'b', '2', 'c'], ['XX1XX2XX']])\n  \" Any non-alphabetic character or end-of-line\n  call add(tl, [2, '\\_A\\+', ['a', '1', 'b', '2', 'c'], ['aXXbXXcXX']])\n  \" Any lowercase character or end-of-line\n  call add(tl, [2, '\\_l\\+', ['a', 'A', 'b', 'B'], ['XXAXXBXX']])\n  \" Any non-lowercase character or end-of-line\n  call add(tl, [2, '\\_L\\+', ['a', 'A', 'b', 'B'], ['aXXbXX']])\n  \" Any uppercase character or end-of-line\n  call add(tl, [2, '\\_u\\+', ['a', 'A', 'b', 'B'], ['aXXbXX']])\n  \" Any non-uppercase character or end-of-line\n  call add(tl, [2, '\\_U\\+', ['a', 'A', 'b', 'B'], ['XXAXXBXX']])\n  \" Collection or end-of-line\n  call add(tl, [2, '\\_[a-z]\\+', ['a', 'A', 'b', 'B'], ['XXAXXBXX']])\n  \" start of line anywhere in the text\n  call add(tl, [2, 'one\\zs\\_s*\\_^\\zetwo',\n        \\ ['', 'one', ' two', 'one', '', 'two'],\n        \\ ['', 'one', ' two', 'oneXXtwo']])\n  \" end of line anywhere in the text\n  call add(tl, [2, 'one\\zs\\_$\\_s*two',\n        \\ ['', 'one', ' two', 'one', '', 'two'], ['', 'oneXX', 'oneXX']])\n\n  \" Check that \\_[0-9] matching EOL does not break a following \\>\n  call add(tl, [2, '\\<\\(\\(25\\_[0-5]\\|2\\_[0-4]\\_[0-9]\\|\\_[01]\\?\\_[0-9]\\_[0-9]\\?\\)\\.\\)\\{3\\}\\(25\\_[0-5]\\|2\\_[0-4]\\_[0-9]\\|\\_[01]\\?\\_[0-9]\\_[0-9]\\?\\)\\>', ['', 'localnet/192.168.0.1', ''], ['', 'localnet/XX', '']])\n\n  \" Check a pattern with a line break and ^ and $\n  call add(tl, [2, 'a\\n^b$\\n^c', ['a', 'b', 'c'], ['XX']])\n\n  call add(tl, [2, '\\(^.\\+\\n\\)\\1', [' dog', ' dog', 'asdf'], ['XXasdf']])\n\n  \" Run the multi-line tests\n  for t in tl\n    let re = t[0]\n    let pat = t[1]\n    let before = t[2]\n    let after = t[3]\n    for engine in [0, 1, 2]\n      if engine == 2 && re == 0 || engine == 1 && re == 1\n        continue\n      endif\n      let &regexpengine = engine\n      new\n      call setline(1, before)\n      exe '%s/' . pat . '/XX/'\n      let result = getline(1, '$')\n      q!\n      if result != after\n        call assert_report('Error: pat: \\\"' . pat . '\\\", text: \\\"'\n              \\ . string(before) . '\\\", expected: \\\"' . string(after)\n              \\ . '\\\", got: \\\"' . string(result) . '\\\"')\n      else\n        \" Test passed\n      endif\n    endfor\n  endfor\n  unlet t tl\nendfunc\n\n\" Check that using a pattern on two lines doesn't get messed up by using\n\" matchstr() with \\ze in between.\nfunc Test_matchstr_with_ze()\n  new\n  call append(0, ['Substitute here:', '<T=\"\">Ta 5</Title>',\n        \\ '<T=\"\">Ac 7</Title>'])\n  call cursor(1, 1)\n  set re=0\n\n  .+1,.+2s/\"\"/\\='\"' . matchstr(getline(\".\"), '\\d\\+\\ze<') . '\"'\n  call assert_equal(['Substitute here:', '<T=\"5\">Ta 5</Title>',\n        \\ '<T=\"7\">Ac 7</Title>', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Check a pattern with a look behind crossing a line boundary\nfunc Test_lookbehind_across_line()\n  new\n  call append(0, ['Behind:', 'asdfasd<yyy', 'xxstart1', 'asdfasd<yy',\n        \\ 'xxxstart2', 'asdfasd<yy', 'xxstart3'])\n  call cursor(1, 1)\n  call search('\\(<\\_[xy]\\+\\)\\@3<=start')\n  call assert_equal([0, 7, 3, 0], getpos('.'))\n  bwipe!\nendfunc\n\n\" Test for the \\%V atom (match inside the visual area)\nfunc Regex_Match_Visual_Area()\n  call append(0, ['Visual:', 'thexe the thexethe', 'andaxand andaxand',\n        \\ 'oooxofor foroxooo', 'oooxofor foroxooo'])\n  call cursor(1, 1)\n  exe \"normal jfxvfx:s/\\\\%Ve/E/g\\<CR>\"\n  exe \"normal jV:s/\\\\%Va/A/g\\<CR>\"\n  exe \"normal jfx\\<C-V>fxj:s/\\\\%Vo/O/g\\<CR>\"\n  call assert_equal(['Visual:', 'thexE thE thExethe', 'AndAxAnd AndAxAnd',\n        \\ 'oooxOfOr fOrOxooo', 'oooxOfOr fOrOxooo', ''], getline(1, '$'))\n  %d\nendfunc\n\n\" Check matching Visual area\nfunc Test_matching_visual_area()\n  new\n  set regexpengine=1\n  call Regex_Match_Visual_Area()\n  set regexpengine=2\n  call Regex_Match_Visual_Area()\n  set regexpengine&\n  bwipe!\nendfunc\n\n\" Check matching marks\nfunc Regex_Mark()\n  call append(0, ['', '', '', 'Marks:', 'asdfSasdfsadfEasdf', 'asdfSas',\n        \\ 'dfsadfEasdf', '', '', '', '', ''])\n  call cursor(4, 1)\n  exe \"normal jfSmsfEme:.-4,.+6s/.\\\\%>'s.*\\\\%<'e../here/\\<CR>\"\n  exe \"normal jfSmsj0fEme:.-4,.+6s/.\\\\%>'s\\\\_.*\\\\%<'e../again/\\<CR>\"\n  call assert_equal(['', '', '', 'Marks:', 'asdfhereasdf', 'asdfagainasdf',\n        \\ '', '', '', '', '', ''], getline(1, '$'))\n  %d\nendfunc\n\nfunc Test_matching_marks()\n  new\n  set regexpengine=1\n  call Regex_Mark()\n  set regexpengine=2\n  call Regex_Mark()\n  bwipe!\nendfunc\n\n\" Check patterns matching cursor position.\nfunc s:curpos_test()\n  new\n  call setline(1, ['ffooooo', 'boboooo', 'zoooooo', 'koooooo', 'moooooo',\n        \\ \"\\t\\t\\tfoo\", 'abababababababfoo', 'bababababababafoo', '********_',\n        \\ '        xxxxxxxxxxxx    xxxx xxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxx xxxxx xxxxxxx xx xxxx xxxxxxxx xxxx xxxxxxxxxxx xxx xxxxxxx xxxxxxxxx xx xxxxxx xx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxx xxxxxxxx xxxxxxxxx xxxx xxx xxxx xxx xxx xxxxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxxxxxxx xx xxxxx xxx xxxxxxxx xxxxxx xxx xxx xxxxxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxxx  xxxxxxxxxxxxxxxxxx xxxxxxx xxxxxxx xxx xxx xxxxxxxx xxxxxxx  xxxx xxx xxxxxx xxxxx xxxxx xx xxxxxx xxxxxxx xxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxx xxxxxx xxxxx xxx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxxxxxxxxx xxxx xx xxxxxxxx xxx xxxxxxxxxxx xxxxx'])\n  call setpos('.', [0, 1, 0, 0])\n  s/\\%>3c.//g\n  call setpos('.', [0, 2, 4, 0])\n  s/\\%#.*$//g\n  call setpos('.', [0, 3, 0, 0])\n  s/\\%<3c./_/g\n  %s/\\%4l\\%>5c./_/g\n  %s/\\%6l\\%>25v./_/g\n  %s/\\%>6l\\%3c./!/g\n  %s/\\%>7l\\%12c./?/g\n  %s/\\%>7l\\%<9l\\%>5v\\%<8v./#/g\n  $s/\\%(|\\u.*\\)\\@<=[^|\\t]\\+$//ge\n  call assert_equal(['ffo', 'bob', '__ooooo', 'koooo__', 'moooooo',\n        \\ '\t\t\tf__', 'ab!babababababfoo',\n        \\ 'ba!ab##abab?bafoo', '**!*****_',\n        \\ '  !     xxx?xxxxxxxx    xxxx xxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxx xxxxx xxxxxxx xx xxxx xxxxxxxx xxxx xxxxxxxxxxx xxx xxxxxxx xxxxxxxxx xx xxxxxx xx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxx xxxxxxxx xxxxxxxxx xxxx xxx xxxx xxx xxx xxxxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxxxxxxx xx xxxxx xxx xxxxxxxx xxxxxx xxx xxx xxxxxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxxx  xxxxxxxxxxxxxxxxxx xxxxxxx xxxxxxx xxx xxx xxxxxxxx xxxxxxx  xxxx xxx xxxxxx xxxxx xxxxx xx xxxxxx xxxxxxx xxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxx xxxxxx xxxxx xxx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxxxxxxxxx xxxx xx xxxxxxxx xxx xxxxxxxxxxx xxxxx'],\n        \\ getline(1, '$'))\n  bwipe!\nendfunc\n\nfunc Test_matching_curpos()\n  set re=0\n  call s:curpos_test()\n  set re=1\n  call s:curpos_test()\n  set re=2\n  call s:curpos_test()\n  set re&\nendfunc\n\n\" Test for matching the start and end of a buffer\nfunc Regex_start_end_buffer()\n  call setline(1, repeat(['vim edit'], 20))\n  /\\%^\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  exe \"normal 50%/\\\\%^..\\<CR>\"\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  exe \"normal 50%/\\\\%$\\<CR>\"\n  call assert_equal([0, 20, 8, 0], getpos('.'))\n  exe \"normal 6gg/..\\\\%$\\<CR>\"\n  call assert_equal([0, 20, 7, 0], getpos('.'))\n  %d\nendfunc\n\nfunc Test_start_end_of_buffer_match()\n  new\n  set regexpengine=1\n  call Regex_start_end_buffer()\n  set regexpengine=2\n  call Regex_start_end_buffer()\n  bwipe!\nendfunc\n\nfunc Test_ze_before_zs()\n  call assert_equal('', matchstr(' ', '\\%#=1\\ze \\zs'))\n  call assert_equal('', matchstr(' ', '\\%#=2\\ze \\zs'))\n  call assert_equal(repeat([''], 10), matchlist(' ', '\\%#=1\\ze \\zs'))\n  call assert_equal(repeat([''], 10), matchlist(' ', '\\%#=2\\ze \\zs'))\nendfunc\n\n\" Check for detecting error\nfunc Test_regexp_error()\n  call assert_fails(\"call matchlist('x x', '\\\\%#=1 \\\\zs*')\", 'E888:')\n  call assert_fails(\"call matchlist('x x', '\\\\%#=1 \\\\ze*')\", 'E888:')\n  call assert_fails(\"call matchlist('x x', '\\\\%#=2 \\\\zs*')\", 'E888:')\n  call assert_fails(\"call matchlist('x x', '\\\\%#=2 \\\\ze*')\", 'E888:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%o841\\\\%o142')\", 'E678:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%#=2\\\\%2147483647c')\", 'E951:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%#=2\\\\%2147483647l')\", 'E951:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%#=2\\\\%2147483647v')\", 'E951:')\n  call assert_fails('exe \"normal /\\\\%#=1\\\\%[x\\\\%[x]]\\<CR>\"',   'E369:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483647l\\<CR>\"', 'E951:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483647c\\<CR>\"', 'E951:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%102261126v\\<CR>\"',  'E951:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483646l\\<CR>\"', 'E486:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483646c\\<CR>\"', 'E486:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%102261125v\\<CR>\"',  'E486:')\n  call assert_equal('', matchstr('abcd', '\\%o181\\%o142'))\nendfunc\n\n\" Test for using the last substitute string pattern (~)\nfunc Test_regexp_last_subst_string()\n  new\n  s/bar/baz/e\n  call assert_equal(matchstr(\"foo\\nbaz\\nbar\", \"\\\\%#=1\\~\"), \"baz\")\n  call assert_equal(matchstr(\"foo\\nbaz\\nbar\", \"\\\\%#=2\\~\"), \"baz\")\n  close!\nendfunc\n\n\" Check patterns matching cursor position.\nfunc s:curpos_test2()\n  new\n  call setline(1, ['1', '2 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '3 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '6\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'])\n  call setpos('.', [0, 2, 10, 0])\n  s/\\%.c.*//g\n  call setpos('.', [0, 3, 15, 0])\n  s/\\%.l.*//g\n  call setpos('.', [0, 5, 3, 0])\n  s/\\%.v.*/_/g\n  call assert_equal(['1',\n        \\ '2 foobar ',\n        \\ '',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\t_',\n        \\ '6\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'],\n        \\ getline(1, '$'))\n  call assert_fails('call search(\"\\\\%.1l\")', 'E1204:')\n  call assert_fails('call search(\"\\\\%.1c\")', 'E1204:')\n  call assert_fails('call search(\"\\\\%.1v\")', 'E1204:')\n  bwipe!\nendfunc\n\n\" Check patterns matching before or after cursor position.\nfunc s:curpos_test3()\n  new\n  call setline(1, ['1', '2 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '3 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '6\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'])\n  call setpos('.', [0, 2, 10, 0])\n  \" Note: This removes all columns, except for the column directly in front of\n  \" the cursor. Bug????\n  :s/^.*\\%<.c//\n  call setpos('.', [0, 3, 10, 0])\n  :s/\\%>.c.*$//\n  call setpos('.', [0, 5, 4, 0])\n  \" Note: This removes all columns, except for the column directly in front of\n  \" the cursor. Bug????\n  :s/^.*\\%<.v/_/\n  call setpos('.', [0, 6, 4, 0])\n  :s/\\%>.v.*$/_/\n  call assert_equal(['1',\n        \\ ' eins zwei drei vier f\u044cnf sechse',\n        \\ '3 foobar e',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '_foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '6\tfo_',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'],\n        \\ getline(1, '$'))\n  sil %d\n  call setline(1, ['1', '2 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '3 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '6\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'])\n  call setpos('.', [0, 4, 4, 0])\n  %s/\\%<.l.*//\n  call setpos('.', [0, 5, 4, 0])\n  %s/\\%>.l.*//\n  call assert_equal(['', '', '',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '', ''],\n        \\ getline(1, '$'))\n  bwipe!\nendfunc\n\n\" Test that matching below, at or after the\n\" cursor position work\nfunc Test_matching_pos()\n  for val in range(3)\n    exe \"set re=\" .. val\n    \" Match at cursor position\n    call s:curpos_test2()\n    \" Match before or after cursor position\n    call s:curpos_test3()\n  endfor\n  set re&\nendfunc\n\nfunc Test_using_mark_position()\n  \" this was using freed memory\n  \" new engine\n  new\n  norm O0\n  call assert_fails(\"s/\\\\%')\", 'E486:')\n  bwipe!\n\n  \" old engine\n  new\n  norm O0\n  call assert_fails(\"s/\\\\%#=1\\\\%')\", 'E486:')\n  bwipe!\nendfunc\n\nfunc Test_using_visual_position()\n  \" this was using freed memory\n  new\n  exe \"norm 0o\\<Esc>\\<C-V>k\\<C-X>o0\"\n  /\\%V\n  bwipe!\nendfunc\n\nfunc Test_using_invalid_visual_position()\n  \" this was going beyond the end of the line\n  new\n  exe \"norm 0o000\\<Esc>0\\<C-V>$s0\"\n  /\\%V\n  bwipe!\nendfunc\n\nfunc Test_using_two_engines_pattern()\n  new\n  call setline(1, ['foobar=0', 'foobar=1', 'foobar=2'])\n  \" \\%#= at the end of the pattern\n  for i in range(0, 2)\n    call cursor( (i+1), 7) \n    call assert_fails(\"%s/foobar\\\\%#=\" .. i, 'E1281:')\n  endfor\n\n  \" \\%#= at the start of the pattern\n  for i in range(0, 2)\n    call cursor( (i+1), 7) \n    exe \":%s/\\\\%#=\" .. i .. \"foobar=\" .. i .. \"/xx\"\n  endfor\n  call assert_equal(['xx', 'xx', 'xx'], getline(1, '$'))\n  bwipe!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_cmds.c: some functions for command line commands\n */\n\n#include \"vim.h\"\n#include \"version.h\"\n\n#ifdef FEAT_FLOAT\n# include <float.h>\n#endif\n\nstatic int linelen(int *has_tab);\nstatic void do_filter(linenr_T line1, linenr_T line2, exarg_T *eap, char_u *cmd, int do_in, int do_out);\nstatic int not_writing(void);\nstatic int check_readonly(int *forceit, buf_T *buf);\nstatic void delbuf_msg(char_u *name);\n\n/*\n * \":ascii\" and \"ga\".\n */\n    void\ndo_ascii(exarg_T *eap UNUSED)\n{\n    int\t\tc;\n    int\t\tcval;\n    char\tbuf1[20];\n    char\tbuf2[20];\n    char_u\tbuf3[7];\n#ifdef FEAT_DIGRAPHS\n    char_u      *dig;\n#endif\n    int\t\tcc[MAX_MCO];\n    int\t\tci = 0;\n    int\t\tlen;\n\n    if (enc_utf8)\n\tc = utfc_ptr2char(ml_get_cursor(), cc);\n    else\n\tc = gchar_cursor();\n    if (c == NUL)\n    {\n\tmsg(\"NUL\");\n\treturn;\n    }\n\n    IObuff[0] = NUL;\n    if (!has_mbyte || (enc_dbcs != 0 && c < 0x100) || c < 0x80)\n    {\n\tif (c == NL)\t    // NUL is stored as NL\n\t    c = NUL;\n\tif (c == CAR && get_fileformat(curbuf) == EOL_MAC)\n\t    cval = NL;\t    // NL is stored as CR\n\telse\n\t    cval = c;\n\tif (vim_isprintc_strict(c) && (c < ' ' || c > '~'))\n\t{\n\t    transchar_nonprint(curbuf, buf3, c);\n\t    vim_snprintf(buf1, sizeof(buf1), \"  <%s>\", (char *)buf3);\n\t}\n\telse\n\t    buf1[0] = NUL;\n\tif (c >= 0x80)\n\t    vim_snprintf(buf2, sizeof(buf2), \"  <M-%s>\",\n\t\t\t\t\t\t (char *)transchar(c & 0x7f));\n\telse\n\t    buf2[0] = NUL;\n#ifdef FEAT_DIGRAPHS\n\tdig = get_digraph_for_char(cval);\n\tif (dig != NULL)\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t_(\"<%s>%s%s  %d,  Hex %02x,  Oct %03o, Digr %s\"),\n\t\t\t      transchar(c), buf1, buf2, cval, cval, cval, dig);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t_(\"<%s>%s%s  %d,  Hex %02x,  Octal %03o\"),\n\t\t\t\t  transchar(c), buf1, buf2, cval, cval, cval);\n\tif (enc_utf8)\n\t    c = cc[ci++];\n\telse\n\t    c = 0;\n    }\n\n    // Repeat for combining characters.\n    while (has_mbyte && (c >= 0x100 || (enc_utf8 && c >= 0x80)))\n    {\n\tlen = (int)STRLEN(IObuff);\n\t// This assumes every multi-byte char is printable...\n\tif (len > 0)\n\t    IObuff[len++] = ' ';\n\tIObuff[len++] = '<';\n\tif (enc_utf8 && utf_iscomposing(c)\n#ifdef USE_GUI\n\t\t&& !gui.in_use\n#endif\n\t\t)\n\t    IObuff[len++] = ' '; // draw composing char on top of a space\n\tlen += (*mb_char2bytes)(c, IObuff + len);\n#ifdef FEAT_DIGRAPHS\n\tdig = get_digraph_for_char(c);\n\tif (dig != NULL)\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\tc < 0x10000 ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")\n\t\t\t\t    : _(\"> %d, Hex %08x, Oct %o, Digr %s\"),\n\t\t\t\t\tc, c, c, dig);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, IOSIZE - len,\n\t\t\t c < 0x10000 ? _(\"> %d, Hex %04x, Octal %o\")\n\t\t\t\t     : _(\"> %d, Hex %08x, Octal %o\"),\n\t\t\t\t     c, c, c);\n\tif (ci == MAX_MCO)\n\t    break;\n\tif (enc_utf8)\n\t    c = cc[ci++];\n\telse\n\t    c = 0;\n    }\n\n    msg((char *)IObuff);\n}\n\n/*\n * \":left\", \":center\" and \":right\": align text.\n */\n    void\nex_align(exarg_T *eap)\n{\n    pos_T\tsave_curpos;\n    int\t\tlen;\n    int\t\tindent = 0;\n    int\t\tnew_indent;\n    int\t\thas_tab;\n    int\t\twidth;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl)\n    {\n\t// switch left and right aligning\n\tif (eap->cmdidx == CMD_right)\n\t    eap->cmdidx = CMD_left;\n\telse if (eap->cmdidx == CMD_left)\n\t    eap->cmdidx = CMD_right;\n    }\n#endif\n\n    width = atoi((char *)eap->arg);\n    save_curpos = curwin->w_cursor;\n    if (eap->cmdidx == CMD_left)    // width is used for new indent\n    {\n\tif (width >= 0)\n\t    indent = width;\n    }\n    else\n    {\n\t/*\n\t * if 'textwidth' set, use it\n\t * else if 'wrapmargin' set, use it\n\t * if invalid value, use 80\n\t */\n\tif (width <= 0)\n\t    width = curbuf->b_p_tw;\n\tif (width == 0 && curbuf->b_p_wm > 0)\n\t    width = curwin->w_width - curbuf->b_p_wm;\n\tif (width <= 0)\n\t    width = 80;\n    }\n\n    if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)\n\treturn;\n\n    for (curwin->w_cursor.lnum = eap->line1;\n\t\t curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum)\n    {\n\tif (eap->cmdidx == CMD_left)\t\t// left align\n\t    new_indent = indent;\n\telse\n\t{\n\t    has_tab = FALSE;\t// avoid uninit warnings\n\t    len = linelen(eap->cmdidx == CMD_right ? &has_tab\n\t\t\t\t\t\t   : NULL) - get_indent();\n\n\t    if (len <= 0)\t\t\t// skip blank lines\n\t\tcontinue;\n\n\t    if (eap->cmdidx == CMD_center)\n\t\tnew_indent = (width - len) / 2;\n\t    else\n\t    {\n\t\tnew_indent = width - len;\t// right align\n\n\t\t/*\n\t\t * Make sure that embedded TABs don't make the text go too far\n\t\t * to the right.\n\t\t */\n\t\tif (has_tab)\n\t\t    while (new_indent > 0)\n\t\t    {\n\t\t\t(void)set_indent(new_indent, 0);\n\t\t\tif (linelen(NULL) <= width)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Now try to move the line as much as possible to\n\t\t\t     * the right.  Stop when it moves too far.\n\t\t\t     */\n\t\t\t    do\n\t\t\t\t(void)set_indent(++new_indent, 0);\n\t\t\t    while (linelen(NULL) <= width);\n\t\t\t    --new_indent;\n\t\t\t    break;\n\t\t\t}\n\t\t\t--new_indent;\n\t\t    }\n\t    }\n\t}\n\tif (new_indent < 0)\n\t    new_indent = 0;\n\t(void)set_indent(new_indent, 0);\t\t// set indent\n    }\n    changed_lines(eap->line1, 0, eap->line2 + 1, 0L);\n    curwin->w_cursor = save_curpos;\n    beginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * Get the length of the current line, excluding trailing white space.\n */\n    static int\nlinelen(int *has_tab)\n{\n    char_u  *line;\n    char_u  *first;\n    char_u  *last;\n    int\t    save;\n    int\t    len;\n\n    // Get the line.  If it's empty bail out early (could be the empty string\n    // for an unloaded buffer).\n    line = ml_get_curline();\n    if (*line == NUL)\n\treturn 0;\n\n    // find the first non-blank character\n    first = skipwhite(line);\n\n    // find the character after the last non-blank character\n    for (last = first + STRLEN(first);\n\t\t\t\tlast > first && VIM_ISWHITE(last[-1]); --last)\n\t;\n    save = *last;\n    *last = NUL;\n    len = linetabsize(line);\t\t// get line length\n    if (has_tab != NULL)\t\t// check for embedded TAB\n\t*has_tab = (vim_strchr(first, TAB) != NULL);\n    *last = save;\n\n    return len;\n}\n\n// Buffer for two lines used during sorting.  They are allocated to\n// contain the longest line being sorted.\nstatic char_u\t*sortbuf1;\nstatic char_u\t*sortbuf2;\n\nstatic int\tsort_lc;\t// sort using locale\nstatic int\tsort_ic;\t// ignore case\nstatic int\tsort_nr;\t// sort on number\nstatic int\tsort_rx;\t// sort on regex instead of skipping it\n#ifdef FEAT_FLOAT\nstatic int\tsort_flt;\t// sort on floating number\n#endif\n\nstatic int\tsort_abort;\t// flag to indicate if sorting has been interrupted\n\n// Struct to store info to be sorted.\ntypedef struct\n{\n    linenr_T\tlnum;\t\t\t// line number\n    union {\n\tstruct\n\t{\n\t    varnumber_T\tstart_col_nr;\t// starting column number\n\t    varnumber_T\tend_col_nr;\t// ending column number\n\t} line;\n\tstruct\n\t{\n\t    varnumber_T\tvalue;\t\t// value if sorting by integer\n\t    int is_number;\t\t// TRUE when line contains a number\n\t} num;\n#ifdef FEAT_FLOAT\n\tfloat_T value_flt;\t\t// value if sorting by float\n#endif\n    } st_u;\n} sorti_T;\n\n    static int\nstring_compare(const void *s1, const void *s2)\n{\n    if (sort_lc)\n\treturn strcoll((char *)s1, (char *)s2);\n    return sort_ic ? STRICMP(s1, s2) : STRCMP(s1, s2);\n}\n\n    static int\nsort_compare(const void *s1, const void *s2)\n{\n    sorti_T\tl1 = *(sorti_T *)s1;\n    sorti_T\tl2 = *(sorti_T *)s2;\n    int\t\tresult = 0;\n\n    // If the user interrupts, there's no way to stop qsort() immediately, but\n    // if we return 0 every time, qsort will assume it's done sorting and\n    // exit.\n    if (sort_abort)\n\treturn 0;\n    fast_breakcheck();\n    if (got_int)\n\tsort_abort = TRUE;\n\n    if (sort_nr)\n    {\n\tif (l1.st_u.num.is_number != l2.st_u.num.is_number)\n\t    result = l1.st_u.num.is_number - l2.st_u.num.is_number;\n\telse\n\t    result = l1.st_u.num.value == l2.st_u.num.value ? 0\n\t\t\t     : l1.st_u.num.value > l2.st_u.num.value ? 1 : -1;\n    }\n#ifdef FEAT_FLOAT\n    else if (sort_flt)\n\tresult = l1.st_u.value_flt == l2.st_u.value_flt ? 0\n\t\t\t     : l1.st_u.value_flt > l2.st_u.value_flt ? 1 : -1;\n#endif\n    else\n    {\n\t// We need to copy one line into \"sortbuf1\", because there is no\n\t// guarantee that the first pointer becomes invalid when obtaining the\n\t// second one.\n\tSTRNCPY(sortbuf1, ml_get(l1.lnum) + l1.st_u.line.start_col_nr,\n\t\t     l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr + 1);\n\tsortbuf1[l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr] = 0;\n\tSTRNCPY(sortbuf2, ml_get(l2.lnum) + l2.st_u.line.start_col_nr,\n\t\t     l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr + 1);\n\tsortbuf2[l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr] = 0;\n\n\tresult = string_compare(sortbuf1, sortbuf2);\n    }\n\n    // If two lines have the same value, preserve the original line order.\n    if (result == 0)\n\treturn (int)(l1.lnum - l2.lnum);\n    return result;\n}\n\n/*\n * \":sort\".\n */\n    void\nex_sort(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    int\t\tlen;\n    linenr_T\tlnum;\n    long\tmaxlen = 0;\n    sorti_T\t*nrs;\n    size_t\tcount = (size_t)(eap->line2 - eap->line1 + 1);\n    size_t\ti;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*s2;\n    char_u\tc;\t\t\t// temporary character storage\n    int\t\tunique = FALSE;\n    long\tdeleted;\n    colnr_T\tstart_col;\n    colnr_T\tend_col;\n    int\t\tsort_what = 0;\n    int\t\tformat_found = 0;\n    int\t\tchange_occurred = FALSE; // Buffer contents changed.\n\n    // Sorting one line is really quick!\n    if (count <= 1)\n\treturn;\n\n    if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)\n\treturn;\n    sortbuf1 = NULL;\n    sortbuf2 = NULL;\n    regmatch.regprog = NULL;\n    nrs = ALLOC_MULT(sorti_T, count);\n    if (nrs == NULL)\n\tgoto sortend;\n\n    sort_abort = sort_ic = sort_lc = sort_rx = sort_nr = 0;\n#ifdef FEAT_FLOAT\n    sort_flt = 0;\n#endif\n\n    for (p = eap->arg; *p != NUL; ++p)\n    {\n\tif (VIM_ISWHITE(*p))\n\t    ;\n\telse if (*p == 'i')\n\t    sort_ic = TRUE;\n\telse if (*p == 'l')\n\t    sort_lc = TRUE;\n\telse if (*p == 'r')\n\t    sort_rx = TRUE;\n\telse if (*p == 'n')\n\t{\n\t    sort_nr = 1;\n\t    ++format_found;\n\t}\n#ifdef FEAT_FLOAT\n\telse if (*p == 'f')\n\t{\n\t    sort_flt = 1;\n\t    ++format_found;\n\t}\n#endif\n\telse if (*p == 'b')\n\t{\n\t    sort_what = STR2NR_BIN + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'o')\n\t{\n\t    sort_what = STR2NR_OCT + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'x')\n\t{\n\t    sort_what = STR2NR_HEX + STR2NR_FORCE;\n\t    ++format_found;\n\t}\n\telse if (*p == 'u')\n\t    unique = TRUE;\n\telse if (*p == '\"')\t// comment start\n\t    break;\n\telse if (eap->nextcmd == NULL && check_nextcmd(p) != NULL)\n\t{\n\t    eap->nextcmd = check_nextcmd(p);\n\t    break;\n\t}\n\telse if (!ASCII_ISALPHA(*p) && regmatch.regprog == NULL)\n\t{\n\t    s = skip_regexp_err(p + 1, *p, TRUE);\n\t    if (s == NULL)\n\t\tgoto sortend;\n\t    *s = NUL;\n\t    // Use last search pattern if sort pattern is empty.\n\t    if (s == p + 1)\n\t    {\n\t\tif (last_search_pat() == NULL)\n\t\t{\n\t\t    emsg(_(e_no_previous_regular_expression));\n\t\t    goto sortend;\n\t\t}\n\t\tregmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);\n\t    }\n\t    else\n\t\tregmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);\n\t    if (regmatch.regprog == NULL)\n\t\tgoto sortend;\n\t    p = s;\t\t// continue after the regexp\n\t    regmatch.rm_ic = p_ic;\n\t}\n\telse\n\t{\n\t    semsg(_(e_invalid_argument_str), p);\n\t    goto sortend;\n\t}\n    }\n\n    // Can only have one of 'n', 'b', 'o' and 'x'.\n    if (format_found > 1)\n    {\n\temsg(_(e_invalid_argument));\n\tgoto sortend;\n    }\n\n    // From here on \"sort_nr\" is used as a flag for any integer number\n    // sorting.\n    sort_nr += sort_what;\n\n    /*\n     * Make an array with all line numbers.  This avoids having to copy all\n     * the lines into allocated memory.\n     * When sorting on strings \"start_col_nr\" is the offset in the line, for\n     * numbers sorting it's the number to sort on.  This means the pattern\n     * matching and number conversion only has to be done once per line.\n     * Also get the longest line length for allocating \"sortbuf\".\n     */\n    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)\n    {\n\ts = ml_get(lnum);\n\tlen = (int)STRLEN(s);\n\tif (maxlen < len)\n\t    maxlen = len;\n\n\tstart_col = 0;\n\tend_col = len;\n\tif (regmatch.regprog != NULL && vim_regexec(&regmatch, s, 0))\n\t{\n\t    if (sort_rx)\n\t    {\n\t\tstart_col = (colnr_T)(regmatch.startp[0] - s);\n\t\tend_col = (colnr_T)(regmatch.endp[0] - s);\n\t    }\n\t    else\n\t\tstart_col = (colnr_T)(regmatch.endp[0] - s);\n\t}\n\telse\n\t    if (regmatch.regprog != NULL)\n\t\tend_col = 0;\n\n\tif (sort_nr\n#ifdef FEAT_FLOAT\n\t\t|| sort_flt\n#endif\n\t\t)\n\t{\n\t    // Make sure vim_str2nr doesn't read any digits past the end\n\t    // of the match, by temporarily terminating the string there\n\t    s2 = s + end_col;\n\t    c = *s2;\n\t    *s2 = NUL;\n\t    // Sorting on number: Store the number itself.\n\t    p = s + start_col;\n\t    if (sort_nr)\n\t    {\n\t\tif (sort_what & STR2NR_HEX)\n\t\t    s = skiptohex(p);\n\t\telse if (sort_what & STR2NR_BIN)\n\t\t    s = skiptobin(p);\n\t\telse\n\t\t    s = skiptodigit(p);\n\t\tif (s > p && s[-1] == '-')\n\t\t    --s;  // include preceding negative sign\n\t\tif (*s == NUL)\n\t\t{\n\t\t    // line without number should sort before any number\n\t\t    nrs[lnum - eap->line1].st_u.num.is_number = FALSE;\n\t\t    nrs[lnum - eap->line1].st_u.num.value = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    nrs[lnum - eap->line1].st_u.num.is_number = TRUE;\n\t\t    vim_str2nr(s, NULL, NULL, sort_what,\n\t\t\t&nrs[lnum - eap->line1].st_u.num.value,\n\t\t\tNULL, 0, FALSE);\n\t\t}\n\t    }\n#ifdef FEAT_FLOAT\n\t    else\n\t    {\n\t\ts = skipwhite(p);\n\t\tif (*s == '+')\n\t\t    s = skipwhite(s + 1);\n\n\t\tif (*s == NUL)\n\t\t    // empty line should sort before any number\n\t\t    nrs[lnum - eap->line1].st_u.value_flt = -DBL_MAX;\n\t\telse\n\t\t    nrs[lnum - eap->line1].st_u.value_flt =\n\t\t\t\t\t\t      strtod((char *)s, NULL);\n\t    }\n#endif\n\t    *s2 = c;\n\t}\n\telse\n\t{\n\t    // Store the column to sort at.\n\t    nrs[lnum - eap->line1].st_u.line.start_col_nr = start_col;\n\t    nrs[lnum - eap->line1].st_u.line.end_col_nr = end_col;\n\t}\n\n\tnrs[lnum - eap->line1].lnum = lnum;\n\n\tif (regmatch.regprog != NULL)\n\t    fast_breakcheck();\n\tif (got_int)\n\t    goto sortend;\n    }\n\n    // Allocate a buffer that can hold the longest line.\n    sortbuf1 = alloc(maxlen + 1);\n    if (sortbuf1 == NULL)\n\tgoto sortend;\n    sortbuf2 = alloc(maxlen + 1);\n    if (sortbuf2 == NULL)\n\tgoto sortend;\n\n    // Sort the array of line numbers.  Note: can't be interrupted!\n    qsort((void *)nrs, count, sizeof(sorti_T), sort_compare);\n\n    if (sort_abort)\n\tgoto sortend;\n\n    // Insert the lines in the sorted order below the last one.\n    lnum = eap->line2;\n    for (i = 0; i < count; ++i)\n    {\n\tlinenr_T get_lnum = nrs[eap->forceit ? count - i - 1 : i].lnum;\n\n\t// If the original line number of the line being placed is not the same\n\t// as \"lnum\" (accounting for offset), we know that the buffer changed.\n\tif (get_lnum + ((linenr_T)count - 1) != lnum)\n\t    change_occurred = TRUE;\n\n\ts = ml_get(get_lnum);\n\tif (!unique || i == 0 || string_compare(s, sortbuf1) != 0)\n\t{\n\t    // Copy the line into a buffer, it may become invalid in\n\t    // ml_append(). And it's needed for \"unique\".\n\t    STRCPY(sortbuf1, s);\n\t    if (ml_append(lnum++, sortbuf1, (colnr_T)0, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\tfast_breakcheck();\n\tif (got_int)\n\t    goto sortend;\n    }\n\n    // delete the original lines if appending worked\n    if (i == count)\n\tfor (i = 0; i < count; ++i)\n\t    ml_delete(eap->line1);\n    else\n\tcount = 0;\n\n    // Adjust marks for deleted (or added) lines and prepare for displaying.\n    deleted = (long)(count - (lnum - eap->line2));\n    if (deleted > 0)\n    {\n\tmark_adjust(eap->line2 - deleted, eap->line2, (long)MAXLNUM, -deleted);\n\tmsgmore(-deleted);\n    }\n    else if (deleted < 0)\n\tmark_adjust(eap->line2, MAXLNUM, -deleted, 0L);\n\n    if (change_occurred || deleted != 0)\n\tchanged_lines(eap->line1, 0, eap->line2 + 1, -deleted);\n\n    curwin->w_cursor.lnum = eap->line1;\n    beginline(BL_WHITE | BL_FIX);\n\nsortend:\n    vim_free(nrs);\n    vim_free(sortbuf1);\n    vim_free(sortbuf2);\n    vim_regfree(regmatch.regprog);\n    if (got_int)\n\temsg(_(e_interrupted));\n}\n\n/*\n * :move command - move lines line1-line2 to line dest\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_move(linenr_T line1, linenr_T line2, linenr_T dest)\n{\n    char_u\t*str;\n    linenr_T\tl;\n    linenr_T\textra;\t    // Num lines added before line1\n    linenr_T\tnum_lines;  // Num lines moved\n    linenr_T\tlast_line;  // Last line in file after adding new text\n#ifdef FEAT_FOLDING\n    win_T\t*win;\n    tabpage_T\t*tp;\n#endif\n\n    if (dest >= line1 && dest < line2)\n    {\n\temsg(_(e_cannot_move_range_of_lines_into_itself));\n\treturn FAIL;\n    }\n\n    // Do nothing if we are not actually moving any lines.  This will prevent\n    // the 'modified' flag from being set without cause.\n    if (dest == line1 - 1 || dest == line2)\n    {\n\t// Move the cursor as if lines were moved (see below) to be backwards\n\t// compatible.\n\tif (dest >= line1)\n\t    curwin->w_cursor.lnum = dest;\n\telse\n\t    curwin->w_cursor.lnum = dest + (line2 - line1) + 1;\n\n\treturn OK;\n    }\n\n    num_lines = line2 - line1 + 1;\n\n    /*\n     * First we copy the old text to its new location -- webb\n     * Also copy the flag that \":global\" command uses.\n     */\n    if (u_save(dest, dest + 1) == FAIL)\n\treturn FAIL;\n    for (extra = 0, l = line1; l <= line2; l++)\n    {\n\tstr = vim_strsave(ml_get(l + extra));\n\tif (str != NULL)\n\t{\n\t    ml_append(dest + l - line1, str, (colnr_T)0, FALSE);\n\t    vim_free(str);\n\t    if (dest < line1)\n\t\textra++;\n\t}\n    }\n\n    /*\n     * Now we must be careful adjusting our marks so that we don't overlap our\n     * mark_adjust() calls.\n     *\n     * We adjust the marks within the old text so that they refer to the\n     * last lines of the file (temporarily), because we know no other marks\n     * will be set there since these line numbers did not exist until we added\n     * our new lines.\n     *\n     * Then we adjust the marks on lines between the old and new text positions\n     * (either forwards or backwards).\n     *\n     * And Finally we adjust the marks we put at the end of the file back to\n     * their final destination at the new text position -- webb\n     */\n    last_line = curbuf->b_ml.ml_line_count;\n    mark_adjust_nofold(line1, line2, last_line - line2, 0L);\n    if (dest >= line2)\n    {\n\tmark_adjust_nofold(line2 + 1, dest, -num_lines, 0L);\n#ifdef FEAT_FOLDING\n\tFOR_ALL_TAB_WINDOWS(tp, win) {\n\t    if (win->w_buffer == curbuf)\n\t\tfoldMoveRange(&win->w_folds, line1, line2, dest);\n\t}\n#endif\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    curbuf->b_op_start.lnum = dest - num_lines + 1;\n\t    curbuf->b_op_end.lnum = dest;\n\t}\n    }\n    else\n    {\n\tmark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L);\n#ifdef FEAT_FOLDING\n\tFOR_ALL_TAB_WINDOWS(tp, win) {\n\t    if (win->w_buffer == curbuf)\n\t\tfoldMoveRange(&win->w_folds, dest + 1, line1 - 1, line2);\n\t}\n#endif\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    curbuf->b_op_start.lnum = dest + 1;\n\t    curbuf->b_op_end.lnum = dest + num_lines;\n\t}\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    mark_adjust_nofold(last_line - num_lines + 1, last_line,\n\t\t\t\t\t     -(last_line - dest - extra), 0L);\n\n    /*\n     * Now we delete the original text -- webb\n     */\n    if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL)\n\treturn FAIL;\n\n    for (l = line1; l <= line2; l++)\n\tml_delete_flags(line1 + extra, ML_DEL_MESSAGE);\n\n    if (!global_busy && num_lines > p_report)\n\tsmsg(NGETTEXT(\"%ld line moved\", \"%ld lines moved\", num_lines),\n\t\t\t(long)num_lines);\n\n    /*\n     * Leave the cursor on the last of the moved lines.\n     */\n    if (dest >= line1)\n\tcurwin->w_cursor.lnum = dest;\n    else\n\tcurwin->w_cursor.lnum = dest + (line2 - line1) + 1;\n\n    if (line1 < dest)\n    {\n\tdest += num_lines + 1;\n\tlast_line = curbuf->b_ml.ml_line_count;\n\tif (dest > last_line + 1)\n\t    dest = last_line + 1;\n\tchanged_lines(line1, 0, dest, 0L);\n    }\n    else\n\tchanged_lines(dest + 1, 0, line1 + num_lines, 0L);\n\n    return OK;\n}\n\n/*\n * \":copy\"\n */\n    void\nex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin->w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\t// need to use vim_strsave() because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n\n    msgmore((long)count);\n}\n\nstatic char_u\t*prevcmd = NULL;\t// the previous command\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_prev_shellcmd(void)\n{\n    vim_free(prevcmd);\n}\n#endif\n\n/*\n * Handle the \":!cmd\" command.\tAlso for \":r !cmd\" and \":w !cmd\"\n * Bangs in the argument are replaced with the previously entered command.\n * Remember the argument.\n */\n    void\ndo_bang(\n    int\t\taddr_count,\n    exarg_T\t*eap,\n    int\t\tforceit,\n    int\t\tdo_in,\n    int\t\tdo_out)\n{\n    char_u\t\t*arg = eap->arg;\t// command\n    linenr_T\t\tline1 = eap->line1;\t// start of range\n    linenr_T\t\tline2 = eap->line2;\t// end of range\n    char_u\t\t*newcmd = NULL;\t\t// the new command\n    int\t\t\tfree_newcmd = FALSE;    // need to free() newcmd\n    int\t\t\tins_prevcmd;\n    char_u\t\t*t;\n    char_u\t\t*p;\n    char_u\t\t*trailarg;\n    int\t\t\tlen;\n    int\t\t\tscroll_save = msg_scroll;\n\n    /*\n     * Disallow shell commands for \"rvim\".\n     * Disallow shell commands from .exrc and .vimrc in current directory for\n     * security reasons.\n     */\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (addr_count == 0)\t\t// :!\n    {\n\tmsg_scroll = FALSE;\t    // don't scroll here\n\tautowrite_all();\n\tmsg_scroll = scroll_save;\n    }\n\n    /*\n     * Try to find an embedded bang, like in :!<cmd> ! [args]\n     * (:!! is indicated by the 'forceit' variable)\n     */\n    ins_prevcmd = forceit;\n    trailarg = arg;\n    do\n    {\n\tlen = (int)STRLEN(trailarg) + 1;\n\tif (newcmd != NULL)\n\t    len += (int)STRLEN(newcmd);\n\tif (ins_prevcmd)\n\t{\n\t    if (prevcmd == NULL)\n\t    {\n\t\temsg(_(e_no_previous_command));\n\t\tvim_free(newcmd);\n\t\treturn;\n\t    }\n\t    len += (int)STRLEN(prevcmd);\n\t}\n\tif ((t = alloc(len)) == NULL)\n\t{\n\t    vim_free(newcmd);\n\t    return;\n\t}\n\t*t = NUL;\n\tif (newcmd != NULL)\n\t    STRCAT(t, newcmd);\n\tif (ins_prevcmd)\n\t    STRCAT(t, prevcmd);\n\tp = t + STRLEN(t);\n\tSTRCAT(t, trailarg);\n\tvim_free(newcmd);\n\tnewcmd = t;\n\n\t/*\n\t * Scan the rest of the argument for '!', which is replaced by the\n\t * previous command.  \"\\!\" is replaced by \"!\" (this is vi compatible).\n\t */\n\ttrailarg = NULL;\n\twhile (*p)\n\t{\n\t    if (*p == '!')\n\t    {\n\t\tif (p > newcmd && p[-1] == '\\\\')\n\t\t    STRMOVE(p - 1, p);\n\t\telse\n\t\t{\n\t\t    trailarg = p;\n\t\t    *trailarg++ = NUL;\n\t\t    ins_prevcmd = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t    ++p;\n\t}\n    } while (trailarg != NULL);\n\n    vim_free(prevcmd);\n    prevcmd = newcmd;\n\n    if (bangredo)\t    // put cmd in redo buffer for ! command\n    {\n\t// If % or # appears in the command, it must have been escaped.\n\t// Reescape them, so that redoing them does not substitute them by the\n\t// buffername.\n\tchar_u *cmd = vim_strsave_escaped(prevcmd, (char_u *)\"%#\");\n\n\tif (cmd != NULL)\n\t{\n\t    AppendToRedobuffLit(cmd, -1);\n\t    vim_free(cmd);\n\t}\n\telse\n\t    AppendToRedobuffLit(prevcmd, -1);\n\tAppendToRedobuff((char_u *)\"\\n\");\n\tbangredo = FALSE;\n    }\n    /*\n     * Add quotes around the command, for shells that need them.\n     */\n    if (*p_shq != NUL)\n    {\n\tnewcmd = alloc(STRLEN(prevcmd) + 2 * STRLEN(p_shq) + 1);\n\tif (newcmd == NULL)\n\t    return;\n\tSTRCPY(newcmd, p_shq);\n\tSTRCAT(newcmd, prevcmd);\n\tSTRCAT(newcmd, p_shq);\n\tfree_newcmd = TRUE;\n    }\n    if (addr_count == 0)\t\t// :!\n    {\n\t// echo the command\n\tmsg_start();\n\tmsg_putchar(':');\n\tmsg_putchar('!');\n\tmsg_outtrans(newcmd);\n\tmsg_clr_eos();\n\twindgoto(msg_row, msg_col);\n\n\tdo_shell(newcmd, 0);\n    }\n    else\t\t\t\t// :range!\n    {\n\t// Careful: This may recursively call do_bang() again! (because of\n\t// autocommands)\n\tdo_filter(line1, line2, eap, newcmd, do_in, do_out);\n\tapply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, FALSE, curbuf);\n    }\n    if (free_newcmd)\n\tvim_free(newcmd);\n}\n\n/*\n * do_filter: filter lines through a command given by the user\n *\n * We mostly use temp files and the call_shell() routine here. This would\n * normally be done using pipes on a UNIX machine, but this is more portable\n * to non-unix machines. The call_shell() routine needs to be able\n * to deal with redirection somehow, and should handle things like looking\n * at the PATH env. variable, and adding reasonable extensions to the\n * command name given by the user. All reasonable versions of call_shell()\n * do this.\n * Alternatively, if on Unix and redirecting input or output, but not both,\n * and the 'shelltemp' option isn't set, use pipes.\n * We use input redirection if do_in is TRUE.\n * We use output redirection if do_out is TRUE.\n */\n    static void\ndo_filter(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    exarg_T\t*eap,\t\t// for forced 'ff' and 'fenc'\n    char_u\t*cmd,\n    int\t\tdo_in,\n    int\t\tdo_out)\n{\n    char_u\t*itmp = NULL;\n    char_u\t*otmp = NULL;\n    linenr_T\tlinecount;\n    linenr_T\tread_linecount;\n    pos_T\tcursor_save;\n    char_u\t*cmd_buf;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\tshell_flags = 0;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#ifdef FEAT_FILTERPIPE\n    int\t\tstmp = p_stmp;\n#endif\n\n    if (*cmd == NUL)\t    // no filter command\n\treturn;\n\n    // Temporarily disable lockmarks since that's needed to propagate changed\n    // regions of the buffer for foldUpdate(), linecount, etc.\n    cmdmod.cmod_flags &= ~CMOD_LOCKMARKS;\n\n    cursor_save = curwin->w_cursor;\n    linecount = line2 - line1 + 1;\n    curwin->w_cursor.lnum = line1;\n    curwin->w_cursor.col = 0;\n    changed_line_abv_curs();\n    invalidate_botline();\n\n    /*\n     * When using temp files:\n     * 1. * Form temp file names\n     * 2. * Write the lines to a temp file\n     * 3.   Run the filter command on the temp file\n     * 4. * Read the output of the command into the buffer\n     * 5. * Delete the original lines to be filtered\n     * 6. * Remove the temp files\n     *\n     * When writing the input with a pipe or when catching the output with a\n     * pipe only need to do 3.\n     */\n\n    if (do_out)\n\tshell_flags |= SHELL_DOOUT;\n\n#ifdef FEAT_FILTERPIPE\n# ifdef VIMDLL\n    if (!gui.in_use && !gui.starting)\n\tstmp = 1;   // Console mode doesn't support filterpipe.\n# endif\n\n    if (!do_in && do_out && !stmp)\n    {\n\t// Use a pipe to fetch stdout of the command, do not use a temp file.\n\tshell_flags |= SHELL_READ;\n\tcurwin->w_cursor.lnum = line2;\n    }\n    else if (do_in && !do_out && !stmp)\n    {\n\t// Use a pipe to write stdin of the command, do not use a temp file.\n\tshell_flags |= SHELL_WRITE;\n\tcurbuf->b_op_start.lnum = line1;\n\tcurbuf->b_op_end.lnum = line2;\n    }\n    else if (do_in && do_out && !stmp)\n    {\n\t// Use a pipe to write stdin and fetch stdout of the command, do not\n\t// use a temp file.\n\tshell_flags |= SHELL_READ|SHELL_WRITE;\n\tcurbuf->b_op_start.lnum = line1;\n\tcurbuf->b_op_end.lnum = line2;\n\tcurwin->w_cursor.lnum = line2;\n    }\n    else\n#endif\n\tif ((do_in && (itmp = vim_tempname('i', FALSE)) == NULL)\n\t\t|| (do_out && (otmp = vim_tempname('o', FALSE)) == NULL))\n\t{\n\t    emsg(_(e_cant_get_temp_file_name));\n\t    goto filterend;\n\t}\n\n/*\n * The writing and reading of temp files will not be shown.\n * Vi also doesn't do this and the messages are not very informative.\n */\n    ++no_wait_return;\t\t// don't call wait_return() while busy\n    if (itmp != NULL && buf_write(curbuf, itmp, NULL, line1, line2, eap,\n\t\t\t\t\t   FALSE, FALSE, FALSE, TRUE) == FAIL)\n    {\n\tmsg_putchar('\\n');\t\t// keep message from buf_write()\n\t--no_wait_return;\n#if defined(FEAT_EVAL)\n\tif (!aborting())\n#endif\n\t    (void)semsg(_(e_cant_create_file_str), itmp);\t// will call wait_return\n\tgoto filterend;\n    }\n    if (curbuf != old_curbuf)\n\tgoto filterend;\n\n    if (!do_out)\n\tmsg_putchar('\\n');\n\n    // Create the shell command in allocated memory.\n    cmd_buf = make_filter_cmd(cmd, itmp, otmp);\n    if (cmd_buf == NULL)\n\tgoto filterend;\n\n    windgoto((int)Rows - 1, 0);\n    cursor_on();\n\n    /*\n     * When not redirecting the output the command can write anything to the\n     * screen. If 'shellredir' is equal to \">\", screen may be messed up by\n     * stderr output of external command. Clear the screen later.\n     * If do_in is FALSE, this could be something like \":r !cat\", which may\n     * also mess up the screen, clear it later.\n     */\n    if (!do_out || STRCMP(p_srr, \">\") == 0 || !do_in)\n\tredraw_later_clear();\n\n    if (do_out)\n    {\n\tif (u_save(line2, (linenr_T)(line2 + 1)) == FAIL)\n\t{\n\t    vim_free(cmd_buf);\n\t    goto error;\n\t}\n\tredraw_curbuf_later(VALID);\n    }\n    read_linecount = curbuf->b_ml.ml_line_count;\n\n    /*\n     * When call_shell() fails wait_return() is called to give the user a\n     * chance to read the error messages. Otherwise errors are ignored, so you\n     * can see the error messages from the command that appear on stdout; use\n     * 'u' to fix the text\n     * Switch to cooked mode when not redirecting stdin, avoids that something\n     * like \":r !cat\" hangs.\n     * Pass on the SHELL_DOOUT flag when the output is being redirected.\n     */\n    if (call_shell(cmd_buf, SHELL_FILTER | SHELL_COOKED | shell_flags))\n    {\n\tredraw_later_clear();\n\twait_return(FALSE);\n    }\n    vim_free(cmd_buf);\n\n    did_check_timestamps = FALSE;\n    need_check_timestamps = TRUE;\n\n    // When interrupting the shell command, it may still have produced some\n    // useful output.  Reset got_int here, so that readfile() won't cancel\n    // reading.\n    ui_breakcheck();\n    got_int = FALSE;\n\n    if (do_out)\n    {\n\tif (otmp != NULL)\n\t{\n\t    if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t\t    eap, READ_FILTER) != OK)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tif (!aborting())\n#endif\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    semsg(_(e_cant_read_file_str), otmp);\n\t\t}\n\t\tgoto error;\n\t    }\n\t    if (curbuf != old_curbuf)\n\t\tgoto filterend;\n\t}\n\n\tread_linecount = curbuf->b_ml.ml_line_count - read_linecount;\n\n\tif (shell_flags & SHELL_READ)\n\t{\n\t    curbuf->b_op_start.lnum = line2 + 1;\n\t    curbuf->b_op_end.lnum = curwin->w_cursor.lnum;\n\t    appended_lines_mark(line2, read_linecount);\n\t}\n\n\tif (do_in)\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_KEEPMARKS)\n\t\t\t\t     || vim_strchr(p_cpo, CPO_REMMARK) == NULL)\n\t    {\n\t\tif (read_linecount >= linecount)\n\t\t    // move all marks from old lines to new lines\n\t\t    mark_adjust(line1, line2, linecount, 0L);\n\t\telse if (save_cmod_flags & CMOD_LOCKMARKS)\n\t\t{\n\t\t    // Move marks from the lines below the new lines down by\n\t\t    // the number of lines lost.\n\t\t    // Move marks from the lines that will be deleted to the\n\t\t    // new lines and below.\n\t\t    mark_adjust(line2 + 1, (linenr_T)MAXLNUM,\n\t\t\t\t\t       linecount - read_linecount, 0L);\n\t\t    mark_adjust(line1, line2, linecount, 0L);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // move marks from old lines to new lines, delete marks\n\t\t    // that are in deleted lines\n\t\t    mark_adjust(line1, line1 + read_linecount - 1,\n\t\t\t\t\t\t\t\tlinecount, 0L);\n\t\t    mark_adjust(line1 + read_linecount, line2, MAXLNUM, 0L);\n\t\t}\n\t    }\n\n\t    /*\n\t     * Put cursor on first filtered line for \":range!cmd\".\n\t     * Adjust '[ and '] (set by buf_write()).\n\t     */\n\t    curwin->w_cursor.lnum = line1;\n\t    del_lines(linecount, TRUE);\n\t    curbuf->b_op_start.lnum -= linecount;\t// adjust '[\n\t    curbuf->b_op_end.lnum -= linecount;\t\t// adjust ']\n\t    write_lnum_adjust(-linecount);\t\t// adjust last line\n\t\t\t\t\t\t\t// for next write\n#ifdef FEAT_FOLDING\n\t    foldUpdate(curwin, curbuf->b_op_start.lnum, curbuf->b_op_end.lnum);\n#endif\n\t}\n\telse\n\t{\n\t    /*\n\t     * Put cursor on last new line for \":r !cmd\".\n\t     */\n\t    linecount = curbuf->b_op_end.lnum - curbuf->b_op_start.lnum + 1;\n\t    curwin->w_cursor.lnum = curbuf->b_op_end.lnum;\n\t}\n\n\tbeginline(BL_WHITE | BL_FIX);\t    // cursor on first non-blank\n\t--no_wait_return;\n\n\tif (linecount > p_report)\n\t{\n\t    if (do_in)\n\t    {\n\t\tvim_snprintf(msg_buf, sizeof(msg_buf),\n\t\t\t\t    _(\"%ld lines filtered\"), (long)linecount);\n\t\tif (msg(msg_buf) && !msg_scroll)\n\t\t    // save message to display it after redraw\n\t\t    set_keep_msg((char_u *)msg_buf, 0);\n\t    }\n\t    else\n\t\tmsgmore((long)linecount);\n\t}\n    }\n    else\n    {\nerror:\n\t// put cursor back in same position for \":w !cmd\"\n\tcurwin->w_cursor = cursor_save;\n\t--no_wait_return;\n\twait_return(FALSE);\n    }\n\nfilterend:\n\n    cmdmod.cmod_flags = save_cmod_flags;\n    if (curbuf != old_curbuf)\n    {\n\t--no_wait_return;\n\temsg(_(e_filter_autocommands_must_not_change_current_buffer));\n    }\n    else if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n\n    if (itmp != NULL)\n\tmch_remove(itmp);\n    if (otmp != NULL)\n\tmch_remove(otmp);\n    vim_free(itmp);\n    vim_free(otmp);\n}\n\n/*\n * Call a shell to execute a command.\n * When \"cmd\" is NULL start an interactive shell.\n */\n    void\ndo_shell(\n    char_u\t*cmd,\n    int\t\tflags)\t// may be SHELL_DOOUT when output is redirected\n{\n    buf_T\t*buf;\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n    int\t\tsave_nwr;\n#endif\n#ifdef MSWIN\n    int\t\twinstart = FALSE;\n#endif\n    int\t\tkeep_termcap = !termcap_active;\n\n    /*\n     * Disallow shell commands for \"rvim\".\n     * Disallow shell commands from .exrc and .vimrc in current directory for\n     * security reasons.\n     */\n    if (check_restricted() || check_secure())\n    {\n\tmsg_end();\n\treturn;\n    }\n\n#ifdef MSWIN\n    /*\n     * Check if \":!start\" is used.  This implies not stopping termcap mode.\n     */\n    if (cmd != NULL)\n\tkeep_termcap = winstart = (STRNICMP(cmd, \"start \", 6) == 0);\n\n# if defined(FEAT_GUI) && defined(FEAT_TERMINAL)\n    // Don't stop termcap mode when using a terminal window for the shell.\n    if (gui.in_use && vim_strchr(p_go, GO_TERMINAL) != NULL)\n\tkeep_termcap = TRUE;\n# endif\n#endif\n\n    /*\n     * For autocommands we want to get the output on the current screen, to\n     * avoid having to type return below.\n     */\n    msg_putchar('\\r');\t\t\t// put cursor at start of line\n    if (!autocmd_busy)\n    {\n\tif (!keep_termcap)\n\t    stoptermcap();\n    }\n#ifdef MSWIN\n    if (!winstart)\n#endif\n\tmsg_putchar('\\n');\t\t// may shift screen one line up\n\n    // warning message before calling the shell\n    if (p_warn && !autocmd_busy && msg_silent == 0)\n\tFOR_ALL_BUFFERS(buf)\n\t    if (bufIsChangedNotTerm(buf))\n\t    {\n#ifdef FEAT_GUI_MSWIN\n\t\tif (!keep_termcap)\n\t\t    starttermcap();\t// don't want a message box here\n#endif\n\t\tmsg_puts(_(\"[No write since last change]\\n\"));\n#ifdef FEAT_GUI_MSWIN\n\t\tif (!keep_termcap)\n\t\t    stoptermcap();\n#endif\n\t\tbreak;\n\t    }\n\n    // This windgoto is required for when the '\\n' resulted in a \"delete line\n    // 1\" command to the terminal.\n    if (!swapping_screen())\n\twindgoto(msg_row, msg_col);\n    cursor_on();\n    (void)call_shell(cmd, SHELL_COOKED | flags);\n    did_check_timestamps = FALSE;\n    need_check_timestamps = TRUE;\n\n    /*\n     * put the message cursor at the end of the screen, avoids wait_return()\n     * to overwrite the text that the external command showed\n     */\n    if (!swapping_screen())\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\n    }\n\n    if (autocmd_busy)\n    {\n\tif (msg_silent == 0)\n\t    redraw_later_clear();\n    }\n    else\n    {\n\t/*\n\t * For \":sh\" there is no need to call wait_return(), just redraw.\n\t * Also for the Win32 GUI (the output is in a console window).\n\t * Otherwise there is probably text on the screen that the user wants\n\t * to read before redrawing, so call wait_return().\n\t */\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t{\n\t    if (cmd == NULL\n# ifdef MSWIN\n\t\t    || (keep_termcap && !need_wait_return)\n# endif\n\t       )\n\t    {\n\t\tif (msg_silent == 0)\n\t\t    redraw_later_clear();\n\t\tneed_wait_return = FALSE;\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * If we switch screens when starttermcap() is called, we\n\t\t * really want to wait for \"hit return to continue\".\n\t\t */\n\t\tsave_nwr = no_wait_return;\n\t\tif (swapping_screen())\n\t\t    no_wait_return = FALSE;\n# ifdef AMIGA\n\t\twait_return(term_console ? -1 : msg_silent == 0); // see below\n# else\n\t\twait_return(msg_silent == 0);\n# endif\n\t\tno_wait_return = save_nwr;\n\t    }\n\t}\n#endif // FEAT_GUI_MSWIN\n\n\tif (!keep_termcap)\t// if keep_termcap is TRUE didn't stop termcap\n\t    starttermcap();\t// start termcap if not done by wait_return()\n\n\t/*\n\t * In an Amiga window redrawing is caused by asking the window size.\n\t * If we got an interrupt this will not work. The chance that the\n\t * window size is wrong is very small, but we need to redraw the\n\t * screen.  Don't do this if ':' hit in wait_return().\tTHIS IS UGLY\n\t * but it saves an extra redraw.\n\t */\n#ifdef AMIGA\n\tif (skip_redraw)\t\t// ':' hit in wait_return()\n\t{\n\t    if (msg_silent == 0)\n\t\tredraw_later_clear();\n\t}\n\telse if (term_console)\n\t{\n\t    OUT_STR(\"\\033[0 q\");\t// get window size\n\t    if (got_int && msg_silent == 0)\n\t\tredraw_later_clear();\t// if got_int is TRUE, redraw needed\n\t    else\n\t\tmust_redraw = 0;\t// no extra redraw needed\n\t}\n#endif\n    }\n\n    // display any error messages now\n    display_errors();\n\n    apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, FALSE, curbuf);\n}\n\n#if !defined(UNIX)\n    static char_u *\nfind_pipe(char_u *cmd)\n{\n    char_u  *p;\n    int\t    inquote = FALSE;\n\n    for (p = cmd; *p != NUL; ++p)\n    {\n\tif (!inquote && *p == '|')\n\t    return p;\n\tif (*p == '\"')\n\t    inquote = !inquote;\n\telse if (rem_backslash(p))\n\t    ++p;\n    }\n    return NULL;\n}\n#endif\n\n/*\n * Create a shell command from a command string, input redirection file and\n * output redirection file.\n * Returns an allocated string with the shell command, or NULL for failure.\n */\n    char_u *\nmake_filter_cmd(\n    char_u\t*cmd,\t\t// command\n    char_u\t*itmp,\t\t// NULL or name of input file\n    char_u\t*otmp)\t\t// NULL or name of output file\n{\n    char_u\t*buf;\n    long_u\tlen;\n\n#if defined(UNIX)\n    int\t\tis_fish_shell;\n    char_u\t*shell_name = get_isolated_shell_name();\n\n    if (shell_name == NULL)\n\treturn NULL;\n\n    // Account for fish's different syntax for subshells\n    is_fish_shell = (fnamecmp(shell_name, \"fish\") == 0);\n    vim_free(shell_name);\n    if (is_fish_shell)\n\tlen = (long_u)STRLEN(cmd) + 13;\t\t// \"begin; \" + \"; end\" + NUL\n    else\n#endif\n\tlen = (long_u)STRLEN(cmd) + 3;\t\t\t// \"()\" + NUL\n    if (itmp != NULL)\n\tlen += (long_u)STRLEN(itmp) + 9;\t\t// \" { < \" + \" } \"\n    if (otmp != NULL)\n\tlen += (long_u)STRLEN(otmp) + (long_u)STRLEN(p_srr) + 2; // \"  \"\n    buf = alloc(len);\n    if (buf == NULL)\n\treturn NULL;\n\n#if defined(UNIX)\n    /*\n     * Put braces around the command (for concatenated commands) when\n     * redirecting input and/or output.\n     */\n    if (itmp != NULL || otmp != NULL)\n    {\n\tif (is_fish_shell)\n\t    vim_snprintf((char *)buf, len, \"begin; %s; end\", (char *)cmd);\n\telse\n\t    vim_snprintf((char *)buf, len, \"(%s)\", (char *)cmd);\n    }\n    else\n\tSTRCPY(buf, cmd);\n    if (itmp != NULL)\n    {\n\tSTRCAT(buf, \" < \");\n\tSTRCAT(buf, itmp);\n    }\n#else\n    // For shells that don't understand braces around commands, at least allow\n    // the use of commands in a pipe.\n    if (*p_sxe != NUL && *p_sxq == '(')\n    {\n\tif (itmp != NULL || otmp != NULL)\n\t    vim_snprintf((char *)buf, len, \"(%s)\", (char *)cmd);\n\telse\n\t    STRCPY(buf, cmd);\n\tif (itmp != NULL)\n\t{\n\t    STRCAT(buf, \" < \");\n\t    STRCAT(buf, itmp);\n\t}\n    }\n    else\n    {\n\tSTRCPY(buf, cmd);\n\tif (itmp != NULL)\n\t{\n\t    char_u\t*p;\n\n\t    // If there is a pipe, we have to put the '<' in front of it.\n\t    // Don't do this when 'shellquote' is not empty, otherwise the\n\t    // redirection would be inside the quotes.\n\t    if (*p_shq == NUL)\n\t    {\n\t\tp = find_pipe(buf);\n\t\tif (p != NULL)\n\t\t    *p = NUL;\n\t    }\n\t    STRCAT(buf, \" <\");\t// \" < \" causes problems on Amiga\n\t    STRCAT(buf, itmp);\n\t    if (*p_shq == NUL)\n\t    {\n\t\tp = find_pipe(cmd);\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(buf, \" \");  // insert a space before the '|' for DOS\n\t\t    STRCAT(buf, p);\n\t\t}\n\t    }\n\t}\n    }\n#endif\n    if (otmp != NULL)\n\tappend_redir(buf, (int)len, p_srr, otmp);\n\n    return buf;\n}\n\n/*\n * Append output redirection for file \"fname\" to the end of string buffer\n * \"buf[buflen]\"\n * Works with the 'shellredir' and 'shellpipe' options.\n * The caller should make sure that there is enough room:\n *\tSTRLEN(opt) + STRLEN(fname) + 3\n */\n    void\nappend_redir(\n    char_u\t*buf,\n    int\t\tbuflen,\n    char_u\t*opt,\n    char_u\t*fname)\n{\n    char_u\t*p;\n    char_u\t*end;\n\n    end = buf + STRLEN(buf);\n    // find \"%s\"\n    for (p = opt; (p = vim_strchr(p, '%')) != NULL; ++p)\n    {\n\tif (p[1] == 's') // found %s\n\t    break;\n\tif (p[1] == '%') // skip %%\n\t    ++p;\n    }\n    if (p != NULL)\n    {\n#ifdef MSWIN\n\t*end++ = ' '; // not really needed? Not with sh, ksh or bash\n#endif\n\tvim_snprintf((char *)end, (size_t)(buflen - (end - buf)),\n\t\t\t\t\t\t  (char *)opt, (char *)fname);\n    }\n    else\n\tvim_snprintf((char *)end, (size_t)(buflen - (end - buf)),\n#ifdef FEAT_QUICKFIX\n\t\t\" %s %s\",\n#else\n\t\t\" %s%s\",\t// \" > %s\" causes problems on Amiga\n#endif\n\t\t(char *)opt, (char *)fname);\n}\n\n/*\n * Implementation of \":fixdel\", also used by get_stty().\n *  <BS>    resulting <Del>\n *   ^?\t\t^H\n * not ^?\t^?\n */\n    void\ndo_fixdel(exarg_T *eap UNUSED)\n{\n    char_u  *p;\n\n    p = find_termcode((char_u *)\"kb\");\n    add_termcode((char_u *)\"kD\", p != NULL\n\t    && *p == DEL ? (char_u *)CTRL_H_STR : DEL_STR, FALSE);\n}\n\n    void\nprint_line_no_prefix(\n    linenr_T\tlnum,\n    int\t\tuse_number,\n    int\t\tlist)\n{\n    char\tnumbuf[30];\n\n    if (curwin->w_p_nu || use_number)\n    {\n\tvim_snprintf(numbuf, sizeof(numbuf),\n\t\t\t\t   \"%*ld \", number_width(curwin), (long)lnum);\n\tmsg_puts_attr(numbuf, HL_ATTR(HLF_N));\t// Highlight line nrs\n    }\n    msg_prt_line(ml_get(lnum), list);\n}\n\n/*\n * Print a text line.  Also in silent mode (\"ex -s\").\n */\n    void\nprint_line(linenr_T lnum, int use_number, int list)\n{\n    int\t\tsave_silent = silent_mode;\n\n    // apply :filter /pat/\n    if (message_filtered(ml_get(lnum)))\n\treturn;\n\n    msg_start();\n    silent_mode = FALSE;\n    info_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n    print_line_no_prefix(lnum, use_number, list);\n    if (save_silent)\n    {\n\tmsg_putchar('\\n');\n\tcursor_on();\t\t// msg_start() switches it off\n\tout_flush();\n\tsilent_mode = save_silent;\n    }\n    info_message = FALSE;\n}\n\n    int\nrename_buffer(char_u *new_fname)\n{\n    char_u\t*fname, *sfname, *xfname;\n    buf_T\t*buf;\n\n    buf = curbuf;\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    // buffer changed, don't change name now\n    if (buf != curbuf)\n\treturn FAIL;\n#ifdef FEAT_EVAL\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n    /*\n     * The name of the current buffer will be changed.\n     * A new (unlisted) buffer entry needs to be made to hold the old file\n     * name, which will become the alternate file name.\n     * But don't set the alternate file name if the buffer didn't have a\n     * name.\n     */\n    fname = curbuf->b_ffname;\n    sfname = curbuf->b_sfname;\n    xfname = curbuf->b_fname;\n    curbuf->b_ffname = NULL;\n    curbuf->b_sfname = NULL;\n    if (setfname(curbuf, new_fname, NULL, TRUE) == FAIL)\n    {\n\tcurbuf->b_ffname = fname;\n\tcurbuf->b_sfname = sfname;\n\treturn FAIL;\n    }\n    curbuf->b_flags |= BF_NOTEDITED;\n    if (xfname != NULL && *xfname != NUL)\n    {\n\tbuf = buflist_new(fname, xfname, curwin->w_cursor.lnum, 0);\n\tif (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t    curwin->w_alt_fnum = buf->b_fnum;\n    }\n    vim_free(fname);\n    vim_free(sfname);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n    return OK;\n}\n\n/*\n * \":file[!] [fname]\".\n */\n    void\nex_file(exarg_T *eap)\n{\n    // \":0file\" removes the file name.  Check for illegal uses \":3file\",\n    // \"0file name\", etc.\n    if (eap->addr_count > 0\n\t    && (*eap->arg != NUL\n\t\t|| eap->line2 > 0\n\t\t|| eap->addr_count > 1))\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    if (*eap->arg != NUL || eap->addr_count == 1)\n    {\n\tif (rename_buffer(eap->arg) == FAIL)\n\t    return;\n\tredraw_tabline = TRUE;\n    }\n\n    // print file name if no argument or 'F' is not in 'shortmess'\n    if (*eap->arg == NUL || !shortmess(SHM_FILEINFO))\n\tfileinfo(FALSE, FALSE, eap->forceit);\n}\n\n/*\n * \":update\".\n */\n    void\nex_update(exarg_T *eap)\n{\n    if (curbufIsChanged())\n\t(void)do_write(eap);\n}\n\n/*\n * \":write\" and \":saveas\".\n */\n    void\nex_write(exarg_T *eap)\n{\n    if (eap->cmdidx == CMD_saveas)\n    {\n\t// :saveas does not take a range, uses all lines.\n\teap->line1 = 1;\n\teap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    if (eap->usefilter)\t\t// input lines to shell command\n\tdo_bang(1, eap, FALSE, TRUE, FALSE);\n    else\n\t(void)do_write(eap);\n}\n\n#ifdef UNIX\n    static int\ncheck_writable(char_u *fname)\n{\n    if (mch_nodetype(fname) == NODE_OTHER)\n    {\n\tsemsg(_(e_str_is_not_file_or_writable_device), fname);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * write current buffer to file 'eap->arg'\n * if 'eap->append' is TRUE, append to the file\n *\n * if *eap->arg == NUL write to current file\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_write(exarg_T *eap)\n{\n    int\t\tother;\n    char_u\t*fname = NULL;\t\t// init to shut up gcc\n    char_u\t*ffname;\n    int\t\tretval = FAIL;\n    char_u\t*free_fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\t*browse_file = NULL;\n#endif\n    buf_T\t*alt_buf = NULL;\n    int\t\tname_was_missing;\n\n    if (not_writing())\t\t// check 'write' option\n\treturn FAIL;\n\n    ffname = eap->arg;\n#ifdef FEAT_BROWSE\n    if ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)\n    {\n\tbrowse_file = do_browse(BROWSE_SAVE, (char_u *)_(\"Save As\"), ffname,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\tif (browse_file == NULL)\n\t    goto theend;\n\tffname = browse_file;\n    }\n#endif\n    if (*ffname == NUL)\n    {\n\tif (eap->cmdidx == CMD_saveas)\n\t{\n\t    emsg(_(e_argument_required));\n\t    goto theend;\n\t}\n\tother = FALSE;\n    }\n    else\n    {\n\tfname = ffname;\n\tfree_fname = fix_fname(ffname);\n\t/*\n\t * When out-of-memory, keep unexpanded file name, because we MUST be\n\t * able to write the file in this situation.\n\t */\n\tif (free_fname != NULL)\n\t    ffname = free_fname;\n\tother = otherfile(ffname);\n    }\n\n    /*\n     * If we have a new file, put its name in the list of alternate file names.\n     */\n    if (other)\n    {\n\tif (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL\n\t\t\t\t\t\t || eap->cmdidx == CMD_saveas)\n\t    alt_buf = setaltfname(ffname, fname, (linenr_T)1);\n\telse\n\t    alt_buf = buflist_findname(ffname);\n\tif (alt_buf != NULL && alt_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    // Overwriting a file that is loaded in another buffer is not a\n\t    // good idea.\n\t    emsg(_(e_file_is_loaded_in_another_buffer));\n\t    goto theend;\n\t}\n    }\n\n    /*\n     * Writing to the current file is not allowed in readonly mode\n     * and a file name is required.\n     * \"nofile\" and \"nowrite\" buffers cannot be written implicitly either.\n     */\n    if (!other && (\n#ifdef FEAT_QUICKFIX\n\t\tbt_dontwrite_msg(curbuf) ||\n#endif\n\t\tcheck_fname() == FAIL\n#ifdef UNIX\n\t\t|| check_writable(curbuf->b_ffname) == FAIL\n#endif\n\t\t|| check_readonly(&eap->forceit, curbuf)))\n\tgoto theend;\n\n    if (!other)\n    {\n\tffname = curbuf->b_ffname;\n\tfname = curbuf->b_fname;\n\t/*\n\t * Not writing the whole file is only allowed with '!'.\n\t */\n\tif (\t   (eap->line1 != 1\n\t\t    || eap->line2 != curbuf->b_ml.ml_line_count)\n\t\t&& !eap->forceit\n\t\t&& !eap->append\n\t\t&& !p_wa)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t    {\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL,\n\t\t\t       (char_u *)_(\"Write partial file?\"), 2) != VIM_YES)\n\t\t    goto theend;\n\t\teap->forceit = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\temsg(_(e_use_bang_to_write_partial_buffer));\n\t\tgoto theend;\n\t    }\n\t}\n    }\n\n    if (check_overwrite(eap, curbuf, fname, ffname, other) == OK)\n    {\n\tif (eap->cmdidx == CMD_saveas && alt_buf != NULL)\n\t{\n\t    buf_T\t*was_curbuf = curbuf;\n\n\t    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n\t    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);\n#ifdef FEAT_EVAL\n\t    if (curbuf != was_curbuf || aborting())\n#else\n\t    if (curbuf != was_curbuf)\n#endif\n\t    {\n\t\t// buffer changed, don't change name now\n\t\tretval = FAIL;\n\t\tgoto theend;\n\t    }\n\t    // Exchange the file names for the current and the alternate\n\t    // buffer.  This makes it look like we are now editing the buffer\n\t    // under the new name.  Must be done before buf_write(), because\n\t    // if there is no file name and 'cpo' contains 'F', it will set\n\t    // the file name.\n\t    fname = alt_buf->b_fname;\n\t    alt_buf->b_fname = curbuf->b_fname;\n\t    curbuf->b_fname = fname;\n\t    fname = alt_buf->b_ffname;\n\t    alt_buf->b_ffname = curbuf->b_ffname;\n\t    curbuf->b_ffname = fname;\n\t    fname = alt_buf->b_sfname;\n\t    alt_buf->b_sfname = curbuf->b_sfname;\n\t    curbuf->b_sfname = fname;\n\t    buf_name_changed(curbuf);\n\n\t    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n\t    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);\n\t    if (!alt_buf->b_p_bl)\n\t    {\n\t\talt_buf->b_p_bl = TRUE;\n\t\tapply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);\n\t    }\n#ifdef FEAT_EVAL\n\t    if (curbuf != was_curbuf || aborting())\n#else\n\t    if (curbuf != was_curbuf)\n#endif\n\t    {\n\t\t// buffer changed, don't write the file\n\t\tretval = FAIL;\n\t\tgoto theend;\n\t    }\n\n\t    // If 'filetype' was empty try detecting it now.\n\t    if (*curbuf->b_p_ft == NUL)\n\t    {\n\t\tif (au_has_group((char_u *)\"filetypedetect\"))\n\t\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\",\n\t\t\t\t\t\t\t\t  TRUE, NULL);\n\t\tdo_modelines(0);\n\t    }\n\n\t    // Autocommands may have changed buffer names, esp. when\n\t    // 'autochdir' is set.\n\t    fname = curbuf->b_sfname;\n\t}\n\n\tname_was_missing = curbuf->b_ffname == NULL;\n\n\tretval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2,\n\t\t\t\t eap, eap->append, eap->forceit, TRUE, FALSE);\n\n\t// After \":saveas fname\" reset 'readonly'.\n\tif (eap->cmdidx == CMD_saveas)\n\t{\n\t    if (retval == OK)\n\t    {\n\t\tcurbuf->b_p_ro = FALSE;\n\t\tredraw_tabline = TRUE;\n\t    }\n\t}\n\n\t// Change directories when the 'acd' option is set and the file name\n\t// got changed or set.\n\tif (eap->cmdidx == CMD_saveas || name_was_missing)\n\t    DO_AUTOCHDIR;\n    }\n\ntheend:\n#ifdef FEAT_BROWSE\n    vim_free(browse_file);\n#endif\n    vim_free(free_fname);\n    return retval;\n}\n\n/*\n * Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,\n * BF_NEW or BF_READERR, check for overwriting current file.\n * May set eap->forceit if a dialog says it's OK to overwrite.\n * Return OK if it's OK, FAIL if it is not.\n */\n    int\ncheck_overwrite(\n    exarg_T\t*eap,\n    buf_T\t*buf,\n    char_u\t*fname,\t    // file name to be used (can differ from\n\t\t\t    // buf->ffname)\n    char_u\t*ffname,    // full path version of fname\n    int\t\tother)\t    // writing under other name\n{\n    /*\n     * Write to another file or b_flags set or not writing the whole file:\n     * overwriting only allowed with '!'.\n     */\n    if (       (other\n\t\t|| (buf->b_flags & BF_NOTEDITED)\n\t\t|| ((buf->b_flags & BF_NEW)\n\t\t    && vim_strchr(p_cpo, CPO_OVERNEW) == NULL)\n\t\t|| (buf->b_flags & BF_READERR))\n\t    && !p_wa\n\t    && vim_fexists(ffname))\n    {\n\tif (!eap->forceit && !eap->append)\n\t{\n#ifdef UNIX\n\t    // with UNIX it is possible to open a directory\n\t    if (mch_isdir(ffname))\n\t    {\n\t\tsemsg(_(e_str_is_directory), ffname);\n\t\treturn FAIL;\n\t    }\n#endif\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t    {\n\t\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\tdialog_msg(buff, _(\"Overwrite existing file \\\"%s\\\"?\"), fname);\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES)\n\t\t    return FAIL;\n\t\teap->forceit = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\temsg(_(e_file_exists));\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// For \":w! filename\" check that no swap file exists for \"filename\".\n\tif (other && !emsg_silent)\n\t{\n\t    char_u\t*dir;\n\t    char_u\t*p;\n\t    int\t\tr;\n\t    char_u\t*swapname;\n\n\t    // We only try the first entry in 'directory', without checking if\n\t    // it's writable.  If the \".\" directory is not writable the write\n\t    // will probably fail anyway.\n\t    // Use 'shortname' of the current buffer, since there is no buffer\n\t    // for the written file.\n\t    if (*p_dir == NUL)\n\t    {\n\t\tdir = alloc(5);\n\t\tif (dir == NULL)\n\t\t    return FAIL;\n\t\tSTRCPY(dir, \".\");\n\t    }\n\t    else\n\t    {\n\t\tdir = alloc(MAXPATHL);\n\t\tif (dir == NULL)\n\t\t    return FAIL;\n\t\tp = p_dir;\n\t\tcopy_option_part(&p, dir, MAXPATHL, \",\");\n\t    }\n\t    swapname = makeswapname(fname, ffname, curbuf, dir);\n\t    vim_free(dir);\n\t    r = vim_fexists(swapname);\n\t    if (r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t{\n\t\t    char_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\t    dialog_msg(buff,\n\t\t\t    _(\"Swap file \\\"%s\\\" exists, overwrite anyway?\"),\n\t\t\t\t\t\t\t\t    swapname);\n\t\t    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)\n\t\t\t\t\t\t\t\t   != VIM_YES)\n\t\t    {\n\t\t\tvim_free(swapname);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    eap->forceit = TRUE;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    semsg(_(e_swap_file_exists_str_silent_overrides), swapname);\n\t\t    vim_free(swapname);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    vim_free(swapname);\n\t}\n    }\n    return OK;\n}\n\n/*\n * Handle \":wnext\", \":wNext\" and \":wprevious\" commands.\n */\n    void\nex_wnext(exarg_T *eap)\n{\n    int\t\ti;\n\n    if (eap->cmd[1] == 'n')\n\ti = curwin->w_arg_idx + (int)eap->line2;\n    else\n\ti = curwin->w_arg_idx - (int)eap->line2;\n    eap->line1 = 1;\n    eap->line2 = curbuf->b_ml.ml_line_count;\n    if (do_write(eap) != FAIL)\n\tdo_argfile(eap, i);\n}\n\n/*\n * \":wall\", \":wqall\" and \":xall\": Write all changed files (and exit).\n */\n    void\ndo_wqall(exarg_T *eap)\n{\n    buf_T\t*buf;\n    int\t\terror = 0;\n    int\t\tsave_forceit = eap->forceit;\n\n    if (eap->cmdidx == CMD_xall || eap->cmdidx == CMD_wqall)\n\texiting = TRUE;\n\n    FOR_ALL_BUFFERS(buf)\n    {\n#ifdef FEAT_TERMINAL\n\tif (exiting && term_job_running(buf->b_term))\n\t{\n\t    no_write_message_nobang(buf);\n\t    ++error;\n\t}\n\telse\n#endif\n\tif (bufIsChanged(buf) && !bt_dontwrite(buf))\n\t{\n\t    /*\n\t     * Check if there is a reason the buffer cannot be written:\n\t     * 1. if the 'write' option is set\n\t     * 2. if there is no file name (even after browsing)\n\t     * 3. if the 'readonly' is set (even after a dialog)\n\t     * 4. if overwriting is allowed (even after a dialog)\n\t     */\n\t    if (not_writing())\n\t    {\n\t\t++error;\n\t\tbreak;\n\t    }\n#ifdef FEAT_BROWSE\n\t    // \":browse wall\": ask for file name if there isn't one\n\t    if (buf->b_ffname == NULL && (cmdmod.cmod_flags & CMOD_BROWSE))\n\t\tbrowse_save_fname(buf);\n#endif\n\t    if (buf->b_ffname == NULL)\n\t    {\n\t\tsemsg(_(e_no_file_name_for_buffer_nr), (long)buf->b_fnum);\n\t\t++error;\n\t    }\n\t    else if (check_readonly(&eap->forceit, buf)\n\t\t    || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,\n\t\t\t\t\t\t\t       FALSE) == FAIL)\n\t    {\n\t\t++error;\n\t    }\n\t    else\n\t    {\n\t\tbufref_T bufref;\n\n\t\tset_bufref(&bufref, buf);\n\t\tif (buf_write_all(buf, eap->forceit) == FAIL)\n\t\t    ++error;\n\t\t// an autocommand may have deleted the buffer\n\t\tif (!bufref_valid(&bufref))\n\t\t    buf = firstbuf;\n\t    }\n\t    eap->forceit = save_forceit;    // check_overwrite() may set it\n\t}\n    }\n    if (exiting)\n    {\n\tif (!error)\n\t    getout(0);\t\t// exit Vim\n\tnot_exiting();\n    }\n}\n\n/*\n * Check the 'write' option.\n * Return TRUE and give a message when it's not set.\n */\n    static int\nnot_writing(void)\n{\n    if (p_write)\n\treturn FALSE;\n    emsg(_(e_file_not_written_writing_is_disabled_by_write_option));\n    return TRUE;\n}\n\n/*\n * Check if a buffer is read-only (either 'readonly' option is set or file is\n * read-only). Ask for overruling in a dialog. Return TRUE and give an error\n * message when the buffer is readonly.\n */\n    static int\ncheck_readonly(int *forceit, buf_T *buf)\n{\n    stat_T\tst;\n\n    // Handle a file being readonly when the 'readonly' option is set or when\n    // the file exists and permissions are read-only.\n    // We will send 0777 to check_file_readonly(), as the \"perm\" variable is\n    // important for device checks but not here.\n    if (!*forceit && (buf->b_p_ro\n\t\t|| (mch_stat((char *)buf->b_ffname, &st) >= 0\n\t\t    && check_file_readonly(buf->b_ffname, 0777))))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t\t\t\t\t       && buf->b_fname != NULL)\n\t{\n\t    char_u\tbuff[DIALOG_MSG_SIZE];\n\n\t    if (buf->b_p_ro)\n\t\tdialog_msg(buff, _(\"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),\n\t\t    buf->b_fname);\n\t    else\n\t\tdialog_msg(buff, _(\"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),\n\t\t    buf->b_fname);\n\n\t    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES)\n\t    {\n\t\t// Set forceit, to force the writing of a readonly file\n\t\t*forceit = TRUE;\n\t\treturn FALSE;\n\t    }\n\t    else\n\t\treturn TRUE;\n\t}\n\telse\n#endif\n\tif (buf->b_p_ro)\n\t    emsg(_(e_readonly_option_is_set_add_bang_to_override));\n\telse\n\t    semsg(_(e_str_is_read_only_add_bang_to_override), buf->b_fname);\n\treturn TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Try to abandon the current file and edit a new or existing file.\n * \"fnum\" is the number of the file, if zero use \"ffname_arg\"/\"sfname_arg\".\n * \"lnum\" is the line number for the cursor in the new file (if non-zero).\n *\n * Return:\n * GETFILE_ERROR for \"normal\" error,\n * GETFILE_NOT_WRITTEN for \"not written\" error,\n * GETFILE_SAME_FILE for success\n * GETFILE_OPEN_OTHER for successfully opening another file.\n */\n    int\ngetfile(\n    int\t\tfnum,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tsetpm,\n    linenr_T\tlnum,\n    int\t\tforceit)\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    int\t\tother;\n    int\t\tretval;\n    char_u\t*free_me = NULL;\n\n    if (text_locked())\n\treturn GETFILE_ERROR;\n    if (curbuf_locked())\n\treturn GETFILE_ERROR;\n\n    if (fnum == 0)\n    {\n\t\t\t\t\t// make ffname full path, set sfname\n\tfname_expand(curbuf, &ffname, &sfname);\n\tother = otherfile(ffname);\n\tfree_me = ffname;\t\t// has been allocated, free() later\n    }\n    else\n\tother = (fnum != curbuf->b_fnum);\n\n    if (other)\n\t++no_wait_return;\t    // don't wait for autowrite message\n    if (other && !forceit && curbuf->b_nwindows == 1 && !buf_hide(curbuf)\n\t\t   && curbufIsChanged() && autowrite(curbuf, forceit) == FAIL)\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif (p_confirm && p_write)\n\t    dialog_changed(curbuf, FALSE);\n\tif (curbufIsChanged())\n#endif\n\t{\n\t    --no_wait_return;\n\t    no_write_message();\n\t    retval = GETFILE_NOT_WRITTEN;\t// file has been changed\n\t    goto theend;\n\t}\n    }\n    if (other)\n\t--no_wait_return;\n    if (setpm)\n\tsetpcmark();\n    if (!other)\n    {\n\tif (lnum != 0)\n\t    curwin->w_cursor.lnum = lnum;\n\tcheck_cursor_lnum();\n\tbeginline(BL_SOL | BL_FIX);\n\tretval = GETFILE_SAME_FILE;\t// it's in the same file\n    }\n    else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,\n\t     (buf_hide(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0),\n\t\tcurwin) == OK)\n\tretval = GETFILE_OPEN_OTHER;\t// opened another file\n    else\n\tretval = GETFILE_ERROR;\t\t// error encountered\n\ntheend:\n    vim_free(free_me);\n    return retval;\n}\n\n/*\n * start editing a new file\n *\n *     fnum: file number; if zero use ffname/sfname\n *   ffname: the file name\n *\t\t- full path if sfname used,\n *\t\t- any file name if sfname is NULL\n *\t\t- empty string to re-edit with the same file name (but may be\n *\t\t    in a different directory)\n *\t\t- NULL to start an empty buffer\n *   sfname: the short file name (or NULL)\n *\teap: contains the command to be executed after loading the file and\n *\t     forced 'ff' and 'fenc'\n *  newlnum: if > 0: put cursor on this line number (if possible)\n *\t     if ECMD_LASTL: use last position in loaded file\n *\t     if ECMD_LAST: use last position in all files\n *\t     if ECMD_ONE: use first line\n *    flags:\n *\t   ECMD_HIDE: if TRUE don't free the current buffer\n *     ECMD_SET_HELP: set b_help flag of (new) buffer before opening file\n *\t ECMD_OLDBUF: use existing buffer if it exists\n *\tECMD_FORCEIT: ! used for Ex command\n *\t ECMD_ADDBUF: don't edit, just add to buffer list\n *\t ECMD_ALTBUF: like ECMD_ADDBUF and also set the alternate file\n *   ECMD_NOWINENTER: Do not trigger BufWinEnter\n *   oldwin: Should be \"curwin\" when editing a new buffer in the current\n *\t     window, NULL when splitting the window first.  When not NULL info\n *\t     of the previous buffer for \"oldwin\" is stored.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndo_ecmd(\n    int\t\tfnum,\n    char_u\t*ffname,\n    char_u\t*sfname,\n    exarg_T\t*eap,\t\t\t// can be NULL!\n    linenr_T\tnewlnum,\n    int\t\tflags,\n    win_T\t*oldwin)\n{\n    int\t\tother_file;\t\t// TRUE if editing another file\n    int\t\toldbuf;\t\t\t// TRUE if using existing buffer\n    int\t\tauto_buf = FALSE;\t// TRUE if autocommands brought us\n\t\t\t\t\t// into the buffer unexpectedly\n    char_u\t*new_name = NULL;\n#if defined(FEAT_EVAL)\n    int\t\tdid_set_swapcommand = FALSE;\n#endif\n    buf_T\t*buf;\n    bufref_T\tbufref;\n    bufref_T\told_curbuf;\n    char_u\t*free_fname = NULL;\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    char_u\t*browse_file = NULL;\n#endif\n    int\t\tretval = FAIL;\n    long\tn;\n    pos_T\torig_pos;\n    linenr_T\ttopline = 0;\n    int\t\tnewcol = -1;\n    int\t\tsolcol = -1;\n    pos_T\t*pos;\n    char_u\t*command = NULL;\n#ifdef FEAT_SPELL\n    int\t\tdid_get_winopts = FALSE;\n#endif\n    int\t\treadfile_flags = 0;\n    int\t\tdid_inc_redrawing_disabled = FALSE;\n    long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn FAIL;\n#endif\n\n    if (eap != NULL)\n\tcommand = eap->do_ecmd_cmd;\n    set_bufref(&old_curbuf, curbuf);\n\n    if (fnum != 0)\n    {\n\tif (fnum == curbuf->b_fnum)\t// file is already being edited\n\t    return OK;\t\t\t// nothing to do\n\tother_file = TRUE;\n    }\n    else\n    {\n#ifdef FEAT_BROWSE\n\tif ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)\n\t{\n\t    if (\n# ifdef FEAT_GUI\n\t\t!gui.in_use &&\n# endif\n\t\t    au_has_group((char_u *)\"FileExplorer\"))\n\t    {\n\t\t// No browsing supported but we do have the file explorer:\n\t\t// Edit the directory.\n\t\tif (ffname == NULL || !mch_isdir(ffname))\n\t\t    ffname = dot_path;\n\t    }\n\t    else\n\t    {\n\t\tbrowse_file = do_browse(0, (char_u *)_(\"Edit File\"), ffname,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\t\tif (browse_file == NULL)\n\t\t    goto theend;\n\t\tffname = browse_file;\n\t    }\n\t}\n#endif\n\t// if no short name given, use ffname for short name\n\tif (sfname == NULL)\n\t    sfname = ffname;\n#ifdef USE_FNAME_CASE\n\tif (sfname != NULL)\n\t    fname_case(sfname, 0);   // set correct case for sfname\n#endif\n\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t\t\t\t\t && (ffname == NULL || *ffname == NUL))\n\t    goto theend;\n\n\tif (ffname == NULL)\n\t    other_file = TRUE;\n\t\t\t\t\t    // there is no file name\n\telse if (*ffname == NUL && curbuf->b_ffname == NULL)\n\t    other_file = FALSE;\n\telse\n\t{\n\t    if (*ffname == NUL)\t\t    // re-edit with same file name\n\t    {\n\t\tffname = curbuf->b_ffname;\n\t\tsfname = curbuf->b_fname;\n\t    }\n\t    free_fname = fix_fname(ffname); // may expand to full path name\n\t    if (free_fname != NULL)\n\t\tffname = free_fname;\n\t    other_file = otherfile(ffname);\n\t}\n    }\n\n    /*\n     * If the file was changed we may not be allowed to abandon it:\n     * - if we are going to re-edit the same file\n     * - or if we are the only window on this file and if ECMD_HIDE is FALSE\n     */\n    if (  ((!other_file && !(flags & ECMD_OLDBUF))\n\t    || (curbuf->b_nwindows == 1\n\t\t&& !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))\n\t&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t       | (other_file ? 0 : CCGD_MULTWIN)\n\t\t\t       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)\n\t\t\t       | (eap == NULL ? 0 : CCGD_EXCMD)))\n    {\n\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n    /*\n     * End Visual mode before switching to another buffer, so the text can be\n     * copied into the GUI selection buffer.\n     */\n    reset_VIsual();\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {\n\tint\tlen;\n\tchar_u\t*p;\n\n\t// Set v:swapcommand for the SwapExists autocommands.\n\tif (command != NULL)\n\t    len = (int)STRLEN(command) + 3;\n\telse\n\t    len = 30;\n\tp = alloc(len);\n\tif (p != NULL)\n\t{\n\t    if (command != NULL)\n\t\tvim_snprintf((char *)p, len, \":%s\\r\", command);\n\t    else\n\t\tvim_snprintf((char *)p, len, \"%ldG\", (long)newlnum);\n\t    set_vim_var_string(VV_SWAPCOMMAND, p, -1);\n\t    did_set_swapcommand = TRUE;\n\t    vim_free(p);\n\t}\n    }\n#endif\n\n    /*\n     * If we are starting to edit another file, open a (new) buffer.\n     * Otherwise we re-use the current buffer.\n     */\n    if (other_file)\n    {\n\tint prev_alt_fnum = curwin->w_alt_fnum;\n\n\tif (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF)))\n\t{\n\t    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\tcurwin->w_alt_fnum = curbuf->b_fnum;\n\t    if (oldwin != NULL)\n\t\tbuflist_altfpos(oldwin);\n\t}\n\n\tif (fnum)\n\t    buf = buflist_findnr(fnum);\n\telse\n\t{\n\t    if (flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n\t    {\n\t\t// Default the line number to zero to avoid that a wininfo item\n\t\t// is added for the current window.\n\t\tlinenr_T\ttlnum = 0;\n\t\tbuf_T\t\t*newbuf;\n\n\t\tif (command != NULL)\n\t\t{\n\t\t    tlnum = atol((char *)command);\n\t\t    if (tlnum <= 0)\n\t\t\ttlnum = 1L;\n\t\t}\n\t\t// Add BLN_NOCURWIN to avoid a new wininfo items are associated\n\t\t// with the current window.\n\t\tnewbuf = buflist_new(ffname, sfname, tlnum,\n\t\t\t\t\t\t    BLN_LISTED | BLN_NOCURWIN);\n\t\tif (newbuf != NULL && (flags & ECMD_ALTBUF))\n\t\t    curwin->w_alt_fnum = newbuf->b_fnum;\n\t\tgoto theend;\n\t    }\n\t    buf = buflist_new(ffname, sfname, 0L,\n\t\t    BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));\n\n\t    // autocommands may change curwin and curbuf\n\t    if (oldwin != NULL)\n\t\toldwin = curwin;\n\t    set_bufref(&old_curbuf, curbuf);\n\t}\n\tif (buf == NULL)\n\t    goto theend;\n\tif (curwin->w_alt_fnum == buf->b_fnum && prev_alt_fnum != 0)\n\t    // reusing the buffer, keep the old alternate file\n\t    curwin->w_alt_fnum = prev_alt_fnum;\n\n\tif (buf->b_ml.ml_mfp == NULL)\t\t// no memfile yet\n\t{\n\t    oldbuf = FALSE;\n\t}\n\telse\t\t\t\t\t// existing memfile\n\t{\n\t    oldbuf = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    (void)buf_check_timestamp(buf, FALSE);\n\t    // Check if autocommands made the buffer invalid or changed the\n\t    // current buffer.\n\t    if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)\n\t\tgoto theend;\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t\tgoto theend;\n#endif\n\t}\n\n\t// May jump to last used line number for a loaded buffer or when asked\n\t// for explicitly\n\tif ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)\n\t{\n\t    pos = buflist_findfpos(buf);\n\t    newlnum = pos->lnum;\n\t    solcol = pos->col;\n\t}\n\n\t/*\n\t * Make the (new) buffer the one used by the current window.\n\t * If the old buffer becomes unused, free it if ECMD_HIDE is FALSE.\n\t * If the current buffer was empty and has no file name, curbuf\n\t * is returned by buflist_new(), nothing to do here.\n\t */\n\tif (buf != curbuf)\n\t{\n\t    bufref_T\tsave_au_new_curbuf;\n#ifdef FEAT_CMDWIN\n\t    int\t\tsave_cmdwin_type = cmdwin_type;\n\n\t    // BufLeave applies to the old buffer.\n\t    cmdwin_type = 0;\n#endif\n\t    /*\n\t     * Be careful: The autocommands may delete any buffer and change\n\t     * the current buffer.\n\t     * - If the buffer we are going to edit is deleted, give up.\n\t     * - If the current buffer is deleted, prefer to load the new\n\t     *   buffer when loading a buffer is required.  This avoids\n\t     *   loading another buffer which then must be closed again.\n\t     * - If we ended up in the new buffer already, need to skip a few\n\t     *\t things, set auto_buf.\n\t     */\n\t    if (buf->b_fname != NULL)\n\t\tnew_name = vim_strsave(buf->b_fname);\n\t    save_au_new_curbuf = au_new_curbuf;\n\t    set_bufref(&au_new_curbuf, buf);\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n#ifdef FEAT_CMDWIN\n\t    cmdwin_type = save_cmdwin_type;\n#endif\n\t    if (!bufref_valid(&au_new_curbuf))\n\t    {\n\t\t// new buffer has been deleted\n\t\tdelbuf_msg(new_name);\t// frees new_name\n\t\tau_new_curbuf = save_au_new_curbuf;\n\t\tgoto theend;\n\t    }\n#ifdef FEAT_EVAL\n\t    if (aborting())\t    // autocmds may abort script processing\n\t    {\n\t\tvim_free(new_name);\n\t\tau_new_curbuf = save_au_new_curbuf;\n\t\tgoto theend;\n\t    }\n#endif\n\t    if (buf == curbuf)\t\t// already in new buffer\n\t\tauto_buf = TRUE;\n\t    else\n\t    {\n\t\twin_T\t    *the_curwin = curwin;\n\t\tint\t    did_decrement;\n\t\tbuf_T\t    *was_curbuf = curbuf;\n\n\t\t// Set the w_closing flag to avoid that autocommands close the\n\t\t// window.  And set b_locked for the same reason.\n\t\tthe_curwin->w_closing = TRUE;\n\t\t++buf->b_locked;\n\n\t\tif (curbuf == old_curbuf.br_buf)\n\t\t    buf_copy_options(buf, BCO_ENTER);\n\n\t\t// Close the link to the current buffer. This will set\n\t\t// oldwin->w_buffer to NULL.\n\t\tu_sync(FALSE);\n\t\tdid_decrement = close_buffer(oldwin, curbuf,\n\t\t\t (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);\n\n\t\t// Autocommands may have closed the window.\n\t\tif (win_valid(the_curwin))\n\t\t    the_curwin->w_closing = FALSE;\n\t\t--buf->b_locked;\n\n#ifdef FEAT_EVAL\n\t\t// autocmds may abort script processing\n\t\tif (aborting() && curwin->w_buffer != NULL)\n\t\t{\n\t\t    vim_free(new_name);\n\t\t    au_new_curbuf = save_au_new_curbuf;\n\t\t    goto theend;\n\t\t}\n#endif\n\t\t// Be careful again, like above.\n\t\tif (!bufref_valid(&au_new_curbuf))\n\t\t{\n\t\t    // new buffer has been deleted\n\t\t    delbuf_msg(new_name);\t// frees new_name\n\t\t    au_new_curbuf = save_au_new_curbuf;\n\t\t    goto theend;\n\t\t}\n\t\tif (buf == curbuf)\t\t// already in new buffer\n\t\t{\n\t\t    // close_buffer() has decremented the window count,\n\t\t    // increment it again here and restore w_buffer.\n\t\t    if (did_decrement && buf_valid(was_curbuf))\n\t\t\t++was_curbuf->b_nwindows;\n\t\t    if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)\n\t\t\toldwin->w_buffer = was_curbuf;\n\t\t    auto_buf = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_SYN_HL\n\t\t    /*\n\t\t     * <VN> We could instead free the synblock\n\t\t     * and re-attach to buffer, perhaps.\n\t\t     */\n\t\t    if (curwin->w_buffer == NULL\n\t\t\t    || curwin->w_s == &(curwin->w_buffer->b_s))\n\t\t\tcurwin->w_s = &(buf->b_s);\n#endif\n\t\t    curwin->w_buffer = buf;\n\t\t    curbuf = buf;\n\t\t    ++curbuf->b_nwindows;\n\n\t\t    // Set 'fileformat', 'binary' and 'fenc' when forced.\n\t\t    if (!oldbuf && eap != NULL)\n\t\t    {\n\t\t\tset_file_options(TRUE, eap);\n\t\t\tset_forced_fenc(eap);\n\t\t    }\n\t\t}\n\n\t\t// May get the window options from the last time this buffer\n\t\t// was in this window (or another window).  If not used\n\t\t// before, reset the local window options to the global\n\t\t// values.  Also restores old folding stuff.\n\t\tget_winopts(curbuf);\n#ifdef FEAT_SPELL\n\t\tdid_get_winopts = TRUE;\n#endif\n\t    }\n\t    vim_free(new_name);\n\t    au_new_curbuf = save_au_new_curbuf;\n\t}\n\n\tcurwin->w_pcmark.lnum = 1;\n\tcurwin->w_pcmark.col = 0;\n    }\n    else // !other_file\n    {\n\tif ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL)\n\t    goto theend;\n\n\toldbuf = (flags & ECMD_OLDBUF);\n    }\n\n    // Don't redraw until the cursor is in the right line, otherwise\n    // autocommands may cause ml_get errors.\n    ++RedrawingDisabled;\n    did_inc_redrawing_disabled = TRUE;\n\n    buf = curbuf;\n    if ((flags & ECMD_SET_HELP) || keep_help_flag)\n    {\n\tprepare_help_buffer();\n    }\n    else\n    {\n\t// Don't make a buffer listed if it's a help buffer.  Useful when\n\t// using CTRL-O to go back to a help file.\n\tif (!curbuf->b_help)\n\t    set_buflisted(TRUE);\n    }\n\n    // If autocommands change buffers under our fingers, forget about\n    // editing the file.\n    if (buf != curbuf)\n\tgoto theend;\n#ifdef FEAT_EVAL\n    if (aborting())\t    // autocmds may abort script processing\n\tgoto theend;\n#endif\n\n    // Since we are starting to edit a file, consider the filetype to be\n    // unset.  Helps for when an autocommand changes files and expects syntax\n    // highlighting to work in the other file.\n    did_filetype = FALSE;\n\n/*\n * other_file\toldbuf\n *  FALSE\tFALSE\t    re-edit same file, buffer is re-used\n *  FALSE\tTRUE\t    re-edit same file, nothing changes\n *  TRUE\tFALSE\t    start editing new file, new buffer\n *  TRUE\tTRUE\t    start editing in existing buffer (nothing to do)\n */\n    if (!other_file && !oldbuf)\t\t// re-use the buffer\n    {\n\tset_last_cursor(curwin);\t// may set b_last_cursor\n\tif (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)\n\t{\n\t    newlnum = curwin->w_cursor.lnum;\n\t    solcol = curwin->w_cursor.col;\n\t}\n\tbuf = curbuf;\n\tif (buf->b_fname != NULL)\n\t    new_name = vim_strsave(buf->b_fname);\n\telse\n\t    new_name = NULL;\n\tset_bufref(&bufref, buf);\n\n\t// If the buffer was used before, store the current contents so that\n\t// the reload can be undone.  Do not do this if the (empty) buffer is\n\t// being re-used for another file.\n\tif (!(curbuf->b_flags & BF_NEVERLOADED)\n\t\t&& (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur))\n\t{\n\t    // Sync first so that this is a separate undo-able action.\n\t    u_sync(FALSE);\n\t    if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)\n\t\t\t\t\t\t\t\t     == FAIL)\n\t    {\n\t\tvim_free(new_name);\n\t\tgoto theend;\n\t    }\n\t    u_unchanged(curbuf);\n\t    buf_freeall(curbuf, BFA_KEEP_UNDO);\n\n\t    // tell readfile() not to clear or reload undo info\n\t    readfile_flags = READ_KEEP_UNDO;\n\t}\n\telse\n\t    buf_freeall(curbuf, 0);   // free all things for buffer\n\n\t// If autocommands deleted the buffer we were going to re-edit, give\n\t// up and jump to the end.\n\tif (!bufref_valid(&bufref))\n\t{\n\t    delbuf_msg(new_name);\t// frees new_name\n\t    goto theend;\n\t}\n\tvim_free(new_name);\n\n\t// If autocommands change buffers under our fingers, forget about\n\t// re-editing the file.  Should do the buf_clear_file(), but perhaps\n\t// the autocommands changed the buffer...\n\tif (buf != curbuf)\n\t    goto theend;\n#ifdef FEAT_EVAL\n\tif (aborting())\t    // autocmds may abort script processing\n\t    goto theend;\n#endif\n\tbuf_clear_file(curbuf);\n\tcurbuf->b_op_start.lnum = 0;\t// clear '[ and '] marks\n\tcurbuf->b_op_end.lnum = 0;\n    }\n\n/*\n * If we get here we are sure to start editing\n */\n    // Assume success now\n    retval = OK;\n\n    /*\n     * Check if we are editing the w_arg_idx file in the argument list.\n     */\n    check_arg_idx(curwin);\n\n    if (!auto_buf)\n    {\n\t/*\n\t * Set cursor and init window before reading the file and executing\n\t * autocommands.  This allows for the autocommands to position the\n\t * cursor.\n\t */\n\tcurwin_init();\n\n#ifdef FEAT_FOLDING\n\t// It's possible that all lines in the buffer changed.  Need to update\n\t// automatic folding for all windows where it's used.\n\t{\n\t    win_T\t    *win;\n\t    tabpage_T\t    *tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, win)\n\t\tif (win->w_buffer == curbuf)\n\t\t    foldUpdateAll(win);\n\t}\n#endif\n\n\t// Change directories when the 'acd' option is set.\n\tDO_AUTOCHDIR;\n\n\t/*\n\t * Careful: open_buffer() and apply_autocmds() may change the current\n\t * buffer and window.\n\t */\n\torig_pos = curwin->w_cursor;\n\ttopline = curwin->w_topline;\n\tif (!oldbuf)\t\t\t    // need to read the file\n\t{\n#ifdef FEAT_PROP_POPUP\n\t    // Don't use the swap-exists dialog for a popup window, can't edit\n\t    // the buffer.\n\t    if (WIN_IS_POPUP(curwin))\n\t\tcurbuf->b_flags |= BF_NO_SEA;\n#endif\n\t    swap_exists_action = SEA_DIALOG;\n\t    curbuf->b_flags |= BF_CHECK_RO; // set/reset 'ro' flag\n\n\t    /*\n\t     * Open the buffer and read the file.\n\t     */\n\t    if (flags & ECMD_NOWINENTER)\n\t\treadfile_flags |= READ_NOWINENTER;\n#if defined(FEAT_EVAL)\n\t    if (should_abort(open_buffer(FALSE, eap, readfile_flags)))\n\t\tretval = FAIL;\n#else\n\t    (void)open_buffer(FALSE, eap, readfile_flags);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n\t    curbuf->b_flags &= ~BF_NO_SEA;\n#endif\n\t    if (swap_exists_action == SEA_QUIT)\n\t\tretval = FAIL;\n\t    handle_swap_exists(&old_curbuf);\n\t}\n\telse\n\t{\n\t    // Read the modelines, but only to set window-local options.  Any\n\t    // buffer-local options have already been set and may have been\n\t    // changed by the user.\n\t    do_modelines(OPT_WINONLY);\n\n\t    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n\t    if ((flags & ECMD_NOWINENTER) == 0)\n\t\tapply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n\t}\n\tcheck_arg_idx(curwin);\n\n\t// If autocommands change the cursor position or topline, we should\n\t// keep it.  Also when it moves within a line. But not when it moves\n\t// to the first non-blank.\n\tif (!EQUAL_POS(curwin->w_cursor, orig_pos))\n\t{\n\t    char_u *text = ml_get_curline();\n\n\t    if (curwin->w_cursor.lnum != orig_pos.lnum\n\t\t    || curwin->w_cursor.col != (int)(skipwhite(text) - text))\n\t    {\n\t\tnewlnum = curwin->w_cursor.lnum;\n\t\tnewcol = curwin->w_cursor.col;\n\t    }\n\t}\n\tif (curwin->w_topline == topline)\n\t    topline = 0;\n\n\t// Even when cursor didn't move we need to recompute topline.\n\tchanged_line_abv_curs();\n\n\tmaketitle();\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)\n\tif (WIN_IS_POPUP(curwin) && curwin->w_p_pvw && retval != FAIL)\n\t    popup_set_title(curwin);\n#endif\n    }\n\n#ifdef FEAT_DIFF\n    // Tell the diff stuff that this buffer is new and/or needs updating.\n    // Also needed when re-editing the same buffer, because unloading will\n    // have removed it as a diff buffer.\n    if (curwin->w_p_diff)\n    {\n\tdiff_buf_add(curbuf);\n\tdiff_invalidate(curbuf);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // If the window options were changed may need to set the spell language.\n    // Can only do this after the buffer has been properly setup.\n    if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)did_set_spelllang(curwin);\n#endif\n\n    if (command == NULL)\n    {\n\tif (newcol >= 0)\t// position set by autocommands\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    curwin->w_cursor.col = newcol;\n\t    check_cursor();\n\t}\n\telse if (newlnum > 0)\t// line number from caller or old position\n\t{\n\t    curwin->w_cursor.lnum = newlnum;\n\t    check_cursor_lnum();\n\t    if (solcol >= 0 && !p_sol)\n\t    {\n\t\t// 'sol' is off: Use last known column.\n\t\tcurwin->w_cursor.col = solcol;\n\t\tcheck_cursor_col();\n\t\tcurwin->w_cursor.coladd = 0;\n\t\tcurwin->w_set_curswant = TRUE;\n\t    }\n\t    else\n\t\tbeginline(BL_SOL | BL_FIX);\n\t}\n\telse\t\t\t// no line number, go to last line in Ex mode\n\t{\n\t    if (exmode_active)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n    }\n\n    // Check if cursors in other windows on the same buffer are still valid\n    check_lnums(FALSE);\n\n    /*\n     * Did not read the file, need to show some info about the file.\n     * Do this after setting the cursor.\n     */\n    if (oldbuf && !auto_buf)\n    {\n\tint\tmsg_scroll_save = msg_scroll;\n\n\t// Obey the 'O' flag in 'cpoptions': overwrite any previous file\n\t// message.\n\tif (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)\n\t    msg_scroll = FALSE;\n\tif (!msg_scroll)\t// wait a bit when overwriting an error msg\n\t    check_for_delay(FALSE);\n\tmsg_start();\n\tmsg_scroll = msg_scroll_save;\n\tmsg_scrolled_ign = TRUE;\n\n\tif (!shortmess(SHM_FILEINFO))\n\t    fileinfo(FALSE, TRUE, FALSE);\n\n\tmsg_scrolled_ign = FALSE;\n    }\n\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    if (command != NULL)\n\tdo_cmdline(command, NULL, NULL, DOCMD_VERBOSE|DOCMD_RANGEOK);\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n\n    --RedrawingDisabled;\n    did_inc_redrawing_disabled = FALSE;\n    if (!skip_redraw)\n    {\n\tn = *so_ptr;\n\tif (topline == 0 && command == NULL)\n\t    *so_ptr = 9999;\t\t// force cursor halfway the window\n\tupdate_topline();\n\tcurwin->w_scbind_pos = curwin->w_topline;\n\t*so_ptr = n;\n\tredraw_curbuf_later(NOT_VALID);\t// redraw this buffer later\n    }\n\n    if (p_im && (State & MODE_INSERT) == 0)\n\tneed_start_insertmode = TRUE;\n\n#ifdef FEAT_AUTOCHDIR\n    // Change directories when the 'acd' option is set and we aren't already in\n    // that directory (should already be done above). Expect getcwd() to be\n    // faster than calling shorten_fnames() unnecessarily.\n    if (p_acd && curbuf->b_ffname != NULL)\n    {\n\tchar_u\tcurdir[MAXPATHL];\n\tchar_u\tfiledir[MAXPATHL];\n\n\tvim_strncpy(filedir, curbuf->b_ffname, MAXPATHL - 1);\n\t*gettail_sep(filedir) = NUL;\n\tif (mch_dirname(curdir, MAXPATHL) != FAIL\n\t\t&& vim_fnamecmp(curdir, filedir) != 0)\n\t    do_autochdir();\n    }\n#endif\n\n#if defined(FEAT_NETBEANS_INTG)\n    if (curbuf->b_ffname != NULL)\n    {\n# ifdef FEAT_NETBEANS_INTG\n\tif ((flags & ECMD_SET_HELP) != ECMD_SET_HELP)\n\t    netbeans_file_opened(curbuf);\n# endif\n    }\n#endif\n\ntheend:\n    if (did_inc_redrawing_disabled)\n\t--RedrawingDisabled;\n#if defined(FEAT_EVAL)\n    if (did_set_swapcommand)\n\tset_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n#ifdef FEAT_BROWSE\n    vim_free(browse_file);\n#endif\n    vim_free(free_fname);\n    return retval;\n}\n\n    static void\ndelbuf_msg(char_u *name)\n{\n    semsg(_(e_autocommands_unexpectedly_deleted_new_buffer_str),\n\t\t\t\t\t   name == NULL ? (char_u *)\"\" : name);\n    vim_free(name);\n    au_new_curbuf.br_buf = NULL;\n    au_new_curbuf.br_buf_free_count = 0;\n}\n\nstatic int append_indent = 0;\t    // autoindent for first line\n\n/*\n * \":insert\" and \":append\", also used by \":change\"\n */\n    void\nex_append(exarg_T *eap)\n{\n    char_u\t*theline;\n    int\t\tdid_undo = FALSE;\n    linenr_T\tlnum = eap->line2;\n    int\t\tindent = 0;\n    char_u\t*p;\n    int\t\tvcol;\n    int\t\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    // the ! flag toggles autoindent\n    if (eap->forceit)\n\tcurbuf->b_p_ai = !curbuf->b_p_ai;\n\n    // First autoindent comes from the line we start on\n    if (eap->cmdidx != CMD_change && curbuf->b_p_ai && lnum > 0)\n\tappend_indent = get_indent_lnum(lnum);\n\n    if (eap->cmdidx != CMD_append)\n\t--lnum;\n\n    // when the buffer is empty need to delete the dummy line\n    if (empty && lnum == 1)\n\tlnum = 0;\n\n    State = MODE_INSERT;\t\t    // behave like in Insert mode\n    if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\tState |= MODE_LANGMAP;\n\n    for (;;)\n    {\n\tmsg_scroll = TRUE;\n\tneed_wait_return = FALSE;\n\tif (curbuf->b_p_ai)\n\t{\n\t    if (append_indent >= 0)\n\t    {\n\t\tindent = append_indent;\n\t\tappend_indent = -1;\n\t    }\n\t    else if (lnum > 0)\n\t\tindent = get_indent_lnum(lnum);\n\t}\n\tex_keep_indent = FALSE;\n\tif (eap->getline == NULL)\n\t{\n\t    // No getline() function, use the lines that follow. This ends\n\t    // when there is no more.\n\t    if (eap->nextcmd == NULL || *eap->nextcmd == NUL)\n\t\tbreak;\n\t    p = vim_strchr(eap->nextcmd, NL);\n\t    if (p == NULL)\n\t\tp = eap->nextcmd + STRLEN(eap->nextcmd);\n\t    theline = vim_strnsave(eap->nextcmd, p - eap->nextcmd);\n\t    if (*p != NUL)\n\t\t++p;\n\t    eap->nextcmd = p;\n\t}\n\telse\n\t{\n\t    int save_State = State;\n\n\t    // Set State to avoid the cursor shape to be set to MODE_INSERT\n\t    // state when getline() returns.\n\t    State = MODE_CMDLINE;\n\t    theline = eap->getline(\n#ifdef FEAT_EVAL\n\t\t    eap->cstack->cs_looplevel > 0 ? -1 :\n#endif\n\t\t    NUL, eap->cookie, indent, TRUE);\n\t    State = save_State;\n\t}\n\tlines_left = Rows - 1;\n\tif (theline == NULL)\n\t    break;\n\n\t// Using ^ CTRL-D in getexmodeline() makes us repeat the indent.\n\tif (ex_keep_indent)\n\t    append_indent = indent;\n\n\t// Look for the \".\" after automatic indent.\n\tvcol = 0;\n\tfor (p = theline; indent > vcol; ++p)\n\t{\n\t    if (*p == ' ')\n\t\t++vcol;\n\t    else if (*p == TAB)\n\t\tvcol += 8 - vcol % 8;\n\t    else\n\t\tbreak;\n\t}\n\tif ((p[0] == '.' && p[1] == NUL)\n\t\t|| (!did_undo && u_save(lnum, lnum + 1 + (empty ? 1 : 0))\n\t\t\t\t\t\t\t\t     == FAIL))\n\t{\n\t    vim_free(theline);\n\t    break;\n\t}\n\n\t// don't use autoindent if nothing was typed.\n\tif (p[0] == NUL)\n\t    theline[0] = NUL;\n\n\tdid_undo = TRUE;\n\tml_append(lnum, theline, (colnr_T)0, FALSE);\n\tif (empty)\n\t    // there are no marks below the inserted lines\n\t    appended_lines(lnum, 1L);\n\telse\n\t    appended_lines_mark(lnum, 1L);\n\n\tvim_free(theline);\n\t++lnum;\n\n\tif (empty)\n\t{\n\t    ml_delete(2L);\n\t    empty = FALSE;\n\t}\n    }\n    State = MODE_NORMAL;\n\n    if (eap->forceit)\n\tcurbuf->b_p_ai = !curbuf->b_p_ai;\n\n    // \"start\" is set to eap->line2+1 unless that position is invalid (when\n    // eap->line2 pointed to the end of the buffer and nothing was appended)\n    // \"end\" is set to lnum when something has been appended, otherwise\n    // it is the same as \"start\"  -- Acevedo\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = (eap->line2 < curbuf->b_ml.ml_line_count) ?\n\t    eap->line2 + 1 : curbuf->b_ml.ml_line_count;\n\tif (eap->cmdidx != CMD_append)\n\t    --curbuf->b_op_start.lnum;\n\tcurbuf->b_op_end.lnum = (eap->line2 < lnum)\n\t\t\t\t\t      ? lnum : curbuf->b_op_start.lnum;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n    curwin->w_cursor.lnum = lnum;\n    check_cursor_lnum();\n    beginline(BL_SOL | BL_FIX);\n\n    need_wait_return = FALSE;\t// don't use wait_return() now\n    ex_no_reprint = TRUE;\n}\n\n/*\n * \":change\"\n */\n    void\nex_change(exarg_T *eap)\n{\n    linenr_T\tlnum;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (eap->line2 >= eap->line1\n\t    && u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)\n\treturn;\n\n    // the ! flag toggles autoindent\n    if (eap->forceit ? !curbuf->b_p_ai : curbuf->b_p_ai)\n\tappend_indent = get_indent_lnum(eap->line1);\n\n    for (lnum = eap->line2; lnum >= eap->line1; --lnum)\n    {\n\tif (curbuf->b_ml.ml_flags & ML_EMPTY)\t    // nothing to delete\n\t    break;\n\tml_delete(eap->line1);\n    }\n\n    // make sure the cursor is not beyond the end of the file now\n    check_cursor_lnum();\n    deleted_lines_mark(eap->line1, (long)(eap->line2 - lnum));\n\n    // \":append\" on the line above the deleted lines.\n    eap->line2 = eap->line1;\n    ex_append(eap);\n}\n\n    void\nex_z(exarg_T *eap)\n{\n    char_u\t*x;\n    long\tbigness;\n    char_u\t*kind;\n    int\t\tminus = 0;\n    linenr_T\tstart, end, curs, i;\n    int\t\tj;\n    linenr_T\tlnum = eap->line2;\n\n    // Vi compatible: \":z!\" uses display height, without a count uses\n    // 'scroll'\n    if (eap->forceit)\n\tbigness = Rows - 1;\n    else if (!ONE_WINDOW)\n\tbigness = curwin->w_height - 3;\n    else\n\tbigness = curwin->w_p_scr * 2;\n    if (bigness < 1)\n\tbigness = 1;\n\n    x = eap->arg;\n    kind = x;\n    if (*kind == '-' || *kind == '+' || *kind == '='\n\t\t\t\t\t      || *kind == '^' || *kind == '.')\n\t++x;\n    while (*x == '-' || *x == '+')\n\t++x;\n\n    if (*x != 0)\n    {\n\tif (!VIM_ISDIGIT(*x))\n\t{\n\t    emsg(_(e_non_numeric_argument_to_z));\n\t    return;\n\t}\n\telse\n\t{\n\t    bigness = atol((char *)x);\n\n\t    // bigness could be < 0 if atol(x) overflows.\n\t    if (bigness > 2 * curbuf->b_ml.ml_line_count || bigness < 0)\n\t\tbigness = 2 * curbuf->b_ml.ml_line_count;\n\n\t    p_window = bigness;\n\t    if (*kind == '=')\n\t\tbigness += 2;\n\t}\n    }\n\n    // the number of '-' and '+' multiplies the distance\n    if (*kind == '-' || *kind == '+')\n\tfor (x = kind + 1; *x == *kind; ++x)\n\t    ;\n\n    switch (*kind)\n    {\n\tcase '-':\n\t    start = lnum - bigness * (linenr_T)(x - kind) + 1;\n\t    end = start + bigness - 1;\n\t    curs = end;\n\t    break;\n\n\tcase '=':\n\t    start = lnum - (bigness + 1) / 2 + 1;\n\t    end = lnum + (bigness + 1) / 2 - 1;\n\t    curs = lnum;\n\t    minus = 1;\n\t    break;\n\n\tcase '^':\n\t    start = lnum - bigness * 2;\n\t    end = lnum - bigness;\n\t    curs = lnum - bigness;\n\t    break;\n\n\tcase '.':\n\t    start = lnum - (bigness + 1) / 2 + 1;\n\t    end = lnum + (bigness + 1) / 2 - 1;\n\t    curs = end;\n\t    break;\n\n\tdefault:  // '+'\n\t    start = lnum;\n\t    if (*kind == '+')\n\t\tstart += bigness * (linenr_T)(x - kind - 1) + 1;\n\t    else if (eap->addr_count == 0)\n\t\t++start;\n\t    end = start + bigness - 1;\n\t    curs = end;\n\t    break;\n    }\n\n    if (start < 1)\n\tstart = 1;\n\n    if (end > curbuf->b_ml.ml_line_count)\n\tend = curbuf->b_ml.ml_line_count;\n\n    if (curs > curbuf->b_ml.ml_line_count)\n\tcurs = curbuf->b_ml.ml_line_count;\n    else if (curs < 1)\n\tcurs = 1;\n\n    for (i = start; i <= end; i++)\n    {\n\tif (minus && i == lnum)\n\t{\n\t    msg_putchar('\\n');\n\n\t    for (j = 1; j < Columns; j++)\n\t\tmsg_putchar('-');\n\t}\n\n\tprint_line(i, eap->flags & EXFLAG_NR, eap->flags & EXFLAG_LIST);\n\n\tif (minus && i == lnum)\n\t{\n\t    msg_putchar('\\n');\n\n\t    for (j = 1; j < Columns; j++)\n\t\tmsg_putchar('-');\n\t}\n    }\n\n    if (curwin->w_cursor.lnum != curs)\n    {\n\tcurwin->w_cursor.lnum = curs;\n\tcurwin->w_cursor.col = 0;\n    }\n    ex_no_reprint = TRUE;\n}\n\n/*\n * Check if the restricted flag is set.\n * If so, give an error message and return TRUE.\n * Otherwise, return FALSE.\n */\n    int\ncheck_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(e_shell_commands_and_some_functionality_not_allowed_in_rvim));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check if the secure flag is set (.exrc or .vimrc in current directory).\n * If so, give an error message and return TRUE.\n * Otherwise, return FALSE.\n */\n    int\ncheck_secure(void)\n{\n    if (secure)\n    {\n\tsecure = 2;\n\temsg(_(e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search));\n\treturn TRUE;\n    }\n#ifdef HAVE_SANDBOX\n    /*\n     * In the sandbox more things are not allowed, including the things\n     * disallowed in secure mode.\n     */\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn TRUE;\n    }\n#endif\n    return FALSE;\n}\n\nstatic char_u\t*old_sub = NULL;\t// previous substitute pattern\nstatic int\tglobal_need_beginline;\t// call beginline() after \":g\"\n\n/*\n * Flags that are kept between calls to :substitute.\n */\ntypedef struct {\n    int\tdo_all;\t\t// do multiple substitutions per line\n    int\tdo_ask;\t\t// ask for confirmation\n    int\tdo_count;\t// count only\n    int\tdo_error;\t// if false, ignore errors\n    int\tdo_print;\t// print last line with subs.\n    int\tdo_list;\t// list last line with subs.\n    int\tdo_number;\t// list last line with line nr\n    int\tdo_ic;\t\t// ignore case flag\n} subflags_T;\n\n/*\n * Skip over the \"sub\" part in :s/pat/sub/ where \"delimiter\" is the separating\n * character.\n */\n    char_u *\nskip_substitute(char_u *start, int delimiter)\n{\n    char_u *p = start;\n\n    while (p[0])\n    {\n\tif (p[0] == delimiter)\t\t// end delimiter found\n\t{\n\t    *p++ = NUL;\t\t\t// replace it with a NUL\n\t    break;\n\t}\n\tif (p[0] == '\\\\' && p[1] != 0)\t// skip escaped characters\n\t    ++p;\n\tMB_PTR_ADV(p);\n    }\n    return p;\n}\n\n    static int\ncheck_regexp_delim(int c)\n{\n    if (isalpha(c))\n    {\n\temsg(_(e_regular_expressions_cant_be_delimited_by_letters));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Perform a substitution from line eap->line1 to line eap->line2 using the\n * command pointed to by eap->arg which should be of the form:\n *\n * /pattern/substitution/{flags}\n *\n * The usual escapes are supported as described in the regexp docs.\n */\n    void\nex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    char_u\t*sub_copy = NULL;\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n    int\t\tsave_sandbox = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    if (in_vim9script())\n\t    {\n\t\temsg(_(e_cannot_use_s_backslash_in_vim9_script));\n\t\treturn;\n\t    }\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST, pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * If the substitute pattern starts with \"\\=\" then it's an expression.\n     * Make a copy, a recursive function may free it.\n     * Otherwise, '~' in the substitute pattern is replaced with the old\n     * pattern.  We do it here once to avoid it to be replaced over and over\n     * again.\n     */\n    if (sub[0] == '\\\\' && sub[1] == '=')\n    {\n\tsub = vim_strsave(sub);\n\tif (sub == NULL)\n\t    return;\n\tsub_copy = sub;\n    }\n    else\n    {\n\tchar_u *newsub = regtilde(sub, magic_isset());\n\n\tif (newsub != sub)\n\t{\n\t    // newsub was allocated, free it later.\n\t    sub_copy = newsub;\n\t    sub = newsub;\n\t}\n    }\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to MODE_CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = MODE_CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t\t// When \":normal\" runs out of characters we get\n\t\t\t\t// an empty line.  Use \"q\" to get out of the\n\t\t\t\t// loop.\n\t\t\t\tif (ex_normal_busy && typed == NUL)\n\t\t\t\t    typed = 'q';\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tsave_sandbox = sandbox;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n\n\t\t// Disallow changing text or switching window in an expression.\n\t\t++textlock;\n#endif\n\t\t// Get length of substitution part, including the NUL.\n\t\t// When it fails sublen is zero.\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, 0,\n\t\t\t       REGSUB_BACKSLASH\n\t\t\t\t    | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (sublen == 0 || aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    sandbox = save_sandbox;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n#ifdef FEAT_EVAL\n\t\t++textlock;\n#endif\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, sublen,\n\t\t\t\t      REGSUB_COPY | REGSUB_BACKSLASH\n\t\t\t\t\t | (magic_isset() ? REGSUB_MAGIC : 0));\n#ifdef FEAT_EVAL\n\t\t--textlock;\n#endif\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n    vim_free(sub_copy);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}\n\n/*\n * Give message for number of substitutions.\n * Can also be used after a \":global\" command.\n * Return TRUE if a message was given.\n */\n    int\ndo_sub_msg(\n    int\t    count_only)\t\t// used 'n' flag for \":s\"\n{\n    /*\n     * Only report substitutions when:\n     * - more than 'report' substitutions\n     * - command was typed by user, or number of changed lines > 'report'\n     * - giving messages is not disabled by 'lazyredraw'\n     */\n    if (((sub_nsubs > p_report && (KeyTyped || sub_nlines > 1 || p_report < 1))\n\t\t|| count_only)\n\t    && messaging())\n    {\n\tchar\t*msg_single;\n\tchar\t*msg_plural;\n\n\tif (got_int)\n\t    STRCPY(msg_buf, _(\"(Interrupted) \"));\n\telse\n\t    *msg_buf = NUL;\n\n\tmsg_single = count_only\n\t\t    ? NGETTEXT(\"%ld match on %ld line\",\n\t\t\t\t\t  \"%ld matches on %ld line\", sub_nsubs)\n\t\t    : NGETTEXT(\"%ld substitution on %ld line\",\n\t\t\t\t   \"%ld substitutions on %ld line\", sub_nsubs);\n\tmsg_plural = count_only\n\t\t    ? NGETTEXT(\"%ld match on %ld lines\",\n\t\t\t\t\t \"%ld matches on %ld lines\", sub_nsubs)\n\t\t    : NGETTEXT(\"%ld substitution on %ld lines\",\n\t\t\t\t  \"%ld substitutions on %ld lines\", sub_nsubs);\n\n\tvim_snprintf_add(msg_buf, sizeof(msg_buf),\n\t\t\t\t NGETTEXT(msg_single, msg_plural, sub_nlines),\n\t\t\t\t sub_nsubs, (long)sub_nlines);\n\n\tif (msg(msg_buf))\n\t    // save message to display it after redraw\n\t    set_keep_msg((char_u *)msg_buf, 0);\n\treturn TRUE;\n    }\n    if (got_int)\n    {\n\temsg(_(e_interrupted));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nglobal_exe_one(char_u *cmd, linenr_T lnum)\n{\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    if (*cmd == NUL || *cmd == '\\n')\n\tdo_cmdline((char_u *)\"p\", NULL, NULL, DOCMD_NOWAIT);\n    else\n\tdo_cmdline(cmd, NULL, NULL, DOCMD_NOWAIT);\n}\n\n/*\n * Execute a global command of the form:\n *\n * g/pattern/X : execute X on all lines where pattern matches\n * v/pattern/X : execute X on all lines where pattern does not match\n *\n * where 'X' is an EX command\n *\n * The command character (as well as the trailing slash) is optional, and\n * is assumed to be 'p' if missing.\n *\n * This is implemented in two passes: first we scan the file for the pattern and\n * set a mark for each line that (not) matches. Secondly we execute the command\n * for each line that has a mark. This is required because after deleting\n * lines we do not know where to search for the next match.\n */\n    void\nex_global(exarg_T *eap)\n{\n    linenr_T\tlnum;\t\t// line number according to old situation\n    int\t\tndone = 0;\n    int\t\ttype;\t\t// first char of cmd: 'v' or 'g'\n    char_u\t*cmd;\t\t// command argument\n\n    char_u\tdelim;\t\t// delimiter, normally '/'\n    char_u\t*pat;\n    regmmatch_T\tregmatch;\n    int\t\tmatch;\n    int\t\twhich_pat;\n\n    // When nesting the command works on one line.  This allows for\n    // \":g/found/v/notfound/command\".\n    if (global_busy && (eap->line1 != 1\n\t\t\t\t  || eap->line2 != curbuf->b_ml.ml_line_count))\n    {\n\t// will increment global_busy to break out of the loop\n\temsg(_(e_cannot_do_global_recursive_with_range));\n\treturn;\n    }\n\n    if (eap->forceit)\t\t    // \":global!\" is like \":vglobal\"\n\ttype = 'v';\n    else\n\ttype = *eap->cmd;\n    cmd = eap->arg;\n    which_pat = RE_LAST;\t    // default: use last used regexp\n\n#ifdef FEAT_EVAL\n    if (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg) == FAIL)\n\treturn;\n#endif\n\n    /*\n     * undocumented vi feature:\n     *\t\"\\/\" and \"\\?\": use previous search pattern.\n     *\t\t \"\\&\": use previous substitute pattern.\n     */\n    if (*cmd == '\\\\')\n    {\n\t++cmd;\n\tif (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t{\n\t    emsg(_(e_backslash_should_be_followed_by));\n\t    return;\n\t}\n\tif (*cmd == '&')\n\t    which_pat = RE_SUBST;\t// use previous substitute pattern\n\telse\n\t    which_pat = RE_SEARCH;\t// use previous search pattern\n\t++cmd;\n\tpat = (char_u *)\"\";\n    }\n    else if (*cmd == NUL)\n    {\n\temsg(_(e_regular_expression_missing_from_global));\n\treturn;\n    }\n    else if (check_regexp_delim(*cmd) == FAIL)\n    {\n\treturn;\n    }\n    else\n    {\n\tdelim = *cmd;\t\t// get the delimiter\n\t++cmd;\t\t\t// skip delimiter if there is one\n\tpat = cmd;\t\t// remember start of pattern\n\tcmd = skip_regexp_ex(cmd, delim, magic_isset(), &eap->arg, NULL, NULL);\n\tif (cmd[0] == delim)\t\t    // end delimiter found\n\t    *cmd++ = NUL;\t\t    // replace it with a NUL\n    }\n\n    if (search_regcomp(pat, RE_BOTH, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\temsg(_(e_invalid_command));\n\treturn;\n    }\n\n    if (global_busy)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\tmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\tif ((type == 'g' && match) || (type == 'v' && !match))\n\t    global_exe_one(cmd, lnum);\n    }\n    else\n    {\n\t/*\n\t * pass 1: set marks for each (not) matching line\n\t */\n\tfor (lnum = eap->line1; lnum <= eap->line2 && !got_int; ++lnum)\n\t{\n\t    // a match on this line?\n\t    match = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL);\n\t    if (regmatch.regprog == NULL)\n\t\tbreak;  // re-compiling regprog failed\n\t    if ((type == 'g' && match) || (type == 'v' && !match))\n\t    {\n\t\tml_setmarked(lnum);\n\t\tndone++;\n\t    }\n\t    line_breakcheck();\n\t}\n\n\t/*\n\t * pass 2: execute the command for each line that has been marked\n\t */\n\tif (got_int)\n\t    msg(_(e_interrupted));\n\telse if (ndone == 0)\n\t{\n\t    if (type == 'v')\n\t    {\n\t\tif (in_vim9script())\n\t\t    semsg(_(e_pattern_found_in_every_line_str), pat);\n\t\telse\n\t\t    smsg(_(\"Pattern found in every line: %s\"), pat);\n\t    }\n\t    else\n\t    {\n\t\tif (in_vim9script())\n\t\t    semsg(_(e_pattern_not_found_str), pat);\n\t\telse\n\t\t    smsg(_(\"Pattern not found: %s\"), pat);\n\t    }\n\t}\n\telse\n\t{\n#ifdef FEAT_CLIPBOARD\n\t    start_global_changes();\n#endif\n\t    global_exe(cmd);\n#ifdef FEAT_CLIPBOARD\n\t    end_global_changes();\n#endif\n\t}\n\n\tml_clearmarked();\t   // clear rest of the marks\n    }\n\n    vim_regfree(regmatch.regprog);\n}\n\n/*\n * Execute \"cmd\" on lines marked with ml_setmarked().\n */\n    void\nglobal_exe(char_u *cmd)\n{\n    linenr_T old_lcount;\t// b_ml.ml_line_count before the command\n    buf_T    *old_buf = curbuf;\t// remember what buffer we started in\n    linenr_T lnum;\t\t// line number according to old situation\n\n    /*\n     * Set current position only once for a global command.\n     * If global_busy is set, setpcmark() will not do anything.\n     * If there is an error, global_busy will be incremented.\n     */\n    setpcmark();\n\n    // When the command writes a message, don't overwrite the command.\n    msg_didout = TRUE;\n\n    sub_nsubs = 0;\n    sub_nlines = 0;\n    global_need_beginline = FALSE;\n    global_busy = 1;\n    old_lcount = curbuf->b_ml.ml_line_count;\n    while (!got_int && (lnum = ml_firstmarked()) != 0 && global_busy == 1)\n    {\n\tglobal_exe_one(cmd, lnum);\n\tui_breakcheck();\n    }\n\n    global_busy = 0;\n    if (global_need_beginline)\n\tbeginline(BL_WHITE | BL_FIX);\n    else\n\tcheck_cursor();\t// cursor may be beyond the end of the line\n\n    // the cursor may not have moved in the text but a change in a previous\n    // line may move it on the screen\n    changed_line_abv_curs();\n\n    // If it looks like no message was written, allow overwriting the\n    // command with the report for number of changes.\n    if (msg_col == 0 && msg_scrolled == 0)\n\tmsg_didout = FALSE;\n\n    // If substitutes done, report number of substitutes, otherwise report\n    // number of extra or deleted lines.\n    // Don't report extra or deleted lines in the edge case where the buffer\n    // we are in after execution is different from the buffer we started in.\n    if (!do_sub_msg(FALSE) && curbuf == old_buf)\n\tmsgmore(curbuf->b_ml.ml_line_count - old_lcount);\n}\n\n#ifdef FEAT_VIMINFO\n/*\n * Get the previous substitute pattern.\n */\n    char_u *\nget_old_sub(void)\n{\n    return old_sub;\n}\n\n/*\n * Set the previous substitute pattern.  \"val\" must be allocated.\n */\n    void\nset_old_sub(char_u *val)\n{\n    vim_free(old_sub);\n    old_sub = val;\n}\n#endif // FEAT_VIMINFO\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_old_sub(void)\n{\n    vim_free(old_sub);\n}\n#endif\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Set up for a tagpreview.\n * Makes the preview window the current window.\n * Return TRUE when it was created.\n */\n    int\nprepare_tagpreview(\n    int\t\tundo_sync,\t    // sync undo when leaving the window\n    int\t\tuse_previewpopup,   // use popup if 'previewpopup' set\n    use_popup_T\tuse_popup)\t    // use other popup window\n{\n    win_T\t*wp;\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n\n    /*\n     * If there is already a preview window open, use that one.\n     */\n    if (!curwin->w_p_pvw)\n    {\n# ifdef FEAT_PROP_POPUP\n\tif (use_previewpopup && *p_pvp != NUL)\n\t{\n\t    wp = popup_find_preview_window();\n\t    if (wp != NULL)\n\t\tpopup_set_wantpos_cursor(wp, wp->w_minwidth, NULL);\n\t}\n\telse if (use_popup != USEPOPUP_NONE)\n\t{\n\t    wp = popup_find_info_window();\n\t    if (wp != NULL)\n\t    {\n\t\tif (use_popup == USEPOPUP_NORMAL)\n\t\t    popup_show(wp);\n\t\telse\n\t\t    popup_hide(wp);\n\t\t// When the popup moves or resizes it may reveal part of\n\t\t// another window.  TODO: can this be done more efficiently?\n\t\tredraw_all_later(NOT_VALID);\n\t    }\n\t}\n\telse\n# endif\n\t{\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_p_pvw)\n\t\t    break;\n\t}\n\tif (wp != NULL)\n\t    win_enter(wp, undo_sync);\n\telse\n\t{\n\t    /*\n\t     * There is no preview window open yet.  Create one.\n\t     */\n# ifdef FEAT_PROP_POPUP\n\t    if ((use_previewpopup && *p_pvp != NUL)\n\t\t\t\t\t\t || use_popup != USEPOPUP_NONE)\n\t\treturn popup_create_preview_window(use_popup != USEPOPUP_NONE);\n# endif\n\t    if (win_split(g_do_tagpreview > 0 ? g_do_tagpreview : 0, 0) == FAIL)\n\t\treturn FALSE;\n\t    curwin->w_p_pvw = TRUE;\n\t    curwin->w_p_wfh = TRUE;\n\t    RESET_BINDING(curwin);\t    // don't take over 'scrollbind'\n\t    // and 'cursorbind'\n# ifdef FEAT_DIFF\n\t    curwin->w_p_diff = FALSE;\t    // no 'diff'\n# endif\n# ifdef FEAT_FOLDING\n\t    curwin->w_p_fdc = 0;\t    // no 'foldcolumn'\n# endif\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n#endif\n\n/*\n * Make the user happy.\n */\n    void\nex_smile(exarg_T *eap UNUSED)\n{\n    static char *code[] = {\n\t\"\\34 \\4o\\14$\\4ox\\30 \\2o\\30$\\1ox\\25 \\2o\\36$\\1o\\11 \\1o\\1$\\3 \\2$\\1 \\1o\\1$x\\5 \\1o\\1 \\1$\\1 \\2o\\10 \\1o\\44$\\1o\\7 \\2$\\1 \\2$\\1 \\2$\\1o\\1$x\\2 \\2o\\1 \\1$\\1 \\1$\\1 \\1\\\"\\1$\\6 \\1o\\11$\\4 \\15$\\4 \\11$\\1o\\7 \\3$\\1o\\2$\\1o\\1$x\\2 \\1\\\"\\6$\\1o\\1$\\5 \\1o\\11$\\6 \\13$\\6 \\12$\\1o\\4 \\10$x\\4 \\7$\\4 \\13$\\6 \\13$\\6 \\27$x\\4 \\27$\\4 \\15$\\4 \\16$\\2 \\3\\\"\\3$x\\5 \\1\\\"\\3$\\4\\\"\\61$\\5 \\1\\\"\\3$x\\6 \\3$\\3 \\1o\\62$\\5 \\1\\\"\\3$\\1ox\\5 \\1o\\2$\\1\\\"\\3 \\63$\\7 \\3$\\1ox\\5 \\3$\\4 \\55$\\1\\\"\\1 \\1\\\"\\6$\",\n\t\"\\5o\\4$\\1ox\\4 \\1o\\3$\\4o\\5$\\2 \\45$\\3 \\1o\\21$x\\4 \\10$\\1\\\"\\4$\\3 \\42$\\5 \\4$\\10\\\"x\\3 \\4\\\"\\7 \\4$\\4 \\1\\\"\\34$\\1\\\"\\6 \\1o\\3$x\\16 \\1\\\"\\3$\\1o\\5 \\3\\\"\\22$\\1\\\"\\2$\\1\\\"\\11 \\3$x\\20 \\3$\\1o\\12 \\1\\\"\\2$\\2\\\"\\6$\\4\\\"\\13 \\1o\\3$x\\21 \\4$\\1o\\40 \\1o\\3$\\1\\\"x\\22 \\1\\\"\\4$\\1o\\6 \\1o\\6$\\1o\\1\\\"\\4$\\1o\\10 \\1o\\4$x\\24 \\1\\\"\\5$\\2o\\5 \\2\\\"\\4$\\1o\\5$\\1o\\3 \\1o\\4$\\2\\\"x\\27 \\2\\\"\\5$\\4o\\2 \\1\\\"\\3$\\1o\\11$\\3\\\"x\\32 \\2\\\"\\7$\\2o\\1 \\12$x\\42 \\4\\\"\\13$x\\46 \\14$x\\47 \\12$\\1\\\"x\\50 \\1\\\"\\3$\\4\\\"x\"\n    };\n    char *p;\n    int n;\n    int i;\n\n    msg_start();\n    msg_putchar('\\n');\n    for (i = 0; i < 2; ++i)\n\tfor (p = code[i]; *p != NUL; ++p)\n\t    if (*p == 'x')\n\t\tmsg_putchar('\\n');\n\t    else\n\t\tfor (n = *p++; n > 0; --n)\n\t\t    if (*p == 'o' || *p == '$')\n\t\t\tmsg_putchar_attr(*p, HL_ATTR(HLF_L));\n\t\t    else\n\t\t\tmsg_putchar(*p);\n    msg_clr_eos();\n}\n\n/*\n * \":drop\"\n * Opens the first argument in a window.  When there are two or more arguments\n * the argument list is redefined.\n */\n    void\nex_drop(exarg_T *eap)\n{\n    int\t\tsplit = FALSE;\n    win_T\t*wp;\n    buf_T\t*buf;\n    tabpage_T\t*tp;\n\n    if (ERROR_IF_POPUP_WINDOW || ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n\n    /*\n     * Check if the first argument is already being edited in a window.  If\n     * so, jump to that window.\n     * We would actually need to check all arguments, but that's complicated\n     * and mostly only one file is dropped.\n     * This also ignores wildcards, since it is very unlikely the user is\n     * editing a file name with a wildcard character.\n     */\n    set_arglist(eap->arg);\n\n    /*\n     * Expanding wildcards may result in an empty argument list.  E.g. when\n     * editing \"foo.pyc\" and \".pyc\" is in 'wildignore'.  Assume that we\n     * already did an error message for this.\n     */\n    if (ARGCOUNT == 0)\n\treturn;\n\n    if (cmdmod.cmod_tab)\n    {\n\t// \":tab drop file ...\": open a tab for each argument that isn't\n\t// edited in a window yet.  It's like \":tab all\" but without closing\n\t// windows or tabs.\n\tex_all(eap);\n    }\n    else\n    {\n\t// \":drop file ...\": Edit the first argument.  Jump to an existing\n\t// window if possible, edit in current window if the current buffer\n\t// can be abandoned, otherwise open a new window.\n\tbuf = buflist_findnr(ARGLIST[0].ae_fnum);\n\n\tFOR_ALL_TAB_WINDOWS(tp, wp)\n\t{\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tcurwin->w_arg_idx = 0;\n\t\tif (!bufIsChanged(curbuf))\n\t\t{\n\t\t    int save_ar = curbuf->b_p_ar;\n\n\t\t    // reload the file if it is newer\n\t\t    curbuf->b_p_ar = TRUE;\n\t\t    buf_check_timestamp(curbuf, FALSE);\n\t\t    curbuf->b_p_ar = save_ar;\n\t\t}\n\t\treturn;\n\t    }\n\t}\n\n\t/*\n\t * Check whether the current buffer is changed. If so, we will need\n\t * to split the current window or data could be lost.\n\t * Skip the check if the 'hidden' option is set, as in this case the\n\t * buffer won't be lost.\n\t */\n\tif (!buf_hide(curbuf))\n\t{\n\t    ++emsg_off;\n\t    split = check_changed(curbuf, CCGD_AW | CCGD_EXCMD);\n\t    --emsg_off;\n\t}\n\n\t// Fake a \":sfirst\" or \":first\" command edit the first argument.\n\tif (split)\n\t{\n\t    eap->cmdidx = CMD_sfirst;\n\t    eap->cmd[0] = 's';\n\t}\n\telse\n\t    eap->cmdidx = CMD_first;\n\tex_rewind(eap);\n    }\n}\n\n/*\n * Skip over the pattern argument of \":vimgrep /pat/[g][j]\".\n * Put the start of the pattern in \"*s\", unless \"s\" is NULL.\n * If \"flags\" is not NULL put the flags in it: VGR_GLOBAL, VGR_NOJUMP.\n * If \"s\" is not NULL terminate the pattern with a NUL.\n * Return a pointer to the char just past the pattern plus flags.\n */\n    char_u *\nskip_vimgrep_pat(char_u *p, char_u **s, int *flags)\n{\n    return skip_vimgrep_pat_ext(p, s, flags, NULL, NULL);\n}\n\n/*\n * As skip_vimgrep_pat() and store the character overwritten by NUL in \"cp\"\n * and the pointer to it in \"nulp\".\n */\n    char_u *\nskip_vimgrep_pat_ext(char_u *p, char_u **s, int *flags, char_u **nulp, int *cp)\n{\n    int\t\tc;\n\n    if (vim_isIDc(*p))\n    {\n\t// \":vimgrep pattern fname\"\n\tif (s != NULL)\n\t    *s = p;\n\tp = skiptowhite(p);\n\tif (s != NULL && *p != NUL)\n\t{\n\t    if (nulp != NULL)\n\t    {\n\t\t*nulp = p;\n\t\t*cp = *p;\n\t    }\n\t    *p++ = NUL;\n\t}\n    }\n    else\n    {\n\t// \":vimgrep /pattern/[g][j] fname\"\n\tif (s != NULL)\n\t    *s = p + 1;\n\tc = *p;\n\tp = skip_regexp(p + 1, c, TRUE);\n\tif (*p != c)\n\t    return NULL;\n\n\t// Truncate the pattern.\n\tif (s != NULL)\n\t{\n\t    if (nulp != NULL)\n\t    {\n\t\t*nulp = p;\n\t\t*cp = *p;\n\t    }\n\t    *p = NUL;\n\t}\n\t++p;\n\n\t// Find the flags\n\twhile (*p == 'g' || *p == 'j' || *p == 'f')\n\t{\n\t    if (flags != NULL)\n\t    {\n\t\tif (*p == 'g')\n\t\t    *flags |= VGR_GLOBAL;\n\t\telse if (*p == 'j')\n\t\t    *flags |= VGR_NOJUMP;\n\t\telse\n\t\t    *flags |= VGR_FUZZY;\n\t    }\n\t    ++p;\n\t}\n    }\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * List v:oldfiles in a nice way.\n */\n    void\nex_oldfiles(exarg_T *eap UNUSED)\n{\n    list_T\t*l = get_vim_var_list(VV_OLDFILES);\n    listitem_T\t*li;\n    int\t\tnr = 0;\n    char_u\t*fname;\n\n    if (l == NULL)\n\tmsg(_(\"No old files\"));\n    else\n    {\n\tmsg_start();\n\tmsg_scroll = TRUE;\n\tfor (li = l->lv_first; li != NULL && !got_int; li = li->li_next)\n\t{\n\t    ++nr;\n\t    fname = tv_get_string(&li->li_tv);\n\t    if (!message_filtered(fname))\n\t    {\n\t\tmsg_outnum((long)nr);\n\t\tmsg_puts(\": \");\n\t\tmsg_outtrans(fname);\n\t\tmsg_clr_eos();\n\t\tmsg_putchar('\\n');\n\t\tout_flush();\t    // output one line at a time\n\t\tui_breakcheck();\n\t    }\n\t}\n\n\t// Assume \"got_int\" was set to truncate the listing.\n\tgot_int = FALSE;\n\n# ifdef FEAT_BROWSE_CMD\n\tif (cmdmod.cmod_flags & CMOD_BROWSE)\n\t{\n\t    quit_more = FALSE;\n\t    nr = prompt_for_number(FALSE);\n\t    msg_starthere();\n\t    if (nr > 0)\n\t    {\n\t\tchar_u *p = list_find_str(get_vim_var_list(VV_OLDFILES),\n\t\t\t\t\t\t\t\t    (long)nr);\n\n\t\tif (p != NULL)\n\t\t{\n\t\t    p = expand_env_save(p);\n\t\t    eap->arg = p;\n\t\t    eap->cmdidx = CMD_edit;\n\t\t    cmdmod.cmod_flags &= ~CMOD_BROWSE;\n\t\t    do_exedit(eap, NULL);\n\t\t    vim_free(p);\n\t\t}\n\t    }\n\t}\n# endif\n    }\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()\n */\n\n// By default: do not create debugging logs or files related to regular\n// expressions, even when compiling with -DDEBUG.\n// Uncomment the second line to get the regexp debugging.\n#undef DEBUG\n// #define DEBUG\n\n#include \"vim.h\"\n\n#ifdef DEBUG\n// show/save debugging data when BT engine is used\n# define BT_REGEXP_DUMP\n// save the debugging data to a file instead of displaying it\n# define BT_REGEXP_LOG\n# define BT_REGEXP_DEBUG_LOG\n# define BT_REGEXP_DEBUG_LOG_NAME\t\"bt_regexp_debug.log\"\n#endif\n\n#ifdef FEAT_RELTIME\nstatic sig_atomic_t dummy_timeout_flag = 0;\nstatic volatile sig_atomic_t *timeout_flag = &dummy_timeout_flag;\n#endif\n\n/*\n * Magic characters have a special meaning, they don't match literally.\n * Magic characters are negative.  This separates them from literal characters\n * (possibly multi-byte).  Only ASCII characters can be Magic.\n */\n#define Magic(x)\t((int)(x) - 256)\n#define un_Magic(x)\t((x) + 256)\n#define is_Magic(x)\t((x) < 0)\n\n    static int\nno_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return x;\n}\n\n    static int\ntoggle_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return Magic(x);\n}\n\n#ifdef FEAT_RELTIME\n    void\ninit_regexp_timeout(long msec)\n{\n    timeout_flag = start_timeout(msec);\n}\n\n    void\ndisable_regexp_timeout(void)\n{\n    stop_timeout();\n    timeout_flag = &dummy_timeout_flag;\n}\n#endif\n\n/*\n * The first byte of the BT regexp internal \"program\" is actually this magic\n * number; the start node begins in the second byte.  It's used to catch the\n * most severe mutilation of the program by the caller.\n */\n\n#define REGMAGIC\t0234\n\n/*\n * Utility definitions.\n */\n#define UCHARAT(p)\t((int)*(char_u *)(p))\n\n// Used for an error (down from) vim_regcomp(): give the error message, set\n// rc_did_emsg and return NULL\n#define EMSG_RET_NULL(m) return (emsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define IEMSG_RET_NULL(m) return (iemsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG_RET_FAIL(m) return (emsg((m)), rc_did_emsg = TRUE, FAIL)\n#define EMSG2_RET_NULL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG3_RET_NULL(m, c, a) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\", (a)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG2_RET_FAIL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, FAIL)\n#define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_(e_invalid_item_in_str_brackets), reg_magic == MAGIC_ALL)\n\n\n#define MAX_LIMIT\t(32767L << 16L)\n\n#define NOT_MULTI\t0\n#define MULTI_ONE\t1\n#define MULTI_MULT\t2\n\n// return values for regmatch()\n#define RA_FAIL\t\t1\t// something failed, abort\n#define RA_CONT\t\t2\t// continue in inner loop\n#define RA_BREAK\t3\t// break inner loop\n#define RA_MATCH\t4\t// successful match\n#define RA_NOMATCH\t5\t// didn't match\n\n/*\n * Return NOT_MULTI if c is not a \"multi\" operator.\n * Return MULTI_ONE if c is a single \"multi\" operator.\n * Return MULTI_MULT if c is a multi \"multi\" operator.\n */\n    static int\nre_multi_type(int c)\n{\n    if (c == Magic('@') || c == Magic('=') || c == Magic('?'))\n\treturn MULTI_ONE;\n    if (c == Magic('*') || c == Magic('+') || c == Magic('{'))\n\treturn MULTI_MULT;\n    return NOT_MULTI;\n}\n\nstatic char_u\t\t*reg_prev_sub = NULL;\n\n/*\n * REGEXP_INRANGE contains all characters which are always special in a []\n * range after '\\'.\n * REGEXP_ABBR contains all characters which act as abbreviations after '\\'.\n * These are:\n *  \\n\t- New line (NL).\n *  \\r\t- Carriage Return (CR).\n *  \\t\t- Tab (TAB).\n *  \\e\t- Escape (ESC).\n *  \\b\t- Backspace (Ctrl_H).\n *  \\d  - Character code in decimal, eg \\d123\n *  \\o\t- Character code in octal, eg \\o80\n *  \\x\t- Character code in hex, eg \\x4a\n *  \\u\t- Multibyte character code, eg \\u20ac\n *  \\U\t- Long multibyte character code, eg \\U12345678\n */\nstatic char_u REGEXP_INRANGE[] = \"]^-n\\\\\";\nstatic char_u REGEXP_ABBR[] = \"nrtebdoxuU\";\n\n/*\n * Translate '\\x' to its control character, except \"\\n\", which is Magic.\n */\n    static int\nbackslash_trans(int c)\n{\n    switch (c)\n    {\n\tcase 'r':   return CAR;\n\tcase 't':   return TAB;\n\tcase 'e':   return ESC;\n\tcase 'b':   return BS;\n    }\n    return c;\n}\n\n/*\n * Check for a character class name \"[:name:]\".  \"pp\" points to the '['.\n * Returns one of the CLASS_ items. CLASS_NONE means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_char_class(char_u **pp)\n{\n    static const char *(class_names[]) =\n    {\n\t\"alnum:]\",\n#define CLASS_ALNUM 0\n\t\"alpha:]\",\n#define CLASS_ALPHA 1\n\t\"blank:]\",\n#define CLASS_BLANK 2\n\t\"cntrl:]\",\n#define CLASS_CNTRL 3\n\t\"digit:]\",\n#define CLASS_DIGIT 4\n\t\"graph:]\",\n#define CLASS_GRAPH 5\n\t\"lower:]\",\n#define CLASS_LOWER 6\n\t\"print:]\",\n#define CLASS_PRINT 7\n\t\"punct:]\",\n#define CLASS_PUNCT 8\n\t\"space:]\",\n#define CLASS_SPACE 9\n\t\"upper:]\",\n#define CLASS_UPPER 10\n\t\"xdigit:]\",\n#define CLASS_XDIGIT 11\n\t\"tab:]\",\n#define CLASS_TAB 12\n\t\"return:]\",\n#define CLASS_RETURN 13\n\t\"backspace:]\",\n#define CLASS_BACKSPACE 14\n\t\"escape:]\",\n#define CLASS_ESCAPE 15\n\t\"ident:]\",\n#define CLASS_IDENT 16\n\t\"keyword:]\",\n#define CLASS_KEYWORD 17\n\t\"fname:]\",\n#define CLASS_FNAME 18\n    };\n#define CLASS_NONE 99\n    int i;\n\n    if ((*pp)[1] == ':')\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(class_names); ++i)\n\t    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)\n\t    {\n\t\t*pp += STRLEN(class_names[i]) + 2;\n\t\treturn i;\n\t    }\n    }\n    return CLASS_NONE;\n}\n\n/*\n * Specific version of character class functions.\n * Using a table to keep this fast.\n */\nstatic short\tclass_tab[256];\n\n#define\t    RI_DIGIT\t0x01\n#define\t    RI_HEX\t0x02\n#define\t    RI_OCTAL\t0x04\n#define\t    RI_WORD\t0x08\n#define\t    RI_HEAD\t0x10\n#define\t    RI_ALPHA\t0x20\n#define\t    RI_LOWER\t0x40\n#define\t    RI_UPPER\t0x80\n#define\t    RI_WHITE\t0x100\n\n    static void\ninit_class_tab(void)\n{\n    int\t\ti;\n    static int\tdone = FALSE;\n\n    if (done)\n\treturn;\n\n    for (i = 0; i < 256; ++i)\n    {\n\tif (i >= '0' && i <= '7')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;\n\telse if (i >= '8' && i <= '9')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;\n\telse if (i >= 'a' && i <= 'f')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'g' && i <= 'z')\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'A' && i <= 'F')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i >= 'G' && i <= 'Z')\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i == '_')\n\t    class_tab[i] = RI_WORD + RI_HEAD;\n\telse\n\t    class_tab[i] = 0;\n    }\n    class_tab[' '] |= RI_WHITE;\n    class_tab['\\t'] |= RI_WHITE;\n    done = TRUE;\n}\n\n#define ri_digit(c)\t((c) < 0x100 && (class_tab[c] & RI_DIGIT))\n#define ri_hex(c)\t((c) < 0x100 && (class_tab[c] & RI_HEX))\n#define ri_octal(c)\t((c) < 0x100 && (class_tab[c] & RI_OCTAL))\n#define ri_word(c)\t((c) < 0x100 && (class_tab[c] & RI_WORD))\n#define ri_head(c)\t((c) < 0x100 && (class_tab[c] & RI_HEAD))\n#define ri_alpha(c)\t((c) < 0x100 && (class_tab[c] & RI_ALPHA))\n#define ri_lower(c)\t((c) < 0x100 && (class_tab[c] & RI_LOWER))\n#define ri_upper(c)\t((c) < 0x100 && (class_tab[c] & RI_UPPER))\n#define ri_white(c)\t((c) < 0x100 && (class_tab[c] & RI_WHITE))\n\n// flags for regflags\n#define RF_ICASE    1\t// ignore case\n#define RF_NOICASE  2\t// don't ignore case\n#define RF_HASNL    4\t// can match a NL\n#define RF_ICOMBINE 8\t// ignore combining characters\n#define RF_LOOKBH   16\t// uses \"\\@<=\" or \"\\@<!\"\n\n/*\n * Global work variables for vim_regcomp().\n */\n\nstatic char_u\t*regparse;\t// Input-scan pointer.\nstatic int\tregnpar;\t// () count.\nstatic int\twants_nfa;\t// regex should use NFA engine\n#ifdef FEAT_SYN_HL\nstatic int\tregnzpar;\t// \\z() count.\nstatic int\tre_has_z;\t// \\z item detected\n#endif\nstatic unsigned\tregflags;\t// RF_ flags for prog\n#if defined(FEAT_SYN_HL) || defined(PROTO)\nstatic int\thad_eol;\t// TRUE when EOL found by vim_regcomp()\n#endif\n\nstatic magic_T\treg_magic;\t// magicness of the pattern\n\nstatic int\treg_string;\t// matching with a string instead of a buffer\n\t\t\t\t// line\nstatic int\treg_strict;\t// \"[abc\" is illegal\n\n/*\n * META contains all characters that may be magic, except '^' and '$'.\n */\n\n// META[] is used often enough to justify turning it into a table.\nstatic char_u META_flags[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//\t\t   %  &     (  )  *  +\t      .\n    0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,\n//     1  2  3\t4  5  6  7  8  9\t<  =  >  ?\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,\n//  @  A     C\tD     F     H  I     K\tL  M\t O\n    1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,\n//  P\t     S\t   U  V  W  X\t  Z  [\t\t _\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,\n//     a     c\td     f     h  i     k\tl  m  n  o\n    0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,\n//  p\t     s\t   u  v  w  x\t  z  {\t|     ~\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1\n};\n\nstatic int\tcurchr;\t\t// currently parsed character\n// Previous character.  Note: prevchr is sometimes -1 when we are not at the\n// start, eg in /[ ^I]^ the pattern was never found even if it existed,\n// because ^ was taken to be magic -- webb\nstatic int\tprevchr;\nstatic int\tprevprevchr;\t// previous-previous character\nstatic int\tnextchr;\t// used for ungetchr()\n\n// arguments for reg()\n#define REG_NOPAREN\t0\t// toplevel reg()\n#define REG_PAREN\t1\t// \\(\\)\n#define REG_ZPAREN\t2\t// \\z(\\)\n#define REG_NPAREN\t3\t// \\%(\\)\n\ntypedef struct\n{\n     char_u\t*regparse;\n     int\tprevchr_len;\n     int\tcurchr;\n     int\tprevchr;\n     int\tprevprevchr;\n     int\tnextchr;\n     int\tat_start;\n     int\tprev_at_start;\n     int\tregnpar;\n} parse_state_T;\n\nstatic void\tinitchr(char_u *);\nstatic int\tgetchr(void);\nstatic void\tskipchr_keepstart(void);\nstatic int\tpeekchr(void);\nstatic void\tskipchr(void);\nstatic void\tungetchr(void);\nstatic long\tgethexchrs(int maxinputlen);\nstatic long\tgetoctchrs(void);\nstatic long\tgetdecchrs(void);\nstatic int\tcoll_get_char(void);\nstatic int\tprog_magic_wrong(void);\nstatic int\tcstrncmp(char_u *s1, char_u *s2, int *n);\nstatic char_u\t*cstrchr(char_u *, int);\nstatic int\tre_mult_next(char *what);\nstatic int\treg_iswordc(int);\n#ifdef FEAT_EVAL\nstatic void report_re_switch(char_u *pat);\n#endif\n\nstatic regengine_T bt_regengine;\nstatic regengine_T nfa_regengine;\n\n/*\n * Return TRUE if compiled regular expression \"prog\" can match a line break.\n */\n    int\nre_multiline(regprog_T *prog)\n{\n    return (prog->regflags & RF_HASNL);\n}\n\n/*\n * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['.\n * Returns a character representing the class. Zero means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_equi_class(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[1] == '=' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '=' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\n/*\n * Check for a collating element \"[.a.]\".  \"pp\" points to the '['.\n * Returns a character. Zero means that no item was recognized.  Otherwise\n * \"pp\" is advanced to after the item.\n * Currently only single characters are recognized!\n */\n    static int\nget_coll_element(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[0] != NUL && p[1] == '.' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '.' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\nstatic int reg_cpo_lit; // 'cpoptions' contains 'l' flag\nstatic int reg_cpo_bsl; // 'cpoptions' contains '\\' flag\n\n    static void\nget_cpo_flags(void)\n{\n    reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;\n    reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;\n}\n\n/*\n * Skip over a \"[]\" range.\n * \"p\" must point to the character after the '['.\n * The returned pointer is on the matching ']', or the terminating NUL.\n */\n    static char_u *\nskip_anyof(char_u *p)\n{\n    int\t\tl;\n\n    if (*p == '^')\t// Complement of range.\n\t++p;\n    if (*p == ']' || *p == '-')\n\t++p;\n    while (*p != NUL && *p != ']')\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t    p += l;\n\telse\n\t    if (*p == '-')\n\t    {\n\t\t++p;\n\t\tif (*p != ']' && *p != NUL)\n\t\t    MB_PTR_ADV(p);\n\t    }\n\telse if (*p == '\\\\'\n\t\t&& !reg_cpo_bsl\n\t\t&& (vim_strchr(REGEXP_INRANGE, p[1]) != NULL\n\t\t    || (!reg_cpo_lit && vim_strchr(REGEXP_ABBR, p[1]) != NULL)))\n\t    p += 2;\n\telse if (*p == '[')\n\t{\n\t    if (get_char_class(&p) == CLASS_NONE\n\t\t    && get_equi_class(&p) == 0\n\t\t    && get_coll_element(&p) == 0\n\t\t    && *p != NUL)\n\t\t++p; // it is not a class name and not NUL\n\t}\n\telse\n\t    ++p;\n    }\n\n    return p;\n}\n\n/*\n * Skip past regular expression.\n * Stop at end of \"startp\" or where \"delim\" is found ('/', '?', etc).\n * Take care of characters with a backslash in front of it.\n * Skip strings inside [ and ].\n */\n    char_u *\nskip_regexp(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    return skip_regexp_ex(startp, delim, magic, NULL, NULL, NULL);\n}\n\n/*\n * Call skip_regexp() and when the delimiter does not match give an error and\n * return NULL.\n */\n    char_u *\nskip_regexp_err(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    char_u *p = skip_regexp(startp, delim, magic);\n\n    if (*p != delim)\n    {\n\tsemsg(_(e_missing_delimiter_after_search_pattern_str), startp);\n\treturn NULL;\n    }\n    return p;\n}\n\n/*\n * skip_regexp() with extra arguments:\n * When \"newp\" is not NULL and \"dirc\" is '?', make an allocated copy of the\n * expression and change \"\\?\" to \"?\".  If \"*newp\" is not NULL the expression\n * is changed in-place.\n * If a \"\\?\" is changed to \"?\" then \"dropped\" is incremented, unless NULL.\n * If \"magic_val\" is not NULL, returns the effective magicness of the pattern\n */\n    char_u *\nskip_regexp_ex(\n    char_u\t*startp,\n    int\t\tdirc,\n    int\t\tmagic,\n    char_u\t**newp,\n    int\t\t*dropped,\n    magic_T\t*magic_val)\n{\n    magic_T\tmymagic;\n    char_u\t*p = startp;\n\n    if (magic)\n\tmymagic = MAGIC_ON;\n    else\n\tmymagic = MAGIC_OFF;\n    get_cpo_flags();\n\n    for (; p[0] != NUL; MB_PTR_ADV(p))\n    {\n\tif (p[0] == dirc)\t// found end of regexp\n\t    break;\n\tif ((p[0] == '[' && mymagic >= MAGIC_ON)\n\t\t|| (p[0] == '\\\\' && p[1] == '[' && mymagic <= MAGIC_OFF))\n\t{\n\t    p = skip_anyof(p + 1);\n\t    if (p[0] == NUL)\n\t\tbreak;\n\t}\n\telse if (p[0] == '\\\\' && p[1] != NUL)\n\t{\n\t    if (dirc == '?' && newp != NULL && p[1] == '?')\n\t    {\n\t\t// change \"\\?\" to \"?\", make a copy first.\n\t\tif (*newp == NULL)\n\t\t{\n\t\t    *newp = vim_strsave(startp);\n\t\t    if (*newp != NULL)\n\t\t\tp = *newp + (p - startp);\n\t\t}\n\t\tif (dropped != NULL)\n\t\t    ++*dropped;\n\t\tif (*newp != NULL)\n\t\t    STRMOVE(p, p + 1);\n\t\telse\n\t\t    ++p;\n\t    }\n\t    else\n\t\t++p;    // skip next character\n\t    if (*p == 'v')\n\t\tmymagic = MAGIC_ALL;\n\t    else if (*p == 'V')\n\t\tmymagic = MAGIC_NONE;\n\t}\n    }\n    if (magic_val != NULL)\n\t*magic_val = mymagic;\n    return p;\n}\n\n/*\n * Functions for getting characters from the regexp input.\n */\nstatic int\tprevchr_len;\t// byte length of previous char\nstatic int\tat_start;\t// True when on the first character\nstatic int\tprev_at_start;  // True when on the second character\n\n/*\n * Start parsing at \"str\".\n */\n    static void\ninitchr(char_u *str)\n{\n    regparse = str;\n    prevchr_len = 0;\n    curchr = prevprevchr = prevchr = nextchr = -1;\n    at_start = TRUE;\n    prev_at_start = FALSE;\n}\n\n/*\n * Save the current parse state, so that it can be restored and parsing\n * starts in the same state again.\n */\n    static void\nsave_parse_state(parse_state_T *ps)\n{\n    ps->regparse = regparse;\n    ps->prevchr_len = prevchr_len;\n    ps->curchr = curchr;\n    ps->prevchr = prevchr;\n    ps->prevprevchr = prevprevchr;\n    ps->nextchr = nextchr;\n    ps->at_start = at_start;\n    ps->prev_at_start = prev_at_start;\n    ps->regnpar = regnpar;\n}\n\n/*\n * Restore a previously saved parse state.\n */\n    static void\nrestore_parse_state(parse_state_T *ps)\n{\n    regparse = ps->regparse;\n    prevchr_len = ps->prevchr_len;\n    curchr = ps->curchr;\n    prevchr = ps->prevchr;\n    prevprevchr = ps->prevprevchr;\n    nextchr = ps->nextchr;\n    at_start = ps->at_start;\n    prev_at_start = ps->prev_at_start;\n    regnpar = ps->regnpar;\n}\n\n\n/*\n * Get the next character without advancing.\n */\n    static int\npeekchr(void)\n{\n    static int\tafter_slash = FALSE;\n\n    if (curchr == -1)\n    {\n\tswitch (curchr = regparse[0])\n\t{\n\tcase '.':\n\tcase '[':\n\tcase '~':\n\t    // magic when 'magic' is on\n\t    if (reg_magic >= MAGIC_ON)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '(':\n\tcase ')':\n\tcase '{':\n\tcase '%':\n\tcase '+':\n\tcase '=':\n\tcase '?':\n\tcase '@':\n\tcase '!':\n\tcase '&':\n\tcase '|':\n\tcase '<':\n\tcase '>':\n\tcase '#':\t// future ext.\n\tcase '\"':\t// future ext.\n\tcase '\\'':\t// future ext.\n\tcase ',':\t// future ext.\n\tcase '-':\t// future ext.\n\tcase ':':\t// future ext.\n\tcase ';':\t// future ext.\n\tcase '`':\t// future ext.\n\tcase '/':\t// Can't be used in / command\n\t    // magic only after \"\\v\"\n\t    if (reg_magic == MAGIC_ALL)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '*':\n\t    // * is not magic as the very first character, eg \"?*ptr\", when\n\t    // after '^', eg \"/^*ptr\" and when after \"\\(\", \"\\|\", \"\\&\".  But\n\t    // \"\\(\\*\" is not magic, thus must be magic if \"after_slash\"\n\t    if (reg_magic >= MAGIC_ON\n\t\t    && !at_start\n\t\t    && !(prev_at_start && prevchr == Magic('^'))\n\t\t    && (after_slash\n\t\t\t|| (prevchr != Magic('(')\n\t\t\t    && prevchr != Magic('&')\n\t\t\t    && prevchr != Magic('|'))))\n\t\tcurchr = Magic('*');\n\t    break;\n\tcase '^':\n\t    // '^' is only magic as the very first character and if it's after\n\t    // \"\\(\", \"\\|\", \"\\&' or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF\n\t\t    && (at_start\n\t\t\t|| reg_magic == MAGIC_ALL\n\t\t\t|| prevchr == Magic('(')\n\t\t\t|| prevchr == Magic('|')\n\t\t\t|| prevchr == Magic('&')\n\t\t\t|| prevchr == Magic('n')\n\t\t\t|| (no_Magic(prevchr) == '('\n\t\t\t    && prevprevchr == Magic('%'))))\n\t    {\n\t\tcurchr = Magic('^');\n\t\tat_start = TRUE;\n\t\tprev_at_start = FALSE;\n\t    }\n\t    break;\n\tcase '$':\n\t    // '$' is only magic as the very last char and if it's in front of\n\t    // either \"\\|\", \"\\)\", \"\\&\", or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF)\n\t    {\n\t\tchar_u *p = regparse + 1;\n\t\tint is_magic_all = (reg_magic == MAGIC_ALL);\n\n\t\t// ignore \\c \\C \\m \\M \\v \\V and \\Z after '$'\n\t\twhile (p[0] == '\\\\' && (p[1] == 'c' || p[1] == 'C'\n\t\t\t\t|| p[1] == 'm' || p[1] == 'M'\n\t\t\t\t|| p[1] == 'v' || p[1] == 'V' || p[1] == 'Z'))\n\t\t{\n\t\t    if (p[1] == 'v')\n\t\t\tis_magic_all = TRUE;\n\t\t    else if (p[1] == 'm' || p[1] == 'M' || p[1] == 'V')\n\t\t\tis_magic_all = FALSE;\n\t\t    p += 2;\n\t\t}\n\t\tif (p[0] == NUL\n\t\t\t|| (p[0] == '\\\\'\n\t\t\t    && (p[1] == '|' || p[1] == '&' || p[1] == ')'\n\t\t\t\t|| p[1] == 'n'))\n\t\t\t|| (is_magic_all\n\t\t\t       && (p[0] == '|' || p[0] == '&' || p[0] == ')'))\n\t\t\t|| reg_magic == MAGIC_ALL)\n\t\t    curchr = Magic('$');\n\t    }\n\t    break;\n\tcase '\\\\':\n\t    {\n\t\tint c = regparse[1];\n\n\t\tif (c == NUL)\n\t\t    curchr = '\\\\';\t// trailing '\\'\n\t\telse if (c <= '~' && META_flags[c])\n\t\t{\n\t\t    /*\n\t\t     * META contains everything that may be magic sometimes,\n\t\t     * except ^ and $ (\"\\^\" and \"\\$\" are only magic after\n\t\t     * \"\\V\").  We now fetch the next character and toggle its\n\t\t     * magicness.  Therefore, \\ is so meta-magic that it is\n\t\t     * not in META.\n\t\t     */\n\t\t    curchr = -1;\n\t\t    prev_at_start = at_start;\n\t\t    at_start = FALSE;\t// be able to say \"/\\*ptr\"\n\t\t    ++regparse;\n\t\t    ++after_slash;\n\t\t    peekchr();\n\t\t    --regparse;\n\t\t    --after_slash;\n\t\t    curchr = toggle_Magic(curchr);\n\t\t}\n\t\telse if (vim_strchr(REGEXP_ABBR, c))\n\t\t{\n\t\t    /*\n\t\t     * Handle abbreviations, like \"\\t\" for TAB -- webb\n\t\t     */\n\t\t    curchr = backslash_trans(c);\n\t\t}\n\t\telse if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))\n\t\t    curchr = toggle_Magic(c);\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Next character can never be (made) magic?\n\t\t     * Then backslashing it won't do anything.\n\t\t     */\n\t\t    if (has_mbyte)\n\t\t\tcurchr = (*mb_ptr2char)(regparse + 1);\n\t\t    else\n\t\t\tcurchr = c;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tdefault:\n\t    if (has_mbyte)\n\t\tcurchr = (*mb_ptr2char)(regparse);\n\t}\n    }\n\n    return curchr;\n}\n\n/*\n * Eat one lexed character.  Do this in a way that we can undo it.\n */\n    static void\nskipchr(void)\n{\n    // peekchr() eats a backslash, do the same here\n    if (*regparse == '\\\\')\n\tprevchr_len = 1;\n    else\n\tprevchr_len = 0;\n    if (regparse[prevchr_len] != NUL)\n    {\n\tif (enc_utf8)\n\t    // exclude composing chars that mb_ptr2len does include\n\t    prevchr_len += utf_ptr2len(regparse + prevchr_len);\n\telse if (has_mbyte)\n\t    prevchr_len += (*mb_ptr2len)(regparse + prevchr_len);\n\telse\n\t    ++prevchr_len;\n    }\n    regparse += prevchr_len;\n    prev_at_start = at_start;\n    at_start = FALSE;\n    prevprevchr = prevchr;\n    prevchr = curchr;\n    curchr = nextchr;\t    // use previously unget char, or -1\n    nextchr = -1;\n}\n\n/*\n * Skip a character while keeping the value of prev_at_start for at_start.\n * prevchr and prevprevchr are also kept.\n */\n    static void\nskipchr_keepstart(void)\n{\n    int as = prev_at_start;\n    int pr = prevchr;\n    int prpr = prevprevchr;\n\n    skipchr();\n    at_start = as;\n    prevchr = pr;\n    prevprevchr = prpr;\n}\n\n/*\n * Get the next character from the pattern. We know about magic and such, so\n * therefore we need a lexical analyzer.\n */\n    static int\ngetchr(void)\n{\n    int chr = peekchr();\n\n    skipchr();\n    return chr;\n}\n\n/*\n * put character back.  Works only once!\n */\n    static void\nungetchr(void)\n{\n    nextchr = curchr;\n    curchr = prevchr;\n    prevchr = prevprevchr;\n    at_start = prev_at_start;\n    prev_at_start = FALSE;\n\n    // Backup regparse, so that it's at the same position as before the\n    // getchr().\n    regparse -= prevchr_len;\n}\n\n/*\n * Get and return the value of the hex string at the current position.\n * Return -1 if there is no valid hex number.\n * The position is updated:\n *     blahblah\\%x20asdf\n *\t   before-^ ^-after\n * The parameter controls the maximum number of input characters. This will be\n * 2 when reading a \\%x20 sequence and 4 when reading a \\%u20AC sequence.\n */\n    static long\ngethexchrs(int maxinputlen)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < maxinputlen; ++i)\n    {\n\tc = regparse[0];\n\tif (!vim_isxdigit(c))\n\t    break;\n\tnr <<= 4;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * Get and return the value of the decimal string immediately after the\n * current position. Return -1 for invalid.  Consumes all digits.\n */\n    static long\ngetdecchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; ; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '9')\n\t    break;\n\tnr *= 10;\n\tnr += c - '0';\n\t++regparse;\n\tcurchr = -1; // no longer valid\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * get and return the value of the octal string immediately after the current\n * position. Return -1 for invalid, or 0-255 for valid. Smart enough to handle\n * numbers > 377 correctly (for example, 400 is treated as 40) and doesn't\n * treat 8 or 9 as recognised characters. Position is updated:\n *     blahblah\\%o210asdf\n *\t   before-^  ^-after\n */\n    static long\ngetoctchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < 3 && nr < 040; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '7')\n\t    break;\n\tnr <<= 3;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * read_limits - Read two integers to be taken as a minimum and maximum.\n * If the first character is '-', then the range is reversed.\n * Should end with 'end'.  If minval is missing, zero is default, if maxval is\n * missing, a very big number is the default.\n */\n    static int\nread_limits(long *minval, long *maxval)\n{\n    int\t\treverse = FALSE;\n    char_u\t*first_char;\n    long\ttmp;\n\n    if (*regparse == '-')\n    {\n\t// Starts with '-', so reverse the range later\n\tregparse++;\n\treverse = TRUE;\n    }\n    first_char = regparse;\n    *minval = getdigits(&regparse);\n    if (*regparse == ',')\t    // There is a comma\n    {\n\tif (vim_isdigit(*++regparse))\n\t    *maxval = getdigits(&regparse);\n\telse\n\t    *maxval = MAX_LIMIT;\n    }\n    else if (VIM_ISDIGIT(*first_char))\n\t*maxval = *minval;\t    // It was \\{n} or \\{-n}\n    else\n\t*maxval = MAX_LIMIT;\t    // It was \\{} or \\{-}\n    if (*regparse == '\\\\')\n\tregparse++;\t// Allow either \\{...} or \\{...\\}\n    if (*regparse != '}')\n\tEMSG2_RET_FAIL(_(e_syntax_error_in_str_curlies),\n\t\t\t\t\t\t       reg_magic == MAGIC_ALL);\n\n    /*\n     * Reverse the range if there was a '-', or make sure it is in the right\n     * order otherwise.\n     */\n    if ((!reverse && *minval > *maxval) || (reverse && *minval < *maxval))\n    {\n\ttmp = *minval;\n\t*minval = *maxval;\n\t*maxval = tmp;\n    }\n    skipchr();\t\t// let's be friends with the lexer again\n    return OK;\n}\n\n/*\n * vim_regexec and friends\n */\n\n/*\n * Global work variables for vim_regexec().\n */\n\nstatic void\tcleanup_subexpr(void);\n#ifdef FEAT_SYN_HL\nstatic void\tcleanup_zsubexpr(void);\n#endif\nstatic void\treg_nextline(void);\nstatic int\tmatch_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen);\n\n/*\n * Sometimes need to save a copy of a line.  Since alloc()/free() is very\n * slow, we keep one allocated piece of memory and only re-allocate it when\n * it's too small.  It's freed in bt_regexec_both() when finished.\n */\nstatic char_u\t*reg_tofree = NULL;\nstatic unsigned\treg_tofreelen;\n\n/*\n * Structure used to store the execution state of the regex engine.\n * Which ones are set depends on whether a single-line or multi-line match is\n * done:\n *\t\t\tsingle-line\t\tmulti-line\n * reg_match\t\t&regmatch_T\t\tNULL\n * reg_mmatch\t\tNULL\t\t\t&regmmatch_T\n * reg_startp\t\treg_match->startp\t<invalid>\n * reg_endp\t\treg_match->endp\t\t<invalid>\n * reg_startpos\t\t<invalid>\t\treg_mmatch->startpos\n * reg_endpos\t\t<invalid>\t\treg_mmatch->endpos\n * reg_win\t\tNULL\t\t\twindow in which to search\n * reg_buf\t\tcurbuf\t\t\tbuffer in which to search\n * reg_firstlnum\t<invalid>\t\tfirst line in which to search\n * reg_maxline\t\t0\t\t\tlast line nr\n * reg_line_lbr\t\tFALSE or TRUE\t\tFALSE\n */\ntypedef struct {\n    regmatch_T\t\t*reg_match;\n    regmmatch_T\t\t*reg_mmatch;\n    char_u\t\t**reg_startp;\n    char_u\t\t**reg_endp;\n    lpos_T\t\t*reg_startpos;\n    lpos_T\t\t*reg_endpos;\n    win_T\t\t*reg_win;\n    buf_T\t\t*reg_buf;\n    linenr_T\t\treg_firstlnum;\n    linenr_T\t\treg_maxline;\n    int\t\t\treg_line_lbr;\t// \"\\n\" in string is line break\n\n    // The current match-position is stord in these variables:\n    linenr_T\tlnum;\t\t// line number, relative to first line\n    char_u\t*line;\t\t// start of current line\n    char_u\t*input;\t\t// current input, points into \"line\"\n\n    int\tneed_clear_subexpr;\t// subexpressions still need to be cleared\n#ifdef FEAT_SYN_HL\n    int\tneed_clear_zsubexpr;\t// extmatch subexpressions still need to be\n\t\t\t\t// cleared\n#endif\n\n    // Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().\n    // Normally it gets the value of \"rm_ic\" or \"rmm_ic\", but when the pattern\n    // contains '\\c' or '\\C' the value is overruled.\n    int\t\t\treg_ic;\n\n    // Similar to \"reg_ic\", but only for 'combining' characters.  Set with \\Z\n    // flag in the regexp.  Defaults to false, always.\n    int\t\t\treg_icombine;\n\n    // Copy of \"rmm_maxcol\": maximum column to search for a match.  Zero when\n    // there is no maximum.\n    colnr_T\t\treg_maxcol;\n\n    // State for the NFA engine regexec.\n    int nfa_has_zend;\t    // NFA regexp \\ze operator encountered.\n    int nfa_has_backref;    // NFA regexp \\1 .. \\9 encountered.\n    int nfa_nsubexpr;\t    // Number of sub expressions actually being used\n\t\t\t    // during execution. 1 if only the whole match\n\t\t\t    // (subexpr 0) is used.\n    // listid is global, so that it increases on recursive calls to\n    // nfa_regmatch(), which means we don't have to clear the lastlist field of\n    // all the states.\n    int nfa_listid;\n    int nfa_alt_listid;\n\n#ifdef FEAT_SYN_HL\n    int nfa_has_zsubexpr;   // NFA regexp has \\z( ), set zsubexpr.\n#endif\n} regexec_T;\n\nstatic regexec_T\trex;\nstatic int\t\trex_in_use = FALSE;\n\n/*\n * Return TRUE if character 'c' is included in 'iskeyword' option for\n * \"reg_buf\" buffer.\n */\n    static int\nreg_iswordc(int c)\n{\n    return vim_iswordc_buf(c, rex.reg_buf);\n}\n\n/*\n * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\".\n */\n    static char_u *\nreg_getline(linenr_T lnum)\n{\n    // when looking behind for a match/no-match lnum is negative.  But we\n    // can't go before line 1\n    if (rex.reg_firstlnum + lnum < 1)\n\treturn NULL;\n    if (lnum > rex.reg_maxline)\n\t// Must have matched the \"\\n\" in the last line.\n\treturn (char_u *)\"\";\n    return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, FALSE);\n}\n\n#ifdef FEAT_SYN_HL\nstatic char_u\t*reg_startzp[NSUBEXP];\t// Workspace to mark beginning\nstatic char_u\t*reg_endzp[NSUBEXP];\t//   and end of \\z(...\\) matches\nstatic lpos_T\treg_startzpos[NSUBEXP];\t// idem, beginning pos\nstatic lpos_T\treg_endzpos[NSUBEXP];\t// idem, end pos\n#endif\n\n// TRUE if using multi-line regexp.\n#define REG_MULTI\t(rex.reg_match == NULL)\n\n#ifdef FEAT_SYN_HL\n/*\n * Create a new extmatch and mark it as referenced once.\n */\n    static reg_extmatch_T *\nmake_extmatch(void)\n{\n    reg_extmatch_T\t*em;\n\n    em = ALLOC_CLEAR_ONE(reg_extmatch_T);\n    if (em != NULL)\n\tem->refcnt = 1;\n    return em;\n}\n\n/*\n * Add a reference to an extmatch.\n */\n    reg_extmatch_T *\nref_extmatch(reg_extmatch_T *em)\n{\n    if (em != NULL)\n\tem->refcnt++;\n    return em;\n}\n\n/*\n * Remove a reference to an extmatch.  If there are no references left, free\n * the info.\n */\n    void\nunref_extmatch(reg_extmatch_T *em)\n{\n    int i;\n\n    if (em != NULL && --em->refcnt <= 0)\n    {\n\tfor (i = 0; i < NSUBEXP; ++i)\n\t    vim_free(em->matches[i]);\n\tvim_free(em);\n    }\n}\n#endif\n\n/*\n * Get class of previous character.\n */\n    static int\nreg_prev_class(void)\n{\n    if (rex.input > rex.line)\n\treturn mb_get_class_buf(rex.input - 1\n\t\t       - (*mb_head_off)(rex.line, rex.input - 1), rex.reg_buf);\n    return -1;\n}\n\n/*\n * Return TRUE if the current rex.input position matches the Visual area.\n */\n    static int\nreg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n\n    // Check if the buffer is the current buffer and not using a string.\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0 || !REG_MULTI)\n\treturn FALSE;\n\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    col = (colnr_T)(rex.input - rex.line);\n    if (mode == 'v')\n    {\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\n\t// getvvcol() flushes rex.line, need to get it again\n\trex.line = reg_getline(rex.lnum);\n\trex.input = rex.line + col;\n\n\tcols = win_linetabsize(wp, rex.line, col);\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Check the regexp program for its magic number.\n * Return TRUE if it's wrong.\n */\n    static int\nprog_magic_wrong(void)\n{\n    regprog_T\t*prog;\n\n    prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;\n    if (prog->engine == &nfa_regengine)\n\t// For NFA matcher we don't check the magic\n\treturn FALSE;\n\n    if (UCHARAT(((bt_regprog_T *)prog)->program) != REGMAGIC)\n    {\n\temsg(_(e_corrupted_regexp_program));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Cleanup the subexpressions, if this wasn't done yet.\n * This construction is used to clear the subexpressions only when they are\n * used (to increase speed).\n */\n    static void\ncleanup_subexpr(void)\n{\n    if (rex.need_clear_subexpr)\n    {\n\tif (REG_MULTI)\n\t{\n\t    // Use 0xff to set lnum to -1\n\t    vim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t    vim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t}\n\telse\n\t{\n\t    vim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);\n\t    vim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);\n\t}\n\trex.need_clear_subexpr = FALSE;\n    }\n}\n\n#ifdef FEAT_SYN_HL\n    static void\ncleanup_zsubexpr(void)\n{\n    if (rex.need_clear_zsubexpr)\n    {\n\tif (REG_MULTI)\n\t{\n\t    // Use 0xff to set lnum to -1\n\t    vim_memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t    vim_memset(reg_endzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t}\n\telse\n\t{\n\t    vim_memset(reg_startzp, 0, sizeof(char_u *) * NSUBEXP);\n\t    vim_memset(reg_endzp, 0, sizeof(char_u *) * NSUBEXP);\n\t}\n\trex.need_clear_zsubexpr = FALSE;\n    }\n}\n#endif\n\n/*\n * Advance rex.lnum, rex.line and rex.input to the next line.\n */\n    static void\nreg_nextline(void)\n{\n    rex.line = reg_getline(++rex.lnum);\n    rex.input = rex.line;\n    fast_breakcheck();\n}\n\n/*\n * Check whether a backreference matches.\n * Returns RA_FAIL, RA_NOMATCH or RA_MATCH.\n * If \"bytelen\" is not NULL, it is set to the byte length of the match in the\n * last line.\n */\n    static int\nmatch_with_backref(\n    linenr_T start_lnum,\n    colnr_T  start_col,\n    linenr_T end_lnum,\n    colnr_T  end_col,\n    int\t     *bytelen)\n{\n    linenr_T\tclnum = start_lnum;\n    colnr_T\tccol = start_col;\n    int\t\tlen;\n    char_u\t*p;\n\n    if (bytelen != NULL)\n\t*bytelen = 0;\n    for (;;)\n    {\n\t// Since getting one line may invalidate the other, need to make copy.\n\t// Slow!\n\tif (rex.line != reg_tofree)\n\t{\n\t    len = (int)STRLEN(rex.line);\n\t    if (reg_tofree == NULL || len >= (int)reg_tofreelen)\n\t    {\n\t\tlen += 50;\t// get some extra\n\t\tvim_free(reg_tofree);\n\t\treg_tofree = alloc(len);\n\t\tif (reg_tofree == NULL)\n\t\t    return RA_FAIL; // out of memory!\n\t\treg_tofreelen = len;\n\t    }\n\t    STRCPY(reg_tofree, rex.line);\n\t    rex.input = reg_tofree + (rex.input - rex.line);\n\t    rex.line = reg_tofree;\n\t}\n\n\t// Get the line to compare with.\n\tp = reg_getline(clnum);\n\tif (clnum == end_lnum)\n\t    len = end_col - ccol;\n\telse\n\t    len = (int)STRLEN(p + ccol);\n\n\tif (cstrncmp(p + ccol, rex.input, &len) != 0)\n\t    return RA_NOMATCH;  // doesn't match\n\tif (bytelen != NULL)\n\t    *bytelen += len;\n\tif (clnum == end_lnum)\n\t    break;\t\t// match and at end!\n\tif (rex.lnum >= rex.reg_maxline)\n\t    return RA_NOMATCH;  // text too short\n\n\t// Advance to next line.\n\treg_nextline();\n\tif (bytelen != NULL)\n\t    *bytelen = 0;\n\t++clnum;\n\tccol = 0;\n\tif (got_int)\n\t    return RA_FAIL;\n    }\n\n    // found a match!  Note that rex.line may now point to a copy of the line,\n    // that should not matter.\n    return RA_MATCH;\n}\n\n/*\n * Used in a place where no * or \\+ can follow.\n */\n    static int\nre_mult_next(char *what)\n{\n    if (re_multi_type(peekchr()) == MULTI_MULT)\n    {\n       semsg(_(e_nfa_regexp_cannot_repeat_str), what);\n       rc_did_emsg = TRUE;\n       return FAIL;\n    }\n    return OK;\n}\n\ntypedef struct\n{\n    int a, b, c;\n} decomp_T;\n\n\n// 0xfb20 - 0xfb4f\nstatic decomp_T decomp_table[0xfb4f-0xfb20+1] =\n{\n    {0x5e2,0,0},\t\t// 0xfb20\talt ayin\n    {0x5d0,0,0},\t\t// 0xfb21\talt alef\n    {0x5d3,0,0},\t\t// 0xfb22\talt dalet\n    {0x5d4,0,0},\t\t// 0xfb23\talt he\n    {0x5db,0,0},\t\t// 0xfb24\talt kaf\n    {0x5dc,0,0},\t\t// 0xfb25\talt lamed\n    {0x5dd,0,0},\t\t// 0xfb26\talt mem-sofit\n    {0x5e8,0,0},\t\t// 0xfb27\talt resh\n    {0x5ea,0,0},\t\t// 0xfb28\talt tav\n    {'+', 0, 0},\t\t// 0xfb29\talt plus\n    {0x5e9, 0x5c1, 0},\t\t// 0xfb2a\tshin+shin-dot\n    {0x5e9, 0x5c2, 0},\t\t// 0xfb2b\tshin+sin-dot\n    {0x5e9, 0x5c1, 0x5bc},\t// 0xfb2c\tshin+shin-dot+dagesh\n    {0x5e9, 0x5c2, 0x5bc},\t// 0xfb2d\tshin+sin-dot+dagesh\n    {0x5d0, 0x5b7, 0},\t\t// 0xfb2e\talef+patah\n    {0x5d0, 0x5b8, 0},\t\t// 0xfb2f\talef+qamats\n    {0x5d0, 0x5b4, 0},\t\t// 0xfb30\talef+hiriq\n    {0x5d1, 0x5bc, 0},\t\t// 0xfb31\tbet+dagesh\n    {0x5d2, 0x5bc, 0},\t\t// 0xfb32\tgimel+dagesh\n    {0x5d3, 0x5bc, 0},\t\t// 0xfb33\tdalet+dagesh\n    {0x5d4, 0x5bc, 0},\t\t// 0xfb34\the+dagesh\n    {0x5d5, 0x5bc, 0},\t\t// 0xfb35\tvav+dagesh\n    {0x5d6, 0x5bc, 0},\t\t// 0xfb36\tzayin+dagesh\n    {0xfb37, 0, 0},\t\t// 0xfb37 -- UNUSED\n    {0x5d8, 0x5bc, 0},\t\t// 0xfb38\ttet+dagesh\n    {0x5d9, 0x5bc, 0},\t\t// 0xfb39\tyud+dagesh\n    {0x5da, 0x5bc, 0},\t\t// 0xfb3a\tkaf sofit+dagesh\n    {0x5db, 0x5bc, 0},\t\t// 0xfb3b\tkaf+dagesh\n    {0x5dc, 0x5bc, 0},\t\t// 0xfb3c\tlamed+dagesh\n    {0xfb3d, 0, 0},\t\t// 0xfb3d -- UNUSED\n    {0x5de, 0x5bc, 0},\t\t// 0xfb3e\tmem+dagesh\n    {0xfb3f, 0, 0},\t\t// 0xfb3f -- UNUSED\n    {0x5e0, 0x5bc, 0},\t\t// 0xfb40\tnun+dagesh\n    {0x5e1, 0x5bc, 0},\t\t// 0xfb41\tsamech+dagesh\n    {0xfb42, 0, 0},\t\t// 0xfb42 -- UNUSED\n    {0x5e3, 0x5bc, 0},\t\t// 0xfb43\tpe sofit+dagesh\n    {0x5e4, 0x5bc,0},\t\t// 0xfb44\tpe+dagesh\n    {0xfb45, 0, 0},\t\t// 0xfb45 -- UNUSED\n    {0x5e6, 0x5bc, 0},\t\t// 0xfb46\ttsadi+dagesh\n    {0x5e7, 0x5bc, 0},\t\t// 0xfb47\tqof+dagesh\n    {0x5e8, 0x5bc, 0},\t\t// 0xfb48\tresh+dagesh\n    {0x5e9, 0x5bc, 0},\t\t// 0xfb49\tshin+dagesh\n    {0x5ea, 0x5bc, 0},\t\t// 0xfb4a\ttav+dagesh\n    {0x5d5, 0x5b9, 0},\t\t// 0xfb4b\tvav+holam\n    {0x5d1, 0x5bf, 0},\t\t// 0xfb4c\tbet+rafe\n    {0x5db, 0x5bf, 0},\t\t// 0xfb4d\tkaf+rafe\n    {0x5e4, 0x5bf, 0},\t\t// 0xfb4e\tpe+rafe\n    {0x5d0, 0x5dc, 0}\t\t// 0xfb4f\talef-lamed\n};\n\n    static void\nmb_decompose(int c, int *c1, int *c2, int *c3)\n{\n    decomp_T d;\n\n    if (c >= 0xfb20 && c <= 0xfb4f)\n    {\n\td = decomp_table[c - 0xfb20];\n\t*c1 = d.a;\n\t*c2 = d.b;\n\t*c3 = d.c;\n    }\n    else\n    {\n\t*c1 = c;\n\t*c2 = *c3 = 0;\n    }\n}\n\n/*\n * Compare two strings, ignore case if rex.reg_ic set.\n * Return 0 if strings match, non-zero otherwise.\n * Correct the length \"*n\" when composing characters are ignored.\n */\n    static int\ncstrncmp(char_u *s1, char_u *s2, int *n)\n{\n    int\t\tresult;\n\n    if (!rex.reg_ic)\n\tresult = STRNCMP(s1, s2, *n);\n    else\n\tresult = MB_STRNICMP(s1, s2, *n);\n\n    // if it failed and it's utf8 and we want to combineignore:\n    if (result != 0 && enc_utf8 && rex.reg_icombine)\n    {\n\tchar_u\t*str1, *str2;\n\tint\tc1, c2, c11, c12;\n\tint\tjunk;\n\n\t// we have to handle the strcmp ourselves, since it is necessary to\n\t// deal with the composing characters by ignoring them:\n\tstr1 = s1;\n\tstr2 = s2;\n\tc1 = c2 = 0;\n\twhile ((int)(str1 - s1) < *n)\n\t{\n\t    c1 = mb_ptr2char_adv(&str1);\n\t    c2 = mb_ptr2char_adv(&str2);\n\n\t    // Decompose the character if necessary, into 'base' characters.\n\t    // Currently hard-coded for Hebrew, Arabic to be done...\n\t    if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))\n\t    {\n\t\t// decomposition necessary?\n\t\tmb_decompose(c1, &c11, &junk, &junk);\n\t\tmb_decompose(c2, &c12, &junk, &junk);\n\t\tc1 = c11;\n\t\tc2 = c12;\n\t\tif (c11 != c12\n\t\t\t    && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12)))\n\t\t    break;\n\t    }\n\t}\n\tresult = c2 - c1;\n\tif (result == 0)\n\t    *n = (int)(str2 - s2);\n    }\n\n    return result;\n}\n\n/*\n * cstrchr: This function is used a lot for simple searches, keep it fast!\n */\n    static char_u *\ncstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    // tolower() and toupper() can be slow, comparing twice should be a lot\n    // faster (esp. when using MS Visual C++!).\n    // For UTF-8 need to use folded case.\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tif (utf_fold(utf_ptr2char(p)) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\t// Faster version for when there are no multi-byte characters.\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}\n\n////////////////////////////////////////////////////////////////\n//\t\t      regsub stuff\t\t\t      //\n////////////////////////////////////////////////////////////////\n\n/*\n * We should define ftpr as a pointer to a function returning a pointer to\n * a function returning a pointer to a function ...\n * This is impossible, so we declare a pointer to a function returning a\n * void pointer. This should work for all compilers.\n */\ntypedef void (*(*fptr_T)(int *, int));\n\nstatic int vim_regsub_both(char_u *source, typval_T *expr, char_u *dest, int destlen, int flags);\n\n    static fptr_T\ndo_upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)do_Upper;\n}\n\n    static fptr_T\ndo_lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)do_Lower;\n}\n\n/*\n * regtilde(): Replace tildes in the pattern by the old pattern.\n *\n * Short explanation of the tilde: It stands for the previous replacement\n * pattern.  If that previous pattern also contains a ~ we should go back a\n * step further...  But we insert the previous pattern into the current one\n * and remember that.\n * This still does not handle the case where \"magic\" changes.  So require the\n * user to keep his hands off of \"magic\".\n *\n * The tildes are parsed once before the first call to vim_regsub().\n */\n    char_u *\nregtilde(char_u *source, int magic)\n{\n    char_u\t*newsub = source;\n    char_u\t*tmpsub;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tprevlen;\n\n    for (p = newsub; *p; ++p)\n    {\n\tif ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic))\n\t{\n\t    if (reg_prev_sub != NULL)\n\t    {\n\t\t// length = len(newsub) - 1 + len(prev_sub) + 1\n\t\tprevlen = (int)STRLEN(reg_prev_sub);\n\t\ttmpsub = alloc(STRLEN(newsub) + prevlen);\n\t\tif (tmpsub != NULL)\n\t\t{\n\t\t    // copy prefix\n\t\t    len = (int)(p - newsub);\t// not including ~\n\t\t    mch_memmove(tmpsub, newsub, (size_t)len);\n\t\t    // interpret tilde\n\t\t    mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);\n\t\t    // copy postfix\n\t\t    if (!magic)\n\t\t\t++p;\t\t\t// back off backslash\n\t\t    STRCPY(tmpsub + len + prevlen, p + 1);\n\n\t\t    if (newsub != source)\t// already allocated newsub\n\t\t\tvim_free(newsub);\n\t\t    newsub = tmpsub;\n\t\t    p = newsub + len + prevlen;\n\t\t}\n\t    }\n\t    else if (magic)\n\t\tSTRMOVE(p, p + 1);\t// remove '~'\n\t    else\n\t\tSTRMOVE(p, p + 2);\t// remove '\\~'\n\t    --p;\n\t}\n\telse\n\t{\n\t    if (*p == '\\\\' && p[1])\t\t// skip escaped characters\n\t\t++p;\n\t    if (has_mbyte)\n\t\tp += (*mb_ptr2len)(p) - 1;\n\t}\n    }\n\n    // Store a copy of newsub  in reg_prev_sub.  It is always allocated,\n    // because recursive calls may make the returned string invalid.\n    vim_free(reg_prev_sub);\n    reg_prev_sub = vim_strsave(newsub);\n\n    return newsub;\n}\n\n#ifdef FEAT_EVAL\nstatic int can_f_submatch = FALSE;\t// TRUE when submatch() can be used\n\n// These pointers are used for reg_submatch().  Needed for when the\n// substitution string is an expression that contains a call to substitute()\n// and submatch().\ntypedef struct {\n    regmatch_T\t*sm_match;\n    regmmatch_T\t*sm_mmatch;\n    linenr_T\tsm_firstlnum;\n    linenr_T\tsm_maxline;\n    int\t\tsm_line_lbr;\n} regsubmatch_T;\n\nstatic regsubmatch_T rsm;  // can only be used when can_f_submatch is TRUE\n#endif\n\n#ifdef FEAT_EVAL\n\n/*\n * Put the submatches in \"argv[argskip]\" which is a list passed into\n * call_func() by vim_regsub_both().\n */\n    static int\nfill_submatch_list(int argc UNUSED, typval_T *argv, int argskip, int argcount)\n{\n    listitem_T\t*li;\n    int\t\ti;\n    char_u\t*s;\n    typval_T\t*listarg = argv + argskip;\n\n    if (argcount == argskip)\n\t// called function doesn't take a submatches argument\n\treturn argskip;\n\n    // Relies on sl_list to be the first item in staticList10_T.\n    init_static_list((staticList10_T *)(listarg->vval.v_list));\n\n    // There are always 10 list items in staticList10_T.\n    li = listarg->vval.v_list->lv_first;\n    for (i = 0; i < 10; ++i)\n    {\n\ts = rsm.sm_match->startp[i];\n\tif (s == NULL || rsm.sm_match->endp[i] == NULL)\n\t    s = NULL;\n\telse\n\t    s = vim_strnsave(s, rsm.sm_match->endp[i] - s);\n\tli->li_tv.v_type = VAR_STRING;\n\tli->li_tv.vval.v_string = s;\n\tli = li->li_next;\n    }\n    return argskip + 1;\n}\n\n    static void\nclear_submatch_list(staticList10_T *sl)\n{\n    int i;\n\n    for (i = 0; i < 10; ++i)\n\tvim_free(sl->sl_items[i].li_tv.vval.v_string);\n}\n#endif\n\n/*\n * vim_regsub() - perform substitutions after a vim_regexec() or\n * vim_regexec_multi() match.\n *\n * If \"flags\" has REGSUB_COPY really copy into \"dest[destlen]\".\n * Oterwise nothing is copied, only compue the length of the result.\n *\n * If \"flags\" has REGSUB_MAGIC then behave like 'magic' is set.\n *\n * If \"flags\" has REGSUB_BACKSLASH a backslash will be removed later, need to\n * double them to keep them, and insert a backslash before a CR to avoid it\n * being replaced with a line break later.\n *\n * Note: The matched text must not change between the call of\n * vim_regexec()/vim_regexec_multi() and vim_regsub()!  It would make the back\n * references invalid!\n *\n * Returns the size of the replacement, including terminating NUL.\n */\n    int\nvim_regsub(\n    regmatch_T\t*rmp,\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = rmp;\n    rex.reg_mmatch = NULL;\n    rex.reg_maxline = 0;\n    rex.reg_buf = curbuf;\n    rex.reg_line_lbr = TRUE;\n    result = vim_regsub_both(source, expr, dest, destlen, flags);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n    int\nvim_regsub_multi(\n    regmmatch_T\t*rmp,\n    linenr_T\tlnum,\n    char_u\t*source,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = curbuf;\t// always works on the current buffer!\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    result = vim_regsub_both(source, NULL, dest, destlen, flags);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n// When nesting more than a couple levels it's probably a mistake.\n# define MAX_REGSUB_NESTING 4\nstatic char_u   *eval_result[MAX_REGSUB_NESTING] = {NULL, NULL, NULL, NULL};\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_resub_eval_result(void)\n{\n    int i;\n\n    for (i = 0; i < MAX_REGSUB_NESTING; ++i)\n\tVIM_CLEAR(eval_result[i]);\n}\n# endif\n#endif\n\n    static int\nvim_regsub_both(\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*s;\n    int\t\tc;\n    int\t\tcc;\n    int\t\tno = -1;\n    fptr_T\tfunc_all = (fptr_T)NULL;\n    fptr_T\tfunc_one = (fptr_T)NULL;\n    linenr_T\tclnum = 0;\t// init for GCC\n    int\t\tlen = 0;\t// init for GCC\n#ifdef FEAT_EVAL\n    static int  nesting = 0;\n    int\t\tnested;\n#endif\n    int\t\tcopy = flags & REGSUB_COPY;\n\n    // Be paranoid...\n    if ((source == NULL && expr == NULL) || dest == NULL)\n    {\n\temsg(_(e_null_argument));\n\treturn 0;\n    }\n    if (prog_magic_wrong())\n\treturn 0;\n#ifdef FEAT_EVAL\n    if (nesting == MAX_REGSUB_NESTING)\n    {\n\temsg(_(e_substitute_nesting_too_deep));\n\treturn 0;\n    }\n    nested = nesting;\n#endif\n    src = source;\n    dst = dest;\n\n    /*\n     * When the substitute part starts with \"\\=\" evaluate it as an expression.\n     */\n    if (expr != NULL || (source[0] == '\\\\' && source[1] == '='))\n    {\n#ifdef FEAT_EVAL\n\t// To make sure that the length doesn't change between checking the\n\t// length and copying the string, and to speed up things, the\n\t// resulting string is saved from the call with\n\t// \"flags & REGSUB_COPY\" == 0 to the call with\n\t// \"flags & REGSUB_COPY\" != 0.\n\tif (copy)\n\t{\n\t    if (eval_result[nested] != NULL)\n\t    {\n\t\tSTRCPY(dest, eval_result[nested]);\n\t\tdst += STRLEN(eval_result[nested]);\n\t\tVIM_CLEAR(eval_result[nested]);\n\t    }\n\t}\n\telse\n\t{\n\t    int\t\t    prev_can_f_submatch = can_f_submatch;\n\t    regsubmatch_T   rsm_save;\n\n\t    VIM_CLEAR(eval_result[nested]);\n\n\t    // The expression may contain substitute(), which calls us\n\t    // recursively.  Make sure submatch() gets the text from the first\n\t    // level.\n\t    if (can_f_submatch)\n\t\trsm_save = rsm;\n\t    can_f_submatch = TRUE;\n\t    rsm.sm_match = rex.reg_match;\n\t    rsm.sm_mmatch = rex.reg_mmatch;\n\t    rsm.sm_firstlnum = rex.reg_firstlnum;\n\t    rsm.sm_maxline = rex.reg_maxline;\n\t    rsm.sm_line_lbr = rex.reg_line_lbr;\n\n\t    // Although unlikely, it is possible that the expression invokes a\n\t    // substitute command (it might fail, but still).  Therefore keep\n\t    // an array of eval results.\n\t    ++nesting;\n\n\t    if (expr != NULL)\n\t    {\n\t\ttypval_T\targv[2];\n\t\tchar_u\t\tbuf[NUMBUFLEN];\n\t\ttypval_T\trettv;\n\t\tstaticList10_T\tmatchList;\n\t\tfuncexe_T\tfuncexe;\n\n\t\trettv.v_type = VAR_STRING;\n\t\trettv.vval.v_string = NULL;\n\t\targv[0].v_type = VAR_LIST;\n\t\targv[0].vval.v_list = &matchList.sl_list;\n\t\tmatchList.sl_list.lv_len = 0;\n\t\tCLEAR_FIELD(funcexe);\n\t\tfuncexe.fe_argv_func = fill_submatch_list;\n\t\tfuncexe.fe_evaluate = TRUE;\n\t\tif (expr->v_type == VAR_FUNC)\n\t\t{\n\t\t    s = expr->vval.v_string;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_PARTIAL)\n\t\t{\n\t\t    partial_T   *partial = expr->vval.v_partial;\n\n\t\t    s = partial_name(partial);\n\t\t    funcexe.fe_partial = partial;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_INSTR)\n\t\t{\n\t\t    exe_typval_instr(expr, &rettv);\n\t\t}\n\t\tif (matchList.sl_list.lv_len > 0)\n\t\t    // fill_submatch_list() was called\n\t\t    clear_submatch_list(&matchList);\n\n\t\tif (rettv.v_type == VAR_UNKNOWN)\n\t\t    // something failed, no need to report another error\n\t\t    eval_result[nested] = NULL;\n\t\telse\n\t\t{\n\t\t    eval_result[nested] = tv_get_string_buf_chk(&rettv, buf);\n\t\t    if (eval_result[nested] != NULL)\n\t\t\teval_result[nested] = vim_strsave(eval_result[nested]);\n\t\t}\n\t\tclear_tv(&rettv);\n\t    }\n\t    else if (substitute_instr != NULL)\n\t\t// Execute instructions from ISN_SUBSTITUTE.\n\t\teval_result[nested] = exe_substitute_instr();\n\t    else\n\t\teval_result[nested] = eval_to_string(source + 2, TRUE);\n\t    --nesting;\n\n\t    if (eval_result[nested] != NULL)\n\t    {\n\t\tint had_backslash = FALSE;\n\n\t\tfor (s = eval_result[nested]; *s != NUL; MB_PTR_ADV(s))\n\t\t{\n\t\t    // Change NL to CR, so that it becomes a line break,\n\t\t    // unless called from vim_regexec_nl().\n\t\t    // Skip over a backslashed character.\n\t\t    if (*s == NL && !rsm.sm_line_lbr)\n\t\t\t*s = CAR;\n\t\t    else if (*s == '\\\\' && s[1] != NUL)\n\t\t    {\n\t\t\t++s;\n\t\t\t/* Change NL to CR here too, so that this works:\n\t\t\t * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:\n\t\t\t *   abc\\\n\t\t\t *   def\n\t\t\t * Not when called from vim_regexec_nl().\n\t\t\t */\n\t\t\tif (*s == NL && !rsm.sm_line_lbr)\n\t\t\t    *s = CAR;\n\t\t\thad_backslash = TRUE;\n\t\t    }\n\t\t}\n\t\tif (had_backslash && (flags & REGSUB_BACKSLASH))\n\t\t{\n\t\t    // Backslashes will be consumed, need to double them.\n\t\t    s = vim_strsave_escaped(eval_result[nested], (char_u *)\"\\\\\");\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tvim_free(eval_result[nested]);\n\t\t\teval_result[nested] = s;\n\t\t    }\n\t\t}\n\n\t\tdst += STRLEN(eval_result[nested]);\n\t    }\n\n\t    can_f_submatch = prev_can_f_submatch;\n\t    if (can_f_submatch)\n\t\trsm = rsm_save;\n\t}\n#endif\n    }\n    else\n      while ((c = *src++) != NUL)\n      {\n\tif (c == '&' && (flags & REGSUB_MAGIC))\n\t    no = 0;\n\telse if (c == '\\\\' && *src != NUL)\n\t{\n\t    if (*src == '&' && !(flags & REGSUB_MAGIC))\n\t    {\n\t\t++src;\n\t\tno = 0;\n\t    }\n\t    else if ('0' <= *src && *src <= '9')\n\t    {\n\t\tno = *src++ - '0';\n\t    }\n\t    else if (vim_strchr((char_u *)\"uUlLeE\", *src))\n\t    {\n\t\tswitch (*src++)\n\t\t{\n\t\tcase 'u':   func_one = (fptr_T)do_upper;\n\t\t\t    continue;\n\t\tcase 'U':   func_all = (fptr_T)do_Upper;\n\t\t\t    continue;\n\t\tcase 'l':   func_one = (fptr_T)do_lower;\n\t\t\t    continue;\n\t\tcase 'L':   func_all = (fptr_T)do_Lower;\n\t\t\t    continue;\n\t\tcase 'e':\n\t\tcase 'E':   func_one = func_all = (fptr_T)NULL;\n\t\t\t    continue;\n\t\t}\n\t    }\n\t}\n\tif (no < 0)\t      // Ordinary character.\n\t{\n\t    if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL)\n\t    {\n\t\t// Copy a special key as-is.\n\t\tif (copy)\n\t\t{\n\t\t    if (dst + 3 > dest + destlen)\n\t\t    {\n\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\treturn 0;\n\t\t    }\n\t\t    *dst++ = c;\n\t\t    *dst++ = *src++;\n\t\t    *dst++ = *src++;\n\t\t}\n\t\telse\n\t\t{\n\t\t    dst += 3;\n\t\t    src += 2;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c == '\\\\' && *src != NUL)\n\t    {\n\t\t// Check for abbreviations -- webb\n\t\tswitch (*src)\n\t\t{\n\t\t    case 'r':\tc = CAR;\t++src;\tbreak;\n\t\t    case 'n':\tc = NL;\t\t++src;\tbreak;\n\t\t    case 't':\tc = TAB;\t++src;\tbreak;\n\t\t // Oh no!  \\e already has meaning in subst pat :-(\n\t\t // case 'e':   c = ESC;\t++src;\tbreak;\n\t\t    case 'b':\tc = Ctrl_H;\t++src;\tbreak;\n\n\t\t    // If \"backslash\" is TRUE the backslash will be removed\n\t\t    // later.  Used to insert a literal CR.\n\t\t    default:\tif (flags & REGSUB_BACKSLASH)\n\t\t\t\t{\n\t\t\t\t    if (copy)\n\t\t\t\t    {\n\t\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t\t{\n\t\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t\t    return 0;\n\t\t\t\t\t}\n\t\t\t\t\t*dst = '\\\\';\n\t\t\t\t    }\n\t\t\t\t    ++dst;\n\t\t\t\t}\n\t\t\t\tc = *src++;\n\t\t}\n\t    }\n\t    else if (has_mbyte)\n\t\tc = mb_ptr2char(src - 1);\n\n\t    // Write to buffer, if copy is set.\n\t    if (func_one != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t    else if (func_all != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t    else // just copy\n\t\tcc = c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tint totlen = mb_ptr2len(src - 1);\n\t\tint charlen = mb_char2len(cc);\n\n\t\tif (copy)\n\t\t{\n\t\t    if (dst + charlen > dest + destlen)\n\t\t    {\n\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\treturn 0;\n\t\t    }\n\t\t    mb_char2bytes(cc, dst);\n\t\t}\n\t\tdst += charlen - 1;\n\t\tif (enc_utf8)\n\t\t{\n\t\t    int clen = utf_ptr2len(src - 1);\n\n\t\t    // If the character length is shorter than \"totlen\", there\n\t\t    // are composing characters; copy them as-is.\n\t\t    if (clen < totlen)\n\t\t    {\n\t\t\tif (copy)\n\t\t\t{\n\t\t\t    if (dst + totlen - clen > dest + destlen)\n\t\t\t    {\n\t\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\treturn 0;\n\t\t\t    }\n\t\t\t    mch_memmove(dst + 1, src - 1 + clen,\n\t\t\t\t\t\t     (size_t)(totlen - clen));\n\t\t\t}\n\t\t\tdst += totlen - clen;\n\t\t    }\n\t\t}\n\t\tsrc += totlen - 1;\n\t    }\n\t    else if (copy)\n\t    {\n\t\tif (dst + 1 > dest + destlen)\n\t\t{\n\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t    return 0;\n\t\t}\n\t\t*dst = cc;\n\t    }\n\t    dst++;\n\t}\n\telse\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\tclnum = rex.reg_mmatch->startpos[no].lnum;\n\t\tif (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0)\n\t\t    s = NULL;\n\t\telse\n\t\t{\n\t\t    s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;\n\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\tlen = rex.reg_mmatch->endpos[no].col\n\t\t\t\t\t    - rex.reg_mmatch->startpos[no].col;\n\t\t    else\n\t\t\tlen = (int)STRLEN(s);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ts = rex.reg_match->startp[no];\n\t\tif (rex.reg_match->endp[no] == NULL)\n\t\t    s = NULL;\n\t\telse\n\t\t    len = (int)(rex.reg_match->endp[no] - s);\n\t    }\n\t    if (s != NULL)\n\t    {\n\t\tfor (;;)\n\t\t{\n\t\t    if (len == 0)\n\t\t    {\n\t\t\tif (REG_MULTI)\n\t\t\t{\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tbreak;\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\t*dst = CAR;\n\t\t\t    }\n\t\t\t    ++dst;\n\t\t\t    s = reg_getline(++clnum);\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tlen = rex.reg_mmatch->endpos[no].col;\n\t\t\t    else\n\t\t\t\tlen = (int)STRLEN(s);\n\t\t\t}\n\t\t\telse\n\t\t\t    break;\n\t\t    }\n\t\t    else if (*s == NUL) // we hit NUL.\n\t\t    {\n\t\t\tif (copy)\n\t\t\t    iemsg(_(e_damaged_match_string));\n\t\t\tgoto exit;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif ((flags & REGSUB_BACKSLASH)\n\t\t\t\t\t\t  && (*s == CAR || *s == '\\\\'))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Insert a backslash in front of a CR, otherwise\n\t\t\t     * it will be replaced by a line break.\n\t\t\t     * Number of backslashes will be halved later,\n\t\t\t     * double them here.\n\t\t\t     */\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 2 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\tdst[0] = '\\\\';\n\t\t\t\tdst[1] = *s;\n\t\t\t    }\n\t\t\t    dst += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (has_mbyte)\n\t\t\t\tc = mb_ptr2char(s);\n\t\t\t    else\n\t\t\t\tc = *s;\n\n\t\t\t    if (func_one != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t\t\t    else if (func_all != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t\t\t    else // just copy\n\t\t\t\tcc = c;\n\n\t\t\t    if (has_mbyte)\n\t\t\t    {\n\t\t\t\tint l;\n\t\t\t\tint charlen;\n\n\t\t\t\t// Copy composing characters separately, one\n\t\t\t\t// at a time.\n\t\t\t\tif (enc_utf8)\n\t\t\t\t    l = utf_ptr2len(s) - 1;\n\t\t\t\telse\n\t\t\t\t    l = mb_ptr2len(s) - 1;\n\n\t\t\t\ts += l;\n\t\t\t\tlen -= l;\n\t\t\t\tcharlen = mb_char2len(cc);\n\t\t\t\tif (copy)\n\t\t\t\t{\n\t\t\t\t    if (dst + charlen > dest + destlen)\n\t\t\t\t    {\n\t\t\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t\treturn 0;\n\t\t\t\t    }\n\t\t\t\t    mb_char2bytes(cc, dst);\n\t\t\t\t}\n\t\t\t\tdst += charlen - 1;\n\t\t\t    }\n\t\t\t    else if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\t*dst = cc;\n\t\t\t    }\n\t\t\t    dst++;\n\t\t\t}\n\n\t\t\t++s;\n\t\t\t--len;\n\t\t    }\n\t\t}\n\t    }\n\t    no = -1;\n\t}\n      }\n    if (copy)\n\t*dst = NUL;\n\nexit:\n    return (int)((dst - dest) + 1);\n}\n\n#ifdef FEAT_EVAL\n/*\n * Call reg_getline() with the line numbers from the submatch.  If a\n * substitute() was used the reg_maxline and other values have been\n * overwritten.\n */\n    static char_u *\nreg_getline_submatch(linenr_T lnum)\n{\n    char_u *s;\n    linenr_T save_first = rex.reg_firstlnum;\n    linenr_T save_max = rex.reg_maxline;\n\n    rex.reg_firstlnum = rsm.sm_firstlnum;\n    rex.reg_maxline = rsm.sm_maxline;\n\n    s = reg_getline(lnum);\n\n    rex.reg_firstlnum = save_first;\n    rex.reg_maxline = save_max;\n    return s;\n}\n\n/*\n * Used for the submatch() function: get the string from the n'th submatch in\n * allocated memory.\n * Returns NULL when not in a \":s\" command and for a non-existing submatch.\n */\n    char_u *\nreg_submatch(int no)\n{\n    char_u\t*retval = NULL;\n    char_u\t*s;\n    int\t\tlen;\n    int\t\tround;\n    linenr_T\tlnum;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\t/*\n\t * First round: compute the length and allocate memory.\n\t * Second round: copy the text.\n\t */\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    lnum = rsm.sm_mmatch->startpos[no].lnum;\n\t    if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0)\n\t\treturn NULL;\n\n\t    s = reg_getline_submatch(lnum);\n\t    if (s == NULL)  // anti-crash check, cannot happen?\n\t\tbreak;\n\t    s += rsm.sm_mmatch->startpos[no].col;\n\t    if (rsm.sm_mmatch->endpos[no].lnum == lnum)\n\t    {\n\t\t// Within one line: take form start to end col.\n\t\tlen = rsm.sm_mmatch->endpos[no].col\n\t\t\t\t\t  - rsm.sm_mmatch->startpos[no].col;\n\t\tif (round == 2)\n\t\t    vim_strncpy(retval, s, len);\n\t\t++len;\n\t    }\n\t    else\n\t    {\n\t\t// Multiple lines: take start line from start col, middle\n\t\t// lines completely and end line up to end col.\n\t\tlen = (int)STRLEN(s);\n\t\tif (round == 2)\n\t\t{\n\t\t    STRCPY(retval, s);\n\t\t    retval[len] = '\\n';\n\t\t}\n\t\t++len;\n\t\t++lnum;\n\t\twhile (lnum < rsm.sm_mmatch->endpos[no].lnum)\n\t\t{\n\t\t    s = reg_getline_submatch(lnum++);\n\t\t    if (round == 2)\n\t\t\tSTRCPY(retval + len, s);\n\t\t    len += (int)STRLEN(s);\n\t\t    if (round == 2)\n\t\t\tretval[len] = '\\n';\n\t\t    ++len;\n\t\t}\n\t\tif (round == 2)\n\t\t    STRNCPY(retval + len, reg_getline_submatch(lnum),\n\t\t\t\t\t     rsm.sm_mmatch->endpos[no].col);\n\t\tlen += rsm.sm_mmatch->endpos[no].col;\n\t\tif (round == 2)\n\t\t    retval[len] = NUL;\n\t\t++len;\n\t    }\n\n\t    if (retval == NULL)\n\t    {\n\t\tretval = alloc(len);\n\t\tif (retval == NULL)\n\t\t    return NULL;\n\t    }\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    retval = NULL;\n\telse\n\t    retval = vim_strnsave(s, rsm.sm_match->endp[no] - s);\n    }\n\n    return retval;\n}\n\n/*\n * Used for the submatch() function with the optional non-zero argument: get\n * the list of strings from the n'th submatch in allocated memory with NULs\n * represented in NLs.\n * Returns a list of allocated strings.  Returns NULL when not in a \":s\"\n * command, for a non-existing submatch and for any error.\n */\n    list_T *\nreg_submatch_list(int no)\n{\n    char_u\t*s;\n    linenr_T\tslnum;\n    linenr_T\telnum;\n    colnr_T\tscol;\n    colnr_T\tecol;\n    int\t\ti;\n    list_T\t*list;\n    int\t\terror = FALSE;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\tslnum = rsm.sm_mmatch->startpos[no].lnum;\n\telnum = rsm.sm_mmatch->endpos[no].lnum;\n\tif (slnum < 0 || elnum < 0)\n\t    return NULL;\n\n\tscol = rsm.sm_mmatch->startpos[no].col;\n\tecol = rsm.sm_mmatch->endpos[no].col;\n\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\n\ts = reg_getline_submatch(slnum) + scol;\n\tif (slnum == elnum)\n\t{\n\t    if (list_append_string(list, s, ecol - scol) == FAIL)\n\t\terror = TRUE;\n\t}\n\telse\n\t{\n\t    if (list_append_string(list, s, -1) == FAIL)\n\t\terror = TRUE;\n\t    for (i = 1; i < elnum - slnum; i++)\n\t    {\n\t\ts = reg_getline_submatch(slnum + i);\n\t\tif (list_append_string(list, s, -1) == FAIL)\n\t\t    error = TRUE;\n\t    }\n\t    s = reg_getline_submatch(elnum);\n\t    if (list_append_string(list, s, ecol) == FAIL)\n\t\terror = TRUE;\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    return NULL;\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\tif (list_append_string(list, s,\n\t\t\t\t (int)(rsm.sm_match->endp[no] - s)) == FAIL)\n\t    error = TRUE;\n    }\n\n    if (error)\n    {\n\tlist_free(list);\n\treturn NULL;\n    }\n    ++list->lv_refcount;\n    return list;\n}\n#endif\n\n/*\n * Initialize the values used for matching against multiple lines\n */\n    static void\ninit_regexec_multi(\n\tregmmatch_T\t*rmp,\n\twin_T\t\t*win,\t// window in which to search or NULL\n\tbuf_T\t\t*buf,\t// buffer in which to search\n\tlinenr_T\tlnum)\t// nr of line to start looking for match\n{\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = buf;\n    rex.reg_win = win;\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    rex.reg_ic = rmp->rmm_ic;\n    rex.reg_icombine = FALSE;\n    rex.reg_maxcol = rmp->rmm_maxcol;\n}\n\n#include \"regexp_bt.c\"\n\nstatic regengine_T bt_regengine =\n{\n    bt_regcomp,\n    bt_regfree,\n    bt_regexec_nl,\n    bt_regexec_multi,\n};\n\n#include \"regexp_nfa.c\"\n\nstatic regengine_T nfa_regengine =\n{\n    nfa_regcomp,\n    nfa_regfree,\n    nfa_regexec_nl,\n    nfa_regexec_multi,\n};\n\n// Which regexp engine to use? Needed for vim_regcomp().\n// Must match with 'regexpengine'.\nstatic int regexp_engine = 0;\n\n#ifdef DEBUG\nstatic char_u regname[][30] = {\n\t\t    \"AUTOMATIC Regexp Engine\",\n\t\t    \"BACKTRACKING Regexp Engine\",\n\t\t    \"NFA Regexp Engine\"\n\t\t\t    };\n#endif\n\n/*\n * Compile a regular expression into internal code.\n * Returns the program in allocated memory.\n * Use vim_regfree() to free the memory.\n * Returns NULL for an error.\n */\n    regprog_T *\nvim_regcomp(char_u *expr_arg, int re_flags)\n{\n    regprog_T   *prog = NULL;\n    char_u\t*expr = expr_arg;\n    int\t\tcalled_emsg_before;\n\n    regexp_engine = p_re;\n\n    // Check for prefix \"\\%#=\", that sets the regexp engine\n    if (STRNCMP(expr, \"\\\\%#=\", 4) == 0)\n    {\n\tint newengine = expr[4] - '0';\n\n\tif (newengine == AUTOMATIC_ENGINE\n\t    || newengine == BACKTRACKING_ENGINE\n\t    || newengine == NFA_ENGINE)\n\t{\n\t    regexp_engine = expr[4] - '0';\n\t    expr += 5;\n#ifdef DEBUG\n\t    smsg(\"New regexp mode selected (%d): %s\",\n\t\t\t\t\t   regexp_engine, regname[newengine]);\n#endif\n\t}\n\telse\n\t{\n\t    emsg(_(e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used));\n\t    regexp_engine = AUTOMATIC_ENGINE;\n\t}\n    }\n#ifdef DEBUG\n    bt_regengine.expr = expr;\n    nfa_regengine.expr = expr;\n#endif\n    // reg_iswordc() uses rex.reg_buf\n    rex.reg_buf = curbuf;\n\n    /*\n     * First try the NFA engine, unless backtracking was requested.\n     */\n    called_emsg_before = called_emsg;\n    if (regexp_engine != BACKTRACKING_ENGINE)\n\tprog = nfa_regengine.regcomp(expr,\n\t\tre_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n    else\n\tprog = bt_regengine.regcomp(expr, re_flags);\n\n    // Check for error compiling regexp with initial engine.\n    if (prog == NULL)\n    {\n#ifdef BT_REGEXP_DEBUG_LOG\n\tif (regexp_engine == BACKTRACKING_ENGINE)   // debugging log for BT engine\n\t{\n\t    FILE *f;\n\t    f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \"a\");\n\t    if (f)\n\t    {\n\t\tfprintf(f, \"Syntax error in \\\"%s\\\"\\n\", expr);\n\t\tfclose(f);\n\t    }\n\t    else\n\t\tsemsg(\"(NFA) Could not open \\\"%s\\\" to write !!!\",\n\t\t\tBT_REGEXP_DEBUG_LOG_NAME);\n\t}\n#endif\n\t/*\n\t * If the NFA engine failed, try the backtracking engine.\n\t * The NFA engine also fails for patterns that it can't handle well\n\t * but are still valid patterns, thus a retry should work.\n\t * But don't try if an error message was given.\n\t */\n\tif (regexp_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t{\n\t    regexp_engine = BACKTRACKING_ENGINE;\n#ifdef FEAT_EVAL\n\t    report_re_switch(expr);\n#endif\n\t    prog = bt_regengine.regcomp(expr, re_flags);\n\t}\n    }\n\n    if (prog != NULL)\n    {\n\t// Store the info needed to call regcomp() again when the engine turns\n\t// out to be very slow when executing it.\n\tprog->re_engine = regexp_engine;\n\tprog->re_flags  = re_flags;\n    }\n\n    return prog;\n}\n\n/*\n * Free a compiled regexp program, returned by vim_regcomp().\n */\n    void\nvim_regfree(regprog_T *prog)\n{\n    if (prog != NULL)\n\tprog->engine->regfree(prog);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_regexp_stuff(void)\n{\n    ga_clear(&regstack);\n    ga_clear(&backpos);\n    vim_free(reg_tofree);\n    vim_free(reg_prev_sub);\n}\n#endif\n\n#ifdef FEAT_EVAL\n    static void\nreport_re_switch(char_u *pat)\n{\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tmsg_puts(_(\"Switching to backtracking RE engine for pattern: \"));\n\tmsg_puts((char *)pat);\n\tverbose_leave();\n    }\n}\n#endif\n\n#if defined(FEAT_X11) || defined(PROTO)\n/*\n * Return whether \"prog\" is currently being executed.\n */\n    int\nregprog_in_use(regprog_T *prog)\n{\n    return prog->re_in_use;\n}\n#endif\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed.\n * Uses curbuf for line count and 'iskeyword'.\n * When \"nl\" is TRUE consider a \"\\n\" in \"line\" to be a line break.\n *\n * Return TRUE if there is a match, FALSE if not.\n */\n    static int\nvim_regexec_string(\n    regmatch_T\t*rmp,\n    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_startp = NULL;\n    rex.reg_endp = NULL;\n    rex.reg_startpos = NULL;\n    rex.reg_endpos = NULL;\n\n    result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tvim_regfree(rmp->regprog);\n\tif (pat != NULL)\n\t{\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n\t    if (rmp->regprog != NULL)\n\t    {\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result > 0;\n}\n\n/*\n * Note: \"*prog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_prog(\n    regprog_T\t**prog,\n    int\t\tignore_case,\n    char_u\t*line,\n    colnr_T\tcol)\n{\n    int\t\tr;\n    regmatch_T\tregmatch;\n\n    regmatch.regprog = *prog;\n    regmatch.rm_ic = ignore_case;\n    r = vim_regexec_string(&regmatch, line, col, FALSE);\n    *prog = regmatch.regprog;\n    return r;\n}\n\n/*\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, FALSE);\n}\n\n/*\n * Like vim_regexec(), but consider a \"\\n\" in \"line\" to be a line break.\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, TRUE);\n}\n\n/*\n * Match a regexp against multiple lines.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed, even set to NULL.\n * Uses curbuf for line count and 'iskeyword'.\n *\n * Return zero if there is no match.  Return number of lines contained in the\n * match otherwise.\n */\n    long\nvim_regexec_multi(\n    regmmatch_T *rmp,\n    win_T       *win,\t\t// window in which to search or NULL\n    buf_T       *buf,\t\t// buffer in which to search\n    linenr_T\tlnum,\t\t// nr of line to start looking for match\n    colnr_T\tcol,\t\t// column to start looking for match\n    int\t\t*timed_out)\t// flag is set when timeout limit reached\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    result = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, timed_out);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tif (pat != NULL)\n\t{\n\t    regprog_T *prev_prog = rmp->regprog;\n\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // checking for \\z misuse was already done when compiling for NFA,\n\t    // allow all here\n\t    reg_do_extmatch = REX_ALL;\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n#ifdef FEAT_SYN_HL\n\t    reg_do_extmatch = 0;\n#endif\n\t    if (rmp->regprog == NULL)\n\t    {\n\t\t// Somehow compiling the pattern failed now, put back the\n\t\t// previous one to avoid \"regprog\" becoming NULL.\n\t\trmp->regprog = prev_prog;\n\t    }\n\t    else\n\t    {\n\t\tvim_regfree(prev_prog);\n\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, timed_out);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result <= 0 ? 0 : result;\n}\n", "\" Tests for regexp in latin1 encoding\n\nset encoding=latin1\nscriptencoding latin1\n\nsource check.vim\n\nfunc s:equivalence_test()\n  let str = 'A\u0410\u0411\u0412\u0413\u0414\u0415 B C D E\u0418\u0419\u041a\u041b F G H I\u041c\u041d\u041e\u041f J K L M N\u0421 O\u0422\u0423\u0424\u0425\u0426\u0428 P Q R S T U\u0429\u042a\u042b\u042c V W X Y\u042d Z '\n  \\      .. 'a\u0430\u0431\u0432\u0433\u0434\u0435 b c d e\u0438\u0439\u043a\u043b f g h i\u043c\u043d\u043e\u043f j k l m n\u0441 o\u0442\u0443\u0444\u0445\u0446\u0448 p q r s t u\u0449\u044a\u044b\u044c v w x y\u044d\u044f z '\n  \\      .. \"0 1 2 3 4 5 6 7 8 9 \"\n  \\      .. \"` ~ ! ? ; : . , / \\\\ ' \\\" | < > [ ] { } ( ) @ # $ % ^ & * _ - + \\b \\e \\f \\n \\r \\t\"\n  let groups = split(str)\n  for group1 in groups\n      for c in split(group1, '\\zs')\n\t\" next statement confirms that equivalence class matches every\n\t\" character in group\n        call assert_match('^[[=' . c . '=]]*$', group1)\n        for group2 in groups\n          if group2 != group1\n\t    \" next statement converts that equivalence class doesn't match\n\t    \" a character in any other group\n            call assert_equal(-1, match(group2, '[[=' . c . '=]]'))\n          endif\n        endfor\n      endfor\n  endfor\nendfunc\n\nfunc Test_equivalence_re1()\n  set re=1\n  call s:equivalence_test()\nendfunc\n\nfunc Test_equivalence_re2()\n  set re=2\n  call s:equivalence_test()\nendfunc\n\nfunc Test_recursive_substitute()\n  new\n  s/^/\\=execute(\"s#^##gn\")\n  \" check we are now not in the sandbox\n  call setwinvar(1, 'myvar', 1)\n  bwipe!\nendfunc\n\nfunc Test_nested_backrefs()\n  \" Check example in change.txt.\n  new\n  for re in range(0, 2)\n    exe 'set re=' . re\n    call setline(1, 'aa ab x')\n    1s/\\(\\(a[a-d] \\)*\\)\\(x\\)/-\\1- -\\2- -\\3-/\n    call assert_equal('-aa ab - -ab - -x-', getline(1))\n\n    call assert_equal('-aa ab - -ab - -x-', substitute('aa ab x', '\\(\\(a[a-d] \\)*\\)\\(x\\)', '-\\1- -\\2- -\\3-', ''))\n  endfor\n  bwipe!\n  set re=0\nendfunc\n\nfunc Test_eow_with_optional()\n  let expected = ['abc def', 'abc', 'def', '', '', '', '', '', '', '']\n  for re in range(0, 2)\n    exe 'set re=' . re\n    let actual = matchlist('abc def', '\\(abc\\>\\)\\?\\s*\\(def\\)')\n    call assert_equal(expected, actual)\n  endfor\nendfunc\n\nfunc Test_backref()\n  new\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  call assert_equal(3, search('\\%#=1\\(e\\)\\1'))\n  call assert_equal(3, search('\\%#=2\\(e\\)\\1'))\n  call assert_fails('call search(\"\\\\%#=1\\\\(e\\\\1\\\\)\")', 'E65:')\n  call assert_fails('call search(\"\\\\%#=2\\\\(e\\\\1\\\\)\")', 'E65:')\n  bwipe!\nendfunc\n\nfunc Test_multi_failure()\n  set re=1\n  call assert_fails('/a**', 'E61:')\n  call assert_fails('/a*\\+', 'E62:')\n  call assert_fails('/a\\{a}', 'E554:')\n  set re=2\n  call assert_fails('/a**', 'E871:')\n  call assert_fails('/a*\\+', 'E871:')\n  call assert_fails('/a\\{a}', 'E554:')\n  set re=0\nendfunc\n\nfunc Test_column_success_failure()\n  new\n  call setline(1, 'xbar')\n\n  set re=1\n  %s/\\%>0v./A/\n  call assert_equal('Abar', getline(1))\n  call assert_fails('/\\%v', 'E71:')\n  call assert_fails('/\\%>v', 'E71:')\n  call assert_fails('/\\%c', 'E71:')\n  call assert_fails('/\\%<c', 'E71:')\n  call assert_fails('/\\%l', 'E71:')\n  set re=2\n  %s/\\%>0v./B/\n  call assert_equal('Bbar', getline(1))\n  call assert_fails('/\\%v', 'E1273:')\n  call assert_fails('/\\%>v', 'E1273:')\n  call assert_fails('/\\%c', 'E1273:')\n  call assert_fails('/\\%<c', 'E1273:')\n  call assert_fails('/\\%l', 'E1273:')\n\n  set re=0\n  bwipe!\nendfunc\n\nfunc Test_recursive_addstate()\n  \" This will call addstate() recursively until it runs into the limit.\n  let lnum = search('\\v((){328}){389}')\n  call assert_equal(0, lnum)\nendfunc\n\nfunc Test_out_of_memory()\n  new\n  s/^/,n\n  \" This will be slow...\n  call assert_fails('call search(\"\\\\v((n||<)+);\")', 'E363:')\nendfunc\n\nfunc Test_get_equi_class()\n  new\n  \" Incomplete equivalence class caused invalid memory access\n  s/^/[[=\n  call assert_equal(1, search(getline(1)))\n  s/.*/[[.\n  call assert_equal(1, search(getline(1)))\nendfunc\n\nfunc Test_rex_init()\n  set noincsearch\n  set re=1\n  new\n  setlocal iskeyword=a-z\n  call setline(1, ['abc', 'ABC'])\n  call assert_equal(1, search('[[:keyword:]]'))\n  new\n  setlocal iskeyword=A-Z\n  call setline(1, ['abc', 'ABC'])\n  call assert_equal(2, search('[[:keyword:]]'))\n  bwipe!\n  bwipe!\n  set re=0\nendfunc\n\nfunc Test_range_with_newline()\n  new\n  call setline(1, \"a\")\n  call assert_equal(0, search(\"[ -*\\\\n- ]\"))\n  call assert_equal(0, search(\"[ -*\\\\t-\\\\n]\"))\n  bwipe!\nendfunc\n\nfunc Test_pattern_compile_speed()\n  CheckOption spellcapcheck\n  CheckFunction reltimefloat\n\n  let start = reltime()\n  \" this used to be very slow, not it should be about a second\n  set spc=\\\\v(((((Nxxxxxxx&&xxxx){179})+)+)+){179}\n  call assert_inrange(0.01, 10.0, reltimefloat(reltime(start)))\n  set spc=\nendfunc\n\n\" Tests for regexp patterns without multi-byte support.\nfunc Test_regexp_single_line_pat()\n  \" tl is a List of Lists with:\n  \"    regexp engines to test\n  \"       0 - test with 'regexpengine' values 0 and 1\n  \"       1 - test with 'regexpengine' values 0 and 2\n  \"       2 - test with 'regexpengine' values 0, 1 and 2\n  \"    regexp pattern\n  \"    text to test the pattern on\n  \"    expected match (optional)\n  \"    expected submatch 1 (optional)\n  \"    expected submatch 2 (optional)\n  \"    etc.\n  \"  When there is no match use only the first two items.\n  let tl = []\n\n  call add(tl, [2, 'ab', 'aab', 'ab'])\n  call add(tl, [2, 'b', 'abcdef', 'b'])\n  call add(tl, [2, 'bc*', 'abccccdef', 'bcccc'])\n  call add(tl, [2, 'bc\\{-}', 'abccccdef', 'b'])\n  call add(tl, [2, 'bc\\{-}\\(d\\)', 'abccccdef', 'bccccd', 'd'])\n  call add(tl, [2, 'bc*', 'abbdef', 'b'])\n  call add(tl, [2, 'c*', 'ccc', 'ccc'])\n  call add(tl, [2, 'bc*', 'abdef', 'b'])\n  call add(tl, [2, 'c*', 'abdef', ''])\n  call add(tl, [2, 'bc\\+', 'abccccdef', 'bcccc'])\n  call add(tl, [2, 'bc\\+', 'abdef']) \" no match\n  \" match escape character in a string\n  call add(tl, [2, '.\\e.', \"one\\<Esc>two\", \"e\\<Esc>t\"])\n  \" match backspace character in a string\n  call add(tl, [2, '.\\b.', \"one\\<C-H>two\", \"e\\<C-H>t\"])\n  \" match newline character in a string\n  call add(tl, [2, 'o\\nb', \"foo\\nbar\", \"o\\nb\"])\n\n  \" operator \\|\n  call add(tl, [2, 'a\\|ab', 'cabd', 'a']) \" alternation is ordered\n\n  call add(tl, [2, 'c\\?', 'ccb', 'c'])\n  call add(tl, [2, 'bc\\?', 'abd', 'b'])\n  call add(tl, [2, 'bc\\?', 'abccd', 'bc'])\n\n  call add(tl, [2, '\\va{1}', 'ab', 'a'])\n\n  call add(tl, [2, '\\va{2}', 'aa', 'aa'])\n  call add(tl, [2, '\\va{2}', 'caad', 'aa'])\n  call add(tl, [2, '\\va{2}', 'aba'])\n  call add(tl, [2, '\\va{2}', 'ab'])\n  call add(tl, [2, '\\va{2}', 'abaa', 'aa'])\n  call add(tl, [2, '\\va{2}', 'aaa', 'aa'])\n\n  call add(tl, [2, '\\vb{1}', 'abca', 'b'])\n  call add(tl, [2, '\\vba{2}', 'abaa', 'baa'])\n  call add(tl, [2, '\\vba{3}', 'aabaac'])\n\n  call add(tl, [2, '\\v(ab){1}', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1}', 'dabc', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1}', 'acb'])\n\n  call add(tl, [2, '\\v(ab){0,2}', 'acb', \"\", \"\"])\n  call add(tl, [2, '\\v(ab){0,2}', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1,2}', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1,2}', 'ababc', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2,4}', 'ababcab', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2,4}', 'abcababa', 'abab', 'ab'])\n\n  call add(tl, [2, '\\v(ab){2}', 'abab', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2}', 'cdababe', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2}', 'abac'])\n  call add(tl, [2, '\\v(ab){2}', 'abacabab', 'abab', 'ab'])\n  call add(tl, [2, '\\v((ab){2}){2}', 'abababab', 'abababab', 'abab', 'ab'])\n  call add(tl, [2, '\\v((ab){2}){2}', 'abacabababab', 'abababab', 'abab', 'ab'])\n\n  call add(tl, [2, '\\v(a{1}){1}', 'a', 'a', 'a'])\n  call add(tl, [2, '\\v(a{2}){1}', 'aa', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){1}', 'aaac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){1}', 'daaac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{1}){2}', 'daaac', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{1}){2}', 'aaa', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{2})+', 'adaac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2})+', 'aa', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){1}', 'aa', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{1}){2}', 'aa', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{1}){1}', 'a', 'a', 'a'])\n  call add(tl, [2, '\\v(a{2}){2}', 'aaaa', 'aaaa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){2}', 'aaabaaaa', 'aaaa', 'aa'])\n\n  call add(tl, [2, '\\v(a+){2}', 'dadaac', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{3}){2}', 'aaaaaaa', 'aaaaaa', 'aaa'])\n\n  call add(tl, [2, '\\v(a{1,2}){2}', 'daaac', 'aaa', 'a'])\n  call add(tl, [2, '\\v(a{1,3}){2}', 'daaaac', 'aaaa', 'a'])\n  call add(tl, [2, '\\v(a{1,3}){2}', 'daaaaac', 'aaaaa', 'aa'])\n  call add(tl, [2, '\\v(a{1,3}){3}', 'daac'])\n  call add(tl, [2, '\\v(a{1,2}){2}', 'dac'])\n  call add(tl, [2, '\\v(a+)+', 'daac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a+)+', 'aaa', 'aaa', 'aaa'])\n  call add(tl, [2, '\\v(a+){1,2}', 'aaa', 'aaa', 'aaa'])\n  call add(tl, [2, '\\v(a+)(a+)', 'aaa', 'aaa', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{3})+', 'daaaac', 'aaa', 'aaa'])\n  call add(tl, [2, '\\v(a|b|c)+', 'aacb', 'aacb', 'b'])\n  call add(tl, [2, '\\v(a|b|c){2}', 'abcb', 'ab', 'b'])\n  call add(tl, [2, '\\v(abc){2}', 'abcabd', ])\n  call add(tl, [2, '\\v(abc){2}', 'abdabcabc','abcabc', 'abc'])\n\n  call add(tl, [2, 'a*', 'cc', ''])\n  call add(tl, [2, '\\v(a*)+', 'cc', ''])\n  call add(tl, [2, '\\v((ab)+)+', 'ab', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(((ab)+)+)+', 'ab', 'ab', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(((ab)+)+)+', 'dababc', 'abab', 'abab', 'abab', 'ab'])\n  call add(tl, [2, '\\v(a{0,2})+', 'cc', ''])\n  call add(tl, [2, '\\v(a*)+', '', ''])\n  call add(tl, [2, '\\v((a*)+)+', '', ''])\n  call add(tl, [2, '\\v((ab)*)+', '', ''])\n  call add(tl, [2, '\\va{1,3}', 'aab', 'aa'])\n  call add(tl, [2, '\\va{2,3}', 'abaa', 'aa'])\n\n  call add(tl, [2, '\\v((ab)+|c*)+', 'abcccaba', 'abcccab', '', 'ab'])\n  call add(tl, [2, '\\v(a{2})|(b{3})', 'bbabbbb', 'bbb', '', 'bbb'])\n  call add(tl, [2, '\\va{2}|b{2}', 'abab'])\n  call add(tl, [2, '\\v(a)+|(c)+', 'bbacbaacbbb', 'a', 'a'])\n  call add(tl, [2, '\\vab{2,3}c', 'aabbccccccccccccc', 'abbc'])\n  call add(tl, [2, '\\vab{2,3}c', 'aabbbccccccccccccc', 'abbbc'])\n  call add(tl, [2, '\\vab{2,3}cd{2,3}e', 'aabbbcddee', 'abbbcdde'])\n  call add(tl, [2, '\\va(bc){2}d', 'aabcbfbc' ])\n  call add(tl, [2, '\\va*a{2}', 'a', ])\n  call add(tl, [2, '\\va*a{2}', 'aa', 'aa' ])\n  call add(tl, [2, '\\va*a{2}', 'aaa', 'aaa' ])\n  call add(tl, [2, '\\va*a{2}', 'bbbabcc', ])\n  call add(tl, [2, '\\va*b*|a*c*', 'a', 'a'])\n  call add(tl, [2, '\\va{1}b{1}|a{1}b{1}', ''])\n\n  \" submatches\n  call add(tl, [2, '\\v(a)', 'ab', 'a', 'a'])\n  call add(tl, [2, '\\v(a)(b)', 'ab', 'ab', 'a', 'b'])\n  call add(tl, [2, '\\v(ab)(b)(c)', 'abbc', 'abbc', 'ab', 'b', 'c'])\n  call add(tl, [2, '\\v((a)(b))', 'ab', 'ab', 'ab', 'a', 'b'])\n  call add(tl, [2, '\\v(a)|(b)', 'ab', 'a', 'a'])\n\n  call add(tl, [2, '\\v(a*)+', 'aaaa', 'aaaa', ''])\n  call add(tl, [2, 'x', 'abcdef'])\n\n  \"\n  \" Simple tests\n  \"\n\n  \" Search single groups\n  call add(tl, [2, 'ab', 'aab', 'ab'])\n  call add(tl, [2, 'ab', 'baced'])\n  call add(tl, [2, 'ab', '                    ab           ', 'ab'])\n\n  \" Search multi-modifiers\n  call add(tl, [2, 'x*', 'xcd', 'x'])\n  call add(tl, [2, 'x*', 'xxxxxxxxxxxxxxxxsofijiojgf', 'xxxxxxxxxxxxxxxx'])\n  \" empty match is good\n  call add(tl, [2, 'x*', 'abcdoij', ''])\n  \" no match here\n  call add(tl, [2, 'x\\+', 'abcdoin'])\n  call add(tl, [2, 'x\\+', 'abcdeoijdfxxiuhfij', 'xx'])\n  call add(tl, [2, 'x\\+', 'xxxxx', 'xxxxx'])\n  call add(tl, [2, 'x\\+', 'abc x siufhiush xxxxxxxxx', 'x'])\n  call add(tl, [2, 'x\\=', 'x sdfoij', 'x'])\n  call add(tl, [2, 'x\\=', 'abc sfoij', '']) \" empty match is good\n  call add(tl, [2, 'x\\=', 'xxxxxxxxx c', 'x'])\n  call add(tl, [2, 'x\\?', 'x sdfoij', 'x'])\n  \" empty match is good\n  call add(tl, [2, 'x\\?', 'abc sfoij', ''])\n  call add(tl, [2, 'x\\?', 'xxxxxxxxxx c', 'x'])\n\n  call add(tl, [2, 'a\\{0,0}', 'abcdfdoij', ''])\n  \" same thing as 'a?'\n  call add(tl, [2, 'a\\{0,1}', 'asiubid axxxaaa', 'a'])\n  \" same thing as 'a\\{0,1}'\n  call add(tl, [2, 'a\\{1,0}', 'asiubid axxxaaa', 'a'])\n  call add(tl, [2, 'a\\{3,6}', 'aa siofuh'])\n  call add(tl, [2, 'a\\{3,6}', 'aaaaa asfoij afaa', 'aaaaa'])\n  call add(tl, [2, 'a\\{3,6}', 'aaaaaaaa', 'aaaaaa'])\n  call add(tl, [2, 'a\\{0}', 'asoiuj', ''])\n  call add(tl, [2, 'a\\{2}', 'aaaa', 'aa'])\n  call add(tl, [2, 'a\\{2}', 'iuash fiusahfliusah fiushfilushfi uhsaifuh askfj nasfvius afg aaaa sfiuhuhiushf', 'aa'])\n  call add(tl, [2, 'a\\{2}', 'abcdefghijklmnopqrestuvwxyz1234567890'])\n  \" same thing as 'a*'\n  call add(tl, [2, 'a\\{0,}', 'oij sdigfusnf', ''])\n  call add(tl, [2, 'a\\{0,}', 'aaaaa aa', 'aaaaa'])\n  call add(tl, [2, 'a\\{2,}', 'sdfiougjdsafg'])\n  call add(tl, [2, 'a\\{2,}', 'aaaaasfoij ', 'aaaaa'])\n  call add(tl, [2, 'a\\{5,}', 'xxaaaaxxx '])\n  call add(tl, [2, 'a\\{5,}', 'xxaaaaaxxx ', 'aaaaa'])\n  call add(tl, [2, 'a\\{,0}', 'oidfguih iuhi hiu aaaa', ''])\n  call add(tl, [2, 'a\\{,5}', 'abcd', 'a'])\n  call add(tl, [2, 'a\\{,5}', 'aaaaaaaaaa', 'aaaaa'])\n  \" leading star as normal char when \\{} follows\n  call add(tl, [2, '^*\\{4,}$', '***'])\n  call add(tl, [2, '^*\\{4,}$', '****', '****'])\n  call add(tl, [2, '^*\\{4,}$', '*****', '*****'])\n  \" same thing as 'a*'\n  call add(tl, [2, 'a\\{}', 'bbbcddiuhfcd', ''])\n  call add(tl, [2, 'a\\{}', 'aaaaioudfh coisf jda', 'aaaa'])\n\n  call add(tl, [2, 'a\\{-0,0}', 'abcdfdoij', ''])\n  \" anti-greedy version of 'a?'\n  call add(tl, [2, 'a\\{-0,1}', 'asiubid axxxaaa', ''])\n  call add(tl, [2, 'a\\{-3,6}', 'aa siofuh'])\n  call add(tl, [2, 'a\\{-3,6}', 'aaaaa asfoij afaa', 'aaa'])\n  call add(tl, [2, 'a\\{-3,6}', 'aaaaaaaa', 'aaa'])\n  call add(tl, [2, 'a\\{-0}', 'asoiuj', ''])\n  call add(tl, [2, 'a\\{-2}', 'aaaa', 'aa'])\n  call add(tl, [2, 'a\\{-2}', 'abcdefghijklmnopqrestuvwxyz1234567890'])\n  call add(tl, [2, 'a\\{-0,}', 'oij sdigfusnf', ''])\n  call add(tl, [2, 'a\\{-0,}', 'aaaaa aa', ''])\n  call add(tl, [2, 'a\\{-2,}', 'sdfiougjdsafg'])\n  call add(tl, [2, 'a\\{-2,}', 'aaaaasfoij ', 'aa'])\n  call add(tl, [2, 'a\\{-,0}', 'oidfguih iuhi hiu aaaa', ''])\n  call add(tl, [2, 'a\\{-,5}', 'abcd', ''])\n  call add(tl, [2, 'a\\{-,5}', 'aaaaaaaaaa', ''])\n  \" anti-greedy version of 'a*'\n  call add(tl, [2, 'a\\{-}', 'bbbcddiuhfcd', ''])\n  call add(tl, [2, 'a\\{-}', 'aaaaioudfh coisf jda', ''])\n\n  \" Test groups of characters and submatches\n  call add(tl, [2, '\\(abc\\)*', 'abcabcabc', 'abcabcabc', 'abc'])\n  call add(tl, [2, '\\(ab\\)\\+', 'abababaaaaa', 'ababab', 'ab'])\n  call add(tl, [2, '\\(abaaaaa\\)*cd', 'cd', 'cd', ''])\n  call add(tl, [2, '\\(test1\\)\\? \\(test2\\)\\?', 'test1 test3', 'test1 ', 'test1', ''])\n  call add(tl, [2, '\\(test1\\)\\= \\(test2\\) \\(test4443\\)\\=', ' test2 test4443 yupiiiiiiiiiii', ' test2 test4443', '', 'test2', 'test4443'])\n  call add(tl, [2, '\\(\\(sub1\\) hello \\(sub 2\\)\\)', 'asterix sub1 hello sub 2 obelix', 'sub1 hello sub 2', 'sub1 hello sub 2', 'sub1', 'sub 2'])\n  call add(tl, [2, '\\(\\(\\(yyxxzz\\)\\)\\)', 'abcdddsfiusfyyzzxxyyxxzz', 'yyxxzz', 'yyxxzz', 'yyxxzz', 'yyxxzz'])\n  call add(tl, [2, '\\v((ab)+|c+)+', 'abcccaba', 'abcccab', 'ab', 'ab'])\n  call add(tl, [2, '\\v((ab)|c*)+', 'abcccaba', 'abcccab', '', 'ab'])\n  call add(tl, [2, '\\v(a(c*)+b)+', 'acbababaaa', 'acbabab', 'ab', ''])\n  call add(tl, [2, '\\v(a|b*)+', 'aaaa', 'aaaa', ''])\n  call add(tl, [2, '\\p*', 'a\u0431 \t', 'a\u0431 '])\n\n  \" Test greedy-ness and lazy-ness\n  call add(tl, [2, 'a\\{-2,7}','aaaaaaaaaaaaa', 'aa'])\n  call add(tl, [2, 'a\\{-2,7}x','aaaaaaaaax', 'aaaaaaax'])\n  call add(tl, [2, 'a\\{2,7}','aaaaaaaaaaaaaaaaaaaa', 'aaaaaaa'])\n  call add(tl, [2, 'a\\{2,7}x','aaaaaaaaax', 'aaaaaaax'])\n  call add(tl, [2, '\\vx(.{-,8})yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz','ayxa','xayzxayz'])\n  call add(tl, [2, '\\vx(.*)yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz', 'ayxayzxayzxa',''])\n  call add(tl, [2, '\\v(a{1,2}){-2,3}','aaaaaaa','aaaa','aa'])\n  call add(tl, [2, '\\v(a{-1,3})+', 'aa', 'aa', 'a'])\n  call add(tl, [2, '^\\s\\{-}\\zs\\( x\\|x$\\)', ' x', ' x', ' x'])\n  call add(tl, [2, '^\\s\\{-}\\zs\\(x\\| x$\\)', ' x', ' x', ' x'])\n  call add(tl, [2, '^\\s\\{-}\\ze\\(x\\| x$\\)', ' x', '', ' x'])\n  call add(tl, [2, '^\\(\\s\\{-}\\)\\(x\\| x$\\)', ' x', ' x', '', ' x'])\n\n  \" Test Character classes\n  call add(tl, [2, '\\d\\+e\\d\\d','test 10e23 fd','10e23'])\n\n  \" Test collections and character range []\n  call add(tl, [2, '\\v[a]', 'abcd', 'a'])\n  call add(tl, [2, 'a[bcd]', 'abcd', 'ab'])\n  call add(tl, [2, 'a[b-d]', 'acbd', 'ac'])\n  call add(tl, [2, '[a-d][e-f][x-x]d', 'cexdxx', 'cexd'])\n  call add(tl, [2, '\\v[[:alpha:]]+', 'abcdefghijklmnopqrstuvwxyz6','abcdefghijklmnopqrstuvwxyz'])\n  call add(tl, [2, '[[:alpha:]\\+]', '6x8','x'])\n  call add(tl, [2, '[^abc]\\+','abcabcabc'])\n  call add(tl, [2, '[^abc]','defghiasijvoinasoiunbvb','d'])\n  call add(tl, [2, '[^abc]\\+','ddddddda','ddddddd'])\n  call add(tl, [2, '[^a-d]\\+','aaaAAAZIHFNCddd','AAAZIHFNC'])\n  call add(tl, [2, '[a-f]*','iiiiiiii',''])\n  call add(tl, [2, '[a-f]*','abcdefgh','abcdef'])\n  call add(tl, [2, '[^a-f]\\+','abcdefgh','gh'])\n  call add(tl, [2, '[a-c]\\{-3,6}','abcabc','abc'])\n  call add(tl, [2, '[^[:alpha:]]\\+','abcccadfoij7787ysf287yrnccdu','7787'])\n  call add(tl, [2, '[-a]', '-', '-'])\n  call add(tl, [2, '[a-]', '-', '-'])\n  call add(tl, [2, '[a-f]*\\c','ABCDEFGH','ABCDEF'])\n  call add(tl, [2, '[abc][xyz]\\c','-af-AF-BY--','BY'])\n  \" filename regexp\n  call add(tl, [2, '[-./[:alnum:]_~]\\+', 'log13.file', 'log13.file'])\n  \" special chars\n  call add(tl, [2, '[\\]\\^\\-\\\\]\\+', '\\^\\\\\\-\\---^', '\\^\\\\\\-\\---^'])\n  \" collation elem\n  call add(tl, [2, '[[.a.]]\\+', 'aa', 'aa'])\n  \" middle of regexp\n  call add(tl, [2, 'abc[0-9]*ddd', 'siuhabc ii'])\n  call add(tl, [2, 'abc[0-9]*ddd', 'adf abc44482ddd oijs', 'abc44482ddd'])\n  call add(tl, [2, '\\_[0-9]\\+', 'asfi9888u', '9888'])\n  call add(tl, [2, '[0-9\\n]\\+', 'asfi9888u', '9888'])\n  call add(tl, [2, '\\_[0-9]\\+', \"asfi\\n9888u\", \"\\n9888\"])\n  call add(tl, [2, '\\_f', \"  \\na \", \"\\n\"])\n  call add(tl, [2, '\\_f\\+', \"  \\na \", \"\\na\"])\n  call add(tl, [2, '[0-9A-Za-z-_.]\\+', \" @0_a.A-{ \", \"0_a.A-\"])\n\n  \" Test start/end of line, start/end of file\n  call add(tl, [2, '^a.', \"a_\\nb \", \"a_\"])\n  call add(tl, [2, '^a.', \"b a \\na_\"])\n  call add(tl, [2, '.a$', \" a\\n \"])\n  call add(tl, [2, '.a$', \" a b\\n_a\", \"_a\"])\n  call add(tl, [2, '\\%^a.', \"a a\\na\", \"a \"])\n  call add(tl, [2, '\\%^a', \" a \\na \"])\n  call add(tl, [2, '.a\\%$', \" a\\n \"])\n  call add(tl, [2, '.a\\%$', \" a\\n_a\", \"_a\"])\n\n  \" Test recognition of character classes\n  call add(tl, [2, '[0-7]\\+', 'x0123456789x', '01234567'])\n  call add(tl, [2, '[^0-7]\\+', '0a;X+% 897', 'a;X+% 89'])\n  call add(tl, [2, '[0-9]\\+', 'x0123456789x', '0123456789'])\n  call add(tl, [2, '[^0-9]\\+', '0a;X+% 9', 'a;X+% '])\n  call add(tl, [2, '[0-9a-fA-F]\\+', 'x0189abcdefg', '0189abcdef'])\n  call add(tl, [2, '[^0-9A-Fa-f]\\+', '0189g;X+% ab', 'g;X+% '])\n  call add(tl, [2, '[a-z_A-Z0-9]\\+', ';+aso_SfOij ', 'aso_SfOij'])\n  call add(tl, [2, '[^a-z_A-Z0-9]\\+', 'aSo_;+% sfOij', ';+% '])\n  call add(tl, [2, '[a-z_A-Z]\\+', '0abyz_ABYZ;', 'abyz_ABYZ'])\n  call add(tl, [2, '[^a-z_A-Z]\\+', 'abAB_09;+% yzYZ', '09;+% '])\n  call add(tl, [2, '[a-z]\\+', '0abcxyz1', 'abcxyz'])\n  call add(tl, [2, '[a-z]\\+', 'AabxyzZ', 'abxyz'])\n  call add(tl, [2, '[^a-z]\\+', 'a;X09+% x', ';X09+% '])\n  call add(tl, [2, '[^a-z]\\+', 'abX0;%yz', 'X0;%'])\n  call add(tl, [2, '[a-zA-Z]\\+', '0abABxzXZ9', 'abABxzXZ'])\n  call add(tl, [2, '[^a-zA-Z]\\+', 'ab09_;+ XZ', '09_;+ '])\n  call add(tl, [2, '[A-Z]\\+', 'aABXYZz', 'ABXYZ'])\n  call add(tl, [2, '[^A-Z]\\+', 'ABx0;%YZ', 'x0;%'])\n  call add(tl, [2, '[a-z]\\+\\c', '0abxyzABXYZ;', 'abxyzABXYZ'])\n  call add(tl, [2, '[A-Z]\\+\\c', '0abABxzXZ9', 'abABxzXZ'])\n  call add(tl, [2, '\\c[^a-z]\\+', 'ab09_;+ XZ', '09_;+ '])\n  call add(tl, [2, '\\c[^A-Z]\\+', 'ab09_;+ XZ', '09_;+ '])\n  call add(tl, [2, '\\C[^A-Z]\\+', 'ABCOIJDEOIFNSD jsfoij sa', ' jsfoij sa'])\n\n  \" Tests for \\z features\n  \" match ends at \\ze\n  call add(tl, [2, 'xx \\ze test', 'xx '])\n  call add(tl, [2, 'abc\\zeend', 'oij abcend', 'abc'])\n  call add(tl, [2, 'aa\\zebb\\|aaxx', ' aabb ', 'aa'])\n  call add(tl, [2, 'aa\\zebb\\|aaxx', ' aaxx ', 'aaxx'])\n  call add(tl, [2, 'aabb\\|aa\\zebb', ' aabb ', 'aabb'])\n  call add(tl, [2, 'aa\\zebb\\|aaebb', ' aabb ', 'aa'])\n  \" match starts at \\zs\n  call add(tl, [2, 'abc\\zsdd', 'ddabcddxyzt', 'dd'])\n  call add(tl, [2, 'aa \\zsax', ' ax'])\n  call add(tl, [2, 'abc \\zsmatch\\ze abc', 'abc abc abc match abc abc', 'match'])\n  call add(tl, [2, '\\v(a \\zsif .*){2}', 'a if then a if last', 'if last', 'a if last'])\n  call add(tl, [2, '\\>\\zs.', 'aword. ', '.'])\n  call add(tl, [2, '\\s\\+\\ze\\[/\\|\\s\\zs\\s\\+', 'is   [a t', '  '])\n\n  \" Tests for \\@= and \\& features\n  call add(tl, [2, 'abc\\@=', 'abc', 'ab'])\n  call add(tl, [2, 'abc\\@=cd', 'abcd', 'abcd'])\n  call add(tl, [2, 'abc\\@=', 'ababc', 'ab'])\n  \" will never match, no matter the input text\n  call add(tl, [2, 'abcd\\@=e', 'abcd'])\n  \" will never match\n  call add(tl, [2, 'abcd\\@=e', 'any text in here ... '])\n  call add(tl, [2, '\\v(abc)@=..', 'xabcd', 'ab', 'abc'])\n  call add(tl, [2, '\\(.*John\\)\\@=.*Bob', 'here is John, and here is B'])\n  call add(tl, [2, '\\(John.*\\)\\@=.*Bob', 'John is Bobs friend', 'John is Bob', 'John is Bobs friend'])\n  call add(tl, [2, '\\<\\S\\+\\())\\)\\@=', '$((i=i+1))', 'i=i+1', '))'])\n  call add(tl, [2, '.*John\\&.*Bob', 'here is John, and here is B'])\n  call add(tl, [2, '.*John\\&.*Bob', 'John is Bobs friend', 'John is Bob'])\n  call add(tl, [2, '\\v(test1)@=.*yep', 'this is a test1, yep it is', 'test1, yep', 'test1'])\n  call add(tl, [2, 'foo\\(bar\\)\\@!', 'foobar'])\n  call add(tl, [2, 'foo\\(bar\\)\\@!', 'foo bar', 'foo'])\n  call add(tl, [2, 'if \\(\\(then\\)\\@!.\\)*$', ' if then else'])\n  call add(tl, [2, 'if \\(\\(then\\)\\@!.\\)*$', ' if else ', 'if else ', ' '])\n  call add(tl, [2, '\\(foo\\)\\@!bar', 'foobar', 'bar'])\n  call add(tl, [2, '\\(foo\\)\\@!...bar', 'foobar'])\n  call add(tl, [2, '^\\%(.*bar\\)\\@!.*\\zsfoo', ' bar foo '])\n  call add(tl, [2, '^\\%(.*bar\\)\\@!.*\\zsfoo', ' foo bar '])\n  call add(tl, [2, '^\\%(.*bar\\)\\@!.*\\zsfoo', ' foo xxx ', 'foo'])\n  call add(tl, [2, '[ ]\\@!\\p\\%([ ]\\@!\\p\\)*:', 'implicit mappings:', 'mappings:'])\n  call add(tl, [2, '[ ]\\@!\\p\\([ ]\\@!\\p\\)*:', 'implicit mappings:', 'mappings:', 's'])\n  call add(tl, [2, 'm\\k\\+_\\@=\\%(_\\@!\\k\\)\\@<=\\k\\+e', 'mx__xe', 'mx__xe'])\n  call add(tl, [2, '\\%(\\U\\@<=S\\k*\\|S\\l\\)R', 'SuR', 'SuR'])\n\n  \" Combining different tests and features\n  call add(tl, [2, '[[:alpha:]]\\{-2,6}', '787abcdiuhsasiuhb4', 'ab'])\n  call add(tl, [2, '', 'abcd', ''])\n  call add(tl, [2, '\\v(())', 'any possible text', ''])\n  call add(tl, [2, '\\v%(ab(xyz)c)', '   abxyzc ', 'abxyzc', 'xyz'])\n  call add(tl, [2, '\\v(test|)empty', 'tesempty', 'empty', ''])\n  call add(tl, [2, '\\v(a|aa)(a|aa)', 'aaa', 'aa', 'a', 'a'])\n\n  \" \\%u and friends\n  call add(tl, [2, '\\%d32', 'yes no', ' '])\n  call add(tl, [2, '\\%o40', 'yes no', ' '])\n  call add(tl, [2, '\\%x20', 'yes no', ' '])\n  call add(tl, [2, '\\%u0020', 'yes no', ' '])\n  call add(tl, [2, '\\%U00000020', 'yes no', ' '])\n  call add(tl, [2, '\\%d0', \"yes\\x0ano\", \"\\x0a\"])\n\n  \"\" \\%[abc]\n  call add(tl, [2, 'foo\\%[bar]', 'fobar'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobar', 'foobar'])\n  call add(tl, [2, 'foo\\%[bar]', 'fooxx', 'foo'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobxx', 'foob'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobaxx', 'fooba'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobarxx', 'foobar'])\n  call add(tl, [2, 'foo\\%[bar]x', 'foobxx', 'foobx'])\n  call add(tl, [2, 'foo\\%[bar]x', 'foobarxx', 'foobarx'])\n  call add(tl, [2, '\\%[bar]x', 'barxx', 'barx'])\n  call add(tl, [2, '\\%[bar]x', 'bxx', 'bx'])\n  call add(tl, [2, '\\%[bar]x', 'xxx', 'x'])\n  call add(tl, [2, 'b\\%[[ao]r]', 'bar bor', 'bar'])\n  call add(tl, [2, 'b\\%[[]]r]', 'b]r bor', 'b]r'])\n  call add(tl, [2, '@\\%[\\w\\-]*', '<http://john.net/pandoc/>[@pandoc]', '@pandoc'])\n\n  \" Alternatives, must use first longest match\n  call add(tl, [2, 'goo\\|go', 'google', 'goo'])\n  call add(tl, [2, '\\<goo\\|\\<go', 'google', 'goo'])\n  call add(tl, [2, '\\<goo\\|go', 'google', 'goo'])\n\n  \" Back references\n  call add(tl, [2, '\\(\\i\\+\\) \\1', ' abc abc', 'abc abc', 'abc'])\n  call add(tl, [2, '\\(\\i\\+\\) \\1', 'xgoo goox', 'goo goo', 'goo'])\n  call add(tl, [2, '\\(a\\)\\(b\\)\\(c\\)\\(dd\\)\\(e\\)\\(f\\)\\(g\\)\\(h\\)\\(i\\)\\1\\2\\3\\4\\5\\6\\7\\8\\9', 'xabcddefghiabcddefghix', 'abcddefghiabcddefghi', 'a', 'b', 'c', 'dd', 'e', 'f', 'g', 'h', 'i'])\n  call add(tl, [2, '\\(\\d*\\)a \\1b', ' a b ', 'a b', ''])\n  call add(tl, [2, '^.\\(.\\).\\_..\\1.', \"aaa\\naaa\\nb\", \"aaa\\naaa\", 'a'])\n  call add(tl, [2, '^.*\\.\\(.*\\)/.\\+\\(\\1\\)\\@<!$', 'foo.bat/foo.com', 'foo.bat/foo.com', 'bat'])\n  call add(tl, [2, '^.*\\.\\(.*\\)/.\\+\\(\\1\\)\\@<!$', 'foo.bat/foo.bat'])\n  call add(tl, [2, '^.*\\.\\(.*\\)/.\\+\\(\\1\\)\\@<=$', 'foo.bat/foo.bat', 'foo.bat/foo.bat', 'bat', 'bat'])\n  call add(tl, [2, '\\\\\\@<!\\${\\(\\d\\+\\%(:.\\{-}\\)\\?\\\\\\@<!\\)}', '2013-06-27${0}', '${0}', '0'])\n  call add(tl, [2, '^\\(a*\\)\\1$', 'aaaaaaaa', 'aaaaaaaa', 'aaaa'])\n  call add(tl, [2, '^\\(a\\{-2,}\\)\\1\\+$', 'aaaaaaaaa', 'aaaaaaaaa', 'aaa'])\n\n  \" Look-behind with limit\n  call add(tl, [2, '<\\@<=span.', 'xxspanxx<spanyyy', 'spany'])\n  call add(tl, [2, '<\\@1<=span.', 'xxspanxx<spanyyy', 'spany'])\n  call add(tl, [2, '<\\@2<=span.', 'xxspanxx<spanyyy', 'spany'])\n  call add(tl, [2, '\\(<<\\)\\@<=span.', 'xxspanxxxx<spanxx<<spanyyy', 'spany', '<<'])\n  call add(tl, [2, '\\(<<\\)\\@1<=span.', 'xxspanxxxx<spanxx<<spanyyy'])\n  call add(tl, [2, '\\(<<\\)\\@2<=span.', 'xxspanxxxx<spanxx<<spanyyy', 'spany', '<<'])\n  call add(tl, [2, '\\(foo\\)\\@<!bar.', 'xx foobar1 xbar2 xx', 'bar2'])\n\n  \" look-behind match in front of a zero-width item\n  call add(tl, [2, '\\v\\C%(<Last Changed:\\s+)@<=.*$', '\" test header'])\n  call add(tl, [2, '\\v\\C%(<Last Changed:\\s+)@<=.*$', '\" Last Changed: 1970', '1970'])\n  call add(tl, [2, '\\(foo\\)\\@<=\\>', 'foobar'])\n  call add(tl, [2, '\\(foo\\)\\@<=\\>', 'barfoo', '', 'foo'])\n  call add(tl, [2, '\\(foo\\)\\@<=.*', 'foobar', 'bar', 'foo'])\n\n  \" complicated look-behind match\n  call add(tl, [2, '\\(r\\@<=\\|\\w\\@<!\\)\\/', 'x = /word/;', '/'])\n  call add(tl, [2, '^[a-z]\\+\\ze \\&\\(asdf\\)\\@<!', 'foo bar', 'foo'])\n\n  \"\" \\@>\n  call add(tl, [2, '\\(a*\\)\\@>a', 'aaaa'])\n  call add(tl, [2, '\\(a*\\)\\@>b', 'aaab', 'aaab', 'aaa'])\n  call add(tl, [2, '^\\(.\\{-}b\\)\\@>.', '  abcbd', '  abc', '  ab'])\n  call add(tl, [2, '\\(.\\{-}\\)\\(\\)\\@>$', 'abc', 'abc', 'abc', ''])\n  \" TODO: BT engine does not restore submatch after failure\n  call add(tl, [1, '\\(a*\\)\\@>a\\|a\\+', 'aaaa', 'aaaa'])\n\n  \" \"\\_\" prepended negated collection matches EOL\n  call add(tl, [2, '\\_[^8-9]\\+', \"asfi\\n9888\", \"asfi\\n\"])\n  call add(tl, [2, '\\_[^a]\\+', \"asfi\\n9888\", \"sfi\\n9888\"])\n\n  \" Requiring lots of states.\n  call add(tl, [2, '[0-9a-zA-Z]\\{8}-\\([0-9a-zA-Z]\\{4}-\\)\\{3}[0-9a-zA-Z]\\{12}', \" 12345678-1234-1234-1234-123456789012 \", \"12345678-1234-1234-1234-123456789012\", \"1234-\"])\n\n  \" Skip adding state twice\n  call add(tl, [2, '^\\%(\\%(^\\s*#\\s*if\\>\\|#\\s*if\\)\\)\\(\\%>1c.*$\\)\\@=', \"#if FOO\", \"#if\", ' FOO'])\n\n  \" Test \\%V atom\n  call add(tl, [2, '\\%>70vGesamt', 'Jean-Michel Charlier & Victor Hubinon\\Gesamtausgabe [Salleck]    Buck Danny {Jean-Michel Charlier & Victor Hubinon}\\Gesamtausgabe', 'Gesamt'])\n\n  \" Test for ignoring case and matching repeated characters\n  call add(tl, [2, '\\cb\\+', 'aAbBbBcC', 'bBbB'])\n\n  \" Run the tests\n  for t in tl\n    let re = t[0]\n    let pat = t[1]\n    let text = t[2]\n    let matchidx = 3\n    for engine in [0, 1, 2]\n      if engine == 2 && re == 0 || engine == 1 && re == 1\n        continue\n      endif\n      let &regexpengine = engine\n      try\n        let l = matchlist(text, pat)\n      catch\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", caused an exception: \\\"'\n              \\ . v:exception . '\\\"')\n      endtry\n      \" check the match itself\n      if len(l) == 0 && len(t) > matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", did not match, expected: \\\"'\n              \\ . t[matchidx] . '\\\"')\n      elseif len(l) > 0 && len(t) == matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0]\n              \\ . '\\\", expected no match')\n      elseif len(t) > matchidx && l[0] != t[matchidx]\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0]\n              \\ . '\\\", expected: \\\"' . t[matchidx] . '\\\"')\n      else\n        \" Test passed\n      endif\n\n      \" check all the nine submatches\n      if len(l) > 0\n        for i in range(1, 9)\n          if len(t) <= matchidx + i\n            let e = ''\n          else\n            let e = t[matchidx + i]\n          endif\n          if l[i] != e\n            call assert_report('Error ' . engine . ': pat: \\\"' . pat\n                  \\ . '\\\", text: \\\"' . text . '\\\", submatch ' . i . ': \\\"'\n                  \\ . l[i] . '\\\", expected: \\\"' . e . '\\\"')\n          endif\n        endfor\n        unlet i\n      endif\n    endfor\n  endfor\n\n  unlet t tl e l\nendfunc\n\n\" Tests for multi-line regexp patterns without multi-byte support.\nfunc Test_regexp_multiline_pat()\n  \" tl is a List of Lists with:\n  \"    regexp engines to test\n  \"       0 - test with 'regexpengine' values 0 and 1\n  \"       1 - test with 'regexpengine' values 0 and 2\n  \"       2 - test with 'regexpengine' values 0, 1 and 2\n  \"    regexp pattern\n  \"    List with text to test the pattern on\n  \"    List with the expected match\n  let tl = []\n\n  \" back references\n  call add(tl, [2, '^.\\(.\\).\\_..\\1.', ['aaa', 'aaa', 'b'], ['XX', 'b']])\n  call add(tl, [2, '\\v.*\\/(.*)\\n.*\\/\\1$', ['./Dir1/Dir2/zyxwvuts.txt', './Dir1/Dir2/abcdefgh.bat', '', './Dir1/Dir2/file1.txt', './OtherDir1/OtherDir2/file1.txt'], ['./Dir1/Dir2/zyxwvuts.txt', './Dir1/Dir2/abcdefgh.bat', '', 'XX']])\n\n  \" line breaks\n  call add(tl, [2, '\\S.*\\nx', ['abc', 'def', 'ghi', 'xjk', 'lmn'], ['abc', 'def', 'XXjk', 'lmn']])\n\n  \" Any single character or end-of-line\n  call add(tl, [2, '\\_.\\+', ['a', 'b', 'c'], ['XX']])\n  \" Any identifier or end-of-line\n  call add(tl, [2, '\\_i\\+', ['a', 'b', ';', '2'], ['XX;XX']])\n  \" Any identifier but excluding digits or end-of-line\n  call add(tl, [2, '\\_I\\+', ['a', 'b', ';', '2'], ['XX;XX2XX']])\n  \" Any keyword or end-of-line\n  call add(tl, [2, '\\_k\\+', ['a', 'b', '=', '2'], ['XX=XX']])\n  \" Any keyword but excluding digits or end-of-line\n  call add(tl, [2, '\\_K\\+', ['a', 'b', '=', '2'], ['XX=XX2XX']])\n  \" Any filename character or end-of-line\n  call add(tl, [2, '\\_f\\+', ['a', 'b', '.', '5'], ['XX']])\n  \" Any filename character but excluding digits or end-of-line\n  call add(tl, [2, '\\_F\\+', ['a', 'b', '.', '5'], ['XX5XX']])\n  \" Any printable character or end-of-line\n  call add(tl, [2, '\\_p\\+', ['a', 'b', '=', '4'], ['XX']])\n  \" Any printable character excluding digits or end-of-line\n  call add(tl, [2, '\\_P\\+', ['a', 'b', '=', '4'], ['XX4XX']])\n  \" Any whitespace character or end-of-line\n  call add(tl, [2, '\\_s\\+', [' ', ' ', 'a', 'b'], ['XXaXXbXX']])\n  \" Any non-whitespace character or end-of-line\n  call add(tl, [2, '\\_S\\+', [' ', ' ', 'a', 'b'], [' XX XX']])\n  \" Any decimal digit or end-of-line\n  call add(tl, [2, '\\_d\\+', ['1', 'a', '2', 'b', '3'], ['XXaXXbXX']])\n  \" Any non-decimal digit or end-of-line\n  call add(tl, [2, '\\_D\\+', ['1', 'a', '2', 'b', '3'], ['1XX2XX3XX']])\n  \" Any hexadecimal digit or end-of-line\n  call add(tl, [2, '\\_x\\+', ['1', 'a', 'g', '9', '8'], ['XXgXX']])\n  \" Any non-hexadecimal digit or end-of-line\n  call add(tl, [2, '\\_X\\+', ['1', 'a', 'g', '9', '8'], ['1XXaXX9XX8XX']])\n  \" Any octal digit or end-of-line\n  call add(tl, [2, '\\_o\\+', ['0', '7', '8', '9', '0'], ['XX8XX9XX']])\n  \" Any non-octal digit or end-of-line\n  call add(tl, [2, '\\_O\\+', ['0', '7', '8', '9', '0'], ['0XX7XX0XX']])\n  \" Any word character or end-of-line\n  call add(tl, [2, '\\_w\\+', ['A', 'B', '=', 'C', 'D'], ['XX=XX']])\n  \" Any non-word character or end-of-line\n  call add(tl, [2, '\\_W\\+', ['A', 'B', '=', 'C', 'D'], ['AXXBXXCXXDXX']])\n  \" Any head-of-word character or end-of-line\n  call add(tl, [2, '\\_h\\+', ['a', '1', 'b', '2', 'c'], ['XX1XX2XX']])\n  \" Any non-head-of-word character or end-of-line\n  call add(tl, [2, '\\_H\\+', ['a', '1', 'b', '2', 'c'], ['aXXbXXcXX']])\n  \" Any alphabetic character or end-of-line\n  call add(tl, [2, '\\_a\\+', ['a', '1', 'b', '2', 'c'], ['XX1XX2XX']])\n  \" Any non-alphabetic character or end-of-line\n  call add(tl, [2, '\\_A\\+', ['a', '1', 'b', '2', 'c'], ['aXXbXXcXX']])\n  \" Any lowercase character or end-of-line\n  call add(tl, [2, '\\_l\\+', ['a', 'A', 'b', 'B'], ['XXAXXBXX']])\n  \" Any non-lowercase character or end-of-line\n  call add(tl, [2, '\\_L\\+', ['a', 'A', 'b', 'B'], ['aXXbXX']])\n  \" Any uppercase character or end-of-line\n  call add(tl, [2, '\\_u\\+', ['a', 'A', 'b', 'B'], ['aXXbXX']])\n  \" Any non-uppercase character or end-of-line\n  call add(tl, [2, '\\_U\\+', ['a', 'A', 'b', 'B'], ['XXAXXBXX']])\n  \" Collection or end-of-line\n  call add(tl, [2, '\\_[a-z]\\+', ['a', 'A', 'b', 'B'], ['XXAXXBXX']])\n  \" start of line anywhere in the text\n  call add(tl, [2, 'one\\zs\\_s*\\_^\\zetwo',\n        \\ ['', 'one', ' two', 'one', '', 'two'],\n        \\ ['', 'one', ' two', 'oneXXtwo']])\n  \" end of line anywhere in the text\n  call add(tl, [2, 'one\\zs\\_$\\_s*two',\n        \\ ['', 'one', ' two', 'one', '', 'two'], ['', 'oneXX', 'oneXX']])\n\n  \" Check that \\_[0-9] matching EOL does not break a following \\>\n  call add(tl, [2, '\\<\\(\\(25\\_[0-5]\\|2\\_[0-4]\\_[0-9]\\|\\_[01]\\?\\_[0-9]\\_[0-9]\\?\\)\\.\\)\\{3\\}\\(25\\_[0-5]\\|2\\_[0-4]\\_[0-9]\\|\\_[01]\\?\\_[0-9]\\_[0-9]\\?\\)\\>', ['', 'localnet/192.168.0.1', ''], ['', 'localnet/XX', '']])\n\n  \" Check a pattern with a line break and ^ and $\n  call add(tl, [2, 'a\\n^b$\\n^c', ['a', 'b', 'c'], ['XX']])\n\n  call add(tl, [2, '\\(^.\\+\\n\\)\\1', [' dog', ' dog', 'asdf'], ['XXasdf']])\n\n  \" Run the multi-line tests\n  for t in tl\n    let re = t[0]\n    let pat = t[1]\n    let before = t[2]\n    let after = t[3]\n    for engine in [0, 1, 2]\n      if engine == 2 && re == 0 || engine == 1 && re == 1\n        continue\n      endif\n      let &regexpengine = engine\n      new\n      call setline(1, before)\n      exe '%s/' . pat . '/XX/'\n      let result = getline(1, '$')\n      q!\n      if result != after\n        call assert_report('Error: pat: \\\"' . pat . '\\\", text: \\\"'\n              \\ . string(before) . '\\\", expected: \\\"' . string(after)\n              \\ . '\\\", got: \\\"' . string(result) . '\\\"')\n      else\n        \" Test passed\n      endif\n    endfor\n  endfor\n  unlet t tl\nendfunc\n\n\" Check that using a pattern on two lines doesn't get messed up by using\n\" matchstr() with \\ze in between.\nfunc Test_matchstr_with_ze()\n  new\n  call append(0, ['Substitute here:', '<T=\"\">Ta 5</Title>',\n        \\ '<T=\"\">Ac 7</Title>'])\n  call cursor(1, 1)\n  set re=0\n\n  .+1,.+2s/\"\"/\\='\"' . matchstr(getline(\".\"), '\\d\\+\\ze<') . '\"'\n  call assert_equal(['Substitute here:', '<T=\"5\">Ta 5</Title>',\n        \\ '<T=\"7\">Ac 7</Title>', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Check a pattern with a look behind crossing a line boundary\nfunc Test_lookbehind_across_line()\n  new\n  call append(0, ['Behind:', 'asdfasd<yyy', 'xxstart1', 'asdfasd<yy',\n        \\ 'xxxstart2', 'asdfasd<yy', 'xxstart3'])\n  call cursor(1, 1)\n  call search('\\(<\\_[xy]\\+\\)\\@3<=start')\n  call assert_equal([0, 7, 3, 0], getpos('.'))\n  bwipe!\nendfunc\n\n\" Test for the \\%V atom (match inside the visual area)\nfunc Regex_Match_Visual_Area()\n  call append(0, ['Visual:', 'thexe the thexethe', 'andaxand andaxand',\n        \\ 'oooxofor foroxooo', 'oooxofor foroxooo'])\n  call cursor(1, 1)\n  exe \"normal jfxvfx:s/\\\\%Ve/E/g\\<CR>\"\n  exe \"normal jV:s/\\\\%Va/A/g\\<CR>\"\n  exe \"normal jfx\\<C-V>fxj:s/\\\\%Vo/O/g\\<CR>\"\n  call assert_equal(['Visual:', 'thexE thE thExethe', 'AndAxAnd AndAxAnd',\n        \\ 'oooxOfOr fOrOxooo', 'oooxOfOr fOrOxooo', ''], getline(1, '$'))\n  %d\nendfunc\n\n\" Check matching Visual area\nfunc Test_matching_visual_area()\n  new\n  set regexpengine=1\n  call Regex_Match_Visual_Area()\n  set regexpengine=2\n  call Regex_Match_Visual_Area()\n  set regexpengine&\n  bwipe!\nendfunc\n\n\" Check matching marks\nfunc Regex_Mark()\n  call append(0, ['', '', '', 'Marks:', 'asdfSasdfsadfEasdf', 'asdfSas',\n        \\ 'dfsadfEasdf', '', '', '', '', ''])\n  call cursor(4, 1)\n  exe \"normal jfSmsfEme:.-4,.+6s/.\\\\%>'s.*\\\\%<'e../here/\\<CR>\"\n  exe \"normal jfSmsj0fEme:.-4,.+6s/.\\\\%>'s\\\\_.*\\\\%<'e../again/\\<CR>\"\n  call assert_equal(['', '', '', 'Marks:', 'asdfhereasdf', 'asdfagainasdf',\n        \\ '', '', '', '', '', ''], getline(1, '$'))\n  %d\nendfunc\n\nfunc Test_matching_marks()\n  new\n  set regexpengine=1\n  call Regex_Mark()\n  set regexpengine=2\n  call Regex_Mark()\n  bwipe!\nendfunc\n\n\" Check patterns matching cursor position.\nfunc s:curpos_test()\n  new\n  call setline(1, ['ffooooo', 'boboooo', 'zoooooo', 'koooooo', 'moooooo',\n        \\ \"\\t\\t\\tfoo\", 'abababababababfoo', 'bababababababafoo', '********_',\n        \\ '        xxxxxxxxxxxx    xxxx xxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxx xxxxx xxxxxxx xx xxxx xxxxxxxx xxxx xxxxxxxxxxx xxx xxxxxxx xxxxxxxxx xx xxxxxx xx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxx xxxxxxxx xxxxxxxxx xxxx xxx xxxx xxx xxx xxxxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxxxxxxx xx xxxxx xxx xxxxxxxx xxxxxx xxx xxx xxxxxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxxx  xxxxxxxxxxxxxxxxxx xxxxxxx xxxxxxx xxx xxx xxxxxxxx xxxxxxx  xxxx xxx xxxxxx xxxxx xxxxx xx xxxxxx xxxxxxx xxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxx xxxxxx xxxxx xxx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxxxxxxxxx xxxx xx xxxxxxxx xxx xxxxxxxxxxx xxxxx'])\n  call setpos('.', [0, 1, 0, 0])\n  s/\\%>3c.//g\n  call setpos('.', [0, 2, 4, 0])\n  s/\\%#.*$//g\n  call setpos('.', [0, 3, 0, 0])\n  s/\\%<3c./_/g\n  %s/\\%4l\\%>5c./_/g\n  %s/\\%6l\\%>25v./_/g\n  %s/\\%>6l\\%3c./!/g\n  %s/\\%>7l\\%12c./?/g\n  %s/\\%>7l\\%<9l\\%>5v\\%<8v./#/g\n  $s/\\%(|\\u.*\\)\\@<=[^|\\t]\\+$//ge\n  call assert_equal(['ffo', 'bob', '__ooooo', 'koooo__', 'moooooo',\n        \\ '\t\t\tf__', 'ab!babababababfoo',\n        \\ 'ba!ab##abab?bafoo', '**!*****_',\n        \\ '  !     xxx?xxxxxxxx    xxxx xxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxx xxxxx xxxxxxx xx xxxx xxxxxxxx xxxx xxxxxxxxxxx xxx xxxxxxx xxxxxxxxx xx xxxxxx xx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxx xxxxxxxx xxxxxxxxx xxxx xxx xxxx xxx xxx xxxxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxxxxxxx xx xxxxx xxx xxxxxxxx xxxxxx xxx xxx xxxxxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxxx  xxxxxxxxxxxxxxxxxx xxxxxxx xxxxxxx xxx xxx xxxxxxxx xxxxxxx  xxxx xxx xxxxxx xxxxx xxxxx xx xxxxxx xxxxxxx xxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxx xxxxxx xxxxx xxx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxxxxxxxxx xxxx xx xxxxxxxx xxx xxxxxxxxxxx xxxxx'],\n        \\ getline(1, '$'))\n  bwipe!\nendfunc\n\nfunc Test_matching_curpos()\n  set re=0\n  call s:curpos_test()\n  set re=1\n  call s:curpos_test()\n  set re=2\n  call s:curpos_test()\n  set re&\nendfunc\n\n\" Test for matching the start and end of a buffer\nfunc Regex_start_end_buffer()\n  call setline(1, repeat(['vim edit'], 20))\n  /\\%^\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  exe \"normal 50%/\\\\%^..\\<CR>\"\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  exe \"normal 50%/\\\\%$\\<CR>\"\n  call assert_equal([0, 20, 8, 0], getpos('.'))\n  exe \"normal 6gg/..\\\\%$\\<CR>\"\n  call assert_equal([0, 20, 7, 0], getpos('.'))\n  %d\nendfunc\n\nfunc Test_start_end_of_buffer_match()\n  new\n  set regexpengine=1\n  call Regex_start_end_buffer()\n  set regexpengine=2\n  call Regex_start_end_buffer()\n  bwipe!\nendfunc\n\nfunc Test_ze_before_zs()\n  call assert_equal('', matchstr(' ', '\\%#=1\\ze \\zs'))\n  call assert_equal('', matchstr(' ', '\\%#=2\\ze \\zs'))\n  call assert_equal(repeat([''], 10), matchlist(' ', '\\%#=1\\ze \\zs'))\n  call assert_equal(repeat([''], 10), matchlist(' ', '\\%#=2\\ze \\zs'))\nendfunc\n\n\" Check for detecting error\nfunc Test_regexp_error()\n  call assert_fails(\"call matchlist('x x', '\\\\%#=1 \\\\zs*')\", 'E888:')\n  call assert_fails(\"call matchlist('x x', '\\\\%#=1 \\\\ze*')\", 'E888:')\n  call assert_fails(\"call matchlist('x x', '\\\\%#=2 \\\\zs*')\", 'E888:')\n  call assert_fails(\"call matchlist('x x', '\\\\%#=2 \\\\ze*')\", 'E888:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%o841\\\\%o142')\", 'E678:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%#=2\\\\%2147483647c')\", 'E951:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%#=2\\\\%2147483647l')\", 'E951:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%#=2\\\\%2147483647v')\", 'E951:')\n  call assert_fails('exe \"normal /\\\\%#=1\\\\%[x\\\\%[x]]\\<CR>\"',   'E369:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483647l\\<CR>\"', 'E951:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483647c\\<CR>\"', 'E951:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%102261126v\\<CR>\"',  'E951:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483646l\\<CR>\"', 'E486:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483646c\\<CR>\"', 'E486:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%102261125v\\<CR>\"',  'E486:')\n  call assert_equal('', matchstr('abcd', '\\%o181\\%o142'))\nendfunc\n\n\" Test for using the last substitute string pattern (~)\nfunc Test_regexp_last_subst_string()\n  new\n  s/bar/baz/e\n  call assert_equal(matchstr(\"foo\\nbaz\\nbar\", \"\\\\%#=1\\~\"), \"baz\")\n  call assert_equal(matchstr(\"foo\\nbaz\\nbar\", \"\\\\%#=2\\~\"), \"baz\")\n  close!\nendfunc\n\n\" Check patterns matching cursor position.\nfunc s:curpos_test2()\n  new\n  call setline(1, ['1', '2 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '3 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '6\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'])\n  call setpos('.', [0, 2, 10, 0])\n  s/\\%.c.*//g\n  call setpos('.', [0, 3, 15, 0])\n  s/\\%.l.*//g\n  call setpos('.', [0, 5, 3, 0])\n  s/\\%.v.*/_/g\n  call assert_equal(['1',\n        \\ '2 foobar ',\n        \\ '',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\t_',\n        \\ '6\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'],\n        \\ getline(1, '$'))\n  call assert_fails('call search(\"\\\\%.1l\")', 'E1204:')\n  call assert_fails('call search(\"\\\\%.1c\")', 'E1204:')\n  call assert_fails('call search(\"\\\\%.1v\")', 'E1204:')\n  bwipe!\nendfunc\n\n\" Check patterns matching before or after cursor position.\nfunc s:curpos_test3()\n  new\n  call setline(1, ['1', '2 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '3 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '6\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'])\n  call setpos('.', [0, 2, 10, 0])\n  \" Note: This removes all columns, except for the column directly in front of\n  \" the cursor. Bug????\n  :s/^.*\\%<.c//\n  call setpos('.', [0, 3, 10, 0])\n  :s/\\%>.c.*$//\n  call setpos('.', [0, 5, 4, 0])\n  \" Note: This removes all columns, except for the column directly in front of\n  \" the cursor. Bug????\n  :s/^.*\\%<.v/_/\n  call setpos('.', [0, 6, 4, 0])\n  :s/\\%>.v.*$/_/\n  call assert_equal(['1',\n        \\ ' eins zwei drei vier f\u044cnf sechse',\n        \\ '3 foobar e',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '_foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '6\tfo_',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'],\n        \\ getline(1, '$'))\n  sil %d\n  call setline(1, ['1', '2 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '3 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '6\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'])\n  call setpos('.', [0, 4, 4, 0])\n  %s/\\%<.l.*//\n  call setpos('.', [0, 5, 4, 0])\n  %s/\\%>.l.*//\n  call assert_equal(['', '', '',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '', ''],\n        \\ getline(1, '$'))\n  bwipe!\nendfunc\n\n\" Test that matching below, at or after the\n\" cursor position work\nfunc Test_matching_pos()\n  for val in range(3)\n    exe \"set re=\" .. val\n    \" Match at cursor position\n    call s:curpos_test2()\n    \" Match before or after cursor position\n    call s:curpos_test3()\n  endfor\n  set re&\nendfunc\n\nfunc Test_using_mark_position()\n  \" this was using freed memory\n  \" new engine\n  new\n  norm O0\n  call assert_fails(\"s/\\\\%')\", 'E486:')\n  bwipe!\n\n  \" old engine\n  new\n  norm O0\n  call assert_fails(\"s/\\\\%#=1\\\\%')\", 'E486:')\n  bwipe!\nendfunc\n\nfunc Test_using_visual_position()\n  \" this was using freed memory\n  new\n  exe \"norm 0o\\<Esc>\\<C-V>k\\<C-X>o0\"\n  /\\%V\n  bwipe!\nendfunc\n\nfunc Test_using_invalid_visual_position()\n  \" this was going beyond the end of the line\n  new\n  exe \"norm 0o000\\<Esc>0\\<C-V>$s0\"\n  /\\%V\n  bwipe!\nendfunc\n\nfunc Test_using_two_engines_pattern()\n  new\n  call setline(1, ['foobar=0', 'foobar=1', 'foobar=2'])\n  \" \\%#= at the end of the pattern\n  for i in range(0, 2)\n    call cursor( (i+1), 7) \n    call assert_fails(\"%s/foobar\\\\%#=\" .. i, 'E1281:')\n  endfor\n\n  \" \\%#= at the start of the pattern\n  for i in range(0, 2)\n    call cursor( (i+1), 7) \n    exe \":%s/\\\\%#=\" .. i .. \"foobar=\" .. i .. \"/xx\"\n  endfor\n  call assert_equal(['xx', 'xx', 'xx'], getline(1, '$'))\n  bwipe!\nendfunc\n\nfunc Test_recursive_substitute_expr()\n  new\n  func Repl()\n    s\n  endfunc\n  silent! s/\\%')/~\\=Repl()\n\n  bwipe!\n  delfunc Repl\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "buggy_code_start_loc": [3997, 1768, 1116, 737], "buggy_code_end_loc": [3998, 1774, 1116, 737], "fixing_code_start_loc": [3997, 1769, 1117, 738], "fixing_code_end_loc": [4007, 1774, 1128, 740], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 9.0.0046.", "other": {"cve": {"id": "CVE-2022-2345", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-08T22:15:07.960", "lastModified": "2023-05-03T12:15:59.990", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 9.0.0046."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio GitHub vim/vim versiones anteriores a 9.0.0046"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0046", "matchCriteriaId": "93C683F1-9B1C-4C94-AADB-B10E747BF83E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/32acf1f1a72ebb9d8942b9c9d80023bf1bb668ea", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/1eed7009-db6d-487b-bc41-8f2fd260483f", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/32acf1f1a72ebb9d8942b9c9d80023bf1bb668ea"}}