{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * move.c: Functions for moving the cursor and scrolling text.\n *\n * There are two ways to move the cursor:\n * 1. Move the cursor directly, the text is scrolled to keep the cursor in the\n *    window.\n * 2. Scroll the text, the cursor is moved into the text visible in the\n *    window.\n * The 'scrolloff' option makes this a bit complicated.\n */\n\n#include \"vim.h\"\n\nstatic int scrolljump_value(void);\nstatic int check_top_offset(void);\nstatic void curs_rows(win_T *wp);\n\ntypedef struct\n{\n    linenr_T\t    lnum;\t// line number\n#ifdef FEAT_DIFF\n    int\t\t    fill;\t// filler lines\n#endif\n    int\t\t    height;\t// height of added line\n} lineoff_T;\n\nstatic void topline_back(lineoff_T *lp);\nstatic void botline_forw(lineoff_T *lp);\n\n/*\n * Reduce \"n\" for the screen lines skipped with \"wp->w_skipcol\".\n */\n    static int\nadjust_plines_for_skipcol(win_T *wp, int n)\n{\n    if (wp->w_skipcol == 0)\n\treturn n;\n\n    int off = 0;\n    int width = wp->w_width - win_col_off(wp);\n    if (wp->w_skipcol >= width)\n    {\n\t++off;\n\tint skip = wp->w_skipcol - width;\n\twidth += win_col_off2(wp);\n\twhile (skip >= width)\n\t{\n\t    ++off;\n\t    skip -= width;\n\t}\n    }\n    wp->w_valid &= ~VALID_WROW;\n    return n - off;\n}\n\n/*\n * Return how many lines \"lnum\" will take on the screen, taking into account\n * whether it is the first line, whether w_skipcol is non-zero and limiting to\n * the window height.\n */\n    static int\nplines_correct_topline(win_T *wp, linenr_T lnum)\n{\n    int n;\n#ifdef FEAT_DIFF\n    if (lnum == wp->w_topline)\n\tn = plines_win_nofill(wp, lnum, FALSE) + wp->w_topfill;\n    else\n#endif\n\tn = plines_win(wp, lnum, FALSE);\n    if (lnum == wp->w_topline)\n\tn = adjust_plines_for_skipcol(wp, n);\n    if (n > wp->w_height)\n\tn = wp->w_height;\n    return n;\n}\n\n/*\n * Compute wp->w_botline for the current wp->w_topline.  Can be called after\n * wp->w_topline changed.\n */\n    static void\ncomp_botline(win_T *wp)\n{\n    int\t\tn;\n    linenr_T\tlnum;\n    int\t\tdone;\n#ifdef FEAT_FOLDING\n    linenr_T    last;\n    int\t\tfolded;\n#endif\n\n    /*\n     * If w_cline_row is valid, start there.\n     * Otherwise have to start at w_topline.\n     */\n    check_cursor_moved(wp);\n    if (wp->w_valid & VALID_CROW)\n    {\n\tlnum = wp->w_cursor.lnum;\n\tdone = wp->w_cline_row;\n    }\n    else\n    {\n\tlnum = wp->w_topline;\n\tdone = 0;\n    }\n\n    for ( ; lnum <= wp->w_buffer->b_ml.ml_line_count; ++lnum)\n    {\n#ifdef FEAT_FOLDING\n\tlast = lnum;\n\tfolded = FALSE;\n\tif (hasFoldingWin(wp, lnum, NULL, &last, TRUE, NULL))\n\t{\n\t    n = 1;\n\t    folded = TRUE;\n\t}\n\telse\n#endif\n\t{\n\t    n = plines_correct_topline(wp, lnum);\n\t}\n\tif (\n#ifdef FEAT_FOLDING\n\t\tlnum <= wp->w_cursor.lnum && last >= wp->w_cursor.lnum\n#else\n\t\tlnum == wp->w_cursor.lnum\n#endif\n\t   )\n\t{\n\t    wp->w_cline_row = done;\n\t    wp->w_cline_height = n;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = folded;\n#endif\n\t    redraw_for_cursorline(wp);\n\t    wp->w_valid |= (VALID_CROW|VALID_CHEIGHT);\n\t}\n\tif (done + n > wp->w_height)\n\t    break;\n\tdone += n;\n#ifdef FEAT_FOLDING\n\tlnum = last;\n#endif\n    }\n\n    // wp->w_botline is the line that is just below the window\n    wp->w_botline = lnum;\n    wp->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\n    set_empty_rows(wp, done);\n}\n\n/*\n * Redraw when w_cline_row changes and 'relativenumber' or 'cursorline' is\n * set.\n */\n    void\nredraw_for_cursorline(win_T *wp)\n{\n    if ((wp->w_p_rnu\n#ifdef FEAT_SYN_HL\n\t\t|| wp->w_p_cul\n#endif\n\t\t)\n\t    && (wp->w_valid & VALID_CROW) == 0\n\t    && !pum_visible())\n    {\n\t// win_line() will redraw the number column and cursorline only.\n\tredraw_win_later(wp, UPD_VALID);\n    }\n}\n\n#ifdef FEAT_SYN_HL\n/*\n * Redraw when w_virtcol changes and 'cursorcolumn' is set or 'cursorlineopt'\n * contains \"screenline\".\n */\n    static void\nredraw_for_cursorcolumn(win_T *wp)\n{\n    if ((wp->w_valid & VALID_VIRTCOL) == 0 && !pum_visible())\n    {\n\t// When 'cursorcolumn' is set need to redraw with UPD_SOME_VALID.\n\tif (wp->w_p_cuc)\n\t    redraw_win_later(wp, UPD_SOME_VALID);\n\t// When 'cursorlineopt' contains \"screenline\" need to redraw with\n\t// UPD_VALID.\n\telse if (wp->w_p_cul && (wp->w_p_culopt_flags & CULOPT_SCRLINE))\n\t    redraw_win_later(wp, UPD_VALID);\n    }\n}\n#endif\n\n/*\n * Calculates how much overlap the smoothscroll marker \"<<<\" overlaps with\n * buffer text for curwin.\n * Parameter \"extra2\" should be the padding on the 2nd line, not the first\n * line.\n * Returns the number of columns of overlap with buffer text, excluding the\n * extra padding on the ledge.\n */\n    static int\nsmoothscroll_marker_overlap(int extra2)\n{\n#if defined(FEAT_LINEBREAK)\n    // We don't draw the <<< marker when in showbreak mode, thus no need to\n    // account for it.  See wlv_screen_line().\n    if (*get_showbreak_value(curwin) != NUL)\n\treturn 0;\n#endif\n    return extra2 > 3 ? 0 : 3 - extra2;\n}\n\n/*\n * Calculates the skipcol offset for window \"wp\" given how many\n * physical lines we want to scroll down.\n */\n    static int\nskipcol_from_plines(win_T *wp, int plines_off)\n{\n    int width1 = wp->w_width - win_col_off(wp);\n\n    int skipcol = 0;\n    if (plines_off > 0)\n\tskipcol += width1;\n    if (plines_off > 1)\n\tskipcol += (width1 + win_col_off2(wp)) * (plines_off - 1);\n    return skipcol;\n}\n\n/*\n * Set curwin->s_skipcol to zero and redraw later if needed.\n */\n    static void\nreset_skipcol(void)\n{\n    if (curwin->w_skipcol == 0)\n\treturn;\n\n    curwin->w_skipcol = 0;\n\n    // Should use the least expensive way that displays all that changed.\n    // UPD_NOT_VALID is too expensive, UPD_REDRAW_TOP does not redraw\n    // enough when the top line gets another screen line.\n    redraw_later(UPD_SOME_VALID);\n}\n\n/*\n * Update curwin->w_topline and redraw if necessary.\n * Used to update the screen before printing a message.\n */\n    void\nupdate_topline_redraw(void)\n{\n    update_topline();\n    if (must_redraw)\n\tupdate_screen(0);\n}\n\n/*\n * Update curwin->w_topline to move the cursor onto the screen.\n */\n    void\nupdate_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // Cursor is updated instead when this is TRUE for 'splitkeep'.\n    if (skip_update_topline)\n\treturn;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(UPD_NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1 || curwin->w_skipcol > 0)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t    else if (curwin->w_cursor.lnum == curwin->w_topline)\n\t    {\n\t\tcolnr_T vcol;\n\n\t\t// Check that the cursor position is visible.  Add columns for\n\t\t// the smoothscroll marker \"<<<\" displayed in the top-left if\n\t\t// needed.\n\t\tgetvvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t\tint smoothscroll_overlap = smoothscroll_marker_overlap(\n\t\t\t\t\t curwin_col_off() - curwin_col_off2());\n\t\tif (curwin->w_skipcol + smoothscroll_overlap > vcol)\n\t\t    check_topline = TRUE;\n\t    }\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE, FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t   >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE, FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tredraw_later(UPD_VALID);\n\treset_skipcol();\n\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}\n\n/*\n * Return the scrolljump value to use for the current window.\n * When 'scrolljump' is positive use it as-is.\n * When 'scrolljump' is negative use it as a percentage of the window height.\n */\n    static int\nscrolljump_value(void)\n{\n    if (p_sj >= 0)\n\treturn (int)p_sj;\n    return (curwin->w_height * -p_sj) / 100;\n}\n\n/*\n * Return TRUE when there are not 'scrolloff' lines above the cursor for the\n * current window.\n */\n    static int\ncheck_top_offset(void)\n{\n    lineoff_T\tloff;\n    int\t\tn;\n    long\tso = get_scrolloff_value();\n\n    if (curwin->w_cursor.lnum < curwin->w_topline + so\n#ifdef FEAT_FOLDING\n\t\t    || hasAnyFolding(curwin)\n#endif\n\t    )\n    {\n\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n\tn = curwin->w_topfill;\t    // always have this context\n#else\n\tn = 0;\n#endif\n\t// Count the visible screen lines above the cursor line.\n\twhile (n < so)\n\t{\n\t    topline_back(&loff);\n\t    // Stop when included a line above the window.\n\t    if (loff.lnum < curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t    || (loff.lnum == curwin->w_topline && loff.fill > 0)\n#endif\n\t\t    )\n\t\tbreak;\n\t    n += loff.height;\n\t}\n\tif (n < so)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Update w_curswant.\n */\n    void\nupdate_curswant_force(void)\n{\n    validate_virtcol();\n    curwin->w_curswant = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t- curwin->w_virtcol_first_char\n#endif\n\t;\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Update w_curswant if w_set_curswant is set.\n */\n    void\nupdate_curswant(void)\n{\n    if (curwin->w_set_curswant)\n\tupdate_curswant_force();\n}\n\n/*\n * Check if the cursor has moved.  Set the w_valid flag accordingly.\n */\n    void\ncheck_cursor_moved(win_T *wp)\n{\n    if (wp->w_cursor.lnum != wp->w_valid_cursor.lnum)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t      |VALID_CHEIGHT|VALID_CROW|VALID_TOPLINE\n\t\t\t\t      |VALID_BOTLINE|VALID_BOTLINE_AP);\n\twp->w_valid_cursor = wp->w_cursor;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_skipcol = wp->w_skipcol;\n    }\n    else if (wp->w_skipcol != wp->w_valid_skipcol)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t      |VALID_CHEIGHT|VALID_CROW\n\t\t\t\t      |VALID_BOTLINE|VALID_BOTLINE_AP);\n\twp->w_valid_cursor = wp->w_cursor;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_skipcol = wp->w_skipcol;\n    }\n    else if (wp->w_cursor.col != wp->w_valid_cursor.col\n\t     || wp->w_leftcol != wp->w_valid_leftcol\n\t     || wp->w_cursor.coladd != wp->w_valid_cursor.coladd)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\twp->w_valid_cursor.col = wp->w_cursor.col;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_cursor.coladd = wp->w_cursor.coladd;\n    }\n}\n\n/*\n * Call this function when some window settings have changed, which require\n * the cursor position, botline and topline to be recomputed and the window to\n * be redrawn.  E.g, when changing the 'wrap' option or folding.\n */\n    void\nchanged_window_setting(void)\n{\n    changed_window_setting_win(curwin);\n}\n\n    void\nchanged_window_setting_win(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP|VALID_TOPLINE);\n    redraw_win_later(wp, UPD_NOT_VALID);\n}\n\n/*\n * Call changed_window_setting_win() for every window containing \"buf\".\n */\n    void\nchanged_window_setting_buf(buf_T *buf)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == buf)\n\t    changed_window_setting_win(wp);\n}\n\n/*\n * Set wp->w_topline to a certain number.\n */\n    void\nset_topline(win_T *wp, linenr_T lnum)\n{\n#ifdef FEAT_DIFF\n    linenr_T prev_topline = wp->w_topline;\n#endif\n\n#ifdef FEAT_FOLDING\n    // go to first of folded lines\n    (void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n    // Approximate the value of w_botline\n    wp->w_botline += lnum - wp->w_topline;\n    if (wp->w_botline > wp->w_buffer->b_ml.ml_line_count + 1)\n\twp->w_botline = wp->w_buffer->b_ml.ml_line_count + 1;\n    wp->w_topline = lnum;\n    wp->w_topline_was_set = TRUE;\n#ifdef FEAT_DIFF\n    if (lnum != prev_topline)\n\t// Keep the filler lines when the topline didn't change.\n\twp->w_topfill = 0;\n#endif\n    wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);\n    // Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.\n    redraw_later(UPD_VALID);\n}\n\n/*\n * Call this function when the length of the cursor line (in screen\n * characters) has changed, and the change is before the cursor.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_cline_bef_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_cline_bef_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Call this function when the length of a line (in screen characters) above\n * the cursor have changed.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_line_abv_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_line_abv_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Display of line has changed for \"buf\", invalidate cursor position and\n * w_botline.\n */\n    void\nchanged_line_display_buf(buf_T *buf)\n{\n    win_T *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer == buf)\n\t    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t|VALID_CROW|VALID_CHEIGHT\n\t\t\t\t|VALID_TOPLINE|VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n/*\n * Make sure the value of curwin->w_botline is valid.\n */\n    void\nvalidate_botline(void)\n{\n    validate_botline_win(curwin);\n}\n\n/*\n * Make sure the value of wp->w_botline is valid.\n */\n    void\nvalidate_botline_win(win_T *wp)\n{\n    if (!(wp->w_valid & VALID_BOTLINE))\n\tcomp_botline(wp);\n}\n\n/*\n * Mark curwin->w_botline as invalid (because of some change in the buffer).\n */\n    void\ninvalidate_botline(void)\n{\n    curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\ninvalidate_botline_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\napproximate_botline_win(\n    win_T\t*wp)\n{\n    wp->w_valid &= ~VALID_BOTLINE;\n}\n\n/*\n * Return TRUE if curwin->w_wrow and curwin->w_wcol are valid.\n */\n    int\ncursor_valid(void)\n{\n    check_cursor_moved(curwin);\n    return ((curwin->w_valid & (VALID_WROW|VALID_WCOL)) ==\n\t\t\t\t\t\t      (VALID_WROW|VALID_WCOL));\n}\n\n/*\n * Validate cursor position.  Makes sure w_wrow and w_wcol are valid.\n * w_topline must be valid, you may need to call update_topline() first!\n */\n    void\nvalidate_cursor(void)\n{\n    check_cursor_lnum();\n    check_cursor_moved(curwin);\n    if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))\n\tcurs_columns(TRUE);\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * validate w_cline_row.\n */\n    void\nvalidate_cline_row(void)\n{\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n}\n#endif\n\n/*\n * Compute wp->w_cline_row and wp->w_cline_height, based on the current value\n * of wp->w_topline.\n */\n    static void\ncurs_rows(win_T *wp)\n{\n    linenr_T\tlnum;\n    int\t\ti;\n    int\t\tall_invalid;\n    int\t\tvalid;\n#ifdef FEAT_FOLDING\n    long\tfold_count;\n#endif\n\n    // Check if wp->w_lines[].wl_size is invalid\n    all_invalid = (!redrawing()\n\t\t\t|| wp->w_lines_valid == 0\n\t\t\t|| wp->w_lines[0].wl_lnum > wp->w_topline);\n    i = 0;\n    wp->w_cline_row = 0;\n    for (lnum = wp->w_topline; lnum < wp->w_cursor.lnum; ++i)\n    {\n\tvalid = FALSE;\n\tif (!all_invalid && i < wp->w_lines_valid)\n\t{\n\t    if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)\n\t\tcontinue;\t\t// skip changed or deleted lines\n\t    if (wp->w_lines[i].wl_lnum == lnum)\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Check for newly inserted lines below this row, in which\n\t\t// case we need to check for folded lines.\n\t\tif (!wp->w_buffer->b_mod_set\n\t\t\t|| wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum\n\t\t\t|| wp->w_buffer->b_mod_top\n\t\t\t\t\t     > wp->w_lines[i].wl_lastlnum + 1)\n#endif\n\t\tvalid = TRUE;\n\t    }\n\t    else if (wp->w_lines[i].wl_lnum > lnum)\n\t\t--i;\t\t\t// hold at inserted lines\n\t}\n\tif (valid\n#ifdef FEAT_DIFF\n\t\t&& (lnum != wp->w_topline || !wp->w_p_diff)\n#endif\n\t\t)\n\t{\n#ifdef FEAT_FOLDING\n\t    lnum = wp->w_lines[i].wl_lastlnum + 1;\n\t    // Cursor inside folded lines, don't count this row\n\t    if (lnum > wp->w_cursor.lnum)\n\t\tbreak;\n#else\n\t    ++lnum;\n#endif\n\t    wp->w_cline_row += wp->w_lines[i].wl_size;\n\t}\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    fold_count = foldedCount(wp, lnum, NULL);\n\t    if (fold_count)\n\t    {\n\t\tlnum += fold_count;\n\t\tif (lnum > wp->w_cursor.lnum)\n\t\t    break;\n\t\t++wp->w_cline_row;\n\t    }\n\t    else\n#endif\n\t    {\n\t\twp->w_cline_row += plines_correct_topline(wp, lnum);\n\t\t++lnum;\n\t    }\n\t}\n    }\n\n    check_cursor_moved(wp);\n    if (!(wp->w_valid & VALID_CHEIGHT))\n    {\n\tif (all_invalid\n\t\t|| i == wp->w_lines_valid\n\t\t|| (i < wp->w_lines_valid\n\t\t    && (!wp->w_lines[i].wl_valid\n\t\t\t|| wp->w_lines[i].wl_lnum != wp->w_cursor.lnum)))\n\t{\n#ifdef FEAT_DIFF\n\t    if (wp->w_cursor.lnum == wp->w_topline)\n\t\twp->w_cline_height = plines_win_nofill(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t\tTRUE) + wp->w_topfill;\n\t    else\n#endif\n\t\twp->w_cline_height = plines_win(wp, wp->w_cursor.lnum, TRUE);\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse if (i > wp->w_lines_valid)\n\t{\n\t    // a line that is too long to fit on the last screen line\n\t    wp->w_cline_height = 0;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse\n\t{\n\t    wp->w_cline_height = wp->w_lines[i].wl_size;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = wp->w_lines[i].wl_folded;\n#endif\n\t}\n    }\n\n    redraw_for_cursorline(curwin);\n    wp->w_valid |= VALID_CROW|VALID_CHEIGHT;\n}\n\n/*\n * Validate curwin->w_virtcol only.\n */\n    void\nvalidate_virtcol(void)\n{\n    validate_virtcol_win(curwin);\n}\n\n/*\n * Validate wp->w_virtcol only.\n */\n    void\nvalidate_virtcol_win(win_T *wp)\n{\n    check_cursor_moved(wp);\n\n    if (wp->w_valid & VALID_VIRTCOL)\n\treturn;\n\n#ifdef FEAT_PROP_POPUP\n    wp->w_virtcol_first_char = 0;\n#endif\n    getvvcol(wp, &wp->w_cursor, NULL, &(wp->w_virtcol), NULL);\n#ifdef FEAT_SYN_HL\n    redraw_for_cursorcolumn(wp);\n#endif\n    wp->w_valid |= VALID_VIRTCOL;\n}\n\n/*\n * Validate curwin->w_cline_height only.\n */\n    void\nvalidate_cheight(void)\n{\n    check_cursor_moved(curwin);\n\n    if (curwin->w_valid & VALID_CHEIGHT)\n\treturn;\n\n#ifdef FEAT_DIFF\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_cline_height = plines_nofill(curwin->w_cursor.lnum)\n\t    + curwin->w_topfill;\n    else\n#endif\n\tcurwin->w_cline_height = plines(curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n    curwin->w_cline_folded = hasFolding(curwin->w_cursor.lnum, NULL, NULL);\n#endif\n    curwin->w_valid |= VALID_CHEIGHT;\n}\n\n/*\n * Validate w_wcol and w_virtcol only.\n */\n    void\nvalidate_cursor_col(void)\n{\n    colnr_T off;\n    colnr_T col;\n    int     width;\n\n    validate_virtcol();\n\n    if (curwin->w_valid & VALID_WCOL)\n\treturn;\n\n    col = curwin->w_virtcol;\n    off = curwin_col_off();\n    col += off;\n    width = curwin->w_width - off + curwin_col_off2();\n\n    // long line wrapping, adjust curwin->w_wrow\n    if (curwin->w_p_wrap\n\t    && col >= (colnr_T)curwin->w_width\n\t    && width > 0)\n\t// use same formula as what is used in curs_columns()\n\tcol -= ((col - curwin->w_width) / width + 1) * width;\n    if (col > (int)curwin->w_leftcol)\n\tcol -= curwin->w_leftcol;\n    else\n\tcol = 0;\n    curwin->w_wcol = col;\n\n    curwin->w_valid |= VALID_WCOL;\n#ifdef FEAT_PROP_POPUP\n    curwin->w_flags &= ~WFLAG_WCOL_OFF_ADDED;\n#endif\n}\n\n/*\n * Compute offset of a window, occupied by absolute or relative line number,\n * fold column and sign column (these don't move when scrolling horizontally).\n */\n    int\nwin_col_off(win_T *wp)\n{\n    return (((wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) + 1 : 0)\n\t    + (cmdwin_type == 0 || wp != curwin ? 0 : 1)\n#ifdef FEAT_FOLDING\n\t    + wp->w_p_fdc\n#endif\n#ifdef FEAT_SIGNS\n\t    + (signcolumn_on(wp) ? 2 : 0)\n#endif\n\t   );\n}\n\n    int\ncurwin_col_off(void)\n{\n    return win_col_off(curwin);\n}\n\n/*\n * Return the difference in column offset for the second screen line of a\n * wrapped line.  It's positive if 'number' or 'relativenumber' is on and 'n'\n * is in 'cpoptions'.\n */\n    int\nwin_col_off2(win_T *wp)\n{\n    if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)\n\treturn number_width(wp) + 1;\n    return 0;\n}\n\n    int\ncurwin_col_off2(void)\n{\n    return win_col_off2(curwin);\n}\n\n/*\n * Compute curwin->w_wcol and curwin->w_virtcol.\n * Also updates curwin->w_wrow and curwin->w_cline_row.\n * Also updates curwin->w_leftcol.\n */\n    void\ncurs_columns(\n    int\t\tmay_scroll)\t// when TRUE, may scroll horizontally\n{\n    int\t\tdiff;\n    int\t\textra;\t\t// offset for first screen line\n    int\t\toff_left, off_right;\n    int\t\tn;\n    int\t\tp_lines;\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2 = 0;\t// text width for second and later screen line\n    int\t\tnew_leftcol;\n    colnr_T\tstartcol;\n    colnr_T\tendcol;\n    colnr_T\tprev_skipcol;\n    long\tso = get_scrolloff_value();\n    long\tsiso = get_sidescrolloff_value();\n    int\t\tdid_sub_skipcol = FALSE;\n\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n\n    /*\n     * Next make sure that w_cline_row is valid.\n     */\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n\n#ifdef FEAT_PROP_POPUP\n    // will be set by getvvcol() but not reset\n    curwin->w_virtcol_first_char = 0;\n#endif\n\n    /*\n     * Compute the number of virtual columns.\n     */\n#ifdef FEAT_FOLDING\n    if (curwin->w_cline_folded)\n\t// In a folded line the cursor is always in the first column\n\tstartcol = curwin->w_virtcol = endcol = curwin->w_leftcol;\n    else\n#endif\n\tgetvvcol(curwin, &curwin->w_cursor,\n\t\t\t\t&startcol, &(curwin->w_virtcol), &endcol);\n\n    // remove '$' from change command when cursor moves onto it\n    if (startcol > dollar_vcol)\n\tdollar_vcol = -1;\n\n    extra = curwin_col_off();\n    curwin->w_wcol = curwin->w_virtcol + extra;\n    endcol += extra;\n\n    /*\n     * Now compute w_wrow, counting screen lines from w_cline_row.\n     */\n    curwin->w_wrow = curwin->w_cline_row;\n\n    width1 = curwin->w_width - extra;\n    if (width1 <= 0)\n    {\n\t// No room for text, put cursor in last char of window.\n\t// If not wrapping, the last non-empty line.\n\tcurwin->w_wcol = curwin->w_width - 1;\n\tif (curwin->w_p_wrap)\n\t    curwin->w_wrow = curwin->w_height - 1;\n\telse\n\t    curwin->w_wrow = curwin->w_height - 1 - curwin->w_empty_rows;\n    }\n    else if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\twidth2 = width1 + curwin_col_off2();\n\n\t// skip columns that are not visible\n\tif (curwin->w_cursor.lnum == curwin->w_topline\n\t\t&& curwin->w_skipcol > 0\n\t\t&& curwin->w_wcol >= curwin->w_skipcol)\n\t{\n\t    // Deduct by multiples of width2.  This allows the long line\n\t    // wrapping formula below to correctly calculate the w_wcol value\n\t    // when wrapping.\n\t    if (curwin->w_skipcol <= width1)\n\t\tcurwin->w_wcol -= width2;\n\t    else\n\t\tcurwin->w_wcol -= width2\n\t\t\t       * (((curwin->w_skipcol - width1) / width2) + 1);\n\n\t    did_sub_skipcol = TRUE;\n\t}\n\n\t// long line wrapping, adjust curwin->w_wrow\n\tif (curwin->w_wcol >= curwin->w_width)\n\t{\n\t    // this same formula is used in validate_cursor_col()\n\t    n = (curwin->w_wcol - curwin->w_width) / width2 + 1;\n\t    curwin->w_wcol -= n * width2;\n\t    curwin->w_wrow += n;\n\n#ifdef FEAT_LINEBREAK\n\t    // When cursor wraps to first char of next line in Insert\n\t    // mode, the 'showbreak' string isn't shown, backup to first\n\t    // column\n\t    char_u *sbr = get_showbreak_value(curwin);\n\t    if (*sbr && *ml_get_cursor() == NUL\n\t\t\t\t    && curwin->w_wcol == vim_strsize(sbr))\n\t\tcurwin->w_wcol = 0;\n#endif\n\t}\n    }\n\n    // No line wrapping: compute curwin->w_leftcol if scrolling is on and line\n    // is not folded.\n    // If scrolling is off, curwin->w_leftcol is assumed to be 0\n    else if (may_scroll\n#ifdef FEAT_FOLDING\n\t    && !curwin->w_cline_folded\n#endif\n\t    )\n    {\n#ifdef FEAT_PROP_POPUP\n\tif (curwin->w_virtcol_first_char > 0)\n\t{\n\t    int cols = (curwin->w_width - extra);\n\t    int rows = cols > 0 ? curwin->w_virtcol_first_char / cols : 1;\n\n\t    // each \"above\" text prop shifts the text one row down\n\t    curwin->w_wrow += rows;\n\t    curwin->w_wcol -= rows * cols;\n\t    endcol -= rows * cols;\n\t    curwin->w_cline_height = rows + 1;\n\t}\n#endif\n\t/*\n\t * If Cursor is left of the screen, scroll rightwards.\n\t * If Cursor is right of the screen, scroll leftwards\n\t * If we get closer to the edge than 'sidescrolloff', scroll a little\n\t * extra\n\t */\n\toff_left = (int)startcol - (int)curwin->w_leftcol - siso;\n\toff_right = (int)endcol - (int)(curwin->w_leftcol + curwin->w_width\n\t\t\t\t\t\t\t\t- siso) + 1;\n\tif (off_left < 0 || off_right > 0)\n\t{\n\t    if (off_left < 0)\n\t\tdiff = -off_left;\n\t    else\n\t\tdiff = off_right;\n\n\t    // When far off or not enough room on either side, put cursor in\n\t    // middle of window.\n\t    if (p_ss == 0 || diff >= width1 / 2 || off_right >= off_left)\n\t\tnew_leftcol = curwin->w_wcol - extra - width1 / 2;\n\t    else\n\t    {\n\t\tif (diff < p_ss)\n\t\t    diff = p_ss;\n\t\tif (off_left < 0)\n\t\t    new_leftcol = curwin->w_leftcol - diff;\n\t\telse\n\t\t    new_leftcol = curwin->w_leftcol + diff;\n\t    }\n\t    if (new_leftcol < 0)\n\t\tnew_leftcol = 0;\n\t    if (new_leftcol != (int)curwin->w_leftcol)\n\t    {\n\t\tcurwin->w_leftcol = new_leftcol;\n\t\t// screen has to be redrawn with new curwin->w_leftcol\n\t\tredraw_later(UPD_NOT_VALID);\n\t    }\n\t}\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    }\n    else if (curwin->w_wcol > (int)curwin->w_leftcol)\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    else\n\tcurwin->w_wcol = 0;\n\n#ifdef FEAT_DIFF\n    // Skip over filler lines.  At the top use w_topfill, there\n    // may be some filler lines above the window.\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_wrow += curwin->w_topfill;\n    else\n\tcurwin->w_wrow += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    prev_skipcol = curwin->w_skipcol;\n\n    p_lines = 0;\n\n    if ((curwin->w_wrow >= curwin->w_height\n\t\t|| ((prev_skipcol > 0\n\t\t\t|| curwin->w_wrow + so >= curwin->w_height)\n\t\t    && (p_lines =\n#ifdef FEAT_DIFF\n\t\t\tplines_win_nofill\n#else\n\t\t\tplines_win\n#endif\n\t\t\t(curwin, curwin->w_cursor.lnum, FALSE))\n\t\t\t\t\t\t    - 1 >= curwin->w_height))\n\t    && curwin->w_height != 0\n\t    && curwin->w_cursor.lnum == curwin->w_topline\n\t    && width2 > 0\n\t    && curwin->w_width != 0)\n    {\n\t// Cursor past end of screen.  Happens with a single line that does\n\t// not fit on screen.  Find a skipcol to show the text around the\n\t// cursor.  Avoid scrolling all the time. compute value of \"extra\":\n\t// 1: Less than 'scrolloff' lines above\n\t// 2: Less than 'scrolloff' lines below\n\t// 3: both of them\n\textra = 0;\n\tif (curwin->w_skipcol + so * width2 > curwin->w_virtcol)\n\t    extra = 1;\n\t// Compute last display line of the buffer line that we want at the\n\t// bottom of the window.\n\tif (p_lines == 0)\n\t    p_lines = plines_win(curwin, curwin->w_cursor.lnum, FALSE);\n\t--p_lines;\n\tif (p_lines > curwin->w_wrow + so)\n\t    n = curwin->w_wrow + so;\n\telse\n\t    n = p_lines;\n\tif ((colnr_T)n >= curwin->w_height + curwin->w_skipcol / width2 - so)\n\t    extra += 2;\n\n\tif (extra == 3 || curwin->w_height <= so * 2)\n\t{\n\t    // not enough room for 'scrolloff', put cursor in the middle\n\t    n = curwin->w_virtcol / width2;\n\t    if (n > curwin->w_height / 2)\n\t\tn -= curwin->w_height / 2;\n\t    else\n\t\tn = 0;\n\t    // don't skip more than necessary\n\t    if (n > p_lines - curwin->w_height + 1)\n\t\tn = p_lines - curwin->w_height + 1;\n\t    curwin->w_skipcol = n * width2;\n\t}\n\telse if (extra == 1)\n\t{\n\t    // less than 'scrolloff' lines above, decrease skipcol\n\t    extra = (curwin->w_skipcol + so * width2 - curwin->w_virtcol\n\t\t\t\t     + width2 - 1) / width2;\n\t    if (extra > 0)\n\t    {\n\t\tif ((colnr_T)(extra * width2) > curwin->w_skipcol)\n\t\t    extra = curwin->w_skipcol / width2;\n\t\tcurwin->w_skipcol -= extra * width2;\n\t    }\n\t}\n\telse if (extra == 2)\n\t{\n\t    // less than 'scrolloff' lines below, increase skipcol\n\t    endcol = (n - curwin->w_height + 1) * width2;\n\t    while (endcol > curwin->w_virtcol)\n\t\tendcol -= width2;\n\t    if (endcol > curwin->w_skipcol)\n\t\tcurwin->w_skipcol = endcol;\n\t}\n\n\t// adjust w_wrow for the changed w_skipcol\n\tif (did_sub_skipcol)\n\t    curwin->w_wrow -= (curwin->w_skipcol - prev_skipcol) / width2;\n\telse\n\t    curwin->w_wrow -= curwin->w_skipcol / width2;\n\n\tif (curwin->w_wrow >= curwin->w_height)\n\t{\n\t    // small window, make sure cursor is in it\n\t    extra = curwin->w_wrow - curwin->w_height + 1;\n\t    curwin->w_skipcol += extra * width2;\n\t    curwin->w_wrow -= extra;\n\t}\n\n\textra = ((int)prev_skipcol - (int)curwin->w_skipcol) / width2;\n\tif (extra > 0)\n\t    win_ins_lines(curwin, 0, extra, FALSE, FALSE);\n\telse if (extra < 0)\n\t    win_del_lines(curwin, 0, -extra, FALSE, FALSE, 0);\n    }\n    else if (!curwin->w_p_sms)\n\tcurwin->w_skipcol = 0;\n    if (prev_skipcol != curwin->w_skipcol)\n\tredraw_later(UPD_SOME_VALID);\n\n#ifdef FEAT_SYN_HL\n    redraw_for_cursorcolumn(curwin);\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\n    if (popup_is_popup(curwin) && curbuf->b_term != NULL)\n    {\n\tcurwin->w_wrow += popup_top_extra(curwin);\n\tcurwin->w_wcol += popup_left_extra(curwin);\n\tcurwin->w_flags |= WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED;\n    }\n    else\n\tcurwin->w_flags &= ~(WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED);\n#endif\n\n    // now w_leftcol and w_skipcol are valid, avoid check_cursor_moved()\n    // thinking otherwise\n    curwin->w_valid_leftcol = curwin->w_leftcol;\n    curwin->w_valid_skipcol = curwin->w_skipcol;\n\n    curwin->w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;\n}\n\n#if (defined(FEAT_EVAL) || defined(FEAT_PROP_POPUP)) || defined(PROTO)\n/*\n * Compute the screen position of text character at \"pos\" in window \"wp\"\n * The resulting values are one-based, zero when character is not visible.\n */\n    void\ntextpos2screenpos(\n\twin_T\t*wp,\n\tpos_T\t*pos,\n\tint\t*rowp,\t// screen row\n\tint\t*scolp,\t// start screen column\n\tint\t*ccolp,\t// cursor screen column\n\tint\t*ecolp)\t// end screen column\n{\n    colnr_T\tscol = 0, ccol = 0, ecol = 0;\n    int\t\trow = 0;\n    int\t\trowoff = 0;\n    colnr_T\tcoloff = 0;\n\n    if (pos->lnum >= wp->w_topline && pos->lnum <= wp->w_botline)\n    {\n\tcolnr_T\t    col;\n\tint\t    width;\n\tlinenr_T    lnum = pos->lnum;\n#ifdef FEAT_FOLDING\n\tint\t    is_folded;\n\n\tis_folded = hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n\trow = plines_m_win(wp, wp->w_topline, lnum - 1) + 1;\n\n#ifdef FEAT_DIFF\n\t// Add filler lines above this buffer line.\n\trow += diff_check_fill(wp, lnum);\n#endif\n\n\tcolnr_T\toff = win_col_off(wp);\n#ifdef FEAT_FOLDING\n\tif (is_folded)\n\t{\n\t    row += W_WINROW(wp);\n\t    coloff = wp->w_wincol + 1 + off;\n\t}\n\telse\n#endif\n\t{\n\t    getvcol(wp, pos, &scol, &ccol, &ecol);\n\n\t    // similar to what is done in validate_cursor_col()\n\t    col = scol;\n\t    col += off;\n\t    width = wp->w_width - off + win_col_off2(wp);\n\n\t    // long line wrapping, adjust row\n\t    if (wp->w_p_wrap\n\t\t    && col >= (colnr_T)wp->w_width\n\t\t    && width > 0)\n\t    {\n\t\t// use same formula as what is used in curs_columns()\n\t\trowoff = ((col - wp->w_width) / width + 1);\n\t\tcol -= rowoff * width;\n\t    }\n\t    col -= wp->w_leftcol;\n\t    if (col >= wp->w_width)\n\t\tcol = -1;\n\t    if (col >= 0 && row + rowoff <= wp->w_height)\n\t    {\n\t\tcoloff = col - scol + wp->w_wincol + 1;\n\t\trow += W_WINROW(wp);\n\t    }\n\t    else\n\t\t// character is left, right or below of the window\n\t\trow = rowoff = scol = ccol = ecol = 0;\n\t}\n    }\n    *rowp = row + rowoff;\n    *scolp = scol + coloff;\n    *ccolp = ccol + coloff;\n    *ecolp = ecol + coloff;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"screenpos({winid}, {lnum}, {col})\" function\n */\n    void\nf_screenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    dict_T\t*dict;\n    win_T\t*wp;\n    pos_T\tpos;\n    int\t\trow = 0;\n    int\t\tscol = 0, ccol = 0, ecol = 0;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n    dict = rettv->vval.v_dict;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    pos.lnum = tv_get_number(&argvars[1]);\n    if (pos.lnum > wp->w_buffer->b_ml.ml_line_count)\n    {\n\tsemsg(_(e_invalid_line_number_nr), pos.lnum);\n\treturn;\n    }\n    pos.col = tv_get_number(&argvars[2]) - 1;\n    pos.coladd = 0;\n    textpos2screenpos(wp, &pos, &row, &scol, &ccol, &ecol);\n\n    dict_add_number(dict, \"row\", row);\n    dict_add_number(dict, \"col\", scol);\n    dict_add_number(dict, \"curscol\", ccol);\n    dict_add_number(dict, \"endcol\", ecol);\n}\n\n/*\n * \"virtcol2col({winid}, {lnum}, {col})\" function\n */\n    void\nf_virtcol2col(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    win_T\t*wp;\n    linenr_T\tlnum;\n    int\t\tscreencol;\n    int\t\terror = FALSE;\n\n    rettv->vval.v_number = -1;\n\n    if (check_for_number_arg(argvars, 0) == FAIL\n\t    || check_for_number_arg(argvars, 1) == FAIL\n\t    || check_for_number_arg(argvars, 2) == FAIL)\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    lnum = tv_get_number_chk(&argvars[1], &error);\n    if (error || lnum < 0 || lnum > wp->w_buffer->b_ml.ml_line_count)\n\treturn;\n\n    screencol = tv_get_number_chk(&argvars[2], &error);\n    if (error || screencol < 0)\n\treturn;\n\n    rettv->vval.v_number = vcol2col(wp, lnum, screencol);\n}\n#endif\n\n/*\n * Scroll the current window down by \"line_count\" logical lines.  \"CTRL-Y\"\n */\n    void\nscrolldown(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n    long\tdone = 0;\t// total # of physical lines done\n    int\t\twrow;\n    int\t\tmoved = FALSE;\n    int\t\tdo_sms = curwin->w_p_wrap && curwin->w_p_sms;\n    int\t\twidth1 = 0;\n    int\t\twidth2 = 0;\n\n    if (do_sms)\n    {\n\twidth1 = curwin->w_width - curwin_col_off();\n\twidth2 = width1 + curwin_col_off2();\n    }\n\n#ifdef FEAT_FOLDING\n    linenr_T\tfirst;\n\n    // Make sure w_topline is at the first of a sequence of folded lines.\n    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    validate_cursor();\t\t// w_wrow needs to be valid\n    for (int todo = line_count; todo > 0; --todo)\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill < diff_check(curwin, curwin->w_topline)\n\t\t&& curwin->w_topfill < curwin->w_height - 1)\n\t{\n\t    ++curwin->w_topfill;\n\t    ++done;\n\t}\n\telse\n#endif\n\t{\n\t    // break when at the very top\n\t    if (curwin->w_topline == 1\n\t\t\t\t   && (!do_sms || curwin->w_skipcol < width1))\n\t\tbreak;\n\t    if (do_sms && curwin->w_skipcol >= width1)\n\t    {\n\t\t// scroll a screen line down\n\t\tif (curwin->w_skipcol >= width1 + width2)\n\t\t    curwin->w_skipcol -= width2;\n\t\telse\n\t\t    curwin->w_skipcol -= width1;\n\t\tredraw_later(UPD_NOT_VALID);\n\t\t++done;\n\t    }\n\t    else\n\t    {\n\t\t// scroll a text line down\n\t\t--curwin->w_topline;\n\t\tcurwin->w_skipcol = 0;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n#ifdef FEAT_FOLDING\n\t\t// A sequence of folded lines only counts for one logical line\n\t\tif (hasFolding(curwin->w_topline, &first, NULL))\n\t\t{\n\t\t    ++done;\n\t\t    if (!byfold)\n\t\t\ttodo -= curwin->w_topline - first - 1;\n\t\t    curwin->w_botline -= curwin->w_topline - first;\n\t\t    curwin->w_topline = first;\n\t\t}\n\t\telse\n#endif\n\t\tif (do_sms)\n\t\t{\n\t\t    int size = win_linetabsize(curwin, curwin->w_topline,\n\t\t\t\t   ml_get(curwin->w_topline), (colnr_T)MAXCOL);\n\t\t    if (size > width1)\n\t\t    {\n\t\t\tcurwin->w_skipcol = width1;\n\t\t\tsize -= width1;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t    while (size > width2)\n\t\t    {\n\t\t\tcurwin->w_skipcol += width2;\n\t\t\tsize -= width2;\n\t\t    }\n\t\t    ++done;\n\t\t}\n\t\telse\n\t\t    done += PLINES_NOFILL(curwin->w_topline);\n\t    }\n\t}\n\t--curwin->w_botline;\t\t// approximate w_botline\n\tinvalidate_botline();\n    }\n    curwin->w_wrow += done;\t\t// keep w_wrow updated\n    curwin->w_cline_row += done;\t// keep w_cline_row updated\n\n#ifdef FEAT_DIFF\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_cline_row = 0;\n    check_topfill(curwin, TRUE);\n#endif\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and move the cursor onto the displayed part of the window.\n     */\n    wrow = curwin->w_wrow;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tvalidate_cheight();\n\twrow += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    while (wrow >= curwin->w_height && curwin->w_cursor.lnum > 1)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(curwin->w_cursor.lnum, &first, NULL))\n\t{\n\t    --wrow;\n\t    if (first == 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n\t\tcurwin->w_cursor.lnum = first - 1;\n\t}\n\telse\n#endif\n\t    wrow -= plines(curwin->w_cursor.lnum--);\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tmoved = TRUE;\n    }\n    if (moved)\n    {\n#ifdef FEAT_FOLDING\n\t// Move cursor to first line of closed fold.\n\tfoldAdjustCursor();\n#endif\n\tcoladvance(curwin->w_curswant);\n    }\n\n    if (curwin->w_cursor.lnum == curwin->w_topline && do_sms)\n    {\n\tlong\tso = get_scrolloff_value();\n\tint\tscrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n\n\t// make sure the cursor is in the visible text\n\tvalidate_virtcol();\n\tint col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;\n\tint row = 0;\n\tif (col >= width1)\n\t{\n\t    col -= width1;\n\t    ++row;\n\t}\n\tif (col > width2)\n\t{\n\t    row += col / width2;\n\t    col = col % width2;\n\t}\n\tif (row >= curwin->w_height)\n\t{\n\t    curwin->w_curswant = curwin->w_virtcol\n\t\t\t\t       - (row - curwin->w_height + 1) * width2;\n\t    coladvance(curwin->w_curswant);\n\t}\n    }\n}\n\n/*\n * Return TRUE if scrollup() will scroll by screen line rather than text line.\n */\n    static int\nscrolling_screenlines(int byfold UNUSED)\n{\n    return (curwin->w_p_wrap && curwin->w_p_sms)\n# ifdef FEAT_FOLDING\n\t|| (byfold && hasAnyFolding(curwin))\n# endif\n# ifdef FEAT_DIFF\n\t|| curwin->w_p_diff\n# endif\n\t;\n}\n\n/*\n * Scroll the current window up by \"line_count\" logical lines.  \"CTRL-E\"\n */\n    void\nscrollup(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n    int\t\tdo_sms = curwin->w_p_wrap && curwin->w_p_sms;\n\n    if (scrolling_screenlines(byfold))\n    {\n\tint\t    width1 = curwin->w_width - curwin_col_off();\n\tint\t    width2 = width1 + curwin_col_off2();\n\tint\t    size = 0;\n\tlinenr_T    prev_topline = curwin->w_topline;\n\n\tif (do_sms)\n\t    size = linetabsize(curwin, curwin->w_topline);\n\n\t// diff mode: first consume \"topfill\"\n\t// 'smoothscroll': increase \"w_skipcol\" until it goes over the end of\n\t// the line, then advance to the next line.\n\t// folding: count each sequence of folded lines as one logical line.\n\tfor (int todo = line_count; todo > 0; --todo)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t\t--curwin->w_topfill;\n\t    else\n# endif\n\t    {\n\t\tlinenr_T lnum = curwin->w_topline;\n\n# ifdef FEAT_FOLDING\n\t\tif (byfold)\n\t\t    // for a closed fold: go to the last line in the fold\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n# endif\n\t\tif (lnum == curwin->w_topline && do_sms)\n\t\t{\n\t\t    // 'smoothscroll': increase \"w_skipcol\" until it goes over\n\t\t    // the end of the line, then advance to the next line.\n\t\t    int add = curwin->w_skipcol > 0 ? width2 : width1;\n\t\t    curwin->w_skipcol += add;\n\t\t    if (curwin->w_skipcol >= size)\n\t\t    {\n\t\t\tif (lnum == curbuf->b_ml.ml_line_count)\n\t\t\t{\n\t\t\t    // at the last screen line, can't scroll further\n\t\t\t    curwin->w_skipcol -= add;\n\t\t\t    break;\n\t\t\t}\n\t\t\t++lnum;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tbreak;\n\t\t    ++lnum;\n\t\t}\n\n\t\tif (lnum > curwin->w_topline)\n\t\t{\n\t\t    // approximate w_botline\n\t\t    curwin->w_botline += lnum - curwin->w_topline;\n\t\t    curwin->w_topline = lnum;\n# ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = diff_check_fill(curwin, lnum);\n# endif\n\t\t    curwin->w_skipcol = 0;\n\t\t    if (todo > 1 && do_sms)\n\t\t\tsize = linetabsize(curwin, curwin->w_topline);\n\t\t}\n\t    }\n\t}\n\n\tif (curwin->w_topline == prev_topline)\n\t    // need to redraw even though w_topline didn't change\n\t    redraw_later(UPD_NOT_VALID);\n    }\n    else\n    {\n\tcurwin->w_topline += line_count;\n\tcurwin->w_botline += line_count;\t// approximate w_botline\n    }\n\n    if (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n    if (curwin->w_botline > curbuf->b_ml.ml_line_count + 1)\n\tcurwin->w_botline = curbuf->b_ml.ml_line_count + 1;\n\n#ifdef FEAT_DIFF\n    check_topfill(curwin, FALSE);\n#endif\n\n#ifdef FEAT_FOLDING\n    if (hasAnyFolding(curwin))\n\t// Make sure w_topline is at the first of a sequence of folded lines.\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n    {\n\tcurwin->w_cursor.lnum = curwin->w_topline;\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tcoladvance(curwin->w_curswant);\n    }\n    if (curwin->w_cursor.lnum == curwin->w_topline\n\t\t\t\t\t    && do_sms && curwin->w_skipcol > 0)\n    {\n\tint\tcol_off = curwin_col_off();\n\tint\tcol_off2 = curwin_col_off2();\n\n\tint\twidth1 = curwin->w_width - col_off;\n\tint\twidth2 = width1 + col_off2;\n\tint\textra2 = col_off - col_off2;\n\tlong\tso = get_scrolloff_value();\n\tint\tscrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n\tint\tspace_cols = (curwin->w_height - 1) * width2;\n\n\t// If we have non-zero scrolloff, just ignore the <<< marker as we are\n\t// going past it anyway.\n\tint smoothscroll_overlap = scrolloff_cols != 0 ? 0 :\n\t\t\t\t\t   smoothscroll_marker_overlap(extra2);\n\n\t// Make sure the cursor is in a visible part of the line, taking\n\t// 'scrolloff' into account, but using screen lines.\n\t// If there are not enough screen lines put the cursor in the middle.\n\tif (scrolloff_cols > space_cols / 2)\n\t    scrolloff_cols = space_cols / 2;\n\tvalidate_virtcol();\n\tif (curwin->w_virtcol < curwin->w_skipcol\n\t\t\t\t       + smoothscroll_overlap + scrolloff_cols)\n\t{\n\t    colnr_T col = curwin->w_virtcol;\n\n\t    if (col < width1)\n\t\tcol += width1;\n\t    while (col < curwin->w_skipcol\n\t\t\t\t       + smoothscroll_overlap + scrolloff_cols)\n\t\tcol += width2;\n\t    curwin->w_curswant = col;\n\t    coladvance(curwin->w_curswant);\n\n\t    // validate_virtcol() marked various things as valid, but after\n\t    // moving the cursor they need to be recomputed\n\t    curwin->w_valid &=\n\t       ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\t}\n    }\n}\n\n/*\n * Called after changing the cursor column: make sure that curwin->w_skipcol is\n * valid for 'smoothscroll'.\n */\n    void\nadjust_skipcol(void)\n{\n    if (!curwin->w_p_wrap\n\t    || !curwin->w_p_sms\n\t    || curwin->w_cursor.lnum != curwin->w_topline)\n\treturn;\n\n    int\t    width1 = curwin->w_width - curwin_col_off();\n    if (width1 <= 0)\n\treturn;  // no text will be displayed\n\n    int\t    width2 = width1 + curwin_col_off2();\n    long    so = get_scrolloff_value();\n    int\t    scrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n    int\t    scrolled = FALSE;\n\n    validate_cheight();\n    if (curwin->w_cline_height == curwin->w_height\n\t    // w_cline_height may be capped at w_height, check there aren't\n\t    // actually more lines.\n\t    && plines_win(curwin, curwin->w_cursor.lnum, FALSE)\n\t\t\t\t\t\t\t   <= curwin->w_height)\n    {\n\t// the line just fits in the window, don't scroll\n\treset_skipcol();\n\treturn;\n    }\n\n    validate_virtcol();\n    while (curwin->w_skipcol > 0\n\t\t && curwin->w_virtcol < curwin->w_skipcol + 3 + scrolloff_cols)\n    {\n\t// scroll a screen line down\n\tif (curwin->w_skipcol >= width1 + width2)\n\t    curwin->w_skipcol -= width2;\n\telse\n\t    curwin->w_skipcol -= width1;\n\tredraw_later(UPD_NOT_VALID);\n\tscrolled = TRUE;\n\tvalidate_virtcol();\n    }\n    if (scrolled)\n\treturn;  // don't scroll in the other direction now\n\n    int col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;\n    int row = 0;\n    if (col >= width1)\n    {\n\tcol -= width1;\n\t++row;\n    }\n    if (col > width2)\n    {\n\trow += col / width2;\n\tcol = col % width2;\n    }\n    if (row >= curwin->w_height)\n    {\n\tif (curwin->w_skipcol == 0)\n\t{\n\t    curwin->w_skipcol += width1;\n\t    --row;\n\t}\n\tif (row >= curwin->w_height)\n\t    curwin->w_skipcol += (row - curwin->w_height) * width2;\n\tredraw_later(UPD_NOT_VALID);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Don't end up with too many filler lines in the window.\n */\n    void\ncheck_topfill(\n    win_T\t*wp,\n    int\t\tdown)\t// when TRUE scroll down when not enough space\n{\n    int\t\tn;\n\n    if (wp->w_topfill <= 0)\n\treturn;\n\n    n = plines_win_nofill(wp, wp->w_topline, TRUE);\n    if (wp->w_topfill + n > wp->w_height)\n    {\n\tif (down && wp->w_topline > 1)\n\t{\n\t    --wp->w_topline;\n\t    wp->w_topfill = 0;\n\t}\n\telse\n\t{\n\t    wp->w_topfill = wp->w_height - n;\n\t    if (wp->w_topfill < 0)\n\t\twp->w_topfill = 0;\n\t}\n    }\n}\n\n/*\n * Use as many filler lines as possible for w_topline.  Make sure w_topline\n * is still visible.\n */\n    static void\nmax_topfill(void)\n{\n    int\t\tn;\n\n    n = plines_nofill(curwin->w_topline);\n    if (n >= curwin->w_height)\n\tcurwin->w_topfill = 0;\n    else\n    {\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill + n > curwin->w_height)\n\t    curwin->w_topfill = curwin->w_height - n;\n    }\n}\n#endif\n\n/*\n * Scroll the screen one line down, but don't do it if it would move the\n * cursor off the screen.\n */\n    void\nscrolldown_clamp(void)\n{\n    int\t\tend_row;\n#ifdef FEAT_DIFF\n    int\t\tcan_fill = (curwin->w_topfill\n\t\t\t\t< diff_check_fill(curwin, curwin->w_topline));\n#endif\n\n    if (curwin->w_topline <= 1\n#ifdef FEAT_DIFF\n\t    && !can_fill\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go past 'scrolloff' lines from the screen end.\n     */\n    end_row = curwin->w_wrow;\n#ifdef FEAT_DIFF\n    if (can_fill)\n\t++end_row;\n    else\n\tend_row += plines_nofill(curwin->w_topline - 1);\n#else\n    end_row += plines(curwin->w_topline - 1);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_cheight();\n\tvalidate_virtcol();\n\tend_row += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    if (end_row < curwin->w_height - get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (can_fill)\n\t{\n\t    ++curwin->w_topfill;\n\t    check_topfill(curwin, TRUE);\n\t}\n\telse\n\t{\n\t    --curwin->w_topline;\n\t    curwin->w_topfill = 0;\n\t}\n#else\n\t--curwin->w_topline;\n#endif\n#ifdef FEAT_FOLDING\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t--curwin->w_botline;\t    // approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Scroll the screen one line up, but don't do it if it would move the cursor\n * off the screen.\n */\n    void\nscrollup_clamp(void)\n{\n    int\t    start_row;\n\n    if (curwin->w_topline == curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t    && curwin->w_topfill == 0\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the first row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go before 'scrolloff' lines from the screen start.\n     */\n#ifdef FEAT_DIFF\n    start_row = curwin->w_wrow - plines_nofill(curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#else\n    start_row = curwin->w_wrow - plines(curwin->w_topline);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tstart_row -= curwin->w_virtcol / curwin->w_width;\n    }\n    if (start_row >= get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill > 0)\n\t    --curwin->w_topfill;\n\telse\n#endif\n\t{\n#ifdef FEAT_FOLDING\n\t    (void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t    ++curwin->w_topline;\n\t}\n\t++curwin->w_botline;\t\t// approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Add one line above \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines above the first one are incredibly high: MAXCOL.\n */\n    static void\ntopline_back_winheight(\n    lineoff_T\t*lp,\n    int\t\twinheight)\t// when TRUE limit to window height\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t--lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum < 1)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, &lp->lnum, NULL))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_WIN_NOFILL(curwin, lp->lnum, winheight);\n    }\n}\n\n    static void\ntopline_back(lineoff_T *lp)\n{\n    topline_back_winheight(lp, TRUE);\n}\n\n\n/*\n * Add one line below \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines below the last one are incredibly high.\n */\n    static void\nbotline_forw(lineoff_T *lp)\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum + 1))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t++lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum > curbuf->b_ml.ml_line_count)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, NULL, &lp->lnum))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_NOFILL(lp->lnum);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Switch from including filler lines below lp->lnum to including filler\n * lines above loff.lnum + 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\nbotline_topline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\t++lp->lnum;\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n    }\n}\n\n/*\n * Switch from including filler lines above lp->lnum to including filler\n * lines below loff.lnum - 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\ntopline_botline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n\t--lp->lnum;\n    }\n}\n#endif\n\n/*\n * Recompute topline to put the cursor at the top of the window.\n * Scroll at least \"min_scroll\" lines.\n * If \"always\" is TRUE, always set topline (for \"zt\").\n */\n    void\nscroll_cursor_top(int min_scroll, int always)\n{\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\tused;\n    int\t\ti;\n    linenr_T\ttop;\t\t// just above displayed lines\n    linenr_T\tbot;\t\t// just below displayed lines\n    linenr_T\told_topline = curwin->w_topline;\n    int\t\told_skipcol = curwin->w_skipcol;\n#ifdef FEAT_DIFF\n    linenr_T\told_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tnew_topline;\n    int\t\toff = get_scrolloff_value();\n\n    if (mouse_dragging > 0)\n\toff = mouse_dragging - 1;\n\n    /*\n     * Decrease topline until:\n     * - it has become 1\n     * - (part of) the cursor line is moved off the screen or\n     * - moved at least 'scrolljump' lines and\n     * - at least 'scrolloff' lines above and below the cursor\n     */\n    validate_cheight();\n    used = curwin->w_cline_height; // includes filler lines above\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n\tscrolled = used;\n\n#ifdef FEAT_FOLDING\n    if (hasFolding(curwin->w_cursor.lnum, &top, &bot))\n    {\n\t--top;\n\t++bot;\n    }\n    else\n#endif\n    {\n\ttop = curwin->w_cursor.lnum - 1;\n\tbot = curwin->w_cursor.lnum + 1;\n    }\n    new_topline = top + 1;\n\n#ifdef FEAT_DIFF\n    // \"used\" already contains the number of filler lines above, don't add it\n    // again.\n    // Hide filler lines above cursor line by adding them to \"extra\".\n    extra += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    /*\n     * Check if the lines from \"top\" to \"bot\" fit in the window.  If they do,\n     * set new_topline and advance \"top\" and \"bot\" to include more lines.\n     */\n    while (top > 0)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(top, &top, NULL))\n\t    // count one logical line for a sequence of folded lines\n\t    i = 1;\n\telse\n#endif\n\t    i = PLINES_NOFILL(top);\n\tif (top < curwin->w_topline)\n\t    scrolled += i;\n\n\t// If scrolling is needed, scroll at least 'sj' lines.\n\tif ((new_topline >= curwin->w_topline || scrolled > min_scroll)\n\t\t&& extra >= off)\n\t    break;\n\n\tused += i;\n\tif (extra + i <= off && bot < curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(bot, NULL, &bot))\n\t\t// count one logical line for a sequence of folded lines\n\t\t++used;\n\t    else\n#endif\n\t\tused += plines(bot);\n\t}\n\tif (used > curwin->w_height)\n\t    break;\n\n\textra += i;\n\tnew_topline = top;\n\t--top;\n\t++bot;\n    }\n\n    /*\n     * If we don't have enough space, put cursor in the middle.\n     * This makes sure we get the same position when using \"k\" and \"j\"\n     * in a small window.\n     */\n    if (used > curwin->w_height)\n\tscroll_cursor_halfway(FALSE, FALSE);\n    else\n    {\n\t/*\n\t * If \"always\" is FALSE, only adjust topline to a lower value, higher\n\t * value may happen with wrapping lines.\n\t */\n\tif (new_topline < curwin->w_topline || always)\n\t    curwin->w_topline = new_topline;\n\tif (curwin->w_topline > curwin->w_cursor.lnum)\n\t    curwin->w_topline = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill > 0 && extra > off)\n\t{\n\t    curwin->w_topfill -= extra - off;\n\t    if (curwin->w_topfill < 0)\n\t\tcurwin->w_topfill = 0;\n\t}\n\tcheck_topfill(curwin, FALSE);\n#endif\n\t// TODO: if the line doesn't fit may optimize w_skipcol\n\tif (curwin->w_topline == curwin->w_cursor.lnum\n\t\t&& curwin->w_skipcol >= curwin->w_cursor.col)\n\t    reset_skipcol();\n\tif (curwin->w_topline != old_topline\n\t\t|| curwin->w_skipcol != old_skipcol\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t)\n\t    curwin->w_valid &=\n\t\t      ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\tcurwin->w_valid |= VALID_TOPLINE;\n    }\n}\n\n/*\n * Set w_empty_rows and w_filler_rows for window \"wp\", having used up \"used\"\n * screen lines for text lines.\n */\n    void\nset_empty_rows(win_T *wp, int used)\n{\n#ifdef FEAT_DIFF\n    wp->w_filler_rows = 0;\n#endif\n    if (used == 0)\n\twp->w_empty_rows = 0;\t// single line that doesn't fit\n    else\n    {\n\twp->w_empty_rows = wp->w_height - used;\n#ifdef FEAT_DIFF\n\tif (wp->w_botline <= wp->w_buffer->b_ml.ml_line_count)\n\t{\n\t    wp->w_filler_rows = diff_check_fill(wp, wp->w_botline);\n\t    if (wp->w_empty_rows > wp->w_filler_rows)\n\t\twp->w_empty_rows -= wp->w_filler_rows;\n\t    else\n\t    {\n\t\twp->w_filler_rows = wp->w_empty_rows;\n\t\twp->w_empty_rows = 0;\n\t    }\n\t}\n#endif\n    }\n}\n\n/*\n * Recompute topline to put the cursor at the bottom of the window.\n * When scrolling scroll at least \"min_scroll\" lines.\n * If \"set_topbot\" is TRUE, set topline and botline first (for \"zb\").\n * This is messy stuff!!!\n */\n    void\nscroll_cursor_bot(int min_scroll, int set_topbot)\n{\n    int\t\tused;\n    int\t\tscrolled = 0;\n    int\t\tmin_scrolled = 1;\n    int\t\textra = 0;\n    int\t\ti;\n    linenr_T\tline_count;\n    linenr_T\told_topline = curwin->w_topline;\n    int\t\told_skipcol = curwin->w_skipcol;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n    int\t\tfill_below_window;\n#endif\n    linenr_T\told_botline = curwin->w_botline;\n    linenr_T\told_valid = curwin->w_valid;\n    int\t\told_empty_rows = curwin->w_empty_rows;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    long\tso = get_scrolloff_value();\n\n    cln = curwin->w_cursor.lnum;\n    if (set_topbot)\n    {\n\tint set_skipcol = FALSE;\n\n\tused = 0;\n\tcurwin->w_botline = cln + 1;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tfor (curwin->w_topline = curwin->w_botline;\n\t\tcurwin->w_topline > 1;\n\t\tcurwin->w_topline = loff.lnum)\n\t{\n\t    loff.lnum = curwin->w_topline;\n\t    topline_back_winheight(&loff, FALSE);\n\t    if (loff.height == MAXCOL)\n\t\tbreak;\n\t    if (used + loff.height > curwin->w_height)\n\t    {\n\t\tif (curwin->w_p_sms && curwin->w_p_wrap)\n\t\t{\n\t\t    // 'smoothscroll' and 'wrap' are set.  The above line is\n\t\t    // too long to show in its entirety, so we show just a part\n\t\t    // of it.\n\t\t    if (used < curwin->w_height)\n\t\t    {\n\t\t\tint plines_offset = used + loff.height\n\t\t\t\t\t\t\t    - curwin->w_height;\n\t\t\tused = curwin->w_height;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = loff.fill;\n#endif\n\t\t\tcurwin->w_topline = loff.lnum;\n\t\t\tcurwin->w_skipcol = skipcol_from_plines(\n\t\t\t\t\t\t\tcurwin, plines_offset);\n\t\t\tset_skipcol = TRUE;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    }\n\t    used += loff.height;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = loff.fill;\n#endif\n\t}\n\tset_empty_rows(curwin, used);\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t|| set_skipcol\n\t\t|| curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    if (set_skipcol)\n\t\tredraw_later(UPD_NOT_VALID);\n\t    else\n\t\treset_skipcol();\n\t}\n    }\n    else\n\tvalidate_botline();\n\n    // The lines of the cursor line itself are always used.\n#ifdef FEAT_DIFF\n    used = plines_nofill(cln);\n#else\n    validate_cheight();\n    used = curwin->w_cline_height;\n#endif\n\n    // If the cursor is on or below botline, we will at least scroll by the\n    // height of the cursor line, which is \"used\".  Correct for empty lines,\n    // which are really part of botline.\n    if (cln >= curwin->w_botline)\n    {\n\tscrolled = used;\n\tif (cln == curwin->w_botline)\n\t    scrolled -= curwin->w_empty_rows;\n\tmin_scrolled = scrolled;\n\tif (curwin->w_p_sms && curwin->w_p_wrap)\n\t{\n\t    // 'smoothscroll' and 'wrap' are set\n\t    if (cln > curwin->w_botline)\n\t\t// add screen lines below w_botline\n\t\tfor (linenr_T lnum = curwin->w_botline + 1; lnum <= cln; ++lnum)\n\t\t    min_scrolled += PLINES_NOFILL(lnum);\n\n\t    // Calculate how many screen lines the current top line of window\n\t    // occupies. If it is occupying more than the entire window, we\n\t    // need to scroll the additional clipped lines to scroll past the\n\t    // top line before we can move on to the other lines.\n\t    int top_plines =\n#ifdef FEAT_DIFF\n\t\t\t    plines_win_nofill\n#else\n\t\t\t    plines_win\n#endif\n\t\t\t\t\t(curwin, curwin->w_topline, FALSE);\n\t    int skip_lines = 0;\n\t    int width1 = curwin->w_width - curwin_col_off();\n\t    int width2 = width1 + curwin_col_off2();\n\t    // similar formula is used in curs_columns()\n\t    if (curwin->w_skipcol > width1)\n\t\tskip_lines += (curwin->w_skipcol - width1) / width2 + 1;\n\t    else if (curwin->w_skipcol > 0)\n\t\tskip_lines = 1;\n\n\t    top_plines -= skip_lines;\n\t    if (top_plines > curwin->w_height)\n\t    {\n\t\tscrolled += (top_plines - curwin->w_height);\n\t\tmin_scrolled += (top_plines - curwin->w_height);\n\t    }\n\t}\n    }\n\n    /*\n     * Stop counting lines to scroll when\n     * - hitting start of the file\n     * - scrolled nothing or at least 'sj' lines\n     * - at least 'scrolloff' lines below the cursor\n     * - lines between botline and cursor have been counted\n     */\n#ifdef FEAT_FOLDING\n    if (!hasFolding(curwin->w_cursor.lnum, &loff.lnum, &boff.lnum))\n#endif\n    {\n\tloff.lnum = cln;\n\tboff.lnum = cln;\n    }\n#ifdef FEAT_DIFF\n    loff.fill = 0;\n    boff.fill = 0;\n    fill_below_window = diff_check_fill(curwin, curwin->w_botline)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\n    while (loff.lnum > 1)\n    {\n\t// Stop when scrolled nothing or at least \"min_scroll\", found \"extra\"\n\t// context for 'scrolloff' and counted all lines below the window.\n\tif ((((scrolled <= 0 || scrolled >= min_scroll)\n\t\t    && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so))\n\t\t    || boff.lnum + 1 > curbuf->b_ml.ml_line_count)\n\t\t&& loff.lnum <= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum < curwin->w_botline\n\t\t    || loff.fill >= fill_below_window)\n#endif\n\t\t)\n\t    break;\n\n\t// Add one line above\n\ttopline_back(&loff);\n\tif (loff.height == MAXCOL)\n\t    used = MAXCOL;\n\telse\n\t    used += loff.height;\n\tif (used > curwin->w_height)\n\t    break;\n\tif (loff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum > curwin->w_botline\n\t\t    || loff.fill <= fill_below_window)\n#endif\n\t\t)\n\t{\n\t    // Count screen lines that are below the window.\n\t    scrolled += loff.height;\n\t    if (loff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && loff.fill == 0\n#endif\n\t\t    )\n\t\tscrolled -= curwin->w_empty_rows;\n\t}\n\n\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    // Add one line below\n\t    botline_forw(&boff);\n\t    used += boff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    if (extra < ( mouse_dragging > 0 ? mouse_dragging - 1 : so)\n\t\t    || scrolled < min_scroll)\n\t    {\n\t\textra += boff.height;\n\t\tif (boff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t|| (boff.lnum + 1 == curwin->w_botline\n\t\t\t    && boff.fill > curwin->w_filler_rows)\n#endif\n\t\t   )\n\t\t{\n\t\t    // Count screen lines that are below the window.\n\t\t    scrolled += boff.height;\n\t\t    if (boff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && boff.fill == 0\n#endif\n\t\t\t    )\n\t\t\tscrolled -= curwin->w_empty_rows;\n\t\t}\n\t    }\n\t}\n    }\n\n    // curwin->w_empty_rows is larger, no need to scroll\n    if (scrolled <= 0)\n\tline_count = 0;\n    // more than a screenfull, don't scroll but redraw\n    else if (used > curwin->w_height)\n\tline_count = used;\n    // scroll minimal number of lines\n    else\n    {\n\tline_count = 0;\n#ifdef FEAT_DIFF\n\tboff.fill = curwin->w_topfill;\n#endif\n\tboff.lnum = curwin->w_topline - 1;\n\tfor (i = 0; i < scrolled && boff.lnum < curwin->w_botline; )\n\t{\n\t    botline_forw(&boff);\n\t    i += boff.height;\n\t    ++line_count;\n\t}\n\tif (i < scrolled)\t// below curwin->w_botline, don't scroll\n\t    line_count = 9999;\n    }\n\n    /*\n     * Scroll up if the cursor is off the bottom of the screen a bit.\n     * Otherwise put it at 1/2 of the screen.\n     */\n    if (line_count >= curwin->w_height && line_count > min_scroll)\n\tscroll_cursor_halfway(FALSE, TRUE);\n    else\n    {\n\t// With 'smoothscroll' scroll at least the height of the cursor line,\n\t// unless it would move the cursor.\n\tif (curwin->w_p_wrap && curwin->w_p_sms && line_count < min_scrolled\n\t\t&& (curwin->w_cursor.lnum < curwin->w_topline\n\t\t    || (curwin->w_virtcol - curwin->w_skipcol >=\n\t\t\t\t\t  curwin->w_width - curwin_col_off())))\n\t    line_count = min_scrolled;\n\tif (line_count > 0)\n\t{\n\t    if (scrolling_screenlines(TRUE))\n\t\tscrollup(scrolled, TRUE);  // TODO\n\t    else\n\t\tscrollup(line_count, TRUE);\n\t}\n    }\n\n    /*\n     * If topline didn't change we need to restore w_botline and w_empty_rows\n     * (we changed them).\n     * If topline did change, update_screen() will set botline.\n     */\n    if (curwin->w_topline == old_topline\n\t    && curwin->w_skipcol == old_skipcol\n\t    && set_topbot)\n    {\n\tcurwin->w_botline = old_botline;\n\tcurwin->w_empty_rows = old_empty_rows;\n\tcurwin->w_valid = old_valid;\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Recompute topline to put the cursor halfway the window\n * If \"atend\" is TRUE, also put it halfway at the end of the file.\n */\n    void\nscroll_cursor_halfway(int atend, int prefer_above)\n{\n    int\t\tabove = 0;\n    linenr_T\ttopline;\n    colnr_T\tskipcol = 0;\n    int\t\tset_skipcol = FALSE;\n#ifdef FEAT_DIFF\n    int\t\ttopfill = 0;\n#endif\n    int\t\tbelow = 0;\n    int\t\tused;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    linenr_T\told_topline = curwin->w_topline;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    // if the width changed this needs to be updated first\n    may_update_popup_position();\n#endif\n    loff.lnum = boff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n    (void)hasFolding(loff.lnum, &loff.lnum, &boff.lnum);\n#endif\n#ifdef FEAT_DIFF\n    used = plines_nofill(loff.lnum);\n    loff.fill = 0;\n    boff.fill = 0;\n#else\n    used = plines(loff.lnum);\n#endif\n    topline = loff.lnum;\n\n    int half_height = 0;\n    int smooth_scroll = FALSE;\n    if (curwin->w_p_sms && curwin->w_p_wrap)\n    {\n\t// 'smoothscroll' and 'wrap' are set\n\tsmooth_scroll = TRUE;\n\thalf_height = (curwin->w_height - used) / 2;\n\tused = 0;\n    }\n\n    while (topline > 1)\n    {\n\t// If using smoothscroll, we can precisely scroll to the\n\t// exact point where the cursor is halfway down the screen.\n\tif (smooth_scroll)\n\t{\n\t    topline_back_winheight(&loff, FALSE);\n\t    if (loff.height == MAXCOL)\n\t\tbreak;\n\t    else\n\t\tused += loff.height;\n\t    if (used > half_height)\n\t    {\n\t\tif (used - loff.height < half_height)\n\t\t{\n\t\t    int plines_offset = used - half_height;\n\t\t    loff.height -= plines_offset;\n\t\t    used = half_height;\n\n\t\t    topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\t    topfill = loff.fill;\n#endif\n\t\t    skipcol = skipcol_from_plines(curwin, plines_offset);\n\t\t    set_skipcol = TRUE;\n\t\t}\n\t\tbreak;\n\t    }\n\t    topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t    topfill = loff.fill;\n#endif\n\t    continue;\n\t}\n\n\t// If not using smoothscroll, we have to iteratively find how many\n\t// lines to scroll down to roughly fit the cursor.\n\t// This may not be right in the middle if the lines'\n\t// physical height > 1 (e.g. 'wrap' is on).\n\n\t// Depending on \"prefer_above\" we add a line above or below first.\n\t// Loop twice to avoid duplicating code.\n\tint done = FALSE;\n\tfor (int round = 1; round <= 2; ++round)\n\t{\n\t    if (prefer_above ? (round == 2 && below < above)\n\t\t\t     : (round == 1 && below <= above))\n\t    {\n\t\t// add a line below the cursor\n\t\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    botline_forw(&boff);\n\t\t    used += boff.height;\n\t\t    if (used > curwin->w_height)\n\t\t    {\n\t\t\tdone = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t    below += boff.height;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++below;\t    // count a \"~\" line\n\t\t    if (atend)\n\t\t\t++used;\n\t\t}\n\t    }\n\n\t    if (prefer_above ? (round == 1 && below >= above)\n\t\t\t     : (round == 1 && below > above))\n\t    {\n\t\t// add a line above the cursor\n\t\ttopline_back(&loff);\n\t\tif (loff.height == MAXCOL)\n\t\t    used = MAXCOL;\n\t\telse\n\t\t    used += loff.height;\n\t\tif (used > curwin->w_height)\n\t\t{\n\t\t    done = TRUE;\n\t\t    break;\n\t\t}\n\t\tabove += loff.height;\n\t\ttopline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\ttopfill = loff.fill;\n#endif\n\t    }\n\t}\n\tif (done)\n\t    break;\n    }\n\n#ifdef FEAT_FOLDING\n    if (!hasFolding(topline, &curwin->w_topline, NULL))\n#endif\n    {\n\tif (curwin->w_topline != topline\n\t\t|| set_skipcol\n\t\t|| curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_topline = topline;\n\t    if (set_skipcol)\n\t    {\n\t\tcurwin->w_skipcol = skipcol;\n\t\tredraw_later(UPD_NOT_VALID);\n\t    }\n\t    else\n\t\treset_skipcol();\n\t}\n    }\n#ifdef FEAT_DIFF\n    curwin->w_topfill = topfill;\n    if (old_topline > curwin->w_topline + curwin->w_height)\n\tcurwin->w_botfill = FALSE;\n    check_topfill(curwin, FALSE);\n#endif\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Correct the cursor position so that it is in a part of the screen at least\n * 'scrolloff' lines from the top and bottom, if possible.\n * If not possible, put it at the same position as scroll_cursor_halfway().\n * When called topline must be valid!\n */\n    void\ncursor_correct(void)\n{\n    int\t\tabove = 0;\t    // screen lines above topline\n    linenr_T\ttopline;\n    int\t\tbelow = 0;\t    // screen lines below botline\n    linenr_T\tbotline;\n    int\t\tabove_wanted, below_wanted;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    int\t\tmax_off;\n    long\tso = get_scrolloff_value();\n\n    /*\n     * How many lines we would like to have above/below the cursor depends on\n     * whether the first/last line of the file is on screen.\n     */\n    above_wanted = so;\n    below_wanted = so;\n    if (mouse_dragging > 0)\n    {\n\tabove_wanted = mouse_dragging - 1;\n\tbelow_wanted = mouse_dragging - 1;\n    }\n    if (curwin->w_topline == 1)\n    {\n\tabove_wanted = 0;\n\tmax_off = curwin->w_height / 2;\n\tif (below_wanted > max_off)\n\t    below_wanted = max_off;\n    }\n    validate_botline();\n    if (curwin->w_botline == curbuf->b_ml.ml_line_count + 1\n\t    && mouse_dragging == 0)\n    {\n\tbelow_wanted = 0;\n\tmax_off = (curwin->w_height - 1) / 2;\n\tif (above_wanted > max_off)\n\t    above_wanted = max_off;\n    }\n\n    /*\n     * If there are sufficient file-lines above and below the cursor, we can\n     * return now.\n     */\n    cln = curwin->w_cursor.lnum;\n    if (cln >= curwin->w_topline + above_wanted\n\t    && cln < curwin->w_botline - below_wanted\n#ifdef FEAT_FOLDING\n\t    && !hasAnyFolding(curwin)\n#endif\n\t    )\n\treturn;\n\n    if (curwin->w_p_sms && !curwin->w_p_wrap)\n    {\n\t// 'smoothscroll is active\n\tif (curwin->w_cline_height == curwin->w_height)\n\t{\n\t    // The cursor line just fits in the window, don't scroll.\n\t    reset_skipcol();\n\t    return;\n\t}\n\t// TODO: If the cursor line doesn't fit in the window then only adjust\n\t// w_skipcol.\n    }\n\n    /*\n     * Narrow down the area where the cursor can be put by taking lines from\n     * the top and the bottom until:\n     * - the desired context lines are found\n     * - the lines from the top is past the lines from the bottom\n     */\n    topline = curwin->w_topline;\n    botline = curwin->w_botline - 1;\n#ifdef FEAT_DIFF\n    // count filler lines as context\n    above = curwin->w_topfill;\n    below = curwin->w_filler_rows;\n#endif\n    while ((above < above_wanted || below < below_wanted) && topline < botline)\n    {\n\tif (below < below_wanted && (below <= above || above >= above_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(botline, &botline, NULL))\n\t\t++below;\n\t    else\n#endif\n\t\tbelow += plines(botline);\n\t    --botline;\n\t}\n\tif (above < above_wanted && (above < below || below >= below_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(topline, NULL, &topline))\n\t\t++above;\n\t    else\n#endif\n\t\tabove += PLINES_NOFILL(topline);\n#ifdef FEAT_DIFF\n\t    // Count filler lines below this line as context.\n\t    if (topline < botline)\n\t\tabove += diff_check_fill(curwin, topline + 1);\n#endif\n\t    ++topline;\n\t}\n    }\n    if (topline == botline || botline == 0)\n\tcurwin->w_cursor.lnum = topline;\n    else if (topline > botline)\n\tcurwin->w_cursor.lnum = botline;\n    else\n    {\n\tif (cln < topline && curwin->w_topline > 1)\n\t{\n\t    curwin->w_cursor.lnum = topline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n\tif (cln > botline && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_cursor.lnum = botline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\nstatic void get_scroll_overlap(lineoff_T *lp, int dir);\n\n/*\n * Move screen \"count\" pages up (\"dir\" is BACKWARD) or down (\"dir\" is FORWARD)\n * and update the screen.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\nonepage(int dir, long count)\n{\n    long\tn;\n    int\t\tretval = OK;\n    lineoff_T\tloff;\n    linenr_T\told_topline = curwin->w_topline;\n    long\tso = get_scrolloff_value();\n\n    if (curbuf->b_ml.ml_line_count == 1)    // nothing to do\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n\n    for ( ; count > 0; --count)\n    {\n\tvalidate_botline();\n\t/*\n\t * It's an error to move a page up when the first line is already on\n\t * the screen.\tIt's an error to move a page down when the last line\n\t * is on the screen and the topline is 'scrolloff' lines from the\n\t * last line.\n\t */\n\tif (dir == FORWARD\n\t\t? ((curwin->w_topline >= curbuf->b_ml.ml_line_count - so)\n\t\t    && curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t: (curwin->w_topline == 1\n#ifdef FEAT_DIFF\n\t\t    && curwin->w_topfill ==\n\t\t\t\t    diff_check_fill(curwin, curwin->w_topline)\n#endif\n\t\t    ))\n\t{\n\t    beep_flush();\n\t    retval = FAIL;\n\t    break;\n\t}\n\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tif (dir == FORWARD)\n\t{\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling\n\t\tif (p_window <= 2)\n\t\t    ++curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline += p_window - 2;\n\t\tif (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t    }\n\t    else if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// at end of file\n\t\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    }\n\t    else\n\t    {\n\t\t// For the overlap, start with the line just below the window\n\t\t// and go upwards.\n\t\tloff.lnum = curwin->w_botline;\n#ifdef FEAT_DIFF\n\t\tloff.fill = diff_check_fill(curwin, loff.lnum)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\t\tget_scroll_overlap(&loff, -1);\n\t\tcurwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = loff.fill;\n\t\tcheck_topfill(curwin, FALSE);\n#endif\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t\tcurwin->w_valid &= ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|\n\t\t\t\t   VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    }\n\t}\n\telse\t// dir == BACKWARDS\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topline == 1)\n\t    {\n\t\t// Include max number of filler lines\n\t\tmax_topfill();\n\t\tcontinue;\n\t    }\n#endif\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling (sort of)\n\t\tif (p_window <= 2)\n\t\t    --curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline -= p_window - 2;\n\t\tif (curwin->w_topline < 1)\n\t\t    curwin->w_topline = 1;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline + p_window - 1;\n\t\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcontinue;\n\t    }\n\n\t    // Find the line at the top of the window that is going to be the\n\t    // line at the bottom of the window.  Make sure this results in\n\t    // the same line as before doing CTRL-F.\n\t    loff.lnum = curwin->w_topline - 1;\n#ifdef FEAT_DIFF\n\t    loff.fill = diff_check_fill(curwin, loff.lnum + 1)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    get_scroll_overlap(&loff, 1);\n\n\t    if (loff.lnum >= curbuf->b_ml.ml_line_count)\n\t    {\n\t\tloff.lnum = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t    }\n\t    else\n\t    {\n\t\tbotline_topline(&loff);\n#endif\n\t    }\n\t    curwin->w_cursor.lnum = loff.lnum;\n\n\t    // Find the line just above the new topline to get the right line\n\t    // at the bottom of the window.\n\t    n = 0;\n\t    while (n <= curwin->w_height && loff.lnum >= 1)\n\t    {\n\t\ttopline_back(&loff);\n\t\tif (loff.height == MAXCOL)\n\t\t    n = MAXCOL;\n\t\telse\n\t\t    n += loff.height;\n\t    }\n\t    if (loff.lnum < 1)\t\t\t// at begin of file\n\t    {\n\t\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\t\tmax_topfill();\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t    }\n\t    else\n\t    {\n\t\t// Go two lines forward again.\n#ifdef FEAT_DIFF\n\t\ttopline_botline(&loff);\n#endif\n\t\tbotline_forw(&loff);\n\t\tbotline_forw(&loff);\n#ifdef FEAT_DIFF\n\t\tbotline_topline(&loff);\n#endif\n#ifdef FEAT_FOLDING\n\t\t// We're at the wrong end of a fold now.\n\t\t(void)hasFolding(loff.lnum, &loff.lnum, NULL);\n#endif\n\n\t\t// Always scroll at least one line.  Avoid getting stuck on\n\t\t// very long lines.\n\t\tif (loff.lnum >= curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum > curwin->w_topline\n\t\t\t    || loff.fill >= curwin->w_topfill)\n#endif\n\t\t\t)\n\t\t{\n#ifdef FEAT_DIFF\n\t\t    // First try using the maximum number of filler lines.  If\n\t\t    // that's not enough, backup one line.\n\t\t    loff.fill = curwin->w_topfill;\n\t\t    if (curwin->w_topfill < diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t\t\tmax_topfill();\n\t\t    if (curwin->w_topfill == loff.fill)\n#endif\n\t\t    {\n\t\t\t--curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = 0;\n#endif\n\t\t    }\n\t\t    comp_botline(curwin);\n\t\t    curwin->w_cursor.lnum = curwin->w_botline - 1;\n\t\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|VALID_CROW);\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = loff.fill;\n\t\t    check_topfill(curwin, FALSE);\n#endif\n\t\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t\t}\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    foldAdjustCursor();\n#endif\n    cursor_correct();\n    check_cursor_col();\n    if (retval == OK)\n\tbeginline(BL_SOL | BL_FIX);\n    curwin->w_valid &= ~(VALID_WCOL|VALID_WROW|VALID_VIRTCOL);\n\n    if (retval == OK && dir == FORWARD)\n    {\n\t// Avoid the screen jumping up and down when 'scrolloff' is non-zero.\n\t// But make sure we scroll at least one line (happens with mix of long\n\t// wrapping lines and non-wrapping line).\n\tif (check_top_offset())\n\t{\n\t    scroll_cursor_top(1, FALSE);\n\t    if (curwin->w_topline <= old_topline\n\t\t\t\t  && old_topline < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_topline = old_topline + 1;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    }\n\t}\n#ifdef FEAT_FOLDING\n\telse if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    }\n\n    redraw_later(UPD_VALID);\n    return retval;\n}\n\n/*\n * Decide how much overlap to use for page-up or page-down scrolling.\n * This is symmetric, so that doing both keeps the same lines displayed.\n * Three lines are examined:\n *\n *  before CTRL-F\t    after CTRL-F / before CTRL-B\n *     etc.\t\t\tl1\n *  l1 last but one line\t------------\n *  l2 last text line\t\tl2 top text line\n *  -------------\t\tl3 second text line\n *  l3\t\t\t\t   etc.\n */\n    static void\nget_scroll_overlap(lineoff_T *lp, int dir)\n{\n    int\t\th1, h2, h3, h4;\n    int\t\tmin_height = curwin->w_height - 2;\n    lineoff_T\tloff0, loff1, loff2;\n\n#ifdef FEAT_DIFF\n    if (lp->fill > 0)\n\tlp->height = 1;\n    else\n\tlp->height = plines_nofill(lp->lnum);\n#else\n    lp->height = plines(lp->lnum);\n#endif\n    h1 = lp->height;\n    if (h1 > min_height)\n\treturn;\t\t// no overlap\n\n    loff0 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h2 = lp->height;\n    if (h2 == MAXCOL || h2 + h1 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff1 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h3 = lp->height;\n    if (h3 == MAXCOL || h3 + h2 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff2 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h4 = lp->height;\n    if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)\n\t*lp = loff1;\t// 1 line overlap\n    else\n\t*lp = loff2;\t// 2 lines overlap\n}\n\n/*\n * Scroll 'scroll' lines up or down.\n */\n    void\nhalfpage(int flag, linenr_T Prenum)\n{\n    long\tscrolled = 0;\n    int\t\ti;\n    int\t\tn;\n    int\t\troom;\n\n    if (Prenum)\n\tcurwin->w_p_scr = (Prenum > curwin->w_height) ?\n\t\t\t\t\t\tcurwin->w_height : Prenum;\n    n = (curwin->w_p_scr <= curwin->w_height) ?\n\t\t\t\t    curwin->w_p_scr : curwin->w_height;\n\n    update_topline();\n    validate_botline();\n    room = curwin->w_empty_rows;\n#ifdef FEAT_DIFF\n    room += curwin->w_filler_rows;\n#endif\n    if (flag)\n    {\n\t/*\n\t * scroll the text up\n\t */\n\twhile (n > 0 && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t--curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t\t++curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n#endif\n\n\t\tif (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_valid &=\n\t\t\t\t    ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t\t}\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW);\n\t    scrolled += i;\n\n\t    /*\n\t     * Correct w_botline for changed w_topline.\n\t     * Won't work when there are filler lines.\n\t     */\n#ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    else\n#endif\n\t    {\n\t\troom += i;\n\t\tdo\n\t\t{\n\t\t    i = plines(curwin->w_botline);\n\t\t    if (i > room)\n\t\t\tbreak;\n#ifdef FEAT_FOLDING\n\t\t    (void)hasFolding(curwin->w_botline, NULL,\n\t\t\t\t\t\t\t  &curwin->w_botline);\n#endif\n\t\t    ++curwin->w_botline;\n\t\t    room -= i;\n\t\t} while (curwin->w_botline <= curbuf->b_ml.ml_line_count);\n\t    }\n\t}\n\n\t/*\n\t * When hit bottom of the file: move cursor down.\n\t */\n\tif (n > 0)\n\t{\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n\t\t    ++curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum += n;\n\t    check_cursor_lnum();\n\t}\n    }\n    else\n    {\n\t/*\n\t * scroll the text down\n\t */\n\twhile (n > 0 && curwin->w_topline > 1)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill < diff_check_fill(curwin, curwin->w_topline))\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t++curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline - 1);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n\t\t--curwin->w_topline;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW|\n\t\t\t\t\t      VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    scrolled += i;\n\t    if (curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--curwin->w_cursor.lnum;\n\t\tcurwin->w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t    }\n\t}\n\n\t/*\n\t * When hit top of the file: move cursor up.\n\t */\n\tif (n > 0)\n\t{\n\t    if (curwin->w_cursor.lnum <= (linenr_T)n)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0 && curwin->w_cursor.lnum > 1)\n\t\t{\n\t\t    --curwin->w_cursor.lnum;\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum -= n;\n\t}\n    }\n# ifdef FEAT_FOLDING\n    // Move cursor to first line of closed fold.\n    foldAdjustCursor();\n# endif\n#ifdef FEAT_DIFF\n    check_topfill(curwin, !flag);\n#endif\n    cursor_correct();\n    beginline(BL_SOL | BL_FIX);\n    redraw_later(UPD_VALID);\n}\n\n    void\ndo_check_cursorbind(void)\n{\n    linenr_T\tline = curwin->w_cursor.lnum;\n    colnr_T\tcol = curwin->w_cursor.col;\n    colnr_T\tcoladd = curwin->w_cursor.coladd;\n    colnr_T\tcurswant = curwin->w_curswant;\n    int\t\tset_curswant = curwin->w_set_curswant;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\trestart_edit_save;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n\n    /*\n     * loop through the cursorbound windows\n     */\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window  and windows with 'noscrollbind'\n\tif (curwin != old_curwin && curwin->w_p_crb)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_cursor.lnum =\n\t\t\t\t diff_get_corresponding_line(old_curbuf, line);\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum = line;\n\t    curwin->w_cursor.col = col;\n\t    curwin->w_cursor.coladd = coladd;\n\t    curwin->w_curswant = curswant;\n\t    curwin->w_set_curswant = set_curswant;\n\n\t    // Make sure the cursor is in a valid position.  Temporarily set\n\t    // \"restart_edit\" to allow the cursor to be beyond the EOL.\n\t    restart_edit_save = restart_edit;\n\t    restart_edit = TRUE;\n\t    check_cursor();\n\n\t    // Avoid a scroll here for the cursor position, 'scrollbind' is\n\t    // more important.\n\t    if (!curwin->w_p_scb)\n\t\tvalidate_cursor();\n\n\t    restart_edit = restart_edit_save;\n\t    // Correct cursor for multi-byte character.\n\t    if (has_mbyte)\n\t\tmb_adjust_cursor();\n\t    redraw_later(UPD_VALID);\n\n\t    // Only scroll when 'scrollbind' hasn't done this.\n\t    if (!curwin->w_p_scb)\n\t\tupdate_topline();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n\n    /*\n     * reset current-window\n     */\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n", "\" Tests for window cmd (:wincmd, :split, :vsplit, :resize and etc...)\n\nsource check.vim\nsource screendump.vim\n\nfunc Test_window_cmd_ls0_with_split()\n  set ls=0\n  set splitbelow\n  split\n  quit\n  call assert_equal(0, &lines - &cmdheight - winheight(0))\n  new | only!\n  \"\n  set splitbelow&vim\n  botright split\n  quit\n  call assert_equal(0, &lines - &cmdheight - winheight(0))\n  new | only!\n  set ls&vim\nendfunc\n\nfunc Test_window_cmd_cmdwin_with_vsp()\n  let efmt = 'Expected 0 but got %d (in ls=%d, %s window)'\n  for v in range(0, 2)\n    exec \"set ls=\" . v\n    vsplit\n    call feedkeys(\"q:\\<CR>\")\n    let ac = &lines - (&cmdheight + winheight(0) + !!v)\n    let emsg = printf(efmt, ac, v, 'left')\n    call assert_equal(0, ac, emsg)\n    wincmd w\n    let ac = &lines - (&cmdheight + winheight(0) + !!v)\n    let emsg = printf(efmt, ac, v, 'right')\n    call assert_equal(0, ac, emsg)\n    new | only!\n  endfor\n  set ls&vim\nendfunc\n\nfunc Test_cmdheight_not_changed()\n  set cmdheight=2\n  set winminheight=0\n  augroup Maximize\n    autocmd WinEnter * wincmd _\n  augroup END\n  split\n  tabnew\n  tabfirst\n  call assert_equal(2, &cmdheight)\n\n  tabonly!\n  only\n  set winminwidth& cmdheight&\n  augroup Maximize\n    au!\n  augroup END\n  augroup! Maximize\nendfunc\n\n\" Test for jumping to windows\nfunc Test_window_jump()\n  new\n  \" jumping to a window with a count greater than the max windows\n  exe \"normal 4\\<C-W>w\"\n  call assert_equal(2, winnr())\n  only\nendfunc\n\nfunc Test_window_cmd_wincmd_gf()\n  let fname = 'test_gf.txt'\n  let swp_fname = '.' . fname . '.swp'\n  call writefile([], fname, 'D')\n  call writefile([], swp_fname, 'D')\n  function s:swap_exists()\n    let v:swapchoice = s:swap_choice\n  endfunc\n  \" Remove the catch-all that runtest.vim adds\n  au! SwapExists\n  augroup test_window_cmd_wincmd_gf\n    autocmd!\n    exec \"autocmd SwapExists \" . fname . \" call s:swap_exists()\"\n  augroup END\n\n  call setline(1, fname)\n  \" (E)dit anyway\n  let s:swap_choice = 'e'\n  wincmd gf\n  call assert_equal(2, tabpagenr())\n  call assert_equal(fname, bufname(\"%\"))\n  quit!\n\n  \" (Q)uit\n  let s:swap_choice = 'q'\n  wincmd gf\n  call assert_equal(1, tabpagenr())\n  call assert_notequal(fname, bufname(\"%\"))\n  new | only!\n\n  augroup! test_window_cmd_wincmd_gf\nendfunc\n\nfunc Test_window_quit()\n  e Xa\n  split Xb\n  call assert_equal(2, '$'->winnr())\n  call assert_equal('Xb', bufname(winbufnr(1)))\n  call assert_equal('Xa', bufname(winbufnr(2)))\n\n  wincmd q\n  call assert_equal(1, winnr('$'))\n  call assert_equal('Xa', bufname(winbufnr(1)))\n\n  bw Xa Xb\nendfunc\n\nfunc Test_window_horizontal_split()\n  call assert_equal(1, winnr('$'))\n  3wincmd s\n  call assert_equal(2, winnr('$'))\n  call assert_equal(3, winheight(0))\n  call assert_equal(winwidth(1), 2->winwidth())\n\n  call assert_fails('botright topleft wincmd s', 'E442:')\n  bw\nendfunc\n\nfunc Test_window_vertical_split()\n  call assert_equal(1, winnr('$'))\n  3wincmd v\n  call assert_equal(2, winnr('$'))\n  call assert_equal(3, winwidth(0))\n  call assert_equal(winheight(1), winheight(2))\n\n  call assert_fails('botright topleft wincmd v', 'E442:')\n  bw\nendfunc\n\n\" Test the \":wincmd ^\" and \"<C-W>^\" commands.\nfunc Test_window_split_edit_alternate()\n  \" Test for failure when the alternate buffer/file no longer exists.\n  edit Xfoo | %bw\n  call assert_fails(':wincmd ^', 'E23:')\n\n  \" Test for the expected behavior when we have two named buffers.\n  edit Xfoo | edit Xbar\n  wincmd ^\n  call assert_equal('Xfoo', bufname(winbufnr(1)))\n  call assert_equal('Xbar', bufname(winbufnr(2)))\n  only\n\n  \" Test for the expected behavior when the alternate buffer is not named.\n  enew | let l:nr1 = bufnr('%')\n  edit Xfoo | let l:nr2 = bufnr('%')\n  wincmd ^\n  call assert_equal(l:nr1, winbufnr(1))\n  call assert_equal(l:nr2, winbufnr(2))\n  only\n\n  \" FIXME: this currently fails on AppVeyor, but passes locally\n  if !has('win32')\n    \" Test the Normal mode command.\n    call feedkeys(\"\\<C-W>\\<C-^>\", 'tx')\n    call assert_equal(l:nr2, winbufnr(1))\n    call assert_equal(l:nr1, winbufnr(2))\n  endif\n\n  %bw!\nendfunc\n\n\" Test the \":[count]wincmd ^\" and \"[count]<C-W>^\" commands.\nfunc Test_window_split_edit_bufnr()\n  %bwipeout\n  let l:nr = bufnr('%') + 1\n  call assert_fails(':execute \"normal! ' . l:nr . '\\<C-W>\\<C-^>\"', 'E92:')\n  call assert_fails(':' . l:nr . 'wincmd ^', 'E16:')\n  call assert_fails(':0wincmd ^', 'E16:')\n\n  edit Xfoo | edit Xbar | edit Xbaz\n  let l:foo_nr = bufnr('Xfoo')\n  let l:bar_nr = bufnr('Xbar')\n  let l:baz_nr = bufnr('Xbaz')\n\n  \" FIXME: this currently fails on AppVeyor, but passes locally\n  if !has('win32')\n    call feedkeys(l:foo_nr . \"\\<C-W>\\<C-^>\", 'tx')\n    call assert_equal('Xfoo', bufname(winbufnr(1)))\n    call assert_equal('Xbaz', bufname(winbufnr(2)))\n    only\n\n    call feedkeys(l:bar_nr . \"\\<C-W>\\<C-^>\", 'tx')\n    call assert_equal('Xbar', bufname(winbufnr(1)))\n    call assert_equal('Xfoo', bufname(winbufnr(2)))\n    only\n\n    execute l:baz_nr . 'wincmd ^'\n    call assert_equal('Xbaz', bufname(winbufnr(1)))\n    call assert_equal('Xbar', bufname(winbufnr(2)))\n  endif\n\n  %bw!\nendfunc\n\nfunc Test_window_split_no_room()\n  \" N horizontal windows need >= 2*N + 1 lines:\n  \" - 1 line + 1 status line in each window\n  \" - 1 Ex command line\n  \"\n  \" 2*N + 1 <= &lines\n  \" N <= (lines - 1)/2\n  \"\n  \" Beyond that number of windows, E36: Not enough room is expected.\n  let hor_win_count = (&lines - 1)/2\n  let hor_split_count = hor_win_count - 1\n  for s in range(1, hor_split_count) | split | endfor\n  call assert_fails('split', 'E36:')\n\n  \" N vertical windows need >= 2*(N - 1) + 1 columns:\n  \" - 1 column + 1 separator for each window (except last window)\n  \" - 1 column for the last window which does not have separator\n  \"\n  \" 2*(N - 1) + 1 <= &columns\n  \" 2*N - 1 <= &columns\n  \" N <= (&columns + 1)/2\n  let ver_win_count = (&columns + 1)/2\n  let ver_split_count = ver_win_count - 1\n  for s in range(1, ver_split_count) | vsplit | endfor\n  call assert_fails('vsplit', 'E36:')\n\n  %bw!\nendfunc\n\nfunc Test_window_exchange()\n  e Xa\n\n  \" Nothing happens with window exchange when there is 1 window\n  wincmd x\n  call assert_equal(1, winnr('$'))\n\n  split Xb\n  split Xc\n\n  call assert_equal('Xc', bufname(winbufnr(1)))\n  call assert_equal('Xb', bufname(winbufnr(2)))\n  call assert_equal('Xa', bufname(winbufnr(3)))\n\n  \" Exchange current window 1 with window 3\n  3wincmd x\n  call assert_equal('Xa', bufname(winbufnr(1)))\n  call assert_equal('Xb', bufname(winbufnr(2)))\n  call assert_equal('Xc', bufname(winbufnr(3)))\n\n  \" Exchange window with next when at the top window\n  wincmd x\n  call assert_equal('Xb', bufname(winbufnr(1)))\n  call assert_equal('Xa', bufname(winbufnr(2)))\n  call assert_equal('Xc', bufname(winbufnr(3)))\n\n  \" Exchange window with next when at the middle window\n  wincmd j\n  wincmd x\n  call assert_equal('Xb', bufname(winbufnr(1)))\n  call assert_equal('Xc', bufname(winbufnr(2)))\n  call assert_equal('Xa', bufname(winbufnr(3)))\n\n  \" Exchange window with next when at the bottom window.\n  \" When there is no next window, it exchanges with the previous window.\n  wincmd j\n  wincmd x\n  call assert_equal('Xb', bufname(winbufnr(1)))\n  call assert_equal('Xa', bufname(winbufnr(2)))\n  call assert_equal('Xc', bufname(winbufnr(3)))\n\n  bw Xa Xb Xc\nendfunc\n\nfunc Test_window_rotate()\n  e Xa\n  split Xb\n  split Xc\n  call assert_equal('Xc', bufname(winbufnr(1)))\n  call assert_equal('Xb', bufname(winbufnr(2)))\n  call assert_equal('Xa', bufname(winbufnr(3)))\n\n  \" Rotate downwards\n  wincmd r\n  call assert_equal('Xa', bufname(winbufnr(1)))\n  call assert_equal('Xc', bufname(winbufnr(2)))\n  call assert_equal('Xb', bufname(winbufnr(3)))\n\n  2wincmd r\n  call assert_equal('Xc', bufname(winbufnr(1)))\n  call assert_equal('Xb', bufname(winbufnr(2)))\n  call assert_equal('Xa', bufname(winbufnr(3)))\n\n  \" Rotate upwards\n  wincmd R\n  call assert_equal('Xb', bufname(winbufnr(1)))\n  call assert_equal('Xa', bufname(winbufnr(2)))\n  call assert_equal('Xc', bufname(winbufnr(3)))\n\n  2wincmd R\n  call assert_equal('Xc', bufname(winbufnr(1)))\n  call assert_equal('Xb', bufname(winbufnr(2)))\n  call assert_equal('Xa', bufname(winbufnr(3)))\n\n  bot vsplit\n  call assert_fails('wincmd R', 'E443:')\n\n  bw Xa Xb Xc\nendfunc\n\nfunc Test_window_height()\n  e Xa\n  split Xb\n\n  let [wh1, wh2] = [winheight(1), winheight(2)]\n  \" Active window (1) should have the same height or 1 more\n  \" than the other window.\n  call assert_inrange(wh2, wh2 + 1, wh1)\n\n  wincmd -\n  call assert_equal(wh1 - 1, winheight(1))\n  call assert_equal(wh2 + 1, winheight(2))\n\n  wincmd +\n  call assert_equal(wh1, winheight(1))\n  call assert_equal(wh2, 2->winheight())\n\n  2wincmd _\n  call assert_equal(2, winheight(1))\n  call assert_equal(wh1 + wh2 - 2, winheight(2))\n\n  wincmd =\n  call assert_equal(wh1, winheight(1))\n  call assert_equal(wh2, winheight(2))\n\n  2wincmd _\n  set winfixheight\n  split Xc\n  let [wh1, wh2, wh3] = [winheight(1), winheight(2), winheight(3)]\n  call assert_equal(2, winheight(2))\n  call assert_inrange(wh3, wh3 + 1, wh1)\n  3wincmd +\n  call assert_equal(2,       winheight(2))\n  call assert_equal(wh1 + 3, winheight(1))\n  call assert_equal(wh3 - 3, winheight(3))\n  wincmd =\n  call assert_equal(2,   winheight(2))\n  call assert_equal(wh1, winheight(1))\n  call assert_equal(wh3, winheight(3))\n\n  wincmd j\n  set winfixheight&\n\n  wincmd =\n  let [wh1, wh2, wh3] = [winheight(1), winheight(2), winheight(3)]\n  \" Current window (2) should have the same height or 1 more\n  \" than the other windows.\n  call assert_inrange(wh1, wh1 + 1, wh2)\n  call assert_inrange(wh3, wh3 + 1, wh2)\n\n  bw Xa Xb Xc\nendfunc\n\nfunc Test_wincmd_equal()\n  edit Xone\n  below split Xtwo\n  rightbelow vsplit Xthree\n  call assert_equal('Xone', bufname(winbufnr(1)))\n  call assert_equal('Xtwo', bufname(winbufnr(2)))\n  call assert_equal('Xthree', bufname(winbufnr(3)))\n\n  \" Xone and Xtwo should be about the same height\n  let [wh1, wh2] = [winheight(1), winheight(2)]\n  call assert_inrange(wh1 - 1, wh1 + 1, wh2)\n  \" Xtwo and Xthree should be about the same width\n  let [ww2, ww3] = [winwidth(2), winwidth(3)]\n  call assert_inrange(ww2 - 1, ww2 + 1, ww3)\n\n  1wincmd w\n  10wincmd _\n  2wincmd w\n  20wincmd |\n  call assert_equal(10, winheight(1))\n  call assert_equal(20, winwidth(2))\n\n  \" equalizing horizontally doesn't change the heights\n  hor wincmd =\n  call assert_equal(10, winheight(1))\n  let [ww2, ww3] = [winwidth(2), winwidth(3)]\n  call assert_inrange(ww2 - 1, ww2 + 1, ww3)\n\n  2wincmd w\n  20wincmd |\n  call assert_equal(20, winwidth(2))\n  \" equalizing vertically doesn't change the widths\n  vert wincmd =\n  call assert_equal(20, winwidth(2))\n  let [wh1, wh2] = [winheight(1), winheight(2)]\n  call assert_inrange(wh1 - 1, wh1 + 1, wh2)\n\n  bwipe Xone Xtwo Xthree\nendfunc\n\nfunc Test_window_width()\n  e Xa\n  vsplit Xb\n\n  let [ww1, ww2] = [winwidth(1), winwidth(2)]\n  \" Active window (1) should have the same width or 1 more\n  \" than the other window.\n  call assert_inrange(ww2, ww2 + 1, ww1)\n\n  wincmd <\n  call assert_equal(ww1 - 1, winwidth(1))\n  call assert_equal(ww2 + 1, winwidth(2))\n\n  wincmd >\n  call assert_equal(ww1, winwidth(1))\n  call assert_equal(ww2, winwidth(2))\n\n  2wincmd |\n  call assert_equal(2, winwidth(1))\n  call assert_equal(ww1 + ww2 - 2, winwidth(2))\n\n  wincmd =\n  call assert_equal(ww1, winwidth(1))\n  call assert_equal(ww2, winwidth(2))\n\n  2wincmd |\n  set winfixwidth\n  vsplit Xc\n  let [ww1, ww2, ww3] = [winwidth(1), winwidth(2), winwidth(3)]\n  call assert_equal(2, winwidth(2))\n  call assert_inrange(ww3, ww3 + 1, ww1)\n  3wincmd >\n  call assert_equal(2,       winwidth(2))\n  call assert_equal(ww1 + 3, winwidth(1))\n  call assert_equal(ww3 - 3, winwidth(3))\n  wincmd =\n  call assert_equal(2,   winwidth(2))\n  call assert_equal(ww1, winwidth(1))\n  call assert_equal(ww3, winwidth(3))\n\n  wincmd l\n  set winfixwidth&\n\n  wincmd =\n  let [ww1, ww2, ww3] = [winwidth(1), winwidth(2), winwidth(3)]\n  \" Current window (2) should have the same width or 1 more\n  \" than the other windows.\n  call assert_inrange(ww1, ww1 + 1, ww2)\n  call assert_inrange(ww3, ww3 + 1, ww2)\n\n  \" when the current window width is less than the new 'winwidth', the current\n  \" window width should be increased.\n  enew | only\n  split\n  10vnew\n  set winwidth=15\n  call assert_equal(15, winwidth(0))\n\n  %bw!\nendfunc\n\nfunc Test_equalalways_on_close()\n  set equalalways\n  vsplit\n  windo split\n  split\n  wincmd J\n  \" now we have a frame top-left with two windows, a frame top-right with two\n  \" windows and a frame at the bottom, full-width.\n  let height_1 = winheight(1)\n  let height_2 = winheight(2)\n  let height_3 = winheight(3)\n  let height_4 = winheight(4)\n  \" closing the bottom window causes all windows to be resized.\n  close\n  call assert_notequal(height_1, winheight(1))\n  call assert_notequal(height_2, winheight(2))\n  call assert_notequal(height_3, winheight(3))\n  call assert_notequal(height_4, winheight(4))\n  call assert_equal(winheight(1), winheight(3))\n  call assert_equal(winheight(2), winheight(4))\n\n  1wincmd w\n  split\n  4wincmd w\n  resize + 5\n  \" left column has three windows, equalized heights.\n  \" right column has two windows, top one a bit higher\n  let height_1 = winheight(1)\n  let height_2 = winheight(2)\n  let height_4 = winheight(4)\n  let height_5 = winheight(5)\n  3wincmd w\n  \" closing window in left column equalizes heights in left column but not in\n  \" the right column\n  close\n  call assert_notequal(height_1, winheight(1))\n  call assert_notequal(height_2, winheight(2))\n  call assert_equal(height_4, winheight(3))\n  call assert_equal(height_5, winheight(4))\n\n  only\n  set equalalways&\nendfunc\n\nfunc Test_win_screenpos()\n  CheckFeature quickfix\n\n  call assert_equal(1, winnr('$'))\n  split\n  vsplit\n  10wincmd _\n  30wincmd |\n  call assert_equal([1, 1], win_screenpos(1))\n  call assert_equal([1, 32], win_screenpos(2))\n  call assert_equal([12, 1], win_screenpos(3))\n  call assert_equal([0, 0], win_screenpos(4))\n  call assert_fails('let l = win_screenpos([])', 'E745:')\n  only\nendfunc\n\nfunc Test_window_jump_tag()\n  CheckFeature quickfix\n\n  help\n  /iccf\n  call assert_match('^|iccf|',  getline('.'))\n  call assert_equal(2, winnr('$'))\n  2wincmd }\n  call assert_equal(3, winnr('$'))\n  call assert_match('^|iccf|',  getline('.'))\n  wincmd k\n  call assert_match('\\*iccf\\*',  getline('.'))\n  call assert_equal(2, winheight(0))\n\n  wincmd z\n  set previewheight=4\n  help\n  /bugs\n  wincmd }\n  wincmd k\n  call assert_match('\\*bugs\\*',  getline('.'))\n  call assert_equal(4, winheight(0))\n  set previewheight&\n\n  %bw!\nendfunc\n\nfunc Test_window_newtab()\n  e Xa\n\n  call assert_equal(1, tabpagenr('$'))\n  call assert_equal(\"\\nAlready only one window\", execute('wincmd T'))\n\n  split Xb\n  split Xc\n\n  wincmd T\n  call assert_equal(2, tabpagenr('$'))\n  call assert_equal(['Xb', 'Xa'], map(tabpagebuflist(1), 'bufname(v:val)'))\n  call assert_equal(['Xc'      ], map(2->tabpagebuflist(), 'bufname(v:val)'))\n  call assert_equal(['Xc'      ], map(tabpagebuflist(), 'bufname(v:val)'))\n\n  %bw!\nendfunc\n\nfunc Test_next_split_all()\n  \" This was causing an illegal memory access.\n  n x\n  norm axxx\n  split\n  split\n  s/x\n  s/x\n  all\n  bwipe!\nendfunc\n\n\" Tests for adjusting window and contents\nfunc GetScreenStr(row)\n   let str = \"\"\n   for c in range(1,3)\n       let str .= nr2char(screenchar(a:row, c))\n   endfor\n   return str\nendfunc\n\nfunc Test_window_contents()\n  enew! | only | new\n  call setline(1, range(1,256))\n\n  exe \"norm! \\<C-W>t\\<C-W>=1Gzt\\<C-W>w\\<C-W>+\"\n  redraw\n  let s3 = GetScreenStr(1)\n  wincmd p\n  call assert_equal(1, line(\"w0\"))\n  call assert_equal('1  ', s3)\n\n  exe \"norm! \\<C-W>t\\<C-W>=50Gzt\\<C-W>w\\<C-W>+\"\n  redraw\n  let s3 = GetScreenStr(1)\n  wincmd p\n  call assert_equal(50, line(\"w0\"))\n  call assert_equal('50 ', s3)\n\n  exe \"norm! \\<C-W>t\\<C-W>=59Gzt\\<C-W>w\\<C-W>+\"\n  redraw\n  let s3 = GetScreenStr(1)\n  wincmd p\n  call assert_equal(59, line(\"w0\"))\n  call assert_equal('59 ', s3)\n\n  %d\n  call setline(1, ['one', 'two', 'three'])\n  call assert_equal(1, line('w0'))\n  call assert_equal(3, line('w$'))\n\n  bwipeout!\n  call test_garbagecollect_now()\nendfunc\n\nfunc Test_window_colon_command()\n  \" This was reading invalid memory.\n  exe \"norm! v\\<C-W>:\\<C-U>echo v:version\"\nendfunc\n\nfunc Test_access_freed_mem()\n  call assert_equal(&columns, winwidth(0))\n  \" This was accessing freed memory (but with what events?)\n  au BufEnter,BufLeave,WinEnter,WinLeave 0 vs xxx\n  arg 0\n  argadd\n  call assert_fails(\"all\", \"E242:\")\n  au!\n  bwipe xxx\n  call assert_equal(&columns, winwidth(0))\nendfunc\n\nfunc Test_insert_cleared_on_switch_to_term()\n  CheckFeature terminal\n\n  set showmode\n  terminal\n  wincmd p\n\n  call feedkeys(\"i\\<C-O>\", 'ntx')\n  redraw\n\n  \" The \"-- (insert) --\" indicator should be visible.\n  let chars = map(range(1, &columns), 'nr2char(screenchar(&lines, v:val))')\n  let str = trim(join(chars, ''))\n  call assert_equal('-- (insert) --', str)\n\n  call feedkeys(\"\\<C-W>p\", 'ntx')\n  redraw\n\n  \" The \"-- (insert) --\" indicator should have been cleared.\n  let chars = map(range(1, &columns), 'nr2char(screenchar(&lines, v:val))')\n  let str = trim(join(chars, ''))\n  call assert_equal('', str)\n\n  set showmode&\n  %bw!\nendfunc\n\nfunc Test_visual_cleared_after_window_split()\n  new | only!\n  let smd_save = &showmode\n  set showmode\n  let ls_save = &laststatus\n  set laststatus=1\n  call setline(1, ['a', 'b', 'c', 'd', ''])\n  norm! G\n  exe \"norm! kkvk\"\n  redraw\n  exe \"norm! \\<C-W>v\"\n  redraw\n  \" check if '-- VISUAL --' disappeared from command line\n  let columns = range(1, &columns)\n  let cmdlinechars = map(columns, 'nr2char(screenchar(&lines, v:val))')\n  let cmdline = join(cmdlinechars, '')\n  let cmdline_ltrim = substitute(cmdline, '^\\s*', \"\", \"\")\n  let mode_shown = substitute(cmdline_ltrim, '\\s*$', \"\", \"\")\n  call assert_equal('', mode_shown)\n  let &showmode = smd_save\n  let &laststatus = ls_save\n  bwipe!\nendfunc\n\nfunc Test_winrestcmd()\n  2split\n  3vsplit\n  let restcmd = winrestcmd()\n  call assert_equal(2, winheight(0))\n  call assert_equal(3, winwidth(0))\n  wincmd =\n  call assert_notequal(2, winheight(0))\n  call assert_notequal(3, winwidth(0))\n  exe restcmd\n  call assert_equal(2, winheight(0))\n  call assert_equal(3, winwidth(0))\n  only\n\n  wincmd v\n  wincmd s\n  wincmd v\n  redraw\n  let restcmd = winrestcmd()\n  wincmd _\n  wincmd |\n  exe restcmd\n  redraw\n  call assert_equal(restcmd, winrestcmd())\n\n  only\nendfunc\n\nfunc Fun_RenewFile()\n  \" Need to wait a bit for the timestamp to be older.\n  let old_ftime = getftime(\"tmp.txt\")\n  while getftime(\"tmp.txt\") == old_ftime\n    sleep 100m\n    silent execute '!echo \"1\" > tmp.txt'\n  endwhile\n  sp\n  wincmd p\n  edit! tmp.txt\nendfunc\n\nfunc Test_window_prevwin()\n  \" Can we make this work on MS-Windows?\n  CheckUnix\n\n  set hidden autoread\n  call writefile(['2'], 'tmp.txt', 'D')\n  new tmp.txt\n  q\n  call Fun_RenewFile()\n  call assert_equal(2, winnr())\n  wincmd p\n  call assert_equal(1, winnr())\n  wincmd p\n  q\n  call Fun_RenewFile()\n  call assert_equal(2, winnr())\n  wincmd p\n  call assert_equal(1, winnr())\n  wincmd p\n  \" reset\n  q\n  set hidden&vim autoread&vim\n  delfunc Fun_RenewFile\nendfunc\n\nfunc Test_relative_cursor_position_in_one_line_window()\n  new\n  only\n  call setline(1, range(1, 10000))\n  normal 50%\n  let lnum = getcurpos()[1]\n  split\n  split\n  \" make third window take as many lines as possible, other windows will\n  \" become one line\n  3wincmd w\n  for i in range(1, &lines - 6)\n    wincmd +\n    redraw!\n  endfor\n\n  \" first and second window should show cursor line\n  let wininfo = getwininfo()\n  call assert_equal(lnum, wininfo[0].topline)\n  call assert_equal(lnum, wininfo[1].topline)\n\n  only!\n  bwipe!\n  call assert_fails('call winrestview(test_null_dict())', 'E1297:')\nendfunc\n\nfunc Test_relative_cursor_position_after_move_and_resize()\n  let so_save = &so\n  set so=0\n  enew\n  call setline(1, range(1, 10000))\n  normal 50%\n  split\n  1wincmd w\n  \" Move cursor to first line in window\n  normal H\n  redraw!\n  \" Reduce window height to two lines\n  let height = winheight(0)\n  while winheight(0) > 2\n    wincmd -\n    redraw!\n  endwhile\n  \" move cursor to second/last line in window\n  normal j\n  \" restore previous height\n  while winheight(0) < height\n    wincmd +\n    redraw!\n  endwhile\n  \" make window two lines again\n  while winheight(0) > 2\n    wincmd -\n    redraw!\n  endwhile\n\n  \" cursor should be at bottom line\n  let info = getwininfo(win_getid())[0]\n  call assert_equal(info.topline + 1, getcurpos()[1])\n\n  only!\n  bwipe!\n  let &so = so_save\nendfunc\n\nfunc Test_relative_cursor_position_after_resize()\n  let so_save = &so\n  set so=0\n  enew\n  call setline(1, range(1, 10000))\n  normal 50%\n  split\n  1wincmd w\n  let winid1 = win_getid()\n  let info = getwininfo(winid1)[0]\n  \" Move cursor to second line in window\n  exe \"normal \" . (info.topline + 1) . \"G\"\n  redraw!\n  let lnum = getcurpos()[1]\n\n  \" Make the window only two lines high, cursor should end up in top line\n  2wincmd w\n  exe (info.height - 2) . \"wincmd +\"\n  redraw!\n  let info = getwininfo(winid1)[0]\n  call assert_equal(lnum, info.topline)\n\n  only!\n  bwipe!\n  let &so = so_save\nendfunc\n\nfunc Test_relative_cursor_second_line_after_resize()\n  let so_save = &so\n  set so=0\n  enew\n  call setline(1, range(1, 10000))\n  normal 50%\n  split\n  1wincmd w\n  let winid1 = win_getid()\n  let info = getwininfo(winid1)[0]\n\n  \" Make the window only two lines high\n  2wincmd _\n\n  \" Move cursor to second line in window\n  normal H\n  normal j\n\n  \" Make window size bigger, then back to 2 lines\n  for i in range(1, 10)\n    wincmd +\n    redraw!\n  endfor\n  for i in range(1, 10)\n    wincmd -\n    redraw!\n  endfor\n\n  \" cursor should end up in bottom line\n  let info = getwininfo(winid1)[0]\n  call assert_equal(info.topline + 1, getcurpos()[1])\n\n  only!\n  bwipe!\n  let &so = so_save\nendfunc\n\nfunc Test_split_noscroll()\n  let so_save = &so\n  enew\n  call setline(1, range(1, 8))\n  normal 100%\n  split\n\n  1wincmd w\n  let winid1 = win_getid()\n  let info1 = getwininfo(winid1)[0]\n\n  2wincmd w\n  let winid2 = win_getid()\n  let info2 = getwininfo(winid2)[0]\n\n  call assert_equal(1, info1.topline)\n  call assert_equal(1, info2.topline)\n\n  \" window that fits all lines by itself, but not when split: closing other\n  \" window should restore fraction.\n  only!\n  call setline(1, range(1, &lines - 10))\n  exe &lines / 4\n  let winid1 = win_getid()\n  let info1 = getwininfo(winid1)[0]\n  call assert_equal(1, info1.topline)\n  new\n  redraw\n  close\n  let info1 = getwininfo(winid1)[0]\n  call assert_equal(1, info1.topline)\n\n  bwipe!\n  let &so = so_save\nendfunc\n\n\" Tests for the winnr() function\nfunc Test_winnr()\n  only | tabonly\n  call assert_equal(1, winnr('j'))\n  call assert_equal(1, winnr('k'))\n  call assert_equal(1, winnr('h'))\n  call assert_equal(1, winnr('l'))\n\n  \" create a set of horizontally and vertically split windows\n  leftabove new | wincmd p\n  leftabove new | wincmd p\n  rightbelow new | wincmd p\n  rightbelow new | wincmd p\n  leftabove vnew | wincmd p\n  leftabove vnew | wincmd p\n  rightbelow vnew | wincmd p\n  rightbelow vnew | wincmd p\n\n  call assert_equal(8, winnr('j'))\n  call assert_equal(2, winnr('k'))\n  call assert_equal(4, winnr('h'))\n  call assert_equal(6, winnr('l'))\n  call assert_equal(9, winnr('2j'))\n  call assert_equal(1, winnr('2k'))\n  call assert_equal(3, winnr('2h'))\n  call assert_equal(7, winnr('2l'))\n\n  \" Error cases\n  call assert_fails(\"echo winnr('0.2k')\", 'E15:')\n  call assert_equal(2, winnr('-2k'))\n  call assert_fails(\"echo winnr('-2xj')\", 'E15:')\n  call assert_fails(\"echo winnr('j2j')\", 'E15:')\n  call assert_fails(\"echo winnr('ll')\", 'E15:')\n  call assert_fails(\"echo winnr('5')\", 'E15:')\n  call assert_equal(4, winnr('0h'))\n  call assert_fails(\"let w = winnr([])\", 'E730:')\n  call assert_equal('unknown', win_gettype(-1))\n  call assert_equal(-1, winheight(-1))\n  call assert_equal(-1, winwidth(-1))\n\n  tabnew\n  call assert_equal(8, tabpagewinnr(1, 'j'))\n  call assert_equal(2, 1->tabpagewinnr('k'))\n  call assert_equal(4, tabpagewinnr(1, 'h'))\n  call assert_equal(6, tabpagewinnr(1, 'l'))\n\n  only | tabonly\nendfunc\n\nfunc Test_winrestview()\n  split runtest.vim\n  normal 50%\n  let view = winsaveview()\n  close\n  split runtest.vim\n  eval view->winrestview()\n  call assert_equal(view, winsaveview())\n\n  bwipe!\n  call assert_fails('call winrestview(test_null_dict())', 'E1297:')\nendfunc\n\nfunc Test_win_splitmove()\n  CheckFeature quickfix\n\n  edit a\n  leftabove split b\n  leftabove vsplit c\n  leftabove split d\n  call assert_equal(0, win_splitmove(winnr(), winnr('l')))\n  call assert_equal(bufname(winbufnr(1)), 'c')\n  call assert_equal(bufname(winbufnr(2)), 'd')\n  call assert_equal(bufname(winbufnr(3)), 'b')\n  call assert_equal(bufname(winbufnr(4)), 'a')\n  call assert_equal(0, win_splitmove(winnr(), winnr('j'), {'vertical': 1}))\n  call assert_equal(0, win_splitmove(winnr(), winnr('j'), {'vertical': 1}))\n  call assert_equal(bufname(winbufnr(1)), 'c')\n  call assert_equal(bufname(winbufnr(2)), 'b')\n  call assert_equal(bufname(winbufnr(3)), 'd')\n  call assert_equal(bufname(winbufnr(4)), 'a')\n  call assert_equal(0, win_splitmove(winnr(), winnr('k'), {'vertical': 1}))\n  call assert_equal(bufname(winbufnr(1)), 'd')\n  call assert_equal(bufname(winbufnr(2)), 'c')\n  call assert_equal(bufname(winbufnr(3)), 'b')\n  call assert_equal(bufname(winbufnr(4)), 'a')\n  call assert_equal(0, win_splitmove(winnr(), winnr('j'), {'rightbelow': v:true}))\n  call assert_equal(bufname(winbufnr(1)), 'c')\n  call assert_equal(bufname(winbufnr(2)), 'b')\n  call assert_equal(bufname(winbufnr(3)), 'a')\n  call assert_equal(bufname(winbufnr(4)), 'd')\n  call assert_fails('call win_splitmove(winnr(), winnr(\"k\"), test_null_dict())', 'E1297:')\n  only | bd\n\n  call assert_fails('call win_splitmove(winnr(), 123)', 'E957:')\n  call assert_fails('call win_splitmove(123, winnr())', 'E957:')\n  call assert_fails('call win_splitmove(winnr(), winnr())', 'E957:')\n\n  tabnew\n  call assert_fails('call win_splitmove(1, win_getid(1, 1))', 'E957:')\n  tabclose\nendfunc\n\n\" Test for the :only command\nfunc Test_window_only()\n  new\n  set modified\n  new\n  call assert_fails('only', 'E445:')\n  only!\n  \" Test for :only with a count\n  let wid = win_getid()\n  new\n  new\n  3only\n  call assert_equal(1, winnr('$'))\n  call assert_equal(wid, win_getid())\n  call assert_fails('close', 'E444:')\n  call assert_fails('%close', 'E16:')\nendfunc\n\n\" Test for errors with :wincmd\nfunc Test_wincmd_errors()\n  call assert_fails('wincmd g', 'E474:')\n  call assert_fails('wincmd ab', 'E474:')\nendfunc\n\n\" Test for errors with :winpos\nfunc Test_winpos_errors()\n  if !has(\"gui_running\") && !has('win32')\n    call assert_fails('winpos', 'E188:')\n  endif\n  call assert_fails('winpos 10', 'E466:')\nendfunc\n\n\" Test for +cmd in a :split command\nfunc Test_split_cmd()\n  split +set\\ readonly\n  call assert_equal(1, &readonly)\n  call assert_equal(2, winnr('$'))\n  close\nendfunc\n\n\" Create maximum number of horizontally or vertically split windows and then\n\" run commands that create a new horizontally/vertically split window\nfunc Run_noroom_for_newwindow_test(dir_arg)\n  let dir = (a:dir_arg == 'v') ? 'vert ' : ''\n\n  \" Open as many windows as possible\n  while v:true\n    try\n      exe dir . 'new'\n    catch /E36:/\n      break\n    endtry\n  endwhile\n\n  call writefile(['first', 'second', 'third'], 'Xnorfile1', 'D')\n  call writefile([], 'Xnorfile2', 'D')\n  call writefile([], 'Xnorfile3', 'D')\n\n  \" Argument list related commands\n  args Xnorfile1 Xnorfile2 Xnorfile3\n  next\n  for cmd in ['sargument 2', 'snext', 'sprevious', 'sNext', 'srewind',\n\t\t\t\\ 'sfirst', 'slast']\n    call assert_fails(dir .. cmd, 'E36:')\n  endfor\n  %argdelete\n\n  \" Buffer related commands\n  set modified\n  hide enew\n  for cmd in ['sbuffer Xnorfile1', 'sbnext', 'sbprevious', 'sbNext', 'sbrewind',\n\t\t\\ 'sbfirst', 'sblast', 'sball', 'sbmodified', 'sunhide']\n    call assert_fails(dir .. cmd, 'E36:')\n  endfor\n\n  \" Window related commands\n  for cmd in ['split', 'split Xnorfile2', 'new', 'new Xnorfile3', 'sview Xnorfile1',\n\t\t\\ 'sfind runtest.vim']\n    call assert_fails(dir .. cmd, 'E36:')\n  endfor\n\n  \" Help\n  call assert_fails(dir .. 'help', 'E36:')\n  call assert_fails(dir .. 'helpgrep window', 'E36:')\n\n  \" Command-line window\n  if a:dir_arg == 'h'\n    \" Cmd-line window is always a horizontally split window\n    call assert_beeps('call feedkeys(\"q:\\<CR>\", \"xt\")')\n  endif\n\n  \" Quickfix and location list window\n  if has('quickfix')\n    cexpr ''\n    call assert_fails(dir .. 'copen', 'E36:')\n    lexpr ''\n    call assert_fails(dir .. 'lopen', 'E36:')\n\n    \" Preview window\n    call assert_fails(dir .. 'pedit Xnorfile2', 'E36:')\n    call setline(1, 'abc')\n    call assert_fails(dir .. 'psearch abc', 'E36:')\n  endif\n\n  \" Window commands (CTRL-W ^ and CTRL-W f)\n  if a:dir_arg == 'h'\n    call assert_fails('call feedkeys(\"\\<C-W>^\", \"xt\")', 'E36:')\n    call setline(1, 'Xnorfile1')\n    call assert_fails('call feedkeys(\"gg\\<C-W>f\", \"xt\")', 'E36:')\n  endif\n  enew!\n\n  \" Tag commands (:stag, :stselect and :stjump)\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"second\\tXnorfile1\\t2\",\n        \\ \"third\\tXnorfile1\\t3\",],\n        \\ 'Xtags')\n  set tags=Xtags\n  call assert_fails(dir .. 'stag second', 'E36:')\n  call assert_fails('call feedkeys(\":\" .. dir .. \"stselect second\\n1\\n\", \"xt\")', 'E36:')\n  call assert_fails(dir .. 'stjump second', 'E36:')\n  call assert_fails(dir .. 'ptag second', 'E36:')\n  set tags&\n  call delete('Xtags')\n\n  \" :isplit and :dsplit\n  call setline(1, ['#define FOO 1', 'FOO'])\n  normal 2G\n  call assert_fails(dir .. 'isplit FOO', 'E36:')\n  call assert_fails(dir .. 'dsplit FOO', 'E36:')\n\n  \" terminal\n  if has('terminal')\n    call assert_fails(dir .. 'terminal', 'E36:')\n  endif\n\n  %bwipe!\n  only\nendfunc\n\nfunc Test_split_cmds_with_no_room()\n  call Run_noroom_for_newwindow_test('h')\n  call Run_noroom_for_newwindow_test('v')\nendfunc\n\n\" Test for various wincmd failures\nfunc Test_wincmd_fails()\n  only!\n  call assert_beeps(\"normal \\<C-W>w\")\n  call assert_beeps(\"normal \\<C-W>p\")\n  call assert_beeps(\"normal \\<C-W>gk\")\n  call assert_beeps(\"normal \\<C-W>r\")\n  call assert_beeps(\"normal \\<C-W>K\")\n  call assert_beeps(\"normal \\<C-W>H\")\n  call assert_beeps(\"normal \\<C-W>2gt\")\nendfunc\n\nfunc Test_window_resize()\n  \" Vertical :resize (absolute, relative, min and max size).\n  vsplit\n  vert resize 8\n  call assert_equal(8, winwidth(0))\n  vert resize +2\n  call assert_equal(10, winwidth(0))\n  vert resize -2\n  call assert_equal(8, winwidth(0))\n  vert resize\n  call assert_equal(&columns - 2, winwidth(0))\n  vert resize 0\n  call assert_equal(1, winwidth(0))\n  vert resize 99999\n  call assert_equal(&columns - 2, winwidth(0))\n\n  %bwipe!\n\n  \" Horizontal :resize (with absolute, relative size, min and max size).\n  split\n  resize 8\n  call assert_equal(8, winheight(0))\n  resize +2\n  call assert_equal(10, winheight(0))\n  resize -2\n  call assert_equal(8, winheight(0))\n  resize\n  call assert_equal(&lines - 4, winheight(0))\n  resize 0\n  call assert_equal(1, winheight(0))\n  resize 99999\n  call assert_equal(&lines - 4, winheight(0))\n\n  \" :resize with explicit window number.\n  let other_winnr = winnr('j')\n  exe other_winnr .. 'resize 10'\n  call assert_equal(10, winheight(other_winnr))\n  call assert_equal(&lines - 10 - 3, winheight(0))\n  exe other_winnr .. 'resize +1'\n  exe other_winnr .. 'resize +1'\n  call assert_equal(12, winheight(other_winnr))\n  call assert_equal(&lines - 10 - 3 -2, winheight(0))\n  close\n\n  vsplit\n  wincmd l\n  let other_winnr = winnr('h')\n  call assert_notequal(winnr(), other_winnr)\n  exe 'vert ' .. other_winnr .. 'resize -' .. &columns\n  call assert_equal(0, winwidth(other_winnr))\n\n  %bwipe!\nendfunc\n\n\" Test for adjusting the window width when a window is closed with some\n\" windows using 'winfixwidth'\nfunc Test_window_width_adjust()\n  only\n  \" Three vertical windows. Windows 1 and 2 have 'winfixwidth' set and close\n  \" window 2.\n  wincmd v\n  vert resize 10\n  set winfixwidth\n  wincmd v\n  set winfixwidth\n  wincmd c\n  call assert_inrange(10, 12, winwidth(1))\n  \" Three vertical windows. Windows 2 and 3 have 'winfixwidth' set and close\n  \" window 3.\n  only\n  set winfixwidth\n  wincmd v\n  vert resize 10\n  set winfixwidth\n  wincmd v\n  set nowinfixwidth\n  wincmd b\n  wincmd c\n  call assert_inrange(10, 12, winwidth(2))\n\n  new | only\nendfunc\n\n\" Test for jumping to a vertical/horizontal neighbor window based on the\n\" current cursor position\nfunc Test_window_goto_neighbor()\n  %bw!\n\n  \" Vertical window movement\n\n  \" create the following window layout:\n  \"     +--+--+\n  \"     |w1|w3|\n  \"     +--+  |\n  \"     |w2|  |\n  \"     +--+--+\n  \"     |w4   |\n  \"     +-----+\n  new\n  vsplit\n  split\n  \" vertically jump from w4\n  wincmd b\n  call setline(1, repeat(' ', &columns))\n  call cursor(1, 1)\n  wincmd k\n  call assert_equal(2, winnr())\n  wincmd b\n  call cursor(1, &columns)\n  redraw!\n  wincmd k\n  call assert_equal(3, winnr())\n  %bw!\n\n  \" create the following window layout:\n  \"     +--+--+--+\n  \"     |w1|w2|w3|\n  \"     +--+--+--+\n  \"     |w4      |\n  \"     +--------+\n  new\n  vsplit\n  vsplit\n  wincmd b\n  call setline(1, repeat(' ', &columns))\n  call cursor(1, 1)\n  wincmd k\n  call assert_equal(1, winnr())\n  wincmd b\n  call cursor(1, &columns / 2)\n  redraw!\n  wincmd k\n  call assert_equal(2, winnr())\n  wincmd b\n  call cursor(1, &columns)\n  redraw!\n  wincmd k\n  call assert_equal(3, winnr())\n  %bw!\n\n  \" Horizontal window movement\n\n  \" create the following window layout:\n  \"     +--+--+--+\n  \"     |w1|w2|w4|\n  \"     +--+--+  |\n  \"     |w3   |  |\n  \"     +-----+--+\n  vsplit\n  split\n  vsplit\n  4wincmd l\n  call setline(1, repeat([' '], &lines))\n  call cursor(1, 1)\n  redraw!\n  wincmd h\n  call assert_equal(2, winnr())\n  4wincmd l\n  call cursor(&lines, 1)\n  redraw!\n  wincmd h\n  call assert_equal(3, winnr())\n  %bw!\n\n  \" create the following window layout:\n  \"     +--+--+\n  \"     |w1|w4|\n  \"     +--+  +\n  \"     |w2|  |\n  \"     +--+  +\n  \"     |w3|  |\n  \"     +--+--+\n  vsplit\n  split\n  split\n  wincmd l\n  call setline(1, repeat([' '], &lines))\n  call cursor(1, 1)\n  redraw!\n  wincmd h\n  call assert_equal(1, winnr())\n  wincmd l\n  call cursor(&lines / 2, 1)\n  redraw!\n  wincmd h\n  call assert_equal(2, winnr())\n  wincmd l\n  call cursor(&lines, 1)\n  redraw!\n  wincmd h\n  call assert_equal(3, winnr())\n  %bw!\nendfunc\n\n\" Test for an autocmd closing the destination window when jumping from one\n\" window to another.\nfunc Test_close_dest_window()\n  split\n  edit Xdstfile\n\n  \" Test for BufLeave\n  augroup T1\n    au!\n    au BufLeave Xdstfile $wincmd c\n  augroup END\n  wincmd b\n  call assert_equal(1, winnr('$'))\n  call assert_equal('Xdstfile', @%)\n  augroup T1\n    au!\n  augroup END\n\n  \" Test for WinLeave\n  new\n  wincmd p\n  augroup T1\n    au!\n    au WinLeave * 1wincmd c\n  augroup END\n  wincmd t\n  call assert_equal(1, winnr('$'))\n  call assert_equal('Xdstfile', @%)\n  augroup T1\n    au!\n  augroup END\n  augroup! T1\n  %bw!\nendfunc\n\nfunc Test_window_minimal_size()\n  set winminwidth=0 winminheight=0\n\n  \" check size is fixed vertically\n  new\n  call win_execute(win_getid(2), 'wincmd _')\n  call assert_equal(0, winheight(0))\n  call feedkeys('0', 'tx')\n  call assert_equal(1, winheight(0))\n  bwipe!\n\n  \" check size is fixed horizontally\n  vert new\n  call win_execute(win_getid(2), 'wincmd |')\n  call assert_equal(0, winwidth(0))\n  call feedkeys('0', 'tx')\n  call assert_equal(1, winwidth(0))\n  bwipe!\n\n  if has('timers')\n    \" check size is fixed in Insert mode\n    func s:CheckSize(timer) abort\n      call win_execute(win_getid(2), 'wincmd _')\n      call assert_equal(0, winheight(0))\n      call feedkeys(\" \\<Esc>\", 't!')\n    endfunc\n    new\n    call timer_start(100, function('s:CheckSize'))\n    call feedkeys('a', 'tx!')\n    call assert_equal(1, winheight(0))\n    bwipe!\n    delfunc s:CheckSize\n  endif\n\n  set winminwidth& winminheight&\nendfunc\n\nfunc Test_win_move_separator()\n  edit a\n  leftabove vsplit b\n  let w = winwidth(0)\n  \" check win_move_separator from left window on left window\n  call assert_equal(1, winnr())\n  for offset in range(5)\n    call assert_true(win_move_separator(0, offset))\n    call assert_equal(w + offset, winwidth(0))\n    call assert_true(0->win_move_separator(-offset))\n    call assert_equal(w, winwidth(0))\n  endfor\n  \" check win_move_separator from right window on left window number\n  wincmd l\n  call assert_notequal(1, winnr())\n  for offset in range(5)\n    call assert_true(1->win_move_separator(offset))\n    call assert_equal(w + offset, winwidth(1))\n    call assert_true(win_move_separator(1, -offset))\n    call assert_equal(w, winwidth(1))\n  endfor\n  \" check win_move_separator from right window on left window ID\n  let id = win_getid(1)\n  for offset in range(5)\n    call assert_true(win_move_separator(id, offset))\n    call assert_equal(w + offset, winwidth(id))\n    call assert_true(id->win_move_separator(-offset))\n    call assert_equal(w, winwidth(id))\n  endfor\n  \" check win_move_separator from right window on right window is no-op\n  let w0 = winwidth(0)\n  call assert_true(win_move_separator(0, 1))\n  call assert_equal(w0, winwidth(0))\n  call assert_true(win_move_separator(0, -1))\n  call assert_equal(w0, winwidth(0))\n\n  \" check that win_move_separator doesn't error with offsets beyond moving\n  \" possibility\n  call assert_true(win_move_separator(id, 5000))\n  call assert_true(winwidth(id) > w)\n  call assert_true(win_move_separator(id, -5000))\n  call assert_true(winwidth(id) < w)\n\n  \" check that win_move_separator returns false for an invalid window\n  wincmd =\n  let w = winwidth(0)\n  call assert_false(win_move_separator(-1, 1))\n  call assert_equal(w, winwidth(0))\n\n  \" check that win_move_separator returns false for a popup window\n  let id = popup_create(['hello', 'world'], {})\n  let w = winwidth(id)\n  call assert_false(win_move_separator(id, 1))\n  call assert_equal(w, winwidth(id))\n  call popup_close(id)\n\n  \" check that using another tabpage fails without crash\n  let id = win_getid()\n  tabnew\n  call assert_fails('call win_move_separator(id, -1)', 'E1308:')\n  tabclose\n\n  %bwipe!\nendfunc\n\nfunc Test_win_move_statusline()\n  edit a\n  leftabove split b\n  let h = winheight(0)\n  \" check win_move_statusline from top window on top window\n  call assert_equal(1, winnr())\n  for offset in range(5)\n    call assert_true(win_move_statusline(0, offset))\n    call assert_equal(h + offset, winheight(0))\n    call assert_true(0->win_move_statusline(-offset))\n    call assert_equal(h, winheight(0))\n  endfor\n  \" check win_move_statusline from bottom window on top window number\n  wincmd j\n  call assert_notequal(1, winnr())\n  for offset in range(5)\n    call assert_true(1->win_move_statusline(offset))\n    call assert_equal(h + offset, winheight(1))\n    call assert_true(win_move_statusline(1, -offset))\n    call assert_equal(h, winheight(1))\n  endfor\n  \" check win_move_statusline from bottom window on bottom window\n  let h0 = winheight(0)\n  for offset in range(5)\n    call assert_true(0->win_move_statusline(-offset))\n    call assert_equal(h0 - offset, winheight(0))\n    call assert_equal(1 + offset, &cmdheight)\n    call assert_true(win_move_statusline(0, offset))\n    call assert_equal(h0, winheight(0))\n    call assert_equal(1, &cmdheight)\n  endfor\n  call assert_true(win_move_statusline(0, 1))\n  call assert_equal(h0, winheight(0))\n  call assert_equal(1, &cmdheight)\n  \" check win_move_statusline from bottom window on top window ID\n  let id = win_getid(1)\n  for offset in range(5)\n    call assert_true(win_move_statusline(id, offset))\n    call assert_equal(h + offset, winheight(id))\n    call assert_true(id->win_move_statusline(-offset))\n    call assert_equal(h, winheight(id))\n  endfor\n\n  \" check that win_move_statusline doesn't error with offsets beyond moving\n  \" possibility\n  call assert_true(win_move_statusline(id, 5000))\n  call assert_true(winheight(id) > h)\n  call assert_true(win_move_statusline(id, -5000))\n  call assert_true(winheight(id) < h)\n\n  \" check that win_move_statusline returns false for an invalid window\n  wincmd =\n  let h = winheight(0)\n  call assert_false(win_move_statusline(-1, 1))\n  call assert_equal(h, winheight(0))\n\n  \" check that win_move_statusline returns false for a popup window\n  let id = popup_create(['hello', 'world'], {})\n  let h = winheight(id)\n  call assert_false(win_move_statusline(id, 1))\n  call assert_equal(h, winheight(id))\n  call popup_close(id)\n\n  \" check that using another tabpage fails without crash\n  let id = win_getid()\n  tabnew\n  call assert_fails('call win_move_statusline(id, -1)', 'E1308:')\n  tabclose\n\n  %bwipe!\nendfunc\n\n\" Test for window allocation failure\nfunc Test_window_alloc_failure()\n  %bw!\n\n  \" test for creating a new window above current window\n  call test_alloc_fail(GetAllocId('newwin_wvars'), 0, 0)\n  call assert_fails('above new', 'E342:')\n  call assert_equal(1, winnr('$'))\n\n  \" test for creating a new window below current window\n  call test_alloc_fail(GetAllocId('newwin_wvars'), 0, 0)\n  call assert_fails('below new', 'E342:')\n  call assert_equal(1, winnr('$'))\n\n  \" test for popup window creation failure\n  call test_alloc_fail(GetAllocId('newwin_wvars'), 0, 0)\n  call assert_fails('call popup_create(\"Hello\", {})', 'E342:')\n  call assert_equal([], popup_list())\n\n  call test_alloc_fail(GetAllocId('newwin_wvars'), 0, 0)\n  call assert_fails('split', 'E342:')\n  call assert_equal(1, winnr('$'))\n\n  edit Xwaffile1\n  edit Xwaffile2\n  call test_alloc_fail(GetAllocId('newwin_wvars'), 0, 0)\n  call assert_fails('sb Xwaffile1', 'E342:')\n  call assert_equal(1, winnr('$'))\n  call assert_equal('Xwaffile2', @%)\n  %bw!\n\n  \" FIXME: The following test crashes Vim\n  \" test for new tabpage creation failure\n  \" call test_alloc_fail(GetAllocId('newwin_wvars'), 0, 0)\n  \" call assert_fails('tabnew', 'E342:')\n  \" call assert_equal(1, tabpagenr('$'))\n  \" call assert_equal(1, winnr('$'))\n\n  \" This test messes up the internal Vim window/frame information. So the\n  \" Test_window_cmd_cmdwin_with_vsp() test fails after running this test.\n  \" Open a new tab and close everything else to fix this issue.\n  tabnew\n  tabonly\nendfunc\n\nfunc Test_win_equal_last_status()\n  let save_lines = &lines\n  set lines=20\n  set splitbelow\n  set laststatus=0\n\n  split | split | quit\n  call assert_equal(winheight(1), winheight(2))\n\n  let &lines = save_lines\n  set splitbelow&\n  set laststatus&\nendfunc\n\n\" Test \"screen\" and \"cursor\" values for 'splitkeep' with a sequence of\n\" split operations for various options: with and without a winbar,\n\" tabline, for each possible value of 'laststatus', 'scrolloff',\n\" 'equalalways', and with the cursor at the top, middle and bottom.\nfunc Test_splitkeep_options()\n  \" disallow window resizing\n  let save_WS = &t_WS\n  set t_WS=\n\n  let gui = has(\"gui_running\")\n  inoremap <expr> c \"<cmd>copen<bar>wincmd k<CR>\"\n  for run in range(0, 20)\n    let &splitkeep = run > 10 ? 'topline' : 'screen'\n    let &scrolloff = (!(run % 4) ? 0 : run)\n    let &laststatus = (run % 3)\n    let &splitbelow = (run % 3)\n    let &equalalways = (run % 2)\n    let wsb = (run % 2) && &splitbelow\n    let tl = (gui ? 0 : ((run % 5) ? 1 : 0))\n    let pos = !(run % 3) ? 'H' : ((run % 2) ? 'M' : 'L')\n    tabnew | tabonly! | redraw\n    execute (run % 5) ? 'tabnew' : ''\n    execute (run % 2) ? 'nnoremenu 1.10 WinBar.Test :echo' : ''\n    call setline(1, range(1, 256))\n    \" No scroll for restore_snapshot\n    norm G\n    try\n      copen | close | colder\n    catch /E380/\n    endtry\n    call assert_equal(257 - winheight(0), line(\"w0\"))\n\n    \" No scroll for firstwin horizontal split\n    execute 'norm gg' . pos\n    split | redraw | wincmd k\n    call assert_equal(1, line(\"w0\"))\n    call assert_equal(&scroll, winheight(0) / 2)\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n\n    \" No scroll when resizing windows\n    wincmd k | resize +2 | redraw\n    call assert_equal(1, line(\"w0\"))\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n\n    \" No scroll when dragging statusline\n    call win_move_statusline(1, -3)\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n    wincmd k\n    call assert_equal(1, line(\"w0\"))\n\n    \" No scroll when changing shellsize\n    set lines+=2\n    call assert_equal(1, line(\"w0\"))\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n    set lines-=2\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n    wincmd k\n    call assert_equal(1, line(\"w0\"))\n\n    \" No scroll when equalizing windows\n    wincmd =\n    call assert_equal(1, line(\"w0\"))\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n    wincmd k\n    call assert_equal(1, line(\"w0\"))\n\n    \" No scroll in windows split multiple times\n    vsplit | split | 4wincmd w\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n    1wincmd w | quit | wincmd l | split\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n\n    \" No scroll in small window\n    2wincmd w | only | 5split | wincmd k\n    call assert_equal(1, line(\"w0\"))\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n\n    \" No scroll for vertical split\n    quit | vsplit | wincmd l\n    call assert_equal(1, line(\"w0\"))\n    wincmd h\n    call assert_equal(1, line(\"w0\"))\n\n    \" No scroll in windows split and quit multiple times\n    quit | redraw | split | split | quit | redraw\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n\n    \" No scroll for new buffer\n    1wincmd w | only | copen | wincmd k\n    call assert_equal(1, line(\"w0\"))\n    only\n    call assert_equal(1, line(\"w0\"))\n    above copen | wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl, line(\"w0\"))\n\n    \" No scroll when opening cmdwin, and no cursor move when closing cmdwin.\n    only | norm ggL\n    let curpos = getcurpos()\n    norm q:\n    call assert_equal(1, line(\"w0\"))\n    call assert_equal(curpos, getcurpos())\n\n    \" Scroll when cursor becomes invalid in insert mode.\n    norm Lic\n    call assert_equal(curpos, getcurpos(), 'run ' .. run)\n\n    \" No scroll when topline not equal to 1\n    only | execute \"norm gg5\\<C-e>\" | split | wincmd k\n    call assert_equal(6, line(\"w0\"))\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 6 : 5 + win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n  endfor\n\n  tabnew | tabonly! | %bwipeout!\n  iunmap c\n  set scrolloff&\n  set splitbelow&\n  set laststatus&\n  set equalalways&\n  set splitkeep&\n  let &t_WS = save_WS\nendfunc\n\nfunction Test_splitkeep_cmdwin_cursor_position()\n  set splitkeep=screen\n  call setline(1, range(&lines))\n\n  \" No scroll when cursor is at near bottom of window and cusor position\n  \" recompution (done by line('w0') in this test) happens while in cmdwin.\n  normal! G\n  let firstline = line('w0')\n  autocmd CmdwinEnter * ++once autocmd WinEnter * ++once call line('w0')\n  execute \"normal! q:\\<C-w>q\"\n  redraw!\n  call assert_equal(firstline, line('w0'))\n\n  \" User script can change cursor position successfully while in cmdwin and it\n  \" shouldn't be changed when closing cmdwin.\n  execute \"normal! Gq:\\<Cmd>call win_execute(winnr('#')->win_getid(), 'call cursor(1, 1)')\\<CR>\\<C-w>q\"\n  call assert_equal(1, line('.'))\n  call assert_equal(1, col('.'))\n\n  execute \"normal! Gq:\\<Cmd>autocmd WinEnter * ++once call cursor(1, 1)\\<CR>\\<C-w>q\"\n  call assert_equal(1, line('.'))\n  call assert_equal(1, col('.'))\n\n  %bwipeout!\n  set splitkeep&\nendfunction\n\nfunction Test_splitkeep_misc()\n  set splitkeep=screen\n  set splitbelow\n\n  call setline(1, range(1, &lines))\n  norm Gzz\n  let top = line('w0')\n  \" No scroll when aucmd_win is opened\n  call setbufvar(bufnr(\"test\", 1) , '&buftype', 'nofile')\n  call assert_equal(top, line('w0'))\n  \" No scroll when tab is changed/closed\n  tab help | close\n  call assert_equal(top, line('w0'))\n  \" No scroll when help is closed and buffer line count < window height\n  norm ggdG\n  call setline(1, range(1, &lines - 10))\n  norm G\n  let top = line('w0')\n  help | quit\n  call assert_equal(top, line('w0'))\n  \" No error when resizing window in autocmd and buffer length changed\n  autocmd FileType qf exe \"resize\" line('$')\n  cexpr getline(1, '$')\n  copen\n  wincmd p\n  norm dd\n  cexpr getline(1, '$')\n\n  %bwipeout!\n  set splitbelow&\n  set splitkeep&\nendfunc\n\nfunction Test_splitkeep_callback()\n  CheckScreendump\n  let lines =<< trim END\n    set splitkeep=screen\n    call setline(1, range(&lines))\n    function C1(a, b)\n      split | wincmd p\n    endfunction\n    function C2(a, b)\n      close | split\n    endfunction\n    nn j <cmd>call job_start([&sh, &shcf, \"true\"], { 'exit_cb': 'C1' })<CR>\n    nn t <cmd>call popup_create(term_start([&sh, &shcf, \"true\"],\n          \\ { 'hidden': 1, 'exit_cb': 'C2' }), {})<CR>\n  END\n  call writefile(lines, 'XTestSplitkeepCallback', 'D')\n  let buf = RunVimInTerminal('-S XTestSplitkeepCallback', #{rows: 8})\n\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_callback_1', {})\n\n  call term_sendkeys(buf, \":quit\\<CR>Ht\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_callback_2', {})\n\n  call term_sendkeys(buf, \":set sb\\<CR>:quit\\<CR>Gj\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_callback_3', {})\n\n  call term_sendkeys(buf, \":quit\\<CR>Gt\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_callback_4', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunction Test_splitkeep_fold()\n  CheckScreendump\n\n  let lines =<< trim END\n    set splitkeep=screen\n    set foldmethod=marker\n    set number\n    let line = 1\n    for n in range(1, &lines)\n      call setline(line, ['int FuncName() {/*{{{*/', 1, 2, 3, 4, 5, '}/*}}}*/',\n            \\ 'after fold'])\n      let line += 8\n    endfor\n  END\n  call writefile(lines, 'XTestSplitkeepFold', 'D')\n  let buf = RunVimInTerminal('-S XTestSplitkeepFold', #{rows: 10})\n\n  call term_sendkeys(buf, \"L:wincmd s\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_fold_1', {})\n\n  call term_sendkeys(buf, \":quit\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_fold_2', {})\n\n  call term_sendkeys(buf, \"H:below split\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_fold_3', {})\n\n  call term_sendkeys(buf, \":wincmd k\\<CR>:quit\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_fold_4', {})\n\n  call StopVimInTerminal(buf)\nendfunction\n\nfunction Test_splitkeep_status()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['a', 'b', 'c'])\n    set nomodified\n    set splitkeep=screen\n    let win = winnr()\n    wincmd s\n    wincmd j\n  END\n  call writefile(lines, 'XTestSplitkeepStatus', 'D')\n  let buf = RunVimInTerminal('-S XTestSplitkeepStatus', #{rows: 10})\n\n  call term_sendkeys(buf, \":call win_move_statusline(win, 1)\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_status_1', {})\n\n  call StopVimInTerminal(buf)\nendfunction\n\nfunction Test_new_help_window_on_error()\n  help change.txt\n  execute \"normal! /CTRL-@\\<CR>\"\n  silent! execute \"normal! \\<C-W>]\"\n\n  let wincount = winnr('$')\n  help 'mod'\n\n  call assert_equal(wincount, winnr('$'))\n  call assert_equal(expand(\"<cword>\"), \"'mod'\")\nendfunction\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * move.c: Functions for moving the cursor and scrolling text.\n *\n * There are two ways to move the cursor:\n * 1. Move the cursor directly, the text is scrolled to keep the cursor in the\n *    window.\n * 2. Scroll the text, the cursor is moved into the text visible in the\n *    window.\n * The 'scrolloff' option makes this a bit complicated.\n */\n\n#include \"vim.h\"\n\nstatic int scrolljump_value(void);\nstatic int check_top_offset(void);\nstatic void curs_rows(win_T *wp);\n\ntypedef struct\n{\n    linenr_T\t    lnum;\t// line number\n#ifdef FEAT_DIFF\n    int\t\t    fill;\t// filler lines\n#endif\n    int\t\t    height;\t// height of added line\n} lineoff_T;\n\nstatic void topline_back(lineoff_T *lp);\nstatic void botline_forw(lineoff_T *lp);\n\n/*\n * Reduce \"n\" for the screen lines skipped with \"wp->w_skipcol\".\n */\n    static int\nadjust_plines_for_skipcol(win_T *wp, int n)\n{\n    if (wp->w_skipcol == 0)\n\treturn n;\n\n    int off = 0;\n    int width = wp->w_width - win_col_off(wp);\n    if (wp->w_skipcol >= width)\n    {\n\t++off;\n\tint skip = wp->w_skipcol - width;\n\twidth += win_col_off2(wp);\n\twhile (skip >= width)\n\t{\n\t    ++off;\n\t    skip -= width;\n\t}\n    }\n    wp->w_valid &= ~VALID_WROW;\n    return n - off;\n}\n\n/*\n * Return how many lines \"lnum\" will take on the screen, taking into account\n * whether it is the first line, whether w_skipcol is non-zero and limiting to\n * the window height.\n */\n    static int\nplines_correct_topline(win_T *wp, linenr_T lnum)\n{\n    int n;\n#ifdef FEAT_DIFF\n    if (lnum == wp->w_topline)\n\tn = plines_win_nofill(wp, lnum, FALSE) + wp->w_topfill;\n    else\n#endif\n\tn = plines_win(wp, lnum, FALSE);\n    if (lnum == wp->w_topline)\n\tn = adjust_plines_for_skipcol(wp, n);\n    if (n > wp->w_height)\n\tn = wp->w_height;\n    return n;\n}\n\n/*\n * Compute wp->w_botline for the current wp->w_topline.  Can be called after\n * wp->w_topline changed.\n */\n    static void\ncomp_botline(win_T *wp)\n{\n    int\t\tn;\n    linenr_T\tlnum;\n    int\t\tdone;\n#ifdef FEAT_FOLDING\n    linenr_T    last;\n    int\t\tfolded;\n#endif\n\n    /*\n     * If w_cline_row is valid, start there.\n     * Otherwise have to start at w_topline.\n     */\n    check_cursor_moved(wp);\n    if (wp->w_valid & VALID_CROW)\n    {\n\tlnum = wp->w_cursor.lnum;\n\tdone = wp->w_cline_row;\n    }\n    else\n    {\n\tlnum = wp->w_topline;\n\tdone = 0;\n    }\n\n    for ( ; lnum <= wp->w_buffer->b_ml.ml_line_count; ++lnum)\n    {\n#ifdef FEAT_FOLDING\n\tlast = lnum;\n\tfolded = FALSE;\n\tif (hasFoldingWin(wp, lnum, NULL, &last, TRUE, NULL))\n\t{\n\t    n = 1;\n\t    folded = TRUE;\n\t}\n\telse\n#endif\n\t{\n\t    n = plines_correct_topline(wp, lnum);\n\t}\n\tif (\n#ifdef FEAT_FOLDING\n\t\tlnum <= wp->w_cursor.lnum && last >= wp->w_cursor.lnum\n#else\n\t\tlnum == wp->w_cursor.lnum\n#endif\n\t   )\n\t{\n\t    wp->w_cline_row = done;\n\t    wp->w_cline_height = n;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = folded;\n#endif\n\t    redraw_for_cursorline(wp);\n\t    wp->w_valid |= (VALID_CROW|VALID_CHEIGHT);\n\t}\n\tif (done + n > wp->w_height)\n\t    break;\n\tdone += n;\n#ifdef FEAT_FOLDING\n\tlnum = last;\n#endif\n    }\n\n    // wp->w_botline is the line that is just below the window\n    wp->w_botline = lnum;\n    wp->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\n    set_empty_rows(wp, done);\n}\n\n/*\n * Redraw when w_cline_row changes and 'relativenumber' or 'cursorline' is\n * set.\n */\n    void\nredraw_for_cursorline(win_T *wp)\n{\n    if ((wp->w_p_rnu\n#ifdef FEAT_SYN_HL\n\t\t|| wp->w_p_cul\n#endif\n\t\t)\n\t    && (wp->w_valid & VALID_CROW) == 0\n\t    && !pum_visible())\n    {\n\t// win_line() will redraw the number column and cursorline only.\n\tredraw_win_later(wp, UPD_VALID);\n    }\n}\n\n#ifdef FEAT_SYN_HL\n/*\n * Redraw when w_virtcol changes and 'cursorcolumn' is set or 'cursorlineopt'\n * contains \"screenline\".\n */\n    static void\nredraw_for_cursorcolumn(win_T *wp)\n{\n    if ((wp->w_valid & VALID_VIRTCOL) == 0 && !pum_visible())\n    {\n\t// When 'cursorcolumn' is set need to redraw with UPD_SOME_VALID.\n\tif (wp->w_p_cuc)\n\t    redraw_win_later(wp, UPD_SOME_VALID);\n\t// When 'cursorlineopt' contains \"screenline\" need to redraw with\n\t// UPD_VALID.\n\telse if (wp->w_p_cul && (wp->w_p_culopt_flags & CULOPT_SCRLINE))\n\t    redraw_win_later(wp, UPD_VALID);\n    }\n}\n#endif\n\n/*\n * Calculates how much overlap the smoothscroll marker \"<<<\" overlaps with\n * buffer text for curwin.\n * Parameter \"extra2\" should be the padding on the 2nd line, not the first\n * line.\n * Returns the number of columns of overlap with buffer text, excluding the\n * extra padding on the ledge.\n */\n    static int\nsmoothscroll_marker_overlap(int extra2)\n{\n#if defined(FEAT_LINEBREAK)\n    // We don't draw the <<< marker when in showbreak mode, thus no need to\n    // account for it.  See wlv_screen_line().\n    if (*get_showbreak_value(curwin) != NUL)\n\treturn 0;\n#endif\n    return extra2 > 3 ? 0 : 3 - extra2;\n}\n\n/*\n * Calculates the skipcol offset for window \"wp\" given how many\n * physical lines we want to scroll down.\n */\n    static int\nskipcol_from_plines(win_T *wp, int plines_off)\n{\n    int width1 = wp->w_width - win_col_off(wp);\n\n    int skipcol = 0;\n    if (plines_off > 0)\n\tskipcol += width1;\n    if (plines_off > 1)\n\tskipcol += (width1 + win_col_off2(wp)) * (plines_off - 1);\n    return skipcol;\n}\n\n/*\n * Set curwin->s_skipcol to zero and redraw later if needed.\n */\n    static void\nreset_skipcol(void)\n{\n    if (curwin->w_skipcol == 0)\n\treturn;\n\n    curwin->w_skipcol = 0;\n\n    // Should use the least expensive way that displays all that changed.\n    // UPD_NOT_VALID is too expensive, UPD_REDRAW_TOP does not redraw\n    // enough when the top line gets another screen line.\n    redraw_later(UPD_SOME_VALID);\n}\n\n/*\n * Update curwin->w_topline and redraw if necessary.\n * Used to update the screen before printing a message.\n */\n    void\nupdate_topline_redraw(void)\n{\n    update_topline();\n    if (must_redraw)\n\tupdate_screen(0);\n}\n\n/*\n * Update curwin->w_topline to move the cursor onto the screen.\n */\n    void\nupdate_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // Cursor is updated instead when this is TRUE for 'splitkeep'.\n    if (skip_update_topline)\n\treturn;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(UPD_NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1 || curwin->w_skipcol > 0)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t    else if (curwin->w_cursor.lnum == curwin->w_topline)\n\t    {\n\t\tcolnr_T vcol;\n\n\t\t// Check that the cursor position is visible.  Add columns for\n\t\t// the smoothscroll marker \"<<<\" displayed in the top-left if\n\t\t// needed.\n\t\tgetvvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t\tint smoothscroll_overlap = smoothscroll_marker_overlap(\n\t\t\t\t\t curwin_col_off() - curwin_col_off2());\n\t\tif (curwin->w_skipcol + smoothscroll_overlap > vcol)\n\t\t    check_topline = TRUE;\n\t    }\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE, FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t   >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE, FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tredraw_later(UPD_VALID);\n\treset_skipcol();\n\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}\n\n/*\n * Return the scrolljump value to use for the current window.\n * When 'scrolljump' is positive use it as-is.\n * When 'scrolljump' is negative use it as a percentage of the window height.\n */\n    static int\nscrolljump_value(void)\n{\n    if (p_sj >= 0)\n\treturn (int)p_sj;\n    return (curwin->w_height * -p_sj) / 100;\n}\n\n/*\n * Return TRUE when there are not 'scrolloff' lines above the cursor for the\n * current window.\n */\n    static int\ncheck_top_offset(void)\n{\n    lineoff_T\tloff;\n    int\t\tn;\n    long\tso = get_scrolloff_value();\n\n    if (curwin->w_cursor.lnum < curwin->w_topline + so\n#ifdef FEAT_FOLDING\n\t\t    || hasAnyFolding(curwin)\n#endif\n\t    )\n    {\n\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n\tn = curwin->w_topfill;\t    // always have this context\n#else\n\tn = 0;\n#endif\n\t// Count the visible screen lines above the cursor line.\n\twhile (n < so)\n\t{\n\t    topline_back(&loff);\n\t    // Stop when included a line above the window.\n\t    if (loff.lnum < curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t    || (loff.lnum == curwin->w_topline && loff.fill > 0)\n#endif\n\t\t    )\n\t\tbreak;\n\t    n += loff.height;\n\t}\n\tif (n < so)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Update w_curswant.\n */\n    void\nupdate_curswant_force(void)\n{\n    validate_virtcol();\n    curwin->w_curswant = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t- curwin->w_virtcol_first_char\n#endif\n\t;\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Update w_curswant if w_set_curswant is set.\n */\n    void\nupdate_curswant(void)\n{\n    if (curwin->w_set_curswant)\n\tupdate_curswant_force();\n}\n\n/*\n * Check if the cursor has moved.  Set the w_valid flag accordingly.\n */\n    void\ncheck_cursor_moved(win_T *wp)\n{\n    if (wp->w_cursor.lnum != wp->w_valid_cursor.lnum)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t      |VALID_CHEIGHT|VALID_CROW|VALID_TOPLINE\n\t\t\t\t      |VALID_BOTLINE|VALID_BOTLINE_AP);\n\twp->w_valid_cursor = wp->w_cursor;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_skipcol = wp->w_skipcol;\n    }\n    else if (wp->w_skipcol != wp->w_valid_skipcol)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t      |VALID_CHEIGHT|VALID_CROW\n\t\t\t\t      |VALID_BOTLINE|VALID_BOTLINE_AP);\n\twp->w_valid_cursor = wp->w_cursor;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_skipcol = wp->w_skipcol;\n    }\n    else if (wp->w_cursor.col != wp->w_valid_cursor.col\n\t     || wp->w_leftcol != wp->w_valid_leftcol\n\t     || wp->w_cursor.coladd != wp->w_valid_cursor.coladd)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\twp->w_valid_cursor.col = wp->w_cursor.col;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_cursor.coladd = wp->w_cursor.coladd;\n    }\n}\n\n/*\n * Call this function when some window settings have changed, which require\n * the cursor position, botline and topline to be recomputed and the window to\n * be redrawn.  E.g, when changing the 'wrap' option or folding.\n */\n    void\nchanged_window_setting(void)\n{\n    changed_window_setting_win(curwin);\n}\n\n    void\nchanged_window_setting_win(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP|VALID_TOPLINE);\n    redraw_win_later(wp, UPD_NOT_VALID);\n}\n\n/*\n * Call changed_window_setting_win() for every window containing \"buf\".\n */\n    void\nchanged_window_setting_buf(buf_T *buf)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == buf)\n\t    changed_window_setting_win(wp);\n}\n\n/*\n * Set wp->w_topline to a certain number.\n */\n    void\nset_topline(win_T *wp, linenr_T lnum)\n{\n#ifdef FEAT_DIFF\n    linenr_T prev_topline = wp->w_topline;\n#endif\n\n#ifdef FEAT_FOLDING\n    // go to first of folded lines\n    (void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n    // Approximate the value of w_botline\n    wp->w_botline += lnum - wp->w_topline;\n    if (wp->w_botline > wp->w_buffer->b_ml.ml_line_count + 1)\n\twp->w_botline = wp->w_buffer->b_ml.ml_line_count + 1;\n    wp->w_topline = lnum;\n    wp->w_topline_was_set = TRUE;\n#ifdef FEAT_DIFF\n    if (lnum != prev_topline)\n\t// Keep the filler lines when the topline didn't change.\n\twp->w_topfill = 0;\n#endif\n    wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);\n    // Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.\n    redraw_later(UPD_VALID);\n}\n\n/*\n * Call this function when the length of the cursor line (in screen\n * characters) has changed, and the change is before the cursor.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_cline_bef_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_cline_bef_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Call this function when the length of a line (in screen characters) above\n * the cursor have changed.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_line_abv_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_line_abv_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Display of line has changed for \"buf\", invalidate cursor position and\n * w_botline.\n */\n    void\nchanged_line_display_buf(buf_T *buf)\n{\n    win_T *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer == buf)\n\t    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t|VALID_CROW|VALID_CHEIGHT\n\t\t\t\t|VALID_TOPLINE|VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n/*\n * Make sure the value of curwin->w_botline is valid.\n */\n    void\nvalidate_botline(void)\n{\n    validate_botline_win(curwin);\n}\n\n/*\n * Make sure the value of wp->w_botline is valid.\n */\n    void\nvalidate_botline_win(win_T *wp)\n{\n    if (!(wp->w_valid & VALID_BOTLINE))\n\tcomp_botline(wp);\n}\n\n/*\n * Mark curwin->w_botline as invalid (because of some change in the buffer).\n */\n    void\ninvalidate_botline(void)\n{\n    curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\ninvalidate_botline_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\napproximate_botline_win(\n    win_T\t*wp)\n{\n    wp->w_valid &= ~VALID_BOTLINE;\n}\n\n/*\n * Return TRUE if curwin->w_wrow and curwin->w_wcol are valid.\n */\n    int\ncursor_valid(void)\n{\n    check_cursor_moved(curwin);\n    return ((curwin->w_valid & (VALID_WROW|VALID_WCOL)) ==\n\t\t\t\t\t\t      (VALID_WROW|VALID_WCOL));\n}\n\n/*\n * Validate cursor position.  Makes sure w_wrow and w_wcol are valid.\n * w_topline must be valid, you may need to call update_topline() first!\n */\n    void\nvalidate_cursor(void)\n{\n    check_cursor_lnum();\n    check_cursor_moved(curwin);\n    if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))\n\tcurs_columns(TRUE);\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * validate w_cline_row.\n */\n    void\nvalidate_cline_row(void)\n{\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n}\n#endif\n\n/*\n * Compute wp->w_cline_row and wp->w_cline_height, based on the current value\n * of wp->w_topline.\n */\n    static void\ncurs_rows(win_T *wp)\n{\n    linenr_T\tlnum;\n    int\t\ti;\n    int\t\tall_invalid;\n    int\t\tvalid;\n#ifdef FEAT_FOLDING\n    long\tfold_count;\n#endif\n\n    // Check if wp->w_lines[].wl_size is invalid\n    all_invalid = (!redrawing()\n\t\t\t|| wp->w_lines_valid == 0\n\t\t\t|| wp->w_lines[0].wl_lnum > wp->w_topline);\n    i = 0;\n    wp->w_cline_row = 0;\n    for (lnum = wp->w_topline; lnum < wp->w_cursor.lnum; ++i)\n    {\n\tvalid = FALSE;\n\tif (!all_invalid && i < wp->w_lines_valid)\n\t{\n\t    if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)\n\t\tcontinue;\t\t// skip changed or deleted lines\n\t    if (wp->w_lines[i].wl_lnum == lnum)\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Check for newly inserted lines below this row, in which\n\t\t// case we need to check for folded lines.\n\t\tif (!wp->w_buffer->b_mod_set\n\t\t\t|| wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum\n\t\t\t|| wp->w_buffer->b_mod_top\n\t\t\t\t\t     > wp->w_lines[i].wl_lastlnum + 1)\n#endif\n\t\tvalid = TRUE;\n\t    }\n\t    else if (wp->w_lines[i].wl_lnum > lnum)\n\t\t--i;\t\t\t// hold at inserted lines\n\t}\n\tif (valid\n#ifdef FEAT_DIFF\n\t\t&& (lnum != wp->w_topline || !wp->w_p_diff)\n#endif\n\t\t)\n\t{\n#ifdef FEAT_FOLDING\n\t    lnum = wp->w_lines[i].wl_lastlnum + 1;\n\t    // Cursor inside folded lines, don't count this row\n\t    if (lnum > wp->w_cursor.lnum)\n\t\tbreak;\n#else\n\t    ++lnum;\n#endif\n\t    wp->w_cline_row += wp->w_lines[i].wl_size;\n\t}\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    fold_count = foldedCount(wp, lnum, NULL);\n\t    if (fold_count)\n\t    {\n\t\tlnum += fold_count;\n\t\tif (lnum > wp->w_cursor.lnum)\n\t\t    break;\n\t\t++wp->w_cline_row;\n\t    }\n\t    else\n#endif\n\t    {\n\t\twp->w_cline_row += plines_correct_topline(wp, lnum);\n\t\t++lnum;\n\t    }\n\t}\n    }\n\n    check_cursor_moved(wp);\n    if (!(wp->w_valid & VALID_CHEIGHT))\n    {\n\tif (all_invalid\n\t\t|| i == wp->w_lines_valid\n\t\t|| (i < wp->w_lines_valid\n\t\t    && (!wp->w_lines[i].wl_valid\n\t\t\t|| wp->w_lines[i].wl_lnum != wp->w_cursor.lnum)))\n\t{\n#ifdef FEAT_DIFF\n\t    if (wp->w_cursor.lnum == wp->w_topline)\n\t\twp->w_cline_height = plines_win_nofill(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t\tTRUE) + wp->w_topfill;\n\t    else\n#endif\n\t\twp->w_cline_height = plines_win(wp, wp->w_cursor.lnum, TRUE);\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse if (i > wp->w_lines_valid)\n\t{\n\t    // a line that is too long to fit on the last screen line\n\t    wp->w_cline_height = 0;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse\n\t{\n\t    wp->w_cline_height = wp->w_lines[i].wl_size;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = wp->w_lines[i].wl_folded;\n#endif\n\t}\n    }\n\n    redraw_for_cursorline(curwin);\n    wp->w_valid |= VALID_CROW|VALID_CHEIGHT;\n}\n\n/*\n * Validate curwin->w_virtcol only.\n */\n    void\nvalidate_virtcol(void)\n{\n    validate_virtcol_win(curwin);\n}\n\n/*\n * Validate wp->w_virtcol only.\n */\n    void\nvalidate_virtcol_win(win_T *wp)\n{\n    check_cursor_moved(wp);\n\n    if (wp->w_valid & VALID_VIRTCOL)\n\treturn;\n\n#ifdef FEAT_PROP_POPUP\n    wp->w_virtcol_first_char = 0;\n#endif\n    getvvcol(wp, &wp->w_cursor, NULL, &(wp->w_virtcol), NULL);\n#ifdef FEAT_SYN_HL\n    redraw_for_cursorcolumn(wp);\n#endif\n    wp->w_valid |= VALID_VIRTCOL;\n}\n\n/*\n * Validate curwin->w_cline_height only.\n */\n    void\nvalidate_cheight(void)\n{\n    check_cursor_moved(curwin);\n\n    if (curwin->w_valid & VALID_CHEIGHT)\n\treturn;\n\n#ifdef FEAT_DIFF\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_cline_height = plines_nofill(curwin->w_cursor.lnum)\n\t    + curwin->w_topfill;\n    else\n#endif\n\tcurwin->w_cline_height = plines(curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n    curwin->w_cline_folded = hasFolding(curwin->w_cursor.lnum, NULL, NULL);\n#endif\n    curwin->w_valid |= VALID_CHEIGHT;\n}\n\n/*\n * Validate w_wcol and w_virtcol only.\n */\n    void\nvalidate_cursor_col(void)\n{\n    colnr_T off;\n    colnr_T col;\n    int     width;\n\n    validate_virtcol();\n\n    if (curwin->w_valid & VALID_WCOL)\n\treturn;\n\n    col = curwin->w_virtcol;\n    off = curwin_col_off();\n    col += off;\n    width = curwin->w_width - off + curwin_col_off2();\n\n    // long line wrapping, adjust curwin->w_wrow\n    if (curwin->w_p_wrap\n\t    && col >= (colnr_T)curwin->w_width\n\t    && width > 0)\n\t// use same formula as what is used in curs_columns()\n\tcol -= ((col - curwin->w_width) / width + 1) * width;\n    if (col > (int)curwin->w_leftcol)\n\tcol -= curwin->w_leftcol;\n    else\n\tcol = 0;\n    curwin->w_wcol = col;\n\n    curwin->w_valid |= VALID_WCOL;\n#ifdef FEAT_PROP_POPUP\n    curwin->w_flags &= ~WFLAG_WCOL_OFF_ADDED;\n#endif\n}\n\n/*\n * Compute offset of a window, occupied by absolute or relative line number,\n * fold column and sign column (these don't move when scrolling horizontally).\n */\n    int\nwin_col_off(win_T *wp)\n{\n    return (((wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) + 1 : 0)\n\t    + (cmdwin_type == 0 || wp != curwin ? 0 : 1)\n#ifdef FEAT_FOLDING\n\t    + wp->w_p_fdc\n#endif\n#ifdef FEAT_SIGNS\n\t    + (signcolumn_on(wp) ? 2 : 0)\n#endif\n\t   );\n}\n\n    int\ncurwin_col_off(void)\n{\n    return win_col_off(curwin);\n}\n\n/*\n * Return the difference in column offset for the second screen line of a\n * wrapped line.  It's positive if 'number' or 'relativenumber' is on and 'n'\n * is in 'cpoptions'.\n */\n    int\nwin_col_off2(win_T *wp)\n{\n    if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)\n\treturn number_width(wp) + 1;\n    return 0;\n}\n\n    int\ncurwin_col_off2(void)\n{\n    return win_col_off2(curwin);\n}\n\n/*\n * Compute curwin->w_wcol and curwin->w_virtcol.\n * Also updates curwin->w_wrow and curwin->w_cline_row.\n * Also updates curwin->w_leftcol.\n */\n    void\ncurs_columns(\n    int\t\tmay_scroll)\t// when TRUE, may scroll horizontally\n{\n    int\t\tdiff;\n    int\t\textra;\t\t// offset for first screen line\n    int\t\toff_left, off_right;\n    int\t\tn;\n    int\t\tp_lines;\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2 = 0;\t// text width for second and later screen line\n    int\t\tnew_leftcol;\n    colnr_T\tstartcol;\n    colnr_T\tendcol;\n    colnr_T\tprev_skipcol;\n    long\tso = get_scrolloff_value();\n    long\tsiso = get_sidescrolloff_value();\n    int\t\tdid_sub_skipcol = FALSE;\n\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n\n    /*\n     * Next make sure that w_cline_row is valid.\n     */\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n\n#ifdef FEAT_PROP_POPUP\n    // will be set by getvvcol() but not reset\n    curwin->w_virtcol_first_char = 0;\n#endif\n\n    /*\n     * Compute the number of virtual columns.\n     */\n#ifdef FEAT_FOLDING\n    if (curwin->w_cline_folded)\n\t// In a folded line the cursor is always in the first column\n\tstartcol = curwin->w_virtcol = endcol = curwin->w_leftcol;\n    else\n#endif\n\tgetvvcol(curwin, &curwin->w_cursor,\n\t\t\t\t&startcol, &(curwin->w_virtcol), &endcol);\n\n    // remove '$' from change command when cursor moves onto it\n    if (startcol > dollar_vcol)\n\tdollar_vcol = -1;\n\n    extra = curwin_col_off();\n    curwin->w_wcol = curwin->w_virtcol + extra;\n    endcol += extra;\n\n    /*\n     * Now compute w_wrow, counting screen lines from w_cline_row.\n     */\n    curwin->w_wrow = curwin->w_cline_row;\n\n    width1 = curwin->w_width - extra;\n    if (width1 <= 0)\n    {\n\t// No room for text, put cursor in last char of window.\n\t// If not wrapping, the last non-empty line.\n\tcurwin->w_wcol = curwin->w_width - 1;\n\tif (curwin->w_p_wrap)\n\t    curwin->w_wrow = curwin->w_height - 1;\n\telse\n\t    curwin->w_wrow = curwin->w_height - 1 - curwin->w_empty_rows;\n    }\n    else if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\twidth2 = width1 + curwin_col_off2();\n\n\t// skip columns that are not visible\n\tif (curwin->w_cursor.lnum == curwin->w_topline\n\t\t&& curwin->w_skipcol > 0\n\t\t&& curwin->w_wcol >= curwin->w_skipcol)\n\t{\n\t    // Deduct by multiples of width2.  This allows the long line\n\t    // wrapping formula below to correctly calculate the w_wcol value\n\t    // when wrapping.\n\t    if (curwin->w_skipcol <= width1)\n\t\tcurwin->w_wcol -= width2;\n\t    else\n\t\tcurwin->w_wcol -= width2\n\t\t\t       * (((curwin->w_skipcol - width1) / width2) + 1);\n\n\t    did_sub_skipcol = TRUE;\n\t}\n\n\t// long line wrapping, adjust curwin->w_wrow\n\tif (curwin->w_wcol >= curwin->w_width)\n\t{\n\t    // this same formula is used in validate_cursor_col()\n\t    n = (curwin->w_wcol - curwin->w_width) / width2 + 1;\n\t    curwin->w_wcol -= n * width2;\n\t    curwin->w_wrow += n;\n\n#ifdef FEAT_LINEBREAK\n\t    // When cursor wraps to first char of next line in Insert\n\t    // mode, the 'showbreak' string isn't shown, backup to first\n\t    // column\n\t    char_u *sbr = get_showbreak_value(curwin);\n\t    if (*sbr && *ml_get_cursor() == NUL\n\t\t\t\t    && curwin->w_wcol == vim_strsize(sbr))\n\t\tcurwin->w_wcol = 0;\n#endif\n\t}\n    }\n\n    // No line wrapping: compute curwin->w_leftcol if scrolling is on and line\n    // is not folded.\n    // If scrolling is off, curwin->w_leftcol is assumed to be 0\n    else if (may_scroll\n#ifdef FEAT_FOLDING\n\t    && !curwin->w_cline_folded\n#endif\n\t    )\n    {\n#ifdef FEAT_PROP_POPUP\n\tif (curwin->w_virtcol_first_char > 0)\n\t{\n\t    int cols = (curwin->w_width - extra);\n\t    int rows = cols > 0 ? curwin->w_virtcol_first_char / cols : 1;\n\n\t    // each \"above\" text prop shifts the text one row down\n\t    curwin->w_wrow += rows;\n\t    curwin->w_wcol -= rows * cols;\n\t    endcol -= rows * cols;\n\t    curwin->w_cline_height = rows + 1;\n\t}\n#endif\n\t/*\n\t * If Cursor is left of the screen, scroll rightwards.\n\t * If Cursor is right of the screen, scroll leftwards\n\t * If we get closer to the edge than 'sidescrolloff', scroll a little\n\t * extra\n\t */\n\toff_left = (int)startcol - (int)curwin->w_leftcol - siso;\n\toff_right = (int)endcol - (int)(curwin->w_leftcol + curwin->w_width\n\t\t\t\t\t\t\t\t- siso) + 1;\n\tif (off_left < 0 || off_right > 0)\n\t{\n\t    if (off_left < 0)\n\t\tdiff = -off_left;\n\t    else\n\t\tdiff = off_right;\n\n\t    // When far off or not enough room on either side, put cursor in\n\t    // middle of window.\n\t    if (p_ss == 0 || diff >= width1 / 2 || off_right >= off_left)\n\t\tnew_leftcol = curwin->w_wcol - extra - width1 / 2;\n\t    else\n\t    {\n\t\tif (diff < p_ss)\n\t\t    diff = p_ss;\n\t\tif (off_left < 0)\n\t\t    new_leftcol = curwin->w_leftcol - diff;\n\t\telse\n\t\t    new_leftcol = curwin->w_leftcol + diff;\n\t    }\n\t    if (new_leftcol < 0)\n\t\tnew_leftcol = 0;\n\t    if (new_leftcol != (int)curwin->w_leftcol)\n\t    {\n\t\tcurwin->w_leftcol = new_leftcol;\n\t\t// screen has to be redrawn with new curwin->w_leftcol\n\t\tredraw_later(UPD_NOT_VALID);\n\t    }\n\t}\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    }\n    else if (curwin->w_wcol > (int)curwin->w_leftcol)\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    else\n\tcurwin->w_wcol = 0;\n\n#ifdef FEAT_DIFF\n    // Skip over filler lines.  At the top use w_topfill, there\n    // may be some filler lines above the window.\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_wrow += curwin->w_topfill;\n    else\n\tcurwin->w_wrow += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    prev_skipcol = curwin->w_skipcol;\n\n    p_lines = 0;\n\n    if ((curwin->w_wrow >= curwin->w_height\n\t\t|| ((prev_skipcol > 0\n\t\t\t|| curwin->w_wrow + so >= curwin->w_height)\n\t\t    && (p_lines =\n#ifdef FEAT_DIFF\n\t\t\tplines_win_nofill\n#else\n\t\t\tplines_win\n#endif\n\t\t\t(curwin, curwin->w_cursor.lnum, FALSE))\n\t\t\t\t\t\t    - 1 >= curwin->w_height))\n\t    && curwin->w_height != 0\n\t    && curwin->w_cursor.lnum == curwin->w_topline\n\t    && width2 > 0\n\t    && curwin->w_width != 0)\n    {\n\t// Cursor past end of screen.  Happens with a single line that does\n\t// not fit on screen.  Find a skipcol to show the text around the\n\t// cursor.  Avoid scrolling all the time. compute value of \"extra\":\n\t// 1: Less than 'scrolloff' lines above\n\t// 2: Less than 'scrolloff' lines below\n\t// 3: both of them\n\textra = 0;\n\tif (curwin->w_skipcol + so * width2 > curwin->w_virtcol)\n\t    extra = 1;\n\t// Compute last display line of the buffer line that we want at the\n\t// bottom of the window.\n\tif (p_lines == 0)\n\t    p_lines = plines_win(curwin, curwin->w_cursor.lnum, FALSE);\n\t--p_lines;\n\tif (p_lines > curwin->w_wrow + so)\n\t    n = curwin->w_wrow + so;\n\telse\n\t    n = p_lines;\n\tif ((colnr_T)n >= curwin->w_height + curwin->w_skipcol / width2 - so)\n\t    extra += 2;\n\n\tif (extra == 3 || curwin->w_height <= so * 2)\n\t{\n\t    // not enough room for 'scrolloff', put cursor in the middle\n\t    n = curwin->w_virtcol / width2;\n\t    if (n > curwin->w_height / 2)\n\t\tn -= curwin->w_height / 2;\n\t    else\n\t\tn = 0;\n\t    // don't skip more than necessary\n\t    if (n > p_lines - curwin->w_height + 1)\n\t\tn = p_lines - curwin->w_height + 1;\n\t    curwin->w_skipcol = n * width2;\n\t}\n\telse if (extra == 1)\n\t{\n\t    // less than 'scrolloff' lines above, decrease skipcol\n\t    extra = (curwin->w_skipcol + so * width2 - curwin->w_virtcol\n\t\t\t\t     + width2 - 1) / width2;\n\t    if (extra > 0)\n\t    {\n\t\tif ((colnr_T)(extra * width2) > curwin->w_skipcol)\n\t\t    extra = curwin->w_skipcol / width2;\n\t\tcurwin->w_skipcol -= extra * width2;\n\t    }\n\t}\n\telse if (extra == 2)\n\t{\n\t    // less than 'scrolloff' lines below, increase skipcol\n\t    endcol = (n - curwin->w_height + 1) * width2;\n\t    while (endcol > curwin->w_virtcol)\n\t\tendcol -= width2;\n\t    if (endcol > curwin->w_skipcol)\n\t\tcurwin->w_skipcol = endcol;\n\t}\n\n\t// adjust w_wrow for the changed w_skipcol\n\tif (did_sub_skipcol)\n\t    curwin->w_wrow -= (curwin->w_skipcol - prev_skipcol) / width2;\n\telse\n\t    curwin->w_wrow -= curwin->w_skipcol / width2;\n\n\tif (curwin->w_wrow >= curwin->w_height)\n\t{\n\t    // small window, make sure cursor is in it\n\t    extra = curwin->w_wrow - curwin->w_height + 1;\n\t    curwin->w_skipcol += extra * width2;\n\t    curwin->w_wrow -= extra;\n\t}\n\n\textra = ((int)prev_skipcol - (int)curwin->w_skipcol) / width2;\n\tif (extra > 0)\n\t    win_ins_lines(curwin, 0, extra, FALSE, FALSE);\n\telse if (extra < 0)\n\t    win_del_lines(curwin, 0, -extra, FALSE, FALSE, 0);\n    }\n    else if (!curwin->w_p_sms)\n\tcurwin->w_skipcol = 0;\n    if (prev_skipcol != curwin->w_skipcol)\n\tredraw_later(UPD_SOME_VALID);\n\n#ifdef FEAT_SYN_HL\n    redraw_for_cursorcolumn(curwin);\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\n    if (popup_is_popup(curwin) && curbuf->b_term != NULL)\n    {\n\tcurwin->w_wrow += popup_top_extra(curwin);\n\tcurwin->w_wcol += popup_left_extra(curwin);\n\tcurwin->w_flags |= WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED;\n    }\n    else\n\tcurwin->w_flags &= ~(WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED);\n#endif\n\n    // now w_leftcol and w_skipcol are valid, avoid check_cursor_moved()\n    // thinking otherwise\n    curwin->w_valid_leftcol = curwin->w_leftcol;\n    curwin->w_valid_skipcol = curwin->w_skipcol;\n\n    curwin->w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;\n}\n\n#if (defined(FEAT_EVAL) || defined(FEAT_PROP_POPUP)) || defined(PROTO)\n/*\n * Compute the screen position of text character at \"pos\" in window \"wp\"\n * The resulting values are one-based, zero when character is not visible.\n */\n    void\ntextpos2screenpos(\n\twin_T\t*wp,\n\tpos_T\t*pos,\n\tint\t*rowp,\t// screen row\n\tint\t*scolp,\t// start screen column\n\tint\t*ccolp,\t// cursor screen column\n\tint\t*ecolp)\t// end screen column\n{\n    colnr_T\tscol = 0, ccol = 0, ecol = 0;\n    int\t\trow = 0;\n    int\t\trowoff = 0;\n    colnr_T\tcoloff = 0;\n\n    if (pos->lnum >= wp->w_topline && pos->lnum <= wp->w_botline)\n    {\n\tcolnr_T\t    col;\n\tint\t    width;\n\tlinenr_T    lnum = pos->lnum;\n#ifdef FEAT_FOLDING\n\tint\t    is_folded;\n\n\tis_folded = hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n\trow = plines_m_win(wp, wp->w_topline, lnum - 1) + 1;\n\n#ifdef FEAT_DIFF\n\t// Add filler lines above this buffer line.\n\trow += diff_check_fill(wp, lnum);\n#endif\n\n\tcolnr_T\toff = win_col_off(wp);\n#ifdef FEAT_FOLDING\n\tif (is_folded)\n\t{\n\t    row += W_WINROW(wp);\n\t    coloff = wp->w_wincol + 1 + off;\n\t}\n\telse\n#endif\n\t{\n\t    getvcol(wp, pos, &scol, &ccol, &ecol);\n\n\t    // similar to what is done in validate_cursor_col()\n\t    col = scol;\n\t    col += off;\n\t    width = wp->w_width - off + win_col_off2(wp);\n\n\t    // long line wrapping, adjust row\n\t    if (wp->w_p_wrap\n\t\t    && col >= (colnr_T)wp->w_width\n\t\t    && width > 0)\n\t    {\n\t\t// use same formula as what is used in curs_columns()\n\t\trowoff = ((col - wp->w_width) / width + 1);\n\t\tcol -= rowoff * width;\n\t    }\n\t    col -= wp->w_leftcol;\n\t    if (col >= wp->w_width)\n\t\tcol = -1;\n\t    if (col >= 0 && row + rowoff <= wp->w_height)\n\t    {\n\t\tcoloff = col - scol + wp->w_wincol + 1;\n\t\trow += W_WINROW(wp);\n\t    }\n\t    else\n\t\t// character is left, right or below of the window\n\t\trow = rowoff = scol = ccol = ecol = 0;\n\t}\n    }\n    *rowp = row + rowoff;\n    *scolp = scol + coloff;\n    *ccolp = ccol + coloff;\n    *ecolp = ecol + coloff;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"screenpos({winid}, {lnum}, {col})\" function\n */\n    void\nf_screenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    dict_T\t*dict;\n    win_T\t*wp;\n    pos_T\tpos;\n    int\t\trow = 0;\n    int\t\tscol = 0, ccol = 0, ecol = 0;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n    dict = rettv->vval.v_dict;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    pos.lnum = tv_get_number(&argvars[1]);\n    if (pos.lnum > wp->w_buffer->b_ml.ml_line_count)\n    {\n\tsemsg(_(e_invalid_line_number_nr), pos.lnum);\n\treturn;\n    }\n    pos.col = tv_get_number(&argvars[2]) - 1;\n    pos.coladd = 0;\n    textpos2screenpos(wp, &pos, &row, &scol, &ccol, &ecol);\n\n    dict_add_number(dict, \"row\", row);\n    dict_add_number(dict, \"col\", scol);\n    dict_add_number(dict, \"curscol\", ccol);\n    dict_add_number(dict, \"endcol\", ecol);\n}\n\n/*\n * \"virtcol2col({winid}, {lnum}, {col})\" function\n */\n    void\nf_virtcol2col(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    win_T\t*wp;\n    linenr_T\tlnum;\n    int\t\tscreencol;\n    int\t\terror = FALSE;\n\n    rettv->vval.v_number = -1;\n\n    if (check_for_number_arg(argvars, 0) == FAIL\n\t    || check_for_number_arg(argvars, 1) == FAIL\n\t    || check_for_number_arg(argvars, 2) == FAIL)\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    lnum = tv_get_number_chk(&argvars[1], &error);\n    if (error || lnum < 0 || lnum > wp->w_buffer->b_ml.ml_line_count)\n\treturn;\n\n    screencol = tv_get_number_chk(&argvars[2], &error);\n    if (error || screencol < 0)\n\treturn;\n\n    rettv->vval.v_number = vcol2col(wp, lnum, screencol);\n}\n#endif\n\n/*\n * Scroll the current window down by \"line_count\" logical lines.  \"CTRL-Y\"\n */\n    void\nscrolldown(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n    long\tdone = 0;\t// total # of physical lines done\n    int\t\twrow;\n    int\t\tmoved = FALSE;\n    int\t\tdo_sms = curwin->w_p_wrap && curwin->w_p_sms;\n    int\t\twidth1 = 0;\n    int\t\twidth2 = 0;\n\n    if (do_sms)\n    {\n\twidth1 = curwin->w_width - curwin_col_off();\n\twidth2 = width1 + curwin_col_off2();\n    }\n\n#ifdef FEAT_FOLDING\n    linenr_T\tfirst;\n\n    // Make sure w_topline is at the first of a sequence of folded lines.\n    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    validate_cursor();\t\t// w_wrow needs to be valid\n    for (int todo = line_count; todo > 0; --todo)\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill < diff_check(curwin, curwin->w_topline)\n\t\t&& curwin->w_topfill < curwin->w_height - 1)\n\t{\n\t    ++curwin->w_topfill;\n\t    ++done;\n\t}\n\telse\n#endif\n\t{\n\t    // break when at the very top\n\t    if (curwin->w_topline == 1\n\t\t\t\t   && (!do_sms || curwin->w_skipcol < width1))\n\t\tbreak;\n\t    if (do_sms && curwin->w_skipcol >= width1)\n\t    {\n\t\t// scroll a screen line down\n\t\tif (curwin->w_skipcol >= width1 + width2)\n\t\t    curwin->w_skipcol -= width2;\n\t\telse\n\t\t    curwin->w_skipcol -= width1;\n\t\tredraw_later(UPD_NOT_VALID);\n\t\t++done;\n\t    }\n\t    else\n\t    {\n\t\t// scroll a text line down\n\t\t--curwin->w_topline;\n\t\tcurwin->w_skipcol = 0;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n#ifdef FEAT_FOLDING\n\t\t// A sequence of folded lines only counts for one logical line\n\t\tif (hasFolding(curwin->w_topline, &first, NULL))\n\t\t{\n\t\t    ++done;\n\t\t    if (!byfold)\n\t\t\ttodo -= curwin->w_topline - first - 1;\n\t\t    curwin->w_botline -= curwin->w_topline - first;\n\t\t    curwin->w_topline = first;\n\t\t}\n\t\telse\n#endif\n\t\tif (do_sms)\n\t\t{\n\t\t    int size = win_linetabsize(curwin, curwin->w_topline,\n\t\t\t\t   ml_get(curwin->w_topline), (colnr_T)MAXCOL);\n\t\t    if (size > width1)\n\t\t    {\n\t\t\tcurwin->w_skipcol = width1;\n\t\t\tsize -= width1;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t    while (size > width2)\n\t\t    {\n\t\t\tcurwin->w_skipcol += width2;\n\t\t\tsize -= width2;\n\t\t    }\n\t\t    ++done;\n\t\t}\n\t\telse\n\t\t    done += PLINES_NOFILL(curwin->w_topline);\n\t    }\n\t}\n\t--curwin->w_botline;\t\t// approximate w_botline\n\tinvalidate_botline();\n    }\n    curwin->w_wrow += done;\t\t// keep w_wrow updated\n    curwin->w_cline_row += done;\t// keep w_cline_row updated\n\n#ifdef FEAT_DIFF\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_cline_row = 0;\n    check_topfill(curwin, TRUE);\n#endif\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and move the cursor onto the displayed part of the window.\n     */\n    wrow = curwin->w_wrow;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tvalidate_cheight();\n\twrow += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    while (wrow >= curwin->w_height && curwin->w_cursor.lnum > 1)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(curwin->w_cursor.lnum, &first, NULL))\n\t{\n\t    --wrow;\n\t    if (first == 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n\t\tcurwin->w_cursor.lnum = first - 1;\n\t}\n\telse\n#endif\n\t    wrow -= plines(curwin->w_cursor.lnum--);\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tmoved = TRUE;\n    }\n    if (moved)\n    {\n#ifdef FEAT_FOLDING\n\t// Move cursor to first line of closed fold.\n\tfoldAdjustCursor();\n#endif\n\tcoladvance(curwin->w_curswant);\n    }\n\n    if (curwin->w_cursor.lnum == curwin->w_topline && do_sms)\n    {\n\tlong\tso = get_scrolloff_value();\n\tint\tscrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n\n\t// make sure the cursor is in the visible text\n\tvalidate_virtcol();\n\tint col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;\n\tint row = 0;\n\tif (col >= width1)\n\t{\n\t    col -= width1;\n\t    ++row;\n\t}\n\tif (col > width2 && width2 > 0)\n\t{\n\t    row += col / width2;\n\t    col = col % width2;\n\t}\n\tif (row >= curwin->w_height)\n\t{\n\t    curwin->w_curswant = curwin->w_virtcol\n\t\t\t\t       - (row - curwin->w_height + 1) * width2;\n\t    coladvance(curwin->w_curswant);\n\t}\n    }\n}\n\n/*\n * Return TRUE if scrollup() will scroll by screen line rather than text line.\n */\n    static int\nscrolling_screenlines(int byfold UNUSED)\n{\n    return (curwin->w_p_wrap && curwin->w_p_sms)\n# ifdef FEAT_FOLDING\n\t|| (byfold && hasAnyFolding(curwin))\n# endif\n# ifdef FEAT_DIFF\n\t|| curwin->w_p_diff\n# endif\n\t;\n}\n\n/*\n * Scroll the current window up by \"line_count\" logical lines.  \"CTRL-E\"\n */\n    void\nscrollup(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n    int\t\tdo_sms = curwin->w_p_wrap && curwin->w_p_sms;\n\n    if (scrolling_screenlines(byfold))\n    {\n\tint\t    width1 = curwin->w_width - curwin_col_off();\n\tint\t    width2 = width1 + curwin_col_off2();\n\tint\t    size = 0;\n\tlinenr_T    prev_topline = curwin->w_topline;\n\n\tif (do_sms)\n\t    size = linetabsize(curwin, curwin->w_topline);\n\n\t// diff mode: first consume \"topfill\"\n\t// 'smoothscroll': increase \"w_skipcol\" until it goes over the end of\n\t// the line, then advance to the next line.\n\t// folding: count each sequence of folded lines as one logical line.\n\tfor (int todo = line_count; todo > 0; --todo)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t\t--curwin->w_topfill;\n\t    else\n# endif\n\t    {\n\t\tlinenr_T lnum = curwin->w_topline;\n\n# ifdef FEAT_FOLDING\n\t\tif (byfold)\n\t\t    // for a closed fold: go to the last line in the fold\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n# endif\n\t\tif (lnum == curwin->w_topline && do_sms)\n\t\t{\n\t\t    // 'smoothscroll': increase \"w_skipcol\" until it goes over\n\t\t    // the end of the line, then advance to the next line.\n\t\t    int add = curwin->w_skipcol > 0 ? width2 : width1;\n\t\t    curwin->w_skipcol += add;\n\t\t    if (curwin->w_skipcol >= size)\n\t\t    {\n\t\t\tif (lnum == curbuf->b_ml.ml_line_count)\n\t\t\t{\n\t\t\t    // at the last screen line, can't scroll further\n\t\t\t    curwin->w_skipcol -= add;\n\t\t\t    break;\n\t\t\t}\n\t\t\t++lnum;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tbreak;\n\t\t    ++lnum;\n\t\t}\n\n\t\tif (lnum > curwin->w_topline)\n\t\t{\n\t\t    // approximate w_botline\n\t\t    curwin->w_botline += lnum - curwin->w_topline;\n\t\t    curwin->w_topline = lnum;\n# ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = diff_check_fill(curwin, lnum);\n# endif\n\t\t    curwin->w_skipcol = 0;\n\t\t    if (todo > 1 && do_sms)\n\t\t\tsize = linetabsize(curwin, curwin->w_topline);\n\t\t}\n\t    }\n\t}\n\n\tif (curwin->w_topline == prev_topline)\n\t    // need to redraw even though w_topline didn't change\n\t    redraw_later(UPD_NOT_VALID);\n    }\n    else\n    {\n\tcurwin->w_topline += line_count;\n\tcurwin->w_botline += line_count;\t// approximate w_botline\n    }\n\n    if (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n    if (curwin->w_botline > curbuf->b_ml.ml_line_count + 1)\n\tcurwin->w_botline = curbuf->b_ml.ml_line_count + 1;\n\n#ifdef FEAT_DIFF\n    check_topfill(curwin, FALSE);\n#endif\n\n#ifdef FEAT_FOLDING\n    if (hasAnyFolding(curwin))\n\t// Make sure w_topline is at the first of a sequence of folded lines.\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n    {\n\tcurwin->w_cursor.lnum = curwin->w_topline;\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tcoladvance(curwin->w_curswant);\n    }\n    if (curwin->w_cursor.lnum == curwin->w_topline\n\t\t\t\t\t    && do_sms && curwin->w_skipcol > 0)\n    {\n\tint\tcol_off = curwin_col_off();\n\tint\tcol_off2 = curwin_col_off2();\n\n\tint\twidth1 = curwin->w_width - col_off;\n\tint\twidth2 = width1 + col_off2;\n\tint\textra2 = col_off - col_off2;\n\tlong\tso = get_scrolloff_value();\n\tint\tscrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n\tint\tspace_cols = (curwin->w_height - 1) * width2;\n\n\t// If we have non-zero scrolloff, just ignore the <<< marker as we are\n\t// going past it anyway.\n\tint smoothscroll_overlap = scrolloff_cols != 0 ? 0 :\n\t\t\t\t\t   smoothscroll_marker_overlap(extra2);\n\n\t// Make sure the cursor is in a visible part of the line, taking\n\t// 'scrolloff' into account, but using screen lines.\n\t// If there are not enough screen lines put the cursor in the middle.\n\tif (scrolloff_cols > space_cols / 2)\n\t    scrolloff_cols = space_cols / 2;\n\tvalidate_virtcol();\n\tif (curwin->w_virtcol < curwin->w_skipcol\n\t\t\t\t       + smoothscroll_overlap + scrolloff_cols)\n\t{\n\t    colnr_T col = curwin->w_virtcol;\n\n\t    if (col < width1)\n\t\tcol += width1;\n\t    while (col < curwin->w_skipcol\n\t\t\t\t       + smoothscroll_overlap + scrolloff_cols)\n\t\tcol += width2;\n\t    curwin->w_curswant = col;\n\t    coladvance(curwin->w_curswant);\n\n\t    // validate_virtcol() marked various things as valid, but after\n\t    // moving the cursor they need to be recomputed\n\t    curwin->w_valid &=\n\t       ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\t}\n    }\n}\n\n/*\n * Called after changing the cursor column: make sure that curwin->w_skipcol is\n * valid for 'smoothscroll'.\n */\n    void\nadjust_skipcol(void)\n{\n    if (!curwin->w_p_wrap\n\t    || !curwin->w_p_sms\n\t    || curwin->w_cursor.lnum != curwin->w_topline)\n\treturn;\n\n    int\t    width1 = curwin->w_width - curwin_col_off();\n    if (width1 <= 0)\n\treturn;  // no text will be displayed\n\n    int\t    width2 = width1 + curwin_col_off2();\n    long    so = get_scrolloff_value();\n    int\t    scrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n    int\t    scrolled = FALSE;\n\n    validate_cheight();\n    if (curwin->w_cline_height == curwin->w_height\n\t    // w_cline_height may be capped at w_height, check there aren't\n\t    // actually more lines.\n\t    && plines_win(curwin, curwin->w_cursor.lnum, FALSE)\n\t\t\t\t\t\t\t   <= curwin->w_height)\n    {\n\t// the line just fits in the window, don't scroll\n\treset_skipcol();\n\treturn;\n    }\n\n    validate_virtcol();\n    while (curwin->w_skipcol > 0\n\t\t && curwin->w_virtcol < curwin->w_skipcol + 3 + scrolloff_cols)\n    {\n\t// scroll a screen line down\n\tif (curwin->w_skipcol >= width1 + width2)\n\t    curwin->w_skipcol -= width2;\n\telse\n\t    curwin->w_skipcol -= width1;\n\tredraw_later(UPD_NOT_VALID);\n\tscrolled = TRUE;\n\tvalidate_virtcol();\n    }\n    if (scrolled)\n\treturn;  // don't scroll in the other direction now\n\n    int col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;\n    int row = 0;\n    if (col >= width1)\n    {\n\tcol -= width1;\n\t++row;\n    }\n    if (col > width2)\n    {\n\trow += col / width2;\n\tcol = col % width2;\n    }\n    if (row >= curwin->w_height)\n    {\n\tif (curwin->w_skipcol == 0)\n\t{\n\t    curwin->w_skipcol += width1;\n\t    --row;\n\t}\n\tif (row >= curwin->w_height)\n\t    curwin->w_skipcol += (row - curwin->w_height) * width2;\n\tredraw_later(UPD_NOT_VALID);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Don't end up with too many filler lines in the window.\n */\n    void\ncheck_topfill(\n    win_T\t*wp,\n    int\t\tdown)\t// when TRUE scroll down when not enough space\n{\n    int\t\tn;\n\n    if (wp->w_topfill <= 0)\n\treturn;\n\n    n = plines_win_nofill(wp, wp->w_topline, TRUE);\n    if (wp->w_topfill + n > wp->w_height)\n    {\n\tif (down && wp->w_topline > 1)\n\t{\n\t    --wp->w_topline;\n\t    wp->w_topfill = 0;\n\t}\n\telse\n\t{\n\t    wp->w_topfill = wp->w_height - n;\n\t    if (wp->w_topfill < 0)\n\t\twp->w_topfill = 0;\n\t}\n    }\n}\n\n/*\n * Use as many filler lines as possible for w_topline.  Make sure w_topline\n * is still visible.\n */\n    static void\nmax_topfill(void)\n{\n    int\t\tn;\n\n    n = plines_nofill(curwin->w_topline);\n    if (n >= curwin->w_height)\n\tcurwin->w_topfill = 0;\n    else\n    {\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill + n > curwin->w_height)\n\t    curwin->w_topfill = curwin->w_height - n;\n    }\n}\n#endif\n\n/*\n * Scroll the screen one line down, but don't do it if it would move the\n * cursor off the screen.\n */\n    void\nscrolldown_clamp(void)\n{\n    int\t\tend_row;\n#ifdef FEAT_DIFF\n    int\t\tcan_fill = (curwin->w_topfill\n\t\t\t\t< diff_check_fill(curwin, curwin->w_topline));\n#endif\n\n    if (curwin->w_topline <= 1\n#ifdef FEAT_DIFF\n\t    && !can_fill\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go past 'scrolloff' lines from the screen end.\n     */\n    end_row = curwin->w_wrow;\n#ifdef FEAT_DIFF\n    if (can_fill)\n\t++end_row;\n    else\n\tend_row += plines_nofill(curwin->w_topline - 1);\n#else\n    end_row += plines(curwin->w_topline - 1);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_cheight();\n\tvalidate_virtcol();\n\tend_row += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    if (end_row < curwin->w_height - get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (can_fill)\n\t{\n\t    ++curwin->w_topfill;\n\t    check_topfill(curwin, TRUE);\n\t}\n\telse\n\t{\n\t    --curwin->w_topline;\n\t    curwin->w_topfill = 0;\n\t}\n#else\n\t--curwin->w_topline;\n#endif\n#ifdef FEAT_FOLDING\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t--curwin->w_botline;\t    // approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Scroll the screen one line up, but don't do it if it would move the cursor\n * off the screen.\n */\n    void\nscrollup_clamp(void)\n{\n    int\t    start_row;\n\n    if (curwin->w_topline == curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t    && curwin->w_topfill == 0\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the first row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go before 'scrolloff' lines from the screen start.\n     */\n#ifdef FEAT_DIFF\n    start_row = curwin->w_wrow - plines_nofill(curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#else\n    start_row = curwin->w_wrow - plines(curwin->w_topline);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tstart_row -= curwin->w_virtcol / curwin->w_width;\n    }\n    if (start_row >= get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill > 0)\n\t    --curwin->w_topfill;\n\telse\n#endif\n\t{\n#ifdef FEAT_FOLDING\n\t    (void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t    ++curwin->w_topline;\n\t}\n\t++curwin->w_botline;\t\t// approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Add one line above \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines above the first one are incredibly high: MAXCOL.\n */\n    static void\ntopline_back_winheight(\n    lineoff_T\t*lp,\n    int\t\twinheight)\t// when TRUE limit to window height\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t--lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum < 1)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, &lp->lnum, NULL))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_WIN_NOFILL(curwin, lp->lnum, winheight);\n    }\n}\n\n    static void\ntopline_back(lineoff_T *lp)\n{\n    topline_back_winheight(lp, TRUE);\n}\n\n\n/*\n * Add one line below \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines below the last one are incredibly high.\n */\n    static void\nbotline_forw(lineoff_T *lp)\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum + 1))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t++lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum > curbuf->b_ml.ml_line_count)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, NULL, &lp->lnum))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_NOFILL(lp->lnum);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Switch from including filler lines below lp->lnum to including filler\n * lines above loff.lnum + 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\nbotline_topline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\t++lp->lnum;\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n    }\n}\n\n/*\n * Switch from including filler lines above lp->lnum to including filler\n * lines below loff.lnum - 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\ntopline_botline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n\t--lp->lnum;\n    }\n}\n#endif\n\n/*\n * Recompute topline to put the cursor at the top of the window.\n * Scroll at least \"min_scroll\" lines.\n * If \"always\" is TRUE, always set topline (for \"zt\").\n */\n    void\nscroll_cursor_top(int min_scroll, int always)\n{\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\tused;\n    int\t\ti;\n    linenr_T\ttop;\t\t// just above displayed lines\n    linenr_T\tbot;\t\t// just below displayed lines\n    linenr_T\told_topline = curwin->w_topline;\n    int\t\told_skipcol = curwin->w_skipcol;\n#ifdef FEAT_DIFF\n    linenr_T\told_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tnew_topline;\n    int\t\toff = get_scrolloff_value();\n\n    if (mouse_dragging > 0)\n\toff = mouse_dragging - 1;\n\n    /*\n     * Decrease topline until:\n     * - it has become 1\n     * - (part of) the cursor line is moved off the screen or\n     * - moved at least 'scrolljump' lines and\n     * - at least 'scrolloff' lines above and below the cursor\n     */\n    validate_cheight();\n    used = curwin->w_cline_height; // includes filler lines above\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n\tscrolled = used;\n\n#ifdef FEAT_FOLDING\n    if (hasFolding(curwin->w_cursor.lnum, &top, &bot))\n    {\n\t--top;\n\t++bot;\n    }\n    else\n#endif\n    {\n\ttop = curwin->w_cursor.lnum - 1;\n\tbot = curwin->w_cursor.lnum + 1;\n    }\n    new_topline = top + 1;\n\n#ifdef FEAT_DIFF\n    // \"used\" already contains the number of filler lines above, don't add it\n    // again.\n    // Hide filler lines above cursor line by adding them to \"extra\".\n    extra += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    /*\n     * Check if the lines from \"top\" to \"bot\" fit in the window.  If they do,\n     * set new_topline and advance \"top\" and \"bot\" to include more lines.\n     */\n    while (top > 0)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(top, &top, NULL))\n\t    // count one logical line for a sequence of folded lines\n\t    i = 1;\n\telse\n#endif\n\t    i = PLINES_NOFILL(top);\n\tif (top < curwin->w_topline)\n\t    scrolled += i;\n\n\t// If scrolling is needed, scroll at least 'sj' lines.\n\tif ((new_topline >= curwin->w_topline || scrolled > min_scroll)\n\t\t&& extra >= off)\n\t    break;\n\n\tused += i;\n\tif (extra + i <= off && bot < curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(bot, NULL, &bot))\n\t\t// count one logical line for a sequence of folded lines\n\t\t++used;\n\t    else\n#endif\n\t\tused += plines(bot);\n\t}\n\tif (used > curwin->w_height)\n\t    break;\n\n\textra += i;\n\tnew_topline = top;\n\t--top;\n\t++bot;\n    }\n\n    /*\n     * If we don't have enough space, put cursor in the middle.\n     * This makes sure we get the same position when using \"k\" and \"j\"\n     * in a small window.\n     */\n    if (used > curwin->w_height)\n\tscroll_cursor_halfway(FALSE, FALSE);\n    else\n    {\n\t/*\n\t * If \"always\" is FALSE, only adjust topline to a lower value, higher\n\t * value may happen with wrapping lines.\n\t */\n\tif (new_topline < curwin->w_topline || always)\n\t    curwin->w_topline = new_topline;\n\tif (curwin->w_topline > curwin->w_cursor.lnum)\n\t    curwin->w_topline = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill > 0 && extra > off)\n\t{\n\t    curwin->w_topfill -= extra - off;\n\t    if (curwin->w_topfill < 0)\n\t\tcurwin->w_topfill = 0;\n\t}\n\tcheck_topfill(curwin, FALSE);\n#endif\n\t// TODO: if the line doesn't fit may optimize w_skipcol\n\tif (curwin->w_topline == curwin->w_cursor.lnum\n\t\t&& curwin->w_skipcol >= curwin->w_cursor.col)\n\t    reset_skipcol();\n\tif (curwin->w_topline != old_topline\n\t\t|| curwin->w_skipcol != old_skipcol\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t)\n\t    curwin->w_valid &=\n\t\t      ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\tcurwin->w_valid |= VALID_TOPLINE;\n    }\n}\n\n/*\n * Set w_empty_rows and w_filler_rows for window \"wp\", having used up \"used\"\n * screen lines for text lines.\n */\n    void\nset_empty_rows(win_T *wp, int used)\n{\n#ifdef FEAT_DIFF\n    wp->w_filler_rows = 0;\n#endif\n    if (used == 0)\n\twp->w_empty_rows = 0;\t// single line that doesn't fit\n    else\n    {\n\twp->w_empty_rows = wp->w_height - used;\n#ifdef FEAT_DIFF\n\tif (wp->w_botline <= wp->w_buffer->b_ml.ml_line_count)\n\t{\n\t    wp->w_filler_rows = diff_check_fill(wp, wp->w_botline);\n\t    if (wp->w_empty_rows > wp->w_filler_rows)\n\t\twp->w_empty_rows -= wp->w_filler_rows;\n\t    else\n\t    {\n\t\twp->w_filler_rows = wp->w_empty_rows;\n\t\twp->w_empty_rows = 0;\n\t    }\n\t}\n#endif\n    }\n}\n\n/*\n * Recompute topline to put the cursor at the bottom of the window.\n * When scrolling scroll at least \"min_scroll\" lines.\n * If \"set_topbot\" is TRUE, set topline and botline first (for \"zb\").\n * This is messy stuff!!!\n */\n    void\nscroll_cursor_bot(int min_scroll, int set_topbot)\n{\n    int\t\tused;\n    int\t\tscrolled = 0;\n    int\t\tmin_scrolled = 1;\n    int\t\textra = 0;\n    int\t\ti;\n    linenr_T\tline_count;\n    linenr_T\told_topline = curwin->w_topline;\n    int\t\told_skipcol = curwin->w_skipcol;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n    int\t\tfill_below_window;\n#endif\n    linenr_T\told_botline = curwin->w_botline;\n    linenr_T\told_valid = curwin->w_valid;\n    int\t\told_empty_rows = curwin->w_empty_rows;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    long\tso = get_scrolloff_value();\n\n    cln = curwin->w_cursor.lnum;\n    if (set_topbot)\n    {\n\tint set_skipcol = FALSE;\n\n\tused = 0;\n\tcurwin->w_botline = cln + 1;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tfor (curwin->w_topline = curwin->w_botline;\n\t\tcurwin->w_topline > 1;\n\t\tcurwin->w_topline = loff.lnum)\n\t{\n\t    loff.lnum = curwin->w_topline;\n\t    topline_back_winheight(&loff, FALSE);\n\t    if (loff.height == MAXCOL)\n\t\tbreak;\n\t    if (used + loff.height > curwin->w_height)\n\t    {\n\t\tif (curwin->w_p_sms && curwin->w_p_wrap)\n\t\t{\n\t\t    // 'smoothscroll' and 'wrap' are set.  The above line is\n\t\t    // too long to show in its entirety, so we show just a part\n\t\t    // of it.\n\t\t    if (used < curwin->w_height)\n\t\t    {\n\t\t\tint plines_offset = used + loff.height\n\t\t\t\t\t\t\t    - curwin->w_height;\n\t\t\tused = curwin->w_height;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = loff.fill;\n#endif\n\t\t\tcurwin->w_topline = loff.lnum;\n\t\t\tcurwin->w_skipcol = skipcol_from_plines(\n\t\t\t\t\t\t\tcurwin, plines_offset);\n\t\t\tset_skipcol = TRUE;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    }\n\t    used += loff.height;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = loff.fill;\n#endif\n\t}\n\tset_empty_rows(curwin, used);\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t|| set_skipcol\n\t\t|| curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    if (set_skipcol)\n\t\tredraw_later(UPD_NOT_VALID);\n\t    else\n\t\treset_skipcol();\n\t}\n    }\n    else\n\tvalidate_botline();\n\n    // The lines of the cursor line itself are always used.\n#ifdef FEAT_DIFF\n    used = plines_nofill(cln);\n#else\n    validate_cheight();\n    used = curwin->w_cline_height;\n#endif\n\n    // If the cursor is on or below botline, we will at least scroll by the\n    // height of the cursor line, which is \"used\".  Correct for empty lines,\n    // which are really part of botline.\n    if (cln >= curwin->w_botline)\n    {\n\tscrolled = used;\n\tif (cln == curwin->w_botline)\n\t    scrolled -= curwin->w_empty_rows;\n\tmin_scrolled = scrolled;\n\tif (curwin->w_p_sms && curwin->w_p_wrap)\n\t{\n\t    // 'smoothscroll' and 'wrap' are set\n\t    if (cln > curwin->w_botline)\n\t\t// add screen lines below w_botline\n\t\tfor (linenr_T lnum = curwin->w_botline + 1; lnum <= cln; ++lnum)\n\t\t    min_scrolled += PLINES_NOFILL(lnum);\n\n\t    // Calculate how many screen lines the current top line of window\n\t    // occupies. If it is occupying more than the entire window, we\n\t    // need to scroll the additional clipped lines to scroll past the\n\t    // top line before we can move on to the other lines.\n\t    int top_plines =\n#ifdef FEAT_DIFF\n\t\t\t    plines_win_nofill\n#else\n\t\t\t    plines_win\n#endif\n\t\t\t\t\t(curwin, curwin->w_topline, FALSE);\n\t    int skip_lines = 0;\n\t    int width1 = curwin->w_width - curwin_col_off();\n\t    int width2 = width1 + curwin_col_off2();\n\t    // similar formula is used in curs_columns()\n\t    if (curwin->w_skipcol > width1)\n\t\tskip_lines += (curwin->w_skipcol - width1) / width2 + 1;\n\t    else if (curwin->w_skipcol > 0)\n\t\tskip_lines = 1;\n\n\t    top_plines -= skip_lines;\n\t    if (top_plines > curwin->w_height)\n\t    {\n\t\tscrolled += (top_plines - curwin->w_height);\n\t\tmin_scrolled += (top_plines - curwin->w_height);\n\t    }\n\t}\n    }\n\n    /*\n     * Stop counting lines to scroll when\n     * - hitting start of the file\n     * - scrolled nothing or at least 'sj' lines\n     * - at least 'scrolloff' lines below the cursor\n     * - lines between botline and cursor have been counted\n     */\n#ifdef FEAT_FOLDING\n    if (!hasFolding(curwin->w_cursor.lnum, &loff.lnum, &boff.lnum))\n#endif\n    {\n\tloff.lnum = cln;\n\tboff.lnum = cln;\n    }\n#ifdef FEAT_DIFF\n    loff.fill = 0;\n    boff.fill = 0;\n    fill_below_window = diff_check_fill(curwin, curwin->w_botline)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\n    while (loff.lnum > 1)\n    {\n\t// Stop when scrolled nothing or at least \"min_scroll\", found \"extra\"\n\t// context for 'scrolloff' and counted all lines below the window.\n\tif ((((scrolled <= 0 || scrolled >= min_scroll)\n\t\t    && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so))\n\t\t    || boff.lnum + 1 > curbuf->b_ml.ml_line_count)\n\t\t&& loff.lnum <= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum < curwin->w_botline\n\t\t    || loff.fill >= fill_below_window)\n#endif\n\t\t)\n\t    break;\n\n\t// Add one line above\n\ttopline_back(&loff);\n\tif (loff.height == MAXCOL)\n\t    used = MAXCOL;\n\telse\n\t    used += loff.height;\n\tif (used > curwin->w_height)\n\t    break;\n\tif (loff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum > curwin->w_botline\n\t\t    || loff.fill <= fill_below_window)\n#endif\n\t\t)\n\t{\n\t    // Count screen lines that are below the window.\n\t    scrolled += loff.height;\n\t    if (loff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && loff.fill == 0\n#endif\n\t\t    )\n\t\tscrolled -= curwin->w_empty_rows;\n\t}\n\n\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    // Add one line below\n\t    botline_forw(&boff);\n\t    used += boff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    if (extra < ( mouse_dragging > 0 ? mouse_dragging - 1 : so)\n\t\t    || scrolled < min_scroll)\n\t    {\n\t\textra += boff.height;\n\t\tif (boff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t|| (boff.lnum + 1 == curwin->w_botline\n\t\t\t    && boff.fill > curwin->w_filler_rows)\n#endif\n\t\t   )\n\t\t{\n\t\t    // Count screen lines that are below the window.\n\t\t    scrolled += boff.height;\n\t\t    if (boff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && boff.fill == 0\n#endif\n\t\t\t    )\n\t\t\tscrolled -= curwin->w_empty_rows;\n\t\t}\n\t    }\n\t}\n    }\n\n    // curwin->w_empty_rows is larger, no need to scroll\n    if (scrolled <= 0)\n\tline_count = 0;\n    // more than a screenfull, don't scroll but redraw\n    else if (used > curwin->w_height)\n\tline_count = used;\n    // scroll minimal number of lines\n    else\n    {\n\tline_count = 0;\n#ifdef FEAT_DIFF\n\tboff.fill = curwin->w_topfill;\n#endif\n\tboff.lnum = curwin->w_topline - 1;\n\tfor (i = 0; i < scrolled && boff.lnum < curwin->w_botline; )\n\t{\n\t    botline_forw(&boff);\n\t    i += boff.height;\n\t    ++line_count;\n\t}\n\tif (i < scrolled)\t// below curwin->w_botline, don't scroll\n\t    line_count = 9999;\n    }\n\n    /*\n     * Scroll up if the cursor is off the bottom of the screen a bit.\n     * Otherwise put it at 1/2 of the screen.\n     */\n    if (line_count >= curwin->w_height && line_count > min_scroll)\n\tscroll_cursor_halfway(FALSE, TRUE);\n    else\n    {\n\t// With 'smoothscroll' scroll at least the height of the cursor line,\n\t// unless it would move the cursor.\n\tif (curwin->w_p_wrap && curwin->w_p_sms && line_count < min_scrolled\n\t\t&& (curwin->w_cursor.lnum < curwin->w_topline\n\t\t    || (curwin->w_virtcol - curwin->w_skipcol >=\n\t\t\t\t\t  curwin->w_width - curwin_col_off())))\n\t    line_count = min_scrolled;\n\tif (line_count > 0)\n\t{\n\t    if (scrolling_screenlines(TRUE))\n\t\tscrollup(scrolled, TRUE);  // TODO\n\t    else\n\t\tscrollup(line_count, TRUE);\n\t}\n    }\n\n    /*\n     * If topline didn't change we need to restore w_botline and w_empty_rows\n     * (we changed them).\n     * If topline did change, update_screen() will set botline.\n     */\n    if (curwin->w_topline == old_topline\n\t    && curwin->w_skipcol == old_skipcol\n\t    && set_topbot)\n    {\n\tcurwin->w_botline = old_botline;\n\tcurwin->w_empty_rows = old_empty_rows;\n\tcurwin->w_valid = old_valid;\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Recompute topline to put the cursor halfway the window\n * If \"atend\" is TRUE, also put it halfway at the end of the file.\n */\n    void\nscroll_cursor_halfway(int atend, int prefer_above)\n{\n    int\t\tabove = 0;\n    linenr_T\ttopline;\n    colnr_T\tskipcol = 0;\n    int\t\tset_skipcol = FALSE;\n#ifdef FEAT_DIFF\n    int\t\ttopfill = 0;\n#endif\n    int\t\tbelow = 0;\n    int\t\tused;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    linenr_T\told_topline = curwin->w_topline;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    // if the width changed this needs to be updated first\n    may_update_popup_position();\n#endif\n    loff.lnum = boff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n    (void)hasFolding(loff.lnum, &loff.lnum, &boff.lnum);\n#endif\n#ifdef FEAT_DIFF\n    used = plines_nofill(loff.lnum);\n    loff.fill = 0;\n    boff.fill = 0;\n#else\n    used = plines(loff.lnum);\n#endif\n    topline = loff.lnum;\n\n    int half_height = 0;\n    int smooth_scroll = FALSE;\n    if (curwin->w_p_sms && curwin->w_p_wrap)\n    {\n\t// 'smoothscroll' and 'wrap' are set\n\tsmooth_scroll = TRUE;\n\thalf_height = (curwin->w_height - used) / 2;\n\tused = 0;\n    }\n\n    while (topline > 1)\n    {\n\t// If using smoothscroll, we can precisely scroll to the\n\t// exact point where the cursor is halfway down the screen.\n\tif (smooth_scroll)\n\t{\n\t    topline_back_winheight(&loff, FALSE);\n\t    if (loff.height == MAXCOL)\n\t\tbreak;\n\t    else\n\t\tused += loff.height;\n\t    if (used > half_height)\n\t    {\n\t\tif (used - loff.height < half_height)\n\t\t{\n\t\t    int plines_offset = used - half_height;\n\t\t    loff.height -= plines_offset;\n\t\t    used = half_height;\n\n\t\t    topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\t    topfill = loff.fill;\n#endif\n\t\t    skipcol = skipcol_from_plines(curwin, plines_offset);\n\t\t    set_skipcol = TRUE;\n\t\t}\n\t\tbreak;\n\t    }\n\t    topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t    topfill = loff.fill;\n#endif\n\t    continue;\n\t}\n\n\t// If not using smoothscroll, we have to iteratively find how many\n\t// lines to scroll down to roughly fit the cursor.\n\t// This may not be right in the middle if the lines'\n\t// physical height > 1 (e.g. 'wrap' is on).\n\n\t// Depending on \"prefer_above\" we add a line above or below first.\n\t// Loop twice to avoid duplicating code.\n\tint done = FALSE;\n\tfor (int round = 1; round <= 2; ++round)\n\t{\n\t    if (prefer_above ? (round == 2 && below < above)\n\t\t\t     : (round == 1 && below <= above))\n\t    {\n\t\t// add a line below the cursor\n\t\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    botline_forw(&boff);\n\t\t    used += boff.height;\n\t\t    if (used > curwin->w_height)\n\t\t    {\n\t\t\tdone = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t    below += boff.height;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++below;\t    // count a \"~\" line\n\t\t    if (atend)\n\t\t\t++used;\n\t\t}\n\t    }\n\n\t    if (prefer_above ? (round == 1 && below >= above)\n\t\t\t     : (round == 1 && below > above))\n\t    {\n\t\t// add a line above the cursor\n\t\ttopline_back(&loff);\n\t\tif (loff.height == MAXCOL)\n\t\t    used = MAXCOL;\n\t\telse\n\t\t    used += loff.height;\n\t\tif (used > curwin->w_height)\n\t\t{\n\t\t    done = TRUE;\n\t\t    break;\n\t\t}\n\t\tabove += loff.height;\n\t\ttopline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\ttopfill = loff.fill;\n#endif\n\t    }\n\t}\n\tif (done)\n\t    break;\n    }\n\n#ifdef FEAT_FOLDING\n    if (!hasFolding(topline, &curwin->w_topline, NULL))\n#endif\n    {\n\tif (curwin->w_topline != topline\n\t\t|| set_skipcol\n\t\t|| curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_topline = topline;\n\t    if (set_skipcol)\n\t    {\n\t\tcurwin->w_skipcol = skipcol;\n\t\tredraw_later(UPD_NOT_VALID);\n\t    }\n\t    else\n\t\treset_skipcol();\n\t}\n    }\n#ifdef FEAT_DIFF\n    curwin->w_topfill = topfill;\n    if (old_topline > curwin->w_topline + curwin->w_height)\n\tcurwin->w_botfill = FALSE;\n    check_topfill(curwin, FALSE);\n#endif\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Correct the cursor position so that it is in a part of the screen at least\n * 'scrolloff' lines from the top and bottom, if possible.\n * If not possible, put it at the same position as scroll_cursor_halfway().\n * When called topline must be valid!\n */\n    void\ncursor_correct(void)\n{\n    int\t\tabove = 0;\t    // screen lines above topline\n    linenr_T\ttopline;\n    int\t\tbelow = 0;\t    // screen lines below botline\n    linenr_T\tbotline;\n    int\t\tabove_wanted, below_wanted;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    int\t\tmax_off;\n    long\tso = get_scrolloff_value();\n\n    /*\n     * How many lines we would like to have above/below the cursor depends on\n     * whether the first/last line of the file is on screen.\n     */\n    above_wanted = so;\n    below_wanted = so;\n    if (mouse_dragging > 0)\n    {\n\tabove_wanted = mouse_dragging - 1;\n\tbelow_wanted = mouse_dragging - 1;\n    }\n    if (curwin->w_topline == 1)\n    {\n\tabove_wanted = 0;\n\tmax_off = curwin->w_height / 2;\n\tif (below_wanted > max_off)\n\t    below_wanted = max_off;\n    }\n    validate_botline();\n    if (curwin->w_botline == curbuf->b_ml.ml_line_count + 1\n\t    && mouse_dragging == 0)\n    {\n\tbelow_wanted = 0;\n\tmax_off = (curwin->w_height - 1) / 2;\n\tif (above_wanted > max_off)\n\t    above_wanted = max_off;\n    }\n\n    /*\n     * If there are sufficient file-lines above and below the cursor, we can\n     * return now.\n     */\n    cln = curwin->w_cursor.lnum;\n    if (cln >= curwin->w_topline + above_wanted\n\t    && cln < curwin->w_botline - below_wanted\n#ifdef FEAT_FOLDING\n\t    && !hasAnyFolding(curwin)\n#endif\n\t    )\n\treturn;\n\n    if (curwin->w_p_sms && !curwin->w_p_wrap)\n    {\n\t// 'smoothscroll is active\n\tif (curwin->w_cline_height == curwin->w_height)\n\t{\n\t    // The cursor line just fits in the window, don't scroll.\n\t    reset_skipcol();\n\t    return;\n\t}\n\t// TODO: If the cursor line doesn't fit in the window then only adjust\n\t// w_skipcol.\n    }\n\n    /*\n     * Narrow down the area where the cursor can be put by taking lines from\n     * the top and the bottom until:\n     * - the desired context lines are found\n     * - the lines from the top is past the lines from the bottom\n     */\n    topline = curwin->w_topline;\n    botline = curwin->w_botline - 1;\n#ifdef FEAT_DIFF\n    // count filler lines as context\n    above = curwin->w_topfill;\n    below = curwin->w_filler_rows;\n#endif\n    while ((above < above_wanted || below < below_wanted) && topline < botline)\n    {\n\tif (below < below_wanted && (below <= above || above >= above_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(botline, &botline, NULL))\n\t\t++below;\n\t    else\n#endif\n\t\tbelow += plines(botline);\n\t    --botline;\n\t}\n\tif (above < above_wanted && (above < below || below >= below_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(topline, NULL, &topline))\n\t\t++above;\n\t    else\n#endif\n\t\tabove += PLINES_NOFILL(topline);\n#ifdef FEAT_DIFF\n\t    // Count filler lines below this line as context.\n\t    if (topline < botline)\n\t\tabove += diff_check_fill(curwin, topline + 1);\n#endif\n\t    ++topline;\n\t}\n    }\n    if (topline == botline || botline == 0)\n\tcurwin->w_cursor.lnum = topline;\n    else if (topline > botline)\n\tcurwin->w_cursor.lnum = botline;\n    else\n    {\n\tif (cln < topline && curwin->w_topline > 1)\n\t{\n\t    curwin->w_cursor.lnum = topline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n\tif (cln > botline && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_cursor.lnum = botline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\nstatic void get_scroll_overlap(lineoff_T *lp, int dir);\n\n/*\n * Move screen \"count\" pages up (\"dir\" is BACKWARD) or down (\"dir\" is FORWARD)\n * and update the screen.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\nonepage(int dir, long count)\n{\n    long\tn;\n    int\t\tretval = OK;\n    lineoff_T\tloff;\n    linenr_T\told_topline = curwin->w_topline;\n    long\tso = get_scrolloff_value();\n\n    if (curbuf->b_ml.ml_line_count == 1)    // nothing to do\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n\n    for ( ; count > 0; --count)\n    {\n\tvalidate_botline();\n\t/*\n\t * It's an error to move a page up when the first line is already on\n\t * the screen.\tIt's an error to move a page down when the last line\n\t * is on the screen and the topline is 'scrolloff' lines from the\n\t * last line.\n\t */\n\tif (dir == FORWARD\n\t\t? ((curwin->w_topline >= curbuf->b_ml.ml_line_count - so)\n\t\t    && curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t: (curwin->w_topline == 1\n#ifdef FEAT_DIFF\n\t\t    && curwin->w_topfill ==\n\t\t\t\t    diff_check_fill(curwin, curwin->w_topline)\n#endif\n\t\t    ))\n\t{\n\t    beep_flush();\n\t    retval = FAIL;\n\t    break;\n\t}\n\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tif (dir == FORWARD)\n\t{\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling\n\t\tif (p_window <= 2)\n\t\t    ++curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline += p_window - 2;\n\t\tif (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t    }\n\t    else if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// at end of file\n\t\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    }\n\t    else\n\t    {\n\t\t// For the overlap, start with the line just below the window\n\t\t// and go upwards.\n\t\tloff.lnum = curwin->w_botline;\n#ifdef FEAT_DIFF\n\t\tloff.fill = diff_check_fill(curwin, loff.lnum)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\t\tget_scroll_overlap(&loff, -1);\n\t\tcurwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = loff.fill;\n\t\tcheck_topfill(curwin, FALSE);\n#endif\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t\tcurwin->w_valid &= ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|\n\t\t\t\t   VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    }\n\t}\n\telse\t// dir == BACKWARDS\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topline == 1)\n\t    {\n\t\t// Include max number of filler lines\n\t\tmax_topfill();\n\t\tcontinue;\n\t    }\n#endif\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling (sort of)\n\t\tif (p_window <= 2)\n\t\t    --curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline -= p_window - 2;\n\t\tif (curwin->w_topline < 1)\n\t\t    curwin->w_topline = 1;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline + p_window - 1;\n\t\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcontinue;\n\t    }\n\n\t    // Find the line at the top of the window that is going to be the\n\t    // line at the bottom of the window.  Make sure this results in\n\t    // the same line as before doing CTRL-F.\n\t    loff.lnum = curwin->w_topline - 1;\n#ifdef FEAT_DIFF\n\t    loff.fill = diff_check_fill(curwin, loff.lnum + 1)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    get_scroll_overlap(&loff, 1);\n\n\t    if (loff.lnum >= curbuf->b_ml.ml_line_count)\n\t    {\n\t\tloff.lnum = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t    }\n\t    else\n\t    {\n\t\tbotline_topline(&loff);\n#endif\n\t    }\n\t    curwin->w_cursor.lnum = loff.lnum;\n\n\t    // Find the line just above the new topline to get the right line\n\t    // at the bottom of the window.\n\t    n = 0;\n\t    while (n <= curwin->w_height && loff.lnum >= 1)\n\t    {\n\t\ttopline_back(&loff);\n\t\tif (loff.height == MAXCOL)\n\t\t    n = MAXCOL;\n\t\telse\n\t\t    n += loff.height;\n\t    }\n\t    if (loff.lnum < 1)\t\t\t// at begin of file\n\t    {\n\t\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\t\tmax_topfill();\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t    }\n\t    else\n\t    {\n\t\t// Go two lines forward again.\n#ifdef FEAT_DIFF\n\t\ttopline_botline(&loff);\n#endif\n\t\tbotline_forw(&loff);\n\t\tbotline_forw(&loff);\n#ifdef FEAT_DIFF\n\t\tbotline_topline(&loff);\n#endif\n#ifdef FEAT_FOLDING\n\t\t// We're at the wrong end of a fold now.\n\t\t(void)hasFolding(loff.lnum, &loff.lnum, NULL);\n#endif\n\n\t\t// Always scroll at least one line.  Avoid getting stuck on\n\t\t// very long lines.\n\t\tif (loff.lnum >= curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum > curwin->w_topline\n\t\t\t    || loff.fill >= curwin->w_topfill)\n#endif\n\t\t\t)\n\t\t{\n#ifdef FEAT_DIFF\n\t\t    // First try using the maximum number of filler lines.  If\n\t\t    // that's not enough, backup one line.\n\t\t    loff.fill = curwin->w_topfill;\n\t\t    if (curwin->w_topfill < diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t\t\tmax_topfill();\n\t\t    if (curwin->w_topfill == loff.fill)\n#endif\n\t\t    {\n\t\t\t--curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = 0;\n#endif\n\t\t    }\n\t\t    comp_botline(curwin);\n\t\t    curwin->w_cursor.lnum = curwin->w_botline - 1;\n\t\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|VALID_CROW);\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = loff.fill;\n\t\t    check_topfill(curwin, FALSE);\n#endif\n\t\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t\t}\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    foldAdjustCursor();\n#endif\n    cursor_correct();\n    check_cursor_col();\n    if (retval == OK)\n\tbeginline(BL_SOL | BL_FIX);\n    curwin->w_valid &= ~(VALID_WCOL|VALID_WROW|VALID_VIRTCOL);\n\n    if (retval == OK && dir == FORWARD)\n    {\n\t// Avoid the screen jumping up and down when 'scrolloff' is non-zero.\n\t// But make sure we scroll at least one line (happens with mix of long\n\t// wrapping lines and non-wrapping line).\n\tif (check_top_offset())\n\t{\n\t    scroll_cursor_top(1, FALSE);\n\t    if (curwin->w_topline <= old_topline\n\t\t\t\t  && old_topline < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_topline = old_topline + 1;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    }\n\t}\n#ifdef FEAT_FOLDING\n\telse if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    }\n\n    redraw_later(UPD_VALID);\n    return retval;\n}\n\n/*\n * Decide how much overlap to use for page-up or page-down scrolling.\n * This is symmetric, so that doing both keeps the same lines displayed.\n * Three lines are examined:\n *\n *  before CTRL-F\t    after CTRL-F / before CTRL-B\n *     etc.\t\t\tl1\n *  l1 last but one line\t------------\n *  l2 last text line\t\tl2 top text line\n *  -------------\t\tl3 second text line\n *  l3\t\t\t\t   etc.\n */\n    static void\nget_scroll_overlap(lineoff_T *lp, int dir)\n{\n    int\t\th1, h2, h3, h4;\n    int\t\tmin_height = curwin->w_height - 2;\n    lineoff_T\tloff0, loff1, loff2;\n\n#ifdef FEAT_DIFF\n    if (lp->fill > 0)\n\tlp->height = 1;\n    else\n\tlp->height = plines_nofill(lp->lnum);\n#else\n    lp->height = plines(lp->lnum);\n#endif\n    h1 = lp->height;\n    if (h1 > min_height)\n\treturn;\t\t// no overlap\n\n    loff0 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h2 = lp->height;\n    if (h2 == MAXCOL || h2 + h1 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff1 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h3 = lp->height;\n    if (h3 == MAXCOL || h3 + h2 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff2 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h4 = lp->height;\n    if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)\n\t*lp = loff1;\t// 1 line overlap\n    else\n\t*lp = loff2;\t// 2 lines overlap\n}\n\n/*\n * Scroll 'scroll' lines up or down.\n */\n    void\nhalfpage(int flag, linenr_T Prenum)\n{\n    long\tscrolled = 0;\n    int\t\ti;\n    int\t\tn;\n    int\t\troom;\n\n    if (Prenum)\n\tcurwin->w_p_scr = (Prenum > curwin->w_height) ?\n\t\t\t\t\t\tcurwin->w_height : Prenum;\n    n = (curwin->w_p_scr <= curwin->w_height) ?\n\t\t\t\t    curwin->w_p_scr : curwin->w_height;\n\n    update_topline();\n    validate_botline();\n    room = curwin->w_empty_rows;\n#ifdef FEAT_DIFF\n    room += curwin->w_filler_rows;\n#endif\n    if (flag)\n    {\n\t/*\n\t * scroll the text up\n\t */\n\twhile (n > 0 && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t--curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t\t++curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n#endif\n\n\t\tif (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_valid &=\n\t\t\t\t    ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t\t}\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW);\n\t    scrolled += i;\n\n\t    /*\n\t     * Correct w_botline for changed w_topline.\n\t     * Won't work when there are filler lines.\n\t     */\n#ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    else\n#endif\n\t    {\n\t\troom += i;\n\t\tdo\n\t\t{\n\t\t    i = plines(curwin->w_botline);\n\t\t    if (i > room)\n\t\t\tbreak;\n#ifdef FEAT_FOLDING\n\t\t    (void)hasFolding(curwin->w_botline, NULL,\n\t\t\t\t\t\t\t  &curwin->w_botline);\n#endif\n\t\t    ++curwin->w_botline;\n\t\t    room -= i;\n\t\t} while (curwin->w_botline <= curbuf->b_ml.ml_line_count);\n\t    }\n\t}\n\n\t/*\n\t * When hit bottom of the file: move cursor down.\n\t */\n\tif (n > 0)\n\t{\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n\t\t    ++curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum += n;\n\t    check_cursor_lnum();\n\t}\n    }\n    else\n    {\n\t/*\n\t * scroll the text down\n\t */\n\twhile (n > 0 && curwin->w_topline > 1)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill < diff_check_fill(curwin, curwin->w_topline))\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t++curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline - 1);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n\t\t--curwin->w_topline;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW|\n\t\t\t\t\t      VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    scrolled += i;\n\t    if (curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--curwin->w_cursor.lnum;\n\t\tcurwin->w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t    }\n\t}\n\n\t/*\n\t * When hit top of the file: move cursor up.\n\t */\n\tif (n > 0)\n\t{\n\t    if (curwin->w_cursor.lnum <= (linenr_T)n)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0 && curwin->w_cursor.lnum > 1)\n\t\t{\n\t\t    --curwin->w_cursor.lnum;\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum -= n;\n\t}\n    }\n# ifdef FEAT_FOLDING\n    // Move cursor to first line of closed fold.\n    foldAdjustCursor();\n# endif\n#ifdef FEAT_DIFF\n    check_topfill(curwin, !flag);\n#endif\n    cursor_correct();\n    beginline(BL_SOL | BL_FIX);\n    redraw_later(UPD_VALID);\n}\n\n    void\ndo_check_cursorbind(void)\n{\n    linenr_T\tline = curwin->w_cursor.lnum;\n    colnr_T\tcol = curwin->w_cursor.col;\n    colnr_T\tcoladd = curwin->w_cursor.coladd;\n    colnr_T\tcurswant = curwin->w_curswant;\n    int\t\tset_curswant = curwin->w_set_curswant;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\trestart_edit_save;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n\n    /*\n     * loop through the cursorbound windows\n     */\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window  and windows with 'noscrollbind'\n\tif (curwin != old_curwin && curwin->w_p_crb)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_cursor.lnum =\n\t\t\t\t diff_get_corresponding_line(old_curbuf, line);\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum = line;\n\t    curwin->w_cursor.col = col;\n\t    curwin->w_cursor.coladd = coladd;\n\t    curwin->w_curswant = curswant;\n\t    curwin->w_set_curswant = set_curswant;\n\n\t    // Make sure the cursor is in a valid position.  Temporarily set\n\t    // \"restart_edit\" to allow the cursor to be beyond the EOL.\n\t    restart_edit_save = restart_edit;\n\t    restart_edit = TRUE;\n\t    check_cursor();\n\n\t    // Avoid a scroll here for the cursor position, 'scrollbind' is\n\t    // more important.\n\t    if (!curwin->w_p_scb)\n\t\tvalidate_cursor();\n\n\t    restart_edit = restart_edit_save;\n\t    // Correct cursor for multi-byte character.\n\t    if (has_mbyte)\n\t\tmb_adjust_cursor();\n\t    redraw_later(UPD_VALID);\n\n\t    // Only scroll when 'scrollbind' hasn't done this.\n\t    if (!curwin->w_p_scb)\n\t\tupdate_topline();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n\n    /*\n     * reset current-window\n     */\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n", "\" Tests for window cmd (:wincmd, :split, :vsplit, :resize and etc...)\n\nsource check.vim\nsource screendump.vim\n\nfunc Test_window_cmd_ls0_with_split()\n  set ls=0\n  set splitbelow\n  split\n  quit\n  call assert_equal(0, &lines - &cmdheight - winheight(0))\n  new | only!\n  \"\n  set splitbelow&vim\n  botright split\n  quit\n  call assert_equal(0, &lines - &cmdheight - winheight(0))\n  new | only!\n  set ls&vim\nendfunc\n\nfunc Test_window_cmd_cmdwin_with_vsp()\n  let efmt = 'Expected 0 but got %d (in ls=%d, %s window)'\n  for v in range(0, 2)\n    exec \"set ls=\" . v\n    vsplit\n    call feedkeys(\"q:\\<CR>\")\n    let ac = &lines - (&cmdheight + winheight(0) + !!v)\n    let emsg = printf(efmt, ac, v, 'left')\n    call assert_equal(0, ac, emsg)\n    wincmd w\n    let ac = &lines - (&cmdheight + winheight(0) + !!v)\n    let emsg = printf(efmt, ac, v, 'right')\n    call assert_equal(0, ac, emsg)\n    new | only!\n  endfor\n  set ls&vim\nendfunc\n\nfunc Test_cmdheight_not_changed()\n  set cmdheight=2\n  set winminheight=0\n  augroup Maximize\n    autocmd WinEnter * wincmd _\n  augroup END\n  split\n  tabnew\n  tabfirst\n  call assert_equal(2, &cmdheight)\n\n  tabonly!\n  only\n  set winminwidth& cmdheight&\n  augroup Maximize\n    au!\n  augroup END\n  augroup! Maximize\nendfunc\n\n\" Test for jumping to windows\nfunc Test_window_jump()\n  new\n  \" jumping to a window with a count greater than the max windows\n  exe \"normal 4\\<C-W>w\"\n  call assert_equal(2, winnr())\n  only\nendfunc\n\nfunc Test_window_cmd_wincmd_gf()\n  let fname = 'test_gf.txt'\n  let swp_fname = '.' . fname . '.swp'\n  call writefile([], fname, 'D')\n  call writefile([], swp_fname, 'D')\n  function s:swap_exists()\n    let v:swapchoice = s:swap_choice\n  endfunc\n  \" Remove the catch-all that runtest.vim adds\n  au! SwapExists\n  augroup test_window_cmd_wincmd_gf\n    autocmd!\n    exec \"autocmd SwapExists \" . fname . \" call s:swap_exists()\"\n  augroup END\n\n  call setline(1, fname)\n  \" (E)dit anyway\n  let s:swap_choice = 'e'\n  wincmd gf\n  call assert_equal(2, tabpagenr())\n  call assert_equal(fname, bufname(\"%\"))\n  quit!\n\n  \" (Q)uit\n  let s:swap_choice = 'q'\n  wincmd gf\n  call assert_equal(1, tabpagenr())\n  call assert_notequal(fname, bufname(\"%\"))\n  new | only!\n\n  augroup! test_window_cmd_wincmd_gf\nendfunc\n\nfunc Test_window_quit()\n  e Xa\n  split Xb\n  call assert_equal(2, '$'->winnr())\n  call assert_equal('Xb', bufname(winbufnr(1)))\n  call assert_equal('Xa', bufname(winbufnr(2)))\n\n  wincmd q\n  call assert_equal(1, winnr('$'))\n  call assert_equal('Xa', bufname(winbufnr(1)))\n\n  bw Xa Xb\nendfunc\n\nfunc Test_window_horizontal_split()\n  call assert_equal(1, winnr('$'))\n  3wincmd s\n  call assert_equal(2, winnr('$'))\n  call assert_equal(3, winheight(0))\n  call assert_equal(winwidth(1), 2->winwidth())\n\n  call assert_fails('botright topleft wincmd s', 'E442:')\n  bw\nendfunc\n\nfunc Test_window_vertical_split()\n  call assert_equal(1, winnr('$'))\n  3wincmd v\n  call assert_equal(2, winnr('$'))\n  call assert_equal(3, winwidth(0))\n  call assert_equal(winheight(1), winheight(2))\n\n  call assert_fails('botright topleft wincmd v', 'E442:')\n  bw\nendfunc\n\n\" Test the \":wincmd ^\" and \"<C-W>^\" commands.\nfunc Test_window_split_edit_alternate()\n  \" Test for failure when the alternate buffer/file no longer exists.\n  edit Xfoo | %bw\n  call assert_fails(':wincmd ^', 'E23:')\n\n  \" Test for the expected behavior when we have two named buffers.\n  edit Xfoo | edit Xbar\n  wincmd ^\n  call assert_equal('Xfoo', bufname(winbufnr(1)))\n  call assert_equal('Xbar', bufname(winbufnr(2)))\n  only\n\n  \" Test for the expected behavior when the alternate buffer is not named.\n  enew | let l:nr1 = bufnr('%')\n  edit Xfoo | let l:nr2 = bufnr('%')\n  wincmd ^\n  call assert_equal(l:nr1, winbufnr(1))\n  call assert_equal(l:nr2, winbufnr(2))\n  only\n\n  \" FIXME: this currently fails on AppVeyor, but passes locally\n  if !has('win32')\n    \" Test the Normal mode command.\n    call feedkeys(\"\\<C-W>\\<C-^>\", 'tx')\n    call assert_equal(l:nr2, winbufnr(1))\n    call assert_equal(l:nr1, winbufnr(2))\n  endif\n\n  %bw!\nendfunc\n\n\" Test the \":[count]wincmd ^\" and \"[count]<C-W>^\" commands.\nfunc Test_window_split_edit_bufnr()\n  %bwipeout\n  let l:nr = bufnr('%') + 1\n  call assert_fails(':execute \"normal! ' . l:nr . '\\<C-W>\\<C-^>\"', 'E92:')\n  call assert_fails(':' . l:nr . 'wincmd ^', 'E16:')\n  call assert_fails(':0wincmd ^', 'E16:')\n\n  edit Xfoo | edit Xbar | edit Xbaz\n  let l:foo_nr = bufnr('Xfoo')\n  let l:bar_nr = bufnr('Xbar')\n  let l:baz_nr = bufnr('Xbaz')\n\n  \" FIXME: this currently fails on AppVeyor, but passes locally\n  if !has('win32')\n    call feedkeys(l:foo_nr . \"\\<C-W>\\<C-^>\", 'tx')\n    call assert_equal('Xfoo', bufname(winbufnr(1)))\n    call assert_equal('Xbaz', bufname(winbufnr(2)))\n    only\n\n    call feedkeys(l:bar_nr . \"\\<C-W>\\<C-^>\", 'tx')\n    call assert_equal('Xbar', bufname(winbufnr(1)))\n    call assert_equal('Xfoo', bufname(winbufnr(2)))\n    only\n\n    execute l:baz_nr . 'wincmd ^'\n    call assert_equal('Xbaz', bufname(winbufnr(1)))\n    call assert_equal('Xbar', bufname(winbufnr(2)))\n  endif\n\n  %bw!\nendfunc\n\nfunc Test_window_split_no_room()\n  \" N horizontal windows need >= 2*N + 1 lines:\n  \" - 1 line + 1 status line in each window\n  \" - 1 Ex command line\n  \"\n  \" 2*N + 1 <= &lines\n  \" N <= (lines - 1)/2\n  \"\n  \" Beyond that number of windows, E36: Not enough room is expected.\n  let hor_win_count = (&lines - 1)/2\n  let hor_split_count = hor_win_count - 1\n  for s in range(1, hor_split_count) | split | endfor\n  call assert_fails('split', 'E36:')\n\n  \" N vertical windows need >= 2*(N - 1) + 1 columns:\n  \" - 1 column + 1 separator for each window (except last window)\n  \" - 1 column for the last window which does not have separator\n  \"\n  \" 2*(N - 1) + 1 <= &columns\n  \" 2*N - 1 <= &columns\n  \" N <= (&columns + 1)/2\n  let ver_win_count = (&columns + 1)/2\n  let ver_split_count = ver_win_count - 1\n  for s in range(1, ver_split_count) | vsplit | endfor\n  call assert_fails('vsplit', 'E36:')\n\n  %bw!\nendfunc\n\nfunc Test_window_exchange()\n  e Xa\n\n  \" Nothing happens with window exchange when there is 1 window\n  wincmd x\n  call assert_equal(1, winnr('$'))\n\n  split Xb\n  split Xc\n\n  call assert_equal('Xc', bufname(winbufnr(1)))\n  call assert_equal('Xb', bufname(winbufnr(2)))\n  call assert_equal('Xa', bufname(winbufnr(3)))\n\n  \" Exchange current window 1 with window 3\n  3wincmd x\n  call assert_equal('Xa', bufname(winbufnr(1)))\n  call assert_equal('Xb', bufname(winbufnr(2)))\n  call assert_equal('Xc', bufname(winbufnr(3)))\n\n  \" Exchange window with next when at the top window\n  wincmd x\n  call assert_equal('Xb', bufname(winbufnr(1)))\n  call assert_equal('Xa', bufname(winbufnr(2)))\n  call assert_equal('Xc', bufname(winbufnr(3)))\n\n  \" Exchange window with next when at the middle window\n  wincmd j\n  wincmd x\n  call assert_equal('Xb', bufname(winbufnr(1)))\n  call assert_equal('Xc', bufname(winbufnr(2)))\n  call assert_equal('Xa', bufname(winbufnr(3)))\n\n  \" Exchange window with next when at the bottom window.\n  \" When there is no next window, it exchanges with the previous window.\n  wincmd j\n  wincmd x\n  call assert_equal('Xb', bufname(winbufnr(1)))\n  call assert_equal('Xa', bufname(winbufnr(2)))\n  call assert_equal('Xc', bufname(winbufnr(3)))\n\n  bw Xa Xb Xc\nendfunc\n\nfunc Test_window_rotate()\n  e Xa\n  split Xb\n  split Xc\n  call assert_equal('Xc', bufname(winbufnr(1)))\n  call assert_equal('Xb', bufname(winbufnr(2)))\n  call assert_equal('Xa', bufname(winbufnr(3)))\n\n  \" Rotate downwards\n  wincmd r\n  call assert_equal('Xa', bufname(winbufnr(1)))\n  call assert_equal('Xc', bufname(winbufnr(2)))\n  call assert_equal('Xb', bufname(winbufnr(3)))\n\n  2wincmd r\n  call assert_equal('Xc', bufname(winbufnr(1)))\n  call assert_equal('Xb', bufname(winbufnr(2)))\n  call assert_equal('Xa', bufname(winbufnr(3)))\n\n  \" Rotate upwards\n  wincmd R\n  call assert_equal('Xb', bufname(winbufnr(1)))\n  call assert_equal('Xa', bufname(winbufnr(2)))\n  call assert_equal('Xc', bufname(winbufnr(3)))\n\n  2wincmd R\n  call assert_equal('Xc', bufname(winbufnr(1)))\n  call assert_equal('Xb', bufname(winbufnr(2)))\n  call assert_equal('Xa', bufname(winbufnr(3)))\n\n  bot vsplit\n  call assert_fails('wincmd R', 'E443:')\n\n  bw Xa Xb Xc\nendfunc\n\nfunc Test_window_height()\n  e Xa\n  split Xb\n\n  let [wh1, wh2] = [winheight(1), winheight(2)]\n  \" Active window (1) should have the same height or 1 more\n  \" than the other window.\n  call assert_inrange(wh2, wh2 + 1, wh1)\n\n  wincmd -\n  call assert_equal(wh1 - 1, winheight(1))\n  call assert_equal(wh2 + 1, winheight(2))\n\n  wincmd +\n  call assert_equal(wh1, winheight(1))\n  call assert_equal(wh2, 2->winheight())\n\n  2wincmd _\n  call assert_equal(2, winheight(1))\n  call assert_equal(wh1 + wh2 - 2, winheight(2))\n\n  wincmd =\n  call assert_equal(wh1, winheight(1))\n  call assert_equal(wh2, winheight(2))\n\n  2wincmd _\n  set winfixheight\n  split Xc\n  let [wh1, wh2, wh3] = [winheight(1), winheight(2), winheight(3)]\n  call assert_equal(2, winheight(2))\n  call assert_inrange(wh3, wh3 + 1, wh1)\n  3wincmd +\n  call assert_equal(2,       winheight(2))\n  call assert_equal(wh1 + 3, winheight(1))\n  call assert_equal(wh3 - 3, winheight(3))\n  wincmd =\n  call assert_equal(2,   winheight(2))\n  call assert_equal(wh1, winheight(1))\n  call assert_equal(wh3, winheight(3))\n\n  wincmd j\n  set winfixheight&\n\n  wincmd =\n  let [wh1, wh2, wh3] = [winheight(1), winheight(2), winheight(3)]\n  \" Current window (2) should have the same height or 1 more\n  \" than the other windows.\n  call assert_inrange(wh1, wh1 + 1, wh2)\n  call assert_inrange(wh3, wh3 + 1, wh2)\n\n  bw Xa Xb Xc\nendfunc\n\nfunc Test_wincmd_equal()\n  edit Xone\n  below split Xtwo\n  rightbelow vsplit Xthree\n  call assert_equal('Xone', bufname(winbufnr(1)))\n  call assert_equal('Xtwo', bufname(winbufnr(2)))\n  call assert_equal('Xthree', bufname(winbufnr(3)))\n\n  \" Xone and Xtwo should be about the same height\n  let [wh1, wh2] = [winheight(1), winheight(2)]\n  call assert_inrange(wh1 - 1, wh1 + 1, wh2)\n  \" Xtwo and Xthree should be about the same width\n  let [ww2, ww3] = [winwidth(2), winwidth(3)]\n  call assert_inrange(ww2 - 1, ww2 + 1, ww3)\n\n  1wincmd w\n  10wincmd _\n  2wincmd w\n  20wincmd |\n  call assert_equal(10, winheight(1))\n  call assert_equal(20, winwidth(2))\n\n  \" equalizing horizontally doesn't change the heights\n  hor wincmd =\n  call assert_equal(10, winheight(1))\n  let [ww2, ww3] = [winwidth(2), winwidth(3)]\n  call assert_inrange(ww2 - 1, ww2 + 1, ww3)\n\n  2wincmd w\n  20wincmd |\n  call assert_equal(20, winwidth(2))\n  \" equalizing vertically doesn't change the widths\n  vert wincmd =\n  call assert_equal(20, winwidth(2))\n  let [wh1, wh2] = [winheight(1), winheight(2)]\n  call assert_inrange(wh1 - 1, wh1 + 1, wh2)\n\n  bwipe Xone Xtwo Xthree\nendfunc\n\nfunc Test_window_width()\n  e Xa\n  vsplit Xb\n\n  let [ww1, ww2] = [winwidth(1), winwidth(2)]\n  \" Active window (1) should have the same width or 1 more\n  \" than the other window.\n  call assert_inrange(ww2, ww2 + 1, ww1)\n\n  wincmd <\n  call assert_equal(ww1 - 1, winwidth(1))\n  call assert_equal(ww2 + 1, winwidth(2))\n\n  wincmd >\n  call assert_equal(ww1, winwidth(1))\n  call assert_equal(ww2, winwidth(2))\n\n  2wincmd |\n  call assert_equal(2, winwidth(1))\n  call assert_equal(ww1 + ww2 - 2, winwidth(2))\n\n  wincmd =\n  call assert_equal(ww1, winwidth(1))\n  call assert_equal(ww2, winwidth(2))\n\n  2wincmd |\n  set winfixwidth\n  vsplit Xc\n  let [ww1, ww2, ww3] = [winwidth(1), winwidth(2), winwidth(3)]\n  call assert_equal(2, winwidth(2))\n  call assert_inrange(ww3, ww3 + 1, ww1)\n  3wincmd >\n  call assert_equal(2,       winwidth(2))\n  call assert_equal(ww1 + 3, winwidth(1))\n  call assert_equal(ww3 - 3, winwidth(3))\n  wincmd =\n  call assert_equal(2,   winwidth(2))\n  call assert_equal(ww1, winwidth(1))\n  call assert_equal(ww3, winwidth(3))\n\n  wincmd l\n  set winfixwidth&\n\n  wincmd =\n  let [ww1, ww2, ww3] = [winwidth(1), winwidth(2), winwidth(3)]\n  \" Current window (2) should have the same width or 1 more\n  \" than the other windows.\n  call assert_inrange(ww1, ww1 + 1, ww2)\n  call assert_inrange(ww3, ww3 + 1, ww2)\n\n  \" when the current window width is less than the new 'winwidth', the current\n  \" window width should be increased.\n  enew | only\n  split\n  10vnew\n  set winwidth=15\n  call assert_equal(15, winwidth(0))\n\n  %bw!\nendfunc\n\nfunc Test_equalalways_on_close()\n  set equalalways\n  vsplit\n  windo split\n  split\n  wincmd J\n  \" now we have a frame top-left with two windows, a frame top-right with two\n  \" windows and a frame at the bottom, full-width.\n  let height_1 = winheight(1)\n  let height_2 = winheight(2)\n  let height_3 = winheight(3)\n  let height_4 = winheight(4)\n  \" closing the bottom window causes all windows to be resized.\n  close\n  call assert_notequal(height_1, winheight(1))\n  call assert_notequal(height_2, winheight(2))\n  call assert_notequal(height_3, winheight(3))\n  call assert_notequal(height_4, winheight(4))\n  call assert_equal(winheight(1), winheight(3))\n  call assert_equal(winheight(2), winheight(4))\n\n  1wincmd w\n  split\n  4wincmd w\n  resize + 5\n  \" left column has three windows, equalized heights.\n  \" right column has two windows, top one a bit higher\n  let height_1 = winheight(1)\n  let height_2 = winheight(2)\n  let height_4 = winheight(4)\n  let height_5 = winheight(5)\n  3wincmd w\n  \" closing window in left column equalizes heights in left column but not in\n  \" the right column\n  close\n  call assert_notequal(height_1, winheight(1))\n  call assert_notequal(height_2, winheight(2))\n  call assert_equal(height_4, winheight(3))\n  call assert_equal(height_5, winheight(4))\n\n  only\n  set equalalways&\nendfunc\n\nfunc Test_win_screenpos()\n  CheckFeature quickfix\n\n  call assert_equal(1, winnr('$'))\n  split\n  vsplit\n  10wincmd _\n  30wincmd |\n  call assert_equal([1, 1], win_screenpos(1))\n  call assert_equal([1, 32], win_screenpos(2))\n  call assert_equal([12, 1], win_screenpos(3))\n  call assert_equal([0, 0], win_screenpos(4))\n  call assert_fails('let l = win_screenpos([])', 'E745:')\n  only\nendfunc\n\nfunc Test_window_jump_tag()\n  CheckFeature quickfix\n\n  help\n  /iccf\n  call assert_match('^|iccf|',  getline('.'))\n  call assert_equal(2, winnr('$'))\n  2wincmd }\n  call assert_equal(3, winnr('$'))\n  call assert_match('^|iccf|',  getline('.'))\n  wincmd k\n  call assert_match('\\*iccf\\*',  getline('.'))\n  call assert_equal(2, winheight(0))\n\n  wincmd z\n  set previewheight=4\n  help\n  /bugs\n  wincmd }\n  wincmd k\n  call assert_match('\\*bugs\\*',  getline('.'))\n  call assert_equal(4, winheight(0))\n  set previewheight&\n\n  %bw!\nendfunc\n\nfunc Test_window_newtab()\n  e Xa\n\n  call assert_equal(1, tabpagenr('$'))\n  call assert_equal(\"\\nAlready only one window\", execute('wincmd T'))\n\n  split Xb\n  split Xc\n\n  wincmd T\n  call assert_equal(2, tabpagenr('$'))\n  call assert_equal(['Xb', 'Xa'], map(tabpagebuflist(1), 'bufname(v:val)'))\n  call assert_equal(['Xc'      ], map(2->tabpagebuflist(), 'bufname(v:val)'))\n  call assert_equal(['Xc'      ], map(tabpagebuflist(), 'bufname(v:val)'))\n\n  %bw!\nendfunc\n\nfunc Test_next_split_all()\n  \" This was causing an illegal memory access.\n  n x\n  norm axxx\n  split\n  split\n  s/x\n  s/x\n  all\n  bwipe!\nendfunc\n\n\" Tests for adjusting window and contents\nfunc GetScreenStr(row)\n   let str = \"\"\n   for c in range(1,3)\n       let str .= nr2char(screenchar(a:row, c))\n   endfor\n   return str\nendfunc\n\nfunc Test_window_contents()\n  enew! | only | new\n  call setline(1, range(1,256))\n\n  exe \"norm! \\<C-W>t\\<C-W>=1Gzt\\<C-W>w\\<C-W>+\"\n  redraw\n  let s3 = GetScreenStr(1)\n  wincmd p\n  call assert_equal(1, line(\"w0\"))\n  call assert_equal('1  ', s3)\n\n  exe \"norm! \\<C-W>t\\<C-W>=50Gzt\\<C-W>w\\<C-W>+\"\n  redraw\n  let s3 = GetScreenStr(1)\n  wincmd p\n  call assert_equal(50, line(\"w0\"))\n  call assert_equal('50 ', s3)\n\n  exe \"norm! \\<C-W>t\\<C-W>=59Gzt\\<C-W>w\\<C-W>+\"\n  redraw\n  let s3 = GetScreenStr(1)\n  wincmd p\n  call assert_equal(59, line(\"w0\"))\n  call assert_equal('59 ', s3)\n\n  %d\n  call setline(1, ['one', 'two', 'three'])\n  call assert_equal(1, line('w0'))\n  call assert_equal(3, line('w$'))\n\n  bwipeout!\n  call test_garbagecollect_now()\nendfunc\n\nfunc Test_window_colon_command()\n  \" This was reading invalid memory.\n  exe \"norm! v\\<C-W>:\\<C-U>echo v:version\"\nendfunc\n\nfunc Test_access_freed_mem()\n  call assert_equal(&columns, winwidth(0))\n  \" This was accessing freed memory (but with what events?)\n  au BufEnter,BufLeave,WinEnter,WinLeave 0 vs xxx\n  arg 0\n  argadd\n  call assert_fails(\"all\", \"E242:\")\n  au!\n  bwipe xxx\n  call assert_equal(&columns, winwidth(0))\nendfunc\n\nfunc Test_insert_cleared_on_switch_to_term()\n  CheckFeature terminal\n\n  set showmode\n  terminal\n  wincmd p\n\n  call feedkeys(\"i\\<C-O>\", 'ntx')\n  redraw\n\n  \" The \"-- (insert) --\" indicator should be visible.\n  let chars = map(range(1, &columns), 'nr2char(screenchar(&lines, v:val))')\n  let str = trim(join(chars, ''))\n  call assert_equal('-- (insert) --', str)\n\n  call feedkeys(\"\\<C-W>p\", 'ntx')\n  redraw\n\n  \" The \"-- (insert) --\" indicator should have been cleared.\n  let chars = map(range(1, &columns), 'nr2char(screenchar(&lines, v:val))')\n  let str = trim(join(chars, ''))\n  call assert_equal('', str)\n\n  set showmode&\n  %bw!\nendfunc\n\nfunc Test_visual_cleared_after_window_split()\n  new | only!\n  let smd_save = &showmode\n  set showmode\n  let ls_save = &laststatus\n  set laststatus=1\n  call setline(1, ['a', 'b', 'c', 'd', ''])\n  norm! G\n  exe \"norm! kkvk\"\n  redraw\n  exe \"norm! \\<C-W>v\"\n  redraw\n  \" check if '-- VISUAL --' disappeared from command line\n  let columns = range(1, &columns)\n  let cmdlinechars = map(columns, 'nr2char(screenchar(&lines, v:val))')\n  let cmdline = join(cmdlinechars, '')\n  let cmdline_ltrim = substitute(cmdline, '^\\s*', \"\", \"\")\n  let mode_shown = substitute(cmdline_ltrim, '\\s*$', \"\", \"\")\n  call assert_equal('', mode_shown)\n  let &showmode = smd_save\n  let &laststatus = ls_save\n  bwipe!\nendfunc\n\nfunc Test_winrestcmd()\n  2split\n  3vsplit\n  let restcmd = winrestcmd()\n  call assert_equal(2, winheight(0))\n  call assert_equal(3, winwidth(0))\n  wincmd =\n  call assert_notequal(2, winheight(0))\n  call assert_notequal(3, winwidth(0))\n  exe restcmd\n  call assert_equal(2, winheight(0))\n  call assert_equal(3, winwidth(0))\n  only\n\n  wincmd v\n  wincmd s\n  wincmd v\n  redraw\n  let restcmd = winrestcmd()\n  wincmd _\n  wincmd |\n  exe restcmd\n  redraw\n  call assert_equal(restcmd, winrestcmd())\n\n  only\nendfunc\n\nfunc Fun_RenewFile()\n  \" Need to wait a bit for the timestamp to be older.\n  let old_ftime = getftime(\"tmp.txt\")\n  while getftime(\"tmp.txt\") == old_ftime\n    sleep 100m\n    silent execute '!echo \"1\" > tmp.txt'\n  endwhile\n  sp\n  wincmd p\n  edit! tmp.txt\nendfunc\n\nfunc Test_window_prevwin()\n  \" Can we make this work on MS-Windows?\n  CheckUnix\n\n  set hidden autoread\n  call writefile(['2'], 'tmp.txt', 'D')\n  new tmp.txt\n  q\n  call Fun_RenewFile()\n  call assert_equal(2, winnr())\n  wincmd p\n  call assert_equal(1, winnr())\n  wincmd p\n  q\n  call Fun_RenewFile()\n  call assert_equal(2, winnr())\n  wincmd p\n  call assert_equal(1, winnr())\n  wincmd p\n  \" reset\n  q\n  set hidden&vim autoread&vim\n  delfunc Fun_RenewFile\nendfunc\n\nfunc Test_relative_cursor_position_in_one_line_window()\n  new\n  only\n  call setline(1, range(1, 10000))\n  normal 50%\n  let lnum = getcurpos()[1]\n  split\n  split\n  \" make third window take as many lines as possible, other windows will\n  \" become one line\n  3wincmd w\n  for i in range(1, &lines - 6)\n    wincmd +\n    redraw!\n  endfor\n\n  \" first and second window should show cursor line\n  let wininfo = getwininfo()\n  call assert_equal(lnum, wininfo[0].topline)\n  call assert_equal(lnum, wininfo[1].topline)\n\n  only!\n  bwipe!\n  call assert_fails('call winrestview(test_null_dict())', 'E1297:')\nendfunc\n\nfunc Test_relative_cursor_position_after_move_and_resize()\n  let so_save = &so\n  set so=0\n  enew\n  call setline(1, range(1, 10000))\n  normal 50%\n  split\n  1wincmd w\n  \" Move cursor to first line in window\n  normal H\n  redraw!\n  \" Reduce window height to two lines\n  let height = winheight(0)\n  while winheight(0) > 2\n    wincmd -\n    redraw!\n  endwhile\n  \" move cursor to second/last line in window\n  normal j\n  \" restore previous height\n  while winheight(0) < height\n    wincmd +\n    redraw!\n  endwhile\n  \" make window two lines again\n  while winheight(0) > 2\n    wincmd -\n    redraw!\n  endwhile\n\n  \" cursor should be at bottom line\n  let info = getwininfo(win_getid())[0]\n  call assert_equal(info.topline + 1, getcurpos()[1])\n\n  only!\n  bwipe!\n  let &so = so_save\nendfunc\n\nfunc Test_relative_cursor_position_after_resize()\n  let so_save = &so\n  set so=0\n  enew\n  call setline(1, range(1, 10000))\n  normal 50%\n  split\n  1wincmd w\n  let winid1 = win_getid()\n  let info = getwininfo(winid1)[0]\n  \" Move cursor to second line in window\n  exe \"normal \" . (info.topline + 1) . \"G\"\n  redraw!\n  let lnum = getcurpos()[1]\n\n  \" Make the window only two lines high, cursor should end up in top line\n  2wincmd w\n  exe (info.height - 2) . \"wincmd +\"\n  redraw!\n  let info = getwininfo(winid1)[0]\n  call assert_equal(lnum, info.topline)\n\n  only!\n  bwipe!\n  let &so = so_save\nendfunc\n\nfunc Test_relative_cursor_second_line_after_resize()\n  let so_save = &so\n  set so=0\n  enew\n  call setline(1, range(1, 10000))\n  normal 50%\n  split\n  1wincmd w\n  let winid1 = win_getid()\n  let info = getwininfo(winid1)[0]\n\n  \" Make the window only two lines high\n  2wincmd _\n\n  \" Move cursor to second line in window\n  normal H\n  normal j\n\n  \" Make window size bigger, then back to 2 lines\n  for i in range(1, 10)\n    wincmd +\n    redraw!\n  endfor\n  for i in range(1, 10)\n    wincmd -\n    redraw!\n  endfor\n\n  \" cursor should end up in bottom line\n  let info = getwininfo(winid1)[0]\n  call assert_equal(info.topline + 1, getcurpos()[1])\n\n  only!\n  bwipe!\n  let &so = so_save\nendfunc\n\nfunc Test_split_noscroll()\n  let so_save = &so\n  enew\n  call setline(1, range(1, 8))\n  normal 100%\n  split\n\n  1wincmd w\n  let winid1 = win_getid()\n  let info1 = getwininfo(winid1)[0]\n\n  2wincmd w\n  let winid2 = win_getid()\n  let info2 = getwininfo(winid2)[0]\n\n  call assert_equal(1, info1.topline)\n  call assert_equal(1, info2.topline)\n\n  \" window that fits all lines by itself, but not when split: closing other\n  \" window should restore fraction.\n  only!\n  call setline(1, range(1, &lines - 10))\n  exe &lines / 4\n  let winid1 = win_getid()\n  let info1 = getwininfo(winid1)[0]\n  call assert_equal(1, info1.topline)\n  new\n  redraw\n  close\n  let info1 = getwininfo(winid1)[0]\n  call assert_equal(1, info1.topline)\n\n  bwipe!\n  let &so = so_save\nendfunc\n\n\" Tests for the winnr() function\nfunc Test_winnr()\n  only | tabonly\n  call assert_equal(1, winnr('j'))\n  call assert_equal(1, winnr('k'))\n  call assert_equal(1, winnr('h'))\n  call assert_equal(1, winnr('l'))\n\n  \" create a set of horizontally and vertically split windows\n  leftabove new | wincmd p\n  leftabove new | wincmd p\n  rightbelow new | wincmd p\n  rightbelow new | wincmd p\n  leftabove vnew | wincmd p\n  leftabove vnew | wincmd p\n  rightbelow vnew | wincmd p\n  rightbelow vnew | wincmd p\n\n  call assert_equal(8, winnr('j'))\n  call assert_equal(2, winnr('k'))\n  call assert_equal(4, winnr('h'))\n  call assert_equal(6, winnr('l'))\n  call assert_equal(9, winnr('2j'))\n  call assert_equal(1, winnr('2k'))\n  call assert_equal(3, winnr('2h'))\n  call assert_equal(7, winnr('2l'))\n\n  \" Error cases\n  call assert_fails(\"echo winnr('0.2k')\", 'E15:')\n  call assert_equal(2, winnr('-2k'))\n  call assert_fails(\"echo winnr('-2xj')\", 'E15:')\n  call assert_fails(\"echo winnr('j2j')\", 'E15:')\n  call assert_fails(\"echo winnr('ll')\", 'E15:')\n  call assert_fails(\"echo winnr('5')\", 'E15:')\n  call assert_equal(4, winnr('0h'))\n  call assert_fails(\"let w = winnr([])\", 'E730:')\n  call assert_equal('unknown', win_gettype(-1))\n  call assert_equal(-1, winheight(-1))\n  call assert_equal(-1, winwidth(-1))\n\n  tabnew\n  call assert_equal(8, tabpagewinnr(1, 'j'))\n  call assert_equal(2, 1->tabpagewinnr('k'))\n  call assert_equal(4, tabpagewinnr(1, 'h'))\n  call assert_equal(6, tabpagewinnr(1, 'l'))\n\n  only | tabonly\nendfunc\n\nfunc Test_winrestview()\n  split runtest.vim\n  normal 50%\n  let view = winsaveview()\n  close\n  split runtest.vim\n  eval view->winrestview()\n  call assert_equal(view, winsaveview())\n\n  bwipe!\n  call assert_fails('call winrestview(test_null_dict())', 'E1297:')\nendfunc\n\nfunc Test_win_splitmove()\n  CheckFeature quickfix\n\n  edit a\n  leftabove split b\n  leftabove vsplit c\n  leftabove split d\n  call assert_equal(0, win_splitmove(winnr(), winnr('l')))\n  call assert_equal(bufname(winbufnr(1)), 'c')\n  call assert_equal(bufname(winbufnr(2)), 'd')\n  call assert_equal(bufname(winbufnr(3)), 'b')\n  call assert_equal(bufname(winbufnr(4)), 'a')\n  call assert_equal(0, win_splitmove(winnr(), winnr('j'), {'vertical': 1}))\n  call assert_equal(0, win_splitmove(winnr(), winnr('j'), {'vertical': 1}))\n  call assert_equal(bufname(winbufnr(1)), 'c')\n  call assert_equal(bufname(winbufnr(2)), 'b')\n  call assert_equal(bufname(winbufnr(3)), 'd')\n  call assert_equal(bufname(winbufnr(4)), 'a')\n  call assert_equal(0, win_splitmove(winnr(), winnr('k'), {'vertical': 1}))\n  call assert_equal(bufname(winbufnr(1)), 'd')\n  call assert_equal(bufname(winbufnr(2)), 'c')\n  call assert_equal(bufname(winbufnr(3)), 'b')\n  call assert_equal(bufname(winbufnr(4)), 'a')\n  call assert_equal(0, win_splitmove(winnr(), winnr('j'), {'rightbelow': v:true}))\n  call assert_equal(bufname(winbufnr(1)), 'c')\n  call assert_equal(bufname(winbufnr(2)), 'b')\n  call assert_equal(bufname(winbufnr(3)), 'a')\n  call assert_equal(bufname(winbufnr(4)), 'd')\n  call assert_fails('call win_splitmove(winnr(), winnr(\"k\"), test_null_dict())', 'E1297:')\n  only | bd\n\n  call assert_fails('call win_splitmove(winnr(), 123)', 'E957:')\n  call assert_fails('call win_splitmove(123, winnr())', 'E957:')\n  call assert_fails('call win_splitmove(winnr(), winnr())', 'E957:')\n\n  tabnew\n  call assert_fails('call win_splitmove(1, win_getid(1, 1))', 'E957:')\n  tabclose\nendfunc\n\n\" Test for the :only command\nfunc Test_window_only()\n  new\n  set modified\n  new\n  call assert_fails('only', 'E445:')\n  only!\n  \" Test for :only with a count\n  let wid = win_getid()\n  new\n  new\n  3only\n  call assert_equal(1, winnr('$'))\n  call assert_equal(wid, win_getid())\n  call assert_fails('close', 'E444:')\n  call assert_fails('%close', 'E16:')\nendfunc\n\n\" Test for errors with :wincmd\nfunc Test_wincmd_errors()\n  call assert_fails('wincmd g', 'E474:')\n  call assert_fails('wincmd ab', 'E474:')\nendfunc\n\n\" Test for errors with :winpos\nfunc Test_winpos_errors()\n  if !has(\"gui_running\") && !has('win32')\n    call assert_fails('winpos', 'E188:')\n  endif\n  call assert_fails('winpos 10', 'E466:')\nendfunc\n\n\" Test for +cmd in a :split command\nfunc Test_split_cmd()\n  split +set\\ readonly\n  call assert_equal(1, &readonly)\n  call assert_equal(2, winnr('$'))\n  close\nendfunc\n\n\" Create maximum number of horizontally or vertically split windows and then\n\" run commands that create a new horizontally/vertically split window\nfunc Run_noroom_for_newwindow_test(dir_arg)\n  let dir = (a:dir_arg == 'v') ? 'vert ' : ''\n\n  \" Open as many windows as possible\n  while v:true\n    try\n      exe dir . 'new'\n    catch /E36:/\n      break\n    endtry\n  endwhile\n\n  call writefile(['first', 'second', 'third'], 'Xnorfile1', 'D')\n  call writefile([], 'Xnorfile2', 'D')\n  call writefile([], 'Xnorfile3', 'D')\n\n  \" Argument list related commands\n  args Xnorfile1 Xnorfile2 Xnorfile3\n  next\n  for cmd in ['sargument 2', 'snext', 'sprevious', 'sNext', 'srewind',\n\t\t\t\\ 'sfirst', 'slast']\n    call assert_fails(dir .. cmd, 'E36:')\n  endfor\n  %argdelete\n\n  \" Buffer related commands\n  set modified\n  hide enew\n  for cmd in ['sbuffer Xnorfile1', 'sbnext', 'sbprevious', 'sbNext', 'sbrewind',\n\t\t\\ 'sbfirst', 'sblast', 'sball', 'sbmodified', 'sunhide']\n    call assert_fails(dir .. cmd, 'E36:')\n  endfor\n\n  \" Window related commands\n  for cmd in ['split', 'split Xnorfile2', 'new', 'new Xnorfile3', 'sview Xnorfile1',\n\t\t\\ 'sfind runtest.vim']\n    call assert_fails(dir .. cmd, 'E36:')\n  endfor\n\n  \" Help\n  call assert_fails(dir .. 'help', 'E36:')\n  call assert_fails(dir .. 'helpgrep window', 'E36:')\n\n  \" Command-line window\n  if a:dir_arg == 'h'\n    \" Cmd-line window is always a horizontally split window\n    call assert_beeps('call feedkeys(\"q:\\<CR>\", \"xt\")')\n  endif\n\n  \" Quickfix and location list window\n  if has('quickfix')\n    cexpr ''\n    call assert_fails(dir .. 'copen', 'E36:')\n    lexpr ''\n    call assert_fails(dir .. 'lopen', 'E36:')\n\n    \" Preview window\n    call assert_fails(dir .. 'pedit Xnorfile2', 'E36:')\n    call setline(1, 'abc')\n    call assert_fails(dir .. 'psearch abc', 'E36:')\n  endif\n\n  \" Window commands (CTRL-W ^ and CTRL-W f)\n  if a:dir_arg == 'h'\n    call assert_fails('call feedkeys(\"\\<C-W>^\", \"xt\")', 'E36:')\n    call setline(1, 'Xnorfile1')\n    call assert_fails('call feedkeys(\"gg\\<C-W>f\", \"xt\")', 'E36:')\n  endif\n  enew!\n\n  \" Tag commands (:stag, :stselect and :stjump)\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"second\\tXnorfile1\\t2\",\n        \\ \"third\\tXnorfile1\\t3\",],\n        \\ 'Xtags')\n  set tags=Xtags\n  call assert_fails(dir .. 'stag second', 'E36:')\n  call assert_fails('call feedkeys(\":\" .. dir .. \"stselect second\\n1\\n\", \"xt\")', 'E36:')\n  call assert_fails(dir .. 'stjump second', 'E36:')\n  call assert_fails(dir .. 'ptag second', 'E36:')\n  set tags&\n  call delete('Xtags')\n\n  \" :isplit and :dsplit\n  call setline(1, ['#define FOO 1', 'FOO'])\n  normal 2G\n  call assert_fails(dir .. 'isplit FOO', 'E36:')\n  call assert_fails(dir .. 'dsplit FOO', 'E36:')\n\n  \" terminal\n  if has('terminal')\n    call assert_fails(dir .. 'terminal', 'E36:')\n  endif\n\n  %bwipe!\n  only\nendfunc\n\nfunc Test_split_cmds_with_no_room()\n  call Run_noroom_for_newwindow_test('h')\n  call Run_noroom_for_newwindow_test('v')\nendfunc\n\n\" Test for various wincmd failures\nfunc Test_wincmd_fails()\n  only!\n  call assert_beeps(\"normal \\<C-W>w\")\n  call assert_beeps(\"normal \\<C-W>p\")\n  call assert_beeps(\"normal \\<C-W>gk\")\n  call assert_beeps(\"normal \\<C-W>r\")\n  call assert_beeps(\"normal \\<C-W>K\")\n  call assert_beeps(\"normal \\<C-W>H\")\n  call assert_beeps(\"normal \\<C-W>2gt\")\nendfunc\n\nfunc Test_window_resize()\n  \" Vertical :resize (absolute, relative, min and max size).\n  vsplit\n  vert resize 8\n  call assert_equal(8, winwidth(0))\n  vert resize +2\n  call assert_equal(10, winwidth(0))\n  vert resize -2\n  call assert_equal(8, winwidth(0))\n  vert resize\n  call assert_equal(&columns - 2, winwidth(0))\n  vert resize 0\n  call assert_equal(1, winwidth(0))\n  vert resize 99999\n  call assert_equal(&columns - 2, winwidth(0))\n\n  %bwipe!\n\n  \" Horizontal :resize (with absolute, relative size, min and max size).\n  split\n  resize 8\n  call assert_equal(8, winheight(0))\n  resize +2\n  call assert_equal(10, winheight(0))\n  resize -2\n  call assert_equal(8, winheight(0))\n  resize\n  call assert_equal(&lines - 4, winheight(0))\n  resize 0\n  call assert_equal(1, winheight(0))\n  resize 99999\n  call assert_equal(&lines - 4, winheight(0))\n\n  \" :resize with explicit window number.\n  let other_winnr = winnr('j')\n  exe other_winnr .. 'resize 10'\n  call assert_equal(10, winheight(other_winnr))\n  call assert_equal(&lines - 10 - 3, winheight(0))\n  exe other_winnr .. 'resize +1'\n  exe other_winnr .. 'resize +1'\n  call assert_equal(12, winheight(other_winnr))\n  call assert_equal(&lines - 10 - 3 -2, winheight(0))\n  close\n\n  vsplit\n  wincmd l\n  let other_winnr = winnr('h')\n  call assert_notequal(winnr(), other_winnr)\n  exe 'vert ' .. other_winnr .. 'resize -' .. &columns\n  call assert_equal(0, winwidth(other_winnr))\n\n  %bwipe!\nendfunc\n\n\" Test for adjusting the window width when a window is closed with some\n\" windows using 'winfixwidth'\nfunc Test_window_width_adjust()\n  only\n  \" Three vertical windows. Windows 1 and 2 have 'winfixwidth' set and close\n  \" window 2.\n  wincmd v\n  vert resize 10\n  set winfixwidth\n  wincmd v\n  set winfixwidth\n  wincmd c\n  call assert_inrange(10, 12, winwidth(1))\n  \" Three vertical windows. Windows 2 and 3 have 'winfixwidth' set and close\n  \" window 3.\n  only\n  set winfixwidth\n  wincmd v\n  vert resize 10\n  set winfixwidth\n  wincmd v\n  set nowinfixwidth\n  wincmd b\n  wincmd c\n  call assert_inrange(10, 12, winwidth(2))\n\n  new | only\nendfunc\n\n\" Test for jumping to a vertical/horizontal neighbor window based on the\n\" current cursor position\nfunc Test_window_goto_neighbor()\n  %bw!\n\n  \" Vertical window movement\n\n  \" create the following window layout:\n  \"     +--+--+\n  \"     |w1|w3|\n  \"     +--+  |\n  \"     |w2|  |\n  \"     +--+--+\n  \"     |w4   |\n  \"     +-----+\n  new\n  vsplit\n  split\n  \" vertically jump from w4\n  wincmd b\n  call setline(1, repeat(' ', &columns))\n  call cursor(1, 1)\n  wincmd k\n  call assert_equal(2, winnr())\n  wincmd b\n  call cursor(1, &columns)\n  redraw!\n  wincmd k\n  call assert_equal(3, winnr())\n  %bw!\n\n  \" create the following window layout:\n  \"     +--+--+--+\n  \"     |w1|w2|w3|\n  \"     +--+--+--+\n  \"     |w4      |\n  \"     +--------+\n  new\n  vsplit\n  vsplit\n  wincmd b\n  call setline(1, repeat(' ', &columns))\n  call cursor(1, 1)\n  wincmd k\n  call assert_equal(1, winnr())\n  wincmd b\n  call cursor(1, &columns / 2)\n  redraw!\n  wincmd k\n  call assert_equal(2, winnr())\n  wincmd b\n  call cursor(1, &columns)\n  redraw!\n  wincmd k\n  call assert_equal(3, winnr())\n  %bw!\n\n  \" Horizontal window movement\n\n  \" create the following window layout:\n  \"     +--+--+--+\n  \"     |w1|w2|w4|\n  \"     +--+--+  |\n  \"     |w3   |  |\n  \"     +-----+--+\n  vsplit\n  split\n  vsplit\n  4wincmd l\n  call setline(1, repeat([' '], &lines))\n  call cursor(1, 1)\n  redraw!\n  wincmd h\n  call assert_equal(2, winnr())\n  4wincmd l\n  call cursor(&lines, 1)\n  redraw!\n  wincmd h\n  call assert_equal(3, winnr())\n  %bw!\n\n  \" create the following window layout:\n  \"     +--+--+\n  \"     |w1|w4|\n  \"     +--+  +\n  \"     |w2|  |\n  \"     +--+  +\n  \"     |w3|  |\n  \"     +--+--+\n  vsplit\n  split\n  split\n  wincmd l\n  call setline(1, repeat([' '], &lines))\n  call cursor(1, 1)\n  redraw!\n  wincmd h\n  call assert_equal(1, winnr())\n  wincmd l\n  call cursor(&lines / 2, 1)\n  redraw!\n  wincmd h\n  call assert_equal(2, winnr())\n  wincmd l\n  call cursor(&lines, 1)\n  redraw!\n  wincmd h\n  call assert_equal(3, winnr())\n  %bw!\nendfunc\n\n\" Test for an autocmd closing the destination window when jumping from one\n\" window to another.\nfunc Test_close_dest_window()\n  split\n  edit Xdstfile\n\n  \" Test for BufLeave\n  augroup T1\n    au!\n    au BufLeave Xdstfile $wincmd c\n  augroup END\n  wincmd b\n  call assert_equal(1, winnr('$'))\n  call assert_equal('Xdstfile', @%)\n  augroup T1\n    au!\n  augroup END\n\n  \" Test for WinLeave\n  new\n  wincmd p\n  augroup T1\n    au!\n    au WinLeave * 1wincmd c\n  augroup END\n  wincmd t\n  call assert_equal(1, winnr('$'))\n  call assert_equal('Xdstfile', @%)\n  augroup T1\n    au!\n  augroup END\n  augroup! T1\n  %bw!\nendfunc\n\nfunc Test_window_minimal_size()\n  set winminwidth=0 winminheight=0\n\n  \" check size is fixed vertically\n  new\n  call win_execute(win_getid(2), 'wincmd _')\n  call assert_equal(0, winheight(0))\n  call feedkeys('0', 'tx')\n  call assert_equal(1, winheight(0))\n  bwipe!\n\n  \" check size is fixed horizontally\n  vert new\n  call win_execute(win_getid(2), 'wincmd |')\n  call assert_equal(0, winwidth(0))\n  call feedkeys('0', 'tx')\n  call assert_equal(1, winwidth(0))\n  bwipe!\n\n  if has('timers')\n    \" check size is fixed in Insert mode\n    func s:CheckSize(timer) abort\n      call win_execute(win_getid(2), 'wincmd _')\n      call assert_equal(0, winheight(0))\n      call feedkeys(\" \\<Esc>\", 't!')\n    endfunc\n    new\n    call timer_start(100, function('s:CheckSize'))\n    call feedkeys('a', 'tx!')\n    call assert_equal(1, winheight(0))\n    bwipe!\n    delfunc s:CheckSize\n  endif\n\n  set winminwidth& winminheight&\nendfunc\n\nfunc Test_win_move_separator()\n  edit a\n  leftabove vsplit b\n  let w = winwidth(0)\n  \" check win_move_separator from left window on left window\n  call assert_equal(1, winnr())\n  for offset in range(5)\n    call assert_true(win_move_separator(0, offset))\n    call assert_equal(w + offset, winwidth(0))\n    call assert_true(0->win_move_separator(-offset))\n    call assert_equal(w, winwidth(0))\n  endfor\n  \" check win_move_separator from right window on left window number\n  wincmd l\n  call assert_notequal(1, winnr())\n  for offset in range(5)\n    call assert_true(1->win_move_separator(offset))\n    call assert_equal(w + offset, winwidth(1))\n    call assert_true(win_move_separator(1, -offset))\n    call assert_equal(w, winwidth(1))\n  endfor\n  \" check win_move_separator from right window on left window ID\n  let id = win_getid(1)\n  for offset in range(5)\n    call assert_true(win_move_separator(id, offset))\n    call assert_equal(w + offset, winwidth(id))\n    call assert_true(id->win_move_separator(-offset))\n    call assert_equal(w, winwidth(id))\n  endfor\n  \" check win_move_separator from right window on right window is no-op\n  let w0 = winwidth(0)\n  call assert_true(win_move_separator(0, 1))\n  call assert_equal(w0, winwidth(0))\n  call assert_true(win_move_separator(0, -1))\n  call assert_equal(w0, winwidth(0))\n\n  \" check that win_move_separator doesn't error with offsets beyond moving\n  \" possibility\n  call assert_true(win_move_separator(id, 5000))\n  call assert_true(winwidth(id) > w)\n  call assert_true(win_move_separator(id, -5000))\n  call assert_true(winwidth(id) < w)\n\n  \" check that win_move_separator returns false for an invalid window\n  wincmd =\n  let w = winwidth(0)\n  call assert_false(win_move_separator(-1, 1))\n  call assert_equal(w, winwidth(0))\n\n  \" check that win_move_separator returns false for a popup window\n  let id = popup_create(['hello', 'world'], {})\n  let w = winwidth(id)\n  call assert_false(win_move_separator(id, 1))\n  call assert_equal(w, winwidth(id))\n  call popup_close(id)\n\n  \" check that using another tabpage fails without crash\n  let id = win_getid()\n  tabnew\n  call assert_fails('call win_move_separator(id, -1)', 'E1308:')\n  tabclose\n\n  %bwipe!\nendfunc\n\nfunc Test_win_move_statusline()\n  edit a\n  leftabove split b\n  let h = winheight(0)\n  \" check win_move_statusline from top window on top window\n  call assert_equal(1, winnr())\n  for offset in range(5)\n    call assert_true(win_move_statusline(0, offset))\n    call assert_equal(h + offset, winheight(0))\n    call assert_true(0->win_move_statusline(-offset))\n    call assert_equal(h, winheight(0))\n  endfor\n  \" check win_move_statusline from bottom window on top window number\n  wincmd j\n  call assert_notequal(1, winnr())\n  for offset in range(5)\n    call assert_true(1->win_move_statusline(offset))\n    call assert_equal(h + offset, winheight(1))\n    call assert_true(win_move_statusline(1, -offset))\n    call assert_equal(h, winheight(1))\n  endfor\n  \" check win_move_statusline from bottom window on bottom window\n  let h0 = winheight(0)\n  for offset in range(5)\n    call assert_true(0->win_move_statusline(-offset))\n    call assert_equal(h0 - offset, winheight(0))\n    call assert_equal(1 + offset, &cmdheight)\n    call assert_true(win_move_statusline(0, offset))\n    call assert_equal(h0, winheight(0))\n    call assert_equal(1, &cmdheight)\n  endfor\n  call assert_true(win_move_statusline(0, 1))\n  call assert_equal(h0, winheight(0))\n  call assert_equal(1, &cmdheight)\n  \" check win_move_statusline from bottom window on top window ID\n  let id = win_getid(1)\n  for offset in range(5)\n    call assert_true(win_move_statusline(id, offset))\n    call assert_equal(h + offset, winheight(id))\n    call assert_true(id->win_move_statusline(-offset))\n    call assert_equal(h, winheight(id))\n  endfor\n\n  \" check that win_move_statusline doesn't error with offsets beyond moving\n  \" possibility\n  call assert_true(win_move_statusline(id, 5000))\n  call assert_true(winheight(id) > h)\n  call assert_true(win_move_statusline(id, -5000))\n  call assert_true(winheight(id) < h)\n\n  \" check that win_move_statusline returns false for an invalid window\n  wincmd =\n  let h = winheight(0)\n  call assert_false(win_move_statusline(-1, 1))\n  call assert_equal(h, winheight(0))\n\n  \" check that win_move_statusline returns false for a popup window\n  let id = popup_create(['hello', 'world'], {})\n  let h = winheight(id)\n  call assert_false(win_move_statusline(id, 1))\n  call assert_equal(h, winheight(id))\n  call popup_close(id)\n\n  \" check that using another tabpage fails without crash\n  let id = win_getid()\n  tabnew\n  call assert_fails('call win_move_statusline(id, -1)', 'E1308:')\n  tabclose\n\n  %bwipe!\nendfunc\n\n\" Test for window allocation failure\nfunc Test_window_alloc_failure()\n  %bw!\n\n  \" test for creating a new window above current window\n  call test_alloc_fail(GetAllocId('newwin_wvars'), 0, 0)\n  call assert_fails('above new', 'E342:')\n  call assert_equal(1, winnr('$'))\n\n  \" test for creating a new window below current window\n  call test_alloc_fail(GetAllocId('newwin_wvars'), 0, 0)\n  call assert_fails('below new', 'E342:')\n  call assert_equal(1, winnr('$'))\n\n  \" test for popup window creation failure\n  call test_alloc_fail(GetAllocId('newwin_wvars'), 0, 0)\n  call assert_fails('call popup_create(\"Hello\", {})', 'E342:')\n  call assert_equal([], popup_list())\n\n  call test_alloc_fail(GetAllocId('newwin_wvars'), 0, 0)\n  call assert_fails('split', 'E342:')\n  call assert_equal(1, winnr('$'))\n\n  edit Xwaffile1\n  edit Xwaffile2\n  call test_alloc_fail(GetAllocId('newwin_wvars'), 0, 0)\n  call assert_fails('sb Xwaffile1', 'E342:')\n  call assert_equal(1, winnr('$'))\n  call assert_equal('Xwaffile2', @%)\n  %bw!\n\n  \" FIXME: The following test crashes Vim\n  \" test for new tabpage creation failure\n  \" call test_alloc_fail(GetAllocId('newwin_wvars'), 0, 0)\n  \" call assert_fails('tabnew', 'E342:')\n  \" call assert_equal(1, tabpagenr('$'))\n  \" call assert_equal(1, winnr('$'))\n\n  \" This test messes up the internal Vim window/frame information. So the\n  \" Test_window_cmd_cmdwin_with_vsp() test fails after running this test.\n  \" Open a new tab and close everything else to fix this issue.\n  tabnew\n  tabonly\nendfunc\n\nfunc Test_win_equal_last_status()\n  let save_lines = &lines\n  set lines=20\n  set splitbelow\n  set laststatus=0\n\n  split | split | quit\n  call assert_equal(winheight(1), winheight(2))\n\n  let &lines = save_lines\n  set splitbelow&\n  set laststatus&\nendfunc\n\n\" Test \"screen\" and \"cursor\" values for 'splitkeep' with a sequence of\n\" split operations for various options: with and without a winbar,\n\" tabline, for each possible value of 'laststatus', 'scrolloff',\n\" 'equalalways', and with the cursor at the top, middle and bottom.\nfunc Test_splitkeep_options()\n  \" disallow window resizing\n  let save_WS = &t_WS\n  set t_WS=\n\n  let gui = has(\"gui_running\")\n  inoremap <expr> c \"<cmd>copen<bar>wincmd k<CR>\"\n  for run in range(0, 20)\n    let &splitkeep = run > 10 ? 'topline' : 'screen'\n    let &scrolloff = (!(run % 4) ? 0 : run)\n    let &laststatus = (run % 3)\n    let &splitbelow = (run % 3)\n    let &equalalways = (run % 2)\n    let wsb = (run % 2) && &splitbelow\n    let tl = (gui ? 0 : ((run % 5) ? 1 : 0))\n    let pos = !(run % 3) ? 'H' : ((run % 2) ? 'M' : 'L')\n    tabnew | tabonly! | redraw\n    execute (run % 5) ? 'tabnew' : ''\n    execute (run % 2) ? 'nnoremenu 1.10 WinBar.Test :echo' : ''\n    call setline(1, range(1, 256))\n    \" No scroll for restore_snapshot\n    norm G\n    try\n      copen | close | colder\n    catch /E380/\n    endtry\n    call assert_equal(257 - winheight(0), line(\"w0\"))\n\n    \" No scroll for firstwin horizontal split\n    execute 'norm gg' . pos\n    split | redraw | wincmd k\n    call assert_equal(1, line(\"w0\"))\n    call assert_equal(&scroll, winheight(0) / 2)\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n\n    \" No scroll when resizing windows\n    wincmd k | resize +2 | redraw\n    call assert_equal(1, line(\"w0\"))\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n\n    \" No scroll when dragging statusline\n    call win_move_statusline(1, -3)\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n    wincmd k\n    call assert_equal(1, line(\"w0\"))\n\n    \" No scroll when changing shellsize\n    set lines+=2\n    call assert_equal(1, line(\"w0\"))\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n    set lines-=2\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n    wincmd k\n    call assert_equal(1, line(\"w0\"))\n\n    \" No scroll when equalizing windows\n    wincmd =\n    call assert_equal(1, line(\"w0\"))\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n    wincmd k\n    call assert_equal(1, line(\"w0\"))\n\n    \" No scroll in windows split multiple times\n    vsplit | split | 4wincmd w\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n    1wincmd w | quit | wincmd l | split\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n\n    \" No scroll in small window\n    2wincmd w | only | 5split | wincmd k\n    call assert_equal(1, line(\"w0\"))\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n\n    \" No scroll for vertical split\n    quit | vsplit | wincmd l\n    call assert_equal(1, line(\"w0\"))\n    wincmd h\n    call assert_equal(1, line(\"w0\"))\n\n    \" No scroll in windows split and quit multiple times\n    quit | redraw | split | split | quit | redraw\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n\n    \" No scroll for new buffer\n    1wincmd w | only | copen | wincmd k\n    call assert_equal(1, line(\"w0\"))\n    only\n    call assert_equal(1, line(\"w0\"))\n    above copen | wincmd j\n    call assert_equal(&spk == 'topline' ? 1 : win_screenpos(0)[0] - tl, line(\"w0\"))\n\n    \" No scroll when opening cmdwin, and no cursor move when closing cmdwin.\n    only | norm ggL\n    let curpos = getcurpos()\n    norm q:\n    call assert_equal(1, line(\"w0\"))\n    call assert_equal(curpos, getcurpos())\n\n    \" Scroll when cursor becomes invalid in insert mode.\n    norm Lic\n    call assert_equal(curpos, getcurpos(), 'run ' .. run)\n\n    \" No scroll when topline not equal to 1\n    only | execute \"norm gg5\\<C-e>\" | split | wincmd k\n    call assert_equal(6, line(\"w0\"))\n    wincmd j\n    call assert_equal(&spk == 'topline' ? 6 : 5 + win_screenpos(0)[0] - tl - wsb, line(\"w0\"))\n  endfor\n\n  tabnew | tabonly! | %bwipeout!\n  iunmap c\n  set scrolloff&\n  set splitbelow&\n  set laststatus&\n  set equalalways&\n  set splitkeep&\n  let &t_WS = save_WS\nendfunc\n\nfunc Test_splitkeep_cmdwin_cursor_position()\n  set splitkeep=screen\n  call setline(1, range(&lines))\n\n  \" No scroll when cursor is at near bottom of window and cusor position\n  \" recompution (done by line('w0') in this test) happens while in cmdwin.\n  normal! G\n  let firstline = line('w0')\n  autocmd CmdwinEnter * ++once autocmd WinEnter * ++once call line('w0')\n  execute \"normal! q:\\<C-w>q\"\n  redraw!\n  call assert_equal(firstline, line('w0'))\n\n  \" User script can change cursor position successfully while in cmdwin and it\n  \" shouldn't be changed when closing cmdwin.\n  execute \"normal! Gq:\\<Cmd>call win_execute(winnr('#')->win_getid(), 'call cursor(1, 1)')\\<CR>\\<C-w>q\"\n  call assert_equal(1, line('.'))\n  call assert_equal(1, col('.'))\n\n  execute \"normal! Gq:\\<Cmd>autocmd WinEnter * ++once call cursor(1, 1)\\<CR>\\<C-w>q\"\n  call assert_equal(1, line('.'))\n  call assert_equal(1, col('.'))\n\n  %bwipeout!\n  set splitkeep&\nendfunc\n\nfunc Test_splitkeep_misc()\n  set splitkeep=screen\n  set splitbelow\n\n  call setline(1, range(1, &lines))\n  norm Gzz\n  let top = line('w0')\n  \" No scroll when aucmd_win is opened\n  call setbufvar(bufnr(\"test\", 1) , '&buftype', 'nofile')\n  call assert_equal(top, line('w0'))\n  \" No scroll when tab is changed/closed\n  tab help | close\n  call assert_equal(top, line('w0'))\n  \" No scroll when help is closed and buffer line count < window height\n  norm ggdG\n  call setline(1, range(1, &lines - 10))\n  norm G\n  let top = line('w0')\n  help | quit\n  call assert_equal(top, line('w0'))\n  \" No error when resizing window in autocmd and buffer length changed\n  autocmd FileType qf exe \"resize\" line('$')\n  cexpr getline(1, '$')\n  copen\n  wincmd p\n  norm dd\n  cexpr getline(1, '$')\n\n  %bwipeout!\n  set splitbelow&\n  set splitkeep&\nendfunc\n\nfunc Test_splitkeep_callback()\n  CheckScreendump\n  let lines =<< trim END\n    set splitkeep=screen\n    call setline(1, range(&lines))\n    function C1(a, b)\n      split | wincmd p\n    endfunction\n    function C2(a, b)\n      close | split\n    endfunction\n    nn j <cmd>call job_start([&sh, &shcf, \"true\"], { 'exit_cb': 'C1' })<CR>\n    nn t <cmd>call popup_create(term_start([&sh, &shcf, \"true\"],\n          \\ { 'hidden': 1, 'exit_cb': 'C2' }), {})<CR>\n  END\n  call writefile(lines, 'XTestSplitkeepCallback', 'D')\n  let buf = RunVimInTerminal('-S XTestSplitkeepCallback', #{rows: 8})\n\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_callback_1', {})\n\n  call term_sendkeys(buf, \":quit\\<CR>Ht\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_callback_2', {})\n\n  call term_sendkeys(buf, \":set sb\\<CR>:quit\\<CR>Gj\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_callback_3', {})\n\n  call term_sendkeys(buf, \":quit\\<CR>Gt\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_callback_4', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_splitkeep_fold()\n  CheckScreendump\n\n  let lines =<< trim END\n    set splitkeep=screen\n    set foldmethod=marker\n    set number\n    let line = 1\n    for n in range(1, &lines)\n      call setline(line, ['int FuncName() {/*{{{*/', 1, 2, 3, 4, 5, '}/*}}}*/',\n            \\ 'after fold'])\n      let line += 8\n    endfor\n  END\n  call writefile(lines, 'XTestSplitkeepFold', 'D')\n  let buf = RunVimInTerminal('-S XTestSplitkeepFold', #{rows: 10})\n\n  call term_sendkeys(buf, \"L:wincmd s\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_fold_1', {})\n\n  call term_sendkeys(buf, \":quit\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_fold_2', {})\n\n  call term_sendkeys(buf, \"H:below split\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_fold_3', {})\n\n  call term_sendkeys(buf, \":wincmd k\\<CR>:quit\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_fold_4', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_splitkeep_status()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['a', 'b', 'c'])\n    set nomodified\n    set splitkeep=screen\n    let win = winnr()\n    wincmd s\n    wincmd j\n  END\n  call writefile(lines, 'XTestSplitkeepStatus', 'D')\n  let buf = RunVimInTerminal('-S XTestSplitkeepStatus', #{rows: 10})\n\n  call term_sendkeys(buf, \":call win_move_statusline(win, 1)\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_splitkeep_status_1', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_new_help_window_on_error()\n  help change.txt\n  execute \"normal! /CTRL-@\\<CR>\"\n  silent! execute \"normal! \\<C-W>]\"\n\n  let wincount = winnr('$')\n  help 'mod'\n\n  call assert_equal(wincount, winnr('$'))\n  call assert_equal(expand(\"<cword>\"), \"'mod'\")\nendfunc\n\nfunc Test_smoothscroll_in_zero_width_window()\n  let save_lines = &lines\n  let save_columns = &columns\n\n  winsize 0 24\n  set cpo+=n\n  exe \"noremap 0 \\<C-W>n\\<C-W>L\"\n  norm 000000\n  set number smoothscroll\n  exe \"norm \\<C-Y>\"\n\n  only!\n  let &lines = save_lines\n  let &columns = save_columns\n  set cpo-=n\n  unmap 0\n  set nonumber nosmoothscroll\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "buggy_code_start_loc": [1737, 1775, 697], "buggy_code_end_loc": [1738, 1931, 697], "fixing_code_start_loc": [1737, 1775, 698], "fixing_code_end_loc": [1738, 1950, 700], "type": "CWE-369", "message": "Divide By Zero in GitHub repository vim/vim prior to 9.0.1367.", "other": {"cve": {"id": "CVE-2023-1127", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-01T19:15:25.860", "lastModified": "2023-04-02T03:15:07.193", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Divide By Zero in GitHub repository vim/vim prior to 9.0.1367."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.1367", "matchCriteriaId": "F1F930ED-3963-4FA6-AC1A-4A1286298B02"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/e0f869196930ef5f25a0ac41c9215b09c9ce2d3c", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/2d4d309e-4c96-415f-9070-36d0815f1beb", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IE44W6WMMREYCW3GJHPSYP7NK2VT5NY6/", "source": "security@huntr.dev"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PDVN5HSWPNVP4QXBPCEGZDLZKURLJWTE/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WJ6TMKKBXHGVUHWFGM4X46VIJO7ZAG2W/", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/e0f869196930ef5f25a0ac41c9215b09c9ce2d3c"}}