{"buggy_code": ["#include \"vterm_internal.h\"\n\n#include <stdio.h>\n#include <string.h>\n\n#define strneq(a,b,n) (strncmp(a,b,n)==0)\n\n#if defined(DEBUG) && DEBUG > 1\n# define DEBUG_GLYPH_COMBINE\n#endif\n\nstatic int on_resize(int rows, int cols, void *user);\n\n/* Some convenient wrappers to make callback functions easier */\n\nstatic void putglyph(VTermState *state, const uint32_t chars[], int width, VTermPos pos)\n{\n  VTermGlyphInfo info;\n  info.chars = chars;\n  info.width = width;\n  info.protected_cell = state->protected_cell;\n  info.dwl = state->lineinfo[pos.row].doublewidth;\n  info.dhl = state->lineinfo[pos.row].doubleheight;\n\n  if(state->callbacks && state->callbacks->putglyph)\n    if((*state->callbacks->putglyph)(&info, pos, state->cbdata))\n      return;\n\n  DEBUG_LOG3(\"libvterm: Unhandled putglyph U+%04x at (%d,%d)\\n\", chars[0], pos.col, pos.row);\n}\n\nstatic void updatecursor(VTermState *state, VTermPos *oldpos, int cancel_phantom)\n{\n  if(state->pos.col == oldpos->col && state->pos.row == oldpos->row)\n    return;\n\n  if(cancel_phantom)\n    state->at_phantom = 0;\n\n  if(state->callbacks && state->callbacks->movecursor)\n    if((*state->callbacks->movecursor)(state->pos, *oldpos, state->mode.cursor_visible, state->cbdata))\n      return;\n}\n\nstatic void erase(VTermState *state, VTermRect rect, int selective)\n{\n  if(state->callbacks && state->callbacks->erase)\n    if((*state->callbacks->erase)(rect, selective, state->cbdata))\n      return;\n}\n\nstatic VTermState *vterm_state_new(VTerm *vt)\n{\n  VTermState *state = vterm_allocator_malloc(vt, sizeof(VTermState));\n\n  state->vt = vt;\n\n  state->rows = vt->rows;\n  state->cols = vt->cols;\n\n  state->mouse_col     = 0;\n  state->mouse_row     = 0;\n  state->mouse_buttons = 0;\n\n  state->mouse_protocol = MOUSE_X10;\n\n  state->callbacks = NULL;\n  state->cbdata    = NULL;\n\n  vterm_state_newpen(state);\n\n  state->bold_is_highbright = 0;\n\n  return state;\n}\n\nINTERNAL void vterm_state_free(VTermState *state)\n{\n  vterm_allocator_free(state->vt, state->tabstops);\n  vterm_allocator_free(state->vt, state->lineinfo);\n  vterm_allocator_free(state->vt, state->combine_chars);\n  vterm_allocator_free(state->vt, state);\n}\n\nstatic void scroll(VTermState *state, VTermRect rect, int downward, int rightward)\n{\n  int rows;\n  int cols;\n  if(!downward && !rightward)\n    return;\n\n  rows = rect.end_row - rect.start_row;\n  if(downward > rows)\n    downward = rows;\n  else if(downward < -rows)\n    downward = -rows;\n\n  cols = rect.end_col - rect.start_col;\n  if(rightward > cols)\n    rightward = cols;\n  else if(rightward < -cols)\n    rightward = -cols;\n\n  // Update lineinfo if full line\n  if(rect.start_col == 0 && rect.end_col == state->cols && rightward == 0) {\n    int height = rect.end_row - rect.start_row - abs(downward);\n\n    if(downward > 0)\n      memmove(state->lineinfo + rect.start_row,\n              state->lineinfo + rect.start_row + downward,\n              height * sizeof(state->lineinfo[0]));\n    else\n      memmove(state->lineinfo + rect.start_row - downward,\n              state->lineinfo + rect.start_row,\n              height * sizeof(state->lineinfo[0]));\n  }\n\n  if(state->callbacks && state->callbacks->scrollrect)\n    if((*state->callbacks->scrollrect)(rect, downward, rightward, state->cbdata))\n      return;\n\n  if(state->callbacks)\n    vterm_scroll_rect(rect, downward, rightward,\n        state->callbacks->moverect, state->callbacks->erase, state->cbdata);\n}\n\nstatic void linefeed(VTermState *state)\n{\n  if(state->pos.row == SCROLLREGION_BOTTOM(state) - 1) {\n    VTermRect rect;\n    rect.start_row = state->scrollregion_top;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = SCROLLREGION_LEFT(state);\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, 1, 0);\n  }\n  else if(state->pos.row < state->rows-1)\n    state->pos.row++;\n}\n\nstatic void grow_combine_buffer(VTermState *state)\n{\n  size_t    new_size = state->combine_chars_size * 2;\n  uint32_t *new_chars = vterm_allocator_malloc(state->vt, new_size * sizeof(new_chars[0]));\n\n  memcpy(new_chars, state->combine_chars, state->combine_chars_size * sizeof(new_chars[0]));\n\n  vterm_allocator_free(state->vt, state->combine_chars);\n\n  state->combine_chars = new_chars;\n  state->combine_chars_size = new_size;\n}\n\nstatic void set_col_tabstop(VTermState *state, int col)\n{\n  unsigned char mask = 1 << (col & 7);\n  state->tabstops[col >> 3] |= mask;\n}\n\nstatic void clear_col_tabstop(VTermState *state, int col)\n{\n  unsigned char mask = 1 << (col & 7);\n  state->tabstops[col >> 3] &= ~mask;\n}\n\nstatic int is_col_tabstop(VTermState *state, int col)\n{\n  unsigned char mask = 1 << (col & 7);\n  return state->tabstops[col >> 3] & mask;\n}\n\nstatic int is_cursor_in_scrollregion(const VTermState *state)\n{\n  if(state->pos.row < state->scrollregion_top ||\n     state->pos.row >= SCROLLREGION_BOTTOM(state))\n    return 0;\n  if(state->pos.col < SCROLLREGION_LEFT(state) ||\n     state->pos.col >= SCROLLREGION_RIGHT(state))\n    return 0;\n\n  return 1;\n}\n\nstatic void tab(VTermState *state, int count, int direction)\n{\n  while(count > 0) {\n    if(direction > 0) {\n      if(state->pos.col >= THISROWWIDTH(state)-1)\n        return;\n\n      state->pos.col++;\n    }\n    else if(direction < 0) {\n      if(state->pos.col < 1)\n        return;\n\n      state->pos.col--;\n    }\n\n    if(is_col_tabstop(state, state->pos.col))\n      count--;\n  }\n}\n\n#define NO_FORCE 0\n#define FORCE    1\n\n#define DWL_OFF 0\n#define DWL_ON  1\n\n#define DHL_OFF    0\n#define DHL_TOP    1\n#define DHL_BOTTOM 2\n\nstatic void set_lineinfo(VTermState *state, int row, int force, int dwl, int dhl)\n{\n  VTermLineInfo info = state->lineinfo[row];\n\n  if(dwl == DWL_OFF)\n    info.doublewidth = DWL_OFF;\n  else if(dwl == DWL_ON)\n    info.doublewidth = DWL_ON;\n  // else -1 to ignore\n\n  if(dhl == DHL_OFF)\n    info.doubleheight = DHL_OFF;\n  else if(dhl == DHL_TOP)\n    info.doubleheight = DHL_TOP;\n  else if(dhl == DHL_BOTTOM)\n    info.doubleheight = DHL_BOTTOM;\n\n  if((state->callbacks &&\n      state->callbacks->setlineinfo &&\n      (*state->callbacks->setlineinfo)(row, &info, state->lineinfo + row, state->cbdata))\n      || force)\n    state->lineinfo[row] = info;\n}\n\nstatic int on_text(const char bytes[], size_t len, void *user)\n{\n  VTermState *state = user;\n  uint32_t *codepoints;\n  int npoints = 0;\n  size_t eaten = 0;\n  VTermEncodingInstance *encoding;\n  int i = 0;\n\n  VTermPos oldpos = state->pos;\n\n  // We'll have at most len codepoints, plus one from a previous incomplete\n  // sequence.\n  codepoints = vterm_allocator_malloc(state->vt, (len + 1) * sizeof(uint32_t));\n\n  encoding =\n    state->gsingle_set     ? &state->encoding[state->gsingle_set] :\n    !(bytes[eaten] & 0x80) ? &state->encoding[state->gl_set] :\n    state->vt->mode.utf8   ? &state->encoding_utf8 :\n                             &state->encoding[state->gr_set];\n\n  (*encoding->enc->decode)(encoding->enc, encoding->data,\n      codepoints, &npoints, state->gsingle_set ? 1 : (int)len,\n      bytes, &eaten, len);\n\n  /* There's a chance an encoding (e.g. UTF-8) hasn't found enough bytes yet\n   * for even a single codepoint\n   */\n  if(!npoints)\n  {\n    vterm_allocator_free(state->vt, codepoints);\n    return (int)eaten;\n  }\n\n  if(state->gsingle_set && npoints)\n    state->gsingle_set = 0;\n\n  /* This is a combining char. that needs to be merged with the previous\n   * glyph output */\n  if(vterm_unicode_is_combining(codepoints[i])) {\n    /* See if the cursor has moved since */\n    if(state->pos.row == state->combine_pos.row && state->pos.col == state->combine_pos.col + state->combine_width) {\n#ifdef DEBUG_GLYPH_COMBINE\n      int printpos;\n      printf(\"DEBUG: COMBINING SPLIT GLYPH of chars {\");\n      for(printpos = 0; state->combine_chars[printpos]; printpos++)\n        printf(\"U+%04x \", state->combine_chars[printpos]);\n      printf(\"} + {\");\n#endif\n\n      /* Find where we need to append these combining chars */\n      int saved_i = 0;\n      while(state->combine_chars[saved_i])\n        saved_i++;\n\n      /* Add extra ones */\n      while(i < npoints && vterm_unicode_is_combining(codepoints[i])) {\n        if(saved_i >= (int)state->combine_chars_size)\n          grow_combine_buffer(state);\n        state->combine_chars[saved_i++] = codepoints[i++];\n      }\n      if(saved_i >= (int)state->combine_chars_size)\n        grow_combine_buffer(state);\n      state->combine_chars[saved_i] = 0;\n\n#ifdef DEBUG_GLYPH_COMBINE\n      for(; state->combine_chars[printpos]; printpos++)\n        printf(\"U+%04x \", state->combine_chars[printpos]);\n      printf(\"}\\n\");\n#endif\n\n      /* Now render it */\n      putglyph(state, state->combine_chars, state->combine_width, state->combine_pos);\n    }\n    else {\n      DEBUG_LOG(\"libvterm: TODO: Skip over split char+combining\\n\");\n    }\n  }\n\n  for(; i < npoints; i++) {\n    // Try to find combining characters following this\n    int glyph_starts = i;\n    int glyph_ends;\n    int width = 0;\n    uint32_t *chars;\n\n    for(glyph_ends = i + 1; glyph_ends < npoints; glyph_ends++)\n      if(!vterm_unicode_is_combining(codepoints[glyph_ends]))\n        break;\n\n    chars = vterm_allocator_malloc(state->vt, (glyph_ends - glyph_starts + 1) * sizeof(uint32_t));\n\n    for( ; i < glyph_ends; i++) {\n      int this_width;\n      chars[i - glyph_starts] = codepoints[i];\n      this_width = vterm_unicode_width(codepoints[i]);\n#ifdef DEBUG\n      if(this_width < 0) {\n        fprintf(stderr, \"Text with negative-width codepoint U+%04x\\n\", codepoints[i]);\n        abort();\n      }\n#endif\n      width += this_width;\n    }\n\n    chars[glyph_ends - glyph_starts] = 0;\n    i--;\n\n#ifdef DEBUG_GLYPH_COMBINE\n    int printpos;\n    printf(\"DEBUG: COMBINED GLYPH of %d chars {\", glyph_ends - glyph_starts);\n    for(printpos = 0; printpos < glyph_ends - glyph_starts; printpos++)\n      printf(\"U+%04x \", chars[printpos]);\n    printf(\"}, onscreen width %d\\n\", width);\n#endif\n\n    if(state->at_phantom || state->pos.col + width > THISROWWIDTH(state)) {\n      linefeed(state);\n      state->pos.col = 0;\n      state->at_phantom = 0;\n    }\n\n    if(state->mode.insert) {\n      /* TODO: This will be a little inefficient for large bodies of text, as\n       * it'll have to 'ICH' effectively before every glyph. We should scan\n       * ahead and ICH as many times as required\n       */\n      VTermRect rect;\n      rect.start_row = state->pos.row;\n      rect.end_row   = state->pos.row + 1;\n      rect.start_col = state->pos.col;\n      rect.end_col   = THISROWWIDTH(state);\n      scroll(state, rect, 0, -1);\n    }\n\n    putglyph(state, chars, width, state->pos);\n\n    if(i == npoints - 1) {\n      /* End of the buffer. Save the chars in case we have to combine with\n       * more on the next call */\n      int save_i;\n      for(save_i = 0; chars[save_i]; save_i++) {\n        if(save_i >= (int)state->combine_chars_size)\n          grow_combine_buffer(state);\n        state->combine_chars[save_i] = chars[save_i];\n      }\n      if(save_i >= (int)state->combine_chars_size)\n        grow_combine_buffer(state);\n      state->combine_chars[save_i] = 0;\n      state->combine_width = width;\n      state->combine_pos = state->pos;\n    }\n\n    if(state->pos.col + width >= THISROWWIDTH(state)) {\n      if(state->mode.autowrap)\n        state->at_phantom = 1;\n    }\n    else {\n      state->pos.col += width;\n    }\n    vterm_allocator_free(state->vt, chars);\n  }\n\n  updatecursor(state, &oldpos, 0);\n\n#ifdef DEBUG\n  if(state->pos.row < 0 || state->pos.row >= state->rows ||\n     state->pos.col < 0 || state->pos.col >= state->cols) {\n    fprintf(stderr, \"Position out of bounds after text: (%d,%d)\\n\",\n        state->pos.row, state->pos.col);\n    abort();\n  }\n#endif\n\n  vterm_allocator_free(state->vt, codepoints);\n  return (int)eaten;\n}\n\nstatic int on_control(unsigned char control, void *user)\n{\n  VTermState *state = user;\n\n  VTermPos oldpos = state->pos;\n\n  switch(control) {\n  case 0x07: // BEL - ECMA-48 8.3.3\n    if(state->callbacks && state->callbacks->bell)\n      (*state->callbacks->bell)(state->cbdata);\n    break;\n\n  case 0x08: // BS - ECMA-48 8.3.5\n    if(state->pos.col > 0)\n      state->pos.col--;\n    break;\n\n  case 0x09: // HT - ECMA-48 8.3.60\n    tab(state, 1, +1);\n    break;\n\n  case 0x0a: // LF - ECMA-48 8.3.74\n  case 0x0b: // VT\n  case 0x0c: // FF\n    linefeed(state);\n    if(state->mode.newline)\n      state->pos.col = 0;\n    break;\n\n  case 0x0d: // CR - ECMA-48 8.3.15\n    state->pos.col = 0;\n    break;\n\n  case 0x0e: // LS1 - ECMA-48 8.3.76\n    state->gl_set = 1;\n    break;\n\n  case 0x0f: // LS0 - ECMA-48 8.3.75\n    state->gl_set = 0;\n    break;\n\n  case 0x84: // IND - DEPRECATED but implemented for completeness\n    linefeed(state);\n    break;\n\n  case 0x85: // NEL - ECMA-48 8.3.86\n    linefeed(state);\n    state->pos.col = 0;\n    break;\n\n  case 0x88: // HTS - ECMA-48 8.3.62\n    set_col_tabstop(state, state->pos.col);\n    break;\n\n  case 0x8d: // RI - ECMA-48 8.3.104\n    if(state->pos.row == state->scrollregion_top) {\n      VTermRect rect;\n      rect.start_row = state->scrollregion_top;\n      rect.end_row   = SCROLLREGION_BOTTOM(state);\n      rect.start_col = SCROLLREGION_LEFT(state);\n      rect.end_col   = SCROLLREGION_RIGHT(state);\n\n      scroll(state, rect, -1, 0);\n    }\n    else if(state->pos.row > 0)\n        state->pos.row--;\n    break;\n\n  case 0x8e: // SS2 - ECMA-48 8.3.141\n    state->gsingle_set = 2;\n    break;\n\n  case 0x8f: // SS3 - ECMA-48 8.3.142\n    state->gsingle_set = 3;\n    break;\n\n  default:\n    if(state->fallbacks && state->fallbacks->control)\n      if((*state->fallbacks->control)(control, state->fbdata))\n        return 1;\n\n    return 0;\n  }\n\n  updatecursor(state, &oldpos, 1);\n\n#ifdef DEBUG\n  if(state->pos.row < 0 || state->pos.row >= state->rows ||\n     state->pos.col < 0 || state->pos.col >= state->cols) {\n    fprintf(stderr, \"Position out of bounds after Ctrl %02x: (%d,%d)\\n\",\n        control, state->pos.row, state->pos.col);\n    abort();\n  }\n#endif\n\n  return 1;\n}\n\nstatic int settermprop_bool(VTermState *state, VTermProp prop, int v)\n{\n  VTermValue val;\n  val.boolean = v;\n  return vterm_state_set_termprop(state, prop, &val);\n}\n\nstatic int settermprop_int(VTermState *state, VTermProp prop, int v)\n{\n  VTermValue val;\n  val.number = v;\n  return vterm_state_set_termprop(state, prop, &val);\n}\n\nstatic int settermprop_string(VTermState *state, VTermProp prop, const char *str, size_t len)\n{\n  char *strvalue;\n  int r;\n  VTermValue val;\n  strvalue = vterm_allocator_malloc(state->vt, (len+1) * sizeof(char));\n  strncpy(strvalue, str, len);\n  strvalue[len] = 0;\n\n  val.string = strvalue;\n  r = vterm_state_set_termprop(state, prop, &val);\n  vterm_allocator_free(state->vt, strvalue);\n  return r;\n}\n\nstatic void savecursor(VTermState *state, int save)\n{\n  if(save) {\n    state->saved.pos = state->pos;\n    state->saved.mode.cursor_visible = state->mode.cursor_visible;\n    state->saved.mode.cursor_blink   = state->mode.cursor_blink;\n    state->saved.mode.cursor_shape   = state->mode.cursor_shape;\n\n    vterm_state_savepen(state, 1);\n  }\n  else {\n    VTermPos oldpos = state->pos;\n\n    state->pos = state->saved.pos;\n\n    settermprop_bool(state, VTERM_PROP_CURSORVISIBLE, state->saved.mode.cursor_visible);\n    settermprop_bool(state, VTERM_PROP_CURSORBLINK,   state->saved.mode.cursor_blink);\n    settermprop_int (state, VTERM_PROP_CURSORSHAPE,   state->saved.mode.cursor_shape);\n\n    vterm_state_savepen(state, 0);\n\n    updatecursor(state, &oldpos, 1);\n  }\n}\n\nstatic int on_escape(const char *bytes, size_t len, void *user)\n{\n  VTermState *state = user;\n\n  /* Easier to decode this from the first byte, even though the final\n   * byte terminates it\n   */\n  switch(bytes[0]) {\n  case ' ':\n    if(len != 2)\n      return 0;\n\n    switch(bytes[1]) {\n      case 'F': // S7C1T\n        state->vt->mode.ctrl8bit = 0;\n        break;\n\n      case 'G': // S8C1T\n        state->vt->mode.ctrl8bit = 1;\n        break;\n\n      default:\n        return 0;\n    }\n    return 2;\n\n  case '#':\n    if(len != 2)\n      return 0;\n\n    switch(bytes[1]) {\n      case '3': // DECDHL top\n        if(state->mode.leftrightmargin)\n          break;\n        set_lineinfo(state, state->pos.row, NO_FORCE, DWL_ON, DHL_TOP);\n        break;\n\n      case '4': // DECDHL bottom\n        if(state->mode.leftrightmargin)\n          break;\n        set_lineinfo(state, state->pos.row, NO_FORCE, DWL_ON, DHL_BOTTOM);\n        break;\n\n      case '5': // DECSWL\n        if(state->mode.leftrightmargin)\n          break;\n        set_lineinfo(state, state->pos.row, NO_FORCE, DWL_OFF, DHL_OFF);\n        break;\n\n      case '6': // DECDWL\n        if(state->mode.leftrightmargin)\n          break;\n        set_lineinfo(state, state->pos.row, NO_FORCE, DWL_ON, DHL_OFF);\n        break;\n\n      case '8': // DECALN\n      {\n        VTermPos pos;\n        uint32_t E[] = { 'E', 0 };\n        for(pos.row = 0; pos.row < state->rows; pos.row++)\n          for(pos.col = 0; pos.col < ROWWIDTH(state, pos.row); pos.col++)\n            putglyph(state, E, 1, pos);\n        break;\n      }\n\n      default:\n        return 0;\n    }\n    return 2;\n\n  case '(': case ')': case '*': case '+': // SCS\n    if(len != 2)\n      return 0;\n\n    {\n      int setnum = bytes[0] - 0x28;\n      VTermEncoding *newenc = vterm_lookup_encoding(ENC_SINGLE_94, bytes[1]);\n\n      if(newenc) {\n        state->encoding[setnum].enc = newenc;\n\n        if(newenc->init)\n          (*newenc->init)(newenc, state->encoding[setnum].data);\n      }\n    }\n\n    return 2;\n\n  case '7': // DECSC\n    savecursor(state, 1);\n    return 1;\n\n  case '8': // DECRC\n    savecursor(state, 0);\n    return 1;\n\n  case '<': // Ignored by VT100. Used in VT52 mode to switch up to VT100\n    return 1;\n\n  case '=': // DECKPAM\n    state->mode.keypad = 1;\n    return 1;\n\n  case '>': // DECKPNM\n    state->mode.keypad = 0;\n    return 1;\n\n  case 'c': // RIS - ECMA-48 8.3.105\n  {\n    VTermPos oldpos = state->pos;\n    vterm_state_reset(state, 1);\n    if(state->callbacks && state->callbacks->movecursor)\n      (*state->callbacks->movecursor)(state->pos, oldpos, state->mode.cursor_visible, state->cbdata);\n    return 1;\n  }\n\n  case 'n': // LS2 - ECMA-48 8.3.78\n    state->gl_set = 2;\n    return 1;\n\n  case 'o': // LS3 - ECMA-48 8.3.80\n    state->gl_set = 3;\n    return 1;\n\n  case '~': // LS1R - ECMA-48 8.3.77\n    state->gr_set = 1;\n    return 1;\n\n  case '}': // LS2R - ECMA-48 8.3.79\n    state->gr_set = 2;\n    return 1;\n\n  case '|': // LS3R - ECMA-48 8.3.81\n    state->gr_set = 3;\n    return 1;\n\n  default:\n    return 0;\n  }\n}\n\nstatic void set_mode(VTermState *state, int num, int val)\n{\n  switch(num) {\n  case 4: // IRM - ECMA-48 7.2.10\n    state->mode.insert = val;\n    break;\n\n  case 20: // LNM - ANSI X3.4-1977\n    state->mode.newline = val;\n    break;\n\n  default:\n    DEBUG_LOG1(\"libvterm: Unknown mode %d\\n\", num);\n    return;\n  }\n}\n\nstatic void set_dec_mode(VTermState *state, int num, int val)\n{\n  switch(num) {\n  case 1:\n    state->mode.cursor = val;\n    break;\n\n  case 5: // DECSCNM - screen mode\n    settermprop_bool(state, VTERM_PROP_REVERSE, val);\n    break;\n\n  case 6: // DECOM - origin mode\n    {\n      VTermPos oldpos = state->pos;\n      state->mode.origin = val;\n      state->pos.row = state->mode.origin ? state->scrollregion_top : 0;\n      state->pos.col = state->mode.origin ? SCROLLREGION_LEFT(state) : 0;\n      updatecursor(state, &oldpos, 1);\n    }\n    break;\n\n  case 7:\n    state->mode.autowrap = val;\n    break;\n\n  case 12:\n    settermprop_bool(state, VTERM_PROP_CURSORBLINK, val);\n    break;\n\n  case 25:\n    settermprop_bool(state, VTERM_PROP_CURSORVISIBLE, val);\n    break;\n\n  case 69: // DECVSSM - vertical split screen mode\n           // DECLRMM - left/right margin mode\n    state->mode.leftrightmargin = val;\n    if(val) {\n      int row;\n\n      // Setting DECVSSM must clear doublewidth/doubleheight state of every line\n      for(row = 0; row < state->rows; row++)\n        set_lineinfo(state, row, FORCE, DWL_OFF, DHL_OFF);\n    }\n\n    break;\n\n  case 1000:\n  case 1002:\n  case 1003:\n    settermprop_int(state, VTERM_PROP_MOUSE,\n        !val          ? VTERM_PROP_MOUSE_NONE  :\n        (num == 1000) ? VTERM_PROP_MOUSE_CLICK :\n        (num == 1002) ? VTERM_PROP_MOUSE_DRAG  :\n                        VTERM_PROP_MOUSE_MOVE);\n    break;\n\n  case 1004:\n    state->mode.report_focus = val;\n    break;\n\n  case 1005:\n    state->mouse_protocol = val ? MOUSE_UTF8 : MOUSE_X10;\n    break;\n\n  case 1006:\n    state->mouse_protocol = val ? MOUSE_SGR : MOUSE_X10;\n    break;\n\n  case 1015:\n    state->mouse_protocol = val ? MOUSE_RXVT : MOUSE_X10;\n    break;\n\n  case 1047:\n    settermprop_bool(state, VTERM_PROP_ALTSCREEN, val);\n    break;\n\n  case 1048:\n    savecursor(state, val);\n    break;\n\n  case 1049:\n    settermprop_bool(state, VTERM_PROP_ALTSCREEN, val);\n    savecursor(state, val);\n    break;\n\n  case 2004:\n    state->mode.bracketpaste = val;\n    break;\n\n  default:\n    DEBUG_LOG1(\"libvterm: Unknown DEC mode %d\\n\", num);\n    return;\n  }\n}\n\nstatic void request_dec_mode(VTermState *state, int num)\n{\n  int reply;\n\n  switch(num) {\n    case 1:\n      reply = state->mode.cursor;\n      break;\n\n    case 5:\n      reply = state->mode.screen;\n      break;\n\n    case 6:\n      reply = state->mode.origin;\n      break;\n\n    case 7:\n      reply = state->mode.autowrap;\n      break;\n\n    case 12:\n      reply = state->mode.cursor_blink;\n      break;\n\n    case 25:\n      reply = state->mode.cursor_visible;\n      break;\n\n    case 69:\n      reply = state->mode.leftrightmargin;\n      break;\n\n    case 1000:\n      reply = state->mouse_flags == MOUSE_WANT_CLICK;\n      break;\n\n    case 1002:\n      reply = state->mouse_flags == (MOUSE_WANT_CLICK|MOUSE_WANT_DRAG);\n      break;\n\n    case 1003:\n      reply = state->mouse_flags == (MOUSE_WANT_CLICK|MOUSE_WANT_MOVE);\n      break;\n\n    case 1004:\n      reply = state->mode.report_focus;\n      break;\n\n    case 1005:\n      reply = state->mouse_protocol == MOUSE_UTF8;\n      break;\n\n    case 1006:\n      reply = state->mouse_protocol == MOUSE_SGR;\n      break;\n\n    case 1015:\n      reply = state->mouse_protocol == MOUSE_RXVT;\n      break;\n\n    case 1047:\n      reply = state->mode.alt_screen;\n      break;\n\n    case 2004:\n      reply = state->mode.bracketpaste;\n      break;\n\n    default:\n      vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"?%d;%d$y\", num, 0);\n      return;\n  }\n\n  vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"?%d;%d$y\", num, reply ? 1 : 2);\n}\n\nstatic int on_csi(const char *leader, const long args[], int argcount, const char *intermed, char command, void *user)\n{\n  VTermState *state = user;\n  int leader_byte = 0;\n  int intermed_byte = 0;\n  VTermPos oldpos = state->pos;\n\n  /* Some temporaries for later code */\n  int count, val;\n  int row, col;\n  VTermRect rect;\n  int selective;\n\n  if(leader && leader[0]) {\n    if(leader[1]) // longer than 1 char\n      return 0;\n\n    switch(leader[0]) {\n    case '?':\n    case '>':\n      leader_byte = leader[0];\n      break;\n    default:\n      return 0;\n    }\n  }\n\n  if(intermed && intermed[0]) {\n    if(intermed[1]) // longer than 1 char\n      return 0;\n\n    switch(intermed[0]) {\n    case ' ':\n    case '\"':\n    case '$':\n    case '\\'':\n      intermed_byte = intermed[0];\n      break;\n    default:\n      return 0;\n    }\n  }\n\n  oldpos = state->pos;\n\n#define LBOUND(v,min) if((v) < (min)) (v) = (min)\n#define UBOUND(v,max) if((v) > (max)) (v) = (max)\n\n#define LEADER(l,b) ((l << 8) | b)\n#define INTERMED(i,b) ((i << 16) | b)\n\n  switch(intermed_byte << 16 | leader_byte << 8 | command) {\n  case 0x40: // ICH - ECMA-48 8.3.64\n    count = CSI_ARG_COUNT(args[0]);\n\n    if(!is_cursor_in_scrollregion(state))\n      break;\n\n    rect.start_row = state->pos.row;\n    rect.end_row   = state->pos.row + 1;\n    rect.start_col = state->pos.col;\n    if(state->mode.leftrightmargin)\n      rect.end_col = SCROLLREGION_RIGHT(state);\n    else\n      rect.end_col = THISROWWIDTH(state);\n\n    scroll(state, rect, 0, -count);\n\n    break;\n\n  case 0x41: // CUU - ECMA-48 8.3.22\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.row -= count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x42: // CUD - ECMA-48 8.3.19\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.row += count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x43: // CUF - ECMA-48 8.3.20\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.col += count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x44: // CUB - ECMA-48 8.3.18\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.col -= count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x45: // CNL - ECMA-48 8.3.12\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.col = 0;\n    state->pos.row += count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x46: // CPL - ECMA-48 8.3.13\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.col = 0;\n    state->pos.row -= count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x47: // CHA - ECMA-48 8.3.9\n    val = CSI_ARG_OR(args[0], 1);\n    state->pos.col = val-1;\n    state->at_phantom = 0;\n    break;\n\n  case 0x48: // CUP - ECMA-48 8.3.21\n    row = CSI_ARG_OR(args[0], 1);\n    col = argcount < 2 || CSI_ARG_IS_MISSING(args[1]) ? 1 : CSI_ARG(args[1]);\n    // zero-based\n    state->pos.row = row-1;\n    state->pos.col = col-1;\n    if(state->mode.origin) {\n      state->pos.row += state->scrollregion_top;\n      state->pos.col += SCROLLREGION_LEFT(state);\n    }\n    state->at_phantom = 0;\n    break;\n\n  case 0x49: // CHT - ECMA-48 8.3.10\n    count = CSI_ARG_COUNT(args[0]);\n    tab(state, count, +1);\n    break;\n\n  case 0x4a: // ED - ECMA-48 8.3.39\n  case LEADER('?', 0x4a): // DECSED - Selective Erase in Display\n    selective = (leader_byte == '?');\n    switch(CSI_ARG(args[0])) {\n    case CSI_ARG_MISSING:\n    case 0:\n      rect.start_row = state->pos.row; rect.end_row = state->pos.row + 1;\n      rect.start_col = state->pos.col; rect.end_col = state->cols;\n      if(rect.end_col > rect.start_col)\n        erase(state, rect, selective);\n\n      rect.start_row = state->pos.row + 1; rect.end_row = state->rows;\n      rect.start_col = 0;\n      for(row = rect.start_row; row < rect.end_row; row++)\n\tset_lineinfo(state, row, FORCE, DWL_OFF, DHL_OFF);\n      if(rect.end_row > rect.start_row)\n        erase(state, rect, selective);\n      break;\n\n    case 1:\n      rect.start_row = 0; rect.end_row = state->pos.row;\n      rect.start_col = 0; rect.end_col = state->cols;\n      for(row = rect.start_row; row < rect.end_row; row++)\n\tset_lineinfo(state, row, FORCE, DWL_OFF, DHL_OFF);\n      if(rect.end_col > rect.start_col)\n        erase(state, rect, selective);\n\n      rect.start_row = state->pos.row; rect.end_row = state->pos.row + 1;\n                          rect.end_col = state->pos.col + 1;\n      if(rect.end_row > rect.start_row)\n        erase(state, rect, selective);\n      break;\n\n    case 2:\n      rect.start_row = 0; rect.end_row = state->rows;\n      rect.start_col = 0; rect.end_col = state->cols;\n      for(row = rect.start_row; row < rect.end_row; row++)\n\tset_lineinfo(state, row, FORCE, DWL_OFF, DHL_OFF);\n      erase(state, rect, selective);\n      break;\n    }\n    break;\n\n  case 0x4b: // EL - ECMA-48 8.3.41\n  case LEADER('?', 0x4b): // DECSEL - Selective Erase in Line\n    selective = (leader_byte == '?');\n    rect.start_row = state->pos.row;\n    rect.end_row   = state->pos.row + 1;\n\n    switch(CSI_ARG(args[0])) {\n    case CSI_ARG_MISSING:\n    case 0:\n      rect.start_col = state->pos.col; rect.end_col = THISROWWIDTH(state); break;\n    case 1:\n      rect.start_col = 0; rect.end_col = state->pos.col + 1; break;\n    case 2:\n      rect.start_col = 0; rect.end_col = THISROWWIDTH(state); break;\n    default:\n      return 0;\n    }\n\n    if(rect.end_col > rect.start_col)\n      erase(state, rect, selective);\n\n    break;\n\n  case 0x4c: // IL - ECMA-48 8.3.67\n    count = CSI_ARG_COUNT(args[0]);\n\n    if(!is_cursor_in_scrollregion(state))\n      break;\n\n    rect.start_row = state->pos.row;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = SCROLLREGION_LEFT(state);\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, -count, 0);\n\n    break;\n\n  case 0x4d: // DL - ECMA-48 8.3.32\n    count = CSI_ARG_COUNT(args[0]);\n\n    if(!is_cursor_in_scrollregion(state))\n      break;\n\n    rect.start_row = state->pos.row;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = SCROLLREGION_LEFT(state);\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, count, 0);\n\n    break;\n\n  case 0x50: // DCH - ECMA-48 8.3.26\n    count = CSI_ARG_COUNT(args[0]);\n\n    if(!is_cursor_in_scrollregion(state))\n      break;\n\n    rect.start_row = state->pos.row;\n    rect.end_row   = state->pos.row + 1;\n    rect.start_col = state->pos.col;\n    if(state->mode.leftrightmargin)\n      rect.end_col = SCROLLREGION_RIGHT(state);\n    else\n      rect.end_col = THISROWWIDTH(state);\n\n    scroll(state, rect, 0, count);\n\n    break;\n\n  case 0x53: // SU - ECMA-48 8.3.147\n    count = CSI_ARG_COUNT(args[0]);\n\n    rect.start_row = state->scrollregion_top;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = SCROLLREGION_LEFT(state);\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, count, 0);\n\n    break;\n\n  case 0x54: // SD - ECMA-48 8.3.113\n    count = CSI_ARG_COUNT(args[0]);\n\n    rect.start_row = state->scrollregion_top;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = SCROLLREGION_LEFT(state);\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, -count, 0);\n\n    break;\n\n  case 0x58: // ECH - ECMA-48 8.3.38\n    count = CSI_ARG_COUNT(args[0]);\n\n    rect.start_row = state->pos.row;\n    rect.end_row   = state->pos.row + 1;\n    rect.start_col = state->pos.col;\n    rect.end_col   = state->pos.col + count;\n    UBOUND(rect.end_col, THISROWWIDTH(state));\n\n    erase(state, rect, 0);\n    break;\n\n  case 0x5a: // CBT - ECMA-48 8.3.7\n    count = CSI_ARG_COUNT(args[0]);\n    tab(state, count, -1);\n    break;\n\n  case 0x60: // HPA - ECMA-48 8.3.57\n    col = CSI_ARG_OR(args[0], 1);\n    state->pos.col = col-1;\n    state->at_phantom = 0;\n    break;\n\n  case 0x61: // HPR - ECMA-48 8.3.59\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.col += count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x63: // DA - ECMA-48 8.3.24\n    val = CSI_ARG_OR(args[0], 0);\n    if(val == 0)\n      // DEC VT100 response\n      vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"?1;2c\");\n    break;\n\n  case LEADER('>', 0x63): // DEC secondary Device Attributes\n    // This returns xterm version number 100.\n    vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \">%d;%d;%dc\", 0, 100, 0);\n    break;\n\n  case 0x64: // VPA - ECMA-48 8.3.158\n    row = CSI_ARG_OR(args[0], 1);\n    state->pos.row = row-1;\n    if(state->mode.origin)\n      state->pos.row += state->scrollregion_top;\n    state->at_phantom = 0;\n    break;\n\n  case 0x65: // VPR - ECMA-48 8.3.160\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.row += count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x66: // HVP - ECMA-48 8.3.63\n    row = CSI_ARG_OR(args[0], 1);\n    col = argcount < 2 || CSI_ARG_IS_MISSING(args[1]) ? 1 : CSI_ARG(args[1]);\n    // zero-based\n    state->pos.row = row-1;\n    state->pos.col = col-1;\n    if(state->mode.origin) {\n      state->pos.row += state->scrollregion_top;\n      state->pos.col += SCROLLREGION_LEFT(state);\n    }\n    state->at_phantom = 0;\n    break;\n\n  case 0x67: // TBC - ECMA-48 8.3.154\n    val = CSI_ARG_OR(args[0], 0);\n\n    switch(val) {\n    case 0:\n      clear_col_tabstop(state, state->pos.col);\n      break;\n    case 3:\n    case 5:\n      for(col = 0; col < state->cols; col++)\n        clear_col_tabstop(state, col);\n      break;\n    case 1:\n    case 2:\n    case 4:\n      break;\n    /* TODO: 1, 2 and 4 aren't meaningful yet without line tab stops */\n    default:\n      return 0;\n    }\n    break;\n\n  case 0x68: // SM - ECMA-48 8.3.125\n    if(!CSI_ARG_IS_MISSING(args[0]))\n      set_mode(state, CSI_ARG(args[0]), 1);\n    break;\n\n  case LEADER('?', 0x68): // DEC private mode set\n    if(!CSI_ARG_IS_MISSING(args[0]))\n      set_dec_mode(state, CSI_ARG(args[0]), 1);\n    break;\n\n  case 0x6a: // HPB - ECMA-48 8.3.58\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.col -= count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x6b: // VPB - ECMA-48 8.3.159\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.row -= count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x6c: // RM - ECMA-48 8.3.106\n    if(!CSI_ARG_IS_MISSING(args[0]))\n      set_mode(state, CSI_ARG(args[0]), 0);\n    break;\n\n  case LEADER('?', 0x6c): // DEC private mode reset\n    if(!CSI_ARG_IS_MISSING(args[0]))\n      set_dec_mode(state, CSI_ARG(args[0]), 0);\n    break;\n\n  case 0x6d: // SGR - ECMA-48 8.3.117\n    vterm_state_setpen(state, args, argcount);\n    break;\n\n  case 0x6e: // DSR - ECMA-48 8.3.35\n  case LEADER('?', 0x6e): // DECDSR\n    val = CSI_ARG_OR(args[0], 0);\n\n    {\n      char *qmark = (leader_byte == '?') ? \"?\" : \"\";\n\n      switch(val) {\n      case 0: case 1: case 2: case 3: case 4:\n        // ignore - these are replies\n        break;\n      case 5:\n        vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"%s0n\", qmark);\n        break;\n      case 6: // CPR - cursor position report\n        vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"%s%d;%dR\", qmark, state->pos.row + 1, state->pos.col + 1);\n        break;\n      }\n    }\n    break;\n\n\n  case LEADER('!', 0x70): // DECSTR - DEC soft terminal reset\n    vterm_state_reset(state, 0);\n    break;\n\n  case LEADER('?', INTERMED('$', 0x70)):\n    request_dec_mode(state, CSI_ARG(args[0]));\n    break;\n\n  case INTERMED(' ', 0x71): // DECSCUSR - DEC set cursor shape\n    val = CSI_ARG_OR(args[0], 1);\n\n    switch(val) {\n    case 0: case 1:\n      settermprop_bool(state, VTERM_PROP_CURSORBLINK, 1);\n      settermprop_int (state, VTERM_PROP_CURSORSHAPE, VTERM_PROP_CURSORSHAPE_BLOCK);\n      break;\n    case 2:\n      settermprop_bool(state, VTERM_PROP_CURSORBLINK, 0);\n      settermprop_int (state, VTERM_PROP_CURSORSHAPE, VTERM_PROP_CURSORSHAPE_BLOCK);\n      break;\n    case 3:\n      settermprop_bool(state, VTERM_PROP_CURSORBLINK, 1);\n      settermprop_int (state, VTERM_PROP_CURSORSHAPE, VTERM_PROP_CURSORSHAPE_UNDERLINE);\n      break;\n    case 4:\n      settermprop_bool(state, VTERM_PROP_CURSORBLINK, 0);\n      settermprop_int (state, VTERM_PROP_CURSORSHAPE, VTERM_PROP_CURSORSHAPE_UNDERLINE);\n      break;\n    case 5:\n      settermprop_bool(state, VTERM_PROP_CURSORBLINK, 1);\n      settermprop_int (state, VTERM_PROP_CURSORSHAPE, VTERM_PROP_CURSORSHAPE_BAR_LEFT);\n      break;\n    case 6:\n      settermprop_bool(state, VTERM_PROP_CURSORBLINK, 0);\n      settermprop_int (state, VTERM_PROP_CURSORSHAPE, VTERM_PROP_CURSORSHAPE_BAR_LEFT);\n      break;\n    }\n\n    break;\n\n  case INTERMED('\"', 0x71): // DECSCA - DEC select character protection attribute\n    val = CSI_ARG_OR(args[0], 0);\n\n    switch(val) {\n    case 0: case 2:\n      state->protected_cell = 0;\n      break;\n    case 1:\n      state->protected_cell = 1;\n      break;\n    }\n\n    break;\n\n  case 0x72: // DECSTBM - DEC custom\n    state->scrollregion_top = CSI_ARG_OR(args[0], 1) - 1;\n    state->scrollregion_bottom = argcount < 2 || CSI_ARG_IS_MISSING(args[1]) ? -1 : CSI_ARG(args[1]);\n    LBOUND(state->scrollregion_top, 0);\n    UBOUND(state->scrollregion_top, state->rows);\n    LBOUND(state->scrollregion_bottom, -1);\n    if(state->scrollregion_top == 0 && state->scrollregion_bottom == state->rows)\n      state->scrollregion_bottom = -1;\n    else\n      UBOUND(state->scrollregion_bottom, state->rows);\n\n    if(SCROLLREGION_BOTTOM(state) <= state->scrollregion_top) {\n      // Invalid\n      state->scrollregion_top    = 0;\n      state->scrollregion_bottom = -1;\n    }\n\n    break;\n\n  case 0x73: // DECSLRM - DEC custom\n    // Always allow setting these margins, just they won't take effect without DECVSSM\n    state->scrollregion_left = CSI_ARG_OR(args[0], 1) - 1;\n    state->scrollregion_right = argcount < 2 || CSI_ARG_IS_MISSING(args[1]) ? -1 : CSI_ARG(args[1]);\n    LBOUND(state->scrollregion_left, 0);\n    UBOUND(state->scrollregion_left, state->cols);\n    LBOUND(state->scrollregion_right, -1);\n    if(state->scrollregion_left == 0 && state->scrollregion_right == state->cols)\n      state->scrollregion_right = -1;\n    else\n      UBOUND(state->scrollregion_right, state->cols);\n\n    if(state->scrollregion_right > -1 &&\n       state->scrollregion_right <= state->scrollregion_left) {\n      // Invalid\n      state->scrollregion_left  = 0;\n      state->scrollregion_right = -1;\n    }\n\n    break;\n\n  case 0x74:\n    switch(CSI_ARG(args[0])) {\n      case 8: /* CSI 8 ; rows ; cols t  set size */\n\tif (argcount == 3)\n\t  on_resize(CSI_ARG(args[1]), CSI_ARG(args[2]), state);\n    }\n    break;\n\n  case INTERMED('\\'', 0x7D): // DECIC\n    count = CSI_ARG_COUNT(args[0]);\n\n    if(!is_cursor_in_scrollregion(state))\n      break;\n\n    rect.start_row = state->scrollregion_top;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = state->pos.col;\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, 0, -count);\n\n    break;\n\n  case INTERMED('\\'', 0x7E): // DECDC\n    count = CSI_ARG_COUNT(args[0]);\n\n    if(!is_cursor_in_scrollregion(state))\n      break;\n\n    rect.start_row = state->scrollregion_top;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = state->pos.col;\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, 0, count);\n\n    break;\n\n  default:\n    if(state->fallbacks && state->fallbacks->csi)\n      if((*state->fallbacks->csi)(leader, args, argcount, intermed, command, state->fbdata))\n        return 1;\n\n    return 0;\n  }\n\n  if(state->mode.origin) {\n    LBOUND(state->pos.row, state->scrollregion_top);\n    UBOUND(state->pos.row, SCROLLREGION_BOTTOM(state)-1);\n    LBOUND(state->pos.col, SCROLLREGION_LEFT(state));\n    UBOUND(state->pos.col, SCROLLREGION_RIGHT(state)-1);\n  }\n  else {\n    LBOUND(state->pos.row, 0);\n    UBOUND(state->pos.row, state->rows-1);\n    LBOUND(state->pos.col, 0);\n    UBOUND(state->pos.col, THISROWWIDTH(state)-1);\n  }\n\n  updatecursor(state, &oldpos, 1);\n\n#ifdef DEBUG\n  if(state->pos.row < 0 || state->pos.row >= state->rows ||\n     state->pos.col < 0 || state->pos.col >= state->cols) {\n    fprintf(stderr, \"Position out of bounds after CSI %c: (%d,%d)\\n\",\n        command, state->pos.row, state->pos.col);\n    abort();\n  }\n\n  if(SCROLLREGION_BOTTOM(state) <= state->scrollregion_top) {\n    fprintf(stderr, \"Scroll region height out of bounds after CSI %c: %d <= %d\\n\",\n        command, SCROLLREGION_BOTTOM(state), state->scrollregion_top);\n    abort();\n  }\n\n  if(SCROLLREGION_RIGHT(state) <= SCROLLREGION_LEFT(state)) {\n    fprintf(stderr, \"Scroll region width out of bounds after CSI %c: %d <= %d\\n\",\n        command, SCROLLREGION_RIGHT(state), SCROLLREGION_LEFT(state));\n    abort();\n  }\n#endif\n\n  return 1;\n}\n\nstatic int on_osc(const char *command, size_t cmdlen, void *user)\n{\n  VTermState *state = user;\n\n  if(cmdlen < 2)\n    return 0;\n\n  if(strneq(command, \"0;\", 2)) {\n    settermprop_string(state, VTERM_PROP_ICONNAME, command + 2, cmdlen - 2);\n    settermprop_string(state, VTERM_PROP_TITLE, command + 2, cmdlen - 2);\n    return 1;\n  }\n  else if(strneq(command, \"1;\", 2)) {\n    settermprop_string(state, VTERM_PROP_ICONNAME, command + 2, cmdlen - 2);\n    return 1;\n  }\n  else if(strneq(command, \"2;\", 2)) {\n    settermprop_string(state, VTERM_PROP_TITLE, command + 2, cmdlen - 2);\n    return 1;\n  }\n  else if(strneq(command, \"10;\", 3)) {\n    /* request foreground color: <Esc>]10;?<0x07> */\n    int red = state->default_fg.red;\n    int blue = state->default_fg.blue;\n    int green = state->default_fg.green;\n    vterm_push_output_sprintf_ctrl(state->vt, C1_OSC, \"10;rgb:%02x%02x/%02x%02x/%02x%02x\\x07\", red, red, green, green, blue, blue);\n    return 1;\n  }\n  else if(strneq(command, \"11;\", 3)) {\n    /* request background color: <Esc>]11;?<0x07> */\n    int red = state->default_bg.red;\n    int blue = state->default_bg.blue;\n    int green = state->default_bg.green;\n    vterm_push_output_sprintf_ctrl(state->vt, C1_OSC, \"11;rgb:%02x%02x/%02x%02x/%02x%02x\\x07\", red, red, green, green, blue, blue);\n    return 1;\n  }\n  else if(strneq(command, \"12;\", 3)) {\n    settermprop_string(state, VTERM_PROP_CURSORCOLOR, command + 3, cmdlen - 3);\n    return 1;\n  }\n  else if(state->fallbacks && state->fallbacks->osc)\n    if((*state->fallbacks->osc)(command, cmdlen, state->fbdata))\n      return 1;\n\n  return 0;\n}\n\nstatic void request_status_string(VTermState *state, const char *command, size_t cmdlen)\n{\n  if(cmdlen == 1)\n    switch(command[0]) {\n      case 'm': // Query SGR\n        {\n          long args[20];\n          int argc = vterm_state_getpen(state, args, sizeof(args)/sizeof(args[0]));\n\t  int argi;\n          vterm_push_output_sprintf_ctrl(state->vt, C1_DCS, \"1$r\");\n          for(argi = 0; argi < argc; argi++)\n            vterm_push_output_sprintf(state->vt,\n                argi == argc - 1             ? \"%d\" :\n                CSI_ARG_HAS_MORE(args[argi]) ? \"%d:\" :\n                                               \"%d;\",\n                CSI_ARG(args[argi]));\n          vterm_push_output_sprintf(state->vt, \"m\");\n          vterm_push_output_sprintf_ctrl(state->vt, C1_ST, \"\");\n        }\n        return;\n      case 'r': // Query DECSTBM\n        vterm_push_output_sprintf_dcs(state->vt, \"1$r%d;%dr\", state->scrollregion_top+1, SCROLLREGION_BOTTOM(state));\n        return;\n      case 's': // Query DECSLRM\n        vterm_push_output_sprintf_dcs(state->vt, \"1$r%d;%ds\", SCROLLREGION_LEFT(state)+1, SCROLLREGION_RIGHT(state));\n        return;\n    }\n\n  if(cmdlen == 2) {\n    if(strneq(command, \" q\", 2)) {\n      int reply;\n      switch(state->mode.cursor_shape) {\n        case VTERM_PROP_CURSORSHAPE_BLOCK:     reply = 2; break;\n        case VTERM_PROP_CURSORSHAPE_UNDERLINE: reply = 4; break;\n\tdefault: /* VTERM_PROP_CURSORSHAPE_BAR_LEFT */  reply = 6; break;\n      }\n      if(state->mode.cursor_blink)\n        reply--;\n      vterm_push_output_sprintf_dcs(state->vt, \"1$r%d q\", reply);\n      return;\n    }\n    else if(strneq(command, \"\\\"q\", 2)) {\n      vterm_push_output_sprintf_dcs(state->vt, \"1$r%d\\\"q\", state->protected_cell ? 1 : 2);\n      return;\n    }\n  }\n\n  vterm_push_output_sprintf_dcs(state->vt, \"0$r%.s\", (int)cmdlen, command);\n}\n\nstatic int on_dcs(const char *command, size_t cmdlen, void *user)\n{\n  VTermState *state = user;\n\n  if(cmdlen >= 2 && strneq(command, \"$q\", 2)) {\n    request_status_string(state, command+2, cmdlen-2);\n    return 1;\n  }\n  else if(state->fallbacks && state->fallbacks->dcs)\n    if((*state->fallbacks->dcs)(command, cmdlen, state->fbdata))\n      return 1;\n\n  return 0;\n}\n\nstatic int on_resize(int rows, int cols, void *user)\n{\n  VTermState *state = user;\n  VTermPos oldpos = state->pos;\n  VTermPos delta = { 0, 0 };\n\n  if(cols != state->cols) {\n    unsigned char *newtabstops = vterm_allocator_malloc(state->vt, (cols + 7) / 8);\n\n    /* TODO: This can all be done much more efficiently bytewise */\n    int col;\n    for(col = 0; col < state->cols && col < cols; col++) {\n      unsigned char mask = 1 << (col & 7);\n      if(state->tabstops[col >> 3] & mask)\n        newtabstops[col >> 3] |= mask;\n      else\n        newtabstops[col >> 3] &= ~mask;\n      }\n\n    for( ; col < cols; col++) {\n      unsigned char mask = 1 << (col & 7);\n      if(col % 8 == 0)\n        newtabstops[col >> 3] |= mask;\n      else\n        newtabstops[col >> 3] &= ~mask;\n    }\n\n    vterm_allocator_free(state->vt, state->tabstops);\n    state->tabstops = newtabstops;\n  }\n\n  if(rows != state->rows) {\n    VTermLineInfo *newlineinfo = vterm_allocator_malloc(state->vt, rows * sizeof(VTermLineInfo));\n\n    int row;\n    for(row = 0; row < state->rows && row < rows; row++) {\n      newlineinfo[row] = state->lineinfo[row];\n    }\n\n    for( ; row < rows; row++) {\n      newlineinfo[row].doublewidth = 0;\n      newlineinfo[row].doubleheight = 0;\n    }\n\n    vterm_allocator_free(state->vt, state->lineinfo);\n    state->lineinfo = newlineinfo;\n  }\n\n  state->rows = rows;\n  state->cols = cols;\n\n  if(state->scrollregion_bottom > -1)\n    UBOUND(state->scrollregion_bottom, state->rows);\n  if(state->scrollregion_right > -1)\n    UBOUND(state->scrollregion_right, state->cols);\n\n  if(state->callbacks && state->callbacks->resize)\n    (*state->callbacks->resize)(rows, cols, &delta, state->cbdata);\n\n  if(state->at_phantom && state->pos.col < cols-1) {\n    state->at_phantom = 0;\n    state->pos.col++;\n  }\n\n  state->pos.row += delta.row;\n  state->pos.col += delta.col;\n\n  if(state->pos.row >= rows)\n    state->pos.row = rows - 1;\n  if(state->pos.col >= cols)\n    state->pos.col = cols - 1;\n\n  updatecursor(state, &oldpos, 1);\n\n  return 1;\n}\n\nstatic const VTermParserCallbacks parser_callbacks = {\n  on_text, /* text */\n  on_control, /* control */\n  on_escape, /* escape */\n  on_csi, /* csi */\n  on_osc, /* osc */\n  on_dcs, /* dcs */\n  on_resize /* resize */\n};\n\nVTermState *vterm_obtain_state(VTerm *vt)\n{\n  VTermState *state;\n  if(vt->state)\n    return vt->state;\n\n  state = vterm_state_new(vt);\n  vt->state = state;\n\n  state->combine_chars_size = 16;\n  state->combine_chars = vterm_allocator_malloc(state->vt, state->combine_chars_size * sizeof(state->combine_chars[0]));\n\n  state->tabstops = vterm_allocator_malloc(state->vt, (state->cols + 7) / 8);\n\n  state->lineinfo = vterm_allocator_malloc(state->vt, state->rows * sizeof(VTermLineInfo));\n\n  state->encoding_utf8.enc = vterm_lookup_encoding(ENC_UTF8, 'u');\n  if(*state->encoding_utf8.enc->init != NULL)\n    (*state->encoding_utf8.enc->init)(state->encoding_utf8.enc, state->encoding_utf8.data);\n\n  vterm_parser_set_callbacks(vt, &parser_callbacks, state);\n\n  return state;\n}\n\nvoid vterm_state_reset(VTermState *state, int hard)\n{\n  VTermEncoding *default_enc;\n\n  state->scrollregion_top = 0;\n  state->scrollregion_bottom = -1;\n  state->scrollregion_left = 0;\n  state->scrollregion_right = -1;\n\n  state->mode.keypad          = 0;\n  state->mode.cursor          = 0;\n  state->mode.autowrap        = 1;\n  state->mode.insert          = 0;\n  state->mode.newline         = 0;\n  state->mode.alt_screen      = 0;\n  state->mode.origin          = 0;\n  state->mode.leftrightmargin = 0;\n  state->mode.bracketpaste    = 0;\n  state->mode.report_focus    = 0;\n\n  state->vt->mode.ctrl8bit   = 0;\n\n  {\n    int col;\n    for(col = 0; col < state->cols; col++)\n      if(col % 8 == 0)\n\tset_col_tabstop(state, col);\n      else\n\tclear_col_tabstop(state, col);\n  }\n\n  {\n    int row;\n    for(row = 0; row < state->rows; row++)\n      set_lineinfo(state, row, FORCE, DWL_OFF, DHL_OFF);\n  }\n\n  if(state->callbacks && state->callbacks->initpen)\n    (*state->callbacks->initpen)(state->cbdata);\n\n  vterm_state_resetpen(state);\n\n  default_enc = state->vt->mode.utf8 ?\n      vterm_lookup_encoding(ENC_UTF8,      'u') :\n      vterm_lookup_encoding(ENC_SINGLE_94, 'B');\n\n  {\n    int i;\n    for(i = 0; i < 4; i++) {\n      state->encoding[i].enc = default_enc;\n      if(default_enc->init)\n\t(*default_enc->init)(default_enc, state->encoding[i].data);\n    }\n  }\n\n  state->gl_set = 0;\n  state->gr_set = 1;\n  state->gsingle_set = 0;\n\n  state->protected_cell = 0;\n\n  // Initialise the props\n  settermprop_bool(state, VTERM_PROP_CURSORVISIBLE, 1);\n  settermprop_bool(state, VTERM_PROP_CURSORBLINK,   1);\n  settermprop_int (state, VTERM_PROP_CURSORSHAPE,   VTERM_PROP_CURSORSHAPE_BLOCK);\n\n  if(hard) {\n    VTermRect rect = { 0, 0, 0, 0 };\n\n    state->pos.row = 0;\n    state->pos.col = 0;\n    state->at_phantom = 0;\n\n    rect.end_row = state->rows;\n    rect.end_col =  state->cols;\n    erase(state, rect, 0);\n  }\n}\n\nvoid vterm_state_get_cursorpos(const VTermState *state, VTermPos *cursorpos)\n{\n  *cursorpos = state->pos;\n}\n\nvoid vterm_state_get_mousestate(const VTermState *state, VTermMouseState *mousestate)\n{\n  mousestate->pos.col = state->mouse_col;\n  mousestate->pos.row = state->mouse_row;\n  mousestate->buttons = state->mouse_buttons;\n  mousestate->flags = state->mouse_flags;\n}\n\nvoid vterm_state_set_callbacks(VTermState *state, const VTermStateCallbacks *callbacks, void *user)\n{\n  if(callbacks) {\n    state->callbacks = callbacks;\n    state->cbdata = user;\n\n    if(state->callbacks && state->callbacks->initpen)\n      (*state->callbacks->initpen)(state->cbdata);\n  }\n  else {\n    state->callbacks = NULL;\n    state->cbdata = NULL;\n  }\n}\n\nvoid *vterm_state_get_cbdata(VTermState *state)\n{\n  return state->cbdata;\n}\n\nvoid vterm_state_set_unrecognised_fallbacks(VTermState *state, const VTermParserCallbacks *fallbacks, void *user)\n{\n  if(fallbacks) {\n    state->fallbacks = fallbacks;\n    state->fbdata = user;\n  }\n  else {\n    state->fallbacks = NULL;\n    state->fbdata = NULL;\n  }\n}\n\nvoid *vterm_state_get_unrecognised_fbdata(VTermState *state)\n{\n  return state->fbdata;\n}\n\nint vterm_state_set_termprop(VTermState *state, VTermProp prop, VTermValue *val)\n{\n  /* Only store the new value of the property if usercode said it was happy.\n   * This is especially important for altscreen switching */\n  if(state->callbacks && state->callbacks->settermprop)\n    if(!(*state->callbacks->settermprop)(prop, val, state->cbdata))\n      return 0;\n\n  switch(prop) {\n  case VTERM_PROP_TITLE:\n  case VTERM_PROP_ICONNAME:\n  case VTERM_PROP_CURSORCOLOR:\n    // we don't store these, just transparently pass through\n    return 1;\n  case VTERM_PROP_CURSORVISIBLE:\n    state->mode.cursor_visible = val->boolean;\n    return 1;\n  case VTERM_PROP_CURSORBLINK:\n    state->mode.cursor_blink = val->boolean;\n    return 1;\n  case VTERM_PROP_CURSORSHAPE:\n    state->mode.cursor_shape = val->number;\n    return 1;\n  case VTERM_PROP_REVERSE:\n    state->mode.screen = val->boolean;\n    return 1;\n  case VTERM_PROP_ALTSCREEN:\n    state->mode.alt_screen = val->boolean;\n    if(state->mode.alt_screen) {\n      VTermRect rect = {0, 0, 0, 0};\n      rect.end_row = state->rows;\n      rect.end_col = state->cols;\n      erase(state, rect, 0);\n    }\n    return 1;\n  case VTERM_PROP_MOUSE:\n    state->mouse_flags = 0;\n    if(val->number)\n      state->mouse_flags |= MOUSE_WANT_CLICK;\n    if(val->number == VTERM_PROP_MOUSE_DRAG)\n      state->mouse_flags |= MOUSE_WANT_DRAG;\n    if(val->number == VTERM_PROP_MOUSE_MOVE)\n      state->mouse_flags |= MOUSE_WANT_MOVE;\n    return 1;\n\n  case VTERM_N_PROPS:\n    return 0;\n  }\n\n  return 0;\n}\n\nvoid vterm_state_focus_in(VTermState *state)\n{\n  if(state->mode.report_focus)\n    vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"I\");\n}\n\nvoid vterm_state_focus_out(VTermState *state)\n{\n  if(state->mode.report_focus)\n    vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"O\");\n}\n\nconst VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)\n{\n  return state->lineinfo + row;\n}\n", "#include \"vterm_internal.h\"\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"rect.h\"\n#include \"utf8.h\"\n\n#define UNICODE_SPACE 0x20\n#define UNICODE_LINEFEED 0x0a\n\n/* State of the pen at some moment in time, also used in a cell */\ntypedef struct\n{\n  /* After the bitfield */\n  VTermColor   fg, bg;\n\n  unsigned int bold      : 1;\n  unsigned int underline : 2;\n  unsigned int italic    : 1;\n  unsigned int blink     : 1;\n  unsigned int reverse   : 1;\n  unsigned int strike    : 1;\n  unsigned int font      : 4; /* 0 to 9 */\n\n  /* Extra state storage that isn't strictly pen-related */\n  unsigned int protected_cell : 1;\n  unsigned int dwl            : 1; /* on a DECDWL or DECDHL line */\n  unsigned int dhl            : 2; /* on a DECDHL line (1=top 2=bottom) */\n} ScreenPen;\n\n/* Internal representation of a screen cell */\ntypedef struct\n{\n  uint32_t chars[VTERM_MAX_CHARS_PER_CELL];\n  ScreenPen pen;\n} ScreenCell;\n\nstatic int vterm_screen_set_cell(VTermScreen *screen, VTermPos pos, const VTermScreenCell *cell);\n\nstruct VTermScreen\n{\n  VTerm *vt;\n  VTermState *state;\n\n  const VTermScreenCallbacks *callbacks;\n  void *cbdata;\n\n  VTermDamageSize damage_merge;\n  /* start_row == -1 => no damage */\n  VTermRect damaged;\n  VTermRect pending_scrollrect;\n  int pending_scroll_downward, pending_scroll_rightward;\n\n  int rows;\n  int cols;\n  int global_reverse;\n\n  /* Primary and Altscreen. buffers[1] is lazily allocated as needed */\n  ScreenCell *buffers[2];\n\n  /* buffer will == buffers[0] or buffers[1], depending on altscreen */\n  ScreenCell *buffer;\n\n  /* buffer for a single screen row used in scrollback storage callbacks */\n  VTermScreenCell *sb_buffer;\n\n  ScreenPen pen;\n};\n\nstatic ScreenCell *getcell(const VTermScreen *screen, int row, int col)\n{\n  if(row < 0 || row >= screen->rows)\n    return NULL;\n  if(col < 0 || col >= screen->cols)\n    return NULL;\n  return screen->buffer + (screen->cols * row) + col;\n}\n\nstatic ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int new_rows, int new_cols)\n{\n  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);\n  int row, col;\n\n  for(row = 0; row < new_rows; row++) {\n    for(col = 0; col < new_cols; col++) {\n      ScreenCell *new_cell = new_buffer + row*new_cols + col;\n\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  if(buffer)\n    vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}\n\nstatic void damagerect(VTermScreen *screen, VTermRect rect)\n{\n  VTermRect emit;\n\n  switch(screen->damage_merge) {\n  case VTERM_DAMAGE_CELL:\n    /* Always emit damage event */\n    emit = rect;\n    break;\n\n  case VTERM_DAMAGE_ROW:\n    /* Emit damage longer than one row. Try to merge with existing damage in\n     * the same row */\n    if(rect.end_row > rect.start_row + 1) {\n      // Bigger than 1 line - flush existing, emit this\n      vterm_screen_flush_damage(screen);\n      emit = rect;\n    }\n    else if(screen->damaged.start_row == -1) {\n      // None stored yet\n      screen->damaged = rect;\n      return;\n    }\n    else if(rect.start_row == screen->damaged.start_row) {\n      // Merge with the stored line\n      if(screen->damaged.start_col > rect.start_col)\n        screen->damaged.start_col = rect.start_col;\n      if(screen->damaged.end_col < rect.end_col)\n        screen->damaged.end_col = rect.end_col;\n      return;\n    }\n    else {\n      // Emit the currently stored line, store a new one\n      emit = screen->damaged;\n      screen->damaged = rect;\n    }\n    break;\n\n  case VTERM_DAMAGE_SCREEN:\n  case VTERM_DAMAGE_SCROLL:\n    /* Never emit damage event */\n    if(screen->damaged.start_row == -1)\n      screen->damaged = rect;\n    else {\n      rect_expand(&screen->damaged, &rect);\n    }\n    return;\n\n  default:\n    DEBUG_LOG1(\"TODO: Maybe merge damage for level %d\\n\", screen->damage_merge);\n    return;\n  }\n\n  if(screen->callbacks && screen->callbacks->damage)\n    (*screen->callbacks->damage)(emit, screen->cbdata);\n}\n\nstatic void damagescreen(VTermScreen *screen)\n{\n  VTermRect rect = {0,0,0,0};\n  rect.end_row = screen->rows;\n  rect.end_col = screen->cols;\n\n  damagerect(screen, rect);\n}\n\nstatic int putglyph(VTermGlyphInfo *info, VTermPos pos, void *user)\n{\n  int i;\n  int col;\n  VTermRect rect;\n\n  VTermScreen *screen = user;\n  ScreenCell *cell = getcell(screen, pos.row, pos.col);\n\n  if(!cell)\n    return 0;\n\n  for(i = 0; i < VTERM_MAX_CHARS_PER_CELL && info->chars[i]; i++) {\n    cell->chars[i] = info->chars[i];\n    cell->pen = screen->pen;\n  }\n  if(i < VTERM_MAX_CHARS_PER_CELL)\n    cell->chars[i] = 0;\n\n  for(col = 1; col < info->width; col++)\n    getcell(screen, pos.row, pos.col + col)->chars[0] = (uint32_t)-1;\n\n  rect.start_row = pos.row;\n  rect.end_row   = pos.row+1;\n  rect.start_col = pos.col;\n  rect.end_col   = pos.col+info->width;\n\n  cell->pen.protected_cell = info->protected_cell;\n  cell->pen.dwl            = info->dwl;\n  cell->pen.dhl            = info->dhl;\n\n  damagerect(screen, rect);\n\n  return 1;\n}\n\nstatic int moverect_internal(VTermRect dest, VTermRect src, void *user)\n{\n  VTermScreen *screen = user;\n\n  if(screen->callbacks && screen->callbacks->sb_pushline &&\n     dest.start_row == 0 && dest.start_col == 0 &&  // starts top-left corner\n     dest.end_col == screen->cols &&                // full width\n     screen->buffer == screen->buffers[0]) {        // not altscreen\n    VTermPos pos;\n    for(pos.row = 0; pos.row < src.start_row; pos.row++) {\n      for(pos.col = 0; pos.col < screen->cols; pos.col++)\n        (void)vterm_screen_get_cell(screen, pos, screen->sb_buffer + pos.col);\n\n      (screen->callbacks->sb_pushline)(screen->cols, screen->sb_buffer, screen->cbdata);\n    }\n  }\n\n  {\n    int cols = src.end_col - src.start_col;\n    int downward = src.start_row - dest.start_row;\n    int init_row, test_row, inc_row;\n    int row;\n\n    if(downward < 0) {\n      init_row = dest.end_row - 1;\n      test_row = dest.start_row - 1;\n      inc_row  = -1;\n    }\n    else {\n      init_row = dest.start_row;\n      test_row = dest.end_row;\n      inc_row  = +1;\n    }\n\n    for(row = init_row; row != test_row; row += inc_row)\n      memmove(getcell(screen, row, dest.start_col),\n\t      getcell(screen, row + downward, src.start_col),\n\t      cols * sizeof(ScreenCell));\n  }\n\n  return 1;\n}\n\nstatic int moverect_user(VTermRect dest, VTermRect src, void *user)\n{\n  VTermScreen *screen = user;\n\n  if(screen->callbacks && screen->callbacks->moverect) {\n    if(screen->damage_merge != VTERM_DAMAGE_SCROLL)\n      // Avoid an infinite loop\n      vterm_screen_flush_damage(screen);\n\n    if((*screen->callbacks->moverect)(dest, src, screen->cbdata))\n      return 1;\n  }\n\n  damagerect(screen, dest);\n\n  return 1;\n}\n\nstatic int erase_internal(VTermRect rect, int selective, void *user)\n{\n  VTermScreen *screen = user;\n  int row, col;\n\n  for(row = rect.start_row; row < screen->state->rows && row < rect.end_row; row++) {\n    const VTermLineInfo *info = vterm_state_get_lineinfo(screen->state, row);\n\n    for(col = rect.start_col; col < rect.end_col; col++) {\n      ScreenCell *cell = getcell(screen, row, col);\n\n      if(selective && cell->pen.protected_cell)\n        continue;\n\n      cell->chars[0] = 0;\n      cell->pen = screen->pen;\n      cell->pen.dwl = info->doublewidth;\n      cell->pen.dhl = info->doubleheight;\n    }\n  }\n\n  return 1;\n}\n\nstatic int erase_user(VTermRect rect, int selective UNUSED, void *user)\n{\n  VTermScreen *screen = user;\n\n  damagerect(screen, rect);\n\n  return 1;\n}\n\nstatic int erase(VTermRect rect, int selective, void *user)\n{\n  erase_internal(rect, selective, user);\n  return erase_user(rect, 0, user);\n}\n\nstatic int scrollrect(VTermRect rect, int downward, int rightward, void *user)\n{\n  VTermScreen *screen = user;\n\n  if(screen->damage_merge != VTERM_DAMAGE_SCROLL) {\n    vterm_scroll_rect(rect, downward, rightward,\n        moverect_internal, erase_internal, screen);\n\n    vterm_screen_flush_damage(screen);\n\n    vterm_scroll_rect(rect, downward, rightward,\n        moverect_user, erase_user, screen);\n\n    return 1;\n  }\n\n  if(screen->damaged.start_row != -1 &&\n     !rect_intersects(&rect, &screen->damaged)) {\n    vterm_screen_flush_damage(screen);\n  }\n\n  if(screen->pending_scrollrect.start_row == -1) {\n    screen->pending_scrollrect = rect;\n    screen->pending_scroll_downward  = downward;\n    screen->pending_scroll_rightward = rightward;\n  }\n  else if(rect_equal(&screen->pending_scrollrect, &rect) &&\n     ((screen->pending_scroll_downward  == 0 && downward  == 0) ||\n      (screen->pending_scroll_rightward == 0 && rightward == 0))) {\n    screen->pending_scroll_downward  += downward;\n    screen->pending_scroll_rightward += rightward;\n  }\n  else {\n    vterm_screen_flush_damage(screen);\n\n    screen->pending_scrollrect = rect;\n    screen->pending_scroll_downward  = downward;\n    screen->pending_scroll_rightward = rightward;\n  }\n\n  vterm_scroll_rect(rect, downward, rightward,\n      moverect_internal, erase_internal, screen);\n\n  if(screen->damaged.start_row == -1)\n    return 1;\n\n  if(rect_contains(&rect, &screen->damaged)) {\n    /* Scroll region entirely contains the damage; just move it */\n    vterm_rect_move(&screen->damaged, -downward, -rightward);\n    rect_clip(&screen->damaged, &rect);\n  }\n  /* There are a number of possible cases here, but lets restrict this to only\n   * the common case where we might actually gain some performance by\n   * optimising it. Namely, a vertical scroll that neatly cuts the damage\n   * region in half.\n   */\n  else if(rect.start_col <= screen->damaged.start_col &&\n          rect.end_col   >= screen->damaged.end_col &&\n          rightward == 0) {\n    if(screen->damaged.start_row >= rect.start_row &&\n       screen->damaged.start_row  < rect.end_row) {\n      screen->damaged.start_row -= downward;\n      if(screen->damaged.start_row < rect.start_row)\n        screen->damaged.start_row = rect.start_row;\n      if(screen->damaged.start_row > rect.end_row)\n        screen->damaged.start_row = rect.end_row;\n    }\n    if(screen->damaged.end_row >= rect.start_row &&\n       screen->damaged.end_row  < rect.end_row) {\n      screen->damaged.end_row -= downward;\n      if(screen->damaged.end_row < rect.start_row)\n        screen->damaged.end_row = rect.start_row;\n      if(screen->damaged.end_row > rect.end_row)\n        screen->damaged.end_row = rect.end_row;\n    }\n  }\n  else {\n    DEBUG_LOG2(\"TODO: Just flush and redo damaged=\" STRFrect \" rect=\" STRFrect \"\\n\",\n        ARGSrect(screen->damaged), ARGSrect(rect));\n  }\n\n  return 1;\n}\n\nstatic int movecursor(VTermPos pos, VTermPos oldpos, int visible, void *user)\n{\n  VTermScreen *screen = user;\n\n  if(screen->callbacks && screen->callbacks->movecursor)\n    return (*screen->callbacks->movecursor)(pos, oldpos, visible, screen->cbdata);\n\n  return 0;\n}\n\nstatic int setpenattr(VTermAttr attr, VTermValue *val, void *user)\n{\n  VTermScreen *screen = user;\n\n  switch(attr) {\n  case VTERM_ATTR_BOLD:\n    screen->pen.bold = val->boolean;\n    return 1;\n  case VTERM_ATTR_UNDERLINE:\n    screen->pen.underline = val->number;\n    return 1;\n  case VTERM_ATTR_ITALIC:\n    screen->pen.italic = val->boolean;\n    return 1;\n  case VTERM_ATTR_BLINK:\n    screen->pen.blink = val->boolean;\n    return 1;\n  case VTERM_ATTR_REVERSE:\n    screen->pen.reverse = val->boolean;\n    return 1;\n  case VTERM_ATTR_STRIKE:\n    screen->pen.strike = val->boolean;\n    return 1;\n  case VTERM_ATTR_FONT:\n    screen->pen.font = val->number;\n    return 1;\n  case VTERM_ATTR_FOREGROUND:\n    screen->pen.fg = val->color;\n    return 1;\n  case VTERM_ATTR_BACKGROUND:\n    screen->pen.bg = val->color;\n    return 1;\n\n  case VTERM_N_ATTRS:\n    return 0;\n  }\n\n  return 0;\n}\n\nstatic int settermprop(VTermProp prop, VTermValue *val, void *user)\n{\n  VTermScreen *screen = user;\n\n  switch(prop) {\n  case VTERM_PROP_ALTSCREEN:\n    if(val->boolean && !screen->buffers[1])\n      return 0;\n\n    screen->buffer = val->boolean ? screen->buffers[1] : screen->buffers[0];\n    /* only send a damage event on disable; because during enable there's an\n     * erase that sends a damage anyway\n     */\n    if(!val->boolean)\n      damagescreen(screen);\n    break;\n  case VTERM_PROP_REVERSE:\n    screen->global_reverse = val->boolean;\n    damagescreen(screen);\n    break;\n  default:\n    ; /* ignore */\n  }\n\n  if(screen->callbacks && screen->callbacks->settermprop)\n    return (*screen->callbacks->settermprop)(prop, val, screen->cbdata);\n\n  return 1;\n}\n\nstatic int bell(void *user)\n{\n  VTermScreen *screen = user;\n\n  if(screen->callbacks && screen->callbacks->bell)\n    return (*screen->callbacks->bell)(screen->cbdata);\n\n  return 0;\n}\n\nstatic int resize(int new_rows, int new_cols, VTermPos *delta, void *user)\n{\n  VTermScreen *screen = user;\n\n  int is_altscreen = (screen->buffers[1] && screen->buffer == screen->buffers[1]);\n\n  int old_rows = screen->rows;\n  int old_cols = screen->cols;\n  int first_blank_row;\n\n  if(!is_altscreen && new_rows < old_rows) {\n    // Fewer rows - determine if we're going to scroll at all, and if so, push\n    // those lines to scrollback\n    VTermPos pos = { 0, 0 };\n    VTermPos cursor = screen->state->pos;\n    // Find the first blank row after the cursor.\n    for(pos.row = old_rows - 1; pos.row >= new_rows; pos.row--)\n      if(!vterm_screen_is_eol(screen, pos) || cursor.row == pos.row)\n        break;\n\n    first_blank_row = pos.row + 1;\n    if(first_blank_row > new_rows) {\n      VTermRect rect = {0,0,0,0};\n      rect.end_row   = old_rows;\n      rect.end_col   = old_cols;\n      scrollrect(rect, first_blank_row - new_rows, 0, user);\n      vterm_screen_flush_damage(screen);\n\n      delta->row -= first_blank_row - new_rows;\n    }\n  }\n\n  screen->buffers[0] = realloc_buffer(screen, screen->buffers[0], new_rows, new_cols);\n  if(screen->buffers[1])\n    screen->buffers[1] = realloc_buffer(screen, screen->buffers[1], new_rows, new_cols);\n\n  screen->buffer = is_altscreen ? screen->buffers[1] : screen->buffers[0];\n\n  screen->rows = new_rows;\n  screen->cols = new_cols;\n\n  if(screen->sb_buffer)\n    vterm_allocator_free(screen->vt, screen->sb_buffer);\n\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * new_cols);\n\n  if(new_cols > old_cols) {\n    VTermRect rect;\n    rect.start_row = 0;\n    rect.end_row   = old_rows;\n    rect.start_col = old_cols;\n    rect.end_col   = new_cols;\n    damagerect(screen, rect);\n  }\n\n  if(new_rows > old_rows) {\n    if(!is_altscreen && screen->callbacks && screen->callbacks->sb_popline) {\n      int rows = new_rows - old_rows;\n      while(rows) {\n        VTermRect rect = {0,0,0,0};\n        VTermPos pos = { 0, 0 };\n        if(!(screen->callbacks->sb_popline(screen->cols, screen->sb_buffer, screen->cbdata)))\n          break;\n\n\trect.end_row   = screen->rows;\n\trect.end_col   = screen->cols;\n        scrollrect(rect, -1, 0, user);\n\n        for(pos.col = 0; pos.col < screen->cols; pos.col += screen->sb_buffer[pos.col].width)\n          vterm_screen_set_cell(screen, pos, screen->sb_buffer + pos.col);\n\n        rect.end_row = 1;\n        damagerect(screen, rect);\n\n        vterm_screen_flush_damage(screen);\n\n        rows--;\n        delta->row++;\n      }\n    }\n\n    {\n      VTermRect rect;\n      rect.start_row = old_rows;\n      rect.end_row   = new_rows;\n      rect.start_col = 0;\n      rect.end_col   = new_cols;\n      damagerect(screen, rect);\n    }\n  }\n\n  if(screen->callbacks && screen->callbacks->resize)\n    return (*screen->callbacks->resize)(new_rows, new_cols, screen->cbdata);\n\n  return 1;\n}\n\nstatic int setlineinfo(int row, const VTermLineInfo *newinfo, const VTermLineInfo *oldinfo, void *user)\n{\n  VTermScreen *screen = user;\n  int col;\n  VTermRect rect;\n\n  if(newinfo->doublewidth != oldinfo->doublewidth ||\n     newinfo->doubleheight != oldinfo->doubleheight) {\n    for(col = 0; col < screen->cols; col++) {\n      ScreenCell *cell = getcell(screen, row, col);\n      cell->pen.dwl = newinfo->doublewidth;\n      cell->pen.dhl = newinfo->doubleheight;\n    }\n\n    rect.start_row = row;\n    rect.end_row   = row + 1;\n    rect.start_col = 0;\n    rect.end_col   = newinfo->doublewidth ? screen->cols / 2 : screen->cols;\n    damagerect(screen, rect);\n\n    if(newinfo->doublewidth) {\n      rect.start_col = screen->cols / 2;\n      rect.end_col   = screen->cols;\n\n      erase_internal(rect, 0, user);\n    }\n  }\n\n  return 1;\n}\n\nstatic VTermStateCallbacks state_cbs = {\n  &putglyph, /* putglyph */\n  &movecursor, /* movecursor */\n  &scrollrect, /* scrollrect */\n  NULL, /* moverect */\n  &erase, /* erase */\n  NULL, /* initpen */\n  &setpenattr, /* setpenattr */\n  &settermprop, /* settermprop */\n  &bell, /* bell */\n  &resize, /* resize */\n  &setlineinfo /* setlineinfo */\n};\n\nstatic VTermScreen *screen_new(VTerm *vt)\n{\n  VTermState *state = vterm_obtain_state(vt);\n  VTermScreen *screen;\n  int rows, cols;\n\n  if(!state)\n    return NULL;\n\n  screen = vterm_allocator_malloc(vt, sizeof(VTermScreen));\n\n  vterm_get_size(vt, &rows, &cols);\n\n  screen->vt = vt;\n  screen->state = state;\n\n  screen->damage_merge = VTERM_DAMAGE_CELL;\n  screen->damaged.start_row = -1;\n  screen->pending_scrollrect.start_row = -1;\n\n  screen->rows = rows;\n  screen->cols = cols;\n\n  screen->callbacks = NULL;\n  screen->cbdata    = NULL;\n\n  screen->buffers[0] = realloc_buffer(screen, NULL, rows, cols);\n\n  screen->buffer = screen->buffers[0];\n\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols);\n\n  vterm_state_set_callbacks(screen->state, &state_cbs, screen);\n\n  return screen;\n}\n\nINTERNAL void vterm_screen_free(VTermScreen *screen)\n{\n  vterm_allocator_free(screen->vt, screen->buffers[0]);\n  if(screen->buffers[1])\n    vterm_allocator_free(screen->vt, screen->buffers[1]);\n\n  vterm_allocator_free(screen->vt, screen->sb_buffer);\n\n  vterm_allocator_free(screen->vt, screen);\n}\n\nvoid vterm_screen_reset(VTermScreen *screen, int hard)\n{\n  screen->damaged.start_row = -1;\n  screen->pending_scrollrect.start_row = -1;\n  vterm_state_reset(screen->state, hard);\n  vterm_screen_flush_damage(screen);\n}\n\nstatic size_t _get_chars(const VTermScreen *screen, const int utf8, void *buffer, size_t len, const VTermRect rect)\n{\n  size_t outpos = 0;\n  int padding = 0;\n  int row, col;\n\n#define PUT(c)                                             \\\n  if(utf8) {                                               \\\n    size_t thislen = utf8_seqlen(c);                       \\\n    if(buffer && outpos + thislen <= len)                  \\\n      outpos += fill_utf8((c), (char *)buffer + outpos);   \\\n    else                                                   \\\n      outpos += thislen;                                   \\\n  }                                                        \\\n  else {                                                   \\\n    if(buffer && outpos + 1 <= len)                        \\\n      ((uint32_t*)buffer)[outpos++] = (c);                 \\\n    else                                                   \\\n      outpos++;                                            \\\n  }\n\n  for(row = rect.start_row; row < rect.end_row; row++) {\n    for(col = rect.start_col; col < rect.end_col; col++) {\n      ScreenCell *cell = getcell(screen, row, col);\n      int i;\n\n      if(cell->chars[0] == 0)\n        // Erased cell, might need a space\n        padding++;\n      else if(cell->chars[0] == (uint32_t)-1)\n        // Gap behind a double-width char, do nothing\n        ;\n      else {\n        while(padding) {\n          PUT(UNICODE_SPACE);\n          padding--;\n        }\n        for(i = 0; i < VTERM_MAX_CHARS_PER_CELL && cell->chars[i]; i++) {\n          PUT(cell->chars[i]);\n        }\n      }\n    }\n\n    if(row < rect.end_row - 1) {\n      PUT(UNICODE_LINEFEED);\n      padding = 0;\n    }\n  }\n\n  return outpos;\n}\n\nsize_t vterm_screen_get_chars(const VTermScreen *screen, uint32_t *chars, size_t len, const VTermRect rect)\n{\n  return _get_chars(screen, 0, chars, len, rect);\n}\n\nsize_t vterm_screen_get_text(const VTermScreen *screen, char *str, size_t len, const VTermRect rect)\n{\n  return _get_chars(screen, 1, str, len, rect);\n}\n\n/* Copy internal to external representation of a screen cell */\nint vterm_screen_get_cell(const VTermScreen *screen, VTermPos pos, VTermScreenCell *cell)\n{\n  ScreenCell *intcell = getcell(screen, pos.row, pos.col);\n  int i;\n\n  if(!intcell)\n    return 0;\n\n  for(i = 0; ; i++) {\n    cell->chars[i] = intcell->chars[i];\n    if(!intcell->chars[i])\n      break;\n  }\n\n  cell->attrs.bold      = intcell->pen.bold;\n  cell->attrs.underline = intcell->pen.underline;\n  cell->attrs.italic    = intcell->pen.italic;\n  cell->attrs.blink     = intcell->pen.blink;\n  cell->attrs.reverse   = intcell->pen.reverse ^ screen->global_reverse;\n  cell->attrs.strike    = intcell->pen.strike;\n  cell->attrs.font      = intcell->pen.font;\n\n  cell->attrs.dwl = intcell->pen.dwl;\n  cell->attrs.dhl = intcell->pen.dhl;\n\n  cell->fg = intcell->pen.fg;\n  cell->bg = intcell->pen.bg;\n\n  if(pos.col < (screen->cols - 1) &&\n     getcell(screen, pos.row, pos.col + 1)->chars[0] == (uint32_t)-1)\n    cell->width = 2;\n  else\n    cell->width = 1;\n\n  return 1;\n}\n\n/* Copy external to internal representation of a screen cell */\n/* static because it's only used internally for sb_popline during resize */\nstatic int vterm_screen_set_cell(VTermScreen *screen, VTermPos pos, const VTermScreenCell *cell)\n{\n  ScreenCell *intcell = getcell(screen, pos.row, pos.col);\n  int i;\n\n  if(!intcell)\n    return 0;\n\n  for(i = 0; ; i++) {\n    intcell->chars[i] = cell->chars[i];\n    if(!cell->chars[i])\n      break;\n  }\n\n  intcell->pen.bold      = cell->attrs.bold;\n  intcell->pen.underline = cell->attrs.underline;\n  intcell->pen.italic    = cell->attrs.italic;\n  intcell->pen.blink     = cell->attrs.blink;\n  intcell->pen.reverse   = cell->attrs.reverse ^ screen->global_reverse;\n  intcell->pen.strike    = cell->attrs.strike;\n  intcell->pen.font      = cell->attrs.font;\n\n  intcell->pen.fg = cell->fg;\n  intcell->pen.bg = cell->bg;\n\n  if(cell->width == 2)\n    getcell(screen, pos.row, pos.col + 1)->chars[0] = (uint32_t)-1;\n\n  return 1;\n}\n\nint vterm_screen_is_eol(const VTermScreen *screen, VTermPos pos)\n{\n  /* This cell is EOL if this and every cell to the right is black */\n  for(; pos.col < screen->cols; pos.col++) {\n    ScreenCell *cell = getcell(screen, pos.row, pos.col);\n    if(cell->chars[0] != 0)\n      return 0;\n  }\n\n  return 1;\n}\n\nVTermScreen *vterm_obtain_screen(VTerm *vt)\n{\n  if(!vt->screen)\n    vt->screen = screen_new(vt);\n  return vt->screen;\n}\n\nvoid vterm_screen_enable_altscreen(VTermScreen *screen, int altscreen)\n{\n\n  if(!screen->buffers[1] && altscreen) {\n    int rows, cols;\n    vterm_get_size(screen->vt, &rows, &cols);\n\n    screen->buffers[1] = realloc_buffer(screen, NULL, rows, cols);\n  }\n}\n\nvoid vterm_screen_set_callbacks(VTermScreen *screen, const VTermScreenCallbacks *callbacks, void *user)\n{\n  screen->callbacks = callbacks;\n  screen->cbdata = user;\n}\n\nvoid *vterm_screen_get_cbdata(VTermScreen *screen)\n{\n  return screen->cbdata;\n}\n\nvoid vterm_screen_set_unrecognised_fallbacks(VTermScreen *screen, const VTermParserCallbacks *fallbacks, void *user)\n{\n  vterm_state_set_unrecognised_fallbacks(screen->state, fallbacks, user);\n}\n\nvoid *vterm_screen_get_unrecognised_fbdata(VTermScreen *screen)\n{\n  return vterm_state_get_unrecognised_fbdata(screen->state);\n}\n\nvoid vterm_screen_flush_damage(VTermScreen *screen)\n{\n  if(screen->pending_scrollrect.start_row != -1) {\n    vterm_scroll_rect(screen->pending_scrollrect, screen->pending_scroll_downward, screen->pending_scroll_rightward,\n        moverect_user, erase_user, screen);\n\n    screen->pending_scrollrect.start_row = -1;\n  }\n\n  if(screen->damaged.start_row != -1) {\n    if(screen->callbacks && screen->callbacks->damage)\n      (*screen->callbacks->damage)(screen->damaged, screen->cbdata);\n\n    screen->damaged.start_row = -1;\n  }\n}\n\nvoid vterm_screen_set_damage_merge(VTermScreen *screen, VTermDamageSize size)\n{\n  vterm_screen_flush_damage(screen);\n  screen->damage_merge = size;\n}\n\nstatic int attrs_differ(VTermAttrMask attrs, ScreenCell *a, ScreenCell *b)\n{\n  if((attrs & VTERM_ATTR_BOLD_MASK)       && (a->pen.bold != b->pen.bold))\n    return 1;\n  if((attrs & VTERM_ATTR_UNDERLINE_MASK)  && (a->pen.underline != b->pen.underline))\n    return 1;\n  if((attrs & VTERM_ATTR_ITALIC_MASK)     && (a->pen.italic != b->pen.italic))\n    return 1;\n  if((attrs & VTERM_ATTR_BLINK_MASK)      && (a->pen.blink != b->pen.blink))\n    return 1;\n  if((attrs & VTERM_ATTR_REVERSE_MASK)    && (a->pen.reverse != b->pen.reverse))\n    return 1;\n  if((attrs & VTERM_ATTR_STRIKE_MASK)     && (a->pen.strike != b->pen.strike))\n    return 1;\n  if((attrs & VTERM_ATTR_FONT_MASK)       && (a->pen.font != b->pen.font))\n    return 1;\n  if((attrs & VTERM_ATTR_FOREGROUND_MASK) && !vterm_color_equal(a->pen.fg, b->pen.fg))\n    return 1;\n  if((attrs & VTERM_ATTR_BACKGROUND_MASK) && !vterm_color_equal(a->pen.bg, b->pen.bg))\n    return 1;\n\n  return 0;\n}\n\nint vterm_screen_get_attrs_extent(const VTermScreen *screen, VTermRect *extent, VTermPos pos, VTermAttrMask attrs)\n{\n  int col;\n\n  ScreenCell *target = getcell(screen, pos.row, pos.col);\n\n  // TODO: bounds check\n  extent->start_row = pos.row;\n  extent->end_row   = pos.row + 1;\n\n  if(extent->start_col < 0)\n    extent->start_col = 0;\n  if(extent->end_col < 0)\n    extent->end_col = screen->cols;\n\n  for(col = pos.col - 1; col >= extent->start_col; col--)\n    if(attrs_differ(attrs, target, getcell(screen, pos.row, col)))\n      break;\n  extent->start_col = col + 1;\n\n  for(col = pos.col + 1; col < extent->end_col; col++)\n    if(attrs_differ(attrs, target, getcell(screen, pos.row, col)))\n      break;\n  extent->end_col = col - 1;\n\n  return 1;\n}\n", "#define DEFINE_INLINES\n\n#include \"vterm_internal.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n\n#include \"utf8.h\"\n\n/*****************\n * API functions *\n *****************/\n\nstatic void *default_malloc(size_t size, void *allocdata UNUSED)\n{\n  void *ptr = malloc(size);\n  if(ptr)\n    memset(ptr, 0, size);\n  return ptr;\n}\n\nstatic void default_free(void *ptr, void *allocdata UNUSED)\n{\n  free(ptr);\n}\n\nstatic VTermAllocatorFunctions default_allocator = {\n  &default_malloc, // malloc\n  &default_free // free\n};\n\nVTerm *vterm_new(int rows, int cols)\n{\n  return vterm_new_with_allocator(rows, cols, &default_allocator, NULL);\n}\n\nVTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)\n{\n  /* Need to bootstrap using the allocator function directly */\n  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);\n\n  vt->allocator = funcs;\n  vt->allocdata = allocdata;\n\n  vt->rows = rows;\n  vt->cols = cols;\n\n  vt->parser.state = NORMAL;\n\n  vt->parser.callbacks = NULL;\n  vt->parser.cbdata    = NULL;\n\n  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */\n  vt->parser.strbuffer_cur = 0;\n  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);\n\n  vt->outbuffer_len = 200;\n  vt->outbuffer_cur = 0;\n  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);\n\n  return vt;\n}\n\nvoid vterm_free(VTerm *vt)\n{\n  if(vt->screen)\n    vterm_screen_free(vt->screen);\n\n  if(vt->state)\n    vterm_state_free(vt->state);\n\n  vterm_allocator_free(vt, vt->parser.strbuffer);\n  vterm_allocator_free(vt, vt->outbuffer);\n\n  vterm_allocator_free(vt, vt);\n}\n\nINTERNAL void *vterm_allocator_malloc(VTerm *vt, size_t size)\n{\n  return (*vt->allocator->malloc)(size, vt->allocdata);\n}\n\nINTERNAL void vterm_allocator_free(VTerm *vt, void *ptr)\n{\n  (*vt->allocator->free)(ptr, vt->allocdata);\n}\n\nvoid vterm_get_size(const VTerm *vt, int *rowsp, int *colsp)\n{\n  if(rowsp)\n    *rowsp = vt->rows;\n  if(colsp)\n    *colsp = vt->cols;\n}\n\nvoid vterm_set_size(VTerm *vt, int rows, int cols)\n{\n  vt->rows = rows;\n  vt->cols = cols;\n\n  if(vt->parser.callbacks && vt->parser.callbacks->resize)\n    (*vt->parser.callbacks->resize)(rows, cols, vt->parser.cbdata);\n}\n\nint vterm_get_utf8(const VTerm *vt)\n{\n  return vt->mode.utf8;\n}\n\nvoid vterm_set_utf8(VTerm *vt, int is_utf8)\n{\n  vt->mode.utf8 = is_utf8;\n}\n\nINTERNAL void vterm_push_output_bytes(VTerm *vt, const char *bytes, size_t len)\n{\n  if(len > vt->outbuffer_len - vt->outbuffer_cur) {\n    DEBUG_LOG(\"vterm_push_output(): buffer overflow; truncating output\\n\");\n    len = vt->outbuffer_len - vt->outbuffer_cur;\n  }\n\n  memcpy(vt->outbuffer + vt->outbuffer_cur, bytes, len);\n  vt->outbuffer_cur += len;\n}\n\nstatic int outbuffer_is_full(VTerm *vt)\n{\n  return vt->outbuffer_cur >= vt->outbuffer_len - 1;\n}\n\n#if (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 500) \\\n\t|| defined(_ISOC99_SOURCE) || defined(_BSD_SOURCE)\n# undef VSNPRINTF\n# define VSNPRINTF vsnprintf\n#else\n# ifdef VSNPRINTF\n/* Use a provided vsnprintf() function. */\nint VSNPRINTF(char *str, size_t str_m, const char *fmt, va_list ap);\n# endif\n#endif\n\n\nINTERNAL void vterm_push_output_vsprintf(VTerm *vt, const char *format, va_list args)\n{\n  int written;\n#ifndef VSNPRINTF\n  /* When vsnprintf() is not available (C90) fall back to vsprintf(). */\n  char buffer[1024]; /* 1Kbyte is enough for everybody, right? */\n#endif\n\n  if(outbuffer_is_full(vt)) {\n    DEBUG_LOG(\"vterm_push_output(): buffer overflow; truncating output\\n\");\n    return;\n  }\n\n#ifdef VSNPRINTF\n  written = VSNPRINTF(vt->outbuffer + vt->outbuffer_cur,\n      vt->outbuffer_len - vt->outbuffer_cur,\n      format, args);\n\n  if(written == (int)(vt->outbuffer_len - vt->outbuffer_cur)) {\n    /* output was truncated */\n    vt->outbuffer_cur = vt->outbuffer_len - 1;\n  }\n  else\n    vt->outbuffer_cur += written;\n#else\n  written = vsprintf(buffer, format, args);\n\n  if(written >= (int)(vt->outbuffer_len - vt->outbuffer_cur - 1)) {\n    /* output was truncated */\n    written = vt->outbuffer_len - vt->outbuffer_cur - 1;\n  }\n  if (written > 0)\n  {\n    strncpy(vt->outbuffer + vt->outbuffer_cur, buffer, written + 1);\n    vt->outbuffer_cur += written;\n  }\n#endif\n}\n\nINTERNAL void vterm_push_output_sprintf(VTerm *vt, const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n  vterm_push_output_vsprintf(vt, format, args);\n  va_end(args);\n}\n\nINTERNAL void vterm_push_output_sprintf_ctrl(VTerm *vt, unsigned char ctrl, const char *fmt, ...)\n{\n  size_t orig_cur = vt->outbuffer_cur;\n  va_list args;\n\n  if(ctrl >= 0x80 && !vt->mode.ctrl8bit)\n    vterm_push_output_sprintf(vt, ESC_S \"%c\", ctrl - 0x40);\n  else\n    vterm_push_output_sprintf(vt, \"%c\", ctrl);\n\n  va_start(args, fmt);\n  vterm_push_output_vsprintf(vt, fmt, args);\n  va_end(args);\n\n  if(outbuffer_is_full(vt))\n    vt->outbuffer_cur = orig_cur;\n}\n\nINTERNAL void vterm_push_output_sprintf_dcs(VTerm *vt, const char *fmt, ...)\n{\n  size_t orig_cur = vt->outbuffer_cur;\n  va_list args;\n\n  if(!vt->mode.ctrl8bit)\n    vterm_push_output_sprintf(vt, ESC_S \"%c\", C1_DCS - 0x40);\n  else\n    vterm_push_output_sprintf(vt, \"%c\", C1_DCS);\n\n  va_start(args, fmt);\n  vterm_push_output_vsprintf(vt, fmt, args);\n  va_end(args);\n\n  vterm_push_output_sprintf_ctrl(vt, C1_ST, \"\");\n\n  if(outbuffer_is_full(vt))\n    vt->outbuffer_cur = orig_cur;\n}\n\nsize_t vterm_output_get_buffer_size(const VTerm *vt)\n{\n  return vt->outbuffer_len;\n}\n\nsize_t vterm_output_get_buffer_current(const VTerm *vt)\n{\n  return vt->outbuffer_cur;\n}\n\nsize_t vterm_output_get_buffer_remaining(const VTerm *vt)\n{\n  return vt->outbuffer_len - vt->outbuffer_cur;\n}\n\nsize_t vterm_output_read(VTerm *vt, char *buffer, size_t len)\n{\n  if(len > vt->outbuffer_cur)\n    len = vt->outbuffer_cur;\n\n  memcpy(buffer, vt->outbuffer, len);\n\n  if(len < vt->outbuffer_cur)\n    memmove(vt->outbuffer, vt->outbuffer + len, vt->outbuffer_cur - len);\n\n  vt->outbuffer_cur -= len;\n\n  return len;\n}\n\nVTermValueType vterm_get_attr_type(VTermAttr attr)\n{\n  switch(attr) {\n    case VTERM_ATTR_BOLD:       return VTERM_VALUETYPE_BOOL;\n    case VTERM_ATTR_UNDERLINE:  return VTERM_VALUETYPE_INT;\n    case VTERM_ATTR_ITALIC:     return VTERM_VALUETYPE_BOOL;\n    case VTERM_ATTR_BLINK:      return VTERM_VALUETYPE_BOOL;\n    case VTERM_ATTR_REVERSE:    return VTERM_VALUETYPE_BOOL;\n    case VTERM_ATTR_STRIKE:     return VTERM_VALUETYPE_BOOL;\n    case VTERM_ATTR_FONT:       return VTERM_VALUETYPE_INT;\n    case VTERM_ATTR_FOREGROUND: return VTERM_VALUETYPE_COLOR;\n    case VTERM_ATTR_BACKGROUND: return VTERM_VALUETYPE_COLOR;\n\n    case VTERM_N_ATTRS: return 0;\n  }\n  return 0; /* UNREACHABLE */\n}\n\nVTermValueType vterm_get_prop_type(VTermProp prop)\n{\n  switch(prop) {\n    case VTERM_PROP_CURSORVISIBLE: return VTERM_VALUETYPE_BOOL;\n    case VTERM_PROP_CURSORBLINK:   return VTERM_VALUETYPE_BOOL;\n    case VTERM_PROP_ALTSCREEN:     return VTERM_VALUETYPE_BOOL;\n    case VTERM_PROP_TITLE:         return VTERM_VALUETYPE_STRING;\n    case VTERM_PROP_ICONNAME:      return VTERM_VALUETYPE_STRING;\n    case VTERM_PROP_REVERSE:       return VTERM_VALUETYPE_BOOL;\n    case VTERM_PROP_CURSORSHAPE:   return VTERM_VALUETYPE_INT;\n    case VTERM_PROP_MOUSE:         return VTERM_VALUETYPE_INT;\n    case VTERM_PROP_CURSORCOLOR:   return VTERM_VALUETYPE_STRING;\n\n    case VTERM_N_PROPS: return 0;\n  }\n  return 0; /* UNREACHABLE */\n}\n\nvoid vterm_scroll_rect(VTermRect rect,\n    int downward,\n    int rightward,\n    int (*moverect)(VTermRect src, VTermRect dest, void *user),\n    int (*eraserect)(VTermRect rect, int selective, void *user),\n    void *user)\n{\n  VTermRect src;\n  VTermRect dest;\n\n  if(abs(downward)  >= rect.end_row - rect.start_row ||\n     abs(rightward) >= rect.end_col - rect.start_col) {\n    /* Scroll more than area; just erase the lot */\n    (*eraserect)(rect, 0, user);\n    return;\n  }\n\n  if(rightward >= 0) {\n    /* rect: [XXX................]\n     * src:     [----------------]\n     * dest: [----------------]\n     */\n    dest.start_col = rect.start_col;\n    dest.end_col   = rect.end_col   - rightward;\n    src.start_col  = rect.start_col + rightward;\n    src.end_col    = rect.end_col;\n  }\n  else {\n    /* rect: [................XXX]\n     * src:  [----------------]\n     * dest:    [----------------]\n     */\n    int leftward = -rightward;\n    dest.start_col = rect.start_col + leftward;\n    dest.end_col   = rect.end_col;\n    src.start_col  = rect.start_col;\n    src.end_col    = rect.end_col - leftward;\n  }\n\n  if(downward >= 0) {\n    dest.start_row = rect.start_row;\n    dest.end_row   = rect.end_row   - downward;\n    src.start_row  = rect.start_row + downward;\n    src.end_row    = rect.end_row;\n  }\n  else {\n    int upward = -downward;\n    dest.start_row = rect.start_row + upward;\n    dest.end_row   = rect.end_row;\n    src.start_row  = rect.start_row;\n    src.end_row    = rect.end_row - upward;\n  }\n\n  if(moverect)\n    (*moverect)(dest, src, user);\n\n  if(downward > 0)\n    rect.start_row = rect.end_row - downward;\n  else if(downward < 0)\n    rect.end_row = rect.start_row - downward;\n\n  if(rightward > 0)\n    rect.start_col = rect.end_col - rightward;\n  else if(rightward < 0)\n    rect.end_col = rect.start_col - rightward;\n\n  (*eraserect)(rect, 0, user);\n}\n\nvoid vterm_copy_cells(VTermRect dest,\n    VTermRect src,\n    void (*copycell)(VTermPos dest, VTermPos src, void *user),\n    void *user)\n{\n  int downward  = src.start_row - dest.start_row;\n  int rightward = src.start_col - dest.start_col;\n\n  int init_row, test_row, init_col, test_col;\n  int inc_row, inc_col;\n\n  VTermPos pos;\n\n  if(downward < 0) {\n    init_row = dest.end_row - 1;\n    test_row = dest.start_row - 1;\n    inc_row = -1;\n  }\n  else /* downward >= 0 */ {\n    init_row = dest.start_row;\n    test_row = dest.end_row;\n    inc_row = +1;\n  }\n\n  if(rightward < 0) {\n    init_col = dest.end_col - 1;\n    test_col = dest.start_col - 1;\n    inc_col = -1;\n  }\n  else /* rightward >= 0 */ {\n    init_col = dest.start_col;\n    test_col = dest.end_col;\n    inc_col = +1;\n  }\n\n  for(pos.row = init_row; pos.row != test_row; pos.row += inc_row)\n    for(pos.col = init_col; pos.col != test_col; pos.col += inc_col) {\n      VTermPos srcpos;\n      srcpos.row = pos.row + downward;\n      srcpos.col = pos.col + rightward;\n      (*copycell)(pos, srcpos, user);\n    }\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * Terminal window support, see \":help :terminal\".\n *\n * There are three parts:\n * 1. Generic code for all systems.\n *    Uses libvterm for the terminal emulator.\n * 2. The MS-Windows implementation.\n *    Uses winpty.\n * 3. The Unix-like implementation.\n *    Uses pseudo-tty's (pty's).\n *\n * For each terminal one VTerm is constructed.  This uses libvterm.  A copy of\n * this library is in the libvterm directory.\n *\n * When a terminal window is opened, a job is started that will be connected to\n * the terminal emulator.\n *\n * If the terminal window has keyboard focus, typed keys are converted to the\n * terminal encoding and writing to the job over a channel.\n *\n * If the job produces output, it is written to the terminal emulator.  The\n * terminal emulator invokes callbacks when its screen content changes.  The\n * line range is stored in tl_dirty_row_start and tl_dirty_row_end.  Once in a\n * while, if the terminal window is visible, the screen contents is drawn.\n *\n * When the job ends the text is put in a buffer.  Redrawing then happens from\n * that buffer, attributes come from the scrollback buffer tl_scrollback.\n * When the buffer is changed it is turned into a normal buffer, the attributes\n * in tl_scrollback are no longer used.\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n\n#ifndef MIN\n# define MIN(x,y) ((x) < (y) ? (x) : (y))\n#endif\n#ifndef MAX\n# define MAX(x,y) ((x) > (y) ? (x) : (y))\n#endif\n\n#include \"libvterm/include/vterm.h\"\n\n/* This is VTermScreenCell without the characters, thus much smaller. */\ntypedef struct {\n  VTermScreenCellAttrs\tattrs;\n  char\t\t\twidth;\n  VTermColor\t\tfg;\n  VTermColor\t\tbg;\n} cellattr_T;\n\ntypedef struct sb_line_S {\n    int\t\tsb_cols;\t/* can differ per line */\n    cellattr_T\t*sb_cells;\t/* allocated */\n    cellattr_T\tsb_fill_attr;\t/* for short line */\n} sb_line_T;\n\n/* typedef term_T in structs.h */\nstruct terminal_S {\n    term_T\t*tl_next;\n\n    VTerm\t*tl_vterm;\n    job_T\t*tl_job;\n    buf_T\t*tl_buffer;\n#if defined(FEAT_GUI)\n    int\t\ttl_system;\t/* when non-zero used for :!cmd output */\n    int\t\ttl_toprow;\t/* row with first line of system terminal */\n#endif\n\n    /* Set when setting the size of a vterm, reset after redrawing. */\n    int\t\ttl_vterm_size_changed;\n\n    int\t\ttl_normal_mode; /* TRUE: Terminal-Normal mode */\n    int\t\ttl_channel_closed;\n    int\t\ttl_channel_recently_closed; // still need to handle tl_finish\n\n    int\t\ttl_finish;\n#define TL_FINISH_UNSET\t    NUL\n#define TL_FINISH_CLOSE\t    'c'\t/* ++close or :terminal without argument */\n#define TL_FINISH_NOCLOSE   'n'\t/* ++noclose */\n#define TL_FINISH_OPEN\t    'o'\t/* ++open */\n    char_u\t*tl_opencmd;\n    char_u\t*tl_eof_chars;\n\n#ifdef WIN3264\n    void\t*tl_winpty_config;\n    void\t*tl_winpty;\n\n    FILE\t*tl_out_fd;\n#endif\n#if defined(FEAT_SESSION)\n    char_u\t*tl_command;\n#endif\n    char_u\t*tl_kill;\n\n    /* last known vterm size */\n    int\t\ttl_rows;\n    int\t\ttl_cols;\n\n    char_u\t*tl_title; /* NULL or allocated */\n    char_u\t*tl_status_text; /* NULL or allocated */\n\n    /* Range of screen rows to update.  Zero based. */\n    int\t\ttl_dirty_row_start; /* MAX_ROW if nothing dirty */\n    int\t\ttl_dirty_row_end;   /* row below last one to update */\n    int\t\ttl_dirty_snapshot;  /* text updated after making snapshot */\n#ifdef FEAT_TIMERS\n    int\t\ttl_timer_set;\n    proftime_T\ttl_timer_due;\n#endif\n    int\t\ttl_postponed_scroll;\t/* to be scrolled up */\n\n    garray_T\ttl_scrollback;\n    int\t\ttl_scrollback_scrolled;\n    cellattr_T\ttl_default_color;\n\n    linenr_T\ttl_top_diff_rows;   /* rows of top diff file or zero */\n    linenr_T\ttl_bot_diff_rows;   /* rows of bottom diff file */\n\n    VTermPos\ttl_cursor_pos;\n    int\t\ttl_cursor_visible;\n    int\t\ttl_cursor_blink;\n    int\t\ttl_cursor_shape;  /* 1: block, 2: underline, 3: bar */\n    char_u\t*tl_cursor_color; /* NULL or allocated */\n\n    int\t\ttl_using_altscreen;\n};\n\n#define TMODE_ONCE 1\t    /* CTRL-\\ CTRL-N used */\n#define TMODE_LOOP 2\t    /* CTRL-W N used */\n\n/*\n * List of all active terminals.\n */\nstatic term_T *first_term = NULL;\n\n/* Terminal active in terminal_loop(). */\nstatic term_T *in_terminal_loop = NULL;\n\n#define MAX_ROW 999999\t    /* used for tl_dirty_row_end to update all rows */\n#define KEY_BUF_LEN 200\n\n/*\n * Functions with separate implementation for MS-Windows and Unix-like systems.\n */\nstatic int term_and_job_init(term_T *term, typval_T *argvar, char **argv, jobopt_T *opt, jobopt_T *orig_opt);\nstatic int create_pty_only(term_T *term, jobopt_T *opt);\nstatic void term_report_winsize(term_T *term, int rows, int cols);\nstatic void term_free_vterm(term_T *term);\n#ifdef FEAT_GUI\nstatic void update_system_term(term_T *term);\n#endif\n\n/* The character that we know (or assume) that the terminal expects for the\n * backspace key. */\nstatic int term_backspace_char = BS;\n\n/* \"Terminal\" highlight group colors. */\nstatic int term_default_cterm_fg = -1;\nstatic int term_default_cterm_bg = -1;\n\n/* Store the last set and the desired cursor properties, so that we only update\n * them when needed.  Doing it unnecessary may result in flicker. */\nstatic char_u\t*last_set_cursor_color = NULL;\nstatic char_u\t*desired_cursor_color = NULL;\nstatic int\tlast_set_cursor_shape = -1;\nstatic int\tdesired_cursor_shape = -1;\nstatic int\tlast_set_cursor_blink = -1;\nstatic int\tdesired_cursor_blink = -1;\n\n\n/**************************************\n * 1. Generic code for all systems.\n */\n\n    static int\ncursor_color_equal(char_u *lhs_color, char_u *rhs_color)\n{\n    if (lhs_color != NULL && rhs_color != NULL)\n\treturn STRCMP(lhs_color, rhs_color) == 0;\n    return lhs_color == NULL && rhs_color == NULL;\n}\n\n    static void\ncursor_color_copy(char_u **to_color, char_u *from_color)\n{\n    // Avoid a free & alloc if the value is already right.\n    if (cursor_color_equal(*to_color, from_color))\n\treturn;\n    vim_free(*to_color);\n    *to_color = (from_color == NULL) ? NULL : vim_strsave(from_color);\n}\n\n    static char_u *\ncursor_color_get(char_u *color)\n{\n    return (color == NULL) ? (char_u *)\"\" : color;\n}\n\n\n/*\n * Parse 'termwinsize' and set \"rows\" and \"cols\" for the terminal size in the\n * current window.\n * Sets \"rows\" and/or \"cols\" to zero when it should follow the window size.\n * Return TRUE if the size is the minimum size: \"24*80\".\n */\n    static int\nparse_termwinsize(win_T *wp, int *rows, int *cols)\n{\n    int\tminsize = FALSE;\n\n    *rows = 0;\n    *cols = 0;\n\n    if (*wp->w_p_tws != NUL)\n    {\n\tchar_u *p = vim_strchr(wp->w_p_tws, 'x');\n\n\t/* Syntax of value was already checked when it's set. */\n\tif (p == NULL)\n\t{\n\t    minsize = TRUE;\n\t    p = vim_strchr(wp->w_p_tws, '*');\n\t}\n\t*rows = atoi((char *)wp->w_p_tws);\n\t*cols = atoi((char *)p + 1);\n    }\n    return minsize;\n}\n\n/*\n * Determine the terminal size from 'termwinsize' and the current window.\n */\n    static void\nset_term_and_win_size(term_T *term)\n{\n#ifdef FEAT_GUI\n    if (term->tl_system)\n    {\n\t/* Use the whole screen for the system command.  However, it will start\n\t * at the command line and scroll up as needed, using tl_toprow. */\n\tterm->tl_rows = Rows;\n\tterm->tl_cols = Columns;\n\treturn;\n    }\n#endif\n    if (parse_termwinsize(curwin, &term->tl_rows, &term->tl_cols))\n    {\n\tif (term->tl_rows != 0)\n\t    term->tl_rows = MAX(term->tl_rows, curwin->w_height);\n\tif (term->tl_cols != 0)\n\t    term->tl_cols = MAX(term->tl_cols, curwin->w_width);\n    }\n    if (term->tl_rows == 0)\n\tterm->tl_rows = curwin->w_height;\n    else\n\twin_setheight_win(term->tl_rows, curwin);\n    if (term->tl_cols == 0)\n\tterm->tl_cols = curwin->w_width;\n    else\n\twin_setwidth_win(term->tl_cols, curwin);\n}\n\n/*\n * Initialize job options for a terminal job.\n * Caller may overrule some of them.\n */\n    void\ninit_job_options(jobopt_T *opt)\n{\n    clear_job_options(opt);\n\n    opt->jo_mode = MODE_RAW;\n    opt->jo_out_mode = MODE_RAW;\n    opt->jo_err_mode = MODE_RAW;\n    opt->jo_set = JO_MODE | JO_OUT_MODE | JO_ERR_MODE;\n}\n\n/*\n * Set job options mandatory for a terminal job.\n */\n    static void\nsetup_job_options(jobopt_T *opt, int rows, int cols)\n{\n#ifndef WIN3264\n    /* Win32: Redirecting the job output won't work, thus always connect stdout\n     * here. */\n    if (!(opt->jo_set & JO_OUT_IO))\n#endif\n    {\n\t/* Connect stdout to the terminal. */\n\topt->jo_io[PART_OUT] = JIO_BUFFER;\n\topt->jo_io_buf[PART_OUT] = curbuf->b_fnum;\n\topt->jo_modifiable[PART_OUT] = 0;\n\topt->jo_set |= JO_OUT_IO + JO_OUT_BUF + JO_OUT_MODIFIABLE;\n    }\n\n#ifndef WIN3264\n    /* Win32: Redirecting the job output won't work, thus always connect stderr\n     * here. */\n    if (!(opt->jo_set & JO_ERR_IO))\n#endif\n    {\n\t/* Connect stderr to the terminal. */\n\topt->jo_io[PART_ERR] = JIO_BUFFER;\n\topt->jo_io_buf[PART_ERR] = curbuf->b_fnum;\n\topt->jo_modifiable[PART_ERR] = 0;\n\topt->jo_set |= JO_ERR_IO + JO_ERR_BUF + JO_ERR_MODIFIABLE;\n    }\n\n    opt->jo_pty = TRUE;\n    if ((opt->jo_set2 & JO2_TERM_ROWS) == 0)\n\topt->jo_term_rows = rows;\n    if ((opt->jo_set2 & JO2_TERM_COLS) == 0)\n\topt->jo_term_cols = cols;\n}\n\n/*\n * Close a terminal buffer (and its window).  Used when creating the terminal\n * fails.\n */\n    static void\nterm_close_buffer(buf_T *buf, buf_T *old_curbuf)\n{\n    free_terminal(buf);\n    if (old_curbuf != NULL)\n    {\n\t--curbuf->b_nwindows;\n\tcurbuf = old_curbuf;\n\tcurwin->w_buffer = curbuf;\n\t++curbuf->b_nwindows;\n    }\n\n    /* Wiping out the buffer will also close the window and call\n     * free_terminal(). */\n    do_buffer(DOBUF_WIPE, DOBUF_FIRST, FORWARD, buf->b_fnum, TRUE);\n}\n\n/*\n * Start a terminal window and return its buffer.\n * Use either \"argvar\" or \"argv\", the other must be NULL.\n * When \"flags\" has TERM_START_NOJOB only create the buffer, b_term and open\n * the window.\n * Returns NULL when failed.\n */\n    buf_T *\nterm_start(\n\ttypval_T    *argvar,\n\tchar\t    **argv,\n\tjobopt_T    *opt,\n\tint\t    flags)\n{\n    exarg_T\tsplit_ea;\n    win_T\t*old_curwin = curwin;\n    term_T\t*term;\n    buf_T\t*old_curbuf = NULL;\n    int\t\tres;\n    buf_T\t*newbuf;\n    int\t\tvertical = opt->jo_vertical || (cmdmod.split & WSP_VERT);\n    jobopt_T\torig_opt;  // only partly filled\n\n    if (check_restricted() || check_secure())\n\treturn NULL;\n\n    if ((opt->jo_set & (JO_IN_IO + JO_OUT_IO + JO_ERR_IO))\n\t\t\t\t\t == (JO_IN_IO + JO_OUT_IO + JO_ERR_IO)\n\t|| (!(opt->jo_set & JO_OUT_IO) && (opt->jo_set & JO_OUT_BUF))\n\t|| (!(opt->jo_set & JO_ERR_IO) && (opt->jo_set & JO_ERR_BUF)))\n    {\n\tEMSG(_(e_invarg));\n\treturn NULL;\n    }\n\n    term = (term_T *)alloc_clear(sizeof(term_T));\n    if (term == NULL)\n\treturn NULL;\n    term->tl_dirty_row_end = MAX_ROW;\n    term->tl_cursor_visible = TRUE;\n    term->tl_cursor_shape = VTERM_PROP_CURSORSHAPE_BLOCK;\n    term->tl_finish = opt->jo_term_finish;\n#ifdef FEAT_GUI\n    term->tl_system = (flags & TERM_START_SYSTEM);\n#endif\n    ga_init2(&term->tl_scrollback, sizeof(sb_line_T), 300);\n\n    vim_memset(&split_ea, 0, sizeof(split_ea));\n    if (opt->jo_curwin)\n    {\n\t/* Create a new buffer in the current window. */\n\tif (!can_abandon(curbuf, flags & TERM_START_FORCEIT))\n\t{\n\t    no_write_message();\n\t    vim_free(term);\n\t    return NULL;\n\t}\n\tif (do_ecmd(0, NULL, NULL, &split_ea, ECMD_ONE,\n\t\t     ECMD_HIDE\n\t\t\t   + ((flags & TERM_START_FORCEIT) ? ECMD_FORCEIT : 0),\n\t\t     curwin) == FAIL)\n\t{\n\t    vim_free(term);\n\t    return NULL;\n\t}\n    }\n    else if (opt->jo_hidden || (flags & TERM_START_SYSTEM))\n    {\n\tbuf_T *buf;\n\n\t/* Create a new buffer without a window. Make it the current buffer for\n\t * a moment to be able to do the initialisations. */\n\tbuf = buflist_new((char_u *)\"\", NULL, (linenr_T)0,\n\t\t\t\t\t\t\t BLN_NEW | BLN_LISTED);\n\tif (buf == NULL || ml_open(buf) == FAIL)\n\t{\n\t    vim_free(term);\n\t    return NULL;\n\t}\n\told_curbuf = curbuf;\n\t--curbuf->b_nwindows;\n\tcurbuf = buf;\n\tcurwin->w_buffer = buf;\n\t++curbuf->b_nwindows;\n    }\n    else\n    {\n\t/* Open a new window or tab. */\n\tsplit_ea.cmdidx = CMD_new;\n\tsplit_ea.cmd = (char_u *)\"new\";\n\tsplit_ea.arg = (char_u *)\"\";\n\tif (opt->jo_term_rows > 0 && !vertical)\n\t{\n\t    split_ea.line2 = opt->jo_term_rows;\n\t    split_ea.addr_count = 1;\n\t}\n\tif (opt->jo_term_cols > 0 && vertical)\n\t{\n\t    split_ea.line2 = opt->jo_term_cols;\n\t    split_ea.addr_count = 1;\n\t}\n\n\tif (vertical)\n\t    cmdmod.split |= WSP_VERT;\n\tex_splitview(&split_ea);\n\tif (curwin == old_curwin)\n\t{\n\t    /* split failed */\n\t    vim_free(term);\n\t    return NULL;\n\t}\n    }\n    term->tl_buffer = curbuf;\n    curbuf->b_term = term;\n\n    if (!opt->jo_hidden)\n    {\n\t/* Only one size was taken care of with :new, do the other one.  With\n\t * \"curwin\" both need to be done. */\n\tif (opt->jo_term_rows > 0 && (opt->jo_curwin || vertical))\n\t    win_setheight(opt->jo_term_rows);\n\tif (opt->jo_term_cols > 0 && (opt->jo_curwin || !vertical))\n\t    win_setwidth(opt->jo_term_cols);\n    }\n\n    /* Link the new terminal in the list of active terminals. */\n    term->tl_next = first_term;\n    first_term = term;\n\n    if (opt->jo_term_name != NULL)\n\tcurbuf->b_ffname = vim_strsave(opt->jo_term_name);\n    else if (argv != NULL)\n\tcurbuf->b_ffname = vim_strsave((char_u *)\"!system\");\n    else\n    {\n\tint\ti;\n\tsize_t\tlen;\n\tchar_u\t*cmd, *p;\n\n\tif (argvar->v_type == VAR_STRING)\n\t{\n\t    cmd = argvar->vval.v_string;\n\t    if (cmd == NULL)\n\t\tcmd = (char_u *)\"\";\n\t    else if (STRCMP(cmd, \"NONE\") == 0)\n\t\tcmd = (char_u *)\"pty\";\n\t}\n\telse if (argvar->v_type != VAR_LIST\n\t\t|| argvar->vval.v_list == NULL\n\t\t|| argvar->vval.v_list->lv_len < 1\n\t\t|| (cmd = tv_get_string_chk(\n\t\t\t       &argvar->vval.v_list->lv_first->li_tv)) == NULL)\n\t    cmd = (char_u*)\"\";\n\n\tlen = STRLEN(cmd) + 10;\n\tp = alloc((int)len);\n\n\tfor (i = 0; p != NULL; ++i)\n\t{\n\t    /* Prepend a ! to the command name to avoid the buffer name equals\n\t     * the executable, otherwise \":w!\" would overwrite it. */\n\t    if (i == 0)\n\t\tvim_snprintf((char *)p, len, \"!%s\", cmd);\n\t    else\n\t\tvim_snprintf((char *)p, len, \"!%s (%d)\", cmd, i);\n\t    if (buflist_findname(p) == NULL)\n\t    {\n\t\tvim_free(curbuf->b_ffname);\n\t\tcurbuf->b_ffname = p;\n\t\tbreak;\n\t    }\n\t}\n    }\n    curbuf->b_fname = curbuf->b_ffname;\n\n    if (opt->jo_term_opencmd != NULL)\n\tterm->tl_opencmd = vim_strsave(opt->jo_term_opencmd);\n\n    if (opt->jo_eof_chars != NULL)\n\tterm->tl_eof_chars = vim_strsave(opt->jo_eof_chars);\n\n    set_string_option_direct((char_u *)\"buftype\", -1,\n\t\t\t\t  (char_u *)\"terminal\", OPT_FREE|OPT_LOCAL, 0);\n    // Avoid that 'buftype' is reset when this buffer is entered.\n    curbuf->b_p_initialized = TRUE;\n\n    /* Mark the buffer as not modifiable. It can only be made modifiable after\n     * the job finished. */\n    curbuf->b_p_ma = FALSE;\n\n    set_term_and_win_size(term);\n#ifdef WIN3264\n    mch_memmove(orig_opt.jo_io, opt->jo_io, sizeof(orig_opt.jo_io));\n#endif\n    setup_job_options(opt, term->tl_rows, term->tl_cols);\n\n    if (flags & TERM_START_NOJOB)\n\treturn curbuf;\n\n#if defined(FEAT_SESSION)\n    /* Remember the command for the session file. */\n    if (opt->jo_term_norestore || argv != NULL)\n    {\n\tterm->tl_command = vim_strsave((char_u *)\"NONE\");\n    }\n    else if (argvar->v_type == VAR_STRING)\n    {\n\tchar_u\t*cmd = argvar->vval.v_string;\n\n\tif (cmd != NULL && STRCMP(cmd, p_sh) != 0)\n\t    term->tl_command = vim_strsave(cmd);\n    }\n    else if (argvar->v_type == VAR_LIST\n\t    && argvar->vval.v_list != NULL\n\t    && argvar->vval.v_list->lv_len > 0)\n    {\n\tgarray_T\tga;\n\tlistitem_T\t*item;\n\n\tga_init2(&ga, 1, 100);\n\tfor (item = argvar->vval.v_list->lv_first;\n\t\t\t\t\titem != NULL; item = item->li_next)\n\t{\n\t    char_u *s = tv_get_string_chk(&item->li_tv);\n\t    char_u *p;\n\n\t    if (s == NULL)\n\t\tbreak;\n\t    p = vim_strsave_fnameescape(s, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    ga_concat(&ga, p);\n\t    vim_free(p);\n\t    ga_append(&ga, ' ');\n\t}\n\tif (item == NULL)\n\t{\n\t    ga_append(&ga, NUL);\n\t    term->tl_command = ga.ga_data;\n\t}\n\telse\n\t    ga_clear(&ga);\n    }\n#endif\n\n    if (opt->jo_term_kill != NULL)\n    {\n\tchar_u *p = skiptowhite(opt->jo_term_kill);\n\n\tterm->tl_kill = vim_strnsave(opt->jo_term_kill, p - opt->jo_term_kill);\n    }\n\n    /* System dependent: setup the vterm and maybe start the job in it. */\n    if (argv == NULL\n\t    && argvar->v_type == VAR_STRING\n\t    && argvar->vval.v_string != NULL\n\t    && STRCMP(argvar->vval.v_string, \"NONE\") == 0)\n\tres = create_pty_only(term, opt);\n    else\n\tres = term_and_job_init(term, argvar, argv, opt, &orig_opt);\n\n    newbuf = curbuf;\n    if (res == OK)\n    {\n\t/* Get and remember the size we ended up with.  Update the pty. */\n\tvterm_get_size(term->tl_vterm, &term->tl_rows, &term->tl_cols);\n\tterm_report_winsize(term, term->tl_rows, term->tl_cols);\n#ifdef FEAT_GUI\n\tif (term->tl_system)\n\t{\n\t    /* display first line below typed command */\n\t    term->tl_toprow = msg_row + 1;\n\t    term->tl_dirty_row_end = 0;\n\t}\n#endif\n\n\t/* Make sure we don't get stuck on sending keys to the job, it leads to\n\t * a deadlock if the job is waiting for Vim to read. */\n\tchannel_set_nonblock(term->tl_job->jv_channel, PART_IN);\n\n\tif (old_curbuf != NULL)\n\t{\n\t    --curbuf->b_nwindows;\n\t    curbuf = old_curbuf;\n\t    curwin->w_buffer = curbuf;\n\t    ++curbuf->b_nwindows;\n\t}\n    }\n    else\n    {\n\tterm_close_buffer(curbuf, old_curbuf);\n\treturn NULL;\n    }\n\n    apply_autocmds(EVENT_TERMINALOPEN, NULL, NULL, FALSE, newbuf);\n    return newbuf;\n}\n\n/*\n * \":terminal\": open a terminal window and execute a job in it.\n */\n    void\nex_terminal(exarg_T *eap)\n{\n    typval_T\targvar[2];\n    jobopt_T\topt;\n    char_u\t*cmd;\n    char_u\t*tofree = NULL;\n\n    init_job_options(&opt);\n\n    cmd = eap->arg;\n    while (*cmd == '+' && *(cmd + 1) == '+')\n    {\n\tchar_u  *p, *ep;\n\n\tcmd += 2;\n\tp = skiptowhite(cmd);\n\tep = vim_strchr(cmd, '=');\n\tif (ep != NULL && ep < p)\n\t    p = ep;\n\n\tif ((int)(p - cmd) == 5 && STRNICMP(cmd, \"close\", 5) == 0)\n\t    opt.jo_term_finish = 'c';\n\telse if ((int)(p - cmd) == 7 && STRNICMP(cmd, \"noclose\", 7) == 0)\n\t    opt.jo_term_finish = 'n';\n\telse if ((int)(p - cmd) == 4 && STRNICMP(cmd, \"open\", 4) == 0)\n\t    opt.jo_term_finish = 'o';\n\telse if ((int)(p - cmd) == 6 && STRNICMP(cmd, \"curwin\", 6) == 0)\n\t    opt.jo_curwin = 1;\n\telse if ((int)(p - cmd) == 6 && STRNICMP(cmd, \"hidden\", 6) == 0)\n\t    opt.jo_hidden = 1;\n\telse if ((int)(p - cmd) == 9 && STRNICMP(cmd, \"norestore\", 9) == 0)\n\t    opt.jo_term_norestore = 1;\n\telse if ((int)(p - cmd) == 4 && STRNICMP(cmd, \"kill\", 4) == 0\n\t\t&& ep != NULL)\n\t{\n\t    opt.jo_set2 |= JO2_TERM_KILL;\n\t    opt.jo_term_kill = ep + 1;\n\t    p = skiptowhite(cmd);\n\t}\n\telse if ((int)(p - cmd) == 4 && STRNICMP(cmd, \"rows\", 4) == 0\n\t\t&& ep != NULL && isdigit(ep[1]))\n\t{\n\t    opt.jo_set2 |= JO2_TERM_ROWS;\n\t    opt.jo_term_rows = atoi((char *)ep + 1);\n\t    p = skiptowhite(cmd);\n\t}\n\telse if ((int)(p - cmd) == 4 && STRNICMP(cmd, \"cols\", 4) == 0\n\t\t&& ep != NULL && isdigit(ep[1]))\n\t{\n\t    opt.jo_set2 |= JO2_TERM_COLS;\n\t    opt.jo_term_cols = atoi((char *)ep + 1);\n\t    p = skiptowhite(cmd);\n\t}\n\telse if ((int)(p - cmd) == 3 && STRNICMP(cmd, \"eof\", 3) == 0\n\t\t\t\t\t\t\t\t && ep != NULL)\n\t{\n\t    char_u *buf = NULL;\n\t    char_u *keys;\n\n\t    p = skiptowhite(cmd);\n\t    *p = NUL;\n\t    keys = replace_termcodes(ep + 1, &buf, TRUE, TRUE, TRUE);\n\t    opt.jo_set2 |= JO2_EOF_CHARS;\n\t    opt.jo_eof_chars = vim_strsave(keys);\n\t    vim_free(buf);\n\t    *p = ' ';\n\t}\n\telse\n\t{\n\t    if (*p)\n\t\t*p = NUL;\n\t    EMSG2(_(\"E181: Invalid attribute: %s\"), cmd);\n\t    goto theend;\n\t}\n\tcmd = skipwhite(p);\n    }\n    if (*cmd == NUL)\n    {\n\t/* Make a copy of 'shell', an autocommand may change the option. */\n\ttofree = cmd = vim_strsave(p_sh);\n\n\t/* default to close when the shell exits */\n\tif (opt.jo_term_finish == NUL)\n\t    opt.jo_term_finish = 'c';\n    }\n\n    if (eap->addr_count > 0)\n    {\n\t/* Write lines from current buffer to the job. */\n\topt.jo_set |= JO_IN_IO | JO_IN_BUF | JO_IN_TOP | JO_IN_BOT;\n\topt.jo_io[PART_IN] = JIO_BUFFER;\n\topt.jo_io_buf[PART_IN] = curbuf->b_fnum;\n\topt.jo_in_top = eap->line1;\n\topt.jo_in_bot = eap->line2;\n    }\n\n    argvar[0].v_type = VAR_STRING;\n    argvar[0].vval.v_string = cmd;\n    argvar[1].v_type = VAR_UNKNOWN;\n    term_start(argvar, NULL, &opt, eap->forceit ? TERM_START_FORCEIT : 0);\n    vim_free(tofree);\n\ntheend:\n    vim_free(opt.jo_eof_chars);\n}\n\n#if defined(FEAT_SESSION) || defined(PROTO)\n/*\n * Write a :terminal command to the session file to restore the terminal in\n * window \"wp\".\n * Return FAIL if writing fails.\n */\n    int\nterm_write_session(FILE *fd, win_T *wp)\n{\n    term_T *term = wp->w_buffer->b_term;\n\n    /* Create the terminal and run the command.  This is not without\n     * risk, but let's assume the user only creates a session when this\n     * will be OK. */\n    if (fprintf(fd, \"terminal ++curwin ++cols=%d ++rows=%d \",\n\t\tterm->tl_cols, term->tl_rows) < 0)\n\treturn FAIL;\n    if (term->tl_command != NULL && fputs((char *)term->tl_command, fd) < 0)\n\treturn FAIL;\n\n    return put_eol(fd);\n}\n\n/*\n * Return TRUE if \"buf\" has a terminal that should be restored.\n */\n    int\nterm_should_restore(buf_T *buf)\n{\n    term_T\t*term = buf->b_term;\n\n    return term != NULL && (term->tl_command == NULL\n\t\t\t\t     || STRCMP(term->tl_command, \"NONE\") != 0);\n}\n#endif\n\n/*\n * Free the scrollback buffer for \"term\".\n */\n    static void\nfree_scrollback(term_T *term)\n{\n    int i;\n\n    for (i = 0; i < term->tl_scrollback.ga_len; ++i)\n\tvim_free(((sb_line_T *)term->tl_scrollback.ga_data + i)->sb_cells);\n    ga_clear(&term->tl_scrollback);\n}\n\n/*\n * Free a terminal and everything it refers to.\n * Kills the job if there is one.\n * Called when wiping out a buffer.\n */\n    void\nfree_terminal(buf_T *buf)\n{\n    term_T\t*term = buf->b_term;\n    term_T\t*tp;\n\n    if (term == NULL)\n\treturn;\n    if (first_term == term)\n\tfirst_term = term->tl_next;\n    else\n\tfor (tp = first_term; tp->tl_next != NULL; tp = tp->tl_next)\n\t    if (tp->tl_next == term)\n\t    {\n\t\ttp->tl_next = term->tl_next;\n\t\tbreak;\n\t    }\n\n    if (term->tl_job != NULL)\n    {\n\tif (term->tl_job->jv_status != JOB_ENDED\n\t\t&& term->tl_job->jv_status != JOB_FINISHED\n\t\t&& term->tl_job->jv_status != JOB_FAILED)\n\t    job_stop(term->tl_job, NULL, \"kill\");\n\tjob_unref(term->tl_job);\n    }\n\n    free_scrollback(term);\n\n    term_free_vterm(term);\n    vim_free(term->tl_title);\n#ifdef FEAT_SESSION\n    vim_free(term->tl_command);\n#endif\n    vim_free(term->tl_kill);\n    vim_free(term->tl_status_text);\n    vim_free(term->tl_opencmd);\n    vim_free(term->tl_eof_chars);\n#ifdef WIN3264\n    if (term->tl_out_fd != NULL)\n\tfclose(term->tl_out_fd);\n#endif\n    vim_free(term->tl_cursor_color);\n    vim_free(term);\n    buf->b_term = NULL;\n    if (in_terminal_loop == term)\n\tin_terminal_loop = NULL;\n}\n\n/*\n * Get the part that is connected to the tty. Normally this is PART_IN, but\n * when writing buffer lines to the job it can be another.  This makes it\n * possible to do \"1,5term vim -\".\n */\n    static ch_part_T\nget_tty_part(term_T *term)\n{\n#ifdef UNIX\n    ch_part_T\tparts[3] = {PART_IN, PART_OUT, PART_ERR};\n    int\t\ti;\n\n    for (i = 0; i < 3; ++i)\n    {\n\tint fd = term->tl_job->jv_channel->ch_part[parts[i]].ch_fd;\n\n\tif (isatty(fd))\n\t    return parts[i];\n    }\n#endif\n    return PART_IN;\n}\n\n/*\n * Write job output \"msg[len]\" to the vterm.\n */\n    static void\nterm_write_job_output(term_T *term, char_u *msg, size_t len)\n{\n    VTerm\t*vterm = term->tl_vterm;\n    size_t\tprevlen = vterm_output_get_buffer_current(vterm);\n\n    vterm_input_write(vterm, (char *)msg, len);\n\n    /* flush vterm buffer when vterm responded to control sequence */\n    if (prevlen != vterm_output_get_buffer_current(vterm))\n    {\n\tchar   buf[KEY_BUF_LEN];\n\tsize_t curlen = vterm_output_read(vterm, buf, KEY_BUF_LEN);\n\n\tif (curlen > 0)\n\t    channel_send(term->tl_job->jv_channel, get_tty_part(term),\n\t\t\t\t\t     (char_u *)buf, (int)curlen, NULL);\n    }\n\n    /* this invokes the damage callbacks */\n    vterm_screen_flush_damage(vterm_obtain_screen(vterm));\n}\n\n    static void\nupdate_cursor(term_T *term, int redraw)\n{\n    if (term->tl_normal_mode)\n\treturn;\n#ifdef FEAT_GUI\n    if (term->tl_system)\n\twindgoto(term->tl_cursor_pos.row + term->tl_toprow,\n\t\t\t\t\t\t      term->tl_cursor_pos.col);\n    else\n#endif\n\tsetcursor();\n    if (redraw)\n    {\n\tif (term->tl_buffer == curbuf && term->tl_cursor_visible)\n\t    cursor_on();\n\tout_flush();\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    gui_update_cursor(FALSE, FALSE);\n\t    gui_mch_flush();\n\t}\n#endif\n    }\n}\n\n/*\n * Invoked when \"msg\" output from a job was received.  Write it to the terminal\n * of \"buffer\".\n */\n    void\nwrite_to_term(buf_T *buffer, char_u *msg, channel_T *channel)\n{\n    size_t\tlen = STRLEN(msg);\n    term_T\t*term = buffer->b_term;\n\n#ifdef WIN3264\n    /* Win32: Cannot redirect output of the job, intercept it here and write to\n     * the file. */\n    if (term->tl_out_fd != NULL)\n    {\n\tch_log(channel, \"Writing %d bytes to output file\", (int)len);\n\tfwrite(msg, len, 1, term->tl_out_fd);\n\treturn;\n    }\n#endif\n\n    if (term->tl_vterm == NULL)\n    {\n\tch_log(channel, \"NOT writing %d bytes to terminal\", (int)len);\n\treturn;\n    }\n    ch_log(channel, \"writing %d bytes to terminal\", (int)len);\n    term_write_job_output(term, msg, len);\n\n#ifdef FEAT_GUI\n    if (term->tl_system)\n    {\n\t/* show system output, scrolling up the screen as needed */\n\tupdate_system_term(term);\n\tupdate_cursor(term, TRUE);\n    }\n    else\n#endif\n    /* In Terminal-Normal mode we are displaying the buffer, not the terminal\n     * contents, thus no screen update is needed. */\n    if (!term->tl_normal_mode)\n    {\n\t// Don't use update_screen() when editing the command line, it gets\n\t// cleared.\n\t// TODO: only update once in a while.\n\tch_log(term->tl_job->jv_channel, \"updating screen\");\n\tif (buffer == curbuf && (State & CMDLINE) == 0)\n\t{\n\t    update_screen(VALID_NO_UPDATE);\n\t    /* update_screen() can be slow, check the terminal wasn't closed\n\t     * already */\n\t    if (buffer == curbuf && curbuf->b_term != NULL)\n\t\tupdate_cursor(curbuf->b_term, TRUE);\n\t}\n\telse\n\t    redraw_after_callback(TRUE);\n    }\n}\n\n/*\n * Send a mouse position and click to the vterm\n */\n    static int\nterm_send_mouse(VTerm *vterm, int button, int pressed)\n{\n    VTermModifier   mod = VTERM_MOD_NONE;\n\n    vterm_mouse_move(vterm, mouse_row - W_WINROW(curwin),\n\t\t\t\t\t    mouse_col - curwin->w_wincol, mod);\n    if (button != 0)\n\tvterm_mouse_button(vterm, button, pressed, mod);\n    return TRUE;\n}\n\nstatic int enter_mouse_col = -1;\nstatic int enter_mouse_row = -1;\n\n/*\n * Handle a mouse click, drag or release.\n * Return TRUE when a mouse event is sent to the terminal.\n */\n    static int\nterm_mouse_click(VTerm *vterm, int key)\n{\n#if defined(FEAT_CLIPBOARD)\n    /* For modeless selection mouse drag and release events are ignored, unless\n     * they are preceded with a mouse down event */\n    static int\t    ignore_drag_release = TRUE;\n    VTermMouseState mouse_state;\n\n    vterm_state_get_mousestate(vterm_obtain_state(vterm), &mouse_state);\n    if (mouse_state.flags == 0)\n    {\n\t/* Terminal is not using the mouse, use modeless selection. */\n\tswitch (key)\n\t{\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\t/* Ignore drag and release events when the button-down wasn't\n\t\t * seen before. */\n\t\tif (ignore_drag_release)\n\t\t{\n\t\t    int save_mouse_col, save_mouse_row;\n\n\t\t    if (enter_mouse_col < 0)\n\t\t\tbreak;\n\n\t\t    /* mouse click in the window gave us focus, handle that\n\t\t     * click now */\n\t\t    save_mouse_col = mouse_col;\n\t\t    save_mouse_row = mouse_row;\n\t\t    mouse_col = enter_mouse_col;\n\t\t    mouse_row = enter_mouse_row;\n\t\t    clip_modeless(MOUSE_LEFT, TRUE, FALSE);\n\t\t    mouse_col = save_mouse_col;\n\t\t    mouse_row = save_mouse_row;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tif (key == K_LEFTRELEASE || key == K_RIGHTRELEASE)\n\t\t    ignore_drag_release = TRUE;\n\t\telse\n\t\t    ignore_drag_release = FALSE;\n\t\t/* Should we call mouse_has() here? */\n\t\tif (clip_star.available)\n\t\t{\n\t\t    int\t    button, is_click, is_drag;\n\n\t\t    button = get_mouse_button(KEY2TERMCAP1(key),\n\t\t\t\t\t\t\t &is_click, &is_drag);\n\t\t    if (mouse_model_popup() && button == MOUSE_LEFT\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\t    {\n\t\t\t/* Translate shift-left to right button. */\n\t\t\tbutton = MOUSE_RIGHT;\n\t\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t\t    }\n\t\t    clip_modeless(button, is_click, is_drag);\n\t\t}\n\t\tbreak;\n\n\tcase K_MIDDLEMOUSE:\n\t\tif (clip_star.available)\n\t\t    insert_reg('*', TRUE);\n\t\tbreak;\n\t}\n\tenter_mouse_col = -1;\n\treturn FALSE;\n    }\n#endif\n    enter_mouse_col = -1;\n\n    switch (key)\n    {\n\tcase K_LEFTMOUSE:\n\tcase K_LEFTMOUSE_NM:\tterm_send_mouse(vterm, 1, 1); break;\n\tcase K_LEFTDRAG:\tterm_send_mouse(vterm, 1, 1); break;\n\tcase K_LEFTRELEASE:\n\tcase K_LEFTRELEASE_NM:\tterm_send_mouse(vterm, 1, 0); break;\n\tcase K_MOUSEMOVE:\tterm_send_mouse(vterm, 0, 0); break;\n\tcase K_MIDDLEMOUSE:\tterm_send_mouse(vterm, 2, 1); break;\n\tcase K_MIDDLEDRAG:\tterm_send_mouse(vterm, 2, 1); break;\n\tcase K_MIDDLERELEASE:\tterm_send_mouse(vterm, 2, 0); break;\n\tcase K_RIGHTMOUSE:\tterm_send_mouse(vterm, 3, 1); break;\n\tcase K_RIGHTDRAG:\tterm_send_mouse(vterm, 3, 1); break;\n\tcase K_RIGHTRELEASE:\tterm_send_mouse(vterm, 3, 0); break;\n    }\n    return TRUE;\n}\n\n/*\n * Convert typed key \"c\" into bytes to send to the job.\n * Return the number of bytes in \"buf\".\n */\n    static int\nterm_convert_key(term_T *term, int c, char *buf)\n{\n    VTerm\t    *vterm = term->tl_vterm;\n    VTermKey\t    key = VTERM_KEY_NONE;\n    VTermModifier   mod = VTERM_MOD_NONE;\n    int\t\t    other = FALSE;\n\n    switch (c)\n    {\n\t/* don't use VTERM_KEY_ENTER, it may do an unwanted conversion */\n\n\t\t\t\t/* don't use VTERM_KEY_BACKSPACE, it always\n\t\t\t\t * becomes 0x7f DEL */\n\tcase K_BS:\t\tc = term_backspace_char; break;\n\n\tcase ESC:\t\tkey = VTERM_KEY_ESCAPE; break;\n\tcase K_DEL:\t\tkey = VTERM_KEY_DEL; break;\n\tcase K_DOWN:\t\tkey = VTERM_KEY_DOWN; break;\n\tcase K_S_DOWN:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_DOWN; break;\n\tcase K_END:\t\tkey = VTERM_KEY_END; break;\n\tcase K_S_END:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_END; break;\n\tcase K_C_END:\t\tmod = VTERM_MOD_CTRL;\n\t\t\t\tkey = VTERM_KEY_END; break;\n\tcase K_F10:\t\tkey = VTERM_KEY_FUNCTION(10); break;\n\tcase K_F11:\t\tkey = VTERM_KEY_FUNCTION(11); break;\n\tcase K_F12:\t\tkey = VTERM_KEY_FUNCTION(12); break;\n\tcase K_F1:\t\tkey = VTERM_KEY_FUNCTION(1); break;\n\tcase K_F2:\t\tkey = VTERM_KEY_FUNCTION(2); break;\n\tcase K_F3:\t\tkey = VTERM_KEY_FUNCTION(3); break;\n\tcase K_F4:\t\tkey = VTERM_KEY_FUNCTION(4); break;\n\tcase K_F5:\t\tkey = VTERM_KEY_FUNCTION(5); break;\n\tcase K_F6:\t\tkey = VTERM_KEY_FUNCTION(6); break;\n\tcase K_F7:\t\tkey = VTERM_KEY_FUNCTION(7); break;\n\tcase K_F8:\t\tkey = VTERM_KEY_FUNCTION(8); break;\n\tcase K_F9:\t\tkey = VTERM_KEY_FUNCTION(9); break;\n\tcase K_HOME:\t\tkey = VTERM_KEY_HOME; break;\n\tcase K_S_HOME:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_HOME; break;\n\tcase K_C_HOME:\t\tmod = VTERM_MOD_CTRL;\n\t\t\t\tkey = VTERM_KEY_HOME; break;\n\tcase K_INS:\t\tkey = VTERM_KEY_INS; break;\n\tcase K_K0:\t\tkey = VTERM_KEY_KP_0; break;\n\tcase K_K1:\t\tkey = VTERM_KEY_KP_1; break;\n\tcase K_K2:\t\tkey = VTERM_KEY_KP_2; break;\n\tcase K_K3:\t\tkey = VTERM_KEY_KP_3; break;\n\tcase K_K4:\t\tkey = VTERM_KEY_KP_4; break;\n\tcase K_K5:\t\tkey = VTERM_KEY_KP_5; break;\n\tcase K_K6:\t\tkey = VTERM_KEY_KP_6; break;\n\tcase K_K7:\t\tkey = VTERM_KEY_KP_7; break;\n\tcase K_K8:\t\tkey = VTERM_KEY_KP_8; break;\n\tcase K_K9:\t\tkey = VTERM_KEY_KP_9; break;\n\tcase K_KDEL:\t\tkey = VTERM_KEY_DEL; break; /* TODO */\n\tcase K_KDIVIDE:\t\tkey = VTERM_KEY_KP_DIVIDE; break;\n\tcase K_KEND:\t\tkey = VTERM_KEY_KP_1; break; /* TODO */\n\tcase K_KENTER:\t\tkey = VTERM_KEY_KP_ENTER; break;\n\tcase K_KHOME:\t\tkey = VTERM_KEY_KP_7; break; /* TODO */\n\tcase K_KINS:\t\tkey = VTERM_KEY_KP_0; break; /* TODO */\n\tcase K_KMINUS:\t\tkey = VTERM_KEY_KP_MINUS; break;\n\tcase K_KMULTIPLY:\tkey = VTERM_KEY_KP_MULT; break;\n\tcase K_KPAGEDOWN:\tkey = VTERM_KEY_KP_3; break; /* TODO */\n\tcase K_KPAGEUP:\t\tkey = VTERM_KEY_KP_9; break; /* TODO */\n\tcase K_KPLUS:\t\tkey = VTERM_KEY_KP_PLUS; break;\n\tcase K_KPOINT:\t\tkey = VTERM_KEY_KP_PERIOD; break;\n\tcase K_LEFT:\t\tkey = VTERM_KEY_LEFT; break;\n\tcase K_S_LEFT:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_LEFT; break;\n\tcase K_C_LEFT:\t\tmod = VTERM_MOD_CTRL;\n\t\t\t\tkey = VTERM_KEY_LEFT; break;\n\tcase K_PAGEDOWN:\tkey = VTERM_KEY_PAGEDOWN; break;\n\tcase K_PAGEUP:\t\tkey = VTERM_KEY_PAGEUP; break;\n\tcase K_RIGHT:\t\tkey = VTERM_KEY_RIGHT; break;\n\tcase K_S_RIGHT:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_RIGHT; break;\n\tcase K_C_RIGHT:\t\tmod = VTERM_MOD_CTRL;\n\t\t\t\tkey = VTERM_KEY_RIGHT; break;\n\tcase K_UP:\t\tkey = VTERM_KEY_UP; break;\n\tcase K_S_UP:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_UP; break;\n\tcase TAB:\t\tkey = VTERM_KEY_TAB; break;\n\tcase K_S_TAB:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_TAB; break;\n\n\tcase K_MOUSEUP:\t\tother = term_send_mouse(vterm, 5, 1); break;\n\tcase K_MOUSEDOWN:\tother = term_send_mouse(vterm, 4, 1); break;\n\tcase K_MOUSELEFT:\t/* TODO */ return 0;\n\tcase K_MOUSERIGHT:\t/* TODO */ return 0;\n\n\tcase K_LEFTMOUSE:\n\tcase K_LEFTMOUSE_NM:\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_LEFTRELEASE_NM:\n\tcase K_MOUSEMOVE:\n\tcase K_MIDDLEMOUSE:\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\tcase K_RIGHTMOUSE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\tif (!term_mouse_click(vterm, c))\n\t\t\t\t    return 0;\n\t\t\t\tother = TRUE;\n\t\t\t\tbreak;\n\n\tcase K_X1MOUSE:\t\t/* TODO */ return 0;\n\tcase K_X1DRAG:\t\t/* TODO */ return 0;\n\tcase K_X1RELEASE:\t/* TODO */ return 0;\n\tcase K_X2MOUSE:\t\t/* TODO */ return 0;\n\tcase K_X2DRAG:\t\t/* TODO */ return 0;\n\tcase K_X2RELEASE:\t/* TODO */ return 0;\n\n\tcase K_IGNORE:\t\treturn 0;\n\tcase K_NOP:\t\treturn 0;\n\tcase K_UNDO:\t\treturn 0;\n\tcase K_HELP:\t\treturn 0;\n\tcase K_XF1:\t\tkey = VTERM_KEY_FUNCTION(1); break;\n\tcase K_XF2:\t\tkey = VTERM_KEY_FUNCTION(2); break;\n\tcase K_XF3:\t\tkey = VTERM_KEY_FUNCTION(3); break;\n\tcase K_XF4:\t\tkey = VTERM_KEY_FUNCTION(4); break;\n\tcase K_SELECT:\t\treturn 0;\n#ifdef FEAT_GUI\n\tcase K_VER_SCROLLBAR:\treturn 0;\n\tcase K_HOR_SCROLLBAR:\treturn 0;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\t\treturn 0;\n\tcase K_TABMENU:\t\treturn 0;\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\tcase K_F21:\t\tkey = VTERM_KEY_FUNCTION(21); break;\n#endif\n#ifdef FEAT_DND\n\tcase K_DROP:\t\treturn 0;\n#endif\n\tcase K_CURSORHOLD:\treturn 0;\n\tcase K_PS:\t\tvterm_keyboard_start_paste(vterm);\n\t\t\t\tother = TRUE;\n\t\t\t\tbreak;\n\tcase K_PE:\t\tvterm_keyboard_end_paste(vterm);\n\t\t\t\tother = TRUE;\n\t\t\t\tbreak;\n    }\n\n    /*\n     * Convert special keys to vterm keys:\n     * - Write keys to vterm: vterm_keyboard_key()\n     * - Write output to channel.\n     * TODO: use mod_mask\n     */\n    if (key != VTERM_KEY_NONE)\n\t/* Special key, let vterm convert it. */\n\tvterm_keyboard_key(vterm, key, mod);\n    else if (!other)\n\t/* Normal character, let vterm convert it. */\n\tvterm_keyboard_unichar(vterm, c, mod);\n\n    /* Read back the converted escape sequence. */\n    return (int)vterm_output_read(vterm, buf, KEY_BUF_LEN);\n}\n\n/*\n * Return TRUE if the job for \"term\" is still running.\n * If \"check_job_status\" is TRUE update the job status.\n */\n    static int\nterm_job_running_check(term_T *term, int check_job_status)\n{\n    /* Also consider the job finished when the channel is closed, to avoid a\n     * race condition when updating the title. */\n    if (term != NULL\n\t&& term->tl_job != NULL\n\t&& channel_is_open(term->tl_job->jv_channel))\n    {\n\tif (check_job_status)\n\t    job_status(term->tl_job);\n\treturn (term->tl_job->jv_status == JOB_STARTED\n\t\t|| term->tl_job->jv_channel->ch_keep_open);\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if the job for \"term\" is still running.\n */\n    int\nterm_job_running(term_T *term)\n{\n    return term_job_running_check(term, FALSE);\n}\n\n/*\n * Return TRUE if \"term\" has an active channel and used \":term NONE\".\n */\n    int\nterm_none_open(term_T *term)\n{\n    /* Also consider the job finished when the channel is closed, to avoid a\n     * race condition when updating the title. */\n    return term != NULL\n\t&& term->tl_job != NULL\n\t&& channel_is_open(term->tl_job->jv_channel)\n\t&& term->tl_job->jv_channel->ch_keep_open;\n}\n\n/*\n * Used when exiting: kill the job in \"buf\" if so desired.\n * Return OK when the job finished.\n * Return FAIL when the job is still running.\n */\n    int\nterm_try_stop_job(buf_T *buf)\n{\n    int\t    count;\n    char    *how = (char *)buf->b_term->tl_kill;\n\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n    if ((how == NULL || *how == NUL) && (p_confirm || cmdmod.confirm))\n    {\n\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\tint\tret;\n\n\tdialog_msg(buff, _(\"Kill job in \\\"%s\\\"?\"), buf->b_fname);\n\tret = vim_dialog_yesnocancel(VIM_QUESTION, NULL, buff, 1);\n\tif (ret == VIM_YES)\n\t    how = \"kill\";\n\telse if (ret == VIM_CANCEL)\n\t    return FAIL;\n    }\n#endif\n    if (how == NULL || *how == NUL)\n\treturn FAIL;\n\n    job_stop(buf->b_term->tl_job, NULL, how);\n\n    /* wait for up to a second for the job to die */\n    for (count = 0; count < 100; ++count)\n    {\n\t/* buffer, terminal and job may be cleaned up while waiting */\n\tif (!buf_valid(buf)\n\t\t|| buf->b_term == NULL\n\t\t|| buf->b_term->tl_job == NULL)\n\t    return OK;\n\n\t/* call job_status() to update jv_status */\n\tjob_status(buf->b_term->tl_job);\n\tif (buf->b_term->tl_job->jv_status >= JOB_ENDED)\n\t    return OK;\n\tui_delay(10L, FALSE);\n\tmch_check_messages();\n\tparse_queued_messages();\n    }\n    return FAIL;\n}\n\n/*\n * Add the last line of the scrollback buffer to the buffer in the window.\n */\n    static void\nadd_scrollback_line_to_buffer(term_T *term, char_u *text, int len)\n{\n    buf_T\t*buf = term->tl_buffer;\n    int\t\tempty = (buf->b_ml.ml_flags & ML_EMPTY);\n    linenr_T\tlnum = buf->b_ml.ml_line_count;\n\n#ifdef WIN3264\n    if (!enc_utf8 && enc_codepage > 0)\n    {\n\tWCHAR   *ret = NULL;\n\tint\tlength = 0;\n\n\tMultiByteToWideChar_alloc(CP_UTF8, 0, (char*)text, len + 1,\n\t\t\t\t\t\t\t   &ret, &length);\n\tif (ret != NULL)\n\t{\n\t    WideCharToMultiByte_alloc(enc_codepage, 0,\n\t\t\t\t      ret, length, (char **)&text, &len, 0, 0);\n\t    vim_free(ret);\n\t    ml_append_buf(term->tl_buffer, lnum, text, len, FALSE);\n\t    vim_free(text);\n\t}\n    }\n    else\n#endif\n\tml_append_buf(term->tl_buffer, lnum, text, len + 1, FALSE);\n    if (empty)\n    {\n\t/* Delete the empty line that was in the empty buffer. */\n\tcurbuf = buf;\n\tml_delete(1, FALSE);\n\tcurbuf = curwin->w_buffer;\n    }\n}\n\n    static void\ncell2cellattr(const VTermScreenCell *cell, cellattr_T *attr)\n{\n    attr->width = cell->width;\n    attr->attrs = cell->attrs;\n    attr->fg = cell->fg;\n    attr->bg = cell->bg;\n}\n\n    static int\nequal_celattr(cellattr_T *a, cellattr_T *b)\n{\n    /* Comparing the colors should be sufficient. */\n    return a->fg.red == b->fg.red\n\t&& a->fg.green == b->fg.green\n\t&& a->fg.blue == b->fg.blue\n\t&& a->bg.red == b->bg.red\n\t&& a->bg.green == b->bg.green\n\t&& a->bg.blue == b->bg.blue;\n}\n\n/*\n * Add an empty scrollback line to \"term\".  When \"lnum\" is not zero, add the\n * line at this position.  Otherwise at the end.\n */\n    static int\nadd_empty_scrollback(term_T *term, cellattr_T *fill_attr, int lnum)\n{\n    if (ga_grow(&term->tl_scrollback, 1) == OK)\n    {\n\tsb_line_T *line = (sb_line_T *)term->tl_scrollback.ga_data\n\t\t\t\t      + term->tl_scrollback.ga_len;\n\n\tif (lnum > 0)\n\t{\n\t    int i;\n\n\t    for (i = 0; i < term->tl_scrollback.ga_len - lnum; ++i)\n\t    {\n\t\t*line = *(line - 1);\n\t\t--line;\n\t    }\n\t}\n\tline->sb_cols = 0;\n\tline->sb_cells = NULL;\n\tline->sb_fill_attr = *fill_attr;\n\t++term->tl_scrollback.ga_len;\n\treturn OK;\n    }\n    return FALSE;\n}\n\n/*\n * Remove the terminal contents from the scrollback and the buffer.\n * Used before adding a new scrollback line or updating the buffer for lines\n * displayed in the terminal.\n */\n    static void\ncleanup_scrollback(term_T *term)\n{\n    sb_line_T\t*line;\n    garray_T\t*gap;\n\n    curbuf = term->tl_buffer;\n    gap = &term->tl_scrollback;\n    while (curbuf->b_ml.ml_line_count > term->tl_scrollback_scrolled\n\t\t\t\t\t\t\t    && gap->ga_len > 0)\n    {\n\tml_delete(curbuf->b_ml.ml_line_count, FALSE);\n\tline = (sb_line_T *)gap->ga_data + gap->ga_len - 1;\n\tvim_free(line->sb_cells);\n\t--gap->ga_len;\n    }\n    curbuf = curwin->w_buffer;\n    if (curbuf == term->tl_buffer)\n\tcheck_cursor();\n}\n\n/*\n * Add the current lines of the terminal to scrollback and to the buffer.\n */\n    static void\nupdate_snapshot(term_T *term)\n{\n    VTermScreen\t    *screen;\n    int\t\t    len;\n    int\t\t    lines_skipped = 0;\n    VTermPos\t    pos;\n    VTermScreenCell cell;\n    cellattr_T\t    fill_attr, new_fill_attr;\n    cellattr_T\t    *p;\n\n    ch_log(term->tl_job == NULL ? NULL : term->tl_job->jv_channel,\n\t\t\t\t  \"Adding terminal window snapshot to buffer\");\n\n    /* First remove the lines that were appended before, they might be\n     * outdated. */\n    cleanup_scrollback(term);\n\n    screen = vterm_obtain_screen(term->tl_vterm);\n    fill_attr = new_fill_attr = term->tl_default_color;\n    for (pos.row = 0; pos.row < term->tl_rows; ++pos.row)\n    {\n\tlen = 0;\n\tfor (pos.col = 0; pos.col < term->tl_cols; ++pos.col)\n\t    if (vterm_screen_get_cell(screen, pos, &cell) != 0\n\t\t\t\t\t\t       && cell.chars[0] != NUL)\n\t    {\n\t\tlen = pos.col + 1;\n\t\tnew_fill_attr = term->tl_default_color;\n\t    }\n\t    else\n\t\t/* Assume the last attr is the filler attr. */\n\t\tcell2cellattr(&cell, &new_fill_attr);\n\n\tif (len == 0 && equal_celattr(&new_fill_attr, &fill_attr))\n\t    ++lines_skipped;\n\telse\n\t{\n\t    while (lines_skipped > 0)\n\t    {\n\t\t/* Line was skipped, add an empty line. */\n\t\t--lines_skipped;\n\t\tif (add_empty_scrollback(term, &fill_attr, 0) == OK)\n\t\t    add_scrollback_line_to_buffer(term, (char_u *)\"\", 0);\n\t    }\n\n\t    if (len == 0)\n\t\tp = NULL;\n\t    else\n\t\tp = (cellattr_T *)alloc((int)sizeof(cellattr_T) * len);\n\t    if ((p != NULL || len == 0)\n\t\t\t\t     && ga_grow(&term->tl_scrollback, 1) == OK)\n\t    {\n\t\tgarray_T    ga;\n\t\tint\t    width;\n\t\tsb_line_T   *line = (sb_line_T *)term->tl_scrollback.ga_data\n\t\t\t\t\t\t  + term->tl_scrollback.ga_len;\n\n\t\tga_init2(&ga, 1, 100);\n\t\tfor (pos.col = 0; pos.col < len; pos.col += width)\n\t\t{\n\t\t    if (vterm_screen_get_cell(screen, pos, &cell) == 0)\n\t\t    {\n\t\t\twidth = 1;\n\t\t\tvim_memset(p + pos.col, 0, sizeof(cellattr_T));\n\t\t\tif (ga_grow(&ga, 1) == OK)\n\t\t\t    ga.ga_len += utf_char2bytes(' ',\n\t\t\t\t\t     (char_u *)ga.ga_data + ga.ga_len);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\twidth = cell.width;\n\n\t\t\tcell2cellattr(&cell, &p[pos.col]);\n\n\t\t\t// Each character can be up to 6 bytes.\n\t\t\tif (ga_grow(&ga, VTERM_MAX_CHARS_PER_CELL * 6) == OK)\n\t\t\t{\n\t\t\t    int\t    i;\n\t\t\t    int\t    c;\n\n\t\t\t    for (i = 0; (c = cell.chars[i]) > 0 || i == 0; ++i)\n\t\t\t\tga.ga_len += utf_char2bytes(c == NUL ? ' ' : c,\n\t\t\t\t\t     (char_u *)ga.ga_data + ga.ga_len);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tline->sb_cols = len;\n\t\tline->sb_cells = p;\n\t\tline->sb_fill_attr = new_fill_attr;\n\t\tfill_attr = new_fill_attr;\n\t\t++term->tl_scrollback.ga_len;\n\n\t\tif (ga_grow(&ga, 1) == FAIL)\n\t\t    add_scrollback_line_to_buffer(term, (char_u *)\"\", 0);\n\t\telse\n\t\t{\n\t\t    *((char_u *)ga.ga_data + ga.ga_len) = NUL;\n\t\t    add_scrollback_line_to_buffer(term, ga.ga_data, ga.ga_len);\n\t\t}\n\t\tga_clear(&ga);\n\t    }\n\t    else\n\t\tvim_free(p);\n\t}\n    }\n\n    // Add trailing empty lines.\n    for (pos.row = term->tl_scrollback.ga_len;\n\t    pos.row < term->tl_scrollback_scrolled + term->tl_cursor_pos.row;\n\t    ++pos.row)\n    {\n\tif (add_empty_scrollback(term, &fill_attr, 0) == OK)\n\t    add_scrollback_line_to_buffer(term, (char_u *)\"\", 0);\n    }\n\n    term->tl_dirty_snapshot = FALSE;\n#ifdef FEAT_TIMERS\n    term->tl_timer_set = FALSE;\n#endif\n}\n\n/*\n * If needed, add the current lines of the terminal to scrollback and to the\n * buffer.  Called after the job has ended and when switching to\n * Terminal-Normal mode.\n * When \"redraw\" is TRUE redraw the windows that show the terminal.\n */\n    static void\nmay_move_terminal_to_buffer(term_T *term, int redraw)\n{\n    win_T\t    *wp;\n\n    if (term->tl_vterm == NULL)\n\treturn;\n\n    /* Update the snapshot only if something changes or the buffer does not\n     * have all the lines. */\n    if (term->tl_dirty_snapshot || term->tl_buffer->b_ml.ml_line_count\n\t\t\t\t\t       <= term->tl_scrollback_scrolled)\n\tupdate_snapshot(term);\n\n    /* Obtain the current background color. */\n    vterm_state_get_default_colors(vterm_obtain_state(term->tl_vterm),\n\t\t       &term->tl_default_color.fg, &term->tl_default_color.bg);\n\n    if (redraw)\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_buffer == term->tl_buffer)\n\t    {\n\t\twp->w_cursor.lnum = term->tl_buffer->b_ml.ml_line_count;\n\t\twp->w_cursor.col = 0;\n\t\twp->w_valid = 0;\n\t\tif (wp->w_cursor.lnum >= wp->w_height)\n\t\t{\n\t\t    linenr_T min_topline = wp->w_cursor.lnum - wp->w_height + 1;\n\n\t\t    if (wp->w_topline < min_topline)\n\t\t\twp->w_topline = min_topline;\n\t\t}\n\t\tredraw_win_later(wp, NOT_VALID);\n\t    }\n\t}\n}\n\n#if defined(FEAT_TIMERS) || defined(PROTO)\n/*\n * Check if any terminal timer expired.  If so, copy text from the terminal to\n * the buffer.\n * Return the time until the next timer will expire.\n */\n    int\nterm_check_timers(int next_due_arg, proftime_T *now)\n{\n    term_T  *term;\n    int\t    next_due = next_due_arg;\n\n    for (term = first_term; term != NULL; term = term->tl_next)\n    {\n\tif (term->tl_timer_set && !term->tl_normal_mode)\n\t{\n\t    long    this_due = proftime_time_left(&term->tl_timer_due, now);\n\n\t    if (this_due <= 1)\n\t    {\n\t\tterm->tl_timer_set = FALSE;\n\t\tmay_move_terminal_to_buffer(term, FALSE);\n\t    }\n\t    else if (next_due == -1 || next_due > this_due)\n\t\tnext_due = this_due;\n\t}\n    }\n\n    return next_due;\n}\n#endif\n\n    static void\nset_terminal_mode(term_T *term, int normal_mode)\n{\n    term->tl_normal_mode = normal_mode;\n    VIM_CLEAR(term->tl_status_text);\n    if (term->tl_buffer == curbuf)\n\tmaketitle();\n}\n\n/*\n * Called after the job if finished and Terminal mode is not active:\n * Move the vterm contents into the scrollback buffer and free the vterm.\n */\n    static void\ncleanup_vterm(term_T *term)\n{\n    if (term->tl_finish != TL_FINISH_CLOSE)\n\tmay_move_terminal_to_buffer(term, TRUE);\n    term_free_vterm(term);\n    set_terminal_mode(term, FALSE);\n}\n\n/*\n * Switch from Terminal-Job mode to Terminal-Normal mode.\n * Suspends updating the terminal window.\n */\n    static void\nterm_enter_normal_mode(void)\n{\n    term_T *term = curbuf->b_term;\n\n    set_terminal_mode(term, TRUE);\n\n    /* Append the current terminal contents to the buffer. */\n    may_move_terminal_to_buffer(term, TRUE);\n\n    /* Move the window cursor to the position of the cursor in the\n     * terminal. */\n    curwin->w_cursor.lnum = term->tl_scrollback_scrolled\n\t\t\t\t\t     + term->tl_cursor_pos.row + 1;\n    check_cursor();\n    if (coladvance(term->tl_cursor_pos.col) == FAIL)\n\tcoladvance(MAXCOL);\n\n    /* Display the same lines as in the terminal. */\n    curwin->w_topline = term->tl_scrollback_scrolled + 1;\n}\n\n/*\n * Returns TRUE if the current window contains a terminal and we are in\n * Terminal-Normal mode.\n */\n    int\nterm_in_normal_mode(void)\n{\n    term_T *term = curbuf->b_term;\n\n    return term != NULL && term->tl_normal_mode;\n}\n\n/*\n * Switch from Terminal-Normal mode to Terminal-Job mode.\n * Restores updating the terminal window.\n */\n    void\nterm_enter_job_mode()\n{\n    term_T\t*term = curbuf->b_term;\n\n    set_terminal_mode(term, FALSE);\n\n    if (term->tl_channel_closed)\n\tcleanup_vterm(term);\n    redraw_buf_and_status_later(curbuf, NOT_VALID);\n}\n\n/*\n * Get a key from the user with terminal mode mappings.\n * Note: while waiting a terminal may be closed and freed if the channel is\n * closed and ++close was used.\n */\n    static int\nterm_vgetc()\n{\n    int c;\n    int save_State = State;\n\n    State = TERMINAL;\n    got_int = FALSE;\n#ifdef WIN3264\n    ctrl_break_was_pressed = FALSE;\n#endif\n    c = vgetc();\n    got_int = FALSE;\n    State = save_State;\n    return c;\n}\n\nstatic int\tmouse_was_outside = FALSE;\n\n/*\n * Send keys to terminal.\n * Return FAIL when the key needs to be handled in Normal mode.\n * Return OK when the key was dropped or sent to the terminal.\n */\n    int\nsend_keys_to_term(term_T *term, int c, int typed)\n{\n    char\tmsg[KEY_BUF_LEN];\n    size_t\tlen;\n    int\t\tdragging_outside = FALSE;\n\n    /* Catch keys that need to be handled as in Normal mode. */\n    switch (c)\n    {\n\tcase NUL:\n\tcase K_ZERO:\n\t    if (typed)\n\t\tstuffcharReadbuff(c);\n\t    return FAIL;\n\n\tcase K_TABLINE:\n\t    stuffcharReadbuff(c);\n\t    return FAIL;\n\n\tcase K_IGNORE:\n\tcase K_CANCEL:  // used for :normal when running out of chars\n\t    return FAIL;\n\n\tcase K_LEFTDRAG:\n\tcase K_MIDDLEDRAG:\n\tcase K_RIGHTDRAG:\n\tcase K_X1DRAG:\n\tcase K_X2DRAG:\n\t    dragging_outside = mouse_was_outside;\n\t    /* FALLTHROUGH */\n\tcase K_LEFTMOUSE:\n\tcase K_LEFTMOUSE_NM:\n\tcase K_LEFTRELEASE:\n\tcase K_LEFTRELEASE_NM:\n\tcase K_MOUSEMOVE:\n\tcase K_MIDDLEMOUSE:\n\tcase K_MIDDLERELEASE:\n\tcase K_RIGHTMOUSE:\n\tcase K_RIGHTRELEASE:\n\tcase K_X1MOUSE:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2RELEASE:\n\n\tcase K_MOUSEUP:\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\t    if (mouse_row < W_WINROW(curwin)\n\t\t    || mouse_row >= (W_WINROW(curwin) + curwin->w_height)\n\t\t    || mouse_col < curwin->w_wincol\n\t\t    || mouse_col >= W_ENDCOL(curwin)\n\t\t    || dragging_outside)\n\t    {\n\t\t/* click or scroll outside the current window or on status line\n\t\t * or vertical separator */\n\t\tif (typed)\n\t\t{\n\t\t    stuffcharReadbuff(c);\n\t\t    mouse_was_outside = TRUE;\n\t\t}\n\t\treturn FAIL;\n\t    }\n    }\n    if (typed)\n\tmouse_was_outside = FALSE;\n\n    /* Convert the typed key to a sequence of bytes for the job. */\n    len = term_convert_key(term, c, msg);\n    if (len > 0)\n\t/* TODO: if FAIL is returned, stop? */\n\tchannel_send(term->tl_job->jv_channel, get_tty_part(term),\n\t\t\t\t\t\t(char_u *)msg, (int)len, NULL);\n\n    return OK;\n}\n\n    static void\nposition_cursor(win_T *wp, VTermPos *pos)\n{\n    wp->w_wrow = MIN(pos->row, MAX(0, wp->w_height - 1));\n    wp->w_wcol = MIN(pos->col, MAX(0, wp->w_width - 1));\n    wp->w_valid |= (VALID_WCOL|VALID_WROW);\n}\n\n/*\n * Handle CTRL-W \"\": send register contents to the job.\n */\n    static void\nterm_paste_register(int prev_c UNUSED)\n{\n    int\t\tc;\n    list_T\t*l;\n    listitem_T\t*item;\n    long\treglen = 0;\n    int\t\ttype;\n\n#ifdef FEAT_CMDL_INFO\n    if (add_to_showcmd(prev_c))\n    if (add_to_showcmd('\"'))\n\tout_flush();\n#endif\n    c = term_vgetc();\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n    if (!term_use_loop())\n\t/* job finished while waiting for a character */\n\treturn;\n\n    /* CTRL-W \"= prompt for expression to evaluate. */\n    if (c == '=' && get_expr_register() != '=')\n\treturn;\n    if (!term_use_loop())\n\t/* job finished while waiting for a character */\n\treturn;\n\n    l = (list_T *)get_reg_contents(c, GREG_LIST);\n    if (l != NULL)\n    {\n\ttype = get_reg_type(c, &reglen);\n\tfor (item = l->lv_first; item != NULL; item = item->li_next)\n\t{\n\t    char_u *s = tv_get_string(&item->li_tv);\n#ifdef WIN3264\n\t    char_u *tmp = s;\n\n\t    if (!enc_utf8 && enc_codepage > 0)\n\t    {\n\t\tWCHAR   *ret = NULL;\n\t\tint\tlength = 0;\n\n\t\tMultiByteToWideChar_alloc(enc_codepage, 0, (char *)s,\n\t\t\t\t\t\t(int)STRLEN(s), &ret, &length);\n\t\tif (ret != NULL)\n\t\t{\n\t\t    WideCharToMultiByte_alloc(CP_UTF8, 0,\n\t\t\t\t    ret, length, (char **)&s, &length, 0, 0);\n\t\t    vim_free(ret);\n\t\t}\n\t    }\n#endif\n\t    channel_send(curbuf->b_term->tl_job->jv_channel, PART_IN,\n\t\t\t\t\t\t      s, (int)STRLEN(s), NULL);\n#ifdef WIN3264\n\t    if (tmp != s)\n\t\tvim_free(s);\n#endif\n\n\t    if (item->li_next != NULL || type == MLINE)\n\t\tchannel_send(curbuf->b_term->tl_job->jv_channel, PART_IN,\n\t\t\t\t\t\t      (char_u *)\"\\r\", 1, NULL);\n\t}\n\tlist_free(l);\n    }\n}\n\n/*\n * Return TRUE when waiting for a character in the terminal, the cursor of the\n * terminal should be displayed.\n */\n    int\nterminal_is_active()\n{\n    return in_terminal_loop != NULL;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n    cursorentry_T *\nterm_get_cursor_shape(guicolor_T *fg, guicolor_T *bg)\n{\n    term_T\t\t *term = in_terminal_loop;\n    static cursorentry_T entry;\n    int\t\t\t id;\n    guicolor_T\t\tterm_fg, term_bg;\n\n    vim_memset(&entry, 0, sizeof(entry));\n    entry.shape = entry.mshape =\n\tterm->tl_cursor_shape == VTERM_PROP_CURSORSHAPE_UNDERLINE ? SHAPE_HOR :\n\tterm->tl_cursor_shape == VTERM_PROP_CURSORSHAPE_BAR_LEFT ? SHAPE_VER :\n\tSHAPE_BLOCK;\n    entry.percentage = 20;\n    if (term->tl_cursor_blink)\n    {\n\tentry.blinkwait = 700;\n\tentry.blinkon = 400;\n\tentry.blinkoff = 250;\n    }\n\n    /* The \"Terminal\" highlight group overrules the defaults. */\n    id = syn_name2id((char_u *)\"Terminal\");\n    if (id != 0)\n    {\n\tsyn_id2colors(id, &term_fg, &term_bg);\n\t*fg = term_bg;\n    }\n    else\n\t*fg = gui.back_pixel;\n\n    if (term->tl_cursor_color == NULL)\n    {\n\tif (id != 0)\n\t    *bg = term_fg;\n\telse\n\t    *bg = gui.norm_pixel;\n    }\n    else\n\t*bg = color_name2handle(term->tl_cursor_color);\n    entry.name = \"n\";\n    entry.used_for = SHAPE_CURSOR;\n\n    return &entry;\n}\n#endif\n\n    static void\nmay_output_cursor_props(void)\n{\n    if (!cursor_color_equal(last_set_cursor_color, desired_cursor_color)\n\t    || last_set_cursor_shape != desired_cursor_shape\n\t    || last_set_cursor_blink != desired_cursor_blink)\n    {\n\tcursor_color_copy(&last_set_cursor_color, desired_cursor_color);\n\tlast_set_cursor_shape = desired_cursor_shape;\n\tlast_set_cursor_blink = desired_cursor_blink;\n\tterm_cursor_color(cursor_color_get(desired_cursor_color));\n\tif (desired_cursor_shape == -1 || desired_cursor_blink == -1)\n\t    /* this will restore the initial cursor style, if possible */\n\t    ui_cursor_shape_forced(TRUE);\n\telse\n\t    term_cursor_shape(desired_cursor_shape, desired_cursor_blink);\n    }\n}\n\n/*\n * Set the cursor color and shape, if not last set to these.\n */\n    static void\nmay_set_cursor_props(term_T *term)\n{\n#ifdef FEAT_GUI\n    /* For the GUI the cursor properties are obtained with\n     * term_get_cursor_shape(). */\n    if (gui.in_use)\n\treturn;\n#endif\n    if (in_terminal_loop == term)\n    {\n\tcursor_color_copy(&desired_cursor_color, term->tl_cursor_color);\n\tdesired_cursor_shape = term->tl_cursor_shape;\n\tdesired_cursor_blink = term->tl_cursor_blink;\n\tmay_output_cursor_props();\n    }\n}\n\n/*\n * Reset the desired cursor properties and restore them when needed.\n */\n    static void\nprepare_restore_cursor_props(void)\n{\n#ifdef FEAT_GUI\n    if (gui.in_use)\n\treturn;\n#endif\n    cursor_color_copy(&desired_cursor_color, NULL);\n    desired_cursor_shape = -1;\n    desired_cursor_blink = -1;\n    may_output_cursor_props();\n}\n\n/*\n * Returns TRUE if the current window contains a terminal and we are sending\n * keys to the job.\n * If \"check_job_status\" is TRUE update the job status.\n */\n    static int\nterm_use_loop_check(int check_job_status)\n{\n    term_T *term = curbuf->b_term;\n\n    return term != NULL\n\t&& !term->tl_normal_mode\n\t&& term->tl_vterm != NULL\n\t&& term_job_running_check(term, check_job_status);\n}\n\n/*\n * Returns TRUE if the current window contains a terminal and we are sending\n * keys to the job.\n */\n    int\nterm_use_loop(void)\n{\n    return term_use_loop_check(FALSE);\n}\n\n/*\n * Called when entering a window with the mouse.  If this is a terminal window\n * we may want to change state.\n */\n    void\nterm_win_entered()\n{\n    term_T *term = curbuf->b_term;\n\n    if (term != NULL)\n    {\n\tif (term_use_loop_check(TRUE))\n\t{\n\t    reset_VIsual_and_resel();\n\t    if (State & INSERT)\n\t\tstop_insert_mode = TRUE;\n\t}\n\tmouse_was_outside = FALSE;\n\tenter_mouse_col = mouse_col;\n\tenter_mouse_row = mouse_row;\n    }\n}\n\n/*\n * Wait for input and send it to the job.\n * When \"blocking\" is TRUE wait for a character to be typed.  Otherwise return\n * when there is no more typahead.\n * Return when the start of a CTRL-W command is typed or anything else that\n * should be handled as a Normal mode command.\n * Returns OK if a typed character is to be handled in Normal mode, FAIL if\n * the terminal was closed.\n */\n    int\nterminal_loop(int blocking)\n{\n    int\t\tc;\n    int\t\ttermwinkey = 0;\n    int\t\tret;\n#ifdef UNIX\n    int\t\ttty_fd = curbuf->b_term->tl_job->jv_channel\n\t\t\t\t ->ch_part[get_tty_part(curbuf->b_term)].ch_fd;\n#endif\n    int\t\trestore_cursor = FALSE;\n\n    /* Remember the terminal we are sending keys to.  However, the terminal\n     * might be closed while waiting for a character, e.g. typing \"exit\" in a\n     * shell and ++close was used.  Therefore use curbuf->b_term instead of a\n     * stored reference. */\n    in_terminal_loop = curbuf->b_term;\n\n    if (*curwin->w_p_twk != NUL)\n    {\n\ttermwinkey = string_to_key(curwin->w_p_twk, TRUE);\n\tif (termwinkey == Ctrl_W)\n\t    termwinkey = 0;\n    }\n    position_cursor(curwin, &curbuf->b_term->tl_cursor_pos);\n    may_set_cursor_props(curbuf->b_term);\n\n    while (blocking || vpeekc_nomap() != NUL)\n    {\n#ifdef FEAT_GUI\n\tif (!curbuf->b_term->tl_system)\n#endif\n\t    /* TODO: skip screen update when handling a sequence of keys. */\n\t    /* Repeat redrawing in case a message is received while redrawing.\n\t     */\n\t    while (must_redraw != 0)\n\t\tif (update_screen(0) == FAIL)\n\t\t    break;\n\tif (!term_use_loop_check(TRUE) || in_terminal_loop != curbuf->b_term)\n\t    /* job finished while redrawing */\n\t    break;\n\n\tupdate_cursor(curbuf->b_term, FALSE);\n\trestore_cursor = TRUE;\n\n\tc = term_vgetc();\n\tif (!term_use_loop_check(TRUE) || in_terminal_loop != curbuf->b_term)\n\t{\n\t    /* Job finished while waiting for a character.  Push back the\n\t     * received character. */\n\t    if (c != K_IGNORE)\n\t\tvungetc(c);\n\t    break;\n\t}\n\tif (c == K_IGNORE)\n\t    continue;\n\n#ifdef UNIX\n\t/*\n\t * The shell or another program may change the tty settings.  Getting\n\t * them for every typed character is a bit of overhead, but it's needed\n\t * for the first character typed, e.g. when Vim starts in a shell.\n\t */\n\tif (isatty(tty_fd))\n\t{\n\t    ttyinfo_T info;\n\n\t    /* Get the current backspace character of the pty. */\n\t    if (get_tty_info(tty_fd, &info) == OK)\n\t\tterm_backspace_char = info.backspace;\n\t}\n#endif\n\n#ifdef WIN3264\n\t/* On Windows winpty handles CTRL-C, don't send a CTRL_C_EVENT.\n\t * Use CTRL-BREAK to kill the job. */\n\tif (ctrl_break_was_pressed)\n\t    mch_signal_job(curbuf->b_term->tl_job, (char_u *)\"kill\");\n#endif\n\t/* Was either CTRL-W (termwinkey) or CTRL-\\ pressed?\n\t * Not in a system terminal. */\n\tif ((c == (termwinkey == 0 ? Ctrl_W : termwinkey) || c == Ctrl_BSL)\n#ifdef FEAT_GUI\n\t\t&& !curbuf->b_term->tl_system\n#endif\n\t\t)\n\t{\n\t    int\t    prev_c = c;\n\n#ifdef FEAT_CMDL_INFO\n\t    if (add_to_showcmd(c))\n\t\tout_flush();\n#endif\n\t    c = term_vgetc();\n#ifdef FEAT_CMDL_INFO\n\t    clear_showcmd();\n#endif\n\t    if (!term_use_loop_check(TRUE)\n\t\t\t\t\t || in_terminal_loop != curbuf->b_term)\n\t\t/* job finished while waiting for a character */\n\t\tbreak;\n\n\t    if (prev_c == Ctrl_BSL)\n\t    {\n\t\tif (c == Ctrl_N)\n\t\t{\n\t\t    /* CTRL-\\ CTRL-N : go to Terminal-Normal mode. */\n\t\t    term_enter_normal_mode();\n\t\t    ret = FAIL;\n\t\t    goto theend;\n\t\t}\n\t\t/* Send both keys to the terminal. */\n\t\tsend_keys_to_term(curbuf->b_term, prev_c, TRUE);\n\t    }\n\t    else if (c == Ctrl_C)\n\t    {\n\t\t/* \"CTRL-W CTRL-C\" or 'termwinkey' CTRL-C: end the job */\n\t\tmch_signal_job(curbuf->b_term->tl_job, (char_u *)\"kill\");\n\t    }\n\t    else if (c == '.')\n\t    {\n\t\t/* \"CTRL-W .\": send CTRL-W to the job */\n\t\t/* \"'termwinkey' .\": send 'termwinkey' to the job */\n\t\tc = termwinkey == 0 ? Ctrl_W : termwinkey;\n\t    }\n\t    else if (c == Ctrl_BSL)\n\t    {\n\t\t/* \"CTRL-W CTRL-\\\": send CTRL-\\ to the job */\n\t\tc = Ctrl_BSL;\n\t    }\n\t    else if (c == 'N')\n\t    {\n\t\t/* CTRL-W N : go to Terminal-Normal mode. */\n\t\tterm_enter_normal_mode();\n\t\tret = FAIL;\n\t\tgoto theend;\n\t    }\n\t    else if (c == '\"')\n\t    {\n\t\tterm_paste_register(prev_c);\n\t\tcontinue;\n\t    }\n\t    else if (termwinkey == 0 || c != termwinkey)\n\t    {\n\t\tstuffcharReadbuff(Ctrl_W);\n\t\tstuffcharReadbuff(c);\n\t\tret = OK;\n\t\tgoto theend;\n\t    }\n\t}\n# ifdef WIN3264\n\tif (!enc_utf8 && has_mbyte && c >= 0x80)\n\t{\n\t    WCHAR   wc;\n\t    char_u  mb[3];\n\n\t    mb[0] = (unsigned)c >> 8;\n\t    mb[1] = c;\n\t    if (MultiByteToWideChar(GetACP(), 0, (char*)mb, 2, &wc, 1) > 0)\n\t\tc = wc;\n\t}\n# endif\n\tif (send_keys_to_term(curbuf->b_term, c, TRUE) != OK)\n\t{\n\t    if (c == K_MOUSEMOVE)\n\t\t/* We are sure to come back here, don't reset the cursor color\n\t\t * and shape to avoid flickering. */\n\t\trestore_cursor = FALSE;\n\n\t    ret = OK;\n\t    goto theend;\n\t}\n    }\n    ret = FAIL;\n\ntheend:\n    in_terminal_loop = NULL;\n    if (restore_cursor)\n\tprepare_restore_cursor_props();\n\n    /* Move a snapshot of the screen contents to the buffer, so that completion\n     * works in other buffers. */\n    if (curbuf->b_term != NULL && !curbuf->b_term->tl_normal_mode)\n\tmay_move_terminal_to_buffer(curbuf->b_term, FALSE);\n\n    return ret;\n}\n\n/*\n * Called when a job has finished.\n * This updates the title and status, but does not close the vterm, because\n * there might still be pending output in the channel.\n */\n    void\nterm_job_ended(job_T *job)\n{\n    term_T *term;\n    int\t    did_one = FALSE;\n\n    for (term = first_term; term != NULL; term = term->tl_next)\n\tif (term->tl_job == job)\n\t{\n\t    VIM_CLEAR(term->tl_title);\n\t    VIM_CLEAR(term->tl_status_text);\n\t    redraw_buf_and_status_later(term->tl_buffer, VALID);\n\t    did_one = TRUE;\n\t}\n    if (did_one)\n\tredraw_statuslines();\n    if (curbuf->b_term != NULL)\n    {\n\tif (curbuf->b_term->tl_job == job)\n\t    maketitle();\n\tupdate_cursor(curbuf->b_term, TRUE);\n    }\n}\n\n    static void\nmay_toggle_cursor(term_T *term)\n{\n    if (in_terminal_loop == term)\n    {\n\tif (term->tl_cursor_visible)\n\t    cursor_on();\n\telse\n\t    cursor_off();\n    }\n}\n\n/*\n * Reverse engineer the RGB value into a cterm color index.\n * First color is 1.  Return 0 if no match found (default color).\n */\n    static int\ncolor2index(VTermColor *color, int fg, int *boldp)\n{\n    int red = color->red;\n    int blue = color->blue;\n    int green = color->green;\n\n    if (color->ansi_index != VTERM_ANSI_INDEX_NONE)\n    {\n\t/* First 16 colors and default: use the ANSI index, because these\n\t * colors can be redefined. */\n\tif (t_colors >= 16)\n\t    return color->ansi_index;\n\tswitch (color->ansi_index)\n\t{\n\t    case  0: return 0;\n\t    case  1: return lookup_color( 0, fg, boldp) + 1; /* black */\n\t    case  2: return lookup_color( 4, fg, boldp) + 1; /* dark red */\n\t    case  3: return lookup_color( 2, fg, boldp) + 1; /* dark green */\n\t    case  4: return lookup_color( 6, fg, boldp) + 1; /* brown */\n\t    case  5: return lookup_color( 1, fg, boldp) + 1; /* dark blue */\n\t    case  6: return lookup_color( 5, fg, boldp) + 1; /* dark magenta */\n\t    case  7: return lookup_color( 3, fg, boldp) + 1; /* dark cyan */\n\t    case  8: return lookup_color( 8, fg, boldp) + 1; /* light grey */\n\t    case  9: return lookup_color(12, fg, boldp) + 1; /* dark grey */\n\t    case 10: return lookup_color(20, fg, boldp) + 1; /* red */\n\t    case 11: return lookup_color(16, fg, boldp) + 1; /* green */\n\t    case 12: return lookup_color(24, fg, boldp) + 1; /* yellow */\n\t    case 13: return lookup_color(14, fg, boldp) + 1; /* blue */\n\t    case 14: return lookup_color(22, fg, boldp) + 1; /* magenta */\n\t    case 15: return lookup_color(18, fg, boldp) + 1; /* cyan */\n\t    case 16: return lookup_color(26, fg, boldp) + 1; /* white */\n\t}\n    }\n\n    if (t_colors >= 256)\n    {\n\tif (red == blue && red == green)\n\t{\n\t    /* 24-color greyscale plus white and black */\n\t    static int cutoff[23] = {\n\t\t    0x0D, 0x17, 0x21, 0x2B, 0x35, 0x3F, 0x49, 0x53, 0x5D, 0x67,\n\t\t    0x71, 0x7B, 0x85, 0x8F, 0x99, 0xA3, 0xAD, 0xB7, 0xC1, 0xCB,\n\t\t    0xD5, 0xDF, 0xE9};\n\t    int i;\n\n\t    if (red < 5)\n\t\treturn 17; /* 00/00/00 */\n\t    if (red > 245) /* ff/ff/ff */\n\t\treturn 232;\n\t    for (i = 0; i < 23; ++i)\n\t\tif (red < cutoff[i])\n\t\t    return i + 233;\n\t    return 256;\n\t}\n\t{\n\t    static int cutoff[5] = {0x2F, 0x73, 0x9B, 0xC3, 0xEB};\n\t    int ri, gi, bi;\n\n\t    /* 216-color cube */\n\t    for (ri = 0; ri < 5; ++ri)\n\t\tif (red < cutoff[ri])\n\t\t    break;\n\t    for (gi = 0; gi < 5; ++gi)\n\t\tif (green < cutoff[gi])\n\t\t    break;\n\t    for (bi = 0; bi < 5; ++bi)\n\t\tif (blue < cutoff[bi])\n\t\t    break;\n\t    return 17 + ri * 36 + gi * 6 + bi;\n\t}\n    }\n    return 0;\n}\n\n/*\n * Convert Vterm attributes to highlight flags.\n */\n    static int\nvtermAttr2hl(VTermScreenCellAttrs cellattrs)\n{\n    int attr = 0;\n\n    if (cellattrs.bold)\n\tattr |= HL_BOLD;\n    if (cellattrs.underline)\n\tattr |= HL_UNDERLINE;\n    if (cellattrs.italic)\n\tattr |= HL_ITALIC;\n    if (cellattrs.strike)\n\tattr |= HL_STRIKETHROUGH;\n    if (cellattrs.reverse)\n\tattr |= HL_INVERSE;\n    return attr;\n}\n\n/*\n * Store Vterm attributes in \"cell\" from highlight flags.\n */\n    static void\nhl2vtermAttr(int attr, cellattr_T *cell)\n{\n    vim_memset(&cell->attrs, 0, sizeof(VTermScreenCellAttrs));\n    if (attr & HL_BOLD)\n\tcell->attrs.bold = 1;\n    if (attr & HL_UNDERLINE)\n\tcell->attrs.underline = 1;\n    if (attr & HL_ITALIC)\n\tcell->attrs.italic = 1;\n    if (attr & HL_STRIKETHROUGH)\n\tcell->attrs.strike = 1;\n    if (attr & HL_INVERSE)\n\tcell->attrs.reverse = 1;\n}\n\n/*\n * Convert the attributes of a vterm cell into an attribute index.\n */\n    static int\ncell2attr(VTermScreenCellAttrs cellattrs, VTermColor cellfg, VTermColor cellbg)\n{\n    int attr = vtermAttr2hl(cellattrs);\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tguicolor_T fg, bg;\n\n\tfg = gui_mch_get_rgb_color(cellfg.red, cellfg.green, cellfg.blue);\n\tbg = gui_mch_get_rgb_color(cellbg.red, cellbg.green, cellbg.blue);\n\treturn get_gui_attr_idx(attr, fg, bg);\n    }\n    else\n#endif\n#ifdef FEAT_TERMGUICOLORS\n    if (p_tgc)\n    {\n\tguicolor_T fg, bg;\n\n\tfg = gui_get_rgb_color_cmn(cellfg.red, cellfg.green, cellfg.blue);\n\tbg = gui_get_rgb_color_cmn(cellbg.red, cellbg.green, cellbg.blue);\n\n\treturn get_tgc_attr_idx(attr, fg, bg);\n    }\n    else\n#endif\n    {\n\tint bold = MAYBE;\n\tint fg = color2index(&cellfg, TRUE, &bold);\n\tint bg = color2index(&cellbg, FALSE, &bold);\n\n\t/* Use the \"Terminal\" highlighting for the default colors. */\n\tif ((fg == 0 || bg == 0) && t_colors >= 16)\n\t{\n\t    if (fg == 0 && term_default_cterm_fg >= 0)\n\t\tfg = term_default_cterm_fg + 1;\n\t    if (bg == 0 && term_default_cterm_bg >= 0)\n\t\tbg = term_default_cterm_bg + 1;\n\t}\n\n\t/* with 8 colors set the bold attribute to get a bright foreground */\n\tif (bold == TRUE)\n\t    attr |= HL_BOLD;\n\treturn get_cterm_attr_idx(attr, fg, bg);\n    }\n    return 0;\n}\n\n    static void\nset_dirty_snapshot(term_T *term)\n{\n    term->tl_dirty_snapshot = TRUE;\n#ifdef FEAT_TIMERS\n    if (!term->tl_normal_mode)\n    {\n\t/* Update the snapshot after 100 msec of not getting updates. */\n\tprofile_setlimit(100L, &term->tl_timer_due);\n\tterm->tl_timer_set = TRUE;\n    }\n#endif\n}\n\n    static int\nhandle_damage(VTermRect rect, void *user)\n{\n    term_T *term = (term_T *)user;\n\n    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, rect.start_row);\n    term->tl_dirty_row_end = MAX(term->tl_dirty_row_end, rect.end_row);\n    set_dirty_snapshot(term);\n    redraw_buf_later(term->tl_buffer, SOME_VALID);\n    return 1;\n}\n\n    static void\nterm_scroll_up(term_T *term, int start_row, int count)\n{\n    win_T\t\t *wp;\n    VTermColor\t\t fg, bg;\n    VTermScreenCellAttrs attr;\n    int\t\t\t clear_attr;\n\n    /* Set the color to clear lines with. */\n    vterm_state_get_default_colors(vterm_obtain_state(term->tl_vterm),\n\t\t\t\t\t\t\t\t     &fg, &bg);\n    vim_memset(&attr, 0, sizeof(attr));\n    clear_attr = cell2attr(attr, fg, bg);\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer == term->tl_buffer)\n\t    win_del_lines(wp, start_row, count, FALSE, FALSE, clear_attr);\n    }\n}\n\n    static int\nhandle_moverect(VTermRect dest, VTermRect src, void *user)\n{\n    term_T\t*term = (term_T *)user;\n    int\t\tcount = src.start_row - dest.start_row;\n\n    /* Scrolling up is done much more efficiently by deleting lines instead of\n     * redrawing the text. But avoid doing this multiple times, postpone until\n     * the redraw happens. */\n    if (dest.start_col == src.start_col\n\t    && dest.end_col == src.end_col\n\t    && dest.start_row < src.start_row)\n    {\n\tif (dest.start_row == 0)\n\t    term->tl_postponed_scroll += count;\n\telse\n\t    term_scroll_up(term, dest.start_row, count);\n    }\n\n    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);\n    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);\n    set_dirty_snapshot(term);\n\n    /* Note sure if the scrolling will work correctly, let's do a complete\n     * redraw later. */\n    redraw_buf_later(term->tl_buffer, NOT_VALID);\n    return 1;\n}\n\n    static int\nhandle_movecursor(\n\tVTermPos pos,\n\tVTermPos oldpos UNUSED,\n\tint visible,\n\tvoid *user)\n{\n    term_T\t*term = (term_T *)user;\n    win_T\t*wp;\n\n    term->tl_cursor_pos = pos;\n    term->tl_cursor_visible = visible;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer == term->tl_buffer)\n\t    position_cursor(wp, &pos);\n    }\n    if (term->tl_buffer == curbuf && !term->tl_normal_mode)\n    {\n\tmay_toggle_cursor(term);\n\tupdate_cursor(term, term->tl_cursor_visible);\n    }\n\n    return 1;\n}\n\n    static int\nhandle_settermprop(\n\tVTermProp prop,\n\tVTermValue *value,\n\tvoid *user)\n{\n    term_T\t*term = (term_T *)user;\n\n    switch (prop)\n    {\n\tcase VTERM_PROP_TITLE:\n\t    vim_free(term->tl_title);\n\t    /* a blank title isn't useful, make it empty, so that \"running\" is\n\t     * displayed */\n\t    if (*skipwhite((char_u *)value->string) == NUL)\n\t\tterm->tl_title = NULL;\n#ifdef WIN3264\n\t    else if (!enc_utf8 && enc_codepage > 0)\n\t    {\n\t\tWCHAR   *ret = NULL;\n\t\tint\tlength = 0;\n\n\t\tMultiByteToWideChar_alloc(CP_UTF8, 0,\n\t\t\t(char*)value->string, (int)STRLEN(value->string),\n\t\t\t\t\t\t\t\t&ret, &length);\n\t\tif (ret != NULL)\n\t\t{\n\t\t    WideCharToMultiByte_alloc(enc_codepage, 0,\n\t\t\t\t\tret, length, (char**)&term->tl_title,\n\t\t\t\t\t&length, 0, 0);\n\t\t    vim_free(ret);\n\t\t}\n\t    }\n#endif\n\t    else\n\t\tterm->tl_title = vim_strsave((char_u *)value->string);\n\t    VIM_CLEAR(term->tl_status_text);\n\t    if (term == curbuf->b_term)\n\t\tmaketitle();\n\t    break;\n\n\tcase VTERM_PROP_CURSORVISIBLE:\n\t    term->tl_cursor_visible = value->boolean;\n\t    may_toggle_cursor(term);\n\t    out_flush();\n\t    break;\n\n\tcase VTERM_PROP_CURSORBLINK:\n\t    term->tl_cursor_blink = value->boolean;\n\t    may_set_cursor_props(term);\n\t    break;\n\n\tcase VTERM_PROP_CURSORSHAPE:\n\t    term->tl_cursor_shape = value->number;\n\t    may_set_cursor_props(term);\n\t    break;\n\n\tcase VTERM_PROP_CURSORCOLOR:\n\t    cursor_color_copy(&term->tl_cursor_color, (char_u*)value->string);\n\t    may_set_cursor_props(term);\n\t    break;\n\n\tcase VTERM_PROP_ALTSCREEN:\n\t    /* TODO: do anything else? */\n\t    term->tl_using_altscreen = value->boolean;\n\t    break;\n\n\tdefault:\n\t    break;\n    }\n    /* Always return 1, otherwise vterm doesn't store the value internally. */\n    return 1;\n}\n\n/*\n * The job running in the terminal resized the terminal.\n */\n    static int\nhandle_resize(int rows, int cols, void *user)\n{\n    term_T\t*term = (term_T *)user;\n    win_T\t*wp;\n\n    term->tl_rows = rows;\n    term->tl_cols = cols;\n    if (term->tl_vterm_size_changed)\n\t/* Size was set by vterm_set_size(), don't set the window size. */\n\tterm->tl_vterm_size_changed = FALSE;\n    else\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_buffer == term->tl_buffer)\n\t    {\n\t\twin_setheight_win(rows, wp);\n\t\twin_setwidth_win(cols, wp);\n\t    }\n\t}\n\tredraw_buf_later(term->tl_buffer, NOT_VALID);\n    }\n    return 1;\n}\n\n/*\n * Handle a line that is pushed off the top of the screen.\n */\n    static int\nhandle_pushline(int cols, const VTermScreenCell *cells, void *user)\n{\n    term_T\t*term = (term_T *)user;\n\n    /* First remove the lines that were appended before, the pushed line goes\n     * above it. */\n    cleanup_scrollback(term);\n\n    /* If the number of lines that are stored goes over 'termscrollback' then\n     * delete the first 10%. */\n    if (term->tl_scrollback.ga_len >= term->tl_buffer->b_p_twsl)\n    {\n\tint\ttodo = term->tl_buffer->b_p_twsl / 10;\n\tint\ti;\n\n\tcurbuf = term->tl_buffer;\n\tfor (i = 0; i < todo; ++i)\n\t{\n\t    vim_free(((sb_line_T *)term->tl_scrollback.ga_data + i)->sb_cells);\n\t    ml_delete(1, FALSE);\n\t}\n\tcurbuf = curwin->w_buffer;\n\n\tterm->tl_scrollback.ga_len -= todo;\n\tmch_memmove(term->tl_scrollback.ga_data,\n\t    (sb_line_T *)term->tl_scrollback.ga_data + todo,\n\t    sizeof(sb_line_T) * term->tl_scrollback.ga_len);\n\tterm->tl_scrollback_scrolled -= todo;\n    }\n\n    if (ga_grow(&term->tl_scrollback, 1) == OK)\n    {\n\tcellattr_T\t*p = NULL;\n\tint\t\tlen = 0;\n\tint\t\ti;\n\tint\t\tc;\n\tint\t\tcol;\n\tsb_line_T\t*line;\n\tgarray_T\tga;\n\tcellattr_T\tfill_attr = term->tl_default_color;\n\n\t/* do not store empty cells at the end */\n\tfor (i = 0; i < cols; ++i)\n\t    if (cells[i].chars[0] != 0)\n\t\tlen = i + 1;\n\t    else\n\t\tcell2cellattr(&cells[i], &fill_attr);\n\n\tga_init2(&ga, 1, 100);\n\tif (len > 0)\n\t    p = (cellattr_T *)alloc((int)sizeof(cellattr_T) * len);\n\tif (p != NULL)\n\t{\n\t    for (col = 0; col < len; col += cells[col].width)\n\t    {\n\t\tif (ga_grow(&ga, MB_MAXBYTES) == FAIL)\n\t\t{\n\t\t    ga.ga_len = 0;\n\t\t    break;\n\t\t}\n\t\tfor (i = 0; (c = cells[col].chars[i]) > 0 || i == 0; ++i)\n\t\t    ga.ga_len += utf_char2bytes(c == NUL ? ' ' : c,\n\t\t\t\t\t     (char_u *)ga.ga_data + ga.ga_len);\n\t\tcell2cellattr(&cells[col], &p[col]);\n\t    }\n\t}\n\tif (ga_grow(&ga, 1) == FAIL)\n\t    add_scrollback_line_to_buffer(term, (char_u *)\"\", 0);\n\telse\n\t{\n\t    *((char_u *)ga.ga_data + ga.ga_len) = NUL;\n\t    add_scrollback_line_to_buffer(term, ga.ga_data, ga.ga_len);\n\t}\n\tga_clear(&ga);\n\n\tline = (sb_line_T *)term->tl_scrollback.ga_data\n\t\t\t\t\t\t  + term->tl_scrollback.ga_len;\n\tline->sb_cols = len;\n\tline->sb_cells = p;\n\tline->sb_fill_attr = fill_attr;\n\t++term->tl_scrollback.ga_len;\n\t++term->tl_scrollback_scrolled;\n    }\n    return 0; /* ignored */\n}\n\nstatic VTermScreenCallbacks screen_callbacks = {\n  handle_damage,\t/* damage */\n  handle_moverect,\t/* moverect */\n  handle_movecursor,\t/* movecursor */\n  handle_settermprop,\t/* settermprop */\n  NULL,\t\t\t/* bell */\n  handle_resize,\t/* resize */\n  handle_pushline,\t/* sb_pushline */\n  NULL\t\t\t/* sb_popline */\n};\n\n/*\n * Do the work after the channel of a terminal was closed.\n * Must be called only when updating_screen is FALSE.\n * Returns TRUE when a buffer was closed (list of terminals may have changed).\n */\n    static int\nterm_after_channel_closed(term_T *term)\n{\n    /* Unless in Terminal-Normal mode: clear the vterm. */\n    if (!term->tl_normal_mode)\n    {\n\tint\tfnum = term->tl_buffer->b_fnum;\n\n\tcleanup_vterm(term);\n\n\tif (term->tl_finish == TL_FINISH_CLOSE)\n\t{\n\t    aco_save_T\taco;\n\t    int\t\tdo_set_w_closing = term->tl_buffer->b_nwindows == 0;\n\n\t    // ++close or term_finish == \"close\"\n\t    ch_log(NULL, \"terminal job finished, closing window\");\n\t    aucmd_prepbuf(&aco, term->tl_buffer);\n\t    // Avoid closing the window if we temporarily use it.\n\t    if (do_set_w_closing)\n\t\tcurwin->w_closing = TRUE;\n\t    do_bufdel(DOBUF_WIPE, (char_u *)\"\", 1, fnum, fnum, FALSE);\n\t    if (do_set_w_closing)\n\t\tcurwin->w_closing = FALSE;\n\t    aucmd_restbuf(&aco);\n\t    return TRUE;\n\t}\n\tif (term->tl_finish == TL_FINISH_OPEN\n\t\t\t\t   && term->tl_buffer->b_nwindows == 0)\n\t{\n\t    char buf[50];\n\n\t    /* TODO: use term_opencmd */\n\t    ch_log(NULL, \"terminal job finished, opening window\");\n\t    vim_snprintf(buf, sizeof(buf),\n\t\t    term->tl_opencmd == NULL\n\t\t\t    ? \"botright sbuf %d\"\n\t\t\t    : (char *)term->tl_opencmd, fnum);\n\t    do_cmdline_cmd((char_u *)buf);\n\t}\n\telse\n\t    ch_log(NULL, \"terminal job finished\");\n    }\n\n    redraw_buf_and_status_later(term->tl_buffer, NOT_VALID);\n    return FALSE;\n}\n\n/*\n * Called when a channel has been closed.\n * If this was a channel for a terminal window then finish it up.\n */\n    void\nterm_channel_closed(channel_T *ch)\n{\n    term_T *term;\n    term_T *next_term;\n    int\t    did_one = FALSE;\n\n    for (term = first_term; term != NULL; term = next_term)\n    {\n\tnext_term = term->tl_next;\n\tif (term->tl_job == ch->ch_job)\n\t{\n\t    term->tl_channel_closed = TRUE;\n\t    did_one = TRUE;\n\n\t    VIM_CLEAR(term->tl_title);\n\t    VIM_CLEAR(term->tl_status_text);\n#ifdef WIN3264\n\t    if (term->tl_out_fd != NULL)\n\t    {\n\t\tfclose(term->tl_out_fd);\n\t\tterm->tl_out_fd = NULL;\n\t    }\n#endif\n\n\t    if (updating_screen)\n\t    {\n\t\t/* Cannot open or close windows now.  Can happen when\n\t\t * 'lazyredraw' is set. */\n\t\tterm->tl_channel_recently_closed = TRUE;\n\t\tcontinue;\n\t    }\n\n\t    if (term_after_channel_closed(term))\n\t\tnext_term = first_term;\n\t}\n    }\n\n    if (did_one)\n    {\n\tredraw_statuslines();\n\n\t/* Need to break out of vgetc(). */\n\tins_char_typebuf(K_IGNORE);\n\ttypebuf_was_filled = TRUE;\n\n\tterm = curbuf->b_term;\n\tif (term != NULL)\n\t{\n\t    if (term->tl_job == ch->ch_job)\n\t\tmaketitle();\n\t    update_cursor(term, term->tl_cursor_visible);\n\t}\n    }\n}\n\n/*\n * To be called after resetting updating_screen: handle any terminal where the\n * channel was closed.\n */\n    void\nterm_check_channel_closed_recently()\n{\n    term_T *term;\n    term_T *next_term;\n\n    for (term = first_term; term != NULL; term = next_term)\n    {\n\tnext_term = term->tl_next;\n\tif (term->tl_channel_recently_closed)\n\t{\n\t    term->tl_channel_recently_closed = FALSE;\n\t    if (term_after_channel_closed(term))\n\t\t// start over, the list may have changed\n\t\tnext_term = first_term;\n\t}\n    }\n}\n\n/*\n * Fill one screen line from a line of the terminal.\n * Advances \"pos\" to past the last column.\n */\n    static void\nterm_line2screenline(VTermScreen *screen, VTermPos *pos, int max_col)\n{\n    int off = screen_get_current_line_off();\n\n    for (pos->col = 0; pos->col < max_col; )\n    {\n\tVTermScreenCell cell;\n\tint\t\tc;\n\n\tif (vterm_screen_get_cell(screen, *pos, &cell) == 0)\n\t    vim_memset(&cell, 0, sizeof(cell));\n\n\tc = cell.chars[0];\n\tif (c == NUL)\n\t{\n\t    ScreenLines[off] = ' ';\n\t    if (enc_utf8)\n\t\tScreenLinesUC[off] = NUL;\n\t}\n\telse\n\t{\n\t    if (enc_utf8)\n\t    {\n\t\tint i;\n\n\t\t/* composing chars */\n\t\tfor (i = 0; i < Screen_mco\n\t\t\t      && i + 1 < VTERM_MAX_CHARS_PER_CELL; ++i)\n\t\t{\n\t\t    ScreenLinesC[i][off] = cell.chars[i + 1];\n\t\t    if (cell.chars[i + 1] == 0)\n\t\t\tbreak;\n\t\t}\n\t\tif (c >= 0x80 || (Screen_mco > 0\n\t\t\t\t\t && ScreenLinesC[0][off] != 0))\n\t\t{\n\t\t    ScreenLines[off] = ' ';\n\t\t    ScreenLinesUC[off] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ScreenLines[off] = c;\n\t\t    ScreenLinesUC[off] = NUL;\n\t\t}\n\t    }\n#ifdef WIN3264\n\t    else if (has_mbyte && c >= 0x80)\n\t    {\n\t\tchar_u\tmb[MB_MAXBYTES+1];\n\t\tWCHAR\twc = c;\n\n\t\tif (WideCharToMultiByte(GetACP(), 0, &wc, 1,\n\t\t\t\t\t       (char*)mb, 2, 0, 0) > 1)\n\t\t{\n\t\t    ScreenLines[off] = mb[0];\n\t\t    ScreenLines[off + 1] = mb[1];\n\t\t    cell.width = mb_ptr2cells(mb);\n\t\t}\n\t\telse\n\t\t    ScreenLines[off] = c;\n\t    }\n#endif\n\t    else\n\t\tScreenLines[off] = c;\n\t}\n\tScreenAttrs[off] = cell2attr(cell.attrs, cell.fg, cell.bg);\n\n\t++pos->col;\n\t++off;\n\tif (cell.width == 2)\n\t{\n\t    if (enc_utf8)\n\t\tScreenLinesUC[off] = NUL;\n\n\t    /* don't set the second byte to NUL for a DBCS encoding, it\n\t     * has been set above */\n\t    if (enc_utf8 || !has_mbyte)\n\t\tScreenLines[off] = NUL;\n\n\t    ++pos->col;\n\t    ++off;\n\t}\n    }\n}\n\n#if defined(FEAT_GUI)\n    static void\nupdate_system_term(term_T *term)\n{\n    VTermPos\t    pos;\n    VTermScreen\t    *screen;\n\n    if (term->tl_vterm == NULL)\n\treturn;\n    screen = vterm_obtain_screen(term->tl_vterm);\n\n    /* Scroll up to make more room for terminal lines if needed. */\n    while (term->tl_toprow > 0\n\t\t\t  && (Rows - term->tl_toprow) < term->tl_dirty_row_end)\n    {\n\tint save_p_more = p_more;\n\n\tp_more = FALSE;\n\tmsg_row = Rows - 1;\n\tmsg_puts((char_u *)\"\\n\");\n\tp_more = save_p_more;\n\t--term->tl_toprow;\n    }\n\n    for (pos.row = term->tl_dirty_row_start; pos.row < term->tl_dirty_row_end\n\t\t\t\t\t\t  && pos.row < Rows; ++pos.row)\n    {\n\tif (pos.row < term->tl_rows)\n\t{\n\t    int max_col = MIN(Columns, term->tl_cols);\n\n\t    term_line2screenline(screen, &pos, max_col);\n\t}\n\telse\n\t    pos.col = 0;\n\n\tscreen_line(term->tl_toprow + pos.row, 0, pos.col, Columns, FALSE);\n    }\n\n    term->tl_dirty_row_start = MAX_ROW;\n    term->tl_dirty_row_end = 0;\n    update_cursor(term, TRUE);\n}\n#endif\n\n/*\n * Return TRUE if window \"wp\" is to be redrawn with term_update_window().\n * Returns FALSE when there is no terminal running in this window or it is in\n * Terminal-Normal mode.\n */\n    int\nterm_do_update_window(win_T *wp)\n{\n    term_T\t*term = wp->w_buffer->b_term;\n\n    return term != NULL && term->tl_vterm != NULL && !term->tl_normal_mode;\n}\n\n/*\n * Called to update a window that contains an active terminal.\n */\n    void\nterm_update_window(win_T *wp)\n{\n    term_T\t*term = wp->w_buffer->b_term;\n    VTerm\t*vterm;\n    VTermScreen *screen;\n    VTermState\t*state;\n    VTermPos\tpos;\n    int\t\trows, cols;\n    int\t\tnewrows, newcols;\n    int\t\tminsize;\n    win_T\t*twp;\n\n    vterm = term->tl_vterm;\n    screen = vterm_obtain_screen(vterm);\n    state = vterm_obtain_state(vterm);\n\n    /* We use NOT_VALID on a resize or scroll, redraw everything then.  With\n     * SOME_VALID only redraw what was marked dirty. */\n    if (wp->w_redr_type > SOME_VALID)\n    {\n\tterm->tl_dirty_row_start = 0;\n\tterm->tl_dirty_row_end = MAX_ROW;\n\n\tif (term->tl_postponed_scroll > 0\n\t\t\t      && term->tl_postponed_scroll < term->tl_rows / 3)\n\t    /* Scrolling is usually faster than redrawing, when there are only\n\t     * a few lines to scroll. */\n\t    term_scroll_up(term, 0, term->tl_postponed_scroll);\n\tterm->tl_postponed_scroll = 0;\n    }\n\n    /*\n     * If the window was resized a redraw will be triggered and we get here.\n     * Adjust the size of the vterm unless 'termwinsize' specifies a fixed size.\n     */\n    minsize = parse_termwinsize(wp, &rows, &cols);\n\n    newrows = 99999;\n    newcols = 99999;\n    FOR_ALL_WINDOWS(twp)\n    {\n\t/* When more than one window shows the same terminal, use the\n\t * smallest size. */\n\tif (twp->w_buffer == term->tl_buffer)\n\t{\n\t    newrows = MIN(newrows, twp->w_height);\n\t    newcols = MIN(newcols, twp->w_width);\n\t}\n    }\n    newrows = rows == 0 ? newrows : minsize ? MAX(rows, newrows) : rows;\n    newcols = cols == 0 ? newcols : minsize ? MAX(cols, newcols) : cols;\n\n    if (term->tl_rows != newrows || term->tl_cols != newcols)\n    {\n\tterm->tl_vterm_size_changed = TRUE;\n\tvterm_set_size(vterm, newrows, newcols);\n\tch_log(term->tl_job->jv_channel, \"Resizing terminal to %d lines\",\n\t\t\t\t\t\t\t\t      newrows);\n\tterm_report_winsize(term, newrows, newcols);\n\n\t// Updating the terminal size will cause the snapshot to be cleared.\n\t// When not in terminal_loop() we need to restore it.\n\tif (term != in_terminal_loop)\n\t    may_move_terminal_to_buffer(term, FALSE);\n    }\n\n    /* The cursor may have been moved when resizing. */\n    vterm_state_get_cursorpos(state, &pos);\n    position_cursor(wp, &pos);\n\n    for (pos.row = term->tl_dirty_row_start; pos.row < term->tl_dirty_row_end\n\t\t\t\t\t  && pos.row < wp->w_height; ++pos.row)\n    {\n\tif (pos.row < term->tl_rows)\n\t{\n\t    int max_col = MIN(wp->w_width, term->tl_cols);\n\n\t    term_line2screenline(screen, &pos, max_col);\n\t}\n\telse\n\t    pos.col = 0;\n\n\tscreen_line(wp->w_winrow + pos.row\n#ifdef FEAT_MENU\n\t\t\t\t+ winbar_height(wp)\n#endif\n\t\t\t\t, wp->w_wincol, pos.col, wp->w_width, FALSE);\n    }\n    term->tl_dirty_row_start = MAX_ROW;\n    term->tl_dirty_row_end = 0;\n}\n\n/*\n * Return TRUE if \"wp\" is a terminal window where the job has finished.\n */\n    int\nterm_is_finished(buf_T *buf)\n{\n    return buf->b_term != NULL && buf->b_term->tl_vterm == NULL;\n}\n\n/*\n * Return TRUE if \"wp\" is a terminal window where the job has finished or we\n * are in Terminal-Normal mode, thus we show the buffer contents.\n */\n    int\nterm_show_buffer(buf_T *buf)\n{\n    term_T *term = buf->b_term;\n\n    return term != NULL && (term->tl_vterm == NULL || term->tl_normal_mode);\n}\n\n/*\n * The current buffer is going to be changed.  If there is terminal\n * highlighting remove it now.\n */\n    void\nterm_change_in_curbuf(void)\n{\n    term_T *term = curbuf->b_term;\n\n    if (term_is_finished(curbuf) && term->tl_scrollback.ga_len > 0)\n    {\n\tfree_scrollback(term);\n\tredraw_buf_later(term->tl_buffer, NOT_VALID);\n\n\t/* The buffer is now like a normal buffer, it cannot be easily\n\t * abandoned when changed. */\n\tset_string_option_direct((char_u *)\"buftype\", -1,\n\t\t\t\t\t  (char_u *)\"\", OPT_FREE|OPT_LOCAL, 0);\n    }\n}\n\n/*\n * Get the screen attribute for a position in the buffer.\n * Use a negative \"col\" to get the filler background color.\n */\n    int\nterm_get_attr(buf_T *buf, linenr_T lnum, int col)\n{\n    term_T\t*term = buf->b_term;\n    sb_line_T\t*line;\n    cellattr_T\t*cellattr;\n\n    if (lnum > term->tl_scrollback.ga_len)\n\tcellattr = &term->tl_default_color;\n    else\n    {\n\tline = (sb_line_T *)term->tl_scrollback.ga_data + lnum - 1;\n\tif (col < 0 || col >= line->sb_cols)\n\t    cellattr = &line->sb_fill_attr;\n\telse\n\t    cellattr = line->sb_cells + col;\n    }\n    return cell2attr(cellattr->attrs, cellattr->fg, cellattr->bg);\n}\n\n/*\n * Convert a cterm color number 0 - 255 to RGB.\n * This is compatible with xterm.\n */\n    static void\ncterm_color2vterm(int nr, VTermColor *rgb)\n{\n    cterm_color2rgb(nr, &rgb->red, &rgb->green, &rgb->blue, &rgb->ansi_index);\n}\n\n/*\n * Initialize term->tl_default_color from the environment.\n */\n    static void\ninit_default_colors(term_T *term)\n{\n    VTermColor\t    *fg, *bg;\n    int\t\t    fgval, bgval;\n    int\t\t    id;\n\n    vim_memset(&term->tl_default_color.attrs, 0, sizeof(VTermScreenCellAttrs));\n    term->tl_default_color.width = 1;\n    fg = &term->tl_default_color.fg;\n    bg = &term->tl_default_color.bg;\n\n    /* Vterm uses a default black background.  Set it to white when\n     * 'background' is \"light\". */\n    if (*p_bg == 'l')\n    {\n\tfgval = 0;\n\tbgval = 255;\n    }\n    else\n    {\n\tfgval = 255;\n\tbgval = 0;\n    }\n    fg->red = fg->green = fg->blue = fgval;\n    bg->red = bg->green = bg->blue = bgval;\n    fg->ansi_index = bg->ansi_index = VTERM_ANSI_INDEX_DEFAULT;\n\n    /* The \"Terminal\" highlight group overrules the defaults. */\n    id = syn_name2id((char_u *)\"Terminal\");\n\n    /* Use the actual color for the GUI and when 'termguicolors' is set. */\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (0\n# ifdef FEAT_GUI\n\t    || gui.in_use\n# endif\n# ifdef FEAT_TERMGUICOLORS\n\t    || p_tgc\n#  ifdef FEAT_VTP\n\t    /* Finally get INVALCOLOR on this execution path */\n\t    || (!p_tgc && t_colors >= 256)\n#  endif\n# endif\n       )\n    {\n\tguicolor_T\tfg_rgb = INVALCOLOR;\n\tguicolor_T\tbg_rgb = INVALCOLOR;\n\n\tif (id != 0)\n\t    syn_id2colors(id, &fg_rgb, &bg_rgb);\n\n# ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    if (fg_rgb == INVALCOLOR)\n\t\tfg_rgb = gui.norm_pixel;\n\t    if (bg_rgb == INVALCOLOR)\n\t\tbg_rgb = gui.back_pixel;\n\t}\n#  ifdef FEAT_TERMGUICOLORS\n\telse\n#  endif\n# endif\n# ifdef FEAT_TERMGUICOLORS\n\t{\n\t    if (fg_rgb == INVALCOLOR)\n\t\tfg_rgb = cterm_normal_fg_gui_color;\n\t    if (bg_rgb == INVALCOLOR)\n\t\tbg_rgb = cterm_normal_bg_gui_color;\n\t}\n# endif\n\tif (fg_rgb != INVALCOLOR)\n\t{\n\t    long_u rgb = GUI_MCH_GET_RGB(fg_rgb);\n\n\t    fg->red = (unsigned)(rgb >> 16);\n\t    fg->green = (unsigned)(rgb >> 8) & 255;\n\t    fg->blue = (unsigned)rgb & 255;\n\t}\n\tif (bg_rgb != INVALCOLOR)\n\t{\n\t    long_u rgb = GUI_MCH_GET_RGB(bg_rgb);\n\n\t    bg->red = (unsigned)(rgb >> 16);\n\t    bg->green = (unsigned)(rgb >> 8) & 255;\n\t    bg->blue = (unsigned)rgb & 255;\n\t}\n    }\n    else\n#endif\n    if (id != 0 && t_colors >= 16)\n    {\n\tif (term_default_cterm_fg >= 0)\n\t    cterm_color2vterm(term_default_cterm_fg, fg);\n\tif (term_default_cterm_bg >= 0)\n\t    cterm_color2vterm(term_default_cterm_bg, bg);\n    }\n    else\n    {\n#if defined(WIN3264) && !defined(FEAT_GUI_W32)\n\tint tmp;\n#endif\n\n\t/* In an MS-Windows console we know the normal colors. */\n\tif (cterm_normal_fg_color > 0)\n\t{\n\t    cterm_color2vterm(cterm_normal_fg_color - 1, fg);\n# if defined(WIN3264) && !defined(FEAT_GUI_W32)\n\t    tmp = fg->red;\n\t    fg->red = fg->blue;\n\t    fg->blue = tmp;\n# endif\n\t}\n# ifdef FEAT_TERMRESPONSE\n\telse\n\t    term_get_fg_color(&fg->red, &fg->green, &fg->blue);\n# endif\n\n\tif (cterm_normal_bg_color > 0)\n\t{\n\t    cterm_color2vterm(cterm_normal_bg_color - 1, bg);\n# if defined(WIN3264) && !defined(FEAT_GUI_W32)\n\t    tmp = bg->red;\n\t    bg->red = bg->blue;\n\t    bg->blue = tmp;\n# endif\n\t}\n# ifdef FEAT_TERMRESPONSE\n\telse\n\t    term_get_bg_color(&bg->red, &bg->green, &bg->blue);\n# endif\n    }\n}\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n/*\n * Set the 16 ANSI colors from array of RGB values\n */\n    static void\nset_vterm_palette(VTerm *vterm, long_u *rgb)\n{\n    int\t\tindex = 0;\n    VTermState\t*state = vterm_obtain_state(vterm);\n    for (; index < 16; index++)\n    {\n\tVTermColor\tcolor;\n\tcolor.red = (unsigned)(rgb[index] >> 16);\n\tcolor.green = (unsigned)(rgb[index] >> 8) & 255;\n\tcolor.blue = (unsigned)rgb[index] & 255;\n\tvterm_state_set_palette_color(state, index, &color);\n    }\n}\n\n/*\n * Set the ANSI color palette from a list of colors\n */\n    static int\nset_ansi_colors_list(VTerm *vterm, list_T *list)\n{\n    int\t\tn = 0;\n    long_u\trgb[16];\n    listitem_T\t*li = list->lv_first;\n\n    for (; li != NULL && n < 16; li = li->li_next, n++)\n    {\n\tchar_u\t\t*color_name;\n\tguicolor_T\tguicolor;\n\n\tcolor_name = tv_get_string_chk(&li->li_tv);\n\tif (color_name == NULL)\n\t    return FAIL;\n\n\tguicolor = GUI_GET_COLOR(color_name);\n\tif (guicolor == INVALCOLOR)\n\t    return FAIL;\n\n\trgb[n] = GUI_MCH_GET_RGB(guicolor);\n    }\n\n    if (n != 16 || li != NULL)\n\treturn FAIL;\n\n    set_vterm_palette(vterm, rgb);\n\n    return OK;\n}\n\n/*\n * Initialize the ANSI color palette from g:terminal_ansi_colors[0:15]\n */\n    static void\ninit_vterm_ansi_colors(VTerm *vterm)\n{\n    dictitem_T\t*var = find_var((char_u *)\"g:terminal_ansi_colors\", NULL, TRUE);\n\n    if (var != NULL\n\t    && (var->di_tv.v_type != VAR_LIST\n\t\t|| var->di_tv.vval.v_list == NULL\n\t\t|| set_ansi_colors_list(vterm, var->di_tv.vval.v_list) == FAIL))\n\tEMSG2(_(e_invarg2), \"g:terminal_ansi_colors\");\n}\n#endif\n\n/*\n * Handles a \"drop\" command from the job in the terminal.\n * \"item\" is the file name, \"item->li_next\" may have options.\n */\n    static void\nhandle_drop_command(listitem_T *item)\n{\n    char_u\t*fname = tv_get_string(&item->li_tv);\n    listitem_T\t*opt_item = item->li_next;\n    int\t\tbufnr;\n    win_T\t*wp;\n    tabpage_T   *tp;\n    exarg_T\tea;\n    char_u\t*tofree = NULL;\n\n    bufnr = buflist_add(fname, BLN_LISTED | BLN_NOOPT);\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer->b_fnum == bufnr)\n\t{\n\t    /* buffer is in a window already, go there */\n\t    goto_tabpage_win(tp, wp);\n\t    return;\n\t}\n    }\n\n    vim_memset(&ea, 0, sizeof(ea));\n\n    if (opt_item != NULL && opt_item->li_tv.v_type == VAR_DICT\n\t\t\t\t\t&& opt_item->li_tv.vval.v_dict != NULL)\n    {\n\tdict_T *dict = opt_item->li_tv.vval.v_dict;\n\tchar_u *p;\n\n\tp = dict_get_string(dict, (char_u *)\"ff\", FALSE);\n\tif (p == NULL)\n\t    p = dict_get_string(dict, (char_u *)\"fileformat\", FALSE);\n\tif (p != NULL)\n\t{\n\t    if (check_ff_value(p) == FAIL)\n\t\tch_log(NULL, \"Invalid ff argument to drop: %s\", p);\n\t    else\n\t\tea.force_ff = *p;\n\t}\n\tp = dict_get_string(dict, (char_u *)\"enc\", FALSE);\n\tif (p == NULL)\n\t    p = dict_get_string(dict, (char_u *)\"encoding\", FALSE);\n\tif (p != NULL)\n\t{\n\t    ea.cmd = alloc((int)STRLEN(p) + 12);\n\t    if (ea.cmd != NULL)\n\t    {\n\t\tsprintf((char *)ea.cmd, \"sbuf ++enc=%s\", p);\n\t\tea.force_enc = 11;\n\t\ttofree = ea.cmd;\n\t    }\n\t}\n\n\tp = dict_get_string(dict, (char_u *)\"bad\", FALSE);\n\tif (p != NULL)\n\t    get_bad_opt(p, &ea);\n\n\tif (dict_find(dict, (char_u *)\"bin\", -1) != NULL)\n\t    ea.force_bin = FORCE_BIN;\n\tif (dict_find(dict, (char_u *)\"binary\", -1) != NULL)\n\t    ea.force_bin = FORCE_BIN;\n\tif (dict_find(dict, (char_u *)\"nobin\", -1) != NULL)\n\t    ea.force_bin = FORCE_NOBIN;\n\tif (dict_find(dict, (char_u *)\"nobinary\", -1) != NULL)\n\t    ea.force_bin = FORCE_NOBIN;\n    }\n\n    /* open in new window, like \":split fname\" */\n    if (ea.cmd == NULL)\n\tea.cmd = (char_u *)\"split\";\n    ea.arg = fname;\n    ea.cmdidx = CMD_split;\n    ex_splitview(&ea);\n\n    vim_free(tofree);\n}\n\n/*\n * Handles a function call from the job running in a terminal.\n * \"item\" is the function name, \"item->li_next\" has the arguments.\n */\n    static void\nhandle_call_command(term_T *term, channel_T *channel, listitem_T *item)\n{\n    char_u\t*func;\n    typval_T\targvars[2];\n    typval_T\trettv;\n    int\t\tdoesrange;\n\n    if (item->li_next == NULL)\n    {\n\tch_log(channel, \"Missing function arguments for call\");\n\treturn;\n    }\n    func = tv_get_string(&item->li_tv);\n\n    if (STRNCMP(func, \"Tapi_\", 5) != 0)\n    {\n\tch_log(channel, \"Invalid function name: %s\", func);\n\treturn;\n    }\n\n    argvars[0].v_type = VAR_NUMBER;\n    argvars[0].vval.v_number = term->tl_buffer->b_fnum;\n    argvars[1] = item->li_next->li_tv;\n    if (call_func(func, (int)STRLEN(func), &rettv,\n\t\t2, argvars, /* argv_func */ NULL,\n\t\t/* firstline */ 1, /* lastline */ 1,\n\t\t&doesrange, /* evaluate */ TRUE,\n\t\t/* partial */ NULL, /* selfdict */ NULL) == OK)\n    {\n\tclear_tv(&rettv);\n\tch_log(channel, \"Function %s called\", func);\n    }\n    else\n\tch_log(channel, \"Calling function %s failed\", func);\n}\n\n/*\n * Called by libvterm when it cannot recognize an OSC sequence.\n * We recognize a terminal API command.\n */\n    static int\nparse_osc(const char *command, size_t cmdlen, void *user)\n{\n    term_T\t*term = (term_T *)user;\n    js_read_T\treader;\n    typval_T\ttv;\n    channel_T\t*channel = term->tl_job == NULL ? NULL\n\t\t\t\t\t\t    : term->tl_job->jv_channel;\n\n    /* We recognize only OSC 5 1 ; {command} */\n    if (cmdlen < 3 || STRNCMP(command, \"51;\", 3) != 0)\n\treturn 0; /* not handled */\n\n    reader.js_buf = vim_strnsave((char_u *)command + 3, (int)(cmdlen - 3));\n    if (reader.js_buf == NULL)\n\treturn 1;\n    reader.js_fill = NULL;\n    reader.js_used = 0;\n    if (json_decode(&reader, &tv, 0) == OK\n\t    && tv.v_type == VAR_LIST\n\t    && tv.vval.v_list != NULL)\n    {\n\tlistitem_T *item = tv.vval.v_list->lv_first;\n\n\tif (item == NULL)\n\t    ch_log(channel, \"Missing command\");\n\telse\n\t{\n\t    char_u\t*cmd = tv_get_string(&item->li_tv);\n\n\t    /* Make sure an invoked command doesn't delete the buffer (and the\n\t     * terminal) under our fingers. */\n\t    ++term->tl_buffer->b_locked;\n\n\t    item = item->li_next;\n\t    if (item == NULL)\n\t\tch_log(channel, \"Missing argument for %s\", cmd);\n\t    else if (STRCMP(cmd, \"drop\") == 0)\n\t\thandle_drop_command(item);\n\t    else if (STRCMP(cmd, \"call\") == 0)\n\t\thandle_call_command(term, channel, item);\n\t    else\n\t\tch_log(channel, \"Invalid command received: %s\", cmd);\n\t    --term->tl_buffer->b_locked;\n\t}\n    }\n    else\n\tch_log(channel, \"Invalid JSON received\");\n\n    vim_free(reader.js_buf);\n    clear_tv(&tv);\n    return 1;\n}\n\nstatic VTermParserCallbacks parser_fallbacks = {\n  NULL,\t\t/* text */\n  NULL,\t\t/* control */\n  NULL,\t\t/* escape */\n  NULL,\t\t/* csi */\n  parse_osc,\t/* osc */\n  NULL,\t\t/* dcs */\n  NULL\t\t/* resize */\n};\n\n/*\n * Use Vim's allocation functions for vterm so profiling works.\n */\n    static void *\nvterm_malloc(size_t size, void *data UNUSED)\n{\n    return alloc_clear((unsigned) size);\n}\n\n    static void\nvterm_memfree(void *ptr, void *data UNUSED)\n{\n    vim_free(ptr);\n}\n\nstatic VTermAllocatorFunctions vterm_allocator = {\n  &vterm_malloc,\n  &vterm_memfree\n};\n\n/*\n * Create a new vterm and initialize it.\n */\n    static void\ncreate_vterm(term_T *term, int rows, int cols)\n{\n    VTerm\t    *vterm;\n    VTermScreen\t    *screen;\n    VTermState\t    *state;\n    VTermValue\t    value;\n\n    vterm = vterm_new_with_allocator(rows, cols, &vterm_allocator, NULL);\n    term->tl_vterm = vterm;\n    screen = vterm_obtain_screen(vterm);\n    vterm_screen_set_callbacks(screen, &screen_callbacks, term);\n    /* TODO: depends on 'encoding'. */\n    vterm_set_utf8(vterm, 1);\n\n    init_default_colors(term);\n\n    vterm_state_set_default_colors(\n\t    vterm_obtain_state(vterm),\n\t    &term->tl_default_color.fg,\n\t    &term->tl_default_color.bg);\n\n    if (t_colors >= 16)\n\tvterm_state_set_bold_highbright(vterm_obtain_state(vterm), 1);\n\n    /* Required to initialize most things. */\n    vterm_screen_reset(screen, 1 /* hard */);\n\n    /* Allow using alternate screen. */\n    vterm_screen_enable_altscreen(screen, 1);\n\n    /* For unix do not use a blinking cursor.  In an xterm this causes the\n     * cursor to blink if it's blinking in the xterm.\n     * For Windows we respect the system wide setting. */\n#ifdef WIN3264\n    if (GetCaretBlinkTime() == INFINITE)\n\tvalue.boolean = 0;\n    else\n\tvalue.boolean = 1;\n#else\n    value.boolean = 0;\n#endif\n    state = vterm_obtain_state(vterm);\n    vterm_state_set_termprop(state, VTERM_PROP_CURSORBLINK, &value);\n    vterm_state_set_unrecognised_fallbacks(state, &parser_fallbacks, term);\n}\n\n/*\n * Return the text to show for the buffer name and status.\n */\n    char_u *\nterm_get_status_text(term_T *term)\n{\n    if (term->tl_status_text == NULL)\n    {\n\tchar_u *txt;\n\tsize_t len;\n\n\tif (term->tl_normal_mode)\n\t{\n\t    if (term_job_running(term))\n\t\ttxt = (char_u *)_(\"Terminal\");\n\t    else\n\t\ttxt = (char_u *)_(\"Terminal-finished\");\n\t}\n\telse if (term->tl_title != NULL)\n\t    txt = term->tl_title;\n\telse if (term_none_open(term))\n\t    txt = (char_u *)_(\"active\");\n\telse if (term_job_running(term))\n\t    txt = (char_u *)_(\"running\");\n\telse\n\t    txt = (char_u *)_(\"finished\");\n\tlen = 9 + STRLEN(term->tl_buffer->b_fname) + STRLEN(txt);\n\tterm->tl_status_text = alloc((int)len);\n\tif (term->tl_status_text != NULL)\n\t    vim_snprintf((char *)term->tl_status_text, len, \"%s [%s]\",\n\t\t\t\t\t\tterm->tl_buffer->b_fname, txt);\n    }\n    return term->tl_status_text;\n}\n\n/*\n * Mark references in jobs of terminals.\n */\n    int\nset_ref_in_term(int copyID)\n{\n    int\t\tabort = FALSE;\n    term_T\t*term;\n    typval_T\ttv;\n\n    for (term = first_term; term != NULL; term = term->tl_next)\n\tif (term->tl_job != NULL)\n\t{\n\t    tv.v_type = VAR_JOB;\n\t    tv.vval.v_job = term->tl_job;\n\t    abort = abort || set_ref_in_item(&tv, copyID, NULL, NULL);\n\t}\n    return abort;\n}\n\n/*\n * Cache \"Terminal\" highlight group colors.\n */\n    void\nset_terminal_default_colors(int cterm_fg, int cterm_bg)\n{\n    term_default_cterm_fg = cterm_fg - 1;\n    term_default_cterm_bg = cterm_bg - 1;\n}\n\n/*\n * Get the buffer from the first argument in \"argvars\".\n * Returns NULL when the buffer is not for a terminal window and logs a message\n * with \"where\".\n */\n    static buf_T *\nterm_get_buf(typval_T *argvars, char *where)\n{\n    buf_T *buf;\n\n    (void)tv_get_number(&argvars[0]);\t    /* issue errmsg if type error */\n    ++emsg_off;\n    buf = get_buf_tv(&argvars[0], FALSE);\n    --emsg_off;\n    if (buf == NULL || buf->b_term == NULL)\n    {\n\tch_log(NULL, \"%s: invalid buffer argument\", where);\n\treturn NULL;\n    }\n    return buf;\n}\n\n    static int\nsame_color(VTermColor *a, VTermColor *b)\n{\n    return a->red == b->red\n\t&& a->green == b->green\n\t&& a->blue == b->blue\n\t&& a->ansi_index == b->ansi_index;\n}\n\n    static void\ndump_term_color(FILE *fd, VTermColor *color)\n{\n    fprintf(fd, \"%02x%02x%02x%d\",\n\t    (int)color->red, (int)color->green, (int)color->blue,\n\t    (int)color->ansi_index);\n}\n\n/*\n * \"term_dumpwrite(buf, filename, options)\" function\n *\n * Each screen cell in full is:\n *    |{characters}+{attributes}#{fg-color}{color-idx}#{bg-color}{color-idx}\n * {characters} is a space for an empty cell\n * For a double-width character \"+\" is changed to \"*\" and the next cell is\n * skipped.\n * {attributes} is the decimal value of HL_BOLD + HL_UNDERLINE, etc.\n *\t\t\t  when \"&\" use the same as the previous cell.\n * {fg-color} is hex RGB, when \"&\" use the same as the previous cell.\n * {bg-color} is hex RGB, when \"&\" use the same as the previous cell.\n * {color-idx} is a number from 0 to 255\n *\n * Screen cell with same width, attributes and color as the previous one:\n *    |{characters}\n *\n * To use the color of the previous cell, use \"&\" instead of {color}-{idx}.\n *\n * Repeating the previous screen cell:\n *    @{count}\n */\n    void\nf_term_dumpwrite(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_dumpwrite()\");\n    term_T\t*term;\n    char_u\t*fname;\n    int\t\tmax_height = 0;\n    int\t\tmax_width = 0;\n    stat_T\tst;\n    FILE\t*fd;\n    VTermPos\tpos;\n    VTermScreen *screen;\n    VTermScreenCell prev_cell;\n    VTermState\t*state;\n    VTermPos\tcursor_pos;\n\n    if (check_restricted() || check_secure())\n\treturn;\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n    if (term->tl_vterm == NULL)\n    {\n\tEMSG(_(\"E958: Job already finished\"));\n\treturn;\n    }\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tdict_T *d;\n\n\tif (argvars[2].v_type != VAR_DICT)\n\t{\n\t    EMSG(_(e_dictreq));\n\t    return;\n\t}\n\td = argvars[2].vval.v_dict;\n\tif (d != NULL)\n\t{\n\t    max_height = dict_get_number(d, (char_u *)\"rows\");\n\t    max_width = dict_get_number(d, (char_u *)\"columns\");\n\t}\n    }\n\n    fname = tv_get_string_chk(&argvars[1]);\n    if (fname == NULL)\n\treturn;\n    if (mch_stat((char *)fname, &st) >= 0)\n    {\n\tEMSG2(_(\"E953: File exists: %s\"), fname);\n\treturn;\n    }\n\n    if (*fname == NUL || (fd = mch_fopen((char *)fname, WRITEBIN)) == NULL)\n    {\n\tEMSG2(_(e_notcreate), *fname == NUL ? (char_u *)_(\"<empty>\") : fname);\n\treturn;\n    }\n\n    vim_memset(&prev_cell, 0, sizeof(prev_cell));\n\n    screen = vterm_obtain_screen(term->tl_vterm);\n    state = vterm_obtain_state(term->tl_vterm);\n    vterm_state_get_cursorpos(state, &cursor_pos);\n\n    for (pos.row = 0; (max_height == 0 || pos.row < max_height)\n\t\t\t\t\t && pos.row < term->tl_rows; ++pos.row)\n    {\n\tint\t\trepeat = 0;\n\n\tfor (pos.col = 0; (max_width == 0 || pos.col < max_width)\n\t\t\t\t\t && pos.col < term->tl_cols; ++pos.col)\n\t{\n\t    VTermScreenCell cell;\n\t    int\t\t    same_attr;\n\t    int\t\t    same_chars = TRUE;\n\t    int\t\t    i;\n\t    int\t\t    is_cursor_pos = (pos.col == cursor_pos.col\n\t\t\t\t\t\t && pos.row == cursor_pos.row);\n\n\t    if (vterm_screen_get_cell(screen, pos, &cell) == 0)\n\t\tvim_memset(&cell, 0, sizeof(cell));\n\n\t    for (i = 0; i < VTERM_MAX_CHARS_PER_CELL; ++i)\n\t    {\n\t\tint c = cell.chars[i];\n\t\tint pc = prev_cell.chars[i];\n\n\t\t/* For the first character NUL is the same as space. */\n\t\tif (i == 0)\n\t\t{\n\t\t    c = (c == NUL) ? ' ' : c;\n\t\t    pc = (pc == NUL) ? ' ' : pc;\n\t\t}\n\t\tif (c != pc)\n\t\t    same_chars = FALSE;\n\t\tif (c == NUL || pc == NUL)\n\t\t    break;\n\t    }\n\t    same_attr = vtermAttr2hl(cell.attrs)\n\t\t\t\t\t       == vtermAttr2hl(prev_cell.attrs)\n\t\t\t&& same_color(&cell.fg, &prev_cell.fg)\n\t\t\t&& same_color(&cell.bg, &prev_cell.bg);\n\t    if (same_chars && cell.width == prev_cell.width && same_attr\n\t\t\t\t\t\t\t     && !is_cursor_pos)\n\t    {\n\t\t++repeat;\n\t    }\n\t    else\n\t    {\n\t\tif (repeat > 0)\n\t\t{\n\t\t    fprintf(fd, \"@%d\", repeat);\n\t\t    repeat = 0;\n\t\t}\n\t\tfputs(is_cursor_pos ? \">\" : \"|\", fd);\n\n\t\tif (cell.chars[0] == NUL)\n\t\t    fputs(\" \", fd);\n\t\telse\n\t\t{\n\t\t    char_u\tcharbuf[10];\n\t\t    int\t\tlen;\n\n\t\t    for (i = 0; i < VTERM_MAX_CHARS_PER_CELL\n\t\t\t\t\t\t  && cell.chars[i] != NUL; ++i)\n\t\t    {\n\t\t\tlen = utf_char2bytes(cell.chars[i], charbuf);\n\t\t\tfwrite(charbuf, len, 1, fd);\n\t\t    }\n\t\t}\n\n\t\t/* When only the characters differ we don't write anything, the\n\t\t * following \"|\", \"@\" or NL will indicate using the same\n\t\t * attributes. */\n\t\tif (cell.width != prev_cell.width || !same_attr)\n\t\t{\n\t\t    if (cell.width == 2)\n\t\t    {\n\t\t\tfputs(\"*\", fd);\n\t\t\t++pos.col;\n\t\t    }\n\t\t    else\n\t\t\tfputs(\"+\", fd);\n\n\t\t    if (same_attr)\n\t\t    {\n\t\t\tfputs(\"&\", fd);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfprintf(fd, \"%d\", vtermAttr2hl(cell.attrs));\n\t\t\tif (same_color(&cell.fg, &prev_cell.fg))\n\t\t\t    fputs(\"&\", fd);\n\t\t\telse\n\t\t\t{\n\t\t\t    fputs(\"#\", fd);\n\t\t\t    dump_term_color(fd, &cell.fg);\n\t\t\t}\n\t\t\tif (same_color(&cell.bg, &prev_cell.bg))\n\t\t\t    fputs(\"&\", fd);\n\t\t\telse\n\t\t\t{\n\t\t\t    fputs(\"#\", fd);\n\t\t\t    dump_term_color(fd, &cell.bg);\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tprev_cell = cell;\n\t    }\n\t}\n\tif (repeat > 0)\n\t    fprintf(fd, \"@%d\", repeat);\n\tfputs(\"\\n\", fd);\n    }\n\n    fclose(fd);\n}\n\n/*\n * Called when a dump is corrupted.  Put a breakpoint here when debugging.\n */\n    static void\ndump_is_corrupt(garray_T *gap)\n{\n    ga_concat(gap, (char_u *)\"CORRUPT\");\n}\n\n    static void\nappend_cell(garray_T *gap, cellattr_T *cell)\n{\n    if (ga_grow(gap, 1) == OK)\n    {\n\t*(((cellattr_T *)gap->ga_data) + gap->ga_len) = *cell;\n\t++gap->ga_len;\n    }\n}\n\n/*\n * Read the dump file from \"fd\" and append lines to the current buffer.\n * Return the cell width of the longest line.\n */\n    static int\nread_dump_file(FILE *fd, VTermPos *cursor_pos)\n{\n    int\t\t    c;\n    garray_T\t    ga_text;\n    garray_T\t    ga_cell;\n    char_u\t    *prev_char = NULL;\n    int\t\t    attr = 0;\n    cellattr_T\t    cell;\n    term_T\t    *term = curbuf->b_term;\n    int\t\t    max_cells = 0;\n    int\t\t    start_row = term->tl_scrollback.ga_len;\n\n    ga_init2(&ga_text, 1, 90);\n    ga_init2(&ga_cell, sizeof(cellattr_T), 90);\n    vim_memset(&cell, 0, sizeof(cell));\n    cursor_pos->row = -1;\n    cursor_pos->col = -1;\n\n    c = fgetc(fd);\n    for (;;)\n    {\n\tif (c == EOF)\n\t    break;\n\tif (c == '\\r')\n\t{\n\t    // DOS line endings?  Ignore.\n\t    c = fgetc(fd);\n\t}\n\telse if (c == '\\n')\n\t{\n\t    /* End of a line: append it to the buffer. */\n\t    if (ga_text.ga_data == NULL)\n\t\tdump_is_corrupt(&ga_text);\n\t    if (ga_grow(&term->tl_scrollback, 1) == OK)\n\t    {\n\t\tsb_line_T   *line = (sb_line_T *)term->tl_scrollback.ga_data\n\t\t\t\t\t\t  + term->tl_scrollback.ga_len;\n\n\t\tif (max_cells < ga_cell.ga_len)\n\t\t    max_cells = ga_cell.ga_len;\n\t\tline->sb_cols = ga_cell.ga_len;\n\t\tline->sb_cells = ga_cell.ga_data;\n\t\tline->sb_fill_attr = term->tl_default_color;\n\t\t++term->tl_scrollback.ga_len;\n\t\tga_init(&ga_cell);\n\n\t\tga_append(&ga_text, NUL);\n\t\tml_append(curbuf->b_ml.ml_line_count, ga_text.ga_data,\n\t\t\t\t\t\t\tga_text.ga_len, FALSE);\n\t    }\n\t    else\n\t\tga_clear(&ga_cell);\n\t    ga_text.ga_len = 0;\n\n\t    c = fgetc(fd);\n\t}\n\telse if (c == '|' || c == '>')\n\t{\n\t    int prev_len = ga_text.ga_len;\n\n\t    if (c == '>')\n\t    {\n\t\tif (cursor_pos->row != -1)\n\t\t    dump_is_corrupt(&ga_text);\t/* duplicate cursor */\n\t\tcursor_pos->row = term->tl_scrollback.ga_len - start_row;\n\t\tcursor_pos->col = ga_cell.ga_len;\n\t    }\n\n\t    /* normal character(s) followed by \"+\", \"*\", \"|\", \"@\" or NL */\n\t    c = fgetc(fd);\n\t    if (c != EOF)\n\t\tga_append(&ga_text, c);\n\t    for (;;)\n\t    {\n\t\tc = fgetc(fd);\n\t\tif (c == '+' || c == '*' || c == '|' || c == '>' || c == '@'\n\t\t\t\t\t\t      || c == EOF || c == '\\n')\n\t\t    break;\n\t\tga_append(&ga_text, c);\n\t    }\n\n\t    /* save the character for repeating it */\n\t    vim_free(prev_char);\n\t    if (ga_text.ga_data != NULL)\n\t\tprev_char = vim_strnsave(((char_u *)ga_text.ga_data) + prev_len,\n\t\t\t\t\t\t    ga_text.ga_len - prev_len);\n\n\t    if (c == '@' || c == '|' || c == '>' || c == '\\n')\n\t    {\n\t\t/* use all attributes from previous cell */\n\t    }\n\t    else if (c == '+' || c == '*')\n\t    {\n\t\tint is_bg;\n\n\t\tcell.width = c == '+' ? 1 : 2;\n\n\t\tc = fgetc(fd);\n\t\tif (c == '&')\n\t\t{\n\t\t    /* use same attr as previous cell */\n\t\t    c = fgetc(fd);\n\t\t}\n\t\telse if (isdigit(c))\n\t\t{\n\t\t    /* get the decimal attribute */\n\t\t    attr = 0;\n\t\t    while (isdigit(c))\n\t\t    {\n\t\t\tattr = attr * 10 + (c - '0');\n\t\t\tc = fgetc(fd);\n\t\t    }\n\t\t    hl2vtermAttr(attr, &cell);\n\t\t}\n\t\telse\n\t\t    dump_is_corrupt(&ga_text);\n\n\t\t/* is_bg == 0: fg, is_bg == 1: bg */\n\t\tfor (is_bg = 0; is_bg <= 1; ++is_bg)\n\t\t{\n\t\t    if (c == '&')\n\t\t    {\n\t\t\t/* use same color as previous cell */\n\t\t\tc = fgetc(fd);\n\t\t    }\n\t\t    else if (c == '#')\n\t\t    {\n\t\t\tint red, green, blue, index = 0;\n\n\t\t\tc = fgetc(fd);\n\t\t\tred = hex2nr(c);\n\t\t\tc = fgetc(fd);\n\t\t\tred = (red << 4) + hex2nr(c);\n\t\t\tc = fgetc(fd);\n\t\t\tgreen = hex2nr(c);\n\t\t\tc = fgetc(fd);\n\t\t\tgreen = (green << 4) + hex2nr(c);\n\t\t\tc = fgetc(fd);\n\t\t\tblue = hex2nr(c);\n\t\t\tc = fgetc(fd);\n\t\t\tblue = (blue << 4) + hex2nr(c);\n\t\t\tc = fgetc(fd);\n\t\t\tif (!isdigit(c))\n\t\t\t    dump_is_corrupt(&ga_text);\n\t\t\twhile (isdigit(c))\n\t\t\t{\n\t\t\t    index = index * 10 + (c - '0');\n\t\t\t    c = fgetc(fd);\n\t\t\t}\n\n\t\t\tif (is_bg)\n\t\t\t{\n\t\t\t    cell.bg.red = red;\n\t\t\t    cell.bg.green = green;\n\t\t\t    cell.bg.blue = blue;\n\t\t\t    cell.bg.ansi_index = index;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    cell.fg.red = red;\n\t\t\t    cell.fg.green = green;\n\t\t\t    cell.fg.blue = blue;\n\t\t\t    cell.fg.ansi_index = index;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tdump_is_corrupt(&ga_text);\n\t\t}\n\t    }\n\t    else\n\t\tdump_is_corrupt(&ga_text);\n\n\t    append_cell(&ga_cell, &cell);\n\t}\n\telse if (c == '@')\n\t{\n\t    if (prev_char == NULL)\n\t\tdump_is_corrupt(&ga_text);\n\t    else\n\t    {\n\t\tint count = 0;\n\n\t\t/* repeat previous character, get the count */\n\t\tfor (;;)\n\t\t{\n\t\t    c = fgetc(fd);\n\t\t    if (!isdigit(c))\n\t\t\tbreak;\n\t\t    count = count * 10 + (c - '0');\n\t\t}\n\n\t\twhile (count-- > 0)\n\t\t{\n\t\t    ga_concat(&ga_text, prev_char);\n\t\t    append_cell(&ga_cell, &cell);\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    dump_is_corrupt(&ga_text);\n\t    c = fgetc(fd);\n\t}\n    }\n\n    if (ga_text.ga_len > 0)\n    {\n\t/* trailing characters after last NL */\n\tdump_is_corrupt(&ga_text);\n\tga_append(&ga_text, NUL);\n\tml_append(curbuf->b_ml.ml_line_count, ga_text.ga_data,\n\t\t\t\t\t\t\tga_text.ga_len, FALSE);\n    }\n\n    ga_clear(&ga_text);\n    vim_free(prev_char);\n\n    return max_cells;\n}\n\n/*\n * Return an allocated string with at least \"text_width\" \"=\" characters and\n * \"fname\" inserted in the middle.\n */\n    static char_u *\nget_separator(int text_width, char_u *fname)\n{\n    int\t    width = MAX(text_width, curwin->w_width);\n    char_u  *textline;\n    int\t    fname_size;\n    char_u  *p = fname;\n    int\t    i;\n    size_t  off;\n\n    textline = alloc(width + (int)STRLEN(fname) + 1);\n    if (textline == NULL)\n\treturn NULL;\n\n    fname_size = vim_strsize(fname);\n    if (fname_size < width - 8)\n    {\n\t/* enough room, don't use the full window width */\n\twidth = MAX(text_width, fname_size + 8);\n    }\n    else if (fname_size > width - 8)\n    {\n\t/* full name doesn't fit, use only the tail */\n\tp = gettail(fname);\n\tfname_size = vim_strsize(p);\n    }\n    /* skip characters until the name fits */\n    while (fname_size > width - 8)\n    {\n\tp += (*mb_ptr2len)(p);\n\tfname_size = vim_strsize(p);\n    }\n\n    for (i = 0; i < (width - fname_size) / 2 - 1; ++i)\n\ttextline[i] = '=';\n    textline[i++] = ' ';\n\n    STRCPY(textline + i, p);\n    off = STRLEN(textline);\n    textline[off] = ' ';\n    for (i = 1; i < (width - fname_size) / 2; ++i)\n\ttextline[off + i] = '=';\n    textline[off + i] = NUL;\n\n    return textline;\n}\n\n/*\n * Common for \"term_dumpdiff()\" and \"term_dumpload()\".\n */\n    static void\nterm_load_dump(typval_T *argvars, typval_T *rettv, int do_diff)\n{\n    jobopt_T\topt;\n    buf_T\t*buf;\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    char_u\t*fname1;\n    char_u\t*fname2 = NULL;\n    char_u\t*fname_tofree = NULL;\n    FILE\t*fd1;\n    FILE\t*fd2 = NULL;\n    char_u\t*textline = NULL;\n\n    /* First open the files.  If this fails bail out. */\n    fname1 = tv_get_string_buf_chk(&argvars[0], buf1);\n    if (do_diff)\n\tfname2 = tv_get_string_buf_chk(&argvars[1], buf2);\n    if (fname1 == NULL || (do_diff && fname2 == NULL))\n    {\n\tEMSG(_(e_invarg));\n\treturn;\n    }\n    fd1 = mch_fopen((char *)fname1, READBIN);\n    if (fd1 == NULL)\n    {\n\tEMSG2(_(e_notread), fname1);\n\treturn;\n    }\n    if (do_diff)\n    {\n\tfd2 = mch_fopen((char *)fname2, READBIN);\n\tif (fd2 == NULL)\n\t{\n\t    fclose(fd1);\n\t    EMSG2(_(e_notread), fname2);\n\t    return;\n\t}\n    }\n\n    init_job_options(&opt);\n    if (argvars[do_diff ? 2 : 1].v_type != VAR_UNKNOWN\n\t    && get_job_options(&argvars[do_diff ? 2 : 1], &opt, 0,\n\t\t    JO2_TERM_NAME + JO2_TERM_COLS + JO2_TERM_ROWS\n\t\t    + JO2_VERTICAL + JO2_CURWIN + JO2_NORESTORE) == FAIL)\n\tgoto theend;\n\n    if (opt.jo_term_name == NULL)\n    {\n\tsize_t len = STRLEN(fname1) + 12;\n\n\tfname_tofree = alloc((int)len);\n\tif (fname_tofree != NULL)\n\t{\n\t    vim_snprintf((char *)fname_tofree, len, \"dump diff %s\", fname1);\n\t    opt.jo_term_name = fname_tofree;\n\t}\n    }\n\n    buf = term_start(&argvars[0], NULL, &opt, TERM_START_NOJOB);\n    if (buf != NULL && buf->b_term != NULL)\n    {\n\tint\t\ti;\n\tlinenr_T\tbot_lnum;\n\tlinenr_T\tlnum;\n\tterm_T\t\t*term = buf->b_term;\n\tint\t\twidth;\n\tint\t\twidth2;\n\tVTermPos\tcursor_pos1;\n\tVTermPos\tcursor_pos2;\n\n\tinit_default_colors(term);\n\n\trettv->vval.v_number = buf->b_fnum;\n\n\t/* read the files, fill the buffer with the diff */\n\twidth = read_dump_file(fd1, &cursor_pos1);\n\n\t/* position the cursor */\n\tif (cursor_pos1.row >= 0)\n\t{\n\t    curwin->w_cursor.lnum = cursor_pos1.row + 1;\n\t    coladvance(cursor_pos1.col);\n\t}\n\n\t/* Delete the empty line that was in the empty buffer. */\n\tml_delete(1, FALSE);\n\n\t/* For term_dumpload() we are done here. */\n\tif (!do_diff)\n\t    goto theend;\n\n\tterm->tl_top_diff_rows = curbuf->b_ml.ml_line_count;\n\n\ttextline = get_separator(width, fname1);\n\tif (textline == NULL)\n\t    goto theend;\n\tif (add_empty_scrollback(term, &term->tl_default_color, 0) == OK)\n\t    ml_append(curbuf->b_ml.ml_line_count, textline, 0, FALSE);\n\tvim_free(textline);\n\n\ttextline = get_separator(width, fname2);\n\tif (textline == NULL)\n\t    goto theend;\n\tif (add_empty_scrollback(term, &term->tl_default_color, 0) == OK)\n\t    ml_append(curbuf->b_ml.ml_line_count, textline, 0, FALSE);\n\ttextline[width] = NUL;\n\n\tbot_lnum = curbuf->b_ml.ml_line_count;\n\twidth2 = read_dump_file(fd2, &cursor_pos2);\n\tif (width2 > width)\n\t{\n\t    vim_free(textline);\n\t    textline = alloc(width2 + 1);\n\t    if (textline == NULL)\n\t\tgoto theend;\n\t    width = width2;\n\t    textline[width] = NUL;\n\t}\n\tterm->tl_bot_diff_rows = curbuf->b_ml.ml_line_count - bot_lnum;\n\n\tfor (lnum = 1; lnum <= term->tl_top_diff_rows; ++lnum)\n\t{\n\t    if (lnum + bot_lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t/* bottom part has fewer rows, fill with \"-\" */\n\t\tfor (i = 0; i < width; ++i)\n\t\t    textline[i] = '-';\n\t    }\n\t    else\n\t    {\n\t\tchar_u *line1;\n\t\tchar_u *line2;\n\t\tchar_u *p1;\n\t\tchar_u *p2;\n\t\tint\tcol;\n\t\tsb_line_T   *sb_line = (sb_line_T *)term->tl_scrollback.ga_data;\n\t\tcellattr_T *cellattr1 = (sb_line + lnum - 1)->sb_cells;\n\t\tcellattr_T *cellattr2 = (sb_line + lnum + bot_lnum - 1)\n\t\t\t\t\t\t\t\t    ->sb_cells;\n\n\t\t/* Make a copy, getting the second line will invalidate it. */\n\t\tline1 = vim_strsave(ml_get(lnum));\n\t\tif (line1 == NULL)\n\t\t    break;\n\t\tp1 = line1;\n\n\t\tline2 = ml_get(lnum + bot_lnum);\n\t\tp2 = line2;\n\t\tfor (col = 0; col < width && *p1 != NUL && *p2 != NUL; ++col)\n\t\t{\n\t\t    int len1 = utfc_ptr2len(p1);\n\t\t    int len2 = utfc_ptr2len(p2);\n\n\t\t    textline[col] = ' ';\n\t\t    if (len1 != len2 || STRNCMP(p1, p2, len1) != 0)\n\t\t\t/* text differs */\n\t\t\ttextline[col] = 'X';\n\t\t    else if (lnum == cursor_pos1.row + 1\n\t\t\t    && col == cursor_pos1.col\n\t\t\t    && (cursor_pos1.row != cursor_pos2.row\n\t\t\t\t\t|| cursor_pos1.col != cursor_pos2.col))\n\t\t\t/* cursor in first but not in second */\n\t\t\ttextline[col] = '>';\n\t\t    else if (lnum == cursor_pos2.row + 1\n\t\t\t    && col == cursor_pos2.col\n\t\t\t    && (cursor_pos1.row != cursor_pos2.row\n\t\t\t\t\t|| cursor_pos1.col != cursor_pos2.col))\n\t\t\t/* cursor in second but not in first */\n\t\t\ttextline[col] = '<';\n\t\t    else if (cellattr1 != NULL && cellattr2 != NULL)\n\t\t    {\n\t\t\tif ((cellattr1 + col)->width\n\t\t\t\t\t\t   != (cellattr2 + col)->width)\n\t\t\t    textline[col] = 'w';\n\t\t\telse if (!same_color(&(cellattr1 + col)->fg,\n\t\t\t\t\t\t   &(cellattr2 + col)->fg))\n\t\t\t    textline[col] = 'f';\n\t\t\telse if (!same_color(&(cellattr1 + col)->bg,\n\t\t\t\t\t\t   &(cellattr2 + col)->bg))\n\t\t\t    textline[col] = 'b';\n\t\t\telse if (vtermAttr2hl((cellattr1 + col)->attrs)\n\t\t\t\t   != vtermAttr2hl(((cellattr2 + col)->attrs)))\n\t\t\t    textline[col] = 'a';\n\t\t    }\n\t\t    p1 += len1;\n\t\t    p2 += len2;\n\t\t    /* TODO: handle different width */\n\t\t}\n\t\tvim_free(line1);\n\n\t\twhile (col < width)\n\t\t{\n\t\t    if (*p1 == NUL && *p2 == NUL)\n\t\t\ttextline[col] = '?';\n\t\t    else if (*p1 == NUL)\n\t\t    {\n\t\t\ttextline[col] = '+';\n\t\t\tp2 += utfc_ptr2len(p2);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\ttextline[col] = '-';\n\t\t\tp1 += utfc_ptr2len(p1);\n\t\t    }\n\t\t    ++col;\n\t\t}\n\t    }\n\t    if (add_empty_scrollback(term, &term->tl_default_color,\n\t\t\t\t\t\t term->tl_top_diff_rows) == OK)\n\t\tml_append(term->tl_top_diff_rows + lnum, textline, 0, FALSE);\n\t    ++bot_lnum;\n\t}\n\n\twhile (lnum + bot_lnum <= curbuf->b_ml.ml_line_count)\n\t{\n\t    /* bottom part has more rows, fill with \"+\" */\n\t    for (i = 0; i < width; ++i)\n\t\ttextline[i] = '+';\n\t    if (add_empty_scrollback(term, &term->tl_default_color,\n\t\t\t\t\t\t term->tl_top_diff_rows) == OK)\n\t\tml_append(term->tl_top_diff_rows + lnum, textline, 0, FALSE);\n\t    ++lnum;\n\t    ++bot_lnum;\n\t}\n\n\tterm->tl_cols = width;\n\n\t/* looks better without wrapping */\n\tcurwin->w_p_wrap = 0;\n    }\n\ntheend:\n    vim_free(textline);\n    vim_free(fname_tofree);\n    fclose(fd1);\n    if (fd2 != NULL)\n\tfclose(fd2);\n}\n\n/*\n * If the current buffer shows the output of term_dumpdiff(), swap the top and\n * bottom files.\n * Return FAIL when this is not possible.\n */\n    int\nterm_swap_diff()\n{\n    term_T\t*term = curbuf->b_term;\n    linenr_T\tline_count;\n    linenr_T\ttop_rows;\n    linenr_T\tbot_rows;\n    linenr_T\tbot_start;\n    linenr_T\tlnum;\n    char_u\t*p;\n    sb_line_T\t*sb_line;\n\n    if (term == NULL\n\t    || !term_is_finished(curbuf)\n\t    || term->tl_top_diff_rows == 0\n\t    || term->tl_scrollback.ga_len == 0)\n\treturn FAIL;\n\n    line_count = curbuf->b_ml.ml_line_count;\n    top_rows = term->tl_top_diff_rows;\n    bot_rows = term->tl_bot_diff_rows;\n    bot_start = line_count - bot_rows;\n    sb_line = (sb_line_T *)term->tl_scrollback.ga_data;\n\n    /* move lines from top to above the bottom part */\n    for (lnum = 1; lnum <= top_rows; ++lnum)\n    {\n\tp = vim_strsave(ml_get(1));\n\tif (p == NULL)\n\t    return OK;\n\tml_append(bot_start, p, 0, FALSE);\n\tml_delete(1, FALSE);\n\tvim_free(p);\n    }\n\n    /* move lines from bottom to the top */\n    for (lnum = 1; lnum <= bot_rows; ++lnum)\n    {\n\tp = vim_strsave(ml_get(bot_start + lnum));\n\tif (p == NULL)\n\t    return OK;\n\tml_delete(bot_start + lnum, FALSE);\n\tml_append(lnum - 1, p, 0, FALSE);\n\tvim_free(p);\n    }\n\n    if (top_rows == bot_rows)\n    {\n\t/* rows counts are equal, can swap cell properties */\n\tfor (lnum = 0; lnum < top_rows; ++lnum)\n\t{\n\t    sb_line_T\ttemp;\n\n\t    temp = *(sb_line + lnum);\n\t    *(sb_line + lnum) = *(sb_line + bot_start + lnum);\n\t    *(sb_line + bot_start + lnum) = temp;\n\t}\n    }\n    else\n    {\n\tsize_t\t\tsize = sizeof(sb_line_T) * term->tl_scrollback.ga_len;\n\tsb_line_T\t*temp = (sb_line_T *)alloc((int)size);\n\n\t/* need to copy cell properties into temp memory */\n\tif (temp != NULL)\n\t{\n\t    mch_memmove(temp, term->tl_scrollback.ga_data, size);\n\t    mch_memmove(term->tl_scrollback.ga_data,\n\t\t    temp + bot_start,\n\t\t    sizeof(sb_line_T) * bot_rows);\n\t    mch_memmove((sb_line_T *)term->tl_scrollback.ga_data + bot_rows,\n\t\t    temp + top_rows,\n\t\t    sizeof(sb_line_T) * (line_count - top_rows - bot_rows));\n\t    mch_memmove((sb_line_T *)term->tl_scrollback.ga_data\n\t\t\t\t\t\t       + line_count - top_rows,\n\t\t    temp,\n\t\t    sizeof(sb_line_T) * top_rows);\n\t    vim_free(temp);\n\t}\n    }\n\n    term->tl_top_diff_rows = bot_rows;\n    term->tl_bot_diff_rows = top_rows;\n\n    update_screen(NOT_VALID);\n    return OK;\n}\n\n/*\n * \"term_dumpdiff(filename, filename, options)\" function\n */\n    void\nf_term_dumpdiff(typval_T *argvars, typval_T *rettv)\n{\n    term_load_dump(argvars, rettv, TRUE);\n}\n\n/*\n * \"term_dumpload(filename, options)\" function\n */\n    void\nf_term_dumpload(typval_T *argvars, typval_T *rettv)\n{\n    term_load_dump(argvars, rettv, FALSE);\n}\n\n/*\n * \"term_getaltscreen(buf)\" function\n */\n    void\nf_term_getaltscreen(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getaltscreen()\");\n\n    if (buf == NULL)\n\treturn;\n    rettv->vval.v_number = buf->b_term->tl_using_altscreen;\n}\n\n/*\n * \"term_getattr(attr, name)\" function\n */\n    void\nf_term_getattr(typval_T *argvars, typval_T *rettv)\n{\n    int\t    attr;\n    size_t  i;\n    char_u  *name;\n\n    static struct {\n\tchar\t    *name;\n\tint\t    attr;\n    } attrs[] = {\n\t{\"bold\",      HL_BOLD},\n\t{\"italic\",    HL_ITALIC},\n\t{\"underline\", HL_UNDERLINE},\n\t{\"strike\",    HL_STRIKETHROUGH},\n\t{\"reverse\",   HL_INVERSE},\n    };\n\n    attr = tv_get_number(&argvars[0]);\n    name = tv_get_string_chk(&argvars[1]);\n    if (name == NULL)\n\treturn;\n\n    for (i = 0; i < sizeof(attrs)/sizeof(attrs[0]); ++i)\n\tif (STRCMP(name, attrs[i].name) == 0)\n\t{\n\t    rettv->vval.v_number = (attr & attrs[i].attr) != 0 ? 1 : 0;\n\t    break;\n\t}\n}\n\n/*\n * \"term_getcursor(buf)\" function\n */\n    void\nf_term_getcursor(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getcursor()\");\n    term_T\t*term;\n    list_T\t*l;\n    dict_T\t*d;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n\n    l = rettv->vval.v_list;\n    list_append_number(l, term->tl_cursor_pos.row + 1);\n    list_append_number(l, term->tl_cursor_pos.col + 1);\n\n    d = dict_alloc();\n    if (d != NULL)\n    {\n\tdict_add_number(d, \"visible\", term->tl_cursor_visible);\n\tdict_add_number(d, \"blink\", blink_state_is_inverted()\n\t\t\t    ? !term->tl_cursor_blink : term->tl_cursor_blink);\n\tdict_add_number(d, \"shape\", term->tl_cursor_shape);\n\tdict_add_string(d, \"color\", cursor_color_get(term->tl_cursor_color));\n\tlist_append_dict(l, d);\n    }\n}\n\n/*\n * \"term_getjob(buf)\" function\n */\n    void\nf_term_getjob(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getjob()\");\n\n    if (buf == NULL)\n    {\n\trettv->v_type = VAR_SPECIAL;\n\trettv->vval.v_number = VVAL_NULL;\n\treturn;\n    }\n\n    rettv->v_type = VAR_JOB;\n    rettv->vval.v_job = buf->b_term->tl_job;\n    if (rettv->vval.v_job != NULL)\n\t++rettv->vval.v_job->jv_refcount;\n}\n\n    static int\nget_row_number(typval_T *tv, term_T *term)\n{\n    if (tv->v_type == VAR_STRING\n\t    && tv->vval.v_string != NULL\n\t    && STRCMP(tv->vval.v_string, \".\") == 0)\n\treturn term->tl_cursor_pos.row;\n    return (int)tv_get_number(tv) - 1;\n}\n\n/*\n * \"term_getline(buf, row)\" function\n */\n    void\nf_term_getline(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t    *buf = term_get_buf(argvars, \"term_getline()\");\n    term_T\t    *term;\n    int\t\t    row;\n\n    rettv->v_type = VAR_STRING;\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n    row = get_row_number(&argvars[1], term);\n\n    if (term->tl_vterm == NULL)\n    {\n\tlinenr_T lnum = row + term->tl_scrollback_scrolled + 1;\n\n\t/* vterm is finished, get the text from the buffer */\n\tif (lnum > 0 && lnum <= buf->b_ml.ml_line_count)\n\t    rettv->vval.v_string = vim_strsave(ml_get_buf(buf, lnum, FALSE));\n    }\n    else\n    {\n\tVTermScreen\t*screen = vterm_obtain_screen(term->tl_vterm);\n\tVTermRect\trect;\n\tint\t\tlen;\n\tchar_u\t\t*p;\n\n\tif (row < 0 || row >= term->tl_rows)\n\t    return;\n\tlen = term->tl_cols * MB_MAXBYTES + 1;\n\tp = alloc(len);\n\tif (p == NULL)\n\t    return;\n\trettv->vval.v_string = p;\n\n\trect.start_col = 0;\n\trect.end_col = term->tl_cols;\n\trect.start_row = row;\n\trect.end_row = row + 1;\n\tp[vterm_screen_get_text(screen, (char *)p, len, rect)] = NUL;\n    }\n}\n\n/*\n * \"term_getscrolled(buf)\" function\n */\n    void\nf_term_getscrolled(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getscrolled()\");\n\n    if (buf == NULL)\n\treturn;\n    rettv->vval.v_number = buf->b_term->tl_scrollback_scrolled;\n}\n\n/*\n * \"term_getsize(buf)\" function\n */\n    void\nf_term_getsize(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getsize()\");\n    list_T\t*l;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n    if (buf == NULL)\n\treturn;\n\n    l = rettv->vval.v_list;\n    list_append_number(l, buf->b_term->tl_rows);\n    list_append_number(l, buf->b_term->tl_cols);\n}\n\n/*\n * \"term_setsize(buf, rows, cols)\" function\n */\n    void\nf_term_setsize(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_setsize()\");\n    term_T\t*term;\n    varnumber_T rows, cols;\n\n    if (buf == NULL)\n    {\n\tEMSG(_(\"E955: Not a terminal buffer\"));\n\treturn;\n    }\n    if (buf->b_term->tl_vterm == NULL)\n\treturn;\n    term = buf->b_term;\n    rows = tv_get_number(&argvars[1]);\n    rows = rows <= 0 ? term->tl_rows : rows;\n    cols = tv_get_number(&argvars[2]);\n    cols = cols <= 0 ? term->tl_cols : cols;\n    vterm_set_size(term->tl_vterm, rows, cols);\n    /* handle_resize() will resize the windows */\n\n    /* Get and remember the size we ended up with.  Update the pty. */\n    vterm_get_size(term->tl_vterm, &term->tl_rows, &term->tl_cols);\n    term_report_winsize(term, term->tl_rows, term->tl_cols);\n}\n\n/*\n * \"term_getstatus(buf)\" function\n */\n    void\nf_term_getstatus(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getstatus()\");\n    term_T\t*term;\n    char_u\tval[100];\n\n    rettv->v_type = VAR_STRING;\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n\n    if (term_job_running(term))\n\tSTRCPY(val, \"running\");\n    else\n\tSTRCPY(val, \"finished\");\n    if (term->tl_normal_mode)\n\tSTRCAT(val, \",normal\");\n    rettv->vval.v_string = vim_strsave(val);\n}\n\n/*\n * \"term_gettitle(buf)\" function\n */\n    void\nf_term_gettitle(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_gettitle()\");\n\n    rettv->v_type = VAR_STRING;\n    if (buf == NULL)\n\treturn;\n\n    if (buf->b_term->tl_title != NULL)\n\trettv->vval.v_string = vim_strsave(buf->b_term->tl_title);\n}\n\n/*\n * \"term_gettty(buf)\" function\n */\n    void\nf_term_gettty(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_gettty()\");\n    char_u\t*p = NULL;\n    int\t\tnum = 0;\n\n    rettv->v_type = VAR_STRING;\n    if (buf == NULL)\n\treturn;\n    if (argvars[1].v_type != VAR_UNKNOWN)\n\tnum = tv_get_number(&argvars[1]);\n\n    switch (num)\n    {\n\tcase 0:\n\t    if (buf->b_term->tl_job != NULL)\n\t\tp = buf->b_term->tl_job->jv_tty_out;\n\t    break;\n\tcase 1:\n\t    if (buf->b_term->tl_job != NULL)\n\t\tp = buf->b_term->tl_job->jv_tty_in;\n\t    break;\n\tdefault:\n\t    EMSG2(_(e_invarg2), tv_get_string(&argvars[1]));\n\t    return;\n    }\n    if (p != NULL)\n\trettv->vval.v_string = vim_strsave(p);\n}\n\n/*\n * \"term_list()\" function\n */\n    void\nf_term_list(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    term_T\t*tp;\n    list_T\t*l;\n\n    if (rettv_list_alloc(rettv) == FAIL || first_term == NULL)\n\treturn;\n\n    l = rettv->vval.v_list;\n    for (tp = first_term; tp != NULL; tp = tp->tl_next)\n\tif (tp != NULL && tp->tl_buffer != NULL)\n\t    if (list_append_number(l,\n\t\t\t\t   (varnumber_T)tp->tl_buffer->b_fnum) == FAIL)\n\t\treturn;\n}\n\n/*\n * \"term_scrape(buf, row)\" function\n */\n    void\nf_term_scrape(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t    *buf = term_get_buf(argvars, \"term_scrape()\");\n    VTermScreen\t    *screen = NULL;\n    VTermPos\t    pos;\n    list_T\t    *l;\n    term_T\t    *term;\n    char_u\t    *p;\n    sb_line_T\t    *line;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n\n    l = rettv->vval.v_list;\n    pos.row = get_row_number(&argvars[1], term);\n\n    if (term->tl_vterm != NULL)\n    {\n\tscreen = vterm_obtain_screen(term->tl_vterm);\n\tp = NULL;\n\tline = NULL;\n    }\n    else\n    {\n\tlinenr_T\tlnum = pos.row + term->tl_scrollback_scrolled;\n\n\tif (lnum < 0 || lnum >= term->tl_scrollback.ga_len)\n\t    return;\n\tp = ml_get_buf(buf, lnum + 1, FALSE);\n\tline = (sb_line_T *)term->tl_scrollback.ga_data + lnum;\n    }\n\n    for (pos.col = 0; pos.col < term->tl_cols; )\n    {\n\tdict_T\t\t*dcell;\n\tint\t\twidth;\n\tVTermScreenCellAttrs attrs;\n\tVTermColor\tfg, bg;\n\tchar_u\t\trgb[8];\n\tchar_u\t\tmbs[MB_MAXBYTES * VTERM_MAX_CHARS_PER_CELL + 1];\n\tint\t\toff = 0;\n\tint\t\ti;\n\n\tif (screen == NULL)\n\t{\n\t    cellattr_T\t*cellattr;\n\t    int\t\tlen;\n\n\t    /* vterm has finished, get the cell from scrollback */\n\t    if (pos.col >= line->sb_cols)\n\t\tbreak;\n\t    cellattr = line->sb_cells + pos.col;\n\t    width = cellattr->width;\n\t    attrs = cellattr->attrs;\n\t    fg = cellattr->fg;\n\t    bg = cellattr->bg;\n\t    len = MB_PTR2LEN(p);\n\t    mch_memmove(mbs, p, len);\n\t    mbs[len] = NUL;\n\t    p += len;\n\t}\n\telse\n\t{\n\t    VTermScreenCell cell;\n\t    if (vterm_screen_get_cell(screen, pos, &cell) == 0)\n\t\tbreak;\n\t    for (i = 0; i < VTERM_MAX_CHARS_PER_CELL; ++i)\n\t    {\n\t\tif (cell.chars[i] == 0)\n\t\t    break;\n\t\toff += (*utf_char2bytes)((int)cell.chars[i], mbs + off);\n\t    }\n\t    mbs[off] = NUL;\n\t    width = cell.width;\n\t    attrs = cell.attrs;\n\t    fg = cell.fg;\n\t    bg = cell.bg;\n\t}\n\tdcell = dict_alloc();\n\tif (dcell == NULL)\n\t    break;\n\tlist_append_dict(l, dcell);\n\n\tdict_add_string(dcell, \"chars\", mbs);\n\n\tvim_snprintf((char *)rgb, 8, \"#%02x%02x%02x\",\n\t\t\t\t     fg.red, fg.green, fg.blue);\n\tdict_add_string(dcell, \"fg\", rgb);\n\tvim_snprintf((char *)rgb, 8, \"#%02x%02x%02x\",\n\t\t\t\t     bg.red, bg.green, bg.blue);\n\tdict_add_string(dcell, \"bg\", rgb);\n\n\tdict_add_number(dcell, \"attr\", cell2attr(attrs, fg, bg));\n\tdict_add_number(dcell, \"width\", width);\n\n\t++pos.col;\n\tif (width == 2)\n\t    ++pos.col;\n    }\n}\n\n/*\n * \"term_sendkeys(buf, keys)\" function\n */\n    void\nf_term_sendkeys(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_sendkeys()\");\n    char_u\t*msg;\n    term_T\t*term;\n\n    rettv->v_type = VAR_UNKNOWN;\n    if (buf == NULL)\n\treturn;\n\n    msg = tv_get_string_chk(&argvars[1]);\n    if (msg == NULL)\n\treturn;\n    term = buf->b_term;\n    if (term->tl_vterm == NULL)\n\treturn;\n\n    while (*msg != NUL)\n    {\n\tint c;\n\n\tif (*msg == K_SPECIAL && msg[1] != NUL && msg[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(msg[1], msg[2]);\n\t    msg += 3;\n\t}\n\telse\n\t{\n\t    c = PTR2CHAR(msg);\n\t    msg += MB_CPTR2LEN(msg);\n\t}\n\tsend_keys_to_term(term, c, FALSE);\n    }\n}\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS) || defined(PROTO)\n/*\n * \"term_getansicolors(buf)\" function\n */\n    void\nf_term_getansicolors(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getansicolors()\");\n    term_T\t*term;\n    VTermState\t*state;\n    VTermColor  color;\n    char_u\thexbuf[10];\n    int\t\tindex;\n    list_T\t*list;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n    if (term->tl_vterm == NULL)\n\treturn;\n\n    list = rettv->vval.v_list;\n    state = vterm_obtain_state(term->tl_vterm);\n    for (index = 0; index < 16; index++)\n    {\n\tvterm_state_get_palette_color(state, index, &color);\n\tsprintf((char *)hexbuf, \"#%02x%02x%02x\",\n\t\tcolor.red, color.green, color.blue);\n\tif (list_append_string(list, hexbuf, 7) == FAIL)\n\t    return;\n    }\n}\n\n/*\n * \"term_setansicolors(buf, list)\" function\n */\n    void\nf_term_setansicolors(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_setansicolors()\");\n    term_T\t*term;\n\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n    if (term->tl_vterm == NULL)\n\treturn;\n\n    if (argvars[1].v_type != VAR_LIST || argvars[1].vval.v_list == NULL)\n    {\n\tEMSG(_(e_listreq));\n\treturn;\n    }\n\n    if (set_ansi_colors_list(term->tl_vterm, argvars[1].vval.v_list) == FAIL)\n\tEMSG(_(e_invarg));\n}\n#endif\n\n/*\n * \"term_setrestore(buf, command)\" function\n */\n    void\nf_term_setrestore(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n#if defined(FEAT_SESSION)\n    buf_T\t*buf = term_get_buf(argvars, \"term_setrestore()\");\n    term_T\t*term;\n    char_u\t*cmd;\n\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n    vim_free(term->tl_command);\n    cmd = tv_get_string_chk(&argvars[1]);\n    if (cmd != NULL)\n\tterm->tl_command = vim_strsave(cmd);\n    else\n\tterm->tl_command = NULL;\n#endif\n}\n\n/*\n * \"term_setkill(buf, how)\" function\n */\n    void\nf_term_setkill(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_setkill()\");\n    term_T\t*term;\n    char_u\t*how;\n\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n    vim_free(term->tl_kill);\n    how = tv_get_string_chk(&argvars[1]);\n    if (how != NULL)\n\tterm->tl_kill = vim_strsave(how);\n    else\n\tterm->tl_kill = NULL;\n}\n\n/*\n * \"term_start(command, options)\" function\n */\n    void\nf_term_start(typval_T *argvars, typval_T *rettv)\n{\n    jobopt_T\topt;\n    buf_T\t*buf;\n\n    init_job_options(&opt);\n    if (argvars[1].v_type != VAR_UNKNOWN\n\t    && get_job_options(&argvars[1], &opt,\n\t\tJO_TIMEOUT_ALL + JO_STOPONEXIT\n\t\t    + JO_CALLBACK + JO_OUT_CALLBACK + JO_ERR_CALLBACK\n\t\t    + JO_EXIT_CB + JO_CLOSE_CALLBACK + JO_OUT_IO,\n\t\tJO2_TERM_NAME + JO2_TERM_FINISH + JO2_HIDDEN + JO2_TERM_OPENCMD\n\t\t    + JO2_TERM_COLS + JO2_TERM_ROWS + JO2_VERTICAL + JO2_CURWIN\n\t\t    + JO2_CWD + JO2_ENV + JO2_EOF_CHARS\n\t\t    + JO2_NORESTORE + JO2_TERM_KILL\n\t\t    + JO2_ANSI_COLORS) == FAIL)\n\treturn;\n\n    buf = term_start(&argvars[0], NULL, &opt, 0);\n\n    if (buf != NULL && buf->b_term != NULL)\n\trettv->vval.v_number = buf->b_fnum;\n}\n\n/*\n * \"term_wait\" function\n */\n    void\nf_term_wait(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_wait()\");\n\n    if (buf == NULL)\n\treturn;\n    if (buf->b_term->tl_job == NULL)\n    {\n\tch_log(NULL, \"term_wait(): no job to wait for\");\n\treturn;\n    }\n    if (buf->b_term->tl_job->jv_channel == NULL)\n\t/* channel is closed, nothing to do */\n\treturn;\n\n    /* Get the job status, this will detect a job that finished. */\n    if (!buf->b_term->tl_job->jv_channel->ch_keep_open\n\t    && STRCMP(job_status(buf->b_term->tl_job), \"dead\") == 0)\n    {\n\t/* The job is dead, keep reading channel I/O until the channel is\n\t * closed. buf->b_term may become NULL if the terminal was closed while\n\t * waiting. */\n\tch_log(NULL, \"term_wait(): waiting for channel to close\");\n\twhile (buf->b_term != NULL && !buf->b_term->tl_channel_closed)\n\t{\n\t    mch_check_messages();\n\t    parse_queued_messages();\n\t    ui_delay(10L, FALSE);\n\t    if (!buf_valid(buf))\n\t\t/* If the terminal is closed when the channel is closed the\n\t\t * buffer disappears. */\n\t\tbreak;\n\t}\n\tmch_check_messages();\n\tparse_queued_messages();\n    }\n    else\n    {\n\tlong wait = 10L;\n\n\tmch_check_messages();\n\tparse_queued_messages();\n\n\t/* Wait for some time for any channel I/O. */\n\tif (argvars[1].v_type != VAR_UNKNOWN)\n\t    wait = tv_get_number(&argvars[1]);\n\tui_delay(wait, TRUE);\n\tmch_check_messages();\n\n\t/* Flushing messages on channels is hopefully sufficient.\n\t * TODO: is there a better way? */\n\tparse_queued_messages();\n    }\n}\n\n/*\n * Called when a channel has sent all the lines to a terminal.\n * Send a CTRL-D to mark the end of the text.\n */\n    void\nterm_send_eof(channel_T *ch)\n{\n    term_T\t*term;\n\n    for (term = first_term; term != NULL; term = term->tl_next)\n\tif (term->tl_job == ch->ch_job)\n\t{\n\t    if (term->tl_eof_chars != NULL)\n\t    {\n\t\tchannel_send(ch, PART_IN, term->tl_eof_chars,\n\t\t\t\t\t(int)STRLEN(term->tl_eof_chars), NULL);\n\t\tchannel_send(ch, PART_IN, (char_u *)\"\\r\", 1, NULL);\n\t    }\n# ifdef WIN3264\n\t    else\n\t\t/* Default: CTRL-D */\n\t\tchannel_send(ch, PART_IN, (char_u *)\"\\004\\r\", 2, NULL);\n# endif\n\t}\n}\n\n    job_T *\nterm_getjob(term_T *term)\n{\n    return term != NULL ? term->tl_job : NULL;\n}\n\n# if defined(WIN3264) || defined(PROTO)\n\n/**************************************\n * 2. MS-Windows implementation.\n */\n\n#  ifndef PROTO\n\n#define WINPTY_SPAWN_FLAG_AUTO_SHUTDOWN 1ul\n#define WINPTY_SPAWN_FLAG_EXIT_AFTER_SHUTDOWN 2ull\n#define WINPTY_MOUSE_MODE_FORCE\t\t2\n\nvoid* (*winpty_config_new)(UINT64, void*);\nvoid* (*winpty_open)(void*, void*);\nvoid* (*winpty_spawn_config_new)(UINT64, void*, LPCWSTR, void*, void*, void*);\nBOOL (*winpty_spawn)(void*, void*, HANDLE*, HANDLE*, DWORD*, void*);\nvoid (*winpty_config_set_mouse_mode)(void*, int);\nvoid (*winpty_config_set_initial_size)(void*, int, int);\nLPCWSTR (*winpty_conin_name)(void*);\nLPCWSTR (*winpty_conout_name)(void*);\nLPCWSTR (*winpty_conerr_name)(void*);\nvoid (*winpty_free)(void*);\nvoid (*winpty_config_free)(void*);\nvoid (*winpty_spawn_config_free)(void*);\nvoid (*winpty_error_free)(void*);\nLPCWSTR (*winpty_error_msg)(void*);\nBOOL (*winpty_set_size)(void*, int, int, void*);\nHANDLE (*winpty_agent_process)(void*);\n\n#define WINPTY_DLL \"winpty.dll\"\n\nstatic HINSTANCE hWinPtyDLL = NULL;\n#  endif\n\n    static int\ndyn_winpty_init(int verbose)\n{\n    int i;\n    static struct\n    {\n\tchar\t    *name;\n\tFARPROC\t    *ptr;\n    } winpty_entry[] =\n    {\n\t{\"winpty_conerr_name\", (FARPROC*)&winpty_conerr_name},\n\t{\"winpty_config_free\", (FARPROC*)&winpty_config_free},\n\t{\"winpty_config_new\", (FARPROC*)&winpty_config_new},\n\t{\"winpty_config_set_mouse_mode\",\n\t\t\t\t      (FARPROC*)&winpty_config_set_mouse_mode},\n\t{\"winpty_config_set_initial_size\",\n\t\t\t\t    (FARPROC*)&winpty_config_set_initial_size},\n\t{\"winpty_conin_name\", (FARPROC*)&winpty_conin_name},\n\t{\"winpty_conout_name\", (FARPROC*)&winpty_conout_name},\n\t{\"winpty_error_free\", (FARPROC*)&winpty_error_free},\n\t{\"winpty_free\", (FARPROC*)&winpty_free},\n\t{\"winpty_open\", (FARPROC*)&winpty_open},\n\t{\"winpty_spawn\", (FARPROC*)&winpty_spawn},\n\t{\"winpty_spawn_config_free\", (FARPROC*)&winpty_spawn_config_free},\n\t{\"winpty_spawn_config_new\", (FARPROC*)&winpty_spawn_config_new},\n\t{\"winpty_error_msg\", (FARPROC*)&winpty_error_msg},\n\t{\"winpty_set_size\", (FARPROC*)&winpty_set_size},\n\t{\"winpty_agent_process\", (FARPROC*)&winpty_agent_process},\n\t{NULL, NULL}\n    };\n\n    /* No need to initialize twice. */\n    if (hWinPtyDLL)\n\treturn OK;\n    /* Load winpty.dll, prefer using the 'winptydll' option, fall back to just\n     * winpty.dll. */\n    if (*p_winptydll != NUL)\n\thWinPtyDLL = vimLoadLib((char *)p_winptydll);\n    if (!hWinPtyDLL)\n\thWinPtyDLL = vimLoadLib(WINPTY_DLL);\n    if (!hWinPtyDLL)\n    {\n\tif (verbose)\n\t    EMSG2(_(e_loadlib), *p_winptydll != NUL ? p_winptydll\n\t\t\t\t\t\t       : (char_u *)WINPTY_DLL);\n\treturn FAIL;\n    }\n    for (i = 0; winpty_entry[i].name != NULL\n\t\t\t\t\t && winpty_entry[i].ptr != NULL; ++i)\n    {\n\tif ((*winpty_entry[i].ptr = (FARPROC)GetProcAddress(hWinPtyDLL,\n\t\t\t\t\t      winpty_entry[i].name)) == NULL)\n\t{\n\t    if (verbose)\n\t\tEMSG2(_(e_loadfunc), winpty_entry[i].name);\n\t    return FAIL;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Create a new terminal of \"rows\" by \"cols\" cells.\n * Store a reference in \"term\".\n * Return OK or FAIL.\n */\n    static int\nterm_and_job_init(\n\tterm_T\t    *term,\n\ttypval_T    *argvar,\n\tchar\t    **argv UNUSED,\n\tjobopt_T    *opt,\n\tjobopt_T    *orig_opt)\n{\n    WCHAR\t    *cmd_wchar = NULL;\n    WCHAR\t    *cwd_wchar = NULL;\n    WCHAR\t    *env_wchar = NULL;\n    channel_T\t    *channel = NULL;\n    job_T\t    *job = NULL;\n    DWORD\t    error;\n    HANDLE\t    jo = NULL;\n    HANDLE\t    child_process_handle;\n    HANDLE\t    child_thread_handle;\n    void\t    *winpty_err = NULL;\n    void\t    *spawn_config = NULL;\n    garray_T\t    ga_cmd, ga_env;\n    char_u\t    *cmd = NULL;\n\n    if (dyn_winpty_init(TRUE) == FAIL)\n\treturn FAIL;\n    ga_init2(&ga_cmd, (int)sizeof(char*), 20);\n    ga_init2(&ga_env, (int)sizeof(char*), 20);\n\n    if (argvar->v_type == VAR_STRING)\n    {\n\tcmd = argvar->vval.v_string;\n    }\n    else if (argvar->v_type == VAR_LIST)\n    {\n\tif (win32_build_cmd(argvar->vval.v_list, &ga_cmd) == FAIL)\n\t    goto failed;\n\tcmd = ga_cmd.ga_data;\n    }\n    if (cmd == NULL || *cmd == NUL)\n    {\n\tEMSG(_(e_invarg));\n\tgoto failed;\n    }\n\n    cmd_wchar = enc_to_utf16(cmd, NULL);\n    ga_clear(&ga_cmd);\n    if (cmd_wchar == NULL)\n\tgoto failed;\n    if (opt->jo_cwd != NULL)\n\tcwd_wchar = enc_to_utf16(opt->jo_cwd, NULL);\n\n    win32_build_env(opt->jo_env, &ga_env, TRUE);\n    env_wchar = ga_env.ga_data;\n\n    term->tl_winpty_config = winpty_config_new(0, &winpty_err);\n    if (term->tl_winpty_config == NULL)\n\tgoto failed;\n\n    winpty_config_set_mouse_mode(term->tl_winpty_config,\n\t\t\t\t\t\t    WINPTY_MOUSE_MODE_FORCE);\n    winpty_config_set_initial_size(term->tl_winpty_config,\n\t\t\t\t\t\t term->tl_cols, term->tl_rows);\n    term->tl_winpty = winpty_open(term->tl_winpty_config, &winpty_err);\n    if (term->tl_winpty == NULL)\n\tgoto failed;\n\n    spawn_config = winpty_spawn_config_new(\n\t    WINPTY_SPAWN_FLAG_AUTO_SHUTDOWN |\n\t\tWINPTY_SPAWN_FLAG_EXIT_AFTER_SHUTDOWN,\n\t    NULL,\n\t    cmd_wchar,\n\t    cwd_wchar,\n\t    env_wchar,\n\t    &winpty_err);\n    if (spawn_config == NULL)\n\tgoto failed;\n\n    channel = add_channel();\n    if (channel == NULL)\n\tgoto failed;\n\n    job = job_alloc();\n    if (job == NULL)\n\tgoto failed;\n    if (argvar->v_type == VAR_STRING)\n    {\n\tint argc;\n\n\tbuild_argv_from_string(cmd, &job->jv_argv, &argc);\n    }\n    else\n    {\n\tint argc;\n\n\tbuild_argv_from_list(argvar->vval.v_list, &job->jv_argv, &argc);\n    }\n\n    if (opt->jo_set & JO_IN_BUF)\n\tjob->jv_in_buf = buflist_findnr(opt->jo_io_buf[PART_IN]);\n\n    if (!winpty_spawn(term->tl_winpty, spawn_config, &child_process_handle,\n\t    &child_thread_handle, &error, &winpty_err))\n\tgoto failed;\n\n    channel_set_pipes(channel,\n\t(sock_T)CreateFileW(\n\t    winpty_conin_name(term->tl_winpty),\n\t    GENERIC_WRITE, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL),\n\t(sock_T)CreateFileW(\n\t    winpty_conout_name(term->tl_winpty),\n\t    GENERIC_READ, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL),\n\t(sock_T)CreateFileW(\n\t    winpty_conerr_name(term->tl_winpty),\n\t    GENERIC_READ, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL));\n\n    /* Write lines with CR instead of NL. */\n    channel->ch_write_text_mode = TRUE;\n\n    jo = CreateJobObject(NULL, NULL);\n    if (jo == NULL)\n\tgoto failed;\n\n    if (!AssignProcessToJobObject(jo, child_process_handle))\n    {\n\t/* Failed, switch the way to terminate process with TerminateProcess. */\n\tCloseHandle(jo);\n\tjo = NULL;\n    }\n\n    winpty_spawn_config_free(spawn_config);\n    vim_free(cmd_wchar);\n    vim_free(cwd_wchar);\n    vim_free(env_wchar);\n\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (opt->jo_set2 & JO2_ANSI_COLORS)\n\tset_vterm_palette(term->tl_vterm, opt->jo_ansi_colors);\n    else\n\tinit_vterm_ansi_colors(term->tl_vterm);\n#endif\n\n    channel_set_job(channel, job, opt);\n    job_set_options(job, opt);\n\n    job->jv_channel = channel;\n    job->jv_proc_info.hProcess = child_process_handle;\n    job->jv_proc_info.dwProcessId = GetProcessId(child_process_handle);\n    job->jv_job_object = jo;\n    job->jv_status = JOB_STARTED;\n    job->jv_tty_in = utf16_to_enc(\n\t    (short_u*)winpty_conin_name(term->tl_winpty), NULL);\n    job->jv_tty_out = utf16_to_enc(\n\t    (short_u*)winpty_conout_name(term->tl_winpty), NULL);\n    ++job->jv_refcount;\n    term->tl_job = job;\n\n    /* Redirecting stdout and stderr doesn't work at the job level.  Instead\n     * open the file here and handle it in.  opt->jo_io was changed in\n     * setup_job_options(), use the original flags here. */\n    if (orig_opt->jo_io[PART_OUT] == JIO_FILE)\n    {\n\tchar_u *fname = opt->jo_io_name[PART_OUT];\n\n\tch_log(channel, \"Opening output file %s\", fname);\n\tterm->tl_out_fd = mch_fopen((char *)fname, WRITEBIN);\n\tif (term->tl_out_fd == NULL)\n\t    EMSG2(_(e_notopen), fname);\n    }\n\n    return OK;\n\nfailed:\n    ga_clear(&ga_cmd);\n    ga_clear(&ga_env);\n    vim_free(cmd_wchar);\n    vim_free(cwd_wchar);\n    if (spawn_config != NULL)\n\twinpty_spawn_config_free(spawn_config);\n    if (channel != NULL)\n\tchannel_clear(channel);\n    if (job != NULL)\n    {\n\tjob->jv_channel = NULL;\n\tjob_cleanup(job);\n    }\n    term->tl_job = NULL;\n    if (jo != NULL)\n\tCloseHandle(jo);\n    if (term->tl_winpty != NULL)\n\twinpty_free(term->tl_winpty);\n    term->tl_winpty = NULL;\n    if (term->tl_winpty_config != NULL)\n\twinpty_config_free(term->tl_winpty_config);\n    term->tl_winpty_config = NULL;\n    if (winpty_err != NULL)\n    {\n\tchar_u *msg = utf16_to_enc(\n\t\t\t\t(short_u *)winpty_error_msg(winpty_err), NULL);\n\n\tEMSG(msg);\n\twinpty_error_free(winpty_err);\n    }\n    return FAIL;\n}\n\n    static int\ncreate_pty_only(term_T *term, jobopt_T *options)\n{\n    HANDLE\t    hPipeIn = INVALID_HANDLE_VALUE;\n    HANDLE\t    hPipeOut = INVALID_HANDLE_VALUE;\n    char\t    in_name[80], out_name[80];\n    channel_T\t    *channel = NULL;\n\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n    vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeIn = CreateNamedPipe(in_name, PIPE_ACCESS_OUTBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, NMPWAIT_NOWAIT, NULL);\n    if (hPipeIn == INVALID_HANDLE_VALUE)\n\tgoto failed;\n\n    vim_snprintf(out_name, sizeof(out_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-out-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeOut = CreateNamedPipe(out_name, PIPE_ACCESS_INBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, 0, NULL);\n    if (hPipeOut == INVALID_HANDLE_VALUE)\n\tgoto failed;\n\n    ConnectNamedPipe(hPipeIn, NULL);\n    ConnectNamedPipe(hPipeOut, NULL);\n\n    term->tl_job = job_alloc();\n    if (term->tl_job == NULL)\n\tgoto failed;\n    ++term->tl_job->jv_refcount;\n\n    /* behave like the job is already finished */\n    term->tl_job->jv_status = JOB_FINISHED;\n\n    channel = add_channel();\n    if (channel == NULL)\n\tgoto failed;\n    term->tl_job->jv_channel = channel;\n    channel->ch_keep_open = TRUE;\n    channel->ch_named_pipe = TRUE;\n\n    channel_set_pipes(channel,\n\t(sock_T)hPipeIn,\n\t(sock_T)hPipeOut,\n\t(sock_T)hPipeOut);\n    channel_set_job(channel, term->tl_job, options);\n    term->tl_job->jv_tty_in = vim_strsave((char_u*)in_name);\n    term->tl_job->jv_tty_out = vim_strsave((char_u*)out_name);\n\n    return OK;\n\nfailed:\n    if (hPipeIn != NULL)\n\tCloseHandle(hPipeIn);\n    if (hPipeOut != NULL)\n\tCloseHandle(hPipeOut);\n    return FAIL;\n}\n\n/*\n * Free the terminal emulator part of \"term\".\n */\n    static void\nterm_free_vterm(term_T *term)\n{\n    if (term->tl_winpty != NULL)\n\twinpty_free(term->tl_winpty);\n    term->tl_winpty = NULL;\n    if (term->tl_winpty_config != NULL)\n\twinpty_config_free(term->tl_winpty_config);\n    term->tl_winpty_config = NULL;\n    if (term->tl_vterm != NULL)\n\tvterm_free(term->tl_vterm);\n    term->tl_vterm = NULL;\n}\n\n/*\n * Report the size to the terminal.\n */\n    static void\nterm_report_winsize(term_T *term, int rows, int cols)\n{\n    if (term->tl_winpty)\n\twinpty_set_size(term->tl_winpty, cols, rows, NULL);\n}\n\n    int\nterminal_enabled(void)\n{\n    return dyn_winpty_init(FALSE) == OK;\n}\n\n# else\n\n/**************************************\n * 3. Unix-like implementation.\n */\n\n/*\n * Create a new terminal of \"rows\" by \"cols\" cells.\n * Start job for \"cmd\".\n * Store the pointers in \"term\".\n * When \"argv\" is not NULL then \"argvar\" is not used.\n * Return OK or FAIL.\n */\n    static int\nterm_and_job_init(\n\tterm_T\t    *term,\n\ttypval_T    *argvar,\n\tchar\t    **argv,\n\tjobopt_T    *opt,\n\tjobopt_T    *orig_opt UNUSED)\n{\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (opt->jo_set2 & JO2_ANSI_COLORS)\n\tset_vterm_palette(term->tl_vterm, opt->jo_ansi_colors);\n    else\n\tinit_vterm_ansi_colors(term->tl_vterm);\n#endif\n\n    /* This may change a string in \"argvar\". */\n    term->tl_job = job_start(argvar, argv, opt, TRUE);\n    if (term->tl_job != NULL)\n\t++term->tl_job->jv_refcount;\n\n    return term->tl_job != NULL\n\t&& term->tl_job->jv_channel != NULL\n\t&& term->tl_job->jv_status != JOB_FAILED ? OK : FAIL;\n}\n\n    static int\ncreate_pty_only(term_T *term, jobopt_T *opt)\n{\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n    term->tl_job = job_alloc();\n    if (term->tl_job == NULL)\n\treturn FAIL;\n    ++term->tl_job->jv_refcount;\n\n    /* behave like the job is already finished */\n    term->tl_job->jv_status = JOB_FINISHED;\n\n    return mch_create_pty_channel(term->tl_job, opt);\n}\n\n/*\n * Free the terminal emulator part of \"term\".\n */\n    static void\nterm_free_vterm(term_T *term)\n{\n    if (term->tl_vterm != NULL)\n\tvterm_free(term->tl_vterm);\n    term->tl_vterm = NULL;\n}\n\n/*\n * Report the size to the terminal.\n */\n    static void\nterm_report_winsize(term_T *term, int rows, int cols)\n{\n    /* Use an ioctl() to report the new window size to the job. */\n    if (term->tl_job != NULL && term->tl_job->jv_channel != NULL)\n    {\n\tint fd = -1;\n\tint part;\n\n\tfor (part = PART_OUT; part < PART_COUNT; ++part)\n\t{\n\t    fd = term->tl_job->jv_channel->ch_part[part].ch_fd;\n\t    if (isatty(fd))\n\t\tbreak;\n\t}\n\tif (part < PART_COUNT && mch_report_winsize(fd, rows, cols) == OK)\n\t    mch_signal_job(term->tl_job, (char_u *)\"winch\");\n    }\n}\n\n# endif\n\n#endif /* FEAT_TERMINAL */\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#ifdef AMIGA\n# include <time.h>\t/* for time() */\n#endif\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't catenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n    strcat(longVersion, \")\");\n}\n\n# else\n    void\ninit_longVersion(void)\n{\n    char *date_time = __DATE__ \" \" __TIME__;\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t\t+ strlen(date_time);\n\n    longVersion = (char *)alloc((unsigned)len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t/* only for Amiga systems */\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n#ifdef FEAT_CMDL_COMPL\n\t\"+cmdline_compl\",\n#else\n\t\"-cmdline_compl\",\n#endif\n#ifdef FEAT_CMDHIST\n\t\"+cmdline_hist\",\n#else\n\t\"-cmdline_hist\",\n#endif\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n#ifdef FEAT_COMMENTS\n\t\"+comments\",\n#else\n\t\"-comments\",\n#endif\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_W32\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n#ifdef FEAT_FKMAP\n\t\"+farsi\",\n#else\n\t\"-farsi\",\n#endif\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    /* only interesting on Unix systems */\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n#ifdef FEAT_HANGULIN\n\t\"+hangul_input\",\n#else\n\t\"-hangul_input\",\n#endif\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n#ifdef FEAT_INS_EXPAND\n\t\"+insert_expand\",\n#else\n\t\"-insert_expand\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n#ifdef FEAT_LOCALMAP\n\t\"+localmap\",\n#else\n\t\"-localmap\",\n#endif\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n#ifdef FEAT_MODIFY_FNAME\n\t\"+modify_fname\",\n#else\n\t\"-modify_fname\",\n#endif\n#ifdef FEAT_MOUSE\n\t\"+mouse\",\n#  ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#  else\n\t\"-mouseshape\",\n#  endif\n# else\n\t\"-mouse\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_SGR\n\t\"+mouse_sgr\",\n# else\n\t\"-mouse_sgr\",\n# endif\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_xterm\",\n# else\n\t\"-mouse_xterm\",\n# endif\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n# ifdef FEAT_MBYTE\n\t\"+multi_byte\",\n# else\n\t\"-multi_byte\",\n# endif\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n#ifdef FEAT_NUM64\n\t\"+num64\",\n#else\n\t\"-num64\",\n#endif\n#ifdef FEAT_GUI_W32\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n#ifdef FEAT_SUN_WORKSHOP\n\t\"+sun_workshop\",\n#else\n\t\"-sun_workshop\",\n#endif\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    /* only interesting on Unix systems */\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n#ifdef FEAT_TAG_OLDSTATIC\n\t\"+tag_old_static\",\n#else\n\t\"-tag_old_static\",\n#endif\n#ifdef FEAT_TAG_ANYWHITE\n\t\"+tag_any_white\",\n#else\n\t\"-tag_any_white\",\n#endif\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n/* only Unix can have terminfo instead of termcap */\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_TEXT_PROP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n/* unix always includes termcap support */\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n#ifdef FEAT_USR_CMDS\n\t\"+user_commands\",\n#else\n\t\"-user_commands\",\n#endif\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n#ifdef FEAT_VIRTUALEDIT\n\t\"+virtualedit\",\n#else\n\t\"-virtualedit\",\n#endif\n\t\"+visual\",\n#ifdef FEAT_VISUALEXTRA\n\t\"+visualextra\",\n#else\n\t\"-visualextra\",\n#endif\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef WIN3264\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef WIN3264\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    int\t\ti;\n    int\t\th = 0;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] > h)\n\t    h = included_patches[i];\n    return h;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\ti;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] == n)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = (int)vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    MSG_PUTS(\"[\");\n\tMSG_PUTS(s);\n\tif (wrap)\n\t    MSG_PUTS(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n\n    /* Find the length of the longest item, use that + 1 as the column\n     * width. */\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = (int)vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t/* Not enough screen columns - show one per line */\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    /* The rightmost column doesn't need a separator.\n     * Sacrifice it to fit in one more column if possible. */\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    /* i counts columns then rows.  idx counts rows then columns. */\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n\t    msg_puts(items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0)\n\t\t    msg_putchar('\\n');\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    MSG(longVersion);\n#ifdef WIN3264\n# ifdef FEAT_GUI_W32\n#  ifdef _WIN64\n    MSG_PUTS(_(\"\\nMS-Windows 64-bit GUI version\"));\n#  else\n    MSG_PUTS(_(\"\\nMS-Windows 32-bit GUI version\"));\n#  endif\n# ifdef FEAT_OLE\n    MSG_PUTS(_(\" with OLE support\"));\n# endif\n# else\n#  ifdef _WIN64\n    MSG_PUTS(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    MSG_PUTS(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    MSG_PUTS(_(\"\\nmacOS version\"));\n# else\n    MSG_PUTS(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n#endif\n\n#ifdef VMS\n    MSG_PUTS(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tMSG_PUTS(\" - \");\n\tMSG_PUTS(compiled_arch);\n    }\n# endif\n\n#endif\n\n    /* Print the list of patch numbers if there is at least one. */\n    /* Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\" */\n    if (included_patches[0] != 0)\n    {\n\tMSG_PUTS(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\t/* find last one */\n\tfor (i = 0; included_patches[i] != 0; ++i)\n\t    ;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tMSG_PUTS(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    MSG_PUTS(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    /* Print the list of extra patch descriptions if there is at least one. */\n    if (extra_patches[0] != NULL)\n    {\n\tMSG_PUTS(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    MSG_PUTS(s);\n\t    s = \", \";\n\t    MSG_PUTS(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    MSG_PUTS(\"\\n\");\n    MSG_PUTS(_(\"Modified by \"));\n    MSG_PUTS(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tMSG_PUTS(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    MSG_PUTS(_(\"by \"));\n\t    MSG_PUTS(compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    MSG_PUTS(\"@\");\n\t    MSG_PUTS(compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    MSG_PUTS(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    MSG_PUTS(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    MSG_PUTS(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    MSG_PUTS(_(\"\\nSmall version \"));\n#   else\n    MSG_PUTS(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    MSG_PUTS(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    MSG_PUTS(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     MSG_PUTS(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     MSG_PUTS(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    MSG_PUTS(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    MSG_PUTS(_(\"with X11-neXtaw GUI.\"));\n#    else\n    MSG_PUTS(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#     ifdef FEAT_GUI_PHOTON\n    MSG_PUTS(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    MSG_PUTS(_(\"with GUI.\"));\n#      else\n#\tif defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON\n    MSG_PUTS(_(\"with Carbon GUI.\"));\n#\telse\n#\t if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX\n    MSG_PUTS(_(\"with Cocoa GUI.\"));\n#\t else\n#\t endif\n#\tendif\n#      endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    void\nintro_message(\n    int\t\tcolon)\t\t/* TRUE for \":intro\" */\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    /* blanklines = screen height - # message lines */\n    blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);\n    if (!p_cp)\n\tblanklines += 4;  /* add 4 for not showing \"Vi compatible\" message */\n\n    /* Don't overwrite a statusline.  Depends on 'cmdheight'. */\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    /* Show the sponsor and register message one out of four times, the Uganda\n     * message two out of four times. */\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    /* start displaying the message lines after half of the blank lines */\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)(sizeof(lines) / sizeof(char *)); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    /* Make the wait-return message appear just below the text. */\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    /* Center the message horizontally. */\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    /* Check for 9.9x or 9.9xx, alpha/beta version */\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    /* Split up in parts to highlight <> items differently. */\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n#ifdef FEAT_MBYTE\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n#endif\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    /* Add the version number to the version line. */\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["#include \"vterm_internal.h\"\n\n#include <stdio.h>\n#include <string.h>\n\n#define strneq(a,b,n) (strncmp(a,b,n)==0)\n\n#if defined(DEBUG) && DEBUG > 1\n# define DEBUG_GLYPH_COMBINE\n#endif\n\nstatic int on_resize(int rows, int cols, void *user);\n\n/* Some convenient wrappers to make callback functions easier */\n\nstatic void putglyph(VTermState *state, const uint32_t chars[], int width, VTermPos pos)\n{\n  VTermGlyphInfo info;\n  info.chars = chars;\n  info.width = width;\n  info.protected_cell = state->protected_cell;\n  info.dwl = state->lineinfo[pos.row].doublewidth;\n  info.dhl = state->lineinfo[pos.row].doubleheight;\n\n  if(state->callbacks && state->callbacks->putglyph)\n    if((*state->callbacks->putglyph)(&info, pos, state->cbdata))\n      return;\n\n  DEBUG_LOG3(\"libvterm: Unhandled putglyph U+%04x at (%d,%d)\\n\", chars[0], pos.col, pos.row);\n}\n\nstatic void updatecursor(VTermState *state, VTermPos *oldpos, int cancel_phantom)\n{\n  if(state->pos.col == oldpos->col && state->pos.row == oldpos->row)\n    return;\n\n  if(cancel_phantom)\n    state->at_phantom = 0;\n\n  if(state->callbacks && state->callbacks->movecursor)\n    if((*state->callbacks->movecursor)(state->pos, *oldpos, state->mode.cursor_visible, state->cbdata))\n      return;\n}\n\nstatic void erase(VTermState *state, VTermRect rect, int selective)\n{\n  if(state->callbacks && state->callbacks->erase)\n    if((*state->callbacks->erase)(rect, selective, state->cbdata))\n      return;\n}\n\nstatic VTermState *vterm_state_new(VTerm *vt)\n{\n  VTermState *state = vterm_allocator_malloc(vt, sizeof(VTermState));\n\n  if (state == NULL)\n    return NULL;\n  state->vt = vt;\n\n  state->rows = vt->rows;\n  state->cols = vt->cols;\n\n  state->mouse_col     = 0;\n  state->mouse_row     = 0;\n  state->mouse_buttons = 0;\n\n  state->mouse_protocol = MOUSE_X10;\n\n  state->callbacks = NULL;\n  state->cbdata    = NULL;\n\n  vterm_state_newpen(state);\n\n  state->bold_is_highbright = 0;\n\n  return state;\n}\n\nINTERNAL void vterm_state_free(VTermState *state)\n{\n  vterm_allocator_free(state->vt, state->tabstops);\n  vterm_allocator_free(state->vt, state->lineinfo);\n  vterm_allocator_free(state->vt, state->combine_chars);\n  vterm_allocator_free(state->vt, state);\n}\n\nstatic void scroll(VTermState *state, VTermRect rect, int downward, int rightward)\n{\n  int rows;\n  int cols;\n  if(!downward && !rightward)\n    return;\n\n  rows = rect.end_row - rect.start_row;\n  if(downward > rows)\n    downward = rows;\n  else if(downward < -rows)\n    downward = -rows;\n\n  cols = rect.end_col - rect.start_col;\n  if(rightward > cols)\n    rightward = cols;\n  else if(rightward < -cols)\n    rightward = -cols;\n\n  // Update lineinfo if full line\n  if(rect.start_col == 0 && rect.end_col == state->cols && rightward == 0) {\n    int height = rect.end_row - rect.start_row - abs(downward);\n\n    if(downward > 0)\n      memmove(state->lineinfo + rect.start_row,\n              state->lineinfo + rect.start_row + downward,\n              height * sizeof(state->lineinfo[0]));\n    else\n      memmove(state->lineinfo + rect.start_row - downward,\n              state->lineinfo + rect.start_row,\n              height * sizeof(state->lineinfo[0]));\n  }\n\n  if(state->callbacks && state->callbacks->scrollrect)\n    if((*state->callbacks->scrollrect)(rect, downward, rightward, state->cbdata))\n      return;\n\n  if(state->callbacks)\n    vterm_scroll_rect(rect, downward, rightward,\n        state->callbacks->moverect, state->callbacks->erase, state->cbdata);\n}\n\nstatic void linefeed(VTermState *state)\n{\n  if(state->pos.row == SCROLLREGION_BOTTOM(state) - 1) {\n    VTermRect rect;\n    rect.start_row = state->scrollregion_top;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = SCROLLREGION_LEFT(state);\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, 1, 0);\n  }\n  else if(state->pos.row < state->rows-1)\n    state->pos.row++;\n}\n\nstatic void grow_combine_buffer(VTermState *state)\n{\n  size_t    new_size = state->combine_chars_size * 2;\n  uint32_t *new_chars = vterm_allocator_malloc(state->vt, new_size * sizeof(new_chars[0]));\n\n  memcpy(new_chars, state->combine_chars, state->combine_chars_size * sizeof(new_chars[0]));\n\n  vterm_allocator_free(state->vt, state->combine_chars);\n\n  state->combine_chars = new_chars;\n  state->combine_chars_size = new_size;\n}\n\nstatic void set_col_tabstop(VTermState *state, int col)\n{\n  unsigned char mask = 1 << (col & 7);\n  state->tabstops[col >> 3] |= mask;\n}\n\nstatic void clear_col_tabstop(VTermState *state, int col)\n{\n  unsigned char mask = 1 << (col & 7);\n  state->tabstops[col >> 3] &= ~mask;\n}\n\nstatic int is_col_tabstop(VTermState *state, int col)\n{\n  unsigned char mask = 1 << (col & 7);\n  return state->tabstops[col >> 3] & mask;\n}\n\nstatic int is_cursor_in_scrollregion(const VTermState *state)\n{\n  if(state->pos.row < state->scrollregion_top ||\n     state->pos.row >= SCROLLREGION_BOTTOM(state))\n    return 0;\n  if(state->pos.col < SCROLLREGION_LEFT(state) ||\n     state->pos.col >= SCROLLREGION_RIGHT(state))\n    return 0;\n\n  return 1;\n}\n\nstatic void tab(VTermState *state, int count, int direction)\n{\n  while(count > 0) {\n    if(direction > 0) {\n      if(state->pos.col >= THISROWWIDTH(state)-1)\n        return;\n\n      state->pos.col++;\n    }\n    else if(direction < 0) {\n      if(state->pos.col < 1)\n        return;\n\n      state->pos.col--;\n    }\n\n    if(is_col_tabstop(state, state->pos.col))\n      count--;\n  }\n}\n\n#define NO_FORCE 0\n#define FORCE    1\n\n#define DWL_OFF 0\n#define DWL_ON  1\n\n#define DHL_OFF    0\n#define DHL_TOP    1\n#define DHL_BOTTOM 2\n\nstatic void set_lineinfo(VTermState *state, int row, int force, int dwl, int dhl)\n{\n  VTermLineInfo info = state->lineinfo[row];\n\n  if(dwl == DWL_OFF)\n    info.doublewidth = DWL_OFF;\n  else if(dwl == DWL_ON)\n    info.doublewidth = DWL_ON;\n  // else -1 to ignore\n\n  if(dhl == DHL_OFF)\n    info.doubleheight = DHL_OFF;\n  else if(dhl == DHL_TOP)\n    info.doubleheight = DHL_TOP;\n  else if(dhl == DHL_BOTTOM)\n    info.doubleheight = DHL_BOTTOM;\n\n  if((state->callbacks &&\n      state->callbacks->setlineinfo &&\n      (*state->callbacks->setlineinfo)(row, &info, state->lineinfo + row, state->cbdata))\n      || force)\n    state->lineinfo[row] = info;\n}\n\nstatic int on_text(const char bytes[], size_t len, void *user)\n{\n  VTermState *state = user;\n  uint32_t *codepoints;\n  int npoints = 0;\n  size_t eaten = 0;\n  VTermEncodingInstance *encoding;\n  int i = 0;\n\n  VTermPos oldpos = state->pos;\n\n  // We'll have at most len codepoints, plus one from a previous incomplete\n  // sequence.\n  codepoints = vterm_allocator_malloc(state->vt, (len + 1) * sizeof(uint32_t));\n\n  encoding =\n    state->gsingle_set     ? &state->encoding[state->gsingle_set] :\n    !(bytes[eaten] & 0x80) ? &state->encoding[state->gl_set] :\n    state->vt->mode.utf8   ? &state->encoding_utf8 :\n                             &state->encoding[state->gr_set];\n\n  (*encoding->enc->decode)(encoding->enc, encoding->data,\n      codepoints, &npoints, state->gsingle_set ? 1 : (int)len,\n      bytes, &eaten, len);\n\n  /* There's a chance an encoding (e.g. UTF-8) hasn't found enough bytes yet\n   * for even a single codepoint\n   */\n  if(!npoints)\n  {\n    vterm_allocator_free(state->vt, codepoints);\n    return (int)eaten;\n  }\n\n  if(state->gsingle_set && npoints)\n    state->gsingle_set = 0;\n\n  /* This is a combining char. that needs to be merged with the previous\n   * glyph output */\n  if(vterm_unicode_is_combining(codepoints[i])) {\n    /* See if the cursor has moved since */\n    if(state->pos.row == state->combine_pos.row && state->pos.col == state->combine_pos.col + state->combine_width) {\n#ifdef DEBUG_GLYPH_COMBINE\n      int printpos;\n      printf(\"DEBUG: COMBINING SPLIT GLYPH of chars {\");\n      for(printpos = 0; state->combine_chars[printpos]; printpos++)\n        printf(\"U+%04x \", state->combine_chars[printpos]);\n      printf(\"} + {\");\n#endif\n\n      /* Find where we need to append these combining chars */\n      int saved_i = 0;\n      while(state->combine_chars[saved_i])\n        saved_i++;\n\n      /* Add extra ones */\n      while(i < npoints && vterm_unicode_is_combining(codepoints[i])) {\n        if(saved_i >= (int)state->combine_chars_size)\n          grow_combine_buffer(state);\n        state->combine_chars[saved_i++] = codepoints[i++];\n      }\n      if(saved_i >= (int)state->combine_chars_size)\n        grow_combine_buffer(state);\n      state->combine_chars[saved_i] = 0;\n\n#ifdef DEBUG_GLYPH_COMBINE\n      for(; state->combine_chars[printpos]; printpos++)\n        printf(\"U+%04x \", state->combine_chars[printpos]);\n      printf(\"}\\n\");\n#endif\n\n      /* Now render it */\n      putglyph(state, state->combine_chars, state->combine_width, state->combine_pos);\n    }\n    else {\n      DEBUG_LOG(\"libvterm: TODO: Skip over split char+combining\\n\");\n    }\n  }\n\n  for(; i < npoints; i++) {\n    // Try to find combining characters following this\n    int glyph_starts = i;\n    int glyph_ends;\n    int width = 0;\n    uint32_t *chars;\n\n    for(glyph_ends = i + 1; glyph_ends < npoints; glyph_ends++)\n      if(!vterm_unicode_is_combining(codepoints[glyph_ends]))\n        break;\n\n    chars = vterm_allocator_malloc(state->vt, (glyph_ends - glyph_starts + 1) * sizeof(uint32_t));\n\n    for( ; i < glyph_ends; i++) {\n      int this_width;\n      chars[i - glyph_starts] = codepoints[i];\n      this_width = vterm_unicode_width(codepoints[i]);\n#ifdef DEBUG\n      if(this_width < 0) {\n        fprintf(stderr, \"Text with negative-width codepoint U+%04x\\n\", codepoints[i]);\n        abort();\n      }\n#endif\n      width += this_width;\n    }\n\n    chars[glyph_ends - glyph_starts] = 0;\n    i--;\n\n#ifdef DEBUG_GLYPH_COMBINE\n    int printpos;\n    printf(\"DEBUG: COMBINED GLYPH of %d chars {\", glyph_ends - glyph_starts);\n    for(printpos = 0; printpos < glyph_ends - glyph_starts; printpos++)\n      printf(\"U+%04x \", chars[printpos]);\n    printf(\"}, onscreen width %d\\n\", width);\n#endif\n\n    if(state->at_phantom || state->pos.col + width > THISROWWIDTH(state)) {\n      linefeed(state);\n      state->pos.col = 0;\n      state->at_phantom = 0;\n    }\n\n    if(state->mode.insert) {\n      /* TODO: This will be a little inefficient for large bodies of text, as\n       * it'll have to 'ICH' effectively before every glyph. We should scan\n       * ahead and ICH as many times as required\n       */\n      VTermRect rect;\n      rect.start_row = state->pos.row;\n      rect.end_row   = state->pos.row + 1;\n      rect.start_col = state->pos.col;\n      rect.end_col   = THISROWWIDTH(state);\n      scroll(state, rect, 0, -1);\n    }\n\n    putglyph(state, chars, width, state->pos);\n\n    if(i == npoints - 1) {\n      /* End of the buffer. Save the chars in case we have to combine with\n       * more on the next call */\n      int save_i;\n      for(save_i = 0; chars[save_i]; save_i++) {\n        if(save_i >= (int)state->combine_chars_size)\n          grow_combine_buffer(state);\n        state->combine_chars[save_i] = chars[save_i];\n      }\n      if(save_i >= (int)state->combine_chars_size)\n        grow_combine_buffer(state);\n      state->combine_chars[save_i] = 0;\n      state->combine_width = width;\n      state->combine_pos = state->pos;\n    }\n\n    if(state->pos.col + width >= THISROWWIDTH(state)) {\n      if(state->mode.autowrap)\n        state->at_phantom = 1;\n    }\n    else {\n      state->pos.col += width;\n    }\n    vterm_allocator_free(state->vt, chars);\n  }\n\n  updatecursor(state, &oldpos, 0);\n\n#ifdef DEBUG\n  if(state->pos.row < 0 || state->pos.row >= state->rows ||\n     state->pos.col < 0 || state->pos.col >= state->cols) {\n    fprintf(stderr, \"Position out of bounds after text: (%d,%d)\\n\",\n        state->pos.row, state->pos.col);\n    abort();\n  }\n#endif\n\n  vterm_allocator_free(state->vt, codepoints);\n  return (int)eaten;\n}\n\nstatic int on_control(unsigned char control, void *user)\n{\n  VTermState *state = user;\n\n  VTermPos oldpos = state->pos;\n\n  switch(control) {\n  case 0x07: // BEL - ECMA-48 8.3.3\n    if(state->callbacks && state->callbacks->bell)\n      (*state->callbacks->bell)(state->cbdata);\n    break;\n\n  case 0x08: // BS - ECMA-48 8.3.5\n    if(state->pos.col > 0)\n      state->pos.col--;\n    break;\n\n  case 0x09: // HT - ECMA-48 8.3.60\n    tab(state, 1, +1);\n    break;\n\n  case 0x0a: // LF - ECMA-48 8.3.74\n  case 0x0b: // VT\n  case 0x0c: // FF\n    linefeed(state);\n    if(state->mode.newline)\n      state->pos.col = 0;\n    break;\n\n  case 0x0d: // CR - ECMA-48 8.3.15\n    state->pos.col = 0;\n    break;\n\n  case 0x0e: // LS1 - ECMA-48 8.3.76\n    state->gl_set = 1;\n    break;\n\n  case 0x0f: // LS0 - ECMA-48 8.3.75\n    state->gl_set = 0;\n    break;\n\n  case 0x84: // IND - DEPRECATED but implemented for completeness\n    linefeed(state);\n    break;\n\n  case 0x85: // NEL - ECMA-48 8.3.86\n    linefeed(state);\n    state->pos.col = 0;\n    break;\n\n  case 0x88: // HTS - ECMA-48 8.3.62\n    set_col_tabstop(state, state->pos.col);\n    break;\n\n  case 0x8d: // RI - ECMA-48 8.3.104\n    if(state->pos.row == state->scrollregion_top) {\n      VTermRect rect;\n      rect.start_row = state->scrollregion_top;\n      rect.end_row   = SCROLLREGION_BOTTOM(state);\n      rect.start_col = SCROLLREGION_LEFT(state);\n      rect.end_col   = SCROLLREGION_RIGHT(state);\n\n      scroll(state, rect, -1, 0);\n    }\n    else if(state->pos.row > 0)\n        state->pos.row--;\n    break;\n\n  case 0x8e: // SS2 - ECMA-48 8.3.141\n    state->gsingle_set = 2;\n    break;\n\n  case 0x8f: // SS3 - ECMA-48 8.3.142\n    state->gsingle_set = 3;\n    break;\n\n  default:\n    if(state->fallbacks && state->fallbacks->control)\n      if((*state->fallbacks->control)(control, state->fbdata))\n        return 1;\n\n    return 0;\n  }\n\n  updatecursor(state, &oldpos, 1);\n\n#ifdef DEBUG\n  if(state->pos.row < 0 || state->pos.row >= state->rows ||\n     state->pos.col < 0 || state->pos.col >= state->cols) {\n    fprintf(stderr, \"Position out of bounds after Ctrl %02x: (%d,%d)\\n\",\n        control, state->pos.row, state->pos.col);\n    abort();\n  }\n#endif\n\n  return 1;\n}\n\nstatic int settermprop_bool(VTermState *state, VTermProp prop, int v)\n{\n  VTermValue val;\n  val.boolean = v;\n  return vterm_state_set_termprop(state, prop, &val);\n}\n\nstatic int settermprop_int(VTermState *state, VTermProp prop, int v)\n{\n  VTermValue val;\n  val.number = v;\n  return vterm_state_set_termprop(state, prop, &val);\n}\n\nstatic int settermprop_string(VTermState *state, VTermProp prop, const char *str, size_t len)\n{\n  char *strvalue;\n  int r;\n  VTermValue val;\n  strvalue = vterm_allocator_malloc(state->vt, (len+1) * sizeof(char));\n  strncpy(strvalue, str, len);\n  strvalue[len] = 0;\n\n  val.string = strvalue;\n  r = vterm_state_set_termprop(state, prop, &val);\n  vterm_allocator_free(state->vt, strvalue);\n  return r;\n}\n\nstatic void savecursor(VTermState *state, int save)\n{\n  if(save) {\n    state->saved.pos = state->pos;\n    state->saved.mode.cursor_visible = state->mode.cursor_visible;\n    state->saved.mode.cursor_blink   = state->mode.cursor_blink;\n    state->saved.mode.cursor_shape   = state->mode.cursor_shape;\n\n    vterm_state_savepen(state, 1);\n  }\n  else {\n    VTermPos oldpos = state->pos;\n\n    state->pos = state->saved.pos;\n\n    settermprop_bool(state, VTERM_PROP_CURSORVISIBLE, state->saved.mode.cursor_visible);\n    settermprop_bool(state, VTERM_PROP_CURSORBLINK,   state->saved.mode.cursor_blink);\n    settermprop_int (state, VTERM_PROP_CURSORSHAPE,   state->saved.mode.cursor_shape);\n\n    vterm_state_savepen(state, 0);\n\n    updatecursor(state, &oldpos, 1);\n  }\n}\n\nstatic int on_escape(const char *bytes, size_t len, void *user)\n{\n  VTermState *state = user;\n\n  /* Easier to decode this from the first byte, even though the final\n   * byte terminates it\n   */\n  switch(bytes[0]) {\n  case ' ':\n    if(len != 2)\n      return 0;\n\n    switch(bytes[1]) {\n      case 'F': // S7C1T\n        state->vt->mode.ctrl8bit = 0;\n        break;\n\n      case 'G': // S8C1T\n        state->vt->mode.ctrl8bit = 1;\n        break;\n\n      default:\n        return 0;\n    }\n    return 2;\n\n  case '#':\n    if(len != 2)\n      return 0;\n\n    switch(bytes[1]) {\n      case '3': // DECDHL top\n        if(state->mode.leftrightmargin)\n          break;\n        set_lineinfo(state, state->pos.row, NO_FORCE, DWL_ON, DHL_TOP);\n        break;\n\n      case '4': // DECDHL bottom\n        if(state->mode.leftrightmargin)\n          break;\n        set_lineinfo(state, state->pos.row, NO_FORCE, DWL_ON, DHL_BOTTOM);\n        break;\n\n      case '5': // DECSWL\n        if(state->mode.leftrightmargin)\n          break;\n        set_lineinfo(state, state->pos.row, NO_FORCE, DWL_OFF, DHL_OFF);\n        break;\n\n      case '6': // DECDWL\n        if(state->mode.leftrightmargin)\n          break;\n        set_lineinfo(state, state->pos.row, NO_FORCE, DWL_ON, DHL_OFF);\n        break;\n\n      case '8': // DECALN\n      {\n        VTermPos pos;\n        uint32_t E[] = { 'E', 0 };\n        for(pos.row = 0; pos.row < state->rows; pos.row++)\n          for(pos.col = 0; pos.col < ROWWIDTH(state, pos.row); pos.col++)\n            putglyph(state, E, 1, pos);\n        break;\n      }\n\n      default:\n        return 0;\n    }\n    return 2;\n\n  case '(': case ')': case '*': case '+': // SCS\n    if(len != 2)\n      return 0;\n\n    {\n      int setnum = bytes[0] - 0x28;\n      VTermEncoding *newenc = vterm_lookup_encoding(ENC_SINGLE_94, bytes[1]);\n\n      if(newenc) {\n        state->encoding[setnum].enc = newenc;\n\n        if(newenc->init)\n          (*newenc->init)(newenc, state->encoding[setnum].data);\n      }\n    }\n\n    return 2;\n\n  case '7': // DECSC\n    savecursor(state, 1);\n    return 1;\n\n  case '8': // DECRC\n    savecursor(state, 0);\n    return 1;\n\n  case '<': // Ignored by VT100. Used in VT52 mode to switch up to VT100\n    return 1;\n\n  case '=': // DECKPAM\n    state->mode.keypad = 1;\n    return 1;\n\n  case '>': // DECKPNM\n    state->mode.keypad = 0;\n    return 1;\n\n  case 'c': // RIS - ECMA-48 8.3.105\n  {\n    VTermPos oldpos = state->pos;\n    vterm_state_reset(state, 1);\n    if(state->callbacks && state->callbacks->movecursor)\n      (*state->callbacks->movecursor)(state->pos, oldpos, state->mode.cursor_visible, state->cbdata);\n    return 1;\n  }\n\n  case 'n': // LS2 - ECMA-48 8.3.78\n    state->gl_set = 2;\n    return 1;\n\n  case 'o': // LS3 - ECMA-48 8.3.80\n    state->gl_set = 3;\n    return 1;\n\n  case '~': // LS1R - ECMA-48 8.3.77\n    state->gr_set = 1;\n    return 1;\n\n  case '}': // LS2R - ECMA-48 8.3.79\n    state->gr_set = 2;\n    return 1;\n\n  case '|': // LS3R - ECMA-48 8.3.81\n    state->gr_set = 3;\n    return 1;\n\n  default:\n    return 0;\n  }\n}\n\nstatic void set_mode(VTermState *state, int num, int val)\n{\n  switch(num) {\n  case 4: // IRM - ECMA-48 7.2.10\n    state->mode.insert = val;\n    break;\n\n  case 20: // LNM - ANSI X3.4-1977\n    state->mode.newline = val;\n    break;\n\n  default:\n    DEBUG_LOG1(\"libvterm: Unknown mode %d\\n\", num);\n    return;\n  }\n}\n\nstatic void set_dec_mode(VTermState *state, int num, int val)\n{\n  switch(num) {\n  case 1:\n    state->mode.cursor = val;\n    break;\n\n  case 5: // DECSCNM - screen mode\n    settermprop_bool(state, VTERM_PROP_REVERSE, val);\n    break;\n\n  case 6: // DECOM - origin mode\n    {\n      VTermPos oldpos = state->pos;\n      state->mode.origin = val;\n      state->pos.row = state->mode.origin ? state->scrollregion_top : 0;\n      state->pos.col = state->mode.origin ? SCROLLREGION_LEFT(state) : 0;\n      updatecursor(state, &oldpos, 1);\n    }\n    break;\n\n  case 7:\n    state->mode.autowrap = val;\n    break;\n\n  case 12:\n    settermprop_bool(state, VTERM_PROP_CURSORBLINK, val);\n    break;\n\n  case 25:\n    settermprop_bool(state, VTERM_PROP_CURSORVISIBLE, val);\n    break;\n\n  case 69: // DECVSSM - vertical split screen mode\n           // DECLRMM - left/right margin mode\n    state->mode.leftrightmargin = val;\n    if(val) {\n      int row;\n\n      // Setting DECVSSM must clear doublewidth/doubleheight state of every line\n      for(row = 0; row < state->rows; row++)\n        set_lineinfo(state, row, FORCE, DWL_OFF, DHL_OFF);\n    }\n\n    break;\n\n  case 1000:\n  case 1002:\n  case 1003:\n    settermprop_int(state, VTERM_PROP_MOUSE,\n        !val          ? VTERM_PROP_MOUSE_NONE  :\n        (num == 1000) ? VTERM_PROP_MOUSE_CLICK :\n        (num == 1002) ? VTERM_PROP_MOUSE_DRAG  :\n                        VTERM_PROP_MOUSE_MOVE);\n    break;\n\n  case 1004:\n    state->mode.report_focus = val;\n    break;\n\n  case 1005:\n    state->mouse_protocol = val ? MOUSE_UTF8 : MOUSE_X10;\n    break;\n\n  case 1006:\n    state->mouse_protocol = val ? MOUSE_SGR : MOUSE_X10;\n    break;\n\n  case 1015:\n    state->mouse_protocol = val ? MOUSE_RXVT : MOUSE_X10;\n    break;\n\n  case 1047:\n    settermprop_bool(state, VTERM_PROP_ALTSCREEN, val);\n    break;\n\n  case 1048:\n    savecursor(state, val);\n    break;\n\n  case 1049:\n    settermprop_bool(state, VTERM_PROP_ALTSCREEN, val);\n    savecursor(state, val);\n    break;\n\n  case 2004:\n    state->mode.bracketpaste = val;\n    break;\n\n  default:\n    DEBUG_LOG1(\"libvterm: Unknown DEC mode %d\\n\", num);\n    return;\n  }\n}\n\nstatic void request_dec_mode(VTermState *state, int num)\n{\n  int reply;\n\n  switch(num) {\n    case 1:\n      reply = state->mode.cursor;\n      break;\n\n    case 5:\n      reply = state->mode.screen;\n      break;\n\n    case 6:\n      reply = state->mode.origin;\n      break;\n\n    case 7:\n      reply = state->mode.autowrap;\n      break;\n\n    case 12:\n      reply = state->mode.cursor_blink;\n      break;\n\n    case 25:\n      reply = state->mode.cursor_visible;\n      break;\n\n    case 69:\n      reply = state->mode.leftrightmargin;\n      break;\n\n    case 1000:\n      reply = state->mouse_flags == MOUSE_WANT_CLICK;\n      break;\n\n    case 1002:\n      reply = state->mouse_flags == (MOUSE_WANT_CLICK|MOUSE_WANT_DRAG);\n      break;\n\n    case 1003:\n      reply = state->mouse_flags == (MOUSE_WANT_CLICK|MOUSE_WANT_MOVE);\n      break;\n\n    case 1004:\n      reply = state->mode.report_focus;\n      break;\n\n    case 1005:\n      reply = state->mouse_protocol == MOUSE_UTF8;\n      break;\n\n    case 1006:\n      reply = state->mouse_protocol == MOUSE_SGR;\n      break;\n\n    case 1015:\n      reply = state->mouse_protocol == MOUSE_RXVT;\n      break;\n\n    case 1047:\n      reply = state->mode.alt_screen;\n      break;\n\n    case 2004:\n      reply = state->mode.bracketpaste;\n      break;\n\n    default:\n      vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"?%d;%d$y\", num, 0);\n      return;\n  }\n\n  vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"?%d;%d$y\", num, reply ? 1 : 2);\n}\n\nstatic int on_csi(const char *leader, const long args[], int argcount, const char *intermed, char command, void *user)\n{\n  VTermState *state = user;\n  int leader_byte = 0;\n  int intermed_byte = 0;\n  VTermPos oldpos = state->pos;\n\n  /* Some temporaries for later code */\n  int count, val;\n  int row, col;\n  VTermRect rect;\n  int selective;\n\n  if(leader && leader[0]) {\n    if(leader[1]) // longer than 1 char\n      return 0;\n\n    switch(leader[0]) {\n    case '?':\n    case '>':\n      leader_byte = leader[0];\n      break;\n    default:\n      return 0;\n    }\n  }\n\n  if(intermed && intermed[0]) {\n    if(intermed[1]) // longer than 1 char\n      return 0;\n\n    switch(intermed[0]) {\n    case ' ':\n    case '\"':\n    case '$':\n    case '\\'':\n      intermed_byte = intermed[0];\n      break;\n    default:\n      return 0;\n    }\n  }\n\n  oldpos = state->pos;\n\n#define LBOUND(v,min) if((v) < (min)) (v) = (min)\n#define UBOUND(v,max) if((v) > (max)) (v) = (max)\n\n#define LEADER(l,b) ((l << 8) | b)\n#define INTERMED(i,b) ((i << 16) | b)\n\n  switch(intermed_byte << 16 | leader_byte << 8 | command) {\n  case 0x40: // ICH - ECMA-48 8.3.64\n    count = CSI_ARG_COUNT(args[0]);\n\n    if(!is_cursor_in_scrollregion(state))\n      break;\n\n    rect.start_row = state->pos.row;\n    rect.end_row   = state->pos.row + 1;\n    rect.start_col = state->pos.col;\n    if(state->mode.leftrightmargin)\n      rect.end_col = SCROLLREGION_RIGHT(state);\n    else\n      rect.end_col = THISROWWIDTH(state);\n\n    scroll(state, rect, 0, -count);\n\n    break;\n\n  case 0x41: // CUU - ECMA-48 8.3.22\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.row -= count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x42: // CUD - ECMA-48 8.3.19\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.row += count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x43: // CUF - ECMA-48 8.3.20\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.col += count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x44: // CUB - ECMA-48 8.3.18\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.col -= count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x45: // CNL - ECMA-48 8.3.12\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.col = 0;\n    state->pos.row += count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x46: // CPL - ECMA-48 8.3.13\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.col = 0;\n    state->pos.row -= count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x47: // CHA - ECMA-48 8.3.9\n    val = CSI_ARG_OR(args[0], 1);\n    state->pos.col = val-1;\n    state->at_phantom = 0;\n    break;\n\n  case 0x48: // CUP - ECMA-48 8.3.21\n    row = CSI_ARG_OR(args[0], 1);\n    col = argcount < 2 || CSI_ARG_IS_MISSING(args[1]) ? 1 : CSI_ARG(args[1]);\n    // zero-based\n    state->pos.row = row-1;\n    state->pos.col = col-1;\n    if(state->mode.origin) {\n      state->pos.row += state->scrollregion_top;\n      state->pos.col += SCROLLREGION_LEFT(state);\n    }\n    state->at_phantom = 0;\n    break;\n\n  case 0x49: // CHT - ECMA-48 8.3.10\n    count = CSI_ARG_COUNT(args[0]);\n    tab(state, count, +1);\n    break;\n\n  case 0x4a: // ED - ECMA-48 8.3.39\n  case LEADER('?', 0x4a): // DECSED - Selective Erase in Display\n    selective = (leader_byte == '?');\n    switch(CSI_ARG(args[0])) {\n    case CSI_ARG_MISSING:\n    case 0:\n      rect.start_row = state->pos.row; rect.end_row = state->pos.row + 1;\n      rect.start_col = state->pos.col; rect.end_col = state->cols;\n      if(rect.end_col > rect.start_col)\n        erase(state, rect, selective);\n\n      rect.start_row = state->pos.row + 1; rect.end_row = state->rows;\n      rect.start_col = 0;\n      for(row = rect.start_row; row < rect.end_row; row++)\n\tset_lineinfo(state, row, FORCE, DWL_OFF, DHL_OFF);\n      if(rect.end_row > rect.start_row)\n        erase(state, rect, selective);\n      break;\n\n    case 1:\n      rect.start_row = 0; rect.end_row = state->pos.row;\n      rect.start_col = 0; rect.end_col = state->cols;\n      for(row = rect.start_row; row < rect.end_row; row++)\n\tset_lineinfo(state, row, FORCE, DWL_OFF, DHL_OFF);\n      if(rect.end_col > rect.start_col)\n        erase(state, rect, selective);\n\n      rect.start_row = state->pos.row; rect.end_row = state->pos.row + 1;\n                          rect.end_col = state->pos.col + 1;\n      if(rect.end_row > rect.start_row)\n        erase(state, rect, selective);\n      break;\n\n    case 2:\n      rect.start_row = 0; rect.end_row = state->rows;\n      rect.start_col = 0; rect.end_col = state->cols;\n      for(row = rect.start_row; row < rect.end_row; row++)\n\tset_lineinfo(state, row, FORCE, DWL_OFF, DHL_OFF);\n      erase(state, rect, selective);\n      break;\n    }\n    break;\n\n  case 0x4b: // EL - ECMA-48 8.3.41\n  case LEADER('?', 0x4b): // DECSEL - Selective Erase in Line\n    selective = (leader_byte == '?');\n    rect.start_row = state->pos.row;\n    rect.end_row   = state->pos.row + 1;\n\n    switch(CSI_ARG(args[0])) {\n    case CSI_ARG_MISSING:\n    case 0:\n      rect.start_col = state->pos.col; rect.end_col = THISROWWIDTH(state); break;\n    case 1:\n      rect.start_col = 0; rect.end_col = state->pos.col + 1; break;\n    case 2:\n      rect.start_col = 0; rect.end_col = THISROWWIDTH(state); break;\n    default:\n      return 0;\n    }\n\n    if(rect.end_col > rect.start_col)\n      erase(state, rect, selective);\n\n    break;\n\n  case 0x4c: // IL - ECMA-48 8.3.67\n    count = CSI_ARG_COUNT(args[0]);\n\n    if(!is_cursor_in_scrollregion(state))\n      break;\n\n    rect.start_row = state->pos.row;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = SCROLLREGION_LEFT(state);\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, -count, 0);\n\n    break;\n\n  case 0x4d: // DL - ECMA-48 8.3.32\n    count = CSI_ARG_COUNT(args[0]);\n\n    if(!is_cursor_in_scrollregion(state))\n      break;\n\n    rect.start_row = state->pos.row;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = SCROLLREGION_LEFT(state);\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, count, 0);\n\n    break;\n\n  case 0x50: // DCH - ECMA-48 8.3.26\n    count = CSI_ARG_COUNT(args[0]);\n\n    if(!is_cursor_in_scrollregion(state))\n      break;\n\n    rect.start_row = state->pos.row;\n    rect.end_row   = state->pos.row + 1;\n    rect.start_col = state->pos.col;\n    if(state->mode.leftrightmargin)\n      rect.end_col = SCROLLREGION_RIGHT(state);\n    else\n      rect.end_col = THISROWWIDTH(state);\n\n    scroll(state, rect, 0, count);\n\n    break;\n\n  case 0x53: // SU - ECMA-48 8.3.147\n    count = CSI_ARG_COUNT(args[0]);\n\n    rect.start_row = state->scrollregion_top;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = SCROLLREGION_LEFT(state);\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, count, 0);\n\n    break;\n\n  case 0x54: // SD - ECMA-48 8.3.113\n    count = CSI_ARG_COUNT(args[0]);\n\n    rect.start_row = state->scrollregion_top;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = SCROLLREGION_LEFT(state);\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, -count, 0);\n\n    break;\n\n  case 0x58: // ECH - ECMA-48 8.3.38\n    count = CSI_ARG_COUNT(args[0]);\n\n    rect.start_row = state->pos.row;\n    rect.end_row   = state->pos.row + 1;\n    rect.start_col = state->pos.col;\n    rect.end_col   = state->pos.col + count;\n    UBOUND(rect.end_col, THISROWWIDTH(state));\n\n    erase(state, rect, 0);\n    break;\n\n  case 0x5a: // CBT - ECMA-48 8.3.7\n    count = CSI_ARG_COUNT(args[0]);\n    tab(state, count, -1);\n    break;\n\n  case 0x60: // HPA - ECMA-48 8.3.57\n    col = CSI_ARG_OR(args[0], 1);\n    state->pos.col = col-1;\n    state->at_phantom = 0;\n    break;\n\n  case 0x61: // HPR - ECMA-48 8.3.59\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.col += count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x63: // DA - ECMA-48 8.3.24\n    val = CSI_ARG_OR(args[0], 0);\n    if(val == 0)\n      // DEC VT100 response\n      vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"?1;2c\");\n    break;\n\n  case LEADER('>', 0x63): // DEC secondary Device Attributes\n    // This returns xterm version number 100.\n    vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \">%d;%d;%dc\", 0, 100, 0);\n    break;\n\n  case 0x64: // VPA - ECMA-48 8.3.158\n    row = CSI_ARG_OR(args[0], 1);\n    state->pos.row = row-1;\n    if(state->mode.origin)\n      state->pos.row += state->scrollregion_top;\n    state->at_phantom = 0;\n    break;\n\n  case 0x65: // VPR - ECMA-48 8.3.160\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.row += count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x66: // HVP - ECMA-48 8.3.63\n    row = CSI_ARG_OR(args[0], 1);\n    col = argcount < 2 || CSI_ARG_IS_MISSING(args[1]) ? 1 : CSI_ARG(args[1]);\n    // zero-based\n    state->pos.row = row-1;\n    state->pos.col = col-1;\n    if(state->mode.origin) {\n      state->pos.row += state->scrollregion_top;\n      state->pos.col += SCROLLREGION_LEFT(state);\n    }\n    state->at_phantom = 0;\n    break;\n\n  case 0x67: // TBC - ECMA-48 8.3.154\n    val = CSI_ARG_OR(args[0], 0);\n\n    switch(val) {\n    case 0:\n      clear_col_tabstop(state, state->pos.col);\n      break;\n    case 3:\n    case 5:\n      for(col = 0; col < state->cols; col++)\n        clear_col_tabstop(state, col);\n      break;\n    case 1:\n    case 2:\n    case 4:\n      break;\n    /* TODO: 1, 2 and 4 aren't meaningful yet without line tab stops */\n    default:\n      return 0;\n    }\n    break;\n\n  case 0x68: // SM - ECMA-48 8.3.125\n    if(!CSI_ARG_IS_MISSING(args[0]))\n      set_mode(state, CSI_ARG(args[0]), 1);\n    break;\n\n  case LEADER('?', 0x68): // DEC private mode set\n    if(!CSI_ARG_IS_MISSING(args[0]))\n      set_dec_mode(state, CSI_ARG(args[0]), 1);\n    break;\n\n  case 0x6a: // HPB - ECMA-48 8.3.58\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.col -= count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x6b: // VPB - ECMA-48 8.3.159\n    count = CSI_ARG_COUNT(args[0]);\n    state->pos.row -= count;\n    state->at_phantom = 0;\n    break;\n\n  case 0x6c: // RM - ECMA-48 8.3.106\n    if(!CSI_ARG_IS_MISSING(args[0]))\n      set_mode(state, CSI_ARG(args[0]), 0);\n    break;\n\n  case LEADER('?', 0x6c): // DEC private mode reset\n    if(!CSI_ARG_IS_MISSING(args[0]))\n      set_dec_mode(state, CSI_ARG(args[0]), 0);\n    break;\n\n  case 0x6d: // SGR - ECMA-48 8.3.117\n    vterm_state_setpen(state, args, argcount);\n    break;\n\n  case 0x6e: // DSR - ECMA-48 8.3.35\n  case LEADER('?', 0x6e): // DECDSR\n    val = CSI_ARG_OR(args[0], 0);\n\n    {\n      char *qmark = (leader_byte == '?') ? \"?\" : \"\";\n\n      switch(val) {\n      case 0: case 1: case 2: case 3: case 4:\n        // ignore - these are replies\n        break;\n      case 5:\n        vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"%s0n\", qmark);\n        break;\n      case 6: // CPR - cursor position report\n        vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"%s%d;%dR\", qmark, state->pos.row + 1, state->pos.col + 1);\n        break;\n      }\n    }\n    break;\n\n\n  case LEADER('!', 0x70): // DECSTR - DEC soft terminal reset\n    vterm_state_reset(state, 0);\n    break;\n\n  case LEADER('?', INTERMED('$', 0x70)):\n    request_dec_mode(state, CSI_ARG(args[0]));\n    break;\n\n  case INTERMED(' ', 0x71): // DECSCUSR - DEC set cursor shape\n    val = CSI_ARG_OR(args[0], 1);\n\n    switch(val) {\n    case 0: case 1:\n      settermprop_bool(state, VTERM_PROP_CURSORBLINK, 1);\n      settermprop_int (state, VTERM_PROP_CURSORSHAPE, VTERM_PROP_CURSORSHAPE_BLOCK);\n      break;\n    case 2:\n      settermprop_bool(state, VTERM_PROP_CURSORBLINK, 0);\n      settermprop_int (state, VTERM_PROP_CURSORSHAPE, VTERM_PROP_CURSORSHAPE_BLOCK);\n      break;\n    case 3:\n      settermprop_bool(state, VTERM_PROP_CURSORBLINK, 1);\n      settermprop_int (state, VTERM_PROP_CURSORSHAPE, VTERM_PROP_CURSORSHAPE_UNDERLINE);\n      break;\n    case 4:\n      settermprop_bool(state, VTERM_PROP_CURSORBLINK, 0);\n      settermprop_int (state, VTERM_PROP_CURSORSHAPE, VTERM_PROP_CURSORSHAPE_UNDERLINE);\n      break;\n    case 5:\n      settermprop_bool(state, VTERM_PROP_CURSORBLINK, 1);\n      settermprop_int (state, VTERM_PROP_CURSORSHAPE, VTERM_PROP_CURSORSHAPE_BAR_LEFT);\n      break;\n    case 6:\n      settermprop_bool(state, VTERM_PROP_CURSORBLINK, 0);\n      settermprop_int (state, VTERM_PROP_CURSORSHAPE, VTERM_PROP_CURSORSHAPE_BAR_LEFT);\n      break;\n    }\n\n    break;\n\n  case INTERMED('\"', 0x71): // DECSCA - DEC select character protection attribute\n    val = CSI_ARG_OR(args[0], 0);\n\n    switch(val) {\n    case 0: case 2:\n      state->protected_cell = 0;\n      break;\n    case 1:\n      state->protected_cell = 1;\n      break;\n    }\n\n    break;\n\n  case 0x72: // DECSTBM - DEC custom\n    state->scrollregion_top = CSI_ARG_OR(args[0], 1) - 1;\n    state->scrollregion_bottom = argcount < 2 || CSI_ARG_IS_MISSING(args[1]) ? -1 : CSI_ARG(args[1]);\n    LBOUND(state->scrollregion_top, 0);\n    UBOUND(state->scrollregion_top, state->rows);\n    LBOUND(state->scrollregion_bottom, -1);\n    if(state->scrollregion_top == 0 && state->scrollregion_bottom == state->rows)\n      state->scrollregion_bottom = -1;\n    else\n      UBOUND(state->scrollregion_bottom, state->rows);\n\n    if(SCROLLREGION_BOTTOM(state) <= state->scrollregion_top) {\n      // Invalid\n      state->scrollregion_top    = 0;\n      state->scrollregion_bottom = -1;\n    }\n\n    break;\n\n  case 0x73: // DECSLRM - DEC custom\n    // Always allow setting these margins, just they won't take effect without DECVSSM\n    state->scrollregion_left = CSI_ARG_OR(args[0], 1) - 1;\n    state->scrollregion_right = argcount < 2 || CSI_ARG_IS_MISSING(args[1]) ? -1 : CSI_ARG(args[1]);\n    LBOUND(state->scrollregion_left, 0);\n    UBOUND(state->scrollregion_left, state->cols);\n    LBOUND(state->scrollregion_right, -1);\n    if(state->scrollregion_left == 0 && state->scrollregion_right == state->cols)\n      state->scrollregion_right = -1;\n    else\n      UBOUND(state->scrollregion_right, state->cols);\n\n    if(state->scrollregion_right > -1 &&\n       state->scrollregion_right <= state->scrollregion_left) {\n      // Invalid\n      state->scrollregion_left  = 0;\n      state->scrollregion_right = -1;\n    }\n\n    break;\n\n  case 0x74:\n    switch(CSI_ARG(args[0])) {\n      case 8: /* CSI 8 ; rows ; cols t  set size */\n\tif (argcount == 3)\n\t  on_resize(CSI_ARG(args[1]), CSI_ARG(args[2]), state);\n    }\n    break;\n\n  case INTERMED('\\'', 0x7D): // DECIC\n    count = CSI_ARG_COUNT(args[0]);\n\n    if(!is_cursor_in_scrollregion(state))\n      break;\n\n    rect.start_row = state->scrollregion_top;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = state->pos.col;\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, 0, -count);\n\n    break;\n\n  case INTERMED('\\'', 0x7E): // DECDC\n    count = CSI_ARG_COUNT(args[0]);\n\n    if(!is_cursor_in_scrollregion(state))\n      break;\n\n    rect.start_row = state->scrollregion_top;\n    rect.end_row   = SCROLLREGION_BOTTOM(state);\n    rect.start_col = state->pos.col;\n    rect.end_col   = SCROLLREGION_RIGHT(state);\n\n    scroll(state, rect, 0, count);\n\n    break;\n\n  default:\n    if(state->fallbacks && state->fallbacks->csi)\n      if((*state->fallbacks->csi)(leader, args, argcount, intermed, command, state->fbdata))\n        return 1;\n\n    return 0;\n  }\n\n  if(state->mode.origin) {\n    LBOUND(state->pos.row, state->scrollregion_top);\n    UBOUND(state->pos.row, SCROLLREGION_BOTTOM(state)-1);\n    LBOUND(state->pos.col, SCROLLREGION_LEFT(state));\n    UBOUND(state->pos.col, SCROLLREGION_RIGHT(state)-1);\n  }\n  else {\n    LBOUND(state->pos.row, 0);\n    UBOUND(state->pos.row, state->rows-1);\n    LBOUND(state->pos.col, 0);\n    UBOUND(state->pos.col, THISROWWIDTH(state)-1);\n  }\n\n  updatecursor(state, &oldpos, 1);\n\n#ifdef DEBUG\n  if(state->pos.row < 0 || state->pos.row >= state->rows ||\n     state->pos.col < 0 || state->pos.col >= state->cols) {\n    fprintf(stderr, \"Position out of bounds after CSI %c: (%d,%d)\\n\",\n        command, state->pos.row, state->pos.col);\n    abort();\n  }\n\n  if(SCROLLREGION_BOTTOM(state) <= state->scrollregion_top) {\n    fprintf(stderr, \"Scroll region height out of bounds after CSI %c: %d <= %d\\n\",\n        command, SCROLLREGION_BOTTOM(state), state->scrollregion_top);\n    abort();\n  }\n\n  if(SCROLLREGION_RIGHT(state) <= SCROLLREGION_LEFT(state)) {\n    fprintf(stderr, \"Scroll region width out of bounds after CSI %c: %d <= %d\\n\",\n        command, SCROLLREGION_RIGHT(state), SCROLLREGION_LEFT(state));\n    abort();\n  }\n#endif\n\n  return 1;\n}\n\nstatic int on_osc(const char *command, size_t cmdlen, void *user)\n{\n  VTermState *state = user;\n\n  if(cmdlen < 2)\n    return 0;\n\n  if(strneq(command, \"0;\", 2)) {\n    settermprop_string(state, VTERM_PROP_ICONNAME, command + 2, cmdlen - 2);\n    settermprop_string(state, VTERM_PROP_TITLE, command + 2, cmdlen - 2);\n    return 1;\n  }\n  else if(strneq(command, \"1;\", 2)) {\n    settermprop_string(state, VTERM_PROP_ICONNAME, command + 2, cmdlen - 2);\n    return 1;\n  }\n  else if(strneq(command, \"2;\", 2)) {\n    settermprop_string(state, VTERM_PROP_TITLE, command + 2, cmdlen - 2);\n    return 1;\n  }\n  else if(strneq(command, \"10;\", 3)) {\n    /* request foreground color: <Esc>]10;?<0x07> */\n    int red = state->default_fg.red;\n    int blue = state->default_fg.blue;\n    int green = state->default_fg.green;\n    vterm_push_output_sprintf_ctrl(state->vt, C1_OSC, \"10;rgb:%02x%02x/%02x%02x/%02x%02x\\x07\", red, red, green, green, blue, blue);\n    return 1;\n  }\n  else if(strneq(command, \"11;\", 3)) {\n    /* request background color: <Esc>]11;?<0x07> */\n    int red = state->default_bg.red;\n    int blue = state->default_bg.blue;\n    int green = state->default_bg.green;\n    vterm_push_output_sprintf_ctrl(state->vt, C1_OSC, \"11;rgb:%02x%02x/%02x%02x/%02x%02x\\x07\", red, red, green, green, blue, blue);\n    return 1;\n  }\n  else if(strneq(command, \"12;\", 3)) {\n    settermprop_string(state, VTERM_PROP_CURSORCOLOR, command + 3, cmdlen - 3);\n    return 1;\n  }\n  else if(state->fallbacks && state->fallbacks->osc)\n    if((*state->fallbacks->osc)(command, cmdlen, state->fbdata))\n      return 1;\n\n  return 0;\n}\n\nstatic void request_status_string(VTermState *state, const char *command, size_t cmdlen)\n{\n  if(cmdlen == 1)\n    switch(command[0]) {\n      case 'm': // Query SGR\n        {\n          long args[20];\n          int argc = vterm_state_getpen(state, args, sizeof(args)/sizeof(args[0]));\n\t  int argi;\n          vterm_push_output_sprintf_ctrl(state->vt, C1_DCS, \"1$r\");\n          for(argi = 0; argi < argc; argi++)\n            vterm_push_output_sprintf(state->vt,\n                argi == argc - 1             ? \"%d\" :\n                CSI_ARG_HAS_MORE(args[argi]) ? \"%d:\" :\n                                               \"%d;\",\n                CSI_ARG(args[argi]));\n          vterm_push_output_sprintf(state->vt, \"m\");\n          vterm_push_output_sprintf_ctrl(state->vt, C1_ST, \"\");\n        }\n        return;\n      case 'r': // Query DECSTBM\n        vterm_push_output_sprintf_dcs(state->vt, \"1$r%d;%dr\", state->scrollregion_top+1, SCROLLREGION_BOTTOM(state));\n        return;\n      case 's': // Query DECSLRM\n        vterm_push_output_sprintf_dcs(state->vt, \"1$r%d;%ds\", SCROLLREGION_LEFT(state)+1, SCROLLREGION_RIGHT(state));\n        return;\n    }\n\n  if(cmdlen == 2) {\n    if(strneq(command, \" q\", 2)) {\n      int reply;\n      switch(state->mode.cursor_shape) {\n        case VTERM_PROP_CURSORSHAPE_BLOCK:     reply = 2; break;\n        case VTERM_PROP_CURSORSHAPE_UNDERLINE: reply = 4; break;\n\tdefault: /* VTERM_PROP_CURSORSHAPE_BAR_LEFT */  reply = 6; break;\n      }\n      if(state->mode.cursor_blink)\n        reply--;\n      vterm_push_output_sprintf_dcs(state->vt, \"1$r%d q\", reply);\n      return;\n    }\n    else if(strneq(command, \"\\\"q\", 2)) {\n      vterm_push_output_sprintf_dcs(state->vt, \"1$r%d\\\"q\", state->protected_cell ? 1 : 2);\n      return;\n    }\n  }\n\n  vterm_push_output_sprintf_dcs(state->vt, \"0$r%.s\", (int)cmdlen, command);\n}\n\nstatic int on_dcs(const char *command, size_t cmdlen, void *user)\n{\n  VTermState *state = user;\n\n  if(cmdlen >= 2 && strneq(command, \"$q\", 2)) {\n    request_status_string(state, command+2, cmdlen-2);\n    return 1;\n  }\n  else if(state->fallbacks && state->fallbacks->dcs)\n    if((*state->fallbacks->dcs)(command, cmdlen, state->fbdata))\n      return 1;\n\n  return 0;\n}\n\nstatic int on_resize(int rows, int cols, void *user)\n{\n  VTermState *state = user;\n  VTermPos oldpos = state->pos;\n  VTermPos delta = { 0, 0 };\n\n  if(cols != state->cols) {\n    unsigned char *newtabstops = vterm_allocator_malloc(state->vt, (cols + 7) / 8);\n\n    /* TODO: This can all be done much more efficiently bytewise */\n    int col;\n    for(col = 0; col < state->cols && col < cols; col++) {\n      unsigned char mask = 1 << (col & 7);\n      if(state->tabstops[col >> 3] & mask)\n        newtabstops[col >> 3] |= mask;\n      else\n        newtabstops[col >> 3] &= ~mask;\n      }\n\n    for( ; col < cols; col++) {\n      unsigned char mask = 1 << (col & 7);\n      if(col % 8 == 0)\n        newtabstops[col >> 3] |= mask;\n      else\n        newtabstops[col >> 3] &= ~mask;\n    }\n\n    vterm_allocator_free(state->vt, state->tabstops);\n    state->tabstops = newtabstops;\n  }\n\n  if(rows != state->rows) {\n    VTermLineInfo *newlineinfo = vterm_allocator_malloc(state->vt, rows * sizeof(VTermLineInfo));\n\n    int row;\n    for(row = 0; row < state->rows && row < rows; row++) {\n      newlineinfo[row] = state->lineinfo[row];\n    }\n\n    for( ; row < rows; row++) {\n      newlineinfo[row].doublewidth = 0;\n      newlineinfo[row].doubleheight = 0;\n    }\n\n    vterm_allocator_free(state->vt, state->lineinfo);\n    state->lineinfo = newlineinfo;\n  }\n\n  state->rows = rows;\n  state->cols = cols;\n\n  if(state->scrollregion_bottom > -1)\n    UBOUND(state->scrollregion_bottom, state->rows);\n  if(state->scrollregion_right > -1)\n    UBOUND(state->scrollregion_right, state->cols);\n\n  if(state->callbacks && state->callbacks->resize)\n    (*state->callbacks->resize)(rows, cols, &delta, state->cbdata);\n\n  if(state->at_phantom && state->pos.col < cols-1) {\n    state->at_phantom = 0;\n    state->pos.col++;\n  }\n\n  state->pos.row += delta.row;\n  state->pos.col += delta.col;\n\n  if(state->pos.row >= rows)\n    state->pos.row = rows - 1;\n  if(state->pos.col >= cols)\n    state->pos.col = cols - 1;\n\n  updatecursor(state, &oldpos, 1);\n\n  return 1;\n}\n\nstatic const VTermParserCallbacks parser_callbacks = {\n  on_text, /* text */\n  on_control, /* control */\n  on_escape, /* escape */\n  on_csi, /* csi */\n  on_osc, /* osc */\n  on_dcs, /* dcs */\n  on_resize /* resize */\n};\n\n/*\n * Return the existing state or create a new one.\n * Returns NULL when out of memory.\n */\nVTermState *vterm_obtain_state(VTerm *vt)\n{\n  VTermState *state;\n  if(vt->state)\n    return vt->state;\n\n  state = vterm_state_new(vt);\n  if (state == NULL)\n    return NULL;\n  vt->state = state;\n\n  state->combine_chars_size = 16;\n  state->combine_chars = vterm_allocator_malloc(state->vt, state->combine_chars_size * sizeof(state->combine_chars[0]));\n\n  state->tabstops = vterm_allocator_malloc(state->vt, (state->cols + 7) / 8);\n\n  state->lineinfo = vterm_allocator_malloc(state->vt, state->rows * sizeof(VTermLineInfo));\n\n  state->encoding_utf8.enc = vterm_lookup_encoding(ENC_UTF8, 'u');\n  if(*state->encoding_utf8.enc->init != NULL)\n    (*state->encoding_utf8.enc->init)(state->encoding_utf8.enc, state->encoding_utf8.data);\n\n  vterm_parser_set_callbacks(vt, &parser_callbacks, state);\n\n  return state;\n}\n\nvoid vterm_state_reset(VTermState *state, int hard)\n{\n  VTermEncoding *default_enc;\n\n  state->scrollregion_top = 0;\n  state->scrollregion_bottom = -1;\n  state->scrollregion_left = 0;\n  state->scrollregion_right = -1;\n\n  state->mode.keypad          = 0;\n  state->mode.cursor          = 0;\n  state->mode.autowrap        = 1;\n  state->mode.insert          = 0;\n  state->mode.newline         = 0;\n  state->mode.alt_screen      = 0;\n  state->mode.origin          = 0;\n  state->mode.leftrightmargin = 0;\n  state->mode.bracketpaste    = 0;\n  state->mode.report_focus    = 0;\n\n  state->vt->mode.ctrl8bit   = 0;\n\n  {\n    int col;\n    for(col = 0; col < state->cols; col++)\n      if(col % 8 == 0)\n\tset_col_tabstop(state, col);\n      else\n\tclear_col_tabstop(state, col);\n  }\n\n  {\n    int row;\n    for(row = 0; row < state->rows; row++)\n      set_lineinfo(state, row, FORCE, DWL_OFF, DHL_OFF);\n  }\n\n  if(state->callbacks && state->callbacks->initpen)\n    (*state->callbacks->initpen)(state->cbdata);\n\n  vterm_state_resetpen(state);\n\n  default_enc = state->vt->mode.utf8 ?\n      vterm_lookup_encoding(ENC_UTF8,      'u') :\n      vterm_lookup_encoding(ENC_SINGLE_94, 'B');\n\n  {\n    int i;\n    for(i = 0; i < 4; i++) {\n      state->encoding[i].enc = default_enc;\n      if(default_enc->init)\n\t(*default_enc->init)(default_enc, state->encoding[i].data);\n    }\n  }\n\n  state->gl_set = 0;\n  state->gr_set = 1;\n  state->gsingle_set = 0;\n\n  state->protected_cell = 0;\n\n  // Initialise the props\n  settermprop_bool(state, VTERM_PROP_CURSORVISIBLE, 1);\n  settermprop_bool(state, VTERM_PROP_CURSORBLINK,   1);\n  settermprop_int (state, VTERM_PROP_CURSORSHAPE,   VTERM_PROP_CURSORSHAPE_BLOCK);\n\n  if(hard) {\n    VTermRect rect = { 0, 0, 0, 0 };\n\n    state->pos.row = 0;\n    state->pos.col = 0;\n    state->at_phantom = 0;\n\n    rect.end_row = state->rows;\n    rect.end_col =  state->cols;\n    erase(state, rect, 0);\n  }\n}\n\nvoid vterm_state_get_cursorpos(const VTermState *state, VTermPos *cursorpos)\n{\n  *cursorpos = state->pos;\n}\n\nvoid vterm_state_get_mousestate(const VTermState *state, VTermMouseState *mousestate)\n{\n  mousestate->pos.col = state->mouse_col;\n  mousestate->pos.row = state->mouse_row;\n  mousestate->buttons = state->mouse_buttons;\n  mousestate->flags = state->mouse_flags;\n}\n\nvoid vterm_state_set_callbacks(VTermState *state, const VTermStateCallbacks *callbacks, void *user)\n{\n  if(callbacks) {\n    state->callbacks = callbacks;\n    state->cbdata = user;\n\n    if(state->callbacks && state->callbacks->initpen)\n      (*state->callbacks->initpen)(state->cbdata);\n  }\n  else {\n    state->callbacks = NULL;\n    state->cbdata = NULL;\n  }\n}\n\nvoid *vterm_state_get_cbdata(VTermState *state)\n{\n  return state->cbdata;\n}\n\nvoid vterm_state_set_unrecognised_fallbacks(VTermState *state, const VTermParserCallbacks *fallbacks, void *user)\n{\n  if(fallbacks) {\n    state->fallbacks = fallbacks;\n    state->fbdata = user;\n  }\n  else {\n    state->fallbacks = NULL;\n    state->fbdata = NULL;\n  }\n}\n\nvoid *vterm_state_get_unrecognised_fbdata(VTermState *state)\n{\n  return state->fbdata;\n}\n\nint vterm_state_set_termprop(VTermState *state, VTermProp prop, VTermValue *val)\n{\n  /* Only store the new value of the property if usercode said it was happy.\n   * This is especially important for altscreen switching */\n  if(state->callbacks && state->callbacks->settermprop)\n    if(!(*state->callbacks->settermprop)(prop, val, state->cbdata))\n      return 0;\n\n  switch(prop) {\n  case VTERM_PROP_TITLE:\n  case VTERM_PROP_ICONNAME:\n  case VTERM_PROP_CURSORCOLOR:\n    // we don't store these, just transparently pass through\n    return 1;\n  case VTERM_PROP_CURSORVISIBLE:\n    state->mode.cursor_visible = val->boolean;\n    return 1;\n  case VTERM_PROP_CURSORBLINK:\n    state->mode.cursor_blink = val->boolean;\n    return 1;\n  case VTERM_PROP_CURSORSHAPE:\n    state->mode.cursor_shape = val->number;\n    return 1;\n  case VTERM_PROP_REVERSE:\n    state->mode.screen = val->boolean;\n    return 1;\n  case VTERM_PROP_ALTSCREEN:\n    state->mode.alt_screen = val->boolean;\n    if(state->mode.alt_screen) {\n      VTermRect rect = {0, 0, 0, 0};\n      rect.end_row = state->rows;\n      rect.end_col = state->cols;\n      erase(state, rect, 0);\n    }\n    return 1;\n  case VTERM_PROP_MOUSE:\n    state->mouse_flags = 0;\n    if(val->number)\n      state->mouse_flags |= MOUSE_WANT_CLICK;\n    if(val->number == VTERM_PROP_MOUSE_DRAG)\n      state->mouse_flags |= MOUSE_WANT_DRAG;\n    if(val->number == VTERM_PROP_MOUSE_MOVE)\n      state->mouse_flags |= MOUSE_WANT_MOVE;\n    return 1;\n\n  case VTERM_N_PROPS:\n    return 0;\n  }\n\n  return 0;\n}\n\nvoid vterm_state_focus_in(VTermState *state)\n{\n  if(state->mode.report_focus)\n    vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"I\");\n}\n\nvoid vterm_state_focus_out(VTermState *state)\n{\n  if(state->mode.report_focus)\n    vterm_push_output_sprintf_ctrl(state->vt, C1_CSI, \"O\");\n}\n\nconst VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)\n{\n  return state->lineinfo + row;\n}\n", "#include \"vterm_internal.h\"\n\n/* vim: set sw=2 : */\n#include <stdio.h>\n#include <string.h>\n\n#include \"rect.h\"\n#include \"utf8.h\"\n\n#define UNICODE_SPACE 0x20\n#define UNICODE_LINEFEED 0x0a\n\n/* State of the pen at some moment in time, also used in a cell */\ntypedef struct\n{\n  /* After the bitfield */\n  VTermColor   fg, bg;\n\n  unsigned int bold      : 1;\n  unsigned int underline : 2;\n  unsigned int italic    : 1;\n  unsigned int blink     : 1;\n  unsigned int reverse   : 1;\n  unsigned int strike    : 1;\n  unsigned int font      : 4; /* 0 to 9 */\n\n  /* Extra state storage that isn't strictly pen-related */\n  unsigned int protected_cell : 1;\n  unsigned int dwl            : 1; /* on a DECDWL or DECDHL line */\n  unsigned int dhl            : 2; /* on a DECDHL line (1=top 2=bottom) */\n} ScreenPen;\n\n/* Internal representation of a screen cell */\ntypedef struct\n{\n  uint32_t chars[VTERM_MAX_CHARS_PER_CELL];\n  ScreenPen pen;\n} ScreenCell;\n\nstatic int vterm_screen_set_cell(VTermScreen *screen, VTermPos pos, const VTermScreenCell *cell);\n\nstruct VTermScreen\n{\n  VTerm *vt;\n  VTermState *state;\n\n  const VTermScreenCallbacks *callbacks;\n  void *cbdata;\n\n  VTermDamageSize damage_merge;\n  /* start_row == -1 => no damage */\n  VTermRect damaged;\n  VTermRect pending_scrollrect;\n  int pending_scroll_downward, pending_scroll_rightward;\n\n  int rows;\n  int cols;\n  int global_reverse;\n\n  /* Primary and Altscreen. buffers[1] is lazily allocated as needed */\n  ScreenCell *buffers[2];\n\n  /* buffer will == buffers[0] or buffers[1], depending on altscreen */\n  ScreenCell *buffer;\n\n  /* buffer for a single screen row used in scrollback storage callbacks */\n  VTermScreenCell *sb_buffer;\n\n  ScreenPen pen;\n};\n\nstatic ScreenCell *getcell(const VTermScreen *screen, int row, int col)\n{\n  if(row < 0 || row >= screen->rows)\n    return NULL;\n  if(col < 0 || col >= screen->cols)\n    return NULL;\n  return screen->buffer + (screen->cols * row) + col;\n}\n\nstatic ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int new_rows, int new_cols)\n{\n  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);\n  int row, col;\n\n  for(row = 0; row < new_rows; row++) {\n    for(col = 0; col < new_cols; col++) {\n      ScreenCell *new_cell = new_buffer + row*new_cols + col;\n\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}\n\nstatic void damagerect(VTermScreen *screen, VTermRect rect)\n{\n  VTermRect emit;\n\n  switch(screen->damage_merge) {\n  case VTERM_DAMAGE_CELL:\n    /* Always emit damage event */\n    emit = rect;\n    break;\n\n  case VTERM_DAMAGE_ROW:\n    /* Emit damage longer than one row. Try to merge with existing damage in\n     * the same row */\n    if(rect.end_row > rect.start_row + 1) {\n      // Bigger than 1 line - flush existing, emit this\n      vterm_screen_flush_damage(screen);\n      emit = rect;\n    }\n    else if(screen->damaged.start_row == -1) {\n      // None stored yet\n      screen->damaged = rect;\n      return;\n    }\n    else if(rect.start_row == screen->damaged.start_row) {\n      // Merge with the stored line\n      if(screen->damaged.start_col > rect.start_col)\n        screen->damaged.start_col = rect.start_col;\n      if(screen->damaged.end_col < rect.end_col)\n        screen->damaged.end_col = rect.end_col;\n      return;\n    }\n    else {\n      // Emit the currently stored line, store a new one\n      emit = screen->damaged;\n      screen->damaged = rect;\n    }\n    break;\n\n  case VTERM_DAMAGE_SCREEN:\n  case VTERM_DAMAGE_SCROLL:\n    /* Never emit damage event */\n    if(screen->damaged.start_row == -1)\n      screen->damaged = rect;\n    else {\n      rect_expand(&screen->damaged, &rect);\n    }\n    return;\n\n  default:\n    DEBUG_LOG1(\"TODO: Maybe merge damage for level %d\\n\", screen->damage_merge);\n    return;\n  }\n\n  if(screen->callbacks && screen->callbacks->damage)\n    (*screen->callbacks->damage)(emit, screen->cbdata);\n}\n\nstatic void damagescreen(VTermScreen *screen)\n{\n  VTermRect rect = {0,0,0,0};\n  rect.end_row = screen->rows;\n  rect.end_col = screen->cols;\n\n  damagerect(screen, rect);\n}\n\nstatic int putglyph(VTermGlyphInfo *info, VTermPos pos, void *user)\n{\n  int i;\n  int col;\n  VTermRect rect;\n\n  VTermScreen *screen = user;\n  ScreenCell *cell = getcell(screen, pos.row, pos.col);\n\n  if(!cell)\n    return 0;\n\n  for(i = 0; i < VTERM_MAX_CHARS_PER_CELL && info->chars[i]; i++) {\n    cell->chars[i] = info->chars[i];\n    cell->pen = screen->pen;\n  }\n  if(i < VTERM_MAX_CHARS_PER_CELL)\n    cell->chars[i] = 0;\n\n  for(col = 1; col < info->width; col++)\n    getcell(screen, pos.row, pos.col + col)->chars[0] = (uint32_t)-1;\n\n  rect.start_row = pos.row;\n  rect.end_row   = pos.row+1;\n  rect.start_col = pos.col;\n  rect.end_col   = pos.col+info->width;\n\n  cell->pen.protected_cell = info->protected_cell;\n  cell->pen.dwl            = info->dwl;\n  cell->pen.dhl            = info->dhl;\n\n  damagerect(screen, rect);\n\n  return 1;\n}\n\nstatic int moverect_internal(VTermRect dest, VTermRect src, void *user)\n{\n  VTermScreen *screen = user;\n\n  if(screen->callbacks && screen->callbacks->sb_pushline &&\n     dest.start_row == 0 && dest.start_col == 0 &&  // starts top-left corner\n     dest.end_col == screen->cols &&                // full width\n     screen->buffer == screen->buffers[0]) {        // not altscreen\n    VTermPos pos;\n    for(pos.row = 0; pos.row < src.start_row; pos.row++) {\n      for(pos.col = 0; pos.col < screen->cols; pos.col++)\n        (void)vterm_screen_get_cell(screen, pos, screen->sb_buffer + pos.col);\n\n      (screen->callbacks->sb_pushline)(screen->cols, screen->sb_buffer, screen->cbdata);\n    }\n  }\n\n  {\n    int cols = src.end_col - src.start_col;\n    int downward = src.start_row - dest.start_row;\n    int init_row, test_row, inc_row;\n    int row;\n\n    if(downward < 0) {\n      init_row = dest.end_row - 1;\n      test_row = dest.start_row - 1;\n      inc_row  = -1;\n    }\n    else {\n      init_row = dest.start_row;\n      test_row = dest.end_row;\n      inc_row  = +1;\n    }\n\n    for(row = init_row; row != test_row; row += inc_row)\n      memmove(getcell(screen, row, dest.start_col),\n\t      getcell(screen, row + downward, src.start_col),\n\t      cols * sizeof(ScreenCell));\n  }\n\n  return 1;\n}\n\nstatic int moverect_user(VTermRect dest, VTermRect src, void *user)\n{\n  VTermScreen *screen = user;\n\n  if(screen->callbacks && screen->callbacks->moverect) {\n    if(screen->damage_merge != VTERM_DAMAGE_SCROLL)\n      // Avoid an infinite loop\n      vterm_screen_flush_damage(screen);\n\n    if((*screen->callbacks->moverect)(dest, src, screen->cbdata))\n      return 1;\n  }\n\n  damagerect(screen, dest);\n\n  return 1;\n}\n\nstatic int erase_internal(VTermRect rect, int selective, void *user)\n{\n  VTermScreen *screen = user;\n  int row, col;\n\n  for(row = rect.start_row; row < screen->state->rows && row < rect.end_row; row++) {\n    const VTermLineInfo *info = vterm_state_get_lineinfo(screen->state, row);\n\n    for(col = rect.start_col; col < rect.end_col; col++) {\n      ScreenCell *cell = getcell(screen, row, col);\n\n      if(selective && cell->pen.protected_cell)\n        continue;\n\n      cell->chars[0] = 0;\n      cell->pen = screen->pen;\n      cell->pen.dwl = info->doublewidth;\n      cell->pen.dhl = info->doubleheight;\n    }\n  }\n\n  return 1;\n}\n\nstatic int erase_user(VTermRect rect, int selective UNUSED, void *user)\n{\n  VTermScreen *screen = user;\n\n  damagerect(screen, rect);\n\n  return 1;\n}\n\nstatic int erase(VTermRect rect, int selective, void *user)\n{\n  erase_internal(rect, selective, user);\n  return erase_user(rect, 0, user);\n}\n\nstatic int scrollrect(VTermRect rect, int downward, int rightward, void *user)\n{\n  VTermScreen *screen = user;\n\n  if(screen->damage_merge != VTERM_DAMAGE_SCROLL) {\n    vterm_scroll_rect(rect, downward, rightward,\n        moverect_internal, erase_internal, screen);\n\n    vterm_screen_flush_damage(screen);\n\n    vterm_scroll_rect(rect, downward, rightward,\n        moverect_user, erase_user, screen);\n\n    return 1;\n  }\n\n  if(screen->damaged.start_row != -1 &&\n     !rect_intersects(&rect, &screen->damaged)) {\n    vterm_screen_flush_damage(screen);\n  }\n\n  if(screen->pending_scrollrect.start_row == -1) {\n    screen->pending_scrollrect = rect;\n    screen->pending_scroll_downward  = downward;\n    screen->pending_scroll_rightward = rightward;\n  }\n  else if(rect_equal(&screen->pending_scrollrect, &rect) &&\n     ((screen->pending_scroll_downward  == 0 && downward  == 0) ||\n      (screen->pending_scroll_rightward == 0 && rightward == 0))) {\n    screen->pending_scroll_downward  += downward;\n    screen->pending_scroll_rightward += rightward;\n  }\n  else {\n    vterm_screen_flush_damage(screen);\n\n    screen->pending_scrollrect = rect;\n    screen->pending_scroll_downward  = downward;\n    screen->pending_scroll_rightward = rightward;\n  }\n\n  vterm_scroll_rect(rect, downward, rightward,\n      moverect_internal, erase_internal, screen);\n\n  if(screen->damaged.start_row == -1)\n    return 1;\n\n  if(rect_contains(&rect, &screen->damaged)) {\n    /* Scroll region entirely contains the damage; just move it */\n    vterm_rect_move(&screen->damaged, -downward, -rightward);\n    rect_clip(&screen->damaged, &rect);\n  }\n  /* There are a number of possible cases here, but lets restrict this to only\n   * the common case where we might actually gain some performance by\n   * optimising it. Namely, a vertical scroll that neatly cuts the damage\n   * region in half.\n   */\n  else if(rect.start_col <= screen->damaged.start_col &&\n          rect.end_col   >= screen->damaged.end_col &&\n          rightward == 0) {\n    if(screen->damaged.start_row >= rect.start_row &&\n       screen->damaged.start_row  < rect.end_row) {\n      screen->damaged.start_row -= downward;\n      if(screen->damaged.start_row < rect.start_row)\n        screen->damaged.start_row = rect.start_row;\n      if(screen->damaged.start_row > rect.end_row)\n        screen->damaged.start_row = rect.end_row;\n    }\n    if(screen->damaged.end_row >= rect.start_row &&\n       screen->damaged.end_row  < rect.end_row) {\n      screen->damaged.end_row -= downward;\n      if(screen->damaged.end_row < rect.start_row)\n        screen->damaged.end_row = rect.start_row;\n      if(screen->damaged.end_row > rect.end_row)\n        screen->damaged.end_row = rect.end_row;\n    }\n  }\n  else {\n    DEBUG_LOG2(\"TODO: Just flush and redo damaged=\" STRFrect \" rect=\" STRFrect \"\\n\",\n        ARGSrect(screen->damaged), ARGSrect(rect));\n  }\n\n  return 1;\n}\n\nstatic int movecursor(VTermPos pos, VTermPos oldpos, int visible, void *user)\n{\n  VTermScreen *screen = user;\n\n  if(screen->callbacks && screen->callbacks->movecursor)\n    return (*screen->callbacks->movecursor)(pos, oldpos, visible, screen->cbdata);\n\n  return 0;\n}\n\nstatic int setpenattr(VTermAttr attr, VTermValue *val, void *user)\n{\n  VTermScreen *screen = user;\n\n  switch(attr) {\n  case VTERM_ATTR_BOLD:\n    screen->pen.bold = val->boolean;\n    return 1;\n  case VTERM_ATTR_UNDERLINE:\n    screen->pen.underline = val->number;\n    return 1;\n  case VTERM_ATTR_ITALIC:\n    screen->pen.italic = val->boolean;\n    return 1;\n  case VTERM_ATTR_BLINK:\n    screen->pen.blink = val->boolean;\n    return 1;\n  case VTERM_ATTR_REVERSE:\n    screen->pen.reverse = val->boolean;\n    return 1;\n  case VTERM_ATTR_STRIKE:\n    screen->pen.strike = val->boolean;\n    return 1;\n  case VTERM_ATTR_FONT:\n    screen->pen.font = val->number;\n    return 1;\n  case VTERM_ATTR_FOREGROUND:\n    screen->pen.fg = val->color;\n    return 1;\n  case VTERM_ATTR_BACKGROUND:\n    screen->pen.bg = val->color;\n    return 1;\n\n  case VTERM_N_ATTRS:\n    return 0;\n  }\n\n  return 0;\n}\n\nstatic int settermprop(VTermProp prop, VTermValue *val, void *user)\n{\n  VTermScreen *screen = user;\n\n  switch(prop) {\n  case VTERM_PROP_ALTSCREEN:\n    if(val->boolean && !screen->buffers[1])\n      return 0;\n\n    screen->buffer = val->boolean ? screen->buffers[1] : screen->buffers[0];\n    /* only send a damage event on disable; because during enable there's an\n     * erase that sends a damage anyway\n     */\n    if(!val->boolean)\n      damagescreen(screen);\n    break;\n  case VTERM_PROP_REVERSE:\n    screen->global_reverse = val->boolean;\n    damagescreen(screen);\n    break;\n  default:\n    ; /* ignore */\n  }\n\n  if(screen->callbacks && screen->callbacks->settermprop)\n    return (*screen->callbacks->settermprop)(prop, val, screen->cbdata);\n\n  return 1;\n}\n\nstatic int bell(void *user)\n{\n  VTermScreen *screen = user;\n\n  if(screen->callbacks && screen->callbacks->bell)\n    return (*screen->callbacks->bell)(screen->cbdata);\n\n  return 0;\n}\n\nstatic int resize(int new_rows, int new_cols, VTermPos *delta, void *user)\n{\n  VTermScreen *screen = user;\n\n  int is_altscreen = (screen->buffers[1] && screen->buffer == screen->buffers[1]);\n\n  int old_rows = screen->rows;\n  int old_cols = screen->cols;\n  int first_blank_row;\n\n  if(!is_altscreen && new_rows < old_rows) {\n    // Fewer rows - determine if we're going to scroll at all, and if so, push\n    // those lines to scrollback\n    VTermPos pos = { 0, 0 };\n    VTermPos cursor = screen->state->pos;\n    // Find the first blank row after the cursor.\n    for(pos.row = old_rows - 1; pos.row >= new_rows; pos.row--)\n      if(!vterm_screen_is_eol(screen, pos) || cursor.row == pos.row)\n        break;\n\n    first_blank_row = pos.row + 1;\n    if(first_blank_row > new_rows) {\n      VTermRect rect = {0,0,0,0};\n      rect.end_row   = old_rows;\n      rect.end_col   = old_cols;\n      scrollrect(rect, first_blank_row - new_rows, 0, user);\n      vterm_screen_flush_damage(screen);\n\n      delta->row -= first_blank_row - new_rows;\n    }\n  }\n\n  screen->buffers[0] = realloc_buffer(screen, screen->buffers[0], new_rows, new_cols);\n  if(screen->buffers[1])\n    screen->buffers[1] = realloc_buffer(screen, screen->buffers[1], new_rows, new_cols);\n\n  screen->buffer = is_altscreen ? screen->buffers[1] : screen->buffers[0];\n\n  screen->rows = new_rows;\n  screen->cols = new_cols;\n\n  vterm_allocator_free(screen->vt, screen->sb_buffer);\n\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * new_cols);\n\n  if(new_cols > old_cols) {\n    VTermRect rect;\n    rect.start_row = 0;\n    rect.end_row   = old_rows;\n    rect.start_col = old_cols;\n    rect.end_col   = new_cols;\n    damagerect(screen, rect);\n  }\n\n  if(new_rows > old_rows) {\n    if(!is_altscreen && screen->callbacks && screen->callbacks->sb_popline) {\n      int rows = new_rows - old_rows;\n      while(rows) {\n        VTermRect rect = {0,0,0,0};\n        VTermPos pos = { 0, 0 };\n        if(!(screen->callbacks->sb_popline(screen->cols, screen->sb_buffer, screen->cbdata)))\n          break;\n\n\trect.end_row   = screen->rows;\n\trect.end_col   = screen->cols;\n        scrollrect(rect, -1, 0, user);\n\n        for(pos.col = 0; pos.col < screen->cols; pos.col += screen->sb_buffer[pos.col].width)\n          vterm_screen_set_cell(screen, pos, screen->sb_buffer + pos.col);\n\n        rect.end_row = 1;\n        damagerect(screen, rect);\n\n        vterm_screen_flush_damage(screen);\n\n        rows--;\n        delta->row++;\n      }\n    }\n\n    {\n      VTermRect rect;\n      rect.start_row = old_rows;\n      rect.end_row   = new_rows;\n      rect.start_col = 0;\n      rect.end_col   = new_cols;\n      damagerect(screen, rect);\n    }\n  }\n\n  if(screen->callbacks && screen->callbacks->resize)\n    return (*screen->callbacks->resize)(new_rows, new_cols, screen->cbdata);\n\n  return 1;\n}\n\nstatic int setlineinfo(int row, const VTermLineInfo *newinfo, const VTermLineInfo *oldinfo, void *user)\n{\n  VTermScreen *screen = user;\n  int col;\n  VTermRect rect;\n\n  if(newinfo->doublewidth != oldinfo->doublewidth ||\n     newinfo->doubleheight != oldinfo->doubleheight) {\n    for(col = 0; col < screen->cols; col++) {\n      ScreenCell *cell = getcell(screen, row, col);\n      cell->pen.dwl = newinfo->doublewidth;\n      cell->pen.dhl = newinfo->doubleheight;\n    }\n\n    rect.start_row = row;\n    rect.end_row   = row + 1;\n    rect.start_col = 0;\n    rect.end_col   = newinfo->doublewidth ? screen->cols / 2 : screen->cols;\n    damagerect(screen, rect);\n\n    if(newinfo->doublewidth) {\n      rect.start_col = screen->cols / 2;\n      rect.end_col   = screen->cols;\n\n      erase_internal(rect, 0, user);\n    }\n  }\n\n  return 1;\n}\n\nstatic VTermStateCallbacks state_cbs = {\n  &putglyph, /* putglyph */\n  &movecursor, /* movecursor */\n  &scrollrect, /* scrollrect */\n  NULL, /* moverect */\n  &erase, /* erase */\n  NULL, /* initpen */\n  &setpenattr, /* setpenattr */\n  &settermprop, /* settermprop */\n  &bell, /* bell */\n  &resize, /* resize */\n  &setlineinfo /* setlineinfo */\n};\n\n/*\n * Allocate a new screen and return it.\n * Return NULL when out of memory.\n */\nstatic VTermScreen *screen_new(VTerm *vt)\n{\n  VTermState *state = vterm_obtain_state(vt);\n  VTermScreen *screen;\n  int rows, cols;\n\n  if (state == NULL)\n    return NULL;\n  screen = vterm_allocator_malloc(vt, sizeof(VTermScreen));\n  if (screen == NULL)\n    return NULL;\n\n  vterm_get_size(vt, &rows, &cols);\n\n  screen->vt = vt;\n  screen->state = state;\n\n  screen->damage_merge = VTERM_DAMAGE_CELL;\n  screen->damaged.start_row = -1;\n  screen->pending_scrollrect.start_row = -1;\n\n  screen->rows = rows;\n  screen->cols = cols;\n\n  screen->callbacks = NULL;\n  screen->cbdata    = NULL;\n\n  screen->buffers[0] = realloc_buffer(screen, NULL, rows, cols);\n  screen->buffer = screen->buffers[0];\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols);\n  if (screen->buffer == NULL || screen->sb_buffer == NULL)\n  {\n    vterm_screen_free(screen);\n    return NULL;\n  }\n\n  vterm_state_set_callbacks(screen->state, &state_cbs, screen);\n\n  return screen;\n}\n\nINTERNAL void vterm_screen_free(VTermScreen *screen)\n{\n  vterm_allocator_free(screen->vt, screen->buffers[0]);\n  vterm_allocator_free(screen->vt, screen->buffers[1]);\n  vterm_allocator_free(screen->vt, screen->sb_buffer);\n  vterm_allocator_free(screen->vt, screen);\n}\n\nvoid vterm_screen_reset(VTermScreen *screen, int hard)\n{\n  screen->damaged.start_row = -1;\n  screen->pending_scrollrect.start_row = -1;\n  vterm_state_reset(screen->state, hard);\n  vterm_screen_flush_damage(screen);\n}\n\nstatic size_t _get_chars(const VTermScreen *screen, const int utf8, void *buffer, size_t len, const VTermRect rect)\n{\n  size_t outpos = 0;\n  int padding = 0;\n  int row, col;\n\n#define PUT(c)                                             \\\n  if(utf8) {                                               \\\n    size_t thislen = utf8_seqlen(c);                       \\\n    if(buffer && outpos + thislen <= len)                  \\\n      outpos += fill_utf8((c), (char *)buffer + outpos);   \\\n    else                                                   \\\n      outpos += thislen;                                   \\\n  }                                                        \\\n  else {                                                   \\\n    if(buffer && outpos + 1 <= len)                        \\\n      ((uint32_t*)buffer)[outpos++] = (c);                 \\\n    else                                                   \\\n      outpos++;                                            \\\n  }\n\n  for(row = rect.start_row; row < rect.end_row; row++) {\n    for(col = rect.start_col; col < rect.end_col; col++) {\n      ScreenCell *cell = getcell(screen, row, col);\n      int i;\n\n      if(cell->chars[0] == 0)\n        // Erased cell, might need a space\n        padding++;\n      else if(cell->chars[0] == (uint32_t)-1)\n        // Gap behind a double-width char, do nothing\n        ;\n      else {\n        while(padding) {\n          PUT(UNICODE_SPACE);\n          padding--;\n        }\n        for(i = 0; i < VTERM_MAX_CHARS_PER_CELL && cell->chars[i]; i++) {\n          PUT(cell->chars[i]);\n        }\n      }\n    }\n\n    if(row < rect.end_row - 1) {\n      PUT(UNICODE_LINEFEED);\n      padding = 0;\n    }\n  }\n\n  return outpos;\n}\n\nsize_t vterm_screen_get_chars(const VTermScreen *screen, uint32_t *chars, size_t len, const VTermRect rect)\n{\n  return _get_chars(screen, 0, chars, len, rect);\n}\n\nsize_t vterm_screen_get_text(const VTermScreen *screen, char *str, size_t len, const VTermRect rect)\n{\n  return _get_chars(screen, 1, str, len, rect);\n}\n\n/* Copy internal to external representation of a screen cell */\nint vterm_screen_get_cell(const VTermScreen *screen, VTermPos pos, VTermScreenCell *cell)\n{\n  ScreenCell *intcell = getcell(screen, pos.row, pos.col);\n  int i;\n\n  if(!intcell)\n    return 0;\n\n  for(i = 0; ; i++) {\n    cell->chars[i] = intcell->chars[i];\n    if(!intcell->chars[i])\n      break;\n  }\n\n  cell->attrs.bold      = intcell->pen.bold;\n  cell->attrs.underline = intcell->pen.underline;\n  cell->attrs.italic    = intcell->pen.italic;\n  cell->attrs.blink     = intcell->pen.blink;\n  cell->attrs.reverse   = intcell->pen.reverse ^ screen->global_reverse;\n  cell->attrs.strike    = intcell->pen.strike;\n  cell->attrs.font      = intcell->pen.font;\n\n  cell->attrs.dwl = intcell->pen.dwl;\n  cell->attrs.dhl = intcell->pen.dhl;\n\n  cell->fg = intcell->pen.fg;\n  cell->bg = intcell->pen.bg;\n\n  if(pos.col < (screen->cols - 1) &&\n     getcell(screen, pos.row, pos.col + 1)->chars[0] == (uint32_t)-1)\n    cell->width = 2;\n  else\n    cell->width = 1;\n\n  return 1;\n}\n\n/* Copy external to internal representation of a screen cell */\n/* static because it's only used internally for sb_popline during resize */\nstatic int vterm_screen_set_cell(VTermScreen *screen, VTermPos pos, const VTermScreenCell *cell)\n{\n  ScreenCell *intcell = getcell(screen, pos.row, pos.col);\n  int i;\n\n  if(!intcell)\n    return 0;\n\n  for(i = 0; ; i++) {\n    intcell->chars[i] = cell->chars[i];\n    if(!cell->chars[i])\n      break;\n  }\n\n  intcell->pen.bold      = cell->attrs.bold;\n  intcell->pen.underline = cell->attrs.underline;\n  intcell->pen.italic    = cell->attrs.italic;\n  intcell->pen.blink     = cell->attrs.blink;\n  intcell->pen.reverse   = cell->attrs.reverse ^ screen->global_reverse;\n  intcell->pen.strike    = cell->attrs.strike;\n  intcell->pen.font      = cell->attrs.font;\n\n  intcell->pen.fg = cell->fg;\n  intcell->pen.bg = cell->bg;\n\n  if(cell->width == 2)\n    getcell(screen, pos.row, pos.col + 1)->chars[0] = (uint32_t)-1;\n\n  return 1;\n}\n\nint vterm_screen_is_eol(const VTermScreen *screen, VTermPos pos)\n{\n  /* This cell is EOL if this and every cell to the right is black */\n  for(; pos.col < screen->cols; pos.col++) {\n    ScreenCell *cell = getcell(screen, pos.row, pos.col);\n    if(cell->chars[0] != 0)\n      return 0;\n  }\n\n  return 1;\n}\n\nVTermScreen *vterm_obtain_screen(VTerm *vt)\n{\n  if(!vt->screen)\n    vt->screen = screen_new(vt);\n  return vt->screen;\n}\n\nvoid vterm_screen_enable_altscreen(VTermScreen *screen, int altscreen)\n{\n\n  if(!screen->buffers[1] && altscreen) {\n    int rows, cols;\n    vterm_get_size(screen->vt, &rows, &cols);\n\n    screen->buffers[1] = realloc_buffer(screen, NULL, rows, cols);\n  }\n}\n\nvoid vterm_screen_set_callbacks(VTermScreen *screen, const VTermScreenCallbacks *callbacks, void *user)\n{\n  screen->callbacks = callbacks;\n  screen->cbdata = user;\n}\n\nvoid *vterm_screen_get_cbdata(VTermScreen *screen)\n{\n  return screen->cbdata;\n}\n\nvoid vterm_screen_set_unrecognised_fallbacks(VTermScreen *screen, const VTermParserCallbacks *fallbacks, void *user)\n{\n  vterm_state_set_unrecognised_fallbacks(screen->state, fallbacks, user);\n}\n\nvoid *vterm_screen_get_unrecognised_fbdata(VTermScreen *screen)\n{\n  return vterm_state_get_unrecognised_fbdata(screen->state);\n}\n\nvoid vterm_screen_flush_damage(VTermScreen *screen)\n{\n  if(screen->pending_scrollrect.start_row != -1) {\n    vterm_scroll_rect(screen->pending_scrollrect, screen->pending_scroll_downward, screen->pending_scroll_rightward,\n        moverect_user, erase_user, screen);\n\n    screen->pending_scrollrect.start_row = -1;\n  }\n\n  if(screen->damaged.start_row != -1) {\n    if(screen->callbacks && screen->callbacks->damage)\n      (*screen->callbacks->damage)(screen->damaged, screen->cbdata);\n\n    screen->damaged.start_row = -1;\n  }\n}\n\nvoid vterm_screen_set_damage_merge(VTermScreen *screen, VTermDamageSize size)\n{\n  vterm_screen_flush_damage(screen);\n  screen->damage_merge = size;\n}\n\nstatic int attrs_differ(VTermAttrMask attrs, ScreenCell *a, ScreenCell *b)\n{\n  if((attrs & VTERM_ATTR_BOLD_MASK)       && (a->pen.bold != b->pen.bold))\n    return 1;\n  if((attrs & VTERM_ATTR_UNDERLINE_MASK)  && (a->pen.underline != b->pen.underline))\n    return 1;\n  if((attrs & VTERM_ATTR_ITALIC_MASK)     && (a->pen.italic != b->pen.italic))\n    return 1;\n  if((attrs & VTERM_ATTR_BLINK_MASK)      && (a->pen.blink != b->pen.blink))\n    return 1;\n  if((attrs & VTERM_ATTR_REVERSE_MASK)    && (a->pen.reverse != b->pen.reverse))\n    return 1;\n  if((attrs & VTERM_ATTR_STRIKE_MASK)     && (a->pen.strike != b->pen.strike))\n    return 1;\n  if((attrs & VTERM_ATTR_FONT_MASK)       && (a->pen.font != b->pen.font))\n    return 1;\n  if((attrs & VTERM_ATTR_FOREGROUND_MASK) && !vterm_color_equal(a->pen.fg, b->pen.fg))\n    return 1;\n  if((attrs & VTERM_ATTR_BACKGROUND_MASK) && !vterm_color_equal(a->pen.bg, b->pen.bg))\n    return 1;\n\n  return 0;\n}\n\nint vterm_screen_get_attrs_extent(const VTermScreen *screen, VTermRect *extent, VTermPos pos, VTermAttrMask attrs)\n{\n  int col;\n\n  ScreenCell *target = getcell(screen, pos.row, pos.col);\n\n  // TODO: bounds check\n  extent->start_row = pos.row;\n  extent->end_row   = pos.row + 1;\n\n  if(extent->start_col < 0)\n    extent->start_col = 0;\n  if(extent->end_col < 0)\n    extent->end_col = screen->cols;\n\n  for(col = pos.col - 1; col >= extent->start_col; col--)\n    if(attrs_differ(attrs, target, getcell(screen, pos.row, col)))\n      break;\n  extent->start_col = col + 1;\n\n  for(col = pos.col + 1; col < extent->end_col; col++)\n    if(attrs_differ(attrs, target, getcell(screen, pos.row, col)))\n      break;\n  extent->end_col = col - 1;\n\n  return 1;\n}\n", "#define DEFINE_INLINES\n\n/* vim: set sw=2 : */\n#include \"vterm_internal.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n\n#include \"utf8.h\"\n\n/*****************\n * API functions *\n *****************/\n\nstatic void *default_malloc(size_t size, void *allocdata UNUSED)\n{\n  void *ptr = malloc(size);\n  if(ptr)\n    memset(ptr, 0, size);\n  return ptr;\n}\n\nstatic void default_free(void *ptr, void *allocdata UNUSED)\n{\n  free(ptr);\n}\n\nstatic VTermAllocatorFunctions default_allocator = {\n  &default_malloc, // malloc\n  &default_free // free\n};\n\nVTerm *vterm_new(int rows, int cols)\n{\n  return vterm_new_with_allocator(rows, cols, &default_allocator, NULL);\n}\n\nVTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)\n{\n  /* Need to bootstrap using the allocator function directly */\n  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);\n\n  if (vt == NULL)\n    return NULL;\n  vt->allocator = funcs;\n  vt->allocdata = allocdata;\n\n  vt->rows = rows;\n  vt->cols = cols;\n\n  vt->parser.state = NORMAL;\n\n  vt->parser.callbacks = NULL;\n  vt->parser.cbdata    = NULL;\n\n  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */\n  vt->parser.strbuffer_cur = 0;\n  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);\n  if (vt->parser.strbuffer == NULL)\n  {\n    vterm_allocator_free(vt, vt);\n    return NULL;\n  }\n\n  vt->outbuffer_len = 200;\n  vt->outbuffer_cur = 0;\n  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);\n  if (vt->outbuffer == NULL)\n  {\n    vterm_allocator_free(vt, vt->parser.strbuffer);\n    vterm_allocator_free(vt, vt);\n    return NULL;\n  }\n\n  return vt;\n}\n\nvoid vterm_free(VTerm *vt)\n{\n  if(vt->screen)\n    vterm_screen_free(vt->screen);\n\n  if(vt->state)\n    vterm_state_free(vt->state);\n\n  vterm_allocator_free(vt, vt->parser.strbuffer);\n  vterm_allocator_free(vt, vt->outbuffer);\n\n  vterm_allocator_free(vt, vt);\n}\n\nINTERNAL void *vterm_allocator_malloc(VTerm *vt, size_t size)\n{\n  return (*vt->allocator->malloc)(size, vt->allocdata);\n}\n\n/*\n * Free \"ptr\" unless it is NULL.\n */\nINTERNAL void vterm_allocator_free(VTerm *vt, void *ptr)\n{\n  if (ptr)\n    (*vt->allocator->free)(ptr, vt->allocdata);\n}\n\nvoid vterm_get_size(const VTerm *vt, int *rowsp, int *colsp)\n{\n  if(rowsp)\n    *rowsp = vt->rows;\n  if(colsp)\n    *colsp = vt->cols;\n}\n\nvoid vterm_set_size(VTerm *vt, int rows, int cols)\n{\n  vt->rows = rows;\n  vt->cols = cols;\n\n  if(vt->parser.callbacks && vt->parser.callbacks->resize)\n    (*vt->parser.callbacks->resize)(rows, cols, vt->parser.cbdata);\n}\n\nint vterm_get_utf8(const VTerm *vt)\n{\n  return vt->mode.utf8;\n}\n\nvoid vterm_set_utf8(VTerm *vt, int is_utf8)\n{\n  vt->mode.utf8 = is_utf8;\n}\n\nINTERNAL void vterm_push_output_bytes(VTerm *vt, const char *bytes, size_t len)\n{\n  if(len > vt->outbuffer_len - vt->outbuffer_cur) {\n    DEBUG_LOG(\"vterm_push_output(): buffer overflow; truncating output\\n\");\n    len = vt->outbuffer_len - vt->outbuffer_cur;\n  }\n\n  memcpy(vt->outbuffer + vt->outbuffer_cur, bytes, len);\n  vt->outbuffer_cur += len;\n}\n\nstatic int outbuffer_is_full(VTerm *vt)\n{\n  return vt->outbuffer_cur >= vt->outbuffer_len - 1;\n}\n\n#if (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 500) \\\n\t|| defined(_ISOC99_SOURCE) || defined(_BSD_SOURCE)\n# undef VSNPRINTF\n# define VSNPRINTF vsnprintf\n#else\n# ifdef VSNPRINTF\n/* Use a provided vsnprintf() function. */\nint VSNPRINTF(char *str, size_t str_m, const char *fmt, va_list ap);\n# endif\n#endif\n\n\nINTERNAL void vterm_push_output_vsprintf(VTerm *vt, const char *format, va_list args)\n{\n  int written;\n#ifndef VSNPRINTF\n  /* When vsnprintf() is not available (C90) fall back to vsprintf(). */\n  char buffer[1024]; /* 1Kbyte is enough for everybody, right? */\n#endif\n\n  if(outbuffer_is_full(vt)) {\n    DEBUG_LOG(\"vterm_push_output(): buffer overflow; truncating output\\n\");\n    return;\n  }\n\n#ifdef VSNPRINTF\n  written = VSNPRINTF(vt->outbuffer + vt->outbuffer_cur,\n      vt->outbuffer_len - vt->outbuffer_cur,\n      format, args);\n\n  if(written == (int)(vt->outbuffer_len - vt->outbuffer_cur)) {\n    /* output was truncated */\n    vt->outbuffer_cur = vt->outbuffer_len - 1;\n  }\n  else\n    vt->outbuffer_cur += written;\n#else\n  written = vsprintf(buffer, format, args);\n\n  if(written >= (int)(vt->outbuffer_len - vt->outbuffer_cur - 1)) {\n    /* output was truncated */\n    written = vt->outbuffer_len - vt->outbuffer_cur - 1;\n  }\n  if (written > 0)\n  {\n    strncpy(vt->outbuffer + vt->outbuffer_cur, buffer, written + 1);\n    vt->outbuffer_cur += written;\n  }\n#endif\n}\n\nINTERNAL void vterm_push_output_sprintf(VTerm *vt, const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n  vterm_push_output_vsprintf(vt, format, args);\n  va_end(args);\n}\n\nINTERNAL void vterm_push_output_sprintf_ctrl(VTerm *vt, unsigned char ctrl, const char *fmt, ...)\n{\n  size_t orig_cur = vt->outbuffer_cur;\n  va_list args;\n\n  if(ctrl >= 0x80 && !vt->mode.ctrl8bit)\n    vterm_push_output_sprintf(vt, ESC_S \"%c\", ctrl - 0x40);\n  else\n    vterm_push_output_sprintf(vt, \"%c\", ctrl);\n\n  va_start(args, fmt);\n  vterm_push_output_vsprintf(vt, fmt, args);\n  va_end(args);\n\n  if(outbuffer_is_full(vt))\n    vt->outbuffer_cur = orig_cur;\n}\n\nINTERNAL void vterm_push_output_sprintf_dcs(VTerm *vt, const char *fmt, ...)\n{\n  size_t orig_cur = vt->outbuffer_cur;\n  va_list args;\n\n  if(!vt->mode.ctrl8bit)\n    vterm_push_output_sprintf(vt, ESC_S \"%c\", C1_DCS - 0x40);\n  else\n    vterm_push_output_sprintf(vt, \"%c\", C1_DCS);\n\n  va_start(args, fmt);\n  vterm_push_output_vsprintf(vt, fmt, args);\n  va_end(args);\n\n  vterm_push_output_sprintf_ctrl(vt, C1_ST, \"\");\n\n  if(outbuffer_is_full(vt))\n    vt->outbuffer_cur = orig_cur;\n}\n\nsize_t vterm_output_get_buffer_size(const VTerm *vt)\n{\n  return vt->outbuffer_len;\n}\n\nsize_t vterm_output_get_buffer_current(const VTerm *vt)\n{\n  return vt->outbuffer_cur;\n}\n\nsize_t vterm_output_get_buffer_remaining(const VTerm *vt)\n{\n  return vt->outbuffer_len - vt->outbuffer_cur;\n}\n\nsize_t vterm_output_read(VTerm *vt, char *buffer, size_t len)\n{\n  if(len > vt->outbuffer_cur)\n    len = vt->outbuffer_cur;\n\n  memcpy(buffer, vt->outbuffer, len);\n\n  if(len < vt->outbuffer_cur)\n    memmove(vt->outbuffer, vt->outbuffer + len, vt->outbuffer_cur - len);\n\n  vt->outbuffer_cur -= len;\n\n  return len;\n}\n\nVTermValueType vterm_get_attr_type(VTermAttr attr)\n{\n  switch(attr) {\n    case VTERM_ATTR_BOLD:       return VTERM_VALUETYPE_BOOL;\n    case VTERM_ATTR_UNDERLINE:  return VTERM_VALUETYPE_INT;\n    case VTERM_ATTR_ITALIC:     return VTERM_VALUETYPE_BOOL;\n    case VTERM_ATTR_BLINK:      return VTERM_VALUETYPE_BOOL;\n    case VTERM_ATTR_REVERSE:    return VTERM_VALUETYPE_BOOL;\n    case VTERM_ATTR_STRIKE:     return VTERM_VALUETYPE_BOOL;\n    case VTERM_ATTR_FONT:       return VTERM_VALUETYPE_INT;\n    case VTERM_ATTR_FOREGROUND: return VTERM_VALUETYPE_COLOR;\n    case VTERM_ATTR_BACKGROUND: return VTERM_VALUETYPE_COLOR;\n\n    case VTERM_N_ATTRS: return 0;\n  }\n  return 0; /* UNREACHABLE */\n}\n\nVTermValueType vterm_get_prop_type(VTermProp prop)\n{\n  switch(prop) {\n    case VTERM_PROP_CURSORVISIBLE: return VTERM_VALUETYPE_BOOL;\n    case VTERM_PROP_CURSORBLINK:   return VTERM_VALUETYPE_BOOL;\n    case VTERM_PROP_ALTSCREEN:     return VTERM_VALUETYPE_BOOL;\n    case VTERM_PROP_TITLE:         return VTERM_VALUETYPE_STRING;\n    case VTERM_PROP_ICONNAME:      return VTERM_VALUETYPE_STRING;\n    case VTERM_PROP_REVERSE:       return VTERM_VALUETYPE_BOOL;\n    case VTERM_PROP_CURSORSHAPE:   return VTERM_VALUETYPE_INT;\n    case VTERM_PROP_MOUSE:         return VTERM_VALUETYPE_INT;\n    case VTERM_PROP_CURSORCOLOR:   return VTERM_VALUETYPE_STRING;\n\n    case VTERM_N_PROPS: return 0;\n  }\n  return 0; /* UNREACHABLE */\n}\n\nvoid vterm_scroll_rect(VTermRect rect,\n    int downward,\n    int rightward,\n    int (*moverect)(VTermRect src, VTermRect dest, void *user),\n    int (*eraserect)(VTermRect rect, int selective, void *user),\n    void *user)\n{\n  VTermRect src;\n  VTermRect dest;\n\n  if(abs(downward)  >= rect.end_row - rect.start_row ||\n     abs(rightward) >= rect.end_col - rect.start_col) {\n    /* Scroll more than area; just erase the lot */\n    (*eraserect)(rect, 0, user);\n    return;\n  }\n\n  if(rightward >= 0) {\n    /* rect: [XXX................]\n     * src:     [----------------]\n     * dest: [----------------]\n     */\n    dest.start_col = rect.start_col;\n    dest.end_col   = rect.end_col   - rightward;\n    src.start_col  = rect.start_col + rightward;\n    src.end_col    = rect.end_col;\n  }\n  else {\n    /* rect: [................XXX]\n     * src:  [----------------]\n     * dest:    [----------------]\n     */\n    int leftward = -rightward;\n    dest.start_col = rect.start_col + leftward;\n    dest.end_col   = rect.end_col;\n    src.start_col  = rect.start_col;\n    src.end_col    = rect.end_col - leftward;\n  }\n\n  if(downward >= 0) {\n    dest.start_row = rect.start_row;\n    dest.end_row   = rect.end_row   - downward;\n    src.start_row  = rect.start_row + downward;\n    src.end_row    = rect.end_row;\n  }\n  else {\n    int upward = -downward;\n    dest.start_row = rect.start_row + upward;\n    dest.end_row   = rect.end_row;\n    src.start_row  = rect.start_row;\n    src.end_row    = rect.end_row - upward;\n  }\n\n  if(moverect)\n    (*moverect)(dest, src, user);\n\n  if(downward > 0)\n    rect.start_row = rect.end_row - downward;\n  else if(downward < 0)\n    rect.end_row = rect.start_row - downward;\n\n  if(rightward > 0)\n    rect.start_col = rect.end_col - rightward;\n  else if(rightward < 0)\n    rect.end_col = rect.start_col - rightward;\n\n  (*eraserect)(rect, 0, user);\n}\n\nvoid vterm_copy_cells(VTermRect dest,\n    VTermRect src,\n    void (*copycell)(VTermPos dest, VTermPos src, void *user),\n    void *user)\n{\n  int downward  = src.start_row - dest.start_row;\n  int rightward = src.start_col - dest.start_col;\n\n  int init_row, test_row, init_col, test_col;\n  int inc_row, inc_col;\n\n  VTermPos pos;\n\n  if(downward < 0) {\n    init_row = dest.end_row - 1;\n    test_row = dest.start_row - 1;\n    inc_row = -1;\n  }\n  else /* downward >= 0 */ {\n    init_row = dest.start_row;\n    test_row = dest.end_row;\n    inc_row = +1;\n  }\n\n  if(rightward < 0) {\n    init_col = dest.end_col - 1;\n    test_col = dest.start_col - 1;\n    inc_col = -1;\n  }\n  else /* rightward >= 0 */ {\n    init_col = dest.start_col;\n    test_col = dest.end_col;\n    inc_col = +1;\n  }\n\n  for(pos.row = init_row; pos.row != test_row; pos.row += inc_row)\n    for(pos.col = init_col; pos.col != test_col; pos.col += inc_col) {\n      VTermPos srcpos;\n      srcpos.row = pos.row + downward;\n      srcpos.col = pos.col + rightward;\n      (*copycell)(pos, srcpos, user);\n    }\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * Terminal window support, see \":help :terminal\".\n *\n * There are three parts:\n * 1. Generic code for all systems.\n *    Uses libvterm for the terminal emulator.\n * 2. The MS-Windows implementation.\n *    Uses winpty.\n * 3. The Unix-like implementation.\n *    Uses pseudo-tty's (pty's).\n *\n * For each terminal one VTerm is constructed.  This uses libvterm.  A copy of\n * this library is in the libvterm directory.\n *\n * When a terminal window is opened, a job is started that will be connected to\n * the terminal emulator.\n *\n * If the terminal window has keyboard focus, typed keys are converted to the\n * terminal encoding and writing to the job over a channel.\n *\n * If the job produces output, it is written to the terminal emulator.  The\n * terminal emulator invokes callbacks when its screen content changes.  The\n * line range is stored in tl_dirty_row_start and tl_dirty_row_end.  Once in a\n * while, if the terminal window is visible, the screen contents is drawn.\n *\n * When the job ends the text is put in a buffer.  Redrawing then happens from\n * that buffer, attributes come from the scrollback buffer tl_scrollback.\n * When the buffer is changed it is turned into a normal buffer, the attributes\n * in tl_scrollback are no longer used.\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n\n#ifndef MIN\n# define MIN(x,y) ((x) < (y) ? (x) : (y))\n#endif\n#ifndef MAX\n# define MAX(x,y) ((x) > (y) ? (x) : (y))\n#endif\n\n#include \"libvterm/include/vterm.h\"\n\n/* This is VTermScreenCell without the characters, thus much smaller. */\ntypedef struct {\n  VTermScreenCellAttrs\tattrs;\n  char\t\t\twidth;\n  VTermColor\t\tfg;\n  VTermColor\t\tbg;\n} cellattr_T;\n\ntypedef struct sb_line_S {\n    int\t\tsb_cols;\t/* can differ per line */\n    cellattr_T\t*sb_cells;\t/* allocated */\n    cellattr_T\tsb_fill_attr;\t/* for short line */\n} sb_line_T;\n\n/* typedef term_T in structs.h */\nstruct terminal_S {\n    term_T\t*tl_next;\n\n    VTerm\t*tl_vterm;\n    job_T\t*tl_job;\n    buf_T\t*tl_buffer;\n#if defined(FEAT_GUI)\n    int\t\ttl_system;\t/* when non-zero used for :!cmd output */\n    int\t\ttl_toprow;\t/* row with first line of system terminal */\n#endif\n\n    /* Set when setting the size of a vterm, reset after redrawing. */\n    int\t\ttl_vterm_size_changed;\n\n    int\t\ttl_normal_mode; /* TRUE: Terminal-Normal mode */\n    int\t\ttl_channel_closed;\n    int\t\ttl_channel_recently_closed; // still need to handle tl_finish\n\n    int\t\ttl_finish;\n#define TL_FINISH_UNSET\t    NUL\n#define TL_FINISH_CLOSE\t    'c'\t/* ++close or :terminal without argument */\n#define TL_FINISH_NOCLOSE   'n'\t/* ++noclose */\n#define TL_FINISH_OPEN\t    'o'\t/* ++open */\n    char_u\t*tl_opencmd;\n    char_u\t*tl_eof_chars;\n\n#ifdef WIN3264\n    void\t*tl_winpty_config;\n    void\t*tl_winpty;\n\n    FILE\t*tl_out_fd;\n#endif\n#if defined(FEAT_SESSION)\n    char_u\t*tl_command;\n#endif\n    char_u\t*tl_kill;\n\n    /* last known vterm size */\n    int\t\ttl_rows;\n    int\t\ttl_cols;\n\n    char_u\t*tl_title; /* NULL or allocated */\n    char_u\t*tl_status_text; /* NULL or allocated */\n\n    /* Range of screen rows to update.  Zero based. */\n    int\t\ttl_dirty_row_start; /* MAX_ROW if nothing dirty */\n    int\t\ttl_dirty_row_end;   /* row below last one to update */\n    int\t\ttl_dirty_snapshot;  /* text updated after making snapshot */\n#ifdef FEAT_TIMERS\n    int\t\ttl_timer_set;\n    proftime_T\ttl_timer_due;\n#endif\n    int\t\ttl_postponed_scroll;\t/* to be scrolled up */\n\n    garray_T\ttl_scrollback;\n    int\t\ttl_scrollback_scrolled;\n    cellattr_T\ttl_default_color;\n\n    linenr_T\ttl_top_diff_rows;   /* rows of top diff file or zero */\n    linenr_T\ttl_bot_diff_rows;   /* rows of bottom diff file */\n\n    VTermPos\ttl_cursor_pos;\n    int\t\ttl_cursor_visible;\n    int\t\ttl_cursor_blink;\n    int\t\ttl_cursor_shape;  /* 1: block, 2: underline, 3: bar */\n    char_u\t*tl_cursor_color; /* NULL or allocated */\n\n    int\t\ttl_using_altscreen;\n};\n\n#define TMODE_ONCE 1\t    /* CTRL-\\ CTRL-N used */\n#define TMODE_LOOP 2\t    /* CTRL-W N used */\n\n/*\n * List of all active terminals.\n */\nstatic term_T *first_term = NULL;\n\n/* Terminal active in terminal_loop(). */\nstatic term_T *in_terminal_loop = NULL;\n\n#define MAX_ROW 999999\t    /* used for tl_dirty_row_end to update all rows */\n#define KEY_BUF_LEN 200\n\n/*\n * Functions with separate implementation for MS-Windows and Unix-like systems.\n */\nstatic int term_and_job_init(term_T *term, typval_T *argvar, char **argv, jobopt_T *opt, jobopt_T *orig_opt);\nstatic int create_pty_only(term_T *term, jobopt_T *opt);\nstatic void term_report_winsize(term_T *term, int rows, int cols);\nstatic void term_free_vterm(term_T *term);\n#ifdef FEAT_GUI\nstatic void update_system_term(term_T *term);\n#endif\n\n/* The character that we know (or assume) that the terminal expects for the\n * backspace key. */\nstatic int term_backspace_char = BS;\n\n/* \"Terminal\" highlight group colors. */\nstatic int term_default_cterm_fg = -1;\nstatic int term_default_cterm_bg = -1;\n\n/* Store the last set and the desired cursor properties, so that we only update\n * them when needed.  Doing it unnecessary may result in flicker. */\nstatic char_u\t*last_set_cursor_color = NULL;\nstatic char_u\t*desired_cursor_color = NULL;\nstatic int\tlast_set_cursor_shape = -1;\nstatic int\tdesired_cursor_shape = -1;\nstatic int\tlast_set_cursor_blink = -1;\nstatic int\tdesired_cursor_blink = -1;\n\n\n/**************************************\n * 1. Generic code for all systems.\n */\n\n    static int\ncursor_color_equal(char_u *lhs_color, char_u *rhs_color)\n{\n    if (lhs_color != NULL && rhs_color != NULL)\n\treturn STRCMP(lhs_color, rhs_color) == 0;\n    return lhs_color == NULL && rhs_color == NULL;\n}\n\n    static void\ncursor_color_copy(char_u **to_color, char_u *from_color)\n{\n    // Avoid a free & alloc if the value is already right.\n    if (cursor_color_equal(*to_color, from_color))\n\treturn;\n    vim_free(*to_color);\n    *to_color = (from_color == NULL) ? NULL : vim_strsave(from_color);\n}\n\n    static char_u *\ncursor_color_get(char_u *color)\n{\n    return (color == NULL) ? (char_u *)\"\" : color;\n}\n\n\n/*\n * Parse 'termwinsize' and set \"rows\" and \"cols\" for the terminal size in the\n * current window.\n * Sets \"rows\" and/or \"cols\" to zero when it should follow the window size.\n * Return TRUE if the size is the minimum size: \"24*80\".\n */\n    static int\nparse_termwinsize(win_T *wp, int *rows, int *cols)\n{\n    int\tminsize = FALSE;\n\n    *rows = 0;\n    *cols = 0;\n\n    if (*wp->w_p_tws != NUL)\n    {\n\tchar_u *p = vim_strchr(wp->w_p_tws, 'x');\n\n\t/* Syntax of value was already checked when it's set. */\n\tif (p == NULL)\n\t{\n\t    minsize = TRUE;\n\t    p = vim_strchr(wp->w_p_tws, '*');\n\t}\n\t*rows = atoi((char *)wp->w_p_tws);\n\t*cols = atoi((char *)p + 1);\n    }\n    return minsize;\n}\n\n/*\n * Determine the terminal size from 'termwinsize' and the current window.\n */\n    static void\nset_term_and_win_size(term_T *term)\n{\n#ifdef FEAT_GUI\n    if (term->tl_system)\n    {\n\t/* Use the whole screen for the system command.  However, it will start\n\t * at the command line and scroll up as needed, using tl_toprow. */\n\tterm->tl_rows = Rows;\n\tterm->tl_cols = Columns;\n\treturn;\n    }\n#endif\n    if (parse_termwinsize(curwin, &term->tl_rows, &term->tl_cols))\n    {\n\tif (term->tl_rows != 0)\n\t    term->tl_rows = MAX(term->tl_rows, curwin->w_height);\n\tif (term->tl_cols != 0)\n\t    term->tl_cols = MAX(term->tl_cols, curwin->w_width);\n    }\n    if (term->tl_rows == 0)\n\tterm->tl_rows = curwin->w_height;\n    else\n\twin_setheight_win(term->tl_rows, curwin);\n    if (term->tl_cols == 0)\n\tterm->tl_cols = curwin->w_width;\n    else\n\twin_setwidth_win(term->tl_cols, curwin);\n}\n\n/*\n * Initialize job options for a terminal job.\n * Caller may overrule some of them.\n */\n    void\ninit_job_options(jobopt_T *opt)\n{\n    clear_job_options(opt);\n\n    opt->jo_mode = MODE_RAW;\n    opt->jo_out_mode = MODE_RAW;\n    opt->jo_err_mode = MODE_RAW;\n    opt->jo_set = JO_MODE | JO_OUT_MODE | JO_ERR_MODE;\n}\n\n/*\n * Set job options mandatory for a terminal job.\n */\n    static void\nsetup_job_options(jobopt_T *opt, int rows, int cols)\n{\n#ifndef WIN3264\n    /* Win32: Redirecting the job output won't work, thus always connect stdout\n     * here. */\n    if (!(opt->jo_set & JO_OUT_IO))\n#endif\n    {\n\t/* Connect stdout to the terminal. */\n\topt->jo_io[PART_OUT] = JIO_BUFFER;\n\topt->jo_io_buf[PART_OUT] = curbuf->b_fnum;\n\topt->jo_modifiable[PART_OUT] = 0;\n\topt->jo_set |= JO_OUT_IO + JO_OUT_BUF + JO_OUT_MODIFIABLE;\n    }\n\n#ifndef WIN3264\n    /* Win32: Redirecting the job output won't work, thus always connect stderr\n     * here. */\n    if (!(opt->jo_set & JO_ERR_IO))\n#endif\n    {\n\t/* Connect stderr to the terminal. */\n\topt->jo_io[PART_ERR] = JIO_BUFFER;\n\topt->jo_io_buf[PART_ERR] = curbuf->b_fnum;\n\topt->jo_modifiable[PART_ERR] = 0;\n\topt->jo_set |= JO_ERR_IO + JO_ERR_BUF + JO_ERR_MODIFIABLE;\n    }\n\n    opt->jo_pty = TRUE;\n    if ((opt->jo_set2 & JO2_TERM_ROWS) == 0)\n\topt->jo_term_rows = rows;\n    if ((opt->jo_set2 & JO2_TERM_COLS) == 0)\n\topt->jo_term_cols = cols;\n}\n\n/*\n * Close a terminal buffer (and its window).  Used when creating the terminal\n * fails.\n */\n    static void\nterm_close_buffer(buf_T *buf, buf_T *old_curbuf)\n{\n    free_terminal(buf);\n    if (old_curbuf != NULL)\n    {\n\t--curbuf->b_nwindows;\n\tcurbuf = old_curbuf;\n\tcurwin->w_buffer = curbuf;\n\t++curbuf->b_nwindows;\n    }\n\n    /* Wiping out the buffer will also close the window and call\n     * free_terminal(). */\n    do_buffer(DOBUF_WIPE, DOBUF_FIRST, FORWARD, buf->b_fnum, TRUE);\n}\n\n/*\n * Start a terminal window and return its buffer.\n * Use either \"argvar\" or \"argv\", the other must be NULL.\n * When \"flags\" has TERM_START_NOJOB only create the buffer, b_term and open\n * the window.\n * Returns NULL when failed.\n */\n    buf_T *\nterm_start(\n\ttypval_T    *argvar,\n\tchar\t    **argv,\n\tjobopt_T    *opt,\n\tint\t    flags)\n{\n    exarg_T\tsplit_ea;\n    win_T\t*old_curwin = curwin;\n    term_T\t*term;\n    buf_T\t*old_curbuf = NULL;\n    int\t\tres;\n    buf_T\t*newbuf;\n    int\t\tvertical = opt->jo_vertical || (cmdmod.split & WSP_VERT);\n    jobopt_T\torig_opt;  // only partly filled\n\n    if (check_restricted() || check_secure())\n\treturn NULL;\n\n    if ((opt->jo_set & (JO_IN_IO + JO_OUT_IO + JO_ERR_IO))\n\t\t\t\t\t == (JO_IN_IO + JO_OUT_IO + JO_ERR_IO)\n\t|| (!(opt->jo_set & JO_OUT_IO) && (opt->jo_set & JO_OUT_BUF))\n\t|| (!(opt->jo_set & JO_ERR_IO) && (opt->jo_set & JO_ERR_BUF)))\n    {\n\tEMSG(_(e_invarg));\n\treturn NULL;\n    }\n\n    term = (term_T *)alloc_clear(sizeof(term_T));\n    if (term == NULL)\n\treturn NULL;\n    term->tl_dirty_row_end = MAX_ROW;\n    term->tl_cursor_visible = TRUE;\n    term->tl_cursor_shape = VTERM_PROP_CURSORSHAPE_BLOCK;\n    term->tl_finish = opt->jo_term_finish;\n#ifdef FEAT_GUI\n    term->tl_system = (flags & TERM_START_SYSTEM);\n#endif\n    ga_init2(&term->tl_scrollback, sizeof(sb_line_T), 300);\n\n    vim_memset(&split_ea, 0, sizeof(split_ea));\n    if (opt->jo_curwin)\n    {\n\t/* Create a new buffer in the current window. */\n\tif (!can_abandon(curbuf, flags & TERM_START_FORCEIT))\n\t{\n\t    no_write_message();\n\t    vim_free(term);\n\t    return NULL;\n\t}\n\tif (do_ecmd(0, NULL, NULL, &split_ea, ECMD_ONE,\n\t\t     ECMD_HIDE\n\t\t\t   + ((flags & TERM_START_FORCEIT) ? ECMD_FORCEIT : 0),\n\t\t     curwin) == FAIL)\n\t{\n\t    vim_free(term);\n\t    return NULL;\n\t}\n    }\n    else if (opt->jo_hidden || (flags & TERM_START_SYSTEM))\n    {\n\tbuf_T *buf;\n\n\t/* Create a new buffer without a window. Make it the current buffer for\n\t * a moment to be able to do the initialisations. */\n\tbuf = buflist_new((char_u *)\"\", NULL, (linenr_T)0,\n\t\t\t\t\t\t\t BLN_NEW | BLN_LISTED);\n\tif (buf == NULL || ml_open(buf) == FAIL)\n\t{\n\t    vim_free(term);\n\t    return NULL;\n\t}\n\told_curbuf = curbuf;\n\t--curbuf->b_nwindows;\n\tcurbuf = buf;\n\tcurwin->w_buffer = buf;\n\t++curbuf->b_nwindows;\n    }\n    else\n    {\n\t/* Open a new window or tab. */\n\tsplit_ea.cmdidx = CMD_new;\n\tsplit_ea.cmd = (char_u *)\"new\";\n\tsplit_ea.arg = (char_u *)\"\";\n\tif (opt->jo_term_rows > 0 && !vertical)\n\t{\n\t    split_ea.line2 = opt->jo_term_rows;\n\t    split_ea.addr_count = 1;\n\t}\n\tif (opt->jo_term_cols > 0 && vertical)\n\t{\n\t    split_ea.line2 = opt->jo_term_cols;\n\t    split_ea.addr_count = 1;\n\t}\n\n\tif (vertical)\n\t    cmdmod.split |= WSP_VERT;\n\tex_splitview(&split_ea);\n\tif (curwin == old_curwin)\n\t{\n\t    /* split failed */\n\t    vim_free(term);\n\t    return NULL;\n\t}\n    }\n    term->tl_buffer = curbuf;\n    curbuf->b_term = term;\n\n    if (!opt->jo_hidden)\n    {\n\t/* Only one size was taken care of with :new, do the other one.  With\n\t * \"curwin\" both need to be done. */\n\tif (opt->jo_term_rows > 0 && (opt->jo_curwin || vertical))\n\t    win_setheight(opt->jo_term_rows);\n\tif (opt->jo_term_cols > 0 && (opt->jo_curwin || !vertical))\n\t    win_setwidth(opt->jo_term_cols);\n    }\n\n    /* Link the new terminal in the list of active terminals. */\n    term->tl_next = first_term;\n    first_term = term;\n\n    if (opt->jo_term_name != NULL)\n\tcurbuf->b_ffname = vim_strsave(opt->jo_term_name);\n    else if (argv != NULL)\n\tcurbuf->b_ffname = vim_strsave((char_u *)\"!system\");\n    else\n    {\n\tint\ti;\n\tsize_t\tlen;\n\tchar_u\t*cmd, *p;\n\n\tif (argvar->v_type == VAR_STRING)\n\t{\n\t    cmd = argvar->vval.v_string;\n\t    if (cmd == NULL)\n\t\tcmd = (char_u *)\"\";\n\t    else if (STRCMP(cmd, \"NONE\") == 0)\n\t\tcmd = (char_u *)\"pty\";\n\t}\n\telse if (argvar->v_type != VAR_LIST\n\t\t|| argvar->vval.v_list == NULL\n\t\t|| argvar->vval.v_list->lv_len < 1\n\t\t|| (cmd = tv_get_string_chk(\n\t\t\t       &argvar->vval.v_list->lv_first->li_tv)) == NULL)\n\t    cmd = (char_u*)\"\";\n\n\tlen = STRLEN(cmd) + 10;\n\tp = alloc((int)len);\n\n\tfor (i = 0; p != NULL; ++i)\n\t{\n\t    /* Prepend a ! to the command name to avoid the buffer name equals\n\t     * the executable, otherwise \":w!\" would overwrite it. */\n\t    if (i == 0)\n\t\tvim_snprintf((char *)p, len, \"!%s\", cmd);\n\t    else\n\t\tvim_snprintf((char *)p, len, \"!%s (%d)\", cmd, i);\n\t    if (buflist_findname(p) == NULL)\n\t    {\n\t\tvim_free(curbuf->b_ffname);\n\t\tcurbuf->b_ffname = p;\n\t\tbreak;\n\t    }\n\t}\n    }\n    curbuf->b_fname = curbuf->b_ffname;\n\n    if (opt->jo_term_opencmd != NULL)\n\tterm->tl_opencmd = vim_strsave(opt->jo_term_opencmd);\n\n    if (opt->jo_eof_chars != NULL)\n\tterm->tl_eof_chars = vim_strsave(opt->jo_eof_chars);\n\n    set_string_option_direct((char_u *)\"buftype\", -1,\n\t\t\t\t  (char_u *)\"terminal\", OPT_FREE|OPT_LOCAL, 0);\n    // Avoid that 'buftype' is reset when this buffer is entered.\n    curbuf->b_p_initialized = TRUE;\n\n    /* Mark the buffer as not modifiable. It can only be made modifiable after\n     * the job finished. */\n    curbuf->b_p_ma = FALSE;\n\n    set_term_and_win_size(term);\n#ifdef WIN3264\n    mch_memmove(orig_opt.jo_io, opt->jo_io, sizeof(orig_opt.jo_io));\n#endif\n    setup_job_options(opt, term->tl_rows, term->tl_cols);\n\n    if (flags & TERM_START_NOJOB)\n\treturn curbuf;\n\n#if defined(FEAT_SESSION)\n    /* Remember the command for the session file. */\n    if (opt->jo_term_norestore || argv != NULL)\n    {\n\tterm->tl_command = vim_strsave((char_u *)\"NONE\");\n    }\n    else if (argvar->v_type == VAR_STRING)\n    {\n\tchar_u\t*cmd = argvar->vval.v_string;\n\n\tif (cmd != NULL && STRCMP(cmd, p_sh) != 0)\n\t    term->tl_command = vim_strsave(cmd);\n    }\n    else if (argvar->v_type == VAR_LIST\n\t    && argvar->vval.v_list != NULL\n\t    && argvar->vval.v_list->lv_len > 0)\n    {\n\tgarray_T\tga;\n\tlistitem_T\t*item;\n\n\tga_init2(&ga, 1, 100);\n\tfor (item = argvar->vval.v_list->lv_first;\n\t\t\t\t\titem != NULL; item = item->li_next)\n\t{\n\t    char_u *s = tv_get_string_chk(&item->li_tv);\n\t    char_u *p;\n\n\t    if (s == NULL)\n\t\tbreak;\n\t    p = vim_strsave_fnameescape(s, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    ga_concat(&ga, p);\n\t    vim_free(p);\n\t    ga_append(&ga, ' ');\n\t}\n\tif (item == NULL)\n\t{\n\t    ga_append(&ga, NUL);\n\t    term->tl_command = ga.ga_data;\n\t}\n\telse\n\t    ga_clear(&ga);\n    }\n#endif\n\n    if (opt->jo_term_kill != NULL)\n    {\n\tchar_u *p = skiptowhite(opt->jo_term_kill);\n\n\tterm->tl_kill = vim_strnsave(opt->jo_term_kill, p - opt->jo_term_kill);\n    }\n\n    /* System dependent: setup the vterm and maybe start the job in it. */\n    if (argv == NULL\n\t    && argvar->v_type == VAR_STRING\n\t    && argvar->vval.v_string != NULL\n\t    && STRCMP(argvar->vval.v_string, \"NONE\") == 0)\n\tres = create_pty_only(term, opt);\n    else\n\tres = term_and_job_init(term, argvar, argv, opt, &orig_opt);\n\n    newbuf = curbuf;\n    if (res == OK)\n    {\n\t/* Get and remember the size we ended up with.  Update the pty. */\n\tvterm_get_size(term->tl_vterm, &term->tl_rows, &term->tl_cols);\n\tterm_report_winsize(term, term->tl_rows, term->tl_cols);\n#ifdef FEAT_GUI\n\tif (term->tl_system)\n\t{\n\t    /* display first line below typed command */\n\t    term->tl_toprow = msg_row + 1;\n\t    term->tl_dirty_row_end = 0;\n\t}\n#endif\n\n\t/* Make sure we don't get stuck on sending keys to the job, it leads to\n\t * a deadlock if the job is waiting for Vim to read. */\n\tchannel_set_nonblock(term->tl_job->jv_channel, PART_IN);\n\n\tif (old_curbuf != NULL)\n\t{\n\t    --curbuf->b_nwindows;\n\t    curbuf = old_curbuf;\n\t    curwin->w_buffer = curbuf;\n\t    ++curbuf->b_nwindows;\n\t}\n    }\n    else\n    {\n\tterm_close_buffer(curbuf, old_curbuf);\n\treturn NULL;\n    }\n\n    apply_autocmds(EVENT_TERMINALOPEN, NULL, NULL, FALSE, newbuf);\n    return newbuf;\n}\n\n/*\n * \":terminal\": open a terminal window and execute a job in it.\n */\n    void\nex_terminal(exarg_T *eap)\n{\n    typval_T\targvar[2];\n    jobopt_T\topt;\n    char_u\t*cmd;\n    char_u\t*tofree = NULL;\n\n    init_job_options(&opt);\n\n    cmd = eap->arg;\n    while (*cmd == '+' && *(cmd + 1) == '+')\n    {\n\tchar_u  *p, *ep;\n\n\tcmd += 2;\n\tp = skiptowhite(cmd);\n\tep = vim_strchr(cmd, '=');\n\tif (ep != NULL && ep < p)\n\t    p = ep;\n\n\tif ((int)(p - cmd) == 5 && STRNICMP(cmd, \"close\", 5) == 0)\n\t    opt.jo_term_finish = 'c';\n\telse if ((int)(p - cmd) == 7 && STRNICMP(cmd, \"noclose\", 7) == 0)\n\t    opt.jo_term_finish = 'n';\n\telse if ((int)(p - cmd) == 4 && STRNICMP(cmd, \"open\", 4) == 0)\n\t    opt.jo_term_finish = 'o';\n\telse if ((int)(p - cmd) == 6 && STRNICMP(cmd, \"curwin\", 6) == 0)\n\t    opt.jo_curwin = 1;\n\telse if ((int)(p - cmd) == 6 && STRNICMP(cmd, \"hidden\", 6) == 0)\n\t    opt.jo_hidden = 1;\n\telse if ((int)(p - cmd) == 9 && STRNICMP(cmd, \"norestore\", 9) == 0)\n\t    opt.jo_term_norestore = 1;\n\telse if ((int)(p - cmd) == 4 && STRNICMP(cmd, \"kill\", 4) == 0\n\t\t&& ep != NULL)\n\t{\n\t    opt.jo_set2 |= JO2_TERM_KILL;\n\t    opt.jo_term_kill = ep + 1;\n\t    p = skiptowhite(cmd);\n\t}\n\telse if ((int)(p - cmd) == 4 && STRNICMP(cmd, \"rows\", 4) == 0\n\t\t&& ep != NULL && isdigit(ep[1]))\n\t{\n\t    opt.jo_set2 |= JO2_TERM_ROWS;\n\t    opt.jo_term_rows = atoi((char *)ep + 1);\n\t    p = skiptowhite(cmd);\n\t}\n\telse if ((int)(p - cmd) == 4 && STRNICMP(cmd, \"cols\", 4) == 0\n\t\t&& ep != NULL && isdigit(ep[1]))\n\t{\n\t    opt.jo_set2 |= JO2_TERM_COLS;\n\t    opt.jo_term_cols = atoi((char *)ep + 1);\n\t    p = skiptowhite(cmd);\n\t}\n\telse if ((int)(p - cmd) == 3 && STRNICMP(cmd, \"eof\", 3) == 0\n\t\t\t\t\t\t\t\t && ep != NULL)\n\t{\n\t    char_u *buf = NULL;\n\t    char_u *keys;\n\n\t    p = skiptowhite(cmd);\n\t    *p = NUL;\n\t    keys = replace_termcodes(ep + 1, &buf, TRUE, TRUE, TRUE);\n\t    opt.jo_set2 |= JO2_EOF_CHARS;\n\t    opt.jo_eof_chars = vim_strsave(keys);\n\t    vim_free(buf);\n\t    *p = ' ';\n\t}\n\telse\n\t{\n\t    if (*p)\n\t\t*p = NUL;\n\t    EMSG2(_(\"E181: Invalid attribute: %s\"), cmd);\n\t    goto theend;\n\t}\n\tcmd = skipwhite(p);\n    }\n    if (*cmd == NUL)\n    {\n\t/* Make a copy of 'shell', an autocommand may change the option. */\n\ttofree = cmd = vim_strsave(p_sh);\n\n\t/* default to close when the shell exits */\n\tif (opt.jo_term_finish == NUL)\n\t    opt.jo_term_finish = 'c';\n    }\n\n    if (eap->addr_count > 0)\n    {\n\t/* Write lines from current buffer to the job. */\n\topt.jo_set |= JO_IN_IO | JO_IN_BUF | JO_IN_TOP | JO_IN_BOT;\n\topt.jo_io[PART_IN] = JIO_BUFFER;\n\topt.jo_io_buf[PART_IN] = curbuf->b_fnum;\n\topt.jo_in_top = eap->line1;\n\topt.jo_in_bot = eap->line2;\n    }\n\n    argvar[0].v_type = VAR_STRING;\n    argvar[0].vval.v_string = cmd;\n    argvar[1].v_type = VAR_UNKNOWN;\n    term_start(argvar, NULL, &opt, eap->forceit ? TERM_START_FORCEIT : 0);\n    vim_free(tofree);\n\ntheend:\n    vim_free(opt.jo_eof_chars);\n}\n\n#if defined(FEAT_SESSION) || defined(PROTO)\n/*\n * Write a :terminal command to the session file to restore the terminal in\n * window \"wp\".\n * Return FAIL if writing fails.\n */\n    int\nterm_write_session(FILE *fd, win_T *wp)\n{\n    term_T *term = wp->w_buffer->b_term;\n\n    /* Create the terminal and run the command.  This is not without\n     * risk, but let's assume the user only creates a session when this\n     * will be OK. */\n    if (fprintf(fd, \"terminal ++curwin ++cols=%d ++rows=%d \",\n\t\tterm->tl_cols, term->tl_rows) < 0)\n\treturn FAIL;\n    if (term->tl_command != NULL && fputs((char *)term->tl_command, fd) < 0)\n\treturn FAIL;\n\n    return put_eol(fd);\n}\n\n/*\n * Return TRUE if \"buf\" has a terminal that should be restored.\n */\n    int\nterm_should_restore(buf_T *buf)\n{\n    term_T\t*term = buf->b_term;\n\n    return term != NULL && (term->tl_command == NULL\n\t\t\t\t     || STRCMP(term->tl_command, \"NONE\") != 0);\n}\n#endif\n\n/*\n * Free the scrollback buffer for \"term\".\n */\n    static void\nfree_scrollback(term_T *term)\n{\n    int i;\n\n    for (i = 0; i < term->tl_scrollback.ga_len; ++i)\n\tvim_free(((sb_line_T *)term->tl_scrollback.ga_data + i)->sb_cells);\n    ga_clear(&term->tl_scrollback);\n}\n\n/*\n * Free a terminal and everything it refers to.\n * Kills the job if there is one.\n * Called when wiping out a buffer.\n */\n    void\nfree_terminal(buf_T *buf)\n{\n    term_T\t*term = buf->b_term;\n    term_T\t*tp;\n\n    if (term == NULL)\n\treturn;\n    if (first_term == term)\n\tfirst_term = term->tl_next;\n    else\n\tfor (tp = first_term; tp->tl_next != NULL; tp = tp->tl_next)\n\t    if (tp->tl_next == term)\n\t    {\n\t\ttp->tl_next = term->tl_next;\n\t\tbreak;\n\t    }\n\n    if (term->tl_job != NULL)\n    {\n\tif (term->tl_job->jv_status != JOB_ENDED\n\t\t&& term->tl_job->jv_status != JOB_FINISHED\n\t\t&& term->tl_job->jv_status != JOB_FAILED)\n\t    job_stop(term->tl_job, NULL, \"kill\");\n\tjob_unref(term->tl_job);\n    }\n\n    free_scrollback(term);\n\n    term_free_vterm(term);\n    vim_free(term->tl_title);\n#ifdef FEAT_SESSION\n    vim_free(term->tl_command);\n#endif\n    vim_free(term->tl_kill);\n    vim_free(term->tl_status_text);\n    vim_free(term->tl_opencmd);\n    vim_free(term->tl_eof_chars);\n#ifdef WIN3264\n    if (term->tl_out_fd != NULL)\n\tfclose(term->tl_out_fd);\n#endif\n    vim_free(term->tl_cursor_color);\n    vim_free(term);\n    buf->b_term = NULL;\n    if (in_terminal_loop == term)\n\tin_terminal_loop = NULL;\n}\n\n/*\n * Get the part that is connected to the tty. Normally this is PART_IN, but\n * when writing buffer lines to the job it can be another.  This makes it\n * possible to do \"1,5term vim -\".\n */\n    static ch_part_T\nget_tty_part(term_T *term)\n{\n#ifdef UNIX\n    ch_part_T\tparts[3] = {PART_IN, PART_OUT, PART_ERR};\n    int\t\ti;\n\n    for (i = 0; i < 3; ++i)\n    {\n\tint fd = term->tl_job->jv_channel->ch_part[parts[i]].ch_fd;\n\n\tif (isatty(fd))\n\t    return parts[i];\n    }\n#endif\n    return PART_IN;\n}\n\n/*\n * Write job output \"msg[len]\" to the vterm.\n */\n    static void\nterm_write_job_output(term_T *term, char_u *msg, size_t len)\n{\n    VTerm\t*vterm = term->tl_vterm;\n    size_t\tprevlen = vterm_output_get_buffer_current(vterm);\n\n    vterm_input_write(vterm, (char *)msg, len);\n\n    /* flush vterm buffer when vterm responded to control sequence */\n    if (prevlen != vterm_output_get_buffer_current(vterm))\n    {\n\tchar   buf[KEY_BUF_LEN];\n\tsize_t curlen = vterm_output_read(vterm, buf, KEY_BUF_LEN);\n\n\tif (curlen > 0)\n\t    channel_send(term->tl_job->jv_channel, get_tty_part(term),\n\t\t\t\t\t     (char_u *)buf, (int)curlen, NULL);\n    }\n\n    /* this invokes the damage callbacks */\n    vterm_screen_flush_damage(vterm_obtain_screen(vterm));\n}\n\n    static void\nupdate_cursor(term_T *term, int redraw)\n{\n    if (term->tl_normal_mode)\n\treturn;\n#ifdef FEAT_GUI\n    if (term->tl_system)\n\twindgoto(term->tl_cursor_pos.row + term->tl_toprow,\n\t\t\t\t\t\t      term->tl_cursor_pos.col);\n    else\n#endif\n\tsetcursor();\n    if (redraw)\n    {\n\tif (term->tl_buffer == curbuf && term->tl_cursor_visible)\n\t    cursor_on();\n\tout_flush();\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    gui_update_cursor(FALSE, FALSE);\n\t    gui_mch_flush();\n\t}\n#endif\n    }\n}\n\n/*\n * Invoked when \"msg\" output from a job was received.  Write it to the terminal\n * of \"buffer\".\n */\n    void\nwrite_to_term(buf_T *buffer, char_u *msg, channel_T *channel)\n{\n    size_t\tlen = STRLEN(msg);\n    term_T\t*term = buffer->b_term;\n\n#ifdef WIN3264\n    /* Win32: Cannot redirect output of the job, intercept it here and write to\n     * the file. */\n    if (term->tl_out_fd != NULL)\n    {\n\tch_log(channel, \"Writing %d bytes to output file\", (int)len);\n\tfwrite(msg, len, 1, term->tl_out_fd);\n\treturn;\n    }\n#endif\n\n    if (term->tl_vterm == NULL)\n    {\n\tch_log(channel, \"NOT writing %d bytes to terminal\", (int)len);\n\treturn;\n    }\n    ch_log(channel, \"writing %d bytes to terminal\", (int)len);\n    term_write_job_output(term, msg, len);\n\n#ifdef FEAT_GUI\n    if (term->tl_system)\n    {\n\t/* show system output, scrolling up the screen as needed */\n\tupdate_system_term(term);\n\tupdate_cursor(term, TRUE);\n    }\n    else\n#endif\n    /* In Terminal-Normal mode we are displaying the buffer, not the terminal\n     * contents, thus no screen update is needed. */\n    if (!term->tl_normal_mode)\n    {\n\t// Don't use update_screen() when editing the command line, it gets\n\t// cleared.\n\t// TODO: only update once in a while.\n\tch_log(term->tl_job->jv_channel, \"updating screen\");\n\tif (buffer == curbuf && (State & CMDLINE) == 0)\n\t{\n\t    update_screen(VALID_NO_UPDATE);\n\t    /* update_screen() can be slow, check the terminal wasn't closed\n\t     * already */\n\t    if (buffer == curbuf && curbuf->b_term != NULL)\n\t\tupdate_cursor(curbuf->b_term, TRUE);\n\t}\n\telse\n\t    redraw_after_callback(TRUE);\n    }\n}\n\n/*\n * Send a mouse position and click to the vterm\n */\n    static int\nterm_send_mouse(VTerm *vterm, int button, int pressed)\n{\n    VTermModifier   mod = VTERM_MOD_NONE;\n\n    vterm_mouse_move(vterm, mouse_row - W_WINROW(curwin),\n\t\t\t\t\t    mouse_col - curwin->w_wincol, mod);\n    if (button != 0)\n\tvterm_mouse_button(vterm, button, pressed, mod);\n    return TRUE;\n}\n\nstatic int enter_mouse_col = -1;\nstatic int enter_mouse_row = -1;\n\n/*\n * Handle a mouse click, drag or release.\n * Return TRUE when a mouse event is sent to the terminal.\n */\n    static int\nterm_mouse_click(VTerm *vterm, int key)\n{\n#if defined(FEAT_CLIPBOARD)\n    /* For modeless selection mouse drag and release events are ignored, unless\n     * they are preceded with a mouse down event */\n    static int\t    ignore_drag_release = TRUE;\n    VTermMouseState mouse_state;\n\n    vterm_state_get_mousestate(vterm_obtain_state(vterm), &mouse_state);\n    if (mouse_state.flags == 0)\n    {\n\t/* Terminal is not using the mouse, use modeless selection. */\n\tswitch (key)\n\t{\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\t/* Ignore drag and release events when the button-down wasn't\n\t\t * seen before. */\n\t\tif (ignore_drag_release)\n\t\t{\n\t\t    int save_mouse_col, save_mouse_row;\n\n\t\t    if (enter_mouse_col < 0)\n\t\t\tbreak;\n\n\t\t    /* mouse click in the window gave us focus, handle that\n\t\t     * click now */\n\t\t    save_mouse_col = mouse_col;\n\t\t    save_mouse_row = mouse_row;\n\t\t    mouse_col = enter_mouse_col;\n\t\t    mouse_row = enter_mouse_row;\n\t\t    clip_modeless(MOUSE_LEFT, TRUE, FALSE);\n\t\t    mouse_col = save_mouse_col;\n\t\t    mouse_row = save_mouse_row;\n\t\t}\n\t\t/* FALLTHROUGH */\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tif (key == K_LEFTRELEASE || key == K_RIGHTRELEASE)\n\t\t    ignore_drag_release = TRUE;\n\t\telse\n\t\t    ignore_drag_release = FALSE;\n\t\t/* Should we call mouse_has() here? */\n\t\tif (clip_star.available)\n\t\t{\n\t\t    int\t    button, is_click, is_drag;\n\n\t\t    button = get_mouse_button(KEY2TERMCAP1(key),\n\t\t\t\t\t\t\t &is_click, &is_drag);\n\t\t    if (mouse_model_popup() && button == MOUSE_LEFT\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\t    {\n\t\t\t/* Translate shift-left to right button. */\n\t\t\tbutton = MOUSE_RIGHT;\n\t\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t\t    }\n\t\t    clip_modeless(button, is_click, is_drag);\n\t\t}\n\t\tbreak;\n\n\tcase K_MIDDLEMOUSE:\n\t\tif (clip_star.available)\n\t\t    insert_reg('*', TRUE);\n\t\tbreak;\n\t}\n\tenter_mouse_col = -1;\n\treturn FALSE;\n    }\n#endif\n    enter_mouse_col = -1;\n\n    switch (key)\n    {\n\tcase K_LEFTMOUSE:\n\tcase K_LEFTMOUSE_NM:\tterm_send_mouse(vterm, 1, 1); break;\n\tcase K_LEFTDRAG:\tterm_send_mouse(vterm, 1, 1); break;\n\tcase K_LEFTRELEASE:\n\tcase K_LEFTRELEASE_NM:\tterm_send_mouse(vterm, 1, 0); break;\n\tcase K_MOUSEMOVE:\tterm_send_mouse(vterm, 0, 0); break;\n\tcase K_MIDDLEMOUSE:\tterm_send_mouse(vterm, 2, 1); break;\n\tcase K_MIDDLEDRAG:\tterm_send_mouse(vterm, 2, 1); break;\n\tcase K_MIDDLERELEASE:\tterm_send_mouse(vterm, 2, 0); break;\n\tcase K_RIGHTMOUSE:\tterm_send_mouse(vterm, 3, 1); break;\n\tcase K_RIGHTDRAG:\tterm_send_mouse(vterm, 3, 1); break;\n\tcase K_RIGHTRELEASE:\tterm_send_mouse(vterm, 3, 0); break;\n    }\n    return TRUE;\n}\n\n/*\n * Convert typed key \"c\" into bytes to send to the job.\n * Return the number of bytes in \"buf\".\n */\n    static int\nterm_convert_key(term_T *term, int c, char *buf)\n{\n    VTerm\t    *vterm = term->tl_vterm;\n    VTermKey\t    key = VTERM_KEY_NONE;\n    VTermModifier   mod = VTERM_MOD_NONE;\n    int\t\t    other = FALSE;\n\n    switch (c)\n    {\n\t/* don't use VTERM_KEY_ENTER, it may do an unwanted conversion */\n\n\t\t\t\t/* don't use VTERM_KEY_BACKSPACE, it always\n\t\t\t\t * becomes 0x7f DEL */\n\tcase K_BS:\t\tc = term_backspace_char; break;\n\n\tcase ESC:\t\tkey = VTERM_KEY_ESCAPE; break;\n\tcase K_DEL:\t\tkey = VTERM_KEY_DEL; break;\n\tcase K_DOWN:\t\tkey = VTERM_KEY_DOWN; break;\n\tcase K_S_DOWN:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_DOWN; break;\n\tcase K_END:\t\tkey = VTERM_KEY_END; break;\n\tcase K_S_END:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_END; break;\n\tcase K_C_END:\t\tmod = VTERM_MOD_CTRL;\n\t\t\t\tkey = VTERM_KEY_END; break;\n\tcase K_F10:\t\tkey = VTERM_KEY_FUNCTION(10); break;\n\tcase K_F11:\t\tkey = VTERM_KEY_FUNCTION(11); break;\n\tcase K_F12:\t\tkey = VTERM_KEY_FUNCTION(12); break;\n\tcase K_F1:\t\tkey = VTERM_KEY_FUNCTION(1); break;\n\tcase K_F2:\t\tkey = VTERM_KEY_FUNCTION(2); break;\n\tcase K_F3:\t\tkey = VTERM_KEY_FUNCTION(3); break;\n\tcase K_F4:\t\tkey = VTERM_KEY_FUNCTION(4); break;\n\tcase K_F5:\t\tkey = VTERM_KEY_FUNCTION(5); break;\n\tcase K_F6:\t\tkey = VTERM_KEY_FUNCTION(6); break;\n\tcase K_F7:\t\tkey = VTERM_KEY_FUNCTION(7); break;\n\tcase K_F8:\t\tkey = VTERM_KEY_FUNCTION(8); break;\n\tcase K_F9:\t\tkey = VTERM_KEY_FUNCTION(9); break;\n\tcase K_HOME:\t\tkey = VTERM_KEY_HOME; break;\n\tcase K_S_HOME:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_HOME; break;\n\tcase K_C_HOME:\t\tmod = VTERM_MOD_CTRL;\n\t\t\t\tkey = VTERM_KEY_HOME; break;\n\tcase K_INS:\t\tkey = VTERM_KEY_INS; break;\n\tcase K_K0:\t\tkey = VTERM_KEY_KP_0; break;\n\tcase K_K1:\t\tkey = VTERM_KEY_KP_1; break;\n\tcase K_K2:\t\tkey = VTERM_KEY_KP_2; break;\n\tcase K_K3:\t\tkey = VTERM_KEY_KP_3; break;\n\tcase K_K4:\t\tkey = VTERM_KEY_KP_4; break;\n\tcase K_K5:\t\tkey = VTERM_KEY_KP_5; break;\n\tcase K_K6:\t\tkey = VTERM_KEY_KP_6; break;\n\tcase K_K7:\t\tkey = VTERM_KEY_KP_7; break;\n\tcase K_K8:\t\tkey = VTERM_KEY_KP_8; break;\n\tcase K_K9:\t\tkey = VTERM_KEY_KP_9; break;\n\tcase K_KDEL:\t\tkey = VTERM_KEY_DEL; break; /* TODO */\n\tcase K_KDIVIDE:\t\tkey = VTERM_KEY_KP_DIVIDE; break;\n\tcase K_KEND:\t\tkey = VTERM_KEY_KP_1; break; /* TODO */\n\tcase K_KENTER:\t\tkey = VTERM_KEY_KP_ENTER; break;\n\tcase K_KHOME:\t\tkey = VTERM_KEY_KP_7; break; /* TODO */\n\tcase K_KINS:\t\tkey = VTERM_KEY_KP_0; break; /* TODO */\n\tcase K_KMINUS:\t\tkey = VTERM_KEY_KP_MINUS; break;\n\tcase K_KMULTIPLY:\tkey = VTERM_KEY_KP_MULT; break;\n\tcase K_KPAGEDOWN:\tkey = VTERM_KEY_KP_3; break; /* TODO */\n\tcase K_KPAGEUP:\t\tkey = VTERM_KEY_KP_9; break; /* TODO */\n\tcase K_KPLUS:\t\tkey = VTERM_KEY_KP_PLUS; break;\n\tcase K_KPOINT:\t\tkey = VTERM_KEY_KP_PERIOD; break;\n\tcase K_LEFT:\t\tkey = VTERM_KEY_LEFT; break;\n\tcase K_S_LEFT:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_LEFT; break;\n\tcase K_C_LEFT:\t\tmod = VTERM_MOD_CTRL;\n\t\t\t\tkey = VTERM_KEY_LEFT; break;\n\tcase K_PAGEDOWN:\tkey = VTERM_KEY_PAGEDOWN; break;\n\tcase K_PAGEUP:\t\tkey = VTERM_KEY_PAGEUP; break;\n\tcase K_RIGHT:\t\tkey = VTERM_KEY_RIGHT; break;\n\tcase K_S_RIGHT:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_RIGHT; break;\n\tcase K_C_RIGHT:\t\tmod = VTERM_MOD_CTRL;\n\t\t\t\tkey = VTERM_KEY_RIGHT; break;\n\tcase K_UP:\t\tkey = VTERM_KEY_UP; break;\n\tcase K_S_UP:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_UP; break;\n\tcase TAB:\t\tkey = VTERM_KEY_TAB; break;\n\tcase K_S_TAB:\t\tmod = VTERM_MOD_SHIFT;\n\t\t\t\tkey = VTERM_KEY_TAB; break;\n\n\tcase K_MOUSEUP:\t\tother = term_send_mouse(vterm, 5, 1); break;\n\tcase K_MOUSEDOWN:\tother = term_send_mouse(vterm, 4, 1); break;\n\tcase K_MOUSELEFT:\t/* TODO */ return 0;\n\tcase K_MOUSERIGHT:\t/* TODO */ return 0;\n\n\tcase K_LEFTMOUSE:\n\tcase K_LEFTMOUSE_NM:\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_LEFTRELEASE_NM:\n\tcase K_MOUSEMOVE:\n\tcase K_MIDDLEMOUSE:\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\tcase K_RIGHTMOUSE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\tif (!term_mouse_click(vterm, c))\n\t\t\t\t    return 0;\n\t\t\t\tother = TRUE;\n\t\t\t\tbreak;\n\n\tcase K_X1MOUSE:\t\t/* TODO */ return 0;\n\tcase K_X1DRAG:\t\t/* TODO */ return 0;\n\tcase K_X1RELEASE:\t/* TODO */ return 0;\n\tcase K_X2MOUSE:\t\t/* TODO */ return 0;\n\tcase K_X2DRAG:\t\t/* TODO */ return 0;\n\tcase K_X2RELEASE:\t/* TODO */ return 0;\n\n\tcase K_IGNORE:\t\treturn 0;\n\tcase K_NOP:\t\treturn 0;\n\tcase K_UNDO:\t\treturn 0;\n\tcase K_HELP:\t\treturn 0;\n\tcase K_XF1:\t\tkey = VTERM_KEY_FUNCTION(1); break;\n\tcase K_XF2:\t\tkey = VTERM_KEY_FUNCTION(2); break;\n\tcase K_XF3:\t\tkey = VTERM_KEY_FUNCTION(3); break;\n\tcase K_XF4:\t\tkey = VTERM_KEY_FUNCTION(4); break;\n\tcase K_SELECT:\t\treturn 0;\n#ifdef FEAT_GUI\n\tcase K_VER_SCROLLBAR:\treturn 0;\n\tcase K_HOR_SCROLLBAR:\treturn 0;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\t\treturn 0;\n\tcase K_TABMENU:\t\treturn 0;\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\tcase K_F21:\t\tkey = VTERM_KEY_FUNCTION(21); break;\n#endif\n#ifdef FEAT_DND\n\tcase K_DROP:\t\treturn 0;\n#endif\n\tcase K_CURSORHOLD:\treturn 0;\n\tcase K_PS:\t\tvterm_keyboard_start_paste(vterm);\n\t\t\t\tother = TRUE;\n\t\t\t\tbreak;\n\tcase K_PE:\t\tvterm_keyboard_end_paste(vterm);\n\t\t\t\tother = TRUE;\n\t\t\t\tbreak;\n    }\n\n    /*\n     * Convert special keys to vterm keys:\n     * - Write keys to vterm: vterm_keyboard_key()\n     * - Write output to channel.\n     * TODO: use mod_mask\n     */\n    if (key != VTERM_KEY_NONE)\n\t/* Special key, let vterm convert it. */\n\tvterm_keyboard_key(vterm, key, mod);\n    else if (!other)\n\t/* Normal character, let vterm convert it. */\n\tvterm_keyboard_unichar(vterm, c, mod);\n\n    /* Read back the converted escape sequence. */\n    return (int)vterm_output_read(vterm, buf, KEY_BUF_LEN);\n}\n\n/*\n * Return TRUE if the job for \"term\" is still running.\n * If \"check_job_status\" is TRUE update the job status.\n */\n    static int\nterm_job_running_check(term_T *term, int check_job_status)\n{\n    /* Also consider the job finished when the channel is closed, to avoid a\n     * race condition when updating the title. */\n    if (term != NULL\n\t&& term->tl_job != NULL\n\t&& channel_is_open(term->tl_job->jv_channel))\n    {\n\tif (check_job_status)\n\t    job_status(term->tl_job);\n\treturn (term->tl_job->jv_status == JOB_STARTED\n\t\t|| term->tl_job->jv_channel->ch_keep_open);\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if the job for \"term\" is still running.\n */\n    int\nterm_job_running(term_T *term)\n{\n    return term_job_running_check(term, FALSE);\n}\n\n/*\n * Return TRUE if \"term\" has an active channel and used \":term NONE\".\n */\n    int\nterm_none_open(term_T *term)\n{\n    /* Also consider the job finished when the channel is closed, to avoid a\n     * race condition when updating the title. */\n    return term != NULL\n\t&& term->tl_job != NULL\n\t&& channel_is_open(term->tl_job->jv_channel)\n\t&& term->tl_job->jv_channel->ch_keep_open;\n}\n\n/*\n * Used when exiting: kill the job in \"buf\" if so desired.\n * Return OK when the job finished.\n * Return FAIL when the job is still running.\n */\n    int\nterm_try_stop_job(buf_T *buf)\n{\n    int\t    count;\n    char    *how = (char *)buf->b_term->tl_kill;\n\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n    if ((how == NULL || *how == NUL) && (p_confirm || cmdmod.confirm))\n    {\n\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\tint\tret;\n\n\tdialog_msg(buff, _(\"Kill job in \\\"%s\\\"?\"), buf->b_fname);\n\tret = vim_dialog_yesnocancel(VIM_QUESTION, NULL, buff, 1);\n\tif (ret == VIM_YES)\n\t    how = \"kill\";\n\telse if (ret == VIM_CANCEL)\n\t    return FAIL;\n    }\n#endif\n    if (how == NULL || *how == NUL)\n\treturn FAIL;\n\n    job_stop(buf->b_term->tl_job, NULL, how);\n\n    /* wait for up to a second for the job to die */\n    for (count = 0; count < 100; ++count)\n    {\n\t/* buffer, terminal and job may be cleaned up while waiting */\n\tif (!buf_valid(buf)\n\t\t|| buf->b_term == NULL\n\t\t|| buf->b_term->tl_job == NULL)\n\t    return OK;\n\n\t/* call job_status() to update jv_status */\n\tjob_status(buf->b_term->tl_job);\n\tif (buf->b_term->tl_job->jv_status >= JOB_ENDED)\n\t    return OK;\n\tui_delay(10L, FALSE);\n\tmch_check_messages();\n\tparse_queued_messages();\n    }\n    return FAIL;\n}\n\n/*\n * Add the last line of the scrollback buffer to the buffer in the window.\n */\n    static void\nadd_scrollback_line_to_buffer(term_T *term, char_u *text, int len)\n{\n    buf_T\t*buf = term->tl_buffer;\n    int\t\tempty = (buf->b_ml.ml_flags & ML_EMPTY);\n    linenr_T\tlnum = buf->b_ml.ml_line_count;\n\n#ifdef WIN3264\n    if (!enc_utf8 && enc_codepage > 0)\n    {\n\tWCHAR   *ret = NULL;\n\tint\tlength = 0;\n\n\tMultiByteToWideChar_alloc(CP_UTF8, 0, (char*)text, len + 1,\n\t\t\t\t\t\t\t   &ret, &length);\n\tif (ret != NULL)\n\t{\n\t    WideCharToMultiByte_alloc(enc_codepage, 0,\n\t\t\t\t      ret, length, (char **)&text, &len, 0, 0);\n\t    vim_free(ret);\n\t    ml_append_buf(term->tl_buffer, lnum, text, len, FALSE);\n\t    vim_free(text);\n\t}\n    }\n    else\n#endif\n\tml_append_buf(term->tl_buffer, lnum, text, len + 1, FALSE);\n    if (empty)\n    {\n\t/* Delete the empty line that was in the empty buffer. */\n\tcurbuf = buf;\n\tml_delete(1, FALSE);\n\tcurbuf = curwin->w_buffer;\n    }\n}\n\n    static void\ncell2cellattr(const VTermScreenCell *cell, cellattr_T *attr)\n{\n    attr->width = cell->width;\n    attr->attrs = cell->attrs;\n    attr->fg = cell->fg;\n    attr->bg = cell->bg;\n}\n\n    static int\nequal_celattr(cellattr_T *a, cellattr_T *b)\n{\n    /* Comparing the colors should be sufficient. */\n    return a->fg.red == b->fg.red\n\t&& a->fg.green == b->fg.green\n\t&& a->fg.blue == b->fg.blue\n\t&& a->bg.red == b->bg.red\n\t&& a->bg.green == b->bg.green\n\t&& a->bg.blue == b->bg.blue;\n}\n\n/*\n * Add an empty scrollback line to \"term\".  When \"lnum\" is not zero, add the\n * line at this position.  Otherwise at the end.\n */\n    static int\nadd_empty_scrollback(term_T *term, cellattr_T *fill_attr, int lnum)\n{\n    if (ga_grow(&term->tl_scrollback, 1) == OK)\n    {\n\tsb_line_T *line = (sb_line_T *)term->tl_scrollback.ga_data\n\t\t\t\t      + term->tl_scrollback.ga_len;\n\n\tif (lnum > 0)\n\t{\n\t    int i;\n\n\t    for (i = 0; i < term->tl_scrollback.ga_len - lnum; ++i)\n\t    {\n\t\t*line = *(line - 1);\n\t\t--line;\n\t    }\n\t}\n\tline->sb_cols = 0;\n\tline->sb_cells = NULL;\n\tline->sb_fill_attr = *fill_attr;\n\t++term->tl_scrollback.ga_len;\n\treturn OK;\n    }\n    return FALSE;\n}\n\n/*\n * Remove the terminal contents from the scrollback and the buffer.\n * Used before adding a new scrollback line or updating the buffer for lines\n * displayed in the terminal.\n */\n    static void\ncleanup_scrollback(term_T *term)\n{\n    sb_line_T\t*line;\n    garray_T\t*gap;\n\n    curbuf = term->tl_buffer;\n    gap = &term->tl_scrollback;\n    while (curbuf->b_ml.ml_line_count > term->tl_scrollback_scrolled\n\t\t\t\t\t\t\t    && gap->ga_len > 0)\n    {\n\tml_delete(curbuf->b_ml.ml_line_count, FALSE);\n\tline = (sb_line_T *)gap->ga_data + gap->ga_len - 1;\n\tvim_free(line->sb_cells);\n\t--gap->ga_len;\n    }\n    curbuf = curwin->w_buffer;\n    if (curbuf == term->tl_buffer)\n\tcheck_cursor();\n}\n\n/*\n * Add the current lines of the terminal to scrollback and to the buffer.\n */\n    static void\nupdate_snapshot(term_T *term)\n{\n    VTermScreen\t    *screen;\n    int\t\t    len;\n    int\t\t    lines_skipped = 0;\n    VTermPos\t    pos;\n    VTermScreenCell cell;\n    cellattr_T\t    fill_attr, new_fill_attr;\n    cellattr_T\t    *p;\n\n    ch_log(term->tl_job == NULL ? NULL : term->tl_job->jv_channel,\n\t\t\t\t  \"Adding terminal window snapshot to buffer\");\n\n    /* First remove the lines that were appended before, they might be\n     * outdated. */\n    cleanup_scrollback(term);\n\n    screen = vterm_obtain_screen(term->tl_vterm);\n    fill_attr = new_fill_attr = term->tl_default_color;\n    for (pos.row = 0; pos.row < term->tl_rows; ++pos.row)\n    {\n\tlen = 0;\n\tfor (pos.col = 0; pos.col < term->tl_cols; ++pos.col)\n\t    if (vterm_screen_get_cell(screen, pos, &cell) != 0\n\t\t\t\t\t\t       && cell.chars[0] != NUL)\n\t    {\n\t\tlen = pos.col + 1;\n\t\tnew_fill_attr = term->tl_default_color;\n\t    }\n\t    else\n\t\t/* Assume the last attr is the filler attr. */\n\t\tcell2cellattr(&cell, &new_fill_attr);\n\n\tif (len == 0 && equal_celattr(&new_fill_attr, &fill_attr))\n\t    ++lines_skipped;\n\telse\n\t{\n\t    while (lines_skipped > 0)\n\t    {\n\t\t/* Line was skipped, add an empty line. */\n\t\t--lines_skipped;\n\t\tif (add_empty_scrollback(term, &fill_attr, 0) == OK)\n\t\t    add_scrollback_line_to_buffer(term, (char_u *)\"\", 0);\n\t    }\n\n\t    if (len == 0)\n\t\tp = NULL;\n\t    else\n\t\tp = (cellattr_T *)alloc((int)sizeof(cellattr_T) * len);\n\t    if ((p != NULL || len == 0)\n\t\t\t\t     && ga_grow(&term->tl_scrollback, 1) == OK)\n\t    {\n\t\tgarray_T    ga;\n\t\tint\t    width;\n\t\tsb_line_T   *line = (sb_line_T *)term->tl_scrollback.ga_data\n\t\t\t\t\t\t  + term->tl_scrollback.ga_len;\n\n\t\tga_init2(&ga, 1, 100);\n\t\tfor (pos.col = 0; pos.col < len; pos.col += width)\n\t\t{\n\t\t    if (vterm_screen_get_cell(screen, pos, &cell) == 0)\n\t\t    {\n\t\t\twidth = 1;\n\t\t\tvim_memset(p + pos.col, 0, sizeof(cellattr_T));\n\t\t\tif (ga_grow(&ga, 1) == OK)\n\t\t\t    ga.ga_len += utf_char2bytes(' ',\n\t\t\t\t\t     (char_u *)ga.ga_data + ga.ga_len);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\twidth = cell.width;\n\n\t\t\tcell2cellattr(&cell, &p[pos.col]);\n\n\t\t\t// Each character can be up to 6 bytes.\n\t\t\tif (ga_grow(&ga, VTERM_MAX_CHARS_PER_CELL * 6) == OK)\n\t\t\t{\n\t\t\t    int\t    i;\n\t\t\t    int\t    c;\n\n\t\t\t    for (i = 0; (c = cell.chars[i]) > 0 || i == 0; ++i)\n\t\t\t\tga.ga_len += utf_char2bytes(c == NUL ? ' ' : c,\n\t\t\t\t\t     (char_u *)ga.ga_data + ga.ga_len);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tline->sb_cols = len;\n\t\tline->sb_cells = p;\n\t\tline->sb_fill_attr = new_fill_attr;\n\t\tfill_attr = new_fill_attr;\n\t\t++term->tl_scrollback.ga_len;\n\n\t\tif (ga_grow(&ga, 1) == FAIL)\n\t\t    add_scrollback_line_to_buffer(term, (char_u *)\"\", 0);\n\t\telse\n\t\t{\n\t\t    *((char_u *)ga.ga_data + ga.ga_len) = NUL;\n\t\t    add_scrollback_line_to_buffer(term, ga.ga_data, ga.ga_len);\n\t\t}\n\t\tga_clear(&ga);\n\t    }\n\t    else\n\t\tvim_free(p);\n\t}\n    }\n\n    // Add trailing empty lines.\n    for (pos.row = term->tl_scrollback.ga_len;\n\t    pos.row < term->tl_scrollback_scrolled + term->tl_cursor_pos.row;\n\t    ++pos.row)\n    {\n\tif (add_empty_scrollback(term, &fill_attr, 0) == OK)\n\t    add_scrollback_line_to_buffer(term, (char_u *)\"\", 0);\n    }\n\n    term->tl_dirty_snapshot = FALSE;\n#ifdef FEAT_TIMERS\n    term->tl_timer_set = FALSE;\n#endif\n}\n\n/*\n * If needed, add the current lines of the terminal to scrollback and to the\n * buffer.  Called after the job has ended and when switching to\n * Terminal-Normal mode.\n * When \"redraw\" is TRUE redraw the windows that show the terminal.\n */\n    static void\nmay_move_terminal_to_buffer(term_T *term, int redraw)\n{\n    win_T\t    *wp;\n\n    if (term->tl_vterm == NULL)\n\treturn;\n\n    /* Update the snapshot only if something changes or the buffer does not\n     * have all the lines. */\n    if (term->tl_dirty_snapshot || term->tl_buffer->b_ml.ml_line_count\n\t\t\t\t\t       <= term->tl_scrollback_scrolled)\n\tupdate_snapshot(term);\n\n    /* Obtain the current background color. */\n    vterm_state_get_default_colors(vterm_obtain_state(term->tl_vterm),\n\t\t       &term->tl_default_color.fg, &term->tl_default_color.bg);\n\n    if (redraw)\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_buffer == term->tl_buffer)\n\t    {\n\t\twp->w_cursor.lnum = term->tl_buffer->b_ml.ml_line_count;\n\t\twp->w_cursor.col = 0;\n\t\twp->w_valid = 0;\n\t\tif (wp->w_cursor.lnum >= wp->w_height)\n\t\t{\n\t\t    linenr_T min_topline = wp->w_cursor.lnum - wp->w_height + 1;\n\n\t\t    if (wp->w_topline < min_topline)\n\t\t\twp->w_topline = min_topline;\n\t\t}\n\t\tredraw_win_later(wp, NOT_VALID);\n\t    }\n\t}\n}\n\n#if defined(FEAT_TIMERS) || defined(PROTO)\n/*\n * Check if any terminal timer expired.  If so, copy text from the terminal to\n * the buffer.\n * Return the time until the next timer will expire.\n */\n    int\nterm_check_timers(int next_due_arg, proftime_T *now)\n{\n    term_T  *term;\n    int\t    next_due = next_due_arg;\n\n    for (term = first_term; term != NULL; term = term->tl_next)\n    {\n\tif (term->tl_timer_set && !term->tl_normal_mode)\n\t{\n\t    long    this_due = proftime_time_left(&term->tl_timer_due, now);\n\n\t    if (this_due <= 1)\n\t    {\n\t\tterm->tl_timer_set = FALSE;\n\t\tmay_move_terminal_to_buffer(term, FALSE);\n\t    }\n\t    else if (next_due == -1 || next_due > this_due)\n\t\tnext_due = this_due;\n\t}\n    }\n\n    return next_due;\n}\n#endif\n\n    static void\nset_terminal_mode(term_T *term, int normal_mode)\n{\n    term->tl_normal_mode = normal_mode;\n    VIM_CLEAR(term->tl_status_text);\n    if (term->tl_buffer == curbuf)\n\tmaketitle();\n}\n\n/*\n * Called after the job if finished and Terminal mode is not active:\n * Move the vterm contents into the scrollback buffer and free the vterm.\n */\n    static void\ncleanup_vterm(term_T *term)\n{\n    if (term->tl_finish != TL_FINISH_CLOSE)\n\tmay_move_terminal_to_buffer(term, TRUE);\n    term_free_vterm(term);\n    set_terminal_mode(term, FALSE);\n}\n\n/*\n * Switch from Terminal-Job mode to Terminal-Normal mode.\n * Suspends updating the terminal window.\n */\n    static void\nterm_enter_normal_mode(void)\n{\n    term_T *term = curbuf->b_term;\n\n    set_terminal_mode(term, TRUE);\n\n    /* Append the current terminal contents to the buffer. */\n    may_move_terminal_to_buffer(term, TRUE);\n\n    /* Move the window cursor to the position of the cursor in the\n     * terminal. */\n    curwin->w_cursor.lnum = term->tl_scrollback_scrolled\n\t\t\t\t\t     + term->tl_cursor_pos.row + 1;\n    check_cursor();\n    if (coladvance(term->tl_cursor_pos.col) == FAIL)\n\tcoladvance(MAXCOL);\n\n    /* Display the same lines as in the terminal. */\n    curwin->w_topline = term->tl_scrollback_scrolled + 1;\n}\n\n/*\n * Returns TRUE if the current window contains a terminal and we are in\n * Terminal-Normal mode.\n */\n    int\nterm_in_normal_mode(void)\n{\n    term_T *term = curbuf->b_term;\n\n    return term != NULL && term->tl_normal_mode;\n}\n\n/*\n * Switch from Terminal-Normal mode to Terminal-Job mode.\n * Restores updating the terminal window.\n */\n    void\nterm_enter_job_mode()\n{\n    term_T\t*term = curbuf->b_term;\n\n    set_terminal_mode(term, FALSE);\n\n    if (term->tl_channel_closed)\n\tcleanup_vterm(term);\n    redraw_buf_and_status_later(curbuf, NOT_VALID);\n}\n\n/*\n * Get a key from the user with terminal mode mappings.\n * Note: while waiting a terminal may be closed and freed if the channel is\n * closed and ++close was used.\n */\n    static int\nterm_vgetc()\n{\n    int c;\n    int save_State = State;\n\n    State = TERMINAL;\n    got_int = FALSE;\n#ifdef WIN3264\n    ctrl_break_was_pressed = FALSE;\n#endif\n    c = vgetc();\n    got_int = FALSE;\n    State = save_State;\n    return c;\n}\n\nstatic int\tmouse_was_outside = FALSE;\n\n/*\n * Send keys to terminal.\n * Return FAIL when the key needs to be handled in Normal mode.\n * Return OK when the key was dropped or sent to the terminal.\n */\n    int\nsend_keys_to_term(term_T *term, int c, int typed)\n{\n    char\tmsg[KEY_BUF_LEN];\n    size_t\tlen;\n    int\t\tdragging_outside = FALSE;\n\n    /* Catch keys that need to be handled as in Normal mode. */\n    switch (c)\n    {\n\tcase NUL:\n\tcase K_ZERO:\n\t    if (typed)\n\t\tstuffcharReadbuff(c);\n\t    return FAIL;\n\n\tcase K_TABLINE:\n\t    stuffcharReadbuff(c);\n\t    return FAIL;\n\n\tcase K_IGNORE:\n\tcase K_CANCEL:  // used for :normal when running out of chars\n\t    return FAIL;\n\n\tcase K_LEFTDRAG:\n\tcase K_MIDDLEDRAG:\n\tcase K_RIGHTDRAG:\n\tcase K_X1DRAG:\n\tcase K_X2DRAG:\n\t    dragging_outside = mouse_was_outside;\n\t    /* FALLTHROUGH */\n\tcase K_LEFTMOUSE:\n\tcase K_LEFTMOUSE_NM:\n\tcase K_LEFTRELEASE:\n\tcase K_LEFTRELEASE_NM:\n\tcase K_MOUSEMOVE:\n\tcase K_MIDDLEMOUSE:\n\tcase K_MIDDLERELEASE:\n\tcase K_RIGHTMOUSE:\n\tcase K_RIGHTRELEASE:\n\tcase K_X1MOUSE:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2RELEASE:\n\n\tcase K_MOUSEUP:\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\t    if (mouse_row < W_WINROW(curwin)\n\t\t    || mouse_row >= (W_WINROW(curwin) + curwin->w_height)\n\t\t    || mouse_col < curwin->w_wincol\n\t\t    || mouse_col >= W_ENDCOL(curwin)\n\t\t    || dragging_outside)\n\t    {\n\t\t/* click or scroll outside the current window or on status line\n\t\t * or vertical separator */\n\t\tif (typed)\n\t\t{\n\t\t    stuffcharReadbuff(c);\n\t\t    mouse_was_outside = TRUE;\n\t\t}\n\t\treturn FAIL;\n\t    }\n    }\n    if (typed)\n\tmouse_was_outside = FALSE;\n\n    /* Convert the typed key to a sequence of bytes for the job. */\n    len = term_convert_key(term, c, msg);\n    if (len > 0)\n\t/* TODO: if FAIL is returned, stop? */\n\tchannel_send(term->tl_job->jv_channel, get_tty_part(term),\n\t\t\t\t\t\t(char_u *)msg, (int)len, NULL);\n\n    return OK;\n}\n\n    static void\nposition_cursor(win_T *wp, VTermPos *pos)\n{\n    wp->w_wrow = MIN(pos->row, MAX(0, wp->w_height - 1));\n    wp->w_wcol = MIN(pos->col, MAX(0, wp->w_width - 1));\n    wp->w_valid |= (VALID_WCOL|VALID_WROW);\n}\n\n/*\n * Handle CTRL-W \"\": send register contents to the job.\n */\n    static void\nterm_paste_register(int prev_c UNUSED)\n{\n    int\t\tc;\n    list_T\t*l;\n    listitem_T\t*item;\n    long\treglen = 0;\n    int\t\ttype;\n\n#ifdef FEAT_CMDL_INFO\n    if (add_to_showcmd(prev_c))\n    if (add_to_showcmd('\"'))\n\tout_flush();\n#endif\n    c = term_vgetc();\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n    if (!term_use_loop())\n\t/* job finished while waiting for a character */\n\treturn;\n\n    /* CTRL-W \"= prompt for expression to evaluate. */\n    if (c == '=' && get_expr_register() != '=')\n\treturn;\n    if (!term_use_loop())\n\t/* job finished while waiting for a character */\n\treturn;\n\n    l = (list_T *)get_reg_contents(c, GREG_LIST);\n    if (l != NULL)\n    {\n\ttype = get_reg_type(c, &reglen);\n\tfor (item = l->lv_first; item != NULL; item = item->li_next)\n\t{\n\t    char_u *s = tv_get_string(&item->li_tv);\n#ifdef WIN3264\n\t    char_u *tmp = s;\n\n\t    if (!enc_utf8 && enc_codepage > 0)\n\t    {\n\t\tWCHAR   *ret = NULL;\n\t\tint\tlength = 0;\n\n\t\tMultiByteToWideChar_alloc(enc_codepage, 0, (char *)s,\n\t\t\t\t\t\t(int)STRLEN(s), &ret, &length);\n\t\tif (ret != NULL)\n\t\t{\n\t\t    WideCharToMultiByte_alloc(CP_UTF8, 0,\n\t\t\t\t    ret, length, (char **)&s, &length, 0, 0);\n\t\t    vim_free(ret);\n\t\t}\n\t    }\n#endif\n\t    channel_send(curbuf->b_term->tl_job->jv_channel, PART_IN,\n\t\t\t\t\t\t      s, (int)STRLEN(s), NULL);\n#ifdef WIN3264\n\t    if (tmp != s)\n\t\tvim_free(s);\n#endif\n\n\t    if (item->li_next != NULL || type == MLINE)\n\t\tchannel_send(curbuf->b_term->tl_job->jv_channel, PART_IN,\n\t\t\t\t\t\t      (char_u *)\"\\r\", 1, NULL);\n\t}\n\tlist_free(l);\n    }\n}\n\n/*\n * Return TRUE when waiting for a character in the terminal, the cursor of the\n * terminal should be displayed.\n */\n    int\nterminal_is_active()\n{\n    return in_terminal_loop != NULL;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n    cursorentry_T *\nterm_get_cursor_shape(guicolor_T *fg, guicolor_T *bg)\n{\n    term_T\t\t *term = in_terminal_loop;\n    static cursorentry_T entry;\n    int\t\t\t id;\n    guicolor_T\t\tterm_fg, term_bg;\n\n    vim_memset(&entry, 0, sizeof(entry));\n    entry.shape = entry.mshape =\n\tterm->tl_cursor_shape == VTERM_PROP_CURSORSHAPE_UNDERLINE ? SHAPE_HOR :\n\tterm->tl_cursor_shape == VTERM_PROP_CURSORSHAPE_BAR_LEFT ? SHAPE_VER :\n\tSHAPE_BLOCK;\n    entry.percentage = 20;\n    if (term->tl_cursor_blink)\n    {\n\tentry.blinkwait = 700;\n\tentry.blinkon = 400;\n\tentry.blinkoff = 250;\n    }\n\n    /* The \"Terminal\" highlight group overrules the defaults. */\n    id = syn_name2id((char_u *)\"Terminal\");\n    if (id != 0)\n    {\n\tsyn_id2colors(id, &term_fg, &term_bg);\n\t*fg = term_bg;\n    }\n    else\n\t*fg = gui.back_pixel;\n\n    if (term->tl_cursor_color == NULL)\n    {\n\tif (id != 0)\n\t    *bg = term_fg;\n\telse\n\t    *bg = gui.norm_pixel;\n    }\n    else\n\t*bg = color_name2handle(term->tl_cursor_color);\n    entry.name = \"n\";\n    entry.used_for = SHAPE_CURSOR;\n\n    return &entry;\n}\n#endif\n\n    static void\nmay_output_cursor_props(void)\n{\n    if (!cursor_color_equal(last_set_cursor_color, desired_cursor_color)\n\t    || last_set_cursor_shape != desired_cursor_shape\n\t    || last_set_cursor_blink != desired_cursor_blink)\n    {\n\tcursor_color_copy(&last_set_cursor_color, desired_cursor_color);\n\tlast_set_cursor_shape = desired_cursor_shape;\n\tlast_set_cursor_blink = desired_cursor_blink;\n\tterm_cursor_color(cursor_color_get(desired_cursor_color));\n\tif (desired_cursor_shape == -1 || desired_cursor_blink == -1)\n\t    /* this will restore the initial cursor style, if possible */\n\t    ui_cursor_shape_forced(TRUE);\n\telse\n\t    term_cursor_shape(desired_cursor_shape, desired_cursor_blink);\n    }\n}\n\n/*\n * Set the cursor color and shape, if not last set to these.\n */\n    static void\nmay_set_cursor_props(term_T *term)\n{\n#ifdef FEAT_GUI\n    /* For the GUI the cursor properties are obtained with\n     * term_get_cursor_shape(). */\n    if (gui.in_use)\n\treturn;\n#endif\n    if (in_terminal_loop == term)\n    {\n\tcursor_color_copy(&desired_cursor_color, term->tl_cursor_color);\n\tdesired_cursor_shape = term->tl_cursor_shape;\n\tdesired_cursor_blink = term->tl_cursor_blink;\n\tmay_output_cursor_props();\n    }\n}\n\n/*\n * Reset the desired cursor properties and restore them when needed.\n */\n    static void\nprepare_restore_cursor_props(void)\n{\n#ifdef FEAT_GUI\n    if (gui.in_use)\n\treturn;\n#endif\n    cursor_color_copy(&desired_cursor_color, NULL);\n    desired_cursor_shape = -1;\n    desired_cursor_blink = -1;\n    may_output_cursor_props();\n}\n\n/*\n * Returns TRUE if the current window contains a terminal and we are sending\n * keys to the job.\n * If \"check_job_status\" is TRUE update the job status.\n */\n    static int\nterm_use_loop_check(int check_job_status)\n{\n    term_T *term = curbuf->b_term;\n\n    return term != NULL\n\t&& !term->tl_normal_mode\n\t&& term->tl_vterm != NULL\n\t&& term_job_running_check(term, check_job_status);\n}\n\n/*\n * Returns TRUE if the current window contains a terminal and we are sending\n * keys to the job.\n */\n    int\nterm_use_loop(void)\n{\n    return term_use_loop_check(FALSE);\n}\n\n/*\n * Called when entering a window with the mouse.  If this is a terminal window\n * we may want to change state.\n */\n    void\nterm_win_entered()\n{\n    term_T *term = curbuf->b_term;\n\n    if (term != NULL)\n    {\n\tif (term_use_loop_check(TRUE))\n\t{\n\t    reset_VIsual_and_resel();\n\t    if (State & INSERT)\n\t\tstop_insert_mode = TRUE;\n\t}\n\tmouse_was_outside = FALSE;\n\tenter_mouse_col = mouse_col;\n\tenter_mouse_row = mouse_row;\n    }\n}\n\n/*\n * Wait for input and send it to the job.\n * When \"blocking\" is TRUE wait for a character to be typed.  Otherwise return\n * when there is no more typahead.\n * Return when the start of a CTRL-W command is typed or anything else that\n * should be handled as a Normal mode command.\n * Returns OK if a typed character is to be handled in Normal mode, FAIL if\n * the terminal was closed.\n */\n    int\nterminal_loop(int blocking)\n{\n    int\t\tc;\n    int\t\ttermwinkey = 0;\n    int\t\tret;\n#ifdef UNIX\n    int\t\ttty_fd = curbuf->b_term->tl_job->jv_channel\n\t\t\t\t ->ch_part[get_tty_part(curbuf->b_term)].ch_fd;\n#endif\n    int\t\trestore_cursor = FALSE;\n\n    /* Remember the terminal we are sending keys to.  However, the terminal\n     * might be closed while waiting for a character, e.g. typing \"exit\" in a\n     * shell and ++close was used.  Therefore use curbuf->b_term instead of a\n     * stored reference. */\n    in_terminal_loop = curbuf->b_term;\n\n    if (*curwin->w_p_twk != NUL)\n    {\n\ttermwinkey = string_to_key(curwin->w_p_twk, TRUE);\n\tif (termwinkey == Ctrl_W)\n\t    termwinkey = 0;\n    }\n    position_cursor(curwin, &curbuf->b_term->tl_cursor_pos);\n    may_set_cursor_props(curbuf->b_term);\n\n    while (blocking || vpeekc_nomap() != NUL)\n    {\n#ifdef FEAT_GUI\n\tif (!curbuf->b_term->tl_system)\n#endif\n\t    /* TODO: skip screen update when handling a sequence of keys. */\n\t    /* Repeat redrawing in case a message is received while redrawing.\n\t     */\n\t    while (must_redraw != 0)\n\t\tif (update_screen(0) == FAIL)\n\t\t    break;\n\tif (!term_use_loop_check(TRUE) || in_terminal_loop != curbuf->b_term)\n\t    /* job finished while redrawing */\n\t    break;\n\n\tupdate_cursor(curbuf->b_term, FALSE);\n\trestore_cursor = TRUE;\n\n\tc = term_vgetc();\n\tif (!term_use_loop_check(TRUE) || in_terminal_loop != curbuf->b_term)\n\t{\n\t    /* Job finished while waiting for a character.  Push back the\n\t     * received character. */\n\t    if (c != K_IGNORE)\n\t\tvungetc(c);\n\t    break;\n\t}\n\tif (c == K_IGNORE)\n\t    continue;\n\n#ifdef UNIX\n\t/*\n\t * The shell or another program may change the tty settings.  Getting\n\t * them for every typed character is a bit of overhead, but it's needed\n\t * for the first character typed, e.g. when Vim starts in a shell.\n\t */\n\tif (isatty(tty_fd))\n\t{\n\t    ttyinfo_T info;\n\n\t    /* Get the current backspace character of the pty. */\n\t    if (get_tty_info(tty_fd, &info) == OK)\n\t\tterm_backspace_char = info.backspace;\n\t}\n#endif\n\n#ifdef WIN3264\n\t/* On Windows winpty handles CTRL-C, don't send a CTRL_C_EVENT.\n\t * Use CTRL-BREAK to kill the job. */\n\tif (ctrl_break_was_pressed)\n\t    mch_signal_job(curbuf->b_term->tl_job, (char_u *)\"kill\");\n#endif\n\t/* Was either CTRL-W (termwinkey) or CTRL-\\ pressed?\n\t * Not in a system terminal. */\n\tif ((c == (termwinkey == 0 ? Ctrl_W : termwinkey) || c == Ctrl_BSL)\n#ifdef FEAT_GUI\n\t\t&& !curbuf->b_term->tl_system\n#endif\n\t\t)\n\t{\n\t    int\t    prev_c = c;\n\n#ifdef FEAT_CMDL_INFO\n\t    if (add_to_showcmd(c))\n\t\tout_flush();\n#endif\n\t    c = term_vgetc();\n#ifdef FEAT_CMDL_INFO\n\t    clear_showcmd();\n#endif\n\t    if (!term_use_loop_check(TRUE)\n\t\t\t\t\t || in_terminal_loop != curbuf->b_term)\n\t\t/* job finished while waiting for a character */\n\t\tbreak;\n\n\t    if (prev_c == Ctrl_BSL)\n\t    {\n\t\tif (c == Ctrl_N)\n\t\t{\n\t\t    /* CTRL-\\ CTRL-N : go to Terminal-Normal mode. */\n\t\t    term_enter_normal_mode();\n\t\t    ret = FAIL;\n\t\t    goto theend;\n\t\t}\n\t\t/* Send both keys to the terminal. */\n\t\tsend_keys_to_term(curbuf->b_term, prev_c, TRUE);\n\t    }\n\t    else if (c == Ctrl_C)\n\t    {\n\t\t/* \"CTRL-W CTRL-C\" or 'termwinkey' CTRL-C: end the job */\n\t\tmch_signal_job(curbuf->b_term->tl_job, (char_u *)\"kill\");\n\t    }\n\t    else if (c == '.')\n\t    {\n\t\t/* \"CTRL-W .\": send CTRL-W to the job */\n\t\t/* \"'termwinkey' .\": send 'termwinkey' to the job */\n\t\tc = termwinkey == 0 ? Ctrl_W : termwinkey;\n\t    }\n\t    else if (c == Ctrl_BSL)\n\t    {\n\t\t/* \"CTRL-W CTRL-\\\": send CTRL-\\ to the job */\n\t\tc = Ctrl_BSL;\n\t    }\n\t    else if (c == 'N')\n\t    {\n\t\t/* CTRL-W N : go to Terminal-Normal mode. */\n\t\tterm_enter_normal_mode();\n\t\tret = FAIL;\n\t\tgoto theend;\n\t    }\n\t    else if (c == '\"')\n\t    {\n\t\tterm_paste_register(prev_c);\n\t\tcontinue;\n\t    }\n\t    else if (termwinkey == 0 || c != termwinkey)\n\t    {\n\t\tstuffcharReadbuff(Ctrl_W);\n\t\tstuffcharReadbuff(c);\n\t\tret = OK;\n\t\tgoto theend;\n\t    }\n\t}\n# ifdef WIN3264\n\tif (!enc_utf8 && has_mbyte && c >= 0x80)\n\t{\n\t    WCHAR   wc;\n\t    char_u  mb[3];\n\n\t    mb[0] = (unsigned)c >> 8;\n\t    mb[1] = c;\n\t    if (MultiByteToWideChar(GetACP(), 0, (char*)mb, 2, &wc, 1) > 0)\n\t\tc = wc;\n\t}\n# endif\n\tif (send_keys_to_term(curbuf->b_term, c, TRUE) != OK)\n\t{\n\t    if (c == K_MOUSEMOVE)\n\t\t/* We are sure to come back here, don't reset the cursor color\n\t\t * and shape to avoid flickering. */\n\t\trestore_cursor = FALSE;\n\n\t    ret = OK;\n\t    goto theend;\n\t}\n    }\n    ret = FAIL;\n\ntheend:\n    in_terminal_loop = NULL;\n    if (restore_cursor)\n\tprepare_restore_cursor_props();\n\n    /* Move a snapshot of the screen contents to the buffer, so that completion\n     * works in other buffers. */\n    if (curbuf->b_term != NULL && !curbuf->b_term->tl_normal_mode)\n\tmay_move_terminal_to_buffer(curbuf->b_term, FALSE);\n\n    return ret;\n}\n\n/*\n * Called when a job has finished.\n * This updates the title and status, but does not close the vterm, because\n * there might still be pending output in the channel.\n */\n    void\nterm_job_ended(job_T *job)\n{\n    term_T *term;\n    int\t    did_one = FALSE;\n\n    for (term = first_term; term != NULL; term = term->tl_next)\n\tif (term->tl_job == job)\n\t{\n\t    VIM_CLEAR(term->tl_title);\n\t    VIM_CLEAR(term->tl_status_text);\n\t    redraw_buf_and_status_later(term->tl_buffer, VALID);\n\t    did_one = TRUE;\n\t}\n    if (did_one)\n\tredraw_statuslines();\n    if (curbuf->b_term != NULL)\n    {\n\tif (curbuf->b_term->tl_job == job)\n\t    maketitle();\n\tupdate_cursor(curbuf->b_term, TRUE);\n    }\n}\n\n    static void\nmay_toggle_cursor(term_T *term)\n{\n    if (in_terminal_loop == term)\n    {\n\tif (term->tl_cursor_visible)\n\t    cursor_on();\n\telse\n\t    cursor_off();\n    }\n}\n\n/*\n * Reverse engineer the RGB value into a cterm color index.\n * First color is 1.  Return 0 if no match found (default color).\n */\n    static int\ncolor2index(VTermColor *color, int fg, int *boldp)\n{\n    int red = color->red;\n    int blue = color->blue;\n    int green = color->green;\n\n    if (color->ansi_index != VTERM_ANSI_INDEX_NONE)\n    {\n\t/* First 16 colors and default: use the ANSI index, because these\n\t * colors can be redefined. */\n\tif (t_colors >= 16)\n\t    return color->ansi_index;\n\tswitch (color->ansi_index)\n\t{\n\t    case  0: return 0;\n\t    case  1: return lookup_color( 0, fg, boldp) + 1; /* black */\n\t    case  2: return lookup_color( 4, fg, boldp) + 1; /* dark red */\n\t    case  3: return lookup_color( 2, fg, boldp) + 1; /* dark green */\n\t    case  4: return lookup_color( 6, fg, boldp) + 1; /* brown */\n\t    case  5: return lookup_color( 1, fg, boldp) + 1; /* dark blue */\n\t    case  6: return lookup_color( 5, fg, boldp) + 1; /* dark magenta */\n\t    case  7: return lookup_color( 3, fg, boldp) + 1; /* dark cyan */\n\t    case  8: return lookup_color( 8, fg, boldp) + 1; /* light grey */\n\t    case  9: return lookup_color(12, fg, boldp) + 1; /* dark grey */\n\t    case 10: return lookup_color(20, fg, boldp) + 1; /* red */\n\t    case 11: return lookup_color(16, fg, boldp) + 1; /* green */\n\t    case 12: return lookup_color(24, fg, boldp) + 1; /* yellow */\n\t    case 13: return lookup_color(14, fg, boldp) + 1; /* blue */\n\t    case 14: return lookup_color(22, fg, boldp) + 1; /* magenta */\n\t    case 15: return lookup_color(18, fg, boldp) + 1; /* cyan */\n\t    case 16: return lookup_color(26, fg, boldp) + 1; /* white */\n\t}\n    }\n\n    if (t_colors >= 256)\n    {\n\tif (red == blue && red == green)\n\t{\n\t    /* 24-color greyscale plus white and black */\n\t    static int cutoff[23] = {\n\t\t    0x0D, 0x17, 0x21, 0x2B, 0x35, 0x3F, 0x49, 0x53, 0x5D, 0x67,\n\t\t    0x71, 0x7B, 0x85, 0x8F, 0x99, 0xA3, 0xAD, 0xB7, 0xC1, 0xCB,\n\t\t    0xD5, 0xDF, 0xE9};\n\t    int i;\n\n\t    if (red < 5)\n\t\treturn 17; /* 00/00/00 */\n\t    if (red > 245) /* ff/ff/ff */\n\t\treturn 232;\n\t    for (i = 0; i < 23; ++i)\n\t\tif (red < cutoff[i])\n\t\t    return i + 233;\n\t    return 256;\n\t}\n\t{\n\t    static int cutoff[5] = {0x2F, 0x73, 0x9B, 0xC3, 0xEB};\n\t    int ri, gi, bi;\n\n\t    /* 216-color cube */\n\t    for (ri = 0; ri < 5; ++ri)\n\t\tif (red < cutoff[ri])\n\t\t    break;\n\t    for (gi = 0; gi < 5; ++gi)\n\t\tif (green < cutoff[gi])\n\t\t    break;\n\t    for (bi = 0; bi < 5; ++bi)\n\t\tif (blue < cutoff[bi])\n\t\t    break;\n\t    return 17 + ri * 36 + gi * 6 + bi;\n\t}\n    }\n    return 0;\n}\n\n/*\n * Convert Vterm attributes to highlight flags.\n */\n    static int\nvtermAttr2hl(VTermScreenCellAttrs cellattrs)\n{\n    int attr = 0;\n\n    if (cellattrs.bold)\n\tattr |= HL_BOLD;\n    if (cellattrs.underline)\n\tattr |= HL_UNDERLINE;\n    if (cellattrs.italic)\n\tattr |= HL_ITALIC;\n    if (cellattrs.strike)\n\tattr |= HL_STRIKETHROUGH;\n    if (cellattrs.reverse)\n\tattr |= HL_INVERSE;\n    return attr;\n}\n\n/*\n * Store Vterm attributes in \"cell\" from highlight flags.\n */\n    static void\nhl2vtermAttr(int attr, cellattr_T *cell)\n{\n    vim_memset(&cell->attrs, 0, sizeof(VTermScreenCellAttrs));\n    if (attr & HL_BOLD)\n\tcell->attrs.bold = 1;\n    if (attr & HL_UNDERLINE)\n\tcell->attrs.underline = 1;\n    if (attr & HL_ITALIC)\n\tcell->attrs.italic = 1;\n    if (attr & HL_STRIKETHROUGH)\n\tcell->attrs.strike = 1;\n    if (attr & HL_INVERSE)\n\tcell->attrs.reverse = 1;\n}\n\n/*\n * Convert the attributes of a vterm cell into an attribute index.\n */\n    static int\ncell2attr(VTermScreenCellAttrs cellattrs, VTermColor cellfg, VTermColor cellbg)\n{\n    int attr = vtermAttr2hl(cellattrs);\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tguicolor_T fg, bg;\n\n\tfg = gui_mch_get_rgb_color(cellfg.red, cellfg.green, cellfg.blue);\n\tbg = gui_mch_get_rgb_color(cellbg.red, cellbg.green, cellbg.blue);\n\treturn get_gui_attr_idx(attr, fg, bg);\n    }\n    else\n#endif\n#ifdef FEAT_TERMGUICOLORS\n    if (p_tgc)\n    {\n\tguicolor_T fg, bg;\n\n\tfg = gui_get_rgb_color_cmn(cellfg.red, cellfg.green, cellfg.blue);\n\tbg = gui_get_rgb_color_cmn(cellbg.red, cellbg.green, cellbg.blue);\n\n\treturn get_tgc_attr_idx(attr, fg, bg);\n    }\n    else\n#endif\n    {\n\tint bold = MAYBE;\n\tint fg = color2index(&cellfg, TRUE, &bold);\n\tint bg = color2index(&cellbg, FALSE, &bold);\n\n\t/* Use the \"Terminal\" highlighting for the default colors. */\n\tif ((fg == 0 || bg == 0) && t_colors >= 16)\n\t{\n\t    if (fg == 0 && term_default_cterm_fg >= 0)\n\t\tfg = term_default_cterm_fg + 1;\n\t    if (bg == 0 && term_default_cterm_bg >= 0)\n\t\tbg = term_default_cterm_bg + 1;\n\t}\n\n\t/* with 8 colors set the bold attribute to get a bright foreground */\n\tif (bold == TRUE)\n\t    attr |= HL_BOLD;\n\treturn get_cterm_attr_idx(attr, fg, bg);\n    }\n    return 0;\n}\n\n    static void\nset_dirty_snapshot(term_T *term)\n{\n    term->tl_dirty_snapshot = TRUE;\n#ifdef FEAT_TIMERS\n    if (!term->tl_normal_mode)\n    {\n\t/* Update the snapshot after 100 msec of not getting updates. */\n\tprofile_setlimit(100L, &term->tl_timer_due);\n\tterm->tl_timer_set = TRUE;\n    }\n#endif\n}\n\n    static int\nhandle_damage(VTermRect rect, void *user)\n{\n    term_T *term = (term_T *)user;\n\n    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, rect.start_row);\n    term->tl_dirty_row_end = MAX(term->tl_dirty_row_end, rect.end_row);\n    set_dirty_snapshot(term);\n    redraw_buf_later(term->tl_buffer, SOME_VALID);\n    return 1;\n}\n\n    static void\nterm_scroll_up(term_T *term, int start_row, int count)\n{\n    win_T\t\t *wp;\n    VTermColor\t\t fg, bg;\n    VTermScreenCellAttrs attr;\n    int\t\t\t clear_attr;\n\n    /* Set the color to clear lines with. */\n    vterm_state_get_default_colors(vterm_obtain_state(term->tl_vterm),\n\t\t\t\t\t\t\t\t     &fg, &bg);\n    vim_memset(&attr, 0, sizeof(attr));\n    clear_attr = cell2attr(attr, fg, bg);\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer == term->tl_buffer)\n\t    win_del_lines(wp, start_row, count, FALSE, FALSE, clear_attr);\n    }\n}\n\n    static int\nhandle_moverect(VTermRect dest, VTermRect src, void *user)\n{\n    term_T\t*term = (term_T *)user;\n    int\t\tcount = src.start_row - dest.start_row;\n\n    /* Scrolling up is done much more efficiently by deleting lines instead of\n     * redrawing the text. But avoid doing this multiple times, postpone until\n     * the redraw happens. */\n    if (dest.start_col == src.start_col\n\t    && dest.end_col == src.end_col\n\t    && dest.start_row < src.start_row)\n    {\n\tif (dest.start_row == 0)\n\t    term->tl_postponed_scroll += count;\n\telse\n\t    term_scroll_up(term, dest.start_row, count);\n    }\n\n    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);\n    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);\n    set_dirty_snapshot(term);\n\n    /* Note sure if the scrolling will work correctly, let's do a complete\n     * redraw later. */\n    redraw_buf_later(term->tl_buffer, NOT_VALID);\n    return 1;\n}\n\n    static int\nhandle_movecursor(\n\tVTermPos pos,\n\tVTermPos oldpos UNUSED,\n\tint visible,\n\tvoid *user)\n{\n    term_T\t*term = (term_T *)user;\n    win_T\t*wp;\n\n    term->tl_cursor_pos = pos;\n    term->tl_cursor_visible = visible;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer == term->tl_buffer)\n\t    position_cursor(wp, &pos);\n    }\n    if (term->tl_buffer == curbuf && !term->tl_normal_mode)\n    {\n\tmay_toggle_cursor(term);\n\tupdate_cursor(term, term->tl_cursor_visible);\n    }\n\n    return 1;\n}\n\n    static int\nhandle_settermprop(\n\tVTermProp prop,\n\tVTermValue *value,\n\tvoid *user)\n{\n    term_T\t*term = (term_T *)user;\n\n    switch (prop)\n    {\n\tcase VTERM_PROP_TITLE:\n\t    vim_free(term->tl_title);\n\t    /* a blank title isn't useful, make it empty, so that \"running\" is\n\t     * displayed */\n\t    if (*skipwhite((char_u *)value->string) == NUL)\n\t\tterm->tl_title = NULL;\n#ifdef WIN3264\n\t    else if (!enc_utf8 && enc_codepage > 0)\n\t    {\n\t\tWCHAR   *ret = NULL;\n\t\tint\tlength = 0;\n\n\t\tMultiByteToWideChar_alloc(CP_UTF8, 0,\n\t\t\t(char*)value->string, (int)STRLEN(value->string),\n\t\t\t\t\t\t\t\t&ret, &length);\n\t\tif (ret != NULL)\n\t\t{\n\t\t    WideCharToMultiByte_alloc(enc_codepage, 0,\n\t\t\t\t\tret, length, (char**)&term->tl_title,\n\t\t\t\t\t&length, 0, 0);\n\t\t    vim_free(ret);\n\t\t}\n\t    }\n#endif\n\t    else\n\t\tterm->tl_title = vim_strsave((char_u *)value->string);\n\t    VIM_CLEAR(term->tl_status_text);\n\t    if (term == curbuf->b_term)\n\t\tmaketitle();\n\t    break;\n\n\tcase VTERM_PROP_CURSORVISIBLE:\n\t    term->tl_cursor_visible = value->boolean;\n\t    may_toggle_cursor(term);\n\t    out_flush();\n\t    break;\n\n\tcase VTERM_PROP_CURSORBLINK:\n\t    term->tl_cursor_blink = value->boolean;\n\t    may_set_cursor_props(term);\n\t    break;\n\n\tcase VTERM_PROP_CURSORSHAPE:\n\t    term->tl_cursor_shape = value->number;\n\t    may_set_cursor_props(term);\n\t    break;\n\n\tcase VTERM_PROP_CURSORCOLOR:\n\t    cursor_color_copy(&term->tl_cursor_color, (char_u*)value->string);\n\t    may_set_cursor_props(term);\n\t    break;\n\n\tcase VTERM_PROP_ALTSCREEN:\n\t    /* TODO: do anything else? */\n\t    term->tl_using_altscreen = value->boolean;\n\t    break;\n\n\tdefault:\n\t    break;\n    }\n    /* Always return 1, otherwise vterm doesn't store the value internally. */\n    return 1;\n}\n\n/*\n * The job running in the terminal resized the terminal.\n */\n    static int\nhandle_resize(int rows, int cols, void *user)\n{\n    term_T\t*term = (term_T *)user;\n    win_T\t*wp;\n\n    term->tl_rows = rows;\n    term->tl_cols = cols;\n    if (term->tl_vterm_size_changed)\n\t/* Size was set by vterm_set_size(), don't set the window size. */\n\tterm->tl_vterm_size_changed = FALSE;\n    else\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_buffer == term->tl_buffer)\n\t    {\n\t\twin_setheight_win(rows, wp);\n\t\twin_setwidth_win(cols, wp);\n\t    }\n\t}\n\tredraw_buf_later(term->tl_buffer, NOT_VALID);\n    }\n    return 1;\n}\n\n/*\n * Handle a line that is pushed off the top of the screen.\n */\n    static int\nhandle_pushline(int cols, const VTermScreenCell *cells, void *user)\n{\n    term_T\t*term = (term_T *)user;\n\n    /* First remove the lines that were appended before, the pushed line goes\n     * above it. */\n    cleanup_scrollback(term);\n\n    /* If the number of lines that are stored goes over 'termscrollback' then\n     * delete the first 10%. */\n    if (term->tl_scrollback.ga_len >= term->tl_buffer->b_p_twsl)\n    {\n\tint\ttodo = term->tl_buffer->b_p_twsl / 10;\n\tint\ti;\n\n\tcurbuf = term->tl_buffer;\n\tfor (i = 0; i < todo; ++i)\n\t{\n\t    vim_free(((sb_line_T *)term->tl_scrollback.ga_data + i)->sb_cells);\n\t    ml_delete(1, FALSE);\n\t}\n\tcurbuf = curwin->w_buffer;\n\n\tterm->tl_scrollback.ga_len -= todo;\n\tmch_memmove(term->tl_scrollback.ga_data,\n\t    (sb_line_T *)term->tl_scrollback.ga_data + todo,\n\t    sizeof(sb_line_T) * term->tl_scrollback.ga_len);\n\tterm->tl_scrollback_scrolled -= todo;\n    }\n\n    if (ga_grow(&term->tl_scrollback, 1) == OK)\n    {\n\tcellattr_T\t*p = NULL;\n\tint\t\tlen = 0;\n\tint\t\ti;\n\tint\t\tc;\n\tint\t\tcol;\n\tsb_line_T\t*line;\n\tgarray_T\tga;\n\tcellattr_T\tfill_attr = term->tl_default_color;\n\n\t/* do not store empty cells at the end */\n\tfor (i = 0; i < cols; ++i)\n\t    if (cells[i].chars[0] != 0)\n\t\tlen = i + 1;\n\t    else\n\t\tcell2cellattr(&cells[i], &fill_attr);\n\n\tga_init2(&ga, 1, 100);\n\tif (len > 0)\n\t    p = (cellattr_T *)alloc((int)sizeof(cellattr_T) * len);\n\tif (p != NULL)\n\t{\n\t    for (col = 0; col < len; col += cells[col].width)\n\t    {\n\t\tif (ga_grow(&ga, MB_MAXBYTES) == FAIL)\n\t\t{\n\t\t    ga.ga_len = 0;\n\t\t    break;\n\t\t}\n\t\tfor (i = 0; (c = cells[col].chars[i]) > 0 || i == 0; ++i)\n\t\t    ga.ga_len += utf_char2bytes(c == NUL ? ' ' : c,\n\t\t\t\t\t     (char_u *)ga.ga_data + ga.ga_len);\n\t\tcell2cellattr(&cells[col], &p[col]);\n\t    }\n\t}\n\tif (ga_grow(&ga, 1) == FAIL)\n\t    add_scrollback_line_to_buffer(term, (char_u *)\"\", 0);\n\telse\n\t{\n\t    *((char_u *)ga.ga_data + ga.ga_len) = NUL;\n\t    add_scrollback_line_to_buffer(term, ga.ga_data, ga.ga_len);\n\t}\n\tga_clear(&ga);\n\n\tline = (sb_line_T *)term->tl_scrollback.ga_data\n\t\t\t\t\t\t  + term->tl_scrollback.ga_len;\n\tline->sb_cols = len;\n\tline->sb_cells = p;\n\tline->sb_fill_attr = fill_attr;\n\t++term->tl_scrollback.ga_len;\n\t++term->tl_scrollback_scrolled;\n    }\n    return 0; /* ignored */\n}\n\nstatic VTermScreenCallbacks screen_callbacks = {\n  handle_damage,\t/* damage */\n  handle_moverect,\t/* moverect */\n  handle_movecursor,\t/* movecursor */\n  handle_settermprop,\t/* settermprop */\n  NULL,\t\t\t/* bell */\n  handle_resize,\t/* resize */\n  handle_pushline,\t/* sb_pushline */\n  NULL\t\t\t/* sb_popline */\n};\n\n/*\n * Do the work after the channel of a terminal was closed.\n * Must be called only when updating_screen is FALSE.\n * Returns TRUE when a buffer was closed (list of terminals may have changed).\n */\n    static int\nterm_after_channel_closed(term_T *term)\n{\n    /* Unless in Terminal-Normal mode: clear the vterm. */\n    if (!term->tl_normal_mode)\n    {\n\tint\tfnum = term->tl_buffer->b_fnum;\n\n\tcleanup_vterm(term);\n\n\tif (term->tl_finish == TL_FINISH_CLOSE)\n\t{\n\t    aco_save_T\taco;\n\t    int\t\tdo_set_w_closing = term->tl_buffer->b_nwindows == 0;\n\n\t    // ++close or term_finish == \"close\"\n\t    ch_log(NULL, \"terminal job finished, closing window\");\n\t    aucmd_prepbuf(&aco, term->tl_buffer);\n\t    // Avoid closing the window if we temporarily use it.\n\t    if (do_set_w_closing)\n\t\tcurwin->w_closing = TRUE;\n\t    do_bufdel(DOBUF_WIPE, (char_u *)\"\", 1, fnum, fnum, FALSE);\n\t    if (do_set_w_closing)\n\t\tcurwin->w_closing = FALSE;\n\t    aucmd_restbuf(&aco);\n\t    return TRUE;\n\t}\n\tif (term->tl_finish == TL_FINISH_OPEN\n\t\t\t\t   && term->tl_buffer->b_nwindows == 0)\n\t{\n\t    char buf[50];\n\n\t    /* TODO: use term_opencmd */\n\t    ch_log(NULL, \"terminal job finished, opening window\");\n\t    vim_snprintf(buf, sizeof(buf),\n\t\t    term->tl_opencmd == NULL\n\t\t\t    ? \"botright sbuf %d\"\n\t\t\t    : (char *)term->tl_opencmd, fnum);\n\t    do_cmdline_cmd((char_u *)buf);\n\t}\n\telse\n\t    ch_log(NULL, \"terminal job finished\");\n    }\n\n    redraw_buf_and_status_later(term->tl_buffer, NOT_VALID);\n    return FALSE;\n}\n\n/*\n * Called when a channel has been closed.\n * If this was a channel for a terminal window then finish it up.\n */\n    void\nterm_channel_closed(channel_T *ch)\n{\n    term_T *term;\n    term_T *next_term;\n    int\t    did_one = FALSE;\n\n    for (term = first_term; term != NULL; term = next_term)\n    {\n\tnext_term = term->tl_next;\n\tif (term->tl_job == ch->ch_job)\n\t{\n\t    term->tl_channel_closed = TRUE;\n\t    did_one = TRUE;\n\n\t    VIM_CLEAR(term->tl_title);\n\t    VIM_CLEAR(term->tl_status_text);\n#ifdef WIN3264\n\t    if (term->tl_out_fd != NULL)\n\t    {\n\t\tfclose(term->tl_out_fd);\n\t\tterm->tl_out_fd = NULL;\n\t    }\n#endif\n\n\t    if (updating_screen)\n\t    {\n\t\t/* Cannot open or close windows now.  Can happen when\n\t\t * 'lazyredraw' is set. */\n\t\tterm->tl_channel_recently_closed = TRUE;\n\t\tcontinue;\n\t    }\n\n\t    if (term_after_channel_closed(term))\n\t\tnext_term = first_term;\n\t}\n    }\n\n    if (did_one)\n    {\n\tredraw_statuslines();\n\n\t/* Need to break out of vgetc(). */\n\tins_char_typebuf(K_IGNORE);\n\ttypebuf_was_filled = TRUE;\n\n\tterm = curbuf->b_term;\n\tif (term != NULL)\n\t{\n\t    if (term->tl_job == ch->ch_job)\n\t\tmaketitle();\n\t    update_cursor(term, term->tl_cursor_visible);\n\t}\n    }\n}\n\n/*\n * To be called after resetting updating_screen: handle any terminal where the\n * channel was closed.\n */\n    void\nterm_check_channel_closed_recently()\n{\n    term_T *term;\n    term_T *next_term;\n\n    for (term = first_term; term != NULL; term = next_term)\n    {\n\tnext_term = term->tl_next;\n\tif (term->tl_channel_recently_closed)\n\t{\n\t    term->tl_channel_recently_closed = FALSE;\n\t    if (term_after_channel_closed(term))\n\t\t// start over, the list may have changed\n\t\tnext_term = first_term;\n\t}\n    }\n}\n\n/*\n * Fill one screen line from a line of the terminal.\n * Advances \"pos\" to past the last column.\n */\n    static void\nterm_line2screenline(VTermScreen *screen, VTermPos *pos, int max_col)\n{\n    int off = screen_get_current_line_off();\n\n    for (pos->col = 0; pos->col < max_col; )\n    {\n\tVTermScreenCell cell;\n\tint\t\tc;\n\n\tif (vterm_screen_get_cell(screen, *pos, &cell) == 0)\n\t    vim_memset(&cell, 0, sizeof(cell));\n\n\tc = cell.chars[0];\n\tif (c == NUL)\n\t{\n\t    ScreenLines[off] = ' ';\n\t    if (enc_utf8)\n\t\tScreenLinesUC[off] = NUL;\n\t}\n\telse\n\t{\n\t    if (enc_utf8)\n\t    {\n\t\tint i;\n\n\t\t/* composing chars */\n\t\tfor (i = 0; i < Screen_mco\n\t\t\t      && i + 1 < VTERM_MAX_CHARS_PER_CELL; ++i)\n\t\t{\n\t\t    ScreenLinesC[i][off] = cell.chars[i + 1];\n\t\t    if (cell.chars[i + 1] == 0)\n\t\t\tbreak;\n\t\t}\n\t\tif (c >= 0x80 || (Screen_mco > 0\n\t\t\t\t\t && ScreenLinesC[0][off] != 0))\n\t\t{\n\t\t    ScreenLines[off] = ' ';\n\t\t    ScreenLinesUC[off] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ScreenLines[off] = c;\n\t\t    ScreenLinesUC[off] = NUL;\n\t\t}\n\t    }\n#ifdef WIN3264\n\t    else if (has_mbyte && c >= 0x80)\n\t    {\n\t\tchar_u\tmb[MB_MAXBYTES+1];\n\t\tWCHAR\twc = c;\n\n\t\tif (WideCharToMultiByte(GetACP(), 0, &wc, 1,\n\t\t\t\t\t       (char*)mb, 2, 0, 0) > 1)\n\t\t{\n\t\t    ScreenLines[off] = mb[0];\n\t\t    ScreenLines[off + 1] = mb[1];\n\t\t    cell.width = mb_ptr2cells(mb);\n\t\t}\n\t\telse\n\t\t    ScreenLines[off] = c;\n\t    }\n#endif\n\t    else\n\t\tScreenLines[off] = c;\n\t}\n\tScreenAttrs[off] = cell2attr(cell.attrs, cell.fg, cell.bg);\n\n\t++pos->col;\n\t++off;\n\tif (cell.width == 2)\n\t{\n\t    if (enc_utf8)\n\t\tScreenLinesUC[off] = NUL;\n\n\t    /* don't set the second byte to NUL for a DBCS encoding, it\n\t     * has been set above */\n\t    if (enc_utf8 || !has_mbyte)\n\t\tScreenLines[off] = NUL;\n\n\t    ++pos->col;\n\t    ++off;\n\t}\n    }\n}\n\n#if defined(FEAT_GUI)\n    static void\nupdate_system_term(term_T *term)\n{\n    VTermPos\t    pos;\n    VTermScreen\t    *screen;\n\n    if (term->tl_vterm == NULL)\n\treturn;\n    screen = vterm_obtain_screen(term->tl_vterm);\n\n    /* Scroll up to make more room for terminal lines if needed. */\n    while (term->tl_toprow > 0\n\t\t\t  && (Rows - term->tl_toprow) < term->tl_dirty_row_end)\n    {\n\tint save_p_more = p_more;\n\n\tp_more = FALSE;\n\tmsg_row = Rows - 1;\n\tmsg_puts((char_u *)\"\\n\");\n\tp_more = save_p_more;\n\t--term->tl_toprow;\n    }\n\n    for (pos.row = term->tl_dirty_row_start; pos.row < term->tl_dirty_row_end\n\t\t\t\t\t\t  && pos.row < Rows; ++pos.row)\n    {\n\tif (pos.row < term->tl_rows)\n\t{\n\t    int max_col = MIN(Columns, term->tl_cols);\n\n\t    term_line2screenline(screen, &pos, max_col);\n\t}\n\telse\n\t    pos.col = 0;\n\n\tscreen_line(term->tl_toprow + pos.row, 0, pos.col, Columns, FALSE);\n    }\n\n    term->tl_dirty_row_start = MAX_ROW;\n    term->tl_dirty_row_end = 0;\n    update_cursor(term, TRUE);\n}\n#endif\n\n/*\n * Return TRUE if window \"wp\" is to be redrawn with term_update_window().\n * Returns FALSE when there is no terminal running in this window or it is in\n * Terminal-Normal mode.\n */\n    int\nterm_do_update_window(win_T *wp)\n{\n    term_T\t*term = wp->w_buffer->b_term;\n\n    return term != NULL && term->tl_vterm != NULL && !term->tl_normal_mode;\n}\n\n/*\n * Called to update a window that contains an active terminal.\n */\n    void\nterm_update_window(win_T *wp)\n{\n    term_T\t*term = wp->w_buffer->b_term;\n    VTerm\t*vterm;\n    VTermScreen *screen;\n    VTermState\t*state;\n    VTermPos\tpos;\n    int\t\trows, cols;\n    int\t\tnewrows, newcols;\n    int\t\tminsize;\n    win_T\t*twp;\n\n    vterm = term->tl_vterm;\n    screen = vterm_obtain_screen(vterm);\n    state = vterm_obtain_state(vterm);\n\n    /* We use NOT_VALID on a resize or scroll, redraw everything then.  With\n     * SOME_VALID only redraw what was marked dirty. */\n    if (wp->w_redr_type > SOME_VALID)\n    {\n\tterm->tl_dirty_row_start = 0;\n\tterm->tl_dirty_row_end = MAX_ROW;\n\n\tif (term->tl_postponed_scroll > 0\n\t\t\t      && term->tl_postponed_scroll < term->tl_rows / 3)\n\t    /* Scrolling is usually faster than redrawing, when there are only\n\t     * a few lines to scroll. */\n\t    term_scroll_up(term, 0, term->tl_postponed_scroll);\n\tterm->tl_postponed_scroll = 0;\n    }\n\n    /*\n     * If the window was resized a redraw will be triggered and we get here.\n     * Adjust the size of the vterm unless 'termwinsize' specifies a fixed size.\n     */\n    minsize = parse_termwinsize(wp, &rows, &cols);\n\n    newrows = 99999;\n    newcols = 99999;\n    FOR_ALL_WINDOWS(twp)\n    {\n\t/* When more than one window shows the same terminal, use the\n\t * smallest size. */\n\tif (twp->w_buffer == term->tl_buffer)\n\t{\n\t    newrows = MIN(newrows, twp->w_height);\n\t    newcols = MIN(newcols, twp->w_width);\n\t}\n    }\n    newrows = rows == 0 ? newrows : minsize ? MAX(rows, newrows) : rows;\n    newcols = cols == 0 ? newcols : minsize ? MAX(cols, newcols) : cols;\n\n    if (term->tl_rows != newrows || term->tl_cols != newcols)\n    {\n\tterm->tl_vterm_size_changed = TRUE;\n\tvterm_set_size(vterm, newrows, newcols);\n\tch_log(term->tl_job->jv_channel, \"Resizing terminal to %d lines\",\n\t\t\t\t\t\t\t\t      newrows);\n\tterm_report_winsize(term, newrows, newcols);\n\n\t// Updating the terminal size will cause the snapshot to be cleared.\n\t// When not in terminal_loop() we need to restore it.\n\tif (term != in_terminal_loop)\n\t    may_move_terminal_to_buffer(term, FALSE);\n    }\n\n    /* The cursor may have been moved when resizing. */\n    vterm_state_get_cursorpos(state, &pos);\n    position_cursor(wp, &pos);\n\n    for (pos.row = term->tl_dirty_row_start; pos.row < term->tl_dirty_row_end\n\t\t\t\t\t  && pos.row < wp->w_height; ++pos.row)\n    {\n\tif (pos.row < term->tl_rows)\n\t{\n\t    int max_col = MIN(wp->w_width, term->tl_cols);\n\n\t    term_line2screenline(screen, &pos, max_col);\n\t}\n\telse\n\t    pos.col = 0;\n\n\tscreen_line(wp->w_winrow + pos.row\n#ifdef FEAT_MENU\n\t\t\t\t+ winbar_height(wp)\n#endif\n\t\t\t\t, wp->w_wincol, pos.col, wp->w_width, FALSE);\n    }\n    term->tl_dirty_row_start = MAX_ROW;\n    term->tl_dirty_row_end = 0;\n}\n\n/*\n * Return TRUE if \"wp\" is a terminal window where the job has finished.\n */\n    int\nterm_is_finished(buf_T *buf)\n{\n    return buf->b_term != NULL && buf->b_term->tl_vterm == NULL;\n}\n\n/*\n * Return TRUE if \"wp\" is a terminal window where the job has finished or we\n * are in Terminal-Normal mode, thus we show the buffer contents.\n */\n    int\nterm_show_buffer(buf_T *buf)\n{\n    term_T *term = buf->b_term;\n\n    return term != NULL && (term->tl_vterm == NULL || term->tl_normal_mode);\n}\n\n/*\n * The current buffer is going to be changed.  If there is terminal\n * highlighting remove it now.\n */\n    void\nterm_change_in_curbuf(void)\n{\n    term_T *term = curbuf->b_term;\n\n    if (term_is_finished(curbuf) && term->tl_scrollback.ga_len > 0)\n    {\n\tfree_scrollback(term);\n\tredraw_buf_later(term->tl_buffer, NOT_VALID);\n\n\t/* The buffer is now like a normal buffer, it cannot be easily\n\t * abandoned when changed. */\n\tset_string_option_direct((char_u *)\"buftype\", -1,\n\t\t\t\t\t  (char_u *)\"\", OPT_FREE|OPT_LOCAL, 0);\n    }\n}\n\n/*\n * Get the screen attribute for a position in the buffer.\n * Use a negative \"col\" to get the filler background color.\n */\n    int\nterm_get_attr(buf_T *buf, linenr_T lnum, int col)\n{\n    term_T\t*term = buf->b_term;\n    sb_line_T\t*line;\n    cellattr_T\t*cellattr;\n\n    if (lnum > term->tl_scrollback.ga_len)\n\tcellattr = &term->tl_default_color;\n    else\n    {\n\tline = (sb_line_T *)term->tl_scrollback.ga_data + lnum - 1;\n\tif (col < 0 || col >= line->sb_cols)\n\t    cellattr = &line->sb_fill_attr;\n\telse\n\t    cellattr = line->sb_cells + col;\n    }\n    return cell2attr(cellattr->attrs, cellattr->fg, cellattr->bg);\n}\n\n/*\n * Convert a cterm color number 0 - 255 to RGB.\n * This is compatible with xterm.\n */\n    static void\ncterm_color2vterm(int nr, VTermColor *rgb)\n{\n    cterm_color2rgb(nr, &rgb->red, &rgb->green, &rgb->blue, &rgb->ansi_index);\n}\n\n/*\n * Initialize term->tl_default_color from the environment.\n */\n    static void\ninit_default_colors(term_T *term)\n{\n    VTermColor\t    *fg, *bg;\n    int\t\t    fgval, bgval;\n    int\t\t    id;\n\n    vim_memset(&term->tl_default_color.attrs, 0, sizeof(VTermScreenCellAttrs));\n    term->tl_default_color.width = 1;\n    fg = &term->tl_default_color.fg;\n    bg = &term->tl_default_color.bg;\n\n    /* Vterm uses a default black background.  Set it to white when\n     * 'background' is \"light\". */\n    if (*p_bg == 'l')\n    {\n\tfgval = 0;\n\tbgval = 255;\n    }\n    else\n    {\n\tfgval = 255;\n\tbgval = 0;\n    }\n    fg->red = fg->green = fg->blue = fgval;\n    bg->red = bg->green = bg->blue = bgval;\n    fg->ansi_index = bg->ansi_index = VTERM_ANSI_INDEX_DEFAULT;\n\n    /* The \"Terminal\" highlight group overrules the defaults. */\n    id = syn_name2id((char_u *)\"Terminal\");\n\n    /* Use the actual color for the GUI and when 'termguicolors' is set. */\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (0\n# ifdef FEAT_GUI\n\t    || gui.in_use\n# endif\n# ifdef FEAT_TERMGUICOLORS\n\t    || p_tgc\n#  ifdef FEAT_VTP\n\t    /* Finally get INVALCOLOR on this execution path */\n\t    || (!p_tgc && t_colors >= 256)\n#  endif\n# endif\n       )\n    {\n\tguicolor_T\tfg_rgb = INVALCOLOR;\n\tguicolor_T\tbg_rgb = INVALCOLOR;\n\n\tif (id != 0)\n\t    syn_id2colors(id, &fg_rgb, &bg_rgb);\n\n# ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    if (fg_rgb == INVALCOLOR)\n\t\tfg_rgb = gui.norm_pixel;\n\t    if (bg_rgb == INVALCOLOR)\n\t\tbg_rgb = gui.back_pixel;\n\t}\n#  ifdef FEAT_TERMGUICOLORS\n\telse\n#  endif\n# endif\n# ifdef FEAT_TERMGUICOLORS\n\t{\n\t    if (fg_rgb == INVALCOLOR)\n\t\tfg_rgb = cterm_normal_fg_gui_color;\n\t    if (bg_rgb == INVALCOLOR)\n\t\tbg_rgb = cterm_normal_bg_gui_color;\n\t}\n# endif\n\tif (fg_rgb != INVALCOLOR)\n\t{\n\t    long_u rgb = GUI_MCH_GET_RGB(fg_rgb);\n\n\t    fg->red = (unsigned)(rgb >> 16);\n\t    fg->green = (unsigned)(rgb >> 8) & 255;\n\t    fg->blue = (unsigned)rgb & 255;\n\t}\n\tif (bg_rgb != INVALCOLOR)\n\t{\n\t    long_u rgb = GUI_MCH_GET_RGB(bg_rgb);\n\n\t    bg->red = (unsigned)(rgb >> 16);\n\t    bg->green = (unsigned)(rgb >> 8) & 255;\n\t    bg->blue = (unsigned)rgb & 255;\n\t}\n    }\n    else\n#endif\n    if (id != 0 && t_colors >= 16)\n    {\n\tif (term_default_cterm_fg >= 0)\n\t    cterm_color2vterm(term_default_cterm_fg, fg);\n\tif (term_default_cterm_bg >= 0)\n\t    cterm_color2vterm(term_default_cterm_bg, bg);\n    }\n    else\n    {\n#if defined(WIN3264) && !defined(FEAT_GUI_W32)\n\tint tmp;\n#endif\n\n\t/* In an MS-Windows console we know the normal colors. */\n\tif (cterm_normal_fg_color > 0)\n\t{\n\t    cterm_color2vterm(cterm_normal_fg_color - 1, fg);\n# if defined(WIN3264) && !defined(FEAT_GUI_W32)\n\t    tmp = fg->red;\n\t    fg->red = fg->blue;\n\t    fg->blue = tmp;\n# endif\n\t}\n# ifdef FEAT_TERMRESPONSE\n\telse\n\t    term_get_fg_color(&fg->red, &fg->green, &fg->blue);\n# endif\n\n\tif (cterm_normal_bg_color > 0)\n\t{\n\t    cterm_color2vterm(cterm_normal_bg_color - 1, bg);\n# if defined(WIN3264) && !defined(FEAT_GUI_W32)\n\t    tmp = bg->red;\n\t    bg->red = bg->blue;\n\t    bg->blue = tmp;\n# endif\n\t}\n# ifdef FEAT_TERMRESPONSE\n\telse\n\t    term_get_bg_color(&bg->red, &bg->green, &bg->blue);\n# endif\n    }\n}\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n/*\n * Set the 16 ANSI colors from array of RGB values\n */\n    static void\nset_vterm_palette(VTerm *vterm, long_u *rgb)\n{\n    int\t\tindex = 0;\n    VTermState\t*state = vterm_obtain_state(vterm);\n\n    for (; index < 16; index++)\n    {\n\tVTermColor\tcolor;\n\tcolor.red = (unsigned)(rgb[index] >> 16);\n\tcolor.green = (unsigned)(rgb[index] >> 8) & 255;\n\tcolor.blue = (unsigned)rgb[index] & 255;\n\tvterm_state_set_palette_color(state, index, &color);\n    }\n}\n\n/*\n * Set the ANSI color palette from a list of colors\n */\n    static int\nset_ansi_colors_list(VTerm *vterm, list_T *list)\n{\n    int\t\tn = 0;\n    long_u\trgb[16];\n    listitem_T\t*li = list->lv_first;\n\n    for (; li != NULL && n < 16; li = li->li_next, n++)\n    {\n\tchar_u\t\t*color_name;\n\tguicolor_T\tguicolor;\n\n\tcolor_name = tv_get_string_chk(&li->li_tv);\n\tif (color_name == NULL)\n\t    return FAIL;\n\n\tguicolor = GUI_GET_COLOR(color_name);\n\tif (guicolor == INVALCOLOR)\n\t    return FAIL;\n\n\trgb[n] = GUI_MCH_GET_RGB(guicolor);\n    }\n\n    if (n != 16 || li != NULL)\n\treturn FAIL;\n\n    set_vterm_palette(vterm, rgb);\n\n    return OK;\n}\n\n/*\n * Initialize the ANSI color palette from g:terminal_ansi_colors[0:15]\n */\n    static void\ninit_vterm_ansi_colors(VTerm *vterm)\n{\n    dictitem_T\t*var = find_var((char_u *)\"g:terminal_ansi_colors\", NULL, TRUE);\n\n    if (var != NULL\n\t    && (var->di_tv.v_type != VAR_LIST\n\t\t|| var->di_tv.vval.v_list == NULL\n\t\t|| set_ansi_colors_list(vterm, var->di_tv.vval.v_list) == FAIL))\n\tEMSG2(_(e_invarg2), \"g:terminal_ansi_colors\");\n}\n#endif\n\n/*\n * Handles a \"drop\" command from the job in the terminal.\n * \"item\" is the file name, \"item->li_next\" may have options.\n */\n    static void\nhandle_drop_command(listitem_T *item)\n{\n    char_u\t*fname = tv_get_string(&item->li_tv);\n    listitem_T\t*opt_item = item->li_next;\n    int\t\tbufnr;\n    win_T\t*wp;\n    tabpage_T   *tp;\n    exarg_T\tea;\n    char_u\t*tofree = NULL;\n\n    bufnr = buflist_add(fname, BLN_LISTED | BLN_NOOPT);\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer->b_fnum == bufnr)\n\t{\n\t    /* buffer is in a window already, go there */\n\t    goto_tabpage_win(tp, wp);\n\t    return;\n\t}\n    }\n\n    vim_memset(&ea, 0, sizeof(ea));\n\n    if (opt_item != NULL && opt_item->li_tv.v_type == VAR_DICT\n\t\t\t\t\t&& opt_item->li_tv.vval.v_dict != NULL)\n    {\n\tdict_T *dict = opt_item->li_tv.vval.v_dict;\n\tchar_u *p;\n\n\tp = dict_get_string(dict, (char_u *)\"ff\", FALSE);\n\tif (p == NULL)\n\t    p = dict_get_string(dict, (char_u *)\"fileformat\", FALSE);\n\tif (p != NULL)\n\t{\n\t    if (check_ff_value(p) == FAIL)\n\t\tch_log(NULL, \"Invalid ff argument to drop: %s\", p);\n\t    else\n\t\tea.force_ff = *p;\n\t}\n\tp = dict_get_string(dict, (char_u *)\"enc\", FALSE);\n\tif (p == NULL)\n\t    p = dict_get_string(dict, (char_u *)\"encoding\", FALSE);\n\tif (p != NULL)\n\t{\n\t    ea.cmd = alloc((int)STRLEN(p) + 12);\n\t    if (ea.cmd != NULL)\n\t    {\n\t\tsprintf((char *)ea.cmd, \"sbuf ++enc=%s\", p);\n\t\tea.force_enc = 11;\n\t\ttofree = ea.cmd;\n\t    }\n\t}\n\n\tp = dict_get_string(dict, (char_u *)\"bad\", FALSE);\n\tif (p != NULL)\n\t    get_bad_opt(p, &ea);\n\n\tif (dict_find(dict, (char_u *)\"bin\", -1) != NULL)\n\t    ea.force_bin = FORCE_BIN;\n\tif (dict_find(dict, (char_u *)\"binary\", -1) != NULL)\n\t    ea.force_bin = FORCE_BIN;\n\tif (dict_find(dict, (char_u *)\"nobin\", -1) != NULL)\n\t    ea.force_bin = FORCE_NOBIN;\n\tif (dict_find(dict, (char_u *)\"nobinary\", -1) != NULL)\n\t    ea.force_bin = FORCE_NOBIN;\n    }\n\n    /* open in new window, like \":split fname\" */\n    if (ea.cmd == NULL)\n\tea.cmd = (char_u *)\"split\";\n    ea.arg = fname;\n    ea.cmdidx = CMD_split;\n    ex_splitview(&ea);\n\n    vim_free(tofree);\n}\n\n/*\n * Handles a function call from the job running in a terminal.\n * \"item\" is the function name, \"item->li_next\" has the arguments.\n */\n    static void\nhandle_call_command(term_T *term, channel_T *channel, listitem_T *item)\n{\n    char_u\t*func;\n    typval_T\targvars[2];\n    typval_T\trettv;\n    int\t\tdoesrange;\n\n    if (item->li_next == NULL)\n    {\n\tch_log(channel, \"Missing function arguments for call\");\n\treturn;\n    }\n    func = tv_get_string(&item->li_tv);\n\n    if (STRNCMP(func, \"Tapi_\", 5) != 0)\n    {\n\tch_log(channel, \"Invalid function name: %s\", func);\n\treturn;\n    }\n\n    argvars[0].v_type = VAR_NUMBER;\n    argvars[0].vval.v_number = term->tl_buffer->b_fnum;\n    argvars[1] = item->li_next->li_tv;\n    if (call_func(func, (int)STRLEN(func), &rettv,\n\t\t2, argvars, /* argv_func */ NULL,\n\t\t/* firstline */ 1, /* lastline */ 1,\n\t\t&doesrange, /* evaluate */ TRUE,\n\t\t/* partial */ NULL, /* selfdict */ NULL) == OK)\n    {\n\tclear_tv(&rettv);\n\tch_log(channel, \"Function %s called\", func);\n    }\n    else\n\tch_log(channel, \"Calling function %s failed\", func);\n}\n\n/*\n * Called by libvterm when it cannot recognize an OSC sequence.\n * We recognize a terminal API command.\n */\n    static int\nparse_osc(const char *command, size_t cmdlen, void *user)\n{\n    term_T\t*term = (term_T *)user;\n    js_read_T\treader;\n    typval_T\ttv;\n    channel_T\t*channel = term->tl_job == NULL ? NULL\n\t\t\t\t\t\t    : term->tl_job->jv_channel;\n\n    /* We recognize only OSC 5 1 ; {command} */\n    if (cmdlen < 3 || STRNCMP(command, \"51;\", 3) != 0)\n\treturn 0; /* not handled */\n\n    reader.js_buf = vim_strnsave((char_u *)command + 3, (int)(cmdlen - 3));\n    if (reader.js_buf == NULL)\n\treturn 1;\n    reader.js_fill = NULL;\n    reader.js_used = 0;\n    if (json_decode(&reader, &tv, 0) == OK\n\t    && tv.v_type == VAR_LIST\n\t    && tv.vval.v_list != NULL)\n    {\n\tlistitem_T *item = tv.vval.v_list->lv_first;\n\n\tif (item == NULL)\n\t    ch_log(channel, \"Missing command\");\n\telse\n\t{\n\t    char_u\t*cmd = tv_get_string(&item->li_tv);\n\n\t    /* Make sure an invoked command doesn't delete the buffer (and the\n\t     * terminal) under our fingers. */\n\t    ++term->tl_buffer->b_locked;\n\n\t    item = item->li_next;\n\t    if (item == NULL)\n\t\tch_log(channel, \"Missing argument for %s\", cmd);\n\t    else if (STRCMP(cmd, \"drop\") == 0)\n\t\thandle_drop_command(item);\n\t    else if (STRCMP(cmd, \"call\") == 0)\n\t\thandle_call_command(term, channel, item);\n\t    else\n\t\tch_log(channel, \"Invalid command received: %s\", cmd);\n\t    --term->tl_buffer->b_locked;\n\t}\n    }\n    else\n\tch_log(channel, \"Invalid JSON received\");\n\n    vim_free(reader.js_buf);\n    clear_tv(&tv);\n    return 1;\n}\n\nstatic VTermParserCallbacks parser_fallbacks = {\n  NULL,\t\t/* text */\n  NULL,\t\t/* control */\n  NULL,\t\t/* escape */\n  NULL,\t\t/* csi */\n  parse_osc,\t/* osc */\n  NULL,\t\t/* dcs */\n  NULL\t\t/* resize */\n};\n\n/*\n * Use Vim's allocation functions for vterm so profiling works.\n */\n    static void *\nvterm_malloc(size_t size, void *data UNUSED)\n{\n    return alloc_clear((unsigned) size);\n}\n\n    static void\nvterm_memfree(void *ptr, void *data UNUSED)\n{\n    vim_free(ptr);\n}\n\nstatic VTermAllocatorFunctions vterm_allocator = {\n  &vterm_malloc,\n  &vterm_memfree\n};\n\n/*\n * Create a new vterm and initialize it.\n * Return FAIL when out of memory.\n */\n    static int\ncreate_vterm(term_T *term, int rows, int cols)\n{\n    VTerm\t    *vterm;\n    VTermScreen\t    *screen;\n    VTermState\t    *state;\n    VTermValue\t    value;\n\n    vterm = vterm_new_with_allocator(rows, cols, &vterm_allocator, NULL);\n    term->tl_vterm = vterm;\n    if (vterm == NULL)\n\treturn FAIL;\n\n    // Allocate screen and state here, so we can bail out if that fails.\n    state = vterm_obtain_state(vterm);\n    screen = vterm_obtain_screen(vterm);\n    if (state == NULL || screen == NULL)\n    {\n\tvterm_free(vterm);\n\treturn FAIL;\n    }\n\n    vterm_screen_set_callbacks(screen, &screen_callbacks, term);\n    /* TODO: depends on 'encoding'. */\n    vterm_set_utf8(vterm, 1);\n\n    init_default_colors(term);\n\n    vterm_state_set_default_colors(\n\t    state,\n\t    &term->tl_default_color.fg,\n\t    &term->tl_default_color.bg);\n\n    if (t_colors >= 16)\n\tvterm_state_set_bold_highbright(vterm_obtain_state(vterm), 1);\n\n    /* Required to initialize most things. */\n    vterm_screen_reset(screen, 1 /* hard */);\n\n    /* Allow using alternate screen. */\n    vterm_screen_enable_altscreen(screen, 1);\n\n    /* For unix do not use a blinking cursor.  In an xterm this causes the\n     * cursor to blink if it's blinking in the xterm.\n     * For Windows we respect the system wide setting. */\n#ifdef WIN3264\n    if (GetCaretBlinkTime() == INFINITE)\n\tvalue.boolean = 0;\n    else\n\tvalue.boolean = 1;\n#else\n    value.boolean = 0;\n#endif\n    vterm_state_set_termprop(state, VTERM_PROP_CURSORBLINK, &value);\n    vterm_state_set_unrecognised_fallbacks(state, &parser_fallbacks, term);\n\n    return OK;\n}\n\n/*\n * Return the text to show for the buffer name and status.\n */\n    char_u *\nterm_get_status_text(term_T *term)\n{\n    if (term->tl_status_text == NULL)\n    {\n\tchar_u *txt;\n\tsize_t len;\n\n\tif (term->tl_normal_mode)\n\t{\n\t    if (term_job_running(term))\n\t\ttxt = (char_u *)_(\"Terminal\");\n\t    else\n\t\ttxt = (char_u *)_(\"Terminal-finished\");\n\t}\n\telse if (term->tl_title != NULL)\n\t    txt = term->tl_title;\n\telse if (term_none_open(term))\n\t    txt = (char_u *)_(\"active\");\n\telse if (term_job_running(term))\n\t    txt = (char_u *)_(\"running\");\n\telse\n\t    txt = (char_u *)_(\"finished\");\n\tlen = 9 + STRLEN(term->tl_buffer->b_fname) + STRLEN(txt);\n\tterm->tl_status_text = alloc((int)len);\n\tif (term->tl_status_text != NULL)\n\t    vim_snprintf((char *)term->tl_status_text, len, \"%s [%s]\",\n\t\t\t\t\t\tterm->tl_buffer->b_fname, txt);\n    }\n    return term->tl_status_text;\n}\n\n/*\n * Mark references in jobs of terminals.\n */\n    int\nset_ref_in_term(int copyID)\n{\n    int\t\tabort = FALSE;\n    term_T\t*term;\n    typval_T\ttv;\n\n    for (term = first_term; term != NULL; term = term->tl_next)\n\tif (term->tl_job != NULL)\n\t{\n\t    tv.v_type = VAR_JOB;\n\t    tv.vval.v_job = term->tl_job;\n\t    abort = abort || set_ref_in_item(&tv, copyID, NULL, NULL);\n\t}\n    return abort;\n}\n\n/*\n * Cache \"Terminal\" highlight group colors.\n */\n    void\nset_terminal_default_colors(int cterm_fg, int cterm_bg)\n{\n    term_default_cterm_fg = cterm_fg - 1;\n    term_default_cterm_bg = cterm_bg - 1;\n}\n\n/*\n * Get the buffer from the first argument in \"argvars\".\n * Returns NULL when the buffer is not for a terminal window and logs a message\n * with \"where\".\n */\n    static buf_T *\nterm_get_buf(typval_T *argvars, char *where)\n{\n    buf_T *buf;\n\n    (void)tv_get_number(&argvars[0]);\t    /* issue errmsg if type error */\n    ++emsg_off;\n    buf = get_buf_tv(&argvars[0], FALSE);\n    --emsg_off;\n    if (buf == NULL || buf->b_term == NULL)\n    {\n\tch_log(NULL, \"%s: invalid buffer argument\", where);\n\treturn NULL;\n    }\n    return buf;\n}\n\n    static int\nsame_color(VTermColor *a, VTermColor *b)\n{\n    return a->red == b->red\n\t&& a->green == b->green\n\t&& a->blue == b->blue\n\t&& a->ansi_index == b->ansi_index;\n}\n\n    static void\ndump_term_color(FILE *fd, VTermColor *color)\n{\n    fprintf(fd, \"%02x%02x%02x%d\",\n\t    (int)color->red, (int)color->green, (int)color->blue,\n\t    (int)color->ansi_index);\n}\n\n/*\n * \"term_dumpwrite(buf, filename, options)\" function\n *\n * Each screen cell in full is:\n *    |{characters}+{attributes}#{fg-color}{color-idx}#{bg-color}{color-idx}\n * {characters} is a space for an empty cell\n * For a double-width character \"+\" is changed to \"*\" and the next cell is\n * skipped.\n * {attributes} is the decimal value of HL_BOLD + HL_UNDERLINE, etc.\n *\t\t\t  when \"&\" use the same as the previous cell.\n * {fg-color} is hex RGB, when \"&\" use the same as the previous cell.\n * {bg-color} is hex RGB, when \"&\" use the same as the previous cell.\n * {color-idx} is a number from 0 to 255\n *\n * Screen cell with same width, attributes and color as the previous one:\n *    |{characters}\n *\n * To use the color of the previous cell, use \"&\" instead of {color}-{idx}.\n *\n * Repeating the previous screen cell:\n *    @{count}\n */\n    void\nf_term_dumpwrite(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_dumpwrite()\");\n    term_T\t*term;\n    char_u\t*fname;\n    int\t\tmax_height = 0;\n    int\t\tmax_width = 0;\n    stat_T\tst;\n    FILE\t*fd;\n    VTermPos\tpos;\n    VTermScreen *screen;\n    VTermScreenCell prev_cell;\n    VTermState\t*state;\n    VTermPos\tcursor_pos;\n\n    if (check_restricted() || check_secure())\n\treturn;\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n    if (term->tl_vterm == NULL)\n    {\n\tEMSG(_(\"E958: Job already finished\"));\n\treturn;\n    }\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tdict_T *d;\n\n\tif (argvars[2].v_type != VAR_DICT)\n\t{\n\t    EMSG(_(e_dictreq));\n\t    return;\n\t}\n\td = argvars[2].vval.v_dict;\n\tif (d != NULL)\n\t{\n\t    max_height = dict_get_number(d, (char_u *)\"rows\");\n\t    max_width = dict_get_number(d, (char_u *)\"columns\");\n\t}\n    }\n\n    fname = tv_get_string_chk(&argvars[1]);\n    if (fname == NULL)\n\treturn;\n    if (mch_stat((char *)fname, &st) >= 0)\n    {\n\tEMSG2(_(\"E953: File exists: %s\"), fname);\n\treturn;\n    }\n\n    if (*fname == NUL || (fd = mch_fopen((char *)fname, WRITEBIN)) == NULL)\n    {\n\tEMSG2(_(e_notcreate), *fname == NUL ? (char_u *)_(\"<empty>\") : fname);\n\treturn;\n    }\n\n    vim_memset(&prev_cell, 0, sizeof(prev_cell));\n\n    screen = vterm_obtain_screen(term->tl_vterm);\n    state = vterm_obtain_state(term->tl_vterm);\n    vterm_state_get_cursorpos(state, &cursor_pos);\n\n    for (pos.row = 0; (max_height == 0 || pos.row < max_height)\n\t\t\t\t\t && pos.row < term->tl_rows; ++pos.row)\n    {\n\tint\t\trepeat = 0;\n\n\tfor (pos.col = 0; (max_width == 0 || pos.col < max_width)\n\t\t\t\t\t && pos.col < term->tl_cols; ++pos.col)\n\t{\n\t    VTermScreenCell cell;\n\t    int\t\t    same_attr;\n\t    int\t\t    same_chars = TRUE;\n\t    int\t\t    i;\n\t    int\t\t    is_cursor_pos = (pos.col == cursor_pos.col\n\t\t\t\t\t\t && pos.row == cursor_pos.row);\n\n\t    if (vterm_screen_get_cell(screen, pos, &cell) == 0)\n\t\tvim_memset(&cell, 0, sizeof(cell));\n\n\t    for (i = 0; i < VTERM_MAX_CHARS_PER_CELL; ++i)\n\t    {\n\t\tint c = cell.chars[i];\n\t\tint pc = prev_cell.chars[i];\n\n\t\t/* For the first character NUL is the same as space. */\n\t\tif (i == 0)\n\t\t{\n\t\t    c = (c == NUL) ? ' ' : c;\n\t\t    pc = (pc == NUL) ? ' ' : pc;\n\t\t}\n\t\tif (c != pc)\n\t\t    same_chars = FALSE;\n\t\tif (c == NUL || pc == NUL)\n\t\t    break;\n\t    }\n\t    same_attr = vtermAttr2hl(cell.attrs)\n\t\t\t\t\t       == vtermAttr2hl(prev_cell.attrs)\n\t\t\t&& same_color(&cell.fg, &prev_cell.fg)\n\t\t\t&& same_color(&cell.bg, &prev_cell.bg);\n\t    if (same_chars && cell.width == prev_cell.width && same_attr\n\t\t\t\t\t\t\t     && !is_cursor_pos)\n\t    {\n\t\t++repeat;\n\t    }\n\t    else\n\t    {\n\t\tif (repeat > 0)\n\t\t{\n\t\t    fprintf(fd, \"@%d\", repeat);\n\t\t    repeat = 0;\n\t\t}\n\t\tfputs(is_cursor_pos ? \">\" : \"|\", fd);\n\n\t\tif (cell.chars[0] == NUL)\n\t\t    fputs(\" \", fd);\n\t\telse\n\t\t{\n\t\t    char_u\tcharbuf[10];\n\t\t    int\t\tlen;\n\n\t\t    for (i = 0; i < VTERM_MAX_CHARS_PER_CELL\n\t\t\t\t\t\t  && cell.chars[i] != NUL; ++i)\n\t\t    {\n\t\t\tlen = utf_char2bytes(cell.chars[i], charbuf);\n\t\t\tfwrite(charbuf, len, 1, fd);\n\t\t    }\n\t\t}\n\n\t\t/* When only the characters differ we don't write anything, the\n\t\t * following \"|\", \"@\" or NL will indicate using the same\n\t\t * attributes. */\n\t\tif (cell.width != prev_cell.width || !same_attr)\n\t\t{\n\t\t    if (cell.width == 2)\n\t\t    {\n\t\t\tfputs(\"*\", fd);\n\t\t\t++pos.col;\n\t\t    }\n\t\t    else\n\t\t\tfputs(\"+\", fd);\n\n\t\t    if (same_attr)\n\t\t    {\n\t\t\tfputs(\"&\", fd);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfprintf(fd, \"%d\", vtermAttr2hl(cell.attrs));\n\t\t\tif (same_color(&cell.fg, &prev_cell.fg))\n\t\t\t    fputs(\"&\", fd);\n\t\t\telse\n\t\t\t{\n\t\t\t    fputs(\"#\", fd);\n\t\t\t    dump_term_color(fd, &cell.fg);\n\t\t\t}\n\t\t\tif (same_color(&cell.bg, &prev_cell.bg))\n\t\t\t    fputs(\"&\", fd);\n\t\t\telse\n\t\t\t{\n\t\t\t    fputs(\"#\", fd);\n\t\t\t    dump_term_color(fd, &cell.bg);\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tprev_cell = cell;\n\t    }\n\t}\n\tif (repeat > 0)\n\t    fprintf(fd, \"@%d\", repeat);\n\tfputs(\"\\n\", fd);\n    }\n\n    fclose(fd);\n}\n\n/*\n * Called when a dump is corrupted.  Put a breakpoint here when debugging.\n */\n    static void\ndump_is_corrupt(garray_T *gap)\n{\n    ga_concat(gap, (char_u *)\"CORRUPT\");\n}\n\n    static void\nappend_cell(garray_T *gap, cellattr_T *cell)\n{\n    if (ga_grow(gap, 1) == OK)\n    {\n\t*(((cellattr_T *)gap->ga_data) + gap->ga_len) = *cell;\n\t++gap->ga_len;\n    }\n}\n\n/*\n * Read the dump file from \"fd\" and append lines to the current buffer.\n * Return the cell width of the longest line.\n */\n    static int\nread_dump_file(FILE *fd, VTermPos *cursor_pos)\n{\n    int\t\t    c;\n    garray_T\t    ga_text;\n    garray_T\t    ga_cell;\n    char_u\t    *prev_char = NULL;\n    int\t\t    attr = 0;\n    cellattr_T\t    cell;\n    term_T\t    *term = curbuf->b_term;\n    int\t\t    max_cells = 0;\n    int\t\t    start_row = term->tl_scrollback.ga_len;\n\n    ga_init2(&ga_text, 1, 90);\n    ga_init2(&ga_cell, sizeof(cellattr_T), 90);\n    vim_memset(&cell, 0, sizeof(cell));\n    cursor_pos->row = -1;\n    cursor_pos->col = -1;\n\n    c = fgetc(fd);\n    for (;;)\n    {\n\tif (c == EOF)\n\t    break;\n\tif (c == '\\r')\n\t{\n\t    // DOS line endings?  Ignore.\n\t    c = fgetc(fd);\n\t}\n\telse if (c == '\\n')\n\t{\n\t    /* End of a line: append it to the buffer. */\n\t    if (ga_text.ga_data == NULL)\n\t\tdump_is_corrupt(&ga_text);\n\t    if (ga_grow(&term->tl_scrollback, 1) == OK)\n\t    {\n\t\tsb_line_T   *line = (sb_line_T *)term->tl_scrollback.ga_data\n\t\t\t\t\t\t  + term->tl_scrollback.ga_len;\n\n\t\tif (max_cells < ga_cell.ga_len)\n\t\t    max_cells = ga_cell.ga_len;\n\t\tline->sb_cols = ga_cell.ga_len;\n\t\tline->sb_cells = ga_cell.ga_data;\n\t\tline->sb_fill_attr = term->tl_default_color;\n\t\t++term->tl_scrollback.ga_len;\n\t\tga_init(&ga_cell);\n\n\t\tga_append(&ga_text, NUL);\n\t\tml_append(curbuf->b_ml.ml_line_count, ga_text.ga_data,\n\t\t\t\t\t\t\tga_text.ga_len, FALSE);\n\t    }\n\t    else\n\t\tga_clear(&ga_cell);\n\t    ga_text.ga_len = 0;\n\n\t    c = fgetc(fd);\n\t}\n\telse if (c == '|' || c == '>')\n\t{\n\t    int prev_len = ga_text.ga_len;\n\n\t    if (c == '>')\n\t    {\n\t\tif (cursor_pos->row != -1)\n\t\t    dump_is_corrupt(&ga_text);\t/* duplicate cursor */\n\t\tcursor_pos->row = term->tl_scrollback.ga_len - start_row;\n\t\tcursor_pos->col = ga_cell.ga_len;\n\t    }\n\n\t    /* normal character(s) followed by \"+\", \"*\", \"|\", \"@\" or NL */\n\t    c = fgetc(fd);\n\t    if (c != EOF)\n\t\tga_append(&ga_text, c);\n\t    for (;;)\n\t    {\n\t\tc = fgetc(fd);\n\t\tif (c == '+' || c == '*' || c == '|' || c == '>' || c == '@'\n\t\t\t\t\t\t      || c == EOF || c == '\\n')\n\t\t    break;\n\t\tga_append(&ga_text, c);\n\t    }\n\n\t    /* save the character for repeating it */\n\t    vim_free(prev_char);\n\t    if (ga_text.ga_data != NULL)\n\t\tprev_char = vim_strnsave(((char_u *)ga_text.ga_data) + prev_len,\n\t\t\t\t\t\t    ga_text.ga_len - prev_len);\n\n\t    if (c == '@' || c == '|' || c == '>' || c == '\\n')\n\t    {\n\t\t/* use all attributes from previous cell */\n\t    }\n\t    else if (c == '+' || c == '*')\n\t    {\n\t\tint is_bg;\n\n\t\tcell.width = c == '+' ? 1 : 2;\n\n\t\tc = fgetc(fd);\n\t\tif (c == '&')\n\t\t{\n\t\t    /* use same attr as previous cell */\n\t\t    c = fgetc(fd);\n\t\t}\n\t\telse if (isdigit(c))\n\t\t{\n\t\t    /* get the decimal attribute */\n\t\t    attr = 0;\n\t\t    while (isdigit(c))\n\t\t    {\n\t\t\tattr = attr * 10 + (c - '0');\n\t\t\tc = fgetc(fd);\n\t\t    }\n\t\t    hl2vtermAttr(attr, &cell);\n\t\t}\n\t\telse\n\t\t    dump_is_corrupt(&ga_text);\n\n\t\t/* is_bg == 0: fg, is_bg == 1: bg */\n\t\tfor (is_bg = 0; is_bg <= 1; ++is_bg)\n\t\t{\n\t\t    if (c == '&')\n\t\t    {\n\t\t\t/* use same color as previous cell */\n\t\t\tc = fgetc(fd);\n\t\t    }\n\t\t    else if (c == '#')\n\t\t    {\n\t\t\tint red, green, blue, index = 0;\n\n\t\t\tc = fgetc(fd);\n\t\t\tred = hex2nr(c);\n\t\t\tc = fgetc(fd);\n\t\t\tred = (red << 4) + hex2nr(c);\n\t\t\tc = fgetc(fd);\n\t\t\tgreen = hex2nr(c);\n\t\t\tc = fgetc(fd);\n\t\t\tgreen = (green << 4) + hex2nr(c);\n\t\t\tc = fgetc(fd);\n\t\t\tblue = hex2nr(c);\n\t\t\tc = fgetc(fd);\n\t\t\tblue = (blue << 4) + hex2nr(c);\n\t\t\tc = fgetc(fd);\n\t\t\tif (!isdigit(c))\n\t\t\t    dump_is_corrupt(&ga_text);\n\t\t\twhile (isdigit(c))\n\t\t\t{\n\t\t\t    index = index * 10 + (c - '0');\n\t\t\t    c = fgetc(fd);\n\t\t\t}\n\n\t\t\tif (is_bg)\n\t\t\t{\n\t\t\t    cell.bg.red = red;\n\t\t\t    cell.bg.green = green;\n\t\t\t    cell.bg.blue = blue;\n\t\t\t    cell.bg.ansi_index = index;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    cell.fg.red = red;\n\t\t\t    cell.fg.green = green;\n\t\t\t    cell.fg.blue = blue;\n\t\t\t    cell.fg.ansi_index = index;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tdump_is_corrupt(&ga_text);\n\t\t}\n\t    }\n\t    else\n\t\tdump_is_corrupt(&ga_text);\n\n\t    append_cell(&ga_cell, &cell);\n\t}\n\telse if (c == '@')\n\t{\n\t    if (prev_char == NULL)\n\t\tdump_is_corrupt(&ga_text);\n\t    else\n\t    {\n\t\tint count = 0;\n\n\t\t/* repeat previous character, get the count */\n\t\tfor (;;)\n\t\t{\n\t\t    c = fgetc(fd);\n\t\t    if (!isdigit(c))\n\t\t\tbreak;\n\t\t    count = count * 10 + (c - '0');\n\t\t}\n\n\t\twhile (count-- > 0)\n\t\t{\n\t\t    ga_concat(&ga_text, prev_char);\n\t\t    append_cell(&ga_cell, &cell);\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    dump_is_corrupt(&ga_text);\n\t    c = fgetc(fd);\n\t}\n    }\n\n    if (ga_text.ga_len > 0)\n    {\n\t/* trailing characters after last NL */\n\tdump_is_corrupt(&ga_text);\n\tga_append(&ga_text, NUL);\n\tml_append(curbuf->b_ml.ml_line_count, ga_text.ga_data,\n\t\t\t\t\t\t\tga_text.ga_len, FALSE);\n    }\n\n    ga_clear(&ga_text);\n    vim_free(prev_char);\n\n    return max_cells;\n}\n\n/*\n * Return an allocated string with at least \"text_width\" \"=\" characters and\n * \"fname\" inserted in the middle.\n */\n    static char_u *\nget_separator(int text_width, char_u *fname)\n{\n    int\t    width = MAX(text_width, curwin->w_width);\n    char_u  *textline;\n    int\t    fname_size;\n    char_u  *p = fname;\n    int\t    i;\n    size_t  off;\n\n    textline = alloc(width + (int)STRLEN(fname) + 1);\n    if (textline == NULL)\n\treturn NULL;\n\n    fname_size = vim_strsize(fname);\n    if (fname_size < width - 8)\n    {\n\t/* enough room, don't use the full window width */\n\twidth = MAX(text_width, fname_size + 8);\n    }\n    else if (fname_size > width - 8)\n    {\n\t/* full name doesn't fit, use only the tail */\n\tp = gettail(fname);\n\tfname_size = vim_strsize(p);\n    }\n    /* skip characters until the name fits */\n    while (fname_size > width - 8)\n    {\n\tp += (*mb_ptr2len)(p);\n\tfname_size = vim_strsize(p);\n    }\n\n    for (i = 0; i < (width - fname_size) / 2 - 1; ++i)\n\ttextline[i] = '=';\n    textline[i++] = ' ';\n\n    STRCPY(textline + i, p);\n    off = STRLEN(textline);\n    textline[off] = ' ';\n    for (i = 1; i < (width - fname_size) / 2; ++i)\n\ttextline[off + i] = '=';\n    textline[off + i] = NUL;\n\n    return textline;\n}\n\n/*\n * Common for \"term_dumpdiff()\" and \"term_dumpload()\".\n */\n    static void\nterm_load_dump(typval_T *argvars, typval_T *rettv, int do_diff)\n{\n    jobopt_T\topt;\n    buf_T\t*buf;\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    char_u\t*fname1;\n    char_u\t*fname2 = NULL;\n    char_u\t*fname_tofree = NULL;\n    FILE\t*fd1;\n    FILE\t*fd2 = NULL;\n    char_u\t*textline = NULL;\n\n    /* First open the files.  If this fails bail out. */\n    fname1 = tv_get_string_buf_chk(&argvars[0], buf1);\n    if (do_diff)\n\tfname2 = tv_get_string_buf_chk(&argvars[1], buf2);\n    if (fname1 == NULL || (do_diff && fname2 == NULL))\n    {\n\tEMSG(_(e_invarg));\n\treturn;\n    }\n    fd1 = mch_fopen((char *)fname1, READBIN);\n    if (fd1 == NULL)\n    {\n\tEMSG2(_(e_notread), fname1);\n\treturn;\n    }\n    if (do_diff)\n    {\n\tfd2 = mch_fopen((char *)fname2, READBIN);\n\tif (fd2 == NULL)\n\t{\n\t    fclose(fd1);\n\t    EMSG2(_(e_notread), fname2);\n\t    return;\n\t}\n    }\n\n    init_job_options(&opt);\n    if (argvars[do_diff ? 2 : 1].v_type != VAR_UNKNOWN\n\t    && get_job_options(&argvars[do_diff ? 2 : 1], &opt, 0,\n\t\t    JO2_TERM_NAME + JO2_TERM_COLS + JO2_TERM_ROWS\n\t\t    + JO2_VERTICAL + JO2_CURWIN + JO2_NORESTORE) == FAIL)\n\tgoto theend;\n\n    if (opt.jo_term_name == NULL)\n    {\n\tsize_t len = STRLEN(fname1) + 12;\n\n\tfname_tofree = alloc((int)len);\n\tif (fname_tofree != NULL)\n\t{\n\t    vim_snprintf((char *)fname_tofree, len, \"dump diff %s\", fname1);\n\t    opt.jo_term_name = fname_tofree;\n\t}\n    }\n\n    buf = term_start(&argvars[0], NULL, &opt, TERM_START_NOJOB);\n    if (buf != NULL && buf->b_term != NULL)\n    {\n\tint\t\ti;\n\tlinenr_T\tbot_lnum;\n\tlinenr_T\tlnum;\n\tterm_T\t\t*term = buf->b_term;\n\tint\t\twidth;\n\tint\t\twidth2;\n\tVTermPos\tcursor_pos1;\n\tVTermPos\tcursor_pos2;\n\n\tinit_default_colors(term);\n\n\trettv->vval.v_number = buf->b_fnum;\n\n\t/* read the files, fill the buffer with the diff */\n\twidth = read_dump_file(fd1, &cursor_pos1);\n\n\t/* position the cursor */\n\tif (cursor_pos1.row >= 0)\n\t{\n\t    curwin->w_cursor.lnum = cursor_pos1.row + 1;\n\t    coladvance(cursor_pos1.col);\n\t}\n\n\t/* Delete the empty line that was in the empty buffer. */\n\tml_delete(1, FALSE);\n\n\t/* For term_dumpload() we are done here. */\n\tif (!do_diff)\n\t    goto theend;\n\n\tterm->tl_top_diff_rows = curbuf->b_ml.ml_line_count;\n\n\ttextline = get_separator(width, fname1);\n\tif (textline == NULL)\n\t    goto theend;\n\tif (add_empty_scrollback(term, &term->tl_default_color, 0) == OK)\n\t    ml_append(curbuf->b_ml.ml_line_count, textline, 0, FALSE);\n\tvim_free(textline);\n\n\ttextline = get_separator(width, fname2);\n\tif (textline == NULL)\n\t    goto theend;\n\tif (add_empty_scrollback(term, &term->tl_default_color, 0) == OK)\n\t    ml_append(curbuf->b_ml.ml_line_count, textline, 0, FALSE);\n\ttextline[width] = NUL;\n\n\tbot_lnum = curbuf->b_ml.ml_line_count;\n\twidth2 = read_dump_file(fd2, &cursor_pos2);\n\tif (width2 > width)\n\t{\n\t    vim_free(textline);\n\t    textline = alloc(width2 + 1);\n\t    if (textline == NULL)\n\t\tgoto theend;\n\t    width = width2;\n\t    textline[width] = NUL;\n\t}\n\tterm->tl_bot_diff_rows = curbuf->b_ml.ml_line_count - bot_lnum;\n\n\tfor (lnum = 1; lnum <= term->tl_top_diff_rows; ++lnum)\n\t{\n\t    if (lnum + bot_lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t/* bottom part has fewer rows, fill with \"-\" */\n\t\tfor (i = 0; i < width; ++i)\n\t\t    textline[i] = '-';\n\t    }\n\t    else\n\t    {\n\t\tchar_u *line1;\n\t\tchar_u *line2;\n\t\tchar_u *p1;\n\t\tchar_u *p2;\n\t\tint\tcol;\n\t\tsb_line_T   *sb_line = (sb_line_T *)term->tl_scrollback.ga_data;\n\t\tcellattr_T *cellattr1 = (sb_line + lnum - 1)->sb_cells;\n\t\tcellattr_T *cellattr2 = (sb_line + lnum + bot_lnum - 1)\n\t\t\t\t\t\t\t\t    ->sb_cells;\n\n\t\t/* Make a copy, getting the second line will invalidate it. */\n\t\tline1 = vim_strsave(ml_get(lnum));\n\t\tif (line1 == NULL)\n\t\t    break;\n\t\tp1 = line1;\n\n\t\tline2 = ml_get(lnum + bot_lnum);\n\t\tp2 = line2;\n\t\tfor (col = 0; col < width && *p1 != NUL && *p2 != NUL; ++col)\n\t\t{\n\t\t    int len1 = utfc_ptr2len(p1);\n\t\t    int len2 = utfc_ptr2len(p2);\n\n\t\t    textline[col] = ' ';\n\t\t    if (len1 != len2 || STRNCMP(p1, p2, len1) != 0)\n\t\t\t/* text differs */\n\t\t\ttextline[col] = 'X';\n\t\t    else if (lnum == cursor_pos1.row + 1\n\t\t\t    && col == cursor_pos1.col\n\t\t\t    && (cursor_pos1.row != cursor_pos2.row\n\t\t\t\t\t|| cursor_pos1.col != cursor_pos2.col))\n\t\t\t/* cursor in first but not in second */\n\t\t\ttextline[col] = '>';\n\t\t    else if (lnum == cursor_pos2.row + 1\n\t\t\t    && col == cursor_pos2.col\n\t\t\t    && (cursor_pos1.row != cursor_pos2.row\n\t\t\t\t\t|| cursor_pos1.col != cursor_pos2.col))\n\t\t\t/* cursor in second but not in first */\n\t\t\ttextline[col] = '<';\n\t\t    else if (cellattr1 != NULL && cellattr2 != NULL)\n\t\t    {\n\t\t\tif ((cellattr1 + col)->width\n\t\t\t\t\t\t   != (cellattr2 + col)->width)\n\t\t\t    textline[col] = 'w';\n\t\t\telse if (!same_color(&(cellattr1 + col)->fg,\n\t\t\t\t\t\t   &(cellattr2 + col)->fg))\n\t\t\t    textline[col] = 'f';\n\t\t\telse if (!same_color(&(cellattr1 + col)->bg,\n\t\t\t\t\t\t   &(cellattr2 + col)->bg))\n\t\t\t    textline[col] = 'b';\n\t\t\telse if (vtermAttr2hl((cellattr1 + col)->attrs)\n\t\t\t\t   != vtermAttr2hl(((cellattr2 + col)->attrs)))\n\t\t\t    textline[col] = 'a';\n\t\t    }\n\t\t    p1 += len1;\n\t\t    p2 += len2;\n\t\t    /* TODO: handle different width */\n\t\t}\n\t\tvim_free(line1);\n\n\t\twhile (col < width)\n\t\t{\n\t\t    if (*p1 == NUL && *p2 == NUL)\n\t\t\ttextline[col] = '?';\n\t\t    else if (*p1 == NUL)\n\t\t    {\n\t\t\ttextline[col] = '+';\n\t\t\tp2 += utfc_ptr2len(p2);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\ttextline[col] = '-';\n\t\t\tp1 += utfc_ptr2len(p1);\n\t\t    }\n\t\t    ++col;\n\t\t}\n\t    }\n\t    if (add_empty_scrollback(term, &term->tl_default_color,\n\t\t\t\t\t\t term->tl_top_diff_rows) == OK)\n\t\tml_append(term->tl_top_diff_rows + lnum, textline, 0, FALSE);\n\t    ++bot_lnum;\n\t}\n\n\twhile (lnum + bot_lnum <= curbuf->b_ml.ml_line_count)\n\t{\n\t    /* bottom part has more rows, fill with \"+\" */\n\t    for (i = 0; i < width; ++i)\n\t\ttextline[i] = '+';\n\t    if (add_empty_scrollback(term, &term->tl_default_color,\n\t\t\t\t\t\t term->tl_top_diff_rows) == OK)\n\t\tml_append(term->tl_top_diff_rows + lnum, textline, 0, FALSE);\n\t    ++lnum;\n\t    ++bot_lnum;\n\t}\n\n\tterm->tl_cols = width;\n\n\t/* looks better without wrapping */\n\tcurwin->w_p_wrap = 0;\n    }\n\ntheend:\n    vim_free(textline);\n    vim_free(fname_tofree);\n    fclose(fd1);\n    if (fd2 != NULL)\n\tfclose(fd2);\n}\n\n/*\n * If the current buffer shows the output of term_dumpdiff(), swap the top and\n * bottom files.\n * Return FAIL when this is not possible.\n */\n    int\nterm_swap_diff()\n{\n    term_T\t*term = curbuf->b_term;\n    linenr_T\tline_count;\n    linenr_T\ttop_rows;\n    linenr_T\tbot_rows;\n    linenr_T\tbot_start;\n    linenr_T\tlnum;\n    char_u\t*p;\n    sb_line_T\t*sb_line;\n\n    if (term == NULL\n\t    || !term_is_finished(curbuf)\n\t    || term->tl_top_diff_rows == 0\n\t    || term->tl_scrollback.ga_len == 0)\n\treturn FAIL;\n\n    line_count = curbuf->b_ml.ml_line_count;\n    top_rows = term->tl_top_diff_rows;\n    bot_rows = term->tl_bot_diff_rows;\n    bot_start = line_count - bot_rows;\n    sb_line = (sb_line_T *)term->tl_scrollback.ga_data;\n\n    /* move lines from top to above the bottom part */\n    for (lnum = 1; lnum <= top_rows; ++lnum)\n    {\n\tp = vim_strsave(ml_get(1));\n\tif (p == NULL)\n\t    return OK;\n\tml_append(bot_start, p, 0, FALSE);\n\tml_delete(1, FALSE);\n\tvim_free(p);\n    }\n\n    /* move lines from bottom to the top */\n    for (lnum = 1; lnum <= bot_rows; ++lnum)\n    {\n\tp = vim_strsave(ml_get(bot_start + lnum));\n\tif (p == NULL)\n\t    return OK;\n\tml_delete(bot_start + lnum, FALSE);\n\tml_append(lnum - 1, p, 0, FALSE);\n\tvim_free(p);\n    }\n\n    if (top_rows == bot_rows)\n    {\n\t/* rows counts are equal, can swap cell properties */\n\tfor (lnum = 0; lnum < top_rows; ++lnum)\n\t{\n\t    sb_line_T\ttemp;\n\n\t    temp = *(sb_line + lnum);\n\t    *(sb_line + lnum) = *(sb_line + bot_start + lnum);\n\t    *(sb_line + bot_start + lnum) = temp;\n\t}\n    }\n    else\n    {\n\tsize_t\t\tsize = sizeof(sb_line_T) * term->tl_scrollback.ga_len;\n\tsb_line_T\t*temp = (sb_line_T *)alloc((int)size);\n\n\t/* need to copy cell properties into temp memory */\n\tif (temp != NULL)\n\t{\n\t    mch_memmove(temp, term->tl_scrollback.ga_data, size);\n\t    mch_memmove(term->tl_scrollback.ga_data,\n\t\t    temp + bot_start,\n\t\t    sizeof(sb_line_T) * bot_rows);\n\t    mch_memmove((sb_line_T *)term->tl_scrollback.ga_data + bot_rows,\n\t\t    temp + top_rows,\n\t\t    sizeof(sb_line_T) * (line_count - top_rows - bot_rows));\n\t    mch_memmove((sb_line_T *)term->tl_scrollback.ga_data\n\t\t\t\t\t\t       + line_count - top_rows,\n\t\t    temp,\n\t\t    sizeof(sb_line_T) * top_rows);\n\t    vim_free(temp);\n\t}\n    }\n\n    term->tl_top_diff_rows = bot_rows;\n    term->tl_bot_diff_rows = top_rows;\n\n    update_screen(NOT_VALID);\n    return OK;\n}\n\n/*\n * \"term_dumpdiff(filename, filename, options)\" function\n */\n    void\nf_term_dumpdiff(typval_T *argvars, typval_T *rettv)\n{\n    term_load_dump(argvars, rettv, TRUE);\n}\n\n/*\n * \"term_dumpload(filename, options)\" function\n */\n    void\nf_term_dumpload(typval_T *argvars, typval_T *rettv)\n{\n    term_load_dump(argvars, rettv, FALSE);\n}\n\n/*\n * \"term_getaltscreen(buf)\" function\n */\n    void\nf_term_getaltscreen(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getaltscreen()\");\n\n    if (buf == NULL)\n\treturn;\n    rettv->vval.v_number = buf->b_term->tl_using_altscreen;\n}\n\n/*\n * \"term_getattr(attr, name)\" function\n */\n    void\nf_term_getattr(typval_T *argvars, typval_T *rettv)\n{\n    int\t    attr;\n    size_t  i;\n    char_u  *name;\n\n    static struct {\n\tchar\t    *name;\n\tint\t    attr;\n    } attrs[] = {\n\t{\"bold\",      HL_BOLD},\n\t{\"italic\",    HL_ITALIC},\n\t{\"underline\", HL_UNDERLINE},\n\t{\"strike\",    HL_STRIKETHROUGH},\n\t{\"reverse\",   HL_INVERSE},\n    };\n\n    attr = tv_get_number(&argvars[0]);\n    name = tv_get_string_chk(&argvars[1]);\n    if (name == NULL)\n\treturn;\n\n    for (i = 0; i < sizeof(attrs)/sizeof(attrs[0]); ++i)\n\tif (STRCMP(name, attrs[i].name) == 0)\n\t{\n\t    rettv->vval.v_number = (attr & attrs[i].attr) != 0 ? 1 : 0;\n\t    break;\n\t}\n}\n\n/*\n * \"term_getcursor(buf)\" function\n */\n    void\nf_term_getcursor(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getcursor()\");\n    term_T\t*term;\n    list_T\t*l;\n    dict_T\t*d;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n\n    l = rettv->vval.v_list;\n    list_append_number(l, term->tl_cursor_pos.row + 1);\n    list_append_number(l, term->tl_cursor_pos.col + 1);\n\n    d = dict_alloc();\n    if (d != NULL)\n    {\n\tdict_add_number(d, \"visible\", term->tl_cursor_visible);\n\tdict_add_number(d, \"blink\", blink_state_is_inverted()\n\t\t\t    ? !term->tl_cursor_blink : term->tl_cursor_blink);\n\tdict_add_number(d, \"shape\", term->tl_cursor_shape);\n\tdict_add_string(d, \"color\", cursor_color_get(term->tl_cursor_color));\n\tlist_append_dict(l, d);\n    }\n}\n\n/*\n * \"term_getjob(buf)\" function\n */\n    void\nf_term_getjob(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getjob()\");\n\n    if (buf == NULL)\n    {\n\trettv->v_type = VAR_SPECIAL;\n\trettv->vval.v_number = VVAL_NULL;\n\treturn;\n    }\n\n    rettv->v_type = VAR_JOB;\n    rettv->vval.v_job = buf->b_term->tl_job;\n    if (rettv->vval.v_job != NULL)\n\t++rettv->vval.v_job->jv_refcount;\n}\n\n    static int\nget_row_number(typval_T *tv, term_T *term)\n{\n    if (tv->v_type == VAR_STRING\n\t    && tv->vval.v_string != NULL\n\t    && STRCMP(tv->vval.v_string, \".\") == 0)\n\treturn term->tl_cursor_pos.row;\n    return (int)tv_get_number(tv) - 1;\n}\n\n/*\n * \"term_getline(buf, row)\" function\n */\n    void\nf_term_getline(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t    *buf = term_get_buf(argvars, \"term_getline()\");\n    term_T\t    *term;\n    int\t\t    row;\n\n    rettv->v_type = VAR_STRING;\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n    row = get_row_number(&argvars[1], term);\n\n    if (term->tl_vterm == NULL)\n    {\n\tlinenr_T lnum = row + term->tl_scrollback_scrolled + 1;\n\n\t/* vterm is finished, get the text from the buffer */\n\tif (lnum > 0 && lnum <= buf->b_ml.ml_line_count)\n\t    rettv->vval.v_string = vim_strsave(ml_get_buf(buf, lnum, FALSE));\n    }\n    else\n    {\n\tVTermScreen\t*screen = vterm_obtain_screen(term->tl_vterm);\n\tVTermRect\trect;\n\tint\t\tlen;\n\tchar_u\t\t*p;\n\n\tif (row < 0 || row >= term->tl_rows)\n\t    return;\n\tlen = term->tl_cols * MB_MAXBYTES + 1;\n\tp = alloc(len);\n\tif (p == NULL)\n\t    return;\n\trettv->vval.v_string = p;\n\n\trect.start_col = 0;\n\trect.end_col = term->tl_cols;\n\trect.start_row = row;\n\trect.end_row = row + 1;\n\tp[vterm_screen_get_text(screen, (char *)p, len, rect)] = NUL;\n    }\n}\n\n/*\n * \"term_getscrolled(buf)\" function\n */\n    void\nf_term_getscrolled(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getscrolled()\");\n\n    if (buf == NULL)\n\treturn;\n    rettv->vval.v_number = buf->b_term->tl_scrollback_scrolled;\n}\n\n/*\n * \"term_getsize(buf)\" function\n */\n    void\nf_term_getsize(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getsize()\");\n    list_T\t*l;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n    if (buf == NULL)\n\treturn;\n\n    l = rettv->vval.v_list;\n    list_append_number(l, buf->b_term->tl_rows);\n    list_append_number(l, buf->b_term->tl_cols);\n}\n\n/*\n * \"term_setsize(buf, rows, cols)\" function\n */\n    void\nf_term_setsize(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_setsize()\");\n    term_T\t*term;\n    varnumber_T rows, cols;\n\n    if (buf == NULL)\n    {\n\tEMSG(_(\"E955: Not a terminal buffer\"));\n\treturn;\n    }\n    if (buf->b_term->tl_vterm == NULL)\n\treturn;\n    term = buf->b_term;\n    rows = tv_get_number(&argvars[1]);\n    rows = rows <= 0 ? term->tl_rows : rows;\n    cols = tv_get_number(&argvars[2]);\n    cols = cols <= 0 ? term->tl_cols : cols;\n    vterm_set_size(term->tl_vterm, rows, cols);\n    /* handle_resize() will resize the windows */\n\n    /* Get and remember the size we ended up with.  Update the pty. */\n    vterm_get_size(term->tl_vterm, &term->tl_rows, &term->tl_cols);\n    term_report_winsize(term, term->tl_rows, term->tl_cols);\n}\n\n/*\n * \"term_getstatus(buf)\" function\n */\n    void\nf_term_getstatus(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getstatus()\");\n    term_T\t*term;\n    char_u\tval[100];\n\n    rettv->v_type = VAR_STRING;\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n\n    if (term_job_running(term))\n\tSTRCPY(val, \"running\");\n    else\n\tSTRCPY(val, \"finished\");\n    if (term->tl_normal_mode)\n\tSTRCAT(val, \",normal\");\n    rettv->vval.v_string = vim_strsave(val);\n}\n\n/*\n * \"term_gettitle(buf)\" function\n */\n    void\nf_term_gettitle(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_gettitle()\");\n\n    rettv->v_type = VAR_STRING;\n    if (buf == NULL)\n\treturn;\n\n    if (buf->b_term->tl_title != NULL)\n\trettv->vval.v_string = vim_strsave(buf->b_term->tl_title);\n}\n\n/*\n * \"term_gettty(buf)\" function\n */\n    void\nf_term_gettty(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_gettty()\");\n    char_u\t*p = NULL;\n    int\t\tnum = 0;\n\n    rettv->v_type = VAR_STRING;\n    if (buf == NULL)\n\treturn;\n    if (argvars[1].v_type != VAR_UNKNOWN)\n\tnum = tv_get_number(&argvars[1]);\n\n    switch (num)\n    {\n\tcase 0:\n\t    if (buf->b_term->tl_job != NULL)\n\t\tp = buf->b_term->tl_job->jv_tty_out;\n\t    break;\n\tcase 1:\n\t    if (buf->b_term->tl_job != NULL)\n\t\tp = buf->b_term->tl_job->jv_tty_in;\n\t    break;\n\tdefault:\n\t    EMSG2(_(e_invarg2), tv_get_string(&argvars[1]));\n\t    return;\n    }\n    if (p != NULL)\n\trettv->vval.v_string = vim_strsave(p);\n}\n\n/*\n * \"term_list()\" function\n */\n    void\nf_term_list(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    term_T\t*tp;\n    list_T\t*l;\n\n    if (rettv_list_alloc(rettv) == FAIL || first_term == NULL)\n\treturn;\n\n    l = rettv->vval.v_list;\n    for (tp = first_term; tp != NULL; tp = tp->tl_next)\n\tif (tp != NULL && tp->tl_buffer != NULL)\n\t    if (list_append_number(l,\n\t\t\t\t   (varnumber_T)tp->tl_buffer->b_fnum) == FAIL)\n\t\treturn;\n}\n\n/*\n * \"term_scrape(buf, row)\" function\n */\n    void\nf_term_scrape(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t    *buf = term_get_buf(argvars, \"term_scrape()\");\n    VTermScreen\t    *screen = NULL;\n    VTermPos\t    pos;\n    list_T\t    *l;\n    term_T\t    *term;\n    char_u\t    *p;\n    sb_line_T\t    *line;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n\n    l = rettv->vval.v_list;\n    pos.row = get_row_number(&argvars[1], term);\n\n    if (term->tl_vterm != NULL)\n    {\n\tscreen = vterm_obtain_screen(term->tl_vterm);\n\tp = NULL;\n\tline = NULL;\n    }\n    else\n    {\n\tlinenr_T\tlnum = pos.row + term->tl_scrollback_scrolled;\n\n\tif (lnum < 0 || lnum >= term->tl_scrollback.ga_len)\n\t    return;\n\tp = ml_get_buf(buf, lnum + 1, FALSE);\n\tline = (sb_line_T *)term->tl_scrollback.ga_data + lnum;\n    }\n\n    for (pos.col = 0; pos.col < term->tl_cols; )\n    {\n\tdict_T\t\t*dcell;\n\tint\t\twidth;\n\tVTermScreenCellAttrs attrs;\n\tVTermColor\tfg, bg;\n\tchar_u\t\trgb[8];\n\tchar_u\t\tmbs[MB_MAXBYTES * VTERM_MAX_CHARS_PER_CELL + 1];\n\tint\t\toff = 0;\n\tint\t\ti;\n\n\tif (screen == NULL)\n\t{\n\t    cellattr_T\t*cellattr;\n\t    int\t\tlen;\n\n\t    /* vterm has finished, get the cell from scrollback */\n\t    if (pos.col >= line->sb_cols)\n\t\tbreak;\n\t    cellattr = line->sb_cells + pos.col;\n\t    width = cellattr->width;\n\t    attrs = cellattr->attrs;\n\t    fg = cellattr->fg;\n\t    bg = cellattr->bg;\n\t    len = MB_PTR2LEN(p);\n\t    mch_memmove(mbs, p, len);\n\t    mbs[len] = NUL;\n\t    p += len;\n\t}\n\telse\n\t{\n\t    VTermScreenCell cell;\n\t    if (vterm_screen_get_cell(screen, pos, &cell) == 0)\n\t\tbreak;\n\t    for (i = 0; i < VTERM_MAX_CHARS_PER_CELL; ++i)\n\t    {\n\t\tif (cell.chars[i] == 0)\n\t\t    break;\n\t\toff += (*utf_char2bytes)((int)cell.chars[i], mbs + off);\n\t    }\n\t    mbs[off] = NUL;\n\t    width = cell.width;\n\t    attrs = cell.attrs;\n\t    fg = cell.fg;\n\t    bg = cell.bg;\n\t}\n\tdcell = dict_alloc();\n\tif (dcell == NULL)\n\t    break;\n\tlist_append_dict(l, dcell);\n\n\tdict_add_string(dcell, \"chars\", mbs);\n\n\tvim_snprintf((char *)rgb, 8, \"#%02x%02x%02x\",\n\t\t\t\t     fg.red, fg.green, fg.blue);\n\tdict_add_string(dcell, \"fg\", rgb);\n\tvim_snprintf((char *)rgb, 8, \"#%02x%02x%02x\",\n\t\t\t\t     bg.red, bg.green, bg.blue);\n\tdict_add_string(dcell, \"bg\", rgb);\n\n\tdict_add_number(dcell, \"attr\", cell2attr(attrs, fg, bg));\n\tdict_add_number(dcell, \"width\", width);\n\n\t++pos.col;\n\tif (width == 2)\n\t    ++pos.col;\n    }\n}\n\n/*\n * \"term_sendkeys(buf, keys)\" function\n */\n    void\nf_term_sendkeys(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_sendkeys()\");\n    char_u\t*msg;\n    term_T\t*term;\n\n    rettv->v_type = VAR_UNKNOWN;\n    if (buf == NULL)\n\treturn;\n\n    msg = tv_get_string_chk(&argvars[1]);\n    if (msg == NULL)\n\treturn;\n    term = buf->b_term;\n    if (term->tl_vterm == NULL)\n\treturn;\n\n    while (*msg != NUL)\n    {\n\tint c;\n\n\tif (*msg == K_SPECIAL && msg[1] != NUL && msg[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(msg[1], msg[2]);\n\t    msg += 3;\n\t}\n\telse\n\t{\n\t    c = PTR2CHAR(msg);\n\t    msg += MB_CPTR2LEN(msg);\n\t}\n\tsend_keys_to_term(term, c, FALSE);\n    }\n}\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS) || defined(PROTO)\n/*\n * \"term_getansicolors(buf)\" function\n */\n    void\nf_term_getansicolors(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_getansicolors()\");\n    term_T\t*term;\n    VTermState\t*state;\n    VTermColor  color;\n    char_u\thexbuf[10];\n    int\t\tindex;\n    list_T\t*list;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n    if (term->tl_vterm == NULL)\n\treturn;\n\n    list = rettv->vval.v_list;\n    state = vterm_obtain_state(term->tl_vterm);\n    for (index = 0; index < 16; index++)\n    {\n\tvterm_state_get_palette_color(state, index, &color);\n\tsprintf((char *)hexbuf, \"#%02x%02x%02x\",\n\t\tcolor.red, color.green, color.blue);\n\tif (list_append_string(list, hexbuf, 7) == FAIL)\n\t    return;\n    }\n}\n\n/*\n * \"term_setansicolors(buf, list)\" function\n */\n    void\nf_term_setansicolors(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_setansicolors()\");\n    term_T\t*term;\n\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n    if (term->tl_vterm == NULL)\n\treturn;\n\n    if (argvars[1].v_type != VAR_LIST || argvars[1].vval.v_list == NULL)\n    {\n\tEMSG(_(e_listreq));\n\treturn;\n    }\n\n    if (set_ansi_colors_list(term->tl_vterm, argvars[1].vval.v_list) == FAIL)\n\tEMSG(_(e_invarg));\n}\n#endif\n\n/*\n * \"term_setrestore(buf, command)\" function\n */\n    void\nf_term_setrestore(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n#if defined(FEAT_SESSION)\n    buf_T\t*buf = term_get_buf(argvars, \"term_setrestore()\");\n    term_T\t*term;\n    char_u\t*cmd;\n\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n    vim_free(term->tl_command);\n    cmd = tv_get_string_chk(&argvars[1]);\n    if (cmd != NULL)\n\tterm->tl_command = vim_strsave(cmd);\n    else\n\tterm->tl_command = NULL;\n#endif\n}\n\n/*\n * \"term_setkill(buf, how)\" function\n */\n    void\nf_term_setkill(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_setkill()\");\n    term_T\t*term;\n    char_u\t*how;\n\n    if (buf == NULL)\n\treturn;\n    term = buf->b_term;\n    vim_free(term->tl_kill);\n    how = tv_get_string_chk(&argvars[1]);\n    if (how != NULL)\n\tterm->tl_kill = vim_strsave(how);\n    else\n\tterm->tl_kill = NULL;\n}\n\n/*\n * \"term_start(command, options)\" function\n */\n    void\nf_term_start(typval_T *argvars, typval_T *rettv)\n{\n    jobopt_T\topt;\n    buf_T\t*buf;\n\n    init_job_options(&opt);\n    if (argvars[1].v_type != VAR_UNKNOWN\n\t    && get_job_options(&argvars[1], &opt,\n\t\tJO_TIMEOUT_ALL + JO_STOPONEXIT\n\t\t    + JO_CALLBACK + JO_OUT_CALLBACK + JO_ERR_CALLBACK\n\t\t    + JO_EXIT_CB + JO_CLOSE_CALLBACK + JO_OUT_IO,\n\t\tJO2_TERM_NAME + JO2_TERM_FINISH + JO2_HIDDEN + JO2_TERM_OPENCMD\n\t\t    + JO2_TERM_COLS + JO2_TERM_ROWS + JO2_VERTICAL + JO2_CURWIN\n\t\t    + JO2_CWD + JO2_ENV + JO2_EOF_CHARS\n\t\t    + JO2_NORESTORE + JO2_TERM_KILL\n\t\t    + JO2_ANSI_COLORS) == FAIL)\n\treturn;\n\n    buf = term_start(&argvars[0], NULL, &opt, 0);\n\n    if (buf != NULL && buf->b_term != NULL)\n\trettv->vval.v_number = buf->b_fnum;\n}\n\n/*\n * \"term_wait\" function\n */\n    void\nf_term_wait(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = term_get_buf(argvars, \"term_wait()\");\n\n    if (buf == NULL)\n\treturn;\n    if (buf->b_term->tl_job == NULL)\n    {\n\tch_log(NULL, \"term_wait(): no job to wait for\");\n\treturn;\n    }\n    if (buf->b_term->tl_job->jv_channel == NULL)\n\t/* channel is closed, nothing to do */\n\treturn;\n\n    /* Get the job status, this will detect a job that finished. */\n    if (!buf->b_term->tl_job->jv_channel->ch_keep_open\n\t    && STRCMP(job_status(buf->b_term->tl_job), \"dead\") == 0)\n    {\n\t/* The job is dead, keep reading channel I/O until the channel is\n\t * closed. buf->b_term may become NULL if the terminal was closed while\n\t * waiting. */\n\tch_log(NULL, \"term_wait(): waiting for channel to close\");\n\twhile (buf->b_term != NULL && !buf->b_term->tl_channel_closed)\n\t{\n\t    mch_check_messages();\n\t    parse_queued_messages();\n\t    ui_delay(10L, FALSE);\n\t    if (!buf_valid(buf))\n\t\t/* If the terminal is closed when the channel is closed the\n\t\t * buffer disappears. */\n\t\tbreak;\n\t}\n\tmch_check_messages();\n\tparse_queued_messages();\n    }\n    else\n    {\n\tlong wait = 10L;\n\n\tmch_check_messages();\n\tparse_queued_messages();\n\n\t/* Wait for some time for any channel I/O. */\n\tif (argvars[1].v_type != VAR_UNKNOWN)\n\t    wait = tv_get_number(&argvars[1]);\n\tui_delay(wait, TRUE);\n\tmch_check_messages();\n\n\t/* Flushing messages on channels is hopefully sufficient.\n\t * TODO: is there a better way? */\n\tparse_queued_messages();\n    }\n}\n\n/*\n * Called when a channel has sent all the lines to a terminal.\n * Send a CTRL-D to mark the end of the text.\n */\n    void\nterm_send_eof(channel_T *ch)\n{\n    term_T\t*term;\n\n    for (term = first_term; term != NULL; term = term->tl_next)\n\tif (term->tl_job == ch->ch_job)\n\t{\n\t    if (term->tl_eof_chars != NULL)\n\t    {\n\t\tchannel_send(ch, PART_IN, term->tl_eof_chars,\n\t\t\t\t\t(int)STRLEN(term->tl_eof_chars), NULL);\n\t\tchannel_send(ch, PART_IN, (char_u *)\"\\r\", 1, NULL);\n\t    }\n# ifdef WIN3264\n\t    else\n\t\t/* Default: CTRL-D */\n\t\tchannel_send(ch, PART_IN, (char_u *)\"\\004\\r\", 2, NULL);\n# endif\n\t}\n}\n\n    job_T *\nterm_getjob(term_T *term)\n{\n    return term != NULL ? term->tl_job : NULL;\n}\n\n# if defined(WIN3264) || defined(PROTO)\n\n/**************************************\n * 2. MS-Windows implementation.\n */\n\n#  ifndef PROTO\n\n#define WINPTY_SPAWN_FLAG_AUTO_SHUTDOWN 1ul\n#define WINPTY_SPAWN_FLAG_EXIT_AFTER_SHUTDOWN 2ull\n#define WINPTY_MOUSE_MODE_FORCE\t\t2\n\nvoid* (*winpty_config_new)(UINT64, void*);\nvoid* (*winpty_open)(void*, void*);\nvoid* (*winpty_spawn_config_new)(UINT64, void*, LPCWSTR, void*, void*, void*);\nBOOL (*winpty_spawn)(void*, void*, HANDLE*, HANDLE*, DWORD*, void*);\nvoid (*winpty_config_set_mouse_mode)(void*, int);\nvoid (*winpty_config_set_initial_size)(void*, int, int);\nLPCWSTR (*winpty_conin_name)(void*);\nLPCWSTR (*winpty_conout_name)(void*);\nLPCWSTR (*winpty_conerr_name)(void*);\nvoid (*winpty_free)(void*);\nvoid (*winpty_config_free)(void*);\nvoid (*winpty_spawn_config_free)(void*);\nvoid (*winpty_error_free)(void*);\nLPCWSTR (*winpty_error_msg)(void*);\nBOOL (*winpty_set_size)(void*, int, int, void*);\nHANDLE (*winpty_agent_process)(void*);\n\n#define WINPTY_DLL \"winpty.dll\"\n\nstatic HINSTANCE hWinPtyDLL = NULL;\n#  endif\n\n    static int\ndyn_winpty_init(int verbose)\n{\n    int i;\n    static struct\n    {\n\tchar\t    *name;\n\tFARPROC\t    *ptr;\n    } winpty_entry[] =\n    {\n\t{\"winpty_conerr_name\", (FARPROC*)&winpty_conerr_name},\n\t{\"winpty_config_free\", (FARPROC*)&winpty_config_free},\n\t{\"winpty_config_new\", (FARPROC*)&winpty_config_new},\n\t{\"winpty_config_set_mouse_mode\",\n\t\t\t\t      (FARPROC*)&winpty_config_set_mouse_mode},\n\t{\"winpty_config_set_initial_size\",\n\t\t\t\t    (FARPROC*)&winpty_config_set_initial_size},\n\t{\"winpty_conin_name\", (FARPROC*)&winpty_conin_name},\n\t{\"winpty_conout_name\", (FARPROC*)&winpty_conout_name},\n\t{\"winpty_error_free\", (FARPROC*)&winpty_error_free},\n\t{\"winpty_free\", (FARPROC*)&winpty_free},\n\t{\"winpty_open\", (FARPROC*)&winpty_open},\n\t{\"winpty_spawn\", (FARPROC*)&winpty_spawn},\n\t{\"winpty_spawn_config_free\", (FARPROC*)&winpty_spawn_config_free},\n\t{\"winpty_spawn_config_new\", (FARPROC*)&winpty_spawn_config_new},\n\t{\"winpty_error_msg\", (FARPROC*)&winpty_error_msg},\n\t{\"winpty_set_size\", (FARPROC*)&winpty_set_size},\n\t{\"winpty_agent_process\", (FARPROC*)&winpty_agent_process},\n\t{NULL, NULL}\n    };\n\n    /* No need to initialize twice. */\n    if (hWinPtyDLL)\n\treturn OK;\n    /* Load winpty.dll, prefer using the 'winptydll' option, fall back to just\n     * winpty.dll. */\n    if (*p_winptydll != NUL)\n\thWinPtyDLL = vimLoadLib((char *)p_winptydll);\n    if (!hWinPtyDLL)\n\thWinPtyDLL = vimLoadLib(WINPTY_DLL);\n    if (!hWinPtyDLL)\n    {\n\tif (verbose)\n\t    EMSG2(_(e_loadlib), *p_winptydll != NUL ? p_winptydll\n\t\t\t\t\t\t       : (char_u *)WINPTY_DLL);\n\treturn FAIL;\n    }\n    for (i = 0; winpty_entry[i].name != NULL\n\t\t\t\t\t && winpty_entry[i].ptr != NULL; ++i)\n    {\n\tif ((*winpty_entry[i].ptr = (FARPROC)GetProcAddress(hWinPtyDLL,\n\t\t\t\t\t      winpty_entry[i].name)) == NULL)\n\t{\n\t    if (verbose)\n\t\tEMSG2(_(e_loadfunc), winpty_entry[i].name);\n\t    return FAIL;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Create a new terminal of \"rows\" by \"cols\" cells.\n * Store a reference in \"term\".\n * Return OK or FAIL.\n */\n    static int\nterm_and_job_init(\n\tterm_T\t    *term,\n\ttypval_T    *argvar,\n\tchar\t    **argv UNUSED,\n\tjobopt_T    *opt,\n\tjobopt_T    *orig_opt)\n{\n    WCHAR\t    *cmd_wchar = NULL;\n    WCHAR\t    *cwd_wchar = NULL;\n    WCHAR\t    *env_wchar = NULL;\n    channel_T\t    *channel = NULL;\n    job_T\t    *job = NULL;\n    DWORD\t    error;\n    HANDLE\t    jo = NULL;\n    HANDLE\t    child_process_handle;\n    HANDLE\t    child_thread_handle;\n    void\t    *winpty_err = NULL;\n    void\t    *spawn_config = NULL;\n    garray_T\t    ga_cmd, ga_env;\n    char_u\t    *cmd = NULL;\n\n    if (dyn_winpty_init(TRUE) == FAIL)\n\treturn FAIL;\n    ga_init2(&ga_cmd, (int)sizeof(char*), 20);\n    ga_init2(&ga_env, (int)sizeof(char*), 20);\n\n    if (argvar->v_type == VAR_STRING)\n    {\n\tcmd = argvar->vval.v_string;\n    }\n    else if (argvar->v_type == VAR_LIST)\n    {\n\tif (win32_build_cmd(argvar->vval.v_list, &ga_cmd) == FAIL)\n\t    goto failed;\n\tcmd = ga_cmd.ga_data;\n    }\n    if (cmd == NULL || *cmd == NUL)\n    {\n\tEMSG(_(e_invarg));\n\tgoto failed;\n    }\n\n    cmd_wchar = enc_to_utf16(cmd, NULL);\n    ga_clear(&ga_cmd);\n    if (cmd_wchar == NULL)\n\tgoto failed;\n    if (opt->jo_cwd != NULL)\n\tcwd_wchar = enc_to_utf16(opt->jo_cwd, NULL);\n\n    win32_build_env(opt->jo_env, &ga_env, TRUE);\n    env_wchar = ga_env.ga_data;\n\n    term->tl_winpty_config = winpty_config_new(0, &winpty_err);\n    if (term->tl_winpty_config == NULL)\n\tgoto failed;\n\n    winpty_config_set_mouse_mode(term->tl_winpty_config,\n\t\t\t\t\t\t    WINPTY_MOUSE_MODE_FORCE);\n    winpty_config_set_initial_size(term->tl_winpty_config,\n\t\t\t\t\t\t term->tl_cols, term->tl_rows);\n    term->tl_winpty = winpty_open(term->tl_winpty_config, &winpty_err);\n    if (term->tl_winpty == NULL)\n\tgoto failed;\n\n    spawn_config = winpty_spawn_config_new(\n\t    WINPTY_SPAWN_FLAG_AUTO_SHUTDOWN |\n\t\tWINPTY_SPAWN_FLAG_EXIT_AFTER_SHUTDOWN,\n\t    NULL,\n\t    cmd_wchar,\n\t    cwd_wchar,\n\t    env_wchar,\n\t    &winpty_err);\n    if (spawn_config == NULL)\n\tgoto failed;\n\n    channel = add_channel();\n    if (channel == NULL)\n\tgoto failed;\n\n    job = job_alloc();\n    if (job == NULL)\n\tgoto failed;\n    if (argvar->v_type == VAR_STRING)\n    {\n\tint argc;\n\n\tbuild_argv_from_string(cmd, &job->jv_argv, &argc);\n    }\n    else\n    {\n\tint argc;\n\n\tbuild_argv_from_list(argvar->vval.v_list, &job->jv_argv, &argc);\n    }\n\n    if (opt->jo_set & JO_IN_BUF)\n\tjob->jv_in_buf = buflist_findnr(opt->jo_io_buf[PART_IN]);\n\n    if (!winpty_spawn(term->tl_winpty, spawn_config, &child_process_handle,\n\t    &child_thread_handle, &error, &winpty_err))\n\tgoto failed;\n\n    channel_set_pipes(channel,\n\t(sock_T)CreateFileW(\n\t    winpty_conin_name(term->tl_winpty),\n\t    GENERIC_WRITE, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL),\n\t(sock_T)CreateFileW(\n\t    winpty_conout_name(term->tl_winpty),\n\t    GENERIC_READ, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL),\n\t(sock_T)CreateFileW(\n\t    winpty_conerr_name(term->tl_winpty),\n\t    GENERIC_READ, 0, NULL,\n\t    OPEN_EXISTING, 0, NULL));\n\n    /* Write lines with CR instead of NL. */\n    channel->ch_write_text_mode = TRUE;\n\n    jo = CreateJobObject(NULL, NULL);\n    if (jo == NULL)\n\tgoto failed;\n\n    if (!AssignProcessToJobObject(jo, child_process_handle))\n    {\n\t/* Failed, switch the way to terminate process with TerminateProcess. */\n\tCloseHandle(jo);\n\tjo = NULL;\n    }\n\n    winpty_spawn_config_free(spawn_config);\n    vim_free(cmd_wchar);\n    vim_free(cwd_wchar);\n    vim_free(env_wchar);\n\n    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n\tgoto failed;\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (opt->jo_set2 & JO2_ANSI_COLORS)\n\tset_vterm_palette(term->tl_vterm, opt->jo_ansi_colors);\n    else\n\tinit_vterm_ansi_colors(term->tl_vterm);\n#endif\n\n    channel_set_job(channel, job, opt);\n    job_set_options(job, opt);\n\n    job->jv_channel = channel;\n    job->jv_proc_info.hProcess = child_process_handle;\n    job->jv_proc_info.dwProcessId = GetProcessId(child_process_handle);\n    job->jv_job_object = jo;\n    job->jv_status = JOB_STARTED;\n    job->jv_tty_in = utf16_to_enc(\n\t    (short_u*)winpty_conin_name(term->tl_winpty), NULL);\n    job->jv_tty_out = utf16_to_enc(\n\t    (short_u*)winpty_conout_name(term->tl_winpty), NULL);\n    ++job->jv_refcount;\n    term->tl_job = job;\n\n    /* Redirecting stdout and stderr doesn't work at the job level.  Instead\n     * open the file here and handle it in.  opt->jo_io was changed in\n     * setup_job_options(), use the original flags here. */\n    if (orig_opt->jo_io[PART_OUT] == JIO_FILE)\n    {\n\tchar_u *fname = opt->jo_io_name[PART_OUT];\n\n\tch_log(channel, \"Opening output file %s\", fname);\n\tterm->tl_out_fd = mch_fopen((char *)fname, WRITEBIN);\n\tif (term->tl_out_fd == NULL)\n\t    EMSG2(_(e_notopen), fname);\n    }\n\n    return OK;\n\nfailed:\n    ga_clear(&ga_cmd);\n    ga_clear(&ga_env);\n    vim_free(cmd_wchar);\n    vim_free(cwd_wchar);\n    if (spawn_config != NULL)\n\twinpty_spawn_config_free(spawn_config);\n    if (channel != NULL)\n\tchannel_clear(channel);\n    if (job != NULL)\n    {\n\tjob->jv_channel = NULL;\n\tjob_cleanup(job);\n    }\n    term->tl_job = NULL;\n    if (jo != NULL)\n\tCloseHandle(jo);\n    if (term->tl_winpty != NULL)\n\twinpty_free(term->tl_winpty);\n    term->tl_winpty = NULL;\n    if (term->tl_winpty_config != NULL)\n\twinpty_config_free(term->tl_winpty_config);\n    term->tl_winpty_config = NULL;\n    if (winpty_err != NULL)\n    {\n\tchar_u *msg = utf16_to_enc(\n\t\t\t\t(short_u *)winpty_error_msg(winpty_err), NULL);\n\n\tEMSG(msg);\n\twinpty_error_free(winpty_err);\n    }\n    return FAIL;\n}\n\n    static int\ncreate_pty_only(term_T *term, jobopt_T *options)\n{\n    HANDLE\t    hPipeIn = INVALID_HANDLE_VALUE;\n    HANDLE\t    hPipeOut = INVALID_HANDLE_VALUE;\n    char\t    in_name[80], out_name[80];\n    channel_T\t    *channel = NULL;\n\n    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n\treturn FAIL;\n\n    vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeIn = CreateNamedPipe(in_name, PIPE_ACCESS_OUTBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, NMPWAIT_NOWAIT, NULL);\n    if (hPipeIn == INVALID_HANDLE_VALUE)\n\tgoto failed;\n\n    vim_snprintf(out_name, sizeof(out_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-out-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeOut = CreateNamedPipe(out_name, PIPE_ACCESS_INBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, 0, NULL);\n    if (hPipeOut == INVALID_HANDLE_VALUE)\n\tgoto failed;\n\n    ConnectNamedPipe(hPipeIn, NULL);\n    ConnectNamedPipe(hPipeOut, NULL);\n\n    term->tl_job = job_alloc();\n    if (term->tl_job == NULL)\n\tgoto failed;\n    ++term->tl_job->jv_refcount;\n\n    /* behave like the job is already finished */\n    term->tl_job->jv_status = JOB_FINISHED;\n\n    channel = add_channel();\n    if (channel == NULL)\n\tgoto failed;\n    term->tl_job->jv_channel = channel;\n    channel->ch_keep_open = TRUE;\n    channel->ch_named_pipe = TRUE;\n\n    channel_set_pipes(channel,\n\t(sock_T)hPipeIn,\n\t(sock_T)hPipeOut,\n\t(sock_T)hPipeOut);\n    channel_set_job(channel, term->tl_job, options);\n    term->tl_job->jv_tty_in = vim_strsave((char_u*)in_name);\n    term->tl_job->jv_tty_out = vim_strsave((char_u*)out_name);\n\n    return OK;\n\nfailed:\n    if (hPipeIn != NULL)\n\tCloseHandle(hPipeIn);\n    if (hPipeOut != NULL)\n\tCloseHandle(hPipeOut);\n    return FAIL;\n}\n\n/*\n * Free the terminal emulator part of \"term\".\n */\n    static void\nterm_free_vterm(term_T *term)\n{\n    if (term->tl_winpty != NULL)\n\twinpty_free(term->tl_winpty);\n    term->tl_winpty = NULL;\n    if (term->tl_winpty_config != NULL)\n\twinpty_config_free(term->tl_winpty_config);\n    term->tl_winpty_config = NULL;\n    if (term->tl_vterm != NULL)\n\tvterm_free(term->tl_vterm);\n    term->tl_vterm = NULL;\n}\n\n/*\n * Report the size to the terminal.\n */\n    static void\nterm_report_winsize(term_T *term, int rows, int cols)\n{\n    if (term->tl_winpty)\n\twinpty_set_size(term->tl_winpty, cols, rows, NULL);\n}\n\n    int\nterminal_enabled(void)\n{\n    return dyn_winpty_init(FALSE) == OK;\n}\n\n# else\n\n/**************************************\n * 3. Unix-like implementation.\n */\n\n/*\n * Create a new terminal of \"rows\" by \"cols\" cells.\n * Start job for \"cmd\".\n * Store the pointers in \"term\".\n * When \"argv\" is not NULL then \"argvar\" is not used.\n * Return OK or FAIL.\n */\n    static int\nterm_and_job_init(\n\tterm_T\t    *term,\n\ttypval_T    *argvar,\n\tchar\t    **argv,\n\tjobopt_T    *opt,\n\tjobopt_T    *orig_opt UNUSED)\n{\n    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n\treturn FAIL;\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (opt->jo_set2 & JO2_ANSI_COLORS)\n\tset_vterm_palette(term->tl_vterm, opt->jo_ansi_colors);\n    else\n\tinit_vterm_ansi_colors(term->tl_vterm);\n#endif\n\n    /* This may change a string in \"argvar\". */\n    term->tl_job = job_start(argvar, argv, opt, TRUE);\n    if (term->tl_job != NULL)\n\t++term->tl_job->jv_refcount;\n\n    return term->tl_job != NULL\n\t&& term->tl_job->jv_channel != NULL\n\t&& term->tl_job->jv_status != JOB_FAILED ? OK : FAIL;\n}\n\n    static int\ncreate_pty_only(term_T *term, jobopt_T *opt)\n{\n    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n\treturn FAIL;\n\n    term->tl_job = job_alloc();\n    if (term->tl_job == NULL)\n\treturn FAIL;\n    ++term->tl_job->jv_refcount;\n\n    /* behave like the job is already finished */\n    term->tl_job->jv_status = JOB_FINISHED;\n\n    return mch_create_pty_channel(term->tl_job, opt);\n}\n\n/*\n * Free the terminal emulator part of \"term\".\n */\n    static void\nterm_free_vterm(term_T *term)\n{\n    if (term->tl_vterm != NULL)\n\tvterm_free(term->tl_vterm);\n    term->tl_vterm = NULL;\n}\n\n/*\n * Report the size to the terminal.\n */\n    static void\nterm_report_winsize(term_T *term, int rows, int cols)\n{\n    /* Use an ioctl() to report the new window size to the job. */\n    if (term->tl_job != NULL && term->tl_job->jv_channel != NULL)\n    {\n\tint fd = -1;\n\tint part;\n\n\tfor (part = PART_OUT; part < PART_COUNT; ++part)\n\t{\n\t    fd = term->tl_job->jv_channel->ch_part[part].ch_fd;\n\t    if (isatty(fd))\n\t\tbreak;\n\t}\n\tif (part < PART_COUNT && mch_report_winsize(fd, rows, cols) == OK)\n\t    mch_signal_job(term->tl_job, (char_u *)\"winch\");\n    }\n}\n\n# endif\n\n#endif /* FEAT_TERMINAL */\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#ifdef AMIGA\n# include <time.h>\t/* for time() */\n#endif\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't catenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n    strcat(longVersion, \")\");\n}\n\n# else\n    void\ninit_longVersion(void)\n{\n    char *date_time = __DATE__ \" \" __TIME__;\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t\t+ strlen(date_time);\n\n    longVersion = (char *)alloc((unsigned)len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t/* only for Amiga systems */\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n#ifdef FEAT_CMDL_COMPL\n\t\"+cmdline_compl\",\n#else\n\t\"-cmdline_compl\",\n#endif\n#ifdef FEAT_CMDHIST\n\t\"+cmdline_hist\",\n#else\n\t\"-cmdline_hist\",\n#endif\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n#ifdef FEAT_COMMENTS\n\t\"+comments\",\n#else\n\t\"-comments\",\n#endif\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_W32\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n#ifdef FEAT_FKMAP\n\t\"+farsi\",\n#else\n\t\"-farsi\",\n#endif\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    /* only interesting on Unix systems */\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n#ifdef FEAT_HANGULIN\n\t\"+hangul_input\",\n#else\n\t\"-hangul_input\",\n#endif\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n#ifdef FEAT_INS_EXPAND\n\t\"+insert_expand\",\n#else\n\t\"-insert_expand\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n#ifdef FEAT_LOCALMAP\n\t\"+localmap\",\n#else\n\t\"-localmap\",\n#endif\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n#ifdef FEAT_MODIFY_FNAME\n\t\"+modify_fname\",\n#else\n\t\"-modify_fname\",\n#endif\n#ifdef FEAT_MOUSE\n\t\"+mouse\",\n#  ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#  else\n\t\"-mouseshape\",\n#  endif\n# else\n\t\"-mouse\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_SGR\n\t\"+mouse_sgr\",\n# else\n\t\"-mouse_sgr\",\n# endif\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_xterm\",\n# else\n\t\"-mouse_xterm\",\n# endif\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n# ifdef FEAT_MBYTE\n\t\"+multi_byte\",\n# else\n\t\"-multi_byte\",\n# endif\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n#ifdef FEAT_NUM64\n\t\"+num64\",\n#else\n\t\"-num64\",\n#endif\n#ifdef FEAT_GUI_W32\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n#ifdef FEAT_SUN_WORKSHOP\n\t\"+sun_workshop\",\n#else\n\t\"-sun_workshop\",\n#endif\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    /* only interesting on Unix systems */\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n#ifdef FEAT_TAG_OLDSTATIC\n\t\"+tag_old_static\",\n#else\n\t\"-tag_old_static\",\n#endif\n#ifdef FEAT_TAG_ANYWHITE\n\t\"+tag_any_white\",\n#else\n\t\"-tag_any_white\",\n#endif\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n/* only Unix can have terminfo instead of termcap */\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_TEXT_PROP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n/* unix always includes termcap support */\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n#ifdef FEAT_USR_CMDS\n\t\"+user_commands\",\n#else\n\t\"-user_commands\",\n#endif\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n#ifdef FEAT_VIRTUALEDIT\n\t\"+virtualedit\",\n#else\n\t\"-virtualedit\",\n#endif\n\t\"+visual\",\n#ifdef FEAT_VISUALEXTRA\n\t\"+visualextra\",\n#else\n\t\"-visualextra\",\n#endif\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef WIN3264\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef WIN3264\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    int\t\ti;\n    int\t\th = 0;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] > h)\n\t    h = included_patches[i];\n    return h;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\ti;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] == n)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = (int)vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    MSG_PUTS(\"[\");\n\tMSG_PUTS(s);\n\tif (wrap)\n\t    MSG_PUTS(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n\n    /* Find the length of the longest item, use that + 1 as the column\n     * width. */\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = (int)vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t/* Not enough screen columns - show one per line */\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    /* The rightmost column doesn't need a separator.\n     * Sacrifice it to fit in one more column if possible. */\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    /* i counts columns then rows.  idx counts rows then columns. */\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n\t    msg_puts(items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0)\n\t\t    msg_putchar('\\n');\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    MSG(longVersion);\n#ifdef WIN3264\n# ifdef FEAT_GUI_W32\n#  ifdef _WIN64\n    MSG_PUTS(_(\"\\nMS-Windows 64-bit GUI version\"));\n#  else\n    MSG_PUTS(_(\"\\nMS-Windows 32-bit GUI version\"));\n#  endif\n# ifdef FEAT_OLE\n    MSG_PUTS(_(\" with OLE support\"));\n# endif\n# else\n#  ifdef _WIN64\n    MSG_PUTS(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    MSG_PUTS(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    MSG_PUTS(_(\"\\nmacOS version\"));\n# else\n    MSG_PUTS(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n#endif\n\n#ifdef VMS\n    MSG_PUTS(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tMSG_PUTS(\" - \");\n\tMSG_PUTS(compiled_arch);\n    }\n# endif\n\n#endif\n\n    /* Print the list of patch numbers if there is at least one. */\n    /* Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\" */\n    if (included_patches[0] != 0)\n    {\n\tMSG_PUTS(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\t/* find last one */\n\tfor (i = 0; included_patches[i] != 0; ++i)\n\t    ;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tMSG_PUTS(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    MSG_PUTS(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    /* Print the list of extra patch descriptions if there is at least one. */\n    if (extra_patches[0] != NULL)\n    {\n\tMSG_PUTS(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    MSG_PUTS(s);\n\t    s = \", \";\n\t    MSG_PUTS(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    MSG_PUTS(\"\\n\");\n    MSG_PUTS(_(\"Modified by \"));\n    MSG_PUTS(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tMSG_PUTS(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    MSG_PUTS(_(\"by \"));\n\t    MSG_PUTS(compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    MSG_PUTS(\"@\");\n\t    MSG_PUTS(compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    MSG_PUTS(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    MSG_PUTS(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    MSG_PUTS(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    MSG_PUTS(_(\"\\nSmall version \"));\n#   else\n    MSG_PUTS(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    MSG_PUTS(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    MSG_PUTS(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     MSG_PUTS(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     MSG_PUTS(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    MSG_PUTS(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    MSG_PUTS(_(\"with X11-neXtaw GUI.\"));\n#    else\n    MSG_PUTS(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#     ifdef FEAT_GUI_PHOTON\n    MSG_PUTS(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    MSG_PUTS(_(\"with GUI.\"));\n#      else\n#\tif defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON\n    MSG_PUTS(_(\"with Carbon GUI.\"));\n#\telse\n#\t if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX\n    MSG_PUTS(_(\"with Cocoa GUI.\"));\n#\t else\n#\t endif\n#\tendif\n#      endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    void\nintro_message(\n    int\t\tcolon)\t\t/* TRUE for \":intro\" */\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    /* blanklines = screen height - # message lines */\n    blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);\n    if (!p_cp)\n\tblanklines += 4;  /* add 4 for not showing \"Vi compatible\" message */\n\n    /* Don't overwrite a statusline.  Depends on 'cmdheight'. */\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    /* Show the sponsor and register message one out of four times, the Uganda\n     * message two out of four times. */\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    /* start displaying the message lines after half of the blank lines */\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)(sizeof(lines) / sizeof(char *)); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    /* Make the wait-return message appear just below the text. */\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    /* Center the message horizontally. */\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    /* Check for 9.9x or 9.9xx, alpha/beta version */\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    /* Split up in parts to highlight <> items differently. */\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n#ifdef FEAT_MBYTE\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n#endif\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    /* Add the version number to the version line. */\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "buggy_code_start_loc": [55, 2, 2, 3432, 801], "buggy_code_end_loc": [1702, 667, 88, 5848, 801], "fixing_code_start_loc": [56, 3, 3, 3433, 802], "fixing_code_end_loc": [1711, 670, 106, 5866, 804], "type": "CWE-476", "message": "libvterm through 0+bzr726, as used in Vim and other products, mishandles certain out-of-memory conditions, leading to a denial of service (application crash), related to screen.c, state.c, and vterm.c.", "other": {"cve": {"id": "CVE-2018-20786", "sourceIdentifier": "cve@mitre.org", "published": "2019-02-24T14:29:00.283", "lastModified": "2020-03-30T20:15:15.917", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libvterm through 0+bzr726, as used in Vim and other products, mishandles certain out-of-memory conditions, leading to a denial of service (application crash), related to screen.c, state.c, and vterm.c."}, {"lang": "es", "value": "libvterm, hasta 0+bzr726, tal y como se emplea en Vim y otros productos, gestiona de manera incorrecta ciertas condiciones fuera de memoria, lo que conduce a una denegaci\u00f3n de servicio (cierre inesperado de la aplicaci\u00f3n). Esto est\u00e1 relacionado con screen.c, state.c y vterm.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:leonerd:libvterm:*:*:*:*:*:*:*:*", "versionEndIncluding": "0\\+bzr726", "matchCriteriaId": "E906BAA8-91DB-4D6B-901F-DB13B8565FE0"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/issues/3711", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4309-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8"}}