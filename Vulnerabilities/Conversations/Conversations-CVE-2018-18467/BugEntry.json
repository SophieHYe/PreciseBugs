{"buggy_code": ["package eu.siacs.conversations.ui;\n\nimport android.Manifest;\nimport android.annotation.SuppressLint;\nimport android.app.Activity;\nimport android.app.FragmentManager;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.databinding.DataBindingUtil;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.preference.PreferenceManager;\nimport android.provider.MediaStore;\nimport android.support.annotation.IdRes;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.StringRes;\nimport android.support.v7.app.AlertDialog;\nimport android.app.Fragment;\nimport android.app.PendingIntent;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentSender.SendIntentException;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.SystemClock;\nimport android.support.v13.view.inputmethod.InputConnectionCompat;\nimport android.support.v13.view.inputmethod.InputContentInfoCompat;\nimport android.text.Editable;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.view.Gravity;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AbsListView;\nimport android.widget.AbsListView.OnScrollListener;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\nimport android.widget.CheckBox;\nimport android.widget.ListView;\nimport android.widget.PopupMenu;\nimport android.widget.TextView.OnEditorActionListener;\nimport android.widget.Toast;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport eu.siacs.conversations.Config;\nimport eu.siacs.conversations.R;\nimport eu.siacs.conversations.crypto.axolotl.AxolotlService;\nimport eu.siacs.conversations.crypto.axolotl.FingerprintStatus;\nimport eu.siacs.conversations.databinding.FragmentConversationBinding;\nimport eu.siacs.conversations.entities.Account;\nimport eu.siacs.conversations.entities.Blockable;\nimport eu.siacs.conversations.entities.Contact;\nimport eu.siacs.conversations.entities.Conversation;\nimport eu.siacs.conversations.entities.Conversational;\nimport eu.siacs.conversations.entities.DownloadableFile;\nimport eu.siacs.conversations.entities.Message;\nimport eu.siacs.conversations.entities.MucOptions;\nimport eu.siacs.conversations.entities.MucOptions.User;\nimport eu.siacs.conversations.entities.Presence;\nimport eu.siacs.conversations.entities.ReadByMarker;\nimport eu.siacs.conversations.entities.Transferable;\nimport eu.siacs.conversations.entities.TransferablePlaceholder;\nimport eu.siacs.conversations.http.HttpDownloadConnection;\nimport eu.siacs.conversations.persistance.FileBackend;\nimport eu.siacs.conversations.services.MessageArchiveService;\nimport eu.siacs.conversations.services.XmppConnectionService;\nimport eu.siacs.conversations.ui.adapter.MediaPreviewAdapter;\nimport eu.siacs.conversations.ui.adapter.MessageAdapter;\nimport eu.siacs.conversations.ui.util.ActivityResult;\nimport eu.siacs.conversations.ui.util.Attachment;\nimport eu.siacs.conversations.ui.util.ConversationMenuConfigurator;\nimport eu.siacs.conversations.ui.util.DateSeparator;\nimport eu.siacs.conversations.ui.util.EditMessageActionModeCallback;\nimport eu.siacs.conversations.ui.util.ListViewUtils;\nimport eu.siacs.conversations.ui.util.MenuDoubleTabUtil;\nimport eu.siacs.conversations.ui.util.MucDetailsContextMenuHelper;\nimport eu.siacs.conversations.ui.util.PendingItem;\nimport eu.siacs.conversations.ui.util.PresenceSelector;\nimport eu.siacs.conversations.ui.util.ScrollState;\nimport eu.siacs.conversations.ui.util.SendButtonAction;\nimport eu.siacs.conversations.ui.util.SendButtonTool;\nimport eu.siacs.conversations.ui.util.ShareUtil;\nimport eu.siacs.conversations.ui.widget.EditMessage;\nimport eu.siacs.conversations.utils.GeoHelper;\nimport eu.siacs.conversations.utils.MessageUtils;\nimport eu.siacs.conversations.utils.NickValidityChecker;\nimport eu.siacs.conversations.utils.Patterns;\nimport eu.siacs.conversations.utils.QuickLoader;\nimport eu.siacs.conversations.utils.StylingHelper;\nimport eu.siacs.conversations.utils.TimeframeUtils;\nimport eu.siacs.conversations.utils.UIHelper;\nimport eu.siacs.conversations.xmpp.XmppConnection;\nimport eu.siacs.conversations.xmpp.chatstate.ChatState;\nimport eu.siacs.conversations.xmpp.jingle.JingleConnection;\nimport rocks.xmpp.addr.Jid;\n\nimport static eu.siacs.conversations.ui.XmppActivity.EXTRA_ACCOUNT;\nimport static eu.siacs.conversations.ui.XmppActivity.REQUEST_INVITE_TO_CONVERSATION;\nimport static eu.siacs.conversations.ui.util.SoftKeyboardUtils.hideSoftKeyboard;\n\n\npublic class ConversationFragment extends XmppFragment implements EditMessage.KeyboardListener {\n\n\n    public static final int REQUEST_SEND_MESSAGE = 0x0201;\n    public static final int REQUEST_DECRYPT_PGP = 0x0202;\n    public static final int REQUEST_ENCRYPT_MESSAGE = 0x0207;\n    public static final int REQUEST_TRUST_KEYS_TEXT = 0x0208;\n    public static final int REQUEST_TRUST_KEYS_ATTACHMENTS = 0x0209;\n    public static final int REQUEST_START_DOWNLOAD = 0x0210;\n    public static final int REQUEST_ADD_EDITOR_CONTENT = 0x0211;\n    public static final int ATTACHMENT_CHOICE_CHOOSE_IMAGE = 0x0301;\n    public static final int ATTACHMENT_CHOICE_TAKE_PHOTO = 0x0302;\n    public static final int ATTACHMENT_CHOICE_CHOOSE_FILE = 0x0303;\n    public static final int ATTACHMENT_CHOICE_RECORD_VOICE = 0x0304;\n    public static final int ATTACHMENT_CHOICE_LOCATION = 0x0305;\n    public static final int ATTACHMENT_CHOICE_INVALID = 0x0306;\n    public static final int ATTACHMENT_CHOICE_RECORD_VIDEO = 0x0307;\n\n    public static final String RECENTLY_USED_QUICK_ACTION = \"recently_used_quick_action\";\n    public static final String STATE_CONVERSATION_UUID = ConversationFragment.class.getName() + \".uuid\";\n    public static final String STATE_SCROLL_POSITION = ConversationFragment.class.getName() + \".scroll_position\";\n    public static final String STATE_PHOTO_URI = ConversationFragment.class.getName() + \".media_previews\";\n    public static final String STATE_MEDIA_PREVIEWS = ConversationFragment.class.getName() + \".take_photo_uri\";\n    private static final String STATE_LAST_MESSAGE_UUID = \"state_last_message_uuid\";\n\n    private final List<Message> messageList = new ArrayList<>();\n    private final PendingItem<ActivityResult> postponedActivityResult = new PendingItem<>();\n    private final PendingItem<String> pendingConversationsUuid = new PendingItem<>();\n    private final PendingItem<ArrayList<Attachment>> pendingMediaPreviews = new PendingItem<>();\n    private final PendingItem<Bundle> pendingExtras = new PendingItem<>();\n    private final PendingItem<Uri> pendingTakePhotoUri = new PendingItem<>();\n    private final PendingItem<ScrollState> pendingScrollState = new PendingItem<>();\n    private final PendingItem<String> pendingLastMessageUuid = new PendingItem<>();\n    private final PendingItem<Message> pendingMessage = new PendingItem<>();\n    public Uri mPendingEditorContent = null;\n    protected MessageAdapter messageListAdapter;\n    private MediaPreviewAdapter mediaPreviewAdapter;\n    private String lastMessageUuid = null;\n    private Conversation conversation;\n    private FragmentConversationBinding binding;\n    private Toast messageLoaderToast;\n    private ConversationsActivity activity;\n    private boolean reInitRequiredOnStart = true;\n    private OnClickListener clickToMuc = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            Intent intent = new Intent(getActivity(), ConferenceDetailsActivity.class);\n            intent.setAction(ConferenceDetailsActivity.ACTION_VIEW_MUC);\n            intent.putExtra(\"uuid\", conversation.getUuid());\n            startActivity(intent);\n        }\n    };\n    private OnClickListener leaveMuc = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            activity.xmppConnectionService.archiveConversation(conversation);\n        }\n    };\n    private OnClickListener joinMuc = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            activity.xmppConnectionService.joinMuc(conversation);\n        }\n    };\n    private OnClickListener enterPassword = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            MucOptions muc = conversation.getMucOptions();\n            String password = muc.getPassword();\n            if (password == null) {\n                password = \"\";\n            }\n            activity.quickPasswordEdit(password, value -> {\n                activity.xmppConnectionService.providePasswordForMuc(conversation, value);\n                return null;\n            });\n        }\n    };\n    private OnScrollListener mOnScrollListener = new OnScrollListener() {\n\n        @Override\n        public void onScrollStateChanged(AbsListView view, int scrollState) {\n            if (AbsListView.OnScrollListener.SCROLL_STATE_IDLE == scrollState) {\n                fireReadEvent();\n            }\n        }\n\n        @Override\n        public void onScroll(final AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\n            toggleScrollDownButton(view);\n            synchronized (ConversationFragment.this.messageList) {\n                if (firstVisibleItem < 5 && conversation != null && conversation.messagesLoaded.compareAndSet(true, false) && messageList.size() > 0) {\n                    long timestamp;\n                    if (messageList.get(0).getType() == Message.TYPE_STATUS && messageList.size() >= 2) {\n                        timestamp = messageList.get(1).getTimeSent();\n                    } else {\n                        timestamp = messageList.get(0).getTimeSent();\n                    }\n                    activity.xmppConnectionService.loadMoreMessages(conversation, timestamp, new XmppConnectionService.OnMoreMessagesLoaded() {\n                        @Override\n                        public void onMoreMessagesLoaded(final int c, final Conversation conversation) {\n                            if (ConversationFragment.this.conversation != conversation) {\n                                conversation.messagesLoaded.set(true);\n                                return;\n                            }\n                            runOnUiThread(() -> {\n                                synchronized (messageList) {\n                                    final int oldPosition = binding.messagesView.getFirstVisiblePosition();\n                                    Message message = null;\n                                    int childPos;\n                                    for (childPos = 0; childPos + oldPosition < messageList.size(); ++childPos) {\n                                        message = messageList.get(oldPosition + childPos);\n                                        if (message.getType() != Message.TYPE_STATUS) {\n                                            break;\n                                        }\n                                    }\n                                    final String uuid = message != null ? message.getUuid() : null;\n                                    View v = binding.messagesView.getChildAt(childPos);\n                                    final int pxOffset = (v == null) ? 0 : v.getTop();\n                                    ConversationFragment.this.conversation.populateWithMessages(ConversationFragment.this.messageList);\n                                    try {\n                                        updateStatusMessages();\n                                    } catch (IllegalStateException e) {\n                                        Log.d(Config.LOGTAG, \"caught illegal state exception while updating status messages\");\n                                    }\n                                    messageListAdapter.notifyDataSetChanged();\n                                    int pos = Math.max(getIndexOf(uuid, messageList), 0);\n                                    binding.messagesView.setSelectionFromTop(pos, pxOffset);\n                                    if (messageLoaderToast != null) {\n                                        messageLoaderToast.cancel();\n                                    }\n                                    conversation.messagesLoaded.set(true);\n                                }\n                            });\n                        }\n\n                        @Override\n                        public void informUser(final int resId) {\n\n                            runOnUiThread(() -> {\n                                if (messageLoaderToast != null) {\n                                    messageLoaderToast.cancel();\n                                }\n                                if (ConversationFragment.this.conversation != conversation) {\n                                    return;\n                                }\n                                messageLoaderToast = Toast.makeText(view.getContext(), resId, Toast.LENGTH_LONG);\n                                messageLoaderToast.show();\n                            });\n\n                        }\n                    });\n\n                }\n            }\n        }\n    };\n    private EditMessage.OnCommitContentListener mEditorContentListener = new EditMessage.OnCommitContentListener() {\n        @Override\n        public boolean onCommitContent(InputContentInfoCompat inputContentInfo, int flags, Bundle opts, String[] contentMimeTypes) {\n            // try to get permission to read the image, if applicable\n            if ((flags & InputConnectionCompat.INPUT_CONTENT_GRANT_READ_URI_PERMISSION) != 0) {\n                try {\n                    inputContentInfo.requestPermission();\n                } catch (Exception e) {\n                    Log.e(Config.LOGTAG, \"InputContentInfoCompat#requestPermission() failed.\", e);\n                    Toast.makeText(getActivity(), activity.getString(R.string.no_permission_to_access_x, inputContentInfo.getDescription()), Toast.LENGTH_LONG\n                    ).show();\n                    return false;\n                }\n            }\n            if (hasPermissions(REQUEST_ADD_EDITOR_CONTENT, Manifest.permission.WRITE_EXTERNAL_STORAGE)) {\n                attachEditorContentToConversation(inputContentInfo.getContentUri());\n            } else {\n                mPendingEditorContent = inputContentInfo.getContentUri();\n            }\n            return true;\n        }\n    };\n    private Message selectedMessage;\n    private OnClickListener mEnableAccountListener = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            final Account account = conversation == null ? null : conversation.getAccount();\n            if (account != null) {\n                account.setOption(Account.OPTION_DISABLED, false);\n                activity.xmppConnectionService.updateAccount(account);\n            }\n        }\n    };\n    private OnClickListener mUnblockClickListener = new OnClickListener() {\n        @Override\n        public void onClick(final View v) {\n            v.post(() -> v.setVisibility(View.INVISIBLE));\n            if (conversation.isDomainBlocked()) {\n                BlockContactDialog.show(activity, conversation);\n            } else {\n                unblockConversation(conversation);\n            }\n        }\n    };\n    private OnClickListener mBlockClickListener = this::showBlockSubmenu;\n    private OnClickListener mAddBackClickListener = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            final Contact contact = conversation == null ? null : conversation.getContact();\n            if (contact != null) {\n                activity.xmppConnectionService.createContact(contact, true);\n                activity.switchToContactDetails(contact);\n            }\n        }\n    };\n    private View.OnLongClickListener mLongPressBlockListener = this::showBlockSubmenu;\n    private OnClickListener mAllowPresenceSubscription = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            final Contact contact = conversation == null ? null : conversation.getContact();\n            if (contact != null) {\n                activity.xmppConnectionService.sendPresencePacket(contact.getAccount(),\n                        activity.xmppConnectionService.getPresenceGenerator()\n                                .sendPresenceUpdatesTo(contact));\n                hideSnackbar();\n            }\n        }\n    };\n    protected OnClickListener clickToDecryptListener = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            PendingIntent pendingIntent = conversation.getAccount().getPgpDecryptionService().getPendingIntent();\n            if (pendingIntent != null) {\n                try {\n                    getActivity().startIntentSenderForResult(pendingIntent.getIntentSender(),\n                            REQUEST_DECRYPT_PGP,\n                            null,\n                            0,\n                            0,\n                            0);\n                } catch (SendIntentException e) {\n                    Toast.makeText(getActivity(), R.string.unable_to_connect_to_keychain, Toast.LENGTH_SHORT).show();\n                    conversation.getAccount().getPgpDecryptionService().continueDecryption(true);\n                }\n            }\n            updateSnackBar(conversation);\n        }\n    };\n    private AtomicBoolean mSendingPgpMessage = new AtomicBoolean(false);\n    private OnEditorActionListener mEditorActionListener = (v, actionId, event) -> {\n        if (actionId == EditorInfo.IME_ACTION_SEND) {\n            InputMethodManager imm = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);\n            if (imm != null && imm.isFullscreenMode()) {\n                imm.hideSoftInputFromWindow(v.getWindowToken(), 0);\n            }\n            sendMessage();\n            return true;\n        } else {\n            return false;\n        }\n    };\n    private OnClickListener mScrollButtonListener = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            stopScrolling();\n            setSelection(binding.messagesView.getCount() - 1, true);\n        }\n    };\n    private OnClickListener mSendButtonListener = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            Object tag = v.getTag();\n            if (tag instanceof SendButtonAction) {\n                SendButtonAction action = (SendButtonAction) tag;\n                switch (action) {\n                    case TAKE_PHOTO:\n                    case RECORD_VIDEO:\n                    case SEND_LOCATION:\n                    case RECORD_VOICE:\n                    case CHOOSE_PICTURE:\n                        attachFile(action.toChoice());\n                        break;\n                    case CANCEL:\n                        if (conversation != null) {\n                            if (conversation.setCorrectingMessage(null)) {\n                                binding.textinput.setText(\"\");\n                                binding.textinput.append(conversation.getDraftMessage());\n                                conversation.setDraftMessage(null);\n                            } else if (conversation.getMode() == Conversation.MODE_MULTI) {\n                                conversation.setNextCounterpart(null);\n                            }\n                            updateChatMsgHint();\n                            updateSendButton();\n                            updateEditablity();\n                        }\n                        break;\n                    default:\n                        sendMessage();\n                }\n            } else {\n                sendMessage();\n            }\n        }\n    };\n    private int completionIndex = 0;\n    private int lastCompletionLength = 0;\n    private String incomplete;\n    private int lastCompletionCursor;\n    private boolean firstWord = false;\n    private Message mPendingDownloadableMessage;\n\n    private static ConversationFragment findConversationFragment(Activity activity) {\n        Fragment fragment = activity.getFragmentManager().findFragmentById(R.id.main_fragment);\n        if (fragment != null && fragment instanceof ConversationFragment) {\n            return (ConversationFragment) fragment;\n        }\n        fragment = activity.getFragmentManager().findFragmentById(R.id.secondary_fragment);\n        if (fragment != null && fragment instanceof ConversationFragment) {\n            return (ConversationFragment) fragment;\n        }\n        return null;\n    }\n\n    public static void startStopPending(Activity activity) {\n        ConversationFragment fragment = findConversationFragment(activity);\n        if (fragment != null) {\n            fragment.messageListAdapter.startStopPending();\n        }\n    }\n\n    public static void downloadFile(Activity activity, Message message) {\n        ConversationFragment fragment = findConversationFragment(activity);\n        if (fragment != null) {\n            fragment.startDownloadable(message);\n        }\n    }\n\n    public static void registerPendingMessage(Activity activity, Message message) {\n        ConversationFragment fragment = findConversationFragment(activity);\n        if (fragment != null) {\n            fragment.pendingMessage.push(message);\n        }\n    }\n\n    public static void openPendingMessage(Activity activity) {\n        ConversationFragment fragment = findConversationFragment(activity);\n        if (fragment != null) {\n            Message message = fragment.pendingMessage.pop();\n            if (message != null) {\n                fragment.messageListAdapter.openDownloadable(message);\n            }\n        }\n    }\n\n    public static Conversation getConversation(Activity activity) {\n        return getConversation(activity, R.id.secondary_fragment);\n    }\n\n    private static Conversation getConversation(Activity activity, @IdRes int res) {\n        final Fragment fragment = activity.getFragmentManager().findFragmentById(res);\n        if (fragment != null && fragment instanceof ConversationFragment) {\n            return ((ConversationFragment) fragment).getConversation();\n        } else {\n            return null;\n        }\n    }\n\n    public static ConversationFragment get(Activity activity) {\n        FragmentManager fragmentManager = activity.getFragmentManager();\n        Fragment fragment = fragmentManager.findFragmentById(R.id.main_fragment);\n        if (fragment != null && fragment instanceof ConversationFragment) {\n            return (ConversationFragment) fragment;\n        } else {\n            fragment = fragmentManager.findFragmentById(R.id.secondary_fragment);\n            return fragment != null && fragment instanceof ConversationFragment ? (ConversationFragment) fragment : null;\n        }\n    }\n\n    public static Conversation getConversationReliable(Activity activity) {\n        final Conversation conversation = getConversation(activity, R.id.secondary_fragment);\n        if (conversation != null) {\n            return conversation;\n        }\n        return getConversation(activity, R.id.main_fragment);\n    }\n\n    private static boolean allGranted(int[] grantResults) {\n        for (int grantResult : grantResults) {\n            if (grantResult != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean writeGranted(int[] grantResults, String[] permission) {\n        for (int i = 0; i < grantResults.length; ++i) {\n            if (Manifest.permission.WRITE_EXTERNAL_STORAGE.equals(permission[i])) {\n                return grantResults[i] == PackageManager.PERMISSION_GRANTED;\n            }\n        }\n        return false;\n    }\n\n    private static String getFirstDenied(int[] grantResults, String[] permissions) {\n        for (int i = 0; i < grantResults.length; ++i) {\n            if (grantResults[i] == PackageManager.PERMISSION_DENIED) {\n                return permissions[i];\n            }\n        }\n        return null;\n    }\n\n    private static boolean scrolledToBottom(AbsListView listView) {\n        final int count = listView.getCount();\n        if (count == 0) {\n            return true;\n        } else if (listView.getLastVisiblePosition() == count - 1) {\n            final View lastChild = listView.getChildAt(listView.getChildCount() - 1);\n            return lastChild != null && lastChild.getBottom() <= listView.getHeight();\n        } else {\n            return false;\n        }\n    }\n\n    private void toggleScrollDownButton() {\n        toggleScrollDownButton(binding.messagesView);\n    }\n\n    private void toggleScrollDownButton(AbsListView listView) {\n        if (conversation == null) {\n            return;\n        }\n        if (scrolledToBottom(listView)) {\n            lastMessageUuid = null;\n            hideUnreadMessagesCount();\n        } else {\n            binding.scrollToBottomButton.setEnabled(true);\n            binding.scrollToBottomButton.show();\n            if (lastMessageUuid == null) {\n                lastMessageUuid = conversation.getLatestMessage().getUuid();\n            }\n            if (conversation.getReceivedMessagesCountSinceUuid(lastMessageUuid) > 0) {\n                binding.unreadCountCustomView.setVisibility(View.VISIBLE);\n            }\n        }\n    }\n\n    private int getIndexOf(String uuid, List<Message> messages) {\n        if (uuid == null) {\n            return messages.size() - 1;\n        }\n        for (int i = 0; i < messages.size(); ++i) {\n            if (uuid.equals(messages.get(i).getUuid())) {\n                return i;\n            } else {\n                Message next = messages.get(i);\n                while (next != null && next.wasMergedIntoPrevious()) {\n                    if (uuid.equals(next.getUuid())) {\n                        return i;\n                    }\n                    next = next.next();\n                }\n\n            }\n        }\n        return -1;\n    }\n\n    private ScrollState getScrollPosition() {\n        final ListView listView = this.binding.messagesView;\n        if (listView.getCount() == 0 || listView.getLastVisiblePosition() == listView.getCount() - 1) {\n            return null;\n        } else {\n            final int pos = listView.getFirstVisiblePosition();\n            final View view = listView.getChildAt(0);\n            if (view == null) {\n                return null;\n            } else {\n                return new ScrollState(pos, view.getTop());\n            }\n        }\n    }\n\n    private void setScrollPosition(ScrollState scrollPosition, String lastMessageUuid) {\n        if (scrollPosition != null) {\n\n            this.lastMessageUuid = lastMessageUuid;\n            if (lastMessageUuid != null) {\n                binding.unreadCountCustomView.setUnreadCount(conversation.getReceivedMessagesCountSinceUuid(lastMessageUuid));\n            }\n            //TODO maybe this needs a 'post'\n            this.binding.messagesView.setSelectionFromTop(scrollPosition.position, scrollPosition.offset);\n            toggleScrollDownButton();\n        }\n    }\n\n    private void attachLocationToConversation(Conversation conversation, Uri uri) {\n        if (conversation == null) {\n            return;\n        }\n        activity.xmppConnectionService.attachLocationToConversation(conversation, uri, new UiCallback<Message>() {\n\n            @Override\n            public void success(Message message) {\n\n            }\n\n            @Override\n            public void error(int errorCode, Message object) {\n                //TODO show possible pgp error\n            }\n\n            @Override\n            public void userInputRequried(PendingIntent pi, Message object) {\n\n            }\n        });\n    }\n\n    private void attachFileToConversation(Conversation conversation, Uri uri, String type) {\n        if (conversation == null) {\n            return;\n        }\n        final Toast prepareFileToast = Toast.makeText(getActivity(), getText(R.string.preparing_file), Toast.LENGTH_LONG);\n        prepareFileToast.show();\n        activity.delegateUriPermissionsToService(uri);\n        activity.xmppConnectionService.attachFileToConversation(conversation, uri, type, new UiInformableCallback<Message>() {\n            @Override\n            public void inform(final String text) {\n                hidePrepareFileToast(prepareFileToast);\n                runOnUiThread(() -> activity.replaceToast(text));\n            }\n\n            @Override\n            public void success(Message message) {\n                runOnUiThread(() -> activity.hideToast());\n                hidePrepareFileToast(prepareFileToast);\n            }\n\n            @Override\n            public void error(final int errorCode, Message message) {\n                hidePrepareFileToast(prepareFileToast);\n                runOnUiThread(() -> activity.replaceToast(getString(errorCode)));\n\n            }\n\n            @Override\n            public void userInputRequried(PendingIntent pi, Message message) {\n                hidePrepareFileToast(prepareFileToast);\n            }\n        });\n    }\n\n    public void attachEditorContentToConversation(Uri uri) {\n        mediaPreviewAdapter.addMediaPreviews(Attachment.of(getActivity(), uri, Attachment.Type.FILE));\n        toggleInputMethod();\n    }\n\n    private void attachImageToConversation(Conversation conversation, Uri uri) {\n        if (conversation == null) {\n            return;\n        }\n        final Toast prepareFileToast = Toast.makeText(getActivity(), getText(R.string.preparing_image), Toast.LENGTH_LONG);\n        prepareFileToast.show();\n        activity.delegateUriPermissionsToService(uri);\n        activity.xmppConnectionService.attachImageToConversation(conversation, uri,\n                new UiCallback<Message>() {\n\n                    @Override\n                    public void userInputRequried(PendingIntent pi, Message object) {\n                        hidePrepareFileToast(prepareFileToast);\n                    }\n\n                    @Override\n                    public void success(Message message) {\n                        hidePrepareFileToast(prepareFileToast);\n                    }\n\n                    @Override\n                    public void error(final int error, Message message) {\n                        hidePrepareFileToast(prepareFileToast);\n                        activity.runOnUiThread(() -> activity.replaceToast(getString(error)));\n                    }\n                });\n    }\n\n    private void hidePrepareFileToast(final Toast prepareFileToast) {\n        if (prepareFileToast != null && activity != null) {\n            activity.runOnUiThread(prepareFileToast::cancel);\n        }\n    }\n\n    private void sendMessage() {\n        if (mediaPreviewAdapter.hasAttachments()) {\n            commitAttachments();\n            return;\n        }\n        final Editable text = this.binding.textinput.getText();\n        final String body =  text == null ? \"\" : text.toString();\n        final Conversation conversation = this.conversation;\n        if (body.length() == 0 || conversation == null) {\n            return;\n        }\n        if (conversation.getNextEncryption() == Message.ENCRYPTION_AXOLOTL && trustKeysIfNeeded(REQUEST_TRUST_KEYS_TEXT)) {\n            return;\n        }\n        final Message message;\n        if (conversation.getCorrectingMessage() == null) {\n            message = new Message(conversation, body, conversation.getNextEncryption());\n            if (conversation.getMode() == Conversation.MODE_MULTI) {\n                final Jid nextCounterpart = conversation.getNextCounterpart();\n                if (nextCounterpart != null) {\n                    message.setCounterpart(nextCounterpart);\n                    message.setTrueCounterpart(conversation.getMucOptions().getTrueCounterpart(nextCounterpart));\n                    message.setType(Message.TYPE_PRIVATE);\n                }\n            }\n        } else {\n            message = conversation.getCorrectingMessage();\n            message.setBody(body);\n            message.setEdited(message.getUuid());\n            message.setUuid(UUID.randomUUID().toString());\n        }\n        switch (conversation.getNextEncryption()) {\n            case Message.ENCRYPTION_PGP:\n                sendPgpMessage(message);\n                break;\n            default:\n                sendMessage(message);\n        }\n    }\n\n    protected boolean trustKeysIfNeeded(int requestCode) {\n        AxolotlService axolotlService = conversation.getAccount().getAxolotlService();\n        final List<Jid> targets = axolotlService.getCryptoTargets(conversation);\n        boolean hasUnaccepted = !conversation.getAcceptedCryptoTargets().containsAll(targets);\n        boolean hasUndecidedOwn = !axolotlService.getKeysWithTrust(FingerprintStatus.createActiveUndecided()).isEmpty();\n        boolean hasUndecidedContacts = !axolotlService.getKeysWithTrust(FingerprintStatus.createActiveUndecided(), targets).isEmpty();\n        boolean hasPendingKeys = !axolotlService.findDevicesWithoutSession(conversation).isEmpty();\n        boolean hasNoTrustedKeys = axolotlService.anyTargetHasNoTrustedKeys(targets);\n        boolean downloadInProgress = axolotlService.hasPendingKeyFetches(targets);\n        if (hasUndecidedOwn || hasUndecidedContacts || hasPendingKeys || hasNoTrustedKeys || hasUnaccepted || downloadInProgress) {\n            axolotlService.createSessionsIfNeeded(conversation);\n            Intent intent = new Intent(getActivity(), TrustKeysActivity.class);\n            String[] contacts = new String[targets.size()];\n            for (int i = 0; i < contacts.length; ++i) {\n                contacts[i] = targets.get(i).toString();\n            }\n            intent.putExtra(\"contacts\", contacts);\n            intent.putExtra(EXTRA_ACCOUNT, conversation.getAccount().getJid().asBareJid().toString());\n            intent.putExtra(\"conversation\", conversation.getUuid());\n            startActivityForResult(intent, requestCode);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void updateChatMsgHint() {\n        final boolean multi = conversation.getMode() == Conversation.MODE_MULTI;\n        if (conversation.getCorrectingMessage() != null) {\n            this.binding.textinput.setHint(R.string.send_corrected_message);\n        } else if (multi && conversation.getNextCounterpart() != null) {\n            this.binding.textinput.setHint(getString(\n                    R.string.send_private_message_to,\n                    conversation.getNextCounterpart().getResource()));\n        } else if (multi && !conversation.getMucOptions().participating()) {\n            this.binding.textinput.setHint(R.string.you_are_not_participating);\n        } else {\n            this.binding.textinput.setHint(UIHelper.getMessageHint(getActivity(), conversation));\n            getActivity().invalidateOptionsMenu();\n        }\n    }\n\n    public void setupIme() {\n        this.binding.textinput.refreshIme();\n    }\n\n    private void handleActivityResult(ActivityResult activityResult) {\n        if (activityResult.resultCode == Activity.RESULT_OK) {\n            handlePositiveActivityResult(activityResult.requestCode, activityResult.data);\n        } else {\n            handleNegativeActivityResult(activityResult.requestCode);\n        }\n    }\n\n    private void handlePositiveActivityResult(int requestCode, final Intent data) {\n        switch (requestCode) {\n            case REQUEST_TRUST_KEYS_TEXT:\n                sendMessage();\n                break;\n            case REQUEST_TRUST_KEYS_ATTACHMENTS:\n                commitAttachments();\n                break;\n            case ATTACHMENT_CHOICE_CHOOSE_IMAGE:\n                final List<Attachment> imageUris = Attachment.extractAttachments(getActivity(), data, Attachment.Type.IMAGE);\n                mediaPreviewAdapter.addMediaPreviews(imageUris);\n                toggleInputMethod();\n                break;\n            case ATTACHMENT_CHOICE_TAKE_PHOTO:\n                final Uri takePhotoUri = pendingTakePhotoUri.pop();\n                if (takePhotoUri != null) {\n                    mediaPreviewAdapter.addMediaPreviews(Attachment.of(getActivity(), takePhotoUri, Attachment.Type.IMAGE));\n                    toggleInputMethod();\n                } else {\n                    Log.d(Config.LOGTAG, \"lost take photo uri. unable to to attach\");\n                }\n                break;\n            case ATTACHMENT_CHOICE_CHOOSE_FILE:\n            case ATTACHMENT_CHOICE_RECORD_VIDEO:\n            case ATTACHMENT_CHOICE_RECORD_VOICE:\n                final Attachment.Type type = requestCode == ATTACHMENT_CHOICE_RECORD_VOICE ? Attachment.Type.RECORDING : Attachment.Type.FILE;\n                final List<Attachment> fileUris = Attachment.extractAttachments(getActivity(), data, type);\n                mediaPreviewAdapter.addMediaPreviews(fileUris);\n                toggleInputMethod();\n                break;\n            case ATTACHMENT_CHOICE_LOCATION:\n                double latitude = data.getDoubleExtra(\"latitude\", 0);\n                double longitude = data.getDoubleExtra(\"longitude\", 0);\n                Uri geo = Uri.parse(\"geo:\" + String.valueOf(latitude) + \",\" + String.valueOf(longitude));\n                mediaPreviewAdapter.addMediaPreviews(Attachment.of(getActivity(), geo, Attachment.Type.LOCATION));\n                toggleInputMethod();\n                break;\n            case REQUEST_INVITE_TO_CONVERSATION:\n                XmppActivity.ConferenceInvite invite = XmppActivity.ConferenceInvite.parse(data);\n                if (invite != null) {\n                    if (invite.execute(activity)) {\n                        activity.mToast = Toast.makeText(activity, R.string.creating_conference, Toast.LENGTH_LONG);\n                        activity.mToast.show();\n                    }\n                }\n                break;\n        }\n    }\n\n    private void commitAttachments() {\n        if (conversation.getNextEncryption() == Message.ENCRYPTION_AXOLOTL && trustKeysIfNeeded(REQUEST_TRUST_KEYS_ATTACHMENTS)) {\n            return;\n        }\n        final List<Attachment> attachments = mediaPreviewAdapter.getAttachments();\n        final PresenceSelector.OnPresenceSelected callback = () -> {\n            for (Iterator<Attachment> i = attachments.iterator(); i.hasNext(); i.remove()) {\n                final Attachment attachment = i.next();\n                if (attachment.getType() == Attachment.Type.LOCATION) {\n                    attachLocationToConversation(conversation, attachment.getUri());\n                } else if (attachment.getType() == Attachment.Type.IMAGE) {\n                    Log.d(Config.LOGTAG, \"ConversationsActivity.commitAttachments() - attaching image to conversations. CHOOSE_IMAGE\");\n                    attachImageToConversation(conversation, attachment.getUri());\n                } else {\n                    Log.d(Config.LOGTAG, \"ConversationsActivity.commitAttachments() - attaching file to conversations. CHOOSE_FILE/RECORD_VOICE/RECORD_VIDEO\");\n                    attachFileToConversation(conversation, attachment.getUri(), attachment.getMime());\n                }\n            }\n            mediaPreviewAdapter.notifyDataSetChanged();\n            toggleInputMethod();\n        };\n        if (conversation == null || conversation.getMode() == Conversation.MODE_MULTI || FileBackend.allFilesUnderSize(getActivity(), attachments, getMaxHttpUploadSize(conversation))) {\n            callback.onPresenceSelected();\n        } else {\n            activity.selectPresence(conversation, callback);\n        }\n    }\n\n    public void toggleInputMethod() {\n        boolean hasAttachments = mediaPreviewAdapter.hasAttachments();\n        binding.textinput.setVisibility(hasAttachments ? View.GONE : View.VISIBLE);\n        binding.mediaPreview.setVisibility(hasAttachments ? View.VISIBLE : View.GONE);\n        updateSendButton();\n    }\n\n    private void handleNegativeActivityResult(int requestCode) {\n        switch (requestCode) {\n            case ATTACHMENT_CHOICE_TAKE_PHOTO:\n                if (pendingTakePhotoUri.clear()) {\n                    Log.d(Config.LOGTAG, \"cleared pending photo uri after negative activity result\");\n                }\n                break;\n        }\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, final Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        ActivityResult activityResult = ActivityResult.of(requestCode, resultCode, data);\n        if (activity != null && activity.xmppConnectionService != null) {\n            handleActivityResult(activityResult);\n        } else {\n            this.postponedActivityResult.push(activityResult);\n        }\n    }\n\n    public void unblockConversation(final Blockable conversation) {\n        activity.xmppConnectionService.sendUnblockRequest(conversation);\n    }\n\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n        Log.d(Config.LOGTAG, \"ConversationFragment.onAttach()\");\n        if (activity instanceof ConversationsActivity) {\n            this.activity = (ConversationsActivity) activity;\n        } else {\n            throw new IllegalStateException(\"Trying to attach fragment to activity that is not the ConversationsActivity\");\n        }\n    }\n\n    @Override\n    public void onDetach() {\n        super.onDetach();\n        this.activity = null; //TODO maybe not a good idea since some callbacks really need it\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setHasOptionsMenu(true);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater menuInflater) {\n        menuInflater.inflate(R.menu.fragment_conversation, menu);\n        final MenuItem menuMucDetails = menu.findItem(R.id.action_muc_details);\n        final MenuItem menuContactDetails = menu.findItem(R.id.action_contact_details);\n        final MenuItem menuInviteContact = menu.findItem(R.id.action_invite);\n        final MenuItem menuMute = menu.findItem(R.id.action_mute);\n        final MenuItem menuUnmute = menu.findItem(R.id.action_unmute);\n\n\n        if (conversation != null) {\n            if (conversation.getMode() == Conversation.MODE_MULTI) {\n                menuContactDetails.setVisible(false);\n                menuInviteContact.setVisible(conversation.getMucOptions().canInvite());\n            } else {\n                menuContactDetails.setVisible(!this.conversation.withSelf());\n                menuMucDetails.setVisible(false);\n                final XmppConnectionService service = activity.xmppConnectionService;\n                menuInviteContact.setVisible(service != null && service.findConferenceServer(conversation.getAccount()) != null);\n            }\n            if (conversation.isMuted()) {\n                menuMute.setVisible(false);\n            } else {\n                menuUnmute.setVisible(false);\n            }\n            ConversationMenuConfigurator.configureAttachmentMenu(conversation, menu);\n            ConversationMenuConfigurator.configureEncryptionMenu(conversation, menu);\n        }\n        super.onCreateOptionsMenu(menu, menuInflater);\n    }\n\n    @Override\n    public View onCreateView(final LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        this.binding = DataBindingUtil.inflate(inflater, R.layout.fragment_conversation, container, false);\n        binding.getRoot().setOnClickListener(null); //TODO why the fuck did we do this?\n\n        binding.textinput.addTextChangedListener(new StylingHelper.MessageEditorStyler(binding.textinput));\n\n        binding.textinput.setOnEditorActionListener(mEditorActionListener);\n        binding.textinput.setRichContentListener(new String[]{\"image/*\"}, mEditorContentListener);\n\n        binding.textSendButton.setOnClickListener(this.mSendButtonListener);\n\n        binding.scrollToBottomButton.setOnClickListener(this.mScrollButtonListener);\n        binding.messagesView.setOnScrollListener(mOnScrollListener);\n        binding.messagesView.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);\n        mediaPreviewAdapter = new MediaPreviewAdapter(this);\n        binding.mediaPreview.setAdapter(mediaPreviewAdapter);\n        messageListAdapter = new MessageAdapter((XmppActivity) getActivity(), this.messageList);\n        messageListAdapter.setOnContactPictureClicked(message -> {\n            String fingerprint;\n            if (message.getEncryption() == Message.ENCRYPTION_PGP || message.getEncryption() == Message.ENCRYPTION_DECRYPTED) {\n                fingerprint = \"pgp\";\n            } else {\n                fingerprint = message.getFingerprint();\n            }\n            final boolean received = message.getStatus() <= Message.STATUS_RECEIVED;\n            if (received) {\n                if (message.getConversation() instanceof Conversation && message.getConversation().getMode() == Conversation.MODE_MULTI) {\n                    Jid tcp = message.getTrueCounterpart();\n                    Jid user = message.getCounterpart();\n                    if (user != null && !user.isBareJid()) {\n                        final MucOptions mucOptions = ((Conversation) message.getConversation()).getMucOptions();\n                        if (mucOptions.participating() || ((Conversation) message.getConversation()).getNextCounterpart() != null) {\n                            if (!mucOptions.isUserInRoom(user) && mucOptions.findUserByRealJid(tcp == null ? null : tcp.asBareJid()) == null) {\n                                Toast.makeText(getActivity(), activity.getString(R.string.user_has_left_conference, user.getResource()), Toast.LENGTH_SHORT).show();\n                            }\n                            highlightInConference(user.getResource());\n                        } else {\n                            Toast.makeText(getActivity(), R.string.you_are_not_participating, Toast.LENGTH_SHORT).show();\n                        }\n                    }\n                    return;\n                } else {\n                    if (!message.getContact().isSelf()) {\n                        activity.switchToContactDetails(message.getContact(), fingerprint);\n                        return;\n                    }\n                }\n            }\n            activity.switchToAccount(message.getConversation().getAccount(), fingerprint);\n        });\n        messageListAdapter.setOnContactPictureLongClicked((v, message) -> {\n            if (message.getStatus() <= Message.STATUS_RECEIVED) {\n                if (message.getConversation().getMode() == Conversation.MODE_MULTI) {\n                    Jid tcp = message.getTrueCounterpart();\n                    Jid cp = message.getCounterpart();\n                    if (cp != null && !cp.isBareJid()) {\n                        User userByRealJid = tcp != null ? conversation.getMucOptions().findOrCreateUserByRealJid(tcp, cp) : null;\n                        final User user = userByRealJid != null ? userByRealJid : conversation.getMucOptions().findUserByFullJid(cp);\n                        final PopupMenu popupMenu = new PopupMenu(getActivity(), v);\n                        popupMenu.inflate(R.menu.muc_details_context);\n                        final Menu menu = popupMenu.getMenu();\n                        MucDetailsContextMenuHelper.configureMucDetailsContextMenu(activity, menu, conversation, user);\n                        popupMenu.setOnMenuItemClickListener(menuItem -> MucDetailsContextMenuHelper.onContextItemSelected(menuItem, user, conversation, activity));\n                        popupMenu.show();\n                    }\n                }\n            } else {\n                activity.showQrCode(conversation.getAccount().getShareableUri());\n            }\n        });\n        messageListAdapter.setOnQuoteListener(this::quoteText);\n        binding.messagesView.setAdapter(messageListAdapter);\n\n        registerForContextMenu(binding.messagesView);\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            this.binding.textinput.setCustomInsertionActionModeCallback(new EditMessageActionModeCallback(this.binding.textinput));\n        }\n\n        return binding.getRoot();\n    }\n\n    private void quoteText(String text) {\n        if (binding.textinput.isEnabled()) {\n            binding.textinput.insertAsQuote(text);\n            binding.textinput.requestFocus();\n            InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n            if (inputMethodManager != null) {\n                inputMethodManager.showSoftInput(binding.textinput, InputMethodManager.SHOW_IMPLICIT);\n            }\n        }\n    }\n\n    private void quoteMessage(Message message) {\n        quoteText(MessageUtils.prepareQuote(message));\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {\n        synchronized (this.messageList) {\n            super.onCreateContextMenu(menu, v, menuInfo);\n            AdapterView.AdapterContextMenuInfo acmi = (AdapterContextMenuInfo) menuInfo;\n            this.selectedMessage = this.messageList.get(acmi.position);\n            populateContextMenu(menu);\n        }\n    }\n\n    private void populateContextMenu(ContextMenu menu) {\n        final Message m = this.selectedMessage;\n        final Transferable t = m.getTransferable();\n        Message relevantForCorrection = m;\n        while (relevantForCorrection.mergeable(relevantForCorrection.next())) {\n            relevantForCorrection = relevantForCorrection.next();\n        }\n        if (m.getType() != Message.TYPE_STATUS) {\n\n            if (m.getEncryption() == Message.ENCRYPTION_AXOLOTL_NOT_FOR_THIS_DEVICE) {\n                return;\n            }\n\n            final boolean deleted = t != null && t instanceof TransferablePlaceholder;\n            final boolean encrypted = m.getEncryption() == Message.ENCRYPTION_DECRYPTION_FAILED\n                    || m.getEncryption() == Message.ENCRYPTION_PGP;\n            final boolean receiving = m.getStatus() == Message.STATUS_RECEIVED && (t instanceof JingleConnection || t instanceof HttpDownloadConnection);\n            activity.getMenuInflater().inflate(R.menu.message_context, menu);\n            menu.setHeaderTitle(R.string.message_options);\n            MenuItem copyMessage = menu.findItem(R.id.copy_message);\n            MenuItem copyLink = menu.findItem(R.id.copy_link);\n            MenuItem quoteMessage = menu.findItem(R.id.quote_message);\n            MenuItem retryDecryption = menu.findItem(R.id.retry_decryption);\n            MenuItem correctMessage = menu.findItem(R.id.correct_message);\n            MenuItem shareWith = menu.findItem(R.id.share_with);\n            MenuItem sendAgain = menu.findItem(R.id.send_again);\n            MenuItem copyUrl = menu.findItem(R.id.copy_url);\n            MenuItem downloadFile = menu.findItem(R.id.download_file);\n            MenuItem cancelTransmission = menu.findItem(R.id.cancel_transmission);\n            MenuItem deleteFile = menu.findItem(R.id.delete_file);\n            MenuItem showErrorMessage = menu.findItem(R.id.show_error_message);\n            if (!m.isFileOrImage() && !encrypted && !m.isGeoUri() && !m.treatAsDownloadable()) {\n                copyMessage.setVisible(true);\n                quoteMessage.setVisible(MessageUtils.prepareQuote(m).length() > 0);\n                String body = m.getMergedBody().toString();\n                if (ShareUtil.containsXmppUri(body)) {\n                    copyLink.setTitle(R.string.copy_jabber_id);\n                    copyLink.setVisible(true);\n                } else if (Patterns.AUTOLINK_WEB_URL.matcher(body).find()) {\n                    copyLink.setVisible(true);\n                }\n            }\n            if (m.getEncryption() == Message.ENCRYPTION_DECRYPTION_FAILED) {\n                retryDecryption.setVisible(true);\n            }\n            if (relevantForCorrection.getType() == Message.TYPE_TEXT\n                    && relevantForCorrection.isLastCorrectableMessage()\n                    && m.getConversation() instanceof Conversation\n                    && (((Conversation) m.getConversation()).getMucOptions().nonanonymous() || m.getConversation().getMode() == Conversation.MODE_SINGLE)) {\n                correctMessage.setVisible(true);\n            }\n            if ((m.isFileOrImage() && !deleted && !receiving) || (m.getType() == Message.TYPE_TEXT && !m.treatAsDownloadable())) {\n                shareWith.setVisible(true);\n            }\n            if (m.getStatus() == Message.STATUS_SEND_FAILED) {\n                sendAgain.setVisible(true);\n            }\n            if (m.hasFileOnRemoteHost()\n                    || m.isGeoUri()\n                    || m.treatAsDownloadable()\n                    || t instanceof HttpDownloadConnection) {\n                copyUrl.setVisible(true);\n            }\n            if (m.isFileOrImage() && deleted && m.hasFileOnRemoteHost()) {\n                downloadFile.setVisible(true);\n                downloadFile.setTitle(activity.getString(R.string.download_x_file, UIHelper.getFileDescriptionString(activity, m)));\n            }\n            final boolean waitingOfferedSending = m.getStatus() == Message.STATUS_WAITING\n                    || m.getStatus() == Message.STATUS_UNSEND\n                    || m.getStatus() == Message.STATUS_OFFERED;\n            final boolean cancelable = (t != null && !deleted) || waitingOfferedSending && m.needsUploading();\n            if (cancelable) {\n                cancelTransmission.setVisible(true);\n            }\n            if (m.isFileOrImage() && !deleted && !cancelable) {\n                String path = m.getRelativeFilePath();\n                if (path == null || !path.startsWith(\"/\") || FileBackend.isInDirectoryThatShouldNotBeScanned(getActivity(), path)) {\n                    deleteFile.setVisible(true);\n                    deleteFile.setTitle(activity.getString(R.string.delete_x_file, UIHelper.getFileDescriptionString(activity, m)));\n                }\n            }\n            if (m.getStatus() == Message.STATUS_SEND_FAILED && m.getErrorMessage() != null && !Message.ERROR_MESSAGE_CANCELLED.equals(m.getErrorMessage())) {\n                showErrorMessage.setVisible(true);\n            }\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.share_with:\n                ShareUtil.share(activity, selectedMessage);\n                return true;\n            case R.id.correct_message:\n                correctMessage(selectedMessage);\n                return true;\n            case R.id.copy_message:\n                ShareUtil.copyToClipboard(activity, selectedMessage);\n                return true;\n            case R.id.copy_link:\n                ShareUtil.copyLinkToClipboard(activity, selectedMessage);\n                return true;\n            case R.id.quote_message:\n                quoteMessage(selectedMessage);\n                return true;\n            case R.id.send_again:\n                resendMessage(selectedMessage);\n                return true;\n            case R.id.copy_url:\n                ShareUtil.copyUrlToClipboard(activity, selectedMessage);\n                return true;\n            case R.id.download_file:\n                startDownloadable(selectedMessage);\n                return true;\n            case R.id.cancel_transmission:\n                cancelTransmission(selectedMessage);\n                return true;\n            case R.id.retry_decryption:\n                retryDecryption(selectedMessage);\n                return true;\n            case R.id.delete_file:\n                deleteFile(selectedMessage);\n                return true;\n            case R.id.show_error_message:\n                showErrorMessage(selectedMessage);\n                return true;\n            default:\n                return super.onContextItemSelected(item);\n        }\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(final MenuItem item) {\n        if (MenuDoubleTabUtil.shouldIgnoreTap()) {\n            return false;\n        } else if (conversation == null) {\n            return super.onOptionsItemSelected(item);\n        }\n        switch (item.getItemId()) {\n            case R.id.encryption_choice_axolotl:\n            case R.id.encryption_choice_pgp:\n            case R.id.encryption_choice_none:\n                handleEncryptionSelection(item);\n                break;\n            case R.id.attach_choose_picture:\n            case R.id.attach_take_picture:\n            case R.id.attach_record_video:\n            case R.id.attach_choose_file:\n            case R.id.attach_record_voice:\n            case R.id.attach_location:\n                handleAttachmentSelection(item);\n                break;\n            case R.id.action_archive:\n                activity.xmppConnectionService.archiveConversation(conversation);\n                break;\n            case R.id.action_contact_details:\n                activity.switchToContactDetails(conversation.getContact());\n                break;\n            case R.id.action_muc_details:\n                Intent intent = new Intent(getActivity(), ConferenceDetailsActivity.class);\n                intent.setAction(ConferenceDetailsActivity.ACTION_VIEW_MUC);\n                intent.putExtra(\"uuid\", conversation.getUuid());\n                startActivity(intent);\n                break;\n            case R.id.action_invite:\n                startActivityForResult(ChooseContactActivity.create(activity, conversation), REQUEST_INVITE_TO_CONVERSATION);\n                break;\n            case R.id.action_clear_history:\n                clearHistoryDialog(conversation);\n                break;\n            case R.id.action_mute:\n                muteConversationDialog(conversation);\n                break;\n            case R.id.action_unmute:\n                unmuteConversation(conversation);\n                break;\n            case R.id.action_block:\n            case R.id.action_unblock:\n                final Activity activity = getActivity();\n                if (activity instanceof XmppActivity) {\n                    BlockContactDialog.show((XmppActivity) activity, conversation);\n                }\n                break;\n            default:\n                break;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private void handleAttachmentSelection(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.attach_choose_picture:\n                attachFile(ATTACHMENT_CHOICE_CHOOSE_IMAGE);\n                break;\n            case R.id.attach_take_picture:\n                attachFile(ATTACHMENT_CHOICE_TAKE_PHOTO);\n                break;\n            case R.id.attach_record_video:\n                attachFile(ATTACHMENT_CHOICE_RECORD_VIDEO);\n                break;\n            case R.id.attach_choose_file:\n                attachFile(ATTACHMENT_CHOICE_CHOOSE_FILE);\n                break;\n            case R.id.attach_record_voice:\n                attachFile(ATTACHMENT_CHOICE_RECORD_VOICE);\n                break;\n            case R.id.attach_location:\n                attachFile(ATTACHMENT_CHOICE_LOCATION);\n                break;\n        }\n    }\n\n    private void handleEncryptionSelection(MenuItem item) {\n        if (conversation == null) {\n            return;\n        }\n        switch (item.getItemId()) {\n            case R.id.encryption_choice_none:\n                conversation.setNextEncryption(Message.ENCRYPTION_NONE);\n                item.setChecked(true);\n                break;\n            case R.id.encryption_choice_pgp:\n                if (activity.hasPgp()) {\n                    if (conversation.getAccount().getPgpSignature() != null) {\n                        conversation.setNextEncryption(Message.ENCRYPTION_PGP);\n                        item.setChecked(true);\n                    } else {\n                        activity.announcePgp(conversation.getAccount(), conversation, null, activity.onOpenPGPKeyPublished);\n                    }\n                } else {\n                    activity.showInstallPgpDialog();\n                }\n                break;\n            case R.id.encryption_choice_axolotl:\n                Log.d(Config.LOGTAG, AxolotlService.getLogprefix(conversation.getAccount())\n                        + \"Enabled axolotl for Contact \" + conversation.getContact().getJid());\n                conversation.setNextEncryption(Message.ENCRYPTION_AXOLOTL);\n                item.setChecked(true);\n                break;\n            default:\n                conversation.setNextEncryption(Message.ENCRYPTION_NONE);\n                break;\n        }\n        activity.xmppConnectionService.updateConversation(conversation);\n        updateChatMsgHint();\n        getActivity().invalidateOptionsMenu();\n        activity.refreshUi();\n    }\n\n    public void attachFile(final int attachmentChoice) {\n        if (attachmentChoice == ATTACHMENT_CHOICE_RECORD_VOICE) {\n            if (!hasPermissions(attachmentChoice, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.RECORD_AUDIO)) {\n                return;\n            }\n        } else if (attachmentChoice == ATTACHMENT_CHOICE_TAKE_PHOTO || attachmentChoice == ATTACHMENT_CHOICE_RECORD_VIDEO) {\n            if (!hasPermissions(attachmentChoice, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA)) {\n                return;\n            }\n        } else if (attachmentChoice != ATTACHMENT_CHOICE_LOCATION) {\n            if (!hasPermissions(attachmentChoice, Manifest.permission.WRITE_EXTERNAL_STORAGE)) {\n                return;\n            }\n        }\n        try {\n            activity.getPreferences().edit()\n                    .putString(RECENTLY_USED_QUICK_ACTION, SendButtonAction.of(attachmentChoice).toString())\n                    .apply();\n        } catch (IllegalArgumentException e) {\n            //just do not save\n        }\n        final int encryption = conversation.getNextEncryption();\n        final int mode = conversation.getMode();\n        if (encryption == Message.ENCRYPTION_PGP) {\n            if (activity.hasPgp()) {\n                if (mode == Conversation.MODE_SINGLE && conversation.getContact().getPgpKeyId() != 0) {\n                    activity.xmppConnectionService.getPgpEngine().hasKey(\n                            conversation.getContact(),\n                            new UiCallback<Contact>() {\n\n                                @Override\n                                public void userInputRequried(PendingIntent pi, Contact contact) {\n                                    startPendingIntent(pi, attachmentChoice);\n                                }\n\n                                @Override\n                                public void success(Contact contact) {\n                                    selectPresenceToAttachFile(attachmentChoice);\n                                }\n\n                                @Override\n                                public void error(int error, Contact contact) {\n                                    activity.replaceToast(getString(error));\n                                }\n                            });\n                } else if (mode == Conversation.MODE_MULTI && conversation.getMucOptions().pgpKeysInUse()) {\n                    if (!conversation.getMucOptions().everybodyHasKeys()) {\n                        Toast warning = Toast.makeText(getActivity(), R.string.missing_public_keys, Toast.LENGTH_LONG);\n                        warning.setGravity(Gravity.CENTER_VERTICAL, 0, 0);\n                        warning.show();\n                    }\n                    selectPresenceToAttachFile(attachmentChoice);\n                } else {\n                    showNoPGPKeyDialog(false, (dialog, which) -> {\n                        conversation.setNextEncryption(Message.ENCRYPTION_NONE);\n                        activity.xmppConnectionService.updateConversation(conversation);\n                        selectPresenceToAttachFile(attachmentChoice);\n                    });\n                }\n            } else {\n                activity.showInstallPgpDialog();\n            }\n        } else {\n            selectPresenceToAttachFile(attachmentChoice);\n        }\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String permissions[], @NonNull int[] grantResults) {\n        if (grantResults.length > 0) {\n            if (allGranted(grantResults)) {\n                if (requestCode == REQUEST_START_DOWNLOAD) {\n                    if (this.mPendingDownloadableMessage != null) {\n                        startDownloadable(this.mPendingDownloadableMessage);\n                    }\n                } else if (requestCode == REQUEST_ADD_EDITOR_CONTENT) {\n                    if (this.mPendingEditorContent != null) {\n                        attachEditorContentToConversation(this.mPendingEditorContent);\n                    }\n                } else {\n                    attachFile(requestCode);\n                }\n            } else {\n                @StringRes int res;\n                String firstDenied = getFirstDenied(grantResults, permissions);\n                if (Manifest.permission.RECORD_AUDIO.equals(firstDenied)) {\n                    res = R.string.no_microphone_permission;\n                } else if (Manifest.permission.CAMERA.equals(firstDenied)) {\n                    res = R.string.no_camera_permission;\n                } else {\n                    res = R.string.no_storage_permission;\n                }\n                Toast.makeText(getActivity(), res, Toast.LENGTH_SHORT).show();\n            }\n        }\n        if (writeGranted(grantResults, permissions)) {\n            if (activity != null && activity.xmppConnectionService != null) {\n                activity.xmppConnectionService.restartFileObserver();\n            }\n        }\n    }\n\n    public void startDownloadable(Message message) {\n        if (!hasPermissions(REQUEST_START_DOWNLOAD, Manifest.permission.WRITE_EXTERNAL_STORAGE)) {\n            this.mPendingDownloadableMessage = message;\n            return;\n        }\n        Transferable transferable = message.getTransferable();\n        if (transferable != null) {\n            if (transferable instanceof TransferablePlaceholder && message.hasFileOnRemoteHost()) {\n                createNewConnection(message);\n                return;\n            }\n            if (!transferable.start()) {\n                Log.d(Config.LOGTAG, \"type: \" + transferable.getClass().getName());\n                Toast.makeText(getActivity(), R.string.not_connected_try_again, Toast.LENGTH_SHORT).show();\n            }\n        } else if (message.treatAsDownloadable()) {\n            createNewConnection(message);\n        }\n    }\n\n    private void createNewConnection(final Message message) {\n        if (!activity.xmppConnectionService.getHttpConnectionManager().checkConnection(message)) {\n            Toast.makeText(getActivity(), R.string.not_connected_try_again, Toast.LENGTH_SHORT).show();\n            return;\n        }\n        activity.xmppConnectionService.getHttpConnectionManager().createNewDownloadConnection(message, true);\n    }\n\n    @SuppressLint(\"InflateParams\")\n    protected void clearHistoryDialog(final Conversation conversation) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setTitle(getString(R.string.clear_conversation_history));\n        final View dialogView = getActivity().getLayoutInflater().inflate(R.layout.dialog_clear_history, null);\n        final CheckBox endConversationCheckBox = dialogView.findViewById(R.id.end_conversation_checkbox);\n        builder.setView(dialogView);\n        builder.setNegativeButton(getString(R.string.cancel), null);\n        builder.setPositiveButton(getString(R.string.confirm), (dialog, which) -> {\n            this.activity.xmppConnectionService.clearConversationHistory(conversation);\n            if (endConversationCheckBox.isChecked()) {\n                this.activity.xmppConnectionService.archiveConversation(conversation);\n                this.activity.onConversationArchived(conversation);\n            } else {\n                activity.onConversationsListItemUpdated();\n                refresh();\n            }\n        });\n        builder.create().show();\n    }\n\n    protected void muteConversationDialog(final Conversation conversation) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setTitle(R.string.disable_notifications);\n        final int[] durations = getResources().getIntArray(R.array.mute_options_durations);\n        final CharSequence[] labels = new CharSequence[durations.length];\n        for (int i = 0; i < durations.length; ++i) {\n            if (durations[i] == -1) {\n                labels[i] = getString(R.string.until_further_notice);\n            } else {\n                labels[i] = TimeframeUtils.resolve(activity, 1000L * durations[i]);\n            }\n        }\n        builder.setItems(labels, (dialog, which) -> {\n            final long till;\n            if (durations[which] == -1) {\n                till = Long.MAX_VALUE;\n            } else {\n                till = System.currentTimeMillis() + (durations[which] * 1000);\n            }\n            conversation.setMutedTill(till);\n            activity.xmppConnectionService.updateConversation(conversation);\n            activity.onConversationsListItemUpdated();\n            refresh();\n            getActivity().invalidateOptionsMenu();\n        });\n        builder.create().show();\n    }\n\n    private boolean hasPermissions(int requestCode, String... permissions) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            final List<String> missingPermissions = new ArrayList<>();\n            for (String permission : permissions) {\n                if (Config.ONLY_INTERNAL_STORAGE && permission.equals(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {\n                    continue;\n                }\n                if (activity.checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {\n                    missingPermissions.add(permission);\n                }\n            }\n            if (missingPermissions.size() == 0) {\n                return true;\n            } else {\n                requestPermissions(missingPermissions.toArray(new String[missingPermissions.size()]), requestCode);\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n\n    public void unmuteConversation(final Conversation conversation) {\n        conversation.setMutedTill(0);\n        this.activity.xmppConnectionService.updateConversation(conversation);\n        this.activity.onConversationsListItemUpdated();\n        refresh();\n        getActivity().invalidateOptionsMenu();\n    }\n\n    protected void selectPresenceToAttachFile(final int attachmentChoice) {\n        final Account account = conversation.getAccount();\n        final PresenceSelector.OnPresenceSelected callback = () -> {\n            Intent intent = new Intent();\n            boolean chooser = false;\n            switch (attachmentChoice) {\n                case ATTACHMENT_CHOICE_CHOOSE_IMAGE:\n                    intent.setAction(Intent.ACTION_GET_CONTENT);\n                    intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);\n                    intent.setType(\"image/*\");\n                    chooser = true;\n                    break;\n                case ATTACHMENT_CHOICE_RECORD_VIDEO:\n                    intent.setAction(MediaStore.ACTION_VIDEO_CAPTURE);\n                    break;\n                case ATTACHMENT_CHOICE_TAKE_PHOTO:\n                    final Uri uri = activity.xmppConnectionService.getFileBackend().getTakePhotoUri();\n                    pendingTakePhotoUri.push(uri);\n                    intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);\n                    intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n                    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                    intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);\n                    break;\n                case ATTACHMENT_CHOICE_CHOOSE_FILE:\n                    chooser = true;\n                    intent.setType(\"*/*\");\n                    intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);\n                    intent.addCategory(Intent.CATEGORY_OPENABLE);\n                    intent.setAction(Intent.ACTION_GET_CONTENT);\n                    break;\n                case ATTACHMENT_CHOICE_RECORD_VOICE:\n                    intent = new Intent(getActivity(), RecordingActivity.class);\n                    break;\n                case ATTACHMENT_CHOICE_LOCATION:\n                    intent = GeoHelper.getFetchIntent(activity);\n                    break;\n            }\n            if (intent.resolveActivity(getActivity().getPackageManager()) != null) {\n                if (chooser) {\n                    startActivityForResult(\n                            Intent.createChooser(intent, getString(R.string.perform_action_with)),\n                            attachmentChoice);\n                } else {\n                    startActivityForResult(intent, attachmentChoice);\n                }\n            }\n        };\n        if (account.httpUploadAvailable() || attachmentChoice == ATTACHMENT_CHOICE_LOCATION) {\n            conversation.setNextCounterpart(null);\n            callback.onPresenceSelected();\n        } else {\n            activity.selectPresence(conversation, callback);\n        }\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        binding.messagesView.post(this::fireReadEvent);\n    }\n\n    private void fireReadEvent() {\n        if (activity != null && this.conversation != null) {\n            String uuid = getLastVisibleMessageUuid();\n            if (uuid != null) {\n                activity.onConversationRead(this.conversation, uuid);\n            }\n        }\n    }\n\n    private String getLastVisibleMessageUuid() {\n        if (binding == null) {\n            return null;\n        }\n        synchronized (this.messageList) {\n            int pos = binding.messagesView.getLastVisiblePosition();\n            if (pos >= 0) {\n                Message message = null;\n                for (int i = pos; i >= 0; --i) {\n                    try {\n                        message = (Message) binding.messagesView.getItemAtPosition(i);\n                    } catch (IndexOutOfBoundsException e) {\n                        //should not happen if we synchronize properly. however if that fails we just gonna try item -1\n                        continue;\n                    }\n                    if (message.getType() != Message.TYPE_STATUS) {\n                        break;\n                    }\n                }\n                if (message != null) {\n                    while (message.next() != null && message.next().wasMergedIntoPrevious()) {\n                        message = message.next();\n                    }\n                    return message.getUuid();\n                }\n            }\n        }\n        return null;\n    }\n\n    private void showErrorMessage(final Message message) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setTitle(R.string.error_message);\n        builder.setMessage(message.getErrorMessage());\n        builder.setPositiveButton(R.string.confirm, null);\n        builder.create().show();\n    }\n\n\n    private void deleteFile(final Message message) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setNegativeButton(R.string.cancel, null);\n        builder.setTitle(R.string.delete_file_dialog);\n        builder.setMessage(R.string.delete_file_dialog_msg);\n        builder.setPositiveButton(R.string.confirm, (dialog, which) -> {\n            if (activity.xmppConnectionService.getFileBackend().deleteFile(message)) {\n                message.setTransferable(new TransferablePlaceholder(Transferable.STATUS_DELETED));\n                activity.onConversationsListItemUpdated();\n                refresh();\n            }\n        });\n        builder.create().show();\n\n    }\n\n    private void resendMessage(final Message message) {\n        if (message.isFileOrImage()) {\n            if (!(message.getConversation() instanceof Conversation)) {\n                return;\n            }\n            final Conversation conversation = (Conversation) message.getConversation();\n            DownloadableFile file = activity.xmppConnectionService.getFileBackend().getFile(message);\n            if (file.exists()) {\n                final XmppConnection xmppConnection = conversation.getAccount().getXmppConnection();\n                if (!message.hasFileOnRemoteHost()\n                        && xmppConnection != null\n                        && !xmppConnection.getFeatures().httpUpload(message.getFileParams().size)) {\n                    activity.selectPresence(conversation, () -> {\n                        message.setCounterpart(conversation.getNextCounterpart());\n                        activity.xmppConnectionService.resendFailedMessages(message);\n                        new Handler().post(() -> {\n                            int size = messageList.size();\n                            this.binding.messagesView.setSelection(size - 1);\n                        });\n                    });\n                    return;\n                }\n            } else {\n                Toast.makeText(activity, R.string.file_deleted, Toast.LENGTH_SHORT).show();\n                message.setTransferable(new TransferablePlaceholder(Transferable.STATUS_DELETED));\n                activity.onConversationsListItemUpdated();\n                refresh();\n                return;\n            }\n        }\n        activity.xmppConnectionService.resendFailedMessages(message);\n        new Handler().post(() -> {\n            int size = messageList.size();\n            this.binding.messagesView.setSelection(size - 1);\n        });\n    }\n\n    private void cancelTransmission(Message message) {\n        Transferable transferable = message.getTransferable();\n        if (transferable != null) {\n            transferable.cancel();\n        } else if (message.getStatus() != Message.STATUS_RECEIVED) {\n            activity.xmppConnectionService.markMessage(message, Message.STATUS_SEND_FAILED, Message.ERROR_MESSAGE_CANCELLED);\n        }\n    }\n\n    private void retryDecryption(Message message) {\n        message.setEncryption(Message.ENCRYPTION_PGP);\n        activity.onConversationsListItemUpdated();\n        refresh();\n        conversation.getAccount().getPgpDecryptionService().decrypt(message, false);\n    }\n\n    public void privateMessageWith(final Jid counterpart) {\n        if (conversation.setOutgoingChatState(Config.DEFAULT_CHATSTATE)) {\n            activity.xmppConnectionService.sendChatState(conversation);\n        }\n        this.binding.textinput.setText(\"\");\n        this.conversation.setNextCounterpart(counterpart);\n        updateChatMsgHint();\n        updateSendButton();\n        updateEditablity();\n    }\n\n    private void correctMessage(Message message) {\n        while (message.mergeable(message.next())) {\n            message = message.next();\n        }\n        this.conversation.setCorrectingMessage(message);\n        final Editable editable = binding.textinput.getText();\n        this.conversation.setDraftMessage(editable.toString());\n        this.binding.textinput.setText(\"\");\n        this.binding.textinput.append(message.getBody());\n\n    }\n\n    private void highlightInConference(String nick) {\n        final Editable editable = this.binding.textinput.getText();\n        String oldString = editable.toString().trim();\n        final int pos = this.binding.textinput.getSelectionStart();\n        if (oldString.isEmpty() || pos == 0) {\n            editable.insert(0, nick + \": \");\n        } else {\n            final char before = editable.charAt(pos - 1);\n            final char after = editable.length() > pos ? editable.charAt(pos) : '\\0';\n            if (before == '\\n') {\n                editable.insert(pos, nick + \": \");\n            } else {\n                if (pos > 2 && editable.subSequence(pos - 2, pos).toString().equals(\": \")) {\n                    if (NickValidityChecker.check(conversation, Arrays.asList(editable.subSequence(0, pos - 2).toString().split(\", \")))) {\n                        editable.insert(pos - 2, \", \" + nick);\n                        return;\n                    }\n                }\n                editable.insert(pos, (Character.isWhitespace(before) ? \"\" : \" \") + nick + (Character.isWhitespace(after) ? \"\" : \" \"));\n                if (Character.isWhitespace(after)) {\n                    this.binding.textinput.setSelection(this.binding.textinput.getSelectionStart() + 1);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        final Activity activity = getActivity();\n        if (activity instanceof ConversationsActivity) {\n            ((ConversationsActivity) activity).clearPendingViewIntent();\n        }\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        if (conversation != null) {\n            outState.putString(STATE_CONVERSATION_UUID, conversation.getUuid());\n            outState.putString(STATE_LAST_MESSAGE_UUID, lastMessageUuid);\n            final Uri uri = pendingTakePhotoUri.peek();\n            if (uri != null) {\n                outState.putString(STATE_PHOTO_URI, uri.toString());\n            }\n            final ScrollState scrollState = getScrollPosition();\n            if (scrollState != null) {\n                outState.putParcelable(STATE_SCROLL_POSITION, scrollState);\n            }\n            final ArrayList<Attachment> attachments = mediaPreviewAdapter.getAttachments();\n            if (attachments.size() > 0) {\n                outState.putParcelableArrayList(STATE_MEDIA_PREVIEWS, attachments);\n            }\n        }\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        if (savedInstanceState == null) {\n            return;\n        }\n        String uuid = savedInstanceState.getString(STATE_CONVERSATION_UUID);\n        ArrayList<Attachment> attachments = savedInstanceState.getParcelableArrayList(STATE_MEDIA_PREVIEWS);\n        pendingLastMessageUuid.push(savedInstanceState.getString(STATE_LAST_MESSAGE_UUID, null));\n        if (uuid != null) {\n            QuickLoader.set(uuid);\n            this.pendingConversationsUuid.push(uuid);\n            if (attachments != null && attachments.size() > 0) {\n                this.pendingMediaPreviews.push(attachments);\n            }\n            String takePhotoUri = savedInstanceState.getString(STATE_PHOTO_URI);\n            if (takePhotoUri != null) {\n                pendingTakePhotoUri.push(Uri.parse(takePhotoUri));\n            }\n            pendingScrollState.push(savedInstanceState.getParcelable(STATE_SCROLL_POSITION));\n        }\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        if (this.reInitRequiredOnStart && this.conversation != null) {\n            final Bundle extras = pendingExtras.pop();\n            reInit(this.conversation, extras != null);\n            if (extras != null) {\n                processExtras(extras);\n            }\n        } else if (conversation == null && activity != null && activity.xmppConnectionService != null) {\n            final String uuid = pendingConversationsUuid.pop();\n            Log.d(Config.LOGTAG, \"ConversationFragment.onStart() - activity was bound but no conversation loaded. uuid=\" + uuid);\n            if (uuid != null) {\n                findAndReInitByUuidOrArchive(uuid);\n            }\n        }\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        final Activity activity = getActivity();\n        messageListAdapter.unregisterListenerInAudioPlayer();\n        if (activity == null || !activity.isChangingConfigurations()) {\n            hideSoftKeyboard(activity);\n            messageListAdapter.stopAudioPlayer();\n        }\n        if (this.conversation != null) {\n            final String msg = this.binding.textinput.getText().toString();\n            storeNextMessage(msg);\n            updateChatState(this.conversation, msg);\n            this.activity.xmppConnectionService.getNotificationService().setOpenConversation(null);\n        }\n        this.reInitRequiredOnStart = true;\n    }\n\n    private void updateChatState(final Conversation conversation, final String msg) {\n        ChatState state = msg.length() == 0 ? Config.DEFAULT_CHATSTATE : ChatState.PAUSED;\n        Account.State status = conversation.getAccount().getStatus();\n        if (status == Account.State.ONLINE && conversation.setOutgoingChatState(state)) {\n            activity.xmppConnectionService.sendChatState(conversation);\n        }\n    }\n\n    private void saveMessageDraftStopAudioPlayer() {\n        final Conversation previousConversation = this.conversation;\n        if (this.activity == null || this.binding == null || previousConversation == null) {\n            return;\n        }\n        Log.d(Config.LOGTAG, \"ConversationFragment.saveMessageDraftStopAudioPlayer()\");\n        final String msg = this.binding.textinput.getText().toString();\n        storeNextMessage(msg);\n        updateChatState(this.conversation, msg);\n        messageListAdapter.stopAudioPlayer();\n        mediaPreviewAdapter.clearPreviews();\n        toggleInputMethod();\n    }\n\n    public void reInit(Conversation conversation, Bundle extras) {\n        QuickLoader.set(conversation.getUuid());\n        this.saveMessageDraftStopAudioPlayer();\n        this.clearPending();\n        if (this.reInit(conversation, extras != null)) {\n            if (extras != null) {\n                processExtras(extras);\n            }\n            this.reInitRequiredOnStart = false;\n        } else {\n            this.reInitRequiredOnStart = true;\n            pendingExtras.push(extras);\n        }\n        resetUnreadMessagesCount();\n    }\n\n    private void reInit(Conversation conversation) {\n        reInit(conversation, false);\n    }\n\n    private boolean reInit(final Conversation conversation, final boolean hasExtras) {\n        if (conversation == null) {\n            return false;\n        }\n        this.conversation = conversation;\n        //once we set the conversation all is good and it will automatically do the right thing in onStart()\n        if (this.activity == null || this.binding == null) {\n            return false;\n        }\n\n        if (!activity.xmppConnectionService.isConversationStillOpen(this.conversation)) {\n            activity.onConversationArchived(this.conversation);\n            return false;\n        }\n\n        stopScrolling();\n        Log.d(Config.LOGTAG, \"reInit(hasExtras=\" + Boolean.toString(hasExtras) + \")\");\n\n        if (this.conversation.isRead() && hasExtras) {\n            Log.d(Config.LOGTAG, \"trimming conversation\");\n            this.conversation.trim();\n        }\n\n        setupIme();\n\n        final boolean scrolledToBottomAndNoPending = this.scrolledToBottom() && pendingScrollState.peek() == null;\n\n        this.binding.textSendButton.setContentDescription(activity.getString(R.string.send_message_to_x, conversation.getName()));\n        this.binding.textinput.setKeyboardListener(null);\n        this.binding.textinput.setText(\"\");\n        final boolean participating = conversation.getMode() == Conversational.MODE_SINGLE || conversation.getMucOptions().participating();\n        if (participating) {\n            this.binding.textinput.append(this.conversation.getNextMessage());\n        }\n        this.binding.textinput.setKeyboardListener(this);\n        messageListAdapter.updatePreferences();\n        refresh(false);\n        this.conversation.messagesLoaded.set(true);\n        Log.d(Config.LOGTAG, \"scrolledToBottomAndNoPending=\" + Boolean.toString(scrolledToBottomAndNoPending));\n\n        if (hasExtras || scrolledToBottomAndNoPending) {\n            resetUnreadMessagesCount();\n            synchronized (this.messageList) {\n                Log.d(Config.LOGTAG, \"jump to first unread message\");\n                final Message first = conversation.getFirstUnreadMessage();\n                final int bottom = Math.max(0, this.messageList.size() - 1);\n                final int pos;\n                final boolean jumpToBottom;\n                if (first == null) {\n                    pos = bottom;\n                    jumpToBottom = true;\n                } else {\n                    int i = getIndexOf(first.getUuid(), this.messageList);\n                    pos = i < 0 ? bottom : i;\n                    jumpToBottom = false;\n                }\n                setSelection(pos, jumpToBottom);\n            }\n        }\n\n\n        this.binding.messagesView.post(this::fireReadEvent);\n        //TODO if we only do this when this fragment is running on main it won't *bing* in tablet layout which might be unnecessary since we can *see* it\n        activity.xmppConnectionService.getNotificationService().setOpenConversation(this.conversation);\n        return true;\n    }\n\n    private void resetUnreadMessagesCount() {\n        lastMessageUuid = null;\n        hideUnreadMessagesCount();\n    }\n\n    private void hideUnreadMessagesCount() {\n        if (this.binding == null) {\n            return;\n        }\n        this.binding.scrollToBottomButton.setEnabled(false);\n        this.binding.scrollToBottomButton.hide();\n        this.binding.unreadCountCustomView.setVisibility(View.GONE);\n    }\n\n    private void setSelection(int pos, boolean jumpToBottom) {\n        ListViewUtils.setSelection(this.binding.messagesView, pos, jumpToBottom);\n        this.binding.messagesView.post(() -> ListViewUtils.setSelection(this.binding.messagesView, pos, jumpToBottom));\n        this.binding.messagesView.post(this::fireReadEvent);\n    }\n\n\n    private boolean scrolledToBottom() {\n        return this.binding != null && scrolledToBottom(this.binding.messagesView);\n    }\n\n    private void processExtras(Bundle extras) {\n        final String downloadUuid = extras.getString(ConversationsActivity.EXTRA_DOWNLOAD_UUID);\n        final String text = extras.getString(Intent.EXTRA_TEXT);\n        final String nick = extras.getString(ConversationsActivity.EXTRA_NICK);\n        final boolean asQuote = extras.getBoolean(ConversationsActivity.EXTRA_AS_QUOTE);\n        final boolean pm = extras.getBoolean(ConversationsActivity.EXTRA_IS_PRIVATE_MESSAGE, false);\n        final List<Uri> uris = extractUris(extras);\n        if (uris != null && uris.size() > 0) {\n            final List<Uri> cleanedUris = cleanUris(new ArrayList<>(uris));\n            mediaPreviewAdapter.addMediaPreviews(Attachment.of(getActivity(), cleanedUris));\n            toggleInputMethod();\n            return;\n        }\n        if (nick != null) {\n            if (pm) {\n                Jid jid = conversation.getJid();\n                try {\n                    Jid next = Jid.of(jid.getLocal(), jid.getDomain(), nick);\n                    privateMessageWith(next);\n                } catch (final IllegalArgumentException ignored) {\n                    //do nothing\n                }\n            } else {\n                final MucOptions mucOptions = conversation.getMucOptions();\n                if (mucOptions.participating() || conversation.getNextCounterpart() != null) {\n                    highlightInConference(nick);\n                }\n            }\n        } else {\n            if (text != null && asQuote) {\n                quoteText(text);\n            } else {\n                appendText(text);\n            }\n        }\n        final Message message = downloadUuid == null ? null : conversation.findMessageWithFileAndUuid(downloadUuid);\n        if (message != null) {\n            startDownloadable(message);\n        }\n    }\n\n    private List<Uri> extractUris(Bundle extras) {\n        final List<Uri> uris = extras.getParcelableArrayList(Intent.EXTRA_STREAM);\n        if (uris != null) {\n            return uris;\n        }\n        final Uri uri = extras.getParcelable(Intent.EXTRA_STREAM);\n        if (uri != null) {\n            return Collections.singletonList(uri);\n        } else {\n            return null;\n        }\n    }\n\n    private List<Uri> cleanUris(List<Uri> uris) {\n        Iterator<Uri> iterator = uris.iterator();\n        while(iterator.hasNext()) {\n            final Uri uri = iterator.next();\n            if (FileBackend.weOwnFile(getActivity(), uri)) {\n                iterator.remove();\n                Toast.makeText(getActivity(), R.string.security_violation_not_attaching_file, Toast.LENGTH_SHORT).show();\n            }\n        }\n        return uris;\n    }\n\n    private boolean showBlockSubmenu(View view) {\n        final Jid jid = conversation.getJid();\n        if (jid.getLocal() == null) {\n            BlockContactDialog.show(activity, conversation);\n        } else {\n            PopupMenu popupMenu = new PopupMenu(getActivity(), view);\n            popupMenu.inflate(R.menu.block);\n            popupMenu.setOnMenuItemClickListener(menuItem -> {\n                Blockable blockable;\n                switch (menuItem.getItemId()) {\n                    case R.id.block_domain:\n                        blockable = conversation.getAccount().getRoster().getContact(Jid.ofDomain(jid.getDomain()));\n                        break;\n                    default:\n                        blockable = conversation;\n                }\n                BlockContactDialog.show(activity, blockable);\n                return true;\n            });\n            popupMenu.show();\n        }\n        return true;\n    }\n\n    private void updateSnackBar(final Conversation conversation) {\n        final Account account = conversation.getAccount();\n        final XmppConnection connection = account.getXmppConnection();\n        final int mode = conversation.getMode();\n        final Contact contact = mode == Conversation.MODE_SINGLE ? conversation.getContact() : null;\n        if (conversation.getStatus() == Conversation.STATUS_ARCHIVED) {\n            return;\n        }\n        if (account.getStatus() == Account.State.DISABLED) {\n            showSnackbar(R.string.this_account_is_disabled, R.string.enable, this.mEnableAccountListener);\n        } else if (conversation.isBlocked()) {\n            showSnackbar(R.string.contact_blocked, R.string.unblock, this.mUnblockClickListener);\n        } else if (contact != null && !contact.showInRoster() && contact.getOption(Contact.Options.PENDING_SUBSCRIPTION_REQUEST)) {\n            showSnackbar(R.string.contact_added_you, R.string.add_back, this.mAddBackClickListener, this.mLongPressBlockListener);\n        } else if (contact != null && contact.getOption(Contact.Options.PENDING_SUBSCRIPTION_REQUEST)) {\n            showSnackbar(R.string.contact_asks_for_presence_subscription, R.string.allow, this.mAllowPresenceSubscription, this.mLongPressBlockListener);\n        } else if (mode == Conversation.MODE_MULTI\n                && !conversation.getMucOptions().online()\n                && account.getStatus() == Account.State.ONLINE) {\n            switch (conversation.getMucOptions().getError()) {\n                case NICK_IN_USE:\n                    showSnackbar(R.string.nick_in_use, R.string.edit, clickToMuc);\n                    break;\n                case NO_RESPONSE:\n                    showSnackbar(R.string.joining_conference, 0, null);\n                    break;\n                case SERVER_NOT_FOUND:\n                    if (conversation.receivedMessagesCount() > 0) {\n                        showSnackbar(R.string.remote_server_not_found, R.string.try_again, joinMuc);\n                    } else {\n                        showSnackbar(R.string.remote_server_not_found, R.string.leave, leaveMuc);\n                    }\n                    break;\n                case REMOTE_SERVER_TIMEOUT:\n                    if (conversation.receivedMessagesCount() > 0) {\n                        showSnackbar(R.string.remote_server_timeout, R.string.try_again, joinMuc);\n                    } else {\n                        showSnackbar(R.string.remote_server_timeout, R.string.leave, leaveMuc);\n                    }\n                    break;\n                case PASSWORD_REQUIRED:\n                    showSnackbar(R.string.conference_requires_password, R.string.enter_password, enterPassword);\n                    break;\n                case BANNED:\n                    showSnackbar(R.string.conference_banned, R.string.leave, leaveMuc);\n                    break;\n                case MEMBERS_ONLY:\n                    showSnackbar(R.string.conference_members_only, R.string.leave, leaveMuc);\n                    break;\n                case RESOURCE_CONSTRAINT:\n                    showSnackbar(R.string.conference_resource_constraint, R.string.try_again, joinMuc);\n                    break;\n                case KICKED:\n                    showSnackbar(R.string.conference_kicked, R.string.join, joinMuc);\n                    break;\n                case UNKNOWN:\n                    showSnackbar(R.string.conference_unknown_error, R.string.try_again, joinMuc);\n                    break;\n                case INVALID_NICK:\n                    showSnackbar(R.string.invalid_muc_nick, R.string.edit, clickToMuc);\n                case SHUTDOWN:\n                    showSnackbar(R.string.conference_shutdown, R.string.try_again, joinMuc);\n                    break;\n                case DESTROYED:\n                    showSnackbar(R.string.conference_destroyed, R.string.leave, leaveMuc);\n                    break;\n                default:\n                    hideSnackbar();\n                    break;\n            }\n        } else if (account.hasPendingPgpIntent(conversation)) {\n            showSnackbar(R.string.openpgp_messages_found, R.string.decrypt, clickToDecryptListener);\n        } else if (connection != null\n                && connection.getFeatures().blocking()\n                && conversation.countMessages() != 0\n                && !conversation.isBlocked()\n                && conversation.isWithStranger()) {\n            showSnackbar(R.string.received_message_from_stranger, R.string.block, mBlockClickListener);\n        } else {\n            hideSnackbar();\n        }\n    }\n\n    @Override\n    public void refresh() {\n        if (this.binding == null) {\n            Log.d(Config.LOGTAG, \"ConversationFragment.refresh() skipped updated because view binding was null\");\n            return;\n        }\n        if (this.conversation != null && this.activity != null && this.activity.xmppConnectionService != null) {\n            if (!activity.xmppConnectionService.isConversationStillOpen(this.conversation)) {\n                activity.onConversationArchived(this.conversation);\n                return;\n            }\n        }\n        this.refresh(true);\n    }\n\n    private void refresh(boolean notifyConversationRead) {\n        synchronized (this.messageList) {\n            if (this.conversation != null) {\n                conversation.populateWithMessages(this.messageList);\n                updateSnackBar(conversation);\n                updateStatusMessages();\n                if (conversation.getReceivedMessagesCountSinceUuid(lastMessageUuid) != 0) {\n                    binding.unreadCountCustomView.setVisibility(View.VISIBLE);\n                    binding.unreadCountCustomView.setUnreadCount(conversation.getReceivedMessagesCountSinceUuid(lastMessageUuid));\n                }\n                this.messageListAdapter.notifyDataSetChanged();\n                updateChatMsgHint();\n                if (notifyConversationRead && activity != null) {\n                    binding.messagesView.post(this::fireReadEvent);\n                }\n                updateSendButton();\n                updateEditablity();\n                activity.invalidateOptionsMenu();\n            }\n        }\n    }\n\n    protected void messageSent() {\n        mSendingPgpMessage.set(false);\n        this.binding.textinput.setText(\"\");\n        if (conversation.setCorrectingMessage(null)) {\n            this.binding.textinput.append(conversation.getDraftMessage());\n            conversation.setDraftMessage(null);\n        }\n        storeNextMessage();\n        updateChatMsgHint();\n        SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(activity);\n        final boolean prefScrollToBottom = p.getBoolean(\"scroll_to_bottom\", activity.getResources().getBoolean(R.bool.scroll_to_bottom));\n        if (prefScrollToBottom || scrolledToBottom()) {\n            new Handler().post(() -> {\n                int size = messageList.size();\n                this.binding.messagesView.setSelection(size - 1);\n            });\n        }\n    }\n\n    private boolean storeNextMessage() {\n        return storeNextMessage(this.binding.textinput.getText().toString());\n    }\n\n    private boolean storeNextMessage(String msg) {\n        final boolean participating = conversation.getMode() == Conversational.MODE_SINGLE || conversation.getMucOptions().participating();\n        if (this.conversation.getStatus() != Conversation.STATUS_ARCHIVED && participating && this.conversation.setNextMessage(msg)) {\n            this.activity.xmppConnectionService.updateConversation(this.conversation);\n            return true;\n        }\n        return false;\n    }\n\n    public void doneSendingPgpMessage() {\n        mSendingPgpMessage.set(false);\n    }\n\n    public long getMaxHttpUploadSize(Conversation conversation) {\n        final XmppConnection connection = conversation.getAccount().getXmppConnection();\n        return connection == null ? -1 : connection.getFeatures().getMaxHttpUploadSize();\n    }\n\n    private void updateEditablity() {\n        boolean canWrite = this.conversation.getMode() == Conversation.MODE_SINGLE || this.conversation.getMucOptions().participating() || this.conversation.getNextCounterpart() != null;\n        this.binding.textinput.setFocusable(canWrite);\n        this.binding.textinput.setFocusableInTouchMode(canWrite);\n        this.binding.textSendButton.setEnabled(canWrite);\n        this.binding.textinput.setCursorVisible(canWrite);\n        this.binding.textinput.setEnabled(canWrite);\n    }\n\n    public void updateSendButton() {\n        boolean hasAttachments = mediaPreviewAdapter != null && mediaPreviewAdapter.hasAttachments();\n        boolean useSendButtonToIndicateStatus = PreferenceManager.getDefaultSharedPreferences(getActivity()).getBoolean(\"send_button_status\", getResources().getBoolean(R.bool.send_button_status));\n        final Conversation c = this.conversation;\n        final Presence.Status status;\n        final String text = this.binding.textinput == null ? \"\" : this.binding.textinput.getText().toString();\n        final SendButtonAction action;\n        if (hasAttachments) {\n            action = SendButtonAction.TEXT;\n        } else {\n            action = SendButtonTool.getAction(getActivity(), c, text);\n        }\n        if (useSendButtonToIndicateStatus && c.getAccount().getStatus() == Account.State.ONLINE) {\n            if (activity.xmppConnectionService != null && activity.xmppConnectionService.getMessageArchiveService().isCatchingUp(c)) {\n                status = Presence.Status.OFFLINE;\n            } else if (c.getMode() == Conversation.MODE_SINGLE) {\n                status = c.getContact().getShownStatus();\n            } else {\n                status = c.getMucOptions().online() ? Presence.Status.ONLINE : Presence.Status.OFFLINE;\n            }\n        } else {\n            status = Presence.Status.OFFLINE;\n        }\n        this.binding.textSendButton.setTag(action);\n        this.binding.textSendButton.setImageResource(SendButtonTool.getSendButtonImageResource(getActivity(), action, status));\n    }\n\n    protected void updateDateSeparators() {\n        synchronized (this.messageList) {\n            DateSeparator.addAll(this.messageList);\n        }\n    }\n\n    protected void updateStatusMessages() {\n        updateDateSeparators();\n        synchronized (this.messageList) {\n            if (showLoadMoreMessages(conversation)) {\n                this.messageList.add(0, Message.createLoadMoreMessage(conversation));\n            }\n            if (conversation.getMode() == Conversation.MODE_SINGLE) {\n                ChatState state = conversation.getIncomingChatState();\n                if (state == ChatState.COMPOSING) {\n                    this.messageList.add(Message.createStatusMessage(conversation, getString(R.string.contact_is_typing, conversation.getName())));\n                } else if (state == ChatState.PAUSED) {\n                    this.messageList.add(Message.createStatusMessage(conversation, getString(R.string.contact_has_stopped_typing, conversation.getName())));\n                } else {\n                    for (int i = this.messageList.size() - 1; i >= 0; --i) {\n                        final Message message = this.messageList.get(i);\n                        if (message.getType() != Message.TYPE_STATUS) {\n                            if (message.getStatus() == Message.STATUS_RECEIVED) {\n                                return;\n                            } else {\n                                if (message.getStatus() == Message.STATUS_SEND_DISPLAYED) {\n                                    this.messageList.add(i + 1,\n                                            Message.createStatusMessage(conversation, getString(R.string.contact_has_read_up_to_this_point, conversation.getName())));\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                final MucOptions mucOptions = conversation.getMucOptions();\n                final List<MucOptions.User> allUsers = mucOptions.getUsers();\n                final Set<ReadByMarker> addedMarkers = new HashSet<>();\n                ChatState state = ChatState.COMPOSING;\n                List<MucOptions.User> users = conversation.getMucOptions().getUsersWithChatState(state, 5);\n                if (users.size() == 0) {\n                    state = ChatState.PAUSED;\n                    users = conversation.getMucOptions().getUsersWithChatState(state, 5);\n                }\n                if (mucOptions.isPrivateAndNonAnonymous()) {\n                    for (int i = this.messageList.size() - 1; i >= 0; --i) {\n                        final Set<ReadByMarker> markersForMessage = messageList.get(i).getReadByMarkers();\n                        final List<MucOptions.User> shownMarkers = new ArrayList<>();\n                        for (ReadByMarker marker : markersForMessage) {\n                            if (!ReadByMarker.contains(marker, addedMarkers)) {\n                                addedMarkers.add(marker); //may be put outside this condition. set should do dedup anyway\n                                MucOptions.User user = mucOptions.findUser(marker);\n                                if (user != null && !users.contains(user)) {\n                                    shownMarkers.add(user);\n                                }\n                            }\n                        }\n                        final ReadByMarker markerForSender = ReadByMarker.from(messageList.get(i));\n                        final Message statusMessage;\n                        final int size = shownMarkers.size();\n                        if (size > 1) {\n                            final String body;\n                            if (size <= 4) {\n                                body = getString(R.string.contacts_have_read_up_to_this_point, UIHelper.concatNames(shownMarkers));\n                            } else if (ReadByMarker.allUsersRepresented(allUsers, markersForMessage, markerForSender)) {\n                                body = getString(R.string.everyone_has_read_up_to_this_point);\n                            } else {\n                                body = getString(R.string.contacts_and_n_more_have_read_up_to_this_point, UIHelper.concatNames(shownMarkers, 3), size - 3);\n                            }\n                            statusMessage = Message.createStatusMessage(conversation, body);\n                            statusMessage.setCounterparts(shownMarkers);\n                        } else if (size == 1) {\n                            statusMessage = Message.createStatusMessage(conversation, getString(R.string.contact_has_read_up_to_this_point, UIHelper.getDisplayName(shownMarkers.get(0))));\n                            statusMessage.setCounterpart(shownMarkers.get(0).getFullJid());\n                            statusMessage.setTrueCounterpart(shownMarkers.get(0).getRealJid());\n                        } else {\n                            statusMessage = null;\n                        }\n                        if (statusMessage != null) {\n                            this.messageList.add(i + 1, statusMessage);\n                        }\n                        addedMarkers.add(markerForSender);\n                        if (ReadByMarker.allUsersRepresented(allUsers, addedMarkers)) {\n                            break;\n                        }\n                    }\n                }\n                if (users.size() > 0) {\n                    Message statusMessage;\n                    if (users.size() == 1) {\n                        MucOptions.User user = users.get(0);\n                        int id = state == ChatState.COMPOSING ? R.string.contact_is_typing : R.string.contact_has_stopped_typing;\n                        statusMessage = Message.createStatusMessage(conversation, getString(id, UIHelper.getDisplayName(user)));\n                        statusMessage.setTrueCounterpart(user.getRealJid());\n                        statusMessage.setCounterpart(user.getFullJid());\n                    } else {\n                        int id = state == ChatState.COMPOSING ? R.string.contacts_are_typing : R.string.contacts_have_stopped_typing;\n                        statusMessage = Message.createStatusMessage(conversation, getString(id, UIHelper.concatNames(users)));\n                        statusMessage.setCounterparts(users);\n                    }\n                    this.messageList.add(statusMessage);\n                }\n\n            }\n        }\n    }\n\n    private void stopScrolling() {\n        long now = SystemClock.uptimeMillis();\n        MotionEvent cancel = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0, 0, 0);\n        binding.messagesView.dispatchTouchEvent(cancel);\n    }\n\n    private boolean showLoadMoreMessages(final Conversation c) {\n        if (activity == null || activity.xmppConnectionService == null) {\n            return false;\n        }\n        final boolean mam = hasMamSupport(c) && !c.getContact().isBlocked();\n        final MessageArchiveService service = activity.xmppConnectionService.getMessageArchiveService();\n        return mam && (c.getLastClearHistory().getTimestamp() != 0 || (c.countMessages() == 0 && c.messagesLoaded.get() && c.hasMessagesLeftOnServer() && !service.queryInProgress(c)));\n    }\n\n    private boolean hasMamSupport(final Conversation c) {\n        if (c.getMode() == Conversation.MODE_SINGLE) {\n            final XmppConnection connection = c.getAccount().getXmppConnection();\n            return connection != null && connection.getFeatures().mam();\n        } else {\n            return c.getMucOptions().mamSupport();\n        }\n    }\n\n    protected void showSnackbar(final int message, final int action, final OnClickListener clickListener) {\n        showSnackbar(message, action, clickListener, null);\n    }\n\n    protected void showSnackbar(final int message, final int action, final OnClickListener clickListener, final View.OnLongClickListener longClickListener) {\n        this.binding.snackbar.setVisibility(View.VISIBLE);\n        this.binding.snackbar.setOnClickListener(null);\n        this.binding.snackbarMessage.setText(message);\n        this.binding.snackbarMessage.setOnClickListener(null);\n        this.binding.snackbarAction.setVisibility(clickListener == null ? View.GONE : View.VISIBLE);\n        if (action != 0) {\n            this.binding.snackbarAction.setText(action);\n        }\n        this.binding.snackbarAction.setOnClickListener(clickListener);\n        this.binding.snackbarAction.setOnLongClickListener(longClickListener);\n    }\n\n    protected void hideSnackbar() {\n        this.binding.snackbar.setVisibility(View.GONE);\n    }\n\n    protected void sendMessage(Message message) {\n        activity.xmppConnectionService.sendMessage(message);\n        messageSent();\n    }\n\n    protected void sendPgpMessage(final Message message) {\n        final XmppConnectionService xmppService = activity.xmppConnectionService;\n        final Contact contact = message.getConversation().getContact();\n        if (!activity.hasPgp()) {\n            activity.showInstallPgpDialog();\n            return;\n        }\n        if (conversation.getAccount().getPgpSignature() == null) {\n            activity.announcePgp(conversation.getAccount(), conversation, null, activity.onOpenPGPKeyPublished);\n            return;\n        }\n        if (!mSendingPgpMessage.compareAndSet(false, true)) {\n            Log.d(Config.LOGTAG, \"sending pgp message already in progress\");\n        }\n        if (conversation.getMode() == Conversation.MODE_SINGLE) {\n            if (contact.getPgpKeyId() != 0) {\n                xmppService.getPgpEngine().hasKey(contact,\n                        new UiCallback<Contact>() {\n\n                            @Override\n                            public void userInputRequried(PendingIntent pi, Contact contact) {\n                                startPendingIntent(pi, REQUEST_ENCRYPT_MESSAGE);\n                            }\n\n                            @Override\n                            public void success(Contact contact) {\n                                encryptTextMessage(message);\n                            }\n\n                            @Override\n                            public void error(int error, Contact contact) {\n                                activity.runOnUiThread(() -> Toast.makeText(activity,\n                                        R.string.unable_to_connect_to_keychain,\n                                        Toast.LENGTH_SHORT\n                                ).show());\n                                mSendingPgpMessage.set(false);\n                            }\n                        });\n\n            } else {\n                showNoPGPKeyDialog(false, (dialog, which) -> {\n                    conversation.setNextEncryption(Message.ENCRYPTION_NONE);\n                    xmppService.updateConversation(conversation);\n                    message.setEncryption(Message.ENCRYPTION_NONE);\n                    xmppService.sendMessage(message);\n                    messageSent();\n                });\n            }\n        } else {\n            if (conversation.getMucOptions().pgpKeysInUse()) {\n                if (!conversation.getMucOptions().everybodyHasKeys()) {\n                    Toast warning = Toast\n                            .makeText(getActivity(),\n                                    R.string.missing_public_keys,\n                                    Toast.LENGTH_LONG);\n                    warning.setGravity(Gravity.CENTER_VERTICAL, 0, 0);\n                    warning.show();\n                }\n                encryptTextMessage(message);\n            } else {\n                showNoPGPKeyDialog(true, (dialog, which) -> {\n                    conversation.setNextEncryption(Message.ENCRYPTION_NONE);\n                    message.setEncryption(Message.ENCRYPTION_NONE);\n                    xmppService.updateConversation(conversation);\n                    xmppService.sendMessage(message);\n                    messageSent();\n                });\n            }\n        }\n    }\n\n    public void encryptTextMessage(Message message) {\n        activity.xmppConnectionService.getPgpEngine().encrypt(message,\n                new UiCallback<Message>() {\n\n                    @Override\n                    public void userInputRequried(PendingIntent pi, Message message) {\n                        startPendingIntent(pi, REQUEST_SEND_MESSAGE);\n                    }\n\n                    @Override\n                    public void success(Message message) {\n                        //TODO the following two call can be made before the callback\n                        getActivity().runOnUiThread(() -> messageSent());\n                    }\n\n                    @Override\n                    public void error(final int error, Message message) {\n                        getActivity().runOnUiThread(() -> {\n                            doneSendingPgpMessage();\n                            Toast.makeText(getActivity(), R.string.unable_to_connect_to_keychain, Toast.LENGTH_SHORT).show();\n                        });\n\n                    }\n                });\n    }\n\n    public void showNoPGPKeyDialog(boolean plural, DialogInterface.OnClickListener listener) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setIconAttribute(android.R.attr.alertDialogIcon);\n        if (plural) {\n            builder.setTitle(getString(R.string.no_pgp_keys));\n            builder.setMessage(getText(R.string.contacts_have_no_pgp_keys));\n        } else {\n            builder.setTitle(getString(R.string.no_pgp_key));\n            builder.setMessage(getText(R.string.contact_has_no_pgp_key));\n        }\n        builder.setNegativeButton(getString(R.string.cancel), null);\n        builder.setPositiveButton(getString(R.string.send_unencrypted), listener);\n        builder.create().show();\n    }\n\n    public void appendText(String text) {\n        if (text == null) {\n            return;\n        }\n        String previous = this.binding.textinput.getText().toString();\n        if (UIHelper.isLastLineQuote(previous)) {\n            text = '\\n' + text;\n        } else if (previous.length() != 0 && !Character.isWhitespace(previous.charAt(previous.length() - 1))) {\n            text = \" \" + text;\n        }\n        this.binding.textinput.append(text);\n    }\n\n    @Override\n    public boolean onEnterPressed() {\n        SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(getActivity());\n        final boolean enterIsSend = p.getBoolean(\"enter_is_send\", getResources().getBoolean(R.bool.enter_is_send));\n        if (enterIsSend) {\n            sendMessage();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public void onTypingStarted() {\n        final XmppConnectionService service = activity == null ? null : activity.xmppConnectionService;\n        if (service == null) {\n            return;\n        }\n        Account.State status = conversation.getAccount().getStatus();\n        if (status == Account.State.ONLINE && conversation.setOutgoingChatState(ChatState.COMPOSING)) {\n            service.sendChatState(conversation);\n        }\n        updateSendButton();\n    }\n\n    @Override\n    public void onTypingStopped() {\n        final XmppConnectionService service = activity == null ? null : activity.xmppConnectionService;\n        if (service == null) {\n            return;\n        }\n        Account.State status = conversation.getAccount().getStatus();\n        if (status == Account.State.ONLINE && conversation.setOutgoingChatState(ChatState.PAUSED)) {\n            service.sendChatState(conversation);\n        }\n    }\n\n    @Override\n    public void onTextDeleted() {\n        final XmppConnectionService service = activity == null ? null : activity.xmppConnectionService;\n        if (service == null) {\n            return;\n        }\n        Account.State status = conversation.getAccount().getStatus();\n        if (status == Account.State.ONLINE && conversation.setOutgoingChatState(Config.DEFAULT_CHATSTATE)) {\n            service.sendChatState(conversation);\n        }\n        if (storeNextMessage()) {\n            activity.onConversationsListItemUpdated();\n        }\n        updateSendButton();\n    }\n\n    @Override\n    public void onTextChanged() {\n        if (conversation != null && conversation.getCorrectingMessage() != null) {\n            updateSendButton();\n        }\n    }\n\n    @Override\n    public boolean onTabPressed(boolean repeated) {\n        if (conversation == null || conversation.getMode() == Conversation.MODE_SINGLE) {\n            return false;\n        }\n        if (repeated) {\n            completionIndex++;\n        } else {\n            lastCompletionLength = 0;\n            completionIndex = 0;\n            final String content = this.binding.textinput.getText().toString();\n            lastCompletionCursor = this.binding.textinput.getSelectionEnd();\n            int start = lastCompletionCursor > 0 ? content.lastIndexOf(\" \", lastCompletionCursor - 1) + 1 : 0;\n            firstWord = start == 0;\n            incomplete = content.substring(start, lastCompletionCursor);\n        }\n        List<String> completions = new ArrayList<>();\n        for (MucOptions.User user : conversation.getMucOptions().getUsers()) {\n            String name = user.getName();\n            if (name != null && name.startsWith(incomplete)) {\n                completions.add(name + (firstWord ? \": \" : \" \"));\n            }\n        }\n        Collections.sort(completions);\n        if (completions.size() > completionIndex) {\n            String completion = completions.get(completionIndex).substring(incomplete.length());\n            this.binding.textinput.getEditableText().delete(lastCompletionCursor, lastCompletionCursor + lastCompletionLength);\n            this.binding.textinput.getEditableText().insert(lastCompletionCursor, completion);\n            lastCompletionLength = completion.length();\n        } else {\n            completionIndex = -1;\n            this.binding.textinput.getEditableText().delete(lastCompletionCursor, lastCompletionCursor + lastCompletionLength);\n            lastCompletionLength = 0;\n        }\n        return true;\n    }\n\n    private void startPendingIntent(PendingIntent pendingIntent, int requestCode) {\n        try {\n            getActivity().startIntentSenderForResult(pendingIntent.getIntentSender(), requestCode, null, 0, 0, 0);\n        } catch (final SendIntentException ignored) {\n        }\n    }\n\n    @Override\n    public void onBackendConnected() {\n        Log.d(Config.LOGTAG, \"ConversationFragment.onBackendConnected()\");\n        String uuid = pendingConversationsUuid.pop();\n        if (uuid != null) {\n            if (!findAndReInitByUuidOrArchive(uuid)) {\n                return;\n            }\n        } else {\n            if (!activity.xmppConnectionService.isConversationStillOpen(conversation)) {\n                clearPending();\n                activity.onConversationArchived(conversation);\n                return;\n            }\n        }\n        ActivityResult activityResult = postponedActivityResult.pop();\n        if (activityResult != null) {\n            handleActivityResult(activityResult);\n        }\n        clearPending();\n    }\n\n    private boolean findAndReInitByUuidOrArchive(@NonNull final String uuid) {\n        Conversation conversation = activity.xmppConnectionService.findConversationByUuid(uuid);\n        if (conversation == null) {\n            clearPending();\n            activity.onConversationArchived(null);\n            return false;\n        }\n        reInit(conversation);\n        ScrollState scrollState = pendingScrollState.pop();\n        String lastMessageUuid = pendingLastMessageUuid.pop();\n        List<Attachment> attachments = pendingMediaPreviews.pop();\n        if (scrollState != null) {\n            setScrollPosition(scrollState, lastMessageUuid);\n        }\n        if (attachments != null && attachments.size() > 0) {\n            Log.d(Config.LOGTAG, \"had attachments on restore\");\n            mediaPreviewAdapter.addMediaPreviews(attachments);\n            toggleInputMethod();\n        }\n        return true;\n    }\n\n    private void clearPending() {\n        if (postponedActivityResult.clear()) {\n            Log.e(Config.LOGTAG, \"cleared pending intent with unhandled result left\");\n        }\n        if (pendingScrollState.clear()) {\n            Log.e(Config.LOGTAG, \"cleared scroll state\");\n        }\n        if (pendingTakePhotoUri.clear()) {\n            Log.e(Config.LOGTAG, \"cleared pending photo uri\");\n        }\n    }\n\n    public Conversation getConversation() {\n        return conversation;\n    }\n}", "/*\n * Copyright (c) 2018, Daniel Gultsch All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation and/or\n * other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors\n * may be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage eu.siacs.conversations.ui;\n\n\nimport android.annotation.SuppressLint;\nimport android.app.Activity;\nimport android.app.Fragment;\nimport android.app.FragmentManager;\nimport android.app.FragmentTransaction;\nimport android.content.ActivityNotFoundException;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.databinding.DataBindingUtil;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.support.annotation.IdRes;\nimport android.support.annotation.NonNull;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AlertDialog;\nimport android.support.v7.widget.Toolbar;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.widget.Toast;\n\nimport org.openintents.openpgp.util.OpenPgpApi;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport eu.siacs.conversations.Config;\nimport eu.siacs.conversations.R;\nimport eu.siacs.conversations.crypto.OmemoSetting;\nimport eu.siacs.conversations.databinding.ActivityConversationsBinding;\nimport eu.siacs.conversations.entities.Account;\nimport eu.siacs.conversations.entities.Conversation;\nimport eu.siacs.conversations.services.XmppConnectionService;\nimport eu.siacs.conversations.ui.interfaces.OnBackendConnected;\nimport eu.siacs.conversations.ui.interfaces.OnConversationArchived;\nimport eu.siacs.conversations.ui.interfaces.OnConversationRead;\nimport eu.siacs.conversations.ui.interfaces.OnConversationSelected;\nimport eu.siacs.conversations.ui.interfaces.OnConversationsListItemUpdated;\nimport eu.siacs.conversations.ui.service.EmojiService;\nimport eu.siacs.conversations.ui.util.ActivityResult;\nimport eu.siacs.conversations.ui.util.ConversationMenuConfigurator;\nimport eu.siacs.conversations.ui.util.MenuDoubleTabUtil;\nimport eu.siacs.conversations.ui.util.PendingItem;\nimport eu.siacs.conversations.utils.EmojiWrapper;\nimport eu.siacs.conversations.utils.ExceptionHelper;\nimport eu.siacs.conversations.utils.XmppUri;\nimport eu.siacs.conversations.xmpp.OnUpdateBlocklist;\nimport rocks.xmpp.addr.Jid;\n\nimport static eu.siacs.conversations.ui.ConversationFragment.REQUEST_DECRYPT_PGP;\n\npublic class ConversationsActivity extends XmppActivity implements OnConversationSelected, OnConversationArchived, OnConversationsListItemUpdated, OnConversationRead, XmppConnectionService.OnAccountUpdate, XmppConnectionService.OnConversationUpdate, XmppConnectionService.OnRosterUpdate, OnUpdateBlocklist, XmppConnectionService.OnShowErrorToast, XmppConnectionService.OnAffiliationChanged, XmppConnectionService.OnRoleChanged {\n\n    public static final String ACTION_VIEW_CONVERSATION = \"eu.siacs.conversations.action.VIEW\";\n    public static final String EXTRA_CONVERSATION = \"conversationUuid\";\n    public static final String EXTRA_DOWNLOAD_UUID = \"eu.siacs.conversations.download_uuid\";\n    public static final String EXTRA_AS_QUOTE = \"as_quote\";\n    public static final String EXTRA_NICK = \"nick\";\n    public static final String EXTRA_IS_PRIVATE_MESSAGE = \"pm\";\n\n    private static List<String> VIEW_AND_SHARE_ACTIONS = Arrays.asList(\n            ACTION_VIEW_CONVERSATION,\n            Intent.ACTION_SEND,\n            Intent.ACTION_SEND_MULTIPLE\n    );\n\n    public static final int REQUEST_OPEN_MESSAGE = 0x9876;\n    public static final int REQUEST_PLAY_PAUSE = 0x5432;\n\n\n    //secondary fragment (when holding the conversation, must be initialized before refreshing the overview fragment\n    private static final @IdRes\n    int[] FRAGMENT_ID_NOTIFICATION_ORDER = {R.id.secondary_fragment, R.id.main_fragment};\n    private final PendingItem<Intent> pendingViewIntent = new PendingItem<>();\n    private final PendingItem<ActivityResult> postponedActivityResult = new PendingItem<>();\n    private ActivityConversationsBinding binding;\n    private boolean mActivityPaused = true;\n    private AtomicBoolean mRedirectInProcess = new AtomicBoolean(false);\n\n    private static boolean isViewOrShareIntent(Intent i) {\n        Log.d(Config.LOGTAG, \"action: \" + (i == null ? null : i.getAction()));\n        return i != null && VIEW_AND_SHARE_ACTIONS.contains(i.getAction()) && i.hasExtra(EXTRA_CONVERSATION);\n    }\n\n    private static Intent createLauncherIntent(Context context) {\n        final Intent intent = new Intent(context, ConversationsActivity.class);\n        intent.setAction(Intent.ACTION_MAIN);\n        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n        return intent;\n    }\n\n    @Override\n    protected void refreshUiReal() {\n        for (@IdRes int id : FRAGMENT_ID_NOTIFICATION_ORDER) {\n            refreshFragment(id);\n        }\n    }\n\n    @Override\n    void onBackendConnected() {\n        if (performRedirectIfNecessary(true)) {\n            return;\n        }\n        xmppConnectionService.getNotificationService().setIsInForeground(true);\n        Intent intent = pendingViewIntent.pop();\n        if (intent != null) {\n            if (processViewIntent(intent)) {\n                if (binding.secondaryFragment != null) {\n                    notifyFragmentOfBackendConnected(R.id.main_fragment);\n                }\n                invalidateActionBarTitle();\n                return;\n            }\n        }\n        for (@IdRes int id : FRAGMENT_ID_NOTIFICATION_ORDER) {\n            notifyFragmentOfBackendConnected(id);\n        }\n\n        ActivityResult activityResult = postponedActivityResult.pop();\n        if (activityResult != null) {\n            handleActivityResult(activityResult);\n        }\n\n        invalidateActionBarTitle();\n        if (binding.secondaryFragment != null && ConversationFragment.getConversation(this) == null) {\n            Conversation conversation = ConversationsOverviewFragment.getSuggestion(this);\n            if (conversation != null) {\n                openConversation(conversation, null);\n            }\n        }\n        showDialogsIfMainIsOverview();\n    }\n\n    private boolean performRedirectIfNecessary(boolean noAnimation) {\n        return performRedirectIfNecessary(null, noAnimation);\n    }\n\n    private boolean performRedirectIfNecessary(final Conversation ignore, final boolean noAnimation) {\n        if (xmppConnectionService == null) {\n            return false;\n        }\n        boolean isConversationsListEmpty = xmppConnectionService.isConversationsListEmpty(ignore);\n        if (isConversationsListEmpty && mRedirectInProcess.compareAndSet(false, true)) {\n            final Intent intent = getRedirectionIntent(noAnimation);\n            runOnUiThread(() -> {\n                startActivity(intent);\n                if (noAnimation) {\n                    overridePendingTransition(0, 0);\n                }\n            });\n        }\n        return mRedirectInProcess.get();\n    }\n\n    private Intent getRedirectionIntent(boolean noAnimation) {\n        Account pendingAccount = xmppConnectionService.getPendingAccount();\n        Intent intent;\n        if (pendingAccount != null) {\n            intent = new Intent(this, EditAccountActivity.class);\n            intent.putExtra(\"jid\", pendingAccount.getJid().asBareJid().toString());\n        } else {\n            if (xmppConnectionService.getAccounts().size() == 0) {\n                if (Config.X509_VERIFICATION) {\n                    intent = new Intent(this, ManageAccountActivity.class);\n                } else if (Config.MAGIC_CREATE_DOMAIN != null) {\n                    intent = new Intent(this, WelcomeActivity.class);\n                    WelcomeActivity.addInviteUri(intent, getIntent());\n                } else {\n                    intent = new Intent(this, EditAccountActivity.class);\n                }\n            } else {\n                intent = new Intent(this, StartConversationActivity.class);\n            }\n        }\n        intent.putExtra(\"init\", true);\n        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n        if (noAnimation) {\n            intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\n        }\n        return intent;\n    }\n\n    private void showDialogsIfMainIsOverview() {\n        if (xmppConnectionService == null) {\n            return;\n        }\n        final Fragment fragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n        if (fragment != null && fragment instanceof ConversationsOverviewFragment) {\n            if (ExceptionHelper.checkForCrash(this)) {\n                return;\n            }\n            openBatteryOptimizationDialogIfNeeded();\n        }\n    }\n\n    private String getBatteryOptimizationPreferenceKey() {\n        @SuppressLint(\"HardwareIds\") String device = Settings.Secure.getString(getContentResolver(), Settings.Secure.ANDROID_ID);\n        return \"show_battery_optimization\" + (device == null ? \"\" : device);\n    }\n\n    private void setNeverAskForBatteryOptimizationsAgain() {\n        getPreferences().edit().putBoolean(getBatteryOptimizationPreferenceKey(), false).apply();\n    }\n\n    private void openBatteryOptimizationDialogIfNeeded() {\n        if (hasAccountWithoutPush()\n                && isOptimizingBattery()\n                && getPreferences().getBoolean(getBatteryOptimizationPreferenceKey(), true)) {\n            AlertDialog.Builder builder = new AlertDialog.Builder(this);\n            builder.setTitle(R.string.battery_optimizations_enabled);\n            builder.setMessage(R.string.battery_optimizations_enabled_dialog);\n            builder.setPositiveButton(R.string.next, (dialog, which) -> {\n                Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);\n                Uri uri = Uri.parse(\"package:\" + getPackageName());\n                intent.setData(uri);\n                try {\n                    startActivityForResult(intent, REQUEST_BATTERY_OP);\n                } catch (ActivityNotFoundException e) {\n                    Toast.makeText(this, R.string.device_does_not_support_battery_op, Toast.LENGTH_SHORT).show();\n                }\n            });\n            builder.setOnDismissListener(dialog -> setNeverAskForBatteryOptimizationsAgain());\n            final AlertDialog dialog = builder.create();\n            dialog.setCanceledOnTouchOutside(false);\n            dialog.show();\n        }\n    }\n\n    private boolean hasAccountWithoutPush() {\n        for (Account account : xmppConnectionService.getAccounts()) {\n            if (account.getStatus() == Account.State.ONLINE && !xmppConnectionService.getPushManagementService().available(account)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void notifyFragmentOfBackendConnected(@IdRes int id) {\n        final Fragment fragment = getFragmentManager().findFragmentById(id);\n        if (fragment != null && fragment instanceof OnBackendConnected) {\n            ((OnBackendConnected) fragment).onBackendConnected();\n        }\n    }\n\n    private void refreshFragment(@IdRes int id) {\n        final Fragment fragment = getFragmentManager().findFragmentById(id);\n        if (fragment != null && fragment instanceof XmppFragment) {\n            ((XmppFragment) fragment).refresh();\n        }\n    }\n\n    private boolean processViewIntent(Intent intent) {\n        String uuid = intent.getStringExtra(EXTRA_CONVERSATION);\n        Conversation conversation = uuid != null ? xmppConnectionService.findConversationByUuid(uuid) : null;\n        if (conversation == null) {\n            Log.d(Config.LOGTAG, \"unable to view conversation with uuid:\" + uuid);\n            return false;\n        }\n        openConversation(conversation, intent.getExtras());\n        return true;\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String permissions[], @NonNull int[] grantResults) {\n        UriHandlerActivity.onRequestPermissionResult(this, requestCode, grantResults);\n        if (grantResults.length > 0) {\n            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                switch (requestCode) {\n                    case REQUEST_OPEN_MESSAGE:\n                        refreshUiReal();\n                        ConversationFragment.openPendingMessage(this);\n                        break;\n                    case REQUEST_PLAY_PAUSE:\n                        ConversationFragment.startStopPending(this);\n                        break;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, final Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        ActivityResult activityResult = ActivityResult.of(requestCode, resultCode, data);\n        if (xmppConnectionService != null) {\n            handleActivityResult(activityResult);\n        } else {\n            this.postponedActivityResult.push(activityResult);\n        }\n    }\n\n    private void handleActivityResult(ActivityResult activityResult) {\n        if (activityResult.resultCode == Activity.RESULT_OK) {\n            handlePositiveActivityResult(activityResult.requestCode, activityResult.data);\n        } else {\n            handleNegativeActivityResult(activityResult.requestCode);\n        }\n    }\n\n    private void handleNegativeActivityResult(int requestCode) {\n        Conversation conversation = ConversationFragment.getConversationReliable(this);\n        switch (requestCode) {\n            case REQUEST_DECRYPT_PGP:\n                if (conversation == null) {\n                    break;\n                }\n                conversation.getAccount().getPgpDecryptionService().giveUpCurrentDecryption();\n                break;\n            case REQUEST_BATTERY_OP:\n                setNeverAskForBatteryOptimizationsAgain();\n                break;\n        }\n    }\n\n    private void handlePositiveActivityResult(int requestCode, final Intent data) {\n        Conversation conversation = ConversationFragment.getConversationReliable(this);\n        if (conversation == null) {\n            Log.d(Config.LOGTAG, \"conversation not found\");\n            return;\n        }\n        switch (requestCode) {\n            case REQUEST_DECRYPT_PGP:\n                conversation.getAccount().getPgpDecryptionService().continueDecryption(data);\n                break;\n            case REQUEST_CHOOSE_PGP_ID:\n                long id = data.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID, 0);\n                if (id != 0) {\n                    conversation.getAccount().setPgpSignId(id);\n                    announcePgp(conversation.getAccount(), null, null, onOpenPGPKeyPublished);\n                } else {\n                    choosePgpSignId(conversation.getAccount());\n                }\n                break;\n            case REQUEST_ANNOUNCE_PGP:\n                announcePgp(conversation.getAccount(), conversation, data, onOpenPGPKeyPublished);\n                break;\n        }\n    }\n\n    @Override\n    protected void onCreate(final Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ConversationMenuConfigurator.reloadFeatures(this);\n        OmemoSetting.load(this);\n        new EmojiService(this).init();\n        this.binding = DataBindingUtil.setContentView(this, R.layout.activity_conversations);\n        setSupportActionBar((Toolbar) binding.toolbar);\n        configureActionBar(getSupportActionBar());\n        this.getFragmentManager().addOnBackStackChangedListener(this::invalidateActionBarTitle);\n        this.getFragmentManager().addOnBackStackChangedListener(this::showDialogsIfMainIsOverview);\n        this.initializeFragments();\n        this.invalidateActionBarTitle();\n        final Intent intent;\n        if (savedInstanceState == null) {\n            intent = getIntent();\n        } else {\n            intent = savedInstanceState.getParcelable(\"intent\");\n        }\n        if (isViewOrShareIntent(intent)) {\n            pendingViewIntent.push(intent);\n            setIntent(createLauncherIntent(this));\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.activity_conversations, menu);\n        MenuItem qrCodeScanMenuItem = menu.findItem(R.id.action_scan_qr_code);\n        if (qrCodeScanMenuItem != null) {\n            if (isCameraFeatureAvailable()) {\n                Fragment fragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n                boolean visible = getResources().getBoolean(R.bool.show_qr_code_scan)\n                        && fragment != null\n                        && fragment instanceof ConversationsOverviewFragment;\n                qrCodeScanMenuItem.setVisible(visible);\n            } else {\n                qrCodeScanMenuItem.setVisible(false);\n            }\n        }\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public void onConversationSelected(Conversation conversation) {\n        clearPendingViewIntent();\n        if (ConversationFragment.getConversation(this) == conversation) {\n            Log.d(Config.LOGTAG, \"ignore onConversationSelected() because conversation is already open\");\n            return;\n        }\n        openConversation(conversation, null);\n    }\n\n    public void clearPendingViewIntent() {\n        if (pendingViewIntent.clear()) {\n            Log.e(Config.LOGTAG, \"cleared pending view intent\");\n        }\n    }\n\n    private void displayToast(final String msg) {\n        runOnUiThread(() -> Toast.makeText(ConversationsActivity.this, msg, Toast.LENGTH_SHORT).show());\n    }\n\n    @Override\n    public void onAffiliationChangedSuccessful(Jid jid) {\n\n    }\n\n    @Override\n    public void onAffiliationChangeFailed(Jid jid, int resId) {\n        displayToast(getString(resId, jid.asBareJid().toString()));\n    }\n\n    @Override\n    public void onRoleChangedSuccessful(String nick) {\n\n    }\n\n    @Override\n    public void onRoleChangeFailed(String nick, int resId) {\n        displayToast(getString(resId, nick));\n    }\n\n    private void openConversation(Conversation conversation, Bundle extras) {\n        ConversationFragment conversationFragment = (ConversationFragment) getFragmentManager().findFragmentById(R.id.secondary_fragment);\n        final boolean mainNeedsRefresh;\n        if (conversationFragment == null) {\n            mainNeedsRefresh = false;\n            Fragment mainFragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n            if (mainFragment != null && mainFragment instanceof ConversationFragment) {\n                conversationFragment = (ConversationFragment) mainFragment;\n            } else {\n                conversationFragment = new ConversationFragment();\n                FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();\n                fragmentTransaction.replace(R.id.main_fragment, conversationFragment);\n                fragmentTransaction.addToBackStack(null);\n                try {\n                    fragmentTransaction.commit();\n                } catch (IllegalStateException e) {\n                    Log.w(Config.LOGTAG, \"sate loss while opening conversation\", e);\n                    //allowing state loss is probably fine since view intents et all are already stored and a click can probably be 'ignored'\n                    return;\n                }\n            }\n        } else {\n            mainNeedsRefresh = true;\n        }\n        conversationFragment.reInit(conversation, extras == null ? new Bundle() : extras);\n        if (mainNeedsRefresh) {\n            refreshFragment(R.id.main_fragment);\n        } else {\n            invalidateActionBarTitle();\n        }\n    }\n\n    public boolean onXmppUriClicked(Uri uri) {\n        XmppUri xmppUri = new XmppUri(uri);\n        if (xmppUri.isJidValid() && !xmppUri.hasFingerprints()) {\n            final Conversation conversation = xmppConnectionService.findUniqueConversationByJid(xmppUri);\n            if (conversation != null) {\n                openConversation(conversation, null);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (MenuDoubleTabUtil.shouldIgnoreTap()) {\n            return false;\n        }\n        switch (item.getItemId()) {\n            case android.R.id.home:\n                FragmentManager fm = getFragmentManager();\n                if (fm.getBackStackEntryCount() > 0) {\n                    try {\n                        fm.popBackStack();\n                    } catch (IllegalStateException e) {\n                        Log.w(Config.LOGTAG, \"Unable to pop back stack after pressing home button\");\n                    }\n                    return true;\n                }\n                break;\n            case R.id.action_scan_qr_code:\n                UriHandlerActivity.scan(this);\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle savedInstanceState) {\n        Intent pendingIntent = pendingViewIntent.peek();\n        savedInstanceState.putParcelable(\"intent\", pendingIntent != null ? pendingIntent : getIntent());\n        super.onSaveInstanceState(savedInstanceState);\n    }\n\n    @Override\n    protected void onStart() {\n        final int theme = findTheme();\n        if (this.mTheme != theme) {\n            this.mSkipBackgroundBinding = true;\n            recreate();\n        } else {\n            this.mSkipBackgroundBinding = false;\n        }\n        mRedirectInProcess.set(false);\n        super.onStart();\n    }\n\n    @Override\n    protected void onNewIntent(final Intent intent) {\n        if (isViewOrShareIntent(intent)) {\n            if (xmppConnectionService != null) {\n                processViewIntent(intent);\n            } else {\n                pendingViewIntent.push(intent);\n            }\n        }\n        setIntent(createLauncherIntent(this));\n    }\n\n    @Override\n    public void onPause() {\n        this.mActivityPaused = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        this.mActivityPaused = false;\n    }\n\n    private void initializeFragments() {\n        FragmentTransaction transaction = getFragmentManager().beginTransaction();\n        Fragment mainFragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n        Fragment secondaryFragment = getFragmentManager().findFragmentById(R.id.secondary_fragment);\n        if (mainFragment != null) {\n            if (binding.secondaryFragment != null) {\n                if (mainFragment instanceof ConversationFragment) {\n                    getFragmentManager().popBackStack();\n                    transaction.remove(mainFragment);\n                    transaction.commit();\n                    getFragmentManager().executePendingTransactions();\n                    transaction = getFragmentManager().beginTransaction();\n                    transaction.replace(R.id.secondary_fragment, mainFragment);\n                    transaction.replace(R.id.main_fragment, new ConversationsOverviewFragment());\n                    transaction.commit();\n                    return;\n                }\n            } else {\n                if (secondaryFragment != null && secondaryFragment instanceof ConversationFragment) {\n                    transaction.remove(secondaryFragment);\n                    transaction.commit();\n                    getFragmentManager().executePendingTransactions();\n                    transaction = getFragmentManager().beginTransaction();\n                    transaction.replace(R.id.main_fragment, secondaryFragment);\n                    transaction.addToBackStack(null);\n                    transaction.commit();\n                    return;\n                }\n            }\n        } else {\n            transaction.replace(R.id.main_fragment, new ConversationsOverviewFragment());\n        }\n        if (binding.secondaryFragment != null && secondaryFragment == null) {\n            transaction.replace(R.id.secondary_fragment, new ConversationFragment());\n        }\n        transaction.commit();\n    }\n\n    private void invalidateActionBarTitle() {\n        final ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            Fragment mainFragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n            if (mainFragment != null && mainFragment instanceof ConversationFragment) {\n                final Conversation conversation = ((ConversationFragment) mainFragment).getConversation();\n                if (conversation != null) {\n                    actionBar.setTitle(EmojiWrapper.transform(conversation.getName()));\n                    actionBar.setDisplayHomeAsUpEnabled(true);\n                    return;\n                }\n            }\n            actionBar.setTitle(R.string.app_name);\n            actionBar.setDisplayHomeAsUpEnabled(false);\n        }\n    }\n\n    @Override\n    public void onConversationArchived(Conversation conversation) {\n        if (performRedirectIfNecessary(conversation, false)) {\n            return;\n        }\n        Fragment mainFragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n        if (mainFragment != null && mainFragment instanceof ConversationFragment) {\n            try {\n                getFragmentManager().popBackStack();\n            } catch (IllegalStateException e) {\n                Log.w(Config.LOGTAG, \"state loss while popping back state after archiving conversation\", e);\n                //this usually means activity is no longer active; meaning on the next open we will run through this again\n            }\n            return;\n        }\n        Fragment secondaryFragment = getFragmentManager().findFragmentById(R.id.secondary_fragment);\n        if (secondaryFragment != null && secondaryFragment instanceof ConversationFragment) {\n            if (((ConversationFragment) secondaryFragment).getConversation() == conversation) {\n                Conversation suggestion = ConversationsOverviewFragment.getSuggestion(this, conversation);\n                if (suggestion != null) {\n                    openConversation(suggestion, null);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onConversationsListItemUpdated() {\n        Fragment fragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n        if (fragment != null && fragment instanceof ConversationsOverviewFragment) {\n            ((ConversationsOverviewFragment) fragment).refresh();\n        }\n    }\n\n    @Override\n    public void switchToConversation(Conversation conversation) {\n        Log.d(Config.LOGTAG, \"override\");\n        openConversation(conversation, null);\n    }\n\n    @Override\n    public void onConversationRead(Conversation conversation, String upToUuid) {\n        if (!mActivityPaused && pendingViewIntent.peek() == null) {\n            xmppConnectionService.sendReadMarker(conversation, upToUuid);\n        } else {\n            Log.d(Config.LOGTAG, \"ignoring read callback. mActivityPaused=\" + Boolean.toString(mActivityPaused));\n        }\n    }\n\n    @Override\n    public void onAccountUpdate() {\n        this.refreshUi();\n    }\n\n    @Override\n    public void onConversationUpdate() {\n        if (performRedirectIfNecessary(false)) {\n            return;\n        }\n        this.refreshUi();\n    }\n\n    @Override\n    public void onRosterUpdate() {\n        this.refreshUi();\n    }\n\n    @Override\n    public void OnUpdateBlocklist(OnUpdateBlocklist.Status status) {\n        this.refreshUi();\n    }\n\n    @Override\n    public void onShowErrorToast(int resId) {\n        runOnUiThread(() -> Toast.makeText(this, resId, Toast.LENGTH_SHORT).show());\n    }\n}\n", "package eu.siacs.conversations.ui;\n\nimport android.Manifest;\nimport android.annotation.SuppressLint;\nimport android.app.Dialog;\nimport android.app.PendingIntent;\nimport android.content.ActivityNotFoundException;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.databinding.DataBindingUtil;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.support.annotation.DrawableRes;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.support.v4.app.Fragment;\nimport android.support.v4.app.FragmentManager;\nimport android.support.v4.app.FragmentTransaction;\nimport android.support.v4.app.ListFragment;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AlertDialog;\nimport android.support.v7.widget.Toolbar;\nimport android.text.Editable;\nimport android.text.SpannableString;\nimport android.text.Spanned;\nimport android.text.TextWatcher;\nimport android.text.style.TypefaceSpan;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.view.ContextMenu;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\nimport android.widget.ArrayAdapter;\nimport android.widget.AutoCompleteTextView;\nimport android.widget.CheckBox;\nimport android.widget.EditText;\nimport android.widget.ListView;\nimport android.widget.Spinner;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport eu.siacs.conversations.Config;\nimport eu.siacs.conversations.R;\nimport eu.siacs.conversations.databinding.ActivityStartConversationBinding;\nimport eu.siacs.conversations.entities.Account;\nimport eu.siacs.conversations.entities.Bookmark;\nimport eu.siacs.conversations.entities.Contact;\nimport eu.siacs.conversations.entities.Conversation;\nimport eu.siacs.conversations.entities.ListItem;\nimport eu.siacs.conversations.entities.Presence;\nimport eu.siacs.conversations.services.XmppConnectionService;\nimport eu.siacs.conversations.services.XmppConnectionService.OnRosterUpdate;\nimport eu.siacs.conversations.ui.adapter.ListItemAdapter;\nimport eu.siacs.conversations.ui.interfaces.OnBackendConnected;\nimport eu.siacs.conversations.ui.service.EmojiService;\nimport eu.siacs.conversations.ui.util.JidDialog;\nimport eu.siacs.conversations.ui.util.MenuDoubleTabUtil;\nimport eu.siacs.conversations.ui.util.PendingItem;\nimport eu.siacs.conversations.ui.util.SoftKeyboardUtils;\nimport eu.siacs.conversations.utils.XmppUri;\nimport eu.siacs.conversations.xmpp.OnUpdateBlocklist;\nimport eu.siacs.conversations.xmpp.XmppConnection;\nimport rocks.xmpp.addr.Jid;\n\npublic class StartConversationActivity extends XmppActivity implements XmppConnectionService.OnConversationUpdate, OnRosterUpdate, OnUpdateBlocklist, CreateConferenceDialog.CreateConferenceDialogListener, JoinConferenceDialog.JoinConferenceDialogListener {\n\n\tprivate final int REQUEST_SYNC_CONTACTS = 0x28cf;\n\tprivate final int REQUEST_CREATE_CONFERENCE = 0x39da;\n\tprivate final PendingItem<Intent> pendingViewIntent = new PendingItem<>();\n\tprivate final PendingItem<String> mInitialSearchValue = new PendingItem<>();\n\tprivate final AtomicBoolean oneShotKeyboardSuppress = new AtomicBoolean();\n\tpublic int conference_context_id;\n\tpublic int contact_context_id;\n\tprivate ListPagerAdapter mListPagerAdapter;\n\tprivate List<ListItem> contacts = new ArrayList<>();\n\tprivate ListItemAdapter mContactsAdapter;\n\tprivate List<ListItem> conferences = new ArrayList<>();\n\tprivate ListItemAdapter mConferenceAdapter;\n\tprivate List<String> mActivatedAccounts = new ArrayList<>();\n\tprivate EditText mSearchEditText;\n\tprivate AtomicBoolean mRequestedContactsPermission = new AtomicBoolean(false);\n\tprivate boolean mHideOfflineContacts = false;\n\tprivate MenuItem.OnActionExpandListener mOnActionExpandListener = new MenuItem.OnActionExpandListener() {\n\n\t\t@Override\n\t\tpublic boolean onMenuItemActionExpand(MenuItem item) {\n\t\t\tmSearchEditText.post(() -> {\n\t\t\t\tupdateSearchViewHint();\n\t\t\t\tmSearchEditText.requestFocus();\n\t\t\t\tif (oneShotKeyboardSuppress.compareAndSet(true, false)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tInputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\t\t\t\tif (imm != null) {\n\t\t\t\t\timm.showSoftInput(mSearchEditText, InputMethodManager.SHOW_IMPLICIT);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onMenuItemActionCollapse(MenuItem item) {\n\t\t\tSoftKeyboardUtils.hideSoftKeyboard(StartConversationActivity.this);\n\t\t\tmSearchEditText.setText(\"\");\n\t\t\tfilter(null);\n\t\t\treturn true;\n\t\t}\n\t};\n\tprivate TextWatcher mSearchTextWatcher = new TextWatcher() {\n\n\t\t@Override\n\t\tpublic void afterTextChanged(Editable editable) {\n\t\t\tfilter(editable.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {\n\t\t}\n\t};\n\tprivate MenuItem mMenuSearchView;\n\tprivate ListItemAdapter.OnTagClickedListener mOnTagClickedListener = new ListItemAdapter.OnTagClickedListener() {\n\t\t@Override\n\t\tpublic void onTagClicked(String tag) {\n\t\t\tif (mMenuSearchView != null) {\n\t\t\t\tmMenuSearchView.expandActionView();\n\t\t\t\tmSearchEditText.setText(\"\");\n\t\t\t\tmSearchEditText.append(tag);\n\t\t\t\tfilter(tag);\n\t\t\t}\n\t\t}\n\t};\n\tprivate Pair<Integer, Intent> mPostponedActivityResult;\n\tprivate Toast mToast;\n\tprivate UiCallback<Conversation> mAdhocConferenceCallback = new UiCallback<Conversation>() {\n\t\t@Override\n\t\tpublic void success(final Conversation conversation) {\n\t\t\trunOnUiThread(() -> {\n\t\t\t\thideToast();\n\t\t\t\tswitchToConversation(conversation);\n\t\t\t});\n\t\t}\n\n\t\t@Override\n\t\tpublic void error(final int errorCode, Conversation object) {\n\t\t\trunOnUiThread(() -> replaceToast(getString(errorCode)));\n\t\t}\n\n\t\t@Override\n\t\tpublic void userInputRequried(PendingIntent pi, Conversation object) {\n\n\t\t}\n\t};\n\tprivate ActivityStartConversationBinding binding;\n\tprivate TextView.OnEditorActionListener mSearchDone = new TextView.OnEditorActionListener() {\n\t\t@Override\n\t\tpublic boolean onEditorAction(TextView v, int actionId, KeyEvent event) {\n\t\t\tint pos = binding.startConversationViewPager.getCurrentItem();\n\t\t\tif (pos == 0) {\n\t\t\t\tif (contacts.size() == 1) {\n\t\t\t\t\topenConversationForContact((Contact) contacts.get(0));\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (contacts.size() == 0 && conferences.size() == 1) {\n\t\t\t\t\topenConversationsForBookmark((Bookmark) conferences.get(0));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (conferences.size() == 1) {\n\t\t\t\t\topenConversationsForBookmark((Bookmark) conferences.get(0));\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (conferences.size() == 0 && contacts.size() == 1) {\n\t\t\t\t\topenConversationForContact((Contact) contacts.get(0));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSoftKeyboardUtils.hideSoftKeyboard(StartConversationActivity.this);\n\t\t\tmListPagerAdapter.requestFocus(pos);\n\t\t\treturn true;\n\t\t}\n\t};\n\tprivate ViewPager.SimpleOnPageChangeListener mOnPageChangeListener = new ViewPager.SimpleOnPageChangeListener() {\n\t\t@Override\n\t\tpublic void onPageSelected(int position) {\n\t\t\tonTabChanged();\n\t\t}\n\t};\n\n\tpublic static void populateAccountSpinner(Context context, List<String> accounts, Spinner spinner) {\n\t\tif (accounts.size() > 0) {\n\t\t\tArrayAdapter<String> adapter = new ArrayAdapter<>(context, R.layout.simple_list_item, accounts);\n\t\t\tadapter.setDropDownViewResource(R.layout.simple_list_item);\n\t\t\tspinner.setAdapter(adapter);\n\t\t\tspinner.setEnabled(true);\n\t\t} else {\n\t\t\tArrayAdapter<String> adapter = new ArrayAdapter<>(context,\n\t\t\t\t\tR.layout.simple_list_item,\n\t\t\t\t\tArrays.asList(context.getString(R.string.no_accounts)));\n\t\t\tadapter.setDropDownViewResource(R.layout.simple_list_item);\n\t\t\tspinner.setAdapter(adapter);\n\t\t\tspinner.setEnabled(false);\n\t\t}\n\t}\n\n\tpublic static void launch(Context context) {\n\t\tfinal Intent intent = new Intent(context, StartConversationActivity.class);\n\t\tcontext.startActivity(intent);\n\t}\n\n\tprivate static Intent createLauncherIntent(Context context) {\n\t\tfinal Intent intent = new Intent(context, StartConversationActivity.class);\n\t\tintent.setAction(Intent.ACTION_MAIN);\n\t\tintent.addCategory(Intent.CATEGORY_LAUNCHER);\n\t\treturn intent;\n\t}\n\n\tprivate static boolean isViewIntent(final Intent i) {\n\t\treturn i != null && (Intent.ACTION_VIEW.equals(i.getAction()) || Intent.ACTION_SENDTO.equals(i.getAction()) || i.hasExtra(WelcomeActivity.EXTRA_INVITE_URI));\n\t}\n\n\tprotected void hideToast() {\n\t\tif (mToast != null) {\n\t\t\tmToast.cancel();\n\t\t}\n\t}\n\n\tprotected void replaceToast(String msg) {\n\t\thideToast();\n\t\tmToast = Toast.makeText(this, msg, Toast.LENGTH_LONG);\n\t\tmToast.show();\n\t}\n\n\t@Override\n\tpublic void onRosterUpdate() {\n\t\tthis.refreshUi();\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tnew EmojiService(this).init();\n\t\tthis.binding = DataBindingUtil.setContentView(this, R.layout.activity_start_conversation);\n\t\tToolbar toolbar = (Toolbar) binding.toolbar;\n\t\tsetSupportActionBar(toolbar);\n\t\tconfigureActionBar(getSupportActionBar());\n\t\tthis.binding.fab.setOnClickListener((v) -> {\n\t\t\tif (binding.startConversationViewPager.getCurrentItem() == 0) {\n\t\t\t\tString searchString = mSearchEditText != null ? mSearchEditText.getText().toString() : null;\n\t\t\t\tif (searchString != null && !searchString.trim().isEmpty()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tJid jid = Jid.of(searchString);\n\t\t\t\t\t\tif (jid.getLocal() != null && jid.isBareJid() && jid.getDomain().contains(\".\")) {\n\t\t\t\t\t\t\tshowCreateContactDialog(jid.toString(), null);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IllegalArgumentException ignored) {\n\t\t\t\t\t\t//ignore and fall through\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshowCreateContactDialog(null, null);\n\t\t\t} else {\n\t\t\t\tshowCreateConferenceDialog();\n\t\t\t}\n\t\t});\n\t\tbinding.tabLayout.setupWithViewPager(binding.startConversationViewPager);\n\t\tbinding.startConversationViewPager.addOnPageChangeListener(mOnPageChangeListener);\n\t\tmListPagerAdapter = new ListPagerAdapter(getSupportFragmentManager());\n\t\tbinding.startConversationViewPager.setAdapter(mListPagerAdapter);\n\n\t\tmConferenceAdapter = new ListItemAdapter(this, conferences);\n\t\tmContactsAdapter = new ListItemAdapter(this, contacts);\n\t\tmContactsAdapter.setOnTagClickedListener(this.mOnTagClickedListener);\n\n\t\tfinal SharedPreferences preferences = getPreferences();\n\n\t\tthis.mHideOfflineContacts = preferences.getBoolean(\"hide_offline\", false);\n\n\t\tfinal boolean startSearching = preferences.getBoolean(\"start_searching\",getResources().getBoolean(R.bool.start_searching));\n\n\t\tfinal Intent intent;\n\t\tif (savedInstanceState == null) {\n\t\t\tintent = getIntent();\n\t\t} else {\n\t\t\tfinal String search = savedInstanceState.getString(\"search\");\n\t\t\tif (search != null) {\n\t\t\t\tmInitialSearchValue.push(search);\n\t\t\t}\n\t\t\tintent = savedInstanceState.getParcelable(\"intent\");\n\t\t}\n\n\t\tif (isViewIntent(intent)) {\n\t\t\tpendingViewIntent.push(intent);\n\t\t\tsetIntent(createLauncherIntent(this));\n\t\t} else if (startSearching && mInitialSearchValue.peek() == null) {\n\t\t\tmInitialSearchValue.push(\"\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\tIntent pendingIntent = pendingViewIntent.peek();\n\t\tsavedInstanceState.putParcelable(\"intent\", pendingIntent != null ? pendingIntent : getIntent());\n\t\tif (mMenuSearchView != null && mMenuSearchView.isActionViewExpanded()) {\n\t\t\tsavedInstanceState.putString(\"search\", mSearchEditText != null ? mSearchEditText.getText().toString() : null);\n\t\t}\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\t\tfinal int theme = findTheme();\n\t\tif (this.mTheme != theme) {\n\t\t\trecreate();\n\t\t} else {\n\t\t\tif (pendingViewIntent.peek() == null) {\n\t\t\t\taskForContactsPermissions();\n\t\t\t}\n\t\t}\n\t\tmConferenceAdapter.refreshSettings();\n\t\tmContactsAdapter.refreshSettings();\n\t}\n\n\t@Override\n\tpublic void onNewIntent(final Intent intent) {\n\t\tif (xmppConnectionServiceBound) {\n\t\t\tprocessViewIntent(intent);\n\t\t} else {\n\t\t\tpendingViewIntent.push(intent);\n\t\t}\n\t\tsetIntent(createLauncherIntent(this));\n\t}\n\n\tprotected void openConversationForContact(int position) {\n\t\tContact contact = (Contact) contacts.get(position);\n\t\topenConversationForContact(contact);\n\t}\n\n\tprotected void openConversationForContact(Contact contact) {\n\t\tConversation conversation = xmppConnectionService.findOrCreateConversation(contact.getAccount(), contact.getJid(), false, true);\n\t\tSoftKeyboardUtils.hideSoftKeyboard(this);\n\t\tswitchToConversation(conversation);\n\t}\n\n\tprotected void openConversationForBookmark() {\n\t\topenConversationForBookmark(conference_context_id);\n\t}\n\n\tprotected void openConversationForBookmark(int position) {\n\t\tBookmark bookmark = (Bookmark) conferences.get(position);\n\t\topenConversationsForBookmark(bookmark);\n\t}\n\n\tprotected void shareBookmarkUri() {\n\t\tshareBookmarkUri(conference_context_id);\n\t}\n\n\tprotected void shareBookmarkUri(int position) {\n\t\tBookmark bookmark = (Bookmark) conferences.get(position);\n\t\tIntent shareIntent = new Intent();\n\t\tshareIntent.setAction(Intent.ACTION_SEND);\n\t\tshareIntent.putExtra(Intent.EXTRA_TEXT, \"xmpp:\" + bookmark.getJid().asBareJid().toEscapedString() + \"?join\");\n\t\tshareIntent.setType(\"text/plain\");\n\t\ttry {\n\t\t\tstartActivity(Intent.createChooser(shareIntent, getText(R.string.share_uri_with)));\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\tToast.makeText(this, R.string.no_application_to_share_uri, Toast.LENGTH_SHORT).show();\n\t\t}\n\t}\n\n\tprotected void openConversationsForBookmark(Bookmark bookmark) {\n\t\tJid jid = bookmark.getJid();\n\t\tif (jid == null) {\n\t\t\tToast.makeText(this, R.string.invalid_jid, Toast.LENGTH_SHORT).show();\n\t\t\treturn;\n\t\t}\n\t\tConversation conversation = xmppConnectionService.findOrCreateConversation(bookmark.getAccount(), jid, true, true, true);\n\t\tbookmark.setConversation(conversation);\n\t\tif (!bookmark.autojoin() && getPreferences().getBoolean(\"autojoin\", getResources().getBoolean(R.bool.autojoin))) {\n\t\t\tbookmark.setAutojoin(true);\n\t\t\txmppConnectionService.pushBookmarks(bookmark.getAccount());\n\t\t}\n\t\tSoftKeyboardUtils.hideSoftKeyboard(this);\n\t\tswitchToConversation(conversation);\n\t}\n\n\tprotected void openDetailsForContact() {\n\t\tint position = contact_context_id;\n\t\tContact contact = (Contact) contacts.get(position);\n\t\tswitchToContactDetails(contact);\n\t}\n\n\tprotected void showQrForContact() {\n\t\tint position = contact_context_id;\n\t\tContact contact = (Contact) contacts.get(position);\n\t\tshowQrCode(\"xmpp:\"+contact.getJid().asBareJid().toEscapedString());\n\t}\n\n\tprotected void toggleContactBlock() {\n\t\tfinal int position = contact_context_id;\n\t\tBlockContactDialog.show(this, (Contact) contacts.get(position));\n\t}\n\n\tprotected void deleteContact() {\n\t\tfinal int position = contact_context_id;\n\t\tfinal Contact contact = (Contact) contacts.get(position);\n\t\tfinal AlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setNegativeButton(R.string.cancel, null);\n\t\tbuilder.setTitle(R.string.action_delete_contact);\n\t\tbuilder.setMessage(JidDialog.style(this, R.string.remove_contact_text, contact.getJid().toEscapedString()));\n\t\tbuilder.setPositiveButton(R.string.delete, (dialog, which) -> {\n\t\t\txmppConnectionService.deleteContactOnServer(contact);\n\t\t\tfilter(mSearchEditText.getText().toString());\n\t\t});\n\t\tbuilder.create().show();\n\t}\n\n\tprotected void deleteConference() {\n\t\tint position = conference_context_id;\n\t\tfinal Bookmark bookmark = (Bookmark) conferences.get(position);\n\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setNegativeButton(R.string.cancel, null);\n\t\tbuilder.setTitle(R.string.delete_bookmark);\n\t\tbuilder.setMessage(JidDialog.style(this, R.string.remove_bookmark_text, bookmark.getJid().toEscapedString()));\n\t\tbuilder.setPositiveButton(R.string.delete, (dialog, which) -> {\n\t\t\tbookmark.setConversation(null);\n\t\t\tAccount account = bookmark.getAccount();\n\t\t\taccount.getBookmarks().remove(bookmark);\n\t\t\txmppConnectionService.pushBookmarks(account);\n\t\t\tfilter(mSearchEditText.getText().toString());\n\t\t});\n\t\tbuilder.create().show();\n\n\t}\n\n\t@SuppressLint(\"InflateParams\")\n\tprotected void showCreateContactDialog(final String prefilledJid, final Invite invite) {\n\t\tFragmentTransaction ft = getSupportFragmentManager().beginTransaction();\n\t\tFragment prev = getSupportFragmentManager().findFragmentByTag(FRAGMENT_TAG_DIALOG);\n\t\tif (prev != null) {\n\t\t\tft.remove(prev);\n\t\t}\n\t\tft.addToBackStack(null);\n\t\tEnterJidDialog dialog = EnterJidDialog.newInstance(\n\t\t\t\tmActivatedAccounts,\n\t\t\t\tgetString(R.string.dialog_title_create_contact),\n\t\t\t\tgetString(R.string.create),\n\t\t\t\tprefilledJid,\n\t\t\t\tnull,\n\t\t\t\tinvite == null || !invite.hasFingerprints()\n\t\t);\n\n\t\tdialog.setOnEnterJidDialogPositiveListener((accountJid, contactJid) -> {\n\t\t\tif (!xmppConnectionServiceBound) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfinal Account account = xmppConnectionService.findAccountByJid(accountJid);\n\t\t\tif (account == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfinal Contact contact = account.getRoster().getContact(contactJid);\n\t\t\tif (invite != null && invite.getName() != null) {\n\t\t\t\tcontact.setServerName(invite.getName());\n\t\t\t}\n\t\t\tif (contact.isSelf()) {\n\t\t\t\tswitchToConversation(contact, null);\n\t\t\t\treturn true;\n\t\t\t} else if (contact.showInRoster()) {\n\t\t\t\tthrow new EnterJidDialog.JidError(getString(R.string.contact_already_exists));\n\t\t\t} else {\n\t\t\t\txmppConnectionService.createContact(contact, true);\n\t\t\t\tif (invite != null && invite.hasFingerprints()) {\n\t\t\t\t\txmppConnectionService.verifyFingerprints(contact, invite.getFingerprints());\n\t\t\t\t}\n\t\t\t\tswitchToConversation(contact, invite == null ? null : invite.getBody());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tdialog.show(ft, FRAGMENT_TAG_DIALOG);\n\t}\n\n\t@SuppressLint(\"InflateParams\")\n\tprotected void showJoinConferenceDialog(final String prefilledJid) {\n\t\tFragmentTransaction ft = getSupportFragmentManager().beginTransaction();\n\t\tFragment prev = getSupportFragmentManager().findFragmentByTag(FRAGMENT_TAG_DIALOG);\n\t\tif (prev != null) {\n\t\t\tft.remove(prev);\n\t\t}\n\t\tft.addToBackStack(null);\n\t\tJoinConferenceDialog joinConferenceFragment = JoinConferenceDialog.newInstance(prefilledJid, mActivatedAccounts);\n\t\tjoinConferenceFragment.show(ft, FRAGMENT_TAG_DIALOG);\n\t}\n\n\tprivate void showCreateConferenceDialog() {\n\t\tFragmentTransaction ft = getSupportFragmentManager().beginTransaction();\n\t\tFragment prev = getSupportFragmentManager().findFragmentByTag(FRAGMENT_TAG_DIALOG);\n\t\tif (prev != null) {\n\t\t\tft.remove(prev);\n\t\t}\n\t\tft.addToBackStack(null);\n\t\tCreateConferenceDialog createConferenceFragment = CreateConferenceDialog.newInstance(mActivatedAccounts);\n\t\tcreateConferenceFragment.show(ft, FRAGMENT_TAG_DIALOG);\n\t}\n\n\tprivate Account getSelectedAccount(Spinner spinner) {\n\t\tif (!spinner.isEnabled()) {\n\t\t\treturn null;\n\t\t}\n\t\tJid jid;\n\t\ttry {\n\t\t\tif (Config.DOMAIN_LOCK != null) {\n\t\t\t\tjid = Jid.of((String) spinner.getSelectedItem(), Config.DOMAIN_LOCK, null);\n\t\t\t} else {\n\t\t\t\tjid = Jid.of((String) spinner.getSelectedItem());\n\t\t\t}\n\t\t} catch (final IllegalArgumentException e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn xmppConnectionService.findAccountByJid(jid);\n\t}\n\n\tprotected void switchToConversation(Contact contact, String body) {\n\t\tConversation conversation = xmppConnectionService\n\t\t\t\t.findOrCreateConversation(contact.getAccount(),\n\t\t\t\t\t\tcontact.getJid(), false, true);\n\t\tswitchToConversation(conversation, body);\n\t}\n\n\t@Override\n\tpublic void invalidateOptionsMenu() {\n\t\tboolean isExpanded = mMenuSearchView != null && mMenuSearchView.isActionViewExpanded();\n\t\tString text = mSearchEditText != null ? mSearchEditText.getText().toString() : \"\";\n\t\tif (isExpanded) {\n\t\t\tmInitialSearchValue.push(text);\n\t\t\toneShotKeyboardSuppress.set(true);\n\t\t}\n\t\tsuper.invalidateOptionsMenu();\n\t}\n\n\tprivate void updateSearchViewHint() {\n\t\tif (binding == null || mSearchEditText == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (binding.startConversationViewPager.getCurrentItem() == 0) {\n\t\t\tmSearchEditText.setHint(R.string.search_contacts);\n\t\t} else {\n\t\t\tmSearchEditText.setHint(R.string.search_groups);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tgetMenuInflater().inflate(R.menu.start_conversation, menu);\n\t\tMenuItem menuHideOffline = menu.findItem(R.id.action_hide_offline);\n\t\tMenuItem joinGroupChat = menu.findItem(R.id.action_join_conference);\n\t\tMenuItem qrCodeScanMenuItem = menu.findItem(R.id.action_scan_qr_code);\n\t\tjoinGroupChat.setVisible(binding.startConversationViewPager.getCurrentItem() == 1);\n\t\tqrCodeScanMenuItem.setVisible(isCameraFeatureAvailable());\n\t\tmenuHideOffline.setChecked(this.mHideOfflineContacts);\n\t\tmMenuSearchView = menu.findItem(R.id.action_search);\n\t\tmMenuSearchView.setOnActionExpandListener(mOnActionExpandListener);\n\t\tView mSearchView = mMenuSearchView.getActionView();\n\t\tmSearchEditText = mSearchView.findViewById(R.id.search_field);\n\t\tmSearchEditText.addTextChangedListener(mSearchTextWatcher);\n\t\tmSearchEditText.setOnEditorActionListener(mSearchDone);\n\t\tString initialSearchValue = mInitialSearchValue.pop();\n\t\tif (initialSearchValue != null) {\n\t\t\tmMenuSearchView.expandActionView();\n\t\t\tmSearchEditText.append(initialSearchValue);\n\t\t\tfilter(initialSearchValue);\n\t\t}\n\t\tupdateSearchViewHint();\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tif (MenuDoubleTabUtil.shouldIgnoreTap()) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (item.getItemId()) {\n\t\t\tcase android.R.id.home:\n\t\t\t\tnavigateBack();\n\t\t\t\treturn true;\n\t\t\tcase R.id.action_join_conference:\n\t\t\t\tshowJoinConferenceDialog(null);\n\t\t\t\treturn true;\n\t\t\tcase R.id.action_scan_qr_code:\n\t\t\t\tUriHandlerActivity.scan(this);\n\t\t\t\treturn true;\n\t\t\tcase R.id.action_hide_offline:\n\t\t\t\tmHideOfflineContacts = !item.isChecked();\n\t\t\t\tgetPreferences().edit().putBoolean(\"hide_offline\", mHideOfflineContacts).commit();\n\t\t\t\tif (mSearchEditText != null) {\n\t\t\t\t\tfilter(mSearchEditText.getText().toString());\n\t\t\t\t}\n\t\t\t\tinvalidateOptionsMenu();\n\t\t}\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\t@Override\n\tpublic boolean onKeyUp(int keyCode, KeyEvent event) {\n\t\tif (keyCode == KeyEvent.KEYCODE_SEARCH && !event.isLongPress()) {\n\t\t\topenSearch();\n\t\t\treturn true;\n\t\t}\n\t\tint c = event.getUnicodeChar();\n\t\tif (c > 32) {\n\t\t\tif (mSearchEditText != null && !mSearchEditText.isFocused()) {\n\t\t\t\topenSearch();\n\t\t\t\tmSearchEditText.append(Character.toString((char) c));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn super.onKeyUp(keyCode, event);\n\t}\n\n\tprivate void openSearch() {\n\t\tif (mMenuSearchView != null) {\n\t\t\tmMenuSearchView.expandActionView();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onActivityResult(int requestCode, int resultCode, Intent intent) {\n\t\tif (resultCode == RESULT_OK) {\n\t\t\tif (xmppConnectionServiceBound) {\n\t\t\t\tthis.mPostponedActivityResult = null;\n\t\t\t\tif (requestCode == REQUEST_CREATE_CONFERENCE) {\n\t\t\t\t\tAccount account = extractAccount(intent);\n\t\t\t\t\tfinal String name = intent.getStringExtra(ChooseContactActivity.EXTRA_GROUP_CHAT_NAME);\n\t\t\t\t\tfinal List<Jid> jids = ChooseContactActivity.extractJabberIds(intent);\n\t\t\t\t\tif (account != null && jids.size() > 0) {\n\t\t\t\t\t\tif (xmppConnectionService.createAdhocConference(account, name, jids, mAdhocConferenceCallback)) {\n\t\t\t\t\t\t\tmToast = Toast.makeText(this, R.string.creating_conference, Toast.LENGTH_LONG);\n\t\t\t\t\t\t\tmToast.show();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.mPostponedActivityResult = new Pair<>(requestCode, intent);\n\t\t\t}\n\t\t}\n\t\tsuper.onActivityResult(requestCode, requestCode, intent);\n\t}\n\n\tprivate void askForContactsPermissions() {\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n\t\t\tif (checkSelfPermission(Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {\n\t\t\t\tif (mRequestedContactsPermission.compareAndSet(false, true)) {\n\t\t\t\t\tif (shouldShowRequestPermissionRationale(Manifest.permission.READ_CONTACTS)) {\n\t\t\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\t\t\tbuilder.setTitle(R.string.sync_with_contacts);\n\t\t\t\t\t\tbuilder.setMessage(R.string.sync_with_contacts_long);\n\t\t\t\t\t\tbuilder.setPositiveButton(R.string.next, (dialog, which) -> requestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, REQUEST_SYNC_CONTACTS));\n\t\t\t\t\t\tbuilder.setOnDismissListener(dialog -> requestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, REQUEST_SYNC_CONTACTS));\n\t\t\t\t\t\tbuilder.create().show();\n\t\t\t\t\t} else {\n\t\t\t\t\t\trequestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, REQUEST_SYNC_CONTACTS);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onRequestPermissionsResult(int requestCode, @NonNull String permissions[], @NonNull int[] grantResults) {\n\t\tif (grantResults.length > 0)\n\t\t\tif (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n\t\t\t\tScanActivity.onRequestPermissionResult(this, requestCode, grantResults);\n\t\t\t\tif (requestCode == REQUEST_SYNC_CONTACTS && xmppConnectionServiceBound) {\n\t\t\t\t\txmppConnectionService.loadPhoneContacts();\n\t\t\t\t\txmppConnectionService.startContactObserver();\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tprivate void configureHomeButton() {\n\t\tfinal ActionBar actionBar = getSupportActionBar();\n\t\tif (actionBar == null) {\n\t\t\treturn;\n\t\t}\n\t\tboolean openConversations = !xmppConnectionService.isConversationsListEmpty(null);\n\t\tactionBar.setDisplayHomeAsUpEnabled(openConversations);\n\t\tactionBar.setDisplayHomeAsUpEnabled(openConversations);\n\n\t}\n\n\t@Override\n\tprotected void onBackendConnected() {\n\t\tif (mPostponedActivityResult != null) {\n\t\t\tonActivityResult(mPostponedActivityResult.first, RESULT_OK, mPostponedActivityResult.second);\n\t\t\tthis.mPostponedActivityResult = null;\n\t\t}\n\t\tthis.mActivatedAccounts.clear();\n\t\tfor (Account account : xmppConnectionService.getAccounts()) {\n\t\t\tif (account.getStatus() != Account.State.DISABLED) {\n\t\t\t\tif (Config.DOMAIN_LOCK != null) {\n\t\t\t\t\tthis.mActivatedAccounts.add(account.getJid().getLocal());\n\t\t\t\t} else {\n\t\t\t\t\tthis.mActivatedAccounts.add(account.getJid().asBareJid().toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconfigureHomeButton();\n\t\tIntent intent = pendingViewIntent.pop();\n\t\tif (intent != null && processViewIntent(intent)) {\n\t\t\tfilter(null);\n\t\t} else {\n\t\t\tif (mSearchEditText != null) {\n\t\t\t\tfilter(mSearchEditText.getText().toString());\n\t\t\t} else {\n\t\t\t\tfilter(null);\n\t\t\t}\n\t\t}\n\t\tFragment fragment = getSupportFragmentManager().findFragmentByTag(FRAGMENT_TAG_DIALOG);\n\t\tif (fragment != null && fragment instanceof OnBackendConnected) {\n\t\t\tLog.d(Config.LOGTAG, \"calling on backend connected on dialog\");\n\t\t\t((OnBackendConnected) fragment).onBackendConnected();\n\t\t}\n\t}\n\n\tprotected boolean processViewIntent(@NonNull Intent intent) {\n\t\tfinal String inviteUri = intent.getStringExtra(WelcomeActivity.EXTRA_INVITE_URI);\n\t\tif (inviteUri != null) {\n\t\t\tInvite invite = new Invite(inviteUri);\n\t\t\tif (invite.isJidValid()) {\n\t\t\t\treturn invite.invite();\n\t\t\t}\n\t\t}\n\t\tfinal String action = intent.getAction();\n\t\tif (action == null) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (action) {\n\t\t\tcase Intent.ACTION_SENDTO:\n\t\t\tcase Intent.ACTION_VIEW:\n\t\t\t\tUri uri = intent.getData();\n\t\t\t\tif (uri != null) {\n\t\t\t\t\tInvite invite = new Invite(intent.getData(), intent.getBooleanExtra(\"scanned\", false));\n\t\t\t\t\tinvite.account = intent.getStringExtra(\"account\");\n\t\t\t\t\treturn invite.invite();\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean handleJid(Invite invite) {\n\t\tList<Contact> contacts = xmppConnectionService.findContacts(invite.getJid(), invite.account);\n\t\tif (invite.isAction(XmppUri.ACTION_JOIN)) {\n\t\t\tConversation muc = xmppConnectionService.findFirstMuc(invite.getJid());\n\t\t\tif (muc != null) {\n\t\t\t\tswitchToConversation(muc, invite.getBody());\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tshowJoinConferenceDialog(invite.getJid().asBareJid().toString());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (contacts.size() == 0) {\n\t\t\tshowCreateContactDialog(invite.getJid().toString(), invite);\n\t\t\treturn false;\n\t\t} else if (contacts.size() == 1) {\n\t\t\tContact contact = contacts.get(0);\n\t\t\tif (!invite.isSafeSource() && invite.hasFingerprints()) {\n\t\t\t\tdisplayVerificationWarningDialog(contact, invite);\n\t\t\t} else {\n\t\t\t\tif (invite.hasFingerprints()) {\n\t\t\t\t\tif (xmppConnectionService.verifyFingerprints(contact, invite.getFingerprints())) {\n\t\t\t\t\t\tToast.makeText(this, R.string.verified_fingerprints, Toast.LENGTH_SHORT).show();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (invite.account != null) {\n\t\t\t\t\txmppConnectionService.getShortcutService().report(contact);\n\t\t\t\t}\n\t\t\t\tswitchToConversation(contact, invite.getBody());\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif (mMenuSearchView != null) {\n\t\t\t\tmMenuSearchView.expandActionView();\n\t\t\t\tmSearchEditText.setText(\"\");\n\t\t\t\tmSearchEditText.append(invite.getJid().toString());\n\t\t\t\tfilter(invite.getJid().toString());\n\t\t\t} else {\n\t\t\t\tmInitialSearchValue.push(invite.getJid().toString());\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate void displayVerificationWarningDialog(final Contact contact, final Invite invite) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(R.string.verify_omemo_keys);\n\t\tView view = getLayoutInflater().inflate(R.layout.dialog_verify_fingerprints, null);\n\t\tfinal CheckBox isTrustedSource = view.findViewById(R.id.trusted_source);\n\t\tTextView warning = view.findViewById(R.id.warning);\n\t\twarning.setText(JidDialog.style(this, R.string.verifying_omemo_keys_trusted_source, contact.getJid().asBareJid().toEscapedString(), contact.getDisplayName()));\n\t\tbuilder.setView(view);\n\t\tbuilder.setPositiveButton(R.string.confirm, (dialog, which) -> {\n\t\t\tif (isTrustedSource.isChecked() && invite.hasFingerprints()) {\n\t\t\t\txmppConnectionService.verifyFingerprints(contact, invite.getFingerprints());\n\t\t\t}\n\t\t\tswitchToConversation(contact, invite.getBody());\n\t\t});\n\t\tbuilder.setNegativeButton(R.string.cancel, (dialog, which) -> StartConversationActivity.this.finish());\n\t\tAlertDialog dialog = builder.create();\n\t\tdialog.setCanceledOnTouchOutside(false);\n\t\tdialog.setOnCancelListener(dialog1 -> StartConversationActivity.this.finish());\n\t\tdialog.show();\n\t}\n\n\tprotected void filter(String needle) {\n\t\tif (xmppConnectionServiceBound) {\n\t\t\tthis.filterContacts(needle);\n\t\t\tthis.filterConferences(needle);\n\t\t}\n\t}\n\n\tprotected void filterContacts(String needle) {\n\t\tthis.contacts.clear();\n\t\tfinal List<Account> accounts = xmppConnectionService.getAccounts();\n\t\tfinal boolean singleAccountActive = isSingleAccountActive(accounts);\n\t\tfor (Account account : accounts) {\n\t\t\tif (account.getStatus() != Account.State.DISABLED) {\n\t\t\t\tfor (Contact contact : account.getRoster().getContacts()) {\n\t\t\t\t\tPresence.Status s = contact.getShownStatus();\n\t\t\t\t\tif ((contact.showInRoster() || (singleAccountActive && contact.showInPhoneBook())) && contact.match(this, needle)\n\t\t\t\t\t\t\t&& (!this.mHideOfflineContacts\n\t\t\t\t\t\t\t|| (needle != null && !needle.trim().isEmpty())\n\t\t\t\t\t\t\t|| s.compareTo(Presence.Status.OFFLINE) < 0)) {\n\t\t\t\t\t\tthis.contacts.add(contact);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(this.contacts);\n\t\tmContactsAdapter.notifyDataSetChanged();\n\t}\n\n\tprivate static boolean isSingleAccountActive(final List<Account> accounts) {\n\t\tint i = 0;\n\t\tfor(Account account : accounts) {\n\t\t\tif (account.getStatus() != Account.State.DISABLED) {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\treturn i == 1;\n\t}\n\n\tprotected void filterConferences(String needle) {\n\t\tthis.conferences.clear();\n\t\tfor (Account account : xmppConnectionService.getAccounts()) {\n\t\t\tif (account.getStatus() != Account.State.DISABLED) {\n\t\t\t\tfor (Bookmark bookmark : account.getBookmarks()) {\n\t\t\t\t\tif (bookmark.match(this, needle)) {\n\t\t\t\t\t\tthis.conferences.add(bookmark);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(this.conferences);\n\t\tmConferenceAdapter.notifyDataSetChanged();\n\t}\n\n\tprivate void onTabChanged() {\n\t\t@DrawableRes final int fabDrawable;\n\t\tif (binding.startConversationViewPager.getCurrentItem() == 0) {\n\t\t\tfabDrawable = R.drawable.ic_person_add_white_24dp;\n\t\t} else {\n\t\t\tfabDrawable = R.drawable.ic_group_add_white_24dp;\n\t\t}\n\t\tbinding.fab.setImageResource(fabDrawable);\n\t\tinvalidateOptionsMenu();\n\t}\n\n\t@Override\n\tpublic void OnUpdateBlocklist(final Status status) {\n\t\trefreshUi();\n\t}\n\n\t@Override\n\tprotected void refreshUiReal() {\n\t\tif (mSearchEditText != null) {\n\t\t\tfilter(mSearchEditText.getText().toString());\n\t\t}\n\t\tconfigureHomeButton();\n\t}\n\n\t@Override\n\tpublic void onBackPressed() {\n\t\tnavigateBack();\n\t}\n\n\tprivate void navigateBack() {\n\t\tif (xmppConnectionService != null && !xmppConnectionService.isConversationsListEmpty(null)) {\n\t\t\tIntent intent = new Intent(this, ConversationsActivity.class);\n\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\n\t\t\tstartActivity(intent);\n\t\t}\n\t\tfinish();\n\t}\n\n\t@Override\n\tpublic void onCreateDialogPositiveClick(Spinner spinner, String name) {\n\t\tif (!xmppConnectionServiceBound) {\n\t\t\treturn;\n\t\t}\n\t\tfinal Account account = getSelectedAccount(spinner);\n\t\tif (account == null) {\n\t\t\treturn;\n\t\t}\n\t\tIntent intent = new Intent(getApplicationContext(), ChooseContactActivity.class);\n\t\tintent.putExtra(ChooseContactActivity.EXTRA_SHOW_ENTER_JID, false);\n\t\tintent.putExtra(ChooseContactActivity.EXTRA_SELECT_MULTIPLE, true);\n\t\tintent.putExtra(ChooseContactActivity.EXTRA_GROUP_CHAT_NAME, name.trim());\n\t\tintent.putExtra(ChooseContactActivity.EXTRA_ACCOUNT, account.getJid().asBareJid().toString());\n\t\tintent.putExtra(ChooseContactActivity.EXTRA_TITLE_RES_ID, R.string.choose_participants);\n\t\tstartActivityForResult(intent, REQUEST_CREATE_CONFERENCE);\n\t}\n\n\t@Override\n\tpublic void onJoinDialogPositiveClick(Dialog dialog, Spinner spinner, AutoCompleteTextView jid, boolean isBookmarkChecked) {\n\t\tif (!xmppConnectionServiceBound) {\n\t\t\treturn;\n\t\t}\n\t\tfinal Account account = getSelectedAccount(spinner);\n\t\tif (account == null) {\n\t\t\treturn;\n\t\t}\n\t\tfinal Jid conferenceJid;\n\t\ttry {\n\t\t\tconferenceJid = Jid.of(jid.getText().toString());\n\t\t} catch (final IllegalArgumentException e) {\n\t\t\tjid.setError(getString(R.string.invalid_jid));\n\t\t\treturn;\n\t\t}\n\n\t\tif (isBookmarkChecked) {\n\t\t\tif (account.hasBookmarkFor(conferenceJid)) {\n\t\t\t\tjid.setError(getString(R.string.bookmark_already_exists));\n\t\t\t} else {\n\t\t\t\tfinal Bookmark bookmark = new Bookmark(account, conferenceJid.asBareJid());\n\t\t\t\tbookmark.setAutojoin(getBooleanPreference(\"autojoin\", R.bool.autojoin));\n\t\t\t\tString nick = conferenceJid.getResource();\n\t\t\t\tif (nick != null && !nick.isEmpty()) {\n\t\t\t\t\tbookmark.setNick(nick);\n\t\t\t\t}\n\t\t\t\taccount.getBookmarks().add(bookmark);\n\t\t\t\txmppConnectionService.pushBookmarks(account);\n\t\t\t\tfinal Conversation conversation = xmppConnectionService\n\t\t\t\t\t\t.findOrCreateConversation(account, conferenceJid, true, true, true);\n\t\t\t\tbookmark.setConversation(conversation);\n\t\t\t\tdialog.dismiss();\n\t\t\t\tswitchToConversation(conversation);\n\t\t\t}\n\t\t} else {\n\t\t\tfinal Conversation conversation = xmppConnectionService\n\t\t\t\t\t.findOrCreateConversation(account, conferenceJid, true, true, true);\n\t\t\tdialog.dismiss();\n\t\t\tswitchToConversation(conversation);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onConversationUpdate() {\n\t\trefreshUi();\n\t}\n\n\tpublic static class MyListFragment extends ListFragment {\n\t\tprivate AdapterView.OnItemClickListener mOnItemClickListener;\n\t\tprivate int mResContextMenu;\n\n\t\tpublic void setContextMenu(final int res) {\n\t\t\tthis.mResContextMenu = res;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onListItemClick(final ListView l, final View v, final int position, final long id) {\n\t\t\tif (mOnItemClickListener != null) {\n\t\t\t\tmOnItemClickListener.onItemClick(l, v, position, id);\n\t\t\t}\n\t\t}\n\n\t\tpublic void setOnListItemClickListener(AdapterView.OnItemClickListener l) {\n\t\t\tthis.mOnItemClickListener = l;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onViewCreated(@NonNull final View view, final Bundle savedInstanceState) {\n\t\t\tsuper.onViewCreated(view, savedInstanceState);\n\t\t\tregisterForContextMenu(getListView());\n\t\t\tgetListView().setFastScrollEnabled(true);\n\t\t\tgetListView().setDivider(null);\n\t\t\tgetListView().setDividerHeight(0);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreateContextMenu(final ContextMenu menu, final View v, final ContextMenuInfo menuInfo) {\n\t\t\tsuper.onCreateContextMenu(menu, v, menuInfo);\n\t\t\tfinal StartConversationActivity activity = (StartConversationActivity) getActivity();\n\t\t\tif (activity == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tactivity.getMenuInflater().inflate(mResContextMenu, menu);\n\t\t\tfinal AdapterView.AdapterContextMenuInfo acmi = (AdapterContextMenuInfo) menuInfo;\n\t\t\tif (mResContextMenu == R.menu.conference_context) {\n\t\t\t\tactivity.conference_context_id = acmi.position;\n\t\t\t} else if (mResContextMenu == R.menu.contact_context) {\n\t\t\t\tactivity.contact_context_id = acmi.position;\n\t\t\t\tfinal Contact contact = (Contact) activity.contacts.get(acmi.position);\n\t\t\t\tfinal MenuItem blockUnblockItem = menu.findItem(R.id.context_contact_block_unblock);\n\t\t\t\tfinal MenuItem showContactDetailsItem = menu.findItem(R.id.context_contact_details);\n\t\t\t\tfinal MenuItem deleteContactMenuItem = menu.findItem(R.id.context_delete_contact);\n\t\t\t\tif (contact.isSelf()) {\n\t\t\t\t\tshowContactDetailsItem.setVisible(false);\n\t\t\t\t}\n\t\t\t\tdeleteContactMenuItem.setVisible(contact.showInRoster());\n\t\t\t\tXmppConnection xmpp = contact.getAccount().getXmppConnection();\n\t\t\t\tif (xmpp != null && xmpp.getFeatures().blocking() && !contact.isSelf()) {\n\t\t\t\t\tif (contact.isBlocked()) {\n\t\t\t\t\t\tblockUnblockItem.setTitle(R.string.unblock_contact);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tblockUnblockItem.setTitle(R.string.block_contact);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tblockUnblockItem.setVisible(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onContextItemSelected(final MenuItem item) {\n\t\t\tStartConversationActivity activity = (StartConversationActivity) getActivity();\n\t\t\tif (activity == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tswitch (item.getItemId()) {\n\t\t\t\tcase R.id.context_contact_details:\n\t\t\t\t\tactivity.openDetailsForContact();\n\t\t\t\t\tbreak;\n\t\t\t\tcase R.id.context_show_qr:\n\t\t\t\t\tactivity.showQrForContact();\n\t\t\t\t\tbreak;\n\t\t\t\tcase R.id.context_contact_block_unblock:\n\t\t\t\t\tactivity.toggleContactBlock();\n\t\t\t\t\tbreak;\n\t\t\t\tcase R.id.context_delete_contact:\n\t\t\t\t\tactivity.deleteContact();\n\t\t\t\t\tbreak;\n\t\t\t\tcase R.id.context_join_conference:\n\t\t\t\t\tactivity.openConversationForBookmark();\n\t\t\t\t\tbreak;\n\t\t\t\tcase R.id.context_share_uri:\n\t\t\t\t\tactivity.shareBookmarkUri();\n\t\t\t\t\tbreak;\n\t\t\t\tcase R.id.context_delete_conference:\n\t\t\t\t\tactivity.deleteConference();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic class ListPagerAdapter extends PagerAdapter {\n\t\tFragmentManager fragmentManager;\n\t\tMyListFragment[] fragments;\n\n\t\tpublic ListPagerAdapter(FragmentManager fm) {\n\t\t\tfragmentManager = fm;\n\t\t\tfragments = new MyListFragment[2];\n\t\t}\n\n\t\tpublic void requestFocus(int pos) {\n\t\t\tif (fragments.length > pos) {\n\t\t\t\tfragments[pos].getListView().requestFocus();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) {\n\t\t\tFragmentTransaction trans = fragmentManager.beginTransaction();\n\t\t\ttrans.remove(fragments[position]);\n\t\t\ttrans.commit();\n\t\t\tfragments[position] = null;\n\t\t}\n\n\t\t@NonNull\n\t\t@Override\n\t\tpublic Fragment instantiateItem(@NonNull ViewGroup container, int position) {\n\t\t\tFragment fragment = getItem(position);\n\t\t\tFragmentTransaction trans = fragmentManager.beginTransaction();\n\t\t\ttrans.add(container.getId(), fragment, \"fragment:\" + position);\n\t\t\ttrans.commit();\n\t\t\treturn fragment;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getCount() {\n\t\t\treturn fragments.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isViewFromObject(@NonNull View view, @NonNull Object fragment) {\n\t\t\treturn ((Fragment) fragment).getView() == view;\n\t\t}\n\n\t\t@Nullable\n\t\t@Override\n\t\tpublic CharSequence getPageTitle(int position) {\n\t\t\tswitch (position) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn getResources().getString(R.string.contacts);\n\t\t\t\tcase 1:\n\t\t\t\t\treturn getResources().getString(R.string.conferences);\n\t\t\t\tdefault:\n\t\t\t\t\treturn super.getPageTitle(position);\n\t\t\t}\n\t\t}\n\n\t\tFragment getItem(int position) {\n\t\t\tif (fragments[position] == null) {\n\t\t\t\tfinal MyListFragment listFragment = new MyListFragment();\n\t\t\t\tif (position == 1) {\n\t\t\t\t\tlistFragment.setListAdapter(mConferenceAdapter);\n\t\t\t\t\tlistFragment.setContextMenu(R.menu.conference_context);\n\t\t\t\t\tlistFragment.setOnListItemClickListener((arg0, arg1, p, arg3) -> openConversationForBookmark(p));\n\t\t\t\t} else {\n\n\t\t\t\t\tlistFragment.setListAdapter(mContactsAdapter);\n\t\t\t\t\tlistFragment.setContextMenu(R.menu.contact_context);\n\t\t\t\t\tlistFragment.setOnListItemClickListener((arg0, arg1, p, arg3) -> openConversationForContact(p));\n\t\t\t\t}\n\t\t\t\tfragments[position] = listFragment;\n\t\t\t}\n\t\t\treturn fragments[position];\n\t\t}\n\t}\n\n\tprivate class Invite extends XmppUri {\n\n\t\tpublic String account;\n\n\t\tpublic Invite(final Uri uri) {\n\t\t\tsuper(uri);\n\t\t}\n\n\t\tpublic Invite(final String uri) {\n\t\t\tsuper(uri);\n\t\t}\n\n\t\tpublic Invite(Uri uri, boolean safeSource) {\n\t\t\tsuper(uri, safeSource);\n\t\t}\n\n\t\tboolean invite() {\n\t\t\tif (!isJidValid()) {\n\t\t\t\tToast.makeText(StartConversationActivity.this, R.string.invalid_jid, Toast.LENGTH_SHORT).show();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (getJid() != null) {\n\t\t\t\treturn handleJid(this);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}\n", "package eu.siacs.conversations.ui;\n\nimport android.Manifest;\nimport android.annotation.SuppressLint;\nimport android.annotation.TargetApi;\nimport android.app.PendingIntent;\nimport android.content.ActivityNotFoundException;\nimport android.content.ClipData;\nimport android.content.ClipboardManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentSender.SendIntentException;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.databinding.DataBindingUtil;\nimport android.graphics.Bitmap;\nimport android.graphics.Color;\nimport android.graphics.Point;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.net.ConnectivityManager;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.PowerManager;\nimport android.os.SystemClock;\nimport android.preference.PreferenceManager;\nimport android.support.annotation.BoolRes;\nimport android.support.annotation.StringRes;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AlertDialog;\nimport android.support.v7.app.AlertDialog.Builder;\nimport android.support.v7.app.AppCompatDelegate;\nimport android.text.InputType;\nimport android.util.DisplayMetrics;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.EditText;\nimport android.widget.ImageView;\nimport android.widget.Toast;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport eu.siacs.conversations.Config;\nimport eu.siacs.conversations.R;\nimport eu.siacs.conversations.crypto.PgpEngine;\nimport eu.siacs.conversations.databinding.DialogQuickeditBinding;\nimport eu.siacs.conversations.entities.Account;\nimport eu.siacs.conversations.entities.Contact;\nimport eu.siacs.conversations.entities.Conversation;\nimport eu.siacs.conversations.entities.Message;\nimport eu.siacs.conversations.entities.Presences;\nimport eu.siacs.conversations.services.AvatarService;\nimport eu.siacs.conversations.services.BarcodeProvider;\nimport eu.siacs.conversations.services.XmppConnectionService;\nimport eu.siacs.conversations.services.XmppConnectionService.XmppConnectionBinder;\nimport eu.siacs.conversations.ui.util.MenuDoubleTabUtil;\nimport eu.siacs.conversations.ui.util.PresenceSelector;\nimport eu.siacs.conversations.ui.util.SoftKeyboardUtils;\nimport eu.siacs.conversations.utils.ExceptionHelper;\nimport eu.siacs.conversations.utils.ThemeHelper;\nimport eu.siacs.conversations.xmpp.OnKeyStatusUpdated;\nimport eu.siacs.conversations.xmpp.OnUpdateBlocklist;\nimport rocks.xmpp.addr.Jid;\n\npublic abstract class XmppActivity extends ActionBarActivity {\n\n\tpublic static final String EXTRA_ACCOUNT = \"account\";\n\tprotected static final int REQUEST_ANNOUNCE_PGP = 0x0101;\n\tprotected static final int REQUEST_INVITE_TO_CONVERSATION = 0x0102;\n\tprotected static final int REQUEST_CHOOSE_PGP_ID = 0x0103;\n\tprotected static final int REQUEST_BATTERY_OP = 0x49ff;\n\tpublic XmppConnectionService xmppConnectionService;\n\tpublic boolean xmppConnectionServiceBound = false;\n\n\tprotected int mColorRed;\n\n\tprotected static final String FRAGMENT_TAG_DIALOG = \"dialog\";\n\n\tprivate boolean isCameraFeatureAvailable = false;\n\n\tprotected int mTheme;\n\tprotected boolean mUsingEnterKey = false;\n\tprotected Toast mToast;\n\tpublic Runnable onOpenPGPKeyPublished = () -> Toast.makeText(XmppActivity.this, R.string.openpgp_has_been_published, Toast.LENGTH_SHORT).show();\n\tprotected ConferenceInvite mPendingConferenceInvite = null;\n\tprotected ServiceConnection mConnection = new ServiceConnection() {\n\n\t\t@Override\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tXmppConnectionBinder binder = (XmppConnectionBinder) service;\n\t\t\txmppConnectionService = binder.getService();\n\t\t\txmppConnectionServiceBound = true;\n\t\t\tregisterListeners();\n\t\t\tonBackendConnected();\n\t\t}\n\n\t\t@Override\n\t\tpublic void onServiceDisconnected(ComponentName arg0) {\n\t\t\txmppConnectionServiceBound = false;\n\t\t}\n\t};\n\tprivate DisplayMetrics metrics;\n\tprivate long mLastUiRefresh = 0;\n\tprivate Handler mRefreshUiHandler = new Handler();\n\tprivate Runnable mRefreshUiRunnable = () -> {\n\t\tmLastUiRefresh = SystemClock.elapsedRealtime();\n\t\trefreshUiReal();\n\t};\n\tprivate UiCallback<Conversation> adhocCallback = new UiCallback<Conversation>() {\n\t\t@Override\n\t\tpublic void success(final Conversation conversation) {\n\t\t\trunOnUiThread(() -> {\n\t\t\t\tswitchToConversation(conversation);\n\t\t\t\thideToast();\n\t\t\t});\n\t\t}\n\n\t\t@Override\n\t\tpublic void error(final int errorCode, Conversation object) {\n\t\t\trunOnUiThread(() -> replaceToast(getString(errorCode)));\n\t\t}\n\n\t\t@Override\n\t\tpublic void userInputRequried(PendingIntent pi, Conversation object) {\n\n\t\t}\n\t};\n\tpublic boolean mSkipBackgroundBinding = false;\n\n\tpublic static boolean cancelPotentialWork(Message message, ImageView imageView) {\n\t\tfinal BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView);\n\n\t\tif (bitmapWorkerTask != null) {\n\t\t\tfinal Message oldMessage = bitmapWorkerTask.message;\n\t\t\tif (oldMessage == null || message != oldMessage) {\n\t\t\t\tbitmapWorkerTask.cancel(true);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static BitmapWorkerTask getBitmapWorkerTask(ImageView imageView) {\n\t\tif (imageView != null) {\n\t\t\tfinal Drawable drawable = imageView.getDrawable();\n\t\t\tif (drawable instanceof AsyncDrawable) {\n\t\t\t\tfinal AsyncDrawable asyncDrawable = (AsyncDrawable) drawable;\n\t\t\t\treturn asyncDrawable.getBitmapWorkerTask();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected void hideToast() {\n\t\tif (mToast != null) {\n\t\t\tmToast.cancel();\n\t\t}\n\t}\n\n\tprotected void replaceToast(String msg) {\n\t\treplaceToast(msg, true);\n\t}\n\n\tprotected void replaceToast(String msg, boolean showlong) {\n\t\thideToast();\n\t\tmToast = Toast.makeText(this, msg, showlong ? Toast.LENGTH_LONG : Toast.LENGTH_SHORT);\n\t\tmToast.show();\n\t}\n\n\tprotected final void refreshUi() {\n\t\tfinal long diff = SystemClock.elapsedRealtime() - mLastUiRefresh;\n\t\tif (diff > Config.REFRESH_UI_INTERVAL) {\n\t\t\tmRefreshUiHandler.removeCallbacks(mRefreshUiRunnable);\n\t\t\trunOnUiThread(mRefreshUiRunnable);\n\t\t} else {\n\t\t\tfinal long next = Config.REFRESH_UI_INTERVAL - diff;\n\t\t\tmRefreshUiHandler.removeCallbacks(mRefreshUiRunnable);\n\t\t\tmRefreshUiHandler.postDelayed(mRefreshUiRunnable, next);\n\t\t}\n\t}\n\n\tabstract protected void refreshUiReal();\n\n\t@Override\n\tprotected void onStart() {\n\t\tsuper.onStart();\n\t\tif (!xmppConnectionServiceBound) {\n\t\t\tif (this.mSkipBackgroundBinding) {\n\t\t\t\tLog.d(Config.LOGTAG,\"skipping background binding\");\n\t\t\t} else {\n\t\t\t\tconnectToBackend();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.registerListeners();\n\t\t\tthis.onBackendConnected();\n\t\t}\n\t}\n\n\tpublic void connectToBackend() {\n\t\tIntent intent = new Intent(this, XmppConnectionService.class);\n\t\tintent.setAction(\"ui\");\n\t\tstartService(intent);\n\t\tbindService(intent, mConnection, Context.BIND_AUTO_CREATE);\n\t}\n\n\t@Override\n\tprotected void onStop() {\n\t\tsuper.onStop();\n\t\tif (xmppConnectionServiceBound) {\n\t\t\tthis.unregisterListeners();\n\t\t\tunbindService(mConnection);\n\t\t\txmppConnectionServiceBound = false;\n\t\t}\n\t}\n\n\n\tpublic boolean hasPgp() {\n\t\treturn xmppConnectionService.getPgpEngine() != null;\n\t}\n\n\tpublic void showInstallPgpDialog() {\n\t\tBuilder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(getString(R.string.openkeychain_required));\n\t\tbuilder.setIconAttribute(android.R.attr.alertDialogIcon);\n\t\tbuilder.setMessage(getText(R.string.openkeychain_required_long));\n\t\tbuilder.setNegativeButton(getString(R.string.cancel), null);\n\t\tbuilder.setNeutralButton(getString(R.string.restart),\n\t\t\t\t(dialog, which) -> {\n\t\t\t\t\tif (xmppConnectionServiceBound) {\n\t\t\t\t\t\tunbindService(mConnection);\n\t\t\t\t\t\txmppConnectionServiceBound = false;\n\t\t\t\t\t}\n\t\t\t\t\tstopService(new Intent(XmppActivity.this,\n\t\t\t\t\t\t\tXmppConnectionService.class));\n\t\t\t\t\tfinish();\n\t\t\t\t});\n\t\tbuilder.setPositiveButton(getString(R.string.install),\n\t\t\t\t(dialog, which) -> {\n\t\t\t\t\tUri uri = Uri\n\t\t\t\t\t\t\t.parse(\"market://details?id=org.sufficientlysecure.keychain\");\n\t\t\t\t\tIntent marketIntent = new Intent(Intent.ACTION_VIEW,\n\t\t\t\t\t\t\turi);\n\t\t\t\t\tPackageManager manager = getApplicationContext()\n\t\t\t\t\t\t\t.getPackageManager();\n\t\t\t\t\tList<ResolveInfo> infos = manager\n\t\t\t\t\t\t\t.queryIntentActivities(marketIntent, 0);\n\t\t\t\t\tif (infos.size() > 0) {\n\t\t\t\t\t\tstartActivity(marketIntent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\turi = Uri.parse(\"http://www.openkeychain.org/\");\n\t\t\t\t\t\tIntent browserIntent = new Intent(\n\t\t\t\t\t\t\t\tIntent.ACTION_VIEW, uri);\n\t\t\t\t\t\tstartActivity(browserIntent);\n\t\t\t\t\t}\n\t\t\t\t\tfinish();\n\t\t\t\t});\n\t\tbuilder.create().show();\n\t}\n\n\tabstract void onBackendConnected();\n\n\tprotected void registerListeners() {\n\t\tif (this instanceof XmppConnectionService.OnConversationUpdate) {\n\t\t\tthis.xmppConnectionService.setOnConversationListChangedListener((XmppConnectionService.OnConversationUpdate) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnAccountUpdate) {\n\t\t\tthis.xmppConnectionService.setOnAccountListChangedListener((XmppConnectionService.OnAccountUpdate) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnCaptchaRequested) {\n\t\t\tthis.xmppConnectionService.setOnCaptchaRequestedListener((XmppConnectionService.OnCaptchaRequested) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnRosterUpdate) {\n\t\t\tthis.xmppConnectionService.setOnRosterUpdateListener((XmppConnectionService.OnRosterUpdate) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnMucRosterUpdate) {\n\t\t\tthis.xmppConnectionService.setOnMucRosterUpdateListener((XmppConnectionService.OnMucRosterUpdate) this);\n\t\t}\n\t\tif (this instanceof OnUpdateBlocklist) {\n\t\t\tthis.xmppConnectionService.setOnUpdateBlocklistListener((OnUpdateBlocklist) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnShowErrorToast) {\n\t\t\tthis.xmppConnectionService.setOnShowErrorToastListener((XmppConnectionService.OnShowErrorToast) this);\n\t\t}\n\t\tif (this instanceof OnKeyStatusUpdated) {\n\t\t\tthis.xmppConnectionService.setOnKeyStatusUpdatedListener((OnKeyStatusUpdated) this);\n\t\t}\n\t}\n\n\tprotected void unregisterListeners() {\n\t\tif (this instanceof XmppConnectionService.OnConversationUpdate) {\n\t\t\tthis.xmppConnectionService.removeOnConversationListChangedListener((XmppConnectionService.OnConversationUpdate) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnAccountUpdate) {\n\t\t\tthis.xmppConnectionService.removeOnAccountListChangedListener((XmppConnectionService.OnAccountUpdate) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnCaptchaRequested) {\n\t\t\tthis.xmppConnectionService.removeOnCaptchaRequestedListener((XmppConnectionService.OnCaptchaRequested) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnRosterUpdate) {\n\t\t\tthis.xmppConnectionService.removeOnRosterUpdateListener((XmppConnectionService.OnRosterUpdate) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnMucRosterUpdate) {\n\t\t\tthis.xmppConnectionService.removeOnMucRosterUpdateListener((XmppConnectionService.OnMucRosterUpdate) this);\n\t\t}\n\t\tif (this instanceof OnUpdateBlocklist) {\n\t\t\tthis.xmppConnectionService.removeOnUpdateBlocklistListener((OnUpdateBlocklist) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnShowErrorToast) {\n\t\t\tthis.xmppConnectionService.removeOnShowErrorToastListener((XmppConnectionService.OnShowErrorToast) this);\n\t\t}\n\t\tif (this instanceof OnKeyStatusUpdated) {\n\t\t\tthis.xmppConnectionService.removeOnNewKeysAvailableListener((OnKeyStatusUpdated) this);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(final MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.action_settings:\n\t\t\t\tstartActivity(new Intent(this, SettingsActivity.class));\n\t\t\t\tbreak;\n\t\t\tcase R.id.action_accounts:\n\t\t\t\tstartActivity(new Intent(this, ManageAccountActivity.class));\n\t\t\t\tbreak;\n\t\t\tcase android.R.id.home:\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.action_show_qr_code:\n\t\t\t\tshowQrCode();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\tpublic void selectPresence(final Conversation conversation, final PresenceSelector.OnPresenceSelected listener) {\n\t\tfinal Contact contact = conversation.getContact();\n\t\tif (!contact.showInRoster()) {\n\t\t\tshowAddToRosterDialog(conversation.getContact());\n\t\t} else {\n\t\t\tfinal Presences presences = contact.getPresences();\n\t\t\tif (presences.size() == 0) {\n\t\t\t\tif (!contact.getOption(Contact.Options.TO)\n\t\t\t\t\t\t&& !contact.getOption(Contact.Options.ASKING)\n\t\t\t\t\t\t&& contact.getAccount().getStatus() == Account.State.ONLINE) {\n\t\t\t\t\tshowAskForPresenceDialog(contact);\n\t\t\t\t} else if (!contact.getOption(Contact.Options.TO)\n\t\t\t\t\t\t|| !contact.getOption(Contact.Options.FROM)) {\n\t\t\t\t\tPresenceSelector.warnMutualPresenceSubscription(this, conversation, listener);\n\t\t\t\t} else {\n\t\t\t\t\tconversation.setNextCounterpart(null);\n\t\t\t\t\tlistener.onPresenceSelected();\n\t\t\t\t}\n\t\t\t} else if (presences.size() == 1) {\n\t\t\t\tString presence = presences.toResourceArray()[0];\n\t\t\t\ttry {\n\t\t\t\t\tconversation.setNextCounterpart(Jid.of(contact.getJid().getLocal(), contact.getJid().getDomain(), presence));\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tconversation.setNextCounterpart(null);\n\t\t\t\t}\n\t\t\t\tlistener.onPresenceSelected();\n\t\t\t} else {\n\t\t\t\tPresenceSelector.showPresenceSelectionDialog(this, conversation, listener);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tmetrics = getResources().getDisplayMetrics();\n\t\tExceptionHelper.init(getApplicationContext());\n\t\tthis.isCameraFeatureAvailable = getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA);\n\n\t\tmColorRed = ContextCompat.getColor(this, R.color.red800);\n\n\t\tthis.mTheme = findTheme();\n\t\tsetTheme(this.mTheme);\n\n\t\tthis.mUsingEnterKey = usingEnterKey();\n\t}\n\n\tprotected boolean isCameraFeatureAvailable() {\n\t\treturn this.isCameraFeatureAvailable;\n\t}\n\n\tpublic boolean isDarkTheme() {\n\t\treturn ThemeHelper.isDark(mTheme);\n\t}\n\n\tpublic int getThemeResource(int r_attr_name, int r_drawable_def) {\n\t\tint[] attrs = {r_attr_name};\n\t\tTypedArray ta = this.getTheme().obtainStyledAttributes(attrs);\n\n\t\tint res = ta.getResourceId(0, r_drawable_def);\n\t\tta.recycle();\n\n\t\treturn res;\n\t}\n\n\tprotected boolean isOptimizingBattery() {\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n\t\t\tfinal PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);\n\t\t\treturn pm != null\n\t\t\t\t\t&& !pm.isIgnoringBatteryOptimizations(getPackageName());\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprotected boolean isAffectedByDataSaver() {\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n\t\t\tfinal ConnectivityManager cm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);\n\t\t\treturn cm != null\n\t\t\t\t\t&& cm.isActiveNetworkMetered()\n\t\t\t\t\t&& cm.getRestrictBackgroundStatus() == ConnectivityManager.RESTRICT_BACKGROUND_STATUS_ENABLED;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprotected boolean usingEnterKey() {\n\t\treturn getBooleanPreference(\"display_enter_key\", R.bool.display_enter_key);\n\t}\n\n\tprotected SharedPreferences getPreferences() {\n\t\treturn PreferenceManager.getDefaultSharedPreferences(getApplicationContext());\n\t}\n\n\tprotected boolean getBooleanPreference(String name, @BoolRes int res) {\n\t\treturn getPreferences().getBoolean(name, getResources().getBoolean(res));\n\t}\n\n\tpublic void switchToConversation(Conversation conversation) {\n\t\tswitchToConversation(conversation, null);\n\t}\n\n\tpublic void switchToConversationAndQuote(Conversation conversation, String text) {\n\t\tswitchToConversation(conversation, text, true, null, false);\n\t}\n\n\tpublic void switchToConversation(Conversation conversation, String text) {\n\t\tswitchToConversation(conversation, text, false, null, false);\n\t}\n\n\tpublic void highlightInMuc(Conversation conversation, String nick) {\n\t\tswitchToConversation(conversation, null, false, nick, false);\n\t}\n\n\tpublic void privateMsgInMuc(Conversation conversation, String nick) {\n\t\tswitchToConversation(conversation, null, false, nick, true);\n\t}\n\n\tprivate void switchToConversation(Conversation conversation, String text, boolean asQuote, String nick, boolean pm) {\n\t\tIntent intent = new Intent(this, ConversationsActivity.class);\n\t\tintent.setAction(ConversationsActivity.ACTION_VIEW_CONVERSATION);\n\t\tintent.putExtra(ConversationsActivity.EXTRA_CONVERSATION, conversation.getUuid());\n\t\tif (text != null) {\n\t\t\tintent.putExtra(Intent.EXTRA_TEXT, text);\n\t\t\tif (asQuote) {\n\t\t\t\tintent.putExtra(ConversationsActivity.EXTRA_AS_QUOTE, true);\n\t\t\t}\n\t\t}\n\t\tif (nick != null) {\n\t\t\tintent.putExtra(ConversationsActivity.EXTRA_NICK, nick);\n\t\t\tintent.putExtra(ConversationsActivity.EXTRA_IS_PRIVATE_MESSAGE, pm);\n\t\t}\n\t\tintent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\tstartActivity(intent);\n\t\tfinish();\n\t}\n\n\tpublic void switchToContactDetails(Contact contact) {\n\t\tswitchToContactDetails(contact, null);\n\t}\n\n\tpublic void switchToContactDetails(Contact contact, String messageFingerprint) {\n\t\tIntent intent = new Intent(this, ContactDetailsActivity.class);\n\t\tintent.setAction(ContactDetailsActivity.ACTION_VIEW_CONTACT);\n\t\tintent.putExtra(EXTRA_ACCOUNT, contact.getAccount().getJid().asBareJid().toString());\n\t\tintent.putExtra(\"contact\", contact.getJid().toString());\n\t\tintent.putExtra(\"fingerprint\", messageFingerprint);\n\t\tstartActivity(intent);\n\t}\n\n\tpublic void switchToAccount(Account account, String fingerprint) {\n\t\tswitchToAccount(account, false, fingerprint);\n\t}\n\n\tpublic void switchToAccount(Account account) {\n\t\tswitchToAccount(account, false, null);\n\t}\n\n\tpublic void switchToAccount(Account account, boolean init, String fingerprint) {\n\t\tIntent intent = new Intent(this, EditAccountActivity.class);\n\t\tintent.putExtra(\"jid\", account.getJid().asBareJid().toString());\n\t\tintent.putExtra(\"init\", init);\n\t\tif (init) {\n\t\t\tintent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NO_ANIMATION);\n\t\t}\n\t\tif (fingerprint != null) {\n\t\t\tintent.putExtra(\"fingerprint\", fingerprint);\n\t\t}\n\t\tstartActivity(intent);\n\t\tif (init) {\n\t\t\toverridePendingTransition(0, 0);\n\t\t}\n\t}\n\n\tprotected void delegateUriPermissionsToService(Uri uri) {\n\t\tIntent intent = new Intent(this, XmppConnectionService.class);\n\t\tintent.setAction(Intent.ACTION_SEND);\n\t\tintent.setData(uri);\n\t\tintent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\t\ttry {\n\t\t\tstartService(intent);\n\t\t} catch (Exception e) {\n\t\t\tLog.e(Config.LOGTAG,\"unable to delegate uri permission\",e);\n\t\t}\n\t}\n\n\tprotected void inviteToConversation(Conversation conversation) {\n\t\tstartActivityForResult(ChooseContactActivity.create(this,conversation), REQUEST_INVITE_TO_CONVERSATION);\n\t}\n\n\tprotected void announcePgp(final Account account, final Conversation conversation, Intent intent, final Runnable onSuccess) {\n\t\tif (account.getPgpId() == 0) {\n\t\t\tchoosePgpSignId(account);\n\t\t} else {\n\t\t\tString status = null;\n\t\t\tif (manuallyChangePresence()) {\n\t\t\t\tstatus = account.getPresenceStatusMessage();\n\t\t\t}\n\t\t\tif (status == null) {\n\t\t\t\tstatus = \"\";\n\t\t\t}\n\t\t\txmppConnectionService.getPgpEngine().generateSignature(intent, account, status, new UiCallback<String>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void userInputRequried(PendingIntent pi, String signature) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstartIntentSenderForResult(pi.getIntentSender(), REQUEST_ANNOUNCE_PGP, null, 0, 0, 0);\n\t\t\t\t\t} catch (final SendIntentException ignored) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void success(String signature) {\n\t\t\t\t\taccount.setPgpSignature(signature);\n\t\t\t\t\txmppConnectionService.databaseBackend.updateAccount(account);\n\t\t\t\t\txmppConnectionService.sendPresence(account);\n\t\t\t\t\tif (conversation != null) {\n\t\t\t\t\t\tconversation.setNextEncryption(Message.ENCRYPTION_PGP);\n\t\t\t\t\t\txmppConnectionService.updateConversation(conversation);\n\t\t\t\t\t\trefreshUi();\n\t\t\t\t\t}\n\t\t\t\t\tif (onSuccess != null) {\n\t\t\t\t\t\trunOnUiThread(onSuccess);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void error(int error, String signature) {\n\t\t\t\t\tif (error == 0) {\n\t\t\t\t\t\taccount.setPgpSignId(0);\n\t\t\t\t\t\taccount.unsetPgpSignature();\n\t\t\t\t\t\txmppConnectionService.databaseBackend.updateAccount(account);\n\t\t\t\t\t\tchoosePgpSignId(account);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisplayErrorDialog(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\t@TargetApi(Build.VERSION_CODES.JELLY_BEAN)\n\tprotected void setListItemBackgroundOnView(View view) {\n\t\tint sdk = android.os.Build.VERSION.SDK_INT;\n\t\tif (sdk < android.os.Build.VERSION_CODES.JELLY_BEAN) {\n\t\t\tview.setBackgroundDrawable(getResources().getDrawable(R.drawable.greybackground));\n\t\t} else {\n\t\t\tview.setBackground(getResources().getDrawable(R.drawable.greybackground));\n\t\t}\n\t}\n\n\tprotected void choosePgpSignId(Account account) {\n\t\txmppConnectionService.getPgpEngine().chooseKey(account, new UiCallback<Account>() {\n\t\t\t@Override\n\t\t\tpublic void success(Account account1) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void error(int errorCode, Account object) {\n\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void userInputRequried(PendingIntent pi, Account object) {\n\t\t\t\ttry {\n\t\t\t\t\tstartIntentSenderForResult(pi.getIntentSender(),\n\t\t\t\t\t\t\tREQUEST_CHOOSE_PGP_ID, null, 0, 0, 0);\n\t\t\t\t} catch (final SendIntentException ignored) {\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprotected void displayErrorDialog(final int errorCode) {\n\t\trunOnUiThread(() -> {\n\t\t\tBuilder builder = new Builder(XmppActivity.this);\n\t\t\tbuilder.setIconAttribute(android.R.attr.alertDialogIcon);\n\t\t\tbuilder.setTitle(getString(R.string.error));\n\t\t\tbuilder.setMessage(errorCode);\n\t\t\tbuilder.setNeutralButton(R.string.accept, null);\n\t\t\tbuilder.create().show();\n\t\t});\n\n\t}\n\n\tprotected void showAddToRosterDialog(final Contact contact) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(contact.getJid().toString());\n\t\tbuilder.setMessage(getString(R.string.not_in_roster));\n\t\tbuilder.setNegativeButton(getString(R.string.cancel), null);\n\t\tbuilder.setPositiveButton(getString(R.string.add_contact), (dialog, which) -> xmppConnectionService.createContact(contact,true));\n\t\tbuilder.create().show();\n\t}\n\n\tprivate void showAskForPresenceDialog(final Contact contact) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(contact.getJid().toString());\n\t\tbuilder.setMessage(R.string.request_presence_updates);\n\t\tbuilder.setNegativeButton(R.string.cancel, null);\n\t\tbuilder.setPositiveButton(R.string.request_now,\n\t\t\t\t(dialog, which) -> {\n\t\t\t\t\tif (xmppConnectionServiceBound) {\n\t\t\t\t\t\txmppConnectionService.sendPresencePacket(contact\n\t\t\t\t\t\t\t\t.getAccount(), xmppConnectionService\n\t\t\t\t\t\t\t\t.getPresenceGenerator()\n\t\t\t\t\t\t\t\t.requestPresenceUpdatesFrom(contact));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tbuilder.create().show();\n\t}\n\n\tprotected void quickEdit(String previousValue, @StringRes int hint, OnValueEdited callback) {\n\t\tquickEdit(previousValue, callback, hint, false, false);\n\t}\n\n\tprotected void quickEdit(String previousValue, @StringRes int hint, OnValueEdited callback, boolean permitEmpty) {\n\t\tquickEdit(previousValue, callback, hint, false, permitEmpty);\n\t}\n\n\tprotected void quickPasswordEdit(String previousValue, OnValueEdited callback) {\n\t\tquickEdit(previousValue, callback, R.string.password, true, false);\n\t}\n\n\t@SuppressLint(\"InflateParams\")\n\tprivate void quickEdit(final String previousValue,\n\t                       final OnValueEdited callback,\n\t                       final @StringRes int hint,\n\t                       boolean password,\n\t                       boolean permitEmpty) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tDialogQuickeditBinding binding = DataBindingUtil.inflate(getLayoutInflater(),R.layout.dialog_quickedit, null, false);\n\t\tif (password) {\n\t\t\tbinding.inputEditText.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n\t\t}\n\t\tbuilder.setPositiveButton(R.string.accept, null);\n\t\tif (hint != 0) {\n\t\t\tbinding.inputLayout.setHint(getString(hint));\n\t\t}\n\t\tbinding.inputEditText.requestFocus();\n\t\tif (previousValue != null) {\n\t\t\tbinding.inputEditText.getText().append(previousValue);\n\t\t}\n\t\tbuilder.setView(binding.getRoot());\n\t\tbuilder.setNegativeButton(R.string.cancel, null);\n\t\tfinal AlertDialog dialog = builder.create();\n\t\tdialog.setOnShowListener(d -> SoftKeyboardUtils.showKeyboard(binding.inputEditText));\n\t\tdialog.show();\n\t\tView.OnClickListener clickListener = v -> {\n\t\t\tString value = binding.inputEditText.getText().toString();\n\t\t\tif (!value.equals(previousValue) && (!value.trim().isEmpty() || permitEmpty)) {\n\t\t\t\tString error = callback.onValueEdited(value);\n\t\t\t\tif (error != null) {\n\t\t\t\t\tbinding.inputLayout.setError(error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSoftKeyboardUtils.hideSoftKeyboard(binding.inputEditText);\n\t\t\tdialog.dismiss();\n\t\t};\n\t\tdialog.getButton(DialogInterface.BUTTON_POSITIVE).setOnClickListener(clickListener);\n\t\tdialog.getButton(DialogInterface.BUTTON_NEGATIVE).setOnClickListener((v -> {\n\t\t\tSoftKeyboardUtils.hideSoftKeyboard(binding.inputEditText);\n\t\t\tdialog.dismiss();\n\t\t}));\n\t\tdialog.setOnDismissListener(dialog1 -> {\n\t\t\tSoftKeyboardUtils.hideSoftKeyboard(binding.inputEditText);\n        });\n\t}\n\n\tprotected boolean hasStoragePermission(int requestCode) {\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n\t\t\tif (checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {\n\t\t\t\trequestPermissions(new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, requestCode);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprotected void onActivityResult(int requestCode, int resultCode, final Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\tif (requestCode == REQUEST_INVITE_TO_CONVERSATION && resultCode == RESULT_OK) {\n\t\t\tmPendingConferenceInvite = ConferenceInvite.parse(data);\n\t\t\tif (xmppConnectionServiceBound && mPendingConferenceInvite != null) {\n\t\t\t\tif (mPendingConferenceInvite.execute(this)) {\n\t\t\t\t\tmToast = Toast.makeText(this, R.string.creating_conference, Toast.LENGTH_LONG);\n\t\t\t\t\tmToast.show();\n\t\t\t\t}\n\t\t\t\tmPendingConferenceInvite = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic int getWarningTextColor() {\n\t\treturn this.mColorRed;\n\t}\n\n\tpublic int getPixel(int dp) {\n\t\tDisplayMetrics metrics = getResources().getDisplayMetrics();\n\t\treturn ((int) (dp * metrics.density));\n\t}\n\n\tpublic boolean copyTextToClipboard(String text, int labelResId) {\n\t\tClipboardManager mClipBoardManager = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t\tString label = getResources().getString(labelResId);\n\t\tif (mClipBoardManager != null) {\n\t\t\tClipData mClipData = ClipData.newPlainText(label, text);\n\t\t\tmClipBoardManager.setPrimaryClip(mClipData);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected boolean neverCompressPictures() {\n\t\treturn getPreferences().getString(\"picture_compression\", getResources().getString(R.string.picture_compression)).equals(\"never\");\n\t}\n\n\tprotected boolean manuallyChangePresence() {\n\t\treturn getBooleanPreference(SettingsActivity.MANUALLY_CHANGE_PRESENCE, R.bool.manually_change_presence);\n\t}\n\n\tprotected String getShareableUri() {\n\t\treturn getShareableUri(false);\n\t}\n\n\tprotected String getShareableUri(boolean http) {\n\t\treturn null;\n\t}\n\n\tprotected void shareLink(boolean http) {\n\t\tString uri = getShareableUri(http);\n\t\tif (uri == null || uri.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\tIntent intent = new Intent(Intent.ACTION_SEND);\n\t\tintent.setType(\"text/plain\");\n\t\tintent.putExtra(Intent.EXTRA_TEXT, getShareableUri(http));\n\t\ttry {\n\t\t\tstartActivity(Intent.createChooser(intent, getText(R.string.share_uri_with)));\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\tToast.makeText(this, R.string.no_application_to_share_uri, Toast.LENGTH_SHORT).show();\n\t\t}\n\t}\n\n\tprotected void launchOpenKeyChain(long keyId) {\n\t\tPgpEngine pgp = XmppActivity.this.xmppConnectionService.getPgpEngine();\n\t\ttry {\n\t\t\tstartIntentSenderForResult(\n\t\t\t\t\tpgp.getIntentForKey(keyId).getIntentSender(), 0, null, 0,\n\t\t\t\t\t0, 0);\n\t\t} catch (Throwable e) {\n\t\t\tToast.makeText(XmppActivity.this, R.string.openpgp_error, Toast.LENGTH_SHORT).show();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onResume() {\n\t\tsuper.onResume();\n\t}\n\n\tprotected int findTheme() {\n\t\treturn ThemeHelper.find(this);\n\t}\n\n\t@Override\n\tpublic void onPause() {\n\t\tsuper.onPause();\n\t}\n\n\t@Override\n\tpublic boolean onMenuOpened(int id, Menu menu) {\n\t\tif(id == AppCompatDelegate.FEATURE_SUPPORT_ACTION_BAR && menu != null) {\n\t\t\tMenuDoubleTabUtil.recordMenuOpen();\n\t\t}\n\t\treturn super.onMenuOpened(id, menu);\n\t}\n\n\tprotected void showQrCode() {\n\t\tshowQrCode(getShareableUri());\n\t}\n\n\tprotected void showQrCode(final String uri) {\n\t\tif (uri == null || uri.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\tPoint size = new Point();\n\t\tgetWindowManager().getDefaultDisplay().getSize(size);\n\t\tfinal int width = (size.x < size.y ? size.x : size.y);\n\t\tBitmap bitmap = BarcodeProvider.create2dBarcodeBitmap(uri, width);\n\t\tImageView view = new ImageView(this);\n\t\tview.setBackgroundColor(Color.WHITE);\n\t\tview.setImageBitmap(bitmap);\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setView(view);\n\t\tbuilder.create().show();\n\t}\n\n\tprotected Account extractAccount(Intent intent) {\n\t\tString jid = intent != null ? intent.getStringExtra(EXTRA_ACCOUNT) : null;\n\t\ttry {\n\t\t\treturn jid != null ? xmppConnectionService.findAccountByJid(Jid.of(jid)) : null;\n\t\t} catch (IllegalArgumentException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic AvatarService avatarService() {\n\t\treturn xmppConnectionService.getAvatarService();\n\t}\n\n\tpublic void loadBitmap(Message message, ImageView imageView) {\n\t\tBitmap bm;\n\t\ttry {\n\t\t\tbm = xmppConnectionService.getFileBackend().getThumbnail(message, (int) (metrics.density * 288), true);\n\t\t} catch (IOException e) {\n\t\t\tbm = null;\n\t\t}\n\t\tif (bm != null) {\n\t\t\tcancelPotentialWork(message, imageView);\n\t\t\timageView.setImageBitmap(bm);\n\t\t\timageView.setBackgroundColor(0x00000000);\n\t\t} else {\n\t\t\tif (cancelPotentialWork(message, imageView)) {\n\t\t\t\timageView.setBackgroundColor(0xff333333);\n\t\t\t\timageView.setImageDrawable(null);\n\t\t\t\tfinal BitmapWorkerTask task = new BitmapWorkerTask(this, imageView);\n\t\t\t\tfinal AsyncDrawable asyncDrawable = new AsyncDrawable(\n\t\t\t\t\t\tgetResources(), null, task);\n\t\t\t\timageView.setImageDrawable(asyncDrawable);\n\t\t\t\ttry {\n\t\t\t\t\ttask.execute(message);\n\t\t\t\t} catch (final RejectedExecutionException ignored) {\n\t\t\t\t\tignored.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected interface OnValueEdited {\n\t\tString onValueEdited(String value);\n\t}\n\n\tpublic static class ConferenceInvite {\n\t\tprivate String uuid;\n\t\tprivate List<Jid> jids = new ArrayList<>();\n\n\t\tpublic static ConferenceInvite parse(Intent data) {\n\t\t\tConferenceInvite invite = new ConferenceInvite();\n\t\t\tinvite.uuid = data.getStringExtra(ChooseContactActivity.EXTRA_CONVERSATION);\n\t\t\tif (invite.uuid == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tinvite.jids.addAll(ChooseContactActivity.extractJabberIds(data));\n\t\t\treturn invite;\n\t\t}\n\n\t\tpublic boolean execute(XmppActivity activity) {\n\t\t\tXmppConnectionService service = activity.xmppConnectionService;\n\t\t\tConversation conversation = service.findConversationByUuid(this.uuid);\n\t\t\tif (conversation == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (conversation.getMode() == Conversation.MODE_MULTI) {\n\t\t\t\tfor (Jid jid : jids) {\n\t\t\t\t\tservice.invite(conversation, jid);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tjids.add(conversation.getJid().asBareJid());\n\t\t\t\treturn service.createAdhocConference(conversation.getAccount(), null, jids, activity.adhocCallback);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class BitmapWorkerTask extends AsyncTask<Message, Void, Bitmap> {\n\t\tprivate final WeakReference<ImageView> imageViewReference;\n\t\tprivate final WeakReference<XmppActivity> activity;\n\t\tprivate Message message = null;\n\n\t\tprivate BitmapWorkerTask(XmppActivity activity, ImageView imageView) {\n\t\t\tthis.activity = new WeakReference<>(activity);\n\t\t\tthis.imageViewReference = new WeakReference<>(imageView);\n\t\t}\n\n\t\t@Override\n\t\tprotected Bitmap doInBackground(Message... params) {\n\t\t\tif (isCancelled()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmessage = params[0];\n\t\t\ttry {\n\t\t\t\tXmppActivity activity = this.activity.get();\n\t\t\t\tif (activity != null && activity.xmppConnectionService != null) {\n\t\t\t\t\treturn activity.xmppConnectionService.getFileBackend().getThumbnail(message, (int) (activity.metrics.density * 288), false);\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void onPostExecute(Bitmap bitmap) {\n\t\t\tif (bitmap != null && !isCancelled()) {\n\t\t\t\tfinal ImageView imageView = imageViewReference.get();\n\t\t\t\tif (imageView != null) {\n\t\t\t\t\timageView.setImageBitmap(bitmap);\n\t\t\t\t\timageView.setBackgroundColor(0x00000000);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class AsyncDrawable extends BitmapDrawable {\n\t\tprivate final WeakReference<BitmapWorkerTask> bitmapWorkerTaskReference;\n\n\t\tprivate AsyncDrawable(Resources res, Bitmap bitmap, BitmapWorkerTask bitmapWorkerTask) {\n\t\t\tsuper(res, bitmap);\n\t\t\tbitmapWorkerTaskReference = new WeakReference<>(bitmapWorkerTask);\n\t\t}\n\n\t\tprivate BitmapWorkerTask getBitmapWorkerTask() {\n\t\t\treturn bitmapWorkerTaskReference.get();\n\t\t}\n\t}\n}\n", "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string name=\"action_settings\">Settings</string>\n    <string name=\"action_add\">New conversation</string>\n    <string name=\"action_accounts\">Manage accounts</string>\n    <string name=\"action_end_conversation\">End this conversation</string>\n    <string name=\"action_contact_details\">Contact details</string>\n    <string name=\"action_muc_details\">Group chat details</string>\n    <string name=\"action_secure\">Secure conversation</string>\n    <string name=\"action_add_account\">Add account</string>\n    <string name=\"action_edit_contact\">Edit name</string>\n    <string name=\"action_add_phone_book\">Add to address book</string>\n    <string name=\"action_delete_contact\">Delete from roster</string>\n    <string name=\"action_block_contact\">Block contact</string>\n    <string name=\"action_unblock_contact\">Unblock contact</string>\n    <string name=\"action_block_domain\">Block domain</string>\n    <string name=\"action_unblock_domain\">Unblock domain</string>\n    <string name=\"title_activity_manage_accounts\">Manage Accounts</string>\n    <string name=\"title_activity_settings\">Settings</string>\n    <string name=\"title_activity_sharewith\">Share with Conversation</string>\n    <string name=\"title_activity_start_conversation\">Start Conversation</string>\n    <string name=\"title_activity_choose_contact\">Choose Contact</string>\n    <string name=\"title_activity_choose_contacts\">Choose Contacts</string>\n    <string name=\"title_activity_share_via_account\">Share via account</string>\n    <string name=\"title_activity_block_list\">Block list</string>\n    <string name=\"just_now\">just now</string>\n    <string name=\"minute_ago\">1 min ago</string>\n    <string name=\"minutes_ago\">%d mins ago</string>\n    <string name=\"unread_conversations\">unread Conversations</string>\n    <string name=\"sending\">sending\u2026</string>\n    <string name=\"message_decrypting\">Decrypting message. Please wait\u2026</string>\n    <string name=\"pgp_message\">OpenPGP encrypted message</string>\n    <string name=\"nick_in_use\">Nickname is already in use</string>\n    <string name=\"invalid_muc_nick\">Invalid nickname</string>\n    <string name=\"admin\">Admin</string>\n    <string name=\"owner\">Owner</string>\n    <string name=\"moderator\">Moderator</string>\n    <string name=\"participant\">Participant</string>\n    <string name=\"visitor\">Visitor</string>\n    <string name=\"remove_contact_text\">Would you like to remove %s from your roster? The conversation associated with this contact will not be removed.</string>\n    <string name=\"block_contact_text\">Would you like to block %s from sending you messages?</string>\n    <string name=\"unblock_contact_text\">Would you like to unblock %s and allow them to send you messages?</string>\n    <string name=\"block_domain_text\">Block all contacts from %s?</string>\n    <string name=\"unblock_domain_text\">Unblock all contacts from %s?</string>\n    <string name=\"contact_blocked\">Contact blocked</string>\n    <string name=\"blocked\">Blocked</string>\n    <string name=\"remove_bookmark_text\">Would you like to remove %s as a bookmark? The conversation associated with this bookmark will not be removed.</string>\n    <string name=\"register_account\">Register new account on server</string>\n    <string name=\"change_password_on_server\">Change password on server</string>\n    <string name=\"share_with\">Share with\u2026</string>\n    <string name=\"start_conversation\">Start conversation</string>\n    <string name=\"invite_contact\">Invite contact</string>\n    <string name=\"contacts\">Contacts</string>\n    <string name=\"contact\">Contact</string>\n    <string name=\"cancel\">Cancel</string>\n    <string name=\"set\">Set</string>\n    <string name=\"add\">Add</string>\n    <string name=\"edit\">Edit</string>\n    <string name=\"delete\">Delete</string>\n    <string name=\"block\">Block</string>\n    <string name=\"unblock\">Unblock</string>\n    <string name=\"save\">Save</string>\n    <string name=\"ok\">OK</string>\n    <string name=\"crash_report_title\">Conversations has crashed</string>\n    <string name=\"crash_report_message\">By sending in stack traces you are helping the ongoing development of Conversations\\n<b>Warning:</b> This will use your XMPP account to send the stack trace to the developer.</string>\n    <string name=\"send_now\">Send now</string>\n    <string name=\"send_never\">Never ask again</string>\n    <string name=\"problem_connecting_to_account\">Unable to connect to account</string>\n    <string name=\"problem_connecting_to_accounts\">Unable to connect to multiple accounts</string>\n    <string name=\"touch_to_fix\">Touch here to manage your accounts</string>\n    <string name=\"attach_file\">Attach file</string>\n    <string name=\"not_in_roster\">The contact is not in your roster. Would you like to add it?</string>\n    <string name=\"add_contact\">Add contact</string>\n    <string name=\"send_failed\">delivery failed</string>\n    <string name=\"preparing_image\">Preparing image for transmission</string>\n    <string name=\"preparing_images\">Preparing images for transmission</string>\n    <string name=\"sharing_files_please_wait\">Sharing files. Please wait\u2026</string>\n    <string name=\"action_clear_history\">Clear history</string>\n    <string name=\"clear_conversation_history\">Clear Conversation History</string>\n    <string name=\"clear_histor_msg\">Are you sure you want to delete all messages within this conversation?\\n\\n<b>Warning:</b> This will not delete copies of those messages that are stored on other devices or servers.</string>\n    <string name=\"delete_file_dialog\">Delete file</string>\n    <string name=\"delete_file_dialog_msg\">Are you sure you want to delete this file?\\n\\n<b>Warning:</b> This will not delete copies of this file that are stored on other devices or servers. </string>\n    <string name=\"also_end_conversation\">End this conversation afterwards</string>\n    <string name=\"choose_presence\">Choose device</string>\n    <string name=\"send_unencrypted_message\">Send unencrypted message</string>\n    <string name=\"send_message\">Send message</string>\n    <string name=\"send_message_to_x\">Send message to %s</string>\n    <string name=\"send_omemo_message\">Send OMEMO encrypted message</string>\n    <string name=\"send_omemo_x509_message\">Send v\\\\OMEMO encrypted message</string>\n    <string name=\"send_pgp_message\">Send OpenPGP encrypted message</string>\n    <string name=\"your_nick_has_been_changed\">Your nickname has been changed</string>\n    <string name=\"send_unencrypted\">Send unencrypted</string>\n    <string name=\"decryption_failed\">Decryption failed. Maybe you don\u2019t have the proper private key.</string>\n    <string name=\"openkeychain_required\">OpenKeychain</string>\n    <string name=\"openkeychain_required_long\">Conversations utilizes a third party app called <b>OpenKeychain</b> to encrypt and decrypt messages and to manage your public keys.\\n\\nOpenKeychain is licensed under GPLv3 and available on F-Droid and Google Play.\\n\\n<small>(Please restart Conversations afterwards.)</small></string>\n    <string name=\"restart\">Restart</string>\n    <string name=\"install\">Install</string>\n    <string name=\"openkeychain_not_installed\">Please install OpenKeychain</string>\n    <string name=\"offering\">offering\u2026</string>\n    <string name=\"waiting\">waiting\u2026</string>\n    <string name=\"no_pgp_key\">No OpenPGP Key found</string>\n    <string name=\"contact_has_no_pgp_key\">Conversations is unable to encrypt your messages because your contact is not announcing his or hers public key.\\n\\n<small>Please ask your contact to setup OpenPGP.</small></string>\n    <string name=\"no_pgp_keys\">No OpenPGP Keys found</string>\n    <string name=\"contacts_have_no_pgp_keys\">Conversations is unable to encrypt your messages because your contacts are not announcing their public key.\\n\\n<small>Please ask your contacts to setup OpenPGP.</small></string>\n    <string name=\"pref_general\">General</string>\n    <string name=\"pref_accept_files\">Accept files</string>\n    <string name=\"pref_accept_files_summary\">Automatically accept files smaller than\u2026</string>\n    <string name=\"pref_attachments\">Attachments</string>\n    <string name=\"pref_notification_settings\">Notification</string>\n    <string name=\"pref_vibrate\">Vibrate</string>\n    <string name=\"pref_vibrate_summary\">Vibrate when a new message arrives</string>\n    <string name=\"pref_led\">LED Notification</string>\n    <string name=\"pref_led_summary\">Blink notification light when a new message arrives</string>\n    <string name=\"pref_sound\">Ringtone</string>\n    <string name=\"pref_sound_summary\">Play sound when a new message arrives</string>\n    <string name=\"pref_notification_grace_period\">Grace Period</string>\n    <string name=\"pref_notification_grace_period_summary\">The length of time Conversations keeps quiet after seeing activity on another device</string>\n    <string name=\"pref_advanced_options\">Advanced</string>\n    <string name=\"pref_never_send_crash\">Never send crash reports</string>\n    <string name=\"pref_never_send_crash_summary\">By sending in stack traces you are helping the ongoing development of Conversations</string>\n    <string name=\"pref_confirm_messages\">Confirm Messages</string>\n    <string name=\"pref_confirm_messages_summary\">Let your contacts know when you have received and read their messages</string>\n    <string name=\"pref_ui_options\">UI</string>\n    <string name=\"openpgp_error\">OpenKeychain reported an error</string>\n    <string name=\"accept\">Accept</string>\n    <string name=\"error\">An error has occurred</string>\n    <string name=\"recording_error\">Error</string>\n    <string name=\"your_account\">Your account</string>\n    <string name=\"send_presence_updates\">Send presence updates</string>\n    <string name=\"receive_presence_updates\">Receive presence updates</string>\n    <string name=\"ask_for_presence_updates\">Ask for presence updates</string>\n    <string name=\"attach_choose_picture\">Choose picture</string>\n    <string name=\"attach_take_picture\">Take picture</string>\n    <string name=\"preemptively_grant\">Preemptively grant subscription request</string>\n    <string name=\"error_not_an_image_file\">The file you selected is not an image</string>\n    <string name=\"error_compressing_image\">Error while converting the image file</string>\n    <string name=\"error_file_not_found\">File not found</string>\n    <string name=\"error_io_exception\">General I/O error. Maybe you ran out of storage space?</string>\n    <string name=\"error_security_exception_during_image_copy\">The app you used to select this image did not provide us with enough permissions to read the file.\\n\\n<small>Use a different file manager to choose an image</small></string>\n    <string name=\"account_status_unknown\">Unknown</string>\n    <string name=\"account_status_disabled\">Temporarily disabled</string>\n    <string name=\"account_status_online\">Online</string>\n    <string name=\"account_status_connecting\">Connecting\\u2026</string>\n    <string name=\"account_status_offline\">Offline</string>\n    <string name=\"account_status_unauthorized\">Unauthorized</string>\n    <string name=\"account_status_not_found\">Server not found</string>\n    <string name=\"account_status_no_internet\">No connectivity</string>\n    <string name=\"account_status_regis_fail\">Registration failed</string>\n    <string name=\"account_status_regis_conflict\">Username already in use</string>\n    <string name=\"account_status_regis_success\">Registration completed</string>\n    <string name=\"account_status_regis_not_sup\">Server does not support registration</string>\n    <string name=\"account_status_tls_error\">TLS negotiation failed</string>\n    <string name=\"account_status_policy_violation\">Policy violation</string>\n    <string name=\"account_status_incompatible_server\">Incompatible server</string>\n    <string name=\"account_status_stream_error\">Stream error</string>\n    <string name=\"account_status_stream_opening_error\">Stream opening error</string>\n    <string name=\"encryption_choice_unencrypted\">Unencrypted</string>\n    <string name=\"encryption_choice_otr\">OTR</string>\n    <string name=\"encryption_choice_pgp\">OpenPGP</string>\n    <string name=\"encryption_choice_omemo\">OMEMO</string>\n    <string name=\"mgmt_account_delete\">Delete account</string>\n    <string name=\"mgmt_account_disable\">Temporarily disable</string>\n    <string name=\"mgmt_account_publish_avatar\">Publish avatar</string>\n    <string name=\"mgmt_account_publish_pgp\">Publish OpenPGP public key</string>\n    <string name=\"unpublish_pgp\">Remove OpenPGP public key</string>\n    <string name=\"unpublish_pgp_message\">Are you sure you want to remove your OpenPGP public key from your presence announcement?\\nYour contacts will no longer be able to send you OpenPGP encrypted messages.</string>\n    <string name=\"openpgp_has_been_published\">OpenPGP public key has been published.</string>\n    <string name=\"mgmt_account_enable\">Enable account</string>\n    <string name=\"mgmt_account_are_you_sure\">Are you sure?</string>\n    <string name=\"mgmt_account_delete_confirm_text\">If you delete your account, your entire conversation history will be lost</string>\n    <string name=\"attach_record_voice\">Record voice</string>\n    <string name=\"account_settings_jabber_id\">Jabber ID</string>\n    <string name=\"block_jabber_id\">Block Jabber ID</string>\n    <string name=\"account_settings_example_jabber_id\">username@example.com</string>\n    <string name=\"password\">Password</string>\n    <string name=\"invalid_jid\">This is not a valid Jabber ID</string>\n    <string name=\"error_out_of_memory\">Out of memory. Image is too large</string>\n    <string name=\"add_phone_book_text\">Do you want to add %s to your address book?</string>\n    <string name=\"server_info_show_more\">Server info</string>\n    <string name=\"server_info_mam\">XEP-0313: MAM</string>\n    <string name=\"server_info_carbon_messages\">XEP-0280: Message Carbons</string>\n    <string name=\"server_info_csi\">XEP-0352: Client State Indication</string>\n    <string name=\"server_info_blocking\">XEP-0191: Blocking Command</string>\n    <string name=\"server_info_roster_version\">XEP-0237: Roster Versioning</string>\n    <string name=\"server_info_stream_management\">XEP-0198: Stream Management</string>\n    <string name=\"server_info_pep\">XEP-0163: PEP (Avatars / OMEMO)</string>\n    <string name=\"server_info_http_upload\">XEP-0363: HTTP File Upload</string>\n    <string name=\"server_info_push\">XEP-0357: Push</string>\n    <string name=\"server_info_available\">available</string>\n    <string name=\"server_info_unavailable\">unavailable</string>\n    <string name=\"missing_public_keys\">Missing public key announcements</string>\n    <string name=\"last_seen_now\">last seen just now</string>\n    <string name=\"last_seen_min\">last seen 1 minute ago</string>\n    <string name=\"last_seen_mins\">last seen %d minutes ago</string>\n    <string name=\"last_seen_hour\">last seen 1 hour ago</string>\n    <string name=\"last_seen_hours\">last seen %d hours ago</string>\n    <string name=\"last_seen_day\">last seen 1 day ago</string>\n    <string name=\"last_seen_days\">last seen %d days ago</string>\n    <string name=\"install_openkeychain\">Encrypted message. Please install OpenKeychain to decrypt.</string>\n    <string name=\"openpgp_messages_found\">OpenPGP encrypted messages found</string>\n    <string name=\"openpgp_key_id\">OpenPGP Key ID</string>\n    <string name=\"omemo_fingerprint\">OMEMO fingerprint</string>\n    <string name=\"omemo_fingerprint_x509\">v\\\\OMEMO fingerprint</string>\n    <string name=\"omemo_fingerprint_selected_message\">OMEMO fingerprint of message</string>\n    <string name=\"omemo_fingerprint_x509_selected_message\">v\\\\OMEMO fingerprint of message</string>\n    <string name=\"other_devices\">Other devices</string>\n    <string name=\"trust_omemo_fingerprints\">Trust OMEMO Fingerprints</string>\n    <string name=\"fetching_keys\">Fetching keys\u2026</string>\n    <string name=\"done\">Done</string>\n    <string name=\"decrypt\">Decrypt</string>\n    <string name=\"conferences\">Group chats</string>\n    <string name=\"search\">Search</string>\n    <string name=\"dialog_title_create_contact\">Create Contact</string>\n    <string name=\"enter_contact\">Enter Contact</string>\n    <string name=\"join_conference\">Join group chat</string>\n    <string name=\"dialog_title_join_conference\">Join Group Chat</string>\n    <string name=\"delete_contact\">Delete contact</string>\n    <string name=\"view_contact_details\">View contact details</string>\n    <string name=\"block_contact\">Block contact</string>\n    <string name=\"unblock_contact\">Unblock contact</string>\n    <string name=\"create\">Create</string>\n    <string name=\"select\">Select</string>\n    <string name=\"contact_already_exists\">The contact already exists</string>\n    <string name=\"join\">Join</string>\n    <string name=\"conference_address\">Group chat address</string>\n    <string name=\"conference_address_example\">room@conference.example.com/nick</string>\n    <string name=\"save_as_bookmark\">Save as bookmark</string>\n    <string name=\"delete_bookmark\">Delete bookmark</string>\n    <string name=\"bookmark_already_exists\">This bookmark already exists</string>\n    <string name=\"action_edit_subject\">Edit group chat subject</string>\n    <string name=\"topic\">Topic</string>\n    <string name=\"joining_conference\">Joining group chat\u2026</string>\n    <string name=\"leave\">Leave</string>\n    <string name=\"contact_added_you\">Contact added you to contact list</string>\n    <string name=\"add_back\">Add back</string>\n    <string name=\"contact_has_read_up_to_this_point\">%s has read up to this point</string>\n    <string name=\"contacts_have_read_up_to_this_point\">%s have read up to this point</string>\n    <string name=\"contacts_and_n_more_have_read_up_to_this_point\">%1$s +%2$d more have read up to this point</string>\n    <string name=\"everyone_has_read_up_to_this_point\">Everyone has read up to this point</string>\n    <string name=\"publish\">Publish</string>\n    <string name=\"touch_to_choose_picture\">Touch avatar to select picture from gallery</string>\n    <string name=\"publishing\">Publishing\u2026</string>\n    <string name=\"error_publish_avatar_server_reject\">The server rejected your publication</string>\n    <string name=\"error_publish_avatar_converting\">Something went wrong while converting your picture</string>\n    <string name=\"error_saving_avatar\">Could not save avatar to disk</string>\n    <string name=\"or_long_press_for_default\">(Or long press to bring back default)</string>\n    <string name=\"error_publish_avatar_no_server_support\">Your server does not support the publication of avatars</string>\n    <string name=\"private_message\">whispered</string>\n    <string name=\"private_message_to\">to %s</string>\n    <string name=\"send_private_message_to\">Send private message to %s</string>\n    <string name=\"connect\">Connect</string>\n    <string name=\"account_already_exists\">This account already exists</string>\n    <string name=\"next\">Next</string>\n    <string name=\"server_info_session_established\">Current session established</string>\n    <string name=\"skip\">Skip</string>\n    <string name=\"disable_notifications\">Disable notifications</string>\n    <string name=\"enable\">Enable</string>\n    <string name=\"conference_requires_password\">Group chat requires password</string>\n    <string name=\"enter_password\">Enter password</string>\n    <string name=\"request_presence_updates\">Please request presence updates from your contact first.\\n\\n<small>This will be used to determine what client(s) your contact is using.</small></string>\n    <string name=\"request_now\">Request now</string>\n    <string name=\"ignore\">Ignore</string>\n    <string name=\"without_mutual_presence_updates\"><b>Warning:</b> Sending this without mutual presence updates could cause unexpected problems.\\n\\n<small>Go to contact details to verify your presence subscriptions.</small></string>\n    <string name=\"pref_security_settings\">Security</string>\n    <string name=\"pref_allow_message_correction\">Allow message correction</string>\n    <string name=\"pref_allow_message_correction_summary\">Allow your contacts to retroactively edit their messages</string>\n    <string name=\"pref_expert_options\">Expert settings</string>\n    <string name=\"pref_expert_options_summary\">Please be careful with these</string>\n    <string name=\"title_activity_about\">About Conversations</string>\n    <string name=\"pref_about_conversations_summary\">Build and licensing information</string>\n    <string name=\"title_pref_quiet_hours\">Quiet Hours</string>\n    <string name=\"title_pref_quiet_hours_start_time\">Start time</string>\n    <string name=\"title_pref_quiet_hours_end_time\">End time</string>\n    <string name=\"title_pref_enable_quiet_hours\">Enable quiet hours</string>\n    <string name=\"pref_quiet_hours_summary\">Notifications will be silenced during quiet hours</string>\n    <string name=\"pref_use_send_button_to_indicate_status\">Send button indicates status</string>\n    <string name=\"pref_use_indicate_received\">Request message receipts</string>\n    <string name=\"pref_use_indicate_received_summary\">Received messages will be marked with a green tick if supported</string>\n    <string name=\"pref_use_send_button_to_indicate_status_summary\">Colorize send button to indicate contact status</string>\n    <string name=\"pref_expert_options_other\">Other</string>\n    <string name=\"pref_autojoin\">Automatically join group chats</string>\n    <string name=\"pref_autojoin_summary\">Respect the autojoin flag in group chat bookmarks</string>\n    <string name=\"toast_message_omemo_fingerprint\">OMEMO fingerprint copied to clipboard!</string>\n    <string name=\"conference_banned\">You are banned from this group chat</string>\n    <string name=\"conference_members_only\">This group chat is members only</string>\n    <string name=\"conference_resource_constraint\">Resource constraint</string>\n    <string name=\"conference_kicked\">You have been kicked from this group chat</string>\n    <string name=\"conference_shutdown\">The group chat was shut down</string>\n    <string name=\"conference_unknown_error\">You are no longer in this group chat</string>\n    <string name=\"using_account\">using account %s</string>\n    <string name=\"checking_x\">Checking %s on HTTP host</string>\n    <string name=\"not_connected_try_again\">You are not connected. Try again later</string>\n    <string name=\"check_x_filesize\">Check %s size</string>\n    <string name=\"check_x_filesize_on_host\">Check %1$s size on %2$s</string>\n    <string name=\"message_options\">Message options</string>\n    <string name=\"quote\">Quote</string>\n    <string name=\"paste_as_quote\">Paste as quote</string>\n    <string name=\"copy_original_url\">Copy original URL</string>\n    <string name=\"send_again\">Send again</string>\n    <string name=\"file_url\">File URL</string>\n    <string name=\"url_copied_to_clipboard\">Copied URL to clipboard</string>\n    <string name=\"jabber_id_copied_to_clipboard\">Copied Jabberd ID to clipboard</string>\n    <string name=\"web_address\">web address</string>\n    <string name=\"scan_qr_code\">Scan 2D Barcode</string>\n    <string name=\"show_qr_code\">Show 2D Barcode</string>\n    <string name=\"show_block_list\">Show block list</string>\n    <string name=\"account_details\">Account details</string>\n    <string name=\"confirm\">Confirm</string>\n    <string name=\"try_again\">Try again</string>\n    <string name=\"conversations_foreground_service\">Conversations</string>\n    <string name=\"pref_keep_foreground_service\">Keep service in foreground</string>\n    <string name=\"pref_keep_foreground_service_summary\">Prevents the operating system from killing your connection</string>\n    <string name=\"pref_export_logs\">Export history</string>\n    <string name=\"pref_export_logs_summary\">Write conversations history logs to SD card</string>\n    <string name=\"notification_export_logs_title\">Writing logs to SD card</string>\n    <string name=\"choose_file\">Choose file</string>\n    <string name=\"receiving_x_file\">Receiving %1$s (%2$d%% completed)</string>\n    <string name=\"download_x_file\">Download %s</string>\n    <string name=\"delete_x_file\">Delete %s</string>\n    <string name=\"file\">file</string>\n    <string name=\"open_x_file\">Open %s</string>\n    <string name=\"sending_file\">sending (%1$d%% completed)</string>\n    <string name=\"preparing_file\">Preparing file for transmission</string>\n    <string name=\"x_file_offered_for_download\">%s offered for download</string>\n    <string name=\"cancel_transmission\">Cancel transmission</string>\n    <string name=\"file_transmission_failed\">file transmission failed</string>\n    <string name=\"file_deleted\">The file has been deleted</string>\n    <string name=\"no_application_found_to_open_file\">No application found to open file</string>\n    <string name=\"no_application_found_to_open_link\">No application found to open link</string>\n    <string name=\"no_application_found_to_view_contact\">No application found to view contact</string>\n    <string name=\"pref_show_dynamic_tags\">Dynamic Tags</string>\n    <string name=\"pref_show_dynamic_tags_summary\">Display read-only tags underneath contacts</string>\n    <string name=\"enable_notifications\">Enable notifications</string>\n    <string name=\"no_conference_server_found\">No group chat server found</string>\n    <string name=\"conference_creation_failed\">Group chat creation failed!</string>\n    <string name=\"account_image_description\">Account avatar</string>\n    <string name=\"copy_omemo_clipboard_description\">Copy OMEMO fingerprint to clipboard</string>\n    <string name=\"regenerate_omemo_key\">Regenerate OMEMO key</string>\n    <string name=\"clear_other_devices\">Clear devices</string>\n    <string name=\"clear_other_devices_desc\">Are you sure you want to clear all other devices from the OMEMO announcement? The next time your devices connect, they will reannounce themselves, but they might not receive messages sent in the meantime.</string>\n    <string name=\"error_no_keys_to_trust_server_error\">There are no usable keys available for this contact.\\nFetching new keys from the server has been unsuccessful. Maybe there is something wrong with your contact\u2019s server.</string>\n    <string name=\"error_no_keys_to_trust_presence\">There are no usable keys available for this contact.\\nMake sure you have mutual presence subscription.</string>\n    <string name=\"error_trustkeys_title\">Something went wrong</string>\n    <string name=\"fetching_history_from_server\">Fetching history from server</string>\n    <string name=\"no_more_history_on_server\">No more history on server</string>\n    <string name=\"updating\">Updating\u2026</string>\n    <string name=\"password_changed\">Password changed!</string>\n    <string name=\"could_not_change_password\">Could not change password</string>\n    <string name=\"change_password\">Change password</string>\n    <string name=\"current_password\">Current password</string>\n    <string name=\"new_password\">New password</string>\n    <string name=\"password_should_not_be_empty\">Password should not be empty</string>\n    <string name=\"enable_all_accounts\">Enable all accounts</string>\n    <string name=\"disable_all_accounts\">Disable all accounts</string>\n    <string name=\"perform_action_with\">Perform action with</string>\n    <string name=\"no_affiliation\">No affiliation</string>\n    <string name=\"no_role\">Offline</string>\n    <string name=\"outcast\">Outcast</string>\n    <string name=\"member\">Member</string>\n    <string name=\"advanced_mode\">Advanced mode</string>\n    <string name=\"grant_membership\">Grant membership</string>\n    <string name=\"remove_membership\">Revoke membership</string>\n    <string name=\"grant_admin_privileges\">Grant admin privileges</string>\n    <string name=\"remove_admin_privileges\">Revoke admin privileges</string>\n    <string name=\"remove_from_room\">Remove from group chat</string>\n    <string name=\"could_not_change_affiliation\">Could not change affiliation of %s</string>\n    <string name=\"ban_from_conference\">Ban from group chat</string>\n    <string name=\"removing_from_public_conference\">You are trying to remove %s from a public group chat. The only way to do that is to ban that user for ever.</string>\n    <string name=\"ban_now\">Ban now</string>\n    <string name=\"could_not_change_role\">Could not change role of %s</string>\n    <string name=\"public_conference\">Publicly accessible group chat</string>\n    <string name=\"private_conference\">Private, members only group chat</string>\n    <string name=\"conference_options\">Group chat options</string>\n    <string name=\"members_only\">Private, members only</string>\n    <string name=\"non_anonymous\">Non-anonymous</string>\n    <string name=\"moderated\">Moderated</string>\n    <string name=\"you_are_not_participating\">You are not participating</string>\n    <string name=\"modified_conference_options\">Modified group chat options!</string>\n    <string name=\"could_not_modify_conference_options\">Could not modify group chat options</string>\n    <string name=\"never\">Never</string>\n    <string name=\"until_further_notice\">Until further notice</string>\n    <string name=\"snooze\">Snooze</string>\n    <string name=\"reply\">Reply</string>\n    <string name=\"mark_as_read\">Mark as read</string>\n    <string name=\"pref_input_options\">Input</string>\n    <string name=\"pref_enter_is_send\">Enter is send</string>\n    <string name=\"pref_enter_is_send_summary\">Use enter key to send message</string>\n    <string name=\"pref_display_enter_key\">Show enter key</string>\n    <string name=\"pref_display_enter_key_summary\">Change the emoticons key to an enter key</string>\n    <string name=\"audio\">audio</string>\n    <string name=\"video\">video</string>\n    <string name=\"image\">image</string>\n    <string name=\"pdf_document\">PDF document</string>\n    <string name=\"apk\">Android App</string>\n    <string name=\"vcard\">Contact</string>\n    <string name=\"touch_to_open_conversations\">Touch to open Conversations</string>\n    <string name=\"avatar_has_been_published\">Avatar has been published!</string>\n    <string name=\"sending_x_file\">Sending %s</string>\n    <string name=\"offering_x_file\">Offering %s</string>\n    <string name=\"hide_offline\">Hide offline</string>\n    <string name=\"contact_is_typing\">%s is typing\u2026</string>\n    <string name=\"contact_has_stopped_typing\">%s has stopped typing</string>\n    <string name=\"contacts_are_typing\">%s are typing\u2026</string>\n    <string name=\"contacts_have_stopped_typing\">%s have stopped typing</string>\n    <string name=\"pref_chat_states\">Typing notifications</string>\n    <string name=\"pref_chat_states_summary\">Let your contacts know when you are writing messages to them</string>\n    <string name=\"send_location\">Send location</string>\n    <string name=\"show_location\">Show location</string>\n    <string name=\"no_application_found_to_display_location\">No application found to display location</string>\n    <string name=\"location\">Location</string>\n    <string name=\"title_undo_swipe_out_conversation\">Conversation closed</string>\n    <string name=\"title_undo_swipe_out_muc\">Left group chat</string>\n    <string name=\"pref_dont_trust_system_cas_title\">Don\u2019t trust system CAs</string>\n    <string name=\"pref_dont_trust_system_cas_summary\">All certificates must be manually approved</string>\n    <string name=\"pref_remove_trusted_certificates_title\">Remove certificates</string>\n    <string name=\"pref_remove_trusted_certificates_summary\">Delete manually approved certificates</string>\n    <string name=\"toast_no_trusted_certs\">No manually approved certificates</string>\n    <string name=\"dialog_manage_certs_title\">Remove certificates</string>\n    <string name=\"dialog_manage_certs_positivebutton\">Delete selection</string>\n    <string name=\"dialog_manage_certs_negativebutton\">Cancel</string>\n    <plurals name=\"toast_delete_certificates\">\n        <item quantity=\"one\">%d certificate deleted</item>\n        <item quantity=\"other\">%d certificates deleted</item>\n    </plurals>\n    <string name=\"pref_quick_action_summary\">Replace send button with quick action</string>\n    <string name=\"pref_quick_action\">Quick Action</string>\n    <string name=\"none\">None</string>\n    <string name=\"recently_used\">Most recently used</string>\n    <string name=\"choose_quick_action\">Choose quick action</string>\n    <string name=\"search_contacts\">Search contacts</string>\n    <string name=\"search_groups\">Search group chats</string>\n    <string name=\"send_private_message\">Send private message</string>\n    <string name=\"user_has_left_conference\">%1$s has left the group chat!</string>\n    <string name=\"username\">Username</string>\n    <string name=\"username_hint\">Username</string>\n    <string name=\"invalid_username\">This is not a valid username</string>\n    <string name=\"download_failed_server_not_found\">Download failed: Server not found</string>\n    <string name=\"download_failed_file_not_found\">Download failed: File not found</string>\n    <string name=\"download_failed_could_not_connect\">Download failed: Could not connect to host</string>\n    <string name=\"download_failed_could_not_write_file\">Download failed: Could not write file</string>\n    <string name=\"account_status_tor_unavailable\">Tor network unavailable</string>\n    <string name=\"account_status_bind_failure\">Bind failure</string>\n    <string name=\"account_status_host_unknown\">Server not responsible for domain</string>\n    <string name=\"server_info_broken\">Broken</string>\n    <string name=\"pref_presence_settings\">Availability</string>\n    <string name=\"pref_away_when_screen_off\">Away when screen is off</string>\n    <string name=\"pref_away_when_screen_off_summary\">Marks your resource as away when the screen is turned off</string>\n    <string name=\"pref_dnd_on_silent_mode\">\u201cDo not disturb\u201d in silent mode</string>\n    <string name=\"pref_dnd_on_silent_mode_summary\">Marks your resource as \u201cDo not disturb\u201d when device is in silent mode</string>\n    <string name=\"pref_treat_vibrate_as_silent\">Treat vibrate as silent mode</string>\n    <string name=\"pref_treat_vibrate_as_dnd_summary\">Marks your resource as \u201cDo not disturb\u201d when device is on vibrate</string>\n    <string name=\"pref_show_connection_options\">Extended connection settings</string>\n    <string name=\"pref_show_connection_options_summary\">Show hostname and port settings when setting up an account</string>\n    <string name=\"hostname_example\">xmpp.example.com</string>\n    <string name=\"action_add_account_with_certificate\">Add account with certificate</string>\n    <string name=\"unable_to_parse_certificate\">Unable to parse certificate</string>\n    <string name=\"authenticate_with_certificate\">Leave empty to authenticate w/ certificate</string>\n    <string name=\"mam_prefs\">Archiving preferences</string>\n    <string name=\"server_side_mam_prefs\">Server-side archiving preferences</string>\n    <string name=\"fetching_mam_prefs\">Fetching archiving preferences. Please wait\u2026</string>\n    <string name=\"unable_to_fetch_mam_prefs\">Unable to fetch archiving preferences</string>\n    <string name=\"captcha_required\">Captcha required</string>\n    <string name=\"captcha_hint\">Enter the text from the image above</string>\n    <string name=\"certificate_chain_is_not_trusted\">Certificate chain is not trusted</string>\n    <string name=\"jid_does_not_match_certificate\">Jabber ID does not match certificate</string>\n    <string name=\"action_renew_certificate\">Renew certificate</string>\n    <string name=\"error_fetching_omemo_key\">Error fetching OMEMO key!</string>\n    <string name=\"verified_omemo_key_with_certificate\">Verified OMEMO key with certificate!</string>\n    <string name=\"device_does_not_support_certificates\">Your device does not support the selection of client certificates!</string>\n    <string name=\"pref_connection_options\">Connection</string>\n    <string name=\"pref_use_tor\">Connect via Tor</string>\n    <string name=\"pref_use_tor_summary\">Tunnel all connections through the Tor network. Requires Orbot</string>\n    <string name=\"account_settings_hostname\">Hostname</string>\n    <string name=\"account_settings_port\">Port</string>\n    <string name=\"hostname_or_onion\">Server- or .onion-Address</string>\n    <string name=\"not_a_valid_port\">This is not a valid port number</string>\n    <string name=\"not_valid_hostname\">This is not a valid hostname</string>\n    <string name=\"connected_accounts\">%1$d of %2$d accounts connected</string>\n    <plurals name=\"x_messages\">\n        <item quantity=\"one\">%d message</item>\n        <item quantity=\"other\">%d messages</item>\n    </plurals>\n    <string name=\"load_more_messages\">Load more messages</string>\n    <string name=\"shared_file_with_x\">Shared file with %s</string>\n    <string name=\"shared_image_with_x\">Shared image with %s</string>\n    <string name=\"shared_images_with_x\">Shared images with %s</string>\n    <string name=\"shared_text_with_x\">Shared text with %s</string>\n    <string name=\"no_storage_permission\">Conversations needs access to external storage</string>\n    <string name=\"no_camera_permission\">Conversations needs access to the camera</string>\n    <string name=\"sync_with_contacts\">Synchronize with contacts</string>\n    <string name=\"sync_with_contacts_long\">Conversations wants to match your XMPP roster with your contacts to show their full names and avatars.\\n\\nConversations will only read your contacts and match them locally without uploading them to your server.\\n\\nYou will now be asked to grant permission to access your contacts.</string>\n    <string name=\"notify_on_all_messages\">Notify on all messages</string>\n    <string name=\"notify_only_when_highlighted\">Notify only when mentioned</string>\n    <string name=\"notify_never\">Notifications disabled</string>\n    <string name=\"notify_paused\">Notifications paused</string>\n    <string name=\"pref_picture_compression\">Image Compression</string>\n    <string name=\"pref_picture_compression_summary\">Resize and compress images</string>\n    <string name=\"always\">Always</string>\n    <string name=\"automatically\">Automatically</string>\n    <string name=\"battery_optimizations_enabled\">Battery optimizations enabled</string>\n    <string name=\"battery_optimizations_enabled_explained\">Your device is doing some heavy battery optimizations on Conversations that might lead to delayed notifications or even message loss.\\nIt is recommended to disable those.</string>\n    <string name=\"battery_optimizations_enabled_dialog\">Your device is doing some heavy battery optimizations on Conversations that might lead to delayed notifications or even message loss.\\n\\nYou will now be asked to disable those.</string>\n    <string name=\"disable\">Disable</string>\n    <string name=\"selection_too_large\">The selected area is too large</string>\n    <string name=\"no_accounts\">(No activated accounts)</string>\n    <string name=\"this_field_is_required\">This field is required</string>\n    <string name=\"correct_message\">Correct message</string>\n    <string name=\"send_corrected_message\">Send corrected message</string>\n    <string name=\"no_keys_just_confirm\">You already trust this contact. By selecting \\'done\\' you are just confirming that %s is part of this group chat.</string>\n    <string name=\"this_account_is_disabled\">You have disabled this account</string>\n    <string name=\"security_error_invalid_file_access\">Security error: Invalid file access</string>\n    <string name=\"no_application_to_share_uri\">No application found to share URI</string>\n    <string name=\"share_uri_with\">Share URI with\u2026</string>\n    <string name=\"welcome_header\" translatable=\"false\">Join the Conversation</string>\n    <string name=\"welcome_text\">Jabber is a provider independent instant messaging network. You can use this client with what ever Jabber server you choose.\\nHowever for your convenience we made it easy to create an account on conversations.im\u00b9; a provider specially suited for the use with Conversations.</string>\n    <string name=\"magic_create_text\">We will guide you through the process of creating an account on conversations.im.\u00b9\\nWhen picking conversations.im as a provider you will be able to communicate with users of other providers by giving them your full Jabber ID.</string>\n    <string name=\"your_full_jid_will_be\">Your full Jabber ID will be: %s</string>\n    <string name=\"create_account\">Create Account</string>\n    <string name=\"use_own_provider\">Use my own provider</string>\n    <string name=\"pick_your_username\">Pick your username</string>\n    <string name=\"pref_manually_change_presence\">Manage availability manually</string>\n    <string name=\"pref_manually_change_presence_summary\">Set your availability when editing your status message.</string>\n    <string name=\"status_message\">Status message</string>\n    <string name=\"presence_chat\">Free for Chat</string>\n    <string name=\"presence_online\">Online</string>\n    <string name=\"presence_away\">Away</string>\n    <string name=\"presence_xa\">Not Available</string>\n    <string name=\"presence_dnd\">Busy</string>\n    <string name=\"secure_password_generated\">A secure password has been generated</string>\n    <string name=\"device_does_not_support_battery_op\">Your device does not support opting out of battery optimization</string>\n    <string name=\"registration_please_wait\">Registration failed: Try again later</string>\n    <string name=\"registration_password_too_weak\">Registration failed: Password too weak</string>\n    <string name=\"dialog_title_create_conference\">Create Group Chat</string>\n    <string name=\"choose_participants\">Choose participants</string>\n    <string name=\"creating_conference\">Creating group chat\u2026</string>\n    <string name=\"invite_again\">Invite again</string>\n    <string name=\"gp_disable\">Disable</string>\n    <string name=\"gp_short\">Short</string>\n    <string name=\"gp_medium\">Medium</string>\n    <string name=\"gp_long\">Long</string>\n    <string name=\"pref_broadcast_last_activity\">Broadcast Last User Interaction</string>\n    <string name=\"pref_broadcast_last_activity_summary\">Let all your contacts know when you use Conversations</string>\n    <string name=\"pref_privacy\">Privacy</string>\n    <string name=\"pref_theme_options\">Theme</string>\n    <string name=\"pref_theme_options_summary\">Select the color palette</string>\n    <string name=\"pref_theme_light\">Light theme</string>\n    <string name=\"pref_theme_dark\">Dark theme</string>\n    <string name=\"pref_use_green_background\">Green Background</string>\n    <string name=\"pref_use_green_background_summary\">Use green background for received messages</string>\n    <string name=\"unable_to_connect_to_keychain\">Unable to connect to OpenKeychain</string>\n    <string name=\"this_device_is_no_longer_in_use\">This device is no longer in use</string>\n    <string name=\"type_pc\">Computer</string>\n    <string name=\"type_phone\">Mobile phone</string>\n    <string name=\"type_tablet\">Tablet</string>\n    <string name=\"type_web\">Web browser</string>\n    <string name=\"type_console\">Console</string>\n    <string name=\"payment_required\">Payment required</string>\n    <string name=\"missing_internet_permission\">Missing internet permission</string>\n    <string name=\"me\">Me</string>\n    <string name=\"contact_asks_for_presence_subscription\">Contact asks for presence subscription</string>\n    <string name=\"allow\">Allow</string>\n    <string name=\"no_permission_to_access_x\">No permission to access %s</string>\n    <string name=\"remote_server_not_found\">Remote server not found</string>\n    <string name=\"remote_server_timeout\">Remote server timeout</string>\n    <string name=\"unable_to_update_account\">Unable to update account</string>\n    <string name=\"report_jid_as_spammer\">Report this JID as sending unwanted messages.</string>\n    <string name=\"pref_delete_omemo_identities\">Delete OMEMO identities</string>\n    <string name=\"pref_delete_omemo_identities_summary\">Regenerate your OMEMO keys. All your contacts will have to verify you again. Use this only as a last resort.</string>\n    <string name=\"delete_selected_keys\">Delete selected keys</string>\n    <string name=\"error_publish_avatar_offline\">You need to be connected to publish your avatar.</string>\n    <string name=\"show_error_message\">Show error message</string>\n    <string name=\"error_message\">Error Message</string>\n    <string name=\"data_saver_enabled\">Data saver enabled</string>\n    <string name=\"data_saver_enabled_explained\">Your operating system is restricting Conversations from accessing the Internet when in background. To receive notifications of new messages you should allow Conversations unrestricted access when Data saver is on.\\nConversations will still make an effort to save data when possible.</string>\n    <string name=\"device_does_not_support_data_saver\">Your device does not support disabling Data saver for Conversations.</string>\n    <string name=\"error_unable_to_create_temporary_file\">Unable to create temporary file</string>\n    <string name=\"this_device_has_been_verified\">This device has been verified</string>\n    <string name=\"copy_fingerprint\">Copy fingerprint</string>\n    <string name=\"all_omemo_keys_have_been_verified\">All OMEMO keys have been verified</string>\n    <string name=\"barcode_does_not_contain_fingerprints_for_this_conversation\">Barcode does not contain fingerprints for this conversation.</string>\n    <string name=\"verified_fingerprints\">Verified fingerprints</string>\n    <string name=\"use_camera_icon_to_scan_barcode\">Use the camera to scan a contact\u2019s barcode</string>\n    <string name=\"please_wait_for_keys_to_be_fetched\">Please wait for keys to be fetched</string>\n    <string name=\"share_as_barcode\">Share as Barcode</string>\n    <string name=\"share_as_uri\">Share as XMPP URI</string>\n    <string name=\"share_as_http\">Share as HTTP link</string>\n    <string name=\"pref_blind_trust_before_verification\">Blind Trust Before Verification</string>\n    <string name=\"pref_blind_trust_before_verification_summary\">Automatically trust all new devices of contacts that haven\u2019t been verified before, and prompt for manual confirmation each time a verified contact adds a new device.</string>\n    <string name=\"blindly_trusted_omemo_keys\">Blindly trusted OMEMO keys</string>\n    <string name=\"not_trusted\">Untrusted</string>\n    <string name=\"invalid_barcode\">Invalid 2D barcode</string>\n    <string name=\"pref_clean_cache_summary\">Clean cache folder (used by Camera Application)</string>\n    <string name=\"pref_clean_cache\">Clean cache</string>\n    <string name=\"pref_clean_private_storage\">Clean private storage</string>\n    <string name=\"pref_clean_private_storage_summary\">Clean private storage where files are kept (They can be re-downloaded from the server)</string>\n    <string name=\"i_followed_this_link_from_a_trusted_source\">I followed this link from a trusted source</string>\n    <string name=\"verifying_omemo_keys_trusted_source\">You are about to verify the OMEMO keys of %1$s after clicking a link. This is only secure if you followed this link from a trusted source where only %2$s could have published this link.</string>\n    <string name=\"verify_omemo_keys\">Verify OMEMO keys</string>\n    <string name=\"show_inactive_devices\">Show inactive</string>\n    <string name=\"hide_inactive_devices\">Hide inactive</string>\n    <string name=\"distrust_omemo_key\">Distrust device</string>\n    <string name=\"distrust_omemo_key_text\">Are you sure you want to remove the verification for this device?\\nThis device and messages coming from that device will be marked as untrusted.</string>\n    <plurals name=\"seconds\">\n        <item quantity=\"one\">%d second</item>\n        <item quantity=\"other\">%d seconds</item>\n    </plurals>\n    <plurals name=\"minutes\">\n        <item quantity=\"one\">%d minute</item>\n        <item quantity=\"other\">%d minutes</item>\n    </plurals>\n    <plurals name=\"hours\">\n        <item quantity=\"one\">%d hour</item>\n        <item quantity=\"other\">%d hours</item>\n    </plurals>\n    <plurals name=\"days\">\n        <item quantity=\"one\">%d day</item>\n        <item quantity=\"other\">%d days</item>\n    </plurals>\n    <plurals name=\"weeks\">\n        <item quantity=\"one\">%d week</item>\n        <item quantity=\"other\">%d weeks</item>\n    </plurals>\n    <plurals name=\"months\">\n        <item quantity=\"one\">%d month</item>\n        <item quantity=\"other\">%d months</item>\n    </plurals>\n    <string name=\"pref_automatically_delete_messages\">Automatic message deletion</string>\n    <string name=\"pref_automatically_delete_messages_description\">Automatically delete messages from this device that are older than the configured time frame.</string>\n    <string name=\"encrypting_message\">Encrypting message</string>\n    <string name=\"not_fetching_history_retention_period\">Not fetching messages due to local retention period.</string>\n    <string name=\"transcoding_video\">Compressing video</string>\n    <string name=\"corresponding_conversations_closed\">Corresponding conversations closed.</string>\n    <string name=\"contact_blocked_past_tense\">Contact blocked.</string>\n    <string name=\"pref_notifications_from_strangers\">Notifications from strangers</string>\n    <string name=\"pref_notifications_from_strangers_summary\">Notify for messages received from strangers.</string>\n    <string name=\"received_message_from_stranger\">Received message from stranger</string>\n    <string name=\"block_stranger\">Block stranger</string>\n    <string name=\"block_entire_domain\">Block entire domain</string>\n    <string name=\"online_right_now\">online right now</string>\n    <string name=\"retry_decryption\">Retry decryption</string>\n    <string name=\"session_failure\">Session failure</string>\n    <string name=\"sasl_downgrade\">Downgraded SASL mechanism</string>\n    <string name=\"account_status_regis_web\">Server requires registration on website</string>\n    <string name=\"open_website\">Open website</string>\n    <string name=\"application_found_to_open_website\">No application found to open website</string>\n    <string name=\"pref_headsup_notifications\">Heads-up Notifications</string>\n    <string name=\"pref_headsup_notifications_summary\">Show Heads-up Notifications</string>\n    <string name=\"today\">Today</string>\n    <string name=\"yesterday\">Yesterday</string>\n    <string name=\"pref_validate_hostname\">Validate hostname with DNSSEC</string>\n    <string name=\"pref_validate_hostname_summary\">Server certificates that contain the validated hostname are considered verified</string>\n    <string name=\"certificate_does_not_contain_jid\">Certificate does not contain a Jabber ID</string>\n    <string name=\"server_info_partial\">partial</string>\n    <string name=\"attach_record_video\">Record video</string>\n    <string name=\"copy_to_clipboard\">Copy to clipboard</string>\n    <string name=\"message_copied_to_clipboard\">Message copied to clipboard</string>\n    <string name=\"message\">Message</string>\n    <string name=\"private_messages_are_disabled\">Private messages are disabled</string>\n    <string name=\"huawei_protected_apps\">Protected Apps</string>\n    <string name=\"huawei_protected_apps_summary\">To keep receiving notifications, even when the screen is turned off, you need to add Conversations to the list of protected apps.</string>\n    <string name=\"mtm_accept_cert\">Accept Unknown Certificate?</string>\n    <string name=\"mtm_trust_anchor\">The server certificate is not signed by a known Certificate Authority.</string>\n    <string name=\"mtm_accept_servername\">Accept Mismatching Server Name?</string>\n    <string name=\"mtm_hostname_mismatch\">Server could not authenticate as \\&quot;%s\\&quot;. The certificate is only valid for:</string>\n    <string name=\"mtm_connect_anyway\">Do you want to connect anyway?</string>\n    <string name=\"mtm_cert_details\">Certificate details:</string>\n    <string name=\"once\">Once</string>\n    <string name=\"qr_code_scanner_needs_access_to_camera\">The QR code scanner needs access to the camera</string>\n    <string name=\"pref_scroll_to_bottom\">Scroll to bottom</string>\n    <string name=\"pref_scroll_to_bottom_summary\">Scroll down after sending a message</string>\n    <string name=\"edit_status_message_title\">Edit Status Message</string>\n    <string name=\"edit_status_message\">Edit status message</string>\n    <string name=\"disable_encryption\">Disable encryption</string>\n    <string name=\"error_trustkey_general\">Conversations is unable to send encrypted messages to %1$s. This may be due to your contact using an outdated server or client that can not handle OMEMO.</string>\n    <string name=\"error_trustkey_device_list\">Unable to fetch device list</string>\n    <string name=\"error_trustkey_bundle\">Unable to fetch device bundles</string>\n    <string name=\"error_trustkey_hint_mutual\">Hint: In some cases this can be fixed by adding each other your contact lists.</string>\n    <string name=\"disable_encryption_message\">Are you sure you want to disable OMEMO encryption for this conversation?\\nThis will allow your server administrator to read your messages, but it might be the only way to communicate with people using outdated clients.</string>\n    <string name=\"disable_now\">Disable now</string>\n    <string name=\"draft\">Draft:</string>\n    <string name=\"pref_omemo_setting\">OMEMO Encryption</string>\n    <string name=\"pref_omemo_setting_summary_always\">OMEMO will always be used for one-on-one and private group chats.</string>\n    <string name=\"pref_omemo_setting_summary_default_on\">OMEMO will be used by default for new conversations.</string>\n    <string name=\"pref_omemo_setting_summary_default_off\">OMEMO will have to be turned on explicitly for new conversations.</string>\n    <string name=\"create_shortcut\">Create Shortcut</string>\n    <string name=\"pref_font_size\">Font Size</string>\n    <string name=\"pref_font_size_summary\">The relative font size used within the app.</string>\n    <string name=\"default_on\">On by default</string>\n    <string name=\"default_off\">Off by default</string>\n    <string name=\"small\">Small</string>\n    <string name=\"medium\">Medium</string>\n    <string name=\"large\">Large</string>\n    <string name=\"not_encrypted_for_this_device\">Message was not encrypted for this device.</string>\n    <string name=\"undo\">undo</string>\n    <string name=\"location_disabled\">Location sharing is disabled</string>\n    <string name=\"action_fix_to_location\">Fix position</string>\n    <string name=\"action_unfix_from_location\">Unfix position</string>\n    <string name=\"action_copy_location\">Copy Location</string>\n    <string name=\"action_share_location\">Share Location</string>\n    <string name=\"action_directions\">Directions</string>\n    <string name=\"title_activity_share_location\">Share location</string>\n    <string name=\"title_activity_show_location\">Show location</string>\n    <string name=\"share\">Share</string>\n    <string name=\"unable_to_start_recording\">Unable to start recording</string>\n    <string name=\"please_wait\">Please wait\u2026</string>\n    <string name=\"no_microphone_permission\">Conversations needs access to the microphone</string>\n    <string name=\"search_messages\">Search messages</string>\n    <string name=\"gif\">GIF</string>\n    <string name=\"view_conversation\">View conversation</string>\n    <string name=\"pref_use_share_location_plugin\">Share Location Plugin</string>\n    <string name=\"pref_use_share_location_plugin_summary\">Use the Share Location Plugin instead of the build in map</string>\n    <string name=\"copy_link\">Copy web address</string>\n    <string name=\"copy_jabber_id\">Copy Jabber ID</string>\n    <string name=\"p1_s3_filetransfer\">HTTP File Sharing for S3</string>\n    <string name=\"pref_start_search\">Direct Search</string>\n    <string name=\"pref_start_search_summary\">At \u2018Start Conversation\u2019 screen open keyboard and place cursor in search field</string>\n    <string name=\"group_chat_avatar\">Group chat avatar</string>\n    <string name=\"host_does_not_support_group_chat_avatars\">Host does not support group chat avatars</string>\n    <string name=\"only_the_owner_can_change_group_chat_avatar\">Only the owner can change group chat avatar</string>\n    <string name=\"contact_name\">Contact name</string>\n    <string name=\"nickname\">Nickname</string>\n    <string name=\"group_chat_name\">Name</string>\n    <string name=\"providing_a_name_is_optional\">Providing a name is optional</string>\n    <string name=\"create_dialog_group_chat_name\">Group chat name</string>\n    <string name=\"conference_destroyed\">This group chat has been destroyed</string>\n    <string name=\"phone_book\">Address book</string>\n    <string name=\"unable_to_save_recording\">Unable to save recording</string>\n    <string name=\"foreground_service_channel_name\">Foreground service</string>\n    <string name=\"foreground_service_channel_description\">This notification category is used to display a permanent notification indicating that Conversations is running.</string>\n    <string name=\"notification_group_status_information\">Status Information</string>\n    <string name=\"error_channel_name\">Connectivity Problems</string>\n    <string name=\"error_channel_description\">This notification category is used to display a notification in case there is a problem connecting to an account.</string>\n    <string name=\"notification_group_messages\">Messages</string>\n    <string name=\"messages_channel_name\">Messages</string>\n    <string name=\"silent_messages_channel_name\">Silent messages</string>\n    <string name=\"silent_messages_channel_description\">This notification group is used to display notifications that should not trigger any sound. For example when being active on another device (Grace Period).</string>\n    <string name=\"pref_more_notification_settings\">Notification Settings</string>\n    <string name=\"pref_more_notification_settings_summary\">Importance, Sound, Vibrate</string>\n    <string name=\"video_compression_channel_name\">Video compression</string>\n    <string name=\"view_media\">View media</string>\n    <string name=\"media_browser\">Media browser</string>\n    <string name=\"export_channel_name\">History export</string>\n    <string name=\"security_violation_not_attaching_file\">File omitted due to security violation.</string>\n    <string name=\"pref_video_compression\">Video Quality</string>\n    <string name=\"pref_video_compression_summary\">Lower quality means smaller files</string>\n    <string name=\"video_360p\">Medium (360p)</string>\n    <string name=\"video_720p\">High (720p)</string>\n    <string name=\"cancelled\">cancelled</string>\n</resources>\n"], "fixing_code": ["package eu.siacs.conversations.ui;\n\nimport android.Manifest;\nimport android.annotation.SuppressLint;\nimport android.app.Activity;\nimport android.app.FragmentManager;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.databinding.DataBindingUtil;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.preference.PreferenceManager;\nimport android.provider.MediaStore;\nimport android.support.annotation.IdRes;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.StringRes;\nimport android.support.v7.app.AlertDialog;\nimport android.app.Fragment;\nimport android.app.PendingIntent;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentSender.SendIntentException;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.SystemClock;\nimport android.support.v13.view.inputmethod.InputConnectionCompat;\nimport android.support.v13.view.inputmethod.InputContentInfoCompat;\nimport android.text.Editable;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.view.Gravity;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AbsListView;\nimport android.widget.AbsListView.OnScrollListener;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\nimport android.widget.CheckBox;\nimport android.widget.ListView;\nimport android.widget.PopupMenu;\nimport android.widget.TextView.OnEditorActionListener;\nimport android.widget.Toast;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport eu.siacs.conversations.Config;\nimport eu.siacs.conversations.R;\nimport eu.siacs.conversations.crypto.axolotl.AxolotlService;\nimport eu.siacs.conversations.crypto.axolotl.FingerprintStatus;\nimport eu.siacs.conversations.databinding.FragmentConversationBinding;\nimport eu.siacs.conversations.entities.Account;\nimport eu.siacs.conversations.entities.Blockable;\nimport eu.siacs.conversations.entities.Contact;\nimport eu.siacs.conversations.entities.Conversation;\nimport eu.siacs.conversations.entities.Conversational;\nimport eu.siacs.conversations.entities.DownloadableFile;\nimport eu.siacs.conversations.entities.Message;\nimport eu.siacs.conversations.entities.MucOptions;\nimport eu.siacs.conversations.entities.MucOptions.User;\nimport eu.siacs.conversations.entities.Presence;\nimport eu.siacs.conversations.entities.ReadByMarker;\nimport eu.siacs.conversations.entities.Transferable;\nimport eu.siacs.conversations.entities.TransferablePlaceholder;\nimport eu.siacs.conversations.http.HttpDownloadConnection;\nimport eu.siacs.conversations.persistance.FileBackend;\nimport eu.siacs.conversations.services.MessageArchiveService;\nimport eu.siacs.conversations.services.XmppConnectionService;\nimport eu.siacs.conversations.ui.adapter.MediaPreviewAdapter;\nimport eu.siacs.conversations.ui.adapter.MessageAdapter;\nimport eu.siacs.conversations.ui.util.ActivityResult;\nimport eu.siacs.conversations.ui.util.Attachment;\nimport eu.siacs.conversations.ui.util.ConversationMenuConfigurator;\nimport eu.siacs.conversations.ui.util.DateSeparator;\nimport eu.siacs.conversations.ui.util.EditMessageActionModeCallback;\nimport eu.siacs.conversations.ui.util.ListViewUtils;\nimport eu.siacs.conversations.ui.util.MenuDoubleTabUtil;\nimport eu.siacs.conversations.ui.util.MucDetailsContextMenuHelper;\nimport eu.siacs.conversations.ui.util.PendingItem;\nimport eu.siacs.conversations.ui.util.PresenceSelector;\nimport eu.siacs.conversations.ui.util.ScrollState;\nimport eu.siacs.conversations.ui.util.SendButtonAction;\nimport eu.siacs.conversations.ui.util.SendButtonTool;\nimport eu.siacs.conversations.ui.util.ShareUtil;\nimport eu.siacs.conversations.ui.widget.EditMessage;\nimport eu.siacs.conversations.utils.GeoHelper;\nimport eu.siacs.conversations.utils.MessageUtils;\nimport eu.siacs.conversations.utils.NickValidityChecker;\nimport eu.siacs.conversations.utils.Patterns;\nimport eu.siacs.conversations.utils.QuickLoader;\nimport eu.siacs.conversations.utils.StylingHelper;\nimport eu.siacs.conversations.utils.TimeframeUtils;\nimport eu.siacs.conversations.utils.UIHelper;\nimport eu.siacs.conversations.xmpp.XmppConnection;\nimport eu.siacs.conversations.xmpp.chatstate.ChatState;\nimport eu.siacs.conversations.xmpp.jingle.JingleConnection;\nimport rocks.xmpp.addr.Jid;\n\nimport static eu.siacs.conversations.ui.XmppActivity.EXTRA_ACCOUNT;\nimport static eu.siacs.conversations.ui.XmppActivity.REQUEST_INVITE_TO_CONVERSATION;\nimport static eu.siacs.conversations.ui.util.SoftKeyboardUtils.hideSoftKeyboard;\n\n\npublic class ConversationFragment extends XmppFragment implements EditMessage.KeyboardListener {\n\n\n    public static final int REQUEST_SEND_MESSAGE = 0x0201;\n    public static final int REQUEST_DECRYPT_PGP = 0x0202;\n    public static final int REQUEST_ENCRYPT_MESSAGE = 0x0207;\n    public static final int REQUEST_TRUST_KEYS_TEXT = 0x0208;\n    public static final int REQUEST_TRUST_KEYS_ATTACHMENTS = 0x0209;\n    public static final int REQUEST_START_DOWNLOAD = 0x0210;\n    public static final int REQUEST_ADD_EDITOR_CONTENT = 0x0211;\n    public static final int ATTACHMENT_CHOICE_CHOOSE_IMAGE = 0x0301;\n    public static final int ATTACHMENT_CHOICE_TAKE_PHOTO = 0x0302;\n    public static final int ATTACHMENT_CHOICE_CHOOSE_FILE = 0x0303;\n    public static final int ATTACHMENT_CHOICE_RECORD_VOICE = 0x0304;\n    public static final int ATTACHMENT_CHOICE_LOCATION = 0x0305;\n    public static final int ATTACHMENT_CHOICE_INVALID = 0x0306;\n    public static final int ATTACHMENT_CHOICE_RECORD_VIDEO = 0x0307;\n\n    public static final String RECENTLY_USED_QUICK_ACTION = \"recently_used_quick_action\";\n    public static final String STATE_CONVERSATION_UUID = ConversationFragment.class.getName() + \".uuid\";\n    public static final String STATE_SCROLL_POSITION = ConversationFragment.class.getName() + \".scroll_position\";\n    public static final String STATE_PHOTO_URI = ConversationFragment.class.getName() + \".media_previews\";\n    public static final String STATE_MEDIA_PREVIEWS = ConversationFragment.class.getName() + \".take_photo_uri\";\n    private static final String STATE_LAST_MESSAGE_UUID = \"state_last_message_uuid\";\n\n    private final List<Message> messageList = new ArrayList<>();\n    private final PendingItem<ActivityResult> postponedActivityResult = new PendingItem<>();\n    private final PendingItem<String> pendingConversationsUuid = new PendingItem<>();\n    private final PendingItem<ArrayList<Attachment>> pendingMediaPreviews = new PendingItem<>();\n    private final PendingItem<Bundle> pendingExtras = new PendingItem<>();\n    private final PendingItem<Uri> pendingTakePhotoUri = new PendingItem<>();\n    private final PendingItem<ScrollState> pendingScrollState = new PendingItem<>();\n    private final PendingItem<String> pendingLastMessageUuid = new PendingItem<>();\n    private final PendingItem<Message> pendingMessage = new PendingItem<>();\n    public Uri mPendingEditorContent = null;\n    protected MessageAdapter messageListAdapter;\n    private MediaPreviewAdapter mediaPreviewAdapter;\n    private String lastMessageUuid = null;\n    private Conversation conversation;\n    private FragmentConversationBinding binding;\n    private Toast messageLoaderToast;\n    private ConversationsActivity activity;\n    private boolean reInitRequiredOnStart = true;\n    private OnClickListener clickToMuc = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            Intent intent = new Intent(getActivity(), ConferenceDetailsActivity.class);\n            intent.setAction(ConferenceDetailsActivity.ACTION_VIEW_MUC);\n            intent.putExtra(\"uuid\", conversation.getUuid());\n            startActivity(intent);\n        }\n    };\n    private OnClickListener leaveMuc = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            activity.xmppConnectionService.archiveConversation(conversation);\n        }\n    };\n    private OnClickListener joinMuc = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            activity.xmppConnectionService.joinMuc(conversation);\n        }\n    };\n    private OnClickListener enterPassword = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            MucOptions muc = conversation.getMucOptions();\n            String password = muc.getPassword();\n            if (password == null) {\n                password = \"\";\n            }\n            activity.quickPasswordEdit(password, value -> {\n                activity.xmppConnectionService.providePasswordForMuc(conversation, value);\n                return null;\n            });\n        }\n    };\n    private OnScrollListener mOnScrollListener = new OnScrollListener() {\n\n        @Override\n        public void onScrollStateChanged(AbsListView view, int scrollState) {\n            if (AbsListView.OnScrollListener.SCROLL_STATE_IDLE == scrollState) {\n                fireReadEvent();\n            }\n        }\n\n        @Override\n        public void onScroll(final AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\n            toggleScrollDownButton(view);\n            synchronized (ConversationFragment.this.messageList) {\n                if (firstVisibleItem < 5 && conversation != null && conversation.messagesLoaded.compareAndSet(true, false) && messageList.size() > 0) {\n                    long timestamp;\n                    if (messageList.get(0).getType() == Message.TYPE_STATUS && messageList.size() >= 2) {\n                        timestamp = messageList.get(1).getTimeSent();\n                    } else {\n                        timestamp = messageList.get(0).getTimeSent();\n                    }\n                    activity.xmppConnectionService.loadMoreMessages(conversation, timestamp, new XmppConnectionService.OnMoreMessagesLoaded() {\n                        @Override\n                        public void onMoreMessagesLoaded(final int c, final Conversation conversation) {\n                            if (ConversationFragment.this.conversation != conversation) {\n                                conversation.messagesLoaded.set(true);\n                                return;\n                            }\n                            runOnUiThread(() -> {\n                                synchronized (messageList) {\n                                    final int oldPosition = binding.messagesView.getFirstVisiblePosition();\n                                    Message message = null;\n                                    int childPos;\n                                    for (childPos = 0; childPos + oldPosition < messageList.size(); ++childPos) {\n                                        message = messageList.get(oldPosition + childPos);\n                                        if (message.getType() != Message.TYPE_STATUS) {\n                                            break;\n                                        }\n                                    }\n                                    final String uuid = message != null ? message.getUuid() : null;\n                                    View v = binding.messagesView.getChildAt(childPos);\n                                    final int pxOffset = (v == null) ? 0 : v.getTop();\n                                    ConversationFragment.this.conversation.populateWithMessages(ConversationFragment.this.messageList);\n                                    try {\n                                        updateStatusMessages();\n                                    } catch (IllegalStateException e) {\n                                        Log.d(Config.LOGTAG, \"caught illegal state exception while updating status messages\");\n                                    }\n                                    messageListAdapter.notifyDataSetChanged();\n                                    int pos = Math.max(getIndexOf(uuid, messageList), 0);\n                                    binding.messagesView.setSelectionFromTop(pos, pxOffset);\n                                    if (messageLoaderToast != null) {\n                                        messageLoaderToast.cancel();\n                                    }\n                                    conversation.messagesLoaded.set(true);\n                                }\n                            });\n                        }\n\n                        @Override\n                        public void informUser(final int resId) {\n\n                            runOnUiThread(() -> {\n                                if (messageLoaderToast != null) {\n                                    messageLoaderToast.cancel();\n                                }\n                                if (ConversationFragment.this.conversation != conversation) {\n                                    return;\n                                }\n                                messageLoaderToast = Toast.makeText(view.getContext(), resId, Toast.LENGTH_LONG);\n                                messageLoaderToast.show();\n                            });\n\n                        }\n                    });\n\n                }\n            }\n        }\n    };\n    private EditMessage.OnCommitContentListener mEditorContentListener = new EditMessage.OnCommitContentListener() {\n        @Override\n        public boolean onCommitContent(InputContentInfoCompat inputContentInfo, int flags, Bundle opts, String[] contentMimeTypes) {\n            // try to get permission to read the image, if applicable\n            if ((flags & InputConnectionCompat.INPUT_CONTENT_GRANT_READ_URI_PERMISSION) != 0) {\n                try {\n                    inputContentInfo.requestPermission();\n                } catch (Exception e) {\n                    Log.e(Config.LOGTAG, \"InputContentInfoCompat#requestPermission() failed.\", e);\n                    Toast.makeText(getActivity(), activity.getString(R.string.no_permission_to_access_x, inputContentInfo.getDescription()), Toast.LENGTH_LONG\n                    ).show();\n                    return false;\n                }\n            }\n            if (hasPermissions(REQUEST_ADD_EDITOR_CONTENT, Manifest.permission.WRITE_EXTERNAL_STORAGE)) {\n                attachEditorContentToConversation(inputContentInfo.getContentUri());\n            } else {\n                mPendingEditorContent = inputContentInfo.getContentUri();\n            }\n            return true;\n        }\n    };\n    private Message selectedMessage;\n    private OnClickListener mEnableAccountListener = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            final Account account = conversation == null ? null : conversation.getAccount();\n            if (account != null) {\n                account.setOption(Account.OPTION_DISABLED, false);\n                activity.xmppConnectionService.updateAccount(account);\n            }\n        }\n    };\n    private OnClickListener mUnblockClickListener = new OnClickListener() {\n        @Override\n        public void onClick(final View v) {\n            v.post(() -> v.setVisibility(View.INVISIBLE));\n            if (conversation.isDomainBlocked()) {\n                BlockContactDialog.show(activity, conversation);\n            } else {\n                unblockConversation(conversation);\n            }\n        }\n    };\n    private OnClickListener mBlockClickListener = this::showBlockSubmenu;\n    private OnClickListener mAddBackClickListener = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            final Contact contact = conversation == null ? null : conversation.getContact();\n            if (contact != null) {\n                activity.xmppConnectionService.createContact(contact, true);\n                activity.switchToContactDetails(contact);\n            }\n        }\n    };\n    private View.OnLongClickListener mLongPressBlockListener = this::showBlockSubmenu;\n    private OnClickListener mAllowPresenceSubscription = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            final Contact contact = conversation == null ? null : conversation.getContact();\n            if (contact != null) {\n                activity.xmppConnectionService.sendPresencePacket(contact.getAccount(),\n                        activity.xmppConnectionService.getPresenceGenerator()\n                                .sendPresenceUpdatesTo(contact));\n                hideSnackbar();\n            }\n        }\n    };\n    protected OnClickListener clickToDecryptListener = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            PendingIntent pendingIntent = conversation.getAccount().getPgpDecryptionService().getPendingIntent();\n            if (pendingIntent != null) {\n                try {\n                    getActivity().startIntentSenderForResult(pendingIntent.getIntentSender(),\n                            REQUEST_DECRYPT_PGP,\n                            null,\n                            0,\n                            0,\n                            0);\n                } catch (SendIntentException e) {\n                    Toast.makeText(getActivity(), R.string.unable_to_connect_to_keychain, Toast.LENGTH_SHORT).show();\n                    conversation.getAccount().getPgpDecryptionService().continueDecryption(true);\n                }\n            }\n            updateSnackBar(conversation);\n        }\n    };\n    private AtomicBoolean mSendingPgpMessage = new AtomicBoolean(false);\n    private OnEditorActionListener mEditorActionListener = (v, actionId, event) -> {\n        if (actionId == EditorInfo.IME_ACTION_SEND) {\n            InputMethodManager imm = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);\n            if (imm != null && imm.isFullscreenMode()) {\n                imm.hideSoftInputFromWindow(v.getWindowToken(), 0);\n            }\n            sendMessage();\n            return true;\n        } else {\n            return false;\n        }\n    };\n    private OnClickListener mScrollButtonListener = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            stopScrolling();\n            setSelection(binding.messagesView.getCount() - 1, true);\n        }\n    };\n    private OnClickListener mSendButtonListener = new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            Object tag = v.getTag();\n            if (tag instanceof SendButtonAction) {\n                SendButtonAction action = (SendButtonAction) tag;\n                switch (action) {\n                    case TAKE_PHOTO:\n                    case RECORD_VIDEO:\n                    case SEND_LOCATION:\n                    case RECORD_VOICE:\n                    case CHOOSE_PICTURE:\n                        attachFile(action.toChoice());\n                        break;\n                    case CANCEL:\n                        if (conversation != null) {\n                            if (conversation.setCorrectingMessage(null)) {\n                                binding.textinput.setText(\"\");\n                                binding.textinput.append(conversation.getDraftMessage());\n                                conversation.setDraftMessage(null);\n                            } else if (conversation.getMode() == Conversation.MODE_MULTI) {\n                                conversation.setNextCounterpart(null);\n                            }\n                            updateChatMsgHint();\n                            updateSendButton();\n                            updateEditablity();\n                        }\n                        break;\n                    default:\n                        sendMessage();\n                }\n            } else {\n                sendMessage();\n            }\n        }\n    };\n    private int completionIndex = 0;\n    private int lastCompletionLength = 0;\n    private String incomplete;\n    private int lastCompletionCursor;\n    private boolean firstWord = false;\n    private Message mPendingDownloadableMessage;\n\n    private static ConversationFragment findConversationFragment(Activity activity) {\n        Fragment fragment = activity.getFragmentManager().findFragmentById(R.id.main_fragment);\n        if (fragment != null && fragment instanceof ConversationFragment) {\n            return (ConversationFragment) fragment;\n        }\n        fragment = activity.getFragmentManager().findFragmentById(R.id.secondary_fragment);\n        if (fragment != null && fragment instanceof ConversationFragment) {\n            return (ConversationFragment) fragment;\n        }\n        return null;\n    }\n\n    public static void startStopPending(Activity activity) {\n        ConversationFragment fragment = findConversationFragment(activity);\n        if (fragment != null) {\n            fragment.messageListAdapter.startStopPending();\n        }\n    }\n\n    public static void downloadFile(Activity activity, Message message) {\n        ConversationFragment fragment = findConversationFragment(activity);\n        if (fragment != null) {\n            fragment.startDownloadable(message);\n        }\n    }\n\n    public static void registerPendingMessage(Activity activity, Message message) {\n        ConversationFragment fragment = findConversationFragment(activity);\n        if (fragment != null) {\n            fragment.pendingMessage.push(message);\n        }\n    }\n\n    public static void openPendingMessage(Activity activity) {\n        ConversationFragment fragment = findConversationFragment(activity);\n        if (fragment != null) {\n            Message message = fragment.pendingMessage.pop();\n            if (message != null) {\n                fragment.messageListAdapter.openDownloadable(message);\n            }\n        }\n    }\n\n    public static Conversation getConversation(Activity activity) {\n        return getConversation(activity, R.id.secondary_fragment);\n    }\n\n    private static Conversation getConversation(Activity activity, @IdRes int res) {\n        final Fragment fragment = activity.getFragmentManager().findFragmentById(res);\n        if (fragment != null && fragment instanceof ConversationFragment) {\n            return ((ConversationFragment) fragment).getConversation();\n        } else {\n            return null;\n        }\n    }\n\n    public static ConversationFragment get(Activity activity) {\n        FragmentManager fragmentManager = activity.getFragmentManager();\n        Fragment fragment = fragmentManager.findFragmentById(R.id.main_fragment);\n        if (fragment != null && fragment instanceof ConversationFragment) {\n            return (ConversationFragment) fragment;\n        } else {\n            fragment = fragmentManager.findFragmentById(R.id.secondary_fragment);\n            return fragment != null && fragment instanceof ConversationFragment ? (ConversationFragment) fragment : null;\n        }\n    }\n\n    public static Conversation getConversationReliable(Activity activity) {\n        final Conversation conversation = getConversation(activity, R.id.secondary_fragment);\n        if (conversation != null) {\n            return conversation;\n        }\n        return getConversation(activity, R.id.main_fragment);\n    }\n\n    private static boolean allGranted(int[] grantResults) {\n        for (int grantResult : grantResults) {\n            if (grantResult != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean writeGranted(int[] grantResults, String[] permission) {\n        for (int i = 0; i < grantResults.length; ++i) {\n            if (Manifest.permission.WRITE_EXTERNAL_STORAGE.equals(permission[i])) {\n                return grantResults[i] == PackageManager.PERMISSION_GRANTED;\n            }\n        }\n        return false;\n    }\n\n    private static String getFirstDenied(int[] grantResults, String[] permissions) {\n        for (int i = 0; i < grantResults.length; ++i) {\n            if (grantResults[i] == PackageManager.PERMISSION_DENIED) {\n                return permissions[i];\n            }\n        }\n        return null;\n    }\n\n    private static boolean scrolledToBottom(AbsListView listView) {\n        final int count = listView.getCount();\n        if (count == 0) {\n            return true;\n        } else if (listView.getLastVisiblePosition() == count - 1) {\n            final View lastChild = listView.getChildAt(listView.getChildCount() - 1);\n            return lastChild != null && lastChild.getBottom() <= listView.getHeight();\n        } else {\n            return false;\n        }\n    }\n\n    private void toggleScrollDownButton() {\n        toggleScrollDownButton(binding.messagesView);\n    }\n\n    private void toggleScrollDownButton(AbsListView listView) {\n        if (conversation == null) {\n            return;\n        }\n        if (scrolledToBottom(listView)) {\n            lastMessageUuid = null;\n            hideUnreadMessagesCount();\n        } else {\n            binding.scrollToBottomButton.setEnabled(true);\n            binding.scrollToBottomButton.show();\n            if (lastMessageUuid == null) {\n                lastMessageUuid = conversation.getLatestMessage().getUuid();\n            }\n            if (conversation.getReceivedMessagesCountSinceUuid(lastMessageUuid) > 0) {\n                binding.unreadCountCustomView.setVisibility(View.VISIBLE);\n            }\n        }\n    }\n\n    private int getIndexOf(String uuid, List<Message> messages) {\n        if (uuid == null) {\n            return messages.size() - 1;\n        }\n        for (int i = 0; i < messages.size(); ++i) {\n            if (uuid.equals(messages.get(i).getUuid())) {\n                return i;\n            } else {\n                Message next = messages.get(i);\n                while (next != null && next.wasMergedIntoPrevious()) {\n                    if (uuid.equals(next.getUuid())) {\n                        return i;\n                    }\n                    next = next.next();\n                }\n\n            }\n        }\n        return -1;\n    }\n\n    private ScrollState getScrollPosition() {\n        final ListView listView = this.binding.messagesView;\n        if (listView.getCount() == 0 || listView.getLastVisiblePosition() == listView.getCount() - 1) {\n            return null;\n        } else {\n            final int pos = listView.getFirstVisiblePosition();\n            final View view = listView.getChildAt(0);\n            if (view == null) {\n                return null;\n            } else {\n                return new ScrollState(pos, view.getTop());\n            }\n        }\n    }\n\n    private void setScrollPosition(ScrollState scrollPosition, String lastMessageUuid) {\n        if (scrollPosition != null) {\n\n            this.lastMessageUuid = lastMessageUuid;\n            if (lastMessageUuid != null) {\n                binding.unreadCountCustomView.setUnreadCount(conversation.getReceivedMessagesCountSinceUuid(lastMessageUuid));\n            }\n            //TODO maybe this needs a 'post'\n            this.binding.messagesView.setSelectionFromTop(scrollPosition.position, scrollPosition.offset);\n            toggleScrollDownButton();\n        }\n    }\n\n    private void attachLocationToConversation(Conversation conversation, Uri uri) {\n        if (conversation == null) {\n            return;\n        }\n        activity.xmppConnectionService.attachLocationToConversation(conversation, uri, new UiCallback<Message>() {\n\n            @Override\n            public void success(Message message) {\n\n            }\n\n            @Override\n            public void error(int errorCode, Message object) {\n                //TODO show possible pgp error\n            }\n\n            @Override\n            public void userInputRequried(PendingIntent pi, Message object) {\n\n            }\n        });\n    }\n\n    private void attachFileToConversation(Conversation conversation, Uri uri, String type) {\n        if (conversation == null) {\n            return;\n        }\n        final Toast prepareFileToast = Toast.makeText(getActivity(), getText(R.string.preparing_file), Toast.LENGTH_LONG);\n        prepareFileToast.show();\n        activity.delegateUriPermissionsToService(uri);\n        activity.xmppConnectionService.attachFileToConversation(conversation, uri, type, new UiInformableCallback<Message>() {\n            @Override\n            public void inform(final String text) {\n                hidePrepareFileToast(prepareFileToast);\n                runOnUiThread(() -> activity.replaceToast(text));\n            }\n\n            @Override\n            public void success(Message message) {\n                runOnUiThread(() -> activity.hideToast());\n                hidePrepareFileToast(prepareFileToast);\n            }\n\n            @Override\n            public void error(final int errorCode, Message message) {\n                hidePrepareFileToast(prepareFileToast);\n                runOnUiThread(() -> activity.replaceToast(getString(errorCode)));\n\n            }\n\n            @Override\n            public void userInputRequried(PendingIntent pi, Message message) {\n                hidePrepareFileToast(prepareFileToast);\n            }\n        });\n    }\n\n    public void attachEditorContentToConversation(Uri uri) {\n        mediaPreviewAdapter.addMediaPreviews(Attachment.of(getActivity(), uri, Attachment.Type.FILE));\n        toggleInputMethod();\n    }\n\n    private void attachImageToConversation(Conversation conversation, Uri uri) {\n        if (conversation == null) {\n            return;\n        }\n        final Toast prepareFileToast = Toast.makeText(getActivity(), getText(R.string.preparing_image), Toast.LENGTH_LONG);\n        prepareFileToast.show();\n        activity.delegateUriPermissionsToService(uri);\n        activity.xmppConnectionService.attachImageToConversation(conversation, uri,\n                new UiCallback<Message>() {\n\n                    @Override\n                    public void userInputRequried(PendingIntent pi, Message object) {\n                        hidePrepareFileToast(prepareFileToast);\n                    }\n\n                    @Override\n                    public void success(Message message) {\n                        hidePrepareFileToast(prepareFileToast);\n                    }\n\n                    @Override\n                    public void error(final int error, Message message) {\n                        hidePrepareFileToast(prepareFileToast);\n                        activity.runOnUiThread(() -> activity.replaceToast(getString(error)));\n                    }\n                });\n    }\n\n    private void hidePrepareFileToast(final Toast prepareFileToast) {\n        if (prepareFileToast != null && activity != null) {\n            activity.runOnUiThread(prepareFileToast::cancel);\n        }\n    }\n\n    private void sendMessage() {\n        if (mediaPreviewAdapter.hasAttachments()) {\n            commitAttachments();\n            return;\n        }\n        final Editable text = this.binding.textinput.getText();\n        final String body =  text == null ? \"\" : text.toString();\n        final Conversation conversation = this.conversation;\n        if (body.length() == 0 || conversation == null) {\n            return;\n        }\n        if (conversation.getNextEncryption() == Message.ENCRYPTION_AXOLOTL && trustKeysIfNeeded(REQUEST_TRUST_KEYS_TEXT)) {\n            return;\n        }\n        final Message message;\n        if (conversation.getCorrectingMessage() == null) {\n            message = new Message(conversation, body, conversation.getNextEncryption());\n            if (conversation.getMode() == Conversation.MODE_MULTI) {\n                final Jid nextCounterpart = conversation.getNextCounterpart();\n                if (nextCounterpart != null) {\n                    message.setCounterpart(nextCounterpart);\n                    message.setTrueCounterpart(conversation.getMucOptions().getTrueCounterpart(nextCounterpart));\n                    message.setType(Message.TYPE_PRIVATE);\n                }\n            }\n        } else {\n            message = conversation.getCorrectingMessage();\n            message.setBody(body);\n            message.setEdited(message.getUuid());\n            message.setUuid(UUID.randomUUID().toString());\n        }\n        switch (conversation.getNextEncryption()) {\n            case Message.ENCRYPTION_PGP:\n                sendPgpMessage(message);\n                break;\n            default:\n                sendMessage(message);\n        }\n    }\n\n    protected boolean trustKeysIfNeeded(int requestCode) {\n        AxolotlService axolotlService = conversation.getAccount().getAxolotlService();\n        final List<Jid> targets = axolotlService.getCryptoTargets(conversation);\n        boolean hasUnaccepted = !conversation.getAcceptedCryptoTargets().containsAll(targets);\n        boolean hasUndecidedOwn = !axolotlService.getKeysWithTrust(FingerprintStatus.createActiveUndecided()).isEmpty();\n        boolean hasUndecidedContacts = !axolotlService.getKeysWithTrust(FingerprintStatus.createActiveUndecided(), targets).isEmpty();\n        boolean hasPendingKeys = !axolotlService.findDevicesWithoutSession(conversation).isEmpty();\n        boolean hasNoTrustedKeys = axolotlService.anyTargetHasNoTrustedKeys(targets);\n        boolean downloadInProgress = axolotlService.hasPendingKeyFetches(targets);\n        if (hasUndecidedOwn || hasUndecidedContacts || hasPendingKeys || hasNoTrustedKeys || hasUnaccepted || downloadInProgress) {\n            axolotlService.createSessionsIfNeeded(conversation);\n            Intent intent = new Intent(getActivity(), TrustKeysActivity.class);\n            String[] contacts = new String[targets.size()];\n            for (int i = 0; i < contacts.length; ++i) {\n                contacts[i] = targets.get(i).toString();\n            }\n            intent.putExtra(\"contacts\", contacts);\n            intent.putExtra(EXTRA_ACCOUNT, conversation.getAccount().getJid().asBareJid().toString());\n            intent.putExtra(\"conversation\", conversation.getUuid());\n            startActivityForResult(intent, requestCode);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void updateChatMsgHint() {\n        final boolean multi = conversation.getMode() == Conversation.MODE_MULTI;\n        if (conversation.getCorrectingMessage() != null) {\n            this.binding.textinput.setHint(R.string.send_corrected_message);\n        } else if (multi && conversation.getNextCounterpart() != null) {\n            this.binding.textinput.setHint(getString(\n                    R.string.send_private_message_to,\n                    conversation.getNextCounterpart().getResource()));\n        } else if (multi && !conversation.getMucOptions().participating()) {\n            this.binding.textinput.setHint(R.string.you_are_not_participating);\n        } else {\n            this.binding.textinput.setHint(UIHelper.getMessageHint(getActivity(), conversation));\n            getActivity().invalidateOptionsMenu();\n        }\n    }\n\n    public void setupIme() {\n        this.binding.textinput.refreshIme();\n    }\n\n    private void handleActivityResult(ActivityResult activityResult) {\n        if (activityResult.resultCode == Activity.RESULT_OK) {\n            handlePositiveActivityResult(activityResult.requestCode, activityResult.data);\n        } else {\n            handleNegativeActivityResult(activityResult.requestCode);\n        }\n    }\n\n    private void handlePositiveActivityResult(int requestCode, final Intent data) {\n        switch (requestCode) {\n            case REQUEST_TRUST_KEYS_TEXT:\n                sendMessage();\n                break;\n            case REQUEST_TRUST_KEYS_ATTACHMENTS:\n                commitAttachments();\n                break;\n            case ATTACHMENT_CHOICE_CHOOSE_IMAGE:\n                final List<Attachment> imageUris = Attachment.extractAttachments(getActivity(), data, Attachment.Type.IMAGE);\n                mediaPreviewAdapter.addMediaPreviews(imageUris);\n                toggleInputMethod();\n                break;\n            case ATTACHMENT_CHOICE_TAKE_PHOTO:\n                final Uri takePhotoUri = pendingTakePhotoUri.pop();\n                if (takePhotoUri != null) {\n                    mediaPreviewAdapter.addMediaPreviews(Attachment.of(getActivity(), takePhotoUri, Attachment.Type.IMAGE));\n                    toggleInputMethod();\n                } else {\n                    Log.d(Config.LOGTAG, \"lost take photo uri. unable to to attach\");\n                }\n                break;\n            case ATTACHMENT_CHOICE_CHOOSE_FILE:\n            case ATTACHMENT_CHOICE_RECORD_VIDEO:\n            case ATTACHMENT_CHOICE_RECORD_VOICE:\n                final Attachment.Type type = requestCode == ATTACHMENT_CHOICE_RECORD_VOICE ? Attachment.Type.RECORDING : Attachment.Type.FILE;\n                final List<Attachment> fileUris = Attachment.extractAttachments(getActivity(), data, type);\n                mediaPreviewAdapter.addMediaPreviews(fileUris);\n                toggleInputMethod();\n                break;\n            case ATTACHMENT_CHOICE_LOCATION:\n                double latitude = data.getDoubleExtra(\"latitude\", 0);\n                double longitude = data.getDoubleExtra(\"longitude\", 0);\n                Uri geo = Uri.parse(\"geo:\" + String.valueOf(latitude) + \",\" + String.valueOf(longitude));\n                mediaPreviewAdapter.addMediaPreviews(Attachment.of(getActivity(), geo, Attachment.Type.LOCATION));\n                toggleInputMethod();\n                break;\n            case REQUEST_INVITE_TO_CONVERSATION:\n                XmppActivity.ConferenceInvite invite = XmppActivity.ConferenceInvite.parse(data);\n                if (invite != null) {\n                    if (invite.execute(activity)) {\n                        activity.mToast = Toast.makeText(activity, R.string.creating_conference, Toast.LENGTH_LONG);\n                        activity.mToast.show();\n                    }\n                }\n                break;\n        }\n    }\n\n    private void commitAttachments() {\n        if (conversation.getNextEncryption() == Message.ENCRYPTION_AXOLOTL && trustKeysIfNeeded(REQUEST_TRUST_KEYS_ATTACHMENTS)) {\n            return;\n        }\n        final List<Attachment> attachments = mediaPreviewAdapter.getAttachments();\n        final PresenceSelector.OnPresenceSelected callback = () -> {\n            for (Iterator<Attachment> i = attachments.iterator(); i.hasNext(); i.remove()) {\n                final Attachment attachment = i.next();\n                if (attachment.getType() == Attachment.Type.LOCATION) {\n                    attachLocationToConversation(conversation, attachment.getUri());\n                } else if (attachment.getType() == Attachment.Type.IMAGE) {\n                    Log.d(Config.LOGTAG, \"ConversationsActivity.commitAttachments() - attaching image to conversations. CHOOSE_IMAGE\");\n                    attachImageToConversation(conversation, attachment.getUri());\n                } else {\n                    Log.d(Config.LOGTAG, \"ConversationsActivity.commitAttachments() - attaching file to conversations. CHOOSE_FILE/RECORD_VOICE/RECORD_VIDEO\");\n                    attachFileToConversation(conversation, attachment.getUri(), attachment.getMime());\n                }\n            }\n            mediaPreviewAdapter.notifyDataSetChanged();\n            toggleInputMethod();\n        };\n        if (conversation == null || conversation.getMode() == Conversation.MODE_MULTI || FileBackend.allFilesUnderSize(getActivity(), attachments, getMaxHttpUploadSize(conversation))) {\n            callback.onPresenceSelected();\n        } else {\n            activity.selectPresence(conversation, callback);\n        }\n    }\n\n    public void toggleInputMethod() {\n        boolean hasAttachments = mediaPreviewAdapter.hasAttachments();\n        binding.textinput.setVisibility(hasAttachments ? View.GONE : View.VISIBLE);\n        binding.mediaPreview.setVisibility(hasAttachments ? View.VISIBLE : View.GONE);\n        updateSendButton();\n    }\n\n    private void handleNegativeActivityResult(int requestCode) {\n        switch (requestCode) {\n            case ATTACHMENT_CHOICE_TAKE_PHOTO:\n                if (pendingTakePhotoUri.clear()) {\n                    Log.d(Config.LOGTAG, \"cleared pending photo uri after negative activity result\");\n                }\n                break;\n        }\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, final Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        ActivityResult activityResult = ActivityResult.of(requestCode, resultCode, data);\n        if (activity != null && activity.xmppConnectionService != null) {\n            handleActivityResult(activityResult);\n        } else {\n            this.postponedActivityResult.push(activityResult);\n        }\n    }\n\n    public void unblockConversation(final Blockable conversation) {\n        activity.xmppConnectionService.sendUnblockRequest(conversation);\n    }\n\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n        Log.d(Config.LOGTAG, \"ConversationFragment.onAttach()\");\n        if (activity instanceof ConversationsActivity) {\n            this.activity = (ConversationsActivity) activity;\n        } else {\n            throw new IllegalStateException(\"Trying to attach fragment to activity that is not the ConversationsActivity\");\n        }\n    }\n\n    @Override\n    public void onDetach() {\n        super.onDetach();\n        this.activity = null; //TODO maybe not a good idea since some callbacks really need it\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setHasOptionsMenu(true);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater menuInflater) {\n        menuInflater.inflate(R.menu.fragment_conversation, menu);\n        final MenuItem menuMucDetails = menu.findItem(R.id.action_muc_details);\n        final MenuItem menuContactDetails = menu.findItem(R.id.action_contact_details);\n        final MenuItem menuInviteContact = menu.findItem(R.id.action_invite);\n        final MenuItem menuMute = menu.findItem(R.id.action_mute);\n        final MenuItem menuUnmute = menu.findItem(R.id.action_unmute);\n\n\n        if (conversation != null) {\n            if (conversation.getMode() == Conversation.MODE_MULTI) {\n                menuContactDetails.setVisible(false);\n                menuInviteContact.setVisible(conversation.getMucOptions().canInvite());\n            } else {\n                menuContactDetails.setVisible(!this.conversation.withSelf());\n                menuMucDetails.setVisible(false);\n                final XmppConnectionService service = activity.xmppConnectionService;\n                menuInviteContact.setVisible(service != null && service.findConferenceServer(conversation.getAccount()) != null);\n            }\n            if (conversation.isMuted()) {\n                menuMute.setVisible(false);\n            } else {\n                menuUnmute.setVisible(false);\n            }\n            ConversationMenuConfigurator.configureAttachmentMenu(conversation, menu);\n            ConversationMenuConfigurator.configureEncryptionMenu(conversation, menu);\n        }\n        super.onCreateOptionsMenu(menu, menuInflater);\n    }\n\n    @Override\n    public View onCreateView(final LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        this.binding = DataBindingUtil.inflate(inflater, R.layout.fragment_conversation, container, false);\n        binding.getRoot().setOnClickListener(null); //TODO why the fuck did we do this?\n\n        binding.textinput.addTextChangedListener(new StylingHelper.MessageEditorStyler(binding.textinput));\n\n        binding.textinput.setOnEditorActionListener(mEditorActionListener);\n        binding.textinput.setRichContentListener(new String[]{\"image/*\"}, mEditorContentListener);\n\n        binding.textSendButton.setOnClickListener(this.mSendButtonListener);\n\n        binding.scrollToBottomButton.setOnClickListener(this.mScrollButtonListener);\n        binding.messagesView.setOnScrollListener(mOnScrollListener);\n        binding.messagesView.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);\n        mediaPreviewAdapter = new MediaPreviewAdapter(this);\n        binding.mediaPreview.setAdapter(mediaPreviewAdapter);\n        messageListAdapter = new MessageAdapter((XmppActivity) getActivity(), this.messageList);\n        messageListAdapter.setOnContactPictureClicked(message -> {\n            String fingerprint;\n            if (message.getEncryption() == Message.ENCRYPTION_PGP || message.getEncryption() == Message.ENCRYPTION_DECRYPTED) {\n                fingerprint = \"pgp\";\n            } else {\n                fingerprint = message.getFingerprint();\n            }\n            final boolean received = message.getStatus() <= Message.STATUS_RECEIVED;\n            if (received) {\n                if (message.getConversation() instanceof Conversation && message.getConversation().getMode() == Conversation.MODE_MULTI) {\n                    Jid tcp = message.getTrueCounterpart();\n                    Jid user = message.getCounterpart();\n                    if (user != null && !user.isBareJid()) {\n                        final MucOptions mucOptions = ((Conversation) message.getConversation()).getMucOptions();\n                        if (mucOptions.participating() || ((Conversation) message.getConversation()).getNextCounterpart() != null) {\n                            if (!mucOptions.isUserInRoom(user) && mucOptions.findUserByRealJid(tcp == null ? null : tcp.asBareJid()) == null) {\n                                Toast.makeText(getActivity(), activity.getString(R.string.user_has_left_conference, user.getResource()), Toast.LENGTH_SHORT).show();\n                            }\n                            highlightInConference(user.getResource());\n                        } else {\n                            Toast.makeText(getActivity(), R.string.you_are_not_participating, Toast.LENGTH_SHORT).show();\n                        }\n                    }\n                    return;\n                } else {\n                    if (!message.getContact().isSelf()) {\n                        activity.switchToContactDetails(message.getContact(), fingerprint);\n                        return;\n                    }\n                }\n            }\n            activity.switchToAccount(message.getConversation().getAccount(), fingerprint);\n        });\n        messageListAdapter.setOnContactPictureLongClicked((v, message) -> {\n            if (message.getStatus() <= Message.STATUS_RECEIVED) {\n                if (message.getConversation().getMode() == Conversation.MODE_MULTI) {\n                    Jid tcp = message.getTrueCounterpart();\n                    Jid cp = message.getCounterpart();\n                    if (cp != null && !cp.isBareJid()) {\n                        User userByRealJid = tcp != null ? conversation.getMucOptions().findOrCreateUserByRealJid(tcp, cp) : null;\n                        final User user = userByRealJid != null ? userByRealJid : conversation.getMucOptions().findUserByFullJid(cp);\n                        final PopupMenu popupMenu = new PopupMenu(getActivity(), v);\n                        popupMenu.inflate(R.menu.muc_details_context);\n                        final Menu menu = popupMenu.getMenu();\n                        MucDetailsContextMenuHelper.configureMucDetailsContextMenu(activity, menu, conversation, user);\n                        popupMenu.setOnMenuItemClickListener(menuItem -> MucDetailsContextMenuHelper.onContextItemSelected(menuItem, user, conversation, activity));\n                        popupMenu.show();\n                    }\n                }\n            } else {\n                activity.showQrCode(conversation.getAccount().getShareableUri());\n            }\n        });\n        messageListAdapter.setOnQuoteListener(this::quoteText);\n        binding.messagesView.setAdapter(messageListAdapter);\n\n        registerForContextMenu(binding.messagesView);\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            this.binding.textinput.setCustomInsertionActionModeCallback(new EditMessageActionModeCallback(this.binding.textinput));\n        }\n\n        return binding.getRoot();\n    }\n\n    private void quoteText(String text) {\n        if (binding.textinput.isEnabled()) {\n            binding.textinput.insertAsQuote(text);\n            binding.textinput.requestFocus();\n            InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\n            if (inputMethodManager != null) {\n                inputMethodManager.showSoftInput(binding.textinput, InputMethodManager.SHOW_IMPLICIT);\n            }\n        }\n    }\n\n    private void quoteMessage(Message message) {\n        quoteText(MessageUtils.prepareQuote(message));\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {\n        synchronized (this.messageList) {\n            super.onCreateContextMenu(menu, v, menuInfo);\n            AdapterView.AdapterContextMenuInfo acmi = (AdapterContextMenuInfo) menuInfo;\n            this.selectedMessage = this.messageList.get(acmi.position);\n            populateContextMenu(menu);\n        }\n    }\n\n    private void populateContextMenu(ContextMenu menu) {\n        final Message m = this.selectedMessage;\n        final Transferable t = m.getTransferable();\n        Message relevantForCorrection = m;\n        while (relevantForCorrection.mergeable(relevantForCorrection.next())) {\n            relevantForCorrection = relevantForCorrection.next();\n        }\n        if (m.getType() != Message.TYPE_STATUS) {\n\n            if (m.getEncryption() == Message.ENCRYPTION_AXOLOTL_NOT_FOR_THIS_DEVICE) {\n                return;\n            }\n\n            final boolean deleted = t != null && t instanceof TransferablePlaceholder;\n            final boolean encrypted = m.getEncryption() == Message.ENCRYPTION_DECRYPTION_FAILED\n                    || m.getEncryption() == Message.ENCRYPTION_PGP;\n            final boolean receiving = m.getStatus() == Message.STATUS_RECEIVED && (t instanceof JingleConnection || t instanceof HttpDownloadConnection);\n            activity.getMenuInflater().inflate(R.menu.message_context, menu);\n            menu.setHeaderTitle(R.string.message_options);\n            MenuItem copyMessage = menu.findItem(R.id.copy_message);\n            MenuItem copyLink = menu.findItem(R.id.copy_link);\n            MenuItem quoteMessage = menu.findItem(R.id.quote_message);\n            MenuItem retryDecryption = menu.findItem(R.id.retry_decryption);\n            MenuItem correctMessage = menu.findItem(R.id.correct_message);\n            MenuItem shareWith = menu.findItem(R.id.share_with);\n            MenuItem sendAgain = menu.findItem(R.id.send_again);\n            MenuItem copyUrl = menu.findItem(R.id.copy_url);\n            MenuItem downloadFile = menu.findItem(R.id.download_file);\n            MenuItem cancelTransmission = menu.findItem(R.id.cancel_transmission);\n            MenuItem deleteFile = menu.findItem(R.id.delete_file);\n            MenuItem showErrorMessage = menu.findItem(R.id.show_error_message);\n            if (!m.isFileOrImage() && !encrypted && !m.isGeoUri() && !m.treatAsDownloadable()) {\n                copyMessage.setVisible(true);\n                quoteMessage.setVisible(MessageUtils.prepareQuote(m).length() > 0);\n                String body = m.getMergedBody().toString();\n                if (ShareUtil.containsXmppUri(body)) {\n                    copyLink.setTitle(R.string.copy_jabber_id);\n                    copyLink.setVisible(true);\n                } else if (Patterns.AUTOLINK_WEB_URL.matcher(body).find()) {\n                    copyLink.setVisible(true);\n                }\n            }\n            if (m.getEncryption() == Message.ENCRYPTION_DECRYPTION_FAILED) {\n                retryDecryption.setVisible(true);\n            }\n            if (relevantForCorrection.getType() == Message.TYPE_TEXT\n                    && relevantForCorrection.isLastCorrectableMessage()\n                    && m.getConversation() instanceof Conversation\n                    && (((Conversation) m.getConversation()).getMucOptions().nonanonymous() || m.getConversation().getMode() == Conversation.MODE_SINGLE)) {\n                correctMessage.setVisible(true);\n            }\n            if ((m.isFileOrImage() && !deleted && !receiving) || (m.getType() == Message.TYPE_TEXT && !m.treatAsDownloadable())) {\n                shareWith.setVisible(true);\n            }\n            if (m.getStatus() == Message.STATUS_SEND_FAILED) {\n                sendAgain.setVisible(true);\n            }\n            if (m.hasFileOnRemoteHost()\n                    || m.isGeoUri()\n                    || m.treatAsDownloadable()\n                    || t instanceof HttpDownloadConnection) {\n                copyUrl.setVisible(true);\n            }\n            if (m.isFileOrImage() && deleted && m.hasFileOnRemoteHost()) {\n                downloadFile.setVisible(true);\n                downloadFile.setTitle(activity.getString(R.string.download_x_file, UIHelper.getFileDescriptionString(activity, m)));\n            }\n            final boolean waitingOfferedSending = m.getStatus() == Message.STATUS_WAITING\n                    || m.getStatus() == Message.STATUS_UNSEND\n                    || m.getStatus() == Message.STATUS_OFFERED;\n            final boolean cancelable = (t != null && !deleted) || waitingOfferedSending && m.needsUploading();\n            if (cancelable) {\n                cancelTransmission.setVisible(true);\n            }\n            if (m.isFileOrImage() && !deleted && !cancelable) {\n                String path = m.getRelativeFilePath();\n                if (path == null || !path.startsWith(\"/\") || FileBackend.isInDirectoryThatShouldNotBeScanned(getActivity(), path)) {\n                    deleteFile.setVisible(true);\n                    deleteFile.setTitle(activity.getString(R.string.delete_x_file, UIHelper.getFileDescriptionString(activity, m)));\n                }\n            }\n            if (m.getStatus() == Message.STATUS_SEND_FAILED && m.getErrorMessage() != null && !Message.ERROR_MESSAGE_CANCELLED.equals(m.getErrorMessage())) {\n                showErrorMessage.setVisible(true);\n            }\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.share_with:\n                ShareUtil.share(activity, selectedMessage);\n                return true;\n            case R.id.correct_message:\n                correctMessage(selectedMessage);\n                return true;\n            case R.id.copy_message:\n                ShareUtil.copyToClipboard(activity, selectedMessage);\n                return true;\n            case R.id.copy_link:\n                ShareUtil.copyLinkToClipboard(activity, selectedMessage);\n                return true;\n            case R.id.quote_message:\n                quoteMessage(selectedMessage);\n                return true;\n            case R.id.send_again:\n                resendMessage(selectedMessage);\n                return true;\n            case R.id.copy_url:\n                ShareUtil.copyUrlToClipboard(activity, selectedMessage);\n                return true;\n            case R.id.download_file:\n                startDownloadable(selectedMessage);\n                return true;\n            case R.id.cancel_transmission:\n                cancelTransmission(selectedMessage);\n                return true;\n            case R.id.retry_decryption:\n                retryDecryption(selectedMessage);\n                return true;\n            case R.id.delete_file:\n                deleteFile(selectedMessage);\n                return true;\n            case R.id.show_error_message:\n                showErrorMessage(selectedMessage);\n                return true;\n            default:\n                return super.onContextItemSelected(item);\n        }\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(final MenuItem item) {\n        if (MenuDoubleTabUtil.shouldIgnoreTap()) {\n            return false;\n        } else if (conversation == null) {\n            return super.onOptionsItemSelected(item);\n        }\n        switch (item.getItemId()) {\n            case R.id.encryption_choice_axolotl:\n            case R.id.encryption_choice_pgp:\n            case R.id.encryption_choice_none:\n                handleEncryptionSelection(item);\n                break;\n            case R.id.attach_choose_picture:\n            case R.id.attach_take_picture:\n            case R.id.attach_record_video:\n            case R.id.attach_choose_file:\n            case R.id.attach_record_voice:\n            case R.id.attach_location:\n                handleAttachmentSelection(item);\n                break;\n            case R.id.action_archive:\n                activity.xmppConnectionService.archiveConversation(conversation);\n                break;\n            case R.id.action_contact_details:\n                activity.switchToContactDetails(conversation.getContact());\n                break;\n            case R.id.action_muc_details:\n                Intent intent = new Intent(getActivity(), ConferenceDetailsActivity.class);\n                intent.setAction(ConferenceDetailsActivity.ACTION_VIEW_MUC);\n                intent.putExtra(\"uuid\", conversation.getUuid());\n                startActivity(intent);\n                break;\n            case R.id.action_invite:\n                startActivityForResult(ChooseContactActivity.create(activity, conversation), REQUEST_INVITE_TO_CONVERSATION);\n                break;\n            case R.id.action_clear_history:\n                clearHistoryDialog(conversation);\n                break;\n            case R.id.action_mute:\n                muteConversationDialog(conversation);\n                break;\n            case R.id.action_unmute:\n                unmuteConversation(conversation);\n                break;\n            case R.id.action_block:\n            case R.id.action_unblock:\n                final Activity activity = getActivity();\n                if (activity instanceof XmppActivity) {\n                    BlockContactDialog.show((XmppActivity) activity, conversation);\n                }\n                break;\n            default:\n                break;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private void handleAttachmentSelection(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.attach_choose_picture:\n                attachFile(ATTACHMENT_CHOICE_CHOOSE_IMAGE);\n                break;\n            case R.id.attach_take_picture:\n                attachFile(ATTACHMENT_CHOICE_TAKE_PHOTO);\n                break;\n            case R.id.attach_record_video:\n                attachFile(ATTACHMENT_CHOICE_RECORD_VIDEO);\n                break;\n            case R.id.attach_choose_file:\n                attachFile(ATTACHMENT_CHOICE_CHOOSE_FILE);\n                break;\n            case R.id.attach_record_voice:\n                attachFile(ATTACHMENT_CHOICE_RECORD_VOICE);\n                break;\n            case R.id.attach_location:\n                attachFile(ATTACHMENT_CHOICE_LOCATION);\n                break;\n        }\n    }\n\n    private void handleEncryptionSelection(MenuItem item) {\n        if (conversation == null) {\n            return;\n        }\n        switch (item.getItemId()) {\n            case R.id.encryption_choice_none:\n                conversation.setNextEncryption(Message.ENCRYPTION_NONE);\n                item.setChecked(true);\n                break;\n            case R.id.encryption_choice_pgp:\n                if (activity.hasPgp()) {\n                    if (conversation.getAccount().getPgpSignature() != null) {\n                        conversation.setNextEncryption(Message.ENCRYPTION_PGP);\n                        item.setChecked(true);\n                    } else {\n                        activity.announcePgp(conversation.getAccount(), conversation, null, activity.onOpenPGPKeyPublished);\n                    }\n                } else {\n                    activity.showInstallPgpDialog();\n                }\n                break;\n            case R.id.encryption_choice_axolotl:\n                Log.d(Config.LOGTAG, AxolotlService.getLogprefix(conversation.getAccount())\n                        + \"Enabled axolotl for Contact \" + conversation.getContact().getJid());\n                conversation.setNextEncryption(Message.ENCRYPTION_AXOLOTL);\n                item.setChecked(true);\n                break;\n            default:\n                conversation.setNextEncryption(Message.ENCRYPTION_NONE);\n                break;\n        }\n        activity.xmppConnectionService.updateConversation(conversation);\n        updateChatMsgHint();\n        getActivity().invalidateOptionsMenu();\n        activity.refreshUi();\n    }\n\n    public void attachFile(final int attachmentChoice) {\n        if (attachmentChoice == ATTACHMENT_CHOICE_RECORD_VOICE) {\n            if (!hasPermissions(attachmentChoice, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.RECORD_AUDIO)) {\n                return;\n            }\n        } else if (attachmentChoice == ATTACHMENT_CHOICE_TAKE_PHOTO || attachmentChoice == ATTACHMENT_CHOICE_RECORD_VIDEO) {\n            if (!hasPermissions(attachmentChoice, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA)) {\n                return;\n            }\n        } else if (attachmentChoice != ATTACHMENT_CHOICE_LOCATION) {\n            if (!hasPermissions(attachmentChoice, Manifest.permission.WRITE_EXTERNAL_STORAGE)) {\n                return;\n            }\n        }\n        try {\n            activity.getPreferences().edit()\n                    .putString(RECENTLY_USED_QUICK_ACTION, SendButtonAction.of(attachmentChoice).toString())\n                    .apply();\n        } catch (IllegalArgumentException e) {\n            //just do not save\n        }\n        final int encryption = conversation.getNextEncryption();\n        final int mode = conversation.getMode();\n        if (encryption == Message.ENCRYPTION_PGP) {\n            if (activity.hasPgp()) {\n                if (mode == Conversation.MODE_SINGLE && conversation.getContact().getPgpKeyId() != 0) {\n                    activity.xmppConnectionService.getPgpEngine().hasKey(\n                            conversation.getContact(),\n                            new UiCallback<Contact>() {\n\n                                @Override\n                                public void userInputRequried(PendingIntent pi, Contact contact) {\n                                    startPendingIntent(pi, attachmentChoice);\n                                }\n\n                                @Override\n                                public void success(Contact contact) {\n                                    selectPresenceToAttachFile(attachmentChoice);\n                                }\n\n                                @Override\n                                public void error(int error, Contact contact) {\n                                    activity.replaceToast(getString(error));\n                                }\n                            });\n                } else if (mode == Conversation.MODE_MULTI && conversation.getMucOptions().pgpKeysInUse()) {\n                    if (!conversation.getMucOptions().everybodyHasKeys()) {\n                        Toast warning = Toast.makeText(getActivity(), R.string.missing_public_keys, Toast.LENGTH_LONG);\n                        warning.setGravity(Gravity.CENTER_VERTICAL, 0, 0);\n                        warning.show();\n                    }\n                    selectPresenceToAttachFile(attachmentChoice);\n                } else {\n                    showNoPGPKeyDialog(false, (dialog, which) -> {\n                        conversation.setNextEncryption(Message.ENCRYPTION_NONE);\n                        activity.xmppConnectionService.updateConversation(conversation);\n                        selectPresenceToAttachFile(attachmentChoice);\n                    });\n                }\n            } else {\n                activity.showInstallPgpDialog();\n            }\n        } else {\n            selectPresenceToAttachFile(attachmentChoice);\n        }\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String permissions[], @NonNull int[] grantResults) {\n        if (grantResults.length > 0) {\n            if (allGranted(grantResults)) {\n                if (requestCode == REQUEST_START_DOWNLOAD) {\n                    if (this.mPendingDownloadableMessage != null) {\n                        startDownloadable(this.mPendingDownloadableMessage);\n                    }\n                } else if (requestCode == REQUEST_ADD_EDITOR_CONTENT) {\n                    if (this.mPendingEditorContent != null) {\n                        attachEditorContentToConversation(this.mPendingEditorContent);\n                    }\n                } else {\n                    attachFile(requestCode);\n                }\n            } else {\n                @StringRes int res;\n                String firstDenied = getFirstDenied(grantResults, permissions);\n                if (Manifest.permission.RECORD_AUDIO.equals(firstDenied)) {\n                    res = R.string.no_microphone_permission;\n                } else if (Manifest.permission.CAMERA.equals(firstDenied)) {\n                    res = R.string.no_camera_permission;\n                } else {\n                    res = R.string.no_storage_permission;\n                }\n                Toast.makeText(getActivity(), res, Toast.LENGTH_SHORT).show();\n            }\n        }\n        if (writeGranted(grantResults, permissions)) {\n            if (activity != null && activity.xmppConnectionService != null) {\n                activity.xmppConnectionService.restartFileObserver();\n            }\n        }\n    }\n\n    public void startDownloadable(Message message) {\n        if (!hasPermissions(REQUEST_START_DOWNLOAD, Manifest.permission.WRITE_EXTERNAL_STORAGE)) {\n            this.mPendingDownloadableMessage = message;\n            return;\n        }\n        Transferable transferable = message.getTransferable();\n        if (transferable != null) {\n            if (transferable instanceof TransferablePlaceholder && message.hasFileOnRemoteHost()) {\n                createNewConnection(message);\n                return;\n            }\n            if (!transferable.start()) {\n                Log.d(Config.LOGTAG, \"type: \" + transferable.getClass().getName());\n                Toast.makeText(getActivity(), R.string.not_connected_try_again, Toast.LENGTH_SHORT).show();\n            }\n        } else if (message.treatAsDownloadable()) {\n            createNewConnection(message);\n        }\n    }\n\n    private void createNewConnection(final Message message) {\n        if (!activity.xmppConnectionService.getHttpConnectionManager().checkConnection(message)) {\n            Toast.makeText(getActivity(), R.string.not_connected_try_again, Toast.LENGTH_SHORT).show();\n            return;\n        }\n        activity.xmppConnectionService.getHttpConnectionManager().createNewDownloadConnection(message, true);\n    }\n\n    @SuppressLint(\"InflateParams\")\n    protected void clearHistoryDialog(final Conversation conversation) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setTitle(getString(R.string.clear_conversation_history));\n        final View dialogView = getActivity().getLayoutInflater().inflate(R.layout.dialog_clear_history, null);\n        final CheckBox endConversationCheckBox = dialogView.findViewById(R.id.end_conversation_checkbox);\n        builder.setView(dialogView);\n        builder.setNegativeButton(getString(R.string.cancel), null);\n        builder.setPositiveButton(getString(R.string.confirm), (dialog, which) -> {\n            this.activity.xmppConnectionService.clearConversationHistory(conversation);\n            if (endConversationCheckBox.isChecked()) {\n                this.activity.xmppConnectionService.archiveConversation(conversation);\n                this.activity.onConversationArchived(conversation);\n            } else {\n                activity.onConversationsListItemUpdated();\n                refresh();\n            }\n        });\n        builder.create().show();\n    }\n\n    protected void muteConversationDialog(final Conversation conversation) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setTitle(R.string.disable_notifications);\n        final int[] durations = getResources().getIntArray(R.array.mute_options_durations);\n        final CharSequence[] labels = new CharSequence[durations.length];\n        for (int i = 0; i < durations.length; ++i) {\n            if (durations[i] == -1) {\n                labels[i] = getString(R.string.until_further_notice);\n            } else {\n                labels[i] = TimeframeUtils.resolve(activity, 1000L * durations[i]);\n            }\n        }\n        builder.setItems(labels, (dialog, which) -> {\n            final long till;\n            if (durations[which] == -1) {\n                till = Long.MAX_VALUE;\n            } else {\n                till = System.currentTimeMillis() + (durations[which] * 1000);\n            }\n            conversation.setMutedTill(till);\n            activity.xmppConnectionService.updateConversation(conversation);\n            activity.onConversationsListItemUpdated();\n            refresh();\n            getActivity().invalidateOptionsMenu();\n        });\n        builder.create().show();\n    }\n\n    private boolean hasPermissions(int requestCode, String... permissions) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            final List<String> missingPermissions = new ArrayList<>();\n            for (String permission : permissions) {\n                if (Config.ONLY_INTERNAL_STORAGE && permission.equals(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {\n                    continue;\n                }\n                if (activity.checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {\n                    missingPermissions.add(permission);\n                }\n            }\n            if (missingPermissions.size() == 0) {\n                return true;\n            } else {\n                requestPermissions(missingPermissions.toArray(new String[missingPermissions.size()]), requestCode);\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n\n    public void unmuteConversation(final Conversation conversation) {\n        conversation.setMutedTill(0);\n        this.activity.xmppConnectionService.updateConversation(conversation);\n        this.activity.onConversationsListItemUpdated();\n        refresh();\n        getActivity().invalidateOptionsMenu();\n    }\n\n    protected void selectPresenceToAttachFile(final int attachmentChoice) {\n        final Account account = conversation.getAccount();\n        final PresenceSelector.OnPresenceSelected callback = () -> {\n            Intent intent = new Intent();\n            boolean chooser = false;\n            switch (attachmentChoice) {\n                case ATTACHMENT_CHOICE_CHOOSE_IMAGE:\n                    intent.setAction(Intent.ACTION_GET_CONTENT);\n                    intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);\n                    intent.setType(\"image/*\");\n                    chooser = true;\n                    break;\n                case ATTACHMENT_CHOICE_RECORD_VIDEO:\n                    intent.setAction(MediaStore.ACTION_VIDEO_CAPTURE);\n                    break;\n                case ATTACHMENT_CHOICE_TAKE_PHOTO:\n                    final Uri uri = activity.xmppConnectionService.getFileBackend().getTakePhotoUri();\n                    pendingTakePhotoUri.push(uri);\n                    intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);\n                    intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n                    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                    intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);\n                    break;\n                case ATTACHMENT_CHOICE_CHOOSE_FILE:\n                    chooser = true;\n                    intent.setType(\"*/*\");\n                    intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);\n                    intent.addCategory(Intent.CATEGORY_OPENABLE);\n                    intent.setAction(Intent.ACTION_GET_CONTENT);\n                    break;\n                case ATTACHMENT_CHOICE_RECORD_VOICE:\n                    intent = new Intent(getActivity(), RecordingActivity.class);\n                    break;\n                case ATTACHMENT_CHOICE_LOCATION:\n                    intent = GeoHelper.getFetchIntent(activity);\n                    break;\n            }\n            if (intent.resolveActivity(getActivity().getPackageManager()) != null) {\n                if (chooser) {\n                    startActivityForResult(\n                            Intent.createChooser(intent, getString(R.string.perform_action_with)),\n                            attachmentChoice);\n                } else {\n                    startActivityForResult(intent, attachmentChoice);\n                }\n            }\n        };\n        if (account.httpUploadAvailable() || attachmentChoice == ATTACHMENT_CHOICE_LOCATION) {\n            conversation.setNextCounterpart(null);\n            callback.onPresenceSelected();\n        } else {\n            activity.selectPresence(conversation, callback);\n        }\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        binding.messagesView.post(this::fireReadEvent);\n    }\n\n    private void fireReadEvent() {\n        if (activity != null && this.conversation != null) {\n            String uuid = getLastVisibleMessageUuid();\n            if (uuid != null) {\n                activity.onConversationRead(this.conversation, uuid);\n            }\n        }\n    }\n\n    private String getLastVisibleMessageUuid() {\n        if (binding == null) {\n            return null;\n        }\n        synchronized (this.messageList) {\n            int pos = binding.messagesView.getLastVisiblePosition();\n            if (pos >= 0) {\n                Message message = null;\n                for (int i = pos; i >= 0; --i) {\n                    try {\n                        message = (Message) binding.messagesView.getItemAtPosition(i);\n                    } catch (IndexOutOfBoundsException e) {\n                        //should not happen if we synchronize properly. however if that fails we just gonna try item -1\n                        continue;\n                    }\n                    if (message.getType() != Message.TYPE_STATUS) {\n                        break;\n                    }\n                }\n                if (message != null) {\n                    while (message.next() != null && message.next().wasMergedIntoPrevious()) {\n                        message = message.next();\n                    }\n                    return message.getUuid();\n                }\n            }\n        }\n        return null;\n    }\n\n    private void showErrorMessage(final Message message) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setTitle(R.string.error_message);\n        builder.setMessage(message.getErrorMessage());\n        builder.setPositiveButton(R.string.confirm, null);\n        builder.create().show();\n    }\n\n\n    private void deleteFile(final Message message) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setNegativeButton(R.string.cancel, null);\n        builder.setTitle(R.string.delete_file_dialog);\n        builder.setMessage(R.string.delete_file_dialog_msg);\n        builder.setPositiveButton(R.string.confirm, (dialog, which) -> {\n            if (activity.xmppConnectionService.getFileBackend().deleteFile(message)) {\n                message.setTransferable(new TransferablePlaceholder(Transferable.STATUS_DELETED));\n                activity.onConversationsListItemUpdated();\n                refresh();\n            }\n        });\n        builder.create().show();\n\n    }\n\n    private void resendMessage(final Message message) {\n        if (message.isFileOrImage()) {\n            if (!(message.getConversation() instanceof Conversation)) {\n                return;\n            }\n            final Conversation conversation = (Conversation) message.getConversation();\n            DownloadableFile file = activity.xmppConnectionService.getFileBackend().getFile(message);\n            if (file.exists()) {\n                final XmppConnection xmppConnection = conversation.getAccount().getXmppConnection();\n                if (!message.hasFileOnRemoteHost()\n                        && xmppConnection != null\n                        && !xmppConnection.getFeatures().httpUpload(message.getFileParams().size)) {\n                    activity.selectPresence(conversation, () -> {\n                        message.setCounterpart(conversation.getNextCounterpart());\n                        activity.xmppConnectionService.resendFailedMessages(message);\n                        new Handler().post(() -> {\n                            int size = messageList.size();\n                            this.binding.messagesView.setSelection(size - 1);\n                        });\n                    });\n                    return;\n                }\n            } else {\n                Toast.makeText(activity, R.string.file_deleted, Toast.LENGTH_SHORT).show();\n                message.setTransferable(new TransferablePlaceholder(Transferable.STATUS_DELETED));\n                activity.onConversationsListItemUpdated();\n                refresh();\n                return;\n            }\n        }\n        activity.xmppConnectionService.resendFailedMessages(message);\n        new Handler().post(() -> {\n            int size = messageList.size();\n            this.binding.messagesView.setSelection(size - 1);\n        });\n    }\n\n    private void cancelTransmission(Message message) {\n        Transferable transferable = message.getTransferable();\n        if (transferable != null) {\n            transferable.cancel();\n        } else if (message.getStatus() != Message.STATUS_RECEIVED) {\n            activity.xmppConnectionService.markMessage(message, Message.STATUS_SEND_FAILED, Message.ERROR_MESSAGE_CANCELLED);\n        }\n    }\n\n    private void retryDecryption(Message message) {\n        message.setEncryption(Message.ENCRYPTION_PGP);\n        activity.onConversationsListItemUpdated();\n        refresh();\n        conversation.getAccount().getPgpDecryptionService().decrypt(message, false);\n    }\n\n    public void privateMessageWith(final Jid counterpart) {\n        if (conversation.setOutgoingChatState(Config.DEFAULT_CHATSTATE)) {\n            activity.xmppConnectionService.sendChatState(conversation);\n        }\n        this.binding.textinput.setText(\"\");\n        this.conversation.setNextCounterpart(counterpart);\n        updateChatMsgHint();\n        updateSendButton();\n        updateEditablity();\n    }\n\n    private void correctMessage(Message message) {\n        while (message.mergeable(message.next())) {\n            message = message.next();\n        }\n        this.conversation.setCorrectingMessage(message);\n        final Editable editable = binding.textinput.getText();\n        this.conversation.setDraftMessage(editable.toString());\n        this.binding.textinput.setText(\"\");\n        this.binding.textinput.append(message.getBody());\n\n    }\n\n    private void highlightInConference(String nick) {\n        final Editable editable = this.binding.textinput.getText();\n        String oldString = editable.toString().trim();\n        final int pos = this.binding.textinput.getSelectionStart();\n        if (oldString.isEmpty() || pos == 0) {\n            editable.insert(0, nick + \": \");\n        } else {\n            final char before = editable.charAt(pos - 1);\n            final char after = editable.length() > pos ? editable.charAt(pos) : '\\0';\n            if (before == '\\n') {\n                editable.insert(pos, nick + \": \");\n            } else {\n                if (pos > 2 && editable.subSequence(pos - 2, pos).toString().equals(\": \")) {\n                    if (NickValidityChecker.check(conversation, Arrays.asList(editable.subSequence(0, pos - 2).toString().split(\", \")))) {\n                        editable.insert(pos - 2, \", \" + nick);\n                        return;\n                    }\n                }\n                editable.insert(pos, (Character.isWhitespace(before) ? \"\" : \" \") + nick + (Character.isWhitespace(after) ? \"\" : \" \"));\n                if (Character.isWhitespace(after)) {\n                    this.binding.textinput.setSelection(this.binding.textinput.getSelectionStart() + 1);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        final Activity activity = getActivity();\n        if (activity instanceof ConversationsActivity) {\n            ((ConversationsActivity) activity).clearPendingViewIntent();\n        }\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        if (conversation != null) {\n            outState.putString(STATE_CONVERSATION_UUID, conversation.getUuid());\n            outState.putString(STATE_LAST_MESSAGE_UUID, lastMessageUuid);\n            final Uri uri = pendingTakePhotoUri.peek();\n            if (uri != null) {\n                outState.putString(STATE_PHOTO_URI, uri.toString());\n            }\n            final ScrollState scrollState = getScrollPosition();\n            if (scrollState != null) {\n                outState.putParcelable(STATE_SCROLL_POSITION, scrollState);\n            }\n            final ArrayList<Attachment> attachments = mediaPreviewAdapter.getAttachments();\n            if (attachments.size() > 0) {\n                outState.putParcelableArrayList(STATE_MEDIA_PREVIEWS, attachments);\n            }\n        }\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        if (savedInstanceState == null) {\n            return;\n        }\n        String uuid = savedInstanceState.getString(STATE_CONVERSATION_UUID);\n        ArrayList<Attachment> attachments = savedInstanceState.getParcelableArrayList(STATE_MEDIA_PREVIEWS);\n        pendingLastMessageUuid.push(savedInstanceState.getString(STATE_LAST_MESSAGE_UUID, null));\n        if (uuid != null) {\n            QuickLoader.set(uuid);\n            this.pendingConversationsUuid.push(uuid);\n            if (attachments != null && attachments.size() > 0) {\n                this.pendingMediaPreviews.push(attachments);\n            }\n            String takePhotoUri = savedInstanceState.getString(STATE_PHOTO_URI);\n            if (takePhotoUri != null) {\n                pendingTakePhotoUri.push(Uri.parse(takePhotoUri));\n            }\n            pendingScrollState.push(savedInstanceState.getParcelable(STATE_SCROLL_POSITION));\n        }\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        if (this.reInitRequiredOnStart && this.conversation != null) {\n            final Bundle extras = pendingExtras.pop();\n            reInit(this.conversation, extras != null);\n            if (extras != null) {\n                processExtras(extras);\n            }\n        } else if (conversation == null && activity != null && activity.xmppConnectionService != null) {\n            final String uuid = pendingConversationsUuid.pop();\n            Log.d(Config.LOGTAG, \"ConversationFragment.onStart() - activity was bound but no conversation loaded. uuid=\" + uuid);\n            if (uuid != null) {\n                findAndReInitByUuidOrArchive(uuid);\n            }\n        }\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        final Activity activity = getActivity();\n        messageListAdapter.unregisterListenerInAudioPlayer();\n        if (activity == null || !activity.isChangingConfigurations()) {\n            hideSoftKeyboard(activity);\n            messageListAdapter.stopAudioPlayer();\n        }\n        if (this.conversation != null) {\n            final String msg = this.binding.textinput.getText().toString();\n            storeNextMessage(msg);\n            updateChatState(this.conversation, msg);\n            this.activity.xmppConnectionService.getNotificationService().setOpenConversation(null);\n        }\n        this.reInitRequiredOnStart = true;\n    }\n\n    private void updateChatState(final Conversation conversation, final String msg) {\n        ChatState state = msg.length() == 0 ? Config.DEFAULT_CHATSTATE : ChatState.PAUSED;\n        Account.State status = conversation.getAccount().getStatus();\n        if (status == Account.State.ONLINE && conversation.setOutgoingChatState(state)) {\n            activity.xmppConnectionService.sendChatState(conversation);\n        }\n    }\n\n    private void saveMessageDraftStopAudioPlayer() {\n        final Conversation previousConversation = this.conversation;\n        if (this.activity == null || this.binding == null || previousConversation == null) {\n            return;\n        }\n        Log.d(Config.LOGTAG, \"ConversationFragment.saveMessageDraftStopAudioPlayer()\");\n        final String msg = this.binding.textinput.getText().toString();\n        storeNextMessage(msg);\n        updateChatState(this.conversation, msg);\n        messageListAdapter.stopAudioPlayer();\n        mediaPreviewAdapter.clearPreviews();\n        toggleInputMethod();\n    }\n\n    public void reInit(Conversation conversation, Bundle extras) {\n        QuickLoader.set(conversation.getUuid());\n        this.saveMessageDraftStopAudioPlayer();\n        this.clearPending();\n        if (this.reInit(conversation, extras != null)) {\n            if (extras != null) {\n                processExtras(extras);\n            }\n            this.reInitRequiredOnStart = false;\n        } else {\n            this.reInitRequiredOnStart = true;\n            pendingExtras.push(extras);\n        }\n        resetUnreadMessagesCount();\n    }\n\n    private void reInit(Conversation conversation) {\n        reInit(conversation, false);\n    }\n\n    private boolean reInit(final Conversation conversation, final boolean hasExtras) {\n        if (conversation == null) {\n            return false;\n        }\n        this.conversation = conversation;\n        //once we set the conversation all is good and it will automatically do the right thing in onStart()\n        if (this.activity == null || this.binding == null) {\n            return false;\n        }\n\n        if (!activity.xmppConnectionService.isConversationStillOpen(this.conversation)) {\n            activity.onConversationArchived(this.conversation);\n            return false;\n        }\n\n        stopScrolling();\n        Log.d(Config.LOGTAG, \"reInit(hasExtras=\" + Boolean.toString(hasExtras) + \")\");\n\n        if (this.conversation.isRead() && hasExtras) {\n            Log.d(Config.LOGTAG, \"trimming conversation\");\n            this.conversation.trim();\n        }\n\n        setupIme();\n\n        final boolean scrolledToBottomAndNoPending = this.scrolledToBottom() && pendingScrollState.peek() == null;\n\n        this.binding.textSendButton.setContentDescription(activity.getString(R.string.send_message_to_x, conversation.getName()));\n        this.binding.textinput.setKeyboardListener(null);\n        this.binding.textinput.setText(\"\");\n        final boolean participating = conversation.getMode() == Conversational.MODE_SINGLE || conversation.getMucOptions().participating();\n        if (participating) {\n            this.binding.textinput.append(this.conversation.getNextMessage());\n        }\n        this.binding.textinput.setKeyboardListener(this);\n        messageListAdapter.updatePreferences();\n        refresh(false);\n        this.conversation.messagesLoaded.set(true);\n        Log.d(Config.LOGTAG, \"scrolledToBottomAndNoPending=\" + Boolean.toString(scrolledToBottomAndNoPending));\n\n        if (hasExtras || scrolledToBottomAndNoPending) {\n            resetUnreadMessagesCount();\n            synchronized (this.messageList) {\n                Log.d(Config.LOGTAG, \"jump to first unread message\");\n                final Message first = conversation.getFirstUnreadMessage();\n                final int bottom = Math.max(0, this.messageList.size() - 1);\n                final int pos;\n                final boolean jumpToBottom;\n                if (first == null) {\n                    pos = bottom;\n                    jumpToBottom = true;\n                } else {\n                    int i = getIndexOf(first.getUuid(), this.messageList);\n                    pos = i < 0 ? bottom : i;\n                    jumpToBottom = false;\n                }\n                setSelection(pos, jumpToBottom);\n            }\n        }\n\n\n        this.binding.messagesView.post(this::fireReadEvent);\n        //TODO if we only do this when this fragment is running on main it won't *bing* in tablet layout which might be unnecessary since we can *see* it\n        activity.xmppConnectionService.getNotificationService().setOpenConversation(this.conversation);\n        return true;\n    }\n\n    private void resetUnreadMessagesCount() {\n        lastMessageUuid = null;\n        hideUnreadMessagesCount();\n    }\n\n    private void hideUnreadMessagesCount() {\n        if (this.binding == null) {\n            return;\n        }\n        this.binding.scrollToBottomButton.setEnabled(false);\n        this.binding.scrollToBottomButton.hide();\n        this.binding.unreadCountCustomView.setVisibility(View.GONE);\n    }\n\n    private void setSelection(int pos, boolean jumpToBottom) {\n        ListViewUtils.setSelection(this.binding.messagesView, pos, jumpToBottom);\n        this.binding.messagesView.post(() -> ListViewUtils.setSelection(this.binding.messagesView, pos, jumpToBottom));\n        this.binding.messagesView.post(this::fireReadEvent);\n    }\n\n\n    private boolean scrolledToBottom() {\n        return this.binding != null && scrolledToBottom(this.binding.messagesView);\n    }\n\n    private void processExtras(Bundle extras) {\n        final String downloadUuid = extras.getString(ConversationsActivity.EXTRA_DOWNLOAD_UUID);\n        final String text = extras.getString(Intent.EXTRA_TEXT);\n        final String nick = extras.getString(ConversationsActivity.EXTRA_NICK);\n        final boolean asQuote = extras.getBoolean(ConversationsActivity.EXTRA_AS_QUOTE);\n        final boolean pm = extras.getBoolean(ConversationsActivity.EXTRA_IS_PRIVATE_MESSAGE, false);\n        final boolean doNotAppend = extras.getBoolean(ConversationsActivity.EXTRA_DO_NOT_APPEND, false);\n        final List<Uri> uris = extractUris(extras);\n        if (uris != null && uris.size() > 0) {\n            final List<Uri> cleanedUris = cleanUris(new ArrayList<>(uris));\n            mediaPreviewAdapter.addMediaPreviews(Attachment.of(getActivity(), cleanedUris));\n            toggleInputMethod();\n            return;\n        }\n        if (nick != null) {\n            if (pm) {\n                Jid jid = conversation.getJid();\n                try {\n                    Jid next = Jid.of(jid.getLocal(), jid.getDomain(), nick);\n                    privateMessageWith(next);\n                } catch (final IllegalArgumentException ignored) {\n                    //do nothing\n                }\n            } else {\n                final MucOptions mucOptions = conversation.getMucOptions();\n                if (mucOptions.participating() || conversation.getNextCounterpart() != null) {\n                    highlightInConference(nick);\n                }\n            }\n        } else {\n            if (text != null && asQuote) {\n                quoteText(text);\n            } else {\n                appendText(text, doNotAppend);\n            }\n        }\n        final Message message = downloadUuid == null ? null : conversation.findMessageWithFileAndUuid(downloadUuid);\n        if (message != null) {\n            startDownloadable(message);\n        }\n    }\n\n    private List<Uri> extractUris(Bundle extras) {\n        final List<Uri> uris = extras.getParcelableArrayList(Intent.EXTRA_STREAM);\n        if (uris != null) {\n            return uris;\n        }\n        final Uri uri = extras.getParcelable(Intent.EXTRA_STREAM);\n        if (uri != null) {\n            return Collections.singletonList(uri);\n        } else {\n            return null;\n        }\n    }\n\n    private List<Uri> cleanUris(List<Uri> uris) {\n        Iterator<Uri> iterator = uris.iterator();\n        while(iterator.hasNext()) {\n            final Uri uri = iterator.next();\n            if (FileBackend.weOwnFile(getActivity(), uri)) {\n                iterator.remove();\n                Toast.makeText(getActivity(), R.string.security_violation_not_attaching_file, Toast.LENGTH_SHORT).show();\n            }\n        }\n        return uris;\n    }\n\n    private boolean showBlockSubmenu(View view) {\n        final Jid jid = conversation.getJid();\n        if (jid.getLocal() == null) {\n            BlockContactDialog.show(activity, conversation);\n        } else {\n            PopupMenu popupMenu = new PopupMenu(getActivity(), view);\n            popupMenu.inflate(R.menu.block);\n            popupMenu.setOnMenuItemClickListener(menuItem -> {\n                Blockable blockable;\n                switch (menuItem.getItemId()) {\n                    case R.id.block_domain:\n                        blockable = conversation.getAccount().getRoster().getContact(Jid.ofDomain(jid.getDomain()));\n                        break;\n                    default:\n                        blockable = conversation;\n                }\n                BlockContactDialog.show(activity, blockable);\n                return true;\n            });\n            popupMenu.show();\n        }\n        return true;\n    }\n\n    private void updateSnackBar(final Conversation conversation) {\n        final Account account = conversation.getAccount();\n        final XmppConnection connection = account.getXmppConnection();\n        final int mode = conversation.getMode();\n        final Contact contact = mode == Conversation.MODE_SINGLE ? conversation.getContact() : null;\n        if (conversation.getStatus() == Conversation.STATUS_ARCHIVED) {\n            return;\n        }\n        if (account.getStatus() == Account.State.DISABLED) {\n            showSnackbar(R.string.this_account_is_disabled, R.string.enable, this.mEnableAccountListener);\n        } else if (conversation.isBlocked()) {\n            showSnackbar(R.string.contact_blocked, R.string.unblock, this.mUnblockClickListener);\n        } else if (contact != null && !contact.showInRoster() && contact.getOption(Contact.Options.PENDING_SUBSCRIPTION_REQUEST)) {\n            showSnackbar(R.string.contact_added_you, R.string.add_back, this.mAddBackClickListener, this.mLongPressBlockListener);\n        } else if (contact != null && contact.getOption(Contact.Options.PENDING_SUBSCRIPTION_REQUEST)) {\n            showSnackbar(R.string.contact_asks_for_presence_subscription, R.string.allow, this.mAllowPresenceSubscription, this.mLongPressBlockListener);\n        } else if (mode == Conversation.MODE_MULTI\n                && !conversation.getMucOptions().online()\n                && account.getStatus() == Account.State.ONLINE) {\n            switch (conversation.getMucOptions().getError()) {\n                case NICK_IN_USE:\n                    showSnackbar(R.string.nick_in_use, R.string.edit, clickToMuc);\n                    break;\n                case NO_RESPONSE:\n                    showSnackbar(R.string.joining_conference, 0, null);\n                    break;\n                case SERVER_NOT_FOUND:\n                    if (conversation.receivedMessagesCount() > 0) {\n                        showSnackbar(R.string.remote_server_not_found, R.string.try_again, joinMuc);\n                    } else {\n                        showSnackbar(R.string.remote_server_not_found, R.string.leave, leaveMuc);\n                    }\n                    break;\n                case REMOTE_SERVER_TIMEOUT:\n                    if (conversation.receivedMessagesCount() > 0) {\n                        showSnackbar(R.string.remote_server_timeout, R.string.try_again, joinMuc);\n                    } else {\n                        showSnackbar(R.string.remote_server_timeout, R.string.leave, leaveMuc);\n                    }\n                    break;\n                case PASSWORD_REQUIRED:\n                    showSnackbar(R.string.conference_requires_password, R.string.enter_password, enterPassword);\n                    break;\n                case BANNED:\n                    showSnackbar(R.string.conference_banned, R.string.leave, leaveMuc);\n                    break;\n                case MEMBERS_ONLY:\n                    showSnackbar(R.string.conference_members_only, R.string.leave, leaveMuc);\n                    break;\n                case RESOURCE_CONSTRAINT:\n                    showSnackbar(R.string.conference_resource_constraint, R.string.try_again, joinMuc);\n                    break;\n                case KICKED:\n                    showSnackbar(R.string.conference_kicked, R.string.join, joinMuc);\n                    break;\n                case UNKNOWN:\n                    showSnackbar(R.string.conference_unknown_error, R.string.try_again, joinMuc);\n                    break;\n                case INVALID_NICK:\n                    showSnackbar(R.string.invalid_muc_nick, R.string.edit, clickToMuc);\n                case SHUTDOWN:\n                    showSnackbar(R.string.conference_shutdown, R.string.try_again, joinMuc);\n                    break;\n                case DESTROYED:\n                    showSnackbar(R.string.conference_destroyed, R.string.leave, leaveMuc);\n                    break;\n                default:\n                    hideSnackbar();\n                    break;\n            }\n        } else if (account.hasPendingPgpIntent(conversation)) {\n            showSnackbar(R.string.openpgp_messages_found, R.string.decrypt, clickToDecryptListener);\n        } else if (connection != null\n                && connection.getFeatures().blocking()\n                && conversation.countMessages() != 0\n                && !conversation.isBlocked()\n                && conversation.isWithStranger()) {\n            showSnackbar(R.string.received_message_from_stranger, R.string.block, mBlockClickListener);\n        } else {\n            hideSnackbar();\n        }\n    }\n\n    @Override\n    public void refresh() {\n        if (this.binding == null) {\n            Log.d(Config.LOGTAG, \"ConversationFragment.refresh() skipped updated because view binding was null\");\n            return;\n        }\n        if (this.conversation != null && this.activity != null && this.activity.xmppConnectionService != null) {\n            if (!activity.xmppConnectionService.isConversationStillOpen(this.conversation)) {\n                activity.onConversationArchived(this.conversation);\n                return;\n            }\n        }\n        this.refresh(true);\n    }\n\n    private void refresh(boolean notifyConversationRead) {\n        synchronized (this.messageList) {\n            if (this.conversation != null) {\n                conversation.populateWithMessages(this.messageList);\n                updateSnackBar(conversation);\n                updateStatusMessages();\n                if (conversation.getReceivedMessagesCountSinceUuid(lastMessageUuid) != 0) {\n                    binding.unreadCountCustomView.setVisibility(View.VISIBLE);\n                    binding.unreadCountCustomView.setUnreadCount(conversation.getReceivedMessagesCountSinceUuid(lastMessageUuid));\n                }\n                this.messageListAdapter.notifyDataSetChanged();\n                updateChatMsgHint();\n                if (notifyConversationRead && activity != null) {\n                    binding.messagesView.post(this::fireReadEvent);\n                }\n                updateSendButton();\n                updateEditablity();\n                activity.invalidateOptionsMenu();\n            }\n        }\n    }\n\n    protected void messageSent() {\n        mSendingPgpMessage.set(false);\n        this.binding.textinput.setText(\"\");\n        if (conversation.setCorrectingMessage(null)) {\n            this.binding.textinput.append(conversation.getDraftMessage());\n            conversation.setDraftMessage(null);\n        }\n        storeNextMessage();\n        updateChatMsgHint();\n        SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(activity);\n        final boolean prefScrollToBottom = p.getBoolean(\"scroll_to_bottom\", activity.getResources().getBoolean(R.bool.scroll_to_bottom));\n        if (prefScrollToBottom || scrolledToBottom()) {\n            new Handler().post(() -> {\n                int size = messageList.size();\n                this.binding.messagesView.setSelection(size - 1);\n            });\n        }\n    }\n\n    private boolean storeNextMessage() {\n        return storeNextMessage(this.binding.textinput.getText().toString());\n    }\n\n    private boolean storeNextMessage(String msg) {\n        final boolean participating = conversation.getMode() == Conversational.MODE_SINGLE || conversation.getMucOptions().participating();\n        if (this.conversation.getStatus() != Conversation.STATUS_ARCHIVED && participating && this.conversation.setNextMessage(msg)) {\n            this.activity.xmppConnectionService.updateConversation(this.conversation);\n            return true;\n        }\n        return false;\n    }\n\n    public void doneSendingPgpMessage() {\n        mSendingPgpMessage.set(false);\n    }\n\n    public long getMaxHttpUploadSize(Conversation conversation) {\n        final XmppConnection connection = conversation.getAccount().getXmppConnection();\n        return connection == null ? -1 : connection.getFeatures().getMaxHttpUploadSize();\n    }\n\n    private void updateEditablity() {\n        boolean canWrite = this.conversation.getMode() == Conversation.MODE_SINGLE || this.conversation.getMucOptions().participating() || this.conversation.getNextCounterpart() != null;\n        this.binding.textinput.setFocusable(canWrite);\n        this.binding.textinput.setFocusableInTouchMode(canWrite);\n        this.binding.textSendButton.setEnabled(canWrite);\n        this.binding.textinput.setCursorVisible(canWrite);\n        this.binding.textinput.setEnabled(canWrite);\n    }\n\n    public void updateSendButton() {\n        boolean hasAttachments = mediaPreviewAdapter != null && mediaPreviewAdapter.hasAttachments();\n        boolean useSendButtonToIndicateStatus = PreferenceManager.getDefaultSharedPreferences(getActivity()).getBoolean(\"send_button_status\", getResources().getBoolean(R.bool.send_button_status));\n        final Conversation c = this.conversation;\n        final Presence.Status status;\n        final String text = this.binding.textinput == null ? \"\" : this.binding.textinput.getText().toString();\n        final SendButtonAction action;\n        if (hasAttachments) {\n            action = SendButtonAction.TEXT;\n        } else {\n            action = SendButtonTool.getAction(getActivity(), c, text);\n        }\n        if (useSendButtonToIndicateStatus && c.getAccount().getStatus() == Account.State.ONLINE) {\n            if (activity.xmppConnectionService != null && activity.xmppConnectionService.getMessageArchiveService().isCatchingUp(c)) {\n                status = Presence.Status.OFFLINE;\n            } else if (c.getMode() == Conversation.MODE_SINGLE) {\n                status = c.getContact().getShownStatus();\n            } else {\n                status = c.getMucOptions().online() ? Presence.Status.ONLINE : Presence.Status.OFFLINE;\n            }\n        } else {\n            status = Presence.Status.OFFLINE;\n        }\n        this.binding.textSendButton.setTag(action);\n        this.binding.textSendButton.setImageResource(SendButtonTool.getSendButtonImageResource(getActivity(), action, status));\n    }\n\n    protected void updateDateSeparators() {\n        synchronized (this.messageList) {\n            DateSeparator.addAll(this.messageList);\n        }\n    }\n\n    protected void updateStatusMessages() {\n        updateDateSeparators();\n        synchronized (this.messageList) {\n            if (showLoadMoreMessages(conversation)) {\n                this.messageList.add(0, Message.createLoadMoreMessage(conversation));\n            }\n            if (conversation.getMode() == Conversation.MODE_SINGLE) {\n                ChatState state = conversation.getIncomingChatState();\n                if (state == ChatState.COMPOSING) {\n                    this.messageList.add(Message.createStatusMessage(conversation, getString(R.string.contact_is_typing, conversation.getName())));\n                } else if (state == ChatState.PAUSED) {\n                    this.messageList.add(Message.createStatusMessage(conversation, getString(R.string.contact_has_stopped_typing, conversation.getName())));\n                } else {\n                    for (int i = this.messageList.size() - 1; i >= 0; --i) {\n                        final Message message = this.messageList.get(i);\n                        if (message.getType() != Message.TYPE_STATUS) {\n                            if (message.getStatus() == Message.STATUS_RECEIVED) {\n                                return;\n                            } else {\n                                if (message.getStatus() == Message.STATUS_SEND_DISPLAYED) {\n                                    this.messageList.add(i + 1,\n                                            Message.createStatusMessage(conversation, getString(R.string.contact_has_read_up_to_this_point, conversation.getName())));\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                final MucOptions mucOptions = conversation.getMucOptions();\n                final List<MucOptions.User> allUsers = mucOptions.getUsers();\n                final Set<ReadByMarker> addedMarkers = new HashSet<>();\n                ChatState state = ChatState.COMPOSING;\n                List<MucOptions.User> users = conversation.getMucOptions().getUsersWithChatState(state, 5);\n                if (users.size() == 0) {\n                    state = ChatState.PAUSED;\n                    users = conversation.getMucOptions().getUsersWithChatState(state, 5);\n                }\n                if (mucOptions.isPrivateAndNonAnonymous()) {\n                    for (int i = this.messageList.size() - 1; i >= 0; --i) {\n                        final Set<ReadByMarker> markersForMessage = messageList.get(i).getReadByMarkers();\n                        final List<MucOptions.User> shownMarkers = new ArrayList<>();\n                        for (ReadByMarker marker : markersForMessage) {\n                            if (!ReadByMarker.contains(marker, addedMarkers)) {\n                                addedMarkers.add(marker); //may be put outside this condition. set should do dedup anyway\n                                MucOptions.User user = mucOptions.findUser(marker);\n                                if (user != null && !users.contains(user)) {\n                                    shownMarkers.add(user);\n                                }\n                            }\n                        }\n                        final ReadByMarker markerForSender = ReadByMarker.from(messageList.get(i));\n                        final Message statusMessage;\n                        final int size = shownMarkers.size();\n                        if (size > 1) {\n                            final String body;\n                            if (size <= 4) {\n                                body = getString(R.string.contacts_have_read_up_to_this_point, UIHelper.concatNames(shownMarkers));\n                            } else if (ReadByMarker.allUsersRepresented(allUsers, markersForMessage, markerForSender)) {\n                                body = getString(R.string.everyone_has_read_up_to_this_point);\n                            } else {\n                                body = getString(R.string.contacts_and_n_more_have_read_up_to_this_point, UIHelper.concatNames(shownMarkers, 3), size - 3);\n                            }\n                            statusMessage = Message.createStatusMessage(conversation, body);\n                            statusMessage.setCounterparts(shownMarkers);\n                        } else if (size == 1) {\n                            statusMessage = Message.createStatusMessage(conversation, getString(R.string.contact_has_read_up_to_this_point, UIHelper.getDisplayName(shownMarkers.get(0))));\n                            statusMessage.setCounterpart(shownMarkers.get(0).getFullJid());\n                            statusMessage.setTrueCounterpart(shownMarkers.get(0).getRealJid());\n                        } else {\n                            statusMessage = null;\n                        }\n                        if (statusMessage != null) {\n                            this.messageList.add(i + 1, statusMessage);\n                        }\n                        addedMarkers.add(markerForSender);\n                        if (ReadByMarker.allUsersRepresented(allUsers, addedMarkers)) {\n                            break;\n                        }\n                    }\n                }\n                if (users.size() > 0) {\n                    Message statusMessage;\n                    if (users.size() == 1) {\n                        MucOptions.User user = users.get(0);\n                        int id = state == ChatState.COMPOSING ? R.string.contact_is_typing : R.string.contact_has_stopped_typing;\n                        statusMessage = Message.createStatusMessage(conversation, getString(id, UIHelper.getDisplayName(user)));\n                        statusMessage.setTrueCounterpart(user.getRealJid());\n                        statusMessage.setCounterpart(user.getFullJid());\n                    } else {\n                        int id = state == ChatState.COMPOSING ? R.string.contacts_are_typing : R.string.contacts_have_stopped_typing;\n                        statusMessage = Message.createStatusMessage(conversation, getString(id, UIHelper.concatNames(users)));\n                        statusMessage.setCounterparts(users);\n                    }\n                    this.messageList.add(statusMessage);\n                }\n\n            }\n        }\n    }\n\n    private void stopScrolling() {\n        long now = SystemClock.uptimeMillis();\n        MotionEvent cancel = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0, 0, 0);\n        binding.messagesView.dispatchTouchEvent(cancel);\n    }\n\n    private boolean showLoadMoreMessages(final Conversation c) {\n        if (activity == null || activity.xmppConnectionService == null) {\n            return false;\n        }\n        final boolean mam = hasMamSupport(c) && !c.getContact().isBlocked();\n        final MessageArchiveService service = activity.xmppConnectionService.getMessageArchiveService();\n        return mam && (c.getLastClearHistory().getTimestamp() != 0 || (c.countMessages() == 0 && c.messagesLoaded.get() && c.hasMessagesLeftOnServer() && !service.queryInProgress(c)));\n    }\n\n    private boolean hasMamSupport(final Conversation c) {\n        if (c.getMode() == Conversation.MODE_SINGLE) {\n            final XmppConnection connection = c.getAccount().getXmppConnection();\n            return connection != null && connection.getFeatures().mam();\n        } else {\n            return c.getMucOptions().mamSupport();\n        }\n    }\n\n    protected void showSnackbar(final int message, final int action, final OnClickListener clickListener) {\n        showSnackbar(message, action, clickListener, null);\n    }\n\n    protected void showSnackbar(final int message, final int action, final OnClickListener clickListener, final View.OnLongClickListener longClickListener) {\n        this.binding.snackbar.setVisibility(View.VISIBLE);\n        this.binding.snackbar.setOnClickListener(null);\n        this.binding.snackbarMessage.setText(message);\n        this.binding.snackbarMessage.setOnClickListener(null);\n        this.binding.snackbarAction.setVisibility(clickListener == null ? View.GONE : View.VISIBLE);\n        if (action != 0) {\n            this.binding.snackbarAction.setText(action);\n        }\n        this.binding.snackbarAction.setOnClickListener(clickListener);\n        this.binding.snackbarAction.setOnLongClickListener(longClickListener);\n    }\n\n    protected void hideSnackbar() {\n        this.binding.snackbar.setVisibility(View.GONE);\n    }\n\n    protected void sendMessage(Message message) {\n        activity.xmppConnectionService.sendMessage(message);\n        messageSent();\n    }\n\n    protected void sendPgpMessage(final Message message) {\n        final XmppConnectionService xmppService = activity.xmppConnectionService;\n        final Contact contact = message.getConversation().getContact();\n        if (!activity.hasPgp()) {\n            activity.showInstallPgpDialog();\n            return;\n        }\n        if (conversation.getAccount().getPgpSignature() == null) {\n            activity.announcePgp(conversation.getAccount(), conversation, null, activity.onOpenPGPKeyPublished);\n            return;\n        }\n        if (!mSendingPgpMessage.compareAndSet(false, true)) {\n            Log.d(Config.LOGTAG, \"sending pgp message already in progress\");\n        }\n        if (conversation.getMode() == Conversation.MODE_SINGLE) {\n            if (contact.getPgpKeyId() != 0) {\n                xmppService.getPgpEngine().hasKey(contact,\n                        new UiCallback<Contact>() {\n\n                            @Override\n                            public void userInputRequried(PendingIntent pi, Contact contact) {\n                                startPendingIntent(pi, REQUEST_ENCRYPT_MESSAGE);\n                            }\n\n                            @Override\n                            public void success(Contact contact) {\n                                encryptTextMessage(message);\n                            }\n\n                            @Override\n                            public void error(int error, Contact contact) {\n                                activity.runOnUiThread(() -> Toast.makeText(activity,\n                                        R.string.unable_to_connect_to_keychain,\n                                        Toast.LENGTH_SHORT\n                                ).show());\n                                mSendingPgpMessage.set(false);\n                            }\n                        });\n\n            } else {\n                showNoPGPKeyDialog(false, (dialog, which) -> {\n                    conversation.setNextEncryption(Message.ENCRYPTION_NONE);\n                    xmppService.updateConversation(conversation);\n                    message.setEncryption(Message.ENCRYPTION_NONE);\n                    xmppService.sendMessage(message);\n                    messageSent();\n                });\n            }\n        } else {\n            if (conversation.getMucOptions().pgpKeysInUse()) {\n                if (!conversation.getMucOptions().everybodyHasKeys()) {\n                    Toast warning = Toast\n                            .makeText(getActivity(),\n                                    R.string.missing_public_keys,\n                                    Toast.LENGTH_LONG);\n                    warning.setGravity(Gravity.CENTER_VERTICAL, 0, 0);\n                    warning.show();\n                }\n                encryptTextMessage(message);\n            } else {\n                showNoPGPKeyDialog(true, (dialog, which) -> {\n                    conversation.setNextEncryption(Message.ENCRYPTION_NONE);\n                    message.setEncryption(Message.ENCRYPTION_NONE);\n                    xmppService.updateConversation(conversation);\n                    xmppService.sendMessage(message);\n                    messageSent();\n                });\n            }\n        }\n    }\n\n    public void encryptTextMessage(Message message) {\n        activity.xmppConnectionService.getPgpEngine().encrypt(message,\n                new UiCallback<Message>() {\n\n                    @Override\n                    public void userInputRequried(PendingIntent pi, Message message) {\n                        startPendingIntent(pi, REQUEST_SEND_MESSAGE);\n                    }\n\n                    @Override\n                    public void success(Message message) {\n                        //TODO the following two call can be made before the callback\n                        getActivity().runOnUiThread(() -> messageSent());\n                    }\n\n                    @Override\n                    public void error(final int error, Message message) {\n                        getActivity().runOnUiThread(() -> {\n                            doneSendingPgpMessage();\n                            Toast.makeText(getActivity(), R.string.unable_to_connect_to_keychain, Toast.LENGTH_SHORT).show();\n                        });\n\n                    }\n                });\n    }\n\n    public void showNoPGPKeyDialog(boolean plural, DialogInterface.OnClickListener listener) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setIconAttribute(android.R.attr.alertDialogIcon);\n        if (plural) {\n            builder.setTitle(getString(R.string.no_pgp_keys));\n            builder.setMessage(getText(R.string.contacts_have_no_pgp_keys));\n        } else {\n            builder.setTitle(getString(R.string.no_pgp_key));\n            builder.setMessage(getText(R.string.contact_has_no_pgp_key));\n        }\n        builder.setNegativeButton(getString(R.string.cancel), null);\n        builder.setPositiveButton(getString(R.string.send_unencrypted), listener);\n        builder.create().show();\n    }\n\n    public void appendText(String text, final boolean doNotAppend) {\n        if (text == null) {\n            return;\n        }\n        final Editable editable = this.binding.textinput.getText();\n        String previous =  editable == null ? \"\" : editable.toString();\n        if (doNotAppend && !TextUtils.isEmpty(previous)) {\n            Toast.makeText(getActivity(),R.string.already_drafting_message, Toast.LENGTH_LONG).show();\n            return;\n        }\n        if (UIHelper.isLastLineQuote(previous)) {\n            text = '\\n' + text;\n        } else if (previous.length() != 0 && !Character.isWhitespace(previous.charAt(previous.length() - 1))) {\n            text = \" \" + text;\n        }\n        this.binding.textinput.append(text);\n    }\n\n    @Override\n    public boolean onEnterPressed() {\n        SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(getActivity());\n        final boolean enterIsSend = p.getBoolean(\"enter_is_send\", getResources().getBoolean(R.bool.enter_is_send));\n        if (enterIsSend) {\n            sendMessage();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public void onTypingStarted() {\n        final XmppConnectionService service = activity == null ? null : activity.xmppConnectionService;\n        if (service == null) {\n            return;\n        }\n        Account.State status = conversation.getAccount().getStatus();\n        if (status == Account.State.ONLINE && conversation.setOutgoingChatState(ChatState.COMPOSING)) {\n            service.sendChatState(conversation);\n        }\n        updateSendButton();\n    }\n\n    @Override\n    public void onTypingStopped() {\n        final XmppConnectionService service = activity == null ? null : activity.xmppConnectionService;\n        if (service == null) {\n            return;\n        }\n        Account.State status = conversation.getAccount().getStatus();\n        if (status == Account.State.ONLINE && conversation.setOutgoingChatState(ChatState.PAUSED)) {\n            service.sendChatState(conversation);\n        }\n    }\n\n    @Override\n    public void onTextDeleted() {\n        final XmppConnectionService service = activity == null ? null : activity.xmppConnectionService;\n        if (service == null) {\n            return;\n        }\n        Account.State status = conversation.getAccount().getStatus();\n        if (status == Account.State.ONLINE && conversation.setOutgoingChatState(Config.DEFAULT_CHATSTATE)) {\n            service.sendChatState(conversation);\n        }\n        if (storeNextMessage()) {\n            activity.onConversationsListItemUpdated();\n        }\n        updateSendButton();\n    }\n\n    @Override\n    public void onTextChanged() {\n        if (conversation != null && conversation.getCorrectingMessage() != null) {\n            updateSendButton();\n        }\n    }\n\n    @Override\n    public boolean onTabPressed(boolean repeated) {\n        if (conversation == null || conversation.getMode() == Conversation.MODE_SINGLE) {\n            return false;\n        }\n        if (repeated) {\n            completionIndex++;\n        } else {\n            lastCompletionLength = 0;\n            completionIndex = 0;\n            final String content = this.binding.textinput.getText().toString();\n            lastCompletionCursor = this.binding.textinput.getSelectionEnd();\n            int start = lastCompletionCursor > 0 ? content.lastIndexOf(\" \", lastCompletionCursor - 1) + 1 : 0;\n            firstWord = start == 0;\n            incomplete = content.substring(start, lastCompletionCursor);\n        }\n        List<String> completions = new ArrayList<>();\n        for (MucOptions.User user : conversation.getMucOptions().getUsers()) {\n            String name = user.getName();\n            if (name != null && name.startsWith(incomplete)) {\n                completions.add(name + (firstWord ? \": \" : \" \"));\n            }\n        }\n        Collections.sort(completions);\n        if (completions.size() > completionIndex) {\n            String completion = completions.get(completionIndex).substring(incomplete.length());\n            this.binding.textinput.getEditableText().delete(lastCompletionCursor, lastCompletionCursor + lastCompletionLength);\n            this.binding.textinput.getEditableText().insert(lastCompletionCursor, completion);\n            lastCompletionLength = completion.length();\n        } else {\n            completionIndex = -1;\n            this.binding.textinput.getEditableText().delete(lastCompletionCursor, lastCompletionCursor + lastCompletionLength);\n            lastCompletionLength = 0;\n        }\n        return true;\n    }\n\n    private void startPendingIntent(PendingIntent pendingIntent, int requestCode) {\n        try {\n            getActivity().startIntentSenderForResult(pendingIntent.getIntentSender(), requestCode, null, 0, 0, 0);\n        } catch (final SendIntentException ignored) {\n        }\n    }\n\n    @Override\n    public void onBackendConnected() {\n        Log.d(Config.LOGTAG, \"ConversationFragment.onBackendConnected()\");\n        String uuid = pendingConversationsUuid.pop();\n        if (uuid != null) {\n            if (!findAndReInitByUuidOrArchive(uuid)) {\n                return;\n            }\n        } else {\n            if (!activity.xmppConnectionService.isConversationStillOpen(conversation)) {\n                clearPending();\n                activity.onConversationArchived(conversation);\n                return;\n            }\n        }\n        ActivityResult activityResult = postponedActivityResult.pop();\n        if (activityResult != null) {\n            handleActivityResult(activityResult);\n        }\n        clearPending();\n    }\n\n    private boolean findAndReInitByUuidOrArchive(@NonNull final String uuid) {\n        Conversation conversation = activity.xmppConnectionService.findConversationByUuid(uuid);\n        if (conversation == null) {\n            clearPending();\n            activity.onConversationArchived(null);\n            return false;\n        }\n        reInit(conversation);\n        ScrollState scrollState = pendingScrollState.pop();\n        String lastMessageUuid = pendingLastMessageUuid.pop();\n        List<Attachment> attachments = pendingMediaPreviews.pop();\n        if (scrollState != null) {\n            setScrollPosition(scrollState, lastMessageUuid);\n        }\n        if (attachments != null && attachments.size() > 0) {\n            Log.d(Config.LOGTAG, \"had attachments on restore\");\n            mediaPreviewAdapter.addMediaPreviews(attachments);\n            toggleInputMethod();\n        }\n        return true;\n    }\n\n    private void clearPending() {\n        if (postponedActivityResult.clear()) {\n            Log.e(Config.LOGTAG, \"cleared pending intent with unhandled result left\");\n        }\n        if (pendingScrollState.clear()) {\n            Log.e(Config.LOGTAG, \"cleared scroll state\");\n        }\n        if (pendingTakePhotoUri.clear()) {\n            Log.e(Config.LOGTAG, \"cleared pending photo uri\");\n        }\n    }\n\n    public Conversation getConversation() {\n        return conversation;\n    }\n}", "/*\n * Copyright (c) 2018, Daniel Gultsch All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation and/or\n * other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors\n * may be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage eu.siacs.conversations.ui;\n\n\nimport android.annotation.SuppressLint;\nimport android.app.Activity;\nimport android.app.Fragment;\nimport android.app.FragmentManager;\nimport android.app.FragmentTransaction;\nimport android.content.ActivityNotFoundException;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.databinding.DataBindingUtil;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.Settings;\nimport android.support.annotation.IdRes;\nimport android.support.annotation.NonNull;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AlertDialog;\nimport android.support.v7.widget.Toolbar;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.widget.Toast;\n\nimport org.openintents.openpgp.util.OpenPgpApi;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport eu.siacs.conversations.Config;\nimport eu.siacs.conversations.R;\nimport eu.siacs.conversations.crypto.OmemoSetting;\nimport eu.siacs.conversations.databinding.ActivityConversationsBinding;\nimport eu.siacs.conversations.entities.Account;\nimport eu.siacs.conversations.entities.Conversation;\nimport eu.siacs.conversations.services.XmppConnectionService;\nimport eu.siacs.conversations.ui.interfaces.OnBackendConnected;\nimport eu.siacs.conversations.ui.interfaces.OnConversationArchived;\nimport eu.siacs.conversations.ui.interfaces.OnConversationRead;\nimport eu.siacs.conversations.ui.interfaces.OnConversationSelected;\nimport eu.siacs.conversations.ui.interfaces.OnConversationsListItemUpdated;\nimport eu.siacs.conversations.ui.service.EmojiService;\nimport eu.siacs.conversations.ui.util.ActivityResult;\nimport eu.siacs.conversations.ui.util.ConversationMenuConfigurator;\nimport eu.siacs.conversations.ui.util.MenuDoubleTabUtil;\nimport eu.siacs.conversations.ui.util.PendingItem;\nimport eu.siacs.conversations.utils.EmojiWrapper;\nimport eu.siacs.conversations.utils.ExceptionHelper;\nimport eu.siacs.conversations.utils.XmppUri;\nimport eu.siacs.conversations.xmpp.OnUpdateBlocklist;\nimport rocks.xmpp.addr.Jid;\n\nimport static eu.siacs.conversations.ui.ConversationFragment.REQUEST_DECRYPT_PGP;\n\npublic class ConversationsActivity extends XmppActivity implements OnConversationSelected, OnConversationArchived, OnConversationsListItemUpdated, OnConversationRead, XmppConnectionService.OnAccountUpdate, XmppConnectionService.OnConversationUpdate, XmppConnectionService.OnRosterUpdate, OnUpdateBlocklist, XmppConnectionService.OnShowErrorToast, XmppConnectionService.OnAffiliationChanged, XmppConnectionService.OnRoleChanged {\n\n    public static final String ACTION_VIEW_CONVERSATION = \"eu.siacs.conversations.action.VIEW\";\n    public static final String EXTRA_CONVERSATION = \"conversationUuid\";\n    public static final String EXTRA_DOWNLOAD_UUID = \"eu.siacs.conversations.download_uuid\";\n    public static final String EXTRA_AS_QUOTE = \"as_quote\";\n    public static final String EXTRA_NICK = \"nick\";\n    public static final String EXTRA_IS_PRIVATE_MESSAGE = \"pm\";\n    public static final String EXTRA_DO_NOT_APPEND = \"do_not_append\";\n\n    private static List<String> VIEW_AND_SHARE_ACTIONS = Arrays.asList(\n            ACTION_VIEW_CONVERSATION,\n            Intent.ACTION_SEND,\n            Intent.ACTION_SEND_MULTIPLE\n    );\n\n    public static final int REQUEST_OPEN_MESSAGE = 0x9876;\n    public static final int REQUEST_PLAY_PAUSE = 0x5432;\n\n\n    //secondary fragment (when holding the conversation, must be initialized before refreshing the overview fragment\n    private static final @IdRes\n    int[] FRAGMENT_ID_NOTIFICATION_ORDER = {R.id.secondary_fragment, R.id.main_fragment};\n    private final PendingItem<Intent> pendingViewIntent = new PendingItem<>();\n    private final PendingItem<ActivityResult> postponedActivityResult = new PendingItem<>();\n    private ActivityConversationsBinding binding;\n    private boolean mActivityPaused = true;\n    private AtomicBoolean mRedirectInProcess = new AtomicBoolean(false);\n\n    private static boolean isViewOrShareIntent(Intent i) {\n        Log.d(Config.LOGTAG, \"action: \" + (i == null ? null : i.getAction()));\n        return i != null && VIEW_AND_SHARE_ACTIONS.contains(i.getAction()) && i.hasExtra(EXTRA_CONVERSATION);\n    }\n\n    private static Intent createLauncherIntent(Context context) {\n        final Intent intent = new Intent(context, ConversationsActivity.class);\n        intent.setAction(Intent.ACTION_MAIN);\n        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n        return intent;\n    }\n\n    @Override\n    protected void refreshUiReal() {\n        for (@IdRes int id : FRAGMENT_ID_NOTIFICATION_ORDER) {\n            refreshFragment(id);\n        }\n    }\n\n    @Override\n    void onBackendConnected() {\n        if (performRedirectIfNecessary(true)) {\n            return;\n        }\n        xmppConnectionService.getNotificationService().setIsInForeground(true);\n        Intent intent = pendingViewIntent.pop();\n        if (intent != null) {\n            if (processViewIntent(intent)) {\n                if (binding.secondaryFragment != null) {\n                    notifyFragmentOfBackendConnected(R.id.main_fragment);\n                }\n                invalidateActionBarTitle();\n                return;\n            }\n        }\n        for (@IdRes int id : FRAGMENT_ID_NOTIFICATION_ORDER) {\n            notifyFragmentOfBackendConnected(id);\n        }\n\n        ActivityResult activityResult = postponedActivityResult.pop();\n        if (activityResult != null) {\n            handleActivityResult(activityResult);\n        }\n\n        invalidateActionBarTitle();\n        if (binding.secondaryFragment != null && ConversationFragment.getConversation(this) == null) {\n            Conversation conversation = ConversationsOverviewFragment.getSuggestion(this);\n            if (conversation != null) {\n                openConversation(conversation, null);\n            }\n        }\n        showDialogsIfMainIsOverview();\n    }\n\n    private boolean performRedirectIfNecessary(boolean noAnimation) {\n        return performRedirectIfNecessary(null, noAnimation);\n    }\n\n    private boolean performRedirectIfNecessary(final Conversation ignore, final boolean noAnimation) {\n        if (xmppConnectionService == null) {\n            return false;\n        }\n        boolean isConversationsListEmpty = xmppConnectionService.isConversationsListEmpty(ignore);\n        if (isConversationsListEmpty && mRedirectInProcess.compareAndSet(false, true)) {\n            final Intent intent = getRedirectionIntent(noAnimation);\n            runOnUiThread(() -> {\n                startActivity(intent);\n                if (noAnimation) {\n                    overridePendingTransition(0, 0);\n                }\n            });\n        }\n        return mRedirectInProcess.get();\n    }\n\n    private Intent getRedirectionIntent(boolean noAnimation) {\n        Account pendingAccount = xmppConnectionService.getPendingAccount();\n        Intent intent;\n        if (pendingAccount != null) {\n            intent = new Intent(this, EditAccountActivity.class);\n            intent.putExtra(\"jid\", pendingAccount.getJid().asBareJid().toString());\n        } else {\n            if (xmppConnectionService.getAccounts().size() == 0) {\n                if (Config.X509_VERIFICATION) {\n                    intent = new Intent(this, ManageAccountActivity.class);\n                } else if (Config.MAGIC_CREATE_DOMAIN != null) {\n                    intent = new Intent(this, WelcomeActivity.class);\n                    WelcomeActivity.addInviteUri(intent, getIntent());\n                } else {\n                    intent = new Intent(this, EditAccountActivity.class);\n                }\n            } else {\n                intent = new Intent(this, StartConversationActivity.class);\n            }\n        }\n        intent.putExtra(\"init\", true);\n        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n        if (noAnimation) {\n            intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\n        }\n        return intent;\n    }\n\n    private void showDialogsIfMainIsOverview() {\n        if (xmppConnectionService == null) {\n            return;\n        }\n        final Fragment fragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n        if (fragment != null && fragment instanceof ConversationsOverviewFragment) {\n            if (ExceptionHelper.checkForCrash(this)) {\n                return;\n            }\n            openBatteryOptimizationDialogIfNeeded();\n        }\n    }\n\n    private String getBatteryOptimizationPreferenceKey() {\n        @SuppressLint(\"HardwareIds\") String device = Settings.Secure.getString(getContentResolver(), Settings.Secure.ANDROID_ID);\n        return \"show_battery_optimization\" + (device == null ? \"\" : device);\n    }\n\n    private void setNeverAskForBatteryOptimizationsAgain() {\n        getPreferences().edit().putBoolean(getBatteryOptimizationPreferenceKey(), false).apply();\n    }\n\n    private void openBatteryOptimizationDialogIfNeeded() {\n        if (hasAccountWithoutPush()\n                && isOptimizingBattery()\n                && getPreferences().getBoolean(getBatteryOptimizationPreferenceKey(), true)) {\n            AlertDialog.Builder builder = new AlertDialog.Builder(this);\n            builder.setTitle(R.string.battery_optimizations_enabled);\n            builder.setMessage(R.string.battery_optimizations_enabled_dialog);\n            builder.setPositiveButton(R.string.next, (dialog, which) -> {\n                Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);\n                Uri uri = Uri.parse(\"package:\" + getPackageName());\n                intent.setData(uri);\n                try {\n                    startActivityForResult(intent, REQUEST_BATTERY_OP);\n                } catch (ActivityNotFoundException e) {\n                    Toast.makeText(this, R.string.device_does_not_support_battery_op, Toast.LENGTH_SHORT).show();\n                }\n            });\n            builder.setOnDismissListener(dialog -> setNeverAskForBatteryOptimizationsAgain());\n            final AlertDialog dialog = builder.create();\n            dialog.setCanceledOnTouchOutside(false);\n            dialog.show();\n        }\n    }\n\n    private boolean hasAccountWithoutPush() {\n        for (Account account : xmppConnectionService.getAccounts()) {\n            if (account.getStatus() == Account.State.ONLINE && !xmppConnectionService.getPushManagementService().available(account)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void notifyFragmentOfBackendConnected(@IdRes int id) {\n        final Fragment fragment = getFragmentManager().findFragmentById(id);\n        if (fragment != null && fragment instanceof OnBackendConnected) {\n            ((OnBackendConnected) fragment).onBackendConnected();\n        }\n    }\n\n    private void refreshFragment(@IdRes int id) {\n        final Fragment fragment = getFragmentManager().findFragmentById(id);\n        if (fragment != null && fragment instanceof XmppFragment) {\n            ((XmppFragment) fragment).refresh();\n        }\n    }\n\n    private boolean processViewIntent(Intent intent) {\n        String uuid = intent.getStringExtra(EXTRA_CONVERSATION);\n        Conversation conversation = uuid != null ? xmppConnectionService.findConversationByUuid(uuid) : null;\n        if (conversation == null) {\n            Log.d(Config.LOGTAG, \"unable to view conversation with uuid:\" + uuid);\n            return false;\n        }\n        openConversation(conversation, intent.getExtras());\n        return true;\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String permissions[], @NonNull int[] grantResults) {\n        UriHandlerActivity.onRequestPermissionResult(this, requestCode, grantResults);\n        if (grantResults.length > 0) {\n            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                switch (requestCode) {\n                    case REQUEST_OPEN_MESSAGE:\n                        refreshUiReal();\n                        ConversationFragment.openPendingMessage(this);\n                        break;\n                    case REQUEST_PLAY_PAUSE:\n                        ConversationFragment.startStopPending(this);\n                        break;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, final Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        ActivityResult activityResult = ActivityResult.of(requestCode, resultCode, data);\n        if (xmppConnectionService != null) {\n            handleActivityResult(activityResult);\n        } else {\n            this.postponedActivityResult.push(activityResult);\n        }\n    }\n\n    private void handleActivityResult(ActivityResult activityResult) {\n        if (activityResult.resultCode == Activity.RESULT_OK) {\n            handlePositiveActivityResult(activityResult.requestCode, activityResult.data);\n        } else {\n            handleNegativeActivityResult(activityResult.requestCode);\n        }\n    }\n\n    private void handleNegativeActivityResult(int requestCode) {\n        Conversation conversation = ConversationFragment.getConversationReliable(this);\n        switch (requestCode) {\n            case REQUEST_DECRYPT_PGP:\n                if (conversation == null) {\n                    break;\n                }\n                conversation.getAccount().getPgpDecryptionService().giveUpCurrentDecryption();\n                break;\n            case REQUEST_BATTERY_OP:\n                setNeverAskForBatteryOptimizationsAgain();\n                break;\n        }\n    }\n\n    private void handlePositiveActivityResult(int requestCode, final Intent data) {\n        Conversation conversation = ConversationFragment.getConversationReliable(this);\n        if (conversation == null) {\n            Log.d(Config.LOGTAG, \"conversation not found\");\n            return;\n        }\n        switch (requestCode) {\n            case REQUEST_DECRYPT_PGP:\n                conversation.getAccount().getPgpDecryptionService().continueDecryption(data);\n                break;\n            case REQUEST_CHOOSE_PGP_ID:\n                long id = data.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID, 0);\n                if (id != 0) {\n                    conversation.getAccount().setPgpSignId(id);\n                    announcePgp(conversation.getAccount(), null, null, onOpenPGPKeyPublished);\n                } else {\n                    choosePgpSignId(conversation.getAccount());\n                }\n                break;\n            case REQUEST_ANNOUNCE_PGP:\n                announcePgp(conversation.getAccount(), conversation, data, onOpenPGPKeyPublished);\n                break;\n        }\n    }\n\n    @Override\n    protected void onCreate(final Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ConversationMenuConfigurator.reloadFeatures(this);\n        OmemoSetting.load(this);\n        new EmojiService(this).init();\n        this.binding = DataBindingUtil.setContentView(this, R.layout.activity_conversations);\n        setSupportActionBar((Toolbar) binding.toolbar);\n        configureActionBar(getSupportActionBar());\n        this.getFragmentManager().addOnBackStackChangedListener(this::invalidateActionBarTitle);\n        this.getFragmentManager().addOnBackStackChangedListener(this::showDialogsIfMainIsOverview);\n        this.initializeFragments();\n        this.invalidateActionBarTitle();\n        final Intent intent;\n        if (savedInstanceState == null) {\n            intent = getIntent();\n        } else {\n            intent = savedInstanceState.getParcelable(\"intent\");\n        }\n        if (isViewOrShareIntent(intent)) {\n            pendingViewIntent.push(intent);\n            setIntent(createLauncherIntent(this));\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.activity_conversations, menu);\n        MenuItem qrCodeScanMenuItem = menu.findItem(R.id.action_scan_qr_code);\n        if (qrCodeScanMenuItem != null) {\n            if (isCameraFeatureAvailable()) {\n                Fragment fragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n                boolean visible = getResources().getBoolean(R.bool.show_qr_code_scan)\n                        && fragment != null\n                        && fragment instanceof ConversationsOverviewFragment;\n                qrCodeScanMenuItem.setVisible(visible);\n            } else {\n                qrCodeScanMenuItem.setVisible(false);\n            }\n        }\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public void onConversationSelected(Conversation conversation) {\n        clearPendingViewIntent();\n        if (ConversationFragment.getConversation(this) == conversation) {\n            Log.d(Config.LOGTAG, \"ignore onConversationSelected() because conversation is already open\");\n            return;\n        }\n        openConversation(conversation, null);\n    }\n\n    public void clearPendingViewIntent() {\n        if (pendingViewIntent.clear()) {\n            Log.e(Config.LOGTAG, \"cleared pending view intent\");\n        }\n    }\n\n    private void displayToast(final String msg) {\n        runOnUiThread(() -> Toast.makeText(ConversationsActivity.this, msg, Toast.LENGTH_SHORT).show());\n    }\n\n    @Override\n    public void onAffiliationChangedSuccessful(Jid jid) {\n\n    }\n\n    @Override\n    public void onAffiliationChangeFailed(Jid jid, int resId) {\n        displayToast(getString(resId, jid.asBareJid().toString()));\n    }\n\n    @Override\n    public void onRoleChangedSuccessful(String nick) {\n\n    }\n\n    @Override\n    public void onRoleChangeFailed(String nick, int resId) {\n        displayToast(getString(resId, nick));\n    }\n\n    private void openConversation(Conversation conversation, Bundle extras) {\n        ConversationFragment conversationFragment = (ConversationFragment) getFragmentManager().findFragmentById(R.id.secondary_fragment);\n        final boolean mainNeedsRefresh;\n        if (conversationFragment == null) {\n            mainNeedsRefresh = false;\n            Fragment mainFragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n            if (mainFragment != null && mainFragment instanceof ConversationFragment) {\n                conversationFragment = (ConversationFragment) mainFragment;\n            } else {\n                conversationFragment = new ConversationFragment();\n                FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();\n                fragmentTransaction.replace(R.id.main_fragment, conversationFragment);\n                fragmentTransaction.addToBackStack(null);\n                try {\n                    fragmentTransaction.commit();\n                } catch (IllegalStateException e) {\n                    Log.w(Config.LOGTAG, \"sate loss while opening conversation\", e);\n                    //allowing state loss is probably fine since view intents et all are already stored and a click can probably be 'ignored'\n                    return;\n                }\n            }\n        } else {\n            mainNeedsRefresh = true;\n        }\n        conversationFragment.reInit(conversation, extras == null ? new Bundle() : extras);\n        if (mainNeedsRefresh) {\n            refreshFragment(R.id.main_fragment);\n        } else {\n            invalidateActionBarTitle();\n        }\n    }\n\n    public boolean onXmppUriClicked(Uri uri) {\n        XmppUri xmppUri = new XmppUri(uri);\n        if (xmppUri.isJidValid() && !xmppUri.hasFingerprints()) {\n            final Conversation conversation = xmppConnectionService.findUniqueConversationByJid(xmppUri);\n            if (conversation != null) {\n                openConversation(conversation, null);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (MenuDoubleTabUtil.shouldIgnoreTap()) {\n            return false;\n        }\n        switch (item.getItemId()) {\n            case android.R.id.home:\n                FragmentManager fm = getFragmentManager();\n                if (fm.getBackStackEntryCount() > 0) {\n                    try {\n                        fm.popBackStack();\n                    } catch (IllegalStateException e) {\n                        Log.w(Config.LOGTAG, \"Unable to pop back stack after pressing home button\");\n                    }\n                    return true;\n                }\n                break;\n            case R.id.action_scan_qr_code:\n                UriHandlerActivity.scan(this);\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle savedInstanceState) {\n        Intent pendingIntent = pendingViewIntent.peek();\n        savedInstanceState.putParcelable(\"intent\", pendingIntent != null ? pendingIntent : getIntent());\n        super.onSaveInstanceState(savedInstanceState);\n    }\n\n    @Override\n    protected void onStart() {\n        final int theme = findTheme();\n        if (this.mTheme != theme) {\n            this.mSkipBackgroundBinding = true;\n            recreate();\n        } else {\n            this.mSkipBackgroundBinding = false;\n        }\n        mRedirectInProcess.set(false);\n        super.onStart();\n    }\n\n    @Override\n    protected void onNewIntent(final Intent intent) {\n        if (isViewOrShareIntent(intent)) {\n            if (xmppConnectionService != null) {\n                processViewIntent(intent);\n            } else {\n                pendingViewIntent.push(intent);\n            }\n        }\n        setIntent(createLauncherIntent(this));\n    }\n\n    @Override\n    public void onPause() {\n        this.mActivityPaused = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        this.mActivityPaused = false;\n    }\n\n    private void initializeFragments() {\n        FragmentTransaction transaction = getFragmentManager().beginTransaction();\n        Fragment mainFragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n        Fragment secondaryFragment = getFragmentManager().findFragmentById(R.id.secondary_fragment);\n        if (mainFragment != null) {\n            if (binding.secondaryFragment != null) {\n                if (mainFragment instanceof ConversationFragment) {\n                    getFragmentManager().popBackStack();\n                    transaction.remove(mainFragment);\n                    transaction.commit();\n                    getFragmentManager().executePendingTransactions();\n                    transaction = getFragmentManager().beginTransaction();\n                    transaction.replace(R.id.secondary_fragment, mainFragment);\n                    transaction.replace(R.id.main_fragment, new ConversationsOverviewFragment());\n                    transaction.commit();\n                    return;\n                }\n            } else {\n                if (secondaryFragment != null && secondaryFragment instanceof ConversationFragment) {\n                    transaction.remove(secondaryFragment);\n                    transaction.commit();\n                    getFragmentManager().executePendingTransactions();\n                    transaction = getFragmentManager().beginTransaction();\n                    transaction.replace(R.id.main_fragment, secondaryFragment);\n                    transaction.addToBackStack(null);\n                    transaction.commit();\n                    return;\n                }\n            }\n        } else {\n            transaction.replace(R.id.main_fragment, new ConversationsOverviewFragment());\n        }\n        if (binding.secondaryFragment != null && secondaryFragment == null) {\n            transaction.replace(R.id.secondary_fragment, new ConversationFragment());\n        }\n        transaction.commit();\n    }\n\n    private void invalidateActionBarTitle() {\n        final ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            Fragment mainFragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n            if (mainFragment != null && mainFragment instanceof ConversationFragment) {\n                final Conversation conversation = ((ConversationFragment) mainFragment).getConversation();\n                if (conversation != null) {\n                    actionBar.setTitle(EmojiWrapper.transform(conversation.getName()));\n                    actionBar.setDisplayHomeAsUpEnabled(true);\n                    return;\n                }\n            }\n            actionBar.setTitle(R.string.app_name);\n            actionBar.setDisplayHomeAsUpEnabled(false);\n        }\n    }\n\n    @Override\n    public void onConversationArchived(Conversation conversation) {\n        if (performRedirectIfNecessary(conversation, false)) {\n            return;\n        }\n        Fragment mainFragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n        if (mainFragment != null && mainFragment instanceof ConversationFragment) {\n            try {\n                getFragmentManager().popBackStack();\n            } catch (IllegalStateException e) {\n                Log.w(Config.LOGTAG, \"state loss while popping back state after archiving conversation\", e);\n                //this usually means activity is no longer active; meaning on the next open we will run through this again\n            }\n            return;\n        }\n        Fragment secondaryFragment = getFragmentManager().findFragmentById(R.id.secondary_fragment);\n        if (secondaryFragment != null && secondaryFragment instanceof ConversationFragment) {\n            if (((ConversationFragment) secondaryFragment).getConversation() == conversation) {\n                Conversation suggestion = ConversationsOverviewFragment.getSuggestion(this, conversation);\n                if (suggestion != null) {\n                    openConversation(suggestion, null);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onConversationsListItemUpdated() {\n        Fragment fragment = getFragmentManager().findFragmentById(R.id.main_fragment);\n        if (fragment != null && fragment instanceof ConversationsOverviewFragment) {\n            ((ConversationsOverviewFragment) fragment).refresh();\n        }\n    }\n\n    @Override\n    public void switchToConversation(Conversation conversation) {\n        Log.d(Config.LOGTAG, \"override\");\n        openConversation(conversation, null);\n    }\n\n    @Override\n    public void onConversationRead(Conversation conversation, String upToUuid) {\n        if (!mActivityPaused && pendingViewIntent.peek() == null) {\n            xmppConnectionService.sendReadMarker(conversation, upToUuid);\n        } else {\n            Log.d(Config.LOGTAG, \"ignoring read callback. mActivityPaused=\" + Boolean.toString(mActivityPaused));\n        }\n    }\n\n    @Override\n    public void onAccountUpdate() {\n        this.refreshUi();\n    }\n\n    @Override\n    public void onConversationUpdate() {\n        if (performRedirectIfNecessary(false)) {\n            return;\n        }\n        this.refreshUi();\n    }\n\n    @Override\n    public void onRosterUpdate() {\n        this.refreshUi();\n    }\n\n    @Override\n    public void OnUpdateBlocklist(OnUpdateBlocklist.Status status) {\n        this.refreshUi();\n    }\n\n    @Override\n    public void onShowErrorToast(int resId) {\n        runOnUiThread(() -> Toast.makeText(this, resId, Toast.LENGTH_SHORT).show());\n    }\n}\n", "package eu.siacs.conversations.ui;\n\nimport android.Manifest;\nimport android.annotation.SuppressLint;\nimport android.app.Dialog;\nimport android.app.PendingIntent;\nimport android.content.ActivityNotFoundException;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.databinding.DataBindingUtil;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.support.annotation.DrawableRes;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.support.v4.app.Fragment;\nimport android.support.v4.app.FragmentManager;\nimport android.support.v4.app.FragmentTransaction;\nimport android.support.v4.app.ListFragment;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AlertDialog;\nimport android.support.v7.widget.Toolbar;\nimport android.text.Editable;\nimport android.text.SpannableString;\nimport android.text.Spanned;\nimport android.text.TextWatcher;\nimport android.text.style.TypefaceSpan;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.view.ContextMenu;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\nimport android.widget.ArrayAdapter;\nimport android.widget.AutoCompleteTextView;\nimport android.widget.CheckBox;\nimport android.widget.EditText;\nimport android.widget.ListView;\nimport android.widget.Spinner;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport eu.siacs.conversations.Config;\nimport eu.siacs.conversations.R;\nimport eu.siacs.conversations.databinding.ActivityStartConversationBinding;\nimport eu.siacs.conversations.entities.Account;\nimport eu.siacs.conversations.entities.Bookmark;\nimport eu.siacs.conversations.entities.Contact;\nimport eu.siacs.conversations.entities.Conversation;\nimport eu.siacs.conversations.entities.ListItem;\nimport eu.siacs.conversations.entities.Presence;\nimport eu.siacs.conversations.services.XmppConnectionService;\nimport eu.siacs.conversations.services.XmppConnectionService.OnRosterUpdate;\nimport eu.siacs.conversations.ui.adapter.ListItemAdapter;\nimport eu.siacs.conversations.ui.interfaces.OnBackendConnected;\nimport eu.siacs.conversations.ui.service.EmojiService;\nimport eu.siacs.conversations.ui.util.JidDialog;\nimport eu.siacs.conversations.ui.util.MenuDoubleTabUtil;\nimport eu.siacs.conversations.ui.util.PendingItem;\nimport eu.siacs.conversations.ui.util.SoftKeyboardUtils;\nimport eu.siacs.conversations.utils.XmppUri;\nimport eu.siacs.conversations.xmpp.OnUpdateBlocklist;\nimport eu.siacs.conversations.xmpp.XmppConnection;\nimport rocks.xmpp.addr.Jid;\n\npublic class StartConversationActivity extends XmppActivity implements XmppConnectionService.OnConversationUpdate, OnRosterUpdate, OnUpdateBlocklist, CreateConferenceDialog.CreateConferenceDialogListener, JoinConferenceDialog.JoinConferenceDialogListener {\n\n\tprivate final int REQUEST_SYNC_CONTACTS = 0x28cf;\n\tprivate final int REQUEST_CREATE_CONFERENCE = 0x39da;\n\tprivate final PendingItem<Intent> pendingViewIntent = new PendingItem<>();\n\tprivate final PendingItem<String> mInitialSearchValue = new PendingItem<>();\n\tprivate final AtomicBoolean oneShotKeyboardSuppress = new AtomicBoolean();\n\tpublic int conference_context_id;\n\tpublic int contact_context_id;\n\tprivate ListPagerAdapter mListPagerAdapter;\n\tprivate List<ListItem> contacts = new ArrayList<>();\n\tprivate ListItemAdapter mContactsAdapter;\n\tprivate List<ListItem> conferences = new ArrayList<>();\n\tprivate ListItemAdapter mConferenceAdapter;\n\tprivate List<String> mActivatedAccounts = new ArrayList<>();\n\tprivate EditText mSearchEditText;\n\tprivate AtomicBoolean mRequestedContactsPermission = new AtomicBoolean(false);\n\tprivate boolean mHideOfflineContacts = false;\n\tprivate MenuItem.OnActionExpandListener mOnActionExpandListener = new MenuItem.OnActionExpandListener() {\n\n\t\t@Override\n\t\tpublic boolean onMenuItemActionExpand(MenuItem item) {\n\t\t\tmSearchEditText.post(() -> {\n\t\t\t\tupdateSearchViewHint();\n\t\t\t\tmSearchEditText.requestFocus();\n\t\t\t\tif (oneShotKeyboardSuppress.compareAndSet(true, false)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tInputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\t\t\t\tif (imm != null) {\n\t\t\t\t\timm.showSoftInput(mSearchEditText, InputMethodManager.SHOW_IMPLICIT);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onMenuItemActionCollapse(MenuItem item) {\n\t\t\tSoftKeyboardUtils.hideSoftKeyboard(StartConversationActivity.this);\n\t\t\tmSearchEditText.setText(\"\");\n\t\t\tfilter(null);\n\t\t\treturn true;\n\t\t}\n\t};\n\tprivate TextWatcher mSearchTextWatcher = new TextWatcher() {\n\n\t\t@Override\n\t\tpublic void afterTextChanged(Editable editable) {\n\t\t\tfilter(editable.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {\n\t\t}\n\t};\n\tprivate MenuItem mMenuSearchView;\n\tprivate ListItemAdapter.OnTagClickedListener mOnTagClickedListener = new ListItemAdapter.OnTagClickedListener() {\n\t\t@Override\n\t\tpublic void onTagClicked(String tag) {\n\t\t\tif (mMenuSearchView != null) {\n\t\t\t\tmMenuSearchView.expandActionView();\n\t\t\t\tmSearchEditText.setText(\"\");\n\t\t\t\tmSearchEditText.append(tag);\n\t\t\t\tfilter(tag);\n\t\t\t}\n\t\t}\n\t};\n\tprivate Pair<Integer, Intent> mPostponedActivityResult;\n\tprivate Toast mToast;\n\tprivate UiCallback<Conversation> mAdhocConferenceCallback = new UiCallback<Conversation>() {\n\t\t@Override\n\t\tpublic void success(final Conversation conversation) {\n\t\t\trunOnUiThread(() -> {\n\t\t\t\thideToast();\n\t\t\t\tswitchToConversation(conversation);\n\t\t\t});\n\t\t}\n\n\t\t@Override\n\t\tpublic void error(final int errorCode, Conversation object) {\n\t\t\trunOnUiThread(() -> replaceToast(getString(errorCode)));\n\t\t}\n\n\t\t@Override\n\t\tpublic void userInputRequried(PendingIntent pi, Conversation object) {\n\n\t\t}\n\t};\n\tprivate ActivityStartConversationBinding binding;\n\tprivate TextView.OnEditorActionListener mSearchDone = new TextView.OnEditorActionListener() {\n\t\t@Override\n\t\tpublic boolean onEditorAction(TextView v, int actionId, KeyEvent event) {\n\t\t\tint pos = binding.startConversationViewPager.getCurrentItem();\n\t\t\tif (pos == 0) {\n\t\t\t\tif (contacts.size() == 1) {\n\t\t\t\t\topenConversationForContact((Contact) contacts.get(0));\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (contacts.size() == 0 && conferences.size() == 1) {\n\t\t\t\t\topenConversationsForBookmark((Bookmark) conferences.get(0));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (conferences.size() == 1) {\n\t\t\t\t\topenConversationsForBookmark((Bookmark) conferences.get(0));\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (conferences.size() == 0 && contacts.size() == 1) {\n\t\t\t\t\topenConversationForContact((Contact) contacts.get(0));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSoftKeyboardUtils.hideSoftKeyboard(StartConversationActivity.this);\n\t\t\tmListPagerAdapter.requestFocus(pos);\n\t\t\treturn true;\n\t\t}\n\t};\n\tprivate ViewPager.SimpleOnPageChangeListener mOnPageChangeListener = new ViewPager.SimpleOnPageChangeListener() {\n\t\t@Override\n\t\tpublic void onPageSelected(int position) {\n\t\t\tonTabChanged();\n\t\t}\n\t};\n\n\tpublic static void populateAccountSpinner(Context context, List<String> accounts, Spinner spinner) {\n\t\tif (accounts.size() > 0) {\n\t\t\tArrayAdapter<String> adapter = new ArrayAdapter<>(context, R.layout.simple_list_item, accounts);\n\t\t\tadapter.setDropDownViewResource(R.layout.simple_list_item);\n\t\t\tspinner.setAdapter(adapter);\n\t\t\tspinner.setEnabled(true);\n\t\t} else {\n\t\t\tArrayAdapter<String> adapter = new ArrayAdapter<>(context,\n\t\t\t\t\tR.layout.simple_list_item,\n\t\t\t\t\tArrays.asList(context.getString(R.string.no_accounts)));\n\t\t\tadapter.setDropDownViewResource(R.layout.simple_list_item);\n\t\t\tspinner.setAdapter(adapter);\n\t\t\tspinner.setEnabled(false);\n\t\t}\n\t}\n\n\tpublic static void launch(Context context) {\n\t\tfinal Intent intent = new Intent(context, StartConversationActivity.class);\n\t\tcontext.startActivity(intent);\n\t}\n\n\tprivate static Intent createLauncherIntent(Context context) {\n\t\tfinal Intent intent = new Intent(context, StartConversationActivity.class);\n\t\tintent.setAction(Intent.ACTION_MAIN);\n\t\tintent.addCategory(Intent.CATEGORY_LAUNCHER);\n\t\treturn intent;\n\t}\n\n\tprivate static boolean isViewIntent(final Intent i) {\n\t\treturn i != null && (Intent.ACTION_VIEW.equals(i.getAction()) || Intent.ACTION_SENDTO.equals(i.getAction()) || i.hasExtra(WelcomeActivity.EXTRA_INVITE_URI));\n\t}\n\n\tprotected void hideToast() {\n\t\tif (mToast != null) {\n\t\t\tmToast.cancel();\n\t\t}\n\t}\n\n\tprotected void replaceToast(String msg) {\n\t\thideToast();\n\t\tmToast = Toast.makeText(this, msg, Toast.LENGTH_LONG);\n\t\tmToast.show();\n\t}\n\n\t@Override\n\tpublic void onRosterUpdate() {\n\t\tthis.refreshUi();\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tnew EmojiService(this).init();\n\t\tthis.binding = DataBindingUtil.setContentView(this, R.layout.activity_start_conversation);\n\t\tToolbar toolbar = (Toolbar) binding.toolbar;\n\t\tsetSupportActionBar(toolbar);\n\t\tconfigureActionBar(getSupportActionBar());\n\t\tthis.binding.fab.setOnClickListener((v) -> {\n\t\t\tif (binding.startConversationViewPager.getCurrentItem() == 0) {\n\t\t\t\tString searchString = mSearchEditText != null ? mSearchEditText.getText().toString() : null;\n\t\t\t\tif (searchString != null && !searchString.trim().isEmpty()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tJid jid = Jid.of(searchString);\n\t\t\t\t\t\tif (jid.getLocal() != null && jid.isBareJid() && jid.getDomain().contains(\".\")) {\n\t\t\t\t\t\t\tshowCreateContactDialog(jid.toString(), null);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IllegalArgumentException ignored) {\n\t\t\t\t\t\t//ignore and fall through\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshowCreateContactDialog(null, null);\n\t\t\t} else {\n\t\t\t\tshowCreateConferenceDialog();\n\t\t\t}\n\t\t});\n\t\tbinding.tabLayout.setupWithViewPager(binding.startConversationViewPager);\n\t\tbinding.startConversationViewPager.addOnPageChangeListener(mOnPageChangeListener);\n\t\tmListPagerAdapter = new ListPagerAdapter(getSupportFragmentManager());\n\t\tbinding.startConversationViewPager.setAdapter(mListPagerAdapter);\n\n\t\tmConferenceAdapter = new ListItemAdapter(this, conferences);\n\t\tmContactsAdapter = new ListItemAdapter(this, contacts);\n\t\tmContactsAdapter.setOnTagClickedListener(this.mOnTagClickedListener);\n\n\t\tfinal SharedPreferences preferences = getPreferences();\n\n\t\tthis.mHideOfflineContacts = preferences.getBoolean(\"hide_offline\", false);\n\n\t\tfinal boolean startSearching = preferences.getBoolean(\"start_searching\",getResources().getBoolean(R.bool.start_searching));\n\n\t\tfinal Intent intent;\n\t\tif (savedInstanceState == null) {\n\t\t\tintent = getIntent();\n\t\t} else {\n\t\t\tfinal String search = savedInstanceState.getString(\"search\");\n\t\t\tif (search != null) {\n\t\t\t\tmInitialSearchValue.push(search);\n\t\t\t}\n\t\t\tintent = savedInstanceState.getParcelable(\"intent\");\n\t\t}\n\n\t\tif (isViewIntent(intent)) {\n\t\t\tpendingViewIntent.push(intent);\n\t\t\tsetIntent(createLauncherIntent(this));\n\t\t} else if (startSearching && mInitialSearchValue.peek() == null) {\n\t\t\tmInitialSearchValue.push(\"\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\tIntent pendingIntent = pendingViewIntent.peek();\n\t\tsavedInstanceState.putParcelable(\"intent\", pendingIntent != null ? pendingIntent : getIntent());\n\t\tif (mMenuSearchView != null && mMenuSearchView.isActionViewExpanded()) {\n\t\t\tsavedInstanceState.putString(\"search\", mSearchEditText != null ? mSearchEditText.getText().toString() : null);\n\t\t}\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\t\tfinal int theme = findTheme();\n\t\tif (this.mTheme != theme) {\n\t\t\trecreate();\n\t\t} else {\n\t\t\tif (pendingViewIntent.peek() == null) {\n\t\t\t\taskForContactsPermissions();\n\t\t\t}\n\t\t}\n\t\tmConferenceAdapter.refreshSettings();\n\t\tmContactsAdapter.refreshSettings();\n\t}\n\n\t@Override\n\tpublic void onNewIntent(final Intent intent) {\n\t\tif (xmppConnectionServiceBound) {\n\t\t\tprocessViewIntent(intent);\n\t\t} else {\n\t\t\tpendingViewIntent.push(intent);\n\t\t}\n\t\tsetIntent(createLauncherIntent(this));\n\t}\n\n\tprotected void openConversationForContact(int position) {\n\t\tContact contact = (Contact) contacts.get(position);\n\t\topenConversationForContact(contact);\n\t}\n\n\tprotected void openConversationForContact(Contact contact) {\n\t\tConversation conversation = xmppConnectionService.findOrCreateConversation(contact.getAccount(), contact.getJid(), false, true);\n\t\tSoftKeyboardUtils.hideSoftKeyboard(this);\n\t\tswitchToConversation(conversation);\n\t}\n\n\tprotected void openConversationForBookmark() {\n\t\topenConversationForBookmark(conference_context_id);\n\t}\n\n\tprotected void openConversationForBookmark(int position) {\n\t\tBookmark bookmark = (Bookmark) conferences.get(position);\n\t\topenConversationsForBookmark(bookmark);\n\t}\n\n\tprotected void shareBookmarkUri() {\n\t\tshareBookmarkUri(conference_context_id);\n\t}\n\n\tprotected void shareBookmarkUri(int position) {\n\t\tBookmark bookmark = (Bookmark) conferences.get(position);\n\t\tIntent shareIntent = new Intent();\n\t\tshareIntent.setAction(Intent.ACTION_SEND);\n\t\tshareIntent.putExtra(Intent.EXTRA_TEXT, \"xmpp:\" + bookmark.getJid().asBareJid().toEscapedString() + \"?join\");\n\t\tshareIntent.setType(\"text/plain\");\n\t\ttry {\n\t\t\tstartActivity(Intent.createChooser(shareIntent, getText(R.string.share_uri_with)));\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\tToast.makeText(this, R.string.no_application_to_share_uri, Toast.LENGTH_SHORT).show();\n\t\t}\n\t}\n\n\tprotected void openConversationsForBookmark(Bookmark bookmark) {\n\t\tJid jid = bookmark.getJid();\n\t\tif (jid == null) {\n\t\t\tToast.makeText(this, R.string.invalid_jid, Toast.LENGTH_SHORT).show();\n\t\t\treturn;\n\t\t}\n\t\tConversation conversation = xmppConnectionService.findOrCreateConversation(bookmark.getAccount(), jid, true, true, true);\n\t\tbookmark.setConversation(conversation);\n\t\tif (!bookmark.autojoin() && getPreferences().getBoolean(\"autojoin\", getResources().getBoolean(R.bool.autojoin))) {\n\t\t\tbookmark.setAutojoin(true);\n\t\t\txmppConnectionService.pushBookmarks(bookmark.getAccount());\n\t\t}\n\t\tSoftKeyboardUtils.hideSoftKeyboard(this);\n\t\tswitchToConversation(conversation);\n\t}\n\n\tprotected void openDetailsForContact() {\n\t\tint position = contact_context_id;\n\t\tContact contact = (Contact) contacts.get(position);\n\t\tswitchToContactDetails(contact);\n\t}\n\n\tprotected void showQrForContact() {\n\t\tint position = contact_context_id;\n\t\tContact contact = (Contact) contacts.get(position);\n\t\tshowQrCode(\"xmpp:\"+contact.getJid().asBareJid().toEscapedString());\n\t}\n\n\tprotected void toggleContactBlock() {\n\t\tfinal int position = contact_context_id;\n\t\tBlockContactDialog.show(this, (Contact) contacts.get(position));\n\t}\n\n\tprotected void deleteContact() {\n\t\tfinal int position = contact_context_id;\n\t\tfinal Contact contact = (Contact) contacts.get(position);\n\t\tfinal AlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setNegativeButton(R.string.cancel, null);\n\t\tbuilder.setTitle(R.string.action_delete_contact);\n\t\tbuilder.setMessage(JidDialog.style(this, R.string.remove_contact_text, contact.getJid().toEscapedString()));\n\t\tbuilder.setPositiveButton(R.string.delete, (dialog, which) -> {\n\t\t\txmppConnectionService.deleteContactOnServer(contact);\n\t\t\tfilter(mSearchEditText.getText().toString());\n\t\t});\n\t\tbuilder.create().show();\n\t}\n\n\tprotected void deleteConference() {\n\t\tint position = conference_context_id;\n\t\tfinal Bookmark bookmark = (Bookmark) conferences.get(position);\n\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setNegativeButton(R.string.cancel, null);\n\t\tbuilder.setTitle(R.string.delete_bookmark);\n\t\tbuilder.setMessage(JidDialog.style(this, R.string.remove_bookmark_text, bookmark.getJid().toEscapedString()));\n\t\tbuilder.setPositiveButton(R.string.delete, (dialog, which) -> {\n\t\t\tbookmark.setConversation(null);\n\t\t\tAccount account = bookmark.getAccount();\n\t\t\taccount.getBookmarks().remove(bookmark);\n\t\t\txmppConnectionService.pushBookmarks(account);\n\t\t\tfilter(mSearchEditText.getText().toString());\n\t\t});\n\t\tbuilder.create().show();\n\n\t}\n\n\t@SuppressLint(\"InflateParams\")\n\tprotected void showCreateContactDialog(final String prefilledJid, final Invite invite) {\n\t\tFragmentTransaction ft = getSupportFragmentManager().beginTransaction();\n\t\tFragment prev = getSupportFragmentManager().findFragmentByTag(FRAGMENT_TAG_DIALOG);\n\t\tif (prev != null) {\n\t\t\tft.remove(prev);\n\t\t}\n\t\tft.addToBackStack(null);\n\t\tEnterJidDialog dialog = EnterJidDialog.newInstance(\n\t\t\t\tmActivatedAccounts,\n\t\t\t\tgetString(R.string.dialog_title_create_contact),\n\t\t\t\tgetString(R.string.create),\n\t\t\t\tprefilledJid,\n\t\t\t\tnull,\n\t\t\t\tinvite == null || !invite.hasFingerprints()\n\t\t);\n\n\t\tdialog.setOnEnterJidDialogPositiveListener((accountJid, contactJid) -> {\n\t\t\tif (!xmppConnectionServiceBound) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfinal Account account = xmppConnectionService.findAccountByJid(accountJid);\n\t\t\tif (account == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfinal Contact contact = account.getRoster().getContact(contactJid);\n\t\t\tif (invite != null && invite.getName() != null) {\n\t\t\t\tcontact.setServerName(invite.getName());\n\t\t\t}\n\t\t\tif (contact.isSelf()) {\n\t\t\t\tswitchToConversation(contact);\n\t\t\t\treturn true;\n\t\t\t} else if (contact.showInRoster()) {\n\t\t\t\tthrow new EnterJidDialog.JidError(getString(R.string.contact_already_exists));\n\t\t\t} else {\n\t\t\t\txmppConnectionService.createContact(contact, true);\n\t\t\t\tif (invite != null && invite.hasFingerprints()) {\n\t\t\t\t\txmppConnectionService.verifyFingerprints(contact, invite.getFingerprints());\n\t\t\t\t}\n\t\t\t\tswitchToConversationDoNotAppend(contact, invite == null ? null : invite.getBody());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tdialog.show(ft, FRAGMENT_TAG_DIALOG);\n\t}\n\n\t@SuppressLint(\"InflateParams\")\n\tprotected void showJoinConferenceDialog(final String prefilledJid) {\n\t\tFragmentTransaction ft = getSupportFragmentManager().beginTransaction();\n\t\tFragment prev = getSupportFragmentManager().findFragmentByTag(FRAGMENT_TAG_DIALOG);\n\t\tif (prev != null) {\n\t\t\tft.remove(prev);\n\t\t}\n\t\tft.addToBackStack(null);\n\t\tJoinConferenceDialog joinConferenceFragment = JoinConferenceDialog.newInstance(prefilledJid, mActivatedAccounts);\n\t\tjoinConferenceFragment.show(ft, FRAGMENT_TAG_DIALOG);\n\t}\n\n\tprivate void showCreateConferenceDialog() {\n\t\tFragmentTransaction ft = getSupportFragmentManager().beginTransaction();\n\t\tFragment prev = getSupportFragmentManager().findFragmentByTag(FRAGMENT_TAG_DIALOG);\n\t\tif (prev != null) {\n\t\t\tft.remove(prev);\n\t\t}\n\t\tft.addToBackStack(null);\n\t\tCreateConferenceDialog createConferenceFragment = CreateConferenceDialog.newInstance(mActivatedAccounts);\n\t\tcreateConferenceFragment.show(ft, FRAGMENT_TAG_DIALOG);\n\t}\n\n\tprivate Account getSelectedAccount(Spinner spinner) {\n\t\tif (!spinner.isEnabled()) {\n\t\t\treturn null;\n\t\t}\n\t\tJid jid;\n\t\ttry {\n\t\t\tif (Config.DOMAIN_LOCK != null) {\n\t\t\t\tjid = Jid.of((String) spinner.getSelectedItem(), Config.DOMAIN_LOCK, null);\n\t\t\t} else {\n\t\t\t\tjid = Jid.of((String) spinner.getSelectedItem());\n\t\t\t}\n\t\t} catch (final IllegalArgumentException e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn xmppConnectionService.findAccountByJid(jid);\n\t}\n\n\tprotected void switchToConversation(Contact contact) {\n\t\tConversation conversation = xmppConnectionService.findOrCreateConversation(contact.getAccount(), contact.getJid(), false, true);\n\t\tswitchToConversation(conversation);\n\t}\n\n\tprotected void switchToConversationDoNotAppend(Contact contact, String body) {\n\t\tConversation conversation = xmppConnectionService.findOrCreateConversation(contact.getAccount(), contact.getJid(), false, true);\n\t\tswitchToConversationDoNotAppend(conversation, body);\n\t}\n\n\t@Override\n\tpublic void invalidateOptionsMenu() {\n\t\tboolean isExpanded = mMenuSearchView != null && mMenuSearchView.isActionViewExpanded();\n\t\tString text = mSearchEditText != null ? mSearchEditText.getText().toString() : \"\";\n\t\tif (isExpanded) {\n\t\t\tmInitialSearchValue.push(text);\n\t\t\toneShotKeyboardSuppress.set(true);\n\t\t}\n\t\tsuper.invalidateOptionsMenu();\n\t}\n\n\tprivate void updateSearchViewHint() {\n\t\tif (binding == null || mSearchEditText == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (binding.startConversationViewPager.getCurrentItem() == 0) {\n\t\t\tmSearchEditText.setHint(R.string.search_contacts);\n\t\t} else {\n\t\t\tmSearchEditText.setHint(R.string.search_groups);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tgetMenuInflater().inflate(R.menu.start_conversation, menu);\n\t\tMenuItem menuHideOffline = menu.findItem(R.id.action_hide_offline);\n\t\tMenuItem joinGroupChat = menu.findItem(R.id.action_join_conference);\n\t\tMenuItem qrCodeScanMenuItem = menu.findItem(R.id.action_scan_qr_code);\n\t\tjoinGroupChat.setVisible(binding.startConversationViewPager.getCurrentItem() == 1);\n\t\tqrCodeScanMenuItem.setVisible(isCameraFeatureAvailable());\n\t\tmenuHideOffline.setChecked(this.mHideOfflineContacts);\n\t\tmMenuSearchView = menu.findItem(R.id.action_search);\n\t\tmMenuSearchView.setOnActionExpandListener(mOnActionExpandListener);\n\t\tView mSearchView = mMenuSearchView.getActionView();\n\t\tmSearchEditText = mSearchView.findViewById(R.id.search_field);\n\t\tmSearchEditText.addTextChangedListener(mSearchTextWatcher);\n\t\tmSearchEditText.setOnEditorActionListener(mSearchDone);\n\t\tString initialSearchValue = mInitialSearchValue.pop();\n\t\tif (initialSearchValue != null) {\n\t\t\tmMenuSearchView.expandActionView();\n\t\t\tmSearchEditText.append(initialSearchValue);\n\t\t\tfilter(initialSearchValue);\n\t\t}\n\t\tupdateSearchViewHint();\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tif (MenuDoubleTabUtil.shouldIgnoreTap()) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (item.getItemId()) {\n\t\t\tcase android.R.id.home:\n\t\t\t\tnavigateBack();\n\t\t\t\treturn true;\n\t\t\tcase R.id.action_join_conference:\n\t\t\t\tshowJoinConferenceDialog(null);\n\t\t\t\treturn true;\n\t\t\tcase R.id.action_scan_qr_code:\n\t\t\t\tUriHandlerActivity.scan(this);\n\t\t\t\treturn true;\n\t\t\tcase R.id.action_hide_offline:\n\t\t\t\tmHideOfflineContacts = !item.isChecked();\n\t\t\t\tgetPreferences().edit().putBoolean(\"hide_offline\", mHideOfflineContacts).commit();\n\t\t\t\tif (mSearchEditText != null) {\n\t\t\t\t\tfilter(mSearchEditText.getText().toString());\n\t\t\t\t}\n\t\t\t\tinvalidateOptionsMenu();\n\t\t}\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\t@Override\n\tpublic boolean onKeyUp(int keyCode, KeyEvent event) {\n\t\tif (keyCode == KeyEvent.KEYCODE_SEARCH && !event.isLongPress()) {\n\t\t\topenSearch();\n\t\t\treturn true;\n\t\t}\n\t\tint c = event.getUnicodeChar();\n\t\tif (c > 32) {\n\t\t\tif (mSearchEditText != null && !mSearchEditText.isFocused()) {\n\t\t\t\topenSearch();\n\t\t\t\tmSearchEditText.append(Character.toString((char) c));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn super.onKeyUp(keyCode, event);\n\t}\n\n\tprivate void openSearch() {\n\t\tif (mMenuSearchView != null) {\n\t\t\tmMenuSearchView.expandActionView();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onActivityResult(int requestCode, int resultCode, Intent intent) {\n\t\tif (resultCode == RESULT_OK) {\n\t\t\tif (xmppConnectionServiceBound) {\n\t\t\t\tthis.mPostponedActivityResult = null;\n\t\t\t\tif (requestCode == REQUEST_CREATE_CONFERENCE) {\n\t\t\t\t\tAccount account = extractAccount(intent);\n\t\t\t\t\tfinal String name = intent.getStringExtra(ChooseContactActivity.EXTRA_GROUP_CHAT_NAME);\n\t\t\t\t\tfinal List<Jid> jids = ChooseContactActivity.extractJabberIds(intent);\n\t\t\t\t\tif (account != null && jids.size() > 0) {\n\t\t\t\t\t\tif (xmppConnectionService.createAdhocConference(account, name, jids, mAdhocConferenceCallback)) {\n\t\t\t\t\t\t\tmToast = Toast.makeText(this, R.string.creating_conference, Toast.LENGTH_LONG);\n\t\t\t\t\t\t\tmToast.show();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.mPostponedActivityResult = new Pair<>(requestCode, intent);\n\t\t\t}\n\t\t}\n\t\tsuper.onActivityResult(requestCode, requestCode, intent);\n\t}\n\n\tprivate void askForContactsPermissions() {\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n\t\t\tif (checkSelfPermission(Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {\n\t\t\t\tif (mRequestedContactsPermission.compareAndSet(false, true)) {\n\t\t\t\t\tif (shouldShowRequestPermissionRationale(Manifest.permission.READ_CONTACTS)) {\n\t\t\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\t\t\tbuilder.setTitle(R.string.sync_with_contacts);\n\t\t\t\t\t\tbuilder.setMessage(R.string.sync_with_contacts_long);\n\t\t\t\t\t\tbuilder.setPositiveButton(R.string.next, (dialog, which) -> requestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, REQUEST_SYNC_CONTACTS));\n\t\t\t\t\t\tbuilder.setOnDismissListener(dialog -> requestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, REQUEST_SYNC_CONTACTS));\n\t\t\t\t\t\tbuilder.create().show();\n\t\t\t\t\t} else {\n\t\t\t\t\t\trequestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, REQUEST_SYNC_CONTACTS);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onRequestPermissionsResult(int requestCode, @NonNull String permissions[], @NonNull int[] grantResults) {\n\t\tif (grantResults.length > 0)\n\t\t\tif (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n\t\t\t\tScanActivity.onRequestPermissionResult(this, requestCode, grantResults);\n\t\t\t\tif (requestCode == REQUEST_SYNC_CONTACTS && xmppConnectionServiceBound) {\n\t\t\t\t\txmppConnectionService.loadPhoneContacts();\n\t\t\t\t\txmppConnectionService.startContactObserver();\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tprivate void configureHomeButton() {\n\t\tfinal ActionBar actionBar = getSupportActionBar();\n\t\tif (actionBar == null) {\n\t\t\treturn;\n\t\t}\n\t\tboolean openConversations = !xmppConnectionService.isConversationsListEmpty(null);\n\t\tactionBar.setDisplayHomeAsUpEnabled(openConversations);\n\t\tactionBar.setDisplayHomeAsUpEnabled(openConversations);\n\n\t}\n\n\t@Override\n\tprotected void onBackendConnected() {\n\t\tif (mPostponedActivityResult != null) {\n\t\t\tonActivityResult(mPostponedActivityResult.first, RESULT_OK, mPostponedActivityResult.second);\n\t\t\tthis.mPostponedActivityResult = null;\n\t\t}\n\t\tthis.mActivatedAccounts.clear();\n\t\tfor (Account account : xmppConnectionService.getAccounts()) {\n\t\t\tif (account.getStatus() != Account.State.DISABLED) {\n\t\t\t\tif (Config.DOMAIN_LOCK != null) {\n\t\t\t\t\tthis.mActivatedAccounts.add(account.getJid().getLocal());\n\t\t\t\t} else {\n\t\t\t\t\tthis.mActivatedAccounts.add(account.getJid().asBareJid().toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconfigureHomeButton();\n\t\tIntent intent = pendingViewIntent.pop();\n\t\tif (intent != null && processViewIntent(intent)) {\n\t\t\tfilter(null);\n\t\t} else {\n\t\t\tif (mSearchEditText != null) {\n\t\t\t\tfilter(mSearchEditText.getText().toString());\n\t\t\t} else {\n\t\t\t\tfilter(null);\n\t\t\t}\n\t\t}\n\t\tFragment fragment = getSupportFragmentManager().findFragmentByTag(FRAGMENT_TAG_DIALOG);\n\t\tif (fragment != null && fragment instanceof OnBackendConnected) {\n\t\t\tLog.d(Config.LOGTAG, \"calling on backend connected on dialog\");\n\t\t\t((OnBackendConnected) fragment).onBackendConnected();\n\t\t}\n\t}\n\n\tprotected boolean processViewIntent(@NonNull Intent intent) {\n\t\tfinal String inviteUri = intent.getStringExtra(WelcomeActivity.EXTRA_INVITE_URI);\n\t\tif (inviteUri != null) {\n\t\t\tInvite invite = new Invite(inviteUri);\n\t\t\tif (invite.isJidValid()) {\n\t\t\t\treturn invite.invite();\n\t\t\t}\n\t\t}\n\t\tfinal String action = intent.getAction();\n\t\tif (action == null) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (action) {\n\t\t\tcase Intent.ACTION_SENDTO:\n\t\t\tcase Intent.ACTION_VIEW:\n\t\t\t\tUri uri = intent.getData();\n\t\t\t\tif (uri != null) {\n\t\t\t\t\tInvite invite = new Invite(intent.getData(), intent.getBooleanExtra(\"scanned\", false));\n\t\t\t\t\tinvite.account = intent.getStringExtra(\"account\");\n\t\t\t\t\treturn invite.invite();\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean handleJid(Invite invite) {\n\t\tList<Contact> contacts = xmppConnectionService.findContacts(invite.getJid(), invite.account);\n\t\tif (invite.isAction(XmppUri.ACTION_JOIN)) {\n\t\t\tConversation muc = xmppConnectionService.findFirstMuc(invite.getJid());\n\t\t\tif (muc != null) {\n\t\t\t\tswitchToConversationDoNotAppend(muc, invite.getBody());\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tshowJoinConferenceDialog(invite.getJid().asBareJid().toString());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (contacts.size() == 0) {\n\t\t\tshowCreateContactDialog(invite.getJid().toString(), invite);\n\t\t\treturn false;\n\t\t} else if (contacts.size() == 1) {\n\t\t\tContact contact = contacts.get(0);\n\t\t\tif (!invite.isSafeSource() && invite.hasFingerprints()) {\n\t\t\t\tdisplayVerificationWarningDialog(contact, invite);\n\t\t\t} else {\n\t\t\t\tif (invite.hasFingerprints()) {\n\t\t\t\t\tif (xmppConnectionService.verifyFingerprints(contact, invite.getFingerprints())) {\n\t\t\t\t\t\tToast.makeText(this, R.string.verified_fingerprints, Toast.LENGTH_SHORT).show();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (invite.account != null) {\n\t\t\t\t\txmppConnectionService.getShortcutService().report(contact);\n\t\t\t\t}\n\t\t\t\tswitchToConversationDoNotAppend(contact, invite.getBody());\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif (mMenuSearchView != null) {\n\t\t\t\tmMenuSearchView.expandActionView();\n\t\t\t\tmSearchEditText.setText(\"\");\n\t\t\t\tmSearchEditText.append(invite.getJid().toString());\n\t\t\t\tfilter(invite.getJid().toString());\n\t\t\t} else {\n\t\t\t\tmInitialSearchValue.push(invite.getJid().toString());\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate void displayVerificationWarningDialog(final Contact contact, final Invite invite) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(R.string.verify_omemo_keys);\n\t\tView view = getLayoutInflater().inflate(R.layout.dialog_verify_fingerprints, null);\n\t\tfinal CheckBox isTrustedSource = view.findViewById(R.id.trusted_source);\n\t\tTextView warning = view.findViewById(R.id.warning);\n\t\twarning.setText(JidDialog.style(this, R.string.verifying_omemo_keys_trusted_source, contact.getJid().asBareJid().toEscapedString(), contact.getDisplayName()));\n\t\tbuilder.setView(view);\n\t\tbuilder.setPositiveButton(R.string.confirm, (dialog, which) -> {\n\t\t\tif (isTrustedSource.isChecked() && invite.hasFingerprints()) {\n\t\t\t\txmppConnectionService.verifyFingerprints(contact, invite.getFingerprints());\n\t\t\t}\n\t\t\tswitchToConversationDoNotAppend(contact, invite.getBody());\n\t\t});\n\t\tbuilder.setNegativeButton(R.string.cancel, (dialog, which) -> StartConversationActivity.this.finish());\n\t\tAlertDialog dialog = builder.create();\n\t\tdialog.setCanceledOnTouchOutside(false);\n\t\tdialog.setOnCancelListener(dialog1 -> StartConversationActivity.this.finish());\n\t\tdialog.show();\n\t}\n\n\tprotected void filter(String needle) {\n\t\tif (xmppConnectionServiceBound) {\n\t\t\tthis.filterContacts(needle);\n\t\t\tthis.filterConferences(needle);\n\t\t}\n\t}\n\n\tprotected void filterContacts(String needle) {\n\t\tthis.contacts.clear();\n\t\tfinal List<Account> accounts = xmppConnectionService.getAccounts();\n\t\tfinal boolean singleAccountActive = isSingleAccountActive(accounts);\n\t\tfor (Account account : accounts) {\n\t\t\tif (account.getStatus() != Account.State.DISABLED) {\n\t\t\t\tfor (Contact contact : account.getRoster().getContacts()) {\n\t\t\t\t\tPresence.Status s = contact.getShownStatus();\n\t\t\t\t\tif ((contact.showInRoster() || (singleAccountActive && contact.showInPhoneBook())) && contact.match(this, needle)\n\t\t\t\t\t\t\t&& (!this.mHideOfflineContacts\n\t\t\t\t\t\t\t|| (needle != null && !needle.trim().isEmpty())\n\t\t\t\t\t\t\t|| s.compareTo(Presence.Status.OFFLINE) < 0)) {\n\t\t\t\t\t\tthis.contacts.add(contact);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(this.contacts);\n\t\tmContactsAdapter.notifyDataSetChanged();\n\t}\n\n\tprivate static boolean isSingleAccountActive(final List<Account> accounts) {\n\t\tint i = 0;\n\t\tfor(Account account : accounts) {\n\t\t\tif (account.getStatus() != Account.State.DISABLED) {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\treturn i == 1;\n\t}\n\n\tprotected void filterConferences(String needle) {\n\t\tthis.conferences.clear();\n\t\tfor (Account account : xmppConnectionService.getAccounts()) {\n\t\t\tif (account.getStatus() != Account.State.DISABLED) {\n\t\t\t\tfor (Bookmark bookmark : account.getBookmarks()) {\n\t\t\t\t\tif (bookmark.match(this, needle)) {\n\t\t\t\t\t\tthis.conferences.add(bookmark);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(this.conferences);\n\t\tmConferenceAdapter.notifyDataSetChanged();\n\t}\n\n\tprivate void onTabChanged() {\n\t\t@DrawableRes final int fabDrawable;\n\t\tif (binding.startConversationViewPager.getCurrentItem() == 0) {\n\t\t\tfabDrawable = R.drawable.ic_person_add_white_24dp;\n\t\t} else {\n\t\t\tfabDrawable = R.drawable.ic_group_add_white_24dp;\n\t\t}\n\t\tbinding.fab.setImageResource(fabDrawable);\n\t\tinvalidateOptionsMenu();\n\t}\n\n\t@Override\n\tpublic void OnUpdateBlocklist(final Status status) {\n\t\trefreshUi();\n\t}\n\n\t@Override\n\tprotected void refreshUiReal() {\n\t\tif (mSearchEditText != null) {\n\t\t\tfilter(mSearchEditText.getText().toString());\n\t\t}\n\t\tconfigureHomeButton();\n\t}\n\n\t@Override\n\tpublic void onBackPressed() {\n\t\tnavigateBack();\n\t}\n\n\tprivate void navigateBack() {\n\t\tif (xmppConnectionService != null && !xmppConnectionService.isConversationsListEmpty(null)) {\n\t\t\tIntent intent = new Intent(this, ConversationsActivity.class);\n\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\n\t\t\tstartActivity(intent);\n\t\t}\n\t\tfinish();\n\t}\n\n\t@Override\n\tpublic void onCreateDialogPositiveClick(Spinner spinner, String name) {\n\t\tif (!xmppConnectionServiceBound) {\n\t\t\treturn;\n\t\t}\n\t\tfinal Account account = getSelectedAccount(spinner);\n\t\tif (account == null) {\n\t\t\treturn;\n\t\t}\n\t\tIntent intent = new Intent(getApplicationContext(), ChooseContactActivity.class);\n\t\tintent.putExtra(ChooseContactActivity.EXTRA_SHOW_ENTER_JID, false);\n\t\tintent.putExtra(ChooseContactActivity.EXTRA_SELECT_MULTIPLE, true);\n\t\tintent.putExtra(ChooseContactActivity.EXTRA_GROUP_CHAT_NAME, name.trim());\n\t\tintent.putExtra(ChooseContactActivity.EXTRA_ACCOUNT, account.getJid().asBareJid().toString());\n\t\tintent.putExtra(ChooseContactActivity.EXTRA_TITLE_RES_ID, R.string.choose_participants);\n\t\tstartActivityForResult(intent, REQUEST_CREATE_CONFERENCE);\n\t}\n\n\t@Override\n\tpublic void onJoinDialogPositiveClick(Dialog dialog, Spinner spinner, AutoCompleteTextView jid, boolean isBookmarkChecked) {\n\t\tif (!xmppConnectionServiceBound) {\n\t\t\treturn;\n\t\t}\n\t\tfinal Account account = getSelectedAccount(spinner);\n\t\tif (account == null) {\n\t\t\treturn;\n\t\t}\n\t\tfinal Jid conferenceJid;\n\t\ttry {\n\t\t\tconferenceJid = Jid.of(jid.getText().toString());\n\t\t} catch (final IllegalArgumentException e) {\n\t\t\tjid.setError(getString(R.string.invalid_jid));\n\t\t\treturn;\n\t\t}\n\n\t\tif (isBookmarkChecked) {\n\t\t\tif (account.hasBookmarkFor(conferenceJid)) {\n\t\t\t\tjid.setError(getString(R.string.bookmark_already_exists));\n\t\t\t} else {\n\t\t\t\tfinal Bookmark bookmark = new Bookmark(account, conferenceJid.asBareJid());\n\t\t\t\tbookmark.setAutojoin(getBooleanPreference(\"autojoin\", R.bool.autojoin));\n\t\t\t\tString nick = conferenceJid.getResource();\n\t\t\t\tif (nick != null && !nick.isEmpty()) {\n\t\t\t\t\tbookmark.setNick(nick);\n\t\t\t\t}\n\t\t\t\taccount.getBookmarks().add(bookmark);\n\t\t\t\txmppConnectionService.pushBookmarks(account);\n\t\t\t\tfinal Conversation conversation = xmppConnectionService\n\t\t\t\t\t\t.findOrCreateConversation(account, conferenceJid, true, true, true);\n\t\t\t\tbookmark.setConversation(conversation);\n\t\t\t\tdialog.dismiss();\n\t\t\t\tswitchToConversation(conversation);\n\t\t\t}\n\t\t} else {\n\t\t\tfinal Conversation conversation = xmppConnectionService\n\t\t\t\t\t.findOrCreateConversation(account, conferenceJid, true, true, true);\n\t\t\tdialog.dismiss();\n\t\t\tswitchToConversation(conversation);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onConversationUpdate() {\n\t\trefreshUi();\n\t}\n\n\tpublic static class MyListFragment extends ListFragment {\n\t\tprivate AdapterView.OnItemClickListener mOnItemClickListener;\n\t\tprivate int mResContextMenu;\n\n\t\tpublic void setContextMenu(final int res) {\n\t\t\tthis.mResContextMenu = res;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onListItemClick(final ListView l, final View v, final int position, final long id) {\n\t\t\tif (mOnItemClickListener != null) {\n\t\t\t\tmOnItemClickListener.onItemClick(l, v, position, id);\n\t\t\t}\n\t\t}\n\n\t\tpublic void setOnListItemClickListener(AdapterView.OnItemClickListener l) {\n\t\t\tthis.mOnItemClickListener = l;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onViewCreated(@NonNull final View view, final Bundle savedInstanceState) {\n\t\t\tsuper.onViewCreated(view, savedInstanceState);\n\t\t\tregisterForContextMenu(getListView());\n\t\t\tgetListView().setFastScrollEnabled(true);\n\t\t\tgetListView().setDivider(null);\n\t\t\tgetListView().setDividerHeight(0);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreateContextMenu(final ContextMenu menu, final View v, final ContextMenuInfo menuInfo) {\n\t\t\tsuper.onCreateContextMenu(menu, v, menuInfo);\n\t\t\tfinal StartConversationActivity activity = (StartConversationActivity) getActivity();\n\t\t\tif (activity == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tactivity.getMenuInflater().inflate(mResContextMenu, menu);\n\t\t\tfinal AdapterView.AdapterContextMenuInfo acmi = (AdapterContextMenuInfo) menuInfo;\n\t\t\tif (mResContextMenu == R.menu.conference_context) {\n\t\t\t\tactivity.conference_context_id = acmi.position;\n\t\t\t} else if (mResContextMenu == R.menu.contact_context) {\n\t\t\t\tactivity.contact_context_id = acmi.position;\n\t\t\t\tfinal Contact contact = (Contact) activity.contacts.get(acmi.position);\n\t\t\t\tfinal MenuItem blockUnblockItem = menu.findItem(R.id.context_contact_block_unblock);\n\t\t\t\tfinal MenuItem showContactDetailsItem = menu.findItem(R.id.context_contact_details);\n\t\t\t\tfinal MenuItem deleteContactMenuItem = menu.findItem(R.id.context_delete_contact);\n\t\t\t\tif (contact.isSelf()) {\n\t\t\t\t\tshowContactDetailsItem.setVisible(false);\n\t\t\t\t}\n\t\t\t\tdeleteContactMenuItem.setVisible(contact.showInRoster());\n\t\t\t\tXmppConnection xmpp = contact.getAccount().getXmppConnection();\n\t\t\t\tif (xmpp != null && xmpp.getFeatures().blocking() && !contact.isSelf()) {\n\t\t\t\t\tif (contact.isBlocked()) {\n\t\t\t\t\t\tblockUnblockItem.setTitle(R.string.unblock_contact);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tblockUnblockItem.setTitle(R.string.block_contact);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tblockUnblockItem.setVisible(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onContextItemSelected(final MenuItem item) {\n\t\t\tStartConversationActivity activity = (StartConversationActivity) getActivity();\n\t\t\tif (activity == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tswitch (item.getItemId()) {\n\t\t\t\tcase R.id.context_contact_details:\n\t\t\t\t\tactivity.openDetailsForContact();\n\t\t\t\t\tbreak;\n\t\t\t\tcase R.id.context_show_qr:\n\t\t\t\t\tactivity.showQrForContact();\n\t\t\t\t\tbreak;\n\t\t\t\tcase R.id.context_contact_block_unblock:\n\t\t\t\t\tactivity.toggleContactBlock();\n\t\t\t\t\tbreak;\n\t\t\t\tcase R.id.context_delete_contact:\n\t\t\t\t\tactivity.deleteContact();\n\t\t\t\t\tbreak;\n\t\t\t\tcase R.id.context_join_conference:\n\t\t\t\t\tactivity.openConversationForBookmark();\n\t\t\t\t\tbreak;\n\t\t\t\tcase R.id.context_share_uri:\n\t\t\t\t\tactivity.shareBookmarkUri();\n\t\t\t\t\tbreak;\n\t\t\t\tcase R.id.context_delete_conference:\n\t\t\t\t\tactivity.deleteConference();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic class ListPagerAdapter extends PagerAdapter {\n\t\tFragmentManager fragmentManager;\n\t\tMyListFragment[] fragments;\n\n\t\tpublic ListPagerAdapter(FragmentManager fm) {\n\t\t\tfragmentManager = fm;\n\t\t\tfragments = new MyListFragment[2];\n\t\t}\n\n\t\tpublic void requestFocus(int pos) {\n\t\t\tif (fragments.length > pos) {\n\t\t\t\tfragments[pos].getListView().requestFocus();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) {\n\t\t\tFragmentTransaction trans = fragmentManager.beginTransaction();\n\t\t\ttrans.remove(fragments[position]);\n\t\t\ttrans.commit();\n\t\t\tfragments[position] = null;\n\t\t}\n\n\t\t@NonNull\n\t\t@Override\n\t\tpublic Fragment instantiateItem(@NonNull ViewGroup container, int position) {\n\t\t\tFragment fragment = getItem(position);\n\t\t\tFragmentTransaction trans = fragmentManager.beginTransaction();\n\t\t\ttrans.add(container.getId(), fragment, \"fragment:\" + position);\n\t\t\ttrans.commit();\n\t\t\treturn fragment;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getCount() {\n\t\t\treturn fragments.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isViewFromObject(@NonNull View view, @NonNull Object fragment) {\n\t\t\treturn ((Fragment) fragment).getView() == view;\n\t\t}\n\n\t\t@Nullable\n\t\t@Override\n\t\tpublic CharSequence getPageTitle(int position) {\n\t\t\tswitch (position) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn getResources().getString(R.string.contacts);\n\t\t\t\tcase 1:\n\t\t\t\t\treturn getResources().getString(R.string.conferences);\n\t\t\t\tdefault:\n\t\t\t\t\treturn super.getPageTitle(position);\n\t\t\t}\n\t\t}\n\n\t\tFragment getItem(int position) {\n\t\t\tif (fragments[position] == null) {\n\t\t\t\tfinal MyListFragment listFragment = new MyListFragment();\n\t\t\t\tif (position == 1) {\n\t\t\t\t\tlistFragment.setListAdapter(mConferenceAdapter);\n\t\t\t\t\tlistFragment.setContextMenu(R.menu.conference_context);\n\t\t\t\t\tlistFragment.setOnListItemClickListener((arg0, arg1, p, arg3) -> openConversationForBookmark(p));\n\t\t\t\t} else {\n\n\t\t\t\t\tlistFragment.setListAdapter(mContactsAdapter);\n\t\t\t\t\tlistFragment.setContextMenu(R.menu.contact_context);\n\t\t\t\t\tlistFragment.setOnListItemClickListener((arg0, arg1, p, arg3) -> openConversationForContact(p));\n\t\t\t\t}\n\t\t\t\tfragments[position] = listFragment;\n\t\t\t}\n\t\t\treturn fragments[position];\n\t\t}\n\t}\n\n\tprivate class Invite extends XmppUri {\n\n\t\tpublic String account;\n\n\t\tpublic Invite(final Uri uri) {\n\t\t\tsuper(uri);\n\t\t}\n\n\t\tpublic Invite(final String uri) {\n\t\t\tsuper(uri);\n\t\t}\n\n\t\tpublic Invite(Uri uri, boolean safeSource) {\n\t\t\tsuper(uri, safeSource);\n\t\t}\n\n\t\tboolean invite() {\n\t\t\tif (!isJidValid()) {\n\t\t\t\tToast.makeText(StartConversationActivity.this, R.string.invalid_jid, Toast.LENGTH_SHORT).show();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (getJid() != null) {\n\t\t\t\treturn handleJid(this);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}\n", "package eu.siacs.conversations.ui;\n\nimport android.Manifest;\nimport android.annotation.SuppressLint;\nimport android.annotation.TargetApi;\nimport android.app.PendingIntent;\nimport android.content.ActivityNotFoundException;\nimport android.content.ClipData;\nimport android.content.ClipboardManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentSender.SendIntentException;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.databinding.DataBindingUtil;\nimport android.graphics.Bitmap;\nimport android.graphics.Color;\nimport android.graphics.Point;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.net.ConnectivityManager;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.PowerManager;\nimport android.os.SystemClock;\nimport android.preference.PreferenceManager;\nimport android.support.annotation.BoolRes;\nimport android.support.annotation.StringRes;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AlertDialog;\nimport android.support.v7.app.AlertDialog.Builder;\nimport android.support.v7.app.AppCompatDelegate;\nimport android.text.InputType;\nimport android.util.DisplayMetrics;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.EditText;\nimport android.widget.ImageView;\nimport android.widget.Toast;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport eu.siacs.conversations.Config;\nimport eu.siacs.conversations.R;\nimport eu.siacs.conversations.crypto.PgpEngine;\nimport eu.siacs.conversations.databinding.DialogQuickeditBinding;\nimport eu.siacs.conversations.entities.Account;\nimport eu.siacs.conversations.entities.Contact;\nimport eu.siacs.conversations.entities.Conversation;\nimport eu.siacs.conversations.entities.Message;\nimport eu.siacs.conversations.entities.Presences;\nimport eu.siacs.conversations.services.AvatarService;\nimport eu.siacs.conversations.services.BarcodeProvider;\nimport eu.siacs.conversations.services.XmppConnectionService;\nimport eu.siacs.conversations.services.XmppConnectionService.XmppConnectionBinder;\nimport eu.siacs.conversations.ui.util.MenuDoubleTabUtil;\nimport eu.siacs.conversations.ui.util.PresenceSelector;\nimport eu.siacs.conversations.ui.util.SoftKeyboardUtils;\nimport eu.siacs.conversations.utils.ExceptionHelper;\nimport eu.siacs.conversations.utils.ThemeHelper;\nimport eu.siacs.conversations.xmpp.OnKeyStatusUpdated;\nimport eu.siacs.conversations.xmpp.OnUpdateBlocklist;\nimport rocks.xmpp.addr.Jid;\n\npublic abstract class XmppActivity extends ActionBarActivity {\n\n\tpublic static final String EXTRA_ACCOUNT = \"account\";\n\tprotected static final int REQUEST_ANNOUNCE_PGP = 0x0101;\n\tprotected static final int REQUEST_INVITE_TO_CONVERSATION = 0x0102;\n\tprotected static final int REQUEST_CHOOSE_PGP_ID = 0x0103;\n\tprotected static final int REQUEST_BATTERY_OP = 0x49ff;\n\tpublic XmppConnectionService xmppConnectionService;\n\tpublic boolean xmppConnectionServiceBound = false;\n\n\tprotected int mColorRed;\n\n\tprotected static final String FRAGMENT_TAG_DIALOG = \"dialog\";\n\n\tprivate boolean isCameraFeatureAvailable = false;\n\n\tprotected int mTheme;\n\tprotected boolean mUsingEnterKey = false;\n\tprotected Toast mToast;\n\tpublic Runnable onOpenPGPKeyPublished = () -> Toast.makeText(XmppActivity.this, R.string.openpgp_has_been_published, Toast.LENGTH_SHORT).show();\n\tprotected ConferenceInvite mPendingConferenceInvite = null;\n\tprotected ServiceConnection mConnection = new ServiceConnection() {\n\n\t\t@Override\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tXmppConnectionBinder binder = (XmppConnectionBinder) service;\n\t\t\txmppConnectionService = binder.getService();\n\t\t\txmppConnectionServiceBound = true;\n\t\t\tregisterListeners();\n\t\t\tonBackendConnected();\n\t\t}\n\n\t\t@Override\n\t\tpublic void onServiceDisconnected(ComponentName arg0) {\n\t\t\txmppConnectionServiceBound = false;\n\t\t}\n\t};\n\tprivate DisplayMetrics metrics;\n\tprivate long mLastUiRefresh = 0;\n\tprivate Handler mRefreshUiHandler = new Handler();\n\tprivate Runnable mRefreshUiRunnable = () -> {\n\t\tmLastUiRefresh = SystemClock.elapsedRealtime();\n\t\trefreshUiReal();\n\t};\n\tprivate UiCallback<Conversation> adhocCallback = new UiCallback<Conversation>() {\n\t\t@Override\n\t\tpublic void success(final Conversation conversation) {\n\t\t\trunOnUiThread(() -> {\n\t\t\t\tswitchToConversation(conversation);\n\t\t\t\thideToast();\n\t\t\t});\n\t\t}\n\n\t\t@Override\n\t\tpublic void error(final int errorCode, Conversation object) {\n\t\t\trunOnUiThread(() -> replaceToast(getString(errorCode)));\n\t\t}\n\n\t\t@Override\n\t\tpublic void userInputRequried(PendingIntent pi, Conversation object) {\n\n\t\t}\n\t};\n\tpublic boolean mSkipBackgroundBinding = false;\n\n\tpublic static boolean cancelPotentialWork(Message message, ImageView imageView) {\n\t\tfinal BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView);\n\n\t\tif (bitmapWorkerTask != null) {\n\t\t\tfinal Message oldMessage = bitmapWorkerTask.message;\n\t\t\tif (oldMessage == null || message != oldMessage) {\n\t\t\t\tbitmapWorkerTask.cancel(true);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static BitmapWorkerTask getBitmapWorkerTask(ImageView imageView) {\n\t\tif (imageView != null) {\n\t\t\tfinal Drawable drawable = imageView.getDrawable();\n\t\t\tif (drawable instanceof AsyncDrawable) {\n\t\t\t\tfinal AsyncDrawable asyncDrawable = (AsyncDrawable) drawable;\n\t\t\t\treturn asyncDrawable.getBitmapWorkerTask();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected void hideToast() {\n\t\tif (mToast != null) {\n\t\t\tmToast.cancel();\n\t\t}\n\t}\n\n\tprotected void replaceToast(String msg) {\n\t\treplaceToast(msg, true);\n\t}\n\n\tprotected void replaceToast(String msg, boolean showlong) {\n\t\thideToast();\n\t\tmToast = Toast.makeText(this, msg, showlong ? Toast.LENGTH_LONG : Toast.LENGTH_SHORT);\n\t\tmToast.show();\n\t}\n\n\tprotected final void refreshUi() {\n\t\tfinal long diff = SystemClock.elapsedRealtime() - mLastUiRefresh;\n\t\tif (diff > Config.REFRESH_UI_INTERVAL) {\n\t\t\tmRefreshUiHandler.removeCallbacks(mRefreshUiRunnable);\n\t\t\trunOnUiThread(mRefreshUiRunnable);\n\t\t} else {\n\t\t\tfinal long next = Config.REFRESH_UI_INTERVAL - diff;\n\t\t\tmRefreshUiHandler.removeCallbacks(mRefreshUiRunnable);\n\t\t\tmRefreshUiHandler.postDelayed(mRefreshUiRunnable, next);\n\t\t}\n\t}\n\n\tabstract protected void refreshUiReal();\n\n\t@Override\n\tprotected void onStart() {\n\t\tsuper.onStart();\n\t\tif (!xmppConnectionServiceBound) {\n\t\t\tif (this.mSkipBackgroundBinding) {\n\t\t\t\tLog.d(Config.LOGTAG,\"skipping background binding\");\n\t\t\t} else {\n\t\t\t\tconnectToBackend();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.registerListeners();\n\t\t\tthis.onBackendConnected();\n\t\t}\n\t}\n\n\tpublic void connectToBackend() {\n\t\tIntent intent = new Intent(this, XmppConnectionService.class);\n\t\tintent.setAction(\"ui\");\n\t\tstartService(intent);\n\t\tbindService(intent, mConnection, Context.BIND_AUTO_CREATE);\n\t}\n\n\t@Override\n\tprotected void onStop() {\n\t\tsuper.onStop();\n\t\tif (xmppConnectionServiceBound) {\n\t\t\tthis.unregisterListeners();\n\t\t\tunbindService(mConnection);\n\t\t\txmppConnectionServiceBound = false;\n\t\t}\n\t}\n\n\n\tpublic boolean hasPgp() {\n\t\treturn xmppConnectionService.getPgpEngine() != null;\n\t}\n\n\tpublic void showInstallPgpDialog() {\n\t\tBuilder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(getString(R.string.openkeychain_required));\n\t\tbuilder.setIconAttribute(android.R.attr.alertDialogIcon);\n\t\tbuilder.setMessage(getText(R.string.openkeychain_required_long));\n\t\tbuilder.setNegativeButton(getString(R.string.cancel), null);\n\t\tbuilder.setNeutralButton(getString(R.string.restart),\n\t\t\t\t(dialog, which) -> {\n\t\t\t\t\tif (xmppConnectionServiceBound) {\n\t\t\t\t\t\tunbindService(mConnection);\n\t\t\t\t\t\txmppConnectionServiceBound = false;\n\t\t\t\t\t}\n\t\t\t\t\tstopService(new Intent(XmppActivity.this,\n\t\t\t\t\t\t\tXmppConnectionService.class));\n\t\t\t\t\tfinish();\n\t\t\t\t});\n\t\tbuilder.setPositiveButton(getString(R.string.install),\n\t\t\t\t(dialog, which) -> {\n\t\t\t\t\tUri uri = Uri\n\t\t\t\t\t\t\t.parse(\"market://details?id=org.sufficientlysecure.keychain\");\n\t\t\t\t\tIntent marketIntent = new Intent(Intent.ACTION_VIEW,\n\t\t\t\t\t\t\turi);\n\t\t\t\t\tPackageManager manager = getApplicationContext()\n\t\t\t\t\t\t\t.getPackageManager();\n\t\t\t\t\tList<ResolveInfo> infos = manager\n\t\t\t\t\t\t\t.queryIntentActivities(marketIntent, 0);\n\t\t\t\t\tif (infos.size() > 0) {\n\t\t\t\t\t\tstartActivity(marketIntent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\turi = Uri.parse(\"http://www.openkeychain.org/\");\n\t\t\t\t\t\tIntent browserIntent = new Intent(\n\t\t\t\t\t\t\t\tIntent.ACTION_VIEW, uri);\n\t\t\t\t\t\tstartActivity(browserIntent);\n\t\t\t\t\t}\n\t\t\t\t\tfinish();\n\t\t\t\t});\n\t\tbuilder.create().show();\n\t}\n\n\tabstract void onBackendConnected();\n\n\tprotected void registerListeners() {\n\t\tif (this instanceof XmppConnectionService.OnConversationUpdate) {\n\t\t\tthis.xmppConnectionService.setOnConversationListChangedListener((XmppConnectionService.OnConversationUpdate) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnAccountUpdate) {\n\t\t\tthis.xmppConnectionService.setOnAccountListChangedListener((XmppConnectionService.OnAccountUpdate) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnCaptchaRequested) {\n\t\t\tthis.xmppConnectionService.setOnCaptchaRequestedListener((XmppConnectionService.OnCaptchaRequested) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnRosterUpdate) {\n\t\t\tthis.xmppConnectionService.setOnRosterUpdateListener((XmppConnectionService.OnRosterUpdate) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnMucRosterUpdate) {\n\t\t\tthis.xmppConnectionService.setOnMucRosterUpdateListener((XmppConnectionService.OnMucRosterUpdate) this);\n\t\t}\n\t\tif (this instanceof OnUpdateBlocklist) {\n\t\t\tthis.xmppConnectionService.setOnUpdateBlocklistListener((OnUpdateBlocklist) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnShowErrorToast) {\n\t\t\tthis.xmppConnectionService.setOnShowErrorToastListener((XmppConnectionService.OnShowErrorToast) this);\n\t\t}\n\t\tif (this instanceof OnKeyStatusUpdated) {\n\t\t\tthis.xmppConnectionService.setOnKeyStatusUpdatedListener((OnKeyStatusUpdated) this);\n\t\t}\n\t}\n\n\tprotected void unregisterListeners() {\n\t\tif (this instanceof XmppConnectionService.OnConversationUpdate) {\n\t\t\tthis.xmppConnectionService.removeOnConversationListChangedListener((XmppConnectionService.OnConversationUpdate) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnAccountUpdate) {\n\t\t\tthis.xmppConnectionService.removeOnAccountListChangedListener((XmppConnectionService.OnAccountUpdate) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnCaptchaRequested) {\n\t\t\tthis.xmppConnectionService.removeOnCaptchaRequestedListener((XmppConnectionService.OnCaptchaRequested) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnRosterUpdate) {\n\t\t\tthis.xmppConnectionService.removeOnRosterUpdateListener((XmppConnectionService.OnRosterUpdate) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnMucRosterUpdate) {\n\t\t\tthis.xmppConnectionService.removeOnMucRosterUpdateListener((XmppConnectionService.OnMucRosterUpdate) this);\n\t\t}\n\t\tif (this instanceof OnUpdateBlocklist) {\n\t\t\tthis.xmppConnectionService.removeOnUpdateBlocklistListener((OnUpdateBlocklist) this);\n\t\t}\n\t\tif (this instanceof XmppConnectionService.OnShowErrorToast) {\n\t\t\tthis.xmppConnectionService.removeOnShowErrorToastListener((XmppConnectionService.OnShowErrorToast) this);\n\t\t}\n\t\tif (this instanceof OnKeyStatusUpdated) {\n\t\t\tthis.xmppConnectionService.removeOnNewKeysAvailableListener((OnKeyStatusUpdated) this);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(final MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.action_settings:\n\t\t\t\tstartActivity(new Intent(this, SettingsActivity.class));\n\t\t\t\tbreak;\n\t\t\tcase R.id.action_accounts:\n\t\t\t\tstartActivity(new Intent(this, ManageAccountActivity.class));\n\t\t\t\tbreak;\n\t\t\tcase android.R.id.home:\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.action_show_qr_code:\n\t\t\t\tshowQrCode();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\tpublic void selectPresence(final Conversation conversation, final PresenceSelector.OnPresenceSelected listener) {\n\t\tfinal Contact contact = conversation.getContact();\n\t\tif (!contact.showInRoster()) {\n\t\t\tshowAddToRosterDialog(conversation.getContact());\n\t\t} else {\n\t\t\tfinal Presences presences = contact.getPresences();\n\t\t\tif (presences.size() == 0) {\n\t\t\t\tif (!contact.getOption(Contact.Options.TO)\n\t\t\t\t\t\t&& !contact.getOption(Contact.Options.ASKING)\n\t\t\t\t\t\t&& contact.getAccount().getStatus() == Account.State.ONLINE) {\n\t\t\t\t\tshowAskForPresenceDialog(contact);\n\t\t\t\t} else if (!contact.getOption(Contact.Options.TO)\n\t\t\t\t\t\t|| !contact.getOption(Contact.Options.FROM)) {\n\t\t\t\t\tPresenceSelector.warnMutualPresenceSubscription(this, conversation, listener);\n\t\t\t\t} else {\n\t\t\t\t\tconversation.setNextCounterpart(null);\n\t\t\t\t\tlistener.onPresenceSelected();\n\t\t\t\t}\n\t\t\t} else if (presences.size() == 1) {\n\t\t\t\tString presence = presences.toResourceArray()[0];\n\t\t\t\ttry {\n\t\t\t\t\tconversation.setNextCounterpart(Jid.of(contact.getJid().getLocal(), contact.getJid().getDomain(), presence));\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tconversation.setNextCounterpart(null);\n\t\t\t\t}\n\t\t\t\tlistener.onPresenceSelected();\n\t\t\t} else {\n\t\t\t\tPresenceSelector.showPresenceSelectionDialog(this, conversation, listener);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tmetrics = getResources().getDisplayMetrics();\n\t\tExceptionHelper.init(getApplicationContext());\n\t\tthis.isCameraFeatureAvailable = getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA);\n\n\t\tmColorRed = ContextCompat.getColor(this, R.color.red800);\n\n\t\tthis.mTheme = findTheme();\n\t\tsetTheme(this.mTheme);\n\n\t\tthis.mUsingEnterKey = usingEnterKey();\n\t}\n\n\tprotected boolean isCameraFeatureAvailable() {\n\t\treturn this.isCameraFeatureAvailable;\n\t}\n\n\tpublic boolean isDarkTheme() {\n\t\treturn ThemeHelper.isDark(mTheme);\n\t}\n\n\tpublic int getThemeResource(int r_attr_name, int r_drawable_def) {\n\t\tint[] attrs = {r_attr_name};\n\t\tTypedArray ta = this.getTheme().obtainStyledAttributes(attrs);\n\n\t\tint res = ta.getResourceId(0, r_drawable_def);\n\t\tta.recycle();\n\n\t\treturn res;\n\t}\n\n\tprotected boolean isOptimizingBattery() {\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n\t\t\tfinal PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);\n\t\t\treturn pm != null\n\t\t\t\t\t&& !pm.isIgnoringBatteryOptimizations(getPackageName());\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprotected boolean isAffectedByDataSaver() {\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n\t\t\tfinal ConnectivityManager cm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);\n\t\t\treturn cm != null\n\t\t\t\t\t&& cm.isActiveNetworkMetered()\n\t\t\t\t\t&& cm.getRestrictBackgroundStatus() == ConnectivityManager.RESTRICT_BACKGROUND_STATUS_ENABLED;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprotected boolean usingEnterKey() {\n\t\treturn getBooleanPreference(\"display_enter_key\", R.bool.display_enter_key);\n\t}\n\n\tprotected SharedPreferences getPreferences() {\n\t\treturn PreferenceManager.getDefaultSharedPreferences(getApplicationContext());\n\t}\n\n\tprotected boolean getBooleanPreference(String name, @BoolRes int res) {\n\t\treturn getPreferences().getBoolean(name, getResources().getBoolean(res));\n\t}\n\n\tpublic void switchToConversation(Conversation conversation) {\n\t\tswitchToConversation(conversation, null);\n\t}\n\n\tpublic void switchToConversationAndQuote(Conversation conversation, String text) {\n\t\tswitchToConversation(conversation, text, true, null, false, false);\n\t}\n\n\tpublic void switchToConversation(Conversation conversation, String text) {\n\t\tswitchToConversation(conversation, text, false, null, false, false);\n\t}\n\n\tpublic void switchToConversationDoNotAppend(Conversation conversation, String text) {\n\t\tswitchToConversation(conversation, text, false, null, false, true);\n\t}\n\n\tpublic void highlightInMuc(Conversation conversation, String nick) {\n\t\tswitchToConversation(conversation, null, false, nick, false, false);\n\t}\n\n\tpublic void privateMsgInMuc(Conversation conversation, String nick) {\n\t\tswitchToConversation(conversation, null, false, nick, true, false);\n\t}\n\n\tprivate void switchToConversation(Conversation conversation, String text, boolean asQuote, String nick, boolean pm, boolean doNotAppend) {\n\t\tIntent intent = new Intent(this, ConversationsActivity.class);\n\t\tintent.setAction(ConversationsActivity.ACTION_VIEW_CONVERSATION);\n\t\tintent.putExtra(ConversationsActivity.EXTRA_CONVERSATION, conversation.getUuid());\n\t\tif (text != null) {\n\t\t\tintent.putExtra(Intent.EXTRA_TEXT, text);\n\t\t\tif (asQuote) {\n\t\t\t\tintent.putExtra(ConversationsActivity.EXTRA_AS_QUOTE, true);\n\t\t\t}\n\t\t}\n\t\tif (nick != null) {\n\t\t\tintent.putExtra(ConversationsActivity.EXTRA_NICK, nick);\n\t\t\tintent.putExtra(ConversationsActivity.EXTRA_IS_PRIVATE_MESSAGE, pm);\n\t\t}\n\t\tif (doNotAppend) {\n\t\t\tintent.putExtra(ConversationsActivity.EXTRA_DO_NOT_APPEND, true);\n\t\t}\n\t\tintent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\tstartActivity(intent);\n\t\tfinish();\n\t}\n\n\tpublic void switchToContactDetails(Contact contact) {\n\t\tswitchToContactDetails(contact, null);\n\t}\n\n\tpublic void switchToContactDetails(Contact contact, String messageFingerprint) {\n\t\tIntent intent = new Intent(this, ContactDetailsActivity.class);\n\t\tintent.setAction(ContactDetailsActivity.ACTION_VIEW_CONTACT);\n\t\tintent.putExtra(EXTRA_ACCOUNT, contact.getAccount().getJid().asBareJid().toString());\n\t\tintent.putExtra(\"contact\", contact.getJid().toString());\n\t\tintent.putExtra(\"fingerprint\", messageFingerprint);\n\t\tstartActivity(intent);\n\t}\n\n\tpublic void switchToAccount(Account account, String fingerprint) {\n\t\tswitchToAccount(account, false, fingerprint);\n\t}\n\n\tpublic void switchToAccount(Account account) {\n\t\tswitchToAccount(account, false, null);\n\t}\n\n\tpublic void switchToAccount(Account account, boolean init, String fingerprint) {\n\t\tIntent intent = new Intent(this, EditAccountActivity.class);\n\t\tintent.putExtra(\"jid\", account.getJid().asBareJid().toString());\n\t\tintent.putExtra(\"init\", init);\n\t\tif (init) {\n\t\t\tintent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NO_ANIMATION);\n\t\t}\n\t\tif (fingerprint != null) {\n\t\t\tintent.putExtra(\"fingerprint\", fingerprint);\n\t\t}\n\t\tstartActivity(intent);\n\t\tif (init) {\n\t\t\toverridePendingTransition(0, 0);\n\t\t}\n\t}\n\n\tprotected void delegateUriPermissionsToService(Uri uri) {\n\t\tIntent intent = new Intent(this, XmppConnectionService.class);\n\t\tintent.setAction(Intent.ACTION_SEND);\n\t\tintent.setData(uri);\n\t\tintent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\t\ttry {\n\t\t\tstartService(intent);\n\t\t} catch (Exception e) {\n\t\t\tLog.e(Config.LOGTAG,\"unable to delegate uri permission\",e);\n\t\t}\n\t}\n\n\tprotected void inviteToConversation(Conversation conversation) {\n\t\tstartActivityForResult(ChooseContactActivity.create(this,conversation), REQUEST_INVITE_TO_CONVERSATION);\n\t}\n\n\tprotected void announcePgp(final Account account, final Conversation conversation, Intent intent, final Runnable onSuccess) {\n\t\tif (account.getPgpId() == 0) {\n\t\t\tchoosePgpSignId(account);\n\t\t} else {\n\t\t\tString status = null;\n\t\t\tif (manuallyChangePresence()) {\n\t\t\t\tstatus = account.getPresenceStatusMessage();\n\t\t\t}\n\t\t\tif (status == null) {\n\t\t\t\tstatus = \"\";\n\t\t\t}\n\t\t\txmppConnectionService.getPgpEngine().generateSignature(intent, account, status, new UiCallback<String>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void userInputRequried(PendingIntent pi, String signature) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstartIntentSenderForResult(pi.getIntentSender(), REQUEST_ANNOUNCE_PGP, null, 0, 0, 0);\n\t\t\t\t\t} catch (final SendIntentException ignored) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void success(String signature) {\n\t\t\t\t\taccount.setPgpSignature(signature);\n\t\t\t\t\txmppConnectionService.databaseBackend.updateAccount(account);\n\t\t\t\t\txmppConnectionService.sendPresence(account);\n\t\t\t\t\tif (conversation != null) {\n\t\t\t\t\t\tconversation.setNextEncryption(Message.ENCRYPTION_PGP);\n\t\t\t\t\t\txmppConnectionService.updateConversation(conversation);\n\t\t\t\t\t\trefreshUi();\n\t\t\t\t\t}\n\t\t\t\t\tif (onSuccess != null) {\n\t\t\t\t\t\trunOnUiThread(onSuccess);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void error(int error, String signature) {\n\t\t\t\t\tif (error == 0) {\n\t\t\t\t\t\taccount.setPgpSignId(0);\n\t\t\t\t\t\taccount.unsetPgpSignature();\n\t\t\t\t\t\txmppConnectionService.databaseBackend.updateAccount(account);\n\t\t\t\t\t\tchoosePgpSignId(account);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisplayErrorDialog(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\t@TargetApi(Build.VERSION_CODES.JELLY_BEAN)\n\tprotected void setListItemBackgroundOnView(View view) {\n\t\tint sdk = android.os.Build.VERSION.SDK_INT;\n\t\tif (sdk < android.os.Build.VERSION_CODES.JELLY_BEAN) {\n\t\t\tview.setBackgroundDrawable(getResources().getDrawable(R.drawable.greybackground));\n\t\t} else {\n\t\t\tview.setBackground(getResources().getDrawable(R.drawable.greybackground));\n\t\t}\n\t}\n\n\tprotected void choosePgpSignId(Account account) {\n\t\txmppConnectionService.getPgpEngine().chooseKey(account, new UiCallback<Account>() {\n\t\t\t@Override\n\t\t\tpublic void success(Account account1) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void error(int errorCode, Account object) {\n\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void userInputRequried(PendingIntent pi, Account object) {\n\t\t\t\ttry {\n\t\t\t\t\tstartIntentSenderForResult(pi.getIntentSender(),\n\t\t\t\t\t\t\tREQUEST_CHOOSE_PGP_ID, null, 0, 0, 0);\n\t\t\t\t} catch (final SendIntentException ignored) {\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprotected void displayErrorDialog(final int errorCode) {\n\t\trunOnUiThread(() -> {\n\t\t\tBuilder builder = new Builder(XmppActivity.this);\n\t\t\tbuilder.setIconAttribute(android.R.attr.alertDialogIcon);\n\t\t\tbuilder.setTitle(getString(R.string.error));\n\t\t\tbuilder.setMessage(errorCode);\n\t\t\tbuilder.setNeutralButton(R.string.accept, null);\n\t\t\tbuilder.create().show();\n\t\t});\n\n\t}\n\n\tprotected void showAddToRosterDialog(final Contact contact) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(contact.getJid().toString());\n\t\tbuilder.setMessage(getString(R.string.not_in_roster));\n\t\tbuilder.setNegativeButton(getString(R.string.cancel), null);\n\t\tbuilder.setPositiveButton(getString(R.string.add_contact), (dialog, which) -> xmppConnectionService.createContact(contact,true));\n\t\tbuilder.create().show();\n\t}\n\n\tprivate void showAskForPresenceDialog(final Contact contact) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(contact.getJid().toString());\n\t\tbuilder.setMessage(R.string.request_presence_updates);\n\t\tbuilder.setNegativeButton(R.string.cancel, null);\n\t\tbuilder.setPositiveButton(R.string.request_now,\n\t\t\t\t(dialog, which) -> {\n\t\t\t\t\tif (xmppConnectionServiceBound) {\n\t\t\t\t\t\txmppConnectionService.sendPresencePacket(contact\n\t\t\t\t\t\t\t\t.getAccount(), xmppConnectionService\n\t\t\t\t\t\t\t\t.getPresenceGenerator()\n\t\t\t\t\t\t\t\t.requestPresenceUpdatesFrom(contact));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tbuilder.create().show();\n\t}\n\n\tprotected void quickEdit(String previousValue, @StringRes int hint, OnValueEdited callback) {\n\t\tquickEdit(previousValue, callback, hint, false, false);\n\t}\n\n\tprotected void quickEdit(String previousValue, @StringRes int hint, OnValueEdited callback, boolean permitEmpty) {\n\t\tquickEdit(previousValue, callback, hint, false, permitEmpty);\n\t}\n\n\tprotected void quickPasswordEdit(String previousValue, OnValueEdited callback) {\n\t\tquickEdit(previousValue, callback, R.string.password, true, false);\n\t}\n\n\t@SuppressLint(\"InflateParams\")\n\tprivate void quickEdit(final String previousValue,\n\t                       final OnValueEdited callback,\n\t                       final @StringRes int hint,\n\t                       boolean password,\n\t                       boolean permitEmpty) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tDialogQuickeditBinding binding = DataBindingUtil.inflate(getLayoutInflater(),R.layout.dialog_quickedit, null, false);\n\t\tif (password) {\n\t\t\tbinding.inputEditText.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n\t\t}\n\t\tbuilder.setPositiveButton(R.string.accept, null);\n\t\tif (hint != 0) {\n\t\t\tbinding.inputLayout.setHint(getString(hint));\n\t\t}\n\t\tbinding.inputEditText.requestFocus();\n\t\tif (previousValue != null) {\n\t\t\tbinding.inputEditText.getText().append(previousValue);\n\t\t}\n\t\tbuilder.setView(binding.getRoot());\n\t\tbuilder.setNegativeButton(R.string.cancel, null);\n\t\tfinal AlertDialog dialog = builder.create();\n\t\tdialog.setOnShowListener(d -> SoftKeyboardUtils.showKeyboard(binding.inputEditText));\n\t\tdialog.show();\n\t\tView.OnClickListener clickListener = v -> {\n\t\t\tString value = binding.inputEditText.getText().toString();\n\t\t\tif (!value.equals(previousValue) && (!value.trim().isEmpty() || permitEmpty)) {\n\t\t\t\tString error = callback.onValueEdited(value);\n\t\t\t\tif (error != null) {\n\t\t\t\t\tbinding.inputLayout.setError(error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSoftKeyboardUtils.hideSoftKeyboard(binding.inputEditText);\n\t\t\tdialog.dismiss();\n\t\t};\n\t\tdialog.getButton(DialogInterface.BUTTON_POSITIVE).setOnClickListener(clickListener);\n\t\tdialog.getButton(DialogInterface.BUTTON_NEGATIVE).setOnClickListener((v -> {\n\t\t\tSoftKeyboardUtils.hideSoftKeyboard(binding.inputEditText);\n\t\t\tdialog.dismiss();\n\t\t}));\n\t\tdialog.setOnDismissListener(dialog1 -> {\n\t\t\tSoftKeyboardUtils.hideSoftKeyboard(binding.inputEditText);\n        });\n\t}\n\n\tprotected boolean hasStoragePermission(int requestCode) {\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n\t\t\tif (checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {\n\t\t\t\trequestPermissions(new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, requestCode);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprotected void onActivityResult(int requestCode, int resultCode, final Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\tif (requestCode == REQUEST_INVITE_TO_CONVERSATION && resultCode == RESULT_OK) {\n\t\t\tmPendingConferenceInvite = ConferenceInvite.parse(data);\n\t\t\tif (xmppConnectionServiceBound && mPendingConferenceInvite != null) {\n\t\t\t\tif (mPendingConferenceInvite.execute(this)) {\n\t\t\t\t\tmToast = Toast.makeText(this, R.string.creating_conference, Toast.LENGTH_LONG);\n\t\t\t\t\tmToast.show();\n\t\t\t\t}\n\t\t\t\tmPendingConferenceInvite = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic int getWarningTextColor() {\n\t\treturn this.mColorRed;\n\t}\n\n\tpublic int getPixel(int dp) {\n\t\tDisplayMetrics metrics = getResources().getDisplayMetrics();\n\t\treturn ((int) (dp * metrics.density));\n\t}\n\n\tpublic boolean copyTextToClipboard(String text, int labelResId) {\n\t\tClipboardManager mClipBoardManager = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t\tString label = getResources().getString(labelResId);\n\t\tif (mClipBoardManager != null) {\n\t\t\tClipData mClipData = ClipData.newPlainText(label, text);\n\t\t\tmClipBoardManager.setPrimaryClip(mClipData);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected boolean neverCompressPictures() {\n\t\treturn getPreferences().getString(\"picture_compression\", getResources().getString(R.string.picture_compression)).equals(\"never\");\n\t}\n\n\tprotected boolean manuallyChangePresence() {\n\t\treturn getBooleanPreference(SettingsActivity.MANUALLY_CHANGE_PRESENCE, R.bool.manually_change_presence);\n\t}\n\n\tprotected String getShareableUri() {\n\t\treturn getShareableUri(false);\n\t}\n\n\tprotected String getShareableUri(boolean http) {\n\t\treturn null;\n\t}\n\n\tprotected void shareLink(boolean http) {\n\t\tString uri = getShareableUri(http);\n\t\tif (uri == null || uri.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\tIntent intent = new Intent(Intent.ACTION_SEND);\n\t\tintent.setType(\"text/plain\");\n\t\tintent.putExtra(Intent.EXTRA_TEXT, getShareableUri(http));\n\t\ttry {\n\t\t\tstartActivity(Intent.createChooser(intent, getText(R.string.share_uri_with)));\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\tToast.makeText(this, R.string.no_application_to_share_uri, Toast.LENGTH_SHORT).show();\n\t\t}\n\t}\n\n\tprotected void launchOpenKeyChain(long keyId) {\n\t\tPgpEngine pgp = XmppActivity.this.xmppConnectionService.getPgpEngine();\n\t\ttry {\n\t\t\tstartIntentSenderForResult(\n\t\t\t\t\tpgp.getIntentForKey(keyId).getIntentSender(), 0, null, 0,\n\t\t\t\t\t0, 0);\n\t\t} catch (Throwable e) {\n\t\t\tToast.makeText(XmppActivity.this, R.string.openpgp_error, Toast.LENGTH_SHORT).show();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onResume() {\n\t\tsuper.onResume();\n\t}\n\n\tprotected int findTheme() {\n\t\treturn ThemeHelper.find(this);\n\t}\n\n\t@Override\n\tpublic void onPause() {\n\t\tsuper.onPause();\n\t}\n\n\t@Override\n\tpublic boolean onMenuOpened(int id, Menu menu) {\n\t\tif(id == AppCompatDelegate.FEATURE_SUPPORT_ACTION_BAR && menu != null) {\n\t\t\tMenuDoubleTabUtil.recordMenuOpen();\n\t\t}\n\t\treturn super.onMenuOpened(id, menu);\n\t}\n\n\tprotected void showQrCode() {\n\t\tshowQrCode(getShareableUri());\n\t}\n\n\tprotected void showQrCode(final String uri) {\n\t\tif (uri == null || uri.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\tPoint size = new Point();\n\t\tgetWindowManager().getDefaultDisplay().getSize(size);\n\t\tfinal int width = (size.x < size.y ? size.x : size.y);\n\t\tBitmap bitmap = BarcodeProvider.create2dBarcodeBitmap(uri, width);\n\t\tImageView view = new ImageView(this);\n\t\tview.setBackgroundColor(Color.WHITE);\n\t\tview.setImageBitmap(bitmap);\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setView(view);\n\t\tbuilder.create().show();\n\t}\n\n\tprotected Account extractAccount(Intent intent) {\n\t\tString jid = intent != null ? intent.getStringExtra(EXTRA_ACCOUNT) : null;\n\t\ttry {\n\t\t\treturn jid != null ? xmppConnectionService.findAccountByJid(Jid.of(jid)) : null;\n\t\t} catch (IllegalArgumentException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic AvatarService avatarService() {\n\t\treturn xmppConnectionService.getAvatarService();\n\t}\n\n\tpublic void loadBitmap(Message message, ImageView imageView) {\n\t\tBitmap bm;\n\t\ttry {\n\t\t\tbm = xmppConnectionService.getFileBackend().getThumbnail(message, (int) (metrics.density * 288), true);\n\t\t} catch (IOException e) {\n\t\t\tbm = null;\n\t\t}\n\t\tif (bm != null) {\n\t\t\tcancelPotentialWork(message, imageView);\n\t\t\timageView.setImageBitmap(bm);\n\t\t\timageView.setBackgroundColor(0x00000000);\n\t\t} else {\n\t\t\tif (cancelPotentialWork(message, imageView)) {\n\t\t\t\timageView.setBackgroundColor(0xff333333);\n\t\t\t\timageView.setImageDrawable(null);\n\t\t\t\tfinal BitmapWorkerTask task = new BitmapWorkerTask(this, imageView);\n\t\t\t\tfinal AsyncDrawable asyncDrawable = new AsyncDrawable(\n\t\t\t\t\t\tgetResources(), null, task);\n\t\t\t\timageView.setImageDrawable(asyncDrawable);\n\t\t\t\ttry {\n\t\t\t\t\ttask.execute(message);\n\t\t\t\t} catch (final RejectedExecutionException ignored) {\n\t\t\t\t\tignored.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected interface OnValueEdited {\n\t\tString onValueEdited(String value);\n\t}\n\n\tpublic static class ConferenceInvite {\n\t\tprivate String uuid;\n\t\tprivate List<Jid> jids = new ArrayList<>();\n\n\t\tpublic static ConferenceInvite parse(Intent data) {\n\t\t\tConferenceInvite invite = new ConferenceInvite();\n\t\t\tinvite.uuid = data.getStringExtra(ChooseContactActivity.EXTRA_CONVERSATION);\n\t\t\tif (invite.uuid == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tinvite.jids.addAll(ChooseContactActivity.extractJabberIds(data));\n\t\t\treturn invite;\n\t\t}\n\n\t\tpublic boolean execute(XmppActivity activity) {\n\t\t\tXmppConnectionService service = activity.xmppConnectionService;\n\t\t\tConversation conversation = service.findConversationByUuid(this.uuid);\n\t\t\tif (conversation == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (conversation.getMode() == Conversation.MODE_MULTI) {\n\t\t\t\tfor (Jid jid : jids) {\n\t\t\t\t\tservice.invite(conversation, jid);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tjids.add(conversation.getJid().asBareJid());\n\t\t\t\treturn service.createAdhocConference(conversation.getAccount(), null, jids, activity.adhocCallback);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class BitmapWorkerTask extends AsyncTask<Message, Void, Bitmap> {\n\t\tprivate final WeakReference<ImageView> imageViewReference;\n\t\tprivate final WeakReference<XmppActivity> activity;\n\t\tprivate Message message = null;\n\n\t\tprivate BitmapWorkerTask(XmppActivity activity, ImageView imageView) {\n\t\t\tthis.activity = new WeakReference<>(activity);\n\t\t\tthis.imageViewReference = new WeakReference<>(imageView);\n\t\t}\n\n\t\t@Override\n\t\tprotected Bitmap doInBackground(Message... params) {\n\t\t\tif (isCancelled()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmessage = params[0];\n\t\t\ttry {\n\t\t\t\tXmppActivity activity = this.activity.get();\n\t\t\t\tif (activity != null && activity.xmppConnectionService != null) {\n\t\t\t\t\treturn activity.xmppConnectionService.getFileBackend().getThumbnail(message, (int) (activity.metrics.density * 288), false);\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void onPostExecute(Bitmap bitmap) {\n\t\t\tif (bitmap != null && !isCancelled()) {\n\t\t\t\tfinal ImageView imageView = imageViewReference.get();\n\t\t\t\tif (imageView != null) {\n\t\t\t\t\timageView.setImageBitmap(bitmap);\n\t\t\t\t\timageView.setBackgroundColor(0x00000000);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class AsyncDrawable extends BitmapDrawable {\n\t\tprivate final WeakReference<BitmapWorkerTask> bitmapWorkerTaskReference;\n\n\t\tprivate AsyncDrawable(Resources res, Bitmap bitmap, BitmapWorkerTask bitmapWorkerTask) {\n\t\t\tsuper(res, bitmap);\n\t\t\tbitmapWorkerTaskReference = new WeakReference<>(bitmapWorkerTask);\n\t\t}\n\n\t\tprivate BitmapWorkerTask getBitmapWorkerTask() {\n\t\t\treturn bitmapWorkerTaskReference.get();\n\t\t}\n\t}\n}\n", "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <string name=\"action_settings\">Settings</string>\n    <string name=\"action_add\">New conversation</string>\n    <string name=\"action_accounts\">Manage accounts</string>\n    <string name=\"action_end_conversation\">End this conversation</string>\n    <string name=\"action_contact_details\">Contact details</string>\n    <string name=\"action_muc_details\">Group chat details</string>\n    <string name=\"action_secure\">Secure conversation</string>\n    <string name=\"action_add_account\">Add account</string>\n    <string name=\"action_edit_contact\">Edit name</string>\n    <string name=\"action_add_phone_book\">Add to address book</string>\n    <string name=\"action_delete_contact\">Delete from roster</string>\n    <string name=\"action_block_contact\">Block contact</string>\n    <string name=\"action_unblock_contact\">Unblock contact</string>\n    <string name=\"action_block_domain\">Block domain</string>\n    <string name=\"action_unblock_domain\">Unblock domain</string>\n    <string name=\"title_activity_manage_accounts\">Manage Accounts</string>\n    <string name=\"title_activity_settings\">Settings</string>\n    <string name=\"title_activity_sharewith\">Share with Conversation</string>\n    <string name=\"title_activity_start_conversation\">Start Conversation</string>\n    <string name=\"title_activity_choose_contact\">Choose Contact</string>\n    <string name=\"title_activity_choose_contacts\">Choose Contacts</string>\n    <string name=\"title_activity_share_via_account\">Share via account</string>\n    <string name=\"title_activity_block_list\">Block list</string>\n    <string name=\"just_now\">just now</string>\n    <string name=\"minute_ago\">1 min ago</string>\n    <string name=\"minutes_ago\">%d mins ago</string>\n    <string name=\"unread_conversations\">unread Conversations</string>\n    <string name=\"sending\">sending\u2026</string>\n    <string name=\"message_decrypting\">Decrypting message. Please wait\u2026</string>\n    <string name=\"pgp_message\">OpenPGP encrypted message</string>\n    <string name=\"nick_in_use\">Nickname is already in use</string>\n    <string name=\"invalid_muc_nick\">Invalid nickname</string>\n    <string name=\"admin\">Admin</string>\n    <string name=\"owner\">Owner</string>\n    <string name=\"moderator\">Moderator</string>\n    <string name=\"participant\">Participant</string>\n    <string name=\"visitor\">Visitor</string>\n    <string name=\"remove_contact_text\">Would you like to remove %s from your roster? The conversation associated with this contact will not be removed.</string>\n    <string name=\"block_contact_text\">Would you like to block %s from sending you messages?</string>\n    <string name=\"unblock_contact_text\">Would you like to unblock %s and allow them to send you messages?</string>\n    <string name=\"block_domain_text\">Block all contacts from %s?</string>\n    <string name=\"unblock_domain_text\">Unblock all contacts from %s?</string>\n    <string name=\"contact_blocked\">Contact blocked</string>\n    <string name=\"blocked\">Blocked</string>\n    <string name=\"remove_bookmark_text\">Would you like to remove %s as a bookmark? The conversation associated with this bookmark will not be removed.</string>\n    <string name=\"register_account\">Register new account on server</string>\n    <string name=\"change_password_on_server\">Change password on server</string>\n    <string name=\"share_with\">Share with\u2026</string>\n    <string name=\"start_conversation\">Start conversation</string>\n    <string name=\"invite_contact\">Invite contact</string>\n    <string name=\"contacts\">Contacts</string>\n    <string name=\"contact\">Contact</string>\n    <string name=\"cancel\">Cancel</string>\n    <string name=\"set\">Set</string>\n    <string name=\"add\">Add</string>\n    <string name=\"edit\">Edit</string>\n    <string name=\"delete\">Delete</string>\n    <string name=\"block\">Block</string>\n    <string name=\"unblock\">Unblock</string>\n    <string name=\"save\">Save</string>\n    <string name=\"ok\">OK</string>\n    <string name=\"crash_report_title\">Conversations has crashed</string>\n    <string name=\"crash_report_message\">By sending in stack traces you are helping the ongoing development of Conversations\\n<b>Warning:</b> This will use your XMPP account to send the stack trace to the developer.</string>\n    <string name=\"send_now\">Send now</string>\n    <string name=\"send_never\">Never ask again</string>\n    <string name=\"problem_connecting_to_account\">Unable to connect to account</string>\n    <string name=\"problem_connecting_to_accounts\">Unable to connect to multiple accounts</string>\n    <string name=\"touch_to_fix\">Touch here to manage your accounts</string>\n    <string name=\"attach_file\">Attach file</string>\n    <string name=\"not_in_roster\">The contact is not in your roster. Would you like to add it?</string>\n    <string name=\"add_contact\">Add contact</string>\n    <string name=\"send_failed\">delivery failed</string>\n    <string name=\"preparing_image\">Preparing image for transmission</string>\n    <string name=\"preparing_images\">Preparing images for transmission</string>\n    <string name=\"sharing_files_please_wait\">Sharing files. Please wait\u2026</string>\n    <string name=\"action_clear_history\">Clear history</string>\n    <string name=\"clear_conversation_history\">Clear Conversation History</string>\n    <string name=\"clear_histor_msg\">Are you sure you want to delete all messages within this conversation?\\n\\n<b>Warning:</b> This will not delete copies of those messages that are stored on other devices or servers.</string>\n    <string name=\"delete_file_dialog\">Delete file</string>\n    <string name=\"delete_file_dialog_msg\">Are you sure you want to delete this file?\\n\\n<b>Warning:</b> This will not delete copies of this file that are stored on other devices or servers. </string>\n    <string name=\"also_end_conversation\">End this conversation afterwards</string>\n    <string name=\"choose_presence\">Choose device</string>\n    <string name=\"send_unencrypted_message\">Send unencrypted message</string>\n    <string name=\"send_message\">Send message</string>\n    <string name=\"send_message_to_x\">Send message to %s</string>\n    <string name=\"send_omemo_message\">Send OMEMO encrypted message</string>\n    <string name=\"send_omemo_x509_message\">Send v\\\\OMEMO encrypted message</string>\n    <string name=\"send_pgp_message\">Send OpenPGP encrypted message</string>\n    <string name=\"your_nick_has_been_changed\">Your nickname has been changed</string>\n    <string name=\"send_unencrypted\">Send unencrypted</string>\n    <string name=\"decryption_failed\">Decryption failed. Maybe you don\u2019t have the proper private key.</string>\n    <string name=\"openkeychain_required\">OpenKeychain</string>\n    <string name=\"openkeychain_required_long\">Conversations utilizes a third party app called <b>OpenKeychain</b> to encrypt and decrypt messages and to manage your public keys.\\n\\nOpenKeychain is licensed under GPLv3 and available on F-Droid and Google Play.\\n\\n<small>(Please restart Conversations afterwards.)</small></string>\n    <string name=\"restart\">Restart</string>\n    <string name=\"install\">Install</string>\n    <string name=\"openkeychain_not_installed\">Please install OpenKeychain</string>\n    <string name=\"offering\">offering\u2026</string>\n    <string name=\"waiting\">waiting\u2026</string>\n    <string name=\"no_pgp_key\">No OpenPGP Key found</string>\n    <string name=\"contact_has_no_pgp_key\">Conversations is unable to encrypt your messages because your contact is not announcing his or hers public key.\\n\\n<small>Please ask your contact to setup OpenPGP.</small></string>\n    <string name=\"no_pgp_keys\">No OpenPGP Keys found</string>\n    <string name=\"contacts_have_no_pgp_keys\">Conversations is unable to encrypt your messages because your contacts are not announcing their public key.\\n\\n<small>Please ask your contacts to setup OpenPGP.</small></string>\n    <string name=\"pref_general\">General</string>\n    <string name=\"pref_accept_files\">Accept files</string>\n    <string name=\"pref_accept_files_summary\">Automatically accept files smaller than\u2026</string>\n    <string name=\"pref_attachments\">Attachments</string>\n    <string name=\"pref_notification_settings\">Notification</string>\n    <string name=\"pref_vibrate\">Vibrate</string>\n    <string name=\"pref_vibrate_summary\">Vibrate when a new message arrives</string>\n    <string name=\"pref_led\">LED Notification</string>\n    <string name=\"pref_led_summary\">Blink notification light when a new message arrives</string>\n    <string name=\"pref_sound\">Ringtone</string>\n    <string name=\"pref_sound_summary\">Play sound when a new message arrives</string>\n    <string name=\"pref_notification_grace_period\">Grace Period</string>\n    <string name=\"pref_notification_grace_period_summary\">The length of time Conversations keeps quiet after seeing activity on another device</string>\n    <string name=\"pref_advanced_options\">Advanced</string>\n    <string name=\"pref_never_send_crash\">Never send crash reports</string>\n    <string name=\"pref_never_send_crash_summary\">By sending in stack traces you are helping the ongoing development of Conversations</string>\n    <string name=\"pref_confirm_messages\">Confirm Messages</string>\n    <string name=\"pref_confirm_messages_summary\">Let your contacts know when you have received and read their messages</string>\n    <string name=\"pref_ui_options\">UI</string>\n    <string name=\"openpgp_error\">OpenKeychain reported an error</string>\n    <string name=\"accept\">Accept</string>\n    <string name=\"error\">An error has occurred</string>\n    <string name=\"recording_error\">Error</string>\n    <string name=\"your_account\">Your account</string>\n    <string name=\"send_presence_updates\">Send presence updates</string>\n    <string name=\"receive_presence_updates\">Receive presence updates</string>\n    <string name=\"ask_for_presence_updates\">Ask for presence updates</string>\n    <string name=\"attach_choose_picture\">Choose picture</string>\n    <string name=\"attach_take_picture\">Take picture</string>\n    <string name=\"preemptively_grant\">Preemptively grant subscription request</string>\n    <string name=\"error_not_an_image_file\">The file you selected is not an image</string>\n    <string name=\"error_compressing_image\">Error while converting the image file</string>\n    <string name=\"error_file_not_found\">File not found</string>\n    <string name=\"error_io_exception\">General I/O error. Maybe you ran out of storage space?</string>\n    <string name=\"error_security_exception_during_image_copy\">The app you used to select this image did not provide us with enough permissions to read the file.\\n\\n<small>Use a different file manager to choose an image</small></string>\n    <string name=\"account_status_unknown\">Unknown</string>\n    <string name=\"account_status_disabled\">Temporarily disabled</string>\n    <string name=\"account_status_online\">Online</string>\n    <string name=\"account_status_connecting\">Connecting\\u2026</string>\n    <string name=\"account_status_offline\">Offline</string>\n    <string name=\"account_status_unauthorized\">Unauthorized</string>\n    <string name=\"account_status_not_found\">Server not found</string>\n    <string name=\"account_status_no_internet\">No connectivity</string>\n    <string name=\"account_status_regis_fail\">Registration failed</string>\n    <string name=\"account_status_regis_conflict\">Username already in use</string>\n    <string name=\"account_status_regis_success\">Registration completed</string>\n    <string name=\"account_status_regis_not_sup\">Server does not support registration</string>\n    <string name=\"account_status_tls_error\">TLS negotiation failed</string>\n    <string name=\"account_status_policy_violation\">Policy violation</string>\n    <string name=\"account_status_incompatible_server\">Incompatible server</string>\n    <string name=\"account_status_stream_error\">Stream error</string>\n    <string name=\"account_status_stream_opening_error\">Stream opening error</string>\n    <string name=\"encryption_choice_unencrypted\">Unencrypted</string>\n    <string name=\"encryption_choice_otr\">OTR</string>\n    <string name=\"encryption_choice_pgp\">OpenPGP</string>\n    <string name=\"encryption_choice_omemo\">OMEMO</string>\n    <string name=\"mgmt_account_delete\">Delete account</string>\n    <string name=\"mgmt_account_disable\">Temporarily disable</string>\n    <string name=\"mgmt_account_publish_avatar\">Publish avatar</string>\n    <string name=\"mgmt_account_publish_pgp\">Publish OpenPGP public key</string>\n    <string name=\"unpublish_pgp\">Remove OpenPGP public key</string>\n    <string name=\"unpublish_pgp_message\">Are you sure you want to remove your OpenPGP public key from your presence announcement?\\nYour contacts will no longer be able to send you OpenPGP encrypted messages.</string>\n    <string name=\"openpgp_has_been_published\">OpenPGP public key has been published.</string>\n    <string name=\"mgmt_account_enable\">Enable account</string>\n    <string name=\"mgmt_account_are_you_sure\">Are you sure?</string>\n    <string name=\"mgmt_account_delete_confirm_text\">If you delete your account, your entire conversation history will be lost</string>\n    <string name=\"attach_record_voice\">Record voice</string>\n    <string name=\"account_settings_jabber_id\">Jabber ID</string>\n    <string name=\"block_jabber_id\">Block Jabber ID</string>\n    <string name=\"account_settings_example_jabber_id\">username@example.com</string>\n    <string name=\"password\">Password</string>\n    <string name=\"invalid_jid\">This is not a valid Jabber ID</string>\n    <string name=\"error_out_of_memory\">Out of memory. Image is too large</string>\n    <string name=\"add_phone_book_text\">Do you want to add %s to your address book?</string>\n    <string name=\"server_info_show_more\">Server info</string>\n    <string name=\"server_info_mam\">XEP-0313: MAM</string>\n    <string name=\"server_info_carbon_messages\">XEP-0280: Message Carbons</string>\n    <string name=\"server_info_csi\">XEP-0352: Client State Indication</string>\n    <string name=\"server_info_blocking\">XEP-0191: Blocking Command</string>\n    <string name=\"server_info_roster_version\">XEP-0237: Roster Versioning</string>\n    <string name=\"server_info_stream_management\">XEP-0198: Stream Management</string>\n    <string name=\"server_info_pep\">XEP-0163: PEP (Avatars / OMEMO)</string>\n    <string name=\"server_info_http_upload\">XEP-0363: HTTP File Upload</string>\n    <string name=\"server_info_push\">XEP-0357: Push</string>\n    <string name=\"server_info_available\">available</string>\n    <string name=\"server_info_unavailable\">unavailable</string>\n    <string name=\"missing_public_keys\">Missing public key announcements</string>\n    <string name=\"last_seen_now\">last seen just now</string>\n    <string name=\"last_seen_min\">last seen 1 minute ago</string>\n    <string name=\"last_seen_mins\">last seen %d minutes ago</string>\n    <string name=\"last_seen_hour\">last seen 1 hour ago</string>\n    <string name=\"last_seen_hours\">last seen %d hours ago</string>\n    <string name=\"last_seen_day\">last seen 1 day ago</string>\n    <string name=\"last_seen_days\">last seen %d days ago</string>\n    <string name=\"install_openkeychain\">Encrypted message. Please install OpenKeychain to decrypt.</string>\n    <string name=\"openpgp_messages_found\">OpenPGP encrypted messages found</string>\n    <string name=\"openpgp_key_id\">OpenPGP Key ID</string>\n    <string name=\"omemo_fingerprint\">OMEMO fingerprint</string>\n    <string name=\"omemo_fingerprint_x509\">v\\\\OMEMO fingerprint</string>\n    <string name=\"omemo_fingerprint_selected_message\">OMEMO fingerprint of message</string>\n    <string name=\"omemo_fingerprint_x509_selected_message\">v\\\\OMEMO fingerprint of message</string>\n    <string name=\"other_devices\">Other devices</string>\n    <string name=\"trust_omemo_fingerprints\">Trust OMEMO Fingerprints</string>\n    <string name=\"fetching_keys\">Fetching keys\u2026</string>\n    <string name=\"done\">Done</string>\n    <string name=\"decrypt\">Decrypt</string>\n    <string name=\"conferences\">Group chats</string>\n    <string name=\"search\">Search</string>\n    <string name=\"dialog_title_create_contact\">Create Contact</string>\n    <string name=\"enter_contact\">Enter Contact</string>\n    <string name=\"join_conference\">Join group chat</string>\n    <string name=\"dialog_title_join_conference\">Join Group Chat</string>\n    <string name=\"delete_contact\">Delete contact</string>\n    <string name=\"view_contact_details\">View contact details</string>\n    <string name=\"block_contact\">Block contact</string>\n    <string name=\"unblock_contact\">Unblock contact</string>\n    <string name=\"create\">Create</string>\n    <string name=\"select\">Select</string>\n    <string name=\"contact_already_exists\">The contact already exists</string>\n    <string name=\"join\">Join</string>\n    <string name=\"conference_address\">Group chat address</string>\n    <string name=\"conference_address_example\">room@conference.example.com/nick</string>\n    <string name=\"save_as_bookmark\">Save as bookmark</string>\n    <string name=\"delete_bookmark\">Delete bookmark</string>\n    <string name=\"bookmark_already_exists\">This bookmark already exists</string>\n    <string name=\"action_edit_subject\">Edit group chat subject</string>\n    <string name=\"topic\">Topic</string>\n    <string name=\"joining_conference\">Joining group chat\u2026</string>\n    <string name=\"leave\">Leave</string>\n    <string name=\"contact_added_you\">Contact added you to contact list</string>\n    <string name=\"add_back\">Add back</string>\n    <string name=\"contact_has_read_up_to_this_point\">%s has read up to this point</string>\n    <string name=\"contacts_have_read_up_to_this_point\">%s have read up to this point</string>\n    <string name=\"contacts_and_n_more_have_read_up_to_this_point\">%1$s +%2$d more have read up to this point</string>\n    <string name=\"everyone_has_read_up_to_this_point\">Everyone has read up to this point</string>\n    <string name=\"publish\">Publish</string>\n    <string name=\"touch_to_choose_picture\">Touch avatar to select picture from gallery</string>\n    <string name=\"publishing\">Publishing\u2026</string>\n    <string name=\"error_publish_avatar_server_reject\">The server rejected your publication</string>\n    <string name=\"error_publish_avatar_converting\">Something went wrong while converting your picture</string>\n    <string name=\"error_saving_avatar\">Could not save avatar to disk</string>\n    <string name=\"or_long_press_for_default\">(Or long press to bring back default)</string>\n    <string name=\"error_publish_avatar_no_server_support\">Your server does not support the publication of avatars</string>\n    <string name=\"private_message\">whispered</string>\n    <string name=\"private_message_to\">to %s</string>\n    <string name=\"send_private_message_to\">Send private message to %s</string>\n    <string name=\"connect\">Connect</string>\n    <string name=\"account_already_exists\">This account already exists</string>\n    <string name=\"next\">Next</string>\n    <string name=\"server_info_session_established\">Current session established</string>\n    <string name=\"skip\">Skip</string>\n    <string name=\"disable_notifications\">Disable notifications</string>\n    <string name=\"enable\">Enable</string>\n    <string name=\"conference_requires_password\">Group chat requires password</string>\n    <string name=\"enter_password\">Enter password</string>\n    <string name=\"request_presence_updates\">Please request presence updates from your contact first.\\n\\n<small>This will be used to determine what client(s) your contact is using.</small></string>\n    <string name=\"request_now\">Request now</string>\n    <string name=\"ignore\">Ignore</string>\n    <string name=\"without_mutual_presence_updates\"><b>Warning:</b> Sending this without mutual presence updates could cause unexpected problems.\\n\\n<small>Go to contact details to verify your presence subscriptions.</small></string>\n    <string name=\"pref_security_settings\">Security</string>\n    <string name=\"pref_allow_message_correction\">Allow message correction</string>\n    <string name=\"pref_allow_message_correction_summary\">Allow your contacts to retroactively edit their messages</string>\n    <string name=\"pref_expert_options\">Expert settings</string>\n    <string name=\"pref_expert_options_summary\">Please be careful with these</string>\n    <string name=\"title_activity_about\">About Conversations</string>\n    <string name=\"pref_about_conversations_summary\">Build and licensing information</string>\n    <string name=\"title_pref_quiet_hours\">Quiet Hours</string>\n    <string name=\"title_pref_quiet_hours_start_time\">Start time</string>\n    <string name=\"title_pref_quiet_hours_end_time\">End time</string>\n    <string name=\"title_pref_enable_quiet_hours\">Enable quiet hours</string>\n    <string name=\"pref_quiet_hours_summary\">Notifications will be silenced during quiet hours</string>\n    <string name=\"pref_use_send_button_to_indicate_status\">Send button indicates status</string>\n    <string name=\"pref_use_indicate_received\">Request message receipts</string>\n    <string name=\"pref_use_indicate_received_summary\">Received messages will be marked with a green tick if supported</string>\n    <string name=\"pref_use_send_button_to_indicate_status_summary\">Colorize send button to indicate contact status</string>\n    <string name=\"pref_expert_options_other\">Other</string>\n    <string name=\"pref_autojoin\">Automatically join group chats</string>\n    <string name=\"pref_autojoin_summary\">Respect the autojoin flag in group chat bookmarks</string>\n    <string name=\"toast_message_omemo_fingerprint\">OMEMO fingerprint copied to clipboard!</string>\n    <string name=\"conference_banned\">You are banned from this group chat</string>\n    <string name=\"conference_members_only\">This group chat is members only</string>\n    <string name=\"conference_resource_constraint\">Resource constraint</string>\n    <string name=\"conference_kicked\">You have been kicked from this group chat</string>\n    <string name=\"conference_shutdown\">The group chat was shut down</string>\n    <string name=\"conference_unknown_error\">You are no longer in this group chat</string>\n    <string name=\"using_account\">using account %s</string>\n    <string name=\"checking_x\">Checking %s on HTTP host</string>\n    <string name=\"not_connected_try_again\">You are not connected. Try again later</string>\n    <string name=\"check_x_filesize\">Check %s size</string>\n    <string name=\"check_x_filesize_on_host\">Check %1$s size on %2$s</string>\n    <string name=\"message_options\">Message options</string>\n    <string name=\"quote\">Quote</string>\n    <string name=\"paste_as_quote\">Paste as quote</string>\n    <string name=\"copy_original_url\">Copy original URL</string>\n    <string name=\"send_again\">Send again</string>\n    <string name=\"file_url\">File URL</string>\n    <string name=\"url_copied_to_clipboard\">Copied URL to clipboard</string>\n    <string name=\"jabber_id_copied_to_clipboard\">Copied Jabberd ID to clipboard</string>\n    <string name=\"web_address\">web address</string>\n    <string name=\"scan_qr_code\">Scan 2D Barcode</string>\n    <string name=\"show_qr_code\">Show 2D Barcode</string>\n    <string name=\"show_block_list\">Show block list</string>\n    <string name=\"account_details\">Account details</string>\n    <string name=\"confirm\">Confirm</string>\n    <string name=\"try_again\">Try again</string>\n    <string name=\"conversations_foreground_service\">Conversations</string>\n    <string name=\"pref_keep_foreground_service\">Keep service in foreground</string>\n    <string name=\"pref_keep_foreground_service_summary\">Prevents the operating system from killing your connection</string>\n    <string name=\"pref_export_logs\">Export history</string>\n    <string name=\"pref_export_logs_summary\">Write conversations history logs to SD card</string>\n    <string name=\"notification_export_logs_title\">Writing logs to SD card</string>\n    <string name=\"choose_file\">Choose file</string>\n    <string name=\"receiving_x_file\">Receiving %1$s (%2$d%% completed)</string>\n    <string name=\"download_x_file\">Download %s</string>\n    <string name=\"delete_x_file\">Delete %s</string>\n    <string name=\"file\">file</string>\n    <string name=\"open_x_file\">Open %s</string>\n    <string name=\"sending_file\">sending (%1$d%% completed)</string>\n    <string name=\"preparing_file\">Preparing file for transmission</string>\n    <string name=\"x_file_offered_for_download\">%s offered for download</string>\n    <string name=\"cancel_transmission\">Cancel transmission</string>\n    <string name=\"file_transmission_failed\">file transmission failed</string>\n    <string name=\"file_deleted\">The file has been deleted</string>\n    <string name=\"no_application_found_to_open_file\">No application found to open file</string>\n    <string name=\"no_application_found_to_open_link\">No application found to open link</string>\n    <string name=\"no_application_found_to_view_contact\">No application found to view contact</string>\n    <string name=\"pref_show_dynamic_tags\">Dynamic Tags</string>\n    <string name=\"pref_show_dynamic_tags_summary\">Display read-only tags underneath contacts</string>\n    <string name=\"enable_notifications\">Enable notifications</string>\n    <string name=\"no_conference_server_found\">No group chat server found</string>\n    <string name=\"conference_creation_failed\">Group chat creation failed!</string>\n    <string name=\"account_image_description\">Account avatar</string>\n    <string name=\"copy_omemo_clipboard_description\">Copy OMEMO fingerprint to clipboard</string>\n    <string name=\"regenerate_omemo_key\">Regenerate OMEMO key</string>\n    <string name=\"clear_other_devices\">Clear devices</string>\n    <string name=\"clear_other_devices_desc\">Are you sure you want to clear all other devices from the OMEMO announcement? The next time your devices connect, they will reannounce themselves, but they might not receive messages sent in the meantime.</string>\n    <string name=\"error_no_keys_to_trust_server_error\">There are no usable keys available for this contact.\\nFetching new keys from the server has been unsuccessful. Maybe there is something wrong with your contact\u2019s server.</string>\n    <string name=\"error_no_keys_to_trust_presence\">There are no usable keys available for this contact.\\nMake sure you have mutual presence subscription.</string>\n    <string name=\"error_trustkeys_title\">Something went wrong</string>\n    <string name=\"fetching_history_from_server\">Fetching history from server</string>\n    <string name=\"no_more_history_on_server\">No more history on server</string>\n    <string name=\"updating\">Updating\u2026</string>\n    <string name=\"password_changed\">Password changed!</string>\n    <string name=\"could_not_change_password\">Could not change password</string>\n    <string name=\"change_password\">Change password</string>\n    <string name=\"current_password\">Current password</string>\n    <string name=\"new_password\">New password</string>\n    <string name=\"password_should_not_be_empty\">Password should not be empty</string>\n    <string name=\"enable_all_accounts\">Enable all accounts</string>\n    <string name=\"disable_all_accounts\">Disable all accounts</string>\n    <string name=\"perform_action_with\">Perform action with</string>\n    <string name=\"no_affiliation\">No affiliation</string>\n    <string name=\"no_role\">Offline</string>\n    <string name=\"outcast\">Outcast</string>\n    <string name=\"member\">Member</string>\n    <string name=\"advanced_mode\">Advanced mode</string>\n    <string name=\"grant_membership\">Grant membership</string>\n    <string name=\"remove_membership\">Revoke membership</string>\n    <string name=\"grant_admin_privileges\">Grant admin privileges</string>\n    <string name=\"remove_admin_privileges\">Revoke admin privileges</string>\n    <string name=\"remove_from_room\">Remove from group chat</string>\n    <string name=\"could_not_change_affiliation\">Could not change affiliation of %s</string>\n    <string name=\"ban_from_conference\">Ban from group chat</string>\n    <string name=\"removing_from_public_conference\">You are trying to remove %s from a public group chat. The only way to do that is to ban that user for ever.</string>\n    <string name=\"ban_now\">Ban now</string>\n    <string name=\"could_not_change_role\">Could not change role of %s</string>\n    <string name=\"public_conference\">Publicly accessible group chat</string>\n    <string name=\"private_conference\">Private, members only group chat</string>\n    <string name=\"conference_options\">Group chat options</string>\n    <string name=\"members_only\">Private, members only</string>\n    <string name=\"non_anonymous\">Non-anonymous</string>\n    <string name=\"moderated\">Moderated</string>\n    <string name=\"you_are_not_participating\">You are not participating</string>\n    <string name=\"modified_conference_options\">Modified group chat options!</string>\n    <string name=\"could_not_modify_conference_options\">Could not modify group chat options</string>\n    <string name=\"never\">Never</string>\n    <string name=\"until_further_notice\">Until further notice</string>\n    <string name=\"snooze\">Snooze</string>\n    <string name=\"reply\">Reply</string>\n    <string name=\"mark_as_read\">Mark as read</string>\n    <string name=\"pref_input_options\">Input</string>\n    <string name=\"pref_enter_is_send\">Enter is send</string>\n    <string name=\"pref_enter_is_send_summary\">Use enter key to send message</string>\n    <string name=\"pref_display_enter_key\">Show enter key</string>\n    <string name=\"pref_display_enter_key_summary\">Change the emoticons key to an enter key</string>\n    <string name=\"audio\">audio</string>\n    <string name=\"video\">video</string>\n    <string name=\"image\">image</string>\n    <string name=\"pdf_document\">PDF document</string>\n    <string name=\"apk\">Android App</string>\n    <string name=\"vcard\">Contact</string>\n    <string name=\"touch_to_open_conversations\">Touch to open Conversations</string>\n    <string name=\"avatar_has_been_published\">Avatar has been published!</string>\n    <string name=\"sending_x_file\">Sending %s</string>\n    <string name=\"offering_x_file\">Offering %s</string>\n    <string name=\"hide_offline\">Hide offline</string>\n    <string name=\"contact_is_typing\">%s is typing\u2026</string>\n    <string name=\"contact_has_stopped_typing\">%s has stopped typing</string>\n    <string name=\"contacts_are_typing\">%s are typing\u2026</string>\n    <string name=\"contacts_have_stopped_typing\">%s have stopped typing</string>\n    <string name=\"pref_chat_states\">Typing notifications</string>\n    <string name=\"pref_chat_states_summary\">Let your contacts know when you are writing messages to them</string>\n    <string name=\"send_location\">Send location</string>\n    <string name=\"show_location\">Show location</string>\n    <string name=\"no_application_found_to_display_location\">No application found to display location</string>\n    <string name=\"location\">Location</string>\n    <string name=\"title_undo_swipe_out_conversation\">Conversation closed</string>\n    <string name=\"title_undo_swipe_out_muc\">Left group chat</string>\n    <string name=\"pref_dont_trust_system_cas_title\">Don\u2019t trust system CAs</string>\n    <string name=\"pref_dont_trust_system_cas_summary\">All certificates must be manually approved</string>\n    <string name=\"pref_remove_trusted_certificates_title\">Remove certificates</string>\n    <string name=\"pref_remove_trusted_certificates_summary\">Delete manually approved certificates</string>\n    <string name=\"toast_no_trusted_certs\">No manually approved certificates</string>\n    <string name=\"dialog_manage_certs_title\">Remove certificates</string>\n    <string name=\"dialog_manage_certs_positivebutton\">Delete selection</string>\n    <string name=\"dialog_manage_certs_negativebutton\">Cancel</string>\n    <plurals name=\"toast_delete_certificates\">\n        <item quantity=\"one\">%d certificate deleted</item>\n        <item quantity=\"other\">%d certificates deleted</item>\n    </plurals>\n    <string name=\"pref_quick_action_summary\">Replace send button with quick action</string>\n    <string name=\"pref_quick_action\">Quick Action</string>\n    <string name=\"none\">None</string>\n    <string name=\"recently_used\">Most recently used</string>\n    <string name=\"choose_quick_action\">Choose quick action</string>\n    <string name=\"search_contacts\">Search contacts</string>\n    <string name=\"search_groups\">Search group chats</string>\n    <string name=\"send_private_message\">Send private message</string>\n    <string name=\"user_has_left_conference\">%1$s has left the group chat!</string>\n    <string name=\"username\">Username</string>\n    <string name=\"username_hint\">Username</string>\n    <string name=\"invalid_username\">This is not a valid username</string>\n    <string name=\"download_failed_server_not_found\">Download failed: Server not found</string>\n    <string name=\"download_failed_file_not_found\">Download failed: File not found</string>\n    <string name=\"download_failed_could_not_connect\">Download failed: Could not connect to host</string>\n    <string name=\"download_failed_could_not_write_file\">Download failed: Could not write file</string>\n    <string name=\"account_status_tor_unavailable\">Tor network unavailable</string>\n    <string name=\"account_status_bind_failure\">Bind failure</string>\n    <string name=\"account_status_host_unknown\">Server not responsible for domain</string>\n    <string name=\"server_info_broken\">Broken</string>\n    <string name=\"pref_presence_settings\">Availability</string>\n    <string name=\"pref_away_when_screen_off\">Away when screen is off</string>\n    <string name=\"pref_away_when_screen_off_summary\">Marks your resource as away when the screen is turned off</string>\n    <string name=\"pref_dnd_on_silent_mode\">\u201cDo not disturb\u201d in silent mode</string>\n    <string name=\"pref_dnd_on_silent_mode_summary\">Marks your resource as \u201cDo not disturb\u201d when device is in silent mode</string>\n    <string name=\"pref_treat_vibrate_as_silent\">Treat vibrate as silent mode</string>\n    <string name=\"pref_treat_vibrate_as_dnd_summary\">Marks your resource as \u201cDo not disturb\u201d when device is on vibrate</string>\n    <string name=\"pref_show_connection_options\">Extended connection settings</string>\n    <string name=\"pref_show_connection_options_summary\">Show hostname and port settings when setting up an account</string>\n    <string name=\"hostname_example\">xmpp.example.com</string>\n    <string name=\"action_add_account_with_certificate\">Add account with certificate</string>\n    <string name=\"unable_to_parse_certificate\">Unable to parse certificate</string>\n    <string name=\"authenticate_with_certificate\">Leave empty to authenticate w/ certificate</string>\n    <string name=\"mam_prefs\">Archiving preferences</string>\n    <string name=\"server_side_mam_prefs\">Server-side archiving preferences</string>\n    <string name=\"fetching_mam_prefs\">Fetching archiving preferences. Please wait\u2026</string>\n    <string name=\"unable_to_fetch_mam_prefs\">Unable to fetch archiving preferences</string>\n    <string name=\"captcha_required\">Captcha required</string>\n    <string name=\"captcha_hint\">Enter the text from the image above</string>\n    <string name=\"certificate_chain_is_not_trusted\">Certificate chain is not trusted</string>\n    <string name=\"jid_does_not_match_certificate\">Jabber ID does not match certificate</string>\n    <string name=\"action_renew_certificate\">Renew certificate</string>\n    <string name=\"error_fetching_omemo_key\">Error fetching OMEMO key!</string>\n    <string name=\"verified_omemo_key_with_certificate\">Verified OMEMO key with certificate!</string>\n    <string name=\"device_does_not_support_certificates\">Your device does not support the selection of client certificates!</string>\n    <string name=\"pref_connection_options\">Connection</string>\n    <string name=\"pref_use_tor\">Connect via Tor</string>\n    <string name=\"pref_use_tor_summary\">Tunnel all connections through the Tor network. Requires Orbot</string>\n    <string name=\"account_settings_hostname\">Hostname</string>\n    <string name=\"account_settings_port\">Port</string>\n    <string name=\"hostname_or_onion\">Server- or .onion-Address</string>\n    <string name=\"not_a_valid_port\">This is not a valid port number</string>\n    <string name=\"not_valid_hostname\">This is not a valid hostname</string>\n    <string name=\"connected_accounts\">%1$d of %2$d accounts connected</string>\n    <plurals name=\"x_messages\">\n        <item quantity=\"one\">%d message</item>\n        <item quantity=\"other\">%d messages</item>\n    </plurals>\n    <string name=\"load_more_messages\">Load more messages</string>\n    <string name=\"shared_file_with_x\">Shared file with %s</string>\n    <string name=\"shared_image_with_x\">Shared image with %s</string>\n    <string name=\"shared_images_with_x\">Shared images with %s</string>\n    <string name=\"shared_text_with_x\">Shared text with %s</string>\n    <string name=\"no_storage_permission\">Conversations needs access to external storage</string>\n    <string name=\"no_camera_permission\">Conversations needs access to the camera</string>\n    <string name=\"sync_with_contacts\">Synchronize with contacts</string>\n    <string name=\"sync_with_contacts_long\">Conversations wants to match your XMPP roster with your contacts to show their full names and avatars.\\n\\nConversations will only read your contacts and match them locally without uploading them to your server.\\n\\nYou will now be asked to grant permission to access your contacts.</string>\n    <string name=\"notify_on_all_messages\">Notify on all messages</string>\n    <string name=\"notify_only_when_highlighted\">Notify only when mentioned</string>\n    <string name=\"notify_never\">Notifications disabled</string>\n    <string name=\"notify_paused\">Notifications paused</string>\n    <string name=\"pref_picture_compression\">Image Compression</string>\n    <string name=\"pref_picture_compression_summary\">Resize and compress images</string>\n    <string name=\"always\">Always</string>\n    <string name=\"automatically\">Automatically</string>\n    <string name=\"battery_optimizations_enabled\">Battery optimizations enabled</string>\n    <string name=\"battery_optimizations_enabled_explained\">Your device is doing some heavy battery optimizations on Conversations that might lead to delayed notifications or even message loss.\\nIt is recommended to disable those.</string>\n    <string name=\"battery_optimizations_enabled_dialog\">Your device is doing some heavy battery optimizations on Conversations that might lead to delayed notifications or even message loss.\\n\\nYou will now be asked to disable those.</string>\n    <string name=\"disable\">Disable</string>\n    <string name=\"selection_too_large\">The selected area is too large</string>\n    <string name=\"no_accounts\">(No activated accounts)</string>\n    <string name=\"this_field_is_required\">This field is required</string>\n    <string name=\"correct_message\">Correct message</string>\n    <string name=\"send_corrected_message\">Send corrected message</string>\n    <string name=\"no_keys_just_confirm\">You already trust this contact. By selecting \\'done\\' you are just confirming that %s is part of this group chat.</string>\n    <string name=\"this_account_is_disabled\">You have disabled this account</string>\n    <string name=\"security_error_invalid_file_access\">Security error: Invalid file access</string>\n    <string name=\"no_application_to_share_uri\">No application found to share URI</string>\n    <string name=\"share_uri_with\">Share URI with\u2026</string>\n    <string name=\"welcome_header\" translatable=\"false\">Join the Conversation</string>\n    <string name=\"welcome_text\">Jabber is a provider independent instant messaging network. You can use this client with what ever Jabber server you choose.\\nHowever for your convenience we made it easy to create an account on conversations.im\u00b9; a provider specially suited for the use with Conversations.</string>\n    <string name=\"magic_create_text\">We will guide you through the process of creating an account on conversations.im.\u00b9\\nWhen picking conversations.im as a provider you will be able to communicate with users of other providers by giving them your full Jabber ID.</string>\n    <string name=\"your_full_jid_will_be\">Your full Jabber ID will be: %s</string>\n    <string name=\"create_account\">Create Account</string>\n    <string name=\"use_own_provider\">Use my own provider</string>\n    <string name=\"pick_your_username\">Pick your username</string>\n    <string name=\"pref_manually_change_presence\">Manage availability manually</string>\n    <string name=\"pref_manually_change_presence_summary\">Set your availability when editing your status message.</string>\n    <string name=\"status_message\">Status message</string>\n    <string name=\"presence_chat\">Free for Chat</string>\n    <string name=\"presence_online\">Online</string>\n    <string name=\"presence_away\">Away</string>\n    <string name=\"presence_xa\">Not Available</string>\n    <string name=\"presence_dnd\">Busy</string>\n    <string name=\"secure_password_generated\">A secure password has been generated</string>\n    <string name=\"device_does_not_support_battery_op\">Your device does not support opting out of battery optimization</string>\n    <string name=\"registration_please_wait\">Registration failed: Try again later</string>\n    <string name=\"registration_password_too_weak\">Registration failed: Password too weak</string>\n    <string name=\"dialog_title_create_conference\">Create Group Chat</string>\n    <string name=\"choose_participants\">Choose participants</string>\n    <string name=\"creating_conference\">Creating group chat\u2026</string>\n    <string name=\"invite_again\">Invite again</string>\n    <string name=\"gp_disable\">Disable</string>\n    <string name=\"gp_short\">Short</string>\n    <string name=\"gp_medium\">Medium</string>\n    <string name=\"gp_long\">Long</string>\n    <string name=\"pref_broadcast_last_activity\">Broadcast Last User Interaction</string>\n    <string name=\"pref_broadcast_last_activity_summary\">Let all your contacts know when you use Conversations</string>\n    <string name=\"pref_privacy\">Privacy</string>\n    <string name=\"pref_theme_options\">Theme</string>\n    <string name=\"pref_theme_options_summary\">Select the color palette</string>\n    <string name=\"pref_theme_light\">Light theme</string>\n    <string name=\"pref_theme_dark\">Dark theme</string>\n    <string name=\"pref_use_green_background\">Green Background</string>\n    <string name=\"pref_use_green_background_summary\">Use green background for received messages</string>\n    <string name=\"unable_to_connect_to_keychain\">Unable to connect to OpenKeychain</string>\n    <string name=\"this_device_is_no_longer_in_use\">This device is no longer in use</string>\n    <string name=\"type_pc\">Computer</string>\n    <string name=\"type_phone\">Mobile phone</string>\n    <string name=\"type_tablet\">Tablet</string>\n    <string name=\"type_web\">Web browser</string>\n    <string name=\"type_console\">Console</string>\n    <string name=\"payment_required\">Payment required</string>\n    <string name=\"missing_internet_permission\">Missing internet permission</string>\n    <string name=\"me\">Me</string>\n    <string name=\"contact_asks_for_presence_subscription\">Contact asks for presence subscription</string>\n    <string name=\"allow\">Allow</string>\n    <string name=\"no_permission_to_access_x\">No permission to access %s</string>\n    <string name=\"remote_server_not_found\">Remote server not found</string>\n    <string name=\"remote_server_timeout\">Remote server timeout</string>\n    <string name=\"unable_to_update_account\">Unable to update account</string>\n    <string name=\"report_jid_as_spammer\">Report this JID as sending unwanted messages.</string>\n    <string name=\"pref_delete_omemo_identities\">Delete OMEMO identities</string>\n    <string name=\"pref_delete_omemo_identities_summary\">Regenerate your OMEMO keys. All your contacts will have to verify you again. Use this only as a last resort.</string>\n    <string name=\"delete_selected_keys\">Delete selected keys</string>\n    <string name=\"error_publish_avatar_offline\">You need to be connected to publish your avatar.</string>\n    <string name=\"show_error_message\">Show error message</string>\n    <string name=\"error_message\">Error Message</string>\n    <string name=\"data_saver_enabled\">Data saver enabled</string>\n    <string name=\"data_saver_enabled_explained\">Your operating system is restricting Conversations from accessing the Internet when in background. To receive notifications of new messages you should allow Conversations unrestricted access when Data saver is on.\\nConversations will still make an effort to save data when possible.</string>\n    <string name=\"device_does_not_support_data_saver\">Your device does not support disabling Data saver for Conversations.</string>\n    <string name=\"error_unable_to_create_temporary_file\">Unable to create temporary file</string>\n    <string name=\"this_device_has_been_verified\">This device has been verified</string>\n    <string name=\"copy_fingerprint\">Copy fingerprint</string>\n    <string name=\"all_omemo_keys_have_been_verified\">All OMEMO keys have been verified</string>\n    <string name=\"barcode_does_not_contain_fingerprints_for_this_conversation\">Barcode does not contain fingerprints for this conversation.</string>\n    <string name=\"verified_fingerprints\">Verified fingerprints</string>\n    <string name=\"use_camera_icon_to_scan_barcode\">Use the camera to scan a contact\u2019s barcode</string>\n    <string name=\"please_wait_for_keys_to_be_fetched\">Please wait for keys to be fetched</string>\n    <string name=\"share_as_barcode\">Share as Barcode</string>\n    <string name=\"share_as_uri\">Share as XMPP URI</string>\n    <string name=\"share_as_http\">Share as HTTP link</string>\n    <string name=\"pref_blind_trust_before_verification\">Blind Trust Before Verification</string>\n    <string name=\"pref_blind_trust_before_verification_summary\">Automatically trust all new devices of contacts that haven\u2019t been verified before, and prompt for manual confirmation each time a verified contact adds a new device.</string>\n    <string name=\"blindly_trusted_omemo_keys\">Blindly trusted OMEMO keys</string>\n    <string name=\"not_trusted\">Untrusted</string>\n    <string name=\"invalid_barcode\">Invalid 2D barcode</string>\n    <string name=\"pref_clean_cache_summary\">Clean cache folder (used by Camera Application)</string>\n    <string name=\"pref_clean_cache\">Clean cache</string>\n    <string name=\"pref_clean_private_storage\">Clean private storage</string>\n    <string name=\"pref_clean_private_storage_summary\">Clean private storage where files are kept (They can be re-downloaded from the server)</string>\n    <string name=\"i_followed_this_link_from_a_trusted_source\">I followed this link from a trusted source</string>\n    <string name=\"verifying_omemo_keys_trusted_source\">You are about to verify the OMEMO keys of %1$s after clicking a link. This is only secure if you followed this link from a trusted source where only %2$s could have published this link.</string>\n    <string name=\"verify_omemo_keys\">Verify OMEMO keys</string>\n    <string name=\"show_inactive_devices\">Show inactive</string>\n    <string name=\"hide_inactive_devices\">Hide inactive</string>\n    <string name=\"distrust_omemo_key\">Distrust device</string>\n    <string name=\"distrust_omemo_key_text\">Are you sure you want to remove the verification for this device?\\nThis device and messages coming from that device will be marked as untrusted.</string>\n    <plurals name=\"seconds\">\n        <item quantity=\"one\">%d second</item>\n        <item quantity=\"other\">%d seconds</item>\n    </plurals>\n    <plurals name=\"minutes\">\n        <item quantity=\"one\">%d minute</item>\n        <item quantity=\"other\">%d minutes</item>\n    </plurals>\n    <plurals name=\"hours\">\n        <item quantity=\"one\">%d hour</item>\n        <item quantity=\"other\">%d hours</item>\n    </plurals>\n    <plurals name=\"days\">\n        <item quantity=\"one\">%d day</item>\n        <item quantity=\"other\">%d days</item>\n    </plurals>\n    <plurals name=\"weeks\">\n        <item quantity=\"one\">%d week</item>\n        <item quantity=\"other\">%d weeks</item>\n    </plurals>\n    <plurals name=\"months\">\n        <item quantity=\"one\">%d month</item>\n        <item quantity=\"other\">%d months</item>\n    </plurals>\n    <string name=\"pref_automatically_delete_messages\">Automatic message deletion</string>\n    <string name=\"pref_automatically_delete_messages_description\">Automatically delete messages from this device that are older than the configured time frame.</string>\n    <string name=\"encrypting_message\">Encrypting message</string>\n    <string name=\"not_fetching_history_retention_period\">Not fetching messages due to local retention period.</string>\n    <string name=\"transcoding_video\">Compressing video</string>\n    <string name=\"corresponding_conversations_closed\">Corresponding conversations closed.</string>\n    <string name=\"contact_blocked_past_tense\">Contact blocked.</string>\n    <string name=\"pref_notifications_from_strangers\">Notifications from strangers</string>\n    <string name=\"pref_notifications_from_strangers_summary\">Notify for messages received from strangers.</string>\n    <string name=\"received_message_from_stranger\">Received message from stranger</string>\n    <string name=\"block_stranger\">Block stranger</string>\n    <string name=\"block_entire_domain\">Block entire domain</string>\n    <string name=\"online_right_now\">online right now</string>\n    <string name=\"retry_decryption\">Retry decryption</string>\n    <string name=\"session_failure\">Session failure</string>\n    <string name=\"sasl_downgrade\">Downgraded SASL mechanism</string>\n    <string name=\"account_status_regis_web\">Server requires registration on website</string>\n    <string name=\"open_website\">Open website</string>\n    <string name=\"application_found_to_open_website\">No application found to open website</string>\n    <string name=\"pref_headsup_notifications\">Heads-up Notifications</string>\n    <string name=\"pref_headsup_notifications_summary\">Show Heads-up Notifications</string>\n    <string name=\"today\">Today</string>\n    <string name=\"yesterday\">Yesterday</string>\n    <string name=\"pref_validate_hostname\">Validate hostname with DNSSEC</string>\n    <string name=\"pref_validate_hostname_summary\">Server certificates that contain the validated hostname are considered verified</string>\n    <string name=\"certificate_does_not_contain_jid\">Certificate does not contain a Jabber ID</string>\n    <string name=\"server_info_partial\">partial</string>\n    <string name=\"attach_record_video\">Record video</string>\n    <string name=\"copy_to_clipboard\">Copy to clipboard</string>\n    <string name=\"message_copied_to_clipboard\">Message copied to clipboard</string>\n    <string name=\"message\">Message</string>\n    <string name=\"private_messages_are_disabled\">Private messages are disabled</string>\n    <string name=\"huawei_protected_apps\">Protected Apps</string>\n    <string name=\"huawei_protected_apps_summary\">To keep receiving notifications, even when the screen is turned off, you need to add Conversations to the list of protected apps.</string>\n    <string name=\"mtm_accept_cert\">Accept Unknown Certificate?</string>\n    <string name=\"mtm_trust_anchor\">The server certificate is not signed by a known Certificate Authority.</string>\n    <string name=\"mtm_accept_servername\">Accept Mismatching Server Name?</string>\n    <string name=\"mtm_hostname_mismatch\">Server could not authenticate as \\&quot;%s\\&quot;. The certificate is only valid for:</string>\n    <string name=\"mtm_connect_anyway\">Do you want to connect anyway?</string>\n    <string name=\"mtm_cert_details\">Certificate details:</string>\n    <string name=\"once\">Once</string>\n    <string name=\"qr_code_scanner_needs_access_to_camera\">The QR code scanner needs access to the camera</string>\n    <string name=\"pref_scroll_to_bottom\">Scroll to bottom</string>\n    <string name=\"pref_scroll_to_bottom_summary\">Scroll down after sending a message</string>\n    <string name=\"edit_status_message_title\">Edit Status Message</string>\n    <string name=\"edit_status_message\">Edit status message</string>\n    <string name=\"disable_encryption\">Disable encryption</string>\n    <string name=\"error_trustkey_general\">Conversations is unable to send encrypted messages to %1$s. This may be due to your contact using an outdated server or client that can not handle OMEMO.</string>\n    <string name=\"error_trustkey_device_list\">Unable to fetch device list</string>\n    <string name=\"error_trustkey_bundle\">Unable to fetch device bundles</string>\n    <string name=\"error_trustkey_hint_mutual\">Hint: In some cases this can be fixed by adding each other your contact lists.</string>\n    <string name=\"disable_encryption_message\">Are you sure you want to disable OMEMO encryption for this conversation?\\nThis will allow your server administrator to read your messages, but it might be the only way to communicate with people using outdated clients.</string>\n    <string name=\"disable_now\">Disable now</string>\n    <string name=\"draft\">Draft:</string>\n    <string name=\"pref_omemo_setting\">OMEMO Encryption</string>\n    <string name=\"pref_omemo_setting_summary_always\">OMEMO will always be used for one-on-one and private group chats.</string>\n    <string name=\"pref_omemo_setting_summary_default_on\">OMEMO will be used by default for new conversations.</string>\n    <string name=\"pref_omemo_setting_summary_default_off\">OMEMO will have to be turned on explicitly for new conversations.</string>\n    <string name=\"create_shortcut\">Create Shortcut</string>\n    <string name=\"pref_font_size\">Font Size</string>\n    <string name=\"pref_font_size_summary\">The relative font size used within the app.</string>\n    <string name=\"default_on\">On by default</string>\n    <string name=\"default_off\">Off by default</string>\n    <string name=\"small\">Small</string>\n    <string name=\"medium\">Medium</string>\n    <string name=\"large\">Large</string>\n    <string name=\"not_encrypted_for_this_device\">Message was not encrypted for this device.</string>\n    <string name=\"undo\">undo</string>\n    <string name=\"location_disabled\">Location sharing is disabled</string>\n    <string name=\"action_fix_to_location\">Fix position</string>\n    <string name=\"action_unfix_from_location\">Unfix position</string>\n    <string name=\"action_copy_location\">Copy Location</string>\n    <string name=\"action_share_location\">Share Location</string>\n    <string name=\"action_directions\">Directions</string>\n    <string name=\"title_activity_share_location\">Share location</string>\n    <string name=\"title_activity_show_location\">Show location</string>\n    <string name=\"share\">Share</string>\n    <string name=\"unable_to_start_recording\">Unable to start recording</string>\n    <string name=\"please_wait\">Please wait\u2026</string>\n    <string name=\"no_microphone_permission\">Conversations needs access to the microphone</string>\n    <string name=\"search_messages\">Search messages</string>\n    <string name=\"gif\">GIF</string>\n    <string name=\"view_conversation\">View conversation</string>\n    <string name=\"pref_use_share_location_plugin\">Share Location Plugin</string>\n    <string name=\"pref_use_share_location_plugin_summary\">Use the Share Location Plugin instead of the build in map</string>\n    <string name=\"copy_link\">Copy web address</string>\n    <string name=\"copy_jabber_id\">Copy Jabber ID</string>\n    <string name=\"p1_s3_filetransfer\">HTTP File Sharing for S3</string>\n    <string name=\"pref_start_search\">Direct Search</string>\n    <string name=\"pref_start_search_summary\">At \u2018Start Conversation\u2019 screen open keyboard and place cursor in search field</string>\n    <string name=\"group_chat_avatar\">Group chat avatar</string>\n    <string name=\"host_does_not_support_group_chat_avatars\">Host does not support group chat avatars</string>\n    <string name=\"only_the_owner_can_change_group_chat_avatar\">Only the owner can change group chat avatar</string>\n    <string name=\"contact_name\">Contact name</string>\n    <string name=\"nickname\">Nickname</string>\n    <string name=\"group_chat_name\">Name</string>\n    <string name=\"providing_a_name_is_optional\">Providing a name is optional</string>\n    <string name=\"create_dialog_group_chat_name\">Group chat name</string>\n    <string name=\"conference_destroyed\">This group chat has been destroyed</string>\n    <string name=\"phone_book\">Address book</string>\n    <string name=\"unable_to_save_recording\">Unable to save recording</string>\n    <string name=\"foreground_service_channel_name\">Foreground service</string>\n    <string name=\"foreground_service_channel_description\">This notification category is used to display a permanent notification indicating that Conversations is running.</string>\n    <string name=\"notification_group_status_information\">Status Information</string>\n    <string name=\"error_channel_name\">Connectivity Problems</string>\n    <string name=\"error_channel_description\">This notification category is used to display a notification in case there is a problem connecting to an account.</string>\n    <string name=\"notification_group_messages\">Messages</string>\n    <string name=\"messages_channel_name\">Messages</string>\n    <string name=\"silent_messages_channel_name\">Silent messages</string>\n    <string name=\"silent_messages_channel_description\">This notification group is used to display notifications that should not trigger any sound. For example when being active on another device (Grace Period).</string>\n    <string name=\"pref_more_notification_settings\">Notification Settings</string>\n    <string name=\"pref_more_notification_settings_summary\">Importance, Sound, Vibrate</string>\n    <string name=\"video_compression_channel_name\">Video compression</string>\n    <string name=\"view_media\">View media</string>\n    <string name=\"media_browser\">Media browser</string>\n    <string name=\"export_channel_name\">History export</string>\n    <string name=\"security_violation_not_attaching_file\">File omitted due to security violation.</string>\n    <string name=\"pref_video_compression\">Video Quality</string>\n    <string name=\"pref_video_compression_summary\">Lower quality means smaller files</string>\n    <string name=\"video_360p\">Medium (360p)</string>\n    <string name=\"video_720p\">High (720p)</string>\n    <string name=\"cancelled\">cancelled</string>\n    <string name=\"already_drafting_message\">You are already drafting a message.</string>\n</resources>\n"], "buggy_code_start_loc": [29, 94, 490, 456, 748], "buggy_code_end_loc": [2553, 94, 831, 483, 748], "fixing_code_start_loc": [30, 95, 490, 456, 749], "fixing_code_end_loc": [2560, 96, 834, 491, 750], "type": "CWE-200", "message": "An issue was discovered in Daniel Gultsch Conversations 2.3.4. It is possible to spoof a custom message to an existing opened conversation by sending an intent.", "other": {"cve": {"id": "CVE-2018-18467", "sourceIdentifier": "cve@mitre.org", "published": "2018-10-23T21:30:54.253", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Daniel Gultsch Conversations 2.3.4. It is possible to spoof a custom message to an existing opened conversation by sending an intent."}, {"lang": "es", "value": "Se ha descubierto un problema en Daniel Gultsch Conversations 2.3.4. Es posible suplantar un mensaje personalizado para una conversaci\u00f3n abierta existente mediante el env\u00edo de un intent."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:conversations:conversations:2.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "3CAE1876-D0B5-427A-B799-2FCD08BEFB96"}]}]}], "references": [{"url": "https://github.com/siacs/Conversations/commit/7177c523a1b31988666b9337249a4f1d0c36f479", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/siacs/Conversations/commit/7177c523a1b31988666b9337249a4f1d0c36f479"}}