{"buggy_code": ["/*\nCopyright 2019 The Crossplane Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage fieldpath\n\nimport (\n\t\"strconv\"\n\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/util/json\"\n\n\t\"github.com/crossplane/crossplane-runtime/pkg/errors\"\n)\n\ntype errNotFound struct {\n\terror\n}\n\nfunc (e errNotFound) IsNotFound() bool {\n\treturn true\n}\n\n// IsNotFound returns true if the supplied error indicates a field path was not\n// found, for example because a field did not exist within an object or an\n// index was out of bounds in an array.\nfunc IsNotFound(err error) bool {\n\tcause := errors.Cause(err)\n\t_, ok := cause.(interface { //nolint: errorlint // Skip errorlint for interface type\n\t\tIsNotFound() bool\n\t})\n\treturn ok\n}\n\n// A Paved JSON object supports getting and setting values by their field path.\ntype Paved struct {\n\tobject map[string]any\n}\n\n// PaveObject paves a runtime.Object, making it possible to get and set values\n// by field path. o must be a non-nil pointer to an object.\nfunc PaveObject(o runtime.Object) (*Paved, error) {\n\tu, err := runtime.DefaultUnstructuredConverter.ToUnstructured(o)\n\treturn Pave(u), errors.Wrap(err, \"cannot convert object to unstructured data\")\n}\n\n// Pave a JSON object, making it possible to get and set values by field path.\nfunc Pave(object map[string]any) *Paved {\n\treturn &Paved{object: object}\n}\n\n// MarshalJSON to the underlying object.\nfunc (p Paved) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(p.object)\n}\n\n// UnmarshalJSON from the underlying object.\nfunc (p *Paved) UnmarshalJSON(data []byte) error {\n\treturn json.Unmarshal(data, &p.object)\n}\n\n// UnstructuredContent returns the JSON serialisable content of this Paved.\nfunc (p *Paved) UnstructuredContent() map[string]any {\n\tif p.object == nil {\n\t\treturn make(map[string]any)\n\t}\n\treturn p.object\n}\n\n// SetUnstructuredContent sets the JSON serialisable content of this Paved.\nfunc (p *Paved) SetUnstructuredContent(content map[string]any) {\n\tp.object = content\n}\n\nfunc (p *Paved) getValue(s Segments) (any, error) {\n\treturn getValueFromInterface(p.object, s)\n}\n\nfunc getValueFromInterface(it any, s Segments) (any, error) {\n\tfor i, current := range s {\n\t\tfinal := i == len(s)-1\n\t\tswitch current.Type {\n\t\tcase SegmentIndex:\n\t\t\tarray, ok := it.([]any)\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.Errorf(\"%s: not an array\", s[:i])\n\t\t\t}\n\t\t\tif int(current.Index) >= len(array) {\n\t\t\t\treturn nil, errNotFound{errors.Errorf(\"%s: no such element\", s[:i+1])}\n\t\t\t}\n\t\t\tif final {\n\t\t\t\treturn array[current.Index], nil\n\t\t\t}\n\t\t\tit = array[current.Index]\n\t\tcase SegmentField:\n\t\t\tobject, ok := it.(map[string]any)\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.Errorf(\"%s: not an object\", s[:i])\n\t\t\t}\n\t\t\tv, ok := object[current.Field]\n\t\t\tif !ok {\n\t\t\t\treturn nil, errNotFound{errors.Errorf(\"%s: no such field\", s[:i+1])}\n\t\t\t}\n\t\t\tif final {\n\t\t\t\treturn v, nil\n\t\t\t}\n\t\t\tit = object[current.Field]\n\t\t}\n\t}\n\n\t// This should be unreachable.\n\treturn nil, nil\n}\n\n// ExpandWildcards expands wildcards for a given field path. It returns an\n// array of field paths with expanded values. Please note that expanded paths\n// depend on the input data which is paved.object.\n//\n// Example:\n//\n// For a Paved object with the following data: []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\", \"image\": \"latest\", \"args\": [\"start\", \"now\", \"debug\"]}]}}`),\n// ExpandWildcards(\"spec.containers[*].args[*]\") returns:\n// []string{\"spec.containers[0].args[0]\", \"spec.containers[0].args[1]\", \"spec.containers[0].args[2]\"},\nfunc (p *Paved) ExpandWildcards(path string) ([]string, error) {\n\tsegments, err := Parse(path)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"cannot parse path %q\", path)\n\t}\n\tsegmentsArray, err := expandWildcards(p.object, segments)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"cannot expand wildcards for segments: %q\", segments)\n\t}\n\tpaths := make([]string, len(segmentsArray))\n\tfor i, s := range segmentsArray {\n\t\tpaths[i] = s.String()\n\t}\n\treturn paths, nil\n}\n\nfunc expandWildcards(data any, segments Segments) ([]Segments, error) { //nolint:gocyclo // See note below.\n\t// Even complexity turns out to be high, it is mostly because we have duplicate\n\t// logic for arrays and maps and a couple of error handling.\n\tvar res []Segments\n\tit := data\n\tfor i, current := range segments {\n\t\t// wildcards are regular fields with \"*\" as string\n\t\tif current.Type == SegmentField && current.Field == wildcard {\n\t\t\tswitch mapOrArray := it.(type) {\n\t\t\tcase []any:\n\t\t\t\tfor ix := range mapOrArray {\n\t\t\t\t\texpanded := make(Segments, len(segments))\n\t\t\t\t\tcopy(expanded, segments)\n\t\t\t\t\texpanded = append(append(expanded[:i], FieldOrIndex(strconv.Itoa(ix))), expanded[i+1:]...)\n\t\t\t\t\tr, err := expandWildcards(data, expanded)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, errors.Wrapf(err, \"%q: cannot expand wildcards\", expanded)\n\t\t\t\t\t}\n\t\t\t\t\tres = append(res, r...)\n\t\t\t\t}\n\t\t\tcase map[string]any:\n\t\t\t\tfor k := range mapOrArray {\n\t\t\t\t\texpanded := make(Segments, len(segments))\n\t\t\t\t\tcopy(expanded, segments)\n\t\t\t\t\texpanded = append(append(expanded[:i], Field(k)), expanded[i+1:]...)\n\t\t\t\t\tr, err := expandWildcards(data, expanded)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, errors.Wrapf(err, \"%q: cannot expand wildcards\", expanded)\n\t\t\t\t\t}\n\t\t\t\t\tres = append(res, r...)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn nil, errors.Errorf(\"%q: unexpected wildcard usage\", segments[:i])\n\t\t\t}\n\t\t\treturn res, nil\n\t\t}\n\t\tvar err error\n\t\tit, err = getValueFromInterface(data, segments[:i+1])\n\t\tif IsNotFound(err) {\n\t\t\treturn nil, nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn append(res, segments), nil\n}\n\n// GetValue of the supplied field path.\nfunc (p *Paved) GetValue(path string) (any, error) {\n\tsegments, err := Parse(path)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"cannot parse path %q\", path)\n\t}\n\n\treturn p.getValue(segments)\n}\n\n// GetValueInto the supplied type.\nfunc (p *Paved) GetValueInto(path string, out any) error {\n\tval, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tjs, err := json.Marshal(val)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"cannot marshal value to JSON\")\n\t}\n\treturn errors.Wrap(json.Unmarshal(js, out), \"cannot unmarshal value from JSON\")\n}\n\n// GetString value of the supplied field path.\nfunc (p *Paved) GetString(path string) (string, error) {\n\tv, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn \"\", errors.Errorf(\"%s: not a string\", path)\n\t}\n\treturn s, nil\n}\n\n// GetStringArray value of the supplied field path.\nfunc (p *Paved) GetStringArray(path string) ([]string, error) {\n\tv, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta, ok := v.([]any)\n\tif !ok {\n\t\treturn nil, errors.Errorf(\"%s: not an array\", path)\n\t}\n\n\tsa := make([]string, len(a))\n\tfor i := range a {\n\t\ts, ok := a[i].(string)\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"%s: not an array of strings\", path)\n\t\t}\n\t\tsa[i] = s\n\t}\n\n\treturn sa, nil\n}\n\n// GetStringObject value of the supplied field path.\nfunc (p *Paved) GetStringObject(path string) (map[string]string, error) {\n\tv, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\to, ok := v.(map[string]any)\n\tif !ok {\n\t\treturn nil, errors.Errorf(\"%s: not an object\", path)\n\t}\n\n\tso := make(map[string]string)\n\tfor k, in := range o {\n\t\ts, ok := in.(string)\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"%s: not an object with string field values\", path)\n\t\t}\n\t\tso[k] = s\n\n\t}\n\n\treturn so, nil\n}\n\n// GetBool value of the supplied field path.\nfunc (p *Paved) GetBool(path string) (bool, error) {\n\tv, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tb, ok := v.(bool)\n\tif !ok {\n\t\treturn false, errors.Errorf(\"%s: not a bool\", path)\n\t}\n\treturn b, nil\n}\n\n// NOTE(muvaf): If there is no CRD, unstructured.Unstructured reads numbers as\n// float64. However, in practice, use of float64 is discouraged and when you fetch\n// an instance of a CRD whose number fields are int64, you'll get int64. So,\n// it's not really possible to test this without an api-server but that's the\n// actual behavior.\n\n// GetNumber value of the supplied field path.\n// Deprecated: Use of float64 is discouraged. Please use GetInteger.\n// See https://github.com/kubernetes/community/blob/c9ae475/contributors/devel/sig-architecture/api-conventions.md#primitive-types\nfunc (p *Paved) GetNumber(path string) (float64, error) {\n\tv, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tf, ok := v.(float64)\n\tif !ok {\n\t\treturn 0, errors.Errorf(\"%s: not a (float64) number\", path)\n\t}\n\treturn f, nil\n}\n\n// GetInteger value of the supplied field path.\nfunc (p *Paved) GetInteger(path string) (int64, error) {\n\tv, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tf, ok := v.(int64)\n\tif !ok {\n\t\treturn 0, errors.Errorf(\"%s: not a (int64) number\", path)\n\t}\n\treturn f, nil\n}\n\nfunc (p *Paved) setValue(s Segments, value any) error {\n\t// We expect p.object to look like JSON data that was unmarshalled into an\n\t// any per https://golang.org/pkg/encoding/json/#Unmarshal. We\n\t// marshal our value to JSON and unmarshal it into an any to ensure\n\t// it meets these criteria before setting it within p.object.\n\tvar v any\n\tj, err := json.Marshal(value)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"cannot marshal value to JSON\")\n\t}\n\tif err := json.Unmarshal(j, &v); err != nil {\n\t\treturn errors.Wrap(err, \"cannot unmarshal value from JSON\")\n\t}\n\n\tvar in any = p.object\n\tfor i, current := range s {\n\t\tfinal := i == len(s)-1\n\n\t\tswitch current.Type {\n\t\tcase SegmentIndex:\n\t\t\tarray, ok := in.([]any)\n\t\t\tif !ok {\n\t\t\t\treturn errors.Errorf(\"%s is not an array\", s[:i])\n\t\t\t}\n\n\t\t\tif final {\n\t\t\t\tarray[current.Index] = v\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tprepareElement(array, current, s[i+1])\n\t\t\tin = array[current.Index]\n\n\t\tcase SegmentField:\n\t\t\tobject, ok := in.(map[string]any)\n\t\t\tif !ok {\n\t\t\t\treturn errors.Errorf(\"%s is not an object\", s[:i])\n\t\t\t}\n\n\t\t\tif final {\n\t\t\t\tobject[current.Field] = v\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tprepareField(object, current, s[i+1])\n\t\t\tin = object[current.Field]\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc prepareElement(array []any, current, next Segment) {\n\t// If this segment is not the final one and doesn't exist we need to\n\t// create it for our next segment.\n\tif array[current.Index] == nil {\n\t\tswitch next.Type {\n\t\tcase SegmentIndex:\n\t\t\tarray[current.Index] = make([]any, next.Index+1)\n\t\tcase SegmentField:\n\t\t\tarray[current.Index] = make(map[string]any)\n\t\t}\n\t\treturn\n\t}\n\n\t// If our next segment indexes an array that exists in our current segment's\n\t// element we must ensure the array is long enough to set the next segment.\n\tif next.Type != SegmentIndex {\n\t\treturn\n\t}\n\n\tna, ok := array[current.Index].([]any)\n\tif !ok {\n\t\treturn\n\t}\n\n\tif int(next.Index) < len(na) {\n\t\treturn\n\t}\n\n\tarray[current.Index] = append(na, make([]any, int(next.Index)-len(na)+1)...)\n}\n\nfunc prepareField(object map[string]any, current, next Segment) {\n\t// If this segment is not the final one and doesn't exist we need to\n\t// create it for our next segment.\n\tif _, ok := object[current.Field]; !ok {\n\t\tswitch next.Type {\n\t\tcase SegmentIndex:\n\t\t\tobject[current.Field] = make([]any, next.Index+1)\n\t\tcase SegmentField:\n\t\t\tobject[current.Field] = make(map[string]any)\n\t\t}\n\t\treturn\n\t}\n\n\t// If our next segment indexes an array that exists in our current segment's\n\t// field we must ensure the array is long enough to set the next segment.\n\tif next.Type != SegmentIndex {\n\t\treturn\n\t}\n\n\tna, ok := object[current.Field].([]any)\n\tif !ok {\n\t\treturn\n\t}\n\n\tif int(next.Index) < len(na) {\n\t\treturn\n\t}\n\n\tobject[current.Field] = append(na, make([]any, int(next.Index)-len(na)+1)...)\n}\n\n// SetValue at the supplied field path.\nfunc (p *Paved) SetValue(path string, value any) error {\n\tsegments, err := Parse(path)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"cannot parse path %q\", path)\n\t}\n\treturn p.setValue(segments, value)\n}\n\n// SetString value at the supplied field path.\nfunc (p *Paved) SetString(path, value string) error {\n\treturn p.SetValue(path, value)\n}\n\n// SetBool value at the supplied field path.\nfunc (p *Paved) SetBool(path string, value bool) error {\n\treturn p.SetValue(path, value)\n}\n\n// SetNumber value at the supplied field path.\nfunc (p *Paved) SetNumber(path string, value float64) error {\n\treturn p.SetValue(path, value)\n}\n\n// DeleteField deletes the field from the object.\n// If the path points to an entry in an array, the element\n// on that index is removed and the next ones are pulled\n// back. If it is a field on a map, the field is\n// removed from the map.\nfunc (p *Paved) DeleteField(path string) error {\n\tsegments, err := Parse(path)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"cannot parse path %q\", path)\n\t}\n\treturn p.delete(segments)\n}\n\nfunc (p *Paved) delete(segments Segments) error { //nolint:gocyclo // See note below.\n\t// NOTE(muvaf): I could not reduce the cyclomatic complexity\n\t// more than that without disturbing the reading flow.\n\tif len(segments) == 1 {\n\t\to, err := deleteField(p.object, segments[0])\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"cannot delete %s\", segments)\n\t\t}\n\t\tp.object = o.(map[string]any)\n\t\treturn nil\n\t}\n\tvar in any = p.object\n\tfor i, current := range segments {\n\t\t// beforeLast is true for the element before the last one because\n\t\t// slices cannot be changed in place and Go does not allow\n\t\t// taking address of map elements which prevents us from\n\t\t// assigning a new array for that entry unless we have the\n\t\t// map available in the context, which is achieved by iterating\n\t\t// until the element before the last one as opposed to\n\t\t// Set/Get functions in this file.\n\t\tbeforeLast := i == len(segments)-2\n\t\tswitch current.Type {\n\t\tcase SegmentIndex:\n\t\t\tarray, ok := in.([]any)\n\t\t\tif !ok {\n\t\t\t\treturn errors.Errorf(\"%s is not an array\", segments[:i])\n\t\t\t}\n\n\t\t\t// It doesn't exist anyway.\n\t\t\tif len(array) <= int(current.Index) {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif beforeLast {\n\t\t\t\to, err := deleteField(array[current.Index], segments[len(segments)-1])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn errors.Wrapf(err, \"cannot delete %s\", segments)\n\t\t\t\t}\n\t\t\t\tarray[current.Index] = o\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tin = array[current.Index]\n\t\tcase SegmentField:\n\t\t\tobject, ok := in.(map[string]any)\n\t\t\tif !ok {\n\t\t\t\treturn errors.Errorf(\"%s is not an object\", segments[:i])\n\t\t\t}\n\n\t\t\t// It doesn't exist anyway.\n\t\t\tif _, ok := object[current.Field]; !ok {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif beforeLast {\n\t\t\t\to, err := deleteField(object[current.Field], segments[len(segments)-1])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn errors.Wrapf(err, \"cannot delete %s\", segments)\n\t\t\t\t}\n\t\t\t\tobject[current.Field] = o\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tin = object[current.Field]\n\t\t}\n\t}\n\treturn nil\n}\n\n// deleteField deletes the object in obj pointed by\n// the given Segment and returns it. Returned object\n// may or may not have the same address in memory.\nfunc deleteField(obj any, s Segment) (any, error) {\n\tswitch s.Type {\n\tcase SegmentIndex:\n\t\tarray, ok := obj.([]any)\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"not an array\")\n\t\t}\n\t\tif len(array) == 0 || len(array) <= int(s.Index) {\n\t\t\treturn array, nil\n\t\t}\n\t\tfor i := int(s.Index); i < len(array)-1; i++ {\n\t\t\tarray[i] = array[i+1]\n\t\t}\n\t\treturn array[:len(array)-1], nil\n\tcase SegmentField:\n\t\tobject, ok := obj.(map[string]any)\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"not an object\")\n\t\t}\n\t\tdelete(object, s.Field)\n\t\treturn object, nil\n\t}\n\treturn nil, nil\n}\n", "/*\nCopyright 2019 The Crossplane Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage fieldpath\n\nimport (\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/json\"\n\n\t\"github.com/crossplane/crossplane-runtime/pkg/errors\"\n\t\"github.com/crossplane/crossplane-runtime/pkg/test\"\n)\n\nfunc TestIsNotFound(t *testing.T) {\n\tcases := map[string]struct {\n\t\treason string\n\t\terr    error\n\t\twant   bool\n\t}{\n\t\t\"NotFound\": {\n\t\t\treason: \"An error with method `IsNotFound() bool` should be considered a not found error.\",\n\t\t\terr:    errNotFound{errors.New(\"boom\")},\n\t\t\twant:   true,\n\t\t},\n\t\t\"WrapsNotFound\": {\n\t\t\treason: \"An error that wraps an error with method `IsNotFound() bool` should be considered a not found error.\",\n\t\t\terr:    errors.Wrap(errNotFound{errors.New(\"boom\")}, \"because reasons\"),\n\t\t\twant:   true,\n\t\t},\n\t\t\"SomethingElse\": {\n\t\t\treason: \"An error without method `IsNotFound() bool` should not be considered a not found error.\",\n\t\t\terr:    errors.New(\"boom\"),\n\t\t\twant:   false,\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := IsNotFound(tc.err)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"IsNotFound(...): Want %t, got %t\", tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetValue(t *testing.T) {\n\ttype want struct {\n\t\tvalue any\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"MetadataName\": {\n\t\t\treason: \"It should be possible to get a field from a nested object\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t},\n\t\t\"ContainerName\": {\n\t\t\treason: \"It should be possible to get a field from an object array element\",\n\t\t\tpath:   \"spec.containers[0].name\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t},\n\t\t\"NestedArray\": {\n\t\t\treason: \"It should be possible to get a field from a nested array\",\n\t\t\tpath:   \"items[0][1]\",\n\t\t\tdata:   []byte(`{\"items\":[[\"a\", \"b\"]]}`),\n\t\t\twant: want{\n\t\t\t\tvalue: \"b\",\n\t\t\t},\n\t\t},\n\t\t\"OwnerRefController\": {\n\t\t\treason: \"Requesting a boolean field path should work.\",\n\t\t\tpath:   \"metadata.ownerRefs[0].controller\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"ownerRefs\":[{\"controller\": true}]}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: true,\n\t\t\t},\n\t\t},\n\t\t\"MetadataVersion\": {\n\t\t\treason: \"Requesting an integer field should work\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: int64(2),\n\t\t\t},\n\t\t},\n\t\t\"SomeFloat\": {\n\t\t\treason: \"Requesting a float field should work\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2.0}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: float64(2),\n\t\t\t},\n\t\t},\n\t\t\"MetadataNope\": {\n\t\t\treason: \"Requesting a non-existent object field should fail\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"nope\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\terr: errNotFound{errors.New(\"metadata.name: no such field\")},\n\t\t\t},\n\t\t},\n\t\t\"InsufficientContainers\": {\n\t\t\treason: \"Requesting a non-existent array element should fail\",\n\t\t\tpath:   \"spec.containers[1].name\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\twant: want{\n\t\t\t\terr: errNotFound{errors.New(\"spec.containers[1]: no such element\")},\n\t\t\t},\n\t\t},\n\t\t\"NotAnArray\": {\n\t\t\treason: \"Indexing an object should fail\",\n\t\t\tpath:   \"metadata[1]\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"nope\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata: not an array\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAnObject\": {\n\t\t\treason: \"Requesting a field in an array should fail\",\n\t\t\tpath:   \"spec.containers[nope].name\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"spec.containers: not an object\"),\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetValue(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetValue(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetValue(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetValueInto(t *testing.T) {\n\ttype Struct struct {\n\t\tSlice       []string `json:\"slice\"`\n\t\tStringField string   `json:\"string\"`\n\t\tIntField    int      `json:\"int\"`\n\t}\n\n\ttype Slice []string\n\n\ttype args struct {\n\t\tpath string\n\t\tout  any\n\t}\n\ttype want struct {\n\t\tout any\n\t\terr error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tdata   []byte\n\t\targs   args\n\t\twant   want\n\t}{\n\t\t\"Struct\": {\n\t\t\treason: \"It should be possible to get a value into a struct.\",\n\t\t\tdata:   []byte(`{\"s\":{\"slice\":[\"a\"],\"string\":\"b\",\"int\":1}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"s\",\n\t\t\t\tout:  &Struct{},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tout: &Struct{Slice: []string{\"a\"}, StringField: \"b\", IntField: 1},\n\t\t\t},\n\t\t},\n\t\t\"Slice\": {\n\t\t\treason: \"It should be possible to get a value into a slice.\",\n\t\t\tdata:   []byte(`{\"s\": [\"a\", \"b\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"s\",\n\t\t\t\tout:  &Slice{},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tout: &Slice{\"a\", \"b\"},\n\t\t\t},\n\t\t},\n\t\t\"MissingPath\": {\n\t\t\treason: \"Getting a value from a fieldpath that doesn't exist should return an error.\",\n\t\t\tdata:   []byte(`{}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"s\",\n\t\t\t\tout:  &Struct{},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tout: &Struct{},\n\t\t\t\terr: errNotFound{errors.New(\"s: no such field\")},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\terr := p.GetValueInto(tc.args.path, tc.args.out)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetValueInto(%s): %s: -want error, +got error:\\n%s\", tc.args.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.out, tc.args.out); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetValueInto(%s): %s: -want, +got:\\n%s\", tc.args.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetString(t *testing.T) {\n\ttype want struct {\n\t\tvalue string\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"MetadataName\": {\n\t\t\treason: \"It should be possible to get a field from a nested object\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAString\": {\n\t\t\treason: \"Requesting an non-string field path should fail\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.version: not a string\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetString(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetString(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetString(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetStringArray(t *testing.T) {\n\ttype want struct {\n\t\tvalue []string\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"MetadataLabels\": {\n\t\t\treason: \"It should be possible to get a field from a nested object\",\n\t\t\tpath:   \"spec.containers[0].command\",\n\t\t\tdata:   []byte(`{\"spec\": {\"containers\": [{\"command\": [\"/bin/bash\"]}]}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: []string{\"/bin/bash\"},\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAnArray\": {\n\t\t\treason: \"Requesting an non-object field path should fail\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.version: not an array\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAStringArray\": {\n\t\t\treason: \"Requesting an non-string-object field path should fail\",\n\t\t\tpath:   \"metadata.versions\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"versions\":[1,2]}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.versions: not an array of strings\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetStringArray(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetStringArray(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetStringArray(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetStringObject(t *testing.T) {\n\ttype want struct {\n\t\tvalue map[string]string\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"MetadataLabels\": {\n\t\t\treason: \"It should be possible to get a field from a nested object\",\n\t\t\tpath:   \"metadata.labels\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"labels\":{\"cool\":\"true\"}}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: map[string]string{\"cool\": \"true\"},\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAnObject\": {\n\t\t\treason: \"Requesting an non-object field path should fail\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.version: not an object\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAStringObject\": {\n\t\t\treason: \"Requesting an non-string-object field path should fail\",\n\t\t\tpath:   \"metadata.versions\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"versions\":{\"a\": 2}}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.versions: not an object with string field values\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetStringObject(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetStringObject(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetStringObject(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetBool(t *testing.T) {\n\ttype want struct {\n\t\tvalue bool\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"OwnerRefController\": {\n\t\t\treason: \"Requesting a boolean field path should work.\",\n\t\t\tpath:   \"metadata.ownerRefs[0].controller\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"ownerRefs\":[{\"controller\": true}]}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: true,\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"NotABool\": {\n\t\t\treason: \"Requesting an non-boolean field path should fail\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.name: not a bool\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetBool(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetBool(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetBool(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetNumber(t *testing.T) {\n\ttype want struct {\n\t\tvalue float64\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"MetadataVersion\": {\n\t\t\treason: \"Requesting a number field should work\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2.0}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: 2,\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"NotANumber\": {\n\t\t\treason: \"Requesting an non-number field path should fail\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.name: not a (float64) number\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetNumber(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetNumber(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetNumber(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetInteger(t *testing.T) {\n\ttype want struct {\n\t\tvalue int64\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"MetadataVersion\": {\n\t\t\treason: \"Requesting a number field should work\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: 2,\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"NotANumber\": {\n\t\t\treason: \"Requesting an non-number field path should fail\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.name: not a (int64) number\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetInteger(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetNumber(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetNumber(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetValue(t *testing.T) {\n\ttype args struct {\n\t\tpath  string\n\t\tvalue any\n\t}\n\ttype want struct {\n\t\tobject map[string]any\n\t\terr    error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tdata   []byte\n\t\targs   args\n\t\twant   want\n\t}{\n\t\t\"MetadataName\": {\n\t\t\treason: \"Setting an object field should work\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"lame\"}}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"metadata.name\",\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"metadata\": map[string]any{\n\t\t\t\t\t\t\"name\": \"cool\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NonExistentMetadataName\": {\n\t\t\treason: \"Setting a non-existent object field should work\",\n\t\t\tdata:   []byte(`{}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"metadata.name\",\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"metadata\": map[string]any{\n\t\t\t\t\t\t\"name\": \"cool\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ContainerName\": {\n\t\t\treason: \"Setting a field of an object that is an array element should work\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"lame\"}]}}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"spec.containers[0].name\",\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"spec\": map[string]any{\n\t\t\t\t\t\t\"containers\": []any{\n\t\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\t\"name\": \"cool\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NonExistentContainerName\": {\n\t\t\treason: \"Setting a field of a non-existent object that is an array element should work\",\n\t\t\tdata:   []byte(`{}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"spec.containers[0].name\",\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"spec\": map[string]any{\n\t\t\t\t\t\t\"containers\": []any{\n\t\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\t\"name\": \"cool\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NewContainer\": {\n\t\t\treason: \"Growing an array object field should work\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"spec.containers[1].name\",\n\t\t\t\tvalue: \"cooler\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"spec\": map[string]any{\n\t\t\t\t\t\t\"containers\": []any{\n\t\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\t\"name\": \"cool\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\t\"name\": \"cooler\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NestedArray\": {\n\t\t\treason: \"Setting a value in a nested array should work\",\n\t\t\tdata:   []byte(`{}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"data[0][0]\",\n\t\t\t\tvalue: \"a\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"data\": []any{\n\t\t\t\t\t\t[]any{\"a\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"GrowNestedArray\": {\n\t\t\treason: \"Growing then setting a value in a nested array should work\",\n\t\t\tdata:   []byte(`{\"data\":[[\"a\"]]}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"data[0][1]\",\n\t\t\t\tvalue: \"b\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"data\": []any{\n\t\t\t\t\t\t[]any{\"a\", \"b\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"GrowArrayField\": {\n\t\t\treason: \"Growing then setting a value in an array field should work\",\n\t\t\tdata:   []byte(`{\"data\":[\"a\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"data[2]\",\n\t\t\t\tvalue: \"c\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"data\": []any{\"a\", nil, \"c\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"MapStringString\": {\n\t\t\treason: \"A map of string to string should be converted to a map of string to any\",\n\t\t\tdata:   []byte(`{\"metadata\":{}}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"metadata.labels\",\n\t\t\t\tvalue: map[string]string{\"cool\": \"very\"},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"metadata\": map[string]any{\n\t\t\t\t\t\t\"labels\": map[string]any{\"cool\": \"very\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"OwnerReference\": {\n\t\t\treason: \"An ObjectReference (i.e. struct) should be converted to a map of string to any\",\n\t\t\tdata:   []byte(`{\"metadata\":{}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"metadata.ownerRefs[0]\",\n\t\t\t\tvalue: metav1.OwnerReference{\n\t\t\t\t\tAPIVersion: \"v\",\n\t\t\t\t\tKind:       \"k\",\n\t\t\t\t\tName:       \"n\",\n\t\t\t\t\tUID:        types.UID(\"u\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"metadata\": map[string]any{\n\t\t\t\t\t\t\"ownerRefs\": []any{\n\t\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\t\"apiVersion\": \"v\",\n\t\t\t\t\t\t\t\t\"kind\":       \"k\",\n\t\t\t\t\t\t\t\t\"name\":       \"n\",\n\t\t\t\t\t\t\t\t\"uid\":        \"u\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NotAnArray\": {\n\t\t\treason: \"Indexing an object field should fail\",\n\t\t\tdata:   []byte(`{\"data\":{}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"data[0]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\"data\": map[string]any{}},\n\t\t\t\terr:    errors.New(\"data is not an array\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAnObject\": {\n\t\t\treason: \"Requesting a field in an array should fail\",\n\t\t\tdata:   []byte(`{\"data\":[]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"data.name\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\"data\": []any{}},\n\t\t\t\terr:    errors.New(\"data is not an object\"),\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\targs: args{\n\t\t\t\tpath: \"spec[]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{},\n\t\t\t\terr:    errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\terr := p.SetValue(tc.args.path, tc.args.value)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.SetValue(%s, %v): %s: -want error, +got error:\\n%s\", tc.args.path, tc.args.value, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.object, p.object); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.SetValue(%s, %v): %s: -want, +got:\\n%s\", tc.args.path, tc.args.value, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExpandWildcards(t *testing.T) {\n\ttype want struct {\n\t\texpanded []string\n\t\terr      error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"NoWildcardExisting\": {\n\t\t\treason: \"It should return same path if no wildcard in an existing path\",\n\t\t\tpath:   \"password\",\n\t\t\tdata:   []byte(`{\"password\":\"top-secret\"}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"password\"},\n\t\t\t},\n\t\t},\n\t\t\"NoWildcardNonExisting\": {\n\t\t\treason: \"It should return no results if no wildcard in a non-existing path\",\n\t\t\tpath:   \"username\",\n\t\t\tdata:   []byte(`{\"password\":\"top-secret\"}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{},\n\t\t\t},\n\t\t},\n\t\t\"NestedNoWildcardExisting\": {\n\t\t\treason: \"It should return same path if no wildcard in an existing path\",\n\t\t\tpath:   \"items[0][1]\",\n\t\t\tdata:   []byte(`{\"items\":[[\"a\", \"b\"]]}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"items[0][1]\"},\n\t\t\t},\n\t\t},\n\t\t\"NestedNoWildcardNonExisting\": {\n\t\t\treason: \"It should return no results if no wildcard in a non-existing path\",\n\t\t\tpath:   \"items[0][5]\",\n\t\t\tdata:   []byte(`{\"items\":[[\"a\", \"b\"]]}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{},\n\t\t\t},\n\t\t},\n\t\t\"NestedArray\": {\n\t\t\treason: \"It should return all possible paths for an array\",\n\t\t\tpath:   \"items[*][*]\",\n\t\t\tdata:   []byte(`{\"items\":[[\"a\", \"b\", \"c\"], [\"d\"]]}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"items[0][0]\", \"items[0][1]\", \"items[0][2]\", \"items[1][0]\"},\n\t\t\t},\n\t\t},\n\t\t\"KeysOfMap\": {\n\t\t\treason: \"It should return all possible paths for a map in proper syntax\",\n\t\t\tpath:   \"items[*]\",\n\t\t\tdata:   []byte(`{\"items\":{ \"key1\": \"val1\", \"key2.as.annotation\": \"val2\"}}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"items.key1\", \"items[key2.as.annotation]\"},\n\t\t\t},\n\t\t},\n\t\t\"ArrayOfObjects\": {\n\t\t\treason: \"It should return all possible paths for an array of objects\",\n\t\t\tpath:   \"spec.containers[*][*]\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\", \"image\": \"latest\", \"args\": [\"start\", \"now\"]}]}}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"spec.containers[0].name\", \"spec.containers[0].image\", \"spec.containers[0].args\"},\n\t\t\t},\n\t\t},\n\t\t\"MultiLayer\": {\n\t\t\treason: \"It should return all possible paths for a multilayer input\",\n\t\t\tpath:   \"spec.containers[*].args[*]\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\", \"image\": \"latest\", \"args\": [\"start\", \"now\", \"debug\"]}]}}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"spec.containers[0].args[0]\", \"spec.containers[0].args[1]\", \"spec.containers[0].args[2]\"},\n\t\t\t},\n\t\t},\n\t\t\"WildcardInTheBeginning\": {\n\t\t\treason: \"It should return all possible paths for a multilayer input with wildcard in the beginning\",\n\t\t\tpath:   \"spec.containers[*].args[1]\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\", \"image\": \"latest\", \"args\": [\"start\", \"now\", \"debug\"]}]}}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"spec.containers[0].args[1]\"},\n\t\t\t},\n\t\t},\n\t\t\"WildcardAtTheEnd\": {\n\t\t\treason: \"It should return all possible paths for a multilayer input with wildcard at the end\",\n\t\t\tpath:   \"spec.containers[0].args[*]\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\", \"image\": \"latest\", \"args\": [\"start\", \"now\", \"debug\"]}]}}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"spec.containers[0].args[0]\", \"spec.containers[0].args[1]\", \"spec.containers[0].args[2]\"},\n\t\t\t},\n\t\t},\n\t\t\"NoData\": {\n\t\t\treason: \"If there is no input data, no expanded fields could be found\",\n\t\t\tpath:   \"metadata[*]\",\n\t\t\tdata:   nil,\n\t\t\twant: want{\n\t\t\t\texpanded: []string{},\n\t\t\t},\n\t\t},\n\t\t\"InsufficientContainers\": {\n\t\t\treason: \"Requesting a non-existent array element should return nothing\",\n\t\t\tpath:   \"spec.containers[1].args[*]\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{},\n\t\t\t},\n\t\t},\n\t\t\"UnexpectedWildcard\": {\n\t\t\treason: \"Requesting a wildcard for an object should fail\",\n\t\t\tpath:   \"spec.containers[0].name[*]\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrapf(errors.Errorf(\"%q: unexpected wildcard usage\", \"spec.containers[0].name\"), \"cannot expand wildcards for segments: %q\", \"spec.containers[0].name[*]\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAnArray\": {\n\t\t\treason: \"Indexing an object should fail\",\n\t\t\tpath:   \"metadata[1]\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"nope\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrapf(errors.New(\"metadata: not an array\"), \"cannot expand wildcards for segments: %q\", \"metadata[1]\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAnObject\": {\n\t\t\treason: \"Requesting a field in an array should fail\",\n\t\t\tpath:   \"spec.containers[nope].name\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrapf(errors.New(\"spec.containers: not an object\"), \"cannot expand wildcards for segments: %q\", \"spec.containers.nope.name\"),\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.ExpandWildcards(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.ExpandWildcards(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.expanded, got, cmpopts.SortSlices(func(x, y string) bool {\n\t\t\t\treturn x < y\n\t\t\t})); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.ExpandWildcards(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDeleteField(t *testing.T) {\n\ttype args struct {\n\t\tpath string\n\t}\n\ttype want struct {\n\t\tobject map[string]any\n\t\terr    error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tdata   []byte\n\t\targs   args\n\t\twant   want\n\t}{\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\targs: args{\n\t\t\t\tpath: \"spec[]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{},\n\t\t\t\terr:    errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"IndexGivenForNonArray\": {\n\t\t\treason: \"Trying to delete a numbered index from a map should fail.\",\n\t\t\tdata:   []byte(`{\"data\":{}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"data[0]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\"data\": map[string]any{}},\n\t\t\t\terr:    errors.Wrap(errors.New(\"not an array\"), \"cannot delete data[0]\"),\n\t\t\t},\n\t\t},\n\t\t\"KeyGivenForNonMap\": {\n\t\t\treason: \"Trying to delete a key from an array should fail.\",\n\t\t\tdata:   []byte(`{\"data\":[[\"a\"]]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"data[0].a\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\"data\": []any{[]any{\"a\"}}},\n\t\t\t\terr:    errors.Wrap(errors.New(\"not an object\"), \"cannot delete data[0].a\"),\n\t\t\t},\n\t\t},\n\t\t\"KeyGivenForNonMapInMiddle\": {\n\t\t\treason: \"If one of the segments that is a field corresponds to array, it should fail.\",\n\t\t\tdata:   []byte(`{\"data\":[{\"another\": \"field\"}]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"data.some.another\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\"data\": []any{\n\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\"another\": \"field\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\terr: errors.New(\"data is not an object\"),\n\t\t\t},\n\t\t},\n\t\t\"IndexGivenForNonArrayInMiddle\": {\n\t\t\treason: \"If one of the segments that is an index corresponds to map, it should fail.\",\n\t\t\tdata:   []byte(`{\"data\":{\"another\": [\"field\"]}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"data[0].another\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\"data\": map[string]any{\n\t\t\t\t\t\"another\": []any{\n\t\t\t\t\t\t\"field\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\terr: errors.New(\"data is not an array\"),\n\t\t\t},\n\t\t},\n\t\t\"ObjectField\": {\n\t\t\treason: \"Deleting a field from a map should work.\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"lame\"}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"metadata.name\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"metadata\": map[string]any{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ObjectSingleField\": {\n\t\t\treason: \"Deleting a field from a map should work.\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"lame\"}, \"olala\": {\"omama\": \"koala\"}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"metadata\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"olala\": map[string]any{\n\t\t\t\t\t\t\"omama\": \"koala\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ObjectLeafField\": {\n\t\t\treason: \"Deleting a field that is deep in the tree from a map should work.\",\n\t\t\tdata:   []byte(`{\"spec\":{\"some\": {\"more\": \"delete-me\"}}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"spec.some.more\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"spec\": map[string]any{\n\t\t\t\t\t\t\"some\": map[string]any{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ObjectMidField\": {\n\t\t\treason: \"Deleting a field that is in the middle of the tree from a map should work.\",\n\t\t\tdata:   []byte(`{\"spec\":{\"some\": {\"more\": \"delete-me\"}}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"spec.some\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"spec\": map[string]any{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ObjectInArray\": {\n\t\t\treason: \"Deleting a field that is in the middle of the tree from a map should work.\",\n\t\t\tdata:   []byte(`{\"spec\":[{\"some\": {\"more\": \"delete-me\"}}]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"spec[0].some.more\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"spec\": []any{\n\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\"some\": map[string]any{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ArrayFirstElement\": {\n\t\t\treason: \"Deleting the first element from an array should work\",\n\t\t\tdata:   []byte(`{\"items\":[\"a\", \"b\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[0]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{\n\t\t\t\t\t\t\"b\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ArrayLastElement\": {\n\t\t\treason: \"Deleting the last element from an array should work\",\n\t\t\tdata:   []byte(`{\"items\":[\"a\", \"b\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[1]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{\n\t\t\t\t\t\t\"a\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ArrayMidElement\": {\n\t\t\treason: \"Deleting an element that is neither first nor last from an array should work\",\n\t\t\tdata:   []byte(`{\"items\":[\"a\", \"b\", \"c\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[1]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{\n\t\t\t\t\t\t\"a\",\n\t\t\t\t\t\t\"c\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ArrayOnlyElements\": {\n\t\t\treason: \"Deleting the only element from an array should work\",\n\t\t\tdata:   []byte(`{\"items\":[\"a\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[0]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ArrayMultipleIndex\": {\n\t\t\treason: \"Deleting an element from an array of array should work\",\n\t\t\tdata:   []byte(`{\"items\":[[\"a\", \"b\"]]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[0][1]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{\n\t\t\t\t\t\t[]any{\n\t\t\t\t\t\t\t\"a\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ArrayNoElement\": {\n\t\t\treason: \"Deleting an element from an empty array should work\",\n\t\t\tdata:   []byte(`{\"items\":[]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[0]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NonExistentPathInMap\": {\n\t\t\treason: \"It should be no-op if the field does not exist already.\",\n\t\t\tdata:   []byte(`{\"items\":[]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[0].metadata\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NonExistentPathInArray\": {\n\t\t\treason: \"It should be no-op if the field does not exist already.\",\n\t\t\tdata:   []byte(`{\"items\":{\"some\": \"other\"}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items.metadata[0]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": map[string]any{\n\t\t\t\t\t\t\"some\": \"other\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NonExistentElementInArray\": {\n\t\t\treason: \"It should be no-op if the field does not exist already.\",\n\t\t\tdata:   []byte(`{\"items\":[\"some\", \"other\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[5]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{\n\t\t\t\t\t\t\"some\", \"other\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\terr := p.DeleteField(tc.args.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.DeleteField(%s): %s: -want error, +got error:\\n%s\", tc.args.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.object, p.object); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.DeleteField(%s): %s: -want, +got:\\n%s\", tc.args.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n"], "fixing_code": ["/*\nCopyright 2019 The Crossplane Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage fieldpath\n\nimport (\n\t\"strconv\"\n\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/util/json\"\n\n\t\"github.com/crossplane/crossplane-runtime/pkg/errors\"\n)\n\n// DefaultMaxFieldPathIndex is the max allowed index in a field path.\nconst DefaultMaxFieldPathIndex = 1024\n\ntype errNotFound struct {\n\terror\n}\n\nfunc (e errNotFound) IsNotFound() bool {\n\treturn true\n}\n\n// IsNotFound returns true if the supplied error indicates a field path was not\n// found, for example because a field did not exist within an object or an\n// index was out of bounds in an array.\nfunc IsNotFound(err error) bool {\n\tcause := errors.Cause(err)\n\t_, ok := cause.(interface { //nolint: errorlint // Skip errorlint for interface type\n\t\tIsNotFound() bool\n\t})\n\treturn ok\n}\n\n// A Paved JSON object supports getting and setting values by their field path.\ntype Paved struct {\n\tobject            map[string]any\n\tmaxFieldPathIndex uint\n}\n\ntype PavedOption func(paved *Paved)\n\n// PaveObject paves a runtime.Object, making it possible to get and set values\n// by field path. o must be a non-nil pointer to an object.\nfunc PaveObject(o runtime.Object, opts ...PavedOption) (*Paved, error) {\n\tu, err := runtime.DefaultUnstructuredConverter.ToUnstructured(o)\n\treturn Pave(u, opts...), errors.Wrap(err, \"cannot convert object to unstructured data\")\n}\n\n// Pave a JSON object, making it possible to get and set values by field path.\nfunc Pave(object map[string]any, opts ...PavedOption) *Paved {\n\tp := &Paved{object: object, maxFieldPathIndex: DefaultMaxFieldPathIndex}\n\n\tfor _, opt := range opts {\n\t\topt(p)\n\t}\n\n\treturn p\n}\n\n// WithMaxFieldPathIndex returns a PavedOption that sets the max allowed index for field paths, 0 means no limit.\nfunc WithMaxFieldPathIndex(max uint) PavedOption {\n\treturn func(paved *Paved) {\n\t\tpaved.maxFieldPathIndex = max\n\t}\n}\n\nfunc (p *Paved) maxFieldPathIndexEnabled() bool {\n\treturn p.maxFieldPathIndex > 0\n}\n\n// MarshalJSON to the underlying object.\nfunc (p Paved) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(p.object)\n}\n\n// UnmarshalJSON from the underlying object.\nfunc (p *Paved) UnmarshalJSON(data []byte) error {\n\treturn json.Unmarshal(data, &p.object)\n}\n\n// UnstructuredContent returns the JSON serialisable content of this Paved.\nfunc (p *Paved) UnstructuredContent() map[string]any {\n\tif p.object == nil {\n\t\treturn make(map[string]any)\n\t}\n\treturn p.object\n}\n\n// SetUnstructuredContent sets the JSON serialisable content of this Paved.\nfunc (p *Paved) SetUnstructuredContent(content map[string]any) {\n\tp.object = content\n}\n\nfunc (p *Paved) getValue(s Segments) (any, error) {\n\treturn getValueFromInterface(p.object, s)\n}\n\nfunc getValueFromInterface(it any, s Segments) (any, error) {\n\tfor i, current := range s {\n\t\tfinal := i == len(s)-1\n\t\tswitch current.Type {\n\t\tcase SegmentIndex:\n\t\t\tarray, ok := it.([]any)\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.Errorf(\"%s: not an array\", s[:i])\n\t\t\t}\n\t\t\tif int(current.Index) >= len(array) {\n\t\t\t\treturn nil, errNotFound{errors.Errorf(\"%s: no such element\", s[:i+1])}\n\t\t\t}\n\t\t\tif final {\n\t\t\t\treturn array[current.Index], nil\n\t\t\t}\n\t\t\tit = array[current.Index]\n\t\tcase SegmentField:\n\t\t\tobject, ok := it.(map[string]any)\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.Errorf(\"%s: not an object\", s[:i])\n\t\t\t}\n\t\t\tv, ok := object[current.Field]\n\t\t\tif !ok {\n\t\t\t\treturn nil, errNotFound{errors.Errorf(\"%s: no such field\", s[:i+1])}\n\t\t\t}\n\t\t\tif final {\n\t\t\t\treturn v, nil\n\t\t\t}\n\t\t\tit = object[current.Field]\n\t\t}\n\t}\n\n\t// This should be unreachable.\n\treturn nil, nil\n}\n\n// ExpandWildcards expands wildcards for a given field path. It returns an\n// array of field paths with expanded values. Please note that expanded paths\n// depend on the input data which is paved.object.\n//\n// Example:\n//\n// For a Paved object with the following data: []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\", \"image\": \"latest\", \"args\": [\"start\", \"now\", \"debug\"]}]}}`),\n// ExpandWildcards(\"spec.containers[*].args[*]\") returns:\n// []string{\"spec.containers[0].args[0]\", \"spec.containers[0].args[1]\", \"spec.containers[0].args[2]\"},\nfunc (p *Paved) ExpandWildcards(path string) ([]string, error) {\n\tsegments, err := Parse(path)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"cannot parse path %q\", path)\n\t}\n\tsegmentsArray, err := expandWildcards(p.object, segments)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"cannot expand wildcards for segments: %q\", segments)\n\t}\n\tpaths := make([]string, len(segmentsArray))\n\tfor i, s := range segmentsArray {\n\t\tpaths[i] = s.String()\n\t}\n\treturn paths, nil\n}\n\nfunc expandWildcards(data any, segments Segments) ([]Segments, error) { //nolint:gocyclo // See note below.\n\t// Even complexity turns out to be high, it is mostly because we have duplicate\n\t// logic for arrays and maps and a couple of error handling.\n\tvar res []Segments\n\tit := data\n\tfor i, current := range segments {\n\t\t// wildcards are regular fields with \"*\" as string\n\t\tif current.Type == SegmentField && current.Field == wildcard {\n\t\t\tswitch mapOrArray := it.(type) {\n\t\t\tcase []any:\n\t\t\t\tfor ix := range mapOrArray {\n\t\t\t\t\texpanded := make(Segments, len(segments))\n\t\t\t\t\tcopy(expanded, segments)\n\t\t\t\t\texpanded = append(append(expanded[:i], FieldOrIndex(strconv.Itoa(ix))), expanded[i+1:]...)\n\t\t\t\t\tr, err := expandWildcards(data, expanded)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, errors.Wrapf(err, \"%q: cannot expand wildcards\", expanded)\n\t\t\t\t\t}\n\t\t\t\t\tres = append(res, r...)\n\t\t\t\t}\n\t\t\tcase map[string]any:\n\t\t\t\tfor k := range mapOrArray {\n\t\t\t\t\texpanded := make(Segments, len(segments))\n\t\t\t\t\tcopy(expanded, segments)\n\t\t\t\t\texpanded = append(append(expanded[:i], Field(k)), expanded[i+1:]...)\n\t\t\t\t\tr, err := expandWildcards(data, expanded)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, errors.Wrapf(err, \"%q: cannot expand wildcards\", expanded)\n\t\t\t\t\t}\n\t\t\t\t\tres = append(res, r...)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn nil, errors.Errorf(\"%q: unexpected wildcard usage\", segments[:i])\n\t\t\t}\n\t\t\treturn res, nil\n\t\t}\n\t\tvar err error\n\t\tit, err = getValueFromInterface(data, segments[:i+1])\n\t\tif IsNotFound(err) {\n\t\t\treturn nil, nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn append(res, segments), nil\n}\n\n// GetValue of the supplied field path.\nfunc (p *Paved) GetValue(path string) (any, error) {\n\tsegments, err := Parse(path)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"cannot parse path %q\", path)\n\t}\n\n\treturn p.getValue(segments)\n}\n\n// GetValueInto the supplied type.\nfunc (p *Paved) GetValueInto(path string, out any) error {\n\tval, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tjs, err := json.Marshal(val)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"cannot marshal value to JSON\")\n\t}\n\treturn errors.Wrap(json.Unmarshal(js, out), \"cannot unmarshal value from JSON\")\n}\n\n// GetString value of the supplied field path.\nfunc (p *Paved) GetString(path string) (string, error) {\n\tv, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn \"\", errors.Errorf(\"%s: not a string\", path)\n\t}\n\treturn s, nil\n}\n\n// GetStringArray value of the supplied field path.\nfunc (p *Paved) GetStringArray(path string) ([]string, error) {\n\tv, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta, ok := v.([]any)\n\tif !ok {\n\t\treturn nil, errors.Errorf(\"%s: not an array\", path)\n\t}\n\n\tsa := make([]string, len(a))\n\tfor i := range a {\n\t\ts, ok := a[i].(string)\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"%s: not an array of strings\", path)\n\t\t}\n\t\tsa[i] = s\n\t}\n\n\treturn sa, nil\n}\n\n// GetStringObject value of the supplied field path.\nfunc (p *Paved) GetStringObject(path string) (map[string]string, error) {\n\tv, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\to, ok := v.(map[string]any)\n\tif !ok {\n\t\treturn nil, errors.Errorf(\"%s: not an object\", path)\n\t}\n\n\tso := make(map[string]string)\n\tfor k, in := range o {\n\t\ts, ok := in.(string)\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"%s: not an object with string field values\", path)\n\t\t}\n\t\tso[k] = s\n\n\t}\n\n\treturn so, nil\n}\n\n// GetBool value of the supplied field path.\nfunc (p *Paved) GetBool(path string) (bool, error) {\n\tv, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tb, ok := v.(bool)\n\tif !ok {\n\t\treturn false, errors.Errorf(\"%s: not a bool\", path)\n\t}\n\treturn b, nil\n}\n\n// NOTE(muvaf): If there is no CRD, unstructured.Unstructured reads numbers as\n// float64. However, in practice, use of float64 is discouraged and when you fetch\n// an instance of a CRD whose number fields are int64, you'll get int64. So,\n// it's not really possible to test this without an api-server but that's the\n// actual behavior.\n\n// GetNumber value of the supplied field path.\n// Deprecated: Use of float64 is discouraged. Please use GetInteger.\n// See https://github.com/kubernetes/community/blob/c9ae475/contributors/devel/sig-architecture/api-conventions.md#primitive-types\nfunc (p *Paved) GetNumber(path string) (float64, error) {\n\tv, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tf, ok := v.(float64)\n\tif !ok {\n\t\treturn 0, errors.Errorf(\"%s: not a (float64) number\", path)\n\t}\n\treturn f, nil\n}\n\n// GetInteger value of the supplied field path.\nfunc (p *Paved) GetInteger(path string) (int64, error) {\n\tv, err := p.GetValue(path)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tf, ok := v.(int64)\n\tif !ok {\n\t\treturn 0, errors.Errorf(\"%s: not a (int64) number\", path)\n\t}\n\treturn f, nil\n}\n\nfunc (p *Paved) setValue(s Segments, value any) error {\n\t// We expect p.object to look like JSON data that was unmarshalled into an\n\t// any per https://golang.org/pkg/encoding/json/#Unmarshal. We\n\t// marshal our value to JSON and unmarshal it into an any to ensure\n\t// it meets these criteria before setting it within p.object.\n\tvar v any\n\tj, err := json.Marshal(value)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"cannot marshal value to JSON\")\n\t}\n\tif err := json.Unmarshal(j, &v); err != nil {\n\t\treturn errors.Wrap(err, \"cannot unmarshal value from JSON\")\n\t}\n\n\tvar in any = p.object\n\tfor i, current := range s {\n\t\tfinal := i == len(s)-1\n\n\t\tswitch current.Type {\n\t\tcase SegmentIndex:\n\t\t\tarray, ok := in.([]any)\n\t\t\tif !ok {\n\t\t\t\treturn errors.Errorf(\"%s is not an array\", s[:i])\n\t\t\t}\n\n\t\t\tif p.maxFieldPathIndexEnabled() && current.Index > p.maxFieldPathIndex {\n\t\t\t\treturn errors.Errorf(\"index %d is greater than max allowed index %d\", current.Index, p.maxFieldPathIndex)\n\t\t\t}\n\n\t\t\tif final {\n\t\t\t\tarray[current.Index] = v\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tprepareElement(array, current, s[i+1])\n\t\t\tin = array[current.Index]\n\n\t\tcase SegmentField:\n\t\t\tobject, ok := in.(map[string]any)\n\t\t\tif !ok {\n\t\t\t\treturn errors.Errorf(\"%s is not an object\", s[:i])\n\t\t\t}\n\n\t\t\tif final {\n\t\t\t\tobject[current.Field] = v\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tprepareField(object, current, s[i+1])\n\t\t\tin = object[current.Field]\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc prepareElement(array []any, current, next Segment) {\n\t// If this segment is not the final one and doesn't exist we need to\n\t// create it for our next segment.\n\tif array[current.Index] == nil {\n\t\tswitch next.Type {\n\t\tcase SegmentIndex:\n\t\t\tarray[current.Index] = make([]any, next.Index+1)\n\t\tcase SegmentField:\n\t\t\tarray[current.Index] = make(map[string]any)\n\t\t}\n\t\treturn\n\t}\n\n\t// If our next segment indexes an array that exists in our current segment's\n\t// element we must ensure the array is long enough to set the next segment.\n\tif next.Type != SegmentIndex {\n\t\treturn\n\t}\n\n\tna, ok := array[current.Index].([]any)\n\tif !ok {\n\t\treturn\n\t}\n\n\tif int(next.Index) < len(na) {\n\t\treturn\n\t}\n\n\tarray[current.Index] = append(na, make([]any, int(next.Index)-len(na)+1)...)\n}\n\nfunc prepareField(object map[string]any, current, next Segment) {\n\t// If this segment is not the final one and doesn't exist we need to\n\t// create it for our next segment.\n\tif _, ok := object[current.Field]; !ok {\n\t\tswitch next.Type {\n\t\tcase SegmentIndex:\n\t\t\tobject[current.Field] = make([]any, next.Index+1)\n\t\tcase SegmentField:\n\t\t\tobject[current.Field] = make(map[string]any)\n\t\t}\n\t\treturn\n\t}\n\n\t// If our next segment indexes an array that exists in our current segment's\n\t// field we must ensure the array is long enough to set the next segment.\n\tif next.Type != SegmentIndex {\n\t\treturn\n\t}\n\n\tna, ok := object[current.Field].([]any)\n\tif !ok {\n\t\treturn\n\t}\n\n\tif int(next.Index) < len(na) {\n\t\treturn\n\t}\n\n\tobject[current.Field] = append(na, make([]any, int(next.Index)-len(na)+1)...)\n}\n\n// SetValue at the supplied field path.\nfunc (p *Paved) SetValue(path string, value any) error {\n\tsegments, err := Parse(path)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"cannot parse path %q\", path)\n\t}\n\treturn p.setValue(segments, value)\n}\n\n// SetString value at the supplied field path.\nfunc (p *Paved) SetString(path, value string) error {\n\treturn p.SetValue(path, value)\n}\n\n// SetBool value at the supplied field path.\nfunc (p *Paved) SetBool(path string, value bool) error {\n\treturn p.SetValue(path, value)\n}\n\n// SetNumber value at the supplied field path.\nfunc (p *Paved) SetNumber(path string, value float64) error {\n\treturn p.SetValue(path, value)\n}\n\n// DeleteField deletes the field from the object.\n// If the path points to an entry in an array, the element\n// on that index is removed and the next ones are pulled\n// back. If it is a field on a map, the field is\n// removed from the map.\nfunc (p *Paved) DeleteField(path string) error {\n\tsegments, err := Parse(path)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"cannot parse path %q\", path)\n\t}\n\treturn p.delete(segments)\n}\n\nfunc (p *Paved) delete(segments Segments) error { //nolint:gocyclo // See note below.\n\t// NOTE(muvaf): I could not reduce the cyclomatic complexity\n\t// more than that without disturbing the reading flow.\n\tif len(segments) == 1 {\n\t\to, err := deleteField(p.object, segments[0])\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"cannot delete %s\", segments)\n\t\t}\n\t\tp.object = o.(map[string]any)\n\t\treturn nil\n\t}\n\tvar in any = p.object\n\tfor i, current := range segments {\n\t\t// beforeLast is true for the element before the last one because\n\t\t// slices cannot be changed in place and Go does not allow\n\t\t// taking address of map elements which prevents us from\n\t\t// assigning a new array for that entry unless we have the\n\t\t// map available in the context, which is achieved by iterating\n\t\t// until the element before the last one as opposed to\n\t\t// Set/Get functions in this file.\n\t\tbeforeLast := i == len(segments)-2\n\t\tswitch current.Type {\n\t\tcase SegmentIndex:\n\t\t\tarray, ok := in.([]any)\n\t\t\tif !ok {\n\t\t\t\treturn errors.Errorf(\"%s is not an array\", segments[:i])\n\t\t\t}\n\n\t\t\t// It doesn't exist anyway.\n\t\t\tif len(array) <= int(current.Index) {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif beforeLast {\n\t\t\t\to, err := deleteField(array[current.Index], segments[len(segments)-1])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn errors.Wrapf(err, \"cannot delete %s\", segments)\n\t\t\t\t}\n\t\t\t\tarray[current.Index] = o\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tin = array[current.Index]\n\t\tcase SegmentField:\n\t\t\tobject, ok := in.(map[string]any)\n\t\t\tif !ok {\n\t\t\t\treturn errors.Errorf(\"%s is not an object\", segments[:i])\n\t\t\t}\n\n\t\t\t// It doesn't exist anyway.\n\t\t\tif _, ok := object[current.Field]; !ok {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif beforeLast {\n\t\t\t\to, err := deleteField(object[current.Field], segments[len(segments)-1])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn errors.Wrapf(err, \"cannot delete %s\", segments)\n\t\t\t\t}\n\t\t\t\tobject[current.Field] = o\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tin = object[current.Field]\n\t\t}\n\t}\n\treturn nil\n}\n\n// deleteField deletes the object in obj pointed by\n// the given Segment and returns it. Returned object\n// may or may not have the same address in memory.\nfunc deleteField(obj any, s Segment) (any, error) {\n\tswitch s.Type {\n\tcase SegmentIndex:\n\t\tarray, ok := obj.([]any)\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"not an array\")\n\t\t}\n\t\tif len(array) == 0 || len(array) <= int(s.Index) {\n\t\t\treturn array, nil\n\t\t}\n\t\tfor i := int(s.Index); i < len(array)-1; i++ {\n\t\t\tarray[i] = array[i+1]\n\t\t}\n\t\treturn array[:len(array)-1], nil\n\tcase SegmentField:\n\t\tobject, ok := obj.(map[string]any)\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"not an object\")\n\t\t}\n\t\tdelete(object, s.Field)\n\t\treturn object, nil\n\t}\n\treturn nil, nil\n}\n", "/*\nCopyright 2019 The Crossplane Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage fieldpath\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/json\"\n\n\t\"github.com/crossplane/crossplane-runtime/pkg/errors\"\n\t\"github.com/crossplane/crossplane-runtime/pkg/test\"\n)\n\nfunc TestIsNotFound(t *testing.T) {\n\tcases := map[string]struct {\n\t\treason string\n\t\terr    error\n\t\twant   bool\n\t}{\n\t\t\"NotFound\": {\n\t\t\treason: \"An error with method `IsNotFound() bool` should be considered a not found error.\",\n\t\t\terr:    errNotFound{errors.New(\"boom\")},\n\t\t\twant:   true,\n\t\t},\n\t\t\"WrapsNotFound\": {\n\t\t\treason: \"An error that wraps an error with method `IsNotFound() bool` should be considered a not found error.\",\n\t\t\terr:    errors.Wrap(errNotFound{errors.New(\"boom\")}, \"because reasons\"),\n\t\t\twant:   true,\n\t\t},\n\t\t\"SomethingElse\": {\n\t\t\treason: \"An error without method `IsNotFound() bool` should not be considered a not found error.\",\n\t\t\terr:    errors.New(\"boom\"),\n\t\t\twant:   false,\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := IsNotFound(tc.err)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"IsNotFound(...): Want %t, got %t\", tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetValue(t *testing.T) {\n\ttype want struct {\n\t\tvalue any\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"MetadataName\": {\n\t\t\treason: \"It should be possible to get a field from a nested object\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t},\n\t\t\"ContainerName\": {\n\t\t\treason: \"It should be possible to get a field from an object array element\",\n\t\t\tpath:   \"spec.containers[0].name\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t},\n\t\t\"NestedArray\": {\n\t\t\treason: \"It should be possible to get a field from a nested array\",\n\t\t\tpath:   \"items[0][1]\",\n\t\t\tdata:   []byte(`{\"items\":[[\"a\", \"b\"]]}`),\n\t\t\twant: want{\n\t\t\t\tvalue: \"b\",\n\t\t\t},\n\t\t},\n\t\t\"OwnerRefController\": {\n\t\t\treason: \"Requesting a boolean field path should work.\",\n\t\t\tpath:   \"metadata.ownerRefs[0].controller\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"ownerRefs\":[{\"controller\": true}]}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: true,\n\t\t\t},\n\t\t},\n\t\t\"MetadataVersion\": {\n\t\t\treason: \"Requesting an integer field should work\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: int64(2),\n\t\t\t},\n\t\t},\n\t\t\"SomeFloat\": {\n\t\t\treason: \"Requesting a float field should work\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2.0}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: float64(2),\n\t\t\t},\n\t\t},\n\t\t\"MetadataNope\": {\n\t\t\treason: \"Requesting a non-existent object field should fail\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"nope\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\terr: errNotFound{errors.New(\"metadata.name: no such field\")},\n\t\t\t},\n\t\t},\n\t\t\"InsufficientContainers\": {\n\t\t\treason: \"Requesting a non-existent array element should fail\",\n\t\t\tpath:   \"spec.containers[1].name\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\twant: want{\n\t\t\t\terr: errNotFound{errors.New(\"spec.containers[1]: no such element\")},\n\t\t\t},\n\t\t},\n\t\t\"NotAnArray\": {\n\t\t\treason: \"Indexing an object should fail\",\n\t\t\tpath:   \"metadata[1]\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"nope\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata: not an array\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAnObject\": {\n\t\t\treason: \"Requesting a field in an array should fail\",\n\t\t\tpath:   \"spec.containers[nope].name\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"spec.containers: not an object\"),\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetValue(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetValue(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetValue(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetValueInto(t *testing.T) {\n\ttype Struct struct {\n\t\tSlice       []string `json:\"slice\"`\n\t\tStringField string   `json:\"string\"`\n\t\tIntField    int      `json:\"int\"`\n\t}\n\n\ttype Slice []string\n\n\ttype args struct {\n\t\tpath string\n\t\tout  any\n\t}\n\ttype want struct {\n\t\tout any\n\t\terr error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tdata   []byte\n\t\targs   args\n\t\twant   want\n\t}{\n\t\t\"Struct\": {\n\t\t\treason: \"It should be possible to get a value into a struct.\",\n\t\t\tdata:   []byte(`{\"s\":{\"slice\":[\"a\"],\"string\":\"b\",\"int\":1}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"s\",\n\t\t\t\tout:  &Struct{},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tout: &Struct{Slice: []string{\"a\"}, StringField: \"b\", IntField: 1},\n\t\t\t},\n\t\t},\n\t\t\"Slice\": {\n\t\t\treason: \"It should be possible to get a value into a slice.\",\n\t\t\tdata:   []byte(`{\"s\": [\"a\", \"b\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"s\",\n\t\t\t\tout:  &Slice{},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tout: &Slice{\"a\", \"b\"},\n\t\t\t},\n\t\t},\n\t\t\"MissingPath\": {\n\t\t\treason: \"Getting a value from a fieldpath that doesn't exist should return an error.\",\n\t\t\tdata:   []byte(`{}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"s\",\n\t\t\t\tout:  &Struct{},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tout: &Struct{},\n\t\t\t\terr: errNotFound{errors.New(\"s: no such field\")},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\terr := p.GetValueInto(tc.args.path, tc.args.out)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetValueInto(%s): %s: -want error, +got error:\\n%s\", tc.args.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.out, tc.args.out); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetValueInto(%s): %s: -want, +got:\\n%s\", tc.args.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetString(t *testing.T) {\n\ttype want struct {\n\t\tvalue string\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"MetadataName\": {\n\t\t\treason: \"It should be possible to get a field from a nested object\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAString\": {\n\t\t\treason: \"Requesting an non-string field path should fail\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.version: not a string\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetString(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetString(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetString(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetStringArray(t *testing.T) {\n\ttype want struct {\n\t\tvalue []string\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"MetadataLabels\": {\n\t\t\treason: \"It should be possible to get a field from a nested object\",\n\t\t\tpath:   \"spec.containers[0].command\",\n\t\t\tdata:   []byte(`{\"spec\": {\"containers\": [{\"command\": [\"/bin/bash\"]}]}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: []string{\"/bin/bash\"},\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAnArray\": {\n\t\t\treason: \"Requesting an non-object field path should fail\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.version: not an array\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAStringArray\": {\n\t\t\treason: \"Requesting an non-string-object field path should fail\",\n\t\t\tpath:   \"metadata.versions\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"versions\":[1,2]}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.versions: not an array of strings\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetStringArray(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetStringArray(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetStringArray(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetStringObject(t *testing.T) {\n\ttype want struct {\n\t\tvalue map[string]string\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"MetadataLabels\": {\n\t\t\treason: \"It should be possible to get a field from a nested object\",\n\t\t\tpath:   \"metadata.labels\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"labels\":{\"cool\":\"true\"}}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: map[string]string{\"cool\": \"true\"},\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAnObject\": {\n\t\t\treason: \"Requesting an non-object field path should fail\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.version: not an object\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAStringObject\": {\n\t\t\treason: \"Requesting an non-string-object field path should fail\",\n\t\t\tpath:   \"metadata.versions\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"versions\":{\"a\": 2}}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.versions: not an object with string field values\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetStringObject(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetStringObject(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetStringObject(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetBool(t *testing.T) {\n\ttype want struct {\n\t\tvalue bool\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"OwnerRefController\": {\n\t\t\treason: \"Requesting a boolean field path should work.\",\n\t\t\tpath:   \"metadata.ownerRefs[0].controller\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"ownerRefs\":[{\"controller\": true}]}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: true,\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"NotABool\": {\n\t\t\treason: \"Requesting an non-boolean field path should fail\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.name: not a bool\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetBool(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetBool(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetBool(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetNumber(t *testing.T) {\n\ttype want struct {\n\t\tvalue float64\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"MetadataVersion\": {\n\t\t\treason: \"Requesting a number field should work\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2.0}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: 2,\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"NotANumber\": {\n\t\t\treason: \"Requesting an non-number field path should fail\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.name: not a (float64) number\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetNumber(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetNumber(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetNumber(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetInteger(t *testing.T) {\n\ttype want struct {\n\t\tvalue int64\n\t\terr   error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"MetadataVersion\": {\n\t\t\treason: \"Requesting a number field should work\",\n\t\t\tpath:   \"metadata.version\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"version\":2}}`),\n\t\t\twant: want{\n\t\t\t\tvalue: 2,\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"NotANumber\": {\n\t\t\treason: \"Requesting an non-number field path should fail\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"metadata.name: not a (int64) number\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.GetInteger(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.GetNumber(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.value, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.GetNumber(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetValue(t *testing.T) {\n\ttype args struct {\n\t\tpath  string\n\t\tvalue any\n\t\topts  []PavedOption\n\t}\n\ttype want struct {\n\t\tobject map[string]any\n\t\terr    error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tdata   []byte\n\t\targs   args\n\t\twant   want\n\t}{\n\t\t\"MetadataName\": {\n\t\t\treason: \"Setting an object field should work\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"lame\"}}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"metadata.name\",\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"metadata\": map[string]any{\n\t\t\t\t\t\t\"name\": \"cool\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NonExistentMetadataName\": {\n\t\t\treason: \"Setting a non-existent object field should work\",\n\t\t\tdata:   []byte(`{}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"metadata.name\",\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"metadata\": map[string]any{\n\t\t\t\t\t\t\"name\": \"cool\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ContainerName\": {\n\t\t\treason: \"Setting a field of an object that is an array element should work\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"lame\"}]}}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"spec.containers[0].name\",\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"spec\": map[string]any{\n\t\t\t\t\t\t\"containers\": []any{\n\t\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\t\"name\": \"cool\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NonExistentContainerName\": {\n\t\t\treason: \"Setting a field of a non-existent object that is an array element should work\",\n\t\t\tdata:   []byte(`{}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"spec.containers[0].name\",\n\t\t\t\tvalue: \"cool\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"spec\": map[string]any{\n\t\t\t\t\t\t\"containers\": []any{\n\t\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\t\"name\": \"cool\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NewContainer\": {\n\t\t\treason: \"Growing an array object field should work\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"spec.containers[1].name\",\n\t\t\t\tvalue: \"cooler\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"spec\": map[string]any{\n\t\t\t\t\t\t\"containers\": []any{\n\t\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\t\"name\": \"cool\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\t\"name\": \"cooler\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NestedArray\": {\n\t\t\treason: \"Setting a value in a nested array should work\",\n\t\t\tdata:   []byte(`{}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"data[0][0]\",\n\t\t\t\tvalue: \"a\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"data\": []any{\n\t\t\t\t\t\t[]any{\"a\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"GrowNestedArray\": {\n\t\t\treason: \"Growing then setting a value in a nested array should work\",\n\t\t\tdata:   []byte(`{\"data\":[[\"a\"]]}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"data[0][1]\",\n\t\t\t\tvalue: \"b\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"data\": []any{\n\t\t\t\t\t\t[]any{\"a\", \"b\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"GrowArrayField\": {\n\t\t\treason: \"Growing then setting a value in an array field should work\",\n\t\t\tdata:   []byte(`{\"data\":[\"a\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"data[2]\",\n\t\t\t\tvalue: \"c\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"data\": []any{\"a\", nil, \"c\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"RejectsHighIndexes\": {\n\t\t\treason: \"Paths having indexes above the maximum default value are rejected\",\n\t\t\tdata:   []byte(`{\"data\":[\"a\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath:  fmt.Sprintf(\"data[%v]\", MaxFieldPathIndex+1),\n\t\t\t\tvalue: \"c\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"data\": []any{\"a\"}},\n\t\t\t\terr: errors.Wrap(errors.Errorf(\"found index above max (%[1]v > %[2]v): data[%[1]v]\",\n\t\t\t\t\tMaxFieldPathIndex+1, MaxFieldPathIndex), \"invalid segments\"),\n\t\t\t},\n\t\t},\n\t\t\"NotRejectsHighIndexesIfNoDefaultOptions\": {\n\t\t\treason: \"Paths having indexes above the maximum default value are not rejected if default disabled\",\n\t\t\tdata:   []byte(`{\"data\":[\"a\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath:  fmt.Sprintf(\"data[%v]\", MaxFieldPathIndex+1),\n\t\t\t\tvalue: \"c\",\n\t\t\t\topts:  []PavedOption{},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"data\": func() []any {\n\t\t\t\t\t\tres := make([]any, MaxFieldPathIndex+2)\n\t\t\t\t\t\tres[0] = \"a\"\n\t\t\t\t\t\tres[MaxFieldPathIndex+1] = \"c\"\n\t\t\t\t\t\treturn res\n\t\t\t\t\t}()},\n\t\t\t},\n\t\t},\n\t\t\"MapStringString\": {\n\t\t\treason: \"A map of string to string should be converted to a map of string to any\",\n\t\t\tdata:   []byte(`{\"metadata\":{}}`),\n\t\t\targs: args{\n\t\t\t\tpath:  \"metadata.labels\",\n\t\t\t\tvalue: map[string]string{\"cool\": \"very\"},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"metadata\": map[string]any{\n\t\t\t\t\t\t\"labels\": map[string]any{\"cool\": \"very\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"OwnerReference\": {\n\t\t\treason: \"An ObjectReference (i.e. struct) should be converted to a map of string to any\",\n\t\t\tdata:   []byte(`{\"metadata\":{}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"metadata.ownerRefs[0]\",\n\t\t\t\tvalue: metav1.OwnerReference{\n\t\t\t\t\tAPIVersion: \"v\",\n\t\t\t\t\tKind:       \"k\",\n\t\t\t\t\tName:       \"n\",\n\t\t\t\t\tUID:        types.UID(\"u\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"metadata\": map[string]any{\n\t\t\t\t\t\t\"ownerRefs\": []any{\n\t\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\t\"apiVersion\": \"v\",\n\t\t\t\t\t\t\t\t\"kind\":       \"k\",\n\t\t\t\t\t\t\t\t\"name\":       \"n\",\n\t\t\t\t\t\t\t\t\"uid\":        \"u\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NotAnArray\": {\n\t\t\treason: \"Indexing an object field should fail\",\n\t\t\tdata:   []byte(`{\"data\":{}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"data[0]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\"data\": map[string]any{}},\n\t\t\t\terr:    errors.New(\"data is not an array\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAnObject\": {\n\t\t\treason: \"Requesting a field in an array should fail\",\n\t\t\tdata:   []byte(`{\"data\":[]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"data.name\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\"data\": []any{}},\n\t\t\t\terr:    errors.New(\"data is not an object\"),\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\targs: args{\n\t\t\t\tpath: \"spec[]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{},\n\t\t\t\terr:    errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in, tc.args.opts...)\n\n\t\t\terr := p.SetValue(tc.args.path, tc.args.value)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.SetValue(%s, %v): %s: -want error, +got error:\\n%s\", tc.args.path, tc.args.value, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.object, p.object); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.SetValue(%s, %v): %s: -want, +got:\\n%s\", tc.args.path, tc.args.value, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExpandWildcards(t *testing.T) {\n\ttype want struct {\n\t\texpanded []string\n\t\terr      error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\tdata   []byte\n\t\twant   want\n\t}{\n\t\t\"NoWildcardExisting\": {\n\t\t\treason: \"It should return same path if no wildcard in an existing path\",\n\t\t\tpath:   \"password\",\n\t\t\tdata:   []byte(`{\"password\":\"top-secret\"}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"password\"},\n\t\t\t},\n\t\t},\n\t\t\"NoWildcardNonExisting\": {\n\t\t\treason: \"It should return no results if no wildcard in a non-existing path\",\n\t\t\tpath:   \"username\",\n\t\t\tdata:   []byte(`{\"password\":\"top-secret\"}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{},\n\t\t\t},\n\t\t},\n\t\t\"NestedNoWildcardExisting\": {\n\t\t\treason: \"It should return same path if no wildcard in an existing path\",\n\t\t\tpath:   \"items[0][1]\",\n\t\t\tdata:   []byte(`{\"items\":[[\"a\", \"b\"]]}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"items[0][1]\"},\n\t\t\t},\n\t\t},\n\t\t\"NestedNoWildcardNonExisting\": {\n\t\t\treason: \"It should return no results if no wildcard in a non-existing path\",\n\t\t\tpath:   \"items[0][5]\",\n\t\t\tdata:   []byte(`{\"items\":[[\"a\", \"b\"]]}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{},\n\t\t\t},\n\t\t},\n\t\t\"NestedArray\": {\n\t\t\treason: \"It should return all possible paths for an array\",\n\t\t\tpath:   \"items[*][*]\",\n\t\t\tdata:   []byte(`{\"items\":[[\"a\", \"b\", \"c\"], [\"d\"]]}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"items[0][0]\", \"items[0][1]\", \"items[0][2]\", \"items[1][0]\"},\n\t\t\t},\n\t\t},\n\t\t\"KeysOfMap\": {\n\t\t\treason: \"It should return all possible paths for a map in proper syntax\",\n\t\t\tpath:   \"items[*]\",\n\t\t\tdata:   []byte(`{\"items\":{ \"key1\": \"val1\", \"key2.as.annotation\": \"val2\"}}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"items.key1\", \"items[key2.as.annotation]\"},\n\t\t\t},\n\t\t},\n\t\t\"ArrayOfObjects\": {\n\t\t\treason: \"It should return all possible paths for an array of objects\",\n\t\t\tpath:   \"spec.containers[*][*]\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\", \"image\": \"latest\", \"args\": [\"start\", \"now\"]}]}}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"spec.containers[0].name\", \"spec.containers[0].image\", \"spec.containers[0].args\"},\n\t\t\t},\n\t\t},\n\t\t\"MultiLayer\": {\n\t\t\treason: \"It should return all possible paths for a multilayer input\",\n\t\t\tpath:   \"spec.containers[*].args[*]\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\", \"image\": \"latest\", \"args\": [\"start\", \"now\", \"debug\"]}]}}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"spec.containers[0].args[0]\", \"spec.containers[0].args[1]\", \"spec.containers[0].args[2]\"},\n\t\t\t},\n\t\t},\n\t\t\"WildcardInTheBeginning\": {\n\t\t\treason: \"It should return all possible paths for a multilayer input with wildcard in the beginning\",\n\t\t\tpath:   \"spec.containers[*].args[1]\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\", \"image\": \"latest\", \"args\": [\"start\", \"now\", \"debug\"]}]}}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"spec.containers[0].args[1]\"},\n\t\t\t},\n\t\t},\n\t\t\"WildcardAtTheEnd\": {\n\t\t\treason: \"It should return all possible paths for a multilayer input with wildcard at the end\",\n\t\t\tpath:   \"spec.containers[0].args[*]\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\", \"image\": \"latest\", \"args\": [\"start\", \"now\", \"debug\"]}]}}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{\"spec.containers[0].args[0]\", \"spec.containers[0].args[1]\", \"spec.containers[0].args[2]\"},\n\t\t\t},\n\t\t},\n\t\t\"NoData\": {\n\t\t\treason: \"If there is no input data, no expanded fields could be found\",\n\t\t\tpath:   \"metadata[*]\",\n\t\t\tdata:   nil,\n\t\t\twant: want{\n\t\t\t\texpanded: []string{},\n\t\t\t},\n\t\t},\n\t\t\"InsufficientContainers\": {\n\t\t\treason: \"Requesting a non-existent array element should return nothing\",\n\t\t\tpath:   \"spec.containers[1].args[*]\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\twant: want{\n\t\t\t\texpanded: []string{},\n\t\t\t},\n\t\t},\n\t\t\"UnexpectedWildcard\": {\n\t\t\treason: \"Requesting a wildcard for an object should fail\",\n\t\t\tpath:   \"spec.containers[0].name[*]\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrapf(errors.Errorf(\"%q: unexpected wildcard usage\", \"spec.containers[0].name\"), \"cannot expand wildcards for segments: %q\", \"spec.containers[0].name[*]\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAnArray\": {\n\t\t\treason: \"Indexing an object should fail\",\n\t\t\tpath:   \"metadata[1]\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"nope\":\"cool\"}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrapf(errors.New(\"metadata: not an array\"), \"cannot expand wildcards for segments: %q\", \"metadata[1]\"),\n\t\t\t},\n\t\t},\n\t\t\"NotAnObject\": {\n\t\t\treason: \"Requesting a field in an array should fail\",\n\t\t\tpath:   \"spec.containers[nope].name\",\n\t\t\tdata:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrapf(errors.New(\"spec.containers: not an object\"), \"cannot expand wildcards for segments: %q\", \"spec.containers.nope.name\"),\n\t\t\t},\n\t\t},\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\tgot, err := p.ExpandWildcards(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.ExpandWildcards(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.expanded, got, cmpopts.SortSlices(func(x, y string) bool {\n\t\t\t\treturn x < y\n\t\t\t})); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\np.ExpandWildcards(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDeleteField(t *testing.T) {\n\ttype args struct {\n\t\tpath string\n\t}\n\ttype want struct {\n\t\tobject map[string]any\n\t\terr    error\n\t}\n\tcases := map[string]struct {\n\t\treason string\n\t\tdata   []byte\n\t\targs   args\n\t\twant   want\n\t}{\n\t\t\"MalformedPath\": {\n\t\t\treason: \"Requesting an invalid field path should fail\",\n\t\t\targs: args{\n\t\t\t\tpath: \"spec[]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{},\n\t\t\t\terr:    errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),\n\t\t\t},\n\t\t},\n\t\t\"IndexGivenForNonArray\": {\n\t\t\treason: \"Trying to delete a numbered index from a map should fail.\",\n\t\t\tdata:   []byte(`{\"data\":{}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"data[0]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\"data\": map[string]any{}},\n\t\t\t\terr:    errors.Wrap(errors.New(\"not an array\"), \"cannot delete data[0]\"),\n\t\t\t},\n\t\t},\n\t\t\"KeyGivenForNonMap\": {\n\t\t\treason: \"Trying to delete a key from an array should fail.\",\n\t\t\tdata:   []byte(`{\"data\":[[\"a\"]]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"data[0].a\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\"data\": []any{[]any{\"a\"}}},\n\t\t\t\terr:    errors.Wrap(errors.New(\"not an object\"), \"cannot delete data[0].a\"),\n\t\t\t},\n\t\t},\n\t\t\"KeyGivenForNonMapInMiddle\": {\n\t\t\treason: \"If one of the segments that is a field corresponds to array, it should fail.\",\n\t\t\tdata:   []byte(`{\"data\":[{\"another\": \"field\"}]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"data.some.another\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\"data\": []any{\n\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\"another\": \"field\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\terr: errors.New(\"data is not an object\"),\n\t\t\t},\n\t\t},\n\t\t\"IndexGivenForNonArrayInMiddle\": {\n\t\t\treason: \"If one of the segments that is an index corresponds to map, it should fail.\",\n\t\t\tdata:   []byte(`{\"data\":{\"another\": [\"field\"]}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"data[0].another\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\"data\": map[string]any{\n\t\t\t\t\t\"another\": []any{\n\t\t\t\t\t\t\"field\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\terr: errors.New(\"data is not an array\"),\n\t\t\t},\n\t\t},\n\t\t\"ObjectField\": {\n\t\t\treason: \"Deleting a field from a map should work.\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"lame\"}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"metadata.name\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"metadata\": map[string]any{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ObjectSingleField\": {\n\t\t\treason: \"Deleting a field from a map should work.\",\n\t\t\tdata:   []byte(`{\"metadata\":{\"name\":\"lame\"}, \"olala\": {\"omama\": \"koala\"}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"metadata\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"olala\": map[string]any{\n\t\t\t\t\t\t\"omama\": \"koala\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ObjectLeafField\": {\n\t\t\treason: \"Deleting a field that is deep in the tree from a map should work.\",\n\t\t\tdata:   []byte(`{\"spec\":{\"some\": {\"more\": \"delete-me\"}}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"spec.some.more\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"spec\": map[string]any{\n\t\t\t\t\t\t\"some\": map[string]any{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ObjectMidField\": {\n\t\t\treason: \"Deleting a field that is in the middle of the tree from a map should work.\",\n\t\t\tdata:   []byte(`{\"spec\":{\"some\": {\"more\": \"delete-me\"}}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"spec.some\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"spec\": map[string]any{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ObjectInArray\": {\n\t\t\treason: \"Deleting a field that is in the middle of the tree from a map should work.\",\n\t\t\tdata:   []byte(`{\"spec\":[{\"some\": {\"more\": \"delete-me\"}}]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"spec[0].some.more\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"spec\": []any{\n\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\"some\": map[string]any{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ArrayFirstElement\": {\n\t\t\treason: \"Deleting the first element from an array should work\",\n\t\t\tdata:   []byte(`{\"items\":[\"a\", \"b\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[0]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{\n\t\t\t\t\t\t\"b\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ArrayLastElement\": {\n\t\t\treason: \"Deleting the last element from an array should work\",\n\t\t\tdata:   []byte(`{\"items\":[\"a\", \"b\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[1]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{\n\t\t\t\t\t\t\"a\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ArrayMidElement\": {\n\t\t\treason: \"Deleting an element that is neither first nor last from an array should work\",\n\t\t\tdata:   []byte(`{\"items\":[\"a\", \"b\", \"c\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[1]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{\n\t\t\t\t\t\t\"a\",\n\t\t\t\t\t\t\"c\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ArrayOnlyElements\": {\n\t\t\treason: \"Deleting the only element from an array should work\",\n\t\t\tdata:   []byte(`{\"items\":[\"a\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[0]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ArrayMultipleIndex\": {\n\t\t\treason: \"Deleting an element from an array of array should work\",\n\t\t\tdata:   []byte(`{\"items\":[[\"a\", \"b\"]]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[0][1]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{\n\t\t\t\t\t\t[]any{\n\t\t\t\t\t\t\t\"a\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"ArrayNoElement\": {\n\t\t\treason: \"Deleting an element from an empty array should work\",\n\t\t\tdata:   []byte(`{\"items\":[]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[0]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NonExistentPathInMap\": {\n\t\t\treason: \"It should be no-op if the field does not exist already.\",\n\t\t\tdata:   []byte(`{\"items\":[]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[0].metadata\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NonExistentPathInArray\": {\n\t\t\treason: \"It should be no-op if the field does not exist already.\",\n\t\t\tdata:   []byte(`{\"items\":{\"some\": \"other\"}}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items.metadata[0]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": map[string]any{\n\t\t\t\t\t\t\"some\": \"other\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NonExistentElementInArray\": {\n\t\t\treason: \"It should be no-op if the field does not exist already.\",\n\t\t\tdata:   []byte(`{\"items\":[\"some\", \"other\"]}`),\n\t\t\targs: args{\n\t\t\t\tpath: \"items[5]\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tobject: map[string]any{\n\t\t\t\t\t\"items\": []any{\n\t\t\t\t\t\t\"some\", \"other\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tin := make(map[string]any)\n\t\t\t_ = json.Unmarshal(tc.data, &in)\n\t\t\tp := Pave(in)\n\n\t\t\terr := p.DeleteField(tc.args.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.DeleteField(%s): %s: -want error, +got error:\\n%s\", tc.args.path, tc.reason, diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tc.want.object, p.object); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\np.DeleteField(%s): %s: -want, +got:\\n%s\", tc.args.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n"], "buggy_code_start_loc": [26, 19], "buggy_code_end_loc": [360, 821], "fixing_code_start_loc": [27, 20], "fixing_code_end_loc": [388, 855], "type": "CWE-400", "message": "crossplane-runtime is a set of go libraries used to build Kubernetes controllers in Crossplane and its related stacks. An out of memory panic vulnerability has been discovered in affected versions. Applications that use the `Paved` type's `SetValue` method with user provided input without proper validation might use excessive amounts of memory and cause an out of memory panic. In the fieldpath package, the Paved.SetValue method sets a value on the Paved object according to the provided path, without any validation. This allows setting values in slices at any provided index, which grows the target array up to the requested index, the index is currently capped at max uint32 (4294967295) given how indexes are parsed, but that is still an unnecessarily large value. If callers are not validating paths' indexes on their own, which most probably are not going to do, given that the input is parsed directly in the SetValue method, this could allow users to consume arbitrary amounts of memory. Applications that do not use the `Paved` type's `SetValue` method are not affected. This issue has been addressed in versions 0.16.1 and 0.19.2. Users are advised to upgrade. Users unable to upgrade can parse and validate the path before passing it to the `SetValue` method of the `Paved` type, constraining the index size as deemed appropriate.", "other": {"cve": {"id": "CVE-2023-27483", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-09T21:15:11.720", "lastModified": "2023-03-17T16:11:00.127", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "crossplane-runtime is a set of go libraries used to build Kubernetes controllers in Crossplane and its related stacks. An out of memory panic vulnerability has been discovered in affected versions. Applications that use the `Paved` type's `SetValue` method with user provided input without proper validation might use excessive amounts of memory and cause an out of memory panic. In the fieldpath package, the Paved.SetValue method sets a value on the Paved object according to the provided path, without any validation. This allows setting values in slices at any provided index, which grows the target array up to the requested index, the index is currently capped at max uint32 (4294967295) given how indexes are parsed, but that is still an unnecessarily large value. If callers are not validating paths' indexes on their own, which most probably are not going to do, given that the input is parsed directly in the SetValue method, this could allow users to consume arbitrary amounts of memory. Applications that do not use the `Paved` type's `SetValue` method are not affected. This issue has been addressed in versions 0.16.1 and 0.19.2. Users are advised to upgrade. Users unable to upgrade can parse and validate the path before passing it to the `SetValue` method of the `Paved` type, constraining the index size as deemed appropriate."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:crossplane:crossplane-runtime:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.19.0", "versionEndExcluding": "0.19.2", "matchCriteriaId": "E12C35E6-F04C-408B-88A3-B56D0012BCE4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:crossplane:crossplane-runtime:0.16.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4B04C9A-761E-42F9-AEF6-2E8AE06CB776"}]}]}], "references": [{"url": "https://github.com/crossplane/crossplane-runtime/commit/53508a9f4374604db140dd8ab2fa52276441e738", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/crossplane/crossplane-runtime/security/advisories/GHSA-vfvj-3m3g-m532", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/crossplane/crossplane-runtime/commit/53508a9f4374604db140dd8ab2fa52276441e738"}}