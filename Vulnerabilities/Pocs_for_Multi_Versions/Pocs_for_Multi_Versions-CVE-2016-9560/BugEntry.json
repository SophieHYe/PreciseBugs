{"buggy_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_tvp.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_fix.h\"\n#include \"jpc_dec.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_mct.h\"\n#include \"jpc_t2dec.h\"\n#include \"jpc_t1dec.h\"\n#include \"jpc_math.h\"\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n#define\tJPC_MHSOC\t0x0001\n  /* In the main header, expecting a SOC marker segment. */\n#define\tJPC_MHSIZ\t0x0002\n  /* In the main header, expecting a SIZ marker segment. */\n#define\tJPC_MH\t\t0x0004\n  /* In the main header, expecting \"other\" marker segments. */\n#define\tJPC_TPHSOT\t0x0008\n  /* In a tile-part header, expecting a SOT marker segment. */\n#define\tJPC_TPH\t\t0x0010\n  /* In a tile-part header, expecting \"other\" marker segments. */\n#define\tJPC_MT\t\t0x0020\n  /* In the main trailer. */\n\ntypedef struct {\n\n\tuint_fast16_t id;\n\t/* The marker segment type. */\n\n\tint validstates;\n\t/* The states in which this type of marker segment can be\n\t  validly encountered. */\n\n\tint (*action)(jpc_dec_t *dec, jpc_ms_t *ms);\n\t/* The action to take upon encountering this type of marker segment. */\n\n} jpc_dec_mstabent_t;\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n/* COD/COC parameters have been specified. */\n#define\tJPC_CSET\t0x0001\n/* QCD/QCC parameters have been specified. */\n#define\tJPC_QSET\t0x0002\n/* COD/COC parameters set from a COC marker segment. */\n#define\tJPC_COC\t0x0004\n/* QCD/QCC parameters set from a QCC marker segment. */\n#define\tJPC_QCC\t0x0008\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out);\n\njpc_ppxstab_t *jpc_ppxstab_create(void);\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab);\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents);\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent);\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab);\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab);\njpc_ppxstabent_t *jpc_ppxstabent_create(void);\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent);\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist);\njpc_streamlist_t *jpc_streamlist_create(void);\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream);\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno);\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist);\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno);\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps);\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod);\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc);\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd);\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc);\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn);\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp);\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset);\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc);\n\nstatic int jpc_dec_decode(jpc_dec_t *dec);\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts,\n  jas_stream_t *in);\nstatic void jpc_dec_destroy(jpc_dec_t *dec);\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize);\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps);\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits);\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic jpc_dec_importopts_t *jpc_dec_opts_create(const char *optstr);\nstatic void jpc_dec_opts_destroy(jpc_dec_importopts_t *opts);\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\njpc_dec_mstabent_t jpc_dec_mstab[] = {\n\t{JPC_MS_SOC, JPC_MHSOC, jpc_dec_process_soc},\n\t{JPC_MS_SOT, JPC_MH | JPC_TPHSOT, jpc_dec_process_sot},\n\t{JPC_MS_SOD, JPC_TPH, jpc_dec_process_sod},\n\t{JPC_MS_EOC, JPC_TPHSOT, jpc_dec_process_eoc},\n\t{JPC_MS_SIZ, JPC_MHSIZ, jpc_dec_process_siz},\n\t{JPC_MS_COD, JPC_MH | JPC_TPH, jpc_dec_process_cod},\n\t{JPC_MS_COC, JPC_MH | JPC_TPH, jpc_dec_process_coc},\n\t{JPC_MS_RGN, JPC_MH | JPC_TPH, jpc_dec_process_rgn},\n\t{JPC_MS_QCD, JPC_MH | JPC_TPH, jpc_dec_process_qcd},\n\t{JPC_MS_QCC, JPC_MH | JPC_TPH, jpc_dec_process_qcc},\n\t{JPC_MS_POC, JPC_MH | JPC_TPH, jpc_dec_process_poc},\n\t{JPC_MS_TLM, JPC_MH, 0},\n\t{JPC_MS_PLM, JPC_MH, 0},\n\t{JPC_MS_PLT, JPC_TPH, 0},\n\t{JPC_MS_PPM, JPC_MH, jpc_dec_process_ppm},\n\t{JPC_MS_PPT, JPC_TPH, jpc_dec_process_ppt},\n\t{JPC_MS_SOP, 0, 0},\n\t{JPC_MS_CRG, JPC_MH, jpc_dec_process_crg},\n\t{JPC_MS_COM, JPC_MH | JPC_TPH, jpc_dec_process_com},\n\t{0, JPC_MH | JPC_TPH, jpc_dec_process_unk}\n};\n\n/******************************************************************************\\\n* The main entry point for the JPEG-2000 decoder.\n\\******************************************************************************/\n\njas_image_t *jpc_decode(jas_stream_t *in, const char *optstr)\n{\n\tjpc_dec_importopts_t *opts;\n\tjpc_dec_t *dec;\n\tjas_image_t *image;\n\n\tdec = 0;\n\topts = 0;\n\n\tJAS_DBGLOG(100, (\"jpc_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(opts = jpc_dec_opts_create(optstr))) {\n\t\tgoto error;\n\t}\n\n\tjpc_initluts();\n\n\tif (!(dec = jpc_dec_create(opts, in))) {\n\t\tgoto error;\n\t}\n\tjpc_dec_opts_destroy(opts);\n\topts = 0;\n\n\t/* Do most of the work. */\n\tif (jpc_dec_decode(dec)) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_numcmpts(dec->image) >= 3) {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(dec->image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(dec->image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Save the return value. */\n\timage = dec->image;\n\n\t/* Stop the image from being discarded. */\n\tdec->image = 0;\n\n\t/* Destroy decoder. */\n\tjpc_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (opts) {\n\t\tjpc_dec_opts_destroy(opts);\n\t}\n\tif (dec) {\n\t\tjpc_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n\ntypedef enum {\n\tOPT_MAXLYRS,\n\tOPT_MAXPKTS,\n\tOPT_MAXSAMPLES,\n\tOPT_DEBUG\n} optid_t;\n\nstatic jas_taginfo_t decopts[] = {\n\t{OPT_MAXLYRS, \"maxlyrs\"},\n\t{OPT_MAXPKTS, \"maxpkts\"},\n\t{OPT_MAXSAMPLES, \"max_samples\"},\n\t{OPT_DEBUG, \"debug\"},\n\t{-1, 0}\n};\n\nstatic jpc_dec_importopts_t *jpc_dec_opts_create(const char *optstr)\n{\n\tjpc_dec_importopts_t *opts;\n\tjas_tvparser_t *tvp;\n\n\topts = 0;\n\n\tif (!(opts = jas_malloc(sizeof(jpc_dec_importopts_t)))) {\n\t\tgoto error;\n\t}\n\n\topts->debug = 0;\n\topts->maxlyrs = JPC_MAXLYRS;\n\topts->maxpkts = -1;\n\topts->max_samples = JAS_DEC_DEFAULT_MAX_SAMPLES;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXLYRS:\n\t\t\topts->maxlyrs = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\topts->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXPKTS:\n\t\t\topts->maxpkts = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXSAMPLES:\n\t\t\topts->max_samples = strtoull(jas_tvparser_getval(tvp), 0, 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn opts;\n\nerror:\n\tif (opts) {\n\t\tjpc_dec_opts_destroy(opts);\n\t}\n\treturn 0;\n}\n\nstatic void jpc_dec_opts_destroy(jpc_dec_importopts_t *opts)\n{\n\tjas_free(opts);\n}\n\n/******************************************************************************\\\n* Code for table-driven code stream decoder.\n\\******************************************************************************/\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id)\n{\n\tjpc_dec_mstabent_t *mstabent;\n\tfor (mstabent = jpc_dec_mstab; mstabent->id != 0; ++mstabent) {\n\t\tif (mstabent->id == id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mstabent;\n}\n\nstatic int jpc_dec_decode(jpc_dec_t *dec)\n{\n\tjpc_ms_t *ms;\n\tjpc_dec_mstabent_t *mstabent;\n\tint ret;\n\tjpc_cstate_t *cstate;\n\n\tif (!(cstate = jpc_cstate_create())) {\n\t\treturn -1;\n\t}\n\tdec->cstate = cstate;\n\n\t/* Initially, we should expect to encounter a SOC marker segment. */\n\tdec->state = JPC_MHSOC;\n\n\tfor (;;) {\n\n\t\t/* Get the next marker segment in the code stream. */\n\t\tif (!(ms = jpc_getms(dec->in, cstate))) {\n\t\t\tjas_eprintf(\"cannot get marker segment\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmstabent = jpc_dec_mstab_lookup(ms->id);\n\t\tassert(mstabent);\n\n\t\t/* Ensure that this type of marker segment is permitted\n\t\t  at this point in the code stream. */\n\t\tif (!(dec->state & mstabent->validstates)) {\n\t\t\tjas_eprintf(\"unexpected marker segment type\\n\");\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Process the marker segment. */\n\t\tif (mstabent->action) {\n\t\t\tret = (*mstabent->action)(dec, ms);\n\t\t} else {\n\t\t\t/* No explicit action is required. */\n\t\t\tret = 0;\n\t\t}\n\n\t\t/* Destroy the marker segment. */\n\t\tjpc_ms_destroy(ms);\n\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t} else if (ret > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint cmptno;\n\tjpc_dec_cmpt_t *cmpt;\n\tjpc_crg_t *crg;\n\n\tcrg = &ms->parms.crg;\n\tfor (cmptno = 0, cmpt = dec->cmpts; cmptno < dec->numcomps; ++cmptno,\n\t  ++cmpt) {\n\t\t/* Ignore the information in the CRG marker segment for now.\n\t\t  This information serves no useful purpose for decoding anyhow.\n\t\t  Some other parts of the code need to be changed if these lines\n\t\t  are uncommented.\n\t\tcmpt->hsubstep = crg->comps[cmptno].hoff;\n\t\tcmpt->vsubstep = crg->comps[cmptno].voff;\n\t\t*/\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate warnings about unused variables. */\n\tms = 0;\n\n\t/* We should expect to encounter a SIZ marker segment next. */\n\tdec->state = JPC_MHSIZ;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tjas_image_cmptparm_t *compinfos;\n\tjas_image_cmptparm_t *compinfo;\n\tjpc_dec_cmpt_t *cmpt;\n\tint cmptno;\n\n\tif (dec->state == JPC_MH) {\n\n\t\tif (!(compinfos = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jas_image_cmptparm_t)))) {\n\t\t\tabort();\n\t\t}\n\t\tfor (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;\n\t\t  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {\n\t\t\tcompinfo->tlx = 0;\n\t\t\tcompinfo->tly = 0;\n\t\t\tcompinfo->prec = cmpt->prec;\n\t\t\tcompinfo->sgnd = cmpt->sgnd;\n\t\t\tcompinfo->width = cmpt->width;\n\t\t\tcompinfo->height = cmpt->height;\n\t\t\tcompinfo->hstep = cmpt->hstep;\n\t\t\tcompinfo->vstep = cmpt->vstep;\n\t\t}\n\n\t\tif (!(dec->image = jas_image_create(dec->numcomps, compinfos,\n\t\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\tjas_free(compinfos);\n\t\t\treturn -1;\n\t\t}\n\t\tjas_free(compinfos);\n\n\t\t/* Is the packet header information stored in PPM marker segments in\n\t\t  the main header? */\n\t\tif (dec->ppmstab) {\n\t\t\t/* Convert the PPM marker segment data into a collection of streams\n\t\t\t  (one stream per tile-part). */\n\t\t\tif (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t\t\tdec->ppmstab = 0;\n\t\t}\n\t}\n\n\tif (sot->len > 0) {\n\t\tdec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -\n\t\t  4 + sot->len;\n\t} else {\n\t\tdec->curtileendoff = 0;\n\t}\n\n\tif (JAS_CAST(int, sot->tileno) >= dec->numtiles) {\n\t\tjas_eprintf(\"invalid tile number in SOT marker segment\\n\");\n\t\treturn -1;\n\t}\n\t/* Set the current tile. */\n\tdec->curtile = &dec->tiles[sot->tileno];\n\ttile = dec->curtile;\n\t/* Ensure that this is the expected part number. */\n\tif (sot->partno != tile->partno) {\n\t\treturn -1;\n\t}\n\tif (tile->numparts > 0 && sot->partno >= tile->numparts) {\n\t\treturn -1;\n\t}\n\tif (!tile->numparts && sot->numparts > 0) {\n\t\ttile->numparts = sot->numparts;\n\t}\n\n\ttile->pptstab = 0;\n\n\tswitch (tile->state) {\n\tcase JPC_TILE_INIT:\n\t\t/* This is the first tile-part for this tile. */\n\t\ttile->state = JPC_TILE_ACTIVE;\n\t\tassert(!tile->cp);\n\t\tif (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_resetflags(dec->cp);\n\t\tbreak;\n\tdefault:\n\t\tif (sot->numparts == sot->partno - 1) {\n\t\t\ttile->state = JPC_TILE_ACTIVELAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Note: We do not increment the expected tile-part number until\n\t  all processing for this tile-part is complete. */\n\n\t/* We should expect to encounter other tile-part header marker\n\t  segments next. */\n\tdec->state = JPC_TPH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tint pos;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tif (!(tile = dec->curtile)) {\n\t\treturn -1;\n\t}\n\n\tif (!tile->partno) {\n\t\tif (!jpc_dec_cp_isvalid(tile->cp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_prepare(tile->cp);\n\t\tif (jpc_dec_tileinit(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Are packet headers stored in the main header or tile-part header? */\n\tif (dec->pkthdrstreams) {\n\t\t/* Get the stream containing the packet header data for this\n\t\t  tile-part. */\n\t\tif (!(tile->pkthdrstream = jpc_streamlist_remove(dec->pkthdrstreams, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (tile->pptstab) {\n\t\tif (!tile->pkthdrstream) {\n\t\t\tif (!(tile->pkthdrstream = jas_stream_memopen(0, 0))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tpos = jas_stream_tell(tile->pkthdrstream);\n\t\tjas_stream_seek(tile->pkthdrstream, 0, SEEK_END);\n\t\tif (jpc_pptstabwrite(tile->pkthdrstream, tile->pptstab)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_stream_seek(tile->pkthdrstream, pos, SEEK_SET);\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\tif (jas_getdbglevel() >= 10) {\n\t\tjpc_dec_dump(dec, stderr);\n\t}\n\n\tif (jpc_dec_decodepkts(dec, (tile->pkthdrstream) ? tile->pkthdrstream :\n\t  dec->in, dec->in)) {\n\t\tjas_eprintf(\"jpc_dec_decodepkts failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Gobble any unconsumed tile data. */\n\tif (dec->curtileendoff > 0) {\n\t\tlong curoff;\n\t\tuint_fast32_t n;\n\t\tcuroff = jas_stream_getrwcount(dec->in);\n\t\tif (curoff < dec->curtileendoff) {\n\t\t\tn = dec->curtileendoff - curoff;\n\t\t\tjas_eprintf(\"warning: ignoring trailing garbage (%lu bytes)\\n\",\n\t\t\t  (unsigned long) n);\n\n\t\t\twhile (n-- > 0) {\n\t\t\t\tif (jas_stream_getc(dec->in) == EOF) {\n\t\t\t\t\tjas_eprintf(\"read error\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curoff > dec->curtileendoff) {\n\t\t\tjas_eprintf(\"warning: not enough tile data (%lu bytes)\\n\",\n\t\t\t  (unsigned long) curoff - dec->curtileendoff);\n\t\t}\n\n\t}\n\n\tif (tile->numparts > 0 && tile->partno == tile->numparts - 1) {\n\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\tdec->curtile = 0;\n\n\t/* Increment the expected tile-part number. */\n\t++tile->partno;\n\n\t/* We should expect to encounter a SOT marker segment next. */\n\tdec->state = JPC_TPHSOT;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_prc_t *prc;\n\tint bndno;\n\tjpc_tsfb_band_t *bnd;\n\tint bandno;\n\tjpc_dec_ccp_t *ccp;\n\tint prccnt;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkcnt;\n\tuint_fast32_t tlprcxstart;\n\tuint_fast32_t tlprcystart;\n\tuint_fast32_t brprcxend;\n\tuint_fast32_t brprcyend;\n\tuint_fast32_t tlcbgxstart;\n\tuint_fast32_t tlcbgystart;\n\tuint_fast32_t brcbgxend;\n\tuint_fast32_t brcbgyend;\n\tuint_fast32_t cbgxstart;\n\tuint_fast32_t cbgystart;\n\tuint_fast32_t cbgxend;\n\tuint_fast32_t cbgyend;\n\tuint_fast32_t tlcblkxstart;\n\tuint_fast32_t tlcblkystart;\n\tuint_fast32_t brcblkxend;\n\tuint_fast32_t brcblkyend;\n\tuint_fast32_t cblkxstart;\n\tuint_fast32_t cblkystart;\n\tuint_fast32_t cblkxend;\n\tuint_fast32_t cblkyend;\n\tuint_fast32_t tmpxstart;\n\tuint_fast32_t tmpystart;\n\tuint_fast32_t tmpxend;\n\tuint_fast32_t tmpyend;\n\tjpc_dec_cp_t *cp;\n\tjpc_tsfb_band_t bnds[64];\n\tjpc_pchg_t *pchg;\n\tint pchgno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tcp = tile->cp;\n\ttile->realmode = 0;\n\tif (cp->mctid == JPC_MCT_ICT) {\n\t\ttile->realmode = 1;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tif (ccp->qmfbid == JPC_COX_INS) {\n\t\t\ttile->realmode = 1;\n\t\t}\n\t\ttcomp->numrlvls = ccp->numrlvls;\n\t\tif (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,\n\t\t  sizeof(jpc_dec_rlvl_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,\n\t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),\n\t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,\n\t\t  cmpt->vstep)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,\n\t\t  tcomp->numrlvls - 1))) {\n\t\t\treturn -1;\n\t\t}\n\t\t{\n\t\t\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data),\n\t\t\t  jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data),\n\t\t\t  jas_seq2d_yend(tcomp->data), bnds);\n\t\t}\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\trlvl->bands = 0;\n\t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];\n\t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];\n\t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>\n\t\t\t  rlvl->prcwidthexpn;\n\t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>\n\t\t\t  rlvl->prcheightexpn;\n\t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {\n\t\t\t\trlvl->bands = 0;\n\t\t\t\trlvl->numprcs = 0;\n\t\t\t\trlvl->numhprcs = 0;\n\t\t\t\trlvl->numvprcs = 0;\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (!rlvlno) {\n\t\t\t\ttlcbgxstart = tlprcxstart;\n\t\t\t\ttlcbgystart = tlprcystart;\n\t\t\t\tbrcbgxend = brprcxend;\n\t\t\t\tbrcbgyend = brprcyend;\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t\t\t} else {\n\t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);\n\t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);\n\t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);\n\t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t\t\t}\n\t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,\n\t\t\t  rlvl->cbgwidthexpn);\n\t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,\n\t\t\t  rlvl->cbgheightexpn);\n\n\t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\t\t\tif (!(rlvl->bands = jas_alloc2(rlvl->numbands,\n\t\t\t  sizeof(jpc_dec_band_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +\n\t\t\t\t  bandno + 1);\n\t\t\t\tbnd = &bnds[bndno];\n\n\t\t\t\tband->orient = bnd->orient;\n\t\t\t\tband->stepsize = ccp->stepsizes[bndno];\n\t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,\n\t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);\n\t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,\n\t\t\t\t  cmpt->prec + band->analgain);\n\t\t\t\tband->numbps = ccp->numguardbits +\n\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?\n\t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;\n\t\t\t\tband->data = 0;\n\t\t\t\tband->prcs = 0;\n\t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart,\n\t\t\t\t  bnd->locystart, bnd->locxend, bnd->locyend);\n\t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);\n\n\t\t\t\tassert(rlvl->numprcs);\n\n\t\t\t\tif (!(band->prcs = jas_alloc2(rlvl->numprcs,\n\t\t\t\t  sizeof(jpc_dec_prc_t)))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n/************************************************/\n\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\tcbgystart = tlcbgystart;\n\t\t\t\tfor (prccnt = rlvl->numprcs, prc = band->prcs;\n\t\t\t\t  prccnt > 0; --prccnt, ++prc) {\n\t\t\t\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);\n\t\t\t\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);\n\t\t\t\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xstart(band->data)));\n\t\t\t\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_ystart(band->data)));\n\t\t\t\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xend(band->data)));\n\t\t\t\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_yend(band->data)));\n\t\t\t\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {\n\t\t\t\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>\n\t\t\t\t\t\t  rlvl->cblkwidthexpn;\n\t\t\t\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>\n\t\t\t\t\t\t  rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\t\t\t\t\t\tassert(prc->numcblks > 0);\n\n\t\t\t\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->cblks = jas_alloc2(prc->numcblks,\n\t\t\t\t\t\t  sizeof(jpc_dec_cblk_t)))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\tcblkystart = cbgystart;\n\t\t\t\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks;\n\t\t\t\t\t\t  cblkcnt > 0;) {\n\t\t\t\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);\n\t\t\t\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);\n\t\t\t\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);\n\t\t\t\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);\n\t\t\t\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);\n\t\t\t\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);\n\t\t\t\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {\n\t\t\t\t\t\t\t\tcblk->firstpassno = -1;\n\t\t\t\t\t\t\t\tcblk->mqdec = 0;\n\t\t\t\t\t\t\t\tcblk->nulldec = 0;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tcblk->numpasses = 0;\n\t\t\t\t\t\t\t\tcblk->segs.head = 0;\n\t\t\t\t\t\t\t\tcblk->segs.tail = 0;\n\t\t\t\t\t\t\t\tcblk->curseg = 0;\n\t\t\t\t\t\t\t\tcblk->numimsbs = 0;\n\t\t\t\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0,\n\t\t\t\t\t\t\t\t  0))) {\n\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data,\n\t\t\t\t\t\t\t\t  tmpxstart, tmpystart, tmpxend, tmpyend);\n\t\t\t\t\t\t\t\t++cblk;\n\t\t\t\t\t\t\t\t--cblkcnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;\n\t\t\t\t\t\t\tif (cblkxstart >= cbgxend) {\n\t\t\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprc->cblks = 0;\n\t\t\t\t\t\tprc->incltagtree = 0;\n\t\t\t\t\t\tprc->numimsbstagtree = 0;\n\t\t\t\t\t}\n\t\t\t\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;\n\t\t\t\t\tif (cbgxstart >= brcbgxend) {\n\t\t\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;\n\t\t\t\t\t}\n\n\t\t\t\t}\n/********************************************/\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(tile->pi = jpc_dec_pi_create(dec, tile))) {\n\t\treturn -1;\n\t}\n\n\tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);\n\t  ++pchgno) {\n\t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));\n\t\tassert(pchg);\n\t\tjpc_pi_addpchg(tile->pi, pchg);\n\t}\n\tjpc_pi_init(tile->pi);\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint bandno;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tjpc_dec_prc_t *prc;\n\tjpc_dec_seg_t *seg;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tif (tile->tcomps) {\n\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t\t  ++rlvlno, ++rlvl) {\n\t\t\t\tif (!rlvl->bands) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t\t\t  ++bandno, ++band) {\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno <\n\t\t\t\t\t\t  rlvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno <\n\t\t\t\t\t\t\t  prc->numcblks; ++cblkno, ++cblk) {\n\n\t\t\t\t\t\t\t\twhile (cblk->segs.head) {\n\t\t\t\t\t\t\t\t\tseg = cblk->segs.head;\n\t\t\t\t\t\t\t\t\tjpc_seglist_remove(&cblk->segs, seg);\n\t\t\t\t\t\t\t\t\tjpc_seg_destroy(seg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->data);\n\t\t\t\t\t\t\t\tif (cblk->mqdec) {\n\t\t\t\t\t\t\t\t\tjpc_mqdec_destroy(cblk->mqdec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->nulldec) {\n\t\t\t\t\t\t\t\t\tjpc_bitstream_close(cblk->nulldec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->flags) {\n\t\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->incltagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->incltagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->numimsbstagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->numimsbstagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->cblks) {\n\t\t\t\t\t\t\t\tjas_free(prc->cblks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (band->data) {\n\t\t\t\t\t\tjas_matrix_destroy(band->data);\n\t\t\t\t\t}\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tjas_free(band->prcs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rlvl->bands) {\n\t\t\t\t\tjas_free(rlvl->bands);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tcomp->rlvls) {\n\t\t\t\tjas_free(tcomp->rlvls);\n\t\t\t}\n\t\t\tif (tcomp->data) {\n\t\t\t\tjas_matrix_destroy(tcomp->data);\n\t\t\t}\n\t\t\tif (tcomp->tsfb) {\n\t\t\t\tjpc_tsfb_destroy(tcomp->tsfb);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tile->cp) {\n\t\tjpc_dec_cp_destroy(tile->cp);\n\t\t//tile->cp = 0;\n\t}\n\tif (tile->tcomps) {\n\t\tjas_free(tile->tcomps);\n\t\t//tile->tcomps = 0;\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t\t//tile->pi = 0;\n\t}\n\tif (tile->pkthdrstream) {\n\t\tjas_stream_close(tile->pkthdrstream);\n\t\t//tile->pkthdrstream = 0;\n\t}\n\tif (tile->pptstab) {\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\t//tile->pptstab = 0;\n\t}\n\n\ttile->state = JPC_TILE_DONE;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tint i;\n\tint j;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tint compno;\n\tint rlvlno;\n\tint bandno;\n\tint adjust;\n\tint v;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (jpc_dec_decodecblks(dec, tile)) {\n\t\tjas_eprintf(\"jpc_dec_decodecblks failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Perform dequantization. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tif (!rlvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjpc_undo_roi(band->data, band->roishift, ccp->roishift -\n\t\t\t\t  band->roishift, band->numbps);\n\t\t\t\tif (tile->realmode) {\n\t\t\t\t\tjas_matrix_asl(band->data, JPC_FIX_FRACBITS);\n\t\t\t\t\tjpc_dequantize(band->data, band->absstepsize);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply an inverse wavelet transform if necessary. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tjpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);\n\t}\n\n\n\t/* Apply an inverse intercomponent transform if necessary. */\n\tswitch (tile->cp->mctid) {\n\tcase JPC_MCT_RCT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"RCT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec->image)) {\n\t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"ICT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec->image)) {\n\t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\t}\n\n\t/* Perform rounding and convert to integer values. */\n\tif (tile->realmode) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t\tv = jas_matrix_get(tcomp->data, i, j);\n\t\t\t\t\tv = jpc_fix_round(v);\n\t\t\t\t\tjas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform level shift. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tadjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));\n\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t*jas_matrix_getref(tcomp->data, i, j) += adjust;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform clipping. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tjpc_fix_t mn;\n\t\tjpc_fix_t mx;\n\t\tmn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);\n\t\tmx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<\n\t\t  cmpt->prec) - 1);\n\t\tjas_matrix_clip(tcomp->data, mn, mx);\n\t}\n\n\t/* XXX need to free tsfb struct */\n\n\t/* Write the data for each component of the image. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tif (jas_image_writecmpt(dec->image, compno, tcomp->xstart -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(\n\t\t  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {\n\t\t\tjas_eprintf(\"write component failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t/* If the tile has not yet been finalized, finalize it. */\n\t\t// OLD CODE: jpc_dec_tilefini(dec, tile);\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}\n\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\tsize_t num_samples;\n\tsize_t num_samples_delta;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tnum_samples = 0;\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\n\t\tif (!jas_safe_size_mul(cmpt->width, cmpt->height, &num_samples_delta)) {\n\t\t\tjas_eprintf(\"image too large\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_safe_size_add(num_samples, num_samples_delta, &num_samples)) {\n\t\t\tjas_eprintf(\"image too large\\n\");\n\t\t}\n\t}\n\n\tif (dec->max_samples > 0 && num_samples > dec->max_samples) {\n\t\tjas_eprintf(\"maximum number of samples exceeded (%zu > %zu)\\n\",\n\t\t  num_samples, dec->max_samples);\n\t\treturn -1;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcod(dec->cp, cod);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcod(tile->cp, cod);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, rgn->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in RGN marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromrgn(dec->cp, rgn);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromrgn(tile->cp, rgn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcd(dec->cp, qcd);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcd(tile->cp, qcd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, qcc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in QCC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcc(dec->cp, qcc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcc(tile->cp, qcc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_dec_tile_t *tile;\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tif (jpc_dec_cp_setfrompoc(dec->cp, poc, 1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!tile->partno) {\n\t\t\tif (jpc_dec_cp_setfrompoc(tile->cp, poc, (!tile->partno))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tjpc_pi_addpchgfrompoc(tile->pi, poc);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tjpc_ppxstabent_t *ppmstabent;\n\n\tif (!dec->ppmstab) {\n\t\tif (!(dec->ppmstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(ppmstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tppmstabent->ind = ppm->ind;\n\tppmstabent->data = ppm->data;\n\tppm->data = 0;\n\tppmstabent->len = ppm->len;\n\tif (jpc_ppxstab_insert(dec->ppmstab, ppmstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tjpc_dec_tile_t *tile;\n\tjpc_ppxstabent_t *pptstabent;\n\n\ttile = dec->curtile;\n\tif (!tile->pptstab) {\n\t\tif (!(tile->pptstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(pptstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tpptstabent->ind = ppt->ind;\n\tpptstabent->data = ppt->data;\n\tppt->data = 0;\n\tpptstabent->len = ppt->len;\n\tif (jpc_ppxstab_insert(tile->pptstab, pptstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\tms = 0;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\n\tjas_eprintf(\"warning: ignoring unknown marker segment (0x%x)\\n\",\n\t  ms->id);\n\tjpc_ms_dump(ms, stderr);\n\treturn 0;\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)\n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_alloc2(cp->numcomps, sizeof(jpc_dec_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tgoto error;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\nerror:\n\tif (cp) {\n\t\tjpc_dec_cp_destroy(cp);\n\t}\n\treturn 0;\n}\n\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_cp_t *newcp;\n\tjpc_dec_ccp_t *newccp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(newcp = jpc_dec_cp_create(cp->numcomps))) {\n\t\treturn 0;\n\t}\n\tnewcp->flags = cp->flags;\n\tnewcp->prgord = cp->prgord;\n\tnewcp->numlyrs = cp->numlyrs;\n\tnewcp->mctid = cp->mctid;\n\tnewcp->csty = cp->csty;\n\tjpc_pchglist_destroy(newcp->pchglist);\n\tnewcp->pchglist = 0;\n\tif (!(newcp->pchglist = jpc_pchglist_copy(cp->pchglist))) {\n\t\tjas_free(newcp);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, newccp = newcp->ccps, ccp = cp->ccps;\n\t  compno < cp->numcomps;\n\t  ++compno, ++newccp, ++ccp) {\n\t\t*newccp = *ccp;\n\t}\n\treturn newcp;\n}\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tcp->flags &= (JPC_CSET | JPC_QSET);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t}\n}\n\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp)\n{\n\tif (cp->ccps) {\n\t\tjas_free(cp->ccps);\n\t}\n\tif (cp->pchglist) {\n\t\tjpc_pchglist_destroy(cp->pchglist);\n\t}\n\tjas_free(cp);\n}\n\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp)\n{\n\tuint_fast16_t compcnt;\n\tjpc_dec_ccp_t *ccp;\n\n\tif (!(cp->flags & JPC_CSET) || !(cp->flags & JPC_QSET)) {\n\t\treturn 0;\n\t}\n\tfor (compcnt = cp->numcomps, ccp = cp->ccps; compcnt > 0; --compcnt,\n\t  ++ccp) {\n\t\t/* Is there enough step sizes for the number of bands? */\n\t\tif ((ccp->qsty != JPC_QCX_SIQNT && JAS_CAST(int, ccp->numstepsizes) < 3 *\n\t\t  ccp->numrlvls - 2) || (ccp->qsty == JPC_QCX_SIQNT &&\n\t\t  ccp->numstepsizes != 1)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n//jas_eprintf(\"DEBUG %d %d %d %d %d\\n\", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}\n\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tint i;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tif (!(ccp->csty & JPC_COX_PRT)) {\n\t\t\tfor (i = 0; i < JPC_MAXRLVLS; ++i) {\n\t\t\t\tccp->prcwidthexpns[i] = 15;\n\t\t\t\tccp->prcheightexpns[i] = 15;\n\t\t\t}\n\t\t}\n\t\tif (ccp->qsty == JPC_QCX_SIQNT) {\n\t\t\tcalcstepsizes(ccp->stepsizes[0], ccp->numrlvls, ccp->stepsizes);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tcp->flags |= JPC_CSET;\n\tcp->prgord = cod->prg;\n\tif (cod->mctrans) {\n\t\tcp->mctid = (cod->compparms.qmfbid == JPC_COX_INS) ? (JPC_MCT_ICT) : (JPC_MCT_RCT);\n\t} else {\n\t\tcp->mctid = JPC_MCT_NONE;\n\t}\n\tcp->numlyrs = cod->numlyrs;\n\tcp->csty = cod->csty & (JPC_COD_SOP | JPC_COD_EPH);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromcox(cp, ccp, &cod->compparms, 0);\n\t}\n\tcp->flags |= JPC_CSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc)\n{\n\tjpc_dec_cp_setfromcox(cp, &cp->ccps[coc->compno], &coc->compparms, JPC_COC);\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags)\n{\n\tint rlvlno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_COC) || !(ccp->flags & JPC_COC)) {\n\t\tccp->numrlvls = compparms->numdlvls + 1;\n\t\tccp->cblkwidthexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkwidthval);\n\t\tccp->cblkheightexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkheightval);\n\t\tccp->qmfbid = compparms->qmfbid;\n\t\tccp->cblkctx = compparms->cblksty;\n\t\tccp->csty = compparms->csty & JPC_COX_PRT;\n\t\tfor (rlvlno = 0; rlvlno < compparms->numrlvls; ++rlvlno) {\n\t\t\tccp->prcwidthexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parwidthval;\n\t\t\tccp->prcheightexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parheightval;\n\t\t}\n\t\tccp->flags |= flags | JPC_CSET;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromqcx(cp, ccp, &qcd->compparms, 0);\n\t}\n\tcp->flags |= JPC_QSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc)\n{\n\treturn jpc_dec_cp_setfromqcx(cp, &cp->ccps[qcc->compno], &qcc->compparms, JPC_QCC);\n}\n\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags)\n{\n\tint bandno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_QCC) || !(ccp->flags & JPC_QCC)) {\n\t\tccp->flags |= flags | JPC_QSET;\n\t\tfor (bandno = 0; bandno < compparms->numstepsizes; ++bandno) {\n\t\t\tccp->stepsizes[bandno] = compparms->stepsizes[bandno];\n\t\t}\n\t\tccp->numstepsizes = compparms->numstepsizes;\n\t\tccp->numguardbits = compparms->numguard;\n\t\tccp->qsty = compparms->qntsty;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn)\n{\n\tjpc_dec_ccp_t *ccp;\n\tccp = &cp->ccps[rgn->compno];\n\tccp->roishift = rgn->roishift;\n\treturn 0;\n}\n\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(pi->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tif (reset) {\n\t\twhile (jpc_pchglist_numpchgs(cp->pchglist) > 0) {\n\t\t\tpchg = jpc_pchglist_remove(cp->pchglist, 0);\n\t\t\tjpc_pchg_destroy(pchg);\n\t\t}\n\t}\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(cp->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits)\n{\n\tjpc_fix_t absstepsize;\n\tint n;\n\n\tabsstepsize = jpc_inttofix(1);\n\tn = JPC_FIX_FRACBITS - 11;\n\tabsstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :\n\t  (JPC_QCX_GETMANT(stepsize) >> (-n));\n\tn = numbits - JPC_QCX_GETEXPN(stepsize);\n\tabsstepsize = (n >= 0) ? (absstepsize << n) : (absstepsize >> (-n));\n\treturn absstepsize;\n}\n\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize)\n{\n\tint i;\n\tint j;\n\tint t;\n\n\tassert(absstepsize >= 0);\n\tif (absstepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tt = jas_matrix_get(x, i, j);\n\t\t\tif (t) {\n\t\t\t\tt = jpc_fix_mul(t, absstepsize);\n\t\t\t} else {\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tjas_matrix_set(x, i, j, t);\n\t\t}\n\t}\n\n}\n\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\n\tif (roishift < 0) {\n\t\t/* We could instead return an error here. */\n\t\t/* I do not think it matters much. */\n\t\tjas_eprintf(\"warning: forcing negative ROI shift to zero \"\n\t\t  \"(bitstream is probably corrupt)\\n\");\n\t\troishift = 0;\n\t}\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\t/* We are dealing with ROI data. */\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;\n\t\t\t\t/* Perform a basic sanity check on the sample value. */\n\t\t\t\t/* Some implementations write garbage in the unused\n\t\t\t\t  most-significant bit planes introduced by ROI shifting.\n\t\t\t\t  Here we ensure that any such bits are masked off. */\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in)\n{\n\tjpc_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jpc_dec_t)))) {\n\t\treturn 0;\n\t}\n\n\tdec->image = 0;\n\tdec->xstart = 0;\n\tdec->ystart = 0;\n\tdec->xend = 0;\n\tdec->yend = 0;\n\tdec->tilewidth = 0;\n\tdec->tileheight = 0;\n\tdec->tilexoff = 0;\n\tdec->tileyoff = 0;\n\tdec->numhtiles = 0;\n\tdec->numvtiles = 0;\n\tdec->numtiles = 0;\n\tdec->tiles = 0;\n\tdec->curtile = 0;\n\tdec->numcomps = 0;\n\tdec->in = in;\n\tdec->cp = 0;\n\tdec->maxlyrs = impopts->maxlyrs;\n\tdec->maxpkts = impopts->maxpkts;\ndec->numpkts = 0;\n\tdec->ppmseqno = 0;\n\tdec->state = 0;\n\tdec->cmpts = 0;\n\tdec->pkthdrstreams = 0;\n\tdec->ppmstab = 0;\n\tdec->curtileendoff = 0;\n\tdec->max_samples = impopts->max_samples;\n\n\treturn dec;\n}\n\nstatic void jpc_dec_destroy(jpc_dec_t *dec)\n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nvoid jpc_seglist_insert(jpc_dec_seglist_t *list, jpc_dec_seg_t *ins, jpc_dec_seg_t *node)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = ins;\n\tnode->prev = prev;\n\tnext = prev ? (prev->next) : 0;\n\tnode->prev = prev;\n\tnode->next = next;\n\tif (prev) {\n\t\tprev->next = node;\n\t} else {\n\t\tlist->head = node;\n\t}\n\tif (next) {\n\t\tnext->prev = node;\n\t} else {\n\t\tlist->tail = node;\n\t}\n}\n\nvoid jpc_seglist_remove(jpc_dec_seglist_t *list, jpc_dec_seg_t *seg)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = seg->prev;\n\tnext = seg->next;\n\tif (prev) {\n\t\tprev->next = next;\n\t} else {\n\t\tlist->head = next;\n\t}\n\tif (next) {\n\t\tnext->prev = prev;\n\t} else {\n\t\tlist->tail = prev;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n}\n\njpc_dec_seg_t *jpc_seg_alloc()\n{\n\tjpc_dec_seg_t *seg;\n\n\tif (!(seg = jas_malloc(sizeof(jpc_dec_seg_t)))) {\n\t\treturn 0;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n\tseg->passno = -1;\n\tseg->numpasses = 0;\n\tseg->maxpasses = 0;\n\tseg->type = JPC_SEG_INVALID;\n\tseg->stream = 0;\n\tseg->cnt = 0;\n\tseg->complete = 0;\n\tseg->lyrno = -1;\n\treturn seg;\n}\n\nvoid jpc_seg_destroy(jpc_dec_seg_t *seg)\n{\n\tif (seg->stream) {\n\t\tjas_stream_close(seg->stream);\n\t}\n\tjas_free(seg);\n}\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out)\n{\n\tjpc_dec_tile_t *tile;\n\tint tileno;\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint prcno;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tassert(!dec->numtiles || dec->tiles);\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles;\n\t  ++tileno, ++tile) {\n\t\tassert(!dec->numcomps || tile->tcomps);\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno <\n\t\t\t  tcomp->numrlvls; ++rlvlno, ++rlvl) {\n\t\t\t\tfprintf(out, \"RESOLUTION LEVEL %d\\n\", rlvlno);\n\t\t\t\tfprintf(out, \"xs = %\"PRIuFAST32\", ys = %\"PRIuFAST32\", xe = %\"PRIuFAST32\", ye = %\"PRIuFAST32\", w = %\"PRIuFAST32\", h = %\"PRIuFAST32\"\\n\",\n\t\t\t\t  rlvl->xstart, rlvl->ystart, rlvl->xend, rlvl->yend,\n\t\t\t\t  rlvl->xend - rlvl->xstart, rlvl->yend - rlvl->ystart);\n\t\t\t\tassert(!rlvl->numbands || rlvl->bands);\n\t\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\t\tfprintf(out, \"BAND %d\\n\", bandno);\n\t\t\t\t\tif (!band->data) {\n\t\t\t\t\t\tfprintf(out, \"band has no data (null pointer)\\n\");\n\t\t\t\t\t\tassert(!band->prcs);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(out, \"xs = %\"PRIiFAST32\", ys = %\"PRIiFAST32\", xe = %\"PRIiFAST32\", ye = %\"PRIiFAST32\", w = %\"PRIiFAST32\", h = %\"PRIiFAST32\"\\n\",\n\t\t\t\t\t  jas_seq2d_xstart(band->data),\n\t\t\t\t\t  jas_seq2d_ystart(band->data),\n\t\t\t\t\t  jas_seq2d_xend(band->data),\n\t\t\t\t\t  jas_seq2d_yend(band->data),\n\t\t\t\t\t  jas_seq2d_xend(band->data) -\n\t\t\t\t\t  jas_seq2d_xstart(band->data),\n\t\t\t\t\t  jas_seq2d_yend(band->data) -\n\t\t\t\t\t  jas_seq2d_ystart(band->data));\n\t\t\t\t\tassert(!rlvl->numprcs || band->prcs);\n\t\t\t\t\tfor (prcno = 0, prc = band->prcs;\n\t\t\t\t\t  prcno < rlvl->numprcs; ++prcno,\n\t\t\t\t\t  ++prc) {\n\t\t\t\t\t\tfprintf(out, \"CODE BLOCK GROUP %d\\n\", prcno);\n\t\t\t\t\t\tfprintf(out, \"xs = %\"PRIuFAST32\", ys = %\"PRIuFAST32\", xe = %\"PRIuFAST32\", ye = %\"PRIuFAST32\", w = %\"PRIuFAST32\", h = %\"PRIuFAST32\"\\n\",\n\t\t\t\t\t\t  prc->xstart, prc->ystart, prc->xend, prc->yend,\n\t\t\t\t\t\t  prc->xend - prc->xstart, prc->yend - prc->ystart);\n\t\t\t\t\t\tassert(!prc->numcblks || prc->cblks);\n\t\t\t\t\t\tfor (cblkno = 0, cblk =\n\t\t\t\t\t\t  prc->cblks; cblkno <\n\t\t\t\t\t\t  prc->numcblks; ++cblkno,\n\t\t\t\t\t\t  ++cblk) {\n\t\t\t\t\t\t\tfprintf(out, \"CODE BLOCK %d\\n\", cblkno);\n\t\t\t\t\t\t\tfprintf(out, \"xs = %\"PRIiFAST32\", ys = %\"PRIiFAST32\", xe = %\"PRIiFAST32\", ye = %\"PRIiFAST32\", w = %\"PRIiFAST32\", h = %\"PRIiFAST32\"\\n\",\n\t\t\t\t\t\t\t  jas_seq2d_xstart(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_ystart(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_xend(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_yend(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_xend(cblk->data) -\n\t\t\t\t\t\t\t  jas_seq2d_xstart(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_yend(cblk->data) -\n\t\t\t\t\t\t\t  jas_seq2d_ystart(cblk->data));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_alloc2(streamlist->maxstreams,\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}\n\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream)\n{\n\tjas_stream_t **newstreams;\n\tint newmaxstreams;\n\tint i;\n\t/* Grow the array of streams if necessary. */\n\tif (streamlist->numstreams >= streamlist->maxstreams) {\n\t\tnewmaxstreams = streamlist->maxstreams + 1024;\n\t\tif (!(newstreams = jas_realloc2(streamlist->streams,\n\t\t  (newmaxstreams + 1024), sizeof(jas_stream_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {\n\t\t\tstreamlist->streams[i] = 0;\n\t\t}\n\t\tstreamlist->maxstreams = newmaxstreams;\n\t\tstreamlist->streams = newstreams;\n\t}\n\tif (streamno != streamlist->numstreams) {\n\t\t/* Can only handle insertion at start of list. */\n\t\treturn -1;\n\t}\n\tstreamlist->streams[streamno] = stream;\n\t++streamlist->numstreams;\n\treturn 0;\n}\n\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno)\n{\n\tjas_stream_t *stream;\n\tint i;\n\tif (streamno >= streamlist->numstreams) {\n\t\tabort();\n\t}\n\tstream = streamlist->streams[streamno];\n\tfor (i = streamno + 1; i < streamlist->numstreams; ++i) {\n\t\tstreamlist->streams[i - 1] = streamlist->streams[i];\n\t}\n\t--streamlist->numstreams;\n\treturn stream;\n}\n\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist)\n{\n\tint streamno;\n\tif (streamlist->streams) {\n\t\tfor (streamno = 0; streamno < streamlist->numstreams;\n\t\t  ++streamno) {\n\t\t\tjas_stream_close(streamlist->streams[streamno]);\n\t\t}\n\t\tjas_free(streamlist->streams);\n\t}\n\tjas_free(streamlist);\n}\n\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno)\n{\n\tassert(streamno < streamlist->numstreams);\n\treturn streamlist->streams[streamno];\n}\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist)\n{\n\treturn streamlist->numstreams;\n}\n\njpc_ppxstab_t *jpc_ppxstab_create()\n{\n\tjpc_ppxstab_t *tab;\n\n\tif (!(tab = jas_malloc(sizeof(jpc_ppxstab_t)))) {\n\t\treturn 0;\n\t}\n\ttab->numents = 0;\n\ttab->maxents = 0;\n\ttab->ents = 0;\n\treturn tab;\n}\n\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab)\n{\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tjpc_ppxstabent_destroy(tab->ents[i]);\n\t}\n\tif (tab->ents) {\n\t\tjas_free(tab->ents);\n\t}\n\tjas_free(tab);\n}\n\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)\n{\n\tjpc_ppxstabent_t **newents;\n\tif (tab->maxents < maxents) {\n\t\tnewents = (tab->ents) ? jas_realloc2(tab->ents, maxents,\n\t\t  sizeof(jpc_ppxstabent_t *)) : jas_alloc2(maxents, sizeof(jpc_ppxstabent_t *));\n\t\tif (!newents) {\n\t\t\treturn -1;\n\t\t}\n\t\ttab->ents = newents;\n\t\ttab->maxents = maxents;\n\t}\n\treturn 0;\n}\n\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n{\n\tjpc_streamlist_t *streams;\n\tjas_uchar *dataptr;\n\tuint_fast32_t datacnt;\n\tuint_fast32_t tpcnt;\n\tjpc_ppxstabent_t *ent;\n\tint entno;\n\tjas_stream_t *stream;\n\tint n;\n\n\tif (!(streams = jpc_streamlist_create())) {\n\t\tgoto error;\n\t}\n\n\tif (!tab->numents) {\n\t\treturn streams;\n\t}\n\n\tentno = 0;\n\tent = tab->ents[entno];\n\tdataptr = ent->data;\n\tdatacnt = ent->len;\n\tfor (;;) {\n\n\t\t/* Get the length of the packet header data for the current\n\t\t  tile-part. */\n\t\tif (datacnt < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(stream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),\n\t\t  stream)) {\n\t\t\tgoto error;\n\t\t}\n\t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)\n\t\t  | dataptr[3];\n\t\tdatacnt -= 4;\n\t\tdataptr += 4;\n\n\t\t/* Get the packet header data for the current tile-part. */\n\t\twhile (tpcnt) {\n\t\t\tif (!datacnt) {\n\t\t\t\tif (++entno >= tab->numents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tent = tab->ents[entno];\n\t\t\t\tdataptr = ent->data;\n\t\t\t\tdatacnt = ent->len;\n\t\t\t}\n\t\t\tn = JAS_MIN(tpcnt, datacnt);\n\t\t\tif (jas_stream_write(stream, dataptr, n) != n) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttpcnt -= n;\n\t\t\tdataptr += n;\n\t\t\tdatacnt -= n;\n\t\t}\n\t\tjas_stream_rewind(stream);\n\t\tif (!datacnt) {\n\t\t\tif (++entno >= tab->numents) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = tab->ents[entno];\n\t\t\tdataptr = ent->data;\n\t\t\tdatacnt = ent->len;\n\t\t}\n\t}\n\n\treturn streams;\n\nerror:\n\tif (streams) {\n\t\tjpc_streamlist_destroy(streams);\n\t}\n\treturn 0;\n}\n\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab)\n{\n\tint i;\n\tjpc_ppxstabent_t *ent;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tent = tab->ents[i];\n\t\tif (jas_stream_write(out, ent->data, ent->len) != JAS_CAST(int, ent->len)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\njpc_ppxstabent_t *jpc_ppxstabent_create()\n{\n\tjpc_ppxstabent_t *ent;\n\tif (!(ent = jas_malloc(sizeof(jpc_ppxstabent_t)))) {\n\t\treturn 0;\n\t}\n\tent->data = 0;\n\tent->len = 0;\n\tent->ind = 0;\n\treturn ent;\n}\n\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent)\n{\n\tif (ent->data) {\n\t\tjas_free(ent->data);\n\t}\n\tjas_free(ent);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_tvp.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_fix.h\"\n#include \"jpc_dec.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_mct.h\"\n#include \"jpc_t2dec.h\"\n#include \"jpc_t1dec.h\"\n#include \"jpc_math.h\"\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n#define\tJPC_MHSOC\t0x0001\n  /* In the main header, expecting a SOC marker segment. */\n#define\tJPC_MHSIZ\t0x0002\n  /* In the main header, expecting a SIZ marker segment. */\n#define\tJPC_MH\t\t0x0004\n  /* In the main header, expecting \"other\" marker segments. */\n#define\tJPC_TPHSOT\t0x0008\n  /* In a tile-part header, expecting a SOT marker segment. */\n#define\tJPC_TPH\t\t0x0010\n  /* In a tile-part header, expecting \"other\" marker segments. */\n#define\tJPC_MT\t\t0x0020\n  /* In the main trailer. */\n\ntypedef struct {\n\n\tuint_fast16_t id;\n\t/* The marker segment type. */\n\n\tint validstates;\n\t/* The states in which this type of marker segment can be\n\t  validly encountered. */\n\n\tint (*action)(jpc_dec_t *dec, jpc_ms_t *ms);\n\t/* The action to take upon encountering this type of marker segment. */\n\n} jpc_dec_mstabent_t;\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n/* COD/COC parameters have been specified. */\n#define\tJPC_CSET\t0x0001\n/* QCD/QCC parameters have been specified. */\n#define\tJPC_QSET\t0x0002\n/* COD/COC parameters set from a COC marker segment. */\n#define\tJPC_COC\t0x0004\n/* QCD/QCC parameters set from a QCC marker segment. */\n#define\tJPC_QCC\t0x0008\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out);\n\njpc_ppxstab_t *jpc_ppxstab_create(void);\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab);\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents);\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent);\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab);\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab);\njpc_ppxstabent_t *jpc_ppxstabent_create(void);\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent);\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist);\njpc_streamlist_t *jpc_streamlist_create(void);\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream);\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno);\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist);\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno);\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps);\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod);\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc);\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd);\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc);\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn);\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp);\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset);\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc);\n\nstatic int jpc_dec_decode(jpc_dec_t *dec);\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts,\n  jas_stream_t *in);\nstatic void jpc_dec_destroy(jpc_dec_t *dec);\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize);\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps);\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits);\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic jpc_dec_importopts_t *jpc_dec_opts_create(const char *optstr);\nstatic void jpc_dec_opts_destroy(jpc_dec_importopts_t *opts);\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\njpc_dec_mstabent_t jpc_dec_mstab[] = {\n\t{JPC_MS_SOC, JPC_MHSOC, jpc_dec_process_soc},\n\t{JPC_MS_SOT, JPC_MH | JPC_TPHSOT, jpc_dec_process_sot},\n\t{JPC_MS_SOD, JPC_TPH, jpc_dec_process_sod},\n\t{JPC_MS_EOC, JPC_TPHSOT, jpc_dec_process_eoc},\n\t{JPC_MS_SIZ, JPC_MHSIZ, jpc_dec_process_siz},\n\t{JPC_MS_COD, JPC_MH | JPC_TPH, jpc_dec_process_cod},\n\t{JPC_MS_COC, JPC_MH | JPC_TPH, jpc_dec_process_coc},\n\t{JPC_MS_RGN, JPC_MH | JPC_TPH, jpc_dec_process_rgn},\n\t{JPC_MS_QCD, JPC_MH | JPC_TPH, jpc_dec_process_qcd},\n\t{JPC_MS_QCC, JPC_MH | JPC_TPH, jpc_dec_process_qcc},\n\t{JPC_MS_POC, JPC_MH | JPC_TPH, jpc_dec_process_poc},\n\t{JPC_MS_TLM, JPC_MH, 0},\n\t{JPC_MS_PLM, JPC_MH, 0},\n\t{JPC_MS_PLT, JPC_TPH, 0},\n\t{JPC_MS_PPM, JPC_MH, jpc_dec_process_ppm},\n\t{JPC_MS_PPT, JPC_TPH, jpc_dec_process_ppt},\n\t{JPC_MS_SOP, 0, 0},\n\t{JPC_MS_CRG, JPC_MH, jpc_dec_process_crg},\n\t{JPC_MS_COM, JPC_MH | JPC_TPH, jpc_dec_process_com},\n\t{0, JPC_MH | JPC_TPH, jpc_dec_process_unk}\n};\n\n/******************************************************************************\\\n* The main entry point for the JPEG-2000 decoder.\n\\******************************************************************************/\n\njas_image_t *jpc_decode(jas_stream_t *in, const char *optstr)\n{\n\tjpc_dec_importopts_t *opts;\n\tjpc_dec_t *dec;\n\tjas_image_t *image;\n\n\tdec = 0;\n\topts = 0;\n\n\tJAS_DBGLOG(100, (\"jpc_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(opts = jpc_dec_opts_create(optstr))) {\n\t\tgoto error;\n\t}\n\n\tjpc_initluts();\n\n\tif (!(dec = jpc_dec_create(opts, in))) {\n\t\tgoto error;\n\t}\n\tjpc_dec_opts_destroy(opts);\n\topts = 0;\n\n\t/* Do most of the work. */\n\tif (jpc_dec_decode(dec)) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_numcmpts(dec->image) >= 3) {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(dec->image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(dec->image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Save the return value. */\n\timage = dec->image;\n\n\t/* Stop the image from being discarded. */\n\tdec->image = 0;\n\n\t/* Destroy decoder. */\n\tjpc_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (opts) {\n\t\tjpc_dec_opts_destroy(opts);\n\t}\n\tif (dec) {\n\t\tjpc_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n\ntypedef enum {\n\tOPT_MAXLYRS,\n\tOPT_MAXPKTS,\n\tOPT_MAXSAMPLES,\n\tOPT_DEBUG\n} optid_t;\n\nstatic jas_taginfo_t decopts[] = {\n\t{OPT_MAXLYRS, \"maxlyrs\"},\n\t{OPT_MAXPKTS, \"maxpkts\"},\n\t{OPT_MAXSAMPLES, \"max_samples\"},\n\t{OPT_DEBUG, \"debug\"},\n\t{-1, 0}\n};\n\nstatic jpc_dec_importopts_t *jpc_dec_opts_create(const char *optstr)\n{\n\tjpc_dec_importopts_t *opts;\n\tjas_tvparser_t *tvp;\n\n\topts = 0;\n\n\tif (!(opts = jas_malloc(sizeof(jpc_dec_importopts_t)))) {\n\t\tgoto error;\n\t}\n\n\topts->debug = 0;\n\topts->maxlyrs = JPC_MAXLYRS;\n\topts->maxpkts = -1;\n\topts->max_samples = JAS_DEC_DEFAULT_MAX_SAMPLES;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXLYRS:\n\t\t\topts->maxlyrs = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\topts->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXPKTS:\n\t\t\topts->maxpkts = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXSAMPLES:\n\t\t\topts->max_samples = strtoull(jas_tvparser_getval(tvp), 0, 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn opts;\n\nerror:\n\tif (opts) {\n\t\tjpc_dec_opts_destroy(opts);\n\t}\n\treturn 0;\n}\n\nstatic void jpc_dec_opts_destroy(jpc_dec_importopts_t *opts)\n{\n\tjas_free(opts);\n}\n\n/******************************************************************************\\\n* Code for table-driven code stream decoder.\n\\******************************************************************************/\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id)\n{\n\tjpc_dec_mstabent_t *mstabent;\n\tfor (mstabent = jpc_dec_mstab; mstabent->id != 0; ++mstabent) {\n\t\tif (mstabent->id == id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mstabent;\n}\n\nstatic int jpc_dec_decode(jpc_dec_t *dec)\n{\n\tjpc_ms_t *ms;\n\tjpc_dec_mstabent_t *mstabent;\n\tint ret;\n\tjpc_cstate_t *cstate;\n\n\tif (!(cstate = jpc_cstate_create())) {\n\t\treturn -1;\n\t}\n\tdec->cstate = cstate;\n\n\t/* Initially, we should expect to encounter a SOC marker segment. */\n\tdec->state = JPC_MHSOC;\n\n\tfor (;;) {\n\n\t\t/* Get the next marker segment in the code stream. */\n\t\tif (!(ms = jpc_getms(dec->in, cstate))) {\n\t\t\tjas_eprintf(\"cannot get marker segment\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmstabent = jpc_dec_mstab_lookup(ms->id);\n\t\tassert(mstabent);\n\n\t\t/* Ensure that this type of marker segment is permitted\n\t\t  at this point in the code stream. */\n\t\tif (!(dec->state & mstabent->validstates)) {\n\t\t\tjas_eprintf(\"unexpected marker segment type\\n\");\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Process the marker segment. */\n\t\tif (mstabent->action) {\n\t\t\tret = (*mstabent->action)(dec, ms);\n\t\t} else {\n\t\t\t/* No explicit action is required. */\n\t\t\tret = 0;\n\t\t}\n\n\t\t/* Destroy the marker segment. */\n\t\tjpc_ms_destroy(ms);\n\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t} else if (ret > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint cmptno;\n\tjpc_dec_cmpt_t *cmpt;\n\tjpc_crg_t *crg;\n\n\tcrg = &ms->parms.crg;\n\tfor (cmptno = 0, cmpt = dec->cmpts; cmptno < dec->numcomps; ++cmptno,\n\t  ++cmpt) {\n\t\t/* Ignore the information in the CRG marker segment for now.\n\t\t  This information serves no useful purpose for decoding anyhow.\n\t\t  Some other parts of the code need to be changed if these lines\n\t\t  are uncommented.\n\t\tcmpt->hsubstep = crg->comps[cmptno].hoff;\n\t\tcmpt->vsubstep = crg->comps[cmptno].voff;\n\t\t*/\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate warnings about unused variables. */\n\tms = 0;\n\n\t/* We should expect to encounter a SIZ marker segment next. */\n\tdec->state = JPC_MHSIZ;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tjas_image_cmptparm_t *compinfos;\n\tjas_image_cmptparm_t *compinfo;\n\tjpc_dec_cmpt_t *cmpt;\n\tint cmptno;\n\n\tif (dec->state == JPC_MH) {\n\n\t\tif (!(compinfos = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jas_image_cmptparm_t)))) {\n\t\t\tabort();\n\t\t}\n\t\tfor (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;\n\t\t  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {\n\t\t\tcompinfo->tlx = 0;\n\t\t\tcompinfo->tly = 0;\n\t\t\tcompinfo->prec = cmpt->prec;\n\t\t\tcompinfo->sgnd = cmpt->sgnd;\n\t\t\tcompinfo->width = cmpt->width;\n\t\t\tcompinfo->height = cmpt->height;\n\t\t\tcompinfo->hstep = cmpt->hstep;\n\t\t\tcompinfo->vstep = cmpt->vstep;\n\t\t}\n\n\t\tif (!(dec->image = jas_image_create(dec->numcomps, compinfos,\n\t\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\tjas_free(compinfos);\n\t\t\treturn -1;\n\t\t}\n\t\tjas_free(compinfos);\n\n\t\t/* Is the packet header information stored in PPM marker segments in\n\t\t  the main header? */\n\t\tif (dec->ppmstab) {\n\t\t\t/* Convert the PPM marker segment data into a collection of streams\n\t\t\t  (one stream per tile-part). */\n\t\t\tif (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t\t\tdec->ppmstab = 0;\n\t\t}\n\t}\n\n\tif (sot->len > 0) {\n\t\tdec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -\n\t\t  4 + sot->len;\n\t} else {\n\t\tdec->curtileendoff = 0;\n\t}\n\n\tif (JAS_CAST(int, sot->tileno) >= dec->numtiles) {\n\t\tjas_eprintf(\"invalid tile number in SOT marker segment\\n\");\n\t\treturn -1;\n\t}\n\t/* Set the current tile. */\n\tdec->curtile = &dec->tiles[sot->tileno];\n\ttile = dec->curtile;\n\t/* Ensure that this is the expected part number. */\n\tif (sot->partno != tile->partno) {\n\t\treturn -1;\n\t}\n\tif (tile->numparts > 0 && sot->partno >= tile->numparts) {\n\t\treturn -1;\n\t}\n\tif (!tile->numparts && sot->numparts > 0) {\n\t\ttile->numparts = sot->numparts;\n\t}\n\n\ttile->pptstab = 0;\n\n\tswitch (tile->state) {\n\tcase JPC_TILE_INIT:\n\t\t/* This is the first tile-part for this tile. */\n\t\ttile->state = JPC_TILE_ACTIVE;\n\t\tassert(!tile->cp);\n\t\tif (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_resetflags(dec->cp);\n\t\tbreak;\n\tdefault:\n\t\tif (sot->numparts == sot->partno - 1) {\n\t\t\ttile->state = JPC_TILE_ACTIVELAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Note: We do not increment the expected tile-part number until\n\t  all processing for this tile-part is complete. */\n\n\t/* We should expect to encounter other tile-part header marker\n\t  segments next. */\n\tdec->state = JPC_TPH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tint pos;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tif (!(tile = dec->curtile)) {\n\t\treturn -1;\n\t}\n\n\tif (!tile->partno) {\n\t\tif (!jpc_dec_cp_isvalid(tile->cp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_prepare(tile->cp);\n\t\tif (jpc_dec_tileinit(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Are packet headers stored in the main header or tile-part header? */\n\tif (dec->pkthdrstreams) {\n\t\t/* Get the stream containing the packet header data for this\n\t\t  tile-part. */\n\t\tif (!(tile->pkthdrstream = jpc_streamlist_remove(dec->pkthdrstreams, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (tile->pptstab) {\n\t\tif (!tile->pkthdrstream) {\n\t\t\tif (!(tile->pkthdrstream = jas_stream_memopen(0, 0))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tpos = jas_stream_tell(tile->pkthdrstream);\n\t\tjas_stream_seek(tile->pkthdrstream, 0, SEEK_END);\n\t\tif (jpc_pptstabwrite(tile->pkthdrstream, tile->pptstab)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_stream_seek(tile->pkthdrstream, pos, SEEK_SET);\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\tif (jas_getdbglevel() >= 10) {\n\t\tjpc_dec_dump(dec, stderr);\n\t}\n\n\tif (jpc_dec_decodepkts(dec, (tile->pkthdrstream) ? tile->pkthdrstream :\n\t  dec->in, dec->in)) {\n\t\tjas_eprintf(\"jpc_dec_decodepkts failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Gobble any unconsumed tile data. */\n\tif (dec->curtileendoff > 0) {\n\t\tlong curoff;\n\t\tuint_fast32_t n;\n\t\tcuroff = jas_stream_getrwcount(dec->in);\n\t\tif (curoff < dec->curtileendoff) {\n\t\t\tn = dec->curtileendoff - curoff;\n\t\t\tjas_eprintf(\"warning: ignoring trailing garbage (%lu bytes)\\n\",\n\t\t\t  (unsigned long) n);\n\n\t\t\twhile (n-- > 0) {\n\t\t\t\tif (jas_stream_getc(dec->in) == EOF) {\n\t\t\t\t\tjas_eprintf(\"read error\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curoff > dec->curtileendoff) {\n\t\t\tjas_eprintf(\"warning: not enough tile data (%lu bytes)\\n\",\n\t\t\t  (unsigned long) curoff - dec->curtileendoff);\n\t\t}\n\n\t}\n\n\tif (tile->numparts > 0 && tile->partno == tile->numparts - 1) {\n\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\tdec->curtile = 0;\n\n\t/* Increment the expected tile-part number. */\n\t++tile->partno;\n\n\t/* We should expect to encounter a SOT marker segment next. */\n\tdec->state = JPC_TPHSOT;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_prc_t *prc;\n\tint bndno;\n\tjpc_tsfb_band_t *bnd;\n\tint bandno;\n\tjpc_dec_ccp_t *ccp;\n\tint prccnt;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkcnt;\n\tuint_fast32_t tlprcxstart;\n\tuint_fast32_t tlprcystart;\n\tuint_fast32_t brprcxend;\n\tuint_fast32_t brprcyend;\n\tuint_fast32_t tlcbgxstart;\n\tuint_fast32_t tlcbgystart;\n\tuint_fast32_t brcbgxend;\n\tuint_fast32_t brcbgyend;\n\tuint_fast32_t cbgxstart;\n\tuint_fast32_t cbgystart;\n\tuint_fast32_t cbgxend;\n\tuint_fast32_t cbgyend;\n\tuint_fast32_t tlcblkxstart;\n\tuint_fast32_t tlcblkystart;\n\tuint_fast32_t brcblkxend;\n\tuint_fast32_t brcblkyend;\n\tuint_fast32_t cblkxstart;\n\tuint_fast32_t cblkystart;\n\tuint_fast32_t cblkxend;\n\tuint_fast32_t cblkyend;\n\tuint_fast32_t tmpxstart;\n\tuint_fast32_t tmpystart;\n\tuint_fast32_t tmpxend;\n\tuint_fast32_t tmpyend;\n\tjpc_dec_cp_t *cp;\n\tjpc_tsfb_band_t bnds[JPC_MAXBANDS];\n\tjpc_pchg_t *pchg;\n\tint pchgno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tcp = tile->cp;\n\ttile->realmode = 0;\n\tif (cp->mctid == JPC_MCT_ICT) {\n\t\ttile->realmode = 1;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tif (ccp->qmfbid == JPC_COX_INS) {\n\t\t\ttile->realmode = 1;\n\t\t}\n\t\ttcomp->numrlvls = ccp->numrlvls;\n\t\tif (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,\n\t\t  sizeof(jpc_dec_rlvl_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,\n\t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),\n\t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,\n\t\t  cmpt->vstep)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,\n\t\t  tcomp->numrlvls - 1))) {\n\t\t\treturn -1;\n\t\t}\n\t\t{\n\t\t\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data),\n\t\t\t  jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data),\n\t\t\t  jas_seq2d_yend(tcomp->data), bnds);\n\t\t}\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\trlvl->bands = 0;\n\t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];\n\t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];\n\t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>\n\t\t\t  rlvl->prcwidthexpn;\n\t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>\n\t\t\t  rlvl->prcheightexpn;\n\t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {\n\t\t\t\trlvl->bands = 0;\n\t\t\t\trlvl->numprcs = 0;\n\t\t\t\trlvl->numhprcs = 0;\n\t\t\t\trlvl->numvprcs = 0;\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (!rlvlno) {\n\t\t\t\ttlcbgxstart = tlprcxstart;\n\t\t\t\ttlcbgystart = tlprcystart;\n\t\t\t\tbrcbgxend = brprcxend;\n\t\t\t\tbrcbgyend = brprcyend;\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t\t\t} else {\n\t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);\n\t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);\n\t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);\n\t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t\t\t}\n\t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,\n\t\t\t  rlvl->cbgwidthexpn);\n\t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,\n\t\t\t  rlvl->cbgheightexpn);\n\n\t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\t\t\tif (!(rlvl->bands = jas_alloc2(rlvl->numbands,\n\t\t\t  sizeof(jpc_dec_band_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +\n\t\t\t\t  bandno + 1);\n\t\t\t\tbnd = &bnds[bndno];\n\n\t\t\t\tband->orient = bnd->orient;\n\t\t\t\tband->stepsize = ccp->stepsizes[bndno];\n\t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,\n\t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);\n\t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,\n\t\t\t\t  cmpt->prec + band->analgain);\n\t\t\t\tband->numbps = ccp->numguardbits +\n\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?\n\t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;\n\t\t\t\tband->data = 0;\n\t\t\t\tband->prcs = 0;\n\t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart,\n\t\t\t\t  bnd->locystart, bnd->locxend, bnd->locyend);\n\t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);\n\n\t\t\t\tassert(rlvl->numprcs);\n\n\t\t\t\tif (!(band->prcs = jas_alloc2(rlvl->numprcs,\n\t\t\t\t  sizeof(jpc_dec_prc_t)))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n/************************************************/\n\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\tcbgystart = tlcbgystart;\n\t\t\t\tfor (prccnt = rlvl->numprcs, prc = band->prcs;\n\t\t\t\t  prccnt > 0; --prccnt, ++prc) {\n\t\t\t\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);\n\t\t\t\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);\n\t\t\t\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xstart(band->data)));\n\t\t\t\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_ystart(band->data)));\n\t\t\t\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xend(band->data)));\n\t\t\t\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_yend(band->data)));\n\t\t\t\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {\n\t\t\t\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>\n\t\t\t\t\t\t  rlvl->cblkwidthexpn;\n\t\t\t\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>\n\t\t\t\t\t\t  rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\t\t\t\t\t\tassert(prc->numcblks > 0);\n\n\t\t\t\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->cblks = jas_alloc2(prc->numcblks,\n\t\t\t\t\t\t  sizeof(jpc_dec_cblk_t)))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\tcblkystart = cbgystart;\n\t\t\t\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks;\n\t\t\t\t\t\t  cblkcnt > 0;) {\n\t\t\t\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);\n\t\t\t\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);\n\t\t\t\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);\n\t\t\t\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);\n\t\t\t\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);\n\t\t\t\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);\n\t\t\t\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {\n\t\t\t\t\t\t\t\tcblk->firstpassno = -1;\n\t\t\t\t\t\t\t\tcblk->mqdec = 0;\n\t\t\t\t\t\t\t\tcblk->nulldec = 0;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tcblk->numpasses = 0;\n\t\t\t\t\t\t\t\tcblk->segs.head = 0;\n\t\t\t\t\t\t\t\tcblk->segs.tail = 0;\n\t\t\t\t\t\t\t\tcblk->curseg = 0;\n\t\t\t\t\t\t\t\tcblk->numimsbs = 0;\n\t\t\t\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0,\n\t\t\t\t\t\t\t\t  0))) {\n\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data,\n\t\t\t\t\t\t\t\t  tmpxstart, tmpystart, tmpxend, tmpyend);\n\t\t\t\t\t\t\t\t++cblk;\n\t\t\t\t\t\t\t\t--cblkcnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;\n\t\t\t\t\t\t\tif (cblkxstart >= cbgxend) {\n\t\t\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprc->cblks = 0;\n\t\t\t\t\t\tprc->incltagtree = 0;\n\t\t\t\t\t\tprc->numimsbstagtree = 0;\n\t\t\t\t\t}\n\t\t\t\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;\n\t\t\t\t\tif (cbgxstart >= brcbgxend) {\n\t\t\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;\n\t\t\t\t\t}\n\n\t\t\t\t}\n/********************************************/\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(tile->pi = jpc_dec_pi_create(dec, tile))) {\n\t\treturn -1;\n\t}\n\n\tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);\n\t  ++pchgno) {\n\t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));\n\t\tassert(pchg);\n\t\tjpc_pi_addpchg(tile->pi, pchg);\n\t}\n\tjpc_pi_init(tile->pi);\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint bandno;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tjpc_dec_prc_t *prc;\n\tjpc_dec_seg_t *seg;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tif (tile->tcomps) {\n\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t\t  ++rlvlno, ++rlvl) {\n\t\t\t\tif (!rlvl->bands) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t\t\t  ++bandno, ++band) {\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno <\n\t\t\t\t\t\t  rlvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno <\n\t\t\t\t\t\t\t  prc->numcblks; ++cblkno, ++cblk) {\n\n\t\t\t\t\t\t\t\twhile (cblk->segs.head) {\n\t\t\t\t\t\t\t\t\tseg = cblk->segs.head;\n\t\t\t\t\t\t\t\t\tjpc_seglist_remove(&cblk->segs, seg);\n\t\t\t\t\t\t\t\t\tjpc_seg_destroy(seg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->data);\n\t\t\t\t\t\t\t\tif (cblk->mqdec) {\n\t\t\t\t\t\t\t\t\tjpc_mqdec_destroy(cblk->mqdec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->nulldec) {\n\t\t\t\t\t\t\t\t\tjpc_bitstream_close(cblk->nulldec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->flags) {\n\t\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->incltagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->incltagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->numimsbstagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->numimsbstagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->cblks) {\n\t\t\t\t\t\t\t\tjas_free(prc->cblks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (band->data) {\n\t\t\t\t\t\tjas_matrix_destroy(band->data);\n\t\t\t\t\t}\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tjas_free(band->prcs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rlvl->bands) {\n\t\t\t\t\tjas_free(rlvl->bands);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tcomp->rlvls) {\n\t\t\t\tjas_free(tcomp->rlvls);\n\t\t\t}\n\t\t\tif (tcomp->data) {\n\t\t\t\tjas_matrix_destroy(tcomp->data);\n\t\t\t}\n\t\t\tif (tcomp->tsfb) {\n\t\t\t\tjpc_tsfb_destroy(tcomp->tsfb);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tile->cp) {\n\t\tjpc_dec_cp_destroy(tile->cp);\n\t\t//tile->cp = 0;\n\t}\n\tif (tile->tcomps) {\n\t\tjas_free(tile->tcomps);\n\t\t//tile->tcomps = 0;\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t\t//tile->pi = 0;\n\t}\n\tif (tile->pkthdrstream) {\n\t\tjas_stream_close(tile->pkthdrstream);\n\t\t//tile->pkthdrstream = 0;\n\t}\n\tif (tile->pptstab) {\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\t//tile->pptstab = 0;\n\t}\n\n\ttile->state = JPC_TILE_DONE;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tint i;\n\tint j;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tint compno;\n\tint rlvlno;\n\tint bandno;\n\tint adjust;\n\tint v;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (jpc_dec_decodecblks(dec, tile)) {\n\t\tjas_eprintf(\"jpc_dec_decodecblks failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Perform dequantization. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tif (!rlvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjpc_undo_roi(band->data, band->roishift, ccp->roishift -\n\t\t\t\t  band->roishift, band->numbps);\n\t\t\t\tif (tile->realmode) {\n\t\t\t\t\tjas_matrix_asl(band->data, JPC_FIX_FRACBITS);\n\t\t\t\t\tjpc_dequantize(band->data, band->absstepsize);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply an inverse wavelet transform if necessary. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tjpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);\n\t}\n\n\n\t/* Apply an inverse intercomponent transform if necessary. */\n\tswitch (tile->cp->mctid) {\n\tcase JPC_MCT_RCT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"RCT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec->image)) {\n\t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"ICT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec->image)) {\n\t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\t}\n\n\t/* Perform rounding and convert to integer values. */\n\tif (tile->realmode) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t\tv = jas_matrix_get(tcomp->data, i, j);\n\t\t\t\t\tv = jpc_fix_round(v);\n\t\t\t\t\tjas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform level shift. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tadjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));\n\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t*jas_matrix_getref(tcomp->data, i, j) += adjust;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform clipping. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tjpc_fix_t mn;\n\t\tjpc_fix_t mx;\n\t\tmn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);\n\t\tmx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<\n\t\t  cmpt->prec) - 1);\n\t\tjas_matrix_clip(tcomp->data, mn, mx);\n\t}\n\n\t/* XXX need to free tsfb struct */\n\n\t/* Write the data for each component of the image. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tif (jas_image_writecmpt(dec->image, compno, tcomp->xstart -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(\n\t\t  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {\n\t\t\tjas_eprintf(\"write component failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t/* If the tile has not yet been finalized, finalize it. */\n\t\t// OLD CODE: jpc_dec_tilefini(dec, tile);\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}\n\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\tsize_t num_samples;\n\tsize_t num_samples_delta;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tnum_samples = 0;\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\n\t\tif (!jas_safe_size_mul(cmpt->width, cmpt->height, &num_samples_delta)) {\n\t\t\tjas_eprintf(\"image too large\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_safe_size_add(num_samples, num_samples_delta, &num_samples)) {\n\t\t\tjas_eprintf(\"image too large\\n\");\n\t\t}\n\t}\n\n\tif (dec->max_samples > 0 && num_samples > dec->max_samples) {\n\t\tjas_eprintf(\"maximum number of samples exceeded (%zu > %zu)\\n\",\n\t\t  num_samples, dec->max_samples);\n\t\treturn -1;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcod(dec->cp, cod);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcod(tile->cp, cod);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, rgn->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in RGN marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromrgn(dec->cp, rgn);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromrgn(tile->cp, rgn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcd(dec->cp, qcd);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcd(tile->cp, qcd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, qcc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in QCC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcc(dec->cp, qcc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcc(tile->cp, qcc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_dec_tile_t *tile;\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tif (jpc_dec_cp_setfrompoc(dec->cp, poc, 1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!tile->partno) {\n\t\t\tif (jpc_dec_cp_setfrompoc(tile->cp, poc, (!tile->partno))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tjpc_pi_addpchgfrompoc(tile->pi, poc);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tjpc_ppxstabent_t *ppmstabent;\n\n\tif (!dec->ppmstab) {\n\t\tif (!(dec->ppmstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(ppmstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tppmstabent->ind = ppm->ind;\n\tppmstabent->data = ppm->data;\n\tppm->data = 0;\n\tppmstabent->len = ppm->len;\n\tif (jpc_ppxstab_insert(dec->ppmstab, ppmstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tjpc_dec_tile_t *tile;\n\tjpc_ppxstabent_t *pptstabent;\n\n\ttile = dec->curtile;\n\tif (!tile->pptstab) {\n\t\tif (!(tile->pptstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(pptstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tpptstabent->ind = ppt->ind;\n\tpptstabent->data = ppt->data;\n\tppt->data = 0;\n\tpptstabent->len = ppt->len;\n\tif (jpc_ppxstab_insert(tile->pptstab, pptstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\tms = 0;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\n\tjas_eprintf(\"warning: ignoring unknown marker segment (0x%x)\\n\",\n\t  ms->id);\n\tjpc_ms_dump(ms, stderr);\n\treturn 0;\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)\n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_alloc2(cp->numcomps, sizeof(jpc_dec_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tgoto error;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\nerror:\n\tif (cp) {\n\t\tjpc_dec_cp_destroy(cp);\n\t}\n\treturn 0;\n}\n\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_cp_t *newcp;\n\tjpc_dec_ccp_t *newccp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(newcp = jpc_dec_cp_create(cp->numcomps))) {\n\t\treturn 0;\n\t}\n\tnewcp->flags = cp->flags;\n\tnewcp->prgord = cp->prgord;\n\tnewcp->numlyrs = cp->numlyrs;\n\tnewcp->mctid = cp->mctid;\n\tnewcp->csty = cp->csty;\n\tjpc_pchglist_destroy(newcp->pchglist);\n\tnewcp->pchglist = 0;\n\tif (!(newcp->pchglist = jpc_pchglist_copy(cp->pchglist))) {\n\t\tjas_free(newcp);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, newccp = newcp->ccps, ccp = cp->ccps;\n\t  compno < cp->numcomps;\n\t  ++compno, ++newccp, ++ccp) {\n\t\t*newccp = *ccp;\n\t}\n\treturn newcp;\n}\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tcp->flags &= (JPC_CSET | JPC_QSET);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t}\n}\n\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp)\n{\n\tif (cp->ccps) {\n\t\tjas_free(cp->ccps);\n\t}\n\tif (cp->pchglist) {\n\t\tjpc_pchglist_destroy(cp->pchglist);\n\t}\n\tjas_free(cp);\n}\n\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp)\n{\n\tuint_fast16_t compcnt;\n\tjpc_dec_ccp_t *ccp;\n\n\tif (!(cp->flags & JPC_CSET) || !(cp->flags & JPC_QSET)) {\n\t\treturn 0;\n\t}\n\tfor (compcnt = cp->numcomps, ccp = cp->ccps; compcnt > 0; --compcnt,\n\t  ++ccp) {\n\t\t/* Is there enough step sizes for the number of bands? */\n\t\tif ((ccp->qsty != JPC_QCX_SIQNT && JAS_CAST(int, ccp->numstepsizes) < 3 *\n\t\t  ccp->numrlvls - 2) || (ccp->qsty == JPC_QCX_SIQNT &&\n\t\t  ccp->numstepsizes != 1)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n//jas_eprintf(\"DEBUG %d %d %d %d %d\\n\", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}\n\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tint i;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tif (!(ccp->csty & JPC_COX_PRT)) {\n\t\t\tfor (i = 0; i < JPC_MAXRLVLS; ++i) {\n\t\t\t\tccp->prcwidthexpns[i] = 15;\n\t\t\t\tccp->prcheightexpns[i] = 15;\n\t\t\t}\n\t\t}\n\t\tif (ccp->qsty == JPC_QCX_SIQNT) {\n\t\t\tcalcstepsizes(ccp->stepsizes[0], ccp->numrlvls, ccp->stepsizes);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tcp->flags |= JPC_CSET;\n\tcp->prgord = cod->prg;\n\tif (cod->mctrans) {\n\t\tcp->mctid = (cod->compparms.qmfbid == JPC_COX_INS) ? (JPC_MCT_ICT) : (JPC_MCT_RCT);\n\t} else {\n\t\tcp->mctid = JPC_MCT_NONE;\n\t}\n\tcp->numlyrs = cod->numlyrs;\n\tcp->csty = cod->csty & (JPC_COD_SOP | JPC_COD_EPH);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromcox(cp, ccp, &cod->compparms, 0);\n\t}\n\tcp->flags |= JPC_CSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc)\n{\n\tjpc_dec_cp_setfromcox(cp, &cp->ccps[coc->compno], &coc->compparms, JPC_COC);\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags)\n{\n\tint rlvlno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_COC) || !(ccp->flags & JPC_COC)) {\n\t\tccp->numrlvls = compparms->numdlvls + 1;\n\t\tccp->cblkwidthexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkwidthval);\n\t\tccp->cblkheightexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkheightval);\n\t\tccp->qmfbid = compparms->qmfbid;\n\t\tccp->cblkctx = compparms->cblksty;\n\t\tccp->csty = compparms->csty & JPC_COX_PRT;\n\t\tfor (rlvlno = 0; rlvlno < compparms->numrlvls; ++rlvlno) {\n\t\t\tccp->prcwidthexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parwidthval;\n\t\t\tccp->prcheightexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parheightval;\n\t\t}\n\t\tccp->flags |= flags | JPC_CSET;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromqcx(cp, ccp, &qcd->compparms, 0);\n\t}\n\tcp->flags |= JPC_QSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc)\n{\n\treturn jpc_dec_cp_setfromqcx(cp, &cp->ccps[qcc->compno], &qcc->compparms, JPC_QCC);\n}\n\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags)\n{\n\tint bandno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_QCC) || !(ccp->flags & JPC_QCC)) {\n\t\tccp->flags |= flags | JPC_QSET;\n\t\tfor (bandno = 0; bandno < compparms->numstepsizes; ++bandno) {\n\t\t\tccp->stepsizes[bandno] = compparms->stepsizes[bandno];\n\t\t}\n\t\tccp->numstepsizes = compparms->numstepsizes;\n\t\tccp->numguardbits = compparms->numguard;\n\t\tccp->qsty = compparms->qntsty;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn)\n{\n\tjpc_dec_ccp_t *ccp;\n\tccp = &cp->ccps[rgn->compno];\n\tccp->roishift = rgn->roishift;\n\treturn 0;\n}\n\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(pi->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tif (reset) {\n\t\twhile (jpc_pchglist_numpchgs(cp->pchglist) > 0) {\n\t\t\tpchg = jpc_pchglist_remove(cp->pchglist, 0);\n\t\t\tjpc_pchg_destroy(pchg);\n\t\t}\n\t}\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(cp->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits)\n{\n\tjpc_fix_t absstepsize;\n\tint n;\n\n\tabsstepsize = jpc_inttofix(1);\n\tn = JPC_FIX_FRACBITS - 11;\n\tabsstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :\n\t  (JPC_QCX_GETMANT(stepsize) >> (-n));\n\tn = numbits - JPC_QCX_GETEXPN(stepsize);\n\tabsstepsize = (n >= 0) ? (absstepsize << n) : (absstepsize >> (-n));\n\treturn absstepsize;\n}\n\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize)\n{\n\tint i;\n\tint j;\n\tint t;\n\n\tassert(absstepsize >= 0);\n\tif (absstepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tt = jas_matrix_get(x, i, j);\n\t\t\tif (t) {\n\t\t\t\tt = jpc_fix_mul(t, absstepsize);\n\t\t\t} else {\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tjas_matrix_set(x, i, j, t);\n\t\t}\n\t}\n\n}\n\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\n\tif (roishift < 0) {\n\t\t/* We could instead return an error here. */\n\t\t/* I do not think it matters much. */\n\t\tjas_eprintf(\"warning: forcing negative ROI shift to zero \"\n\t\t  \"(bitstream is probably corrupt)\\n\");\n\t\troishift = 0;\n\t}\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\t/* We are dealing with ROI data. */\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;\n\t\t\t\t/* Perform a basic sanity check on the sample value. */\n\t\t\t\t/* Some implementations write garbage in the unused\n\t\t\t\t  most-significant bit planes introduced by ROI shifting.\n\t\t\t\t  Here we ensure that any such bits are masked off. */\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in)\n{\n\tjpc_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jpc_dec_t)))) {\n\t\treturn 0;\n\t}\n\n\tdec->image = 0;\n\tdec->xstart = 0;\n\tdec->ystart = 0;\n\tdec->xend = 0;\n\tdec->yend = 0;\n\tdec->tilewidth = 0;\n\tdec->tileheight = 0;\n\tdec->tilexoff = 0;\n\tdec->tileyoff = 0;\n\tdec->numhtiles = 0;\n\tdec->numvtiles = 0;\n\tdec->numtiles = 0;\n\tdec->tiles = 0;\n\tdec->curtile = 0;\n\tdec->numcomps = 0;\n\tdec->in = in;\n\tdec->cp = 0;\n\tdec->maxlyrs = impopts->maxlyrs;\n\tdec->maxpkts = impopts->maxpkts;\ndec->numpkts = 0;\n\tdec->ppmseqno = 0;\n\tdec->state = 0;\n\tdec->cmpts = 0;\n\tdec->pkthdrstreams = 0;\n\tdec->ppmstab = 0;\n\tdec->curtileendoff = 0;\n\tdec->max_samples = impopts->max_samples;\n\n\treturn dec;\n}\n\nstatic void jpc_dec_destroy(jpc_dec_t *dec)\n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nvoid jpc_seglist_insert(jpc_dec_seglist_t *list, jpc_dec_seg_t *ins, jpc_dec_seg_t *node)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = ins;\n\tnode->prev = prev;\n\tnext = prev ? (prev->next) : 0;\n\tnode->prev = prev;\n\tnode->next = next;\n\tif (prev) {\n\t\tprev->next = node;\n\t} else {\n\t\tlist->head = node;\n\t}\n\tif (next) {\n\t\tnext->prev = node;\n\t} else {\n\t\tlist->tail = node;\n\t}\n}\n\nvoid jpc_seglist_remove(jpc_dec_seglist_t *list, jpc_dec_seg_t *seg)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = seg->prev;\n\tnext = seg->next;\n\tif (prev) {\n\t\tprev->next = next;\n\t} else {\n\t\tlist->head = next;\n\t}\n\tif (next) {\n\t\tnext->prev = prev;\n\t} else {\n\t\tlist->tail = prev;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n}\n\njpc_dec_seg_t *jpc_seg_alloc()\n{\n\tjpc_dec_seg_t *seg;\n\n\tif (!(seg = jas_malloc(sizeof(jpc_dec_seg_t)))) {\n\t\treturn 0;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n\tseg->passno = -1;\n\tseg->numpasses = 0;\n\tseg->maxpasses = 0;\n\tseg->type = JPC_SEG_INVALID;\n\tseg->stream = 0;\n\tseg->cnt = 0;\n\tseg->complete = 0;\n\tseg->lyrno = -1;\n\treturn seg;\n}\n\nvoid jpc_seg_destroy(jpc_dec_seg_t *seg)\n{\n\tif (seg->stream) {\n\t\tjas_stream_close(seg->stream);\n\t}\n\tjas_free(seg);\n}\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out)\n{\n\tjpc_dec_tile_t *tile;\n\tint tileno;\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint prcno;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tassert(!dec->numtiles || dec->tiles);\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles;\n\t  ++tileno, ++tile) {\n\t\tassert(!dec->numcomps || tile->tcomps);\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno <\n\t\t\t  tcomp->numrlvls; ++rlvlno, ++rlvl) {\n\t\t\t\tfprintf(out, \"RESOLUTION LEVEL %d\\n\", rlvlno);\n\t\t\t\tfprintf(out, \"xs = %\"PRIuFAST32\", ys = %\"PRIuFAST32\", xe = %\"PRIuFAST32\", ye = %\"PRIuFAST32\", w = %\"PRIuFAST32\", h = %\"PRIuFAST32\"\\n\",\n\t\t\t\t  rlvl->xstart, rlvl->ystart, rlvl->xend, rlvl->yend,\n\t\t\t\t  rlvl->xend - rlvl->xstart, rlvl->yend - rlvl->ystart);\n\t\t\t\tassert(!rlvl->numbands || rlvl->bands);\n\t\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\t\tfprintf(out, \"BAND %d\\n\", bandno);\n\t\t\t\t\tif (!band->data) {\n\t\t\t\t\t\tfprintf(out, \"band has no data (null pointer)\\n\");\n\t\t\t\t\t\tassert(!band->prcs);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(out, \"xs = %\"PRIiFAST32\", ys = %\"PRIiFAST32\", xe = %\"PRIiFAST32\", ye = %\"PRIiFAST32\", w = %\"PRIiFAST32\", h = %\"PRIiFAST32\"\\n\",\n\t\t\t\t\t  jas_seq2d_xstart(band->data),\n\t\t\t\t\t  jas_seq2d_ystart(band->data),\n\t\t\t\t\t  jas_seq2d_xend(band->data),\n\t\t\t\t\t  jas_seq2d_yend(band->data),\n\t\t\t\t\t  jas_seq2d_xend(band->data) -\n\t\t\t\t\t  jas_seq2d_xstart(band->data),\n\t\t\t\t\t  jas_seq2d_yend(band->data) -\n\t\t\t\t\t  jas_seq2d_ystart(band->data));\n\t\t\t\t\tassert(!rlvl->numprcs || band->prcs);\n\t\t\t\t\tfor (prcno = 0, prc = band->prcs;\n\t\t\t\t\t  prcno < rlvl->numprcs; ++prcno,\n\t\t\t\t\t  ++prc) {\n\t\t\t\t\t\tfprintf(out, \"CODE BLOCK GROUP %d\\n\", prcno);\n\t\t\t\t\t\tfprintf(out, \"xs = %\"PRIuFAST32\", ys = %\"PRIuFAST32\", xe = %\"PRIuFAST32\", ye = %\"PRIuFAST32\", w = %\"PRIuFAST32\", h = %\"PRIuFAST32\"\\n\",\n\t\t\t\t\t\t  prc->xstart, prc->ystart, prc->xend, prc->yend,\n\t\t\t\t\t\t  prc->xend - prc->xstart, prc->yend - prc->ystart);\n\t\t\t\t\t\tassert(!prc->numcblks || prc->cblks);\n\t\t\t\t\t\tfor (cblkno = 0, cblk =\n\t\t\t\t\t\t  prc->cblks; cblkno <\n\t\t\t\t\t\t  prc->numcblks; ++cblkno,\n\t\t\t\t\t\t  ++cblk) {\n\t\t\t\t\t\t\tfprintf(out, \"CODE BLOCK %d\\n\", cblkno);\n\t\t\t\t\t\t\tfprintf(out, \"xs = %\"PRIiFAST32\", ys = %\"PRIiFAST32\", xe = %\"PRIiFAST32\", ye = %\"PRIiFAST32\", w = %\"PRIiFAST32\", h = %\"PRIiFAST32\"\\n\",\n\t\t\t\t\t\t\t  jas_seq2d_xstart(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_ystart(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_xend(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_yend(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_xend(cblk->data) -\n\t\t\t\t\t\t\t  jas_seq2d_xstart(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_yend(cblk->data) -\n\t\t\t\t\t\t\t  jas_seq2d_ystart(cblk->data));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_alloc2(streamlist->maxstreams,\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}\n\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream)\n{\n\tjas_stream_t **newstreams;\n\tint newmaxstreams;\n\tint i;\n\t/* Grow the array of streams if necessary. */\n\tif (streamlist->numstreams >= streamlist->maxstreams) {\n\t\tnewmaxstreams = streamlist->maxstreams + 1024;\n\t\tif (!(newstreams = jas_realloc2(streamlist->streams,\n\t\t  (newmaxstreams + 1024), sizeof(jas_stream_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {\n\t\t\tstreamlist->streams[i] = 0;\n\t\t}\n\t\tstreamlist->maxstreams = newmaxstreams;\n\t\tstreamlist->streams = newstreams;\n\t}\n\tif (streamno != streamlist->numstreams) {\n\t\t/* Can only handle insertion at start of list. */\n\t\treturn -1;\n\t}\n\tstreamlist->streams[streamno] = stream;\n\t++streamlist->numstreams;\n\treturn 0;\n}\n\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno)\n{\n\tjas_stream_t *stream;\n\tint i;\n\tif (streamno >= streamlist->numstreams) {\n\t\tabort();\n\t}\n\tstream = streamlist->streams[streamno];\n\tfor (i = streamno + 1; i < streamlist->numstreams; ++i) {\n\t\tstreamlist->streams[i - 1] = streamlist->streams[i];\n\t}\n\t--streamlist->numstreams;\n\treturn stream;\n}\n\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist)\n{\n\tint streamno;\n\tif (streamlist->streams) {\n\t\tfor (streamno = 0; streamno < streamlist->numstreams;\n\t\t  ++streamno) {\n\t\t\tjas_stream_close(streamlist->streams[streamno]);\n\t\t}\n\t\tjas_free(streamlist->streams);\n\t}\n\tjas_free(streamlist);\n}\n\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno)\n{\n\tassert(streamno < streamlist->numstreams);\n\treturn streamlist->streams[streamno];\n}\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist)\n{\n\treturn streamlist->numstreams;\n}\n\njpc_ppxstab_t *jpc_ppxstab_create()\n{\n\tjpc_ppxstab_t *tab;\n\n\tif (!(tab = jas_malloc(sizeof(jpc_ppxstab_t)))) {\n\t\treturn 0;\n\t}\n\ttab->numents = 0;\n\ttab->maxents = 0;\n\ttab->ents = 0;\n\treturn tab;\n}\n\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab)\n{\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tjpc_ppxstabent_destroy(tab->ents[i]);\n\t}\n\tif (tab->ents) {\n\t\tjas_free(tab->ents);\n\t}\n\tjas_free(tab);\n}\n\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)\n{\n\tjpc_ppxstabent_t **newents;\n\tif (tab->maxents < maxents) {\n\t\tnewents = (tab->ents) ? jas_realloc2(tab->ents, maxents,\n\t\t  sizeof(jpc_ppxstabent_t *)) : jas_alloc2(maxents, sizeof(jpc_ppxstabent_t *));\n\t\tif (!newents) {\n\t\t\treturn -1;\n\t\t}\n\t\ttab->ents = newents;\n\t\ttab->maxents = maxents;\n\t}\n\treturn 0;\n}\n\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n{\n\tjpc_streamlist_t *streams;\n\tjas_uchar *dataptr;\n\tuint_fast32_t datacnt;\n\tuint_fast32_t tpcnt;\n\tjpc_ppxstabent_t *ent;\n\tint entno;\n\tjas_stream_t *stream;\n\tint n;\n\n\tif (!(streams = jpc_streamlist_create())) {\n\t\tgoto error;\n\t}\n\n\tif (!tab->numents) {\n\t\treturn streams;\n\t}\n\n\tentno = 0;\n\tent = tab->ents[entno];\n\tdataptr = ent->data;\n\tdatacnt = ent->len;\n\tfor (;;) {\n\n\t\t/* Get the length of the packet header data for the current\n\t\t  tile-part. */\n\t\tif (datacnt < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(stream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),\n\t\t  stream)) {\n\t\t\tgoto error;\n\t\t}\n\t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)\n\t\t  | dataptr[3];\n\t\tdatacnt -= 4;\n\t\tdataptr += 4;\n\n\t\t/* Get the packet header data for the current tile-part. */\n\t\twhile (tpcnt) {\n\t\t\tif (!datacnt) {\n\t\t\t\tif (++entno >= tab->numents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tent = tab->ents[entno];\n\t\t\t\tdataptr = ent->data;\n\t\t\t\tdatacnt = ent->len;\n\t\t\t}\n\t\t\tn = JAS_MIN(tpcnt, datacnt);\n\t\t\tif (jas_stream_write(stream, dataptr, n) != n) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttpcnt -= n;\n\t\t\tdataptr += n;\n\t\t\tdatacnt -= n;\n\t\t}\n\t\tjas_stream_rewind(stream);\n\t\tif (!datacnt) {\n\t\t\tif (++entno >= tab->numents) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = tab->ents[entno];\n\t\t\tdataptr = ent->data;\n\t\t\tdatacnt = ent->len;\n\t\t}\n\t}\n\n\treturn streams;\n\nerror:\n\tif (streams) {\n\t\tjpc_streamlist_destroy(streams);\n\t}\n\treturn 0;\n}\n\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab)\n{\n\tint i;\n\tjpc_ppxstabent_t *ent;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tent = tab->ents[i];\n\t\tif (jas_stream_write(out, ent->data, ent->len) != JAS_CAST(int, ent->len)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\njpc_ppxstabent_t *jpc_ppxstabent_create()\n{\n\tjpc_ppxstabent_t *ent;\n\tif (!(ent = jas_malloc(sizeof(jpc_ppxstabent_t)))) {\n\t\treturn 0;\n\t}\n\tent->data = 0;\n\tent->len = 0;\n\tent->ind = 0;\n\treturn ent;\n}\n\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent)\n{\n\tif (ent->data) {\n\t\tjas_free(ent->data);\n\t}\n\tjas_free(ent);\n}\n"], "buggy_code_start_loc": [715], "buggy_code_end_loc": [716], "fixing_code_start_loc": [715], "fixing_code_end_loc": [716], "type": "CWE-787", "message": "Stack-based buffer overflow in the jpc_tsfb_getbands2 function in jpc_tsfb.c in JasPer before 1.900.30 allows remote attackers to have unspecified impact via a crafted image.", "other": {"cve": {"id": "CVE-2016-9560", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-15T19:59:01.173", "lastModified": "2021-03-15T22:08:39.907", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stack-based buffer overflow in the jpc_tsfb_getbands2 function in jpc_tsfb.c in JasPer before 1.900.30 allows remote attackers to have unspecified impact via a crafted image."}, {"lang": "es", "value": "El desbordamiento del b\u00fafer basado en la pila en la funci\u00f3n jpc_tsfb_getbands2 en jpc_tsfb.c en JasPer antes de la versi\u00f3n 1.900.30 permite a los atacantes remotos tener un impacto no especificado a trav\u00e9s de una imagen manipulada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.900.30", "matchCriteriaId": "7C65596E-E47A-46AC-9C6B-541B69A17E1C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "807C024A-F8E8-4B48-A349-4C68CD252CA1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "F96E3779-F56A-45FF-BB3D-4980527D721E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "0CF73560-2F5B-4723-A8A1-9AADBB3ADA00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5BF3C7A5-9117-42C7-BEA1-4AA378A582EF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "83737173-E12E-4641-BC49-0BD84A6B29D0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "7431ABC1-9252-419E-8CC1-311B41360078"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "17F256A9-D3B9-4C72-B013-4EFD878BFEA8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3785", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/20/1", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/23/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94428", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1208", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://blogs.gentoo.org/ago/2016/11/20/jasper-stack-based-buffer-overflow-in-jpc_tsfb_getbands2-jpc_tsfb-c/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/Hack-Me/Pocs_for_Multi_Versions/tree/main/CVE-2016-9560", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/mdadams/jasper/commit/1abc2e5a401a4bf1d5ca4df91358ce5df111f495", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/1abc2e5a401a4bf1d5ca4df91358ce5df111f495"}}