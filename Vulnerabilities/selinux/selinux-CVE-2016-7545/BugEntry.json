{"buggy_code": ["#! /usr/bin/python -Es\n# Authors: Dan Walsh <dwalsh@redhat.com>\n# Authors: Thomas Liu <tliu@fedoraproject.org>\n# Authors: Josh Cogliati\n#\n# Copyright (C) 2009,2010  Red Hat\n# see file 'COPYING' for use and warranty information\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; version 2 only\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n#\n\nimport os\nimport stat\nimport sys\nimport socket\nimport random\nimport fcntl\nimport shutil\nimport re\nimport subprocess\nimport selinux\nimport signal\nfrom tempfile import mkdtemp\nimport pwd\nimport sepolicy\n\nSEUNSHARE = \"/usr/sbin/seunshare\"\nSANDBOXSH = \"/usr/share/sandbox/sandboxX.sh\"\nPROGNAME = \"policycoreutils\"\ntry:\n    import gettext\n    kwargs = {}\n    if sys.version_info < (3,):\n        kwargs['unicode'] = True\n    gettext.install(PROGNAME,\n                    localedir=\"/usr/share/locale\",\n                    codeset='utf-8',\n                    **kwargs)\nexcept:\n    try:\n        import builtins\n        builtins.__dict__['_'] = str\n    except ImportError:\n        import __builtin__\n        __builtin__.__dict__['_'] = unicode\n\nDEFAULT_WINDOWSIZE = \"1000x700\"\nDEFAULT_TYPE = \"sandbox_t\"\nDEFAULT_X_TYPE = \"sandbox_x_t\"\nSAVE_FILES = {}\n\nrandom.seed(None)\n\n\ndef sighandler(signum, frame):\n    signal.signal(signum, signal.SIG_IGN)\n    os.kill(0, signum)\n    raise KeyboardInterrupt\n\n\ndef setup_sighandlers():\n    signal.signal(signal.SIGHUP, sighandler)\n    signal.signal(signal.SIGQUIT, sighandler)\n    signal.signal(signal.SIGTERM, sighandler)\n\n\ndef error_exit(msg):\n    sys.stderr.write(\"%s: \" % sys.argv[0])\n    sys.stderr.write(\"%s\\n\" % msg)\n    sys.stderr.flush()\n    sys.exit(1)\n\n\ndef copyfile(file, srcdir, dest):\n    import re\n    if file.startswith(srcdir):\n        dname = os.path.dirname(file)\n        bname = os.path.basename(file)\n        if dname == srcdir:\n            dest = dest + \"/\" + bname\n        else:\n            newdir = re.sub(srcdir, dest, dname)\n            if not os.path.exists(newdir):\n                os.makedirs(newdir)\n            dest = newdir + \"/\" + bname\n\n        try:\n            if os.path.isdir(file):\n                shutil.copytree(file, dest)\n            else:\n                shutil.copy2(file, dest)\n\n        except shutil.Error as elist:\n            for e in elist.message:\n                sys.stderr.write(e[2])\n\n        SAVE_FILES[file] = (dest, os.path.getmtime(dest))\n\n\ndef savefile(new, orig, X_ind):\n    copy = False\n    if(X_ind):\n        import gi\n        gi.require_version('Gtk', '3.0')\n        from gi.repository import Gtk\n        dlg = Gtk.MessageDialog(None, 0, Gtk.MessageType.INFO,\n                                Gtk.ButtonsType.YES_NO,\n                                _(\"Do you want to save changes to '%s' (Y/N): \") % orig)\n        dlg.set_title(_(\"Sandbox Message\"))\n        dlg.set_position(Gtk.WindowPosition.MOUSE)\n        dlg.show_all()\n        rc = dlg.run()\n        dlg.destroy()\n        if rc == Gtk.ResponseType.YES:\n            copy = True\n    else:\n        try:\n            input = raw_input\n        except NameError:\n            pass\n        ans = input(_(\"Do you want to save changes to '%s' (y/N): \") % orig)\n        if(re.match(_(\"[yY]\"), ans)):\n            copy = True\n    if(copy):\n        shutil.copy2(new, orig)\n\n\ndef reserve(level):\n    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    sock.bind(\"\\0%s\" % level)\n    fcntl.fcntl(sock.fileno(), fcntl.F_SETFD, fcntl.FD_CLOEXEC)\n\n\ndef get_range():\n    try:\n        level = selinux.getcon_raw()[1].split(\":\")[4]\n        lowc, highc = level.split(\".\")\n        low = int(lowc[1:])\n        high = int(highc[1:]) + 1\n        if high - low == 0:\n            raise IndexError\n\n        return low, high\n    except IndexError:\n        raise ValueError(_(\"User account must be setup with an MCS Range\"))\n\n\ndef gen_mcs():\n    low, high = get_range()\n\n    level = None\n    ctr = 0\n    total = high - low\n    total = (total * (total - 1)) / 2\n    while ctr < total:\n        ctr += 1\n        i1 = random.randrange(low, high)\n        i2 = random.randrange(low, high)\n        if i1 == i2:\n            continue\n        if i1 > i2:\n            tmp = i1\n            i1 = i2\n            i2 = tmp\n        level = \"s0:c%d,c%d\" % (i1, i2)\n        try:\n            reserve(level)\n        except socket.error:\n            continue\n        break\n    if level:\n        return level\n    raise ValueError(_(\"Failed to find any unused category sets.  Consider a larger MCS range for this user.\"))\n\n\ndef fullpath(cmd):\n    for i in [\"/\", \"./\", \"../\"]:\n        if cmd.startswith(i):\n            return cmd\n    for i in os.environ[\"PATH\"].split(':'):\n        f = \"%s/%s\" % (i, cmd)\n        if os.access(f, os.X_OK):\n            return f\n    return cmd\n\n\nclass Sandbox:\n    SYSLOG = \"/var/log/messages\"\n\n    def __init__(self):\n        self.setype = DEFAULT_TYPE\n        self.__options = None\n        self.__cmds = None\n        self.__init_files = []\n        self.__paths = []\n        self.__mount = False\n        self.__level = None\n        self.__homedir = None\n        self.__tmpdir = None\n\n    def __validate_mount(self):\n        if self.__options.level:\n            if not self.__options.homedir or not self.__options.tmpdir:\n                self.usage(_(\"Homedir and tempdir required for level mounts\"))\n\n        if not os.path.exists(SEUNSHARE):\n            raise ValueError(_(\"\"\"\n%s is required for the action you want to perform.\n\"\"\") % SEUNSHARE)\n\n    def __mount_callback(self, option, opt, value, parser):\n        self.__mount = True\n\n    def __x_callback(self, option, opt, value, parser):\n        self.__mount = True\n        setattr(parser.values, option.dest, True)\n        if not os.path.exists(SEUNSHARE):\n            raise ValueError(_(\"\"\"\n%s is required for the action you want to perform.\n\"\"\") % SEUNSHARE)\n\n        if not os.path.exists(SANDBOXSH):\n            raise ValueError(_(\"\"\"\n%s is required for the action you want to perform.\n\"\"\") % SANDBOXSH)\n\n    def __validdir(self, option, opt, value, parser):\n        if not os.path.isdir(value):\n            raise IOError(\"Directory \" + value + \" not found\")\n        setattr(parser.values, option.dest, value)\n        self.__mount = True\n\n    def __include(self, option, opt, value, parser):\n        rp = os.path.realpath(os.path.expanduser(value))\n        if not os.path.exists(rp):\n            raise IOError(value + \" not found\")\n\n        if rp not in self.__init_files:\n            self.__init_files.append(rp)\n\n    def __includefile(self, option, opt, value, parser):\n        fd = open(value, \"r\")\n        for i in fd.readlines():\n            try:\n                self.__include(option, opt, i[:-1], parser)\n            except IOError as e:\n                sys.stderr.write(str(e))\n            except TypeError as e:\n                sys.stderr.write(str(e))\n        fd.close()\n\n    def __copyfiles(self):\n        files = self.__init_files + self.__paths\n        homedir = pwd.getpwuid(os.getuid()).pw_dir\n        for f in files:\n            copyfile(f, homedir, self.__homedir)\n            copyfile(f, \"/tmp\", self.__tmpdir)\n            copyfile(f, \"/var/tmp\", self.__tmpdir)\n\n    def __setup_sandboxrc(self, wm=\"/usr/bin/openbox\"):\n        execfile = self.__homedir + \"/.sandboxrc\"\n        fd = open(execfile, \"w+\")\n        if self.__options.session:\n            fd.write(\"\"\"#!/bin/sh\n#TITLE: /etc/gdm/Xsession\n/etc/gdm/Xsession\n\"\"\")\n        else:\n            command = self.__paths[0] + \" \"\n            for p in self.__paths[1:]:\n                command += \"'%s' \" % p\n            fd.write(\"\"\"#! /bin/sh\n#TITLE: %s\n# /usr/bin/test -r ~/.xmodmap && /usr/bin/xmodmap ~/.xmodmap\n%s &\nWM_PID=$!\ndbus-launch --exit-with-session %s\nkill -TERM $WM_PID  2> /dev/null\n\"\"\" % (command, wm, command))\n        fd.close()\n        os.chmod(execfile, 0o700)\n\n    def usage(self, message=\"\"):\n        error_exit(\"%s\\n%s\" % (self.__parser.usage, message))\n\n    def __parse_options(self):\n        from optparse import OptionParser\n        types = \"\"\n        try:\n            types = _(\"\"\"\nPolicy defines the following types for use with the -t:\n\\t%s\n\"\"\") % \"\\n\\t\".join(sepolicy.info(sepolicy.ATTRIBUTE, \"sandbox_type\")[0]['types'])\n        except RuntimeError:\n            pass\n\n        usage = _(\"\"\"\nsandbox [-h] [-l level ] [-[X|M] [-H homedir] [-T tempdir]] [-I includefile ] [-W windowmanager ] [ -w windowsize ] [[-i file ] ...] [ -t type ] command\n\nsandbox [-h] [-l level ] [-[X|M] [-H homedir] [-T tempdir]] [-I includefile ] [-W windowmanager ] [ -w windowsize ] [[-i file ] ...] [ -t type ] -S\n%s\n\"\"\") % types\n\n        parser = OptionParser(usage=usage)\n        parser.disable_interspersed_args()\n        parser.add_option(\"-i\", \"--include\",\n                          action=\"callback\", callback=self.__include,\n                          type=\"string\",\n                          help=_(\"include file in sandbox\"))\n        parser.add_option(\"-I\", \"--includefile\", action=\"callback\", callback=self.__includefile,\n                          type=\"string\",\n                          help=_(\"read list of files to include in sandbox from INCLUDEFILE\"))\n        parser.add_option(\"-t\", \"--type\", dest=\"setype\", action=\"store\", default=None,\n                          help=_(\"run sandbox with SELinux type\"))\n        parser.add_option(\"-M\", \"--mount\",\n                          action=\"callback\", callback=self.__mount_callback,\n                          help=_(\"mount new home and/or tmp directory\"))\n\n        parser.add_option(\"-d\", \"--dpi\",\n                          dest=\"dpi\", action=\"store\",\n                          help=_(\"dots per inch for X display\"))\n\n        parser.add_option(\"-S\", \"--session\", action=\"store_true\", dest=\"session\",\n                          default=False, help=_(\"run complete desktop session within sandbox\"))\n\n        parser.add_option(\"-s\", \"--shred\", action=\"store_true\", dest=\"shred\",\n                          default=False, help=_(\"Shred content before tempory directories are removed\"))\n\n        parser.add_option(\"-X\", dest=\"X_ind\",\n                          action=\"callback\", callback=self.__x_callback,\n                          default=False, help=_(\"run X application within a sandbox\"))\n\n        parser.add_option(\"-H\", \"--homedir\",\n                          action=\"callback\", callback=self.__validdir,\n                          type=\"string\",\n                          dest=\"homedir\",\n                          help=_(\"alternate home directory to use for mounting\"))\n\n        parser.add_option(\"-T\", \"--tmpdir\", dest=\"tmpdir\",\n                          type=\"string\",\n                          action=\"callback\", callback=self.__validdir,\n                          help=_(\"alternate /tmp directory to use for mounting\"))\n\n        parser.add_option(\"-w\", \"--windowsize\", dest=\"windowsize\",\n                          type=\"string\", default=DEFAULT_WINDOWSIZE,\n                          help=\"size of the sandbox window\")\n\n        parser.add_option(\"-W\", \"--windowmanager\", dest=\"wm\",\n                          type=\"string\",\n                          default=\"/usr/bin/openbox\",\n                          help=_(\"alternate window manager\"))\n\n        parser.add_option(\"-l\", \"--level\", dest=\"level\",\n                          help=_(\"MCS/MLS level for the sandbox\"))\n\n        parser.add_option(\"-C\", \"--capabilities\",\n                          action=\"store_true\", dest=\"usecaps\", default=False,\n                          help=\"Allow apps requiring capabilities to run within the sandbox.\")\n\n        self.__parser = parser\n\n        self.__options, cmds = parser.parse_args()\n\n        if self.__options.X_ind:\n            self.setype = DEFAULT_X_TYPE\n        else:\n            try:\n                sepolicy.info(sepolicy.TYPE, \"sandbox_t\")\n            except RuntimeError:\n                raise ValueError(_(\"Sandbox Policy is not currently installed.\\nYou need to install the selinux-policy-sandbox package in order to run this command\"))\n\n        if self.__options.setype:\n            self.setype = self.__options.setype\n\n        if self.__mount:\n            self.__validate_mount()\n\n        if self.__options.session:\n            if not self.__options.setype:\n                self.setype = selinux.getcon()[1].split(\":\")[2]\n            if not self.__options.homedir or not self.__options.tmpdir:\n                self.usage(_(\"You must specify a Homedir and tempdir when setting up a session sandbox\"))\n            if len(cmds) > 0:\n                self.usage(_(\"Commands are not allowed in a session sandbox\"))\n            self.__options.X_ind = True\n            self.__homedir = self.__options.homedir\n            self.__tmpdir = self.__options.tmpdir\n        else:\n            if self.__options.level:\n                self.__homedir = self.__options.homedir\n                self.__tmpdir = self.__options.tmpdir\n\n            if len(cmds) == 0:\n                self.usage(_(\"Command required\"))\n            cmds[0] = fullpath(cmds[0])\n            if not os.access(cmds[0], os.X_OK):\n                self.usage(_(\"%s is not an executable\") % cmds[0])\n\n            self.__cmds = cmds\n\n        for f in cmds:\n            rp = os.path.realpath(f)\n            if os.path.exists(rp):\n                self.__paths.append(rp)\n            else:\n                self.__paths.append(f)\n\n    def __gen_context(self):\n        if self.__options.level:\n            level = self.__options.level\n        else:\n            level = gen_mcs()\n\n        con = selinux.getcon()[1].split(\":\")\n        self.__execcon = \"%s:%s:%s:%s\" % (con[0], con[1], self.setype, level)\n        self.__filecon = \"%s:object_r:sandbox_file_t:%s\" % (con[0], level)\n\n    def __setup_dir(self):\n        selinux.setfscreatecon(self.__filecon)\n        if self.__options.homedir:\n            self.__homedir = self.__options.homedir\n        else:\n            self.__homedir = mkdtemp(dir=\"/tmp\", prefix=\".sandbox_home_\")\n\n        if self.__options.tmpdir:\n            self.__tmpdir = self.__options.tmpdir\n        else:\n            self.__tmpdir = mkdtemp(dir=\"/tmp\", prefix=\".sandbox_tmp_\")\n        self.__copyfiles()\n        selinux.chcon(self.__homedir, self.__filecon, recursive=True)\n        selinux.chcon(self.__tmpdir, self.__filecon, recursive=True)\n        selinux.setfscreatecon(None)\n\n    def __execute(self):\n        try:\n            cmds = [SEUNSHARE, \"-Z\", self.__execcon]\n            if self.__options.usecaps:\n                cmds.append('-C')\n            if self.__mount:\n                cmds += [\"-t\", self.__tmpdir, \"-h\", self.__homedir]\n\n                if self.__options.X_ind:\n                    if self.__options.dpi:\n                        dpi = self.__options.dpi\n                    else:\n                        import gi\n                        gi.require_version('Gtk', '3.0')\n                        from gi.repository import Gtk\n                        dpi = str(Gtk.Settings.get_default().props.gtk_xft_dpi / 1024)\n\n                    xmodmapfile = self.__homedir + \"/.xmodmap\"\n                    xd = open(xmodmapfile, \"w\")\n                    subprocess.Popen([\"/usr/bin/xmodmap\", \"-pke\"], stdout=xd).wait()\n                    xd.close()\n\n                    self.__setup_sandboxrc(self.__options.wm)\n\n                    cmds += [\"--\", SANDBOXSH, self.__options.windowsize, dpi]\n                else:\n                    cmds += [\"--\"] + self.__paths\n                return subprocess.Popen(cmds).wait()\n\n            selinux.setexeccon(self.__execcon)\n            rc = subprocess.Popen(self.__cmds).wait()\n            selinux.setexeccon(None)\n            return rc\n\n        finally:\n            for i in self.__paths:\n                if i not in SAVE_FILES:\n                    continue\n                (dest, mtime) = SAVE_FILES[i]\n                if os.path.getmtime(dest) > mtime:\n                    savefile(dest, i, self.__options.X_ind)\n\n            if self.__homedir and not self.__options.homedir:\n                if self.__options.shred:\n                    self.shred(self.__homedir)\n                shutil.rmtree(self.__homedir)\n            if self.__tmpdir and not self.__options.tmpdir:\n                if self.__options.shred:\n                    self.shred(self.__homedir)\n                shutil.rmtree(self.__tmpdir)\n\n    def shred(self, path):\n        for root, dirs, files in os.walk(path):\n            for f in files:\n                dest = root + \"/\" + f\n                subprocess.Popen([\"/usr/bin/shred\", dest]).wait()\n\n    def main(self):\n        try:\n            self.__parse_options()\n            self.__gen_context()\n            if self.__mount:\n                self.__setup_dir()\n            return self.__execute()\n        except KeyboardInterrupt:\n            sys.exit(0)\n\n\nif __name__ == '__main__':\n    setup_sighandlers()\n    if selinux.is_selinux_enabled() != 1:\n        error_exit(\"Requires an SELinux enabled system\")\n\n    try:\n        sandbox = Sandbox()\n        rc = sandbox.main()\n    except OSError as error:\n        error_exit(error)\n    except ValueError as error:\n        error_exit(error.args[0])\n    except KeyError as error:\n        error_exit(_(\"Invalid value %s\") % error.args[0])\n    except IOError as error:\n        error_exit(error)\n    except KeyboardInterrupt:\n        rc = 0\n\n    sys.exit(rc)\n"], "fixing_code": ["#! /usr/bin/python -Es\n# Authors: Dan Walsh <dwalsh@redhat.com>\n# Authors: Thomas Liu <tliu@fedoraproject.org>\n# Authors: Josh Cogliati\n#\n# Copyright (C) 2009,2010  Red Hat\n# see file 'COPYING' for use and warranty information\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; version 2 only\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n#\n\nimport os\nimport stat\nimport sys\nimport socket\nimport random\nimport fcntl\nimport shutil\nimport re\nimport subprocess\nimport selinux\nimport signal\nfrom tempfile import mkdtemp\nimport pwd\nimport sepolicy\n\nSEUNSHARE = \"/usr/sbin/seunshare\"\nSANDBOXSH = \"/usr/share/sandbox/sandboxX.sh\"\nPROGNAME = \"policycoreutils\"\ntry:\n    import gettext\n    kwargs = {}\n    if sys.version_info < (3,):\n        kwargs['unicode'] = True\n    gettext.install(PROGNAME,\n                    localedir=\"/usr/share/locale\",\n                    codeset='utf-8',\n                    **kwargs)\nexcept:\n    try:\n        import builtins\n        builtins.__dict__['_'] = str\n    except ImportError:\n        import __builtin__\n        __builtin__.__dict__['_'] = unicode\n\nDEFAULT_WINDOWSIZE = \"1000x700\"\nDEFAULT_TYPE = \"sandbox_t\"\nDEFAULT_X_TYPE = \"sandbox_x_t\"\nSAVE_FILES = {}\n\nrandom.seed(None)\n\n\ndef sighandler(signum, frame):\n    signal.signal(signum, signal.SIG_IGN)\n    os.kill(0, signum)\n    raise KeyboardInterrupt\n\n\ndef setup_sighandlers():\n    signal.signal(signal.SIGHUP, sighandler)\n    signal.signal(signal.SIGQUIT, sighandler)\n    signal.signal(signal.SIGTERM, sighandler)\n\n\ndef error_exit(msg):\n    sys.stderr.write(\"%s: \" % sys.argv[0])\n    sys.stderr.write(\"%s\\n\" % msg)\n    sys.stderr.flush()\n    sys.exit(1)\n\n\ndef copyfile(file, srcdir, dest):\n    import re\n    if file.startswith(srcdir):\n        dname = os.path.dirname(file)\n        bname = os.path.basename(file)\n        if dname == srcdir:\n            dest = dest + \"/\" + bname\n        else:\n            newdir = re.sub(srcdir, dest, dname)\n            if not os.path.exists(newdir):\n                os.makedirs(newdir)\n            dest = newdir + \"/\" + bname\n\n        try:\n            if os.path.isdir(file):\n                shutil.copytree(file, dest)\n            else:\n                shutil.copy2(file, dest)\n\n        except shutil.Error as elist:\n            for e in elist.message:\n                sys.stderr.write(e[2])\n\n        SAVE_FILES[file] = (dest, os.path.getmtime(dest))\n\n\ndef savefile(new, orig, X_ind):\n    copy = False\n    if(X_ind):\n        import gi\n        gi.require_version('Gtk', '3.0')\n        from gi.repository import Gtk\n        dlg = Gtk.MessageDialog(None, 0, Gtk.MessageType.INFO,\n                                Gtk.ButtonsType.YES_NO,\n                                _(\"Do you want to save changes to '%s' (Y/N): \") % orig)\n        dlg.set_title(_(\"Sandbox Message\"))\n        dlg.set_position(Gtk.WindowPosition.MOUSE)\n        dlg.show_all()\n        rc = dlg.run()\n        dlg.destroy()\n        if rc == Gtk.ResponseType.YES:\n            copy = True\n    else:\n        try:\n            input = raw_input\n        except NameError:\n            pass\n        ans = input(_(\"Do you want to save changes to '%s' (y/N): \") % orig)\n        if(re.match(_(\"[yY]\"), ans)):\n            copy = True\n    if(copy):\n        shutil.copy2(new, orig)\n\n\ndef reserve(level):\n    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    sock.bind(\"\\0%s\" % level)\n    fcntl.fcntl(sock.fileno(), fcntl.F_SETFD, fcntl.FD_CLOEXEC)\n\n\ndef get_range():\n    try:\n        level = selinux.getcon_raw()[1].split(\":\")[4]\n        lowc, highc = level.split(\".\")\n        low = int(lowc[1:])\n        high = int(highc[1:]) + 1\n        if high - low == 0:\n            raise IndexError\n\n        return low, high\n    except IndexError:\n        raise ValueError(_(\"User account must be setup with an MCS Range\"))\n\n\ndef gen_mcs():\n    low, high = get_range()\n\n    level = None\n    ctr = 0\n    total = high - low\n    total = (total * (total - 1)) / 2\n    while ctr < total:\n        ctr += 1\n        i1 = random.randrange(low, high)\n        i2 = random.randrange(low, high)\n        if i1 == i2:\n            continue\n        if i1 > i2:\n            tmp = i1\n            i1 = i2\n            i2 = tmp\n        level = \"s0:c%d,c%d\" % (i1, i2)\n        try:\n            reserve(level)\n        except socket.error:\n            continue\n        break\n    if level:\n        return level\n    raise ValueError(_(\"Failed to find any unused category sets.  Consider a larger MCS range for this user.\"))\n\n\ndef fullpath(cmd):\n    for i in [\"/\", \"./\", \"../\"]:\n        if cmd.startswith(i):\n            return cmd\n    for i in os.environ[\"PATH\"].split(':'):\n        f = \"%s/%s\" % (i, cmd)\n        if os.access(f, os.X_OK):\n            return f\n    return cmd\n\n\nclass Sandbox:\n    SYSLOG = \"/var/log/messages\"\n\n    def __init__(self):\n        self.setype = DEFAULT_TYPE\n        self.__options = None\n        self.__cmds = None\n        self.__init_files = []\n        self.__paths = []\n        self.__mount = False\n        self.__level = None\n        self.__homedir = None\n        self.__tmpdir = None\n\n    def __validate_mount(self):\n        if self.__options.level:\n            if not self.__options.homedir or not self.__options.tmpdir:\n                self.usage(_(\"Homedir and tempdir required for level mounts\"))\n\n        if not os.path.exists(SEUNSHARE):\n            raise ValueError(_(\"\"\"\n%s is required for the action you want to perform.\n\"\"\") % SEUNSHARE)\n\n    def __mount_callback(self, option, opt, value, parser):\n        self.__mount = True\n\n    def __x_callback(self, option, opt, value, parser):\n        self.__mount = True\n        setattr(parser.values, option.dest, True)\n        if not os.path.exists(SEUNSHARE):\n            raise ValueError(_(\"\"\"\n%s is required for the action you want to perform.\n\"\"\") % SEUNSHARE)\n\n        if not os.path.exists(SANDBOXSH):\n            raise ValueError(_(\"\"\"\n%s is required for the action you want to perform.\n\"\"\") % SANDBOXSH)\n\n    def __validdir(self, option, opt, value, parser):\n        if not os.path.isdir(value):\n            raise IOError(\"Directory \" + value + \" not found\")\n        setattr(parser.values, option.dest, value)\n        self.__mount = True\n\n    def __include(self, option, opt, value, parser):\n        rp = os.path.realpath(os.path.expanduser(value))\n        if not os.path.exists(rp):\n            raise IOError(value + \" not found\")\n\n        if rp not in self.__init_files:\n            self.__init_files.append(rp)\n\n    def __includefile(self, option, opt, value, parser):\n        fd = open(value, \"r\")\n        for i in fd.readlines():\n            try:\n                self.__include(option, opt, i[:-1], parser)\n            except IOError as e:\n                sys.stderr.write(str(e))\n            except TypeError as e:\n                sys.stderr.write(str(e))\n        fd.close()\n\n    def __copyfiles(self):\n        files = self.__init_files + self.__paths\n        homedir = pwd.getpwuid(os.getuid()).pw_dir\n        for f in files:\n            copyfile(f, homedir, self.__homedir)\n            copyfile(f, \"/tmp\", self.__tmpdir)\n            copyfile(f, \"/var/tmp\", self.__tmpdir)\n\n    def __setup_sandboxrc(self, wm=\"/usr/bin/openbox\"):\n        execfile = self.__homedir + \"/.sandboxrc\"\n        fd = open(execfile, \"w+\")\n        if self.__options.session:\n            fd.write(\"\"\"#!/bin/sh\n#TITLE: /etc/gdm/Xsession\n/etc/gdm/Xsession\n\"\"\")\n        else:\n            command = self.__paths[0] + \" \"\n            for p in self.__paths[1:]:\n                command += \"'%s' \" % p\n            fd.write(\"\"\"#! /bin/sh\n#TITLE: %s\n# /usr/bin/test -r ~/.xmodmap && /usr/bin/xmodmap ~/.xmodmap\n%s &\nWM_PID=$!\ndbus-launch --exit-with-session %s\nkill -TERM $WM_PID  2> /dev/null\n\"\"\" % (command, wm, command))\n        fd.close()\n        os.chmod(execfile, 0o700)\n\n    def usage(self, message=\"\"):\n        error_exit(\"%s\\n%s\" % (self.__parser.usage, message))\n\n    def __parse_options(self):\n        from optparse import OptionParser\n        types = \"\"\n        try:\n            types = _(\"\"\"\nPolicy defines the following types for use with the -t:\n\\t%s\n\"\"\") % \"\\n\\t\".join(sepolicy.info(sepolicy.ATTRIBUTE, \"sandbox_type\")[0]['types'])\n        except RuntimeError:\n            pass\n\n        usage = _(\"\"\"\nsandbox [-h] [-l level ] [-[X|M] [-H homedir] [-T tempdir]] [-I includefile ] [-W windowmanager ] [ -w windowsize ] [[-i file ] ...] [ -t type ] command\n\nsandbox [-h] [-l level ] [-[X|M] [-H homedir] [-T tempdir]] [-I includefile ] [-W windowmanager ] [ -w windowsize ] [[-i file ] ...] [ -t type ] -S\n%s\n\"\"\") % types\n\n        parser = OptionParser(usage=usage)\n        parser.disable_interspersed_args()\n        parser.add_option(\"-i\", \"--include\",\n                          action=\"callback\", callback=self.__include,\n                          type=\"string\",\n                          help=_(\"include file in sandbox\"))\n        parser.add_option(\"-I\", \"--includefile\", action=\"callback\", callback=self.__includefile,\n                          type=\"string\",\n                          help=_(\"read list of files to include in sandbox from INCLUDEFILE\"))\n        parser.add_option(\"-t\", \"--type\", dest=\"setype\", action=\"store\", default=None,\n                          help=_(\"run sandbox with SELinux type\"))\n        parser.add_option(\"-M\", \"--mount\",\n                          action=\"callback\", callback=self.__mount_callback,\n                          help=_(\"mount new home and/or tmp directory\"))\n\n        parser.add_option(\"-d\", \"--dpi\",\n                          dest=\"dpi\", action=\"store\",\n                          help=_(\"dots per inch for X display\"))\n\n        parser.add_option(\"-S\", \"--session\", action=\"store_true\", dest=\"session\",\n                          default=False, help=_(\"run complete desktop session within sandbox\"))\n\n        parser.add_option(\"-s\", \"--shred\", action=\"store_true\", dest=\"shred\",\n                          default=False, help=_(\"Shred content before tempory directories are removed\"))\n\n        parser.add_option(\"-X\", dest=\"X_ind\",\n                          action=\"callback\", callback=self.__x_callback,\n                          default=False, help=_(\"run X application within a sandbox\"))\n\n        parser.add_option(\"-H\", \"--homedir\",\n                          action=\"callback\", callback=self.__validdir,\n                          type=\"string\",\n                          dest=\"homedir\",\n                          help=_(\"alternate home directory to use for mounting\"))\n\n        parser.add_option(\"-T\", \"--tmpdir\", dest=\"tmpdir\",\n                          type=\"string\",\n                          action=\"callback\", callback=self.__validdir,\n                          help=_(\"alternate /tmp directory to use for mounting\"))\n\n        parser.add_option(\"-w\", \"--windowsize\", dest=\"windowsize\",\n                          type=\"string\", default=DEFAULT_WINDOWSIZE,\n                          help=\"size of the sandbox window\")\n\n        parser.add_option(\"-W\", \"--windowmanager\", dest=\"wm\",\n                          type=\"string\",\n                          default=\"/usr/bin/openbox\",\n                          help=_(\"alternate window manager\"))\n\n        parser.add_option(\"-l\", \"--level\", dest=\"level\",\n                          help=_(\"MCS/MLS level for the sandbox\"))\n\n        parser.add_option(\"-C\", \"--capabilities\",\n                          action=\"store_true\", dest=\"usecaps\", default=False,\n                          help=\"Allow apps requiring capabilities to run within the sandbox.\")\n\n        self.__parser = parser\n\n        self.__options, cmds = parser.parse_args()\n\n        if self.__options.X_ind:\n            self.setype = DEFAULT_X_TYPE\n        else:\n            try:\n                sepolicy.info(sepolicy.TYPE, \"sandbox_t\")\n            except RuntimeError:\n                raise ValueError(_(\"Sandbox Policy is not currently installed.\\nYou need to install the selinux-policy-sandbox package in order to run this command\"))\n\n        if self.__options.setype:\n            self.setype = self.__options.setype\n\n        if self.__mount:\n            self.__validate_mount()\n\n        if self.__options.session:\n            if not self.__options.setype:\n                self.setype = selinux.getcon()[1].split(\":\")[2]\n            if not self.__options.homedir or not self.__options.tmpdir:\n                self.usage(_(\"You must specify a Homedir and tempdir when setting up a session sandbox\"))\n            if len(cmds) > 0:\n                self.usage(_(\"Commands are not allowed in a session sandbox\"))\n            self.__options.X_ind = True\n            self.__homedir = self.__options.homedir\n            self.__tmpdir = self.__options.tmpdir\n        else:\n            if self.__options.level:\n                self.__homedir = self.__options.homedir\n                self.__tmpdir = self.__options.tmpdir\n\n            if len(cmds) == 0:\n                self.usage(_(\"Command required\"))\n            cmds[0] = fullpath(cmds[0])\n            if not os.access(cmds[0], os.X_OK):\n                self.usage(_(\"%s is not an executable\") % cmds[0])\n\n            self.__cmds = cmds\n\n        for f in cmds:\n            rp = os.path.realpath(f)\n            if os.path.exists(rp):\n                self.__paths.append(rp)\n            else:\n                self.__paths.append(f)\n\n    def __gen_context(self):\n        if self.__options.level:\n            level = self.__options.level\n        else:\n            level = gen_mcs()\n\n        con = selinux.getcon()[1].split(\":\")\n        self.__execcon = \"%s:%s:%s:%s\" % (con[0], con[1], self.setype, level)\n        self.__filecon = \"%s:object_r:sandbox_file_t:%s\" % (con[0], level)\n\n    def __setup_dir(self):\n        selinux.setfscreatecon(self.__filecon)\n        if self.__options.homedir:\n            self.__homedir = self.__options.homedir\n        else:\n            self.__homedir = mkdtemp(dir=\"/tmp\", prefix=\".sandbox_home_\")\n\n        if self.__options.tmpdir:\n            self.__tmpdir = self.__options.tmpdir\n        else:\n            self.__tmpdir = mkdtemp(dir=\"/tmp\", prefix=\".sandbox_tmp_\")\n        self.__copyfiles()\n        selinux.chcon(self.__homedir, self.__filecon, recursive=True)\n        selinux.chcon(self.__tmpdir, self.__filecon, recursive=True)\n        selinux.setfscreatecon(None)\n\n    def __execute(self):\n        try:\n            cmds = [SEUNSHARE, \"-Z\", self.__execcon]\n            if self.__options.usecaps:\n                cmds.append('-C')\n            if self.__mount:\n                cmds += [\"-t\", self.__tmpdir, \"-h\", self.__homedir]\n\n                if self.__options.X_ind:\n                    if self.__options.dpi:\n                        dpi = self.__options.dpi\n                    else:\n                        import gi\n                        gi.require_version('Gtk', '3.0')\n                        from gi.repository import Gtk\n                        dpi = str(Gtk.Settings.get_default().props.gtk_xft_dpi / 1024)\n\n                    xmodmapfile = self.__homedir + \"/.xmodmap\"\n                    xd = open(xmodmapfile, \"w\")\n                    subprocess.Popen([\"/usr/bin/xmodmap\", \"-pke\"], stdout=xd).wait()\n                    xd.close()\n\n                    self.__setup_sandboxrc(self.__options.wm)\n\n                    cmds += [\"--\", SANDBOXSH, self.__options.windowsize, dpi]\n                else:\n                    cmds += [\"--\"] + self.__paths\n                return subprocess.Popen(cmds).wait()\n\n            pid = os.fork()\n            if pid == 0:\n                rc = os.setsid()\n                if rc:\n                    return rc\n                selinux.setexeccon(self.__execcon)\n                os.execv(self.__cmds[0], self.__cmds)\n            rc = os.waitpid(pid, 0)\n            return os.WEXITSTATUS(rc[1])\n\n        finally:\n            for i in self.__paths:\n                if i not in SAVE_FILES:\n                    continue\n                (dest, mtime) = SAVE_FILES[i]\n                if os.path.getmtime(dest) > mtime:\n                    savefile(dest, i, self.__options.X_ind)\n\n            if self.__homedir and not self.__options.homedir:\n                if self.__options.shred:\n                    self.shred(self.__homedir)\n                shutil.rmtree(self.__homedir)\n            if self.__tmpdir and not self.__options.tmpdir:\n                if self.__options.shred:\n                    self.shred(self.__homedir)\n                shutil.rmtree(self.__tmpdir)\n\n    def shred(self, path):\n        for root, dirs, files in os.walk(path):\n            for f in files:\n                dest = root + \"/\" + f\n                subprocess.Popen([\"/usr/bin/shred\", dest]).wait()\n\n    def main(self):\n        try:\n            self.__parse_options()\n            self.__gen_context()\n            if self.__mount:\n                self.__setup_dir()\n            return self.__execute()\n        except KeyboardInterrupt:\n            sys.exit(0)\n\n\nif __name__ == '__main__':\n    setup_sighandlers()\n    if selinux.is_selinux_enabled() != 1:\n        error_exit(\"Requires an SELinux enabled system\")\n\n    try:\n        sandbox = Sandbox()\n        rc = sandbox.main()\n    except OSError as error:\n        error_exit(error)\n    except ValueError as error:\n        error_exit(error.args[0])\n    except KeyError as error:\n        error_exit(_(\"Invalid value %s\") % error.args[0])\n    except IOError as error:\n        error_exit(error)\n    except KeyboardInterrupt:\n        rc = 0\n\n    sys.exit(rc)\n"], "buggy_code_start_loc": [474], "buggy_code_end_loc": [478], "fixing_code_start_loc": [474], "fixing_code_end_loc": [483], "type": "CWE-284", "message": "SELinux policycoreutils allows local users to execute arbitrary commands outside of the sandbox via a crafted TIOCSTI ioctl call.", "other": {"cve": {"id": "CVE-2016-7545", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-19T20:59:00.533", "lastModified": "2018-01-05T02:31:15.620", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "SELinux policycoreutils allows local users to execute arbitrary commands outside of the sandbox via a crafted TIOCSTI ioctl call."}, {"lang": "es", "value": "SELinux policycoreutils permite a usuarios locales ejecutar comandos arbitrarios fuera de la sandbox a trav\u00e9s de una llamada ioctl TIOCSTI manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:selinux_project:selinux:-:*:*:*:*:*:*:*", "matchCriteriaId": "4C42EBCF-BAC2-43F9-945A-E95A1B1B9078"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:25:*:*:*:*:*:*:*", "matchCriteriaId": "772E9557-A371-4664-AE2D-4135AAEB89AA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "C2FAC325-6EEB-466D-9EBA-8ED4DBC9CFBF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "3C84489B-B08C-4854-8A12-D01B6E45CF79"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2016-2702.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0535.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0536.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/25/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93156", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037283", "source": "cve@mitre.org"}, {"url": "https://github.com/SELinuxProject/selinux/commit/acca96a135a4d2a028ba9b636886af99c0915379", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UPRNK3PWMAVNJZ53YW5GOEOGJSFNAQIF/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://marc.info/?l=selinux&m=147465160112766&w=2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/SELinuxProject/selinux/commit/acca96a135a4d2a028ba9b636886af99c0915379"}}