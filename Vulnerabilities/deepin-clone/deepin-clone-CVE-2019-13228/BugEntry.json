{"buggy_code": ["/*\n * Copyright (C) 2017 ~ 2017 Deepin Technology Co., Ltd.\n *\n * Author:     zccrs <zccrs@live.com>\n *\n * Maintainer: zccrs <zhangjide@deepin.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#define private public\n#include <private/qiodevice_p.h>\n#undef private\n\n#include \"ddevicediskinfo.h\"\n#include \"ddiskinfo_p.h\"\n#include \"helper.h\"\n#include \"ddevicepartinfo.h\"\n#include \"dpartinfo_p.h\"\n\n#include <QJsonObject>\n#include <QJsonArray>\n#include <QJsonDocument>\n#include <QProcess>\n#include <QBuffer>\n\nstatic QString getPTName(const QString &device)\n{\n    Helper::processExec(QStringLiteral(\"/sbin/blkid -p -s PTTYPE -d -i %1\").arg(device));\n\n    const QByteArray &data = Helper::lastProcessStandardOutput();\n\n    if (data.isEmpty())\n        return QString();\n\n    const QByteArrayList &list = data.split('=');\n\n    if (list.count() != 3)\n        return QString();\n\n    return list.last().simplified();\n}\n\nclass DDeviceDiskInfoPrivate : public DDiskInfoPrivate\n{\npublic:\n    DDeviceDiskInfoPrivate(DDeviceDiskInfo *qq);\n    ~DDeviceDiskInfoPrivate();\n\n    void init(const QJsonObject &obj);\n\n    QString filePath() const Q_DECL_OVERRIDE;\n    void refresh() Q_DECL_OVERRIDE;\n\n    bool hasScope(DDiskInfo::DataScope scope, DDiskInfo::ScopeMode mode, int index = 0) const Q_DECL_OVERRIDE;\n    bool openDataStream(int index) Q_DECL_OVERRIDE;\n    void closeDataStream() Q_DECL_OVERRIDE;\n\n    // Unfulfilled\n    qint64 readableDataSize(DDiskInfo::DataScope scope) const Q_DECL_OVERRIDE;\n\n    qint64 totalReadableDataSize() const Q_DECL_OVERRIDE;\n    qint64 maxReadableDataSize() const Q_DECL_OVERRIDE;\n    qint64 totalWritableDataSize() const Q_DECL_OVERRIDE;\n\n    qint64 read(char *data, qint64 maxSize) Q_DECL_OVERRIDE;\n    qint64 write(const char *data, qint64 maxSize) Q_DECL_OVERRIDE;\n\n    bool atEnd() const Q_DECL_OVERRIDE;\n\n    QString errorString() const Q_DECL_OVERRIDE;\n\n    bool isClosing() const;\n\n    QProcess *process = NULL;\n    QBuffer buffer;\n    bool closing = false;\n};\n\nDDeviceDiskInfoPrivate::DDeviceDiskInfoPrivate(DDeviceDiskInfo *qq)\n    : DDiskInfoPrivate(qq)\n{\n\n}\n\nDDeviceDiskInfoPrivate::~DDeviceDiskInfoPrivate()\n{\n    closeDataStream();\n\n    if (process)\n        process->deleteLater();\n}\n\nvoid DDeviceDiskInfoPrivate::init(const QJsonObject &obj)\n{\n    model = obj.value(\"model\").toString();\n    name = obj.value(\"name\").toString();\n    kname = obj.value(\"kname\").toString();\n    size = obj.value(\"size\").toString().toLongLong();\n    typeName = obj.value(\"type\").toString();\n    readonly = obj.value(\"ro\").toString() == \"1\" || typeName == \"rom\";\n    removeable = obj.value(\"rm\").toString() == \"1\";\n    transport = obj.value(\"tran\").toString();\n    serial = obj.value(\"serial\").toString();\n\n    if (obj.value(\"pkname\").isNull())\n        type = DDiskInfo::Disk;\n    else\n        type = DDiskInfo::Part;\n\n    const QJsonArray &list = obj.value(\"children\").toArray();\n    QStringList children_uuids;\n\n    for (const QJsonValue &part : list) {\n        const QJsonObject &obj = part.toObject();\n\n        const QString &uuid = obj.value(\"partuuid\").toString();\n\n        if (!uuid.isEmpty() && children_uuids.contains(uuid))\n            continue;\n\n        DDevicePartInfo info;\n\n        info.init(obj);\n\n        if (!info.partUUID().isEmpty() && children_uuids.contains(info.partUUID()))\n            continue;\n\n        info.d->transport = transport;\n        children << info;\n        children_uuids << info.partUUID();\n    }\n\n    qSort(children.begin(), children.end(), [] (const DPartInfo &info1, const DPartInfo &info2) {\n        return info1.sizeStart() < info2.sizeStart();\n    });\n\n    if (type == DDiskInfo::Disk)\n        ptTypeName = getPTName(name);\n    else\n        ptTypeName = getPTName(obj.value(\"pkname\").toString());\n\n    if (ptTypeName == \"dos\") {\n        ptType = DDiskInfo::MBR;\n    } else if (ptTypeName == \"gpt\") {\n        ptType = DDiskInfo::GPT;\n    } else {\n        ptType = DDiskInfo::Unknow;\n        havePartitionTable = false;\n    }\n\n    if (type == DDiskInfo::Part)\n        havePartitionTable = false;\n\n    if ((!havePartitionTable && children.isEmpty()) || type == DDiskInfo::Part) {\n        DDevicePartInfo info;\n\n        info.init(obj);\n        info.d->transport = transport;\n        info.d->index = 0;\n        children << info;\n    }\n}\n\nQString DDeviceDiskInfoPrivate::filePath() const\n{\n    return name;\n}\n\nvoid DDeviceDiskInfoPrivate::refresh()\n{\n    children.clear();\n\n    const QJsonArray &block_devices = Helper::getBlockDevices(name);\n\n    if (!block_devices.isEmpty())\n        init(block_devices.first().toObject());\n}\n\nbool DDeviceDiskInfoPrivate::hasScope(DDiskInfo::DataScope scope, DDiskInfo::ScopeMode mode, int index) const\n{\n    if (mode == DDiskInfo::Read) {\n        if (scope == DDiskInfo::Headgear) {\n            return havePartitionTable && (children.isEmpty() || children.first().sizeStart() >= 1048576);\n        } else if (scope == DDiskInfo::JsonInfo) {\n            return true;\n        }\n\n        if (scope == DDiskInfo::PartitionTable)\n            return havePartitionTable;\n    } else if (readonly || scope == DDiskInfo::JsonInfo) {\n        return false;\n    }\n\n    if (scope == DDiskInfo::Partition) {\n        if (index == 0 && mode == DDiskInfo::Write)\n            return true;\n\n        const DPartInfo &info = q->getPartByNumber(index);\n\n        if (!info) {\n            dCDebug(\"Can not find parition by number(device: \\\"%s\\\"): %d\", qPrintable(q->filePath()), index);\n\n            return false;\n        }\n\n        if (info.isExtended() || (mode == DDiskInfo::Read\n                                  && info.type() == DPartInfo::Unknow\n                                  && info.fileSystemType() == DPartInfo::Invalid\n                                  && info.guidType() == DPartInfo::InvalidGUID)) {\n            dCDebug(\"Skip the \\\"%s\\\" partition, type: %s\", qPrintable(info.filePath()), qPrintable(info.typeDescription(info.type())));\n\n            return false;\n        }\n\n        return mode != DDiskInfo::Write || !info.isReadonly();\n    }\n\n    return (scope == DDiskInfo::Headgear || scope == DDiskInfo::PartitionTable) ? type == DDiskInfo::Disk : true;\n}\n\nbool DDeviceDiskInfoPrivate::openDataStream(int index)\n{\n    if (process) {\n        process->deleteLater();\n    }\n\n    process = new QProcess();\n\n    QObject::connect(process, static_cast<void (QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n                     process, [this] (int code, QProcess::ExitStatus status) {\n        if (isClosing())\n            return;\n\n        if (status == QProcess::CrashExit) {\n            setErrorString(QObject::tr(\"process \\\"%1 %2\\\" crashed\").arg(process->program()).arg(process->arguments().join(\" \")));\n        } else if (code != 0) {\n            setErrorString(QObject::tr(\"Failed to perform process \\\"%1 %2\\\", error: %3\").arg(process->program()).arg(process->arguments().join(\" \")).arg(QString::fromUtf8(process->readAllStandardError())));\n        }\n    });\n\n    switch (currentScope) {\n    case DDiskInfo::Headgear: {\n        if (type != DDiskInfo::Disk) {\n            setErrorString(QObject::tr(\"\\\"%1\\\" is not a disk device\").arg(filePath()));\n\n            return false;\n        }\n\n        if (currentMode == DDiskInfo::Read) {\n            process->start(QStringLiteral(\"dd if=%1 bs=512 count=2048 status=none\").arg(filePath()), QIODevice::ReadOnly);\n        } else {\n            process->start(QStringLiteral(\"dd of=%1 bs=512 status=none conv=fsync\").arg(filePath()));\n        }\n\n        break;\n    }\n    case DDiskInfo::PartitionTable: {\n        if (type != DDiskInfo::Disk) {\n            setErrorString(QObject::tr(\"\\\"%1\\\" is not a disk device\").arg(filePath()));\n\n            return false;\n        }\n\n        if (currentMode == DDiskInfo::Read)\n            process->start(QStringLiteral(\"sfdisk -d %1\").arg(filePath()), QIODevice::ReadOnly);\n        else\n            process->start(QStringLiteral(\"sfdisk %1 --no-reread\").arg(filePath()));\n\n        break;\n    }\n    case DDiskInfo::Partition: {\n        const DPartInfo &part = (index == 0 && currentMode == DDiskInfo::Write) ? DDevicePartInfo(filePath()) : q->getPartByNumber(index);\n\n        if (!part) {\n            dCDebug(\"Part is null(index: %d)\", index);\n\n            return false;\n        }\n\n        dCDebug(\"Try open device: %s, mode: %s\", qPrintable(part.filePath()), currentMode == DDiskInfo::Read ? \"Read\" : \"Write\");\n\n        if (Helper::isMounted(part.filePath())) {\n            if (Helper::umountDevice(part.filePath())) {\n                part.d->mountPoint.clear();\n            } else {\n                setErrorString(QObject::tr(\"\\\"%1\\\" is busy\").arg(part.filePath()));\n\n                return false;\n            }\n        }\n\n        if (currentMode == DDiskInfo::Read) {\n            const QString &executer = Helper::getPartcloneExecuter(part);\n            process->start(QStringLiteral(\"%1 -s %2 -o - -c -z %3 -L /tmp/partclone.log\").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);\n        } else {\n            process->start(QStringLiteral(\"partclone.restore -s - -o %2 -z %3 -L /tmp/partclone.log\").arg(part.filePath()).arg(Global::bufferSize));\n        }\n\n        break;\n    }\n    case DDiskInfo::JsonInfo: {\n        process->deleteLater();\n        process = 0;\n        buffer.setData(q->toJson());\n        break;\n    }\n    default:\n        return false;\n    }\n\n    if (process) {\n        if (!process->waitForStarted()) {\n            setErrorString(QObject::tr(\"Failed to start \\\"%1 %2\\\", error: %3\").arg(process->program()).arg(process->arguments().join(\" \")).arg(process->errorString()));\n\n            return false;\n        }\n\n        dCDebug(\"The \\\"%s %s\\\" command start finished\", qPrintable(process->program()), qPrintable(process->arguments().join(\" \")));\n    }\n\n    bool ok = process ? process->isOpen() : buffer.open(QIODevice::ReadOnly);\n\n    if (!ok) {\n        setErrorString(QObject::tr(\"Failed to open process, error: %1\").arg(process ? process->errorString(): buffer.errorString()));\n    }\n\n    return ok;\n}\n\nvoid DDeviceDiskInfoPrivate::closeDataStream()\n{\n    closing = true;\n\n    if (process) {\n        if (process->state() != QProcess::NotRunning) {\n            if (currentMode == DDiskInfo::Read) {\n                process->closeReadChannel(QProcess::StandardOutput);\n                process->terminate();\n            } else {\n                process->closeWriteChannel();\n            }\n\n            while (process->state() != QProcess::NotRunning) {\n                QThread::currentThread()->sleep(1);\n\n                if (!QFile::exists(QString(\"/proc/%2\").arg(process->pid()))) {\n                    process->waitForFinished(-1);\n\n                    if (process->error() == QProcess::Timedout)\n                        process->QIODevice::d_func()->errorString.clear();\n\n                    break;\n                }\n            }\n        }\n\n        dCDebug(\"Process exit code: %d(%s %s)\", process->exitCode(), qPrintable(process->program()), qPrintable(process->arguments().join(' ')));\n    }\n\n    if (currentMode == DDiskInfo::Write && currentScope == DDiskInfo::PartitionTable) {\n        Helper::umountDevice(filePath());\n\n        if (Helper::refreshSystemPartList(filePath())) {\n            refresh();\n        } else {\n            dCWarning(\"Refresh the devcie %s failed\", qPrintable(filePath()));\n        }\n    }\n\n    if (currentScope == DDiskInfo::JsonInfo)\n        buffer.close();\n\n    closing = false;\n}\n\nqint64 DDeviceDiskInfoPrivate::readableDataSize(DDiskInfo::DataScope scope) const\n{\n    Q_UNUSED(scope)\n\n    return -1;\n}\n\nqint64 DDeviceDiskInfoPrivate::totalReadableDataSize() const\n{\n    qint64 size = 0;\n\n    if (hasScope(DDiskInfo::PartitionTable, DDiskInfo::Read)) {\n        if (hasScope(DDiskInfo::Headgear, DDiskInfo::Read)) {\n            size += 1048576;\n        } else if (!children.isEmpty()) {\n            size += children.first().sizeStart();\n        }\n\n        if (ptType == DDiskInfo::MBR) {\n            size += 512;\n        } else if (ptType == DDiskInfo::GPT) {\n            size += 17408;\n            size += 16896;\n        }\n    }\n\n    for (const DPartInfo &part : children) {\n        if (!part.isExtended())\n            size += part.usedSize();\n    }\n\n    return size;\n}\n\nqint64 DDeviceDiskInfoPrivate::maxReadableDataSize() const\n{\n    if (children.isEmpty()) {\n        return totalReadableDataSize();\n    }\n\n    if (type == DDiskInfo::Disk)\n        return children.last().sizeEnd() + 1;\n\n    return children.first().totalSize();\n}\n\nqint64 DDeviceDiskInfoPrivate::totalWritableDataSize() const\n{\n    return size;\n}\n\nqint64 DDeviceDiskInfoPrivate::read(char *data, qint64 maxSize)\n{\n    if (!process) {\n        return buffer.read(data, maxSize);\n    }\n\n    process->waitForReadyRead(-1);\n\n    if (process->bytesAvailable() > Global::bufferSize) {\n        dCWarning(\"The \\\"%s %s\\\" process bytes available: %s\", qPrintable(process->program()), qPrintable(process->arguments().join(\" \")), qPrintable(Helper::sizeDisplay(process->bytesAvailable())));\n    }\n\n    return process->read(data, maxSize);\n}\n\nqint64 DDeviceDiskInfoPrivate::write(const char *data, qint64 maxSize)\n{\n    if (!process)\n        return -1;\n\n    if (process->state() != QProcess::Running)\n        return -1;\n\n    qint64 size = process->write(data, maxSize);\n\n    QElapsedTimer timer;\n\n    timer.start();\n\n    int timeout = 5000;\n\n    while (process->state() == QProcess::Running && process->bytesToWrite() > 0) {\n        process->waitForBytesWritten();\n\n        if (timer.elapsed() > timeout) {\n            timeout += 5000;\n\n            dCWarning(\"Wait for bytes written timeout, elapsed: %lld, bytes to write: %lld\", timer.elapsed(), process->bytesToWrite());\n        }\n    }\n\n    return size;\n}\n\nbool DDeviceDiskInfoPrivate::atEnd() const\n{\n    if (!process) {\n        return buffer.atEnd();\n    }\n\n    process->waitForReadyRead(-1);\n\n    return process->atEnd();\n}\n\nQString DDeviceDiskInfoPrivate::errorString() const\n{\n    if (error.isEmpty()) {\n        if (process) {\n            if (process->error() == QProcess::UnknownError)\n                return QString();\n\n            return QString(\"%1 %2: %3\").arg(process->program()).arg(process->arguments().join(' ')).arg(process->errorString());\n        }\n\n        if (!buffer.QIODevice::d_func()->errorString.isEmpty())\n            return buffer.errorString();\n    }\n\n    return error;\n}\n\nbool DDeviceDiskInfoPrivate::isClosing() const\n{\n    return closing;\n}\n\nDDeviceDiskInfo::DDeviceDiskInfo()\n{\n\n}\n\nDDeviceDiskInfo::DDeviceDiskInfo(const QString &filePath)\n{\n    const QJsonArray &block_devices = Helper::getBlockDevices(filePath);\n\n    if (!block_devices.isEmpty()) {\n        const QJsonObject &obj = block_devices.first().toObject();\n\n        d = new DDeviceDiskInfoPrivate(this);\n        d_func()->init(obj);\n\n        if (d->type == Part) {\n            const QJsonArray &parent = Helper::getBlockDevices(obj.value(\"pkname\").toString());\n\n            if (!parent.isEmpty()) {\n                const QJsonObject &parent_obj = parent.first().toObject();\n\n                d->transport = parent_obj.value(\"tran\").toString();\n                d->model = parent_obj.value(\"model\").toString();\n                d->serial = parent_obj.value(\"serial\").toString();\n            }\n\n            if (!d->children.isEmpty())\n                d->children.first().d->transport = d->transport;\n        }\n    }\n}\n\nQList<DDeviceDiskInfo> DDeviceDiskInfo::localeDiskList()\n{\n    const QJsonArray &block_devices = Helper::getBlockDevices();\n\n    QList<DDeviceDiskInfo> list;\n\n    for (const QJsonValue &value : block_devices) {\n        const QJsonObject &obj = value.toObject();\n\n        if (Global::disableLoopDevice && obj.value(\"type\").toString() == \"loop\")\n            continue;\n\n        DDeviceDiskInfo info;\n\n        info.d = new DDeviceDiskInfoPrivate(&info);\n        info.d_func()->init(obj);\n        list << info;\n    }\n\n    return list;\n}\n", "/*\n * Copyright (C) 2017 ~ 2017 Deepin Technology Co., Ltd.\n *\n * Author:     zccrs <zccrs@live.com>\n *\n * Maintainer: zccrs <zhangjide@deepin.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"helper.h\"\n#include \"dpartinfo.h\"\n#include \"dglobal.h\"\n#include \"ddevicepartinfo.h\"\n#include \"ddiskinfo.h\"\n\n#include <QProcess>\n#include <QEventLoop>\n#include <QTimer>\n#include <QJsonDocument>\n#include <QJsonObject>\n#include <QFile>\n#include <QDebug>\n#include <QLoggingCategory>\n#include <QRegularExpression>\n#include <QUuid>\n\n#define COMMAND_LSBLK QStringLiteral(\"/bin/lsblk -J -b -p -o NAME,KNAME,PKNAME,FSTYPE,MOUNTPOINT,LABEL,UUID,SIZE,TYPE,PARTTYPE,PARTLABEL,PARTUUID,MODEL,PHY-SEC,RO,RM,TRAN,SERIAL %1\")\n\nQByteArray Helper::m_processStandardError;\nQByteArray Helper::m_processStandardOutput;\n\nQ_LOGGING_CATEGORY(lcDeepinGhost, \"deepin.ghost\")\nQ_GLOBAL_STATIC(Helper, _g_globalHelper)\n\nHelper *Helper::instance()\n{\n    return _g_globalHelper;\n}\n\nint Helper::processExec(QProcess *process, const QString &command, int timeout, QIODevice::OpenMode mode)\n{\n    m_processStandardOutput.clear();\n    m_processStandardError.clear();\n\n    QEventLoop loop;\n    QTimer timer;\n\n    timer.setSingleShot(true);\n    timer.setInterval(timeout);\n\n    timer.connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);\n    loop.connect(process, static_cast<void(QProcess::*)(int)>(&QProcess::finished), &loop, &QEventLoop::exit);\n\n    // \u9632\u6b62\u5b50\u8fdb\u7a0b\u8f93\u51fa\u4fe1\u606f\u5c06\u7ba1\u9053\u585e\u6ee1\u5bfc\u81f4\u8fdb\u7a0b\u963b\u585e\n    process->connect(process, &QProcess::readyReadStandardError, process, [process] {\n        m_processStandardError.append(process->readAllStandardError());\n    });\n    process->connect(process, &QProcess::readyReadStandardOutput, process, [process] {\n        m_processStandardOutput.append(process->readAllStandardOutput());\n    });\n\n    if (timeout > 0) {\n        timer.start();\n    } else {\n        QTimer::singleShot(10000, process, [process] {\n            dCWarning(\"\\\"%s %s\\\" running for more than 10 seconds, state=%d, pid_file_exist=%d\",\n                      qPrintable(process->program()), qPrintable(process->arguments().join(\" \")),\n                      (int)process->state(), (int)QFile::exists(QString(\"/proc/%1\").arg(process->pid())));\n        });\n    }\n\n    if (Global::debugLevel > 1)\n        dCDebug(\"Exec: \\\"%s\\\", timeout: %d\", qPrintable(command), timeout);\n\n    process->start(command, mode);\n    process->waitForStarted();\n\n    if (process->error() != QProcess::UnknownError) {\n        dCError(process->errorString());\n\n        return -1;\n    }\n\n    if (process->state() == QProcess::Running) {\n        loop.exec();\n    }\n\n    if (process->state() != QProcess::NotRunning) {\n        dCDebug(\"The \\\"%s\\\" timeout, timeout: %d\", qPrintable(command), timeout);\n\n        if (QFile::exists(QString(\"/proc/%1\").arg(process->pid()))) {\n            process->terminate();\n            process->waitForFinished();\n        } else {\n            dCDebug(\"The \\\"%s\\\" is quit, but the QProcess object state is not NotRunning\");\n        }\n    }\n\n    m_processStandardOutput.append(process->readAllStandardOutput());\n    m_processStandardError.append(process->readAllStandardError());\n\n    if (Global::debugLevel > 1) {\n        dCDebug(\"Done: \\\"%s\\\", exit code: %d\", qPrintable(command), process->exitCode());\n\n        if (process->exitCode() != 0) {\n            dCError(\"error: \\\"%s\\\"\\nstdout: \\\"%s\\\"\", qPrintable(m_processStandardError), qPrintable(m_processStandardOutput));\n        }\n    }\n\n    return process->exitCode();\n}\n\nint Helper::processExec(const QString &command, int timeout)\n{\n    QProcess process;\n\n    return processExec(&process, command, timeout);\n}\n\nQByteArray Helper::lastProcessStandardOutput()\n{\n    return m_processStandardOutput;\n}\n\nQByteArray Helper::lastProcessStandardError()\n{\n    return m_processStandardError;\n}\n\nconst QLoggingCategory &Helper::loggerCategory()\n{\n    return lcDeepinGhost();\n}\n\nvoid Helper::warning(const QString &message)\n{\n    m_warningString = message;\n\n    emit newWarning(message);\n}\n\nvoid Helper::error(const QString &message)\n{\n    m_errorString = message;\n\n    emit newError(message);\n}\n\nQString Helper::lastWarningString()\n{\n    return m_warningString;\n}\n\nQString Helper::lastErrorString()\n{\n    return m_errorString;\n}\n\nQString Helper::sizeDisplay(qint64 size)\n{\n    constexpr qreal kb = 1024;\n    constexpr qreal mb = kb * 1024;\n    constexpr qreal gb = mb * 1024;\n    constexpr qreal tb = gb * 1024;\n\n    if (size > tb)\n        return QString::asprintf(\"%.2f TB\", size / tb);\n\n    if (size > gb)\n        return QString::asprintf(\"%.2f GB\", size / gb);\n\n    if (size > mb)\n        return QString::asprintf(\"%.2f MB\", size / mb);\n\n    if (size > kb)\n        return QString::asprintf(\"%.2f KB\", size / kb);\n\n    return QString(\"%1 B\").arg(size);\n}\n\nQString Helper::secondsToString(qint64 seconds)\n{\n    int days = seconds / 86400;\n\n    seconds = seconds % 86400;\n\n    int hours = seconds / 3600;\n\n    seconds = seconds % 3600;\n\n    int minutes = seconds / 60;\n\n    seconds = seconds % 60;\n\n    if (days > 0)\n        return QObject::tr(\"%1 d %2 h %3 m\").arg(days).arg(hours).arg(minutes + 1);\n\n    if (hours > 0)\n        return QObject::tr(\"%1 h %2 m\").arg(hours).arg(minutes + 1);\n\n    if (minutes > 0)\n        return QObject::tr(\"%1 m\").arg(minutes + 1);\n\n    return QObject::tr(\"%1 s\").arg(seconds);\n}\n\nbool Helper::refreshSystemPartList(const QString &device)\n{\n    int code = device.isEmpty() ? processExec(\"partprobe\") : processExec(QString(\"partprobe %1\").arg(device));\n\n    if (code != 0)\n        return false;\n\n    QThread::sleep(1);\n\n    return true;\n}\n\nQString Helper::getPartcloneExecuter(const DPartInfo &info)\n{\n    QString executor;\n\n    switch (info.fileSystemType()) {\n    case DPartInfo::Invalid:\n        break;\n    case DPartInfo::Btrfs:\n        executor = \"btrfs\";\n        break;\n    case DPartInfo::EXT2:\n    case DPartInfo::EXT3:\n    case DPartInfo::EXT4:\n        executor = \"extfs\";\n        break;\n    case DPartInfo::F2FS:\n        executor = \"f2fs\";\n        break;\n    case DPartInfo::FAT12:\n    case DPartInfo::FAT16:\n    case DPartInfo::FAT32:\n        executor = \"fat\";\n        break;\n    case DPartInfo::HFS_Plus:\n        executor = \"hfsplus\";\n        break;\n    case DPartInfo::Minix:\n        executor = \"minix\";\n        break;\n    case DPartInfo::Nilfs2:\n        executor = \"nilfs2\";\n        break;\n    case DPartInfo::NTFS:\n        executor = \"ntfs -I\";\n        break;\n    case DPartInfo::Reiser4:\n        executor = \"reiser4\";\n        break;\n    case DPartInfo::VFAT:\n        executor = \"vfat\";\n        break;\n    case DPartInfo::XFS:\n        executor = \"xfs\";\n        break;\n    default:\n        if (!QStandardPaths::findExecutable(\"partclone.\" + info.fileSystemTypeName().toLower()).isEmpty())\n            executor = info.fileSystemTypeName().toLower();\n        break;\n    }\n\n    if (executor.isEmpty())\n        return \"partclone.imager\";\n\n    return \"partclone.\" + executor;\n}\n\nbool Helper::getPartitionSizeInfo(const QString &partDevice, qint64 *used, qint64 *free, int *blockSize)\n{\n    QProcess process;\n    QStringList env_list = QProcess::systemEnvironment();\n\n    env_list.append(\"LANG=C\");\n    process.setEnvironment(env_list);\n\n    if (Helper::isMounted(partDevice)) {\n        process.start(QString(\"df -B1 -P %1\").arg(partDevice));\n        process.waitForFinished();\n\n        if (process.exitCode() != 0) {\n            dCError(\"Call df failed: %s\", qPrintable(process.readAllStandardError()));\n\n            return false;\n        }\n\n        QByteArray output = process.readAll();\n        const QByteArrayList &lines = output.trimmed().split('\\n');\n\n        if (lines.count() != 2)\n            return false;\n\n        output = lines.last().simplified();\n\n        const QByteArrayList &values = output.split(' ');\n\n        if (values.count() != 6)\n            return false;\n\n        bool ok = false;\n\n        if (used)\n            *used = values.at(2).toLongLong(&ok);\n\n        if (!ok)\n            return false;\n\n        if (free)\n            *free = values.at(3).toLongLong(&ok);\n\n        if (!ok)\n            return false;\n\n        return true;\n    } else {\n        process.start(QString(\"%1 -s %2 -c -q -C -L /tmp/partclone.log\").arg(getPartcloneExecuter(DDevicePartInfo(partDevice))).arg(partDevice));\n        process.setStandardOutputFile(\"/dev/null\");\n        process.setReadChannel(QProcess::StandardError);\n        process.waitForStarted();\n\n        qint64 used_block = -1;\n        qint64 free_block = -1;\n\n        while (process.waitForReadyRead(5000)) {\n            const QByteArray &data = process.readAll();\n\n            for (QByteArray line : data.split('\\n')) {\n                line = line.simplified();\n\n                if (QString::fromLatin1(line).contains(QRegularExpression(\"\\\\berror\\\\b\"))) {\n                    dCError(\"Call \\\"%s %s\\\" failed: \\\"%s\\\"\", qPrintable(process.program()), qPrintable(process.arguments().join(' ')), line.constData());\n                }\n\n                if (line.startsWith(\"Space in use:\")) {\n                    bool ok = false;\n                    const QByteArray &value = line.split(' ').value(6, \"-1\");\n\n                    used_block = value.toLongLong(&ok);\n\n                    if (!ok) {\n                        dCError(\"String to LongLong failed, String: %s\", value.constData());\n\n                        return false;\n                    }\n                } else if (line.startsWith(\"Free Space:\")) {\n                    bool ok = false;\n                    const QByteArray &value = line.split(' ').value(5, \"-1\");\n\n                    free_block = value.toLongLong(&ok);\n\n                    if (!ok) {\n                        dCError(\"String to LongLong failed, String: %s\", value.constData());\n\n                        return false;\n                    }\n                } else if (line.startsWith(\"Block size:\")) {\n                    bool ok = false;\n                    const QByteArray &value = line.split(' ').value(2, \"-1\");\n\n                    int block_size = value.toInt(&ok);\n\n                    if (!ok) {\n                        dCError(\"String to Int failed, String: %s\", value.constData());\n\n                        return false;\n                    }\n\n                    if (used_block < 0 || free_block < 0 || block_size < 0)\n                        return false;\n\n                    if (used)\n                        *used = used_block * block_size;\n\n                    if (free)\n                        *free = free_block * block_size;\n\n                    if (blockSize)\n                        *blockSize = block_size;\n\n                    process.terminate();\n                    process.waitForFinished();\n\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nQByteArray Helper::callLsblk(const QString &extraArg)\n{\n    processExec(COMMAND_LSBLK.arg(extraArg));\n\n    return lastProcessStandardOutput();\n}\n\nQJsonArray Helper::getBlockDevices(const QString &commandExtraArg)\n{\n    const QByteArray &array = Helper::callLsblk(commandExtraArg);\n\n    QJsonParseError error;\n\n    const QJsonDocument &jd = QJsonDocument::fromJson(QString::fromUtf8(array).toUtf8(), &error);\n\n    if (error.error != QJsonParseError::NoError) {\n        dCError(error.errorString());\n    }\n\n    return jd.object().value(\"blockdevices\").toArray();\n}\n\nQString Helper::mountPoint(const QString &device)\n{\n    const QJsonArray &array = getBlockDevices(device);\n\n    if (array.isEmpty())\n        return QString();\n\n    return array.first().toObject().value(\"mountpoint\").toString();\n}\n\nbool Helper::isMounted(const QString &device)\n{\n    const QJsonArray &array = getBlockDevices(\"-l \" + device);\n\n    for (const QJsonValue &part : array) {\n        const QJsonObject &obj = part.toObject();\n\n        if (!obj.value(\"mountpoint\").isNull())\n            return true;\n    }\n\n    return false;\n}\n\nbool Helper::umountDevice(const QString &device)\n{\n    const QJsonArray &array = getBlockDevices(\"-l \" + device);\n\n    for (const QJsonValue &device : array) {\n        const QJsonObject &obj = device.toObject();\n\n        if (!obj.value(\"mountpoint\").isNull()) {\n            if (processExec(QString(\"umount -d %1\").arg(obj.value(\"name\").toString())) != 0)\n                return false;\n        }\n    }\n\n    return true;\n}\n\nbool Helper::tryUmountDevice(const QString &device)\n{\n    const QJsonArray &array = getBlockDevices(\"-l \" + device);\n\n    for (const QJsonValue &device : array) {\n        const QJsonObject &obj = device.toObject();\n\n        if (!obj.value(\"mountpoint\").isNull()) {\n            if (processExec(QString(\"umount -d %1 --fake\").arg(obj.value(\"name\").toString())) != 0)\n                return false;\n        }\n    }\n\n    return true;\n}\n\nbool Helper::mountDevice(const QString &device, const QString &path, bool readonly)\n{\n    if (readonly)\n        return processExec(QString(\"mount -r %1 %2\").arg(device, path)) == 0;\n\n    return processExec(QString(\"mount %1 %2\").arg(device, path)) == 0;\n}\n\nQString Helper::temporaryMountDevice(const QString &device, const QString &name, bool readonly)\n{\n    QString mount_point = mountPoint(device);\n\n    if (!mount_point.isEmpty())\n        return mount_point;\n\n    mount_point = \"%1/.%2/mount/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n\n        return QString();\n    }\n\n    if (!mountDevice(device, mount_point, readonly)) {\n        dCError(\"Mount the device \\\"%s\\\" to \\\"%s\\\" failed\", qPrintable(device), qPrintable(mount_point));\n\n        return QString();\n    }\n\n    return mount_point;\n}\n\nQString Helper::findDiskBySerialIndexNumber(const QString &serialNumber, int partIndexNumber)\n{\n    const QJsonArray &array = getBlockDevices();\n\n    for (const QJsonValue &disk : array) {\n        const QJsonObject &obj = disk.toObject();\n\n        if (obj.value(\"serial\").toString().compare(serialNumber, Qt::CaseInsensitive) != 0) {\n            continue;\n        }\n\n        if (partIndexNumber <= 0)\n            return obj.value(\"name\").toString();\n\n        const QJsonArray &children = obj.value(\"children\").toArray();\n\n        for (const QJsonValue &v : children) {\n            const QJsonObject &obj = v.toObject();\n            const QString &name = obj.value(\"name\").toString();\n\n            if (DDevicePartInfo(name).indexNumber() == partIndexNumber)\n                return name;\n        }\n    }\n\n    return QString();\n}\n\nint Helper::partitionIndexNumber(const QString &partDevice)\n{\n    const QJsonArray &array = getBlockDevices(partDevice);\n\n    if (array.isEmpty())\n        return -1;\n\n    const QJsonArray &p_array = getBlockDevices(array.first().toObject().value(\"pkname\").toString() + \" -x NAME\");\n\n    if (p_array.isEmpty())\n        return -1;\n\n    const QJsonArray &part_list = p_array.first().toObject().value(\"children\").toArray();\n\n    for (int i = 0; i < part_list.count(); ++i) {\n        const QJsonObject &obj = part_list.at(i).toObject();\n\n        if (obj.value(\"name\").toString() == partDevice || obj.value(\"kname\").toString() == partDevice)\n            return i;\n    }\n\n    return -1;\n}\n\nQByteArray Helper::getPartitionTable(const QString &devicePath)\n{\n    processExec(QStringLiteral(\"/sbin/sfdisk -d %1\").arg(devicePath));\n\n    return lastProcessStandardOutput();\n}\n\nbool Helper::setPartitionTable(const QString &devicePath, const QString &ptFile)\n{\n    QProcess process;\n\n    process.setStandardInputFile(ptFile);\n\n    if (processExec(&process, QStringLiteral(\"/sbin/sfdisk %1\").arg(devicePath)) != 0)\n        return false;\n\n    int code = processExec(QStringLiteral(\"/sbin/partprobe %1\").arg(devicePath));\n    processExec(\"sleep 1\");\n\n    return code == 0;\n}\n\nbool Helper::saveToFile(const QString &fileName, const QByteArray &data, bool override)\n{\n    if (!override && QFile::exists(fileName))\n        return false;\n\n    QFile file(fileName);\n\n    if (!file.open(QIODevice::WriteOnly)) {\n        dCError(file.errorString());\n\n        return false;\n    }\n\n    qint64 size = file.write(data);\n    file.flush();\n    file.close();\n\n    return size == data.size();\n}\n\nbool Helper::isBlockSpecialFile(const QString &fileName)\n{\n    if (fileName.startsWith(\"/dev/\"))\n        return true;\n\n    processExec(QStringLiteral(\"env LANG=C stat -c %F %1\").arg(fileName));\n\n    return lastProcessStandardOutput() == \"block special file\\n\";\n}\n\nbool Helper::isPartcloneFile(const QString &fileName)\n{\n    return processExec(QStringLiteral(\"partclone.info %1\").arg(fileName)) == 0;\n}\n\nbool Helper::isDiskDevice(const QString &devicePath)\n{\n    const QJsonArray &blocks = getBlockDevices(devicePath);\n\n    if (blocks.isEmpty())\n        return false;\n\n    if (!blocks.first().isObject())\n        return false;\n\n    return blocks.first().toObject().value(\"pkname\").isNull();\n}\n\nbool Helper::isPartitionDevice(const QString &devicePath)\n{\n    const QJsonArray &blocks = getBlockDevices(devicePath);\n\n    if (blocks.isEmpty())\n        return false;\n\n    if (!blocks.first().isObject())\n        return false;\n\n    return !blocks.first().toObject().value(\"pkname\").isString();\n}\n\nQString Helper::parentDevice(const QString &device)\n{\n    const QJsonArray &blocks = getBlockDevices(device);\n\n    if (blocks.isEmpty())\n        return device;\n\n    const QString &parent = blocks.first().toObject().value(\"pkname\").toString();\n\n    if (parent.isEmpty())\n        return device;\n\n    return parent;\n}\n\nbool Helper::deviceHaveKinship(const QString &device1, const QString &device2)\n{\n    return device1 == device2 || parentDevice(device1) == parentDevice(device2);\n}\n\nint Helper::clonePartition(const DPartInfo &part, const QString &to, bool override)\n{\n    QString executor = getPartcloneExecuter(part);\n    QString command;\n\n    if (executor.isEmpty() || executor == \"partclone.imager\") {\n        if (part.guidType() == DPartInfo::InvalidGUID)\n            return -1;\n\n        command = QStringLiteral(\"dd if=%1 of=%2 status=none conv=fsync\").arg(part.filePath()).arg(to);\n    } else if (isBlockSpecialFile(to)) {\n        command = QStringLiteral(\"/usr/sbin/%1 -b -c -s %2 -%3 %4\").arg(executor).arg(part.filePath()).arg(override ? \"O\" : \"o\").arg(to);\n    } else {\n        command = QStringLiteral(\"/usr/sbin/%1 -c -s %2 -%3 %4\").arg(executor).arg(part.filePath()).arg(override ? \"O\" : \"o\").arg(to);\n    }\n\n    int code = processExec(command);\n\n    if (code != 0)\n        qDebug() << command << QString::fromUtf8(lastProcessStandardOutput());\n\n    return code;\n}\n\nint Helper::restorePartition(const QString &from, const DPartInfo &to)\n{\n    QString command;\n\n    if (isPartcloneFile(from)) {\n        command = QStringLiteral(\"/usr/sbin/partclone.restore -s %1 -o %2\").arg(from).arg(to.filePath());\n    } else {\n        command = QStringLiteral(\"dd if=%1 of=%2 status=none conv=fsync\").arg(from).arg(to.filePath());\n    }\n\n    int code = processExec(command);\n\n    if (code != 0)\n        qDebug() << command << QString::fromUtf8(lastProcessStandardOutput());\n\n    return code;\n}\n\nbool Helper::existLiveSystem()\n{\n    return QFile::exists(\"/recovery\");\n}\n\nbool Helper::restartToLiveSystem(const QStringList &arguments)\n{\n    if (!existLiveSystem()) {\n        dCDebug(\"Not install live system\");\n\n        return false;\n    }\n\n    if (!QDir::current().mkpath(\"/recovery/.tmp\")) {\n        dCDebug(\"mkpath failed\");\n\n        return false;\n    }\n\n    QFile file(\"/recovery/.tmp/deepin-clone.arguments\");\n\n    if (!file.open(QIODevice::WriteOnly)) {\n        dCDebug(\"Open file failed: \\\"%s\\\"\", qPrintable(file.fileName()));\n\n        return false;\n    }\n\n    file.write(arguments.join('\\n').toUtf8());\n    file.close();\n\n    if (processExec(\"grub-reboot \\\"Deepin Recovery\\\"\") != 0) {\n        dCDebug(\"Exec grub-reboot \\\"Deepin Recovery\\\" failed\");\n\n        file.remove();\n\n        return false;\n    }\n\n    if (processExec(\"reboot\") != 0)\n        file.remove();\n\n    return true;\n}\n\nbool Helper::isDeepinSystem(const DPartInfo &part)\n{\n    QString mout_root = part.mountPoint();\n    bool umount_device = false;\n\n    if (mout_root.isEmpty()) {\n        mout_root = temporaryMountDevice(part.name(), QFileInfo(part.name()).fileName(), true);\n\n        if (mout_root.isEmpty())\n            return false;\n\n        umount_device = true;\n    }\n\n    bool is = QFile::exists(mout_root + \"/etc/deepin-version\");\n\n    if (umount_device)\n        umountDevice(part.name());\n\n    return is;\n}\n\nbool Helper::resetPartUUID(const DPartInfo &part, QByteArray uuid)\n{\n    QString command;\n\n    if (uuid.isEmpty()) {\n        uuid = QUuid::createUuid().toByteArray().mid(1, 36);\n    }\n\n    switch (part.fileSystemType()) {\n    case DPartInfo::EXT2:\n    case DPartInfo::EXT3:\n    case DPartInfo::EXT4:\n        command = QString(\"tune2fs -U %1 %2\").arg(QString::fromLatin1(uuid)).arg(part.filePath());\n        break;\n    case DPartInfo::JFS:\n        command = QString(\"jfs_tune -U %1 %2\").arg(QString::fromLatin1(uuid)).arg(part.filePath());\n        break;\n    case DPartInfo::NTFS:\n        command = QString(\"ntfslabel --new-half-serial %1\").arg(part.filePath());\n        break;\n    case DPartInfo::XFS:\n        command = QString(\"xfs_admin -U %1 %2\").arg(QString::fromLatin1(uuid)).arg(part.filePath());\n        break;\n    default:\n        dCDebug(\"Not support the file system type: %s\", qPrintable(part.fileSystemTypeName()));\n\n        return false;\n    }\n\n    if (!umountDevice(part.filePath())) {\n        dCDebug(\"Failed to umount the partition: %s\", qPrintable(part.filePath()));\n\n        return false;\n    }\n\n    // check the partition\n    processExec(\"fsck -f -y \" + part.filePath());\n\n    bool ok = processExec(command) == 0;\n\n    if (!ok) {\n        dCError(\"Failed reset part uuid\");\n        dCDebug(qPrintable(lastProcessStandardOutput()));\n        dCError(qPrintable(lastProcessStandardError()));\n    }\n\n    return ok;\n}\n\nQString Helper::parseSerialUrl(const QString &urlString, QString *errorString)\n{\n    if (urlString.isEmpty())\n        return QString();\n\n    const QUrl url(urlString);\n    const QString serial_number = urlString.split(\"//\").at(1).split(\":\").first();\n    const int part_index = url.port();\n    const QString &path = url.path();\n    const QString &device = Helper::findDiskBySerialIndexNumber(serial_number, part_index);\n    const QString &device_url = part_index > 0 ? QString(\"serial://%1:%2\").arg(serial_number).arg(part_index) : \"serial://\" + serial_number;\n\n    if (device.isEmpty()) {\n        if (errorString) {\n            if (part_index > 0)\n                *errorString = QObject::tr(\"Partition \\\"%1\\\" not found\").arg(device_url);\n            else\n                *errorString = QObject::tr(\"Disk \\\"%1\\\" not found\").arg(device_url);\n        }\n\n        return device;\n    }\n\n    if (path.isEmpty())\n        return device;\n\n    const QString &mp = Helper::mountPoint(device);\n\n    QDir mount_point(mp);\n\n    if (mp.isEmpty()) {\n        QString mount_name;\n\n        if (part_index >= 0)\n            mount_name = QString(\"%1-%2\").arg(serial_number).arg(part_index);\n        else\n            mount_name = serial_number;\n\n        const QString &_mount_point = Helper::temporaryMountDevice(device, mount_name);\n\n        if (_mount_point.isEmpty()) {\n            if (errorString)\n                *errorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(device_url);\n\n            return QString();\n        }\n\n        mount_point.setPath(_mount_point);\n    }\n\n    if (mount_point.absolutePath() == \"/\")\n        return path;\n\n    return mount_point.absolutePath() + path;\n}\n\nQString Helper::getDeviceForFile(const QString &file, QString *rootPath)\n{\n    if (file.isEmpty())\n        return QString();\n\n    if (Helper::isBlockSpecialFile(file))\n        return file;\n\n    QFileInfo info(file);\n\n    while (!info.exists() && info.absoluteFilePath() != \"/\")\n        info.setFile(info.absolutePath());\n\n    QStorageInfo storage_info(info.absoluteFilePath());\n\n    if (rootPath)\n        *rootPath = storage_info.rootPath();\n\n    return QString::fromUtf8(storage_info.device());\n}\n\nQString Helper::toSerialUrl(const QString &file)\n{\n    if (file.isEmpty())\n        return QString();\n\n    if (Helper::isBlockSpecialFile(file)) {\n        DDiskInfo info;\n\n        if (Helper::isDiskDevice(file))\n            info = DDiskInfo::getInfo(file);\n        else\n            info = DDiskInfo::getInfo(Helper::parentDevice(file));\n\n        if (!info)\n            return QString();\n\n        if (info.serial().isEmpty())\n            return QString();\n\n        int index = DDevicePartInfo(file).indexNumber();\n\n        if (index == 0)\n            return \"serial://\" + info.serial();\n\n        return QString(\"serial://%1:%2\").arg(info.serial()).arg(index);\n    }\n\n    QString root_path;\n    QString url = toSerialUrl(getDeviceForFile(file, &root_path));\n\n    if (root_path == \"/\")\n        return url + QFileInfo(file).absoluteFilePath();\n\n    return url + QFileInfo(file).absoluteFilePath().mid(root_path.length());\n}\n", "/*\n * Copyright (C) 2017 ~ 2017 Deepin Technology Co., Ltd.\n *\n * Author:     zccrs <zccrs@live.com>\n *\n * Maintainer: zccrs <zhangjide@deepin.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef HELPER_H\n#define HELPER_H\n\n#include <QByteArray>\n#include <QJsonArray>\n#include <QObject>\n#include <QLoggingCategory>\n#include <QtConcurrent/QtConcurrent>\n#include <QFutureWatcher>\n\n#include <typeinfo>\n\nQT_BEGIN_NAMESPACE\nclass QProcess;\nQT_END_NAMESPACE\n\nclass DPartInfo;\nclass Helper : public QObject\n{\n    Q_OBJECT\n\npublic:\n    static Helper *instance();\n\n    static int processExec(QProcess *process, const QString &command,\n                           int timeout = -1, QIODevice::OpenMode mode = QIODevice::ReadOnly);\n    static int processExec(const QString &command, int timeout = -1);\n    static QByteArray lastProcessStandardOutput();\n    static QByteArray lastProcessStandardError();\n\n    static const QLoggingCategory &loggerCategory();\n\n    void warning(const QString &message);\n    void error(const QString &message);\n    QString lastWarningString();\n    QString lastErrorString();\n\n    static QString sizeDisplay(qint64 size);\n    static QString secondsToString(qint64 seconds);\n\n    static bool refreshSystemPartList(const QString &device = QString());\n    static QString getPartcloneExecuter(const DPartInfo &info);\n    static bool getPartitionSizeInfo(const QString &partDevice, qint64 *used, qint64 *free, int *blockSize);\n\n    static QByteArray callLsblk(const QString &extraArg = QString());\n    static QJsonArray getBlockDevices(const QString &commandExtraArg = QString());\n\n    static QString mountPoint(const QString &device);\n    static bool isMounted(const QString &device);\n    static bool umountDevice(const QString &device);\n    static bool tryUmountDevice(const QString &device);\n    static bool mountDevice(const QString &device, const QString &path, bool readonly = false);\n    static QString temporaryMountDevice(const QString &device, const QString &name, bool readonly = false);\n\n    static QString findDiskBySerialIndexNumber(const QString &serialNumber, int partIndexNumber = -1);\n    static int partitionIndexNumber(const QString &partDevice);\n\n    static QByteArray getPartitionTable(const QString &devicePath);\n    static bool setPartitionTable(const QString &devicePath, const QString &ptFile);\n    static bool saveToFile(const QString &fileName, const QByteArray &data, bool override = true);\n    static bool isBlockSpecialFile(const QString &fileName);\n    static bool isPartcloneFile(const QString &fileName);\n    static bool isDiskDevice(const QString &devicePath);\n    static bool isPartitionDevice(const QString &devicePath);\n    static QString parentDevice(const QString &device);\n    static bool deviceHaveKinship(const QString &device1, const QString &device2);\n\n    static int clonePartition(const DPartInfo &part, const QString &to, bool override = true);\n    static int restorePartition(const QString &from, const DPartInfo &to);\n\n    static bool existLiveSystem();\n    static bool restartToLiveSystem(const QStringList &arguments);\n\n    static bool isDeepinSystem(const DPartInfo &part);\n    static bool resetPartUUID(const DPartInfo &part, QByteArray uuid = QByteArray());\n\n    static QString getDeviceForFile(const QString &file, QString *rootPath = 0);\n    static QString parseSerialUrl(const QString &urlString, QString *errorString = 0);\n    static QString toSerialUrl(const QString &file);\n\nsignals:\n    void newWarning(const QString &message);\n    void newError(const QString &message);\n\nprivate:\n    static QByteArray m_processStandardOutput;\n    static QByteArray m_processStandardError;\n\n    QString m_warningString;\n    QString m_errorString;\n};\n\ntemplate<typename... Args>\nstatic\ntypename QtPrivate::QEnableIf<int(sizeof...(Args)) >= 1, QString>::Type\n__d_asprintf__(const char *format, Args&&... args)\n{\n    return QString::asprintf(format, std::forward<Args>(args)...);\n}\ntemplate<typename... Args>\nstatic\ntypename QtPrivate::QEnableIf<int(sizeof...(Args)) == 0, QString>::Type\n__d_asprintf__(const char *message, Args&&...)\n{\n    return QString::asprintf(\"%s\", message);\n}\ntemplate<typename... Args>\nstatic QString __d_asprintf__(const QString &string, Args&&... args)\n{\n    return __d_asprintf__(string.toUtf8().constData(), std::forward<Args>(args)...);\n}\ntemplate<typename... Args>\nstatic QString __d_asprintf__(const QByteArray &array, Args&&... args)\n{\n    return __d_asprintf__(array.constData(), std::forward<Args>(args)...);\n}\n\n#ifdef dCDebug\n#undef dCDebug\n#endif\n#define dCDebug(...) qCDebug(Helper::loggerCategory, __VA_ARGS__)\n\n#ifdef dCInfo\n#undef dCInfo\n#endif\n#define dCInfo(format, ...) { \\\n    QString __m = __d_asprintf__(format, ##__VA_ARGS__); \\\n    __m.prepend(\"\\033[33m\"); __m.append(\"\\033[0m\"); \\\n    qCInfo(Helper::loggerCategory, qPrintable(__m));}\n\n#ifdef dCWarning\n#undef dCWarning\n#endif\n#define dCWarning(format, ...) { \\\n    QString __m = __d_asprintf__(format, ##__VA_ARGS__); \\\n    __m.prepend(\"\\033[30;41m\"); __m.append(\"\\033[0m\"); \\\n    Helper::instance()->warning(__m); \\\n    qCWarning(Helper::loggerCategory, qPrintable(__m));}\n\n#ifdef dCError\n#undef dCError\n#endif\n#define dCError(format, ...) { \\\n    QString __m = __d_asprintf__(format, ##__VA_ARGS__); \\\n    __m.prepend(\"\\033[30;45m\"); __m.append(\"\\033[0m\"); \\\n    Helper::instance()->warning(__m); \\\n    qCCritical(Helper::loggerCategory, qPrintable(__m));}\n\nnamespace ThreadUtil {\ntemplate <typename ReturnType>\nclass _TMP\n{\npublic:\n    template <typename Fun, typename... Args>\n    static ReturnType runInNewThread(Fun fun, Args&&... args)\n    {\n        QFutureWatcher<ReturnType> watcher;\n        QEventLoop loop;\n\n        QObject::connect(&watcher, &QFutureWatcherBase::finished, &loop, &QEventLoop::quit);\n        watcher.setFuture(QtConcurrent::run(fun, std::forward<Args>(args)...));\n\n        loop.exec();\n\n        return watcher.result();\n    }\n};\n\ntemplate <typename Fun, typename... Args>\nauto runInNewThread(Fun fun, Args&&... args) -> decltype(fun(args...))\n{\n    return _TMP<decltype(fun(args...))>::runInNewThread(fun, std::forward<Args>(args)...);\n}\ntemplate <typename Fun, typename... Args>\ntypename QtPrivate::FunctionPointer<Fun>::ReturnType runInNewThread(typename QtPrivate::FunctionPointer<Fun>::Object *obj, Fun fun, Args&&... args)\n{\n    return _TMP<typename QtPrivate::FunctionPointer<Fun>::ReturnType>::runInNewThread([&] {\n        return (obj->*fun)(std::forward<Args>(args)...);\n    });\n}\n\n}\n\n#endif // HELPER_H\n", "/*\n * Copyright (C) 2017 ~ 2017 Deepin Technology Co., Ltd.\n *\n * Author:     zccrs <zccrs@live.com>\n *\n * Maintainer: zccrs <zhangjide@deepin.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include \"bootdoctor.h\"\n#include \"helper.h\"\n#include \"ddevicediskinfo.h\"\n#include \"ddevicepartinfo.h\"\n\nQString BootDoctor::m_lastErrorString;\n\nbool BootDoctor::fix(const QString &partDevice)\n{\n    m_lastErrorString.clear();\n\n    DDevicePartInfo part_info(partDevice);\n    const QString part_old_uuid = part_info.uuid();\n\n    if (Helper::processExec(\"lsblk -s -d -n -o UUID\") == 0) {\n        if (Helper::lastProcessStandardOutput().contains(part_old_uuid.toLatin1())) {\n            // reset uuid\n            if (Helper::resetPartUUID(part_info)) {\n                QThread::sleep(1);\n                part_info.refresh();\n\n                qDebug() << part_old_uuid << part_info.uuid();\n            } else {\n                dCWarning(\"Failed to reset uuid\");\n            }\n        }\n    }\n\n    bool device_is_mounted = Helper::isMounted(partDevice);\n    const QString &mount_root = Helper::temporaryMountDevice(partDevice, QFileInfo(partDevice).fileName());\n\n    if (mount_root.isEmpty()) {\n        m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(partDevice);\n        goto failed;\n    }\n\n    {\n        const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n        const QString tmp_dir = (tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()) + \"/.deepin-clone\";\n\n        if (!QDir::current().mkpath(tmp_dir)) {\n            dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(tmp_dir));\n            goto failed;\n        }\n\n        const QString &repo_path = tmp_dir + \"/repo.iso\";\n\n        if (!QFile::exists(repo_path)\n                && !QFile::copy(QString(\":/repo_%1.iso\").arg(HOST_ARCH), repo_path)) {\n            dCError(\"copy file failed, new name: %s\", qPrintable(repo_path));\n            goto failed;\n        }\n\n        bool ok = false;\n\n        const QString &repo_mount_point = mount_root + \"/deepin-clone\";\n        QFile file_boot_fix(mount_root + \"/boot_fix.sh\");\n\n        do {\n            if (!QDir(mount_root).exists(\"deepin-clone\") && !QDir(mount_root).mkdir(\"deepin-clone\")) {\n                dCError(\"Create \\\"deepin-clone\\\" dir failed(\\\"%s\\\")\", qPrintable(mount_root));\n                break;\n            }\n\n            if (!Helper::mountDevice(repo_path, repo_mount_point, true)) {\n                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(repo_path);\n                break;\n            }\n\n            if (file_boot_fix.exists()) {\n                file_boot_fix.remove();\n            }\n\n            if (!QFile::copy(QString(\":/scripts/boot_fix_%1.sh\").arg(\n                     #if defined(HOST_ARCH_x86_64) || defined(HOST_ARCH_i386) || defined(HOST_ARCH_i686)\n                                 \"x86\"\n                     #elif defined(HOST_ARCH_mips64) || defined(HOST_ARCH_mips32)\n                                 \"mips\"\n                     #elif defined(HOST_ARCH_sw_64)\n                                 \"sw_64\"\n                     #elif defined(HOST_ARCH_aarch64)\n                                 \"aarch64\"\n                     #else\n                     #pragma message \"Machine: \" HOST_ARCH\n                                \"unknow\"\n                     #endif\n                                 ), file_boot_fix.fileName())) {\n                dCError(\"copy file failed, new name: %s\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (!file_boot_fix.setPermissions(file_boot_fix.permissions() | QFile::ExeUser)) {\n                dCError(\"Set \\\"%s\\\" permissions failed\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev %1/dev\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev/pts %1/dev/pts\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev/pts\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /proc %1/proc\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /proc\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /sys %1/sys\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /sys\");\n                break;\n            }\n\n            ok = true;\n        } while (0);\n\n        QProcess process;\n\n        if (ok) {\n            const QString &parent_device = Helper::parentDevice(partDevice);\n\n            bool is_efi = false;\n\n            if (!parent_device.isEmpty()) {\n                DDeviceDiskInfo info(parent_device);\n\n                dCDebug(\"Disk partition table type: %d\", info.ptType());\n\n                if (info.ptType() == DDeviceDiskInfo::GPT) {\n                    for (const DPartInfo &part : info.childrenPartList()) {\n                        if (part.guidType() == DPartInfo::EFI_SP_None) {\n                            const QString &efi_path = mount_root + \"/boot/efi\";\n\n                            QDir::current().mkpath(efi_path);\n\n                            if (Helper::processExec(QString(\"mount %1 %2\").arg(part.filePath()).arg(efi_path)) != 0) {\n                                dCError(\"Failed to mount EFI partition\");\n                                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(part.filePath());\n                                ok = false;\n                                break;\n                            }\n\n                            is_efi = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!is_efi && m_lastErrorString.isEmpty()) {\n                        m_lastErrorString = QObject::tr(\"EFI partition not found\");\n                        ok = false;\n                    }\n                } else if (info.ptType() == DDeviceDiskInfo::Unknow) {\n                    m_lastErrorString = QObject::tr(\"Unknown partition style\");\n                    ok = false;\n                }\n            }\n\n            if (ok) {\n                process.setProcessChannelMode(QProcess::MergedChannels);\n                process.start(QString(\"chroot %1 ./boot_fix.sh %2 %3 /deepin-clone\")\n                              .arg(mount_root)\n                              .arg(parent_device)\n                              .arg(is_efi ? \"true\" : \"false\"));\n\n                while (process.waitForReadyRead()) {\n                    const QByteArray &data = process.readAll().simplified().constData();\n\n                    dCDebug(data.constData());\n                }\n\n                process.waitForFinished(-1);\n\n                switch (process.exitCode()) {\n                case 1:\n                    m_lastErrorString = QObject::tr(\"Boot for install system failed\");\n                    break;\n                case 2:\n                    m_lastErrorString = QObject::tr(\"Boot for update system failed\");\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n\n        // clear\n        Helper::processExec(\"umount \" + repo_mount_point);\n        QDir(mount_root).rmdir(\"deepin-clone\");\n        file_boot_fix.remove();\n        Helper::processExec(\"umount \" + mount_root + \"/dev/pts\");\n        Helper::processExec(\"umount \" + mount_root + \"/dev\");\n        Helper::processExec(\"umount \" + mount_root + \"/proc\");\n        Helper::processExec(\"umount \" + mount_root + \"/sys\");\n        Helper::processExec(\"umount \" + mount_root + \"/boot/efi\");\n\n        if (ok && process.exitCode() == 0) {\n            if (part_old_uuid != part_info.uuid()) {\n                dCDebug(\"Reset the uuid from \\\"%s\\\" to \\\"%s\\\"\", qPrintable(part_old_uuid), qPrintable(part_info.uuid()));\n\n                // update /etc/fstab\n                QFile file(mount_root + \"/etc/fstab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/fstab, error: %s\", qPrintable(file.errorString()));\n                }\n\n                file.setFileName(mount_root + \"/etc/crypttab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/crypttab, error: %s\", qPrintable(file.errorString()));\n                }\n            }\n\n            if (!device_is_mounted)\n                Helper::umountDevice(partDevice);\n\n            return true;\n        }\n    }\n\nfailed:\n    if (!device_is_mounted)\n        Helper::umountDevice(partDevice);\n\n    if (m_lastErrorString.isEmpty())\n        m_lastErrorString = QObject::tr(\"Boot for repair system failed\");\n\n    dCDebug(\"Restore partition uuid\");\n\n    if (!Helper::resetPartUUID(part_info, part_old_uuid.toLatin1())) {\n        dCWarning(\"Failed to restore partition uuid, part: %s, uuid: %s\", qPrintable(partDevice), qPrintable(part_old_uuid));\n    }\n\n    return false;\n}\n\nQString BootDoctor::errorString()\n{\n    return m_lastErrorString;\n}\n", "/*\n * Copyright (C) 2017 ~ 2017 Deepin Technology Co., Ltd.\n *\n * Author:     zccrs <zccrs@live.com>\n *\n * Maintainer: zccrs <zhangjide@deepin.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <QDebug>\n#include <DLog>\n\n#ifdef ENABLE_GUI\n#include <DApplication>\n#include <DTitlebar>\n#include <DThemeManager>\n\n#include <QDesktopServices>\n\n#include \"mainwindow.h\"\n#include \"dvirtualimagefileio.h\"\n\n#include <pwd.h>\n#include <unistd.h>\n\nDWIDGET_USE_NAMESPACE\n#else\n#include <QCoreApplication>\n#endif\n\n#include \"helper.h\"\n#include \"dglobal.h\"\n#include \"clonejob.h\"\n#include \"commandlineparser.h\"\n\nbool Global::isOverride = true;\nbool Global::disableMD5CheckForDimFile = false;\nbool Global::disableLoopDevice = true;\nbool Global::fixBoot = false;\n#ifdef ENABLE_GUI\nbool Global::isTUIMode = false;\n#else\nbool Global::isTUIMode = true;\n#endif\n\nint Global::bufferSize = 1024 * 1024;\nint Global::compressionLevel = 0;\nint Global::debugLevel = 1;\n\nDCORE_USE_NAMESPACE\n\ninline static bool isTUIMode(int argc, char *argv[])\n{\n#ifndef ENABLE_GUI\n    Q_UNUSED(argc)\n    Q_UNUSED(argv)\n\n    return true;\n#endif\n\n    if (qEnvironmentVariableIsEmpty(\"DISPLAY\"))\n        return true;\n\n    const QByteArrayList in_tui_args = {\n        \"--tui\", \"-i\", \"--info\", \"--dim-info\", \"--to-serial-url\",\n        \"--from-serial-url\", \"-f\", \"--fix-boot\", \"-v\", \"--version\",\n        \"-h\", \"--help\", \"--re-checksum\"\n    };\n\n    for (int i = 1; i < argc; ++i)\n        if (in_tui_args.contains(argv[i]))\n            return true;\n\n    return false;\n}\n\nstatic QString logFormat = \"[%{time}{yyyy-MM-dd, HH:mm:ss.zzz}] [%{type:-7}] [%{file}=>%{function}: %{line}] %{message}\\n\";\n\nint main(int argc, char *argv[])\n{\n    QCoreApplication *a;\n\n    if (isTUIMode(argc, argv)) {\n        Global::isTUIMode = true;\n\n        a = new QCoreApplication(argc, argv);\n    }\n#ifdef ENABLE_GUI\n    else {\n        ConsoleAppender *consoleAppender = new ConsoleAppender;\n        consoleAppender->setFormat(logFormat);\n\n        RollingFileAppender *rollingFileAppender = new RollingFileAppender(\"/tmp/.deepin-clone.log\");\n        rollingFileAppender->setFormat(logFormat);\n        rollingFileAppender->setLogFilesLimit(5);\n        rollingFileAppender->setDatePattern(RollingFileAppender::DailyRollover);\n\n        logger->registerAppender(consoleAppender);\n        logger->registerAppender(rollingFileAppender);\n\n        if (qEnvironmentVariableIsSet(\"PKEXEC_UID\")) {\n            const quint32 pkexec_uid = qgetenv(\"PKEXEC_UID\").toUInt();\n            const QDir user_home(getpwuid(pkexec_uid)->pw_dir);\n\n            QFile pam_file(user_home.absoluteFilePath(\".pam_environment\"));\n\n            if (pam_file.open(QIODevice::ReadOnly)) {\n                while (!pam_file.atEnd()) {\n                    const QByteArray &line = pam_file.readLine().simplified();\n\n                    if (line.startsWith(\"QT_SCALE_FACTOR\")) {\n                        const QByteArrayList &list = line.split('=');\n\n                        if (list.count() == 2) {\n                            qputenv(\"QT_SCALE_FACTOR\", list.last());\n                            break;\n                        }\n                    }\n                }\n\n                pam_file.close();\n            }\n        }\n\n        DApplication::loadDXcbPlugin();\n        DApplication *app = new DApplication(argc, argv);\n\n        app->setAttribute(Qt::AA_UseHighDpiPixmaps);\n\n        if (!qApp->setSingleInstance(\"_deepin_clone_\")) {\n            qCritical() << \"As well as the process is running\";\n\n            return -1;\n        }\n\n        if (!app->loadTranslator()) {\n            dError(\"Load translator failed\");\n        }\n\n        app->setApplicationDisplayName(QObject::tr(\"Deepin Clone\"));\n        app->setApplicationDescription(QObject::tr(\"Deepin Clone is a backup and restore tool in deepin. \"\n                                                   \"It supports disk or partition clone, backup and restore, and other functions.\"));\n        app->setApplicationAcknowledgementPage(\"https://www.deepin.org/acknowledgments/deepin-clone/\");\n        app->setTheme(\"light\");\n        a = app;\n    }\n#endif\n\n    a->setApplicationName(\"deepin-clone\");\n#ifdef ENABLE_GUI\n    a->setApplicationVersion(DApplication::buildVersion(\"1.0.0.1\"));\n#else\n    a->setApplicationVersion(\"1.0.0.1\");\n#endif\n    a->setOrganizationName(\"deepin\");\n\n    CommandLineParser parser;\n\n    QFile arguments_file(\"/lib/live/mount/medium/.tmp/deepin-clone.arguments\");\n    QStringList arguments;\n\n    bool load_arg_from_file = arguments_file.exists() && !Global::isTUIMode && !a->arguments().contains(\"--tui\");\n\n    if (load_arg_from_file) {\n        arguments.append(a->arguments().first());\n\n        if (!arguments_file.open(QIODevice::ReadOnly)) {\n            qCritical() << \"Open \\\"/lib/live/mount/medium/.tmp/deepin-clone.arguments\\\" failed, error:\" << arguments_file.errorString();\n        } else {\n            while (!arguments_file.atEnd()) {\n                const QString &arg = QString::fromUtf8(arguments_file.readLine().trimmed());\n\n                if (!arg.isEmpty())\n                    arguments.append(arg);\n            }\n\n            arguments_file.close();\n            arguments_file.remove();\n        }\n\n        qDebug() << arguments;\n    } else {\n        arguments = a->arguments();\n    }\n\n    parser.process(arguments);\n\n    ConsoleAppender *consoleAppender = new ConsoleAppender;\n    consoleAppender->setFormat(logFormat);\n\n    RollingFileAppender *rollingFileAppender = new RollingFileAppender(parser.logFile());\n    rollingFileAppender->setFormat(logFormat);\n    rollingFileAppender->setLogFilesLimit(5);\n    rollingFileAppender->setDatePattern(RollingFileAppender::DailyRollover);\n\n    logger->registerCategoryAppender(\"deepin.ghost\", consoleAppender);\n    logger->registerCategoryAppender(\"deepin.ghost\", rollingFileAppender);\n\n    parser.parse();\n\n    if (load_arg_from_file) {\n        dCDebug(\"Load arguments from \\\"%s\\\"\", qPrintable(arguments_file.fileName()));\n    }\n\n    dCInfo(\"Application command line: %s\", qPrintable(arguments.join(' ')));\n\n    if (Global::debugLevel == 0) {\n        QLoggingCategory::setFilterRules(\"deepin.ghost.debug=false\");\n    }\n\n    if (Global::isTUIMode) {\n        if (!parser.target().isEmpty()) {\n            CloneJob *job = new CloneJob;\n\n            QObject::connect(job, &QThread::finished, a, &QCoreApplication::quit);\n\n            job->start(parser.source(), parser.target());\n        }\n    }\n#ifdef ENABLE_GUI\n    else {\n        if (!parser.isSetOverride())\n            Global::isOverride = true;\n\n        if (!parser.isSetDebug())\n            Global::debugLevel = 2;\n\n        MainWindow *window = new MainWindow;\n\n        window->setFixedSize(860, 660);\n        window->setStyleSheet(DThemeManager::instance()->getQssForWidget(\"main\", window));\n        window->setWindowIcon(QIcon::fromTheme(\"deepin-clone\"));\n        window->setWindowFlags(Qt::WindowCloseButtonHint | Qt::WindowMinimizeButtonHint | Qt::WindowSystemMenuHint);\n        window->titlebar()->setIcon(window->windowIcon());\n        window->titlebar()->setTitle(QString());\n#if DTK_VERSION > DTK_VERSION_CHECK(2, 0, 6, 0)\n        window->titlebar()->setBackgroundTransparent(true);\n#endif\n        window->show();\n\n        qApp->setProductIcon(window->windowIcon());\n\n        if (!parser.source().isEmpty()) {\n            window->startWithFile(parser.source(), parser.target());\n        }\n\n        QObject::connect(a, &QCoreApplication::aboutToQuit, window, &MainWindow::deleteLater);\n        QDesktopServices::setUrlHandler(\"https\", window, \"openUrl\");\n    }\n#endif\n\n    int exitCode = Global::isTUIMode ? a->exec() : qApp->exec();\n    QString log_backup_file = parser.logBackupFile();\n\n    if (log_backup_file.startsWith(\"serial://\")) {\n        log_backup_file = Helper::parseSerialUrl(log_backup_file);\n    }\n\n    if (log_backup_file.isEmpty()) {\n        return exitCode;\n    }\n\n    if (!QFile::copy(parser.logFile(), log_backup_file)) {\n        dCWarning(\"failed to copy log file to \\\"%s\\\"\", qPrintable(log_backup_file));\n    }\n\n    return exitCode;\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2017 ~ 2017 Deepin Technology Co., Ltd.\n *\n * Author:     zccrs <zccrs@live.com>\n *\n * Maintainer: zccrs <zhangjide@deepin.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#define private public\n#include <private/qiodevice_p.h>\n#undef private\n\n#include \"ddevicediskinfo.h\"\n#include \"ddiskinfo_p.h\"\n#include \"helper.h\"\n#include \"ddevicepartinfo.h\"\n#include \"dpartinfo_p.h\"\n\n#include <QJsonObject>\n#include <QJsonArray>\n#include <QJsonDocument>\n#include <QProcess>\n#include <QBuffer>\n\nstatic QString getPTName(const QString &device)\n{\n    Helper::processExec(QStringLiteral(\"/sbin/blkid -p -s PTTYPE -d -i %1\").arg(device));\n\n    const QByteArray &data = Helper::lastProcessStandardOutput();\n\n    if (data.isEmpty())\n        return QString();\n\n    const QByteArrayList &list = data.split('=');\n\n    if (list.count() != 3)\n        return QString();\n\n    return list.last().simplified();\n}\n\nclass DDeviceDiskInfoPrivate : public DDiskInfoPrivate\n{\npublic:\n    DDeviceDiskInfoPrivate(DDeviceDiskInfo *qq);\n    ~DDeviceDiskInfoPrivate();\n\n    void init(const QJsonObject &obj);\n\n    QString filePath() const Q_DECL_OVERRIDE;\n    void refresh() Q_DECL_OVERRIDE;\n\n    bool hasScope(DDiskInfo::DataScope scope, DDiskInfo::ScopeMode mode, int index = 0) const Q_DECL_OVERRIDE;\n    bool openDataStream(int index) Q_DECL_OVERRIDE;\n    void closeDataStream() Q_DECL_OVERRIDE;\n\n    // Unfulfilled\n    qint64 readableDataSize(DDiskInfo::DataScope scope) const Q_DECL_OVERRIDE;\n\n    qint64 totalReadableDataSize() const Q_DECL_OVERRIDE;\n    qint64 maxReadableDataSize() const Q_DECL_OVERRIDE;\n    qint64 totalWritableDataSize() const Q_DECL_OVERRIDE;\n\n    qint64 read(char *data, qint64 maxSize) Q_DECL_OVERRIDE;\n    qint64 write(const char *data, qint64 maxSize) Q_DECL_OVERRIDE;\n\n    bool atEnd() const Q_DECL_OVERRIDE;\n\n    QString errorString() const Q_DECL_OVERRIDE;\n\n    bool isClosing() const;\n\n    QProcess *process = NULL;\n    QBuffer buffer;\n    bool closing = false;\n};\n\nDDeviceDiskInfoPrivate::DDeviceDiskInfoPrivate(DDeviceDiskInfo *qq)\n    : DDiskInfoPrivate(qq)\n{\n\n}\n\nDDeviceDiskInfoPrivate::~DDeviceDiskInfoPrivate()\n{\n    closeDataStream();\n\n    if (process)\n        process->deleteLater();\n}\n\nvoid DDeviceDiskInfoPrivate::init(const QJsonObject &obj)\n{\n    model = obj.value(\"model\").toString();\n    name = obj.value(\"name\").toString();\n    kname = obj.value(\"kname\").toString();\n    size = obj.value(\"size\").toString().toLongLong();\n    typeName = obj.value(\"type\").toString();\n    readonly = obj.value(\"ro\").toString() == \"1\" || typeName == \"rom\";\n    removeable = obj.value(\"rm\").toString() == \"1\";\n    transport = obj.value(\"tran\").toString();\n    serial = obj.value(\"serial\").toString();\n\n    if (obj.value(\"pkname\").isNull())\n        type = DDiskInfo::Disk;\n    else\n        type = DDiskInfo::Part;\n\n    const QJsonArray &list = obj.value(\"children\").toArray();\n    QStringList children_uuids;\n\n    for (const QJsonValue &part : list) {\n        const QJsonObject &obj = part.toObject();\n\n        const QString &uuid = obj.value(\"partuuid\").toString();\n\n        if (!uuid.isEmpty() && children_uuids.contains(uuid))\n            continue;\n\n        DDevicePartInfo info;\n\n        info.init(obj);\n\n        if (!info.partUUID().isEmpty() && children_uuids.contains(info.partUUID()))\n            continue;\n\n        info.d->transport = transport;\n        children << info;\n        children_uuids << info.partUUID();\n    }\n\n    qSort(children.begin(), children.end(), [] (const DPartInfo &info1, const DPartInfo &info2) {\n        return info1.sizeStart() < info2.sizeStart();\n    });\n\n    if (type == DDiskInfo::Disk)\n        ptTypeName = getPTName(name);\n    else\n        ptTypeName = getPTName(obj.value(\"pkname\").toString());\n\n    if (ptTypeName == \"dos\") {\n        ptType = DDiskInfo::MBR;\n    } else if (ptTypeName == \"gpt\") {\n        ptType = DDiskInfo::GPT;\n    } else {\n        ptType = DDiskInfo::Unknow;\n        havePartitionTable = false;\n    }\n\n    if (type == DDiskInfo::Part)\n        havePartitionTable = false;\n\n    if ((!havePartitionTable && children.isEmpty()) || type == DDiskInfo::Part) {\n        DDevicePartInfo info;\n\n        info.init(obj);\n        info.d->transport = transport;\n        info.d->index = 0;\n        children << info;\n    }\n}\n\nQString DDeviceDiskInfoPrivate::filePath() const\n{\n    return name;\n}\n\nvoid DDeviceDiskInfoPrivate::refresh()\n{\n    children.clear();\n\n    const QJsonArray &block_devices = Helper::getBlockDevices(name);\n\n    if (!block_devices.isEmpty())\n        init(block_devices.first().toObject());\n}\n\nbool DDeviceDiskInfoPrivate::hasScope(DDiskInfo::DataScope scope, DDiskInfo::ScopeMode mode, int index) const\n{\n    if (mode == DDiskInfo::Read) {\n        if (scope == DDiskInfo::Headgear) {\n            return havePartitionTable && (children.isEmpty() || children.first().sizeStart() >= 1048576);\n        } else if (scope == DDiskInfo::JsonInfo) {\n            return true;\n        }\n\n        if (scope == DDiskInfo::PartitionTable)\n            return havePartitionTable;\n    } else if (readonly || scope == DDiskInfo::JsonInfo) {\n        return false;\n    }\n\n    if (scope == DDiskInfo::Partition) {\n        if (index == 0 && mode == DDiskInfo::Write)\n            return true;\n\n        const DPartInfo &info = q->getPartByNumber(index);\n\n        if (!info) {\n            dCDebug(\"Can not find parition by number(device: \\\"%s\\\"): %d\", qPrintable(q->filePath()), index);\n\n            return false;\n        }\n\n        if (info.isExtended() || (mode == DDiskInfo::Read\n                                  && info.type() == DPartInfo::Unknow\n                                  && info.fileSystemType() == DPartInfo::Invalid\n                                  && info.guidType() == DPartInfo::InvalidGUID)) {\n            dCDebug(\"Skip the \\\"%s\\\" partition, type: %s\", qPrintable(info.filePath()), qPrintable(info.typeDescription(info.type())));\n\n            return false;\n        }\n\n        return mode != DDiskInfo::Write || !info.isReadonly();\n    }\n\n    return (scope == DDiskInfo::Headgear || scope == DDiskInfo::PartitionTable) ? type == DDiskInfo::Disk : true;\n}\n\nbool DDeviceDiskInfoPrivate::openDataStream(int index)\n{\n    if (process) {\n        process->deleteLater();\n    }\n\n    process = new QProcess();\n\n    QObject::connect(process, static_cast<void (QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n                     process, [this] (int code, QProcess::ExitStatus status) {\n        if (isClosing())\n            return;\n\n        if (status == QProcess::CrashExit) {\n            setErrorString(QObject::tr(\"process \\\"%1 %2\\\" crashed\").arg(process->program()).arg(process->arguments().join(\" \")));\n        } else if (code != 0) {\n            setErrorString(QObject::tr(\"Failed to perform process \\\"%1 %2\\\", error: %3\").arg(process->program()).arg(process->arguments().join(\" \")).arg(QString::fromUtf8(process->readAllStandardError())));\n        }\n    });\n\n    switch (currentScope) {\n    case DDiskInfo::Headgear: {\n        if (type != DDiskInfo::Disk) {\n            setErrorString(QObject::tr(\"\\\"%1\\\" is not a disk device\").arg(filePath()));\n\n            return false;\n        }\n\n        if (currentMode == DDiskInfo::Read) {\n            process->start(QStringLiteral(\"dd if=%1 bs=512 count=2048 status=none\").arg(filePath()), QIODevice::ReadOnly);\n        } else {\n            process->start(QStringLiteral(\"dd of=%1 bs=512 status=none conv=fsync\").arg(filePath()));\n        }\n\n        break;\n    }\n    case DDiskInfo::PartitionTable: {\n        if (type != DDiskInfo::Disk) {\n            setErrorString(QObject::tr(\"\\\"%1\\\" is not a disk device\").arg(filePath()));\n\n            return false;\n        }\n\n        if (currentMode == DDiskInfo::Read)\n            process->start(QStringLiteral(\"sfdisk -d %1\").arg(filePath()), QIODevice::ReadOnly);\n        else\n            process->start(QStringLiteral(\"sfdisk %1 --no-reread\").arg(filePath()));\n\n        break;\n    }\n    case DDiskInfo::Partition: {\n        const DPartInfo &part = (index == 0 && currentMode == DDiskInfo::Write) ? DDevicePartInfo(filePath()) : q->getPartByNumber(index);\n\n        if (!part) {\n            dCDebug(\"Part is null(index: %d)\", index);\n\n            return false;\n        }\n\n        dCDebug(\"Try open device: %s, mode: %s\", qPrintable(part.filePath()), currentMode == DDiskInfo::Read ? \"Read\" : \"Write\");\n\n        if (Helper::isMounted(part.filePath())) {\n            if (Helper::umountDevice(part.filePath())) {\n                part.d->mountPoint.clear();\n            } else {\n                setErrorString(QObject::tr(\"\\\"%1\\\" is busy\").arg(part.filePath()));\n\n                return false;\n            }\n        }\n\n        if (currentMode == DDiskInfo::Read) {\n            const QString &executer = Helper::getPartcloneExecuter(part);\n            process->start(QStringLiteral(\"%1 -s %2 -o - -c -z %3 -L /var/log/partclone.log\").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);\n        } else {\n            process->start(QStringLiteral(\"partclone.restore -s - -o %2 -z %3 -L /var/log/partclone.log\").arg(part.filePath()).arg(Global::bufferSize));\n        }\n\n        break;\n    }\n    case DDiskInfo::JsonInfo: {\n        process->deleteLater();\n        process = 0;\n        buffer.setData(q->toJson());\n        break;\n    }\n    default:\n        return false;\n    }\n\n    if (process) {\n        if (!process->waitForStarted()) {\n            setErrorString(QObject::tr(\"Failed to start \\\"%1 %2\\\", error: %3\").arg(process->program()).arg(process->arguments().join(\" \")).arg(process->errorString()));\n\n            return false;\n        }\n\n        dCDebug(\"The \\\"%s %s\\\" command start finished\", qPrintable(process->program()), qPrintable(process->arguments().join(\" \")));\n    }\n\n    bool ok = process ? process->isOpen() : buffer.open(QIODevice::ReadOnly);\n\n    if (!ok) {\n        setErrorString(QObject::tr(\"Failed to open process, error: %1\").arg(process ? process->errorString(): buffer.errorString()));\n    }\n\n    return ok;\n}\n\nvoid DDeviceDiskInfoPrivate::closeDataStream()\n{\n    closing = true;\n\n    if (process) {\n        if (process->state() != QProcess::NotRunning) {\n            if (currentMode == DDiskInfo::Read) {\n                process->closeReadChannel(QProcess::StandardOutput);\n                process->terminate();\n            } else {\n                process->closeWriteChannel();\n            }\n\n            while (process->state() != QProcess::NotRunning) {\n                QThread::currentThread()->sleep(1);\n\n                if (!QFile::exists(QString(\"/proc/%2\").arg(process->pid()))) {\n                    process->waitForFinished(-1);\n\n                    if (process->error() == QProcess::Timedout)\n                        process->QIODevice::d_func()->errorString.clear();\n\n                    break;\n                }\n            }\n        }\n\n        dCDebug(\"Process exit code: %d(%s %s)\", process->exitCode(), qPrintable(process->program()), qPrintable(process->arguments().join(' ')));\n    }\n\n    if (currentMode == DDiskInfo::Write && currentScope == DDiskInfo::PartitionTable) {\n        Helper::umountDevice(filePath());\n\n        if (Helper::refreshSystemPartList(filePath())) {\n            refresh();\n        } else {\n            dCWarning(\"Refresh the devcie %s failed\", qPrintable(filePath()));\n        }\n    }\n\n    if (currentScope == DDiskInfo::JsonInfo)\n        buffer.close();\n\n    closing = false;\n}\n\nqint64 DDeviceDiskInfoPrivate::readableDataSize(DDiskInfo::DataScope scope) const\n{\n    Q_UNUSED(scope)\n\n    return -1;\n}\n\nqint64 DDeviceDiskInfoPrivate::totalReadableDataSize() const\n{\n    qint64 size = 0;\n\n    if (hasScope(DDiskInfo::PartitionTable, DDiskInfo::Read)) {\n        if (hasScope(DDiskInfo::Headgear, DDiskInfo::Read)) {\n            size += 1048576;\n        } else if (!children.isEmpty()) {\n            size += children.first().sizeStart();\n        }\n\n        if (ptType == DDiskInfo::MBR) {\n            size += 512;\n        } else if (ptType == DDiskInfo::GPT) {\n            size += 17408;\n            size += 16896;\n        }\n    }\n\n    for (const DPartInfo &part : children) {\n        if (!part.isExtended())\n            size += part.usedSize();\n    }\n\n    return size;\n}\n\nqint64 DDeviceDiskInfoPrivate::maxReadableDataSize() const\n{\n    if (children.isEmpty()) {\n        return totalReadableDataSize();\n    }\n\n    if (type == DDiskInfo::Disk)\n        return children.last().sizeEnd() + 1;\n\n    return children.first().totalSize();\n}\n\nqint64 DDeviceDiskInfoPrivate::totalWritableDataSize() const\n{\n    return size;\n}\n\nqint64 DDeviceDiskInfoPrivate::read(char *data, qint64 maxSize)\n{\n    if (!process) {\n        return buffer.read(data, maxSize);\n    }\n\n    process->waitForReadyRead(-1);\n\n    if (process->bytesAvailable() > Global::bufferSize) {\n        dCWarning(\"The \\\"%s %s\\\" process bytes available: %s\", qPrintable(process->program()), qPrintable(process->arguments().join(\" \")), qPrintable(Helper::sizeDisplay(process->bytesAvailable())));\n    }\n\n    return process->read(data, maxSize);\n}\n\nqint64 DDeviceDiskInfoPrivate::write(const char *data, qint64 maxSize)\n{\n    if (!process)\n        return -1;\n\n    if (process->state() != QProcess::Running)\n        return -1;\n\n    qint64 size = process->write(data, maxSize);\n\n    QElapsedTimer timer;\n\n    timer.start();\n\n    int timeout = 5000;\n\n    while (process->state() == QProcess::Running && process->bytesToWrite() > 0) {\n        process->waitForBytesWritten();\n\n        if (timer.elapsed() > timeout) {\n            timeout += 5000;\n\n            dCWarning(\"Wait for bytes written timeout, elapsed: %lld, bytes to write: %lld\", timer.elapsed(), process->bytesToWrite());\n        }\n    }\n\n    return size;\n}\n\nbool DDeviceDiskInfoPrivate::atEnd() const\n{\n    if (!process) {\n        return buffer.atEnd();\n    }\n\n    process->waitForReadyRead(-1);\n\n    return process->atEnd();\n}\n\nQString DDeviceDiskInfoPrivate::errorString() const\n{\n    if (error.isEmpty()) {\n        if (process) {\n            if (process->error() == QProcess::UnknownError)\n                return QString();\n\n            return QString(\"%1 %2: %3\").arg(process->program()).arg(process->arguments().join(' ')).arg(process->errorString());\n        }\n\n        if (!buffer.QIODevice::d_func()->errorString.isEmpty())\n            return buffer.errorString();\n    }\n\n    return error;\n}\n\nbool DDeviceDiskInfoPrivate::isClosing() const\n{\n    return closing;\n}\n\nDDeviceDiskInfo::DDeviceDiskInfo()\n{\n\n}\n\nDDeviceDiskInfo::DDeviceDiskInfo(const QString &filePath)\n{\n    const QJsonArray &block_devices = Helper::getBlockDevices(filePath);\n\n    if (!block_devices.isEmpty()) {\n        const QJsonObject &obj = block_devices.first().toObject();\n\n        d = new DDeviceDiskInfoPrivate(this);\n        d_func()->init(obj);\n\n        if (d->type == Part) {\n            const QJsonArray &parent = Helper::getBlockDevices(obj.value(\"pkname\").toString());\n\n            if (!parent.isEmpty()) {\n                const QJsonObject &parent_obj = parent.first().toObject();\n\n                d->transport = parent_obj.value(\"tran\").toString();\n                d->model = parent_obj.value(\"model\").toString();\n                d->serial = parent_obj.value(\"serial\").toString();\n            }\n\n            if (!d->children.isEmpty())\n                d->children.first().d->transport = d->transport;\n        }\n    }\n}\n\nQList<DDeviceDiskInfo> DDeviceDiskInfo::localeDiskList()\n{\n    const QJsonArray &block_devices = Helper::getBlockDevices();\n\n    QList<DDeviceDiskInfo> list;\n\n    for (const QJsonValue &value : block_devices) {\n        const QJsonObject &obj = value.toObject();\n\n        if (Global::disableLoopDevice && obj.value(\"type\").toString() == \"loop\")\n            continue;\n\n        DDeviceDiskInfo info;\n\n        info.d = new DDeviceDiskInfoPrivate(&info);\n        info.d_func()->init(obj);\n        list << info;\n    }\n\n    return list;\n}\n", "/*\n * Copyright (C) 2017 ~ 2017 Deepin Technology Co., Ltd.\n *\n * Author:     zccrs <zccrs@live.com>\n *\n * Maintainer: zccrs <zhangjide@deepin.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"helper.h\"\n#include \"dpartinfo.h\"\n#include \"dglobal.h\"\n#include \"ddevicepartinfo.h\"\n#include \"ddiskinfo.h\"\n\n#include <QProcess>\n#include <QEventLoop>\n#include <QTimer>\n#include <QJsonDocument>\n#include <QJsonObject>\n#include <QFile>\n#include <QDebug>\n#include <QLoggingCategory>\n#include <QRegularExpression>\n#include <QUuid>\n\n#define COMMAND_LSBLK QStringLiteral(\"/bin/lsblk -J -b -p -o NAME,KNAME,PKNAME,FSTYPE,MOUNTPOINT,LABEL,UUID,SIZE,TYPE,PARTTYPE,PARTLABEL,PARTUUID,MODEL,PHY-SEC,RO,RM,TRAN,SERIAL %1\")\n\nQByteArray Helper::m_processStandardError;\nQByteArray Helper::m_processStandardOutput;\n\nQ_LOGGING_CATEGORY(lcDeepinGhost, \"deepin.ghost\")\nQ_GLOBAL_STATIC(Helper, _g_globalHelper)\n\nHelper *Helper::instance()\n{\n    return _g_globalHelper;\n}\n\nint Helper::processExec(QProcess *process, const QString &command, int timeout, QIODevice::OpenMode mode)\n{\n    m_processStandardOutput.clear();\n    m_processStandardError.clear();\n\n    QEventLoop loop;\n    QTimer timer;\n\n    timer.setSingleShot(true);\n    timer.setInterval(timeout);\n\n    timer.connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);\n    loop.connect(process, static_cast<void(QProcess::*)(int)>(&QProcess::finished), &loop, &QEventLoop::exit);\n\n    // \u9632\u6b62\u5b50\u8fdb\u7a0b\u8f93\u51fa\u4fe1\u606f\u5c06\u7ba1\u9053\u585e\u6ee1\u5bfc\u81f4\u8fdb\u7a0b\u963b\u585e\n    process->connect(process, &QProcess::readyReadStandardError, process, [process] {\n        m_processStandardError.append(process->readAllStandardError());\n    });\n    process->connect(process, &QProcess::readyReadStandardOutput, process, [process] {\n        m_processStandardOutput.append(process->readAllStandardOutput());\n    });\n\n    if (timeout > 0) {\n        timer.start();\n    } else {\n        QTimer::singleShot(10000, process, [process] {\n            dCWarning(\"\\\"%s %s\\\" running for more than 10 seconds, state=%d, pid_file_exist=%d\",\n                      qPrintable(process->program()), qPrintable(process->arguments().join(\" \")),\n                      (int)process->state(), (int)QFile::exists(QString(\"/proc/%1\").arg(process->pid())));\n        });\n    }\n\n    if (Global::debugLevel > 1)\n        dCDebug(\"Exec: \\\"%s\\\", timeout: %d\", qPrintable(command), timeout);\n\n    process->start(command, mode);\n    process->waitForStarted();\n\n    if (process->error() != QProcess::UnknownError) {\n        dCError(process->errorString());\n\n        return -1;\n    }\n\n    if (process->state() == QProcess::Running) {\n        loop.exec();\n    }\n\n    if (process->state() != QProcess::NotRunning) {\n        dCDebug(\"The \\\"%s\\\" timeout, timeout: %d\", qPrintable(command), timeout);\n\n        // QT Bug\uff0c\u67d0\u79cd\u60c5\u51b5\u4e0b(\u672a\u77e5) QProcess::state \u8fd4\u56de\u7684\u72b6\u6001\u6709\u8bef\uff0c\u5bfc\u81f4\u8fdb\u7a0b\u5df2\u9000\u51fa\u5374\u672a\u80fd\u6b63\u786e\u83b7\u53d6\u5230\u5176\u5f53\u524d\u72b6\u6001\n        // \u56e0\u6b64,\u989d\u5916\u901a\u8fc7\u7cfb\u7edf\u6587\u4ef6\u5224\u65ad\u8fdb\u7a0b\u662f\u5426\u8fd8\u5b58\u5728\n        if (QFile::exists(QString(\"/proc/%1\").arg(process->pid()))) {\n            process->terminate();\n            process->waitForFinished();\n        } else {\n            dCDebug(\"The \\\"%s\\\" is quit, but the QProcess object state is not NotRunning\");\n        }\n    }\n\n    m_processStandardOutput.append(process->readAllStandardOutput());\n    m_processStandardError.append(process->readAllStandardError());\n\n    if (Global::debugLevel > 1) {\n        dCDebug(\"Done: \\\"%s\\\", exit code: %d\", qPrintable(command), process->exitCode());\n\n        if (process->exitCode() != 0) {\n            dCError(\"error: \\\"%s\\\"\\nstdout: \\\"%s\\\"\", qPrintable(m_processStandardError), qPrintable(m_processStandardOutput));\n        }\n    }\n\n    return process->exitCode();\n}\n\nint Helper::processExec(const QString &command, int timeout)\n{\n    QProcess process;\n\n    return processExec(&process, command, timeout);\n}\n\nQByteArray Helper::lastProcessStandardOutput()\n{\n    return m_processStandardOutput;\n}\n\nQByteArray Helper::lastProcessStandardError()\n{\n    return m_processStandardError;\n}\n\nconst QLoggingCategory &Helper::loggerCategory()\n{\n    return lcDeepinGhost();\n}\n\nvoid Helper::warning(const QString &message)\n{\n    m_warningString = message;\n\n    emit newWarning(message);\n}\n\nvoid Helper::error(const QString &message)\n{\n    m_errorString = message;\n\n    emit newError(message);\n}\n\nQString Helper::lastWarningString()\n{\n    return m_warningString;\n}\n\nQString Helper::lastErrorString()\n{\n    return m_errorString;\n}\n\nQString Helper::sizeDisplay(qint64 size)\n{\n    constexpr qreal kb = 1024;\n    constexpr qreal mb = kb * 1024;\n    constexpr qreal gb = mb * 1024;\n    constexpr qreal tb = gb * 1024;\n\n    if (size > tb)\n        return QString::asprintf(\"%.2f TB\", size / tb);\n\n    if (size > gb)\n        return QString::asprintf(\"%.2f GB\", size / gb);\n\n    if (size > mb)\n        return QString::asprintf(\"%.2f MB\", size / mb);\n\n    if (size > kb)\n        return QString::asprintf(\"%.2f KB\", size / kb);\n\n    return QString(\"%1 B\").arg(size);\n}\n\nQString Helper::secondsToString(qint64 seconds)\n{\n    int days = seconds / 86400;\n\n    seconds = seconds % 86400;\n\n    int hours = seconds / 3600;\n\n    seconds = seconds % 3600;\n\n    int minutes = seconds / 60;\n\n    seconds = seconds % 60;\n\n    if (days > 0)\n        return QObject::tr(\"%1 d %2 h %3 m\").arg(days).arg(hours).arg(minutes + 1);\n\n    if (hours > 0)\n        return QObject::tr(\"%1 h %2 m\").arg(hours).arg(minutes + 1);\n\n    if (minutes > 0)\n        return QObject::tr(\"%1 m\").arg(minutes + 1);\n\n    return QObject::tr(\"%1 s\").arg(seconds);\n}\n\nbool Helper::refreshSystemPartList(const QString &device)\n{\n    int code = device.isEmpty() ? processExec(\"partprobe\") : processExec(QString(\"partprobe %1\").arg(device));\n\n    if (code != 0)\n        return false;\n\n    QThread::sleep(1);\n\n    return true;\n}\n\nQString Helper::getPartcloneExecuter(const DPartInfo &info)\n{\n    QString executor;\n\n    switch (info.fileSystemType()) {\n    case DPartInfo::Invalid:\n        break;\n    case DPartInfo::Btrfs:\n        executor = \"btrfs\";\n        break;\n    case DPartInfo::EXT2:\n    case DPartInfo::EXT3:\n    case DPartInfo::EXT4:\n        executor = \"extfs\";\n        break;\n    case DPartInfo::F2FS:\n        executor = \"f2fs\";\n        break;\n    case DPartInfo::FAT12:\n    case DPartInfo::FAT16:\n    case DPartInfo::FAT32:\n        executor = \"fat\";\n        break;\n    case DPartInfo::HFS_Plus:\n        executor = \"hfsplus\";\n        break;\n    case DPartInfo::Minix:\n        executor = \"minix\";\n        break;\n    case DPartInfo::Nilfs2:\n        executor = \"nilfs2\";\n        break;\n    case DPartInfo::NTFS:\n        executor = \"ntfs -I\";\n        break;\n    case DPartInfo::Reiser4:\n        executor = \"reiser4\";\n        break;\n    case DPartInfo::VFAT:\n        executor = \"vfat\";\n        break;\n    case DPartInfo::XFS:\n        executor = \"xfs\";\n        break;\n    default:\n        if (!QStandardPaths::findExecutable(\"partclone.\" + info.fileSystemTypeName().toLower()).isEmpty())\n            executor = info.fileSystemTypeName().toLower();\n        break;\n    }\n\n    if (executor.isEmpty())\n        return \"partclone.imager\";\n\n    return \"partclone.\" + executor;\n}\n\nbool Helper::getPartitionSizeInfo(const QString &partDevice, qint64 *used, qint64 *free, int *blockSize)\n{\n    QProcess process;\n    QStringList env_list = QProcess::systemEnvironment();\n\n    env_list.append(\"LANG=C\");\n    process.setEnvironment(env_list);\n\n    if (Helper::isMounted(partDevice)) {\n        process.start(QString(\"df -B1 -P %1\").arg(partDevice));\n        process.waitForFinished();\n\n        if (process.exitCode() != 0) {\n            dCError(\"Call df failed: %s\", qPrintable(process.readAllStandardError()));\n\n            return false;\n        }\n\n        QByteArray output = process.readAll();\n        const QByteArrayList &lines = output.trimmed().split('\\n');\n\n        if (lines.count() != 2)\n            return false;\n\n        output = lines.last().simplified();\n\n        const QByteArrayList &values = output.split(' ');\n\n        if (values.count() != 6)\n            return false;\n\n        bool ok = false;\n\n        if (used)\n            *used = values.at(2).toLongLong(&ok);\n\n        if (!ok)\n            return false;\n\n        if (free)\n            *free = values.at(3).toLongLong(&ok);\n\n        if (!ok)\n            return false;\n\n        return true;\n    } else {\n        process.start(QString(\"%1 -s %2 -c -q -C -L /var/log/partclone.log\").arg(getPartcloneExecuter(DDevicePartInfo(partDevice))).arg(partDevice));\n        process.setStandardOutputFile(\"/dev/null\");\n        process.setReadChannel(QProcess::StandardError);\n        process.waitForStarted();\n\n        qint64 used_block = -1;\n        qint64 free_block = -1;\n\n        while (process.waitForReadyRead(5000)) {\n            const QByteArray &data = process.readAll();\n\n            for (QByteArray line : data.split('\\n')) {\n                line = line.simplified();\n\n                if (QString::fromLatin1(line).contains(QRegularExpression(\"\\\\berror\\\\b\"))) {\n                    dCError(\"Call \\\"%s %s\\\" failed: \\\"%s\\\"\", qPrintable(process.program()), qPrintable(process.arguments().join(' ')), line.constData());\n                }\n\n                if (line.startsWith(\"Space in use:\")) {\n                    bool ok = false;\n                    const QByteArray &value = line.split(' ').value(6, \"-1\");\n\n                    used_block = value.toLongLong(&ok);\n\n                    if (!ok) {\n                        dCError(\"String to LongLong failed, String: %s\", value.constData());\n\n                        return false;\n                    }\n                } else if (line.startsWith(\"Free Space:\")) {\n                    bool ok = false;\n                    const QByteArray &value = line.split(' ').value(5, \"-1\");\n\n                    free_block = value.toLongLong(&ok);\n\n                    if (!ok) {\n                        dCError(\"String to LongLong failed, String: %s\", value.constData());\n\n                        return false;\n                    }\n                } else if (line.startsWith(\"Block size:\")) {\n                    bool ok = false;\n                    const QByteArray &value = line.split(' ').value(2, \"-1\");\n\n                    int block_size = value.toInt(&ok);\n\n                    if (!ok) {\n                        dCError(\"String to Int failed, String: %s\", value.constData());\n\n                        return false;\n                    }\n\n                    if (used_block < 0 || free_block < 0 || block_size < 0)\n                        return false;\n\n                    if (used)\n                        *used = used_block * block_size;\n\n                    if (free)\n                        *free = free_block * block_size;\n\n                    if (blockSize)\n                        *blockSize = block_size;\n\n                    process.terminate();\n                    process.waitForFinished();\n\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nQByteArray Helper::callLsblk(const QString &extraArg)\n{\n    processExec(COMMAND_LSBLK.arg(extraArg));\n\n    return lastProcessStandardOutput();\n}\n\nQJsonArray Helper::getBlockDevices(const QString &commandExtraArg)\n{\n    const QByteArray &array = Helper::callLsblk(commandExtraArg);\n\n    QJsonParseError error;\n\n    const QJsonDocument &jd = QJsonDocument::fromJson(QString::fromUtf8(array).toUtf8(), &error);\n\n    if (error.error != QJsonParseError::NoError) {\n        dCError(error.errorString());\n    }\n\n    return jd.object().value(\"blockdevices\").toArray();\n}\n\nQString Helper::mountPoint(const QString &device)\n{\n    const QJsonArray &array = getBlockDevices(device);\n\n    if (array.isEmpty())\n        return QString();\n\n    return array.first().toObject().value(\"mountpoint\").toString();\n}\n\nbool Helper::isMounted(const QString &device)\n{\n    const QJsonArray &array = getBlockDevices(\"-l \" + device);\n\n    for (const QJsonValue &part : array) {\n        const QJsonObject &obj = part.toObject();\n\n        if (!obj.value(\"mountpoint\").isNull())\n            return true;\n    }\n\n    return false;\n}\n\nbool Helper::umountDevice(const QString &device)\n{\n    const QJsonArray &array = getBlockDevices(\"-l \" + device);\n\n    for (const QJsonValue &device : array) {\n        const QJsonObject &obj = device.toObject();\n\n        if (!obj.value(\"mountpoint\").isNull()) {\n            if (processExec(QString(\"umount -d %1\").arg(obj.value(\"name\").toString())) != 0)\n                return false;\n        }\n    }\n\n    return true;\n}\n\nbool Helper::tryUmountDevice(const QString &device)\n{\n    const QJsonArray &array = getBlockDevices(\"-l \" + device);\n\n    for (const QJsonValue &device : array) {\n        const QJsonObject &obj = device.toObject();\n\n        if (!obj.value(\"mountpoint\").isNull()) {\n            if (processExec(QString(\"umount -d %1 --fake\").arg(obj.value(\"name\").toString())) != 0)\n                return false;\n        }\n    }\n\n    return true;\n}\n\nbool Helper::mountDevice(const QString &device, const QString &path, bool readonly)\n{\n    if (readonly)\n        return processExec(QString(\"mount -r %1 %2\").arg(device, path)) == 0;\n\n    return processExec(QString(\"mount %1 %2\").arg(device, path)) == 0;\n}\n\nQString Helper::temporaryMountDevice(const QString &device, const QString &name, bool readonly)\n{\n    QString mount_point = mountPoint(device);\n\n    if (!mount_point.isEmpty())\n        return mount_point;\n\n    mount_point = \"%1/.%2/mount/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::RuntimeLocation);\n\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/run/user/0\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n\n        return QString();\n    }\n\n    if (!mountDevice(device, mount_point, readonly)) {\n        dCError(\"Mount the device \\\"%s\\\" to \\\"%s\\\" failed\", qPrintable(device), qPrintable(mount_point));\n\n        return QString();\n    }\n\n    return mount_point;\n}\n\nQString Helper::findDiskBySerialIndexNumber(const QString &serialNumber, int partIndexNumber)\n{\n    const QJsonArray &array = getBlockDevices();\n\n    for (const QJsonValue &disk : array) {\n        const QJsonObject &obj = disk.toObject();\n\n        if (obj.value(\"serial\").toString().compare(serialNumber, Qt::CaseInsensitive) != 0) {\n            continue;\n        }\n\n        if (partIndexNumber <= 0)\n            return obj.value(\"name\").toString();\n\n        const QJsonArray &children = obj.value(\"children\").toArray();\n\n        for (const QJsonValue &v : children) {\n            const QJsonObject &obj = v.toObject();\n            const QString &name = obj.value(\"name\").toString();\n\n            if (DDevicePartInfo(name).indexNumber() == partIndexNumber)\n                return name;\n        }\n    }\n\n    return QString();\n}\n\nint Helper::partitionIndexNumber(const QString &partDevice)\n{\n    const QJsonArray &array = getBlockDevices(partDevice);\n\n    if (array.isEmpty())\n        return -1;\n\n    const QJsonArray &p_array = getBlockDevices(array.first().toObject().value(\"pkname\").toString() + \" -x NAME\");\n\n    if (p_array.isEmpty())\n        return -1;\n\n    const QJsonArray &part_list = p_array.first().toObject().value(\"children\").toArray();\n\n    for (int i = 0; i < part_list.count(); ++i) {\n        const QJsonObject &obj = part_list.at(i).toObject();\n\n        if (obj.value(\"name\").toString() == partDevice || obj.value(\"kname\").toString() == partDevice)\n            return i;\n    }\n\n    return -1;\n}\n\nQByteArray Helper::getPartitionTable(const QString &devicePath)\n{\n    processExec(QStringLiteral(\"/sbin/sfdisk -d %1\").arg(devicePath));\n\n    return lastProcessStandardOutput();\n}\n\nbool Helper::setPartitionTable(const QString &devicePath, const QString &ptFile)\n{\n    QProcess process;\n\n    process.setStandardInputFile(ptFile);\n\n    if (processExec(&process, QStringLiteral(\"/sbin/sfdisk %1\").arg(devicePath)) != 0)\n        return false;\n\n    int code = processExec(QStringLiteral(\"/sbin/partprobe %1\").arg(devicePath));\n    processExec(\"sleep 1\");\n\n    return code == 0;\n}\n\nbool Helper::saveToFile(const QString &fileName, const QByteArray &data, bool override)\n{\n    if (!override && QFile::exists(fileName))\n        return false;\n\n    QFile file(fileName);\n\n    if (!file.open(QIODevice::WriteOnly)) {\n        dCError(file.errorString());\n\n        return false;\n    }\n\n    qint64 size = file.write(data);\n    file.flush();\n    file.close();\n\n    return size == data.size();\n}\n\nbool Helper::isBlockSpecialFile(const QString &fileName)\n{\n    if (fileName.startsWith(\"/dev/\"))\n        return true;\n\n    processExec(QStringLiteral(\"env LANG=C stat -c %F %1\").arg(fileName));\n\n    return lastProcessStandardOutput() == \"block special file\\n\";\n}\n\nbool Helper::isPartcloneFile(const QString &fileName)\n{\n    return processExec(QStringLiteral(\"partclone.info %1\").arg(fileName)) == 0;\n}\n\nbool Helper::isDiskDevice(const QString &devicePath)\n{\n    const QJsonArray &blocks = getBlockDevices(devicePath);\n\n    if (blocks.isEmpty())\n        return false;\n\n    if (!blocks.first().isObject())\n        return false;\n\n    return blocks.first().toObject().value(\"pkname\").isNull();\n}\n\nbool Helper::isPartitionDevice(const QString &devicePath)\n{\n    const QJsonArray &blocks = getBlockDevices(devicePath);\n\n    if (blocks.isEmpty())\n        return false;\n\n    if (!blocks.first().isObject())\n        return false;\n\n    return !blocks.first().toObject().value(\"pkname\").isString();\n}\n\nQString Helper::parentDevice(const QString &device)\n{\n    const QJsonArray &blocks = getBlockDevices(device);\n\n    if (blocks.isEmpty())\n        return device;\n\n    const QString &parent = blocks.first().toObject().value(\"pkname\").toString();\n\n    if (parent.isEmpty())\n        return device;\n\n    return parent;\n}\n\nbool Helper::deviceHaveKinship(const QString &device1, const QString &device2)\n{\n    return device1 == device2 || parentDevice(device1) == parentDevice(device2);\n}\n\nint Helper::clonePartition(const DPartInfo &part, const QString &to, bool override)\n{\n    QString executor = getPartcloneExecuter(part);\n    QString command;\n\n    if (executor.isEmpty() || executor == \"partclone.imager\") {\n        if (part.guidType() == DPartInfo::InvalidGUID)\n            return -1;\n\n        command = QStringLiteral(\"dd if=%1 of=%2 status=none conv=fsync\").arg(part.filePath()).arg(to);\n    } else if (isBlockSpecialFile(to)) {\n        command = QStringLiteral(\"/usr/sbin/%1 -b -c -s %2 -%3 %4\").arg(executor).arg(part.filePath()).arg(override ? \"O\" : \"o\").arg(to);\n    } else {\n        command = QStringLiteral(\"/usr/sbin/%1 -c -s %2 -%3 %4\").arg(executor).arg(part.filePath()).arg(override ? \"O\" : \"o\").arg(to);\n    }\n\n    int code = processExec(command);\n\n    if (code != 0)\n        qDebug() << command << QString::fromUtf8(lastProcessStandardOutput());\n\n    return code;\n}\n\nint Helper::restorePartition(const QString &from, const DPartInfo &to)\n{\n    QString command;\n\n    if (isPartcloneFile(from)) {\n        command = QStringLiteral(\"/usr/sbin/partclone.restore -s %1 -o %2\").arg(from).arg(to.filePath());\n    } else {\n        command = QStringLiteral(\"dd if=%1 of=%2 status=none conv=fsync\").arg(from).arg(to.filePath());\n    }\n\n    int code = processExec(command);\n\n    if (code != 0)\n        qDebug() << command << QString::fromUtf8(lastProcessStandardOutput());\n\n    return code;\n}\n\nbool Helper::existLiveSystem()\n{\n    return QFile::exists(\"/recovery\");\n}\n\nbool Helper::restartToLiveSystem(const QStringList &arguments)\n{\n    if (!existLiveSystem()) {\n        dCDebug(\"Not install live system\");\n\n        return false;\n    }\n\n    if (!QDir::current().mkpath(\"/recovery/.tmp\")) {\n        dCDebug(\"mkpath failed\");\n\n        return false;\n    }\n\n    QFile file(\"/recovery/.tmp/deepin-clone.arguments\");\n\n    if (!file.open(QIODevice::WriteOnly)) {\n        dCDebug(\"Open file failed: \\\"%s\\\"\", qPrintable(file.fileName()));\n\n        return false;\n    }\n\n    file.write(arguments.join('\\n').toUtf8());\n    file.close();\n\n    if (processExec(\"grub-reboot \\\"Deepin Recovery\\\"\") != 0) {\n        dCDebug(\"Exec grub-reboot \\\"Deepin Recovery\\\" failed\");\n\n        file.remove();\n\n        return false;\n    }\n\n    if (processExec(\"reboot\") != 0)\n        file.remove();\n\n    return true;\n}\n\nbool Helper::isDeepinSystem(const DPartInfo &part)\n{\n    QString mout_root = part.mountPoint();\n    bool umount_device = false;\n\n    if (mout_root.isEmpty()) {\n        mout_root = temporaryMountDevice(part.name(), QFileInfo(part.name()).fileName(), true);\n\n        if (mout_root.isEmpty())\n            return false;\n\n        umount_device = true;\n    }\n\n    bool is = QFile::exists(mout_root + \"/etc/deepin-version\");\n\n    if (umount_device)\n        umountDevice(part.name());\n\n    return is;\n}\n\nbool Helper::resetPartUUID(const DPartInfo &part, QByteArray uuid)\n{\n    QString command;\n\n    if (uuid.isEmpty()) {\n        uuid = QUuid::createUuid().toByteArray().mid(1, 36);\n    }\n\n    switch (part.fileSystemType()) {\n    case DPartInfo::EXT2:\n    case DPartInfo::EXT3:\n    case DPartInfo::EXT4:\n        command = QString(\"tune2fs -U %1 %2\").arg(QString::fromLatin1(uuid)).arg(part.filePath());\n        break;\n    case DPartInfo::JFS:\n        command = QString(\"jfs_tune -U %1 %2\").arg(QString::fromLatin1(uuid)).arg(part.filePath());\n        break;\n    case DPartInfo::NTFS:\n        command = QString(\"ntfslabel --new-half-serial %1\").arg(part.filePath());\n        break;\n    case DPartInfo::XFS:\n        command = QString(\"xfs_admin -U %1 %2\").arg(QString::fromLatin1(uuid)).arg(part.filePath());\n        break;\n    default:\n        dCDebug(\"Not support the file system type: %s\", qPrintable(part.fileSystemTypeName()));\n\n        return false;\n    }\n\n    if (!umountDevice(part.filePath())) {\n        dCDebug(\"Failed to umount the partition: %s\", qPrintable(part.filePath()));\n\n        return false;\n    }\n\n    // check the partition\n    processExec(\"fsck -f -y \" + part.filePath());\n\n    bool ok = processExec(command) == 0;\n\n    if (!ok) {\n        dCError(\"Failed reset part uuid\");\n        dCDebug(qPrintable(lastProcessStandardOutput()));\n        dCError(qPrintable(lastProcessStandardError()));\n    }\n\n    return ok;\n}\n\nQString Helper::parseSerialUrl(const QString &urlString, QString *errorString)\n{\n    if (urlString.isEmpty())\n        return QString();\n\n    const QUrl url(urlString);\n    const QString serial_number = urlString.split(\"//\").at(1).split(\":\").first();\n    const int part_index = url.port();\n    const QString &path = url.path();\n    const QString &device = Helper::findDiskBySerialIndexNumber(serial_number, part_index);\n    const QString &device_url = part_index > 0 ? QString(\"serial://%1:%2\").arg(serial_number).arg(part_index) : \"serial://\" + serial_number;\n\n    if (device.isEmpty()) {\n        if (errorString) {\n            if (part_index > 0)\n                *errorString = QObject::tr(\"Partition \\\"%1\\\" not found\").arg(device_url);\n            else\n                *errorString = QObject::tr(\"Disk \\\"%1\\\" not found\").arg(device_url);\n        }\n\n        return device;\n    }\n\n    if (path.isEmpty())\n        return device;\n\n    const QString &mp = Helper::mountPoint(device);\n\n    QDir mount_point(mp);\n\n    if (mp.isEmpty()) {\n        QString mount_name;\n\n        if (part_index >= 0)\n            mount_name = QString(\"%1-%2\").arg(serial_number).arg(part_index);\n        else\n            mount_name = serial_number;\n\n        const QString &_mount_point = Helper::temporaryMountDevice(device, mount_name);\n\n        if (_mount_point.isEmpty()) {\n            if (errorString)\n                *errorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(device_url);\n\n            return QString();\n        }\n\n        mount_point.setPath(_mount_point);\n    }\n\n    if (mount_point.absolutePath() == \"/\")\n        return path;\n\n    return mount_point.absolutePath() + path;\n}\n\nQString Helper::getDeviceForFile(const QString &file, QString *rootPath)\n{\n    if (file.isEmpty())\n        return QString();\n\n    if (Helper::isBlockSpecialFile(file))\n        return file;\n\n    QFileInfo info(file);\n\n    while (!info.exists() && info.absoluteFilePath() != \"/\")\n        info.setFile(info.absolutePath());\n\n    QStorageInfo storage_info(info.absoluteFilePath());\n\n    if (rootPath)\n        *rootPath = storage_info.rootPath();\n\n    return QString::fromUtf8(storage_info.device());\n}\n\nQString Helper::toSerialUrl(const QString &file)\n{\n    if (file.isEmpty())\n        return QString();\n\n    if (Helper::isBlockSpecialFile(file)) {\n        DDiskInfo info;\n\n        if (Helper::isDiskDevice(file))\n            info = DDiskInfo::getInfo(file);\n        else\n            info = DDiskInfo::getInfo(Helper::parentDevice(file));\n\n        if (!info)\n            return QString();\n\n        if (info.serial().isEmpty())\n            return QString();\n\n        int index = DDevicePartInfo(file).indexNumber();\n\n        if (index == 0)\n            return \"serial://\" + info.serial();\n\n        return QString(\"serial://%1:%2\").arg(info.serial()).arg(index);\n    }\n\n    QString root_path;\n    QString url = toSerialUrl(getDeviceForFile(file, &root_path));\n\n    if (root_path == \"/\")\n        return url + QFileInfo(file).absoluteFilePath();\n\n    return url + QFileInfo(file).absoluteFilePath().mid(root_path.length());\n}\n", "/*\n * Copyright (C) 2017 ~ 2017 Deepin Technology Co., Ltd.\n *\n * Author:     zccrs <zccrs@live.com>\n *\n * Maintainer: zccrs <zhangjide@deepin.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef HELPER_H\n#define HELPER_H\n\n#include <QByteArray>\n#include <QJsonArray>\n#include <QObject>\n#include <QLoggingCategory>\n#include <QtConcurrent/QtConcurrent>\n#include <QFutureWatcher>\n\n#include <typeinfo>\n\nQT_BEGIN_NAMESPACE\nclass QProcess;\nQT_END_NAMESPACE\n\nclass DPartInfo;\nclass Helper : public QObject\n{\n    Q_OBJECT\n\npublic:\n    static Helper *instance();\n\n    static int processExec(QProcess *process, const QString &command,\n                           int timeout = -1, QIODevice::OpenMode mode = QIODevice::ReadOnly);\n    static int processExec(const QString &command, int timeout = -1);\n    static QByteArray lastProcessStandardOutput();\n    static QByteArray lastProcessStandardError();\n\n    static const QLoggingCategory &loggerCategory();\n\n    void warning(const QString &message);\n    void error(const QString &message);\n    QString lastWarningString();\n    QString lastErrorString();\n\n    static QString sizeDisplay(qint64 size);\n    static QString secondsToString(qint64 seconds);\n\n    static bool refreshSystemPartList(const QString &device = QString());\n    static QString getPartcloneExecuter(const DPartInfo &info);\n    static bool getPartitionSizeInfo(const QString &partDevice, qint64 *used, qint64 *free, int *blockSize);\n\n    static QByteArray callLsblk(const QString &extraArg = QString());\n    static QJsonArray getBlockDevices(const QString &commandExtraArg = QString());\n\n    static QString mountPoint(const QString &device);\n    static bool isMounted(const QString &device);\n    static bool umountDevice(const QString &device);\n    static bool tryUmountDevice(const QString &device);\n    static bool mountDevice(const QString &device, const QString &path, bool readonly = false);\n    static QString temporaryMountDevice(const QString &device, const QString &name, bool readonly = false);\n\n    static QString findDiskBySerialIndexNumber(const QString &serialNumber, int partIndexNumber = -1);\n    static int partitionIndexNumber(const QString &partDevice);\n\n    static QByteArray getPartitionTable(const QString &devicePath);\n    static bool setPartitionTable(const QString &devicePath, const QString &ptFile);\n    static bool saveToFile(const QString &fileName, const QByteArray &data, bool override = true);\n    static bool isBlockSpecialFile(const QString &fileName);\n    static bool isPartcloneFile(const QString &fileName);\n    static bool isDiskDevice(const QString &devicePath);\n    static bool isPartitionDevice(const QString &devicePath);\n    static QString parentDevice(const QString &device);\n    static bool deviceHaveKinship(const QString &device1, const QString &device2);\n\n    static int clonePartition(const DPartInfo &part, const QString &to, bool override = true);\n    static int restorePartition(const QString &from, const DPartInfo &to);\n\n    static bool existLiveSystem();\n    static bool restartToLiveSystem(const QStringList &arguments);\n\n    static bool isDeepinSystem(const DPartInfo &part);\n    static bool resetPartUUID(const DPartInfo &part, QByteArray uuid = QByteArray());\n\n    static QString getDeviceForFile(const QString &file, QString *rootPath = 0);\n    static QString parseSerialUrl(const QString &urlString, QString *errorString = 0);\n    static QString toSerialUrl(const QString &file);\n\n    static bool clearSymlink(const QString &path);\n\nsignals:\n    void newWarning(const QString &message);\n    void newError(const QString &message);\n\nprivate:\n    static QByteArray m_processStandardOutput;\n    static QByteArray m_processStandardError;\n\n    QString m_warningString;\n    QString m_errorString;\n};\n\ntemplate<typename... Args>\nstatic\ntypename QtPrivate::QEnableIf<int(sizeof...(Args)) >= 1, QString>::Type\n__d_asprintf__(const char *format, Args&&... args)\n{\n    return QString::asprintf(format, std::forward<Args>(args)...);\n}\ntemplate<typename... Args>\nstatic\ntypename QtPrivate::QEnableIf<int(sizeof...(Args)) == 0, QString>::Type\n__d_asprintf__(const char *message, Args&&...)\n{\n    return QString::asprintf(\"%s\", message);\n}\ntemplate<typename... Args>\nstatic QString __d_asprintf__(const QString &string, Args&&... args)\n{\n    return __d_asprintf__(string.toUtf8().constData(), std::forward<Args>(args)...);\n}\ntemplate<typename... Args>\nstatic QString __d_asprintf__(const QByteArray &array, Args&&... args)\n{\n    return __d_asprintf__(array.constData(), std::forward<Args>(args)...);\n}\n\n#ifdef dCDebug\n#undef dCDebug\n#endif\n#define dCDebug(...) qCDebug(Helper::loggerCategory, __VA_ARGS__)\n\n#ifdef dCInfo\n#undef dCInfo\n#endif\n#define dCInfo(format, ...) { \\\n    QString __m = __d_asprintf__(format, ##__VA_ARGS__); \\\n    __m.prepend(\"\\033[33m\"); __m.append(\"\\033[0m\"); \\\n    qCInfo(Helper::loggerCategory, qPrintable(__m));}\n\n#ifdef dCWarning\n#undef dCWarning\n#endif\n#define dCWarning(format, ...) { \\\n    QString __m = __d_asprintf__(format, ##__VA_ARGS__); \\\n    __m.prepend(\"\\033[30;41m\"); __m.append(\"\\033[0m\"); \\\n    Helper::instance()->warning(__m); \\\n    qCWarning(Helper::loggerCategory, qPrintable(__m));}\n\n#ifdef dCError\n#undef dCError\n#endif\n#define dCError(format, ...) { \\\n    QString __m = __d_asprintf__(format, ##__VA_ARGS__); \\\n    __m.prepend(\"\\033[30;45m\"); __m.append(\"\\033[0m\"); \\\n    Helper::instance()->warning(__m); \\\n    qCCritical(Helper::loggerCategory, qPrintable(__m));}\n\nnamespace ThreadUtil {\ntemplate <typename ReturnType>\nclass _TMP\n{\npublic:\n    template <typename Fun, typename... Args>\n    static ReturnType runInNewThread(Fun fun, Args&&... args)\n    {\n        QFutureWatcher<ReturnType> watcher;\n        QEventLoop loop;\n\n        QObject::connect(&watcher, &QFutureWatcherBase::finished, &loop, &QEventLoop::quit);\n        watcher.setFuture(QtConcurrent::run(fun, std::forward<Args>(args)...));\n\n        loop.exec();\n\n        return watcher.result();\n    }\n};\n\ntemplate <typename Fun, typename... Args>\nauto runInNewThread(Fun fun, Args&&... args) -> decltype(fun(args...))\n{\n    return _TMP<decltype(fun(args...))>::runInNewThread(fun, std::forward<Args>(args)...);\n}\ntemplate <typename Fun, typename... Args>\ntypename QtPrivate::FunctionPointer<Fun>::ReturnType runInNewThread(typename QtPrivate::FunctionPointer<Fun>::Object *obj, Fun fun, Args&&... args)\n{\n    return _TMP<typename QtPrivate::FunctionPointer<Fun>::ReturnType>::runInNewThread([&] {\n        return (obj->*fun)(std::forward<Args>(args)...);\n    });\n}\n\n}\n\n#endif // HELPER_H\n", "/*\n * Copyright (C) 2017 ~ 2017 Deepin Technology Co., Ltd.\n *\n * Author:     zccrs <zccrs@live.com>\n *\n * Maintainer: zccrs <zhangjide@deepin.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include \"bootdoctor.h\"\n#include \"helper.h\"\n#include \"ddevicediskinfo.h\"\n#include \"ddevicepartinfo.h\"\n\nQString BootDoctor::m_lastErrorString;\n\nbool BootDoctor::fix(const QString &partDevice)\n{\n    m_lastErrorString.clear();\n\n    DDevicePartInfo part_info(partDevice);\n    const QString part_old_uuid = part_info.uuid();\n\n    if (Helper::processExec(\"lsblk -s -d -n -o UUID\") == 0) {\n        if (Helper::lastProcessStandardOutput().contains(part_old_uuid.toLatin1())) {\n            // reset uuid\n            if (Helper::resetPartUUID(part_info)) {\n                QThread::sleep(1);\n                part_info.refresh();\n\n                qDebug() << part_old_uuid << part_info.uuid();\n            } else {\n                dCWarning(\"Failed to reset uuid\");\n            }\n        }\n    }\n\n    bool device_is_mounted = Helper::isMounted(partDevice);\n    const QString &mount_root = Helper::temporaryMountDevice(partDevice, QFileInfo(partDevice).fileName());\n\n    if (mount_root.isEmpty()) {\n        m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(partDevice);\n        goto failed;\n    }\n\n    {\n        const QString tmp_dir = \"/var/cache/deepin-clone\";\n\n        if (!QDir::current().mkpath(tmp_dir)) {\n            dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(tmp_dir));\n            goto failed;\n        }\n\n        const QString &repo_path = tmp_dir + \"/repo.iso\";\n\n        if (!QFile::exists(repo_path)\n                && !QFile::copy(QString(\":/repo_%1.iso\").arg(HOST_ARCH), repo_path)) {\n            dCError(\"copy file failed, new name: %s\", qPrintable(repo_path));\n            goto failed;\n        }\n\n        bool ok = false;\n\n        const QString &repo_mount_point = mount_root + \"/deepin-clone\";\n        QFile file_boot_fix(mount_root + \"/boot_fix.sh\");\n\n        do {\n            if (!QDir(mount_root).exists(\"deepin-clone\") && !QDir(mount_root).mkdir(\"deepin-clone\")) {\n                dCError(\"Create \\\"deepin-clone\\\" dir failed(\\\"%s\\\")\", qPrintable(mount_root));\n                break;\n            }\n\n            if (!Helper::mountDevice(repo_path, repo_mount_point, true)) {\n                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(repo_path);\n                break;\n            }\n\n            if (file_boot_fix.exists()) {\n                file_boot_fix.remove();\n            }\n\n            if (!QFile::copy(QString(\":/scripts/boot_fix_%1.sh\").arg(\n                     #if defined(HOST_ARCH_x86_64) || defined(HOST_ARCH_i386) || defined(HOST_ARCH_i686)\n                                 \"x86\"\n                     #elif defined(HOST_ARCH_mips64) || defined(HOST_ARCH_mips32)\n                                 \"mips\"\n                     #elif defined(HOST_ARCH_sw_64)\n                                 \"sw_64\"\n                     #elif defined(HOST_ARCH_aarch64)\n                                 \"aarch64\"\n                     #else\n                     #pragma message \"Machine: \" HOST_ARCH\n                                \"unknow\"\n                     #endif\n                                 ), file_boot_fix.fileName())) {\n                dCError(\"copy file failed, new name: %s\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (!file_boot_fix.setPermissions(file_boot_fix.permissions() | QFile::ExeUser)) {\n                dCError(\"Set \\\"%s\\\" permissions failed\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev %1/dev\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev/pts %1/dev/pts\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev/pts\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /proc %1/proc\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /proc\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /sys %1/sys\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /sys\");\n                break;\n            }\n\n            ok = true;\n        } while (0);\n\n        QProcess process;\n\n        if (ok) {\n            const QString &parent_device = Helper::parentDevice(partDevice);\n\n            bool is_efi = false;\n\n            if (!parent_device.isEmpty()) {\n                DDeviceDiskInfo info(parent_device);\n\n                dCDebug(\"Disk partition table type: %d\", info.ptType());\n\n                if (info.ptType() == DDeviceDiskInfo::GPT) {\n                    for (const DPartInfo &part : info.childrenPartList()) {\n                        if (part.guidType() == DPartInfo::EFI_SP_None) {\n                            const QString &efi_path = mount_root + \"/boot/efi\";\n\n                            QDir::current().mkpath(efi_path);\n\n                            if (Helper::processExec(QString(\"mount %1 %2\").arg(part.filePath()).arg(efi_path)) != 0) {\n                                dCError(\"Failed to mount EFI partition\");\n                                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(part.filePath());\n                                ok = false;\n                                break;\n                            }\n\n                            is_efi = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!is_efi && m_lastErrorString.isEmpty()) {\n                        m_lastErrorString = QObject::tr(\"EFI partition not found\");\n                        ok = false;\n                    }\n                } else if (info.ptType() == DDeviceDiskInfo::Unknow) {\n                    m_lastErrorString = QObject::tr(\"Unknown partition style\");\n                    ok = false;\n                }\n            }\n\n            if (ok) {\n                process.setProcessChannelMode(QProcess::MergedChannels);\n                process.start(QString(\"chroot %1 ./boot_fix.sh %2 %3 /deepin-clone\")\n                              .arg(mount_root)\n                              .arg(parent_device)\n                              .arg(is_efi ? \"true\" : \"false\"));\n\n                while (process.waitForReadyRead()) {\n                    const QByteArray &data = process.readAll().simplified().constData();\n\n                    dCDebug(data.constData());\n                }\n\n                process.waitForFinished(-1);\n\n                switch (process.exitCode()) {\n                case 1:\n                    m_lastErrorString = QObject::tr(\"Boot for install system failed\");\n                    break;\n                case 2:\n                    m_lastErrorString = QObject::tr(\"Boot for update system failed\");\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n\n        // clear\n        Helper::processExec(\"umount \" + repo_mount_point);\n        QDir(mount_root).rmdir(\"deepin-clone\");\n        file_boot_fix.remove();\n        Helper::processExec(\"umount \" + mount_root + \"/dev/pts\");\n        Helper::processExec(\"umount \" + mount_root + \"/dev\");\n        Helper::processExec(\"umount \" + mount_root + \"/proc\");\n        Helper::processExec(\"umount \" + mount_root + \"/sys\");\n        Helper::processExec(\"umount \" + mount_root + \"/boot/efi\");\n\n        if (ok && process.exitCode() == 0) {\n            if (part_old_uuid != part_info.uuid()) {\n                dCDebug(\"Reset the uuid from \\\"%s\\\" to \\\"%s\\\"\", qPrintable(part_old_uuid), qPrintable(part_info.uuid()));\n\n                // update /etc/fstab\n                QFile file(mount_root + \"/etc/fstab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/fstab, error: %s\", qPrintable(file.errorString()));\n                }\n\n                file.setFileName(mount_root + \"/etc/crypttab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/crypttab, error: %s\", qPrintable(file.errorString()));\n                }\n            }\n\n            if (!device_is_mounted)\n                Helper::umountDevice(partDevice);\n\n            return true;\n        }\n    }\n\nfailed:\n    if (!device_is_mounted)\n        Helper::umountDevice(partDevice);\n\n    if (m_lastErrorString.isEmpty())\n        m_lastErrorString = QObject::tr(\"Boot for repair system failed\");\n\n    dCDebug(\"Restore partition uuid\");\n\n    if (!Helper::resetPartUUID(part_info, part_old_uuid.toLatin1())) {\n        dCWarning(\"Failed to restore partition uuid, part: %s, uuid: %s\", qPrintable(partDevice), qPrintable(part_old_uuid));\n    }\n\n    return false;\n}\n\nQString BootDoctor::errorString()\n{\n    return m_lastErrorString;\n}\n", "/*\n * Copyright (C) 2017 ~ 2017 Deepin Technology Co., Ltd.\n *\n * Author:     zccrs <zccrs@live.com>\n *\n * Maintainer: zccrs <zhangjide@deepin.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <QDebug>\n#include <DLog>\n\n#ifdef ENABLE_GUI\n#include <DApplication>\n#include <DTitlebar>\n#include <DThemeManager>\n\n#include <QDesktopServices>\n\n#include \"mainwindow.h\"\n#include \"dvirtualimagefileio.h\"\n\n#include <pwd.h>\n#include <unistd.h>\n\nDWIDGET_USE_NAMESPACE\n#else\n#include <QCoreApplication>\n#endif\n\n#include \"helper.h\"\n#include \"dglobal.h\"\n#include \"clonejob.h\"\n#include \"commandlineparser.h\"\n\nbool Global::isOverride = true;\nbool Global::disableMD5CheckForDimFile = false;\nbool Global::disableLoopDevice = true;\nbool Global::fixBoot = false;\n#ifdef ENABLE_GUI\nbool Global::isTUIMode = false;\n#else\nbool Global::isTUIMode = true;\n#endif\n\nint Global::bufferSize = 1024 * 1024;\nint Global::compressionLevel = 0;\nint Global::debugLevel = 1;\n\nDCORE_USE_NAMESPACE\n\ninline static bool isTUIMode(int argc, char *argv[])\n{\n#ifndef ENABLE_GUI\n    Q_UNUSED(argc)\n    Q_UNUSED(argv)\n\n    return true;\n#endif\n\n    if (qEnvironmentVariableIsEmpty(\"DISPLAY\"))\n        return true;\n\n    const QByteArrayList in_tui_args = {\n        \"--tui\", \"-i\", \"--info\", \"--dim-info\", \"--to-serial-url\",\n        \"--from-serial-url\", \"-f\", \"--fix-boot\", \"-v\", \"--version\",\n        \"-h\", \"--help\", \"--re-checksum\"\n    };\n\n    for (int i = 1; i < argc; ++i)\n        if (in_tui_args.contains(argv[i]))\n            return true;\n\n    return false;\n}\n\nstatic QString logFormat = \"[%{time}{yyyy-MM-dd, HH:mm:ss.zzz}] [%{type:-7}] [%{file}=>%{function}: %{line}] %{message}\\n\";\n\nint main(int argc, char *argv[])\n{\n    QCoreApplication *a;\n\n    if (isTUIMode(argc, argv)) {\n        Global::isTUIMode = true;\n\n        a = new QCoreApplication(argc, argv);\n    }\n#ifdef ENABLE_GUI\n    else {\n        ConsoleAppender *consoleAppender = new ConsoleAppender;\n        consoleAppender->setFormat(logFormat);\n\n        const QString log_file(\"/var/log/deepin-clone.log\");\n\n        RollingFileAppender *rollingFileAppender = new RollingFileAppender(log_file);\n        rollingFileAppender->setFormat(logFormat);\n        rollingFileAppender->setLogFilesLimit(5);\n        rollingFileAppender->setDatePattern(RollingFileAppender::DailyRollover);\n\n        logger->registerAppender(rollingFileAppender);\n        logger->registerAppender(consoleAppender);\n\n        if (qEnvironmentVariableIsSet(\"PKEXEC_UID\")) {\n            const quint32 pkexec_uid = qgetenv(\"PKEXEC_UID\").toUInt();\n\n            DApplication::customQtThemeConfigPathByUserHome(getpwuid(pkexec_uid)->pw_dir);\n        }\n\n        DApplication::loadDXcbPlugin();\n        DApplication *app = new DApplication(argc, argv);\n\n        app->setAttribute(Qt::AA_UseHighDpiPixmaps);\n\n        if (!qApp->setSingleInstance(\"_deepin_clone_\")) {\n            qCritical() << \"As well as the process is running\";\n\n            return -1;\n        }\n\n        if (!app->loadTranslator()) {\n            dError(\"Load translator failed\");\n        }\n\n        app->setApplicationDisplayName(QObject::tr(\"Deepin Clone\"));\n        app->setApplicationDescription(QObject::tr(\"Deepin Clone is a backup and restore tool in deepin. \"\n                                                   \"It supports disk or partition clone, backup and restore, and other functions.\"));\n        app->setApplicationAcknowledgementPage(\"https://www.deepin.org/acknowledgments/deepin-clone/\");\n        app->setTheme(\"light\");\n        a = app;\n    }\n#endif\n\n    a->setApplicationName(\"deepin-clone\");\n#ifdef ENABLE_GUI\n    a->setApplicationVersion(DApplication::buildVersion(\"1.0.0.1\"));\n#else\n    a->setApplicationVersion(\"1.0.0.1\");\n#endif\n    a->setOrganizationName(\"deepin\");\n\n    CommandLineParser parser;\n\n    QFile arguments_file(\"/lib/live/mount/medium/.tmp/deepin-clone.arguments\");\n    QStringList arguments;\n\n    bool load_arg_from_file = arguments_file.exists() && !Global::isTUIMode && !a->arguments().contains(\"--tui\");\n\n    if (load_arg_from_file) {\n        arguments.append(a->arguments().first());\n\n        if (!arguments_file.open(QIODevice::ReadOnly)) {\n            qCritical() << \"Open \\\"/lib/live/mount/medium/.tmp/deepin-clone.arguments\\\" failed, error:\" << arguments_file.errorString();\n        } else {\n            while (!arguments_file.atEnd()) {\n                const QString &arg = QString::fromUtf8(arguments_file.readLine().trimmed());\n\n                if (!arg.isEmpty())\n                    arguments.append(arg);\n            }\n\n            arguments_file.close();\n            arguments_file.remove();\n        }\n\n        qDebug() << arguments;\n    } else {\n        arguments = a->arguments();\n    }\n\n    parser.process(arguments);\n\n    ConsoleAppender *consoleAppender = new ConsoleAppender;\n    consoleAppender->setFormat(logFormat);\n\n    RollingFileAppender *rollingFileAppender = new RollingFileAppender(parser.logFile());\n    rollingFileAppender->setFormat(logFormat);\n    rollingFileAppender->setLogFilesLimit(5);\n    rollingFileAppender->setDatePattern(RollingFileAppender::DailyRollover);\n\n    logger->registerCategoryAppender(\"deepin.ghost\", consoleAppender);\n    logger->registerCategoryAppender(\"deepin.ghost\", rollingFileAppender);\n\n    parser.parse();\n\n    if (load_arg_from_file) {\n        dCDebug(\"Load arguments from \\\"%s\\\"\", qPrintable(arguments_file.fileName()));\n    }\n\n    dCInfo(\"Application command line: %s\", qPrintable(arguments.join(' ')));\n\n    if (Global::debugLevel == 0) {\n        QLoggingCategory::setFilterRules(\"deepin.ghost.debug=false\");\n    }\n\n    if (Global::isTUIMode) {\n        if (!parser.target().isEmpty()) {\n            CloneJob *job = new CloneJob;\n\n            QObject::connect(job, &QThread::finished, a, &QCoreApplication::quit);\n\n            job->start(parser.source(), parser.target());\n        }\n    }\n#ifdef ENABLE_GUI\n    else {\n        if (!parser.isSetOverride())\n            Global::isOverride = true;\n\n        if (!parser.isSetDebug())\n            Global::debugLevel = 2;\n\n        MainWindow *window = new MainWindow;\n\n        window->setFixedSize(860, 660);\n        window->setStyleSheet(DThemeManager::instance()->getQssForWidget(\"main\", window));\n        window->setWindowIcon(QIcon::fromTheme(\"deepin-clone\"));\n        window->setWindowFlags(Qt::WindowCloseButtonHint | Qt::WindowMinimizeButtonHint | Qt::WindowSystemMenuHint);\n        window->titlebar()->setIcon(window->windowIcon());\n        window->titlebar()->setTitle(QString());\n#if DTK_VERSION > DTK_VERSION_CHECK(2, 0, 6, 0)\n        window->titlebar()->setBackgroundTransparent(true);\n#endif\n        window->show();\n\n        qApp->setProductIcon(window->windowIcon());\n\n        if (!parser.source().isEmpty()) {\n            window->startWithFile(parser.source(), parser.target());\n        }\n\n        QObject::connect(a, &QCoreApplication::aboutToQuit, window, &MainWindow::deleteLater);\n        QDesktopServices::setUrlHandler(\"https\", window, \"openUrl\");\n    }\n#endif\n\n    int exitCode = Global::isTUIMode ? a->exec() : qApp->exec();\n    QString log_backup_file = parser.logBackupFile();\n\n    if (log_backup_file.startsWith(\"serial://\")) {\n        log_backup_file = Helper::parseSerialUrl(log_backup_file);\n    }\n\n    if (log_backup_file.isEmpty()) {\n        return exitCode;\n    }\n\n    if (!QFile::copy(parser.logFile(), log_backup_file)) {\n        dCWarning(\"failed to copy log file to \\\"%s\\\"\", qPrintable(log_backup_file));\n    }\n\n    return exitCode;\n}\n"], "buggy_code_start_loc": [306, 102, 101, 58, 105], "buggy_code_end_loc": [309, 507, 101, 60, 135], "fixing_code_start_loc": [306, 103, 102, 58, 105], "fixing_code_end_loc": [309, 509, 104, 59, 119], "type": "CWE-59", "message": "deepin-clone before 1.1.3 uses a fixed path /tmp/repo.iso in the BootDoctor::fix() function to download an ISO file, and follows symlinks there. An unprivileged user can prepare a symlink attack there to create or overwrite files in arbitrary file system locations. The content is not attacker controlled. By winning a race condition to replace the /tmp/repo.iso symlink by an attacker controlled ISO file, further privilege escalation may be possible.", "other": {"cve": {"id": "CVE-2019-13228", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-04T12:15:10.597", "lastModified": "2019-07-28T03:15:10.807", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "deepin-clone before 1.1.3 uses a fixed path /tmp/repo.iso in the BootDoctor::fix() function to download an ISO file, and follows symlinks there. An unprivileged user can prepare a symlink attack there to create or overwrite files in arbitrary file system locations. The content is not attacker controlled. By winning a race condition to replace the /tmp/repo.iso symlink by an attacker controlled ISO file, further privilege escalation may be possible."}, {"lang": "es", "value": "deepin-clone anterior a versi\u00f3n 1.1.3, utiliza una ruta (path) fija /tmp/repo.iso en la funci\u00f3n BootDoctor::fix() para descargar un archivo ISO, y sigue ah\u00ed los enlaces simb\u00f3licos (symlinks). Un usuario sin privilegios puede preparar en esta ubicaci\u00f3n un ataque de enlace simb\u00f3lico para crear o sobrescribir archivos en ubicaciones del sistema de archivos arbitrarias. El contenido no es controlado por el atacante. Al ganar una condici\u00f3n de carrera para reemplazar el enlace simb\u00f3lico /tmp/repo.iso mediante un archivo ISO controlado por un atacante, puede ser posible una escalada de privilegios mayor ."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 9.5, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:deepin:deepin-clone:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.3", "matchCriteriaId": "A0642A7D-0FB8-459D-8C64-A29F65AE6CAC"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2019/07/04/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1130388", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/linuxdeepin/deepin-clone/commit/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TCHGRJV5CWTMYEE5B5C2FNMCFVP45S7H/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/linuxdeepin/deepin-clone/commit/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab"}}