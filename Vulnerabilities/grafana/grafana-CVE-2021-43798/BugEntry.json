{"buggy_code": ["package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/infra/fs\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/plugins/backendplugin\"\n\t\"github.com/grafana/grafana/pkg/plugins/manager/installer\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nfunc (hs *HTTPServer) GetPluginList(c *models.ReqContext) response.Response {\n\ttypeFilter := c.Query(\"type\")\n\tenabledFilter := c.Query(\"enabled\")\n\tembeddedFilter := c.Query(\"embedded\")\n\tcoreFilter := c.Query(\"core\")\n\n\t// For users with viewer role we only return core plugins\n\tif !c.HasRole(models.ROLE_ADMIN) {\n\t\tcoreFilter = \"1\"\n\t}\n\n\tpluginSettingsMap, err := hs.pluginSettings(c.Req.Context(), c.OrgId)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get list of plugins\", err)\n\t}\n\n\tresult := make(dtos.PluginList, 0)\n\tfor _, pluginDef := range hs.pluginStore.Plugins(c.Req.Context()) {\n\t\t// filter out app sub plugins\n\t\tif embeddedFilter == \"0\" && pluginDef.IncludedInAppID != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out core plugins\n\t\tif (coreFilter == \"0\" && pluginDef.IsCorePlugin()) || (coreFilter == \"1\" && !pluginDef.IsCorePlugin()) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter on type\n\t\tif typeFilter != \"\" && typeFilter != string(pluginDef.Type) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif pluginDef.State == plugins.AlphaRelease && !hs.Cfg.PluginsEnableAlpha {\n\t\t\tcontinue\n\t\t}\n\n\t\tlistItem := dtos.PluginListItem{\n\t\t\tId:            pluginDef.ID,\n\t\t\tName:          pluginDef.Name,\n\t\t\tType:          string(pluginDef.Type),\n\t\t\tCategory:      pluginDef.Category,\n\t\t\tInfo:          pluginDef.Info,\n\t\t\tDependencies:  pluginDef.Dependencies,\n\t\t\tLatestVersion: pluginDef.GrafanaComVersion,\n\t\t\tHasUpdate:     pluginDef.GrafanaComHasUpdate,\n\t\t\tDefaultNavUrl: pluginDef.DefaultNavURL,\n\t\t\tState:         pluginDef.State,\n\t\t\tSignature:     pluginDef.Signature,\n\t\t\tSignatureType: pluginDef.SignatureType,\n\t\t\tSignatureOrg:  pluginDef.SignatureOrg,\n\t\t}\n\n\t\tif pluginSetting, exists := pluginSettingsMap[pluginDef.ID]; exists {\n\t\t\tlistItem.Enabled = pluginSetting.Enabled\n\t\t\tlistItem.Pinned = pluginSetting.Pinned\n\t\t}\n\n\t\tif listItem.DefaultNavUrl == \"\" || !listItem.Enabled {\n\t\t\tlistItem.DefaultNavUrl = hs.Cfg.AppSubURL + \"/plugins/\" + listItem.Id + \"/\"\n\t\t}\n\n\t\t// filter out disabled plugins\n\t\tif enabledFilter == \"1\" && !listItem.Enabled {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out built in plugins\n\t\tif pluginDef.BuiltIn {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult = append(result, listItem)\n\t}\n\n\tsort.Sort(result)\n\treturn response.JSON(200, result)\n}\n\nfunc (hs *HTTPServer) GetPluginSettingByID(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\treturn response.Error(404, \"Plugin not found, no installed plugin with that id\", nil)\n\t}\n\n\tdto := &dtos.PluginSetting{\n\t\tType:          string(plugin.Type),\n\t\tId:            plugin.ID,\n\t\tName:          plugin.Name,\n\t\tInfo:          plugin.Info,\n\t\tDependencies:  plugin.Dependencies,\n\t\tIncludes:      plugin.Includes,\n\t\tBaseUrl:       plugin.BaseURL,\n\t\tModule:        plugin.Module,\n\t\tDefaultNavUrl: plugin.DefaultNavURL,\n\t\tLatestVersion: plugin.GrafanaComVersion,\n\t\tHasUpdate:     plugin.GrafanaComHasUpdate,\n\t\tState:         plugin.State,\n\t\tSignature:     plugin.Signature,\n\t\tSignatureType: plugin.SignatureType,\n\t\tSignatureOrg:  plugin.SignatureOrg,\n\t}\n\n\tif plugin.IsApp() {\n\t\tdto.Enabled = plugin.AutoEnabled\n\t\tdto.Pinned = plugin.AutoEnabled\n\t}\n\n\tquery := models.GetPluginSettingByIdQuery{PluginId: pluginID, OrgId: c.OrgId}\n\tif err := bus.DispatchCtx(c.Req.Context(), &query); err != nil {\n\t\tif !errors.Is(err, models.ErrPluginSettingNotFound) {\n\t\t\treturn response.Error(500, \"Failed to get login settings\", nil)\n\t\t}\n\t} else {\n\t\tdto.Enabled = query.Result.Enabled\n\t\tdto.Pinned = query.Result.Pinned\n\t\tdto.JsonData = query.Result.JsonData\n\t}\n\n\treturn response.JSON(200, dto)\n}\n\nfunc (hs *HTTPServer) UpdatePluginSetting(c *models.ReqContext) response.Response {\n\tcmd := models.UpdatePluginSettingCmd{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tif _, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID); !exists {\n\t\treturn response.Error(404, \"Plugin not installed\", nil)\n\t}\n\n\tcmd.OrgId = c.OrgId\n\tcmd.PluginId = pluginID\n\tif err := bus.DispatchCtx(c.Req.Context(), &cmd); err != nil {\n\t\treturn response.Error(500, \"Failed to update plugin setting\", err)\n\t}\n\n\treturn response.Success(\"Plugin settings updated\")\n}\n\nfunc (hs *HTTPServer) GetPluginDashboards(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tlist, err := hs.pluginDashboardManager.GetPluginDashboards(c.Req.Context(), c.OrgId, pluginID)\n\tif err != nil {\n\t\tvar notFound plugins.NotFoundError\n\t\tif errors.As(err, &notFound) {\n\t\t\treturn response.Error(404, notFound.Error(), nil)\n\t\t}\n\n\t\treturn response.Error(500, \"Failed to get plugin dashboards\", err)\n\t}\n\n\treturn response.JSON(200, list)\n}\n\nfunc (hs *HTTPServer) GetPluginMarkdown(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tname := web.Params(c.Req)[\":name\"]\n\n\tcontent, err := hs.pluginMarkdown(c.Req.Context(), pluginID, name)\n\tif err != nil {\n\t\tvar notFound plugins.NotFoundError\n\t\tif errors.As(err, &notFound) {\n\t\t\treturn response.Error(404, notFound.Error(), nil)\n\t\t}\n\n\t\treturn response.Error(500, \"Could not get markdown file\", err)\n\t}\n\n\t// fallback try readme\n\tif len(content) == 0 {\n\t\tcontent, err = hs.pluginMarkdown(c.Req.Context(), pluginID, \"readme\")\n\t\tif err != nil {\n\t\t\treturn response.Error(501, \"Could not get markdown file\", err)\n\t\t}\n\t}\n\n\tresp := response.Respond(200, content)\n\tresp.SetHeader(\"Content-Type\", \"text/plain; charset=utf-8\")\n\treturn resp\n}\n\nfunc (hs *HTTPServer) ImportDashboard(c *models.ReqContext) response.Response {\n\tapiCmd := dtos.ImportDashboardCommand{}\n\tif err := web.Bind(c.Req, &apiCmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tvar err error\n\tif apiCmd.PluginId == \"\" && apiCmd.Dashboard == nil {\n\t\treturn response.Error(422, \"Dashboard must be set\", nil)\n\t}\n\n\tlimitReached, err := hs.QuotaService.QuotaReached(c, \"dashboard\")\n\tif err != nil {\n\t\treturn response.Error(500, \"failed to get quota\", err)\n\t}\n\tif limitReached {\n\t\treturn response.Error(403, \"Quota reached\", nil)\n\t}\n\n\ttrimDefaults := c.QueryBoolWithDefault(\"trimdefaults\", true)\n\tif trimDefaults && !hs.LoadSchemaService.IsDisabled() {\n\t\tapiCmd.Dashboard, err = hs.LoadSchemaService.DashboardApplyDefaults(apiCmd.Dashboard)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Error while applying default value to the dashboard json\", err)\n\t\t}\n\t}\n\n\tdashInfo, dash, err := hs.pluginDashboardManager.ImportDashboard(c.Req.Context(), apiCmd.PluginId, apiCmd.Path, c.OrgId, apiCmd.FolderId,\n\t\tapiCmd.Dashboard, apiCmd.Overwrite, apiCmd.Inputs, c.SignedInUser)\n\tif err != nil {\n\t\treturn hs.dashboardSaveErrorToApiResponse(c.Req.Context(), err)\n\t}\n\n\terr = hs.LibraryPanelService.ImportLibraryPanelsForDashboard(c.Req.Context(), c.SignedInUser, dash, apiCmd.FolderId)\n\tif err != nil {\n\t\treturn response.Error(500, \"Error while importing library panels\", err)\n\t}\n\n\terr = hs.LibraryPanelService.ConnectLibraryPanelsForDashboard(c.Req.Context(), c.SignedInUser, dash)\n\tif err != nil {\n\t\treturn response.Error(500, \"Error while connecting library panels\", err)\n\t}\n\n\treturn response.JSON(200, dashInfo)\n}\n\n// CollectPluginMetrics collect metrics from a plugin.\n//\n// /api/plugins/:pluginId/metrics\nfunc (hs *HTTPServer) CollectPluginMetrics(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\treturn response.Error(404, \"Plugin not found\", nil)\n\t}\n\n\tresp, err := hs.pluginClient.CollectMetrics(c.Req.Context(), plugin.ID)\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\theaders := make(http.Header)\n\theaders.Set(\"Content-Type\", \"text/plain\")\n\n\treturn response.CreateNormalResponse(headers, resp.PrometheusMetrics, http.StatusOK)\n}\n\n// getPluginAssets returns public plugin assets (images, JS, etc.)\n//\n// /public/plugins/:pluginId/*\nfunc (hs *HTTPServer) getPluginAssets(c *models.ReqContext) {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\trequestedFile := filepath.Clean(web.Params(c.Req)[\"*\"])\n\tpluginFilePath := filepath.Join(plugin.PluginDir, requestedFile)\n\n\tif !plugin.IncludedInSignature(requestedFile) {\n\t\ths.log.Warn(\"Access to requested plugin file will be forbidden in upcoming Grafana versions as the file \"+\n\t\t\t\"is not included in the plugin signature\", \"file\", requestedFile)\n\t}\n\n\t// It's safe to ignore gosec warning G304 since we already clean the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\t// nolint:gosec\n\tf, err := os.Open(pluginFilePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tc.JsonApiErr(404, \"Plugin file not found\", err)\n\t\t\treturn\n\t\t}\n\t\tc.JsonApiErr(500, \"Could not open plugin file\", err)\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif err := f.Close(); err != nil {\n\t\t\ths.log.Error(\"Failed to close file\", \"err\", err)\n\t\t}\n\t}()\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Plugin file exists but could not open\", err)\n\t\treturn\n\t}\n\n\tif hs.Cfg.Env == setting.Dev {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"max-age=0, must-revalidate, no-cache\")\n\t} else {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"public, max-age=3600\")\n\t}\n\n\thttp.ServeContent(c.Resp, c.Req, pluginFilePath, fi.ModTime(), f)\n}\n\n// CheckHealth returns the health of a plugin.\n// /api/plugins/:pluginId/health\nfunc (hs *HTTPServer) CheckHealth(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, \"\", c.SignedInUser, false)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get plugin settings\", err)\n\t}\n\tif !found {\n\t\treturn response.Error(404, \"Plugin not found\", nil)\n\t}\n\n\tresp, err := hs.pluginClient.CheckHealth(c.Req.Context(), &backend.CheckHealthRequest{\n\t\tPluginContext: pCtx,\n\t})\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\tpayload := map[string]interface{}{\n\t\t\"status\":  resp.Status.String(),\n\t\t\"message\": resp.Message,\n\t}\n\n\t// Unmarshal JSONDetails if it's not empty.\n\tif len(resp.JSONDetails) > 0 {\n\t\tvar jsonDetails map[string]interface{}\n\t\terr = json.Unmarshal(resp.JSONDetails, &jsonDetails)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to unmarshal detailed response from backend plugin\", err)\n\t\t}\n\n\t\tpayload[\"details\"] = jsonDetails\n\t}\n\n\tif resp.Status != backend.HealthStatusOk {\n\t\treturn response.JSON(503, payload)\n\t}\n\n\treturn response.JSON(200, payload)\n}\n\n// CallResource passes a resource call from a plugin to the backend plugin.\n//\n// /api/plugins/:pluginId/resources/*\nfunc (hs *HTTPServer) CallResource(c *models.ReqContext) {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, \"\", c.SignedInUser, false)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin settings\", err)\n\t\treturn\n\t}\n\tif !found {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\ths.pluginClient.CallResource(pCtx, c, web.Params(c.Req)[\"*\"])\n}\n\nfunc (hs *HTTPServer) GetPluginErrorsList(_ *models.ReqContext) response.Response {\n\treturn response.JSON(200, hs.pluginErrorResolver.PluginErrors())\n}\n\nfunc (hs *HTTPServer) InstallPlugin(c *models.ReqContext) response.Response {\n\tdto := dtos.InstallPluginCommand{}\n\tif err := web.Bind(c.Req, &dto); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginStore.Add(c.Req.Context(), pluginID, dto.Version, plugins.AddOpts{})\n\tif err != nil {\n\t\tvar dupeErr plugins.DuplicateError\n\t\tif errors.As(err, &dupeErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin already installed\", err)\n\t\t}\n\t\tvar versionUnsupportedErr installer.ErrVersionUnsupported\n\t\tif errors.As(err, &versionUnsupportedErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin version not supported\", err)\n\t\t}\n\t\tvar versionNotFoundErr installer.ErrVersionNotFound\n\t\tif errors.As(err, &versionNotFoundErr) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin version not found\", err)\n\t\t}\n\t\tvar clientError installer.Response4xxError\n\t\tif errors.As(err, &clientError) {\n\t\t\treturn response.Error(clientError.StatusCode, clientError.Message, err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrInstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot install or change a Core plugin\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to install plugin\", err)\n\t}\n\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc (hs *HTTPServer) UninstallPlugin(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginStore.Remove(c.Req.Context(), pluginID)\n\tif err != nil {\n\t\tif errors.Is(err, plugins.ErrPluginNotInstalled) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin not installed\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a Core plugin\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallOutsideOfPluginDir) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a plugin outside of the plugins directory\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to uninstall plugin\", err)\n\t}\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc translatePluginRequestErrorToAPIError(err error) response.Response {\n\tif errors.Is(err, backendplugin.ErrPluginNotRegistered) {\n\t\treturn response.Error(404, \"Plugin not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrMethodNotImplemented) {\n\t\treturn response.Error(404, \"Not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrHealthCheckFailed) {\n\t\treturn response.Error(500, \"Plugin health check failed\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrPluginUnavailable) {\n\t\treturn response.Error(503, \"Plugin unavailable\", err)\n\t}\n\n\treturn response.Error(500, \"Plugin request failed\", err)\n}\n\nfunc (hs *HTTPServer) pluginMarkdown(ctx context.Context, pluginId string, name string) ([]byte, error) {\n\tplugin, exists := hs.pluginStore.Plugin(ctx, pluginId)\n\tif !exists {\n\t\treturn nil, plugins.NotFoundError{PluginID: pluginId}\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning on this one because `plugin.PluginDir` is based\n\t// on plugin the folder structure on disk and not user input.\n\tpath := filepath.Join(plugin.PluginDir, fmt.Sprintf(\"%s.md\", strings.ToUpper(name)))\n\texists, err := fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\tpath = filepath.Join(plugin.PluginDir, fmt.Sprintf(\"%s.md\", strings.ToLower(name)))\n\t}\n\n\texists, err = fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn make([]byte, 0), nil\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning on this one because `plugin.PluginDir` is based\n\t// on plugin the folder structure on disk and not user input.\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n", "package api\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n)\n\nfunc Test_GetPluginAssets(t *testing.T) {\n\tpluginID := \"test-plugin\"\n\tpluginDir := \".\"\n\ttmpFile, err := ioutil.TempFile(pluginDir, \"\")\n\trequire.NoError(t, err)\n\tt.Cleanup(func() {\n\t\terr := os.RemoveAll(tmpFile.Name())\n\t\tassert.NoError(t, err)\n\t})\n\texpectedBody := \"Plugin test\"\n\t_, err = tmpFile.WriteString(expectedBody)\n\tassert.NoError(t, err)\n\n\trequestedFile := filepath.Clean(tmpFile.Name())\n\n\tt.Run(\"Given a request for an existing plugin file that is listed as a signature covered file\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t\tSignedFiles: map[string]struct{}{\n\t\t\t\trequestedFile: {},\n\t\t\t},\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\t\t\tassert.Equal(t, expectedBody, sc.resp.Body.String())\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for an existing plugin file that is not listed as a signature covered file\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\t\t\tassert.Equal(t, expectedBody, sc.resp.Body.String())\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for an non-existing plugin file\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\trequestedFile := \"nonExistent\"\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\tvar respJson map[string]interface{}\n\t\t\t\terr := json.NewDecoder(sc.resp.Body).Decode(&respJson)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.Equal(t, 404, sc.resp.Code)\n\t\t\t\tassert.Equal(t, \"Plugin file not found\", respJson[\"message\"])\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for an non-existing plugin\", func(t *testing.T) {\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{},\n\t\t}\n\t\tl := &logger{}\n\n\t\trequestedFile := \"nonExistent\"\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\tvar respJson map[string]interface{}\n\t\t\t\terr := json.NewDecoder(sc.resp.Body).Decode(&respJson)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, 404, sc.resp.Code)\n\t\t\t\tassert.Equal(t, \"Plugin not found\", respJson[\"message\"])\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for a core plugin's file\", func(t *testing.T) {\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: {\n\t\t\t\t\tClass: plugins.Core,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\t\t\tassert.Equal(t, expectedBody, sc.resp.Body.String())\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n}\n\nfunc callGetPluginAsset(sc *scenarioContext) {\n\tsc.fakeReqWithParams(\"GET\", sc.url, map[string]string{}).exec()\n}\n\nfunc pluginAssetScenario(t *testing.T, desc string, url string, urlPattern string, pluginStore plugins.Store,\n\tlogger log.Logger, fn scenarioFunc) {\n\tt.Run(fmt.Sprintf(\"%s %s\", desc, url), func(t *testing.T) {\n\t\tdefer bus.ClearBusHandlers()\n\n\t\ths := HTTPServer{\n\t\t\tCfg:         setting.NewCfg(),\n\t\t\tpluginStore: pluginStore,\n\t\t\tlog:         logger,\n\t\t}\n\n\t\tsc := setupScenarioContext(t, url)\n\t\tsc.defaultHandler = func(c *models.ReqContext) {\n\t\t\tsc.context = c\n\t\t\ths.getPluginAssets(c)\n\t\t}\n\n\t\tsc.m.Get(urlPattern, sc.defaultHandler)\n\n\t\tfn(sc)\n\t})\n}\n\ntype logger struct {\n\tlog.Logger\n\n\twarnings []string\n}\n\nfunc (l *logger) Warn(msg string, ctx ...interface{}) {\n\tl.warnings = append(l.warnings, msg)\n}\n"], "fixing_code": ["package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/infra/fs\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/plugins/backendplugin\"\n\t\"github.com/grafana/grafana/pkg/plugins/manager/installer\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nfunc (hs *HTTPServer) GetPluginList(c *models.ReqContext) response.Response {\n\ttypeFilter := c.Query(\"type\")\n\tenabledFilter := c.Query(\"enabled\")\n\tembeddedFilter := c.Query(\"embedded\")\n\tcoreFilter := c.Query(\"core\")\n\n\t// For users with viewer role we only return core plugins\n\tif !c.HasRole(models.ROLE_ADMIN) {\n\t\tcoreFilter = \"1\"\n\t}\n\n\tpluginSettingsMap, err := hs.pluginSettings(c.Req.Context(), c.OrgId)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get list of plugins\", err)\n\t}\n\n\tresult := make(dtos.PluginList, 0)\n\tfor _, pluginDef := range hs.pluginStore.Plugins(c.Req.Context()) {\n\t\t// filter out app sub plugins\n\t\tif embeddedFilter == \"0\" && pluginDef.IncludedInAppID != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out core plugins\n\t\tif (coreFilter == \"0\" && pluginDef.IsCorePlugin()) || (coreFilter == \"1\" && !pluginDef.IsCorePlugin()) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter on type\n\t\tif typeFilter != \"\" && typeFilter != string(pluginDef.Type) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif pluginDef.State == plugins.AlphaRelease && !hs.Cfg.PluginsEnableAlpha {\n\t\t\tcontinue\n\t\t}\n\n\t\tlistItem := dtos.PluginListItem{\n\t\t\tId:            pluginDef.ID,\n\t\t\tName:          pluginDef.Name,\n\t\t\tType:          string(pluginDef.Type),\n\t\t\tCategory:      pluginDef.Category,\n\t\t\tInfo:          pluginDef.Info,\n\t\t\tDependencies:  pluginDef.Dependencies,\n\t\t\tLatestVersion: pluginDef.GrafanaComVersion,\n\t\t\tHasUpdate:     pluginDef.GrafanaComHasUpdate,\n\t\t\tDefaultNavUrl: pluginDef.DefaultNavURL,\n\t\t\tState:         pluginDef.State,\n\t\t\tSignature:     pluginDef.Signature,\n\t\t\tSignatureType: pluginDef.SignatureType,\n\t\t\tSignatureOrg:  pluginDef.SignatureOrg,\n\t\t}\n\n\t\tif pluginSetting, exists := pluginSettingsMap[pluginDef.ID]; exists {\n\t\t\tlistItem.Enabled = pluginSetting.Enabled\n\t\t\tlistItem.Pinned = pluginSetting.Pinned\n\t\t}\n\n\t\tif listItem.DefaultNavUrl == \"\" || !listItem.Enabled {\n\t\t\tlistItem.DefaultNavUrl = hs.Cfg.AppSubURL + \"/plugins/\" + listItem.Id + \"/\"\n\t\t}\n\n\t\t// filter out disabled plugins\n\t\tif enabledFilter == \"1\" && !listItem.Enabled {\n\t\t\tcontinue\n\t\t}\n\n\t\t// filter out built in plugins\n\t\tif pluginDef.BuiltIn {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult = append(result, listItem)\n\t}\n\n\tsort.Sort(result)\n\treturn response.JSON(200, result)\n}\n\nfunc (hs *HTTPServer) GetPluginSettingByID(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\treturn response.Error(404, \"Plugin not found, no installed plugin with that id\", nil)\n\t}\n\n\tdto := &dtos.PluginSetting{\n\t\tType:          string(plugin.Type),\n\t\tId:            plugin.ID,\n\t\tName:          plugin.Name,\n\t\tInfo:          plugin.Info,\n\t\tDependencies:  plugin.Dependencies,\n\t\tIncludes:      plugin.Includes,\n\t\tBaseUrl:       plugin.BaseURL,\n\t\tModule:        plugin.Module,\n\t\tDefaultNavUrl: plugin.DefaultNavURL,\n\t\tLatestVersion: plugin.GrafanaComVersion,\n\t\tHasUpdate:     plugin.GrafanaComHasUpdate,\n\t\tState:         plugin.State,\n\t\tSignature:     plugin.Signature,\n\t\tSignatureType: plugin.SignatureType,\n\t\tSignatureOrg:  plugin.SignatureOrg,\n\t}\n\n\tif plugin.IsApp() {\n\t\tdto.Enabled = plugin.AutoEnabled\n\t\tdto.Pinned = plugin.AutoEnabled\n\t}\n\n\tquery := models.GetPluginSettingByIdQuery{PluginId: pluginID, OrgId: c.OrgId}\n\tif err := bus.DispatchCtx(c.Req.Context(), &query); err != nil {\n\t\tif !errors.Is(err, models.ErrPluginSettingNotFound) {\n\t\t\treturn response.Error(500, \"Failed to get login settings\", nil)\n\t\t}\n\t} else {\n\t\tdto.Enabled = query.Result.Enabled\n\t\tdto.Pinned = query.Result.Pinned\n\t\tdto.JsonData = query.Result.JsonData\n\t}\n\n\treturn response.JSON(200, dto)\n}\n\nfunc (hs *HTTPServer) UpdatePluginSetting(c *models.ReqContext) response.Response {\n\tcmd := models.UpdatePluginSettingCmd{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tif _, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID); !exists {\n\t\treturn response.Error(404, \"Plugin not installed\", nil)\n\t}\n\n\tcmd.OrgId = c.OrgId\n\tcmd.PluginId = pluginID\n\tif err := bus.DispatchCtx(c.Req.Context(), &cmd); err != nil {\n\t\treturn response.Error(500, \"Failed to update plugin setting\", err)\n\t}\n\n\treturn response.Success(\"Plugin settings updated\")\n}\n\nfunc (hs *HTTPServer) GetPluginDashboards(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tlist, err := hs.pluginDashboardManager.GetPluginDashboards(c.Req.Context(), c.OrgId, pluginID)\n\tif err != nil {\n\t\tvar notFound plugins.NotFoundError\n\t\tif errors.As(err, &notFound) {\n\t\t\treturn response.Error(404, notFound.Error(), nil)\n\t\t}\n\n\t\treturn response.Error(500, \"Failed to get plugin dashboards\", err)\n\t}\n\n\treturn response.JSON(200, list)\n}\n\nfunc (hs *HTTPServer) GetPluginMarkdown(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tname := web.Params(c.Req)[\":name\"]\n\n\tcontent, err := hs.pluginMarkdown(c.Req.Context(), pluginID, name)\n\tif err != nil {\n\t\tvar notFound plugins.NotFoundError\n\t\tif errors.As(err, &notFound) {\n\t\t\treturn response.Error(404, notFound.Error(), nil)\n\t\t}\n\n\t\treturn response.Error(500, \"Could not get markdown file\", err)\n\t}\n\n\t// fallback try readme\n\tif len(content) == 0 {\n\t\tcontent, err = hs.pluginMarkdown(c.Req.Context(), pluginID, \"readme\")\n\t\tif err != nil {\n\t\t\treturn response.Error(501, \"Could not get markdown file\", err)\n\t\t}\n\t}\n\n\tresp := response.Respond(200, content)\n\tresp.SetHeader(\"Content-Type\", \"text/plain; charset=utf-8\")\n\treturn resp\n}\n\nfunc (hs *HTTPServer) ImportDashboard(c *models.ReqContext) response.Response {\n\tapiCmd := dtos.ImportDashboardCommand{}\n\tif err := web.Bind(c.Req, &apiCmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tvar err error\n\tif apiCmd.PluginId == \"\" && apiCmd.Dashboard == nil {\n\t\treturn response.Error(422, \"Dashboard must be set\", nil)\n\t}\n\n\tlimitReached, err := hs.QuotaService.QuotaReached(c, \"dashboard\")\n\tif err != nil {\n\t\treturn response.Error(500, \"failed to get quota\", err)\n\t}\n\tif limitReached {\n\t\treturn response.Error(403, \"Quota reached\", nil)\n\t}\n\n\ttrimDefaults := c.QueryBoolWithDefault(\"trimdefaults\", true)\n\tif trimDefaults && !hs.LoadSchemaService.IsDisabled() {\n\t\tapiCmd.Dashboard, err = hs.LoadSchemaService.DashboardApplyDefaults(apiCmd.Dashboard)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Error while applying default value to the dashboard json\", err)\n\t\t}\n\t}\n\n\tdashInfo, dash, err := hs.pluginDashboardManager.ImportDashboard(c.Req.Context(), apiCmd.PluginId, apiCmd.Path, c.OrgId, apiCmd.FolderId,\n\t\tapiCmd.Dashboard, apiCmd.Overwrite, apiCmd.Inputs, c.SignedInUser)\n\tif err != nil {\n\t\treturn hs.dashboardSaveErrorToApiResponse(c.Req.Context(), err)\n\t}\n\n\terr = hs.LibraryPanelService.ImportLibraryPanelsForDashboard(c.Req.Context(), c.SignedInUser, dash, apiCmd.FolderId)\n\tif err != nil {\n\t\treturn response.Error(500, \"Error while importing library panels\", err)\n\t}\n\n\terr = hs.LibraryPanelService.ConnectLibraryPanelsForDashboard(c.Req.Context(), c.SignedInUser, dash)\n\tif err != nil {\n\t\treturn response.Error(500, \"Error while connecting library panels\", err)\n\t}\n\n\treturn response.JSON(200, dashInfo)\n}\n\n// CollectPluginMetrics collect metrics from a plugin.\n//\n// /api/plugins/:pluginId/metrics\nfunc (hs *HTTPServer) CollectPluginMetrics(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\treturn response.Error(404, \"Plugin not found\", nil)\n\t}\n\n\tresp, err := hs.pluginClient.CollectMetrics(c.Req.Context(), plugin.ID)\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\theaders := make(http.Header)\n\theaders.Set(\"Content-Type\", \"text/plain\")\n\n\treturn response.CreateNormalResponse(headers, resp.PrometheusMetrics, http.StatusOK)\n}\n\n// getPluginAssets returns public plugin assets (images, JS, etc.)\n//\n// /public/plugins/:pluginId/*\nfunc (hs *HTTPServer) getPluginAssets(c *models.ReqContext) {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID)\n\tif !exists {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\t// prepend slash for cleaning relative paths\n\trequestedFile := filepath.Clean(filepath.Join(\"/\", web.Params(c.Req)[\"*\"]))\n\trel, err := filepath.Rel(\"/\", requestedFile)\n\tif err != nil {\n\t\t// slash is prepended above therefore this is not expected to fail\n\t\tc.JsonApiErr(500, \"Failed to get the relative path\", err)\n\t\treturn\n\t}\n\n\tif !plugin.IncludedInSignature(rel) {\n\t\ths.log.Warn(\"Access to requested plugin file will be forbidden in upcoming Grafana versions as the file \"+\n\t\t\t\"is not included in the plugin signature\", \"file\", requestedFile)\n\t}\n\n\tabsPluginDir, err := filepath.Abs(plugin.PluginDir)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin absolute path\", nil)\n\t\treturn\n\t}\n\n\tpluginFilePath := filepath.Join(absPluginDir, rel)\n\t// It's safe to ignore gosec warning G304 since we already clean the requested file path and subsequently\n\t// use this with a prefix of the plugin's directory, which is set during plugin loading\n\t// nolint:gosec\n\tf, err := os.Open(pluginFilePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tc.JsonApiErr(404, \"Plugin file not found\", err)\n\t\t\treturn\n\t\t}\n\t\tc.JsonApiErr(500, \"Could not open plugin file\", err)\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif err := f.Close(); err != nil {\n\t\t\ths.log.Error(\"Failed to close file\", \"err\", err)\n\t\t}\n\t}()\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Plugin file exists but could not open\", err)\n\t\treturn\n\t}\n\n\tif hs.Cfg.Env == setting.Dev {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"max-age=0, must-revalidate, no-cache\")\n\t} else {\n\t\tc.Resp.Header().Set(\"Cache-Control\", \"public, max-age=3600\")\n\t}\n\n\thttp.ServeContent(c.Resp, c.Req, pluginFilePath, fi.ModTime(), f)\n}\n\n// CheckHealth returns the health of a plugin.\n// /api/plugins/:pluginId/health\nfunc (hs *HTTPServer) CheckHealth(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, \"\", c.SignedInUser, false)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to get plugin settings\", err)\n\t}\n\tif !found {\n\t\treturn response.Error(404, \"Plugin not found\", nil)\n\t}\n\n\tresp, err := hs.pluginClient.CheckHealth(c.Req.Context(), &backend.CheckHealthRequest{\n\t\tPluginContext: pCtx,\n\t})\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\tpayload := map[string]interface{}{\n\t\t\"status\":  resp.Status.String(),\n\t\t\"message\": resp.Message,\n\t}\n\n\t// Unmarshal JSONDetails if it's not empty.\n\tif len(resp.JSONDetails) > 0 {\n\t\tvar jsonDetails map[string]interface{}\n\t\terr = json.Unmarshal(resp.JSONDetails, &jsonDetails)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to unmarshal detailed response from backend plugin\", err)\n\t\t}\n\n\t\tpayload[\"details\"] = jsonDetails\n\t}\n\n\tif resp.Status != backend.HealthStatusOk {\n\t\treturn response.JSON(503, payload)\n\t}\n\n\treturn response.JSON(200, payload)\n}\n\n// CallResource passes a resource call from a plugin to the backend plugin.\n//\n// /api/plugins/:pluginId/resources/*\nfunc (hs *HTTPServer) CallResource(c *models.ReqContext) {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, \"\", c.SignedInUser, false)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin settings\", err)\n\t\treturn\n\t}\n\tif !found {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\ths.pluginClient.CallResource(pCtx, c, web.Params(c.Req)[\"*\"])\n}\n\nfunc (hs *HTTPServer) GetPluginErrorsList(_ *models.ReqContext) response.Response {\n\treturn response.JSON(200, hs.pluginErrorResolver.PluginErrors())\n}\n\nfunc (hs *HTTPServer) InstallPlugin(c *models.ReqContext) response.Response {\n\tdto := dtos.InstallPluginCommand{}\n\tif err := web.Bind(c.Req, &dto); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginStore.Add(c.Req.Context(), pluginID, dto.Version, plugins.AddOpts{})\n\tif err != nil {\n\t\tvar dupeErr plugins.DuplicateError\n\t\tif errors.As(err, &dupeErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin already installed\", err)\n\t\t}\n\t\tvar versionUnsupportedErr installer.ErrVersionUnsupported\n\t\tif errors.As(err, &versionUnsupportedErr) {\n\t\t\treturn response.Error(http.StatusConflict, \"Plugin version not supported\", err)\n\t\t}\n\t\tvar versionNotFoundErr installer.ErrVersionNotFound\n\t\tif errors.As(err, &versionNotFoundErr) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin version not found\", err)\n\t\t}\n\t\tvar clientError installer.Response4xxError\n\t\tif errors.As(err, &clientError) {\n\t\t\treturn response.Error(clientError.StatusCode, clientError.Message, err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrInstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot install or change a Core plugin\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to install plugin\", err)\n\t}\n\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc (hs *HTTPServer) UninstallPlugin(c *models.ReqContext) response.Response {\n\tpluginID := web.Params(c.Req)[\":pluginId\"]\n\n\terr := hs.pluginStore.Remove(c.Req.Context(), pluginID)\n\tif err != nil {\n\t\tif errors.Is(err, plugins.ErrPluginNotInstalled) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Plugin not installed\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallCorePlugin) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a Core plugin\", err)\n\t\t}\n\t\tif errors.Is(err, plugins.ErrUninstallOutsideOfPluginDir) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Cannot uninstall a plugin outside of the plugins directory\", err)\n\t\t}\n\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to uninstall plugin\", err)\n\t}\n\treturn response.JSON(http.StatusOK, []byte{})\n}\n\nfunc translatePluginRequestErrorToAPIError(err error) response.Response {\n\tif errors.Is(err, backendplugin.ErrPluginNotRegistered) {\n\t\treturn response.Error(404, \"Plugin not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrMethodNotImplemented) {\n\t\treturn response.Error(404, \"Not found\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrHealthCheckFailed) {\n\t\treturn response.Error(500, \"Plugin health check failed\", err)\n\t}\n\n\tif errors.Is(err, backendplugin.ErrPluginUnavailable) {\n\t\treturn response.Error(503, \"Plugin unavailable\", err)\n\t}\n\n\treturn response.Error(500, \"Plugin request failed\", err)\n}\n\nfunc (hs *HTTPServer) pluginMarkdown(ctx context.Context, pluginId string, name string) ([]byte, error) {\n\tplugin, exists := hs.pluginStore.Plugin(ctx, pluginId)\n\tif !exists {\n\t\treturn nil, plugins.NotFoundError{PluginID: pluginId}\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning on this one because `plugin.PluginDir` is based\n\t// on plugin the folder structure on disk and not user input.\n\tpath := filepath.Join(plugin.PluginDir, fmt.Sprintf(\"%s.md\", strings.ToUpper(name)))\n\texists, err := fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\tpath = filepath.Join(plugin.PluginDir, fmt.Sprintf(\"%s.md\", strings.ToLower(name)))\n\t}\n\n\texists, err = fs.Exists(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn make([]byte, 0), nil\n\t}\n\n\t// nolint:gosec\n\t// We can ignore the gosec G304 warning on this one because `plugin.PluginDir` is based\n\t// on plugin the folder structure on disk and not user input.\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n", "package api\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/grafana/grafana/pkg/bus\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n)\n\nfunc Test_GetPluginAssets(t *testing.T) {\n\tpluginID := \"test-plugin\"\n\tpluginDir := \".\"\n\ttmpFile, err := ioutil.TempFile(pluginDir, \"\")\n\trequire.NoError(t, err)\n\ttmpFileInParentDir, err := ioutil.TempFile(\"..\", \"\")\n\trequire.NoError(t, err)\n\tt.Cleanup(func() {\n\t\terr := os.RemoveAll(tmpFile.Name())\n\t\tassert.NoError(t, err)\n\t\terr = os.RemoveAll(tmpFileInParentDir.Name())\n\t\tassert.NoError(t, err)\n\t})\n\texpectedBody := \"Plugin test\"\n\t_, err = tmpFile.WriteString(expectedBody)\n\tassert.NoError(t, err)\n\n\trequestedFile := filepath.Clean(tmpFile.Name())\n\n\tt.Run(\"Given a request for an existing plugin file that is listed as a signature covered file\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t\tSignedFiles: map[string]struct{}{\n\t\t\t\trequestedFile: {},\n\t\t\t},\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\t\t\tassert.Equal(t, expectedBody, sc.resp.Body.String())\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for a relative path\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, tmpFileInParentDir.Name())\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 404, sc.resp.Code)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for an existing plugin file that is not listed as a signature covered file\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\t\t\tassert.Equal(t, expectedBody, sc.resp.Body.String())\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for an non-existing plugin file\", func(t *testing.T) {\n\t\tp := plugins.PluginDTO{\n\t\t\tJSONData: plugins.JSONData{\n\t\t\t\tID: pluginID,\n\t\t\t},\n\t\t\tPluginDir: pluginDir,\n\t\t}\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: p,\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\trequestedFile := \"nonExistent\"\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\tvar respJson map[string]interface{}\n\t\t\t\terr := json.NewDecoder(sc.resp.Body).Decode(&respJson)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.Equal(t, 404, sc.resp.Code)\n\t\t\t\tassert.Equal(t, \"Plugin file not found\", respJson[\"message\"])\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for an non-existing plugin\", func(t *testing.T) {\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{},\n\t\t}\n\t\tl := &logger{}\n\n\t\trequestedFile := \"nonExistent\"\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\tvar respJson map[string]interface{}\n\t\t\t\terr := json.NewDecoder(sc.resp.Body).Decode(&respJson)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, 404, sc.resp.Code)\n\t\t\t\tassert.Equal(t, \"Plugin not found\", respJson[\"message\"])\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n\n\tt.Run(\"Given a request for a core plugin's file\", func(t *testing.T) {\n\t\tservice := &fakePluginStore{\n\t\t\tplugins: map[string]plugins.PluginDTO{\n\t\t\t\tpluginID: {\n\t\t\t\t\tClass: plugins.Core,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tl := &logger{}\n\n\t\turl := fmt.Sprintf(\"/public/plugins/%s/%s\", pluginID, requestedFile)\n\t\tpluginAssetScenario(t, \"When calling GET on\", url, \"/public/plugins/:pluginId/*\", service, l,\n\t\t\tfunc(sc *scenarioContext) {\n\t\t\t\tcallGetPluginAsset(sc)\n\n\t\t\t\trequire.Equal(t, 200, sc.resp.Code)\n\t\t\t\tassert.Equal(t, expectedBody, sc.resp.Body.String())\n\t\t\t\tassert.Empty(t, l.warnings)\n\t\t\t})\n\t})\n}\n\nfunc callGetPluginAsset(sc *scenarioContext) {\n\tsc.fakeReqWithParams(\"GET\", sc.url, map[string]string{}).exec()\n}\n\nfunc pluginAssetScenario(t *testing.T, desc string, url string, urlPattern string, pluginStore plugins.Store,\n\tlogger log.Logger, fn scenarioFunc) {\n\tt.Run(fmt.Sprintf(\"%s %s\", desc, url), func(t *testing.T) {\n\t\tdefer bus.ClearBusHandlers()\n\n\t\ths := HTTPServer{\n\t\t\tCfg:         setting.NewCfg(),\n\t\t\tpluginStore: pluginStore,\n\t\t\tlog:         logger,\n\t\t}\n\n\t\tsc := setupScenarioContext(t, url)\n\t\tsc.defaultHandler = func(c *models.ReqContext) {\n\t\t\tsc.context = c\n\t\t\ths.getPluginAssets(c)\n\t\t}\n\n\t\tsc.m.Get(urlPattern, sc.defaultHandler)\n\n\t\tfn(sc)\n\t})\n}\n\ntype logger struct {\n\tlog.Logger\n\n\twarnings []string\n}\n\nfunc (l *logger) Warn(msg string, ctx ...interface{}) {\n\tl.warnings = append(l.warnings, msg)\n}\n"], "buggy_code_start_loc": [292, 25], "buggy_code_end_loc": [299, 60], "fixing_code_start_loc": [292, 26], "fixing_code_end_loc": [313, 88], "type": "CWE-22", "message": "Grafana is an open-source platform for monitoring and observability. Grafana versions 8.0.0-beta1 through 8.3.0 (except for patched versions) iss vulnerable to directory traversal, allowing access to local files. The vulnerable URL path is: `<grafana_host_url>/public/plugins//`, where is the plugin ID for any installed plugin. At no time has Grafana Cloud been vulnerable. Users are advised to upgrade to patched versions 8.0.7, 8.1.8, 8.2.7, or 8.3.1. The GitHub Security Advisory contains more information about vulnerable URL paths, mitigation, and the disclosure timeline.", "other": {"cve": {"id": "CVE-2021-43798", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-07T19:15:07.633", "lastModified": "2022-04-12T18:06:34.363", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Grafana is an open-source platform for monitoring and observability. Grafana versions 8.0.0-beta1 through 8.3.0 (except for patched versions) iss vulnerable to directory traversal, allowing access to local files. The vulnerable URL path is: `<grafana_host_url>/public/plugins//`, where is the plugin ID for any installed plugin. At no time has Grafana Cloud been vulnerable. Users are advised to upgrade to patched versions 8.0.7, 8.1.8, 8.2.7, or 8.3.1. The GitHub Security Advisory contains more information about vulnerable URL paths, mitigation, and the disclosure timeline."}, {"lang": "es", "value": "Grafana es una plataforma de c\u00f3digo abierto para la monitorizaci\u00f3n y la observaci\u00f3n. Grafana versiones 8.0.0-beta1 hasta 8.3.0 (excepto las versiones parcheadas) son vulnerables a un salto de directorio, permitiendo el acceso a archivos locales. La ruta de la URL vulnerable es: \"(grafana_host_url)/public/plugins//\", donde est\u00e1 el ID del plugin para cualquier plugin instalado. En ning\u00fan momento Grafana Cloud ha sido vulnerable. Se aconseja a usuarios que actualicen a las versiones parcheadas 8.0.7, 8.1.8, 8.2.7 o 8.3.1. El aviso de seguridad de GitHub contiene m\u00e1s informaci\u00f3n sobre las rutas de URL vulnerables, la mitigaci\u00f3n y el calendario de divulgaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.1", "versionEndExcluding": "8.0.7", "matchCriteriaId": "449504C1-1B9B-4D4E-940B-7107D6235AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.1.0", "versionEndExcluding": "8.1.8", "matchCriteriaId": "53D52B8C-3355-4329-B222-4C3878A8F074"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.2.0", "versionEndExcluding": "8.2.7", "matchCriteriaId": "860C7085-A83F-4A15-8587-6A4A598D9141"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:8.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "0D8F31CD-1C2B-47F0-9629-D29AD700F689"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:8.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "CA972DB1-60A8-470F-86F5-A7AFB1C98666"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:8.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "4FF3AB6B-AAE8-41DF-BB0A-3FE119E826D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:8.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "DB249517-1BC4-4D6F-8C8F-D1744CFF4E4C"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/165198/Grafana-Arbitrary-File-Reading.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/165221/Grafana-8.3.0-Directory-Traversal-Arbitrary-File-Read.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/12/09/2", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/12/10/4", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/commit/c798c0e958d15d9cc7f27c72113d572fa58545ce", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/security/advisories/GHSA-8pjx-jj86-j47p", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://grafana.com/blog/2021/12/08/an-update-on-0day-cve-2021-43798-grafana-directory-traversal/", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20211229-0004/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/grafana/grafana/commit/c798c0e958d15d9cc7f27c72113d572fa58545ce"}}