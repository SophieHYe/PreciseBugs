{"buggy_code": ["# History\n\n\n## not yet released, version 3.17.0\n\n- Improved `simplify` for nested exponentiations. Thanks @IvanVergiliev.\n\n\n## 2017-10-18, version 3.16.5\n\n- Fixed #954: Functions `add` and `multiply` not working when\n  passing three or more arrays or matrices.\n\n\n## 2017-10-01, version 3.16.4\n\n- Fixed #948, #949: function `simplify` returning wrong results or \n  running into an infinite recursive loop. Thanks @ericman314.\n- Fixed many small issues in the embedded docs.  Thanks @Schnark.\n\n\n## 2017-08-28, version 3.16.3\n\n- Fixed #934: Wrong simplification of unary minus. Thanks @firepick1.\n- Fixed #933: function `simplify` reordering operations. Thanks @firepick1.\n- Fixed #930: function `isNaN` returning wrong result for complex \n  numbers having just one of their parts (re/im) being `NaN`.\n- Fixed #929: `FibonacciHeap.isEmpty` returning wrong result.\n\n\n## 2017-08-20, version 3.16.2\n\n- Fixed #924: a regression in `simplify` not accepting the signature\n  `simplify(expr, rules, scope)` anymore. Thanks @firepick1.\n- Fixed missing parenthesis when stringifying expressions containing\n  implicit multiplications (see #922). Thanks @FSMaxB.\n\n\n## 2017-08-12, version 3.16.1\n\n- For security reasons, type checking is now done in a more strict\n  way using functions like `isComplex(x)` instead of duck type checking\n  like `x && x.isComplex === true`.\n- Fixed #915: No access to property \"name\".\n- Fixed #901: Simplify units when calling `unit.toNumeric()`.\n  Thanks @AlexanderBeyn.\n- Fixed `toString` of a parsed expression tree containing an\n  immediately invoked function assignment not being wrapped in\n  parenthesis (for example `(f(x) = x^2)(4)`).\n\n\n## 2017-08-06, version 3.16.0\n\n- Significant performance improvements in `math.simplify`.\n  Thanks @firepick1.\n- Improved API for `math.simplify`, optionally pass a scope with\n  variables which are resolved, see #907. Thanks @firepick1.\n- Fixed #912: math.js didn't work on IE10 anymore (regression\n  since 3.15.0).\n\n\n## 2017-07-29, version 3.15.0\n\n- Added support for the dollar character `$` in symbol names (see #895).\n- Allow objects with prototypes as scope again in the expression parser,\n  this was disabled for security reasons some time ago. See #888, #899.\n  Thanks @ThomasBrierley.\n- Fixed #846: Issues in the functions `map`, `forEach`, and `filter`\n  when used in the expression parser:\n  - Not being able to use a function assignment as inline expression\n    for the callback function.\n  - Not being able to pass an inline expression as callback for `map`\n    and `forEach`.\n  - Index and original array/matrix not passed in `map` and `filter`.\n\n\n## 2017-07-05, version 3.14.2\n\n- Upgraded to `fraction.js@4.0.2`\n- Fixed #891 using BigNumbers not working in browser environments.\n\n\n## 2017-06-30, version 3.14.1\n\n- Reverted to `fraction.js@4.0.0`, there is an issue with `4.0.1`\n  in the browser.\n\n\n## 2017-06-30, version 3.14.0\n\n- Implemented set methods `setCartesian`, `setDifference`,\n  `setDistinct`, `setIntersect`, `setIsSubset`, `setPowerset`,\n  `setSize`. Thanks @Nekomajin42.\n- Implemented method `toHTML` on nodes. Thanks @Nekomajin42.\n- Implemented `compareNatural` and `sort([...], 'natural')`.\n- Upgraded dependencies to the latest versions:\n  - `complex.js@2.0.4`\n  - `decimal.js@7.2.3`\n  - `fraction.js@4.0.1`\n  - `tiny-emitter@2.0.0`\n  - And all devDependencies.\n- Fixed #865: `splitUnit` can now deal with round-off errors.\n  Thanks @ericman314.\n- Fixed #876: incorrect definition for unit `erg`. Thanks @pjhampton.\n- More informative error message when using single quotes instead of\n  double quotes around a string. Thanks @HarrySarson.\n\n\n## 2017-05-27, version 3.13.3\n\n- Fixed a bug in function `intersection` of line and plane.\n  Thanks @viclai.\n- Fixed security vulnerabilities.\n\n\n## 2017-05-26, version 3.13.2\n\n- Disabled function `chain` inside the expression parser for security\n  reasons (it's not needed there anyway).\n- Fixed #856: function `subset` not returning non-primitive scalars\n  from Arrays correctly. (like `math.eval('arr[1]', {arr: [math.bignumber(2)]})`.\n- Fixed #861: physical constants not available in the expression parser.\n\n\n## 2017-05-12, version 3.13.1\n\n- Fixed creating units with an alias not working within the expression\n  parser.\n- Fixed security vulnerabilities. Thanks Sam.\n\n\n## 2017-05-12, version 3.13.0\n\n- Command line application can now evaluate inline expressions\n  like `mathjs 1+2`. Thanks @slavaGanzin.\n- Function `derivative` now supports `abs`. Thanks @tetslee.\n- Function `simplify` now supports BigNumbers. Thanks @tetslee.\n- Prevent against endless loops in `simplify`. Thanks @tetslee.\n- Fixed #813: function `simplify` converting small numbers to inexact\n  Fractions. Thanks @tetslee.\n- Fixed #838: Function `simplify` now supports constants like `e`.\n  Thanks @tetslee.\n\n\n## 2017-05-05, version 3.12.3\n\n- Fixed security vulnerabilities. Thanks Dan and Sam.\n\n\n## 2017-04-30, version 3.12.2\n\n- Added a rocket trajectory optimization example.\n\n\n## 2017-04-24, version 3.12.1\n\n- Fixed #804\n  - Improved handling of powers of `Infinity`. Thanks @HarrySarson.\n  - Fixed wrong formatting of complex NaN.\n- Fixed security vulnerabilities in the expression parser.\n  Thanks Sam and Dan.\n\n\n## 2017-04-17, version 3.12.0\n\n- Implemented QR decomposition, function `math.qr`. Thanks @HarrySarson.\n- Fixed #824: Calling `math.random()` freezes IE and node.js.\n\n\n## 2017-04-08, version 3.11.5\n\n- More security measures in the expression parser.\n  WARNING: the behavior of the expression parser is now more strict,\n  some undocumented features may not work any longer.\n  - Accessing and assigning properties is now only allowed on plain\n    objects, not on classes, arrays, and functions anymore.\n  - Accessing methods is restricted to a set of known, safe methods.\n\n\n## 2017-04-03, version 3.11.4\n\n- Fixed a security vulnerability in the expression parser. Thanks @xfix.\n\n\n## 2017-04-03, version 3.11.3\n\n- Fixed a security vulnerability in the expression parser. Thanks @xfix.\n\n\n## 2017-04-03, version 3.11.2\n\n- Fixed a security vulnerability in the expression parser. Thanks @xfix.\n\n\n## 2017-04-02, version 3.11.1\n\n- Fixed security vulnerabilities in the expression parser.\n  Thanks Joe Vennix and @xfix.\n\n\n## 2017-04-02, version 3.11.0\n\n- Implemented method Unit.toSI() to convert a unit to base SI units.\n  Thanks @ericman314.\n- Fixed #821, #822: security vulnerabilities in the expression parser.\n  Thanks @comex and @xfix.\n\n\n## 2017-03-31, version 3.10.3\n\n- More security fixes related to the ones fixed in `v3.10.2`.\n\n\n## 2017-03-31, version 3.10.2\n\n- Fixed a security vulnerability in the expression parser allowing\n  execution of arbitrary JavaScript. Thanks @CapacitorSet and @denvit.\n\n\n## 2017-03-26, version 3.10.1\n\n- Fixed `xgcd` for negative values. Thanks @litmit.\n- Fixed #807: function transform of existing functions not being removed when\n  overriding such a function.\n\n\n## 2017-03-05, version 3.10.0\n\n- Implemented function `reshape`. Thanks @patgrasso and @ericman314.\n- Implemented configuration option `seedRandom` for deterministic random\n  numbers. Thanks @morsecodist.\n- Small fixes in the docs. Thanks @HarrySarson.\n- Dropped support for component package manager (which became deprecated about\n  one and a half year ago).\n\n\n## 2017-02-22, version 3.9.3\n\n- Fixed #797: issue with production builds of React Native projects.\n- Fixed `math.round` not accepting inputs `NaN`, `Infinity`, `-Infinity`.\n- Upgraded all dependencies.\n\n\n## 2017-02-16, version 3.9.2\n\n- Fixed #795: Parse error in case of a multi-line expression with just comments.\n\n\n## 2017-02-06, version 3.9.1\n\n- Fixed #789: Math.js not supporting conversion of `string` to `BigNumber`,\n  `Fraction`, or `Complex` number.\n- Fixed #790: Expression parser did not pass function arguments of enclosing\n  functions via `scope` to functions having `rawArgs = true`.\n- Small fixes in the docs. Thanks @HarrySarson.\n\n\n## 2017-01-23, version 3.9.0\n\n- Implemented support for algebra: powerful new functions `simplify` and\n  `derivative`. Thanks @ericman314, @tetslee, and @BigFav.\n- Implemented Kronecker Product `kron`. Thanks @adamisntdead.\n- Reverted `FunctionNode` not accepting a string as function name anymore.\n- Fixed #765: `FunctionAssignmentNode.toString()` returning a string\n  incompatible with the function assignment syntax.\n\n\n## 2016-12-15, version 3.8.1\n\n- Implemented function `mad` (median absolute deviation). Thanks @ruhleder.\n- Fixed #762: expression parser failing to invoke a function returned\n  by a function.\n\n\n## 2016-11-18, version 3.8.0\n\n- Functions `add` and `multiply` now accept more than two arguments. See #739.\n- `OperatorNode` now supports more than two arguments. See #739. Thanks @FSMaxB.\n- Implemented a method `Node.cloneDeep` for the expression nodes. See #745.\n- Fixed a bug in `Node.clone()` not cloning implicit multiplication correctly.\n  Thanks @FSMaxB.\n- Fixed #737: Improved algorithm determining the best prefix for units.\n  It will now retain the original unit like `1 cm` when close enough,\n  instead of returning `10 mm`. Thanks @ericman314.\n- Fixed #732: Allow letter-like unicode characters like Ohm `\\u2126`.\n- Fixed #749: Units `rad`, `deg`, and `grad` can now have prefixes like `millirad`.\n- Some fixes in the docs and comments of examples. Thanks @HarrySarson.\n\n\n## 2016-11-05, version 3.7.0\n\n- Implemented method `Node.equals(other)` for all nodes of the expression parser.\n- Implemented BigNumber support in function `arg()`.\n- Command Line Interface loads faster.\n- Implicit conversions between Fractions and BigNumbers throw a neat error now\n  (See #710).\n\n\n## 2016-10-21, version 3.6.0\n\n- Implemented function `erf()`. THanks @patgrasso.\n- Extended function `cross()` to support n-d vectors. Thanks @patgrasso.\n- Extended function `pickRandom` with the option to pick multiple values from\n  an array and give the values weights: `pickRandom(possibles, number, weights)`.\n  Thanks @woylie.\n- Parser now exposes test functions like `isAlpha` which can be replaced in\n  order to adjust the allowed characters in variables names (See #715).\n- Fixed #727: Parser not throwing an error for invalid implicit multiplications\n  like `-2 2` and `2^3 4` (right after the second value of an operator).\n- Fixed #688: Describe allowed variable names in the docs.\n\n\n## 2016-09-21, version 3.5.3\n\n- Some more fixes regarding numbers ending with a decimal mark (like `2.`).\n\n\n## 2016-09-20, version 3.5.2\n\n- Fixed numbers ending with a decimal mark (like `2.`) not being supported by\n  the parser, solved the underlying ambiguity in the parser. See #707, #711.\n\n\n## 2016-09-12, version 3.5.1\n\n- Removed a left over console.log statement. Thanks @eknkc.\n\n\n## 2016-09-07, version 3.5.0\n\n- Comments of expressions are are now stored in the parsed nodes. See #690.\n- Fixed function `print` not accepting an Object with formatting options as\n  third parameter Thanks @ThomasBrierley.\n- Fixed #707: The expression parser no longer accepts numbers ending with a dot\n  like `2.`.\n\n\n## 2016-08-08, version 3.4.1\n\n- Fixed broken bundle files (`dist/math.js`, `dist/math.min.js`).\n- Fixed some layout issues in the function reference docs.\n\n\n## 2016-08-07, version 3.4.0\n\n- Implemented support for custom units using `createUnit`. Thanks @ericman314.\n- Implemented function `splitUnits`. Thanks @ericman314.\n- Implemented function `isPrime`. Thanks @MathBunny.\n\n\n## 2016-07-05, version 3.3.0\n\n- Implemented function `isNaN`.\n- Function `math.filter` now passes three arguments to the callback function:\n  value, index, and array.\n- Removed the check on the number of arguments from functions defined in the\n  expression parser (see #665).\n- Fixed #665: functions `map`, `forEach`, and `filter` now invoke callbacks\n  which are a typed-function with the correct number of arguments.\n\n\n## 2016-04-26, version 3.2.1\n\n- Fixed #651: unable to perform calculations on \"Unit-less\" units.\n- Fixed matrix.subset mutating the replacement matrix when unsqueezing it.\n\n\n## 2016-04-16, version 3.2.0\n\n- Implemented #644: method `Parser.getAll()` to retrieve all defined variables.\n- Upgraded dependencies (decimal.js@5.0.8, fraction.js@3.3.1,\n  typed-function@0.10.4).\n- Fixed #601: Issue with unnamed typed-functions by upgrading to\n  typed-function v0.10.4.\n- Fixed #636: More strict `toTex` templates, reckon with number of arguments.\n- Fixed #641: Bug in expression parser parsing implicit multiplication with\n  wrong precedence in specific cases.\n- Fixed #645: Added documentation about `engineering` notation of function\n  `math.format`.\n\n\n## 2016-04-03, version 3.1.4\n\n- Using ES6 Math functions like `Math.sinh`, `Math.cbrt`, `Math.sign`, etc when\n  available.\n- Fixed #631: unit aliases `weeks`, `months`, and `years` where missing.\n- Fixed #632: problem with escaped backslashes at the end of strings.\n- Fixed #635: `Node.toString` options where not passed to function arguments.\n- Fixed #629: expression parser throws an error when passing a number with\n  decimal exponent instead of parsing them as implicit multiplication.\n- Fixed #484, #555: inaccuracy of `math.sinh` for values between -1 and 1.\n- Fixed #625: Unit `in` (`inch`) not always working due to ambiguity with\n  the operator `a in b` (alias of `a to b`).\n\n\n## 2016-03-24, version 3.1.3\n\n- Fix broken bundle.\n\n\n## 2016-03-24, version 3.1.2\n\n- Fix broken npm release.\n\n\n## 2016-03-24, version 3.1.1\n\n- Fixed #621: a bug in parsing implicit multiplications like `(2)(3)+4`.\n- Fixed #623: `nthRoot` of zero with a negative root returned `0` instead of\n  `Infinity`.\n- Throw an error when functions `min`, `max`, `mean`, or `median` are invoked\n  with multiple matrices as arguments (see #598).\n\n\n## 2016-03-19, version 3.1.0\n\n- Hide multiplication operator by default when outputting `toTex` and `toString`\n  for implicit multiplications. Implemented and option to output the operator.\n- Implemented unit `kip` and alias `kips`. Thanks @hgupta9.\n- Added support for prefixes for units `mol` and `mole`. Thanks @stu-blair.\n- Restored support for implicit multiplications like `2(3+4)` and `(2+3)(4+5)`.\n- Some improvements in the docs.\n- Added automatic conversions from `boolean` and `null` to `Fraction`,\n  and conversions from `Fraction` to `Complex`.\n\n\n## 2016-03-04, version 3.0.0\n\n### breaking changes\n\n- More restricted support for implicit multiplication in the expression\n  parser: `(...)(...)` is now evaluated as a function invocation,\n  and `[...][...]` as a matrix subset.\n- Matrix multiplication no longer squeezes scalar outputs to a scalar value,\n  but leaves them as they are: a vector or matrix containing a single value.\n  See #529.\n- Assignments in the expression parser now return the assigned value rather\n  than the created or updated object (see #533). Example:\n\n  ```\n  A = eye(3)\n  A[1,1] = 2   # this assignment now returns 2 instead of A\n  ```\n\n- Expression parser now supports objects. This involves a refactoring and\n  extension in expression nodes:\n  - Implemented new node `ObjectNode`.\n  - Refactored `AssignmentNode`, `UpdateNode`, and `IndexNode` are refactored\n    into `AccessorNode`, `AssignmentNode`, and `IndexNode` having a different API.\n- Upgraded the used BigNumber library `decimal.js` to v5. Replaced the\n  trigonometric functions of math.js with those provided in decimal.js v5.\n  This can give slightly different behavior qua round-off errors.\n- Replaced the internal `Complex.js` class with the `complex.js` library\n  created by @infusion.\n- Entries in a matrix (typically numbers, BigNumbers, Units, etc) are now\n  considered immutable, they are no longer copied when performing operations on\n  the entries, improving performance.\n- Implemented nearly equal comparison for relational functions (`equal`,\n  `larger`, `smaller`, etc.) when using BigNumbers.\n- Changed the casing of the configuration options `matrix` (`Array` or `Matrix`)\n  and `number` (`number`, `BigNumber`, `Fraction`) such that they now match\n  the type returned by `math.typeof`. Wrong casing gives a console warning but\n  will still work.\n- Changed the default config value for `epsilon` from `1e-14` to `1e-12`,\n  see #561.\n\n### non-breaking changes\n\n- Extended function `pow` to return the real root for cubic roots of negative\n  numbers. See #525, #482, #567.\n- Implemented support for JSON objects in the expression parser and the\n  function `math.format`.\n- Function `math.fraction` now supports `BigNumber`, and function\n  `math.bignumber` now supports `Fraction`.\n- Expression parser now allows function and/or variable assignments inside\n  accessors and conditionals, like `A[x=2]` or `a > 2 ? b=\"ok\" : b=\"fail\"`.\n- Command line interface:\n  - Outputs the variable name of assignments.\n  - Fixed not rounding BigNumbers to 14 digits like numbers.\n  - Fixed non-working autocompletion of user defined variables.\n- Reorganized and extended docs, added docs on classes and more. Thanks @hgupta9.\n- Added new units `acre`, `hectare`, `torr`, `bar`, `mmHg`, `mmH2O`, `cmH2O`,\n  and added new aliases `acres`, `hectares`, `sqfeet`, `sqyard`, `sqmile`,\n  `sqmiles`, `mmhg`, `mmh2o`, `cmh2o`. Thanks @hgupta9.\n- Fixed a bug in the toString method of an IndexNode.\n- Fixed angle units `deg`, `rad`, `grad`, `cycle`, `arcsec`, and `arcmin` not\n  being defined as BigNumbers when configuring to use BigNumbers.\n\n\n## 2016-02-03, version 2.7.0\n\n- Added more unit aliases for time: `secs`, `mins`, `hr`, `hrs`. See #551.\n- Added support for doing operations with mixed `Fractions` and `BigNumbers`.\n- Fixed #540: `math.intersect()` returning null in some cases. Thanks @void42.\n- Fixed #546: Cannot import BigNumber, Fraction, Matrix, Array.\n  Thanks @brettjurgens.\n\n\n## 2016-01-08, version 2.6.0\n\n- Implemented (complex) units `VA` and `VAR`.\n- Implemented time units for weeks, months, years, decades, centuries, and \n  millennia. Thanks @owenversteeg.\n- Implemented new notation `engineering` in function `math.format`. \n  Thanks @johnmarinelli.\n- Fixed #523: In some circumstances, matrix subset returned a scalar instead \n  of the correct subset.\n- Fixed #536: A bug in an internal method used for sparse matrices.\n\n\n## 2015-12-05, version 2.5.0\n\n- Implemented support for numeric types `Fraction` and `BigNumber` in units.\n- Implemented new method `toNumeric` for units.\n- Implemented new units `arcsec`, `arcsecond`, `arcmin`, `arcminute`. \n  Thanks @devdevdata222.\n- Implemented new unit `Herts` (`Hz`). Thanks @SwamWithTurtles.\n- Fixed #485: Scoping issue with variables both used globally as well as in a \n  function definition.\n- Fixed: Function `number` didn't support `Fraction` as input.\n\n\n## 2015-11-14, version 2.4.2\n\n- Fixed #502: Issue with `format` in some JavaScript engines.\n- Fixed #503: Removed trailing commas and the use of keyword `import` as \n  property, as this gives issues with old JavaScript engines.\n\n\n## 2015-10-29, version 2.4.1\n\n- Fixed #480: `nthRoot` not working on Internet Explorer (up to IE 11).\n- Fixed #490: `nthRoot` returning an error for negative values like \n  `nthRoot(-2, 3)`.\n- Fixed #489: an issue with initializing a sparse matrix without data.\n  Thanks @Retsam.\n- Fixed: #493: function `combinations` did not throw an exception for \n  non-integer values of `k`.\n- Fixed: function `import` did not override typed functions when the option\n  override was set true.\n- Fixed: added functions `math.sparse` and `math.index` to the reference docs, \n  they where missing.\n- Fixed: removed memoization from `gamma` and `factorial` functions, this \n  could blow up memory.\n\n\n## 2015-10-09, version 2.4.0\n\n- Added support in the expression parser for mathematical alphanumeric symbols \n  in the expression parser: unicode range \\u{1D400} to \\u{1D7FF} excluding \n  invalid code points.\n- Extended function `distance` with more signatures. Thanks @kv-kunalvyas.\n- Fixed a bug in functions `sin` and `cos`, which gave wrong results for \n  BigNumber integer values around multiples of tau (i.e. `sin(bignumber(7))`).\n- Fixed value of unit `stone`. Thanks @Esvandiary for finding the error.\n\n\n## 2015-09-19, version 2.3.0\n\n- Implemented function `distance`. Thanks @devanp92.\n- Implemented support for Fractions in function `lcm`. Thanks @infusion.\n- Implemented function `cbrt` for numbers, complex numbers, BigNumbers, Units.\n- Implemented function `hypot`.\n- Upgraded to fraction.js v3.0.0.\n- Fixed #450: issue with non sorted index in sparse matrices.\n- Fixed #463, #322: inconsistent handling of implicit multiplication.\n- Fixed #444: factorial of infinity not returning infinity.\n\n\n## 2015-08-30, version 2.2.0\n\n- Units with powers (like `m^2` and `s^-1`) now output with the best prefix.\n- Implemented support for units to `abs`, `cube`, `sign`, `sqrt`, `square`.\n  Thanks @ericman314.\n- Implemented function `catalan` (Combinatorics). Thanks @devanp92.\n- Improved the `canDefineProperty` check to return false in case of IE8, which\n  has a broken implementation of `defineProperty`. Thanks @golmansax.\n- Fixed function `to` not working in case of a simplified unit.\n- Fixed #437: an issue with row swapping in `lup`, also affecting `lusolve`.\n\n\n## 2015-08-12, version 2.1.1\n\n- Fixed wrong values of the physical constants `speedOfLight`, `molarMassC12`,  \n  and `magneticFluxQuantum`. Thanks @ericman314 for finding two of them.\n\n\n## 2015-08-11, version 2.1.0\n\n- Implemented derived units (like `110 km/h in m/s`). Thanks @ericman314.\n- Implemented support for electric units. Thanks @ericman314.\n- Implemented about 50 physical constants like `speedOfLight`, `gravity`, etc. \n- Implemented function `kldivergence` (Kullback-Leibler divergence). \n  Thanks @saromanov.\n- Implemented function `mode`. Thanks @kv-kunalvyas.\n- Added support for unicode characters in the expression parser: greek letters\n  and latin letters with accents. See #265.\n- Internal functions `Unit.parse` and `Complex.parse` now throw an Error \n  instead of returning null when passing invalid input.\n\n\n## 2015-07-29, version 2.0.1\n\n- Fixed operations with mixed fractions and numbers be converted to numbers\n  instead of fractions.\n\n\n## 2015-07-28, version 2.0.0\n\n- Large internal refactoring:\n  - performance improvements.\n  - allows to create custom bundles\n  - functions are composed using `typed-function` and are extensible\n- Implemented support for fractions, powered by the library `fraction.js`.\n- Implemented matrix LU decomposition with partial pivoting and a LU based \n  linear equations solver (functions `lup` and `lusolve`). Thanks @rjbaucells.\n- Implemented a new configuration option `predictable`, which can be set to\n  true in order to ensure predictable function output types.\n- Implemented function `intersect`. Thanks @kv-kunalvyas.\n- Implemented support for adding `toTex` properties to custom functions.\n  Thanks @FSMaxB.\n- Implemented support for complex values to `nthRoot`. Thanks @gangachris.\n- Implemented util functions `isInteger`, `isNegative`, `isNumeric`, \n  `isPositive`, and `isZero`.\n\n### breaking changes\n\n- String input is now converted to numbers by default for all functions. \n- Adding two strings will no longer concatenate them, but will convert the \n  strings to numbers and add them.\n- Function `index` does no longer accept an array `[start, end, step]`, but\n  instead accepts an array with arbitrary index values. It also accepts\n  a `Range` object as input.\n- Function `typeof` no longer returns lower case names, but now returns lower\n  case names for primitives (like `number`, `boolean`, `string`), and \n  upper-camel-case for non-primitives (like `Array`, `Complex`, `Function`).\n- Function `import` no longer supports a module name as argument. Instead,\n  modules can be loaded using require: `math.import(require('module-name'))`.\n- Function `import` has a new option `silent` to ignore errors, and throws\n  errors on duplicates by default.\n- Method `Node.compile()` no longer needs `math` to be passed as argument.\n- Reintroduced method `Node.eval([scope])`.\n- Function `sum` now returns zero when input is an empty array. Thanks @FSMAxB.\n- The size of Arrays is no longer validated. Matrices will validate this on\n  creation.\n\n\n## 2015-07-12, version 1.7.1\n\n- Fixed #397: Inaccuracies in nthRoot for very large values, and wrong results \n  for very small values. (backported from v2)\n- Fixed #405: Parser throws error when defining a function in a multiline \n  expression.\n\n\n## 2015-05-31, version 1.7.0\n\n- Implemented function `quantileSeq` and `partitionSelect`. Thanks @BigFav.\n- Implemented functions `stirlingS2`, `bellNumbers`, `composition`, and \n  `multinomial`. Thanks @devanp92.\n- Improved the performance of `median` (see #373). Thanks @BigFav.\n- Extended the command line interface with a `mode` option to output either\n  the expressions result, string representation, or tex representation.\n  Thanks @FSMaxB.\n- Fixed #309: Function median mutating the input matrix. Thanks @FSMaxB. \n- Fixed `Node.transform` not recursing over replaced parts of the \n  node tree (see #349).\n- Fixed #381: issue in docs of `randomInt`.\n\n\n## 2015-04-22, version 1.6.0\n\n- Improvements in `toTex`. Thanks @FSMaxB.\n- Fixed #328: `abs(0 + 0i)` evaluated to `NaN`.\n- Fixed not being able to override lazy loaded constants.\n\n\n## 2015-04-09, version 1.5.2\n\n- Fixed #313: parsed functions did not handle recursive calls correctly.\n- Fixed #251: binary prefix and SI prefix incorrectly used for byte. Now \n  following SI standards (`1 KiB == 1024 B`, `1 kB == 1000 B`).\n- Performance improvements in parsed functions.\n\n\n## 2015-04-08, version 1.5.1\n\n- Fixed #316: a bug in rounding values when formatting.\n- Fixed #317, #319: a bug in formatting negative values.\n\n\n## 2015-03-28, version 1.5.0\n\n- Added unit `stone` (6.35 kg).\n- Implemented support for sparse matrices. Thanks @rjbaucells.\n- Implemented BigNumber support for function `atan2`. Thanks @BigFav.\n- Implemented support for custom LaTeX representations. Thanks @FSMaxB.\n- Improvements and bug fixes in outputting parentheses in `Node.toString` and\n  `Node.toTex` functions. Thanks @FSMaxB.\n- Fixed #291: function `format` sometimes returning exponential notation when\n  it should return a fixed notation.\n\n\n## 2015-02-28, version 1.4.0\n\n- Implemented trigonometric functions:\n  `acosh`, `acoth`, `acsch`, `asech`, `asinh`, `atanh`, `acot`, `acsc`, `asec`.\n  Thanks @BigFav.\n- Added BigNumber support for functions: `cot`, `csc`, `sec`, `coth`,\n  `csch`, `sech`. Thanks @BigFav.\n- Implemented support for serialization and deserialization of math.js data\n  types.\n- Fixed the calculation of `norm()` and `abs()` for large complex numbers.\n  Thanks @rjbaucells.\n- Fixed #281: improved formatting complex numbers. Round the real or imaginary\n  part to zero when the difference is larger than the configured precision.\n\n\n## 2015-02-09, version 1.3.0\n\n- Implemented BigNumber implementations of most trigonometric functions: `sin`,\n  `cos`, `tan`, `asin`, `acos`, `atan`, `cosh`, `sinh`, `tanh`. Thanks @BigFav.\n- Implemented function `trace`. Thanks @pcorey.\n- Faster loading of BigNumber configuration with a high precision by lazy\n  loading constants like `pi` and `e`.\n- Fixed constants `NaN` and `Infinity` not being BigNumber objects when\n  BigNumbers are configured.\n- Fixed missing parentheses in the `toTex` representation of function\n  `permutations`.\n- Some minor fixes in the docs. Thanks @KenanY.\n\n\n## 2014-12-25, version 1.2.0\n\n- Support for bitwise operations `bitAnd`, `bitNot`, `bitOr`, `bitXor`,\n  `leftShift`, `rightArithShift`, and `rightLogShift`. Thanks @BigFav.\n- Support for boolean operations `and`, `not`, `or`, `xor`. Thanks @BigFav.\n- Support for `gamma` function. Thanks @BigFav.\n- Converting a unit without value will now result in a unit *with* value,\n  i.e. `inch in cm` will return `2.54 cm` instead of `cm`.\n- Improved accuracy of `sinh` and complex `cos` and `sin`. Thanks @pavpanchekha.\n- Renamed function `select` to `chain`. The old function `select` will remain\n  functional until math.js v2.0.\n- Upgraded to decimal.js v4.0.1 (BigNumber library).\n\n\n## 2014-11-22, version 1.1.1\n\n- Fixed Unit divided by Number returning zero.\n- Fixed BigNumber downgrading to Number for a negative base in `pow`.\n- Fixed some typos in error messaging (thanks @andy0130tw) and docs.\n\n\n## 2014-11-15, version 1.1.0\n\n- Implemented functions `dot` (dot product), `cross` (cross product), and\n  `nthRoot`.\n- Officially opened up the API of expression trees:\n  - Documented the API.\n  - Implemented recursive functions `clone`, `map`, `forEach`, `traverse`,\n    `transform`, and `filter` for expression trees.\n  - Parameter `index` in the callbacks of `map` and `forEach` are now cloned\n    for every callback.\n  - Some internal refactoring inside nodes to make the API consistent:\n    - Renamed `params` to `args` and vice versa to make things consistent.\n    - Renamed `Block.nodes` to `Block.blocks`.\n    - `FunctionNode` now has a `name: string` instead of a `symbol: SymbolNode`.\n    - Changed constructor of `RangeNode` to\n      `new RangeNode(start: Node, end: Node [, step: Node])`.\n    - Nodes for a `BlockNode` must now be passed via the constructor instead\n      of via a function `add`.\n- Fixed `2e` giving a syntax error instead of being parsed as `2 * e`.\n\n\n## 2014-09-12, version 1.0.1\n\n- Disabled array notation for ranges in a matrix index in the expression parser \n  (it is confusing and redundant there).\n- Fixed a regression in the build of function subset not being able to return\n  a scalar.\n- Fixed some missing docs and broken links in the docs.\n\n\n## 2014-09-04, version 1.0.0\n\n- Implemented a function `filter(x, test)`.\n- Removed `math.distribution` for now, needs some rethinking.\n- `math.number` can convert units to numbers (requires a second argument)\n- Fixed some precedence issues with the range and conversion operators.\n- Fixed an zero-based issue when getting a matrix subset using an index \n  containing a matrix.\n\n\n## 2014-08-21, version 0.27.0\n\n- Implemented functions `sort(x [, compare])` and `flatten(x)`.\n- Implemented support for `null` in all functions.\n- Implemented support for \"rawArgs\" functions in the expression parser. Raw \n  functions are invoked with unevaluated parameters (nodes).\n- Expressions in the expression parser can now be spread over multiple lines,\n  like '2 +\\n3'.\n- Changed default value of the option `wrap` of function `math.import` to false.\n- Changed the default value for new entries in a resized matrix when to zero. \n  To leave new entries uninitialized, use the new constant `math.uninitialized` \n  as default value.\n- Renamed transform property from `__transform__` to `transform`, and documented\n  the transform feature.\n- Fixed a bug in `math.import` not applying options when passing a module name.\n- A returned matrix subset is now only squeezed when the `index` consists of\n  scalar values, and no longer for ranges resolving into a single value. \n\n\n## 2014-08-03, version 0.26.0\n\n- A new instance of math.js can no longer be created like `math([options])`,\n  to prevent side effects from math being a function instead of an object.\n  Instead, use the function `math.create([options])` to create a new instance.\n- Implemented `BigNumber` support for all constants: `pi`, `tau`, `e`, `phi`,\n  `E`, `LN2`, `LN10`, `LOG2E`, `LOG10E`, `PI`, `SQRT1_2`, and `SQRT2`.\n- Implemented `BigNumber` support for functions `gcd`, `xgcd`, and `lcm`.\n- Fixed function `gxcd` returning an Array when math.js was configured \n  as `{matrix: 'matrix'}`.\n- Multi-line expressions now return a `ResultSet` instead of an `Array`.\n- Implemented transforms (used right now to transform one-based indices to \n  zero-based for expressions).\n- When used inside the expression parser, functions `concat`, `min`, `max`,\n  and `mean` expect an one-based dimension number.\n- Functions `map` and `forEach` invoke the callback with one-based indices\n  when used from within the expression parser.\n- When adding or removing dimensions when resizing a matrix, the dimensions\n  are added/removed from the inner side (right) instead of outer side (left).\n- Improved index out of range errors.\n- Fixed function `concat` not accepting a `BigNumber` for parameter `dim`.\n- Function `squeeze` now squeezes both inner and outer singleton dimensions.\n- Output of getting a matrix subset is not automatically squeezed anymore\n  except for scalar output.\n- Renamed `FunctionNode` to `FunctionAssignmentNode`, and renamed `ParamsNode`\n  to `FunctionNode` for more clarity.\n- Fixed broken auto completion in CLI.\n- Some minor fixes.\n\n\n## 2014-07-01, version 0.25.0\n\n- The library now immediately returns a default instance of mathjs, there is\n  no need to instantiate math.js in a separate step unless one ones to set \n  configuration options: \n  \n        // instead of:\n        var mathjs = require('mathjs'),  // load math.js\n            math = mathjs();             // create an instance\n      \n        // just do:\n        var math = require('mathjs');\n- Implemented support for implicit multiplication, like `math.eval('2a', {a:3})`\n  and `math.eval('(2+3)(1-3)')`. This changes behavior of matrix indexes as \n  well: an expression like `[...][...]` is not evaluated as taking a subset of \n  the first matrix, but as an implicit multiplication of two matrices.\n- Removed utility function `ifElse`. This function is redundant now the \n  expression parser has a conditional operator `a ? b : c`.\n- Fixed a bug with multiplying a number with a temperature,  \n  like `math.eval('10 * celsius')`.\n- Fixed a bug with symbols having value `undefined` not being evaluated.\n\n\n## 2014-06-20, version 0.24.1\n\n- Something went wrong with publishing on npm.\n\n\n## 2014-06-20, version 0.24.0\n\n- Added constant `null`.\n- Functions `equal` and `unequal` support `null` and `undefined` now.\n- Function `typeof` now recognizes regular expressions as well.\n- Objects `Complex`, `Unit`, and `Help` now return their string representation\n  when calling `.valueOf()`.\n- Changed the default number of significant digits for BigNumbers from 20 to 64.\n- Changed the behavior of the conditional operator (a ? b : c) to lazy \n  evaluating.\n- Fixed imported, wrapped functions not accepting `null` and `undefined` as\n  function arguments.\n\n\n## 2014-06-10, version 0.23.0\n\n- Renamed some functions (everything now has a logical, camel case name):\n  - Renamed functions `edivide`, `emultiply`, and `epow` to `dotDivide`, \n    `dotMultiply`, and `dotPow` respectively. \n  - Renamed functions `smallereq` and `largereq` to `smallerEq` and `largerEq`.\n  - Renamed function `unary` to `unaryMinus` and added support for strings.\n- `end` is now a reserved keyword which cannot be used as function or symbol\n  name in the expression parser, and is not allowed in the scope against which\n  an expression is evaluated.\n- Implemented function `unaryPlus` and unary plus operator.\n- Implemented function `deepEqual` for matrix comparisons. \n- Added constant `phi`, the golden ratio (`phi = 1.618...`).\n- Added constant `version`, returning the version number of math.js as string.\n- Added unit `drop` (`gtt`).\n- Fixed not being able to load math.js using AMD/require.js.\n- Changed signature of `math.parse(expr, nodes)` to `math.parse(expr, options)`\n  where `options: {nodes: Object.<String, Node>}`\n- Removed matrix support from conditional function `ifElse`.\n- Removed automatic assignment of expression results to variable `ans`. \n  This functionality can be restored by pre- or postprocessing every evaluation, \n  something like:\n  \n        function evalWithAns (expr, scope) {\n          var ans = math.eval(expr, scope);\n          if (scope) {\n            scope.ans = ans;\n          }\n          return ans;\n        }\n\n\n## 2014-05-22, version 0.22.0\n\n- Implemented support to export expressions to LaTeX. Thanks Niels Heisterkamp\n  (@nheisterkamp).\n- Output of matrix multiplication is now consistently squeezed.\n- Added reference documentation in the section /docs/reference.\n- Fixed a bug in multiplying units without value with a number (like `5 * cm`).\n- Fixed a bug in multiplying two matrices containing vectors (worked fine for \n  arrays).\n- Fixed random functions not accepting Matrix as input, and always returning\n  a Matrix as output.\n\n\n## 2014-05-13, version 0.21.1\n\n- Removed `crypto` library from the bundle.\n- Deprecated functions `Parser.parse` and `Parser.compile`. Use\n  `math.parse` and `math.compile` instead.\n- Fixed function `add` not adding strings and matrices element wise.\n- Fixed parser not being able to evaluate an exponent followed by a unary minus\n  like `2^-3`, and a transpose followed by an index like `[3]'[1]`.\n\n\n## 2014-04-24, version 0.21.0\n\n- Implemented trigonometric hyperbolic functions `cosh`, `coth`, `csch`,\n  `sech`, `sinh`, `tanh`. Thanks Rogelio J. Baucells (@rjbaucells).\n- Added property `type` to all expression nodes in an expression tree.\n- Fixed functions `log`, `log10`, `pow`, and `sqrt` not supporting complex\n  results from BigNumber input (like `sqrt(bignumber(-4))`).\n\n\n## 2014-04-16, version 0.20.0\n\n- Switched to module `decimal.js` for BigNumber support, instead of\n  `bignumber.js`.\n- Implemented support for polar coordinates to the `Complex` datatype.\n  Thanks Finn Pauls (@finnp).\n- Implemented BigNumber support for functions `exp`, `log`, and `log10`.\n- Implemented conditional operator `a ? b : c` in expression parser.\n- Improved floating point comparison: the functions now check whether values\n  are nearly equal, against a configured maximum relative difference `epsilon`.\n  Thanks Rogelio J. Baucells (@rjbaucells).\n- Implemented function `norm`. Thanks Rogelio J. Baucells (@rjbaucells).\n- Improved function `ifElse`, is now specified for special data types too.\n- Improved function `det`. Thanks Bryan Cuccioli (@bcuccioli).\n- Implemented `BigNumber` support for functions `det` and `diag`.\n- Added unit alias `lbs` (pound mass).\n- Changed configuration option `decimals` to `precision` (applies to BigNumbers\n  only).\n- Fixed support for element-wise comparisons between a string and a matrix.\n- Fixed: expression parser now trows IndexErrors with one-based indices instead\n  of zero-based.\n- Minor bug fixes.\n\n\n## 2014-03-30, version 0.19.0\n\n- Implemented functions `compare`, `sum`, `prod`, `var`, `std`, `median`.\n- Implemented function `ifElse` Thanks @mtraynham.\n- Minor bug fixes.\n\n\n## 2014-02-15, version 0.18.1\n\n- Added unit `feet`.\n- Implemented function `compile` (shortcut for parsing and then compiling).\n- Improved performance of function `pow` for matrices. Thanks @hamadu.\n- Fixed broken auto completion in the command line interface.\n- Fixed an error in function `combinations` for large numbers, and\n  improved performance of both functions `combinations` and `permutations`.\n\n\n## 2014-01-18, version 0.18.0\n\n- Changed matrix index notation of expression parser from round brackets to\n  square brackets, for example `A[1, 1:3]` instead of `A(1, 1:3)`.\n- Removed need to use the `function` keyword for function assignments in the\n  expression parser, you can define a function now like `f(x) = x^2`.\n- Implemented a compilation step in the expression parser: expressions are\n  compiled into JavaScript, giving much better performance (easily 10x as fast).\n- Renamed unit conversion function and operator `in` to `to`. Operator `in` is\n  still available in the expression parser as an alias for `to`. Added unit\n  `in`, an abbreviation for `inch`. Thanks Elijah Insua (@tmpvar).\n- Added plurals and aliases for units.\n- Implemented an argument `includeEnd` for function `range` (false by default).\n- Ranges in the expression parser now support big numbers.\n- Implemented functions `permutations` and `combinations`.\n  Thanks Daniel Levin (@daniel-levin).\n- Added lower case abbreviation `l` for unit litre.\n\n\n## 2013-12-19, version 0.17.1\n\n- Fixed a bug with negative temperatures.\n- Fixed a bug with prefixes of units squared meter `m2` and cubic meter `m3`.\n\n\n## 2013-12-12, version 0.17.0\n\n- Renamed and flattened configuration settings:\n  - `number.defaultType` is now `number`.\n  - `number.precision` is now `decimals`.\n  - `matrix.defaultType` is now `matrix`.\n- Function `multiply` now consistently outputs a complex number on complex input.\n- Fixed `mod` and `in` not working as function (only as operator).\n- Fixed support for old browsers (IE8 and older), compatible when using es5-shim.\n- Fixed support for Java's ScriptEngine.\n\n\n## 2013-11-28, version 0.16.0\n\n- Implemented BigNumber support for arbitrary precision calculations.\n  Added settings `number.defaultType` and `number.precision` to configure\n  big numbers.\n- Documentation is extended.\n- Removed utility functions `isScalar`, `toScalar`, `isVector`, `toVector`\n  from `Matrix` and `Range`. Use `math.squeeze` and `math.size` instead.\n- Implemented functions `get` and `set` on `Matrix`, for easier and faster\n  retrieval/replacement of elements in a matrix.\n- Implemented function `resize`, handling matrices, scalars, and strings.\n- Functions `ones` and `zeros` now return an empty matrix instead of a\n  number 1 or 0 when no arguments are provided.\n- Implemented functions `min` and `max` for `Range` and `Index`.\n- Resizing matrices now leaves new elements undefined by default instead of\n  filling them with zeros. Function `resize` now has an extra optional\n  parameter `defaultValue`.\n- Range operator `:` in expression parser has been given a higher precedence.\n- Functions don't allow arguments of unknown type anymore.\n- Options be set when constructing a math.js instance or using the new function\n  `config(options`. Options are no longer accessible via `math.options`.\n- Renamed `scientific` notation to `exponential` in function `format`.\n- Function `format` outputs exponential notation with positive exponents now\n  always with `+` sign, so outputs `2.1e+3` instead of `2.1e3`.\n- Fixed function `squeeze` not being able squeeze into a scalar.\n- Some fixes and performance improvements in the `resize` and `subset`\n  functions.\n- Function `size` now adheres to the option `matrix.defaultType` for scalar\n  input.\n- Minor bug fixes.\n\n\n## 2013-10-26, version 0.15.0\n\n- Math.js must be instantiated now, static calls are no longer supported. Usage:\n  - node.js: `var math = require('mathjs')();`\n  - browser: `var math = mathjs();`\n- Implemented support for multiplying vectors with matrices.\n- Improved number formatting:\n  - Function `format` now support various options: precision, different\n    notations (`fixed`, `scientific`, `auto`), and more.\n  - Numbers are no longer rounded to 5 digits by default when formatted.\n  - Implemented a function `format` for `Matrix`, `Complex`, `Unit`, `Range`,\n    and `Selector` to format using options.\n  - Function `format` does only stringify values now, and has a new parameter\n    `precision` to round to a specific number of digits.\n  - Removed option `math.options.precision`,\n    use `math.format(value [, precision])` instead.\n  - Fixed formatting numbers as scientific notation in some cases returning\n    a zero digit left from the decimal point. (like \"0.33333e8\" rather than\n    \"3.3333e7\"). Thanks @husayt.\n- Implemented a function `print` to interpolate values in a template string,\n  this functionality was moved from the function `format`.\n- Implemented statistics function `mean`. Thanks Guillermo Indalecio Fernandez\n  (@guillermobox).\n- Extended and changed `max` and `min` for multi dimensional matrices: they now\n  return the maximum and minimum of the flattened array. An optional second\n  argument `dim` allows to calculate the `max` or `min` for specified dimension.\n- Renamed option `math.options.matrix.default` to\n  `math.options.matrix.defaultType`.\n- Removed support for comparing complex numbers in functions `smaller`,\n  `smallereq`, `larger`, `largereq`. Complex numbers cannot be ordered.\n\n\n## 2013-10-08, version 0.14.0\n\n- Introduced an option `math.options.matrix.default` which can have values\n  `matrix` (default) or `array`. This option is used by the functions `eye`,\n  `ones`, `range`, and `zeros`, to determine the type of matrix output.\n- Getting a subset of a matrix will automatically squeeze the resulting subset,\n  setting a subset of a matrix will automatically unsqueeze the given subset.\n- Removed concatenation of nested arrays in the expression parser.\n  You can now input nested arrays like in JavaScript. Matrices can be\n  concatenated using the function `concat`.\n- The matrix syntax `[...]` in the expression parser now creates 1 dimensional\n  matrices by default. `math.eval('[1,2,3,4]')` returns a matrix with\n  size `[4]`, `math.eval('[1,2;3,4]')` returns a matrix with size `[2,2]`.\n- Documentation is restructured and extended.\n- Fixed non working operator `mod` (modulus operator).\n\n\n## 2013-09-03, version 0.13.0\n\n- Implemented support for booleans in all relevant functions.\n- Implemented functions `map` and `forEach`. Thanks Sebastien Piquemal (@sebpic).\n- All construction functions can be used to convert the type of variables,\n  also element-wise for all elements in an Array or Matrix.\n- Changed matrix indexes of the expression parser to one-based with the\n  upper-bound included, similar to most math applications. Note that on a\n  JavaScript level, math.js uses zero-based indexes with excluded upper-bound.\n- Removed support for scalars in the function `subset`, it now only supports\n  Array, Matrix, and String.\n- Removed the functions `get` and `set` from a selector, they are a duplicate\n  of the function `subset`.\n- Replaced functions `get` and `set` of `Matrix` with a single function\n  `subset`.\n- Some moving around with code and namespaces:\n  - Renamed namespace `math.expr` to `math.expression` (contains Scope, Parser,\n    node objects).\n  - Renamed namespace `math.docs` to `math.expression.docs`.\n  - Moved `math.expr.Selector` to `math.chaining.Selector`.\n- Fixed some edge cases in functions `lcm` and `xgcd`.\n\n\n## 2013-08-22, version 0.12.1\n\n- Fixed outdated version of README.md.\n- Fixed a broken unit test.\n\n\n## 2013-08-22, version 0.12.0\n\n- Implemented functions `random([min, max])`, `randomInt([min, max])`,\n  `pickRandom(array)`. Thanks Sebastien Piquemal (@sebpic).\n- Implemented function `distribution(name)`, generating a distribution object\n  with functions `random`, `randomInt`, `pickRandom` for different\n  distributions. Currently supporting `uniform` and `normal`.\n- Changed the behavior of `range` to exclude the upper bound, so `range(1, 4)`\n  now returns `[1, 2, 3]` instead of `[1, 2, 3, 4]`.\n- Changed the syntax of `range`, which is now `range(start, end [, step])`\n  instead of `range(start, [step, ] end)`.\n- Changed the behavior of `ones` and `zeros` to geometric dimensions, for\n  example `ones(3)` returns a vector with length 3, filled with ones, and\n  `ones(3,3)` returns a 2D array with size [3, 3].\n- Changed the return type of `ones` and `zeros`: they now return an Array when\n  arguments are Numbers or an Array, and returns a Matrix when the argument\n  is a Matrix.\n- Change matrix index notation in parser from round brackets to square brackets,\n  for example `A[0, 0:3]`.\n- Removed the feature introduced in v0.10.0 to automatically convert a complex\n  value with an imaginary part equal to zero to a number.\n- Fixed zeros being formatted as null. Thanks @TimKraft.\n\n\n## 2013-07-23, version 0.11.1\n\n- Fixed missing development dependency\n\n\n## 2013-07-23, version 0.11.0\n\n- Changed math.js from one-based to zero-based indexes.\n  - Getting and setting matrix subset is now zero-based.\n  - The dimension argument in function `concat` is now zero-based.\n- Improvements in the string output of function help.\n- Added constants `true` and `false`.\n- Added constructor function `boolean`.\n- Fixed function `select` not accepting `0` as input.\n  Thanks Elijah Manor (@elijahmanor).\n- Parser now supports multiple unary minus operators after each other.\n- Fixed not accepting empty matrices like `[[], []]`.\n- Some fixes in the end user documentation.\n\n\n## 2013-07-08, version 0.10.0\n\n- For complex calculations, all functions now automatically replace results\n  having an imaginary part of zero with a Number. (`2i * 2i` now returns a\n  Number `-4` instead of a Complex `-4 + 0i`).\n- Implemented support for injecting custom node handlers in the parser. Can be\n  used for example to implement a node handler for plotting a graph.\n- Implemented end user documentation and a new `help` function.\n- Functions `size` and `squeeze` now return a Matrix instead of an Array as\n  output on Matrix input.\n- Added a constant tau (2 * pi). Thanks Zak Zibrat (@palimpsests).\n- Renamed function `unaryminus` to `unary`.\n- Fixed a bug in determining node dependencies in function assignments.\n\n\n## 2013-06-14, version 0.9.1\n\n- Implemented element-wise functions and operators: `emultiply` (`x .* y`),\n  `edivide` (`x ./ y`), `epow` (`x .^ y`).\n- Added constants `Infinity` and `NaN`.\n- Removed support for Workspace to keep the library focused on its core task.\n- Fixed a bug in the Complex constructor, not accepting NaN values.\n- Fixed division by zero in case of pure complex values.\n- Fixed a bug in function multiply multiplying a pure complex value with\n  Infinity.\n\n\n## 2013-05-29, version 0.9.0\n\n- Implemented function `math.parse(expr [,scope])`. Optional parameter scope can\n  be a plain JavaScript Object containing variables.\n- Extended function `math.expr(expr [, scope])` with an additional parameter\n  `scope`, similar to `parse`. Example: `math.eval('x^a', {x:3, a:2});`.\n- Implemented function `subset`, to get or set a subset from a matrix, string,\n  or other data types.\n- Implemented construction functions number and string (mainly useful inside\n  the parser).\n- Improved function `det`. Thanks Bryan Cuccioli (@bcuccioli).\n- Moved the parse code from prototype math.expr.Parser to function math.parse,\n  simplified Parser a little bit.\n- Strongly simplified the code of Scope and Workspace.\n- Fixed function mod for negative numerators, and added error messages in case\n  of wrong input.\n\n\n## 2013-05-18, version 0.8.2\n\n- Extended the import function and some other minor improvements.\n- Fixed a bug in merging one dimensional vectors into a matrix.\n- Fixed a bug in function subtract, when subtracting a complex number from a\n  real number.\n\n\n## 2013-05-10, version 0.8.1\n\n- Fixed an npm warning when installing mathjs globally.\n\n\n## 2013-05-10, version 0.8.0\n\n- Implemented a command line interface. When math.js is installed globally via\n  npm, the application is available on your system as 'mathjs'.\n- Implemented `end` keyword for index operator, and added support for implicit\n  start and end (expressions like `a(2,:)` and `b(2:end,3:end-1)` are supported\n  now).\n- Function math.eval is more flexible now: it supports variables and multi-line\n  expressions.\n- Removed the read-only option from Parser and Scope.\n- Fixed non-working unequal operator != in the parser.\n- Fixed a bug in resizing matrices when replacing a subset.\n- Fixed a bug in updating a subset of a non-existing variable.\n- Minor bug fixes.\n\n\n## 2013-05-04, version 0.7.2\n\n- Fixed method unequal, which was checking for equality instead of inequality.\n  Thanks @FJS2.\n\n\n## 2013-04-27, version 0.7.1\n\n- Improvements in the parser:\n  - Added support for chained arguments.\n  - Added support for chained variable assignments.\n  - Added a function remove(name) to remove a variable from the parsers scope.\n  - Renamed nodes for more consistency and to resolve naming conflicts.\n  - Improved stringification of an expression tree.\n  - Some simplifications in the code.\n  - Minor bug fixes.\n- Fixed a bug in the parser, returning NaN instead of throwing an error for a\n  number with multiple decimal separators like `2.3.4`.\n- Fixed a bug in Workspace.insertAfter.\n- Fixed: math.js now works on IE 6-8 too.\n\n\n## 2013-04-20, version 0.7.0\n\n- Implemented method `math.eval`, which uses a readonly parser to evaluate\n  expressions.\n- Implemented method `xgcd` (extended eucledian algorithm). Thanks Bart Kiers\n  (@bkiers).\n- Improved math.format, which now rounds values to a maximum number of digits\n  instead of decimals (default is 5 digits, for example `math.format(math.pi)`\n  returns `3.1416`).\n- Added examples.\n- Changed methods square and cube to evaluate matrices element wise (consistent\n  with all other methods).\n- Changed second parameter of method import to an object with options.\n- Fixed method math.typeof on IE.\n- Minor bug fixes and improvements.\n\n\n## 2013-04-13, version 0.6.0\n\n- Implemented chained operations via method math.select(). For example\n  `math.select(3).add(4).subtract(2).done()` will return `5`.\n- Implemented methods gcd and lcm.\n- Implemented method `Unit.in(unit)`, which creates a clone of the unit with a\n  fixed representation. For example `math.unit('5.08 cm').in('inch')` will\n  return a unit which string representation always is in inch, thus `2 inch`.\n  `Unit.in(unit)` is the same as method `math.in(x, unit)`.\n- Implemented `Unit.toNumber(unit)`, which returns the value of the unit when\n  represented with given unit. For example\n  `math.unit('5.08 cm').toNumber('inch')` returns the number `2`, as the\n  representation of the unit in inches has 2 as value.\n- Improved: method `math.in(x, unit)` now supports a string as second parameter,\n  for example `math.in(math.unit('5.08 cm'), 'inch')`.\n- Split the end user documentation of the parser functions from the source\n  files.\n- Removed function help and the built-in documentation from the core library.\n- Fixed constant i being defined as -1i instead of 1i.\n- Minor bug fixes.\n\n\n## 2013-04-06, version 0.5.0\n\n- Implemented data types Matrix and Range.\n- Implemented matrix methods clone, concat, det, diag, eye, inv, ones, size,\n  squeeze, transpose, zeros.\n- Implemented range operator `:`, and transpose operator `'` in parser.\n- Changed: created construction methods for easy object creation for all data\n  types and for the parser. For example, a complex value is now created\n  with `math.complex(2, 3)` instead of `new math.Complex(2, 3)`, and a parser\n  is now created with `math.parser()` instead of `new math.parser.Parser()`.\n- Changed: moved all data types under the namespace math.type, and moved the\n  Parser, Workspace, etc. under the namespace math.expr.\n- Changed: changed operator precedence of the power operator:\n  - it is now right associative instead of left associative like most scripting\n    languages. So `2^3^4` is now calculated as `2^(3^4)`.\n  - it has now higher precedence than unary minus most languages, thus `-3^2` is\n    now calculated as `-(3^2)`.\n- Changed: renamed the parsers method 'put' into 'set'.\n- Fixed: method 'in' did not check for units to have the same base.\n\n\n## 2013-03-16, version 0.4.0\n\n- Implemented Array support for all methods.\n- Implemented Array support in the Parser.\n- Implemented method format.\n- Implemented parser for units, math.Unit.parse(str).\n- Improved parser for complex values math.Complex.parse(str);\n- Improved method help: it now evaluates the examples.\n- Fixed: a scoping issue with the Parser when defining functions.\n- Fixed: method 'typeof' was not working well with minified and mangled code.\n- Fixed: errors in determining the best prefix for a unit.\n\n\n## 2013-03-09, version 0.3.0\n\n- Implemented Workspace\n- Implemented methods cot, csc, sec.\n- Implemented Array support for methods with one parameter.\n\n\n## 2013-02-25, version 0.2.0\n\n- Parser, Scope, and expression tree with Nodes implemented.\n- Implemented method import which makes it easy to extend math.js.\n- Implemented methods arg, conj, cube, equal, factorial, im, largereq,\n  log(x, base), log10, mod, re, sign, smallereq, square, unequal.\n\n\n## 2013-02-18, version 0.1.0\n\n- Reached full compatibility with Javascripts built-in Math library.\n- More functions implemented.\n- Some bugfixes.\n\n\n## 2013-02-16, version 0.0.2\n\n- All constants of Math implemented, plus the imaginary unit i.\n- Data types Complex and Unit implemented.\n- First set of functions implemented.\n\n\n## 2013-02-15, version 0.0.1\n\n- First publish of the mathjs package. (package is still empty)\n", "'use strict';\n\nvar ArgumentsError = require('../error/ArgumentsError');\nvar deepMap = require('../utils/collection/deepMap');\n\nfunction factory (type, config, load, typed) {\n  var AccessorNode            = load(require('./node/AccessorNode'));\n  var ArrayNode               = load(require('./node/ArrayNode'));\n  var AssignmentNode          = load(require('./node/AssignmentNode'));\n  var BlockNode               = load(require('./node/BlockNode'));\n  var ConditionalNode         = load(require('./node/ConditionalNode'));\n  var ConstantNode            = load(require('./node/ConstantNode'));\n  var FunctionAssignmentNode  = load(require('./node/FunctionAssignmentNode'));\n  var IndexNode               = load(require('./node/IndexNode'));\n  var ObjectNode              = load(require('./node/ObjectNode'));\n  var OperatorNode            = load(require('./node/OperatorNode'));\n  var ParenthesisNode         = load(require('./node/ParenthesisNode'));\n  var FunctionNode            = load(require('./node/FunctionNode'));\n  var RangeNode               = load(require('./node/RangeNode'));\n  var SymbolNode              = load(require('./node/SymbolNode'));\n\n\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.eval();\n   *\n   * Syntax:\n   *\n   *     parse(expr)\n   *     parse(expr, options)\n   *     parse([expr1, expr2, expr3, ...])\n   *     parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     var node = parse('sqrt(3^2 + 4^2)');\n   *     node.compile(math).eval(); // 5\n   *\n   *     var scope = {a:3, b:4}\n   *     var node = parse('a * b'); // 12\n   *     var code = node.compile(math);\n   *     code.eval(scope); // 12\n   *     scope.a = 5;\n   *     code.eval(scope); // 20\n   *\n   *     var nodes = math.parse(['a = 3', 'b = 4', 'a * b']);\n   *     nodes[2].compile(math).eval(); // 12\n   *\n   * @param {string | string[] | Matrix} expr\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n  function parse (expr, options) {\n    if (arguments.length != 1 && arguments.length != 2) {\n      throw new ArgumentsError('parse', arguments.length, 1, 2);\n    }\n\n    // pass extra nodes\n    extra_nodes = (options && options.nodes) ? options.nodes : {};\n\n    if (typeof expr === 'string') {\n      // parse a single expression\n      expression = expr;\n      return parseStart();\n    }\n    else if (Array.isArray(expr) || expr instanceof type.Matrix) {\n      // parse an array or matrix with expressions\n      return deepMap(expr, function (elem) {\n        if (typeof elem !== 'string') throw new TypeError('String expected');\n\n        expression = elem;\n        return parseStart();\n      });\n    }\n    else {\n      // oops\n      throw new TypeError('String or matrix expected');\n    }\n  }\n\n  // token types enumeration\n  var TOKENTYPE = {\n    NULL : 0,\n    DELIMITER : 1,\n    NUMBER : 2,\n    SYMBOL : 3,\n    UNKNOWN : 4\n  };\n\n  // map with all delimiters\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\\\"': true,\n    ';': true,\n\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '\\'': true,\n    '=': true,\n    ':': true,\n    '?': true,\n\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  };\n\n  // map with all named delimiters\n  var NAMED_DELIMITERS = {\n    'mod': true,\n    'to': true,\n    'in': true,\n    'and': true,\n    'xor': true,\n    'or': true,\n    'not': true\n  };\n\n  var extra_nodes = {};             // current extra nodes\n  var expression = '';              // current expression\n  var comment = '';                 // last parsed comment\n  var index = 0;                    // current index in expr\n  var c = '';                       // current token character in expr\n  var token = '';                   // current token\n  var token_type = TOKENTYPE.NULL;  // type of the token\n  var nesting_level = 0;            // level of nesting inside parameters, used to ignore newline characters\n  var conditional_level = null;     // when a conditional is being parsed, the level of the conditional is stored here\n\n  /**\n   * Get the first character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n  function first() {\n    index = 0;\n    c = expression.charAt(0);\n    nesting_level = 0;\n    conditional_level = null;\n  }\n\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n  function next() {\n    index++;\n    c = expression.charAt(index);\n  }\n\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function prevPreview() {\n    return expression.charAt(index - 1);\n  }\n\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function nextPreview() {\n    return expression.charAt(index + 1);\n  }\n\n  /**\n   * Preview the second next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function nextNextPreview() {\n    return expression.charAt(index + 2);\n  }\n\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and token_type\n   * @private\n   */\n  function getToken() {\n    token_type = TOKENTYPE.NULL;\n    token = '';\n    comment = '';\n\n    // skip over whitespaces\n    // space, tab, and newline when inside parameters\n    while (parse.isWhitespace(c, nesting_level)) {\n      next();\n    }\n\n    // skip comment\n    if (c == '#') {\n      while (c != '\\n' && c != '') {\n        comment += c;\n        next();\n      }\n    }\n\n    // check for end of expression\n    if (c == '') {\n      // token is still empty\n      token_type = TOKENTYPE.DELIMITER;\n      return;\n    }\n\n    // check for new line character\n    if (c == '\\n' && !nesting_level) {\n      token_type = TOKENTYPE.DELIMITER;\n      token = c;\n      next();\n      return;\n    }\n\n    // check for delimiters consisting of 3 characters\n    var c2 = c + nextPreview();\n    var c3 = c2 + nextNextPreview();\n    if (c3.length == 3 && DELIMITERS[c3]) {\n      token_type = TOKENTYPE.DELIMITER;\n      token = c3;\n      next();\n      next();\n      next();\n      return;\n    }\n\n    // check for delimiters consisting of 2 characters\n    if (c2.length == 2 && DELIMITERS[c2]) {\n      token_type = TOKENTYPE.DELIMITER;\n      token = c2;\n      next();\n      next();\n      return;\n    }\n\n    // check for delimiters consisting of 1 character\n    if (DELIMITERS[c]) {\n      token_type = TOKENTYPE.DELIMITER;\n      token = c;\n      next();\n      return;\n    }\n\n    // check for a number\n    if (parse.isDigitDot(c)) {\n      token_type = TOKENTYPE.NUMBER;\n\n      // get number, can have a single dot\n      if (c == '.') {\n        token += c;\n        next();\n\n        if (!parse.isDigit(c)) {\n          // this is no number, it is just a dot (can be dot notation)\n          token_type = TOKENTYPE.DELIMITER;\n        }\n      }\n      else {\n        while (parse.isDigit(c)) {\n          token += c;\n          next();\n        }\n        if (parse.isDecimalMark(c, nextPreview())) {\n          token += c;\n          next();\n        }\n      }\n      while (parse.isDigit(c)) {\n        token += c;\n        next();\n      }\n\n      // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n      c2 = nextPreview();\n      if (c == 'E' || c == 'e') {\n        if (parse.isDigit(c2) || c2 == '-' || c2 == '+') {\n          token += c;\n          next();\n\n          if (c == '+' || c == '-') {\n            token += c;\n            next();\n          }\n\n          // Scientific notation MUST be followed by an exponent\n          if (!parse.isDigit(c)) {\n            throw createSyntaxError('Digit expected, got \"' + c + '\"');\n          }\n\n          while (parse.isDigit(c)) {\n            token += c;\n            next();\n          }\n\n          if (parse.isDecimalMark(c, nextPreview())) {\n            throw createSyntaxError('Digit expected, got \"' + c + '\"');\n          }\n        }\n        else if (c2 == '.') {\n          next();\n          throw createSyntaxError('Digit expected, got \"' + c + '\"');\n        }\n      }\n\n      return;\n    }\n\n    // check for variables, functions, named operators\n    if (parse.isAlpha(c, prevPreview(), nextPreview())) {\n      while (parse.isAlpha(c, prevPreview(), nextPreview()) || parse.isDigit(c)) {\n        token += c;\n        next();\n      }\n\n      if (NAMED_DELIMITERS.hasOwnProperty(token)) {\n        token_type = TOKENTYPE.DELIMITER;\n      }\n      else {\n        token_type = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    }\n\n    // something unknown is found, wrong characters -> a syntax error\n    token_type = TOKENTYPE.UNKNOWN;\n    while (c != '') {\n      token += c;\n      next();\n    }\n    throw createSyntaxError('Syntax error in part \"' + token + '\"');\n  }\n\n  /**\n   * Get next token and skip newline tokens\n   */\n  function getTokenSkipNewline () {\n    do {\n      getToken();\n    }\n    while (token == '\\n');\n  }\n\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams() is called\n   */\n  function openParams() {\n    nesting_level++;\n  }\n\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n  function closeParams() {\n    nesting_level--;\n  }\n\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n  parse.isAlpha = function isAlpha (c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c)\n        || parse.isValidMathSymbol(c, cNext)\n        || parse.isValidMathSymbol(cPrev, c);\n  };\n\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek (c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * http://unicode-table.com/en/\n   * http://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * http://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n  parse.isValidMathSymbol = function isValidMathSymbol (high, low) {\n    return /^[\\uD835]$/.test(high) &&\n        /^[\\uDC00-\\uDFFF]$/.test(low) &&\n        /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n  parse.isWhitespace = function isWhitespace (c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c == ' ' || c == '\\t' || (c == '\\n' && nestingLevel > 0);\n  };\n\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n  parse.isDecimalMark = function isDecimalMark (c, cNext) {\n    return c == '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n  parse.isDigitDot = function isDigitDot (c) {\n    return ((c >= '0' && c <= '9') || c == '.');\n  };\n\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n  parse.isDigit = function isDigit (c) {\n    return (c >= '0' && c <= '9');\n  };\n\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n  function parseStart () {\n    // get the first character in expression\n    first();\n\n    getToken();\n\n    var node = parseBlock();\n\n    // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and token_type DELIMITER\n    if (token != '') {\n      if (token_type == TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean != ?\"\n        throw createError('Unexpected operator ' + token);\n      }\n      else {\n        throw createSyntaxError('Unexpected part \"' + token + '\"');\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n  function parseBlock () {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (token != '' && token != '\\n' && token != ';') {\n      node = parseAssignment();\n      node.comment = comment;\n    }\n\n    // TODO: simplify this loop\n    while (token == '\\n' || token == ';') {\n      if (blocks.length == 0 && node) {\n        visible = (token != ';');\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n\n      getToken();\n      if (token != '\\n' && token != ';' && token != '') {\n        node = parseAssignment();\n        node.comment = comment;\n\n        visible = (token != ';');\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    }\n    else {\n      if (!node) {\n        node = new ConstantNode('undefined', 'undefined');\n        node.comment = comment;\n      }\n\n      return node\n    }\n  }\n\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n  function parseAssignment () {\n    var name, args, value, valid;\n\n    var node = parseConditional();\n\n    if (token == '=') {\n      if (type.isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline();\n        value = parseAssignment();\n        return new AssignmentNode(new SymbolNode(name), value);\n      }\n      else if (type.isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline();\n        value = parseAssignment();\n        return new AssignmentNode(node.object, node.index, value);\n      }\n      else if (type.isFunctionNode(node)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (type.isSymbolNode(arg)) {\n            args[index] = arg.name;\n          }\n          else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline();\n          value = parseAssignment();\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError('Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n  function parseConditional () {\n    var node = parseLogicalOr();\n\n    while (token == '?') {\n      // set a conditional level, the range operator will be ignored as long\n      // as conditional_level == nesting_level.\n      var prev = conditional_level;\n      conditional_level = nesting_level;\n      getTokenSkipNewline();\n\n      var condition = node;\n      var trueExpr = parseAssignment();\n\n      if (token != ':') throw createSyntaxError('False part of conditional expression expected');\n\n      conditional_level = null;\n      getTokenSkipNewline();\n\n      var falseExpr = parseAssignment(); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr);\n\n      // restore the previous conditional level\n      conditional_level = prev;\n    }\n\n    return node;\n  }\n\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalOr() {\n    var node = parseLogicalXor();\n\n    while (token == 'or') {\n      getTokenSkipNewline();\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalXor() {\n    var node = parseLogicalAnd();\n\n    while (token == 'xor') {\n      getTokenSkipNewline();\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalAnd() {\n    var node = parseBitwiseOr();\n\n    while (token == 'and') {\n      getTokenSkipNewline();\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseOr() {\n    var node = parseBitwiseXor();\n\n    while (token == '|') {\n      getTokenSkipNewline();\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseXor() {\n    var node = parseBitwiseAnd();\n\n    while (token == '^|') {\n      getTokenSkipNewline();\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseAnd () {\n    var node = parseRelational();\n\n    while (token == '&') {\n      getTokenSkipNewline();\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * relational operators\n   * @return {Node} node\n   * @private\n   */\n  function parseRelational () {\n    var node, operators, name, fn, params;\n\n    node = parseShift();\n\n    operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getTokenSkipNewline();\n      params = [node, parseShift()];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n  function parseShift () {\n    var node, operators, name, fn, params;\n\n    node = parseConversion();\n\n    operators = {\n      '<<' : 'leftShift',\n      '>>' : 'rightArithShift',\n      '>>>' : 'rightLogShift'\n    };\n\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getTokenSkipNewline();\n      params = [node, parseConversion()];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n  function parseConversion () {\n    var node, operators, name, fn, params;\n\n    node = parseRange();\n\n    operators = {\n      'to' : 'to',\n      'in' : 'to'   // alias of 'to'\n    };\n\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getTokenSkipNewline();\n      \n      if (name === 'in' && token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      }\n      else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange()];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n  function parseRange () {\n    var node, params = [];\n\n    if (token == ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode('1', 'number');\n    }\n    else {\n      // explicit start\n      node = parseAddSubtract();\n    }\n\n    if (token == ':' && (conditional_level !== nesting_level)) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node);\n\n      // parse step and end\n      while (token == ':' && params.length < 3) {\n        getTokenSkipNewline();\n\n        if (token == ')' || token == ']' || token == ',' || token == '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        }\n        else {\n          // explicit end\n          params.push(parseAddSubtract());\n        }\n      }\n\n      if (params.length == 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      }\n      else { // length == 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n  function parseAddSubtract ()  {\n    var node, operators, name, fn, params;\n\n    node = parseMultiplyDivide();\n\n    operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getTokenSkipNewline();\n      params = [node, parseMultiplyDivide()];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n  function parseMultiplyDivide () {\n    var node, last, operators, name, fn;\n\n    node = parseUnary();\n    last = node;\n\n    operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide',\n      '%': 'mod',\n      'mod': 'mod'\n    };\n\n    while (true) {\n      if (operators.hasOwnProperty(token)) {\n        // explicit operators\n        name = token;\n        fn = operators[name];\n\n        getTokenSkipNewline();\n\n        last = parseUnary();\n        node = new OperatorNode(name, fn, [node, last]);\n      }\n      else if ((token_type === TOKENTYPE.SYMBOL) ||\n          (token === 'in' && type.isConstantNode(node)) ||\n          (token_type === TOKENTYPE.NUMBER &&\n              !type.isConstantNode(last) &&\n              (!type.isOperatorNode(last) || last.op === '!')) ||\n          (token === '(')) {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseUnary();\n        node = new OperatorNode('*', 'multiply', [node, last], true /*implicit*/);\n      }\n      else {\n        break;\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n  function parseUnary () {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      'not': 'not'\n    };\n\n    if (operators.hasOwnProperty(token)) {\n      fn = operators[token];\n      name = token;\n\n      getTokenSkipNewline();\n      params = [parseUnary()];\n\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow();\n  }\n\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n  function parsePow () {\n    var node, name, fn, params;\n\n    node = parseLeftHandOperators();\n\n    if (token == '^' || token == '.^') {\n      name = token;\n      fn = (name == '^') ? 'pow' : 'dotPow';\n\n      getTokenSkipNewline();\n      params = [node, parseUnary()]; // Go back to unary, we can have '2^-3'\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n\n  /**\n   * Left hand operators: factorial x!, transpose x'\n   * @return {Node} node\n   * @private\n   */\n  function parseLeftHandOperators ()  {\n    var node, operators, name, fn, params;\n\n    node = parseCustomNodes();\n\n    operators = {\n      '!': 'factorial',\n      '\\'': 'transpose'\n    };\n\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getToken();\n      params = [node];\n\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(node);\n    }\n\n    return node;\n  }\n\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.expression.node.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     };\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params);\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes);\n   *\n   * @return {Node} node\n   * @private\n   */\n  function parseCustomNodes () {\n    var params = [];\n\n    if (token_type == TOKENTYPE.SYMBOL && extra_nodes.hasOwnProperty(token)) {\n      var CustomNode = extra_nodes[token];\n\n      getToken();\n\n      // parse parameters\n      if (token == '(') {\n        params = [];\n\n        openParams();\n        getToken();\n\n        if (token != ')') {\n          params.push(parseAssignment());\n\n          // parse a list with parameters\n          while (token == ',') {\n            getToken();\n            params.push(parseAssignment());\n          }\n        }\n\n        if (token != ')') {\n          throw createSyntaxError('Parenthesis ) expected');\n        }\n        closeParams();\n        getToken();\n      }\n\n      // create a new custom node\n      //noinspection JSValidateTypes\n      return new CustomNode(params);\n    }\n\n    return parseSymbol();\n  }\n\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n  function parseSymbol () {\n    var node, name;\n\n    if (token_type == TOKENTYPE.SYMBOL ||\n        (token_type == TOKENTYPE.DELIMITER && token in NAMED_DELIMITERS)) {\n      name = token;\n\n      getToken();\n\n      // parse function parameters and matrix index\n      node = new SymbolNode(name);\n      node = parseAccessors(node);\n      return node;\n    }\n\n    return parseString();\n  }\n\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2)\n   * - index enclosed in square brackets [...], for example A[2,3]\n   * - dot notation for properties, like foo.bar\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n  function parseAccessors (node, types) {\n    var params;\n\n    while ((token === '(' || token === '[' || token === '.') &&\n        (!types || types.indexOf(token) !== -1)) {\n      params = [];\n\n      if (token === '(') {\n        if (type.isSymbolNode(node) || type.isAccessorNode(node) || type.isFunctionNode(node)) {\n          // function invocation like fn(2, 3)\n          openParams();\n          getToken();\n\n          if (token !== ')') {\n            params.push(parseAssignment());\n\n            // parse a list with parameters\n            while (token === ',') {\n              getToken();\n              params.push(parseAssignment());\n            }\n          }\n\n          if (token !== ')') {\n            throw createSyntaxError('Parenthesis ) expected');\n          }\n          closeParams();\n          getToken();\n\n          node = new FunctionNode(node, params);\n        }\n        else {\n          // implicit multiplication like (2+3)(4+5)\n          // don't parse it here but let it be handled by parseMultiplyDivide\n          // with correct precedence\n          return node;\n        }\n      }\n      else if (token === '[') {\n        // index notation like variable[2, 3]\n        openParams();\n        getToken();\n\n        if (token !== ']') {\n          params.push(parseAssignment());\n\n          // parse a list with parameters\n          while (token === ',') {\n            getToken();\n            params.push(parseAssignment());\n          }\n        }\n\n        if (token !== ']') {\n          throw createSyntaxError('Parenthesis ] expected');\n        }\n        closeParams();\n        getToken();\n\n        node = new AccessorNode(node, new IndexNode(params));\n      }\n      else {\n        // dot notation like variable.prop\n        getToken();\n\n        if (token_type !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError('Property name expected after dot');\n        }\n        params.push(new ConstantNode(token));\n        getToken();\n\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * parse a string.\n   * A string is enclosed by double quotes\n   * @return {Node} node\n   * @private\n   */\n  function parseString () {\n    var node, str;\n\n    if (token == '\"') {\n      str = parseStringToken();\n\n      // create constant\n      node = new ConstantNode(str, 'string');\n\n      // parse index parameters\n      node = parseAccessors(node);\n\n      return node;\n    }\n\n    return parseMatrix();\n  }\n\n  /**\n   * Parse a string surrounded by double quotes \"...\"\n   * @return {string}\n   */\n  function parseStringToken () {\n    var str = '';\n\n    while (c != '' && c != '\\\"') {\n      if (c == '\\\\') {\n        // escape character\n        str += c;\n        next();\n      }\n\n      str += c;\n      next();\n    }\n\n    getToken();\n    if (token != '\"') {\n      throw createSyntaxError('End of string \" expected');\n    }\n    getToken();\n\n    return str;\n  }\n\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n  function parseMatrix () {\n    var array, params, rows, cols;\n\n    if (token == '[') {\n      // matrix [...]\n      openParams();\n      getToken();\n\n      if (token != ']') {\n        // this is a non-empty matrix\n        var row = parseRow();\n\n        if (token == ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row];\n\n          // the rows of the matrix are separated by dot-comma's\n          while (token == ';') {\n            getToken();\n\n            params[rows] = parseRow();\n            rows++;\n          }\n\n          if (token != ']') {\n            throw createSyntaxError('End of matrix ] expected');\n          }\n          closeParams();\n          getToken();\n\n          // check if the number of columns matches in all rows\n          cols = params[0].items.length;\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length != cols) {\n              throw createError('Column dimensions mismatch ' +\n                  '(' + params[r].items.length + ' != ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        }\n        else {\n          // 1 dimensional vector\n          if (token != ']') {\n            throw createSyntaxError('End of matrix ] expected');\n          }\n          closeParams();\n          getToken();\n\n          array = row;\n        }\n      }\n      else {\n        // this is an empty matrix \"[ ]\"\n        closeParams();\n        getToken();\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(array);\n    }\n\n    return parseObject();\n  }\n\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n  function parseRow () {\n    var params = [parseAssignment()];\n    var len = 1;\n\n    while (token == ',') {\n      getToken();\n\n      // parse expression\n      params[len] = parseAssignment();\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n  function parseObject () {\n    if (token == '{') {\n      var key;\n\n      var properties = {};\n      do {\n        getToken();\n\n        if (token != '}') {\n          // parse key\n          if (token == '\"') {\n            key = parseStringToken();\n          }\n          else if (token_type == TOKENTYPE.SYMBOL) {\n            key = token;\n            getToken();\n          }\n          else {\n            throw createSyntaxError('Symbol or string expected as object key');\n          }\n\n          // parse key/value separator\n          if (token != ':') {\n            throw createSyntaxError('Colon : expected after object key');\n          }\n          getToken();\n\n          // parse key\n          properties[key] = parseAssignment();\n        }\n      }\n      while (token == ',');\n\n      if (token != '}') {\n        throw createSyntaxError('Comma , or bracket } expected after object value');\n      }\n      getToken();\n\n      var node = new ObjectNode(properties);\n\n      // parse index parameters\n      node = parseAccessors(node);\n\n      return node;\n    }\n\n    return parseNumber();\n  }\n\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n  function parseNumber () {\n    var number;\n\n    if (token_type == TOKENTYPE.NUMBER) {\n      // this is a number\n      number = token;\n      getToken();\n\n      return new ConstantNode(number, 'number');\n    }\n\n    return parseParentheses();\n  }\n\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n  function parseParentheses () {\n    var node;\n\n    // check if it is a parenthesized expression\n    if (token == '(') {\n      // parentheses (...)\n      openParams();\n      getToken();\n\n      node = parseAssignment(); // start again\n\n      if (token != ')') {\n        throw createSyntaxError('Parenthesis ) expected');\n      }\n      closeParams();\n      getToken();\n\n      node = new ParenthesisNode(node);\n      node = parseAccessors(node);\n      return node;\n    }\n\n    return parseEnd();\n  }\n\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n  function parseEnd () {\n    if (token == '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError('Unexpected end of expression');\n    } else if (token === \"'\") {\n      throw createSyntaxError('Value expected. Note: strings must be enclosed by double quotes');\n    } else {\n      throw createSyntaxError('Value expected');\n    }\n  }\n\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null;\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last token starts\n   * @private\n   */\n  function col () {\n    return index - token.length + 1;\n  }\n\n  /**\n   * Create an error\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n  function createSyntaxError (message) {\n    var c = col();\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error['char'] = c;\n\n    return error;\n  }\n\n  /**\n   * Create an error\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n  function createError (message) {\n    var c = col();\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error['char'] = c;\n\n    return error;\n  }\n\n  return parse;\n}\n\nexports.name = 'parse';\nexports.path = 'expression';\nexports.factory = factory;\n", "{\n  \"name\": \"mathjs\",\n  \"version\": \"3.16.5\",\n  \"description\": \"Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices.\",\n  \"author\": \"Jos de Jong <wjosdejong@gmail.com> (https://github.com/josdejong)\",\n  \"contributors\": [\n    \"Adam Kelly (https://github.com/adamisntdead)\",\n    \"Alexander Beyn (https://github.com/AlexanderBeyn)\",\n    \"Andy Pan (https://github.com/andy0130tw)\",\n    \"Bart Kiers (https://github.com/bkiers)\",\n    \"Brett Jurgens (https://github.com/brettjurgens)\",\n    \"Bryan Cuccioli (https://github.com/bcuccioli)\",\n    \"Daniel Levin (https://github.com/daniel-levin)\",\n    \"David Simons (https://github.com/SwamWithTurtles)\",\n    \"Devan Patel (https://github.com/devanp92)\",\n    \"devdevdata222 (https://github.com/devdevdata222)\",\n    \"Dzmitry Litskalau (https://github.com/litmit)\",\n    \"Ekin Koc (https://github.com/eknkc)\",\n    \"Elijah Insua (https://github.com/tmpvar)\",\n    \"Eric Mansfield (https://github.com/ericman314)\",\n    \"Fabrice Colas (https://github.com/fabricecolas)\",\n    \"Favian Contreras (https://github.com/BigFav)\",\n    \"Finn Pauls (https://github.com/finnp)\",\n    \"Ganga Christopher (https://github.com/gangachris)\",\n    \"Harry Sarson (https://github.com/HarrySarson)\",\n    \"Holman Gao (https://github.com/golmansax)\",\n    \"Guillermo Indalecio Fern\u00e1ndez (https://github.com/guillermobox)\",\n    \"Gulfaraz (https://github.com/gulfaraz)\",\n    \"hamadu (https://github.com/hamadu)\",\n    \"Harsh Gupta (https://github.com/hgupta9)\",\n    \"Huseyn Guliyev (https://github.com/husayt)\",\n    \"Ivan Vergiliev (IvanVergiliev)\",\n    \"Jim Garrison (https://github.com/garrison)\",\n    \"Karl Lew (https://github.com/firepick1)\",\n    \"Kenan Yildirim (https://github.com/KenanY)\",\n    \"Keunhong Park (https://github.com/void42)\",\n    \"Kunal Vyas (https://github.com/kv-kunalvyas)\",\n    \"Marcus Andre (https://github.com/marcusandre)\",\n    \"Horatiu Lazu (https://github.com/MathBunny)\",\n    \"Mathias Polligkeit (https://github.com/woylie)\",\n    \"Max Bruckner (https://github.com/FSMaxB)\",\n    \"Maxence Dalmais (https://github.com/maxired)\",\n    \"Michael M. (https://github.com/Schnark)\",\n    \"Mitchel Kelonye (https://github.com/kelonye)\",\n    \"mtraynham (https://github.com/mtraynham)\",\n    \"Niels Heisterkamp (https://github.com/nheisterkamp)\",\n    \"Owen Versteeg (https://github.com/owenversteeg)\",\n    \"Pavel Panchekha (https://github.com/pavpanchekha)\",\n    \"Pat Grasso (https://github.com/patgrasso)\",\n    \"Pete Corey (https://github.com/pcorey)\",\n    \"PJ Hampton (https://github.com/pjhampton )\",\n    \"Retsam (https://github.com/Retsam)\",\n    \"Robert Eisele (https://github.com/infusion)\",\n    \"Rogelio J. Baucells (https://github.com/rjbaucells)\",\n    \"Ryan Seys (https://github.com/ryanseys)\",\n    \"Sebastien Piquemal (https://github.com/sebpiq)\",\n    \"Sebastian Ruhleder (https://github.com/ruhleder)\",\n    \"Sergey Romanov (https://github.com/saromanov)\",\n    \"Slava Ganzin (https://github.com/slavaGanzin)\",\n    \"Stu Blair (https://github.com/stu-blair)\",\n    \"Thomas Brierley (https://github.com/ThomasBrierley)\",\n    \"Timothy Lee (https://github.com/tetslee)\",\n    \"T\u00f3th R\u00f3bert (https://github.com/Nekomajin42)\",\n    \"Todd Morse (https://github.com/morsecodist)\",\n    \"Waldir Pimenta (https://github.com/waldyrious)\",\n    \"Zach Zibrat (https://github.com/palimpsests)\"\n  ],\n  \"homepage\": \"http://mathjs.org\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/josdejong/mathjs.git\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"keywords\": [\n    \"math\",\n    \"mathematics\",\n    \"functions\",\n    \"numeric\",\n    \"algebra\",\n    \"parser\",\n    \"expression\",\n    \"number\",\n    \"bignumber\",\n    \"complex\",\n    \"fraction\",\n    \"matrix\",\n    \"unit\"\n  ],\n  \"dependencies\": {\n    \"complex.js\": \"2.0.4\",\n    \"decimal.js\": \"7.2.3\",\n    \"fraction.js\": \"4.0.2\",\n    \"javascript-natural-sort\": \"0.7.1\",\n    \"seed-random\": \"2.2.0\",\n    \"tiny-emitter\": \"2.0.0\",\n    \"typed-function\": \"0.10.5\"\n  },\n  \"devDependencies\": {\n    \"benchmark\": \"2.1.4\",\n    \"expr-eval\": \"1.0.1\",\n    \"glob\": \"7.1.2\",\n    \"gulp\": \"3.9.1\",\n    \"gulp-util\": \"3.0.8\",\n    \"istanbul\": \"0.4.5\",\n    \"jsep\": \"0.3.0\",\n    \"math-expression-evaluator\": \"1.2.17\",\n    \"mkdirp\": \"0.5.1\",\n    \"mocha\": \"3.4.2\",\n    \"ndarray\": \"1.0.18\",\n    \"ndarray-determinant\": \"1.0.0\",\n    \"ndarray-gemm\": \"1.0.0\",\n    \"ndarray-ops\": \"1.2.2\",\n    \"ndarray-pack\": \"1.2.1\",\n    \"numericjs\": \"1.2.6\",\n    \"pad-right\": \"0.2.2\",\n    \"q\": \"1.5.0\",\n    \"sylvester\": \"0.0.21\",\n    \"tar\": \"2.2.1\",\n    \"uglify-js\": \"2.7.5\",\n    \"underscore\": \"1.8.3\",\n    \"webpack\": \"2.6.1\",\n    \"zeros\": \"1.0.0\"\n  },\n  \"main\": \"./index\",\n  \"scripts\": {\n    \"build\": \"gulp\",\n    \"watch\": \"gulp watch\",\n    \"docs\": \"gulp docs\",\n    \"test\": \"mocha test --recursive\",\n    \"coverage\": \"istanbul cover _mocha -- test --recursive; echo \\\"\\nCoverage report is available at ./coverage/lcov-report/index.html\\\"\"\n  },\n  \"bin\": {\n    \"mathjs\": \"./bin/cli.js\"\n  },\n  \"engines\": {\n    \"node\": \">= 0.1\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/josdejong/mathjs/issues\"\n  },\n  \"directories\": {\n    \"doc\": \"docs\",\n    \"example\": \"examples\",\n    \"lib\": \"lib\",\n    \"test\": \"test\"\n  }\n}\n", "// test parse\nvar assert = require('assert');\nvar approx = require('../../tools/approx');\nvar math = require('../../index');\nvar ArgumentsError = require('../../lib/error/ArgumentsError');\nvar parse = math.expression.parse;\nvar ConditionalNode = math.expression.node.ConditionalNode;\nvar OperatorNode = math.expression.node.OperatorNode;\nvar RangeNode = math.expression.node.RangeNode;\nvar Complex = math.type.Complex;\nvar Matrix = math.type.Matrix;\nvar Range = math.type.Range;\nvar Unit = math.type.Unit;\nvar ResultSet = math.type.ResultSet;\n\n/**\n * Helper function to parse an expression and immediately evaluate its results\n * @param {String} expr\n * @param {Object} [scope]\n * @return {*} result\n */\nfunction parseAndEval(expr, scope) {\n  return parse(expr).eval(scope);\n}\n\ndescribe('parse', function() {\n\n  it('should parse a single expression', function() {\n    approx.equal(parse('2 + 6 / 3').compile().eval(), 4);\n  });\n\n  it('should parse an empty expression', function() {\n    assert.strictEqual(parse('').compile().eval(), undefined);\n    assert.strictEqual(parse('\\n').compile().eval(), undefined);\n    assert.strictEqual(parse('\\n\\n').compile().eval(), undefined);\n    assert.strictEqual(parse('\\n  \\n').compile().eval(), undefined);\n    assert.strictEqual(parse('#foo\\n').compile().eval(), undefined);\n    assert.strictEqual(parse('#foo\\n#bar\\n').compile().eval(), undefined);\n  });\n\n  it('should parse an array with expressions', function() {\n    var scope = {};\n    assert.deepEqual(parse(['a=3', 'b=4', 'a*b']).map(function (node) {\n      return node.compile().eval(scope);\n    }), [3, 4, 12]);\n  });\n\n  it('should parse a matrix with expressions', function() {\n    var scope = {};\n    assert.deepEqual(parse(math.matrix(['a=3', 'b=4', 'a*b'])).map(function (node) {\n      return node.compile().eval(scope);\n    }), math.matrix([3, 4, 12]));\n  });\n\n  it('should parse an array with an empty expression', function() {\n    assert.deepEqual(parse(['']).map(function (node) {\n      return node.compile().eval();\n    }), [undefined]);\n  });\n\n  it('should parse an array with an empty expression', function() {\n    assert.deepEqual(parse(math.matrix([''])).map(function (node) {\n      return node.compile().eval();\n    }), math.matrix([undefined]));\n  });\n\n  it('should parse unicode and other special characters', function() {\n    // http://unicode-table.com/en\n    var scope = {};\n\n    math.eval('$ab$c = 2', scope); // dollar sign\n    assert.strictEqual(scope['$ab$c'], 2);\n\n    math.eval('\\u00E9 = 2', scope); // Latin Small Letter E with Acute\n    assert.strictEqual(scope['\\u00E9'], 2);\n\n    math.eval('\\u03A6 = 3', scope); // Greek Capital Letter Phi\n    assert.strictEqual(scope['\\u03A6'], 3);\n\n    math.eval('\\u03A9 = 4', scope); // Greek Capital Letter Omega\n    assert.strictEqual(scope['\\u03A9'], 4);\n\n    math.eval('\\u2126 = 4', scope); // Letter-like character Ohm\n    assert.strictEqual(scope['\\u2126'], 4);\n\n    math.eval('k\\u00F6ln = 5', scope); // Combination of latin and unicode\n    assert.strictEqual(scope['k\\u00F6ln'], 5);\n\n    // test unicode characters in the astral plane (surrogate pairs\n    math.eval('\\uD835\\uDD38 = 1', scope); // double struck capital A\n    assert.strictEqual(scope['\\uD835\\uDD38'], 1);\n\n    // should not allow the \"holes\"\n    assert.throws(function () {\n      math.eval('\\uD835\\uDCA3 = 1', scope);\n    })\n\n  });\n\n  describe('multiline', function () {\n\n    it('should parse multiline expressions', function() {\n      assert.deepEqual(parse('a=3\\nb=4\\na*b').compile().eval(), new ResultSet([3, 4, 12]));\n      assert.deepEqual(parse('b = 43; b * 4').compile().eval(), new ResultSet([172]));\n    });\n\n    it('should skip empty lines in multiline expressions', function() {\n      assert.deepEqual(parse('\\n;\\n2 * 4\\n').compile().eval(), new ResultSet([8]));\n    });\n\n    it('should spread operators over multiple lines', function() {\n      assert.deepEqual(parse('2+\\n3').compile().eval(), 5);\n      assert.deepEqual(parse('2+\\n\\n3').compile().eval(), 5);\n      assert.deepEqual(parse('2*\\n3').compile().eval(), 6);\n      assert.deepEqual(parse('2^\\n3').compile().eval(), 8);\n      assert.deepEqual(parse('2==\\n3').compile().eval(), false);\n      assert.deepEqual(parse('2*-\\n3').compile().eval(), -6);\n    });\n\n    it('should parse multiple function assignments', function() {\n      var scope = {};\n      parse('f(x)=x*2;g(x)=x*3').compile().eval(scope);\n      assert.equal(scope.f(2), 4);\n      assert.equal(scope.g(2), 6);\n\n      var scope2 = {};\n      parse('a=2;f(x)=x^a;').compile().eval(scope2);\n      assert.equal(scope2.a, 2);\n      assert.equal(scope2.f(3), 9);\n    });\n\n    it ('should correctly scope a function variable if also used outside the function', function () {\n      var scope = {};\n      var res = parse('x=2;f(x)=x^2;x').compile().eval(scope); // x should be x=2, not x of the function\n\n      assert.deepEqual(res, {entries: [2]});\n      assert.equal(scope.x, 2);\n      assert.equal(scope.f(3), 9);\n    });\n\n    it('should spread a function over multiple lines', function() {\n      assert.deepEqual(parse('add(\\n4\\n,\\n2\\n)').compile().eval(), 6);\n    });\n\n    it('should spread contents of parameters over multiple lines', function() {\n      assert.deepEqual(parse('(\\n4\\n+\\n2\\n)').compile().eval(), 6);\n    });\n\n    it('should spread a function assignment over multiple lines', function() {\n      assert.deepEqual(typeof parse('f(\\nx\\n,\\ny\\n)=\\nx+\\ny').compile().eval(), 'function');\n    });\n\n    it('should spread a variable assignment over multiple lines', function() {\n      assert.deepEqual(parse('x=\\n2').compile().eval(), 2);\n    });\n\n    it('should spread a matrix over multiple lines', function() {\n      assert.deepEqual(parse('[\\n1\\n,\\n2\\n]').compile().eval(), math.matrix([1, 2]));\n    });\n\n    it('should spread a range over multiple lines', function() {\n      assert.deepEqual(parse('2:\\n4').compile().eval(), math.matrix([2,3,4]));\n      assert.deepEqual(parse('2:\\n2:\\n6').compile().eval(), math.matrix([2,4,6]));\n    });\n\n    it('should spread an index over multiple lines', function() {\n      assert.deepEqual(parse('a[\\n1\\n,\\n1\\n]').compile().eval({a: [[1,2],[3,4]]}), 1);\n\n      var scope = {a: [[1,2],[3,4]]};\n      assert.deepEqual(parse('a[\\n1\\n,\\n1\\n]=\\n100').compile().eval(scope), 100);\n      assert.deepEqual(scope, {a: [[100,2],[3,4]]})\n    });\n\n  });\n\n  it('should throw an error when scope contains a reserved keyword', function() {\n    var scope = {\n      end: 2\n    };\n    assert.throws(function () {\n      parse('2+3').compile().eval(scope);\n    }, /Scope contains an illegal symbol/);\n  });\n\n  it('should give informative syntax errors', function() {\n    assert.throws(function () {parse('2 +');}, /Unexpected end of expression \\(char 4\\)/);\n    assert.throws(function () {parse('2 + 3 + *');}, /Value expected \\(char 9\\)/);\n  });\n\n  it('should throw an error if called with wrong number of arguments', function() {\n    assert.throws(function () {parse();}, ArgumentsError);\n    assert.throws(function () {parse(1,2,3);}, ArgumentsError);\n    assert.throws(function () {parse([1, 2]);}, TypeError);\n  });\n\n  it('should throw an error if called with a wrong type of argument', function() {\n    assert.throws(function () {parse(23);}, TypeError);\n    assert.throws(function () {parse(math.unit('5cm'));}, TypeError);\n    assert.throws(function () {parse(new Complex(2,3));}, TypeError);\n    assert.throws(function () {parse(true);}, TypeError);\n  });\n\n  it('should throw an error in case of unsupported characters', function() {\n    assert.throws(function () {parse('2\\u00A1');}, /Syntax error in part \"\\u00A1\"/);\n  });\n\n  describe('comments', function () {\n\n    it('should skip comments', function() {\n      assert.equal(parseAndEval('2 + 3 # - 4'), 5);\n    });\n\n    it('should skip comments in a ResultSet', function() {\n      assert.deepEqual(parseAndEval('2 + 3 # - 4\\n6-2'), new ResultSet([5, 4]));\n    });\n\n    it('should fill in the property comment of a Node', function() {\n      assert.equal(parse('2 + 3').comment, '');\n\n      assert.equal(parse('2 + 3 # hello').comment, '# hello');\n      assert.equal(parse('   # hi').comment, '# hi');\n\n      var blockNode = parse('2 # foo\\n3   # bar');\n      assert.equal(blockNode.blocks.length, 2);\n      assert.equal(blockNode.blocks[0].node.comment, '# foo');\n      assert.equal(blockNode.blocks[1].node.comment, '# bar');\n    });\n\n  });\n\n  describe('number', function () {\n\n    it('should parse valid numbers', function() {\n      assert.equal(parseAndEval('0'), 0);\n      assert.equal(parseAndEval('3'), 3);\n      assert.equal(parseAndEval('3.2'), 3.2);\n      assert.equal(parseAndEval('3.'), 3);\n      assert.equal(parseAndEval('3. '), 3);\n      assert.equal(parseAndEval('3.\\t'), 3);\n      assert.equal(parseAndEval('003.2'), 3.2);\n      assert.equal(parseAndEval('003.200'), 3.2);\n      assert.equal(parseAndEval('.2'), 0.2);\n      assert.equal(parseAndEval('3e2'), 300);\n      assert.equal(parseAndEval('300e2'), 30000);\n      assert.equal(parseAndEval('300e+2'), 30000);\n      assert.equal(parseAndEval('300e-2'), 3);\n      assert.equal(parseAndEval('300E-2'), 3);\n      assert.equal(parseAndEval('3.2e2'), 320);\n    });\n\n    it('should parse a number followed by e', function() {\n      approx.equal(parseAndEval('2e'), 2 * Math.E);\n    });\n\n    it('should throw an error with invalid numbers', function() {\n      assert.throws(function () {parseAndEval('.'); }, /Value expected/);\n      assert.throws(function () {parseAndEval('3.2.2'); }, SyntaxError);\n      assert.throws(function () {parseAndEval('3.2e2.2'); }, SyntaxError);\n      \n      assert.throws(function () {parseAndEval('3e0.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('3e.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('-3e0.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('-3e.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('3e-0.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('3e-.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('-3e-0.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('-3e-.5'); }, /Digit expected, got \".\"/);\n\n      assert.throws(function () {parseAndEval('2e+a'); }, /Digit expected, got \"a\"/);\n    });\n\n  });\n\n  describe('bignumber', function () {\n\n    it('should parse bignumbers', function() {\n      assert.deepEqual(parseAndEval('bignumber(0.1)'), math.bignumber(0.1));\n      assert.deepEqual(parseAndEval('bignumber(\"1.2e500\")'), math.bignumber('1.2e500'));\n    });\n\n    it('should output bignumbers if default number type is bignumber', function() {\n      var bigmath = math.create({\n        number: 'BigNumber'\n      });\n\n      assert.deepEqual(bigmath.parse('0.1').compile().eval(), bigmath.bignumber(0.1));\n      assert.deepEqual(bigmath.parse('1.2e5000').compile().eval(), bigmath.bignumber('1.2e5000'));\n    });\n\n  });\n\n  describe('fraction', function () {\n\n    it('should output fractions if default number type is fraction', function() {\n      var fmath = math.create({\n        number: 'Fraction'\n      });\n\n      assert(fmath.parse('0.1').compile().eval() instanceof math.type.Fraction);\n      assert.equal(fmath.parse('1/3').compile().eval().toString(), '0.(3)');\n      assert.equal(fmath.parse('0.1+0.2').compile().eval().toString(), '0.3');\n    });\n\n  });\n\n  describe('string', function () {\n\n    it('should parse a string', function() {\n      assert.deepEqual(parseAndEval('\"hello\"'), \"hello\");\n      assert.deepEqual(parseAndEval('   \"hi\" '), \"hi\");\n    });\n\n    it('should parse a with escaped characters', function() {\n      assert.deepEqual(parseAndEval('\"line end\\\\nnext\"'), 'line end\\nnext');\n      assert.deepEqual(parseAndEval('\"line end\\\\n\"'), 'line end\\n');\n      assert.deepEqual(parseAndEval('\"tab\\\\tnext\"'), 'tab\\tnext');\n      assert.deepEqual(parseAndEval('\"tab\\\\t\"'), 'tab\\t');\n      assert.deepEqual(parseAndEval('\"escaped backslash\\\\\\\\next\"'), 'escaped backslash\\\\next');\n      assert.deepEqual(parseAndEval('\"escaped backslash\\\\\\\\\"'), 'escaped backslash\\\\');\n    });\n\n    it('should throw an error with invalid strings', function() {\n      assert.throws(function () {parseAndEval('\"hi'); }, SyntaxError);\n      assert.throws(function () {parseAndEval(' hi\" '); }, Error);\n    });\n\n    it('should get a string subset', function() {\n      var scope = {};\n      assert.deepEqual(parseAndEval('c=\"hello\"', scope), \"hello\");\n      assert.deepEqual(parseAndEval('c[2:4]', scope), \"ell\");\n      assert.deepEqual(parseAndEval('c[5:-1:1]', scope), \"olleh\");\n      assert.deepEqual(parseAndEval('c[end-2:-1:1]', scope), \"leh\");\n      assert.deepEqual(parseAndEval('\"hello\"[2:4]', scope), \"ell\");\n    });\n\n    it('should set a string subset', function() {\n      var scope = {};\n      assert.deepEqual(parseAndEval('c=\"hello\"', scope), \"hello\");\n      assert.deepEqual(parseAndEval('c[1] = \"H\"', scope), \"H\");\n      assert.deepEqual(scope.c, \"Hello\");\n      assert.deepEqual(parseAndEval('c', scope), \"Hello\");\n      assert.deepEqual(parseAndEval('c[6:11] = \" world\"', scope), \" world\");\n      assert.deepEqual(scope.c, \"Hello world\");\n      assert.deepEqual(parseAndEval('c[end] = \"D\"', scope), \"D\");\n      assert.deepEqual(scope.c, \"Hello worlD\");\n    });\n\n    it('should set a string subset on an object', function() {\n      var scope = { a: {} };\n      assert.deepEqual(parseAndEval('a.c=\"hello\"', scope), \"hello\");\n      assert.deepEqual(parseAndEval('a.c[1] = \"H\"', scope), \"H\");\n      assert.deepEqual(scope.a, {c: \"Hello\"});\n      assert.deepEqual(parseAndEval('a.c', scope), \"Hello\");\n      assert.deepEqual(parseAndEval('a.c[6:11] = \" world\"', scope), \" world\");\n      assert.deepEqual(scope.a, {c: \"Hello world\"});\n      assert.deepEqual(parseAndEval('a.c', scope), \"Hello world\");\n      assert.deepEqual(scope.a, {c: \"Hello world\"});\n      assert.deepEqual(parseAndEval('a.c[end] = \"D\"', scope), \"D\");\n      assert.deepEqual(scope.a, {c: \"Hello worlD\"});\n    });\n\n  });\n\n  describe('unit', function () {\n\n    it('should parse units', function() {\n      assert.deepEqual(parseAndEval('5cm'), new Unit(5, 'cm'));\n      assert.ok(parseAndEval('5cm') instanceof Unit);\n    });\n\n    it('should parse constants', function() {\n      assert.equal(parseAndEval('pi'), Math.PI);\n    });\n\n    it('should parse physical constants', function() {\n      var expected = new Unit(299792458, 'm/s');\n      expected.fixPrefix = true;\n      assert.deepEqual(parseAndEval('speedOfLight'), expected);\n    });\n\n    it('should correctly parse negative temperatures', function () {\n      approx.deepEqual(parseAndEval('-6 celsius'), new Unit(-6, 'celsius'));\n      approx.deepEqual(parseAndEval('--6 celsius'), new Unit(6, 'celsius'));\n      approx.deepEqual(parseAndEval('-6 celsius to fahrenheit'),\n          new Unit(21.2, 'fahrenheit').to('fahrenheit'));\n    });\n\n    it('should convert units', function() {\n      var scope = {};\n      approx.deepEqual(parseAndEval('(5.08 cm * 1000) to inch', scope),\n          math.unit(2000, 'inch').to('inch'));\n      approx.deepEqual(parseAndEval('a = (5.08 cm * 1000) to mm', scope),\n          math.unit(50800, 'mm').to('mm'));\n      approx.deepEqual(parseAndEval('a to inch', scope),\n          math.unit(2000, 'inch').to('inch'));\n\n      approx.deepEqual(parseAndEval('10 celsius to fahrenheit'),\n          math.unit(50, 'fahrenheit').to('fahrenheit'));\n      approx.deepEqual(parseAndEval('20 celsius to fahrenheit'),\n          math.unit(68, 'fahrenheit').to('fahrenheit'));\n      approx.deepEqual(parseAndEval('50 fahrenheit to celsius'),\n          math.unit(10, 'celsius').to('celsius'));\n    });\n\n    it('should create units and aliases', function() {\n      var myMath = math.create()\n      myMath.eval('createUnit(\"knot\", {definition: \"0.514444444 m/s\", aliases: [\"knots\", \"kt\", \"kts\"]})');\n      assert.equal(myMath.eval('5 knot').toString(), '5 knot');\n      assert.equal(myMath.eval('5 knots').toString(), '5 knots');\n      assert.equal(myMath.eval('5 kt').toString(), '5 kt');\n    });\n\n    it('should evaluate operator \"to\" with correct precedence ', function () {\n      approx.deepEqual(parseAndEval('5.08 cm * 1000 to inch'),\n          new Unit(2000, 'inch').to('inch'));\n    });\n\n    it('should evaluate operator \"in\" (alias of \"to\") ', function () {\n      approx.deepEqual(parseAndEval('5.08 cm in inch'),\n          new Unit(2, 'inch').to('inch'));\n    });\n\n    it('should evaluate unit \"in\" (should not conflict with operator \"in\")', function () {\n      approx.deepEqual(parseAndEval('2 in'),          new Unit(2, 'in'));\n      approx.deepEqual(parseAndEval('5.08 cm in in'), new Unit(2, 'in').to('in'));\n      approx.deepEqual(parseAndEval('5 in in in'),    new Unit(5, 'in').to('in'));\n      approx.deepEqual(parseAndEval('2 in to meter'), new Unit(2, 'inch').to('meter'));\n      approx.deepEqual(parseAndEval('2 in in meter'), new Unit(2, 'inch').to('meter'));\n      approx.deepEqual(parseAndEval('a in inch', {a: new Unit(5.08, 'cm')}), new Unit(2, 'inch').to('inch'));\n      approx.deepEqual(parseAndEval('(2+3) in'), new Unit(5, 'in'));\n      approx.deepEqual(parseAndEval('a in', {a: 5}), new Unit(5, 'in'));\n      approx.deepEqual(parseAndEval('0.5in + 1.5in to cm'), new Unit(5.08, 'cm').to('cm'));\n    });\n  });\n\n  describe('complex', function () {\n\n    it('should parse complex values', function () {\n      assert.deepEqual(parseAndEval('i'), new Complex(0,1));\n      assert.deepEqual(parseAndEval('2+3i'), new Complex(2,3));\n      assert.deepEqual(parseAndEval('2+3*i'), new Complex(2,3));\n      assert.deepEqual(parseAndEval('1/2i'), new Complex(0, 0.5));\n    });\n\n  });\n\n  describe('matrix', function () {\n\n    it('should parse a matrix', function() {\n      assert.ok(parseAndEval('[1,2;3,4]') instanceof Matrix);\n\n      var m = parseAndEval('[1,2,3;4,5,6]');\n      assert.deepEqual(m.size(), [2,3]);\n      assert.deepEqual(m, math.matrix([[1,2,3],[4,5,6]]));\n\n      var b = parseAndEval('[5, 6; 1, 1]');\n      assert.deepEqual(b.size(), [2,2]);\n      assert.deepEqual(b, math.matrix([[5,6],[1,1]]));\n\n      // from 1 to n dimensions\n      assert.deepEqual(parseAndEval('[ ]'), math.matrix([]));\n      assert.deepEqual(parseAndEval('[1,2,3]'), math.matrix([1,2,3]));\n      assert.deepEqual(parseAndEval('[1;2;3]'), math.matrix([[1],[2],[3]]));\n      assert.deepEqual(parseAndEval('[[1,2],[3,4]]'), math.matrix([[1,2],[3,4]]));\n      assert.deepEqual(parseAndEval('[[[1],[2]],[[3],[4]]]'), math.matrix([[[1],[2]],[[3],[4]]]));\n    });\n\n    it('should parse an empty matrix', function() {\n      assert.deepEqual(parseAndEval('[]'), math.matrix([]));\n    });\n\n    it('should get a matrix subset', function() {\n      var scope = {\n        a: math.matrix([\n          [1,2,3],\n          [4,5,6],\n          [7,8,9]\n        ])\n      };\n      assert.deepEqual(parseAndEval('a[2, :]', scope),        math.matrix([[4,5,6]]));\n      assert.deepEqual(parseAndEval('a[2, :2]', scope),       math.matrix([[4,5]]));\n      assert.deepEqual(parseAndEval('a[2, :end-1]', scope),   math.matrix([[4,5]]));\n      assert.deepEqual(parseAndEval('a[2, 2:]', scope),       math.matrix([[5,6]]));\n      assert.deepEqual(parseAndEval('a[2, 2:3]', scope),      math.matrix([[5,6]]));\n      assert.deepEqual(parseAndEval('a[2, 1:2:3]', scope),    math.matrix([[4,6]]));\n      assert.deepEqual(parseAndEval('a[:, 2]', scope),        math.matrix([[2],[5],[8]]));\n      assert.deepEqual(parseAndEval('a[:2, 2]', scope),       math.matrix([[2],[5]]));\n      assert.deepEqual(parseAndEval('a[:end-1, 2]', scope),   math.matrix([[2],[5]]));\n      assert.deepEqual(parseAndEval('a[2:, 2]', scope),       math.matrix([[5],[8]]));\n      assert.deepEqual(parseAndEval('a[2:3, 2]', scope),      math.matrix([[5],[8]]));\n      assert.deepEqual(parseAndEval('a[1:2:3, 2]', scope),    math.matrix([[2],[8]]));\n    });\n\n    it('should get a matrix subset of a matrix subset', function() {\n      var scope = {\n        a: math.matrix([\n          [1,2,3],\n          [4,5,6],\n          [7,8,9]\n        ])\n      };\n      assert.deepEqual(parseAndEval('a[2, :][1,1]', scope), 4);\n    });\n\n    it('should get BigNumber value from an array', function() {\n      var res = parseAndEval('arr[1]', {arr: [math.bignumber(2)]});\n      assert.deepEqual(res, math.bignumber(2));\n    });\n\n    it('should parse matrix resizings', function() {\n      var scope = {};\n      assert.deepEqual(parseAndEval('a = []', scope),    math.matrix([]));\n      assert.deepEqual(parseAndEval('a[1:3,1] = [1;2;3]', scope), math.matrix([[1],[2],[3]]));\n      assert.deepEqual(parseAndEval('a[:,2] = [4;5;6]', scope), math.matrix([[4],[5],[6]]));\n      assert.deepEqual(scope.a, math.matrix([[1,4],[2,5],[3,6]]));\n\n      assert.deepEqual(parseAndEval('a = []', scope),    math.matrix([]));\n      assert.strictEqual(parseAndEval('a[1,3] = 3', scope), 3);\n      assert.deepEqual(scope.a, math.matrix([[0,0,3]]));\n      assert.deepEqual(parseAndEval('a[2,:] = [[4,5,6]]', scope), math.matrix([[4,5,6]]));\n      assert.deepEqual(scope.a, math.matrix([[0,0,3],[4,5,6]]));\n\n      assert.deepEqual(parseAndEval('a = []', scope),    math.matrix([]));\n      assert.strictEqual(parseAndEval('a[3,1] = 3', scope), 3);\n      assert.deepEqual(scope.a, math.matrix([[0],[0],[3]]));\n      assert.deepEqual(parseAndEval('a[:,2] = [4;5;6]', scope), math.matrix([[4],[5],[6]]));\n      assert.deepEqual(scope.a, math.matrix([[0,4],[0,5],[3,6]]));\n\n      assert.deepEqual(parseAndEval('a = []', scope),    math.matrix([]));\n      assert.deepEqual(parseAndEval('a[1,1:3] = [[1,2,3]]', scope), math.matrix([[1,2,3]]));\n      assert.deepEqual(scope.a, math.matrix([[1,2,3]]));\n      assert.deepEqual(parseAndEval('a[2,:] = [[4,5,6]]', scope), math.matrix([[4,5,6]]));\n      assert.deepEqual(scope.a, math.matrix([[1,2,3],[4,5,6]]));\n    });\n\n    it('should get/set the matrix correctly', function() {\n      var scope = {};\n      parseAndEval('a=[1,2;3,4]', scope);\n      parseAndEval('a[1,1] = 100', scope);\n      assert.deepEqual(scope.a.size(), [2,2]);\n      assert.deepEqual(scope.a, math.matrix([[100,2],[3,4]]));\n      parseAndEval('a[2:3,2:3] = [10,11;12,13]', scope);\n      assert.deepEqual(scope.a.size(), [3,3]);\n      assert.deepEqual(scope.a, math.matrix([[100, 2, 0],[3,10,11],[0,12,13]]));\n      var a = scope.a;\n      // note: after getting subset, uninitialized elements are replaced by elements with an undefined value\n      assert.deepEqual(a.subset(math.index(new Range(0,3), new Range(0,2))), math.matrix([[100,2],[3,10],[0,12]]));\n      assert.deepEqual(parseAndEval('a[1:3,1:2]', scope), math.matrix([[100,2],[3,10],[0,12]]));\n\n      scope.b = [[1,2],[3,4]];\n      assert.deepEqual(parseAndEval('b[1,:]', scope), [[1, 2]]);\n    });\n\n    it('should get/set the matrix correctly for 3d matrices', function() {\n      var scope = {};\n      assert.deepEqual(parseAndEval('f=[1,2;3,4]', scope), math.matrix([[1,2],[3,4]]));\n      assert.deepEqual(parseAndEval('size(f)', scope), math.matrix([2,2]));\n\n      parseAndEval('f[:,:,2]=[5,6;7,8]', scope);\n      assert.deepEqual(scope.f, math.matrix([\n        [\n          [1,5],\n          [2,6]\n        ],\n        [\n          [3,7],\n          [4,8]\n        ]\n      ]));\n\n      assert.deepEqual(parseAndEval('size(f)', scope), math.matrix([2,2,2]));\n      assert.deepEqual(parseAndEval('f[:,:,1]', scope), math.matrix([[[1],[2]],[[3],[4]]]));\n      assert.deepEqual(parseAndEval('f[:,:,2]', scope), math.matrix([[[5],[6]],[[7],[8]]]));\n      assert.deepEqual(parseAndEval('f[:,2,:]', scope), math.matrix([[[2,6]],[[4,8]]]));\n      assert.deepEqual(parseAndEval('f[2,:,:]', scope), math.matrix([[[3,7],[4,8]]]));\n\n      parseAndEval('a=diag([1,2,3,4])', scope);\n      assert.deepEqual(parseAndEval('a[3:end, 3:end]', scope), math.matrix([[3,0],[0,4]]));\n      parseAndEval('a[3:end, 2:end]=9*ones(2,3)', scope);\n      assert.deepEqual(scope.a, math.matrix([\n        [1,0,0,0],\n        [0,2,0,0],\n        [0,9,9,9],\n        [0,9,9,9]\n      ]));\n      assert.deepEqual(parseAndEval('a[2:end-1, 2:end-1]', scope), math.matrix([[2,0],[9,9]]));\n    });\n\n    it('should merge nested matrices', function() {\n      var scope = {};\n      parseAndEval('a=[1,2;3,4]', scope);\n\n    });\n\n    it('should parse matrix concatenations', function() {\n      var scope = {};\n      parseAndEval('a=[1,2;3,4]', scope);\n      parseAndEval('b=[5,6;7,8]', scope);\n      assert.deepEqual(parseAndEval('c=concat(a,b)', scope), math.matrix([[1,2,5,6],[3,4,7,8]]));\n      assert.deepEqual(parseAndEval('c=concat(a,b,1)', scope), math.matrix([[1,2],[3,4],[5,6],[7,8]]));\n      assert.deepEqual(parseAndEval('c=concat(concat(a,b), concat(b,a), 1)', scope), math.matrix([[1,2,5,6],[3,4,7,8],[5,6,1,2],[7,8,3,4]]));\n      assert.deepEqual(parseAndEval('c=concat([[1,2]], [[3,4]], 1)', scope), math.matrix([[1,2],[3,4]]));\n      assert.deepEqual(parseAndEval('c=concat([[1,2]], [[3,4]], 2)', scope), math.matrix([[1,2,3,4]]));\n      assert.deepEqual(parseAndEval('c=concat([[1]], [2;3], 1)', scope), math.matrix([[1],[2],[3]]));\n      assert.deepEqual(parseAndEval('d=1:3', scope), math.matrix([1,2,3]));\n      assert.deepEqual(parseAndEval('concat(d,d)', scope), math.matrix([1,2,3,1,2,3]));\n      assert.deepEqual(parseAndEval('e=1+d', scope), math.matrix([2,3,4]));\n      assert.deepEqual(parseAndEval('size(e)', scope), math.matrix([3]));\n      assert.deepEqual(parseAndEval('concat(e,e)', scope), math.matrix([2,3,4,2,3,4]));\n      assert.deepEqual(parseAndEval('[[],[]]', scope), math.matrix([[],[]]));\n      assert.deepEqual(parseAndEval('[[],[]]', scope).size(), [2, 0]);\n      assert.deepEqual(parseAndEval('size([[],[]])', scope), math.matrix([2, 0]));\n    });\n\n    it('should disable arrays as range in a matrix index', function () {\n      var scope = {\n        a: [[1,2,3],[4,5,6]]\n      };\n\n      assert.throws(function () {\n        parseAndEval('a[2, 2+3i]', scope);\n      }, /TypeError: Dimension must be an Array, Matrix, number, string, or Range/);\n    });\n\n    it('should throw an error for invalid matrix', function() {\n      assert.throws(function () {parseAndEval('[1, 2');}, /End of matrix ] expected/);\n      assert.throws(function () {parseAndEval('[1; 2');}, /End of matrix ] expected/);\n    });\n\n    it('should throw an error when matrix rows mismatch', function() {\n      assert.throws(function () {parseAndEval('[1, 2; 1, 2, 3]');}, /Column dimensions mismatch/);\n    });\n\n    it('should throw an error for invalid matrix subsets', function() {\n      var scope = {a: [1,2,3]};\n      assert.throws(function () {parseAndEval('a[1', scope);}, /Parenthesis ] expected/);\n    });\n\n    it('should throw an error for invalid matrix concatenations', function() {\n      var scope = {};\n      assert.throws(function () {parseAndEval('c=concat(a, [1,2,3])', scope);});\n    });\n  });\n\n  describe('objects', function () {\n\n    it('should get an object property', function () {\n      assert.deepEqual(parseAndEval('obj[\"foo\"]', {obj: {foo: 2}}), 2);\n    });\n\n    it('should get a nested object property', function () {\n      assert.deepEqual(parseAndEval('obj[\"foo\"][\"bar\"]', {obj: {foo: {bar: 2}}}), 2);\n    });\n\n    it('should get a nested matrix subset from an object property', function () {\n      assert.deepEqual(parseAndEval('obj.foo[2]', {obj: {foo: [1,2,3]}}), 2);\n      assert.deepEqual(parseAndEval('obj.foo[end]', {obj: {foo: [1,2,3]}}), 3);\n      assert.deepEqual(parseAndEval('obj.foo[2][3]', {obj: {foo: ['hello', 'world']}}), 'r');\n      assert.deepEqual(parseAndEval('obj.foo[2][end]', {obj: {foo: ['hello', 'world']}}), 'd');\n      assert.deepEqual(parseAndEval('obj.foo[1].bar', {obj: {foo: [{bar:4}]}}), 4);\n    });\n\n    it('should set an object property', function () {\n      var scope = {obj: {a:3}};\n      var res = parseAndEval('obj[\"b\"] = 2', scope);\n      assert.strictEqual(res, 2);\n      assert.deepEqual(scope, {obj: {a: 3, b: 2}});\n    });\n\n    it('should set a nested object property', function () {\n      var scope = {obj: {foo: {}}};\n      var res = parseAndEval('obj[\"foo\"][\"bar\"] = 2', scope);\n      assert.strictEqual(res, 2);\n      assert.deepEqual(scope, {obj: {foo: {bar: 2}}});\n    });\n\n    it('should throw an error when trying to apply a matrix index as object property', function () {\n      var scope = {a: {}};\n      assert.throws(function () {\n        parseAndEval('a[2] = 6', scope);\n      }, /Cannot apply a numeric index as object property/);\n    });\n\n    it('should set a nested matrix subset from an object property (1)', function () {\n      var scope = {obj: {foo: [1,2,3]}};\n      assert.deepEqual(parseAndEval('obj.foo[2] = 6', scope), 6);\n      assert.deepEqual(scope, {obj: {foo: [1,6,3]}});\n\n      assert.deepEqual(parseAndEval('obj.foo[end] = 8', scope), 8);\n      assert.deepEqual(scope, {obj: {foo: [1,6,8]}});\n    });\n\n    it('should set a nested matrix subset from an object property (2)', function () {\n      var scope = {obj: {foo: [{bar:4}]}};\n      assert.deepEqual(parseAndEval('obj.foo[1].bar = 6', scope), 6);\n      assert.deepEqual(scope, {obj: {foo: [{bar: 6}]}});\n    });\n\n    it('should set a nested matrix subset from an object property (3)', function () {\n      var scope = {obj: {foo: [{bar:{}}]}};\n      assert.deepEqual(parseAndEval('obj.foo[1].bar.baz = 6', scope), 6);\n      assert.deepEqual(scope, {obj: {foo: [{bar: {baz:6}}]}});\n    });\n\n    it('should set a nested matrix subset from an object property (4)', function () {\n      var scope = {obj: {foo: ['hello', 'world']}};\n      assert.deepEqual(parseAndEval('obj.foo[1][end] = \"a\"', scope), 'a');\n      assert.deepEqual(scope, {obj: {foo: ['hella', 'world']}});\n      assert.deepEqual(parseAndEval('obj.foo[end][end] = \"!\"', scope), '!');\n      assert.deepEqual(scope, {obj: {foo: ['hella', 'worl!']}});\n    });\n\n    // TODO: test whether 1-based IndexErrors are thrown\n\n    it('should get an object property with dot notation', function () {\n      assert.deepEqual(parseAndEval('obj.foo', {obj: {foo: 2}}), 2);\n    });\n\n    it('should get an object property from an object inside parentheses', function () {\n      assert.deepEqual(parseAndEval('(obj).foo', {obj: {foo: 2}}), 2);\n    });\n\n    it('should get a nested object property with dot notation', function () {\n      assert.deepEqual(parseAndEval('obj.foo.bar', {obj: {foo: {bar: 2}}}), 2);\n    });\n\n    it('should invoke a function in an object', function () {\n      var scope = {\n        obj: {\n          fn: function (x) {\n            return x * x;\n          }\n        }\n      };\n      assert.deepEqual(parseAndEval('obj.fn(2)', scope), 4);\n      assert.deepEqual(parseAndEval('obj[\"fn\"](2)', scope), 4);\n    });\n\n    it('should invoke a function returned by a function', function () {\n      var scope = {\n        theAnswer: function () {\n          return function () {\n            return 42;\n          };\n        },\n        partialAdd: function (a) {\n          return function (b) {\n            return a + b;\n          };\n        }\n      };\n      assert.deepEqual(parseAndEval('theAnswer()()', scope), 42);\n      assert.deepEqual(parseAndEval('partialAdd(2)(3)', scope), 5);\n    });\n\n    it('should invoke a function on an object with the right context', function () {\n      approx.equal(parseAndEval('(2.54 cm).toNumeric(\"inch\")'), 1);\n      assert.deepEqual(parseAndEval('bignumber(2).plus(3)'), math.bignumber(5));\n      assert.deepEqual(parseAndEval('bignumber(2)[\"plus\"](3)'), math.bignumber(5));\n    });\n\n    it('should invoke native methods on a number', function () {\n      assert.strictEqual(parseAndEval('(3).toString()'), '3');\n      assert.strictEqual(parseAndEval('(3.2).toFixed()'), '3');\n    });\n\n    it('should get nested object property with mixed dot- and index-notation', function () {\n      assert.deepEqual(parseAndEval('obj.foo[\"bar\"].baz', {obj: {foo: {bar: {baz: 2}}}}), 2);\n      assert.deepEqual(parseAndEval('obj[\"foo\"].bar[\"baz\"]', {obj: {foo: {bar: {baz: 2}}}}), 2);\n    });\n\n    it('should set an object property with dot notation', function () {\n      var scope = {obj: {}};\n      parseAndEval('obj.foo = 2', scope);\n      assert.deepEqual(scope, {obj: {foo: 2}});\n    });\n\n    it('should set a nested object property with dot notation', function () {\n      var scope = {obj: {foo: {}}};\n      parseAndEval('obj.foo.bar = 2', scope);\n      assert.deepEqual(scope, {obj: {foo: {bar: 2}}});\n    });\n\n    it('should throw an error in case of invalid property with dot notation', function () {\n      assert.throws(function () {parseAndEval('obj. +foo')}, /SyntaxError: Property name expected after dot \\(char 6\\)/);\n      assert.throws(function () {parseAndEval('obj.[\"foo\"]')}, /SyntaxError: Property name expected after dot \\(char 5\\)/);\n    });\n\n    it('should create an empty object', function () {\n      assert.deepEqual(parseAndEval('{}'), {});\n    });\n\n    it('should create an object with quoted keys', function () {\n      assert.deepEqual(parseAndEval('{\"a\":2+3,\"b\":\"foo\"}'), {a: 5, b: 'foo'});\n    });\n\n    it('should create an object with unquoted keys', function () {\n      assert.deepEqual(parseAndEval('{a:2+3,b:\"foo\"}'), {a: 5, b: 'foo'});\n    });\n\n    it('should create an object with child object', function () {\n      assert.deepEqual(parseAndEval('{a:{b:2}}'), {a:{b:2}})\n    });\n\n    it('should get a property from a just created object', function () {\n      assert.deepEqual(parseAndEval('{foo:2}[\"foo\"]'), 2);\n    });\n\n    it('should parse an object containing a function assignment', function () {\n      var obj = parseAndEval('{f: f(x)=x^2}');\n      assert.deepEqual(Object.keys(obj), ['f']);\n      assert.equal(obj.f(2), 4);\n    });\n\n    it('should parse an object containing a variable assignment', function () {\n      var scope = {};\n      assert.deepEqual(parseAndEval('{f: a=42}', scope), {f: 42});\n      assert.strictEqual(scope.a, 42);\n    });\n\n    it('should throw an exception in case of invalid object key', function () {\n      assert.throws(function () {parseAndEval('{a b: 2}')}, /SyntaxError: Colon : expected after object key \\(char 4\\)/);\n      assert.throws(function () {parseAndEval('{a: }')}, /SyntaxError: Value expected \\(char 5\\)/);\n    });\n\n  });\n\n  describe('boolean', function () {\n\n    it('should parse boolean values', function () {\n      assert.equal(parseAndEval('true'), true);\n      assert.equal(parseAndEval('false'), false);\n    });\n\n  });\n\n\n  describe('constants', function () {\n\n    it('should parse constants', function() {\n      assert.deepEqual(parseAndEval('i'), new Complex(0, 1));\n      approx.equal(parseAndEval('pi'), Math.PI);\n      approx.equal(parseAndEval('e'), Math.E);\n    });\n\n  });\n\n  describe('variables', function () {\n\n    it('should parse valid variable assignments', function() {\n      var scope = {};\n      assert.equal(parseAndEval('a = 0.75', scope), 0.75);\n      assert.equal(parseAndEval('a + 2', scope), 2.75);\n      assert.equal(parseAndEval('a = 2', scope), 2);\n      assert.equal(parseAndEval('a + 2', scope), 4);\n      approx.equal(parseAndEval('pi * 2', scope), 6.283185307179586);\n    });\n\n    it('should throw an error on undefined symbol', function() {\n      assert.throws(function() {parseAndEval('qqq + 2'); });\n    });\n\n    it('should throw an error on invalid assignments', function() {\n      //assert.throws(function () {parseAndEval('sin(2) = 0.75')}, SyntaxError); // TODO: should this throw an exception?\n      assert.throws(function () {parseAndEval('sin + 2 = 3');}, SyntaxError);\n    });\n\n    it('should parse nested assignments', function() {\n      var scope = {};\n      assert.equal(parseAndEval('c = d = (e = 4.5)', scope), 4.5);\n      assert.equal(scope.c, 4.5);\n      assert.equal(scope.d, 4.5);\n      assert.equal(scope.e, 4.5);\n      assert.deepEqual(parseAndEval('a = [1,2,f=3]', scope), math.matrix([1,2,3]));\n      assert.equal(scope.f, 3);\n      assert.equal(parseAndEval('2 + (g = 3 + 4)', scope), 9);\n      assert.equal(scope.g, 7);\n    });\n\n    it('should parse variable assignment inside a function call', function() {\n      var scope = {};\n      assert.deepEqual(parseAndEval('sqrt(x=4)', scope), 2);\n      assert.deepEqual(scope, { x:4 });\n    });\n\n    it('should parse variable assignment inside an accessor', function () {\n      var scope = {A: [10,20,30]};\n      assert.deepEqual(parseAndEval('A[x=2]', scope), 20);\n      assert.deepEqual(scope, { A:[10,20,30], x:2 });\n    });\n\n  });\n\n\n  describe('functions', function () {\n\n    it('should parse functions', function() {\n      assert.equal(parseAndEval('sqrt(4)'), 2);\n      assert.equal(parseAndEval('sqrt(6+3)'), 3);\n      assert.equal(parseAndEval('atan2(2,2)'), 0.7853981633974483);\n      assert.deepEqual(parseAndEval('sqrt(-4)'), new Complex(0, 2));\n      assert.equal(parseAndEval('abs(-4.2)'), 4.2);\n      assert.equal(parseAndEval('add(2, 3)'), 5);\n      approx.deepEqual(parseAndEval('1+exp(pi*i)'), new Complex(0, 0));\n      assert.equal(parseAndEval('unequal(2, 3)'), true);\n    });\n\n    it('should get a subset of a matrix returned by a function', function() {\n      var scope = {\n        test: function () {\n          return [1,2,3,4];\n        }\n      };\n      assert.equal(parseAndEval('test()[2]', scope), 2);\n    });\n\n    it('should parse functions without parameters', function() {\n      assert.equal(parseAndEval('r()', {r: function() {return 2;}}), 2);\n    });\n\n    it('should parse function assignments', function() {\n      var scope = {};\n      parseAndEval('x=100', scope); // for testing scoping of the function variables\n      assert.equal(parseAndEval('f(x) = x^2', scope).syntax, 'f(x)');\n      assert.equal(parseAndEval('f(3)', scope), 9);\n      assert.equal(scope.f(3), 9);\n      assert.equal(scope.x, 100);\n      assert.equal(parseAndEval('g(x, y) = x^y', scope).syntax, 'g(x, y)');\n      assert.equal(parseAndEval('g(4,5)', scope), 1024);\n      assert.equal(scope.g(4,5), 1024);\n    });\n\n    it ('should correctly evaluate variables in assigned functions', function () {\n      var scope = {};\n      assert.equal(parseAndEval('a = 3', scope), 3);\n      assert.equal(parseAndEval('f(x) = a * x', scope).syntax, 'f(x)');\n      assert.equal(parseAndEval('f(2)', scope), 6);\n      assert.equal(parseAndEval('a = 5', scope), 5);\n      assert.equal(parseAndEval('f(2)', scope), 10);\n      assert.equal(parseAndEval('g(x) = x^q', scope).syntax, 'g(x)');\n      assert.equal(parseAndEval('q = 4/2', scope), 2);\n      assert.equal(parseAndEval('g(3)', scope), 9);\n    });\n\n    it('should throw an error for undefined variables in an assigned function', function() {\n      var scope = {};\n      assert.equal(parseAndEval('g(x) = x^q', scope).syntax, 'g(x)');\n      assert.throws(function () {\n        parseAndEval('g(3)', scope);\n      }, function (err) {\n        return (err instanceof Error) && (err.toString() == 'Error: Undefined symbol q');\n      });\n    });\n\n    it('should throw an error on invalid left hand side of a function assignment', function() {\n      assert.throws(function () {\n        var scope = {};\n        parseAndEval('g(x, 2) = x^2', scope);\n      }, SyntaxError);\n\n      assert.throws(function () {\n        var scope = {};\n        parseAndEval('2(x, 2) = x^2', scope);\n      }, SyntaxError);\n    });\n  });\n\n  describe ('parentheses', function () {\n    it('should parse parentheses overriding the default precedence', function () {\n      approx.equal(parseAndEval('2 - (2 - 2)'), 2);\n      approx.equal(parseAndEval('2 - ((2 - 2) - 2)'), 4);\n      approx.equal(parseAndEval('3 * (2 + 3)'), 15);\n      approx.equal(parseAndEval('(2 + 3) * 3'), 15);\n    });\n\n    it('should throw an error in case of unclosed parentheses', function () {\n      assert.throws(function () {parseAndEval('3 * (1 + 2');}, /Parenthesis \\) expected/);\n    });\n  });\n\n  describe ('operators', function () {\n\n    it('should parse operations', function() {\n      approx.equal(parseAndEval('(2+3)/4'), 1.25);\n      approx.equal(parseAndEval('2+3/4'), 2.75);\n      assert.equal(parse('0 + 2').toString(), '0 + 2');\n    });\n\n    it('should parse add +', function() {\n      assert.equal(parseAndEval('2 + 3'), 5);\n      assert.equal(parseAndEval('2 + 3 + 4'), 9);\n      assert.equal(parseAndEval('2.+3'), 5); // test whether the decimal mark isn't confused\n    });\n\n    it('should parse divide /', function() {\n      assert.equal(parseAndEval('4 / 2'), 2);\n      assert.equal(parseAndEval('8 / 2 / 2'), 2);\n    });\n\n    it('should parse dotDivide ./', function() {\n      assert.equal(parseAndEval('4./2'), 2);\n      assert.deepEqual(parseAndEval('4./[2,4]'), math.matrix([2,1]));\n      assert.equal(parseAndEval('4 ./ 2'), 2);\n      assert.equal(parseAndEval('8 ./ 2 / 2'), 2);\n\n      assert.deepEqual(parseAndEval('[1,2,3] ./ [1,2,3]'), math.matrix([1,1,1]));\n    });\n\n    it('should parse dotMultiply .*', function() {\n      approx.deepEqual(parseAndEval('2.*3'), 6);\n      approx.deepEqual(parseAndEval('2e3.*3'), 6e3);\n      approx.deepEqual(parseAndEval('2 .* 3'), 6);\n      approx.deepEqual(parseAndEval('4 .* 2'), 8);\n      approx.deepEqual(parseAndEval('8 .* 2 .* 2'), 32);\n      assert.deepEqual(parseAndEval('a=3; a.*4'), new ResultSet([12]));\n\n      assert.deepEqual(parseAndEval('[1,2,3] .* [1,2,3]'), math.matrix([1,4,9]));\n    });\n\n    it('should parse dotPower .^', function() {\n      approx.deepEqual(parseAndEval('2.^3'), 8);\n      approx.deepEqual(parseAndEval('2 .^ 3'), 8);\n      approx.deepEqual(parseAndEval('-2.^2'), -4);  // -(2^2)\n      approx.deepEqual(parseAndEval('2.^3.^4'), 2.41785163922926e+24); // 2^(3^4)\n\n      assert.deepEqual(parseAndEval('[2,3] .^ [2,3]'), math.matrix([4,27]));\n    });\n\n    it('should parse equal ==', function() {\n      assert.strictEqual(parseAndEval('2 == 3'), false);\n      assert.strictEqual(parseAndEval('2 == 2'), true);\n      assert.deepEqual(parseAndEval('[2,3] == [2,4]'), math.matrix([true, false]));\n    });\n\n    it('should parse larger >', function() {\n      assert.equal(parseAndEval('2 > 3'), false);\n      assert.equal(parseAndEval('2 > 2'), false);\n      assert.equal(parseAndEval('2 > 1'), true);\n    });\n\n    it('should parse largerEq >=', function() {\n      assert.equal(parseAndEval('2 >= 3'), false);\n      assert.equal(parseAndEval('2 >= 2'), true);\n      assert.equal(parseAndEval('2 >= 1'), true);\n    });\n\n    it('should parse mod %', function() {\n      approx.equal(parseAndEval('8 % 3'), 2);\n    });\n\n    it('should parse operator mod', function() {\n      approx.equal(parseAndEval('8 mod 3'), 2);\n    });\n\n    it('should parse multiply *', function() {\n      approx.equal(parseAndEval('4 * 2'), 8);\n      approx.equal(parseAndEval('8 * 2 * 2'), 32);\n    });\n\n    it('should parse implicit multiplication', function() {\n      assert.equal(parseAndEval('4a', {a:2}), 8);\n      assert.equal(parseAndEval('4 a', {a:2}), 8);\n      assert.equal(parseAndEval('a b', {a: 2, b: 4}), 8);\n      assert.equal(parseAndEval('2a b', {a: 2, b: 4}), 16);\n      assert.equal(parseAndEval('2a * b', {a: 2, b: 4}), 16);\n      assert.equal(parseAndEval('2a / b', {a: 2, b: 4}), 1);\n      assert.equal(parseAndEval('a b c', {a: 2, b: 4, c: 6}), 48);\n      assert.equal(parseAndEval('a b*c', {a: 2, b: 4, c: 6}), 48);\n      assert.equal(parseAndEval('a*b c', {a: 2, b: 4, c: 6}), 48);\n      assert.equal(parseAndEval('a/b c', {a: 4, b: 2, c: 6}), 12);\n\n      assert.equal(parseAndEval('1/2a', {a:2}), 1);\n      assert.equal(parseAndEval('8/2a/2', {a:2}), 4);\n      assert.equal(parseAndEval('8/2a*2', {a:2}), 16);\n      assert.equal(parseAndEval('4*2a', {a:2}), 16);\n      assert.equal(parseAndEval('3!10'), 60);\n\n      assert.equal(parseAndEval('(2+3)a', {a:2}), 10);\n      assert.equal(parseAndEval('(2+3)2'), 10);\n      assert.equal(parseAndEval('(2)(3)+4'), 10);\n      assert.equal(parseAndEval('2(3+4)'), 14);\n      assert.equal(parseAndEval('(2+3)-2'), 3); // no implicit multiplication, just a unary minus\n      assert.equal(parseAndEval('a(2+3)', {a: function() {return 42;}}), 42);        // function call\n      assert.equal(parseAndEval('a.b(2+3)', {a: {b: function() {return 42;}}}), 42); // function call\n      assert.equal(parseAndEval('(2+3)(4+5)'), 45);       // implicit multiplication\n      assert.equal(parseAndEval('(2+3)(4+5)(3-1)'), 90);  // implicit multiplication\n\n      assert.equal(parseAndEval('(2a)^3', {a:2}), 64);\n      assert.equal(parseAndEval('2a^3', {a:2}), 16);\n      assert.equal(parseAndEval('2(a)^3', {a:2}), 16);\n      assert.equal(parseAndEval('(2)a^3', {a:2}), 16);\n      assert.equal(parseAndEval('2^3a', {a:2}), 16);\n      assert.equal(parseAndEval('2^3(a)', {a:2}), 16);\n      assert.equal(parseAndEval('2^(3)(a)', {a:2}), 16);\n      assert.equal(parseAndEval('sqrt(2a)', {a:2}), 2);\n\n      assert.deepEqual(parseAndEval('[2, 3] 2'), math.matrix([4, 6]));\n      assert.deepEqual(parseAndEval('[2, 3] a', {a:2}), math.matrix([4, 6]));\n      assert.deepEqual(parseAndEval('A [2,2]', {A: [[1,2], [3,4]]}), 4);          // index\n      assert.deepEqual(parseAndEval('(A) [2,2]', {A: [[1,2], [3,4]]}), 4);        // index\n\n      assert.deepEqual(parseAndEval('[1,2;3,4] [2,2]'), 4);                       // index\n      assert.deepEqual(parseAndEval('([1,2;3,4])[2,2]'), 4);                      // index\n      assert.throws(function () {parseAndEval('2[1,2,3]')}, /Unexpected operator/);// index\n    });\n\n    it('should tell the OperatorNode about implicit multiplications', function() {\n      assert.equal(parse('2 + 3').implicit, false);\n      assert.equal(parse('4 * a').implicit, false);\n\n      assert.equal(parse('4a').implicit, true);\n      assert.equal(parse('4 a').implicit, true);\n      assert.equal(parse('a b').implicit, true);\n      assert.equal(parse('2a b').implicit, true);\n      assert.equal(parse('a b c').implicit, true);\n\n      assert.equal(parse('(2+3)a').implicit, true);\n      assert.equal(parse('(2+3)2').implicit, true);\n      assert.equal(parse('2(3+4)').implicit, true);\n    });\n\n    it('should correctly order consecutive multiplications and implicit multiplications', function() {\n      var node = parse('9km*3km');\n      assert.equal(node.toString({parenthesis: 'all'}), '((9 km) * 3) km');\n    });\n\n    it('should throw an error when having an implicit multiplication between two numbers', function() {\n      assert.throws(function () { math.parse('2 3'); }, /Unexpected part \"3\"/);\n      assert.throws(function () { math.parse('2 * 3 4'); }, /Unexpected part \"4\"/);\n      assert.throws(function () { math.parse('2 * 3 4 * 5'); }, /Unexpected part \"4\"/);\n      assert.throws(function () { math.parse('2 / 3 4 5'); }, /Unexpected part \"4\"/);\n      assert.throws(function () { math.parse('2 + 3 4'); }, /Unexpected part \"4\"/);\n      assert.throws(function () { math.parse('-2 2'); }, /Unexpected part \"2\"/);\n      assert.throws(function () { math.parse('+3 3'); }, /Unexpected part \"3\"/);\n      assert.throws(function () { math.parse('2^3 4'); }, /Unexpected part \"4\"/);\n    });\n\n    it('should parse pow ^', function() {\n      approx.equal(parseAndEval('2^3'), 8);\n      approx.equal(parseAndEval('-2^2'), -4);  // -(2^2)\n      approx.equal(parseAndEval('2^3^4'), 2.41785163922926e+24); // 2^(3^4)\n    });\n\n    it('should parse smaller <', function() {\n      assert.strictEqual(parseAndEval('2 < 3'), true);\n      assert.strictEqual(parseAndEval('2 < 2'), false);\n      assert.strictEqual(parseAndEval('2 < 1'), false);\n    });\n\n    it('should parse smallerEq <=', function() {\n      assert.strictEqual(parseAndEval('2 <= 3'), true);\n      assert.strictEqual(parseAndEval('2 <= 2'), true);\n      assert.strictEqual(parseAndEval('2 <= 1'), false);\n    });\n\n    it('should parse bitwise and &', function() {\n      assert.strictEqual(parseAndEval('2 & 6'), 2);\n      assert.strictEqual(parseAndEval('5 & 3'), 1);\n      assert.strictEqual(parseAndEval('true & true'), 1);\n      assert.strictEqual(parseAndEval('true & false'), 0);\n      assert.strictEqual(parseAndEval('false & true'), 0);\n      assert.strictEqual(parseAndEval('false & false'), 0);\n    });\n\n    it('should parse bitwise xor ^|', function() {\n      assert.strictEqual(parseAndEval('2 ^| 6'), 4);\n      assert.strictEqual(parseAndEval('5 ^| 3'), 6);\n      assert.strictEqual(parseAndEval('true ^| true'), 0);\n      assert.strictEqual(parseAndEval('true ^| false'), 1);\n      assert.strictEqual(parseAndEval('false ^| true'), 1);\n      assert.strictEqual(parseAndEval('false ^| false'), 0);\n    });\n\n    it('should parse bitwise or |', function() {\n      assert.strictEqual(parseAndEval('2 | 6'), 6);\n      assert.strictEqual(parseAndEval('5 | 3'), 7);\n      assert.strictEqual(parseAndEval('true | true'), 1);\n      assert.strictEqual(parseAndEval('true | false'), 1);\n      assert.strictEqual(parseAndEval('false | true'), 1);\n      assert.strictEqual(parseAndEval('false | false'), 0);\n    });\n\n    it('should parse bitwise left shift <<', function() {\n      assert.strictEqual(parseAndEval('23 << 1'), 46);\n    });\n\n    it('should parse bitwise right arithmetic shift >>', function() {\n      assert.strictEqual(parseAndEval('32 >> 4'), 2);\n      assert.strictEqual(parseAndEval('-12 >> 2'), -3);\n    });\n\n    it('should parse bitwise right logical shift >>>', function() {\n      assert.strictEqual(parseAndEval('32 >>> 4'), 2);\n      assert.strictEqual(parseAndEval('-12 >>> 2'), 1073741821);\n    });\n\n    it('should parse logical and', function() {\n      assert.strictEqual(parseAndEval('2 and 6'), true);\n      assert.strictEqual(parseAndEval('2 and 0'), false);\n      assert.strictEqual(parseAndEval('true and true'), true);\n      assert.strictEqual(parseAndEval('true and false'), false);\n      assert.strictEqual(parseAndEval('false and true'), false);\n      assert.strictEqual(parseAndEval('false and false'), false);\n    });\n\n    it('should parse logical xor', function() {\n      assert.strictEqual(parseAndEval('2 xor 6'), false);\n      assert.strictEqual(parseAndEval('2 xor 0'), true);\n      assert.strictEqual(parseAndEval('true xor true'), false);\n      assert.strictEqual(parseAndEval('true xor false'), true);\n      assert.strictEqual(parseAndEval('false xor true'), true);\n      assert.strictEqual(parseAndEval('false xor false'), false);\n    });\n\n    it('should parse logical or', function() {\n      assert.strictEqual(parseAndEval('2 or 6'), true);\n      assert.strictEqual(parseAndEval('2 or 0'), true);\n      assert.strictEqual(parseAndEval('true or true'), true);\n      assert.strictEqual(parseAndEval('true or false'), true);\n      assert.strictEqual(parseAndEval('false or true'), true);\n      assert.strictEqual(parseAndEval('false or false'), false);\n    });\n\n    it('should parse logical not', function() {\n      assert.strictEqual(parseAndEval('not 2'), false);\n      assert.strictEqual(parseAndEval('not not 2'), true);\n      assert.strictEqual(parseAndEval('not not not 2'), false);\n      assert.strictEqual(parseAndEval('not true'), false);\n\n      assert.strictEqual(parseAndEval('4*not 2'), 0);\n      assert.strictEqual(parseAndEval('4 * not 2'), 0);\n      assert.strictEqual(parseAndEval('4-not 2'), 4);\n      assert.strictEqual(parseAndEval('4 - not 2'), 4);\n      assert.strictEqual(parseAndEval('4+not 2'), 4);\n      assert.strictEqual(parseAndEval('4 + not 2'), 4);\n\n      assert.strictEqual(parseAndEval('10+not not 3'), 11);\n    });\n\n    it('should parse minus -', function() {\n      assert.equal(parseAndEval('4 - 2'), 2);\n      assert.equal(parseAndEval('8 - 2 - 2'), 4);\n    });\n\n    it('should parse unary minus -', function() {\n      assert.equal(parseAndEval('-2'), -2);\n      assert.equal(parseAndEval('--2'), 2);\n      assert.equal(parseAndEval('---2'), -2);\n\n      assert.equal(parseAndEval('4*-2'), -8);\n      assert.equal(parseAndEval('4 * -2'), -8);\n      assert.equal(parseAndEval('4+-2'), 2);\n      assert.equal(parseAndEval('4 + -2'), 2);\n      assert.equal(parseAndEval('4--2'), 6);\n      assert.equal(parseAndEval('4 - -2'), 6);\n\n      assert.equal(parseAndEval('5-3'), 2);\n      assert.equal(parseAndEval('5--3'), 8);\n      assert.equal(parseAndEval('5---3'), 2);\n      assert.equal(parseAndEval('5+---3'), 2);\n      assert.equal(parseAndEval('5----3'), 8);\n      assert.equal(parseAndEval('5+--(2+1)'), 8);\n    });\n\n    it('should parse unary +', function() {\n      assert.equal(parseAndEval('+2'), 2);\n      assert.equal(parseAndEval('++2'), 2);\n      assert.equal(parseAndEval('+++2'), 2);\n      assert.equal(parseAndEval('+true'), 1);\n\n      assert.equal(parseAndEval('4*+2'), 8);\n      assert.equal(parseAndEval('4 * +2'), 8);\n      assert.equal(parseAndEval('4-+2'), 2);\n      assert.equal(parseAndEval('4 - +2'), 2);\n      assert.equal(parseAndEval('4++2'), 6);\n      assert.equal(parseAndEval('4 + +2'), 6);\n\n      assert.equal(parseAndEval('5+3'), 8);\n      assert.equal(parseAndEval('5++3'), 8);\n    });\n\n    it('should parse unary ~', function() {\n      assert.equal(parseAndEval('~2'), -3);\n      assert.equal(parseAndEval('~~2'), 2);\n      assert.equal(parseAndEval('~~~2'), -3);\n      assert.equal(parseAndEval('~true'), -2);\n\n      assert.equal(parseAndEval('4*~2'), -12);\n      assert.equal(parseAndEval('4 * ~2'), -12);\n      assert.equal(parseAndEval('4-~2'), 7);\n      assert.equal(parseAndEval('4 - ~2'), 7);\n      assert.equal(parseAndEval('4+~2'), 1);\n      assert.equal(parseAndEval('4 + ~2'), 1);\n\n      assert.equal(parseAndEval('10+~~3'), 13);\n    });\n\n    it('should parse unary plus and minus  +, -', function() {\n      assert.equal(parseAndEval('-+2'), -2);\n      assert.equal(parseAndEval('-+-2'), 2);\n      assert.equal(parseAndEval('+-+-2'), 2);\n      assert.equal(parseAndEval('+-2'), -2);\n      assert.equal(parseAndEval('+-+2'), -2);\n      assert.equal(parseAndEval('-+-+2'), 2);\n    });\n\n    it('should parse unary plus and bitwise not  +, ~', function() {\n      assert.equal(parseAndEval('~+2'), -3);\n      assert.equal(parseAndEval('~+~2'), 2);\n      assert.equal(parseAndEval('+~+~2'), 2);\n      assert.equal(parseAndEval('+~2'), -3);\n      assert.equal(parseAndEval('+~+2'), -3);\n      assert.equal(parseAndEval('~+~+2'), 2);\n    });\n\n    it('should parse unary minus and bitwise not  -, ~', function() {\n      assert.equal(parseAndEval('~-2'), 1);\n      assert.equal(parseAndEval('~-~2'), -4);\n      assert.equal(parseAndEval('-~-~2'), 4);\n      assert.equal(parseAndEval('-~2'), 3);\n      assert.equal(parseAndEval('-~-2'), -1);\n      assert.equal(parseAndEval('~-~-2'), 0);\n    });\n\n    it('should parse unary plus + and logical not', function() {\n      assert.equal(parseAndEval('not+2'), false);\n      assert.equal(parseAndEval('not + not 2'), true);\n      assert.equal(parseAndEval('+not+not 2'), 1);\n      assert.equal(parseAndEval('+ not 2'), 0);\n      assert.equal(parseAndEval('+ not +2'), 0);\n      assert.equal(parseAndEval('not + not +2'), true);\n    });\n\n    it('should parse bitwise not ~ and logical not', function() {\n      assert.equal(parseAndEval('~not 2'), -1);\n      assert.equal(parseAndEval('~not~2'), -1);\n      assert.equal(parseAndEval('not~not~2'), false);\n      assert.equal(parseAndEval('not~2'), false);\n      assert.equal(parseAndEval('not~not 2'), false);\n      assert.equal(parseAndEval('~not~not 2'), -1);\n    });\n\n    it('should parse unary minus and logical not', function() {\n      assert.equal(parseAndEval('not-2'), false);\n      assert.equal(parseAndEval('not-not 2'), true);\n      assert.equal(parseAndEval('-not-not 2'), -1);\n      assert.equal(parseAndEval('-not 2'), -0);\n      assert.equal(parseAndEval('-not-2'), -0);\n      assert.equal(parseAndEval('not-not-2'), true);\n    });\n\n    it('should parse unequal !=', function() {\n      assert.strictEqual(parseAndEval('2 != 3'), true);\n      assert.strictEqual(parseAndEval('2 != 2'), false);\n      assert.deepEqual(parseAndEval('[2,3] != [2,4]'), math.matrix([false, true]));\n    });\n\n    it('should parse conditional expression a ? b : c', function() {\n      assert.equal(parseAndEval('2 ? true : false'), true);\n      assert.equal(parseAndEval('0 ? true : false'), false);\n      assert.equal(parseAndEval('false ? true : false'), false);\n\n      assert.equal(parseAndEval('2 > 0 ? 1 : 2 < 0 ? -1 : 0'), 1);\n      assert.equal(parseAndEval('(2 > 0 ? 1 : 2 < 0) ? -1 : 0'), -1);\n      assert.equal(parseAndEval('-2 > 0 ? 1 : -2 < 0 ? -1 : 0'), -1);\n      assert.equal(parseAndEval('0 > 0 ? 1 : 0 < 0 ? -1 : 0'), 0);\n    });\n\n    it('should lazily evaluate conditional expression a ? b : c', function() {\n      var scope = {};\n      math.parse('true ? (a = 2) : (b = 2)').compile().eval(scope);\n      assert.deepEqual(scope, {a: 2});\n    });\n\n    it('should throw an error when false part of conditional expression is missing', function() {\n      assert.throws(function() {parseAndEval('2 ? true');}, /False part of conditional expression expected/);\n    });\n\n    it('should parse : (range)', function() {\n      assert.ok(parseAndEval('2:5') instanceof Matrix);\n      assert.deepEqual(parseAndEval('2:5'), math.matrix([2,3,4,5]));\n      assert.deepEqual(parseAndEval('10:-2:0'), math.matrix([10,8,6,4,2,0]));\n      assert.deepEqual(parseAndEval('2:4.0'), math.matrix([2,3,4]));\n      assert.deepEqual(parseAndEval('2:4.5'), math.matrix([2,3,4]));\n      assert.deepEqual(parseAndEval('2:4.1'), math.matrix([2,3,4]));\n      assert.deepEqual(parseAndEval('2:3.9'), math.matrix([2,3]));\n      assert.deepEqual(parseAndEval('2:3.5'), math.matrix([2,3]));\n      assert.deepEqual(parseAndEval('3:-1:0.5'), math.matrix([3,2,1]));\n      assert.deepEqual(parseAndEval('3:-1:0.5'), math.matrix([3,2,1]));\n      assert.deepEqual(parseAndEval('3:-1:0.1'), math.matrix([3,2,1]));\n      assert.deepEqual(parseAndEval('3:-1:-0.1'), math.matrix([3,2,1,0]));\n    });\n\n    it('should parse to', function() {\n      approx.deepEqual(parseAndEval('2.54 cm to inch'), math.unit(1, 'inch').to('inch'));\n      approx.deepEqual(parseAndEval('2.54 cm + 2 inch to foot'), math.unit(0.25, 'foot').to('foot'));\n    });\n\n    it('should parse in', function() {\n      approx.deepEqual(parseAndEval('2.54 cm in inch'), math.unit(1, 'inch').to('inch'));\n    });\n\n    it('should parse factorial !', function() {\n      assert.deepEqual(parseAndEval('5!'), 120);\n      assert.deepEqual(parseAndEval('[1,2,3,4]!'), math.matrix([1,2,6,24]));\n      assert.deepEqual(parseAndEval('4!+2'), 26);\n      assert.deepEqual(parseAndEval('4!-2'), 22);\n      assert.deepEqual(parseAndEval('4!*2'), 48);\n      assert.deepEqual(parseAndEval('3!!'), 720);\n      assert.deepEqual(parseAndEval('[1,2;3,1]!\\'!'), math.matrix([[1, 720], [2, 1]]));\n      assert.deepEqual(parseAndEval('[4,5]![2]'), 120); // index [2]\n    });\n\n    it('should parse transpose \\'', function() {\n      assert.deepEqual(parseAndEval('23\\''), 23);\n      assert.deepEqual(parseAndEval('[1,2,3;4,5,6]\\''), math.matrix([[1,4],[2,5],[3,6]]));\n      assert.ok(parseAndEval('[1,2,3;4,5,6]\\'') instanceof Matrix);\n      assert.deepEqual(parseAndEval('[1:5]'), math.matrix([[1,2,3,4,5]]));\n      assert.deepEqual(parseAndEval('[1:5]\\''), math.matrix([[1],[2],[3],[4],[5]]));\n      assert.deepEqual(parseAndEval('size([1:5])'), math.matrix([1, 5]));\n      assert.deepEqual(parseAndEval('[1,2;3,4]\\''), math.matrix([[1,3],[2,4]]));\n    });\n\n    describe('operator precedence', function() {\n      it('should respect precedence of plus and minus', function () {\n        assert.equal(parseAndEval('4-2+3'), 5);\n        assert.equal(parseAndEval('4-(2+3)'), -1);\n        assert.equal(parseAndEval('4-2-3'), -1);\n        assert.equal(parseAndEval('4-(2-3)'), 5);\n      });\n\n      it('should respect precedence of plus/minus and multiply/divide', function () {\n        assert.equal(parseAndEval('2+3*4'), 14);\n        assert.equal(parseAndEval('2*3+4'), 10);\n      });\n\n      it('should respect precedence of plus/minus and pow', function () {\n        assert.equal(parseAndEval('2+3^2'), 11);\n        assert.equal(parseAndEval('3^2+2'), 11);\n        assert.equal(parseAndEval('8-2^2'), 4);\n        assert.equal(parseAndEval('4^2-2'), 14);\n      });\n\n      it('should respect precedence of multiply/divide and pow', function () {\n        assert.equal(parseAndEval('2*3^2'), 18);\n        assert.equal(parseAndEval('3^2*2'), 18);\n        assert.equal(parseAndEval('8/2^2'), 2);\n        assert.equal(parseAndEval('4^2/2'), 8);\n      });\n\n      it('should respect precedence of pow', function () {\n        assert.equal(parseAndEval('2^3'), 8);\n        assert.equal(parseAndEval('2^3^4'), Math.pow(2, Math.pow(3, 4)));\n        assert.equal(parseAndEval('1.5^1.5^1.5'), parseAndEval('1.5^(1.5^1.5)'));\n        assert.equal(parseAndEval('1.5^1.5^1.5^1.5'), parseAndEval('1.5^(1.5^(1.5^1.5))'));\n      });\n\n      it('should respect precedence of unary operations and pow', function () {\n        assert.equal(parseAndEval('-3^2'), -9);\n        assert.equal(parseAndEval('(-3)^2'), 9);\n        assert.equal(parseAndEval('2^-2'), 0.25);\n        assert.equal(parseAndEval('2^(-2)'), 0.25);\n\n        assert.equal(parseAndEval('+3^2'), 9);\n        assert.equal(parseAndEval('(+3)^2'), 9);\n        assert.equal(parseAndEval('2^(+2)'), 4);\n\n        assert.equal(parseAndEval('~3^2'), -10);\n        assert.equal(parseAndEval('(~3)^2'), 16);\n        assert.equal(parseAndEval('2^~2'), 0.125);\n        assert.equal(parseAndEval('2^(~2)'), 0.125);\n\n        assert.equal(parseAndEval('not 3^2'), false);\n        assert.equal(parseAndEval('(not 3)^2'), 0);\n        assert.equal(parseAndEval('2^not 2'), 1);\n        assert.equal(parseAndEval('2^(not 2)'), 1);\n      });\n\n      it('should respect precedence of factorial and pow', function () {\n        assert.equal(parseAndEval('2^3!'), 64);\n        assert.equal(parseAndEval('2^(3!)'), 64);\n        assert.equal(parseAndEval('3!^2'), 36);\n      });\n\n      it('should respect precedence of factorial and unary operations', function () {\n        assert.equal(parseAndEval('-4!'), -24);\n        assert.equal(parseAndEval('-(4!)'), -24);\n\n        assert.equal(parseAndEval('3!+2'), 8);\n        assert.equal(parseAndEval('(3!)+2'), 8);\n        assert.equal(parseAndEval('+4!'), 24);\n\n        assert.equal(parseAndEval('~4!+1'), -24);\n        assert.equal(parseAndEval('~(4!)+1'), -24);\n\n        assert.equal(parseAndEval('not 4!'), false);\n        assert.equal(parseAndEval('not not 4!'), true);\n        assert.equal(parseAndEval('not(4!)'), false);\n        assert.equal(parseAndEval('(not 4!)'), false);\n        assert.equal(parseAndEval('(not 4)!'), 1);\n      });\n\n      it('should respect precedence of transpose', function () {\n        var node = math.parse('a + b\\'');\n        assert(node instanceof OperatorNode);\n        assert.equal(node.op, '+');\n        assert.equal(node.args[0].toString(), 'a');\n        assert.equal(node.args[1].toString(), 'b\\'');\n      });\n\n      it('should respect precedence of transpose (2)', function () {\n        var node = math.parse('a ^ b\\'');\n        assert(node instanceof OperatorNode);\n        assert.equal(node.op, '^');\n        assert.equal(node.args[0].toString(), 'a');\n        assert.equal(node.args[1].toString(), 'b\\'');\n      });\n\n      it('should respect precedence of conditional operator and other operators', function () {\n        assert.equal(parseAndEval('2 > 3 ? true : false'), false);\n        assert.equal(parseAndEval('2 == 3 ? true : false'), false);\n        assert.equal(parseAndEval('3 ? 2 + 4 : 2 - 1'), 6);\n        assert.deepEqual(parseAndEval('3 ? true : false; 22'), new ResultSet([22]));\n        assert.deepEqual(parseAndEval('3 ? 5cm to m : 5cm in mm'), new Unit(5, 'cm').to('m'));\n        assert.deepEqual(parseAndEval('2 == 4-2 ? [1,2] : false'), math.matrix([1,2]));\n        assert.deepEqual(parseAndEval('false ? 1:2:6'), math.matrix([2,3,4,5,6]));\n      });\n\n      it('should respect precedence between left/right shift and relational operators', function () {\n        assert.strictEqual(parseAndEval('32 >> 4 == 2'), true);\n        assert.strictEqual(parseAndEval('2 == 32 >> 4'), true);\n        assert.strictEqual(parseAndEval('2 << 2 == 8'), true);\n        assert.strictEqual(parseAndEval('8 == 2 << 2'), true);\n      });\n\n      it('should respect precedence between relational operators and bitwise and', function () {\n        assert.strictEqual(parseAndEval('2 == 3 & 1'), 0);\n        assert.strictEqual(parseAndEval('3 & 1 == 2'), 0);\n        assert.strictEqual(parseAndEval('2 == (3 & 1)'), false);\n      });\n\n      it('should respect precedence between bitwise or | and logical and', function () {\n        assert.strictEqual(parseAndEval('2 | 2 and 4'), true);\n        assert.strictEqual(parseAndEval('4 and 2 | 2'), true);\n      });\n\n      it('should respect precedence between bitwise xor ^| and bitwise or |', function () {\n        assert.strictEqual(parseAndEval('4 ^| 6 | 2'), 2);\n        assert.strictEqual(parseAndEval('2 | 4 ^| 6'), 2);\n        assert.strictEqual(parseAndEval('(2 | 4) ^| 6'), 0);\n      });\n\n      it('should respect precedence between bitwise and & and bitwise or |', function () {\n        assert.strictEqual(parseAndEval('4 & 3 | 12'), 12);\n        assert.strictEqual(parseAndEval('12 | 4 & 3'), 12);\n        assert.strictEqual(parseAndEval('(12 | 4) & 3'), 0);\n      });\n\n      it('should respect precedence between logical and and or', function () {\n        assert.strictEqual(parseAndEval('false and true or true'), true);\n        assert.strictEqual(parseAndEval('false and (true or true)'), false);\n        assert.strictEqual(parseAndEval('true or true and false'), true);\n        assert.strictEqual(parseAndEval('(true or true) and false'), false);\n      });\n\n      it('should respect precedence of conditional operator and logical or', function () {\n        var node = math.parse('1 or 0 ? 2 or 3 : 0 or 0');\n        assert(node instanceof ConditionalNode);\n        assert.equal(node.condition.toString(), '1 or 0');\n        assert.equal(node.trueExpr.toString(), '2 or 3');\n        assert.equal(node.falseExpr.toString(), '0 or 0');\n        assert.strictEqual(node.compile().eval(), true);\n      });\n\n      it('should respect precedence of conditional operator and relational operators', function () {\n        var node = math.parse('a == b ? a > b : a < b');\n        assert(node instanceof ConditionalNode);\n        assert.equal(node.condition.toString(), 'a == b');\n        assert.equal(node.trueExpr.toString(), 'a > b');\n        assert.equal(node.falseExpr.toString(), 'a < b');\n      });\n\n      it('should respect precedence of conditional operator and range operator', function () {\n        var node = math.parse('a ? b : c : d');\n        assert(node instanceof ConditionalNode);\n        assert.equal(node.condition.toString(), 'a');\n        assert.equal(node.trueExpr.toString(), 'b');\n        assert.equal(node.falseExpr.toString(), 'c:d');\n      });\n\n      it('should respect precedence of conditional operator and range operator (2)', function () {\n        var node = math.parse('a ? (b : c) : (d : e)');\n        assert(node instanceof ConditionalNode);\n        assert.equal(node.condition.toString(), 'a');\n        assert.equal(node.trueExpr.toString(), '(b:c)');\n        assert.equal(node.falseExpr.toString(), '(d:e)');\n      });\n\n      it('should respect precedence of conditional operator and range operator (2)', function () {\n        var node = math.parse('a ? (b ? c : d) : (e ? f : g)');\n        assert(node instanceof ConditionalNode);\n        assert.equal(node.condition.toString(), 'a');\n        assert.equal(node.trueExpr.toString(), '(b ? c : d)');\n        assert.equal(node.falseExpr.toString(), '(e ? f : g)');\n      });\n\n      it('should respect precedence of range operator and relational operators', function () {\n        var node = math.parse('a:b == c:d');\n        assert(node instanceof OperatorNode);\n        assert.equal(node.args[0].toString(), 'a:b');\n        assert.equal(node.args[1].toString(), 'c:d');\n      });\n\n      it('should respect precedence of range operator and operator plus and minus', function () {\n        var node = math.parse('a + b : c - d');\n        assert(node instanceof RangeNode);\n        assert.equal(node.start.toString(), 'a + b');\n        assert.equal(node.end.toString(), 'c - d');\n      });\n\n      it('should respect precedence of \"to\" operator and relational operators', function () {\n        var node = math.parse('a == b to c');\n        assert(node instanceof OperatorNode);\n        assert.equal(node.args[0].toString(), 'a');\n        assert.equal(node.args[1].toString(), 'b to c');\n      });\n\n      it('should respect precedence of \"to\" operator and relational operators (2)', function () {\n        var node = math.parse('a to b == c');\n        assert(node instanceof OperatorNode);\n        assert.equal(node.args[0].toString(), 'a to b');\n        assert.equal(node.args[1].toString(), 'c');\n      });\n\n      // TODO: extensively test operator precedence\n\n    });\n  });\n\n  describe('functions', function () {\n    it('should evaluate function \"mod\"', function () {\n      approx.equal(parseAndEval('mod(8, 3)'), 2);\n\n    });\n\n    it('should evaluate function \"to\" ', function () {\n      approx.deepEqual(parseAndEval('to(5.08 cm * 1000, inch)'),\n          math.unit(2000, 'inch').to('inch'));\n    });\n\n    it('should evaluate function \"sort\" with a custom sort function', function () {\n      var scope = {};\n      parseAndEval('sortByLength(a, b) = size(a)[1] - size(b)[1]', scope);\n      assert.deepEqual(parseAndEval('sort([\"Langdon\", \"Tom\", \"Sara\"], sortByLength)', scope),\n          math.matrix([\"Tom\", \"Sara\", \"Langdon\"]));\n    });\n\n  });\n\n  describe('bignumber', function () {\n    var bigmath = math.create({\n      number: 'BigNumber'\n    });\n    var BigNumber = bigmath.type.BigNumber;\n\n    it('should parse numbers as bignumber', function() {\n      assert.deepEqual(bigmath.bignumber('2.3'), new BigNumber('2.3'));\n      assert.deepEqual(bigmath.eval('2.3'), new BigNumber('2.3'));\n      assert.deepEqual(bigmath.eval('2.3e+500'), new BigNumber('2.3e+500'));\n    });\n\n    it('should evaluate functions supporting bignumbers', function() {\n      assert.deepEqual(bigmath.eval('0.1 + 0.2'), new BigNumber('0.3'));\n    });\n\n    it('should evaluate functions supporting bignumbers', function() {\n      assert.deepEqual(bigmath.eval('add(0.1, 0.2)'), new BigNumber('0.3'));\n    });\n\n    it('should work with mixed numbers and bignumbers', function() {\n      approx.equal(bigmath.eval('pi + 1'), 4.141592653589793);\n    });\n\n    it('should evaluate functions not supporting bignumbers', function() {\n      approx.equal(bigmath.eval('sin(0.1)'), 0.09983341664682815);\n    });\n\n    it('should create a range from bignumbers', function() {\n      assert.deepEqual(bigmath.eval('4:6'),\n          bigmath.matrix([new BigNumber(4), new BigNumber(5), new BigNumber(6)]));\n      assert.deepEqual(bigmath.eval('0:2:4'),\n          bigmath.matrix([new BigNumber(0), new BigNumber(2), new BigNumber(4)]));\n    });\n\n    it('should create a matrix with bignumbers', function() {\n      assert.deepEqual(bigmath.eval('[0.1, 0.2]'),\n          bigmath.matrix([new BigNumber(0.1), new BigNumber(0.2)]));\n    });\n\n    it('should get an element from a matrix with bignumbers', function() {\n      var scope = {};\n      assert.deepEqual(bigmath.eval('a=[0.1, 0.2]', scope),\n          bigmath.matrix([new BigNumber(0.1), new BigNumber(0.2)]));\n\n      assert.deepEqual(bigmath.eval('a[1]', scope), new BigNumber(0.1));\n      assert.deepEqual(bigmath.eval('a[:]', scope),\n          bigmath.matrix([new BigNumber(0.1), new BigNumber(0.2)]));\n      assert.deepEqual(bigmath.eval('a[1:2]', scope),\n          bigmath.matrix([new BigNumber(0.1), new BigNumber(0.2)]));\n    });\n\n    it('should replace elements in a matrix with bignumbers', function() {\n      var scope = {};\n      assert.deepEqual(bigmath.eval('a=[0.1, 0.2]', scope),\n          bigmath.matrix([new BigNumber(0.1), new BigNumber(0.2)]));\n\n      bigmath.eval('a[1] = 0.3', scope);\n      assert.deepEqual(scope.a, bigmath.matrix([new BigNumber(0.3), new BigNumber(0.2)]));\n      bigmath.eval('a[:] = [0.5, 0.6]', scope);\n      assert.deepEqual(scope.a, bigmath.matrix([new BigNumber(0.5), new BigNumber(0.6)]));\n      bigmath.eval('a[1:2] = [0.7, 0.8]', scope);\n      assert.deepEqual(scope.a, bigmath.matrix([new BigNumber(0.7), new BigNumber(0.8)]));\n    });\n\n    it('should work with complex numbers (downgrades bignumbers to number)', function() {\n      assert.deepEqual(bigmath.eval('3i'), new Complex(0, 3));\n      assert.deepEqual(bigmath.eval('2 + 3i'), new Complex(2, 3));\n      assert.deepEqual(bigmath.eval('2 * i'), new Complex(0, 2));\n    });\n\n    it('should work with units', function() {\n      assert.deepEqual(bigmath.eval('2 cm'), new Unit(new BigNumber(2), 'cm'));\n    });\n  });\n\n  describe('scope', function () {\n\n    it('should use a given scope for assignments', function() {\n      var scope = {\n        a: 3,\n        b: 4\n      };\n      assert.deepEqual(parse('a*b').compile().eval(scope), 12);\n      assert.deepEqual(parse('c=5').compile().eval(scope), 5);\n      assert.deepEqual(parse('f(x) = x^a').compile().eval(scope).syntax, 'f(x)');\n\n\n      assert.deepEqual(Object.keys(scope).length, 4);\n      assert.deepEqual(scope.a, 3);\n      assert.deepEqual(scope.b, 4);\n      assert.deepEqual(scope.c, 5);\n      assert.deepEqual(typeof scope.f, 'function');\n\n      assert.equal(scope.f(3), 27);\n      scope.a = 2;\n      assert.equal(scope.f(3), 9);\n      scope.hello = function (name) {\n        return 'hello, ' + name + '!';\n      };\n      assert.deepEqual(parse('hello(\"jos\")').compile().eval(scope), 'hello, jos!');\n    });\n\n    it('should parse undefined symbols, defining symbols, and removing symbols', function() {\n      var scope = {};\n      var n = parse('q');\n      assert.throws(function () { n.compile().eval(scope); });\n      parse('q=33').compile().eval(scope);\n      assert.equal(n.compile().eval(scope), 33);\n      delete scope.q;\n      assert.throws(function () { n.compile().eval(scope); });\n\n      n = parse('qq[1,1]=33');\n      assert.throws(function () { n.compile().eval(scope); });\n      parse('qq=[1,2;3,4]').compile().eval(scope);\n      n.compile().eval(scope);\n      assert.deepEqual(scope.qq, math.matrix([[33,2],[3,4]]));\n      parse('qq=[4]').compile().eval(scope);\n      n.compile().eval(scope);\n      assert.deepEqual(scope.qq, math.matrix([[33]]));\n      delete scope.qq;\n      assert.throws(function () { n.compile().eval(scope); });\n    });\n\n    it('should evaluate a symbol with value null or undefined', function () {\n      assert.equal(parse('a').compile().eval({a: null}), null);\n      assert.equal(parse('a').compile().eval({a: undefined}), undefined);\n    });\n\n  });\n\n  describe('errors', function () {\n\n    it('should return IndexErrors with one based indices', function () {\n      // functions throw a zero-based error\n      assert.throws(function () {math.subset([1,2,3], math.index(4));}, /Index out of range \\(4 > 2\\)/);\n      assert.throws(function () {math.subset([1,2,3], math.index(-2));}, /Index out of range \\(-2 < 0\\)/);\n\n      // evaluation via parser throws one-based error\n      assert.throws(function () {math.eval('A[4]', {A:[1,2,3]});}, /Index out of range \\(4 > 3\\)/);\n      assert.throws(function () {math.eval('A[-2]', {A: [1,2,3]});}, /IndexError: Index out of range \\(-2 < 1\\)/);\n    });\n\n    it('should return DimensionErrors with one based indices (subset)', function () {\n      // TODO: it would be more clear when all errors where DimensionErrors\n\n      // functions throw a zero-based error\n      assert.throws(function () {math.subset([1,2,3], math.index(1,1));}, /DimensionError: Dimension mismatch \\(2 != 1\\)/);\n\n      // evaluation via parser throws one-based error\n      assert.throws(function () {math.eval('A[1,1]', {A: [1,2,3]});}, /DimensionError: Dimension mismatch \\(2 != 1\\)/);\n    });\n\n    it('should return DimensionErrors with one based indices (concat)', function () {\n      // TODO: it would be more clear when all errors where DimensionErrors\n\n      // functions throw a zero-based error\n      assert.throws(function () {math.concat([1,2], [[3,4]]);}, /DimensionError: Dimension mismatch \\(1 != 2\\)/);\n      assert.throws(function () {math.concat([[1,2]], [[3,4]], 2);}, /IndexError: Index out of range \\(2 > 1\\)/);\n      assert.throws(function () {math.concat([[1,2]], [[3,4]], -1);}, /IndexError: Index out of range \\(-1 < 0\\)/);\n\n      // evaluation via parser throws one-based error\n      assert.throws(function () {math.eval('concat([1,2], [[3,4]])');}, /DimensionError: Dimension mismatch \\(1 != 2\\)/);\n      assert.throws(function () {math.eval('concat([[1,2]], [[3,4]], 3)');}, /IndexError: Index out of range \\(3 > 2\\)/);\n      assert.throws(function () {math.eval('concat([[1,2]], [[3,4]], 0)');}, /IndexError: Index out of range \\(0 < 1\\)/);\n    });\n\n    it('should return DimensionErrors with one based indices (max)', function () {\n      // TODO: it would be more clear when all errors where DimensionErrors\n\n      // functions throw a zero-based error\n      // TODO\n\n      // evaluation via parser throws one-based error\n      assert.deepEqual(math.eval('max([[1,2], [3,4]])'), 4);\n      assert.deepEqual(math.eval('max([[1,2], [3,4]], 1)'), math.matrix([3, 4]));\n      assert.deepEqual(math.eval('max([[1,2], [3,4]], 2)'), math.matrix([2, 4]));\n      assert.throws(function () {math.eval('max([[1,2], [3,4]], 3)');}, /IndexError: Index out of range \\(3 > 2\\)/);\n      assert.throws(function () {math.eval('max([[1,2], [3,4]], 0)');}, /IndexError: Index out of range \\(0 < 1\\)/);\n    });\n\n    it('should return DimensionErrors with one based indices (min)', function () {\n      // TODO: it would be more clear when all errors where DimensionErrors\n\n      // functions throw a zero-based error\n      // TODO\n\n      // evaluation via parser throws one-based error\n      assert.deepEqual(math.eval('min([[1,2], [3,4]])'), 1);\n      assert.deepEqual(math.eval('min([[1,2], [3,4]], 1)'), math.matrix([1, 2]));\n      assert.deepEqual(math.eval('min([[1,2], [3,4]], 2)'), math.matrix([1, 3]));\n      assert.throws(function () {math.eval('min([[1,2], [3,4]], 3)');}, /IndexError: Index out of range \\(3 > 2\\)/);\n      assert.throws(function () {math.eval('min([[1,2], [3,4]], 0)');}, /IndexError: Index out of range \\(0 < 1\\)/);\n    });\n\n    it('should return DimensionErrors with one based indices (mean)', function () {\n      // TODO: it would be more clear when all errors where DimensionErrors\n\n      // functions throw a zero-based error\n      // TODO\n\n      // evaluation via parser throws one-based error\n      assert.deepEqual(math.eval('mean([[1,2], [3,4]])'), 2.5);\n      assert.deepEqual(math.eval('mean([[1,2], [3,4]], 1)'), math.matrix([2, 3]));\n      assert.deepEqual(math.eval('mean([[1,2], [3,4]], 2)'), math.matrix([1.5, 3.5]));\n      assert.throws(function () {math.eval('mean([[1,2], [3,4]], 3)');}, /IndexError: Index out of range \\(3 > 2\\)/);\n      assert.throws(function () {math.eval('mean([[1,2], [3,4]], 0)');}, /IndexError: Index out of range \\(0 < 1\\)/);\n    });\n\n  });\n\n  describe('node tree', function () {\n\n    // TODO: test parsing into a node tree\n\n    it('should correctly stringify a node tree', function() {\n      assert.equal(parse('0').toString(), '0');\n      assert.equal(parse('\"hello\"').toString(), '\"hello\"');\n      assert.equal(parse('[1, 2 + 3i, 4]').toString(), '[1, 2 + 3 i, 4]');\n      assert.equal(parse('1/2a').toString(), '1 / 2 a');\n    });\n\n    it('should correctly stringify an index with dot notation', function() {\n      assert.equal(parse('A[2]').toString(), 'A[2]');\n      assert.equal(parse('a[\"b\"]').toString(), 'a[\"b\"]');\n      assert.equal(parse('a.b').toString(), 'a.b');\n    });\n\n    describe('custom nodes', function () {\n      // define a custom node\n      function CustomNode (args) {\n        this.args = args;\n      }\n      CustomNode.prototype = new math.expression.node.Node();\n      CustomNode.prototype.toString = function () {\n        return 'CustomNode';\n      };\n      CustomNode.prototype._compile = function (defs) {\n        var strArgs = [];\n        this.args.forEach(function (arg) {\n          strArgs.push(arg.toString());\n        });\n        return '\"CustomNode(' + strArgs.join(', ') + ')\"';\n      };\n      CustomNode.prototype.forEach = function (callback) {\n        // we don't have childs\n      };\n\n      var options = {\n        nodes: {\n          custom: CustomNode\n        }\n      };\n\n      it('should parse custom nodes', function() {\n        var node = parse('custom(x, (2+x), sin(x))', options);\n        assert.equal(node.compile().eval(), 'CustomNode(x, (2 + x), sin(x))');\n      });\n\n      it('should parse custom nodes without parameters', function() {\n        var node = parse('custom()', options);\n        assert.equal(node.compile().eval(), 'CustomNode()');\n        assert.equal(node.filter(function (node) {return node instanceof CustomNode;}).length, 1);\n\n        var node2 = parse('custom', options);\n        assert.equal(node2.compile().eval(), 'CustomNode()');\n        assert.equal(node2.filter(function (node) {return node instanceof CustomNode;}).length, 1);\n      });\n\n      it('should throw an error on syntax errors in using custom nodes', function() {\n        assert.throws(function () {parse('custom(x', options);}, /Parenthesis \\) expected/);\n        assert.throws(function () {parse('custom(x, ', options);}, /Unexpected end of expression/);\n      });\n    });\n\n  });\n\n  describe ('expose test functions', function () {\n    it('should expose isAlpha', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isAlpha === 'function')\n    });\n\n    it('should expose isValidLatinOrGreek', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isValidLatinOrGreek === 'function')\n    });\n\n    it('should expose isValidMathSymbol', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isValidMathSymbol === 'function')\n    });\n\n    it('should expose isWhitespace', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isWhitespace === 'function')\n    });\n\n    it('should expose isDecimalMark', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isDecimalMark === 'function')\n    });\n\n    it('should expose isDigitDot', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isDigitDot === 'function')\n    });\n\n    it('should expose isDigit', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isDigit === 'function')\n    });\n\n    it('should allow overriding isAlpha', function() {\n      var originalIsAlpha = math.expression.parse.isAlpha;\n\n      // override isAlpha with one accepting $ characters too\n      math.expression.parse.isAlpha = function (c, cPrev, cNext) {\n        return /^[a-zA-Z_$]$/.test(c)\n      };\n\n      var node = math.expression.parse('$foo');\n      var result = node.eval({$foo: 42});\n      assert.equal(result, 42);\n\n      // restore original isAlpha\n      math.expression.parse.isAlpha = originalIsAlpha\n    });\n\n  });\n\n  it ('Should not allow crashing math by placing a clone function in the config', function () {\n    var mathClone = math.create();\n\n    try {\n      mathClone.eval('f(x)=1;config({clone:f})')\n    }\n    catch (err) {}\n\n    assert.equal(mathClone.eval('2'), 2);\n  });\n\n});\n", "var assert = require('assert');\nvar math = require('../../index');\n\ndescribe('security', function () {\n\n  it ('should not allow calling Function via constructor', function () {\n    assert.throws(function () {\n      math.eval('[].map.constructor(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n  })\n\n  it ('should not allow calling Function via constructor (2)', function () {\n    assert.throws(function () {\n      math.eval('sqrt.constructor(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: No access to method \"constructor\"/);\n  })\n\n  it ('should not allow calling Function via call/apply', function () {\n    assert.throws(function () {\n      math.eval('[].map.constructor.call(null, \"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n\n    assert.throws(function () {\n      math.eval('[].map.constructor.apply(null, [\"console.log(\\'hacked...\\')\"])()');\n    }, /Error: Cannot access method \"map\" as a property/);\n  })\n\n  it ('should not allow calling constructor of a class', function () {\n    assert.throws(function () {\n      math.eval('[].constructor()');\n    }, /Error: No access to method \"constructor\"/);\n  })\n\n  it ('should not allow calling constructor', function () {\n    assert.throws(function () {\n      math.eval('constructor');\n    }, /Error: No access to property \"constructor\"/);\n\n    assert.throws(function () {\n      math.eval('toString');\n    }, /Cannot access method \"toString\" as a property/);\n  })\n\n  it ('should not allow calling Function via constructor', function () {\n    assert.throws(function () {\n      math.eval('[].map.constructor(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n\n    assert.throws(function () {\n      math.eval('[].map[\"constructor\"](\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n  })\n\n  it ('should not allow calling Function via a disguised constructor', function () {\n    assert.throws(function () {\n      math.eval('prop=\"constructor\"; [].map[prop](\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n\n    assert.throws(function () {\n      math.eval('[].map[concat(\"constr\", \"uctor\")](\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n  })\n\n  it ('should not allow calling Function via bind', function () {\n    assert.throws(function () {\n      math.eval('[].map.constructor.bind()(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n  })\n\n  it ('should not allow calling Function via map/forEach', function () {\n    // TODO: simplify this test case, let it output console.log('hacked...')\n    assert.throws(function () {\n      math.eval('[\"//\",\"a/*\\\\nreturn process.mainModule.require\"]._data.map(cos.constructor)[1]()(\"child_process\").execSync(\"ps >&2\")');\n    }, /Error: No access to property \"_data/);\n  })\n\n  it ('should not allow calling Function via Object.assign', function () {\n    // TODO: simplify this test case, let it output console.log('hacked...')\n    assert.throws(function () {\n      math.eval('{}.constructor.assign(cos.constructor, {binding: cos.bind})\\n' +\n          '{}.constructor.assign(cos.constructor, {bind: null})\\n' +\n          'cos.constructor.binding()(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: No access to property \"bind/);\n  })\n\n  it ('should not allow calling Function via imported, overridden function', function () {\n    assert.throws(function () {\n      var math2 = math.create();\n      math2.eval('import({matrix:cos.constructor},{override:1});x=[\"console.log(\\'hacked...\\')\"];x()');\n    }, /Error: Undefined symbol import/);\n  })\n\n  it ('should not allow calling Function via index retrieval', function () {\n    assert.throws(function () {\n      math.eval('a=[\"console.log(\\'hacked...\\')\"]._data;a.isRange=true;x={subset:cos.constructor}[a];x()');\n    }, /Error: No access to property \"_data/);\n  })\n\n  it ('should not allow calling Function via getOwnPropertyDescriptor', function () {\n    assert.throws(function () {\n      math.eval('p = parser()\\n' +\n          'p.eval(\"\", [])\\n' +\n          'o = p.get(\"constructor\")\\n' +\n          'c = o.getOwnPropertyDescriptor(o.__proto__, \"constructor\")\\n' +\n          'c.value(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: No access to property \"constructor\"/);\n  })\n\n  it ('should not allow calling Function via a symbol', function () {\n    assert.throws(function () {\n      math.eval('O = {}.constructor\\n' +\n          'd = O.getOwnPropertyDescriptor(O.__proto__, \"constructor\")\\n' +\n          'eval(\"value\", d)(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: No access to property \"constructor/);\n  })\n\n  it ('should not allow calling Function via a specially encoded constructor property name', function () {\n    assert.throws(function () {\n      math.eval('[].map[\"\\\\x63onstructor\"](\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n  })\n\n  it ('should not allow creating an Object with forbidden properties', function () {\n    assert.throws(function () {\n      math.eval('{hasOwnProperty: 2}');\n    }, /Error: No access to property \"hasOwnProperty/);\n\n    assert.throws(function () {\n      math.eval('{constructor: 2}');\n    }, /Error: No access to property \"constructor/);\n\n    assert.throws(function () {\n      math.eval('{toString: 2}');\n    }, /Error: No access to property \"toString/);\n  })\n\n  it ('should not allow calling Object via a an object constructor', function () {\n    assert.throws(function () {\n            math.eval('{}.constructor.assign(expression.node.AssignmentNode.prototype, ' +\n                '{_compile: \"\".toString.bind(\"console.log(\\'hacked...\\')\")})\\n' +\n                'eval(\"a = 2\")');\n    }, /Error: No access to property \"constructor/);\n  })\n\n  it ('should not allow calling Object via a __defineGetter__', function () {\n    assert.throws(function () {\n      math.eval('expression.node.AssignmentNode.prototype.__defineGetter__(\"_compile\", ' +\n          '{}.valueOf.bind(\"\".toString.bind(\"console.log(\\'hacked...\\')\"))); eval(\"a = 2\")')\n    }, /Error: Undefined symbol expression/);\n  })\n\n  it ('should not allow calling eval via a custom compiled SymbolNode', function () {\n    assert.throws(function () {\n      math.eval(\"s={};s.__proto__=expression.node.SymbolNode[\\\"prototype\\\"];expression.node.SymbolNode.apply(s,[\\\"\\\\\\\");},\\\\\\\"exec\\\\\\\":function(a){return global.eval}};//\\\"]._data);s.compile().exec()(\\\"console.log(\\'hacked...\\')\\\")\")\n    }, /Error: Undefined symbol expression/);\n  })\n\n  it ('should not allow calling eval via parse', function () {\n    assert.throws(function () {\n      math.eval('x=parse(\\\"cos\\\");x.name = \\\"\\\\\\\");},\\\\\\\"eval\\\\\\\": function(a) {return global.eval}};\\/\\/a\\\"; x.compile().eval()(\\\"console.log(\\'hacked...\\')\\\")')\n    }, /No access to property \"name\"/);\n  })\n\n  it ('should not allow calling eval via parse (2)', function () {\n    assert.throws(function () {\n      math.eval('p = parse(\"{}[\\\\\"console.log(\\'hacked...\\')\\\\\"]\"); p.index.dimensions[\"0\"].valueType = \"boolean\"; p.eval()')\n    }, /No access to property \"index\"/);\n  })\n\n  it ('should not allow calling eval via function.syntax', function () {\n    assert.throws(function () {\n      math.eval('cos.syntax=\"global.eval\";s=unit(\"5 cm\");s.units=[]._data;s.value=cos;s._compile=s.toString;expression.node.Node.prototype.compile.call(s).eval()(\"console.log(\\'hacked...\\')\")')\n    }, /Error: No access to property \"syntax\"/);\n  })\n\n  it ('should not allow calling eval via clone', function () {\n    assert.throws(function () {\n      math.eval('expression.node.ConstantNode.prototype.clone.call({\"value\":\"eval\", \"valueType\":\"null\"}).eval()(\"console.log(\\'hacked...\\')\")')\n    }, /Error: Undefined symbol expression/);\n  })\n\n  it ('should not allow replacing _compile', function () {\n    assert.throws(function () {\n      math.eval('c(x,y)=\"console.log(\\'hacked...\\')\";expression.node.Node.prototype.compile.apply({_compile:c}).eval()')\n    }, /Error: Undefined symbol expression/);\n  })\n\n  it ('should not allow using restricted properties via subset (1)', function () {\n    assert.throws(function () {\n      math.eval('f()=false;' +\n          'g()={length:3};' +\n          'h()={\"0\":0,\"1\":0,\"2\":0};' +\n          'j(x)=[x(\"constructor\")];' +\n          'k(x)={map:j};' +\n          'i={isIndex:true,isScalar:f,size:g,min:h,max:h,dimension:k};' +\n          'subset(subset([[[0]]],i),index(1,1,1))(\"console.log(\\'hacked...\\')\")()')\n    }, /TypeError: Unexpected type of argument in function subset \\(expected: Index, actual: Object, index: 1\\)/);\n  })\n\n  it ('should not allow using restricted properties via subset (2)', function () {\n    assert.throws(function () {\n      math.eval(\"scope={}; setter = eval(\\\"f(obj, name, newValue, assign) = (obj[name] = newValue)\\\", scope); o = parse(\\\"1\\\"); setter(o, \\\"value\\\", \\\"eval\\\", subset); scope.obj.compile().eval()(\\\"console.log('hacked...')\\\")\")\n    }, /Error: Undefined symbol name/);\n  })\n\n  it ('should not allow using restricted properties via subset (3)', function () {\n    assert.throws(function () {\n      math.eval('subset(parse(\"1\"), index(\"value\"), \"eval\").compile().eval()(\"console.log(\\'hacked...\\')\")')\n    }, /Error: No access to property \"value/);\n  })\n\n  it ('should not allow inserting fake nodes with bad code via node.map or node.transform', function () {\n    assert.throws(function () {\n      math.eval(\"badValue = {\\\"isNode\\\": true, \\\"_compile\\\": eval(\\\"f(a, b) = \\\\\\\"eval\\\\\\\"\\\")}; x = eval(\\\"f(child, path, parent) = path ==\\\\\\\"value\\\\\\\" ? newChild : child\\\", {\\\"newChild\\\": badValue}); parse(\\\"x = 1\\\").map(x).compile().eval()(\\\"console.log(\\'hacked\\')\\\")\")\n    }, /TypeError: Callback function must return a Node/);\n\n    assert.throws(function () {\n      math.eval(\"badValue = {\\\"isNode\\\": true, \\\"type\\\": \\\"ConstantNode\\\", \\\"valueType\\\": \\\"string\\\", \\\"_compile\\\": eval(\\\"f(a, b) = \\\\\\\"eval\\\\\\\"\\\")}; x = eval(\\\"f(child, path, parent) = path ==\\\\\\\"value\\\\\\\" ? newChild : child\\\", {\\\"newChild\\\": badValue}); parse(\\\"x = 1\\\").map(x).compile().eval()(\\\"console.log(\\'hacked...\\')\\\")\")\n    }); // The error message is vague but well...\n  })\n\n  it ('should not allow replacing validateSafeMethod with a local variant', function () {\n    assert.throws(function () {\n      math.eval(\"eval(\\\"f(validateSafeMethod)=cos.constructor(\\\\\\\"return eval\\\\\\\")()\\\")(eval(\\\"f(x,y)=0\\\"))(\\\"console.log('hacked...')\\\")\")\n    }, /Error: No access to method \"constructor\"/);\n  })\n\n  it ('should not allow abusing toString', function () {\n    assert.throws(function () {\n      math.eval(\"badToString = eval(\\\"f() = 1\\\"); badReplace = eval(\\\"f(a, b) = \\\\\\\"eval\\\\\\\"\\\"); badNumber = {toString:badToString, replace:badReplace}; badNode = {\\\"isNode\\\": true, \\\"type\\\": \\\"ConstantNode\\\", \\\"valueType\\\": \\\"number\\\", \\\"value\\\": badNumber}; x = eval(\\\"f(child, path, parent) = badNode\\\", {badNode:badNode}); parse(\\\"(1)\\\").map(x).compile().eval()(\\\"console.log('hacked...')\\\")\")\n    }, /Error: No access to property \"toString\"/);\n  })\n\n  it ('should not allow creating a bad FunctionAssignmentNode', function () {\n    assert.throws(function () {\n      math.eval(\"badNode={isNode:true,type:\\\"FunctionAssignmentNode\\\",expr:parse(\\\"1\\\"),types:{join:eval(\\\"f(a)=\\\\\\\"\\\\\\\"\\\")},params:{\\\"forEach\\\":eval(\\\"f(x)=1\\\"),\\\"join\\\":eval(\\\"f(x)=\\\\\\\"){return eval;}});return fn;})())}});return fn;})());}};//\\\\\\\"\\\")}};parse(\\\"f()=x\\\").map(eval(\\\"f(a,b,c)=badNode\\\",{\\\"badNode\\\":badNode})).compile().eval()()()(\\\"console.log('hacked...')\\\")\")\n    }, /TypeError: Callback function must return a Node/);\n  })\n\n  it ('should not allow creating a bad OperatorNode (1)', function () {\n    assert.throws(function () {\n      math.eval(\"badNode={isNode:true,type:\\\"FunctionAssignmentNode\\\",expr:parse(\\\"1\\\"),types:{join:eval(\\\"f(a)=\\\\\\\"\\\\\\\"\\\")},params:{\\\"forEach\\\":eval(\\\"f(x)=1\\\"),\\\"join\\\":eval(\\\"f(x)=\\\\\\\"){return eval;}});return fn;})())}});return fn;})());}};//\\\\\\\"\\\")}};parse(\\\"f()=x\\\").map(eval(\\\"f(a,b,c)=badNode\\\",{\\\"badNode\\\":badNode})).compile().eval()()()(\\\"console.log('hacked...')\\\")\")\n    }, /TypeError: Callback function must return a Node/);\n  })\n\n  it ('should not allow creating a bad OperatorNode (2)', function () {\n    assert.throws(function () {\n      math.eval(\"parse(\\\"(0)\\\").map(eval(\\\"f(a,b,c)=d\\\",{d:{isNode:true,type:\\\"OperatorNode\\\",fn:\\\"__lookupGetter__\\\",args:{map:eval(\\\"f(a)=b\\\",{b:{join:eval(\\\"f(a)=\\\\\\\"1)||eval;}};//\\\\\\\"\\\")}})}}})).compile().eval()(\\\"console.log('hacked...')\\\")\")\n    }, /TypeError: Node expected for parameter \"content\"/);\n  })\n\n  it ('should not allow creating a bad ConstantNode', function () {\n    assert.throws(function () {\n      math.eval('f(x,y)=\"eval\";g()=3;fakeConstantNode={\"isNode\": true, \"type\": \"ConstantNode\", \"valueType\": \"number\", \"value\": {\"replace\": f, \"toString\": g}};injectFakeConstantNode(child,path,parent)=path==\"value\"?fakeConstantNode:child;parse(\"a=3\").map(injectFakeConstantNode).compile().eval()(\"console.log(\\'hacked...\\')\")')\n    }, /Error: No access to property \"toString\"/);\n  })\n\n  it ('should not allow creating a bad ArrayNode', function () {\n    assert.throws(function () {\n      math.eval('g(x)=\"eval\";f(x)=({join: g});fakeArrayNode={isNode: true, type: \"ArrayNode\", items: {map: f}};injectFakeArrayNode(child,path,parent)=path==\"value\"?fakeArrayNode:child;parse(\"a=3\").map(injectFakeArrayNode).compile().eval()[1](\"console.log(\\'hacked...\\')\")')\n    }, /TypeError: Callback function must return a Node/);\n  })\n\n  it ('should not allow unescaping escaped double quotes', function () {\n    // exploits:\n    // 1) A bug in validateSafeMethod which allows to call any method in Object.prototype\n    // 2) A bug in stringify\n    assert.throws(function () {\n      math.eval(\"x=parse(\\\"\\\\\\\"a\\\\\\\"\\\");x.__defineGetter__(\\\"value\\\",eval(\\\"f()=\\\\\\\"false\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"&&eval;}};\\\\\\/\\\\\\/\\\\\\\"\\\")); x.compile().eval()(\\\"console.log('hacked...')\\\")\")\n    }, /Error: No access to method \"__defineGetter__\"/);\n  })\n\n  it ('should not allow using method chain', function () {\n    assert.throws(function () {\n      math.eval(\"chain(\\\"a(){return eval;};function b\\\").typed({\\\"\\\":f()=0}).done()()(\\\"console.log(\\'hacked...\\')\\\")\")\n    }, /is not a function/);\n  })\n\n  it ('should not allow using method chain (2)', function () {\n    assert.throws(function () {\n      math.eval(\"evilMath=chain().create().done();evilMath.import({\\\"_compile\\\":f(a,b,c)=\\\"eval\\\",\\\"isNode\\\":f()=true}); parse(\\\"(1)\\\").map(g(a,b,c)=evilMath.chain()).compile().eval()(\\\"console.log(\\'hacked...\\')\\\")\")\n    }, /is not a function/);\n  })\n\n  it ('should not allow using method Chain', function () {\n    assert.throws(function () {\n      math.eval(\"x=parse(\\\"a\\\",{nodes:{a:Chain}});Chain.bind(x,{})();evilMath=x.create().done();evilMath.import({\\\"_compile\\\":f(a,b,c)=\\\"eval\\\",\\\"isNode\\\":f()=true}); parse(\\\"(1)\\\").map(g(a,b,c)=evilMath.chain()).compile().eval()(\\\"console.log(\\'hacked...\\')\\\")\");\n    }, /Undefined symbol Chain/);\n  })\n\n  it ('should allow calling functions on math', function () {\n    assert.equal(math.eval('sqrt(4)'), 2);\n  })\n\n  it ('should allow invoking methods on complex numbers', function () {\n    assert.deepEqual(math.eval('complex(4, 0).sqrt(2)'), math.complex(2, 0));\n  })\n\n  it ('should allow accessing properties on an object', function () {\n    assert.deepEqual(math.eval('obj.a', {obj: {a:42}}), 42);\n  })\n\n  it ('should not allow accessing inherited properties on an object', function () {\n    assert.throws(function () {\n      math.eval('obj.constructor', {obj: {a:42}});\n    }, /Error: No access to property \"constructor\"/)\n  })\n\n  it ('should not allow accessing __proto__', function () {\n    assert.throws(function () {\n      math.eval('{}.__proto__');\n    }, /Error: No access to property \"__proto__\"/)\n  })\n\n  it ('should not allow getting properties from non plain objects', function () {\n    assert.throws(function () {math.eval('[]._data')}, /No access to property \"_data\"/)\n    assert.throws(function () {math.eval('unit(\"5cm\").valueOf')}, /Cannot access method \"valueOf\" as a property/);\n  });\n\n  it ('should not have access to specific namespaces', function () {\n    Object.keys(math.expression.mathWithTransform).forEach (function (name) {\n      var value = math.expression.mathWithTransform[name];\n\n      // only plain functions allowed, no constructor functions\n      if (typeof value === 'function') {\n        assert.strictEqual(isPlainFunction(value), true,\n            'only plain functions expected, constructor functions not allowed (name: ' + name + ')');\n      }\n      else {\n        // plain objects not allowed, only class instances like units and complex numbers\n        if (value && typeof value === 'object') {\n          if (isPlainObject(value) && (name !== 'uninitialized' )) {\n            throw new Error('plain objects are not allowed, only class instances (object name: ' + name + ')');\n          }\n        }\n      }\n\n    });\n\n    assert.throws(function () {math.eval('expression')}, /Undefined symbol/);\n    assert.throws(function () {math.eval('type')}, /Undefined symbol/);\n    assert.throws(function () {math.eval('error')}, /Undefined symbol/);\n    assert.throws(function () {math.eval('json')}, /Undefined symbol/);\n\n    assert.strictEqual(math.expression.mathWithTransform.Matrix, undefined);\n    assert.strictEqual(math.expression.mathWithTransform.Node, undefined);\n    assert.strictEqual(math.expression.mathWithTransform.chain, undefined);\n    assert.deepEqual(math.eval('chain'), math.unit('chain'));\n  });\n\n});\n\nfunction isPlainObject (object) {\n  return typeof object === 'object' && object &&\n      object.constructor === Object &&\n      object.__proto__ === Object.prototype;\n}\n\nfunction isPlainFunction (fn) {\n  return typeof fn === 'function' && fn.prototype.constructor === fn;\n}\n"], "fixing_code": ["# History\n\n\n## not yet released, version 3.17.0\n\n- Improved `simplify` for nested exponentiations. Thanks @IvanVergiliev.\n- Fixed a security issue in `typed-function` allowing arbitrary code execution\n  in the JavaScript engine by creating a typed function with JavaScript code\n  in the name. Thanks Masato Kinugawa.\n\n\n## 2017-10-18, version 3.16.5\n\n- Fixed #954: Functions `add` and `multiply` not working when\n  passing three or more arrays or matrices.\n\n\n## 2017-10-01, version 3.16.4\n\n- Fixed #948, #949: function `simplify` returning wrong results or \n  running into an infinite recursive loop. Thanks @ericman314.\n- Fixed many small issues in the embedded docs.  Thanks @Schnark.\n\n\n## 2017-08-28, version 3.16.3\n\n- Fixed #934: Wrong simplification of unary minus. Thanks @firepick1.\n- Fixed #933: function `simplify` reordering operations. Thanks @firepick1.\n- Fixed #930: function `isNaN` returning wrong result for complex \n  numbers having just one of their parts (re/im) being `NaN`.\n- Fixed #929: `FibonacciHeap.isEmpty` returning wrong result.\n\n\n## 2017-08-20, version 3.16.2\n\n- Fixed #924: a regression in `simplify` not accepting the signature\n  `simplify(expr, rules, scope)` anymore. Thanks @firepick1.\n- Fixed missing parenthesis when stringifying expressions containing\n  implicit multiplications (see #922). Thanks @FSMaxB.\n\n\n## 2017-08-12, version 3.16.1\n\n- For security reasons, type checking is now done in a more strict\n  way using functions like `isComplex(x)` instead of duck type checking\n  like `x && x.isComplex === true`.\n- Fixed #915: No access to property \"name\".\n- Fixed #901: Simplify units when calling `unit.toNumeric()`.\n  Thanks @AlexanderBeyn.\n- Fixed `toString` of a parsed expression tree containing an\n  immediately invoked function assignment not being wrapped in\n  parenthesis (for example `(f(x) = x^2)(4)`).\n\n\n## 2017-08-06, version 3.16.0\n\n- Significant performance improvements in `math.simplify`.\n  Thanks @firepick1.\n- Improved API for `math.simplify`, optionally pass a scope with\n  variables which are resolved, see #907. Thanks @firepick1.\n- Fixed #912: math.js didn't work on IE10 anymore (regression\n  since 3.15.0).\n\n\n## 2017-07-29, version 3.15.0\n\n- Added support for the dollar character `$` in symbol names (see #895).\n- Allow objects with prototypes as scope again in the expression parser,\n  this was disabled for security reasons some time ago. See #888, #899.\n  Thanks @ThomasBrierley.\n- Fixed #846: Issues in the functions `map`, `forEach`, and `filter`\n  when used in the expression parser:\n  - Not being able to use a function assignment as inline expression\n    for the callback function.\n  - Not being able to pass an inline expression as callback for `map`\n    and `forEach`.\n  - Index and original array/matrix not passed in `map` and `filter`.\n\n\n## 2017-07-05, version 3.14.2\n\n- Upgraded to `fraction.js@4.0.2`\n- Fixed #891 using BigNumbers not working in browser environments.\n\n\n## 2017-06-30, version 3.14.1\n\n- Reverted to `fraction.js@4.0.0`, there is an issue with `4.0.1`\n  in the browser.\n\n\n## 2017-06-30, version 3.14.0\n\n- Implemented set methods `setCartesian`, `setDifference`,\n  `setDistinct`, `setIntersect`, `setIsSubset`, `setPowerset`,\n  `setSize`. Thanks @Nekomajin42.\n- Implemented method `toHTML` on nodes. Thanks @Nekomajin42.\n- Implemented `compareNatural` and `sort([...], 'natural')`.\n- Upgraded dependencies to the latest versions:\n  - `complex.js@2.0.4`\n  - `decimal.js@7.2.3`\n  - `fraction.js@4.0.1`\n  - `tiny-emitter@2.0.0`\n  - And all devDependencies.\n- Fixed #865: `splitUnit` can now deal with round-off errors.\n  Thanks @ericman314.\n- Fixed #876: incorrect definition for unit `erg`. Thanks @pjhampton.\n- More informative error message when using single quotes instead of\n  double quotes around a string. Thanks @HarrySarson.\n\n\n## 2017-05-27, version 3.13.3\n\n- Fixed a bug in function `intersection` of line and plane.\n  Thanks @viclai.\n- Fixed security vulnerabilities.\n\n\n## 2017-05-26, version 3.13.2\n\n- Disabled function `chain` inside the expression parser for security\n  reasons (it's not needed there anyway).\n- Fixed #856: function `subset` not returning non-primitive scalars\n  from Arrays correctly. (like `math.eval('arr[1]', {arr: [math.bignumber(2)]})`.\n- Fixed #861: physical constants not available in the expression parser.\n\n\n## 2017-05-12, version 3.13.1\n\n- Fixed creating units with an alias not working within the expression\n  parser.\n- Fixed security vulnerabilities. Thanks Sam.\n\n\n## 2017-05-12, version 3.13.0\n\n- Command line application can now evaluate inline expressions\n  like `mathjs 1+2`. Thanks @slavaGanzin.\n- Function `derivative` now supports `abs`. Thanks @tetslee.\n- Function `simplify` now supports BigNumbers. Thanks @tetslee.\n- Prevent against endless loops in `simplify`. Thanks @tetslee.\n- Fixed #813: function `simplify` converting small numbers to inexact\n  Fractions. Thanks @tetslee.\n- Fixed #838: Function `simplify` now supports constants like `e`.\n  Thanks @tetslee.\n\n\n## 2017-05-05, version 3.12.3\n\n- Fixed security vulnerabilities. Thanks Dan and Sam.\n\n\n## 2017-04-30, version 3.12.2\n\n- Added a rocket trajectory optimization example.\n\n\n## 2017-04-24, version 3.12.1\n\n- Fixed #804\n  - Improved handling of powers of `Infinity`. Thanks @HarrySarson.\n  - Fixed wrong formatting of complex NaN.\n- Fixed security vulnerabilities in the expression parser.\n  Thanks Sam and Dan.\n\n\n## 2017-04-17, version 3.12.0\n\n- Implemented QR decomposition, function `math.qr`. Thanks @HarrySarson.\n- Fixed #824: Calling `math.random()` freezes IE and node.js.\n\n\n## 2017-04-08, version 3.11.5\n\n- More security measures in the expression parser.\n  WARNING: the behavior of the expression parser is now more strict,\n  some undocumented features may not work any longer.\n  - Accessing and assigning properties is now only allowed on plain\n    objects, not on classes, arrays, and functions anymore.\n  - Accessing methods is restricted to a set of known, safe methods.\n\n\n## 2017-04-03, version 3.11.4\n\n- Fixed a security vulnerability in the expression parser. Thanks @xfix.\n\n\n## 2017-04-03, version 3.11.3\n\n- Fixed a security vulnerability in the expression parser. Thanks @xfix.\n\n\n## 2017-04-03, version 3.11.2\n\n- Fixed a security vulnerability in the expression parser. Thanks @xfix.\n\n\n## 2017-04-02, version 3.11.1\n\n- Fixed security vulnerabilities in the expression parser.\n  Thanks Joe Vennix and @xfix.\n\n\n## 2017-04-02, version 3.11.0\n\n- Implemented method Unit.toSI() to convert a unit to base SI units.\n  Thanks @ericman314.\n- Fixed #821, #822: security vulnerabilities in the expression parser.\n  Thanks @comex and @xfix.\n\n\n## 2017-03-31, version 3.10.3\n\n- More security fixes related to the ones fixed in `v3.10.2`.\n\n\n## 2017-03-31, version 3.10.2\n\n- Fixed a security vulnerability in the expression parser allowing\n  execution of arbitrary JavaScript. Thanks @CapacitorSet and @denvit.\n\n\n## 2017-03-26, version 3.10.1\n\n- Fixed `xgcd` for negative values. Thanks @litmit.\n- Fixed #807: function transform of existing functions not being removed when\n  overriding such a function.\n\n\n## 2017-03-05, version 3.10.0\n\n- Implemented function `reshape`. Thanks @patgrasso and @ericman314.\n- Implemented configuration option `seedRandom` for deterministic random\n  numbers. Thanks @morsecodist.\n- Small fixes in the docs. Thanks @HarrySarson.\n- Dropped support for component package manager (which became deprecated about\n  one and a half year ago).\n\n\n## 2017-02-22, version 3.9.3\n\n- Fixed #797: issue with production builds of React Native projects.\n- Fixed `math.round` not accepting inputs `NaN`, `Infinity`, `-Infinity`.\n- Upgraded all dependencies.\n\n\n## 2017-02-16, version 3.9.2\n\n- Fixed #795: Parse error in case of a multi-line expression with just comments.\n\n\n## 2017-02-06, version 3.9.1\n\n- Fixed #789: Math.js not supporting conversion of `string` to `BigNumber`,\n  `Fraction`, or `Complex` number.\n- Fixed #790: Expression parser did not pass function arguments of enclosing\n  functions via `scope` to functions having `rawArgs = true`.\n- Small fixes in the docs. Thanks @HarrySarson.\n\n\n## 2017-01-23, version 3.9.0\n\n- Implemented support for algebra: powerful new functions `simplify` and\n  `derivative`. Thanks @ericman314, @tetslee, and @BigFav.\n- Implemented Kronecker Product `kron`. Thanks @adamisntdead.\n- Reverted `FunctionNode` not accepting a string as function name anymore.\n- Fixed #765: `FunctionAssignmentNode.toString()` returning a string\n  incompatible with the function assignment syntax.\n\n\n## 2016-12-15, version 3.8.1\n\n- Implemented function `mad` (median absolute deviation). Thanks @ruhleder.\n- Fixed #762: expression parser failing to invoke a function returned\n  by a function.\n\n\n## 2016-11-18, version 3.8.0\n\n- Functions `add` and `multiply` now accept more than two arguments. See #739.\n- `OperatorNode` now supports more than two arguments. See #739. Thanks @FSMaxB.\n- Implemented a method `Node.cloneDeep` for the expression nodes. See #745.\n- Fixed a bug in `Node.clone()` not cloning implicit multiplication correctly.\n  Thanks @FSMaxB.\n- Fixed #737: Improved algorithm determining the best prefix for units.\n  It will now retain the original unit like `1 cm` when close enough,\n  instead of returning `10 mm`. Thanks @ericman314.\n- Fixed #732: Allow letter-like unicode characters like Ohm `\\u2126`.\n- Fixed #749: Units `rad`, `deg`, and `grad` can now have prefixes like `millirad`.\n- Some fixes in the docs and comments of examples. Thanks @HarrySarson.\n\n\n## 2016-11-05, version 3.7.0\n\n- Implemented method `Node.equals(other)` for all nodes of the expression parser.\n- Implemented BigNumber support in function `arg()`.\n- Command Line Interface loads faster.\n- Implicit conversions between Fractions and BigNumbers throw a neat error now\n  (See #710).\n\n\n## 2016-10-21, version 3.6.0\n\n- Implemented function `erf()`. THanks @patgrasso.\n- Extended function `cross()` to support n-d vectors. Thanks @patgrasso.\n- Extended function `pickRandom` with the option to pick multiple values from\n  an array and give the values weights: `pickRandom(possibles, number, weights)`.\n  Thanks @woylie.\n- Parser now exposes test functions like `isAlpha` which can be replaced in\n  order to adjust the allowed characters in variables names (See #715).\n- Fixed #727: Parser not throwing an error for invalid implicit multiplications\n  like `-2 2` and `2^3 4` (right after the second value of an operator).\n- Fixed #688: Describe allowed variable names in the docs.\n\n\n## 2016-09-21, version 3.5.3\n\n- Some more fixes regarding numbers ending with a decimal mark (like `2.`).\n\n\n## 2016-09-20, version 3.5.2\n\n- Fixed numbers ending with a decimal mark (like `2.`) not being supported by\n  the parser, solved the underlying ambiguity in the parser. See #707, #711.\n\n\n## 2016-09-12, version 3.5.1\n\n- Removed a left over console.log statement. Thanks @eknkc.\n\n\n## 2016-09-07, version 3.5.0\n\n- Comments of expressions are are now stored in the parsed nodes. See #690.\n- Fixed function `print` not accepting an Object with formatting options as\n  third parameter Thanks @ThomasBrierley.\n- Fixed #707: The expression parser no longer accepts numbers ending with a dot\n  like `2.`.\n\n\n## 2016-08-08, version 3.4.1\n\n- Fixed broken bundle files (`dist/math.js`, `dist/math.min.js`).\n- Fixed some layout issues in the function reference docs.\n\n\n## 2016-08-07, version 3.4.0\n\n- Implemented support for custom units using `createUnit`. Thanks @ericman314.\n- Implemented function `splitUnits`. Thanks @ericman314.\n- Implemented function `isPrime`. Thanks @MathBunny.\n\n\n## 2016-07-05, version 3.3.0\n\n- Implemented function `isNaN`.\n- Function `math.filter` now passes three arguments to the callback function:\n  value, index, and array.\n- Removed the check on the number of arguments from functions defined in the\n  expression parser (see #665).\n- Fixed #665: functions `map`, `forEach`, and `filter` now invoke callbacks\n  which are a typed-function with the correct number of arguments.\n\n\n## 2016-04-26, version 3.2.1\n\n- Fixed #651: unable to perform calculations on \"Unit-less\" units.\n- Fixed matrix.subset mutating the replacement matrix when unsqueezing it.\n\n\n## 2016-04-16, version 3.2.0\n\n- Implemented #644: method `Parser.getAll()` to retrieve all defined variables.\n- Upgraded dependencies (decimal.js@5.0.8, fraction.js@3.3.1,\n  typed-function@0.10.4).\n- Fixed #601: Issue with unnamed typed-functions by upgrading to\n  typed-function v0.10.4.\n- Fixed #636: More strict `toTex` templates, reckon with number of arguments.\n- Fixed #641: Bug in expression parser parsing implicit multiplication with\n  wrong precedence in specific cases.\n- Fixed #645: Added documentation about `engineering` notation of function\n  `math.format`.\n\n\n## 2016-04-03, version 3.1.4\n\n- Using ES6 Math functions like `Math.sinh`, `Math.cbrt`, `Math.sign`, etc when\n  available.\n- Fixed #631: unit aliases `weeks`, `months`, and `years` where missing.\n- Fixed #632: problem with escaped backslashes at the end of strings.\n- Fixed #635: `Node.toString` options where not passed to function arguments.\n- Fixed #629: expression parser throws an error when passing a number with\n  decimal exponent instead of parsing them as implicit multiplication.\n- Fixed #484, #555: inaccuracy of `math.sinh` for values between -1 and 1.\n- Fixed #625: Unit `in` (`inch`) not always working due to ambiguity with\n  the operator `a in b` (alias of `a to b`).\n\n\n## 2016-03-24, version 3.1.3\n\n- Fix broken bundle.\n\n\n## 2016-03-24, version 3.1.2\n\n- Fix broken npm release.\n\n\n## 2016-03-24, version 3.1.1\n\n- Fixed #621: a bug in parsing implicit multiplications like `(2)(3)+4`.\n- Fixed #623: `nthRoot` of zero with a negative root returned `0` instead of\n  `Infinity`.\n- Throw an error when functions `min`, `max`, `mean`, or `median` are invoked\n  with multiple matrices as arguments (see #598).\n\n\n## 2016-03-19, version 3.1.0\n\n- Hide multiplication operator by default when outputting `toTex` and `toString`\n  for implicit multiplications. Implemented and option to output the operator.\n- Implemented unit `kip` and alias `kips`. Thanks @hgupta9.\n- Added support for prefixes for units `mol` and `mole`. Thanks @stu-blair.\n- Restored support for implicit multiplications like `2(3+4)` and `(2+3)(4+5)`.\n- Some improvements in the docs.\n- Added automatic conversions from `boolean` and `null` to `Fraction`,\n  and conversions from `Fraction` to `Complex`.\n\n\n## 2016-03-04, version 3.0.0\n\n### breaking changes\n\n- More restricted support for implicit multiplication in the expression\n  parser: `(...)(...)` is now evaluated as a function invocation,\n  and `[...][...]` as a matrix subset.\n- Matrix multiplication no longer squeezes scalar outputs to a scalar value,\n  but leaves them as they are: a vector or matrix containing a single value.\n  See #529.\n- Assignments in the expression parser now return the assigned value rather\n  than the created or updated object (see #533). Example:\n\n  ```\n  A = eye(3)\n  A[1,1] = 2   # this assignment now returns 2 instead of A\n  ```\n\n- Expression parser now supports objects. This involves a refactoring and\n  extension in expression nodes:\n  - Implemented new node `ObjectNode`.\n  - Refactored `AssignmentNode`, `UpdateNode`, and `IndexNode` are refactored\n    into `AccessorNode`, `AssignmentNode`, and `IndexNode` having a different API.\n- Upgraded the used BigNumber library `decimal.js` to v5. Replaced the\n  trigonometric functions of math.js with those provided in decimal.js v5.\n  This can give slightly different behavior qua round-off errors.\n- Replaced the internal `Complex.js` class with the `complex.js` library\n  created by @infusion.\n- Entries in a matrix (typically numbers, BigNumbers, Units, etc) are now\n  considered immutable, they are no longer copied when performing operations on\n  the entries, improving performance.\n- Implemented nearly equal comparison for relational functions (`equal`,\n  `larger`, `smaller`, etc.) when using BigNumbers.\n- Changed the casing of the configuration options `matrix` (`Array` or `Matrix`)\n  and `number` (`number`, `BigNumber`, `Fraction`) such that they now match\n  the type returned by `math.typeof`. Wrong casing gives a console warning but\n  will still work.\n- Changed the default config value for `epsilon` from `1e-14` to `1e-12`,\n  see #561.\n\n### non-breaking changes\n\n- Extended function `pow` to return the real root for cubic roots of negative\n  numbers. See #525, #482, #567.\n- Implemented support for JSON objects in the expression parser and the\n  function `math.format`.\n- Function `math.fraction` now supports `BigNumber`, and function\n  `math.bignumber` now supports `Fraction`.\n- Expression parser now allows function and/or variable assignments inside\n  accessors and conditionals, like `A[x=2]` or `a > 2 ? b=\"ok\" : b=\"fail\"`.\n- Command line interface:\n  - Outputs the variable name of assignments.\n  - Fixed not rounding BigNumbers to 14 digits like numbers.\n  - Fixed non-working autocompletion of user defined variables.\n- Reorganized and extended docs, added docs on classes and more. Thanks @hgupta9.\n- Added new units `acre`, `hectare`, `torr`, `bar`, `mmHg`, `mmH2O`, `cmH2O`,\n  and added new aliases `acres`, `hectares`, `sqfeet`, `sqyard`, `sqmile`,\n  `sqmiles`, `mmhg`, `mmh2o`, `cmh2o`. Thanks @hgupta9.\n- Fixed a bug in the toString method of an IndexNode.\n- Fixed angle units `deg`, `rad`, `grad`, `cycle`, `arcsec`, and `arcmin` not\n  being defined as BigNumbers when configuring to use BigNumbers.\n\n\n## 2016-02-03, version 2.7.0\n\n- Added more unit aliases for time: `secs`, `mins`, `hr`, `hrs`. See #551.\n- Added support for doing operations with mixed `Fractions` and `BigNumbers`.\n- Fixed #540: `math.intersect()` returning null in some cases. Thanks @void42.\n- Fixed #546: Cannot import BigNumber, Fraction, Matrix, Array.\n  Thanks @brettjurgens.\n\n\n## 2016-01-08, version 2.6.0\n\n- Implemented (complex) units `VA` and `VAR`.\n- Implemented time units for weeks, months, years, decades, centuries, and \n  millennia. Thanks @owenversteeg.\n- Implemented new notation `engineering` in function `math.format`. \n  Thanks @johnmarinelli.\n- Fixed #523: In some circumstances, matrix subset returned a scalar instead \n  of the correct subset.\n- Fixed #536: A bug in an internal method used for sparse matrices.\n\n\n## 2015-12-05, version 2.5.0\n\n- Implemented support for numeric types `Fraction` and `BigNumber` in units.\n- Implemented new method `toNumeric` for units.\n- Implemented new units `arcsec`, `arcsecond`, `arcmin`, `arcminute`. \n  Thanks @devdevdata222.\n- Implemented new unit `Herts` (`Hz`). Thanks @SwamWithTurtles.\n- Fixed #485: Scoping issue with variables both used globally as well as in a \n  function definition.\n- Fixed: Function `number` didn't support `Fraction` as input.\n\n\n## 2015-11-14, version 2.4.2\n\n- Fixed #502: Issue with `format` in some JavaScript engines.\n- Fixed #503: Removed trailing commas and the use of keyword `import` as \n  property, as this gives issues with old JavaScript engines.\n\n\n## 2015-10-29, version 2.4.1\n\n- Fixed #480: `nthRoot` not working on Internet Explorer (up to IE 11).\n- Fixed #490: `nthRoot` returning an error for negative values like \n  `nthRoot(-2, 3)`.\n- Fixed #489: an issue with initializing a sparse matrix without data.\n  Thanks @Retsam.\n- Fixed: #493: function `combinations` did not throw an exception for \n  non-integer values of `k`.\n- Fixed: function `import` did not override typed functions when the option\n  override was set true.\n- Fixed: added functions `math.sparse` and `math.index` to the reference docs, \n  they where missing.\n- Fixed: removed memoization from `gamma` and `factorial` functions, this \n  could blow up memory.\n\n\n## 2015-10-09, version 2.4.0\n\n- Added support in the expression parser for mathematical alphanumeric symbols \n  in the expression parser: unicode range \\u{1D400} to \\u{1D7FF} excluding \n  invalid code points.\n- Extended function `distance` with more signatures. Thanks @kv-kunalvyas.\n- Fixed a bug in functions `sin` and `cos`, which gave wrong results for \n  BigNumber integer values around multiples of tau (i.e. `sin(bignumber(7))`).\n- Fixed value of unit `stone`. Thanks @Esvandiary for finding the error.\n\n\n## 2015-09-19, version 2.3.0\n\n- Implemented function `distance`. Thanks @devanp92.\n- Implemented support for Fractions in function `lcm`. Thanks @infusion.\n- Implemented function `cbrt` for numbers, complex numbers, BigNumbers, Units.\n- Implemented function `hypot`.\n- Upgraded to fraction.js v3.0.0.\n- Fixed #450: issue with non sorted index in sparse matrices.\n- Fixed #463, #322: inconsistent handling of implicit multiplication.\n- Fixed #444: factorial of infinity not returning infinity.\n\n\n## 2015-08-30, version 2.2.0\n\n- Units with powers (like `m^2` and `s^-1`) now output with the best prefix.\n- Implemented support for units to `abs`, `cube`, `sign`, `sqrt`, `square`.\n  Thanks @ericman314.\n- Implemented function `catalan` (Combinatorics). Thanks @devanp92.\n- Improved the `canDefineProperty` check to return false in case of IE8, which\n  has a broken implementation of `defineProperty`. Thanks @golmansax.\n- Fixed function `to` not working in case of a simplified unit.\n- Fixed #437: an issue with row swapping in `lup`, also affecting `lusolve`.\n\n\n## 2015-08-12, version 2.1.1\n\n- Fixed wrong values of the physical constants `speedOfLight`, `molarMassC12`,  \n  and `magneticFluxQuantum`. Thanks @ericman314 for finding two of them.\n\n\n## 2015-08-11, version 2.1.0\n\n- Implemented derived units (like `110 km/h in m/s`). Thanks @ericman314.\n- Implemented support for electric units. Thanks @ericman314.\n- Implemented about 50 physical constants like `speedOfLight`, `gravity`, etc. \n- Implemented function `kldivergence` (Kullback-Leibler divergence). \n  Thanks @saromanov.\n- Implemented function `mode`. Thanks @kv-kunalvyas.\n- Added support for unicode characters in the expression parser: greek letters\n  and latin letters with accents. See #265.\n- Internal functions `Unit.parse` and `Complex.parse` now throw an Error \n  instead of returning null when passing invalid input.\n\n\n## 2015-07-29, version 2.0.1\n\n- Fixed operations with mixed fractions and numbers be converted to numbers\n  instead of fractions.\n\n\n## 2015-07-28, version 2.0.0\n\n- Large internal refactoring:\n  - performance improvements.\n  - allows to create custom bundles\n  - functions are composed using `typed-function` and are extensible\n- Implemented support for fractions, powered by the library `fraction.js`.\n- Implemented matrix LU decomposition with partial pivoting and a LU based \n  linear equations solver (functions `lup` and `lusolve`). Thanks @rjbaucells.\n- Implemented a new configuration option `predictable`, which can be set to\n  true in order to ensure predictable function output types.\n- Implemented function `intersect`. Thanks @kv-kunalvyas.\n- Implemented support for adding `toTex` properties to custom functions.\n  Thanks @FSMaxB.\n- Implemented support for complex values to `nthRoot`. Thanks @gangachris.\n- Implemented util functions `isInteger`, `isNegative`, `isNumeric`, \n  `isPositive`, and `isZero`.\n\n### breaking changes\n\n- String input is now converted to numbers by default for all functions. \n- Adding two strings will no longer concatenate them, but will convert the \n  strings to numbers and add them.\n- Function `index` does no longer accept an array `[start, end, step]`, but\n  instead accepts an array with arbitrary index values. It also accepts\n  a `Range` object as input.\n- Function `typeof` no longer returns lower case names, but now returns lower\n  case names for primitives (like `number`, `boolean`, `string`), and \n  upper-camel-case for non-primitives (like `Array`, `Complex`, `Function`).\n- Function `import` no longer supports a module name as argument. Instead,\n  modules can be loaded using require: `math.import(require('module-name'))`.\n- Function `import` has a new option `silent` to ignore errors, and throws\n  errors on duplicates by default.\n- Method `Node.compile()` no longer needs `math` to be passed as argument.\n- Reintroduced method `Node.eval([scope])`.\n- Function `sum` now returns zero when input is an empty array. Thanks @FSMAxB.\n- The size of Arrays is no longer validated. Matrices will validate this on\n  creation.\n\n\n## 2015-07-12, version 1.7.1\n\n- Fixed #397: Inaccuracies in nthRoot for very large values, and wrong results \n  for very small values. (backported from v2)\n- Fixed #405: Parser throws error when defining a function in a multiline \n  expression.\n\n\n## 2015-05-31, version 1.7.0\n\n- Implemented function `quantileSeq` and `partitionSelect`. Thanks @BigFav.\n- Implemented functions `stirlingS2`, `bellNumbers`, `composition`, and \n  `multinomial`. Thanks @devanp92.\n- Improved the performance of `median` (see #373). Thanks @BigFav.\n- Extended the command line interface with a `mode` option to output either\n  the expressions result, string representation, or tex representation.\n  Thanks @FSMaxB.\n- Fixed #309: Function median mutating the input matrix. Thanks @FSMaxB. \n- Fixed `Node.transform` not recursing over replaced parts of the \n  node tree (see #349).\n- Fixed #381: issue in docs of `randomInt`.\n\n\n## 2015-04-22, version 1.6.0\n\n- Improvements in `toTex`. Thanks @FSMaxB.\n- Fixed #328: `abs(0 + 0i)` evaluated to `NaN`.\n- Fixed not being able to override lazy loaded constants.\n\n\n## 2015-04-09, version 1.5.2\n\n- Fixed #313: parsed functions did not handle recursive calls correctly.\n- Fixed #251: binary prefix and SI prefix incorrectly used for byte. Now \n  following SI standards (`1 KiB == 1024 B`, `1 kB == 1000 B`).\n- Performance improvements in parsed functions.\n\n\n## 2015-04-08, version 1.5.1\n\n- Fixed #316: a bug in rounding values when formatting.\n- Fixed #317, #319: a bug in formatting negative values.\n\n\n## 2015-03-28, version 1.5.0\n\n- Added unit `stone` (6.35 kg).\n- Implemented support for sparse matrices. Thanks @rjbaucells.\n- Implemented BigNumber support for function `atan2`. Thanks @BigFav.\n- Implemented support for custom LaTeX representations. Thanks @FSMaxB.\n- Improvements and bug fixes in outputting parentheses in `Node.toString` and\n  `Node.toTex` functions. Thanks @FSMaxB.\n- Fixed #291: function `format` sometimes returning exponential notation when\n  it should return a fixed notation.\n\n\n## 2015-02-28, version 1.4.0\n\n- Implemented trigonometric functions:\n  `acosh`, `acoth`, `acsch`, `asech`, `asinh`, `atanh`, `acot`, `acsc`, `asec`.\n  Thanks @BigFav.\n- Added BigNumber support for functions: `cot`, `csc`, `sec`, `coth`,\n  `csch`, `sech`. Thanks @BigFav.\n- Implemented support for serialization and deserialization of math.js data\n  types.\n- Fixed the calculation of `norm()` and `abs()` for large complex numbers.\n  Thanks @rjbaucells.\n- Fixed #281: improved formatting complex numbers. Round the real or imaginary\n  part to zero when the difference is larger than the configured precision.\n\n\n## 2015-02-09, version 1.3.0\n\n- Implemented BigNumber implementations of most trigonometric functions: `sin`,\n  `cos`, `tan`, `asin`, `acos`, `atan`, `cosh`, `sinh`, `tanh`. Thanks @BigFav.\n- Implemented function `trace`. Thanks @pcorey.\n- Faster loading of BigNumber configuration with a high precision by lazy\n  loading constants like `pi` and `e`.\n- Fixed constants `NaN` and `Infinity` not being BigNumber objects when\n  BigNumbers are configured.\n- Fixed missing parentheses in the `toTex` representation of function\n  `permutations`.\n- Some minor fixes in the docs. Thanks @KenanY.\n\n\n## 2014-12-25, version 1.2.0\n\n- Support for bitwise operations `bitAnd`, `bitNot`, `bitOr`, `bitXor`,\n  `leftShift`, `rightArithShift`, and `rightLogShift`. Thanks @BigFav.\n- Support for boolean operations `and`, `not`, `or`, `xor`. Thanks @BigFav.\n- Support for `gamma` function. Thanks @BigFav.\n- Converting a unit without value will now result in a unit *with* value,\n  i.e. `inch in cm` will return `2.54 cm` instead of `cm`.\n- Improved accuracy of `sinh` and complex `cos` and `sin`. Thanks @pavpanchekha.\n- Renamed function `select` to `chain`. The old function `select` will remain\n  functional until math.js v2.0.\n- Upgraded to decimal.js v4.0.1 (BigNumber library).\n\n\n## 2014-11-22, version 1.1.1\n\n- Fixed Unit divided by Number returning zero.\n- Fixed BigNumber downgrading to Number for a negative base in `pow`.\n- Fixed some typos in error messaging (thanks @andy0130tw) and docs.\n\n\n## 2014-11-15, version 1.1.0\n\n- Implemented functions `dot` (dot product), `cross` (cross product), and\n  `nthRoot`.\n- Officially opened up the API of expression trees:\n  - Documented the API.\n  - Implemented recursive functions `clone`, `map`, `forEach`, `traverse`,\n    `transform`, and `filter` for expression trees.\n  - Parameter `index` in the callbacks of `map` and `forEach` are now cloned\n    for every callback.\n  - Some internal refactoring inside nodes to make the API consistent:\n    - Renamed `params` to `args` and vice versa to make things consistent.\n    - Renamed `Block.nodes` to `Block.blocks`.\n    - `FunctionNode` now has a `name: string` instead of a `symbol: SymbolNode`.\n    - Changed constructor of `RangeNode` to\n      `new RangeNode(start: Node, end: Node [, step: Node])`.\n    - Nodes for a `BlockNode` must now be passed via the constructor instead\n      of via a function `add`.\n- Fixed `2e` giving a syntax error instead of being parsed as `2 * e`.\n\n\n## 2014-09-12, version 1.0.1\n\n- Disabled array notation for ranges in a matrix index in the expression parser \n  (it is confusing and redundant there).\n- Fixed a regression in the build of function subset not being able to return\n  a scalar.\n- Fixed some missing docs and broken links in the docs.\n\n\n## 2014-09-04, version 1.0.0\n\n- Implemented a function `filter(x, test)`.\n- Removed `math.distribution` for now, needs some rethinking.\n- `math.number` can convert units to numbers (requires a second argument)\n- Fixed some precedence issues with the range and conversion operators.\n- Fixed an zero-based issue when getting a matrix subset using an index \n  containing a matrix.\n\n\n## 2014-08-21, version 0.27.0\n\n- Implemented functions `sort(x [, compare])` and `flatten(x)`.\n- Implemented support for `null` in all functions.\n- Implemented support for \"rawArgs\" functions in the expression parser. Raw \n  functions are invoked with unevaluated parameters (nodes).\n- Expressions in the expression parser can now be spread over multiple lines,\n  like '2 +\\n3'.\n- Changed default value of the option `wrap` of function `math.import` to false.\n- Changed the default value for new entries in a resized matrix when to zero. \n  To leave new entries uninitialized, use the new constant `math.uninitialized` \n  as default value.\n- Renamed transform property from `__transform__` to `transform`, and documented\n  the transform feature.\n- Fixed a bug in `math.import` not applying options when passing a module name.\n- A returned matrix subset is now only squeezed when the `index` consists of\n  scalar values, and no longer for ranges resolving into a single value. \n\n\n## 2014-08-03, version 0.26.0\n\n- A new instance of math.js can no longer be created like `math([options])`,\n  to prevent side effects from math being a function instead of an object.\n  Instead, use the function `math.create([options])` to create a new instance.\n- Implemented `BigNumber` support for all constants: `pi`, `tau`, `e`, `phi`,\n  `E`, `LN2`, `LN10`, `LOG2E`, `LOG10E`, `PI`, `SQRT1_2`, and `SQRT2`.\n- Implemented `BigNumber` support for functions `gcd`, `xgcd`, and `lcm`.\n- Fixed function `gxcd` returning an Array when math.js was configured \n  as `{matrix: 'matrix'}`.\n- Multi-line expressions now return a `ResultSet` instead of an `Array`.\n- Implemented transforms (used right now to transform one-based indices to \n  zero-based for expressions).\n- When used inside the expression parser, functions `concat`, `min`, `max`,\n  and `mean` expect an one-based dimension number.\n- Functions `map` and `forEach` invoke the callback with one-based indices\n  when used from within the expression parser.\n- When adding or removing dimensions when resizing a matrix, the dimensions\n  are added/removed from the inner side (right) instead of outer side (left).\n- Improved index out of range errors.\n- Fixed function `concat` not accepting a `BigNumber` for parameter `dim`.\n- Function `squeeze` now squeezes both inner and outer singleton dimensions.\n- Output of getting a matrix subset is not automatically squeezed anymore\n  except for scalar output.\n- Renamed `FunctionNode` to `FunctionAssignmentNode`, and renamed `ParamsNode`\n  to `FunctionNode` for more clarity.\n- Fixed broken auto completion in CLI.\n- Some minor fixes.\n\n\n## 2014-07-01, version 0.25.0\n\n- The library now immediately returns a default instance of mathjs, there is\n  no need to instantiate math.js in a separate step unless one ones to set \n  configuration options: \n  \n        // instead of:\n        var mathjs = require('mathjs'),  // load math.js\n            math = mathjs();             // create an instance\n      \n        // just do:\n        var math = require('mathjs');\n- Implemented support for implicit multiplication, like `math.eval('2a', {a:3})`\n  and `math.eval('(2+3)(1-3)')`. This changes behavior of matrix indexes as \n  well: an expression like `[...][...]` is not evaluated as taking a subset of \n  the first matrix, but as an implicit multiplication of two matrices.\n- Removed utility function `ifElse`. This function is redundant now the \n  expression parser has a conditional operator `a ? b : c`.\n- Fixed a bug with multiplying a number with a temperature,  \n  like `math.eval('10 * celsius')`.\n- Fixed a bug with symbols having value `undefined` not being evaluated.\n\n\n## 2014-06-20, version 0.24.1\n\n- Something went wrong with publishing on npm.\n\n\n## 2014-06-20, version 0.24.0\n\n- Added constant `null`.\n- Functions `equal` and `unequal` support `null` and `undefined` now.\n- Function `typeof` now recognizes regular expressions as well.\n- Objects `Complex`, `Unit`, and `Help` now return their string representation\n  when calling `.valueOf()`.\n- Changed the default number of significant digits for BigNumbers from 20 to 64.\n- Changed the behavior of the conditional operator (a ? b : c) to lazy \n  evaluating.\n- Fixed imported, wrapped functions not accepting `null` and `undefined` as\n  function arguments.\n\n\n## 2014-06-10, version 0.23.0\n\n- Renamed some functions (everything now has a logical, camel case name):\n  - Renamed functions `edivide`, `emultiply`, and `epow` to `dotDivide`, \n    `dotMultiply`, and `dotPow` respectively. \n  - Renamed functions `smallereq` and `largereq` to `smallerEq` and `largerEq`.\n  - Renamed function `unary` to `unaryMinus` and added support for strings.\n- `end` is now a reserved keyword which cannot be used as function or symbol\n  name in the expression parser, and is not allowed in the scope against which\n  an expression is evaluated.\n- Implemented function `unaryPlus` and unary plus operator.\n- Implemented function `deepEqual` for matrix comparisons. \n- Added constant `phi`, the golden ratio (`phi = 1.618...`).\n- Added constant `version`, returning the version number of math.js as string.\n- Added unit `drop` (`gtt`).\n- Fixed not being able to load math.js using AMD/require.js.\n- Changed signature of `math.parse(expr, nodes)` to `math.parse(expr, options)`\n  where `options: {nodes: Object.<String, Node>}`\n- Removed matrix support from conditional function `ifElse`.\n- Removed automatic assignment of expression results to variable `ans`. \n  This functionality can be restored by pre- or postprocessing every evaluation, \n  something like:\n  \n        function evalWithAns (expr, scope) {\n          var ans = math.eval(expr, scope);\n          if (scope) {\n            scope.ans = ans;\n          }\n          return ans;\n        }\n\n\n## 2014-05-22, version 0.22.0\n\n- Implemented support to export expressions to LaTeX. Thanks Niels Heisterkamp\n  (@nheisterkamp).\n- Output of matrix multiplication is now consistently squeezed.\n- Added reference documentation in the section /docs/reference.\n- Fixed a bug in multiplying units without value with a number (like `5 * cm`).\n- Fixed a bug in multiplying two matrices containing vectors (worked fine for \n  arrays).\n- Fixed random functions not accepting Matrix as input, and always returning\n  a Matrix as output.\n\n\n## 2014-05-13, version 0.21.1\n\n- Removed `crypto` library from the bundle.\n- Deprecated functions `Parser.parse` and `Parser.compile`. Use\n  `math.parse` and `math.compile` instead.\n- Fixed function `add` not adding strings and matrices element wise.\n- Fixed parser not being able to evaluate an exponent followed by a unary minus\n  like `2^-3`, and a transpose followed by an index like `[3]'[1]`.\n\n\n## 2014-04-24, version 0.21.0\n\n- Implemented trigonometric hyperbolic functions `cosh`, `coth`, `csch`,\n  `sech`, `sinh`, `tanh`. Thanks Rogelio J. Baucells (@rjbaucells).\n- Added property `type` to all expression nodes in an expression tree.\n- Fixed functions `log`, `log10`, `pow`, and `sqrt` not supporting complex\n  results from BigNumber input (like `sqrt(bignumber(-4))`).\n\n\n## 2014-04-16, version 0.20.0\n\n- Switched to module `decimal.js` for BigNumber support, instead of\n  `bignumber.js`.\n- Implemented support for polar coordinates to the `Complex` datatype.\n  Thanks Finn Pauls (@finnp).\n- Implemented BigNumber support for functions `exp`, `log`, and `log10`.\n- Implemented conditional operator `a ? b : c` in expression parser.\n- Improved floating point comparison: the functions now check whether values\n  are nearly equal, against a configured maximum relative difference `epsilon`.\n  Thanks Rogelio J. Baucells (@rjbaucells).\n- Implemented function `norm`. Thanks Rogelio J. Baucells (@rjbaucells).\n- Improved function `ifElse`, is now specified for special data types too.\n- Improved function `det`. Thanks Bryan Cuccioli (@bcuccioli).\n- Implemented `BigNumber` support for functions `det` and `diag`.\n- Added unit alias `lbs` (pound mass).\n- Changed configuration option `decimals` to `precision` (applies to BigNumbers\n  only).\n- Fixed support for element-wise comparisons between a string and a matrix.\n- Fixed: expression parser now trows IndexErrors with one-based indices instead\n  of zero-based.\n- Minor bug fixes.\n\n\n## 2014-03-30, version 0.19.0\n\n- Implemented functions `compare`, `sum`, `prod`, `var`, `std`, `median`.\n- Implemented function `ifElse` Thanks @mtraynham.\n- Minor bug fixes.\n\n\n## 2014-02-15, version 0.18.1\n\n- Added unit `feet`.\n- Implemented function `compile` (shortcut for parsing and then compiling).\n- Improved performance of function `pow` for matrices. Thanks @hamadu.\n- Fixed broken auto completion in the command line interface.\n- Fixed an error in function `combinations` for large numbers, and\n  improved performance of both functions `combinations` and `permutations`.\n\n\n## 2014-01-18, version 0.18.0\n\n- Changed matrix index notation of expression parser from round brackets to\n  square brackets, for example `A[1, 1:3]` instead of `A(1, 1:3)`.\n- Removed need to use the `function` keyword for function assignments in the\n  expression parser, you can define a function now like `f(x) = x^2`.\n- Implemented a compilation step in the expression parser: expressions are\n  compiled into JavaScript, giving much better performance (easily 10x as fast).\n- Renamed unit conversion function and operator `in` to `to`. Operator `in` is\n  still available in the expression parser as an alias for `to`. Added unit\n  `in`, an abbreviation for `inch`. Thanks Elijah Insua (@tmpvar).\n- Added plurals and aliases for units.\n- Implemented an argument `includeEnd` for function `range` (false by default).\n- Ranges in the expression parser now support big numbers.\n- Implemented functions `permutations` and `combinations`.\n  Thanks Daniel Levin (@daniel-levin).\n- Added lower case abbreviation `l` for unit litre.\n\n\n## 2013-12-19, version 0.17.1\n\n- Fixed a bug with negative temperatures.\n- Fixed a bug with prefixes of units squared meter `m2` and cubic meter `m3`.\n\n\n## 2013-12-12, version 0.17.0\n\n- Renamed and flattened configuration settings:\n  - `number.defaultType` is now `number`.\n  - `number.precision` is now `decimals`.\n  - `matrix.defaultType` is now `matrix`.\n- Function `multiply` now consistently outputs a complex number on complex input.\n- Fixed `mod` and `in` not working as function (only as operator).\n- Fixed support for old browsers (IE8 and older), compatible when using es5-shim.\n- Fixed support for Java's ScriptEngine.\n\n\n## 2013-11-28, version 0.16.0\n\n- Implemented BigNumber support for arbitrary precision calculations.\n  Added settings `number.defaultType` and `number.precision` to configure\n  big numbers.\n- Documentation is extended.\n- Removed utility functions `isScalar`, `toScalar`, `isVector`, `toVector`\n  from `Matrix` and `Range`. Use `math.squeeze` and `math.size` instead.\n- Implemented functions `get` and `set` on `Matrix`, for easier and faster\n  retrieval/replacement of elements in a matrix.\n- Implemented function `resize`, handling matrices, scalars, and strings.\n- Functions `ones` and `zeros` now return an empty matrix instead of a\n  number 1 or 0 when no arguments are provided.\n- Implemented functions `min` and `max` for `Range` and `Index`.\n- Resizing matrices now leaves new elements undefined by default instead of\n  filling them with zeros. Function `resize` now has an extra optional\n  parameter `defaultValue`.\n- Range operator `:` in expression parser has been given a higher precedence.\n- Functions don't allow arguments of unknown type anymore.\n- Options be set when constructing a math.js instance or using the new function\n  `config(options`. Options are no longer accessible via `math.options`.\n- Renamed `scientific` notation to `exponential` in function `format`.\n- Function `format` outputs exponential notation with positive exponents now\n  always with `+` sign, so outputs `2.1e+3` instead of `2.1e3`.\n- Fixed function `squeeze` not being able squeeze into a scalar.\n- Some fixes and performance improvements in the `resize` and `subset`\n  functions.\n- Function `size` now adheres to the option `matrix.defaultType` for scalar\n  input.\n- Minor bug fixes.\n\n\n## 2013-10-26, version 0.15.0\n\n- Math.js must be instantiated now, static calls are no longer supported. Usage:\n  - node.js: `var math = require('mathjs')();`\n  - browser: `var math = mathjs();`\n- Implemented support for multiplying vectors with matrices.\n- Improved number formatting:\n  - Function `format` now support various options: precision, different\n    notations (`fixed`, `scientific`, `auto`), and more.\n  - Numbers are no longer rounded to 5 digits by default when formatted.\n  - Implemented a function `format` for `Matrix`, `Complex`, `Unit`, `Range`,\n    and `Selector` to format using options.\n  - Function `format` does only stringify values now, and has a new parameter\n    `precision` to round to a specific number of digits.\n  - Removed option `math.options.precision`,\n    use `math.format(value [, precision])` instead.\n  - Fixed formatting numbers as scientific notation in some cases returning\n    a zero digit left from the decimal point. (like \"0.33333e8\" rather than\n    \"3.3333e7\"). Thanks @husayt.\n- Implemented a function `print` to interpolate values in a template string,\n  this functionality was moved from the function `format`.\n- Implemented statistics function `mean`. Thanks Guillermo Indalecio Fernandez\n  (@guillermobox).\n- Extended and changed `max` and `min` for multi dimensional matrices: they now\n  return the maximum and minimum of the flattened array. An optional second\n  argument `dim` allows to calculate the `max` or `min` for specified dimension.\n- Renamed option `math.options.matrix.default` to\n  `math.options.matrix.defaultType`.\n- Removed support for comparing complex numbers in functions `smaller`,\n  `smallereq`, `larger`, `largereq`. Complex numbers cannot be ordered.\n\n\n## 2013-10-08, version 0.14.0\n\n- Introduced an option `math.options.matrix.default` which can have values\n  `matrix` (default) or `array`. This option is used by the functions `eye`,\n  `ones`, `range`, and `zeros`, to determine the type of matrix output.\n- Getting a subset of a matrix will automatically squeeze the resulting subset,\n  setting a subset of a matrix will automatically unsqueeze the given subset.\n- Removed concatenation of nested arrays in the expression parser.\n  You can now input nested arrays like in JavaScript. Matrices can be\n  concatenated using the function `concat`.\n- The matrix syntax `[...]` in the expression parser now creates 1 dimensional\n  matrices by default. `math.eval('[1,2,3,4]')` returns a matrix with\n  size `[4]`, `math.eval('[1,2;3,4]')` returns a matrix with size `[2,2]`.\n- Documentation is restructured and extended.\n- Fixed non working operator `mod` (modulus operator).\n\n\n## 2013-09-03, version 0.13.0\n\n- Implemented support for booleans in all relevant functions.\n- Implemented functions `map` and `forEach`. Thanks Sebastien Piquemal (@sebpic).\n- All construction functions can be used to convert the type of variables,\n  also element-wise for all elements in an Array or Matrix.\n- Changed matrix indexes of the expression parser to one-based with the\n  upper-bound included, similar to most math applications. Note that on a\n  JavaScript level, math.js uses zero-based indexes with excluded upper-bound.\n- Removed support for scalars in the function `subset`, it now only supports\n  Array, Matrix, and String.\n- Removed the functions `get` and `set` from a selector, they are a duplicate\n  of the function `subset`.\n- Replaced functions `get` and `set` of `Matrix` with a single function\n  `subset`.\n- Some moving around with code and namespaces:\n  - Renamed namespace `math.expr` to `math.expression` (contains Scope, Parser,\n    node objects).\n  - Renamed namespace `math.docs` to `math.expression.docs`.\n  - Moved `math.expr.Selector` to `math.chaining.Selector`.\n- Fixed some edge cases in functions `lcm` and `xgcd`.\n\n\n## 2013-08-22, version 0.12.1\n\n- Fixed outdated version of README.md.\n- Fixed a broken unit test.\n\n\n## 2013-08-22, version 0.12.0\n\n- Implemented functions `random([min, max])`, `randomInt([min, max])`,\n  `pickRandom(array)`. Thanks Sebastien Piquemal (@sebpic).\n- Implemented function `distribution(name)`, generating a distribution object\n  with functions `random`, `randomInt`, `pickRandom` for different\n  distributions. Currently supporting `uniform` and `normal`.\n- Changed the behavior of `range` to exclude the upper bound, so `range(1, 4)`\n  now returns `[1, 2, 3]` instead of `[1, 2, 3, 4]`.\n- Changed the syntax of `range`, which is now `range(start, end [, step])`\n  instead of `range(start, [step, ] end)`.\n- Changed the behavior of `ones` and `zeros` to geometric dimensions, for\n  example `ones(3)` returns a vector with length 3, filled with ones, and\n  `ones(3,3)` returns a 2D array with size [3, 3].\n- Changed the return type of `ones` and `zeros`: they now return an Array when\n  arguments are Numbers or an Array, and returns a Matrix when the argument\n  is a Matrix.\n- Change matrix index notation in parser from round brackets to square brackets,\n  for example `A[0, 0:3]`.\n- Removed the feature introduced in v0.10.0 to automatically convert a complex\n  value with an imaginary part equal to zero to a number.\n- Fixed zeros being formatted as null. Thanks @TimKraft.\n\n\n## 2013-07-23, version 0.11.1\n\n- Fixed missing development dependency\n\n\n## 2013-07-23, version 0.11.0\n\n- Changed math.js from one-based to zero-based indexes.\n  - Getting and setting matrix subset is now zero-based.\n  - The dimension argument in function `concat` is now zero-based.\n- Improvements in the string output of function help.\n- Added constants `true` and `false`.\n- Added constructor function `boolean`.\n- Fixed function `select` not accepting `0` as input.\n  Thanks Elijah Manor (@elijahmanor).\n- Parser now supports multiple unary minus operators after each other.\n- Fixed not accepting empty matrices like `[[], []]`.\n- Some fixes in the end user documentation.\n\n\n## 2013-07-08, version 0.10.0\n\n- For complex calculations, all functions now automatically replace results\n  having an imaginary part of zero with a Number. (`2i * 2i` now returns a\n  Number `-4` instead of a Complex `-4 + 0i`).\n- Implemented support for injecting custom node handlers in the parser. Can be\n  used for example to implement a node handler for plotting a graph.\n- Implemented end user documentation and a new `help` function.\n- Functions `size` and `squeeze` now return a Matrix instead of an Array as\n  output on Matrix input.\n- Added a constant tau (2 * pi). Thanks Zak Zibrat (@palimpsests).\n- Renamed function `unaryminus` to `unary`.\n- Fixed a bug in determining node dependencies in function assignments.\n\n\n## 2013-06-14, version 0.9.1\n\n- Implemented element-wise functions and operators: `emultiply` (`x .* y`),\n  `edivide` (`x ./ y`), `epow` (`x .^ y`).\n- Added constants `Infinity` and `NaN`.\n- Removed support for Workspace to keep the library focused on its core task.\n- Fixed a bug in the Complex constructor, not accepting NaN values.\n- Fixed division by zero in case of pure complex values.\n- Fixed a bug in function multiply multiplying a pure complex value with\n  Infinity.\n\n\n## 2013-05-29, version 0.9.0\n\n- Implemented function `math.parse(expr [,scope])`. Optional parameter scope can\n  be a plain JavaScript Object containing variables.\n- Extended function `math.expr(expr [, scope])` with an additional parameter\n  `scope`, similar to `parse`. Example: `math.eval('x^a', {x:3, a:2});`.\n- Implemented function `subset`, to get or set a subset from a matrix, string,\n  or other data types.\n- Implemented construction functions number and string (mainly useful inside\n  the parser).\n- Improved function `det`. Thanks Bryan Cuccioli (@bcuccioli).\n- Moved the parse code from prototype math.expr.Parser to function math.parse,\n  simplified Parser a little bit.\n- Strongly simplified the code of Scope and Workspace.\n- Fixed function mod for negative numerators, and added error messages in case\n  of wrong input.\n\n\n## 2013-05-18, version 0.8.2\n\n- Extended the import function and some other minor improvements.\n- Fixed a bug in merging one dimensional vectors into a matrix.\n- Fixed a bug in function subtract, when subtracting a complex number from a\n  real number.\n\n\n## 2013-05-10, version 0.8.1\n\n- Fixed an npm warning when installing mathjs globally.\n\n\n## 2013-05-10, version 0.8.0\n\n- Implemented a command line interface. When math.js is installed globally via\n  npm, the application is available on your system as 'mathjs'.\n- Implemented `end` keyword for index operator, and added support for implicit\n  start and end (expressions like `a(2,:)` and `b(2:end,3:end-1)` are supported\n  now).\n- Function math.eval is more flexible now: it supports variables and multi-line\n  expressions.\n- Removed the read-only option from Parser and Scope.\n- Fixed non-working unequal operator != in the parser.\n- Fixed a bug in resizing matrices when replacing a subset.\n- Fixed a bug in updating a subset of a non-existing variable.\n- Minor bug fixes.\n\n\n## 2013-05-04, version 0.7.2\n\n- Fixed method unequal, which was checking for equality instead of inequality.\n  Thanks @FJS2.\n\n\n## 2013-04-27, version 0.7.1\n\n- Improvements in the parser:\n  - Added support for chained arguments.\n  - Added support for chained variable assignments.\n  - Added a function remove(name) to remove a variable from the parsers scope.\n  - Renamed nodes for more consistency and to resolve naming conflicts.\n  - Improved stringification of an expression tree.\n  - Some simplifications in the code.\n  - Minor bug fixes.\n- Fixed a bug in the parser, returning NaN instead of throwing an error for a\n  number with multiple decimal separators like `2.3.4`.\n- Fixed a bug in Workspace.insertAfter.\n- Fixed: math.js now works on IE 6-8 too.\n\n\n## 2013-04-20, version 0.7.0\n\n- Implemented method `math.eval`, which uses a readonly parser to evaluate\n  expressions.\n- Implemented method `xgcd` (extended eucledian algorithm). Thanks Bart Kiers\n  (@bkiers).\n- Improved math.format, which now rounds values to a maximum number of digits\n  instead of decimals (default is 5 digits, for example `math.format(math.pi)`\n  returns `3.1416`).\n- Added examples.\n- Changed methods square and cube to evaluate matrices element wise (consistent\n  with all other methods).\n- Changed second parameter of method import to an object with options.\n- Fixed method math.typeof on IE.\n- Minor bug fixes and improvements.\n\n\n## 2013-04-13, version 0.6.0\n\n- Implemented chained operations via method math.select(). For example\n  `math.select(3).add(4).subtract(2).done()` will return `5`.\n- Implemented methods gcd and lcm.\n- Implemented method `Unit.in(unit)`, which creates a clone of the unit with a\n  fixed representation. For example `math.unit('5.08 cm').in('inch')` will\n  return a unit which string representation always is in inch, thus `2 inch`.\n  `Unit.in(unit)` is the same as method `math.in(x, unit)`.\n- Implemented `Unit.toNumber(unit)`, which returns the value of the unit when\n  represented with given unit. For example\n  `math.unit('5.08 cm').toNumber('inch')` returns the number `2`, as the\n  representation of the unit in inches has 2 as value.\n- Improved: method `math.in(x, unit)` now supports a string as second parameter,\n  for example `math.in(math.unit('5.08 cm'), 'inch')`.\n- Split the end user documentation of the parser functions from the source\n  files.\n- Removed function help and the built-in documentation from the core library.\n- Fixed constant i being defined as -1i instead of 1i.\n- Minor bug fixes.\n\n\n## 2013-04-06, version 0.5.0\n\n- Implemented data types Matrix and Range.\n- Implemented matrix methods clone, concat, det, diag, eye, inv, ones, size,\n  squeeze, transpose, zeros.\n- Implemented range operator `:`, and transpose operator `'` in parser.\n- Changed: created construction methods for easy object creation for all data\n  types and for the parser. For example, a complex value is now created\n  with `math.complex(2, 3)` instead of `new math.Complex(2, 3)`, and a parser\n  is now created with `math.parser()` instead of `new math.parser.Parser()`.\n- Changed: moved all data types under the namespace math.type, and moved the\n  Parser, Workspace, etc. under the namespace math.expr.\n- Changed: changed operator precedence of the power operator:\n  - it is now right associative instead of left associative like most scripting\n    languages. So `2^3^4` is now calculated as `2^(3^4)`.\n  - it has now higher precedence than unary minus most languages, thus `-3^2` is\n    now calculated as `-(3^2)`.\n- Changed: renamed the parsers method 'put' into 'set'.\n- Fixed: method 'in' did not check for units to have the same base.\n\n\n## 2013-03-16, version 0.4.0\n\n- Implemented Array support for all methods.\n- Implemented Array support in the Parser.\n- Implemented method format.\n- Implemented parser for units, math.Unit.parse(str).\n- Improved parser for complex values math.Complex.parse(str);\n- Improved method help: it now evaluates the examples.\n- Fixed: a scoping issue with the Parser when defining functions.\n- Fixed: method 'typeof' was not working well with minified and mangled code.\n- Fixed: errors in determining the best prefix for a unit.\n\n\n## 2013-03-09, version 0.3.0\n\n- Implemented Workspace\n- Implemented methods cot, csc, sec.\n- Implemented Array support for methods with one parameter.\n\n\n## 2013-02-25, version 0.2.0\n\n- Parser, Scope, and expression tree with Nodes implemented.\n- Implemented method import which makes it easy to extend math.js.\n- Implemented methods arg, conj, cube, equal, factorial, im, largereq,\n  log(x, base), log10, mod, re, sign, smallereq, square, unequal.\n\n\n## 2013-02-18, version 0.1.0\n\n- Reached full compatibility with Javascripts built-in Math library.\n- More functions implemented.\n- Some bugfixes.\n\n\n## 2013-02-16, version 0.0.2\n\n- All constants of Math implemented, plus the imaginary unit i.\n- Data types Complex and Unit implemented.\n- First set of functions implemented.\n\n\n## 2013-02-15, version 0.0.1\n\n- First publish of the mathjs package. (package is still empty)\n", "'use strict';\n\nvar ArgumentsError = require('../error/ArgumentsError');\nvar deepMap = require('../utils/collection/deepMap');\n\nfunction factory (type, config, load, typed) {\n  var AccessorNode            = load(require('./node/AccessorNode'));\n  var ArrayNode               = load(require('./node/ArrayNode'));\n  var AssignmentNode          = load(require('./node/AssignmentNode'));\n  var BlockNode               = load(require('./node/BlockNode'));\n  var ConditionalNode         = load(require('./node/ConditionalNode'));\n  var ConstantNode            = load(require('./node/ConstantNode'));\n  var FunctionAssignmentNode  = load(require('./node/FunctionAssignmentNode'));\n  var IndexNode               = load(require('./node/IndexNode'));\n  var ObjectNode              = load(require('./node/ObjectNode'));\n  var OperatorNode            = load(require('./node/OperatorNode'));\n  var ParenthesisNode         = load(require('./node/ParenthesisNode'));\n  var FunctionNode            = load(require('./node/FunctionNode'));\n  var RangeNode               = load(require('./node/RangeNode'));\n  var SymbolNode              = load(require('./node/SymbolNode'));\n\n\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.eval();\n   *\n   * Syntax:\n   *\n   *     parse(expr)\n   *     parse(expr, options)\n   *     parse([expr1, expr2, expr3, ...])\n   *     parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     var node = parse('sqrt(3^2 + 4^2)');\n   *     node.compile(math).eval(); // 5\n   *\n   *     var scope = {a:3, b:4}\n   *     var node = parse('a * b'); // 12\n   *     var code = node.compile(math);\n   *     code.eval(scope); // 12\n   *     scope.a = 5;\n   *     code.eval(scope); // 20\n   *\n   *     var nodes = math.parse(['a = 3', 'b = 4', 'a * b']);\n   *     nodes[2].compile(math).eval(); // 12\n   *\n   * @param {string | string[] | Matrix} expr\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n  function parse (expr, options) {\n    if (arguments.length != 1 && arguments.length != 2) {\n      throw new ArgumentsError('parse', arguments.length, 1, 2);\n    }\n\n    // pass extra nodes\n    extra_nodes = (options && options.nodes) ? options.nodes : {};\n\n    if (typeof expr === 'string') {\n      // parse a single expression\n      expression = expr;\n      return parseStart();\n    }\n    else if (Array.isArray(expr) || expr instanceof type.Matrix) {\n      // parse an array or matrix with expressions\n      return deepMap(expr, function (elem) {\n        if (typeof elem !== 'string') throw new TypeError('String expected');\n\n        expression = elem;\n        return parseStart();\n      });\n    }\n    else {\n      // oops\n      throw new TypeError('String or matrix expected');\n    }\n  }\n\n  // token types enumeration\n  var TOKENTYPE = {\n    NULL : 0,\n    DELIMITER : 1,\n    NUMBER : 2,\n    SYMBOL : 3,\n    UNKNOWN : 4\n  };\n\n  // map with all delimiters\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\\\"': true,\n    ';': true,\n\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '\\'': true,\n    '=': true,\n    ':': true,\n    '?': true,\n\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  };\n\n  // map with all named delimiters\n  var NAMED_DELIMITERS = {\n    'mod': true,\n    'to': true,\n    'in': true,\n    'and': true,\n    'xor': true,\n    'or': true,\n    'not': true\n  };\n\n  var extra_nodes = {};             // current extra nodes\n  var expression = '';              // current expression\n  var comment = '';                 // last parsed comment\n  var index = 0;                    // current index in expr\n  var c = '';                       // current token character in expr\n  var token = '';                   // current token\n  var token_type = TOKENTYPE.NULL;  // type of the token\n  var nesting_level = 0;            // level of nesting inside parameters, used to ignore newline characters\n  var conditional_level = null;     // when a conditional is being parsed, the level of the conditional is stored here\n\n  /**\n   * Get the first character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n  function first() {\n    index = 0;\n    c = expression.charAt(0);\n    nesting_level = 0;\n    conditional_level = null;\n  }\n\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n  function next() {\n    index++;\n    c = expression.charAt(index);\n  }\n\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function prevPreview() {\n    return expression.charAt(index - 1);\n  }\n\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function nextPreview() {\n    return expression.charAt(index + 1);\n  }\n\n  /**\n   * Preview the second next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function nextNextPreview() {\n    return expression.charAt(index + 2);\n  }\n\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and token_type\n   * @private\n   */\n  function getToken() {\n    token_type = TOKENTYPE.NULL;\n    token = '';\n    comment = '';\n\n    // skip over whitespaces\n    // space, tab, and newline when inside parameters\n    while (parse.isWhitespace(c, nesting_level)) {\n      next();\n    }\n\n    // skip comment\n    if (c == '#') {\n      while (c != '\\n' && c != '') {\n        comment += c;\n        next();\n      }\n    }\n\n    // check for end of expression\n    if (c == '') {\n      // token is still empty\n      token_type = TOKENTYPE.DELIMITER;\n      return;\n    }\n\n    // check for new line character\n    if (c == '\\n' && !nesting_level) {\n      token_type = TOKENTYPE.DELIMITER;\n      token = c;\n      next();\n      return;\n    }\n\n    // check for delimiters consisting of 3 characters\n    var c2 = c + nextPreview();\n    var c3 = c2 + nextNextPreview();\n    if (c3.length == 3 && DELIMITERS[c3]) {\n      token_type = TOKENTYPE.DELIMITER;\n      token = c3;\n      next();\n      next();\n      next();\n      return;\n    }\n\n    // check for delimiters consisting of 2 characters\n    if (c2.length == 2 && DELIMITERS[c2]) {\n      token_type = TOKENTYPE.DELIMITER;\n      token = c2;\n      next();\n      next();\n      return;\n    }\n\n    // check for delimiters consisting of 1 character\n    if (DELIMITERS[c]) {\n      token_type = TOKENTYPE.DELIMITER;\n      token = c;\n      next();\n      return;\n    }\n\n    // check for a number\n    if (parse.isDigitDot(c)) {\n      token_type = TOKENTYPE.NUMBER;\n\n      // get number, can have a single dot\n      if (c == '.') {\n        token += c;\n        next();\n\n        if (!parse.isDigit(c)) {\n          // this is no number, it is just a dot (can be dot notation)\n          token_type = TOKENTYPE.DELIMITER;\n        }\n      }\n      else {\n        while (parse.isDigit(c)) {\n          token += c;\n          next();\n        }\n        if (parse.isDecimalMark(c, nextPreview())) {\n          token += c;\n          next();\n        }\n      }\n      while (parse.isDigit(c)) {\n        token += c;\n        next();\n      }\n\n      // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n      c2 = nextPreview();\n      if (c == 'E' || c == 'e') {\n        if (parse.isDigit(c2) || c2 == '-' || c2 == '+') {\n          token += c;\n          next();\n\n          if (c == '+' || c == '-') {\n            token += c;\n            next();\n          }\n\n          // Scientific notation MUST be followed by an exponent\n          if (!parse.isDigit(c)) {\n            throw createSyntaxError('Digit expected, got \"' + c + '\"');\n          }\n\n          while (parse.isDigit(c)) {\n            token += c;\n            next();\n          }\n\n          if (parse.isDecimalMark(c, nextPreview())) {\n            throw createSyntaxError('Digit expected, got \"' + c + '\"');\n          }\n        }\n        else if (c2 == '.') {\n          next();\n          throw createSyntaxError('Digit expected, got \"' + c + '\"');\n        }\n      }\n\n      return;\n    }\n\n    // check for variables, functions, named operators\n    if (parse.isAlpha(c, prevPreview(), nextPreview())) {\n      while (parse.isAlpha(c, prevPreview(), nextPreview()) || parse.isDigit(c)) {\n        token += c;\n        next();\n      }\n\n      if (NAMED_DELIMITERS.hasOwnProperty(token)) {\n        token_type = TOKENTYPE.DELIMITER;\n      }\n      else {\n        token_type = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    }\n\n    // something unknown is found, wrong characters -> a syntax error\n    token_type = TOKENTYPE.UNKNOWN;\n    while (c != '') {\n      token += c;\n      next();\n    }\n    throw createSyntaxError('Syntax error in part \"' + token + '\"');\n  }\n\n  /**\n   * Get next token and skip newline tokens\n   */\n  function getTokenSkipNewline () {\n    do {\n      getToken();\n    }\n    while (token == '\\n');\n  }\n\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams() is called\n   */\n  function openParams() {\n    nesting_level++;\n  }\n\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n  function closeParams() {\n    nesting_level--;\n  }\n\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n  parse.isAlpha = function isAlpha (c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c)\n        || parse.isValidMathSymbol(c, cNext)\n        || parse.isValidMathSymbol(cPrev, c);\n  };\n\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek (c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * http://unicode-table.com/en/\n   * http://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * http://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n  parse.isValidMathSymbol = function isValidMathSymbol (high, low) {\n    return /^[\\uD835]$/.test(high) &&\n        /^[\\uDC00-\\uDFFF]$/.test(low) &&\n        /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n  parse.isWhitespace = function isWhitespace (c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c == ' ' || c == '\\t' || (c == '\\n' && nestingLevel > 0);\n  };\n\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n  parse.isDecimalMark = function isDecimalMark (c, cNext) {\n    return c == '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n  parse.isDigitDot = function isDigitDot (c) {\n    return ((c >= '0' && c <= '9') || c == '.');\n  };\n\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n  parse.isDigit = function isDigit (c) {\n    return (c >= '0' && c <= '9');\n  };\n\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n  function parseStart () {\n    // get the first character in expression\n    first();\n\n    getToken();\n\n    var node = parseBlock();\n\n    // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and token_type DELIMITER\n    if (token != '') {\n      if (token_type == TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean != ?\"\n        throw createError('Unexpected operator ' + token);\n      }\n      else {\n        throw createSyntaxError('Unexpected part \"' + token + '\"');\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n  function parseBlock () {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (token != '' && token != '\\n' && token != ';') {\n      node = parseAssignment();\n      node.comment = comment;\n    }\n\n    // TODO: simplify this loop\n    while (token == '\\n' || token == ';') {\n      if (blocks.length == 0 && node) {\n        visible = (token != ';');\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n\n      getToken();\n      if (token != '\\n' && token != ';' && token != '') {\n        node = parseAssignment();\n        node.comment = comment;\n\n        visible = (token != ';');\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    }\n    else {\n      if (!node) {\n        node = new ConstantNode('undefined', 'undefined');\n        node.comment = comment;\n      }\n\n      return node\n    }\n  }\n\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n  function parseAssignment () {\n    var name, args, value, valid;\n\n    var node = parseConditional();\n\n    if (token == '=') {\n      if (type.isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline();\n        value = parseAssignment();\n        return new AssignmentNode(new SymbolNode(name), value);\n      }\n      else if (type.isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline();\n        value = parseAssignment();\n        return new AssignmentNode(node.object, node.index, value);\n      }\n      else if (type.isFunctionNode(node) && type.isSymbolNode(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (type.isSymbolNode(arg)) {\n            args[index] = arg.name;\n          }\n          else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline();\n          value = parseAssignment();\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError('Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n  function parseConditional () {\n    var node = parseLogicalOr();\n\n    while (token == '?') {\n      // set a conditional level, the range operator will be ignored as long\n      // as conditional_level == nesting_level.\n      var prev = conditional_level;\n      conditional_level = nesting_level;\n      getTokenSkipNewline();\n\n      var condition = node;\n      var trueExpr = parseAssignment();\n\n      if (token != ':') throw createSyntaxError('False part of conditional expression expected');\n\n      conditional_level = null;\n      getTokenSkipNewline();\n\n      var falseExpr = parseAssignment(); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr);\n\n      // restore the previous conditional level\n      conditional_level = prev;\n    }\n\n    return node;\n  }\n\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalOr() {\n    var node = parseLogicalXor();\n\n    while (token == 'or') {\n      getTokenSkipNewline();\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalXor() {\n    var node = parseLogicalAnd();\n\n    while (token == 'xor') {\n      getTokenSkipNewline();\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalAnd() {\n    var node = parseBitwiseOr();\n\n    while (token == 'and') {\n      getTokenSkipNewline();\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseOr() {\n    var node = parseBitwiseXor();\n\n    while (token == '|') {\n      getTokenSkipNewline();\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseXor() {\n    var node = parseBitwiseAnd();\n\n    while (token == '^|') {\n      getTokenSkipNewline();\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseAnd () {\n    var node = parseRelational();\n\n    while (token == '&') {\n      getTokenSkipNewline();\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational()]);\n    }\n\n    return node;\n  }\n\n  /**\n   * relational operators\n   * @return {Node} node\n   * @private\n   */\n  function parseRelational () {\n    var node, operators, name, fn, params;\n\n    node = parseShift();\n\n    operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getTokenSkipNewline();\n      params = [node, parseShift()];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n  function parseShift () {\n    var node, operators, name, fn, params;\n\n    node = parseConversion();\n\n    operators = {\n      '<<' : 'leftShift',\n      '>>' : 'rightArithShift',\n      '>>>' : 'rightLogShift'\n    };\n\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getTokenSkipNewline();\n      params = [node, parseConversion()];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n  function parseConversion () {\n    var node, operators, name, fn, params;\n\n    node = parseRange();\n\n    operators = {\n      'to' : 'to',\n      'in' : 'to'   // alias of 'to'\n    };\n\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getTokenSkipNewline();\n      \n      if (name === 'in' && token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      }\n      else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange()];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n  function parseRange () {\n    var node, params = [];\n\n    if (token == ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode('1', 'number');\n    }\n    else {\n      // explicit start\n      node = parseAddSubtract();\n    }\n\n    if (token == ':' && (conditional_level !== nesting_level)) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node);\n\n      // parse step and end\n      while (token == ':' && params.length < 3) {\n        getTokenSkipNewline();\n\n        if (token == ')' || token == ']' || token == ',' || token == '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        }\n        else {\n          // explicit end\n          params.push(parseAddSubtract());\n        }\n      }\n\n      if (params.length == 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      }\n      else { // length == 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n  function parseAddSubtract ()  {\n    var node, operators, name, fn, params;\n\n    node = parseMultiplyDivide();\n\n    operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getTokenSkipNewline();\n      params = [node, parseMultiplyDivide()];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n  function parseMultiplyDivide () {\n    var node, last, operators, name, fn;\n\n    node = parseUnary();\n    last = node;\n\n    operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide',\n      '%': 'mod',\n      'mod': 'mod'\n    };\n\n    while (true) {\n      if (operators.hasOwnProperty(token)) {\n        // explicit operators\n        name = token;\n        fn = operators[name];\n\n        getTokenSkipNewline();\n\n        last = parseUnary();\n        node = new OperatorNode(name, fn, [node, last]);\n      }\n      else if ((token_type === TOKENTYPE.SYMBOL) ||\n          (token === 'in' && type.isConstantNode(node)) ||\n          (token_type === TOKENTYPE.NUMBER &&\n              !type.isConstantNode(last) &&\n              (!type.isOperatorNode(last) || last.op === '!')) ||\n          (token === '(')) {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseUnary();\n        node = new OperatorNode('*', 'multiply', [node, last], true /*implicit*/);\n      }\n      else {\n        break;\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n  function parseUnary () {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      'not': 'not'\n    };\n\n    if (operators.hasOwnProperty(token)) {\n      fn = operators[token];\n      name = token;\n\n      getTokenSkipNewline();\n      params = [parseUnary()];\n\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow();\n  }\n\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n  function parsePow () {\n    var node, name, fn, params;\n\n    node = parseLeftHandOperators();\n\n    if (token == '^' || token == '.^') {\n      name = token;\n      fn = (name == '^') ? 'pow' : 'dotPow';\n\n      getTokenSkipNewline();\n      params = [node, parseUnary()]; // Go back to unary, we can have '2^-3'\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n\n  /**\n   * Left hand operators: factorial x!, transpose x'\n   * @return {Node} node\n   * @private\n   */\n  function parseLeftHandOperators ()  {\n    var node, operators, name, fn, params;\n\n    node = parseCustomNodes();\n\n    operators = {\n      '!': 'factorial',\n      '\\'': 'transpose'\n    };\n\n    while (operators.hasOwnProperty(token)) {\n      name = token;\n      fn = operators[name];\n\n      getToken();\n      params = [node];\n\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(node);\n    }\n\n    return node;\n  }\n\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.expression.node.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     };\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params);\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes);\n   *\n   * @return {Node} node\n   * @private\n   */\n  function parseCustomNodes () {\n    var params = [];\n\n    if (token_type == TOKENTYPE.SYMBOL && extra_nodes.hasOwnProperty(token)) {\n      var CustomNode = extra_nodes[token];\n\n      getToken();\n\n      // parse parameters\n      if (token == '(') {\n        params = [];\n\n        openParams();\n        getToken();\n\n        if (token != ')') {\n          params.push(parseAssignment());\n\n          // parse a list with parameters\n          while (token == ',') {\n            getToken();\n            params.push(parseAssignment());\n          }\n        }\n\n        if (token != ')') {\n          throw createSyntaxError('Parenthesis ) expected');\n        }\n        closeParams();\n        getToken();\n      }\n\n      // create a new custom node\n      //noinspection JSValidateTypes\n      return new CustomNode(params);\n    }\n\n    return parseSymbol();\n  }\n\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n  function parseSymbol () {\n    var node, name;\n\n    if (token_type == TOKENTYPE.SYMBOL ||\n        (token_type == TOKENTYPE.DELIMITER && token in NAMED_DELIMITERS)) {\n      name = token;\n\n      getToken();\n\n      // parse function parameters and matrix index\n      node = new SymbolNode(name);\n      node = parseAccessors(node);\n      return node;\n    }\n\n    return parseString();\n  }\n\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2)\n   * - index enclosed in square brackets [...], for example A[2,3]\n   * - dot notation for properties, like foo.bar\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n  function parseAccessors (node, types) {\n    var params;\n\n    while ((token === '(' || token === '[' || token === '.') &&\n        (!types || types.indexOf(token) !== -1)) {\n      params = [];\n\n      if (token === '(') {\n        if (type.isSymbolNode(node) || type.isAccessorNode(node) || type.isFunctionNode(node)) {\n          // function invocation like fn(2, 3)\n          openParams();\n          getToken();\n\n          if (token !== ')') {\n            params.push(parseAssignment());\n\n            // parse a list with parameters\n            while (token === ',') {\n              getToken();\n              params.push(parseAssignment());\n            }\n          }\n\n          if (token !== ')') {\n            throw createSyntaxError('Parenthesis ) expected');\n          }\n          closeParams();\n          getToken();\n\n          node = new FunctionNode(node, params);\n        }\n        else {\n          // implicit multiplication like (2+3)(4+5)\n          // don't parse it here but let it be handled by parseMultiplyDivide\n          // with correct precedence\n          return node;\n        }\n      }\n      else if (token === '[') {\n        // index notation like variable[2, 3]\n        openParams();\n        getToken();\n\n        if (token !== ']') {\n          params.push(parseAssignment());\n\n          // parse a list with parameters\n          while (token === ',') {\n            getToken();\n            params.push(parseAssignment());\n          }\n        }\n\n        if (token !== ']') {\n          throw createSyntaxError('Parenthesis ] expected');\n        }\n        closeParams();\n        getToken();\n\n        node = new AccessorNode(node, new IndexNode(params));\n      }\n      else {\n        // dot notation like variable.prop\n        getToken();\n\n        if (token_type !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError('Property name expected after dot');\n        }\n        params.push(new ConstantNode(token));\n        getToken();\n\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * parse a string.\n   * A string is enclosed by double quotes\n   * @return {Node} node\n   * @private\n   */\n  function parseString () {\n    var node, str;\n\n    if (token == '\"') {\n      str = parseStringToken();\n\n      // create constant\n      node = new ConstantNode(str, 'string');\n\n      // parse index parameters\n      node = parseAccessors(node);\n\n      return node;\n    }\n\n    return parseMatrix();\n  }\n\n  /**\n   * Parse a string surrounded by double quotes \"...\"\n   * @return {string}\n   */\n  function parseStringToken () {\n    var str = '';\n\n    while (c != '' && c != '\\\"') {\n      if (c == '\\\\') {\n        // escape character\n        str += c;\n        next();\n      }\n\n      str += c;\n      next();\n    }\n\n    getToken();\n    if (token != '\"') {\n      throw createSyntaxError('End of string \" expected');\n    }\n    getToken();\n\n    return str;\n  }\n\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n  function parseMatrix () {\n    var array, params, rows, cols;\n\n    if (token == '[') {\n      // matrix [...]\n      openParams();\n      getToken();\n\n      if (token != ']') {\n        // this is a non-empty matrix\n        var row = parseRow();\n\n        if (token == ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row];\n\n          // the rows of the matrix are separated by dot-comma's\n          while (token == ';') {\n            getToken();\n\n            params[rows] = parseRow();\n            rows++;\n          }\n\n          if (token != ']') {\n            throw createSyntaxError('End of matrix ] expected');\n          }\n          closeParams();\n          getToken();\n\n          // check if the number of columns matches in all rows\n          cols = params[0].items.length;\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length != cols) {\n              throw createError('Column dimensions mismatch ' +\n                  '(' + params[r].items.length + ' != ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        }\n        else {\n          // 1 dimensional vector\n          if (token != ']') {\n            throw createSyntaxError('End of matrix ] expected');\n          }\n          closeParams();\n          getToken();\n\n          array = row;\n        }\n      }\n      else {\n        // this is an empty matrix \"[ ]\"\n        closeParams();\n        getToken();\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(array);\n    }\n\n    return parseObject();\n  }\n\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n  function parseRow () {\n    var params = [parseAssignment()];\n    var len = 1;\n\n    while (token == ',') {\n      getToken();\n\n      // parse expression\n      params[len] = parseAssignment();\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n  function parseObject () {\n    if (token == '{') {\n      var key;\n\n      var properties = {};\n      do {\n        getToken();\n\n        if (token != '}') {\n          // parse key\n          if (token == '\"') {\n            key = parseStringToken();\n          }\n          else if (token_type == TOKENTYPE.SYMBOL) {\n            key = token;\n            getToken();\n          }\n          else {\n            throw createSyntaxError('Symbol or string expected as object key');\n          }\n\n          // parse key/value separator\n          if (token != ':') {\n            throw createSyntaxError('Colon : expected after object key');\n          }\n          getToken();\n\n          // parse key\n          properties[key] = parseAssignment();\n        }\n      }\n      while (token == ',');\n\n      if (token != '}') {\n        throw createSyntaxError('Comma , or bracket } expected after object value');\n      }\n      getToken();\n\n      var node = new ObjectNode(properties);\n\n      // parse index parameters\n      node = parseAccessors(node);\n\n      return node;\n    }\n\n    return parseNumber();\n  }\n\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n  function parseNumber () {\n    var number;\n\n    if (token_type == TOKENTYPE.NUMBER) {\n      // this is a number\n      number = token;\n      getToken();\n\n      return new ConstantNode(number, 'number');\n    }\n\n    return parseParentheses();\n  }\n\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n  function parseParentheses () {\n    var node;\n\n    // check if it is a parenthesized expression\n    if (token == '(') {\n      // parentheses (...)\n      openParams();\n      getToken();\n\n      node = parseAssignment(); // start again\n\n      if (token != ')') {\n        throw createSyntaxError('Parenthesis ) expected');\n      }\n      closeParams();\n      getToken();\n\n      node = new ParenthesisNode(node);\n      node = parseAccessors(node);\n      return node;\n    }\n\n    return parseEnd();\n  }\n\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n  function parseEnd () {\n    if (token == '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError('Unexpected end of expression');\n    } else if (token === \"'\") {\n      throw createSyntaxError('Value expected. Note: strings must be enclosed by double quotes');\n    } else {\n      throw createSyntaxError('Value expected');\n    }\n  }\n\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null;\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last token starts\n   * @private\n   */\n  function col () {\n    return index - token.length + 1;\n  }\n\n  /**\n   * Create an error\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n  function createSyntaxError (message) {\n    var c = col();\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error['char'] = c;\n\n    return error;\n  }\n\n  /**\n   * Create an error\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n  function createError (message) {\n    var c = col();\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error['char'] = c;\n\n    return error;\n  }\n\n  return parse;\n}\n\nexports.name = 'parse';\nexports.path = 'expression';\nexports.factory = factory;\n", "{\n  \"name\": \"mathjs\",\n  \"version\": \"3.16.5\",\n  \"description\": \"Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices.\",\n  \"author\": \"Jos de Jong <wjosdejong@gmail.com> (https://github.com/josdejong)\",\n  \"contributors\": [\n    \"Adam Kelly (https://github.com/adamisntdead)\",\n    \"Alexander Beyn (https://github.com/AlexanderBeyn)\",\n    \"Andy Pan (https://github.com/andy0130tw)\",\n    \"Bart Kiers (https://github.com/bkiers)\",\n    \"Brett Jurgens (https://github.com/brettjurgens)\",\n    \"Bryan Cuccioli (https://github.com/bcuccioli)\",\n    \"Daniel Levin (https://github.com/daniel-levin)\",\n    \"David Simons (https://github.com/SwamWithTurtles)\",\n    \"Devan Patel (https://github.com/devanp92)\",\n    \"devdevdata222 (https://github.com/devdevdata222)\",\n    \"Dzmitry Litskalau (https://github.com/litmit)\",\n    \"Ekin Koc (https://github.com/eknkc)\",\n    \"Elijah Insua (https://github.com/tmpvar)\",\n    \"Eric Mansfield (https://github.com/ericman314)\",\n    \"Fabrice Colas (https://github.com/fabricecolas)\",\n    \"Favian Contreras (https://github.com/BigFav)\",\n    \"Finn Pauls (https://github.com/finnp)\",\n    \"Ganga Christopher (https://github.com/gangachris)\",\n    \"Harry Sarson (https://github.com/HarrySarson)\",\n    \"Holman Gao (https://github.com/golmansax)\",\n    \"Guillermo Indalecio Fern\u00e1ndez (https://github.com/guillermobox)\",\n    \"Gulfaraz (https://github.com/gulfaraz)\",\n    \"hamadu (https://github.com/hamadu)\",\n    \"Harsh Gupta (https://github.com/hgupta9)\",\n    \"Huseyn Guliyev (https://github.com/husayt)\",\n    \"Ivan Vergiliev (IvanVergiliev)\",\n    \"Jim Garrison (https://github.com/garrison)\",\n    \"Karl Lew (https://github.com/firepick1)\",\n    \"Kenan Yildirim (https://github.com/KenanY)\",\n    \"Keunhong Park (https://github.com/void42)\",\n    \"Kunal Vyas (https://github.com/kv-kunalvyas)\",\n    \"Marcus Andre (https://github.com/marcusandre)\",\n    \"Horatiu Lazu (https://github.com/MathBunny)\",\n    \"Mathias Polligkeit (https://github.com/woylie)\",\n    \"Max Bruckner (https://github.com/FSMaxB)\",\n    \"Maxence Dalmais (https://github.com/maxired)\",\n    \"Michael M. (https://github.com/Schnark)\",\n    \"Mitchel Kelonye (https://github.com/kelonye)\",\n    \"mtraynham (https://github.com/mtraynham)\",\n    \"Niels Heisterkamp (https://github.com/nheisterkamp)\",\n    \"Owen Versteeg (https://github.com/owenversteeg)\",\n    \"Pavel Panchekha (https://github.com/pavpanchekha)\",\n    \"Pat Grasso (https://github.com/patgrasso)\",\n    \"Pete Corey (https://github.com/pcorey)\",\n    \"PJ Hampton (https://github.com/pjhampton )\",\n    \"Retsam (https://github.com/Retsam)\",\n    \"Robert Eisele (https://github.com/infusion)\",\n    \"Rogelio J. Baucells (https://github.com/rjbaucells)\",\n    \"Ryan Seys (https://github.com/ryanseys)\",\n    \"Sebastien Piquemal (https://github.com/sebpiq)\",\n    \"Sebastian Ruhleder (https://github.com/ruhleder)\",\n    \"Sergey Romanov (https://github.com/saromanov)\",\n    \"Slava Ganzin (https://github.com/slavaGanzin)\",\n    \"Stu Blair (https://github.com/stu-blair)\",\n    \"Thomas Brierley (https://github.com/ThomasBrierley)\",\n    \"Timothy Lee (https://github.com/tetslee)\",\n    \"T\u00f3th R\u00f3bert (https://github.com/Nekomajin42)\",\n    \"Todd Morse (https://github.com/morsecodist)\",\n    \"Waldir Pimenta (https://github.com/waldyrious)\",\n    \"Zach Zibrat (https://github.com/palimpsests)\"\n  ],\n  \"homepage\": \"http://mathjs.org\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/josdejong/mathjs.git\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"keywords\": [\n    \"math\",\n    \"mathematics\",\n    \"functions\",\n    \"numeric\",\n    \"algebra\",\n    \"parser\",\n    \"expression\",\n    \"number\",\n    \"bignumber\",\n    \"complex\",\n    \"fraction\",\n    \"matrix\",\n    \"unit\"\n  ],\n  \"dependencies\": {\n    \"complex.js\": \"2.0.4\",\n    \"decimal.js\": \"7.2.3\",\n    \"fraction.js\": \"4.0.2\",\n    \"javascript-natural-sort\": \"0.7.1\",\n    \"seed-random\": \"2.2.0\",\n    \"tiny-emitter\": \"2.0.0\",\n    \"typed-function\": \"0.10.6\"\n  },\n  \"devDependencies\": {\n    \"benchmark\": \"2.1.4\",\n    \"expr-eval\": \"1.0.1\",\n    \"glob\": \"7.1.2\",\n    \"gulp\": \"3.9.1\",\n    \"gulp-util\": \"3.0.8\",\n    \"istanbul\": \"0.4.5\",\n    \"jsep\": \"0.3.0\",\n    \"math-expression-evaluator\": \"1.2.17\",\n    \"mkdirp\": \"0.5.1\",\n    \"mocha\": \"3.4.2\",\n    \"ndarray\": \"1.0.18\",\n    \"ndarray-determinant\": \"1.0.0\",\n    \"ndarray-gemm\": \"1.0.0\",\n    \"ndarray-ops\": \"1.2.2\",\n    \"ndarray-pack\": \"1.2.1\",\n    \"numericjs\": \"1.2.6\",\n    \"pad-right\": \"0.2.2\",\n    \"q\": \"1.5.0\",\n    \"sylvester\": \"0.0.21\",\n    \"tar\": \"2.2.1\",\n    \"uglify-js\": \"2.7.5\",\n    \"underscore\": \"1.8.3\",\n    \"webpack\": \"2.6.1\",\n    \"zeros\": \"1.0.0\"\n  },\n  \"main\": \"./index\",\n  \"scripts\": {\n    \"build\": \"gulp\",\n    \"watch\": \"gulp watch\",\n    \"docs\": \"gulp docs\",\n    \"test\": \"mocha test --recursive\",\n    \"coverage\": \"istanbul cover _mocha -- test --recursive; echo \\\"\\nCoverage report is available at ./coverage/lcov-report/index.html\\\"\"\n  },\n  \"bin\": {\n    \"mathjs\": \"./bin/cli.js\"\n  },\n  \"engines\": {\n    \"node\": \">= 0.1\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/josdejong/mathjs/issues\"\n  },\n  \"directories\": {\n    \"doc\": \"docs\",\n    \"example\": \"examples\",\n    \"lib\": \"lib\",\n    \"test\": \"test\"\n  }\n}\n", "// test parse\nvar assert = require('assert');\nvar approx = require('../../tools/approx');\nvar math = require('../../index');\nvar ArgumentsError = require('../../lib/error/ArgumentsError');\nvar parse = math.expression.parse;\nvar ConditionalNode = math.expression.node.ConditionalNode;\nvar OperatorNode = math.expression.node.OperatorNode;\nvar RangeNode = math.expression.node.RangeNode;\nvar Complex = math.type.Complex;\nvar Matrix = math.type.Matrix;\nvar Range = math.type.Range;\nvar Unit = math.type.Unit;\nvar ResultSet = math.type.ResultSet;\n\n/**\n * Helper function to parse an expression and immediately evaluate its results\n * @param {String} expr\n * @param {Object} [scope]\n * @return {*} result\n */\nfunction parseAndEval(expr, scope) {\n  return parse(expr).eval(scope);\n}\n\ndescribe('parse', function() {\n\n  it('should parse a single expression', function() {\n    approx.equal(parse('2 + 6 / 3').compile().eval(), 4);\n  });\n\n  it('should parse an empty expression', function() {\n    assert.strictEqual(parse('').compile().eval(), undefined);\n    assert.strictEqual(parse('\\n').compile().eval(), undefined);\n    assert.strictEqual(parse('\\n\\n').compile().eval(), undefined);\n    assert.strictEqual(parse('\\n  \\n').compile().eval(), undefined);\n    assert.strictEqual(parse('#foo\\n').compile().eval(), undefined);\n    assert.strictEqual(parse('#foo\\n#bar\\n').compile().eval(), undefined);\n  });\n\n  it('should parse an array with expressions', function() {\n    var scope = {};\n    assert.deepEqual(parse(['a=3', 'b=4', 'a*b']).map(function (node) {\n      return node.compile().eval(scope);\n    }), [3, 4, 12]);\n  });\n\n  it('should parse a matrix with expressions', function() {\n    var scope = {};\n    assert.deepEqual(parse(math.matrix(['a=3', 'b=4', 'a*b'])).map(function (node) {\n      return node.compile().eval(scope);\n    }), math.matrix([3, 4, 12]));\n  });\n\n  it('should parse an array with an empty expression', function() {\n    assert.deepEqual(parse(['']).map(function (node) {\n      return node.compile().eval();\n    }), [undefined]);\n  });\n\n  it('should parse an array with an empty expression', function() {\n    assert.deepEqual(parse(math.matrix([''])).map(function (node) {\n      return node.compile().eval();\n    }), math.matrix([undefined]));\n  });\n\n  it('should parse unicode and other special characters', function() {\n    // http://unicode-table.com/en\n    var scope = {};\n\n    math.eval('$ab$c = 2', scope); // dollar sign\n    assert.strictEqual(scope['$ab$c'], 2);\n\n    math.eval('\\u00E9 = 2', scope); // Latin Small Letter E with Acute\n    assert.strictEqual(scope['\\u00E9'], 2);\n\n    math.eval('\\u03A6 = 3', scope); // Greek Capital Letter Phi\n    assert.strictEqual(scope['\\u03A6'], 3);\n\n    math.eval('\\u03A9 = 4', scope); // Greek Capital Letter Omega\n    assert.strictEqual(scope['\\u03A9'], 4);\n\n    math.eval('\\u2126 = 4', scope); // Letter-like character Ohm\n    assert.strictEqual(scope['\\u2126'], 4);\n\n    math.eval('k\\u00F6ln = 5', scope); // Combination of latin and unicode\n    assert.strictEqual(scope['k\\u00F6ln'], 5);\n\n    // test unicode characters in the astral plane (surrogate pairs\n    math.eval('\\uD835\\uDD38 = 1', scope); // double struck capital A\n    assert.strictEqual(scope['\\uD835\\uDD38'], 1);\n\n    // should not allow the \"holes\"\n    assert.throws(function () {\n      math.eval('\\uD835\\uDCA3 = 1', scope);\n    })\n\n  });\n\n  describe('multiline', function () {\n\n    it('should parse multiline expressions', function() {\n      assert.deepEqual(parse('a=3\\nb=4\\na*b').compile().eval(), new ResultSet([3, 4, 12]));\n      assert.deepEqual(parse('b = 43; b * 4').compile().eval(), new ResultSet([172]));\n    });\n\n    it('should skip empty lines in multiline expressions', function() {\n      assert.deepEqual(parse('\\n;\\n2 * 4\\n').compile().eval(), new ResultSet([8]));\n    });\n\n    it('should spread operators over multiple lines', function() {\n      assert.deepEqual(parse('2+\\n3').compile().eval(), 5);\n      assert.deepEqual(parse('2+\\n\\n3').compile().eval(), 5);\n      assert.deepEqual(parse('2*\\n3').compile().eval(), 6);\n      assert.deepEqual(parse('2^\\n3').compile().eval(), 8);\n      assert.deepEqual(parse('2==\\n3').compile().eval(), false);\n      assert.deepEqual(parse('2*-\\n3').compile().eval(), -6);\n    });\n\n    it('should parse multiple function assignments', function() {\n      var scope = {};\n      parse('f(x)=x*2;g(x)=x*3').compile().eval(scope);\n      assert.equal(scope.f(2), 4);\n      assert.equal(scope.g(2), 6);\n\n      var scope2 = {};\n      parse('a=2;f(x)=x^a;').compile().eval(scope2);\n      assert.equal(scope2.a, 2);\n      assert.equal(scope2.f(3), 9);\n    });\n\n    it ('should correctly scope a function variable if also used outside the function', function () {\n      var scope = {};\n      var res = parse('x=2;f(x)=x^2;x').compile().eval(scope); // x should be x=2, not x of the function\n\n      assert.deepEqual(res, {entries: [2]});\n      assert.equal(scope.x, 2);\n      assert.equal(scope.f(3), 9);\n    });\n\n    it('should spread a function over multiple lines', function() {\n      assert.deepEqual(parse('add(\\n4\\n,\\n2\\n)').compile().eval(), 6);\n    });\n\n    it('should spread contents of parameters over multiple lines', function() {\n      assert.deepEqual(parse('(\\n4\\n+\\n2\\n)').compile().eval(), 6);\n    });\n\n    it('should spread a function assignment over multiple lines', function() {\n      assert.deepEqual(typeof parse('f(\\nx\\n,\\ny\\n)=\\nx+\\ny').compile().eval(), 'function');\n    });\n\n    it('should spread a variable assignment over multiple lines', function() {\n      assert.deepEqual(parse('x=\\n2').compile().eval(), 2);\n    });\n\n    it('should spread a matrix over multiple lines', function() {\n      assert.deepEqual(parse('[\\n1\\n,\\n2\\n]').compile().eval(), math.matrix([1, 2]));\n    });\n\n    it('should spread a range over multiple lines', function() {\n      assert.deepEqual(parse('2:\\n4').compile().eval(), math.matrix([2,3,4]));\n      assert.deepEqual(parse('2:\\n2:\\n6').compile().eval(), math.matrix([2,4,6]));\n    });\n\n    it('should spread an index over multiple lines', function() {\n      assert.deepEqual(parse('a[\\n1\\n,\\n1\\n]').compile().eval({a: [[1,2],[3,4]]}), 1);\n\n      var scope = {a: [[1,2],[3,4]]};\n      assert.deepEqual(parse('a[\\n1\\n,\\n1\\n]=\\n100').compile().eval(scope), 100);\n      assert.deepEqual(scope, {a: [[100,2],[3,4]]})\n    });\n\n  });\n\n  it('should throw an error when scope contains a reserved keyword', function() {\n    var scope = {\n      end: 2\n    };\n    assert.throws(function () {\n      parse('2+3').compile().eval(scope);\n    }, /Scope contains an illegal symbol/);\n  });\n\n  it('should give informative syntax errors', function() {\n    assert.throws(function () {parse('2 +');}, /Unexpected end of expression \\(char 4\\)/);\n    assert.throws(function () {parse('2 + 3 + *');}, /Value expected \\(char 9\\)/);\n  });\n\n  it('should throw an error if called with wrong number of arguments', function() {\n    assert.throws(function () {parse();}, ArgumentsError);\n    assert.throws(function () {parse(1,2,3);}, ArgumentsError);\n    assert.throws(function () {parse([1, 2]);}, TypeError);\n  });\n\n  it('should throw an error if called with a wrong type of argument', function() {\n    assert.throws(function () {parse(23);}, TypeError);\n    assert.throws(function () {parse(math.unit('5cm'));}, TypeError);\n    assert.throws(function () {parse(new Complex(2,3));}, TypeError);\n    assert.throws(function () {parse(true);}, TypeError);\n  });\n\n  it('should throw an error in case of unsupported characters', function() {\n    assert.throws(function () {parse('2\\u00A1');}, /Syntax error in part \"\\u00A1\"/);\n  });\n\n  describe('comments', function () {\n\n    it('should skip comments', function() {\n      assert.equal(parseAndEval('2 + 3 # - 4'), 5);\n    });\n\n    it('should skip comments in a ResultSet', function() {\n      assert.deepEqual(parseAndEval('2 + 3 # - 4\\n6-2'), new ResultSet([5, 4]));\n    });\n\n    it('should fill in the property comment of a Node', function() {\n      assert.equal(parse('2 + 3').comment, '');\n\n      assert.equal(parse('2 + 3 # hello').comment, '# hello');\n      assert.equal(parse('   # hi').comment, '# hi');\n\n      var blockNode = parse('2 # foo\\n3   # bar');\n      assert.equal(blockNode.blocks.length, 2);\n      assert.equal(blockNode.blocks[0].node.comment, '# foo');\n      assert.equal(blockNode.blocks[1].node.comment, '# bar');\n    });\n\n  });\n\n  describe('number', function () {\n\n    it('should parse valid numbers', function() {\n      assert.equal(parseAndEval('0'), 0);\n      assert.equal(parseAndEval('3'), 3);\n      assert.equal(parseAndEval('3.2'), 3.2);\n      assert.equal(parseAndEval('3.'), 3);\n      assert.equal(parseAndEval('3. '), 3);\n      assert.equal(parseAndEval('3.\\t'), 3);\n      assert.equal(parseAndEval('003.2'), 3.2);\n      assert.equal(parseAndEval('003.200'), 3.2);\n      assert.equal(parseAndEval('.2'), 0.2);\n      assert.equal(parseAndEval('3e2'), 300);\n      assert.equal(parseAndEval('300e2'), 30000);\n      assert.equal(parseAndEval('300e+2'), 30000);\n      assert.equal(parseAndEval('300e-2'), 3);\n      assert.equal(parseAndEval('300E-2'), 3);\n      assert.equal(parseAndEval('3.2e2'), 320);\n    });\n\n    it('should parse a number followed by e', function() {\n      approx.equal(parseAndEval('2e'), 2 * Math.E);\n    });\n\n    it('should throw an error with invalid numbers', function() {\n      assert.throws(function () {parseAndEval('.'); }, /Value expected/);\n      assert.throws(function () {parseAndEval('3.2.2'); }, SyntaxError);\n      assert.throws(function () {parseAndEval('3.2e2.2'); }, SyntaxError);\n      \n      assert.throws(function () {parseAndEval('3e0.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('3e.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('-3e0.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('-3e.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('3e-0.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('3e-.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('-3e-0.5'); }, /Digit expected, got \".\"/);\n      assert.throws(function () {parseAndEval('-3e-.5'); }, /Digit expected, got \".\"/);\n\n      assert.throws(function () {parseAndEval('2e+a'); }, /Digit expected, got \"a\"/);\n    });\n\n  });\n\n  describe('bignumber', function () {\n\n    it('should parse bignumbers', function() {\n      assert.deepEqual(parseAndEval('bignumber(0.1)'), math.bignumber(0.1));\n      assert.deepEqual(parseAndEval('bignumber(\"1.2e500\")'), math.bignumber('1.2e500'));\n    });\n\n    it('should output bignumbers if default number type is bignumber', function() {\n      var bigmath = math.create({\n        number: 'BigNumber'\n      });\n\n      assert.deepEqual(bigmath.parse('0.1').compile().eval(), bigmath.bignumber(0.1));\n      assert.deepEqual(bigmath.parse('1.2e5000').compile().eval(), bigmath.bignumber('1.2e5000'));\n    });\n\n  });\n\n  describe('fraction', function () {\n\n    it('should output fractions if default number type is fraction', function() {\n      var fmath = math.create({\n        number: 'Fraction'\n      });\n\n      assert(fmath.parse('0.1').compile().eval() instanceof math.type.Fraction);\n      assert.equal(fmath.parse('1/3').compile().eval().toString(), '0.(3)');\n      assert.equal(fmath.parse('0.1+0.2').compile().eval().toString(), '0.3');\n    });\n\n  });\n\n  describe('string', function () {\n\n    it('should parse a string', function() {\n      assert.deepEqual(parseAndEval('\"hello\"'), \"hello\");\n      assert.deepEqual(parseAndEval('   \"hi\" '), \"hi\");\n    });\n\n    it('should parse a with escaped characters', function() {\n      assert.deepEqual(parseAndEval('\"line end\\\\nnext\"'), 'line end\\nnext');\n      assert.deepEqual(parseAndEval('\"line end\\\\n\"'), 'line end\\n');\n      assert.deepEqual(parseAndEval('\"tab\\\\tnext\"'), 'tab\\tnext');\n      assert.deepEqual(parseAndEval('\"tab\\\\t\"'), 'tab\\t');\n      assert.deepEqual(parseAndEval('\"escaped backslash\\\\\\\\next\"'), 'escaped backslash\\\\next');\n      assert.deepEqual(parseAndEval('\"escaped backslash\\\\\\\\\"'), 'escaped backslash\\\\');\n    });\n\n    it('should throw an error with invalid strings', function() {\n      assert.throws(function () {parseAndEval('\"hi'); }, SyntaxError);\n      assert.throws(function () {parseAndEval(' hi\" '); }, Error);\n    });\n\n    it('should get a string subset', function() {\n      var scope = {};\n      assert.deepEqual(parseAndEval('c=\"hello\"', scope), \"hello\");\n      assert.deepEqual(parseAndEval('c[2:4]', scope), \"ell\");\n      assert.deepEqual(parseAndEval('c[5:-1:1]', scope), \"olleh\");\n      assert.deepEqual(parseAndEval('c[end-2:-1:1]', scope), \"leh\");\n      assert.deepEqual(parseAndEval('\"hello\"[2:4]', scope), \"ell\");\n    });\n\n    it('should set a string subset', function() {\n      var scope = {};\n      assert.deepEqual(parseAndEval('c=\"hello\"', scope), \"hello\");\n      assert.deepEqual(parseAndEval('c[1] = \"H\"', scope), \"H\");\n      assert.deepEqual(scope.c, \"Hello\");\n      assert.deepEqual(parseAndEval('c', scope), \"Hello\");\n      assert.deepEqual(parseAndEval('c[6:11] = \" world\"', scope), \" world\");\n      assert.deepEqual(scope.c, \"Hello world\");\n      assert.deepEqual(parseAndEval('c[end] = \"D\"', scope), \"D\");\n      assert.deepEqual(scope.c, \"Hello worlD\");\n    });\n\n    it('should set a string subset on an object', function() {\n      var scope = { a: {} };\n      assert.deepEqual(parseAndEval('a.c=\"hello\"', scope), \"hello\");\n      assert.deepEqual(parseAndEval('a.c[1] = \"H\"', scope), \"H\");\n      assert.deepEqual(scope.a, {c: \"Hello\"});\n      assert.deepEqual(parseAndEval('a.c', scope), \"Hello\");\n      assert.deepEqual(parseAndEval('a.c[6:11] = \" world\"', scope), \" world\");\n      assert.deepEqual(scope.a, {c: \"Hello world\"});\n      assert.deepEqual(parseAndEval('a.c', scope), \"Hello world\");\n      assert.deepEqual(scope.a, {c: \"Hello world\"});\n      assert.deepEqual(parseAndEval('a.c[end] = \"D\"', scope), \"D\");\n      assert.deepEqual(scope.a, {c: \"Hello worlD\"});\n    });\n\n  });\n\n  describe('unit', function () {\n\n    it('should parse units', function() {\n      assert.deepEqual(parseAndEval('5cm'), new Unit(5, 'cm'));\n      assert.ok(parseAndEval('5cm') instanceof Unit);\n    });\n\n    it('should parse constants', function() {\n      assert.equal(parseAndEval('pi'), Math.PI);\n    });\n\n    it('should parse physical constants', function() {\n      var expected = new Unit(299792458, 'm/s');\n      expected.fixPrefix = true;\n      assert.deepEqual(parseAndEval('speedOfLight'), expected);\n    });\n\n    it('should correctly parse negative temperatures', function () {\n      approx.deepEqual(parseAndEval('-6 celsius'), new Unit(-6, 'celsius'));\n      approx.deepEqual(parseAndEval('--6 celsius'), new Unit(6, 'celsius'));\n      approx.deepEqual(parseAndEval('-6 celsius to fahrenheit'),\n          new Unit(21.2, 'fahrenheit').to('fahrenheit'));\n    });\n\n    it('should convert units', function() {\n      var scope = {};\n      approx.deepEqual(parseAndEval('(5.08 cm * 1000) to inch', scope),\n          math.unit(2000, 'inch').to('inch'));\n      approx.deepEqual(parseAndEval('a = (5.08 cm * 1000) to mm', scope),\n          math.unit(50800, 'mm').to('mm'));\n      approx.deepEqual(parseAndEval('a to inch', scope),\n          math.unit(2000, 'inch').to('inch'));\n\n      approx.deepEqual(parseAndEval('10 celsius to fahrenheit'),\n          math.unit(50, 'fahrenheit').to('fahrenheit'));\n      approx.deepEqual(parseAndEval('20 celsius to fahrenheit'),\n          math.unit(68, 'fahrenheit').to('fahrenheit'));\n      approx.deepEqual(parseAndEval('50 fahrenheit to celsius'),\n          math.unit(10, 'celsius').to('celsius'));\n    });\n\n    it('should create units and aliases', function() {\n      var myMath = math.create()\n      myMath.eval('createUnit(\"knot\", {definition: \"0.514444444 m/s\", aliases: [\"knots\", \"kt\", \"kts\"]})');\n      assert.equal(myMath.eval('5 knot').toString(), '5 knot');\n      assert.equal(myMath.eval('5 knots').toString(), '5 knots');\n      assert.equal(myMath.eval('5 kt').toString(), '5 kt');\n    });\n\n    it('should evaluate operator \"to\" with correct precedence ', function () {\n      approx.deepEqual(parseAndEval('5.08 cm * 1000 to inch'),\n          new Unit(2000, 'inch').to('inch'));\n    });\n\n    it('should evaluate operator \"in\" (alias of \"to\") ', function () {\n      approx.deepEqual(parseAndEval('5.08 cm in inch'),\n          new Unit(2, 'inch').to('inch'));\n    });\n\n    it('should evaluate unit \"in\" (should not conflict with operator \"in\")', function () {\n      approx.deepEqual(parseAndEval('2 in'),          new Unit(2, 'in'));\n      approx.deepEqual(parseAndEval('5.08 cm in in'), new Unit(2, 'in').to('in'));\n      approx.deepEqual(parseAndEval('5 in in in'),    new Unit(5, 'in').to('in'));\n      approx.deepEqual(parseAndEval('2 in to meter'), new Unit(2, 'inch').to('meter'));\n      approx.deepEqual(parseAndEval('2 in in meter'), new Unit(2, 'inch').to('meter'));\n      approx.deepEqual(parseAndEval('a in inch', {a: new Unit(5.08, 'cm')}), new Unit(2, 'inch').to('inch'));\n      approx.deepEqual(parseAndEval('(2+3) in'), new Unit(5, 'in'));\n      approx.deepEqual(parseAndEval('a in', {a: 5}), new Unit(5, 'in'));\n      approx.deepEqual(parseAndEval('0.5in + 1.5in to cm'), new Unit(5.08, 'cm').to('cm'));\n    });\n  });\n\n  describe('complex', function () {\n\n    it('should parse complex values', function () {\n      assert.deepEqual(parseAndEval('i'), new Complex(0,1));\n      assert.deepEqual(parseAndEval('2+3i'), new Complex(2,3));\n      assert.deepEqual(parseAndEval('2+3*i'), new Complex(2,3));\n      assert.deepEqual(parseAndEval('1/2i'), new Complex(0, 0.5));\n    });\n\n  });\n\n  describe('matrix', function () {\n\n    it('should parse a matrix', function() {\n      assert.ok(parseAndEval('[1,2;3,4]') instanceof Matrix);\n\n      var m = parseAndEval('[1,2,3;4,5,6]');\n      assert.deepEqual(m.size(), [2,3]);\n      assert.deepEqual(m, math.matrix([[1,2,3],[4,5,6]]));\n\n      var b = parseAndEval('[5, 6; 1, 1]');\n      assert.deepEqual(b.size(), [2,2]);\n      assert.deepEqual(b, math.matrix([[5,6],[1,1]]));\n\n      // from 1 to n dimensions\n      assert.deepEqual(parseAndEval('[ ]'), math.matrix([]));\n      assert.deepEqual(parseAndEval('[1,2,3]'), math.matrix([1,2,3]));\n      assert.deepEqual(parseAndEval('[1;2;3]'), math.matrix([[1],[2],[3]]));\n      assert.deepEqual(parseAndEval('[[1,2],[3,4]]'), math.matrix([[1,2],[3,4]]));\n      assert.deepEqual(parseAndEval('[[[1],[2]],[[3],[4]]]'), math.matrix([[[1],[2]],[[3],[4]]]));\n    });\n\n    it('should parse an empty matrix', function() {\n      assert.deepEqual(parseAndEval('[]'), math.matrix([]));\n    });\n\n    it('should get a matrix subset', function() {\n      var scope = {\n        a: math.matrix([\n          [1,2,3],\n          [4,5,6],\n          [7,8,9]\n        ])\n      };\n      assert.deepEqual(parseAndEval('a[2, :]', scope),        math.matrix([[4,5,6]]));\n      assert.deepEqual(parseAndEval('a[2, :2]', scope),       math.matrix([[4,5]]));\n      assert.deepEqual(parseAndEval('a[2, :end-1]', scope),   math.matrix([[4,5]]));\n      assert.deepEqual(parseAndEval('a[2, 2:]', scope),       math.matrix([[5,6]]));\n      assert.deepEqual(parseAndEval('a[2, 2:3]', scope),      math.matrix([[5,6]]));\n      assert.deepEqual(parseAndEval('a[2, 1:2:3]', scope),    math.matrix([[4,6]]));\n      assert.deepEqual(parseAndEval('a[:, 2]', scope),        math.matrix([[2],[5],[8]]));\n      assert.deepEqual(parseAndEval('a[:2, 2]', scope),       math.matrix([[2],[5]]));\n      assert.deepEqual(parseAndEval('a[:end-1, 2]', scope),   math.matrix([[2],[5]]));\n      assert.deepEqual(parseAndEval('a[2:, 2]', scope),       math.matrix([[5],[8]]));\n      assert.deepEqual(parseAndEval('a[2:3, 2]', scope),      math.matrix([[5],[8]]));\n      assert.deepEqual(parseAndEval('a[1:2:3, 2]', scope),    math.matrix([[2],[8]]));\n    });\n\n    it('should get a matrix subset of a matrix subset', function() {\n      var scope = {\n        a: math.matrix([\n          [1,2,3],\n          [4,5,6],\n          [7,8,9]\n        ])\n      };\n      assert.deepEqual(parseAndEval('a[2, :][1,1]', scope), 4);\n    });\n\n    it('should get BigNumber value from an array', function() {\n      var res = parseAndEval('arr[1]', {arr: [math.bignumber(2)]});\n      assert.deepEqual(res, math.bignumber(2));\n    });\n\n    it('should parse matrix resizings', function() {\n      var scope = {};\n      assert.deepEqual(parseAndEval('a = []', scope),    math.matrix([]));\n      assert.deepEqual(parseAndEval('a[1:3,1] = [1;2;3]', scope), math.matrix([[1],[2],[3]]));\n      assert.deepEqual(parseAndEval('a[:,2] = [4;5;6]', scope), math.matrix([[4],[5],[6]]));\n      assert.deepEqual(scope.a, math.matrix([[1,4],[2,5],[3,6]]));\n\n      assert.deepEqual(parseAndEval('a = []', scope),    math.matrix([]));\n      assert.strictEqual(parseAndEval('a[1,3] = 3', scope), 3);\n      assert.deepEqual(scope.a, math.matrix([[0,0,3]]));\n      assert.deepEqual(parseAndEval('a[2,:] = [[4,5,6]]', scope), math.matrix([[4,5,6]]));\n      assert.deepEqual(scope.a, math.matrix([[0,0,3],[4,5,6]]));\n\n      assert.deepEqual(parseAndEval('a = []', scope),    math.matrix([]));\n      assert.strictEqual(parseAndEval('a[3,1] = 3', scope), 3);\n      assert.deepEqual(scope.a, math.matrix([[0],[0],[3]]));\n      assert.deepEqual(parseAndEval('a[:,2] = [4;5;6]', scope), math.matrix([[4],[5],[6]]));\n      assert.deepEqual(scope.a, math.matrix([[0,4],[0,5],[3,6]]));\n\n      assert.deepEqual(parseAndEval('a = []', scope),    math.matrix([]));\n      assert.deepEqual(parseAndEval('a[1,1:3] = [[1,2,3]]', scope), math.matrix([[1,2,3]]));\n      assert.deepEqual(scope.a, math.matrix([[1,2,3]]));\n      assert.deepEqual(parseAndEval('a[2,:] = [[4,5,6]]', scope), math.matrix([[4,5,6]]));\n      assert.deepEqual(scope.a, math.matrix([[1,2,3],[4,5,6]]));\n    });\n\n    it('should get/set the matrix correctly', function() {\n      var scope = {};\n      parseAndEval('a=[1,2;3,4]', scope);\n      parseAndEval('a[1,1] = 100', scope);\n      assert.deepEqual(scope.a.size(), [2,2]);\n      assert.deepEqual(scope.a, math.matrix([[100,2],[3,4]]));\n      parseAndEval('a[2:3,2:3] = [10,11;12,13]', scope);\n      assert.deepEqual(scope.a.size(), [3,3]);\n      assert.deepEqual(scope.a, math.matrix([[100, 2, 0],[3,10,11],[0,12,13]]));\n      var a = scope.a;\n      // note: after getting subset, uninitialized elements are replaced by elements with an undefined value\n      assert.deepEqual(a.subset(math.index(new Range(0,3), new Range(0,2))), math.matrix([[100,2],[3,10],[0,12]]));\n      assert.deepEqual(parseAndEval('a[1:3,1:2]', scope), math.matrix([[100,2],[3,10],[0,12]]));\n\n      scope.b = [[1,2],[3,4]];\n      assert.deepEqual(parseAndEval('b[1,:]', scope), [[1, 2]]);\n    });\n\n    it('should get/set the matrix correctly for 3d matrices', function() {\n      var scope = {};\n      assert.deepEqual(parseAndEval('f=[1,2;3,4]', scope), math.matrix([[1,2],[3,4]]));\n      assert.deepEqual(parseAndEval('size(f)', scope), math.matrix([2,2]));\n\n      parseAndEval('f[:,:,2]=[5,6;7,8]', scope);\n      assert.deepEqual(scope.f, math.matrix([\n        [\n          [1,5],\n          [2,6]\n        ],\n        [\n          [3,7],\n          [4,8]\n        ]\n      ]));\n\n      assert.deepEqual(parseAndEval('size(f)', scope), math.matrix([2,2,2]));\n      assert.deepEqual(parseAndEval('f[:,:,1]', scope), math.matrix([[[1],[2]],[[3],[4]]]));\n      assert.deepEqual(parseAndEval('f[:,:,2]', scope), math.matrix([[[5],[6]],[[7],[8]]]));\n      assert.deepEqual(parseAndEval('f[:,2,:]', scope), math.matrix([[[2,6]],[[4,8]]]));\n      assert.deepEqual(parseAndEval('f[2,:,:]', scope), math.matrix([[[3,7],[4,8]]]));\n\n      parseAndEval('a=diag([1,2,3,4])', scope);\n      assert.deepEqual(parseAndEval('a[3:end, 3:end]', scope), math.matrix([[3,0],[0,4]]));\n      parseAndEval('a[3:end, 2:end]=9*ones(2,3)', scope);\n      assert.deepEqual(scope.a, math.matrix([\n        [1,0,0,0],\n        [0,2,0,0],\n        [0,9,9,9],\n        [0,9,9,9]\n      ]));\n      assert.deepEqual(parseAndEval('a[2:end-1, 2:end-1]', scope), math.matrix([[2,0],[9,9]]));\n    });\n\n    it('should merge nested matrices', function() {\n      var scope = {};\n      parseAndEval('a=[1,2;3,4]', scope);\n\n    });\n\n    it('should parse matrix concatenations', function() {\n      var scope = {};\n      parseAndEval('a=[1,2;3,4]', scope);\n      parseAndEval('b=[5,6;7,8]', scope);\n      assert.deepEqual(parseAndEval('c=concat(a,b)', scope), math.matrix([[1,2,5,6],[3,4,7,8]]));\n      assert.deepEqual(parseAndEval('c=concat(a,b,1)', scope), math.matrix([[1,2],[3,4],[5,6],[7,8]]));\n      assert.deepEqual(parseAndEval('c=concat(concat(a,b), concat(b,a), 1)', scope), math.matrix([[1,2,5,6],[3,4,7,8],[5,6,1,2],[7,8,3,4]]));\n      assert.deepEqual(parseAndEval('c=concat([[1,2]], [[3,4]], 1)', scope), math.matrix([[1,2],[3,4]]));\n      assert.deepEqual(parseAndEval('c=concat([[1,2]], [[3,4]], 2)', scope), math.matrix([[1,2,3,4]]));\n      assert.deepEqual(parseAndEval('c=concat([[1]], [2;3], 1)', scope), math.matrix([[1],[2],[3]]));\n      assert.deepEqual(parseAndEval('d=1:3', scope), math.matrix([1,2,3]));\n      assert.deepEqual(parseAndEval('concat(d,d)', scope), math.matrix([1,2,3,1,2,3]));\n      assert.deepEqual(parseAndEval('e=1+d', scope), math.matrix([2,3,4]));\n      assert.deepEqual(parseAndEval('size(e)', scope), math.matrix([3]));\n      assert.deepEqual(parseAndEval('concat(e,e)', scope), math.matrix([2,3,4,2,3,4]));\n      assert.deepEqual(parseAndEval('[[],[]]', scope), math.matrix([[],[]]));\n      assert.deepEqual(parseAndEval('[[],[]]', scope).size(), [2, 0]);\n      assert.deepEqual(parseAndEval('size([[],[]])', scope), math.matrix([2, 0]));\n    });\n\n    it('should disable arrays as range in a matrix index', function () {\n      var scope = {\n        a: [[1,2,3],[4,5,6]]\n      };\n\n      assert.throws(function () {\n        parseAndEval('a[2, 2+3i]', scope);\n      }, /TypeError: Dimension must be an Array, Matrix, number, string, or Range/);\n    });\n\n    it('should throw an error for invalid matrix', function() {\n      assert.throws(function () {parseAndEval('[1, 2');}, /End of matrix ] expected/);\n      assert.throws(function () {parseAndEval('[1; 2');}, /End of matrix ] expected/);\n    });\n\n    it('should throw an error when matrix rows mismatch', function() {\n      assert.throws(function () {parseAndEval('[1, 2; 1, 2, 3]');}, /Column dimensions mismatch/);\n    });\n\n    it('should throw an error for invalid matrix subsets', function() {\n      var scope = {a: [1,2,3]};\n      assert.throws(function () {parseAndEval('a[1', scope);}, /Parenthesis ] expected/);\n    });\n\n    it('should throw an error for invalid matrix concatenations', function() {\n      var scope = {};\n      assert.throws(function () {parseAndEval('c=concat(a, [1,2,3])', scope);});\n    });\n  });\n\n  describe('objects', function () {\n\n    it('should get an object property', function () {\n      assert.deepEqual(parseAndEval('obj[\"foo\"]', {obj: {foo: 2}}), 2);\n    });\n\n    it('should get a nested object property', function () {\n      assert.deepEqual(parseAndEval('obj[\"foo\"][\"bar\"]', {obj: {foo: {bar: 2}}}), 2);\n    });\n\n    it('should get a nested matrix subset from an object property', function () {\n      assert.deepEqual(parseAndEval('obj.foo[2]', {obj: {foo: [1,2,3]}}), 2);\n      assert.deepEqual(parseAndEval('obj.foo[end]', {obj: {foo: [1,2,3]}}), 3);\n      assert.deepEqual(parseAndEval('obj.foo[2][3]', {obj: {foo: ['hello', 'world']}}), 'r');\n      assert.deepEqual(parseAndEval('obj.foo[2][end]', {obj: {foo: ['hello', 'world']}}), 'd');\n      assert.deepEqual(parseAndEval('obj.foo[1].bar', {obj: {foo: [{bar:4}]}}), 4);\n    });\n\n    it('should set an object property', function () {\n      var scope = {obj: {a:3}};\n      var res = parseAndEval('obj[\"b\"] = 2', scope);\n      assert.strictEqual(res, 2);\n      assert.deepEqual(scope, {obj: {a: 3, b: 2}});\n    });\n\n    it('should set a nested object property', function () {\n      var scope = {obj: {foo: {}}};\n      var res = parseAndEval('obj[\"foo\"][\"bar\"] = 2', scope);\n      assert.strictEqual(res, 2);\n      assert.deepEqual(scope, {obj: {foo: {bar: 2}}});\n    });\n\n    it('should throw an error when trying to apply a matrix index as object property', function () {\n      var scope = {a: {}};\n      assert.throws(function () {\n        parseAndEval('a[2] = 6', scope);\n      }, /Cannot apply a numeric index as object property/);\n    });\n\n    it('should set a nested matrix subset from an object property (1)', function () {\n      var scope = {obj: {foo: [1,2,3]}};\n      assert.deepEqual(parseAndEval('obj.foo[2] = 6', scope), 6);\n      assert.deepEqual(scope, {obj: {foo: [1,6,3]}});\n\n      assert.deepEqual(parseAndEval('obj.foo[end] = 8', scope), 8);\n      assert.deepEqual(scope, {obj: {foo: [1,6,8]}});\n    });\n\n    it('should set a nested matrix subset from an object property (2)', function () {\n      var scope = {obj: {foo: [{bar:4}]}};\n      assert.deepEqual(parseAndEval('obj.foo[1].bar = 6', scope), 6);\n      assert.deepEqual(scope, {obj: {foo: [{bar: 6}]}});\n    });\n\n    it('should set a nested matrix subset from an object property (3)', function () {\n      var scope = {obj: {foo: [{bar:{}}]}};\n      assert.deepEqual(parseAndEval('obj.foo[1].bar.baz = 6', scope), 6);\n      assert.deepEqual(scope, {obj: {foo: [{bar: {baz:6}}]}});\n    });\n\n    it('should set a nested matrix subset from an object property (4)', function () {\n      var scope = {obj: {foo: ['hello', 'world']}};\n      assert.deepEqual(parseAndEval('obj.foo[1][end] = \"a\"', scope), 'a');\n      assert.deepEqual(scope, {obj: {foo: ['hella', 'world']}});\n      assert.deepEqual(parseAndEval('obj.foo[end][end] = \"!\"', scope), '!');\n      assert.deepEqual(scope, {obj: {foo: ['hella', 'worl!']}});\n    });\n\n    // TODO: test whether 1-based IndexErrors are thrown\n\n    it('should get an object property with dot notation', function () {\n      assert.deepEqual(parseAndEval('obj.foo', {obj: {foo: 2}}), 2);\n    });\n\n    it('should get an object property from an object inside parentheses', function () {\n      assert.deepEqual(parseAndEval('(obj).foo', {obj: {foo: 2}}), 2);\n    });\n\n    it('should get a nested object property with dot notation', function () {\n      assert.deepEqual(parseAndEval('obj.foo.bar', {obj: {foo: {bar: 2}}}), 2);\n    });\n\n    it('should invoke a function in an object', function () {\n      var scope = {\n        obj: {\n          fn: function (x) {\n            return x * x;\n          }\n        }\n      };\n      assert.deepEqual(parseAndEval('obj.fn(2)', scope), 4);\n      assert.deepEqual(parseAndEval('obj[\"fn\"](2)', scope), 4);\n    });\n\n    it('should invoke a function returned by a function', function () {\n      var scope = {\n        theAnswer: function () {\n          return function () {\n            return 42;\n          };\n        },\n        partialAdd: function (a) {\n          return function (b) {\n            return a + b;\n          };\n        }\n      };\n      assert.deepEqual(parseAndEval('theAnswer()()', scope), 42);\n      assert.deepEqual(parseAndEval('partialAdd(2)(3)', scope), 5);\n    });\n\n    it('should invoke a function on an object with the right context', function () {\n      approx.equal(parseAndEval('(2.54 cm).toNumeric(\"inch\")'), 1);\n      assert.deepEqual(parseAndEval('bignumber(2).plus(3)'), math.bignumber(5));\n      assert.deepEqual(parseAndEval('bignumber(2)[\"plus\"](3)'), math.bignumber(5));\n    });\n\n    it('should invoke native methods on a number', function () {\n      assert.strictEqual(parseAndEval('(3).toString()'), '3');\n      assert.strictEqual(parseAndEval('(3.2).toFixed()'), '3');\n    });\n\n    it('should get nested object property with mixed dot- and index-notation', function () {\n      assert.deepEqual(parseAndEval('obj.foo[\"bar\"].baz', {obj: {foo: {bar: {baz: 2}}}}), 2);\n      assert.deepEqual(parseAndEval('obj[\"foo\"].bar[\"baz\"]', {obj: {foo: {bar: {baz: 2}}}}), 2);\n    });\n\n    it('should set an object property with dot notation', function () {\n      var scope = {obj: {}};\n      parseAndEval('obj.foo = 2', scope);\n      assert.deepEqual(scope, {obj: {foo: 2}});\n    });\n\n    it('should set a nested object property with dot notation', function () {\n      var scope = {obj: {foo: {}}};\n      parseAndEval('obj.foo.bar = 2', scope);\n      assert.deepEqual(scope, {obj: {foo: {bar: 2}}});\n    });\n\n    it('should throw an error in case of invalid property with dot notation', function () {\n      assert.throws(function () {parseAndEval('obj. +foo')}, /SyntaxError: Property name expected after dot \\(char 6\\)/);\n      assert.throws(function () {parseAndEval('obj.[\"foo\"]')}, /SyntaxError: Property name expected after dot \\(char 5\\)/);\n    });\n\n    it('should create an empty object', function () {\n      assert.deepEqual(parseAndEval('{}'), {});\n    });\n\n    it('should create an object with quoted keys', function () {\n      assert.deepEqual(parseAndEval('{\"a\":2+3,\"b\":\"foo\"}'), {a: 5, b: 'foo'});\n    });\n\n    it('should create an object with unquoted keys', function () {\n      assert.deepEqual(parseAndEval('{a:2+3,b:\"foo\"}'), {a: 5, b: 'foo'});\n    });\n\n    it('should create an object with child object', function () {\n      assert.deepEqual(parseAndEval('{a:{b:2}}'), {a:{b:2}})\n    });\n\n    it('should get a property from a just created object', function () {\n      assert.deepEqual(parseAndEval('{foo:2}[\"foo\"]'), 2);\n    });\n\n    it('should parse an object containing a function assignment', function () {\n      var obj = parseAndEval('{f: f(x)=x^2}');\n      assert.deepEqual(Object.keys(obj), ['f']);\n      assert.equal(obj.f(2), 4);\n    });\n\n    it('should not parse a function assignment in an accessor node', function () {\n      assert.throws(function () {\n        var scope = {}\n        var obj = parseAndEval('a[\"b\"](x)=x^2', scope);\n      }, /SyntaxError: Invalid left hand side of assignment operator =/)\n    });\n\n    it('should parse an object containing a variable assignment', function () {\n      var scope = {};\n      assert.deepEqual(parseAndEval('{f: a=42}', scope), {f: 42});\n      assert.strictEqual(scope.a, 42);\n    });\n\n    it('should throw an exception in case of invalid object key', function () {\n      assert.throws(function () {parseAndEval('{a b: 2}')}, /SyntaxError: Colon : expected after object key \\(char 4\\)/);\n      assert.throws(function () {parseAndEval('{a: }')}, /SyntaxError: Value expected \\(char 5\\)/);\n    });\n\n  });\n\n  describe('boolean', function () {\n\n    it('should parse boolean values', function () {\n      assert.equal(parseAndEval('true'), true);\n      assert.equal(parseAndEval('false'), false);\n    });\n\n  });\n\n\n  describe('constants', function () {\n\n    it('should parse constants', function() {\n      assert.deepEqual(parseAndEval('i'), new Complex(0, 1));\n      approx.equal(parseAndEval('pi'), Math.PI);\n      approx.equal(parseAndEval('e'), Math.E);\n    });\n\n  });\n\n  describe('variables', function () {\n\n    it('should parse valid variable assignments', function() {\n      var scope = {};\n      assert.equal(parseAndEval('a = 0.75', scope), 0.75);\n      assert.equal(parseAndEval('a + 2', scope), 2.75);\n      assert.equal(parseAndEval('a = 2', scope), 2);\n      assert.equal(parseAndEval('a + 2', scope), 4);\n      approx.equal(parseAndEval('pi * 2', scope), 6.283185307179586);\n    });\n\n    it('should throw an error on undefined symbol', function() {\n      assert.throws(function() {parseAndEval('qqq + 2'); });\n    });\n\n    it('should throw an error on invalid assignments', function() {\n      //assert.throws(function () {parseAndEval('sin(2) = 0.75')}, SyntaxError); // TODO: should this throw an exception?\n      assert.throws(function () {parseAndEval('sin + 2 = 3');}, SyntaxError);\n    });\n\n    it('should parse nested assignments', function() {\n      var scope = {};\n      assert.equal(parseAndEval('c = d = (e = 4.5)', scope), 4.5);\n      assert.equal(scope.c, 4.5);\n      assert.equal(scope.d, 4.5);\n      assert.equal(scope.e, 4.5);\n      assert.deepEqual(parseAndEval('a = [1,2,f=3]', scope), math.matrix([1,2,3]));\n      assert.equal(scope.f, 3);\n      assert.equal(parseAndEval('2 + (g = 3 + 4)', scope), 9);\n      assert.equal(scope.g, 7);\n    });\n\n    it('should parse variable assignment inside a function call', function() {\n      var scope = {};\n      assert.deepEqual(parseAndEval('sqrt(x=4)', scope), 2);\n      assert.deepEqual(scope, { x:4 });\n    });\n\n    it('should parse variable assignment inside an accessor', function () {\n      var scope = {A: [10,20,30]};\n      assert.deepEqual(parseAndEval('A[x=2]', scope), 20);\n      assert.deepEqual(scope, { A:[10,20,30], x:2 });\n    });\n\n  });\n\n\n  describe('functions', function () {\n\n    it('should parse functions', function() {\n      assert.equal(parseAndEval('sqrt(4)'), 2);\n      assert.equal(parseAndEval('sqrt(6+3)'), 3);\n      assert.equal(parseAndEval('atan2(2,2)'), 0.7853981633974483);\n      assert.deepEqual(parseAndEval('sqrt(-4)'), new Complex(0, 2));\n      assert.equal(parseAndEval('abs(-4.2)'), 4.2);\n      assert.equal(parseAndEval('add(2, 3)'), 5);\n      approx.deepEqual(parseAndEval('1+exp(pi*i)'), new Complex(0, 0));\n      assert.equal(parseAndEval('unequal(2, 3)'), true);\n    });\n\n    it('should get a subset of a matrix returned by a function', function() {\n      var scope = {\n        test: function () {\n          return [1,2,3,4];\n        }\n      };\n      assert.equal(parseAndEval('test()[2]', scope), 2);\n    });\n\n    it('should parse functions without parameters', function() {\n      assert.equal(parseAndEval('r()', {r: function() {return 2;}}), 2);\n    });\n\n    it('should parse function assignments', function() {\n      var scope = {};\n      parseAndEval('x=100', scope); // for testing scoping of the function variables\n      assert.equal(parseAndEval('f(x) = x^2', scope).syntax, 'f(x)');\n      assert.equal(parseAndEval('f(3)', scope), 9);\n      assert.equal(scope.f(3), 9);\n      assert.equal(scope.x, 100);\n      assert.equal(parseAndEval('g(x, y) = x^y', scope).syntax, 'g(x, y)');\n      assert.equal(parseAndEval('g(4,5)', scope), 1024);\n      assert.equal(scope.g(4,5), 1024);\n    });\n\n    it ('should correctly evaluate variables in assigned functions', function () {\n      var scope = {};\n      assert.equal(parseAndEval('a = 3', scope), 3);\n      assert.equal(parseAndEval('f(x) = a * x', scope).syntax, 'f(x)');\n      assert.equal(parseAndEval('f(2)', scope), 6);\n      assert.equal(parseAndEval('a = 5', scope), 5);\n      assert.equal(parseAndEval('f(2)', scope), 10);\n      assert.equal(parseAndEval('g(x) = x^q', scope).syntax, 'g(x)');\n      assert.equal(parseAndEval('q = 4/2', scope), 2);\n      assert.equal(parseAndEval('g(3)', scope), 9);\n    });\n\n    it('should throw an error for undefined variables in an assigned function', function() {\n      var scope = {};\n      assert.equal(parseAndEval('g(x) = x^q', scope).syntax, 'g(x)');\n      assert.throws(function () {\n        parseAndEval('g(3)', scope);\n      }, function (err) {\n        return (err instanceof Error) && (err.toString() == 'Error: Undefined symbol q');\n      });\n    });\n\n    it('should throw an error on invalid left hand side of a function assignment', function() {\n      assert.throws(function () {\n        var scope = {};\n        parseAndEval('g(x, 2) = x^2', scope);\n      }, SyntaxError);\n\n      assert.throws(function () {\n        var scope = {};\n        parseAndEval('2(x, 2) = x^2', scope);\n      }, SyntaxError);\n    });\n  });\n\n  describe ('parentheses', function () {\n    it('should parse parentheses overriding the default precedence', function () {\n      approx.equal(parseAndEval('2 - (2 - 2)'), 2);\n      approx.equal(parseAndEval('2 - ((2 - 2) - 2)'), 4);\n      approx.equal(parseAndEval('3 * (2 + 3)'), 15);\n      approx.equal(parseAndEval('(2 + 3) * 3'), 15);\n    });\n\n    it('should throw an error in case of unclosed parentheses', function () {\n      assert.throws(function () {parseAndEval('3 * (1 + 2');}, /Parenthesis \\) expected/);\n    });\n  });\n\n  describe ('operators', function () {\n\n    it('should parse operations', function() {\n      approx.equal(parseAndEval('(2+3)/4'), 1.25);\n      approx.equal(parseAndEval('2+3/4'), 2.75);\n      assert.equal(parse('0 + 2').toString(), '0 + 2');\n    });\n\n    it('should parse add +', function() {\n      assert.equal(parseAndEval('2 + 3'), 5);\n      assert.equal(parseAndEval('2 + 3 + 4'), 9);\n      assert.equal(parseAndEval('2.+3'), 5); // test whether the decimal mark isn't confused\n    });\n\n    it('should parse divide /', function() {\n      assert.equal(parseAndEval('4 / 2'), 2);\n      assert.equal(parseAndEval('8 / 2 / 2'), 2);\n    });\n\n    it('should parse dotDivide ./', function() {\n      assert.equal(parseAndEval('4./2'), 2);\n      assert.deepEqual(parseAndEval('4./[2,4]'), math.matrix([2,1]));\n      assert.equal(parseAndEval('4 ./ 2'), 2);\n      assert.equal(parseAndEval('8 ./ 2 / 2'), 2);\n\n      assert.deepEqual(parseAndEval('[1,2,3] ./ [1,2,3]'), math.matrix([1,1,1]));\n    });\n\n    it('should parse dotMultiply .*', function() {\n      approx.deepEqual(parseAndEval('2.*3'), 6);\n      approx.deepEqual(parseAndEval('2e3.*3'), 6e3);\n      approx.deepEqual(parseAndEval('2 .* 3'), 6);\n      approx.deepEqual(parseAndEval('4 .* 2'), 8);\n      approx.deepEqual(parseAndEval('8 .* 2 .* 2'), 32);\n      assert.deepEqual(parseAndEval('a=3; a.*4'), new ResultSet([12]));\n\n      assert.deepEqual(parseAndEval('[1,2,3] .* [1,2,3]'), math.matrix([1,4,9]));\n    });\n\n    it('should parse dotPower .^', function() {\n      approx.deepEqual(parseAndEval('2.^3'), 8);\n      approx.deepEqual(parseAndEval('2 .^ 3'), 8);\n      approx.deepEqual(parseAndEval('-2.^2'), -4);  // -(2^2)\n      approx.deepEqual(parseAndEval('2.^3.^4'), 2.41785163922926e+24); // 2^(3^4)\n\n      assert.deepEqual(parseAndEval('[2,3] .^ [2,3]'), math.matrix([4,27]));\n    });\n\n    it('should parse equal ==', function() {\n      assert.strictEqual(parseAndEval('2 == 3'), false);\n      assert.strictEqual(parseAndEval('2 == 2'), true);\n      assert.deepEqual(parseAndEval('[2,3] == [2,4]'), math.matrix([true, false]));\n    });\n\n    it('should parse larger >', function() {\n      assert.equal(parseAndEval('2 > 3'), false);\n      assert.equal(parseAndEval('2 > 2'), false);\n      assert.equal(parseAndEval('2 > 1'), true);\n    });\n\n    it('should parse largerEq >=', function() {\n      assert.equal(parseAndEval('2 >= 3'), false);\n      assert.equal(parseAndEval('2 >= 2'), true);\n      assert.equal(parseAndEval('2 >= 1'), true);\n    });\n\n    it('should parse mod %', function() {\n      approx.equal(parseAndEval('8 % 3'), 2);\n    });\n\n    it('should parse operator mod', function() {\n      approx.equal(parseAndEval('8 mod 3'), 2);\n    });\n\n    it('should parse multiply *', function() {\n      approx.equal(parseAndEval('4 * 2'), 8);\n      approx.equal(parseAndEval('8 * 2 * 2'), 32);\n    });\n\n    it('should parse implicit multiplication', function() {\n      assert.equal(parseAndEval('4a', {a:2}), 8);\n      assert.equal(parseAndEval('4 a', {a:2}), 8);\n      assert.equal(parseAndEval('a b', {a: 2, b: 4}), 8);\n      assert.equal(parseAndEval('2a b', {a: 2, b: 4}), 16);\n      assert.equal(parseAndEval('2a * b', {a: 2, b: 4}), 16);\n      assert.equal(parseAndEval('2a / b', {a: 2, b: 4}), 1);\n      assert.equal(parseAndEval('a b c', {a: 2, b: 4, c: 6}), 48);\n      assert.equal(parseAndEval('a b*c', {a: 2, b: 4, c: 6}), 48);\n      assert.equal(parseAndEval('a*b c', {a: 2, b: 4, c: 6}), 48);\n      assert.equal(parseAndEval('a/b c', {a: 4, b: 2, c: 6}), 12);\n\n      assert.equal(parseAndEval('1/2a', {a:2}), 1);\n      assert.equal(parseAndEval('8/2a/2', {a:2}), 4);\n      assert.equal(parseAndEval('8/2a*2', {a:2}), 16);\n      assert.equal(parseAndEval('4*2a', {a:2}), 16);\n      assert.equal(parseAndEval('3!10'), 60);\n\n      assert.equal(parseAndEval('(2+3)a', {a:2}), 10);\n      assert.equal(parseAndEval('(2+3)2'), 10);\n      assert.equal(parseAndEval('(2)(3)+4'), 10);\n      assert.equal(parseAndEval('2(3+4)'), 14);\n      assert.equal(parseAndEval('(2+3)-2'), 3); // no implicit multiplication, just a unary minus\n      assert.equal(parseAndEval('a(2+3)', {a: function() {return 42;}}), 42);        // function call\n      assert.equal(parseAndEval('a.b(2+3)', {a: {b: function() {return 42;}}}), 42); // function call\n      assert.equal(parseAndEval('(2+3)(4+5)'), 45);       // implicit multiplication\n      assert.equal(parseAndEval('(2+3)(4+5)(3-1)'), 90);  // implicit multiplication\n\n      assert.equal(parseAndEval('(2a)^3', {a:2}), 64);\n      assert.equal(parseAndEval('2a^3', {a:2}), 16);\n      assert.equal(parseAndEval('2(a)^3', {a:2}), 16);\n      assert.equal(parseAndEval('(2)a^3', {a:2}), 16);\n      assert.equal(parseAndEval('2^3a', {a:2}), 16);\n      assert.equal(parseAndEval('2^3(a)', {a:2}), 16);\n      assert.equal(parseAndEval('2^(3)(a)', {a:2}), 16);\n      assert.equal(parseAndEval('sqrt(2a)', {a:2}), 2);\n\n      assert.deepEqual(parseAndEval('[2, 3] 2'), math.matrix([4, 6]));\n      assert.deepEqual(parseAndEval('[2, 3] a', {a:2}), math.matrix([4, 6]));\n      assert.deepEqual(parseAndEval('A [2,2]', {A: [[1,2], [3,4]]}), 4);          // index\n      assert.deepEqual(parseAndEval('(A) [2,2]', {A: [[1,2], [3,4]]}), 4);        // index\n\n      assert.deepEqual(parseAndEval('[1,2;3,4] [2,2]'), 4);                       // index\n      assert.deepEqual(parseAndEval('([1,2;3,4])[2,2]'), 4);                      // index\n      assert.throws(function () {parseAndEval('2[1,2,3]')}, /Unexpected operator/);// index\n    });\n\n    it('should tell the OperatorNode about implicit multiplications', function() {\n      assert.equal(parse('2 + 3').implicit, false);\n      assert.equal(parse('4 * a').implicit, false);\n\n      assert.equal(parse('4a').implicit, true);\n      assert.equal(parse('4 a').implicit, true);\n      assert.equal(parse('a b').implicit, true);\n      assert.equal(parse('2a b').implicit, true);\n      assert.equal(parse('a b c').implicit, true);\n\n      assert.equal(parse('(2+3)a').implicit, true);\n      assert.equal(parse('(2+3)2').implicit, true);\n      assert.equal(parse('2(3+4)').implicit, true);\n    });\n\n    it('should correctly order consecutive multiplications and implicit multiplications', function() {\n      var node = parse('9km*3km');\n      assert.equal(node.toString({parenthesis: 'all'}), '((9 km) * 3) km');\n    });\n\n    it('should throw an error when having an implicit multiplication between two numbers', function() {\n      assert.throws(function () { math.parse('2 3'); }, /Unexpected part \"3\"/);\n      assert.throws(function () { math.parse('2 * 3 4'); }, /Unexpected part \"4\"/);\n      assert.throws(function () { math.parse('2 * 3 4 * 5'); }, /Unexpected part \"4\"/);\n      assert.throws(function () { math.parse('2 / 3 4 5'); }, /Unexpected part \"4\"/);\n      assert.throws(function () { math.parse('2 + 3 4'); }, /Unexpected part \"4\"/);\n      assert.throws(function () { math.parse('-2 2'); }, /Unexpected part \"2\"/);\n      assert.throws(function () { math.parse('+3 3'); }, /Unexpected part \"3\"/);\n      assert.throws(function () { math.parse('2^3 4'); }, /Unexpected part \"4\"/);\n    });\n\n    it('should parse pow ^', function() {\n      approx.equal(parseAndEval('2^3'), 8);\n      approx.equal(parseAndEval('-2^2'), -4);  // -(2^2)\n      approx.equal(parseAndEval('2^3^4'), 2.41785163922926e+24); // 2^(3^4)\n    });\n\n    it('should parse smaller <', function() {\n      assert.strictEqual(parseAndEval('2 < 3'), true);\n      assert.strictEqual(parseAndEval('2 < 2'), false);\n      assert.strictEqual(parseAndEval('2 < 1'), false);\n    });\n\n    it('should parse smallerEq <=', function() {\n      assert.strictEqual(parseAndEval('2 <= 3'), true);\n      assert.strictEqual(parseAndEval('2 <= 2'), true);\n      assert.strictEqual(parseAndEval('2 <= 1'), false);\n    });\n\n    it('should parse bitwise and &', function() {\n      assert.strictEqual(parseAndEval('2 & 6'), 2);\n      assert.strictEqual(parseAndEval('5 & 3'), 1);\n      assert.strictEqual(parseAndEval('true & true'), 1);\n      assert.strictEqual(parseAndEval('true & false'), 0);\n      assert.strictEqual(parseAndEval('false & true'), 0);\n      assert.strictEqual(parseAndEval('false & false'), 0);\n    });\n\n    it('should parse bitwise xor ^|', function() {\n      assert.strictEqual(parseAndEval('2 ^| 6'), 4);\n      assert.strictEqual(parseAndEval('5 ^| 3'), 6);\n      assert.strictEqual(parseAndEval('true ^| true'), 0);\n      assert.strictEqual(parseAndEval('true ^| false'), 1);\n      assert.strictEqual(parseAndEval('false ^| true'), 1);\n      assert.strictEqual(parseAndEval('false ^| false'), 0);\n    });\n\n    it('should parse bitwise or |', function() {\n      assert.strictEqual(parseAndEval('2 | 6'), 6);\n      assert.strictEqual(parseAndEval('5 | 3'), 7);\n      assert.strictEqual(parseAndEval('true | true'), 1);\n      assert.strictEqual(parseAndEval('true | false'), 1);\n      assert.strictEqual(parseAndEval('false | true'), 1);\n      assert.strictEqual(parseAndEval('false | false'), 0);\n    });\n\n    it('should parse bitwise left shift <<', function() {\n      assert.strictEqual(parseAndEval('23 << 1'), 46);\n    });\n\n    it('should parse bitwise right arithmetic shift >>', function() {\n      assert.strictEqual(parseAndEval('32 >> 4'), 2);\n      assert.strictEqual(parseAndEval('-12 >> 2'), -3);\n    });\n\n    it('should parse bitwise right logical shift >>>', function() {\n      assert.strictEqual(parseAndEval('32 >>> 4'), 2);\n      assert.strictEqual(parseAndEval('-12 >>> 2'), 1073741821);\n    });\n\n    it('should parse logical and', function() {\n      assert.strictEqual(parseAndEval('2 and 6'), true);\n      assert.strictEqual(parseAndEval('2 and 0'), false);\n      assert.strictEqual(parseAndEval('true and true'), true);\n      assert.strictEqual(parseAndEval('true and false'), false);\n      assert.strictEqual(parseAndEval('false and true'), false);\n      assert.strictEqual(parseAndEval('false and false'), false);\n    });\n\n    it('should parse logical xor', function() {\n      assert.strictEqual(parseAndEval('2 xor 6'), false);\n      assert.strictEqual(parseAndEval('2 xor 0'), true);\n      assert.strictEqual(parseAndEval('true xor true'), false);\n      assert.strictEqual(parseAndEval('true xor false'), true);\n      assert.strictEqual(parseAndEval('false xor true'), true);\n      assert.strictEqual(parseAndEval('false xor false'), false);\n    });\n\n    it('should parse logical or', function() {\n      assert.strictEqual(parseAndEval('2 or 6'), true);\n      assert.strictEqual(parseAndEval('2 or 0'), true);\n      assert.strictEqual(parseAndEval('true or true'), true);\n      assert.strictEqual(parseAndEval('true or false'), true);\n      assert.strictEqual(parseAndEval('false or true'), true);\n      assert.strictEqual(parseAndEval('false or false'), false);\n    });\n\n    it('should parse logical not', function() {\n      assert.strictEqual(parseAndEval('not 2'), false);\n      assert.strictEqual(parseAndEval('not not 2'), true);\n      assert.strictEqual(parseAndEval('not not not 2'), false);\n      assert.strictEqual(parseAndEval('not true'), false);\n\n      assert.strictEqual(parseAndEval('4*not 2'), 0);\n      assert.strictEqual(parseAndEval('4 * not 2'), 0);\n      assert.strictEqual(parseAndEval('4-not 2'), 4);\n      assert.strictEqual(parseAndEval('4 - not 2'), 4);\n      assert.strictEqual(parseAndEval('4+not 2'), 4);\n      assert.strictEqual(parseAndEval('4 + not 2'), 4);\n\n      assert.strictEqual(parseAndEval('10+not not 3'), 11);\n    });\n\n    it('should parse minus -', function() {\n      assert.equal(parseAndEval('4 - 2'), 2);\n      assert.equal(parseAndEval('8 - 2 - 2'), 4);\n    });\n\n    it('should parse unary minus -', function() {\n      assert.equal(parseAndEval('-2'), -2);\n      assert.equal(parseAndEval('--2'), 2);\n      assert.equal(parseAndEval('---2'), -2);\n\n      assert.equal(parseAndEval('4*-2'), -8);\n      assert.equal(parseAndEval('4 * -2'), -8);\n      assert.equal(parseAndEval('4+-2'), 2);\n      assert.equal(parseAndEval('4 + -2'), 2);\n      assert.equal(parseAndEval('4--2'), 6);\n      assert.equal(parseAndEval('4 - -2'), 6);\n\n      assert.equal(parseAndEval('5-3'), 2);\n      assert.equal(parseAndEval('5--3'), 8);\n      assert.equal(parseAndEval('5---3'), 2);\n      assert.equal(parseAndEval('5+---3'), 2);\n      assert.equal(parseAndEval('5----3'), 8);\n      assert.equal(parseAndEval('5+--(2+1)'), 8);\n    });\n\n    it('should parse unary +', function() {\n      assert.equal(parseAndEval('+2'), 2);\n      assert.equal(parseAndEval('++2'), 2);\n      assert.equal(parseAndEval('+++2'), 2);\n      assert.equal(parseAndEval('+true'), 1);\n\n      assert.equal(parseAndEval('4*+2'), 8);\n      assert.equal(parseAndEval('4 * +2'), 8);\n      assert.equal(parseAndEval('4-+2'), 2);\n      assert.equal(parseAndEval('4 - +2'), 2);\n      assert.equal(parseAndEval('4++2'), 6);\n      assert.equal(parseAndEval('4 + +2'), 6);\n\n      assert.equal(parseAndEval('5+3'), 8);\n      assert.equal(parseAndEval('5++3'), 8);\n    });\n\n    it('should parse unary ~', function() {\n      assert.equal(parseAndEval('~2'), -3);\n      assert.equal(parseAndEval('~~2'), 2);\n      assert.equal(parseAndEval('~~~2'), -3);\n      assert.equal(parseAndEval('~true'), -2);\n\n      assert.equal(parseAndEval('4*~2'), -12);\n      assert.equal(parseAndEval('4 * ~2'), -12);\n      assert.equal(parseAndEval('4-~2'), 7);\n      assert.equal(parseAndEval('4 - ~2'), 7);\n      assert.equal(parseAndEval('4+~2'), 1);\n      assert.equal(parseAndEval('4 + ~2'), 1);\n\n      assert.equal(parseAndEval('10+~~3'), 13);\n    });\n\n    it('should parse unary plus and minus  +, -', function() {\n      assert.equal(parseAndEval('-+2'), -2);\n      assert.equal(parseAndEval('-+-2'), 2);\n      assert.equal(parseAndEval('+-+-2'), 2);\n      assert.equal(parseAndEval('+-2'), -2);\n      assert.equal(parseAndEval('+-+2'), -2);\n      assert.equal(parseAndEval('-+-+2'), 2);\n    });\n\n    it('should parse unary plus and bitwise not  +, ~', function() {\n      assert.equal(parseAndEval('~+2'), -3);\n      assert.equal(parseAndEval('~+~2'), 2);\n      assert.equal(parseAndEval('+~+~2'), 2);\n      assert.equal(parseAndEval('+~2'), -3);\n      assert.equal(parseAndEval('+~+2'), -3);\n      assert.equal(parseAndEval('~+~+2'), 2);\n    });\n\n    it('should parse unary minus and bitwise not  -, ~', function() {\n      assert.equal(parseAndEval('~-2'), 1);\n      assert.equal(parseAndEval('~-~2'), -4);\n      assert.equal(parseAndEval('-~-~2'), 4);\n      assert.equal(parseAndEval('-~2'), 3);\n      assert.equal(parseAndEval('-~-2'), -1);\n      assert.equal(parseAndEval('~-~-2'), 0);\n    });\n\n    it('should parse unary plus + and logical not', function() {\n      assert.equal(parseAndEval('not+2'), false);\n      assert.equal(parseAndEval('not + not 2'), true);\n      assert.equal(parseAndEval('+not+not 2'), 1);\n      assert.equal(parseAndEval('+ not 2'), 0);\n      assert.equal(parseAndEval('+ not +2'), 0);\n      assert.equal(parseAndEval('not + not +2'), true);\n    });\n\n    it('should parse bitwise not ~ and logical not', function() {\n      assert.equal(parseAndEval('~not 2'), -1);\n      assert.equal(parseAndEval('~not~2'), -1);\n      assert.equal(parseAndEval('not~not~2'), false);\n      assert.equal(parseAndEval('not~2'), false);\n      assert.equal(parseAndEval('not~not 2'), false);\n      assert.equal(parseAndEval('~not~not 2'), -1);\n    });\n\n    it('should parse unary minus and logical not', function() {\n      assert.equal(parseAndEval('not-2'), false);\n      assert.equal(parseAndEval('not-not 2'), true);\n      assert.equal(parseAndEval('-not-not 2'), -1);\n      assert.equal(parseAndEval('-not 2'), -0);\n      assert.equal(parseAndEval('-not-2'), -0);\n      assert.equal(parseAndEval('not-not-2'), true);\n    });\n\n    it('should parse unequal !=', function() {\n      assert.strictEqual(parseAndEval('2 != 3'), true);\n      assert.strictEqual(parseAndEval('2 != 2'), false);\n      assert.deepEqual(parseAndEval('[2,3] != [2,4]'), math.matrix([false, true]));\n    });\n\n    it('should parse conditional expression a ? b : c', function() {\n      assert.equal(parseAndEval('2 ? true : false'), true);\n      assert.equal(parseAndEval('0 ? true : false'), false);\n      assert.equal(parseAndEval('false ? true : false'), false);\n\n      assert.equal(parseAndEval('2 > 0 ? 1 : 2 < 0 ? -1 : 0'), 1);\n      assert.equal(parseAndEval('(2 > 0 ? 1 : 2 < 0) ? -1 : 0'), -1);\n      assert.equal(parseAndEval('-2 > 0 ? 1 : -2 < 0 ? -1 : 0'), -1);\n      assert.equal(parseAndEval('0 > 0 ? 1 : 0 < 0 ? -1 : 0'), 0);\n    });\n\n    it('should lazily evaluate conditional expression a ? b : c', function() {\n      var scope = {};\n      math.parse('true ? (a = 2) : (b = 2)').compile().eval(scope);\n      assert.deepEqual(scope, {a: 2});\n    });\n\n    it('should throw an error when false part of conditional expression is missing', function() {\n      assert.throws(function() {parseAndEval('2 ? true');}, /False part of conditional expression expected/);\n    });\n\n    it('should parse : (range)', function() {\n      assert.ok(parseAndEval('2:5') instanceof Matrix);\n      assert.deepEqual(parseAndEval('2:5'), math.matrix([2,3,4,5]));\n      assert.deepEqual(parseAndEval('10:-2:0'), math.matrix([10,8,6,4,2,0]));\n      assert.deepEqual(parseAndEval('2:4.0'), math.matrix([2,3,4]));\n      assert.deepEqual(parseAndEval('2:4.5'), math.matrix([2,3,4]));\n      assert.deepEqual(parseAndEval('2:4.1'), math.matrix([2,3,4]));\n      assert.deepEqual(parseAndEval('2:3.9'), math.matrix([2,3]));\n      assert.deepEqual(parseAndEval('2:3.5'), math.matrix([2,3]));\n      assert.deepEqual(parseAndEval('3:-1:0.5'), math.matrix([3,2,1]));\n      assert.deepEqual(parseAndEval('3:-1:0.5'), math.matrix([3,2,1]));\n      assert.deepEqual(parseAndEval('3:-1:0.1'), math.matrix([3,2,1]));\n      assert.deepEqual(parseAndEval('3:-1:-0.1'), math.matrix([3,2,1,0]));\n    });\n\n    it('should parse to', function() {\n      approx.deepEqual(parseAndEval('2.54 cm to inch'), math.unit(1, 'inch').to('inch'));\n      approx.deepEqual(parseAndEval('2.54 cm + 2 inch to foot'), math.unit(0.25, 'foot').to('foot'));\n    });\n\n    it('should parse in', function() {\n      approx.deepEqual(parseAndEval('2.54 cm in inch'), math.unit(1, 'inch').to('inch'));\n    });\n\n    it('should parse factorial !', function() {\n      assert.deepEqual(parseAndEval('5!'), 120);\n      assert.deepEqual(parseAndEval('[1,2,3,4]!'), math.matrix([1,2,6,24]));\n      assert.deepEqual(parseAndEval('4!+2'), 26);\n      assert.deepEqual(parseAndEval('4!-2'), 22);\n      assert.deepEqual(parseAndEval('4!*2'), 48);\n      assert.deepEqual(parseAndEval('3!!'), 720);\n      assert.deepEqual(parseAndEval('[1,2;3,1]!\\'!'), math.matrix([[1, 720], [2, 1]]));\n      assert.deepEqual(parseAndEval('[4,5]![2]'), 120); // index [2]\n    });\n\n    it('should parse transpose \\'', function() {\n      assert.deepEqual(parseAndEval('23\\''), 23);\n      assert.deepEqual(parseAndEval('[1,2,3;4,5,6]\\''), math.matrix([[1,4],[2,5],[3,6]]));\n      assert.ok(parseAndEval('[1,2,3;4,5,6]\\'') instanceof Matrix);\n      assert.deepEqual(parseAndEval('[1:5]'), math.matrix([[1,2,3,4,5]]));\n      assert.deepEqual(parseAndEval('[1:5]\\''), math.matrix([[1],[2],[3],[4],[5]]));\n      assert.deepEqual(parseAndEval('size([1:5])'), math.matrix([1, 5]));\n      assert.deepEqual(parseAndEval('[1,2;3,4]\\''), math.matrix([[1,3],[2,4]]));\n    });\n\n    describe('operator precedence', function() {\n      it('should respect precedence of plus and minus', function () {\n        assert.equal(parseAndEval('4-2+3'), 5);\n        assert.equal(parseAndEval('4-(2+3)'), -1);\n        assert.equal(parseAndEval('4-2-3'), -1);\n        assert.equal(parseAndEval('4-(2-3)'), 5);\n      });\n\n      it('should respect precedence of plus/minus and multiply/divide', function () {\n        assert.equal(parseAndEval('2+3*4'), 14);\n        assert.equal(parseAndEval('2*3+4'), 10);\n      });\n\n      it('should respect precedence of plus/minus and pow', function () {\n        assert.equal(parseAndEval('2+3^2'), 11);\n        assert.equal(parseAndEval('3^2+2'), 11);\n        assert.equal(parseAndEval('8-2^2'), 4);\n        assert.equal(parseAndEval('4^2-2'), 14);\n      });\n\n      it('should respect precedence of multiply/divide and pow', function () {\n        assert.equal(parseAndEval('2*3^2'), 18);\n        assert.equal(parseAndEval('3^2*2'), 18);\n        assert.equal(parseAndEval('8/2^2'), 2);\n        assert.equal(parseAndEval('4^2/2'), 8);\n      });\n\n      it('should respect precedence of pow', function () {\n        assert.equal(parseAndEval('2^3'), 8);\n        assert.equal(parseAndEval('2^3^4'), Math.pow(2, Math.pow(3, 4)));\n        assert.equal(parseAndEval('1.5^1.5^1.5'), parseAndEval('1.5^(1.5^1.5)'));\n        assert.equal(parseAndEval('1.5^1.5^1.5^1.5'), parseAndEval('1.5^(1.5^(1.5^1.5))'));\n      });\n\n      it('should respect precedence of unary operations and pow', function () {\n        assert.equal(parseAndEval('-3^2'), -9);\n        assert.equal(parseAndEval('(-3)^2'), 9);\n        assert.equal(parseAndEval('2^-2'), 0.25);\n        assert.equal(parseAndEval('2^(-2)'), 0.25);\n\n        assert.equal(parseAndEval('+3^2'), 9);\n        assert.equal(parseAndEval('(+3)^2'), 9);\n        assert.equal(parseAndEval('2^(+2)'), 4);\n\n        assert.equal(parseAndEval('~3^2'), -10);\n        assert.equal(parseAndEval('(~3)^2'), 16);\n        assert.equal(parseAndEval('2^~2'), 0.125);\n        assert.equal(parseAndEval('2^(~2)'), 0.125);\n\n        assert.equal(parseAndEval('not 3^2'), false);\n        assert.equal(parseAndEval('(not 3)^2'), 0);\n        assert.equal(parseAndEval('2^not 2'), 1);\n        assert.equal(parseAndEval('2^(not 2)'), 1);\n      });\n\n      it('should respect precedence of factorial and pow', function () {\n        assert.equal(parseAndEval('2^3!'), 64);\n        assert.equal(parseAndEval('2^(3!)'), 64);\n        assert.equal(parseAndEval('3!^2'), 36);\n      });\n\n      it('should respect precedence of factorial and unary operations', function () {\n        assert.equal(parseAndEval('-4!'), -24);\n        assert.equal(parseAndEval('-(4!)'), -24);\n\n        assert.equal(parseAndEval('3!+2'), 8);\n        assert.equal(parseAndEval('(3!)+2'), 8);\n        assert.equal(parseAndEval('+4!'), 24);\n\n        assert.equal(parseAndEval('~4!+1'), -24);\n        assert.equal(parseAndEval('~(4!)+1'), -24);\n\n        assert.equal(parseAndEval('not 4!'), false);\n        assert.equal(parseAndEval('not not 4!'), true);\n        assert.equal(parseAndEval('not(4!)'), false);\n        assert.equal(parseAndEval('(not 4!)'), false);\n        assert.equal(parseAndEval('(not 4)!'), 1);\n      });\n\n      it('should respect precedence of transpose', function () {\n        var node = math.parse('a + b\\'');\n        assert(node instanceof OperatorNode);\n        assert.equal(node.op, '+');\n        assert.equal(node.args[0].toString(), 'a');\n        assert.equal(node.args[1].toString(), 'b\\'');\n      });\n\n      it('should respect precedence of transpose (2)', function () {\n        var node = math.parse('a ^ b\\'');\n        assert(node instanceof OperatorNode);\n        assert.equal(node.op, '^');\n        assert.equal(node.args[0].toString(), 'a');\n        assert.equal(node.args[1].toString(), 'b\\'');\n      });\n\n      it('should respect precedence of conditional operator and other operators', function () {\n        assert.equal(parseAndEval('2 > 3 ? true : false'), false);\n        assert.equal(parseAndEval('2 == 3 ? true : false'), false);\n        assert.equal(parseAndEval('3 ? 2 + 4 : 2 - 1'), 6);\n        assert.deepEqual(parseAndEval('3 ? true : false; 22'), new ResultSet([22]));\n        assert.deepEqual(parseAndEval('3 ? 5cm to m : 5cm in mm'), new Unit(5, 'cm').to('m'));\n        assert.deepEqual(parseAndEval('2 == 4-2 ? [1,2] : false'), math.matrix([1,2]));\n        assert.deepEqual(parseAndEval('false ? 1:2:6'), math.matrix([2,3,4,5,6]));\n      });\n\n      it('should respect precedence between left/right shift and relational operators', function () {\n        assert.strictEqual(parseAndEval('32 >> 4 == 2'), true);\n        assert.strictEqual(parseAndEval('2 == 32 >> 4'), true);\n        assert.strictEqual(parseAndEval('2 << 2 == 8'), true);\n        assert.strictEqual(parseAndEval('8 == 2 << 2'), true);\n      });\n\n      it('should respect precedence between relational operators and bitwise and', function () {\n        assert.strictEqual(parseAndEval('2 == 3 & 1'), 0);\n        assert.strictEqual(parseAndEval('3 & 1 == 2'), 0);\n        assert.strictEqual(parseAndEval('2 == (3 & 1)'), false);\n      });\n\n      it('should respect precedence between bitwise or | and logical and', function () {\n        assert.strictEqual(parseAndEval('2 | 2 and 4'), true);\n        assert.strictEqual(parseAndEval('4 and 2 | 2'), true);\n      });\n\n      it('should respect precedence between bitwise xor ^| and bitwise or |', function () {\n        assert.strictEqual(parseAndEval('4 ^| 6 | 2'), 2);\n        assert.strictEqual(parseAndEval('2 | 4 ^| 6'), 2);\n        assert.strictEqual(parseAndEval('(2 | 4) ^| 6'), 0);\n      });\n\n      it('should respect precedence between bitwise and & and bitwise or |', function () {\n        assert.strictEqual(parseAndEval('4 & 3 | 12'), 12);\n        assert.strictEqual(parseAndEval('12 | 4 & 3'), 12);\n        assert.strictEqual(parseAndEval('(12 | 4) & 3'), 0);\n      });\n\n      it('should respect precedence between logical and and or', function () {\n        assert.strictEqual(parseAndEval('false and true or true'), true);\n        assert.strictEqual(parseAndEval('false and (true or true)'), false);\n        assert.strictEqual(parseAndEval('true or true and false'), true);\n        assert.strictEqual(parseAndEval('(true or true) and false'), false);\n      });\n\n      it('should respect precedence of conditional operator and logical or', function () {\n        var node = math.parse('1 or 0 ? 2 or 3 : 0 or 0');\n        assert(node instanceof ConditionalNode);\n        assert.equal(node.condition.toString(), '1 or 0');\n        assert.equal(node.trueExpr.toString(), '2 or 3');\n        assert.equal(node.falseExpr.toString(), '0 or 0');\n        assert.strictEqual(node.compile().eval(), true);\n      });\n\n      it('should respect precedence of conditional operator and relational operators', function () {\n        var node = math.parse('a == b ? a > b : a < b');\n        assert(node instanceof ConditionalNode);\n        assert.equal(node.condition.toString(), 'a == b');\n        assert.equal(node.trueExpr.toString(), 'a > b');\n        assert.equal(node.falseExpr.toString(), 'a < b');\n      });\n\n      it('should respect precedence of conditional operator and range operator', function () {\n        var node = math.parse('a ? b : c : d');\n        assert(node instanceof ConditionalNode);\n        assert.equal(node.condition.toString(), 'a');\n        assert.equal(node.trueExpr.toString(), 'b');\n        assert.equal(node.falseExpr.toString(), 'c:d');\n      });\n\n      it('should respect precedence of conditional operator and range operator (2)', function () {\n        var node = math.parse('a ? (b : c) : (d : e)');\n        assert(node instanceof ConditionalNode);\n        assert.equal(node.condition.toString(), 'a');\n        assert.equal(node.trueExpr.toString(), '(b:c)');\n        assert.equal(node.falseExpr.toString(), '(d:e)');\n      });\n\n      it('should respect precedence of conditional operator and range operator (2)', function () {\n        var node = math.parse('a ? (b ? c : d) : (e ? f : g)');\n        assert(node instanceof ConditionalNode);\n        assert.equal(node.condition.toString(), 'a');\n        assert.equal(node.trueExpr.toString(), '(b ? c : d)');\n        assert.equal(node.falseExpr.toString(), '(e ? f : g)');\n      });\n\n      it('should respect precedence of range operator and relational operators', function () {\n        var node = math.parse('a:b == c:d');\n        assert(node instanceof OperatorNode);\n        assert.equal(node.args[0].toString(), 'a:b');\n        assert.equal(node.args[1].toString(), 'c:d');\n      });\n\n      it('should respect precedence of range operator and operator plus and minus', function () {\n        var node = math.parse('a + b : c - d');\n        assert(node instanceof RangeNode);\n        assert.equal(node.start.toString(), 'a + b');\n        assert.equal(node.end.toString(), 'c - d');\n      });\n\n      it('should respect precedence of \"to\" operator and relational operators', function () {\n        var node = math.parse('a == b to c');\n        assert(node instanceof OperatorNode);\n        assert.equal(node.args[0].toString(), 'a');\n        assert.equal(node.args[1].toString(), 'b to c');\n      });\n\n      it('should respect precedence of \"to\" operator and relational operators (2)', function () {\n        var node = math.parse('a to b == c');\n        assert(node instanceof OperatorNode);\n        assert.equal(node.args[0].toString(), 'a to b');\n        assert.equal(node.args[1].toString(), 'c');\n      });\n\n      // TODO: extensively test operator precedence\n\n    });\n  });\n\n  describe('functions', function () {\n    it('should evaluate function \"mod\"', function () {\n      approx.equal(parseAndEval('mod(8, 3)'), 2);\n\n    });\n\n    it('should evaluate function \"to\" ', function () {\n      approx.deepEqual(parseAndEval('to(5.08 cm * 1000, inch)'),\n          math.unit(2000, 'inch').to('inch'));\n    });\n\n    it('should evaluate function \"sort\" with a custom sort function', function () {\n      var scope = {};\n      parseAndEval('sortByLength(a, b) = size(a)[1] - size(b)[1]', scope);\n      assert.deepEqual(parseAndEval('sort([\"Langdon\", \"Tom\", \"Sara\"], sortByLength)', scope),\n          math.matrix([\"Tom\", \"Sara\", \"Langdon\"]));\n    });\n\n  });\n\n  describe('bignumber', function () {\n    var bigmath = math.create({\n      number: 'BigNumber'\n    });\n    var BigNumber = bigmath.type.BigNumber;\n\n    it('should parse numbers as bignumber', function() {\n      assert.deepEqual(bigmath.bignumber('2.3'), new BigNumber('2.3'));\n      assert.deepEqual(bigmath.eval('2.3'), new BigNumber('2.3'));\n      assert.deepEqual(bigmath.eval('2.3e+500'), new BigNumber('2.3e+500'));\n    });\n\n    it('should evaluate functions supporting bignumbers', function() {\n      assert.deepEqual(bigmath.eval('0.1 + 0.2'), new BigNumber('0.3'));\n    });\n\n    it('should evaluate functions supporting bignumbers', function() {\n      assert.deepEqual(bigmath.eval('add(0.1, 0.2)'), new BigNumber('0.3'));\n    });\n\n    it('should work with mixed numbers and bignumbers', function() {\n      approx.equal(bigmath.eval('pi + 1'), 4.141592653589793);\n    });\n\n    it('should evaluate functions not supporting bignumbers', function() {\n      approx.equal(bigmath.eval('sin(0.1)'), 0.09983341664682815);\n    });\n\n    it('should create a range from bignumbers', function() {\n      assert.deepEqual(bigmath.eval('4:6'),\n          bigmath.matrix([new BigNumber(4), new BigNumber(5), new BigNumber(6)]));\n      assert.deepEqual(bigmath.eval('0:2:4'),\n          bigmath.matrix([new BigNumber(0), new BigNumber(2), new BigNumber(4)]));\n    });\n\n    it('should create a matrix with bignumbers', function() {\n      assert.deepEqual(bigmath.eval('[0.1, 0.2]'),\n          bigmath.matrix([new BigNumber(0.1), new BigNumber(0.2)]));\n    });\n\n    it('should get an element from a matrix with bignumbers', function() {\n      var scope = {};\n      assert.deepEqual(bigmath.eval('a=[0.1, 0.2]', scope),\n          bigmath.matrix([new BigNumber(0.1), new BigNumber(0.2)]));\n\n      assert.deepEqual(bigmath.eval('a[1]', scope), new BigNumber(0.1));\n      assert.deepEqual(bigmath.eval('a[:]', scope),\n          bigmath.matrix([new BigNumber(0.1), new BigNumber(0.2)]));\n      assert.deepEqual(bigmath.eval('a[1:2]', scope),\n          bigmath.matrix([new BigNumber(0.1), new BigNumber(0.2)]));\n    });\n\n    it('should replace elements in a matrix with bignumbers', function() {\n      var scope = {};\n      assert.deepEqual(bigmath.eval('a=[0.1, 0.2]', scope),\n          bigmath.matrix([new BigNumber(0.1), new BigNumber(0.2)]));\n\n      bigmath.eval('a[1] = 0.3', scope);\n      assert.deepEqual(scope.a, bigmath.matrix([new BigNumber(0.3), new BigNumber(0.2)]));\n      bigmath.eval('a[:] = [0.5, 0.6]', scope);\n      assert.deepEqual(scope.a, bigmath.matrix([new BigNumber(0.5), new BigNumber(0.6)]));\n      bigmath.eval('a[1:2] = [0.7, 0.8]', scope);\n      assert.deepEqual(scope.a, bigmath.matrix([new BigNumber(0.7), new BigNumber(0.8)]));\n    });\n\n    it('should work with complex numbers (downgrades bignumbers to number)', function() {\n      assert.deepEqual(bigmath.eval('3i'), new Complex(0, 3));\n      assert.deepEqual(bigmath.eval('2 + 3i'), new Complex(2, 3));\n      assert.deepEqual(bigmath.eval('2 * i'), new Complex(0, 2));\n    });\n\n    it('should work with units', function() {\n      assert.deepEqual(bigmath.eval('2 cm'), new Unit(new BigNumber(2), 'cm'));\n    });\n  });\n\n  describe('scope', function () {\n\n    it('should use a given scope for assignments', function() {\n      var scope = {\n        a: 3,\n        b: 4\n      };\n      assert.deepEqual(parse('a*b').compile().eval(scope), 12);\n      assert.deepEqual(parse('c=5').compile().eval(scope), 5);\n      assert.deepEqual(parse('f(x) = x^a').compile().eval(scope).syntax, 'f(x)');\n\n\n      assert.deepEqual(Object.keys(scope).length, 4);\n      assert.deepEqual(scope.a, 3);\n      assert.deepEqual(scope.b, 4);\n      assert.deepEqual(scope.c, 5);\n      assert.deepEqual(typeof scope.f, 'function');\n\n      assert.equal(scope.f(3), 27);\n      scope.a = 2;\n      assert.equal(scope.f(3), 9);\n      scope.hello = function (name) {\n        return 'hello, ' + name + '!';\n      };\n      assert.deepEqual(parse('hello(\"jos\")').compile().eval(scope), 'hello, jos!');\n    });\n\n    it('should parse undefined symbols, defining symbols, and removing symbols', function() {\n      var scope = {};\n      var n = parse('q');\n      assert.throws(function () { n.compile().eval(scope); });\n      parse('q=33').compile().eval(scope);\n      assert.equal(n.compile().eval(scope), 33);\n      delete scope.q;\n      assert.throws(function () { n.compile().eval(scope); });\n\n      n = parse('qq[1,1]=33');\n      assert.throws(function () { n.compile().eval(scope); });\n      parse('qq=[1,2;3,4]').compile().eval(scope);\n      n.compile().eval(scope);\n      assert.deepEqual(scope.qq, math.matrix([[33,2],[3,4]]));\n      parse('qq=[4]').compile().eval(scope);\n      n.compile().eval(scope);\n      assert.deepEqual(scope.qq, math.matrix([[33]]));\n      delete scope.qq;\n      assert.throws(function () { n.compile().eval(scope); });\n    });\n\n    it('should evaluate a symbol with value null or undefined', function () {\n      assert.equal(parse('a').compile().eval({a: null}), null);\n      assert.equal(parse('a').compile().eval({a: undefined}), undefined);\n    });\n\n  });\n\n  describe('errors', function () {\n\n    it('should return IndexErrors with one based indices', function () {\n      // functions throw a zero-based error\n      assert.throws(function () {math.subset([1,2,3], math.index(4));}, /Index out of range \\(4 > 2\\)/);\n      assert.throws(function () {math.subset([1,2,3], math.index(-2));}, /Index out of range \\(-2 < 0\\)/);\n\n      // evaluation via parser throws one-based error\n      assert.throws(function () {math.eval('A[4]', {A:[1,2,3]});}, /Index out of range \\(4 > 3\\)/);\n      assert.throws(function () {math.eval('A[-2]', {A: [1,2,3]});}, /IndexError: Index out of range \\(-2 < 1\\)/);\n    });\n\n    it('should return DimensionErrors with one based indices (subset)', function () {\n      // TODO: it would be more clear when all errors where DimensionErrors\n\n      // functions throw a zero-based error\n      assert.throws(function () {math.subset([1,2,3], math.index(1,1));}, /DimensionError: Dimension mismatch \\(2 != 1\\)/);\n\n      // evaluation via parser throws one-based error\n      assert.throws(function () {math.eval('A[1,1]', {A: [1,2,3]});}, /DimensionError: Dimension mismatch \\(2 != 1\\)/);\n    });\n\n    it('should return DimensionErrors with one based indices (concat)', function () {\n      // TODO: it would be more clear when all errors where DimensionErrors\n\n      // functions throw a zero-based error\n      assert.throws(function () {math.concat([1,2], [[3,4]]);}, /DimensionError: Dimension mismatch \\(1 != 2\\)/);\n      assert.throws(function () {math.concat([[1,2]], [[3,4]], 2);}, /IndexError: Index out of range \\(2 > 1\\)/);\n      assert.throws(function () {math.concat([[1,2]], [[3,4]], -1);}, /IndexError: Index out of range \\(-1 < 0\\)/);\n\n      // evaluation via parser throws one-based error\n      assert.throws(function () {math.eval('concat([1,2], [[3,4]])');}, /DimensionError: Dimension mismatch \\(1 != 2\\)/);\n      assert.throws(function () {math.eval('concat([[1,2]], [[3,4]], 3)');}, /IndexError: Index out of range \\(3 > 2\\)/);\n      assert.throws(function () {math.eval('concat([[1,2]], [[3,4]], 0)');}, /IndexError: Index out of range \\(0 < 1\\)/);\n    });\n\n    it('should return DimensionErrors with one based indices (max)', function () {\n      // TODO: it would be more clear when all errors where DimensionErrors\n\n      // functions throw a zero-based error\n      // TODO\n\n      // evaluation via parser throws one-based error\n      assert.deepEqual(math.eval('max([[1,2], [3,4]])'), 4);\n      assert.deepEqual(math.eval('max([[1,2], [3,4]], 1)'), math.matrix([3, 4]));\n      assert.deepEqual(math.eval('max([[1,2], [3,4]], 2)'), math.matrix([2, 4]));\n      assert.throws(function () {math.eval('max([[1,2], [3,4]], 3)');}, /IndexError: Index out of range \\(3 > 2\\)/);\n      assert.throws(function () {math.eval('max([[1,2], [3,4]], 0)');}, /IndexError: Index out of range \\(0 < 1\\)/);\n    });\n\n    it('should return DimensionErrors with one based indices (min)', function () {\n      // TODO: it would be more clear when all errors where DimensionErrors\n\n      // functions throw a zero-based error\n      // TODO\n\n      // evaluation via parser throws one-based error\n      assert.deepEqual(math.eval('min([[1,2], [3,4]])'), 1);\n      assert.deepEqual(math.eval('min([[1,2], [3,4]], 1)'), math.matrix([1, 2]));\n      assert.deepEqual(math.eval('min([[1,2], [3,4]], 2)'), math.matrix([1, 3]));\n      assert.throws(function () {math.eval('min([[1,2], [3,4]], 3)');}, /IndexError: Index out of range \\(3 > 2\\)/);\n      assert.throws(function () {math.eval('min([[1,2], [3,4]], 0)');}, /IndexError: Index out of range \\(0 < 1\\)/);\n    });\n\n    it('should return DimensionErrors with one based indices (mean)', function () {\n      // TODO: it would be more clear when all errors where DimensionErrors\n\n      // functions throw a zero-based error\n      // TODO\n\n      // evaluation via parser throws one-based error\n      assert.deepEqual(math.eval('mean([[1,2], [3,4]])'), 2.5);\n      assert.deepEqual(math.eval('mean([[1,2], [3,4]], 1)'), math.matrix([2, 3]));\n      assert.deepEqual(math.eval('mean([[1,2], [3,4]], 2)'), math.matrix([1.5, 3.5]));\n      assert.throws(function () {math.eval('mean([[1,2], [3,4]], 3)');}, /IndexError: Index out of range \\(3 > 2\\)/);\n      assert.throws(function () {math.eval('mean([[1,2], [3,4]], 0)');}, /IndexError: Index out of range \\(0 < 1\\)/);\n    });\n\n  });\n\n  describe('node tree', function () {\n\n    // TODO: test parsing into a node tree\n\n    it('should correctly stringify a node tree', function() {\n      assert.equal(parse('0').toString(), '0');\n      assert.equal(parse('\"hello\"').toString(), '\"hello\"');\n      assert.equal(parse('[1, 2 + 3i, 4]').toString(), '[1, 2 + 3 i, 4]');\n      assert.equal(parse('1/2a').toString(), '1 / 2 a');\n    });\n\n    it('should correctly stringify an index with dot notation', function() {\n      assert.equal(parse('A[2]').toString(), 'A[2]');\n      assert.equal(parse('a[\"b\"]').toString(), 'a[\"b\"]');\n      assert.equal(parse('a.b').toString(), 'a.b');\n    });\n\n    describe('custom nodes', function () {\n      // define a custom node\n      function CustomNode (args) {\n        this.args = args;\n      }\n      CustomNode.prototype = new math.expression.node.Node();\n      CustomNode.prototype.toString = function () {\n        return 'CustomNode';\n      };\n      CustomNode.prototype._compile = function (defs) {\n        var strArgs = [];\n        this.args.forEach(function (arg) {\n          strArgs.push(arg.toString());\n        });\n        return '\"CustomNode(' + strArgs.join(', ') + ')\"';\n      };\n      CustomNode.prototype.forEach = function (callback) {\n        // we don't have childs\n      };\n\n      var options = {\n        nodes: {\n          custom: CustomNode\n        }\n      };\n\n      it('should parse custom nodes', function() {\n        var node = parse('custom(x, (2+x), sin(x))', options);\n        assert.equal(node.compile().eval(), 'CustomNode(x, (2 + x), sin(x))');\n      });\n\n      it('should parse custom nodes without parameters', function() {\n        var node = parse('custom()', options);\n        assert.equal(node.compile().eval(), 'CustomNode()');\n        assert.equal(node.filter(function (node) {return node instanceof CustomNode;}).length, 1);\n\n        var node2 = parse('custom', options);\n        assert.equal(node2.compile().eval(), 'CustomNode()');\n        assert.equal(node2.filter(function (node) {return node instanceof CustomNode;}).length, 1);\n      });\n\n      it('should throw an error on syntax errors in using custom nodes', function() {\n        assert.throws(function () {parse('custom(x', options);}, /Parenthesis \\) expected/);\n        assert.throws(function () {parse('custom(x, ', options);}, /Unexpected end of expression/);\n      });\n    });\n\n  });\n\n  describe ('expose test functions', function () {\n    it('should expose isAlpha', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isAlpha === 'function')\n    });\n\n    it('should expose isValidLatinOrGreek', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isValidLatinOrGreek === 'function')\n    });\n\n    it('should expose isValidMathSymbol', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isValidMathSymbol === 'function')\n    });\n\n    it('should expose isWhitespace', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isWhitespace === 'function')\n    });\n\n    it('should expose isDecimalMark', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isDecimalMark === 'function')\n    });\n\n    it('should expose isDigitDot', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isDigitDot === 'function')\n    });\n\n    it('should expose isDigit', function() {\n      assert.ok('should expose isAlpha', typeof math.expression.parse.isDigit === 'function')\n    });\n\n    it('should allow overriding isAlpha', function() {\n      var originalIsAlpha = math.expression.parse.isAlpha;\n\n      // override isAlpha with one accepting $ characters too\n      math.expression.parse.isAlpha = function (c, cPrev, cNext) {\n        return /^[a-zA-Z_$]$/.test(c)\n      };\n\n      var node = math.expression.parse('$foo');\n      var result = node.eval({$foo: 42});\n      assert.equal(result, 42);\n\n      // restore original isAlpha\n      math.expression.parse.isAlpha = originalIsAlpha\n    });\n\n  });\n\n  it ('Should not allow crashing math by placing a clone function in the config', function () {\n    var mathClone = math.create();\n\n    try {\n      mathClone.eval('f(x)=1;config({clone:f})')\n    }\n    catch (err) {}\n\n    assert.equal(mathClone.eval('2'), 2);\n  });\n\n});\n", "var assert = require('assert');\nvar math = require('../../index');\n\ndescribe('security', function () {\n\n  it ('should not allow calling Function via constructor', function () {\n    assert.throws(function () {\n      math.eval('[].map.constructor(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n  })\n\n  it ('should not allow calling Function via constructor (2)', function () {\n    assert.throws(function () {\n      math.eval('sqrt.constructor(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: No access to method \"constructor\"/);\n  })\n\n  it ('should not allow calling Function via call/apply', function () {\n    assert.throws(function () {\n      math.eval('[].map.constructor.call(null, \"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n\n    assert.throws(function () {\n      math.eval('[].map.constructor.apply(null, [\"console.log(\\'hacked...\\')\"])()');\n    }, /Error: Cannot access method \"map\" as a property/);\n  })\n\n  it ('should not allow calling constructor of a class', function () {\n    assert.throws(function () {\n      math.eval('[].constructor()');\n    }, /Error: No access to method \"constructor\"/);\n  })\n\n  it ('should not allow calling constructor', function () {\n    assert.throws(function () {\n      math.eval('constructor');\n    }, /Error: No access to property \"constructor\"/);\n\n    assert.throws(function () {\n      math.eval('toString');\n    }, /Cannot access method \"toString\" as a property/);\n  })\n\n  it ('should not allow calling Function via constructor', function () {\n    assert.throws(function () {\n      math.eval('[].map.constructor(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n\n    assert.throws(function () {\n      math.eval('[].map[\"constructor\"](\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n  })\n\n  it ('should not allow calling Function via a disguised constructor', function () {\n    assert.throws(function () {\n      math.eval('prop=\"constructor\"; [].map[prop](\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n\n    assert.throws(function () {\n      math.eval('[].map[concat(\"constr\", \"uctor\")](\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n  })\n\n  it ('should not allow calling Function via bind', function () {\n    assert.throws(function () {\n      math.eval('[].map.constructor.bind()(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n  })\n\n  it ('should not allow calling Function via map/forEach', function () {\n    // TODO: simplify this test case, let it output console.log('hacked...')\n    assert.throws(function () {\n      math.eval('[\"//\",\"a/*\\\\nreturn process.mainModule.require\"]._data.map(cos.constructor)[1]()(\"child_process\").execSync(\"ps >&2\")');\n    }, /Error: No access to property \"_data/);\n  })\n\n  it ('should not allow calling Function via Object.assign', function () {\n    // TODO: simplify this test case, let it output console.log('hacked...')\n    assert.throws(function () {\n      math.eval('{}.constructor.assign(cos.constructor, {binding: cos.bind})\\n' +\n          '{}.constructor.assign(cos.constructor, {bind: null})\\n' +\n          'cos.constructor.binding()(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: No access to property \"bind/);\n  })\n\n  it ('should not allow calling Function via imported, overridden function', function () {\n    assert.throws(function () {\n      var math2 = math.create();\n      math2.eval('import({matrix:cos.constructor},{override:1});x=[\"console.log(\\'hacked...\\')\"];x()');\n    }, /Error: Undefined symbol import/);\n  })\n\n  it ('should not allow calling Function via index retrieval', function () {\n    assert.throws(function () {\n      math.eval('a=[\"console.log(\\'hacked...\\')\"]._data;a.isRange=true;x={subset:cos.constructor}[a];x()');\n    }, /Error: No access to property \"_data/);\n  })\n\n  it ('should not allow calling Function via getOwnPropertyDescriptor', function () {\n    assert.throws(function () {\n      math.eval('p = parser()\\n' +\n          'p.eval(\"\", [])\\n' +\n          'o = p.get(\"constructor\")\\n' +\n          'c = o.getOwnPropertyDescriptor(o.__proto__, \"constructor\")\\n' +\n          'c.value(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: No access to property \"constructor\"/);\n  })\n\n  it ('should not allow calling Function via a symbol', function () {\n    assert.throws(function () {\n      math.eval('O = {}.constructor\\n' +\n          'd = O.getOwnPropertyDescriptor(O.__proto__, \"constructor\")\\n' +\n          'eval(\"value\", d)(\"console.log(\\'hacked...\\')\")()');\n    }, /Error: No access to property \"constructor/);\n  })\n\n  it ('should not allow calling Function via a specially encoded constructor property name', function () {\n    assert.throws(function () {\n      math.eval('[].map[\"\\\\x63onstructor\"](\"console.log(\\'hacked...\\')\")()');\n    }, /Error: Cannot access method \"map\" as a property/);\n  })\n\n  it ('should not allow creating an Object with forbidden properties', function () {\n    assert.throws(function () {\n      math.eval('{hasOwnProperty: 2}');\n    }, /Error: No access to property \"hasOwnProperty/);\n\n    assert.throws(function () {\n      math.eval('{constructor: 2}');\n    }, /Error: No access to property \"constructor/);\n\n    assert.throws(function () {\n      math.eval('{toString: 2}');\n    }, /Error: No access to property \"toString/);\n  })\n\n  it ('should not allow calling Object via a an object constructor', function () {\n    assert.throws(function () {\n            math.eval('{}.constructor.assign(expression.node.AssignmentNode.prototype, ' +\n                '{_compile: \"\".toString.bind(\"console.log(\\'hacked...\\')\")})\\n' +\n                'eval(\"a = 2\")');\n    }, /Error: No access to property \"constructor/);\n  })\n\n  it ('should not allow calling Object via a __defineGetter__', function () {\n    assert.throws(function () {\n      math.eval('expression.node.AssignmentNode.prototype.__defineGetter__(\"_compile\", ' +\n          '{}.valueOf.bind(\"\".toString.bind(\"console.log(\\'hacked...\\')\"))); eval(\"a = 2\")')\n    }, /Error: Undefined symbol expression/);\n  })\n\n  it ('should not allow calling eval via a custom compiled SymbolNode', function () {\n    assert.throws(function () {\n      math.eval(\"s={};s.__proto__=expression.node.SymbolNode[\\\"prototype\\\"];expression.node.SymbolNode.apply(s,[\\\"\\\\\\\");},\\\\\\\"exec\\\\\\\":function(a){return global.eval}};//\\\"]._data);s.compile().exec()(\\\"console.log(\\'hacked...\\')\\\")\")\n    }, /Error: Undefined symbol expression/);\n  })\n\n  it ('should not allow calling eval via parse', function () {\n    assert.throws(function () {\n      math.eval('x=parse(\\\"cos\\\");x.name = \\\"\\\\\\\");},\\\\\\\"eval\\\\\\\": function(a) {return global.eval}};\\/\\/a\\\"; x.compile().eval()(\\\"console.log(\\'hacked...\\')\\\")')\n    }, /No access to property \"name\"/);\n  })\n\n  it ('should not allow calling eval via parse (2)', function () {\n    assert.throws(function () {\n      math.eval('p = parse(\"{}[\\\\\"console.log(\\'hacked...\\')\\\\\"]\"); p.index.dimensions[\"0\"].valueType = \"boolean\"; p.eval()')\n    }, /No access to property \"index\"/);\n  })\n\n  it ('should not allow calling eval via function.syntax', function () {\n    assert.throws(function () {\n      math.eval('cos.syntax=\"global.eval\";s=unit(\"5 cm\");s.units=[]._data;s.value=cos;s._compile=s.toString;expression.node.Node.prototype.compile.call(s).eval()(\"console.log(\\'hacked...\\')\")')\n    }, /Error: No access to property \"syntax\"/);\n  })\n\n  it ('should not allow calling eval via clone', function () {\n    assert.throws(function () {\n      math.eval('expression.node.ConstantNode.prototype.clone.call({\"value\":\"eval\", \"valueType\":\"null\"}).eval()(\"console.log(\\'hacked...\\')\")')\n    }, /Error: Undefined symbol expression/);\n  })\n\n  it ('should not allow replacing _compile', function () {\n    assert.throws(function () {\n      math.eval('c(x,y)=\"console.log(\\'hacked...\\')\";expression.node.Node.prototype.compile.apply({_compile:c}).eval()')\n    }, /Error: Undefined symbol expression/);\n  })\n\n  it ('should not allow using restricted properties via subset (1)', function () {\n    assert.throws(function () {\n      math.eval('f()=false;' +\n          'g()={length:3};' +\n          'h()={\"0\":0,\"1\":0,\"2\":0};' +\n          'j(x)=[x(\"constructor\")];' +\n          'k(x)={map:j};' +\n          'i={isIndex:true,isScalar:f,size:g,min:h,max:h,dimension:k};' +\n          'subset(subset([[[0]]],i),index(1,1,1))(\"console.log(\\'hacked...\\')\")()')\n    }, /TypeError: Unexpected type of argument in function subset \\(expected: Index, actual: Object, index: 1\\)/);\n  })\n\n  it ('should not allow using restricted properties via subset (2)', function () {\n    assert.throws(function () {\n      math.eval(\"scope={}; setter = eval(\\\"f(obj, name, newValue, assign) = (obj[name] = newValue)\\\", scope); o = parse(\\\"1\\\"); setter(o, \\\"value\\\", \\\"eval\\\", subset); scope.obj.compile().eval()(\\\"console.log('hacked...')\\\")\")\n    }, /Error: Undefined symbol name/);\n  })\n\n  it ('should not allow using restricted properties via subset (3)', function () {\n    assert.throws(function () {\n      math.eval('subset(parse(\"1\"), index(\"value\"), \"eval\").compile().eval()(\"console.log(\\'hacked...\\')\")')\n    }, /Error: No access to property \"value/);\n  })\n\n  it ('should not allow inserting fake nodes with bad code via node.map or node.transform', function () {\n    assert.throws(function () {\n      math.eval(\"badValue = {\\\"isNode\\\": true, \\\"_compile\\\": eval(\\\"f(a, b) = \\\\\\\"eval\\\\\\\"\\\")}; x = eval(\\\"f(child, path, parent) = path ==\\\\\\\"value\\\\\\\" ? newChild : child\\\", {\\\"newChild\\\": badValue}); parse(\\\"x = 1\\\").map(x).compile().eval()(\\\"console.log(\\'hacked\\')\\\")\")\n    }, /TypeError: Callback function must return a Node/);\n\n    assert.throws(function () {\n      math.eval(\"badValue = {\\\"isNode\\\": true, \\\"type\\\": \\\"ConstantNode\\\", \\\"valueType\\\": \\\"string\\\", \\\"_compile\\\": eval(\\\"f(a, b) = \\\\\\\"eval\\\\\\\"\\\")}; x = eval(\\\"f(child, path, parent) = path ==\\\\\\\"value\\\\\\\" ? newChild : child\\\", {\\\"newChild\\\": badValue}); parse(\\\"x = 1\\\").map(x).compile().eval()(\\\"console.log(\\'hacked...\\')\\\")\")\n    }); // The error message is vague but well...\n  })\n\n  it ('should not allow replacing validateSafeMethod with a local variant', function () {\n    assert.throws(function () {\n      math.eval(\"eval(\\\"f(validateSafeMethod)=cos.constructor(\\\\\\\"return eval\\\\\\\")()\\\")(eval(\\\"f(x,y)=0\\\"))(\\\"console.log('hacked...')\\\")\")\n    }, /Error: No access to method \"constructor\"/);\n  })\n\n  it ('should not allow abusing toString', function () {\n    assert.throws(function () {\n      math.eval(\"badToString = eval(\\\"f() = 1\\\"); badReplace = eval(\\\"f(a, b) = \\\\\\\"eval\\\\\\\"\\\"); badNumber = {toString:badToString, replace:badReplace}; badNode = {\\\"isNode\\\": true, \\\"type\\\": \\\"ConstantNode\\\", \\\"valueType\\\": \\\"number\\\", \\\"value\\\": badNumber}; x = eval(\\\"f(child, path, parent) = badNode\\\", {badNode:badNode}); parse(\\\"(1)\\\").map(x).compile().eval()(\\\"console.log('hacked...')\\\")\")\n    }, /Error: No access to property \"toString\"/);\n  })\n\n  it ('should not allow creating a bad FunctionAssignmentNode', function () {\n    assert.throws(function () {\n      math.eval(\"badNode={isNode:true,type:\\\"FunctionAssignmentNode\\\",expr:parse(\\\"1\\\"),types:{join:eval(\\\"f(a)=\\\\\\\"\\\\\\\"\\\")},params:{\\\"forEach\\\":eval(\\\"f(x)=1\\\"),\\\"join\\\":eval(\\\"f(x)=\\\\\\\"){return eval;}});return fn;})())}});return fn;})());}};//\\\\\\\"\\\")}};parse(\\\"f()=x\\\").map(eval(\\\"f(a,b,c)=badNode\\\",{\\\"badNode\\\":badNode})).compile().eval()()()(\\\"console.log('hacked...')\\\")\")\n    }, /TypeError: Callback function must return a Node/);\n  })\n\n  it ('should not allow creating a bad OperatorNode (1)', function () {\n    assert.throws(function () {\n      math.eval(\"badNode={isNode:true,type:\\\"FunctionAssignmentNode\\\",expr:parse(\\\"1\\\"),types:{join:eval(\\\"f(a)=\\\\\\\"\\\\\\\"\\\")},params:{\\\"forEach\\\":eval(\\\"f(x)=1\\\"),\\\"join\\\":eval(\\\"f(x)=\\\\\\\"){return eval;}});return fn;})())}});return fn;})());}};//\\\\\\\"\\\")}};parse(\\\"f()=x\\\").map(eval(\\\"f(a,b,c)=badNode\\\",{\\\"badNode\\\":badNode})).compile().eval()()()(\\\"console.log('hacked...')\\\")\")\n    }, /TypeError: Callback function must return a Node/);\n  })\n\n  it ('should not allow creating a bad OperatorNode (2)', function () {\n    assert.throws(function () {\n      math.eval(\"parse(\\\"(0)\\\").map(eval(\\\"f(a,b,c)=d\\\",{d:{isNode:true,type:\\\"OperatorNode\\\",fn:\\\"__lookupGetter__\\\",args:{map:eval(\\\"f(a)=b\\\",{b:{join:eval(\\\"f(a)=\\\\\\\"1)||eval;}};//\\\\\\\"\\\")}})}}})).compile().eval()(\\\"console.log('hacked...')\\\")\")\n    }, /TypeError: Node expected for parameter \"content\"/);\n  })\n\n  it ('should not allow creating a bad ConstantNode', function () {\n    assert.throws(function () {\n      math.eval('f(x,y)=\"eval\";g()=3;fakeConstantNode={\"isNode\": true, \"type\": \"ConstantNode\", \"valueType\": \"number\", \"value\": {\"replace\": f, \"toString\": g}};injectFakeConstantNode(child,path,parent)=path==\"value\"?fakeConstantNode:child;parse(\"a=3\").map(injectFakeConstantNode).compile().eval()(\"console.log(\\'hacked...\\')\")')\n    }, /Error: No access to property \"toString\"/);\n  })\n\n  it ('should not allow creating a bad ArrayNode', function () {\n    assert.throws(function () {\n      math.eval('g(x)=\"eval\";f(x)=({join: g});fakeArrayNode={isNode: true, type: \"ArrayNode\", items: {map: f}};injectFakeArrayNode(child,path,parent)=path==\"value\"?fakeArrayNode:child;parse(\"a=3\").map(injectFakeArrayNode).compile().eval()[1](\"console.log(\\'hacked...\\')\")')\n    }, /TypeError: Callback function must return a Node/);\n  })\n\n  it ('should not allow unescaping escaped double quotes', function () {\n    // exploits:\n    // 1) A bug in validateSafeMethod which allows to call any method in Object.prototype\n    // 2) A bug in stringify\n    assert.throws(function () {\n      math.eval(\"x=parse(\\\"\\\\\\\"a\\\\\\\"\\\");x.__defineGetter__(\\\"value\\\",eval(\\\"f()=\\\\\\\"false\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"&&eval;}};\\\\\\/\\\\\\/\\\\\\\"\\\")); x.compile().eval()(\\\"console.log('hacked...')\\\")\")\n    }, /Error: No access to method \"__defineGetter__\"/);\n  })\n\n  it ('should not allow using method chain', function () {\n    assert.throws(function () {\n      math.eval(\"chain(\\\"a(){return eval;};function b\\\").typed({\\\"\\\":f()=0}).done()()(\\\"console.log(\\'hacked...\\')\\\")\")\n    }, /is not a function/);\n  })\n\n  it ('should not allow using method chain (2)', function () {\n    assert.throws(function () {\n      math.eval(\"evilMath=chain().create().done();evilMath.import({\\\"_compile\\\":f(a,b,c)=\\\"eval\\\",\\\"isNode\\\":f()=true}); parse(\\\"(1)\\\").map(g(a,b,c)=evilMath.chain()).compile().eval()(\\\"console.log(\\'hacked...\\')\\\")\")\n    }, /is not a function/);\n  })\n\n  it ('should not allow using method Chain', function () {\n    assert.throws(function () {\n      math.eval(\"x=parse(\\\"a\\\",{nodes:{a:Chain}});Chain.bind(x,{})();evilMath=x.create().done();evilMath.import({\\\"_compile\\\":f(a,b,c)=\\\"eval\\\",\\\"isNode\\\":f()=true}); parse(\\\"(1)\\\").map(g(a,b,c)=evilMath.chain()).compile().eval()(\\\"console.log(\\'hacked...\\')\\\")\");\n    }, /Undefined symbol Chain/);\n  })\n\n  it ('should not allow passing a function name containg bad contents', function () {\n    // underlying issues where:\n    // the input '[][\"fn\"]()=0'   \n    // - defines a function in the root scope, but this shouldn't be allowed syntax\n    // - there is a typed function created which unsecurely evaluates JS code with the function name in it \n    //   -> when the function name contains JS code it can be executed, example:\n    //\n    //         var fn = typed(\"(){}+console.log(`hacked...`);function a\", { \"\": function () { } })\n\n    assert.throws(function () {\n      math.eval('[][\"(){}+console.log(`hacked...`);function a\"]()=0')\n    }, /SyntaxError: Invalid left hand side of assignment operator =/);\n\n    assert.throws(function () {\n      math.eval('{}[\"(){}+console.log(`hacked...`);function a\"]()=0')\n    }, /SyntaxError: Invalid left hand side of assignment operator =/);\n  })\n\n  it ('should allow calling functions on math', function () {\n    assert.equal(math.eval('sqrt(4)'), 2);\n  })\n\n  it ('should allow invoking methods on complex numbers', function () {\n    assert.deepEqual(math.eval('complex(4, 0).sqrt(2)'), math.complex(2, 0));\n  })\n\n  it ('should allow accessing properties on an object', function () {\n    assert.deepEqual(math.eval('obj.a', {obj: {a:42}}), 42);\n  })\n\n  it ('should not allow accessing inherited properties on an object', function () {\n    assert.throws(function () {\n      math.eval('obj.constructor', {obj: {a:42}});\n    }, /Error: No access to property \"constructor\"/)\n  })\n\n  it ('should not allow accessing __proto__', function () {\n    assert.throws(function () {\n      math.eval('{}.__proto__');\n    }, /Error: No access to property \"__proto__\"/)\n  })\n\n  it ('should not allow getting properties from non plain objects', function () {\n    assert.throws(function () {math.eval('[]._data')}, /No access to property \"_data\"/)\n    assert.throws(function () {math.eval('unit(\"5cm\").valueOf')}, /Cannot access method \"valueOf\" as a property/);\n  });\n\n  it ('should not have access to specific namespaces', function () {\n    Object.keys(math.expression.mathWithTransform).forEach (function (name) {\n      var value = math.expression.mathWithTransform[name];\n\n      // only plain functions allowed, no constructor functions\n      if (typeof value === 'function') {\n        assert.strictEqual(isPlainFunction(value), true,\n            'only plain functions expected, constructor functions not allowed (name: ' + name + ')');\n      }\n      else {\n        // plain objects not allowed, only class instances like units and complex numbers\n        if (value && typeof value === 'object') {\n          if (isPlainObject(value) && (name !== 'uninitialized' )) {\n            throw new Error('plain objects are not allowed, only class instances (object name: ' + name + ')');\n          }\n        }\n      }\n\n    });\n\n    assert.throws(function () {math.eval('expression')}, /Undefined symbol/);\n    assert.throws(function () {math.eval('type')}, /Undefined symbol/);\n    assert.throws(function () {math.eval('error')}, /Undefined symbol/);\n    assert.throws(function () {math.eval('json')}, /Undefined symbol/);\n\n    assert.strictEqual(math.expression.mathWithTransform.Matrix, undefined);\n    assert.strictEqual(math.expression.mathWithTransform.Node, undefined);\n    assert.strictEqual(math.expression.mathWithTransform.chain, undefined);\n    assert.deepEqual(math.eval('chain'), math.unit('chain'));\n  });\n\n});\n\nfunction isPlainObject (object) {\n  return typeof object === 'object' && object &&\n      object.constructor === Object &&\n      object.__proto__ === Object.prototype;\n}\n\nfunction isPlainFunction (fn) {\n  return typeof fn === 'function' && fn.prototype.constructor === fn;\n}\n"], "buggy_code_start_loc": [6, 595, 96, 814, 288], "buggy_code_end_loc": [6, 596, 97, 814, 288], "fixing_code_start_loc": [7, 595, 96, 815, 289], "fixing_code_end_loc": [10, 596, 97, 822, 307], "type": "CWE-94", "message": "math.js before 3.17.0 had an arbitrary code execution in the JavaScript engine. Creating a typed function with JavaScript code in the name could result arbitrary execution.", "other": {"cve": {"id": "CVE-2017-1001002", "sourceIdentifier": "josh@bress.net", "published": "2017-11-27T14:29:00.240", "lastModified": "2019-10-09T23:21:24.587", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "math.js before 3.17.0 had an arbitrary code execution in the JavaScript engine. Creating a typed function with JavaScript code in the name could result arbitrary execution."}, {"lang": "es", "value": "Las versiones anteriores a la 3.17.0 de math.js ten\u00edan una vulnerabilidad de ejecuci\u00f3n de c\u00f3digo arbitrario en el motor de JavaScript. La creaci\u00f3n de una funci\u00f3n escrita con c\u00f3digo JavaScript en el nombre podr\u00eda resultar en la ejecuci\u00f3n arbitraria."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}, {"source": "josh@bress.net", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mathjs:math.js:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.17.0", "matchCriteriaId": "CAA4C359-CEFC-48E5-ADD9-42689961238F"}]}]}], "references": [{"url": "https://github.com/josdejong/mathjs/blob/master/HISTORY.md#2017-11-18-version-3170", "source": "josh@bress.net", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/josdejong/mathjs/commit/8d2d48d81b3c233fb64eb2ec1d7a9e1cf6a55a90", "source": "josh@bress.net", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/josdejong/mathjs/commit/8d2d48d81b3c233fb64eb2ec1d7a9e1cf6a55a90"}}