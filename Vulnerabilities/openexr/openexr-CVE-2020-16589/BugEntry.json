{"buggy_code": ["///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2004, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n//-----------------------------------------------------------------------------\n//\n//\tclass TiledInputFile\n//\n//-----------------------------------------------------------------------------\n\n#include \"ImfTiledInputFile.h\"\n#include \"ImfTileDescriptionAttribute.h\"\n#include \"ImfChannelList.h\"\n#include \"ImfMisc.h\"\n#include \"ImfTiledMisc.h\"\n#include \"ImfStdIO.h\"\n#include \"ImfCompressor.h\"\n#include \"ImfXdr.h\"\n#include \"ImfConvert.h\"\n#include \"ImfVersion.h\"\n#include \"ImfTileOffsets.h\"\n#include \"ImfThreading.h\"\n#include \"ImfPartType.h\"\n#include \"ImfMultiPartInputFile.h\"\n#include \"ImfInputStreamMutex.h\"\n#include \"IlmThreadPool.h\"\n#include \"IlmThreadSemaphore.h\"\n#include \"IlmThreadMutex.h\"\n#include \"ImathVec.h\"\n#include \"Iex.h\"\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <assert.h>\n#include \"ImfInputPartData.h\"\n#include \"ImfNamespace.h\"\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\nusing IMATH_NAMESPACE::Box2i;\nusing IMATH_NAMESPACE::V2i;\nusing std::string;\nusing std::vector;\nusing std::min;\nusing std::max;\nusing ILMTHREAD_NAMESPACE::Mutex;\nusing ILMTHREAD_NAMESPACE::Lock;\nusing ILMTHREAD_NAMESPACE::Semaphore;\nusing ILMTHREAD_NAMESPACE::Task;\nusing ILMTHREAD_NAMESPACE::TaskGroup;\nusing ILMTHREAD_NAMESPACE::ThreadPool;\n\nnamespace {\n\nstruct TInSliceInfo\n{\n    PixelType   typeInFrameBuffer;\n    PixelType   typeInFile;\n    char *      base;\n    size_t      xStride;\n    size_t      yStride;\n    bool        fill;\n    bool        skip;\n    double      fillValue;\n    int         xTileCoords;\n    int         yTileCoords;\n\n    TInSliceInfo (PixelType typeInFrameBuffer = HALF,\n                  PixelType typeInFile = HALF,\n                  char *base = 0,\n                  size_t xStride = 0,\n                  size_t yStride = 0,\n                  bool fill = false,\n                  bool skip = false,\n                  double fillValue = 0.0,\n                  int xTileCoords = 0,\n                  int yTileCoords = 0);\n};\n\n\nTInSliceInfo::TInSliceInfo (PixelType tifb,\n                            PixelType tifl,\n                            char *b,\n                            size_t xs, size_t ys,\n                            bool f, bool s,\n                            double fv,\n                            int xtc,\n                            int ytc)\n:\n    typeInFrameBuffer (tifb),\n    typeInFile (tifl),\n    base (b),\n    xStride (xs),\n    yStride (ys),\n    fill (f),\n    skip (s),\n    fillValue (fv),\n    xTileCoords (xtc),\n    yTileCoords (ytc)\n{\n    // empty\n}\n\n\nstruct TileBuffer\n{\n    const char *\tuncompressedData;\n    char *\t\tbuffer;\n    int\t\t\tdataSize;\n    Compressor *\tcompressor;\n    Compressor::Format\tformat;\n    int\t\t\tdx;\n    int\t\t\tdy;\n    int\t\t\tlx;\n    int\t\t\tly;\n    bool\t\thasException;\n    string\t\texception;\n\n     TileBuffer (Compressor * const comp);\n    ~TileBuffer ();\n\n    inline void\t\twait () {_sem.wait();}\n    inline void\t\tpost () {_sem.post();}\n\n protected:\n\n    Semaphore _sem;\n};\n\n\nTileBuffer::TileBuffer (Compressor *comp):\n    uncompressedData (0),\n    buffer (0),\n    dataSize (0),\n    compressor (comp),\n    format (defaultFormat (compressor)),\n    dx (-1),\n    dy (-1),\n    lx (-1),\n    ly (-1),\n    hasException (false),\n    exception (),\n    _sem (1)\n{\n    // empty\n}\n\n\nTileBuffer::~TileBuffer ()\n{\n    delete compressor;\n}\n\n} // namespace\n\n\nclass MultiPartInputFile;\n\n\n//\n// struct TiledInputFile::Data stores things that will be\n// needed between calls to readTile()\n//\n\nstruct TiledInputFile::Data: public Mutex\n{\n    Header\t    header;\t        \t    // the image header\n    TileDescription tileDesc;\t\t            // describes the tile layout\n    int\t\t    version;\t\t            // file's version\n    FrameBuffer\t    frameBuffer;\t            // framebuffer to write into\n    LineOrder\t    lineOrder;\t\t            // the file's lineorder\n    int\t\t    minX;\t\t            // data window's min x coord\n    int\t\t    maxX;\t\t            // data window's max x coord\n    int\t\t    minY;\t\t            // data window's min y coord\n    int\t\t    maxY;\t\t            // data window's max x coord\n\n    int\t\t    numXLevels;\t\t            // number of x levels\n    int\t\t    numYLevels;\t\t            // number of y levels\n    int *\t    numXTiles;\t\t            // number of x tiles at a level\n    int *\t    numYTiles;\t\t            // number of y tiles at a level\n\n    TileOffsets\t    tileOffsets;\t            // stores offsets in file for\n    // each tile\n\n    bool\t    fileIsComplete;\t            // True if no tiles are missing\n                                                    // in the file\n\n    vector<TInSliceInfo> slices;        \t    // info about channels in file\n\n    size_t\t    bytesPerPixel;                  // size of an uncompressed pixel\n\n    size_t\t    maxBytesPerTileLine;            // combined size of a line\n                                                    // over all channels\n\n    int             partNumber;                     // part number\n\n    bool            multiPartBackwardSupport;       // if we are reading a multipart file\n                                                    // using OpenEXR 1.7 API\n\n    int             numThreads;                     // number of threads\n\n    MultiPartInputFile* multiPartFile;              // the MultiPartInputFile used to\n                                                    // support backward compatibility\n    \n    vector<TileBuffer*> tileBuffers;                // each holds a single tile\n    size_t          tileBufferSize;\t            // size of the tile buffers\n\n    bool            memoryMapped;                   // if the stream is memory mapped\n\n    InputStreamMutex * _streamData;\n    bool                _deleteStream;\n\n     Data (int numThreads);\n    ~Data ();\n\n    inline TileBuffer * getTileBuffer (int number);\n\t\t\t\t\t    // hash function from tile indices\n\t\t\t\t\t    // into our vector of tile buffers\n};\n\n\nTiledInputFile::Data::Data (int numThreads):\n    numXTiles (0),\n    numYTiles (0),\n    partNumber (-1),\n    multiPartBackwardSupport(false),\n    numThreads(numThreads),\n    memoryMapped(false),\n    _streamData(NULL),\n    _deleteStream(false)\n{\n    //\n    // We need at least one tileBuffer, but if threading is used,\n    // to keep n threads busy we need 2*n tileBuffers\n    //\n\n    tileBuffers.resize (max (1, 2 * numThreads));\n}\n\n\nTiledInputFile::Data::~Data ()\n{\n    delete [] numXTiles;\n    delete [] numYTiles;\n\n    for (size_t i = 0; i < tileBuffers.size(); i++)\n        delete tileBuffers[i];\n\n    if (multiPartBackwardSupport)\n        delete multiPartFile;\n}\n\n\nTileBuffer*\nTiledInputFile::Data::getTileBuffer (int number)\n{\n    return tileBuffers[number % tileBuffers.size()];\n}\n\n\nnamespace {\n\nvoid\nreadTileData (InputStreamMutex *streamData,\n              TiledInputFile::Data *ifd,\n\t      int dx, int dy,\n\t      int lx, int ly,\n              char *&buffer,\n              int &dataSize)\n{\n    //\n    // Read a single tile block from the file and into the array pointed\n    // to by buffer.  If the file is memory-mapped, then we change where\n    // buffer points instead of writing into the array (hence buffer needs\n    // to be a reference to a char *).\n    //\n\n    //\n    // Look up the location for this tile in the Index and\n    // seek to that position if necessary\n    //\n    \n    Int64 tileOffset = ifd->tileOffsets (dx, dy, lx, ly);\n\n    if (tileOffset == 0)\n    {\n        THROW (IEX_NAMESPACE::InputExc, \"Tile (\" << dx << \", \" << dy << \", \" <<\n\t\t\t      lx << \", \" << ly << \") is missing.\");\n    }\n\n\n    //\n    // In a multi-part file, the next chunk does not need to\n    // belong to the same part, so we have to compare the\n    // offset here.\n    //\n\n    if (!isMultiPart(ifd->version))\n    {\n        if (streamData->currentPosition != tileOffset)\n            streamData->is->seekg (tileOffset);\n    }\n    else\n    {\n        //\n        // In a multi-part file, the file pointer may be moved by other\n        // parts, so we have to ask tellg() where we are.\n        //\n        if (streamData->is->tellg() != tileOffset)\n            streamData->is->seekg (tileOffset);\n    }\n\n    //\n    // Read the first few bytes of the tile (the header).\n    // Verify that the tile coordinates and the level number\n    // are correct.\n    //\n    \n    int tileXCoord, tileYCoord, levelX, levelY;\n\n    if (isMultiPart(ifd->version))\n    {\n        int partNumber;\n        Xdr::read <StreamIO> (*streamData->is, partNumber);\n        if (partNumber != ifd->partNumber)\n        {\n            THROW (IEX_NAMESPACE::ArgExc, \"Unexpected part number \" << partNumber\n                   << \", should be \" << ifd->partNumber << \".\");\n        }\n    }\n\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, tileXCoord);\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, tileYCoord);\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, levelX);\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, levelY);\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, dataSize);\n\n    if (tileXCoord != dx)\n        throw IEX_NAMESPACE::InputExc (\"Unexpected tile x coordinate.\");\n\n    if (tileYCoord != dy)\n        throw IEX_NAMESPACE::InputExc (\"Unexpected tile y coordinate.\");\n\n    if (levelX != lx)\n        throw IEX_NAMESPACE::InputExc (\"Unexpected tile x level number coordinate.\");\n\n    if (levelY != ly)\n        throw IEX_NAMESPACE::InputExc (\"Unexpected tile y level number coordinate.\");\n\n    if (dataSize < 0 || dataSize > static_cast<int>(ifd->tileBufferSize) )\n        throw IEX_NAMESPACE::InputExc (\"Unexpected tile block length.\");\n\n    //\n    // Read the pixel data.\n    //\n\n    if (streamData->is->isMemoryMapped ())\n        buffer = streamData->is->readMemoryMapped (dataSize);\n    else\n        streamData->is->read (buffer, dataSize);\n\n    //\n    // Keep track of which tile is the next one in\n    // the file, so that we can avoid redundant seekg()\n    // operations (seekg() can be fairly expensive).\n    //\n    \n    streamData->currentPosition = tileOffset + 5 * Xdr::size<int>() + dataSize;\n}\n\n\nvoid\nreadNextTileData (InputStreamMutex *streamData,\n                  TiledInputFile::Data *ifd,\n\t\t  int &dx, int &dy,\n\t\t  int &lx, int &ly,\n                  char * & buffer,\n\t\t  int &dataSize)\n{\n    //\n    // Read the next tile block from the file\n    //\n\n    if(isMultiPart(ifd->version))\n    {\n        int part;\n        Xdr::read <StreamIO> (*streamData->is, part);\n        if(part!=ifd->partNumber)\n        {\n           throw IEX_NAMESPACE::InputExc(\"Unexpected part number in readNextTileData\");\n        }\n    }\n\n    //\n    // Read the first few bytes of the tile (the header).\n    //\n\n    Xdr::read <StreamIO> (*streamData->is, dx);\n    Xdr::read <StreamIO> (*streamData->is, dy);\n    Xdr::read <StreamIO> (*streamData->is, lx);\n    Xdr::read <StreamIO> (*streamData->is, ly);\n    Xdr::read <StreamIO> (*streamData->is, dataSize);\n\n    if (dataSize > (int) ifd->tileBufferSize)\n        throw IEX_NAMESPACE::InputExc (\"Unexpected tile block length.\");\n    \n    //\n    // Read the pixel data.\n    //\n\n    streamData->is->read (buffer, dataSize);\n    \n    //\n    // Keep track of which tile is the next one in\n    // the file, so that we can avoid redundant seekg()\n    // operations (seekg() can be fairly expensive).\n    //\n\n    streamData->currentPosition += 5 * Xdr::size<int>() + dataSize;\n}\n\n\n//\n// A TileBufferTask encapsulates the task of uncompressing\n// a single tile and copying it into the frame buffer.\n//\n\nclass TileBufferTask : public Task\n{\n  public:\n\n    TileBufferTask (TaskGroup *group,\n                    TiledInputFile::Data *ifd,\n\t\t    TileBuffer *tileBuffer);\n                    \n    virtual ~TileBufferTask ();\n\n    virtual void\t\texecute ();\n    \n  private:\n\n    TiledInputFile::Data *\t_ifd;\n    TileBuffer *\t\t_tileBuffer;\n};\n\n\nTileBufferTask::TileBufferTask\n    (TaskGroup *group,\n     TiledInputFile::Data *ifd,\n     TileBuffer *tileBuffer)\n:\n    Task (group),\n    _ifd (ifd),\n    _tileBuffer (tileBuffer)\n{\n    // empty\n}\n\n\nTileBufferTask::~TileBufferTask ()\n{\n    //\n    // Signal that the tile buffer is now free\n    //\n\n    _tileBuffer->post ();\n}\n\n\nvoid\nTileBufferTask::execute ()\n{\n    try\n    {\n        //\n        // Calculate information about the tile\n        //\n    \n        Box2i tileRange =  OPENEXR_IMF_INTERNAL_NAMESPACE::dataWindowForTile (\n                _ifd->tileDesc,\n                _ifd->minX, _ifd->maxX,\n                _ifd->minY, _ifd->maxY,\n                _tileBuffer->dx,\n                _tileBuffer->dy,\n                _tileBuffer->lx,\n                _tileBuffer->ly);\n\n        int numPixelsPerScanLine = tileRange.max.x - tileRange.min.x + 1;\n    \n        int numPixelsInTile = numPixelsPerScanLine *\n                            (tileRange.max.y - tileRange.min.y + 1);\n    \n        int sizeOfTile = _ifd->bytesPerPixel * numPixelsInTile;\n    \n    \n        //\n        // Uncompress the data, if necessary\n        //\n    \n        if (_tileBuffer->compressor && _tileBuffer->dataSize < sizeOfTile)\n        {\n            _tileBuffer->format = _tileBuffer->compressor->format();\n\n            _tileBuffer->dataSize = _tileBuffer->compressor->uncompressTile\n\t\t(_tileBuffer->buffer, _tileBuffer->dataSize,\n\t\t tileRange, _tileBuffer->uncompressedData);\n        }\n        else\n        {\n            //\n            // If the line is uncompressed, it's in XDR format,\n            // regardless of the compressor's output format.\n            //\n    \n            _tileBuffer->format = Compressor::XDR;\n            _tileBuffer->uncompressedData = _tileBuffer->buffer;\n        }\n    \n        //\n        // Convert the tile of pixel data back from the machine-independent\n\t// representation, and store the result in the frame buffer.\n        //\n    \n        const char *readPtr = _tileBuffer->uncompressedData;\n                                                        // points to where we\n                                                        // read from in the\n                                                        // tile block\n        \n        //\n        // Iterate over the scan lines in the tile.\n        //\n    \n        for (int y = tileRange.min.y; y <= tileRange.max.y; ++y)\n        {\n            //\n            // Iterate over all image channels.\n            //\n            \n            for (unsigned int i = 0; i < _ifd->slices.size(); ++i)\n            {\n                const TInSliceInfo &slice = _ifd->slices[i];\n    \n                //\n                // These offsets are used to facilitate both\n                // absolute and tile-relative pixel coordinates.\n                //\n            \n                int xOffset = slice.xTileCoords * tileRange.min.x;\n                int yOffset = slice.yTileCoords * tileRange.min.y;\n    \n                //\n                // Fill the frame buffer with pixel data.\n                //\n    \n                if (slice.skip)\n                {\n                    //\n                    // The file contains data for this channel, but\n                    // the frame buffer contains no slice for this channel.\n                    //\n    \n                    skipChannel (readPtr, slice.typeInFile,\n                                 numPixelsPerScanLine);\n                }\n                else\n                {\n                    //\n                    // The frame buffer contains a slice for this channel.\n                    //\n    \n                    char *writePtr = slice.base +\n                                     (y - yOffset) * slice.yStride +\n                                     (tileRange.min.x - xOffset) *\n                                     slice.xStride;\n\n                    char *endPtr = writePtr +\n                                   (numPixelsPerScanLine - 1) * slice.xStride;\n                                    \n                    copyIntoFrameBuffer (readPtr, writePtr, endPtr,\n                                         slice.xStride,\n                                         slice.fill, slice.fillValue,\n                                         _tileBuffer->format,\n                                         slice.typeInFrameBuffer,\n                                         slice.typeInFile);\n                }\n            }\n        }\n    }\n    catch (std::exception &e)\n    {\n        if (!_tileBuffer->hasException)\n        {\n            _tileBuffer->exception = e.what ();\n            _tileBuffer->hasException = true;\n        }\n    }\n    catch (...)\n    {\n        if (!_tileBuffer->hasException)\n        {\n            _tileBuffer->exception = \"unrecognized exception\";\n            _tileBuffer->hasException = true;\n        }\n    }\n}\n\n\nTileBufferTask *\nnewTileBufferTask\n    (TaskGroup *group,\n     InputStreamMutex *streamData,\n     TiledInputFile::Data *ifd,\n     int number,\n     int dx, int dy,\n     int lx, int ly)\n{\n    //\n    // Wait for a tile buffer to become available,\n    // fill the buffer with raw data from the file,\n    // and create a new TileBufferTask whose execute()\n    // method will uncompress the tile and copy the\n    // tile's pixels into the frame buffer.\n    //\n\n    TileBuffer *tileBuffer = ifd->getTileBuffer (number);\n\n    try\n    {\n\ttileBuffer->wait();\n\t\n\ttileBuffer->dx = dx;\n\ttileBuffer->dy = dy;\n\ttileBuffer->lx = lx;\n\ttileBuffer->ly = ly;\n\n\ttileBuffer->uncompressedData = 0;\n\n\treadTileData (streamData, ifd, dx, dy, lx, ly,\n\t\t      tileBuffer->buffer,\n\t\t      tileBuffer->dataSize);\n    }\n    catch (...)\n    {\n\t//\n\t// Reading from the file caused an exception.\n\t// Signal that the tile buffer is free, and\n\t// re-throw the exception.\n\t//\n\n\ttileBuffer->post();\n\tthrow;\n    }\n\n    return new TileBufferTask (group, ifd, tileBuffer);\n}\n\n\n} // namespace\n\n\nTiledInputFile::TiledInputFile (const char fileName[], int numThreads):\n    _data (new Data (numThreads))\n{\n    _data->_streamData=NULL;\n    _data->_deleteStream=true;\n    \n    //\n    // This constructor is called when a user\n    // explicitly wants to read a tiled file.\n    //\n\n\n    IStream* is = 0;\n    try\n    {\n        is = new StdIFStream (fileName);\n\treadMagicNumberAndVersionField(*is, _data->version);\n\n\t//\n        // Backward compatibility to read multpart file.\n        //\n\tif (isMultiPart(_data->version))\n\t{\n\t    compatibilityInitialize(*is);\n\t    return;\n\t}\n\n\t_data->_streamData = new InputStreamMutex();\n\t_data->_streamData->is = is;\n\t_data->header.readFrom (*_data->_streamData->is, _data->version);\n\tinitialize();\n        //read tile offsets - we are not multipart or deep\n        _data->tileOffsets.readFrom (*(_data->_streamData->is), _data->fileIsComplete,false,false);\n\t_data->_streamData->currentPosition = _data->_streamData->is->tellg();\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        if (_data->_streamData != 0)\n        {\n            if (_data->_streamData->is != 0)\n            {\n                delete _data->_streamData->is;\n                _data->_streamData->is = is = 0;\n            }\n\n            delete _data->_streamData;\n        }\n\n        if (is != 0)\n            delete is;\n\n\tREPLACE_EXC (e, \"Cannot open image file \"\n                 \"\\\"\" << fileName << \"\\\". \" << e.what());\n\tthrow;\n    }\n    catch (...)\n    {\n        if ( _data->_streamData != 0)\n        {\n            if ( _data->_streamData->is != 0)\n            {\n                delete _data->_streamData->is;\n                _data->_streamData->is = is = 0;\n            }\n\n            delete _data->_streamData;\n        }\n\n        if (is != 0)\n            delete is;\n        throw;\n    }\n}\n\n\nTiledInputFile::TiledInputFile (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &is, int numThreads):\n    _data (new Data (numThreads))\n{\n    _data->_deleteStream=false;\n    //\n    // This constructor is called when a user\n    // explicitly wants to read a tiled file.\n    //\n\n    bool streamDataCreated = false;\n\n    try\n    {\n\treadMagicNumberAndVersionField(is, _data->version);\n\n\t//\n\t// Backward compatibility to read multpart file.\n\t//\n\tif (isMultiPart(_data->version))\n        {\n\t    compatibilityInitialize(is);\n            return;\n        }\n\n\tstreamDataCreated = true;\n\t_data->_streamData = new InputStreamMutex();\n\t_data->_streamData->is = &is;\n\t_data->header.readFrom (*_data->_streamData->is, _data->version);\n\tinitialize();\n        // file is guaranteed to be single part, regular image\n        _data->tileOffsets.readFrom (*(_data->_streamData->is), _data->fileIsComplete,false,false);\n\t_data->memoryMapped = _data->_streamData->is->isMemoryMapped();\n\t_data->_streamData->currentPosition = _data->_streamData->is->tellg();\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        if (streamDataCreated) delete _data->_streamData;\n\tdelete _data;\n\n\tREPLACE_EXC (e, \"Cannot open image file \"\n                 \"\\\"\" << is.fileName() << \"\\\". \" << e.what());\n\tthrow;\n    }\n    catch (...)\n    {\n        if (streamDataCreated) delete _data->_streamData;\n\tdelete _data;\n        throw;\n    }\n}\n\n\nTiledInputFile::TiledInputFile (const Header &header,\n                                OPENEXR_IMF_INTERNAL_NAMESPACE::IStream *is,\n                                int version,\n                                int numThreads) :\n    _data (new Data (numThreads))\n{\n    _data->_deleteStream=false;\n    _data->_streamData = new InputStreamMutex();\n    //\n    // This constructor called by class Imf::InputFile\n    // when a user wants to just read an image file, and\n    // doesn't care or know if the file is tiled.\n    // No need to have backward compatibility here, because\n    // we have somehow got the header.\n    //\n\n    _data->_streamData->is = is;\n    _data->header = header;\n    _data->version = version;\n    initialize();\n    _data->tileOffsets.readFrom (*(_data->_streamData->is),_data->fileIsComplete,false,false);\n    _data->memoryMapped = is->isMemoryMapped();\n    _data->_streamData->currentPosition = _data->_streamData->is->tellg();\n}\n\n\nTiledInputFile::TiledInputFile (InputPartData* part) \n{\n    _data = new Data (part->numThreads);\n    _data->_deleteStream=false;\n    multiPartInitialize(part);\n}\n\n\nvoid\nTiledInputFile::compatibilityInitialize(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is)\n{\n    is.seekg(0);\n    //\n    // Construct a MultiPartInputFile, initialize TiledInputFile\n    // with the part 0 data.\n    // (TODO) maybe change the third parameter of the constructor of MultiPartInputFile later.\n    //\n    _data->multiPartBackwardSupport = true;\n    _data->multiPartFile = new MultiPartInputFile(is, _data->numThreads);\n    InputPartData* part = _data->multiPartFile->getPart(0);\n\n    multiPartInitialize(part);\n}\n\n\nvoid\nTiledInputFile::multiPartInitialize(InputPartData* part)\n{\n    if (part->header.type() != TILEDIMAGE)\n        throw IEX_NAMESPACE::ArgExc(\"Can't build a TiledInputFile from a type-mismatched part.\");\n\n    _data->_streamData = part->mutex;\n    _data->header = part->header;\n    _data->version = part->version;\n    _data->partNumber = part->partNumber;\n    _data->memoryMapped = _data->_streamData->is->isMemoryMapped();\n    initialize();\n    _data->tileOffsets.readFrom(part->chunkOffsets,_data->fileIsComplete);\n    _data->_streamData->currentPosition = _data->_streamData->is->tellg();\n}\n\n\nvoid\nTiledInputFile::initialize ()\n{\n    // fix bad types in header (arises when a tool built against an older version of\n    // OpenEXR converts a scanline image to tiled)\n    // only applies when file is a single part, regular image, tiled file\n    //\n    if(!isMultiPart(_data->version) &&\n       !isNonImage(_data->version) && \n       isTiled(_data->version) && \n       _data->header.hasType() )\n    {\n        _data->header.setType(TILEDIMAGE);\n    }\n    \n    if (_data->partNumber == -1)\n    {\n        if (!isTiled (_data->version))\n            throw IEX_NAMESPACE::ArgExc (\"Expected a tiled file but the file is not tiled.\");\n        \n    }\n    else\n    {\n        if(_data->header.hasType() && _data->header.type()!=TILEDIMAGE)\n        {\n            throw IEX_NAMESPACE::ArgExc (\"TiledInputFile used for non-tiledimage part.\");\n        }\n    }\n    \n    _data->header.sanityCheck (true);\n\n    _data->tileDesc = _data->header.tileDescription();\n    _data->lineOrder = _data->header.lineOrder();\n\n    //\n    // Save the dataWindow information\n    //\n    \n    const Box2i &dataWindow = _data->header.dataWindow();\n    _data->minX = dataWindow.min.x;\n    _data->maxX = dataWindow.max.x;\n    _data->minY = dataWindow.min.y;\n    _data->maxY = dataWindow.max.y;\n\n    //\n    // Precompute level and tile information to speed up utility functions\n    //\n\n    precalculateTileInfo (_data->tileDesc,\n\t\t\t  _data->minX, _data->maxX,\n\t\t\t  _data->minY, _data->maxY,\n\t\t\t  _data->numXTiles, _data->numYTiles,\n\t\t\t  _data->numXLevels, _data->numYLevels);    \n\n    _data->bytesPerPixel = calculateBytesPerPixel (_data->header);\n\n    _data->maxBytesPerTileLine = _data->bytesPerPixel * _data->tileDesc.xSize;\n\n    _data->tileBufferSize = _data->maxBytesPerTileLine * _data->tileDesc.ySize;\n\n    //\n    // Create all the TileBuffers and allocate their internal buffers\n    //\n\n    for (size_t i = 0; i < _data->tileBuffers.size(); i++)\n    {\n        _data->tileBuffers[i] = new TileBuffer (newTileCompressor\n\t\t\t\t\t\t  (_data->header.compression(),\n\t\t\t\t\t\t   _data->maxBytesPerTileLine,\n\t\t\t\t\t\t   _data->tileDesc.ySize,\n\t\t\t\t\t\t   _data->header));\n\n        if (!_data->_streamData->is->isMemoryMapped ())\n            _data->tileBuffers[i]->buffer = new char [_data->tileBufferSize];\n    }\n\n    _data->tileOffsets = TileOffsets (_data->tileDesc.mode,\n\t\t\t\t      _data->numXLevels,\n\t\t\t\t      _data->numYLevels,\n\t\t\t\t      _data->numXTiles,\n\t\t\t\t      _data->numYTiles);\n}\n\n\nTiledInputFile::~TiledInputFile ()\n{\n    if (!_data->memoryMapped)\n        for (size_t i = 0; i < _data->tileBuffers.size(); i++)\n            delete [] _data->tileBuffers[i]->buffer;\n\n    if (_data->_deleteStream)\n        delete _data->_streamData->is;\n\n    if (_data->partNumber == -1)\n        delete _data->_streamData;\n\n    delete _data;\n}\n\n\nconst char *\nTiledInputFile::fileName () const\n{\n    return _data->_streamData->is->fileName();\n}\n\n\nconst Header &\nTiledInputFile::header () const\n{\n    return _data->header;\n}\n\n\nint\nTiledInputFile::version () const\n{\n    return _data->version;\n}\n\n\nvoid\t\nTiledInputFile::setFrameBuffer (const FrameBuffer &frameBuffer)\n{\n    Lock lock (*_data->_streamData);\n\n    //\n    // Set the frame buffer\n    //\n\n    //\n    // Check if the new frame buffer descriptor is\n    // compatible with the image file header.\n    //\n\n    const ChannelList &channels = _data->header.channels();\n\n    for (FrameBuffer::ConstIterator j = frameBuffer.begin();\n         j != frameBuffer.end();\n         ++j)\n    {\n        ChannelList::ConstIterator i = channels.find (j.name());\n\n        if (i == channels.end())\n            continue;\n\n        if (i.channel().xSampling != j.slice().xSampling ||\n            i.channel().ySampling != j.slice().ySampling)\n            THROW (IEX_NAMESPACE::ArgExc, \"X and/or y subsampling factors \"\n\t\t\t\t\"of \\\"\" << i.name() << \"\\\" channel \"\n\t\t\t\t\"of input file \\\"\" << fileName() << \"\\\" are \"\n\t\t\t\t\"not compatible with the frame buffer's \"\n\t\t\t\t\"subsampling factors.\");\n    }\n\n    //\n    // Initialize the slice table for readPixels().\n    //\n\n    vector<TInSliceInfo> slices;\n    ChannelList::ConstIterator i = channels.begin();\n\n    for (FrameBuffer::ConstIterator j = frameBuffer.begin();\n         j != frameBuffer.end();\n         ++j)\n    {\n        while (i != channels.end() && strcmp (i.name(), j.name()) < 0)\n        {\n            //\n            // Channel i is present in the file but not\n            // in the frame buffer; data for channel i\n            // will be skipped during readPixels().\n            //\n\n            slices.push_back (TInSliceInfo (i.channel().type,\n\t\t\t\t\t    i.channel().type,\n\t\t\t\t\t    0,      // base\n\t\t\t\t\t    0,      // xStride\n\t\t\t\t\t    0,      // yStride\n\t\t\t\t\t    false,  // fill\n\t\t\t\t\t    true,   // skip\n\t\t\t\t\t    0.0));  // fillValue\n            ++i;\n        }\n\n        bool fill = false;\n\n        if (i == channels.end() || strcmp (i.name(), j.name()) > 0)\n        {\n            //\n            // Channel i is present in the frame buffer, but not in the file.\n            // In the frame buffer, slice j will be filled with a default value.\n            //\n\n            fill = true;\n        }\n\n        slices.push_back (TInSliceInfo (j.slice().type,\n                                        fill? j.slice().type: i.channel().type,\n                                        j.slice().base,\n                                        j.slice().xStride,\n                                        j.slice().yStride,\n                                        fill,\n                                        false, // skip\n                                        j.slice().fillValue,\n                                        (j.slice().xTileCoords)? 1: 0,\n                                        (j.slice().yTileCoords)? 1: 0));\n\n        if (i != channels.end() && !fill)\n            ++i;\n    }\n\n    while (i != channels.end())\n    {\n\t//\n\t// Channel i is present in the file but not\n\t// in the frame buffer; data for channel i\n\t// will be skipped during readPixels().\n\t//\n\n\tslices.push_back (TInSliceInfo (i.channel().type,\n\t\t\t\t\ti.channel().type,\n\t\t\t\t\t0, // base\n\t\t\t\t\t0, // xStride\n\t\t\t\t\t0, // yStride\n\t\t\t\t\tfalse,  // fill\n\t\t\t\t\ttrue, // skip\n\t\t\t\t\t0.0)); // fillValue\n\t++i;\n    }\n\n    //\n    // Store the new frame buffer.\n    //\n\n    _data->frameBuffer = frameBuffer;\n    _data->slices = slices;\n}\n\n\nconst FrameBuffer &\nTiledInputFile::frameBuffer () const\n{\n    Lock lock (*_data->_streamData);\n    return _data->frameBuffer;\n}\n\n\nbool\nTiledInputFile::isComplete () const\n{\n    return _data->fileIsComplete;\n}\n\n\nvoid\nTiledInputFile::readTiles (int dx1, int dx2, int dy1, int dy2, int lx, int ly)\n{\n    //\n    // Read a range of tiles from the file into the framebuffer\n    //\n\n    try\n    {\n        Lock lock (*_data->_streamData);\n\n        if (_data->slices.size() == 0)\n            throw IEX_NAMESPACE::ArgExc (\"No frame buffer specified \"\n\t\t\t       \"as pixel data destination.\");\n        \n        if (!isValidLevel (lx, ly))\n            THROW (IEX_NAMESPACE::ArgExc,\n                   \"Level coordinate \"\n                   \"(\" << lx << \", \" << ly << \") \"\n                   \"is invalid.\");\n\n        //\n        // Determine the first and last tile coordinates in both dimensions.\n        // We always attempt to read the range of tiles in the order that\n        // they are stored in the file.\n        //\n                               \n        if (dx1 > dx2)\n            std::swap (dx1, dx2);\n        \n        if (dy1 > dy2)\n            std::swap (dy1, dy2);\n        \n        int dyStart = dy1;\n\tint dyStop  = dy2 + 1;\n\tint dY      = 1;\n\n        if (_data->lineOrder == DECREASING_Y)\n        {\n            dyStart = dy2;\n            dyStop  = dy1 - 1;\n            dY      = -1;\n        }\n\n        //\n        // Create a task group for all tile buffer tasks.  When the\n\t// task group goes out of scope, the destructor waits until\n\t// all tasks are complete.\n        //\n        \n        {\n            TaskGroup taskGroup;\n            int tileNumber = 0;\n    \n            for (int dy = dyStart; dy != dyStop; dy += dY)\n            {\n                for (int dx = dx1; dx <= dx2; dx++)\n                {\n                    if (!isValidTile (dx, dy, lx, ly))\n                        THROW (IEX_NAMESPACE::ArgExc,\n\t\t\t       \"Tile (\" << dx << \", \" << dy << \", \" <<\n\t\t\t       lx << \",\" << ly << \") is not a valid tile.\");\n                    \n                    ThreadPool::addGlobalTask (newTileBufferTask (&taskGroup,\n                                                                  _data->_streamData,\n                                                                  _data,\n                                                                  tileNumber++,\n                                                                  dx, dy,\n                                                                  lx, ly));\n                }\n            }\n\n\t    //\n            // finish all tasks\n\t    //\n        }\n\n\t//\n\t// Exeption handling:\n\t//\n\t// TileBufferTask::execute() may have encountered exceptions, but\n\t// those exceptions occurred in another thread, not in the thread\n\t// that is executing this call to TiledInputFile::readTiles().\n\t// TileBufferTask::execute() has caught all exceptions and stored\n\t// the exceptions' what() strings in the tile buffers.\n\t// Now we check if any tile buffer contains a stored exception; if\n\t// this is the case then we re-throw the exception in this thread.\n\t// (It is possible that multiple tile buffers contain stored\n\t// exceptions.  We re-throw the first exception we find and\n\t// ignore all others.)\n\t//\n\n\tconst string *exception = 0;\n\n        for (size_t i = 0; i < _data->tileBuffers.size(); ++i)\n\t{\n            TileBuffer *tileBuffer = _data->tileBuffers[i];\n\n\t    if (tileBuffer->hasException && !exception)\n\t\texception = &tileBuffer->exception;\n\n\t    tileBuffer->hasException = false;\n\t}\n\n\tif (exception)\n\t    throw IEX_NAMESPACE::IoExc (*exception);\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        REPLACE_EXC (e, \"Error reading pixel data from image \"\n                     \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n}\n\n\nvoid\t\nTiledInputFile::readTiles (int dx1, int dx2, int dy1, int dy2, int l)\n{\n    readTiles (dx1, dx2, dy1, dy2, l, l);\n}\n\n\nvoid\t\nTiledInputFile::readTile (int dx, int dy, int lx, int ly)\n{\n    readTiles (dx, dx, dy, dy, lx, ly);\n}\n\n\nvoid\t\nTiledInputFile::readTile (int dx, int dy, int l)\n{\n    readTile (dx, dy, l, l);\n}\n\n\nvoid\nTiledInputFile::rawTileData (int &dx, int &dy,\n\t\t\t     int &lx, int &ly,\n                             const char *&pixelData,\n\t\t\t     int &pixelDataSize)\n{\n    try\n    {\n        Lock lock (*_data->_streamData);\n\n        if (!isValidTile (dx, dy, lx, ly))\n            throw IEX_NAMESPACE::ArgExc (\"Tried to read a tile outside \"\n\t\t\t       \"the image file's data window.\");\n\n        TileBuffer *tileBuffer = _data->getTileBuffer (0);\n\n        //\n        // if file is a multipart file, we have to seek to the required tile\n        // since we don't know where the file pointer is\n        //\n        int old_dx=dx;\n        int old_dy=dy;\n        int old_lx=lx;\n        int old_ly=ly;\n        if(isMultiPart(version()))\n        {\n            _data->_streamData->is->seekg(_data->tileOffsets(dx,dy,lx,ly));\n        }\n        readNextTileData (_data->_streamData, _data, dx, dy, lx, ly,\n\t\t\t  tileBuffer->buffer,\n                          pixelDataSize);\n        if(isMultiPart(version()))\n        {\n            if (old_dx!=dx || old_dy !=dy || old_lx!=lx || old_ly!=ly)\n            {\n                throw IEX_NAMESPACE::ArgExc (\"rawTileData read the wrong tile\");\n            }\n        }\n        pixelData = tileBuffer->buffer;\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        REPLACE_EXC (e, \"Error reading pixel data from image \"\n                     \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n}\n\n\nunsigned int\nTiledInputFile::tileXSize () const\n{\n    return _data->tileDesc.xSize;\n}\n\n\nunsigned int\nTiledInputFile::tileYSize () const\n{\n    return _data->tileDesc.ySize;\n}\n\n\nLevelMode\nTiledInputFile::levelMode () const\n{\n    return _data->tileDesc.mode;\n}\n\n\nLevelRoundingMode\nTiledInputFile::levelRoundingMode () const\n{\n    return _data->tileDesc.roundingMode;\n}\n\n\nint\nTiledInputFile::numLevels () const\n{\n    if (levelMode() == RIPMAP_LEVELS)\n\tTHROW (IEX_NAMESPACE::LogicExc, \"Error calling numLevels() on image \"\n\t\t\t      \"file \\\"\" << fileName() << \"\\\" \"\n\t\t\t      \"(numLevels() is not defined for files \"\n\t\t\t      \"with RIPMAP level mode).\");\n\n    return _data->numXLevels;\n}\n\n\nint\nTiledInputFile::numXLevels () const\n{\n    return _data->numXLevels;\n}\n\n\nint\nTiledInputFile::numYLevels () const\n{\n    return _data->numYLevels;\n}\n\n\nbool\t\nTiledInputFile::isValidLevel (int lx, int ly) const\n{\n    if (lx < 0 || ly < 0)\n\treturn false;\n\n    if (levelMode() == MIPMAP_LEVELS && lx != ly)\n\treturn false;\n\n    if (lx >= numXLevels() || ly >= numYLevels())\n\treturn false;\n\n    return true;\n}\n\n\nint\nTiledInputFile::levelWidth (int lx) const\n{\n    try\n    {\n        return levelSize (_data->minX, _data->maxX, lx,\n\t\t\t  _data->tileDesc.roundingMode);\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n\tREPLACE_EXC (e, \"Error calling levelWidth() on image \"\n                 \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n\tthrow;\n    }\n}\n\n\nint\nTiledInputFile::levelHeight (int ly) const\n{\n    try\n    {\n        return levelSize (_data->minY, _data->maxY, ly,\n                          _data->tileDesc.roundingMode);\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n\tREPLACE_EXC (e, \"Error calling levelHeight() on image \"\n                 \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n\tthrow;\n    }\n}\n\n\nint\nTiledInputFile::numXTiles (int lx) const\n{\n    if (lx < 0 || lx >= _data->numXLevels)\n    {\n        THROW (IEX_NAMESPACE::ArgExc, \"Error calling numXTiles() on image \"\n\t\t\t    \"file \\\"\" << _data->_streamData->is->fileName() << \"\\\" \"\n\t\t\t    \"(Argument is not in valid range).\");\n\n    }\n    \n    return _data->numXTiles[lx];\n}\n\n\nint\nTiledInputFile::numYTiles (int ly) const\n{\n    if (ly < 0 || ly >= _data->numYLevels)\n    {\n        THROW (IEX_NAMESPACE::ArgExc, \"Error calling numYTiles() on image \"\n\t\t\t    \"file \\\"\" << _data->_streamData->is->fileName() << \"\\\" \"\n\t\t\t    \"(Argument is not in valid range).\");\n    }\n    \n    return _data->numYTiles[ly];\n}\n\n\nBox2i\nTiledInputFile::dataWindowForLevel (int l) const\n{\n    return dataWindowForLevel (l, l);\n}\n\n\nBox2i\nTiledInputFile::dataWindowForLevel (int lx, int ly) const\n{\n    try\n    {\n\treturn OPENEXR_IMF_INTERNAL_NAMESPACE::dataWindowForLevel (\n\t        _data->tileDesc,\n\t        _data->minX, _data->maxX,\n\t        _data->minY, _data->maxY,\n\t        lx, ly);\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n\tREPLACE_EXC (e, \"Error calling dataWindowForLevel() on image \"\n                 \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n\tthrow;\n    }\n}\n\n\nBox2i\nTiledInputFile::dataWindowForTile (int dx, int dy, int l) const\n{\n    return dataWindowForTile (dx, dy, l, l);\n}\n\n\nBox2i\nTiledInputFile::dataWindowForTile (int dx, int dy, int lx, int ly) const\n{\n    try\n    {\n\tif (!isValidTile (dx, dy, lx, ly))\n\t    throw IEX_NAMESPACE::ArgExc (\"Arguments not in valid range.\");\n\n        return OPENEXR_IMF_INTERNAL_NAMESPACE::dataWindowForTile (\n                _data->tileDesc,\n                _data->minX, _data->maxX,\n                _data->minY, _data->maxY,\n                dx, dy, lx, ly);\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n\tREPLACE_EXC (e, \"Error calling dataWindowForTile() on image \"\n                 \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n\tthrow;\n    }\n}\n\n\nbool\nTiledInputFile::isValidTile (int dx, int dy, int lx, int ly) const\n{\n    return ((lx < _data->numXLevels && lx >= 0) &&\n            (ly < _data->numYLevels && ly >= 0) &&\n            (dx < _data->numXTiles[lx] && dx >= 0) &&\n            (dy < _data->numYTiles[ly] && dy >= 0));\n}\n\nvoid TiledInputFile::tileOrder(int dx[], int dy[], int lx[], int ly[]) const\n{\n   return _data->tileOffsets.getTileOrder(dx,dy,lx,ly);\n}\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT\n"], "fixing_code": ["///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2004, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n//-----------------------------------------------------------------------------\n//\n//\tclass TiledInputFile\n//\n//-----------------------------------------------------------------------------\n\n#include \"ImfTiledInputFile.h\"\n#include \"ImfTileDescriptionAttribute.h\"\n#include \"ImfChannelList.h\"\n#include \"ImfMisc.h\"\n#include \"ImfTiledMisc.h\"\n#include \"ImfStdIO.h\"\n#include \"ImfCompressor.h\"\n#include \"ImfXdr.h\"\n#include \"ImfConvert.h\"\n#include \"ImfVersion.h\"\n#include \"ImfTileOffsets.h\"\n#include \"ImfThreading.h\"\n#include \"ImfPartType.h\"\n#include \"ImfMultiPartInputFile.h\"\n#include \"ImfInputStreamMutex.h\"\n#include \"IlmThreadPool.h\"\n#include \"IlmThreadSemaphore.h\"\n#include \"IlmThreadMutex.h\"\n#include \"ImathVec.h\"\n#include \"Iex.h\"\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <assert.h>\n#include \"ImfInputPartData.h\"\n#include \"ImfNamespace.h\"\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\nusing IMATH_NAMESPACE::Box2i;\nusing IMATH_NAMESPACE::V2i;\nusing std::string;\nusing std::vector;\nusing std::min;\nusing std::max;\nusing ILMTHREAD_NAMESPACE::Mutex;\nusing ILMTHREAD_NAMESPACE::Lock;\nusing ILMTHREAD_NAMESPACE::Semaphore;\nusing ILMTHREAD_NAMESPACE::Task;\nusing ILMTHREAD_NAMESPACE::TaskGroup;\nusing ILMTHREAD_NAMESPACE::ThreadPool;\n\nnamespace {\n\nstruct TInSliceInfo\n{\n    PixelType   typeInFrameBuffer;\n    PixelType   typeInFile;\n    char *      base;\n    size_t      xStride;\n    size_t      yStride;\n    bool        fill;\n    bool        skip;\n    double      fillValue;\n    int         xTileCoords;\n    int         yTileCoords;\n\n    TInSliceInfo (PixelType typeInFrameBuffer = HALF,\n                  PixelType typeInFile = HALF,\n                  char *base = 0,\n                  size_t xStride = 0,\n                  size_t yStride = 0,\n                  bool fill = false,\n                  bool skip = false,\n                  double fillValue = 0.0,\n                  int xTileCoords = 0,\n                  int yTileCoords = 0);\n};\n\n\nTInSliceInfo::TInSliceInfo (PixelType tifb,\n                            PixelType tifl,\n                            char *b,\n                            size_t xs, size_t ys,\n                            bool f, bool s,\n                            double fv,\n                            int xtc,\n                            int ytc)\n:\n    typeInFrameBuffer (tifb),\n    typeInFile (tifl),\n    base (b),\n    xStride (xs),\n    yStride (ys),\n    fill (f),\n    skip (s),\n    fillValue (fv),\n    xTileCoords (xtc),\n    yTileCoords (ytc)\n{\n    // empty\n}\n\n\nstruct TileBuffer\n{\n    const char *\tuncompressedData;\n    char *\t\tbuffer;\n    int\t\t\tdataSize;\n    Compressor *\tcompressor;\n    Compressor::Format\tformat;\n    int\t\t\tdx;\n    int\t\t\tdy;\n    int\t\t\tlx;\n    int\t\t\tly;\n    bool\t\thasException;\n    string\t\texception;\n\n     TileBuffer (Compressor * const comp);\n    ~TileBuffer ();\n\n    inline void\t\twait () {_sem.wait();}\n    inline void\t\tpost () {_sem.post();}\n\n protected:\n\n    Semaphore _sem;\n};\n\n\nTileBuffer::TileBuffer (Compressor *comp):\n    uncompressedData (0),\n    buffer (0),\n    dataSize (0),\n    compressor (comp),\n    format (defaultFormat (compressor)),\n    dx (-1),\n    dy (-1),\n    lx (-1),\n    ly (-1),\n    hasException (false),\n    exception (),\n    _sem (1)\n{\n    // empty\n}\n\n\nTileBuffer::~TileBuffer ()\n{\n    delete compressor;\n}\n\n} // namespace\n\n\nclass MultiPartInputFile;\n\n\n//\n// struct TiledInputFile::Data stores things that will be\n// needed between calls to readTile()\n//\n\nstruct TiledInputFile::Data: public Mutex\n{\n    Header\t    header;\t        \t    // the image header\n    TileDescription tileDesc;\t\t            // describes the tile layout\n    int\t\t    version;\t\t            // file's version\n    FrameBuffer\t    frameBuffer;\t            // framebuffer to write into\n    LineOrder\t    lineOrder;\t\t            // the file's lineorder\n    int\t\t    minX;\t\t            // data window's min x coord\n    int\t\t    maxX;\t\t            // data window's max x coord\n    int\t\t    minY;\t\t            // data window's min y coord\n    int\t\t    maxY;\t\t            // data window's max x coord\n\n    int\t\t    numXLevels;\t\t            // number of x levels\n    int\t\t    numYLevels;\t\t            // number of y levels\n    int *\t    numXTiles;\t\t            // number of x tiles at a level\n    int *\t    numYTiles;\t\t            // number of y tiles at a level\n\n    TileOffsets\t    tileOffsets;\t            // stores offsets in file for\n    // each tile\n\n    bool\t    fileIsComplete;\t            // True if no tiles are missing\n                                                    // in the file\n\n    vector<TInSliceInfo> slices;        \t    // info about channels in file\n\n    size_t\t    bytesPerPixel;                  // size of an uncompressed pixel\n\n    size_t\t    maxBytesPerTileLine;            // combined size of a line\n                                                    // over all channels\n\n    int             partNumber;                     // part number\n\n    bool            multiPartBackwardSupport;       // if we are reading a multipart file\n                                                    // using OpenEXR 1.7 API\n\n    int             numThreads;                     // number of threads\n\n    MultiPartInputFile* multiPartFile;              // the MultiPartInputFile used to\n                                                    // support backward compatibility\n    \n    vector<TileBuffer*> tileBuffers;                // each holds a single tile\n    size_t          tileBufferSize;\t            // size of the tile buffers\n\n    bool            memoryMapped;                   // if the stream is memory mapped\n\n    InputStreamMutex * _streamData;\n    bool                _deleteStream;\n\n     Data (int numThreads);\n    ~Data ();\n\n    inline TileBuffer * getTileBuffer (int number);\n\t\t\t\t\t    // hash function from tile indices\n\t\t\t\t\t    // into our vector of tile buffers\n};\n\n\nTiledInputFile::Data::Data (int numThreads):\n    numXTiles (0),\n    numYTiles (0),\n    partNumber (-1),\n    multiPartBackwardSupport(false),\n    numThreads(numThreads),\n    memoryMapped(false),\n    _streamData(NULL),\n    _deleteStream(false)\n{\n    //\n    // We need at least one tileBuffer, but if threading is used,\n    // to keep n threads busy we need 2*n tileBuffers\n    //\n\n    tileBuffers.resize (max (1, 2 * numThreads));\n}\n\n\nTiledInputFile::Data::~Data ()\n{\n    delete [] numXTiles;\n    delete [] numYTiles;\n\n    for (size_t i = 0; i < tileBuffers.size(); i++)\n        delete tileBuffers[i];\n\n    if (multiPartBackwardSupport)\n        delete multiPartFile;\n}\n\n\nTileBuffer*\nTiledInputFile::Data::getTileBuffer (int number)\n{\n    return tileBuffers[number % tileBuffers.size()];\n}\n\n\nnamespace {\n\nvoid\nreadTileData (InputStreamMutex *streamData,\n              TiledInputFile::Data *ifd,\n\t      int dx, int dy,\n\t      int lx, int ly,\n              char *&buffer,\n              int &dataSize)\n{\n    //\n    // Read a single tile block from the file and into the array pointed\n    // to by buffer.  If the file is memory-mapped, then we change where\n    // buffer points instead of writing into the array (hence buffer needs\n    // to be a reference to a char *).\n    //\n\n    //\n    // Look up the location for this tile in the Index and\n    // seek to that position if necessary\n    //\n    \n    Int64 tileOffset = ifd->tileOffsets (dx, dy, lx, ly);\n\n    if (tileOffset == 0)\n    {\n        THROW (IEX_NAMESPACE::InputExc, \"Tile (\" << dx << \", \" << dy << \", \" <<\n\t\t\t      lx << \", \" << ly << \") is missing.\");\n    }\n\n\n    //\n    // In a multi-part file, the next chunk does not need to\n    // belong to the same part, so we have to compare the\n    // offset here.\n    //\n\n    if (!isMultiPart(ifd->version))\n    {\n        if (streamData->currentPosition != tileOffset)\n            streamData->is->seekg (tileOffset);\n    }\n    else\n    {\n        //\n        // In a multi-part file, the file pointer may be moved by other\n        // parts, so we have to ask tellg() where we are.\n        //\n        if (streamData->is->tellg() != tileOffset)\n            streamData->is->seekg (tileOffset);\n    }\n\n    //\n    // Read the first few bytes of the tile (the header).\n    // Verify that the tile coordinates and the level number\n    // are correct.\n    //\n    \n    int tileXCoord, tileYCoord, levelX, levelY;\n\n    if (isMultiPart(ifd->version))\n    {\n        int partNumber;\n        Xdr::read <StreamIO> (*streamData->is, partNumber);\n        if (partNumber != ifd->partNumber)\n        {\n            THROW (IEX_NAMESPACE::ArgExc, \"Unexpected part number \" << partNumber\n                   << \", should be \" << ifd->partNumber << \".\");\n        }\n    }\n\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, tileXCoord);\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, tileYCoord);\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, levelX);\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, levelY);\n    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, dataSize);\n\n    if (tileXCoord != dx)\n        throw IEX_NAMESPACE::InputExc (\"Unexpected tile x coordinate.\");\n\n    if (tileYCoord != dy)\n        throw IEX_NAMESPACE::InputExc (\"Unexpected tile y coordinate.\");\n\n    if (levelX != lx)\n        throw IEX_NAMESPACE::InputExc (\"Unexpected tile x level number coordinate.\");\n\n    if (levelY != ly)\n        throw IEX_NAMESPACE::InputExc (\"Unexpected tile y level number coordinate.\");\n\n    if (dataSize < 0 || dataSize > static_cast<int>(ifd->tileBufferSize) )\n        throw IEX_NAMESPACE::InputExc (\"Unexpected tile block length.\");\n\n    //\n    // Read the pixel data.\n    //\n\n    if (streamData->is->isMemoryMapped ())\n        buffer = streamData->is->readMemoryMapped (dataSize);\n    else\n        streamData->is->read (buffer, dataSize);\n\n    //\n    // Keep track of which tile is the next one in\n    // the file, so that we can avoid redundant seekg()\n    // operations (seekg() can be fairly expensive).\n    //\n    \n    streamData->currentPosition = tileOffset + 5 * Xdr::size<int>() + dataSize;\n}\n\n\nvoid\nreadNextTileData (InputStreamMutex *streamData,\n                  TiledInputFile::Data *ifd,\n\t\t  int &dx, int &dy,\n\t\t  int &lx, int &ly,\n                  char * & buffer,\n\t\t  int &dataSize)\n{\n    //\n    // Read the next tile block from the file\n    //\n\n    if(isMultiPart(ifd->version))\n    {\n        int part;\n        Xdr::read <StreamIO> (*streamData->is, part);\n        if(part!=ifd->partNumber)\n        {\n           throw IEX_NAMESPACE::InputExc(\"Unexpected part number in readNextTileData\");\n        }\n    }\n\n    //\n    // Read the first few bytes of the tile (the header).\n    //\n\n    Xdr::read <StreamIO> (*streamData->is, dx);\n    Xdr::read <StreamIO> (*streamData->is, dy);\n    Xdr::read <StreamIO> (*streamData->is, lx);\n    Xdr::read <StreamIO> (*streamData->is, ly);\n    Xdr::read <StreamIO> (*streamData->is, dataSize);\n\n    if (dataSize > (int) ifd->tileBufferSize)\n        throw IEX_NAMESPACE::InputExc (\"Unexpected tile block length.\");\n    \n    //\n    // Read the pixel data.\n    //\n\n    streamData->is->read (buffer, dataSize);\n    \n    //\n    // Keep track of which tile is the next one in\n    // the file, so that we can avoid redundant seekg()\n    // operations (seekg() can be fairly expensive).\n    //\n\n    streamData->currentPosition += 5 * Xdr::size<int>() + dataSize;\n}\n\n\n//\n// A TileBufferTask encapsulates the task of uncompressing\n// a single tile and copying it into the frame buffer.\n//\n\nclass TileBufferTask : public Task\n{\n  public:\n\n    TileBufferTask (TaskGroup *group,\n                    TiledInputFile::Data *ifd,\n\t\t    TileBuffer *tileBuffer);\n                    \n    virtual ~TileBufferTask ();\n\n    virtual void\t\texecute ();\n    \n  private:\n\n    TiledInputFile::Data *\t_ifd;\n    TileBuffer *\t\t_tileBuffer;\n};\n\n\nTileBufferTask::TileBufferTask\n    (TaskGroup *group,\n     TiledInputFile::Data *ifd,\n     TileBuffer *tileBuffer)\n:\n    Task (group),\n    _ifd (ifd),\n    _tileBuffer (tileBuffer)\n{\n    // empty\n}\n\n\nTileBufferTask::~TileBufferTask ()\n{\n    //\n    // Signal that the tile buffer is now free\n    //\n\n    _tileBuffer->post ();\n}\n\n\nvoid\nTileBufferTask::execute ()\n{\n    try\n    {\n        //\n        // Calculate information about the tile\n        //\n    \n        Box2i tileRange =  OPENEXR_IMF_INTERNAL_NAMESPACE::dataWindowForTile (\n                _ifd->tileDesc,\n                _ifd->minX, _ifd->maxX,\n                _ifd->minY, _ifd->maxY,\n                _tileBuffer->dx,\n                _tileBuffer->dy,\n                _tileBuffer->lx,\n                _tileBuffer->ly);\n\n        int numPixelsPerScanLine = tileRange.max.x - tileRange.min.x + 1;\n    \n        int numPixelsInTile = numPixelsPerScanLine *\n                            (tileRange.max.y - tileRange.min.y + 1);\n    \n        int sizeOfTile = _ifd->bytesPerPixel * numPixelsInTile;\n    \n    \n        //\n        // Uncompress the data, if necessary\n        //\n    \n        if (_tileBuffer->compressor && _tileBuffer->dataSize < sizeOfTile)\n        {\n            _tileBuffer->format = _tileBuffer->compressor->format();\n\n            _tileBuffer->dataSize = _tileBuffer->compressor->uncompressTile\n\t\t(_tileBuffer->buffer, _tileBuffer->dataSize,\n\t\t tileRange, _tileBuffer->uncompressedData);\n        }\n        else\n        {\n            //\n            // If the line is uncompressed, it's in XDR format,\n            // regardless of the compressor's output format.\n            //\n    \n            _tileBuffer->format = Compressor::XDR;\n            _tileBuffer->uncompressedData = _tileBuffer->buffer;\n        }\n    \n        //\n        // Convert the tile of pixel data back from the machine-independent\n\t// representation, and store the result in the frame buffer.\n        //\n    \n        const char *readPtr = _tileBuffer->uncompressedData;\n                                                        // points to where we\n                                                        // read from in the\n                                                        // tile block\n        \n        //\n        // Iterate over the scan lines in the tile.\n        //\n    \n        for (int y = tileRange.min.y; y <= tileRange.max.y; ++y)\n        {\n            //\n            // Iterate over all image channels.\n            //\n            \n            for (unsigned int i = 0; i < _ifd->slices.size(); ++i)\n            {\n                const TInSliceInfo &slice = _ifd->slices[i];\n    \n                //\n                // These offsets are used to facilitate both\n                // absolute and tile-relative pixel coordinates.\n                //\n            \n                int xOffset = slice.xTileCoords * tileRange.min.x;\n                int yOffset = slice.yTileCoords * tileRange.min.y;\n    \n                //\n                // Fill the frame buffer with pixel data.\n                //\n    \n                if (slice.skip)\n                {\n                    //\n                    // The file contains data for this channel, but\n                    // the frame buffer contains no slice for this channel.\n                    //\n    \n                    skipChannel (readPtr, slice.typeInFile,\n                                 numPixelsPerScanLine);\n                }\n                else\n                {\n                    //\n                    // The frame buffer contains a slice for this channel.\n                    //\n    \n                    char *writePtr = slice.base +\n                                     (y - yOffset) * slice.yStride +\n                                     (tileRange.min.x - xOffset) *\n                                     slice.xStride;\n\n                    char *endPtr = writePtr +\n                                   (numPixelsPerScanLine - 1) * slice.xStride;\n                                    \n                    copyIntoFrameBuffer (readPtr, writePtr, endPtr,\n                                         slice.xStride,\n                                         slice.fill, slice.fillValue,\n                                         _tileBuffer->format,\n                                         slice.typeInFrameBuffer,\n                                         slice.typeInFile);\n                }\n            }\n        }\n    }\n    catch (std::exception &e)\n    {\n        if (!_tileBuffer->hasException)\n        {\n            _tileBuffer->exception = e.what ();\n            _tileBuffer->hasException = true;\n        }\n    }\n    catch (...)\n    {\n        if (!_tileBuffer->hasException)\n        {\n            _tileBuffer->exception = \"unrecognized exception\";\n            _tileBuffer->hasException = true;\n        }\n    }\n}\n\n\nTileBufferTask *\nnewTileBufferTask\n    (TaskGroup *group,\n     InputStreamMutex *streamData,\n     TiledInputFile::Data *ifd,\n     int number,\n     int dx, int dy,\n     int lx, int ly)\n{\n    //\n    // Wait for a tile buffer to become available,\n    // fill the buffer with raw data from the file,\n    // and create a new TileBufferTask whose execute()\n    // method will uncompress the tile and copy the\n    // tile's pixels into the frame buffer.\n    //\n\n    TileBuffer *tileBuffer = ifd->getTileBuffer (number);\n\n    try\n    {\n\ttileBuffer->wait();\n\t\n\ttileBuffer->dx = dx;\n\ttileBuffer->dy = dy;\n\ttileBuffer->lx = lx;\n\ttileBuffer->ly = ly;\n\n\ttileBuffer->uncompressedData = 0;\n\n\treadTileData (streamData, ifd, dx, dy, lx, ly,\n\t\t      tileBuffer->buffer,\n\t\t      tileBuffer->dataSize);\n    }\n    catch (...)\n    {\n\t//\n\t// Reading from the file caused an exception.\n\t// Signal that the tile buffer is free, and\n\t// re-throw the exception.\n\t//\n\n\ttileBuffer->post();\n\tthrow;\n    }\n\n    return new TileBufferTask (group, ifd, tileBuffer);\n}\n\n\n} // namespace\n\n\nTiledInputFile::TiledInputFile (const char fileName[], int numThreads):\n    _data (new Data (numThreads))\n{\n    _data->_streamData=NULL;\n    _data->_deleteStream=true;\n    \n    //\n    // This constructor is called when a user\n    // explicitly wants to read a tiled file.\n    //\n\n\n    IStream* is = 0;\n    try\n    {\n        is = new StdIFStream (fileName);\n\treadMagicNumberAndVersionField(*is, _data->version);\n\n\t//\n        // Backward compatibility to read multpart file.\n        //\n\tif (isMultiPart(_data->version))\n\t{\n\t    compatibilityInitialize(*is);\n\t    return;\n\t}\n\n\t_data->_streamData = new InputStreamMutex();\n\t_data->_streamData->is = is;\n\t_data->header.readFrom (*_data->_streamData->is, _data->version);\n\tinitialize();\n        //read tile offsets - we are not multipart or deep\n        _data->tileOffsets.readFrom (*(_data->_streamData->is), _data->fileIsComplete,false,false);\n\t_data->_streamData->currentPosition = _data->_streamData->is->tellg();\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        if (_data->_streamData != 0)\n        {\n            if (_data->_streamData->is != 0)\n            {\n                delete _data->_streamData->is;\n                _data->_streamData->is = is = 0;\n            }\n\n            delete _data->_streamData;\n        }\n\n        if (is != 0)\n            delete is;\n\n\tREPLACE_EXC (e, \"Cannot open image file \"\n                 \"\\\"\" << fileName << \"\\\". \" << e.what());\n\tthrow;\n    }\n    catch (...)\n    {\n        if ( _data->_streamData != 0)\n        {\n            if ( _data->_streamData->is != 0)\n            {\n                delete _data->_streamData->is;\n                _data->_streamData->is = is = 0;\n            }\n\n            delete _data->_streamData;\n        }\n\n        if (is != 0)\n            delete is;\n        throw;\n    }\n}\n\n\nTiledInputFile::TiledInputFile (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &is, int numThreads):\n    _data (new Data (numThreads))\n{\n    _data->_deleteStream=false;\n    //\n    // This constructor is called when a user\n    // explicitly wants to read a tiled file.\n    //\n\n    bool streamDataCreated = false;\n\n    try\n    {\n\treadMagicNumberAndVersionField(is, _data->version);\n\n\t//\n\t// Backward compatibility to read multpart file.\n\t//\n\tif (isMultiPart(_data->version))\n        {\n\t    compatibilityInitialize(is);\n            return;\n        }\n\n\tstreamDataCreated = true;\n\t_data->_streamData = new InputStreamMutex();\n\t_data->_streamData->is = &is;\n\t_data->header.readFrom (*_data->_streamData->is, _data->version);\n\tinitialize();\n        // file is guaranteed to be single part, regular image\n        _data->tileOffsets.readFrom (*(_data->_streamData->is), _data->fileIsComplete,false,false);\n\t_data->memoryMapped = _data->_streamData->is->isMemoryMapped();\n\t_data->_streamData->currentPosition = _data->_streamData->is->tellg();\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        if (streamDataCreated) delete _data->_streamData;\n\tdelete _data;\n\n\tREPLACE_EXC (e, \"Cannot open image file \"\n                 \"\\\"\" << is.fileName() << \"\\\". \" << e.what());\n\tthrow;\n    }\n    catch (...)\n    {\n        if (streamDataCreated) delete _data->_streamData;\n\tdelete _data;\n        throw;\n    }\n}\n\n\nTiledInputFile::TiledInputFile (const Header &header,\n                                OPENEXR_IMF_INTERNAL_NAMESPACE::IStream *is,\n                                int version,\n                                int numThreads) :\n    _data (new Data (numThreads))\n{\n    _data->_deleteStream=false;\n    _data->_streamData = new InputStreamMutex();\n    //\n    // This constructor called by class Imf::InputFile\n    // when a user wants to just read an image file, and\n    // doesn't care or know if the file is tiled.\n    // No need to have backward compatibility here, because\n    // we have somehow got the header.\n    //\n\n    _data->_streamData->is = is;\n    _data->header = header;\n    _data->version = version;\n    initialize();\n    _data->tileOffsets.readFrom (*(_data->_streamData->is),_data->fileIsComplete,false,false);\n    _data->memoryMapped = is->isMemoryMapped();\n    _data->_streamData->currentPosition = _data->_streamData->is->tellg();\n}\n\n\nTiledInputFile::TiledInputFile (InputPartData* part) \n{\n    _data = new Data (part->numThreads);\n    _data->_deleteStream=false;\n    multiPartInitialize(part);\n}\n\n\nvoid\nTiledInputFile::compatibilityInitialize(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is)\n{\n    is.seekg(0);\n    //\n    // Construct a MultiPartInputFile, initialize TiledInputFile\n    // with the part 0 data.\n    // (TODO) maybe change the third parameter of the constructor of MultiPartInputFile later.\n    //\n    _data->multiPartBackwardSupport = true;\n    _data->multiPartFile = new MultiPartInputFile(is, _data->numThreads);\n    InputPartData* part = _data->multiPartFile->getPart(0);\n\n    multiPartInitialize(part);\n}\n\n\nvoid\nTiledInputFile::multiPartInitialize(InputPartData* part)\n{\n    if (part->header.type() != TILEDIMAGE)\n        throw IEX_NAMESPACE::ArgExc(\"Can't build a TiledInputFile from a type-mismatched part.\");\n\n    _data->_streamData = part->mutex;\n    _data->header = part->header;\n    _data->version = part->version;\n    _data->partNumber = part->partNumber;\n    _data->memoryMapped = _data->_streamData->is->isMemoryMapped();\n    initialize();\n    _data->tileOffsets.readFrom(part->chunkOffsets,_data->fileIsComplete);\n    _data->_streamData->currentPosition = _data->_streamData->is->tellg();\n}\n\n\nvoid\nTiledInputFile::initialize ()\n{\n    // fix bad types in header (arises when a tool built against an older version of\n    // OpenEXR converts a scanline image to tiled)\n    // only applies when file is a single part, regular image, tiled file\n    //\n    if(!isMultiPart(_data->version) &&\n       !isNonImage(_data->version) && \n       isTiled(_data->version) && \n       _data->header.hasType() )\n    {\n        _data->header.setType(TILEDIMAGE);\n    }\n    \n    if (_data->partNumber == -1)\n    {\n        if (!isTiled (_data->version))\n            throw IEX_NAMESPACE::ArgExc (\"Expected a tiled file but the file is not tiled.\");\n        \n    }\n    else\n    {\n        if(_data->header.hasType() && _data->header.type()!=TILEDIMAGE)\n        {\n            throw IEX_NAMESPACE::ArgExc (\"TiledInputFile used for non-tiledimage part.\");\n        }\n    }\n    \n    _data->header.sanityCheck (true);\n\n    _data->tileDesc = _data->header.tileDescription();\n    _data->lineOrder = _data->header.lineOrder();\n\n    //\n    // Save the dataWindow information\n    //\n    \n    const Box2i &dataWindow = _data->header.dataWindow();\n    _data->minX = dataWindow.min.x;\n    _data->maxX = dataWindow.max.x;\n    _data->minY = dataWindow.min.y;\n    _data->maxY = dataWindow.max.y;\n\n    //\n    // Precompute level and tile information to speed up utility functions\n    //\n\n    precalculateTileInfo (_data->tileDesc,\n\t\t\t  _data->minX, _data->maxX,\n\t\t\t  _data->minY, _data->maxY,\n\t\t\t  _data->numXTiles, _data->numYTiles,\n\t\t\t  _data->numXLevels, _data->numYLevels);    \n\n    _data->bytesPerPixel = calculateBytesPerPixel (_data->header);\n\n    _data->maxBytesPerTileLine = _data->bytesPerPixel * _data->tileDesc.xSize;\n\n    _data->tileBufferSize = _data->maxBytesPerTileLine * _data->tileDesc.ySize;\n\n    //\n    // Create all the TileBuffers and allocate their internal buffers\n    //\n\n    for (size_t i = 0; i < _data->tileBuffers.size(); i++)\n    {\n        _data->tileBuffers[i] = new TileBuffer (newTileCompressor\n\t\t\t\t\t\t  (_data->header.compression(),\n\t\t\t\t\t\t   _data->maxBytesPerTileLine,\n\t\t\t\t\t\t   _data->tileDesc.ySize,\n\t\t\t\t\t\t   _data->header));\n\n        if (!_data->_streamData->is->isMemoryMapped ())\n            _data->tileBuffers[i]->buffer = new char [_data->tileBufferSize];\n    }\n\n    _data->tileOffsets = TileOffsets (_data->tileDesc.mode,\n\t\t\t\t      _data->numXLevels,\n\t\t\t\t      _data->numYLevels,\n\t\t\t\t      _data->numXTiles,\n\t\t\t\t      _data->numYTiles);\n}\n\n\nTiledInputFile::~TiledInputFile ()\n{\n    if (!_data->memoryMapped)\n        for (size_t i = 0; i < _data->tileBuffers.size(); i++)\n            delete [] _data->tileBuffers[i]->buffer;\n\n    if (_data->_deleteStream)\n        delete _data->_streamData->is;\n\n    if (_data->partNumber == -1)\n        delete _data->_streamData;\n\n    delete _data;\n}\n\n\nconst char *\nTiledInputFile::fileName () const\n{\n    return _data->_streamData->is->fileName();\n}\n\n\nconst Header &\nTiledInputFile::header () const\n{\n    return _data->header;\n}\n\n\nint\nTiledInputFile::version () const\n{\n    return _data->version;\n}\n\n\nvoid\t\nTiledInputFile::setFrameBuffer (const FrameBuffer &frameBuffer)\n{\n    Lock lock (*_data->_streamData);\n\n    //\n    // Set the frame buffer\n    //\n\n    //\n    // Check if the new frame buffer descriptor is\n    // compatible with the image file header.\n    //\n\n    const ChannelList &channels = _data->header.channels();\n\n    for (FrameBuffer::ConstIterator j = frameBuffer.begin();\n         j != frameBuffer.end();\n         ++j)\n    {\n        ChannelList::ConstIterator i = channels.find (j.name());\n\n        if (i == channels.end())\n            continue;\n\n        if (i.channel().xSampling != j.slice().xSampling ||\n            i.channel().ySampling != j.slice().ySampling)\n            THROW (IEX_NAMESPACE::ArgExc, \"X and/or y subsampling factors \"\n\t\t\t\t\"of \\\"\" << i.name() << \"\\\" channel \"\n\t\t\t\t\"of input file \\\"\" << fileName() << \"\\\" are \"\n\t\t\t\t\"not compatible with the frame buffer's \"\n\t\t\t\t\"subsampling factors.\");\n    }\n\n    //\n    // Initialize the slice table for readPixels().\n    //\n\n    vector<TInSliceInfo> slices;\n    ChannelList::ConstIterator i = channels.begin();\n\n    for (FrameBuffer::ConstIterator j = frameBuffer.begin();\n         j != frameBuffer.end();\n         ++j)\n    {\n        while (i != channels.end() && strcmp (i.name(), j.name()) < 0)\n        {\n            //\n            // Channel i is present in the file but not\n            // in the frame buffer; data for channel i\n            // will be skipped during readPixels().\n            //\n\n            slices.push_back (TInSliceInfo (i.channel().type,\n\t\t\t\t\t    i.channel().type,\n\t\t\t\t\t    0,      // base\n\t\t\t\t\t    0,      // xStride\n\t\t\t\t\t    0,      // yStride\n\t\t\t\t\t    false,  // fill\n\t\t\t\t\t    true,   // skip\n\t\t\t\t\t    0.0));  // fillValue\n            ++i;\n        }\n\n        bool fill = false;\n\n        if (i == channels.end() || strcmp (i.name(), j.name()) > 0)\n        {\n            //\n            // Channel i is present in the frame buffer, but not in the file.\n            // In the frame buffer, slice j will be filled with a default value.\n            //\n\n            fill = true;\n        }\n\n        slices.push_back (TInSliceInfo (j.slice().type,\n                                        fill? j.slice().type: i.channel().type,\n                                        j.slice().base,\n                                        j.slice().xStride,\n                                        j.slice().yStride,\n                                        fill,\n                                        false, // skip\n                                        j.slice().fillValue,\n                                        (j.slice().xTileCoords)? 1: 0,\n                                        (j.slice().yTileCoords)? 1: 0));\n\n        if (i != channels.end() && !fill)\n            ++i;\n    }\n\n    while (i != channels.end())\n    {\n\t//\n\t// Channel i is present in the file but not\n\t// in the frame buffer; data for channel i\n\t// will be skipped during readPixels().\n\t//\n\n\tslices.push_back (TInSliceInfo (i.channel().type,\n\t\t\t\t\ti.channel().type,\n\t\t\t\t\t0, // base\n\t\t\t\t\t0, // xStride\n\t\t\t\t\t0, // yStride\n\t\t\t\t\tfalse,  // fill\n\t\t\t\t\ttrue, // skip\n\t\t\t\t\t0.0)); // fillValue\n\t++i;\n    }\n\n    //\n    // Store the new frame buffer.\n    //\n\n    _data->frameBuffer = frameBuffer;\n    _data->slices = slices;\n}\n\n\nconst FrameBuffer &\nTiledInputFile::frameBuffer () const\n{\n    Lock lock (*_data->_streamData);\n    return _data->frameBuffer;\n}\n\n\nbool\nTiledInputFile::isComplete () const\n{\n    return _data->fileIsComplete;\n}\n\n\nvoid\nTiledInputFile::readTiles (int dx1, int dx2, int dy1, int dy2, int lx, int ly)\n{\n    //\n    // Read a range of tiles from the file into the framebuffer\n    //\n\n    try\n    {\n        Lock lock (*_data->_streamData);\n\n        if (_data->slices.size() == 0)\n            throw IEX_NAMESPACE::ArgExc (\"No frame buffer specified \"\n\t\t\t       \"as pixel data destination.\");\n        \n        if (!isValidLevel (lx, ly))\n            THROW (IEX_NAMESPACE::ArgExc,\n                   \"Level coordinate \"\n                   \"(\" << lx << \", \" << ly << \") \"\n                   \"is invalid.\");\n\n        //\n        // Determine the first and last tile coordinates in both dimensions.\n        // We always attempt to read the range of tiles in the order that\n        // they are stored in the file.\n        //\n                               \n        if (dx1 > dx2)\n            std::swap (dx1, dx2);\n        \n        if (dy1 > dy2)\n            std::swap (dy1, dy2);\n        \n        int dyStart = dy1;\n\tint dyStop  = dy2 + 1;\n\tint dY      = 1;\n\n        if (_data->lineOrder == DECREASING_Y)\n        {\n            dyStart = dy2;\n            dyStop  = dy1 - 1;\n            dY      = -1;\n        }\n\n        //\n        // Create a task group for all tile buffer tasks.  When the\n\t// task group goes out of scope, the destructor waits until\n\t// all tasks are complete.\n        //\n        \n        {\n            TaskGroup taskGroup;\n            int tileNumber = 0;\n    \n            for (int dy = dyStart; dy != dyStop; dy += dY)\n            {\n                for (int dx = dx1; dx <= dx2; dx++)\n                {\n                    if (!isValidTile (dx, dy, lx, ly))\n                        THROW (IEX_NAMESPACE::ArgExc,\n\t\t\t       \"Tile (\" << dx << \", \" << dy << \", \" <<\n\t\t\t       lx << \",\" << ly << \") is not a valid tile.\");\n                    \n                    ThreadPool::addGlobalTask (newTileBufferTask (&taskGroup,\n                                                                  _data->_streamData,\n                                                                  _data,\n                                                                  tileNumber++,\n                                                                  dx, dy,\n                                                                  lx, ly));\n                }\n            }\n\n\t    //\n            // finish all tasks\n\t    //\n        }\n\n\t//\n\t// Exeption handling:\n\t//\n\t// TileBufferTask::execute() may have encountered exceptions, but\n\t// those exceptions occurred in another thread, not in the thread\n\t// that is executing this call to TiledInputFile::readTiles().\n\t// TileBufferTask::execute() has caught all exceptions and stored\n\t// the exceptions' what() strings in the tile buffers.\n\t// Now we check if any tile buffer contains a stored exception; if\n\t// this is the case then we re-throw the exception in this thread.\n\t// (It is possible that multiple tile buffers contain stored\n\t// exceptions.  We re-throw the first exception we find and\n\t// ignore all others.)\n\t//\n\n\tconst string *exception = 0;\n\n        for (size_t i = 0; i < _data->tileBuffers.size(); ++i)\n\t{\n            TileBuffer *tileBuffer = _data->tileBuffers[i];\n\n\t    if (tileBuffer->hasException && !exception)\n\t\texception = &tileBuffer->exception;\n\n\t    tileBuffer->hasException = false;\n\t}\n\n\tif (exception)\n\t    throw IEX_NAMESPACE::IoExc (*exception);\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        REPLACE_EXC (e, \"Error reading pixel data from image \"\n                     \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n}\n\n\nvoid\t\nTiledInputFile::readTiles (int dx1, int dx2, int dy1, int dy2, int l)\n{\n    readTiles (dx1, dx2, dy1, dy2, l, l);\n}\n\n\nvoid\t\nTiledInputFile::readTile (int dx, int dy, int lx, int ly)\n{\n    readTiles (dx, dx, dy, dy, lx, ly);\n}\n\n\nvoid\t\nTiledInputFile::readTile (int dx, int dy, int l)\n{\n    readTile (dx, dy, l, l);\n}\n\n\nvoid\nTiledInputFile::rawTileData (int &dx, int &dy,\n\t\t\t     int &lx, int &ly,\n                             const char *&pixelData,\n\t\t\t     int &pixelDataSize)\n{\n    try\n    {\n        Lock lock (*_data->_streamData);\n\n        if (!isValidTile (dx, dy, lx, ly))\n            throw IEX_NAMESPACE::ArgExc (\"Tried to read a tile outside \"\n\t\t\t       \"the image file's data window.\");\n\n        TileBuffer *tileBuffer = _data->getTileBuffer (0);\n\n        //\n        // if file is a multipart file, we have to seek to the required tile\n        // since we don't know where the file pointer is\n        //\n        int old_dx=dx;\n        int old_dy=dy;\n        int old_lx=lx;\n        int old_ly=ly;\n        if(isMultiPart(version()))\n        {\n            _data->_streamData->is->seekg(_data->tileOffsets(dx,dy,lx,ly));\n        }\n        readNextTileData (_data->_streamData, _data, dx, dy, lx, ly,\n\t\t\t  tileBuffer->buffer,\n                          pixelDataSize);\n        if(isMultiPart(version()))\n        {\n            if (old_dx!=dx || old_dy !=dy || old_lx!=lx || old_ly!=ly)\n            {\n                throw IEX_NAMESPACE::ArgExc (\"rawTileData read the wrong tile\");\n            }\n        }\n        else\n        {\n             if(!isValidTile (dx, dy, lx, ly) )\n             {\n                 throw IEX_NAMESPACE::IoExc (\"rawTileData read an invalid tile\");\n             }\n        }\n        pixelData = tileBuffer->buffer;\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        REPLACE_EXC (e, \"Error reading pixel data from image \"\n                     \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n}\n\n\nunsigned int\nTiledInputFile::tileXSize () const\n{\n    return _data->tileDesc.xSize;\n}\n\n\nunsigned int\nTiledInputFile::tileYSize () const\n{\n    return _data->tileDesc.ySize;\n}\n\n\nLevelMode\nTiledInputFile::levelMode () const\n{\n    return _data->tileDesc.mode;\n}\n\n\nLevelRoundingMode\nTiledInputFile::levelRoundingMode () const\n{\n    return _data->tileDesc.roundingMode;\n}\n\n\nint\nTiledInputFile::numLevels () const\n{\n    if (levelMode() == RIPMAP_LEVELS)\n\tTHROW (IEX_NAMESPACE::LogicExc, \"Error calling numLevels() on image \"\n\t\t\t      \"file \\\"\" << fileName() << \"\\\" \"\n\t\t\t      \"(numLevels() is not defined for files \"\n\t\t\t      \"with RIPMAP level mode).\");\n\n    return _data->numXLevels;\n}\n\n\nint\nTiledInputFile::numXLevels () const\n{\n    return _data->numXLevels;\n}\n\n\nint\nTiledInputFile::numYLevels () const\n{\n    return _data->numYLevels;\n}\n\n\nbool\t\nTiledInputFile::isValidLevel (int lx, int ly) const\n{\n    if (lx < 0 || ly < 0)\n\treturn false;\n\n    if (levelMode() == MIPMAP_LEVELS && lx != ly)\n\treturn false;\n\n    if (lx >= numXLevels() || ly >= numYLevels())\n\treturn false;\n\n    return true;\n}\n\n\nint\nTiledInputFile::levelWidth (int lx) const\n{\n    try\n    {\n        return levelSize (_data->minX, _data->maxX, lx,\n\t\t\t  _data->tileDesc.roundingMode);\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n\tREPLACE_EXC (e, \"Error calling levelWidth() on image \"\n                 \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n\tthrow;\n    }\n}\n\n\nint\nTiledInputFile::levelHeight (int ly) const\n{\n    try\n    {\n        return levelSize (_data->minY, _data->maxY, ly,\n                          _data->tileDesc.roundingMode);\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n\tREPLACE_EXC (e, \"Error calling levelHeight() on image \"\n                 \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n\tthrow;\n    }\n}\n\n\nint\nTiledInputFile::numXTiles (int lx) const\n{\n    if (lx < 0 || lx >= _data->numXLevels)\n    {\n        THROW (IEX_NAMESPACE::ArgExc, \"Error calling numXTiles() on image \"\n\t\t\t    \"file \\\"\" << _data->_streamData->is->fileName() << \"\\\" \"\n\t\t\t    \"(Argument is not in valid range).\");\n\n    }\n    \n    return _data->numXTiles[lx];\n}\n\n\nint\nTiledInputFile::numYTiles (int ly) const\n{\n    if (ly < 0 || ly >= _data->numYLevels)\n    {\n        THROW (IEX_NAMESPACE::ArgExc, \"Error calling numYTiles() on image \"\n\t\t\t    \"file \\\"\" << _data->_streamData->is->fileName() << \"\\\" \"\n\t\t\t    \"(Argument is not in valid range).\");\n    }\n    \n    return _data->numYTiles[ly];\n}\n\n\nBox2i\nTiledInputFile::dataWindowForLevel (int l) const\n{\n    return dataWindowForLevel (l, l);\n}\n\n\nBox2i\nTiledInputFile::dataWindowForLevel (int lx, int ly) const\n{\n    try\n    {\n\treturn OPENEXR_IMF_INTERNAL_NAMESPACE::dataWindowForLevel (\n\t        _data->tileDesc,\n\t        _data->minX, _data->maxX,\n\t        _data->minY, _data->maxY,\n\t        lx, ly);\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n\tREPLACE_EXC (e, \"Error calling dataWindowForLevel() on image \"\n                 \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n\tthrow;\n    }\n}\n\n\nBox2i\nTiledInputFile::dataWindowForTile (int dx, int dy, int l) const\n{\n    return dataWindowForTile (dx, dy, l, l);\n}\n\n\nBox2i\nTiledInputFile::dataWindowForTile (int dx, int dy, int lx, int ly) const\n{\n    try\n    {\n\tif (!isValidTile (dx, dy, lx, ly))\n\t    throw IEX_NAMESPACE::ArgExc (\"Arguments not in valid range.\");\n\n        return OPENEXR_IMF_INTERNAL_NAMESPACE::dataWindowForTile (\n                _data->tileDesc,\n                _data->minX, _data->maxX,\n                _data->minY, _data->maxY,\n                dx, dy, lx, ly);\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n\tREPLACE_EXC (e, \"Error calling dataWindowForTile() on image \"\n                 \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n\tthrow;\n    }\n}\n\n\nbool\nTiledInputFile::isValidTile (int dx, int dy, int lx, int ly) const\n{\n    return ((lx < _data->numXLevels && lx >= 0) &&\n            (ly < _data->numYLevels && ly >= 0) &&\n            (dx < _data->numXTiles[lx] && dx >= 0) &&\n            (dy < _data->numYTiles[ly] && dy >= 0));\n}\n\nvoid TiledInputFile::tileOrder(int dx[], int dy[], int lx[], int ly[]) const\n{\n   return _data->tileOffsets.getTileOrder(dx,dy,lx,ly);\n}\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT\n"], "buggy_code_start_loc": [1315], "buggy_code_end_loc": [1315], "fixing_code_start_loc": [1316], "fixing_code_end_loc": [1323], "type": "CWE-787", "message": "A head-based buffer overflow exists in Academy Software Foundation OpenEXR 2.3.0 in writeTileData in ImfTiledOutputFile.cpp that can cause a denial of service via a crafted EXR file.", "other": {"cve": {"id": "CVE-2020-16589", "sourceIdentifier": "cve@mitre.org", "published": "2020-12-09T21:15:14.977", "lastModified": "2023-02-02T18:54:45.700", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A head-based buffer overflow exists in Academy Software Foundation OpenEXR 2.3.0 in writeTileData in ImfTiledOutputFile.cpp that can cause a denial of service via a crafted EXR file."}, {"lang": "es", "value": "Se presenta un desbordamiento del b\u00fafer en la regi\u00f3n heap de la memoria en Academy Software Foundation OpenEXR versi\u00f3n 2.3.0 en la funci\u00f3n writeTileData en el archivo ImfTiledOutputFile.cpp que puede causar una denegaci\u00f3n de servicio por medio de un archivo EXR dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openexr:openexr:2.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "211E2557-6796-4695-AE6C-80D0C537B2D9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/AcademySoftwareFoundation/openexr/commit/6bb36714528a9563dd3b92720c5063a1284b86f8", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/AcademySoftwareFoundation/openexr/issues/494", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/12/msg00022.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/6bb36714528a9563dd3b92720c5063a1284b86f8"}}