{"buggy_code": ["//\n// SPDX-License-Identifier: BSD-3-Clause\n// Copyright (c) Weta Digital, Ltd and Contributors to the OpenEXR Project.\n//\n\n\n#include \"ImfCompositeDeepScanLine.h\"\n#include \"ImfDeepScanLineInputPart.h\"\n#include \"ImfDeepScanLineInputFile.h\"\n#include \"ImfChannelList.h\"\n#include \"ImfFrameBuffer.h\"\n#include \"ImfDeepFrameBuffer.h\"\n#include \"ImfDeepCompositing.h\"\n#include \"ImfPixelType.h\"\n#include \"IlmThreadPool.h\"\n\n#include <Iex.h>\n#include <vector>\n#include <stddef.h>\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\nusing std::vector;\nusing std::string;\nusing IMATH_NAMESPACE::Box2i;\nusing ILMTHREAD_NAMESPACE::Task;\nusing ILMTHREAD_NAMESPACE::TaskGroup;\nusing ILMTHREAD_NAMESPACE::ThreadPool;\n\n\n\nstruct CompositeDeepScanLine::Data{\n    public :\n    vector<DeepScanLineInputFile *>     _file;   // array of files    \n    vector<DeepScanLineInputPart *>     _part;   // array of parts \n    FrameBuffer            _outputFrameBuffer;   // output frame buffer provided\n    bool                               _zback;   // true if we are using zback (otherwise channel 1 = channel 0)\n    vector< vector<float> >      _channeldata;   // pixel values, read from the input, one array per channel\n    vector< int >               _sampleCounts;   // total per-pixel sample counts,   \n    Box2i                         _dataWindow;   // data window of combined inputs\n    DeepCompositing *                   _comp;   // user-provided compositor\n    vector<string>                  _channels;   // names of channels that will be composited\n    vector<int>                    _bufferMap;   // entry _outputFrameBuffer[n].name() == _channels[ _bufferMap[n] ].name()\n    \n    void check_valid(const Header & header);     // check newly added part/file is OK; on first good call, set _zback/_dataWindow\n\n    //\n    // set up the given deep frame buffer to contain the required channels\n    // resize counts and pointers to the width of _dataWindow\n    // zero-out all counts, since the datawindow may be smaller than/not include this part\n    //\n\n    void handleDeepFrameBuffer (DeepFrameBuffer & buf,\n                                vector<unsigned int> & counts,        //per-pixel counts\n                                vector< vector<float *> > & pointers, //per-channel-per-pixel pointers to data\n                                const Header & header,\n                                int start,\n                                int end);\n\n    Data();\n};\n\nCompositeDeepScanLine::Data::Data() : _zback(false) , _comp(NULL) {}\n\nCompositeDeepScanLine::CompositeDeepScanLine() : _Data(new Data) {}\n\nCompositeDeepScanLine::~CompositeDeepScanLine()\n{\n   delete _Data;\n}\n\nvoid\nCompositeDeepScanLine::addSource(DeepScanLineInputPart* part)\n{\n  _Data->check_valid(part->header());\n  _Data->_part.push_back(part);\n}\n\nvoid\nCompositeDeepScanLine::addSource(DeepScanLineInputFile* file)\n{\n    _Data->check_valid(file->header());\n    _Data->_file.push_back(file);\n}\n\nint \nCompositeDeepScanLine::sources() const\n{\n   return int(_Data->_part.size())+int(_Data->_file.size());\n}\n\nvoid\nCompositeDeepScanLine::Data::check_valid(const Header & header)\n{\n\n    bool has_z=false;\n    bool has_alpha=false;\n    // check good channel names\n    for( ChannelList::ConstIterator i=header.channels().begin();i!=header.channels().end();++i)\n    {\n        std::string n(i.name()); \n        if(n==\"ZBack\")\n        {\n            _zback=true;\n        }\n        else if(n==\"Z\")\n        {\n            has_z=true;\n        }\n        else if(n==\"A\")\n        {\n            has_alpha=true;\n        }\n    }\n    \n    if(!has_z)\n    {\n        throw IEX_NAMESPACE::ArgExc(\"Deep data provided to CompositeDeepScanLine is missing a Z channel\");\n    }\n    \n    if(!has_alpha)\n    {\n        throw IEX_NAMESPACE::ArgExc(\"Deep data provided to CompositeDeepScanLine is missing an alpha channel\");\n    }\n    \n    \n    if(_part.size()==0 && _file.size()==0)\n    {\n       // first in - update and return\n\n       _dataWindow = header.dataWindow();\n       \n       return;\n    }\n    \n    \n    const Header * const match_header = _part.size()>0 ? &_part[0]->header() : &_file[0]->header();\n    \n    // check the sizes match\n    if(match_header->displayWindow() != header.displayWindow())\n    {\n        throw IEX_NAMESPACE::ArgExc(\"Deep data provided to CompositeDeepScanLine has a different displayWindow to previously provided data\");\n    }\n    \n    _dataWindow.extendBy(header.dataWindow());\n    \n}\nvoid \nCompositeDeepScanLine::Data::handleDeepFrameBuffer (DeepFrameBuffer& buf,\n                                                    std::vector< unsigned int > & counts,\n                                                    vector< std::vector< float* > > & pointers,\n                                                    const Header& header,\n                                                    int start,\n                                                    int end)\n{\n    ptrdiff_t width=_dataWindow.size().x+1;\n    size_t pixelcount = width * (end-start+1);\n    pointers.resize(_channels.size());\n    counts.resize(pixelcount);\n    buf.insertSampleCountSlice (Slice (OPENEXR_IMF_INTERNAL_NAMESPACE::UINT,\n                                (char *) (&counts[0]-_dataWindow.min.x-start*width),\n                                sizeof(unsigned int),\n                                sizeof(unsigned int)*width));\n\n    pointers[0].resize(pixelcount);\n    buf.insert (\"Z\", DeepSlice (OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT,\n                                (char *)(&pointers[0][0]-_dataWindow.min.x-start*width),\n                                sizeof(float *),\n                                sizeof(float *)*width,\n                                sizeof(float) ));\n\n    if(_zback)\n    {\n        pointers[1].resize(pixelcount);\n        buf.insert (\"ZBack\", DeepSlice (OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT,\n                                        (char *)(&pointers[1][0]-_dataWindow.min.x-start*width),\n                                        sizeof(float *),\n                                        sizeof(float *)*width,\n                                        sizeof(float) ));\n    }\n\n    pointers[2].resize(pixelcount);\n    buf.insert (\"A\", DeepSlice (OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT,\n                                (char *)(&pointers[2][0]-_dataWindow.min.x-start*width),\n                                sizeof(float *),\n                                sizeof(float *)*width,\n                                sizeof(float) ));\n\n\n    size_t i =0;\n    for(FrameBuffer::ConstIterator qt  = _outputFrameBuffer.begin();\n                                   qt != _outputFrameBuffer.end();\n                                   qt++)\n    {\n        int channel_in_source = _bufferMap[i];\n        if(channel_in_source>2)\n        {\n            // not dealt with yet (0,1,2 previously inserted)\n            pointers[channel_in_source].resize(pixelcount);\n            buf.insert (qt.name(),\n                        DeepSlice (OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT,\n                                   (char *)(&pointers[channel_in_source][0]-_dataWindow.min.x-start*width),\n                                   sizeof(float *),\n                                   sizeof(float *)*width,\n                                   sizeof(float) ));\n        }\n\n        i++;\n    }\n\n}\n\nvoid\nCompositeDeepScanLine::setCompositing(DeepCompositing* c)\n{\n  _Data->_comp=c;\n}\n\nconst IMATH_NAMESPACE::Box2i& CompositeDeepScanLine::dataWindow() const\n{\n  return  _Data->_dataWindow;\n}\n\n\nvoid\nCompositeDeepScanLine::setFrameBuffer(const FrameBuffer& fr)\n{\n    \n    //\n    // count channels; build map between channels in frame buffer\n    // and channels in internal buffers\n    //\n    \n    _Data->_channels.resize(3);\n    _Data->_channels[0]=\"Z\";\n    _Data->_channels[1]=_Data->_zback ? \"ZBack\" : \"Z\";\n    _Data->_channels[2]=\"A\";\n    _Data->_bufferMap.resize(0);\n    \n    for(FrameBuffer::ConstIterator q=fr.begin();q!=fr.end();q++)\n    {\n        string name(q.name());\n        if(name==\"ZBack\")\n        {\n            _Data->_bufferMap.push_back(1);\n        }else if(name==\"Z\")\n        {\n            _Data->_bufferMap.push_back(0);\n        }else if(name==\"A\")\n        {\n            _Data->_bufferMap.push_back(2);\n        }else{\n            _Data->_bufferMap.push_back(static_cast<int>(_Data->_channels.size()));\n            _Data->_channels.push_back(name);\n        }\n    }\n    \n  _Data->_outputFrameBuffer=fr;\n}\n\nnamespace \n{\n    \nclass LineCompositeTask : public Task\n{\n  public:\n\n    LineCompositeTask ( TaskGroup* group ,\n                        CompositeDeepScanLine::Data * data,\n                    int y,\n                    int start,\n                    vector<const char*>* names,\n                    vector<vector< vector<float *> > >* pointers,\n                    vector<unsigned int>* total_sizes,\n                    vector<unsigned int>* num_sources\n                  ) : Task(group) ,\n                     _Data(data),\n                     _y(y),\n                     _start(start),\n                     _names(names),\n                     _pointers(pointers),\n                     _total_sizes(total_sizes),\n                     _num_sources(num_sources)\n                     {}\n\n    virtual ~LineCompositeTask () {}\n\n    virtual void                execute ();\n    CompositeDeepScanLine::Data*         _Data;\n    int                                  _y;\n    int                                  _start;\n    vector<const char *>*                _names;\n    vector<vector< vector<float *> > >*  _pointers;\n    vector<unsigned int>*                _total_sizes;\n    vector<unsigned int>*                _num_sources;\n\n};\n\nvoid\ncomposite_line(int y,\n               int start,\n               CompositeDeepScanLine::Data * _Data,\n               vector<const char *> & names,\n               const vector<vector< vector<float *> > >  & pointers,\n               const vector<unsigned int> & total_sizes,\n               const vector<unsigned int> & num_sources\n              )\n{\n    vector<float> output_pixel(names.size());    //the pixel we'll output to\n    vector<const float *> inputs(names.size());\n    DeepCompositing d; // fallback compositing engine\n    DeepCompositing * comp= _Data->_comp ? _Data->_comp : &d;\n\n    int pixel = (y-start)*(_Data->_dataWindow.max.x+1-_Data->_dataWindow.min.x);\n    \n     for(int x=_Data->_dataWindow.min.x;x<=_Data->_dataWindow.max.x;x++)\n     {\n           // set inputs[] to point to the first sample of the first part of each channel\n           // if there's a zback, set all channel independently...\n\n          if(_Data->_zback)\n          {\n\n              for(size_t channel=0;channel<names.size();channel++)\n              {\n                 inputs[channel]=pointers[0][channel][pixel];\n              }\n\n          }else{\n\n              // otherwise, set 0 and 1 to point to Z\n\n\n              inputs[0]=pointers[0][0][pixel];\n              inputs[1]=pointers[0][0][pixel];\n              for(size_t channel=2;channel<names.size();channel++)\n              {\n                  inputs[channel]=pointers[0][channel][pixel];\n              }\n\n          }\n          comp->composite_pixel(&output_pixel[0],\n                                &inputs[0],\n                                &names[0],\n                                static_cast<int>(names.size()),\n                                total_sizes[pixel],\n                                num_sources[pixel]\n                               );\n\n\n           size_t channel_number=0;\n\n\n           //\n           // write out composited value into internal frame buffer\n           //\n           for(FrameBuffer::Iterator it = _Data->_outputFrameBuffer.begin();it !=_Data->_outputFrameBuffer.end();it++)\n           {\n\n               float value = output_pixel[ _Data->_bufferMap[channel_number] ]; // value to write\n               intptr_t base = reinterpret_cast<intptr_t>(it.slice().base);\n\n                // cast to half float if necessary\n               if(it.slice().type==OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT)\n               {\n                   float* ptr = reinterpret_cast<float*>(base + y*it.slice().yStride + x*it.slice().xStride);\n                   *ptr  = value;\n               }\n               else if(it.slice().type==HALF)\n               {\n                   half* ptr =  reinterpret_cast<half*>(base + y*it.slice().yStride + x*it.slice().xStride);\n                   *ptr = half(value);\n               }\n\n               channel_number++;\n\n           }\n\n           pixel++;\n\n       }// next pixel on row\n}\n\nvoid LineCompositeTask::execute()\n{\n  composite_line(_y,_start,_Data,*_names,*_pointers,*_total_sizes,*_num_sources);\n}\n\n\n}\n\nvoid\nCompositeDeepScanLine::readPixels(int start, int end)\n{\n   size_t parts = _Data->_file.size() + _Data->_part.size(); // total of files+parts\n   \n   vector<DeepFrameBuffer> framebuffers(parts);\n   vector< vector<unsigned int> > counts(parts);\n   \n   //\n   // for each part, a pointer to an array of channels\n   //\n   vector<vector< vector<float *> > > pointers(parts);\n   vector<const Header *> headers(parts);\n   \n   {\n     size_t i;\n     for(i=0;i<_Data->_file.size();i++)\n     {\n         headers[i] = &_Data->_file[i]->header();\n     }\n     \n     for(size_t j=0;j<_Data->_part.size();j++)\n     {\n        headers[i+j] = &_Data->_part[j]->header();\n     }\n   }\n   \n   \n   for(size_t i=0;i<parts;i++)\n   {\n     _Data->handleDeepFrameBuffer(framebuffers[i],counts[i],pointers[i],*headers[i],start,end);\n   }\n   \n   //\n   // set frame buffers and read scanlines from all parts\n   // TODO what happens if SCANLINE not in data window?\n   //\n   \n   {\n       size_t i=0;\n       for(i=0;i<_Data->_file.size();i++)\n       {\n            _Data->_file[i]->setFrameBuffer(framebuffers[i]);\n            _Data->_file[i]->readPixelSampleCounts(start,end);\n       }\n       for(size_t j=0;j<_Data->_part.size();j++)\n       {\n           _Data->_part[j]->setFrameBuffer(framebuffers[i+j]);\n           _Data->_part[j]->readPixelSampleCounts(start,end); \n       }\n   }   \n   \n   \n   //\n   //  total width\n   //\n   \n   size_t total_width = _Data->_dataWindow.size().x+1;\n   size_t total_pixels = total_width*(end-start+1);\n   vector<unsigned int> total_sizes(total_pixels);\n   vector<unsigned int> num_sources(total_pixels); //number of parts with non-zero sample count\n   \n   size_t overall_sample_count=0; // sum of all samples in all images between start and end\n   \n   \n   //\n   // accumulate pixel counts\n   //\n   for(size_t ptr=0;ptr<total_pixels;ptr++)\n   {\n       total_sizes[ptr]=0;\n       num_sources[ptr]=0;\n       for(size_t j=0;j<parts;j++)\n       {\n          total_sizes[ptr]+=counts[j][ptr];\n          if(counts[j][ptr]>0) num_sources[ptr]++;\n       }\n       overall_sample_count+=total_sizes[ptr];\n       \n       \n       \n   }\n   \n  \n  \n   \n   //\n   // allocate arrays for pixel data\n   // samples array accessed as in pixels[channel][sample]\n   //\n   \n   vector<vector<float> > samples( _Data->_channels.size() );\n   \n   for(size_t channel=0;channel<_Data->_channels.size();channel++)\n   {\n       if( channel!=1 || _Data->_zback)\n       {            \n           samples[channel].resize(overall_sample_count);\n       }\n   }\n   \n   for(size_t channel=0;channel<samples.size();channel++)\n   {\n       \n       if( channel!=1 || _Data->_zback)\n       {\n           \n           samples[channel].resize(overall_sample_count);\n       \n       \n          //\n          // allocate pointers for channel data\n          //\n          \n          size_t offset=0;\n       \n          for(size_t pixel=0;pixel<total_pixels;pixel++)\n          {\n              for(size_t part=0 ; part<parts && offset<overall_sample_count ; part++ )\n              {\n                      pointers[part][channel][pixel]=&samples[channel][offset];           \n                      offset+=counts[part][pixel];\n              }\n          }\n       \n       }\n   }\n   \n   //\n   // read data\n   //\n   \n   for(size_t i=0;i<_Data->_file.size();i++)\n   {\n       _Data->_file[i]->readPixels(start,end);\n   }\n   for(size_t j=0;j<_Data->_part.size();j++)\n   {\n       _Data->_part[j]->readPixels(start,end); \n   }\n   \n   \n   \n   \n   //\n   // composite pixels and write back to framebuffer\n  //\n   \n   \n   // turn vector of strings into array of char *\n   // and make sure 'ZBack' channel is correct\n   vector<const char *> names(_Data->_channels.size());\n   for(size_t i=0;i<names.size();i++)\n   {\n       names[i]=_Data->_channels[i].c_str();\n   }\n   \n   if(!_Data->_zback) names[1]=names[0]; // no zback channel, so make it point to z\n\n   \n   \n   TaskGroup g;\n   for(int y=start;y<=end;y++)\n   {\n       ThreadPool::addGlobalTask(new LineCompositeTask(&g,_Data,y,start,&names,&pointers,&total_sizes,&num_sources));\n   }//next row\n}  \n\nconst FrameBuffer& \nCompositeDeepScanLine::frameBuffer() const\n{\n  return _Data->_outputFrameBuffer;\n}\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT\n"], "fixing_code": ["//\n// SPDX-License-Identifier: BSD-3-Clause\n// Copyright (c) Weta Digital, Ltd and Contributors to the OpenEXR Project.\n//\n\n\n#include \"ImfCompositeDeepScanLine.h\"\n#include \"ImfDeepScanLineInputPart.h\"\n#include \"ImfDeepScanLineInputFile.h\"\n#include \"ImfChannelList.h\"\n#include \"ImfFrameBuffer.h\"\n#include \"ImfDeepFrameBuffer.h\"\n#include \"ImfDeepCompositing.h\"\n#include \"ImfPixelType.h\"\n#include \"IlmThreadPool.h\"\n\n#include <Iex.h>\n#include <vector>\n#include <stddef.h>\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\nusing std::vector;\nusing std::string;\nusing IMATH_NAMESPACE::Box2i;\nusing ILMTHREAD_NAMESPACE::Task;\nusing ILMTHREAD_NAMESPACE::TaskGroup;\nusing ILMTHREAD_NAMESPACE::ThreadPool;\n\n\n\nstruct CompositeDeepScanLine::Data{\n    public :\n    vector<DeepScanLineInputFile *>     _file;   // array of files    \n    vector<DeepScanLineInputPart *>     _part;   // array of parts \n    FrameBuffer            _outputFrameBuffer;   // output frame buffer provided\n    bool                               _zback;   // true if we are using zback (otherwise channel 1 = channel 0)\n    vector< vector<float> >      _channeldata;   // pixel values, read from the input, one array per channel\n    vector< int >               _sampleCounts;   // total per-pixel sample counts,   \n    Box2i                         _dataWindow;   // data window of combined inputs\n    DeepCompositing *                   _comp;   // user-provided compositor\n    vector<string>                  _channels;   // names of channels that will be composited\n    vector<int>                    _bufferMap;   // entry _outputFrameBuffer[n].name() == _channels[ _bufferMap[n] ].name()\n    \n    void check_valid(const Header & header);     // check newly added part/file is OK; on first good call, set _zback/_dataWindow\n\n    //\n    // set up the given deep frame buffer to contain the required channels\n    // resize counts and pointers to the width of _dataWindow\n    // zero-out all counts, since the datawindow may be smaller than/not include this part\n    //\n\n    void handleDeepFrameBuffer (DeepFrameBuffer & buf,\n                                vector<unsigned int> & counts,        //per-pixel counts\n                                vector< vector<float *> > & pointers, //per-channel-per-pixel pointers to data\n                                const Header & header,\n                                int start,\n                                int end);\n\n    Data();\n};\n\nCompositeDeepScanLine::Data::Data() : _zback(false) , _comp(NULL) {}\n\nCompositeDeepScanLine::CompositeDeepScanLine() : _Data(new Data) {}\n\nCompositeDeepScanLine::~CompositeDeepScanLine()\n{\n   delete _Data;\n}\n\nvoid\nCompositeDeepScanLine::addSource(DeepScanLineInputPart* part)\n{\n  _Data->check_valid(part->header());\n  _Data->_part.push_back(part);\n}\n\nvoid\nCompositeDeepScanLine::addSource(DeepScanLineInputFile* file)\n{\n    _Data->check_valid(file->header());\n    _Data->_file.push_back(file);\n}\n\nint \nCompositeDeepScanLine::sources() const\n{\n   return int(_Data->_part.size())+int(_Data->_file.size());\n}\n\nvoid\nCompositeDeepScanLine::Data::check_valid(const Header & header)\n{\n\n    bool has_z=false;\n    bool has_alpha=false;\n    // check good channel names\n    for( ChannelList::ConstIterator i=header.channels().begin();i!=header.channels().end();++i)\n    {\n        std::string n(i.name()); \n        if(n==\"ZBack\")\n        {\n            _zback=true;\n        }\n        else if(n==\"Z\")\n        {\n            has_z=true;\n        }\n        else if(n==\"A\")\n        {\n            has_alpha=true;\n        }\n    }\n    \n    if(!has_z)\n    {\n        throw IEX_NAMESPACE::ArgExc(\"Deep data provided to CompositeDeepScanLine is missing a Z channel\");\n    }\n    \n    if(!has_alpha)\n    {\n        throw IEX_NAMESPACE::ArgExc(\"Deep data provided to CompositeDeepScanLine is missing an alpha channel\");\n    }\n    \n    \n    if(_part.size()==0 && _file.size()==0)\n    {\n       // first in - update and return\n\n       _dataWindow = header.dataWindow();\n       \n       return;\n    }\n    \n    \n    const Header * const match_header = _part.size()>0 ? &_part[0]->header() : &_file[0]->header();\n    \n    // check the sizes match\n    if(match_header->displayWindow() != header.displayWindow())\n    {\n        throw IEX_NAMESPACE::ArgExc(\"Deep data provided to CompositeDeepScanLine has a different displayWindow to previously provided data\");\n    }\n    \n    _dataWindow.extendBy(header.dataWindow());\n    \n}\nvoid \nCompositeDeepScanLine::Data::handleDeepFrameBuffer (DeepFrameBuffer& buf,\n                                                    std::vector< unsigned int > & counts,\n                                                    vector< std::vector< float* > > & pointers,\n                                                    const Header& header,\n                                                    int start,\n                                                    int end)\n{\n    ptrdiff_t width=_dataWindow.size().x+1;\n    size_t pixelcount = width * (end-start+1);\n    pointers.resize(_channels.size());\n    counts.resize(pixelcount);\n    buf.insertSampleCountSlice (Slice (OPENEXR_IMF_INTERNAL_NAMESPACE::UINT,\n                                (char *) (&counts[0]-_dataWindow.min.x-start*width),\n                                sizeof(unsigned int),\n                                sizeof(unsigned int)*width));\n\n    pointers[0].resize(pixelcount);\n    buf.insert (\"Z\", DeepSlice (OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT,\n                                (char *)(&pointers[0][0]-_dataWindow.min.x-start*width),\n                                sizeof(float *),\n                                sizeof(float *)*width,\n                                sizeof(float) ));\n\n    if(_zback)\n    {\n        pointers[1].resize(pixelcount);\n        buf.insert (\"ZBack\", DeepSlice (OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT,\n                                        (char *)(&pointers[1][0]-_dataWindow.min.x-start*width),\n                                        sizeof(float *),\n                                        sizeof(float *)*width,\n                                        sizeof(float) ));\n    }\n\n    pointers[2].resize(pixelcount);\n    buf.insert (\"A\", DeepSlice (OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT,\n                                (char *)(&pointers[2][0]-_dataWindow.min.x-start*width),\n                                sizeof(float *),\n                                sizeof(float *)*width,\n                                sizeof(float) ));\n\n\n    size_t i =0;\n    for(FrameBuffer::ConstIterator qt  = _outputFrameBuffer.begin();\n                                   qt != _outputFrameBuffer.end();\n                                   qt++)\n    {\n        int channel_in_source = _bufferMap[i];\n        if(channel_in_source>2)\n        {\n            // not dealt with yet (0,1,2 previously inserted)\n            pointers[channel_in_source].resize(pixelcount);\n            buf.insert (qt.name(),\n                        DeepSlice (OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT,\n                                   (char *)(&pointers[channel_in_source][0]-_dataWindow.min.x-start*width),\n                                   sizeof(float *),\n                                   sizeof(float *)*width,\n                                   sizeof(float) ));\n        }\n\n        i++;\n    }\n\n}\n\nvoid\nCompositeDeepScanLine::setCompositing(DeepCompositing* c)\n{\n  _Data->_comp=c;\n}\n\nconst IMATH_NAMESPACE::Box2i& CompositeDeepScanLine::dataWindow() const\n{\n  return  _Data->_dataWindow;\n}\n\n\nvoid\nCompositeDeepScanLine::setFrameBuffer(const FrameBuffer& fr)\n{\n    \n    //\n    // count channels; build map between channels in frame buffer\n    // and channels in internal buffers\n    //\n    \n    _Data->_channels.resize(3);\n    _Data->_channels[0]=\"Z\";\n    _Data->_channels[1]=_Data->_zback ? \"ZBack\" : \"Z\";\n    _Data->_channels[2]=\"A\";\n    _Data->_bufferMap.resize(0);\n    \n    for(FrameBuffer::ConstIterator q=fr.begin();q!=fr.end();q++)\n    {\n\n        //\n        // Frame buffer must have xSampling and ySampling set to 1\n        // (Sampling in FrameBuffers must match sampling in file,\n        //  and Header::sanityCheck enforces sampling in deep files is 1)\n        //\n\n        if(q.slice().xSampling!=1 || q.slice().ySampling!=1)\n        {\n             THROW (IEX_NAMESPACE::ArgExc, \"X and/or y subsampling factors \"\n\t\t\t\t\"of \\\"\" << q.name() << \"\\\" channel in framebuffer \"\n\t\t\t\t\"are not 1\");\n        }\n\n        string name(q.name());\n        if(name==\"ZBack\")\n        {\n            _Data->_bufferMap.push_back(1);\n        }else if(name==\"Z\")\n        {\n            _Data->_bufferMap.push_back(0);\n        }else if(name==\"A\")\n        {\n            _Data->_bufferMap.push_back(2);\n        }else{\n            _Data->_bufferMap.push_back(static_cast<int>(_Data->_channels.size()));\n            _Data->_channels.push_back(name);\n        }\n    }\n    \n  _Data->_outputFrameBuffer=fr;\n}\n\nnamespace \n{\n    \nclass LineCompositeTask : public Task\n{\n  public:\n\n    LineCompositeTask ( TaskGroup* group ,\n                        CompositeDeepScanLine::Data * data,\n                    int y,\n                    int start,\n                    vector<const char*>* names,\n                    vector<vector< vector<float *> > >* pointers,\n                    vector<unsigned int>* total_sizes,\n                    vector<unsigned int>* num_sources\n                  ) : Task(group) ,\n                     _Data(data),\n                     _y(y),\n                     _start(start),\n                     _names(names),\n                     _pointers(pointers),\n                     _total_sizes(total_sizes),\n                     _num_sources(num_sources)\n                     {}\n\n    virtual ~LineCompositeTask () {}\n\n    virtual void                execute ();\n    CompositeDeepScanLine::Data*         _Data;\n    int                                  _y;\n    int                                  _start;\n    vector<const char *>*                _names;\n    vector<vector< vector<float *> > >*  _pointers;\n    vector<unsigned int>*                _total_sizes;\n    vector<unsigned int>*                _num_sources;\n\n};\n\nvoid\ncomposite_line(int y,\n               int start,\n               CompositeDeepScanLine::Data * _Data,\n               vector<const char *> & names,\n               const vector<vector< vector<float *> > >  & pointers,\n               const vector<unsigned int> & total_sizes,\n               const vector<unsigned int> & num_sources\n              )\n{\n    vector<float> output_pixel(names.size());    //the pixel we'll output to\n    vector<const float *> inputs(names.size());\n    DeepCompositing d; // fallback compositing engine\n    DeepCompositing * comp= _Data->_comp ? _Data->_comp : &d;\n\n    int pixel = (y-start)*(_Data->_dataWindow.max.x+1-_Data->_dataWindow.min.x);\n    \n     for(int x=_Data->_dataWindow.min.x;x<=_Data->_dataWindow.max.x;x++)\n     {\n           // set inputs[] to point to the first sample of the first part of each channel\n           // if there's a zback, set all channel independently...\n\n          if(_Data->_zback)\n          {\n\n              for(size_t channel=0;channel<names.size();channel++)\n              {\n                 inputs[channel]=pointers[0][channel][pixel];\n              }\n\n          }else{\n\n              // otherwise, set 0 and 1 to point to Z\n\n\n              inputs[0]=pointers[0][0][pixel];\n              inputs[1]=pointers[0][0][pixel];\n              for(size_t channel=2;channel<names.size();channel++)\n              {\n                  inputs[channel]=pointers[0][channel][pixel];\n              }\n\n          }\n          comp->composite_pixel(&output_pixel[0],\n                                &inputs[0],\n                                &names[0],\n                                static_cast<int>(names.size()),\n                                total_sizes[pixel],\n                                num_sources[pixel]\n                               );\n\n\n           size_t channel_number=0;\n\n\n           //\n           // write out composited value into internal frame buffer\n           //\n           for(FrameBuffer::Iterator it = _Data->_outputFrameBuffer.begin();it !=_Data->_outputFrameBuffer.end();it++)\n           {\n\n               float value = output_pixel[ _Data->_bufferMap[channel_number] ]; // value to write\n               intptr_t base = reinterpret_cast<intptr_t>(it.slice().base);\n\n                // cast to half float if necessary\n               if(it.slice().type==OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT)\n               {\n                   float* ptr = reinterpret_cast<float*>(base + y*it.slice().yStride + x*it.slice().xStride);\n                   *ptr  = value;\n               }\n               else if(it.slice().type==HALF)\n               {\n                   half* ptr =  reinterpret_cast<half*>(base + y*it.slice().yStride + x*it.slice().xStride);\n                   *ptr = half(value);\n               }\n\n               channel_number++;\n\n           }\n\n           pixel++;\n\n       }// next pixel on row\n}\n\nvoid LineCompositeTask::execute()\n{\n  composite_line(_y,_start,_Data,*_names,*_pointers,*_total_sizes,*_num_sources);\n}\n\n\n}\n\nvoid\nCompositeDeepScanLine::readPixels(int start, int end)\n{\n   size_t parts = _Data->_file.size() + _Data->_part.size(); // total of files+parts\n   \n   vector<DeepFrameBuffer> framebuffers(parts);\n   vector< vector<unsigned int> > counts(parts);\n   \n   //\n   // for each part, a pointer to an array of channels\n   //\n   vector<vector< vector<float *> > > pointers(parts);\n   vector<const Header *> headers(parts);\n   \n   {\n     size_t i;\n     for(i=0;i<_Data->_file.size();i++)\n     {\n         headers[i] = &_Data->_file[i]->header();\n     }\n     \n     for(size_t j=0;j<_Data->_part.size();j++)\n     {\n        headers[i+j] = &_Data->_part[j]->header();\n     }\n   }\n   \n   \n   for(size_t i=0;i<parts;i++)\n   {\n     _Data->handleDeepFrameBuffer(framebuffers[i],counts[i],pointers[i],*headers[i],start,end);\n   }\n   \n   //\n   // set frame buffers and read scanlines from all parts\n   // TODO what happens if SCANLINE not in data window?\n   //\n   \n   {\n       size_t i=0;\n       for(i=0;i<_Data->_file.size();i++)\n       {\n            _Data->_file[i]->setFrameBuffer(framebuffers[i]);\n            _Data->_file[i]->readPixelSampleCounts(start,end);\n       }\n       for(size_t j=0;j<_Data->_part.size();j++)\n       {\n           _Data->_part[j]->setFrameBuffer(framebuffers[i+j]);\n           _Data->_part[j]->readPixelSampleCounts(start,end); \n       }\n   }   \n   \n   \n   //\n   //  total width\n   //\n   \n   size_t total_width = _Data->_dataWindow.size().x+1;\n   size_t total_pixels = total_width*(end-start+1);\n   vector<unsigned int> total_sizes(total_pixels);\n   vector<unsigned int> num_sources(total_pixels); //number of parts with non-zero sample count\n   \n   size_t overall_sample_count=0; // sum of all samples in all images between start and end\n   \n   \n   //\n   // accumulate pixel counts\n   //\n   for(size_t ptr=0;ptr<total_pixels;ptr++)\n   {\n       total_sizes[ptr]=0;\n       num_sources[ptr]=0;\n       for(size_t j=0;j<parts;j++)\n       {\n          total_sizes[ptr]+=counts[j][ptr];\n          if(counts[j][ptr]>0) num_sources[ptr]++;\n       }\n       overall_sample_count+=total_sizes[ptr];\n       \n       \n       \n   }\n   \n  \n  \n   \n   //\n   // allocate arrays for pixel data\n   // samples array accessed as in pixels[channel][sample]\n   //\n   \n   vector<vector<float> > samples( _Data->_channels.size() );\n   \n   for(size_t channel=0;channel<_Data->_channels.size();channel++)\n   {\n       if( channel!=1 || _Data->_zback)\n       {            \n           samples[channel].resize(overall_sample_count);\n       }\n   }\n   \n   for(size_t channel=0;channel<samples.size();channel++)\n   {\n       \n       if( channel!=1 || _Data->_zback)\n       {\n           \n           samples[channel].resize(overall_sample_count);\n       \n       \n          //\n          // allocate pointers for channel data\n          //\n          \n          size_t offset=0;\n       \n          for(size_t pixel=0;pixel<total_pixels;pixel++)\n          {\n              for(size_t part=0 ; part<parts && offset<overall_sample_count ; part++ )\n              {\n                      pointers[part][channel][pixel]=&samples[channel][offset];           \n                      offset+=counts[part][pixel];\n              }\n          }\n       \n       }\n   }\n   \n   //\n   // read data\n   //\n   \n   for(size_t i=0;i<_Data->_file.size();i++)\n   {\n       _Data->_file[i]->readPixels(start,end);\n   }\n   for(size_t j=0;j<_Data->_part.size();j++)\n   {\n       _Data->_part[j]->readPixels(start,end); \n   }\n   \n   \n   \n   \n   //\n   // composite pixels and write back to framebuffer\n  //\n   \n   \n   // turn vector of strings into array of char *\n   // and make sure 'ZBack' channel is correct\n   vector<const char *> names(_Data->_channels.size());\n   for(size_t i=0;i<names.size();i++)\n   {\n       names[i]=_Data->_channels[i].c_str();\n   }\n   \n   if(!_Data->_zback) names[1]=names[0]; // no zback channel, so make it point to z\n\n   \n   \n   TaskGroup g;\n   for(int y=start;y<=end;y++)\n   {\n       ThreadPool::addGlobalTask(new LineCompositeTask(&g,_Data,y,start,&names,&pointers,&total_sizes,&num_sources));\n   }//next row\n}  \n\nconst FrameBuffer& \nCompositeDeepScanLine::frameBuffer() const\n{\n  return _Data->_outputFrameBuffer;\n}\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT\n"], "buggy_code_start_loc": [240], "buggy_code_end_loc": [240], "fixing_code_start_loc": [241], "fixing_code_end_loc": [255], "type": "CWE-787", "message": "OpenEXR 3.1.x before 3.1.4 has a heap-based buffer overflow in Imf_3_1::LineCompositeTask::execute (called from IlmThread_3_1::NullThreadPoolProvider::addTask and IlmThread_3_1::ThreadPool::addGlobalTask). NOTE: db217f2 may be inapplicable.", "other": {"cve": {"id": "CVE-2021-45942", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-01T01:15:09.043", "lastModified": "2023-02-03T23:34:41.300", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenEXR 3.1.x before 3.1.4 has a heap-based buffer overflow in Imf_3_1::LineCompositeTask::execute (called from IlmThread_3_1::NullThreadPoolProvider::addTask and IlmThread_3_1::ThreadPool::addGlobalTask). NOTE: db217f2 may be inapplicable."}, {"lang": "es", "value": "OpenEXR versi\u00f3n 3.1.x anterior a la versi\u00f3n 3.1.4 tiene un desbordamiento de b\u00fafer basado en la pila en Imf_3_1::LineCompositeTask::execute (llamado desde IlmThread_3_1::NullThreadPoolProvider::addTask e IlmThread_3_1::ThreadPool::addGlobalTask). NOTA: db217f2 puede ser inaplicable"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openexr:openexr:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1.0", "versionEndExcluding": "3.1.4", "matchCriteriaId": "9AA90700-5D9F-479F-8A3E-AB4F864535BA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=41416", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/AcademySoftwareFoundation/openexr/blob/v3.1.4/CHANGES.md#version-314-january-26-2022", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/AcademySoftwareFoundation/openexr/commit/11cad77da87c4fa2aab7d58dd5339e254db7937e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/AcademySoftwareFoundation/openexr/commit/db217f29dfb24f6b4b5100c24ac5e7490e1c57d0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/AcademySoftwareFoundation/openexr/pull/1209", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/AcademySoftwareFoundation/openexr/releases/tag/v3.1.4", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/openexr/OSV-2021-1627.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/12/msg00022.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6TEZDE2S2DB4BF4LZSSV4W3DNW7DSRHJ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HJ5PW4WNXBKCRFGDZGAQOSVH2BKZKL4X/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XJUK7WIQV5EKWTCZBRXFN6INHG6MLS5O/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-31", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5299", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/11cad77da87c4fa2aab7d58dd5339e254db7937e"}}