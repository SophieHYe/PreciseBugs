{"buggy_code": ["package org.bouncycastle.tls.crypto.impl.jcajce;\n\nimport java.io.IOException;\nimport java.security.PrivateKey;\nimport java.security.SecureRandom;\nimport java.security.interfaces.RSAPrivateKey;\n\nimport javax.crypto.Cipher;\n\nimport org.bouncycastle.tls.Certificate;\nimport org.bouncycastle.tls.ProtocolVersion;\nimport org.bouncycastle.tls.TlsCredentialedDecryptor;\nimport org.bouncycastle.tls.crypto.TlsCryptoParameters;\nimport org.bouncycastle.tls.crypto.TlsSecret;\nimport org.bouncycastle.util.Arrays;\n\n/**\n * Credentialed class decrypting RSA encrypted secrets sent from a peer for our end of the TLS connection using the JCE.\n */\npublic class JceDefaultTlsCredentialedDecryptor\n    implements TlsCredentialedDecryptor\n{\n    protected JcaTlsCrypto crypto;\n    protected Certificate certificate;\n    protected PrivateKey privateKey;\n\n    public JceDefaultTlsCredentialedDecryptor(JcaTlsCrypto crypto, Certificate certificate,\n                                              PrivateKey privateKey)\n    {\n        if (crypto == null)\n        {\n            throw new IllegalArgumentException(\"'crypto' cannot be null\");\n        }\n        if (certificate == null)\n        {\n            throw new IllegalArgumentException(\"'certificate' cannot be null\");\n        }\n        if (certificate.isEmpty())\n        {\n            throw new IllegalArgumentException(\"'certificate' cannot be empty\");\n        }\n        if (privateKey == null)\n        {\n            throw new IllegalArgumentException(\"'privateKey' cannot be null\");\n        }\n\n        if (privateKey instanceof RSAPrivateKey || \"RSA\".equals(privateKey.getAlgorithm()))\n        {\n            this.crypto = crypto;\n            this.certificate = certificate;\n            this.privateKey = privateKey;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"'privateKey' type not supported: \"\n                + privateKey.getClass().getName());\n        }\n    }\n\n    public Certificate getCertificate()\n    {\n        return certificate;\n    }\n\n    public TlsSecret decrypt(TlsCryptoParameters cryptoParams, byte[] ciphertext) throws IOException\n    {\n        // TODO Keep only the decryption itself here - move error handling outside \n        return safeDecryptPreMasterSecret(cryptoParams, privateKey, ciphertext);\n    }\n\n    /*\n     * TODO[tls-ops] Probably need to make RSA encryption/decryption into TlsCrypto functions so\n     * that users can implement \"generic\" encryption credentials externally\n     */\n    protected TlsSecret safeDecryptPreMasterSecret(TlsCryptoParameters cryptoParams, PrivateKey rsaServerPrivateKey,\n                                                   byte[] encryptedPreMasterSecret)\n    {\n        SecureRandom secureRandom = crypto.getSecureRandom();\n\n        /*\n         * RFC 5246 7.4.7.1.\n         */\n        ProtocolVersion clientVersion = cryptoParams.getClientVersion();\n\n        // TODO Provide as configuration option?\n        boolean versionNumberCheckDisabled = false;\n\n        /*\n         * Generate 48 random bytes we can use as a Pre-Master-Secret, if the\n         * PKCS1 padding check should fail.\n         */\n        byte[] fallback = new byte[48];\n        secureRandom.nextBytes(fallback);\n\n        byte[] M = Arrays.clone(fallback);\n        try\n        {\n            Cipher c = crypto.createRSAEncryptionCipher();\n            c.init(Cipher.DECRYPT_MODE, rsaServerPrivateKey);\n            M = c.doFinal(encryptedPreMasterSecret);\n        }\n        catch (Exception e)\n        {\n            /*\n             * A TLS server MUST NOT generate an alert if processing an\n             * RSA-encrypted premaster secret message fails, or the version number is not as\n             * expected. Instead, it MUST continue the handshake with a randomly generated\n             * premaster secret.\n             */\n        }\n\n        /*\n         * If ClientHello.client_version is TLS 1.1 or higher, server implementations MUST\n         * check the version number [..].\n         */\n        if (versionNumberCheckDisabled && clientVersion.isEqualOrEarlierVersionOf(ProtocolVersion.TLSv10))\n        {\n            /*\n             * If the version number is TLS 1.0 or earlier, server\n             * implementations SHOULD check the version number, but MAY have a\n             * configuration option to disable the check.\n             *\n             * So there is nothing to do here.\n             */\n        }\n        else\n        {\n            /*\n             * OK, we need to compare the version number in the decrypted Pre-Master-Secret with the\n             * clientVersion received during the handshake. If they don't match, we replace the\n             * decrypted Pre-Master-Secret with a random one.\n             */\n            int correct = (clientVersion.getMajorVersion() ^ (M[0] & 0xff))\n                | (clientVersion.getMinorVersion() ^ (M[1] & 0xff));\n            correct |= correct >> 1;\n            correct |= correct >> 2;\n            correct |= correct >> 4;\n            int mask = ~((correct & 1) - 1);\n\n            /*\n             * mask will be all bits set to 0xff if the version number differed.\n             */\n            for (int i = 0; i < 48; i++)\n            {\n                M[i] = (byte)((M[i] & (~mask)) | (fallback[i] & mask));\n            }\n        }\n        return crypto.createSecret(M);\n    }\n}\n"], "fixing_code": ["package org.bouncycastle.tls.crypto.impl.jcajce;\n\nimport java.io.IOException;\nimport java.security.PrivateKey;\nimport java.security.SecureRandom;\nimport java.security.interfaces.RSAPrivateKey;\n\nimport javax.crypto.Cipher;\n\nimport org.bouncycastle.tls.Certificate;\nimport org.bouncycastle.tls.ProtocolVersion;\nimport org.bouncycastle.tls.TlsCredentialedDecryptor;\nimport org.bouncycastle.tls.crypto.TlsCryptoParameters;\nimport org.bouncycastle.tls.crypto.TlsSecret;\nimport org.bouncycastle.util.Arrays;\n\n/**\n * Credentialed class decrypting RSA encrypted secrets sent from a peer for our end of the TLS connection using the JCE.\n */\npublic class JceDefaultTlsCredentialedDecryptor\n    implements TlsCredentialedDecryptor\n{\n    protected JcaTlsCrypto crypto;\n    protected Certificate certificate;\n    protected PrivateKey privateKey;\n\n    public JceDefaultTlsCredentialedDecryptor(JcaTlsCrypto crypto, Certificate certificate,\n                                              PrivateKey privateKey)\n    {\n        if (crypto == null)\n        {\n            throw new IllegalArgumentException(\"'crypto' cannot be null\");\n        }\n        if (certificate == null)\n        {\n            throw new IllegalArgumentException(\"'certificate' cannot be null\");\n        }\n        if (certificate.isEmpty())\n        {\n            throw new IllegalArgumentException(\"'certificate' cannot be empty\");\n        }\n        if (privateKey == null)\n        {\n            throw new IllegalArgumentException(\"'privateKey' cannot be null\");\n        }\n\n        if (privateKey instanceof RSAPrivateKey || \"RSA\".equals(privateKey.getAlgorithm()))\n        {\n            this.crypto = crypto;\n            this.certificate = certificate;\n            this.privateKey = privateKey;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"'privateKey' type not supported: \"\n                + privateKey.getClass().getName());\n        }\n    }\n\n    public Certificate getCertificate()\n    {\n        return certificate;\n    }\n\n    public TlsSecret decrypt(TlsCryptoParameters cryptoParams, byte[] ciphertext) throws IOException\n    {\n        // TODO Keep only the decryption itself here - move error handling outside \n        return safeDecryptPreMasterSecret(cryptoParams, privateKey, ciphertext);\n    }\n\n    /*\n     * TODO[tls-ops] Probably need to make RSA encryption/decryption into TlsCrypto functions so\n     * that users can implement \"generic\" encryption credentials externally\n     */\n    protected TlsSecret safeDecryptPreMasterSecret(TlsCryptoParameters cryptoParams, PrivateKey rsaServerPrivateKey,\n                                                   byte[] encryptedPreMasterSecret)\n    {\n        SecureRandom secureRandom = crypto.getSecureRandom();\n\n        /*\n         * RFC 5246 7.4.7.1.\n         */\n        ProtocolVersion clientVersion = cryptoParams.getClientVersion();\n\n        // TODO Provide as configuration option?\n        boolean versionNumberCheckDisabled = false;\n\n        /*\n         * Generate 48 random bytes we can use as a Pre-Master-Secret, if the\n         * PKCS1 padding check should fail.\n         */\n        byte[] fallback = new byte[48];\n        secureRandom.nextBytes(fallback);\n\n        byte[] M = Arrays.clone(fallback);\n        try\n        {\n            Cipher c = crypto.createRSAEncryptionCipher();\n            c.init(Cipher.DECRYPT_MODE, rsaServerPrivateKey);\n            byte[] m = c.doFinal(encryptedPreMasterSecret);\n            if (m != null && m.length == 48)\n            {\n                M = m;\n            }\n        }\n        catch (Exception e)\n        {\n            /*\n             * A TLS server MUST NOT generate an alert if processing an\n             * RSA-encrypted premaster secret message fails, or the version number is not as\n             * expected. Instead, it MUST continue the handshake with a randomly generated\n             * premaster secret.\n             */\n        }\n\n        /*\n         * If ClientHello.client_version is TLS 1.1 or higher, server implementations MUST\n         * check the version number [..].\n         */\n        if (versionNumberCheckDisabled && clientVersion.isEqualOrEarlierVersionOf(ProtocolVersion.TLSv10))\n        {\n            /*\n             * If the version number is TLS 1.0 or earlier, server\n             * implementations SHOULD check the version number, but MAY have a\n             * configuration option to disable the check.\n             *\n             * So there is nothing to do here.\n             */\n        }\n        else\n        {\n            /*\n             * OK, we need to compare the version number in the decrypted Pre-Master-Secret with the\n             * clientVersion received during the handshake. If they don't match, we replace the\n             * decrypted Pre-Master-Secret with a random one.\n             */\n            int correct = (clientVersion.getMajorVersion() ^ (M[0] & 0xff))\n                | (clientVersion.getMinorVersion() ^ (M[1] & 0xff));\n            correct |= correct >> 1;\n            correct |= correct >> 2;\n            correct |= correct >> 4;\n            int mask = ~((correct & 1) - 1);\n\n            /*\n             * mask will be all bits set to 0xff if the version number differed.\n             */\n            for (int i = 0; i < 48; i++)\n            {\n                M[i] = (byte)((M[i] & (~mask)) | (fallback[i] & mask));\n            }\n        }\n        return crypto.createSecret(M);\n    }\n}\n"], "buggy_code_start_loc": [100], "buggy_code_end_loc": [101], "fixing_code_start_loc": [100], "fixing_code_end_loc": [105], "type": "CWE-203", "message": "BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\"", "other": {"cve": {"id": "CVE-2017-13098", "sourceIdentifier": "cret@cert.org", "published": "2017-12-13T01:29:00.280", "lastModified": "2020-10-20T22:15:20.170", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\""}, {"lang": "es", "value": "BouncyCastle TLS, en versiones anteriores a la 1.0.3 cuando est\u00e1 configurado para utilizar la JCE (Java Cryptography Extension) para funciones criptogr\u00e1ficas, proporciona un or\u00e1culo de Bleichenbacher d\u00e9bil cuando se negocia una suite de cifrado TLS que utiliza un intercambio de claves RSA. Un atacante puede recuperar la clave privada desde una aplicaci\u00f3n vulnerable. Esta vulnerabilidad es conocida como \"ROBOT\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "cret@cert.org", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "cret@cert.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bouncycastle:legion-of-the-bouncy-castle-java-crytography-api:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.59", "matchCriteriaId": "9B5E0326-248A-4558-B1CC-CB28FE80DCE6"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00011.html", "source": "cret@cert.org"}, {"url": "http://www.kb.cert.org/vuls/id/144389", "source": "cret@cert.org", "tags": ["Issue Tracking", "Mitigation", "Third Party Advisory", "US Government Resource"]}, {"url": "http://www.securityfocus.com/bid/102195", "source": "cret@cert.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/bcgit/bc-java/commit/a00b684465b38d722ca9a3543b8af8568e6bad5c", "source": "cret@cert.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://robotattack.org/", "source": "cret@cert.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20171222-0001/", "source": "cret@cert.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-4072", "source": "cret@cert.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "cret@cert.org"}]}, "github_commit_url": "https://github.com/bcgit/bc-java/commit/a00b684465b38d722ca9a3543b8af8568e6bad5c"}}