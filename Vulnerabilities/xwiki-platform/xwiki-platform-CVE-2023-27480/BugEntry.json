{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xar;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.stream.XMLOutputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamWriter;\n\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.apache.commons.io.input.CloseShieldInputStream;\nimport org.apache.commons.lang3.LocaleUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.internal.reference.DefaultSymbolScheme;\nimport org.xwiki.model.internal.reference.LocalStringEntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.xar.internal.XarUtils;\nimport org.xwiki.xar.internal.model.XarModel;\n\nimport javanet.staxutils.IndentingXMLStreamWriter;\n\n/**\n * Manipulate package.xml XAR package file.\n * \n * @version $Id$\n * @since 5.4RC1\n */\npublic class XarPackage\n{\n    private static final LocalStringEntityReferenceSerializer TOSTRING_SERIALIZER =\n        new LocalStringEntityReferenceSerializer(new DefaultSymbolScheme());\n\n    /**\n     * Get all entries found in a XAR file.\n     * \n     * @param file the XAR file\n     * @return the entries of the passed XAR file\n     * @throws XarException when failing to parse the XAR package\n     * @throws IOException when failing to read the file\n     */\n    public static Collection<XarEntry> getEntries(File file) throws XarException, IOException\n    {\n        XarPackage xarPackage = new XarPackage(file);\n\n        return xarPackage.getEntries();\n    }\n\n    /**\n     * @see #getPackageExtensionId()\n     */\n    private String packageExtensionId;\n\n    /**\n     * @see #isPackagePreserveVersion()\n     */\n    private boolean packagePreserveVersion = true;\n\n    /**\n     * @see #getPackageName()\n     */\n    private String packageName;\n\n    /**\n     * @see #getPackageDescription()\n     */\n    private String packageDescription;\n\n    /**\n     * @see #getPackageLicense()\n     */\n    private String packageLicense;\n\n    /**\n     * @see #getPackageAuthor()\n     */\n    private String packageAuthor;\n\n    /**\n     * @see #getPackageVersion()\n     */\n    private String packageVersion;\n\n    /**\n     * @see #isPackageBackupPack()\n     */\n    private boolean packageBackupPack;\n\n    private final Map<LocalDocumentReference, XarEntry> packageFiles = new LinkedHashMap<>();\n\n    private final Map<LocalDocumentReference, XarEntry> entries = new LinkedHashMap<>();\n\n    /**\n     * Default constructor.\n     */\n    public XarPackage()\n    {\n\n    }\n\n    /**\n     * @param zipFile the XAR file as a {@link ZipFile}\n     * @throws XarException when failing to parse the XAR package\n     * @throws IOException when failing to read the file\n     */\n    public XarPackage(ZipFile zipFile) throws XarException, IOException\n    {\n        read(zipFile);\n    }\n\n    /**\n     * @param file the XAR file\n     * @throws IOException when failing to read the file\n     * @throws XarException when failing to parse the XAR package\n     */\n    public XarPackage(File file) throws IOException, XarException\n    {\n        if (file.isDirectory()) {\n            read(file);\n        } else {\n            try (ZipFile zipFile = new ZipFile(file)) {\n                read(zipFile);\n            }\n        }\n    }\n\n    /**\n     * @param xarStream an input stream the the XAR file\n     * @throws IOException when failing to read the file\n     * @throws XarException when failing to parse the XAR package\n     */\n    public XarPackage(InputStream xarStream) throws IOException, XarException\n    {\n        read(xarStream);\n    }\n\n    /**\n     * @param entries the entries in the XAR file\n     */\n    public XarPackage(Collection<XarEntry> entries)\n    {\n        for (XarEntry entry : entries) {\n            this.entries.put(entry, entry);\n        }\n    }\n\n    /**\n     * Find and add the entries located in the passed XAR file.\n     * \n     * @param xarStream an input stream to a XAR file\n     * @throws IOException when failing to read the file\n     * @throws XarException when failing to parse the XAR package\n     */\n    public void read(InputStream xarStream) throws IOException, XarException\n    {\n        ZipArchiveInputStream zis = new ZipArchiveInputStream(xarStream, \"UTF-8\", false);\n\n        try {\n            for (ZipArchiveEntry entry = zis.getNextZipEntry(); entry != null; entry = zis.getNextZipEntry()) {\n                if (!entry.isDirectory() && zis.canReadEntryData(entry)) {\n                    readEntry(zis, entry.getName());\n                }\n            }\n        } finally {\n            zis.close();\n        }\n    }\n\n    /**\n     * Find and add the entries located in the passed XAR file.\n     * \n     * @param zipFile the XAR file\n     * @throws IOException when failing to read the file\n     * @throws XarException when failing to parse the XAR package\n     */\n    public void read(ZipFile zipFile) throws IOException, XarException\n    {\n        Enumeration<ZipArchiveEntry> zipEntries = zipFile.getEntries();\n\n        while (zipEntries.hasMoreElements()) {\n            ZipArchiveEntry entry = zipEntries.nextElement();\n\n            if (!entry.isDirectory()) {\n                InputStream stream = zipFile.getInputStream(entry);\n\n                try {\n                    readEntry(stream, entry.getName());\n                } finally {\n                    stream.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Find and add the entries located in the passed XAR directory.\n     * \n     * @param directory the expended XAR file\n     * @throws IOException when failing to read the file\n     * @throws XarException when failing to parse the XAR package\n     * @since 9.5RC1\n     */\n    public void read(File directory) throws IOException, XarException\n    {\n        String directoryName = directory.getPath();\n        directoryName += File.separator;\n\n        read(directory, directoryName);\n    }\n\n    private void read(File directory, String rootDirectory) throws IOException, XarException\n    {\n        for (File file : directory.listFiles()) {\n            if (file.isDirectory()) {\n                read(file, rootDirectory);\n            } else {\n                try (FileInputStream stream = new FileInputStream(file)) {\n                    String entryName = file.getPath();\n                    entryName = entryName.substring(rootDirectory.length(), entryName.length());\n                    readEntry(stream, entryName);\n                }\n            }\n        }\n    }\n\n    private void readEntry(InputStream stream, String entryName) throws XarException, IOException\n    {\n        if (entryName.equals(XarModel.PATH_PACKAGE)) {\n            readDescriptor(stream);\n        } else {\n            LocalDocumentReference reference = XarUtils.getReference(stream);\n\n            // Get current action associated to the document\n            int defaultAction = getDefaultAction(reference);\n            // Get current type associated to the document\n            String entryType = getEntryType(reference);\n\n            // Create entry\n            XarEntry xarEntry = new XarEntry(reference, entryName, defaultAction, entryType);\n\n            // Register entry\n            putEntry(xarEntry);\n        }\n    }\n\n    /**\n     * @return the identifier of the extension stored in the XAR package\n     */\n    public String getPackageExtensionId()\n    {\n        return this.packageExtensionId;\n    }\n\n    /**\n     * @param packageExtensionId the identifier of the extension stored in the XAR package\n     */\n    public void setPackageExtensionId(String packageExtensionId)\n    {\n        this.packageExtensionId = packageExtensionId;\n    }\n\n    /**\n     * @return true if the history should be preserved by default\n     */\n    public boolean isPackagePreserveVersion()\n    {\n        return this.packagePreserveVersion;\n    }\n\n    /**\n     * @param preserveVersion true if the history should be preserved by default\n     * @deprecated since 7.2M1, use {@link #setPackagePreserveVersion(boolean)} instead\n     */\n    @Deprecated\n    public void setPreserveVersion(boolean preserveVersion)\n    {\n        this.packagePreserveVersion = preserveVersion;\n    }\n\n    /**\n     * @param packagePreserveVersion true if the history should be preserved by default\n     */\n    public void setPackagePreserveVersion(boolean packagePreserveVersion)\n    {\n        this.packagePreserveVersion = packagePreserveVersion;\n    }\n\n    /**\n     * @return the name of the package\n     */\n    public String getPackageName()\n    {\n        return this.packageName;\n    }\n\n    /**\n     * @param packageName the name of the package\n     */\n    public void setPackageName(String packageName)\n    {\n        this.packageName = packageName;\n    }\n\n    /**\n     * @return the description of package\n     */\n    public String getPackageDescription()\n    {\n        return this.packageDescription;\n    }\n\n    /**\n     * @param packageDescription the description of package\n     */\n    public void setPackageDescription(String packageDescription)\n    {\n        this.packageDescription = packageDescription;\n    }\n\n    /**\n     * @return the license of the package\n     */\n    public String getPackageLicense()\n    {\n        return this.packageLicense;\n    }\n\n    /**\n     * @param packageLicense the license of the package\n     */\n    public void setPackageLicense(String packageLicense)\n    {\n        this.packageLicense = packageLicense;\n    }\n\n    /**\n     * @return the author of the package\n     */\n    public String getPackageAuthor()\n    {\n        return this.packageAuthor;\n    }\n\n    /**\n     * @param packageAuthor the author of the package\n     */\n    public void setPackageAuthor(String packageAuthor)\n    {\n        this.packageAuthor = packageAuthor;\n    }\n\n    /**\n     * @return the version of the package\n     */\n    public String getPackageVersion()\n    {\n        return this.packageVersion;\n    }\n\n    /**\n     * @param packageVersion the version of the package\n     */\n    public void setPackageVersion(String packageVersion)\n    {\n        this.packageVersion = packageVersion;\n    }\n\n    /**\n     * @return true of the package is a backup\n     */\n    public boolean isPackageBackupPack()\n    {\n        return this.packageBackupPack;\n    }\n\n    /**\n     * @param packageBackupPack true of the package is a backup\n     */\n    public void setPackageBackupPack(boolean packageBackupPack)\n    {\n        this.packageBackupPack = packageBackupPack;\n    }\n\n    /**\n     * @return the entries listed in the package descriptor\n     * @since 7.2M1\n     */\n    public Collection<XarEntry> getPackageFiles()\n    {\n        return this.packageFiles.values();\n    }\n\n    /**\n     * Add a new entry to the package.\n     * \n     * @param reference the entry reference since 7.2M1\n     * @param action the default action associated to this XAR (not used at the moment)\n     */\n    public void addPackageFile(LocalDocumentReference reference, int action)\n    {\n        this.packageFiles.put(reference, new XarEntry(reference, null, action));\n    }\n\n    /**\n     * Add a new entry to the package.\n     * \n     * @param reference the entry reference\n     * @deprecated since 7.2M1, use {@link #addPackageFile(LocalDocumentReference, int)} instead\n     */\n    @Deprecated\n    public void addEntry(LocalDocumentReference reference)\n    {\n        addEntry(reference, null);\n    }\n\n    /**\n     * Add a new entry to the package.\n     * \n     * @param reference the entry reference\n     * @param entryName the name of the entry (ZIP style)\n     * @since 7.2M1\n     */\n    public void addEntry(LocalDocumentReference reference, String entryName)\n    {\n        addEntry(reference, entryName, XarModel.ACTION_OVERWRITE);\n    }\n\n    /**\n     * Add a new entry to the package.\n     * \n     * @param reference the entry reference\n     * @param entryName the name of the entry (ZIP style)\n     * @param action the default action associated to this XAR (not used at the moment)\n     * @since 7.2M1\n     */\n    public void addEntry(LocalDocumentReference reference, String entryName, int action)\n    {\n        XarEntry entry = new XarEntry(reference, entryName, action);\n\n        putEntry(entry);\n    }\n\n    private void putEntry(XarEntry entry)\n    {\n        this.entries.put(entry, entry);\n        this.packageFiles.put(entry, entry);\n    }\n\n    /**\n     * @return the entries of the package\n     */\n    public Collection<XarEntry> getEntries()\n    {\n        return this.entries.values();\n    }\n\n    /**\n     * @param reference the reference of the document\n     * @return the entry associated to the passage reference\n     */\n    public XarEntry getEntry(LocalDocumentReference reference)\n    {\n        return this.entries.get(reference);\n    }\n\n    /**\n     * Read a XML descriptor of a XAR package (usually names package.xml).\n     * \n     * @param stream the input stream to the XML file to parse\n     * @throws XarException when failing to parse the descriptor\n     * @throws IOException when failing to read the file\n     */\n    public void readDescriptor(InputStream stream) throws XarException, IOException\n    {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n\n        DocumentBuilder dBuilder;\n        try {\n            dBuilder = dbFactory.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            throw new XarException(\"Failed to create a new Document builder\", e);\n        }\n\n        Document doc;\n        try {\n            // DocumentBuilder#parse close the passed stream which is not what we want\n            doc = dBuilder.parse(new CloseShieldInputStream(stream));\n        } catch (SAXException e) {\n            throw new XarException(\"Failed to parse XML document\", e);\n        }\n\n        // Normalize the document\n        doc.getDocumentElement().normalize();\n\n        // Read the document\n        NodeList children = doc.getChildNodes();\n        for (int i = 0; i < children.getLength(); ++i) {\n            Node node = children.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element element = (Element) node;\n                if (element.getTagName().equals(XarModel.ELEMENT_PACKAGE)) {\n                    readDescriptorPackage(element);\n                    break;\n                }\n            }\n        }\n    }\n\n    private void readDescriptorPackage(Element packageElement)\n    {\n        NodeList children = packageElement.getChildNodes();\n        for (int i = 0; i < children.getLength(); ++i) {\n            Node node = children.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element element = (Element) node;\n                if (element.getTagName().equals(XarModel.ELEMENT_INFOS)) {\n                    readDescriptorInfos(element);\n                } else if (element.getTagName().equals(XarModel.ELEMENT_FILES)) {\n                    readDescriptorFiles(element);\n                }\n            }\n        }\n    }\n\n    private void readDescriptorInfos(Element infos)\n    {\n        this.packageExtensionId = getElementText(infos, XarModel.ELEMENT_INFOS_EXTENSIONID, true);\n        this.packageVersion = getElementText(infos, XarModel.ELEMENT_INFOS_VERSION, false);\n        this.packageName = getElementText(infos, XarModel.ELEMENT_INFOS_NAME, false);\n        this.packageDescription = getElementText(infos, XarModel.ELEMENT_INFOS_DESCRIPTION, false);\n        this.packageLicense = getElementText(infos, XarModel.ELEMENT_INFOS_LICENSE, false);\n        this.packageAuthor = getElementText(infos, XarModel.ELEMENT_INFOS_AUTHOR, false);\n        this.packageBackupPack =\n            Boolean.parseBoolean(getElementText(infos, XarModel.ELEMENT_INFOS_ISBACKUPPACK, false));\n        this.packagePreserveVersion =\n            Boolean.parseBoolean(getElementText(infos, XarModel.ELEMENT_INFOS_ISPRESERVEVERSION, false));\n    }\n\n    private void readDescriptorFiles(Element files)\n    {\n        NodeList children = files.getChildNodes();\n        for (int i = 0; i < children.getLength(); ++i) {\n            Node node = children.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element element = (Element) node;\n                if (element.getTagName().equals(XarModel.ELEMENT_FILES_FILE)) {\n                    String localeString = element.getAttribute(XarModel.ATTRIBUTE_LOCALE);\n                    String defaultActionString = getAttribute(element, XarModel.ATTRIBUTE_DEFAULTACTION);\n                    String entryType = getAttribute(element, XarModel.ATTRIBUTE_TYPE);\n                    String referenceString = element.getTextContent();\n\n                    // Parse reference\n                    LocalDocumentReference reference =\n                        new LocalDocumentReference(XarUtils.RESOLVER.resolve(referenceString, EntityType.DOCUMENT),\n                            LocaleUtils.toLocale(localeString));\n\n                    // Parse default action\n                    int defaultAction =\n                        defaultActionString != null ? Integer.parseInt(defaultActionString) : XarModel.ACTION_OVERWRITE;\n\n                    // Get entry name associated to the document\n                    String entryName = getEntryName(reference);\n\n                    // Create entry\n                    XarEntry packageFile = new XarEntry(reference, entryName, defaultAction, entryType);\n\n                    // Register package file entry\n                    this.packageFiles.put(packageFile, packageFile);\n\n                    // Update existing entry default action\n                    updateEntry(packageFile);\n                }\n            }\n        }\n    }\n\n    private String getAttribute(Element element, String attributeName)\n    {\n        Attr attrribute = element.getAttributeNode(attributeName);\n\n        return attrribute != null ? attrribute.getValue() : null;\n    }\n\n    private String getEntryName(LocalDocumentReference reference)\n    {\n        String entryName = null;\n\n        XarEntry entry = this.entries.get(reference);\n        if (entry != null) {\n            entryName = entry.getEntryName();\n        }\n\n        return entryName;\n    }\n\n    private int getDefaultAction(LocalDocumentReference reference)\n    {\n        int defaultAction = XarModel.ACTION_SKIP;\n\n        XarEntry packageFile = this.packageFiles.get(reference);\n        if (packageFile != null) {\n            defaultAction = packageFile.getDefaultAction();\n        }\n\n        return defaultAction;\n    }\n\n    private String getEntryType(LocalDocumentReference reference)\n    {\n        String entryType = null;\n\n        XarEntry packageFile = this.packageFiles.get(reference);\n        if (packageFile != null) {\n            entryType = packageFile.getEntryType();\n        }\n\n        return entryType;\n    }\n\n    private void updateEntry(XarEntry packageFile)\n    {\n        if (this.entries.containsKey(packageFile)) {\n            this.entries.put(packageFile, packageFile);\n        }\n    }\n\n    private String getElementText(Element element, String tagName, boolean ignoreEmpty)\n    {\n        NodeList nList = element.getElementsByTagName(tagName);\n\n        String value = nList.getLength() > 0 ? nList.item(0).getTextContent() : null;\n\n        if (value != null && ignoreEmpty && StringUtils.isEmpty(value)) {\n            value = null;\n        }\n\n        return value;\n    }\n\n    /**\n     * Write and add the package descriptor to the passed ZIP stream.\n     * \n     * @param zipStream the ZIP stream in which to write\n     * @param encoding the encoding to use to write the descriptor\n     * @throws XarException when failing to parse the descriptor\n     * @throws IOException when failing to read the file\n     */\n    public void write(ZipArchiveOutputStream zipStream, String encoding) throws XarException, IOException\n    {\n        ZipArchiveEntry zipentry = new ZipArchiveEntry(XarModel.PATH_PACKAGE);\n        zipStream.putArchiveEntry(zipentry);\n\n        try {\n            write((OutputStream) zipStream, encoding);\n        } finally {\n            zipStream.closeArchiveEntry();\n        }\n    }\n\n    /**\n     * Write the package descriptor to the passed stream as XML.\n     * \n     * @param stream the stream to the resulting XML file\n     * @param encoding the encoding to use to write the descriptor\n     * @throws XarException when failing to parse the descriptor\n     */\n    public void write(OutputStream stream, String encoding) throws XarException\n    {\n        XMLStreamWriter writer;\n        try {\n            writer = XMLOutputFactory.newInstance().createXMLStreamWriter(stream, encoding);\n        } catch (Exception e) {\n            throw new XarException(\"Failed to create an instance of XML stream writer\", e);\n        }\n\n        writer = new IndentingXMLStreamWriter(writer);\n\n        try {\n            writer.writeStartDocument(encoding, \"1.0\");\n            write(writer);\n            writer.writeEndDocument();\n\n            writer.flush();\n        } catch (Exception e) {\n            throw new XarException(\"Failed to write XML\", e);\n        } finally {\n            try {\n                writer.close();\n            } catch (XMLStreamException e) {\n                throw new XarException(\"Failed to close XML writer\", e);\n            }\n        }\n    }\n\n    /**\n     * Write the package descriptor to the passed XML stream.\n     * \n     * @param writer the XML stream where to write\n     * @throws XMLStreamException when failing to write the file\n     */\n    public void write(XMLStreamWriter writer) throws XMLStreamException\n    {\n        writer.writeStartElement(XarModel.ELEMENT_PACKAGE);\n\n        writer.writeStartElement(XarModel.ELEMENT_INFOS);\n        writeElement(writer, XarModel.ELEMENT_INFOS_NAME, getPackageName(), true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_DESCRIPTION, getPackageDescription(), true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_LICENSE, getPackageLicense(), true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_AUTHOR, getPackageAuthor(), true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_VERSION, getPackageVersion(), true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_ISBACKUPPACK, String.valueOf(isPackageBackupPack()), true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_ISPRESERVEVERSION, String.valueOf(isPackagePreserveVersion()),\n            true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_EXTENSIONID, getPackageExtensionId(), false);\n        writer.writeEndElement();\n\n        writer.writeStartElement(XarModel.ELEMENT_FILES);\n        for (XarEntry entry : this.entries.values()) {\n            writer.writeStartElement(XarModel.ELEMENT_FILES_FILE);\n\n            writer.writeAttribute(XarModel.ATTRIBUTE_DEFAULTACTION, String.valueOf(entry.getDefaultAction()));\n            writer.writeAttribute(XarModel.ATTRIBUTE_LOCALE, Objects.toString(entry.getLocale(), \"\"));\n            if (entry.getEntryType() != null) {\n                writer.writeAttribute(XarModel.ATTRIBUTE_TYPE, entry.getEntryType());\n            }\n\n            writer.writeCharacters(TOSTRING_SERIALIZER.serialize(entry));\n\n            writer.writeEndElement();\n        }\n        writer.writeEndElement();\n    }\n\n    private void writeElement(XMLStreamWriter streamWriter, String localName, String value, boolean emptyIfNull)\n        throws XMLStreamException\n    {\n        if (value != null) {\n            if (value.isEmpty()) {\n                streamWriter.writeEmptyElement(localName);\n            } else {\n                streamWriter.writeStartElement(localName);\n                streamWriter.writeCharacters(value);\n                streamWriter.writeEndElement();\n            }\n        } else if (emptyIfNull) {\n            streamWriter.writeEmptyElement(localName);\n        }\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xar;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.stream.XMLOutputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamWriter;\n\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.apache.commons.io.input.CloseShieldInputStream;\nimport org.apache.commons.lang3.LocaleUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.internal.reference.DefaultSymbolScheme;\nimport org.xwiki.model.internal.reference.LocalStringEntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.xar.internal.XarUtils;\nimport org.xwiki.xar.internal.model.XarModel;\n\nimport javanet.staxutils.IndentingXMLStreamWriter;\n\n/**\n * Manipulate package.xml XAR package file.\n * \n * @version $Id$\n * @since 5.4RC1\n */\npublic class XarPackage\n{\n    private static final LocalStringEntityReferenceSerializer TOSTRING_SERIALIZER =\n        new LocalStringEntityReferenceSerializer(new DefaultSymbolScheme());\n\n    /**\n     * Get all entries found in a XAR file.\n     * \n     * @param file the XAR file\n     * @return the entries of the passed XAR file\n     * @throws XarException when failing to parse the XAR package\n     * @throws IOException when failing to read the file\n     */\n    public static Collection<XarEntry> getEntries(File file) throws XarException, IOException\n    {\n        XarPackage xarPackage = new XarPackage(file);\n\n        return xarPackage.getEntries();\n    }\n\n    /**\n     * @see #getPackageExtensionId()\n     */\n    private String packageExtensionId;\n\n    /**\n     * @see #isPackagePreserveVersion()\n     */\n    private boolean packagePreserveVersion = true;\n\n    /**\n     * @see #getPackageName()\n     */\n    private String packageName;\n\n    /**\n     * @see #getPackageDescription()\n     */\n    private String packageDescription;\n\n    /**\n     * @see #getPackageLicense()\n     */\n    private String packageLicense;\n\n    /**\n     * @see #getPackageAuthor()\n     */\n    private String packageAuthor;\n\n    /**\n     * @see #getPackageVersion()\n     */\n    private String packageVersion;\n\n    /**\n     * @see #isPackageBackupPack()\n     */\n    private boolean packageBackupPack;\n\n    private final Map<LocalDocumentReference, XarEntry> packageFiles = new LinkedHashMap<>();\n\n    private final Map<LocalDocumentReference, XarEntry> entries = new LinkedHashMap<>();\n\n    /**\n     * Default constructor.\n     */\n    public XarPackage()\n    {\n\n    }\n\n    /**\n     * @param zipFile the XAR file as a {@link ZipFile}\n     * @throws XarException when failing to parse the XAR package\n     * @throws IOException when failing to read the file\n     */\n    public XarPackage(ZipFile zipFile) throws XarException, IOException\n    {\n        read(zipFile);\n    }\n\n    /**\n     * @param file the XAR file\n     * @throws IOException when failing to read the file\n     * @throws XarException when failing to parse the XAR package\n     */\n    public XarPackage(File file) throws IOException, XarException\n    {\n        if (file.isDirectory()) {\n            read(file);\n        } else {\n            try (ZipFile zipFile = new ZipFile(file)) {\n                read(zipFile);\n            }\n        }\n    }\n\n    /**\n     * @param xarStream an input stream the the XAR file\n     * @throws IOException when failing to read the file\n     * @throws XarException when failing to parse the XAR package\n     */\n    public XarPackage(InputStream xarStream) throws IOException, XarException\n    {\n        read(xarStream);\n    }\n\n    /**\n     * @param entries the entries in the XAR file\n     */\n    public XarPackage(Collection<XarEntry> entries)\n    {\n        for (XarEntry entry : entries) {\n            this.entries.put(entry, entry);\n        }\n    }\n\n    /**\n     * Find and add the entries located in the passed XAR file.\n     * \n     * @param xarStream an input stream to a XAR file\n     * @throws IOException when failing to read the file\n     * @throws XarException when failing to parse the XAR package\n     */\n    public void read(InputStream xarStream) throws IOException, XarException\n    {\n        ZipArchiveInputStream zis = new ZipArchiveInputStream(xarStream, \"UTF-8\", false);\n\n        try {\n            for (ZipArchiveEntry entry = zis.getNextZipEntry(); entry != null; entry = zis.getNextZipEntry()) {\n                if (!entry.isDirectory() && zis.canReadEntryData(entry)) {\n                    readEntry(zis, entry.getName());\n                }\n            }\n        } finally {\n            zis.close();\n        }\n    }\n\n    /**\n     * Find and add the entries located in the passed XAR file.\n     * \n     * @param zipFile the XAR file\n     * @throws IOException when failing to read the file\n     * @throws XarException when failing to parse the XAR package\n     */\n    public void read(ZipFile zipFile) throws IOException, XarException\n    {\n        Enumeration<ZipArchiveEntry> zipEntries = zipFile.getEntries();\n\n        while (zipEntries.hasMoreElements()) {\n            ZipArchiveEntry entry = zipEntries.nextElement();\n\n            if (!entry.isDirectory()) {\n                InputStream stream = zipFile.getInputStream(entry);\n\n                try {\n                    readEntry(stream, entry.getName());\n                } finally {\n                    stream.close();\n                }\n            }\n        }\n    }\n\n    /**\n     * Find and add the entries located in the passed XAR directory.\n     * \n     * @param directory the expended XAR file\n     * @throws IOException when failing to read the file\n     * @throws XarException when failing to parse the XAR package\n     * @since 9.5RC1\n     */\n    public void read(File directory) throws IOException, XarException\n    {\n        String directoryName = directory.getPath();\n        directoryName += File.separator;\n\n        read(directory, directoryName);\n    }\n\n    private void read(File directory, String rootDirectory) throws IOException, XarException\n    {\n        for (File file : directory.listFiles()) {\n            if (file.isDirectory()) {\n                read(file, rootDirectory);\n            } else {\n                try (FileInputStream stream = new FileInputStream(file)) {\n                    String entryName = file.getPath();\n                    entryName = entryName.substring(rootDirectory.length(), entryName.length());\n                    readEntry(stream, entryName);\n                }\n            }\n        }\n    }\n\n    private void readEntry(InputStream stream, String entryName) throws XarException, IOException\n    {\n        if (entryName.equals(XarModel.PATH_PACKAGE)) {\n            readDescriptor(stream);\n        } else {\n            LocalDocumentReference reference = XarUtils.getReference(stream);\n\n            // Get current action associated to the document\n            int defaultAction = getDefaultAction(reference);\n            // Get current type associated to the document\n            String entryType = getEntryType(reference);\n\n            // Create entry\n            XarEntry xarEntry = new XarEntry(reference, entryName, defaultAction, entryType);\n\n            // Register entry\n            putEntry(xarEntry);\n        }\n    }\n\n    /**\n     * @return the identifier of the extension stored in the XAR package\n     */\n    public String getPackageExtensionId()\n    {\n        return this.packageExtensionId;\n    }\n\n    /**\n     * @param packageExtensionId the identifier of the extension stored in the XAR package\n     */\n    public void setPackageExtensionId(String packageExtensionId)\n    {\n        this.packageExtensionId = packageExtensionId;\n    }\n\n    /**\n     * @return true if the history should be preserved by default\n     */\n    public boolean isPackagePreserveVersion()\n    {\n        return this.packagePreserveVersion;\n    }\n\n    /**\n     * @param preserveVersion true if the history should be preserved by default\n     * @deprecated since 7.2M1, use {@link #setPackagePreserveVersion(boolean)} instead\n     */\n    @Deprecated\n    public void setPreserveVersion(boolean preserveVersion)\n    {\n        this.packagePreserveVersion = preserveVersion;\n    }\n\n    /**\n     * @param packagePreserveVersion true if the history should be preserved by default\n     */\n    public void setPackagePreserveVersion(boolean packagePreserveVersion)\n    {\n        this.packagePreserveVersion = packagePreserveVersion;\n    }\n\n    /**\n     * @return the name of the package\n     */\n    public String getPackageName()\n    {\n        return this.packageName;\n    }\n\n    /**\n     * @param packageName the name of the package\n     */\n    public void setPackageName(String packageName)\n    {\n        this.packageName = packageName;\n    }\n\n    /**\n     * @return the description of package\n     */\n    public String getPackageDescription()\n    {\n        return this.packageDescription;\n    }\n\n    /**\n     * @param packageDescription the description of package\n     */\n    public void setPackageDescription(String packageDescription)\n    {\n        this.packageDescription = packageDescription;\n    }\n\n    /**\n     * @return the license of the package\n     */\n    public String getPackageLicense()\n    {\n        return this.packageLicense;\n    }\n\n    /**\n     * @param packageLicense the license of the package\n     */\n    public void setPackageLicense(String packageLicense)\n    {\n        this.packageLicense = packageLicense;\n    }\n\n    /**\n     * @return the author of the package\n     */\n    public String getPackageAuthor()\n    {\n        return this.packageAuthor;\n    }\n\n    /**\n     * @param packageAuthor the author of the package\n     */\n    public void setPackageAuthor(String packageAuthor)\n    {\n        this.packageAuthor = packageAuthor;\n    }\n\n    /**\n     * @return the version of the package\n     */\n    public String getPackageVersion()\n    {\n        return this.packageVersion;\n    }\n\n    /**\n     * @param packageVersion the version of the package\n     */\n    public void setPackageVersion(String packageVersion)\n    {\n        this.packageVersion = packageVersion;\n    }\n\n    /**\n     * @return true of the package is a backup\n     */\n    public boolean isPackageBackupPack()\n    {\n        return this.packageBackupPack;\n    }\n\n    /**\n     * @param packageBackupPack true of the package is a backup\n     */\n    public void setPackageBackupPack(boolean packageBackupPack)\n    {\n        this.packageBackupPack = packageBackupPack;\n    }\n\n    /**\n     * @return the entries listed in the package descriptor\n     * @since 7.2M1\n     */\n    public Collection<XarEntry> getPackageFiles()\n    {\n        return this.packageFiles.values();\n    }\n\n    /**\n     * Add a new entry to the package.\n     * \n     * @param reference the entry reference since 7.2M1\n     * @param action the default action associated to this XAR (not used at the moment)\n     */\n    public void addPackageFile(LocalDocumentReference reference, int action)\n    {\n        this.packageFiles.put(reference, new XarEntry(reference, null, action));\n    }\n\n    /**\n     * Add a new entry to the package.\n     * \n     * @param reference the entry reference\n     * @deprecated since 7.2M1, use {@link #addPackageFile(LocalDocumentReference, int)} instead\n     */\n    @Deprecated\n    public void addEntry(LocalDocumentReference reference)\n    {\n        addEntry(reference, null);\n    }\n\n    /**\n     * Add a new entry to the package.\n     * \n     * @param reference the entry reference\n     * @param entryName the name of the entry (ZIP style)\n     * @since 7.2M1\n     */\n    public void addEntry(LocalDocumentReference reference, String entryName)\n    {\n        addEntry(reference, entryName, XarModel.ACTION_OVERWRITE);\n    }\n\n    /**\n     * Add a new entry to the package.\n     * \n     * @param reference the entry reference\n     * @param entryName the name of the entry (ZIP style)\n     * @param action the default action associated to this XAR (not used at the moment)\n     * @since 7.2M1\n     */\n    public void addEntry(LocalDocumentReference reference, String entryName, int action)\n    {\n        XarEntry entry = new XarEntry(reference, entryName, action);\n\n        putEntry(entry);\n    }\n\n    private void putEntry(XarEntry entry)\n    {\n        this.entries.put(entry, entry);\n        this.packageFiles.put(entry, entry);\n    }\n\n    /**\n     * @return the entries of the package\n     */\n    public Collection<XarEntry> getEntries()\n    {\n        return this.entries.values();\n    }\n\n    /**\n     * @param reference the reference of the document\n     * @return the entry associated to the passage reference\n     */\n    public XarEntry getEntry(LocalDocumentReference reference)\n    {\n        return this.entries.get(reference);\n    }\n\n    /**\n     * Read a XML descriptor of a XAR package (usually names package.xml).\n     * \n     * @param stream the input stream to the XML file to parse\n     * @throws XarException when failing to parse the descriptor\n     * @throws IOException when failing to read the file\n     */\n    public void readDescriptor(InputStream stream) throws XarException, IOException\n    {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n\n        DocumentBuilder dBuilder;\n        try {\n            // Prevent XXE attack\n            dbFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dBuilder = dbFactory.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            throw new XarException(\"Failed to create a new Document builder\", e);\n        }\n\n        Document doc;\n        try {\n            // DocumentBuilder#parse close the passed stream which is not what we want\n            doc = dBuilder.parse(new CloseShieldInputStream(stream));\n        } catch (SAXException e) {\n            throw new XarException(\"Failed to parse XML document\", e);\n        }\n\n        // Normalize the document\n        doc.getDocumentElement().normalize();\n\n        // Read the document\n        NodeList children = doc.getChildNodes();\n        for (int i = 0; i < children.getLength(); ++i) {\n            Node node = children.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element element = (Element) node;\n                if (element.getTagName().equals(XarModel.ELEMENT_PACKAGE)) {\n                    readDescriptorPackage(element);\n                    break;\n                }\n            }\n        }\n    }\n\n    private void readDescriptorPackage(Element packageElement)\n    {\n        NodeList children = packageElement.getChildNodes();\n        for (int i = 0; i < children.getLength(); ++i) {\n            Node node = children.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element element = (Element) node;\n                if (element.getTagName().equals(XarModel.ELEMENT_INFOS)) {\n                    readDescriptorInfos(element);\n                } else if (element.getTagName().equals(XarModel.ELEMENT_FILES)) {\n                    readDescriptorFiles(element);\n                }\n            }\n        }\n    }\n\n    private void readDescriptorInfos(Element infos)\n    {\n        this.packageExtensionId = getElementText(infos, XarModel.ELEMENT_INFOS_EXTENSIONID, true);\n        this.packageVersion = getElementText(infos, XarModel.ELEMENT_INFOS_VERSION, false);\n        this.packageName = getElementText(infos, XarModel.ELEMENT_INFOS_NAME, false);\n        this.packageDescription = getElementText(infos, XarModel.ELEMENT_INFOS_DESCRIPTION, false);\n        this.packageLicense = getElementText(infos, XarModel.ELEMENT_INFOS_LICENSE, false);\n        this.packageAuthor = getElementText(infos, XarModel.ELEMENT_INFOS_AUTHOR, false);\n        this.packageBackupPack =\n            Boolean.parseBoolean(getElementText(infos, XarModel.ELEMENT_INFOS_ISBACKUPPACK, false));\n        this.packagePreserveVersion =\n            Boolean.parseBoolean(getElementText(infos, XarModel.ELEMENT_INFOS_ISPRESERVEVERSION, false));\n    }\n\n    private void readDescriptorFiles(Element files)\n    {\n        NodeList children = files.getChildNodes();\n        for (int i = 0; i < children.getLength(); ++i) {\n            Node node = children.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element element = (Element) node;\n                if (element.getTagName().equals(XarModel.ELEMENT_FILES_FILE)) {\n                    String localeString = element.getAttribute(XarModel.ATTRIBUTE_LOCALE);\n                    String defaultActionString = getAttribute(element, XarModel.ATTRIBUTE_DEFAULTACTION);\n                    String entryType = getAttribute(element, XarModel.ATTRIBUTE_TYPE);\n                    String referenceString = element.getTextContent();\n\n                    // Parse reference\n                    LocalDocumentReference reference =\n                        new LocalDocumentReference(XarUtils.RESOLVER.resolve(referenceString, EntityType.DOCUMENT),\n                            LocaleUtils.toLocale(localeString));\n\n                    // Parse default action\n                    int defaultAction =\n                        defaultActionString != null ? Integer.parseInt(defaultActionString) : XarModel.ACTION_OVERWRITE;\n\n                    // Get entry name associated to the document\n                    String entryName = getEntryName(reference);\n\n                    // Create entry\n                    XarEntry packageFile = new XarEntry(reference, entryName, defaultAction, entryType);\n\n                    // Register package file entry\n                    this.packageFiles.put(packageFile, packageFile);\n\n                    // Update existing entry default action\n                    updateEntry(packageFile);\n                }\n            }\n        }\n    }\n\n    private String getAttribute(Element element, String attributeName)\n    {\n        Attr attrribute = element.getAttributeNode(attributeName);\n\n        return attrribute != null ? attrribute.getValue() : null;\n    }\n\n    private String getEntryName(LocalDocumentReference reference)\n    {\n        String entryName = null;\n\n        XarEntry entry = this.entries.get(reference);\n        if (entry != null) {\n            entryName = entry.getEntryName();\n        }\n\n        return entryName;\n    }\n\n    private int getDefaultAction(LocalDocumentReference reference)\n    {\n        int defaultAction = XarModel.ACTION_SKIP;\n\n        XarEntry packageFile = this.packageFiles.get(reference);\n        if (packageFile != null) {\n            defaultAction = packageFile.getDefaultAction();\n        }\n\n        return defaultAction;\n    }\n\n    private String getEntryType(LocalDocumentReference reference)\n    {\n        String entryType = null;\n\n        XarEntry packageFile = this.packageFiles.get(reference);\n        if (packageFile != null) {\n            entryType = packageFile.getEntryType();\n        }\n\n        return entryType;\n    }\n\n    private void updateEntry(XarEntry packageFile)\n    {\n        if (this.entries.containsKey(packageFile)) {\n            this.entries.put(packageFile, packageFile);\n        }\n    }\n\n    private String getElementText(Element element, String tagName, boolean ignoreEmpty)\n    {\n        NodeList nList = element.getElementsByTagName(tagName);\n\n        String value = nList.getLength() > 0 ? nList.item(0).getTextContent() : null;\n\n        if (value != null && ignoreEmpty && StringUtils.isEmpty(value)) {\n            value = null;\n        }\n\n        return value;\n    }\n\n    /**\n     * Write and add the package descriptor to the passed ZIP stream.\n     * \n     * @param zipStream the ZIP stream in which to write\n     * @param encoding the encoding to use to write the descriptor\n     * @throws XarException when failing to parse the descriptor\n     * @throws IOException when failing to read the file\n     */\n    public void write(ZipArchiveOutputStream zipStream, String encoding) throws XarException, IOException\n    {\n        ZipArchiveEntry zipentry = new ZipArchiveEntry(XarModel.PATH_PACKAGE);\n        zipStream.putArchiveEntry(zipentry);\n\n        try {\n            write((OutputStream) zipStream, encoding);\n        } finally {\n            zipStream.closeArchiveEntry();\n        }\n    }\n\n    /**\n     * Write the package descriptor to the passed stream as XML.\n     * \n     * @param stream the stream to the resulting XML file\n     * @param encoding the encoding to use to write the descriptor\n     * @throws XarException when failing to parse the descriptor\n     */\n    public void write(OutputStream stream, String encoding) throws XarException\n    {\n        XMLStreamWriter writer;\n        try {\n            writer = XMLOutputFactory.newInstance().createXMLStreamWriter(stream, encoding);\n        } catch (Exception e) {\n            throw new XarException(\"Failed to create an instance of XML stream writer\", e);\n        }\n\n        writer = new IndentingXMLStreamWriter(writer);\n\n        try {\n            writer.writeStartDocument(encoding, \"1.0\");\n            write(writer);\n            writer.writeEndDocument();\n\n            writer.flush();\n        } catch (Exception e) {\n            throw new XarException(\"Failed to write XML\", e);\n        } finally {\n            try {\n                writer.close();\n            } catch (XMLStreamException e) {\n                throw new XarException(\"Failed to close XML writer\", e);\n            }\n        }\n    }\n\n    /**\n     * Write the package descriptor to the passed XML stream.\n     * \n     * @param writer the XML stream where to write\n     * @throws XMLStreamException when failing to write the file\n     */\n    public void write(XMLStreamWriter writer) throws XMLStreamException\n    {\n        writer.writeStartElement(XarModel.ELEMENT_PACKAGE);\n\n        writer.writeStartElement(XarModel.ELEMENT_INFOS);\n        writeElement(writer, XarModel.ELEMENT_INFOS_NAME, getPackageName(), true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_DESCRIPTION, getPackageDescription(), true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_LICENSE, getPackageLicense(), true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_AUTHOR, getPackageAuthor(), true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_VERSION, getPackageVersion(), true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_ISBACKUPPACK, String.valueOf(isPackageBackupPack()), true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_ISPRESERVEVERSION, String.valueOf(isPackagePreserveVersion()),\n            true);\n        writeElement(writer, XarModel.ELEMENT_INFOS_EXTENSIONID, getPackageExtensionId(), false);\n        writer.writeEndElement();\n\n        writer.writeStartElement(XarModel.ELEMENT_FILES);\n        for (XarEntry entry : this.entries.values()) {\n            writer.writeStartElement(XarModel.ELEMENT_FILES_FILE);\n\n            writer.writeAttribute(XarModel.ATTRIBUTE_DEFAULTACTION, String.valueOf(entry.getDefaultAction()));\n            writer.writeAttribute(XarModel.ATTRIBUTE_LOCALE, Objects.toString(entry.getLocale(), \"\"));\n            if (entry.getEntryType() != null) {\n                writer.writeAttribute(XarModel.ATTRIBUTE_TYPE, entry.getEntryType());\n            }\n\n            writer.writeCharacters(TOSTRING_SERIALIZER.serialize(entry));\n\n            writer.writeEndElement();\n        }\n        writer.writeEndElement();\n    }\n\n    private void writeElement(XMLStreamWriter streamWriter, String localName, String value, boolean emptyIfNull)\n        throws XMLStreamException\n    {\n        if (value != null) {\n            if (value.isEmpty()) {\n                streamWriter.writeEmptyElement(localName);\n            } else {\n                streamWriter.writeStartElement(localName);\n                streamWriter.writeCharacters(value);\n                streamWriter.writeEndElement();\n            }\n        } else if (emptyIfNull) {\n            streamWriter.writeEmptyElement(localName);\n        }\n    }\n}\n"], "buggy_code_start_loc": [517], "buggy_code_end_loc": [517], "fixing_code_start_loc": [518], "fixing_code_end_loc": [520], "type": "CWE-611", "message": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. In affected versions any user with edit rights on a document can trigger an XAR import on a forged XAR file, leading to the ability to display the content of any file on the XWiki server host. This vulnerability has been patched in XWiki 13.10.11, 14.4.7 and 14.10-rc-1. Users are advised to upgrade. Users unable to upgrade may apply the patch `e3527b98fd` manually.", "other": {"cve": {"id": "CVE-2023-27480", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-07T19:15:12.663", "lastModified": "2023-03-14T16:57:18.623", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. In affected versions any user with edit rights on a document can trigger an XAR import on a forged XAR file, leading to the ability to display the content of any file on the XWiki server host. This vulnerability has been patched in XWiki 13.10.11, 14.4.7 and 14.10-rc-1. Users are advised to upgrade. Users unable to upgrade may apply the patch `e3527b98fd` manually."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartExcluding": "1.1", "versionEndExcluding": "13.10.11", "matchCriteriaId": "C8664072-FDBA-4714-8B9B-2B1E4DA8DE11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0", "versionEndExcluding": "14.4.7", "matchCriteriaId": "FA3A5151-58FB-48CF-BFFB-5688608200C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.5", "versionEndExcluding": "14.10", "matchCriteriaId": "569EE28C-5C86-467F-A153-DD4B9BF0053D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:1.1:milestone3:*:*:*:*:*:*", "matchCriteriaId": "1C11FD2B-E7B0-429B-8F7C-91227BED4913"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:1.1:milestone4:*:*:*:*:*:*", "matchCriteriaId": "AE0AF2D9-374A-4760-ACC3-CA04A332BAE6"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/e3527b98fdd8dc8179c24dc55e662b2c55199434", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-gx4f-976g-7g6v", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-20320", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/e3527b98fdd8dc8179c24dc55e662b2c55199434"}}