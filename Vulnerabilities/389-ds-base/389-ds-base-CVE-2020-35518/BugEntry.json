{"buggy_code": ["# --- BEGIN COPYRIGHT BLOCK ---\n# Copyright (C) 2020 Red Hat, Inc.\n# All rights reserved.\n#\n# License: GPL (version 3 or any later version).\n# See LICENSE for details.\n# --- END COPYRIGHT BLOCK ---\n#\n\nfrom subprocess import check_output, PIPE, run\nfrom lib389 import DirSrv\nfrom lib389.idm.user import UserAccounts\nimport pytest\nfrom lib389.tasks import *\nfrom lib389.utils import *\nfrom lib389.topologies import topology_st\nfrom lib389.dbgen import dbgen_users\nfrom lib389.idm.organizationalunit import OrganizationalUnits\nfrom lib389._constants import DN_DM, PASSWORD, PW_DM\nfrom lib389.paths import Paths\nfrom lib389.idm.directorymanager import DirectoryManager\nfrom lib389.config import LDBMConfig\nfrom lib389.dseldif import DSEldif\nfrom lib389.rootdse import RootDSE\n\n\npytestmark = pytest.mark.tier0\n\ndefault_paths = Paths()\n\nlog = logging.getLogger(__name__)\n\n# Globals\nUSER1_DN = 'uid=user1,' + DEFAULT_SUFFIX\nUSER2_DN = 'uid=user2,' + DEFAULT_SUFFIX\nUSER3_DN = 'uid=user3,' + DEFAULT_SUFFIX\nUSER4_DN = 'uid=user4,' + DEFAULT_SUFFIX\n\nROOTDSE_DEF_ATTR_LIST = ('namingContexts',\n                         'supportedLDAPVersion',\n                         'supportedControl',\n                         'supportedExtension',\n                         'supportedSASLMechanisms',\n                         'vendorName',\n                         'vendorVersion')\n\n\n@pytest.fixture(scope=\"module\")\ndef import_example_ldif(topology_st):\n    \"\"\"Import the Example LDIF for the tests in this suite\"\"\"\n\n    log.info('Initializing the \"basic\" test suite')\n\n    ldif = '%s/dirsrv/data/Example.ldif' % topology_st.standalone.get_data_dir()\n    import_ldif = topology_st.standalone.get_ldif_dir() + \"/Example.ldif\"\n    shutil.copy(ldif, import_ldif)\n\n    import_task = ImportTask(topology_st.standalone)\n    import_task.import_suffix_from_ldif(ldiffile=import_ldif, suffix=DEFAULT_SUFFIX)\n    import_task.wait()\n\n\n@pytest.fixture(params=ROOTDSE_DEF_ATTR_LIST)\ndef rootdse_attr(topology_st, request):\n    \"\"\"Adds an attr from the list\n    as the default attr to the rootDSE\n    \"\"\"\n    # Ensure the server is started and connected\n    topology_st.standalone.start()\n\n    RETURN_DEFAULT_OPATTR = \"nsslapd-return-default-opattr\"\n    rootdse_attr_name = ensure_bytes(request.param)\n\n    log.info(\"        Add the %s: %s to rootdse\" % (RETURN_DEFAULT_OPATTR,\n                                                    rootdse_attr_name))\n    mod = [(ldap.MOD_ADD, RETURN_DEFAULT_OPATTR, rootdse_attr_name)]\n    try:\n        topology_st.standalone.modify_s(\"\", mod)\n    except ldap.LDAPError as e:\n        log.fatal('Failed to add attr: error (%s)' % (e.args[0]['desc']))\n        assert False\n\n    def fin():\n        log.info(\"        Delete the %s: %s from rootdse\" % (RETURN_DEFAULT_OPATTR,\n                                                             rootdse_attr_name))\n        mod = [(ldap.MOD_DELETE, RETURN_DEFAULT_OPATTR, rootdse_attr_name)]\n        try:\n            topology_st.standalone.modify_s(\"\", mod)\n        except ldap.LDAPError as e:\n            log.fatal('Failed to delete attr: error (%s)' % (e.args[0]['desc']))\n            assert False\n\n    request.addfinalizer(fin)\n\n    return rootdse_attr_name\n\n\ndef test_basic_ops(topology_st, import_example_ldif):\n    \"\"\"Tests adds, mods, modrdns, and deletes operations\n\n    :id: 33f97f55-60bf-46c7-b880-6c488517ae19\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Add 3 test users USER1, USER2 and USER3 to database\n         2. Modify (ADD, REPLACE and DELETE) description for USER1 in database\n         3. Rename USER1, USER2 and USER3 using Modrds\n         4. Delete test entries USER1, USER2 and USER3\n\n    :expectedresults:\n         1. Add operation should PASS.\n         2. Modify operations should PASS.\n         3. Rename operations should PASS.\n         4. Delete operations should PASS.\n    \"\"\"\n    log.info('Running test_basic_ops...')\n    USER1_NEWDN = 'cn=user1'\n    USER2_NEWDN = 'cn=user2'\n    USER3_NEWDN = 'cn=user3'\n    NEW_SUPERIOR = 'ou=people,' + DEFAULT_SUFFIX\n    USER1_RDN_DN = 'cn=user1,' + DEFAULT_SUFFIX\n    USER2_RDN_DN = 'cn=user2,' + DEFAULT_SUFFIX\n    USER3_RDN_DN = 'cn=user3,' + NEW_SUPERIOR  # New superior test\n\n    #\n    # Adds#\n    try:\n        topology_st.standalone.add_s(Entry((USER1_DN,\n                                            {'objectclass': \"top extensibleObject\".split(),\n                                             'sn': '1',\n                                             'cn': 'user1',\n                                             'uid': 'user1',\n                                             'userpassword': 'password'})))\n    except ldap.LDAPError as e:\n        log.error('Failed to add test user' + USER1_DN + ': error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.add_s(Entry((USER2_DN,\n                                            {'objectclass': \"top extensibleObject\".split(),\n                                             'sn': '2',\n                                             'cn': 'user2',\n                                             'uid': 'user2',\n                                             'userpassword': 'password'})))\n    except ldap.LDAPError as e:\n        log.error('Failed to add test user' + USER2_DN + ': error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.add_s(Entry((USER3_DN,\n                                            {'objectclass': \"top extensibleObject\".split(),\n                                             'sn': '3',\n                                             'cn': 'user3',\n                                             'uid': 'user3',\n                                             'userpassword': 'password'})))\n    except ldap.LDAPError as e:\n        log.error('Failed to add test user' + USER3_DN + ': error ' + e.args[0]['desc'])\n        assert False\n\n    #\n    # Mods\n    #\n    try:\n        topology_st.standalone.modify_s(USER1_DN, [(ldap.MOD_ADD, 'description',\n                                                    b'New description')])\n    except ldap.LDAPError as e:\n        log.error('Failed to add description: error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.modify_s(USER1_DN, [(ldap.MOD_REPLACE, 'description',\n                                                    b'Modified description')])\n    except ldap.LDAPError as e:\n        log.error('Failed to modify description: error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.modify_s(USER1_DN, [(ldap.MOD_DELETE, 'description',\n                                                    None)])\n    except ldap.LDAPError as e:\n        log.error('Failed to delete description: error ' + e.args[0]['desc'])\n        assert False\n\n    #\n    # Modrdns\n    #\n    try:\n        topology_st.standalone.rename_s(USER1_DN, USER1_NEWDN, delold=1)\n    except ldap.LDAPError as e:\n        log.error('Failed to modrdn user1: error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.rename_s(USER2_DN, USER2_NEWDN, delold=0)\n    except ldap.LDAPError as e:\n        log.error('Failed to modrdn user2: error ' + e.args[0]['desc'])\n        assert False  # Modrdn - New superior\n\n    try:\n        topology_st.standalone.rename_s(USER3_DN, USER3_NEWDN,\n                                        newsuperior=NEW_SUPERIOR, delold=1)\n    except ldap.LDAPError as e:\n        log.error('Failed to modrdn(new superior) user3: error ' + e.args[0]['desc'])\n        assert False\n    #\n    # Deletes\n    #\n    try:\n        topology_st.standalone.delete_s(USER1_RDN_DN)\n    except ldap.LDAPError as e:\n        log.error('Failed to delete test entry1: ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.delete_s(USER2_RDN_DN)\n    except ldap.LDAPError as e:\n        log.error('Failed to delete test entry2: ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.delete_s(USER3_RDN_DN)\n    except ldap.LDAPError as e:\n        log.error('Failed to delete test entry3: ' + e.args[0]['desc'])\n        assert False\n    log.info('test_basic_ops: PASSED')\n\n\ndef test_basic_import_export(topology_st, import_example_ldif):\n    \"\"\"Test online and offline LDIF import & export\n\n    :id: 3ceeea11-9235-4e20-b80e-7203b2c6e149\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Generate a test ldif (50k entries)\n         2. Import test ldif file using Online import.\n         3. Import test ldif file using Offline import (ldif2db).\n         4. Export test ldif file using Online export.\n         5. Export test ldif file using Offline export (db2ldif).\n         6. Cleanup - Import the Example LDIF for the other tests in this suite\n\n    :expectedresults:\n         1. Test ldif file creation should PASS.\n         2. Online import should PASS.\n         3. Offline import should PASS.\n         4. Online export should PASS.\n         5. Offline export should PASS.\n         6. Cleanup should PASS.\n    \"\"\"\n\n    log.info('Running test_basic_import_export...')\n    #\n    # Test online/offline LDIF imports\n    #\n    topology_st.standalone.start()\n    # topology_st.standalone.config.set('nsslapd-errorlog-level', '1')\n\n    # Generate a test ldif (50k entries)\n    log.info(\"Generating LDIF...\")\n    ldif_dir = topology_st.standalone.get_ldif_dir()\n    import_ldif = ldif_dir + '/basic_import.ldif'\n    dbgen_users(topology_st.standalone, 50000, import_ldif, DEFAULT_SUFFIX)\n\n\n    # Online\n    log.info(\"Importing LDIF online...\")\n    import_task = ImportTask(topology_st.standalone)\n    import_task.import_suffix_from_ldif(ldiffile=import_ldif, suffix=DEFAULT_SUFFIX)\n\n    # Wait a bit till the task is created and available for searching\n    time.sleep(0.5)\n\n    # Good as place as any to quick test the task has some expected attributes\n    if ds_is_newer('1.4.1.2'):\n        assert import_task.present('nstaskcreated')\n    assert import_task.present('nstasklog')\n    assert import_task.present('nstaskcurrentitem')\n    assert import_task.present('nstasktotalitems')\n    assert import_task.present('ttl')\n\n    import_task.wait()\n\n    # Offline\n    log.info(\"Importing LDIF offline...\")\n    topology_st.standalone.stop()\n    if not topology_st.standalone.ldif2db(DEFAULT_BENAME, None, None, None, import_ldif):\n        log.fatal('test_basic_import_export: Offline import failed')\n        assert False\n    topology_st.standalone.start()\n\n    #\n    # Test online and offline LDIF export\n    #\n\n    # Online export\n    log.info(\"Exporting LDIF online...\")\n    export_ldif = ldif_dir + '/export.ldif'\n\n    export_task = ExportTask(topology_st.standalone)\n    export_task.export_suffix_to_ldif(ldiffile=export_ldif, suffix=DEFAULT_SUFFIX)\n    export_task.wait()\n\n    # Offline export\n    log.info(\"Exporting LDIF offline...\")\n    topology_st.standalone.stop()\n    if not topology_st.standalone.db2ldif(DEFAULT_BENAME, (DEFAULT_SUFFIX,),\n                                          None, None, None, export_ldif):\n        log.fatal('test_basic_import_export: Failed to run offline db2ldif')\n        assert False\n\n    topology_st.standalone.start()\n\n    #\n    # Cleanup - Import the Example LDIF for the other tests in this suite\n    #\n    log.info(\"Restore datrabase, import initial LDIF...\")\n    ldif = '%s/dirsrv/data/Example.ldif' % topology_st.standalone.get_data_dir()\n    import_ldif = topology_st.standalone.get_ldif_dir() + \"/Example.ldif\"\n    shutil.copyfile(ldif, import_ldif)\n\n    import_task = ImportTask(topology_st.standalone)\n    import_task.import_suffix_from_ldif(ldiffile=import_ldif, suffix=DEFAULT_SUFFIX)\n    import_task.wait()\n\n    log.info('test_basic_import_export: PASSED')\n\n\ndef test_basic_backup(topology_st, import_example_ldif):\n    \"\"\"Tests online and offline backup and restore\n\n    :id: 0e9d91f8-8748-40b6-ab03-fbd1998eb985\n\n    :setup: Standalone instance and import example.ldif\n\n    :steps:\n         1. Test online backup using db2bak.\n         2. Test online restore using bak2db.\n         3. Test offline backup using db2bak.\n         4. Test offline restore using bak2db.\n\n    :expectedresults:\n         1. Online backup should PASS.\n         2. Online restore should PASS.\n         3. Offline backup should PASS.\n         4. Offline restore should PASS.\n    \"\"\"\n\n    log.info('Running test_basic_backup...')\n\n    backup_dir = topology_st.standalone.get_bak_dir() + '/backup_test'\n\n    # Test online backup\n    try:\n        topology_st.standalone.tasks.db2bak(backup_dir=backup_dir,\n                                            args={TASK_WAIT: True})\n    except ValueError:\n        log.fatal('test_basic_backup: Online backup failed')\n        assert False\n\n    # Test online restore\n    try:\n        topology_st.standalone.tasks.bak2db(backup_dir=backup_dir,\n                                            args={TASK_WAIT: True})\n    except ValueError:\n        log.fatal('test_basic_backup: Online restore failed')\n        assert False\n\n    # Test offline backup\n    topology_st.standalone.stop()\n    if not topology_st.standalone.db2bak(backup_dir):\n        log.fatal('test_basic_backup: Offline backup failed')\n        assert False\n\n    # Test offline restore\n    if not topology_st.standalone.bak2db(backup_dir):\n        log.fatal('test_basic_backup: Offline backup failed')\n        assert False\n    topology_st.standalone.start()\n\n    log.info('test_basic_backup: PASSED')\n\n\ndef test_basic_db2index(topology_st, import_example_ldif):\n    \"\"\"Assert db2index can operate correctly.\n\n    :id: 191fc0fd-9722-46b5-a7c3-e8760effe119\n\n    :setup: Standalone instance\n\n    :steps:\n        1: call db2index\n\n    :expectedresults:\n        1: Index succeeds.\n\n    \"\"\"\n    topology_st.standalone.stop()\n    topology_st.standalone.db2index()\n    topology_st.standalone.db2index(suffixes=[DEFAULT_SUFFIX], attrs=['uid'])\n    topology_st.standalone.start()\n\n\ndef test_basic_acl(topology_st, import_example_ldif):\n    \"\"\"Run some basic access control (ACL) tests\n\n    :id: 4f4e705f-32f4-4065-b3a8-2b0c2525798b\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Add two test users USER1_DN and USER2_DN.\n         2. Add an aci that denies USER1 from doing anything.\n         3. Set the default anonymous access for USER2.\n         4. Try searching entries using USER1.\n         5. Try searching entries using USER2.\n         6. Try searching entries using root dn.\n         7. Cleanup - delete test users and test ACI.\n\n    :expectedresults:\n         1. Test Users should be added.\n         2. ACI should be added.\n         3. This operation should PASS.\n         4. USER1 should not be able to search anything.\n         5. USER2 should be able to search everything except password.\n         6. RootDN should be allowed to search everything.\n         7. Cleanup should PASS.\n    \"\"\"\n\n    \"\"\"Run some basic access control(ACL) tests\"\"\"\n    log.info('Running test_basic_acl...')\n\n    DENY_ACI = ensure_bytes('(targetattr = \"*\")(version 3.0;acl \"deny user\";deny (all)(userdn = \"ldap:///%s\");)' % USER1_DN)\n\n    #\n    # Add two users\n    #\n    try:\n        topology_st.standalone.add_s(Entry((USER1_DN,\n                                            {'objectclass': \"top extensibleObject\".split(),\n                                             'sn': '1',\n                                             'cn': 'user 1',\n                                             'uid': 'user1',\n                                             'userpassword': PASSWORD})))\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to add test user ' + USER1_DN +\n                  ': error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.add_s(Entry((USER2_DN,\n                                            {'objectclass': \"top extensibleObject\".split(),\n                                             'sn': '2',\n                                             'cn': 'user 2',\n                                             'uid': 'user2',\n                                             'userpassword': PASSWORD})))\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to add test user ' + USER1_DN +\n                  ': error ' + e.args[0]['desc'])\n        assert False\n\n    #\n    # Add an aci that denies USER1 from doing anything,\n    # and also set the default anonymous access\n    #\n    try:\n        topology_st.standalone.modify_s(DEFAULT_SUFFIX, [(ldap.MOD_ADD, 'aci', DENY_ACI)])\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to add DENY ACI: error ' + e.args[0]['desc'])\n        assert False\n\n    #\n    # Make sure USER1_DN can not search anything, but USER2_dn can...\n    #\n    try:\n        topology_st.standalone.simple_bind_s(USER1_DN, PASSWORD)\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to bind as user1, error: ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        entries = topology_st.standalone.search_s(DEFAULT_SUFFIX,\n                                                  ldap.SCOPE_SUBTREE,\n                                                  '(uid=*)')\n        if entries:\n            log.fatal('test_basic_acl: User1 was incorrectly able to search the suffix!')\n            assert False\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Search suffix failed(as user1): ' + e.args[0]['desc'])\n        assert False\n\n    # Now try user2...  Also check that userpassword is stripped out\n    try:\n        topology_st.standalone.simple_bind_s(USER2_DN, PASSWORD)\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to bind as user2, error: ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        entries = topology_st.standalone.search_s(DEFAULT_SUFFIX,\n                                                  ldap.SCOPE_SUBTREE,\n                                                  '(uid=user1)')\n        if not entries:\n            log.fatal('test_basic_acl: User1 incorrectly not able to search the suffix')\n            assert False\n        if entries[0].hasAttr('userpassword'):\n            # The default anonymous access aci should have stripped out userpassword\n            log.fatal('test_basic_acl: User2 was incorrectly able to see userpassword')\n            assert False\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Search for user1 failed(as user2): ' + e.args[0]['desc'])\n        assert False\n\n    # Make sure RootDN can also search (this also resets the bind dn to the\n    # Root DN for future operations)\n    try:\n        topology_st.standalone.simple_bind_s(DN_DM, PW_DM)\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to bind as ROotDN, error: ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        entries = topology_st.standalone.search_s(DEFAULT_SUFFIX,\n                                                  ldap.SCOPE_SUBTREE,\n                                                  '(uid=*)')\n        if not entries:\n            log.fatal('test_basic_acl: Root DN incorrectly not able to search the suffix')\n            assert False\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Search for user1 failed(as user2): ' + e.args[0]['desc'])\n        assert False\n\n    #\n    # Cleanup\n    #\n    try:\n        topology_st.standalone.modify_s(DEFAULT_SUFFIX, [(ldap.MOD_DELETE, 'aci', DENY_ACI)])\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to delete DENY ACI: error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.delete_s(USER1_DN)\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to delete test entry1: ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.delete_s(USER2_DN)\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to delete test entry2: ' + e.args[0]['desc'])\n        assert False\n\n    log.info('test_basic_acl: PASSED')\n\n\ndef test_basic_searches(topology_st, import_example_ldif):\n    \"\"\"Tests basic search operations with filters.\n\n    :id: 426a59ff-49b8-4a70-b377-0c0634a29b6f\n\n    :setup: Standalone instance, add example.ldif to the database\n\n    :steps:\n         1. Execute search command while using different filters.\n         2. Check number of entries returned by search filters.\n\n    :expectedresults:\n         1. Search command should PASS.\n         2. Number of result entries returned should match number of the database entries according to the search filter.\n    \"\"\"\n\n    log.info('Running test_basic_searches...')\n\n    filters = (('(uid=scarter)', 1),\n               ('(uid=tmorris*)', 1),\n               ('(uid=*hunt*)', 4),\n               ('(uid=*cope)', 2),\n               ('(mail=*)', 150),\n               ('(roomnumber>=4000)', 35),\n               ('(roomnumber<=4000)', 115),\n               ('(&(roomnumber>=4000)(roomnumber<=4500))', 18),\n               ('(!(l=sunnyvale))', 120),\n               ('(&(uid=t*)(l=santa clara))', 7),\n               ('(|(uid=k*)(uid=r*))', 18),\n               ('(|(uid=t*)(l=sunnyvale))', 50),\n               ('(&(!(uid=r*))(ou=people))', 139),\n               ('(&(uid=m*)(l=sunnyvale)(ou=people)(mail=*example*)(roomNumber=*))', 3),\n               ('(&(|(uid=m*)(l=santa clara))(roomNumber=22*))', 5),\n               ('(&(|(uid=m*)(l=santa clara))(roomNumber=22*)(!(roomnumber=2254)))', 4),)\n\n    for (search_filter, search_result) in filters:\n        try:\n            entries = topology_st.standalone.search_s(DEFAULT_SUFFIX,\n                                                      ldap.SCOPE_SUBTREE,\n                                                      search_filter)\n            if len(entries) != search_result:\n                log.fatal('test_basic_searches: An incorrect number of entries\\\n                        was returned from filter (%s): (%d) expected (%d)' %\n                          (search_filter, len(entries), search_result))\n                assert False\n        except ldap.LDAPError as e:\n            log.fatal('Search failed: ' + e.args[0]['desc'])\n            assert False\n\n    log.info('test_basic_searches: PASSED')\n\n\n@pytest.fixture(scope=\"module\")\ndef add_test_entry(topology_st, request):\n    # Add test entry\n    topology_st.standalone.add_s(Entry((USER4_DN,\n                                        {'objectclass': \"top extensibleObject\".split(),\n                                         'cn': 'user1', 'uid': 'user1'})))\n\n\nsearch_params = [(['1.1'], 'cn', False),\n                 (['1.1', 'cn'], 'cn', True),\n                 (['+'], 'nsUniqueId', True),\n                 (['*'], 'cn', True),\n                 (['cn'], 'cn', True)]\n@pytest.mark.skipif(ds_is_older(\"1.4.2.0\"), reason=\"Not implemented\")\n@pytest.mark.parametrize(\"attrs, attr, present\", search_params)\ndef test_search_req_attrs(topology_st, add_test_entry, attrs, attr, present):\n    \"\"\"Test requested attributes in search operations.\n\n    :id: 426a59ff-49b8-4a70-b377-0c0634a29b6e\n    :parametrized: yes\n    :setup: Standalone instance\n    :steps:\n         1. Test \"1.1\" does not return any attributes.\n         2. Test \"1.1\" is ignored if there are other requested attributes\n         3. Test \"+\" returns all operational attributes\n         4. Test \"*\" returns all attributes\n         5. Test requested attributes\n\n    :expectedresults:\n         1. Success\n         2. Success\n         3. Success\n         4. Success\n         5. Success\n    \"\"\"\n\n    log.info(\"Testing attrs: {} attr: {} present: {}\".format(attrs, attr, present))\n    entry = topology_st.standalone.search_s(USER4_DN,\n                                            ldap.SCOPE_BASE,\n                                            'objectclass=top',\n                                            attrs)\n    if present:\n        assert entry[0].hasAttr(attr)\n    else:\n        assert not entry[0].hasAttr(attr)\n\n\ndef test_basic_referrals(topology_st, import_example_ldif):\n    \"\"\"Test LDAP server in referral mode.\n\n    :id: c586aede-7ac3-4e8d-a1cf-bfa8b8d78cc2\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Set the referral and the backend state\n         2. Set backend state to referral mode.\n         3. Set server to not follow referral.\n         4. Search using referral.\n         5. Make sure server can restart in referral mode.\n         6. Cleanup - Delete referral.\n\n    :expectedresults:\n         1. Set the referral, and the backend state should PASS.\n         2. Set backend state to referral mode should PASS.\n         3. Set server to not follow referral should PASS.\n         4. referral error(10) should occur.\n         5. Restart should PASS.\n         6. Cleanup should PASS.\n    \"\"\"\n\n    log.info('Running test_basic_referrals...')\n    SUFFIX_CONFIG = 'cn=\"dc=example,dc=com\",cn=mapping tree,cn=config'\n    #\n    # Set the referral, and the backend state\n    #\n    try:\n        topology_st.standalone.modify_s(SUFFIX_CONFIG,\n                                        [(ldap.MOD_REPLACE,\n                                          'nsslapd-referral',\n                                          b'ldap://localhost.localdomain:389/o%3dnetscaperoot')])\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_referrals: Failed to set referral: error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.modify_s(SUFFIX_CONFIG, [(ldap.MOD_REPLACE,\n                                                         'nsslapd-state', b'Referral')])\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_referrals: Failed to set backend state: error '\n                  + e.args[0]['desc'])\n        assert False\n\n    #\n    # Test that a referral error is returned\n    #\n    topology_st.standalone.set_option(ldap.OPT_REFERRALS, 0)  # Do not follow referral\n    try:\n        topology_st.standalone.search_s(DEFAULT_SUFFIX, ldap.SCOPE_SUBTREE, 'objectclass=top')\n    except ldap.REFERRAL:\n        pass\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_referrals: Search failed: ' + e.args[0]['desc'])\n        assert False\n\n    #\n    # Make sure server can restart in referral mode\n    #\n    topology_st.standalone.restart(timeout=10)\n\n    #\n    # Cleanup\n    #\n    try:\n        topology_st.standalone.modify_s(SUFFIX_CONFIG, [(ldap.MOD_REPLACE,\n                                                         'nsslapd-state', b'Backend')])\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_referrals: Failed to set backend state: error '\n                  + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.modify_s(SUFFIX_CONFIG, [(ldap.MOD_DELETE,\n                                                         'nsslapd-referral', None)])\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_referrals: Failed to delete referral: error '\n                  + e.args[0]['desc'])\n        assert False\n    topology_st.standalone.set_option(ldap.OPT_REFERRALS, 1)\n\n    log.info('test_basic_referrals: PASSED')\n\n\ndef test_basic_systemctl(topology_st, import_example_ldif):\n    \"\"\"Tests systemctl/lib389 can stop and start the server.\n\n    :id: a92a7438-ecfa-4583-a89c-5fbfc0220b69\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Stop the server.\n         2. Start the server.\n         3. Stop the server, break the dse.ldif and dse.ldif.bak, so a start fails.\n         4. Verify that systemctl detects the failed start.\n         5. Fix the dse.ldif, and make sure the server starts up.\n         6. Verify systemctl correctly identifies the successful start.\n\n    :expectedresults:\n         1. Server should be stopped.\n         2. Server should start\n         3. Stop should work but start after breaking dse.ldif should fail.\n         4. Systemctl should be able to detect the failed start.\n         5. Server should start.\n         6. Systemctl should be able to detect the successful start.\n    \"\"\"\n\n    log.info('Running test_basic_systemctl...')\n\n    config_dir = topology_st.standalone.get_config_dir()\n\n    #\n    # Stop the server\n    #\n    log.info('Stopping the server...')\n    topology_st.standalone.stop()\n    log.info('Stopped the server.')\n\n    #\n    # Start the server\n    #\n    log.info('Starting the server...')\n    topology_st.standalone.start()\n    log.info('Started the server.')\n\n    #\n    # Stop the server, break the dse.ldif so a start fails,\n    # and verify that systemctl detects the failed start\n    #\n    log.info('Stopping the server...')\n    topology_st.standalone.stop()\n    log.info('Stopped the server before breaking the dse.ldif.')\n\n    shutil.copy(config_dir + '/dse.ldif', config_dir + '/dse.ldif.correct')\n    open(config_dir + '/dse.ldif', 'w').close()\n    # We need to kill the .bak file too, DS is just too smart!\n    open(config_dir + '/dse.ldif.bak', 'w').close()\n\n    log.info('Attempting to start the server with broken dse.ldif...')\n    try:\n        topology_st.standalone.start()\n    except Exception as e:\n        log.info('Server failed to start as expected: ' + str(e))\n    log.info('Check the status...')\n    assert (not topology_st.standalone.status())\n    log.info('Server failed to start as expected')\n    time.sleep(5)\n\n    #\n    # Fix the dse.ldif, and make sure the server starts up,\n    # and systemctl correctly identifies the successful start\n    #\n    shutil.copy(config_dir + '/dse.ldif.correct', config_dir + '/dse.ldif')\n    log.info('Starting the server with good dse.ldif...')\n    topology_st.standalone.start()\n    log.info('Check the status...')\n    assert (topology_st.standalone.status())\n    log.info('Server started after fixing dse.ldif.')\n\n    log.info('test_basic_systemctl: PASSED')\n\n\ndef test_basic_ldapagent(topology_st, import_example_ldif):\n    \"\"\"Tests that the ldap agent starts\n\n    :id: da1d1846-8fc4-4b8c-8e53-4c9c16eff1ba\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Start SNMP ldap agent using command.\n         2. Cleanup - Kill SNMP agent process.\n\n    :expectedresults:\n         1. SNMP agent should start.\n         2. SNMP agent process should be successfully killed.\n    \"\"\"\n\n    log.info('Running test_basic_ldapagent...')\n\n    var_dir = topology_st.standalone.get_local_state_dir()\n\n    config_file = os.path.join(topology_st.standalone.get_sysconf_dir(), 'dirsrv/config/agent.conf')\n\n    agent_config_file = open(config_file, 'w')\n    agent_config_file.write('agentx-master ' + var_dir + '/agentx/master\\n')\n    agent_config_file.write('agent-logdir ' + var_dir + '/log/dirsrv\\n')\n    agent_config_file.write('server slapd-' + topology_st.standalone.serverid + '\\n')\n    agent_config_file.close()\n\n    # Remember, this is *forking*\n    check_output([os.path.join(topology_st.standalone.get_sbin_dir(), 'ldap-agent'), config_file])\n    # First kill any previous agents ....\n    pidpath = os.path.join(var_dir, 'run/ldap-agent.pid')\n    pid = None\n    with open(pidpath, 'r') as pf:\n        pid = pf.readlines()[0].strip()\n    if pid:\n        log.debug('test_basic_ldapagent: Terminating agent %s', pid)\n        check_output(['kill', pid])\n\n    log.info('test_basic_ldapagent: PASSED')\n\n\n@pytest.mark.skipif(not get_user_is_ds_owner(),\n                    reason=\"process ownership permission is required\")\ndef test_basic_dse_survives_kill9(topology_st, import_example_ldif):\n    \"\"\"Tests that the dse.ldif is not wiped out after the process is killed (bug 910581)\n\n    :id: 10f141da-9b22-443a-885c-87271dcd7a59\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Check out pid of ns-slapd process and Kill ns-slapd process.\n         2. Check the contents of dse.ldif file.\n         3. Start server.\n\n    :expectedresults:\n         1. ns-slapd process should be killed.\n         2. dse.ldif should not be corrupted.\n         3. Server should start successfully.\n    \"\"\"\n    log.info('Running test_basic_dse...')\n\n    dse_file = topology_st.standalone.confdir + '/dse.ldif'\n    pid = check_output(['pidof', '-s', 'ns-slapd']).strip()\n    # We can't guarantee we have access to sudo in any environment ... Either\n    # run py.test with sudo, or as the same user as the dirsrv.\n    check_output(['kill', '-9', ensure_str(pid)])\n    if os.path.getsize(dse_file) == 0:\n        log.fatal('test_basic_dse: dse.ldif\\'s content was incorrectly removed!')\n        assert False\n\n    topology_st.standalone.start(timeout=60)\n    log.info('dse.ldif was not corrupted, and the server was restarted')\n\n    log.info('test_basic_dse: PASSED')\n    # Give the server time to startup, in some conditions this can be racey without systemd notification. Only affects this one test though...\n    time.sleep(10)\n\n\n@pytest.mark.parametrize(\"rootdse_attr_name\", ROOTDSE_DEF_ATTR_LIST)\ndef test_def_rootdse_attr(topology_st, import_example_ldif, rootdse_attr_name):\n    \"\"\"Tests that operational attributes are not returned by default in rootDSE searches\n\n    :id: 4fee33cc-4019-4c27-89e8-998e6c770dc0\n    :parametrized: yes\n    :setup: Standalone instance\n\n    :steps:\n         1. Make an ldapsearch for rootdse attribute\n         2. Check the returned entries.\n\n    :expectedresults:\n         1. Search should not fail\n         2. Operational attributes should not be returned.\n    \"\"\"\n\n    topology_st.standalone.start()\n\n    log.info(\" Assert rootdse search hasn't %s attr\" % rootdse_attr_name)\n    try:\n        entry = topology_st.standalone.search_s(\"\", ldap.SCOPE_BASE)[0]\n        assert not entry.hasAttr(rootdse_attr_name)\n\n    except ldap.LDAPError as e:\n        log.fatal('Search failed, error: ' + e.args[0]['desc'])\n        assert False\n\n\ndef test_mod_def_rootdse_attr(topology_st, import_example_ldif, rootdse_attr):\n    \"\"\"Tests that operational attributes are returned by default in rootDSE searches after config modification\n\n   :id: c7831e04-f458-4e23-83c7-b6f66109f639\n   :parametrized: yes\n   :setup: Standalone instance and we are using rootdse_attr fixture which\n           adds nsslapd-return-default-opattr attr with value of one operation attribute.\n\n   :steps:\n         1. Make an ldapsearch for rootdse attribute\n         2. Check the returned entries.\n\n   :expectedresults:\n         1. Search should not fail\n         2. Operational attributes should be returned after the config modification\n   \"\"\"\n\n    log.info(\" Assert rootdse search has %s attr\" % rootdse_attr)\n    try:\n        entry = topology_st.standalone.search_s(\"\", ldap.SCOPE_BASE)[0]\n        assert entry.hasAttr(rootdse_attr)\n\n    except ldap.LDAPError as e:\n        log.fatal('Search failed, error: ' + e.args[0]['desc'])\n        assert False\n\n\n@pytest.fixture(scope=\"module\")\ndef create_users(topology_st):\n    \"\"\"Add users to the default suffix\n    \"\"\"\n\n    users = UserAccounts(topology_st.standalone, DEFAULT_SUFFIX)\n    user_names = [\"Directory\", \"Server\", \"389\", \"lib389\", \"pytest\"]\n\n    log.info('Adding 5 test users')\n    for name in user_names:\n        users.create(properties={\n            'uid': name,\n            'sn': name,\n            'cn': name,\n            'uidNumber': '1000',\n            'gidNumber': '1000',\n            'homeDirectory': '/home/%s' % name,\n            'mail': '%s@example.com' % name,\n            'userpassword': 'pass%s' % name,\n        })\n\n\ndef test_basic_anonymous_search(topology_st, create_users):\n    \"\"\"Tests basic anonymous search operations\n\n    :id: c7831e04-f458-4e50-83c7-b6f77109f639\n    :setup: Standalone instance\n            Add 5 test users with different user names\n    :steps:\n         1. Execute anonymous search with different filters\n    :expectedresults:\n         1. Search should be successful\n    \"\"\"\n\n    filters = [\"uid=Directory\", \"(|(uid=S*)(uid=3*))\", \"(&(uid=l*)(mail=l*))\", \"(&(!(uid=D*))(ou=People))\"]\n    log.info(\"Execute anonymous search with different filters\")\n    for filtr in filters:\n        entries = topology_st.standalone.search_s(DEFAULT_SUFFIX, ldap.SCOPE_SUBTREE, filtr)\n        assert len(entries) != 0\n\n\n@pytest.mark.ds604\n@pytest.mark.bz915801\ndef test_search_original_type(topology_st, create_users):\n    \"\"\"Test ldapsearch returning original attributes\n       using nsslapd-search-return-original-type-switch\n\n    :id: d7831d04-f558-4e50-93c7-b6f77109f640\n    :setup: Standalone instance\n            Add some test entries\n    :steps:\n         1. Set nsslapd-search-return-original-type-switch to ON\n         2. Check that ldapsearch *does* return unknown attributes\n         3. Turn off nsslapd-search-return-original-type-switch\n         4. Check that ldapsearch doesn't return any unknown attributes\n    :expectedresults:\n         1. nsslapd-search-return-original-type-switch should be set to ON\n         2. ldapsearch should return unknown attributes\n         3. nsslapd-search-return-original-type-switch should be OFF\n         4. ldapsearch should not return any unknown attributes\n    \"\"\"\n\n    log.info(\"Set nsslapd-search-return-original-type-switch to ON\")\n    topology_st.standalone.config.set('nsslapd-search-return-original-type-switch', 'on')\n\n    log.info(\"Check that ldapsearch *does* return unknown attributes\")\n    entries = topology_st.standalone.search_s(DEFAULT_SUFFIX, ldap.SCOPE_SUBTREE, 'uid=Directory',\n                                              ['objectclass overflow', 'unknown'])\n    assert \"objectclass overflow\" in entries[0].getAttrs()\n\n    log.info(\"Set nsslapd-search-return-original-type-switch to Off\")\n    topology_st.standalone.config.set('nsslapd-search-return-original-type-switch', 'off')\n    log.info(\"Check that ldapsearch *does not* return unknown attributes\")\n    entries = topology_st.standalone.search_s(DEFAULT_SUFFIX, ldap.SCOPE_SUBTREE, 'uid=Directory',\n                                              ['objectclass overflow', 'unknown'])\n    assert \"objectclass overflow\" not in entries[0].getAttrs()\n\n\n@pytest.mark.bz192901\ndef test_search_ou(topology_st):\n    \"\"\"Test that DS should not return an entry that does not match the filter\n\n    :id: d7831d05-f117-4e89-93c7-b6f77109f640\n    :setup: Standalone instance\n    :steps:\n         1. Create an OU entry without sub entries\n         2. Search from the OU with the filter that does not match the OU\n    :expectedresults:\n         1. Creation of OU should be successful\n         2. Search should not return any results\n    \"\"\"\n\n    log.info(\"Create a test OU without sub entries\")\n    ou = OrganizationalUnits(topology_st.standalone, DEFAULT_SUFFIX)\n    ou.create(properties={\n        'ou': 'test_ou',\n    })\n\n    search_base = (\"ou=test_ou,%s\" % DEFAULT_SUFFIX)\n    log.info(\"Search from the OU with the filter that does not match the OU, it should not return anything\")\n    entries = topology_st.standalone.search_s(search_base, ldap.SCOPE_SUBTREE, 'uid=*', ['dn'])\n    assert len(entries) == 0\n\n\ndef test_bind_invalid_entry(topology_st):\n    \"\"\"Test the failing bind does not return information about the entry\n\n    :id: 5cd9b083-eea6-426b-84ca-83c26fc49a6f\n\n    :customerscenario: True\n\n    :setup: Standalone instance\n\n    :steps:\n    1: bind as non existing entry\n    2: check that bind info does not report 'No such entry'\n\n    :expectedresults:\n    1: pass\n    2: pass\n    \"\"\"\n\n    topology_st.standalone.restart()\n    INVALID_ENTRY=\"cn=foooo,%s\" % DEFAULT_SUFFIX\n    try:\n        topology_st.standalone.simple_bind_s(INVALID_ENTRY, PASSWORD)\n    except ldap.LDAPError as e:\n        log.info('test_bind_invalid_entry: Failed to bind as %s (expected)' % INVALID_ENTRY)\n        log.info('exception description: ' + e.args[0]['desc'])\n        if 'info' in e.args[0]:\n            log.info('exception info: ' + e.args[0]['info'])\n        assert e.args[0]['desc'] == 'Invalid credentials'\n        assert 'info' not in e.args[0]\n        pass\n\n    log.info('test_bind_invalid_entry: PASSED')\n\n    # reset credentials\n    topology_st.standalone.simple_bind_s(DN_DM, PW_DM)\n\n\n@pytest.mark.bz1044135\n@pytest.mark.ds47319\ndef test_connection_buffer_size(topology_st):\n    \"\"\"Test connection buffer size adjustable with different values(valid values and invalid)\n\n    :id: e7831d05-f117-4ec9-1203-b6f77109f117\n    :setup: Standalone instance\n    :steps:\n         1. Set nsslapd-connection-buffer to some valid values (2, 0 , 1)\n         2. Set nsslapd-connection-buffer to some invalid values (-1, a)\n    :expectedresults:\n         1. This should pass\n         2. This should fail\n    \"\"\"\n\n    valid_values = ['2', '0', '1']\n    for value in valid_values:\n        topology_st.standalone.config.replace('nsslapd-connection-buffer', value)\n\n    invalid_values = ['-1', 'a']\n    for value in invalid_values:\n        with pytest.raises(ldap.OPERATIONS_ERROR):\n            topology_st.standalone.config.replace('nsslapd-connection-buffer', value)\n\n\n@pytest.mark.bz1637439\ndef test_critical_msg_on_empty_range_idl(topology_st):\n    \"\"\"Doing a range index lookup should not report a critical message even if IDL is empty\n\n    :id: a07a2222-0551-44a6-b113-401d23799364\n    :setup: Standalone instance\n    :steps:\n         1. Create an index for internationalISDNNumber. (attribute chosen because it is\n            unlikely that previous tests used it)\n         2. telephoneNumber being indexed by default create 20 users without telephoneNumber\n         3. add a telephoneNumber value and delete it to trigger an empty index database\n         4. Do a search that triggers a range lookup on empty telephoneNumber\n         5. Check that the critical message is not logged in error logs\n    :expectedresults:\n         1. This should pass\n         2. This should pass\n         3. This should pass\n         4. This should pass on normal build but could abort a debug build\n         5. This should pass\n    \"\"\"\n    indexedAttr = 'internationalISDNNumber'\n\n    # Step 1\n    from lib389.index import Indexes\n\n    indexes = Indexes(topology_st.standalone)\n    indexes.create(properties={\n        'cn': indexedAttr,\n        'nsSystemIndex': 'false',\n        'nsIndexType': 'eq'\n        })\n    topology_st.standalone.restart()\n\n    # Step 2\n    users = UserAccounts(topology_st.standalone, DEFAULT_SUFFIX)\n    log.info('Adding 20 users without \"%s\"' % indexedAttr)\n    for i in range(20):\n        name = 'user_%d' % i\n        last_user = users.create(properties={\n            'uid': name,\n            'sn': name,\n            'cn': name,\n            'uidNumber': '1000',\n            'gidNumber': '1000',\n            'homeDirectory': '/home/%s' % name,\n            'mail': '%s@example.com' % name,\n            'userpassword': 'pass%s' % name,\n        })\n\n    # Step 3\n    # required update to create the indexAttr (i.e. 'loginShell') database, and then make it empty\n    topology_st.standalone.modify_s(last_user.dn, [(ldap.MOD_ADD, indexedAttr, b'1234')])\n    ent = topology_st.standalone.getEntry(last_user.dn, ldap.SCOPE_BASE,)\n    assert ent\n    assert ent.hasAttr(indexedAttr)\n    topology_st.standalone.modify_s(last_user.dn, [(ldap.MOD_DELETE, indexedAttr, None)])\n    ent = topology_st.standalone.getEntry(last_user.dn, ldap.SCOPE_BASE,)\n    assert ent\n    assert not ent.hasAttr(indexedAttr)\n\n    # Step 4\n    # The first component being not indexed the range on second is evaluated\n    try:\n        ents = topology_st.standalone.search_s(DEFAULT_SUFFIX, ldap.SCOPE_SUBTREE, '(&(sudoNotAfter=*)(%s>=111))' % indexedAttr)\n        assert len(ents) == 0\n    except ldap.SERVER_DOWN:\n        log.error('Likely testing against a debug version that asserted')\n        pass\n\n    # Step 5\n    assert not topology_st.standalone.searchErrorsLog('CRIT - list_candidates - NULL idl was recieved from filter_candidates_ext.')\n\n\n@pytest.mark.bz1647099\n@pytest.mark.ds50026\ndef test_ldbm_modification_audit_log(topology_st):\n    \"\"\"When updating LDBM config attributes, those attributes/values are not listed\n    in the audit log\n\n    :id: 5bf75c47-a283-430e-a65c-3c5fd8dbadb8\n    :setup: Standalone Instance\n    :steps:\n        1. Bind as DM\n        2. Enable audit log\n        3. Update a set of config attrs in LDBM config\n        4. Restart the server\n        5. Check that config attrs are listed in the audit log\n    :expectedresults:\n        1. Operation successful\n        2. Operation successful\n        3. Operation successful\n        4. Operation successful\n        5. Audit log should contain modification of attrs\"\n    \"\"\"\n\n    VALUE = '10001'\n\n    d_manager = DirectoryManager(topology_st.standalone)\n    conn = d_manager.bind()\n    config_ldbm = LDBMConfig(conn)\n\n    log.info(\"Enable audit logging\")\n    conn.config.enable_log('audit')\n\n    attrs = ['nsslapd-lookthroughlimit', 'nsslapd-pagedidlistscanlimit', 'nsslapd-idlistscanlimit', 'nsslapd-db-locks']\n\n    for attr in attrs:\n        log.info(\"Set attribute %s to value %s\" % (attr, VALUE))\n        config_ldbm.set(attr, VALUE)\n\n    log.info('Restart the server to flush the logs')\n    conn.restart()\n\n    for attr in attrs:\n        log.info(\"Check if attribute %s is replaced in the audit log\" % attr)\n        assert conn.searchAuditLog('replace: %s' % attr)\n        assert conn.searchAuditLog('%s: %s' % (attr, VALUE))\n\n\n@pytest.mark.skipif(not get_user_is_root() or ds_is_older('1.4.0.0'),\n                    reason=\"This test is only required if perl is enabled, and requires root.\")\ndef test_dscreate(request):\n    \"\"\"Test that dscreate works, we need this for now until setup-ds.pl is\n    fully discontinued.\n\n    :id: 5bf75c47-a283-430e-a65c-3c5fd8dbadb9\n    :setup: None\n    :steps:\n        1. Create template file for dscreate\n        2. Create instance using template file\n    :expectedresults:\n        1. Should succeeds\n        2. Should succeeds\n    \"\"\"\n\n    template_file = \"/tmp/dssetup.inf\"\n    template_text = \"\"\"[general]\nconfig_version = 2\n# This invalid hostname ...\nfull_machine_name = localhost.localdomain\n# Means we absolutely require this.\nstrict_host_checking = False\n# In tests, we can be run in containers, NEVER trust\n# that systemd is there, or functional in any capacity\nsystemd = False\n\n[slapd]\ninstance_name = test_dscreate\nroot_dn = cn=directory manager\nroot_password = someLongPassword_123\n# We do not have access to high ports in containers,\n# so default to something higher.\nport = 38999\nsecure_port = 63699\n\n\n[backend-userroot]\nsuffix = dc=example,dc=com\nsample_entries = yes\n\"\"\"\n\n    with open(template_file, \"w\") as template_fd:\n        template_fd.write(template_text)\n\n    # Unset PYTHONPATH to avoid mixing old CLI tools and new lib389\n    tmp_env = os.environ\n    if \"PYTHONPATH\" in tmp_env:\n        del tmp_env[\"PYTHONPATH\"]\n    try:\n        subprocess.check_call([\n            'dscreate',\n            'from-file',\n            template_file\n        ], env=tmp_env)\n    except subprocess.CalledProcessError as e:\n        log.fatal(\"dscreate failed!  Error ({}) {}\".format(e.returncode, e.output))\n        assert False\n\n    def fin():\n        os.remove(template_file)\n        try:\n            subprocess.check_call(['dsctl', 'test_dscreate', 'remove', '--do-it'])\n        except subprocess.CalledProcessError as e:\n            log.fatal(\"Failed to remove test instance  Error ({}) {}\".format(e.returncode, e.output))\n\n    request.addfinalizer(fin)\n\n\n@pytest.fixture(scope=\"function\")\ndef dscreate_long_instance(request):\n    template_file = \"/tmp/dssetup.inf\"\n    longname_serverid = \"test-longname-deadbeef-deadbeef-deadbeef-deadbeef-deadbeef\"\n    template_text = \"\"\"[general]\nconfig_version = 2\n# This invalid hostname ...\nfull_machine_name = localhost.localdomain\n# Means we absolutely require this.\nstrict_host_checking = False\n# In tests, we can be run in containers, NEVER trust\n# that systemd is there, or functional in any capacity\nsystemd = False\n\n[slapd]\ninstance_name = %s\nroot_dn = cn=directory manager\nroot_password = someLongPassword_123\n# We do not have access to high ports in containers,\n# so default to something higher.\nport = 38999\nsecure_port = 63699\n\n\n[backend-userroot]\nsuffix = dc=example,dc=com\nsample_entries = yes\n\"\"\" % longname_serverid\n\n    with open(template_file, \"w\") as template_fd:\n        template_fd.write(template_text)\n\n    # Unset PYTHONPATH to avoid mixing old CLI tools and new lib389\n    tmp_env = os.environ\n    if \"PYTHONPATH\" in tmp_env:\n        del tmp_env[\"PYTHONPATH\"]\n    try:\n        subprocess.check_call([\n            'dscreate',\n            'from-file',\n            template_file\n        ], env=tmp_env)\n    except subprocess.CalledProcessError as e:\n        log.fatal(\"dscreate failed!  Error ({}) {}\".format(e.returncode, e.output))\n        assert False\n\n    inst = DirSrv(verbose=True, external_log=log)\n    dse_ldif = DSEldif(inst,\n                       serverid=longname_serverid)\n\n    socket_path = dse_ldif.get(\"cn=config\", \"nsslapd-ldapifilepath\")\n    inst.local_simple_allocate(\n       serverid=longname_serverid,\n       ldapuri=f\"ldapi://{socket_path[0].replace('/', '%2f')}\",\n       password=\"someLongPassword_123\"\n    )\n    inst.ldapi_enabled = 'on'\n    inst.ldapi_socket = socket_path\n    inst.ldapi_autobind = 'off'\n    try:\n        inst.open()\n    except:\n        log.fatal(\"Failed to connect via ldapi to %s instance\" % longname_serverid)\n        os.remove(template_file)\n        try:\n            subprocess.check_call(['dsctl', longname_serverid, 'remove', '--do-it'])\n        except subprocess.CalledProcessError as e:\n            log.fatal(\"Failed to remove test instance  Error ({}) {}\".format(e.returncode, e.output))\n\n    def fin():\n        os.remove(template_file)\n        try:\n            subprocess.check_call(['dsctl', longname_serverid, 'remove', '--do-it'])\n        except subprocess.CalledProcessError as e:\n            log.fatal(\"Failed to remove test instance  Error ({}) {}\".format(e.returncode, e.output))\n\n    request.addfinalizer(fin)\n\n    return inst\n\n\n@pytest.mark.skipif(not get_user_is_root() or ds_is_older('1.4.2.0'),\n                    reason=\"This test is only required with new admin cli, and requires root.\")\n@pytest.mark.bz1748016\n@pytest.mark.ds50581\ndef test_dscreate_ldapi(dscreate_long_instance):\n    \"\"\"Test that an instance with a long name can\n    handle ldapi connection using a long socket name\n\n    :id: 5d72d955-aff8-4741-8c9a-32c1c707cf1f\n    :setup: None\n    :steps:\n        1. Ccreate an instance with a long serverId name, that open a ldapi connection\n        2. Connect with ldapi, that hit 50581 and crash the instance\n    :expectedresults:\n        1. Should succeeds\n        2. Should succeeds\n    \"\"\"\n\n    root_dse = RootDSE(dscreate_long_instance)\n    log.info(root_dse.get_supported_ctrls())\n\n\n@pytest.mark.skipif(not get_user_is_root() or ds_is_older('1.4.2.0'),\n                    reason=\"This test is only required with new admin cli, and requires root.\")\n@pytest.mark.bz1715406\n@pytest.mark.ds50923\ndef test_dscreate_multiple_dashes_name(dscreate_long_instance):\n    \"\"\"Test that an instance with a multiple dashes in the name\n    can be removed with dsctl --remove-all\n\n    :id: 265c3ac7-5ba6-4278-b8f4-4e7692afd1a5\n    :setup: An instance with a few dashes in its name\n    :steps:\n        1. Run 'dsctl --remove-all' command\n        2. Check if the instance exists\n    :expectedresults:\n        1. Should succeeds\n        2. Instance doesn't exists\n    \"\"\"\n\n    p = run(['dsctl', '--remove-all'], stdout=PIPE, input='Yes\\n', encoding='ascii')\n    assert not dscreate_long_instance.exists()\n\n\n@pytest.fixture(scope=\"module\", params=('c=uk', 'cn=test_user', 'dc=example,dc=com', 'o=south', 'ou=sales', 'wrong=some_value'))\ndef dscreate_test_rdn_value(request):\n    template_file = \"/tmp/dssetup.inf\"\n    template_text = f\"\"\"[general]\nconfig_version = 2\n# This invalid hostname ...\nfull_machine_name = localhost.localdomain\n# Means we absolutely require this.\nstrict_host_checking = False\n# In tests, we can be run in containers, NEVER trust\n# that systemd is there, or functional in any capacity\nsystemd = False\n\n[slapd]\ninstance_name = test_different_rdn\nroot_dn = cn=directory manager\nroot_password = someLongPassword_123\n# We do not have access to high ports in containers,\n# so default to something higher.\nport = 38999\nsecure_port = 63699\n\n[backend-userroot]\ncreate_suffix_entry = True\nsuffix = {request.param}\n\"\"\"\n\n    with open(template_file, \"w\") as template_fd:\n        template_fd.write(template_text)\n\n    # Unset PYTHONPATH to avoid mixing old CLI tools and new lib389\n    tmp_env = os.environ\n    if \"PYTHONPATH\" in tmp_env:\n        del tmp_env[\"PYTHONPATH\"]\n\n    def fin():\n        os.remove(template_file)\n        if request.param != \"wrong=some_value\":\n            try:\n                subprocess.check_call(['dsctl', 'test_different_rdn', 'remove', '--do-it'])\n            except subprocess.CalledProcessError as e:\n                log.fatal(f\"Failed to remove test instance  Error ({e.returncode}) {e.output}\")\n        else:\n            log.info(\"Wrong RDN is passed, instance not created\")\n    request.addfinalizer(fin)\n    return template_file, tmp_env, request.param,\n\n\n@pytest.mark.skipif(not get_user_is_root() or ds_is_older('1.4.0.0'),\n                    reason=\"This test is only required with new admin cli, and requires root.\")\n@pytest.mark.bz1807419\n@pytest.mark.ds50928\ndef test_dscreate_with_different_rdn(dscreate_test_rdn_value):\n    \"\"\"Test that dscreate works with different RDN attributes as suffix\n\n    :id: 77ed6300-6a2f-4e79-a862-1f1105f1e3ef\n    :customerscenario: True\n    :parametrized: yes\n    :setup: None\n    :steps:\n        1. Create template file for dscreate with different RDN attributes as suffix\n        2. Create instance using template file\n        3. Create instance with 'wrong=some_value' as suffix's RDN attribute\n    :expectedresults:\n        1. Should succeeds\n        2. Should succeeds\n        3. Should fail\n    \"\"\"\n    try:\n        subprocess.check_call([\n            'dscreate',\n            'from-file',\n            dscreate_test_rdn_value[0]\n        ], env=dscreate_test_rdn_value[1])\n    except subprocess.CalledProcessError as e:\n        log.fatal(f\"dscreate failed!  Error ({e.returncode}) {e.output}\")\n        if  dscreate_test_rdn_value[2] != \"wrong=some_value\":\n            assert False\n        else:\n            assert True\n\n\nif __name__ == '__main__':\n    # Run isolated\n    # -s for DEBUG mode\n    CURRENT_FILE = os.path.realpath(__file__)\n    pytest.main(\"-s %s\" % CURRENT_FILE)\n", "/** BEGIN COPYRIGHT BLOCK\n * Copyright (C) 2001 Sun Microsystems, Inc. Used by permission.\n * Copyright (C) 2005 Red Hat, Inc.\n * All rights reserved.\n *\n * License: GPL (version 3 or any later version).\n * See LICENSE for details.\n * END COPYRIGHT BLOCK **/\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n/* bind.c  - ldbm backend bind and unbind routines */\n\n#include \"back-ldbm.h\"\n\nint\nldbm_back_bind(Slapi_PBlock *pb)\n{\n    backend *be;\n    ldbm_instance *inst;\n    ber_tag_t method;\n    struct berval *cred;\n    struct ldbminfo *li;\n    struct backentry *e;\n    Slapi_Attr *attr;\n    Slapi_Value **bvals;\n    entry_address *addr;\n    back_txn txn = {NULL};\n    int rc = SLAPI_BIND_SUCCESS;\n    int result_sent = 0;\n\n    /* get parameters */\n    slapi_pblock_get(pb, SLAPI_BACKEND, &be);\n    slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &li);\n    slapi_pblock_get(pb, SLAPI_TARGET_ADDRESS, &addr);\n    slapi_pblock_get(pb, SLAPI_BIND_METHOD, &method);\n    slapi_pblock_get(pb, SLAPI_BIND_CREDENTIALS, &cred);\n    slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn);\n\n    if (!txn.back_txn_txn) {\n        dblayer_txn_init(li, &txn);\n        slapi_pblock_set(pb, SLAPI_TXN, txn.back_txn_txn);\n    }\n\n    inst = (ldbm_instance *)be->be_instance_info;\n    if (inst->inst_ref_count) {\n        slapi_counter_increment(inst->inst_ref_count);\n    } else {\n        slapi_log_err(SLAPI_LOG_ERR, \"ldbm_back_bind\",\n                      \"instance %s does not exist.\\n\", inst->inst_name);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    /* always allow noauth simple binds (front end will send the result) */\n    if (method == LDAP_AUTH_SIMPLE && cred->bv_len == 0) {\n        rc = SLAPI_BIND_ANONYMOUS;\n        goto bail;\n    }\n\n    /*\n     * find the target entry.  find_entry() takes care of referrals\n     *   and sending errors if the entry does not exist.\n     */\n    if ((e = find_entry(pb, be, addr, &txn, &result_sent)) == NULL) {\n        rc = SLAPI_BIND_FAIL;\n        /* In the failure case, the result is supposed to be sent in the backend. */\n        if (!result_sent) {\n            slapi_send_ldap_result(pb, LDAP_INAPPROPRIATE_AUTH, NULL, NULL, 0, NULL);\n        }\n        goto bail;\n    }\n\n    switch (method) {\n    case LDAP_AUTH_SIMPLE: {\n        Slapi_Value cv;\n        if (slapi_entry_attr_find(e->ep_entry, \"userpassword\", &attr) != 0) {\n            slapi_send_ldap_result(pb, LDAP_INAPPROPRIATE_AUTH, NULL,\n                                   NULL, 0, NULL);\n            CACHE_RETURN(&inst->inst_cache, &e);\n            rc = SLAPI_BIND_FAIL;\n            goto bail;\n        }\n        bvals = attr_get_present_values(attr);\n        slapi_value_init_berval(&cv, cred);\n        if (slapi_pw_find_sv(bvals, &cv) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Invalid credentials\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            CACHE_RETURN(&inst->inst_cache, &e);\n            value_done(&cv);\n            rc = SLAPI_BIND_FAIL;\n            goto bail;\n        }\n        value_done(&cv);\n    } break;\n\n    default:\n        slapi_send_ldap_result(pb, LDAP_STRONG_AUTH_NOT_SUPPORTED, NULL,\n                               \"auth method not supported\", 0, NULL);\n        CACHE_RETURN(&inst->inst_cache, &e);\n        rc = SLAPI_BIND_FAIL;\n        goto bail;\n    }\n\n    CACHE_RETURN(&inst->inst_cache, &e);\nbail:\n    if (inst->inst_ref_count) {\n        slapi_counter_decrement(inst->inst_ref_count);\n    }\n    /* success:  front end will send result */\n    return rc;\n}\n", "/** BEGIN COPYRIGHT BLOCK\n * Copyright (C) 2001 Sun Microsystems, Inc. Used by permission.\n * Copyright (C) 2005 Red Hat, Inc.\n * All rights reserved.\n *\n * License: GPL (version 3 or any later version).\n * See LICENSE for details.\n * END COPYRIGHT BLOCK **/\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n/*\n * dse.c - DSE (DSA-Specific Entry) persistent storage.\n *\n * The DSE store is an LDIF file contained in the file dse.ldif.\n * The file is located in the directory specified with '-D'\n * when staring the server.\n *\n * In core, the DSEs are stored in an AVL tree, keyed on\n * DN.  Whenever a modification is made to a DSE, the\n * in-core entry is updated, then dse_write_file() is\n * called to commit the changes to disk.\n *\n * This is designed for a small number of DSEs, say\n * a maximum of 10 or 20.  If large numbers of DSEs\n * need to be stored, this approach of writing out\n * the entire contents on every modification will\n * be insufficient.\n *\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <prio.h>\n#include <prcountr.h>\n#include \"slap.h\"\n#include <pwd.h>\n/* Needed to access read_config_dse */\n#include \"proto-slap.h\"\n\n#include <unistd.h> /* provides fsync/close */\n\n/* #define SLAPI_DSE_DEBUG */ /* define this to force trace log    */\n                              /* messages to always be logged        */\n\n#ifdef SLAPI_DSE_DEBUG\n#define SLAPI_DSE_TRACELEVEL SLAPI_LOG_INFO\n#else /* SLAPI_DSE_DEBUG */\n#define SLAPI_DSE_TRACELEVEL SLAPI_LOG_TRACE\n#endif /* SLAPI_DSE_DEBUG */\n\n#define SCHEMA_VIOLATION -2\n#define STOP_TRAVERSAL -2\n\n/* This is returned by dupentry_replace if the duplicate entry was found and\n   replaced.  This is returned up through the avl_insert() in\n   dse_replace_entry().  Otherwise, if avl_insert() returns 0, the\n   entry was added i.e. a duplicate was not found.\n*/\n#define DSE_ENTRY_WAS_REPLACED -3\n/* This is returned by dupentry_merge if the duplicate entry was found and\n   merged.  This is returned up through the avl_insert() in dse_add_entry_pb().\n   Otherwise, if avl_insert() returns 0, the\n   entry was added i.e. a duplicate was not found.\n*/\n#define DSE_ENTRY_WAS_MERGED -4\n\n/* some functions can be used either from within a lock or \"standalone\" */\n#define DSE_USE_LOCK 1\n#define DSE_NO_LOCK 0\n\nstruct dse_callback\n{\n    int operation;\n    int flags;\n    Slapi_DN *base;\n    int scope;\n    char *filter;              /* NULL means match all entries */\n    Slapi_Filter *slapifilter; /* NULL means match all entries */\n    int (*fn)(Slapi_PBlock *, Slapi_Entry *, Slapi_Entry *, int *, char *, void *);\n    void *fn_arg;\n    struct slapdplugin *plugin;\n    struct dse_callback *next;\n};\n\nstruct dse\n{\n    char *dse_filename;    /* these are the primary files which get read from */\n    char *dse_tmpfile;     /* and written to when changes are made via LDAP */\n    char *dse_fileback;    /* contain the latest info, just before a new change */\n    char *dse_filestartOK; /* contain the latest info with which the server has successfully started */\n    char *dse_configdir;   /* The location of config files - allows us to fsync the dir post rename */\n    Avlnode *dse_tree;\n    struct dse_callback *dse_callback;\n    Slapi_RWLock *dse_rwlock;        /* a read-write lock to protect the whole dse backend */\n    char **dse_filelist;             /* these are additional read only files used to */\n                                     /* initialize the dse */\n    int dse_is_updateable;           /* if non-zero, this DSE can be written to */\n    int dse_readonly_error_reported; /* used to ensure that read-only errors are logged only once */\n};\n\nstruct dse_node\n{\n    Slapi_Entry *entry;\n};\n\n/* search set stuff - used to pass search results to the frontend */\ntypedef struct dse_search_set\n{\n    DataList dl;\n    int current_entry;\n} dse_search_set;\n\nstatic int dse_permission_to_write(struct dse *pdse, int loglevel);\nstatic int dse_write_file_nolock(struct dse *pdse);\nstatic int dse_apply_nolock(struct dse *pdse, IFP fp, caddr_t arg);\nstatic int dse_replace_entry(struct dse *pdse, Slapi_Entry *e, int write_file, int use_lock);\nstatic dse_search_set *dse_search_set_new(void);\nstatic void dse_search_set_delete(dse_search_set *ss);\nstatic void dse_search_set_clean(dse_search_set *ss);\nstatic void dse_free_entry(void **data);\nstatic void dse_search_set_add_entry(dse_search_set *ss, Slapi_Entry *e);\nstatic Slapi_Entry *dse_search_set_get_next_entry(dse_search_set *ss);\nstatic int dse_add_entry_pb(struct dse *pdse, Slapi_Entry *e, Slapi_PBlock *pb);\nstatic struct dse_node *dse_find_node(struct dse *pdse, const Slapi_DN *dn);\nstatic int dse_modify_plugin(Slapi_Entry *pre_entry, Slapi_Entry *post_entry, char *returntext);\nstatic int dse_add_plugin(Slapi_Entry *entry, char *returntext);\nstatic int dse_delete_plugin(Slapi_Entry *entry, char *returntext);\nstatic int dse_pre_modify_plugin(Slapi_Entry *entryBefore, Slapi_Entry *entryAfter, LDAPMod **mods);\n\n/*\n  richm: In almost all modes e.g. db2ldif, ldif2db, etc. we do not need/want\n  to write out the dse.ldif and ldbm.ldif files.  The only mode which really\n  needs to write out the file is the regular server mode.  The variable\n  dont_ever_write_dse_files tells dse_write_file_nolock whether or not to write\n  the .ldif file for the entry.  The default is 1, which means never write the\n  file.  The server, when it starts up in regular mode, must call\n  dse_unset_dont_ever_write_dse_files() to enable this file to be written\n*/\nstatic int dont_ever_write_dse_files = 1;\n\n/* Forward declarations */\nstatic int entry_dn_cmp(caddr_t d1, caddr_t d2);\nstatic int dupentry_disallow(caddr_t d1, caddr_t d2);\nstatic int dupentry_merge(caddr_t d1, caddr_t d2);\nstatic int dse_write_entry(caddr_t data, caddr_t arg);\nstatic int ldif_record_end(char *p);\nstatic int dse_call_callback(struct dse *pdse, Slapi_PBlock *pb, int operation, int flags, Slapi_Entry *entryBefore, Slapi_Entry *entryAfter, int *returncode, char *returntext);\n\n/*\n * Map a DN onto a dse_node.\n * Returns NULL if not found.\n * You must have a read or write lock on the dse_rwlock while\n * using the returned node.\n */\nstatic struct dse_node *\ndse_find_node(struct dse *pdse, const Slapi_DN *dn)\n{\n    struct dse_node *n = NULL;\n    if (NULL != dn) {\n        struct dse_node searchNode;\n        Slapi_Entry *fe = slapi_entry_alloc();\n        slapi_entry_init(fe, NULL, NULL);\n        slapi_entry_set_sdn(fe, dn);\n        searchNode.entry = fe;\n\n        n = (struct dse_node *)avl_find(pdse->dse_tree, &searchNode, entry_dn_cmp);\n\n        slapi_entry_free(fe);\n    }\n    return n;\n}\n\nstatic int counters_created = 0;\nPR_DEFINE_COUNTER(dse_entries_exist);\n\n/*\n * Map a DN onto a real Entry.\n * Returns NULL if not found.\n */\nstatic Slapi_Entry *\ndse_get_entry_copy(struct dse *pdse, const Slapi_DN *dn, int use_lock)\n{\n    Slapi_Entry *e = NULL;\n    struct dse_node *n;\n\n    if (use_lock == DSE_USE_LOCK && pdse->dse_rwlock) {\n        slapi_rwlock_rdlock(pdse->dse_rwlock);\n    }\n\n    n = dse_find_node(pdse, dn);\n    if (n != NULL) {\n        e = slapi_entry_dup(n->entry);\n    }\n\n    if (use_lock == DSE_USE_LOCK && pdse->dse_rwlock) {\n        slapi_rwlock_unlock(pdse->dse_rwlock);\n    }\n\n    return e;\n}\n\nstatic struct dse_callback *\ndse_callback_new(int operation,\n                 int flags,\n                 const Slapi_DN *base,\n                 int scope,\n                 const char *filter,\n                 dseCallbackFn fn,\n                 void *fn_arg,\n                 struct slapdplugin *plugin)\n{\n    struct dse_callback *p = NULL;\n    p = (struct dse_callback *)slapi_ch_calloc(1, sizeof(struct dse_callback));\n    if (p != NULL) {\n        p->operation = operation;\n        p->flags = flags;\n        p->base = slapi_sdn_dup(base);\n        p->scope = scope;\n        if (NULL == filter) {\n            p->filter = NULL;\n            p->slapifilter = NULL;\n        } else {\n            p->filter = slapi_ch_strdup(filter);\n            p->slapifilter = slapi_str2filter(p->filter);\n            filter_normalize(p->slapifilter);\n        }\n        p->fn = fn;\n        p->fn_arg = fn_arg;\n        p->plugin = plugin;\n        p->next = NULL;\n    }\n    return p;\n}\n\nstatic void\ndse_callback_delete(struct dse_callback **pp)\n{\n    if (pp != NULL) {\n        slapi_sdn_free(&((*pp)->base));\n        slapi_ch_free((void **)&((*pp)->filter));\n        slapi_filter_free((*pp)->slapifilter, 1);\n        slapi_ch_free((void **)pp);\n    }\n}\n\nstatic void\ndse_callback_deletelist(struct dse_callback **pp)\n{\n    if (pp != NULL) {\n        struct dse_callback *p, *n;\n        for (p = *pp; p != NULL;) {\n            n = p->next;\n            dse_callback_delete(&p);\n            p = n;\n        }\n    }\n}\n\n/*\n  Makes a copy of the entry passed in, so it's const\n*/\nstatic struct dse_node *\ndse_node_new(const Slapi_Entry *entry)\n{\n    struct dse_node *p = NULL;\n    p = (struct dse_node *)slapi_ch_malloc(sizeof(struct dse_node));\n    if (p != NULL) {\n        p->entry = slapi_entry_dup(entry);\n    }\n    if (!counters_created) {\n        PR_CREATE_COUNTER(dse_entries_exist, \"DSE\", \"entries\", \"\");\n        counters_created = 1;\n    }\n    PR_INCREMENT_COUNTER(dse_entries_exist);\n    return p;\n}\n\nstatic void\ndse_node_delete(struct dse_node **pp)\n{\n    slapi_entry_free((*pp)->entry);\n    slapi_ch_free((void **)&(*pp));\n    PR_DECREMENT_COUNTER(dse_entries_exist);\n}\n\nstatic void\ndse_callback_addtolist(struct dse_callback **pplist, struct dse_callback *p)\n{\n    if (pplist != NULL) {\n        p->next = NULL;\n        if (*pplist == NULL) {\n            *pplist = p;\n        } else {\n            struct dse_callback *t = *pplist;\n            for (; t->next != NULL; t = t->next)\n                ;\n            t->next = p;\n        }\n    }\n}\n\nstatic void\ndse_callback_removefromlist(struct dse_callback **pplist, int operation, int flags, const Slapi_DN *base, int scope, const char *filter, dseCallbackFn fn)\n{\n    if (pplist != NULL) {\n        struct dse_callback *t = *pplist;\n        struct dse_callback *prev = NULL;\n        for (; t != NULL;) {\n            if ((t->operation & operation) && (t->flags & flags) &&\n                (t->fn == fn) && (scope == t->scope) &&\n                (slapi_sdn_compare(base, t->base) == 0) &&\n                ((NULL == filter && NULL == t->filter) || /* both are NULL OR */\n                 ((filter && t->filter) &&                /* both are not NULL AND match. */\n                  (strcasecmp(filter, t->filter) == 0)))) {\n                if (prev == NULL) {\n                    *pplist = t->next;\n                } else {\n                    prev->next = t->next;\n                }\n                dse_callback_delete(&t);\n                t = NULL;\n            } else {\n                prev = t;\n                t = t->next;\n            }\n        }\n    }\n}\n\n/*\n * Create a new dse structure.\n */\nstruct dse *\ndse_new(char *filename, char *tmpfilename, char *backfilename, char *startokfilename, const char *configdir)\n{\n    struct dse *pdse = NULL;\n    char *realconfigdir = NULL;\n\n    if (configdir != NULL) {\n        realconfigdir = slapi_ch_strdup(configdir);\n    } else {\n        realconfigdir = config_get_configdir();\n    }\n    if (realconfigdir != NULL) {\n        pdse = (struct dse *)slapi_ch_calloc(1, sizeof(struct dse));\n        if (pdse != NULL) {\n            pdse->dse_rwlock = slapi_new_rwlock();\n            /* Set the full path name for the config DSE entry */\n            if (!strstr(filename, realconfigdir)) {\n                pdse->dse_filename = slapi_ch_smprintf(\"%s/%s\", realconfigdir, filename);\n            } else {\n                pdse->dse_filename = slapi_ch_strdup(filename);\n            }\n\n            if (!strstr(tmpfilename, realconfigdir)) {\n                pdse->dse_tmpfile = slapi_ch_smprintf(\"%s/%s\", realconfigdir, tmpfilename);\n            } else {\n                pdse->dse_tmpfile = slapi_ch_strdup(tmpfilename);\n            }\n\n            pdse->dse_configdir = slapi_ch_strdup(realconfigdir);\n\n            if (backfilename != NULL) {\n                if (!strstr(backfilename, realconfigdir)) {\n                    pdse->dse_fileback = slapi_ch_smprintf(\"%s/%s\", realconfigdir, backfilename);\n                } else {\n                    pdse->dse_fileback = slapi_ch_strdup(backfilename);\n                }\n            } else {\n                pdse->dse_fileback = NULL;\n            }\n\n            if (startokfilename != NULL) {\n                if (!strstr(startokfilename, realconfigdir)) {\n                    pdse->dse_filestartOK = slapi_ch_smprintf(\"%s/%s\", realconfigdir, startokfilename);\n                } else {\n                    pdse->dse_filestartOK = slapi_ch_strdup(startokfilename);\n                }\n            } else {\n                pdse->dse_filestartOK = NULL;\n            }\n\n            pdse->dse_tree = NULL;\n            pdse->dse_callback = NULL;\n            pdse->dse_is_updateable = dse_permission_to_write(pdse,\n                                                              SLAPI_LOG_TRACE);\n        }\n        slapi_ch_free((void **)&realconfigdir);\n    }\n    return pdse;\n}\n\n/*\n * Create a new dse structure with a file list\n */\nstruct dse *\ndse_new_with_filelist(char *filename, char *tmpfilename, char *backfilename, char *startokfilename, const char *configdir, char **filelist)\n{\n    struct dse *newdse = dse_new(filename, tmpfilename, backfilename, startokfilename, configdir);\n    newdse->dse_filelist = filelist;\n    return newdse;\n}\n\nstatic int\ndse_internal_delete_entry(caddr_t data, caddr_t arg __attribute__((unused)))\n{\n    struct dse_node *n = (struct dse_node *)data;\n    dse_node_delete(&n);\n    return 0;\n}\n\n/*\n * Get rid of a dse structure.\n */\nint\ndse_destroy(struct dse *pdse)\n{\n    int nentries = 0;\n\n    if (NULL == pdse) {\n        return 0; /* no one checks this return value */\n    }\n    if (pdse->dse_rwlock)\n        slapi_rwlock_wrlock(pdse->dse_rwlock);\n    slapi_ch_free((void **)&(pdse->dse_filename));\n    slapi_ch_free((void **)&(pdse->dse_tmpfile));\n    slapi_ch_free((void **)&(pdse->dse_fileback));\n    slapi_ch_free((void **)&(pdse->dse_filestartOK));\n    slapi_ch_free((void **)&(pdse->dse_configdir));\n    dse_callback_deletelist(&pdse->dse_callback);\n    charray_free(pdse->dse_filelist);\n    nentries = avl_free(pdse->dse_tree, dse_internal_delete_entry);\n    if (pdse->dse_rwlock) {\n        slapi_rwlock_unlock(pdse->dse_rwlock);\n        slapi_destroy_rwlock(pdse->dse_rwlock);\n    }\n    slapi_ch_free((void **)&pdse);\n    slapi_log_err(SLAPI_DSE_TRACELEVEL, \"dse_destroy\", \"Removed [%d] entries from the dse tree.\\n\",\n                  nentries);\n\n    return 0; /* no one checks this return value */\n}\n\n/*\n * Get rid of a dse structure.\n */\nint\ndse_deletedse(Slapi_PBlock *pb)\n{\n    struct dse *pdse = NULL;\n\n    slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse);\n\n    if (pdse) {\n        dse_destroy(pdse);\n    }\n\n    /* data is freed, so make sure no one tries to use it */\n    slapi_pblock_set(pb, SLAPI_PLUGIN_PRIVATE, NULL);\n\n    return 0;\n}\n\nstatic char *subordinatecount = \"numsubordinates\";\n\n/*\n * Get the number of subordinates for this entry.\n */\nstatic size_t\ndse_numsubordinates(Slapi_Entry *entry)\n{\n    int ret = 0;\n    Slapi_Attr *read_attr = NULL;\n    size_t current_sub_count = 0;\n\n    /* Get the present value of the subcount attr, or 0 if not present */\n    ret = slapi_entry_attr_find(entry, subordinatecount, &read_attr);\n    if (0 == ret) {\n        /* decode the value */\n        Slapi_Value *sval;\n        slapi_attr_first_value(read_attr, &sval);\n        if (sval != NULL) {\n            const struct berval *bval = slapi_value_get_berval(sval);\n            if (NULL != bval)\n                current_sub_count = atol(bval->bv_val);\n        }\n    }\n    return current_sub_count;\n}\n\n/*\n * Update the numsubordinates count.\n * mod_op is either an Add or Delete.\n */\nstatic void\ndse_updateNumSubordinates(Slapi_Entry *entry, int op)\n{\n    int ret = 0;\n    int mod_op = 0;\n    Slapi_Attr *read_attr = NULL;\n    size_t current_sub_count = 0;\n    int already_present = 0;\n\n    /* For now, we're only interested in subordinatecount.\n       We first examine the present value for the attribute.\n       If it isn't present and we're adding, we assign value 1 to the attribute and add it.\n       If it is present, we increment or decrement depending upon whether we're adding or deleting.\n       If the value after decrementing is zero, we remove it.\n    */\n\n    /* Get the present value of the subcount attr, or 0 if not present */\n    ret = slapi_entry_attr_find(entry, subordinatecount, &read_attr);\n    if (0 == ret) {\n        /* decode the value */\n        Slapi_Value *sval;\n        slapi_attr_first_value(read_attr, &sval);\n        if (sval != NULL) {\n            const struct berval *bval = slapi_value_get_berval(sval);\n            if (bval != NULL) {\n                already_present = 1;\n                current_sub_count = atol(bval->bv_val);\n            }\n        }\n    }\n\n    /* are we adding ? */\n    if ((SLAPI_OPERATION_ADD == op) && !already_present) {\n        /* If so, and the parent entry does not already have a subcount attribute, we need to add it */\n        mod_op = LDAP_MOD_ADD;\n    } else {\n        if (SLAPI_OPERATION_DELETE == op) {\n            if (!already_present) {\n                /* This means that something is wrong---deleting a child but no subcount present on parent */\n                slapi_log_err(SLAPI_LOG_ERR, \"dse_updateNumSubordinates\",\n                              \"numsubordinates assertion failure\\n\");\n                return;\n            } else {\n                if (current_sub_count == 1) {\n                    mod_op = LDAP_MOD_DELETE;\n                } else {\n                    mod_op = LDAP_MOD_REPLACE;\n                }\n            }\n        } else {\n            mod_op = LDAP_MOD_REPLACE;\n        }\n    }\n\n    /* Now compute the new value */\n    if (SLAPI_OPERATION_ADD == op) {\n        current_sub_count++;\n    } else {\n        current_sub_count--;\n    }\n    {\n        char value_buffer[22] = {0}; /* enough digits for 2^64 children */\n        struct berval *vals[2];\n        struct berval val;\n        vals[0] = &val;\n        vals[1] = NULL;\n        sprintf(value_buffer, \"%lu\", (long unsigned int)current_sub_count);\n        val.bv_val = value_buffer;\n        val.bv_len = strlen(val.bv_val);\n        switch (mod_op) {\n        case LDAP_MOD_ADD:\n            attrlist_merge(&entry->e_attrs, subordinatecount, vals);\n            break;\n        case LDAP_MOD_REPLACE:\n            attrlist_replace(&entry->e_attrs, subordinatecount, vals);\n            break;\n        case LDAP_MOD_DELETE:\n            attrlist_delete(&entry->e_attrs, subordinatecount);\n            break;\n        }\n    }\n}\n\n/* the write lock should always be acquired before calling this function */\nstatic void\ndse_updateNumSubOfParent(struct dse *pdse, const Slapi_DN *child, int op)\n{\n    Slapi_DN parent;\n    slapi_sdn_init(&parent);\n    slapi_sdn_get_parent(child, &parent);\n    if (!slapi_sdn_isempty(&parent)) {\n        /* no lock because caller should already have the write lock */\n        Slapi_Entry *parententry = dse_get_entry_copy(pdse, &parent, DSE_NO_LOCK);\n        if (parententry != NULL) {\n            /* Decrement the numsubordinate count of the parent entry */\n            dse_updateNumSubordinates(parententry, op);\n            /* no lock because caller should always have the write lock */\n            dse_replace_entry(pdse, parententry, 0, DSE_NO_LOCK);\n            slapi_entry_free(parententry);\n        }\n    }\n    slapi_sdn_done(&parent);\n}\n\n/* check if a file is valid, or if a provided backup file can be used.\n * there is no way to determine if the file contents is usable, the only\n * checks that can be done is that the file exists and that it is not size 0\n */\nint\ndse_check_file(char *filename, char *backupname)\n{\n    int rc = 0; /* Fail */\n    PRFileInfo64 prfinfo;\n\n    if (PR_GetFileInfo64(filename, &prfinfo) == PR_SUCCESS) {\n        if (prfinfo.size > 0) {\n            /* File exists and has content. */\n            return 1;\n        } else {\n            slapi_log_err(SLAPI_LOG_INFO, \"dse_check_file\",\n                          \"The config %s has zero length. Attempting restore ... \\n\", filename);\n            rc = PR_Delete(filename);\n        }\n    } else {\n        slapi_log_err(SLAPI_LOG_INFO, \"dse_check_file\",\n                      \"The config %s can not be accessed. Attempting restore ... (reason: %d)\\n\", filename, rc);\n    }\n\n    if (backupname) {\n\n        if (PR_GetFileInfo64(backupname, &prfinfo) != PR_SUCCESS) {\n            slapi_log_err(SLAPI_LOG_INFO, \"dse_check_file\",\n                          \"The backup %s can not be accessed. Check it exists and permissions.\\n\", backupname);\n            return 0;\n        }\n\n        if (prfinfo.size <= 0) {\n            slapi_log_err(SLAPI_LOG_ERR, \"dse_check_file\",\n                      \"The backup file %s has zero length, refusing to restore it.\\n\", backupname);\n            return 0;\n        }\n\n        rc = PR_Rename(backupname, filename);\n        if (rc != PR_SUCCESS) {\n            slapi_log_err(SLAPI_LOG_INFO, \"dse_check_file\",\n                      \"The configuration file %s was NOT able to be restored from %s, error %d\\n\", filename, backupname, rc);\n            return 0;\n        }\n\n        slapi_log_err(SLAPI_LOG_INFO, \"dse_check_file\",\n                  \"The configuration file %s was restored from backup %s\\n\", filename, backupname);\n        return 1;\n\n    } else {\n        slapi_log_err(SLAPI_LOG_INFO, \"dse_check_file\", \"No backup filename provided.\\n\");\n        return 0;\n    }\n}\n\nstatic int\ndse_read_one_file(struct dse *pdse, const char *filename, Slapi_PBlock *pb, int primary_file)\n{\n    Slapi_Entry *e = NULL;\n    char *entrystr = NULL;\n    char *buf = NULL;\n    char *lastp = NULL;\n    int rc = 0; /* Fail */\n    PRInt32 nr = 0;\n    PRFileInfo64 prfinfo;\n    PRFileDesc *prfd = 0;\n    int schema_flags = 0;\n\n    slapi_pblock_get(pb, SLAPI_SCHEMA_FLAGS, &schema_flags);\n\n    if ((NULL != pdse) && (NULL != filename)) {\n        /* check if the \"real\" file exists and cam be used, if not try tmp as backup */\n        rc = dse_check_file((char *)filename, pdse->dse_tmpfile);\n        if (!rc) {\n            rc = dse_check_file((char *)filename, pdse->dse_fileback);\n        }\n\n        if ((rc = PR_GetFileInfo64(filename, &prfinfo)) != PR_SUCCESS) {\n            slapi_log_err(SLAPI_LOG_ERR, \"dse_read_one_file\",\n                          \"The configuration file %s could not be accessed, error %d\\n\",\n                          filename, rc);\n            rc = 0; /* Fail */\n        } else if ((prfd = PR_Open(filename, PR_RDONLY, SLAPD_DEFAULT_FILE_MODE)) == NULL) {\n            slapi_log_err(SLAPI_LOG_ERR, \"dse_read_one_file\",\n                          \"The configuration file %s could not be read. \" SLAPI_COMPONENT_NAME_NSPR \" %d (%s)\\n\",\n                          filename,\n                          PR_GetError(), slapd_pr_strerror(PR_GetError()));\n            rc = 0; /* Fail */\n        } else {\n            int done = 0;\n            /* read the entire file into core */\n            buf = slapi_ch_malloc(prfinfo.size + 1);\n            if ((nr = slapi_read_buffer(prfd, buf, prfinfo.size)) < 0) {\n                slapi_log_err(SLAPI_LOG_ERR, \"dse_read_one_file\",\n                              \"Could only read %d of %ld bytes from config file %s\\n\",\n                              nr, (long int)prfinfo.size, filename);\n                rc = 0; /* Fail */\n                done = 1;\n            }\n\n            (void)PR_Close(prfd);\n            buf[nr] = '\\0';\n\n            if (!done) {\n                int lineno = 1;\n                int lines = 0;\n                int dont_check_dups = 0;\n                int str2entry_flags = SLAPI_STR2ENTRY_EXPAND_OBJECTCLASSES |\n                                      SLAPI_STR2ENTRY_NOT_WELL_FORMED_LDIF;\n                if (schema_flags & DSE_SCHEMA_LOCKED)\n                    str2entry_flags |= SLAPI_STR2ENTRY_NO_SCHEMA_LOCK;\n\n                PR_ASSERT(pb);\n                slapi_pblock_get(pb, SLAPI_DSE_DONT_CHECK_DUPS, &dont_check_dups);\n                if (!dont_check_dups) {\n                    str2entry_flags |= SLAPI_STR2ENTRY_REMOVEDUPVALS;\n                }\n\n                /* Convert LDIF to entry structures */\n                rc = 1; /* assume we will succeed */\n                while ((entrystr = dse_read_next_entry(buf, &lastp)) != NULL) {\n                    char *p, *q;\n                    char errbuf[256];\n                    size_t estrlen = strlen(entrystr);\n                    size_t cpylen =\n                        (estrlen < sizeof(errbuf)) ? estrlen : sizeof(errbuf) - 1;\n\n                    memcpy(errbuf, entrystr, cpylen);\n                    errbuf[cpylen] = '\\0';\n\n                    lines = 1;\n                    p = entrystr;\n                    while ((q = strchr(p, '\\n'))) {\n                        p = q + 1;\n                        lines++;\n                    }\n\n                    e = slapi_str2entry(entrystr, str2entry_flags);\n                    if (e != NULL) {\n                        int returncode = 0;\n                        char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = {0};\n\n                        slapi_log_err(SLAPI_LOG_TRACE, \"dse_read_one_file\",\n                                      \" processing entry \\\"%s\\\" in file %s%s \"\n                                      \"(lineno: %d)\\n\",\n                                      slapi_entry_get_dn_const(e), filename,\n                                      primary_file ? \" (primary file)\" : \"\",\n                                      lineno);\n\n                        /* remove the numsubordinates attr, which may be bogus */\n                        slapi_entry_attr_delete(e, subordinatecount);\n\n                        /* set the \"primary file\" flag if appropriate */\n                        slapi_pblock_set(pb, SLAPI_DSE_IS_PRIMARY_FILE, &primary_file);\n                        if (dse_call_callback(pdse, pb, DSE_OPERATION_READ,\n                                              DSE_FLAG_PREOP, e, NULL, &returncode,\n                                              returntext) == SLAPI_DSE_CALLBACK_OK) {\n                            /*\n                             * This will free the entry if not added, so it is\n                             * definitely consumed by this call\n                             */\n                            if (dse_add_entry_pb(pdse, e, pb) == SCHEMA_VIOLATION) {\n                                /* schema violation, return failure */\n                                rc = 0;\n                            }\n                        } else /* free entry if not used */\n                        {\n                            slapi_log_err(SLAPI_LOG_FATAL,\n                                          \"dse_read_one_file\",\n                                          \"The entry %s in file %s \"\n                                          \"(lineno: %d) is invalid, \"\n                                          \"error code %d (%s) - %s\\n\",\n                                          slapi_entry_get_dn_const(e),\n                                          filename, lineno, returncode,\n                                          ldap_err2string(returncode),\n                                          returntext);\n                            slapi_entry_free(e);\n                            rc = 0; /* failure */\n                        }\n                    } else {\n                        slapi_log_err(SLAPI_LOG_ERR, \"dse_read_one_file\",\n                                      \"Parsing entry (lineno: %d) \"\n                                      \"in file %s failed.\\n\",\n                                      lineno, filename);\n                        slapi_log_err(SLAPI_LOG_ERR, \"dse_read_one_file\",\n                                      \"Invalid section [%s%s]\\n\",\n                                      errbuf, cpylen == estrlen ? \"\" : \" ...\");\n                        rc = 0; /* failure */\n                    }\n                    lineno += lines + 1 /* 1 is for a blank line. */;\n                }\n            }\n            slapi_ch_free((void **)&buf);\n        }\n    }\n\n    return rc;\n}\n\n/*\n * Read the file we were initialised with into memory.\n * If not NULL call entry_filter_fn on each entry as it's read.\n * The function is free to modify the entry before it's places\n * into the AVL tree. True means add the entry. False means don't.\n *\n * Return 1 for OK, 0 for Fail.\n */\nint\ndse_read_file(struct dse *pdse, Slapi_PBlock *pb)\n{\n    int rc = 1; /* Good */\n    int ii;\n    char **filelist = 0;\n    char *filename = 0;\n\n    filelist = charray_dup(pdse->dse_filelist);\n    filename = slapi_ch_strdup(pdse->dse_filename);\n\n    for (ii = 0; rc && filelist && filelist[ii]; ++ii) {\n        if (strcasecmp(filename, filelist[ii]) != 0) {\n            rc = dse_read_one_file(pdse, filelist[ii], pb, 0 /* not primary */);\n        }\n    }\n\n    if (rc) {\n        rc = dse_read_one_file(pdse, filename, pb, 1 /* primary file */);\n    }\n\n    charray_free(filelist);\n    slapi_ch_free((void **)&filename);\n\n    return rc;\n}\n\n/*\n * Structure to carry context information whilst\n * traversing the tree writing the entries to disk.\n */\ntypedef struct _fpw\n{\n    PRFileDesc *fpw_prfd;\n    int fpw_rc;\n    struct dse *fpw_pdse;\n} FPWrapper;\n\n\nstatic int\ndse_rw_permission_to_one_file(const char *name, int loglevel)\n{\n    PRErrorCode prerr = 0;\n    const char *accesstype = \"\";\n\n    if (NULL == name) {\n        return 1; /* file won't be used -- return \"sufficient permission\" */\n    }\n\n    if (PR_Access(name, PR_ACCESS_EXISTS) == PR_SUCCESS) {\n        /* file exists: check for read and write permission */\n        if (PR_Access(name, PR_ACCESS_WRITE_OK) != PR_SUCCESS) {\n            prerr = PR_GetError();\n            accesstype = \"write\";\n        } else if (PR_Access(name, PR_ACCESS_READ_OK) != PR_SUCCESS) {\n            prerr = PR_GetError();\n            accesstype = \"read\";\n        }\n    } else {\n        /* file does not exist: make sure we can create it */\n        PRFileDesc *prfd;\n\n        prfd = PR_Open(name, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE,\n                       SLAPD_DEFAULT_FILE_MODE);\n        if (NULL == prfd) {\n            prerr = PR_GetError();\n            accesstype = \"create\";\n        } else {\n            PR_Close(prfd);\n            PR_Delete(name);\n        }\n    }\n\n    if (prerr != 0) {\n        slapi_log_err(loglevel,\n                      \"dse_rw_permission_to_one_file\", \"Unable to %s \\\"%s\\\": \" SLAPI_COMPONENT_NAME_NSPR \" error %d (%s)\\n\",\n                      accesstype, name, prerr, slapd_pr_strerror(prerr));\n        return 0; /* insufficient permission */\n    } else {\n        return 1; /* sufficient permission */\n    }\n}\n\n\n/*\n * Check that we have permission to write to all the files that\n * dse_write_file_nolock() uses.\n * Returns a non-zero value if sufficient permission and 0 if not.\n */\nstatic int\ndse_permission_to_write(struct dse *pdse, int loglevel)\n{\n    int rc = 1; /* sufficient permission */\n\n    if (NULL != pdse->dse_filename) {\n        if (!dse_rw_permission_to_one_file(pdse->dse_filename, loglevel) ||\n            !dse_rw_permission_to_one_file(pdse->dse_fileback, loglevel) ||\n            !dse_rw_permission_to_one_file(pdse->dse_tmpfile, loglevel)) {\n            rc = 0; /* insufficient permission */\n        }\n    }\n\n    return rc;\n}\n\n\n/*\n * Check for read-only status and return an appropriate error to the\n * LDAP client.\n * Returns 0 if no error was returned and non-zero if one was.\n */\nstatic int\ndse_check_for_readonly_error(Slapi_PBlock *pb, struct dse *pdse)\n{\n    int rc = 0; /* default: no error */\n\n    if (pdse->dse_rwlock)\n        slapi_rwlock_rdlock(pdse->dse_rwlock);\n\n    if (!pdse->dse_is_updateable) {\n        if (!pdse->dse_readonly_error_reported) {\n            if (NULL != pdse->dse_filename) {\n                slapi_log_err(SLAPI_LOG_ERR, \"dse_check_for_readonly_error\",\n                              \"The DSE database stored in \\\"%s\\\" is not writeable\\n\",\n                              pdse->dse_filename);\n                /* log the details too */\n                (void)dse_permission_to_write(pdse, SLAPI_LOG_ERR);\n            }\n            pdse->dse_readonly_error_reported = 1;\n        }\n        rc = 1; /* return an error to the client */\n    }\n\n    if (pdse->dse_rwlock)\n        slapi_rwlock_unlock(pdse->dse_rwlock);\n\n    if (rc != 0) {\n        slapi_send_ldap_result(pb, LDAP_UNWILLING_TO_PERFORM, NULL,\n                               \"DSE database is read-only\", 0, NULL);\n    }\n\n    return rc; /* no error */\n}\n\n\n/*\n * Write the AVL tree of entries back to the LDIF file.\n */\nstatic int\ndse_write_file_nolock(struct dse *pdse)\n{\n    FPWrapper fpw;\n    int rc = 0;\n\n    if (dont_ever_write_dse_files) {\n        return rc;\n    }\n\n    fpw.fpw_rc = 0;\n    fpw.fpw_prfd = NULL;\n\n    if (NULL != pdse->dse_filename) {\n        if ((fpw.fpw_prfd = PR_Open(pdse->dse_tmpfile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE, SLAPD_DEFAULT_FILE_MODE)) == NULL) {\n            rc = PR_GetOSError();\n            slapi_log_err(SLAPI_LOG_ERR, \"dse_write_file_nolock\", \"Cannot open \"\n                                                                  \"temporary DSE file \\\"%s\\\" for update: OS error %d (%s)\\n\",\n                          pdse->dse_tmpfile, rc, slapd_system_strerror(rc));\n        } else {\n            fpw.fpw_pdse = pdse;\n            if (avl_apply(pdse->dse_tree, dse_write_entry, &fpw, STOP_TRAVERSAL, AVL_INORDER) == STOP_TRAVERSAL) {\n                rc = fpw.fpw_rc;\n                slapi_log_err(SLAPI_LOG_ERR, \"dse_write_file_nolock\", \"Cannot write \"\n                                                                      \" temporary DSE file \\\"%s\\\": OS error %d (%s)\\n\",\n                              pdse->dse_tmpfile, rc, slapd_system_strerror(rc));\n                (void)PR_Close(fpw.fpw_prfd);\n                fpw.fpw_prfd = NULL;\n            } else {\n                (void)PR_Close(fpw.fpw_prfd);\n                fpw.fpw_prfd = NULL;\n                if (pdse->dse_fileback != NULL) {\n                    rc = slapi_destructive_rename(pdse->dse_filename, pdse->dse_fileback);\n                    if (rc != 0) {\n                        slapi_log_err(SLAPI_LOG_ERR, \"dse_write_file_nolock\", \"Cannot backup\"\n                                                                              \" DSE file \\\"%s\\\" to \\\"%s\\\": OS error %d (%s)\\n\",\n                                      pdse->dse_filename, pdse->dse_fileback,\n                                      rc, slapd_system_strerror(rc));\n                    }\n                }\n                rc = slapi_destructive_rename(pdse->dse_tmpfile, pdse->dse_filename);\n                if (rc != 0) {\n                    slapi_log_err(SLAPI_LOG_ERR, \"dse_write_file_nolock\", \"Cannot rename\"\n                                                                          \" temporary DSE file \\\"%s\\\" to \\\"%s\\\":\"\n                                                                          \" OS error %d (%s)\\n\",\n                                  pdse->dse_tmpfile, pdse->dse_filename,\n                                  rc, slapd_system_strerror(rc));\n                }\n                /*\n                 * We have now written to the tmp location, and renamed it\n                 * we need to open and fsync the dir to make the rename stick.\n                 */\n                int fp_configdir =\n#ifdef O_PATH\n                    open(pdse->dse_configdir, O_PATH | O_DIRECTORY)\n#else\n                    open(pdse->dse_configdir, O_RDONLY | O_DIRECTORY)\n#endif\n                    ;\n                if (fp_configdir != -1) {\n                    fsync(fp_configdir);\n                    close(fp_configdir);\n                }\n            }\n        }\n        if (fpw.fpw_prfd)\n            (void)PR_Close(fpw.fpw_prfd);\n    }\n\n    return rc;\n}\n\n/*\n * Local function for writing an entry to a file.\n * Called by the AVL code during traversal.\n */\nstatic int\ndse_write_entry(caddr_t data, caddr_t arg)\n{\n    struct dse_node *n = (struct dse_node *)data;\n    FPWrapper *fpw = (FPWrapper *)arg;\n    char *s;\n    PRInt32 len;\n\n    if (NULL != n && NULL != n->entry) {\n        int returncode;\n        char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = \"\";\n        /* need to make a duplicate here for two reasons:\n           1) we don't want to hold on to the raw data in the node for any longer\n           than we have to; we will usually be inside the dse write lock, but . . .\n           2) the write callback may modify the entry, so we want to pass it a\n           writeable copy rather than the raw avl tree data pointer\n        */\n        Slapi_Entry *ec = slapi_entry_dup(n->entry);\n        if (dse_call_callback(fpw->fpw_pdse, NULL, DSE_OPERATION_WRITE,\n                              DSE_FLAG_PREOP, ec, NULL, &returncode, returntext) == SLAPI_DSE_CALLBACK_OK) {\n            /*\n             * 3-August-2000 mcs: We used to pass the SLAPI_DUMP_NOOPATTRS\n             * option to slapi_entry2str_with_options() so that operational\n             * attributes were NOT stored in the DSE LDIF files.  But now\n             * we store all attribute types.\n             */\n            if ((s = slapi_entry2str_with_options(ec, &len, 0)) != NULL) {\n                if (slapi_write_buffer(fpw->fpw_prfd, s, len) != len) {\n                    fpw->fpw_rc = PR_GetOSError();\n                    ;\n                    slapi_ch_free((void **)&s);\n                    return STOP_TRAVERSAL;\n                }\n                if (slapi_write_buffer(fpw->fpw_prfd, \"\\n\", 1) != 1) {\n                    fpw->fpw_rc = PR_GetOSError();\n                    ;\n                    slapi_ch_free((void **)&s);\n                    return STOP_TRAVERSAL;\n                }\n                slapi_ch_free((void **)&s);\n            }\n        }\n        slapi_entry_free(ec);\n    }\n    return 0;\n}\n\n/*\n * Adds an entry to the dse backend.  The passed in entry will be\n * free'd always.\n *\n * return -1 for duplicate entry\n * return -2 for schema violation (SCHEMA_VIOLATION)\n */\nstatic int\ndse_add_entry_pb(struct dse *pdse, Slapi_Entry *e, Slapi_PBlock *pb)\n{\n    int dont_write_file = 0, merge = 0; /* defaults */\n    int rc = 0;\n    struct dse_node *n = dse_node_new(e); /* copies e */\n    Slapi_Entry *schemacheckentry = NULL; /* to use for schema checking */\n\n    PR_ASSERT(pb);\n    slapi_pblock_get(pb, SLAPI_DSE_DONT_WRITE_WHEN_ADDING, &dont_write_file);\n    slapi_pblock_get(pb, SLAPI_DSE_MERGE_WHEN_ADDING, &merge);\n\n    /* keep write lock during both tree update and file write operations */\n    if (pdse->dse_rwlock)\n        slapi_rwlock_wrlock(pdse->dse_rwlock);\n    if (merge) {\n        rc = avl_insert(&(pdse->dse_tree), n, entry_dn_cmp, dupentry_merge);\n    } else {\n        rc = avl_insert(&(pdse->dse_tree), n, entry_dn_cmp, dupentry_disallow);\n    }\n    if (-1 != rc) {\n        /* update num sub of parent with no lock; we already hold the write lock */\n        if (0 == rc) { /* entry was added, not merged; update numsub */\n            /* easter egg entry - don't update num sub */\n            if (strcmp(slapi_entry_get_ndn(e), \"ou=red hat directory server team,cn=monitor\") != 0) {\n                dse_updateNumSubOfParent(pdse, slapi_entry_get_sdn_const(e),\n                                         SLAPI_OPERATION_ADD);\n            }\n        } else { /* entry was merged, free temp unused data */\n            dse_node_delete(&n);\n        }\n        if (!dont_write_file) {\n            dse_write_file_nolock(pdse);\n        }\n    } else {                 /* duplicate entry ignored */\n        dse_node_delete(&n); /* This also deletes the contained entry */\n    }\n    if (pdse->dse_rwlock)\n        slapi_rwlock_unlock(pdse->dse_rwlock);\n\n    if (rc == -1) {\n        /* duplicate entry ignored */\n        schemacheckentry = dse_get_entry_copy(pdse,\n                                              slapi_entry_get_sdn_const(e),\n                                              DSE_USE_LOCK);\n    } else /* entry added or merged */\n    {\n        /* entry was added or merged */\n        if (0 == rc) /* 0 return means entry was added, not merged */\n        {\n            /* save a search of the tree, since we added the entry, the\n               contents of e should be the same as what is in the tree */\n            schemacheckentry = slapi_entry_dup(e);\n        } else /* merged */\n        {\n            /* schema check the new merged entry, so get it from the tree */\n            schemacheckentry = dse_get_entry_copy(pdse,\n                                                  slapi_entry_get_sdn_const(e),\n                                                  DSE_USE_LOCK);\n        }\n    }\n    if (NULL != schemacheckentry) {\n        /*\n         * Verify that the new or merged entry conforms to the schema.\n         *        Errors are logged by slapi_entry_schema_check().\n         */\n        if (slapi_entry_schema_check(pb, schemacheckentry)) {\n            rc = SCHEMA_VIOLATION;\n        }\n        slapi_entry_free(schemacheckentry);\n    }\n\n    /* Callers expect e (SLAPI_ADD_ENTRY) to be freed */\n    /* This function duplicates 'e' for dse_node 'n' and schemacheckentry.\n     * 'e' should not have been consumed */\n    slapi_entry_free(e);\n\n    return rc;\n}\n\n/*\n * Local function for comparing two entries by DN.  Store the entries\n * so that when they are printed out, the child entries are below their\n * ancestor entries\n */\nstatic int\nentry_dn_cmp(caddr_t d1, caddr_t d2)\n{\n    struct dse_node *n1 = (struct dse_node *)d1;\n    struct dse_node *n2 = (struct dse_node *)d2;\n    const Slapi_DN *dn1 = slapi_entry_get_sdn_const(n1->entry);\n    const Slapi_DN *dn2 = slapi_entry_get_sdn_const(n2->entry);\n    int retval = slapi_sdn_compare(dn1, dn2);\n\n    if (retval != 0) {\n        if (slapi_sdn_issuffix(dn1, dn2)) {\n            retval = 1;\n        } else if (slapi_sdn_issuffix(dn2, dn1)) {\n            retval = -1;\n        } else {\n            /* put fewer rdns before more rdns */\n            int rc = 0;\n            char **dnlist1 = slapi_ldap_explode_dn(slapi_sdn_get_ndn(dn1), 0);\n            char **dnlist2 = slapi_ldap_explode_dn(slapi_sdn_get_ndn(dn2), 0);\n            int len1 = 0;\n            int len2 = 0;\n            if (dnlist1)\n                for (len1 = 0; dnlist1[len1]; ++len1)\n                    ;\n            if (dnlist2)\n                for (len2 = 0; dnlist2[len2]; ++len2)\n                    ;\n\n            if (len1 == len2) {\n                len1--;\n                for (; (rc == 0) && (len1 >= 0); --len1) {\n                    rc = strcmp(dnlist1[len1], dnlist2[len1]);\n                }\n                if (rc)\n                    retval = rc;\n            } else\n                retval = len1 - len2;\n\n            if (dnlist1)\n                slapi_ldap_value_free(dnlist1);\n            if (dnlist2)\n                slapi_ldap_value_free(dnlist2);\n        }\n    }\n    /* else entries are equal if dns are equal */\n\n    return retval;\n}\n\n\nstatic int\ndupentry_disallow(caddr_t d1 __attribute__((unused)), caddr_t d2 __attribute__((unused)))\n{\n    return -1;\n}\n\n\nstatic int\ndupentry_replace(caddr_t d1, caddr_t d2)\n{\n    /*\n     * Hack attack: since we don't have the address of the pointer\n     * in the avl node, we have to replace the e_dn and e_attrs\n     * members of the entry which is in the AVL tree with our\n     * new entry DN and attrs.  We then point the \"new\" entry's\n     * e_dn and e_attrs pointers to point to the values we just\n     * replaced, on the assumption that the caller will be freeing\n     * these.\n     */\n    struct dse_node *n1 = (struct dse_node *)d1; /* OLD */\n    struct dse_node *n2 = (struct dse_node *)d2; /* NEW */\n    Slapi_Entry *e = n1->entry;\n    n1->entry = n2->entry;\n    n2->entry = e;\n    return DSE_ENTRY_WAS_REPLACED;\n}\n\nstatic int\ndupentry_merge(caddr_t d1, caddr_t d2)\n{\n    struct dse_node *n1 = (struct dse_node *)d1; /* OLD */\n    struct dse_node *n2 = (struct dse_node *)d2; /* NEW */\n    Slapi_Entry *e1 = n1->entry;\n    Slapi_Entry *e2 = n2->entry;\n    int rc = 0;\n    Slapi_Attr *newattr = 0;\n\n    for (rc = slapi_entry_first_attr(e2, &newattr);\n         !rc && newattr;\n         rc = slapi_entry_next_attr(e2, newattr, &newattr)) {\n        char *type = 0;\n        slapi_attr_get_type(newattr, &type);\n        if (type) {\n            /* insure there are no duplicate values in e1 */\n            rc = slapi_entry_merge_values_sv(e1, type,\n                                             attr_get_present_values(newattr));\n        }\n    }\n\n    return DSE_ENTRY_WAS_MERGED;\n}\n\n/*\n * Add an entry to the DSE without locking the DSE avl tree.\n * Replaces the entry if it already exists.\n *\n * The given entry e is never consumed.  It is the responsibility of the\n * caller to free it when it is no longer needed.\n *\n * The write_file flag is used if we want to update the entry in memory\n * but we do not want to write out the file.  For example, if we update\n * the numsubordinates in the entry, this is an operational attribute that\n * we do not want saved to disk.\n */\nstatic int\ndse_replace_entry(struct dse *pdse, Slapi_Entry *e, int write_file, int use_lock)\n{\n    int rc = -1;\n    if (NULL != e) {\n        struct dse_node *n = dse_node_new(e);\n        if (use_lock && pdse->dse_rwlock)\n            slapi_rwlock_wrlock(pdse->dse_rwlock);\n        rc = avl_insert(&(pdse->dse_tree), n, entry_dn_cmp, dupentry_replace);\n        if (write_file)\n            dse_write_file_nolock(pdse);\n        /* If the entry was replaced i.e. not added as a new entry, we need to\n           free the old data, which is set in dupentry_replace */\n        if (DSE_ENTRY_WAS_REPLACED == rc) {\n            dse_node_delete(&n);\n            rc = 0; /* for return to caller */\n        }\n        if (use_lock && pdse->dse_rwlock)\n            slapi_rwlock_unlock(pdse->dse_rwlock);\n    }\n    return rc;\n}\n\n\n/*\n * Return -1 if p does not point to a valid LDIF\n * end-of-record delimiter (a NULL, two newlines, or two\n * pairs of CRLF).  Otherwise, return the length of\n * the delimiter found.\n */\nstatic int\nldif_record_end(char *p)\n{\n    if (NULL != p) {\n        if ('\\0' == *p) {\n            return 0;\n        } else if ('\\n' == *p && '\\n' == *(p + 1)) {\n            return 2;\n        } else if ('\\r' == *p && '\\n' == *(p + 1) && '\\r' == *(p + 2) && '\\n' == *(p + 3)) {\n            return 4;\n        }\n    }\n    return -1;\n}\n\nchar *\ndse_read_next_entry(char *buf, char **lastp)\n{\n    char *p, *start;\n\n    if (NULL == buf) {\n        *lastp = NULL;\n        return NULL;\n    }\n    p = start = (NULL == *lastp) ? buf : *lastp;\n    /* Skip over any leading record delimiters */\n    while ('\\n' == *p || '\\r' == *p) {\n        p++;\n    }\n    if ('\\0' == *p) {\n        *lastp = NULL;\n        return NULL;\n    }\n    while ('\\0' != *p) {\n        int rc;\n        if ((rc = ldif_record_end(p)) >= 0) {\n            /* Found end of LDIF record */\n            *p = '\\0';\n            p += rc;\n            break;\n        } else {\n            p++;\n        }\n    }\n    *lastp = p;\n    return start;\n}\n\n/*\n * Apply the function to each entry.  The caller is responsible for locking\n * the rwlock in the dse for the appropriate type of operation e.g. for\n * searching, a read lock, for modifying in place, a write lock\n */\nstatic int\ndse_apply_nolock(struct dse *pdse, IFP fp, caddr_t arg)\n{\n    avl_apply(pdse->dse_tree, fp, arg, STOP_TRAVERSAL, AVL_INORDER);\n    return 1;\n}\n\n\n/*\n * Remove the entry from the tree.\n * Returns 1 if entry is removed and 0 if not.\n */\nstatic int\ndse_delete_entry(struct dse *pdse, Slapi_PBlock *pb, const Slapi_Entry *e)\n{\n    int dont_write_file = 0;\n    struct dse_node *n = dse_node_new(e);\n    struct dse_node *deleted_node = NULL;\n\n    slapi_pblock_get(pb, SLAPI_DSE_DONT_WRITE_WHEN_ADDING, &dont_write_file);\n\n    /* keep write lock for both tree deleting and file writing */\n    if (pdse->dse_rwlock)\n        slapi_rwlock_wrlock(pdse->dse_rwlock);\n    if ((deleted_node = (struct dse_node *)avl_delete(&pdse->dse_tree,\n                                                      n, entry_dn_cmp)))\n        dse_node_delete(&deleted_node);\n    dse_node_delete(&n);\n\n    if (!dont_write_file) {\n        /* Decrement the numsubordinate count of the parent entry */\n        dse_updateNumSubOfParent(pdse, slapi_entry_get_sdn_const(e),\n                                 SLAPI_OPERATION_DELETE);\n        dse_write_file_nolock(pdse);\n    }\n    if (pdse->dse_rwlock)\n        slapi_rwlock_unlock(pdse->dse_rwlock);\n\n    return 1;\n}\n\n\n/*\n * Returns a SLAPI_BIND_xxx retun code.\n */\nint\ndse_bind(Slapi_PBlock *pb) /* JCM There should only be one exit point from this function! */\n{\n    ber_tag_t method;    /* The bind method */\n    struct berval *cred; /* The bind credentials */\n    Slapi_Value **bvals;\n    struct dse *pdse;\n    Slapi_Attr *attr;\n    Slapi_DN *sdn = NULL;\n    Slapi_Entry *ec = NULL;\n\n    /*Get the parameters*/\n    if (slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse) < 0 ||\n        slapi_pblock_get(pb, SLAPI_BIND_TARGET_SDN, &sdn) < 0 ||\n        slapi_pblock_get(pb, SLAPI_BIND_METHOD, &method) < 0 ||\n        slapi_pblock_get(pb, SLAPI_BIND_CREDENTIALS, &cred) < 0) {\n        slapi_send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, NULL, 0, NULL);\n        return SLAPI_BIND_FAIL;\n    }\n\n    /* always allow noauth simple binds */\n    if (method == LDAP_AUTH_SIMPLE && cred->bv_len == 0) {\n        /*\n         * report success to client, but return\n         * SLAPI_BIND_FAIL so we don't\n         * authorize based on noauth credentials\n         */\n        slapi_send_ldap_result(pb, LDAP_SUCCESS, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        slapi_send_ldap_result(pb, LDAP_NO_SUCH_OBJECT, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    switch (method) {\n    case LDAP_AUTH_SIMPLE: {\n        Slapi_Value cv;\n        if (slapi_entry_attr_find(ec, \"userpassword\", &attr) != 0) {\n            slapi_send_ldap_result(pb, LDAP_INAPPROPRIATE_AUTH, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            return SLAPI_BIND_FAIL;\n        }\n        bvals = attr_get_present_values(attr);\n\n        slapi_value_init_berval(&cv, cred);\n        if (slapi_pw_find_sv(bvals, &cv) != 0) {\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            value_done(&cv);\n            return SLAPI_BIND_FAIL;\n        }\n        value_done(&cv);\n    } break;\n\n    default:\n        slapi_send_ldap_result(pb, LDAP_STRONG_AUTH_NOT_SUPPORTED, NULL, \"auth method not supported\", 0, NULL);\n        slapi_entry_free(ec);\n        return SLAPI_BIND_FAIL;\n    }\n    slapi_entry_free(ec);\n    /* success:  front end will send result */\n    return SLAPI_BIND_SUCCESS;\n}\n\nint\ndse_unbind(Slapi_PBlock *pb __attribute__((unused)))\n{\n    return 0;\n}\n\n/*\n * This structure is simply to pass parameters to dse_search_filter_entry.\n */\nstruct magicSearchStuff\n{\n    Slapi_PBlock *pb;\n    struct dse *pdse;\n    int scope;\n    const Slapi_DN *basedn;\n    Slapi_Filter *filter;\n    int nentries;\n    char **attrs;       /*Attributes*/\n    int attrsonly;      /*Should we just return the attributes found?*/\n    dse_search_set *ss; /* for the temporary results - to pass to the dse search callbacks */\n};\n\n/*\n * The function which is called on each node of the AVL tree.\n */\nstatic int\ndse_search_filter_entry(caddr_t data, caddr_t arg)\n{\n    struct dse_node *n = (struct dse_node *)data;\n    struct magicSearchStuff *p = (struct magicSearchStuff *)arg;\n    if (slapi_sdn_scope_test(slapi_entry_get_sdn_const(n->entry), p->basedn, p->scope)) {\n        if (slapi_vattr_filter_test(p->pb, n->entry, p->filter, 1 /* verify access */) == 0) {\n            Slapi_Entry *ec = slapi_entry_dup(n->entry);\n            p->nentries++;\n            if (!p->ss) {\n                p->ss = dse_search_set_new();\n            }\n            dse_search_set_add_entry(p->ss, ec); /* consumes the entry */\n        } else {\n            /*\n            slapd_log_error_proc(\"dse_search_filter_entry\",\n                                 \"filter test failed: dn %s did not match filter %d\\n\",\n                                 slapi_entry_get_dn_const(n->entry), p->filter->f_choice);\n*/\n        }\n    } else {\n        /*\n        slapd_log_error_proc(\"dse_search_filter_entry\",\n                             \"scope test failed: dn %s is not in scope %d of dn [%s]\\n\",\n                             slapi_entry_get_dn_const(n->entry), p->scope,\n                             slapi_sdn_get_dn(p->basedn));\n*/\n    }\n    return 0;\n}\n\n/*\n * The function which kicks off the traversal of the AVL tree.\n * Returns the number of entries returned.\n */\n/* jcm: Not very efficient if there are many DSE entries. */\n/* jcm: It applies the filter to every node in the tree regardless */\nstatic int\ndo_dse_search(struct dse *pdse, Slapi_PBlock *pb, int scope, const Slapi_DN *basedn, Slapi_Filter *filter, char **attrs, int attrsonly)\n{\n    struct magicSearchStuff stuff;\n    stuff.pb = pb;\n    stuff.pdse = pdse;\n    stuff.scope = scope;\n    stuff.basedn = basedn;\n    stuff.filter = filter;\n    stuff.nentries = 0;\n    stuff.attrs = attrs;\n    stuff.attrsonly = attrsonly;\n    stuff.ss = NULL;\n    Operation *pb_op = NULL;\n    slapi_pblock_get(pb, SLAPI_OPERATION, &pb_op);\n\n    /*\n     * If this is a persistent search and the client is only interested in\n     * entries that change, we skip looking through the DSE entries.\n     */\n    if (pb_op == NULL || !operation_is_flag_set(pb_op, OP_FLAG_PS_CHANGESONLY)) {\n        if (pdse->dse_rwlock)\n            slapi_rwlock_rdlock(pdse->dse_rwlock);\n        dse_apply_nolock(pdse, dse_search_filter_entry, (caddr_t)&stuff);\n        if (pdse->dse_rwlock)\n            slapi_rwlock_unlock(pdse->dse_rwlock);\n    }\n\n    if (stuff.ss) /* something was found which matched our criteria */\n    {\n        Slapi_Entry *e = NULL;\n        for (e = dse_search_set_get_next_entry(stuff.ss);\n             e;\n             e = dse_search_set_get_next_entry(stuff.ss)) {\n            int returncode = 0;\n            char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = \"\";\n\n            if (dse_call_callback(pdse, pb, SLAPI_OPERATION_SEARCH,\n                                  DSE_FLAG_PREOP, e, NULL, &returncode, returntext) == SLAPI_DSE_CALLBACK_OK) {\n                dse_search_set *ss = NULL;\n                slapi_pblock_get(pb, SLAPI_SEARCH_RESULT_SET, &ss);\n                /* if this is the first entry - allocate dse_search_set structure */\n                if (ss == NULL) {\n                    ss = dse_search_set_new();\n                    slapi_pblock_set(pb, SLAPI_SEARCH_RESULT_SET, ss);\n                }\n                /* make another reference to e (stuff.ss references it too)\n                   the stuff.ss reference is removed by dse_search_set_clean()\n                   below, leaving ss as the sole owner of the memory */\n                dse_search_set_add_entry(ss, e);\n            } else {\n                stuff.nentries--; /* rejected entry */\n                /* this leaves a freed pointer in stuff.ss, but that's ok because\n                   it should never be referenced, and the reference is removed by\n                   the call to dse_search_set_clean() below */\n                slapi_entry_free(e);\n            }\n        }\n        dse_search_set_clean(stuff.ss);\n    }\n\n    /* the pblock ss now contains the \"real\" search result set and the copies of\n       the entries allocated in dse_search_filter_entry; any entries rejected by\n       the search callback were freed above by the call to slapi_entry_free() */\n    return stuff.nentries;\n}\n\n/*\n * -1 means something went wrong.\n * 0 means everything went ok.\n */\nint\ndse_search(Slapi_PBlock *pb) /* JCM There should only be one exit point from this function! */\n{\n    int scope;            /*Scope of the search*/\n    Slapi_Filter *filter; /*The filter*/\n    char **attrs;         /*Attributes*/\n    int attrsonly;        /*Should we just return the attributes found?*/\n    /*int nentries= 0; Number of entries found thus far*/\n    struct dse *pdse;\n    int returncode = LDAP_SUCCESS;\n    int isrootdse = 0;\n    char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = \"\";\n    Slapi_DN *basesdn = NULL;\n    int estimate = 0; /* estimated search result set size */\n\n    /*\n     * Get private information created in the init routine.\n     * Also get the parameters of the search operation. These come\n     * more or less directly from the client.\n     */\n    if (slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse) < 0 ||\n        slapi_pblock_get(pb, SLAPI_SEARCH_TARGET_SDN, &basesdn) < 0 ||\n        slapi_pblock_get(pb, SLAPI_SEARCH_SCOPE, &scope) < 0 ||\n        slapi_pblock_get(pb, SLAPI_SEARCH_FILTER, &filter) < 0 ||\n        slapi_pblock_get(pb, SLAPI_SEARCH_ATTRS, &attrs) < 0 ||\n        slapi_pblock_get(pb, SLAPI_SEARCH_ATTRSONLY, &attrsonly) < 0) {\n        slapi_send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, NULL, 0, NULL);\n        return (-1);\n    }\n    /*\n     * Sadly the root dse is still a special case.  We must not allow\n     * acl checks on it, or allow onelevel or subtree searches on it.\n     */\n    isrootdse = slapi_sdn_isempty(basesdn);\n\n    switch (scope) {\n    case LDAP_SCOPE_BASE: {\n        Slapi_Entry *baseentry = NULL;\n        baseentry = dse_get_entry_copy(pdse, basesdn, DSE_USE_LOCK);\n        if (baseentry == NULL) {\n            slapi_send_ldap_result(pb, LDAP_NO_SUCH_OBJECT, NULL, NULL, 0, NULL);\n            slapi_log_err(SLAPI_LOG_PLUGIN, \"dse_search\", \"node %s was not found\\n\",\n                          slapi_sdn_get_dn(basesdn));\n            return -1;\n        }\n        /*\n         * We don't want to do an acl check for the root dse... because the acl\n         * code thinks it's a suffix of every target... so every acl applies to\n         * the root dse... which is wrong.\n         */\n        if (slapi_vattr_filter_test(pb, baseentry, filter, !isrootdse /* verify access */) == 0) {\n            /* Callbacks modify a copy of the entry */\n            if (dse_call_callback(pdse, pb, SLAPI_OPERATION_SEARCH,\n                                  DSE_FLAG_PREOP, baseentry, NULL, &returncode, returntext) == SLAPI_DSE_CALLBACK_OK) {\n                dse_search_set *ss;\n                ss = dse_search_set_new();\n                slapi_pblock_set(pb, SLAPI_SEARCH_RESULT_SET, ss);\n                dse_search_set_add_entry(ss, baseentry); /* consumes the entry */\n                baseentry = NULL;\n                estimate = 1; /* scope base */\n            }\n        }\n        slapi_entry_free(baseentry);\n    } break;\n    case LDAP_SCOPE_ONELEVEL:\n    /* FALL THROUGH */\n    case LDAP_SCOPE_SUBTREE:\n        if (!isrootdse) {\n            estimate = do_dse_search(pdse, pb, scope, basesdn, filter, attrs, attrsonly);\n        }\n        break;\n    }\n    slapi_pblock_set(pb, SLAPI_SEARCH_RESULT_SET_SIZE_ESTIMATE, &estimate);\n\n    /* Search is done, send LDAP_SUCCESS */\n    return 0;\n}\n\nint32_t\ndse_compare(Slapi_PBlock *pb)\n{\n    /*\n     * Inspired largely by ldbm_compare.c. Allow schema aware comparison\n     * of entries in the DSE, including cn=config.\n     */\n    backend *be = NULL;\n    char *type = NULL;\n    struct berval *bval = NULL;\n    Slapi_DN *sdn = NULL;\n    struct dse *pdse = NULL;\n    Slapi_Entry *ec = NULL;\n    Slapi_Value compare_value = {0};\n\n    slapi_pblock_get(pb, SLAPI_BACKEND, &be);\n    slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse);\n    slapi_pblock_get(pb, SLAPI_TARGET_SDN, &sdn);\n    slapi_pblock_get(pb, SLAPI_COMPARE_TYPE, &type);\n    slapi_pblock_get(pb, SLAPI_COMPARE_VALUE, &bval);\n\n    /* get the entry */\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        slapi_send_ldap_result(pb, LDAP_NO_SUCH_OBJECT, NULL, NULL, 0, NULL);\n        return -1;\n    }\n\n    /* Access control check */\n    int32_t err = slapi_access_allowed(pb, ec, type, bval, SLAPI_ACL_COMPARE);\n    if (err != LDAP_SUCCESS) {\n        slapi_entry_free(ec);\n        slapi_send_ldap_result(pb, err, NULL, NULL, 0, NULL);\n        return -1;\n    }\n\n    /* If cn=config, setup the entry with ALL values we could check from defaults */\n    Slapi_DN config_dn;\n    slapi_sdn_init_ndn_byref(&config_dn, \"cn=config\");\n    if (slapi_sdn_compare(&config_dn, sdn) == 0) {\n        read_config_dse(pb, ec, NULL, &err, NULL, NULL);\n        /*\n         * read_config_dse, and in turn, config_set_entry always returns\n         * a 1 here, which is probably dse_callback related.\n         */\n        if (err != 1) {\n            slapi_send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, NULL, 0, NULL);\n            return -1;\n        }\n        /*\n         * cn=config is now populated\n         */\n    }\n    slapi_sdn_done(&config_dn);\n\n    /* Do the schema aware check. */\n    slapi_value_init_berval(&compare_value, bval);\n\n    int32_t result = 0;\n    err = slapi_vattr_value_compare(ec, type, &compare_value, &result, 0);\n\n    /* We have the results, now free and then send. */\n    slapi_entry_free(ec);\n    value_done(&compare_value);\n\n    /* Format the result as expected. */\n    if (err != LDAP_SUCCESS) {\n        if (SLAPI_VIRTUALATTRS_NOT_FOUND == err) {\n            slapi_send_ldap_result(pb, LDAP_NO_SUCH_ATTRIBUTE, NULL, NULL, 0, NULL);\n        } else {\n            /* Some other problem, call it an operations error */\n            slapi_send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, NULL, 0, NULL);\n        }\n        return -1;\n    } else {\n        if (result != 0) {\n            slapi_send_ldap_result(pb, LDAP_COMPARE_TRUE, NULL, NULL, 0, NULL);\n        } else {\n            slapi_send_ldap_result(pb, LDAP_COMPARE_FALSE, NULL, NULL, 0, NULL);\n        }\n    }\n    return 0;\n}\n\n/*\n * -1 means something went wrong.\n * 0 means everything went ok.\n */\n\nstatic int\ndse_modify_return(int rv, Slapi_Entry *ec, Slapi_Entry *ecc)\n{\n    slapi_entry_free(ec);\n    slapi_entry_free(ecc);\n    return rv;\n}\n\nint\ndse_modify(Slapi_PBlock *pb) /* JCM There should only be one exit point from this function! */\n{\n    int err;             /*House keeping stuff*/\n    LDAPMod **mods;      /*Used to apply the modifications*/\n    LDAPMod **original_mods = NULL; /* some mods can be removed by callback, save them for later logging */\n    char *errbuf = NULL; /* To get error back */\n    struct dse *pdse;\n    Slapi_Entry *ec = NULL;\n    Slapi_Entry *ecc = NULL;\n    int returncode = LDAP_SUCCESS;\n    char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = \"\";\n    Slapi_DN *sdn = NULL;\n    int dont_write_file = 0; /* default */\n    int rc = SLAPI_DSE_CALLBACK_DO_NOT_APPLY;\n    int retval = -1;\n    int need_be_postop = 0;\n    int plugin_started = 0;\n    int internal_op = 0;\n    PRBool global_lock_owned = PR_FALSE;\n    Operation *pb_op = NULL;\n\n    PR_ASSERT(pb);\n    if (slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse) < 0 ||\n        /* slapi_pblock_get( pb, SLAPI_MODIFY_TARGET, &dn ) < 0 || */\n        slapi_pblock_get(pb, SLAPI_MODIFY_TARGET_SDN, &sdn) < 0 ||\n        slapi_pblock_get(pb, SLAPI_MODIFY_MODS, &mods) < 0 || (NULL == pdse)) {\n        returncode = LDAP_OPERATIONS_ERROR;\n        goto done;\n    }\n\n    slapi_pblock_get(pb, SLAPI_DSE_DONT_WRITE_WHEN_ADDING, &dont_write_file);\n    if (!dont_write_file && dse_check_for_readonly_error(pb, pdse)) {\n        /* already returned result */\n        return retval;\n    }\n\n    slapi_pblock_get(pb, SLAPI_OPERATION, &pb_op);\n    if (pb_op){\n        internal_op = operation_is_flag_set(pb_op, OP_FLAG_INTERNAL);\n    }\n    /* Find the entry we are about to modify. */\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        returncode = LDAP_NO_SUCH_OBJECT;\n        goto done;\n    }\n\n    /* Check acl */\n    err = plugin_call_acl_mods_access(pb, ec, mods, &errbuf);\n    if (err != LDAP_SUCCESS) {\n        returncode = err;\n        if (errbuf) {\n            PL_strncpyz(returntext, errbuf, sizeof(returntext));\n            slapi_ch_free_string(&errbuf);\n        }\n        goto done;\n    }\n\n    /* Save away a copy of the entry, before modifications */\n    slapi_pblock_set(pb, SLAPI_ENTRY_PRE_OP, slapi_entry_dup(ec)); /* JCM - When does this get free'd? */\n    /* richm - it is freed in modify.c */\n\n    /* Modify a copy of the entry*/\n    ecc = slapi_entry_dup(ec);\n    err = entry_apply_mods(ecc, mods);\n\n    /* Possibly acquire the global backend lock */\n    if (global_backend_lock_requested()) {\n        global_backend_lock_lock();\n        global_lock_owned = PR_TRUE;\n    }\n    original_mods = copy_mods(mods);\n\n    /* XXXmcs: should we expand objectclass values here?? */\n    /* give the dse callbacks the first crack at the modify */\n    rc = dse_call_callback(pdse, pb, SLAPI_OPERATION_MODIFY, DSE_FLAG_PREOP, ec, ecc, &returncode, returntext);\n    if (SLAPI_DSE_CALLBACK_OK == rc) {\n        int plugin_rc;\n\n        /* next, give the be plugins a crack at it */\n        slapi_pblock_set(pb, SLAPI_RESULT_CODE, &returncode);\n        slapi_pblock_set(pb, SLAPI_MODIFY_EXISTING_ENTRY, ecc);\n        plugin_rc = plugin_call_plugins(pb, SLAPI_PLUGIN_BE_PRE_MODIFY_FN);\n        need_be_postop = 1; /* if the be preops were called, have to call the be postops too */\n        if (!returncode) {\n            slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n        }\n        if (!plugin_rc && !returncode) {\n            /* finally, give the betxn plugins a crack at it */\n            plugin_rc = plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_PRE_MODIFY_FN);\n            if (!returncode) {\n                slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n            }\n            if (plugin_rc || returncode) {\n                slapi_log_err(SLAPI_DSE_TRACELEVEL,\n                              \"dse_modify\", \"SLAPI_PLUGIN_BE_TXN_PRE_MODIFY_FN failed - rc %d LDAP error %d:%s\\n\",\n                              plugin_rc, returncode, ldap_err2string(returncode));\n            }\n        } else {\n            slapi_log_err(SLAPI_DSE_TRACELEVEL,\n                          \"dse_modify\", \"SLAPI_PLUGIN_BE_PRE_MODIFY_FN failed - rc %d LDAP error %d:%s\\n\",\n                          rc, returncode, ldap_err2string(returncode));\n        }\n        if (plugin_rc || returncode) {\n            char *ldap_result_message = NULL;\n            rc = SLAPI_DSE_CALLBACK_ERROR;\n            if (!returncode) {\n                slapi_log_err(SLAPI_DSE_TRACELEVEL,\n                              \"dse_modify\", \"PRE_MODIFY plugin returned non-zero but did not set an LDAP error\\n\");\n                returncode = LDAP_OPERATIONS_ERROR;\n            }\n            if (!returntext[0]) {\n                slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);\n                if (ldap_result_message && ldap_result_message[0]) {\n                    PL_strncpyz(returntext, ldap_result_message, sizeof(returntext));\n                }\n            }\n        } else {\n            /*\n             * If we are using dynamic plugins, and we are modifying a plugin\n             * we need to do some additional checks.  First, check if we are\n             * enabling/disabling a plugin.  Then make sure the plugin still\n             * starts after applying the plugin changes.\n             */\n            rc = SLAPI_DSE_CALLBACK_OK;\n            if (slapi_entry_attr_hasvalue(ec, SLAPI_ATTR_OBJECTCLASS, \"nsSlapdPlugin\")) {\n                if (config_get_dynamic_plugins()) {\n                    if ((plugin_started = dse_modify_plugin(ec, ecc, returntext)) == -1) {\n                        returncode = LDAP_UNWILLING_TO_PERFORM;\n                        rc = SLAPI_DSE_CALLBACK_ERROR;\n                        retval = -1;\n                        goto done;\n                    }\n                    /*\n                     * If this is not a internal operation, make sure the plugin\n                     * can be restarted.\n                     */\n                    if (!internal_op) {\n                        if (dse_pre_modify_plugin(ec, ecc, mods)) {\n                            char *errtext;\n                            slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &errtext);\n                            if (errtext) {\n                                PL_strncpyz(returntext,\n                                            \"Failed to apply plugin config change, \"\n                                            \"check the errors log for more info.\",\n                                            sizeof(returntext));\n                            }\n                            returncode = LDAP_UNWILLING_TO_PERFORM;\n                            rc = SLAPI_DSE_CALLBACK_ERROR;\n                            retval = -1;\n                            goto done;\n                        }\n                    }\n                } else {\n                    slapi_log_err(SLAPI_LOG_NOTICE, \"dse_modify\", \"A plugin has been enabled or disabled, but nsslapd-dynamic-plugins is off. A server restart is required to change this plugin state.\\n\");\n                } /* end config_get_dynamic_plugins */\n            } /* end has nsSlapdPlugin */\n        }\n    }\n\n    switch (rc) {\n    case SLAPI_DSE_CALLBACK_ERROR:\n        /* Error occured in the callback -- return error code from callback */\n        goto done;\n        break;\n    case SLAPI_DSE_CALLBACK_DO_NOT_APPLY:\n        /* Callback says don't apply the changes -- return Success */\n        returncode = LDAP_SUCCESS;\n        returntext[0] = '\\0';\n        retval = 0;\n        goto done;\n        break;\n    case SLAPI_DSE_CALLBACK_OK: {\n        /* The callback may alter the mods in the pblock.  This happens\n           for example in the schema code.  Since the schema attributes\n           are managed exclusively by the schema code, we should not\n           apply those mods.  However, for reasons unknown to me, we\n           must in the general case call entry_apply_mods before calling\n           the modify callback above.  In the case of schema, the schema\n           code will remove the schema attributes from the mods.  So, we\n           reapply the mods to the entry for the attributes we manage in\n           the dse code (e.g. aci)\n        */\n        int reapply_mods = 0; /* default is to not reapply entry_apply_mods */\n        slapi_pblock_get(pb, SLAPI_DSE_REAPPLY_MODS, &reapply_mods);\n        /* Callback says apply the changes */\n        if (reapply_mods) {\n            LDAPMod **modsagain = NULL; /*Used to apply the modifications*/\n            slapi_pblock_get(pb, SLAPI_MODIFY_MODS, &modsagain);\n            if (NULL != modsagain) {\n                /* the dse modify callback must have modified ecc back to it's\n                   original state, before the earlier apply_mods, but without the\n                   attributes it did not want us to apply mods to */\n                err = entry_apply_mods(ecc, modsagain);\n            }\n        }\n\n        if (err != 0) {\n            returncode = err;\n            returntext[0] = '\\0';\n            retval = -1;\n            goto done;\n        }\n        break;\n    }\n    }\n\n    /* We're applying the mods... check that the entry still obeys the schema */\n    if (slapi_entry_schema_check(pb, ecc) != 0) {\n        char *errtext;\n\n        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &errtext);\n        if (errtext) {\n            PL_strncpyz(returntext, errtext, sizeof(returntext));\n        }\n        returncode = LDAP_OBJECT_CLASS_VIOLATION;\n        retval = -1;\n        goto done;\n    }\n\n    /* Check if the attribute values in the mods obey the syntaxes */\n    if (slapi_mods_syntax_check(pb, mods, 0) != 0) {\n        char *errtext;\n\n        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &errtext);\n        if (errtext) {\n            PL_strncpyz(returntext, errtext, sizeof(returntext));\n        }\n        returncode = LDAP_INVALID_SYNTAX;\n        retval = -1;\n        goto done;\n    }\n\n    /* Change the entry itself both on disk and in the AVL tree */\n    /* dse_replace_entry free's the existing entry. */\n    if (dse_replace_entry(pdse, ecc, !dont_write_file, DSE_USE_LOCK) != 0) {\n        returncode = LDAP_OPERATIONS_ERROR;\n        retval = -1;\n        goto done;\n    }\n    retval = 0;                                                      /* so far, so good */\n    slapi_pblock_set(pb, SLAPI_ENTRY_POST_OP, slapi_entry_dup(ecc)); /* JCM - When does this get free'd? */\n    /* richm - it is freed in modify.c */\n    /* give the dse callbacks the first crack at the modify */\n    rc = dse_call_callback(pdse, pb, SLAPI_OPERATION_MODIFY, DSE_FLAG_POSTOP, ec, ecc, &returncode, returntext);\ndone:\n    if (rc != SLAPI_DSE_CALLBACK_DO_NOT_APPLY) {\n        /* make sure OPRETURN is set */\n        slapi_pblock_get(pb, SLAPI_PLUGIN_OPRETURN, &err);\n        if ((retval || returncode) && !err) {\n            slapi_pblock_set(pb, SLAPI_PLUGIN_OPRETURN, retval ? &retval : &returncode);\n        }\n        /* next, give the betxn plugins a crack at it */\n        slapi_pblock_set(pb, SLAPI_RESULT_CODE, &returncode);\n        slapi_pblock_set(pb, SLAPI_MODIFY_EXISTING_ENTRY, ecc);\n        if (need_be_postop) {\n            plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_POST_MODIFY_FN);\n            if (!returncode) {\n                slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n            }\n            if (returncode && !returntext[0]) {\n                char *ldap_result_message = NULL;\n                slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);\n                if (ldap_result_message && ldap_result_message[0]) {\n                    PL_strncpyz(returntext, ldap_result_message, sizeof(returntext));\n                }\n            }\n\n            plugin_call_plugins(pb, SLAPI_PLUGIN_BE_POST_MODIFY_FN);\n            if (!returncode) {\n                slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n            }\n        }\n    } else {\n        /* It should not happen but just be paranoiac, do not\n         * forget to call the postop if needed\n         */\n        if (need_be_postop) {\n            plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_POST_MODIFY_FN);\n            if (!returncode) {\n                slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n            }\n\n            plugin_call_plugins(pb, SLAPI_PLUGIN_BE_POST_MODIFY_FN);\n            if (!returncode) {\n                slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n            }\n        }\n    }\n\n    /* time to restore original mods */\n    if (original_mods) {\n        LDAPMod **mods_from_callback;\n        slapi_pblock_get(pb, SLAPI_MODIFY_MODS, &mods_from_callback);\n        ldap_mods_free(mods_from_callback, 1 /* Free the Array and the Elements */);\n        slapi_pblock_set(pb, SLAPI_MODIFY_MODS, original_mods);\n    }\n    if (global_lock_owned) {\n        global_backend_lock_unlock();\n    }\n    slapi_send_ldap_result(pb, returncode, NULL, returntext[0] ? returntext : NULL, 0, NULL);\n\n    return dse_modify_return(retval, ec, ecc);\n}\n\nstatic int\ndse_pre_modify_plugin(Slapi_Entry *entryBefore, Slapi_Entry *entryAfter, LDAPMod **mods)\n{\n    const char *enabled = NULL;\n    int restart_plugin = 1;\n    int rc = 0;\n    int i;\n\n    /*\n     * Only check the mods if the plugin is enabled - no need to restart a plugin if it's not running.\n     */\n    if ((enabled = slapi_entry_attr_get_ref(entryBefore, ATTR_PLUGIN_ENABLED)) &&\n        !strcasecmp(enabled, \"on\")) {\n        for (i = 0; mods && mods[i]; i++) {\n            if (strcasecmp(mods[i]->mod_type, ATTR_PLUGIN_ENABLED) == 0) {\n                /* we already stop/started the pugin - don't do it again */\n                restart_plugin = 0;\n                break;\n            }\n        }\n        if (restart_plugin) { /* for all other plugin config changes, restart the plugin */\n            if (plugin_restart(entryBefore, entryAfter) != LDAP_SUCCESS) {\n                slapi_log_err(SLAPI_LOG_ERR, \"dse_pre_modify_plugin\",\n                              \"The configuration change for plugin (%s) could not be applied.\\n\",\n                              slapi_entry_get_dn(entryBefore));\n                rc = -1;\n            }\n        }\n    }\n    return rc;\n}\n\n/*\n * If this is modifying a plugin, check if we are disabling/enabling it - update the\n * global plugins as needed.\n *\n * Return 1 if the plugin was successfully started\n * Return 2 if the plugin was successfully stopped\n * Return -1 on error\n * Return 0 if nothing was done\n */\nstatic int\ndse_modify_plugin(Slapi_Entry *pre_entry, Slapi_Entry *post_entry, char *returntext)\n{\n    int rc = LDAP_SUCCESS;\n\n    if (slapi_entry_attr_hasvalue(pre_entry, \"nsslapd-pluginEnabled\", \"on\") &&\n        slapi_entry_attr_hasvalue(post_entry, \"nsslapd-pluginEnabled\", \"off\")) {\n        /*\n         * Plugin has been disabled\n         */\n        if (plugin_delete(post_entry, returntext, 0 /* not locked */)) {\n            rc = -1;\n        } else {\n            rc = 2; /* plugin disabled */\n            slapi_log_err(SLAPI_LOG_PLUGIN, \"dse_modify_plugin\", \"Disabled plugin (%s)\\n\",\n                          slapi_entry_get_dn(post_entry));\n        }\n    } else if (slapi_entry_attr_hasvalue(pre_entry, \"nsslapd-pluginEnabled\", \"off\") &&\n               slapi_entry_attr_hasvalue(post_entry, \"nsslapd-pluginEnabled\", \"on\")) {\n        /*\n         * Plugin has been enabled\n         */\n        if (plugin_add(post_entry, returntext, 0 /* not locked */)) {\n            rc = -1;\n        } else {\n            rc = 1; /* plugin started */\n            slapi_log_err(SLAPI_LOG_PLUGIN, \"dse_modify_plugin\", \"Enabled plugin (%s)\\n\",\n                          slapi_entry_get_dn(post_entry));\n        }\n    }\n\n    return rc;\n}\n\n/*\n * Add the plugin to the global plugin list\n */\nstatic int\ndse_add_plugin(Slapi_Entry *entry, char *returntext)\n{\n    int rc = LDAP_SUCCESS;\n\n    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, \"nsSlapdPlugin\") ||\n        !config_get_dynamic_plugins()) {\n        /*\n         * This is not a plugin, or we are not allowing dynamic updates.\n         */\n        return rc;\n    }\n    rc = plugin_add(entry, returntext, 0 /* not locked */);\n\n    return rc;\n}\n\n/*\n * Delete the plugin from the global plugin list\n */\nstatic int\ndse_delete_plugin(Slapi_Entry *entry, char *returntext)\n{\n    int rc = LDAP_SUCCESS;\n\n    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, \"nsSlapdPlugin\") ||\n        slapi_entry_attr_hasvalue(entry, \"nsslapd-PluginEnabled\", \"off\") ||\n        !config_get_dynamic_plugins()) {\n        /*\n         * This is not a plugin, this plugin was not enabled to begin with, or we\n         * are not allowing dynamic updates .\n         */\n        return rc;\n    }\n    rc = plugin_delete(entry, returntext, 0 /* not locked */);\n\n    return rc;\n}\n\nstatic int\ndse_add_return(int rv, Slapi_Entry *e)\n{\n    slapi_entry_free(e);\n    return rv;\n}\n\n/*\n * -1 means something went wrong.\n * 0 means everything went ok.\n */\nint\ndse_add(Slapi_PBlock *pb) /* JCM There should only be one exit point from this function! */\n{\n    Slapi_Entry *e = NULL;      /*The new entry to add*/\n    Slapi_Entry *e_copy = NULL; /* copy of added entry */\n    char *errbuf = NULL;\n    int rc = LDAP_SUCCESS;\n    int error = -1;\n    int dont_write_file = 0; /* default */\n    struct dse *pdse;\n    int returncode = LDAP_SUCCESS;\n    char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = \"\";\n    Slapi_DN *sdn = NULL;\n    Slapi_DN parent;\n    int need_be_postop = 0;\n    PRBool global_lock_owned = PR_FALSE;\n\n    /*\n     * Get the database, the dn and the entry to add\n     */\n    if (slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse) < 0 ||\n        slapi_pblock_get(pb, SLAPI_ADD_TARGET_SDN, &sdn) < 0 ||\n        slapi_pblock_get(pb, SLAPI_ADD_ENTRY, &e) < 0 || (NULL == pdse)) {\n        rc = LDAP_OPERATIONS_ERROR;\n        goto done;\n    }\n\n    slapi_pblock_get(pb, SLAPI_DSE_DONT_WRITE_WHEN_ADDING, &dont_write_file);\n    if (!dont_write_file && dse_check_for_readonly_error(pb, pdse)) {\n        return (error); /* result already sent */\n    }\n\n    /*\n     * Check to make sure the entry passes the schema check\n     */\n    if (slapi_entry_schema_check(pb, e) != 0) {\n        char *errtext;\n        slapi_log_err(SLAPI_DSE_TRACELEVEL,\n                      \"dse_add\", \"entry failed schema check\\n\");\n        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &errtext);\n        if (errtext && errtext[0]) {\n            PL_strncpyz(returntext, errtext, sizeof(returntext));\n        }\n        rc = LDAP_OBJECT_CLASS_VIOLATION;\n        e = NULL; /* caller will free upon error */\n        goto done;\n    }\n\n    /* Check if the attribute values in the entry obey the syntaxes */\n    if (slapi_entry_syntax_check(pb, e, 0) != 0) {\n        char *errtext;\n        slapi_log_err(SLAPI_DSE_TRACELEVEL,\n                      \"dse_add\", \"entry failed syntax check\\n\");\n        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &errtext);\n        if (errtext && errtext[0]) {\n            PL_strncpyz(returntext, errtext, sizeof(returntext));\n        }\n        rc = LDAP_INVALID_SYNTAX;\n        e = NULL; /* caller will free upon error */\n        goto done;\n    }\n\n    /*\n     * Attempt to find this dn.\n     */\n    {\n        Slapi_Entry *existingentry = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n        if (existingentry != NULL) {\n            /*\n             * If we've reached this code, there is an entry\n             * whose dn matches dn, so tell the user and return\n             */\n            slapi_entry_free(existingentry);\n            rc = LDAP_ALREADY_EXISTS;\n            e = NULL; /* caller will free upon error */\n            goto done;\n        }\n    }\n\n    /*\n     * Get the parent dn and see if the corresponding entry exists.\n     * If the parent does not exist, only allow the \"root\" user to\n     * add the entry.\n     */\n    slapi_sdn_init(&parent);\n    slapi_sdn_get_parent(sdn, &parent);\n    if (!slapi_sdn_isempty(&parent)) {\n        Slapi_Entry *parententry = NULL;\n        parententry = dse_get_entry_copy(pdse, &parent, DSE_USE_LOCK);\n        if (parententry == NULL) {\n            rc = LDAP_NO_SUCH_OBJECT;\n            slapi_log_err(SLAPI_DSE_TRACELEVEL, \" dse_add\", \"Narent does not exist\\n\");\n            slapi_sdn_done(&parent);\n            e = NULL; /* caller will free upon error */\n            goto done;\n        }\n        rc = plugin_call_acl_plugin(pb, parententry, NULL, NULL, SLAPI_ACL_ADD, ACLPLUGIN_ACCESS_DEFAULT, &errbuf);\n        slapi_entry_free(parententry);\n        if (rc != LDAP_SUCCESS) {\n            slapi_log_err(SLAPI_DSE_TRACELEVEL, \"dse_add\", \"No access to parent\\n\");\n            if (errbuf && errbuf[0]) {\n                PL_strncpyz(returntext, errbuf, sizeof(returntext));\n            }\n            slapi_ch_free_string(&errbuf);\n            slapi_sdn_done(&parent);\n            e = NULL; /* caller will free upon error */\n            goto done;\n        }\n    } else {\n        /* no parent */\n        int isroot;\n        slapi_pblock_get(pb, SLAPI_REQUESTOR_ISROOT, &isroot);\n        if (!isroot) {\n            slapi_log_err(SLAPI_DSE_TRACELEVEL, \"dse_add\", \"No parent and not root\\n\");\n            rc = LDAP_INSUFFICIENT_ACCESS;\n            slapi_sdn_done(&parent);\n            e = NULL; /* caller will free upon error */\n            goto done;\n        }\n    }\n    slapi_sdn_done(&parent);\n\n    /*\n     * Before we add the entry, find out if the syntax of the aci\n     * aci attribute values are correct or not. We don't want to add\n     * the entry if the syntax is incorrect.\n     */\n    if (plugin_call_acl_verify_syntax(pb, e, &errbuf) != 0) {\n        if (errbuf && errbuf[0]) {\n            PL_strncpyz(returntext, errbuf, sizeof(returntext));\n            slapi_ch_free_string(&errbuf);\n        }\n        rc = LDAP_INVALID_SYNTAX;\n        e = NULL; /* caller will free upon error */\n        goto done;\n    }\n\n    /* Possibly acquire the global backend lock */\n    if (global_backend_lock_requested()) {\n        global_backend_lock_lock();\n        global_lock_owned = PR_TRUE;\n    }\n\n    if (dse_call_callback(pdse, pb, SLAPI_OPERATION_ADD, DSE_FLAG_PREOP, e,\n                          NULL, &returncode, returntext) != SLAPI_DSE_CALLBACK_OK) {\n        if (!returncode) {\n            slapi_log_err(SLAPI_LOG_ERR, \"dse_add\",\n                          \"DSE PREOP callback returned error but did not set returncode\\n\");\n            returncode = LDAP_OPERATIONS_ERROR;\n        }\n        rc = returncode;\n        e = NULL; /* caller will free upon error */\n        goto done;\n    }\n    /* next, give the be plugins a crack at it */\n    slapi_pblock_set(pb, SLAPI_RESULT_CODE, &returncode);\n    plugin_call_plugins(pb, SLAPI_PLUGIN_BE_PRE_ADD_FN);\n    need_be_postop = 1; /* have to call be postops now */\n    if (!returncode) {\n        slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n    }\n    if (!returncode) {\n        /* finally, give the betxn plugins a crack at it */\n        plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_PRE_ADD_FN);\n        if (!returncode) {\n            slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n        }\n    }\n    if (returncode) {\n        if (!returntext[0]) {\n            char *ldap_result_message = NULL;\n            slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);\n            if (ldap_result_message && ldap_result_message[0]) {\n                PL_strncpyz(returntext, ldap_result_message, sizeof(returntext));\n            }\n        }\n        rc = returncode;\n        e = NULL; /* caller will free upon error */\n        goto done;\n    }\n    /*\n     * Check if we are adding a plugin\n     */\n    if (dse_add_plugin(e, returntext)) {\n        returncode = LDAP_UNWILLING_TO_PERFORM;\n        goto done;\n    }\n\n    /* make copy for postop fns because add_entry_pb consumes the given entry */\n    e_copy = slapi_entry_dup(e);\n    if (dse_add_entry_pb(pdse, e_copy, pb) != 0) {\n        rc = LDAP_OPERATIONS_ERROR;\n        e = NULL; /* caller will free upon error */\n        goto done;\n    }\n    /* The postop must be called after the write lock is released. */\n    dse_call_callback(pdse, pb, SLAPI_OPERATION_ADD, DSE_FLAG_POSTOP, e, NULL, &returncode, returntext);\ndone:\n    if (e) {\n        slapi_pblock_set(pb, SLAPI_ENTRY_POST_OP, slapi_entry_dup(e));\n    }\n\n    /* make sure OPRETURN and RESULT_CODE are set */\n    slapi_pblock_get(pb, SLAPI_PLUGIN_OPRETURN, &error);\n    if (rc || returncode) {\n        if (!error) {\n            slapi_pblock_set(pb, SLAPI_PLUGIN_OPRETURN, rc ? &rc : &returncode);\n        }\n        if (!returncode) {\n            returncode = rc;\n        }\n    }\n    if (need_be_postop) {\n        /* next, give the be txn plugins a crack at it */\n        slapi_pblock_set(pb, SLAPI_RESULT_CODE, &returncode);\n        plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_POST_ADD_FN);\n\n        /* finally, give the be plugins a crack at it */\n        plugin_call_plugins(pb, SLAPI_PLUGIN_BE_POST_ADD_FN);\n        if (!returncode) {\n            slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n        }\n    }\n    if (global_lock_owned) {\n        global_backend_lock_unlock();\n    }\n    slapi_send_ldap_result(pb, returncode, NULL, returntext[0] ? returntext : NULL, 0, NULL);\n    return dse_add_return(rc, e);\n}\n\n/*\n * -1 means something went wrong.\n * 0 means everything went ok.\n */\n\nstatic int\ndse_delete_return(int rv, Slapi_Entry *ec)\n{\n    slapi_entry_free(ec);\n    return rv;\n}\n\nint\ndse_delete(Slapi_PBlock *pb) /* JCM There should only be one exit point from this function! */\n{\n    int rc = -1;\n    int dont_write_file = 0; /* default */\n    struct dse *pdse = NULL;\n    int returncode = LDAP_SUCCESS;\n    char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = \"\";\n    char *entry_str = \"entry\";\n    char *errbuf = NULL;\n    char *attrs[2] = {NULL, NULL};\n    Slapi_DN *sdn = NULL;\n    Slapi_Entry *ec = NULL; /* copy of entry to delete */\n    Slapi_Entry *orig_entry = NULL;\n    int need_be_postop = 0;\n    PRBool global_lock_owned = PR_FALSE;\n\n    /*\n     * Get the database and the dn\n     */\n    if (slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse) < 0 ||\n        slapi_pblock_get(pb, SLAPI_DELETE_TARGET_SDN, &sdn) < 0 ||\n        (pdse == NULL)) {\n        returncode = LDAP_OPERATIONS_ERROR;\n        goto done;\n    }\n\n    slapi_pblock_get(pb, SLAPI_DSE_DONT_WRITE_WHEN_ADDING, &dont_write_file);\n    if (!dont_write_file && dse_check_for_readonly_error(pb, pdse)) {\n        return (rc); /* result already sent */\n    }\n\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        returncode = LDAP_NO_SUCH_OBJECT;\n        goto done;\n    }\n\n    /*\n     * Check if this node has any children.\n     */\n    if (dse_numsubordinates(ec) > 0) {\n        returncode = LDAP_NOT_ALLOWED_ON_NONLEAF;\n        goto done;\n    }\n\n    /*\n     * Check the access\n     */\n    attrs[0] = entry_str;\n    attrs[1] = NULL;\n    returncode = plugin_call_acl_plugin(pb, ec, attrs, NULL, SLAPI_ACL_DELETE, ACLPLUGIN_ACCESS_DEFAULT, &errbuf);\n    if (returncode != LDAP_SUCCESS) {\n        if (errbuf && errbuf[0]) {\n            PL_strncpyz(returntext, errbuf, sizeof(returntext));\n        }\n        slapi_ch_free_string(&errbuf);\n        goto done;\n    }\n\n    /* Possibly acquire the global backend lock */\n    if (global_backend_lock_requested()) {\n        global_backend_lock_lock();\n        global_lock_owned = PR_TRUE;\n    }\n\n    if (dse_call_callback(pdse, pb, SLAPI_OPERATION_DELETE, DSE_FLAG_PREOP, ec, NULL, &returncode, returntext) == SLAPI_DSE_CALLBACK_OK) {\n        slapi_pblock_set(pb, SLAPI_DELETE_BEPREOP_ENTRY, ec);\n        slapi_pblock_set(pb, SLAPI_RESULT_CODE, &returncode);\n        plugin_call_plugins(pb, SLAPI_PLUGIN_BE_PRE_DELETE_FN);\n        need_be_postop = 1;\n        if (!returncode) {\n            slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n        }\n        if (!returncode) {\n            plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_PRE_DELETE_FN);\n            if (!returncode) {\n                slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n            }\n            if (!returncode) {\n                if (dse_delete_entry(pdse, pb, ec) == 0) {\n                    returncode = LDAP_OPERATIONS_ERROR;\n                }\n            }\n        }\n        /* Setting SLAPI_ENTRY_PRE_OP here,\n         * since some betxn postop may need the pre op entry. */\n        slapi_pblock_set(pb, SLAPI_ENTRY_PRE_OP, slapi_entry_dup(ec));\n    } else {\n        goto done;\n    }\n\n    dse_call_callback(pdse, pb, SLAPI_OPERATION_DELETE, DSE_FLAG_POSTOP, ec, NULL, &returncode, returntext);\ndone:\n    slapi_pblock_get(pb, SLAPI_DELETE_BEPOSTOP_ENTRY, &orig_entry);\n    slapi_pblock_set(pb, SLAPI_DELETE_BEPOSTOP_ENTRY, ec);\n    /* make sure OPRETURN and RESULT_CODE are set */\n    slapi_pblock_get(pb, SLAPI_PLUGIN_OPRETURN, &rc);\n    if (returncode || rc) {\n        if (!rc) {\n            slapi_pblock_set(pb, SLAPI_PLUGIN_OPRETURN, &returncode);\n        }\n        if (!returncode) {\n            returncode = rc;\n        }\n    }\n    if (need_be_postop) {\n        plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_POST_DELETE_FN);\n        if (!returncode) {\n            slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n        }\n\n        /* finally, give the be plugins a crack at it */\n        plugin_call_plugins(pb, SLAPI_PLUGIN_BE_POST_DELETE_FN);\n        if (!returncode) {\n            slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n        }\n    }\n    if (global_lock_owned) {\n        global_backend_lock_unlock();\n    }\n    if (returncode && !returntext[0]) {\n        char *ldap_result_message = NULL;\n        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);\n        if (ldap_result_message && ldap_result_message[0]) {\n            PL_strncpyz(returntext, ldap_result_message, sizeof(returntext));\n        }\n    }\n    /*\n     * Check if we are deleting a plugin\n     */\n    if (returncode == LDAP_SUCCESS) {\n        if (dse_delete_plugin(ec, returntext)) {\n            rc = LDAP_UNWILLING_TO_PERFORM;\n        }\n    }\n    slapi_pblock_set(pb, SLAPI_DELETE_BEPOSTOP_ENTRY, orig_entry);\n    slapi_send_ldap_result(pb, returncode, NULL, returntext, 0, NULL);\n    return dse_delete_return(returncode, ec);\n}\n\nstruct dse_callback *\ndse_register_callback(struct dse *pdse,\n                      int operation,\n                      int flags,\n                      const Slapi_DN *base,\n                      int scope,\n                      const char *filter,\n                      dseCallbackFn fn,\n                      void *fn_arg,\n                      struct slapdplugin *plugin)\n{\n    struct dse_callback *callback = dse_callback_new(operation, flags, base, scope, filter, fn, fn_arg, plugin);\n    dse_callback_addtolist(&pdse->dse_callback, callback);\n    return callback;\n}\n\nvoid\ndse_remove_callback(struct dse *pdse, int operation, int flags, const Slapi_DN *base, int scope, const char *filter, dseCallbackFn fn)\n{\n    dse_callback_removefromlist(&pdse->dse_callback, operation, flags, base, scope, filter, fn);\n}\n\n/*\n * Return values:\n *    SLAPI_DSE_CALLBACK_ERROR        -- Callback failed.\n *  SLAPI_DSE_CALLBACK_OK           -- OK, do it.\n *  SLAPI_DSE_CALLBACK_DO_NOT_APPLY -- No error, but don't apply changes.\n */\nstatic int\ndse_call_callback(struct dse *pdse, Slapi_PBlock *pb, int operation, int flags, Slapi_Entry *entryBefore, Slapi_Entry *entryAfter, int *returncode, char *returntext)\n{\n    /* ONREPL callbacks can potentially modify pblock parameters like backend\n     * which would cause problems during request processing. We need to save\n     * \"important\" fields before calls and restoring them afterwards */\n    int rc = SLAPI_DSE_CALLBACK_OK;\n\n    if (pdse->dse_callback != NULL) {\n        struct dse_callback *p = pdse->dse_callback;\n        struct dse_callback *next = NULL;\n        int result = SLAPI_DSE_CALLBACK_OK;\n\n        while (p != NULL) {\n            next = p->next;\n            if ((p->operation & operation) && (p->flags & flags)) {\n                if (slapi_sdn_scope_test(slapi_entry_get_sdn_const(entryBefore), p->base, p->scope)) {\n                    if (NULL == p->slapifilter || slapi_vattr_filter_test(pb, entryBefore, p->slapifilter, 0) == 0) {\n                        struct slapdplugin *plugin = p->plugin;\n                        int plugin_started = 1;\n\n                        if (plugin) {\n                            /* this is a plugin callback, update the operation counter */\n                            slapi_plugin_op_started(plugin);\n                            if (!plugin->plg_started) {\n                                /* must be a task function being called */\n                                result = SLAPI_DSE_CALLBACK_ERROR;\n                                PR_snprintf(returntext, SLAPI_DSE_RETURNTEXT_SIZE,\n                                            \"Task entry (%s) could not added because the (%s) plugin is disabled.\",\n                                            slapi_entry_get_dn(entryBefore), p->plugin->plg_dn);\n                                plugin_started = 0;\n                            }\n                        }\n                        if (plugin_started) {\n                            result = (*p->fn)(pb, entryBefore, entryAfter, returncode, returntext, p->fn_arg);\n                        }\n                        if (result < rc) {\n                            rc = result;\n                        }\n                        slapi_plugin_op_finished(plugin);\n                    }\n                }\n            }\n            p = next;\n        }\n    }\n    return rc;\n}\n\nint\nslapi_config_register_callback(int operation,\n                               int flags,\n                               const char *base,\n                               int scope,\n                               const char *filter,\n                               dseCallbackFn fn,\n                               void *fn_arg)\n{\n    return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);\n}\n\n/*\n *  We pass in the pblock so we can update the operation counter for \"dynamic plugins\".\n */\nint\nslapi_config_register_callback_plugin(int operation,\n                                      int flags,\n                                      const char *base,\n                                      int scope,\n                                      const char *filter,\n                                      dseCallbackFn fn,\n                                      void *fn_arg,\n                                      Slapi_PBlock *pb)\n{\n    int rc = 0;\n    Slapi_Backend *be = slapi_be_select_by_instance_name(DSE_BACKEND);\n    if (be != NULL) {\n        struct dse *pdse = (struct dse *)be->be_database->plg_private;\n        if (pdse != NULL) {\n            Slapi_DN dn;\n            slapi_sdn_init_dn_byref(&dn, base);\n            if (pb != NULL) {\n                /* if a pblock was passed, this is a plugin, so set the f_arg as the plugin */\n                struct slapdplugin *pb_plugin = NULL;\n                slapi_pblock_get(pb, SLAPI_PLUGIN, &pb_plugin);\n                rc = (NULL != dse_register_callback(pdse, operation, flags, &dn, scope, filter, fn,\n                                                    (void *)pb_plugin, pb_plugin));\n            } else {\n                rc = (NULL != dse_register_callback(pdse, operation, flags, &dn, scope, filter, fn,\n                                                    fn_arg, NULL));\n            }\n\n            slapi_sdn_done(&dn);\n        }\n    }\n    return rc;\n}\n\n\nint\nslapi_config_remove_callback(int operation, int flags, const char *base, int scope, const char *filter, dseCallbackFn fn)\n{\n    int rc = 0;\n    Slapi_Backend *be = slapi_be_select_by_instance_name(DSE_BACKEND);\n    if (be != NULL) {\n        struct dse *pdse = (struct dse *)be->be_database->plg_private;\n        if (pdse != NULL) {\n            Slapi_DN dn;\n            slapi_sdn_init_dn_byref(&dn, base);\n            dse_remove_callback(pdse, operation, flags, &dn, scope, filter, fn);\n            slapi_sdn_done(&dn);\n            rc = 1;\n        }\n    }\n    return rc;\n}\n\nvoid\ndse_set_dont_ever_write_dse_files()\n{\n    dont_ever_write_dse_files = 1;\n}\n\nvoid\ndse_unset_dont_ever_write_dse_files()\n{\n    dont_ever_write_dse_files = 0;\n}\n\nstatic dse_search_set *\ndse_search_set_new(void)\n{\n    dse_search_set *ss;\n\n    ss = (dse_search_set *)slapi_ch_malloc(sizeof(*ss));\n\n    if (ss) {\n        dl_init(&ss->dl, 0);\n        ss->current_entry = -1;\n    }\n\n    return ss;\n}\n\n/* This is similar to delete, but it does not free the entries contained in the\n   search set.  This is useful in do_dse_search when we copy the entries from\n   1 search set to the other. */\nstatic void\ndse_search_set_clean(dse_search_set *ss)\n{\n    if (ss) {\n        dl_cleanup(&ss->dl, NULL);\n        slapi_ch_free((void **)&ss);\n    }\n}\n\nvoid\ndse_search_set_release(void **ss)\n{\n    dse_search_set_delete(*(dse_search_set **)ss);\n}\n\nvoid\ndse_prev_search_results(void *vp)\n{\n    Slapi_PBlock *pb = (Slapi_PBlock *)vp;\n    dse_search_set *ss;\n    slapi_pblock_get(pb, SLAPI_SEARCH_RESULT_SET, &ss);\n    if (ss) {\n        dl_get_prev(&ss->dl, &ss->current_entry);\n    }\n}\n\nstatic void\ndse_search_set_delete(dse_search_set *ss)\n{\n    if (ss) {\n        dl_cleanup(&ss->dl, dse_free_entry);\n        slapi_ch_free((void **)&ss);\n    }\n}\n\nstatic void\ndse_free_entry(void **data)\n{\n    Slapi_Entry **e;\n\n    if (data) {\n        e = (Slapi_Entry **)data;\n        if (*e)\n            slapi_entry_free(*e);\n    }\n}\n\nstatic void\ndse_search_set_add_entry(dse_search_set *ss, Slapi_Entry *e)\n{\n    PR_ASSERT(ss && e);\n\n    dl_add(&ss->dl, e);\n}\n\nstatic Slapi_Entry *\ndse_search_set_get_next_entry(dse_search_set *ss)\n{\n    PR_ASSERT(ss);\n\n    if (ss->current_entry == -1)\n        return (dl_get_first(&ss->dl, &ss->current_entry));\n    else\n        return (dl_get_next(&ss->dl, &ss->current_entry));\n}\n\nint\ndse_next_search_entry(Slapi_PBlock *pb)\n{\n    dse_search_set *ss;\n    Slapi_Entry *e;\n\n    slapi_pblock_get(pb, SLAPI_SEARCH_RESULT_SET, &ss);\n\n    /* no entries to return */\n    if (ss == NULL) {\n        slapi_pblock_set(pb, SLAPI_SEARCH_RESULT_ENTRY, NULL);\n        return 0;\n    }\n\n    e = dse_search_set_get_next_entry(ss);\n    slapi_pblock_set(pb, SLAPI_SEARCH_RESULT_ENTRY, e);\n\n    /* we reached the end of the list */\n    if (e == NULL) {\n        pagedresults_set_search_result_pb(pb, NULL, 0);\n        dse_search_set_delete(ss);\n        slapi_pblock_set(pb, SLAPI_SEARCH_RESULT_SET, NULL);\n    }\n\n    return 0;\n}\n"], "fixing_code": ["# --- BEGIN COPYRIGHT BLOCK ---\n# Copyright (C) 2020 Red Hat, Inc.\n# All rights reserved.\n#\n# License: GPL (version 3 or any later version).\n# See LICENSE for details.\n# --- END COPYRIGHT BLOCK ---\n#\n\nfrom subprocess import check_output, PIPE, run\nfrom lib389 import DirSrv\nfrom lib389.idm.user import UserAccount, UserAccounts\nimport pytest\nfrom lib389.tasks import *\nfrom lib389.utils import *\nfrom lib389.topologies import topology_st\nfrom lib389.dbgen import dbgen_users\nfrom lib389.idm.organizationalunit import OrganizationalUnits\nfrom lib389._constants import DN_DM, PASSWORD, PW_DM\nfrom lib389.paths import Paths\nfrom lib389.idm.directorymanager import DirectoryManager\nfrom lib389.config import LDBMConfig\nfrom lib389.dseldif import DSEldif\nfrom lib389.rootdse import RootDSE\n\n\npytestmark = pytest.mark.tier0\n\ndefault_paths = Paths()\n\nlog = logging.getLogger(__name__)\n\n# Globals\nUSER1_DN = 'uid=user1,' + DEFAULT_SUFFIX\nUSER2_DN = 'uid=user2,' + DEFAULT_SUFFIX\nUSER3_DN = 'uid=user3,' + DEFAULT_SUFFIX\nUSER4_DN = 'uid=user4,' + DEFAULT_SUFFIX\n\nROOTDSE_DEF_ATTR_LIST = ('namingContexts',\n                         'supportedLDAPVersion',\n                         'supportedControl',\n                         'supportedExtension',\n                         'supportedSASLMechanisms',\n                         'vendorName',\n                         'vendorVersion')\n\n\n@pytest.fixture(scope=\"module\")\ndef import_example_ldif(topology_st):\n    \"\"\"Import the Example LDIF for the tests in this suite\"\"\"\n\n    log.info('Initializing the \"basic\" test suite')\n\n    ldif = '%s/dirsrv/data/Example.ldif' % topology_st.standalone.get_data_dir()\n    import_ldif = topology_st.standalone.get_ldif_dir() + \"/Example.ldif\"\n    shutil.copy(ldif, import_ldif)\n\n    import_task = ImportTask(topology_st.standalone)\n    import_task.import_suffix_from_ldif(ldiffile=import_ldif, suffix=DEFAULT_SUFFIX)\n    import_task.wait()\n\n\n@pytest.fixture(params=ROOTDSE_DEF_ATTR_LIST)\ndef rootdse_attr(topology_st, request):\n    \"\"\"Adds an attr from the list\n    as the default attr to the rootDSE\n    \"\"\"\n    # Ensure the server is started and connected\n    topology_st.standalone.start()\n\n    RETURN_DEFAULT_OPATTR = \"nsslapd-return-default-opattr\"\n    rootdse_attr_name = ensure_bytes(request.param)\n\n    log.info(\"        Add the %s: %s to rootdse\" % (RETURN_DEFAULT_OPATTR,\n                                                    rootdse_attr_name))\n    mod = [(ldap.MOD_ADD, RETURN_DEFAULT_OPATTR, rootdse_attr_name)]\n    try:\n        topology_st.standalone.modify_s(\"\", mod)\n    except ldap.LDAPError as e:\n        log.fatal('Failed to add attr: error (%s)' % (e.args[0]['desc']))\n        assert False\n\n    def fin():\n        log.info(\"        Delete the %s: %s from rootdse\" % (RETURN_DEFAULT_OPATTR,\n                                                             rootdse_attr_name))\n        mod = [(ldap.MOD_DELETE, RETURN_DEFAULT_OPATTR, rootdse_attr_name)]\n        try:\n            topology_st.standalone.modify_s(\"\", mod)\n        except ldap.LDAPError as e:\n            log.fatal('Failed to delete attr: error (%s)' % (e.args[0]['desc']))\n            assert False\n\n    request.addfinalizer(fin)\n\n    return rootdse_attr_name\n\n\ndef test_basic_ops(topology_st, import_example_ldif):\n    \"\"\"Tests adds, mods, modrdns, and deletes operations\n\n    :id: 33f97f55-60bf-46c7-b880-6c488517ae19\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Add 3 test users USER1, USER2 and USER3 to database\n         2. Modify (ADD, REPLACE and DELETE) description for USER1 in database\n         3. Rename USER1, USER2 and USER3 using Modrds\n         4. Delete test entries USER1, USER2 and USER3\n\n    :expectedresults:\n         1. Add operation should PASS.\n         2. Modify operations should PASS.\n         3. Rename operations should PASS.\n         4. Delete operations should PASS.\n    \"\"\"\n    log.info('Running test_basic_ops...')\n    USER1_NEWDN = 'cn=user1'\n    USER2_NEWDN = 'cn=user2'\n    USER3_NEWDN = 'cn=user3'\n    NEW_SUPERIOR = 'ou=people,' + DEFAULT_SUFFIX\n    USER1_RDN_DN = 'cn=user1,' + DEFAULT_SUFFIX\n    USER2_RDN_DN = 'cn=user2,' + DEFAULT_SUFFIX\n    USER3_RDN_DN = 'cn=user3,' + NEW_SUPERIOR  # New superior test\n\n    #\n    # Adds#\n    try:\n        topology_st.standalone.add_s(Entry((USER1_DN,\n                                            {'objectclass': \"top extensibleObject\".split(),\n                                             'sn': '1',\n                                             'cn': 'user1',\n                                             'uid': 'user1',\n                                             'userpassword': 'password'})))\n    except ldap.LDAPError as e:\n        log.error('Failed to add test user' + USER1_DN + ': error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.add_s(Entry((USER2_DN,\n                                            {'objectclass': \"top extensibleObject\".split(),\n                                             'sn': '2',\n                                             'cn': 'user2',\n                                             'uid': 'user2',\n                                             'userpassword': 'password'})))\n    except ldap.LDAPError as e:\n        log.error('Failed to add test user' + USER2_DN + ': error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.add_s(Entry((USER3_DN,\n                                            {'objectclass': \"top extensibleObject\".split(),\n                                             'sn': '3',\n                                             'cn': 'user3',\n                                             'uid': 'user3',\n                                             'userpassword': 'password'})))\n    except ldap.LDAPError as e:\n        log.error('Failed to add test user' + USER3_DN + ': error ' + e.args[0]['desc'])\n        assert False\n\n    #\n    # Mods\n    #\n    try:\n        topology_st.standalone.modify_s(USER1_DN, [(ldap.MOD_ADD, 'description',\n                                                    b'New description')])\n    except ldap.LDAPError as e:\n        log.error('Failed to add description: error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.modify_s(USER1_DN, [(ldap.MOD_REPLACE, 'description',\n                                                    b'Modified description')])\n    except ldap.LDAPError as e:\n        log.error('Failed to modify description: error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.modify_s(USER1_DN, [(ldap.MOD_DELETE, 'description',\n                                                    None)])\n    except ldap.LDAPError as e:\n        log.error('Failed to delete description: error ' + e.args[0]['desc'])\n        assert False\n\n    #\n    # Modrdns\n    #\n    try:\n        topology_st.standalone.rename_s(USER1_DN, USER1_NEWDN, delold=1)\n    except ldap.LDAPError as e:\n        log.error('Failed to modrdn user1: error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.rename_s(USER2_DN, USER2_NEWDN, delold=0)\n    except ldap.LDAPError as e:\n        log.error('Failed to modrdn user2: error ' + e.args[0]['desc'])\n        assert False  # Modrdn - New superior\n\n    try:\n        topology_st.standalone.rename_s(USER3_DN, USER3_NEWDN,\n                                        newsuperior=NEW_SUPERIOR, delold=1)\n    except ldap.LDAPError as e:\n        log.error('Failed to modrdn(new superior) user3: error ' + e.args[0]['desc'])\n        assert False\n    #\n    # Deletes\n    #\n    try:\n        topology_st.standalone.delete_s(USER1_RDN_DN)\n    except ldap.LDAPError as e:\n        log.error('Failed to delete test entry1: ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.delete_s(USER2_RDN_DN)\n    except ldap.LDAPError as e:\n        log.error('Failed to delete test entry2: ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.delete_s(USER3_RDN_DN)\n    except ldap.LDAPError as e:\n        log.error('Failed to delete test entry3: ' + e.args[0]['desc'])\n        assert False\n    log.info('test_basic_ops: PASSED')\n\n\ndef test_basic_import_export(topology_st, import_example_ldif):\n    \"\"\"Test online and offline LDIF import & export\n\n    :id: 3ceeea11-9235-4e20-b80e-7203b2c6e149\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Generate a test ldif (50k entries)\n         2. Import test ldif file using Online import.\n         3. Import test ldif file using Offline import (ldif2db).\n         4. Export test ldif file using Online export.\n         5. Export test ldif file using Offline export (db2ldif).\n         6. Cleanup - Import the Example LDIF for the other tests in this suite\n\n    :expectedresults:\n         1. Test ldif file creation should PASS.\n         2. Online import should PASS.\n         3. Offline import should PASS.\n         4. Online export should PASS.\n         5. Offline export should PASS.\n         6. Cleanup should PASS.\n    \"\"\"\n\n    log.info('Running test_basic_import_export...')\n    #\n    # Test online/offline LDIF imports\n    #\n    topology_st.standalone.start()\n    # topology_st.standalone.config.set('nsslapd-errorlog-level', '1')\n\n    # Generate a test ldif (50k entries)\n    log.info(\"Generating LDIF...\")\n    ldif_dir = topology_st.standalone.get_ldif_dir()\n    import_ldif = ldif_dir + '/basic_import.ldif'\n    dbgen_users(topology_st.standalone, 50000, import_ldif, DEFAULT_SUFFIX)\n\n\n    # Online\n    log.info(\"Importing LDIF online...\")\n    import_task = ImportTask(topology_st.standalone)\n    import_task.import_suffix_from_ldif(ldiffile=import_ldif, suffix=DEFAULT_SUFFIX)\n\n    # Wait a bit till the task is created and available for searching\n    time.sleep(0.5)\n\n    # Good as place as any to quick test the task has some expected attributes\n    if ds_is_newer('1.4.1.2'):\n        assert import_task.present('nstaskcreated')\n    assert import_task.present('nstasklog')\n    assert import_task.present('nstaskcurrentitem')\n    assert import_task.present('nstasktotalitems')\n    assert import_task.present('ttl')\n\n    import_task.wait()\n\n    # Offline\n    log.info(\"Importing LDIF offline...\")\n    topology_st.standalone.stop()\n    if not topology_st.standalone.ldif2db(DEFAULT_BENAME, None, None, None, import_ldif):\n        log.fatal('test_basic_import_export: Offline import failed')\n        assert False\n    topology_st.standalone.start()\n\n    #\n    # Test online and offline LDIF export\n    #\n\n    # Online export\n    log.info(\"Exporting LDIF online...\")\n    export_ldif = ldif_dir + '/export.ldif'\n\n    export_task = ExportTask(topology_st.standalone)\n    export_task.export_suffix_to_ldif(ldiffile=export_ldif, suffix=DEFAULT_SUFFIX)\n    export_task.wait()\n\n    # Offline export\n    log.info(\"Exporting LDIF offline...\")\n    topology_st.standalone.stop()\n    if not topology_st.standalone.db2ldif(DEFAULT_BENAME, (DEFAULT_SUFFIX,),\n                                          None, None, None, export_ldif):\n        log.fatal('test_basic_import_export: Failed to run offline db2ldif')\n        assert False\n\n    topology_st.standalone.start()\n\n    #\n    # Cleanup - Import the Example LDIF for the other tests in this suite\n    #\n    log.info(\"Restore datrabase, import initial LDIF...\")\n    ldif = '%s/dirsrv/data/Example.ldif' % topology_st.standalone.get_data_dir()\n    import_ldif = topology_st.standalone.get_ldif_dir() + \"/Example.ldif\"\n    shutil.copyfile(ldif, import_ldif)\n\n    import_task = ImportTask(topology_st.standalone)\n    import_task.import_suffix_from_ldif(ldiffile=import_ldif, suffix=DEFAULT_SUFFIX)\n    import_task.wait()\n\n    log.info('test_basic_import_export: PASSED')\n\n\ndef test_basic_backup(topology_st, import_example_ldif):\n    \"\"\"Tests online and offline backup and restore\n\n    :id: 0e9d91f8-8748-40b6-ab03-fbd1998eb985\n\n    :setup: Standalone instance and import example.ldif\n\n    :steps:\n         1. Test online backup using db2bak.\n         2. Test online restore using bak2db.\n         3. Test offline backup using db2bak.\n         4. Test offline restore using bak2db.\n\n    :expectedresults:\n         1. Online backup should PASS.\n         2. Online restore should PASS.\n         3. Offline backup should PASS.\n         4. Offline restore should PASS.\n    \"\"\"\n\n    log.info('Running test_basic_backup...')\n\n    backup_dir = topology_st.standalone.get_bak_dir() + '/backup_test'\n\n    # Test online backup\n    try:\n        topology_st.standalone.tasks.db2bak(backup_dir=backup_dir,\n                                            args={TASK_WAIT: True})\n    except ValueError:\n        log.fatal('test_basic_backup: Online backup failed')\n        assert False\n\n    # Test online restore\n    try:\n        topology_st.standalone.tasks.bak2db(backup_dir=backup_dir,\n                                            args={TASK_WAIT: True})\n    except ValueError:\n        log.fatal('test_basic_backup: Online restore failed')\n        assert False\n\n    # Test offline backup\n    topology_st.standalone.stop()\n    if not topology_st.standalone.db2bak(backup_dir):\n        log.fatal('test_basic_backup: Offline backup failed')\n        assert False\n\n    # Test offline restore\n    if not topology_st.standalone.bak2db(backup_dir):\n        log.fatal('test_basic_backup: Offline backup failed')\n        assert False\n    topology_st.standalone.start()\n\n    log.info('test_basic_backup: PASSED')\n\n\ndef test_basic_db2index(topology_st, import_example_ldif):\n    \"\"\"Assert db2index can operate correctly.\n\n    :id: 191fc0fd-9722-46b5-a7c3-e8760effe119\n\n    :setup: Standalone instance\n\n    :steps:\n        1: call db2index\n\n    :expectedresults:\n        1: Index succeeds.\n\n    \"\"\"\n    topology_st.standalone.stop()\n    topology_st.standalone.db2index()\n    topology_st.standalone.db2index(suffixes=[DEFAULT_SUFFIX], attrs=['uid'])\n    topology_st.standalone.start()\n\n\ndef test_basic_acl(topology_st, import_example_ldif):\n    \"\"\"Run some basic access control (ACL) tests\n\n    :id: 4f4e705f-32f4-4065-b3a8-2b0c2525798b\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Add two test users USER1_DN and USER2_DN.\n         2. Add an aci that denies USER1 from doing anything.\n         3. Set the default anonymous access for USER2.\n         4. Try searching entries using USER1.\n         5. Try searching entries using USER2.\n         6. Try searching entries using root dn.\n         7. Cleanup - delete test users and test ACI.\n\n    :expectedresults:\n         1. Test Users should be added.\n         2. ACI should be added.\n         3. This operation should PASS.\n         4. USER1 should not be able to search anything.\n         5. USER2 should be able to search everything except password.\n         6. RootDN should be allowed to search everything.\n         7. Cleanup should PASS.\n    \"\"\"\n\n    \"\"\"Run some basic access control(ACL) tests\"\"\"\n    log.info('Running test_basic_acl...')\n\n    DENY_ACI = ensure_bytes('(targetattr = \"*\")(version 3.0;acl \"deny user\";deny (all)(userdn = \"ldap:///%s\");)' % USER1_DN)\n\n    #\n    # Add two users\n    #\n    try:\n        topology_st.standalone.add_s(Entry((USER1_DN,\n                                            {'objectclass': \"top extensibleObject\".split(),\n                                             'sn': '1',\n                                             'cn': 'user 1',\n                                             'uid': 'user1',\n                                             'userpassword': PASSWORD})))\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to add test user ' + USER1_DN +\n                  ': error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.add_s(Entry((USER2_DN,\n                                            {'objectclass': \"top extensibleObject\".split(),\n                                             'sn': '2',\n                                             'cn': 'user 2',\n                                             'uid': 'user2',\n                                             'userpassword': PASSWORD})))\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to add test user ' + USER1_DN +\n                  ': error ' + e.args[0]['desc'])\n        assert False\n\n    #\n    # Add an aci that denies USER1 from doing anything,\n    # and also set the default anonymous access\n    #\n    try:\n        topology_st.standalone.modify_s(DEFAULT_SUFFIX, [(ldap.MOD_ADD, 'aci', DENY_ACI)])\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to add DENY ACI: error ' + e.args[0]['desc'])\n        assert False\n\n    #\n    # Make sure USER1_DN can not search anything, but USER2_dn can...\n    #\n    try:\n        topology_st.standalone.simple_bind_s(USER1_DN, PASSWORD)\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to bind as user1, error: ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        entries = topology_st.standalone.search_s(DEFAULT_SUFFIX,\n                                                  ldap.SCOPE_SUBTREE,\n                                                  '(uid=*)')\n        if entries:\n            log.fatal('test_basic_acl: User1 was incorrectly able to search the suffix!')\n            assert False\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Search suffix failed(as user1): ' + e.args[0]['desc'])\n        assert False\n\n    # Now try user2...  Also check that userpassword is stripped out\n    try:\n        topology_st.standalone.simple_bind_s(USER2_DN, PASSWORD)\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to bind as user2, error: ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        entries = topology_st.standalone.search_s(DEFAULT_SUFFIX,\n                                                  ldap.SCOPE_SUBTREE,\n                                                  '(uid=user1)')\n        if not entries:\n            log.fatal('test_basic_acl: User1 incorrectly not able to search the suffix')\n            assert False\n        if entries[0].hasAttr('userpassword'):\n            # The default anonymous access aci should have stripped out userpassword\n            log.fatal('test_basic_acl: User2 was incorrectly able to see userpassword')\n            assert False\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Search for user1 failed(as user2): ' + e.args[0]['desc'])\n        assert False\n\n    # Make sure RootDN can also search (this also resets the bind dn to the\n    # Root DN for future operations)\n    try:\n        topology_st.standalone.simple_bind_s(DN_DM, PW_DM)\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to bind as ROotDN, error: ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        entries = topology_st.standalone.search_s(DEFAULT_SUFFIX,\n                                                  ldap.SCOPE_SUBTREE,\n                                                  '(uid=*)')\n        if not entries:\n            log.fatal('test_basic_acl: Root DN incorrectly not able to search the suffix')\n            assert False\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Search for user1 failed(as user2): ' + e.args[0]['desc'])\n        assert False\n\n    #\n    # Cleanup\n    #\n    try:\n        topology_st.standalone.modify_s(DEFAULT_SUFFIX, [(ldap.MOD_DELETE, 'aci', DENY_ACI)])\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to delete DENY ACI: error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.delete_s(USER1_DN)\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to delete test entry1: ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.delete_s(USER2_DN)\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_acl: Failed to delete test entry2: ' + e.args[0]['desc'])\n        assert False\n\n    log.info('test_basic_acl: PASSED')\n\n\ndef test_basic_searches(topology_st, import_example_ldif):\n    \"\"\"Tests basic search operations with filters.\n\n    :id: 426a59ff-49b8-4a70-b377-0c0634a29b6f\n\n    :setup: Standalone instance, add example.ldif to the database\n\n    :steps:\n         1. Execute search command while using different filters.\n         2. Check number of entries returned by search filters.\n\n    :expectedresults:\n         1. Search command should PASS.\n         2. Number of result entries returned should match number of the database entries according to the search filter.\n    \"\"\"\n\n    log.info('Running test_basic_searches...')\n\n    filters = (('(uid=scarter)', 1),\n               ('(uid=tmorris*)', 1),\n               ('(uid=*hunt*)', 4),\n               ('(uid=*cope)', 2),\n               ('(mail=*)', 150),\n               ('(roomnumber>=4000)', 35),\n               ('(roomnumber<=4000)', 115),\n               ('(&(roomnumber>=4000)(roomnumber<=4500))', 18),\n               ('(!(l=sunnyvale))', 120),\n               ('(&(uid=t*)(l=santa clara))', 7),\n               ('(|(uid=k*)(uid=r*))', 18),\n               ('(|(uid=t*)(l=sunnyvale))', 50),\n               ('(&(!(uid=r*))(ou=people))', 139),\n               ('(&(uid=m*)(l=sunnyvale)(ou=people)(mail=*example*)(roomNumber=*))', 3),\n               ('(&(|(uid=m*)(l=santa clara))(roomNumber=22*))', 5),\n               ('(&(|(uid=m*)(l=santa clara))(roomNumber=22*)(!(roomnumber=2254)))', 4),)\n\n    for (search_filter, search_result) in filters:\n        try:\n            entries = topology_st.standalone.search_s(DEFAULT_SUFFIX,\n                                                      ldap.SCOPE_SUBTREE,\n                                                      search_filter)\n            if len(entries) != search_result:\n                log.fatal('test_basic_searches: An incorrect number of entries\\\n                        was returned from filter (%s): (%d) expected (%d)' %\n                          (search_filter, len(entries), search_result))\n                assert False\n        except ldap.LDAPError as e:\n            log.fatal('Search failed: ' + e.args[0]['desc'])\n            assert False\n\n    log.info('test_basic_searches: PASSED')\n\n\n@pytest.fixture(scope=\"module\")\ndef add_test_entry(topology_st, request):\n    # Add test entry\n    topology_st.standalone.add_s(Entry((USER4_DN,\n                                        {'objectclass': \"top extensibleObject\".split(),\n                                         'cn': 'user1', 'uid': 'user1'})))\n\n\nsearch_params = [(['1.1'], 'cn', False),\n                 (['1.1', 'cn'], 'cn', True),\n                 (['+'], 'nsUniqueId', True),\n                 (['*'], 'cn', True),\n                 (['cn'], 'cn', True)]\n@pytest.mark.skipif(ds_is_older(\"1.4.2.0\"), reason=\"Not implemented\")\n@pytest.mark.parametrize(\"attrs, attr, present\", search_params)\ndef test_search_req_attrs(topology_st, add_test_entry, attrs, attr, present):\n    \"\"\"Test requested attributes in search operations.\n\n    :id: 426a59ff-49b8-4a70-b377-0c0634a29b6e\n    :parametrized: yes\n    :setup: Standalone instance\n    :steps:\n         1. Test \"1.1\" does not return any attributes.\n         2. Test \"1.1\" is ignored if there are other requested attributes\n         3. Test \"+\" returns all operational attributes\n         4. Test \"*\" returns all attributes\n         5. Test requested attributes\n\n    :expectedresults:\n         1. Success\n         2. Success\n         3. Success\n         4. Success\n         5. Success\n    \"\"\"\n\n    log.info(\"Testing attrs: {} attr: {} present: {}\".format(attrs, attr, present))\n    entry = topology_st.standalone.search_s(USER4_DN,\n                                            ldap.SCOPE_BASE,\n                                            'objectclass=top',\n                                            attrs)\n    if present:\n        assert entry[0].hasAttr(attr)\n    else:\n        assert not entry[0].hasAttr(attr)\n\n\ndef test_basic_referrals(topology_st, import_example_ldif):\n    \"\"\"Test LDAP server in referral mode.\n\n    :id: c586aede-7ac3-4e8d-a1cf-bfa8b8d78cc2\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Set the referral and the backend state\n         2. Set backend state to referral mode.\n         3. Set server to not follow referral.\n         4. Search using referral.\n         5. Make sure server can restart in referral mode.\n         6. Cleanup - Delete referral.\n\n    :expectedresults:\n         1. Set the referral, and the backend state should PASS.\n         2. Set backend state to referral mode should PASS.\n         3. Set server to not follow referral should PASS.\n         4. referral error(10) should occur.\n         5. Restart should PASS.\n         6. Cleanup should PASS.\n    \"\"\"\n\n    log.info('Running test_basic_referrals...')\n    SUFFIX_CONFIG = 'cn=\"dc=example,dc=com\",cn=mapping tree,cn=config'\n    #\n    # Set the referral, and the backend state\n    #\n    try:\n        topology_st.standalone.modify_s(SUFFIX_CONFIG,\n                                        [(ldap.MOD_REPLACE,\n                                          'nsslapd-referral',\n                                          b'ldap://localhost.localdomain:389/o%3dnetscaperoot')])\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_referrals: Failed to set referral: error ' + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.modify_s(SUFFIX_CONFIG, [(ldap.MOD_REPLACE,\n                                                         'nsslapd-state', b'Referral')])\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_referrals: Failed to set backend state: error '\n                  + e.args[0]['desc'])\n        assert False\n\n    #\n    # Test that a referral error is returned\n    #\n    topology_st.standalone.set_option(ldap.OPT_REFERRALS, 0)  # Do not follow referral\n    try:\n        topology_st.standalone.search_s(DEFAULT_SUFFIX, ldap.SCOPE_SUBTREE, 'objectclass=top')\n    except ldap.REFERRAL:\n        pass\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_referrals: Search failed: ' + e.args[0]['desc'])\n        assert False\n\n    #\n    # Make sure server can restart in referral mode\n    #\n    topology_st.standalone.restart(timeout=10)\n\n    #\n    # Cleanup\n    #\n    try:\n        topology_st.standalone.modify_s(SUFFIX_CONFIG, [(ldap.MOD_REPLACE,\n                                                         'nsslapd-state', b'Backend')])\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_referrals: Failed to set backend state: error '\n                  + e.args[0]['desc'])\n        assert False\n\n    try:\n        topology_st.standalone.modify_s(SUFFIX_CONFIG, [(ldap.MOD_DELETE,\n                                                         'nsslapd-referral', None)])\n    except ldap.LDAPError as e:\n        log.fatal('test_basic_referrals: Failed to delete referral: error '\n                  + e.args[0]['desc'])\n        assert False\n    topology_st.standalone.set_option(ldap.OPT_REFERRALS, 1)\n\n    log.info('test_basic_referrals: PASSED')\n\n\ndef test_basic_systemctl(topology_st, import_example_ldif):\n    \"\"\"Tests systemctl/lib389 can stop and start the server.\n\n    :id: a92a7438-ecfa-4583-a89c-5fbfc0220b69\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Stop the server.\n         2. Start the server.\n         3. Stop the server, break the dse.ldif and dse.ldif.bak, so a start fails.\n         4. Verify that systemctl detects the failed start.\n         5. Fix the dse.ldif, and make sure the server starts up.\n         6. Verify systemctl correctly identifies the successful start.\n\n    :expectedresults:\n         1. Server should be stopped.\n         2. Server should start\n         3. Stop should work but start after breaking dse.ldif should fail.\n         4. Systemctl should be able to detect the failed start.\n         5. Server should start.\n         6. Systemctl should be able to detect the successful start.\n    \"\"\"\n\n    log.info('Running test_basic_systemctl...')\n\n    config_dir = topology_st.standalone.get_config_dir()\n\n    #\n    # Stop the server\n    #\n    log.info('Stopping the server...')\n    topology_st.standalone.stop()\n    log.info('Stopped the server.')\n\n    #\n    # Start the server\n    #\n    log.info('Starting the server...')\n    topology_st.standalone.start()\n    log.info('Started the server.')\n\n    #\n    # Stop the server, break the dse.ldif so a start fails,\n    # and verify that systemctl detects the failed start\n    #\n    log.info('Stopping the server...')\n    topology_st.standalone.stop()\n    log.info('Stopped the server before breaking the dse.ldif.')\n\n    shutil.copy(config_dir + '/dse.ldif', config_dir + '/dse.ldif.correct')\n    open(config_dir + '/dse.ldif', 'w').close()\n    # We need to kill the .bak file too, DS is just too smart!\n    open(config_dir + '/dse.ldif.bak', 'w').close()\n\n    log.info('Attempting to start the server with broken dse.ldif...')\n    try:\n        topology_st.standalone.start()\n    except Exception as e:\n        log.info('Server failed to start as expected: ' + str(e))\n    log.info('Check the status...')\n    assert (not topology_st.standalone.status())\n    log.info('Server failed to start as expected')\n    time.sleep(5)\n\n    #\n    # Fix the dse.ldif, and make sure the server starts up,\n    # and systemctl correctly identifies the successful start\n    #\n    shutil.copy(config_dir + '/dse.ldif.correct', config_dir + '/dse.ldif')\n    log.info('Starting the server with good dse.ldif...')\n    topology_st.standalone.start()\n    log.info('Check the status...')\n    assert (topology_st.standalone.status())\n    log.info('Server started after fixing dse.ldif.')\n\n    log.info('test_basic_systemctl: PASSED')\n\n\ndef test_basic_ldapagent(topology_st, import_example_ldif):\n    \"\"\"Tests that the ldap agent starts\n\n    :id: da1d1846-8fc4-4b8c-8e53-4c9c16eff1ba\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Start SNMP ldap agent using command.\n         2. Cleanup - Kill SNMP agent process.\n\n    :expectedresults:\n         1. SNMP agent should start.\n         2. SNMP agent process should be successfully killed.\n    \"\"\"\n\n    log.info('Running test_basic_ldapagent...')\n\n    var_dir = topology_st.standalone.get_local_state_dir()\n\n    config_file = os.path.join(topology_st.standalone.get_sysconf_dir(), 'dirsrv/config/agent.conf')\n\n    agent_config_file = open(config_file, 'w')\n    agent_config_file.write('agentx-master ' + var_dir + '/agentx/master\\n')\n    agent_config_file.write('agent-logdir ' + var_dir + '/log/dirsrv\\n')\n    agent_config_file.write('server slapd-' + topology_st.standalone.serverid + '\\n')\n    agent_config_file.close()\n\n    # Remember, this is *forking*\n    check_output([os.path.join(topology_st.standalone.get_sbin_dir(), 'ldap-agent'), config_file])\n    # First kill any previous agents ....\n    pidpath = os.path.join(var_dir, 'run/ldap-agent.pid')\n    pid = None\n    with open(pidpath, 'r') as pf:\n        pid = pf.readlines()[0].strip()\n    if pid:\n        log.debug('test_basic_ldapagent: Terminating agent %s', pid)\n        check_output(['kill', pid])\n\n    log.info('test_basic_ldapagent: PASSED')\n\n\n@pytest.mark.skipif(not get_user_is_ds_owner(),\n                    reason=\"process ownership permission is required\")\ndef test_basic_dse_survives_kill9(topology_st, import_example_ldif):\n    \"\"\"Tests that the dse.ldif is not wiped out after the process is killed (bug 910581)\n\n    :id: 10f141da-9b22-443a-885c-87271dcd7a59\n\n    :setup: Standalone instance\n\n    :steps:\n         1. Check out pid of ns-slapd process and Kill ns-slapd process.\n         2. Check the contents of dse.ldif file.\n         3. Start server.\n\n    :expectedresults:\n         1. ns-slapd process should be killed.\n         2. dse.ldif should not be corrupted.\n         3. Server should start successfully.\n    \"\"\"\n    log.info('Running test_basic_dse...')\n\n    dse_file = topology_st.standalone.confdir + '/dse.ldif'\n    pid = check_output(['pidof', '-s', 'ns-slapd']).strip()\n    # We can't guarantee we have access to sudo in any environment ... Either\n    # run py.test with sudo, or as the same user as the dirsrv.\n    check_output(['kill', '-9', ensure_str(pid)])\n    if os.path.getsize(dse_file) == 0:\n        log.fatal('test_basic_dse: dse.ldif\\'s content was incorrectly removed!')\n        assert False\n\n    topology_st.standalone.start(timeout=60)\n    log.info('dse.ldif was not corrupted, and the server was restarted')\n\n    log.info('test_basic_dse: PASSED')\n    # Give the server time to startup, in some conditions this can be racey without systemd notification. Only affects this one test though...\n    time.sleep(10)\n\n\n@pytest.mark.parametrize(\"rootdse_attr_name\", ROOTDSE_DEF_ATTR_LIST)\ndef test_def_rootdse_attr(topology_st, import_example_ldif, rootdse_attr_name):\n    \"\"\"Tests that operational attributes are not returned by default in rootDSE searches\n\n    :id: 4fee33cc-4019-4c27-89e8-998e6c770dc0\n    :parametrized: yes\n    :setup: Standalone instance\n\n    :steps:\n         1. Make an ldapsearch for rootdse attribute\n         2. Check the returned entries.\n\n    :expectedresults:\n         1. Search should not fail\n         2. Operational attributes should not be returned.\n    \"\"\"\n\n    topology_st.standalone.start()\n\n    log.info(\" Assert rootdse search hasn't %s attr\" % rootdse_attr_name)\n    try:\n        entry = topology_st.standalone.search_s(\"\", ldap.SCOPE_BASE)[0]\n        assert not entry.hasAttr(rootdse_attr_name)\n\n    except ldap.LDAPError as e:\n        log.fatal('Search failed, error: ' + e.args[0]['desc'])\n        assert False\n\n\ndef test_mod_def_rootdse_attr(topology_st, import_example_ldif, rootdse_attr):\n    \"\"\"Tests that operational attributes are returned by default in rootDSE searches after config modification\n\n   :id: c7831e04-f458-4e23-83c7-b6f66109f639\n   :parametrized: yes\n   :setup: Standalone instance and we are using rootdse_attr fixture which\n           adds nsslapd-return-default-opattr attr with value of one operation attribute.\n\n   :steps:\n         1. Make an ldapsearch for rootdse attribute\n         2. Check the returned entries.\n\n   :expectedresults:\n         1. Search should not fail\n         2. Operational attributes should be returned after the config modification\n   \"\"\"\n\n    log.info(\" Assert rootdse search has %s attr\" % rootdse_attr)\n    try:\n        entry = topology_st.standalone.search_s(\"\", ldap.SCOPE_BASE)[0]\n        assert entry.hasAttr(rootdse_attr)\n\n    except ldap.LDAPError as e:\n        log.fatal('Search failed, error: ' + e.args[0]['desc'])\n        assert False\n\n\n@pytest.fixture(scope=\"module\")\ndef create_users(topology_st):\n    \"\"\"Add users to the default suffix\n    \"\"\"\n\n    users = UserAccounts(topology_st.standalone, DEFAULT_SUFFIX)\n    user_names = [\"Directory\", \"Server\", \"389\", \"lib389\", \"pytest\"]\n\n    log.info('Adding 5 test users')\n    for name in user_names:\n        users.create(properties={\n            'uid': name,\n            'sn': name,\n            'cn': name,\n            'uidNumber': '1000',\n            'gidNumber': '1000',\n            'homeDirectory': '/home/%s' % name,\n            'mail': '%s@example.com' % name,\n            'userpassword': 'pass%s' % name,\n        })\n\n\ndef test_basic_anonymous_search(topology_st, create_users):\n    \"\"\"Tests basic anonymous search operations\n\n    :id: c7831e04-f458-4e50-83c7-b6f77109f639\n    :setup: Standalone instance\n            Add 5 test users with different user names\n    :steps:\n         1. Execute anonymous search with different filters\n    :expectedresults:\n         1. Search should be successful\n    \"\"\"\n\n    filters = [\"uid=Directory\", \"(|(uid=S*)(uid=3*))\", \"(&(uid=l*)(mail=l*))\", \"(&(!(uid=D*))(ou=People))\"]\n    log.info(\"Execute anonymous search with different filters\")\n    for filtr in filters:\n        entries = topology_st.standalone.search_s(DEFAULT_SUFFIX, ldap.SCOPE_SUBTREE, filtr)\n        assert len(entries) != 0\n\n\n@pytest.mark.ds604\n@pytest.mark.bz915801\ndef test_search_original_type(topology_st, create_users):\n    \"\"\"Test ldapsearch returning original attributes\n       using nsslapd-search-return-original-type-switch\n\n    :id: d7831d04-f558-4e50-93c7-b6f77109f640\n    :setup: Standalone instance\n            Add some test entries\n    :steps:\n         1. Set nsslapd-search-return-original-type-switch to ON\n         2. Check that ldapsearch *does* return unknown attributes\n         3. Turn off nsslapd-search-return-original-type-switch\n         4. Check that ldapsearch doesn't return any unknown attributes\n    :expectedresults:\n         1. nsslapd-search-return-original-type-switch should be set to ON\n         2. ldapsearch should return unknown attributes\n         3. nsslapd-search-return-original-type-switch should be OFF\n         4. ldapsearch should not return any unknown attributes\n    \"\"\"\n\n    log.info(\"Set nsslapd-search-return-original-type-switch to ON\")\n    topology_st.standalone.config.set('nsslapd-search-return-original-type-switch', 'on')\n\n    log.info(\"Check that ldapsearch *does* return unknown attributes\")\n    entries = topology_st.standalone.search_s(DEFAULT_SUFFIX, ldap.SCOPE_SUBTREE, 'uid=Directory',\n                                              ['objectclass overflow', 'unknown'])\n    assert \"objectclass overflow\" in entries[0].getAttrs()\n\n    log.info(\"Set nsslapd-search-return-original-type-switch to Off\")\n    topology_st.standalone.config.set('nsslapd-search-return-original-type-switch', 'off')\n    log.info(\"Check that ldapsearch *does not* return unknown attributes\")\n    entries = topology_st.standalone.search_s(DEFAULT_SUFFIX, ldap.SCOPE_SUBTREE, 'uid=Directory',\n                                              ['objectclass overflow', 'unknown'])\n    assert \"objectclass overflow\" not in entries[0].getAttrs()\n\n\n@pytest.mark.bz192901\ndef test_search_ou(topology_st):\n    \"\"\"Test that DS should not return an entry that does not match the filter\n\n    :id: d7831d05-f117-4e89-93c7-b6f77109f640\n    :setup: Standalone instance\n    :steps:\n         1. Create an OU entry without sub entries\n         2. Search from the OU with the filter that does not match the OU\n    :expectedresults:\n         1. Creation of OU should be successful\n         2. Search should not return any results\n    \"\"\"\n\n    log.info(\"Create a test OU without sub entries\")\n    ou = OrganizationalUnits(topology_st.standalone, DEFAULT_SUFFIX)\n    ou.create(properties={\n        'ou': 'test_ou',\n    })\n\n    search_base = (\"ou=test_ou,%s\" % DEFAULT_SUFFIX)\n    log.info(\"Search from the OU with the filter that does not match the OU, it should not return anything\")\n    entries = topology_st.standalone.search_s(search_base, ldap.SCOPE_SUBTREE, 'uid=*', ['dn'])\n    assert len(entries) == 0\n\n\ndef test_bind_invalid_entry(topology_st):\n    \"\"\"Test the failing bind does not return information about the entry\n\n    :id: 5cd9b083-eea6-426b-84ca-83c26fc49a6f\n    :customerscenario: True\n    :setup: Standalone instance\n    :steps:\n        1: bind as non existing entry\n        2: check that bind info does not report 'No such entry'\n    :expectedresults:\n        1: pass\n        2: pass\n    \"\"\"\n\n    topology_st.standalone.restart()\n    INVALID_ENTRY=\"cn=foooo,%s\" % DEFAULT_SUFFIX\n    try:\n        topology_st.standalone.simple_bind_s(INVALID_ENTRY, PASSWORD)\n    except ldap.LDAPError as e:\n        log.info('test_bind_invalid_entry: Failed to bind as %s (expected)' % INVALID_ENTRY)\n        log.info('exception description: ' + e.args[0]['desc'])\n        if 'info' in e.args[0]:\n            log.info('exception info: ' + e.args[0]['info'])\n        assert e.args[0]['desc'] == 'Invalid credentials'\n        assert 'info' not in e.args[0]\n        pass\n\n    log.info('test_bind_invalid_entry: PASSED')\n\n    # reset credentials\n    topology_st.standalone.simple_bind_s(DN_DM, PW_DM)\n\n\ndef test_bind_entry_missing_passwd(topology_st):\n    \"\"\"\n    :id: af209149-8fb8-48cb-93ea-3e82dd7119d2\n    :setup: Standalone Instance\n    :steps:\n        1. Bind as database entry that does not have userpassword set\n        2. Bind as database entry that does not exist\n        1. Bind as cn=config entry that does not have userpassword set\n        2. Bind as cn=config entry that does not exist\n    :expectedresults:\n        1. Fails with error 49\n        2. Fails with error 49\n        3. Fails with error 49\n        4. Fails with error 49\n    \"\"\"\n    user = UserAccount(topology_st.standalone, DEFAULT_SUFFIX)\n    with pytest.raises(ldap.INVALID_CREDENTIALS):\n        # Bind as the suffix root entry which does not have a userpassword\n        user.bind(\"some_password\")\n\n    user = UserAccount(topology_st.standalone, \"cn=not here,\" + DEFAULT_SUFFIX)\n    with pytest.raises(ldap.INVALID_CREDENTIALS):\n        # Bind as the entry which does not exist\n        user.bind(\"some_password\")\n\n    # Test cn=config since it has its own code path\n    user = UserAccount(topology_st.standalone, \"cn=config\")\n    with pytest.raises(ldap.INVALID_CREDENTIALS):\n        # Bind as the config entry which does not have a userpassword\n        user.bind(\"some_password\")\n\n    user = UserAccount(topology_st.standalone, \"cn=does not exist,cn=config\")\n    with pytest.raises(ldap.INVALID_CREDENTIALS):\n        # Bind as an entry under cn=config that does not exist\n        user.bind(\"some_password\")\n\n\n@pytest.mark.bz1044135\n@pytest.mark.ds47319\ndef test_connection_buffer_size(topology_st):\n    \"\"\"Test connection buffer size adjustable with different values(valid values and invalid)\n\n    :id: e7831d05-f117-4ec9-1203-b6f77109f117\n    :setup: Standalone instance\n    :steps:\n         1. Set nsslapd-connection-buffer to some valid values (2, 0 , 1)\n         2. Set nsslapd-connection-buffer to some invalid values (-1, a)\n    :expectedresults:\n         1. This should pass\n         2. This should fail\n    \"\"\"\n\n    valid_values = ['2', '0', '1']\n    for value in valid_values:\n        topology_st.standalone.config.replace('nsslapd-connection-buffer', value)\n\n    invalid_values = ['-1', 'a']\n    for value in invalid_values:\n        with pytest.raises(ldap.OPERATIONS_ERROR):\n            topology_st.standalone.config.replace('nsslapd-connection-buffer', value)\n\n\n@pytest.mark.bz1637439\ndef test_critical_msg_on_empty_range_idl(topology_st):\n    \"\"\"Doing a range index lookup should not report a critical message even if IDL is empty\n\n    :id: a07a2222-0551-44a6-b113-401d23799364\n    :setup: Standalone instance\n    :steps:\n         1. Create an index for internationalISDNNumber. (attribute chosen because it is\n            unlikely that previous tests used it)\n         2. telephoneNumber being indexed by default create 20 users without telephoneNumber\n         3. add a telephoneNumber value and delete it to trigger an empty index database\n         4. Do a search that triggers a range lookup on empty telephoneNumber\n         5. Check that the critical message is not logged in error logs\n    :expectedresults:\n         1. This should pass\n         2. This should pass\n         3. This should pass\n         4. This should pass on normal build but could abort a debug build\n         5. This should pass\n    \"\"\"\n    indexedAttr = 'internationalISDNNumber'\n\n    # Step 1\n    from lib389.index import Indexes\n\n    indexes = Indexes(topology_st.standalone)\n    indexes.create(properties={\n        'cn': indexedAttr,\n        'nsSystemIndex': 'false',\n        'nsIndexType': 'eq'\n        })\n    topology_st.standalone.restart()\n\n    # Step 2\n    users = UserAccounts(topology_st.standalone, DEFAULT_SUFFIX)\n    log.info('Adding 20 users without \"%s\"' % indexedAttr)\n    for i in range(20):\n        name = 'user_%d' % i\n        last_user = users.create(properties={\n            'uid': name,\n            'sn': name,\n            'cn': name,\n            'uidNumber': '1000',\n            'gidNumber': '1000',\n            'homeDirectory': '/home/%s' % name,\n            'mail': '%s@example.com' % name,\n            'userpassword': 'pass%s' % name,\n        })\n\n    # Step 3\n    # required update to create the indexAttr (i.e. 'loginShell') database, and then make it empty\n    topology_st.standalone.modify_s(last_user.dn, [(ldap.MOD_ADD, indexedAttr, b'1234')])\n    ent = topology_st.standalone.getEntry(last_user.dn, ldap.SCOPE_BASE,)\n    assert ent\n    assert ent.hasAttr(indexedAttr)\n    topology_st.standalone.modify_s(last_user.dn, [(ldap.MOD_DELETE, indexedAttr, None)])\n    ent = topology_st.standalone.getEntry(last_user.dn, ldap.SCOPE_BASE,)\n    assert ent\n    assert not ent.hasAttr(indexedAttr)\n\n    # Step 4\n    # The first component being not indexed the range on second is evaluated\n    try:\n        ents = topology_st.standalone.search_s(DEFAULT_SUFFIX, ldap.SCOPE_SUBTREE, '(&(sudoNotAfter=*)(%s>=111))' % indexedAttr)\n        assert len(ents) == 0\n    except ldap.SERVER_DOWN:\n        log.error('Likely testing against a debug version that asserted')\n        pass\n\n    # Step 5\n    assert not topology_st.standalone.searchErrorsLog('CRIT - list_candidates - NULL idl was recieved from filter_candidates_ext.')\n\n\n@pytest.mark.bz1647099\n@pytest.mark.ds50026\ndef test_ldbm_modification_audit_log(topology_st):\n    \"\"\"When updating LDBM config attributes, those attributes/values are not listed\n    in the audit log\n\n    :id: 5bf75c47-a283-430e-a65c-3c5fd8dbadb8\n    :setup: Standalone Instance\n    :steps:\n        1. Bind as DM\n        2. Enable audit log\n        3. Update a set of config attrs in LDBM config\n        4. Restart the server\n        5. Check that config attrs are listed in the audit log\n    :expectedresults:\n        1. Operation successful\n        2. Operation successful\n        3. Operation successful\n        4. Operation successful\n        5. Audit log should contain modification of attrs\"\n    \"\"\"\n\n    VALUE = '10001'\n\n    d_manager = DirectoryManager(topology_st.standalone)\n    conn = d_manager.bind()\n    config_ldbm = LDBMConfig(conn)\n\n    log.info(\"Enable audit logging\")\n    conn.config.enable_log('audit')\n\n    attrs = ['nsslapd-lookthroughlimit', 'nsslapd-pagedidlistscanlimit', 'nsslapd-idlistscanlimit', 'nsslapd-db-locks']\n\n    for attr in attrs:\n        log.info(\"Set attribute %s to value %s\" % (attr, VALUE))\n        config_ldbm.set(attr, VALUE)\n\n    log.info('Restart the server to flush the logs')\n    conn.restart()\n\n    for attr in attrs:\n        log.info(\"Check if attribute %s is replaced in the audit log\" % attr)\n        assert conn.searchAuditLog('replace: %s' % attr)\n        assert conn.searchAuditLog('%s: %s' % (attr, VALUE))\n\n\n@pytest.mark.skipif(not get_user_is_root() or ds_is_older('1.4.0.0'),\n                    reason=\"This test is only required if perl is enabled, and requires root.\")\ndef test_dscreate(request):\n    \"\"\"Test that dscreate works, we need this for now until setup-ds.pl is\n    fully discontinued.\n\n    :id: 5bf75c47-a283-430e-a65c-3c5fd8dbadb9\n    :setup: None\n    :steps:\n        1. Create template file for dscreate\n        2. Create instance using template file\n    :expectedresults:\n        1. Should succeeds\n        2. Should succeeds\n    \"\"\"\n\n    template_file = \"/tmp/dssetup.inf\"\n    template_text = \"\"\"[general]\nconfig_version = 2\n# This invalid hostname ...\nfull_machine_name = localhost.localdomain\n# Means we absolutely require this.\nstrict_host_checking = False\n# In tests, we can be run in containers, NEVER trust\n# that systemd is there, or functional in any capacity\nsystemd = False\n\n[slapd]\ninstance_name = test_dscreate\nroot_dn = cn=directory manager\nroot_password = someLongPassword_123\n# We do not have access to high ports in containers,\n# so default to something higher.\nport = 38999\nsecure_port = 63699\n\n\n[backend-userroot]\nsuffix = dc=example,dc=com\nsample_entries = yes\n\"\"\"\n\n    with open(template_file, \"w\") as template_fd:\n        template_fd.write(template_text)\n\n    # Unset PYTHONPATH to avoid mixing old CLI tools and new lib389\n    tmp_env = os.environ\n    if \"PYTHONPATH\" in tmp_env:\n        del tmp_env[\"PYTHONPATH\"]\n    try:\n        subprocess.check_call([\n            'dscreate',\n            'from-file',\n            template_file\n        ], env=tmp_env)\n    except subprocess.CalledProcessError as e:\n        log.fatal(\"dscreate failed!  Error ({}) {}\".format(e.returncode, e.output))\n        assert False\n\n    def fin():\n        os.remove(template_file)\n        try:\n            subprocess.check_call(['dsctl', 'test_dscreate', 'remove', '--do-it'])\n        except subprocess.CalledProcessError as e:\n            log.fatal(\"Failed to remove test instance  Error ({}) {}\".format(e.returncode, e.output))\n\n    request.addfinalizer(fin)\n\n\n@pytest.fixture(scope=\"function\")\ndef dscreate_long_instance(request):\n    template_file = \"/tmp/dssetup.inf\"\n    longname_serverid = \"test-longname-deadbeef-deadbeef-deadbeef-deadbeef-deadbeef\"\n    template_text = \"\"\"[general]\nconfig_version = 2\n# This invalid hostname ...\nfull_machine_name = localhost.localdomain\n# Means we absolutely require this.\nstrict_host_checking = False\n# In tests, we can be run in containers, NEVER trust\n# that systemd is there, or functional in any capacity\nsystemd = False\n\n[slapd]\ninstance_name = %s\nroot_dn = cn=directory manager\nroot_password = someLongPassword_123\n# We do not have access to high ports in containers,\n# so default to something higher.\nport = 38999\nsecure_port = 63699\n\n\n[backend-userroot]\nsuffix = dc=example,dc=com\nsample_entries = yes\n\"\"\" % longname_serverid\n\n    with open(template_file, \"w\") as template_fd:\n        template_fd.write(template_text)\n\n    # Unset PYTHONPATH to avoid mixing old CLI tools and new lib389\n    tmp_env = os.environ\n    if \"PYTHONPATH\" in tmp_env:\n        del tmp_env[\"PYTHONPATH\"]\n    try:\n        subprocess.check_call([\n            'dscreate',\n            'from-file',\n            template_file\n        ], env=tmp_env)\n    except subprocess.CalledProcessError as e:\n        log.fatal(\"dscreate failed!  Error ({}) {}\".format(e.returncode, e.output))\n        assert False\n\n    inst = DirSrv(verbose=True, external_log=log)\n    dse_ldif = DSEldif(inst,\n                       serverid=longname_serverid)\n\n    socket_path = dse_ldif.get(\"cn=config\", \"nsslapd-ldapifilepath\")\n    inst.local_simple_allocate(\n       serverid=longname_serverid,\n       ldapuri=f\"ldapi://{socket_path[0].replace('/', '%2f')}\",\n       password=\"someLongPassword_123\"\n    )\n    inst.ldapi_enabled = 'on'\n    inst.ldapi_socket = socket_path\n    inst.ldapi_autobind = 'off'\n    try:\n        inst.open()\n    except:\n        log.fatal(\"Failed to connect via ldapi to %s instance\" % longname_serverid)\n        os.remove(template_file)\n        try:\n            subprocess.check_call(['dsctl', longname_serverid, 'remove', '--do-it'])\n        except subprocess.CalledProcessError as e:\n            log.fatal(\"Failed to remove test instance  Error ({}) {}\".format(e.returncode, e.output))\n\n    def fin():\n        os.remove(template_file)\n        try:\n            subprocess.check_call(['dsctl', longname_serverid, 'remove', '--do-it'])\n        except subprocess.CalledProcessError as e:\n            log.fatal(\"Failed to remove test instance  Error ({}) {}\".format(e.returncode, e.output))\n\n    request.addfinalizer(fin)\n\n    return inst\n\n\n@pytest.mark.skipif(not get_user_is_root() or ds_is_older('1.4.2.0'),\n                    reason=\"This test is only required with new admin cli, and requires root.\")\n@pytest.mark.bz1748016\n@pytest.mark.ds50581\ndef test_dscreate_ldapi(dscreate_long_instance):\n    \"\"\"Test that an instance with a long name can\n    handle ldapi connection using a long socket name\n\n    :id: 5d72d955-aff8-4741-8c9a-32c1c707cf1f\n    :setup: None\n    :steps:\n        1. Ccreate an instance with a long serverId name, that open a ldapi connection\n        2. Connect with ldapi, that hit 50581 and crash the instance\n    :expectedresults:\n        1. Should succeeds\n        2. Should succeeds\n    \"\"\"\n\n    root_dse = RootDSE(dscreate_long_instance)\n    log.info(root_dse.get_supported_ctrls())\n\n\n@pytest.mark.skipif(not get_user_is_root() or ds_is_older('1.4.2.0'),\n                    reason=\"This test is only required with new admin cli, and requires root.\")\n@pytest.mark.bz1715406\n@pytest.mark.ds50923\ndef test_dscreate_multiple_dashes_name(dscreate_long_instance):\n    \"\"\"Test that an instance with a multiple dashes in the name\n    can be removed with dsctl --remove-all\n\n    :id: 265c3ac7-5ba6-4278-b8f4-4e7692afd1a5\n    :setup: An instance with a few dashes in its name\n    :steps:\n        1. Run 'dsctl --remove-all' command\n        2. Check if the instance exists\n    :expectedresults:\n        1. Should succeeds\n        2. Instance doesn't exists\n    \"\"\"\n\n    p = run(['dsctl', '--remove-all'], stdout=PIPE, input='Yes\\n', encoding='ascii')\n    assert not dscreate_long_instance.exists()\n\n\n@pytest.fixture(scope=\"module\", params=('c=uk', 'cn=test_user', 'dc=example,dc=com', 'o=south', 'ou=sales', 'wrong=some_value'))\ndef dscreate_test_rdn_value(request):\n    template_file = \"/tmp/dssetup.inf\"\n    template_text = f\"\"\"[general]\nconfig_version = 2\n# This invalid hostname ...\nfull_machine_name = localhost.localdomain\n# Means we absolutely require this.\nstrict_host_checking = False\n# In tests, we can be run in containers, NEVER trust\n# that systemd is there, or functional in any capacity\nsystemd = False\n\n[slapd]\ninstance_name = test_different_rdn\nroot_dn = cn=directory manager\nroot_password = someLongPassword_123\n# We do not have access to high ports in containers,\n# so default to something higher.\nport = 38999\nsecure_port = 63699\n\n[backend-userroot]\ncreate_suffix_entry = True\nsuffix = {request.param}\n\"\"\"\n\n    with open(template_file, \"w\") as template_fd:\n        template_fd.write(template_text)\n\n    # Unset PYTHONPATH to avoid mixing old CLI tools and new lib389\n    tmp_env = os.environ\n    if \"PYTHONPATH\" in tmp_env:\n        del tmp_env[\"PYTHONPATH\"]\n\n    def fin():\n        os.remove(template_file)\n        if request.param != \"wrong=some_value\":\n            try:\n                subprocess.check_call(['dsctl', 'test_different_rdn', 'remove', '--do-it'])\n            except subprocess.CalledProcessError as e:\n                log.fatal(f\"Failed to remove test instance  Error ({e.returncode}) {e.output}\")\n        else:\n            log.info(\"Wrong RDN is passed, instance not created\")\n    request.addfinalizer(fin)\n    return template_file, tmp_env, request.param,\n\n\n@pytest.mark.skipif(not get_user_is_root() or ds_is_older('1.4.0.0'),\n                    reason=\"This test is only required with new admin cli, and requires root.\")\n@pytest.mark.bz1807419\n@pytest.mark.ds50928\ndef test_dscreate_with_different_rdn(dscreate_test_rdn_value):\n    \"\"\"Test that dscreate works with different RDN attributes as suffix\n\n    :id: 77ed6300-6a2f-4e79-a862-1f1105f1e3ef\n    :customerscenario: True\n    :parametrized: yes\n    :setup: None\n    :steps:\n        1. Create template file for dscreate with different RDN attributes as suffix\n        2. Create instance using template file\n        3. Create instance with 'wrong=some_value' as suffix's RDN attribute\n    :expectedresults:\n        1. Should succeeds\n        2. Should succeeds\n        3. Should fail\n    \"\"\"\n    try:\n        subprocess.check_call([\n            'dscreate',\n            'from-file',\n            dscreate_test_rdn_value[0]\n        ], env=dscreate_test_rdn_value[1])\n    except subprocess.CalledProcessError as e:\n        log.fatal(f\"dscreate failed!  Error ({e.returncode}) {e.output}\")\n        if  dscreate_test_rdn_value[2] != \"wrong=some_value\":\n            assert False\n        else:\n            assert True\n\n\nif __name__ == '__main__':\n    # Run isolated\n    # -s for DEBUG mode\n    CURRENT_FILE = os.path.realpath(__file__)\n    pytest.main(\"-s %s\" % CURRENT_FILE)\n", "/** BEGIN COPYRIGHT BLOCK\n * Copyright (C) 2001 Sun Microsystems, Inc. Used by permission.\n * Copyright (C) 2005 Red Hat, Inc.\n * All rights reserved.\n *\n * License: GPL (version 3 or any later version).\n * See LICENSE for details.\n * END COPYRIGHT BLOCK **/\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n/* bind.c  - ldbm backend bind and unbind routines */\n\n#include \"back-ldbm.h\"\n\nint\nldbm_back_bind(Slapi_PBlock *pb)\n{\n    backend *be;\n    ldbm_instance *inst;\n    ber_tag_t method;\n    struct berval *cred;\n    struct ldbminfo *li;\n    struct backentry *e;\n    Slapi_Attr *attr;\n    Slapi_Value **bvals;\n    entry_address *addr;\n    back_txn txn = {NULL};\n    int rc = SLAPI_BIND_SUCCESS;\n    int result_sent = 0;\n\n    /* get parameters */\n    slapi_pblock_get(pb, SLAPI_BACKEND, &be);\n    slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &li);\n    slapi_pblock_get(pb, SLAPI_TARGET_ADDRESS, &addr);\n    slapi_pblock_get(pb, SLAPI_BIND_METHOD, &method);\n    slapi_pblock_get(pb, SLAPI_BIND_CREDENTIALS, &cred);\n    slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn);\n\n    if (!txn.back_txn_txn) {\n        dblayer_txn_init(li, &txn);\n        slapi_pblock_set(pb, SLAPI_TXN, txn.back_txn_txn);\n    }\n\n    inst = (ldbm_instance *)be->be_instance_info;\n    if (inst->inst_ref_count) {\n        slapi_counter_increment(inst->inst_ref_count);\n    } else {\n        slapi_log_err(SLAPI_LOG_ERR, \"ldbm_back_bind\",\n                      \"instance %s does not exist.\\n\", inst->inst_name);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    /* always allow noauth simple binds (front end will send the result) */\n    if (method == LDAP_AUTH_SIMPLE && cred->bv_len == 0) {\n        rc = SLAPI_BIND_ANONYMOUS;\n        goto bail;\n    }\n\n    /*\n     * find the target entry.  find_entry() takes care of referrals\n     *   and sending errors if the entry does not exist.\n     */\n    if ((e = find_entry(pb, be, addr, &txn, &result_sent)) == NULL) {\n        rc = SLAPI_BIND_FAIL;\n        /* In the failure case, the result is supposed to be sent in the backend. */\n        if (!result_sent) {\n            slapi_send_ldap_result(pb, LDAP_INAPPROPRIATE_AUTH, NULL, NULL, 0, NULL);\n        }\n        goto bail;\n    }\n\n    switch (method) {\n    case LDAP_AUTH_SIMPLE: {\n        Slapi_Value cv;\n        if (slapi_entry_attr_find(e->ep_entry, \"userpassword\", &attr) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Entry does not have userpassword set\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            CACHE_RETURN(&inst->inst_cache, &e);\n            rc = SLAPI_BIND_FAIL;\n            goto bail;\n        }\n        bvals = attr_get_present_values(attr);\n        slapi_value_init_berval(&cv, cred);\n        if (slapi_pw_find_sv(bvals, &cv) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Invalid credentials\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            CACHE_RETURN(&inst->inst_cache, &e);\n            value_done(&cv);\n            rc = SLAPI_BIND_FAIL;\n            goto bail;\n        }\n        value_done(&cv);\n    } break;\n\n    default:\n        slapi_send_ldap_result(pb, LDAP_STRONG_AUTH_NOT_SUPPORTED, NULL,\n                               \"auth method not supported\", 0, NULL);\n        CACHE_RETURN(&inst->inst_cache, &e);\n        rc = SLAPI_BIND_FAIL;\n        goto bail;\n    }\n\n    CACHE_RETURN(&inst->inst_cache, &e);\nbail:\n    if (inst->inst_ref_count) {\n        slapi_counter_decrement(inst->inst_ref_count);\n    }\n    /* success:  front end will send result */\n    return rc;\n}\n", "/** BEGIN COPYRIGHT BLOCK\n * Copyright (C) 2001 Sun Microsystems, Inc. Used by permission.\n * Copyright (C) 2005 Red Hat, Inc.\n * All rights reserved.\n *\n * License: GPL (version 3 or any later version).\n * See LICENSE for details.\n * END COPYRIGHT BLOCK **/\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n/*\n * dse.c - DSE (DSA-Specific Entry) persistent storage.\n *\n * The DSE store is an LDIF file contained in the file dse.ldif.\n * The file is located in the directory specified with '-D'\n * when staring the server.\n *\n * In core, the DSEs are stored in an AVL tree, keyed on\n * DN.  Whenever a modification is made to a DSE, the\n * in-core entry is updated, then dse_write_file() is\n * called to commit the changes to disk.\n *\n * This is designed for a small number of DSEs, say\n * a maximum of 10 or 20.  If large numbers of DSEs\n * need to be stored, this approach of writing out\n * the entire contents on every modification will\n * be insufficient.\n *\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <prio.h>\n#include <prcountr.h>\n#include \"slap.h\"\n#include <pwd.h>\n/* Needed to access read_config_dse */\n#include \"proto-slap.h\"\n\n#include <unistd.h> /* provides fsync/close */\n\n/* #define SLAPI_DSE_DEBUG */ /* define this to force trace log    */\n                              /* messages to always be logged        */\n\n#ifdef SLAPI_DSE_DEBUG\n#define SLAPI_DSE_TRACELEVEL SLAPI_LOG_INFO\n#else /* SLAPI_DSE_DEBUG */\n#define SLAPI_DSE_TRACELEVEL SLAPI_LOG_TRACE\n#endif /* SLAPI_DSE_DEBUG */\n\n#define SCHEMA_VIOLATION -2\n#define STOP_TRAVERSAL -2\n\n/* This is returned by dupentry_replace if the duplicate entry was found and\n   replaced.  This is returned up through the avl_insert() in\n   dse_replace_entry().  Otherwise, if avl_insert() returns 0, the\n   entry was added i.e. a duplicate was not found.\n*/\n#define DSE_ENTRY_WAS_REPLACED -3\n/* This is returned by dupentry_merge if the duplicate entry was found and\n   merged.  This is returned up through the avl_insert() in dse_add_entry_pb().\n   Otherwise, if avl_insert() returns 0, the\n   entry was added i.e. a duplicate was not found.\n*/\n#define DSE_ENTRY_WAS_MERGED -4\n\n/* some functions can be used either from within a lock or \"standalone\" */\n#define DSE_USE_LOCK 1\n#define DSE_NO_LOCK 0\n\nstruct dse_callback\n{\n    int operation;\n    int flags;\n    Slapi_DN *base;\n    int scope;\n    char *filter;              /* NULL means match all entries */\n    Slapi_Filter *slapifilter; /* NULL means match all entries */\n    int (*fn)(Slapi_PBlock *, Slapi_Entry *, Slapi_Entry *, int *, char *, void *);\n    void *fn_arg;\n    struct slapdplugin *plugin;\n    struct dse_callback *next;\n};\n\nstruct dse\n{\n    char *dse_filename;    /* these are the primary files which get read from */\n    char *dse_tmpfile;     /* and written to when changes are made via LDAP */\n    char *dse_fileback;    /* contain the latest info, just before a new change */\n    char *dse_filestartOK; /* contain the latest info with which the server has successfully started */\n    char *dse_configdir;   /* The location of config files - allows us to fsync the dir post rename */\n    Avlnode *dse_tree;\n    struct dse_callback *dse_callback;\n    Slapi_RWLock *dse_rwlock;        /* a read-write lock to protect the whole dse backend */\n    char **dse_filelist;             /* these are additional read only files used to */\n                                     /* initialize the dse */\n    int dse_is_updateable;           /* if non-zero, this DSE can be written to */\n    int dse_readonly_error_reported; /* used to ensure that read-only errors are logged only once */\n};\n\nstruct dse_node\n{\n    Slapi_Entry *entry;\n};\n\n/* search set stuff - used to pass search results to the frontend */\ntypedef struct dse_search_set\n{\n    DataList dl;\n    int current_entry;\n} dse_search_set;\n\nstatic int dse_permission_to_write(struct dse *pdse, int loglevel);\nstatic int dse_write_file_nolock(struct dse *pdse);\nstatic int dse_apply_nolock(struct dse *pdse, IFP fp, caddr_t arg);\nstatic int dse_replace_entry(struct dse *pdse, Slapi_Entry *e, int write_file, int use_lock);\nstatic dse_search_set *dse_search_set_new(void);\nstatic void dse_search_set_delete(dse_search_set *ss);\nstatic void dse_search_set_clean(dse_search_set *ss);\nstatic void dse_free_entry(void **data);\nstatic void dse_search_set_add_entry(dse_search_set *ss, Slapi_Entry *e);\nstatic Slapi_Entry *dse_search_set_get_next_entry(dse_search_set *ss);\nstatic int dse_add_entry_pb(struct dse *pdse, Slapi_Entry *e, Slapi_PBlock *pb);\nstatic struct dse_node *dse_find_node(struct dse *pdse, const Slapi_DN *dn);\nstatic int dse_modify_plugin(Slapi_Entry *pre_entry, Slapi_Entry *post_entry, char *returntext);\nstatic int dse_add_plugin(Slapi_Entry *entry, char *returntext);\nstatic int dse_delete_plugin(Slapi_Entry *entry, char *returntext);\nstatic int dse_pre_modify_plugin(Slapi_Entry *entryBefore, Slapi_Entry *entryAfter, LDAPMod **mods);\n\n/*\n  richm: In almost all modes e.g. db2ldif, ldif2db, etc. we do not need/want\n  to write out the dse.ldif and ldbm.ldif files.  The only mode which really\n  needs to write out the file is the regular server mode.  The variable\n  dont_ever_write_dse_files tells dse_write_file_nolock whether or not to write\n  the .ldif file for the entry.  The default is 1, which means never write the\n  file.  The server, when it starts up in regular mode, must call\n  dse_unset_dont_ever_write_dse_files() to enable this file to be written\n*/\nstatic int dont_ever_write_dse_files = 1;\n\n/* Forward declarations */\nstatic int entry_dn_cmp(caddr_t d1, caddr_t d2);\nstatic int dupentry_disallow(caddr_t d1, caddr_t d2);\nstatic int dupentry_merge(caddr_t d1, caddr_t d2);\nstatic int dse_write_entry(caddr_t data, caddr_t arg);\nstatic int ldif_record_end(char *p);\nstatic int dse_call_callback(struct dse *pdse, Slapi_PBlock *pb, int operation, int flags, Slapi_Entry *entryBefore, Slapi_Entry *entryAfter, int *returncode, char *returntext);\n\n/*\n * Map a DN onto a dse_node.\n * Returns NULL if not found.\n * You must have a read or write lock on the dse_rwlock while\n * using the returned node.\n */\nstatic struct dse_node *\ndse_find_node(struct dse *pdse, const Slapi_DN *dn)\n{\n    struct dse_node *n = NULL;\n    if (NULL != dn) {\n        struct dse_node searchNode;\n        Slapi_Entry *fe = slapi_entry_alloc();\n        slapi_entry_init(fe, NULL, NULL);\n        slapi_entry_set_sdn(fe, dn);\n        searchNode.entry = fe;\n\n        n = (struct dse_node *)avl_find(pdse->dse_tree, &searchNode, entry_dn_cmp);\n\n        slapi_entry_free(fe);\n    }\n    return n;\n}\n\nstatic int counters_created = 0;\nPR_DEFINE_COUNTER(dse_entries_exist);\n\n/*\n * Map a DN onto a real Entry.\n * Returns NULL if not found.\n */\nstatic Slapi_Entry *\ndse_get_entry_copy(struct dse *pdse, const Slapi_DN *dn, int use_lock)\n{\n    Slapi_Entry *e = NULL;\n    struct dse_node *n;\n\n    if (use_lock == DSE_USE_LOCK && pdse->dse_rwlock) {\n        slapi_rwlock_rdlock(pdse->dse_rwlock);\n    }\n\n    n = dse_find_node(pdse, dn);\n    if (n != NULL) {\n        e = slapi_entry_dup(n->entry);\n    }\n\n    if (use_lock == DSE_USE_LOCK && pdse->dse_rwlock) {\n        slapi_rwlock_unlock(pdse->dse_rwlock);\n    }\n\n    return e;\n}\n\nstatic struct dse_callback *\ndse_callback_new(int operation,\n                 int flags,\n                 const Slapi_DN *base,\n                 int scope,\n                 const char *filter,\n                 dseCallbackFn fn,\n                 void *fn_arg,\n                 struct slapdplugin *plugin)\n{\n    struct dse_callback *p = NULL;\n    p = (struct dse_callback *)slapi_ch_calloc(1, sizeof(struct dse_callback));\n    if (p != NULL) {\n        p->operation = operation;\n        p->flags = flags;\n        p->base = slapi_sdn_dup(base);\n        p->scope = scope;\n        if (NULL == filter) {\n            p->filter = NULL;\n            p->slapifilter = NULL;\n        } else {\n            p->filter = slapi_ch_strdup(filter);\n            p->slapifilter = slapi_str2filter(p->filter);\n            filter_normalize(p->slapifilter);\n        }\n        p->fn = fn;\n        p->fn_arg = fn_arg;\n        p->plugin = plugin;\n        p->next = NULL;\n    }\n    return p;\n}\n\nstatic void\ndse_callback_delete(struct dse_callback **pp)\n{\n    if (pp != NULL) {\n        slapi_sdn_free(&((*pp)->base));\n        slapi_ch_free((void **)&((*pp)->filter));\n        slapi_filter_free((*pp)->slapifilter, 1);\n        slapi_ch_free((void **)pp);\n    }\n}\n\nstatic void\ndse_callback_deletelist(struct dse_callback **pp)\n{\n    if (pp != NULL) {\n        struct dse_callback *p, *n;\n        for (p = *pp; p != NULL;) {\n            n = p->next;\n            dse_callback_delete(&p);\n            p = n;\n        }\n    }\n}\n\n/*\n  Makes a copy of the entry passed in, so it's const\n*/\nstatic struct dse_node *\ndse_node_new(const Slapi_Entry *entry)\n{\n    struct dse_node *p = NULL;\n    p = (struct dse_node *)slapi_ch_malloc(sizeof(struct dse_node));\n    if (p != NULL) {\n        p->entry = slapi_entry_dup(entry);\n    }\n    if (!counters_created) {\n        PR_CREATE_COUNTER(dse_entries_exist, \"DSE\", \"entries\", \"\");\n        counters_created = 1;\n    }\n    PR_INCREMENT_COUNTER(dse_entries_exist);\n    return p;\n}\n\nstatic void\ndse_node_delete(struct dse_node **pp)\n{\n    slapi_entry_free((*pp)->entry);\n    slapi_ch_free((void **)&(*pp));\n    PR_DECREMENT_COUNTER(dse_entries_exist);\n}\n\nstatic void\ndse_callback_addtolist(struct dse_callback **pplist, struct dse_callback *p)\n{\n    if (pplist != NULL) {\n        p->next = NULL;\n        if (*pplist == NULL) {\n            *pplist = p;\n        } else {\n            struct dse_callback *t = *pplist;\n            for (; t->next != NULL; t = t->next)\n                ;\n            t->next = p;\n        }\n    }\n}\n\nstatic void\ndse_callback_removefromlist(struct dse_callback **pplist, int operation, int flags, const Slapi_DN *base, int scope, const char *filter, dseCallbackFn fn)\n{\n    if (pplist != NULL) {\n        struct dse_callback *t = *pplist;\n        struct dse_callback *prev = NULL;\n        for (; t != NULL;) {\n            if ((t->operation & operation) && (t->flags & flags) &&\n                (t->fn == fn) && (scope == t->scope) &&\n                (slapi_sdn_compare(base, t->base) == 0) &&\n                ((NULL == filter && NULL == t->filter) || /* both are NULL OR */\n                 ((filter && t->filter) &&                /* both are not NULL AND match. */\n                  (strcasecmp(filter, t->filter) == 0)))) {\n                if (prev == NULL) {\n                    *pplist = t->next;\n                } else {\n                    prev->next = t->next;\n                }\n                dse_callback_delete(&t);\n                t = NULL;\n            } else {\n                prev = t;\n                t = t->next;\n            }\n        }\n    }\n}\n\n/*\n * Create a new dse structure.\n */\nstruct dse *\ndse_new(char *filename, char *tmpfilename, char *backfilename, char *startokfilename, const char *configdir)\n{\n    struct dse *pdse = NULL;\n    char *realconfigdir = NULL;\n\n    if (configdir != NULL) {\n        realconfigdir = slapi_ch_strdup(configdir);\n    } else {\n        realconfigdir = config_get_configdir();\n    }\n    if (realconfigdir != NULL) {\n        pdse = (struct dse *)slapi_ch_calloc(1, sizeof(struct dse));\n        if (pdse != NULL) {\n            pdse->dse_rwlock = slapi_new_rwlock();\n            /* Set the full path name for the config DSE entry */\n            if (!strstr(filename, realconfigdir)) {\n                pdse->dse_filename = slapi_ch_smprintf(\"%s/%s\", realconfigdir, filename);\n            } else {\n                pdse->dse_filename = slapi_ch_strdup(filename);\n            }\n\n            if (!strstr(tmpfilename, realconfigdir)) {\n                pdse->dse_tmpfile = slapi_ch_smprintf(\"%s/%s\", realconfigdir, tmpfilename);\n            } else {\n                pdse->dse_tmpfile = slapi_ch_strdup(tmpfilename);\n            }\n\n            pdse->dse_configdir = slapi_ch_strdup(realconfigdir);\n\n            if (backfilename != NULL) {\n                if (!strstr(backfilename, realconfigdir)) {\n                    pdse->dse_fileback = slapi_ch_smprintf(\"%s/%s\", realconfigdir, backfilename);\n                } else {\n                    pdse->dse_fileback = slapi_ch_strdup(backfilename);\n                }\n            } else {\n                pdse->dse_fileback = NULL;\n            }\n\n            if (startokfilename != NULL) {\n                if (!strstr(startokfilename, realconfigdir)) {\n                    pdse->dse_filestartOK = slapi_ch_smprintf(\"%s/%s\", realconfigdir, startokfilename);\n                } else {\n                    pdse->dse_filestartOK = slapi_ch_strdup(startokfilename);\n                }\n            } else {\n                pdse->dse_filestartOK = NULL;\n            }\n\n            pdse->dse_tree = NULL;\n            pdse->dse_callback = NULL;\n            pdse->dse_is_updateable = dse_permission_to_write(pdse,\n                                                              SLAPI_LOG_TRACE);\n        }\n        slapi_ch_free((void **)&realconfigdir);\n    }\n    return pdse;\n}\n\n/*\n * Create a new dse structure with a file list\n */\nstruct dse *\ndse_new_with_filelist(char *filename, char *tmpfilename, char *backfilename, char *startokfilename, const char *configdir, char **filelist)\n{\n    struct dse *newdse = dse_new(filename, tmpfilename, backfilename, startokfilename, configdir);\n    newdse->dse_filelist = filelist;\n    return newdse;\n}\n\nstatic int\ndse_internal_delete_entry(caddr_t data, caddr_t arg __attribute__((unused)))\n{\n    struct dse_node *n = (struct dse_node *)data;\n    dse_node_delete(&n);\n    return 0;\n}\n\n/*\n * Get rid of a dse structure.\n */\nint\ndse_destroy(struct dse *pdse)\n{\n    int nentries = 0;\n\n    if (NULL == pdse) {\n        return 0; /* no one checks this return value */\n    }\n    if (pdse->dse_rwlock)\n        slapi_rwlock_wrlock(pdse->dse_rwlock);\n    slapi_ch_free((void **)&(pdse->dse_filename));\n    slapi_ch_free((void **)&(pdse->dse_tmpfile));\n    slapi_ch_free((void **)&(pdse->dse_fileback));\n    slapi_ch_free((void **)&(pdse->dse_filestartOK));\n    slapi_ch_free((void **)&(pdse->dse_configdir));\n    dse_callback_deletelist(&pdse->dse_callback);\n    charray_free(pdse->dse_filelist);\n    nentries = avl_free(pdse->dse_tree, dse_internal_delete_entry);\n    if (pdse->dse_rwlock) {\n        slapi_rwlock_unlock(pdse->dse_rwlock);\n        slapi_destroy_rwlock(pdse->dse_rwlock);\n    }\n    slapi_ch_free((void **)&pdse);\n    slapi_log_err(SLAPI_DSE_TRACELEVEL, \"dse_destroy\", \"Removed [%d] entries from the dse tree.\\n\",\n                  nentries);\n\n    return 0; /* no one checks this return value */\n}\n\n/*\n * Get rid of a dse structure.\n */\nint\ndse_deletedse(Slapi_PBlock *pb)\n{\n    struct dse *pdse = NULL;\n\n    slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse);\n\n    if (pdse) {\n        dse_destroy(pdse);\n    }\n\n    /* data is freed, so make sure no one tries to use it */\n    slapi_pblock_set(pb, SLAPI_PLUGIN_PRIVATE, NULL);\n\n    return 0;\n}\n\nstatic char *subordinatecount = \"numsubordinates\";\n\n/*\n * Get the number of subordinates for this entry.\n */\nstatic size_t\ndse_numsubordinates(Slapi_Entry *entry)\n{\n    int ret = 0;\n    Slapi_Attr *read_attr = NULL;\n    size_t current_sub_count = 0;\n\n    /* Get the present value of the subcount attr, or 0 if not present */\n    ret = slapi_entry_attr_find(entry, subordinatecount, &read_attr);\n    if (0 == ret) {\n        /* decode the value */\n        Slapi_Value *sval;\n        slapi_attr_first_value(read_attr, &sval);\n        if (sval != NULL) {\n            const struct berval *bval = slapi_value_get_berval(sval);\n            if (NULL != bval)\n                current_sub_count = atol(bval->bv_val);\n        }\n    }\n    return current_sub_count;\n}\n\n/*\n * Update the numsubordinates count.\n * mod_op is either an Add or Delete.\n */\nstatic void\ndse_updateNumSubordinates(Slapi_Entry *entry, int op)\n{\n    int ret = 0;\n    int mod_op = 0;\n    Slapi_Attr *read_attr = NULL;\n    size_t current_sub_count = 0;\n    int already_present = 0;\n\n    /* For now, we're only interested in subordinatecount.\n       We first examine the present value for the attribute.\n       If it isn't present and we're adding, we assign value 1 to the attribute and add it.\n       If it is present, we increment or decrement depending upon whether we're adding or deleting.\n       If the value after decrementing is zero, we remove it.\n    */\n\n    /* Get the present value of the subcount attr, or 0 if not present */\n    ret = slapi_entry_attr_find(entry, subordinatecount, &read_attr);\n    if (0 == ret) {\n        /* decode the value */\n        Slapi_Value *sval;\n        slapi_attr_first_value(read_attr, &sval);\n        if (sval != NULL) {\n            const struct berval *bval = slapi_value_get_berval(sval);\n            if (bval != NULL) {\n                already_present = 1;\n                current_sub_count = atol(bval->bv_val);\n            }\n        }\n    }\n\n    /* are we adding ? */\n    if ((SLAPI_OPERATION_ADD == op) && !already_present) {\n        /* If so, and the parent entry does not already have a subcount attribute, we need to add it */\n        mod_op = LDAP_MOD_ADD;\n    } else {\n        if (SLAPI_OPERATION_DELETE == op) {\n            if (!already_present) {\n                /* This means that something is wrong---deleting a child but no subcount present on parent */\n                slapi_log_err(SLAPI_LOG_ERR, \"dse_updateNumSubordinates\",\n                              \"numsubordinates assertion failure\\n\");\n                return;\n            } else {\n                if (current_sub_count == 1) {\n                    mod_op = LDAP_MOD_DELETE;\n                } else {\n                    mod_op = LDAP_MOD_REPLACE;\n                }\n            }\n        } else {\n            mod_op = LDAP_MOD_REPLACE;\n        }\n    }\n\n    /* Now compute the new value */\n    if (SLAPI_OPERATION_ADD == op) {\n        current_sub_count++;\n    } else {\n        current_sub_count--;\n    }\n    {\n        char value_buffer[22] = {0}; /* enough digits for 2^64 children */\n        struct berval *vals[2];\n        struct berval val;\n        vals[0] = &val;\n        vals[1] = NULL;\n        sprintf(value_buffer, \"%lu\", (long unsigned int)current_sub_count);\n        val.bv_val = value_buffer;\n        val.bv_len = strlen(val.bv_val);\n        switch (mod_op) {\n        case LDAP_MOD_ADD:\n            attrlist_merge(&entry->e_attrs, subordinatecount, vals);\n            break;\n        case LDAP_MOD_REPLACE:\n            attrlist_replace(&entry->e_attrs, subordinatecount, vals);\n            break;\n        case LDAP_MOD_DELETE:\n            attrlist_delete(&entry->e_attrs, subordinatecount);\n            break;\n        }\n    }\n}\n\n/* the write lock should always be acquired before calling this function */\nstatic void\ndse_updateNumSubOfParent(struct dse *pdse, const Slapi_DN *child, int op)\n{\n    Slapi_DN parent;\n    slapi_sdn_init(&parent);\n    slapi_sdn_get_parent(child, &parent);\n    if (!slapi_sdn_isempty(&parent)) {\n        /* no lock because caller should already have the write lock */\n        Slapi_Entry *parententry = dse_get_entry_copy(pdse, &parent, DSE_NO_LOCK);\n        if (parententry != NULL) {\n            /* Decrement the numsubordinate count of the parent entry */\n            dse_updateNumSubordinates(parententry, op);\n            /* no lock because caller should always have the write lock */\n            dse_replace_entry(pdse, parententry, 0, DSE_NO_LOCK);\n            slapi_entry_free(parententry);\n        }\n    }\n    slapi_sdn_done(&parent);\n}\n\n/* check if a file is valid, or if a provided backup file can be used.\n * there is no way to determine if the file contents is usable, the only\n * checks that can be done is that the file exists and that it is not size 0\n */\nint\ndse_check_file(char *filename, char *backupname)\n{\n    int rc = 0; /* Fail */\n    PRFileInfo64 prfinfo;\n\n    if (PR_GetFileInfo64(filename, &prfinfo) == PR_SUCCESS) {\n        if (prfinfo.size > 0) {\n            /* File exists and has content. */\n            return 1;\n        } else {\n            slapi_log_err(SLAPI_LOG_INFO, \"dse_check_file\",\n                          \"The config %s has zero length. Attempting restore ... \\n\", filename);\n            rc = PR_Delete(filename);\n        }\n    } else {\n        slapi_log_err(SLAPI_LOG_INFO, \"dse_check_file\",\n                      \"The config %s can not be accessed. Attempting restore ... (reason: %d)\\n\", filename, rc);\n    }\n\n    if (backupname) {\n\n        if (PR_GetFileInfo64(backupname, &prfinfo) != PR_SUCCESS) {\n            slapi_log_err(SLAPI_LOG_INFO, \"dse_check_file\",\n                          \"The backup %s can not be accessed. Check it exists and permissions.\\n\", backupname);\n            return 0;\n        }\n\n        if (prfinfo.size <= 0) {\n            slapi_log_err(SLAPI_LOG_ERR, \"dse_check_file\",\n                      \"The backup file %s has zero length, refusing to restore it.\\n\", backupname);\n            return 0;\n        }\n\n        rc = PR_Rename(backupname, filename);\n        if (rc != PR_SUCCESS) {\n            slapi_log_err(SLAPI_LOG_INFO, \"dse_check_file\",\n                      \"The configuration file %s was NOT able to be restored from %s, error %d\\n\", filename, backupname, rc);\n            return 0;\n        }\n\n        slapi_log_err(SLAPI_LOG_INFO, \"dse_check_file\",\n                  \"The configuration file %s was restored from backup %s\\n\", filename, backupname);\n        return 1;\n\n    } else {\n        slapi_log_err(SLAPI_LOG_INFO, \"dse_check_file\", \"No backup filename provided.\\n\");\n        return 0;\n    }\n}\n\nstatic int\ndse_read_one_file(struct dse *pdse, const char *filename, Slapi_PBlock *pb, int primary_file)\n{\n    Slapi_Entry *e = NULL;\n    char *entrystr = NULL;\n    char *buf = NULL;\n    char *lastp = NULL;\n    int rc = 0; /* Fail */\n    PRInt32 nr = 0;\n    PRFileInfo64 prfinfo;\n    PRFileDesc *prfd = 0;\n    int schema_flags = 0;\n\n    slapi_pblock_get(pb, SLAPI_SCHEMA_FLAGS, &schema_flags);\n\n    if ((NULL != pdse) && (NULL != filename)) {\n        /* check if the \"real\" file exists and cam be used, if not try tmp as backup */\n        rc = dse_check_file((char *)filename, pdse->dse_tmpfile);\n        if (!rc) {\n            rc = dse_check_file((char *)filename, pdse->dse_fileback);\n        }\n\n        if ((rc = PR_GetFileInfo64(filename, &prfinfo)) != PR_SUCCESS) {\n            slapi_log_err(SLAPI_LOG_ERR, \"dse_read_one_file\",\n                          \"The configuration file %s could not be accessed, error %d\\n\",\n                          filename, rc);\n            rc = 0; /* Fail */\n        } else if ((prfd = PR_Open(filename, PR_RDONLY, SLAPD_DEFAULT_FILE_MODE)) == NULL) {\n            slapi_log_err(SLAPI_LOG_ERR, \"dse_read_one_file\",\n                          \"The configuration file %s could not be read. \" SLAPI_COMPONENT_NAME_NSPR \" %d (%s)\\n\",\n                          filename,\n                          PR_GetError(), slapd_pr_strerror(PR_GetError()));\n            rc = 0; /* Fail */\n        } else {\n            int done = 0;\n            /* read the entire file into core */\n            buf = slapi_ch_malloc(prfinfo.size + 1);\n            if ((nr = slapi_read_buffer(prfd, buf, prfinfo.size)) < 0) {\n                slapi_log_err(SLAPI_LOG_ERR, \"dse_read_one_file\",\n                              \"Could only read %d of %ld bytes from config file %s\\n\",\n                              nr, (long int)prfinfo.size, filename);\n                rc = 0; /* Fail */\n                done = 1;\n            }\n\n            (void)PR_Close(prfd);\n            buf[nr] = '\\0';\n\n            if (!done) {\n                int lineno = 1;\n                int lines = 0;\n                int dont_check_dups = 0;\n                int str2entry_flags = SLAPI_STR2ENTRY_EXPAND_OBJECTCLASSES |\n                                      SLAPI_STR2ENTRY_NOT_WELL_FORMED_LDIF;\n                if (schema_flags & DSE_SCHEMA_LOCKED)\n                    str2entry_flags |= SLAPI_STR2ENTRY_NO_SCHEMA_LOCK;\n\n                PR_ASSERT(pb);\n                slapi_pblock_get(pb, SLAPI_DSE_DONT_CHECK_DUPS, &dont_check_dups);\n                if (!dont_check_dups) {\n                    str2entry_flags |= SLAPI_STR2ENTRY_REMOVEDUPVALS;\n                }\n\n                /* Convert LDIF to entry structures */\n                rc = 1; /* assume we will succeed */\n                while ((entrystr = dse_read_next_entry(buf, &lastp)) != NULL) {\n                    char *p, *q;\n                    char errbuf[256];\n                    size_t estrlen = strlen(entrystr);\n                    size_t cpylen =\n                        (estrlen < sizeof(errbuf)) ? estrlen : sizeof(errbuf) - 1;\n\n                    memcpy(errbuf, entrystr, cpylen);\n                    errbuf[cpylen] = '\\0';\n\n                    lines = 1;\n                    p = entrystr;\n                    while ((q = strchr(p, '\\n'))) {\n                        p = q + 1;\n                        lines++;\n                    }\n\n                    e = slapi_str2entry(entrystr, str2entry_flags);\n                    if (e != NULL) {\n                        int returncode = 0;\n                        char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = {0};\n\n                        slapi_log_err(SLAPI_LOG_TRACE, \"dse_read_one_file\",\n                                      \" processing entry \\\"%s\\\" in file %s%s \"\n                                      \"(lineno: %d)\\n\",\n                                      slapi_entry_get_dn_const(e), filename,\n                                      primary_file ? \" (primary file)\" : \"\",\n                                      lineno);\n\n                        /* remove the numsubordinates attr, which may be bogus */\n                        slapi_entry_attr_delete(e, subordinatecount);\n\n                        /* set the \"primary file\" flag if appropriate */\n                        slapi_pblock_set(pb, SLAPI_DSE_IS_PRIMARY_FILE, &primary_file);\n                        if (dse_call_callback(pdse, pb, DSE_OPERATION_READ,\n                                              DSE_FLAG_PREOP, e, NULL, &returncode,\n                                              returntext) == SLAPI_DSE_CALLBACK_OK) {\n                            /*\n                             * This will free the entry if not added, so it is\n                             * definitely consumed by this call\n                             */\n                            if (dse_add_entry_pb(pdse, e, pb) == SCHEMA_VIOLATION) {\n                                /* schema violation, return failure */\n                                rc = 0;\n                            }\n                        } else /* free entry if not used */\n                        {\n                            slapi_log_err(SLAPI_LOG_FATAL,\n                                          \"dse_read_one_file\",\n                                          \"The entry %s in file %s \"\n                                          \"(lineno: %d) is invalid, \"\n                                          \"error code %d (%s) - %s\\n\",\n                                          slapi_entry_get_dn_const(e),\n                                          filename, lineno, returncode,\n                                          ldap_err2string(returncode),\n                                          returntext);\n                            slapi_entry_free(e);\n                            rc = 0; /* failure */\n                        }\n                    } else {\n                        slapi_log_err(SLAPI_LOG_ERR, \"dse_read_one_file\",\n                                      \"Parsing entry (lineno: %d) \"\n                                      \"in file %s failed.\\n\",\n                                      lineno, filename);\n                        slapi_log_err(SLAPI_LOG_ERR, \"dse_read_one_file\",\n                                      \"Invalid section [%s%s]\\n\",\n                                      errbuf, cpylen == estrlen ? \"\" : \" ...\");\n                        rc = 0; /* failure */\n                    }\n                    lineno += lines + 1 /* 1 is for a blank line. */;\n                }\n            }\n            slapi_ch_free((void **)&buf);\n        }\n    }\n\n    return rc;\n}\n\n/*\n * Read the file we were initialised with into memory.\n * If not NULL call entry_filter_fn on each entry as it's read.\n * The function is free to modify the entry before it's places\n * into the AVL tree. True means add the entry. False means don't.\n *\n * Return 1 for OK, 0 for Fail.\n */\nint\ndse_read_file(struct dse *pdse, Slapi_PBlock *pb)\n{\n    int rc = 1; /* Good */\n    int ii;\n    char **filelist = 0;\n    char *filename = 0;\n\n    filelist = charray_dup(pdse->dse_filelist);\n    filename = slapi_ch_strdup(pdse->dse_filename);\n\n    for (ii = 0; rc && filelist && filelist[ii]; ++ii) {\n        if (strcasecmp(filename, filelist[ii]) != 0) {\n            rc = dse_read_one_file(pdse, filelist[ii], pb, 0 /* not primary */);\n        }\n    }\n\n    if (rc) {\n        rc = dse_read_one_file(pdse, filename, pb, 1 /* primary file */);\n    }\n\n    charray_free(filelist);\n    slapi_ch_free((void **)&filename);\n\n    return rc;\n}\n\n/*\n * Structure to carry context information whilst\n * traversing the tree writing the entries to disk.\n */\ntypedef struct _fpw\n{\n    PRFileDesc *fpw_prfd;\n    int fpw_rc;\n    struct dse *fpw_pdse;\n} FPWrapper;\n\n\nstatic int\ndse_rw_permission_to_one_file(const char *name, int loglevel)\n{\n    PRErrorCode prerr = 0;\n    const char *accesstype = \"\";\n\n    if (NULL == name) {\n        return 1; /* file won't be used -- return \"sufficient permission\" */\n    }\n\n    if (PR_Access(name, PR_ACCESS_EXISTS) == PR_SUCCESS) {\n        /* file exists: check for read and write permission */\n        if (PR_Access(name, PR_ACCESS_WRITE_OK) != PR_SUCCESS) {\n            prerr = PR_GetError();\n            accesstype = \"write\";\n        } else if (PR_Access(name, PR_ACCESS_READ_OK) != PR_SUCCESS) {\n            prerr = PR_GetError();\n            accesstype = \"read\";\n        }\n    } else {\n        /* file does not exist: make sure we can create it */\n        PRFileDesc *prfd;\n\n        prfd = PR_Open(name, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE,\n                       SLAPD_DEFAULT_FILE_MODE);\n        if (NULL == prfd) {\n            prerr = PR_GetError();\n            accesstype = \"create\";\n        } else {\n            PR_Close(prfd);\n            PR_Delete(name);\n        }\n    }\n\n    if (prerr != 0) {\n        slapi_log_err(loglevel,\n                      \"dse_rw_permission_to_one_file\", \"Unable to %s \\\"%s\\\": \" SLAPI_COMPONENT_NAME_NSPR \" error %d (%s)\\n\",\n                      accesstype, name, prerr, slapd_pr_strerror(prerr));\n        return 0; /* insufficient permission */\n    } else {\n        return 1; /* sufficient permission */\n    }\n}\n\n\n/*\n * Check that we have permission to write to all the files that\n * dse_write_file_nolock() uses.\n * Returns a non-zero value if sufficient permission and 0 if not.\n */\nstatic int\ndse_permission_to_write(struct dse *pdse, int loglevel)\n{\n    int rc = 1; /* sufficient permission */\n\n    if (NULL != pdse->dse_filename) {\n        if (!dse_rw_permission_to_one_file(pdse->dse_filename, loglevel) ||\n            !dse_rw_permission_to_one_file(pdse->dse_fileback, loglevel) ||\n            !dse_rw_permission_to_one_file(pdse->dse_tmpfile, loglevel)) {\n            rc = 0; /* insufficient permission */\n        }\n    }\n\n    return rc;\n}\n\n\n/*\n * Check for read-only status and return an appropriate error to the\n * LDAP client.\n * Returns 0 if no error was returned and non-zero if one was.\n */\nstatic int\ndse_check_for_readonly_error(Slapi_PBlock *pb, struct dse *pdse)\n{\n    int rc = 0; /* default: no error */\n\n    if (pdse->dse_rwlock)\n        slapi_rwlock_rdlock(pdse->dse_rwlock);\n\n    if (!pdse->dse_is_updateable) {\n        if (!pdse->dse_readonly_error_reported) {\n            if (NULL != pdse->dse_filename) {\n                slapi_log_err(SLAPI_LOG_ERR, \"dse_check_for_readonly_error\",\n                              \"The DSE database stored in \\\"%s\\\" is not writeable\\n\",\n                              pdse->dse_filename);\n                /* log the details too */\n                (void)dse_permission_to_write(pdse, SLAPI_LOG_ERR);\n            }\n            pdse->dse_readonly_error_reported = 1;\n        }\n        rc = 1; /* return an error to the client */\n    }\n\n    if (pdse->dse_rwlock)\n        slapi_rwlock_unlock(pdse->dse_rwlock);\n\n    if (rc != 0) {\n        slapi_send_ldap_result(pb, LDAP_UNWILLING_TO_PERFORM, NULL,\n                               \"DSE database is read-only\", 0, NULL);\n    }\n\n    return rc; /* no error */\n}\n\n\n/*\n * Write the AVL tree of entries back to the LDIF file.\n */\nstatic int\ndse_write_file_nolock(struct dse *pdse)\n{\n    FPWrapper fpw;\n    int rc = 0;\n\n    if (dont_ever_write_dse_files) {\n        return rc;\n    }\n\n    fpw.fpw_rc = 0;\n    fpw.fpw_prfd = NULL;\n\n    if (NULL != pdse->dse_filename) {\n        if ((fpw.fpw_prfd = PR_Open(pdse->dse_tmpfile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE, SLAPD_DEFAULT_FILE_MODE)) == NULL) {\n            rc = PR_GetOSError();\n            slapi_log_err(SLAPI_LOG_ERR, \"dse_write_file_nolock\", \"Cannot open \"\n                                                                  \"temporary DSE file \\\"%s\\\" for update: OS error %d (%s)\\n\",\n                          pdse->dse_tmpfile, rc, slapd_system_strerror(rc));\n        } else {\n            fpw.fpw_pdse = pdse;\n            if (avl_apply(pdse->dse_tree, dse_write_entry, &fpw, STOP_TRAVERSAL, AVL_INORDER) == STOP_TRAVERSAL) {\n                rc = fpw.fpw_rc;\n                slapi_log_err(SLAPI_LOG_ERR, \"dse_write_file_nolock\", \"Cannot write \"\n                                                                      \" temporary DSE file \\\"%s\\\": OS error %d (%s)\\n\",\n                              pdse->dse_tmpfile, rc, slapd_system_strerror(rc));\n                (void)PR_Close(fpw.fpw_prfd);\n                fpw.fpw_prfd = NULL;\n            } else {\n                (void)PR_Close(fpw.fpw_prfd);\n                fpw.fpw_prfd = NULL;\n                if (pdse->dse_fileback != NULL) {\n                    rc = slapi_destructive_rename(pdse->dse_filename, pdse->dse_fileback);\n                    if (rc != 0) {\n                        slapi_log_err(SLAPI_LOG_ERR, \"dse_write_file_nolock\", \"Cannot backup\"\n                                                                              \" DSE file \\\"%s\\\" to \\\"%s\\\": OS error %d (%s)\\n\",\n                                      pdse->dse_filename, pdse->dse_fileback,\n                                      rc, slapd_system_strerror(rc));\n                    }\n                }\n                rc = slapi_destructive_rename(pdse->dse_tmpfile, pdse->dse_filename);\n                if (rc != 0) {\n                    slapi_log_err(SLAPI_LOG_ERR, \"dse_write_file_nolock\", \"Cannot rename\"\n                                                                          \" temporary DSE file \\\"%s\\\" to \\\"%s\\\":\"\n                                                                          \" OS error %d (%s)\\n\",\n                                  pdse->dse_tmpfile, pdse->dse_filename,\n                                  rc, slapd_system_strerror(rc));\n                }\n                /*\n                 * We have now written to the tmp location, and renamed it\n                 * we need to open and fsync the dir to make the rename stick.\n                 */\n                int fp_configdir =\n#ifdef O_PATH\n                    open(pdse->dse_configdir, O_PATH | O_DIRECTORY)\n#else\n                    open(pdse->dse_configdir, O_RDONLY | O_DIRECTORY)\n#endif\n                    ;\n                if (fp_configdir != -1) {\n                    fsync(fp_configdir);\n                    close(fp_configdir);\n                }\n            }\n        }\n        if (fpw.fpw_prfd)\n            (void)PR_Close(fpw.fpw_prfd);\n    }\n\n    return rc;\n}\n\n/*\n * Local function for writing an entry to a file.\n * Called by the AVL code during traversal.\n */\nstatic int\ndse_write_entry(caddr_t data, caddr_t arg)\n{\n    struct dse_node *n = (struct dse_node *)data;\n    FPWrapper *fpw = (FPWrapper *)arg;\n    char *s;\n    PRInt32 len;\n\n    if (NULL != n && NULL != n->entry) {\n        int returncode;\n        char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = \"\";\n        /* need to make a duplicate here for two reasons:\n           1) we don't want to hold on to the raw data in the node for any longer\n           than we have to; we will usually be inside the dse write lock, but . . .\n           2) the write callback may modify the entry, so we want to pass it a\n           writeable copy rather than the raw avl tree data pointer\n        */\n        Slapi_Entry *ec = slapi_entry_dup(n->entry);\n        if (dse_call_callback(fpw->fpw_pdse, NULL, DSE_OPERATION_WRITE,\n                              DSE_FLAG_PREOP, ec, NULL, &returncode, returntext) == SLAPI_DSE_CALLBACK_OK) {\n            /*\n             * 3-August-2000 mcs: We used to pass the SLAPI_DUMP_NOOPATTRS\n             * option to slapi_entry2str_with_options() so that operational\n             * attributes were NOT stored in the DSE LDIF files.  But now\n             * we store all attribute types.\n             */\n            if ((s = slapi_entry2str_with_options(ec, &len, 0)) != NULL) {\n                if (slapi_write_buffer(fpw->fpw_prfd, s, len) != len) {\n                    fpw->fpw_rc = PR_GetOSError();\n                    ;\n                    slapi_ch_free((void **)&s);\n                    return STOP_TRAVERSAL;\n                }\n                if (slapi_write_buffer(fpw->fpw_prfd, \"\\n\", 1) != 1) {\n                    fpw->fpw_rc = PR_GetOSError();\n                    ;\n                    slapi_ch_free((void **)&s);\n                    return STOP_TRAVERSAL;\n                }\n                slapi_ch_free((void **)&s);\n            }\n        }\n        slapi_entry_free(ec);\n    }\n    return 0;\n}\n\n/*\n * Adds an entry to the dse backend.  The passed in entry will be\n * free'd always.\n *\n * return -1 for duplicate entry\n * return -2 for schema violation (SCHEMA_VIOLATION)\n */\nstatic int\ndse_add_entry_pb(struct dse *pdse, Slapi_Entry *e, Slapi_PBlock *pb)\n{\n    int dont_write_file = 0, merge = 0; /* defaults */\n    int rc = 0;\n    struct dse_node *n = dse_node_new(e); /* copies e */\n    Slapi_Entry *schemacheckentry = NULL; /* to use for schema checking */\n\n    PR_ASSERT(pb);\n    slapi_pblock_get(pb, SLAPI_DSE_DONT_WRITE_WHEN_ADDING, &dont_write_file);\n    slapi_pblock_get(pb, SLAPI_DSE_MERGE_WHEN_ADDING, &merge);\n\n    /* keep write lock during both tree update and file write operations */\n    if (pdse->dse_rwlock)\n        slapi_rwlock_wrlock(pdse->dse_rwlock);\n    if (merge) {\n        rc = avl_insert(&(pdse->dse_tree), n, entry_dn_cmp, dupentry_merge);\n    } else {\n        rc = avl_insert(&(pdse->dse_tree), n, entry_dn_cmp, dupentry_disallow);\n    }\n    if (-1 != rc) {\n        /* update num sub of parent with no lock; we already hold the write lock */\n        if (0 == rc) { /* entry was added, not merged; update numsub */\n            /* easter egg entry - don't update num sub */\n            if (strcmp(slapi_entry_get_ndn(e), \"ou=red hat directory server team,cn=monitor\") != 0) {\n                dse_updateNumSubOfParent(pdse, slapi_entry_get_sdn_const(e),\n                                         SLAPI_OPERATION_ADD);\n            }\n        } else { /* entry was merged, free temp unused data */\n            dse_node_delete(&n);\n        }\n        if (!dont_write_file) {\n            dse_write_file_nolock(pdse);\n        }\n    } else {                 /* duplicate entry ignored */\n        dse_node_delete(&n); /* This also deletes the contained entry */\n    }\n    if (pdse->dse_rwlock)\n        slapi_rwlock_unlock(pdse->dse_rwlock);\n\n    if (rc == -1) {\n        /* duplicate entry ignored */\n        schemacheckentry = dse_get_entry_copy(pdse,\n                                              slapi_entry_get_sdn_const(e),\n                                              DSE_USE_LOCK);\n    } else /* entry added or merged */\n    {\n        /* entry was added or merged */\n        if (0 == rc) /* 0 return means entry was added, not merged */\n        {\n            /* save a search of the tree, since we added the entry, the\n               contents of e should be the same as what is in the tree */\n            schemacheckentry = slapi_entry_dup(e);\n        } else /* merged */\n        {\n            /* schema check the new merged entry, so get it from the tree */\n            schemacheckentry = dse_get_entry_copy(pdse,\n                                                  slapi_entry_get_sdn_const(e),\n                                                  DSE_USE_LOCK);\n        }\n    }\n    if (NULL != schemacheckentry) {\n        /*\n         * Verify that the new or merged entry conforms to the schema.\n         *        Errors are logged by slapi_entry_schema_check().\n         */\n        if (slapi_entry_schema_check(pb, schemacheckentry)) {\n            rc = SCHEMA_VIOLATION;\n        }\n        slapi_entry_free(schemacheckentry);\n    }\n\n    /* Callers expect e (SLAPI_ADD_ENTRY) to be freed */\n    /* This function duplicates 'e' for dse_node 'n' and schemacheckentry.\n     * 'e' should not have been consumed */\n    slapi_entry_free(e);\n\n    return rc;\n}\n\n/*\n * Local function for comparing two entries by DN.  Store the entries\n * so that when they are printed out, the child entries are below their\n * ancestor entries\n */\nstatic int\nentry_dn_cmp(caddr_t d1, caddr_t d2)\n{\n    struct dse_node *n1 = (struct dse_node *)d1;\n    struct dse_node *n2 = (struct dse_node *)d2;\n    const Slapi_DN *dn1 = slapi_entry_get_sdn_const(n1->entry);\n    const Slapi_DN *dn2 = slapi_entry_get_sdn_const(n2->entry);\n    int retval = slapi_sdn_compare(dn1, dn2);\n\n    if (retval != 0) {\n        if (slapi_sdn_issuffix(dn1, dn2)) {\n            retval = 1;\n        } else if (slapi_sdn_issuffix(dn2, dn1)) {\n            retval = -1;\n        } else {\n            /* put fewer rdns before more rdns */\n            int rc = 0;\n            char **dnlist1 = slapi_ldap_explode_dn(slapi_sdn_get_ndn(dn1), 0);\n            char **dnlist2 = slapi_ldap_explode_dn(slapi_sdn_get_ndn(dn2), 0);\n            int len1 = 0;\n            int len2 = 0;\n            if (dnlist1)\n                for (len1 = 0; dnlist1[len1]; ++len1)\n                    ;\n            if (dnlist2)\n                for (len2 = 0; dnlist2[len2]; ++len2)\n                    ;\n\n            if (len1 == len2) {\n                len1--;\n                for (; (rc == 0) && (len1 >= 0); --len1) {\n                    rc = strcmp(dnlist1[len1], dnlist2[len1]);\n                }\n                if (rc)\n                    retval = rc;\n            } else\n                retval = len1 - len2;\n\n            if (dnlist1)\n                slapi_ldap_value_free(dnlist1);\n            if (dnlist2)\n                slapi_ldap_value_free(dnlist2);\n        }\n    }\n    /* else entries are equal if dns are equal */\n\n    return retval;\n}\n\n\nstatic int\ndupentry_disallow(caddr_t d1 __attribute__((unused)), caddr_t d2 __attribute__((unused)))\n{\n    return -1;\n}\n\n\nstatic int\ndupentry_replace(caddr_t d1, caddr_t d2)\n{\n    /*\n     * Hack attack: since we don't have the address of the pointer\n     * in the avl node, we have to replace the e_dn and e_attrs\n     * members of the entry which is in the AVL tree with our\n     * new entry DN and attrs.  We then point the \"new\" entry's\n     * e_dn and e_attrs pointers to point to the values we just\n     * replaced, on the assumption that the caller will be freeing\n     * these.\n     */\n    struct dse_node *n1 = (struct dse_node *)d1; /* OLD */\n    struct dse_node *n2 = (struct dse_node *)d2; /* NEW */\n    Slapi_Entry *e = n1->entry;\n    n1->entry = n2->entry;\n    n2->entry = e;\n    return DSE_ENTRY_WAS_REPLACED;\n}\n\nstatic int\ndupentry_merge(caddr_t d1, caddr_t d2)\n{\n    struct dse_node *n1 = (struct dse_node *)d1; /* OLD */\n    struct dse_node *n2 = (struct dse_node *)d2; /* NEW */\n    Slapi_Entry *e1 = n1->entry;\n    Slapi_Entry *e2 = n2->entry;\n    int rc = 0;\n    Slapi_Attr *newattr = 0;\n\n    for (rc = slapi_entry_first_attr(e2, &newattr);\n         !rc && newattr;\n         rc = slapi_entry_next_attr(e2, newattr, &newattr)) {\n        char *type = 0;\n        slapi_attr_get_type(newattr, &type);\n        if (type) {\n            /* insure there are no duplicate values in e1 */\n            rc = slapi_entry_merge_values_sv(e1, type,\n                                             attr_get_present_values(newattr));\n        }\n    }\n\n    return DSE_ENTRY_WAS_MERGED;\n}\n\n/*\n * Add an entry to the DSE without locking the DSE avl tree.\n * Replaces the entry if it already exists.\n *\n * The given entry e is never consumed.  It is the responsibility of the\n * caller to free it when it is no longer needed.\n *\n * The write_file flag is used if we want to update the entry in memory\n * but we do not want to write out the file.  For example, if we update\n * the numsubordinates in the entry, this is an operational attribute that\n * we do not want saved to disk.\n */\nstatic int\ndse_replace_entry(struct dse *pdse, Slapi_Entry *e, int write_file, int use_lock)\n{\n    int rc = -1;\n    if (NULL != e) {\n        struct dse_node *n = dse_node_new(e);\n        if (use_lock && pdse->dse_rwlock)\n            slapi_rwlock_wrlock(pdse->dse_rwlock);\n        rc = avl_insert(&(pdse->dse_tree), n, entry_dn_cmp, dupentry_replace);\n        if (write_file)\n            dse_write_file_nolock(pdse);\n        /* If the entry was replaced i.e. not added as a new entry, we need to\n           free the old data, which is set in dupentry_replace */\n        if (DSE_ENTRY_WAS_REPLACED == rc) {\n            dse_node_delete(&n);\n            rc = 0; /* for return to caller */\n        }\n        if (use_lock && pdse->dse_rwlock)\n            slapi_rwlock_unlock(pdse->dse_rwlock);\n    }\n    return rc;\n}\n\n\n/*\n * Return -1 if p does not point to a valid LDIF\n * end-of-record delimiter (a NULL, two newlines, or two\n * pairs of CRLF).  Otherwise, return the length of\n * the delimiter found.\n */\nstatic int\nldif_record_end(char *p)\n{\n    if (NULL != p) {\n        if ('\\0' == *p) {\n            return 0;\n        } else if ('\\n' == *p && '\\n' == *(p + 1)) {\n            return 2;\n        } else if ('\\r' == *p && '\\n' == *(p + 1) && '\\r' == *(p + 2) && '\\n' == *(p + 3)) {\n            return 4;\n        }\n    }\n    return -1;\n}\n\nchar *\ndse_read_next_entry(char *buf, char **lastp)\n{\n    char *p, *start;\n\n    if (NULL == buf) {\n        *lastp = NULL;\n        return NULL;\n    }\n    p = start = (NULL == *lastp) ? buf : *lastp;\n    /* Skip over any leading record delimiters */\n    while ('\\n' == *p || '\\r' == *p) {\n        p++;\n    }\n    if ('\\0' == *p) {\n        *lastp = NULL;\n        return NULL;\n    }\n    while ('\\0' != *p) {\n        int rc;\n        if ((rc = ldif_record_end(p)) >= 0) {\n            /* Found end of LDIF record */\n            *p = '\\0';\n            p += rc;\n            break;\n        } else {\n            p++;\n        }\n    }\n    *lastp = p;\n    return start;\n}\n\n/*\n * Apply the function to each entry.  The caller is responsible for locking\n * the rwlock in the dse for the appropriate type of operation e.g. for\n * searching, a read lock, for modifying in place, a write lock\n */\nstatic int\ndse_apply_nolock(struct dse *pdse, IFP fp, caddr_t arg)\n{\n    avl_apply(pdse->dse_tree, fp, arg, STOP_TRAVERSAL, AVL_INORDER);\n    return 1;\n}\n\n\n/*\n * Remove the entry from the tree.\n * Returns 1 if entry is removed and 0 if not.\n */\nstatic int\ndse_delete_entry(struct dse *pdse, Slapi_PBlock *pb, const Slapi_Entry *e)\n{\n    int dont_write_file = 0;\n    struct dse_node *n = dse_node_new(e);\n    struct dse_node *deleted_node = NULL;\n\n    slapi_pblock_get(pb, SLAPI_DSE_DONT_WRITE_WHEN_ADDING, &dont_write_file);\n\n    /* keep write lock for both tree deleting and file writing */\n    if (pdse->dse_rwlock)\n        slapi_rwlock_wrlock(pdse->dse_rwlock);\n    if ((deleted_node = (struct dse_node *)avl_delete(&pdse->dse_tree,\n                                                      n, entry_dn_cmp)))\n        dse_node_delete(&deleted_node);\n    dse_node_delete(&n);\n\n    if (!dont_write_file) {\n        /* Decrement the numsubordinate count of the parent entry */\n        dse_updateNumSubOfParent(pdse, slapi_entry_get_sdn_const(e),\n                                 SLAPI_OPERATION_DELETE);\n        dse_write_file_nolock(pdse);\n    }\n    if (pdse->dse_rwlock)\n        slapi_rwlock_unlock(pdse->dse_rwlock);\n\n    return 1;\n}\n\n\n/*\n * Returns a SLAPI_BIND_xxx retun code.\n */\nint\ndse_bind(Slapi_PBlock *pb) /* JCM There should only be one exit point from this function! */\n{\n    ber_tag_t method;    /* The bind method */\n    struct berval *cred; /* The bind credentials */\n    Slapi_Value **bvals;\n    struct dse *pdse;\n    Slapi_Attr *attr;\n    Slapi_DN *sdn = NULL;\n    Slapi_Entry *ec = NULL;\n\n    /*Get the parameters*/\n    if (slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse) < 0 ||\n        slapi_pblock_get(pb, SLAPI_BIND_TARGET_SDN, &sdn) < 0 ||\n        slapi_pblock_get(pb, SLAPI_BIND_METHOD, &method) < 0 ||\n        slapi_pblock_get(pb, SLAPI_BIND_CREDENTIALS, &cred) < 0) {\n        slapi_send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, NULL, 0, NULL);\n        return SLAPI_BIND_FAIL;\n    }\n\n    /* always allow noauth simple binds */\n    if (method == LDAP_AUTH_SIMPLE && cred->bv_len == 0) {\n        /*\n         * report success to client, but return\n         * SLAPI_BIND_FAIL so we don't\n         * authorize based on noauth credentials\n         */\n        slapi_send_ldap_result(pb, LDAP_SUCCESS, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Entry does not exist\");\n        slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    switch (method) {\n    case LDAP_AUTH_SIMPLE: {\n        Slapi_Value cv;\n        if (slapi_entry_attr_find(ec, \"userpassword\", &attr) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Entry does not have userpassword set\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            return SLAPI_BIND_FAIL;\n        }\n        bvals = attr_get_present_values(attr);\n\n        slapi_value_init_berval(&cv, cred);\n        if (slapi_pw_find_sv(bvals, &cv) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Invalid credentials\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            value_done(&cv);\n            return SLAPI_BIND_FAIL;\n        }\n        value_done(&cv);\n    } break;\n\n    default:\n        slapi_send_ldap_result(pb, LDAP_STRONG_AUTH_NOT_SUPPORTED, NULL, \"auth method not supported\", 0, NULL);\n        slapi_entry_free(ec);\n        return SLAPI_BIND_FAIL;\n    }\n    slapi_entry_free(ec);\n    /* success:  front end will send result */\n    return SLAPI_BIND_SUCCESS;\n}\n\nint\ndse_unbind(Slapi_PBlock *pb __attribute__((unused)))\n{\n    return 0;\n}\n\n/*\n * This structure is simply to pass parameters to dse_search_filter_entry.\n */\nstruct magicSearchStuff\n{\n    Slapi_PBlock *pb;\n    struct dse *pdse;\n    int scope;\n    const Slapi_DN *basedn;\n    Slapi_Filter *filter;\n    int nentries;\n    char **attrs;       /*Attributes*/\n    int attrsonly;      /*Should we just return the attributes found?*/\n    dse_search_set *ss; /* for the temporary results - to pass to the dse search callbacks */\n};\n\n/*\n * The function which is called on each node of the AVL tree.\n */\nstatic int\ndse_search_filter_entry(caddr_t data, caddr_t arg)\n{\n    struct dse_node *n = (struct dse_node *)data;\n    struct magicSearchStuff *p = (struct magicSearchStuff *)arg;\n    if (slapi_sdn_scope_test(slapi_entry_get_sdn_const(n->entry), p->basedn, p->scope)) {\n        if (slapi_vattr_filter_test(p->pb, n->entry, p->filter, 1 /* verify access */) == 0) {\n            Slapi_Entry *ec = slapi_entry_dup(n->entry);\n            p->nentries++;\n            if (!p->ss) {\n                p->ss = dse_search_set_new();\n            }\n            dse_search_set_add_entry(p->ss, ec); /* consumes the entry */\n        } else {\n            /*\n            slapd_log_error_proc(\"dse_search_filter_entry\",\n                                 \"filter test failed: dn %s did not match filter %d\\n\",\n                                 slapi_entry_get_dn_const(n->entry), p->filter->f_choice);\n*/\n        }\n    } else {\n        /*\n        slapd_log_error_proc(\"dse_search_filter_entry\",\n                             \"scope test failed: dn %s is not in scope %d of dn [%s]\\n\",\n                             slapi_entry_get_dn_const(n->entry), p->scope,\n                             slapi_sdn_get_dn(p->basedn));\n*/\n    }\n    return 0;\n}\n\n/*\n * The function which kicks off the traversal of the AVL tree.\n * Returns the number of entries returned.\n */\n/* jcm: Not very efficient if there are many DSE entries. */\n/* jcm: It applies the filter to every node in the tree regardless */\nstatic int\ndo_dse_search(struct dse *pdse, Slapi_PBlock *pb, int scope, const Slapi_DN *basedn, Slapi_Filter *filter, char **attrs, int attrsonly)\n{\n    struct magicSearchStuff stuff;\n    stuff.pb = pb;\n    stuff.pdse = pdse;\n    stuff.scope = scope;\n    stuff.basedn = basedn;\n    stuff.filter = filter;\n    stuff.nentries = 0;\n    stuff.attrs = attrs;\n    stuff.attrsonly = attrsonly;\n    stuff.ss = NULL;\n    Operation *pb_op = NULL;\n    slapi_pblock_get(pb, SLAPI_OPERATION, &pb_op);\n\n    /*\n     * If this is a persistent search and the client is only interested in\n     * entries that change, we skip looking through the DSE entries.\n     */\n    if (pb_op == NULL || !operation_is_flag_set(pb_op, OP_FLAG_PS_CHANGESONLY)) {\n        if (pdse->dse_rwlock)\n            slapi_rwlock_rdlock(pdse->dse_rwlock);\n        dse_apply_nolock(pdse, dse_search_filter_entry, (caddr_t)&stuff);\n        if (pdse->dse_rwlock)\n            slapi_rwlock_unlock(pdse->dse_rwlock);\n    }\n\n    if (stuff.ss) /* something was found which matched our criteria */\n    {\n        Slapi_Entry *e = NULL;\n        for (e = dse_search_set_get_next_entry(stuff.ss);\n             e;\n             e = dse_search_set_get_next_entry(stuff.ss)) {\n            int returncode = 0;\n            char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = \"\";\n\n            if (dse_call_callback(pdse, pb, SLAPI_OPERATION_SEARCH,\n                                  DSE_FLAG_PREOP, e, NULL, &returncode, returntext) == SLAPI_DSE_CALLBACK_OK) {\n                dse_search_set *ss = NULL;\n                slapi_pblock_get(pb, SLAPI_SEARCH_RESULT_SET, &ss);\n                /* if this is the first entry - allocate dse_search_set structure */\n                if (ss == NULL) {\n                    ss = dse_search_set_new();\n                    slapi_pblock_set(pb, SLAPI_SEARCH_RESULT_SET, ss);\n                }\n                /* make another reference to e (stuff.ss references it too)\n                   the stuff.ss reference is removed by dse_search_set_clean()\n                   below, leaving ss as the sole owner of the memory */\n                dse_search_set_add_entry(ss, e);\n            } else {\n                stuff.nentries--; /* rejected entry */\n                /* this leaves a freed pointer in stuff.ss, but that's ok because\n                   it should never be referenced, and the reference is removed by\n                   the call to dse_search_set_clean() below */\n                slapi_entry_free(e);\n            }\n        }\n        dse_search_set_clean(stuff.ss);\n    }\n\n    /* the pblock ss now contains the \"real\" search result set and the copies of\n       the entries allocated in dse_search_filter_entry; any entries rejected by\n       the search callback were freed above by the call to slapi_entry_free() */\n    return stuff.nentries;\n}\n\n/*\n * -1 means something went wrong.\n * 0 means everything went ok.\n */\nint\ndse_search(Slapi_PBlock *pb) /* JCM There should only be one exit point from this function! */\n{\n    int scope;            /*Scope of the search*/\n    Slapi_Filter *filter; /*The filter*/\n    char **attrs;         /*Attributes*/\n    int attrsonly;        /*Should we just return the attributes found?*/\n    /*int nentries= 0; Number of entries found thus far*/\n    struct dse *pdse;\n    int returncode = LDAP_SUCCESS;\n    int isrootdse = 0;\n    char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = \"\";\n    Slapi_DN *basesdn = NULL;\n    int estimate = 0; /* estimated search result set size */\n\n    /*\n     * Get private information created in the init routine.\n     * Also get the parameters of the search operation. These come\n     * more or less directly from the client.\n     */\n    if (slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse) < 0 ||\n        slapi_pblock_get(pb, SLAPI_SEARCH_TARGET_SDN, &basesdn) < 0 ||\n        slapi_pblock_get(pb, SLAPI_SEARCH_SCOPE, &scope) < 0 ||\n        slapi_pblock_get(pb, SLAPI_SEARCH_FILTER, &filter) < 0 ||\n        slapi_pblock_get(pb, SLAPI_SEARCH_ATTRS, &attrs) < 0 ||\n        slapi_pblock_get(pb, SLAPI_SEARCH_ATTRSONLY, &attrsonly) < 0) {\n        slapi_send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, NULL, 0, NULL);\n        return (-1);\n    }\n    /*\n     * Sadly the root dse is still a special case.  We must not allow\n     * acl checks on it, or allow onelevel or subtree searches on it.\n     */\n    isrootdse = slapi_sdn_isempty(basesdn);\n\n    switch (scope) {\n    case LDAP_SCOPE_BASE: {\n        Slapi_Entry *baseentry = NULL;\n        baseentry = dse_get_entry_copy(pdse, basesdn, DSE_USE_LOCK);\n        if (baseentry == NULL) {\n            slapi_send_ldap_result(pb, LDAP_NO_SUCH_OBJECT, NULL, NULL, 0, NULL);\n            slapi_log_err(SLAPI_LOG_PLUGIN, \"dse_search\", \"node %s was not found\\n\",\n                          slapi_sdn_get_dn(basesdn));\n            return -1;\n        }\n        /*\n         * We don't want to do an acl check for the root dse... because the acl\n         * code thinks it's a suffix of every target... so every acl applies to\n         * the root dse... which is wrong.\n         */\n        if (slapi_vattr_filter_test(pb, baseentry, filter, !isrootdse /* verify access */) == 0) {\n            /* Callbacks modify a copy of the entry */\n            if (dse_call_callback(pdse, pb, SLAPI_OPERATION_SEARCH,\n                                  DSE_FLAG_PREOP, baseentry, NULL, &returncode, returntext) == SLAPI_DSE_CALLBACK_OK) {\n                dse_search_set *ss;\n                ss = dse_search_set_new();\n                slapi_pblock_set(pb, SLAPI_SEARCH_RESULT_SET, ss);\n                dse_search_set_add_entry(ss, baseentry); /* consumes the entry */\n                baseentry = NULL;\n                estimate = 1; /* scope base */\n            }\n        }\n        slapi_entry_free(baseentry);\n    } break;\n    case LDAP_SCOPE_ONELEVEL:\n    /* FALL THROUGH */\n    case LDAP_SCOPE_SUBTREE:\n        if (!isrootdse) {\n            estimate = do_dse_search(pdse, pb, scope, basesdn, filter, attrs, attrsonly);\n        }\n        break;\n    }\n    slapi_pblock_set(pb, SLAPI_SEARCH_RESULT_SET_SIZE_ESTIMATE, &estimate);\n\n    /* Search is done, send LDAP_SUCCESS */\n    return 0;\n}\n\nint32_t\ndse_compare(Slapi_PBlock *pb)\n{\n    /*\n     * Inspired largely by ldbm_compare.c. Allow schema aware comparison\n     * of entries in the DSE, including cn=config.\n     */\n    backend *be = NULL;\n    char *type = NULL;\n    struct berval *bval = NULL;\n    Slapi_DN *sdn = NULL;\n    struct dse *pdse = NULL;\n    Slapi_Entry *ec = NULL;\n    Slapi_Value compare_value = {0};\n\n    slapi_pblock_get(pb, SLAPI_BACKEND, &be);\n    slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse);\n    slapi_pblock_get(pb, SLAPI_TARGET_SDN, &sdn);\n    slapi_pblock_get(pb, SLAPI_COMPARE_TYPE, &type);\n    slapi_pblock_get(pb, SLAPI_COMPARE_VALUE, &bval);\n\n    /* get the entry */\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        slapi_send_ldap_result(pb, LDAP_NO_SUCH_OBJECT, NULL, NULL, 0, NULL);\n        return -1;\n    }\n\n    /* Access control check */\n    int32_t err = slapi_access_allowed(pb, ec, type, bval, SLAPI_ACL_COMPARE);\n    if (err != LDAP_SUCCESS) {\n        slapi_entry_free(ec);\n        slapi_send_ldap_result(pb, err, NULL, NULL, 0, NULL);\n        return -1;\n    }\n\n    /* If cn=config, setup the entry with ALL values we could check from defaults */\n    Slapi_DN config_dn;\n    slapi_sdn_init_ndn_byref(&config_dn, \"cn=config\");\n    if (slapi_sdn_compare(&config_dn, sdn) == 0) {\n        read_config_dse(pb, ec, NULL, &err, NULL, NULL);\n        /*\n         * read_config_dse, and in turn, config_set_entry always returns\n         * a 1 here, which is probably dse_callback related.\n         */\n        if (err != 1) {\n            slapi_send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, NULL, 0, NULL);\n            return -1;\n        }\n        /*\n         * cn=config is now populated\n         */\n    }\n    slapi_sdn_done(&config_dn);\n\n    /* Do the schema aware check. */\n    slapi_value_init_berval(&compare_value, bval);\n\n    int32_t result = 0;\n    err = slapi_vattr_value_compare(ec, type, &compare_value, &result, 0);\n\n    /* We have the results, now free and then send. */\n    slapi_entry_free(ec);\n    value_done(&compare_value);\n\n    /* Format the result as expected. */\n    if (err != LDAP_SUCCESS) {\n        if (SLAPI_VIRTUALATTRS_NOT_FOUND == err) {\n            slapi_send_ldap_result(pb, LDAP_NO_SUCH_ATTRIBUTE, NULL, NULL, 0, NULL);\n        } else {\n            /* Some other problem, call it an operations error */\n            slapi_send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, NULL, 0, NULL);\n        }\n        return -1;\n    } else {\n        if (result != 0) {\n            slapi_send_ldap_result(pb, LDAP_COMPARE_TRUE, NULL, NULL, 0, NULL);\n        } else {\n            slapi_send_ldap_result(pb, LDAP_COMPARE_FALSE, NULL, NULL, 0, NULL);\n        }\n    }\n    return 0;\n}\n\n/*\n * -1 means something went wrong.\n * 0 means everything went ok.\n */\n\nstatic int\ndse_modify_return(int rv, Slapi_Entry *ec, Slapi_Entry *ecc)\n{\n    slapi_entry_free(ec);\n    slapi_entry_free(ecc);\n    return rv;\n}\n\nint\ndse_modify(Slapi_PBlock *pb) /* JCM There should only be one exit point from this function! */\n{\n    int err;             /*House keeping stuff*/\n    LDAPMod **mods;      /*Used to apply the modifications*/\n    LDAPMod **original_mods = NULL; /* some mods can be removed by callback, save them for later logging */\n    char *errbuf = NULL; /* To get error back */\n    struct dse *pdse;\n    Slapi_Entry *ec = NULL;\n    Slapi_Entry *ecc = NULL;\n    int returncode = LDAP_SUCCESS;\n    char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = \"\";\n    Slapi_DN *sdn = NULL;\n    int dont_write_file = 0; /* default */\n    int rc = SLAPI_DSE_CALLBACK_DO_NOT_APPLY;\n    int retval = -1;\n    int need_be_postop = 0;\n    int plugin_started = 0;\n    int internal_op = 0;\n    PRBool global_lock_owned = PR_FALSE;\n    Operation *pb_op = NULL;\n\n    PR_ASSERT(pb);\n    if (slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse) < 0 ||\n        /* slapi_pblock_get( pb, SLAPI_MODIFY_TARGET, &dn ) < 0 || */\n        slapi_pblock_get(pb, SLAPI_MODIFY_TARGET_SDN, &sdn) < 0 ||\n        slapi_pblock_get(pb, SLAPI_MODIFY_MODS, &mods) < 0 || (NULL == pdse)) {\n        returncode = LDAP_OPERATIONS_ERROR;\n        goto done;\n    }\n\n    slapi_pblock_get(pb, SLAPI_DSE_DONT_WRITE_WHEN_ADDING, &dont_write_file);\n    if (!dont_write_file && dse_check_for_readonly_error(pb, pdse)) {\n        /* already returned result */\n        return retval;\n    }\n\n    slapi_pblock_get(pb, SLAPI_OPERATION, &pb_op);\n    if (pb_op){\n        internal_op = operation_is_flag_set(pb_op, OP_FLAG_INTERNAL);\n    }\n    /* Find the entry we are about to modify. */\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        returncode = LDAP_NO_SUCH_OBJECT;\n        goto done;\n    }\n\n    /* Check acl */\n    err = plugin_call_acl_mods_access(pb, ec, mods, &errbuf);\n    if (err != LDAP_SUCCESS) {\n        returncode = err;\n        if (errbuf) {\n            PL_strncpyz(returntext, errbuf, sizeof(returntext));\n            slapi_ch_free_string(&errbuf);\n        }\n        goto done;\n    }\n\n    /* Save away a copy of the entry, before modifications */\n    slapi_pblock_set(pb, SLAPI_ENTRY_PRE_OP, slapi_entry_dup(ec)); /* JCM - When does this get free'd? */\n    /* richm - it is freed in modify.c */\n\n    /* Modify a copy of the entry*/\n    ecc = slapi_entry_dup(ec);\n    err = entry_apply_mods(ecc, mods);\n\n    /* Possibly acquire the global backend lock */\n    if (global_backend_lock_requested()) {\n        global_backend_lock_lock();\n        global_lock_owned = PR_TRUE;\n    }\n    original_mods = copy_mods(mods);\n\n    /* XXXmcs: should we expand objectclass values here?? */\n    /* give the dse callbacks the first crack at the modify */\n    rc = dse_call_callback(pdse, pb, SLAPI_OPERATION_MODIFY, DSE_FLAG_PREOP, ec, ecc, &returncode, returntext);\n    if (SLAPI_DSE_CALLBACK_OK == rc) {\n        int plugin_rc;\n\n        /* next, give the be plugins a crack at it */\n        slapi_pblock_set(pb, SLAPI_RESULT_CODE, &returncode);\n        slapi_pblock_set(pb, SLAPI_MODIFY_EXISTING_ENTRY, ecc);\n        plugin_rc = plugin_call_plugins(pb, SLAPI_PLUGIN_BE_PRE_MODIFY_FN);\n        need_be_postop = 1; /* if the be preops were called, have to call the be postops too */\n        if (!returncode) {\n            slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n        }\n        if (!plugin_rc && !returncode) {\n            /* finally, give the betxn plugins a crack at it */\n            plugin_rc = plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_PRE_MODIFY_FN);\n            if (!returncode) {\n                slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n            }\n            if (plugin_rc || returncode) {\n                slapi_log_err(SLAPI_DSE_TRACELEVEL,\n                              \"dse_modify\", \"SLAPI_PLUGIN_BE_TXN_PRE_MODIFY_FN failed - rc %d LDAP error %d:%s\\n\",\n                              plugin_rc, returncode, ldap_err2string(returncode));\n            }\n        } else {\n            slapi_log_err(SLAPI_DSE_TRACELEVEL,\n                          \"dse_modify\", \"SLAPI_PLUGIN_BE_PRE_MODIFY_FN failed - rc %d LDAP error %d:%s\\n\",\n                          rc, returncode, ldap_err2string(returncode));\n        }\n        if (plugin_rc || returncode) {\n            char *ldap_result_message = NULL;\n            rc = SLAPI_DSE_CALLBACK_ERROR;\n            if (!returncode) {\n                slapi_log_err(SLAPI_DSE_TRACELEVEL,\n                              \"dse_modify\", \"PRE_MODIFY plugin returned non-zero but did not set an LDAP error\\n\");\n                returncode = LDAP_OPERATIONS_ERROR;\n            }\n            if (!returntext[0]) {\n                slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);\n                if (ldap_result_message && ldap_result_message[0]) {\n                    PL_strncpyz(returntext, ldap_result_message, sizeof(returntext));\n                }\n            }\n        } else {\n            /*\n             * If we are using dynamic plugins, and we are modifying a plugin\n             * we need to do some additional checks.  First, check if we are\n             * enabling/disabling a plugin.  Then make sure the plugin still\n             * starts after applying the plugin changes.\n             */\n            rc = SLAPI_DSE_CALLBACK_OK;\n            if (slapi_entry_attr_hasvalue(ec, SLAPI_ATTR_OBJECTCLASS, \"nsSlapdPlugin\")) {\n                if (config_get_dynamic_plugins()) {\n                    if ((plugin_started = dse_modify_plugin(ec, ecc, returntext)) == -1) {\n                        returncode = LDAP_UNWILLING_TO_PERFORM;\n                        rc = SLAPI_DSE_CALLBACK_ERROR;\n                        retval = -1;\n                        goto done;\n                    }\n                    /*\n                     * If this is not a internal operation, make sure the plugin\n                     * can be restarted.\n                     */\n                    if (!internal_op) {\n                        if (dse_pre_modify_plugin(ec, ecc, mods)) {\n                            char *errtext;\n                            slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &errtext);\n                            if (errtext) {\n                                PL_strncpyz(returntext,\n                                            \"Failed to apply plugin config change, \"\n                                            \"check the errors log for more info.\",\n                                            sizeof(returntext));\n                            }\n                            returncode = LDAP_UNWILLING_TO_PERFORM;\n                            rc = SLAPI_DSE_CALLBACK_ERROR;\n                            retval = -1;\n                            goto done;\n                        }\n                    }\n                } else {\n                    slapi_log_err(SLAPI_LOG_NOTICE, \"dse_modify\", \"A plugin has been enabled or disabled, but nsslapd-dynamic-plugins is off. A server restart is required to change this plugin state.\\n\");\n                } /* end config_get_dynamic_plugins */\n            } /* end has nsSlapdPlugin */\n        }\n    }\n\n    switch (rc) {\n    case SLAPI_DSE_CALLBACK_ERROR:\n        /* Error occured in the callback -- return error code from callback */\n        goto done;\n        break;\n    case SLAPI_DSE_CALLBACK_DO_NOT_APPLY:\n        /* Callback says don't apply the changes -- return Success */\n        returncode = LDAP_SUCCESS;\n        returntext[0] = '\\0';\n        retval = 0;\n        goto done;\n        break;\n    case SLAPI_DSE_CALLBACK_OK: {\n        /* The callback may alter the mods in the pblock.  This happens\n           for example in the schema code.  Since the schema attributes\n           are managed exclusively by the schema code, we should not\n           apply those mods.  However, for reasons unknown to me, we\n           must in the general case call entry_apply_mods before calling\n           the modify callback above.  In the case of schema, the schema\n           code will remove the schema attributes from the mods.  So, we\n           reapply the mods to the entry for the attributes we manage in\n           the dse code (e.g. aci)\n        */\n        int reapply_mods = 0; /* default is to not reapply entry_apply_mods */\n        slapi_pblock_get(pb, SLAPI_DSE_REAPPLY_MODS, &reapply_mods);\n        /* Callback says apply the changes */\n        if (reapply_mods) {\n            LDAPMod **modsagain = NULL; /*Used to apply the modifications*/\n            slapi_pblock_get(pb, SLAPI_MODIFY_MODS, &modsagain);\n            if (NULL != modsagain) {\n                /* the dse modify callback must have modified ecc back to it's\n                   original state, before the earlier apply_mods, but without the\n                   attributes it did not want us to apply mods to */\n                err = entry_apply_mods(ecc, modsagain);\n            }\n        }\n\n        if (err != 0) {\n            returncode = err;\n            returntext[0] = '\\0';\n            retval = -1;\n            goto done;\n        }\n        break;\n    }\n    }\n\n    /* We're applying the mods... check that the entry still obeys the schema */\n    if (slapi_entry_schema_check(pb, ecc) != 0) {\n        char *errtext;\n\n        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &errtext);\n        if (errtext) {\n            PL_strncpyz(returntext, errtext, sizeof(returntext));\n        }\n        returncode = LDAP_OBJECT_CLASS_VIOLATION;\n        retval = -1;\n        goto done;\n    }\n\n    /* Check if the attribute values in the mods obey the syntaxes */\n    if (slapi_mods_syntax_check(pb, mods, 0) != 0) {\n        char *errtext;\n\n        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &errtext);\n        if (errtext) {\n            PL_strncpyz(returntext, errtext, sizeof(returntext));\n        }\n        returncode = LDAP_INVALID_SYNTAX;\n        retval = -1;\n        goto done;\n    }\n\n    /* Change the entry itself both on disk and in the AVL tree */\n    /* dse_replace_entry free's the existing entry. */\n    if (dse_replace_entry(pdse, ecc, !dont_write_file, DSE_USE_LOCK) != 0) {\n        returncode = LDAP_OPERATIONS_ERROR;\n        retval = -1;\n        goto done;\n    }\n    retval = 0;                                                      /* so far, so good */\n    slapi_pblock_set(pb, SLAPI_ENTRY_POST_OP, slapi_entry_dup(ecc)); /* JCM - When does this get free'd? */\n    /* richm - it is freed in modify.c */\n    /* give the dse callbacks the first crack at the modify */\n    rc = dse_call_callback(pdse, pb, SLAPI_OPERATION_MODIFY, DSE_FLAG_POSTOP, ec, ecc, &returncode, returntext);\ndone:\n    if (rc != SLAPI_DSE_CALLBACK_DO_NOT_APPLY) {\n        /* make sure OPRETURN is set */\n        slapi_pblock_get(pb, SLAPI_PLUGIN_OPRETURN, &err);\n        if ((retval || returncode) && !err) {\n            slapi_pblock_set(pb, SLAPI_PLUGIN_OPRETURN, retval ? &retval : &returncode);\n        }\n        /* next, give the betxn plugins a crack at it */\n        slapi_pblock_set(pb, SLAPI_RESULT_CODE, &returncode);\n        slapi_pblock_set(pb, SLAPI_MODIFY_EXISTING_ENTRY, ecc);\n        if (need_be_postop) {\n            plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_POST_MODIFY_FN);\n            if (!returncode) {\n                slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n            }\n            if (returncode && !returntext[0]) {\n                char *ldap_result_message = NULL;\n                slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);\n                if (ldap_result_message && ldap_result_message[0]) {\n                    PL_strncpyz(returntext, ldap_result_message, sizeof(returntext));\n                }\n            }\n\n            plugin_call_plugins(pb, SLAPI_PLUGIN_BE_POST_MODIFY_FN);\n            if (!returncode) {\n                slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n            }\n        }\n    } else {\n        /* It should not happen but just be paranoiac, do not\n         * forget to call the postop if needed\n         */\n        if (need_be_postop) {\n            plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_POST_MODIFY_FN);\n            if (!returncode) {\n                slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n            }\n\n            plugin_call_plugins(pb, SLAPI_PLUGIN_BE_POST_MODIFY_FN);\n            if (!returncode) {\n                slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n            }\n        }\n    }\n\n    /* time to restore original mods */\n    if (original_mods) {\n        LDAPMod **mods_from_callback;\n        slapi_pblock_get(pb, SLAPI_MODIFY_MODS, &mods_from_callback);\n        ldap_mods_free(mods_from_callback, 1 /* Free the Array and the Elements */);\n        slapi_pblock_set(pb, SLAPI_MODIFY_MODS, original_mods);\n    }\n    if (global_lock_owned) {\n        global_backend_lock_unlock();\n    }\n    slapi_send_ldap_result(pb, returncode, NULL, returntext[0] ? returntext : NULL, 0, NULL);\n\n    return dse_modify_return(retval, ec, ecc);\n}\n\nstatic int\ndse_pre_modify_plugin(Slapi_Entry *entryBefore, Slapi_Entry *entryAfter, LDAPMod **mods)\n{\n    const char *enabled = NULL;\n    int restart_plugin = 1;\n    int rc = 0;\n    int i;\n\n    /*\n     * Only check the mods if the plugin is enabled - no need to restart a plugin if it's not running.\n     */\n    if ((enabled = slapi_entry_attr_get_ref(entryBefore, ATTR_PLUGIN_ENABLED)) &&\n        !strcasecmp(enabled, \"on\")) {\n        for (i = 0; mods && mods[i]; i++) {\n            if (strcasecmp(mods[i]->mod_type, ATTR_PLUGIN_ENABLED) == 0) {\n                /* we already stop/started the pugin - don't do it again */\n                restart_plugin = 0;\n                break;\n            }\n        }\n        if (restart_plugin) { /* for all other plugin config changes, restart the plugin */\n            if (plugin_restart(entryBefore, entryAfter) != LDAP_SUCCESS) {\n                slapi_log_err(SLAPI_LOG_ERR, \"dse_pre_modify_plugin\",\n                              \"The configuration change for plugin (%s) could not be applied.\\n\",\n                              slapi_entry_get_dn(entryBefore));\n                rc = -1;\n            }\n        }\n    }\n    return rc;\n}\n\n/*\n * If this is modifying a plugin, check if we are disabling/enabling it - update the\n * global plugins as needed.\n *\n * Return 1 if the plugin was successfully started\n * Return 2 if the plugin was successfully stopped\n * Return -1 on error\n * Return 0 if nothing was done\n */\nstatic int\ndse_modify_plugin(Slapi_Entry *pre_entry, Slapi_Entry *post_entry, char *returntext)\n{\n    int rc = LDAP_SUCCESS;\n\n    if (slapi_entry_attr_hasvalue(pre_entry, \"nsslapd-pluginEnabled\", \"on\") &&\n        slapi_entry_attr_hasvalue(post_entry, \"nsslapd-pluginEnabled\", \"off\")) {\n        /*\n         * Plugin has been disabled\n         */\n        if (plugin_delete(post_entry, returntext, 0 /* not locked */)) {\n            rc = -1;\n        } else {\n            rc = 2; /* plugin disabled */\n            slapi_log_err(SLAPI_LOG_PLUGIN, \"dse_modify_plugin\", \"Disabled plugin (%s)\\n\",\n                          slapi_entry_get_dn(post_entry));\n        }\n    } else if (slapi_entry_attr_hasvalue(pre_entry, \"nsslapd-pluginEnabled\", \"off\") &&\n               slapi_entry_attr_hasvalue(post_entry, \"nsslapd-pluginEnabled\", \"on\")) {\n        /*\n         * Plugin has been enabled\n         */\n        if (plugin_add(post_entry, returntext, 0 /* not locked */)) {\n            rc = -1;\n        } else {\n            rc = 1; /* plugin started */\n            slapi_log_err(SLAPI_LOG_PLUGIN, \"dse_modify_plugin\", \"Enabled plugin (%s)\\n\",\n                          slapi_entry_get_dn(post_entry));\n        }\n    }\n\n    return rc;\n}\n\n/*\n * Add the plugin to the global plugin list\n */\nstatic int\ndse_add_plugin(Slapi_Entry *entry, char *returntext)\n{\n    int rc = LDAP_SUCCESS;\n\n    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, \"nsSlapdPlugin\") ||\n        !config_get_dynamic_plugins()) {\n        /*\n         * This is not a plugin, or we are not allowing dynamic updates.\n         */\n        return rc;\n    }\n    rc = plugin_add(entry, returntext, 0 /* not locked */);\n\n    return rc;\n}\n\n/*\n * Delete the plugin from the global plugin list\n */\nstatic int\ndse_delete_plugin(Slapi_Entry *entry, char *returntext)\n{\n    int rc = LDAP_SUCCESS;\n\n    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, \"nsSlapdPlugin\") ||\n        slapi_entry_attr_hasvalue(entry, \"nsslapd-PluginEnabled\", \"off\") ||\n        !config_get_dynamic_plugins()) {\n        /*\n         * This is not a plugin, this plugin was not enabled to begin with, or we\n         * are not allowing dynamic updates .\n         */\n        return rc;\n    }\n    rc = plugin_delete(entry, returntext, 0 /* not locked */);\n\n    return rc;\n}\n\nstatic int\ndse_add_return(int rv, Slapi_Entry *e)\n{\n    slapi_entry_free(e);\n    return rv;\n}\n\n/*\n * -1 means something went wrong.\n * 0 means everything went ok.\n */\nint\ndse_add(Slapi_PBlock *pb) /* JCM There should only be one exit point from this function! */\n{\n    Slapi_Entry *e = NULL;      /*The new entry to add*/\n    Slapi_Entry *e_copy = NULL; /* copy of added entry */\n    char *errbuf = NULL;\n    int rc = LDAP_SUCCESS;\n    int error = -1;\n    int dont_write_file = 0; /* default */\n    struct dse *pdse;\n    int returncode = LDAP_SUCCESS;\n    char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = \"\";\n    Slapi_DN *sdn = NULL;\n    Slapi_DN parent;\n    int need_be_postop = 0;\n    PRBool global_lock_owned = PR_FALSE;\n\n    /*\n     * Get the database, the dn and the entry to add\n     */\n    if (slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse) < 0 ||\n        slapi_pblock_get(pb, SLAPI_ADD_TARGET_SDN, &sdn) < 0 ||\n        slapi_pblock_get(pb, SLAPI_ADD_ENTRY, &e) < 0 || (NULL == pdse)) {\n        rc = LDAP_OPERATIONS_ERROR;\n        goto done;\n    }\n\n    slapi_pblock_get(pb, SLAPI_DSE_DONT_WRITE_WHEN_ADDING, &dont_write_file);\n    if (!dont_write_file && dse_check_for_readonly_error(pb, pdse)) {\n        return (error); /* result already sent */\n    }\n\n    /*\n     * Check to make sure the entry passes the schema check\n     */\n    if (slapi_entry_schema_check(pb, e) != 0) {\n        char *errtext;\n        slapi_log_err(SLAPI_DSE_TRACELEVEL,\n                      \"dse_add\", \"entry failed schema check\\n\");\n        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &errtext);\n        if (errtext && errtext[0]) {\n            PL_strncpyz(returntext, errtext, sizeof(returntext));\n        }\n        rc = LDAP_OBJECT_CLASS_VIOLATION;\n        e = NULL; /* caller will free upon error */\n        goto done;\n    }\n\n    /* Check if the attribute values in the entry obey the syntaxes */\n    if (slapi_entry_syntax_check(pb, e, 0) != 0) {\n        char *errtext;\n        slapi_log_err(SLAPI_DSE_TRACELEVEL,\n                      \"dse_add\", \"entry failed syntax check\\n\");\n        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &errtext);\n        if (errtext && errtext[0]) {\n            PL_strncpyz(returntext, errtext, sizeof(returntext));\n        }\n        rc = LDAP_INVALID_SYNTAX;\n        e = NULL; /* caller will free upon error */\n        goto done;\n    }\n\n    /*\n     * Attempt to find this dn.\n     */\n    {\n        Slapi_Entry *existingentry = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n        if (existingentry != NULL) {\n            /*\n             * If we've reached this code, there is an entry\n             * whose dn matches dn, so tell the user and return\n             */\n            slapi_entry_free(existingentry);\n            rc = LDAP_ALREADY_EXISTS;\n            e = NULL; /* caller will free upon error */\n            goto done;\n        }\n    }\n\n    /*\n     * Get the parent dn and see if the corresponding entry exists.\n     * If the parent does not exist, only allow the \"root\" user to\n     * add the entry.\n     */\n    slapi_sdn_init(&parent);\n    slapi_sdn_get_parent(sdn, &parent);\n    if (!slapi_sdn_isempty(&parent)) {\n        Slapi_Entry *parententry = NULL;\n        parententry = dse_get_entry_copy(pdse, &parent, DSE_USE_LOCK);\n        if (parententry == NULL) {\n            rc = LDAP_NO_SUCH_OBJECT;\n            slapi_log_err(SLAPI_DSE_TRACELEVEL, \" dse_add\", \"Narent does not exist\\n\");\n            slapi_sdn_done(&parent);\n            e = NULL; /* caller will free upon error */\n            goto done;\n        }\n        rc = plugin_call_acl_plugin(pb, parententry, NULL, NULL, SLAPI_ACL_ADD, ACLPLUGIN_ACCESS_DEFAULT, &errbuf);\n        slapi_entry_free(parententry);\n        if (rc != LDAP_SUCCESS) {\n            slapi_log_err(SLAPI_DSE_TRACELEVEL, \"dse_add\", \"No access to parent\\n\");\n            if (errbuf && errbuf[0]) {\n                PL_strncpyz(returntext, errbuf, sizeof(returntext));\n            }\n            slapi_ch_free_string(&errbuf);\n            slapi_sdn_done(&parent);\n            e = NULL; /* caller will free upon error */\n            goto done;\n        }\n    } else {\n        /* no parent */\n        int isroot;\n        slapi_pblock_get(pb, SLAPI_REQUESTOR_ISROOT, &isroot);\n        if (!isroot) {\n            slapi_log_err(SLAPI_DSE_TRACELEVEL, \"dse_add\", \"No parent and not root\\n\");\n            rc = LDAP_INSUFFICIENT_ACCESS;\n            slapi_sdn_done(&parent);\n            e = NULL; /* caller will free upon error */\n            goto done;\n        }\n    }\n    slapi_sdn_done(&parent);\n\n    /*\n     * Before we add the entry, find out if the syntax of the aci\n     * aci attribute values are correct or not. We don't want to add\n     * the entry if the syntax is incorrect.\n     */\n    if (plugin_call_acl_verify_syntax(pb, e, &errbuf) != 0) {\n        if (errbuf && errbuf[0]) {\n            PL_strncpyz(returntext, errbuf, sizeof(returntext));\n            slapi_ch_free_string(&errbuf);\n        }\n        rc = LDAP_INVALID_SYNTAX;\n        e = NULL; /* caller will free upon error */\n        goto done;\n    }\n\n    /* Possibly acquire the global backend lock */\n    if (global_backend_lock_requested()) {\n        global_backend_lock_lock();\n        global_lock_owned = PR_TRUE;\n    }\n\n    if (dse_call_callback(pdse, pb, SLAPI_OPERATION_ADD, DSE_FLAG_PREOP, e,\n                          NULL, &returncode, returntext) != SLAPI_DSE_CALLBACK_OK) {\n        if (!returncode) {\n            slapi_log_err(SLAPI_LOG_ERR, \"dse_add\",\n                          \"DSE PREOP callback returned error but did not set returncode\\n\");\n            returncode = LDAP_OPERATIONS_ERROR;\n        }\n        rc = returncode;\n        e = NULL; /* caller will free upon error */\n        goto done;\n    }\n    /* next, give the be plugins a crack at it */\n    slapi_pblock_set(pb, SLAPI_RESULT_CODE, &returncode);\n    plugin_call_plugins(pb, SLAPI_PLUGIN_BE_PRE_ADD_FN);\n    need_be_postop = 1; /* have to call be postops now */\n    if (!returncode) {\n        slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n    }\n    if (!returncode) {\n        /* finally, give the betxn plugins a crack at it */\n        plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_PRE_ADD_FN);\n        if (!returncode) {\n            slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n        }\n    }\n    if (returncode) {\n        if (!returntext[0]) {\n            char *ldap_result_message = NULL;\n            slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);\n            if (ldap_result_message && ldap_result_message[0]) {\n                PL_strncpyz(returntext, ldap_result_message, sizeof(returntext));\n            }\n        }\n        rc = returncode;\n        e = NULL; /* caller will free upon error */\n        goto done;\n    }\n    /*\n     * Check if we are adding a plugin\n     */\n    if (dse_add_plugin(e, returntext)) {\n        returncode = LDAP_UNWILLING_TO_PERFORM;\n        goto done;\n    }\n\n    /* make copy for postop fns because add_entry_pb consumes the given entry */\n    e_copy = slapi_entry_dup(e);\n    if (dse_add_entry_pb(pdse, e_copy, pb) != 0) {\n        rc = LDAP_OPERATIONS_ERROR;\n        e = NULL; /* caller will free upon error */\n        goto done;\n    }\n    /* The postop must be called after the write lock is released. */\n    dse_call_callback(pdse, pb, SLAPI_OPERATION_ADD, DSE_FLAG_POSTOP, e, NULL, &returncode, returntext);\ndone:\n    if (e) {\n        slapi_pblock_set(pb, SLAPI_ENTRY_POST_OP, slapi_entry_dup(e));\n    }\n\n    /* make sure OPRETURN and RESULT_CODE are set */\n    slapi_pblock_get(pb, SLAPI_PLUGIN_OPRETURN, &error);\n    if (rc || returncode) {\n        if (!error) {\n            slapi_pblock_set(pb, SLAPI_PLUGIN_OPRETURN, rc ? &rc : &returncode);\n        }\n        if (!returncode) {\n            returncode = rc;\n        }\n    }\n    if (need_be_postop) {\n        /* next, give the be txn plugins a crack at it */\n        slapi_pblock_set(pb, SLAPI_RESULT_CODE, &returncode);\n        plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_POST_ADD_FN);\n\n        /* finally, give the be plugins a crack at it */\n        plugin_call_plugins(pb, SLAPI_PLUGIN_BE_POST_ADD_FN);\n        if (!returncode) {\n            slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n        }\n    }\n    if (global_lock_owned) {\n        global_backend_lock_unlock();\n    }\n    slapi_send_ldap_result(pb, returncode, NULL, returntext[0] ? returntext : NULL, 0, NULL);\n    return dse_add_return(rc, e);\n}\n\n/*\n * -1 means something went wrong.\n * 0 means everything went ok.\n */\n\nstatic int\ndse_delete_return(int rv, Slapi_Entry *ec)\n{\n    slapi_entry_free(ec);\n    return rv;\n}\n\nint\ndse_delete(Slapi_PBlock *pb) /* JCM There should only be one exit point from this function! */\n{\n    int rc = -1;\n    int dont_write_file = 0; /* default */\n    struct dse *pdse = NULL;\n    int returncode = LDAP_SUCCESS;\n    char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = \"\";\n    char *entry_str = \"entry\";\n    char *errbuf = NULL;\n    char *attrs[2] = {NULL, NULL};\n    Slapi_DN *sdn = NULL;\n    Slapi_Entry *ec = NULL; /* copy of entry to delete */\n    Slapi_Entry *orig_entry = NULL;\n    int need_be_postop = 0;\n    PRBool global_lock_owned = PR_FALSE;\n\n    /*\n     * Get the database and the dn\n     */\n    if (slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse) < 0 ||\n        slapi_pblock_get(pb, SLAPI_DELETE_TARGET_SDN, &sdn) < 0 ||\n        (pdse == NULL)) {\n        returncode = LDAP_OPERATIONS_ERROR;\n        goto done;\n    }\n\n    slapi_pblock_get(pb, SLAPI_DSE_DONT_WRITE_WHEN_ADDING, &dont_write_file);\n    if (!dont_write_file && dse_check_for_readonly_error(pb, pdse)) {\n        return (rc); /* result already sent */\n    }\n\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        returncode = LDAP_NO_SUCH_OBJECT;\n        goto done;\n    }\n\n    /*\n     * Check if this node has any children.\n     */\n    if (dse_numsubordinates(ec) > 0) {\n        returncode = LDAP_NOT_ALLOWED_ON_NONLEAF;\n        goto done;\n    }\n\n    /*\n     * Check the access\n     */\n    attrs[0] = entry_str;\n    attrs[1] = NULL;\n    returncode = plugin_call_acl_plugin(pb, ec, attrs, NULL, SLAPI_ACL_DELETE, ACLPLUGIN_ACCESS_DEFAULT, &errbuf);\n    if (returncode != LDAP_SUCCESS) {\n        if (errbuf && errbuf[0]) {\n            PL_strncpyz(returntext, errbuf, sizeof(returntext));\n        }\n        slapi_ch_free_string(&errbuf);\n        goto done;\n    }\n\n    /* Possibly acquire the global backend lock */\n    if (global_backend_lock_requested()) {\n        global_backend_lock_lock();\n        global_lock_owned = PR_TRUE;\n    }\n\n    if (dse_call_callback(pdse, pb, SLAPI_OPERATION_DELETE, DSE_FLAG_PREOP, ec, NULL, &returncode, returntext) == SLAPI_DSE_CALLBACK_OK) {\n        slapi_pblock_set(pb, SLAPI_DELETE_BEPREOP_ENTRY, ec);\n        slapi_pblock_set(pb, SLAPI_RESULT_CODE, &returncode);\n        plugin_call_plugins(pb, SLAPI_PLUGIN_BE_PRE_DELETE_FN);\n        need_be_postop = 1;\n        if (!returncode) {\n            slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n        }\n        if (!returncode) {\n            plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_PRE_DELETE_FN);\n            if (!returncode) {\n                slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n            }\n            if (!returncode) {\n                if (dse_delete_entry(pdse, pb, ec) == 0) {\n                    returncode = LDAP_OPERATIONS_ERROR;\n                }\n            }\n        }\n        /* Setting SLAPI_ENTRY_PRE_OP here,\n         * since some betxn postop may need the pre op entry. */\n        slapi_pblock_set(pb, SLAPI_ENTRY_PRE_OP, slapi_entry_dup(ec));\n    } else {\n        goto done;\n    }\n\n    dse_call_callback(pdse, pb, SLAPI_OPERATION_DELETE, DSE_FLAG_POSTOP, ec, NULL, &returncode, returntext);\ndone:\n    slapi_pblock_get(pb, SLAPI_DELETE_BEPOSTOP_ENTRY, &orig_entry);\n    slapi_pblock_set(pb, SLAPI_DELETE_BEPOSTOP_ENTRY, ec);\n    /* make sure OPRETURN and RESULT_CODE are set */\n    slapi_pblock_get(pb, SLAPI_PLUGIN_OPRETURN, &rc);\n    if (returncode || rc) {\n        if (!rc) {\n            slapi_pblock_set(pb, SLAPI_PLUGIN_OPRETURN, &returncode);\n        }\n        if (!returncode) {\n            returncode = rc;\n        }\n    }\n    if (need_be_postop) {\n        plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_POST_DELETE_FN);\n        if (!returncode) {\n            slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n        }\n\n        /* finally, give the be plugins a crack at it */\n        plugin_call_plugins(pb, SLAPI_PLUGIN_BE_POST_DELETE_FN);\n        if (!returncode) {\n            slapi_pblock_get(pb, SLAPI_RESULT_CODE, &returncode);\n        }\n    }\n    if (global_lock_owned) {\n        global_backend_lock_unlock();\n    }\n    if (returncode && !returntext[0]) {\n        char *ldap_result_message = NULL;\n        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);\n        if (ldap_result_message && ldap_result_message[0]) {\n            PL_strncpyz(returntext, ldap_result_message, sizeof(returntext));\n        }\n    }\n    /*\n     * Check if we are deleting a plugin\n     */\n    if (returncode == LDAP_SUCCESS) {\n        if (dse_delete_plugin(ec, returntext)) {\n            rc = LDAP_UNWILLING_TO_PERFORM;\n        }\n    }\n    slapi_pblock_set(pb, SLAPI_DELETE_BEPOSTOP_ENTRY, orig_entry);\n    slapi_send_ldap_result(pb, returncode, NULL, returntext, 0, NULL);\n    return dse_delete_return(returncode, ec);\n}\n\nstruct dse_callback *\ndse_register_callback(struct dse *pdse,\n                      int operation,\n                      int flags,\n                      const Slapi_DN *base,\n                      int scope,\n                      const char *filter,\n                      dseCallbackFn fn,\n                      void *fn_arg,\n                      struct slapdplugin *plugin)\n{\n    struct dse_callback *callback = dse_callback_new(operation, flags, base, scope, filter, fn, fn_arg, plugin);\n    dse_callback_addtolist(&pdse->dse_callback, callback);\n    return callback;\n}\n\nvoid\ndse_remove_callback(struct dse *pdse, int operation, int flags, const Slapi_DN *base, int scope, const char *filter, dseCallbackFn fn)\n{\n    dse_callback_removefromlist(&pdse->dse_callback, operation, flags, base, scope, filter, fn);\n}\n\n/*\n * Return values:\n *    SLAPI_DSE_CALLBACK_ERROR        -- Callback failed.\n *  SLAPI_DSE_CALLBACK_OK           -- OK, do it.\n *  SLAPI_DSE_CALLBACK_DO_NOT_APPLY -- No error, but don't apply changes.\n */\nstatic int\ndse_call_callback(struct dse *pdse, Slapi_PBlock *pb, int operation, int flags, Slapi_Entry *entryBefore, Slapi_Entry *entryAfter, int *returncode, char *returntext)\n{\n    /* ONREPL callbacks can potentially modify pblock parameters like backend\n     * which would cause problems during request processing. We need to save\n     * \"important\" fields before calls and restoring them afterwards */\n    int rc = SLAPI_DSE_CALLBACK_OK;\n\n    if (pdse->dse_callback != NULL) {\n        struct dse_callback *p = pdse->dse_callback;\n        struct dse_callback *next = NULL;\n        int result = SLAPI_DSE_CALLBACK_OK;\n\n        while (p != NULL) {\n            next = p->next;\n            if ((p->operation & operation) && (p->flags & flags)) {\n                if (slapi_sdn_scope_test(slapi_entry_get_sdn_const(entryBefore), p->base, p->scope)) {\n                    if (NULL == p->slapifilter || slapi_vattr_filter_test(pb, entryBefore, p->slapifilter, 0) == 0) {\n                        struct slapdplugin *plugin = p->plugin;\n                        int plugin_started = 1;\n\n                        if (plugin) {\n                            /* this is a plugin callback, update the operation counter */\n                            slapi_plugin_op_started(plugin);\n                            if (!plugin->plg_started) {\n                                /* must be a task function being called */\n                                result = SLAPI_DSE_CALLBACK_ERROR;\n                                PR_snprintf(returntext, SLAPI_DSE_RETURNTEXT_SIZE,\n                                            \"Task entry (%s) could not added because the (%s) plugin is disabled.\",\n                                            slapi_entry_get_dn(entryBefore), p->plugin->plg_dn);\n                                plugin_started = 0;\n                            }\n                        }\n                        if (plugin_started) {\n                            result = (*p->fn)(pb, entryBefore, entryAfter, returncode, returntext, p->fn_arg);\n                        }\n                        if (result < rc) {\n                            rc = result;\n                        }\n                        slapi_plugin_op_finished(plugin);\n                    }\n                }\n            }\n            p = next;\n        }\n    }\n    return rc;\n}\n\nint\nslapi_config_register_callback(int operation,\n                               int flags,\n                               const char *base,\n                               int scope,\n                               const char *filter,\n                               dseCallbackFn fn,\n                               void *fn_arg)\n{\n    return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);\n}\n\n/*\n *  We pass in the pblock so we can update the operation counter for \"dynamic plugins\".\n */\nint\nslapi_config_register_callback_plugin(int operation,\n                                      int flags,\n                                      const char *base,\n                                      int scope,\n                                      const char *filter,\n                                      dseCallbackFn fn,\n                                      void *fn_arg,\n                                      Slapi_PBlock *pb)\n{\n    int rc = 0;\n    Slapi_Backend *be = slapi_be_select_by_instance_name(DSE_BACKEND);\n    if (be != NULL) {\n        struct dse *pdse = (struct dse *)be->be_database->plg_private;\n        if (pdse != NULL) {\n            Slapi_DN dn;\n            slapi_sdn_init_dn_byref(&dn, base);\n            if (pb != NULL) {\n                /* if a pblock was passed, this is a plugin, so set the f_arg as the plugin */\n                struct slapdplugin *pb_plugin = NULL;\n                slapi_pblock_get(pb, SLAPI_PLUGIN, &pb_plugin);\n                rc = (NULL != dse_register_callback(pdse, operation, flags, &dn, scope, filter, fn,\n                                                    (void *)pb_plugin, pb_plugin));\n            } else {\n                rc = (NULL != dse_register_callback(pdse, operation, flags, &dn, scope, filter, fn,\n                                                    fn_arg, NULL));\n            }\n\n            slapi_sdn_done(&dn);\n        }\n    }\n    return rc;\n}\n\n\nint\nslapi_config_remove_callback(int operation, int flags, const char *base, int scope, const char *filter, dseCallbackFn fn)\n{\n    int rc = 0;\n    Slapi_Backend *be = slapi_be_select_by_instance_name(DSE_BACKEND);\n    if (be != NULL) {\n        struct dse *pdse = (struct dse *)be->be_database->plg_private;\n        if (pdse != NULL) {\n            Slapi_DN dn;\n            slapi_sdn_init_dn_byref(&dn, base);\n            dse_remove_callback(pdse, operation, flags, &dn, scope, filter, fn);\n            slapi_sdn_done(&dn);\n            rc = 1;\n        }\n    }\n    return rc;\n}\n\nvoid\ndse_set_dont_ever_write_dse_files()\n{\n    dont_ever_write_dse_files = 1;\n}\n\nvoid\ndse_unset_dont_ever_write_dse_files()\n{\n    dont_ever_write_dse_files = 0;\n}\n\nstatic dse_search_set *\ndse_search_set_new(void)\n{\n    dse_search_set *ss;\n\n    ss = (dse_search_set *)slapi_ch_malloc(sizeof(*ss));\n\n    if (ss) {\n        dl_init(&ss->dl, 0);\n        ss->current_entry = -1;\n    }\n\n    return ss;\n}\n\n/* This is similar to delete, but it does not free the entries contained in the\n   search set.  This is useful in do_dse_search when we copy the entries from\n   1 search set to the other. */\nstatic void\ndse_search_set_clean(dse_search_set *ss)\n{\n    if (ss) {\n        dl_cleanup(&ss->dl, NULL);\n        slapi_ch_free((void **)&ss);\n    }\n}\n\nvoid\ndse_search_set_release(void **ss)\n{\n    dse_search_set_delete(*(dse_search_set **)ss);\n}\n\nvoid\ndse_prev_search_results(void *vp)\n{\n    Slapi_PBlock *pb = (Slapi_PBlock *)vp;\n    dse_search_set *ss;\n    slapi_pblock_get(pb, SLAPI_SEARCH_RESULT_SET, &ss);\n    if (ss) {\n        dl_get_prev(&ss->dl, &ss->current_entry);\n    }\n}\n\nstatic void\ndse_search_set_delete(dse_search_set *ss)\n{\n    if (ss) {\n        dl_cleanup(&ss->dl, dse_free_entry);\n        slapi_ch_free((void **)&ss);\n    }\n}\n\nstatic void\ndse_free_entry(void **data)\n{\n    Slapi_Entry **e;\n\n    if (data) {\n        e = (Slapi_Entry **)data;\n        if (*e)\n            slapi_entry_free(*e);\n    }\n}\n\nstatic void\ndse_search_set_add_entry(dse_search_set *ss, Slapi_Entry *e)\n{\n    PR_ASSERT(ss && e);\n\n    dl_add(&ss->dl, e);\n}\n\nstatic Slapi_Entry *\ndse_search_set_get_next_entry(dse_search_set *ss)\n{\n    PR_ASSERT(ss);\n\n    if (ss->current_entry == -1)\n        return (dl_get_first(&ss->dl, &ss->current_entry));\n    else\n        return (dl_get_next(&ss->dl, &ss->current_entry));\n}\n\nint\ndse_next_search_entry(Slapi_PBlock *pb)\n{\n    dse_search_set *ss;\n    Slapi_Entry *e;\n\n    slapi_pblock_get(pb, SLAPI_SEARCH_RESULT_SET, &ss);\n\n    /* no entries to return */\n    if (ss == NULL) {\n        slapi_pblock_set(pb, SLAPI_SEARCH_RESULT_ENTRY, NULL);\n        return 0;\n    }\n\n    e = dse_search_set_get_next_entry(ss);\n    slapi_pblock_set(pb, SLAPI_SEARCH_RESULT_ENTRY, e);\n\n    /* we reached the end of the list */\n    if (e == NULL) {\n        pagedresults_set_search_result_pb(pb, NULL, 0);\n        dse_search_set_delete(ss);\n        slapi_pblock_set(pb, SLAPI_SEARCH_RESULT_SET, NULL);\n    }\n\n    return 0;\n}\n"], "buggy_code_start_loc": [12, 79, 1449], "buggy_code_end_loc": [1096, 81, 1464], "fixing_code_start_loc": [12, 79, 1449], "fixing_code_end_loc": [1130, 81, 1468], "type": "CWE-203", "message": "When binding against a DN during authentication, the reply from 389-ds-base will be different whether the DN exists or not. This can be used by an unauthenticated attacker to check the existence of an entry in the LDAP database.", "other": {"cve": {"id": "CVE-2020-35518", "sourceIdentifier": "secalert@redhat.com", "published": "2021-03-26T17:15:12.280", "lastModified": "2022-08-05T17:42:42.370", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "When binding against a DN during authentication, the reply from 389-ds-base will be different whether the DN exists or not. This can be used by an unauthenticated attacker to check the existence of an entry in the LDAP database."}, {"lang": "es", "value": "Cuando se vincula con un DN durante la autenticaci\u00f3n, la respuesta de 389-ds-base ser\u00e1 diferente si el DN se presenta o no. Esto puede ser usado por un atacante no autenticado para comprobar la existencia de una entrada en la base de datos de LDAP."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:389_directory_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.3.19", "matchCriteriaId": "826F6485-30A1-49A6-8E66-4F53DAD03EDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:389_directory_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.4.4.0", "versionEndExcluding": "1.4.4.13", "matchCriteriaId": "7273B979-C446-45CA-A601-9F81F6DA503C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:389_directory_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.3", "matchCriteriaId": "72D21DC8-ED0C-4C96-A9CF-0EE1E3EBD7F9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:directory_server:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "2A169F6D-88A5-4631-9D30-519350ACFE6E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1905565", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/389ds/389-ds-base/commit/b6aae4d8e7c8a6ddd21646f94fef1bf7f22c3f32", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/389ds/389-ds-base/commit/cc0f69283abc082488824702dae485b8eae938bc", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/389ds/389-ds-base/issues/4480", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/389ds/389-ds-base/commit/b6aae4d8e7c8a6ddd21646f94fef1bf7f22c3f32"}}